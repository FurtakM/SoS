// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 684 0 0
// InitMacro ;
  19: CALL 56039 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 48912 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 48912 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 48912 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 48912 0 9
// PrepareArabian ;
 168: CALL 3958 0 0
// PrepareRussian ;
 172: CALL 2929 0 0
// PrepareAlliance ;
 176: CALL 894 0 0
// MC_Start ( ) ;
 180: CALL 58204 0 0
// if debug then
 184: LD_EXP 1
 188: IFFALSE 197
// FogOff ( 1 ) ;
 190: LD_INT 1
 192: PPUSH
 193: CALL_OW 344
// Action ;
 197: CALL 7316 0 0
// end ;
 201: END
// export function CustomInitMacro ; var i ; begin
 202: LD_INT 0
 204: PPUSH
 205: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 206: LD_ADDR_EXP 84
 210: PUSH
 211: LD_INT 1
 213: PUSH
 214: LD_INT 2
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 221: LD_ADDR_EXP 85
 225: PUSH
 226: LD_INT 3
 228: PUSH
 229: LD_INT 4
 231: PUSH
 232: EMPTY
 233: LIST
 234: LIST
 235: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 236: LD_INT 1
 238: PPUSH
 239: LD_INT 12
 241: PUSH
 242: LD_INT 15
 244: PUSH
 245: LD_INT 18
 247: PUSH
 248: LD_INT 20
 250: PUSH
 251: EMPTY
 252: LIST
 253: LIST
 254: LIST
 255: LIST
 256: PUSH
 257: LD_OWVAR 67
 261: ARRAY
 262: PPUSH
 263: LD_INT 7
 265: PPUSH
 266: CALL 79889 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 270: LD_INT 1
 272: PPUSH
 273: LD_EXP 55
 277: PPUSH
 278: CALL 80315 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 282: LD_INT 1
 284: PPUSH
 285: LD_INT 6
 287: PPUSH
 288: CALL 80773 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 292: LD_INT 1
 294: PPUSH
 295: LD_INT 9
 297: PUSH
 298: EMPTY
 299: LIST
 300: PPUSH
 301: CALL 81042 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 13
 310: PUSH
 311: LD_INT 1
 313: PUSH
 314: LD_INT 2
 316: PUSH
 317: LD_INT 32
 319: PUSH
 320: EMPTY
 321: LIST
 322: LIST
 323: LIST
 324: LIST
 325: PUSH
 326: LD_INT 13
 328: PUSH
 329: LD_INT 1
 331: PUSH
 332: LD_INT 2
 334: PUSH
 335: LD_INT 88
 337: PUSH
 338: EMPTY
 339: LIST
 340: LIST
 341: LIST
 342: LIST
 343: PUSH
 344: EMPTY
 345: LIST
 346: LIST
 347: PPUSH
 348: CALL 80255 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 352: LD_INT 2
 354: PPUSH
 355: LD_INT 12
 357: PUSH
 358: LD_INT 14
 360: PUSH
 361: LD_INT 10
 363: PUSH
 364: LD_INT 11
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: LIST
 371: LIST
 372: PPUSH
 373: CALL 80949 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 377: LD_INT 2
 379: PPUSH
 380: LD_EXP 52
 384: PPUSH
 385: CALL 80315 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 389: LD_INT 2
 391: PPUSH
 392: LD_INT 8
 394: PPUSH
 395: CALL 80773 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 399: LD_INT 2
 401: PPUSH
 402: LD_INT 10
 404: PUSH
 405: EMPTY
 406: LIST
 407: PPUSH
 408: CALL 81042 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 412: LD_INT 2
 414: PPUSH
 415: LD_INT 6
 417: PUSH
 418: LD_INT 71
 420: PUSH
 421: LD_INT 116
 423: PUSH
 424: LD_INT 4
 426: PUSH
 427: EMPTY
 428: LIST
 429: LIST
 430: LIST
 431: LIST
 432: PUSH
 433: LD_INT 4
 435: PUSH
 436: LD_INT 85
 438: PUSH
 439: LD_INT 116
 441: PUSH
 442: LD_INT 4
 444: PUSH
 445: EMPTY
 446: LIST
 447: LIST
 448: LIST
 449: LIST
 450: PUSH
 451: LD_INT 32
 453: PUSH
 454: LD_INT 83
 456: PUSH
 457: LD_INT 111
 459: PUSH
 460: LD_INT 4
 462: PUSH
 463: EMPTY
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: PUSH
 469: LD_INT 32
 471: PUSH
 472: LD_INT 87
 474: PUSH
 475: LD_INT 121
 477: PUSH
 478: LD_INT 4
 480: PUSH
 481: EMPTY
 482: LIST
 483: LIST
 484: LIST
 485: LIST
 486: PUSH
 487: LD_INT 33
 489: PUSH
 490: LD_INT 88
 492: PUSH
 493: LD_INT 128
 495: PUSH
 496: LD_INT 4
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: PUSH
 505: LD_INT 32
 507: PUSH
 508: LD_INT 59
 510: PUSH
 511: LD_INT 89
 513: PUSH
 514: LD_INT 3
 516: PUSH
 517: EMPTY
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 33
 525: PUSH
 526: LD_INT 69
 528: PUSH
 529: LD_INT 98
 531: PUSH
 532: LD_INT 3
 534: PUSH
 535: EMPTY
 536: LIST
 537: LIST
 538: LIST
 539: LIST
 540: PUSH
 541: LD_INT 33
 543: PUSH
 544: LD_INT 77
 546: PUSH
 547: LD_INT 103
 549: PUSH
 550: LD_INT 3
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: PUSH
 559: LD_INT 33
 561: PUSH
 562: LD_INT 83
 564: PUSH
 565: LD_INT 105
 567: PUSH
 568: LD_INT 3
 570: PUSH
 571: EMPTY
 572: LIST
 573: LIST
 574: LIST
 575: LIST
 576: PUSH
 577: LD_INT 33
 579: PUSH
 580: LD_INT 71
 582: PUSH
 583: LD_INT 125
 585: PUSH
 586: LD_INT 5
 588: PUSH
 589: EMPTY
 590: LIST
 591: LIST
 592: LIST
 593: LIST
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: PPUSH
 607: CALL 80099 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 611: LD_INT 2
 613: PPUSH
 614: LD_INT 43
 616: PUSH
 617: LD_INT 47
 619: PUSH
 620: LD_INT 46
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: PPUSH
 628: CALL 81360 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 632: LD_INT 2
 634: PPUSH
 635: LD_INT 21
 637: PUSH
 638: LD_INT 1
 640: PUSH
 641: LD_INT 3
 643: PUSH
 644: LD_INT 51
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: LD_INT 22
 655: PUSH
 656: LD_INT 1
 658: PUSH
 659: LD_INT 3
 661: PUSH
 662: LD_INT 52
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: PPUSH
 675: CALL 80255 0 2
// end ;
 679: LD_VAR 0 1
 683: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 684: LD_INT 0
 686: PPUSH
// debug := false ;
 687: LD_ADDR_EXP 1
 691: PUSH
 692: LD_INT 0
 694: ST_TO_ADDR
// game := true ;
 695: LD_ADDR_EXP 2
 699: PUSH
 700: LD_INT 1
 702: ST_TO_ADDR
// gossudarov_arrive := false ;
 703: LD_ADDR_EXP 4
 707: PUSH
 708: LD_INT 0
 710: ST_TO_ADDR
// ru_lab_builded := false ;
 711: LD_ADDR_EXP 5
 715: PUSH
 716: LD_INT 0
 718: ST_TO_ADDR
// player_spotted := false ;
 719: LD_ADDR_EXP 6
 723: PUSH
 724: LD_INT 0
 726: ST_TO_ADDR
// first_attack := false ;
 727: LD_ADDR_EXP 7
 731: PUSH
 732: LD_INT 0
 734: ST_TO_ADDR
// ru_attackers := [ ] ;
 735: LD_ADDR_EXP 53
 739: PUSH
 740: EMPTY
 741: ST_TO_ADDR
// ar_base_spotted := false ;
 742: LD_ADDR_EXP 8
 746: PUSH
 747: LD_INT 0
 749: ST_TO_ADDR
// ar_active_attack := false ;
 750: LD_ADDR_EXP 9
 754: PUSH
 755: LD_INT 0
 757: ST_TO_ADDR
// ar_attackers := [ ] ;
 758: LD_ADDR_EXP 11
 762: PUSH
 763: EMPTY
 764: ST_TO_ADDR
// first_powell_attack := false ;
 765: LD_ADDR_EXP 12
 769: PUSH
 770: LD_INT 0
 772: ST_TO_ADDR
// masha_killed := false ;
 773: LD_ADDR_EXP 10
 777: PUSH
 778: LD_INT 0
 780: ST_TO_ADDR
// abdul_escaped := true ;
 781: LD_ADDR_EXP 13
 785: PUSH
 786: LD_INT 1
 788: ST_TO_ADDR
// loss_counter := 0 ;
 789: LD_ADDR_EXP 14
 793: PUSH
 794: LD_INT 0
 796: ST_TO_ADDR
// hack_counter := 0 ;
 797: LD_ADDR_EXP 15
 801: PUSH
 802: LD_INT 0
 804: ST_TO_ADDR
// end ;
 805: LD_VAR 0 1
 809: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 810: LD_EXP 49
 814: PPUSH
 815: CALL_OW 255
 819: PUSH
 820: LD_INT 7
 822: EQUAL
 823: PUSH
 824: LD_EXP 48
 828: PPUSH
 829: CALL_OW 255
 833: PUSH
 834: LD_INT 7
 836: EQUAL
 837: AND
 838: PUSH
 839: LD_EXP 49
 843: PPUSH
 844: CALL_OW 302
 848: AND
 849: PUSH
 850: LD_EXP 48
 854: PPUSH
 855: CALL_OW 302
 859: AND
 860: IFFALSE 872
 862: GO 864
 864: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 865: LD_STRING ACH_COMRADE
 867: PPUSH
 868: CALL_OW 543
 872: END
// every 0 0$1 trigger hack_counter >= 10 do
 873: LD_EXP 15
 877: PUSH
 878: LD_INT 10
 880: GREATEREQUAL
 881: IFFALSE 893
 883: GO 885
 885: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 886: LD_STRING ACH_HACK
 888: PPUSH
 889: CALL_OW 543
 893: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 894: LD_INT 0
 896: PPUSH
 897: PPUSH
 898: PPUSH
 899: PPUSH
// uc_side := 7 ;
 900: LD_ADDR_OWVAR 20
 904: PUSH
 905: LD_INT 7
 907: ST_TO_ADDR
// uc_nation := 1 ;
 908: LD_ADDR_OWVAR 21
 912: PUSH
 913: LD_INT 1
 915: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 916: LD_ADDR_EXP 16
 920: PUSH
 921: LD_STRING JMM
 923: PPUSH
 924: LD_EXP 1
 928: NOT
 929: PPUSH
 930: LD_STRING 12a_
 932: PPUSH
 933: CALL 14854 0 3
 937: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 938: LD_EXP 16
 942: PPUSH
 943: LD_INT 71
 945: PPUSH
 946: LD_INT 23
 948: PPUSH
 949: LD_INT 0
 951: PPUSH
 952: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 956: LD_EXP 16
 960: PPUSH
 961: LD_INT 2
 963: PPUSH
 964: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 968: LD_ADDR_EXP 17
 972: PUSH
 973: LD_STRING Roth
 975: PPUSH
 976: LD_EXP 1
 980: NOT
 981: PPUSH
 982: LD_STRING 12a_
 984: PPUSH
 985: CALL 14854 0 3
 989: ST_TO_ADDR
// if Roth then
 990: LD_EXP 17
 994: IFFALSE 1014
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 996: LD_EXP 17
1000: PPUSH
1001: LD_INT 71
1003: PPUSH
1004: LD_INT 21
1006: PPUSH
1007: LD_INT 0
1009: PPUSH
1010: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1014: LD_ADDR_EXP 18
1018: PUSH
1019: LD_STRING Lisa
1021: PPUSH
1022: LD_EXP 1
1026: NOT
1027: PPUSH
1028: LD_STRING 12a_
1030: PPUSH
1031: CALL 14854 0 3
1035: ST_TO_ADDR
// if Lisa then
1036: LD_EXP 18
1040: IFFALSE 1057
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1042: LD_EXP 18
1046: PPUSH
1047: LD_INT 13
1049: PPUSH
1050: LD_INT 0
1052: PPUSH
1053: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1057: LD_ADDR_EXP 19
1061: PUSH
1062: LD_STRING Donaldson
1064: PPUSH
1065: LD_EXP 1
1069: NOT
1070: PPUSH
1071: LD_STRING 12a_
1073: PPUSH
1074: CALL 14854 0 3
1078: ST_TO_ADDR
// if Donaldson then
1079: LD_EXP 19
1083: IFFALSE 1100
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1085: LD_EXP 19
1089: PPUSH
1090: LD_INT 13
1092: PPUSH
1093: LD_INT 0
1095: PPUSH
1096: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1100: LD_ADDR_EXP 20
1104: PUSH
1105: LD_STRING Bobby
1107: PPUSH
1108: LD_EXP 1
1112: NOT
1113: PPUSH
1114: LD_STRING 12a_
1116: PPUSH
1117: CALL 14854 0 3
1121: ST_TO_ADDR
// if Bobby then
1122: LD_EXP 20
1126: IFFALSE 1143
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1128: LD_EXP 20
1132: PPUSH
1133: LD_INT 13
1135: PPUSH
1136: LD_INT 0
1138: PPUSH
1139: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1143: LD_ADDR_EXP 21
1147: PUSH
1148: LD_STRING Cyrus
1150: PPUSH
1151: LD_EXP 1
1155: NOT
1156: PPUSH
1157: LD_STRING 12a_
1159: PPUSH
1160: CALL 14854 0 3
1164: ST_TO_ADDR
// if Cyrus then
1165: LD_EXP 21
1169: IFFALSE 1186
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1171: LD_EXP 21
1175: PPUSH
1176: LD_INT 13
1178: PPUSH
1179: LD_INT 0
1181: PPUSH
1182: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1186: LD_ADDR_EXP 22
1190: PUSH
1191: LD_STRING Denis
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: LD_STRING 12a_
1202: PPUSH
1203: CALL 14854 0 3
1207: ST_TO_ADDR
// if Denis then
1208: LD_EXP 22
1212: IFFALSE 1229
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1214: LD_EXP 22
1218: PPUSH
1219: LD_INT 13
1221: PPUSH
1222: LD_INT 0
1224: PPUSH
1225: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1229: LD_ADDR_EXP 23
1233: PUSH
1234: LD_STRING Brown
1236: PPUSH
1237: LD_EXP 1
1241: NOT
1242: PPUSH
1243: LD_STRING 12a_
1245: PPUSH
1246: CALL 14854 0 3
1250: ST_TO_ADDR
// if Brown then
1251: LD_EXP 23
1255: IFFALSE 1272
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1257: LD_EXP 23
1261: PPUSH
1262: LD_INT 13
1264: PPUSH
1265: LD_INT 0
1267: PPUSH
1268: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1272: LD_ADDR_EXP 24
1276: PUSH
1277: LD_STRING Gladstone
1279: PPUSH
1280: LD_EXP 1
1284: NOT
1285: PPUSH
1286: LD_STRING 12a_
1288: PPUSH
1289: CALL 14854 0 3
1293: ST_TO_ADDR
// if Gladstone then
1294: LD_EXP 24
1298: IFFALSE 1315
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1300: LD_EXP 24
1304: PPUSH
1305: LD_INT 13
1307: PPUSH
1308: LD_INT 0
1310: PPUSH
1311: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1315: LD_ADDR_EXP 25
1319: PUSH
1320: LD_STRING Houten
1322: PPUSH
1323: LD_EXP 1
1327: NOT
1328: PPUSH
1329: LD_STRING 12a_
1331: PPUSH
1332: CALL 14854 0 3
1336: ST_TO_ADDR
// if Houten then
1337: LD_EXP 25
1341: IFFALSE 1358
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1343: LD_EXP 25
1347: PPUSH
1348: LD_INT 13
1350: PPUSH
1351: LD_INT 0
1353: PPUSH
1354: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1358: LD_ADDR_EXP 26
1362: PUSH
1363: LD_STRING Cornell
1365: PPUSH
1366: LD_EXP 1
1370: NOT
1371: PPUSH
1372: LD_STRING 12a_
1374: PPUSH
1375: CALL 14854 0 3
1379: ST_TO_ADDR
// if Cornel then
1380: LD_EXP 26
1384: IFFALSE 1401
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1386: LD_EXP 26
1390: PPUSH
1391: LD_INT 13
1393: PPUSH
1394: LD_INT 0
1396: PPUSH
1397: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1401: LD_ADDR_EXP 27
1405: PUSH
1406: LD_STRING Gary
1408: PPUSH
1409: LD_EXP 1
1413: NOT
1414: PPUSH
1415: LD_STRING 12a_
1417: PPUSH
1418: CALL 14854 0 3
1422: ST_TO_ADDR
// if Gary then
1423: LD_EXP 27
1427: IFFALSE 1444
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1429: LD_EXP 27
1433: PPUSH
1434: LD_INT 13
1436: PPUSH
1437: LD_INT 0
1439: PPUSH
1440: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1444: LD_ADDR_EXP 28
1448: PUSH
1449: LD_STRING Frank
1451: PPUSH
1452: LD_EXP 1
1456: NOT
1457: PPUSH
1458: LD_STRING 12a_
1460: PPUSH
1461: CALL 14854 0 3
1465: ST_TO_ADDR
// if Frank then
1466: LD_EXP 28
1470: IFFALSE 1487
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1472: LD_EXP 28
1476: PPUSH
1477: LD_INT 13
1479: PPUSH
1480: LD_INT 0
1482: PPUSH
1483: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1487: LD_ADDR_EXP 29
1491: PUSH
1492: LD_STRING Kikuchi
1494: PPUSH
1495: LD_EXP 1
1499: NOT
1500: PPUSH
1501: LD_STRING 12a_
1503: PPUSH
1504: CALL 14854 0 3
1508: ST_TO_ADDR
// if Kikuchi then
1509: LD_EXP 29
1513: IFFALSE 1530
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1515: LD_EXP 29
1519: PPUSH
1520: LD_INT 13
1522: PPUSH
1523: LD_INT 0
1525: PPUSH
1526: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1530: LD_ADDR_EXP 30
1534: PUSH
1535: LD_STRING Simms
1537: PPUSH
1538: LD_EXP 1
1542: NOT
1543: PPUSH
1544: LD_STRING 12a_
1546: PPUSH
1547: CALL 14854 0 3
1551: ST_TO_ADDR
// if Simms then
1552: LD_EXP 30
1556: IFFALSE 1573
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1558: LD_EXP 30
1562: PPUSH
1563: LD_INT 13
1565: PPUSH
1566: LD_INT 0
1568: PPUSH
1569: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1573: LD_ADDR_EXP 31
1577: PUSH
1578: LD_STRING Joan
1580: PPUSH
1581: LD_EXP 1
1585: NOT
1586: PPUSH
1587: LD_STRING 12a_
1589: PPUSH
1590: CALL 14854 0 3
1594: ST_TO_ADDR
// if Joan then
1595: LD_EXP 31
1599: IFFALSE 1616
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1601: LD_EXP 31
1605: PPUSH
1606: LD_INT 13
1608: PPUSH
1609: LD_INT 0
1611: PPUSH
1612: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1616: LD_ADDR_EXP 32
1620: PUSH
1621: LD_STRING DeltaDoctor
1623: PPUSH
1624: LD_EXP 1
1628: NOT
1629: PPUSH
1630: LD_STRING 12a_
1632: PPUSH
1633: CALL 14854 0 3
1637: ST_TO_ADDR
// if DeltaDoctor then
1638: LD_EXP 32
1642: IFFALSE 1659
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1644: LD_EXP 32
1648: PPUSH
1649: LD_INT 13
1651: PPUSH
1652: LD_INT 0
1654: PPUSH
1655: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1659: LD_ADDR_VAR 0 4
1663: PUSH
1664: LD_STRING 12a_others
1666: PPUSH
1667: CALL_OW 31
1671: ST_TO_ADDR
// if tmp then
1672: LD_VAR 0 4
1676: IFFALSE 1710
// for i in tmp do
1678: LD_ADDR_VAR 0 3
1682: PUSH
1683: LD_VAR 0 4
1687: PUSH
1688: FOR_IN
1689: IFFALSE 1708
// PlaceUnitArea ( i , alliance_start , false ) ;
1691: LD_VAR 0 3
1695: PPUSH
1696: LD_INT 13
1698: PPUSH
1699: LD_INT 0
1701: PPUSH
1702: CALL_OW 49
1706: GO 1688
1708: POP
1709: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1710: LD_INT 3
1712: PPUSH
1713: LD_INT 3
1715: PPUSH
1716: LD_INT 3
1718: PPUSH
1719: LD_INT 12
1721: PPUSH
1722: LD_INT 100
1724: PPUSH
1725: CALL 19869 0 5
// veh := CreateVehicle ;
1729: LD_ADDR_VAR 0 2
1733: PUSH
1734: CALL_OW 45
1738: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1739: LD_VAR 0 2
1743: PPUSH
1744: LD_INT 2
1746: PPUSH
1747: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1751: LD_VAR 0 2
1755: PPUSH
1756: LD_INT 60
1758: PPUSH
1759: LD_INT 6
1761: PPUSH
1762: LD_INT 0
1764: PPUSH
1765: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1769: LD_VAR 0 2
1773: PPUSH
1774: LD_INT 4
1776: PPUSH
1777: LD_INT 30
1779: PPUSH
1780: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1784: LD_STRING 11_artifact_captured
1786: PPUSH
1787: LD_INT 0
1789: PPUSH
1790: CALL_OW 30
1794: IFFALSE 1870
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1796: LD_INT 3
1798: PPUSH
1799: LD_INT 3
1801: PPUSH
1802: LD_INT 3
1804: PPUSH
1805: LD_INT 12
1807: PPUSH
1808: LD_INT 100
1810: PPUSH
1811: CALL 19869 0 5
// veh := CreateVehicle ;
1815: LD_ADDR_VAR 0 2
1819: PUSH
1820: CALL_OW 45
1824: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1825: LD_VAR 0 2
1829: PPUSH
1830: LD_INT 3
1832: PPUSH
1833: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1837: LD_VAR 0 2
1841: PPUSH
1842: LD_INT 75
1844: PPUSH
1845: LD_INT 6
1847: PPUSH
1848: LD_INT 0
1850: PPUSH
1851: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1855: LD_VAR 0 2
1859: PPUSH
1860: LD_INT 4
1862: PPUSH
1863: LD_INT 50
1865: PPUSH
1866: CALL_OW 290
// end ; end ;
1870: LD_VAR 0 1
1874: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1875: LD_INT 0
1877: PPUSH
1878: PPUSH
1879: PPUSH
1880: PPUSH
// uc_side := 6 ;
1881: LD_ADDR_OWVAR 20
1885: PUSH
1886: LD_INT 6
1888: ST_TO_ADDR
// uc_nation := 3 ;
1889: LD_ADDR_OWVAR 21
1893: PUSH
1894: LD_INT 3
1896: ST_TO_ADDR
// InitHc ;
1897: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1901: LD_ADDR_EXP 33
1905: PUSH
1906: LD_STRING Gossudarov
1908: PPUSH
1909: CALL_OW 25
1913: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1914: LD_ADDR_EXP 34
1918: PUSH
1919: LD_STRING Kirilenkova
1921: PPUSH
1922: CALL_OW 25
1926: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1927: LD_ADDR_EXP 35
1931: PUSH
1932: LD_STRING Titov
1934: PPUSH
1935: CALL_OW 25
1939: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1940: LD_ADDR_EXP 40
1944: PUSH
1945: LD_STRING Oblukov
1947: PPUSH
1948: CALL_OW 25
1952: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1953: LD_ADDR_EXP 37
1957: PUSH
1958: LD_STRING Dolgov
1960: PPUSH
1961: CALL_OW 25
1965: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1966: LD_ADDR_EXP 38
1970: PUSH
1971: LD_STRING Petrosyan
1973: PPUSH
1974: CALL_OW 25
1978: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1979: LD_ADDR_EXP 39
1983: PUSH
1984: LD_STRING Scholtze
1986: PPUSH
1987: CALL_OW 25
1991: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1992: LD_ADDR_EXP 41
1996: PUSH
1997: LD_STRING Kapitsova
1999: PPUSH
2000: CALL_OW 25
2004: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2005: LD_ADDR_VAR 0 2
2009: PUSH
2010: LD_EXP 33
2014: PUSH
2015: LD_EXP 34
2019: PUSH
2020: LD_EXP 35
2024: PUSH
2025: LD_EXP 40
2029: PUSH
2030: LD_EXP 37
2034: PUSH
2035: LD_EXP 38
2039: PUSH
2040: LD_EXP 39
2044: PUSH
2045: LD_EXP 41
2049: PUSH
2050: EMPTY
2051: LIST
2052: LIST
2053: LIST
2054: LIST
2055: LIST
2056: LIST
2057: LIST
2058: LIST
2059: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2060: LD_INT 1
2062: PPUSH
2063: LD_INT 4
2065: PPUSH
2066: LD_INT 8
2068: PPUSH
2069: CALL_OW 380
// un := CreateHuman ;
2073: LD_ADDR_VAR 0 4
2077: PUSH
2078: CALL_OW 44
2082: ST_TO_ADDR
// tmp := tmp ^ un ;
2083: LD_ADDR_VAR 0 2
2087: PUSH
2088: LD_VAR 0 2
2092: PUSH
2093: LD_VAR 0 4
2097: ADD
2098: ST_TO_ADDR
// for i in tmp do
2099: LD_ADDR_VAR 0 3
2103: PUSH
2104: LD_VAR 0 2
2108: PUSH
2109: FOR_IN
2110: IFFALSE 2129
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2112: LD_VAR 0 3
2116: PPUSH
2117: LD_INT 14
2119: PPUSH
2120: LD_INT 0
2122: PPUSH
2123: CALL_OW 49
2127: GO 2109
2129: POP
2130: POP
// if freedom then
2131: LD_EXP 3
2135: IFFALSE 2168
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2137: LD_VAR 0 2
2141: PPUSH
2142: LD_EXP 3
2146: PPUSH
2147: CALL_OW 250
2151: PPUSH
2152: LD_EXP 3
2156: PPUSH
2157: CALL_OW 251
2161: PPUSH
2162: CALL_OW 111
2166: GO 2183
// ComMoveXY ( tmp , 70 , 48 ) ;
2168: LD_VAR 0 2
2172: PPUSH
2173: LD_INT 70
2175: PPUSH
2176: LD_INT 48
2178: PPUSH
2179: CALL_OW 111
// end ;
2183: LD_VAR 0 1
2187: RET
// export function PrepareBelkov ; begin
2188: LD_INT 0
2190: PPUSH
// uc_side := 4 ;
2191: LD_ADDR_OWVAR 20
2195: PUSH
2196: LD_INT 4
2198: ST_TO_ADDR
// uc_nation := 3 ;
2199: LD_ADDR_OWVAR 21
2203: PUSH
2204: LD_INT 3
2206: ST_TO_ADDR
// InitHc ;
2207: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2211: LD_ADDR_EXP 48
2215: PUSH
2216: LD_STRING Belkov
2218: PPUSH
2219: CALL_OW 25
2223: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2224: LD_EXP 48
2228: PPUSH
2229: LD_INT 14
2231: PPUSH
2232: LD_INT 0
2234: PPUSH
2235: CALL_OW 49
// end ;
2239: LD_VAR 0 1
2243: RET
// export function PrepareGnyevko ; begin
2244: LD_INT 0
2246: PPUSH
// uc_side := 4 ;
2247: LD_ADDR_OWVAR 20
2251: PUSH
2252: LD_INT 4
2254: ST_TO_ADDR
// uc_nation := 3 ;
2255: LD_ADDR_OWVAR 21
2259: PUSH
2260: LD_INT 3
2262: ST_TO_ADDR
// InitHc ;
2263: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2267: LD_ADDR_EXP 49
2271: PUSH
2272: LD_STRING Gnyevko
2274: PPUSH
2275: CALL_OW 25
2279: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2280: LD_EXP 49
2284: PPUSH
2285: LD_INT 14
2287: PPUSH
2288: LD_INT 0
2290: PPUSH
2291: CALL_OW 49
// end ;
2295: LD_VAR 0 1
2299: RET
// export function PrepareBurlak ; var i , tmp ; begin
2300: LD_INT 0
2302: PPUSH
2303: PPUSH
2304: PPUSH
// uc_side := 4 ;
2305: LD_ADDR_OWVAR 20
2309: PUSH
2310: LD_INT 4
2312: ST_TO_ADDR
// uc_nation := 3 ;
2313: LD_ADDR_OWVAR 21
2317: PUSH
2318: LD_INT 3
2320: ST_TO_ADDR
// InitHc ;
2321: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2325: LD_ADDR_EXP 47
2329: PUSH
2330: LD_STRING Burlak
2332: PPUSH
2333: CALL_OW 25
2337: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2338: LD_INT 24
2340: PUSH
2341: LD_INT 23
2343: PUSH
2344: LD_INT 22
2346: PUSH
2347: LD_INT 22
2349: PUSH
2350: EMPTY
2351: LIST
2352: LIST
2353: LIST
2354: LIST
2355: PUSH
2356: LD_OWVAR 67
2360: ARRAY
2361: PPUSH
2362: LD_INT 1
2364: PPUSH
2365: LD_INT 1
2367: PPUSH
2368: LD_INT 45
2370: PUSH
2371: LD_INT 44
2373: PUSH
2374: LD_INT 43
2376: PUSH
2377: LD_INT 42
2379: PUSH
2380: EMPTY
2381: LIST
2382: LIST
2383: LIST
2384: LIST
2385: PUSH
2386: LD_OWVAR 67
2390: ARRAY
2391: PPUSH
2392: LD_INT 0
2394: PPUSH
2395: CALL 19869 0 5
// Masha := CreateVehicle ;
2399: LD_ADDR_EXP 50
2403: PUSH
2404: CALL_OW 45
2408: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2409: LD_EXP 50
2413: PUSH
2414: LD_EXP 47
2418: PUSH
2419: EMPTY
2420: LIST
2421: LIST
2422: PPUSH
2423: LD_INT 499
2425: PPUSH
2426: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2430: LD_EXP 50
2434: PPUSH
2435: LD_INT 3
2437: PPUSH
2438: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2442: LD_EXP 50
2446: PPUSH
2447: LD_INT 1
2449: PPUSH
2450: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2454: LD_INT 1
2456: PPUSH
2457: LD_INT 18
2459: PPUSH
2460: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2464: LD_INT 35
2466: PPUSH
2467: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2471: LD_ADDR_VAR 0 3
2475: PUSH
2476: LD_INT 18
2478: PPUSH
2479: EMPTY
2480: PPUSH
2481: CALL_OW 70
2485: ST_TO_ADDR
// if tmp then
2486: LD_VAR 0 3
2490: IFFALSE 2524
// for i in tmp do
2492: LD_ADDR_VAR 0 2
2496: PUSH
2497: LD_VAR 0 3
2501: PUSH
2502: FOR_IN
2503: IFFALSE 2522
// ComMoveXY ( i , 114 , 9 ) ;
2505: LD_VAR 0 2
2509: PPUSH
2510: LD_INT 114
2512: PPUSH
2513: LD_INT 9
2515: PPUSH
2516: CALL_OW 111
2520: GO 2502
2522: POP
2523: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2524: LD_INT 18
2526: PPUSH
2527: EMPTY
2528: PPUSH
2529: CALL_OW 70
2533: NOT
2534: PUSH
2535: LD_INT 123
2537: PPUSH
2538: LD_INT 3
2540: PPUSH
2541: CALL_OW 428
2545: PUSH
2546: LD_INT 0
2548: EQUAL
2549: AND
2550: IFFALSE 2464
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2552: LD_EXP 50
2556: PPUSH
2557: LD_INT 123
2559: PPUSH
2560: LD_INT 3
2562: PPUSH
2563: LD_INT 0
2565: PPUSH
2566: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2570: LD_EXP 47
2574: PPUSH
2575: LD_INT 125
2577: PPUSH
2578: LD_INT 1
2580: PPUSH
2581: LD_INT 0
2583: PPUSH
2584: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2588: LD_EXP 47
2592: PPUSH
2593: LD_EXP 50
2597: PPUSH
2598: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2602: LD_INT 10
2604: PPUSH
2605: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2609: LD_EXP 50
2613: PPUSH
2614: LD_INT 110
2616: PPUSH
2617: LD_INT 10
2619: PPUSH
2620: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2624: LD_ADDR_EXP 43
2628: PUSH
2629: LD_STRING Petrovova
2631: PPUSH
2632: CALL_OW 25
2636: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2637: LD_ADDR_EXP 45
2641: PUSH
2642: LD_STRING Kuzmov
2644: PPUSH
2645: CALL_OW 25
2649: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2650: LD_ADDR_EXP 44
2654: PUSH
2655: LD_STRING Kovalyuk
2657: PPUSH
2658: CALL_OW 25
2662: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2663: LD_ADDR_EXP 42
2667: PUSH
2668: LD_STRING Lipshchin
2670: PPUSH
2671: CALL_OW 25
2675: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2676: LD_ADDR_EXP 46
2680: PUSH
2681: LD_STRING Karamazov
2683: PPUSH
2684: CALL_OW 25
2688: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2689: LD_ADDR_VAR 0 3
2693: PUSH
2694: LD_EXP 43
2698: PUSH
2699: LD_EXP 45
2703: PUSH
2704: LD_EXP 44
2708: PUSH
2709: LD_EXP 42
2713: PUSH
2714: LD_EXP 46
2718: PUSH
2719: EMPTY
2720: LIST
2721: LIST
2722: LIST
2723: LIST
2724: LIST
2725: ST_TO_ADDR
// for i in tmp do
2726: LD_ADDR_VAR 0 2
2730: PUSH
2731: LD_VAR 0 3
2735: PUSH
2736: FOR_IN
2737: IFFALSE 2776
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2739: LD_VAR 0 2
2743: PPUSH
2744: LD_INT 399
2746: PPUSH
2747: LD_INT 799
2749: PPUSH
2750: CALL_OW 12
2754: PPUSH
2755: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2759: LD_VAR 0 2
2763: PPUSH
2764: LD_INT 19
2766: PPUSH
2767: LD_INT 0
2769: PPUSH
2770: CALL_OW 49
// end ;
2774: GO 2736
2776: POP
2777: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2778: LD_VAR 0 3
2782: PPUSH
2783: LD_INT 112
2785: PPUSH
2786: LD_INT 5
2788: PPUSH
2789: CALL_OW 111
// AddComHold ( tmp ) ;
2793: LD_VAR 0 3
2797: PPUSH
2798: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: LD_VAR 0 3
2811: PPUSH
2812: LD_INT 25
2814: PUSH
2815: LD_INT 1
2817: PUSH
2818: EMPTY
2819: LIST
2820: LIST
2821: PPUSH
2822: CALL_OW 72
2826: PUSH
2827: FOR_IN
2828: IFFALSE 2868
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2830: LD_VAR 0 2
2834: PPUSH
2835: LD_INT 20
2837: PPUSH
2838: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2842: LD_VAR 0 2
2846: PPUSH
2847: LD_INT 147
2849: PPUSH
2850: LD_INT 45
2852: PPUSH
2853: CALL_OW 178
// AddComCrawl ( i ) ;
2857: LD_VAR 0 2
2861: PPUSH
2862: CALL_OW 197
// end ;
2866: GO 2827
2868: POP
2869: POP
// repeat wait ( 0 0$1 ) ;
2870: LD_INT 35
2872: PPUSH
2873: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2877: LD_EXP 50
2881: PPUSH
2882: LD_INT 110
2884: PPUSH
2885: LD_INT 10
2887: PPUSH
2888: CALL_OW 307
2892: PUSH
2893: LD_EXP 50
2897: PPUSH
2898: CALL_OW 305
2902: NOT
2903: OR
2904: IFFALSE 2870
// ComStop ( Burlak ) ;
2906: LD_EXP 47
2910: PPUSH
2911: CALL_OW 141
// AddComHold ( Burlak ) ;
2915: LD_EXP 47
2919: PPUSH
2920: CALL_OW 200
// end ; end_of_file
2924: LD_VAR 0 1
2928: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2929: LD_INT 0
2931: PPUSH
2932: PPUSH
2933: PPUSH
2934: PPUSH
2935: PPUSH
// uc_side := 3 ;
2936: LD_ADDR_OWVAR 20
2940: PUSH
2941: LD_INT 3
2943: ST_TO_ADDR
// uc_nation := 3 ;
2944: LD_ADDR_OWVAR 21
2948: PUSH
2949: LD_INT 3
2951: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2952: LD_ADDR_EXP 51
2956: PUSH
2957: LD_INT 47
2959: PPUSH
2960: LD_INT 4
2962: PPUSH
2963: LD_STRING 
2965: PPUSH
2966: LD_INT 7
2968: PUSH
2969: LD_INT 8
2971: PUSH
2972: LD_INT 9
2974: PUSH
2975: LD_INT 10
2977: PUSH
2978: EMPTY
2979: LIST
2980: LIST
2981: LIST
2982: LIST
2983: PUSH
2984: LD_OWVAR 67
2988: ARRAY
2989: PPUSH
2990: LD_INT 10000
2992: PUSH
2993: LD_INT 3000
2995: PUSH
2996: LD_INT 300
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: LIST
3003: PPUSH
3004: LD_INT 9
3006: PUSH
3007: LD_INT 5
3009: PUSH
3010: LD_INT 6
3012: PUSH
3013: LD_INT 6
3015: PUSH
3016: EMPTY
3017: LIST
3018: LIST
3019: LIST
3020: LIST
3021: PPUSH
3022: CALL 23313 0 6
3026: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3027: LD_ADDR_EXP 60
3031: PUSH
3032: LD_EXP 60
3036: PPUSH
3037: LD_INT 2
3039: PPUSH
3040: LD_EXP 51
3044: PPUSH
3045: CALL_OW 1
3049: ST_TO_ADDR
// tmp := [ ] ;
3050: LD_ADDR_VAR 0 4
3054: PUSH
3055: EMPTY
3056: ST_TO_ADDR
// for i = 1 to 4 do
3057: LD_ADDR_VAR 0 2
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_INT 4
3069: PUSH
3070: FOR_TO
3071: IFFALSE 3164
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3073: LD_INT 22
3075: PPUSH
3076: LD_INT 3
3078: PPUSH
3079: LD_INT 3
3081: PPUSH
3082: LD_INT 43
3084: PUSH
3085: LD_INT 45
3087: PUSH
3088: LD_INT 45
3090: PUSH
3091: LD_INT 44
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: LIST
3098: LIST
3099: PUSH
3100: LD_VAR 0 2
3104: PUSH
3105: LD_INT 4
3107: MOD
3108: PUSH
3109: LD_INT 1
3111: PLUS
3112: ARRAY
3113: PPUSH
3114: LD_INT 100
3116: PPUSH
3117: CALL 19869 0 5
// veh := CreateVehicle ;
3121: LD_ADDR_VAR 0 3
3125: PUSH
3126: CALL_OW 45
3130: ST_TO_ADDR
// tmp := tmp ^ veh ;
3131: LD_ADDR_VAR 0 4
3135: PUSH
3136: LD_VAR 0 4
3140: PUSH
3141: LD_VAR 0 3
3145: ADD
3146: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3147: LD_VAR 0 3
3151: PPUSH
3152: LD_INT 2
3154: PPUSH
3155: LD_INT 0
3157: PPUSH
3158: CALL_OW 49
// end ;
3162: GO 3070
3164: POP
3165: POP
// russian_guard := tmp ;
3166: LD_ADDR_EXP 52
3170: PUSH
3171: LD_VAR 0 4
3175: ST_TO_ADDR
// if Difficulty >= 3 then
3176: LD_OWVAR 67
3180: PUSH
3181: LD_INT 3
3183: GREATEREQUAL
3184: IFFALSE 3248
// begin bc_type := b_breastwork ;
3186: LD_ADDR_OWVAR 42
3190: PUSH
3191: LD_INT 31
3193: ST_TO_ADDR
// bc_level := 10 ;
3194: LD_ADDR_OWVAR 43
3198: PUSH
3199: LD_INT 10
3201: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3202: LD_ADDR_VAR 0 5
3206: PUSH
3207: LD_INT 96
3209: PPUSH
3210: LD_INT 105
3212: PPUSH
3213: LD_INT 3
3215: PPUSH
3216: CALL_OW 47
3220: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3221: LD_INT 0
3223: PPUSH
3224: LD_INT 9
3226: PPUSH
3227: LD_INT 10
3229: PPUSH
3230: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3234: CALL_OW 44
3238: PPUSH
3239: LD_VAR 0 5
3243: PPUSH
3244: CALL_OW 52
// end ; end ;
3248: LD_VAR 0 1
3252: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers , amount ;
3253: LD_INT 47
3255: PPUSH
3256: CALL_OW 302
3260: PUSH
3261: LD_EXP 6
3265: AND
3266: IFFALSE 3955
3268: GO 3270
3270: DISABLE
3271: LD_INT 0
3273: PPUSH
3274: PPUSH
3275: PPUSH
3276: PPUSH
3277: PPUSH
3278: PPUSH
3279: PPUSH
// begin enable ;
3280: ENABLE
// base := 2 ;
3281: LD_ADDR_VAR 0 2
3285: PUSH
3286: LD_INT 2
3288: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3289: LD_ADDR_VAR 0 4
3293: PUSH
3294: LD_INT 0
3296: PUSH
3297: LD_INT 0
3299: PUSH
3300: LD_INT 0
3302: PUSH
3303: LD_INT 0
3305: PUSH
3306: LD_INT 0
3308: PUSH
3309: LD_INT 0
3311: PUSH
3312: LD_INT 0
3314: PUSH
3315: LD_INT 0
3317: PUSH
3318: LD_INT 1
3320: PUSH
3321: LD_INT 0
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: LIST
3329: LIST
3330: LIST
3331: LIST
3332: LIST
3333: LIST
3334: LIST
3335: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3336: LD_ADDR_VAR 0 3
3340: PUSH
3341: LD_INT 22
3343: PUSH
3344: LD_INT 1
3346: PUSH
3347: LD_INT 3
3349: PUSH
3350: LD_INT 45
3352: PUSH
3353: EMPTY
3354: LIST
3355: LIST
3356: LIST
3357: LIST
3358: PUSH
3359: LD_INT 21
3361: PUSH
3362: LD_INT 1
3364: PUSH
3365: LD_INT 3
3367: PUSH
3368: LD_INT 45
3370: PUSH
3371: EMPTY
3372: LIST
3373: LIST
3374: LIST
3375: LIST
3376: PUSH
3377: LD_INT 22
3379: PUSH
3380: LD_INT 1
3382: PUSH
3383: LD_INT 3
3385: PUSH
3386: LD_INT 45
3388: PUSH
3389: EMPTY
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: PUSH
3395: LD_INT 23
3397: PUSH
3398: LD_INT 1
3400: PUSH
3401: LD_INT 3
3403: PUSH
3404: LD_INT 46
3406: PUSH
3407: EMPTY
3408: LIST
3409: LIST
3410: LIST
3411: LIST
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: ST_TO_ADDR
// amount := Difficulty ;
3419: LD_ADDR_VAR 0 7
3423: PUSH
3424: LD_OWVAR 67
3428: ST_TO_ADDR
// if tick > 30 30$00 then
3429: LD_OWVAR 1
3433: PUSH
3434: LD_INT 63000
3436: GREATER
3437: IFFALSE 3474
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3439: LD_ADDR_VAR 0 7
3443: PUSH
3444: LD_VAR 0 7
3448: PUSH
3449: LD_INT 2
3451: PUSH
3452: LD_INT 3
3454: PUSH
3455: LD_INT 4
3457: PUSH
3458: LD_INT 4
3460: PUSH
3461: EMPTY
3462: LIST
3463: LIST
3464: LIST
3465: LIST
3466: PUSH
3467: LD_OWVAR 67
3471: ARRAY
3472: PLUS
3473: ST_TO_ADDR
// for i = 1 to amount do
3474: LD_ADDR_VAR 0 1
3478: PUSH
3479: DOUBLE
3480: LD_INT 1
3482: DEC
3483: ST_TO_ADDR
3484: LD_VAR 0 7
3488: PUSH
3489: FOR_TO
3490: IFFALSE 3578
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3492: LD_ADDR_VAR 0 3
3496: PUSH
3497: LD_VAR 0 3
3501: PPUSH
3502: LD_VAR 0 3
3506: PUSH
3507: LD_INT 1
3509: PLUS
3510: PPUSH
3511: LD_INT 23
3513: PUSH
3514: LD_INT 24
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: PUSH
3521: LD_INT 1
3523: PPUSH
3524: LD_INT 2
3526: PPUSH
3527: CALL_OW 12
3531: ARRAY
3532: PUSH
3533: LD_INT 1
3535: PUSH
3536: LD_INT 3
3538: PUSH
3539: LD_INT 46
3541: PUSH
3542: LD_INT 47
3544: PUSH
3545: LD_INT 45
3547: PUSH
3548: EMPTY
3549: LIST
3550: LIST
3551: LIST
3552: PUSH
3553: LD_INT 1
3555: PPUSH
3556: LD_INT 3
3558: PPUSH
3559: CALL_OW 12
3563: ARRAY
3564: PUSH
3565: EMPTY
3566: LIST
3567: LIST
3568: LIST
3569: LIST
3570: PPUSH
3571: CALL_OW 2
3575: ST_TO_ADDR
3576: GO 3489
3578: POP
3579: POP
// MC_InsertProduceList ( base , tmp ) ;
3580: LD_VAR 0 2
3584: PPUSH
3585: LD_VAR 0 3
3589: PPUSH
3590: CALL 80255 0 2
// repeat wait ( 0 0$1 ) ;
3594: LD_INT 35
3596: PPUSH
3597: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3601: LD_VAR 0 2
3605: PPUSH
3606: LD_INT 1
3608: PPUSH
3609: CALL 81673 0 2
3613: PUSH
3614: LD_VAR 0 7
3618: GREATEREQUAL
3619: IFFALSE 3594
// wait ( 0 0$30 ) ;
3621: LD_INT 1050
3623: PPUSH
3624: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3628: LD_ADDR_VAR 0 5
3632: PUSH
3633: LD_INT 71
3635: PUSH
3636: LD_INT 19
3638: PUSH
3639: EMPTY
3640: LIST
3641: LIST
3642: PUSH
3643: LD_INT 91
3645: PUSH
3646: LD_INT 67
3648: PUSH
3649: EMPTY
3650: LIST
3651: LIST
3652: PUSH
3653: LD_INT 52
3655: PUSH
3656: LD_INT 44
3658: PUSH
3659: EMPTY
3660: LIST
3661: LIST
3662: PUSH
3663: LD_INT 68
3665: PUSH
3666: LD_INT 48
3668: PUSH
3669: EMPTY
3670: LIST
3671: LIST
3672: PUSH
3673: EMPTY
3674: LIST
3675: LIST
3676: LIST
3677: LIST
3678: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3679: LD_ADDR_VAR 0 6
3683: PUSH
3684: LD_EXP 79
3688: PUSH
3689: LD_VAR 0 2
3693: ARRAY
3694: PUSH
3695: LD_EXP 79
3699: PUSH
3700: LD_VAR 0 2
3704: ARRAY
3705: PPUSH
3706: LD_INT 2
3708: PUSH
3709: LD_INT 34
3711: PUSH
3712: LD_INT 51
3714: PUSH
3715: EMPTY
3716: LIST
3717: LIST
3718: PUSH
3719: LD_INT 34
3721: PUSH
3722: LD_INT 52
3724: PUSH
3725: EMPTY
3726: LIST
3727: LIST
3728: PUSH
3729: EMPTY
3730: LIST
3731: LIST
3732: LIST
3733: PPUSH
3734: CALL_OW 72
3738: DIFF
3739: ST_TO_ADDR
// if not attackers then
3740: LD_VAR 0 6
3744: NOT
3745: IFFALSE 3749
// exit ;
3747: GO 3955
// ru_attackers := attackers ;
3749: LD_ADDR_EXP 53
3753: PUSH
3754: LD_VAR 0 6
3758: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3759: LD_ADDR_EXP 79
3763: PUSH
3764: LD_EXP 79
3768: PPUSH
3769: LD_VAR 0 2
3773: PPUSH
3774: LD_EXP 79
3778: PUSH
3779: LD_VAR 0 2
3783: ARRAY
3784: PUSH
3785: LD_VAR 0 6
3789: DIFF
3790: PPUSH
3791: CALL_OW 1
3795: ST_TO_ADDR
// for i = 1 to attackers do
3796: LD_ADDR_VAR 0 1
3800: PUSH
3801: DOUBLE
3802: LD_INT 1
3804: DEC
3805: ST_TO_ADDR
3806: LD_VAR 0 6
3810: PUSH
3811: FOR_TO
3812: IFFALSE 3889
// begin case i mod 3 of 0 :
3814: LD_VAR 0 1
3818: PUSH
3819: LD_INT 3
3821: MOD
3822: PUSH
3823: LD_INT 0
3825: DOUBLE
3826: EQUAL
3827: IFTRUE 3831
3829: GO 3834
3831: POP
// ; 1 :
3832: GO 3887
3834: LD_INT 1
3836: DOUBLE
3837: EQUAL
3838: IFTRUE 3842
3840: GO 3860
3842: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3843: LD_VAR 0 1
3847: PPUSH
3848: LD_INT 32
3850: PPUSH
3851: LD_INT 49
3853: PPUSH
3854: CALL_OW 114
3858: GO 3887
3860: LD_INT 2
3862: DOUBLE
3863: EQUAL
3864: IFTRUE 3868
3866: GO 3886
3868: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3869: LD_VAR 0 1
3873: PPUSH
3874: LD_INT 117
3876: PPUSH
3877: LD_INT 107
3879: PPUSH
3880: CALL_OW 114
3884: GO 3887
3886: POP
// end ;
3887: GO 3811
3889: POP
3890: POP
// repeat wait ( 0 0$1 ) ;
3891: LD_INT 35
3893: PPUSH
3894: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3898: LD_VAR 0 6
3902: PPUSH
3903: LD_INT 60
3905: PUSH
3906: EMPTY
3907: LIST
3908: PPUSH
3909: CALL_OW 72
3913: NOT
3914: IFFALSE 3891
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3916: LD_VAR 0 2
3920: PPUSH
3921: LD_VAR 0 6
3925: PPUSH
3926: LD_VAR 0 5
3930: PPUSH
3931: LD_VAR 0 4
3935: PPUSH
3936: CALL 80440 0 4
// if not first_attack then
3940: LD_EXP 7
3944: NOT
3945: IFFALSE 3955
// first_attack := true ;
3947: LD_ADDR_EXP 7
3951: PUSH
3952: LD_INT 1
3954: ST_TO_ADDR
// end ; end_of_file
3955: PPOPN 7
3957: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3958: LD_INT 0
3960: PPUSH
3961: PPUSH
3962: PPUSH
3963: PPUSH
3964: PPUSH
3965: PPUSH
3966: PPUSH
// uc_side := 2 ;
3967: LD_ADDR_OWVAR 20
3971: PUSH
3972: LD_INT 2
3974: ST_TO_ADDR
// uc_nation := 2 ;
3975: LD_ADDR_OWVAR 21
3979: PUSH
3980: LD_INT 2
3982: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3983: LD_ADDR_EXP 56
3987: PUSH
3988: LD_STRING Abdul
3990: PPUSH
3991: CALL_OW 25
3995: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3996: LD_EXP 56
4000: PPUSH
4001: LD_INT 11
4003: PPUSH
4004: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4008: LD_EXP 56
4012: PPUSH
4013: LD_INT 1
4015: PPUSH
4016: CALL_OW 52
// vc_chassis := 31 ;
4020: LD_ADDR_OWVAR 37
4024: PUSH
4025: LD_INT 31
4027: ST_TO_ADDR
// vc_control := control_rider ;
4028: LD_ADDR_OWVAR 38
4032: PUSH
4033: LD_INT 4
4035: ST_TO_ADDR
// mastodont := CreateVehicle ;
4036: LD_ADDR_EXP 57
4040: PUSH
4041: CALL_OW 45
4045: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4046: LD_EXP 57
4050: PPUSH
4051: LD_INT 153
4053: PPUSH
4054: LD_INT 71
4056: PPUSH
4057: LD_INT 0
4059: PPUSH
4060: CALL_OW 48
// InitVc ;
4064: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4068: LD_ADDR_EXP 54
4072: PUSH
4073: LD_INT 1
4075: PPUSH
4076: LD_INT 3
4078: PPUSH
4079: LD_STRING 
4081: PPUSH
4082: LD_INT 7
4084: PUSH
4085: LD_INT 8
4087: PUSH
4088: LD_INT 9
4090: PUSH
4091: LD_INT 10
4093: PUSH
4094: EMPTY
4095: LIST
4096: LIST
4097: LIST
4098: LIST
4099: PUSH
4100: LD_OWVAR 67
4104: ARRAY
4105: PPUSH
4106: LD_INT 5000
4108: PUSH
4109: LD_INT 1000
4111: PUSH
4112: LD_INT 300
4114: PUSH
4115: EMPTY
4116: LIST
4117: LIST
4118: LIST
4119: PPUSH
4120: LD_INT 18
4122: PUSH
4123: LD_INT 5
4125: PUSH
4126: LD_INT 6
4128: PUSH
4129: LD_INT 9
4131: PUSH
4132: EMPTY
4133: LIST
4134: LIST
4135: LIST
4136: LIST
4137: PPUSH
4138: CALL 23313 0 6
4142: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4143: LD_ADDR_EXP 60
4147: PUSH
4148: LD_EXP 60
4152: PPUSH
4153: LD_INT 1
4155: PPUSH
4156: LD_EXP 54
4160: PPUSH
4161: CALL_OW 1
4165: ST_TO_ADDR
// tmp := [ ] ;
4166: LD_ADDR_VAR 0 4
4170: PUSH
4171: EMPTY
4172: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4173: LD_ADDR_OWVAR 37
4177: PUSH
4178: LD_INT 14
4180: ST_TO_ADDR
// vc_engine := engine_siberite ;
4181: LD_ADDR_OWVAR 39
4185: PUSH
4186: LD_INT 3
4188: ST_TO_ADDR
// vc_control := control_manual ;
4189: LD_ADDR_OWVAR 38
4193: PUSH
4194: LD_INT 1
4196: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4197: LD_ADDR_OWVAR 40
4201: PUSH
4202: LD_INT 31
4204: ST_TO_ADDR
// for i = 1 to 3 do
4205: LD_ADDR_VAR 0 2
4209: PUSH
4210: DOUBLE
4211: LD_INT 1
4213: DEC
4214: ST_TO_ADDR
4215: LD_INT 3
4217: PUSH
4218: FOR_TO
4219: IFFALSE 4467
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4221: LD_ADDR_VAR 0 5
4225: PUSH
4226: LD_INT 153
4228: PUSH
4229: LD_INT 71
4231: PUSH
4232: EMPTY
4233: LIST
4234: LIST
4235: PUSH
4236: LD_INT 155
4238: PUSH
4239: LD_INT 81
4241: PUSH
4242: EMPTY
4243: LIST
4244: LIST
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: PUSH
4250: LD_VAR 0 2
4254: PUSH
4255: LD_INT 2
4257: MOD
4258: PUSH
4259: LD_INT 1
4261: PLUS
4262: ARRAY
4263: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4264: LD_INT 0
4266: PPUSH
4267: LD_INT 3
4269: PPUSH
4270: LD_INT 7
4272: PUSH
4273: LD_INT 8
4275: PUSH
4276: LD_INT 10
4278: PUSH
4279: LD_INT 10
4281: PUSH
4282: EMPTY
4283: LIST
4284: LIST
4285: LIST
4286: LIST
4287: PUSH
4288: LD_OWVAR 67
4292: ARRAY
4293: PPUSH
4294: CALL_OW 380
// un := CreateVehicle ;
4298: LD_ADDR_VAR 0 6
4302: PUSH
4303: CALL_OW 45
4307: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4308: LD_VAR 0 6
4312: PPUSH
4313: LD_INT 0
4315: PPUSH
4316: LD_INT 5
4318: PPUSH
4319: CALL_OW 12
4323: PPUSH
4324: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4328: LD_VAR 0 6
4332: PPUSH
4333: LD_VAR 0 5
4337: PUSH
4338: LD_INT 1
4340: ARRAY
4341: PPUSH
4342: LD_VAR 0 5
4346: PUSH
4347: LD_INT 2
4349: ARRAY
4350: PPUSH
4351: LD_INT 6
4353: PPUSH
4354: LD_INT 0
4356: PPUSH
4357: CALL_OW 50
// un2 := CreateHuman ;
4361: LD_ADDR_VAR 0 7
4365: PUSH
4366: CALL_OW 44
4370: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4371: LD_VAR 0 7
4375: PPUSH
4376: LD_VAR 0 6
4380: PPUSH
4381: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4385: LD_ADDR_EXP 60
4389: PUSH
4390: LD_EXP 60
4394: PPUSH
4395: LD_INT 1
4397: PUSH
4398: LD_EXP 60
4402: PUSH
4403: LD_INT 1
4405: ARRAY
4406: PUSH
4407: LD_INT 1
4409: PLUS
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PPUSH
4415: LD_VAR 0 6
4419: PPUSH
4420: CALL 19991 0 3
4424: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4425: LD_ADDR_EXP 60
4429: PUSH
4430: LD_EXP 60
4434: PPUSH
4435: LD_INT 1
4437: PUSH
4438: LD_EXP 60
4442: PUSH
4443: LD_INT 1
4445: ARRAY
4446: PUSH
4447: LD_INT 1
4449: PLUS
4450: PUSH
4451: EMPTY
4452: LIST
4453: LIST
4454: PPUSH
4455: LD_VAR 0 7
4459: PPUSH
4460: CALL 19991 0 3
4464: ST_TO_ADDR
// end ;
4465: GO 4218
4467: POP
4468: POP
// for i = 1 to 5 do
4469: LD_ADDR_VAR 0 2
4473: PUSH
4474: DOUBLE
4475: LD_INT 1
4477: DEC
4478: ST_TO_ADDR
4479: LD_INT 5
4481: PUSH
4482: FOR_TO
4483: IFFALSE 4576
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4485: LD_INT 14
4487: PPUSH
4488: LD_INT 3
4490: PPUSH
4491: LD_INT 1
4493: PPUSH
4494: LD_INT 25
4496: PUSH
4497: LD_INT 28
4499: PUSH
4500: LD_INT 28
4502: PUSH
4503: LD_INT 26
4505: PUSH
4506: EMPTY
4507: LIST
4508: LIST
4509: LIST
4510: LIST
4511: PUSH
4512: LD_VAR 0 2
4516: PUSH
4517: LD_INT 4
4519: MOD
4520: PUSH
4521: LD_INT 1
4523: PLUS
4524: ARRAY
4525: PPUSH
4526: LD_INT 100
4528: PPUSH
4529: CALL 19869 0 5
// veh := CreateVehicle ;
4533: LD_ADDR_VAR 0 3
4537: PUSH
4538: CALL_OW 45
4542: ST_TO_ADDR
// tmp := tmp ^ veh ;
4543: LD_ADDR_VAR 0 4
4547: PUSH
4548: LD_VAR 0 4
4552: PUSH
4553: LD_VAR 0 3
4557: ADD
4558: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4559: LD_VAR 0 3
4563: PPUSH
4564: LD_INT 1
4566: PPUSH
4567: LD_INT 0
4569: PPUSH
4570: CALL_OW 49
// end ;
4574: GO 4482
4576: POP
4577: POP
// arabian_guard := tmp ;
4578: LD_ADDR_EXP 55
4582: PUSH
4583: LD_VAR 0 4
4587: ST_TO_ADDR
// end ;
4588: LD_VAR 0 1
4592: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4593: LD_INT 22
4595: PUSH
4596: LD_INT 7
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: PUSH
4603: LD_INT 91
4605: PUSH
4606: LD_INT 1
4608: PUSH
4609: LD_INT 12
4611: PUSH
4612: EMPTY
4613: LIST
4614: LIST
4615: LIST
4616: PUSH
4617: EMPTY
4618: LIST
4619: LIST
4620: PPUSH
4621: CALL_OW 69
4625: PUSH
4626: LD_EXP 57
4630: PPUSH
4631: CALL_OW 256
4635: PUSH
4636: LD_INT 990
4638: LESS
4639: OR
4640: PUSH
4641: LD_EXP 56
4645: PPUSH
4646: CALL_OW 256
4650: PUSH
4651: LD_INT 990
4653: LESS
4654: OR
4655: IFFALSE 4798
4657: GO 4659
4659: DISABLE
// begin if IsInUnit ( Abdul ) then
4660: LD_EXP 56
4664: PPUSH
4665: CALL_OW 310
4669: IFFALSE 4680
// ComExitBuilding ( Abdul ) ;
4671: LD_EXP 56
4675: PPUSH
4676: CALL_OW 122
// if Mastodont then
4680: LD_EXP 57
4684: IFFALSE 4701
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4686: LD_EXP 57
4690: PPUSH
4691: LD_INT 205
4693: PPUSH
4694: LD_INT 132
4696: PPUSH
4697: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4701: LD_EXP 56
4705: PPUSH
4706: LD_INT 205
4708: PPUSH
4709: LD_INT 132
4711: PPUSH
4712: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4716: LD_INT 35
4718: PPUSH
4719: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4723: LD_EXP 56
4727: PPUSH
4728: LD_INT 21
4730: PPUSH
4731: CALL_OW 308
4735: IFFALSE 4716
// RemoveUnit ( Abdul ) ;
4737: LD_EXP 56
4741: PPUSH
4742: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4746: LD_INT 35
4748: PPUSH
4749: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4753: LD_EXP 57
4757: PPUSH
4758: LD_INT 21
4760: PPUSH
4761: CALL_OW 308
4765: PUSH
4766: LD_EXP 57
4770: PPUSH
4771: CALL_OW 301
4775: OR
4776: IFFALSE 4746
// if IsOk ( Mastodont ) then
4778: LD_EXP 57
4782: PPUSH
4783: CALL_OW 302
4787: IFFALSE 4798
// RemoveUnit ( Mastodont ) ;
4789: LD_EXP 57
4793: PPUSH
4794: CALL_OW 64
// end ;
4798: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4799: LD_EXP 56
4803: PPUSH
4804: CALL_OW 301
4808: PUSH
4809: LD_INT 22
4811: PUSH
4812: LD_INT 2
4814: PUSH
4815: EMPTY
4816: LIST
4817: LIST
4818: PUSH
4819: LD_INT 2
4821: PUSH
4822: LD_INT 25
4824: PUSH
4825: LD_INT 1
4827: PUSH
4828: EMPTY
4829: LIST
4830: LIST
4831: PUSH
4832: LD_INT 25
4834: PUSH
4835: LD_INT 2
4837: PUSH
4838: EMPTY
4839: LIST
4840: LIST
4841: PUSH
4842: LD_INT 25
4844: PUSH
4845: LD_INT 3
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: PUSH
4852: LD_INT 25
4854: PUSH
4855: LD_INT 4
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: LD_INT 25
4864: PUSH
4865: LD_INT 8
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: PUSH
4880: EMPTY
4881: LIST
4882: LIST
4883: PPUSH
4884: CALL_OW 69
4888: PUSH
4889: LD_INT 16
4891: PUSH
4892: LD_INT 19
4894: PUSH
4895: LD_INT 22
4897: PUSH
4898: LD_INT 22
4900: PUSH
4901: EMPTY
4902: LIST
4903: LIST
4904: LIST
4905: LIST
4906: PUSH
4907: LD_OWVAR 67
4911: ARRAY
4912: LESS
4913: OR
4914: IFFALSE 5587
4916: GO 4918
4918: DISABLE
4919: LD_INT 0
4921: PPUSH
4922: PPUSH
4923: PPUSH
4924: PPUSH
4925: PPUSH
4926: PPUSH
// begin MC_Kill ( 1 ) ;
4927: LD_INT 1
4929: PPUSH
4930: CALL 56281 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4934: LD_ADDR_VAR 0 2
4938: PUSH
4939: LD_INT 22
4941: PUSH
4942: LD_INT 2
4944: PUSH
4945: EMPTY
4946: LIST
4947: LIST
4948: PUSH
4949: LD_INT 2
4951: PUSH
4952: LD_INT 25
4954: PUSH
4955: LD_INT 1
4957: PUSH
4958: EMPTY
4959: LIST
4960: LIST
4961: PUSH
4962: LD_INT 25
4964: PUSH
4965: LD_INT 2
4967: PUSH
4968: EMPTY
4969: LIST
4970: LIST
4971: PUSH
4972: LD_INT 25
4974: PUSH
4975: LD_INT 3
4977: PUSH
4978: EMPTY
4979: LIST
4980: LIST
4981: PUSH
4982: LD_INT 25
4984: PUSH
4985: LD_INT 4
4987: PUSH
4988: EMPTY
4989: LIST
4990: LIST
4991: PUSH
4992: LD_INT 25
4994: PUSH
4995: LD_INT 8
4997: PUSH
4998: EMPTY
4999: LIST
5000: LIST
5001: PUSH
5002: EMPTY
5003: LIST
5004: LIST
5005: LIST
5006: LIST
5007: LIST
5008: LIST
5009: PUSH
5010: EMPTY
5011: LIST
5012: LIST
5013: PPUSH
5014: CALL_OW 69
5018: ST_TO_ADDR
// for i in tmp do
5019: LD_ADDR_VAR 0 5
5023: PUSH
5024: LD_VAR 0 2
5028: PUSH
5029: FOR_IN
5030: IFFALSE 5046
// SetTag ( i , 10 ) ;
5032: LD_VAR 0 5
5036: PPUSH
5037: LD_INT 10
5039: PPUSH
5040: CALL_OW 109
5044: GO 5029
5046: POP
5047: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5048: LD_ADDR_VAR 0 3
5052: PUSH
5053: LD_INT 22
5055: PUSH
5056: LD_INT 2
5058: PUSH
5059: EMPTY
5060: LIST
5061: LIST
5062: PUSH
5063: LD_INT 21
5065: PUSH
5066: LD_INT 1
5068: PUSH
5069: EMPTY
5070: LIST
5071: LIST
5072: PUSH
5073: EMPTY
5074: LIST
5075: LIST
5076: PPUSH
5077: CALL_OW 69
5081: PUSH
5082: LD_VAR 0 2
5086: DIFF
5087: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5088: LD_ADDR_VAR 0 1
5092: PUSH
5093: LD_INT 22
5095: PUSH
5096: LD_INT 2
5098: PUSH
5099: EMPTY
5100: LIST
5101: LIST
5102: PUSH
5103: LD_INT 21
5105: PUSH
5106: LD_INT 2
5108: PUSH
5109: EMPTY
5110: LIST
5111: LIST
5112: PUSH
5113: LD_INT 24
5115: PUSH
5116: LD_INT 300
5118: PUSH
5119: EMPTY
5120: LIST
5121: LIST
5122: PUSH
5123: EMPTY
5124: LIST
5125: LIST
5126: LIST
5127: PPUSH
5128: CALL_OW 69
5132: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5133: LD_ADDR_VAR 0 4
5137: PUSH
5138: LD_VAR 0 1
5142: PPUSH
5143: LD_INT 33
5145: PUSH
5146: LD_INT 1
5148: PUSH
5149: EMPTY
5150: LIST
5151: LIST
5152: PUSH
5153: LD_INT 58
5155: PUSH
5156: EMPTY
5157: LIST
5158: PUSH
5159: EMPTY
5160: LIST
5161: LIST
5162: PPUSH
5163: CALL_OW 72
5167: ST_TO_ADDR
// for i in tmp do
5168: LD_ADDR_VAR 0 5
5172: PUSH
5173: LD_VAR 0 2
5177: PUSH
5178: FOR_IN
5179: IFFALSE 5363
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5181: LD_VAR 0 5
5185: PUSH
5186: LD_INT 55
5188: PUSH
5189: EMPTY
5190: LIST
5191: PPUSH
5192: CALL_OW 69
5196: IN
5197: IFFALSE 5216
// begin AddComMoveXY ( i , 209 , 132 ) ;
5199: LD_VAR 0 5
5203: PPUSH
5204: LD_INT 209
5206: PPUSH
5207: LD_INT 132
5209: PPUSH
5210: CALL_OW 171
// continue ;
5214: GO 5178
// end ; if IsInUnit ( i ) then
5216: LD_VAR 0 5
5220: PPUSH
5221: CALL_OW 310
5225: IFFALSE 5243
// begin ComExitBuilding ( i ) ;
5227: LD_VAR 0 5
5231: PPUSH
5232: CALL_OW 122
// wait ( 3 ) ;
5236: LD_INT 3
5238: PPUSH
5239: CALL_OW 67
// end ; if tmp_empty then
5243: LD_VAR 0 4
5247: IFFALSE 5346
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5249: LD_VAR 0 5
5253: PPUSH
5254: LD_VAR 0 4
5258: PPUSH
5259: LD_VAR 0 5
5263: PPUSH
5264: CALL_OW 74
5268: PPUSH
5269: CALL_OW 296
5273: PUSH
5274: LD_INT 25
5276: LESS
5277: IFFALSE 5346
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5279: LD_ADDR_VAR 0 6
5283: PUSH
5284: LD_VAR 0 4
5288: PPUSH
5289: LD_VAR 0 5
5293: PPUSH
5294: CALL_OW 74
5298: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5299: LD_VAR 0 5
5303: PPUSH
5304: LD_VAR 0 6
5308: PPUSH
5309: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5313: LD_VAR 0 5
5317: PPUSH
5318: LD_INT 209
5320: PPUSH
5321: LD_INT 132
5323: PPUSH
5324: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5328: LD_ADDR_VAR 0 4
5332: PUSH
5333: LD_VAR 0 4
5337: PUSH
5338: LD_VAR 0 6
5342: DIFF
5343: ST_TO_ADDR
// continue ;
5344: GO 5178
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5346: LD_VAR 0 5
5350: PPUSH
5351: LD_INT 201
5353: PPUSH
5354: LD_INT 132
5356: PPUSH
5357: CALL_OW 171
// end ;
5361: GO 5178
5363: POP
5364: POP
// for i in tmp_ape do
5365: LD_ADDR_VAR 0 5
5369: PUSH
5370: LD_VAR 0 3
5374: PUSH
5375: FOR_IN
5376: IFFALSE 5415
// begin if IsInUnit ( i ) then
5378: LD_VAR 0 5
5382: PPUSH
5383: CALL_OW 310
5387: IFFALSE 5398
// ComExitBuilding ( i ) ;
5389: LD_VAR 0 5
5393: PPUSH
5394: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5398: LD_VAR 0 5
5402: PPUSH
5403: LD_INT 201
5405: PPUSH
5406: LD_INT 132
5408: PPUSH
5409: CALL_OW 171
// end ;
5413: GO 5375
5415: POP
5416: POP
// repeat wait ( 0 0$1 ) ;
5417: LD_INT 35
5419: PPUSH
5420: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5424: LD_ADDR_VAR 0 5
5428: PUSH
5429: LD_VAR 0 2
5433: PUSH
5434: LD_VAR 0 3
5438: UNION
5439: PUSH
5440: LD_VAR 0 1
5444: UNION
5445: PUSH
5446: FOR_IN
5447: IFFALSE 5478
// if not HasTask ( i ) then
5449: LD_VAR 0 5
5453: PPUSH
5454: CALL_OW 314
5458: NOT
5459: IFFALSE 5476
// ComMoveXY ( i , 201 , 132 ) ;
5461: LD_VAR 0 5
5465: PPUSH
5466: LD_INT 201
5468: PPUSH
5469: LD_INT 132
5471: PPUSH
5472: CALL_OW 111
5476: GO 5446
5478: POP
5479: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5480: LD_INT 21
5482: PPUSH
5483: LD_INT 22
5485: PUSH
5486: LD_INT 2
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: PPUSH
5493: CALL_OW 70
5497: IFFALSE 5538
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5499: LD_ADDR_VAR 0 5
5503: PUSH
5504: LD_INT 21
5506: PPUSH
5507: LD_INT 22
5509: PUSH
5510: LD_INT 2
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: PPUSH
5517: CALL_OW 70
5521: PUSH
5522: FOR_IN
5523: IFFALSE 5536
// RemoveUnit ( i ) ;
5525: LD_VAR 0 5
5529: PPUSH
5530: CALL_OW 64
5534: GO 5522
5536: POP
5537: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5538: LD_INT 22
5540: PUSH
5541: LD_INT 2
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: PUSH
5548: LD_INT 2
5550: PUSH
5551: LD_INT 21
5553: PUSH
5554: LD_INT 1
5556: PUSH
5557: EMPTY
5558: LIST
5559: LIST
5560: PUSH
5561: LD_INT 21
5563: PUSH
5564: LD_INT 2
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: LIST
5575: PUSH
5576: EMPTY
5577: LIST
5578: LIST
5579: PPUSH
5580: CALL_OW 69
5584: NOT
5585: IFFALSE 5417
// end ;
5587: PPOPN 6
5589: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5590: LD_EXP 9
5594: PUSH
5595: LD_INT 92
5597: PPUSH
5598: LD_INT 40
5600: PPUSH
5601: CALL_OW 428
5605: PPUSH
5606: CALL_OW 266
5610: PUSH
5611: LD_INT 30
5613: EQUAL
5614: AND
5615: IFFALSE 5811
5617: GO 5619
5619: DISABLE
5620: LD_INT 0
5622: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5623: LD_ADDR_VAR 0 1
5627: PUSH
5628: LD_EXP 60
5632: PUSH
5633: LD_INT 1
5635: ARRAY
5636: PPUSH
5637: LD_INT 25
5639: PUSH
5640: LD_INT 4
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PPUSH
5647: CALL_OW 72
5651: ST_TO_ADDR
// if not sci then
5652: LD_VAR 0 1
5656: NOT
5657: IFFALSE 5661
// exit ;
5659: GO 5811
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5661: LD_ADDR_EXP 60
5665: PUSH
5666: LD_EXP 60
5670: PPUSH
5671: LD_INT 1
5673: PPUSH
5674: LD_EXP 60
5678: PUSH
5679: LD_INT 1
5681: ARRAY
5682: PUSH
5683: LD_VAR 0 1
5687: PUSH
5688: LD_INT 1
5690: ARRAY
5691: DIFF
5692: PPUSH
5693: CALL_OW 1
5697: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5698: LD_VAR 0 1
5702: PUSH
5703: LD_INT 1
5705: ARRAY
5706: PPUSH
5707: CALL_OW 310
5711: IFFALSE 5726
// ComExitBuilding ( sci [ 1 ] ) ;
5713: LD_VAR 0 1
5717: PUSH
5718: LD_INT 1
5720: ARRAY
5721: PPUSH
5722: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5726: LD_INT 2
5728: PPUSH
5729: LD_INT 105
5731: PPUSH
5732: LD_INT 14
5734: PPUSH
5735: LD_INT 20
5737: PPUSH
5738: CALL 20887 0 4
5742: PUSH
5743: LD_INT 4
5745: ARRAY
5746: PUSH
5747: LD_INT 10
5749: LESS
5750: IFFALSE 5773
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5752: LD_VAR 0 1
5756: PUSH
5757: LD_INT 1
5759: ARRAY
5760: PPUSH
5761: LD_INT 105
5763: PPUSH
5764: LD_INT 14
5766: PPUSH
5767: CALL_OW 171
5771: GO 5792
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5773: LD_VAR 0 1
5777: PUSH
5778: LD_INT 1
5780: ARRAY
5781: PPUSH
5782: LD_INT 118
5784: PPUSH
5785: LD_INT 77
5787: PPUSH
5788: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5792: LD_VAR 0 1
5796: PUSH
5797: LD_INT 1
5799: ARRAY
5800: PPUSH
5801: LD_INT 92
5803: PPUSH
5804: LD_INT 40
5806: PPUSH
5807: CALL_OW 218
// end ;
5811: PPOPN 1
5813: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5814: LD_INT 1
5816: PPUSH
5817: CALL_OW 302
5821: PUSH
5822: LD_EXP 9
5826: AND
5827: IFFALSE 6304
5829: GO 5831
5831: DISABLE
5832: LD_INT 0
5834: PPUSH
5835: PPUSH
5836: PPUSH
5837: PPUSH
5838: PPUSH
5839: PPUSH
// begin enable ;
5840: ENABLE
// base := 1 ;
5841: LD_ADDR_VAR 0 2
5845: PUSH
5846: LD_INT 1
5848: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5849: LD_ADDR_VAR 0 4
5853: PUSH
5854: LD_INT 0
5856: PUSH
5857: LD_INT 0
5859: PUSH
5860: LD_INT 0
5862: PUSH
5863: LD_INT 0
5865: PUSH
5866: LD_INT 0
5868: PUSH
5869: LD_INT 0
5871: PUSH
5872: LD_INT 0
5874: PUSH
5875: LD_INT 0
5877: PUSH
5878: LD_INT 1
5880: PUSH
5881: LD_INT 0
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: LIST
5889: LIST
5890: LIST
5891: LIST
5892: LIST
5893: LIST
5894: LIST
5895: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5896: LD_ADDR_VAR 0 3
5900: PUSH
5901: LD_INT 14
5903: PUSH
5904: LD_INT 1
5906: PUSH
5907: LD_INT 2
5909: PUSH
5910: LD_INT 26
5912: PUSH
5913: EMPTY
5914: LIST
5915: LIST
5916: LIST
5917: LIST
5918: PUSH
5919: LD_INT 14
5921: PUSH
5922: LD_INT 1
5924: PUSH
5925: LD_INT 2
5927: PUSH
5928: LD_INT 28
5930: PUSH
5931: EMPTY
5932: LIST
5933: LIST
5934: LIST
5935: LIST
5936: PUSH
5937: LD_INT 13
5939: PUSH
5940: LD_INT 1
5942: PUSH
5943: LD_INT 2
5945: PUSH
5946: LD_INT 29
5948: PUSH
5949: EMPTY
5950: LIST
5951: LIST
5952: LIST
5953: LIST
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5960: LD_ADDR_VAR 0 1
5964: PUSH
5965: DOUBLE
5966: LD_INT 1
5968: DEC
5969: ST_TO_ADDR
5970: LD_OWVAR 67
5974: PUSH
5975: LD_OWVAR 1
5979: PUSH
5980: LD_INT 21000
5982: DIV
5983: PLUS
5984: PUSH
5985: FOR_TO
5986: IFFALSE 6078
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5988: LD_ADDR_VAR 0 3
5992: PUSH
5993: LD_VAR 0 3
5997: PPUSH
5998: LD_VAR 0 3
6002: PUSH
6003: LD_INT 1
6005: PLUS
6006: PPUSH
6007: LD_INT 13
6009: PUSH
6010: LD_INT 14
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: PUSH
6017: LD_INT 1
6019: PPUSH
6020: LD_INT 2
6022: PPUSH
6023: CALL_OW 12
6027: ARRAY
6028: PUSH
6029: LD_INT 1
6031: PUSH
6032: LD_INT 2
6034: PUSH
6035: LD_INT 28
6037: PUSH
6038: LD_INT 29
6040: PUSH
6041: LD_INT 25
6043: PUSH
6044: LD_INT 26
6046: PUSH
6047: EMPTY
6048: LIST
6049: LIST
6050: LIST
6051: LIST
6052: PUSH
6053: LD_INT 1
6055: PPUSH
6056: LD_INT 4
6058: PPUSH
6059: CALL_OW 12
6063: ARRAY
6064: PUSH
6065: EMPTY
6066: LIST
6067: LIST
6068: LIST
6069: LIST
6070: PPUSH
6071: CALL_OW 2
6075: ST_TO_ADDR
6076: GO 5985
6078: POP
6079: POP
// MC_InsertProduceList ( base , tmp ) ;
6080: LD_VAR 0 2
6084: PPUSH
6085: LD_VAR 0 3
6089: PPUSH
6090: CALL 80255 0 2
// repeat wait ( 0 0$1 ) ;
6094: LD_INT 35
6096: PPUSH
6097: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
6101: LD_EXP 79
6105: PUSH
6106: LD_VAR 0 2
6110: ARRAY
6111: PUSH
6112: LD_INT 6
6114: GREATER
6115: IFFALSE 6094
// wait ( 0 0$20 ) ;
6117: LD_INT 700
6119: PPUSH
6120: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6124: LD_ADDR_VAR 0 5
6128: PUSH
6129: LD_INT 124
6131: PUSH
6132: LD_INT 85
6134: PUSH
6135: EMPTY
6136: LIST
6137: LIST
6138: PUSH
6139: LD_INT 90
6141: PUSH
6142: LD_INT 61
6144: PUSH
6145: EMPTY
6146: LIST
6147: LIST
6148: PUSH
6149: LD_INT 69
6151: PUSH
6152: LD_INT 48
6154: PUSH
6155: EMPTY
6156: LIST
6157: LIST
6158: PUSH
6159: LD_INT 68
6161: PUSH
6162: LD_INT 48
6164: PUSH
6165: EMPTY
6166: LIST
6167: LIST
6168: PUSH
6169: EMPTY
6170: LIST
6171: LIST
6172: LIST
6173: LIST
6174: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6175: LD_ADDR_VAR 0 6
6179: PUSH
6180: LD_EXP 79
6184: PUSH
6185: LD_VAR 0 2
6189: ARRAY
6190: PUSH
6191: LD_EXP 79
6195: PUSH
6196: LD_VAR 0 2
6200: ARRAY
6201: PPUSH
6202: LD_INT 2
6204: PUSH
6205: LD_INT 34
6207: PUSH
6208: LD_INT 32
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 34
6217: PUSH
6218: LD_INT 88
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: PUSH
6225: EMPTY
6226: LIST
6227: LIST
6228: LIST
6229: PPUSH
6230: CALL_OW 72
6234: DIFF
6235: ST_TO_ADDR
// if not attackers then
6236: LD_VAR 0 6
6240: NOT
6241: IFFALSE 6245
// exit ;
6243: GO 6304
// ar_attackers := attackers ;
6245: LD_ADDR_EXP 11
6249: PUSH
6250: LD_VAR 0 6
6254: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6255: LD_INT 35
6257: PPUSH
6258: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6262: LD_VAR 0 6
6266: PPUSH
6267: LD_INT 60
6269: PUSH
6270: EMPTY
6271: LIST
6272: PPUSH
6273: CALL_OW 72
6277: NOT
6278: IFFALSE 6255
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6280: LD_VAR 0 2
6284: PPUSH
6285: LD_VAR 0 6
6289: PPUSH
6290: LD_VAR 0 5
6294: PPUSH
6295: LD_VAR 0 4
6299: PPUSH
6300: CALL 80440 0 4
// end ;
6304: PPOPN 6
6306: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6307: LD_INT 1
6309: PPUSH
6310: CALL_OW 302
6314: PUSH
6315: LD_EXP 9
6319: AND
6320: PUSH
6321: LD_EXP 50
6325: PPUSH
6326: LD_INT 22
6328: PPUSH
6329: CALL_OW 308
6333: AND
6334: PUSH
6335: LD_INT 1
6337: PPUSH
6338: CALL 80603 0 1
6342: PUSH
6343: LD_INT 0
6345: EQUAL
6346: AND
6347: PUSH
6348: LD_EXP 11
6352: NOT
6353: AND
6354: IFFALSE 6840
6356: GO 6358
6358: DISABLE
6359: LD_INT 0
6361: PPUSH
6362: PPUSH
6363: PPUSH
6364: PPUSH
6365: PPUSH
6366: PPUSH
6367: PPUSH
// begin base := 1 ;
6368: LD_ADDR_VAR 0 2
6372: PUSH
6373: LD_INT 1
6375: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6376: LD_ADDR_VAR 0 4
6380: PUSH
6381: LD_INT 0
6383: PUSH
6384: LD_INT 0
6386: PUSH
6387: LD_INT 0
6389: PUSH
6390: LD_INT 0
6392: PUSH
6393: LD_INT 0
6395: PUSH
6396: LD_INT 0
6398: PUSH
6399: LD_INT 0
6401: PUSH
6402: LD_INT 0
6404: PUSH
6405: LD_INT 1
6407: PUSH
6408: LD_INT 0
6410: PUSH
6411: EMPTY
6412: LIST
6413: LIST
6414: LIST
6415: LIST
6416: LIST
6417: LIST
6418: LIST
6419: LIST
6420: LIST
6421: LIST
6422: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6423: LD_ADDR_VAR 0 3
6427: PUSH
6428: LD_INT 13
6430: PUSH
6431: LD_INT 1
6433: PUSH
6434: LD_INT 2
6436: PUSH
6437: LD_INT 28
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 13
6448: PUSH
6449: LD_INT 1
6451: PUSH
6452: LD_INT 2
6454: PUSH
6455: LD_INT 27
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 13
6466: PUSH
6467: LD_INT 1
6469: PUSH
6470: LD_INT 2
6472: PUSH
6473: LD_INT 25
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: LIST
6480: LIST
6481: PUSH
6482: LD_INT 11
6484: PUSH
6485: LD_INT 2
6487: PUSH
6488: LD_INT 2
6490: PUSH
6491: LD_INT 24
6493: PUSH
6494: EMPTY
6495: LIST
6496: LIST
6497: LIST
6498: LIST
6499: PUSH
6500: LD_INT 11
6502: PUSH
6503: LD_INT 2
6505: PUSH
6506: LD_INT 2
6508: PUSH
6509: LD_INT 24
6511: PUSH
6512: EMPTY
6513: LIST
6514: LIST
6515: LIST
6516: LIST
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: LIST
6522: LIST
6523: LIST
6524: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6525: LD_VAR 0 2
6529: PPUSH
6530: LD_VAR 0 3
6534: PPUSH
6535: CALL 80255 0 2
// repeat wait ( 0 0$1 ) ;
6539: LD_INT 35
6541: PPUSH
6542: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6546: LD_EXP 79
6550: PUSH
6551: LD_VAR 0 2
6555: ARRAY
6556: PUSH
6557: LD_INT 6
6559: GREATEREQUAL
6560: IFFALSE 6539
// wait ( 0 0$20 ) ;
6562: LD_INT 700
6564: PPUSH
6565: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6569: LD_ADDR_VAR 0 5
6573: PUSH
6574: LD_INT 119
6576: PUSH
6577: LD_INT 9
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: PUSH
6584: EMPTY
6585: LIST
6586: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6587: LD_ADDR_VAR 0 6
6591: PUSH
6592: LD_EXP 79
6596: PUSH
6597: LD_VAR 0 2
6601: ARRAY
6602: PUSH
6603: LD_EXP 79
6607: PUSH
6608: LD_VAR 0 2
6612: ARRAY
6613: PPUSH
6614: LD_INT 2
6616: PUSH
6617: LD_INT 34
6619: PUSH
6620: LD_INT 32
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: PUSH
6627: LD_INT 34
6629: PUSH
6630: LD_INT 88
6632: PUSH
6633: EMPTY
6634: LIST
6635: LIST
6636: PUSH
6637: EMPTY
6638: LIST
6639: LIST
6640: LIST
6641: PPUSH
6642: CALL_OW 72
6646: DIFF
6647: ST_TO_ADDR
// if not attackers then
6648: LD_VAR 0 6
6652: NOT
6653: IFFALSE 6657
// exit ;
6655: GO 6840
// uc_side := 2 ;
6657: LD_ADDR_OWVAR 20
6661: PUSH
6662: LD_INT 2
6664: ST_TO_ADDR
// uc_nation := 2 ;
6665: LD_ADDR_OWVAR 21
6669: PUSH
6670: LD_INT 2
6672: ST_TO_ADDR
// InitHc ;
6673: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
6677: LD_ADDR_VAR 0 1
6681: PUSH
6682: DOUBLE
6683: LD_INT 1
6685: DEC
6686: ST_TO_ADDR
6687: LD_INT 4
6689: PUSH
6690: LD_INT 5
6692: PUSH
6693: LD_INT 6
6695: PUSH
6696: LD_INT 6
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: LD_OWVAR 67
6709: ARRAY
6710: PUSH
6711: FOR_TO
6712: IFFALSE 6789
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6714: LD_INT 0
6716: PPUSH
6717: LD_INT 15
6719: PUSH
6720: LD_INT 17
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: PUSH
6727: LD_INT 1
6729: PPUSH
6730: LD_INT 2
6732: PPUSH
6733: CALL_OW 12
6737: ARRAY
6738: PPUSH
6739: LD_INT 8
6741: PPUSH
6742: CALL_OW 380
// un := CreateHuman ;
6746: LD_ADDR_VAR 0 7
6750: PUSH
6751: CALL_OW 44
6755: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6756: LD_VAR 0 7
6760: PPUSH
6761: LD_INT 23
6763: PPUSH
6764: LD_INT 0
6766: PPUSH
6767: CALL_OW 49
// attackers := attackers union un ;
6771: LD_ADDR_VAR 0 6
6775: PUSH
6776: LD_VAR 0 6
6780: PUSH
6781: LD_VAR 0 7
6785: UNION
6786: ST_TO_ADDR
// end ;
6787: GO 6711
6789: POP
6790: POP
// repeat wait ( 0 0$1 ) ;
6791: LD_INT 35
6793: PPUSH
6794: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6798: LD_VAR 0 6
6802: PPUSH
6803: LD_INT 60
6805: PUSH
6806: EMPTY
6807: LIST
6808: PPUSH
6809: CALL_OW 72
6813: NOT
6814: IFFALSE 6791
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6816: LD_VAR 0 2
6820: PPUSH
6821: LD_VAR 0 6
6825: PPUSH
6826: LD_VAR 0 5
6830: PPUSH
6831: LD_VAR 0 4
6835: PPUSH
6836: CALL 80440 0 4
// end ; end_of_file
6840: PPOPN 7
6842: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
6843: LD_INT 0
6845: PPUSH
6846: PPUSH
6847: PPUSH
6848: PPUSH
6849: PPUSH
6850: PPUSH
// uc_side := 1 ;
6851: LD_ADDR_OWVAR 20
6855: PUSH
6856: LD_INT 1
6858: ST_TO_ADDR
// uc_nation := 1 ;
6859: LD_ADDR_OWVAR 21
6863: PUSH
6864: LD_INT 1
6866: ST_TO_ADDR
// InitHc ;
6867: CALL_OW 19
// InitVc ;
6871: CALL_OW 20
// tmp := [ ] ;
6875: LD_ADDR_VAR 0 3
6879: PUSH
6880: EMPTY
6881: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
6882: LD_ADDR_VAR 0 2
6886: PUSH
6887: DOUBLE
6888: LD_INT 1
6890: DEC
6891: ST_TO_ADDR
6892: LD_INT 6
6894: PUSH
6895: LD_INT 8
6897: PUSH
6898: LD_INT 10
6900: PUSH
6901: LD_INT 10
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: LIST
6908: LIST
6909: PUSH
6910: LD_OWVAR 67
6914: ARRAY
6915: PUSH
6916: FOR_TO
6917: IFFALSE 7191
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
6919: LD_ADDR_VAR 0 5
6923: PUSH
6924: LD_INT 2
6926: PUSH
6927: LD_INT 4
6929: PUSH
6930: LD_INT 5
6932: PUSH
6933: EMPTY
6934: LIST
6935: LIST
6936: LIST
6937: PUSH
6938: LD_INT 1
6940: PPUSH
6941: LD_INT 3
6943: PPUSH
6944: CALL_OW 12
6948: ARRAY
6949: ST_TO_ADDR
// case chassis of us_medium_wheeled :
6950: LD_VAR 0 5
6954: PUSH
6955: LD_INT 2
6957: DOUBLE
6958: EQUAL
6959: IFTRUE 6963
6961: GO 6997
6963: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
6964: LD_ADDR_VAR 0 6
6968: PUSH
6969: LD_INT 9
6971: PUSH
6972: LD_INT 5
6974: PUSH
6975: LD_INT 7
6977: PUSH
6978: EMPTY
6979: LIST
6980: LIST
6981: LIST
6982: PUSH
6983: LD_INT 1
6985: PPUSH
6986: LD_INT 3
6988: PPUSH
6989: CALL_OW 12
6993: ARRAY
6994: ST_TO_ADDR
6995: GO 7086
6997: LD_INT 4
6999: DOUBLE
7000: EQUAL
7001: IFTRUE 7005
7003: GO 7043
7005: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7006: LD_ADDR_VAR 0 6
7010: PUSH
7011: LD_INT 9
7013: PUSH
7014: LD_INT 6
7016: PUSH
7017: LD_INT 6
7019: PUSH
7020: LD_INT 7
7022: PUSH
7023: EMPTY
7024: LIST
7025: LIST
7026: LIST
7027: LIST
7028: PUSH
7029: LD_INT 1
7031: PPUSH
7032: LD_INT 4
7034: PPUSH
7035: CALL_OW 12
7039: ARRAY
7040: ST_TO_ADDR
7041: GO 7086
7043: LD_INT 5
7045: DOUBLE
7046: EQUAL
7047: IFTRUE 7051
7049: GO 7085
7051: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7052: LD_ADDR_VAR 0 6
7056: PUSH
7057: LD_INT 9
7059: PUSH
7060: LD_INT 6
7062: PUSH
7063: LD_INT 7
7065: PUSH
7066: EMPTY
7067: LIST
7068: LIST
7069: LIST
7070: PUSH
7071: LD_INT 1
7073: PPUSH
7074: LD_INT 3
7076: PPUSH
7077: CALL_OW 12
7081: ARRAY
7082: ST_TO_ADDR
7083: GO 7086
7085: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7086: LD_VAR 0 5
7090: PPUSH
7091: LD_INT 1
7093: PUSH
7094: LD_INT 3
7096: PUSH
7097: EMPTY
7098: LIST
7099: LIST
7100: PUSH
7101: LD_INT 1
7103: PPUSH
7104: LD_INT 2
7106: PPUSH
7107: CALL_OW 12
7111: ARRAY
7112: PPUSH
7113: LD_INT 3
7115: PPUSH
7116: LD_VAR 0 6
7120: PPUSH
7121: LD_INT 70
7123: PPUSH
7124: LD_INT 90
7126: PPUSH
7127: CALL_OW 12
7131: PPUSH
7132: CALL 19869 0 5
// veh := CreateVehicle ;
7136: LD_ADDR_VAR 0 4
7140: PUSH
7141: CALL_OW 45
7145: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7146: LD_VAR 0 4
7150: PPUSH
7151: LD_INT 2
7153: PPUSH
7154: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7158: LD_VAR 0 4
7162: PPUSH
7163: LD_INT 17
7165: PPUSH
7166: LD_INT 0
7168: PPUSH
7169: CALL_OW 49
// tmp := tmp ^ veh ;
7173: LD_ADDR_VAR 0 3
7177: PUSH
7178: LD_VAR 0 3
7182: PUSH
7183: LD_VAR 0 4
7187: ADD
7188: ST_TO_ADDR
// end ;
7189: GO 6916
7191: POP
7192: POP
// if not tmp then
7193: LD_VAR 0 3
7197: NOT
7198: IFFALSE 7202
// exit ;
7200: GO 7311
// if not first_powell_attack then
7202: LD_EXP 12
7206: NOT
7207: IFFALSE 7217
// first_powell_attack := true ;
7209: LD_ADDR_EXP 12
7213: PUSH
7214: LD_INT 1
7216: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7217: LD_INT 70
7219: PPUSH
7220: CALL_OW 67
// for i in tmp do
7224: LD_ADDR_VAR 0 2
7228: PUSH
7229: LD_VAR 0 3
7233: PUSH
7234: FOR_IN
7235: IFFALSE 7302
// if IsOk ( i ) then
7237: LD_VAR 0 2
7241: PPUSH
7242: CALL_OW 302
7246: IFFALSE 7284
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7248: LD_VAR 0 2
7252: PPUSH
7253: LD_INT 81
7255: PUSH
7256: LD_INT 1
7258: PUSH
7259: EMPTY
7260: LIST
7261: LIST
7262: PPUSH
7263: CALL_OW 69
7267: PPUSH
7268: LD_VAR 0 2
7272: PPUSH
7273: CALL_OW 74
7277: PPUSH
7278: CALL_OW 115
7282: GO 7300
// tmp := tmp diff i ;
7284: LD_ADDR_VAR 0 3
7288: PUSH
7289: LD_VAR 0 3
7293: PUSH
7294: LD_VAR 0 2
7298: DIFF
7299: ST_TO_ADDR
7300: GO 7234
7302: POP
7303: POP
// until not tmp ;
7304: LD_VAR 0 3
7308: NOT
7309: IFFALSE 7217
// end ; end_of_file
7311: LD_VAR 0 1
7315: RET
// export function Action ; var tmp , i , un ; begin
7316: LD_INT 0
7318: PPUSH
7319: PPUSH
7320: PPUSH
7321: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7322: LD_INT 68
7324: PPUSH
7325: LD_INT 39
7327: PPUSH
7328: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7332: LD_ADDR_VAR 0 2
7336: PUSH
7337: LD_INT 22
7339: PUSH
7340: LD_INT 7
7342: PUSH
7343: EMPTY
7344: LIST
7345: LIST
7346: PPUSH
7347: CALL_OW 69
7351: ST_TO_ADDR
// InGameOn ;
7352: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7356: LD_VAR 0 2
7360: PPUSH
7361: LD_INT 71
7363: PPUSH
7364: LD_INT 49
7366: PPUSH
7367: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7371: LD_INT 35
7373: PPUSH
7374: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7378: LD_INT 7
7380: PPUSH
7381: LD_INT 71
7383: PPUSH
7384: LD_INT 51
7386: PPUSH
7387: CALL_OW 293
7391: IFFALSE 7371
// DialogueOn ;
7393: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7397: LD_EXP 16
7401: PPUSH
7402: LD_STRING D1-JMM-1
7404: PPUSH
7405: CALL_OW 88
// if Joan then
7409: LD_EXP 31
7413: IFFALSE 7427
// Say ( Joan , D1-Joan-1 ) ;
7415: LD_EXP 31
7419: PPUSH
7420: LD_STRING D1-Joan-1
7422: PPUSH
7423: CALL_OW 88
// if Lisa then
7427: LD_EXP 18
7431: IFFALSE 7445
// Say ( Lisa , D1-Lisa-1 ) ;
7433: LD_EXP 18
7437: PPUSH
7438: LD_STRING D1-Lisa-1
7440: PPUSH
7441: CALL_OW 88
// if Joan or Lisa then
7445: LD_EXP 31
7449: PUSH
7450: LD_EXP 18
7454: OR
7455: IFFALSE 7469
// Say ( JMM , D1-JMM-2 ) ;
7457: LD_EXP 16
7461: PPUSH
7462: LD_STRING D1-JMM-2
7464: PPUSH
7465: CALL_OW 88
// DialogueOff ;
7469: CALL_OW 7
// InGameOff ;
7473: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7477: LD_INT 71
7479: PPUSH
7480: LD_INT 50
7482: PPUSH
7483: LD_INT 7
7485: PPUSH
7486: LD_INT 30
7488: NEG
7489: PPUSH
7490: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7494: LD_INT 71
7496: PPUSH
7497: LD_INT 50
7499: PPUSH
7500: LD_INT 7
7502: PPUSH
7503: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7507: LD_STRING M1
7509: PPUSH
7510: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7514: LD_INT 35
7516: PPUSH
7517: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7521: LD_EXP 3
7525: PUSH
7526: LD_OWVAR 1
7530: PUSH
7531: LD_INT 2100
7533: GREATER
7534: OR
7535: IFFALSE 7514
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7537: LD_INT 350
7539: PPUSH
7540: LD_INT 700
7542: PPUSH
7543: CALL_OW 12
7547: PPUSH
7548: CALL_OW 67
// PrepareGossudarov ;
7552: CALL 1875 0 0
// repeat wait ( 0 0$1 ) ;
7556: LD_INT 35
7558: PPUSH
7559: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7563: LD_INT 22
7565: PUSH
7566: LD_INT 6
7568: PUSH
7569: EMPTY
7570: LIST
7571: LIST
7572: PUSH
7573: LD_INT 3
7575: PUSH
7576: LD_INT 24
7578: PUSH
7579: LD_INT 1000
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: PUSH
7586: EMPTY
7587: LIST
7588: LIST
7589: PUSH
7590: EMPTY
7591: LIST
7592: LIST
7593: PPUSH
7594: CALL_OW 69
7598: PUSH
7599: LD_INT 7
7601: PPUSH
7602: LD_EXP 33
7606: PPUSH
7607: CALL_OW 292
7611: OR
7612: IFFALSE 7556
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7614: LD_ADDR_VAR 0 2
7618: PUSH
7619: LD_INT 22
7621: PUSH
7622: LD_INT 6
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: PPUSH
7629: CALL_OW 69
7633: ST_TO_ADDR
// for i in tmp do
7634: LD_ADDR_VAR 0 3
7638: PUSH
7639: LD_VAR 0 2
7643: PUSH
7644: FOR_IN
7645: IFFALSE 7661
// SetSide ( i , 7 ) ;
7647: LD_VAR 0 3
7651: PPUSH
7652: LD_INT 7
7654: PPUSH
7655: CALL_OW 235
7659: GO 7644
7661: POP
7662: POP
// DialogueOn ;
7663: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7667: LD_EXP 16
7671: PUSH
7672: LD_EXP 17
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: PPUSH
7681: LD_EXP 33
7685: PPUSH
7686: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7690: LD_EXP 33
7694: PPUSH
7695: CALL_OW 87
// if not Roth then
7699: LD_EXP 17
7703: NOT
7704: IFFALSE 7796
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7706: LD_VAR 0 2
7710: PPUSH
7711: LD_INT 3
7713: PUSH
7714: LD_INT 24
7716: PUSH
7717: LD_INT 1000
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: PPUSH
7728: CALL_OW 72
7732: IFFALSE 7746
// Say ( JMM , D2-JMM-1 ) ;
7734: LD_EXP 16
7738: PPUSH
7739: LD_STRING D2-JMM-1
7741: PPUSH
7742: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7746: LD_EXP 16
7750: PPUSH
7751: LD_STRING D2-JMM-1b
7753: PPUSH
7754: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7758: LD_EXP 33
7762: PPUSH
7763: LD_STRING D2-Gos-1
7765: PPUSH
7766: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7770: LD_EXP 16
7774: PPUSH
7775: LD_STRING D2-JMM-2
7777: PPUSH
7778: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7782: LD_EXP 33
7786: PPUSH
7787: LD_STRING D2-Gos-2
7789: PPUSH
7790: CALL_OW 88
// end else
7794: GO 7948
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7796: LD_VAR 0 2
7800: PPUSH
7801: LD_INT 3
7803: PUSH
7804: LD_INT 24
7806: PUSH
7807: LD_INT 1000
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: PUSH
7814: EMPTY
7815: LIST
7816: LIST
7817: PPUSH
7818: CALL_OW 72
7822: IFFALSE 7848
// begin Say ( Roth , D2-Roth-2 ) ;
7824: LD_EXP 17
7828: PPUSH
7829: LD_STRING D2-Roth-2
7831: PPUSH
7832: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7836: LD_EXP 16
7840: PPUSH
7841: LD_STRING D2-JMM-1a
7843: PPUSH
7844: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7848: LD_EXP 17
7852: PPUSH
7853: LD_STRING D2-Roth-2a
7855: PPUSH
7856: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7860: LD_EXP 17
7864: PPUSH
7865: LD_STRING D2-Roth-2b
7867: PPUSH
7868: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7872: LD_EXP 16
7876: PPUSH
7877: LD_STRING D2-JMM-3
7879: PPUSH
7880: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7884: LD_VAR 0 2
7888: PPUSH
7889: LD_INT 3
7891: PUSH
7892: LD_INT 24
7894: PUSH
7895: LD_INT 1000
7897: PUSH
7898: EMPTY
7899: LIST
7900: LIST
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: PPUSH
7906: CALL_OW 72
7910: IFFALSE 7948
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7912: LD_EXP 33
7916: PPUSH
7917: LD_STRING D2-Gos-3
7919: PPUSH
7920: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7924: LD_EXP 16
7928: PPUSH
7929: LD_STRING D2-JMM-4
7931: PPUSH
7932: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7936: LD_EXP 33
7940: PPUSH
7941: LD_STRING D2-Gos-4
7943: PPUSH
7944: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7948: LD_EXP 16
7952: PPUSH
7953: LD_STRING D2-JMM-5
7955: PPUSH
7956: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7960: LD_EXP 33
7964: PPUSH
7965: LD_STRING D2-Gos-5
7967: PPUSH
7968: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7972: LD_EXP 16
7976: PPUSH
7977: LD_STRING D2-JMM-6
7979: PPUSH
7980: CALL_OW 88
// DialogueOff ;
7984: CALL_OW 7
// wait ( 0 0$2 ) ;
7988: LD_INT 70
7990: PPUSH
7991: CALL_OW 67
// if Kirilenkova then
7995: LD_EXP 34
7999: IFFALSE 8013
// Say ( Kirilenkova , D3-Kir-1 ) ;
8001: LD_EXP 34
8005: PPUSH
8006: LD_STRING D3-Kir-1
8008: PPUSH
8009: CALL_OW 88
// gossudarov_arrive := true ;
8013: LD_ADDR_EXP 4
8017: PUSH
8018: LD_INT 1
8020: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8021: LD_INT 35
8023: PPUSH
8024: CALL_OW 67
// until ru_lab_builded ;
8028: LD_EXP 5
8032: IFFALSE 8021
// DialogueOn ;
8034: CALL_OW 6
// if Kirilenkova then
8038: LD_EXP 34
8042: IFFALSE 8058
// Say ( Kirilenkova , D3a-Kir-1 ) else
8044: LD_EXP 34
8048: PPUSH
8049: LD_STRING D3a-Kir-1
8051: PPUSH
8052: CALL_OW 88
8056: GO 8080
// begin un := SciRu ;
8058: LD_ADDR_VAR 0 4
8062: PUSH
8063: CALL 13238 0 0
8067: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8068: LD_VAR 0 4
8072: PPUSH
8073: LD_STRING D3a-Sci1-1
8075: PPUSH
8076: CALL_OW 88
// end ; if Kirilenkova or un then
8080: LD_EXP 34
8084: PUSH
8085: LD_VAR 0 4
8089: OR
8090: IFFALSE 8104
// Say ( JMM , D3a-JMM-1 ) ;
8092: LD_EXP 16
8096: PPUSH
8097: LD_STRING D3a-JMM-1
8099: PPUSH
8100: CALL_OW 88
// DialogueOff ;
8104: CALL_OW 7
// end ;
8108: LD_VAR 0 1
8112: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8113: LD_EXP 4
8117: PUSH
8118: LD_INT 22
8120: PUSH
8121: LD_INT 7
8123: PUSH
8124: EMPTY
8125: LIST
8126: LIST
8127: PUSH
8128: LD_INT 2
8130: PUSH
8131: LD_INT 25
8133: PUSH
8134: LD_INT 1
8136: PUSH
8137: EMPTY
8138: LIST
8139: LIST
8140: PUSH
8141: LD_INT 25
8143: PUSH
8144: LD_INT 2
8146: PUSH
8147: EMPTY
8148: LIST
8149: LIST
8150: PUSH
8151: LD_INT 25
8153: PUSH
8154: LD_INT 3
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: PUSH
8161: LD_INT 25
8163: PUSH
8164: LD_INT 4
8166: PUSH
8167: EMPTY
8168: LIST
8169: LIST
8170: PUSH
8171: LD_INT 25
8173: PUSH
8174: LD_INT 5
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 25
8183: PUSH
8184: LD_INT 8
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 25
8193: PUSH
8194: LD_INT 9
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: LIST
8205: LIST
8206: LIST
8207: LIST
8208: LIST
8209: LIST
8210: PUSH
8211: EMPTY
8212: LIST
8213: LIST
8214: PPUSH
8215: CALL_OW 69
8219: PUSH
8220: LD_INT 7
8222: LESS
8223: AND
8224: IFFALSE 8236
8226: GO 8228
8228: DISABLE
// YouLost ( TooMany ) ;
8229: LD_STRING TooMany
8231: PPUSH
8232: CALL_OW 104
8236: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8237: LD_EXP 33
8241: PPUSH
8242: CALL_OW 255
8246: PUSH
8247: LD_INT 7
8249: EQUAL
8250: IFFALSE 8467
8252: GO 8254
8254: DISABLE
8255: LD_INT 0
8257: PPUSH
8258: PPUSH
8259: PPUSH
// begin uc_side := 3 ;
8260: LD_ADDR_OWVAR 20
8264: PUSH
8265: LD_INT 3
8267: ST_TO_ADDR
// uc_nation := 3 ;
8268: LD_ADDR_OWVAR 21
8272: PUSH
8273: LD_INT 3
8275: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8276: LD_INT 21
8278: PPUSH
8279: LD_INT 3
8281: PPUSH
8282: LD_INT 3
8284: PPUSH
8285: LD_INT 42
8287: PPUSH
8288: LD_INT 100
8290: PPUSH
8291: CALL 19869 0 5
// un := CreateVehicle ;
8295: LD_ADDR_VAR 0 3
8299: PUSH
8300: CALL_OW 45
8304: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8305: LD_VAR 0 3
8309: PPUSH
8310: LD_INT 15
8312: PPUSH
8313: LD_INT 0
8315: PPUSH
8316: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8320: LD_VAR 0 3
8324: PPUSH
8325: LD_INT 67
8327: PPUSH
8328: LD_INT 45
8330: PPUSH
8331: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8335: LD_VAR 0 3
8339: PPUSH
8340: LD_INT 70
8342: PPUSH
8343: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8347: LD_VAR 0 3
8351: PPUSH
8352: LD_INT 69
8354: PPUSH
8355: LD_INT 18
8357: PPUSH
8358: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8362: LD_VAR 0 3
8366: PPUSH
8367: LD_INT 60
8369: PPUSH
8370: LD_INT 3
8372: PPUSH
8373: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8377: LD_INT 35
8379: PPUSH
8380: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8384: LD_VAR 0 3
8388: PPUSH
8389: CALL_OW 302
8393: NOT
8394: PUSH
8395: LD_VAR 0 3
8399: PPUSH
8400: LD_INT 17
8402: PPUSH
8403: CALL_OW 308
8407: OR
8408: PUSH
8409: LD_VAR 0 3
8413: PPUSH
8414: LD_INT 60
8416: PPUSH
8417: LD_INT 3
8419: PPUSH
8420: CALL_OW 307
8424: OR
8425: IFFALSE 8377
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8427: LD_VAR 0 3
8431: PPUSH
8432: LD_INT 17
8434: PPUSH
8435: CALL_OW 308
8439: PUSH
8440: LD_VAR 0 3
8444: PPUSH
8445: LD_INT 60
8447: PPUSH
8448: LD_INT 3
8450: PPUSH
8451: CALL_OW 307
8455: OR
8456: IFFALSE 8467
// RemoveUnit ( un ) ;
8458: LD_VAR 0 3
8462: PPUSH
8463: CALL_OW 64
// end ;
8467: PPOPN 3
8469: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8470: LD_EXP 4
8474: IFFALSE 8716
8476: GO 8478
8478: DISABLE
8479: LD_INT 0
8481: PPUSH
8482: PPUSH
8483: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8484: LD_INT 70
8486: PPUSH
8487: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8491: LD_ADDR_VAR 0 3
8495: PUSH
8496: LD_INT 22
8498: PUSH
8499: LD_INT 7
8501: PUSH
8502: EMPTY
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 101
8508: PUSH
8509: LD_INT 3
8511: PUSH
8512: EMPTY
8513: LIST
8514: LIST
8515: PUSH
8516: EMPTY
8517: LIST
8518: LIST
8519: PPUSH
8520: CALL_OW 69
8524: ST_TO_ADDR
// until tmp ;
8525: LD_VAR 0 3
8529: IFFALSE 8484
// un := NearestUnitToUnit ( tmp , JMM ) ;
8531: LD_ADDR_VAR 0 2
8535: PUSH
8536: LD_VAR 0 3
8540: PPUSH
8541: LD_EXP 16
8545: PPUSH
8546: CALL_OW 74
8550: ST_TO_ADDR
// player_spotted := true ;
8551: LD_ADDR_EXP 6
8555: PUSH
8556: LD_INT 1
8558: ST_TO_ADDR
// tmp := SciRu ;
8559: LD_ADDR_VAR 0 3
8563: PUSH
8564: CALL 13238 0 0
8568: ST_TO_ADDR
// if not tmp then
8569: LD_VAR 0 3
8573: NOT
8574: IFFALSE 8586
// tmp := SolRu ;
8576: LD_ADDR_VAR 0 3
8580: PUSH
8581: CALL 13385 0 0
8585: ST_TO_ADDR
// DialogueOn ;
8586: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8590: LD_VAR 0 2
8594: PPUSH
8595: CALL_OW 250
8599: PPUSH
8600: LD_VAR 0 2
8604: PPUSH
8605: CALL_OW 251
8609: PPUSH
8610: LD_INT 7
8612: PPUSH
8613: LD_INT 8
8615: NEG
8616: PPUSH
8617: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8621: LD_VAR 0 2
8625: PPUSH
8626: CALL_OW 87
// if tmp then
8630: LD_VAR 0 3
8634: IFFALSE 8648
// Say ( tmp , D4-RSci1-1 ) ;
8636: LD_VAR 0 3
8640: PPUSH
8641: LD_STRING D4-RSci1-1
8643: PPUSH
8644: CALL_OW 88
// if Gossudarov then
8648: LD_EXP 33
8652: IFFALSE 8678
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8654: LD_EXP 33
8658: PPUSH
8659: LD_STRING D4-Gos-1
8661: PPUSH
8662: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8666: LD_EXP 16
8670: PPUSH
8671: LD_STRING D4-JMM-1
8673: PPUSH
8674: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8678: LD_VAR 0 2
8682: PPUSH
8683: CALL_OW 250
8687: PPUSH
8688: LD_VAR 0 2
8692: PPUSH
8693: CALL_OW 251
8697: PPUSH
8698: LD_INT 7
8700: PPUSH
8701: CALL_OW 331
// DialogueOff ;
8705: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8709: LD_STRING M5
8711: PPUSH
8712: CALL_OW 337
// end ;
8716: PPOPN 3
8718: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8719: LD_EXP 6
8723: IFFALSE 9316
8725: GO 8727
8727: DISABLE
8728: LD_INT 0
8730: PPUSH
8731: PPUSH
8732: PPUSH
// begin PrepareBelkov ;
8733: CALL 2188 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8737: LD_EXP 48
8741: PPUSH
8742: LD_INT 118
8744: PPUSH
8745: LD_INT 106
8747: PPUSH
8748: CALL_OW 111
// AddComHold ( Belkov ) ;
8752: LD_EXP 48
8756: PPUSH
8757: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8761: LD_INT 35
8763: PPUSH
8764: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8768: LD_EXP 48
8772: PPUSH
8773: LD_INT 118
8775: PPUSH
8776: LD_INT 106
8778: PPUSH
8779: CALL_OW 307
8783: IFFALSE 8761
// ChangeSideFog ( 4 , 7 ) ;
8785: LD_INT 4
8787: PPUSH
8788: LD_INT 7
8790: PPUSH
8791: CALL_OW 343
// if IsOk ( Belkov ) then
8795: LD_EXP 48
8799: PPUSH
8800: CALL_OW 302
8804: IFFALSE 8888
// begin InGameOn ;
8806: CALL_OW 8
// DialogueOn ;
8810: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8814: LD_EXP 48
8818: PPUSH
8819: LD_STRING D5-Bel-1
8821: PPUSH
8822: CALL_OW 94
// if Gossudarov then
8826: LD_EXP 33
8830: IFFALSE 8880
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8832: LD_EXP 33
8836: PPUSH
8837: LD_STRING D5-Gos-1
8839: PPUSH
8840: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8844: LD_EXP 16
8848: PPUSH
8849: LD_STRING D5-JMM-1
8851: PPUSH
8852: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8856: LD_EXP 33
8860: PPUSH
8861: LD_STRING D5-Gos-2
8863: PPUSH
8864: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8868: LD_EXP 16
8872: PPUSH
8873: LD_STRING D5-JMM-2
8875: PPUSH
8876: CALL_OW 88
// end ; DialogueOff ;
8880: CALL_OW 7
// InGameOff ;
8884: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8888: LD_STRING QSaveBelkov
8890: PPUSH
8891: CALL_OW 97
8895: PUSH
8896: LD_INT 1
8898: DOUBLE
8899: EQUAL
8900: IFTRUE 8904
8902: GO 8954
8904: POP
// begin DialogueOn ;
8905: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8909: LD_EXP 16
8913: PPUSH
8914: LD_STRING D5a-JMM-1
8916: PPUSH
8917: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8921: LD_EXP 48
8925: PPUSH
8926: LD_STRING D5a-Bel-1
8928: PPUSH
8929: CALL_OW 94
// DialogueOff ;
8933: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8937: LD_EXP 48
8941: PPUSH
8942: LD_INT 83
8944: PPUSH
8945: LD_INT 49
8947: PPUSH
8948: CALL_OW 111
// end ; 2 :
8952: GO 8987
8954: LD_INT 2
8956: DOUBLE
8957: EQUAL
8958: IFTRUE 8962
8960: GO 8986
8962: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8963: LD_EXP 16
8967: PPUSH
8968: LD_STRING D5a-JMM-2
8970: PPUSH
8971: CALL_OW 88
// ComHold ( Belkov ) ;
8975: LD_EXP 48
8979: PPUSH
8980: CALL_OW 140
// end ; end ;
8984: GO 8987
8986: POP
// time := 0 0$00 ;
8987: LD_ADDR_VAR 0 1
8991: PUSH
8992: LD_INT 0
8994: ST_TO_ADDR
// vehSpawned := false ;
8995: LD_ADDR_VAR 0 3
8999: PUSH
9000: LD_INT 0
9002: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9003: LD_INT 35
9005: PPUSH
9006: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
9010: LD_VAR 0 1
9014: PUSH
9015: LD_INT 350
9017: PUSH
9018: LD_INT 175
9020: PUSH
9021: LD_INT 105
9023: PUSH
9024: LD_INT 70
9026: PUSH
9027: EMPTY
9028: LIST
9029: LIST
9030: LIST
9031: LIST
9032: PUSH
9033: LD_OWVAR 67
9037: ARRAY
9038: GREATEREQUAL
9039: PUSH
9040: LD_VAR 0 3
9044: NOT
9045: AND
9046: IFFALSE 9136
// begin vehSpawned := true ;
9048: LD_ADDR_VAR 0 3
9052: PUSH
9053: LD_INT 1
9055: ST_TO_ADDR
// uc_side := 3 ;
9056: LD_ADDR_OWVAR 20
9060: PUSH
9061: LD_INT 3
9063: ST_TO_ADDR
// uc_nation := 3 ;
9064: LD_ADDR_OWVAR 21
9068: PUSH
9069: LD_INT 3
9071: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9072: LD_INT 22
9074: PPUSH
9075: LD_INT 3
9077: PPUSH
9078: LD_INT 3
9080: PPUSH
9081: LD_INT 43
9083: PPUSH
9084: LD_INT 100
9086: PPUSH
9087: CALL 19869 0 5
// veh := CreateVehicle ;
9091: LD_ADDR_VAR 0 2
9095: PUSH
9096: CALL_OW 45
9100: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9101: LD_VAR 0 2
9105: PPUSH
9106: LD_INT 130
9108: PPUSH
9109: LD_INT 131
9111: PPUSH
9112: LD_INT 0
9114: PPUSH
9115: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9119: LD_VAR 0 2
9123: PPUSH
9124: LD_INT 100
9126: PPUSH
9127: LD_INT 82
9129: PPUSH
9130: CALL_OW 114
// end else
9134: GO 9150
// time := time + 0 0$1 ;
9136: LD_ADDR_VAR 0 1
9140: PUSH
9141: LD_VAR 0 1
9145: PUSH
9146: LD_INT 35
9148: PLUS
9149: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9150: LD_EXP 48
9154: PPUSH
9155: CALL_OW 301
9159: PUSH
9160: LD_EXP 48
9164: PPUSH
9165: CALL_OW 255
9169: PUSH
9170: LD_INT 4
9172: EQUAL
9173: AND
9174: PUSH
9175: LD_INT 22
9177: PUSH
9178: LD_INT 7
9180: PUSH
9181: EMPTY
9182: LIST
9183: LIST
9184: PPUSH
9185: CALL_OW 69
9189: PPUSH
9190: LD_EXP 48
9194: PPUSH
9195: CALL_OW 74
9199: PPUSH
9200: LD_EXP 48
9204: PPUSH
9205: CALL_OW 296
9209: PUSH
9210: LD_INT 10
9212: LESS
9213: OR
9214: IFFALSE 9003
// if IsDead ( Belkov ) then
9216: LD_EXP 48
9220: PPUSH
9221: CALL_OW 301
9225: IFFALSE 9250
// begin CenterNowOnUnits ( Belkov ) ;
9227: LD_EXP 48
9231: PPUSH
9232: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9236: LD_EXP 16
9240: PPUSH
9241: LD_STRING D5a-JMM-2a
9243: PPUSH
9244: CALL_OW 88
// exit ;
9248: GO 9316
// end ; if See ( 7 , Belkov ) then
9250: LD_INT 7
9252: PPUSH
9253: LD_EXP 48
9257: PPUSH
9258: CALL_OW 292
9262: IFFALSE 9276
// SetSide ( Belkov , 7 ) ;
9264: LD_EXP 48
9268: PPUSH
9269: LD_INT 7
9271: PPUSH
9272: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9276: LD_INT 35
9278: PPUSH
9279: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9283: LD_EXP 48
9287: PPUSH
9288: LD_INT 66
9290: PPUSH
9291: LD_INT 45
9293: PPUSH
9294: CALL_OW 297
9298: PUSH
9299: LD_INT 30
9301: LESS
9302: IFFALSE 9276
// Say ( Belkov , D6-Bel-1 ) ;
9304: LD_EXP 48
9308: PPUSH
9309: LD_STRING D6-Bel-1
9311: PPUSH
9312: CALL_OW 88
// end ;
9316: PPOPN 3
9318: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9319: LD_EXP 48
9323: PPUSH
9324: CALL_OW 302
9328: PUSH
9329: LD_EXP 48
9333: PPUSH
9334: CALL_OW 504
9338: PUSH
9339: LD_INT 2
9341: PUSH
9342: LD_INT 34
9344: PUSH
9345: LD_INT 47
9347: PUSH
9348: EMPTY
9349: LIST
9350: LIST
9351: PUSH
9352: LD_INT 34
9354: PUSH
9355: LD_INT 45
9357: PUSH
9358: EMPTY
9359: LIST
9360: LIST
9361: PUSH
9362: EMPTY
9363: LIST
9364: LIST
9365: LIST
9366: PPUSH
9367: CALL_OW 69
9371: IN
9372: AND
9373: IFFALSE 9390
9375: GO 9377
9377: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9378: LD_EXP 48
9382: PPUSH
9383: LD_STRING D7-Bel-1
9385: PPUSH
9386: CALL_OW 88
9390: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9391: LD_INT 22
9393: PUSH
9394: LD_INT 7
9396: PUSH
9397: EMPTY
9398: LIST
9399: LIST
9400: PUSH
9401: LD_INT 101
9403: PUSH
9404: LD_INT 2
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: PUSH
9411: EMPTY
9412: LIST
9413: LIST
9414: PPUSH
9415: CALL_OW 69
9419: PUSH
9420: LD_EXP 8
9424: NOT
9425: AND
9426: PUSH
9427: LD_EXP 47
9431: PPUSH
9432: CALL_OW 305
9436: NOT
9437: AND
9438: IFFALSE 9908
9440: GO 9442
9442: DISABLE
9443: LD_INT 0
9445: PPUSH
// begin ar_base_spotted := true ;
9446: LD_ADDR_EXP 8
9450: PUSH
9451: LD_INT 1
9453: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9454: LD_ADDR_VAR 0 1
9458: PUSH
9459: LD_INT 22
9461: PUSH
9462: LD_INT 2
9464: PUSH
9465: EMPTY
9466: LIST
9467: LIST
9468: PUSH
9469: LD_INT 21
9471: PUSH
9472: LD_INT 3
9474: PUSH
9475: EMPTY
9476: LIST
9477: LIST
9478: PUSH
9479: EMPTY
9480: LIST
9481: LIST
9482: PPUSH
9483: CALL_OW 69
9487: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9488: LD_ADDR_VAR 0 1
9492: PUSH
9493: LD_VAR 0 1
9497: PPUSH
9498: LD_EXP 16
9502: PPUSH
9503: CALL_OW 74
9507: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9508: LD_INT 7
9510: PPUSH
9511: LD_INT 3
9513: PPUSH
9514: CALL_OW 332
// DialogueOn ;
9518: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9522: LD_VAR 0 1
9526: PPUSH
9527: CALL_OW 250
9531: PPUSH
9532: LD_VAR 0 1
9536: PPUSH
9537: CALL_OW 251
9541: PPUSH
9542: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9546: LD_ADDR_VAR 0 1
9550: PUSH
9551: LD_INT 22
9553: PUSH
9554: LD_INT 7
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PUSH
9561: LD_INT 23
9563: PUSH
9564: LD_INT 1
9566: PUSH
9567: EMPTY
9568: LIST
9569: LIST
9570: PUSH
9571: LD_INT 26
9573: PUSH
9574: LD_INT 1
9576: PUSH
9577: EMPTY
9578: LIST
9579: LIST
9580: PUSH
9581: EMPTY
9582: LIST
9583: LIST
9584: LIST
9585: PPUSH
9586: CALL_OW 69
9590: PUSH
9591: LD_EXP 16
9595: PUSH
9596: LD_EXP 20
9600: PUSH
9601: LD_EXP 21
9605: PUSH
9606: LD_EXP 28
9610: PUSH
9611: LD_EXP 17
9615: PUSH
9616: LD_EXP 26
9620: PUSH
9621: LD_EXP 22
9625: PUSH
9626: LD_EXP 24
9630: PUSH
9631: EMPTY
9632: LIST
9633: LIST
9634: LIST
9635: LIST
9636: LIST
9637: LIST
9638: LIST
9639: LIST
9640: DIFF
9641: ST_TO_ADDR
// if not tmp then
9642: LD_VAR 0 1
9646: NOT
9647: IFFALSE 9721
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9649: LD_ADDR_VAR 0 1
9653: PUSH
9654: LD_INT 22
9656: PUSH
9657: LD_INT 7
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: PUSH
9664: LD_INT 23
9666: PUSH
9667: LD_INT 1
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: PUSH
9674: LD_INT 26
9676: PUSH
9677: LD_INT 2
9679: PUSH
9680: EMPTY
9681: LIST
9682: LIST
9683: PUSH
9684: EMPTY
9685: LIST
9686: LIST
9687: LIST
9688: PPUSH
9689: CALL_OW 69
9693: PUSH
9694: LD_EXP 31
9698: PUSH
9699: LD_EXP 18
9703: PUSH
9704: LD_EXP 29
9708: PUSH
9709: LD_EXP 30
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: LIST
9718: LIST
9719: DIFF
9720: ST_TO_ADDR
// if tmp then
9721: LD_VAR 0 1
9725: IFFALSE 9796
// case GetSex ( tmp [ 1 ] ) of sex_male :
9727: LD_VAR 0 1
9731: PUSH
9732: LD_INT 1
9734: ARRAY
9735: PPUSH
9736: CALL_OW 258
9740: PUSH
9741: LD_INT 1
9743: DOUBLE
9744: EQUAL
9745: IFTRUE 9749
9747: GO 9768
9749: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9750: LD_VAR 0 1
9754: PUSH
9755: LD_INT 1
9757: ARRAY
9758: PPUSH
9759: LD_STRING D9-Sol1-1
9761: PPUSH
9762: CALL_OW 88
9766: GO 9796
9768: LD_INT 2
9770: DOUBLE
9771: EQUAL
9772: IFTRUE 9776
9774: GO 9795
9776: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9777: LD_VAR 0 1
9781: PUSH
9782: LD_INT 1
9784: ARRAY
9785: PPUSH
9786: LD_STRING D9-FSol1-1
9788: PPUSH
9789: CALL_OW 88
9793: GO 9796
9795: POP
// if Frank then
9796: LD_EXP 28
9800: IFFALSE 9904
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9802: LD_EXP 57
9806: PPUSH
9807: CALL_OW 250
9811: PPUSH
9812: LD_EXP 57
9816: PPUSH
9817: CALL_OW 251
9821: PPUSH
9822: LD_INT 7
9824: PPUSH
9825: LD_INT 8
9827: PPUSH
9828: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9832: LD_EXP 57
9836: PPUSH
9837: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9841: LD_EXP 28
9845: PPUSH
9846: LD_STRING D9-Frank-1
9848: PPUSH
9849: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9853: LD_EXP 16
9857: PPUSH
9858: LD_STRING D9-JMM-1
9860: PPUSH
9861: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9865: LD_EXP 28
9869: PPUSH
9870: LD_STRING D9-Frank-2
9872: PPUSH
9873: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9877: LD_EXP 57
9881: PPUSH
9882: CALL_OW 250
9886: PPUSH
9887: LD_EXP 57
9891: PPUSH
9892: CALL_OW 251
9896: PPUSH
9897: LD_INT 7
9899: PPUSH
9900: CALL_OW 331
// end ; DialogueOff ;
9904: CALL_OW 7
// end ;
9908: PPOPN 1
9910: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9911: LD_EXP 7
9915: PUSH
9916: LD_OWVAR 1
9920: PUSH
9921: LD_INT 42000
9923: GREATEREQUAL
9924: OR
9925: IFFALSE 10952
9927: GO 9929
9929: DISABLE
9930: LD_INT 0
9932: PPUSH
9933: PPUSH
// begin selected_option := 1 ;
9934: LD_ADDR_VAR 0 2
9938: PUSH
9939: LD_INT 1
9941: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9942: LD_INT 10500
9944: PPUSH
9945: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9949: LD_INT 35
9951: PPUSH
9952: CALL_OW 67
// until not ru_attackers ;
9956: LD_EXP 53
9960: NOT
9961: IFFALSE 9949
// PrepareBurlak ;
9963: CALL 2300 0 0
// repeat wait ( 0 0$2 ) ;
9967: LD_INT 70
9969: PPUSH
9970: CALL_OW 67
// until not HasTask ( Burlak ) ;
9974: LD_EXP 47
9978: PPUSH
9979: CALL_OW 314
9983: NOT
9984: IFFALSE 9967
// InGameOn ;
9986: CALL_OW 8
// DialogueOn ;
9990: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9994: LD_EXP 50
9998: PPUSH
9999: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
10003: LD_EXP 47
10007: PPUSH
10008: LD_STRING D10-Bur-1
10010: PPUSH
10011: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
10015: LD_EXP 48
10019: PUSH
10020: LD_EXP 48
10024: PPUSH
10025: CALL_OW 255
10029: PUSH
10030: LD_INT 7
10032: EQUAL
10033: AND
10034: IFFALSE 10048
// Say ( Belkov , D10-Bel-1 ) ;
10036: LD_EXP 48
10040: PPUSH
10041: LD_STRING D10-Bel-1
10043: PPUSH
10044: CALL_OW 88
// if Gossudarov then
10048: LD_EXP 33
10052: IFFALSE 10066
// Say ( Gossudarov , D10-Gos-1 ) ;
10054: LD_EXP 33
10058: PPUSH
10059: LD_STRING D10-Gos-1
10061: PPUSH
10062: CALL_OW 88
// if Kirilenkova then
10066: LD_EXP 34
10070: IFFALSE 10084
// Say ( Kirilenkova , D10-Kir-1 ) ;
10072: LD_EXP 34
10076: PPUSH
10077: LD_STRING D10-Kir-1
10079: PPUSH
10080: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10084: CALL 13385 0 0
10088: PPUSH
10089: LD_STRING D10-RSol1-1
10091: PPUSH
10092: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10096: LD_EXP 47
10100: PPUSH
10101: LD_STRING D10-Bur-2
10103: PPUSH
10104: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10108: LD_EXP 16
10112: PPUSH
10113: LD_STRING D10-JMM-2
10115: PPUSH
10116: CALL_OW 88
// if Kirilenkova then
10120: LD_EXP 34
10124: IFFALSE 10140
// Say ( Kirilenkova , D10-Kir-2 ) else
10126: LD_EXP 34
10130: PPUSH
10131: LD_STRING D10-Kir-2
10133: PPUSH
10134: CALL_OW 88
10138: GO 10152
// Say ( SolRu , D10-RSol1-2 ) ;
10140: CALL 13385 0 0
10144: PPUSH
10145: LD_STRING D10-RSol1-2
10147: PPUSH
10148: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10152: LD_EXP 16
10156: PPUSH
10157: LD_STRING D10-JMM-3
10159: PPUSH
10160: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10164: LD_EXP 47
10168: PPUSH
10169: LD_STRING D10-Bur-3
10171: PPUSH
10172: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10176: LD_EXP 16
10180: PPUSH
10181: LD_STRING D10-JMM-4
10183: PPUSH
10184: CALL_OW 88
// DialogueOff ;
10188: CALL_OW 7
// InGameOff ;
10192: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10196: LD_STRING M2
10198: PPUSH
10199: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10203: LD_INT 35
10205: PPUSH
10206: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10210: LD_INT 22
10212: PUSH
10213: LD_INT 7
10215: PUSH
10216: EMPTY
10217: LIST
10218: LIST
10219: PUSH
10220: LD_INT 91
10222: PUSH
10223: LD_EXP 47
10227: PUSH
10228: LD_INT 8
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: LIST
10235: PUSH
10236: EMPTY
10237: LIST
10238: LIST
10239: PPUSH
10240: CALL_OW 69
10244: IFFALSE 10203
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10246: LD_ADDR_VAR 0 1
10250: PUSH
10251: LD_INT 22
10253: PUSH
10254: LD_INT 4
10256: PUSH
10257: EMPTY
10258: LIST
10259: LIST
10260: PPUSH
10261: CALL_OW 69
10265: PUSH
10266: FOR_IN
10267: IFFALSE 10283
// SetSide ( i , 7 ) ;
10269: LD_VAR 0 1
10273: PPUSH
10274: LD_INT 7
10276: PPUSH
10277: CALL_OW 235
10281: GO 10266
10283: POP
10284: POP
// ChangeMissionObjectives ( M3 ) ;
10285: LD_STRING M3
10287: PPUSH
10288: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10292: LD_INT 35
10294: PPUSH
10295: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10299: LD_EXP 16
10303: PPUSH
10304: LD_EXP 47
10308: PPUSH
10309: CALL_OW 296
10313: PUSH
10314: LD_INT 8
10316: LESS
10317: IFFALSE 10292
// ComTurnUnit ( JMM , Burlak ) ;
10319: LD_EXP 16
10323: PPUSH
10324: LD_EXP 47
10328: PPUSH
10329: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10333: LD_EXP 47
10337: PPUSH
10338: LD_EXP 16
10342: PPUSH
10343: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10347: LD_INT 10
10349: PPUSH
10350: CALL_OW 67
// DialogueOn ;
10354: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10358: LD_EXP 16
10362: PPUSH
10363: LD_STRING D11-JMM-1
10365: PPUSH
10366: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10370: LD_EXP 47
10374: PPUSH
10375: LD_STRING D11-Bur-1
10377: PPUSH
10378: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10382: LD_EXP 16
10386: PPUSH
10387: LD_STRING D11-JMM-2
10389: PPUSH
10390: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10394: LD_EXP 47
10398: PPUSH
10399: LD_STRING D11-Bur-2
10401: PPUSH
10402: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10406: LD_EXP 16
10410: PPUSH
10411: LD_STRING D11-JMM-3
10413: PPUSH
10414: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10418: LD_EXP 47
10422: PPUSH
10423: LD_STRING D11-Bur-3
10425: PPUSH
10426: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10430: LD_EXP 16
10434: PPUSH
10435: LD_STRING D11-JMM-4
10437: PPUSH
10438: CALL_OW 88
// if ar_base_spotted then
10442: LD_EXP 8
10446: IFFALSE 10462
// Say ( Burlak , D12-Bur-1 ) else
10448: LD_EXP 47
10452: PPUSH
10453: LD_STRING D12-Bur-1
10455: PPUSH
10456: CALL_OW 88
10460: GO 10501
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10462: LD_INT 7
10464: PPUSH
10465: LD_INT 3
10467: PPUSH
10468: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10472: LD_INT 127
10474: PPUSH
10475: LD_INT 45
10477: PPUSH
10478: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10482: LD_EXP 47
10486: PPUSH
10487: LD_STRING D12-Bur-1a
10489: PPUSH
10490: CALL_OW 88
// dwait ( 0 0$2 ) ;
10494: LD_INT 70
10496: PPUSH
10497: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10501: LD_EXP 47
10505: PPUSH
10506: LD_STRING D12-Bur-1b
10508: PPUSH
10509: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10513: LD_EXP 16
10517: PPUSH
10518: LD_STRING D12-JMM-1
10520: PPUSH
10521: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10525: LD_EXP 47
10529: PPUSH
10530: LD_STRING D12-Bur-2
10532: PPUSH
10533: CALL_OW 88
// if Roth then
10537: LD_EXP 17
10541: IFFALSE 10557
// Say ( Roth , D12-Roth-2 ) else
10543: LD_EXP 17
10547: PPUSH
10548: LD_STRING D12-Roth-2
10550: PPUSH
10551: CALL_OW 88
10555: GO 10569
// Say ( SciRu , D12-RSci1-2 ) ;
10557: CALL 13238 0 0
10561: PPUSH
10562: LD_STRING D12-RSci1-2
10564: PPUSH
10565: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10569: LD_EXP 16
10573: PPUSH
10574: LD_STRING D12-JMM-2
10576: PPUSH
10577: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10581: LD_EXP 47
10585: PPUSH
10586: LD_STRING D12-Bur-3
10588: PPUSH
10589: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10593: LD_EXP 16
10597: PPUSH
10598: LD_STRING D12-JMM-3
10600: PPUSH
10601: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10605: LD_EXP 47
10609: PPUSH
10610: LD_STRING D12-Bur-4
10612: PPUSH
10613: CALL_OW 88
// case Query ( QBase ) of 1 :
10617: LD_STRING QBase
10619: PPUSH
10620: CALL_OW 97
10624: PUSH
10625: LD_INT 1
10627: DOUBLE
10628: EQUAL
10629: IFTRUE 10633
10631: GO 10751
10633: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10634: LD_EXP 16
10638: PPUSH
10639: LD_STRING D13a-JMM-1
10641: PPUSH
10642: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10646: LD_EXP 47
10650: PPUSH
10651: LD_STRING D13a-Bur-1
10653: PPUSH
10654: CALL_OW 88
// if Roth then
10658: LD_EXP 17
10662: IFFALSE 10678
// Say ( Roth , D13a-Roth-1 ) else
10664: LD_EXP 17
10668: PPUSH
10669: LD_STRING D13a-Roth-1
10671: PPUSH
10672: CALL_OW 88
10676: GO 10690
// Say ( SciRu , D13a-RSci1-1 ) ;
10678: CALL 13238 0 0
10682: PPUSH
10683: LD_STRING D13a-RSci1-1
10685: PPUSH
10686: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10690: LD_EXP 16
10694: PPUSH
10695: LD_STRING D13a-JMM-2
10697: PPUSH
10698: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10702: LD_STRING QBaseAgain
10704: PPUSH
10705: CALL_OW 97
10709: PUSH
10710: LD_INT 1
10712: DOUBLE
10713: EQUAL
10714: IFTRUE 10718
10716: GO 10729
10718: POP
// selected_option := 2 ; 2 :
10719: LD_ADDR_VAR 0 2
10723: PUSH
10724: LD_INT 2
10726: ST_TO_ADDR
10727: GO 10749
10729: LD_INT 2
10731: DOUBLE
10732: EQUAL
10733: IFTRUE 10737
10735: GO 10748
10737: POP
// selected_option := 3 ; end ;
10738: LD_ADDR_VAR 0 2
10742: PUSH
10743: LD_INT 3
10745: ST_TO_ADDR
10746: GO 10749
10748: POP
// end ; 2 :
10749: GO 10790
10751: LD_INT 2
10753: DOUBLE
10754: EQUAL
10755: IFTRUE 10759
10757: GO 10770
10759: POP
// selected_option := 2 ; 3 :
10760: LD_ADDR_VAR 0 2
10764: PUSH
10765: LD_INT 2
10767: ST_TO_ADDR
10768: GO 10790
10770: LD_INT 3
10772: DOUBLE
10773: EQUAL
10774: IFTRUE 10778
10776: GO 10789
10778: POP
// selected_option := 3 ; end ;
10779: LD_ADDR_VAR 0 2
10783: PUSH
10784: LD_INT 3
10786: ST_TO_ADDR
10787: GO 10790
10789: POP
// if selected_option = 2 then
10790: LD_VAR 0 2
10794: PUSH
10795: LD_INT 2
10797: EQUAL
10798: IFFALSE 10892
// begin Say ( JMM , D13b-JMM-1 ) ;
10800: LD_EXP 16
10804: PPUSH
10805: LD_STRING D13b-JMM-1
10807: PPUSH
10808: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10812: LD_EXP 47
10816: PPUSH
10817: LD_STRING D13b-Bur-1
10819: PPUSH
10820: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10824: LD_EXP 16
10828: PPUSH
10829: LD_STRING D13b-JMM-2
10831: PPUSH
10832: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10836: LD_EXP 56
10840: PPUSH
10841: LD_STRING D13b-Abd-2
10843: PPUSH
10844: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10848: LD_EXP 16
10852: PPUSH
10853: LD_STRING D13b-JMM-3
10855: PPUSH
10856: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10860: LD_EXP 56
10864: PPUSH
10865: LD_STRING D13b-Abd-3
10867: PPUSH
10868: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10872: LD_EXP 16
10876: PPUSH
10877: LD_STRING D13b-JMM-4
10879: PPUSH
10880: CALL_OW 88
// ar_active_attack := true ;
10884: LD_ADDR_EXP 9
10888: PUSH
10889: LD_INT 1
10891: ST_TO_ADDR
// end ; if selected_option = 3 then
10892: LD_VAR 0 2
10896: PUSH
10897: LD_INT 3
10899: EQUAL
10900: IFFALSE 10926
// begin Say ( JMM , D13c-JMM-1 ) ;
10902: LD_EXP 16
10906: PPUSH
10907: LD_STRING D13c-JMM-1
10909: PPUSH
10910: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10914: LD_EXP 47
10918: PPUSH
10919: LD_STRING D13c-Bur-1
10921: PPUSH
10922: CALL_OW 88
// end ; DialogueOff ;
10926: CALL_OW 7
// if not ar_active_attack then
10930: LD_EXP 9
10934: NOT
10935: IFFALSE 10952
// begin wait ( 6 6$00 ) ;
10937: LD_INT 12600
10939: PPUSH
10940: CALL_OW 67
// ar_active_attack := true ;
10944: LD_ADDR_EXP 9
10948: PUSH
10949: LD_INT 1
10951: ST_TO_ADDR
// end ; end ;
10952: PPOPN 2
10954: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10955: LD_EXP 47
10959: PPUSH
10960: CALL_OW 305
10964: PUSH
10965: LD_EXP 47
10969: PPUSH
10970: CALL_OW 255
10974: PUSH
10975: LD_INT 7
10977: EQUAL
10978: AND
10979: IFFALSE 11175
10981: GO 10983
10983: DISABLE
10984: LD_INT 0
10986: PPUSH
// begin wait ( 4 4$40 ) ;
10987: LD_INT 9800
10989: PPUSH
10990: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10994: LD_INT 35
10996: PPUSH
10997: CALL_OW 67
// until not ru_attackers ;
11001: LD_EXP 53
11005: NOT
11006: IFFALSE 10994
// PrepareGnyevko ;
11008: CALL 2244 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
11012: LD_EXP 49
11016: PPUSH
11017: LD_INT 124
11019: PPUSH
11020: LD_INT 118
11022: PPUSH
11023: CALL_OW 111
// AddComHold ( Gnyevko ) ;
11027: LD_EXP 49
11031: PPUSH
11032: CALL_OW 200
// time := 0 0$00 ;
11036: LD_ADDR_VAR 0 1
11040: PUSH
11041: LD_INT 0
11043: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11044: LD_INT 35
11046: PPUSH
11047: CALL_OW 67
// time := time + 0 0$1 ;
11051: LD_ADDR_VAR 0 1
11055: PUSH
11056: LD_VAR 0 1
11060: PUSH
11061: LD_INT 35
11063: PLUS
11064: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11065: LD_EXP 49
11069: PPUSH
11070: LD_INT 124
11072: PPUSH
11073: LD_INT 118
11075: PPUSH
11076: CALL_OW 307
11080: PUSH
11081: LD_VAR 0 1
11085: PUSH
11086: LD_INT 1050
11088: GREATEREQUAL
11089: OR
11090: IFFALSE 11044
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11092: LD_EXP 49
11096: PPUSH
11097: LD_STRING DBelkov-Gny-1
11099: PPUSH
11100: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11104: LD_EXP 47
11108: PPUSH
11109: LD_STRING DBelkov-Bur-1a
11111: PPUSH
11112: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11116: LD_INT 35
11118: PPUSH
11119: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11123: LD_EXP 49
11127: PPUSH
11128: LD_INT 22
11130: PUSH
11131: LD_INT 7
11133: PUSH
11134: EMPTY
11135: LIST
11136: LIST
11137: PPUSH
11138: CALL_OW 69
11142: PPUSH
11143: LD_EXP 49
11147: PPUSH
11148: CALL_OW 74
11152: PPUSH
11153: CALL_OW 296
11157: PUSH
11158: LD_INT 8
11160: LESS
11161: IFFALSE 11116
// SetSide ( Gnyevko , 7 ) ;
11163: LD_EXP 49
11167: PPUSH
11168: LD_INT 7
11170: PPUSH
11171: CALL_OW 235
// end ;
11175: PPOPN 1
11177: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11178: LD_EXP 47
11182: PPUSH
11183: CALL_OW 255
11187: PUSH
11188: LD_INT 7
11190: EQUAL
11191: IFFALSE 11201
11193: GO 11195
11195: DISABLE
// begin enable ;
11196: ENABLE
// PrepareAmericanAttack ;
11197: CALL 6843 0 0
// end ;
11201: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11202: LD_INT 22
11204: PUSH
11205: LD_INT 1
11207: PUSH
11208: EMPTY
11209: LIST
11210: LIST
11211: PPUSH
11212: CALL_OW 69
11216: IFFALSE 11400
11218: GO 11220
11220: DISABLE
11221: LD_INT 0
11223: PPUSH
11224: PPUSH
// begin while true do
11225: LD_INT 1
11227: IFFALSE 11284
// begin wait ( 0 0$1 ) ;
11229: LD_INT 35
11231: PPUSH
11232: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11236: LD_ADDR_VAR 0 2
11240: PUSH
11241: LD_INT 22
11243: PUSH
11244: LD_INT 1
11246: PUSH
11247: EMPTY
11248: LIST
11249: LIST
11250: PPUSH
11251: CALL_OW 69
11255: PPUSH
11256: LD_EXP 16
11260: PPUSH
11261: CALL_OW 74
11265: ST_TO_ADDR
// if See ( 7 , tmp ) then
11266: LD_INT 7
11268: PPUSH
11269: LD_VAR 0 2
11273: PPUSH
11274: CALL_OW 292
11278: IFFALSE 11282
// break ;
11280: GO 11284
// end ;
11282: GO 11225
// DialogueOn ;
11284: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11288: LD_VAR 0 2
11292: PPUSH
11293: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11297: LD_VAR 0 2
11301: PPUSH
11302: CALL_OW 250
11306: PPUSH
11307: LD_VAR 0 2
11311: PPUSH
11312: CALL_OW 251
11316: PPUSH
11317: LD_INT 7
11319: PPUSH
11320: LD_INT 8
11322: PPUSH
11323: CALL_OW 330
// if Denis then
11327: LD_EXP 22
11331: IFFALSE 11345
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11333: LD_EXP 22
11337: PPUSH
11338: LD_STRING DAmerAttack-Pet-1
11340: PPUSH
11341: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11345: LD_EXP 16
11349: PPUSH
11350: LD_STRING DAmerAttack-JMM-1
11352: PPUSH
11353: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11357: LD_EXP 47
11361: PPUSH
11362: LD_STRING DStop-Bur-1
11364: PPUSH
11365: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11369: LD_VAR 0 2
11373: PPUSH
11374: CALL_OW 250
11378: PPUSH
11379: LD_VAR 0 2
11383: PPUSH
11384: CALL_OW 251
11388: PPUSH
11389: LD_INT 7
11391: PPUSH
11392: CALL_OW 331
// DialogueOff ;
11396: CALL_OW 7
// end ;
11400: PPOPN 2
11402: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11403: LD_INT 22
11405: PUSH
11406: LD_INT 3
11408: PUSH
11409: EMPTY
11410: LIST
11411: LIST
11412: PUSH
11413: LD_INT 21
11415: PUSH
11416: LD_INT 1
11418: PUSH
11419: EMPTY
11420: LIST
11421: LIST
11422: PUSH
11423: EMPTY
11424: LIST
11425: LIST
11426: PPUSH
11427: CALL_OW 69
11431: PUSH
11432: LD_INT 0
11434: EQUAL
11435: IFFALSE 11477
11437: GO 11439
11439: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11440: LD_STRING M5a
11442: PPUSH
11443: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11447: LD_EXP 16
11451: PPUSH
11452: LD_STRING D8-JMM-1
11454: PPUSH
11455: CALL_OW 88
// if Gossudarov then
11459: LD_EXP 33
11463: IFFALSE 11477
// Say ( Gossudarov , D8-Gos-1 ) ;
11465: LD_EXP 33
11469: PPUSH
11470: LD_STRING D8-Gos-1
11472: PPUSH
11473: CALL_OW 88
// end ;
11477: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11478: LD_INT 22
11480: PUSH
11481: LD_INT 2
11483: PUSH
11484: EMPTY
11485: LIST
11486: LIST
11487: PUSH
11488: LD_INT 21
11490: PUSH
11491: LD_INT 1
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: PUSH
11498: EMPTY
11499: LIST
11500: LIST
11501: PPUSH
11502: CALL_OW 69
11506: PUSH
11507: LD_INT 0
11509: EQUAL
11510: IFFALSE 11560
11512: GO 11514
11514: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11515: LD_STRING M4c
11517: PPUSH
11518: CALL_OW 337
// if Roth then
11522: LD_EXP 17
11526: IFFALSE 11542
// Say ( Roth , DStop-Roth-1 ) else
11528: LD_EXP 17
11532: PPUSH
11533: LD_STRING DStop-Roth-1
11535: PPUSH
11536: CALL_OW 88
11540: GO 11560
// if Gossudarov then
11542: LD_EXP 33
11546: IFFALSE 11560
// Say ( Gossudarov , D8-Gos-1a ) ;
11548: LD_EXP 33
11552: PPUSH
11553: LD_STRING D8-Gos-1a
11555: PPUSH
11556: CALL_OW 88
// end ;
11560: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11561: LD_INT 7
11563: PPUSH
11564: LD_INT 1
11566: PPUSH
11567: LD_INT 1
11569: PPUSH
11570: CALL 14917 0 3
11574: PUSH
11575: LD_INT 0
11577: EQUAL
11578: PUSH
11579: LD_INT 7
11581: PPUSH
11582: LD_INT 3
11584: PPUSH
11585: LD_INT 1
11587: PPUSH
11588: CALL 14917 0 3
11592: PUSH
11593: LD_INT 0
11595: EQUAL
11596: AND
11597: IFFALSE 11609
11599: GO 11601
11601: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11602: LD_STRING M1a
11604: PPUSH
11605: CALL_OW 337
// end ;
11609: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
11610: LD_INT 22
11612: PUSH
11613: LD_INT 2
11615: PUSH
11616: EMPTY
11617: LIST
11618: LIST
11619: PUSH
11620: LD_INT 21
11622: PUSH
11623: LD_INT 1
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: PUSH
11630: EMPTY
11631: LIST
11632: LIST
11633: PPUSH
11634: CALL_OW 69
11638: PUSH
11639: LD_INT 0
11641: EQUAL
11642: PUSH
11643: LD_INT 22
11645: PUSH
11646: LD_INT 3
11648: PUSH
11649: EMPTY
11650: LIST
11651: LIST
11652: PUSH
11653: LD_INT 21
11655: PUSH
11656: LD_INT 1
11658: PUSH
11659: EMPTY
11660: LIST
11661: LIST
11662: PUSH
11663: EMPTY
11664: LIST
11665: LIST
11666: PPUSH
11667: CALL_OW 69
11671: PUSH
11672: LD_INT 0
11674: EQUAL
11675: AND
11676: PUSH
11677: LD_INT 22
11679: PUSH
11680: LD_INT 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PPUSH
11687: CALL_OW 69
11691: PUSH
11692: LD_INT 0
11694: EQUAL
11695: AND
11696: PUSH
11697: LD_INT 7
11699: PPUSH
11700: LD_INT 1
11702: PPUSH
11703: LD_INT 1
11705: PPUSH
11706: CALL 14917 0 3
11710: PUSH
11711: LD_INT 0
11713: EQUAL
11714: AND
11715: PUSH
11716: LD_INT 7
11718: PPUSH
11719: LD_INT 3
11721: PPUSH
11722: LD_INT 1
11724: PPUSH
11725: CALL 14917 0 3
11729: PUSH
11730: LD_INT 0
11732: EQUAL
11733: AND
11734: PUSH
11735: LD_EXP 47
11739: PPUSH
11740: CALL_OW 255
11744: PUSH
11745: LD_INT 7
11747: EQUAL
11748: AND
11749: PUSH
11750: LD_EXP 47
11754: PPUSH
11755: CALL_OW 302
11759: AND
11760: IFFALSE 13235
11762: GO 11764
11764: DISABLE
11765: LD_INT 0
11767: PPUSH
11768: PPUSH
11769: PPUSH
11770: PPUSH
11771: PPUSH
11772: PPUSH
// begin m1 := false ;
11773: LD_ADDR_VAR 0 4
11777: PUSH
11778: LD_INT 0
11780: ST_TO_ADDR
// m2 := false ;
11781: LD_ADDR_VAR 0 5
11785: PUSH
11786: LD_INT 0
11788: ST_TO_ADDR
// m3 := false ;
11789: LD_ADDR_VAR 0 6
11793: PUSH
11794: LD_INT 0
11796: ST_TO_ADDR
// if tick < 40 40$00 then
11797: LD_OWVAR 1
11801: PUSH
11802: LD_INT 84000
11804: LESS
11805: IFFALSE 11814
// SetAchievement ( ACH_ASPEED_17 ) ;
11807: LD_STRING ACH_ASPEED_17
11809: PPUSH
11810: CALL_OW 543
// wait ( 0 0$5 ) ;
11814: LD_INT 175
11816: PPUSH
11817: CALL_OW 67
// if not masha_killed then
11821: LD_EXP 10
11825: NOT
11826: IFFALSE 11848
// begin m1 := true ;
11828: LD_ADDR_VAR 0 4
11832: PUSH
11833: LD_INT 1
11835: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11836: LD_STRING Masha
11838: PPUSH
11839: LD_INT 1
11841: PPUSH
11842: CALL_OW 101
// end else
11846: GO 11859
// AddMedal ( Masha , - 1 ) ;
11848: LD_STRING Masha
11850: PPUSH
11851: LD_INT 1
11853: NEG
11854: PPUSH
11855: CALL_OW 101
// if abdul_escaped then
11859: LD_EXP 13
11863: IFFALSE 11878
// AddMedal ( Abdul , - 1 ) else
11865: LD_STRING Abdul
11867: PPUSH
11868: LD_INT 1
11870: NEG
11871: PPUSH
11872: CALL_OW 101
11876: GO 11896
// begin m2 := true ;
11878: LD_ADDR_VAR 0 5
11882: PUSH
11883: LD_INT 1
11885: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11886: LD_STRING Abdul
11888: PPUSH
11889: LD_INT 1
11891: PPUSH
11892: CALL_OW 101
// end ; if loss_counter = 0 then
11896: LD_EXP 14
11900: PUSH
11901: LD_INT 0
11903: EQUAL
11904: IFFALSE 11926
// begin m3 := true ;
11906: LD_ADDR_VAR 0 6
11910: PUSH
11911: LD_INT 1
11913: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11914: LD_STRING People
11916: PPUSH
11917: LD_INT 2
11919: PPUSH
11920: CALL_OW 101
// end else
11924: GO 11988
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
11926: LD_EXP 14
11930: PUSH
11931: LD_INT 3
11933: PUSH
11934: LD_INT 2
11936: PUSH
11937: LD_INT 2
11939: PUSH
11940: LD_INT 1
11942: PUSH
11943: EMPTY
11944: LIST
11945: LIST
11946: LIST
11947: LIST
11948: PUSH
11949: LD_OWVAR 67
11953: ARRAY
11954: LESSEQUAL
11955: IFFALSE 11977
// begin AddMedal ( People , 1 ) ;
11957: LD_STRING People
11959: PPUSH
11960: LD_INT 1
11962: PPUSH
11963: CALL_OW 101
// m3 := true ;
11967: LD_ADDR_VAR 0 6
11971: PUSH
11972: LD_INT 1
11974: ST_TO_ADDR
// end else
11975: GO 11988
// AddMedal ( People , - 1 ) ;
11977: LD_STRING People
11979: PPUSH
11980: LD_INT 1
11982: NEG
11983: PPUSH
11984: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
11988: LD_OWVAR 67
11992: PUSH
11993: LD_INT 3
11995: GREATEREQUAL
11996: PUSH
11997: LD_VAR 0 4
12001: AND
12002: PUSH
12003: LD_VAR 0 5
12007: AND
12008: PUSH
12009: LD_VAR 0 6
12013: AND
12014: IFFALSE 12026
// SetAchievementEX ( ACH_AMER , 17 ) ;
12016: LD_STRING ACH_AMER
12018: PPUSH
12019: LD_INT 17
12021: PPUSH
12022: CALL_OW 564
// GiveMedals ( MAIN ) ;
12026: LD_STRING MAIN
12028: PPUSH
12029: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
12033: LD_ADDR_VAR 0 2
12037: PUSH
12038: LD_INT 22
12040: PUSH
12041: LD_INT 7
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: LD_INT 2
12050: PUSH
12051: LD_INT 25
12053: PUSH
12054: LD_INT 1
12056: PUSH
12057: EMPTY
12058: LIST
12059: LIST
12060: PUSH
12061: LD_INT 25
12063: PUSH
12064: LD_INT 2
12066: PUSH
12067: EMPTY
12068: LIST
12069: LIST
12070: PUSH
12071: LD_INT 25
12073: PUSH
12074: LD_INT 3
12076: PUSH
12077: EMPTY
12078: LIST
12079: LIST
12080: PUSH
12081: LD_INT 25
12083: PUSH
12084: LD_INT 4
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: PUSH
12091: LD_INT 25
12093: PUSH
12094: LD_INT 5
12096: PUSH
12097: EMPTY
12098: LIST
12099: LIST
12100: PUSH
12101: LD_INT 25
12103: PUSH
12104: LD_INT 8
12106: PUSH
12107: EMPTY
12108: LIST
12109: LIST
12110: PUSH
12111: LD_INT 25
12113: PUSH
12114: LD_INT 9
12116: PUSH
12117: EMPTY
12118: LIST
12119: LIST
12120: PUSH
12121: EMPTY
12122: LIST
12123: LIST
12124: LIST
12125: LIST
12126: LIST
12127: LIST
12128: LIST
12129: LIST
12130: PUSH
12131: EMPTY
12132: LIST
12133: LIST
12134: PPUSH
12135: CALL_OW 69
12139: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12140: LD_VAR 0 2
12144: PPUSH
12145: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
12149: LD_ADDR_VAR 0 3
12153: PUSH
12154: LD_EXP 16
12158: PUSH
12159: LD_EXP 17
12163: PUSH
12164: LD_EXP 18
12168: PUSH
12169: LD_EXP 19
12173: PUSH
12174: LD_EXP 20
12178: PUSH
12179: LD_EXP 21
12183: PUSH
12184: LD_EXP 22
12188: PUSH
12189: LD_EXP 23
12193: PUSH
12194: LD_EXP 24
12198: PUSH
12199: LD_EXP 25
12203: PUSH
12204: LD_EXP 26
12208: PUSH
12209: LD_EXP 27
12213: PUSH
12214: LD_EXP 28
12218: PUSH
12219: LD_EXP 29
12223: PUSH
12224: LD_EXP 30
12228: PUSH
12229: LD_EXP 31
12233: PUSH
12234: LD_EXP 32
12238: PUSH
12239: LD_EXP 33
12243: PUSH
12244: LD_EXP 34
12248: PUSH
12249: LD_EXP 35
12253: PUSH
12254: LD_EXP 37
12258: PUSH
12259: LD_EXP 38
12263: PUSH
12264: LD_EXP 39
12268: PUSH
12269: LD_EXP 40
12273: PUSH
12274: LD_EXP 41
12278: PUSH
12279: LD_EXP 42
12283: PUSH
12284: LD_EXP 43
12288: PUSH
12289: LD_EXP 44
12293: PUSH
12294: LD_EXP 45
12298: PUSH
12299: LD_EXP 46
12303: PUSH
12304: LD_EXP 47
12308: PUSH
12309: LD_EXP 48
12313: PUSH
12314: LD_EXP 49
12318: PUSH
12319: EMPTY
12320: LIST
12321: LIST
12322: LIST
12323: LIST
12324: LIST
12325: LIST
12326: LIST
12327: LIST
12328: LIST
12329: LIST
12330: LIST
12331: LIST
12332: LIST
12333: LIST
12334: LIST
12335: LIST
12336: LIST
12337: LIST
12338: LIST
12339: LIST
12340: LIST
12341: LIST
12342: LIST
12343: LIST
12344: LIST
12345: LIST
12346: LIST
12347: LIST
12348: LIST
12349: LIST
12350: LIST
12351: LIST
12352: LIST
12353: ST_TO_ADDR
// if tmp diff tmp2 then
12354: LD_VAR 0 2
12358: PUSH
12359: LD_VAR 0 3
12363: DIFF
12364: IFFALSE 12384
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12366: LD_VAR 0 2
12370: PUSH
12371: LD_VAR 0 3
12375: DIFF
12376: PPUSH
12377: LD_STRING 13a_others
12379: PPUSH
12380: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12384: LD_EXP 16
12388: PPUSH
12389: LD_STRING 13a_JMM
12391: PPUSH
12392: CALL_OW 38
// if Titov then
12396: LD_EXP 35
12400: IFFALSE 12414
// SaveCharacters ( Titov , 13a_Titov ) ;
12402: LD_EXP 35
12406: PPUSH
12407: LD_STRING 13a_Titov
12409: PPUSH
12410: CALL_OW 38
// if Dolgov then
12414: LD_EXP 37
12418: IFFALSE 12432
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12420: LD_EXP 37
12424: PPUSH
12425: LD_STRING 13a_Dolgov
12427: PPUSH
12428: CALL_OW 38
// if Petrosyan then
12432: LD_EXP 38
12436: IFFALSE 12450
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12438: LD_EXP 38
12442: PPUSH
12443: LD_STRING 13a_Petrosyan
12445: PPUSH
12446: CALL_OW 38
// if Scholtze then
12450: LD_EXP 39
12454: IFFALSE 12468
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12456: LD_EXP 39
12460: PPUSH
12461: LD_STRING 13a_Scholtze
12463: PPUSH
12464: CALL_OW 38
// if Oblukov then
12468: LD_EXP 40
12472: IFFALSE 12486
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12474: LD_EXP 40
12478: PPUSH
12479: LD_STRING 13a_Oblukov
12481: PPUSH
12482: CALL_OW 38
// if Kapitsova then
12486: LD_EXP 41
12490: IFFALSE 12504
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12492: LD_EXP 41
12496: PPUSH
12497: LD_STRING 13a_Kapitsova
12499: PPUSH
12500: CALL_OW 38
// if Lipshchin then
12504: LD_EXP 42
12508: IFFALSE 12522
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12510: LD_EXP 42
12514: PPUSH
12515: LD_STRING 13a_Lipshchin
12517: PPUSH
12518: CALL_OW 38
// if Petrovova then
12522: LD_EXP 43
12526: IFFALSE 12540
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12528: LD_EXP 43
12532: PPUSH
12533: LD_STRING 13a_Petrovova
12535: PPUSH
12536: CALL_OW 38
// if Kovalyuk then
12540: LD_EXP 44
12544: IFFALSE 12558
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12546: LD_EXP 44
12550: PPUSH
12551: LD_STRING 13a_Kovalyuk
12553: PPUSH
12554: CALL_OW 38
// if Kuzmov then
12558: LD_EXP 45
12562: IFFALSE 12576
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12564: LD_EXP 45
12568: PPUSH
12569: LD_STRING 13a_Kuzmov
12571: PPUSH
12572: CALL_OW 38
// if Karamazov then
12576: LD_EXP 46
12580: IFFALSE 12594
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12582: LD_EXP 46
12586: PPUSH
12587: LD_STRING 13a_Karamazov
12589: PPUSH
12590: CALL_OW 38
// if Burlak then
12594: LD_EXP 47
12598: IFFALSE 12612
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12600: LD_EXP 47
12604: PPUSH
12605: LD_STRING 13a_Burlak
12607: PPUSH
12608: CALL_OW 38
// if Belkov then
12612: LD_EXP 48
12616: IFFALSE 12630
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12618: LD_EXP 48
12622: PPUSH
12623: LD_STRING 13a_Belkov
12625: PPUSH
12626: CALL_OW 38
// if Gnyevko then
12630: LD_EXP 49
12634: IFFALSE 12648
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12636: LD_EXP 49
12640: PPUSH
12641: LD_STRING 13a_Gnyevko
12643: PPUSH
12644: CALL_OW 38
// if Lisa then
12648: LD_EXP 18
12652: IFFALSE 12666
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12654: LD_EXP 18
12658: PPUSH
12659: LD_STRING 13a_Lisa
12661: PPUSH
12662: CALL_OW 38
// if Donaldson then
12666: LD_EXP 19
12670: IFFALSE 12684
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12672: LD_EXP 19
12676: PPUSH
12677: LD_STRING 13a_Donaldson
12679: PPUSH
12680: CALL_OW 38
// if Bobby then
12684: LD_EXP 20
12688: IFFALSE 12702
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12690: LD_EXP 20
12694: PPUSH
12695: LD_STRING 13a_Bobby
12697: PPUSH
12698: CALL_OW 38
// if Cyrus then
12702: LD_EXP 21
12706: IFFALSE 12720
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12708: LD_EXP 21
12712: PPUSH
12713: LD_STRING 13a_Cyrus
12715: PPUSH
12716: CALL_OW 38
// if Denis then
12720: LD_EXP 22
12724: IFFALSE 12738
// SaveCharacters ( Denis , 13a_Denis ) ;
12726: LD_EXP 22
12730: PPUSH
12731: LD_STRING 13a_Denis
12733: PPUSH
12734: CALL_OW 38
// if Brown then
12738: LD_EXP 23
12742: IFFALSE 12756
// SaveCharacters ( Brown , 13a_Brown ) ;
12744: LD_EXP 23
12748: PPUSH
12749: LD_STRING 13a_Brown
12751: PPUSH
12752: CALL_OW 38
// if Gladstone then
12756: LD_EXP 24
12760: IFFALSE 12774
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12762: LD_EXP 24
12766: PPUSH
12767: LD_STRING 13a_Gladstone
12769: PPUSH
12770: CALL_OW 38
// if Houten then
12774: LD_EXP 25
12778: IFFALSE 12792
// SaveCharacters ( Houten , 13a_Houten ) ;
12780: LD_EXP 25
12784: PPUSH
12785: LD_STRING 13a_Houten
12787: PPUSH
12788: CALL_OW 38
// if Cornel then
12792: LD_EXP 26
12796: IFFALSE 12810
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12798: LD_EXP 26
12802: PPUSH
12803: LD_STRING 13a_Cornel
12805: PPUSH
12806: CALL_OW 38
// if Gary then
12810: LD_EXP 27
12814: IFFALSE 12828
// SaveCharacters ( Gary , 13a_Gary ) ;
12816: LD_EXP 27
12820: PPUSH
12821: LD_STRING 13a_Gary
12823: PPUSH
12824: CALL_OW 38
// if Frank then
12828: LD_EXP 28
12832: IFFALSE 12846
// SaveCharacters ( Frank , 13a_Frank ) ;
12834: LD_EXP 28
12838: PPUSH
12839: LD_STRING 13a_Frank
12841: PPUSH
12842: CALL_OW 38
// if Kikuchi then
12846: LD_EXP 29
12850: IFFALSE 12864
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12852: LD_EXP 29
12856: PPUSH
12857: LD_STRING 13a_Kikuchi
12859: PPUSH
12860: CALL_OW 38
// if Simms then
12864: LD_EXP 30
12868: IFFALSE 12882
// SaveCharacters ( Simms , 13a_Simms ) ;
12870: LD_EXP 30
12874: PPUSH
12875: LD_STRING 13a_Simms
12877: PPUSH
12878: CALL_OW 38
// if Joan then
12882: LD_EXP 31
12886: IFFALSE 12900
// SaveCharacters ( Joan , 13a_Joan ) ;
12888: LD_EXP 31
12892: PPUSH
12893: LD_STRING 13a_Joan
12895: PPUSH
12896: CALL_OW 38
// if DeltaDoctor then
12900: LD_EXP 32
12904: IFFALSE 12918
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12906: LD_EXP 32
12910: PPUSH
12911: LD_STRING 13a_DeltaDoctor
12913: PPUSH
12914: CALL_OW 38
// if Gossudarov then
12918: LD_EXP 33
12922: IFFALSE 12936
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12924: LD_EXP 33
12928: PPUSH
12929: LD_STRING 13a_Gossudarov
12931: PPUSH
12932: CALL_OW 38
// if Kirilenkova then
12936: LD_EXP 34
12940: IFFALSE 12954
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12942: LD_EXP 34
12946: PPUSH
12947: LD_STRING 13a_Kirilenkova
12949: PPUSH
12950: CALL_OW 38
// if Roth then
12954: LD_EXP 17
12958: IFFALSE 12972
// SaveCharacters ( Roth , 13a_Roth ) ;
12960: LD_EXP 17
12964: PPUSH
12965: LD_STRING 13a_Roth
12967: PPUSH
12968: CALL_OW 38
// if Masha then
12972: LD_EXP 50
12976: IFFALSE 13031
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12978: LD_EXP 50
12982: PPUSH
12983: CALL_OW 265
12987: PUSH
12988: LD_EXP 50
12992: PPUSH
12993: CALL_OW 262
12997: PUSH
12998: LD_EXP 50
13002: PPUSH
13003: CALL_OW 263
13007: PUSH
13008: LD_EXP 50
13012: PPUSH
13013: CALL_OW 264
13017: PUSH
13018: EMPTY
13019: LIST
13020: LIST
13021: LIST
13022: LIST
13023: PPUSH
13024: LD_STRING 13a_Masha
13026: PPUSH
13027: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
13031: LD_ADDR_VAR 0 2
13035: PUSH
13036: LD_INT 21
13038: PUSH
13039: LD_INT 3
13041: PUSH
13042: EMPTY
13043: LIST
13044: LIST
13045: PPUSH
13046: CALL_OW 69
13050: ST_TO_ADDR
// tmp2 := [ ] ;
13051: LD_ADDR_VAR 0 3
13055: PUSH
13056: EMPTY
13057: ST_TO_ADDR
// if tmp then
13058: LD_VAR 0 2
13062: IFFALSE 13213
// for i in tmp do
13064: LD_ADDR_VAR 0 1
13068: PUSH
13069: LD_VAR 0 2
13073: PUSH
13074: FOR_IN
13075: IFFALSE 13211
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13077: LD_ADDR_VAR 0 3
13081: PUSH
13082: LD_VAR 0 3
13086: PUSH
13087: LD_VAR 0 1
13091: PPUSH
13092: CALL_OW 255
13096: PUSH
13097: LD_VAR 0 1
13101: PPUSH
13102: CALL_OW 248
13106: PUSH
13107: LD_VAR 0 1
13111: PPUSH
13112: CALL_OW 266
13116: PUSH
13117: LD_VAR 0 1
13121: PPUSH
13122: CALL_OW 250
13126: PUSH
13127: LD_VAR 0 1
13131: PPUSH
13132: CALL_OW 251
13136: PUSH
13137: LD_VAR 0 1
13141: PPUSH
13142: CALL_OW 254
13146: PUSH
13147: LD_VAR 0 1
13151: PPUSH
13152: CALL_OW 267
13156: PUSH
13157: LD_VAR 0 1
13161: PPUSH
13162: LD_INT 1
13164: PPUSH
13165: CALL_OW 268
13169: PUSH
13170: LD_VAR 0 1
13174: PPUSH
13175: LD_INT 2
13177: PPUSH
13178: CALL_OW 268
13182: PUSH
13183: LD_VAR 0 1
13187: PPUSH
13188: CALL_OW 269
13192: PUSH
13193: EMPTY
13194: LIST
13195: LIST
13196: LIST
13197: LIST
13198: LIST
13199: LIST
13200: LIST
13201: LIST
13202: LIST
13203: LIST
13204: PUSH
13205: EMPTY
13206: LIST
13207: ADD
13208: ST_TO_ADDR
13209: GO 13074
13211: POP
13212: POP
// if tmp2 then
13213: LD_VAR 0 3
13217: IFFALSE 13231
// SaveVariable ( tmp2 , 13a_buildings ) ;
13219: LD_VAR 0 3
13223: PPUSH
13224: LD_STRING 13a_buildings
13226: PPUSH
13227: CALL_OW 39
// YouWin ;
13231: CALL_OW 103
// end ;
13235: PPOPN 6
13237: END
// export function SciRu ; var tmp , t ; begin
13238: LD_INT 0
13240: PPUSH
13241: PPUSH
13242: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13243: LD_ADDR_VAR 0 3
13247: PUSH
13248: LD_EXP 33
13252: PUSH
13253: LD_EXP 47
13257: PUSH
13258: LD_EXP 35
13262: PUSH
13263: LD_EXP 48
13267: PUSH
13268: LD_EXP 49
13272: PUSH
13273: LD_EXP 38
13277: PUSH
13278: LD_EXP 39
13282: PUSH
13283: LD_EXP 37
13287: PUSH
13288: EMPTY
13289: LIST
13290: LIST
13291: LIST
13292: LIST
13293: LIST
13294: LIST
13295: LIST
13296: LIST
13297: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13298: LD_ADDR_VAR 0 2
13302: PUSH
13303: LD_INT 22
13305: PUSH
13306: LD_INT 7
13308: PUSH
13309: EMPTY
13310: LIST
13311: LIST
13312: PUSH
13313: LD_INT 23
13315: PUSH
13316: LD_INT 3
13318: PUSH
13319: EMPTY
13320: LIST
13321: LIST
13322: PUSH
13323: LD_INT 25
13325: PUSH
13326: LD_INT 4
13328: PUSH
13329: EMPTY
13330: LIST
13331: LIST
13332: PUSH
13333: LD_INT 26
13335: PUSH
13336: LD_INT 1
13338: PUSH
13339: EMPTY
13340: LIST
13341: LIST
13342: PUSH
13343: EMPTY
13344: LIST
13345: LIST
13346: LIST
13347: LIST
13348: PPUSH
13349: CALL_OW 69
13353: PUSH
13354: LD_VAR 0 3
13358: DIFF
13359: ST_TO_ADDR
// if tmp then
13360: LD_VAR 0 2
13364: IFFALSE 13380
// result := tmp [ 1 ] ;
13366: LD_ADDR_VAR 0 1
13370: PUSH
13371: LD_VAR 0 2
13375: PUSH
13376: LD_INT 1
13378: ARRAY
13379: ST_TO_ADDR
// end ;
13380: LD_VAR 0 1
13384: RET
// export function SolRu ; var tmp , t ; begin
13385: LD_INT 0
13387: PPUSH
13388: PPUSH
13389: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13390: LD_ADDR_VAR 0 3
13394: PUSH
13395: LD_EXP 33
13399: PUSH
13400: LD_EXP 47
13404: PUSH
13405: LD_EXP 35
13409: PUSH
13410: LD_EXP 48
13414: PUSH
13415: LD_EXP 49
13419: PUSH
13420: LD_EXP 38
13424: PUSH
13425: LD_EXP 39
13429: PUSH
13430: LD_EXP 37
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: LIST
13439: LIST
13440: LIST
13441: LIST
13442: LIST
13443: LIST
13444: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
13445: LD_ADDR_VAR 0 2
13449: PUSH
13450: LD_INT 22
13452: PUSH
13453: LD_INT 7
13455: PUSH
13456: EMPTY
13457: LIST
13458: LIST
13459: PUSH
13460: LD_INT 23
13462: PUSH
13463: LD_INT 3
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: PUSH
13470: LD_INT 25
13472: PUSH
13473: LD_INT 1
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: PUSH
13480: LD_INT 26
13482: PUSH
13483: LD_INT 1
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: PUSH
13490: EMPTY
13491: LIST
13492: LIST
13493: LIST
13494: LIST
13495: PPUSH
13496: CALL_OW 69
13500: PUSH
13501: LD_VAR 0 3
13505: DIFF
13506: ST_TO_ADDR
// if tmp then
13507: LD_VAR 0 2
13511: IFFALSE 13527
// result := tmp [ 1 ] ;
13513: LD_ADDR_VAR 0 1
13517: PUSH
13518: LD_VAR 0 2
13522: PUSH
13523: LD_INT 1
13525: ARRAY
13526: ST_TO_ADDR
// end ; end_of_file
13527: LD_VAR 0 1
13531: RET
// export function CustomEvent ( event ) ; begin
13532: LD_INT 0
13534: PPUSH
// end ;
13535: LD_VAR 0 2
13539: RET
// on UnitDestroyed ( un ) do var i , side ;
13540: LD_INT 0
13542: PPUSH
13543: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
13544: LD_VAR 0 1
13548: PPUSH
13549: CALL 102292 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13553: LD_VAR 0 1
13557: PUSH
13558: LD_INT 22
13560: PUSH
13561: LD_INT 7
13563: PUSH
13564: EMPTY
13565: LIST
13566: LIST
13567: PUSH
13568: LD_INT 2
13570: PUSH
13571: LD_INT 25
13573: PUSH
13574: LD_INT 1
13576: PUSH
13577: EMPTY
13578: LIST
13579: LIST
13580: PUSH
13581: LD_INT 25
13583: PUSH
13584: LD_INT 2
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: PUSH
13591: LD_INT 25
13593: PUSH
13594: LD_INT 3
13596: PUSH
13597: EMPTY
13598: LIST
13599: LIST
13600: PUSH
13601: LD_INT 25
13603: PUSH
13604: LD_INT 4
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PUSH
13611: LD_INT 25
13613: PUSH
13614: LD_INT 5
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 25
13623: PUSH
13624: LD_INT 8
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: LD_INT 25
13633: PUSH
13634: LD_INT 9
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PUSH
13641: EMPTY
13642: LIST
13643: LIST
13644: LIST
13645: LIST
13646: LIST
13647: LIST
13648: LIST
13649: LIST
13650: PUSH
13651: EMPTY
13652: LIST
13653: LIST
13654: PPUSH
13655: CALL_OW 69
13659: IN
13660: IFFALSE 13676
// loss_counter := loss_counter + 1 ;
13662: LD_ADDR_EXP 14
13666: PUSH
13667: LD_EXP 14
13671: PUSH
13672: LD_INT 1
13674: PLUS
13675: ST_TO_ADDR
// if un = Abdul then
13676: LD_VAR 0 1
13680: PUSH
13681: LD_EXP 56
13685: EQUAL
13686: IFFALSE 13696
// abdul_escaped := false ;
13688: LD_ADDR_EXP 13
13692: PUSH
13693: LD_INT 0
13695: ST_TO_ADDR
// if un in ru_attackers then
13696: LD_VAR 0 1
13700: PUSH
13701: LD_EXP 53
13705: IN
13706: IFFALSE 13724
// ru_attackers := ru_attackers diff un ;
13708: LD_ADDR_EXP 53
13712: PUSH
13713: LD_EXP 53
13717: PUSH
13718: LD_VAR 0 1
13722: DIFF
13723: ST_TO_ADDR
// if un in ar_attackers then
13724: LD_VAR 0 1
13728: PUSH
13729: LD_EXP 11
13733: IN
13734: IFFALSE 13752
// ar_attackers := ar_attackers diff un ;
13736: LD_ADDR_EXP 11
13740: PUSH
13741: LD_EXP 11
13745: PUSH
13746: LD_VAR 0 1
13750: DIFF
13751: ST_TO_ADDR
// if un = JMM then
13752: LD_VAR 0 1
13756: PUSH
13757: LD_EXP 16
13761: EQUAL
13762: IFFALSE 13773
// begin YouLost ( JMM ) ;
13764: LD_STRING JMM
13766: PPUSH
13767: CALL_OW 104
// exit ;
13771: GO 13870
// end ; if un = Burlak then
13773: LD_VAR 0 1
13777: PUSH
13778: LD_EXP 47
13782: EQUAL
13783: IFFALSE 13794
// begin YouLost ( Burlak ) ;
13785: LD_STRING Burlak
13787: PPUSH
13788: CALL_OW 104
// exit ;
13792: GO 13870
// end ; if un = freedom then
13794: LD_VAR 0 1
13798: PUSH
13799: LD_EXP 3
13803: EQUAL
13804: IFFALSE 13815
// begin YouLost ( Destroyed ) ;
13806: LD_STRING Destroyed
13808: PPUSH
13809: CALL_OW 104
// exit ;
13813: GO 13870
// end ; if un = Masha then
13815: LD_VAR 0 1
13819: PUSH
13820: LD_EXP 50
13824: EQUAL
13825: IFFALSE 13842
// begin ChangeMissionObjectives ( M4b ) ;
13827: LD_STRING M4b
13829: PPUSH
13830: CALL_OW 337
// masha_killed := true ;
13834: LD_ADDR_EXP 10
13838: PUSH
13839: LD_INT 1
13841: ST_TO_ADDR
// end ; if un = Mastodont then
13842: LD_VAR 0 1
13846: PUSH
13847: LD_EXP 57
13851: EQUAL
13852: IFFALSE 13861
// ChangeMissionObjectives ( M4a ) ;
13854: LD_STRING M4a
13856: PPUSH
13857: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13861: LD_VAR 0 1
13865: PPUSH
13866: CALL 83659 0 1
// end ;
13870: PPOPN 3
13872: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13873: LD_VAR 0 1
13877: PPUSH
13878: LD_VAR 0 2
13882: PPUSH
13883: CALL 85991 0 2
// end ;
13887: PPOPN 2
13889: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13890: LD_VAR 0 1
13894: PPUSH
13895: CALL 85059 0 1
// end ;
13899: PPOPN 1
13901: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13902: LD_VAR 0 1
13906: PUSH
13907: LD_INT 22
13909: PUSH
13910: LD_INT 7
13912: PUSH
13913: EMPTY
13914: LIST
13915: LIST
13916: PUSH
13917: LD_INT 30
13919: PUSH
13920: LD_INT 0
13922: PUSH
13923: EMPTY
13924: LIST
13925: LIST
13926: PUSH
13927: EMPTY
13928: LIST
13929: LIST
13930: PPUSH
13931: CALL_OW 69
13935: IN
13936: IFFALSE 13975
// begin SetBName ( building , freedom ) ;
13938: LD_VAR 0 1
13942: PPUSH
13943: LD_STRING freedom
13945: PPUSH
13946: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13950: LD_INT 0
13952: PPUSH
13953: LD_INT 7
13955: PPUSH
13956: LD_INT 0
13958: PPUSH
13959: CALL_OW 324
// freedom := building ;
13963: LD_ADDR_EXP 3
13967: PUSH
13968: LD_VAR 0 1
13972: ST_TO_ADDR
// exit ;
13973: GO 14041
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13975: LD_VAR 0 1
13979: PUSH
13980: LD_INT 22
13982: PUSH
13983: LD_INT 7
13985: PUSH
13986: EMPTY
13987: LIST
13988: LIST
13989: PUSH
13990: LD_INT 23
13992: PUSH
13993: LD_INT 3
13995: PUSH
13996: EMPTY
13997: LIST
13998: LIST
13999: PUSH
14000: LD_INT 30
14002: PUSH
14003: LD_INT 6
14005: PUSH
14006: EMPTY
14007: LIST
14008: LIST
14009: PUSH
14010: EMPTY
14011: LIST
14012: LIST
14013: LIST
14014: PPUSH
14015: CALL_OW 69
14019: IN
14020: IFFALSE 14032
// begin ru_lab_builded := true ;
14022: LD_ADDR_EXP 5
14026: PUSH
14027: LD_INT 1
14029: ST_TO_ADDR
// exit ;
14030: GO 14041
// end ; MCE_BuildingComplete ( building ) ;
14032: LD_VAR 0 1
14036: PPUSH
14037: CALL 85300 0 1
// end ;
14041: PPOPN 1
14043: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
14044: LD_VAR 0 1
14048: PPUSH
14049: LD_VAR 0 2
14053: PPUSH
14054: CALL 83355 0 2
// end ;
14058: PPOPN 2
14060: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
14061: LD_VAR 0 1
14065: PPUSH
14066: LD_VAR 0 2
14070: PPUSH
14071: LD_VAR 0 3
14075: PPUSH
14076: LD_VAR 0 4
14080: PPUSH
14081: LD_VAR 0 5
14085: PPUSH
14086: CALL 82975 0 5
// end ;
14090: PPOPN 5
14092: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
14093: LD_VAR 0 1
14097: PPUSH
14098: LD_VAR 0 2
14102: PPUSH
14103: CALL 102412 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
14107: LD_VAR 0 1
14111: PPUSH
14112: LD_VAR 0 2
14116: PPUSH
14117: CALL 82566 0 2
// end ;
14121: PPOPN 2
14123: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14124: LD_VAR 0 1
14128: PPUSH
14129: CALL_OW 263
14133: PUSH
14134: LD_INT 3
14136: EQUAL
14137: PUSH
14138: LD_VAR 0 2
14142: PPUSH
14143: CALL_OW 263
14147: PUSH
14148: LD_INT 3
14150: EQUAL
14151: OR
14152: IFFALSE 14168
// hack_counter := hack_counter + 1 ;
14154: LD_ADDR_EXP 15
14158: PUSH
14159: LD_EXP 15
14163: PUSH
14164: LD_INT 1
14166: PLUS
14167: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14168: LD_VAR 0 1
14172: PPUSH
14173: LD_VAR 0 2
14177: PPUSH
14178: LD_VAR 0 3
14182: PPUSH
14183: LD_VAR 0 4
14187: PPUSH
14188: CALL 82404 0 4
// end ;
14192: PPOPN 4
14194: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14195: LD_VAR 0 1
14199: PPUSH
14200: LD_VAR 0 2
14204: PPUSH
14205: LD_VAR 0 3
14209: PPUSH
14210: CALL 82179 0 3
// end ;
14214: PPOPN 3
14216: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14217: LD_VAR 0 1
14221: PPUSH
14222: LD_VAR 0 2
14226: PPUSH
14227: CALL 82064 0 2
// end ;
14231: PPOPN 2
14233: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14234: LD_VAR 0 1
14238: PPUSH
14239: LD_VAR 0 2
14243: PPUSH
14244: CALL 86286 0 2
// end ;
14248: PPOPN 2
14250: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14251: LD_VAR 0 1
14255: PPUSH
14256: LD_VAR 0 2
14260: PPUSH
14261: LD_VAR 0 3
14265: PPUSH
14266: LD_VAR 0 4
14270: PPUSH
14271: CALL 86502 0 4
// end ;
14275: PPOPN 4
14277: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14278: LD_VAR 0 1
14282: PPUSH
14283: LD_VAR 0 2
14287: PPUSH
14288: CALL 81873 0 2
// end ;
14292: PPOPN 2
14294: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14295: LD_VAR 0 1
14299: PPUSH
14300: CALL 102396 0 1
// end ; end_of_file
14304: PPOPN 1
14306: END
// every 0 0$30 do var cr , time ;
14307: GO 14309
14309: DISABLE
14310: LD_INT 0
14312: PPUSH
14313: PPUSH
// begin time := 0 0$20 ;
14314: LD_ADDR_VAR 0 2
14318: PUSH
14319: LD_INT 700
14321: ST_TO_ADDR
// while game do
14322: LD_EXP 2
14326: IFFALSE 14429
// begin wait ( time ) ;
14328: LD_VAR 0 2
14332: PPUSH
14333: CALL_OW 67
// if tick > 2 2$00 then
14337: LD_OWVAR 1
14341: PUSH
14342: LD_INT 4200
14344: GREATER
14345: IFFALSE 14382
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14347: LD_ADDR_VAR 0 2
14351: PUSH
14352: LD_VAR 0 2
14356: PUSH
14357: LD_INT 140
14359: PUSH
14360: LD_INT 140
14362: PUSH
14363: LD_INT 210
14365: PUSH
14366: LD_INT 280
14368: PUSH
14369: EMPTY
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: PUSH
14375: LD_OWVAR 67
14379: ARRAY
14380: PLUS
14381: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
14382: LD_INT 1
14384: PPUSH
14385: LD_INT 5
14387: PPUSH
14388: CALL_OW 12
14392: PPUSH
14393: LD_INT 70
14395: PPUSH
14396: LD_INT 49
14398: PPUSH
14399: LD_INT 25
14401: PPUSH
14402: LD_INT 1
14404: PPUSH
14405: CALL_OW 56
// if time > 3 3$00 then
14409: LD_VAR 0 2
14413: PUSH
14414: LD_INT 6300
14416: GREATER
14417: IFFALSE 14427
// time := 0 0$30 ;
14419: LD_ADDR_VAR 0 2
14423: PUSH
14424: LD_INT 1050
14426: ST_TO_ADDR
// end ;
14427: GO 14322
// end ;
14429: PPOPN 2
14431: END
// every 0 0$30 do var cr , time ;
14432: GO 14434
14434: DISABLE
14435: LD_INT 0
14437: PPUSH
14438: PPUSH
// begin time := 0 0$20 ;
14439: LD_ADDR_VAR 0 2
14443: PUSH
14444: LD_INT 700
14446: ST_TO_ADDR
// while game do
14447: LD_EXP 2
14451: IFFALSE 14544
// begin wait ( time ) ;
14453: LD_VAR 0 2
14457: PPUSH
14458: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14462: LD_ADDR_VAR 0 2
14466: PUSH
14467: LD_VAR 0 2
14471: PUSH
14472: LD_INT 140
14474: PUSH
14475: LD_INT 175
14477: PUSH
14478: LD_INT 210
14480: PUSH
14481: LD_INT 280
14483: PUSH
14484: EMPTY
14485: LIST
14486: LIST
14487: LIST
14488: LIST
14489: PUSH
14490: LD_OWVAR 67
14494: ARRAY
14495: PLUS
14496: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
14497: LD_INT 3
14499: PPUSH
14500: LD_INT 5
14502: PPUSH
14503: CALL_OW 12
14507: PPUSH
14508: LD_INT 26
14510: PPUSH
14511: LD_INT 9
14513: PPUSH
14514: LD_INT 30
14516: PPUSH
14517: LD_INT 1
14519: PPUSH
14520: CALL_OW 56
// if time > 3 3$00 then
14524: LD_VAR 0 2
14528: PUSH
14529: LD_INT 6300
14531: GREATER
14532: IFFALSE 14542
// time := 0 0$20 ;
14534: LD_ADDR_VAR 0 2
14538: PUSH
14539: LD_INT 700
14541: ST_TO_ADDR
// end ;
14542: GO 14447
// end ;
14544: PPOPN 2
14546: END
// every 0 0$30 do var cr , time ;
14547: GO 14549
14549: DISABLE
14550: LD_INT 0
14552: PPUSH
14553: PPUSH
// begin time := 0 0$20 ;
14554: LD_ADDR_VAR 0 2
14558: PUSH
14559: LD_INT 700
14561: ST_TO_ADDR
// while game do
14562: LD_EXP 2
14566: IFFALSE 14695
// begin wait ( time ) ;
14568: LD_VAR 0 2
14572: PPUSH
14573: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
14577: LD_ADDR_VAR 0 2
14581: PUSH
14582: LD_VAR 0 2
14586: PUSH
14587: LD_INT 175
14589: PUSH
14590: LD_INT 210
14592: PUSH
14593: LD_INT 280
14595: PUSH
14596: LD_INT 350
14598: PUSH
14599: EMPTY
14600: LIST
14601: LIST
14602: LIST
14603: LIST
14604: PUSH
14605: LD_OWVAR 67
14609: ARRAY
14610: PLUS
14611: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14612: LD_INT 1
14614: PPUSH
14615: LD_INT 5
14617: PPUSH
14618: CALL_OW 12
14622: PPUSH
14623: LD_INT 179
14625: PPUSH
14626: LD_INT 101
14628: PPUSH
14629: LD_INT 20
14631: PPUSH
14632: LD_INT 1
14634: PPUSH
14635: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14639: LD_INT 350
14641: PPUSH
14642: LD_INT 525
14644: PPUSH
14645: CALL_OW 12
14649: PPUSH
14650: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14654: LD_INT 1
14656: PPUSH
14657: LD_INT 5
14659: PPUSH
14660: CALL_OW 12
14664: PPUSH
14665: LD_INT 9
14667: PPUSH
14668: LD_INT 1
14670: PPUSH
14671: CALL_OW 55
// if time > 4 4$00 then
14675: LD_VAR 0 2
14679: PUSH
14680: LD_INT 8400
14682: GREATER
14683: IFFALSE 14693
// time := 0 0$30 ;
14685: LD_ADDR_VAR 0 2
14689: PUSH
14690: LD_INT 1050
14692: ST_TO_ADDR
// end ;
14693: GO 14562
// end ;
14695: PPOPN 2
14697: END
// every 0 0$30 do var cr , time ;
14698: GO 14700
14700: DISABLE
14701: LD_INT 0
14703: PPUSH
14704: PPUSH
// begin time := 0 0$10 ;
14705: LD_ADDR_VAR 0 2
14709: PUSH
14710: LD_INT 350
14712: ST_TO_ADDR
// while game do
14713: LD_EXP 2
14717: IFFALSE 14851
// begin wait ( time ) ;
14719: LD_VAR 0 2
14723: PPUSH
14724: CALL_OW 67
// time := time + 0 0$10 ;
14728: LD_ADDR_VAR 0 2
14732: PUSH
14733: LD_VAR 0 2
14737: PUSH
14738: LD_INT 350
14740: PLUS
14741: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14742: LD_INT 1
14744: PPUSH
14745: LD_INT 5
14747: PPUSH
14748: CALL_OW 12
14752: PPUSH
14753: LD_INT 11
14755: PPUSH
14756: LD_INT 1
14758: PPUSH
14759: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14763: LD_ADDR_VAR 0 1
14767: PUSH
14768: LD_INT 1
14770: PPUSH
14771: LD_INT 3
14773: PPUSH
14774: CALL_OW 12
14778: ST_TO_ADDR
// if cr = 1 then
14779: LD_VAR 0 1
14783: PUSH
14784: LD_INT 1
14786: EQUAL
14787: IFFALSE 14831
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14789: LD_INT 700
14791: PPUSH
14792: LD_INT 1575
14794: PPUSH
14795: CALL_OW 12
14799: PPUSH
14800: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14804: LD_INT 1
14806: PPUSH
14807: LD_INT 5
14809: PPUSH
14810: CALL_OW 12
14814: PPUSH
14815: LD_INT 34
14817: PPUSH
14818: LD_INT 50
14820: PPUSH
14821: LD_INT 7
14823: PPUSH
14824: LD_INT 1
14826: PPUSH
14827: CALL_OW 56
// end ; if time > 4 4$00 then
14831: LD_VAR 0 2
14835: PUSH
14836: LD_INT 8400
14838: GREATER
14839: IFFALSE 14849
// time := 0 0$40 ;
14841: LD_ADDR_VAR 0 2
14845: PUSH
14846: LD_INT 1400
14848: ST_TO_ADDR
// end ;
14849: GO 14713
// end ; end_of_file
14851: PPOPN 2
14853: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14854: LD_INT 0
14856: PPUSH
14857: PPUSH
// if exist_mode then
14858: LD_VAR 0 2
14862: IFFALSE 14887
// unit := CreateCharacter ( prefix & ident ) else
14864: LD_ADDR_VAR 0 5
14868: PUSH
14869: LD_VAR 0 3
14873: PUSH
14874: LD_VAR 0 1
14878: STR
14879: PPUSH
14880: CALL_OW 34
14884: ST_TO_ADDR
14885: GO 14902
// unit := NewCharacter ( ident ) ;
14887: LD_ADDR_VAR 0 5
14891: PUSH
14892: LD_VAR 0 1
14896: PPUSH
14897: CALL_OW 25
14901: ST_TO_ADDR
// result := unit ;
14902: LD_ADDR_VAR 0 4
14906: PUSH
14907: LD_VAR 0 5
14911: ST_TO_ADDR
// end ;
14912: LD_VAR 0 4
14916: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14917: LD_INT 0
14919: PPUSH
14920: PPUSH
// if not side or not nation then
14921: LD_VAR 0 1
14925: NOT
14926: PUSH
14927: LD_VAR 0 2
14931: NOT
14932: OR
14933: IFFALSE 14937
// exit ;
14935: GO 15705
// case nation of nation_american :
14937: LD_VAR 0 2
14941: PUSH
14942: LD_INT 1
14944: DOUBLE
14945: EQUAL
14946: IFTRUE 14950
14948: GO 15164
14950: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14951: LD_ADDR_VAR 0 4
14955: PUSH
14956: LD_INT 35
14958: PUSH
14959: LD_INT 45
14961: PUSH
14962: LD_INT 46
14964: PUSH
14965: LD_INT 47
14967: PUSH
14968: LD_INT 82
14970: PUSH
14971: LD_INT 83
14973: PUSH
14974: LD_INT 84
14976: PUSH
14977: LD_INT 85
14979: PUSH
14980: LD_INT 86
14982: PUSH
14983: LD_INT 1
14985: PUSH
14986: LD_INT 2
14988: PUSH
14989: LD_INT 6
14991: PUSH
14992: LD_INT 15
14994: PUSH
14995: LD_INT 16
14997: PUSH
14998: LD_INT 7
15000: PUSH
15001: LD_INT 12
15003: PUSH
15004: LD_INT 13
15006: PUSH
15007: LD_INT 10
15009: PUSH
15010: LD_INT 14
15012: PUSH
15013: LD_INT 20
15015: PUSH
15016: LD_INT 21
15018: PUSH
15019: LD_INT 22
15021: PUSH
15022: LD_INT 25
15024: PUSH
15025: LD_INT 32
15027: PUSH
15028: LD_INT 27
15030: PUSH
15031: LD_INT 36
15033: PUSH
15034: LD_INT 69
15036: PUSH
15037: LD_INT 39
15039: PUSH
15040: LD_INT 34
15042: PUSH
15043: LD_INT 40
15045: PUSH
15046: LD_INT 48
15048: PUSH
15049: LD_INT 49
15051: PUSH
15052: LD_INT 50
15054: PUSH
15055: LD_INT 51
15057: PUSH
15058: LD_INT 52
15060: PUSH
15061: LD_INT 53
15063: PUSH
15064: LD_INT 54
15066: PUSH
15067: LD_INT 55
15069: PUSH
15070: LD_INT 56
15072: PUSH
15073: LD_INT 57
15075: PUSH
15076: LD_INT 58
15078: PUSH
15079: LD_INT 59
15081: PUSH
15082: LD_INT 60
15084: PUSH
15085: LD_INT 61
15087: PUSH
15088: LD_INT 62
15090: PUSH
15091: LD_INT 80
15093: PUSH
15094: LD_INT 82
15096: PUSH
15097: LD_INT 83
15099: PUSH
15100: LD_INT 84
15102: PUSH
15103: LD_INT 85
15105: PUSH
15106: LD_INT 86
15108: PUSH
15109: EMPTY
15110: LIST
15111: LIST
15112: LIST
15113: LIST
15114: LIST
15115: LIST
15116: LIST
15117: LIST
15118: LIST
15119: LIST
15120: LIST
15121: LIST
15122: LIST
15123: LIST
15124: LIST
15125: LIST
15126: LIST
15127: LIST
15128: LIST
15129: LIST
15130: LIST
15131: LIST
15132: LIST
15133: LIST
15134: LIST
15135: LIST
15136: LIST
15137: LIST
15138: LIST
15139: LIST
15140: LIST
15141: LIST
15142: LIST
15143: LIST
15144: LIST
15145: LIST
15146: LIST
15147: LIST
15148: LIST
15149: LIST
15150: LIST
15151: LIST
15152: LIST
15153: LIST
15154: LIST
15155: LIST
15156: LIST
15157: LIST
15158: LIST
15159: LIST
15160: LIST
15161: ST_TO_ADDR
15162: GO 15629
15164: LD_INT 2
15166: DOUBLE
15167: EQUAL
15168: IFTRUE 15172
15170: GO 15398
15172: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15173: LD_ADDR_VAR 0 4
15177: PUSH
15178: LD_INT 35
15180: PUSH
15181: LD_INT 45
15183: PUSH
15184: LD_INT 46
15186: PUSH
15187: LD_INT 47
15189: PUSH
15190: LD_INT 82
15192: PUSH
15193: LD_INT 83
15195: PUSH
15196: LD_INT 84
15198: PUSH
15199: LD_INT 85
15201: PUSH
15202: LD_INT 87
15204: PUSH
15205: LD_INT 70
15207: PUSH
15208: LD_INT 1
15210: PUSH
15211: LD_INT 11
15213: PUSH
15214: LD_INT 3
15216: PUSH
15217: LD_INT 4
15219: PUSH
15220: LD_INT 5
15222: PUSH
15223: LD_INT 6
15225: PUSH
15226: LD_INT 15
15228: PUSH
15229: LD_INT 18
15231: PUSH
15232: LD_INT 7
15234: PUSH
15235: LD_INT 17
15237: PUSH
15238: LD_INT 8
15240: PUSH
15241: LD_INT 20
15243: PUSH
15244: LD_INT 21
15246: PUSH
15247: LD_INT 22
15249: PUSH
15250: LD_INT 72
15252: PUSH
15253: LD_INT 26
15255: PUSH
15256: LD_INT 69
15258: PUSH
15259: LD_INT 39
15261: PUSH
15262: LD_INT 40
15264: PUSH
15265: LD_INT 41
15267: PUSH
15268: LD_INT 42
15270: PUSH
15271: LD_INT 43
15273: PUSH
15274: LD_INT 48
15276: PUSH
15277: LD_INT 49
15279: PUSH
15280: LD_INT 50
15282: PUSH
15283: LD_INT 51
15285: PUSH
15286: LD_INT 52
15288: PUSH
15289: LD_INT 53
15291: PUSH
15292: LD_INT 54
15294: PUSH
15295: LD_INT 55
15297: PUSH
15298: LD_INT 56
15300: PUSH
15301: LD_INT 60
15303: PUSH
15304: LD_INT 61
15306: PUSH
15307: LD_INT 62
15309: PUSH
15310: LD_INT 66
15312: PUSH
15313: LD_INT 67
15315: PUSH
15316: LD_INT 68
15318: PUSH
15319: LD_INT 81
15321: PUSH
15322: LD_INT 82
15324: PUSH
15325: LD_INT 83
15327: PUSH
15328: LD_INT 84
15330: PUSH
15331: LD_INT 85
15333: PUSH
15334: LD_INT 87
15336: PUSH
15337: LD_INT 88
15339: PUSH
15340: EMPTY
15341: LIST
15342: LIST
15343: LIST
15344: LIST
15345: LIST
15346: LIST
15347: LIST
15348: LIST
15349: LIST
15350: LIST
15351: LIST
15352: LIST
15353: LIST
15354: LIST
15355: LIST
15356: LIST
15357: LIST
15358: LIST
15359: LIST
15360: LIST
15361: LIST
15362: LIST
15363: LIST
15364: LIST
15365: LIST
15366: LIST
15367: LIST
15368: LIST
15369: LIST
15370: LIST
15371: LIST
15372: LIST
15373: LIST
15374: LIST
15375: LIST
15376: LIST
15377: LIST
15378: LIST
15379: LIST
15380: LIST
15381: LIST
15382: LIST
15383: LIST
15384: LIST
15385: LIST
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: LIST
15391: LIST
15392: LIST
15393: LIST
15394: LIST
15395: ST_TO_ADDR
15396: GO 15629
15398: LD_INT 3
15400: DOUBLE
15401: EQUAL
15402: IFTRUE 15406
15404: GO 15628
15406: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
15407: LD_ADDR_VAR 0 4
15411: PUSH
15412: LD_INT 46
15414: PUSH
15415: LD_INT 47
15417: PUSH
15418: LD_INT 1
15420: PUSH
15421: LD_INT 2
15423: PUSH
15424: LD_INT 82
15426: PUSH
15427: LD_INT 83
15429: PUSH
15430: LD_INT 84
15432: PUSH
15433: LD_INT 85
15435: PUSH
15436: LD_INT 86
15438: PUSH
15439: LD_INT 11
15441: PUSH
15442: LD_INT 9
15444: PUSH
15445: LD_INT 20
15447: PUSH
15448: LD_INT 19
15450: PUSH
15451: LD_INT 21
15453: PUSH
15454: LD_INT 24
15456: PUSH
15457: LD_INT 22
15459: PUSH
15460: LD_INT 25
15462: PUSH
15463: LD_INT 28
15465: PUSH
15466: LD_INT 29
15468: PUSH
15469: LD_INT 30
15471: PUSH
15472: LD_INT 31
15474: PUSH
15475: LD_INT 37
15477: PUSH
15478: LD_INT 38
15480: PUSH
15481: LD_INT 32
15483: PUSH
15484: LD_INT 27
15486: PUSH
15487: LD_INT 33
15489: PUSH
15490: LD_INT 69
15492: PUSH
15493: LD_INT 39
15495: PUSH
15496: LD_INT 34
15498: PUSH
15499: LD_INT 40
15501: PUSH
15502: LD_INT 71
15504: PUSH
15505: LD_INT 23
15507: PUSH
15508: LD_INT 44
15510: PUSH
15511: LD_INT 48
15513: PUSH
15514: LD_INT 49
15516: PUSH
15517: LD_INT 50
15519: PUSH
15520: LD_INT 51
15522: PUSH
15523: LD_INT 52
15525: PUSH
15526: LD_INT 53
15528: PUSH
15529: LD_INT 54
15531: PUSH
15532: LD_INT 55
15534: PUSH
15535: LD_INT 56
15537: PUSH
15538: LD_INT 57
15540: PUSH
15541: LD_INT 58
15543: PUSH
15544: LD_INT 59
15546: PUSH
15547: LD_INT 63
15549: PUSH
15550: LD_INT 64
15552: PUSH
15553: LD_INT 65
15555: PUSH
15556: LD_INT 82
15558: PUSH
15559: LD_INT 83
15561: PUSH
15562: LD_INT 84
15564: PUSH
15565: LD_INT 85
15567: PUSH
15568: LD_INT 86
15570: PUSH
15571: EMPTY
15572: LIST
15573: LIST
15574: LIST
15575: LIST
15576: LIST
15577: LIST
15578: LIST
15579: LIST
15580: LIST
15581: LIST
15582: LIST
15583: LIST
15584: LIST
15585: LIST
15586: LIST
15587: LIST
15588: LIST
15589: LIST
15590: LIST
15591: LIST
15592: LIST
15593: LIST
15594: LIST
15595: LIST
15596: LIST
15597: LIST
15598: LIST
15599: LIST
15600: LIST
15601: LIST
15602: LIST
15603: LIST
15604: LIST
15605: LIST
15606: LIST
15607: LIST
15608: LIST
15609: LIST
15610: LIST
15611: LIST
15612: LIST
15613: LIST
15614: LIST
15615: LIST
15616: LIST
15617: LIST
15618: LIST
15619: LIST
15620: LIST
15621: LIST
15622: LIST
15623: LIST
15624: LIST
15625: ST_TO_ADDR
15626: GO 15629
15628: POP
// if state > - 1 and state < 3 then
15629: LD_VAR 0 3
15633: PUSH
15634: LD_INT 1
15636: NEG
15637: GREATER
15638: PUSH
15639: LD_VAR 0 3
15643: PUSH
15644: LD_INT 3
15646: LESS
15647: AND
15648: IFFALSE 15705
// for i in result do
15650: LD_ADDR_VAR 0 5
15654: PUSH
15655: LD_VAR 0 4
15659: PUSH
15660: FOR_IN
15661: IFFALSE 15703
// if GetTech ( i , side ) <> state then
15663: LD_VAR 0 5
15667: PPUSH
15668: LD_VAR 0 1
15672: PPUSH
15673: CALL_OW 321
15677: PUSH
15678: LD_VAR 0 3
15682: NONEQUAL
15683: IFFALSE 15701
// result := result diff i ;
15685: LD_ADDR_VAR 0 4
15689: PUSH
15690: LD_VAR 0 4
15694: PUSH
15695: LD_VAR 0 5
15699: DIFF
15700: ST_TO_ADDR
15701: GO 15660
15703: POP
15704: POP
// end ;
15705: LD_VAR 0 4
15709: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15710: LD_INT 0
15712: PPUSH
15713: PPUSH
15714: PPUSH
// result := true ;
15715: LD_ADDR_VAR 0 3
15719: PUSH
15720: LD_INT 1
15722: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15723: LD_ADDR_VAR 0 5
15727: PUSH
15728: LD_VAR 0 2
15732: PPUSH
15733: CALL_OW 480
15737: ST_TO_ADDR
// if not tmp then
15738: LD_VAR 0 5
15742: NOT
15743: IFFALSE 15747
// exit ;
15745: GO 15796
// for i in tmp do
15747: LD_ADDR_VAR 0 4
15751: PUSH
15752: LD_VAR 0 5
15756: PUSH
15757: FOR_IN
15758: IFFALSE 15794
// if GetTech ( i , side ) <> state_researched then
15760: LD_VAR 0 4
15764: PPUSH
15765: LD_VAR 0 1
15769: PPUSH
15770: CALL_OW 321
15774: PUSH
15775: LD_INT 2
15777: NONEQUAL
15778: IFFALSE 15792
// begin result := false ;
15780: LD_ADDR_VAR 0 3
15784: PUSH
15785: LD_INT 0
15787: ST_TO_ADDR
// exit ;
15788: POP
15789: POP
15790: GO 15796
// end ;
15792: GO 15757
15794: POP
15795: POP
// end ;
15796: LD_VAR 0 3
15800: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15801: LD_INT 0
15803: PPUSH
15804: PPUSH
15805: PPUSH
15806: PPUSH
15807: PPUSH
15808: PPUSH
15809: PPUSH
15810: PPUSH
15811: PPUSH
15812: PPUSH
15813: PPUSH
15814: PPUSH
15815: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15816: LD_VAR 0 1
15820: NOT
15821: PUSH
15822: LD_VAR 0 1
15826: PPUSH
15827: CALL_OW 257
15831: PUSH
15832: LD_INT 9
15834: NONEQUAL
15835: OR
15836: IFFALSE 15840
// exit ;
15838: GO 16413
// side := GetSide ( unit ) ;
15840: LD_ADDR_VAR 0 9
15844: PUSH
15845: LD_VAR 0 1
15849: PPUSH
15850: CALL_OW 255
15854: ST_TO_ADDR
// tech_space := tech_spacanom ;
15855: LD_ADDR_VAR 0 12
15859: PUSH
15860: LD_INT 29
15862: ST_TO_ADDR
// tech_time := tech_taurad ;
15863: LD_ADDR_VAR 0 13
15867: PUSH
15868: LD_INT 28
15870: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15871: LD_ADDR_VAR 0 11
15875: PUSH
15876: LD_VAR 0 1
15880: PPUSH
15881: CALL_OW 310
15885: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15886: LD_VAR 0 11
15890: PPUSH
15891: CALL_OW 247
15895: PUSH
15896: LD_INT 2
15898: EQUAL
15899: IFFALSE 15903
// exit ;
15901: GO 16413
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15903: LD_ADDR_VAR 0 8
15907: PUSH
15908: LD_INT 81
15910: PUSH
15911: LD_VAR 0 9
15915: PUSH
15916: EMPTY
15917: LIST
15918: LIST
15919: PUSH
15920: LD_INT 3
15922: PUSH
15923: LD_INT 21
15925: PUSH
15926: LD_INT 3
15928: PUSH
15929: EMPTY
15930: LIST
15931: LIST
15932: PUSH
15933: EMPTY
15934: LIST
15935: LIST
15936: PUSH
15937: EMPTY
15938: LIST
15939: LIST
15940: PPUSH
15941: CALL_OW 69
15945: ST_TO_ADDR
// if not tmp then
15946: LD_VAR 0 8
15950: NOT
15951: IFFALSE 15955
// exit ;
15953: GO 16413
// if in_unit then
15955: LD_VAR 0 11
15959: IFFALSE 15983
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15961: LD_ADDR_VAR 0 10
15965: PUSH
15966: LD_VAR 0 8
15970: PPUSH
15971: LD_VAR 0 11
15975: PPUSH
15976: CALL_OW 74
15980: ST_TO_ADDR
15981: GO 16003
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15983: LD_ADDR_VAR 0 10
15987: PUSH
15988: LD_VAR 0 8
15992: PPUSH
15993: LD_VAR 0 1
15997: PPUSH
15998: CALL_OW 74
16002: ST_TO_ADDR
// if not enemy then
16003: LD_VAR 0 10
16007: NOT
16008: IFFALSE 16012
// exit ;
16010: GO 16413
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
16012: LD_VAR 0 11
16016: PUSH
16017: LD_VAR 0 11
16021: PPUSH
16022: LD_VAR 0 10
16026: PPUSH
16027: CALL_OW 296
16031: PUSH
16032: LD_INT 13
16034: GREATER
16035: AND
16036: PUSH
16037: LD_VAR 0 1
16041: PPUSH
16042: LD_VAR 0 10
16046: PPUSH
16047: CALL_OW 296
16051: PUSH
16052: LD_INT 12
16054: GREATER
16055: OR
16056: IFFALSE 16060
// exit ;
16058: GO 16413
// missile := [ 1 ] ;
16060: LD_ADDR_VAR 0 14
16064: PUSH
16065: LD_INT 1
16067: PUSH
16068: EMPTY
16069: LIST
16070: ST_TO_ADDR
// if Researched ( side , tech_space ) then
16071: LD_VAR 0 9
16075: PPUSH
16076: LD_VAR 0 12
16080: PPUSH
16081: CALL_OW 325
16085: IFFALSE 16114
// missile := Replace ( missile , missile + 1 , 2 ) ;
16087: LD_ADDR_VAR 0 14
16091: PUSH
16092: LD_VAR 0 14
16096: PPUSH
16097: LD_VAR 0 14
16101: PUSH
16102: LD_INT 1
16104: PLUS
16105: PPUSH
16106: LD_INT 2
16108: PPUSH
16109: CALL_OW 1
16113: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16114: LD_VAR 0 9
16118: PPUSH
16119: LD_VAR 0 13
16123: PPUSH
16124: CALL_OW 325
16128: PUSH
16129: LD_VAR 0 10
16133: PPUSH
16134: CALL_OW 255
16138: PPUSH
16139: LD_VAR 0 13
16143: PPUSH
16144: CALL_OW 325
16148: NOT
16149: AND
16150: IFFALSE 16179
// missile := Replace ( missile , missile + 1 , 3 ) ;
16152: LD_ADDR_VAR 0 14
16156: PUSH
16157: LD_VAR 0 14
16161: PPUSH
16162: LD_VAR 0 14
16166: PUSH
16167: LD_INT 1
16169: PLUS
16170: PPUSH
16171: LD_INT 3
16173: PPUSH
16174: CALL_OW 1
16178: ST_TO_ADDR
// if missile < 2 then
16179: LD_VAR 0 14
16183: PUSH
16184: LD_INT 2
16186: LESS
16187: IFFALSE 16191
// exit ;
16189: GO 16413
// x := GetX ( enemy ) ;
16191: LD_ADDR_VAR 0 4
16195: PUSH
16196: LD_VAR 0 10
16200: PPUSH
16201: CALL_OW 250
16205: ST_TO_ADDR
// y := GetY ( enemy ) ;
16206: LD_ADDR_VAR 0 5
16210: PUSH
16211: LD_VAR 0 10
16215: PPUSH
16216: CALL_OW 251
16220: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16221: LD_ADDR_VAR 0 6
16225: PUSH
16226: LD_VAR 0 4
16230: PUSH
16231: LD_INT 1
16233: NEG
16234: PPUSH
16235: LD_INT 1
16237: PPUSH
16238: CALL_OW 12
16242: PLUS
16243: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16244: LD_ADDR_VAR 0 7
16248: PUSH
16249: LD_VAR 0 5
16253: PUSH
16254: LD_INT 1
16256: NEG
16257: PPUSH
16258: LD_INT 1
16260: PPUSH
16261: CALL_OW 12
16265: PLUS
16266: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16267: LD_VAR 0 6
16271: PPUSH
16272: LD_VAR 0 7
16276: PPUSH
16277: CALL_OW 488
16281: NOT
16282: IFFALSE 16304
// begin _x := x ;
16284: LD_ADDR_VAR 0 6
16288: PUSH
16289: LD_VAR 0 4
16293: ST_TO_ADDR
// _y := y ;
16294: LD_ADDR_VAR 0 7
16298: PUSH
16299: LD_VAR 0 5
16303: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16304: LD_ADDR_VAR 0 3
16308: PUSH
16309: LD_INT 1
16311: PPUSH
16312: LD_VAR 0 14
16316: PPUSH
16317: CALL_OW 12
16321: ST_TO_ADDR
// case i of 1 :
16322: LD_VAR 0 3
16326: PUSH
16327: LD_INT 1
16329: DOUBLE
16330: EQUAL
16331: IFTRUE 16335
16333: GO 16352
16335: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16336: LD_VAR 0 1
16340: PPUSH
16341: LD_VAR 0 10
16345: PPUSH
16346: CALL_OW 115
16350: GO 16413
16352: LD_INT 2
16354: DOUBLE
16355: EQUAL
16356: IFTRUE 16360
16358: GO 16382
16360: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
16361: LD_VAR 0 1
16365: PPUSH
16366: LD_VAR 0 6
16370: PPUSH
16371: LD_VAR 0 7
16375: PPUSH
16376: CALL_OW 153
16380: GO 16413
16382: LD_INT 3
16384: DOUBLE
16385: EQUAL
16386: IFTRUE 16390
16388: GO 16412
16390: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
16391: LD_VAR 0 1
16395: PPUSH
16396: LD_VAR 0 6
16400: PPUSH
16401: LD_VAR 0 7
16405: PPUSH
16406: CALL_OW 154
16410: GO 16413
16412: POP
// end ;
16413: LD_VAR 0 2
16417: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
16418: LD_INT 0
16420: PPUSH
16421: PPUSH
16422: PPUSH
16423: PPUSH
16424: PPUSH
16425: PPUSH
// if not unit or not building then
16426: LD_VAR 0 1
16430: NOT
16431: PUSH
16432: LD_VAR 0 2
16436: NOT
16437: OR
16438: IFFALSE 16442
// exit ;
16440: GO 16600
// x := GetX ( building ) ;
16442: LD_ADDR_VAR 0 5
16446: PUSH
16447: LD_VAR 0 2
16451: PPUSH
16452: CALL_OW 250
16456: ST_TO_ADDR
// y := GetY ( building ) ;
16457: LD_ADDR_VAR 0 6
16461: PUSH
16462: LD_VAR 0 2
16466: PPUSH
16467: CALL_OW 251
16471: ST_TO_ADDR
// for i = 0 to 5 do
16472: LD_ADDR_VAR 0 4
16476: PUSH
16477: DOUBLE
16478: LD_INT 0
16480: DEC
16481: ST_TO_ADDR
16482: LD_INT 5
16484: PUSH
16485: FOR_TO
16486: IFFALSE 16598
// begin _x := ShiftX ( x , i , 3 ) ;
16488: LD_ADDR_VAR 0 7
16492: PUSH
16493: LD_VAR 0 5
16497: PPUSH
16498: LD_VAR 0 4
16502: PPUSH
16503: LD_INT 3
16505: PPUSH
16506: CALL_OW 272
16510: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
16511: LD_ADDR_VAR 0 8
16515: PUSH
16516: LD_VAR 0 6
16520: PPUSH
16521: LD_VAR 0 4
16525: PPUSH
16526: LD_INT 3
16528: PPUSH
16529: CALL_OW 273
16533: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16534: LD_VAR 0 7
16538: PPUSH
16539: LD_VAR 0 8
16543: PPUSH
16544: CALL_OW 488
16548: NOT
16549: IFFALSE 16553
// continue ;
16551: GO 16485
// if HexInfo ( _x , _y ) = 0 then
16553: LD_VAR 0 7
16557: PPUSH
16558: LD_VAR 0 8
16562: PPUSH
16563: CALL_OW 428
16567: PUSH
16568: LD_INT 0
16570: EQUAL
16571: IFFALSE 16596
// begin ComMoveXY ( unit , _x , _y ) ;
16573: LD_VAR 0 1
16577: PPUSH
16578: LD_VAR 0 7
16582: PPUSH
16583: LD_VAR 0 8
16587: PPUSH
16588: CALL_OW 111
// exit ;
16592: POP
16593: POP
16594: GO 16600
// end ; end ;
16596: GO 16485
16598: POP
16599: POP
// end ;
16600: LD_VAR 0 3
16604: RET
// export function ScanBase ( side , base_area ) ; begin
16605: LD_INT 0
16607: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16608: LD_ADDR_VAR 0 3
16612: PUSH
16613: LD_VAR 0 2
16617: PPUSH
16618: LD_INT 81
16620: PUSH
16621: LD_VAR 0 1
16625: PUSH
16626: EMPTY
16627: LIST
16628: LIST
16629: PPUSH
16630: CALL_OW 70
16634: ST_TO_ADDR
// end ;
16635: LD_VAR 0 3
16639: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16640: LD_INT 0
16642: PPUSH
16643: PPUSH
16644: PPUSH
16645: PPUSH
// result := false ;
16646: LD_ADDR_VAR 0 2
16650: PUSH
16651: LD_INT 0
16653: ST_TO_ADDR
// side := GetSide ( unit ) ;
16654: LD_ADDR_VAR 0 3
16658: PUSH
16659: LD_VAR 0 1
16663: PPUSH
16664: CALL_OW 255
16668: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16669: LD_ADDR_VAR 0 4
16673: PUSH
16674: LD_VAR 0 1
16678: PPUSH
16679: CALL_OW 248
16683: ST_TO_ADDR
// case nat of 1 :
16684: LD_VAR 0 4
16688: PUSH
16689: LD_INT 1
16691: DOUBLE
16692: EQUAL
16693: IFTRUE 16697
16695: GO 16708
16697: POP
// tech := tech_lassight ; 2 :
16698: LD_ADDR_VAR 0 5
16702: PUSH
16703: LD_INT 12
16705: ST_TO_ADDR
16706: GO 16747
16708: LD_INT 2
16710: DOUBLE
16711: EQUAL
16712: IFTRUE 16716
16714: GO 16727
16716: POP
// tech := tech_mortar ; 3 :
16717: LD_ADDR_VAR 0 5
16721: PUSH
16722: LD_INT 41
16724: ST_TO_ADDR
16725: GO 16747
16727: LD_INT 3
16729: DOUBLE
16730: EQUAL
16731: IFTRUE 16735
16733: GO 16746
16735: POP
// tech := tech_bazooka ; end ;
16736: LD_ADDR_VAR 0 5
16740: PUSH
16741: LD_INT 44
16743: ST_TO_ADDR
16744: GO 16747
16746: POP
// if Researched ( side , tech ) then
16747: LD_VAR 0 3
16751: PPUSH
16752: LD_VAR 0 5
16756: PPUSH
16757: CALL_OW 325
16761: IFFALSE 16788
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16763: LD_ADDR_VAR 0 2
16767: PUSH
16768: LD_INT 5
16770: PUSH
16771: LD_INT 8
16773: PUSH
16774: LD_INT 9
16776: PUSH
16777: EMPTY
16778: LIST
16779: LIST
16780: LIST
16781: PUSH
16782: LD_VAR 0 4
16786: ARRAY
16787: ST_TO_ADDR
// end ;
16788: LD_VAR 0 2
16792: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16793: LD_INT 0
16795: PPUSH
16796: PPUSH
16797: PPUSH
// if not mines then
16798: LD_VAR 0 2
16802: NOT
16803: IFFALSE 16807
// exit ;
16805: GO 16951
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16807: LD_ADDR_VAR 0 5
16811: PUSH
16812: LD_INT 81
16814: PUSH
16815: LD_VAR 0 1
16819: PUSH
16820: EMPTY
16821: LIST
16822: LIST
16823: PUSH
16824: LD_INT 3
16826: PUSH
16827: LD_INT 21
16829: PUSH
16830: LD_INT 3
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: PUSH
16837: EMPTY
16838: LIST
16839: LIST
16840: PUSH
16841: EMPTY
16842: LIST
16843: LIST
16844: PPUSH
16845: CALL_OW 69
16849: ST_TO_ADDR
// for i in mines do
16850: LD_ADDR_VAR 0 4
16854: PUSH
16855: LD_VAR 0 2
16859: PUSH
16860: FOR_IN
16861: IFFALSE 16949
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16863: LD_VAR 0 4
16867: PUSH
16868: LD_INT 1
16870: ARRAY
16871: PPUSH
16872: LD_VAR 0 4
16876: PUSH
16877: LD_INT 2
16879: ARRAY
16880: PPUSH
16881: CALL_OW 458
16885: NOT
16886: IFFALSE 16890
// continue ;
16888: GO 16860
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16890: LD_VAR 0 4
16894: PUSH
16895: LD_INT 1
16897: ARRAY
16898: PPUSH
16899: LD_VAR 0 4
16903: PUSH
16904: LD_INT 2
16906: ARRAY
16907: PPUSH
16908: CALL_OW 428
16912: PUSH
16913: LD_VAR 0 5
16917: IN
16918: IFFALSE 16947
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16920: LD_VAR 0 4
16924: PUSH
16925: LD_INT 1
16927: ARRAY
16928: PPUSH
16929: LD_VAR 0 4
16933: PUSH
16934: LD_INT 2
16936: ARRAY
16937: PPUSH
16938: LD_VAR 0 1
16942: PPUSH
16943: CALL_OW 456
// end ;
16947: GO 16860
16949: POP
16950: POP
// end ;
16951: LD_VAR 0 3
16955: RET
// export function Count ( array ) ; var i ; begin
16956: LD_INT 0
16958: PPUSH
16959: PPUSH
// result := 0 ;
16960: LD_ADDR_VAR 0 2
16964: PUSH
16965: LD_INT 0
16967: ST_TO_ADDR
// for i in array do
16968: LD_ADDR_VAR 0 3
16972: PUSH
16973: LD_VAR 0 1
16977: PUSH
16978: FOR_IN
16979: IFFALSE 17003
// if i then
16981: LD_VAR 0 3
16985: IFFALSE 17001
// result := result + 1 ;
16987: LD_ADDR_VAR 0 2
16991: PUSH
16992: LD_VAR 0 2
16996: PUSH
16997: LD_INT 1
16999: PLUS
17000: ST_TO_ADDR
17001: GO 16978
17003: POP
17004: POP
// end ;
17005: LD_VAR 0 2
17009: RET
// export function IsEmpty ( building ) ; begin
17010: LD_INT 0
17012: PPUSH
// if not building then
17013: LD_VAR 0 1
17017: NOT
17018: IFFALSE 17022
// exit ;
17020: GO 17065
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17022: LD_ADDR_VAR 0 2
17026: PUSH
17027: LD_VAR 0 1
17031: PUSH
17032: LD_INT 22
17034: PUSH
17035: LD_VAR 0 1
17039: PPUSH
17040: CALL_OW 255
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: PUSH
17049: LD_INT 58
17051: PUSH
17052: EMPTY
17053: LIST
17054: PUSH
17055: EMPTY
17056: LIST
17057: LIST
17058: PPUSH
17059: CALL_OW 69
17063: IN
17064: ST_TO_ADDR
// end ;
17065: LD_VAR 0 2
17069: RET
// export function IsNotFull ( building ) ; var places ; begin
17070: LD_INT 0
17072: PPUSH
17073: PPUSH
// if not building then
17074: LD_VAR 0 1
17078: NOT
17079: IFFALSE 17083
// exit ;
17081: GO 17254
// result := false ;
17083: LD_ADDR_VAR 0 2
17087: PUSH
17088: LD_INT 0
17090: ST_TO_ADDR
// places := 0 ;
17091: LD_ADDR_VAR 0 3
17095: PUSH
17096: LD_INT 0
17098: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
17099: LD_VAR 0 1
17103: PPUSH
17104: CALL_OW 266
17108: PUSH
17109: LD_INT 0
17111: DOUBLE
17112: EQUAL
17113: IFTRUE 17171
17115: LD_INT 1
17117: DOUBLE
17118: EQUAL
17119: IFTRUE 17171
17121: LD_INT 6
17123: DOUBLE
17124: EQUAL
17125: IFTRUE 17171
17127: LD_INT 7
17129: DOUBLE
17130: EQUAL
17131: IFTRUE 17171
17133: LD_INT 8
17135: DOUBLE
17136: EQUAL
17137: IFTRUE 17171
17139: LD_INT 4
17141: DOUBLE
17142: EQUAL
17143: IFTRUE 17171
17145: LD_INT 5
17147: DOUBLE
17148: EQUAL
17149: IFTRUE 17171
17151: LD_INT 2
17153: DOUBLE
17154: EQUAL
17155: IFTRUE 17171
17157: LD_INT 3
17159: DOUBLE
17160: EQUAL
17161: IFTRUE 17171
17163: LD_INT 35
17165: DOUBLE
17166: EQUAL
17167: IFTRUE 17171
17169: GO 17182
17171: POP
// places := 6 ; b_bunker , b_breastwork :
17172: LD_ADDR_VAR 0 3
17176: PUSH
17177: LD_INT 6
17179: ST_TO_ADDR
17180: GO 17227
17182: LD_INT 32
17184: DOUBLE
17185: EQUAL
17186: IFTRUE 17196
17188: LD_INT 31
17190: DOUBLE
17191: EQUAL
17192: IFTRUE 17196
17194: GO 17207
17196: POP
// places := 1 ; b_control_tower :
17197: LD_ADDR_VAR 0 3
17201: PUSH
17202: LD_INT 1
17204: ST_TO_ADDR
17205: GO 17227
17207: LD_INT 36
17209: DOUBLE
17210: EQUAL
17211: IFTRUE 17215
17213: GO 17226
17215: POP
// places := 3 ; end ;
17216: LD_ADDR_VAR 0 3
17220: PUSH
17221: LD_INT 3
17223: ST_TO_ADDR
17224: GO 17227
17226: POP
// if places then
17227: LD_VAR 0 3
17231: IFFALSE 17254
// result := UnitsInside ( building ) < places ;
17233: LD_ADDR_VAR 0 2
17237: PUSH
17238: LD_VAR 0 1
17242: PPUSH
17243: CALL_OW 313
17247: PUSH
17248: LD_VAR 0 3
17252: LESS
17253: ST_TO_ADDR
// end ;
17254: LD_VAR 0 2
17258: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17259: LD_INT 0
17261: PPUSH
17262: PPUSH
17263: PPUSH
17264: PPUSH
// tmp := [ ] ;
17265: LD_ADDR_VAR 0 3
17269: PUSH
17270: EMPTY
17271: ST_TO_ADDR
// list := [ ] ;
17272: LD_ADDR_VAR 0 5
17276: PUSH
17277: EMPTY
17278: ST_TO_ADDR
// for i = 16 to 25 do
17279: LD_ADDR_VAR 0 4
17283: PUSH
17284: DOUBLE
17285: LD_INT 16
17287: DEC
17288: ST_TO_ADDR
17289: LD_INT 25
17291: PUSH
17292: FOR_TO
17293: IFFALSE 17366
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17295: LD_ADDR_VAR 0 3
17299: PUSH
17300: LD_VAR 0 3
17304: PUSH
17305: LD_INT 22
17307: PUSH
17308: LD_VAR 0 1
17312: PPUSH
17313: CALL_OW 255
17317: PUSH
17318: EMPTY
17319: LIST
17320: LIST
17321: PUSH
17322: LD_INT 91
17324: PUSH
17325: LD_VAR 0 1
17329: PUSH
17330: LD_INT 6
17332: PUSH
17333: EMPTY
17334: LIST
17335: LIST
17336: LIST
17337: PUSH
17338: LD_INT 30
17340: PUSH
17341: LD_VAR 0 4
17345: PUSH
17346: EMPTY
17347: LIST
17348: LIST
17349: PUSH
17350: EMPTY
17351: LIST
17352: LIST
17353: LIST
17354: PUSH
17355: EMPTY
17356: LIST
17357: PPUSH
17358: CALL_OW 69
17362: ADD
17363: ST_TO_ADDR
17364: GO 17292
17366: POP
17367: POP
// for i = 1 to tmp do
17368: LD_ADDR_VAR 0 4
17372: PUSH
17373: DOUBLE
17374: LD_INT 1
17376: DEC
17377: ST_TO_ADDR
17378: LD_VAR 0 3
17382: PUSH
17383: FOR_TO
17384: IFFALSE 17472
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17386: LD_ADDR_VAR 0 5
17390: PUSH
17391: LD_VAR 0 5
17395: PUSH
17396: LD_VAR 0 3
17400: PUSH
17401: LD_VAR 0 4
17405: ARRAY
17406: PPUSH
17407: CALL_OW 266
17411: PUSH
17412: LD_VAR 0 3
17416: PUSH
17417: LD_VAR 0 4
17421: ARRAY
17422: PPUSH
17423: CALL_OW 250
17427: PUSH
17428: LD_VAR 0 3
17432: PUSH
17433: LD_VAR 0 4
17437: ARRAY
17438: PPUSH
17439: CALL_OW 251
17443: PUSH
17444: LD_VAR 0 3
17448: PUSH
17449: LD_VAR 0 4
17453: ARRAY
17454: PPUSH
17455: CALL_OW 254
17459: PUSH
17460: EMPTY
17461: LIST
17462: LIST
17463: LIST
17464: LIST
17465: PUSH
17466: EMPTY
17467: LIST
17468: ADD
17469: ST_TO_ADDR
17470: GO 17383
17472: POP
17473: POP
// result := list ;
17474: LD_ADDR_VAR 0 2
17478: PUSH
17479: LD_VAR 0 5
17483: ST_TO_ADDR
// end ;
17484: LD_VAR 0 2
17488: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17489: LD_INT 0
17491: PPUSH
17492: PPUSH
17493: PPUSH
17494: PPUSH
17495: PPUSH
17496: PPUSH
17497: PPUSH
// if not factory then
17498: LD_VAR 0 1
17502: NOT
17503: IFFALSE 17507
// exit ;
17505: GO 18100
// if control = control_apeman then
17507: LD_VAR 0 4
17511: PUSH
17512: LD_INT 5
17514: EQUAL
17515: IFFALSE 17624
// begin tmp := UnitsInside ( factory ) ;
17517: LD_ADDR_VAR 0 8
17521: PUSH
17522: LD_VAR 0 1
17526: PPUSH
17527: CALL_OW 313
17531: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17532: LD_VAR 0 8
17536: PPUSH
17537: LD_INT 25
17539: PUSH
17540: LD_INT 12
17542: PUSH
17543: EMPTY
17544: LIST
17545: LIST
17546: PPUSH
17547: CALL_OW 72
17551: NOT
17552: IFFALSE 17562
// control := control_manual ;
17554: LD_ADDR_VAR 0 4
17558: PUSH
17559: LD_INT 1
17561: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17562: LD_ADDR_VAR 0 8
17566: PUSH
17567: LD_VAR 0 1
17571: PPUSH
17572: CALL 17259 0 1
17576: ST_TO_ADDR
// if tmp then
17577: LD_VAR 0 8
17581: IFFALSE 17624
// begin for i in tmp do
17583: LD_ADDR_VAR 0 7
17587: PUSH
17588: LD_VAR 0 8
17592: PUSH
17593: FOR_IN
17594: IFFALSE 17622
// if i [ 1 ] = b_ext_radio then
17596: LD_VAR 0 7
17600: PUSH
17601: LD_INT 1
17603: ARRAY
17604: PUSH
17605: LD_INT 22
17607: EQUAL
17608: IFFALSE 17620
// begin control := control_remote ;
17610: LD_ADDR_VAR 0 4
17614: PUSH
17615: LD_INT 2
17617: ST_TO_ADDR
// break ;
17618: GO 17622
// end ;
17620: GO 17593
17622: POP
17623: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17624: LD_VAR 0 1
17628: PPUSH
17629: LD_VAR 0 2
17633: PPUSH
17634: LD_VAR 0 3
17638: PPUSH
17639: LD_VAR 0 4
17643: PPUSH
17644: LD_VAR 0 5
17648: PPUSH
17649: CALL_OW 448
17653: IFFALSE 17688
// begin result := [ chassis , engine , control , weapon ] ;
17655: LD_ADDR_VAR 0 6
17659: PUSH
17660: LD_VAR 0 2
17664: PUSH
17665: LD_VAR 0 3
17669: PUSH
17670: LD_VAR 0 4
17674: PUSH
17675: LD_VAR 0 5
17679: PUSH
17680: EMPTY
17681: LIST
17682: LIST
17683: LIST
17684: LIST
17685: ST_TO_ADDR
// exit ;
17686: GO 18100
// end ; _chassis := AvailableChassisList ( factory ) ;
17688: LD_ADDR_VAR 0 9
17692: PUSH
17693: LD_VAR 0 1
17697: PPUSH
17698: CALL_OW 475
17702: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17703: LD_ADDR_VAR 0 11
17707: PUSH
17708: LD_VAR 0 1
17712: PPUSH
17713: CALL_OW 476
17717: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17718: LD_ADDR_VAR 0 12
17722: PUSH
17723: LD_VAR 0 1
17727: PPUSH
17728: CALL_OW 477
17732: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17733: LD_ADDR_VAR 0 10
17737: PUSH
17738: LD_VAR 0 1
17742: PPUSH
17743: CALL_OW 478
17747: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17748: LD_VAR 0 9
17752: NOT
17753: PUSH
17754: LD_VAR 0 11
17758: NOT
17759: OR
17760: PUSH
17761: LD_VAR 0 12
17765: NOT
17766: OR
17767: PUSH
17768: LD_VAR 0 10
17772: NOT
17773: OR
17774: IFFALSE 17809
// begin result := [ chassis , engine , control , weapon ] ;
17776: LD_ADDR_VAR 0 6
17780: PUSH
17781: LD_VAR 0 2
17785: PUSH
17786: LD_VAR 0 3
17790: PUSH
17791: LD_VAR 0 4
17795: PUSH
17796: LD_VAR 0 5
17800: PUSH
17801: EMPTY
17802: LIST
17803: LIST
17804: LIST
17805: LIST
17806: ST_TO_ADDR
// exit ;
17807: GO 18100
// end ; if not chassis in _chassis then
17809: LD_VAR 0 2
17813: PUSH
17814: LD_VAR 0 9
17818: IN
17819: NOT
17820: IFFALSE 17846
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17822: LD_ADDR_VAR 0 2
17826: PUSH
17827: LD_VAR 0 9
17831: PUSH
17832: LD_INT 1
17834: PPUSH
17835: LD_VAR 0 9
17839: PPUSH
17840: CALL_OW 12
17844: ARRAY
17845: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17846: LD_VAR 0 2
17850: PPUSH
17851: LD_VAR 0 3
17855: PPUSH
17856: CALL 18105 0 2
17860: NOT
17861: IFFALSE 17920
// repeat engine := _engine [ 1 ] ;
17863: LD_ADDR_VAR 0 3
17867: PUSH
17868: LD_VAR 0 11
17872: PUSH
17873: LD_INT 1
17875: ARRAY
17876: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17877: LD_ADDR_VAR 0 11
17881: PUSH
17882: LD_VAR 0 11
17886: PPUSH
17887: LD_INT 1
17889: PPUSH
17890: CALL_OW 3
17894: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17895: LD_VAR 0 2
17899: PPUSH
17900: LD_VAR 0 3
17904: PPUSH
17905: CALL 18105 0 2
17909: PUSH
17910: LD_VAR 0 11
17914: PUSH
17915: EMPTY
17916: EQUAL
17917: OR
17918: IFFALSE 17863
// if not control in _control then
17920: LD_VAR 0 4
17924: PUSH
17925: LD_VAR 0 12
17929: IN
17930: NOT
17931: IFFALSE 17957
// control := _control [ rand ( 1 , _control ) ] ;
17933: LD_ADDR_VAR 0 4
17937: PUSH
17938: LD_VAR 0 12
17942: PUSH
17943: LD_INT 1
17945: PPUSH
17946: LD_VAR 0 12
17950: PPUSH
17951: CALL_OW 12
17955: ARRAY
17956: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17957: LD_VAR 0 2
17961: PPUSH
17962: LD_VAR 0 5
17966: PPUSH
17967: CALL 18325 0 2
17971: NOT
17972: IFFALSE 18031
// repeat weapon := _weapon [ 1 ] ;
17974: LD_ADDR_VAR 0 5
17978: PUSH
17979: LD_VAR 0 10
17983: PUSH
17984: LD_INT 1
17986: ARRAY
17987: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17988: LD_ADDR_VAR 0 10
17992: PUSH
17993: LD_VAR 0 10
17997: PPUSH
17998: LD_INT 1
18000: PPUSH
18001: CALL_OW 3
18005: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18006: LD_VAR 0 2
18010: PPUSH
18011: LD_VAR 0 5
18015: PPUSH
18016: CALL 18325 0 2
18020: PUSH
18021: LD_VAR 0 10
18025: PUSH
18026: EMPTY
18027: EQUAL
18028: OR
18029: IFFALSE 17974
// result := [ ] ;
18031: LD_ADDR_VAR 0 6
18035: PUSH
18036: EMPTY
18037: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18038: LD_VAR 0 1
18042: PPUSH
18043: LD_VAR 0 2
18047: PPUSH
18048: LD_VAR 0 3
18052: PPUSH
18053: LD_VAR 0 4
18057: PPUSH
18058: LD_VAR 0 5
18062: PPUSH
18063: CALL_OW 448
18067: IFFALSE 18100
// result := [ chassis , engine , control , weapon ] ;
18069: LD_ADDR_VAR 0 6
18073: PUSH
18074: LD_VAR 0 2
18078: PUSH
18079: LD_VAR 0 3
18083: PUSH
18084: LD_VAR 0 4
18088: PUSH
18089: LD_VAR 0 5
18093: PUSH
18094: EMPTY
18095: LIST
18096: LIST
18097: LIST
18098: LIST
18099: ST_TO_ADDR
// end ;
18100: LD_VAR 0 6
18104: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18105: LD_INT 0
18107: PPUSH
// if not chassis or not engine then
18108: LD_VAR 0 1
18112: NOT
18113: PUSH
18114: LD_VAR 0 2
18118: NOT
18119: OR
18120: IFFALSE 18124
// exit ;
18122: GO 18320
// case engine of engine_solar :
18124: LD_VAR 0 2
18128: PUSH
18129: LD_INT 2
18131: DOUBLE
18132: EQUAL
18133: IFTRUE 18137
18135: GO 18175
18137: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18138: LD_ADDR_VAR 0 3
18142: PUSH
18143: LD_INT 11
18145: PUSH
18146: LD_INT 12
18148: PUSH
18149: LD_INT 13
18151: PUSH
18152: LD_INT 14
18154: PUSH
18155: LD_INT 1
18157: PUSH
18158: LD_INT 2
18160: PUSH
18161: LD_INT 3
18163: PUSH
18164: EMPTY
18165: LIST
18166: LIST
18167: LIST
18168: LIST
18169: LIST
18170: LIST
18171: LIST
18172: ST_TO_ADDR
18173: GO 18304
18175: LD_INT 1
18177: DOUBLE
18178: EQUAL
18179: IFTRUE 18183
18181: GO 18245
18183: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18184: LD_ADDR_VAR 0 3
18188: PUSH
18189: LD_INT 11
18191: PUSH
18192: LD_INT 12
18194: PUSH
18195: LD_INT 13
18197: PUSH
18198: LD_INT 14
18200: PUSH
18201: LD_INT 1
18203: PUSH
18204: LD_INT 2
18206: PUSH
18207: LD_INT 3
18209: PUSH
18210: LD_INT 4
18212: PUSH
18213: LD_INT 5
18215: PUSH
18216: LD_INT 21
18218: PUSH
18219: LD_INT 23
18221: PUSH
18222: LD_INT 22
18224: PUSH
18225: LD_INT 24
18227: PUSH
18228: EMPTY
18229: LIST
18230: LIST
18231: LIST
18232: LIST
18233: LIST
18234: LIST
18235: LIST
18236: LIST
18237: LIST
18238: LIST
18239: LIST
18240: LIST
18241: LIST
18242: ST_TO_ADDR
18243: GO 18304
18245: LD_INT 3
18247: DOUBLE
18248: EQUAL
18249: IFTRUE 18253
18251: GO 18303
18253: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18254: LD_ADDR_VAR 0 3
18258: PUSH
18259: LD_INT 13
18261: PUSH
18262: LD_INT 14
18264: PUSH
18265: LD_INT 2
18267: PUSH
18268: LD_INT 3
18270: PUSH
18271: LD_INT 4
18273: PUSH
18274: LD_INT 5
18276: PUSH
18277: LD_INT 21
18279: PUSH
18280: LD_INT 22
18282: PUSH
18283: LD_INT 23
18285: PUSH
18286: LD_INT 24
18288: PUSH
18289: EMPTY
18290: LIST
18291: LIST
18292: LIST
18293: LIST
18294: LIST
18295: LIST
18296: LIST
18297: LIST
18298: LIST
18299: LIST
18300: ST_TO_ADDR
18301: GO 18304
18303: POP
// result := ( chassis in result ) ;
18304: LD_ADDR_VAR 0 3
18308: PUSH
18309: LD_VAR 0 1
18313: PUSH
18314: LD_VAR 0 3
18318: IN
18319: ST_TO_ADDR
// end ;
18320: LD_VAR 0 3
18324: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18325: LD_INT 0
18327: PPUSH
// if not chassis or not weapon then
18328: LD_VAR 0 1
18332: NOT
18333: PUSH
18334: LD_VAR 0 2
18338: NOT
18339: OR
18340: IFFALSE 18344
// exit ;
18342: GO 19404
// case weapon of us_machine_gun :
18344: LD_VAR 0 2
18348: PUSH
18349: LD_INT 2
18351: DOUBLE
18352: EQUAL
18353: IFTRUE 18357
18355: GO 18387
18357: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18358: LD_ADDR_VAR 0 3
18362: PUSH
18363: LD_INT 1
18365: PUSH
18366: LD_INT 2
18368: PUSH
18369: LD_INT 3
18371: PUSH
18372: LD_INT 4
18374: PUSH
18375: LD_INT 5
18377: PUSH
18378: EMPTY
18379: LIST
18380: LIST
18381: LIST
18382: LIST
18383: LIST
18384: ST_TO_ADDR
18385: GO 19388
18387: LD_INT 3
18389: DOUBLE
18390: EQUAL
18391: IFTRUE 18395
18393: GO 18425
18395: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18396: LD_ADDR_VAR 0 3
18400: PUSH
18401: LD_INT 1
18403: PUSH
18404: LD_INT 2
18406: PUSH
18407: LD_INT 3
18409: PUSH
18410: LD_INT 4
18412: PUSH
18413: LD_INT 5
18415: PUSH
18416: EMPTY
18417: LIST
18418: LIST
18419: LIST
18420: LIST
18421: LIST
18422: ST_TO_ADDR
18423: GO 19388
18425: LD_INT 11
18427: DOUBLE
18428: EQUAL
18429: IFTRUE 18433
18431: GO 18463
18433: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18434: LD_ADDR_VAR 0 3
18438: PUSH
18439: LD_INT 1
18441: PUSH
18442: LD_INT 2
18444: PUSH
18445: LD_INT 3
18447: PUSH
18448: LD_INT 4
18450: PUSH
18451: LD_INT 5
18453: PUSH
18454: EMPTY
18455: LIST
18456: LIST
18457: LIST
18458: LIST
18459: LIST
18460: ST_TO_ADDR
18461: GO 19388
18463: LD_INT 4
18465: DOUBLE
18466: EQUAL
18467: IFTRUE 18471
18469: GO 18497
18471: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18472: LD_ADDR_VAR 0 3
18476: PUSH
18477: LD_INT 2
18479: PUSH
18480: LD_INT 3
18482: PUSH
18483: LD_INT 4
18485: PUSH
18486: LD_INT 5
18488: PUSH
18489: EMPTY
18490: LIST
18491: LIST
18492: LIST
18493: LIST
18494: ST_TO_ADDR
18495: GO 19388
18497: LD_INT 5
18499: DOUBLE
18500: EQUAL
18501: IFTRUE 18505
18503: GO 18531
18505: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18506: LD_ADDR_VAR 0 3
18510: PUSH
18511: LD_INT 2
18513: PUSH
18514: LD_INT 3
18516: PUSH
18517: LD_INT 4
18519: PUSH
18520: LD_INT 5
18522: PUSH
18523: EMPTY
18524: LIST
18525: LIST
18526: LIST
18527: LIST
18528: ST_TO_ADDR
18529: GO 19388
18531: LD_INT 9
18533: DOUBLE
18534: EQUAL
18535: IFTRUE 18539
18537: GO 18565
18539: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18540: LD_ADDR_VAR 0 3
18544: PUSH
18545: LD_INT 2
18547: PUSH
18548: LD_INT 3
18550: PUSH
18551: LD_INT 4
18553: PUSH
18554: LD_INT 5
18556: PUSH
18557: EMPTY
18558: LIST
18559: LIST
18560: LIST
18561: LIST
18562: ST_TO_ADDR
18563: GO 19388
18565: LD_INT 7
18567: DOUBLE
18568: EQUAL
18569: IFTRUE 18573
18571: GO 18599
18573: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18574: LD_ADDR_VAR 0 3
18578: PUSH
18579: LD_INT 2
18581: PUSH
18582: LD_INT 3
18584: PUSH
18585: LD_INT 4
18587: PUSH
18588: LD_INT 5
18590: PUSH
18591: EMPTY
18592: LIST
18593: LIST
18594: LIST
18595: LIST
18596: ST_TO_ADDR
18597: GO 19388
18599: LD_INT 12
18601: DOUBLE
18602: EQUAL
18603: IFTRUE 18607
18605: GO 18633
18607: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18608: LD_ADDR_VAR 0 3
18612: PUSH
18613: LD_INT 2
18615: PUSH
18616: LD_INT 3
18618: PUSH
18619: LD_INT 4
18621: PUSH
18622: LD_INT 5
18624: PUSH
18625: EMPTY
18626: LIST
18627: LIST
18628: LIST
18629: LIST
18630: ST_TO_ADDR
18631: GO 19388
18633: LD_INT 13
18635: DOUBLE
18636: EQUAL
18637: IFTRUE 18641
18639: GO 18667
18641: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18642: LD_ADDR_VAR 0 3
18646: PUSH
18647: LD_INT 2
18649: PUSH
18650: LD_INT 3
18652: PUSH
18653: LD_INT 4
18655: PUSH
18656: LD_INT 5
18658: PUSH
18659: EMPTY
18660: LIST
18661: LIST
18662: LIST
18663: LIST
18664: ST_TO_ADDR
18665: GO 19388
18667: LD_INT 14
18669: DOUBLE
18670: EQUAL
18671: IFTRUE 18675
18673: GO 18693
18675: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18676: LD_ADDR_VAR 0 3
18680: PUSH
18681: LD_INT 4
18683: PUSH
18684: LD_INT 5
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: ST_TO_ADDR
18691: GO 19388
18693: LD_INT 6
18695: DOUBLE
18696: EQUAL
18697: IFTRUE 18701
18699: GO 18719
18701: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18702: LD_ADDR_VAR 0 3
18706: PUSH
18707: LD_INT 4
18709: PUSH
18710: LD_INT 5
18712: PUSH
18713: EMPTY
18714: LIST
18715: LIST
18716: ST_TO_ADDR
18717: GO 19388
18719: LD_INT 10
18721: DOUBLE
18722: EQUAL
18723: IFTRUE 18727
18725: GO 18745
18727: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18728: LD_ADDR_VAR 0 3
18732: PUSH
18733: LD_INT 4
18735: PUSH
18736: LD_INT 5
18738: PUSH
18739: EMPTY
18740: LIST
18741: LIST
18742: ST_TO_ADDR
18743: GO 19388
18745: LD_INT 22
18747: DOUBLE
18748: EQUAL
18749: IFTRUE 18753
18751: GO 18779
18753: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18754: LD_ADDR_VAR 0 3
18758: PUSH
18759: LD_INT 11
18761: PUSH
18762: LD_INT 12
18764: PUSH
18765: LD_INT 13
18767: PUSH
18768: LD_INT 14
18770: PUSH
18771: EMPTY
18772: LIST
18773: LIST
18774: LIST
18775: LIST
18776: ST_TO_ADDR
18777: GO 19388
18779: LD_INT 23
18781: DOUBLE
18782: EQUAL
18783: IFTRUE 18787
18785: GO 18813
18787: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18788: LD_ADDR_VAR 0 3
18792: PUSH
18793: LD_INT 11
18795: PUSH
18796: LD_INT 12
18798: PUSH
18799: LD_INT 13
18801: PUSH
18802: LD_INT 14
18804: PUSH
18805: EMPTY
18806: LIST
18807: LIST
18808: LIST
18809: LIST
18810: ST_TO_ADDR
18811: GO 19388
18813: LD_INT 24
18815: DOUBLE
18816: EQUAL
18817: IFTRUE 18821
18819: GO 18847
18821: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18822: LD_ADDR_VAR 0 3
18826: PUSH
18827: LD_INT 11
18829: PUSH
18830: LD_INT 12
18832: PUSH
18833: LD_INT 13
18835: PUSH
18836: LD_INT 14
18838: PUSH
18839: EMPTY
18840: LIST
18841: LIST
18842: LIST
18843: LIST
18844: ST_TO_ADDR
18845: GO 19388
18847: LD_INT 30
18849: DOUBLE
18850: EQUAL
18851: IFTRUE 18855
18853: GO 18881
18855: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18856: LD_ADDR_VAR 0 3
18860: PUSH
18861: LD_INT 11
18863: PUSH
18864: LD_INT 12
18866: PUSH
18867: LD_INT 13
18869: PUSH
18870: LD_INT 14
18872: PUSH
18873: EMPTY
18874: LIST
18875: LIST
18876: LIST
18877: LIST
18878: ST_TO_ADDR
18879: GO 19388
18881: LD_INT 25
18883: DOUBLE
18884: EQUAL
18885: IFTRUE 18889
18887: GO 18907
18889: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18890: LD_ADDR_VAR 0 3
18894: PUSH
18895: LD_INT 13
18897: PUSH
18898: LD_INT 14
18900: PUSH
18901: EMPTY
18902: LIST
18903: LIST
18904: ST_TO_ADDR
18905: GO 19388
18907: LD_INT 27
18909: DOUBLE
18910: EQUAL
18911: IFTRUE 18915
18913: GO 18933
18915: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
18916: LD_ADDR_VAR 0 3
18920: PUSH
18921: LD_INT 13
18923: PUSH
18924: LD_INT 14
18926: PUSH
18927: EMPTY
18928: LIST
18929: LIST
18930: ST_TO_ADDR
18931: GO 19388
18933: LD_INT 92
18935: DOUBLE
18936: EQUAL
18937: IFTRUE 18941
18939: GO 18967
18941: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18942: LD_ADDR_VAR 0 3
18946: PUSH
18947: LD_INT 11
18949: PUSH
18950: LD_INT 12
18952: PUSH
18953: LD_INT 13
18955: PUSH
18956: LD_INT 14
18958: PUSH
18959: EMPTY
18960: LIST
18961: LIST
18962: LIST
18963: LIST
18964: ST_TO_ADDR
18965: GO 19388
18967: LD_INT 28
18969: DOUBLE
18970: EQUAL
18971: IFTRUE 18975
18973: GO 18993
18975: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18976: LD_ADDR_VAR 0 3
18980: PUSH
18981: LD_INT 13
18983: PUSH
18984: LD_INT 14
18986: PUSH
18987: EMPTY
18988: LIST
18989: LIST
18990: ST_TO_ADDR
18991: GO 19388
18993: LD_INT 29
18995: DOUBLE
18996: EQUAL
18997: IFTRUE 19001
18999: GO 19019
19001: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19002: LD_ADDR_VAR 0 3
19006: PUSH
19007: LD_INT 13
19009: PUSH
19010: LD_INT 14
19012: PUSH
19013: EMPTY
19014: LIST
19015: LIST
19016: ST_TO_ADDR
19017: GO 19388
19019: LD_INT 31
19021: DOUBLE
19022: EQUAL
19023: IFTRUE 19027
19025: GO 19045
19027: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19028: LD_ADDR_VAR 0 3
19032: PUSH
19033: LD_INT 13
19035: PUSH
19036: LD_INT 14
19038: PUSH
19039: EMPTY
19040: LIST
19041: LIST
19042: ST_TO_ADDR
19043: GO 19388
19045: LD_INT 26
19047: DOUBLE
19048: EQUAL
19049: IFTRUE 19053
19051: GO 19071
19053: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19054: LD_ADDR_VAR 0 3
19058: PUSH
19059: LD_INT 13
19061: PUSH
19062: LD_INT 14
19064: PUSH
19065: EMPTY
19066: LIST
19067: LIST
19068: ST_TO_ADDR
19069: GO 19388
19071: LD_INT 42
19073: DOUBLE
19074: EQUAL
19075: IFTRUE 19079
19077: GO 19105
19079: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19080: LD_ADDR_VAR 0 3
19084: PUSH
19085: LD_INT 21
19087: PUSH
19088: LD_INT 22
19090: PUSH
19091: LD_INT 23
19093: PUSH
19094: LD_INT 24
19096: PUSH
19097: EMPTY
19098: LIST
19099: LIST
19100: LIST
19101: LIST
19102: ST_TO_ADDR
19103: GO 19388
19105: LD_INT 43
19107: DOUBLE
19108: EQUAL
19109: IFTRUE 19113
19111: GO 19139
19113: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19114: LD_ADDR_VAR 0 3
19118: PUSH
19119: LD_INT 21
19121: PUSH
19122: LD_INT 22
19124: PUSH
19125: LD_INT 23
19127: PUSH
19128: LD_INT 24
19130: PUSH
19131: EMPTY
19132: LIST
19133: LIST
19134: LIST
19135: LIST
19136: ST_TO_ADDR
19137: GO 19388
19139: LD_INT 44
19141: DOUBLE
19142: EQUAL
19143: IFTRUE 19147
19145: GO 19173
19147: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19148: LD_ADDR_VAR 0 3
19152: PUSH
19153: LD_INT 21
19155: PUSH
19156: LD_INT 22
19158: PUSH
19159: LD_INT 23
19161: PUSH
19162: LD_INT 24
19164: PUSH
19165: EMPTY
19166: LIST
19167: LIST
19168: LIST
19169: LIST
19170: ST_TO_ADDR
19171: GO 19388
19173: LD_INT 45
19175: DOUBLE
19176: EQUAL
19177: IFTRUE 19181
19179: GO 19207
19181: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19182: LD_ADDR_VAR 0 3
19186: PUSH
19187: LD_INT 21
19189: PUSH
19190: LD_INT 22
19192: PUSH
19193: LD_INT 23
19195: PUSH
19196: LD_INT 24
19198: PUSH
19199: EMPTY
19200: LIST
19201: LIST
19202: LIST
19203: LIST
19204: ST_TO_ADDR
19205: GO 19388
19207: LD_INT 49
19209: DOUBLE
19210: EQUAL
19211: IFTRUE 19215
19213: GO 19241
19215: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19216: LD_ADDR_VAR 0 3
19220: PUSH
19221: LD_INT 21
19223: PUSH
19224: LD_INT 22
19226: PUSH
19227: LD_INT 23
19229: PUSH
19230: LD_INT 24
19232: PUSH
19233: EMPTY
19234: LIST
19235: LIST
19236: LIST
19237: LIST
19238: ST_TO_ADDR
19239: GO 19388
19241: LD_INT 51
19243: DOUBLE
19244: EQUAL
19245: IFTRUE 19249
19247: GO 19275
19249: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19250: LD_ADDR_VAR 0 3
19254: PUSH
19255: LD_INT 21
19257: PUSH
19258: LD_INT 22
19260: PUSH
19261: LD_INT 23
19263: PUSH
19264: LD_INT 24
19266: PUSH
19267: EMPTY
19268: LIST
19269: LIST
19270: LIST
19271: LIST
19272: ST_TO_ADDR
19273: GO 19388
19275: LD_INT 52
19277: DOUBLE
19278: EQUAL
19279: IFTRUE 19283
19281: GO 19309
19283: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19284: LD_ADDR_VAR 0 3
19288: PUSH
19289: LD_INT 21
19291: PUSH
19292: LD_INT 22
19294: PUSH
19295: LD_INT 23
19297: PUSH
19298: LD_INT 24
19300: PUSH
19301: EMPTY
19302: LIST
19303: LIST
19304: LIST
19305: LIST
19306: ST_TO_ADDR
19307: GO 19388
19309: LD_INT 53
19311: DOUBLE
19312: EQUAL
19313: IFTRUE 19317
19315: GO 19335
19317: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19318: LD_ADDR_VAR 0 3
19322: PUSH
19323: LD_INT 23
19325: PUSH
19326: LD_INT 24
19328: PUSH
19329: EMPTY
19330: LIST
19331: LIST
19332: ST_TO_ADDR
19333: GO 19388
19335: LD_INT 46
19337: DOUBLE
19338: EQUAL
19339: IFTRUE 19343
19341: GO 19361
19343: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19344: LD_ADDR_VAR 0 3
19348: PUSH
19349: LD_INT 23
19351: PUSH
19352: LD_INT 24
19354: PUSH
19355: EMPTY
19356: LIST
19357: LIST
19358: ST_TO_ADDR
19359: GO 19388
19361: LD_INT 47
19363: DOUBLE
19364: EQUAL
19365: IFTRUE 19369
19367: GO 19387
19369: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19370: LD_ADDR_VAR 0 3
19374: PUSH
19375: LD_INT 23
19377: PUSH
19378: LD_INT 24
19380: PUSH
19381: EMPTY
19382: LIST
19383: LIST
19384: ST_TO_ADDR
19385: GO 19388
19387: POP
// result := ( chassis in result ) ;
19388: LD_ADDR_VAR 0 3
19392: PUSH
19393: LD_VAR 0 1
19397: PUSH
19398: LD_VAR 0 3
19402: IN
19403: ST_TO_ADDR
// end ;
19404: LD_VAR 0 3
19408: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19409: LD_INT 0
19411: PPUSH
19412: PPUSH
19413: PPUSH
19414: PPUSH
19415: PPUSH
19416: PPUSH
19417: PPUSH
// result := array ;
19418: LD_ADDR_VAR 0 5
19422: PUSH
19423: LD_VAR 0 1
19427: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19428: LD_VAR 0 1
19432: NOT
19433: PUSH
19434: LD_VAR 0 2
19438: NOT
19439: OR
19440: PUSH
19441: LD_VAR 0 3
19445: NOT
19446: OR
19447: PUSH
19448: LD_VAR 0 2
19452: PUSH
19453: LD_VAR 0 1
19457: GREATER
19458: OR
19459: PUSH
19460: LD_VAR 0 3
19464: PUSH
19465: LD_VAR 0 1
19469: GREATER
19470: OR
19471: IFFALSE 19475
// exit ;
19473: GO 19771
// if direction then
19475: LD_VAR 0 4
19479: IFFALSE 19543
// begin d := 1 ;
19481: LD_ADDR_VAR 0 9
19485: PUSH
19486: LD_INT 1
19488: ST_TO_ADDR
// if i_from > i_to then
19489: LD_VAR 0 2
19493: PUSH
19494: LD_VAR 0 3
19498: GREATER
19499: IFFALSE 19525
// length := ( array - i_from ) + i_to else
19501: LD_ADDR_VAR 0 11
19505: PUSH
19506: LD_VAR 0 1
19510: PUSH
19511: LD_VAR 0 2
19515: MINUS
19516: PUSH
19517: LD_VAR 0 3
19521: PLUS
19522: ST_TO_ADDR
19523: GO 19541
// length := i_to - i_from ;
19525: LD_ADDR_VAR 0 11
19529: PUSH
19530: LD_VAR 0 3
19534: PUSH
19535: LD_VAR 0 2
19539: MINUS
19540: ST_TO_ADDR
// end else
19541: GO 19604
// begin d := - 1 ;
19543: LD_ADDR_VAR 0 9
19547: PUSH
19548: LD_INT 1
19550: NEG
19551: ST_TO_ADDR
// if i_from > i_to then
19552: LD_VAR 0 2
19556: PUSH
19557: LD_VAR 0 3
19561: GREATER
19562: IFFALSE 19582
// length := i_from - i_to else
19564: LD_ADDR_VAR 0 11
19568: PUSH
19569: LD_VAR 0 2
19573: PUSH
19574: LD_VAR 0 3
19578: MINUS
19579: ST_TO_ADDR
19580: GO 19604
// length := ( array - i_to ) + i_from ;
19582: LD_ADDR_VAR 0 11
19586: PUSH
19587: LD_VAR 0 1
19591: PUSH
19592: LD_VAR 0 3
19596: MINUS
19597: PUSH
19598: LD_VAR 0 2
19602: PLUS
19603: ST_TO_ADDR
// end ; if not length then
19604: LD_VAR 0 11
19608: NOT
19609: IFFALSE 19613
// exit ;
19611: GO 19771
// tmp := array ;
19613: LD_ADDR_VAR 0 10
19617: PUSH
19618: LD_VAR 0 1
19622: ST_TO_ADDR
// for i = 1 to length do
19623: LD_ADDR_VAR 0 6
19627: PUSH
19628: DOUBLE
19629: LD_INT 1
19631: DEC
19632: ST_TO_ADDR
19633: LD_VAR 0 11
19637: PUSH
19638: FOR_TO
19639: IFFALSE 19759
// begin for j = 1 to array do
19641: LD_ADDR_VAR 0 7
19645: PUSH
19646: DOUBLE
19647: LD_INT 1
19649: DEC
19650: ST_TO_ADDR
19651: LD_VAR 0 1
19655: PUSH
19656: FOR_TO
19657: IFFALSE 19745
// begin k := j + d ;
19659: LD_ADDR_VAR 0 8
19663: PUSH
19664: LD_VAR 0 7
19668: PUSH
19669: LD_VAR 0 9
19673: PLUS
19674: ST_TO_ADDR
// if k > array then
19675: LD_VAR 0 8
19679: PUSH
19680: LD_VAR 0 1
19684: GREATER
19685: IFFALSE 19695
// k := 1 ;
19687: LD_ADDR_VAR 0 8
19691: PUSH
19692: LD_INT 1
19694: ST_TO_ADDR
// if not k then
19695: LD_VAR 0 8
19699: NOT
19700: IFFALSE 19712
// k := array ;
19702: LD_ADDR_VAR 0 8
19706: PUSH
19707: LD_VAR 0 1
19711: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19712: LD_ADDR_VAR 0 10
19716: PUSH
19717: LD_VAR 0 10
19721: PPUSH
19722: LD_VAR 0 8
19726: PPUSH
19727: LD_VAR 0 1
19731: PUSH
19732: LD_VAR 0 7
19736: ARRAY
19737: PPUSH
19738: CALL_OW 1
19742: ST_TO_ADDR
// end ;
19743: GO 19656
19745: POP
19746: POP
// array := tmp ;
19747: LD_ADDR_VAR 0 1
19751: PUSH
19752: LD_VAR 0 10
19756: ST_TO_ADDR
// end ;
19757: GO 19638
19759: POP
19760: POP
// result := array ;
19761: LD_ADDR_VAR 0 5
19765: PUSH
19766: LD_VAR 0 1
19770: ST_TO_ADDR
// end ;
19771: LD_VAR 0 5
19775: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19776: LD_INT 0
19778: PPUSH
19779: PPUSH
// result := 0 ;
19780: LD_ADDR_VAR 0 3
19784: PUSH
19785: LD_INT 0
19787: ST_TO_ADDR
// if not array or not value in array then
19788: LD_VAR 0 1
19792: NOT
19793: PUSH
19794: LD_VAR 0 2
19798: PUSH
19799: LD_VAR 0 1
19803: IN
19804: NOT
19805: OR
19806: IFFALSE 19810
// exit ;
19808: GO 19864
// for i = 1 to array do
19810: LD_ADDR_VAR 0 4
19814: PUSH
19815: DOUBLE
19816: LD_INT 1
19818: DEC
19819: ST_TO_ADDR
19820: LD_VAR 0 1
19824: PUSH
19825: FOR_TO
19826: IFFALSE 19862
// if value = array [ i ] then
19828: LD_VAR 0 2
19832: PUSH
19833: LD_VAR 0 1
19837: PUSH
19838: LD_VAR 0 4
19842: ARRAY
19843: EQUAL
19844: IFFALSE 19860
// begin result := i ;
19846: LD_ADDR_VAR 0 3
19850: PUSH
19851: LD_VAR 0 4
19855: ST_TO_ADDR
// exit ;
19856: POP
19857: POP
19858: GO 19864
// end ;
19860: GO 19825
19862: POP
19863: POP
// end ;
19864: LD_VAR 0 3
19868: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19869: LD_INT 0
19871: PPUSH
// vc_chassis := chassis ;
19872: LD_ADDR_OWVAR 37
19876: PUSH
19877: LD_VAR 0 1
19881: ST_TO_ADDR
// vc_engine := engine ;
19882: LD_ADDR_OWVAR 39
19886: PUSH
19887: LD_VAR 0 2
19891: ST_TO_ADDR
// vc_control := control ;
19892: LD_ADDR_OWVAR 38
19896: PUSH
19897: LD_VAR 0 3
19901: ST_TO_ADDR
// vc_weapon := weapon ;
19902: LD_ADDR_OWVAR 40
19906: PUSH
19907: LD_VAR 0 4
19911: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19912: LD_ADDR_OWVAR 41
19916: PUSH
19917: LD_VAR 0 5
19921: ST_TO_ADDR
// end ;
19922: LD_VAR 0 6
19926: RET
// export function WantPlant ( unit ) ; var task ; begin
19927: LD_INT 0
19929: PPUSH
19930: PPUSH
// result := false ;
19931: LD_ADDR_VAR 0 2
19935: PUSH
19936: LD_INT 0
19938: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19939: LD_ADDR_VAR 0 3
19943: PUSH
19944: LD_VAR 0 1
19948: PPUSH
19949: CALL_OW 437
19953: ST_TO_ADDR
// if task then
19954: LD_VAR 0 3
19958: IFFALSE 19986
// if task [ 1 ] [ 1 ] = p then
19960: LD_VAR 0 3
19964: PUSH
19965: LD_INT 1
19967: ARRAY
19968: PUSH
19969: LD_INT 1
19971: ARRAY
19972: PUSH
19973: LD_STRING p
19975: EQUAL
19976: IFFALSE 19986
// result := true ;
19978: LD_ADDR_VAR 0 2
19982: PUSH
19983: LD_INT 1
19985: ST_TO_ADDR
// end ;
19986: LD_VAR 0 2
19990: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19991: LD_INT 0
19993: PPUSH
19994: PPUSH
19995: PPUSH
19996: PPUSH
// if pos < 1 then
19997: LD_VAR 0 2
20001: PUSH
20002: LD_INT 1
20004: LESS
20005: IFFALSE 20009
// exit ;
20007: GO 20312
// if pos = 1 then
20009: LD_VAR 0 2
20013: PUSH
20014: LD_INT 1
20016: EQUAL
20017: IFFALSE 20050
// result := Replace ( arr , pos [ 1 ] , value ) else
20019: LD_ADDR_VAR 0 4
20023: PUSH
20024: LD_VAR 0 1
20028: PPUSH
20029: LD_VAR 0 2
20033: PUSH
20034: LD_INT 1
20036: ARRAY
20037: PPUSH
20038: LD_VAR 0 3
20042: PPUSH
20043: CALL_OW 1
20047: ST_TO_ADDR
20048: GO 20312
// begin tmp := arr ;
20050: LD_ADDR_VAR 0 6
20054: PUSH
20055: LD_VAR 0 1
20059: ST_TO_ADDR
// s_arr := [ tmp ] ;
20060: LD_ADDR_VAR 0 7
20064: PUSH
20065: LD_VAR 0 6
20069: PUSH
20070: EMPTY
20071: LIST
20072: ST_TO_ADDR
// for i = 1 to pos - 1 do
20073: LD_ADDR_VAR 0 5
20077: PUSH
20078: DOUBLE
20079: LD_INT 1
20081: DEC
20082: ST_TO_ADDR
20083: LD_VAR 0 2
20087: PUSH
20088: LD_INT 1
20090: MINUS
20091: PUSH
20092: FOR_TO
20093: IFFALSE 20138
// begin tmp := tmp [ pos [ i ] ] ;
20095: LD_ADDR_VAR 0 6
20099: PUSH
20100: LD_VAR 0 6
20104: PUSH
20105: LD_VAR 0 2
20109: PUSH
20110: LD_VAR 0 5
20114: ARRAY
20115: ARRAY
20116: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20117: LD_ADDR_VAR 0 7
20121: PUSH
20122: LD_VAR 0 7
20126: PUSH
20127: LD_VAR 0 6
20131: PUSH
20132: EMPTY
20133: LIST
20134: ADD
20135: ST_TO_ADDR
// end ;
20136: GO 20092
20138: POP
20139: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20140: LD_ADDR_VAR 0 6
20144: PUSH
20145: LD_VAR 0 6
20149: PPUSH
20150: LD_VAR 0 2
20154: PUSH
20155: LD_VAR 0 2
20159: ARRAY
20160: PPUSH
20161: LD_VAR 0 3
20165: PPUSH
20166: CALL_OW 1
20170: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20171: LD_ADDR_VAR 0 7
20175: PUSH
20176: LD_VAR 0 7
20180: PPUSH
20181: LD_VAR 0 7
20185: PPUSH
20186: LD_VAR 0 6
20190: PPUSH
20191: CALL_OW 1
20195: ST_TO_ADDR
// for i = s_arr downto 2 do
20196: LD_ADDR_VAR 0 5
20200: PUSH
20201: DOUBLE
20202: LD_VAR 0 7
20206: INC
20207: ST_TO_ADDR
20208: LD_INT 2
20210: PUSH
20211: FOR_DOWNTO
20212: IFFALSE 20296
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20214: LD_ADDR_VAR 0 6
20218: PUSH
20219: LD_VAR 0 7
20223: PUSH
20224: LD_VAR 0 5
20228: PUSH
20229: LD_INT 1
20231: MINUS
20232: ARRAY
20233: PPUSH
20234: LD_VAR 0 2
20238: PUSH
20239: LD_VAR 0 5
20243: PUSH
20244: LD_INT 1
20246: MINUS
20247: ARRAY
20248: PPUSH
20249: LD_VAR 0 7
20253: PUSH
20254: LD_VAR 0 5
20258: ARRAY
20259: PPUSH
20260: CALL_OW 1
20264: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20265: LD_ADDR_VAR 0 7
20269: PUSH
20270: LD_VAR 0 7
20274: PPUSH
20275: LD_VAR 0 5
20279: PUSH
20280: LD_INT 1
20282: MINUS
20283: PPUSH
20284: LD_VAR 0 6
20288: PPUSH
20289: CALL_OW 1
20293: ST_TO_ADDR
// end ;
20294: GO 20211
20296: POP
20297: POP
// result := s_arr [ 1 ] ;
20298: LD_ADDR_VAR 0 4
20302: PUSH
20303: LD_VAR 0 7
20307: PUSH
20308: LD_INT 1
20310: ARRAY
20311: ST_TO_ADDR
// end ; end ;
20312: LD_VAR 0 4
20316: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20317: LD_INT 0
20319: PPUSH
20320: PPUSH
// if not list then
20321: LD_VAR 0 1
20325: NOT
20326: IFFALSE 20330
// exit ;
20328: GO 20421
// i := list [ pos1 ] ;
20330: LD_ADDR_VAR 0 5
20334: PUSH
20335: LD_VAR 0 1
20339: PUSH
20340: LD_VAR 0 2
20344: ARRAY
20345: ST_TO_ADDR
// if not i then
20346: LD_VAR 0 5
20350: NOT
20351: IFFALSE 20355
// exit ;
20353: GO 20421
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20355: LD_ADDR_VAR 0 1
20359: PUSH
20360: LD_VAR 0 1
20364: PPUSH
20365: LD_VAR 0 2
20369: PPUSH
20370: LD_VAR 0 1
20374: PUSH
20375: LD_VAR 0 3
20379: ARRAY
20380: PPUSH
20381: CALL_OW 1
20385: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20386: LD_ADDR_VAR 0 1
20390: PUSH
20391: LD_VAR 0 1
20395: PPUSH
20396: LD_VAR 0 3
20400: PPUSH
20401: LD_VAR 0 5
20405: PPUSH
20406: CALL_OW 1
20410: ST_TO_ADDR
// result := list ;
20411: LD_ADDR_VAR 0 4
20415: PUSH
20416: LD_VAR 0 1
20420: ST_TO_ADDR
// end ;
20421: LD_VAR 0 4
20425: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20426: LD_INT 0
20428: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20429: LD_ADDR_VAR 0 5
20433: PUSH
20434: LD_VAR 0 1
20438: PPUSH
20439: CALL_OW 250
20443: PPUSH
20444: LD_VAR 0 1
20448: PPUSH
20449: CALL_OW 251
20453: PPUSH
20454: LD_VAR 0 2
20458: PPUSH
20459: LD_VAR 0 3
20463: PPUSH
20464: LD_VAR 0 4
20468: PPUSH
20469: CALL 20479 0 5
20473: ST_TO_ADDR
// end ;
20474: LD_VAR 0 5
20478: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20479: LD_INT 0
20481: PPUSH
20482: PPUSH
20483: PPUSH
20484: PPUSH
// if not list then
20485: LD_VAR 0 3
20489: NOT
20490: IFFALSE 20494
// exit ;
20492: GO 20882
// result := [ ] ;
20494: LD_ADDR_VAR 0 6
20498: PUSH
20499: EMPTY
20500: ST_TO_ADDR
// for i in list do
20501: LD_ADDR_VAR 0 7
20505: PUSH
20506: LD_VAR 0 3
20510: PUSH
20511: FOR_IN
20512: IFFALSE 20714
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20514: LD_ADDR_VAR 0 9
20518: PUSH
20519: LD_VAR 0 7
20523: PPUSH
20524: LD_VAR 0 1
20528: PPUSH
20529: LD_VAR 0 2
20533: PPUSH
20534: CALL_OW 297
20538: ST_TO_ADDR
// if not result then
20539: LD_VAR 0 6
20543: NOT
20544: IFFALSE 20570
// result := [ [ i , tmp ] ] else
20546: LD_ADDR_VAR 0 6
20550: PUSH
20551: LD_VAR 0 7
20555: PUSH
20556: LD_VAR 0 9
20560: PUSH
20561: EMPTY
20562: LIST
20563: LIST
20564: PUSH
20565: EMPTY
20566: LIST
20567: ST_TO_ADDR
20568: GO 20712
// begin if result [ result ] [ 2 ] < tmp then
20570: LD_VAR 0 6
20574: PUSH
20575: LD_VAR 0 6
20579: ARRAY
20580: PUSH
20581: LD_INT 2
20583: ARRAY
20584: PUSH
20585: LD_VAR 0 9
20589: LESS
20590: IFFALSE 20632
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20592: LD_ADDR_VAR 0 6
20596: PUSH
20597: LD_VAR 0 6
20601: PPUSH
20602: LD_VAR 0 6
20606: PUSH
20607: LD_INT 1
20609: PLUS
20610: PPUSH
20611: LD_VAR 0 7
20615: PUSH
20616: LD_VAR 0 9
20620: PUSH
20621: EMPTY
20622: LIST
20623: LIST
20624: PPUSH
20625: CALL_OW 2
20629: ST_TO_ADDR
20630: GO 20712
// for j = 1 to result do
20632: LD_ADDR_VAR 0 8
20636: PUSH
20637: DOUBLE
20638: LD_INT 1
20640: DEC
20641: ST_TO_ADDR
20642: LD_VAR 0 6
20646: PUSH
20647: FOR_TO
20648: IFFALSE 20710
// begin if tmp < result [ j ] [ 2 ] then
20650: LD_VAR 0 9
20654: PUSH
20655: LD_VAR 0 6
20659: PUSH
20660: LD_VAR 0 8
20664: ARRAY
20665: PUSH
20666: LD_INT 2
20668: ARRAY
20669: LESS
20670: IFFALSE 20708
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20672: LD_ADDR_VAR 0 6
20676: PUSH
20677: LD_VAR 0 6
20681: PPUSH
20682: LD_VAR 0 8
20686: PPUSH
20687: LD_VAR 0 7
20691: PUSH
20692: LD_VAR 0 9
20696: PUSH
20697: EMPTY
20698: LIST
20699: LIST
20700: PPUSH
20701: CALL_OW 2
20705: ST_TO_ADDR
// break ;
20706: GO 20710
// end ; end ;
20708: GO 20647
20710: POP
20711: POP
// end ; end ;
20712: GO 20511
20714: POP
20715: POP
// if result and not asc then
20716: LD_VAR 0 6
20720: PUSH
20721: LD_VAR 0 4
20725: NOT
20726: AND
20727: IFFALSE 20802
// begin tmp := result ;
20729: LD_ADDR_VAR 0 9
20733: PUSH
20734: LD_VAR 0 6
20738: ST_TO_ADDR
// for i = tmp downto 1 do
20739: LD_ADDR_VAR 0 7
20743: PUSH
20744: DOUBLE
20745: LD_VAR 0 9
20749: INC
20750: ST_TO_ADDR
20751: LD_INT 1
20753: PUSH
20754: FOR_DOWNTO
20755: IFFALSE 20800
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20757: LD_ADDR_VAR 0 6
20761: PUSH
20762: LD_VAR 0 6
20766: PPUSH
20767: LD_VAR 0 9
20771: PUSH
20772: LD_VAR 0 7
20776: MINUS
20777: PUSH
20778: LD_INT 1
20780: PLUS
20781: PPUSH
20782: LD_VAR 0 9
20786: PUSH
20787: LD_VAR 0 7
20791: ARRAY
20792: PPUSH
20793: CALL_OW 1
20797: ST_TO_ADDR
20798: GO 20754
20800: POP
20801: POP
// end ; tmp := [ ] ;
20802: LD_ADDR_VAR 0 9
20806: PUSH
20807: EMPTY
20808: ST_TO_ADDR
// if mode then
20809: LD_VAR 0 5
20813: IFFALSE 20882
// begin for i = 1 to result do
20815: LD_ADDR_VAR 0 7
20819: PUSH
20820: DOUBLE
20821: LD_INT 1
20823: DEC
20824: ST_TO_ADDR
20825: LD_VAR 0 6
20829: PUSH
20830: FOR_TO
20831: IFFALSE 20870
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20833: LD_ADDR_VAR 0 9
20837: PUSH
20838: LD_VAR 0 9
20842: PPUSH
20843: LD_VAR 0 7
20847: PPUSH
20848: LD_VAR 0 6
20852: PUSH
20853: LD_VAR 0 7
20857: ARRAY
20858: PUSH
20859: LD_INT 1
20861: ARRAY
20862: PPUSH
20863: CALL_OW 1
20867: ST_TO_ADDR
20868: GO 20830
20870: POP
20871: POP
// result := tmp ;
20872: LD_ADDR_VAR 0 6
20876: PUSH
20877: LD_VAR 0 9
20881: ST_TO_ADDR
// end ; end ;
20882: LD_VAR 0 6
20886: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20887: LD_INT 0
20889: PPUSH
20890: PPUSH
20891: PPUSH
20892: PPUSH
20893: PPUSH
20894: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20895: LD_ADDR_VAR 0 5
20899: PUSH
20900: LD_INT 0
20902: PUSH
20903: LD_INT 0
20905: PUSH
20906: LD_INT 0
20908: PUSH
20909: EMPTY
20910: PUSH
20911: EMPTY
20912: LIST
20913: LIST
20914: LIST
20915: LIST
20916: ST_TO_ADDR
// if not x or not y then
20917: LD_VAR 0 2
20921: NOT
20922: PUSH
20923: LD_VAR 0 3
20927: NOT
20928: OR
20929: IFFALSE 20933
// exit ;
20931: GO 22583
// if not range then
20933: LD_VAR 0 4
20937: NOT
20938: IFFALSE 20948
// range := 10 ;
20940: LD_ADDR_VAR 0 4
20944: PUSH
20945: LD_INT 10
20947: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20948: LD_ADDR_VAR 0 8
20952: PUSH
20953: LD_INT 81
20955: PUSH
20956: LD_VAR 0 1
20960: PUSH
20961: EMPTY
20962: LIST
20963: LIST
20964: PUSH
20965: LD_INT 92
20967: PUSH
20968: LD_VAR 0 2
20972: PUSH
20973: LD_VAR 0 3
20977: PUSH
20978: LD_VAR 0 4
20982: PUSH
20983: EMPTY
20984: LIST
20985: LIST
20986: LIST
20987: LIST
20988: PUSH
20989: LD_INT 3
20991: PUSH
20992: LD_INT 21
20994: PUSH
20995: LD_INT 3
20997: PUSH
20998: EMPTY
20999: LIST
21000: LIST
21001: PUSH
21002: EMPTY
21003: LIST
21004: LIST
21005: PUSH
21006: EMPTY
21007: LIST
21008: LIST
21009: LIST
21010: PPUSH
21011: CALL_OW 69
21015: ST_TO_ADDR
// if not tmp then
21016: LD_VAR 0 8
21020: NOT
21021: IFFALSE 21025
// exit ;
21023: GO 22583
// for i in tmp do
21025: LD_ADDR_VAR 0 6
21029: PUSH
21030: LD_VAR 0 8
21034: PUSH
21035: FOR_IN
21036: IFFALSE 22558
// begin points := [ 0 , 0 , 0 ] ;
21038: LD_ADDR_VAR 0 9
21042: PUSH
21043: LD_INT 0
21045: PUSH
21046: LD_INT 0
21048: PUSH
21049: LD_INT 0
21051: PUSH
21052: EMPTY
21053: LIST
21054: LIST
21055: LIST
21056: ST_TO_ADDR
// bpoints := 1 ;
21057: LD_ADDR_VAR 0 10
21061: PUSH
21062: LD_INT 1
21064: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21065: LD_VAR 0 6
21069: PPUSH
21070: CALL_OW 247
21074: PUSH
21075: LD_INT 1
21077: DOUBLE
21078: EQUAL
21079: IFTRUE 21083
21081: GO 21661
21083: POP
// begin if GetClass ( i ) = 1 then
21084: LD_VAR 0 6
21088: PPUSH
21089: CALL_OW 257
21093: PUSH
21094: LD_INT 1
21096: EQUAL
21097: IFFALSE 21118
// points := [ 10 , 5 , 3 ] ;
21099: LD_ADDR_VAR 0 9
21103: PUSH
21104: LD_INT 10
21106: PUSH
21107: LD_INT 5
21109: PUSH
21110: LD_INT 3
21112: PUSH
21113: EMPTY
21114: LIST
21115: LIST
21116: LIST
21117: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21118: LD_VAR 0 6
21122: PPUSH
21123: CALL_OW 257
21127: PUSH
21128: LD_INT 2
21130: PUSH
21131: LD_INT 3
21133: PUSH
21134: LD_INT 4
21136: PUSH
21137: EMPTY
21138: LIST
21139: LIST
21140: LIST
21141: IN
21142: IFFALSE 21163
// points := [ 3 , 2 , 1 ] ;
21144: LD_ADDR_VAR 0 9
21148: PUSH
21149: LD_INT 3
21151: PUSH
21152: LD_INT 2
21154: PUSH
21155: LD_INT 1
21157: PUSH
21158: EMPTY
21159: LIST
21160: LIST
21161: LIST
21162: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21163: LD_VAR 0 6
21167: PPUSH
21168: CALL_OW 257
21172: PUSH
21173: LD_INT 5
21175: EQUAL
21176: IFFALSE 21197
// points := [ 130 , 5 , 2 ] ;
21178: LD_ADDR_VAR 0 9
21182: PUSH
21183: LD_INT 130
21185: PUSH
21186: LD_INT 5
21188: PUSH
21189: LD_INT 2
21191: PUSH
21192: EMPTY
21193: LIST
21194: LIST
21195: LIST
21196: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21197: LD_VAR 0 6
21201: PPUSH
21202: CALL_OW 257
21206: PUSH
21207: LD_INT 8
21209: EQUAL
21210: IFFALSE 21231
// points := [ 35 , 35 , 30 ] ;
21212: LD_ADDR_VAR 0 9
21216: PUSH
21217: LD_INT 35
21219: PUSH
21220: LD_INT 35
21222: PUSH
21223: LD_INT 30
21225: PUSH
21226: EMPTY
21227: LIST
21228: LIST
21229: LIST
21230: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21231: LD_VAR 0 6
21235: PPUSH
21236: CALL_OW 257
21240: PUSH
21241: LD_INT 9
21243: EQUAL
21244: IFFALSE 21265
// points := [ 20 , 55 , 40 ] ;
21246: LD_ADDR_VAR 0 9
21250: PUSH
21251: LD_INT 20
21253: PUSH
21254: LD_INT 55
21256: PUSH
21257: LD_INT 40
21259: PUSH
21260: EMPTY
21261: LIST
21262: LIST
21263: LIST
21264: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21265: LD_VAR 0 6
21269: PPUSH
21270: CALL_OW 257
21274: PUSH
21275: LD_INT 12
21277: PUSH
21278: LD_INT 16
21280: PUSH
21281: EMPTY
21282: LIST
21283: LIST
21284: IN
21285: IFFALSE 21306
// points := [ 5 , 3 , 2 ] ;
21287: LD_ADDR_VAR 0 9
21291: PUSH
21292: LD_INT 5
21294: PUSH
21295: LD_INT 3
21297: PUSH
21298: LD_INT 2
21300: PUSH
21301: EMPTY
21302: LIST
21303: LIST
21304: LIST
21305: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21306: LD_VAR 0 6
21310: PPUSH
21311: CALL_OW 257
21315: PUSH
21316: LD_INT 17
21318: EQUAL
21319: IFFALSE 21340
// points := [ 100 , 50 , 75 ] ;
21321: LD_ADDR_VAR 0 9
21325: PUSH
21326: LD_INT 100
21328: PUSH
21329: LD_INT 50
21331: PUSH
21332: LD_INT 75
21334: PUSH
21335: EMPTY
21336: LIST
21337: LIST
21338: LIST
21339: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21340: LD_VAR 0 6
21344: PPUSH
21345: CALL_OW 257
21349: PUSH
21350: LD_INT 15
21352: EQUAL
21353: IFFALSE 21374
// points := [ 10 , 5 , 3 ] ;
21355: LD_ADDR_VAR 0 9
21359: PUSH
21360: LD_INT 10
21362: PUSH
21363: LD_INT 5
21365: PUSH
21366: LD_INT 3
21368: PUSH
21369: EMPTY
21370: LIST
21371: LIST
21372: LIST
21373: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21374: LD_VAR 0 6
21378: PPUSH
21379: CALL_OW 257
21383: PUSH
21384: LD_INT 14
21386: EQUAL
21387: IFFALSE 21408
// points := [ 10 , 0 , 0 ] ;
21389: LD_ADDR_VAR 0 9
21393: PUSH
21394: LD_INT 10
21396: PUSH
21397: LD_INT 0
21399: PUSH
21400: LD_INT 0
21402: PUSH
21403: EMPTY
21404: LIST
21405: LIST
21406: LIST
21407: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21408: LD_VAR 0 6
21412: PPUSH
21413: CALL_OW 257
21417: PUSH
21418: LD_INT 11
21420: EQUAL
21421: IFFALSE 21442
// points := [ 30 , 10 , 5 ] ;
21423: LD_ADDR_VAR 0 9
21427: PUSH
21428: LD_INT 30
21430: PUSH
21431: LD_INT 10
21433: PUSH
21434: LD_INT 5
21436: PUSH
21437: EMPTY
21438: LIST
21439: LIST
21440: LIST
21441: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21442: LD_VAR 0 1
21446: PPUSH
21447: LD_INT 5
21449: PPUSH
21450: CALL_OW 321
21454: PUSH
21455: LD_INT 2
21457: EQUAL
21458: IFFALSE 21475
// bpoints := bpoints * 1.8 ;
21460: LD_ADDR_VAR 0 10
21464: PUSH
21465: LD_VAR 0 10
21469: PUSH
21470: LD_REAL  1.80000000000000E+0000
21473: MUL
21474: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21475: LD_VAR 0 6
21479: PPUSH
21480: CALL_OW 257
21484: PUSH
21485: LD_INT 1
21487: PUSH
21488: LD_INT 2
21490: PUSH
21491: LD_INT 3
21493: PUSH
21494: LD_INT 4
21496: PUSH
21497: EMPTY
21498: LIST
21499: LIST
21500: LIST
21501: LIST
21502: IN
21503: PUSH
21504: LD_VAR 0 1
21508: PPUSH
21509: LD_INT 51
21511: PPUSH
21512: CALL_OW 321
21516: PUSH
21517: LD_INT 2
21519: EQUAL
21520: AND
21521: IFFALSE 21538
// bpoints := bpoints * 1.2 ;
21523: LD_ADDR_VAR 0 10
21527: PUSH
21528: LD_VAR 0 10
21532: PUSH
21533: LD_REAL  1.20000000000000E+0000
21536: MUL
21537: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21538: LD_VAR 0 6
21542: PPUSH
21543: CALL_OW 257
21547: PUSH
21548: LD_INT 5
21550: PUSH
21551: LD_INT 7
21553: PUSH
21554: LD_INT 9
21556: PUSH
21557: EMPTY
21558: LIST
21559: LIST
21560: LIST
21561: IN
21562: PUSH
21563: LD_VAR 0 1
21567: PPUSH
21568: LD_INT 52
21570: PPUSH
21571: CALL_OW 321
21575: PUSH
21576: LD_INT 2
21578: EQUAL
21579: AND
21580: IFFALSE 21597
// bpoints := bpoints * 1.5 ;
21582: LD_ADDR_VAR 0 10
21586: PUSH
21587: LD_VAR 0 10
21591: PUSH
21592: LD_REAL  1.50000000000000E+0000
21595: MUL
21596: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21597: LD_VAR 0 1
21601: PPUSH
21602: LD_INT 66
21604: PPUSH
21605: CALL_OW 321
21609: PUSH
21610: LD_INT 2
21612: EQUAL
21613: IFFALSE 21630
// bpoints := bpoints * 1.1 ;
21615: LD_ADDR_VAR 0 10
21619: PUSH
21620: LD_VAR 0 10
21624: PUSH
21625: LD_REAL  1.10000000000000E+0000
21628: MUL
21629: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21630: LD_ADDR_VAR 0 10
21634: PUSH
21635: LD_VAR 0 10
21639: PUSH
21640: LD_VAR 0 6
21644: PPUSH
21645: LD_INT 1
21647: PPUSH
21648: CALL_OW 259
21652: PUSH
21653: LD_REAL  1.15000000000000E+0000
21656: MUL
21657: MUL
21658: ST_TO_ADDR
// end ; unit_vehicle :
21659: GO 22487
21661: LD_INT 2
21663: DOUBLE
21664: EQUAL
21665: IFTRUE 21669
21667: GO 22475
21669: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21670: LD_VAR 0 6
21674: PPUSH
21675: CALL_OW 264
21679: PUSH
21680: LD_INT 2
21682: PUSH
21683: LD_INT 42
21685: PUSH
21686: LD_INT 24
21688: PUSH
21689: EMPTY
21690: LIST
21691: LIST
21692: LIST
21693: IN
21694: IFFALSE 21715
// points := [ 25 , 5 , 3 ] ;
21696: LD_ADDR_VAR 0 9
21700: PUSH
21701: LD_INT 25
21703: PUSH
21704: LD_INT 5
21706: PUSH
21707: LD_INT 3
21709: PUSH
21710: EMPTY
21711: LIST
21712: LIST
21713: LIST
21714: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21715: LD_VAR 0 6
21719: PPUSH
21720: CALL_OW 264
21724: PUSH
21725: LD_INT 4
21727: PUSH
21728: LD_INT 43
21730: PUSH
21731: LD_INT 25
21733: PUSH
21734: EMPTY
21735: LIST
21736: LIST
21737: LIST
21738: IN
21739: IFFALSE 21760
// points := [ 40 , 15 , 5 ] ;
21741: LD_ADDR_VAR 0 9
21745: PUSH
21746: LD_INT 40
21748: PUSH
21749: LD_INT 15
21751: PUSH
21752: LD_INT 5
21754: PUSH
21755: EMPTY
21756: LIST
21757: LIST
21758: LIST
21759: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21760: LD_VAR 0 6
21764: PPUSH
21765: CALL_OW 264
21769: PUSH
21770: LD_INT 3
21772: PUSH
21773: LD_INT 23
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: IN
21780: IFFALSE 21801
// points := [ 7 , 25 , 8 ] ;
21782: LD_ADDR_VAR 0 9
21786: PUSH
21787: LD_INT 7
21789: PUSH
21790: LD_INT 25
21792: PUSH
21793: LD_INT 8
21795: PUSH
21796: EMPTY
21797: LIST
21798: LIST
21799: LIST
21800: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21801: LD_VAR 0 6
21805: PPUSH
21806: CALL_OW 264
21810: PUSH
21811: LD_INT 5
21813: PUSH
21814: LD_INT 27
21816: PUSH
21817: LD_INT 44
21819: PUSH
21820: EMPTY
21821: LIST
21822: LIST
21823: LIST
21824: IN
21825: IFFALSE 21846
// points := [ 14 , 50 , 16 ] ;
21827: LD_ADDR_VAR 0 9
21831: PUSH
21832: LD_INT 14
21834: PUSH
21835: LD_INT 50
21837: PUSH
21838: LD_INT 16
21840: PUSH
21841: EMPTY
21842: LIST
21843: LIST
21844: LIST
21845: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21846: LD_VAR 0 6
21850: PPUSH
21851: CALL_OW 264
21855: PUSH
21856: LD_INT 6
21858: PUSH
21859: LD_INT 46
21861: PUSH
21862: EMPTY
21863: LIST
21864: LIST
21865: IN
21866: IFFALSE 21887
// points := [ 32 , 120 , 70 ] ;
21868: LD_ADDR_VAR 0 9
21872: PUSH
21873: LD_INT 32
21875: PUSH
21876: LD_INT 120
21878: PUSH
21879: LD_INT 70
21881: PUSH
21882: EMPTY
21883: LIST
21884: LIST
21885: LIST
21886: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
21887: LD_VAR 0 6
21891: PPUSH
21892: CALL_OW 264
21896: PUSH
21897: LD_INT 7
21899: PUSH
21900: LD_INT 28
21902: PUSH
21903: LD_INT 45
21905: PUSH
21906: LD_INT 92
21908: PUSH
21909: EMPTY
21910: LIST
21911: LIST
21912: LIST
21913: LIST
21914: IN
21915: IFFALSE 21936
// points := [ 35 , 20 , 45 ] ;
21917: LD_ADDR_VAR 0 9
21921: PUSH
21922: LD_INT 35
21924: PUSH
21925: LD_INT 20
21927: PUSH
21928: LD_INT 45
21930: PUSH
21931: EMPTY
21932: LIST
21933: LIST
21934: LIST
21935: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21936: LD_VAR 0 6
21940: PPUSH
21941: CALL_OW 264
21945: PUSH
21946: LD_INT 47
21948: PUSH
21949: EMPTY
21950: LIST
21951: IN
21952: IFFALSE 21973
// points := [ 67 , 45 , 75 ] ;
21954: LD_ADDR_VAR 0 9
21958: PUSH
21959: LD_INT 67
21961: PUSH
21962: LD_INT 45
21964: PUSH
21965: LD_INT 75
21967: PUSH
21968: EMPTY
21969: LIST
21970: LIST
21971: LIST
21972: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21973: LD_VAR 0 6
21977: PPUSH
21978: CALL_OW 264
21982: PUSH
21983: LD_INT 26
21985: PUSH
21986: EMPTY
21987: LIST
21988: IN
21989: IFFALSE 22010
// points := [ 120 , 30 , 80 ] ;
21991: LD_ADDR_VAR 0 9
21995: PUSH
21996: LD_INT 120
21998: PUSH
21999: LD_INT 30
22001: PUSH
22002: LD_INT 80
22004: PUSH
22005: EMPTY
22006: LIST
22007: LIST
22008: LIST
22009: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22010: LD_VAR 0 6
22014: PPUSH
22015: CALL_OW 264
22019: PUSH
22020: LD_INT 22
22022: PUSH
22023: EMPTY
22024: LIST
22025: IN
22026: IFFALSE 22047
// points := [ 40 , 1 , 1 ] ;
22028: LD_ADDR_VAR 0 9
22032: PUSH
22033: LD_INT 40
22035: PUSH
22036: LD_INT 1
22038: PUSH
22039: LD_INT 1
22041: PUSH
22042: EMPTY
22043: LIST
22044: LIST
22045: LIST
22046: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22047: LD_VAR 0 6
22051: PPUSH
22052: CALL_OW 264
22056: PUSH
22057: LD_INT 29
22059: PUSH
22060: EMPTY
22061: LIST
22062: IN
22063: IFFALSE 22084
// points := [ 70 , 200 , 400 ] ;
22065: LD_ADDR_VAR 0 9
22069: PUSH
22070: LD_INT 70
22072: PUSH
22073: LD_INT 200
22075: PUSH
22076: LD_INT 400
22078: PUSH
22079: EMPTY
22080: LIST
22081: LIST
22082: LIST
22083: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22084: LD_VAR 0 6
22088: PPUSH
22089: CALL_OW 264
22093: PUSH
22094: LD_INT 14
22096: PUSH
22097: LD_INT 53
22099: PUSH
22100: EMPTY
22101: LIST
22102: LIST
22103: IN
22104: IFFALSE 22125
// points := [ 40 , 10 , 20 ] ;
22106: LD_ADDR_VAR 0 9
22110: PUSH
22111: LD_INT 40
22113: PUSH
22114: LD_INT 10
22116: PUSH
22117: LD_INT 20
22119: PUSH
22120: EMPTY
22121: LIST
22122: LIST
22123: LIST
22124: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22125: LD_VAR 0 6
22129: PPUSH
22130: CALL_OW 264
22134: PUSH
22135: LD_INT 9
22137: PUSH
22138: EMPTY
22139: LIST
22140: IN
22141: IFFALSE 22162
// points := [ 5 , 70 , 20 ] ;
22143: LD_ADDR_VAR 0 9
22147: PUSH
22148: LD_INT 5
22150: PUSH
22151: LD_INT 70
22153: PUSH
22154: LD_INT 20
22156: PUSH
22157: EMPTY
22158: LIST
22159: LIST
22160: LIST
22161: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22162: LD_VAR 0 6
22166: PPUSH
22167: CALL_OW 264
22171: PUSH
22172: LD_INT 10
22174: PUSH
22175: EMPTY
22176: LIST
22177: IN
22178: IFFALSE 22199
// points := [ 35 , 110 , 70 ] ;
22180: LD_ADDR_VAR 0 9
22184: PUSH
22185: LD_INT 35
22187: PUSH
22188: LD_INT 110
22190: PUSH
22191: LD_INT 70
22193: PUSH
22194: EMPTY
22195: LIST
22196: LIST
22197: LIST
22198: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22199: LD_VAR 0 6
22203: PPUSH
22204: CALL_OW 265
22208: PUSH
22209: LD_INT 25
22211: EQUAL
22212: IFFALSE 22233
// points := [ 80 , 65 , 100 ] ;
22214: LD_ADDR_VAR 0 9
22218: PUSH
22219: LD_INT 80
22221: PUSH
22222: LD_INT 65
22224: PUSH
22225: LD_INT 100
22227: PUSH
22228: EMPTY
22229: LIST
22230: LIST
22231: LIST
22232: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22233: LD_VAR 0 6
22237: PPUSH
22238: CALL_OW 263
22242: PUSH
22243: LD_INT 1
22245: EQUAL
22246: IFFALSE 22281
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22248: LD_ADDR_VAR 0 10
22252: PUSH
22253: LD_VAR 0 10
22257: PUSH
22258: LD_VAR 0 6
22262: PPUSH
22263: CALL_OW 311
22267: PPUSH
22268: LD_INT 3
22270: PPUSH
22271: CALL_OW 259
22275: PUSH
22276: LD_INT 4
22278: MUL
22279: MUL
22280: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22281: LD_VAR 0 6
22285: PPUSH
22286: CALL_OW 263
22290: PUSH
22291: LD_INT 2
22293: EQUAL
22294: IFFALSE 22345
// begin j := IsControledBy ( i ) ;
22296: LD_ADDR_VAR 0 7
22300: PUSH
22301: LD_VAR 0 6
22305: PPUSH
22306: CALL_OW 312
22310: ST_TO_ADDR
// if j then
22311: LD_VAR 0 7
22315: IFFALSE 22345
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22317: LD_ADDR_VAR 0 10
22321: PUSH
22322: LD_VAR 0 10
22326: PUSH
22327: LD_VAR 0 7
22331: PPUSH
22332: LD_INT 3
22334: PPUSH
22335: CALL_OW 259
22339: PUSH
22340: LD_INT 3
22342: MUL
22343: MUL
22344: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22345: LD_VAR 0 6
22349: PPUSH
22350: CALL_OW 264
22354: PUSH
22355: LD_INT 5
22357: PUSH
22358: LD_INT 6
22360: PUSH
22361: LD_INT 46
22363: PUSH
22364: LD_INT 44
22366: PUSH
22367: LD_INT 47
22369: PUSH
22370: LD_INT 45
22372: PUSH
22373: LD_INT 28
22375: PUSH
22376: LD_INT 7
22378: PUSH
22379: LD_INT 27
22381: PUSH
22382: LD_INT 29
22384: PUSH
22385: EMPTY
22386: LIST
22387: LIST
22388: LIST
22389: LIST
22390: LIST
22391: LIST
22392: LIST
22393: LIST
22394: LIST
22395: LIST
22396: IN
22397: PUSH
22398: LD_VAR 0 1
22402: PPUSH
22403: LD_INT 52
22405: PPUSH
22406: CALL_OW 321
22410: PUSH
22411: LD_INT 2
22413: EQUAL
22414: AND
22415: IFFALSE 22432
// bpoints := bpoints * 1.2 ;
22417: LD_ADDR_VAR 0 10
22421: PUSH
22422: LD_VAR 0 10
22426: PUSH
22427: LD_REAL  1.20000000000000E+0000
22430: MUL
22431: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22432: LD_VAR 0 6
22436: PPUSH
22437: CALL_OW 264
22441: PUSH
22442: LD_INT 6
22444: PUSH
22445: LD_INT 46
22447: PUSH
22448: LD_INT 47
22450: PUSH
22451: EMPTY
22452: LIST
22453: LIST
22454: LIST
22455: IN
22456: IFFALSE 22473
// bpoints := bpoints * 1.2 ;
22458: LD_ADDR_VAR 0 10
22462: PUSH
22463: LD_VAR 0 10
22467: PUSH
22468: LD_REAL  1.20000000000000E+0000
22471: MUL
22472: ST_TO_ADDR
// end ; unit_building :
22473: GO 22487
22475: LD_INT 3
22477: DOUBLE
22478: EQUAL
22479: IFTRUE 22483
22481: GO 22486
22483: POP
// ; end ;
22484: GO 22487
22486: POP
// for j = 1 to 3 do
22487: LD_ADDR_VAR 0 7
22491: PUSH
22492: DOUBLE
22493: LD_INT 1
22495: DEC
22496: ST_TO_ADDR
22497: LD_INT 3
22499: PUSH
22500: FOR_TO
22501: IFFALSE 22554
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22503: LD_ADDR_VAR 0 5
22507: PUSH
22508: LD_VAR 0 5
22512: PPUSH
22513: LD_VAR 0 7
22517: PPUSH
22518: LD_VAR 0 5
22522: PUSH
22523: LD_VAR 0 7
22527: ARRAY
22528: PUSH
22529: LD_VAR 0 9
22533: PUSH
22534: LD_VAR 0 7
22538: ARRAY
22539: PUSH
22540: LD_VAR 0 10
22544: MUL
22545: PLUS
22546: PPUSH
22547: CALL_OW 1
22551: ST_TO_ADDR
22552: GO 22500
22554: POP
22555: POP
// end ;
22556: GO 21035
22558: POP
22559: POP
// result := Replace ( result , 4 , tmp ) ;
22560: LD_ADDR_VAR 0 5
22564: PUSH
22565: LD_VAR 0 5
22569: PPUSH
22570: LD_INT 4
22572: PPUSH
22573: LD_VAR 0 8
22577: PPUSH
22578: CALL_OW 1
22582: ST_TO_ADDR
// end ;
22583: LD_VAR 0 5
22587: RET
// export function DangerAtRange ( unit , range ) ; begin
22588: LD_INT 0
22590: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22591: LD_ADDR_VAR 0 3
22595: PUSH
22596: LD_VAR 0 1
22600: PPUSH
22601: CALL_OW 255
22605: PPUSH
22606: LD_VAR 0 1
22610: PPUSH
22611: CALL_OW 250
22615: PPUSH
22616: LD_VAR 0 1
22620: PPUSH
22621: CALL_OW 251
22625: PPUSH
22626: LD_VAR 0 2
22630: PPUSH
22631: CALL 20887 0 4
22635: ST_TO_ADDR
// end ;
22636: LD_VAR 0 3
22640: RET
// export function DangerInArea ( side , area ) ; begin
22641: LD_INT 0
22643: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22644: LD_ADDR_VAR 0 3
22648: PUSH
22649: LD_VAR 0 2
22653: PPUSH
22654: LD_INT 81
22656: PUSH
22657: LD_VAR 0 1
22661: PUSH
22662: EMPTY
22663: LIST
22664: LIST
22665: PPUSH
22666: CALL_OW 70
22670: ST_TO_ADDR
// end ;
22671: LD_VAR 0 3
22675: RET
// export function IsExtension ( b ) ; begin
22676: LD_INT 0
22678: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22679: LD_ADDR_VAR 0 2
22683: PUSH
22684: LD_VAR 0 1
22688: PUSH
22689: LD_INT 23
22691: PUSH
22692: LD_INT 20
22694: PUSH
22695: LD_INT 22
22697: PUSH
22698: LD_INT 17
22700: PUSH
22701: LD_INT 24
22703: PUSH
22704: LD_INT 21
22706: PUSH
22707: LD_INT 19
22709: PUSH
22710: LD_INT 16
22712: PUSH
22713: LD_INT 25
22715: PUSH
22716: LD_INT 18
22718: PUSH
22719: EMPTY
22720: LIST
22721: LIST
22722: LIST
22723: LIST
22724: LIST
22725: LIST
22726: LIST
22727: LIST
22728: LIST
22729: LIST
22730: IN
22731: ST_TO_ADDR
// end ;
22732: LD_VAR 0 2
22736: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22737: LD_INT 0
22739: PPUSH
22740: PPUSH
22741: PPUSH
// result := [ ] ;
22742: LD_ADDR_VAR 0 4
22746: PUSH
22747: EMPTY
22748: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22749: LD_ADDR_VAR 0 5
22753: PUSH
22754: LD_VAR 0 2
22758: PPUSH
22759: LD_INT 21
22761: PUSH
22762: LD_INT 3
22764: PUSH
22765: EMPTY
22766: LIST
22767: LIST
22768: PPUSH
22769: CALL_OW 70
22773: ST_TO_ADDR
// if not tmp then
22774: LD_VAR 0 5
22778: NOT
22779: IFFALSE 22783
// exit ;
22781: GO 22847
// if checkLink then
22783: LD_VAR 0 3
22787: IFFALSE 22837
// begin for i in tmp do
22789: LD_ADDR_VAR 0 6
22793: PUSH
22794: LD_VAR 0 5
22798: PUSH
22799: FOR_IN
22800: IFFALSE 22835
// if GetBase ( i ) <> base then
22802: LD_VAR 0 6
22806: PPUSH
22807: CALL_OW 274
22811: PUSH
22812: LD_VAR 0 1
22816: NONEQUAL
22817: IFFALSE 22833
// ComLinkToBase ( base , i ) ;
22819: LD_VAR 0 1
22823: PPUSH
22824: LD_VAR 0 6
22828: PPUSH
22829: CALL_OW 169
22833: GO 22799
22835: POP
22836: POP
// end ; result := tmp ;
22837: LD_ADDR_VAR 0 4
22841: PUSH
22842: LD_VAR 0 5
22846: ST_TO_ADDR
// end ;
22847: LD_VAR 0 4
22851: RET
// export function ComComplete ( units , b ) ; var i ; begin
22852: LD_INT 0
22854: PPUSH
22855: PPUSH
// if not units then
22856: LD_VAR 0 1
22860: NOT
22861: IFFALSE 22865
// exit ;
22863: GO 22955
// for i in units do
22865: LD_ADDR_VAR 0 4
22869: PUSH
22870: LD_VAR 0 1
22874: PUSH
22875: FOR_IN
22876: IFFALSE 22953
// if BuildingStatus ( b ) = bs_build then
22878: LD_VAR 0 2
22882: PPUSH
22883: CALL_OW 461
22887: PUSH
22888: LD_INT 1
22890: EQUAL
22891: IFFALSE 22951
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22893: LD_VAR 0 4
22897: PPUSH
22898: LD_STRING h
22900: PUSH
22901: LD_VAR 0 2
22905: PPUSH
22906: CALL_OW 250
22910: PUSH
22911: LD_VAR 0 2
22915: PPUSH
22916: CALL_OW 251
22920: PUSH
22921: LD_VAR 0 2
22925: PUSH
22926: LD_INT 0
22928: PUSH
22929: LD_INT 0
22931: PUSH
22932: LD_INT 0
22934: PUSH
22935: EMPTY
22936: LIST
22937: LIST
22938: LIST
22939: LIST
22940: LIST
22941: LIST
22942: LIST
22943: PUSH
22944: EMPTY
22945: LIST
22946: PPUSH
22947: CALL_OW 446
22951: GO 22875
22953: POP
22954: POP
// end ;
22955: LD_VAR 0 3
22959: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22960: LD_INT 0
22962: PPUSH
22963: PPUSH
22964: PPUSH
22965: PPUSH
22966: PPUSH
22967: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
22968: LD_VAR 0 1
22972: NOT
22973: PUSH
22974: LD_VAR 0 1
22978: PPUSH
22979: CALL_OW 263
22983: PUSH
22984: LD_INT 2
22986: NONEQUAL
22987: OR
22988: IFFALSE 22992
// exit ;
22990: GO 23308
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22992: LD_ADDR_VAR 0 6
22996: PUSH
22997: LD_INT 22
22999: PUSH
23000: LD_VAR 0 1
23004: PPUSH
23005: CALL_OW 255
23009: PUSH
23010: EMPTY
23011: LIST
23012: LIST
23013: PUSH
23014: LD_INT 2
23016: PUSH
23017: LD_INT 30
23019: PUSH
23020: LD_INT 36
23022: PUSH
23023: EMPTY
23024: LIST
23025: LIST
23026: PUSH
23027: LD_INT 34
23029: PUSH
23030: LD_INT 31
23032: PUSH
23033: EMPTY
23034: LIST
23035: LIST
23036: PUSH
23037: EMPTY
23038: LIST
23039: LIST
23040: LIST
23041: PUSH
23042: EMPTY
23043: LIST
23044: LIST
23045: PPUSH
23046: CALL_OW 69
23050: ST_TO_ADDR
// if not tmp then
23051: LD_VAR 0 6
23055: NOT
23056: IFFALSE 23060
// exit ;
23058: GO 23308
// result := [ ] ;
23060: LD_ADDR_VAR 0 2
23064: PUSH
23065: EMPTY
23066: ST_TO_ADDR
// for i in tmp do
23067: LD_ADDR_VAR 0 3
23071: PUSH
23072: LD_VAR 0 6
23076: PUSH
23077: FOR_IN
23078: IFFALSE 23149
// begin t := UnitsInside ( i ) ;
23080: LD_ADDR_VAR 0 4
23084: PUSH
23085: LD_VAR 0 3
23089: PPUSH
23090: CALL_OW 313
23094: ST_TO_ADDR
// if t then
23095: LD_VAR 0 4
23099: IFFALSE 23147
// for j in t do
23101: LD_ADDR_VAR 0 7
23105: PUSH
23106: LD_VAR 0 4
23110: PUSH
23111: FOR_IN
23112: IFFALSE 23145
// result := Replace ( result , result + 1 , j ) ;
23114: LD_ADDR_VAR 0 2
23118: PUSH
23119: LD_VAR 0 2
23123: PPUSH
23124: LD_VAR 0 2
23128: PUSH
23129: LD_INT 1
23131: PLUS
23132: PPUSH
23133: LD_VAR 0 7
23137: PPUSH
23138: CALL_OW 1
23142: ST_TO_ADDR
23143: GO 23111
23145: POP
23146: POP
// end ;
23147: GO 23077
23149: POP
23150: POP
// if not result then
23151: LD_VAR 0 2
23155: NOT
23156: IFFALSE 23160
// exit ;
23158: GO 23308
// mech := result [ 1 ] ;
23160: LD_ADDR_VAR 0 5
23164: PUSH
23165: LD_VAR 0 2
23169: PUSH
23170: LD_INT 1
23172: ARRAY
23173: ST_TO_ADDR
// if result > 1 then
23174: LD_VAR 0 2
23178: PUSH
23179: LD_INT 1
23181: GREATER
23182: IFFALSE 23294
// begin for i = 2 to result do
23184: LD_ADDR_VAR 0 3
23188: PUSH
23189: DOUBLE
23190: LD_INT 2
23192: DEC
23193: ST_TO_ADDR
23194: LD_VAR 0 2
23198: PUSH
23199: FOR_TO
23200: IFFALSE 23292
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23202: LD_ADDR_VAR 0 4
23206: PUSH
23207: LD_VAR 0 2
23211: PUSH
23212: LD_VAR 0 3
23216: ARRAY
23217: PPUSH
23218: LD_INT 3
23220: PPUSH
23221: CALL_OW 259
23225: PUSH
23226: LD_VAR 0 2
23230: PUSH
23231: LD_VAR 0 3
23235: ARRAY
23236: PPUSH
23237: CALL_OW 432
23241: MINUS
23242: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23243: LD_VAR 0 4
23247: PUSH
23248: LD_VAR 0 5
23252: PPUSH
23253: LD_INT 3
23255: PPUSH
23256: CALL_OW 259
23260: PUSH
23261: LD_VAR 0 5
23265: PPUSH
23266: CALL_OW 432
23270: MINUS
23271: GREATEREQUAL
23272: IFFALSE 23290
// mech := result [ i ] ;
23274: LD_ADDR_VAR 0 5
23278: PUSH
23279: LD_VAR 0 2
23283: PUSH
23284: LD_VAR 0 3
23288: ARRAY
23289: ST_TO_ADDR
// end ;
23290: GO 23199
23292: POP
23293: POP
// end ; ComLinkTo ( vehicle , mech ) ;
23294: LD_VAR 0 1
23298: PPUSH
23299: LD_VAR 0 5
23303: PPUSH
23304: CALL_OW 135
// end ;
23308: LD_VAR 0 2
23312: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23313: LD_INT 0
23315: PPUSH
23316: PPUSH
23317: PPUSH
23318: PPUSH
23319: PPUSH
23320: PPUSH
23321: PPUSH
23322: PPUSH
23323: PPUSH
23324: PPUSH
23325: PPUSH
23326: PPUSH
23327: PPUSH
// result := [ ] ;
23328: LD_ADDR_VAR 0 7
23332: PUSH
23333: EMPTY
23334: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23335: LD_VAR 0 1
23339: PPUSH
23340: CALL_OW 266
23344: PUSH
23345: LD_INT 0
23347: PUSH
23348: LD_INT 1
23350: PUSH
23351: EMPTY
23352: LIST
23353: LIST
23354: IN
23355: NOT
23356: IFFALSE 23360
// exit ;
23358: GO 24994
// if name then
23360: LD_VAR 0 3
23364: IFFALSE 23380
// SetBName ( base_dep , name ) ;
23366: LD_VAR 0 1
23370: PPUSH
23371: LD_VAR 0 3
23375: PPUSH
23376: CALL_OW 500
// base := GetBase ( base_dep ) ;
23380: LD_ADDR_VAR 0 15
23384: PUSH
23385: LD_VAR 0 1
23389: PPUSH
23390: CALL_OW 274
23394: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23395: LD_ADDR_VAR 0 16
23399: PUSH
23400: LD_VAR 0 1
23404: PPUSH
23405: CALL_OW 255
23409: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23410: LD_ADDR_VAR 0 17
23414: PUSH
23415: LD_VAR 0 1
23419: PPUSH
23420: CALL_OW 248
23424: ST_TO_ADDR
// if sources then
23425: LD_VAR 0 5
23429: IFFALSE 23476
// for i = 1 to 3 do
23431: LD_ADDR_VAR 0 8
23435: PUSH
23436: DOUBLE
23437: LD_INT 1
23439: DEC
23440: ST_TO_ADDR
23441: LD_INT 3
23443: PUSH
23444: FOR_TO
23445: IFFALSE 23474
// AddResourceType ( base , i , sources [ i ] ) ;
23447: LD_VAR 0 15
23451: PPUSH
23452: LD_VAR 0 8
23456: PPUSH
23457: LD_VAR 0 5
23461: PUSH
23462: LD_VAR 0 8
23466: ARRAY
23467: PPUSH
23468: CALL_OW 276
23472: GO 23444
23474: POP
23475: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23476: LD_ADDR_VAR 0 18
23480: PUSH
23481: LD_VAR 0 15
23485: PPUSH
23486: LD_VAR 0 2
23490: PPUSH
23491: LD_INT 1
23493: PPUSH
23494: CALL 22737 0 3
23498: ST_TO_ADDR
// InitHc ;
23499: CALL_OW 19
// InitUc ;
23503: CALL_OW 18
// uc_side := side ;
23507: LD_ADDR_OWVAR 20
23511: PUSH
23512: LD_VAR 0 16
23516: ST_TO_ADDR
// uc_nation := nation ;
23517: LD_ADDR_OWVAR 21
23521: PUSH
23522: LD_VAR 0 17
23526: ST_TO_ADDR
// if buildings then
23527: LD_VAR 0 18
23531: IFFALSE 24853
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23533: LD_ADDR_VAR 0 19
23537: PUSH
23538: LD_VAR 0 18
23542: PPUSH
23543: LD_INT 2
23545: PUSH
23546: LD_INT 30
23548: PUSH
23549: LD_INT 29
23551: PUSH
23552: EMPTY
23553: LIST
23554: LIST
23555: PUSH
23556: LD_INT 30
23558: PUSH
23559: LD_INT 30
23561: PUSH
23562: EMPTY
23563: LIST
23564: LIST
23565: PUSH
23566: EMPTY
23567: LIST
23568: LIST
23569: LIST
23570: PPUSH
23571: CALL_OW 72
23575: ST_TO_ADDR
// if tmp then
23576: LD_VAR 0 19
23580: IFFALSE 23628
// for i in tmp do
23582: LD_ADDR_VAR 0 8
23586: PUSH
23587: LD_VAR 0 19
23591: PUSH
23592: FOR_IN
23593: IFFALSE 23626
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23595: LD_VAR 0 8
23599: PPUSH
23600: CALL_OW 250
23604: PPUSH
23605: LD_VAR 0 8
23609: PPUSH
23610: CALL_OW 251
23614: PPUSH
23615: LD_VAR 0 16
23619: PPUSH
23620: CALL_OW 441
23624: GO 23592
23626: POP
23627: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23628: LD_VAR 0 18
23632: PPUSH
23633: LD_INT 2
23635: PUSH
23636: LD_INT 30
23638: PUSH
23639: LD_INT 32
23641: PUSH
23642: EMPTY
23643: LIST
23644: LIST
23645: PUSH
23646: LD_INT 30
23648: PUSH
23649: LD_INT 33
23651: PUSH
23652: EMPTY
23653: LIST
23654: LIST
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: LIST
23660: PPUSH
23661: CALL_OW 72
23665: IFFALSE 23753
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23667: LD_ADDR_VAR 0 8
23671: PUSH
23672: LD_VAR 0 18
23676: PPUSH
23677: LD_INT 2
23679: PUSH
23680: LD_INT 30
23682: PUSH
23683: LD_INT 32
23685: PUSH
23686: EMPTY
23687: LIST
23688: LIST
23689: PUSH
23690: LD_INT 30
23692: PUSH
23693: LD_INT 33
23695: PUSH
23696: EMPTY
23697: LIST
23698: LIST
23699: PUSH
23700: EMPTY
23701: LIST
23702: LIST
23703: LIST
23704: PPUSH
23705: CALL_OW 72
23709: PUSH
23710: FOR_IN
23711: IFFALSE 23751
// begin if not GetBWeapon ( i ) then
23713: LD_VAR 0 8
23717: PPUSH
23718: CALL_OW 269
23722: NOT
23723: IFFALSE 23749
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23725: LD_VAR 0 8
23729: PPUSH
23730: LD_VAR 0 8
23734: PPUSH
23735: LD_VAR 0 2
23739: PPUSH
23740: CALL 24999 0 2
23744: PPUSH
23745: CALL_OW 431
// end ;
23749: GO 23710
23751: POP
23752: POP
// end ; for i = 1 to personel do
23753: LD_ADDR_VAR 0 8
23757: PUSH
23758: DOUBLE
23759: LD_INT 1
23761: DEC
23762: ST_TO_ADDR
23763: LD_VAR 0 6
23767: PUSH
23768: FOR_TO
23769: IFFALSE 24833
// begin if i > 4 then
23771: LD_VAR 0 8
23775: PUSH
23776: LD_INT 4
23778: GREATER
23779: IFFALSE 23783
// break ;
23781: GO 24833
// case i of 1 :
23783: LD_VAR 0 8
23787: PUSH
23788: LD_INT 1
23790: DOUBLE
23791: EQUAL
23792: IFTRUE 23796
23794: GO 23876
23796: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23797: LD_ADDR_VAR 0 12
23801: PUSH
23802: LD_VAR 0 18
23806: PPUSH
23807: LD_INT 22
23809: PUSH
23810: LD_VAR 0 16
23814: PUSH
23815: EMPTY
23816: LIST
23817: LIST
23818: PUSH
23819: LD_INT 58
23821: PUSH
23822: EMPTY
23823: LIST
23824: PUSH
23825: LD_INT 2
23827: PUSH
23828: LD_INT 30
23830: PUSH
23831: LD_INT 32
23833: PUSH
23834: EMPTY
23835: LIST
23836: LIST
23837: PUSH
23838: LD_INT 30
23840: PUSH
23841: LD_INT 4
23843: PUSH
23844: EMPTY
23845: LIST
23846: LIST
23847: PUSH
23848: LD_INT 30
23850: PUSH
23851: LD_INT 5
23853: PUSH
23854: EMPTY
23855: LIST
23856: LIST
23857: PUSH
23858: EMPTY
23859: LIST
23860: LIST
23861: LIST
23862: LIST
23863: PUSH
23864: EMPTY
23865: LIST
23866: LIST
23867: LIST
23868: PPUSH
23869: CALL_OW 72
23873: ST_TO_ADDR
23874: GO 24098
23876: LD_INT 2
23878: DOUBLE
23879: EQUAL
23880: IFTRUE 23884
23882: GO 23946
23884: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23885: LD_ADDR_VAR 0 12
23889: PUSH
23890: LD_VAR 0 18
23894: PPUSH
23895: LD_INT 22
23897: PUSH
23898: LD_VAR 0 16
23902: PUSH
23903: EMPTY
23904: LIST
23905: LIST
23906: PUSH
23907: LD_INT 2
23909: PUSH
23910: LD_INT 30
23912: PUSH
23913: LD_INT 0
23915: PUSH
23916: EMPTY
23917: LIST
23918: LIST
23919: PUSH
23920: LD_INT 30
23922: PUSH
23923: LD_INT 1
23925: PUSH
23926: EMPTY
23927: LIST
23928: LIST
23929: PUSH
23930: EMPTY
23931: LIST
23932: LIST
23933: LIST
23934: PUSH
23935: EMPTY
23936: LIST
23937: LIST
23938: PPUSH
23939: CALL_OW 72
23943: ST_TO_ADDR
23944: GO 24098
23946: LD_INT 3
23948: DOUBLE
23949: EQUAL
23950: IFTRUE 23954
23952: GO 24016
23954: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23955: LD_ADDR_VAR 0 12
23959: PUSH
23960: LD_VAR 0 18
23964: PPUSH
23965: LD_INT 22
23967: PUSH
23968: LD_VAR 0 16
23972: PUSH
23973: EMPTY
23974: LIST
23975: LIST
23976: PUSH
23977: LD_INT 2
23979: PUSH
23980: LD_INT 30
23982: PUSH
23983: LD_INT 2
23985: PUSH
23986: EMPTY
23987: LIST
23988: LIST
23989: PUSH
23990: LD_INT 30
23992: PUSH
23993: LD_INT 3
23995: PUSH
23996: EMPTY
23997: LIST
23998: LIST
23999: PUSH
24000: EMPTY
24001: LIST
24002: LIST
24003: LIST
24004: PUSH
24005: EMPTY
24006: LIST
24007: LIST
24008: PPUSH
24009: CALL_OW 72
24013: ST_TO_ADDR
24014: GO 24098
24016: LD_INT 4
24018: DOUBLE
24019: EQUAL
24020: IFTRUE 24024
24022: GO 24097
24024: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24025: LD_ADDR_VAR 0 12
24029: PUSH
24030: LD_VAR 0 18
24034: PPUSH
24035: LD_INT 22
24037: PUSH
24038: LD_VAR 0 16
24042: PUSH
24043: EMPTY
24044: LIST
24045: LIST
24046: PUSH
24047: LD_INT 2
24049: PUSH
24050: LD_INT 30
24052: PUSH
24053: LD_INT 6
24055: PUSH
24056: EMPTY
24057: LIST
24058: LIST
24059: PUSH
24060: LD_INT 30
24062: PUSH
24063: LD_INT 7
24065: PUSH
24066: EMPTY
24067: LIST
24068: LIST
24069: PUSH
24070: LD_INT 30
24072: PUSH
24073: LD_INT 8
24075: PUSH
24076: EMPTY
24077: LIST
24078: LIST
24079: PUSH
24080: EMPTY
24081: LIST
24082: LIST
24083: LIST
24084: LIST
24085: PUSH
24086: EMPTY
24087: LIST
24088: LIST
24089: PPUSH
24090: CALL_OW 72
24094: ST_TO_ADDR
24095: GO 24098
24097: POP
// if i = 1 then
24098: LD_VAR 0 8
24102: PUSH
24103: LD_INT 1
24105: EQUAL
24106: IFFALSE 24217
// begin tmp := [ ] ;
24108: LD_ADDR_VAR 0 19
24112: PUSH
24113: EMPTY
24114: ST_TO_ADDR
// for j in f do
24115: LD_ADDR_VAR 0 9
24119: PUSH
24120: LD_VAR 0 12
24124: PUSH
24125: FOR_IN
24126: IFFALSE 24199
// if GetBType ( j ) = b_bunker then
24128: LD_VAR 0 9
24132: PPUSH
24133: CALL_OW 266
24137: PUSH
24138: LD_INT 32
24140: EQUAL
24141: IFFALSE 24168
// tmp := Insert ( tmp , 1 , j ) else
24143: LD_ADDR_VAR 0 19
24147: PUSH
24148: LD_VAR 0 19
24152: PPUSH
24153: LD_INT 1
24155: PPUSH
24156: LD_VAR 0 9
24160: PPUSH
24161: CALL_OW 2
24165: ST_TO_ADDR
24166: GO 24197
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24168: LD_ADDR_VAR 0 19
24172: PUSH
24173: LD_VAR 0 19
24177: PPUSH
24178: LD_VAR 0 19
24182: PUSH
24183: LD_INT 1
24185: PLUS
24186: PPUSH
24187: LD_VAR 0 9
24191: PPUSH
24192: CALL_OW 2
24196: ST_TO_ADDR
24197: GO 24125
24199: POP
24200: POP
// if tmp then
24201: LD_VAR 0 19
24205: IFFALSE 24217
// f := tmp ;
24207: LD_ADDR_VAR 0 12
24211: PUSH
24212: LD_VAR 0 19
24216: ST_TO_ADDR
// end ; x := personel [ i ] ;
24217: LD_ADDR_VAR 0 13
24221: PUSH
24222: LD_VAR 0 6
24226: PUSH
24227: LD_VAR 0 8
24231: ARRAY
24232: ST_TO_ADDR
// if x = - 1 then
24233: LD_VAR 0 13
24237: PUSH
24238: LD_INT 1
24240: NEG
24241: EQUAL
24242: IFFALSE 24451
// begin for j in f do
24244: LD_ADDR_VAR 0 9
24248: PUSH
24249: LD_VAR 0 12
24253: PUSH
24254: FOR_IN
24255: IFFALSE 24447
// repeat InitHc ;
24257: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24261: LD_VAR 0 9
24265: PPUSH
24266: CALL_OW 266
24270: PUSH
24271: LD_INT 5
24273: EQUAL
24274: IFFALSE 24344
// begin if UnitsInside ( j ) < 3 then
24276: LD_VAR 0 9
24280: PPUSH
24281: CALL_OW 313
24285: PUSH
24286: LD_INT 3
24288: LESS
24289: IFFALSE 24325
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24291: LD_INT 0
24293: PPUSH
24294: LD_INT 5
24296: PUSH
24297: LD_INT 8
24299: PUSH
24300: LD_INT 9
24302: PUSH
24303: EMPTY
24304: LIST
24305: LIST
24306: LIST
24307: PUSH
24308: LD_VAR 0 17
24312: ARRAY
24313: PPUSH
24314: LD_VAR 0 4
24318: PPUSH
24319: CALL_OW 380
24323: GO 24342
// PrepareHuman ( false , i , skill ) ;
24325: LD_INT 0
24327: PPUSH
24328: LD_VAR 0 8
24332: PPUSH
24333: LD_VAR 0 4
24337: PPUSH
24338: CALL_OW 380
// end else
24342: GO 24361
// PrepareHuman ( false , i , skill ) ;
24344: LD_INT 0
24346: PPUSH
24347: LD_VAR 0 8
24351: PPUSH
24352: LD_VAR 0 4
24356: PPUSH
24357: CALL_OW 380
// un := CreateHuman ;
24361: LD_ADDR_VAR 0 14
24365: PUSH
24366: CALL_OW 44
24370: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24371: LD_ADDR_VAR 0 7
24375: PUSH
24376: LD_VAR 0 7
24380: PPUSH
24381: LD_INT 1
24383: PPUSH
24384: LD_VAR 0 14
24388: PPUSH
24389: CALL_OW 2
24393: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24394: LD_VAR 0 14
24398: PPUSH
24399: LD_VAR 0 9
24403: PPUSH
24404: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24408: LD_VAR 0 9
24412: PPUSH
24413: CALL_OW 313
24417: PUSH
24418: LD_INT 6
24420: EQUAL
24421: PUSH
24422: LD_VAR 0 9
24426: PPUSH
24427: CALL_OW 266
24431: PUSH
24432: LD_INT 32
24434: PUSH
24435: LD_INT 31
24437: PUSH
24438: EMPTY
24439: LIST
24440: LIST
24441: IN
24442: OR
24443: IFFALSE 24257
24445: GO 24254
24447: POP
24448: POP
// end else
24449: GO 24831
// for j = 1 to x do
24451: LD_ADDR_VAR 0 9
24455: PUSH
24456: DOUBLE
24457: LD_INT 1
24459: DEC
24460: ST_TO_ADDR
24461: LD_VAR 0 13
24465: PUSH
24466: FOR_TO
24467: IFFALSE 24829
// begin InitHc ;
24469: CALL_OW 19
// if not f then
24473: LD_VAR 0 12
24477: NOT
24478: IFFALSE 24567
// begin PrepareHuman ( false , i , skill ) ;
24480: LD_INT 0
24482: PPUSH
24483: LD_VAR 0 8
24487: PPUSH
24488: LD_VAR 0 4
24492: PPUSH
24493: CALL_OW 380
// un := CreateHuman ;
24497: LD_ADDR_VAR 0 14
24501: PUSH
24502: CALL_OW 44
24506: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24507: LD_ADDR_VAR 0 7
24511: PUSH
24512: LD_VAR 0 7
24516: PPUSH
24517: LD_INT 1
24519: PPUSH
24520: LD_VAR 0 14
24524: PPUSH
24525: CALL_OW 2
24529: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24530: LD_VAR 0 14
24534: PPUSH
24535: LD_VAR 0 1
24539: PPUSH
24540: CALL_OW 250
24544: PPUSH
24545: LD_VAR 0 1
24549: PPUSH
24550: CALL_OW 251
24554: PPUSH
24555: LD_INT 10
24557: PPUSH
24558: LD_INT 0
24560: PPUSH
24561: CALL_OW 50
// continue ;
24565: GO 24466
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24567: LD_VAR 0 12
24571: PUSH
24572: LD_INT 1
24574: ARRAY
24575: PPUSH
24576: CALL_OW 313
24580: PUSH
24581: LD_VAR 0 12
24585: PUSH
24586: LD_INT 1
24588: ARRAY
24589: PPUSH
24590: CALL_OW 266
24594: PUSH
24595: LD_INT 32
24597: PUSH
24598: LD_INT 31
24600: PUSH
24601: EMPTY
24602: LIST
24603: LIST
24604: IN
24605: AND
24606: PUSH
24607: LD_VAR 0 12
24611: PUSH
24612: LD_INT 1
24614: ARRAY
24615: PPUSH
24616: CALL_OW 313
24620: PUSH
24621: LD_INT 6
24623: EQUAL
24624: OR
24625: IFFALSE 24645
// f := Delete ( f , 1 ) ;
24627: LD_ADDR_VAR 0 12
24631: PUSH
24632: LD_VAR 0 12
24636: PPUSH
24637: LD_INT 1
24639: PPUSH
24640: CALL_OW 3
24644: ST_TO_ADDR
// if not f then
24645: LD_VAR 0 12
24649: NOT
24650: IFFALSE 24668
// begin x := x + 2 ;
24652: LD_ADDR_VAR 0 13
24656: PUSH
24657: LD_VAR 0 13
24661: PUSH
24662: LD_INT 2
24664: PLUS
24665: ST_TO_ADDR
// continue ;
24666: GO 24466
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24668: LD_VAR 0 12
24672: PUSH
24673: LD_INT 1
24675: ARRAY
24676: PPUSH
24677: CALL_OW 266
24681: PUSH
24682: LD_INT 5
24684: EQUAL
24685: IFFALSE 24759
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24687: LD_VAR 0 12
24691: PUSH
24692: LD_INT 1
24694: ARRAY
24695: PPUSH
24696: CALL_OW 313
24700: PUSH
24701: LD_INT 3
24703: LESS
24704: IFFALSE 24740
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24706: LD_INT 0
24708: PPUSH
24709: LD_INT 5
24711: PUSH
24712: LD_INT 8
24714: PUSH
24715: LD_INT 9
24717: PUSH
24718: EMPTY
24719: LIST
24720: LIST
24721: LIST
24722: PUSH
24723: LD_VAR 0 17
24727: ARRAY
24728: PPUSH
24729: LD_VAR 0 4
24733: PPUSH
24734: CALL_OW 380
24738: GO 24757
// PrepareHuman ( false , i , skill ) ;
24740: LD_INT 0
24742: PPUSH
24743: LD_VAR 0 8
24747: PPUSH
24748: LD_VAR 0 4
24752: PPUSH
24753: CALL_OW 380
// end else
24757: GO 24776
// PrepareHuman ( false , i , skill ) ;
24759: LD_INT 0
24761: PPUSH
24762: LD_VAR 0 8
24766: PPUSH
24767: LD_VAR 0 4
24771: PPUSH
24772: CALL_OW 380
// un := CreateHuman ;
24776: LD_ADDR_VAR 0 14
24780: PUSH
24781: CALL_OW 44
24785: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24786: LD_ADDR_VAR 0 7
24790: PUSH
24791: LD_VAR 0 7
24795: PPUSH
24796: LD_INT 1
24798: PPUSH
24799: LD_VAR 0 14
24803: PPUSH
24804: CALL_OW 2
24808: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24809: LD_VAR 0 14
24813: PPUSH
24814: LD_VAR 0 12
24818: PUSH
24819: LD_INT 1
24821: ARRAY
24822: PPUSH
24823: CALL_OW 52
// end ;
24827: GO 24466
24829: POP
24830: POP
// end ;
24831: GO 23768
24833: POP
24834: POP
// result := result ^ buildings ;
24835: LD_ADDR_VAR 0 7
24839: PUSH
24840: LD_VAR 0 7
24844: PUSH
24845: LD_VAR 0 18
24849: ADD
24850: ST_TO_ADDR
// end else
24851: GO 24994
// begin for i = 1 to personel do
24853: LD_ADDR_VAR 0 8
24857: PUSH
24858: DOUBLE
24859: LD_INT 1
24861: DEC
24862: ST_TO_ADDR
24863: LD_VAR 0 6
24867: PUSH
24868: FOR_TO
24869: IFFALSE 24992
// begin if i > 4 then
24871: LD_VAR 0 8
24875: PUSH
24876: LD_INT 4
24878: GREATER
24879: IFFALSE 24883
// break ;
24881: GO 24992
// x := personel [ i ] ;
24883: LD_ADDR_VAR 0 13
24887: PUSH
24888: LD_VAR 0 6
24892: PUSH
24893: LD_VAR 0 8
24897: ARRAY
24898: ST_TO_ADDR
// if x = - 1 then
24899: LD_VAR 0 13
24903: PUSH
24904: LD_INT 1
24906: NEG
24907: EQUAL
24908: IFFALSE 24912
// continue ;
24910: GO 24868
// PrepareHuman ( false , i , skill ) ;
24912: LD_INT 0
24914: PPUSH
24915: LD_VAR 0 8
24919: PPUSH
24920: LD_VAR 0 4
24924: PPUSH
24925: CALL_OW 380
// un := CreateHuman ;
24929: LD_ADDR_VAR 0 14
24933: PUSH
24934: CALL_OW 44
24938: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24939: LD_VAR 0 14
24943: PPUSH
24944: LD_VAR 0 1
24948: PPUSH
24949: CALL_OW 250
24953: PPUSH
24954: LD_VAR 0 1
24958: PPUSH
24959: CALL_OW 251
24963: PPUSH
24964: LD_INT 10
24966: PPUSH
24967: LD_INT 0
24969: PPUSH
24970: CALL_OW 50
// result := result ^ un ;
24974: LD_ADDR_VAR 0 7
24978: PUSH
24979: LD_VAR 0 7
24983: PUSH
24984: LD_VAR 0 14
24988: ADD
24989: ST_TO_ADDR
// end ;
24990: GO 24868
24992: POP
24993: POP
// end ; end ;
24994: LD_VAR 0 7
24998: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24999: LD_INT 0
25001: PPUSH
25002: PPUSH
25003: PPUSH
25004: PPUSH
25005: PPUSH
25006: PPUSH
25007: PPUSH
25008: PPUSH
25009: PPUSH
25010: PPUSH
25011: PPUSH
25012: PPUSH
25013: PPUSH
25014: PPUSH
25015: PPUSH
25016: PPUSH
// result := false ;
25017: LD_ADDR_VAR 0 3
25021: PUSH
25022: LD_INT 0
25024: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25025: LD_VAR 0 1
25029: NOT
25030: PUSH
25031: LD_VAR 0 1
25035: PPUSH
25036: CALL_OW 266
25040: PUSH
25041: LD_INT 32
25043: PUSH
25044: LD_INT 33
25046: PUSH
25047: EMPTY
25048: LIST
25049: LIST
25050: IN
25051: NOT
25052: OR
25053: IFFALSE 25057
// exit ;
25055: GO 26166
// nat := GetNation ( tower ) ;
25057: LD_ADDR_VAR 0 12
25061: PUSH
25062: LD_VAR 0 1
25066: PPUSH
25067: CALL_OW 248
25071: ST_TO_ADDR
// side := GetSide ( tower ) ;
25072: LD_ADDR_VAR 0 16
25076: PUSH
25077: LD_VAR 0 1
25081: PPUSH
25082: CALL_OW 255
25086: ST_TO_ADDR
// x := GetX ( tower ) ;
25087: LD_ADDR_VAR 0 10
25091: PUSH
25092: LD_VAR 0 1
25096: PPUSH
25097: CALL_OW 250
25101: ST_TO_ADDR
// y := GetY ( tower ) ;
25102: LD_ADDR_VAR 0 11
25106: PUSH
25107: LD_VAR 0 1
25111: PPUSH
25112: CALL_OW 251
25116: ST_TO_ADDR
// if not x or not y then
25117: LD_VAR 0 10
25121: NOT
25122: PUSH
25123: LD_VAR 0 11
25127: NOT
25128: OR
25129: IFFALSE 25133
// exit ;
25131: GO 26166
// weapon := 0 ;
25133: LD_ADDR_VAR 0 18
25137: PUSH
25138: LD_INT 0
25140: ST_TO_ADDR
// fac_list := [ ] ;
25141: LD_ADDR_VAR 0 17
25145: PUSH
25146: EMPTY
25147: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
25148: LD_ADDR_VAR 0 6
25152: PUSH
25153: LD_VAR 0 1
25157: PPUSH
25158: CALL_OW 274
25162: PPUSH
25163: LD_VAR 0 2
25167: PPUSH
25168: LD_INT 0
25170: PPUSH
25171: CALL 22737 0 3
25175: PPUSH
25176: LD_INT 30
25178: PUSH
25179: LD_INT 3
25181: PUSH
25182: EMPTY
25183: LIST
25184: LIST
25185: PPUSH
25186: CALL_OW 72
25190: ST_TO_ADDR
// if not factories then
25191: LD_VAR 0 6
25195: NOT
25196: IFFALSE 25200
// exit ;
25198: GO 26166
// for i in factories do
25200: LD_ADDR_VAR 0 8
25204: PUSH
25205: LD_VAR 0 6
25209: PUSH
25210: FOR_IN
25211: IFFALSE 25236
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25213: LD_ADDR_VAR 0 17
25217: PUSH
25218: LD_VAR 0 17
25222: PUSH
25223: LD_VAR 0 8
25227: PPUSH
25228: CALL_OW 478
25232: UNION
25233: ST_TO_ADDR
25234: GO 25210
25236: POP
25237: POP
// if not fac_list then
25238: LD_VAR 0 17
25242: NOT
25243: IFFALSE 25247
// exit ;
25245: GO 26166
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25247: LD_ADDR_VAR 0 5
25251: PUSH
25252: LD_INT 4
25254: PUSH
25255: LD_INT 5
25257: PUSH
25258: LD_INT 9
25260: PUSH
25261: LD_INT 10
25263: PUSH
25264: LD_INT 6
25266: PUSH
25267: LD_INT 7
25269: PUSH
25270: LD_INT 11
25272: PUSH
25273: EMPTY
25274: LIST
25275: LIST
25276: LIST
25277: LIST
25278: LIST
25279: LIST
25280: LIST
25281: PUSH
25282: LD_INT 27
25284: PUSH
25285: LD_INT 28
25287: PUSH
25288: LD_INT 26
25290: PUSH
25291: LD_INT 30
25293: PUSH
25294: EMPTY
25295: LIST
25296: LIST
25297: LIST
25298: LIST
25299: PUSH
25300: LD_INT 43
25302: PUSH
25303: LD_INT 44
25305: PUSH
25306: LD_INT 46
25308: PUSH
25309: LD_INT 45
25311: PUSH
25312: LD_INT 47
25314: PUSH
25315: LD_INT 49
25317: PUSH
25318: EMPTY
25319: LIST
25320: LIST
25321: LIST
25322: LIST
25323: LIST
25324: LIST
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: LIST
25330: PUSH
25331: LD_VAR 0 12
25335: ARRAY
25336: ST_TO_ADDR
// list := list isect fac_list ;
25337: LD_ADDR_VAR 0 5
25341: PUSH
25342: LD_VAR 0 5
25346: PUSH
25347: LD_VAR 0 17
25351: ISECT
25352: ST_TO_ADDR
// if not list then
25353: LD_VAR 0 5
25357: NOT
25358: IFFALSE 25362
// exit ;
25360: GO 26166
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25362: LD_VAR 0 12
25366: PUSH
25367: LD_INT 3
25369: EQUAL
25370: PUSH
25371: LD_INT 49
25373: PUSH
25374: LD_VAR 0 5
25378: IN
25379: AND
25380: PUSH
25381: LD_INT 31
25383: PPUSH
25384: LD_VAR 0 16
25388: PPUSH
25389: CALL_OW 321
25393: PUSH
25394: LD_INT 2
25396: EQUAL
25397: AND
25398: IFFALSE 25458
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25400: LD_INT 22
25402: PUSH
25403: LD_VAR 0 16
25407: PUSH
25408: EMPTY
25409: LIST
25410: LIST
25411: PUSH
25412: LD_INT 35
25414: PUSH
25415: LD_INT 49
25417: PUSH
25418: EMPTY
25419: LIST
25420: LIST
25421: PUSH
25422: LD_INT 91
25424: PUSH
25425: LD_VAR 0 1
25429: PUSH
25430: LD_INT 10
25432: PUSH
25433: EMPTY
25434: LIST
25435: LIST
25436: LIST
25437: PUSH
25438: EMPTY
25439: LIST
25440: LIST
25441: LIST
25442: PPUSH
25443: CALL_OW 69
25447: NOT
25448: IFFALSE 25458
// weapon := ru_time_lapser ;
25450: LD_ADDR_VAR 0 18
25454: PUSH
25455: LD_INT 49
25457: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25458: LD_VAR 0 12
25462: PUSH
25463: LD_INT 1
25465: PUSH
25466: LD_INT 2
25468: PUSH
25469: EMPTY
25470: LIST
25471: LIST
25472: IN
25473: PUSH
25474: LD_INT 11
25476: PUSH
25477: LD_VAR 0 5
25481: IN
25482: PUSH
25483: LD_INT 30
25485: PUSH
25486: LD_VAR 0 5
25490: IN
25491: OR
25492: AND
25493: PUSH
25494: LD_INT 6
25496: PPUSH
25497: LD_VAR 0 16
25501: PPUSH
25502: CALL_OW 321
25506: PUSH
25507: LD_INT 2
25509: EQUAL
25510: AND
25511: IFFALSE 25676
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25513: LD_INT 22
25515: PUSH
25516: LD_VAR 0 16
25520: PUSH
25521: EMPTY
25522: LIST
25523: LIST
25524: PUSH
25525: LD_INT 2
25527: PUSH
25528: LD_INT 35
25530: PUSH
25531: LD_INT 11
25533: PUSH
25534: EMPTY
25535: LIST
25536: LIST
25537: PUSH
25538: LD_INT 35
25540: PUSH
25541: LD_INT 30
25543: PUSH
25544: EMPTY
25545: LIST
25546: LIST
25547: PUSH
25548: EMPTY
25549: LIST
25550: LIST
25551: LIST
25552: PUSH
25553: LD_INT 91
25555: PUSH
25556: LD_VAR 0 1
25560: PUSH
25561: LD_INT 18
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: LIST
25568: PUSH
25569: EMPTY
25570: LIST
25571: LIST
25572: LIST
25573: PPUSH
25574: CALL_OW 69
25578: NOT
25579: PUSH
25580: LD_INT 22
25582: PUSH
25583: LD_VAR 0 16
25587: PUSH
25588: EMPTY
25589: LIST
25590: LIST
25591: PUSH
25592: LD_INT 2
25594: PUSH
25595: LD_INT 30
25597: PUSH
25598: LD_INT 32
25600: PUSH
25601: EMPTY
25602: LIST
25603: LIST
25604: PUSH
25605: LD_INT 30
25607: PUSH
25608: LD_INT 33
25610: PUSH
25611: EMPTY
25612: LIST
25613: LIST
25614: PUSH
25615: EMPTY
25616: LIST
25617: LIST
25618: LIST
25619: PUSH
25620: LD_INT 91
25622: PUSH
25623: LD_VAR 0 1
25627: PUSH
25628: LD_INT 12
25630: PUSH
25631: EMPTY
25632: LIST
25633: LIST
25634: LIST
25635: PUSH
25636: EMPTY
25637: LIST
25638: LIST
25639: LIST
25640: PUSH
25641: EMPTY
25642: LIST
25643: PPUSH
25644: CALL_OW 69
25648: PUSH
25649: LD_INT 2
25651: GREATER
25652: AND
25653: IFFALSE 25676
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25655: LD_ADDR_VAR 0 18
25659: PUSH
25660: LD_INT 11
25662: PUSH
25663: LD_INT 30
25665: PUSH
25666: EMPTY
25667: LIST
25668: LIST
25669: PUSH
25670: LD_VAR 0 12
25674: ARRAY
25675: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25676: LD_VAR 0 18
25680: NOT
25681: PUSH
25682: LD_INT 40
25684: PPUSH
25685: LD_VAR 0 16
25689: PPUSH
25690: CALL_OW 321
25694: PUSH
25695: LD_INT 2
25697: EQUAL
25698: AND
25699: PUSH
25700: LD_INT 7
25702: PUSH
25703: LD_VAR 0 5
25707: IN
25708: PUSH
25709: LD_INT 28
25711: PUSH
25712: LD_VAR 0 5
25716: IN
25717: OR
25718: PUSH
25719: LD_INT 45
25721: PUSH
25722: LD_VAR 0 5
25726: IN
25727: OR
25728: AND
25729: IFFALSE 25983
// begin hex := GetHexInfo ( x , y ) ;
25731: LD_ADDR_VAR 0 4
25735: PUSH
25736: LD_VAR 0 10
25740: PPUSH
25741: LD_VAR 0 11
25745: PPUSH
25746: CALL_OW 546
25750: ST_TO_ADDR
// if hex [ 1 ] then
25751: LD_VAR 0 4
25755: PUSH
25756: LD_INT 1
25758: ARRAY
25759: IFFALSE 25763
// exit ;
25761: GO 26166
// height := hex [ 2 ] ;
25763: LD_ADDR_VAR 0 15
25767: PUSH
25768: LD_VAR 0 4
25772: PUSH
25773: LD_INT 2
25775: ARRAY
25776: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25777: LD_ADDR_VAR 0 14
25781: PUSH
25782: LD_INT 0
25784: PUSH
25785: LD_INT 2
25787: PUSH
25788: LD_INT 3
25790: PUSH
25791: LD_INT 5
25793: PUSH
25794: EMPTY
25795: LIST
25796: LIST
25797: LIST
25798: LIST
25799: ST_TO_ADDR
// for i in tmp do
25800: LD_ADDR_VAR 0 8
25804: PUSH
25805: LD_VAR 0 14
25809: PUSH
25810: FOR_IN
25811: IFFALSE 25981
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25813: LD_ADDR_VAR 0 9
25817: PUSH
25818: LD_VAR 0 10
25822: PPUSH
25823: LD_VAR 0 8
25827: PPUSH
25828: LD_INT 5
25830: PPUSH
25831: CALL_OW 272
25835: PUSH
25836: LD_VAR 0 11
25840: PPUSH
25841: LD_VAR 0 8
25845: PPUSH
25846: LD_INT 5
25848: PPUSH
25849: CALL_OW 273
25853: PUSH
25854: EMPTY
25855: LIST
25856: LIST
25857: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25858: LD_VAR 0 9
25862: PUSH
25863: LD_INT 1
25865: ARRAY
25866: PPUSH
25867: LD_VAR 0 9
25871: PUSH
25872: LD_INT 2
25874: ARRAY
25875: PPUSH
25876: CALL_OW 488
25880: IFFALSE 25979
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25882: LD_ADDR_VAR 0 4
25886: PUSH
25887: LD_VAR 0 9
25891: PUSH
25892: LD_INT 1
25894: ARRAY
25895: PPUSH
25896: LD_VAR 0 9
25900: PUSH
25901: LD_INT 2
25903: ARRAY
25904: PPUSH
25905: CALL_OW 546
25909: ST_TO_ADDR
// if hex [ 1 ] then
25910: LD_VAR 0 4
25914: PUSH
25915: LD_INT 1
25917: ARRAY
25918: IFFALSE 25922
// continue ;
25920: GO 25810
// h := hex [ 2 ] ;
25922: LD_ADDR_VAR 0 13
25926: PUSH
25927: LD_VAR 0 4
25931: PUSH
25932: LD_INT 2
25934: ARRAY
25935: ST_TO_ADDR
// if h + 7 < height then
25936: LD_VAR 0 13
25940: PUSH
25941: LD_INT 7
25943: PLUS
25944: PUSH
25945: LD_VAR 0 15
25949: LESS
25950: IFFALSE 25979
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25952: LD_ADDR_VAR 0 18
25956: PUSH
25957: LD_INT 7
25959: PUSH
25960: LD_INT 28
25962: PUSH
25963: LD_INT 45
25965: PUSH
25966: EMPTY
25967: LIST
25968: LIST
25969: LIST
25970: PUSH
25971: LD_VAR 0 12
25975: ARRAY
25976: ST_TO_ADDR
// break ;
25977: GO 25981
// end ; end ; end ;
25979: GO 25810
25981: POP
25982: POP
// end ; if not weapon then
25983: LD_VAR 0 18
25987: NOT
25988: IFFALSE 26048
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25990: LD_ADDR_VAR 0 5
25994: PUSH
25995: LD_VAR 0 5
25999: PUSH
26000: LD_INT 11
26002: PUSH
26003: LD_INT 30
26005: PUSH
26006: LD_INT 49
26008: PUSH
26009: EMPTY
26010: LIST
26011: LIST
26012: LIST
26013: DIFF
26014: ST_TO_ADDR
// if not list then
26015: LD_VAR 0 5
26019: NOT
26020: IFFALSE 26024
// exit ;
26022: GO 26166
// weapon := list [ rand ( 1 , list ) ] ;
26024: LD_ADDR_VAR 0 18
26028: PUSH
26029: LD_VAR 0 5
26033: PUSH
26034: LD_INT 1
26036: PPUSH
26037: LD_VAR 0 5
26041: PPUSH
26042: CALL_OW 12
26046: ARRAY
26047: ST_TO_ADDR
// end ; if weapon then
26048: LD_VAR 0 18
26052: IFFALSE 26166
// begin tmp := CostOfWeapon ( weapon ) ;
26054: LD_ADDR_VAR 0 14
26058: PUSH
26059: LD_VAR 0 18
26063: PPUSH
26064: CALL_OW 451
26068: ST_TO_ADDR
// j := GetBase ( tower ) ;
26069: LD_ADDR_VAR 0 9
26073: PUSH
26074: LD_VAR 0 1
26078: PPUSH
26079: CALL_OW 274
26083: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26084: LD_VAR 0 9
26088: PPUSH
26089: LD_INT 1
26091: PPUSH
26092: CALL_OW 275
26096: PUSH
26097: LD_VAR 0 14
26101: PUSH
26102: LD_INT 1
26104: ARRAY
26105: GREATEREQUAL
26106: PUSH
26107: LD_VAR 0 9
26111: PPUSH
26112: LD_INT 2
26114: PPUSH
26115: CALL_OW 275
26119: PUSH
26120: LD_VAR 0 14
26124: PUSH
26125: LD_INT 2
26127: ARRAY
26128: GREATEREQUAL
26129: AND
26130: PUSH
26131: LD_VAR 0 9
26135: PPUSH
26136: LD_INT 3
26138: PPUSH
26139: CALL_OW 275
26143: PUSH
26144: LD_VAR 0 14
26148: PUSH
26149: LD_INT 3
26151: ARRAY
26152: GREATEREQUAL
26153: AND
26154: IFFALSE 26166
// result := weapon ;
26156: LD_ADDR_VAR 0 3
26160: PUSH
26161: LD_VAR 0 18
26165: ST_TO_ADDR
// end ; end ;
26166: LD_VAR 0 3
26170: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26171: LD_INT 0
26173: PPUSH
26174: PPUSH
// result := true ;
26175: LD_ADDR_VAR 0 3
26179: PUSH
26180: LD_INT 1
26182: ST_TO_ADDR
// if array1 = array2 then
26183: LD_VAR 0 1
26187: PUSH
26188: LD_VAR 0 2
26192: EQUAL
26193: IFFALSE 26253
// begin for i = 1 to array1 do
26195: LD_ADDR_VAR 0 4
26199: PUSH
26200: DOUBLE
26201: LD_INT 1
26203: DEC
26204: ST_TO_ADDR
26205: LD_VAR 0 1
26209: PUSH
26210: FOR_TO
26211: IFFALSE 26249
// if array1 [ i ] <> array2 [ i ] then
26213: LD_VAR 0 1
26217: PUSH
26218: LD_VAR 0 4
26222: ARRAY
26223: PUSH
26224: LD_VAR 0 2
26228: PUSH
26229: LD_VAR 0 4
26233: ARRAY
26234: NONEQUAL
26235: IFFALSE 26247
// begin result := false ;
26237: LD_ADDR_VAR 0 3
26241: PUSH
26242: LD_INT 0
26244: ST_TO_ADDR
// break ;
26245: GO 26249
// end ;
26247: GO 26210
26249: POP
26250: POP
// end else
26251: GO 26261
// result := false ;
26253: LD_ADDR_VAR 0 3
26257: PUSH
26258: LD_INT 0
26260: ST_TO_ADDR
// end ;
26261: LD_VAR 0 3
26265: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
26266: LD_INT 0
26268: PPUSH
26269: PPUSH
// if not array1 or not array2 then
26270: LD_VAR 0 1
26274: NOT
26275: PUSH
26276: LD_VAR 0 2
26280: NOT
26281: OR
26282: IFFALSE 26286
// exit ;
26284: GO 26350
// result := true ;
26286: LD_ADDR_VAR 0 3
26290: PUSH
26291: LD_INT 1
26293: ST_TO_ADDR
// for i = 1 to array1 do
26294: LD_ADDR_VAR 0 4
26298: PUSH
26299: DOUBLE
26300: LD_INT 1
26302: DEC
26303: ST_TO_ADDR
26304: LD_VAR 0 1
26308: PUSH
26309: FOR_TO
26310: IFFALSE 26348
// if array1 [ i ] <> array2 [ i ] then
26312: LD_VAR 0 1
26316: PUSH
26317: LD_VAR 0 4
26321: ARRAY
26322: PUSH
26323: LD_VAR 0 2
26327: PUSH
26328: LD_VAR 0 4
26332: ARRAY
26333: NONEQUAL
26334: IFFALSE 26346
// begin result := false ;
26336: LD_ADDR_VAR 0 3
26340: PUSH
26341: LD_INT 0
26343: ST_TO_ADDR
// break ;
26344: GO 26348
// end ;
26346: GO 26309
26348: POP
26349: POP
// end ;
26350: LD_VAR 0 3
26354: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26355: LD_INT 0
26357: PPUSH
26358: PPUSH
26359: PPUSH
// pom := GetBase ( fac ) ;
26360: LD_ADDR_VAR 0 5
26364: PUSH
26365: LD_VAR 0 1
26369: PPUSH
26370: CALL_OW 274
26374: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26375: LD_ADDR_VAR 0 4
26379: PUSH
26380: LD_VAR 0 2
26384: PUSH
26385: LD_INT 1
26387: ARRAY
26388: PPUSH
26389: LD_VAR 0 2
26393: PUSH
26394: LD_INT 2
26396: ARRAY
26397: PPUSH
26398: LD_VAR 0 2
26402: PUSH
26403: LD_INT 3
26405: ARRAY
26406: PPUSH
26407: LD_VAR 0 2
26411: PUSH
26412: LD_INT 4
26414: ARRAY
26415: PPUSH
26416: CALL_OW 449
26420: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26421: LD_ADDR_VAR 0 3
26425: PUSH
26426: LD_VAR 0 5
26430: PPUSH
26431: LD_INT 1
26433: PPUSH
26434: CALL_OW 275
26438: PUSH
26439: LD_VAR 0 4
26443: PUSH
26444: LD_INT 1
26446: ARRAY
26447: GREATEREQUAL
26448: PUSH
26449: LD_VAR 0 5
26453: PPUSH
26454: LD_INT 2
26456: PPUSH
26457: CALL_OW 275
26461: PUSH
26462: LD_VAR 0 4
26466: PUSH
26467: LD_INT 2
26469: ARRAY
26470: GREATEREQUAL
26471: AND
26472: PUSH
26473: LD_VAR 0 5
26477: PPUSH
26478: LD_INT 3
26480: PPUSH
26481: CALL_OW 275
26485: PUSH
26486: LD_VAR 0 4
26490: PUSH
26491: LD_INT 3
26493: ARRAY
26494: GREATEREQUAL
26495: AND
26496: ST_TO_ADDR
// end ;
26497: LD_VAR 0 3
26501: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26502: LD_INT 0
26504: PPUSH
26505: PPUSH
26506: PPUSH
26507: PPUSH
// pom := GetBase ( building ) ;
26508: LD_ADDR_VAR 0 3
26512: PUSH
26513: LD_VAR 0 1
26517: PPUSH
26518: CALL_OW 274
26522: ST_TO_ADDR
// if not pom then
26523: LD_VAR 0 3
26527: NOT
26528: IFFALSE 26532
// exit ;
26530: GO 26702
// btype := GetBType ( building ) ;
26532: LD_ADDR_VAR 0 5
26536: PUSH
26537: LD_VAR 0 1
26541: PPUSH
26542: CALL_OW 266
26546: ST_TO_ADDR
// if btype = b_armoury then
26547: LD_VAR 0 5
26551: PUSH
26552: LD_INT 4
26554: EQUAL
26555: IFFALSE 26565
// btype := b_barracks ;
26557: LD_ADDR_VAR 0 5
26561: PUSH
26562: LD_INT 5
26564: ST_TO_ADDR
// if btype = b_depot then
26565: LD_VAR 0 5
26569: PUSH
26570: LD_INT 0
26572: EQUAL
26573: IFFALSE 26583
// btype := b_warehouse ;
26575: LD_ADDR_VAR 0 5
26579: PUSH
26580: LD_INT 1
26582: ST_TO_ADDR
// if btype = b_workshop then
26583: LD_VAR 0 5
26587: PUSH
26588: LD_INT 2
26590: EQUAL
26591: IFFALSE 26601
// btype := b_factory ;
26593: LD_ADDR_VAR 0 5
26597: PUSH
26598: LD_INT 3
26600: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26601: LD_ADDR_VAR 0 4
26605: PUSH
26606: LD_VAR 0 5
26610: PPUSH
26611: LD_VAR 0 1
26615: PPUSH
26616: CALL_OW 248
26620: PPUSH
26621: CALL_OW 450
26625: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26626: LD_ADDR_VAR 0 2
26630: PUSH
26631: LD_VAR 0 3
26635: PPUSH
26636: LD_INT 1
26638: PPUSH
26639: CALL_OW 275
26643: PUSH
26644: LD_VAR 0 4
26648: PUSH
26649: LD_INT 1
26651: ARRAY
26652: GREATEREQUAL
26653: PUSH
26654: LD_VAR 0 3
26658: PPUSH
26659: LD_INT 2
26661: PPUSH
26662: CALL_OW 275
26666: PUSH
26667: LD_VAR 0 4
26671: PUSH
26672: LD_INT 2
26674: ARRAY
26675: GREATEREQUAL
26676: AND
26677: PUSH
26678: LD_VAR 0 3
26682: PPUSH
26683: LD_INT 3
26685: PPUSH
26686: CALL_OW 275
26690: PUSH
26691: LD_VAR 0 4
26695: PUSH
26696: LD_INT 3
26698: ARRAY
26699: GREATEREQUAL
26700: AND
26701: ST_TO_ADDR
// end ;
26702: LD_VAR 0 2
26706: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26707: LD_INT 0
26709: PPUSH
26710: PPUSH
26711: PPUSH
// pom := GetBase ( building ) ;
26712: LD_ADDR_VAR 0 4
26716: PUSH
26717: LD_VAR 0 1
26721: PPUSH
26722: CALL_OW 274
26726: ST_TO_ADDR
// if not pom then
26727: LD_VAR 0 4
26731: NOT
26732: IFFALSE 26736
// exit ;
26734: GO 26837
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26736: LD_ADDR_VAR 0 5
26740: PUSH
26741: LD_VAR 0 2
26745: PPUSH
26746: LD_VAR 0 1
26750: PPUSH
26751: CALL_OW 248
26755: PPUSH
26756: CALL_OW 450
26760: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26761: LD_ADDR_VAR 0 3
26765: PUSH
26766: LD_VAR 0 4
26770: PPUSH
26771: LD_INT 1
26773: PPUSH
26774: CALL_OW 275
26778: PUSH
26779: LD_VAR 0 5
26783: PUSH
26784: LD_INT 1
26786: ARRAY
26787: GREATEREQUAL
26788: PUSH
26789: LD_VAR 0 4
26793: PPUSH
26794: LD_INT 2
26796: PPUSH
26797: CALL_OW 275
26801: PUSH
26802: LD_VAR 0 5
26806: PUSH
26807: LD_INT 2
26809: ARRAY
26810: GREATEREQUAL
26811: AND
26812: PUSH
26813: LD_VAR 0 4
26817: PPUSH
26818: LD_INT 3
26820: PPUSH
26821: CALL_OW 275
26825: PUSH
26826: LD_VAR 0 5
26830: PUSH
26831: LD_INT 3
26833: ARRAY
26834: GREATEREQUAL
26835: AND
26836: ST_TO_ADDR
// end ;
26837: LD_VAR 0 3
26841: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26842: LD_INT 0
26844: PPUSH
26845: PPUSH
26846: PPUSH
26847: PPUSH
26848: PPUSH
26849: PPUSH
26850: PPUSH
26851: PPUSH
26852: PPUSH
26853: PPUSH
26854: PPUSH
// result := false ;
26855: LD_ADDR_VAR 0 8
26859: PUSH
26860: LD_INT 0
26862: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26863: LD_VAR 0 5
26867: NOT
26868: PUSH
26869: LD_VAR 0 1
26873: NOT
26874: OR
26875: PUSH
26876: LD_VAR 0 2
26880: NOT
26881: OR
26882: PUSH
26883: LD_VAR 0 3
26887: NOT
26888: OR
26889: IFFALSE 26893
// exit ;
26891: GO 27707
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26893: LD_ADDR_VAR 0 14
26897: PUSH
26898: LD_VAR 0 1
26902: PPUSH
26903: LD_VAR 0 2
26907: PPUSH
26908: LD_VAR 0 3
26912: PPUSH
26913: LD_VAR 0 4
26917: PPUSH
26918: LD_VAR 0 5
26922: PUSH
26923: LD_INT 1
26925: ARRAY
26926: PPUSH
26927: CALL_OW 248
26931: PPUSH
26932: LD_INT 0
26934: PPUSH
26935: CALL 28940 0 6
26939: ST_TO_ADDR
// if not hexes then
26940: LD_VAR 0 14
26944: NOT
26945: IFFALSE 26949
// exit ;
26947: GO 27707
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26949: LD_ADDR_VAR 0 17
26953: PUSH
26954: LD_VAR 0 5
26958: PPUSH
26959: LD_INT 22
26961: PUSH
26962: LD_VAR 0 13
26966: PPUSH
26967: CALL_OW 255
26971: PUSH
26972: EMPTY
26973: LIST
26974: LIST
26975: PUSH
26976: LD_INT 2
26978: PUSH
26979: LD_INT 30
26981: PUSH
26982: LD_INT 0
26984: PUSH
26985: EMPTY
26986: LIST
26987: LIST
26988: PUSH
26989: LD_INT 30
26991: PUSH
26992: LD_INT 1
26994: PUSH
26995: EMPTY
26996: LIST
26997: LIST
26998: PUSH
26999: EMPTY
27000: LIST
27001: LIST
27002: LIST
27003: PUSH
27004: EMPTY
27005: LIST
27006: LIST
27007: PPUSH
27008: CALL_OW 72
27012: ST_TO_ADDR
// for i = 1 to hexes do
27013: LD_ADDR_VAR 0 9
27017: PUSH
27018: DOUBLE
27019: LD_INT 1
27021: DEC
27022: ST_TO_ADDR
27023: LD_VAR 0 14
27027: PUSH
27028: FOR_TO
27029: IFFALSE 27705
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27031: LD_ADDR_VAR 0 13
27035: PUSH
27036: LD_VAR 0 14
27040: PUSH
27041: LD_VAR 0 9
27045: ARRAY
27046: PUSH
27047: LD_INT 1
27049: ARRAY
27050: PPUSH
27051: LD_VAR 0 14
27055: PUSH
27056: LD_VAR 0 9
27060: ARRAY
27061: PUSH
27062: LD_INT 2
27064: ARRAY
27065: PPUSH
27066: CALL_OW 428
27070: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27071: LD_VAR 0 14
27075: PUSH
27076: LD_VAR 0 9
27080: ARRAY
27081: PUSH
27082: LD_INT 1
27084: ARRAY
27085: PPUSH
27086: LD_VAR 0 14
27090: PUSH
27091: LD_VAR 0 9
27095: ARRAY
27096: PUSH
27097: LD_INT 2
27099: ARRAY
27100: PPUSH
27101: CALL_OW 351
27105: PUSH
27106: LD_VAR 0 14
27110: PUSH
27111: LD_VAR 0 9
27115: ARRAY
27116: PUSH
27117: LD_INT 1
27119: ARRAY
27120: PPUSH
27121: LD_VAR 0 14
27125: PUSH
27126: LD_VAR 0 9
27130: ARRAY
27131: PUSH
27132: LD_INT 2
27134: ARRAY
27135: PPUSH
27136: CALL_OW 488
27140: NOT
27141: OR
27142: PUSH
27143: LD_VAR 0 13
27147: PPUSH
27148: CALL_OW 247
27152: PUSH
27153: LD_INT 3
27155: EQUAL
27156: OR
27157: IFFALSE 27163
// exit ;
27159: POP
27160: POP
27161: GO 27707
// if not tmp then
27163: LD_VAR 0 13
27167: NOT
27168: IFFALSE 27172
// continue ;
27170: GO 27028
// result := true ;
27172: LD_ADDR_VAR 0 8
27176: PUSH
27177: LD_INT 1
27179: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
27180: LD_VAR 0 6
27184: PUSH
27185: LD_VAR 0 13
27189: PPUSH
27190: CALL_OW 247
27194: PUSH
27195: LD_INT 2
27197: EQUAL
27198: AND
27199: PUSH
27200: LD_VAR 0 13
27204: PPUSH
27205: CALL_OW 263
27209: PUSH
27210: LD_INT 1
27212: EQUAL
27213: AND
27214: IFFALSE 27378
// begin if IsDrivenBy ( tmp ) then
27216: LD_VAR 0 13
27220: PPUSH
27221: CALL_OW 311
27225: IFFALSE 27229
// continue ;
27227: GO 27028
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
27229: LD_VAR 0 6
27233: PPUSH
27234: LD_INT 3
27236: PUSH
27237: LD_INT 60
27239: PUSH
27240: EMPTY
27241: LIST
27242: PUSH
27243: EMPTY
27244: LIST
27245: LIST
27246: PUSH
27247: LD_INT 3
27249: PUSH
27250: LD_INT 55
27252: PUSH
27253: EMPTY
27254: LIST
27255: PUSH
27256: EMPTY
27257: LIST
27258: LIST
27259: PUSH
27260: EMPTY
27261: LIST
27262: LIST
27263: PPUSH
27264: CALL_OW 72
27268: IFFALSE 27376
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
27270: LD_ADDR_VAR 0 18
27274: PUSH
27275: LD_VAR 0 6
27279: PPUSH
27280: LD_INT 3
27282: PUSH
27283: LD_INT 60
27285: PUSH
27286: EMPTY
27287: LIST
27288: PUSH
27289: EMPTY
27290: LIST
27291: LIST
27292: PUSH
27293: LD_INT 3
27295: PUSH
27296: LD_INT 55
27298: PUSH
27299: EMPTY
27300: LIST
27301: PUSH
27302: EMPTY
27303: LIST
27304: LIST
27305: PUSH
27306: EMPTY
27307: LIST
27308: LIST
27309: PPUSH
27310: CALL_OW 72
27314: PUSH
27315: LD_INT 1
27317: ARRAY
27318: ST_TO_ADDR
// if IsInUnit ( driver ) then
27319: LD_VAR 0 18
27323: PPUSH
27324: CALL_OW 310
27328: IFFALSE 27339
// ComExit ( driver ) ;
27330: LD_VAR 0 18
27334: PPUSH
27335: CALL 52628 0 1
// AddComEnterUnit ( driver , tmp ) ;
27339: LD_VAR 0 18
27343: PPUSH
27344: LD_VAR 0 13
27348: PPUSH
27349: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27353: LD_VAR 0 18
27357: PPUSH
27358: LD_VAR 0 7
27362: PPUSH
27363: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27367: LD_VAR 0 18
27371: PPUSH
27372: CALL_OW 181
// end ; continue ;
27376: GO 27028
// end ; if not cleaners or not tmp in cleaners then
27378: LD_VAR 0 6
27382: NOT
27383: PUSH
27384: LD_VAR 0 13
27388: PUSH
27389: LD_VAR 0 6
27393: IN
27394: NOT
27395: OR
27396: IFFALSE 27703
// begin if dep then
27398: LD_VAR 0 17
27402: IFFALSE 27538
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27404: LD_ADDR_VAR 0 16
27408: PUSH
27409: LD_VAR 0 17
27413: PUSH
27414: LD_INT 1
27416: ARRAY
27417: PPUSH
27418: CALL_OW 250
27422: PPUSH
27423: LD_VAR 0 17
27427: PUSH
27428: LD_INT 1
27430: ARRAY
27431: PPUSH
27432: CALL_OW 254
27436: PPUSH
27437: LD_INT 5
27439: PPUSH
27440: CALL_OW 272
27444: PUSH
27445: LD_VAR 0 17
27449: PUSH
27450: LD_INT 1
27452: ARRAY
27453: PPUSH
27454: CALL_OW 251
27458: PPUSH
27459: LD_VAR 0 17
27463: PUSH
27464: LD_INT 1
27466: ARRAY
27467: PPUSH
27468: CALL_OW 254
27472: PPUSH
27473: LD_INT 5
27475: PPUSH
27476: CALL_OW 273
27480: PUSH
27481: EMPTY
27482: LIST
27483: LIST
27484: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27485: LD_VAR 0 16
27489: PUSH
27490: LD_INT 1
27492: ARRAY
27493: PPUSH
27494: LD_VAR 0 16
27498: PUSH
27499: LD_INT 2
27501: ARRAY
27502: PPUSH
27503: CALL_OW 488
27507: IFFALSE 27538
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27509: LD_VAR 0 13
27513: PPUSH
27514: LD_VAR 0 16
27518: PUSH
27519: LD_INT 1
27521: ARRAY
27522: PPUSH
27523: LD_VAR 0 16
27527: PUSH
27528: LD_INT 2
27530: ARRAY
27531: PPUSH
27532: CALL_OW 111
// continue ;
27536: GO 27028
// end ; end ; r := GetDir ( tmp ) ;
27538: LD_ADDR_VAR 0 15
27542: PUSH
27543: LD_VAR 0 13
27547: PPUSH
27548: CALL_OW 254
27552: ST_TO_ADDR
// if r = 5 then
27553: LD_VAR 0 15
27557: PUSH
27558: LD_INT 5
27560: EQUAL
27561: IFFALSE 27571
// r := 0 ;
27563: LD_ADDR_VAR 0 15
27567: PUSH
27568: LD_INT 0
27570: ST_TO_ADDR
// for j = r to 5 do
27571: LD_ADDR_VAR 0 10
27575: PUSH
27576: DOUBLE
27577: LD_VAR 0 15
27581: DEC
27582: ST_TO_ADDR
27583: LD_INT 5
27585: PUSH
27586: FOR_TO
27587: IFFALSE 27701
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27589: LD_ADDR_VAR 0 11
27593: PUSH
27594: LD_VAR 0 13
27598: PPUSH
27599: CALL_OW 250
27603: PPUSH
27604: LD_VAR 0 10
27608: PPUSH
27609: LD_INT 2
27611: PPUSH
27612: CALL_OW 272
27616: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27617: LD_ADDR_VAR 0 12
27621: PUSH
27622: LD_VAR 0 13
27626: PPUSH
27627: CALL_OW 251
27631: PPUSH
27632: LD_VAR 0 10
27636: PPUSH
27637: LD_INT 2
27639: PPUSH
27640: CALL_OW 273
27644: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27645: LD_VAR 0 11
27649: PPUSH
27650: LD_VAR 0 12
27654: PPUSH
27655: CALL_OW 488
27659: PUSH
27660: LD_VAR 0 11
27664: PPUSH
27665: LD_VAR 0 12
27669: PPUSH
27670: CALL_OW 428
27674: NOT
27675: AND
27676: IFFALSE 27699
// begin ComMoveXY ( tmp , _x , _y ) ;
27678: LD_VAR 0 13
27682: PPUSH
27683: LD_VAR 0 11
27687: PPUSH
27688: LD_VAR 0 12
27692: PPUSH
27693: CALL_OW 111
// break ;
27697: GO 27701
// end ; end ;
27699: GO 27586
27701: POP
27702: POP
// end ; end ;
27703: GO 27028
27705: POP
27706: POP
// end ;
27707: LD_VAR 0 8
27711: RET
// export function BuildingTechInvented ( side , btype ) ; begin
27712: LD_INT 0
27714: PPUSH
// result := true ;
27715: LD_ADDR_VAR 0 3
27719: PUSH
27720: LD_INT 1
27722: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
27723: LD_VAR 0 2
27727: PUSH
27728: LD_INT 24
27730: DOUBLE
27731: EQUAL
27732: IFTRUE 27742
27734: LD_INT 33
27736: DOUBLE
27737: EQUAL
27738: IFTRUE 27742
27740: GO 27767
27742: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
27743: LD_ADDR_VAR 0 3
27747: PUSH
27748: LD_INT 32
27750: PPUSH
27751: LD_VAR 0 1
27755: PPUSH
27756: CALL_OW 321
27760: PUSH
27761: LD_INT 2
27763: EQUAL
27764: ST_TO_ADDR
27765: GO 28083
27767: LD_INT 20
27769: DOUBLE
27770: EQUAL
27771: IFTRUE 27775
27773: GO 27800
27775: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
27776: LD_ADDR_VAR 0 3
27780: PUSH
27781: LD_INT 6
27783: PPUSH
27784: LD_VAR 0 1
27788: PPUSH
27789: CALL_OW 321
27793: PUSH
27794: LD_INT 2
27796: EQUAL
27797: ST_TO_ADDR
27798: GO 28083
27800: LD_INT 22
27802: DOUBLE
27803: EQUAL
27804: IFTRUE 27814
27806: LD_INT 36
27808: DOUBLE
27809: EQUAL
27810: IFTRUE 27814
27812: GO 27839
27814: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
27815: LD_ADDR_VAR 0 3
27819: PUSH
27820: LD_INT 15
27822: PPUSH
27823: LD_VAR 0 1
27827: PPUSH
27828: CALL_OW 321
27832: PUSH
27833: LD_INT 2
27835: EQUAL
27836: ST_TO_ADDR
27837: GO 28083
27839: LD_INT 30
27841: DOUBLE
27842: EQUAL
27843: IFTRUE 27847
27845: GO 27872
27847: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
27848: LD_ADDR_VAR 0 3
27852: PUSH
27853: LD_INT 20
27855: PPUSH
27856: LD_VAR 0 1
27860: PPUSH
27861: CALL_OW 321
27865: PUSH
27866: LD_INT 2
27868: EQUAL
27869: ST_TO_ADDR
27870: GO 28083
27872: LD_INT 28
27874: DOUBLE
27875: EQUAL
27876: IFTRUE 27886
27878: LD_INT 21
27880: DOUBLE
27881: EQUAL
27882: IFTRUE 27886
27884: GO 27911
27886: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
27887: LD_ADDR_VAR 0 3
27891: PUSH
27892: LD_INT 21
27894: PPUSH
27895: LD_VAR 0 1
27899: PPUSH
27900: CALL_OW 321
27904: PUSH
27905: LD_INT 2
27907: EQUAL
27908: ST_TO_ADDR
27909: GO 28083
27911: LD_INT 16
27913: DOUBLE
27914: EQUAL
27915: IFTRUE 27919
27917: GO 27944
27919: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
27920: LD_ADDR_VAR 0 3
27924: PUSH
27925: LD_INT 84
27927: PPUSH
27928: LD_VAR 0 1
27932: PPUSH
27933: CALL_OW 321
27937: PUSH
27938: LD_INT 2
27940: EQUAL
27941: ST_TO_ADDR
27942: GO 28083
27944: LD_INT 19
27946: DOUBLE
27947: EQUAL
27948: IFTRUE 27958
27950: LD_INT 23
27952: DOUBLE
27953: EQUAL
27954: IFTRUE 27958
27956: GO 27983
27958: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
27959: LD_ADDR_VAR 0 3
27963: PUSH
27964: LD_INT 83
27966: PPUSH
27967: LD_VAR 0 1
27971: PPUSH
27972: CALL_OW 321
27976: PUSH
27977: LD_INT 2
27979: EQUAL
27980: ST_TO_ADDR
27981: GO 28083
27983: LD_INT 17
27985: DOUBLE
27986: EQUAL
27987: IFTRUE 27991
27989: GO 28016
27991: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
27992: LD_ADDR_VAR 0 3
27996: PUSH
27997: LD_INT 39
27999: PPUSH
28000: LD_VAR 0 1
28004: PPUSH
28005: CALL_OW 321
28009: PUSH
28010: LD_INT 2
28012: EQUAL
28013: ST_TO_ADDR
28014: GO 28083
28016: LD_INT 18
28018: DOUBLE
28019: EQUAL
28020: IFTRUE 28024
28022: GO 28049
28024: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
28025: LD_ADDR_VAR 0 3
28029: PUSH
28030: LD_INT 40
28032: PPUSH
28033: LD_VAR 0 1
28037: PPUSH
28038: CALL_OW 321
28042: PUSH
28043: LD_INT 2
28045: EQUAL
28046: ST_TO_ADDR
28047: GO 28083
28049: LD_INT 27
28051: DOUBLE
28052: EQUAL
28053: IFTRUE 28057
28055: GO 28082
28057: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
28058: LD_ADDR_VAR 0 3
28062: PUSH
28063: LD_INT 35
28065: PPUSH
28066: LD_VAR 0 1
28070: PPUSH
28071: CALL_OW 321
28075: PUSH
28076: LD_INT 2
28078: EQUAL
28079: ST_TO_ADDR
28080: GO 28083
28082: POP
// end ;
28083: LD_VAR 0 3
28087: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
28088: LD_INT 0
28090: PPUSH
28091: PPUSH
28092: PPUSH
28093: PPUSH
28094: PPUSH
28095: PPUSH
28096: PPUSH
28097: PPUSH
28098: PPUSH
28099: PPUSH
28100: PPUSH
// result := false ;
28101: LD_ADDR_VAR 0 6
28105: PUSH
28106: LD_INT 0
28108: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28109: LD_VAR 0 1
28113: NOT
28114: PUSH
28115: LD_VAR 0 1
28119: PPUSH
28120: CALL_OW 266
28124: PUSH
28125: LD_INT 0
28127: PUSH
28128: LD_INT 1
28130: PUSH
28131: EMPTY
28132: LIST
28133: LIST
28134: IN
28135: NOT
28136: OR
28137: PUSH
28138: LD_VAR 0 2
28142: NOT
28143: OR
28144: PUSH
28145: LD_VAR 0 5
28149: PUSH
28150: LD_INT 0
28152: PUSH
28153: LD_INT 1
28155: PUSH
28156: LD_INT 2
28158: PUSH
28159: LD_INT 3
28161: PUSH
28162: LD_INT 4
28164: PUSH
28165: LD_INT 5
28167: PUSH
28168: EMPTY
28169: LIST
28170: LIST
28171: LIST
28172: LIST
28173: LIST
28174: LIST
28175: IN
28176: NOT
28177: OR
28178: PUSH
28179: LD_VAR 0 3
28183: PPUSH
28184: LD_VAR 0 4
28188: PPUSH
28189: CALL_OW 488
28193: NOT
28194: OR
28195: IFFALSE 28199
// exit ;
28197: GO 28935
// side := GetSide ( depot ) ;
28199: LD_ADDR_VAR 0 9
28203: PUSH
28204: LD_VAR 0 1
28208: PPUSH
28209: CALL_OW 255
28213: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
28214: LD_VAR 0 9
28218: PPUSH
28219: LD_VAR 0 2
28223: PPUSH
28224: CALL 27712 0 2
28228: NOT
28229: IFFALSE 28233
// exit ;
28231: GO 28935
// pom := GetBase ( depot ) ;
28233: LD_ADDR_VAR 0 10
28237: PUSH
28238: LD_VAR 0 1
28242: PPUSH
28243: CALL_OW 274
28247: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28248: LD_ADDR_VAR 0 11
28252: PUSH
28253: LD_VAR 0 2
28257: PPUSH
28258: LD_VAR 0 1
28262: PPUSH
28263: CALL_OW 248
28267: PPUSH
28268: CALL_OW 450
28272: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28273: LD_VAR 0 10
28277: PPUSH
28278: LD_INT 1
28280: PPUSH
28281: CALL_OW 275
28285: PUSH
28286: LD_VAR 0 11
28290: PUSH
28291: LD_INT 1
28293: ARRAY
28294: GREATEREQUAL
28295: PUSH
28296: LD_VAR 0 10
28300: PPUSH
28301: LD_INT 2
28303: PPUSH
28304: CALL_OW 275
28308: PUSH
28309: LD_VAR 0 11
28313: PUSH
28314: LD_INT 2
28316: ARRAY
28317: GREATEREQUAL
28318: AND
28319: PUSH
28320: LD_VAR 0 10
28324: PPUSH
28325: LD_INT 3
28327: PPUSH
28328: CALL_OW 275
28332: PUSH
28333: LD_VAR 0 11
28337: PUSH
28338: LD_INT 3
28340: ARRAY
28341: GREATEREQUAL
28342: AND
28343: NOT
28344: IFFALSE 28348
// exit ;
28346: GO 28935
// if GetBType ( depot ) = b_depot then
28348: LD_VAR 0 1
28352: PPUSH
28353: CALL_OW 266
28357: PUSH
28358: LD_INT 0
28360: EQUAL
28361: IFFALSE 28373
// dist := 28 else
28363: LD_ADDR_VAR 0 14
28367: PUSH
28368: LD_INT 28
28370: ST_TO_ADDR
28371: GO 28381
// dist := 36 ;
28373: LD_ADDR_VAR 0 14
28377: PUSH
28378: LD_INT 36
28380: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28381: LD_VAR 0 1
28385: PPUSH
28386: LD_VAR 0 3
28390: PPUSH
28391: LD_VAR 0 4
28395: PPUSH
28396: CALL_OW 297
28400: PUSH
28401: LD_VAR 0 14
28405: GREATER
28406: IFFALSE 28410
// exit ;
28408: GO 28935
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28410: LD_ADDR_VAR 0 12
28414: PUSH
28415: LD_VAR 0 2
28419: PPUSH
28420: LD_VAR 0 3
28424: PPUSH
28425: LD_VAR 0 4
28429: PPUSH
28430: LD_VAR 0 5
28434: PPUSH
28435: LD_VAR 0 1
28439: PPUSH
28440: CALL_OW 248
28444: PPUSH
28445: LD_INT 0
28447: PPUSH
28448: CALL 28940 0 6
28452: ST_TO_ADDR
// if not hexes then
28453: LD_VAR 0 12
28457: NOT
28458: IFFALSE 28462
// exit ;
28460: GO 28935
// hex := GetHexInfo ( x , y ) ;
28462: LD_ADDR_VAR 0 15
28466: PUSH
28467: LD_VAR 0 3
28471: PPUSH
28472: LD_VAR 0 4
28476: PPUSH
28477: CALL_OW 546
28481: ST_TO_ADDR
// if hex [ 1 ] then
28482: LD_VAR 0 15
28486: PUSH
28487: LD_INT 1
28489: ARRAY
28490: IFFALSE 28494
// exit ;
28492: GO 28935
// height := hex [ 2 ] ;
28494: LD_ADDR_VAR 0 13
28498: PUSH
28499: LD_VAR 0 15
28503: PUSH
28504: LD_INT 2
28506: ARRAY
28507: ST_TO_ADDR
// for i = 1 to hexes do
28508: LD_ADDR_VAR 0 7
28512: PUSH
28513: DOUBLE
28514: LD_INT 1
28516: DEC
28517: ST_TO_ADDR
28518: LD_VAR 0 12
28522: PUSH
28523: FOR_TO
28524: IFFALSE 28854
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28526: LD_VAR 0 12
28530: PUSH
28531: LD_VAR 0 7
28535: ARRAY
28536: PUSH
28537: LD_INT 1
28539: ARRAY
28540: PPUSH
28541: LD_VAR 0 12
28545: PUSH
28546: LD_VAR 0 7
28550: ARRAY
28551: PUSH
28552: LD_INT 2
28554: ARRAY
28555: PPUSH
28556: CALL_OW 488
28560: NOT
28561: PUSH
28562: LD_VAR 0 12
28566: PUSH
28567: LD_VAR 0 7
28571: ARRAY
28572: PUSH
28573: LD_INT 1
28575: ARRAY
28576: PPUSH
28577: LD_VAR 0 12
28581: PUSH
28582: LD_VAR 0 7
28586: ARRAY
28587: PUSH
28588: LD_INT 2
28590: ARRAY
28591: PPUSH
28592: CALL_OW 428
28596: PUSH
28597: LD_INT 0
28599: GREATER
28600: OR
28601: PUSH
28602: LD_VAR 0 12
28606: PUSH
28607: LD_VAR 0 7
28611: ARRAY
28612: PUSH
28613: LD_INT 1
28615: ARRAY
28616: PPUSH
28617: LD_VAR 0 12
28621: PUSH
28622: LD_VAR 0 7
28626: ARRAY
28627: PUSH
28628: LD_INT 2
28630: ARRAY
28631: PPUSH
28632: CALL_OW 351
28636: OR
28637: IFFALSE 28643
// exit ;
28639: POP
28640: POP
28641: GO 28935
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28643: LD_ADDR_VAR 0 8
28647: PUSH
28648: LD_VAR 0 12
28652: PUSH
28653: LD_VAR 0 7
28657: ARRAY
28658: PUSH
28659: LD_INT 1
28661: ARRAY
28662: PPUSH
28663: LD_VAR 0 12
28667: PUSH
28668: LD_VAR 0 7
28672: ARRAY
28673: PUSH
28674: LD_INT 2
28676: ARRAY
28677: PPUSH
28678: CALL_OW 546
28682: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28683: LD_VAR 0 8
28687: PUSH
28688: LD_INT 1
28690: ARRAY
28691: PUSH
28692: LD_VAR 0 8
28696: PUSH
28697: LD_INT 2
28699: ARRAY
28700: PUSH
28701: LD_VAR 0 13
28705: PUSH
28706: LD_INT 2
28708: PLUS
28709: GREATER
28710: OR
28711: PUSH
28712: LD_VAR 0 8
28716: PUSH
28717: LD_INT 2
28719: ARRAY
28720: PUSH
28721: LD_VAR 0 13
28725: PUSH
28726: LD_INT 2
28728: MINUS
28729: LESS
28730: OR
28731: PUSH
28732: LD_VAR 0 8
28736: PUSH
28737: LD_INT 3
28739: ARRAY
28740: PUSH
28741: LD_INT 0
28743: PUSH
28744: LD_INT 8
28746: PUSH
28747: LD_INT 9
28749: PUSH
28750: LD_INT 10
28752: PUSH
28753: LD_INT 11
28755: PUSH
28756: LD_INT 12
28758: PUSH
28759: LD_INT 13
28761: PUSH
28762: LD_INT 16
28764: PUSH
28765: LD_INT 17
28767: PUSH
28768: LD_INT 18
28770: PUSH
28771: LD_INT 19
28773: PUSH
28774: LD_INT 20
28776: PUSH
28777: LD_INT 21
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: LIST
28784: LIST
28785: LIST
28786: LIST
28787: LIST
28788: LIST
28789: LIST
28790: LIST
28791: LIST
28792: LIST
28793: LIST
28794: IN
28795: NOT
28796: OR
28797: PUSH
28798: LD_VAR 0 8
28802: PUSH
28803: LD_INT 5
28805: ARRAY
28806: NOT
28807: OR
28808: PUSH
28809: LD_VAR 0 8
28813: PUSH
28814: LD_INT 6
28816: ARRAY
28817: PUSH
28818: LD_INT 1
28820: PUSH
28821: LD_INT 2
28823: PUSH
28824: LD_INT 7
28826: PUSH
28827: LD_INT 9
28829: PUSH
28830: LD_INT 10
28832: PUSH
28833: LD_INT 11
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: LIST
28840: LIST
28841: LIST
28842: LIST
28843: IN
28844: NOT
28845: OR
28846: IFFALSE 28852
// exit ;
28848: POP
28849: POP
28850: GO 28935
// end ;
28852: GO 28523
28854: POP
28855: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28856: LD_VAR 0 9
28860: PPUSH
28861: LD_VAR 0 3
28865: PPUSH
28866: LD_VAR 0 4
28870: PPUSH
28871: LD_INT 20
28873: PPUSH
28874: CALL 20887 0 4
28878: PUSH
28879: LD_INT 4
28881: ARRAY
28882: IFFALSE 28886
// exit ;
28884: GO 28935
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28886: LD_VAR 0 2
28890: PUSH
28891: LD_INT 29
28893: PUSH
28894: LD_INT 30
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: IN
28901: PUSH
28902: LD_VAR 0 3
28906: PPUSH
28907: LD_VAR 0 4
28911: PPUSH
28912: LD_VAR 0 9
28916: PPUSH
28917: CALL_OW 440
28921: NOT
28922: AND
28923: IFFALSE 28927
// exit ;
28925: GO 28935
// result := true ;
28927: LD_ADDR_VAR 0 6
28931: PUSH
28932: LD_INT 1
28934: ST_TO_ADDR
// end ;
28935: LD_VAR 0 6
28939: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
28940: LD_INT 0
28942: PPUSH
28943: PPUSH
28944: PPUSH
28945: PPUSH
28946: PPUSH
28947: PPUSH
28948: PPUSH
28949: PPUSH
28950: PPUSH
28951: PPUSH
28952: PPUSH
28953: PPUSH
28954: PPUSH
28955: PPUSH
28956: PPUSH
28957: PPUSH
28958: PPUSH
28959: PPUSH
28960: PPUSH
28961: PPUSH
28962: PPUSH
28963: PPUSH
28964: PPUSH
28965: PPUSH
28966: PPUSH
28967: PPUSH
28968: PPUSH
28969: PPUSH
28970: PPUSH
28971: PPUSH
28972: PPUSH
28973: PPUSH
28974: PPUSH
28975: PPUSH
28976: PPUSH
28977: PPUSH
28978: PPUSH
28979: PPUSH
28980: PPUSH
28981: PPUSH
28982: PPUSH
28983: PPUSH
28984: PPUSH
28985: PPUSH
28986: PPUSH
28987: PPUSH
28988: PPUSH
28989: PPUSH
28990: PPUSH
28991: PPUSH
28992: PPUSH
28993: PPUSH
28994: PPUSH
28995: PPUSH
28996: PPUSH
28997: PPUSH
28998: PPUSH
28999: PPUSH
// result = [ ] ;
29000: LD_ADDR_VAR 0 7
29004: PUSH
29005: EMPTY
29006: ST_TO_ADDR
// temp_list = [ ] ;
29007: LD_ADDR_VAR 0 9
29011: PUSH
29012: EMPTY
29013: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29014: LD_VAR 0 4
29018: PUSH
29019: LD_INT 0
29021: PUSH
29022: LD_INT 1
29024: PUSH
29025: LD_INT 2
29027: PUSH
29028: LD_INT 3
29030: PUSH
29031: LD_INT 4
29033: PUSH
29034: LD_INT 5
29036: PUSH
29037: EMPTY
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: IN
29045: NOT
29046: PUSH
29047: LD_VAR 0 1
29051: PUSH
29052: LD_INT 0
29054: PUSH
29055: LD_INT 1
29057: PUSH
29058: EMPTY
29059: LIST
29060: LIST
29061: IN
29062: PUSH
29063: LD_VAR 0 5
29067: PUSH
29068: LD_INT 1
29070: PUSH
29071: LD_INT 2
29073: PUSH
29074: LD_INT 3
29076: PUSH
29077: EMPTY
29078: LIST
29079: LIST
29080: LIST
29081: IN
29082: NOT
29083: AND
29084: OR
29085: IFFALSE 29089
// exit ;
29087: GO 47480
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29089: LD_VAR 0 1
29093: PUSH
29094: LD_INT 6
29096: PUSH
29097: LD_INT 7
29099: PUSH
29100: LD_INT 8
29102: PUSH
29103: LD_INT 13
29105: PUSH
29106: LD_INT 12
29108: PUSH
29109: LD_INT 15
29111: PUSH
29112: LD_INT 11
29114: PUSH
29115: LD_INT 14
29117: PUSH
29118: LD_INT 10
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: LIST
29125: LIST
29126: LIST
29127: LIST
29128: LIST
29129: LIST
29130: LIST
29131: IN
29132: IFFALSE 29142
// btype = b_lab ;
29134: LD_ADDR_VAR 0 1
29138: PUSH
29139: LD_INT 6
29141: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29142: LD_VAR 0 6
29146: PUSH
29147: LD_INT 0
29149: PUSH
29150: LD_INT 1
29152: PUSH
29153: LD_INT 2
29155: PUSH
29156: EMPTY
29157: LIST
29158: LIST
29159: LIST
29160: IN
29161: NOT
29162: PUSH
29163: LD_VAR 0 1
29167: PUSH
29168: LD_INT 0
29170: PUSH
29171: LD_INT 1
29173: PUSH
29174: LD_INT 2
29176: PUSH
29177: LD_INT 3
29179: PUSH
29180: LD_INT 6
29182: PUSH
29183: LD_INT 36
29185: PUSH
29186: LD_INT 4
29188: PUSH
29189: LD_INT 5
29191: PUSH
29192: LD_INT 31
29194: PUSH
29195: LD_INT 32
29197: PUSH
29198: LD_INT 33
29200: PUSH
29201: EMPTY
29202: LIST
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: IN
29214: NOT
29215: PUSH
29216: LD_VAR 0 6
29220: PUSH
29221: LD_INT 1
29223: EQUAL
29224: AND
29225: OR
29226: PUSH
29227: LD_VAR 0 1
29231: PUSH
29232: LD_INT 2
29234: PUSH
29235: LD_INT 3
29237: PUSH
29238: EMPTY
29239: LIST
29240: LIST
29241: IN
29242: NOT
29243: PUSH
29244: LD_VAR 0 6
29248: PUSH
29249: LD_INT 2
29251: EQUAL
29252: AND
29253: OR
29254: IFFALSE 29264
// mode = 0 ;
29256: LD_ADDR_VAR 0 6
29260: PUSH
29261: LD_INT 0
29263: ST_TO_ADDR
// case mode of 0 :
29264: LD_VAR 0 6
29268: PUSH
29269: LD_INT 0
29271: DOUBLE
29272: EQUAL
29273: IFTRUE 29277
29275: GO 40730
29277: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29278: LD_ADDR_VAR 0 11
29282: PUSH
29283: LD_INT 0
29285: PUSH
29286: LD_INT 0
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: LD_INT 0
29295: PUSH
29296: LD_INT 1
29298: NEG
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: PUSH
29304: LD_INT 1
29306: PUSH
29307: LD_INT 0
29309: PUSH
29310: EMPTY
29311: LIST
29312: LIST
29313: PUSH
29314: LD_INT 1
29316: PUSH
29317: LD_INT 1
29319: PUSH
29320: EMPTY
29321: LIST
29322: LIST
29323: PUSH
29324: LD_INT 0
29326: PUSH
29327: LD_INT 1
29329: PUSH
29330: EMPTY
29331: LIST
29332: LIST
29333: PUSH
29334: LD_INT 1
29336: NEG
29337: PUSH
29338: LD_INT 0
29340: PUSH
29341: EMPTY
29342: LIST
29343: LIST
29344: PUSH
29345: LD_INT 1
29347: NEG
29348: PUSH
29349: LD_INT 1
29351: NEG
29352: PUSH
29353: EMPTY
29354: LIST
29355: LIST
29356: PUSH
29357: LD_INT 1
29359: NEG
29360: PUSH
29361: LD_INT 2
29363: NEG
29364: PUSH
29365: EMPTY
29366: LIST
29367: LIST
29368: PUSH
29369: LD_INT 0
29371: PUSH
29372: LD_INT 2
29374: NEG
29375: PUSH
29376: EMPTY
29377: LIST
29378: LIST
29379: PUSH
29380: LD_INT 1
29382: PUSH
29383: LD_INT 1
29385: NEG
29386: PUSH
29387: EMPTY
29388: LIST
29389: LIST
29390: PUSH
29391: LD_INT 1
29393: PUSH
29394: LD_INT 2
29396: PUSH
29397: EMPTY
29398: LIST
29399: LIST
29400: PUSH
29401: LD_INT 0
29403: PUSH
29404: LD_INT 2
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: PUSH
29411: LD_INT 1
29413: NEG
29414: PUSH
29415: LD_INT 1
29417: PUSH
29418: EMPTY
29419: LIST
29420: LIST
29421: PUSH
29422: LD_INT 1
29424: PUSH
29425: LD_INT 3
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: LD_INT 0
29434: PUSH
29435: LD_INT 3
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: PUSH
29442: LD_INT 1
29444: NEG
29445: PUSH
29446: LD_INT 2
29448: PUSH
29449: EMPTY
29450: LIST
29451: LIST
29452: PUSH
29453: EMPTY
29454: LIST
29455: LIST
29456: LIST
29457: LIST
29458: LIST
29459: LIST
29460: LIST
29461: LIST
29462: LIST
29463: LIST
29464: LIST
29465: LIST
29466: LIST
29467: LIST
29468: LIST
29469: LIST
29470: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29471: LD_ADDR_VAR 0 12
29475: PUSH
29476: LD_INT 0
29478: PUSH
29479: LD_INT 0
29481: PUSH
29482: EMPTY
29483: LIST
29484: LIST
29485: PUSH
29486: LD_INT 0
29488: PUSH
29489: LD_INT 1
29491: NEG
29492: PUSH
29493: EMPTY
29494: LIST
29495: LIST
29496: PUSH
29497: LD_INT 1
29499: PUSH
29500: LD_INT 0
29502: PUSH
29503: EMPTY
29504: LIST
29505: LIST
29506: PUSH
29507: LD_INT 1
29509: PUSH
29510: LD_INT 1
29512: PUSH
29513: EMPTY
29514: LIST
29515: LIST
29516: PUSH
29517: LD_INT 0
29519: PUSH
29520: LD_INT 1
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: LD_INT 1
29529: NEG
29530: PUSH
29531: LD_INT 0
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: PUSH
29538: LD_INT 1
29540: NEG
29541: PUSH
29542: LD_INT 1
29544: NEG
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PUSH
29550: LD_INT 1
29552: PUSH
29553: LD_INT 1
29555: NEG
29556: PUSH
29557: EMPTY
29558: LIST
29559: LIST
29560: PUSH
29561: LD_INT 2
29563: PUSH
29564: LD_INT 0
29566: PUSH
29567: EMPTY
29568: LIST
29569: LIST
29570: PUSH
29571: LD_INT 2
29573: PUSH
29574: LD_INT 1
29576: PUSH
29577: EMPTY
29578: LIST
29579: LIST
29580: PUSH
29581: LD_INT 1
29583: NEG
29584: PUSH
29585: LD_INT 1
29587: PUSH
29588: EMPTY
29589: LIST
29590: LIST
29591: PUSH
29592: LD_INT 2
29594: NEG
29595: PUSH
29596: LD_INT 0
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: LD_INT 2
29605: NEG
29606: PUSH
29607: LD_INT 1
29609: NEG
29610: PUSH
29611: EMPTY
29612: LIST
29613: LIST
29614: PUSH
29615: LD_INT 2
29617: NEG
29618: PUSH
29619: LD_INT 1
29621: PUSH
29622: EMPTY
29623: LIST
29624: LIST
29625: PUSH
29626: LD_INT 3
29628: NEG
29629: PUSH
29630: LD_INT 0
29632: PUSH
29633: EMPTY
29634: LIST
29635: LIST
29636: PUSH
29637: LD_INT 3
29639: NEG
29640: PUSH
29641: LD_INT 1
29643: NEG
29644: PUSH
29645: EMPTY
29646: LIST
29647: LIST
29648: PUSH
29649: EMPTY
29650: LIST
29651: LIST
29652: LIST
29653: LIST
29654: LIST
29655: LIST
29656: LIST
29657: LIST
29658: LIST
29659: LIST
29660: LIST
29661: LIST
29662: LIST
29663: LIST
29664: LIST
29665: LIST
29666: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29667: LD_ADDR_VAR 0 13
29671: PUSH
29672: LD_INT 0
29674: PUSH
29675: LD_INT 0
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: PUSH
29682: LD_INT 0
29684: PUSH
29685: LD_INT 1
29687: NEG
29688: PUSH
29689: EMPTY
29690: LIST
29691: LIST
29692: PUSH
29693: LD_INT 1
29695: PUSH
29696: LD_INT 0
29698: PUSH
29699: EMPTY
29700: LIST
29701: LIST
29702: PUSH
29703: LD_INT 1
29705: PUSH
29706: LD_INT 1
29708: PUSH
29709: EMPTY
29710: LIST
29711: LIST
29712: PUSH
29713: LD_INT 0
29715: PUSH
29716: LD_INT 1
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: PUSH
29723: LD_INT 1
29725: NEG
29726: PUSH
29727: LD_INT 0
29729: PUSH
29730: EMPTY
29731: LIST
29732: LIST
29733: PUSH
29734: LD_INT 1
29736: NEG
29737: PUSH
29738: LD_INT 1
29740: NEG
29741: PUSH
29742: EMPTY
29743: LIST
29744: LIST
29745: PUSH
29746: LD_INT 1
29748: NEG
29749: PUSH
29750: LD_INT 2
29752: NEG
29753: PUSH
29754: EMPTY
29755: LIST
29756: LIST
29757: PUSH
29758: LD_INT 2
29760: PUSH
29761: LD_INT 1
29763: PUSH
29764: EMPTY
29765: LIST
29766: LIST
29767: PUSH
29768: LD_INT 2
29770: PUSH
29771: LD_INT 2
29773: PUSH
29774: EMPTY
29775: LIST
29776: LIST
29777: PUSH
29778: LD_INT 1
29780: PUSH
29781: LD_INT 2
29783: PUSH
29784: EMPTY
29785: LIST
29786: LIST
29787: PUSH
29788: LD_INT 2
29790: NEG
29791: PUSH
29792: LD_INT 1
29794: NEG
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: PUSH
29800: LD_INT 2
29802: NEG
29803: PUSH
29804: LD_INT 2
29806: NEG
29807: PUSH
29808: EMPTY
29809: LIST
29810: LIST
29811: PUSH
29812: LD_INT 2
29814: NEG
29815: PUSH
29816: LD_INT 3
29818: NEG
29819: PUSH
29820: EMPTY
29821: LIST
29822: LIST
29823: PUSH
29824: LD_INT 3
29826: NEG
29827: PUSH
29828: LD_INT 2
29830: NEG
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 3
29838: NEG
29839: PUSH
29840: LD_INT 3
29842: NEG
29843: PUSH
29844: EMPTY
29845: LIST
29846: LIST
29847: PUSH
29848: EMPTY
29849: LIST
29850: LIST
29851: LIST
29852: LIST
29853: LIST
29854: LIST
29855: LIST
29856: LIST
29857: LIST
29858: LIST
29859: LIST
29860: LIST
29861: LIST
29862: LIST
29863: LIST
29864: LIST
29865: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29866: LD_ADDR_VAR 0 14
29870: PUSH
29871: LD_INT 0
29873: PUSH
29874: LD_INT 0
29876: PUSH
29877: EMPTY
29878: LIST
29879: LIST
29880: PUSH
29881: LD_INT 0
29883: PUSH
29884: LD_INT 1
29886: NEG
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: LD_INT 1
29894: PUSH
29895: LD_INT 0
29897: PUSH
29898: EMPTY
29899: LIST
29900: LIST
29901: PUSH
29902: LD_INT 1
29904: PUSH
29905: LD_INT 1
29907: PUSH
29908: EMPTY
29909: LIST
29910: LIST
29911: PUSH
29912: LD_INT 0
29914: PUSH
29915: LD_INT 1
29917: PUSH
29918: EMPTY
29919: LIST
29920: LIST
29921: PUSH
29922: LD_INT 1
29924: NEG
29925: PUSH
29926: LD_INT 0
29928: PUSH
29929: EMPTY
29930: LIST
29931: LIST
29932: PUSH
29933: LD_INT 1
29935: NEG
29936: PUSH
29937: LD_INT 1
29939: NEG
29940: PUSH
29941: EMPTY
29942: LIST
29943: LIST
29944: PUSH
29945: LD_INT 1
29947: NEG
29948: PUSH
29949: LD_INT 2
29951: NEG
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PUSH
29957: LD_INT 0
29959: PUSH
29960: LD_INT 2
29962: NEG
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: LD_INT 1
29970: PUSH
29971: LD_INT 1
29973: NEG
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 1
29981: PUSH
29982: LD_INT 2
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: LD_INT 0
29991: PUSH
29992: LD_INT 2
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: PUSH
29999: LD_INT 1
30001: NEG
30002: PUSH
30003: LD_INT 1
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: PUSH
30010: LD_INT 1
30012: NEG
30013: PUSH
30014: LD_INT 3
30016: NEG
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PUSH
30022: LD_INT 0
30024: PUSH
30025: LD_INT 3
30027: NEG
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: LD_INT 1
30035: PUSH
30036: LD_INT 2
30038: NEG
30039: PUSH
30040: EMPTY
30041: LIST
30042: LIST
30043: PUSH
30044: EMPTY
30045: LIST
30046: LIST
30047: LIST
30048: LIST
30049: LIST
30050: LIST
30051: LIST
30052: LIST
30053: LIST
30054: LIST
30055: LIST
30056: LIST
30057: LIST
30058: LIST
30059: LIST
30060: LIST
30061: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30062: LD_ADDR_VAR 0 15
30066: PUSH
30067: LD_INT 0
30069: PUSH
30070: LD_INT 0
30072: PUSH
30073: EMPTY
30074: LIST
30075: LIST
30076: PUSH
30077: LD_INT 0
30079: PUSH
30080: LD_INT 1
30082: NEG
30083: PUSH
30084: EMPTY
30085: LIST
30086: LIST
30087: PUSH
30088: LD_INT 1
30090: PUSH
30091: LD_INT 0
30093: PUSH
30094: EMPTY
30095: LIST
30096: LIST
30097: PUSH
30098: LD_INT 1
30100: PUSH
30101: LD_INT 1
30103: PUSH
30104: EMPTY
30105: LIST
30106: LIST
30107: PUSH
30108: LD_INT 0
30110: PUSH
30111: LD_INT 1
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PUSH
30118: LD_INT 1
30120: NEG
30121: PUSH
30122: LD_INT 0
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: PUSH
30129: LD_INT 1
30131: NEG
30132: PUSH
30133: LD_INT 1
30135: NEG
30136: PUSH
30137: EMPTY
30138: LIST
30139: LIST
30140: PUSH
30141: LD_INT 1
30143: PUSH
30144: LD_INT 1
30146: NEG
30147: PUSH
30148: EMPTY
30149: LIST
30150: LIST
30151: PUSH
30152: LD_INT 2
30154: PUSH
30155: LD_INT 0
30157: PUSH
30158: EMPTY
30159: LIST
30160: LIST
30161: PUSH
30162: LD_INT 2
30164: PUSH
30165: LD_INT 1
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 1
30174: NEG
30175: PUSH
30176: LD_INT 1
30178: PUSH
30179: EMPTY
30180: LIST
30181: LIST
30182: PUSH
30183: LD_INT 2
30185: NEG
30186: PUSH
30187: LD_INT 0
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: PUSH
30194: LD_INT 2
30196: NEG
30197: PUSH
30198: LD_INT 1
30200: NEG
30201: PUSH
30202: EMPTY
30203: LIST
30204: LIST
30205: PUSH
30206: LD_INT 2
30208: PUSH
30209: LD_INT 1
30211: NEG
30212: PUSH
30213: EMPTY
30214: LIST
30215: LIST
30216: PUSH
30217: LD_INT 3
30219: PUSH
30220: LD_INT 0
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: PUSH
30227: LD_INT 3
30229: PUSH
30230: LD_INT 1
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: PUSH
30237: EMPTY
30238: LIST
30239: LIST
30240: LIST
30241: LIST
30242: LIST
30243: LIST
30244: LIST
30245: LIST
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: LIST
30253: LIST
30254: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30255: LD_ADDR_VAR 0 16
30259: PUSH
30260: LD_INT 0
30262: PUSH
30263: LD_INT 0
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 0
30272: PUSH
30273: LD_INT 1
30275: NEG
30276: PUSH
30277: EMPTY
30278: LIST
30279: LIST
30280: PUSH
30281: LD_INT 1
30283: PUSH
30284: LD_INT 0
30286: PUSH
30287: EMPTY
30288: LIST
30289: LIST
30290: PUSH
30291: LD_INT 1
30293: PUSH
30294: LD_INT 1
30296: PUSH
30297: EMPTY
30298: LIST
30299: LIST
30300: PUSH
30301: LD_INT 0
30303: PUSH
30304: LD_INT 1
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 1
30313: NEG
30314: PUSH
30315: LD_INT 0
30317: PUSH
30318: EMPTY
30319: LIST
30320: LIST
30321: PUSH
30322: LD_INT 1
30324: NEG
30325: PUSH
30326: LD_INT 1
30328: NEG
30329: PUSH
30330: EMPTY
30331: LIST
30332: LIST
30333: PUSH
30334: LD_INT 1
30336: NEG
30337: PUSH
30338: LD_INT 2
30340: NEG
30341: PUSH
30342: EMPTY
30343: LIST
30344: LIST
30345: PUSH
30346: LD_INT 2
30348: PUSH
30349: LD_INT 1
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: PUSH
30356: LD_INT 2
30358: PUSH
30359: LD_INT 2
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: LD_INT 1
30368: PUSH
30369: LD_INT 2
30371: PUSH
30372: EMPTY
30373: LIST
30374: LIST
30375: PUSH
30376: LD_INT 2
30378: NEG
30379: PUSH
30380: LD_INT 1
30382: NEG
30383: PUSH
30384: EMPTY
30385: LIST
30386: LIST
30387: PUSH
30388: LD_INT 2
30390: NEG
30391: PUSH
30392: LD_INT 2
30394: NEG
30395: PUSH
30396: EMPTY
30397: LIST
30398: LIST
30399: PUSH
30400: LD_INT 3
30402: PUSH
30403: LD_INT 2
30405: PUSH
30406: EMPTY
30407: LIST
30408: LIST
30409: PUSH
30410: LD_INT 3
30412: PUSH
30413: LD_INT 3
30415: PUSH
30416: EMPTY
30417: LIST
30418: LIST
30419: PUSH
30420: LD_INT 2
30422: PUSH
30423: LD_INT 3
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: LIST
30434: LIST
30435: LIST
30436: LIST
30437: LIST
30438: LIST
30439: LIST
30440: LIST
30441: LIST
30442: LIST
30443: LIST
30444: LIST
30445: LIST
30446: LIST
30447: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30448: LD_ADDR_VAR 0 17
30452: PUSH
30453: LD_INT 0
30455: PUSH
30456: LD_INT 0
30458: PUSH
30459: EMPTY
30460: LIST
30461: LIST
30462: PUSH
30463: LD_INT 0
30465: PUSH
30466: LD_INT 1
30468: NEG
30469: PUSH
30470: EMPTY
30471: LIST
30472: LIST
30473: PUSH
30474: LD_INT 1
30476: PUSH
30477: LD_INT 0
30479: PUSH
30480: EMPTY
30481: LIST
30482: LIST
30483: PUSH
30484: LD_INT 1
30486: PUSH
30487: LD_INT 1
30489: PUSH
30490: EMPTY
30491: LIST
30492: LIST
30493: PUSH
30494: LD_INT 0
30496: PUSH
30497: LD_INT 1
30499: PUSH
30500: EMPTY
30501: LIST
30502: LIST
30503: PUSH
30504: LD_INT 1
30506: NEG
30507: PUSH
30508: LD_INT 0
30510: PUSH
30511: EMPTY
30512: LIST
30513: LIST
30514: PUSH
30515: LD_INT 1
30517: NEG
30518: PUSH
30519: LD_INT 1
30521: NEG
30522: PUSH
30523: EMPTY
30524: LIST
30525: LIST
30526: PUSH
30527: LD_INT 1
30529: NEG
30530: PUSH
30531: LD_INT 2
30533: NEG
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PUSH
30539: LD_INT 0
30541: PUSH
30542: LD_INT 2
30544: NEG
30545: PUSH
30546: EMPTY
30547: LIST
30548: LIST
30549: PUSH
30550: LD_INT 1
30552: PUSH
30553: LD_INT 1
30555: NEG
30556: PUSH
30557: EMPTY
30558: LIST
30559: LIST
30560: PUSH
30561: LD_INT 2
30563: PUSH
30564: LD_INT 0
30566: PUSH
30567: EMPTY
30568: LIST
30569: LIST
30570: PUSH
30571: LD_INT 2
30573: PUSH
30574: LD_INT 1
30576: PUSH
30577: EMPTY
30578: LIST
30579: LIST
30580: PUSH
30581: LD_INT 2
30583: PUSH
30584: LD_INT 2
30586: PUSH
30587: EMPTY
30588: LIST
30589: LIST
30590: PUSH
30591: LD_INT 1
30593: PUSH
30594: LD_INT 2
30596: PUSH
30597: EMPTY
30598: LIST
30599: LIST
30600: PUSH
30601: LD_INT 0
30603: PUSH
30604: LD_INT 2
30606: PUSH
30607: EMPTY
30608: LIST
30609: LIST
30610: PUSH
30611: LD_INT 1
30613: NEG
30614: PUSH
30615: LD_INT 1
30617: PUSH
30618: EMPTY
30619: LIST
30620: LIST
30621: PUSH
30622: LD_INT 2
30624: NEG
30625: PUSH
30626: LD_INT 0
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: PUSH
30633: LD_INT 2
30635: NEG
30636: PUSH
30637: LD_INT 1
30639: NEG
30640: PUSH
30641: EMPTY
30642: LIST
30643: LIST
30644: PUSH
30645: LD_INT 2
30647: NEG
30648: PUSH
30649: LD_INT 2
30651: NEG
30652: PUSH
30653: EMPTY
30654: LIST
30655: LIST
30656: PUSH
30657: EMPTY
30658: LIST
30659: LIST
30660: LIST
30661: LIST
30662: LIST
30663: LIST
30664: LIST
30665: LIST
30666: LIST
30667: LIST
30668: LIST
30669: LIST
30670: LIST
30671: LIST
30672: LIST
30673: LIST
30674: LIST
30675: LIST
30676: LIST
30677: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30678: LD_ADDR_VAR 0 18
30682: PUSH
30683: LD_INT 0
30685: PUSH
30686: LD_INT 0
30688: PUSH
30689: EMPTY
30690: LIST
30691: LIST
30692: PUSH
30693: LD_INT 0
30695: PUSH
30696: LD_INT 1
30698: NEG
30699: PUSH
30700: EMPTY
30701: LIST
30702: LIST
30703: PUSH
30704: LD_INT 1
30706: PUSH
30707: LD_INT 0
30709: PUSH
30710: EMPTY
30711: LIST
30712: LIST
30713: PUSH
30714: LD_INT 1
30716: PUSH
30717: LD_INT 1
30719: PUSH
30720: EMPTY
30721: LIST
30722: LIST
30723: PUSH
30724: LD_INT 0
30726: PUSH
30727: LD_INT 1
30729: PUSH
30730: EMPTY
30731: LIST
30732: LIST
30733: PUSH
30734: LD_INT 1
30736: NEG
30737: PUSH
30738: LD_INT 0
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: LD_INT 1
30747: NEG
30748: PUSH
30749: LD_INT 1
30751: NEG
30752: PUSH
30753: EMPTY
30754: LIST
30755: LIST
30756: PUSH
30757: LD_INT 1
30759: NEG
30760: PUSH
30761: LD_INT 2
30763: NEG
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: PUSH
30769: LD_INT 0
30771: PUSH
30772: LD_INT 2
30774: NEG
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: LD_INT 1
30782: PUSH
30783: LD_INT 1
30785: NEG
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 2
30793: PUSH
30794: LD_INT 0
30796: PUSH
30797: EMPTY
30798: LIST
30799: LIST
30800: PUSH
30801: LD_INT 2
30803: PUSH
30804: LD_INT 1
30806: PUSH
30807: EMPTY
30808: LIST
30809: LIST
30810: PUSH
30811: LD_INT 2
30813: PUSH
30814: LD_INT 2
30816: PUSH
30817: EMPTY
30818: LIST
30819: LIST
30820: PUSH
30821: LD_INT 1
30823: PUSH
30824: LD_INT 2
30826: PUSH
30827: EMPTY
30828: LIST
30829: LIST
30830: PUSH
30831: LD_INT 0
30833: PUSH
30834: LD_INT 2
30836: PUSH
30837: EMPTY
30838: LIST
30839: LIST
30840: PUSH
30841: LD_INT 1
30843: NEG
30844: PUSH
30845: LD_INT 1
30847: PUSH
30848: EMPTY
30849: LIST
30850: LIST
30851: PUSH
30852: LD_INT 2
30854: NEG
30855: PUSH
30856: LD_INT 0
30858: PUSH
30859: EMPTY
30860: LIST
30861: LIST
30862: PUSH
30863: LD_INT 2
30865: NEG
30866: PUSH
30867: LD_INT 1
30869: NEG
30870: PUSH
30871: EMPTY
30872: LIST
30873: LIST
30874: PUSH
30875: LD_INT 2
30877: NEG
30878: PUSH
30879: LD_INT 2
30881: NEG
30882: PUSH
30883: EMPTY
30884: LIST
30885: LIST
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: LIST
30891: LIST
30892: LIST
30893: LIST
30894: LIST
30895: LIST
30896: LIST
30897: LIST
30898: LIST
30899: LIST
30900: LIST
30901: LIST
30902: LIST
30903: LIST
30904: LIST
30905: LIST
30906: LIST
30907: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30908: LD_ADDR_VAR 0 19
30912: PUSH
30913: LD_INT 0
30915: PUSH
30916: LD_INT 0
30918: PUSH
30919: EMPTY
30920: LIST
30921: LIST
30922: PUSH
30923: LD_INT 0
30925: PUSH
30926: LD_INT 1
30928: NEG
30929: PUSH
30930: EMPTY
30931: LIST
30932: LIST
30933: PUSH
30934: LD_INT 1
30936: PUSH
30937: LD_INT 0
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: LD_INT 1
30946: PUSH
30947: LD_INT 1
30949: PUSH
30950: EMPTY
30951: LIST
30952: LIST
30953: PUSH
30954: LD_INT 0
30956: PUSH
30957: LD_INT 1
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: PUSH
30964: LD_INT 1
30966: NEG
30967: PUSH
30968: LD_INT 0
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 1
30977: NEG
30978: PUSH
30979: LD_INT 1
30981: NEG
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PUSH
30987: LD_INT 1
30989: NEG
30990: PUSH
30991: LD_INT 2
30993: NEG
30994: PUSH
30995: EMPTY
30996: LIST
30997: LIST
30998: PUSH
30999: LD_INT 0
31001: PUSH
31002: LD_INT 2
31004: NEG
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PUSH
31010: LD_INT 1
31012: PUSH
31013: LD_INT 1
31015: NEG
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PUSH
31021: LD_INT 2
31023: PUSH
31024: LD_INT 0
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 2
31033: PUSH
31034: LD_INT 1
31036: PUSH
31037: EMPTY
31038: LIST
31039: LIST
31040: PUSH
31041: LD_INT 2
31043: PUSH
31044: LD_INT 2
31046: PUSH
31047: EMPTY
31048: LIST
31049: LIST
31050: PUSH
31051: LD_INT 1
31053: PUSH
31054: LD_INT 2
31056: PUSH
31057: EMPTY
31058: LIST
31059: LIST
31060: PUSH
31061: LD_INT 0
31063: PUSH
31064: LD_INT 2
31066: PUSH
31067: EMPTY
31068: LIST
31069: LIST
31070: PUSH
31071: LD_INT 1
31073: NEG
31074: PUSH
31075: LD_INT 1
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PUSH
31082: LD_INT 2
31084: NEG
31085: PUSH
31086: LD_INT 0
31088: PUSH
31089: EMPTY
31090: LIST
31091: LIST
31092: PUSH
31093: LD_INT 2
31095: NEG
31096: PUSH
31097: LD_INT 1
31099: NEG
31100: PUSH
31101: EMPTY
31102: LIST
31103: LIST
31104: PUSH
31105: LD_INT 2
31107: NEG
31108: PUSH
31109: LD_INT 2
31111: NEG
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: LIST
31121: LIST
31122: LIST
31123: LIST
31124: LIST
31125: LIST
31126: LIST
31127: LIST
31128: LIST
31129: LIST
31130: LIST
31131: LIST
31132: LIST
31133: LIST
31134: LIST
31135: LIST
31136: LIST
31137: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31138: LD_ADDR_VAR 0 20
31142: PUSH
31143: LD_INT 0
31145: PUSH
31146: LD_INT 0
31148: PUSH
31149: EMPTY
31150: LIST
31151: LIST
31152: PUSH
31153: LD_INT 0
31155: PUSH
31156: LD_INT 1
31158: NEG
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PUSH
31164: LD_INT 1
31166: PUSH
31167: LD_INT 0
31169: PUSH
31170: EMPTY
31171: LIST
31172: LIST
31173: PUSH
31174: LD_INT 1
31176: PUSH
31177: LD_INT 1
31179: PUSH
31180: EMPTY
31181: LIST
31182: LIST
31183: PUSH
31184: LD_INT 0
31186: PUSH
31187: LD_INT 1
31189: PUSH
31190: EMPTY
31191: LIST
31192: LIST
31193: PUSH
31194: LD_INT 1
31196: NEG
31197: PUSH
31198: LD_INT 0
31200: PUSH
31201: EMPTY
31202: LIST
31203: LIST
31204: PUSH
31205: LD_INT 1
31207: NEG
31208: PUSH
31209: LD_INT 1
31211: NEG
31212: PUSH
31213: EMPTY
31214: LIST
31215: LIST
31216: PUSH
31217: LD_INT 1
31219: NEG
31220: PUSH
31221: LD_INT 2
31223: NEG
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 0
31231: PUSH
31232: LD_INT 2
31234: NEG
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 1
31242: PUSH
31243: LD_INT 1
31245: NEG
31246: PUSH
31247: EMPTY
31248: LIST
31249: LIST
31250: PUSH
31251: LD_INT 2
31253: PUSH
31254: LD_INT 0
31256: PUSH
31257: EMPTY
31258: LIST
31259: LIST
31260: PUSH
31261: LD_INT 2
31263: PUSH
31264: LD_INT 1
31266: PUSH
31267: EMPTY
31268: LIST
31269: LIST
31270: PUSH
31271: LD_INT 2
31273: PUSH
31274: LD_INT 2
31276: PUSH
31277: EMPTY
31278: LIST
31279: LIST
31280: PUSH
31281: LD_INT 1
31283: PUSH
31284: LD_INT 2
31286: PUSH
31287: EMPTY
31288: LIST
31289: LIST
31290: PUSH
31291: LD_INT 0
31293: PUSH
31294: LD_INT 2
31296: PUSH
31297: EMPTY
31298: LIST
31299: LIST
31300: PUSH
31301: LD_INT 1
31303: NEG
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 2
31314: NEG
31315: PUSH
31316: LD_INT 0
31318: PUSH
31319: EMPTY
31320: LIST
31321: LIST
31322: PUSH
31323: LD_INT 2
31325: NEG
31326: PUSH
31327: LD_INT 1
31329: NEG
31330: PUSH
31331: EMPTY
31332: LIST
31333: LIST
31334: PUSH
31335: LD_INT 2
31337: NEG
31338: PUSH
31339: LD_INT 2
31341: NEG
31342: PUSH
31343: EMPTY
31344: LIST
31345: LIST
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: LIST
31351: LIST
31352: LIST
31353: LIST
31354: LIST
31355: LIST
31356: LIST
31357: LIST
31358: LIST
31359: LIST
31360: LIST
31361: LIST
31362: LIST
31363: LIST
31364: LIST
31365: LIST
31366: LIST
31367: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31368: LD_ADDR_VAR 0 21
31372: PUSH
31373: LD_INT 0
31375: PUSH
31376: LD_INT 0
31378: PUSH
31379: EMPTY
31380: LIST
31381: LIST
31382: PUSH
31383: LD_INT 0
31385: PUSH
31386: LD_INT 1
31388: NEG
31389: PUSH
31390: EMPTY
31391: LIST
31392: LIST
31393: PUSH
31394: LD_INT 1
31396: PUSH
31397: LD_INT 0
31399: PUSH
31400: EMPTY
31401: LIST
31402: LIST
31403: PUSH
31404: LD_INT 1
31406: PUSH
31407: LD_INT 1
31409: PUSH
31410: EMPTY
31411: LIST
31412: LIST
31413: PUSH
31414: LD_INT 0
31416: PUSH
31417: LD_INT 1
31419: PUSH
31420: EMPTY
31421: LIST
31422: LIST
31423: PUSH
31424: LD_INT 1
31426: NEG
31427: PUSH
31428: LD_INT 0
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: PUSH
31435: LD_INT 1
31437: NEG
31438: PUSH
31439: LD_INT 1
31441: NEG
31442: PUSH
31443: EMPTY
31444: LIST
31445: LIST
31446: PUSH
31447: LD_INT 1
31449: NEG
31450: PUSH
31451: LD_INT 2
31453: NEG
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: PUSH
31459: LD_INT 0
31461: PUSH
31462: LD_INT 2
31464: NEG
31465: PUSH
31466: EMPTY
31467: LIST
31468: LIST
31469: PUSH
31470: LD_INT 1
31472: PUSH
31473: LD_INT 1
31475: NEG
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: LD_INT 2
31483: PUSH
31484: LD_INT 0
31486: PUSH
31487: EMPTY
31488: LIST
31489: LIST
31490: PUSH
31491: LD_INT 2
31493: PUSH
31494: LD_INT 1
31496: PUSH
31497: EMPTY
31498: LIST
31499: LIST
31500: PUSH
31501: LD_INT 2
31503: PUSH
31504: LD_INT 2
31506: PUSH
31507: EMPTY
31508: LIST
31509: LIST
31510: PUSH
31511: LD_INT 1
31513: PUSH
31514: LD_INT 2
31516: PUSH
31517: EMPTY
31518: LIST
31519: LIST
31520: PUSH
31521: LD_INT 0
31523: PUSH
31524: LD_INT 2
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PUSH
31531: LD_INT 1
31533: NEG
31534: PUSH
31535: LD_INT 1
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: PUSH
31542: LD_INT 2
31544: NEG
31545: PUSH
31546: LD_INT 0
31548: PUSH
31549: EMPTY
31550: LIST
31551: LIST
31552: PUSH
31553: LD_INT 2
31555: NEG
31556: PUSH
31557: LD_INT 1
31559: NEG
31560: PUSH
31561: EMPTY
31562: LIST
31563: LIST
31564: PUSH
31565: LD_INT 2
31567: NEG
31568: PUSH
31569: LD_INT 2
31571: NEG
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: LIST
31581: LIST
31582: LIST
31583: LIST
31584: LIST
31585: LIST
31586: LIST
31587: LIST
31588: LIST
31589: LIST
31590: LIST
31591: LIST
31592: LIST
31593: LIST
31594: LIST
31595: LIST
31596: LIST
31597: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31598: LD_ADDR_VAR 0 22
31602: PUSH
31603: LD_INT 0
31605: PUSH
31606: LD_INT 0
31608: PUSH
31609: EMPTY
31610: LIST
31611: LIST
31612: PUSH
31613: LD_INT 0
31615: PUSH
31616: LD_INT 1
31618: NEG
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 1
31626: PUSH
31627: LD_INT 0
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: LD_INT 1
31636: PUSH
31637: LD_INT 1
31639: PUSH
31640: EMPTY
31641: LIST
31642: LIST
31643: PUSH
31644: LD_INT 0
31646: PUSH
31647: LD_INT 1
31649: PUSH
31650: EMPTY
31651: LIST
31652: LIST
31653: PUSH
31654: LD_INT 1
31656: NEG
31657: PUSH
31658: LD_INT 0
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PUSH
31665: LD_INT 1
31667: NEG
31668: PUSH
31669: LD_INT 1
31671: NEG
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: LD_INT 1
31679: NEG
31680: PUSH
31681: LD_INT 2
31683: NEG
31684: PUSH
31685: EMPTY
31686: LIST
31687: LIST
31688: PUSH
31689: LD_INT 0
31691: PUSH
31692: LD_INT 2
31694: NEG
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 1
31702: PUSH
31703: LD_INT 1
31705: NEG
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 2
31713: PUSH
31714: LD_INT 0
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 2
31723: PUSH
31724: LD_INT 1
31726: PUSH
31727: EMPTY
31728: LIST
31729: LIST
31730: PUSH
31731: LD_INT 2
31733: PUSH
31734: LD_INT 2
31736: PUSH
31737: EMPTY
31738: LIST
31739: LIST
31740: PUSH
31741: LD_INT 1
31743: PUSH
31744: LD_INT 2
31746: PUSH
31747: EMPTY
31748: LIST
31749: LIST
31750: PUSH
31751: LD_INT 0
31753: PUSH
31754: LD_INT 2
31756: PUSH
31757: EMPTY
31758: LIST
31759: LIST
31760: PUSH
31761: LD_INT 1
31763: NEG
31764: PUSH
31765: LD_INT 1
31767: PUSH
31768: EMPTY
31769: LIST
31770: LIST
31771: PUSH
31772: LD_INT 2
31774: NEG
31775: PUSH
31776: LD_INT 0
31778: PUSH
31779: EMPTY
31780: LIST
31781: LIST
31782: PUSH
31783: LD_INT 2
31785: NEG
31786: PUSH
31787: LD_INT 1
31789: NEG
31790: PUSH
31791: EMPTY
31792: LIST
31793: LIST
31794: PUSH
31795: LD_INT 2
31797: NEG
31798: PUSH
31799: LD_INT 2
31801: NEG
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: EMPTY
31808: LIST
31809: LIST
31810: LIST
31811: LIST
31812: LIST
31813: LIST
31814: LIST
31815: LIST
31816: LIST
31817: LIST
31818: LIST
31819: LIST
31820: LIST
31821: LIST
31822: LIST
31823: LIST
31824: LIST
31825: LIST
31826: LIST
31827: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31828: LD_ADDR_VAR 0 23
31832: PUSH
31833: LD_INT 0
31835: PUSH
31836: LD_INT 0
31838: PUSH
31839: EMPTY
31840: LIST
31841: LIST
31842: PUSH
31843: LD_INT 0
31845: PUSH
31846: LD_INT 1
31848: NEG
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 1
31856: PUSH
31857: LD_INT 0
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PUSH
31864: LD_INT 1
31866: PUSH
31867: LD_INT 1
31869: PUSH
31870: EMPTY
31871: LIST
31872: LIST
31873: PUSH
31874: LD_INT 0
31876: PUSH
31877: LD_INT 1
31879: PUSH
31880: EMPTY
31881: LIST
31882: LIST
31883: PUSH
31884: LD_INT 1
31886: NEG
31887: PUSH
31888: LD_INT 0
31890: PUSH
31891: EMPTY
31892: LIST
31893: LIST
31894: PUSH
31895: LD_INT 1
31897: NEG
31898: PUSH
31899: LD_INT 1
31901: NEG
31902: PUSH
31903: EMPTY
31904: LIST
31905: LIST
31906: PUSH
31907: LD_INT 1
31909: NEG
31910: PUSH
31911: LD_INT 2
31913: NEG
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: PUSH
31919: LD_INT 0
31921: PUSH
31922: LD_INT 2
31924: NEG
31925: PUSH
31926: EMPTY
31927: LIST
31928: LIST
31929: PUSH
31930: LD_INT 1
31932: PUSH
31933: LD_INT 1
31935: NEG
31936: PUSH
31937: EMPTY
31938: LIST
31939: LIST
31940: PUSH
31941: LD_INT 2
31943: PUSH
31944: LD_INT 0
31946: PUSH
31947: EMPTY
31948: LIST
31949: LIST
31950: PUSH
31951: LD_INT 2
31953: PUSH
31954: LD_INT 1
31956: PUSH
31957: EMPTY
31958: LIST
31959: LIST
31960: PUSH
31961: LD_INT 2
31963: PUSH
31964: LD_INT 2
31966: PUSH
31967: EMPTY
31968: LIST
31969: LIST
31970: PUSH
31971: LD_INT 1
31973: PUSH
31974: LD_INT 2
31976: PUSH
31977: EMPTY
31978: LIST
31979: LIST
31980: PUSH
31981: LD_INT 0
31983: PUSH
31984: LD_INT 2
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: LD_INT 1
31993: NEG
31994: PUSH
31995: LD_INT 1
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: PUSH
32002: LD_INT 2
32004: NEG
32005: PUSH
32006: LD_INT 0
32008: PUSH
32009: EMPTY
32010: LIST
32011: LIST
32012: PUSH
32013: LD_INT 2
32015: NEG
32016: PUSH
32017: LD_INT 1
32019: NEG
32020: PUSH
32021: EMPTY
32022: LIST
32023: LIST
32024: PUSH
32025: LD_INT 2
32027: NEG
32028: PUSH
32029: LD_INT 2
32031: NEG
32032: PUSH
32033: EMPTY
32034: LIST
32035: LIST
32036: PUSH
32037: LD_INT 2
32039: NEG
32040: PUSH
32041: LD_INT 3
32043: NEG
32044: PUSH
32045: EMPTY
32046: LIST
32047: LIST
32048: PUSH
32049: LD_INT 1
32051: NEG
32052: PUSH
32053: LD_INT 3
32055: NEG
32056: PUSH
32057: EMPTY
32058: LIST
32059: LIST
32060: PUSH
32061: LD_INT 1
32063: PUSH
32064: LD_INT 2
32066: NEG
32067: PUSH
32068: EMPTY
32069: LIST
32070: LIST
32071: PUSH
32072: LD_INT 2
32074: PUSH
32075: LD_INT 1
32077: NEG
32078: PUSH
32079: EMPTY
32080: LIST
32081: LIST
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: LIST
32087: LIST
32088: LIST
32089: LIST
32090: LIST
32091: LIST
32092: LIST
32093: LIST
32094: LIST
32095: LIST
32096: LIST
32097: LIST
32098: LIST
32099: LIST
32100: LIST
32101: LIST
32102: LIST
32103: LIST
32104: LIST
32105: LIST
32106: LIST
32107: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32108: LD_ADDR_VAR 0 24
32112: PUSH
32113: LD_INT 0
32115: PUSH
32116: LD_INT 0
32118: PUSH
32119: EMPTY
32120: LIST
32121: LIST
32122: PUSH
32123: LD_INT 0
32125: PUSH
32126: LD_INT 1
32128: NEG
32129: PUSH
32130: EMPTY
32131: LIST
32132: LIST
32133: PUSH
32134: LD_INT 1
32136: PUSH
32137: LD_INT 0
32139: PUSH
32140: EMPTY
32141: LIST
32142: LIST
32143: PUSH
32144: LD_INT 1
32146: PUSH
32147: LD_INT 1
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: LD_INT 0
32156: PUSH
32157: LD_INT 1
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: LD_INT 1
32166: NEG
32167: PUSH
32168: LD_INT 0
32170: PUSH
32171: EMPTY
32172: LIST
32173: LIST
32174: PUSH
32175: LD_INT 1
32177: NEG
32178: PUSH
32179: LD_INT 1
32181: NEG
32182: PUSH
32183: EMPTY
32184: LIST
32185: LIST
32186: PUSH
32187: LD_INT 1
32189: NEG
32190: PUSH
32191: LD_INT 2
32193: NEG
32194: PUSH
32195: EMPTY
32196: LIST
32197: LIST
32198: PUSH
32199: LD_INT 0
32201: PUSH
32202: LD_INT 2
32204: NEG
32205: PUSH
32206: EMPTY
32207: LIST
32208: LIST
32209: PUSH
32210: LD_INT 1
32212: PUSH
32213: LD_INT 1
32215: NEG
32216: PUSH
32217: EMPTY
32218: LIST
32219: LIST
32220: PUSH
32221: LD_INT 2
32223: PUSH
32224: LD_INT 0
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 2
32233: PUSH
32234: LD_INT 1
32236: PUSH
32237: EMPTY
32238: LIST
32239: LIST
32240: PUSH
32241: LD_INT 2
32243: PUSH
32244: LD_INT 2
32246: PUSH
32247: EMPTY
32248: LIST
32249: LIST
32250: PUSH
32251: LD_INT 1
32253: PUSH
32254: LD_INT 2
32256: PUSH
32257: EMPTY
32258: LIST
32259: LIST
32260: PUSH
32261: LD_INT 0
32263: PUSH
32264: LD_INT 2
32266: PUSH
32267: EMPTY
32268: LIST
32269: LIST
32270: PUSH
32271: LD_INT 1
32273: NEG
32274: PUSH
32275: LD_INT 1
32277: PUSH
32278: EMPTY
32279: LIST
32280: LIST
32281: PUSH
32282: LD_INT 2
32284: NEG
32285: PUSH
32286: LD_INT 0
32288: PUSH
32289: EMPTY
32290: LIST
32291: LIST
32292: PUSH
32293: LD_INT 2
32295: NEG
32296: PUSH
32297: LD_INT 1
32299: NEG
32300: PUSH
32301: EMPTY
32302: LIST
32303: LIST
32304: PUSH
32305: LD_INT 2
32307: NEG
32308: PUSH
32309: LD_INT 2
32311: NEG
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: PUSH
32317: LD_INT 1
32319: PUSH
32320: LD_INT 2
32322: NEG
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: PUSH
32328: LD_INT 2
32330: PUSH
32331: LD_INT 1
32333: NEG
32334: PUSH
32335: EMPTY
32336: LIST
32337: LIST
32338: PUSH
32339: LD_INT 3
32341: PUSH
32342: LD_INT 1
32344: PUSH
32345: EMPTY
32346: LIST
32347: LIST
32348: PUSH
32349: LD_INT 3
32351: PUSH
32352: LD_INT 2
32354: PUSH
32355: EMPTY
32356: LIST
32357: LIST
32358: PUSH
32359: EMPTY
32360: LIST
32361: LIST
32362: LIST
32363: LIST
32364: LIST
32365: LIST
32366: LIST
32367: LIST
32368: LIST
32369: LIST
32370: LIST
32371: LIST
32372: LIST
32373: LIST
32374: LIST
32375: LIST
32376: LIST
32377: LIST
32378: LIST
32379: LIST
32380: LIST
32381: LIST
32382: LIST
32383: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32384: LD_ADDR_VAR 0 25
32388: PUSH
32389: LD_INT 0
32391: PUSH
32392: LD_INT 0
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: PUSH
32399: LD_INT 0
32401: PUSH
32402: LD_INT 1
32404: NEG
32405: PUSH
32406: EMPTY
32407: LIST
32408: LIST
32409: PUSH
32410: LD_INT 1
32412: PUSH
32413: LD_INT 0
32415: PUSH
32416: EMPTY
32417: LIST
32418: LIST
32419: PUSH
32420: LD_INT 1
32422: PUSH
32423: LD_INT 1
32425: PUSH
32426: EMPTY
32427: LIST
32428: LIST
32429: PUSH
32430: LD_INT 0
32432: PUSH
32433: LD_INT 1
32435: PUSH
32436: EMPTY
32437: LIST
32438: LIST
32439: PUSH
32440: LD_INT 1
32442: NEG
32443: PUSH
32444: LD_INT 0
32446: PUSH
32447: EMPTY
32448: LIST
32449: LIST
32450: PUSH
32451: LD_INT 1
32453: NEG
32454: PUSH
32455: LD_INT 1
32457: NEG
32458: PUSH
32459: EMPTY
32460: LIST
32461: LIST
32462: PUSH
32463: LD_INT 1
32465: NEG
32466: PUSH
32467: LD_INT 2
32469: NEG
32470: PUSH
32471: EMPTY
32472: LIST
32473: LIST
32474: PUSH
32475: LD_INT 0
32477: PUSH
32478: LD_INT 2
32480: NEG
32481: PUSH
32482: EMPTY
32483: LIST
32484: LIST
32485: PUSH
32486: LD_INT 1
32488: PUSH
32489: LD_INT 1
32491: NEG
32492: PUSH
32493: EMPTY
32494: LIST
32495: LIST
32496: PUSH
32497: LD_INT 2
32499: PUSH
32500: LD_INT 0
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 2
32509: PUSH
32510: LD_INT 1
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: PUSH
32517: LD_INT 2
32519: PUSH
32520: LD_INT 2
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PUSH
32527: LD_INT 1
32529: PUSH
32530: LD_INT 2
32532: PUSH
32533: EMPTY
32534: LIST
32535: LIST
32536: PUSH
32537: LD_INT 0
32539: PUSH
32540: LD_INT 2
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PUSH
32547: LD_INT 1
32549: NEG
32550: PUSH
32551: LD_INT 1
32553: PUSH
32554: EMPTY
32555: LIST
32556: LIST
32557: PUSH
32558: LD_INT 2
32560: NEG
32561: PUSH
32562: LD_INT 0
32564: PUSH
32565: EMPTY
32566: LIST
32567: LIST
32568: PUSH
32569: LD_INT 2
32571: NEG
32572: PUSH
32573: LD_INT 1
32575: NEG
32576: PUSH
32577: EMPTY
32578: LIST
32579: LIST
32580: PUSH
32581: LD_INT 2
32583: NEG
32584: PUSH
32585: LD_INT 2
32587: NEG
32588: PUSH
32589: EMPTY
32590: LIST
32591: LIST
32592: PUSH
32593: LD_INT 3
32595: PUSH
32596: LD_INT 1
32598: PUSH
32599: EMPTY
32600: LIST
32601: LIST
32602: PUSH
32603: LD_INT 3
32605: PUSH
32606: LD_INT 2
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: LD_INT 2
32615: PUSH
32616: LD_INT 3
32618: PUSH
32619: EMPTY
32620: LIST
32621: LIST
32622: PUSH
32623: LD_INT 1
32625: PUSH
32626: LD_INT 3
32628: PUSH
32629: EMPTY
32630: LIST
32631: LIST
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: LIST
32637: LIST
32638: LIST
32639: LIST
32640: LIST
32641: LIST
32642: LIST
32643: LIST
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: LIST
32657: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32658: LD_ADDR_VAR 0 26
32662: PUSH
32663: LD_INT 0
32665: PUSH
32666: LD_INT 0
32668: PUSH
32669: EMPTY
32670: LIST
32671: LIST
32672: PUSH
32673: LD_INT 0
32675: PUSH
32676: LD_INT 1
32678: NEG
32679: PUSH
32680: EMPTY
32681: LIST
32682: LIST
32683: PUSH
32684: LD_INT 1
32686: PUSH
32687: LD_INT 0
32689: PUSH
32690: EMPTY
32691: LIST
32692: LIST
32693: PUSH
32694: LD_INT 1
32696: PUSH
32697: LD_INT 1
32699: PUSH
32700: EMPTY
32701: LIST
32702: LIST
32703: PUSH
32704: LD_INT 0
32706: PUSH
32707: LD_INT 1
32709: PUSH
32710: EMPTY
32711: LIST
32712: LIST
32713: PUSH
32714: LD_INT 1
32716: NEG
32717: PUSH
32718: LD_INT 0
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PUSH
32725: LD_INT 1
32727: NEG
32728: PUSH
32729: LD_INT 1
32731: NEG
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: LD_INT 1
32739: NEG
32740: PUSH
32741: LD_INT 2
32743: NEG
32744: PUSH
32745: EMPTY
32746: LIST
32747: LIST
32748: PUSH
32749: LD_INT 0
32751: PUSH
32752: LD_INT 2
32754: NEG
32755: PUSH
32756: EMPTY
32757: LIST
32758: LIST
32759: PUSH
32760: LD_INT 1
32762: PUSH
32763: LD_INT 1
32765: NEG
32766: PUSH
32767: EMPTY
32768: LIST
32769: LIST
32770: PUSH
32771: LD_INT 2
32773: PUSH
32774: LD_INT 0
32776: PUSH
32777: EMPTY
32778: LIST
32779: LIST
32780: PUSH
32781: LD_INT 2
32783: PUSH
32784: LD_INT 1
32786: PUSH
32787: EMPTY
32788: LIST
32789: LIST
32790: PUSH
32791: LD_INT 2
32793: PUSH
32794: LD_INT 2
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PUSH
32801: LD_INT 1
32803: PUSH
32804: LD_INT 2
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: PUSH
32811: LD_INT 0
32813: PUSH
32814: LD_INT 2
32816: PUSH
32817: EMPTY
32818: LIST
32819: LIST
32820: PUSH
32821: LD_INT 1
32823: NEG
32824: PUSH
32825: LD_INT 1
32827: PUSH
32828: EMPTY
32829: LIST
32830: LIST
32831: PUSH
32832: LD_INT 2
32834: NEG
32835: PUSH
32836: LD_INT 0
32838: PUSH
32839: EMPTY
32840: LIST
32841: LIST
32842: PUSH
32843: LD_INT 2
32845: NEG
32846: PUSH
32847: LD_INT 1
32849: NEG
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: PUSH
32855: LD_INT 2
32857: NEG
32858: PUSH
32859: LD_INT 2
32861: NEG
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PUSH
32867: LD_INT 2
32869: PUSH
32870: LD_INT 3
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PUSH
32877: LD_INT 1
32879: PUSH
32880: LD_INT 3
32882: PUSH
32883: EMPTY
32884: LIST
32885: LIST
32886: PUSH
32887: LD_INT 1
32889: NEG
32890: PUSH
32891: LD_INT 2
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: PUSH
32898: LD_INT 2
32900: NEG
32901: PUSH
32902: LD_INT 1
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: EMPTY
32910: LIST
32911: LIST
32912: LIST
32913: LIST
32914: LIST
32915: LIST
32916: LIST
32917: LIST
32918: LIST
32919: LIST
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32934: LD_ADDR_VAR 0 27
32938: PUSH
32939: LD_INT 0
32941: PUSH
32942: LD_INT 0
32944: PUSH
32945: EMPTY
32946: LIST
32947: LIST
32948: PUSH
32949: LD_INT 0
32951: PUSH
32952: LD_INT 1
32954: NEG
32955: PUSH
32956: EMPTY
32957: LIST
32958: LIST
32959: PUSH
32960: LD_INT 1
32962: PUSH
32963: LD_INT 0
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 1
32972: PUSH
32973: LD_INT 1
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: LD_INT 0
32982: PUSH
32983: LD_INT 1
32985: PUSH
32986: EMPTY
32987: LIST
32988: LIST
32989: PUSH
32990: LD_INT 1
32992: NEG
32993: PUSH
32994: LD_INT 0
32996: PUSH
32997: EMPTY
32998: LIST
32999: LIST
33000: PUSH
33001: LD_INT 1
33003: NEG
33004: PUSH
33005: LD_INT 1
33007: NEG
33008: PUSH
33009: EMPTY
33010: LIST
33011: LIST
33012: PUSH
33013: LD_INT 1
33015: NEG
33016: PUSH
33017: LD_INT 2
33019: NEG
33020: PUSH
33021: EMPTY
33022: LIST
33023: LIST
33024: PUSH
33025: LD_INT 0
33027: PUSH
33028: LD_INT 2
33030: NEG
33031: PUSH
33032: EMPTY
33033: LIST
33034: LIST
33035: PUSH
33036: LD_INT 1
33038: PUSH
33039: LD_INT 1
33041: NEG
33042: PUSH
33043: EMPTY
33044: LIST
33045: LIST
33046: PUSH
33047: LD_INT 2
33049: PUSH
33050: LD_INT 0
33052: PUSH
33053: EMPTY
33054: LIST
33055: LIST
33056: PUSH
33057: LD_INT 2
33059: PUSH
33060: LD_INT 1
33062: PUSH
33063: EMPTY
33064: LIST
33065: LIST
33066: PUSH
33067: LD_INT 2
33069: PUSH
33070: LD_INT 2
33072: PUSH
33073: EMPTY
33074: LIST
33075: LIST
33076: PUSH
33077: LD_INT 1
33079: PUSH
33080: LD_INT 2
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 0
33089: PUSH
33090: LD_INT 2
33092: PUSH
33093: EMPTY
33094: LIST
33095: LIST
33096: PUSH
33097: LD_INT 1
33099: NEG
33100: PUSH
33101: LD_INT 1
33103: PUSH
33104: EMPTY
33105: LIST
33106: LIST
33107: PUSH
33108: LD_INT 2
33110: NEG
33111: PUSH
33112: LD_INT 0
33114: PUSH
33115: EMPTY
33116: LIST
33117: LIST
33118: PUSH
33119: LD_INT 2
33121: NEG
33122: PUSH
33123: LD_INT 1
33125: NEG
33126: PUSH
33127: EMPTY
33128: LIST
33129: LIST
33130: PUSH
33131: LD_INT 2
33133: NEG
33134: PUSH
33135: LD_INT 2
33137: NEG
33138: PUSH
33139: EMPTY
33140: LIST
33141: LIST
33142: PUSH
33143: LD_INT 1
33145: NEG
33146: PUSH
33147: LD_INT 2
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: PUSH
33154: LD_INT 2
33156: NEG
33157: PUSH
33158: LD_INT 1
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: PUSH
33165: LD_INT 3
33167: NEG
33168: PUSH
33169: LD_INT 1
33171: NEG
33172: PUSH
33173: EMPTY
33174: LIST
33175: LIST
33176: PUSH
33177: LD_INT 3
33179: NEG
33180: PUSH
33181: LD_INT 2
33183: NEG
33184: PUSH
33185: EMPTY
33186: LIST
33187: LIST
33188: PUSH
33189: EMPTY
33190: LIST
33191: LIST
33192: LIST
33193: LIST
33194: LIST
33195: LIST
33196: LIST
33197: LIST
33198: LIST
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: LIST
33212: LIST
33213: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33214: LD_ADDR_VAR 0 28
33218: PUSH
33219: LD_INT 0
33221: PUSH
33222: LD_INT 0
33224: PUSH
33225: EMPTY
33226: LIST
33227: LIST
33228: PUSH
33229: LD_INT 0
33231: PUSH
33232: LD_INT 1
33234: NEG
33235: PUSH
33236: EMPTY
33237: LIST
33238: LIST
33239: PUSH
33240: LD_INT 1
33242: PUSH
33243: LD_INT 0
33245: PUSH
33246: EMPTY
33247: LIST
33248: LIST
33249: PUSH
33250: LD_INT 1
33252: PUSH
33253: LD_INT 1
33255: PUSH
33256: EMPTY
33257: LIST
33258: LIST
33259: PUSH
33260: LD_INT 0
33262: PUSH
33263: LD_INT 1
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: LD_INT 1
33272: NEG
33273: PUSH
33274: LD_INT 0
33276: PUSH
33277: EMPTY
33278: LIST
33279: LIST
33280: PUSH
33281: LD_INT 1
33283: NEG
33284: PUSH
33285: LD_INT 1
33287: NEG
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PUSH
33293: LD_INT 1
33295: NEG
33296: PUSH
33297: LD_INT 2
33299: NEG
33300: PUSH
33301: EMPTY
33302: LIST
33303: LIST
33304: PUSH
33305: LD_INT 0
33307: PUSH
33308: LD_INT 2
33310: NEG
33311: PUSH
33312: EMPTY
33313: LIST
33314: LIST
33315: PUSH
33316: LD_INT 1
33318: PUSH
33319: LD_INT 1
33321: NEG
33322: PUSH
33323: EMPTY
33324: LIST
33325: LIST
33326: PUSH
33327: LD_INT 2
33329: PUSH
33330: LD_INT 0
33332: PUSH
33333: EMPTY
33334: LIST
33335: LIST
33336: PUSH
33337: LD_INT 2
33339: PUSH
33340: LD_INT 1
33342: PUSH
33343: EMPTY
33344: LIST
33345: LIST
33346: PUSH
33347: LD_INT 2
33349: PUSH
33350: LD_INT 2
33352: PUSH
33353: EMPTY
33354: LIST
33355: LIST
33356: PUSH
33357: LD_INT 1
33359: PUSH
33360: LD_INT 2
33362: PUSH
33363: EMPTY
33364: LIST
33365: LIST
33366: PUSH
33367: LD_INT 0
33369: PUSH
33370: LD_INT 2
33372: PUSH
33373: EMPTY
33374: LIST
33375: LIST
33376: PUSH
33377: LD_INT 1
33379: NEG
33380: PUSH
33381: LD_INT 1
33383: PUSH
33384: EMPTY
33385: LIST
33386: LIST
33387: PUSH
33388: LD_INT 2
33390: NEG
33391: PUSH
33392: LD_INT 0
33394: PUSH
33395: EMPTY
33396: LIST
33397: LIST
33398: PUSH
33399: LD_INT 2
33401: NEG
33402: PUSH
33403: LD_INT 1
33405: NEG
33406: PUSH
33407: EMPTY
33408: LIST
33409: LIST
33410: PUSH
33411: LD_INT 2
33413: NEG
33414: PUSH
33415: LD_INT 2
33417: NEG
33418: PUSH
33419: EMPTY
33420: LIST
33421: LIST
33422: PUSH
33423: LD_INT 2
33425: NEG
33426: PUSH
33427: LD_INT 3
33429: NEG
33430: PUSH
33431: EMPTY
33432: LIST
33433: LIST
33434: PUSH
33435: LD_INT 1
33437: NEG
33438: PUSH
33439: LD_INT 3
33441: NEG
33442: PUSH
33443: EMPTY
33444: LIST
33445: LIST
33446: PUSH
33447: LD_INT 3
33449: NEG
33450: PUSH
33451: LD_INT 1
33453: NEG
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PUSH
33459: LD_INT 3
33461: NEG
33462: PUSH
33463: LD_INT 2
33465: NEG
33466: PUSH
33467: EMPTY
33468: LIST
33469: LIST
33470: PUSH
33471: EMPTY
33472: LIST
33473: LIST
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: LIST
33486: LIST
33487: LIST
33488: LIST
33489: LIST
33490: LIST
33491: LIST
33492: LIST
33493: LIST
33494: LIST
33495: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33496: LD_ADDR_VAR 0 29
33500: PUSH
33501: LD_INT 0
33503: PUSH
33504: LD_INT 0
33506: PUSH
33507: EMPTY
33508: LIST
33509: LIST
33510: PUSH
33511: LD_INT 0
33513: PUSH
33514: LD_INT 1
33516: NEG
33517: PUSH
33518: EMPTY
33519: LIST
33520: LIST
33521: PUSH
33522: LD_INT 1
33524: PUSH
33525: LD_INT 0
33527: PUSH
33528: EMPTY
33529: LIST
33530: LIST
33531: PUSH
33532: LD_INT 1
33534: PUSH
33535: LD_INT 1
33537: PUSH
33538: EMPTY
33539: LIST
33540: LIST
33541: PUSH
33542: LD_INT 0
33544: PUSH
33545: LD_INT 1
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PUSH
33552: LD_INT 1
33554: NEG
33555: PUSH
33556: LD_INT 0
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PUSH
33563: LD_INT 1
33565: NEG
33566: PUSH
33567: LD_INT 1
33569: NEG
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: LD_INT 1
33577: NEG
33578: PUSH
33579: LD_INT 2
33581: NEG
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: LD_INT 0
33589: PUSH
33590: LD_INT 2
33592: NEG
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 1
33600: PUSH
33601: LD_INT 1
33603: NEG
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 2
33611: PUSH
33612: LD_INT 0
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 2
33621: PUSH
33622: LD_INT 1
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 1
33631: PUSH
33632: LD_INT 2
33634: PUSH
33635: EMPTY
33636: LIST
33637: LIST
33638: PUSH
33639: LD_INT 0
33641: PUSH
33642: LD_INT 2
33644: PUSH
33645: EMPTY
33646: LIST
33647: LIST
33648: PUSH
33649: LD_INT 1
33651: NEG
33652: PUSH
33653: LD_INT 1
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 2
33662: NEG
33663: PUSH
33664: LD_INT 1
33666: NEG
33667: PUSH
33668: EMPTY
33669: LIST
33670: LIST
33671: PUSH
33672: LD_INT 2
33674: NEG
33675: PUSH
33676: LD_INT 2
33678: NEG
33679: PUSH
33680: EMPTY
33681: LIST
33682: LIST
33683: PUSH
33684: LD_INT 2
33686: NEG
33687: PUSH
33688: LD_INT 3
33690: NEG
33691: PUSH
33692: EMPTY
33693: LIST
33694: LIST
33695: PUSH
33696: LD_INT 2
33698: PUSH
33699: LD_INT 1
33701: NEG
33702: PUSH
33703: EMPTY
33704: LIST
33705: LIST
33706: PUSH
33707: LD_INT 3
33709: PUSH
33710: LD_INT 1
33712: PUSH
33713: EMPTY
33714: LIST
33715: LIST
33716: PUSH
33717: LD_INT 1
33719: PUSH
33720: LD_INT 3
33722: PUSH
33723: EMPTY
33724: LIST
33725: LIST
33726: PUSH
33727: LD_INT 1
33729: NEG
33730: PUSH
33731: LD_INT 2
33733: PUSH
33734: EMPTY
33735: LIST
33736: LIST
33737: PUSH
33738: LD_INT 3
33740: NEG
33741: PUSH
33742: LD_INT 2
33744: NEG
33745: PUSH
33746: EMPTY
33747: LIST
33748: LIST
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: LIST
33754: LIST
33755: LIST
33756: LIST
33757: LIST
33758: LIST
33759: LIST
33760: LIST
33761: LIST
33762: LIST
33763: LIST
33764: LIST
33765: LIST
33766: LIST
33767: LIST
33768: LIST
33769: LIST
33770: LIST
33771: LIST
33772: LIST
33773: LIST
33774: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33775: LD_ADDR_VAR 0 30
33779: PUSH
33780: LD_INT 0
33782: PUSH
33783: LD_INT 0
33785: PUSH
33786: EMPTY
33787: LIST
33788: LIST
33789: PUSH
33790: LD_INT 0
33792: PUSH
33793: LD_INT 1
33795: NEG
33796: PUSH
33797: EMPTY
33798: LIST
33799: LIST
33800: PUSH
33801: LD_INT 1
33803: PUSH
33804: LD_INT 0
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 1
33813: PUSH
33814: LD_INT 1
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: LD_INT 0
33823: PUSH
33824: LD_INT 1
33826: PUSH
33827: EMPTY
33828: LIST
33829: LIST
33830: PUSH
33831: LD_INT 1
33833: NEG
33834: PUSH
33835: LD_INT 0
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PUSH
33842: LD_INT 1
33844: NEG
33845: PUSH
33846: LD_INT 1
33848: NEG
33849: PUSH
33850: EMPTY
33851: LIST
33852: LIST
33853: PUSH
33854: LD_INT 1
33856: NEG
33857: PUSH
33858: LD_INT 2
33860: NEG
33861: PUSH
33862: EMPTY
33863: LIST
33864: LIST
33865: PUSH
33866: LD_INT 0
33868: PUSH
33869: LD_INT 2
33871: NEG
33872: PUSH
33873: EMPTY
33874: LIST
33875: LIST
33876: PUSH
33877: LD_INT 1
33879: PUSH
33880: LD_INT 1
33882: NEG
33883: PUSH
33884: EMPTY
33885: LIST
33886: LIST
33887: PUSH
33888: LD_INT 2
33890: PUSH
33891: LD_INT 0
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: PUSH
33898: LD_INT 2
33900: PUSH
33901: LD_INT 1
33903: PUSH
33904: EMPTY
33905: LIST
33906: LIST
33907: PUSH
33908: LD_INT 2
33910: PUSH
33911: LD_INT 2
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 1
33920: PUSH
33921: LD_INT 2
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: NEG
33931: PUSH
33932: LD_INT 1
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: LD_INT 2
33941: NEG
33942: PUSH
33943: LD_INT 0
33945: PUSH
33946: EMPTY
33947: LIST
33948: LIST
33949: PUSH
33950: LD_INT 2
33952: NEG
33953: PUSH
33954: LD_INT 1
33956: NEG
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 1
33964: NEG
33965: PUSH
33966: LD_INT 3
33968: NEG
33969: PUSH
33970: EMPTY
33971: LIST
33972: LIST
33973: PUSH
33974: LD_INT 1
33976: PUSH
33977: LD_INT 2
33979: NEG
33980: PUSH
33981: EMPTY
33982: LIST
33983: LIST
33984: PUSH
33985: LD_INT 3
33987: PUSH
33988: LD_INT 2
33990: PUSH
33991: EMPTY
33992: LIST
33993: LIST
33994: PUSH
33995: LD_INT 2
33997: PUSH
33998: LD_INT 3
34000: PUSH
34001: EMPTY
34002: LIST
34003: LIST
34004: PUSH
34005: LD_INT 2
34007: NEG
34008: PUSH
34009: LD_INT 1
34011: PUSH
34012: EMPTY
34013: LIST
34014: LIST
34015: PUSH
34016: LD_INT 3
34018: NEG
34019: PUSH
34020: LD_INT 1
34022: NEG
34023: PUSH
34024: EMPTY
34025: LIST
34026: LIST
34027: PUSH
34028: EMPTY
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34053: LD_ADDR_VAR 0 31
34057: PUSH
34058: LD_INT 0
34060: PUSH
34061: LD_INT 0
34063: PUSH
34064: EMPTY
34065: LIST
34066: LIST
34067: PUSH
34068: LD_INT 0
34070: PUSH
34071: LD_INT 1
34073: NEG
34074: PUSH
34075: EMPTY
34076: LIST
34077: LIST
34078: PUSH
34079: LD_INT 1
34081: PUSH
34082: LD_INT 0
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 1
34091: PUSH
34092: LD_INT 1
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 0
34101: PUSH
34102: LD_INT 1
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: PUSH
34109: LD_INT 1
34111: NEG
34112: PUSH
34113: LD_INT 0
34115: PUSH
34116: EMPTY
34117: LIST
34118: LIST
34119: PUSH
34120: LD_INT 1
34122: NEG
34123: PUSH
34124: LD_INT 1
34126: NEG
34127: PUSH
34128: EMPTY
34129: LIST
34130: LIST
34131: PUSH
34132: LD_INT 1
34134: NEG
34135: PUSH
34136: LD_INT 2
34138: NEG
34139: PUSH
34140: EMPTY
34141: LIST
34142: LIST
34143: PUSH
34144: LD_INT 1
34146: PUSH
34147: LD_INT 1
34149: NEG
34150: PUSH
34151: EMPTY
34152: LIST
34153: LIST
34154: PUSH
34155: LD_INT 2
34157: PUSH
34158: LD_INT 0
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PUSH
34165: LD_INT 2
34167: PUSH
34168: LD_INT 1
34170: PUSH
34171: EMPTY
34172: LIST
34173: LIST
34174: PUSH
34175: LD_INT 2
34177: PUSH
34178: LD_INT 2
34180: PUSH
34181: EMPTY
34182: LIST
34183: LIST
34184: PUSH
34185: LD_INT 1
34187: PUSH
34188: LD_INT 2
34190: PUSH
34191: EMPTY
34192: LIST
34193: LIST
34194: PUSH
34195: LD_INT 0
34197: PUSH
34198: LD_INT 2
34200: PUSH
34201: EMPTY
34202: LIST
34203: LIST
34204: PUSH
34205: LD_INT 1
34207: NEG
34208: PUSH
34209: LD_INT 1
34211: PUSH
34212: EMPTY
34213: LIST
34214: LIST
34215: PUSH
34216: LD_INT 2
34218: NEG
34219: PUSH
34220: LD_INT 1
34222: NEG
34223: PUSH
34224: EMPTY
34225: LIST
34226: LIST
34227: PUSH
34228: LD_INT 2
34230: NEG
34231: PUSH
34232: LD_INT 2
34234: NEG
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: PUSH
34240: LD_INT 2
34242: NEG
34243: PUSH
34244: LD_INT 3
34246: NEG
34247: PUSH
34248: EMPTY
34249: LIST
34250: LIST
34251: PUSH
34252: LD_INT 2
34254: PUSH
34255: LD_INT 1
34257: NEG
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: PUSH
34263: LD_INT 3
34265: PUSH
34266: LD_INT 1
34268: PUSH
34269: EMPTY
34270: LIST
34271: LIST
34272: PUSH
34273: LD_INT 1
34275: PUSH
34276: LD_INT 3
34278: PUSH
34279: EMPTY
34280: LIST
34281: LIST
34282: PUSH
34283: LD_INT 1
34285: NEG
34286: PUSH
34287: LD_INT 2
34289: PUSH
34290: EMPTY
34291: LIST
34292: LIST
34293: PUSH
34294: LD_INT 3
34296: NEG
34297: PUSH
34298: LD_INT 2
34300: NEG
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PUSH
34306: EMPTY
34307: LIST
34308: LIST
34309: LIST
34310: LIST
34311: LIST
34312: LIST
34313: LIST
34314: LIST
34315: LIST
34316: LIST
34317: LIST
34318: LIST
34319: LIST
34320: LIST
34321: LIST
34322: LIST
34323: LIST
34324: LIST
34325: LIST
34326: LIST
34327: LIST
34328: LIST
34329: LIST
34330: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34331: LD_ADDR_VAR 0 32
34335: PUSH
34336: LD_INT 0
34338: PUSH
34339: LD_INT 0
34341: PUSH
34342: EMPTY
34343: LIST
34344: LIST
34345: PUSH
34346: LD_INT 0
34348: PUSH
34349: LD_INT 1
34351: NEG
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 1
34359: PUSH
34360: LD_INT 0
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: LD_INT 1
34369: PUSH
34370: LD_INT 1
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 0
34379: PUSH
34380: LD_INT 1
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: NEG
34390: PUSH
34391: LD_INT 0
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 1
34400: NEG
34401: PUSH
34402: LD_INT 1
34404: NEG
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 1
34412: NEG
34413: PUSH
34414: LD_INT 2
34416: NEG
34417: PUSH
34418: EMPTY
34419: LIST
34420: LIST
34421: PUSH
34422: LD_INT 0
34424: PUSH
34425: LD_INT 2
34427: NEG
34428: PUSH
34429: EMPTY
34430: LIST
34431: LIST
34432: PUSH
34433: LD_INT 1
34435: PUSH
34436: LD_INT 1
34438: NEG
34439: PUSH
34440: EMPTY
34441: LIST
34442: LIST
34443: PUSH
34444: LD_INT 2
34446: PUSH
34447: LD_INT 1
34449: PUSH
34450: EMPTY
34451: LIST
34452: LIST
34453: PUSH
34454: LD_INT 2
34456: PUSH
34457: LD_INT 2
34459: PUSH
34460: EMPTY
34461: LIST
34462: LIST
34463: PUSH
34464: LD_INT 1
34466: PUSH
34467: LD_INT 2
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 0
34476: PUSH
34477: LD_INT 2
34479: PUSH
34480: EMPTY
34481: LIST
34482: LIST
34483: PUSH
34484: LD_INT 1
34486: NEG
34487: PUSH
34488: LD_INT 1
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 2
34497: NEG
34498: PUSH
34499: LD_INT 0
34501: PUSH
34502: EMPTY
34503: LIST
34504: LIST
34505: PUSH
34506: LD_INT 2
34508: NEG
34509: PUSH
34510: LD_INT 1
34512: NEG
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: LD_INT 1
34520: NEG
34521: PUSH
34522: LD_INT 3
34524: NEG
34525: PUSH
34526: EMPTY
34527: LIST
34528: LIST
34529: PUSH
34530: LD_INT 1
34532: PUSH
34533: LD_INT 2
34535: NEG
34536: PUSH
34537: EMPTY
34538: LIST
34539: LIST
34540: PUSH
34541: LD_INT 3
34543: PUSH
34544: LD_INT 2
34546: PUSH
34547: EMPTY
34548: LIST
34549: LIST
34550: PUSH
34551: LD_INT 2
34553: PUSH
34554: LD_INT 3
34556: PUSH
34557: EMPTY
34558: LIST
34559: LIST
34560: PUSH
34561: LD_INT 2
34563: NEG
34564: PUSH
34565: LD_INT 1
34567: PUSH
34568: EMPTY
34569: LIST
34570: LIST
34571: PUSH
34572: LD_INT 3
34574: NEG
34575: PUSH
34576: LD_INT 1
34578: NEG
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: EMPTY
34585: LIST
34586: LIST
34587: LIST
34588: LIST
34589: LIST
34590: LIST
34591: LIST
34592: LIST
34593: LIST
34594: LIST
34595: LIST
34596: LIST
34597: LIST
34598: LIST
34599: LIST
34600: LIST
34601: LIST
34602: LIST
34603: LIST
34604: LIST
34605: LIST
34606: LIST
34607: LIST
34608: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34609: LD_ADDR_VAR 0 33
34613: PUSH
34614: LD_INT 0
34616: PUSH
34617: LD_INT 0
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 0
34626: PUSH
34627: LD_INT 1
34629: NEG
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 1
34637: PUSH
34638: LD_INT 0
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 1
34647: PUSH
34648: LD_INT 1
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: LD_INT 0
34657: PUSH
34658: LD_INT 1
34660: PUSH
34661: EMPTY
34662: LIST
34663: LIST
34664: PUSH
34665: LD_INT 1
34667: NEG
34668: PUSH
34669: LD_INT 0
34671: PUSH
34672: EMPTY
34673: LIST
34674: LIST
34675: PUSH
34676: LD_INT 1
34678: NEG
34679: PUSH
34680: LD_INT 1
34682: NEG
34683: PUSH
34684: EMPTY
34685: LIST
34686: LIST
34687: PUSH
34688: LD_INT 1
34690: NEG
34691: PUSH
34692: LD_INT 2
34694: NEG
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 1
34702: PUSH
34703: LD_INT 1
34705: NEG
34706: PUSH
34707: EMPTY
34708: LIST
34709: LIST
34710: PUSH
34711: LD_INT 2
34713: PUSH
34714: LD_INT 0
34716: PUSH
34717: EMPTY
34718: LIST
34719: LIST
34720: PUSH
34721: LD_INT 2
34723: PUSH
34724: LD_INT 1
34726: PUSH
34727: EMPTY
34728: LIST
34729: LIST
34730: PUSH
34731: LD_INT 1
34733: PUSH
34734: LD_INT 2
34736: PUSH
34737: EMPTY
34738: LIST
34739: LIST
34740: PUSH
34741: LD_INT 0
34743: PUSH
34744: LD_INT 2
34746: PUSH
34747: EMPTY
34748: LIST
34749: LIST
34750: PUSH
34751: LD_INT 1
34753: NEG
34754: PUSH
34755: LD_INT 1
34757: PUSH
34758: EMPTY
34759: LIST
34760: LIST
34761: PUSH
34762: LD_INT 2
34764: NEG
34765: PUSH
34766: LD_INT 0
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 2
34775: NEG
34776: PUSH
34777: LD_INT 1
34779: NEG
34780: PUSH
34781: EMPTY
34782: LIST
34783: LIST
34784: PUSH
34785: LD_INT 2
34787: NEG
34788: PUSH
34789: LD_INT 2
34791: NEG
34792: PUSH
34793: EMPTY
34794: LIST
34795: LIST
34796: PUSH
34797: LD_INT 2
34799: NEG
34800: PUSH
34801: LD_INT 3
34803: NEG
34804: PUSH
34805: EMPTY
34806: LIST
34807: LIST
34808: PUSH
34809: LD_INT 2
34811: PUSH
34812: LD_INT 1
34814: NEG
34815: PUSH
34816: EMPTY
34817: LIST
34818: LIST
34819: PUSH
34820: LD_INT 3
34822: PUSH
34823: LD_INT 1
34825: PUSH
34826: EMPTY
34827: LIST
34828: LIST
34829: PUSH
34830: LD_INT 1
34832: PUSH
34833: LD_INT 3
34835: PUSH
34836: EMPTY
34837: LIST
34838: LIST
34839: PUSH
34840: LD_INT 1
34842: NEG
34843: PUSH
34844: LD_INT 2
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 3
34853: NEG
34854: PUSH
34855: LD_INT 2
34857: NEG
34858: PUSH
34859: EMPTY
34860: LIST
34861: LIST
34862: PUSH
34863: EMPTY
34864: LIST
34865: LIST
34866: LIST
34867: LIST
34868: LIST
34869: LIST
34870: LIST
34871: LIST
34872: LIST
34873: LIST
34874: LIST
34875: LIST
34876: LIST
34877: LIST
34878: LIST
34879: LIST
34880: LIST
34881: LIST
34882: LIST
34883: LIST
34884: LIST
34885: LIST
34886: LIST
34887: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34888: LD_ADDR_VAR 0 34
34892: PUSH
34893: LD_INT 0
34895: PUSH
34896: LD_INT 0
34898: PUSH
34899: EMPTY
34900: LIST
34901: LIST
34902: PUSH
34903: LD_INT 0
34905: PUSH
34906: LD_INT 1
34908: NEG
34909: PUSH
34910: EMPTY
34911: LIST
34912: LIST
34913: PUSH
34914: LD_INT 1
34916: PUSH
34917: LD_INT 0
34919: PUSH
34920: EMPTY
34921: LIST
34922: LIST
34923: PUSH
34924: LD_INT 1
34926: PUSH
34927: LD_INT 1
34929: PUSH
34930: EMPTY
34931: LIST
34932: LIST
34933: PUSH
34934: LD_INT 0
34936: PUSH
34937: LD_INT 1
34939: PUSH
34940: EMPTY
34941: LIST
34942: LIST
34943: PUSH
34944: LD_INT 1
34946: NEG
34947: PUSH
34948: LD_INT 0
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 1
34957: NEG
34958: PUSH
34959: LD_INT 1
34961: NEG
34962: PUSH
34963: EMPTY
34964: LIST
34965: LIST
34966: PUSH
34967: LD_INT 1
34969: NEG
34970: PUSH
34971: LD_INT 2
34973: NEG
34974: PUSH
34975: EMPTY
34976: LIST
34977: LIST
34978: PUSH
34979: LD_INT 0
34981: PUSH
34982: LD_INT 2
34984: NEG
34985: PUSH
34986: EMPTY
34987: LIST
34988: LIST
34989: PUSH
34990: LD_INT 1
34992: PUSH
34993: LD_INT 1
34995: NEG
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: LD_INT 2
35003: PUSH
35004: LD_INT 1
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 2
35013: PUSH
35014: LD_INT 2
35016: PUSH
35017: EMPTY
35018: LIST
35019: LIST
35020: PUSH
35021: LD_INT 1
35023: PUSH
35024: LD_INT 2
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: LD_INT 1
35033: NEG
35034: PUSH
35035: LD_INT 1
35037: PUSH
35038: EMPTY
35039: LIST
35040: LIST
35041: PUSH
35042: LD_INT 2
35044: NEG
35045: PUSH
35046: LD_INT 0
35048: PUSH
35049: EMPTY
35050: LIST
35051: LIST
35052: PUSH
35053: LD_INT 2
35055: NEG
35056: PUSH
35057: LD_INT 1
35059: NEG
35060: PUSH
35061: EMPTY
35062: LIST
35063: LIST
35064: PUSH
35065: LD_INT 2
35067: NEG
35068: PUSH
35069: LD_INT 2
35071: NEG
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 1
35079: NEG
35080: PUSH
35081: LD_INT 3
35083: NEG
35084: PUSH
35085: EMPTY
35086: LIST
35087: LIST
35088: PUSH
35089: LD_INT 1
35091: PUSH
35092: LD_INT 2
35094: NEG
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 3
35102: PUSH
35103: LD_INT 2
35105: PUSH
35106: EMPTY
35107: LIST
35108: LIST
35109: PUSH
35110: LD_INT 2
35112: PUSH
35113: LD_INT 3
35115: PUSH
35116: EMPTY
35117: LIST
35118: LIST
35119: PUSH
35120: LD_INT 2
35122: NEG
35123: PUSH
35124: LD_INT 1
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: LD_INT 3
35133: NEG
35134: PUSH
35135: LD_INT 1
35137: NEG
35138: PUSH
35139: EMPTY
35140: LIST
35141: LIST
35142: PUSH
35143: EMPTY
35144: LIST
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: LIST
35150: LIST
35151: LIST
35152: LIST
35153: LIST
35154: LIST
35155: LIST
35156: LIST
35157: LIST
35158: LIST
35159: LIST
35160: LIST
35161: LIST
35162: LIST
35163: LIST
35164: LIST
35165: LIST
35166: LIST
35167: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35168: LD_ADDR_VAR 0 35
35172: PUSH
35173: LD_INT 0
35175: PUSH
35176: LD_INT 0
35178: PUSH
35179: EMPTY
35180: LIST
35181: LIST
35182: PUSH
35183: LD_INT 0
35185: PUSH
35186: LD_INT 1
35188: NEG
35189: PUSH
35190: EMPTY
35191: LIST
35192: LIST
35193: PUSH
35194: LD_INT 1
35196: PUSH
35197: LD_INT 0
35199: PUSH
35200: EMPTY
35201: LIST
35202: LIST
35203: PUSH
35204: LD_INT 1
35206: PUSH
35207: LD_INT 1
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: PUSH
35214: LD_INT 0
35216: PUSH
35217: LD_INT 1
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 1
35226: NEG
35227: PUSH
35228: LD_INT 0
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: PUSH
35235: LD_INT 1
35237: NEG
35238: PUSH
35239: LD_INT 1
35241: NEG
35242: PUSH
35243: EMPTY
35244: LIST
35245: LIST
35246: PUSH
35247: LD_INT 2
35249: PUSH
35250: LD_INT 1
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 2
35259: NEG
35260: PUSH
35261: LD_INT 1
35263: NEG
35264: PUSH
35265: EMPTY
35266: LIST
35267: LIST
35268: PUSH
35269: EMPTY
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35280: LD_ADDR_VAR 0 36
35284: PUSH
35285: LD_INT 0
35287: PUSH
35288: LD_INT 0
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 0
35297: PUSH
35298: LD_INT 1
35300: NEG
35301: PUSH
35302: EMPTY
35303: LIST
35304: LIST
35305: PUSH
35306: LD_INT 1
35308: PUSH
35309: LD_INT 0
35311: PUSH
35312: EMPTY
35313: LIST
35314: LIST
35315: PUSH
35316: LD_INT 1
35318: PUSH
35319: LD_INT 1
35321: PUSH
35322: EMPTY
35323: LIST
35324: LIST
35325: PUSH
35326: LD_INT 0
35328: PUSH
35329: LD_INT 1
35331: PUSH
35332: EMPTY
35333: LIST
35334: LIST
35335: PUSH
35336: LD_INT 1
35338: NEG
35339: PUSH
35340: LD_INT 0
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 1
35349: NEG
35350: PUSH
35351: LD_INT 1
35353: NEG
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: PUSH
35359: LD_INT 1
35361: NEG
35362: PUSH
35363: LD_INT 2
35365: NEG
35366: PUSH
35367: EMPTY
35368: LIST
35369: LIST
35370: PUSH
35371: LD_INT 1
35373: PUSH
35374: LD_INT 2
35376: PUSH
35377: EMPTY
35378: LIST
35379: LIST
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: LIST
35385: LIST
35386: LIST
35387: LIST
35388: LIST
35389: LIST
35390: LIST
35391: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35392: LD_ADDR_VAR 0 37
35396: PUSH
35397: LD_INT 0
35399: PUSH
35400: LD_INT 0
35402: PUSH
35403: EMPTY
35404: LIST
35405: LIST
35406: PUSH
35407: LD_INT 0
35409: PUSH
35410: LD_INT 1
35412: NEG
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: LD_INT 1
35420: PUSH
35421: LD_INT 0
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: PUSH
35428: LD_INT 1
35430: PUSH
35431: LD_INT 1
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: LD_INT 0
35440: PUSH
35441: LD_INT 1
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 1
35450: NEG
35451: PUSH
35452: LD_INT 0
35454: PUSH
35455: EMPTY
35456: LIST
35457: LIST
35458: PUSH
35459: LD_INT 1
35461: NEG
35462: PUSH
35463: LD_INT 1
35465: NEG
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: LD_INT 1
35473: PUSH
35474: LD_INT 1
35476: NEG
35477: PUSH
35478: EMPTY
35479: LIST
35480: LIST
35481: PUSH
35482: LD_INT 1
35484: NEG
35485: PUSH
35486: LD_INT 1
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: LIST
35497: LIST
35498: LIST
35499: LIST
35500: LIST
35501: LIST
35502: LIST
35503: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35504: LD_ADDR_VAR 0 38
35508: PUSH
35509: LD_INT 0
35511: PUSH
35512: LD_INT 0
35514: PUSH
35515: EMPTY
35516: LIST
35517: LIST
35518: PUSH
35519: LD_INT 0
35521: PUSH
35522: LD_INT 1
35524: NEG
35525: PUSH
35526: EMPTY
35527: LIST
35528: LIST
35529: PUSH
35530: LD_INT 1
35532: PUSH
35533: LD_INT 0
35535: PUSH
35536: EMPTY
35537: LIST
35538: LIST
35539: PUSH
35540: LD_INT 1
35542: PUSH
35543: LD_INT 1
35545: PUSH
35546: EMPTY
35547: LIST
35548: LIST
35549: PUSH
35550: LD_INT 0
35552: PUSH
35553: LD_INT 1
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: LD_INT 1
35562: NEG
35563: PUSH
35564: LD_INT 0
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: PUSH
35571: LD_INT 1
35573: NEG
35574: PUSH
35575: LD_INT 1
35577: NEG
35578: PUSH
35579: EMPTY
35580: LIST
35581: LIST
35582: PUSH
35583: LD_INT 2
35585: PUSH
35586: LD_INT 1
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: LD_INT 2
35595: NEG
35596: PUSH
35597: LD_INT 1
35599: NEG
35600: PUSH
35601: EMPTY
35602: LIST
35603: LIST
35604: PUSH
35605: EMPTY
35606: LIST
35607: LIST
35608: LIST
35609: LIST
35610: LIST
35611: LIST
35612: LIST
35613: LIST
35614: LIST
35615: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35616: LD_ADDR_VAR 0 39
35620: PUSH
35621: LD_INT 0
35623: PUSH
35624: LD_INT 0
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: LD_INT 0
35633: PUSH
35634: LD_INT 1
35636: NEG
35637: PUSH
35638: EMPTY
35639: LIST
35640: LIST
35641: PUSH
35642: LD_INT 1
35644: PUSH
35645: LD_INT 0
35647: PUSH
35648: EMPTY
35649: LIST
35650: LIST
35651: PUSH
35652: LD_INT 1
35654: PUSH
35655: LD_INT 1
35657: PUSH
35658: EMPTY
35659: LIST
35660: LIST
35661: PUSH
35662: LD_INT 0
35664: PUSH
35665: LD_INT 1
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: PUSH
35672: LD_INT 1
35674: NEG
35675: PUSH
35676: LD_INT 0
35678: PUSH
35679: EMPTY
35680: LIST
35681: LIST
35682: PUSH
35683: LD_INT 1
35685: NEG
35686: PUSH
35687: LD_INT 1
35689: NEG
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PUSH
35695: LD_INT 1
35697: NEG
35698: PUSH
35699: LD_INT 2
35701: NEG
35702: PUSH
35703: EMPTY
35704: LIST
35705: LIST
35706: PUSH
35707: LD_INT 1
35709: PUSH
35710: LD_INT 2
35712: PUSH
35713: EMPTY
35714: LIST
35715: LIST
35716: PUSH
35717: EMPTY
35718: LIST
35719: LIST
35720: LIST
35721: LIST
35722: LIST
35723: LIST
35724: LIST
35725: LIST
35726: LIST
35727: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35728: LD_ADDR_VAR 0 40
35732: PUSH
35733: LD_INT 0
35735: PUSH
35736: LD_INT 0
35738: PUSH
35739: EMPTY
35740: LIST
35741: LIST
35742: PUSH
35743: LD_INT 0
35745: PUSH
35746: LD_INT 1
35748: NEG
35749: PUSH
35750: EMPTY
35751: LIST
35752: LIST
35753: PUSH
35754: LD_INT 1
35756: PUSH
35757: LD_INT 0
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 1
35766: PUSH
35767: LD_INT 1
35769: PUSH
35770: EMPTY
35771: LIST
35772: LIST
35773: PUSH
35774: LD_INT 0
35776: PUSH
35777: LD_INT 1
35779: PUSH
35780: EMPTY
35781: LIST
35782: LIST
35783: PUSH
35784: LD_INT 1
35786: NEG
35787: PUSH
35788: LD_INT 0
35790: PUSH
35791: EMPTY
35792: LIST
35793: LIST
35794: PUSH
35795: LD_INT 1
35797: NEG
35798: PUSH
35799: LD_INT 1
35801: NEG
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PUSH
35807: LD_INT 1
35809: PUSH
35810: LD_INT 1
35812: NEG
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: LD_INT 1
35820: NEG
35821: PUSH
35822: LD_INT 1
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: EMPTY
35830: LIST
35831: LIST
35832: LIST
35833: LIST
35834: LIST
35835: LIST
35836: LIST
35837: LIST
35838: LIST
35839: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35840: LD_ADDR_VAR 0 41
35844: PUSH
35845: LD_INT 0
35847: PUSH
35848: LD_INT 0
35850: PUSH
35851: EMPTY
35852: LIST
35853: LIST
35854: PUSH
35855: LD_INT 0
35857: PUSH
35858: LD_INT 1
35860: NEG
35861: PUSH
35862: EMPTY
35863: LIST
35864: LIST
35865: PUSH
35866: LD_INT 1
35868: PUSH
35869: LD_INT 0
35871: PUSH
35872: EMPTY
35873: LIST
35874: LIST
35875: PUSH
35876: LD_INT 1
35878: PUSH
35879: LD_INT 1
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: LD_INT 0
35888: PUSH
35889: LD_INT 1
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 1
35898: NEG
35899: PUSH
35900: LD_INT 0
35902: PUSH
35903: EMPTY
35904: LIST
35905: LIST
35906: PUSH
35907: LD_INT 1
35909: NEG
35910: PUSH
35911: LD_INT 1
35913: NEG
35914: PUSH
35915: EMPTY
35916: LIST
35917: LIST
35918: PUSH
35919: LD_INT 1
35921: NEG
35922: PUSH
35923: LD_INT 2
35925: NEG
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: PUSH
35931: LD_INT 1
35933: PUSH
35934: LD_INT 1
35936: NEG
35937: PUSH
35938: EMPTY
35939: LIST
35940: LIST
35941: PUSH
35942: LD_INT 2
35944: PUSH
35945: LD_INT 0
35947: PUSH
35948: EMPTY
35949: LIST
35950: LIST
35951: PUSH
35952: LD_INT 2
35954: PUSH
35955: LD_INT 1
35957: PUSH
35958: EMPTY
35959: LIST
35960: LIST
35961: PUSH
35962: LD_INT 2
35964: PUSH
35965: LD_INT 2
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 1
35974: PUSH
35975: LD_INT 2
35977: PUSH
35978: EMPTY
35979: LIST
35980: LIST
35981: PUSH
35982: LD_INT 1
35984: NEG
35985: PUSH
35986: LD_INT 1
35988: PUSH
35989: EMPTY
35990: LIST
35991: LIST
35992: PUSH
35993: LD_INT 2
35995: NEG
35996: PUSH
35997: LD_INT 0
35999: PUSH
36000: EMPTY
36001: LIST
36002: LIST
36003: PUSH
36004: LD_INT 2
36006: NEG
36007: PUSH
36008: LD_INT 1
36010: NEG
36011: PUSH
36012: EMPTY
36013: LIST
36014: LIST
36015: PUSH
36016: LD_INT 2
36018: NEG
36019: PUSH
36020: LD_INT 2
36022: NEG
36023: PUSH
36024: EMPTY
36025: LIST
36026: LIST
36027: PUSH
36028: LD_INT 2
36030: NEG
36031: PUSH
36032: LD_INT 3
36034: NEG
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 2
36042: PUSH
36043: LD_INT 1
36045: NEG
36046: PUSH
36047: EMPTY
36048: LIST
36049: LIST
36050: PUSH
36051: LD_INT 3
36053: PUSH
36054: LD_INT 0
36056: PUSH
36057: EMPTY
36058: LIST
36059: LIST
36060: PUSH
36061: LD_INT 3
36063: PUSH
36064: LD_INT 1
36066: PUSH
36067: EMPTY
36068: LIST
36069: LIST
36070: PUSH
36071: LD_INT 3
36073: PUSH
36074: LD_INT 2
36076: PUSH
36077: EMPTY
36078: LIST
36079: LIST
36080: PUSH
36081: LD_INT 3
36083: PUSH
36084: LD_INT 3
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PUSH
36091: LD_INT 2
36093: PUSH
36094: LD_INT 3
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 2
36103: NEG
36104: PUSH
36105: LD_INT 1
36107: PUSH
36108: EMPTY
36109: LIST
36110: LIST
36111: PUSH
36112: LD_INT 3
36114: NEG
36115: PUSH
36116: LD_INT 0
36118: PUSH
36119: EMPTY
36120: LIST
36121: LIST
36122: PUSH
36123: LD_INT 3
36125: NEG
36126: PUSH
36127: LD_INT 1
36129: NEG
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 3
36137: NEG
36138: PUSH
36139: LD_INT 2
36141: NEG
36142: PUSH
36143: EMPTY
36144: LIST
36145: LIST
36146: PUSH
36147: LD_INT 3
36149: NEG
36150: PUSH
36151: LD_INT 3
36153: NEG
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PUSH
36159: EMPTY
36160: LIST
36161: LIST
36162: LIST
36163: LIST
36164: LIST
36165: LIST
36166: LIST
36167: LIST
36168: LIST
36169: LIST
36170: LIST
36171: LIST
36172: LIST
36173: LIST
36174: LIST
36175: LIST
36176: LIST
36177: LIST
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: LIST
36184: LIST
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36190: LD_ADDR_VAR 0 42
36194: PUSH
36195: LD_INT 0
36197: PUSH
36198: LD_INT 0
36200: PUSH
36201: EMPTY
36202: LIST
36203: LIST
36204: PUSH
36205: LD_INT 0
36207: PUSH
36208: LD_INT 1
36210: NEG
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: PUSH
36216: LD_INT 1
36218: PUSH
36219: LD_INT 0
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 1
36228: PUSH
36229: LD_INT 1
36231: PUSH
36232: EMPTY
36233: LIST
36234: LIST
36235: PUSH
36236: LD_INT 0
36238: PUSH
36239: LD_INT 1
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 1
36248: NEG
36249: PUSH
36250: LD_INT 0
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: LD_INT 1
36259: NEG
36260: PUSH
36261: LD_INT 1
36263: NEG
36264: PUSH
36265: EMPTY
36266: LIST
36267: LIST
36268: PUSH
36269: LD_INT 1
36271: NEG
36272: PUSH
36273: LD_INT 2
36275: NEG
36276: PUSH
36277: EMPTY
36278: LIST
36279: LIST
36280: PUSH
36281: LD_INT 0
36283: PUSH
36284: LD_INT 2
36286: NEG
36287: PUSH
36288: EMPTY
36289: LIST
36290: LIST
36291: PUSH
36292: LD_INT 1
36294: PUSH
36295: LD_INT 1
36297: NEG
36298: PUSH
36299: EMPTY
36300: LIST
36301: LIST
36302: PUSH
36303: LD_INT 2
36305: PUSH
36306: LD_INT 1
36308: PUSH
36309: EMPTY
36310: LIST
36311: LIST
36312: PUSH
36313: LD_INT 2
36315: PUSH
36316: LD_INT 2
36318: PUSH
36319: EMPTY
36320: LIST
36321: LIST
36322: PUSH
36323: LD_INT 1
36325: PUSH
36326: LD_INT 2
36328: PUSH
36329: EMPTY
36330: LIST
36331: LIST
36332: PUSH
36333: LD_INT 0
36335: PUSH
36336: LD_INT 2
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: PUSH
36343: LD_INT 1
36345: NEG
36346: PUSH
36347: LD_INT 1
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 2
36356: NEG
36357: PUSH
36358: LD_INT 1
36360: NEG
36361: PUSH
36362: EMPTY
36363: LIST
36364: LIST
36365: PUSH
36366: LD_INT 2
36368: NEG
36369: PUSH
36370: LD_INT 2
36372: NEG
36373: PUSH
36374: EMPTY
36375: LIST
36376: LIST
36377: PUSH
36378: LD_INT 2
36380: NEG
36381: PUSH
36382: LD_INT 3
36384: NEG
36385: PUSH
36386: EMPTY
36387: LIST
36388: LIST
36389: PUSH
36390: LD_INT 1
36392: NEG
36393: PUSH
36394: LD_INT 3
36396: NEG
36397: PUSH
36398: EMPTY
36399: LIST
36400: LIST
36401: PUSH
36402: LD_INT 0
36404: PUSH
36405: LD_INT 3
36407: NEG
36408: PUSH
36409: EMPTY
36410: LIST
36411: LIST
36412: PUSH
36413: LD_INT 1
36415: PUSH
36416: LD_INT 2
36418: NEG
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: PUSH
36424: LD_INT 3
36426: PUSH
36427: LD_INT 2
36429: PUSH
36430: EMPTY
36431: LIST
36432: LIST
36433: PUSH
36434: LD_INT 3
36436: PUSH
36437: LD_INT 3
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PUSH
36444: LD_INT 2
36446: PUSH
36447: LD_INT 3
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: PUSH
36454: LD_INT 1
36456: PUSH
36457: LD_INT 3
36459: PUSH
36460: EMPTY
36461: LIST
36462: LIST
36463: PUSH
36464: LD_INT 0
36466: PUSH
36467: LD_INT 3
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: PUSH
36474: LD_INT 1
36476: NEG
36477: PUSH
36478: LD_INT 2
36480: PUSH
36481: EMPTY
36482: LIST
36483: LIST
36484: PUSH
36485: LD_INT 3
36487: NEG
36488: PUSH
36489: LD_INT 2
36491: NEG
36492: PUSH
36493: EMPTY
36494: LIST
36495: LIST
36496: PUSH
36497: LD_INT 3
36499: NEG
36500: PUSH
36501: LD_INT 3
36503: NEG
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: EMPTY
36510: LIST
36511: LIST
36512: LIST
36513: LIST
36514: LIST
36515: LIST
36516: LIST
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: LIST
36522: LIST
36523: LIST
36524: LIST
36525: LIST
36526: LIST
36527: LIST
36528: LIST
36529: LIST
36530: LIST
36531: LIST
36532: LIST
36533: LIST
36534: LIST
36535: LIST
36536: LIST
36537: LIST
36538: LIST
36539: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36540: LD_ADDR_VAR 0 43
36544: PUSH
36545: LD_INT 0
36547: PUSH
36548: LD_INT 0
36550: PUSH
36551: EMPTY
36552: LIST
36553: LIST
36554: PUSH
36555: LD_INT 0
36557: PUSH
36558: LD_INT 1
36560: NEG
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: LD_INT 1
36568: PUSH
36569: LD_INT 0
36571: PUSH
36572: EMPTY
36573: LIST
36574: LIST
36575: PUSH
36576: LD_INT 1
36578: PUSH
36579: LD_INT 1
36581: PUSH
36582: EMPTY
36583: LIST
36584: LIST
36585: PUSH
36586: LD_INT 0
36588: PUSH
36589: LD_INT 1
36591: PUSH
36592: EMPTY
36593: LIST
36594: LIST
36595: PUSH
36596: LD_INT 1
36598: NEG
36599: PUSH
36600: LD_INT 0
36602: PUSH
36603: EMPTY
36604: LIST
36605: LIST
36606: PUSH
36607: LD_INT 1
36609: NEG
36610: PUSH
36611: LD_INT 1
36613: NEG
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 1
36621: NEG
36622: PUSH
36623: LD_INT 2
36625: NEG
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 0
36633: PUSH
36634: LD_INT 2
36636: NEG
36637: PUSH
36638: EMPTY
36639: LIST
36640: LIST
36641: PUSH
36642: LD_INT 1
36644: PUSH
36645: LD_INT 1
36647: NEG
36648: PUSH
36649: EMPTY
36650: LIST
36651: LIST
36652: PUSH
36653: LD_INT 2
36655: PUSH
36656: LD_INT 0
36658: PUSH
36659: EMPTY
36660: LIST
36661: LIST
36662: PUSH
36663: LD_INT 2
36665: PUSH
36666: LD_INT 1
36668: PUSH
36669: EMPTY
36670: LIST
36671: LIST
36672: PUSH
36673: LD_INT 1
36675: PUSH
36676: LD_INT 2
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PUSH
36683: LD_INT 0
36685: PUSH
36686: LD_INT 2
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: LD_INT 1
36695: NEG
36696: PUSH
36697: LD_INT 1
36699: PUSH
36700: EMPTY
36701: LIST
36702: LIST
36703: PUSH
36704: LD_INT 2
36706: NEG
36707: PUSH
36708: LD_INT 0
36710: PUSH
36711: EMPTY
36712: LIST
36713: LIST
36714: PUSH
36715: LD_INT 2
36717: NEG
36718: PUSH
36719: LD_INT 1
36721: NEG
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 1
36729: NEG
36730: PUSH
36731: LD_INT 3
36733: NEG
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: PUSH
36739: LD_INT 0
36741: PUSH
36742: LD_INT 3
36744: NEG
36745: PUSH
36746: EMPTY
36747: LIST
36748: LIST
36749: PUSH
36750: LD_INT 1
36752: PUSH
36753: LD_INT 2
36755: NEG
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 2
36763: PUSH
36764: LD_INT 1
36766: NEG
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 3
36774: PUSH
36775: LD_INT 0
36777: PUSH
36778: EMPTY
36779: LIST
36780: LIST
36781: PUSH
36782: LD_INT 3
36784: PUSH
36785: LD_INT 1
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 1
36794: PUSH
36795: LD_INT 3
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: LD_INT 0
36804: PUSH
36805: LD_INT 3
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PUSH
36812: LD_INT 1
36814: NEG
36815: PUSH
36816: LD_INT 2
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: LD_INT 2
36825: NEG
36826: PUSH
36827: LD_INT 1
36829: PUSH
36830: EMPTY
36831: LIST
36832: LIST
36833: PUSH
36834: LD_INT 3
36836: NEG
36837: PUSH
36838: LD_INT 0
36840: PUSH
36841: EMPTY
36842: LIST
36843: LIST
36844: PUSH
36845: LD_INT 3
36847: NEG
36848: PUSH
36849: LD_INT 1
36851: NEG
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: PUSH
36857: EMPTY
36858: LIST
36859: LIST
36860: LIST
36861: LIST
36862: LIST
36863: LIST
36864: LIST
36865: LIST
36866: LIST
36867: LIST
36868: LIST
36869: LIST
36870: LIST
36871: LIST
36872: LIST
36873: LIST
36874: LIST
36875: LIST
36876: LIST
36877: LIST
36878: LIST
36879: LIST
36880: LIST
36881: LIST
36882: LIST
36883: LIST
36884: LIST
36885: LIST
36886: LIST
36887: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36888: LD_ADDR_VAR 0 44
36892: PUSH
36893: LD_INT 0
36895: PUSH
36896: LD_INT 0
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PUSH
36903: LD_INT 0
36905: PUSH
36906: LD_INT 1
36908: NEG
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 1
36916: PUSH
36917: LD_INT 0
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: PUSH
36924: LD_INT 1
36926: PUSH
36927: LD_INT 1
36929: PUSH
36930: EMPTY
36931: LIST
36932: LIST
36933: PUSH
36934: LD_INT 0
36936: PUSH
36937: LD_INT 1
36939: PUSH
36940: EMPTY
36941: LIST
36942: LIST
36943: PUSH
36944: LD_INT 1
36946: NEG
36947: PUSH
36948: LD_INT 0
36950: PUSH
36951: EMPTY
36952: LIST
36953: LIST
36954: PUSH
36955: LD_INT 1
36957: NEG
36958: PUSH
36959: LD_INT 1
36961: NEG
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: LD_INT 1
36969: NEG
36970: PUSH
36971: LD_INT 2
36973: NEG
36974: PUSH
36975: EMPTY
36976: LIST
36977: LIST
36978: PUSH
36979: LD_INT 1
36981: PUSH
36982: LD_INT 1
36984: NEG
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: PUSH
36990: LD_INT 2
36992: PUSH
36993: LD_INT 0
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: PUSH
37000: LD_INT 2
37002: PUSH
37003: LD_INT 1
37005: PUSH
37006: EMPTY
37007: LIST
37008: LIST
37009: PUSH
37010: LD_INT 2
37012: PUSH
37013: LD_INT 2
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: PUSH
37020: LD_INT 1
37022: PUSH
37023: LD_INT 2
37025: PUSH
37026: EMPTY
37027: LIST
37028: LIST
37029: PUSH
37030: LD_INT 1
37032: NEG
37033: PUSH
37034: LD_INT 1
37036: PUSH
37037: EMPTY
37038: LIST
37039: LIST
37040: PUSH
37041: LD_INT 2
37043: NEG
37044: PUSH
37045: LD_INT 0
37047: PUSH
37048: EMPTY
37049: LIST
37050: LIST
37051: PUSH
37052: LD_INT 2
37054: NEG
37055: PUSH
37056: LD_INT 1
37058: NEG
37059: PUSH
37060: EMPTY
37061: LIST
37062: LIST
37063: PUSH
37064: LD_INT 2
37066: NEG
37067: PUSH
37068: LD_INT 2
37070: NEG
37071: PUSH
37072: EMPTY
37073: LIST
37074: LIST
37075: PUSH
37076: LD_INT 2
37078: NEG
37079: PUSH
37080: LD_INT 3
37082: NEG
37083: PUSH
37084: EMPTY
37085: LIST
37086: LIST
37087: PUSH
37088: LD_INT 2
37090: PUSH
37091: LD_INT 1
37093: NEG
37094: PUSH
37095: EMPTY
37096: LIST
37097: LIST
37098: PUSH
37099: LD_INT 3
37101: PUSH
37102: LD_INT 0
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: LD_INT 3
37111: PUSH
37112: LD_INT 1
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 3
37121: PUSH
37122: LD_INT 2
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: PUSH
37129: LD_INT 3
37131: PUSH
37132: LD_INT 3
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 2
37141: PUSH
37142: LD_INT 3
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 2
37151: NEG
37152: PUSH
37153: LD_INT 1
37155: PUSH
37156: EMPTY
37157: LIST
37158: LIST
37159: PUSH
37160: LD_INT 3
37162: NEG
37163: PUSH
37164: LD_INT 0
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 3
37173: NEG
37174: PUSH
37175: LD_INT 1
37177: NEG
37178: PUSH
37179: EMPTY
37180: LIST
37181: LIST
37182: PUSH
37183: LD_INT 3
37185: NEG
37186: PUSH
37187: LD_INT 2
37189: NEG
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 3
37197: NEG
37198: PUSH
37199: LD_INT 3
37201: NEG
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: EMPTY
37208: LIST
37209: LIST
37210: LIST
37211: LIST
37212: LIST
37213: LIST
37214: LIST
37215: LIST
37216: LIST
37217: LIST
37218: LIST
37219: LIST
37220: LIST
37221: LIST
37222: LIST
37223: LIST
37224: LIST
37225: LIST
37226: LIST
37227: LIST
37228: LIST
37229: LIST
37230: LIST
37231: LIST
37232: LIST
37233: LIST
37234: LIST
37235: LIST
37236: LIST
37237: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37238: LD_ADDR_VAR 0 45
37242: PUSH
37243: LD_INT 0
37245: PUSH
37246: LD_INT 0
37248: PUSH
37249: EMPTY
37250: LIST
37251: LIST
37252: PUSH
37253: LD_INT 0
37255: PUSH
37256: LD_INT 1
37258: NEG
37259: PUSH
37260: EMPTY
37261: LIST
37262: LIST
37263: PUSH
37264: LD_INT 1
37266: PUSH
37267: LD_INT 0
37269: PUSH
37270: EMPTY
37271: LIST
37272: LIST
37273: PUSH
37274: LD_INT 1
37276: PUSH
37277: LD_INT 1
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: PUSH
37284: LD_INT 0
37286: PUSH
37287: LD_INT 1
37289: PUSH
37290: EMPTY
37291: LIST
37292: LIST
37293: PUSH
37294: LD_INT 1
37296: NEG
37297: PUSH
37298: LD_INT 0
37300: PUSH
37301: EMPTY
37302: LIST
37303: LIST
37304: PUSH
37305: LD_INT 1
37307: NEG
37308: PUSH
37309: LD_INT 1
37311: NEG
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: PUSH
37317: LD_INT 1
37319: NEG
37320: PUSH
37321: LD_INT 2
37323: NEG
37324: PUSH
37325: EMPTY
37326: LIST
37327: LIST
37328: PUSH
37329: LD_INT 0
37331: PUSH
37332: LD_INT 2
37334: NEG
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: LD_INT 1
37342: PUSH
37343: LD_INT 1
37345: NEG
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: LD_INT 2
37353: PUSH
37354: LD_INT 1
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: LD_INT 2
37363: PUSH
37364: LD_INT 2
37366: PUSH
37367: EMPTY
37368: LIST
37369: LIST
37370: PUSH
37371: LD_INT 1
37373: PUSH
37374: LD_INT 2
37376: PUSH
37377: EMPTY
37378: LIST
37379: LIST
37380: PUSH
37381: LD_INT 0
37383: PUSH
37384: LD_INT 2
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 1
37393: NEG
37394: PUSH
37395: LD_INT 1
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PUSH
37402: LD_INT 2
37404: NEG
37405: PUSH
37406: LD_INT 1
37408: NEG
37409: PUSH
37410: EMPTY
37411: LIST
37412: LIST
37413: PUSH
37414: LD_INT 2
37416: NEG
37417: PUSH
37418: LD_INT 2
37420: NEG
37421: PUSH
37422: EMPTY
37423: LIST
37424: LIST
37425: PUSH
37426: LD_INT 2
37428: NEG
37429: PUSH
37430: LD_INT 3
37432: NEG
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 1
37440: NEG
37441: PUSH
37442: LD_INT 3
37444: NEG
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 0
37452: PUSH
37453: LD_INT 3
37455: NEG
37456: PUSH
37457: EMPTY
37458: LIST
37459: LIST
37460: PUSH
37461: LD_INT 1
37463: PUSH
37464: LD_INT 2
37466: NEG
37467: PUSH
37468: EMPTY
37469: LIST
37470: LIST
37471: PUSH
37472: LD_INT 3
37474: PUSH
37475: LD_INT 2
37477: PUSH
37478: EMPTY
37479: LIST
37480: LIST
37481: PUSH
37482: LD_INT 3
37484: PUSH
37485: LD_INT 3
37487: PUSH
37488: EMPTY
37489: LIST
37490: LIST
37491: PUSH
37492: LD_INT 2
37494: PUSH
37495: LD_INT 3
37497: PUSH
37498: EMPTY
37499: LIST
37500: LIST
37501: PUSH
37502: LD_INT 1
37504: PUSH
37505: LD_INT 3
37507: PUSH
37508: EMPTY
37509: LIST
37510: LIST
37511: PUSH
37512: LD_INT 0
37514: PUSH
37515: LD_INT 3
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: PUSH
37522: LD_INT 1
37524: NEG
37525: PUSH
37526: LD_INT 2
37528: PUSH
37529: EMPTY
37530: LIST
37531: LIST
37532: PUSH
37533: LD_INT 3
37535: NEG
37536: PUSH
37537: LD_INT 2
37539: NEG
37540: PUSH
37541: EMPTY
37542: LIST
37543: LIST
37544: PUSH
37545: LD_INT 3
37547: NEG
37548: PUSH
37549: LD_INT 3
37551: NEG
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: EMPTY
37558: LIST
37559: LIST
37560: LIST
37561: LIST
37562: LIST
37563: LIST
37564: LIST
37565: LIST
37566: LIST
37567: LIST
37568: LIST
37569: LIST
37570: LIST
37571: LIST
37572: LIST
37573: LIST
37574: LIST
37575: LIST
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: LIST
37585: LIST
37586: LIST
37587: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37588: LD_ADDR_VAR 0 46
37592: PUSH
37593: LD_INT 0
37595: PUSH
37596: LD_INT 0
37598: PUSH
37599: EMPTY
37600: LIST
37601: LIST
37602: PUSH
37603: LD_INT 0
37605: PUSH
37606: LD_INT 1
37608: NEG
37609: PUSH
37610: EMPTY
37611: LIST
37612: LIST
37613: PUSH
37614: LD_INT 1
37616: PUSH
37617: LD_INT 0
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: PUSH
37624: LD_INT 1
37626: PUSH
37627: LD_INT 1
37629: PUSH
37630: EMPTY
37631: LIST
37632: LIST
37633: PUSH
37634: LD_INT 0
37636: PUSH
37637: LD_INT 1
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 1
37646: NEG
37647: PUSH
37648: LD_INT 0
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: LD_INT 1
37657: NEG
37658: PUSH
37659: LD_INT 1
37661: NEG
37662: PUSH
37663: EMPTY
37664: LIST
37665: LIST
37666: PUSH
37667: LD_INT 1
37669: NEG
37670: PUSH
37671: LD_INT 2
37673: NEG
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 0
37681: PUSH
37682: LD_INT 2
37684: NEG
37685: PUSH
37686: EMPTY
37687: LIST
37688: LIST
37689: PUSH
37690: LD_INT 1
37692: PUSH
37693: LD_INT 1
37695: NEG
37696: PUSH
37697: EMPTY
37698: LIST
37699: LIST
37700: PUSH
37701: LD_INT 2
37703: PUSH
37704: LD_INT 0
37706: PUSH
37707: EMPTY
37708: LIST
37709: LIST
37710: PUSH
37711: LD_INT 2
37713: PUSH
37714: LD_INT 1
37716: PUSH
37717: EMPTY
37718: LIST
37719: LIST
37720: PUSH
37721: LD_INT 1
37723: PUSH
37724: LD_INT 2
37726: PUSH
37727: EMPTY
37728: LIST
37729: LIST
37730: PUSH
37731: LD_INT 0
37733: PUSH
37734: LD_INT 2
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 1
37743: NEG
37744: PUSH
37745: LD_INT 1
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: LD_INT 2
37754: NEG
37755: PUSH
37756: LD_INT 0
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PUSH
37763: LD_INT 2
37765: NEG
37766: PUSH
37767: LD_INT 1
37769: NEG
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 1
37777: NEG
37778: PUSH
37779: LD_INT 3
37781: NEG
37782: PUSH
37783: EMPTY
37784: LIST
37785: LIST
37786: PUSH
37787: LD_INT 0
37789: PUSH
37790: LD_INT 3
37792: NEG
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: PUSH
37798: LD_INT 1
37800: PUSH
37801: LD_INT 2
37803: NEG
37804: PUSH
37805: EMPTY
37806: LIST
37807: LIST
37808: PUSH
37809: LD_INT 2
37811: PUSH
37812: LD_INT 1
37814: NEG
37815: PUSH
37816: EMPTY
37817: LIST
37818: LIST
37819: PUSH
37820: LD_INT 3
37822: PUSH
37823: LD_INT 0
37825: PUSH
37826: EMPTY
37827: LIST
37828: LIST
37829: PUSH
37830: LD_INT 3
37832: PUSH
37833: LD_INT 1
37835: PUSH
37836: EMPTY
37837: LIST
37838: LIST
37839: PUSH
37840: LD_INT 1
37842: PUSH
37843: LD_INT 3
37845: PUSH
37846: EMPTY
37847: LIST
37848: LIST
37849: PUSH
37850: LD_INT 0
37852: PUSH
37853: LD_INT 3
37855: PUSH
37856: EMPTY
37857: LIST
37858: LIST
37859: PUSH
37860: LD_INT 1
37862: NEG
37863: PUSH
37864: LD_INT 2
37866: PUSH
37867: EMPTY
37868: LIST
37869: LIST
37870: PUSH
37871: LD_INT 2
37873: NEG
37874: PUSH
37875: LD_INT 1
37877: PUSH
37878: EMPTY
37879: LIST
37880: LIST
37881: PUSH
37882: LD_INT 3
37884: NEG
37885: PUSH
37886: LD_INT 0
37888: PUSH
37889: EMPTY
37890: LIST
37891: LIST
37892: PUSH
37893: LD_INT 3
37895: NEG
37896: PUSH
37897: LD_INT 1
37899: NEG
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: LIST
37909: LIST
37910: LIST
37911: LIST
37912: LIST
37913: LIST
37914: LIST
37915: LIST
37916: LIST
37917: LIST
37918: LIST
37919: LIST
37920: LIST
37921: LIST
37922: LIST
37923: LIST
37924: LIST
37925: LIST
37926: LIST
37927: LIST
37928: LIST
37929: LIST
37930: LIST
37931: LIST
37932: LIST
37933: LIST
37934: LIST
37935: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37936: LD_ADDR_VAR 0 47
37940: PUSH
37941: LD_INT 0
37943: PUSH
37944: LD_INT 0
37946: PUSH
37947: EMPTY
37948: LIST
37949: LIST
37950: PUSH
37951: LD_INT 0
37953: PUSH
37954: LD_INT 1
37956: NEG
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 1
37964: PUSH
37965: LD_INT 0
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: LD_INT 1
37974: PUSH
37975: LD_INT 1
37977: PUSH
37978: EMPTY
37979: LIST
37980: LIST
37981: PUSH
37982: LD_INT 0
37984: PUSH
37985: LD_INT 1
37987: PUSH
37988: EMPTY
37989: LIST
37990: LIST
37991: PUSH
37992: LD_INT 1
37994: NEG
37995: PUSH
37996: LD_INT 0
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: PUSH
38003: LD_INT 1
38005: NEG
38006: PUSH
38007: LD_INT 1
38009: NEG
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 1
38017: NEG
38018: PUSH
38019: LD_INT 2
38021: NEG
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: PUSH
38027: LD_INT 0
38029: PUSH
38030: LD_INT 2
38032: NEG
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: PUSH
38038: LD_INT 1
38040: PUSH
38041: LD_INT 1
38043: NEG
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: LD_INT 2
38051: NEG
38052: PUSH
38053: LD_INT 1
38055: NEG
38056: PUSH
38057: EMPTY
38058: LIST
38059: LIST
38060: PUSH
38061: LD_INT 2
38063: NEG
38064: PUSH
38065: LD_INT 2
38067: NEG
38068: PUSH
38069: EMPTY
38070: LIST
38071: LIST
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: LIST
38077: LIST
38078: LIST
38079: LIST
38080: LIST
38081: LIST
38082: LIST
38083: LIST
38084: LIST
38085: LIST
38086: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38087: LD_ADDR_VAR 0 48
38091: PUSH
38092: LD_INT 0
38094: PUSH
38095: LD_INT 0
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: LD_INT 0
38104: PUSH
38105: LD_INT 1
38107: NEG
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: LD_INT 1
38115: PUSH
38116: LD_INT 0
38118: PUSH
38119: EMPTY
38120: LIST
38121: LIST
38122: PUSH
38123: LD_INT 1
38125: PUSH
38126: LD_INT 1
38128: PUSH
38129: EMPTY
38130: LIST
38131: LIST
38132: PUSH
38133: LD_INT 0
38135: PUSH
38136: LD_INT 1
38138: PUSH
38139: EMPTY
38140: LIST
38141: LIST
38142: PUSH
38143: LD_INT 1
38145: NEG
38146: PUSH
38147: LD_INT 0
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: PUSH
38154: LD_INT 1
38156: NEG
38157: PUSH
38158: LD_INT 1
38160: NEG
38161: PUSH
38162: EMPTY
38163: LIST
38164: LIST
38165: PUSH
38166: LD_INT 1
38168: NEG
38169: PUSH
38170: LD_INT 2
38172: NEG
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: LD_INT 0
38180: PUSH
38181: LD_INT 2
38183: NEG
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PUSH
38189: LD_INT 1
38191: PUSH
38192: LD_INT 1
38194: NEG
38195: PUSH
38196: EMPTY
38197: LIST
38198: LIST
38199: PUSH
38200: LD_INT 2
38202: PUSH
38203: LD_INT 0
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 2
38212: PUSH
38213: LD_INT 1
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: EMPTY
38221: LIST
38222: LIST
38223: LIST
38224: LIST
38225: LIST
38226: LIST
38227: LIST
38228: LIST
38229: LIST
38230: LIST
38231: LIST
38232: LIST
38233: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38234: LD_ADDR_VAR 0 49
38238: PUSH
38239: LD_INT 0
38241: PUSH
38242: LD_INT 0
38244: PUSH
38245: EMPTY
38246: LIST
38247: LIST
38248: PUSH
38249: LD_INT 0
38251: PUSH
38252: LD_INT 1
38254: NEG
38255: PUSH
38256: EMPTY
38257: LIST
38258: LIST
38259: PUSH
38260: LD_INT 1
38262: PUSH
38263: LD_INT 0
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: PUSH
38270: LD_INT 1
38272: PUSH
38273: LD_INT 1
38275: PUSH
38276: EMPTY
38277: LIST
38278: LIST
38279: PUSH
38280: LD_INT 0
38282: PUSH
38283: LD_INT 1
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 1
38292: NEG
38293: PUSH
38294: LD_INT 0
38296: PUSH
38297: EMPTY
38298: LIST
38299: LIST
38300: PUSH
38301: LD_INT 1
38303: NEG
38304: PUSH
38305: LD_INT 1
38307: NEG
38308: PUSH
38309: EMPTY
38310: LIST
38311: LIST
38312: PUSH
38313: LD_INT 1
38315: PUSH
38316: LD_INT 1
38318: NEG
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: LD_INT 2
38326: PUSH
38327: LD_INT 0
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: PUSH
38334: LD_INT 2
38336: PUSH
38337: LD_INT 1
38339: PUSH
38340: EMPTY
38341: LIST
38342: LIST
38343: PUSH
38344: LD_INT 2
38346: PUSH
38347: LD_INT 2
38349: PUSH
38350: EMPTY
38351: LIST
38352: LIST
38353: PUSH
38354: LD_INT 1
38356: PUSH
38357: LD_INT 2
38359: PUSH
38360: EMPTY
38361: LIST
38362: LIST
38363: PUSH
38364: EMPTY
38365: LIST
38366: LIST
38367: LIST
38368: LIST
38369: LIST
38370: LIST
38371: LIST
38372: LIST
38373: LIST
38374: LIST
38375: LIST
38376: LIST
38377: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38378: LD_ADDR_VAR 0 50
38382: PUSH
38383: LD_INT 0
38385: PUSH
38386: LD_INT 0
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: PUSH
38393: LD_INT 0
38395: PUSH
38396: LD_INT 1
38398: NEG
38399: PUSH
38400: EMPTY
38401: LIST
38402: LIST
38403: PUSH
38404: LD_INT 1
38406: PUSH
38407: LD_INT 0
38409: PUSH
38410: EMPTY
38411: LIST
38412: LIST
38413: PUSH
38414: LD_INT 1
38416: PUSH
38417: LD_INT 1
38419: PUSH
38420: EMPTY
38421: LIST
38422: LIST
38423: PUSH
38424: LD_INT 0
38426: PUSH
38427: LD_INT 1
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: LD_INT 1
38436: NEG
38437: PUSH
38438: LD_INT 0
38440: PUSH
38441: EMPTY
38442: LIST
38443: LIST
38444: PUSH
38445: LD_INT 1
38447: NEG
38448: PUSH
38449: LD_INT 1
38451: NEG
38452: PUSH
38453: EMPTY
38454: LIST
38455: LIST
38456: PUSH
38457: LD_INT 2
38459: PUSH
38460: LD_INT 1
38462: PUSH
38463: EMPTY
38464: LIST
38465: LIST
38466: PUSH
38467: LD_INT 2
38469: PUSH
38470: LD_INT 2
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 1
38479: PUSH
38480: LD_INT 2
38482: PUSH
38483: EMPTY
38484: LIST
38485: LIST
38486: PUSH
38487: LD_INT 0
38489: PUSH
38490: LD_INT 2
38492: PUSH
38493: EMPTY
38494: LIST
38495: LIST
38496: PUSH
38497: LD_INT 1
38499: NEG
38500: PUSH
38501: LD_INT 1
38503: PUSH
38504: EMPTY
38505: LIST
38506: LIST
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: LIST
38512: LIST
38513: LIST
38514: LIST
38515: LIST
38516: LIST
38517: LIST
38518: LIST
38519: LIST
38520: LIST
38521: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38522: LD_ADDR_VAR 0 51
38526: PUSH
38527: LD_INT 0
38529: PUSH
38530: LD_INT 0
38532: PUSH
38533: EMPTY
38534: LIST
38535: LIST
38536: PUSH
38537: LD_INT 0
38539: PUSH
38540: LD_INT 1
38542: NEG
38543: PUSH
38544: EMPTY
38545: LIST
38546: LIST
38547: PUSH
38548: LD_INT 1
38550: PUSH
38551: LD_INT 0
38553: PUSH
38554: EMPTY
38555: LIST
38556: LIST
38557: PUSH
38558: LD_INT 1
38560: PUSH
38561: LD_INT 1
38563: PUSH
38564: EMPTY
38565: LIST
38566: LIST
38567: PUSH
38568: LD_INT 0
38570: PUSH
38571: LD_INT 1
38573: PUSH
38574: EMPTY
38575: LIST
38576: LIST
38577: PUSH
38578: LD_INT 1
38580: NEG
38581: PUSH
38582: LD_INT 0
38584: PUSH
38585: EMPTY
38586: LIST
38587: LIST
38588: PUSH
38589: LD_INT 1
38591: NEG
38592: PUSH
38593: LD_INT 1
38595: NEG
38596: PUSH
38597: EMPTY
38598: LIST
38599: LIST
38600: PUSH
38601: LD_INT 1
38603: PUSH
38604: LD_INT 2
38606: PUSH
38607: EMPTY
38608: LIST
38609: LIST
38610: PUSH
38611: LD_INT 0
38613: PUSH
38614: LD_INT 2
38616: PUSH
38617: EMPTY
38618: LIST
38619: LIST
38620: PUSH
38621: LD_INT 1
38623: NEG
38624: PUSH
38625: LD_INT 1
38627: PUSH
38628: EMPTY
38629: LIST
38630: LIST
38631: PUSH
38632: LD_INT 2
38634: NEG
38635: PUSH
38636: LD_INT 0
38638: PUSH
38639: EMPTY
38640: LIST
38641: LIST
38642: PUSH
38643: LD_INT 2
38645: NEG
38646: PUSH
38647: LD_INT 1
38649: NEG
38650: PUSH
38651: EMPTY
38652: LIST
38653: LIST
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: LIST
38659: LIST
38660: LIST
38661: LIST
38662: LIST
38663: LIST
38664: LIST
38665: LIST
38666: LIST
38667: LIST
38668: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38669: LD_ADDR_VAR 0 52
38673: PUSH
38674: LD_INT 0
38676: PUSH
38677: LD_INT 0
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: PUSH
38684: LD_INT 0
38686: PUSH
38687: LD_INT 1
38689: NEG
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: PUSH
38695: LD_INT 1
38697: PUSH
38698: LD_INT 0
38700: PUSH
38701: EMPTY
38702: LIST
38703: LIST
38704: PUSH
38705: LD_INT 1
38707: PUSH
38708: LD_INT 1
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 0
38717: PUSH
38718: LD_INT 1
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: LD_INT 1
38727: NEG
38728: PUSH
38729: LD_INT 0
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 1
38738: NEG
38739: PUSH
38740: LD_INT 1
38742: NEG
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: PUSH
38748: LD_INT 1
38750: NEG
38751: PUSH
38752: LD_INT 2
38754: NEG
38755: PUSH
38756: EMPTY
38757: LIST
38758: LIST
38759: PUSH
38760: LD_INT 1
38762: NEG
38763: PUSH
38764: LD_INT 1
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 2
38773: NEG
38774: PUSH
38775: LD_INT 0
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: LD_INT 2
38784: NEG
38785: PUSH
38786: LD_INT 1
38788: NEG
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 2
38796: NEG
38797: PUSH
38798: LD_INT 2
38800: NEG
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: LIST
38810: LIST
38811: LIST
38812: LIST
38813: LIST
38814: LIST
38815: LIST
38816: LIST
38817: LIST
38818: LIST
38819: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38820: LD_ADDR_VAR 0 53
38824: PUSH
38825: LD_INT 0
38827: PUSH
38828: LD_INT 0
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: LD_INT 0
38837: PUSH
38838: LD_INT 1
38840: NEG
38841: PUSH
38842: EMPTY
38843: LIST
38844: LIST
38845: PUSH
38846: LD_INT 1
38848: PUSH
38849: LD_INT 0
38851: PUSH
38852: EMPTY
38853: LIST
38854: LIST
38855: PUSH
38856: LD_INT 1
38858: PUSH
38859: LD_INT 1
38861: PUSH
38862: EMPTY
38863: LIST
38864: LIST
38865: PUSH
38866: LD_INT 0
38868: PUSH
38869: LD_INT 1
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: PUSH
38876: LD_INT 1
38878: NEG
38879: PUSH
38880: LD_INT 0
38882: PUSH
38883: EMPTY
38884: LIST
38885: LIST
38886: PUSH
38887: LD_INT 1
38889: NEG
38890: PUSH
38891: LD_INT 1
38893: NEG
38894: PUSH
38895: EMPTY
38896: LIST
38897: LIST
38898: PUSH
38899: LD_INT 1
38901: NEG
38902: PUSH
38903: LD_INT 2
38905: NEG
38906: PUSH
38907: EMPTY
38908: LIST
38909: LIST
38910: PUSH
38911: LD_INT 0
38913: PUSH
38914: LD_INT 2
38916: NEG
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 1
38924: PUSH
38925: LD_INT 1
38927: NEG
38928: PUSH
38929: EMPTY
38930: LIST
38931: LIST
38932: PUSH
38933: LD_INT 2
38935: PUSH
38936: LD_INT 0
38938: PUSH
38939: EMPTY
38940: LIST
38941: LIST
38942: PUSH
38943: LD_INT 2
38945: PUSH
38946: LD_INT 1
38948: PUSH
38949: EMPTY
38950: LIST
38951: LIST
38952: PUSH
38953: LD_INT 2
38955: PUSH
38956: LD_INT 2
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: PUSH
38963: LD_INT 1
38965: PUSH
38966: LD_INT 2
38968: PUSH
38969: EMPTY
38970: LIST
38971: LIST
38972: PUSH
38973: LD_INT 0
38975: PUSH
38976: LD_INT 2
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: PUSH
38983: LD_INT 1
38985: NEG
38986: PUSH
38987: LD_INT 1
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: PUSH
38994: LD_INT 2
38996: NEG
38997: PUSH
38998: LD_INT 0
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: LD_INT 2
39007: NEG
39008: PUSH
39009: LD_INT 1
39011: NEG
39012: PUSH
39013: EMPTY
39014: LIST
39015: LIST
39016: PUSH
39017: LD_INT 2
39019: NEG
39020: PUSH
39021: LD_INT 2
39023: NEG
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: LIST
39033: LIST
39034: LIST
39035: LIST
39036: LIST
39037: LIST
39038: LIST
39039: LIST
39040: LIST
39041: LIST
39042: LIST
39043: LIST
39044: LIST
39045: LIST
39046: LIST
39047: LIST
39048: LIST
39049: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39050: LD_ADDR_VAR 0 54
39054: PUSH
39055: LD_INT 0
39057: PUSH
39058: LD_INT 0
39060: PUSH
39061: EMPTY
39062: LIST
39063: LIST
39064: PUSH
39065: LD_INT 0
39067: PUSH
39068: LD_INT 1
39070: NEG
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: PUSH
39076: LD_INT 1
39078: PUSH
39079: LD_INT 0
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: PUSH
39086: LD_INT 1
39088: PUSH
39089: LD_INT 1
39091: PUSH
39092: EMPTY
39093: LIST
39094: LIST
39095: PUSH
39096: LD_INT 0
39098: PUSH
39099: LD_INT 1
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: LD_INT 1
39108: NEG
39109: PUSH
39110: LD_INT 0
39112: PUSH
39113: EMPTY
39114: LIST
39115: LIST
39116: PUSH
39117: LD_INT 1
39119: NEG
39120: PUSH
39121: LD_INT 1
39123: NEG
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 1
39131: NEG
39132: PUSH
39133: LD_INT 2
39135: NEG
39136: PUSH
39137: EMPTY
39138: LIST
39139: LIST
39140: PUSH
39141: LD_INT 0
39143: PUSH
39144: LD_INT 2
39146: NEG
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: PUSH
39152: LD_INT 1
39154: PUSH
39155: LD_INT 1
39157: NEG
39158: PUSH
39159: EMPTY
39160: LIST
39161: LIST
39162: PUSH
39163: LD_INT 2
39165: PUSH
39166: LD_INT 0
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: PUSH
39173: LD_INT 2
39175: PUSH
39176: LD_INT 1
39178: PUSH
39179: EMPTY
39180: LIST
39181: LIST
39182: PUSH
39183: LD_INT 2
39185: PUSH
39186: LD_INT 2
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: PUSH
39193: LD_INT 1
39195: PUSH
39196: LD_INT 2
39198: PUSH
39199: EMPTY
39200: LIST
39201: LIST
39202: PUSH
39203: LD_INT 0
39205: PUSH
39206: LD_INT 2
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: LD_INT 1
39215: NEG
39216: PUSH
39217: LD_INT 1
39219: PUSH
39220: EMPTY
39221: LIST
39222: LIST
39223: PUSH
39224: LD_INT 2
39226: NEG
39227: PUSH
39228: LD_INT 0
39230: PUSH
39231: EMPTY
39232: LIST
39233: LIST
39234: PUSH
39235: LD_INT 2
39237: NEG
39238: PUSH
39239: LD_INT 1
39241: NEG
39242: PUSH
39243: EMPTY
39244: LIST
39245: LIST
39246: PUSH
39247: LD_INT 2
39249: NEG
39250: PUSH
39251: LD_INT 2
39253: NEG
39254: PUSH
39255: EMPTY
39256: LIST
39257: LIST
39258: PUSH
39259: EMPTY
39260: LIST
39261: LIST
39262: LIST
39263: LIST
39264: LIST
39265: LIST
39266: LIST
39267: LIST
39268: LIST
39269: LIST
39270: LIST
39271: LIST
39272: LIST
39273: LIST
39274: LIST
39275: LIST
39276: LIST
39277: LIST
39278: LIST
39279: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39280: LD_ADDR_VAR 0 55
39284: PUSH
39285: LD_INT 0
39287: PUSH
39288: LD_INT 0
39290: PUSH
39291: EMPTY
39292: LIST
39293: LIST
39294: PUSH
39295: LD_INT 0
39297: PUSH
39298: LD_INT 1
39300: NEG
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: PUSH
39306: LD_INT 1
39308: PUSH
39309: LD_INT 0
39311: PUSH
39312: EMPTY
39313: LIST
39314: LIST
39315: PUSH
39316: LD_INT 1
39318: PUSH
39319: LD_INT 1
39321: PUSH
39322: EMPTY
39323: LIST
39324: LIST
39325: PUSH
39326: LD_INT 0
39328: PUSH
39329: LD_INT 1
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: LD_INT 1
39338: NEG
39339: PUSH
39340: LD_INT 0
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 1
39349: NEG
39350: PUSH
39351: LD_INT 1
39353: NEG
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: LD_INT 1
39361: NEG
39362: PUSH
39363: LD_INT 2
39365: NEG
39366: PUSH
39367: EMPTY
39368: LIST
39369: LIST
39370: PUSH
39371: LD_INT 0
39373: PUSH
39374: LD_INT 2
39376: NEG
39377: PUSH
39378: EMPTY
39379: LIST
39380: LIST
39381: PUSH
39382: LD_INT 1
39384: PUSH
39385: LD_INT 1
39387: NEG
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: PUSH
39393: LD_INT 2
39395: PUSH
39396: LD_INT 0
39398: PUSH
39399: EMPTY
39400: LIST
39401: LIST
39402: PUSH
39403: LD_INT 2
39405: PUSH
39406: LD_INT 1
39408: PUSH
39409: EMPTY
39410: LIST
39411: LIST
39412: PUSH
39413: LD_INT 2
39415: PUSH
39416: LD_INT 2
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PUSH
39423: LD_INT 1
39425: PUSH
39426: LD_INT 2
39428: PUSH
39429: EMPTY
39430: LIST
39431: LIST
39432: PUSH
39433: LD_INT 0
39435: PUSH
39436: LD_INT 2
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 1
39445: NEG
39446: PUSH
39447: LD_INT 1
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: PUSH
39454: LD_INT 2
39456: NEG
39457: PUSH
39458: LD_INT 0
39460: PUSH
39461: EMPTY
39462: LIST
39463: LIST
39464: PUSH
39465: LD_INT 2
39467: NEG
39468: PUSH
39469: LD_INT 1
39471: NEG
39472: PUSH
39473: EMPTY
39474: LIST
39475: LIST
39476: PUSH
39477: LD_INT 2
39479: NEG
39480: PUSH
39481: LD_INT 2
39483: NEG
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: LIST
39493: LIST
39494: LIST
39495: LIST
39496: LIST
39497: LIST
39498: LIST
39499: LIST
39500: LIST
39501: LIST
39502: LIST
39503: LIST
39504: LIST
39505: LIST
39506: LIST
39507: LIST
39508: LIST
39509: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39510: LD_ADDR_VAR 0 56
39514: PUSH
39515: LD_INT 0
39517: PUSH
39518: LD_INT 0
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: PUSH
39525: LD_INT 0
39527: PUSH
39528: LD_INT 1
39530: NEG
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: LD_INT 1
39538: PUSH
39539: LD_INT 0
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: LD_INT 1
39548: PUSH
39549: LD_INT 1
39551: PUSH
39552: EMPTY
39553: LIST
39554: LIST
39555: PUSH
39556: LD_INT 0
39558: PUSH
39559: LD_INT 1
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 1
39568: NEG
39569: PUSH
39570: LD_INT 0
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: LD_INT 1
39579: NEG
39580: PUSH
39581: LD_INT 1
39583: NEG
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: PUSH
39589: LD_INT 1
39591: NEG
39592: PUSH
39593: LD_INT 2
39595: NEG
39596: PUSH
39597: EMPTY
39598: LIST
39599: LIST
39600: PUSH
39601: LD_INT 0
39603: PUSH
39604: LD_INT 2
39606: NEG
39607: PUSH
39608: EMPTY
39609: LIST
39610: LIST
39611: PUSH
39612: LD_INT 1
39614: PUSH
39615: LD_INT 1
39617: NEG
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 2
39625: PUSH
39626: LD_INT 0
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: LD_INT 2
39635: PUSH
39636: LD_INT 1
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 2
39645: PUSH
39646: LD_INT 2
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 1
39655: PUSH
39656: LD_INT 2
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 0
39665: PUSH
39666: LD_INT 2
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: LD_INT 1
39675: NEG
39676: PUSH
39677: LD_INT 1
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 2
39686: NEG
39687: PUSH
39688: LD_INT 0
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 2
39697: NEG
39698: PUSH
39699: LD_INT 1
39701: NEG
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: LD_INT 2
39709: NEG
39710: PUSH
39711: LD_INT 2
39713: NEG
39714: PUSH
39715: EMPTY
39716: LIST
39717: LIST
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: LIST
39723: LIST
39724: LIST
39725: LIST
39726: LIST
39727: LIST
39728: LIST
39729: LIST
39730: LIST
39731: LIST
39732: LIST
39733: LIST
39734: LIST
39735: LIST
39736: LIST
39737: LIST
39738: LIST
39739: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39740: LD_ADDR_VAR 0 57
39744: PUSH
39745: LD_INT 0
39747: PUSH
39748: LD_INT 0
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: PUSH
39755: LD_INT 0
39757: PUSH
39758: LD_INT 1
39760: NEG
39761: PUSH
39762: EMPTY
39763: LIST
39764: LIST
39765: PUSH
39766: LD_INT 1
39768: PUSH
39769: LD_INT 0
39771: PUSH
39772: EMPTY
39773: LIST
39774: LIST
39775: PUSH
39776: LD_INT 1
39778: PUSH
39779: LD_INT 1
39781: PUSH
39782: EMPTY
39783: LIST
39784: LIST
39785: PUSH
39786: LD_INT 0
39788: PUSH
39789: LD_INT 1
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 1
39798: NEG
39799: PUSH
39800: LD_INT 0
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: PUSH
39807: LD_INT 1
39809: NEG
39810: PUSH
39811: LD_INT 1
39813: NEG
39814: PUSH
39815: EMPTY
39816: LIST
39817: LIST
39818: PUSH
39819: LD_INT 1
39821: NEG
39822: PUSH
39823: LD_INT 2
39825: NEG
39826: PUSH
39827: EMPTY
39828: LIST
39829: LIST
39830: PUSH
39831: LD_INT 0
39833: PUSH
39834: LD_INT 2
39836: NEG
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: PUSH
39842: LD_INT 1
39844: PUSH
39845: LD_INT 1
39847: NEG
39848: PUSH
39849: EMPTY
39850: LIST
39851: LIST
39852: PUSH
39853: LD_INT 2
39855: PUSH
39856: LD_INT 0
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: LD_INT 2
39865: PUSH
39866: LD_INT 1
39868: PUSH
39869: EMPTY
39870: LIST
39871: LIST
39872: PUSH
39873: LD_INT 2
39875: PUSH
39876: LD_INT 2
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 1
39885: PUSH
39886: LD_INT 2
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: LD_INT 0
39895: PUSH
39896: LD_INT 2
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: LD_INT 1
39905: NEG
39906: PUSH
39907: LD_INT 1
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 2
39916: NEG
39917: PUSH
39918: LD_INT 0
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: PUSH
39925: LD_INT 2
39927: NEG
39928: PUSH
39929: LD_INT 1
39931: NEG
39932: PUSH
39933: EMPTY
39934: LIST
39935: LIST
39936: PUSH
39937: LD_INT 2
39939: NEG
39940: PUSH
39941: LD_INT 2
39943: NEG
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: LIST
39953: LIST
39954: LIST
39955: LIST
39956: LIST
39957: LIST
39958: LIST
39959: LIST
39960: LIST
39961: LIST
39962: LIST
39963: LIST
39964: LIST
39965: LIST
39966: LIST
39967: LIST
39968: LIST
39969: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39970: LD_ADDR_VAR 0 58
39974: PUSH
39975: LD_INT 0
39977: PUSH
39978: LD_INT 0
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: PUSH
39985: LD_INT 0
39987: PUSH
39988: LD_INT 1
39990: NEG
39991: PUSH
39992: EMPTY
39993: LIST
39994: LIST
39995: PUSH
39996: LD_INT 1
39998: PUSH
39999: LD_INT 0
40001: PUSH
40002: EMPTY
40003: LIST
40004: LIST
40005: PUSH
40006: LD_INT 1
40008: PUSH
40009: LD_INT 1
40011: PUSH
40012: EMPTY
40013: LIST
40014: LIST
40015: PUSH
40016: LD_INT 0
40018: PUSH
40019: LD_INT 1
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: LD_INT 1
40028: NEG
40029: PUSH
40030: LD_INT 0
40032: PUSH
40033: EMPTY
40034: LIST
40035: LIST
40036: PUSH
40037: LD_INT 1
40039: NEG
40040: PUSH
40041: LD_INT 1
40043: NEG
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 1
40051: NEG
40052: PUSH
40053: LD_INT 2
40055: NEG
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PUSH
40061: LD_INT 0
40063: PUSH
40064: LD_INT 2
40066: NEG
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 1
40074: PUSH
40075: LD_INT 1
40077: NEG
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 2
40085: PUSH
40086: LD_INT 0
40088: PUSH
40089: EMPTY
40090: LIST
40091: LIST
40092: PUSH
40093: LD_INT 2
40095: PUSH
40096: LD_INT 1
40098: PUSH
40099: EMPTY
40100: LIST
40101: LIST
40102: PUSH
40103: LD_INT 2
40105: PUSH
40106: LD_INT 2
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: PUSH
40113: LD_INT 1
40115: PUSH
40116: LD_INT 2
40118: PUSH
40119: EMPTY
40120: LIST
40121: LIST
40122: PUSH
40123: LD_INT 0
40125: PUSH
40126: LD_INT 2
40128: PUSH
40129: EMPTY
40130: LIST
40131: LIST
40132: PUSH
40133: LD_INT 1
40135: NEG
40136: PUSH
40137: LD_INT 1
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 2
40146: NEG
40147: PUSH
40148: LD_INT 0
40150: PUSH
40151: EMPTY
40152: LIST
40153: LIST
40154: PUSH
40155: LD_INT 2
40157: NEG
40158: PUSH
40159: LD_INT 1
40161: NEG
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: PUSH
40167: LD_INT 2
40169: NEG
40170: PUSH
40171: LD_INT 2
40173: NEG
40174: PUSH
40175: EMPTY
40176: LIST
40177: LIST
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: LIST
40183: LIST
40184: LIST
40185: LIST
40186: LIST
40187: LIST
40188: LIST
40189: LIST
40190: LIST
40191: LIST
40192: LIST
40193: LIST
40194: LIST
40195: LIST
40196: LIST
40197: LIST
40198: LIST
40199: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40200: LD_ADDR_VAR 0 59
40204: PUSH
40205: LD_INT 0
40207: PUSH
40208: LD_INT 0
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: PUSH
40215: LD_INT 0
40217: PUSH
40218: LD_INT 1
40220: NEG
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: PUSH
40226: LD_INT 1
40228: PUSH
40229: LD_INT 0
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: LD_INT 1
40238: PUSH
40239: LD_INT 1
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: LD_INT 0
40248: PUSH
40249: LD_INT 1
40251: PUSH
40252: EMPTY
40253: LIST
40254: LIST
40255: PUSH
40256: LD_INT 1
40258: NEG
40259: PUSH
40260: LD_INT 0
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: PUSH
40267: LD_INT 1
40269: NEG
40270: PUSH
40271: LD_INT 1
40273: NEG
40274: PUSH
40275: EMPTY
40276: LIST
40277: LIST
40278: PUSH
40279: EMPTY
40280: LIST
40281: LIST
40282: LIST
40283: LIST
40284: LIST
40285: LIST
40286: LIST
40287: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40288: LD_ADDR_VAR 0 60
40292: PUSH
40293: LD_INT 0
40295: PUSH
40296: LD_INT 0
40298: PUSH
40299: EMPTY
40300: LIST
40301: LIST
40302: PUSH
40303: LD_INT 0
40305: PUSH
40306: LD_INT 1
40308: NEG
40309: PUSH
40310: EMPTY
40311: LIST
40312: LIST
40313: PUSH
40314: LD_INT 1
40316: PUSH
40317: LD_INT 0
40319: PUSH
40320: EMPTY
40321: LIST
40322: LIST
40323: PUSH
40324: LD_INT 1
40326: PUSH
40327: LD_INT 1
40329: PUSH
40330: EMPTY
40331: LIST
40332: LIST
40333: PUSH
40334: LD_INT 0
40336: PUSH
40337: LD_INT 1
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: PUSH
40344: LD_INT 1
40346: NEG
40347: PUSH
40348: LD_INT 0
40350: PUSH
40351: EMPTY
40352: LIST
40353: LIST
40354: PUSH
40355: LD_INT 1
40357: NEG
40358: PUSH
40359: LD_INT 1
40361: NEG
40362: PUSH
40363: EMPTY
40364: LIST
40365: LIST
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: LIST
40371: LIST
40372: LIST
40373: LIST
40374: LIST
40375: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40376: LD_ADDR_VAR 0 61
40380: PUSH
40381: LD_INT 0
40383: PUSH
40384: LD_INT 0
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 0
40393: PUSH
40394: LD_INT 1
40396: NEG
40397: PUSH
40398: EMPTY
40399: LIST
40400: LIST
40401: PUSH
40402: LD_INT 1
40404: PUSH
40405: LD_INT 0
40407: PUSH
40408: EMPTY
40409: LIST
40410: LIST
40411: PUSH
40412: LD_INT 1
40414: PUSH
40415: LD_INT 1
40417: PUSH
40418: EMPTY
40419: LIST
40420: LIST
40421: PUSH
40422: LD_INT 0
40424: PUSH
40425: LD_INT 1
40427: PUSH
40428: EMPTY
40429: LIST
40430: LIST
40431: PUSH
40432: LD_INT 1
40434: NEG
40435: PUSH
40436: LD_INT 0
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: PUSH
40443: LD_INT 1
40445: NEG
40446: PUSH
40447: LD_INT 1
40449: NEG
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: LIST
40459: LIST
40460: LIST
40461: LIST
40462: LIST
40463: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40464: LD_ADDR_VAR 0 62
40468: PUSH
40469: LD_INT 0
40471: PUSH
40472: LD_INT 0
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: PUSH
40479: LD_INT 0
40481: PUSH
40482: LD_INT 1
40484: NEG
40485: PUSH
40486: EMPTY
40487: LIST
40488: LIST
40489: PUSH
40490: LD_INT 1
40492: PUSH
40493: LD_INT 0
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: PUSH
40500: LD_INT 1
40502: PUSH
40503: LD_INT 1
40505: PUSH
40506: EMPTY
40507: LIST
40508: LIST
40509: PUSH
40510: LD_INT 0
40512: PUSH
40513: LD_INT 1
40515: PUSH
40516: EMPTY
40517: LIST
40518: LIST
40519: PUSH
40520: LD_INT 1
40522: NEG
40523: PUSH
40524: LD_INT 0
40526: PUSH
40527: EMPTY
40528: LIST
40529: LIST
40530: PUSH
40531: LD_INT 1
40533: NEG
40534: PUSH
40535: LD_INT 1
40537: NEG
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: LIST
40549: LIST
40550: LIST
40551: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40552: LD_ADDR_VAR 0 63
40556: PUSH
40557: LD_INT 0
40559: PUSH
40560: LD_INT 0
40562: PUSH
40563: EMPTY
40564: LIST
40565: LIST
40566: PUSH
40567: LD_INT 0
40569: PUSH
40570: LD_INT 1
40572: NEG
40573: PUSH
40574: EMPTY
40575: LIST
40576: LIST
40577: PUSH
40578: LD_INT 1
40580: PUSH
40581: LD_INT 0
40583: PUSH
40584: EMPTY
40585: LIST
40586: LIST
40587: PUSH
40588: LD_INT 1
40590: PUSH
40591: LD_INT 1
40593: PUSH
40594: EMPTY
40595: LIST
40596: LIST
40597: PUSH
40598: LD_INT 0
40600: PUSH
40601: LD_INT 1
40603: PUSH
40604: EMPTY
40605: LIST
40606: LIST
40607: PUSH
40608: LD_INT 1
40610: NEG
40611: PUSH
40612: LD_INT 0
40614: PUSH
40615: EMPTY
40616: LIST
40617: LIST
40618: PUSH
40619: LD_INT 1
40621: NEG
40622: PUSH
40623: LD_INT 1
40625: NEG
40626: PUSH
40627: EMPTY
40628: LIST
40629: LIST
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: LIST
40635: LIST
40636: LIST
40637: LIST
40638: LIST
40639: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40640: LD_ADDR_VAR 0 64
40644: PUSH
40645: LD_INT 0
40647: PUSH
40648: LD_INT 0
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 0
40657: PUSH
40658: LD_INT 1
40660: NEG
40661: PUSH
40662: EMPTY
40663: LIST
40664: LIST
40665: PUSH
40666: LD_INT 1
40668: PUSH
40669: LD_INT 0
40671: PUSH
40672: EMPTY
40673: LIST
40674: LIST
40675: PUSH
40676: LD_INT 1
40678: PUSH
40679: LD_INT 1
40681: PUSH
40682: EMPTY
40683: LIST
40684: LIST
40685: PUSH
40686: LD_INT 0
40688: PUSH
40689: LD_INT 1
40691: PUSH
40692: EMPTY
40693: LIST
40694: LIST
40695: PUSH
40696: LD_INT 1
40698: NEG
40699: PUSH
40700: LD_INT 0
40702: PUSH
40703: EMPTY
40704: LIST
40705: LIST
40706: PUSH
40707: LD_INT 1
40709: NEG
40710: PUSH
40711: LD_INT 1
40713: NEG
40714: PUSH
40715: EMPTY
40716: LIST
40717: LIST
40718: PUSH
40719: EMPTY
40720: LIST
40721: LIST
40722: LIST
40723: LIST
40724: LIST
40725: LIST
40726: LIST
40727: ST_TO_ADDR
// end ; 1 :
40728: GO 46625
40730: LD_INT 1
40732: DOUBLE
40733: EQUAL
40734: IFTRUE 40738
40736: GO 43361
40738: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40739: LD_ADDR_VAR 0 11
40743: PUSH
40744: LD_INT 1
40746: NEG
40747: PUSH
40748: LD_INT 3
40750: NEG
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: PUSH
40756: LD_INT 0
40758: PUSH
40759: LD_INT 3
40761: NEG
40762: PUSH
40763: EMPTY
40764: LIST
40765: LIST
40766: PUSH
40767: LD_INT 1
40769: PUSH
40770: LD_INT 2
40772: NEG
40773: PUSH
40774: EMPTY
40775: LIST
40776: LIST
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: LIST
40782: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40783: LD_ADDR_VAR 0 12
40787: PUSH
40788: LD_INT 2
40790: PUSH
40791: LD_INT 1
40793: NEG
40794: PUSH
40795: EMPTY
40796: LIST
40797: LIST
40798: PUSH
40799: LD_INT 3
40801: PUSH
40802: LD_INT 0
40804: PUSH
40805: EMPTY
40806: LIST
40807: LIST
40808: PUSH
40809: LD_INT 3
40811: PUSH
40812: LD_INT 1
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: LIST
40823: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40824: LD_ADDR_VAR 0 13
40828: PUSH
40829: LD_INT 3
40831: PUSH
40832: LD_INT 2
40834: PUSH
40835: EMPTY
40836: LIST
40837: LIST
40838: PUSH
40839: LD_INT 3
40841: PUSH
40842: LD_INT 3
40844: PUSH
40845: EMPTY
40846: LIST
40847: LIST
40848: PUSH
40849: LD_INT 2
40851: PUSH
40852: LD_INT 3
40854: PUSH
40855: EMPTY
40856: LIST
40857: LIST
40858: PUSH
40859: EMPTY
40860: LIST
40861: LIST
40862: LIST
40863: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40864: LD_ADDR_VAR 0 14
40868: PUSH
40869: LD_INT 1
40871: PUSH
40872: LD_INT 3
40874: PUSH
40875: EMPTY
40876: LIST
40877: LIST
40878: PUSH
40879: LD_INT 0
40881: PUSH
40882: LD_INT 3
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 1
40891: NEG
40892: PUSH
40893: LD_INT 2
40895: PUSH
40896: EMPTY
40897: LIST
40898: LIST
40899: PUSH
40900: EMPTY
40901: LIST
40902: LIST
40903: LIST
40904: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40905: LD_ADDR_VAR 0 15
40909: PUSH
40910: LD_INT 2
40912: NEG
40913: PUSH
40914: LD_INT 1
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: LD_INT 3
40923: NEG
40924: PUSH
40925: LD_INT 0
40927: PUSH
40928: EMPTY
40929: LIST
40930: LIST
40931: PUSH
40932: LD_INT 3
40934: NEG
40935: PUSH
40936: LD_INT 1
40938: NEG
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: EMPTY
40945: LIST
40946: LIST
40947: LIST
40948: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40949: LD_ADDR_VAR 0 16
40953: PUSH
40954: LD_INT 2
40956: NEG
40957: PUSH
40958: LD_INT 3
40960: NEG
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 3
40968: NEG
40969: PUSH
40970: LD_INT 2
40972: NEG
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: PUSH
40978: LD_INT 3
40980: NEG
40981: PUSH
40982: LD_INT 3
40984: NEG
40985: PUSH
40986: EMPTY
40987: LIST
40988: LIST
40989: PUSH
40990: EMPTY
40991: LIST
40992: LIST
40993: LIST
40994: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40995: LD_ADDR_VAR 0 17
40999: PUSH
41000: LD_INT 1
41002: NEG
41003: PUSH
41004: LD_INT 3
41006: NEG
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: PUSH
41012: LD_INT 0
41014: PUSH
41015: LD_INT 3
41017: NEG
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: PUSH
41023: LD_INT 1
41025: PUSH
41026: LD_INT 2
41028: NEG
41029: PUSH
41030: EMPTY
41031: LIST
41032: LIST
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: LIST
41038: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41039: LD_ADDR_VAR 0 18
41043: PUSH
41044: LD_INT 2
41046: PUSH
41047: LD_INT 1
41049: NEG
41050: PUSH
41051: EMPTY
41052: LIST
41053: LIST
41054: PUSH
41055: LD_INT 3
41057: PUSH
41058: LD_INT 0
41060: PUSH
41061: EMPTY
41062: LIST
41063: LIST
41064: PUSH
41065: LD_INT 3
41067: PUSH
41068: LD_INT 1
41070: PUSH
41071: EMPTY
41072: LIST
41073: LIST
41074: PUSH
41075: EMPTY
41076: LIST
41077: LIST
41078: LIST
41079: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41080: LD_ADDR_VAR 0 19
41084: PUSH
41085: LD_INT 3
41087: PUSH
41088: LD_INT 2
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: PUSH
41095: LD_INT 3
41097: PUSH
41098: LD_INT 3
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: LD_INT 2
41107: PUSH
41108: LD_INT 3
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: LIST
41119: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41120: LD_ADDR_VAR 0 20
41124: PUSH
41125: LD_INT 1
41127: PUSH
41128: LD_INT 3
41130: PUSH
41131: EMPTY
41132: LIST
41133: LIST
41134: PUSH
41135: LD_INT 0
41137: PUSH
41138: LD_INT 3
41140: PUSH
41141: EMPTY
41142: LIST
41143: LIST
41144: PUSH
41145: LD_INT 1
41147: NEG
41148: PUSH
41149: LD_INT 2
41151: PUSH
41152: EMPTY
41153: LIST
41154: LIST
41155: PUSH
41156: EMPTY
41157: LIST
41158: LIST
41159: LIST
41160: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41161: LD_ADDR_VAR 0 21
41165: PUSH
41166: LD_INT 2
41168: NEG
41169: PUSH
41170: LD_INT 1
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 3
41179: NEG
41180: PUSH
41181: LD_INT 0
41183: PUSH
41184: EMPTY
41185: LIST
41186: LIST
41187: PUSH
41188: LD_INT 3
41190: NEG
41191: PUSH
41192: LD_INT 1
41194: NEG
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: LIST
41204: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41205: LD_ADDR_VAR 0 22
41209: PUSH
41210: LD_INT 2
41212: NEG
41213: PUSH
41214: LD_INT 3
41216: NEG
41217: PUSH
41218: EMPTY
41219: LIST
41220: LIST
41221: PUSH
41222: LD_INT 3
41224: NEG
41225: PUSH
41226: LD_INT 2
41228: NEG
41229: PUSH
41230: EMPTY
41231: LIST
41232: LIST
41233: PUSH
41234: LD_INT 3
41236: NEG
41237: PUSH
41238: LD_INT 3
41240: NEG
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: PUSH
41246: EMPTY
41247: LIST
41248: LIST
41249: LIST
41250: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41251: LD_ADDR_VAR 0 23
41255: PUSH
41256: LD_INT 0
41258: PUSH
41259: LD_INT 3
41261: NEG
41262: PUSH
41263: EMPTY
41264: LIST
41265: LIST
41266: PUSH
41267: LD_INT 1
41269: NEG
41270: PUSH
41271: LD_INT 4
41273: NEG
41274: PUSH
41275: EMPTY
41276: LIST
41277: LIST
41278: PUSH
41279: LD_INT 1
41281: PUSH
41282: LD_INT 3
41284: NEG
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: PUSH
41290: EMPTY
41291: LIST
41292: LIST
41293: LIST
41294: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41295: LD_ADDR_VAR 0 24
41299: PUSH
41300: LD_INT 3
41302: PUSH
41303: LD_INT 0
41305: PUSH
41306: EMPTY
41307: LIST
41308: LIST
41309: PUSH
41310: LD_INT 3
41312: PUSH
41313: LD_INT 1
41315: NEG
41316: PUSH
41317: EMPTY
41318: LIST
41319: LIST
41320: PUSH
41321: LD_INT 4
41323: PUSH
41324: LD_INT 1
41326: PUSH
41327: EMPTY
41328: LIST
41329: LIST
41330: PUSH
41331: EMPTY
41332: LIST
41333: LIST
41334: LIST
41335: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41336: LD_ADDR_VAR 0 25
41340: PUSH
41341: LD_INT 3
41343: PUSH
41344: LD_INT 3
41346: PUSH
41347: EMPTY
41348: LIST
41349: LIST
41350: PUSH
41351: LD_INT 4
41353: PUSH
41354: LD_INT 3
41356: PUSH
41357: EMPTY
41358: LIST
41359: LIST
41360: PUSH
41361: LD_INT 3
41363: PUSH
41364: LD_INT 4
41366: PUSH
41367: EMPTY
41368: LIST
41369: LIST
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: LIST
41375: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41376: LD_ADDR_VAR 0 26
41380: PUSH
41381: LD_INT 0
41383: PUSH
41384: LD_INT 3
41386: PUSH
41387: EMPTY
41388: LIST
41389: LIST
41390: PUSH
41391: LD_INT 1
41393: PUSH
41394: LD_INT 4
41396: PUSH
41397: EMPTY
41398: LIST
41399: LIST
41400: PUSH
41401: LD_INT 1
41403: NEG
41404: PUSH
41405: LD_INT 3
41407: PUSH
41408: EMPTY
41409: LIST
41410: LIST
41411: PUSH
41412: EMPTY
41413: LIST
41414: LIST
41415: LIST
41416: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41417: LD_ADDR_VAR 0 27
41421: PUSH
41422: LD_INT 3
41424: NEG
41425: PUSH
41426: LD_INT 0
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PUSH
41433: LD_INT 3
41435: NEG
41436: PUSH
41437: LD_INT 1
41439: PUSH
41440: EMPTY
41441: LIST
41442: LIST
41443: PUSH
41444: LD_INT 4
41446: NEG
41447: PUSH
41448: LD_INT 1
41450: NEG
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: LIST
41460: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41461: LD_ADDR_VAR 0 28
41465: PUSH
41466: LD_INT 3
41468: NEG
41469: PUSH
41470: LD_INT 3
41472: NEG
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 3
41480: NEG
41481: PUSH
41482: LD_INT 4
41484: NEG
41485: PUSH
41486: EMPTY
41487: LIST
41488: LIST
41489: PUSH
41490: LD_INT 4
41492: NEG
41493: PUSH
41494: LD_INT 3
41496: NEG
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: PUSH
41502: EMPTY
41503: LIST
41504: LIST
41505: LIST
41506: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41507: LD_ADDR_VAR 0 29
41511: PUSH
41512: LD_INT 1
41514: NEG
41515: PUSH
41516: LD_INT 3
41518: NEG
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: PUSH
41524: LD_INT 0
41526: PUSH
41527: LD_INT 3
41529: NEG
41530: PUSH
41531: EMPTY
41532: LIST
41533: LIST
41534: PUSH
41535: LD_INT 1
41537: PUSH
41538: LD_INT 2
41540: NEG
41541: PUSH
41542: EMPTY
41543: LIST
41544: LIST
41545: PUSH
41546: LD_INT 1
41548: NEG
41549: PUSH
41550: LD_INT 4
41552: NEG
41553: PUSH
41554: EMPTY
41555: LIST
41556: LIST
41557: PUSH
41558: LD_INT 0
41560: PUSH
41561: LD_INT 4
41563: NEG
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PUSH
41569: LD_INT 1
41571: PUSH
41572: LD_INT 3
41574: NEG
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PUSH
41580: LD_INT 1
41582: NEG
41583: PUSH
41584: LD_INT 5
41586: NEG
41587: PUSH
41588: EMPTY
41589: LIST
41590: LIST
41591: PUSH
41592: LD_INT 0
41594: PUSH
41595: LD_INT 5
41597: NEG
41598: PUSH
41599: EMPTY
41600: LIST
41601: LIST
41602: PUSH
41603: LD_INT 1
41605: PUSH
41606: LD_INT 4
41608: NEG
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: PUSH
41614: LD_INT 1
41616: NEG
41617: PUSH
41618: LD_INT 6
41620: NEG
41621: PUSH
41622: EMPTY
41623: LIST
41624: LIST
41625: PUSH
41626: LD_INT 0
41628: PUSH
41629: LD_INT 6
41631: NEG
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: PUSH
41637: LD_INT 1
41639: PUSH
41640: LD_INT 5
41642: NEG
41643: PUSH
41644: EMPTY
41645: LIST
41646: LIST
41647: PUSH
41648: EMPTY
41649: LIST
41650: LIST
41651: LIST
41652: LIST
41653: LIST
41654: LIST
41655: LIST
41656: LIST
41657: LIST
41658: LIST
41659: LIST
41660: LIST
41661: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41662: LD_ADDR_VAR 0 30
41666: PUSH
41667: LD_INT 2
41669: PUSH
41670: LD_INT 1
41672: NEG
41673: PUSH
41674: EMPTY
41675: LIST
41676: LIST
41677: PUSH
41678: LD_INT 3
41680: PUSH
41681: LD_INT 0
41683: PUSH
41684: EMPTY
41685: LIST
41686: LIST
41687: PUSH
41688: LD_INT 3
41690: PUSH
41691: LD_INT 1
41693: PUSH
41694: EMPTY
41695: LIST
41696: LIST
41697: PUSH
41698: LD_INT 3
41700: PUSH
41701: LD_INT 1
41703: NEG
41704: PUSH
41705: EMPTY
41706: LIST
41707: LIST
41708: PUSH
41709: LD_INT 4
41711: PUSH
41712: LD_INT 0
41714: PUSH
41715: EMPTY
41716: LIST
41717: LIST
41718: PUSH
41719: LD_INT 4
41721: PUSH
41722: LD_INT 1
41724: PUSH
41725: EMPTY
41726: LIST
41727: LIST
41728: PUSH
41729: LD_INT 4
41731: PUSH
41732: LD_INT 1
41734: NEG
41735: PUSH
41736: EMPTY
41737: LIST
41738: LIST
41739: PUSH
41740: LD_INT 5
41742: PUSH
41743: LD_INT 0
41745: PUSH
41746: EMPTY
41747: LIST
41748: LIST
41749: PUSH
41750: LD_INT 5
41752: PUSH
41753: LD_INT 1
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 5
41762: PUSH
41763: LD_INT 1
41765: NEG
41766: PUSH
41767: EMPTY
41768: LIST
41769: LIST
41770: PUSH
41771: LD_INT 6
41773: PUSH
41774: LD_INT 0
41776: PUSH
41777: EMPTY
41778: LIST
41779: LIST
41780: PUSH
41781: LD_INT 6
41783: PUSH
41784: LD_INT 1
41786: PUSH
41787: EMPTY
41788: LIST
41789: LIST
41790: PUSH
41791: EMPTY
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: LIST
41800: LIST
41801: LIST
41802: LIST
41803: LIST
41804: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41805: LD_ADDR_VAR 0 31
41809: PUSH
41810: LD_INT 3
41812: PUSH
41813: LD_INT 2
41815: PUSH
41816: EMPTY
41817: LIST
41818: LIST
41819: PUSH
41820: LD_INT 3
41822: PUSH
41823: LD_INT 3
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 2
41832: PUSH
41833: LD_INT 3
41835: PUSH
41836: EMPTY
41837: LIST
41838: LIST
41839: PUSH
41840: LD_INT 4
41842: PUSH
41843: LD_INT 3
41845: PUSH
41846: EMPTY
41847: LIST
41848: LIST
41849: PUSH
41850: LD_INT 4
41852: PUSH
41853: LD_INT 4
41855: PUSH
41856: EMPTY
41857: LIST
41858: LIST
41859: PUSH
41860: LD_INT 3
41862: PUSH
41863: LD_INT 4
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PUSH
41870: LD_INT 5
41872: PUSH
41873: LD_INT 4
41875: PUSH
41876: EMPTY
41877: LIST
41878: LIST
41879: PUSH
41880: LD_INT 5
41882: PUSH
41883: LD_INT 5
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PUSH
41890: LD_INT 4
41892: PUSH
41893: LD_INT 5
41895: PUSH
41896: EMPTY
41897: LIST
41898: LIST
41899: PUSH
41900: LD_INT 6
41902: PUSH
41903: LD_INT 5
41905: PUSH
41906: EMPTY
41907: LIST
41908: LIST
41909: PUSH
41910: LD_INT 6
41912: PUSH
41913: LD_INT 6
41915: PUSH
41916: EMPTY
41917: LIST
41918: LIST
41919: PUSH
41920: LD_INT 5
41922: PUSH
41923: LD_INT 6
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: LIST
41934: LIST
41935: LIST
41936: LIST
41937: LIST
41938: LIST
41939: LIST
41940: LIST
41941: LIST
41942: LIST
41943: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41944: LD_ADDR_VAR 0 32
41948: PUSH
41949: LD_INT 1
41951: PUSH
41952: LD_INT 3
41954: PUSH
41955: EMPTY
41956: LIST
41957: LIST
41958: PUSH
41959: LD_INT 0
41961: PUSH
41962: LD_INT 3
41964: PUSH
41965: EMPTY
41966: LIST
41967: LIST
41968: PUSH
41969: LD_INT 1
41971: NEG
41972: PUSH
41973: LD_INT 2
41975: PUSH
41976: EMPTY
41977: LIST
41978: LIST
41979: PUSH
41980: LD_INT 1
41982: PUSH
41983: LD_INT 4
41985: PUSH
41986: EMPTY
41987: LIST
41988: LIST
41989: PUSH
41990: LD_INT 0
41992: PUSH
41993: LD_INT 4
41995: PUSH
41996: EMPTY
41997: LIST
41998: LIST
41999: PUSH
42000: LD_INT 1
42002: NEG
42003: PUSH
42004: LD_INT 3
42006: PUSH
42007: EMPTY
42008: LIST
42009: LIST
42010: PUSH
42011: LD_INT 1
42013: PUSH
42014: LD_INT 5
42016: PUSH
42017: EMPTY
42018: LIST
42019: LIST
42020: PUSH
42021: LD_INT 0
42023: PUSH
42024: LD_INT 5
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: PUSH
42031: LD_INT 1
42033: NEG
42034: PUSH
42035: LD_INT 4
42037: PUSH
42038: EMPTY
42039: LIST
42040: LIST
42041: PUSH
42042: LD_INT 1
42044: PUSH
42045: LD_INT 6
42047: PUSH
42048: EMPTY
42049: LIST
42050: LIST
42051: PUSH
42052: LD_INT 0
42054: PUSH
42055: LD_INT 6
42057: PUSH
42058: EMPTY
42059: LIST
42060: LIST
42061: PUSH
42062: LD_INT 1
42064: NEG
42065: PUSH
42066: LD_INT 5
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: PUSH
42073: EMPTY
42074: LIST
42075: LIST
42076: LIST
42077: LIST
42078: LIST
42079: LIST
42080: LIST
42081: LIST
42082: LIST
42083: LIST
42084: LIST
42085: LIST
42086: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42087: LD_ADDR_VAR 0 33
42091: PUSH
42092: LD_INT 2
42094: NEG
42095: PUSH
42096: LD_INT 1
42098: PUSH
42099: EMPTY
42100: LIST
42101: LIST
42102: PUSH
42103: LD_INT 3
42105: NEG
42106: PUSH
42107: LD_INT 0
42109: PUSH
42110: EMPTY
42111: LIST
42112: LIST
42113: PUSH
42114: LD_INT 3
42116: NEG
42117: PUSH
42118: LD_INT 1
42120: NEG
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: PUSH
42126: LD_INT 3
42128: NEG
42129: PUSH
42130: LD_INT 1
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: PUSH
42137: LD_INT 4
42139: NEG
42140: PUSH
42141: LD_INT 0
42143: PUSH
42144: EMPTY
42145: LIST
42146: LIST
42147: PUSH
42148: LD_INT 4
42150: NEG
42151: PUSH
42152: LD_INT 1
42154: NEG
42155: PUSH
42156: EMPTY
42157: LIST
42158: LIST
42159: PUSH
42160: LD_INT 4
42162: NEG
42163: PUSH
42164: LD_INT 1
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 5
42173: NEG
42174: PUSH
42175: LD_INT 0
42177: PUSH
42178: EMPTY
42179: LIST
42180: LIST
42181: PUSH
42182: LD_INT 5
42184: NEG
42185: PUSH
42186: LD_INT 1
42188: NEG
42189: PUSH
42190: EMPTY
42191: LIST
42192: LIST
42193: PUSH
42194: LD_INT 5
42196: NEG
42197: PUSH
42198: LD_INT 1
42200: PUSH
42201: EMPTY
42202: LIST
42203: LIST
42204: PUSH
42205: LD_INT 6
42207: NEG
42208: PUSH
42209: LD_INT 0
42211: PUSH
42212: EMPTY
42213: LIST
42214: LIST
42215: PUSH
42216: LD_INT 6
42218: NEG
42219: PUSH
42220: LD_INT 1
42222: NEG
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: PUSH
42228: EMPTY
42229: LIST
42230: LIST
42231: LIST
42232: LIST
42233: LIST
42234: LIST
42235: LIST
42236: LIST
42237: LIST
42238: LIST
42239: LIST
42240: LIST
42241: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42242: LD_ADDR_VAR 0 34
42246: PUSH
42247: LD_INT 2
42249: NEG
42250: PUSH
42251: LD_INT 3
42253: NEG
42254: PUSH
42255: EMPTY
42256: LIST
42257: LIST
42258: PUSH
42259: LD_INT 3
42261: NEG
42262: PUSH
42263: LD_INT 2
42265: NEG
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: PUSH
42271: LD_INT 3
42273: NEG
42274: PUSH
42275: LD_INT 3
42277: NEG
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: LD_INT 3
42285: NEG
42286: PUSH
42287: LD_INT 4
42289: NEG
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PUSH
42295: LD_INT 4
42297: NEG
42298: PUSH
42299: LD_INT 3
42301: NEG
42302: PUSH
42303: EMPTY
42304: LIST
42305: LIST
42306: PUSH
42307: LD_INT 4
42309: NEG
42310: PUSH
42311: LD_INT 4
42313: NEG
42314: PUSH
42315: EMPTY
42316: LIST
42317: LIST
42318: PUSH
42319: LD_INT 4
42321: NEG
42322: PUSH
42323: LD_INT 5
42325: NEG
42326: PUSH
42327: EMPTY
42328: LIST
42329: LIST
42330: PUSH
42331: LD_INT 5
42333: NEG
42334: PUSH
42335: LD_INT 4
42337: NEG
42338: PUSH
42339: EMPTY
42340: LIST
42341: LIST
42342: PUSH
42343: LD_INT 5
42345: NEG
42346: PUSH
42347: LD_INT 5
42349: NEG
42350: PUSH
42351: EMPTY
42352: LIST
42353: LIST
42354: PUSH
42355: LD_INT 5
42357: NEG
42358: PUSH
42359: LD_INT 6
42361: NEG
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: PUSH
42367: LD_INT 6
42369: NEG
42370: PUSH
42371: LD_INT 5
42373: NEG
42374: PUSH
42375: EMPTY
42376: LIST
42377: LIST
42378: PUSH
42379: LD_INT 6
42381: NEG
42382: PUSH
42383: LD_INT 6
42385: NEG
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: LIST
42395: LIST
42396: LIST
42397: LIST
42398: LIST
42399: LIST
42400: LIST
42401: LIST
42402: LIST
42403: LIST
42404: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42405: LD_ADDR_VAR 0 41
42409: PUSH
42410: LD_INT 0
42412: PUSH
42413: LD_INT 2
42415: NEG
42416: PUSH
42417: EMPTY
42418: LIST
42419: LIST
42420: PUSH
42421: LD_INT 1
42423: NEG
42424: PUSH
42425: LD_INT 3
42427: NEG
42428: PUSH
42429: EMPTY
42430: LIST
42431: LIST
42432: PUSH
42433: LD_INT 1
42435: PUSH
42436: LD_INT 2
42438: NEG
42439: PUSH
42440: EMPTY
42441: LIST
42442: LIST
42443: PUSH
42444: EMPTY
42445: LIST
42446: LIST
42447: LIST
42448: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42449: LD_ADDR_VAR 0 42
42453: PUSH
42454: LD_INT 2
42456: PUSH
42457: LD_INT 0
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: LD_INT 2
42466: PUSH
42467: LD_INT 1
42469: NEG
42470: PUSH
42471: EMPTY
42472: LIST
42473: LIST
42474: PUSH
42475: LD_INT 3
42477: PUSH
42478: LD_INT 1
42480: PUSH
42481: EMPTY
42482: LIST
42483: LIST
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: LIST
42489: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42490: LD_ADDR_VAR 0 43
42494: PUSH
42495: LD_INT 2
42497: PUSH
42498: LD_INT 2
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 3
42507: PUSH
42508: LD_INT 2
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: LD_INT 2
42517: PUSH
42518: LD_INT 3
42520: PUSH
42521: EMPTY
42522: LIST
42523: LIST
42524: PUSH
42525: EMPTY
42526: LIST
42527: LIST
42528: LIST
42529: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42530: LD_ADDR_VAR 0 44
42534: PUSH
42535: LD_INT 0
42537: PUSH
42538: LD_INT 2
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: PUSH
42545: LD_INT 1
42547: PUSH
42548: LD_INT 3
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: PUSH
42555: LD_INT 1
42557: NEG
42558: PUSH
42559: LD_INT 2
42561: PUSH
42562: EMPTY
42563: LIST
42564: LIST
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: LIST
42570: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42571: LD_ADDR_VAR 0 45
42575: PUSH
42576: LD_INT 2
42578: NEG
42579: PUSH
42580: LD_INT 0
42582: PUSH
42583: EMPTY
42584: LIST
42585: LIST
42586: PUSH
42587: LD_INT 2
42589: NEG
42590: PUSH
42591: LD_INT 1
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: LD_INT 3
42600: NEG
42601: PUSH
42602: LD_INT 1
42604: NEG
42605: PUSH
42606: EMPTY
42607: LIST
42608: LIST
42609: PUSH
42610: EMPTY
42611: LIST
42612: LIST
42613: LIST
42614: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42615: LD_ADDR_VAR 0 46
42619: PUSH
42620: LD_INT 2
42622: NEG
42623: PUSH
42624: LD_INT 2
42626: NEG
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: PUSH
42632: LD_INT 2
42634: NEG
42635: PUSH
42636: LD_INT 3
42638: NEG
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: LD_INT 3
42646: NEG
42647: PUSH
42648: LD_INT 2
42650: NEG
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: PUSH
42656: EMPTY
42657: LIST
42658: LIST
42659: LIST
42660: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42661: LD_ADDR_VAR 0 47
42665: PUSH
42666: LD_INT 2
42668: NEG
42669: PUSH
42670: LD_INT 3
42672: NEG
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PUSH
42678: LD_INT 1
42680: NEG
42681: PUSH
42682: LD_INT 3
42684: NEG
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42694: LD_ADDR_VAR 0 48
42698: PUSH
42699: LD_INT 1
42701: PUSH
42702: LD_INT 2
42704: NEG
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: PUSH
42710: LD_INT 2
42712: PUSH
42713: LD_INT 1
42715: NEG
42716: PUSH
42717: EMPTY
42718: LIST
42719: LIST
42720: PUSH
42721: EMPTY
42722: LIST
42723: LIST
42724: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42725: LD_ADDR_VAR 0 49
42729: PUSH
42730: LD_INT 3
42732: PUSH
42733: LD_INT 1
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: PUSH
42740: LD_INT 3
42742: PUSH
42743: LD_INT 2
42745: PUSH
42746: EMPTY
42747: LIST
42748: LIST
42749: PUSH
42750: EMPTY
42751: LIST
42752: LIST
42753: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42754: LD_ADDR_VAR 0 50
42758: PUSH
42759: LD_INT 2
42761: PUSH
42762: LD_INT 3
42764: PUSH
42765: EMPTY
42766: LIST
42767: LIST
42768: PUSH
42769: LD_INT 1
42771: PUSH
42772: LD_INT 3
42774: PUSH
42775: EMPTY
42776: LIST
42777: LIST
42778: PUSH
42779: EMPTY
42780: LIST
42781: LIST
42782: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42783: LD_ADDR_VAR 0 51
42787: PUSH
42788: LD_INT 1
42790: NEG
42791: PUSH
42792: LD_INT 2
42794: PUSH
42795: EMPTY
42796: LIST
42797: LIST
42798: PUSH
42799: LD_INT 2
42801: NEG
42802: PUSH
42803: LD_INT 1
42805: PUSH
42806: EMPTY
42807: LIST
42808: LIST
42809: PUSH
42810: EMPTY
42811: LIST
42812: LIST
42813: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42814: LD_ADDR_VAR 0 52
42818: PUSH
42819: LD_INT 3
42821: NEG
42822: PUSH
42823: LD_INT 1
42825: NEG
42826: PUSH
42827: EMPTY
42828: LIST
42829: LIST
42830: PUSH
42831: LD_INT 3
42833: NEG
42834: PUSH
42835: LD_INT 2
42837: NEG
42838: PUSH
42839: EMPTY
42840: LIST
42841: LIST
42842: PUSH
42843: EMPTY
42844: LIST
42845: LIST
42846: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42847: LD_ADDR_VAR 0 53
42851: PUSH
42852: LD_INT 1
42854: NEG
42855: PUSH
42856: LD_INT 3
42858: NEG
42859: PUSH
42860: EMPTY
42861: LIST
42862: LIST
42863: PUSH
42864: LD_INT 0
42866: PUSH
42867: LD_INT 3
42869: NEG
42870: PUSH
42871: EMPTY
42872: LIST
42873: LIST
42874: PUSH
42875: LD_INT 1
42877: PUSH
42878: LD_INT 2
42880: NEG
42881: PUSH
42882: EMPTY
42883: LIST
42884: LIST
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: LIST
42890: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42891: LD_ADDR_VAR 0 54
42895: PUSH
42896: LD_INT 2
42898: PUSH
42899: LD_INT 1
42901: NEG
42902: PUSH
42903: EMPTY
42904: LIST
42905: LIST
42906: PUSH
42907: LD_INT 3
42909: PUSH
42910: LD_INT 0
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PUSH
42917: LD_INT 3
42919: PUSH
42920: LD_INT 1
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: LIST
42931: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42932: LD_ADDR_VAR 0 55
42936: PUSH
42937: LD_INT 3
42939: PUSH
42940: LD_INT 2
42942: PUSH
42943: EMPTY
42944: LIST
42945: LIST
42946: PUSH
42947: LD_INT 3
42949: PUSH
42950: LD_INT 3
42952: PUSH
42953: EMPTY
42954: LIST
42955: LIST
42956: PUSH
42957: LD_INT 2
42959: PUSH
42960: LD_INT 3
42962: PUSH
42963: EMPTY
42964: LIST
42965: LIST
42966: PUSH
42967: EMPTY
42968: LIST
42969: LIST
42970: LIST
42971: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42972: LD_ADDR_VAR 0 56
42976: PUSH
42977: LD_INT 1
42979: PUSH
42980: LD_INT 3
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: PUSH
42987: LD_INT 0
42989: PUSH
42990: LD_INT 3
42992: PUSH
42993: EMPTY
42994: LIST
42995: LIST
42996: PUSH
42997: LD_INT 1
42999: NEG
43000: PUSH
43001: LD_INT 2
43003: PUSH
43004: EMPTY
43005: LIST
43006: LIST
43007: PUSH
43008: EMPTY
43009: LIST
43010: LIST
43011: LIST
43012: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43013: LD_ADDR_VAR 0 57
43017: PUSH
43018: LD_INT 2
43020: NEG
43021: PUSH
43022: LD_INT 1
43024: PUSH
43025: EMPTY
43026: LIST
43027: LIST
43028: PUSH
43029: LD_INT 3
43031: NEG
43032: PUSH
43033: LD_INT 0
43035: PUSH
43036: EMPTY
43037: LIST
43038: LIST
43039: PUSH
43040: LD_INT 3
43042: NEG
43043: PUSH
43044: LD_INT 1
43046: NEG
43047: PUSH
43048: EMPTY
43049: LIST
43050: LIST
43051: PUSH
43052: EMPTY
43053: LIST
43054: LIST
43055: LIST
43056: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43057: LD_ADDR_VAR 0 58
43061: PUSH
43062: LD_INT 2
43064: NEG
43065: PUSH
43066: LD_INT 3
43068: NEG
43069: PUSH
43070: EMPTY
43071: LIST
43072: LIST
43073: PUSH
43074: LD_INT 3
43076: NEG
43077: PUSH
43078: LD_INT 2
43080: NEG
43081: PUSH
43082: EMPTY
43083: LIST
43084: LIST
43085: PUSH
43086: LD_INT 3
43088: NEG
43089: PUSH
43090: LD_INT 3
43092: NEG
43093: PUSH
43094: EMPTY
43095: LIST
43096: LIST
43097: PUSH
43098: EMPTY
43099: LIST
43100: LIST
43101: LIST
43102: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43103: LD_ADDR_VAR 0 59
43107: PUSH
43108: LD_INT 1
43110: NEG
43111: PUSH
43112: LD_INT 2
43114: NEG
43115: PUSH
43116: EMPTY
43117: LIST
43118: LIST
43119: PUSH
43120: LD_INT 0
43122: PUSH
43123: LD_INT 2
43125: NEG
43126: PUSH
43127: EMPTY
43128: LIST
43129: LIST
43130: PUSH
43131: LD_INT 1
43133: PUSH
43134: LD_INT 1
43136: NEG
43137: PUSH
43138: EMPTY
43139: LIST
43140: LIST
43141: PUSH
43142: EMPTY
43143: LIST
43144: LIST
43145: LIST
43146: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43147: LD_ADDR_VAR 0 60
43151: PUSH
43152: LD_INT 1
43154: PUSH
43155: LD_INT 1
43157: NEG
43158: PUSH
43159: EMPTY
43160: LIST
43161: LIST
43162: PUSH
43163: LD_INT 2
43165: PUSH
43166: LD_INT 0
43168: PUSH
43169: EMPTY
43170: LIST
43171: LIST
43172: PUSH
43173: LD_INT 2
43175: PUSH
43176: LD_INT 1
43178: PUSH
43179: EMPTY
43180: LIST
43181: LIST
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: LIST
43187: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43188: LD_ADDR_VAR 0 61
43192: PUSH
43193: LD_INT 2
43195: PUSH
43196: LD_INT 1
43198: PUSH
43199: EMPTY
43200: LIST
43201: LIST
43202: PUSH
43203: LD_INT 2
43205: PUSH
43206: LD_INT 2
43208: PUSH
43209: EMPTY
43210: LIST
43211: LIST
43212: PUSH
43213: LD_INT 1
43215: PUSH
43216: LD_INT 2
43218: PUSH
43219: EMPTY
43220: LIST
43221: LIST
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: LIST
43227: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43228: LD_ADDR_VAR 0 62
43232: PUSH
43233: LD_INT 1
43235: PUSH
43236: LD_INT 2
43238: PUSH
43239: EMPTY
43240: LIST
43241: LIST
43242: PUSH
43243: LD_INT 0
43245: PUSH
43246: LD_INT 2
43248: PUSH
43249: EMPTY
43250: LIST
43251: LIST
43252: PUSH
43253: LD_INT 1
43255: NEG
43256: PUSH
43257: LD_INT 1
43259: PUSH
43260: EMPTY
43261: LIST
43262: LIST
43263: PUSH
43264: EMPTY
43265: LIST
43266: LIST
43267: LIST
43268: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43269: LD_ADDR_VAR 0 63
43273: PUSH
43274: LD_INT 1
43276: NEG
43277: PUSH
43278: LD_INT 1
43280: PUSH
43281: EMPTY
43282: LIST
43283: LIST
43284: PUSH
43285: LD_INT 2
43287: NEG
43288: PUSH
43289: LD_INT 0
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: PUSH
43296: LD_INT 2
43298: NEG
43299: PUSH
43300: LD_INT 1
43302: NEG
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: LIST
43312: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43313: LD_ADDR_VAR 0 64
43317: PUSH
43318: LD_INT 1
43320: NEG
43321: PUSH
43322: LD_INT 2
43324: NEG
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 2
43332: NEG
43333: PUSH
43334: LD_INT 1
43336: NEG
43337: PUSH
43338: EMPTY
43339: LIST
43340: LIST
43341: PUSH
43342: LD_INT 2
43344: NEG
43345: PUSH
43346: LD_INT 2
43348: NEG
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: EMPTY
43355: LIST
43356: LIST
43357: LIST
43358: ST_TO_ADDR
// end ; 2 :
43359: GO 46625
43361: LD_INT 2
43363: DOUBLE
43364: EQUAL
43365: IFTRUE 43369
43367: GO 46624
43369: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43370: LD_ADDR_VAR 0 29
43374: PUSH
43375: LD_INT 4
43377: PUSH
43378: LD_INT 0
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: PUSH
43385: LD_INT 4
43387: PUSH
43388: LD_INT 1
43390: NEG
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: PUSH
43396: LD_INT 5
43398: PUSH
43399: LD_INT 0
43401: PUSH
43402: EMPTY
43403: LIST
43404: LIST
43405: PUSH
43406: LD_INT 5
43408: PUSH
43409: LD_INT 1
43411: PUSH
43412: EMPTY
43413: LIST
43414: LIST
43415: PUSH
43416: LD_INT 4
43418: PUSH
43419: LD_INT 1
43421: PUSH
43422: EMPTY
43423: LIST
43424: LIST
43425: PUSH
43426: LD_INT 3
43428: PUSH
43429: LD_INT 0
43431: PUSH
43432: EMPTY
43433: LIST
43434: LIST
43435: PUSH
43436: LD_INT 3
43438: PUSH
43439: LD_INT 1
43441: NEG
43442: PUSH
43443: EMPTY
43444: LIST
43445: LIST
43446: PUSH
43447: LD_INT 3
43449: PUSH
43450: LD_INT 2
43452: NEG
43453: PUSH
43454: EMPTY
43455: LIST
43456: LIST
43457: PUSH
43458: LD_INT 5
43460: PUSH
43461: LD_INT 2
43463: PUSH
43464: EMPTY
43465: LIST
43466: LIST
43467: PUSH
43468: LD_INT 3
43470: PUSH
43471: LD_INT 3
43473: PUSH
43474: EMPTY
43475: LIST
43476: LIST
43477: PUSH
43478: LD_INT 3
43480: PUSH
43481: LD_INT 2
43483: PUSH
43484: EMPTY
43485: LIST
43486: LIST
43487: PUSH
43488: LD_INT 4
43490: PUSH
43491: LD_INT 3
43493: PUSH
43494: EMPTY
43495: LIST
43496: LIST
43497: PUSH
43498: LD_INT 4
43500: PUSH
43501: LD_INT 4
43503: PUSH
43504: EMPTY
43505: LIST
43506: LIST
43507: PUSH
43508: LD_INT 3
43510: PUSH
43511: LD_INT 4
43513: PUSH
43514: EMPTY
43515: LIST
43516: LIST
43517: PUSH
43518: LD_INT 2
43520: PUSH
43521: LD_INT 3
43523: PUSH
43524: EMPTY
43525: LIST
43526: LIST
43527: PUSH
43528: LD_INT 2
43530: PUSH
43531: LD_INT 2
43533: PUSH
43534: EMPTY
43535: LIST
43536: LIST
43537: PUSH
43538: LD_INT 4
43540: PUSH
43541: LD_INT 2
43543: PUSH
43544: EMPTY
43545: LIST
43546: LIST
43547: PUSH
43548: LD_INT 2
43550: PUSH
43551: LD_INT 4
43553: PUSH
43554: EMPTY
43555: LIST
43556: LIST
43557: PUSH
43558: LD_INT 0
43560: PUSH
43561: LD_INT 4
43563: PUSH
43564: EMPTY
43565: LIST
43566: LIST
43567: PUSH
43568: LD_INT 0
43570: PUSH
43571: LD_INT 3
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 1
43580: PUSH
43581: LD_INT 4
43583: PUSH
43584: EMPTY
43585: LIST
43586: LIST
43587: PUSH
43588: LD_INT 1
43590: PUSH
43591: LD_INT 5
43593: PUSH
43594: EMPTY
43595: LIST
43596: LIST
43597: PUSH
43598: LD_INT 0
43600: PUSH
43601: LD_INT 5
43603: PUSH
43604: EMPTY
43605: LIST
43606: LIST
43607: PUSH
43608: LD_INT 1
43610: NEG
43611: PUSH
43612: LD_INT 4
43614: PUSH
43615: EMPTY
43616: LIST
43617: LIST
43618: PUSH
43619: LD_INT 1
43621: NEG
43622: PUSH
43623: LD_INT 3
43625: PUSH
43626: EMPTY
43627: LIST
43628: LIST
43629: PUSH
43630: LD_INT 2
43632: PUSH
43633: LD_INT 5
43635: PUSH
43636: EMPTY
43637: LIST
43638: LIST
43639: PUSH
43640: LD_INT 2
43642: NEG
43643: PUSH
43644: LD_INT 3
43646: PUSH
43647: EMPTY
43648: LIST
43649: LIST
43650: PUSH
43651: LD_INT 3
43653: NEG
43654: PUSH
43655: LD_INT 0
43657: PUSH
43658: EMPTY
43659: LIST
43660: LIST
43661: PUSH
43662: LD_INT 3
43664: NEG
43665: PUSH
43666: LD_INT 1
43668: NEG
43669: PUSH
43670: EMPTY
43671: LIST
43672: LIST
43673: PUSH
43674: LD_INT 2
43676: NEG
43677: PUSH
43678: LD_INT 0
43680: PUSH
43681: EMPTY
43682: LIST
43683: LIST
43684: PUSH
43685: LD_INT 2
43687: NEG
43688: PUSH
43689: LD_INT 1
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PUSH
43696: LD_INT 3
43698: NEG
43699: PUSH
43700: LD_INT 1
43702: PUSH
43703: EMPTY
43704: LIST
43705: LIST
43706: PUSH
43707: LD_INT 4
43709: NEG
43710: PUSH
43711: LD_INT 0
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: PUSH
43718: LD_INT 4
43720: NEG
43721: PUSH
43722: LD_INT 1
43724: NEG
43725: PUSH
43726: EMPTY
43727: LIST
43728: LIST
43729: PUSH
43730: LD_INT 4
43732: NEG
43733: PUSH
43734: LD_INT 2
43736: NEG
43737: PUSH
43738: EMPTY
43739: LIST
43740: LIST
43741: PUSH
43742: LD_INT 2
43744: NEG
43745: PUSH
43746: LD_INT 2
43748: PUSH
43749: EMPTY
43750: LIST
43751: LIST
43752: PUSH
43753: LD_INT 4
43755: NEG
43756: PUSH
43757: LD_INT 4
43759: NEG
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 4
43767: NEG
43768: PUSH
43769: LD_INT 5
43771: NEG
43772: PUSH
43773: EMPTY
43774: LIST
43775: LIST
43776: PUSH
43777: LD_INT 3
43779: NEG
43780: PUSH
43781: LD_INT 4
43783: NEG
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: LD_INT 3
43791: NEG
43792: PUSH
43793: LD_INT 3
43795: NEG
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: LD_INT 4
43803: NEG
43804: PUSH
43805: LD_INT 3
43807: NEG
43808: PUSH
43809: EMPTY
43810: LIST
43811: LIST
43812: PUSH
43813: LD_INT 5
43815: NEG
43816: PUSH
43817: LD_INT 4
43819: NEG
43820: PUSH
43821: EMPTY
43822: LIST
43823: LIST
43824: PUSH
43825: LD_INT 5
43827: NEG
43828: PUSH
43829: LD_INT 5
43831: NEG
43832: PUSH
43833: EMPTY
43834: LIST
43835: LIST
43836: PUSH
43837: LD_INT 3
43839: NEG
43840: PUSH
43841: LD_INT 5
43843: NEG
43844: PUSH
43845: EMPTY
43846: LIST
43847: LIST
43848: PUSH
43849: LD_INT 5
43851: NEG
43852: PUSH
43853: LD_INT 3
43855: NEG
43856: PUSH
43857: EMPTY
43858: LIST
43859: LIST
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: LIST
43867: LIST
43868: LIST
43869: LIST
43870: LIST
43871: LIST
43872: LIST
43873: LIST
43874: LIST
43875: LIST
43876: LIST
43877: LIST
43878: LIST
43879: LIST
43880: LIST
43881: LIST
43882: LIST
43883: LIST
43884: LIST
43885: LIST
43886: LIST
43887: LIST
43888: LIST
43889: LIST
43890: LIST
43891: LIST
43892: LIST
43893: LIST
43894: LIST
43895: LIST
43896: LIST
43897: LIST
43898: LIST
43899: LIST
43900: LIST
43901: LIST
43902: LIST
43903: LIST
43904: LIST
43905: LIST
43906: LIST
43907: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43908: LD_ADDR_VAR 0 30
43912: PUSH
43913: LD_INT 4
43915: PUSH
43916: LD_INT 4
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PUSH
43923: LD_INT 4
43925: PUSH
43926: LD_INT 3
43928: PUSH
43929: EMPTY
43930: LIST
43931: LIST
43932: PUSH
43933: LD_INT 5
43935: PUSH
43936: LD_INT 4
43938: PUSH
43939: EMPTY
43940: LIST
43941: LIST
43942: PUSH
43943: LD_INT 5
43945: PUSH
43946: LD_INT 5
43948: PUSH
43949: EMPTY
43950: LIST
43951: LIST
43952: PUSH
43953: LD_INT 4
43955: PUSH
43956: LD_INT 5
43958: PUSH
43959: EMPTY
43960: LIST
43961: LIST
43962: PUSH
43963: LD_INT 3
43965: PUSH
43966: LD_INT 4
43968: PUSH
43969: EMPTY
43970: LIST
43971: LIST
43972: PUSH
43973: LD_INT 3
43975: PUSH
43976: LD_INT 3
43978: PUSH
43979: EMPTY
43980: LIST
43981: LIST
43982: PUSH
43983: LD_INT 5
43985: PUSH
43986: LD_INT 3
43988: PUSH
43989: EMPTY
43990: LIST
43991: LIST
43992: PUSH
43993: LD_INT 3
43995: PUSH
43996: LD_INT 5
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 0
44005: PUSH
44006: LD_INT 3
44008: PUSH
44009: EMPTY
44010: LIST
44011: LIST
44012: PUSH
44013: LD_INT 0
44015: PUSH
44016: LD_INT 2
44018: PUSH
44019: EMPTY
44020: LIST
44021: LIST
44022: PUSH
44023: LD_INT 1
44025: PUSH
44026: LD_INT 3
44028: PUSH
44029: EMPTY
44030: LIST
44031: LIST
44032: PUSH
44033: LD_INT 1
44035: PUSH
44036: LD_INT 4
44038: PUSH
44039: EMPTY
44040: LIST
44041: LIST
44042: PUSH
44043: LD_INT 0
44045: PUSH
44046: LD_INT 4
44048: PUSH
44049: EMPTY
44050: LIST
44051: LIST
44052: PUSH
44053: LD_INT 1
44055: NEG
44056: PUSH
44057: LD_INT 3
44059: PUSH
44060: EMPTY
44061: LIST
44062: LIST
44063: PUSH
44064: LD_INT 1
44066: NEG
44067: PUSH
44068: LD_INT 2
44070: PUSH
44071: EMPTY
44072: LIST
44073: LIST
44074: PUSH
44075: LD_INT 2
44077: PUSH
44078: LD_INT 4
44080: PUSH
44081: EMPTY
44082: LIST
44083: LIST
44084: PUSH
44085: LD_INT 2
44087: NEG
44088: PUSH
44089: LD_INT 2
44091: PUSH
44092: EMPTY
44093: LIST
44094: LIST
44095: PUSH
44096: LD_INT 4
44098: NEG
44099: PUSH
44100: LD_INT 0
44102: PUSH
44103: EMPTY
44104: LIST
44105: LIST
44106: PUSH
44107: LD_INT 4
44109: NEG
44110: PUSH
44111: LD_INT 1
44113: NEG
44114: PUSH
44115: EMPTY
44116: LIST
44117: LIST
44118: PUSH
44119: LD_INT 3
44121: NEG
44122: PUSH
44123: LD_INT 0
44125: PUSH
44126: EMPTY
44127: LIST
44128: LIST
44129: PUSH
44130: LD_INT 3
44132: NEG
44133: PUSH
44134: LD_INT 1
44136: PUSH
44137: EMPTY
44138: LIST
44139: LIST
44140: PUSH
44141: LD_INT 4
44143: NEG
44144: PUSH
44145: LD_INT 1
44147: PUSH
44148: EMPTY
44149: LIST
44150: LIST
44151: PUSH
44152: LD_INT 5
44154: NEG
44155: PUSH
44156: LD_INT 0
44158: PUSH
44159: EMPTY
44160: LIST
44161: LIST
44162: PUSH
44163: LD_INT 5
44165: NEG
44166: PUSH
44167: LD_INT 1
44169: NEG
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: LD_INT 5
44177: NEG
44178: PUSH
44179: LD_INT 2
44181: NEG
44182: PUSH
44183: EMPTY
44184: LIST
44185: LIST
44186: PUSH
44187: LD_INT 3
44189: NEG
44190: PUSH
44191: LD_INT 2
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: PUSH
44198: LD_INT 3
44200: NEG
44201: PUSH
44202: LD_INT 3
44204: NEG
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 3
44212: NEG
44213: PUSH
44214: LD_INT 4
44216: NEG
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: PUSH
44222: LD_INT 2
44224: NEG
44225: PUSH
44226: LD_INT 3
44228: NEG
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: PUSH
44234: LD_INT 2
44236: NEG
44237: PUSH
44238: LD_INT 2
44240: NEG
44241: PUSH
44242: EMPTY
44243: LIST
44244: LIST
44245: PUSH
44246: LD_INT 3
44248: NEG
44249: PUSH
44250: LD_INT 2
44252: NEG
44253: PUSH
44254: EMPTY
44255: LIST
44256: LIST
44257: PUSH
44258: LD_INT 4
44260: NEG
44261: PUSH
44262: LD_INT 3
44264: NEG
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: PUSH
44270: LD_INT 4
44272: NEG
44273: PUSH
44274: LD_INT 4
44276: NEG
44277: PUSH
44278: EMPTY
44279: LIST
44280: LIST
44281: PUSH
44282: LD_INT 2
44284: NEG
44285: PUSH
44286: LD_INT 4
44288: NEG
44289: PUSH
44290: EMPTY
44291: LIST
44292: LIST
44293: PUSH
44294: LD_INT 4
44296: NEG
44297: PUSH
44298: LD_INT 2
44300: NEG
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PUSH
44306: LD_INT 0
44308: PUSH
44309: LD_INT 4
44311: NEG
44312: PUSH
44313: EMPTY
44314: LIST
44315: LIST
44316: PUSH
44317: LD_INT 0
44319: PUSH
44320: LD_INT 5
44322: NEG
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_INT 1
44330: PUSH
44331: LD_INT 4
44333: NEG
44334: PUSH
44335: EMPTY
44336: LIST
44337: LIST
44338: PUSH
44339: LD_INT 1
44341: PUSH
44342: LD_INT 3
44344: NEG
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: LD_INT 0
44352: PUSH
44353: LD_INT 3
44355: NEG
44356: PUSH
44357: EMPTY
44358: LIST
44359: LIST
44360: PUSH
44361: LD_INT 1
44363: NEG
44364: PUSH
44365: LD_INT 4
44367: NEG
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 1
44375: NEG
44376: PUSH
44377: LD_INT 5
44379: NEG
44380: PUSH
44381: EMPTY
44382: LIST
44383: LIST
44384: PUSH
44385: LD_INT 2
44387: PUSH
44388: LD_INT 3
44390: NEG
44391: PUSH
44392: EMPTY
44393: LIST
44394: LIST
44395: PUSH
44396: LD_INT 2
44398: NEG
44399: PUSH
44400: LD_INT 5
44402: NEG
44403: PUSH
44404: EMPTY
44405: LIST
44406: LIST
44407: PUSH
44408: EMPTY
44409: LIST
44410: LIST
44411: LIST
44412: LIST
44413: LIST
44414: LIST
44415: LIST
44416: LIST
44417: LIST
44418: LIST
44419: LIST
44420: LIST
44421: LIST
44422: LIST
44423: LIST
44424: LIST
44425: LIST
44426: LIST
44427: LIST
44428: LIST
44429: LIST
44430: LIST
44431: LIST
44432: LIST
44433: LIST
44434: LIST
44435: LIST
44436: LIST
44437: LIST
44438: LIST
44439: LIST
44440: LIST
44441: LIST
44442: LIST
44443: LIST
44444: LIST
44445: LIST
44446: LIST
44447: LIST
44448: LIST
44449: LIST
44450: LIST
44451: LIST
44452: LIST
44453: LIST
44454: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44455: LD_ADDR_VAR 0 31
44459: PUSH
44460: LD_INT 0
44462: PUSH
44463: LD_INT 4
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: PUSH
44470: LD_INT 0
44472: PUSH
44473: LD_INT 3
44475: PUSH
44476: EMPTY
44477: LIST
44478: LIST
44479: PUSH
44480: LD_INT 1
44482: PUSH
44483: LD_INT 4
44485: PUSH
44486: EMPTY
44487: LIST
44488: LIST
44489: PUSH
44490: LD_INT 1
44492: PUSH
44493: LD_INT 5
44495: PUSH
44496: EMPTY
44497: LIST
44498: LIST
44499: PUSH
44500: LD_INT 0
44502: PUSH
44503: LD_INT 5
44505: PUSH
44506: EMPTY
44507: LIST
44508: LIST
44509: PUSH
44510: LD_INT 1
44512: NEG
44513: PUSH
44514: LD_INT 4
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: PUSH
44521: LD_INT 1
44523: NEG
44524: PUSH
44525: LD_INT 3
44527: PUSH
44528: EMPTY
44529: LIST
44530: LIST
44531: PUSH
44532: LD_INT 2
44534: PUSH
44535: LD_INT 5
44537: PUSH
44538: EMPTY
44539: LIST
44540: LIST
44541: PUSH
44542: LD_INT 2
44544: NEG
44545: PUSH
44546: LD_INT 3
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: PUSH
44553: LD_INT 3
44555: NEG
44556: PUSH
44557: LD_INT 0
44559: PUSH
44560: EMPTY
44561: LIST
44562: LIST
44563: PUSH
44564: LD_INT 3
44566: NEG
44567: PUSH
44568: LD_INT 1
44570: NEG
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: PUSH
44576: LD_INT 2
44578: NEG
44579: PUSH
44580: LD_INT 0
44582: PUSH
44583: EMPTY
44584: LIST
44585: LIST
44586: PUSH
44587: LD_INT 2
44589: NEG
44590: PUSH
44591: LD_INT 1
44593: PUSH
44594: EMPTY
44595: LIST
44596: LIST
44597: PUSH
44598: LD_INT 3
44600: NEG
44601: PUSH
44602: LD_INT 1
44604: PUSH
44605: EMPTY
44606: LIST
44607: LIST
44608: PUSH
44609: LD_INT 4
44611: NEG
44612: PUSH
44613: LD_INT 0
44615: PUSH
44616: EMPTY
44617: LIST
44618: LIST
44619: PUSH
44620: LD_INT 4
44622: NEG
44623: PUSH
44624: LD_INT 1
44626: NEG
44627: PUSH
44628: EMPTY
44629: LIST
44630: LIST
44631: PUSH
44632: LD_INT 4
44634: NEG
44635: PUSH
44636: LD_INT 2
44638: NEG
44639: PUSH
44640: EMPTY
44641: LIST
44642: LIST
44643: PUSH
44644: LD_INT 2
44646: NEG
44647: PUSH
44648: LD_INT 2
44650: PUSH
44651: EMPTY
44652: LIST
44653: LIST
44654: PUSH
44655: LD_INT 4
44657: NEG
44658: PUSH
44659: LD_INT 4
44661: NEG
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: PUSH
44667: LD_INT 4
44669: NEG
44670: PUSH
44671: LD_INT 5
44673: NEG
44674: PUSH
44675: EMPTY
44676: LIST
44677: LIST
44678: PUSH
44679: LD_INT 3
44681: NEG
44682: PUSH
44683: LD_INT 4
44685: NEG
44686: PUSH
44687: EMPTY
44688: LIST
44689: LIST
44690: PUSH
44691: LD_INT 3
44693: NEG
44694: PUSH
44695: LD_INT 3
44697: NEG
44698: PUSH
44699: EMPTY
44700: LIST
44701: LIST
44702: PUSH
44703: LD_INT 4
44705: NEG
44706: PUSH
44707: LD_INT 3
44709: NEG
44710: PUSH
44711: EMPTY
44712: LIST
44713: LIST
44714: PUSH
44715: LD_INT 5
44717: NEG
44718: PUSH
44719: LD_INT 4
44721: NEG
44722: PUSH
44723: EMPTY
44724: LIST
44725: LIST
44726: PUSH
44727: LD_INT 5
44729: NEG
44730: PUSH
44731: LD_INT 5
44733: NEG
44734: PUSH
44735: EMPTY
44736: LIST
44737: LIST
44738: PUSH
44739: LD_INT 3
44741: NEG
44742: PUSH
44743: LD_INT 5
44745: NEG
44746: PUSH
44747: EMPTY
44748: LIST
44749: LIST
44750: PUSH
44751: LD_INT 5
44753: NEG
44754: PUSH
44755: LD_INT 3
44757: NEG
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: PUSH
44763: LD_INT 0
44765: PUSH
44766: LD_INT 3
44768: NEG
44769: PUSH
44770: EMPTY
44771: LIST
44772: LIST
44773: PUSH
44774: LD_INT 0
44776: PUSH
44777: LD_INT 4
44779: NEG
44780: PUSH
44781: EMPTY
44782: LIST
44783: LIST
44784: PUSH
44785: LD_INT 1
44787: PUSH
44788: LD_INT 3
44790: NEG
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PUSH
44796: LD_INT 1
44798: PUSH
44799: LD_INT 2
44801: NEG
44802: PUSH
44803: EMPTY
44804: LIST
44805: LIST
44806: PUSH
44807: LD_INT 0
44809: PUSH
44810: LD_INT 2
44812: NEG
44813: PUSH
44814: EMPTY
44815: LIST
44816: LIST
44817: PUSH
44818: LD_INT 1
44820: NEG
44821: PUSH
44822: LD_INT 3
44824: NEG
44825: PUSH
44826: EMPTY
44827: LIST
44828: LIST
44829: PUSH
44830: LD_INT 1
44832: NEG
44833: PUSH
44834: LD_INT 4
44836: NEG
44837: PUSH
44838: EMPTY
44839: LIST
44840: LIST
44841: PUSH
44842: LD_INT 2
44844: PUSH
44845: LD_INT 2
44847: NEG
44848: PUSH
44849: EMPTY
44850: LIST
44851: LIST
44852: PUSH
44853: LD_INT 2
44855: NEG
44856: PUSH
44857: LD_INT 4
44859: NEG
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PUSH
44865: LD_INT 4
44867: PUSH
44868: LD_INT 0
44870: PUSH
44871: EMPTY
44872: LIST
44873: LIST
44874: PUSH
44875: LD_INT 4
44877: PUSH
44878: LD_INT 1
44880: NEG
44881: PUSH
44882: EMPTY
44883: LIST
44884: LIST
44885: PUSH
44886: LD_INT 5
44888: PUSH
44889: LD_INT 0
44891: PUSH
44892: EMPTY
44893: LIST
44894: LIST
44895: PUSH
44896: LD_INT 5
44898: PUSH
44899: LD_INT 1
44901: PUSH
44902: EMPTY
44903: LIST
44904: LIST
44905: PUSH
44906: LD_INT 4
44908: PUSH
44909: LD_INT 1
44911: PUSH
44912: EMPTY
44913: LIST
44914: LIST
44915: PUSH
44916: LD_INT 3
44918: PUSH
44919: LD_INT 0
44921: PUSH
44922: EMPTY
44923: LIST
44924: LIST
44925: PUSH
44926: LD_INT 3
44928: PUSH
44929: LD_INT 1
44931: NEG
44932: PUSH
44933: EMPTY
44934: LIST
44935: LIST
44936: PUSH
44937: LD_INT 3
44939: PUSH
44940: LD_INT 2
44942: NEG
44943: PUSH
44944: EMPTY
44945: LIST
44946: LIST
44947: PUSH
44948: LD_INT 5
44950: PUSH
44951: LD_INT 2
44953: PUSH
44954: EMPTY
44955: LIST
44956: LIST
44957: PUSH
44958: EMPTY
44959: LIST
44960: LIST
44961: LIST
44962: LIST
44963: LIST
44964: LIST
44965: LIST
44966: LIST
44967: LIST
44968: LIST
44969: LIST
44970: LIST
44971: LIST
44972: LIST
44973: LIST
44974: LIST
44975: LIST
44976: LIST
44977: LIST
44978: LIST
44979: LIST
44980: LIST
44981: LIST
44982: LIST
44983: LIST
44984: LIST
44985: LIST
44986: LIST
44987: LIST
44988: LIST
44989: LIST
44990: LIST
44991: LIST
44992: LIST
44993: LIST
44994: LIST
44995: LIST
44996: LIST
44997: LIST
44998: LIST
44999: LIST
45000: LIST
45001: LIST
45002: LIST
45003: LIST
45004: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45005: LD_ADDR_VAR 0 32
45009: PUSH
45010: LD_INT 4
45012: NEG
45013: PUSH
45014: LD_INT 0
45016: PUSH
45017: EMPTY
45018: LIST
45019: LIST
45020: PUSH
45021: LD_INT 4
45023: NEG
45024: PUSH
45025: LD_INT 1
45027: NEG
45028: PUSH
45029: EMPTY
45030: LIST
45031: LIST
45032: PUSH
45033: LD_INT 3
45035: NEG
45036: PUSH
45037: LD_INT 0
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: LD_INT 3
45046: NEG
45047: PUSH
45048: LD_INT 1
45050: PUSH
45051: EMPTY
45052: LIST
45053: LIST
45054: PUSH
45055: LD_INT 4
45057: NEG
45058: PUSH
45059: LD_INT 1
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: PUSH
45066: LD_INT 5
45068: NEG
45069: PUSH
45070: LD_INT 0
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: LD_INT 5
45079: NEG
45080: PUSH
45081: LD_INT 1
45083: NEG
45084: PUSH
45085: EMPTY
45086: LIST
45087: LIST
45088: PUSH
45089: LD_INT 5
45091: NEG
45092: PUSH
45093: LD_INT 2
45095: NEG
45096: PUSH
45097: EMPTY
45098: LIST
45099: LIST
45100: PUSH
45101: LD_INT 3
45103: NEG
45104: PUSH
45105: LD_INT 2
45107: PUSH
45108: EMPTY
45109: LIST
45110: LIST
45111: PUSH
45112: LD_INT 3
45114: NEG
45115: PUSH
45116: LD_INT 3
45118: NEG
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: PUSH
45124: LD_INT 3
45126: NEG
45127: PUSH
45128: LD_INT 4
45130: NEG
45131: PUSH
45132: EMPTY
45133: LIST
45134: LIST
45135: PUSH
45136: LD_INT 2
45138: NEG
45139: PUSH
45140: LD_INT 3
45142: NEG
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: PUSH
45148: LD_INT 2
45150: NEG
45151: PUSH
45152: LD_INT 2
45154: NEG
45155: PUSH
45156: EMPTY
45157: LIST
45158: LIST
45159: PUSH
45160: LD_INT 3
45162: NEG
45163: PUSH
45164: LD_INT 2
45166: NEG
45167: PUSH
45168: EMPTY
45169: LIST
45170: LIST
45171: PUSH
45172: LD_INT 4
45174: NEG
45175: PUSH
45176: LD_INT 3
45178: NEG
45179: PUSH
45180: EMPTY
45181: LIST
45182: LIST
45183: PUSH
45184: LD_INT 4
45186: NEG
45187: PUSH
45188: LD_INT 4
45190: NEG
45191: PUSH
45192: EMPTY
45193: LIST
45194: LIST
45195: PUSH
45196: LD_INT 2
45198: NEG
45199: PUSH
45200: LD_INT 4
45202: NEG
45203: PUSH
45204: EMPTY
45205: LIST
45206: LIST
45207: PUSH
45208: LD_INT 4
45210: NEG
45211: PUSH
45212: LD_INT 2
45214: NEG
45215: PUSH
45216: EMPTY
45217: LIST
45218: LIST
45219: PUSH
45220: LD_INT 0
45222: PUSH
45223: LD_INT 4
45225: NEG
45226: PUSH
45227: EMPTY
45228: LIST
45229: LIST
45230: PUSH
45231: LD_INT 0
45233: PUSH
45234: LD_INT 5
45236: NEG
45237: PUSH
45238: EMPTY
45239: LIST
45240: LIST
45241: PUSH
45242: LD_INT 1
45244: PUSH
45245: LD_INT 4
45247: NEG
45248: PUSH
45249: EMPTY
45250: LIST
45251: LIST
45252: PUSH
45253: LD_INT 1
45255: PUSH
45256: LD_INT 3
45258: NEG
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: PUSH
45264: LD_INT 0
45266: PUSH
45267: LD_INT 3
45269: NEG
45270: PUSH
45271: EMPTY
45272: LIST
45273: LIST
45274: PUSH
45275: LD_INT 1
45277: NEG
45278: PUSH
45279: LD_INT 4
45281: NEG
45282: PUSH
45283: EMPTY
45284: LIST
45285: LIST
45286: PUSH
45287: LD_INT 1
45289: NEG
45290: PUSH
45291: LD_INT 5
45293: NEG
45294: PUSH
45295: EMPTY
45296: LIST
45297: LIST
45298: PUSH
45299: LD_INT 2
45301: PUSH
45302: LD_INT 3
45304: NEG
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: PUSH
45310: LD_INT 2
45312: NEG
45313: PUSH
45314: LD_INT 5
45316: NEG
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PUSH
45322: LD_INT 3
45324: PUSH
45325: LD_INT 0
45327: PUSH
45328: EMPTY
45329: LIST
45330: LIST
45331: PUSH
45332: LD_INT 3
45334: PUSH
45335: LD_INT 1
45337: NEG
45338: PUSH
45339: EMPTY
45340: LIST
45341: LIST
45342: PUSH
45343: LD_INT 4
45345: PUSH
45346: LD_INT 0
45348: PUSH
45349: EMPTY
45350: LIST
45351: LIST
45352: PUSH
45353: LD_INT 4
45355: PUSH
45356: LD_INT 1
45358: PUSH
45359: EMPTY
45360: LIST
45361: LIST
45362: PUSH
45363: LD_INT 3
45365: PUSH
45366: LD_INT 1
45368: PUSH
45369: EMPTY
45370: LIST
45371: LIST
45372: PUSH
45373: LD_INT 2
45375: PUSH
45376: LD_INT 0
45378: PUSH
45379: EMPTY
45380: LIST
45381: LIST
45382: PUSH
45383: LD_INT 2
45385: PUSH
45386: LD_INT 1
45388: NEG
45389: PUSH
45390: EMPTY
45391: LIST
45392: LIST
45393: PUSH
45394: LD_INT 2
45396: PUSH
45397: LD_INT 2
45399: NEG
45400: PUSH
45401: EMPTY
45402: LIST
45403: LIST
45404: PUSH
45405: LD_INT 4
45407: PUSH
45408: LD_INT 2
45410: PUSH
45411: EMPTY
45412: LIST
45413: LIST
45414: PUSH
45415: LD_INT 4
45417: PUSH
45418: LD_INT 4
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: PUSH
45425: LD_INT 4
45427: PUSH
45428: LD_INT 3
45430: PUSH
45431: EMPTY
45432: LIST
45433: LIST
45434: PUSH
45435: LD_INT 5
45437: PUSH
45438: LD_INT 4
45440: PUSH
45441: EMPTY
45442: LIST
45443: LIST
45444: PUSH
45445: LD_INT 5
45447: PUSH
45448: LD_INT 5
45450: PUSH
45451: EMPTY
45452: LIST
45453: LIST
45454: PUSH
45455: LD_INT 4
45457: PUSH
45458: LD_INT 5
45460: PUSH
45461: EMPTY
45462: LIST
45463: LIST
45464: PUSH
45465: LD_INT 3
45467: PUSH
45468: LD_INT 4
45470: PUSH
45471: EMPTY
45472: LIST
45473: LIST
45474: PUSH
45475: LD_INT 3
45477: PUSH
45478: LD_INT 3
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: PUSH
45485: LD_INT 5
45487: PUSH
45488: LD_INT 3
45490: PUSH
45491: EMPTY
45492: LIST
45493: LIST
45494: PUSH
45495: LD_INT 3
45497: PUSH
45498: LD_INT 5
45500: PUSH
45501: EMPTY
45502: LIST
45503: LIST
45504: PUSH
45505: EMPTY
45506: LIST
45507: LIST
45508: LIST
45509: LIST
45510: LIST
45511: LIST
45512: LIST
45513: LIST
45514: LIST
45515: LIST
45516: LIST
45517: LIST
45518: LIST
45519: LIST
45520: LIST
45521: LIST
45522: LIST
45523: LIST
45524: LIST
45525: LIST
45526: LIST
45527: LIST
45528: LIST
45529: LIST
45530: LIST
45531: LIST
45532: LIST
45533: LIST
45534: LIST
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: LIST
45540: LIST
45541: LIST
45542: LIST
45543: LIST
45544: LIST
45545: LIST
45546: LIST
45547: LIST
45548: LIST
45549: LIST
45550: LIST
45551: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45552: LD_ADDR_VAR 0 33
45556: PUSH
45557: LD_INT 4
45559: NEG
45560: PUSH
45561: LD_INT 4
45563: NEG
45564: PUSH
45565: EMPTY
45566: LIST
45567: LIST
45568: PUSH
45569: LD_INT 4
45571: NEG
45572: PUSH
45573: LD_INT 5
45575: NEG
45576: PUSH
45577: EMPTY
45578: LIST
45579: LIST
45580: PUSH
45581: LD_INT 3
45583: NEG
45584: PUSH
45585: LD_INT 4
45587: NEG
45588: PUSH
45589: EMPTY
45590: LIST
45591: LIST
45592: PUSH
45593: LD_INT 3
45595: NEG
45596: PUSH
45597: LD_INT 3
45599: NEG
45600: PUSH
45601: EMPTY
45602: LIST
45603: LIST
45604: PUSH
45605: LD_INT 4
45607: NEG
45608: PUSH
45609: LD_INT 3
45611: NEG
45612: PUSH
45613: EMPTY
45614: LIST
45615: LIST
45616: PUSH
45617: LD_INT 5
45619: NEG
45620: PUSH
45621: LD_INT 4
45623: NEG
45624: PUSH
45625: EMPTY
45626: LIST
45627: LIST
45628: PUSH
45629: LD_INT 5
45631: NEG
45632: PUSH
45633: LD_INT 5
45635: NEG
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: PUSH
45641: LD_INT 3
45643: NEG
45644: PUSH
45645: LD_INT 5
45647: NEG
45648: PUSH
45649: EMPTY
45650: LIST
45651: LIST
45652: PUSH
45653: LD_INT 5
45655: NEG
45656: PUSH
45657: LD_INT 3
45659: NEG
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: PUSH
45665: LD_INT 0
45667: PUSH
45668: LD_INT 3
45670: NEG
45671: PUSH
45672: EMPTY
45673: LIST
45674: LIST
45675: PUSH
45676: LD_INT 0
45678: PUSH
45679: LD_INT 4
45681: NEG
45682: PUSH
45683: EMPTY
45684: LIST
45685: LIST
45686: PUSH
45687: LD_INT 1
45689: PUSH
45690: LD_INT 3
45692: NEG
45693: PUSH
45694: EMPTY
45695: LIST
45696: LIST
45697: PUSH
45698: LD_INT 1
45700: PUSH
45701: LD_INT 2
45703: NEG
45704: PUSH
45705: EMPTY
45706: LIST
45707: LIST
45708: PUSH
45709: LD_INT 0
45711: PUSH
45712: LD_INT 2
45714: NEG
45715: PUSH
45716: EMPTY
45717: LIST
45718: LIST
45719: PUSH
45720: LD_INT 1
45722: NEG
45723: PUSH
45724: LD_INT 3
45726: NEG
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: PUSH
45732: LD_INT 1
45734: NEG
45735: PUSH
45736: LD_INT 4
45738: NEG
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: PUSH
45744: LD_INT 2
45746: PUSH
45747: LD_INT 2
45749: NEG
45750: PUSH
45751: EMPTY
45752: LIST
45753: LIST
45754: PUSH
45755: LD_INT 2
45757: NEG
45758: PUSH
45759: LD_INT 4
45761: NEG
45762: PUSH
45763: EMPTY
45764: LIST
45765: LIST
45766: PUSH
45767: LD_INT 4
45769: PUSH
45770: LD_INT 0
45772: PUSH
45773: EMPTY
45774: LIST
45775: LIST
45776: PUSH
45777: LD_INT 4
45779: PUSH
45780: LD_INT 1
45782: NEG
45783: PUSH
45784: EMPTY
45785: LIST
45786: LIST
45787: PUSH
45788: LD_INT 5
45790: PUSH
45791: LD_INT 0
45793: PUSH
45794: EMPTY
45795: LIST
45796: LIST
45797: PUSH
45798: LD_INT 5
45800: PUSH
45801: LD_INT 1
45803: PUSH
45804: EMPTY
45805: LIST
45806: LIST
45807: PUSH
45808: LD_INT 4
45810: PUSH
45811: LD_INT 1
45813: PUSH
45814: EMPTY
45815: LIST
45816: LIST
45817: PUSH
45818: LD_INT 3
45820: PUSH
45821: LD_INT 0
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: PUSH
45828: LD_INT 3
45830: PUSH
45831: LD_INT 1
45833: NEG
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 3
45841: PUSH
45842: LD_INT 2
45844: NEG
45845: PUSH
45846: EMPTY
45847: LIST
45848: LIST
45849: PUSH
45850: LD_INT 5
45852: PUSH
45853: LD_INT 2
45855: PUSH
45856: EMPTY
45857: LIST
45858: LIST
45859: PUSH
45860: LD_INT 3
45862: PUSH
45863: LD_INT 3
45865: PUSH
45866: EMPTY
45867: LIST
45868: LIST
45869: PUSH
45870: LD_INT 3
45872: PUSH
45873: LD_INT 2
45875: PUSH
45876: EMPTY
45877: LIST
45878: LIST
45879: PUSH
45880: LD_INT 4
45882: PUSH
45883: LD_INT 3
45885: PUSH
45886: EMPTY
45887: LIST
45888: LIST
45889: PUSH
45890: LD_INT 4
45892: PUSH
45893: LD_INT 4
45895: PUSH
45896: EMPTY
45897: LIST
45898: LIST
45899: PUSH
45900: LD_INT 3
45902: PUSH
45903: LD_INT 4
45905: PUSH
45906: EMPTY
45907: LIST
45908: LIST
45909: PUSH
45910: LD_INT 2
45912: PUSH
45913: LD_INT 3
45915: PUSH
45916: EMPTY
45917: LIST
45918: LIST
45919: PUSH
45920: LD_INT 2
45922: PUSH
45923: LD_INT 2
45925: PUSH
45926: EMPTY
45927: LIST
45928: LIST
45929: PUSH
45930: LD_INT 4
45932: PUSH
45933: LD_INT 2
45935: PUSH
45936: EMPTY
45937: LIST
45938: LIST
45939: PUSH
45940: LD_INT 2
45942: PUSH
45943: LD_INT 4
45945: PUSH
45946: EMPTY
45947: LIST
45948: LIST
45949: PUSH
45950: LD_INT 0
45952: PUSH
45953: LD_INT 4
45955: PUSH
45956: EMPTY
45957: LIST
45958: LIST
45959: PUSH
45960: LD_INT 0
45962: PUSH
45963: LD_INT 3
45965: PUSH
45966: EMPTY
45967: LIST
45968: LIST
45969: PUSH
45970: LD_INT 1
45972: PUSH
45973: LD_INT 4
45975: PUSH
45976: EMPTY
45977: LIST
45978: LIST
45979: PUSH
45980: LD_INT 1
45982: PUSH
45983: LD_INT 5
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: PUSH
45990: LD_INT 0
45992: PUSH
45993: LD_INT 5
45995: PUSH
45996: EMPTY
45997: LIST
45998: LIST
45999: PUSH
46000: LD_INT 1
46002: NEG
46003: PUSH
46004: LD_INT 4
46006: PUSH
46007: EMPTY
46008: LIST
46009: LIST
46010: PUSH
46011: LD_INT 1
46013: NEG
46014: PUSH
46015: LD_INT 3
46017: PUSH
46018: EMPTY
46019: LIST
46020: LIST
46021: PUSH
46022: LD_INT 2
46024: PUSH
46025: LD_INT 5
46027: PUSH
46028: EMPTY
46029: LIST
46030: LIST
46031: PUSH
46032: LD_INT 2
46034: NEG
46035: PUSH
46036: LD_INT 3
46038: PUSH
46039: EMPTY
46040: LIST
46041: LIST
46042: PUSH
46043: EMPTY
46044: LIST
46045: LIST
46046: LIST
46047: LIST
46048: LIST
46049: LIST
46050: LIST
46051: LIST
46052: LIST
46053: LIST
46054: LIST
46055: LIST
46056: LIST
46057: LIST
46058: LIST
46059: LIST
46060: LIST
46061: LIST
46062: LIST
46063: LIST
46064: LIST
46065: LIST
46066: LIST
46067: LIST
46068: LIST
46069: LIST
46070: LIST
46071: LIST
46072: LIST
46073: LIST
46074: LIST
46075: LIST
46076: LIST
46077: LIST
46078: LIST
46079: LIST
46080: LIST
46081: LIST
46082: LIST
46083: LIST
46084: LIST
46085: LIST
46086: LIST
46087: LIST
46088: LIST
46089: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46090: LD_ADDR_VAR 0 34
46094: PUSH
46095: LD_INT 0
46097: PUSH
46098: LD_INT 4
46100: NEG
46101: PUSH
46102: EMPTY
46103: LIST
46104: LIST
46105: PUSH
46106: LD_INT 0
46108: PUSH
46109: LD_INT 5
46111: NEG
46112: PUSH
46113: EMPTY
46114: LIST
46115: LIST
46116: PUSH
46117: LD_INT 1
46119: PUSH
46120: LD_INT 4
46122: NEG
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: PUSH
46128: LD_INT 1
46130: PUSH
46131: LD_INT 3
46133: NEG
46134: PUSH
46135: EMPTY
46136: LIST
46137: LIST
46138: PUSH
46139: LD_INT 0
46141: PUSH
46142: LD_INT 3
46144: NEG
46145: PUSH
46146: EMPTY
46147: LIST
46148: LIST
46149: PUSH
46150: LD_INT 1
46152: NEG
46153: PUSH
46154: LD_INT 4
46156: NEG
46157: PUSH
46158: EMPTY
46159: LIST
46160: LIST
46161: PUSH
46162: LD_INT 1
46164: NEG
46165: PUSH
46166: LD_INT 5
46168: NEG
46169: PUSH
46170: EMPTY
46171: LIST
46172: LIST
46173: PUSH
46174: LD_INT 2
46176: PUSH
46177: LD_INT 3
46179: NEG
46180: PUSH
46181: EMPTY
46182: LIST
46183: LIST
46184: PUSH
46185: LD_INT 2
46187: NEG
46188: PUSH
46189: LD_INT 5
46191: NEG
46192: PUSH
46193: EMPTY
46194: LIST
46195: LIST
46196: PUSH
46197: LD_INT 3
46199: PUSH
46200: LD_INT 0
46202: PUSH
46203: EMPTY
46204: LIST
46205: LIST
46206: PUSH
46207: LD_INT 3
46209: PUSH
46210: LD_INT 1
46212: NEG
46213: PUSH
46214: EMPTY
46215: LIST
46216: LIST
46217: PUSH
46218: LD_INT 4
46220: PUSH
46221: LD_INT 0
46223: PUSH
46224: EMPTY
46225: LIST
46226: LIST
46227: PUSH
46228: LD_INT 4
46230: PUSH
46231: LD_INT 1
46233: PUSH
46234: EMPTY
46235: LIST
46236: LIST
46237: PUSH
46238: LD_INT 3
46240: PUSH
46241: LD_INT 1
46243: PUSH
46244: EMPTY
46245: LIST
46246: LIST
46247: PUSH
46248: LD_INT 2
46250: PUSH
46251: LD_INT 0
46253: PUSH
46254: EMPTY
46255: LIST
46256: LIST
46257: PUSH
46258: LD_INT 2
46260: PUSH
46261: LD_INT 1
46263: NEG
46264: PUSH
46265: EMPTY
46266: LIST
46267: LIST
46268: PUSH
46269: LD_INT 2
46271: PUSH
46272: LD_INT 2
46274: NEG
46275: PUSH
46276: EMPTY
46277: LIST
46278: LIST
46279: PUSH
46280: LD_INT 4
46282: PUSH
46283: LD_INT 2
46285: PUSH
46286: EMPTY
46287: LIST
46288: LIST
46289: PUSH
46290: LD_INT 4
46292: PUSH
46293: LD_INT 4
46295: PUSH
46296: EMPTY
46297: LIST
46298: LIST
46299: PUSH
46300: LD_INT 4
46302: PUSH
46303: LD_INT 3
46305: PUSH
46306: EMPTY
46307: LIST
46308: LIST
46309: PUSH
46310: LD_INT 5
46312: PUSH
46313: LD_INT 4
46315: PUSH
46316: EMPTY
46317: LIST
46318: LIST
46319: PUSH
46320: LD_INT 5
46322: PUSH
46323: LD_INT 5
46325: PUSH
46326: EMPTY
46327: LIST
46328: LIST
46329: PUSH
46330: LD_INT 4
46332: PUSH
46333: LD_INT 5
46335: PUSH
46336: EMPTY
46337: LIST
46338: LIST
46339: PUSH
46340: LD_INT 3
46342: PUSH
46343: LD_INT 4
46345: PUSH
46346: EMPTY
46347: LIST
46348: LIST
46349: PUSH
46350: LD_INT 3
46352: PUSH
46353: LD_INT 3
46355: PUSH
46356: EMPTY
46357: LIST
46358: LIST
46359: PUSH
46360: LD_INT 5
46362: PUSH
46363: LD_INT 3
46365: PUSH
46366: EMPTY
46367: LIST
46368: LIST
46369: PUSH
46370: LD_INT 3
46372: PUSH
46373: LD_INT 5
46375: PUSH
46376: EMPTY
46377: LIST
46378: LIST
46379: PUSH
46380: LD_INT 0
46382: PUSH
46383: LD_INT 3
46385: PUSH
46386: EMPTY
46387: LIST
46388: LIST
46389: PUSH
46390: LD_INT 0
46392: PUSH
46393: LD_INT 2
46395: PUSH
46396: EMPTY
46397: LIST
46398: LIST
46399: PUSH
46400: LD_INT 1
46402: PUSH
46403: LD_INT 3
46405: PUSH
46406: EMPTY
46407: LIST
46408: LIST
46409: PUSH
46410: LD_INT 1
46412: PUSH
46413: LD_INT 4
46415: PUSH
46416: EMPTY
46417: LIST
46418: LIST
46419: PUSH
46420: LD_INT 0
46422: PUSH
46423: LD_INT 4
46425: PUSH
46426: EMPTY
46427: LIST
46428: LIST
46429: PUSH
46430: LD_INT 1
46432: NEG
46433: PUSH
46434: LD_INT 3
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: PUSH
46441: LD_INT 1
46443: NEG
46444: PUSH
46445: LD_INT 2
46447: PUSH
46448: EMPTY
46449: LIST
46450: LIST
46451: PUSH
46452: LD_INT 2
46454: PUSH
46455: LD_INT 4
46457: PUSH
46458: EMPTY
46459: LIST
46460: LIST
46461: PUSH
46462: LD_INT 2
46464: NEG
46465: PUSH
46466: LD_INT 2
46468: PUSH
46469: EMPTY
46470: LIST
46471: LIST
46472: PUSH
46473: LD_INT 4
46475: NEG
46476: PUSH
46477: LD_INT 0
46479: PUSH
46480: EMPTY
46481: LIST
46482: LIST
46483: PUSH
46484: LD_INT 4
46486: NEG
46487: PUSH
46488: LD_INT 1
46490: NEG
46491: PUSH
46492: EMPTY
46493: LIST
46494: LIST
46495: PUSH
46496: LD_INT 3
46498: NEG
46499: PUSH
46500: LD_INT 0
46502: PUSH
46503: EMPTY
46504: LIST
46505: LIST
46506: PUSH
46507: LD_INT 3
46509: NEG
46510: PUSH
46511: LD_INT 1
46513: PUSH
46514: EMPTY
46515: LIST
46516: LIST
46517: PUSH
46518: LD_INT 4
46520: NEG
46521: PUSH
46522: LD_INT 1
46524: PUSH
46525: EMPTY
46526: LIST
46527: LIST
46528: PUSH
46529: LD_INT 5
46531: NEG
46532: PUSH
46533: LD_INT 0
46535: PUSH
46536: EMPTY
46537: LIST
46538: LIST
46539: PUSH
46540: LD_INT 5
46542: NEG
46543: PUSH
46544: LD_INT 1
46546: NEG
46547: PUSH
46548: EMPTY
46549: LIST
46550: LIST
46551: PUSH
46552: LD_INT 5
46554: NEG
46555: PUSH
46556: LD_INT 2
46558: NEG
46559: PUSH
46560: EMPTY
46561: LIST
46562: LIST
46563: PUSH
46564: LD_INT 3
46566: NEG
46567: PUSH
46568: LD_INT 2
46570: PUSH
46571: EMPTY
46572: LIST
46573: LIST
46574: PUSH
46575: EMPTY
46576: LIST
46577: LIST
46578: LIST
46579: LIST
46580: LIST
46581: LIST
46582: LIST
46583: LIST
46584: LIST
46585: LIST
46586: LIST
46587: LIST
46588: LIST
46589: LIST
46590: LIST
46591: LIST
46592: LIST
46593: LIST
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: LIST
46608: LIST
46609: LIST
46610: LIST
46611: LIST
46612: LIST
46613: LIST
46614: LIST
46615: LIST
46616: LIST
46617: LIST
46618: LIST
46619: LIST
46620: LIST
46621: ST_TO_ADDR
// end ; end ;
46622: GO 46625
46624: POP
// case btype of b_depot , b_warehouse :
46625: LD_VAR 0 1
46629: PUSH
46630: LD_INT 0
46632: DOUBLE
46633: EQUAL
46634: IFTRUE 46644
46636: LD_INT 1
46638: DOUBLE
46639: EQUAL
46640: IFTRUE 46644
46642: GO 46845
46644: POP
// case nation of nation_american :
46645: LD_VAR 0 5
46649: PUSH
46650: LD_INT 1
46652: DOUBLE
46653: EQUAL
46654: IFTRUE 46658
46656: GO 46714
46658: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
46659: LD_ADDR_VAR 0 9
46663: PUSH
46664: LD_VAR 0 11
46668: PUSH
46669: LD_VAR 0 12
46673: PUSH
46674: LD_VAR 0 13
46678: PUSH
46679: LD_VAR 0 14
46683: PUSH
46684: LD_VAR 0 15
46688: PUSH
46689: LD_VAR 0 16
46693: PUSH
46694: EMPTY
46695: LIST
46696: LIST
46697: LIST
46698: LIST
46699: LIST
46700: LIST
46701: PUSH
46702: LD_VAR 0 4
46706: PUSH
46707: LD_INT 1
46709: PLUS
46710: ARRAY
46711: ST_TO_ADDR
46712: GO 46843
46714: LD_INT 2
46716: DOUBLE
46717: EQUAL
46718: IFTRUE 46722
46720: GO 46778
46722: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
46723: LD_ADDR_VAR 0 9
46727: PUSH
46728: LD_VAR 0 17
46732: PUSH
46733: LD_VAR 0 18
46737: PUSH
46738: LD_VAR 0 19
46742: PUSH
46743: LD_VAR 0 20
46747: PUSH
46748: LD_VAR 0 21
46752: PUSH
46753: LD_VAR 0 22
46757: PUSH
46758: EMPTY
46759: LIST
46760: LIST
46761: LIST
46762: LIST
46763: LIST
46764: LIST
46765: PUSH
46766: LD_VAR 0 4
46770: PUSH
46771: LD_INT 1
46773: PLUS
46774: ARRAY
46775: ST_TO_ADDR
46776: GO 46843
46778: LD_INT 3
46780: DOUBLE
46781: EQUAL
46782: IFTRUE 46786
46784: GO 46842
46786: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46787: LD_ADDR_VAR 0 9
46791: PUSH
46792: LD_VAR 0 23
46796: PUSH
46797: LD_VAR 0 24
46801: PUSH
46802: LD_VAR 0 25
46806: PUSH
46807: LD_VAR 0 26
46811: PUSH
46812: LD_VAR 0 27
46816: PUSH
46817: LD_VAR 0 28
46821: PUSH
46822: EMPTY
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: PUSH
46830: LD_VAR 0 4
46834: PUSH
46835: LD_INT 1
46837: PLUS
46838: ARRAY
46839: ST_TO_ADDR
46840: GO 46843
46842: POP
46843: GO 47398
46845: LD_INT 2
46847: DOUBLE
46848: EQUAL
46849: IFTRUE 46859
46851: LD_INT 3
46853: DOUBLE
46854: EQUAL
46855: IFTRUE 46859
46857: GO 46915
46859: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46860: LD_ADDR_VAR 0 9
46864: PUSH
46865: LD_VAR 0 29
46869: PUSH
46870: LD_VAR 0 30
46874: PUSH
46875: LD_VAR 0 31
46879: PUSH
46880: LD_VAR 0 32
46884: PUSH
46885: LD_VAR 0 33
46889: PUSH
46890: LD_VAR 0 34
46894: PUSH
46895: EMPTY
46896: LIST
46897: LIST
46898: LIST
46899: LIST
46900: LIST
46901: LIST
46902: PUSH
46903: LD_VAR 0 4
46907: PUSH
46908: LD_INT 1
46910: PLUS
46911: ARRAY
46912: ST_TO_ADDR
46913: GO 47398
46915: LD_INT 16
46917: DOUBLE
46918: EQUAL
46919: IFTRUE 46977
46921: LD_INT 17
46923: DOUBLE
46924: EQUAL
46925: IFTRUE 46977
46927: LD_INT 18
46929: DOUBLE
46930: EQUAL
46931: IFTRUE 46977
46933: LD_INT 19
46935: DOUBLE
46936: EQUAL
46937: IFTRUE 46977
46939: LD_INT 22
46941: DOUBLE
46942: EQUAL
46943: IFTRUE 46977
46945: LD_INT 20
46947: DOUBLE
46948: EQUAL
46949: IFTRUE 46977
46951: LD_INT 21
46953: DOUBLE
46954: EQUAL
46955: IFTRUE 46977
46957: LD_INT 23
46959: DOUBLE
46960: EQUAL
46961: IFTRUE 46977
46963: LD_INT 24
46965: DOUBLE
46966: EQUAL
46967: IFTRUE 46977
46969: LD_INT 25
46971: DOUBLE
46972: EQUAL
46973: IFTRUE 46977
46975: GO 47033
46977: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46978: LD_ADDR_VAR 0 9
46982: PUSH
46983: LD_VAR 0 35
46987: PUSH
46988: LD_VAR 0 36
46992: PUSH
46993: LD_VAR 0 37
46997: PUSH
46998: LD_VAR 0 38
47002: PUSH
47003: LD_VAR 0 39
47007: PUSH
47008: LD_VAR 0 40
47012: PUSH
47013: EMPTY
47014: LIST
47015: LIST
47016: LIST
47017: LIST
47018: LIST
47019: LIST
47020: PUSH
47021: LD_VAR 0 4
47025: PUSH
47026: LD_INT 1
47028: PLUS
47029: ARRAY
47030: ST_TO_ADDR
47031: GO 47398
47033: LD_INT 6
47035: DOUBLE
47036: EQUAL
47037: IFTRUE 47089
47039: LD_INT 7
47041: DOUBLE
47042: EQUAL
47043: IFTRUE 47089
47045: LD_INT 8
47047: DOUBLE
47048: EQUAL
47049: IFTRUE 47089
47051: LD_INT 13
47053: DOUBLE
47054: EQUAL
47055: IFTRUE 47089
47057: LD_INT 12
47059: DOUBLE
47060: EQUAL
47061: IFTRUE 47089
47063: LD_INT 15
47065: DOUBLE
47066: EQUAL
47067: IFTRUE 47089
47069: LD_INT 11
47071: DOUBLE
47072: EQUAL
47073: IFTRUE 47089
47075: LD_INT 14
47077: DOUBLE
47078: EQUAL
47079: IFTRUE 47089
47081: LD_INT 10
47083: DOUBLE
47084: EQUAL
47085: IFTRUE 47089
47087: GO 47145
47089: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
47090: LD_ADDR_VAR 0 9
47094: PUSH
47095: LD_VAR 0 41
47099: PUSH
47100: LD_VAR 0 42
47104: PUSH
47105: LD_VAR 0 43
47109: PUSH
47110: LD_VAR 0 44
47114: PUSH
47115: LD_VAR 0 45
47119: PUSH
47120: LD_VAR 0 46
47124: PUSH
47125: EMPTY
47126: LIST
47127: LIST
47128: LIST
47129: LIST
47130: LIST
47131: LIST
47132: PUSH
47133: LD_VAR 0 4
47137: PUSH
47138: LD_INT 1
47140: PLUS
47141: ARRAY
47142: ST_TO_ADDR
47143: GO 47398
47145: LD_INT 36
47147: DOUBLE
47148: EQUAL
47149: IFTRUE 47153
47151: GO 47209
47153: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47154: LD_ADDR_VAR 0 9
47158: PUSH
47159: LD_VAR 0 47
47163: PUSH
47164: LD_VAR 0 48
47168: PUSH
47169: LD_VAR 0 49
47173: PUSH
47174: LD_VAR 0 50
47178: PUSH
47179: LD_VAR 0 51
47183: PUSH
47184: LD_VAR 0 52
47188: PUSH
47189: EMPTY
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: PUSH
47197: LD_VAR 0 4
47201: PUSH
47202: LD_INT 1
47204: PLUS
47205: ARRAY
47206: ST_TO_ADDR
47207: GO 47398
47209: LD_INT 4
47211: DOUBLE
47212: EQUAL
47213: IFTRUE 47235
47215: LD_INT 5
47217: DOUBLE
47218: EQUAL
47219: IFTRUE 47235
47221: LD_INT 34
47223: DOUBLE
47224: EQUAL
47225: IFTRUE 47235
47227: LD_INT 37
47229: DOUBLE
47230: EQUAL
47231: IFTRUE 47235
47233: GO 47291
47235: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47236: LD_ADDR_VAR 0 9
47240: PUSH
47241: LD_VAR 0 53
47245: PUSH
47246: LD_VAR 0 54
47250: PUSH
47251: LD_VAR 0 55
47255: PUSH
47256: LD_VAR 0 56
47260: PUSH
47261: LD_VAR 0 57
47265: PUSH
47266: LD_VAR 0 58
47270: PUSH
47271: EMPTY
47272: LIST
47273: LIST
47274: LIST
47275: LIST
47276: LIST
47277: LIST
47278: PUSH
47279: LD_VAR 0 4
47283: PUSH
47284: LD_INT 1
47286: PLUS
47287: ARRAY
47288: ST_TO_ADDR
47289: GO 47398
47291: LD_INT 31
47293: DOUBLE
47294: EQUAL
47295: IFTRUE 47341
47297: LD_INT 32
47299: DOUBLE
47300: EQUAL
47301: IFTRUE 47341
47303: LD_INT 33
47305: DOUBLE
47306: EQUAL
47307: IFTRUE 47341
47309: LD_INT 27
47311: DOUBLE
47312: EQUAL
47313: IFTRUE 47341
47315: LD_INT 26
47317: DOUBLE
47318: EQUAL
47319: IFTRUE 47341
47321: LD_INT 28
47323: DOUBLE
47324: EQUAL
47325: IFTRUE 47341
47327: LD_INT 29
47329: DOUBLE
47330: EQUAL
47331: IFTRUE 47341
47333: LD_INT 30
47335: DOUBLE
47336: EQUAL
47337: IFTRUE 47341
47339: GO 47397
47341: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
47342: LD_ADDR_VAR 0 9
47346: PUSH
47347: LD_VAR 0 59
47351: PUSH
47352: LD_VAR 0 60
47356: PUSH
47357: LD_VAR 0 61
47361: PUSH
47362: LD_VAR 0 62
47366: PUSH
47367: LD_VAR 0 63
47371: PUSH
47372: LD_VAR 0 64
47376: PUSH
47377: EMPTY
47378: LIST
47379: LIST
47380: LIST
47381: LIST
47382: LIST
47383: LIST
47384: PUSH
47385: LD_VAR 0 4
47389: PUSH
47390: LD_INT 1
47392: PLUS
47393: ARRAY
47394: ST_TO_ADDR
47395: GO 47398
47397: POP
// temp_list2 = [ ] ;
47398: LD_ADDR_VAR 0 10
47402: PUSH
47403: EMPTY
47404: ST_TO_ADDR
// for i in temp_list do
47405: LD_ADDR_VAR 0 8
47409: PUSH
47410: LD_VAR 0 9
47414: PUSH
47415: FOR_IN
47416: IFFALSE 47468
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47418: LD_ADDR_VAR 0 10
47422: PUSH
47423: LD_VAR 0 10
47427: PUSH
47428: LD_VAR 0 8
47432: PUSH
47433: LD_INT 1
47435: ARRAY
47436: PUSH
47437: LD_VAR 0 2
47441: PLUS
47442: PUSH
47443: LD_VAR 0 8
47447: PUSH
47448: LD_INT 2
47450: ARRAY
47451: PUSH
47452: LD_VAR 0 3
47456: PLUS
47457: PUSH
47458: EMPTY
47459: LIST
47460: LIST
47461: PUSH
47462: EMPTY
47463: LIST
47464: ADD
47465: ST_TO_ADDR
47466: GO 47415
47468: POP
47469: POP
// result = temp_list2 ;
47470: LD_ADDR_VAR 0 7
47474: PUSH
47475: LD_VAR 0 10
47479: ST_TO_ADDR
// end ;
47480: LD_VAR 0 7
47484: RET
// export function EnemyInRange ( unit , dist ) ; begin
47485: LD_INT 0
47487: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47488: LD_ADDR_VAR 0 3
47492: PUSH
47493: LD_VAR 0 1
47497: PPUSH
47498: CALL_OW 255
47502: PPUSH
47503: LD_VAR 0 1
47507: PPUSH
47508: CALL_OW 250
47512: PPUSH
47513: LD_VAR 0 1
47517: PPUSH
47518: CALL_OW 251
47522: PPUSH
47523: LD_VAR 0 2
47527: PPUSH
47528: CALL 20887 0 4
47532: PUSH
47533: LD_INT 4
47535: ARRAY
47536: ST_TO_ADDR
// end ;
47537: LD_VAR 0 3
47541: RET
// export function PlayerSeeMe ( unit ) ; begin
47542: LD_INT 0
47544: PPUSH
// result := See ( your_side , unit ) ;
47545: LD_ADDR_VAR 0 2
47549: PUSH
47550: LD_OWVAR 2
47554: PPUSH
47555: LD_VAR 0 1
47559: PPUSH
47560: CALL_OW 292
47564: ST_TO_ADDR
// end ;
47565: LD_VAR 0 2
47569: RET
// export function ReverseDir ( unit ) ; begin
47570: LD_INT 0
47572: PPUSH
// if not unit then
47573: LD_VAR 0 1
47577: NOT
47578: IFFALSE 47582
// exit ;
47580: GO 47605
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
47582: LD_ADDR_VAR 0 2
47586: PUSH
47587: LD_VAR 0 1
47591: PPUSH
47592: CALL_OW 254
47596: PUSH
47597: LD_INT 3
47599: PLUS
47600: PUSH
47601: LD_INT 6
47603: MOD
47604: ST_TO_ADDR
// end ;
47605: LD_VAR 0 2
47609: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
47610: LD_INT 0
47612: PPUSH
47613: PPUSH
47614: PPUSH
47615: PPUSH
47616: PPUSH
47617: PPUSH
// if not unit or not hexes then
47618: LD_VAR 0 1
47622: NOT
47623: PUSH
47624: LD_VAR 0 2
47628: NOT
47629: OR
47630: IFFALSE 47634
// exit ;
47632: GO 47757
// dist := 9999 ;
47634: LD_ADDR_VAR 0 5
47638: PUSH
47639: LD_INT 9999
47641: ST_TO_ADDR
// for i = 1 to hexes do
47642: LD_ADDR_VAR 0 4
47646: PUSH
47647: DOUBLE
47648: LD_INT 1
47650: DEC
47651: ST_TO_ADDR
47652: LD_VAR 0 2
47656: PUSH
47657: FOR_TO
47658: IFFALSE 47745
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47660: LD_ADDR_VAR 0 6
47664: PUSH
47665: LD_VAR 0 1
47669: PPUSH
47670: LD_VAR 0 2
47674: PUSH
47675: LD_VAR 0 4
47679: ARRAY
47680: PUSH
47681: LD_INT 1
47683: ARRAY
47684: PPUSH
47685: LD_VAR 0 2
47689: PUSH
47690: LD_VAR 0 4
47694: ARRAY
47695: PUSH
47696: LD_INT 2
47698: ARRAY
47699: PPUSH
47700: CALL_OW 297
47704: ST_TO_ADDR
// if tdist < dist then
47705: LD_VAR 0 6
47709: PUSH
47710: LD_VAR 0 5
47714: LESS
47715: IFFALSE 47743
// begin hex := hexes [ i ] ;
47717: LD_ADDR_VAR 0 8
47721: PUSH
47722: LD_VAR 0 2
47726: PUSH
47727: LD_VAR 0 4
47731: ARRAY
47732: ST_TO_ADDR
// dist := tdist ;
47733: LD_ADDR_VAR 0 5
47737: PUSH
47738: LD_VAR 0 6
47742: ST_TO_ADDR
// end ; end ;
47743: GO 47657
47745: POP
47746: POP
// result := hex ;
47747: LD_ADDR_VAR 0 3
47751: PUSH
47752: LD_VAR 0 8
47756: ST_TO_ADDR
// end ;
47757: LD_VAR 0 3
47761: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47762: LD_INT 0
47764: PPUSH
47765: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47766: LD_VAR 0 1
47770: NOT
47771: PUSH
47772: LD_VAR 0 1
47776: PUSH
47777: LD_INT 21
47779: PUSH
47780: LD_INT 2
47782: PUSH
47783: EMPTY
47784: LIST
47785: LIST
47786: PUSH
47787: LD_INT 23
47789: PUSH
47790: LD_INT 2
47792: PUSH
47793: EMPTY
47794: LIST
47795: LIST
47796: PUSH
47797: EMPTY
47798: LIST
47799: LIST
47800: PPUSH
47801: CALL_OW 69
47805: IN
47806: NOT
47807: OR
47808: IFFALSE 47812
// exit ;
47810: GO 47859
// for i = 1 to 3 do
47812: LD_ADDR_VAR 0 3
47816: PUSH
47817: DOUBLE
47818: LD_INT 1
47820: DEC
47821: ST_TO_ADDR
47822: LD_INT 3
47824: PUSH
47825: FOR_TO
47826: IFFALSE 47857
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47828: LD_VAR 0 1
47832: PPUSH
47833: CALL_OW 250
47837: PPUSH
47838: LD_VAR 0 1
47842: PPUSH
47843: CALL_OW 251
47847: PPUSH
47848: LD_INT 1
47850: PPUSH
47851: CALL_OW 453
47855: GO 47825
47857: POP
47858: POP
// end ;
47859: LD_VAR 0 2
47863: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47864: LD_INT 0
47866: PPUSH
47867: PPUSH
47868: PPUSH
47869: PPUSH
47870: PPUSH
47871: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47872: LD_VAR 0 1
47876: NOT
47877: PUSH
47878: LD_VAR 0 2
47882: NOT
47883: OR
47884: PUSH
47885: LD_VAR 0 1
47889: PPUSH
47890: CALL_OW 314
47894: OR
47895: IFFALSE 47899
// exit ;
47897: GO 48340
// x := GetX ( enemy_unit ) ;
47899: LD_ADDR_VAR 0 7
47903: PUSH
47904: LD_VAR 0 2
47908: PPUSH
47909: CALL_OW 250
47913: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47914: LD_ADDR_VAR 0 8
47918: PUSH
47919: LD_VAR 0 2
47923: PPUSH
47924: CALL_OW 251
47928: ST_TO_ADDR
// if not x or not y then
47929: LD_VAR 0 7
47933: NOT
47934: PUSH
47935: LD_VAR 0 8
47939: NOT
47940: OR
47941: IFFALSE 47945
// exit ;
47943: GO 48340
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47945: LD_ADDR_VAR 0 6
47949: PUSH
47950: LD_VAR 0 7
47954: PPUSH
47955: LD_INT 0
47957: PPUSH
47958: LD_INT 4
47960: PPUSH
47961: CALL_OW 272
47965: PUSH
47966: LD_VAR 0 8
47970: PPUSH
47971: LD_INT 0
47973: PPUSH
47974: LD_INT 4
47976: PPUSH
47977: CALL_OW 273
47981: PUSH
47982: EMPTY
47983: LIST
47984: LIST
47985: PUSH
47986: LD_VAR 0 7
47990: PPUSH
47991: LD_INT 1
47993: PPUSH
47994: LD_INT 4
47996: PPUSH
47997: CALL_OW 272
48001: PUSH
48002: LD_VAR 0 8
48006: PPUSH
48007: LD_INT 1
48009: PPUSH
48010: LD_INT 4
48012: PPUSH
48013: CALL_OW 273
48017: PUSH
48018: EMPTY
48019: LIST
48020: LIST
48021: PUSH
48022: LD_VAR 0 7
48026: PPUSH
48027: LD_INT 2
48029: PPUSH
48030: LD_INT 4
48032: PPUSH
48033: CALL_OW 272
48037: PUSH
48038: LD_VAR 0 8
48042: PPUSH
48043: LD_INT 2
48045: PPUSH
48046: LD_INT 4
48048: PPUSH
48049: CALL_OW 273
48053: PUSH
48054: EMPTY
48055: LIST
48056: LIST
48057: PUSH
48058: LD_VAR 0 7
48062: PPUSH
48063: LD_INT 3
48065: PPUSH
48066: LD_INT 4
48068: PPUSH
48069: CALL_OW 272
48073: PUSH
48074: LD_VAR 0 8
48078: PPUSH
48079: LD_INT 3
48081: PPUSH
48082: LD_INT 4
48084: PPUSH
48085: CALL_OW 273
48089: PUSH
48090: EMPTY
48091: LIST
48092: LIST
48093: PUSH
48094: LD_VAR 0 7
48098: PPUSH
48099: LD_INT 4
48101: PPUSH
48102: LD_INT 4
48104: PPUSH
48105: CALL_OW 272
48109: PUSH
48110: LD_VAR 0 8
48114: PPUSH
48115: LD_INT 4
48117: PPUSH
48118: LD_INT 4
48120: PPUSH
48121: CALL_OW 273
48125: PUSH
48126: EMPTY
48127: LIST
48128: LIST
48129: PUSH
48130: LD_VAR 0 7
48134: PPUSH
48135: LD_INT 5
48137: PPUSH
48138: LD_INT 4
48140: PPUSH
48141: CALL_OW 272
48145: PUSH
48146: LD_VAR 0 8
48150: PPUSH
48151: LD_INT 5
48153: PPUSH
48154: LD_INT 4
48156: PPUSH
48157: CALL_OW 273
48161: PUSH
48162: EMPTY
48163: LIST
48164: LIST
48165: PUSH
48166: EMPTY
48167: LIST
48168: LIST
48169: LIST
48170: LIST
48171: LIST
48172: LIST
48173: ST_TO_ADDR
// for i = tmp downto 1 do
48174: LD_ADDR_VAR 0 4
48178: PUSH
48179: DOUBLE
48180: LD_VAR 0 6
48184: INC
48185: ST_TO_ADDR
48186: LD_INT 1
48188: PUSH
48189: FOR_DOWNTO
48190: IFFALSE 48291
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48192: LD_VAR 0 6
48196: PUSH
48197: LD_VAR 0 4
48201: ARRAY
48202: PUSH
48203: LD_INT 1
48205: ARRAY
48206: PPUSH
48207: LD_VAR 0 6
48211: PUSH
48212: LD_VAR 0 4
48216: ARRAY
48217: PUSH
48218: LD_INT 2
48220: ARRAY
48221: PPUSH
48222: CALL_OW 488
48226: NOT
48227: PUSH
48228: LD_VAR 0 6
48232: PUSH
48233: LD_VAR 0 4
48237: ARRAY
48238: PUSH
48239: LD_INT 1
48241: ARRAY
48242: PPUSH
48243: LD_VAR 0 6
48247: PUSH
48248: LD_VAR 0 4
48252: ARRAY
48253: PUSH
48254: LD_INT 2
48256: ARRAY
48257: PPUSH
48258: CALL_OW 428
48262: PUSH
48263: LD_INT 0
48265: NONEQUAL
48266: OR
48267: IFFALSE 48289
// tmp := Delete ( tmp , i ) ;
48269: LD_ADDR_VAR 0 6
48273: PUSH
48274: LD_VAR 0 6
48278: PPUSH
48279: LD_VAR 0 4
48283: PPUSH
48284: CALL_OW 3
48288: ST_TO_ADDR
48289: GO 48189
48291: POP
48292: POP
// j := GetClosestHex ( unit , tmp ) ;
48293: LD_ADDR_VAR 0 5
48297: PUSH
48298: LD_VAR 0 1
48302: PPUSH
48303: LD_VAR 0 6
48307: PPUSH
48308: CALL 47610 0 2
48312: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48313: LD_VAR 0 1
48317: PPUSH
48318: LD_VAR 0 5
48322: PUSH
48323: LD_INT 1
48325: ARRAY
48326: PPUSH
48327: LD_VAR 0 5
48331: PUSH
48332: LD_INT 2
48334: ARRAY
48335: PPUSH
48336: CALL_OW 111
// end ;
48340: LD_VAR 0 3
48344: RET
// export function PrepareApemanSoldier ( ) ; begin
48345: LD_INT 0
48347: PPUSH
// uc_nation := 0 ;
48348: LD_ADDR_OWVAR 21
48352: PUSH
48353: LD_INT 0
48355: ST_TO_ADDR
// hc_sex := sex_male ;
48356: LD_ADDR_OWVAR 27
48360: PUSH
48361: LD_INT 1
48363: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
48364: LD_ADDR_OWVAR 28
48368: PUSH
48369: LD_INT 15
48371: ST_TO_ADDR
// hc_gallery :=  ;
48372: LD_ADDR_OWVAR 33
48376: PUSH
48377: LD_STRING 
48379: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48380: LD_ADDR_OWVAR 31
48384: PUSH
48385: LD_INT 0
48387: PPUSH
48388: LD_INT 3
48390: PPUSH
48391: CALL_OW 12
48395: PUSH
48396: LD_INT 0
48398: PPUSH
48399: LD_INT 3
48401: PPUSH
48402: CALL_OW 12
48406: PUSH
48407: LD_INT 0
48409: PUSH
48410: LD_INT 0
48412: PUSH
48413: EMPTY
48414: LIST
48415: LIST
48416: LIST
48417: LIST
48418: ST_TO_ADDR
// end ;
48419: LD_VAR 0 1
48423: RET
// export function PrepareApemanEngineer ( ) ; begin
48424: LD_INT 0
48426: PPUSH
// uc_nation := 0 ;
48427: LD_ADDR_OWVAR 21
48431: PUSH
48432: LD_INT 0
48434: ST_TO_ADDR
// hc_sex := sex_male ;
48435: LD_ADDR_OWVAR 27
48439: PUSH
48440: LD_INT 1
48442: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
48443: LD_ADDR_OWVAR 28
48447: PUSH
48448: LD_INT 16
48450: ST_TO_ADDR
// hc_gallery :=  ;
48451: LD_ADDR_OWVAR 33
48455: PUSH
48456: LD_STRING 
48458: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48459: LD_ADDR_OWVAR 31
48463: PUSH
48464: LD_INT 0
48466: PPUSH
48467: LD_INT 3
48469: PPUSH
48470: CALL_OW 12
48474: PUSH
48475: LD_INT 0
48477: PPUSH
48478: LD_INT 3
48480: PPUSH
48481: CALL_OW 12
48485: PUSH
48486: LD_INT 0
48488: PUSH
48489: LD_INT 0
48491: PUSH
48492: EMPTY
48493: LIST
48494: LIST
48495: LIST
48496: LIST
48497: ST_TO_ADDR
// end ;
48498: LD_VAR 0 1
48502: RET
// export function PrepareApeman ( agressivity ) ; begin
48503: LD_INT 0
48505: PPUSH
// uc_side := 0 ;
48506: LD_ADDR_OWVAR 20
48510: PUSH
48511: LD_INT 0
48513: ST_TO_ADDR
// uc_nation := 0 ;
48514: LD_ADDR_OWVAR 21
48518: PUSH
48519: LD_INT 0
48521: ST_TO_ADDR
// hc_sex := sex_male ;
48522: LD_ADDR_OWVAR 27
48526: PUSH
48527: LD_INT 1
48529: ST_TO_ADDR
// hc_class := class_apeman ;
48530: LD_ADDR_OWVAR 28
48534: PUSH
48535: LD_INT 12
48537: ST_TO_ADDR
// hc_gallery :=  ;
48538: LD_ADDR_OWVAR 33
48542: PUSH
48543: LD_STRING 
48545: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
48546: LD_ADDR_OWVAR 35
48550: PUSH
48551: LD_VAR 0 1
48555: NEG
48556: PPUSH
48557: LD_VAR 0 1
48561: PPUSH
48562: CALL_OW 12
48566: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48567: LD_ADDR_OWVAR 31
48571: PUSH
48572: LD_INT 0
48574: PPUSH
48575: LD_INT 3
48577: PPUSH
48578: CALL_OW 12
48582: PUSH
48583: LD_INT 0
48585: PPUSH
48586: LD_INT 3
48588: PPUSH
48589: CALL_OW 12
48593: PUSH
48594: LD_INT 0
48596: PUSH
48597: LD_INT 0
48599: PUSH
48600: EMPTY
48601: LIST
48602: LIST
48603: LIST
48604: LIST
48605: ST_TO_ADDR
// end ;
48606: LD_VAR 0 2
48610: RET
// export function PrepareTiger ( agressivity ) ; begin
48611: LD_INT 0
48613: PPUSH
// uc_side := 0 ;
48614: LD_ADDR_OWVAR 20
48618: PUSH
48619: LD_INT 0
48621: ST_TO_ADDR
// uc_nation := 0 ;
48622: LD_ADDR_OWVAR 21
48626: PUSH
48627: LD_INT 0
48629: ST_TO_ADDR
// hc_class := class_tiger ;
48630: LD_ADDR_OWVAR 28
48634: PUSH
48635: LD_INT 14
48637: ST_TO_ADDR
// hc_gallery :=  ;
48638: LD_ADDR_OWVAR 33
48642: PUSH
48643: LD_STRING 
48645: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
48646: LD_ADDR_OWVAR 35
48650: PUSH
48651: LD_VAR 0 1
48655: NEG
48656: PPUSH
48657: LD_VAR 0 1
48661: PPUSH
48662: CALL_OW 12
48666: ST_TO_ADDR
// end ;
48667: LD_VAR 0 2
48671: RET
// export function PrepareEnchidna ( ) ; begin
48672: LD_INT 0
48674: PPUSH
// uc_side := 0 ;
48675: LD_ADDR_OWVAR 20
48679: PUSH
48680: LD_INT 0
48682: ST_TO_ADDR
// uc_nation := 0 ;
48683: LD_ADDR_OWVAR 21
48687: PUSH
48688: LD_INT 0
48690: ST_TO_ADDR
// hc_class := class_baggie ;
48691: LD_ADDR_OWVAR 28
48695: PUSH
48696: LD_INT 13
48698: ST_TO_ADDR
// hc_gallery :=  ;
48699: LD_ADDR_OWVAR 33
48703: PUSH
48704: LD_STRING 
48706: ST_TO_ADDR
// end ;
48707: LD_VAR 0 1
48711: RET
// export function PrepareFrog ( ) ; begin
48712: LD_INT 0
48714: PPUSH
// uc_side := 0 ;
48715: LD_ADDR_OWVAR 20
48719: PUSH
48720: LD_INT 0
48722: ST_TO_ADDR
// uc_nation := 0 ;
48723: LD_ADDR_OWVAR 21
48727: PUSH
48728: LD_INT 0
48730: ST_TO_ADDR
// hc_class := class_frog ;
48731: LD_ADDR_OWVAR 28
48735: PUSH
48736: LD_INT 19
48738: ST_TO_ADDR
// hc_gallery :=  ;
48739: LD_ADDR_OWVAR 33
48743: PUSH
48744: LD_STRING 
48746: ST_TO_ADDR
// end ;
48747: LD_VAR 0 1
48751: RET
// export function PrepareFish ( ) ; begin
48752: LD_INT 0
48754: PPUSH
// uc_side := 0 ;
48755: LD_ADDR_OWVAR 20
48759: PUSH
48760: LD_INT 0
48762: ST_TO_ADDR
// uc_nation := 0 ;
48763: LD_ADDR_OWVAR 21
48767: PUSH
48768: LD_INT 0
48770: ST_TO_ADDR
// hc_class := class_fish ;
48771: LD_ADDR_OWVAR 28
48775: PUSH
48776: LD_INT 20
48778: ST_TO_ADDR
// hc_gallery :=  ;
48779: LD_ADDR_OWVAR 33
48783: PUSH
48784: LD_STRING 
48786: ST_TO_ADDR
// end ;
48787: LD_VAR 0 1
48791: RET
// export function PrepareBird ( ) ; begin
48792: LD_INT 0
48794: PPUSH
// uc_side := 0 ;
48795: LD_ADDR_OWVAR 20
48799: PUSH
48800: LD_INT 0
48802: ST_TO_ADDR
// uc_nation := 0 ;
48803: LD_ADDR_OWVAR 21
48807: PUSH
48808: LD_INT 0
48810: ST_TO_ADDR
// hc_class := class_phororhacos ;
48811: LD_ADDR_OWVAR 28
48815: PUSH
48816: LD_INT 18
48818: ST_TO_ADDR
// hc_gallery :=  ;
48819: LD_ADDR_OWVAR 33
48823: PUSH
48824: LD_STRING 
48826: ST_TO_ADDR
// end ;
48827: LD_VAR 0 1
48831: RET
// export function PrepareHorse ( ) ; begin
48832: LD_INT 0
48834: PPUSH
// uc_side := 0 ;
48835: LD_ADDR_OWVAR 20
48839: PUSH
48840: LD_INT 0
48842: ST_TO_ADDR
// uc_nation := 0 ;
48843: LD_ADDR_OWVAR 21
48847: PUSH
48848: LD_INT 0
48850: ST_TO_ADDR
// hc_class := class_horse ;
48851: LD_ADDR_OWVAR 28
48855: PUSH
48856: LD_INT 21
48858: ST_TO_ADDR
// hc_gallery :=  ;
48859: LD_ADDR_OWVAR 33
48863: PUSH
48864: LD_STRING 
48866: ST_TO_ADDR
// end ;
48867: LD_VAR 0 1
48871: RET
// export function PrepareMastodont ( ) ; begin
48872: LD_INT 0
48874: PPUSH
// uc_side := 0 ;
48875: LD_ADDR_OWVAR 20
48879: PUSH
48880: LD_INT 0
48882: ST_TO_ADDR
// uc_nation := 0 ;
48883: LD_ADDR_OWVAR 21
48887: PUSH
48888: LD_INT 0
48890: ST_TO_ADDR
// vc_chassis := class_mastodont ;
48891: LD_ADDR_OWVAR 37
48895: PUSH
48896: LD_INT 31
48898: ST_TO_ADDR
// vc_control := control_rider ;
48899: LD_ADDR_OWVAR 38
48903: PUSH
48904: LD_INT 4
48906: ST_TO_ADDR
// end ;
48907: LD_VAR 0 1
48911: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48912: LD_INT 0
48914: PPUSH
48915: PPUSH
48916: PPUSH
// uc_side = 0 ;
48917: LD_ADDR_OWVAR 20
48921: PUSH
48922: LD_INT 0
48924: ST_TO_ADDR
// uc_nation = 0 ;
48925: LD_ADDR_OWVAR 21
48929: PUSH
48930: LD_INT 0
48932: ST_TO_ADDR
// InitHc_All ( ) ;
48933: CALL_OW 584
// InitVc ;
48937: CALL_OW 20
// if mastodonts then
48941: LD_VAR 0 6
48945: IFFALSE 49012
// for i = 1 to mastodonts do
48947: LD_ADDR_VAR 0 11
48951: PUSH
48952: DOUBLE
48953: LD_INT 1
48955: DEC
48956: ST_TO_ADDR
48957: LD_VAR 0 6
48961: PUSH
48962: FOR_TO
48963: IFFALSE 49010
// begin vc_chassis := 31 ;
48965: LD_ADDR_OWVAR 37
48969: PUSH
48970: LD_INT 31
48972: ST_TO_ADDR
// vc_control := control_rider ;
48973: LD_ADDR_OWVAR 38
48977: PUSH
48978: LD_INT 4
48980: ST_TO_ADDR
// animal := CreateVehicle ;
48981: LD_ADDR_VAR 0 12
48985: PUSH
48986: CALL_OW 45
48990: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48991: LD_VAR 0 12
48995: PPUSH
48996: LD_VAR 0 8
49000: PPUSH
49001: LD_INT 0
49003: PPUSH
49004: CALL 51147 0 3
// end ;
49008: GO 48962
49010: POP
49011: POP
// if horses then
49012: LD_VAR 0 5
49016: IFFALSE 49083
// for i = 1 to horses do
49018: LD_ADDR_VAR 0 11
49022: PUSH
49023: DOUBLE
49024: LD_INT 1
49026: DEC
49027: ST_TO_ADDR
49028: LD_VAR 0 5
49032: PUSH
49033: FOR_TO
49034: IFFALSE 49081
// begin hc_class := 21 ;
49036: LD_ADDR_OWVAR 28
49040: PUSH
49041: LD_INT 21
49043: ST_TO_ADDR
// hc_gallery :=  ;
49044: LD_ADDR_OWVAR 33
49048: PUSH
49049: LD_STRING 
49051: ST_TO_ADDR
// animal := CreateHuman ;
49052: LD_ADDR_VAR 0 12
49056: PUSH
49057: CALL_OW 44
49061: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49062: LD_VAR 0 12
49066: PPUSH
49067: LD_VAR 0 8
49071: PPUSH
49072: LD_INT 0
49074: PPUSH
49075: CALL 51147 0 3
// end ;
49079: GO 49033
49081: POP
49082: POP
// if birds then
49083: LD_VAR 0 1
49087: IFFALSE 49154
// for i = 1 to birds do
49089: LD_ADDR_VAR 0 11
49093: PUSH
49094: DOUBLE
49095: LD_INT 1
49097: DEC
49098: ST_TO_ADDR
49099: LD_VAR 0 1
49103: PUSH
49104: FOR_TO
49105: IFFALSE 49152
// begin hc_class = 18 ;
49107: LD_ADDR_OWVAR 28
49111: PUSH
49112: LD_INT 18
49114: ST_TO_ADDR
// hc_gallery =  ;
49115: LD_ADDR_OWVAR 33
49119: PUSH
49120: LD_STRING 
49122: ST_TO_ADDR
// animal := CreateHuman ;
49123: LD_ADDR_VAR 0 12
49127: PUSH
49128: CALL_OW 44
49132: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49133: LD_VAR 0 12
49137: PPUSH
49138: LD_VAR 0 8
49142: PPUSH
49143: LD_INT 0
49145: PPUSH
49146: CALL 51147 0 3
// end ;
49150: GO 49104
49152: POP
49153: POP
// if tigers then
49154: LD_VAR 0 2
49158: IFFALSE 49242
// for i = 1 to tigers do
49160: LD_ADDR_VAR 0 11
49164: PUSH
49165: DOUBLE
49166: LD_INT 1
49168: DEC
49169: ST_TO_ADDR
49170: LD_VAR 0 2
49174: PUSH
49175: FOR_TO
49176: IFFALSE 49240
// begin hc_class = class_tiger ;
49178: LD_ADDR_OWVAR 28
49182: PUSH
49183: LD_INT 14
49185: ST_TO_ADDR
// hc_gallery =  ;
49186: LD_ADDR_OWVAR 33
49190: PUSH
49191: LD_STRING 
49193: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49194: LD_ADDR_OWVAR 35
49198: PUSH
49199: LD_INT 7
49201: NEG
49202: PPUSH
49203: LD_INT 7
49205: PPUSH
49206: CALL_OW 12
49210: ST_TO_ADDR
// animal := CreateHuman ;
49211: LD_ADDR_VAR 0 12
49215: PUSH
49216: CALL_OW 44
49220: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49221: LD_VAR 0 12
49225: PPUSH
49226: LD_VAR 0 8
49230: PPUSH
49231: LD_INT 0
49233: PPUSH
49234: CALL 51147 0 3
// end ;
49238: GO 49175
49240: POP
49241: POP
// if apemans then
49242: LD_VAR 0 3
49246: IFFALSE 49369
// for i = 1 to apemans do
49248: LD_ADDR_VAR 0 11
49252: PUSH
49253: DOUBLE
49254: LD_INT 1
49256: DEC
49257: ST_TO_ADDR
49258: LD_VAR 0 3
49262: PUSH
49263: FOR_TO
49264: IFFALSE 49367
// begin hc_class = class_apeman ;
49266: LD_ADDR_OWVAR 28
49270: PUSH
49271: LD_INT 12
49273: ST_TO_ADDR
// hc_gallery =  ;
49274: LD_ADDR_OWVAR 33
49278: PUSH
49279: LD_STRING 
49281: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
49282: LD_ADDR_OWVAR 35
49286: PUSH
49287: LD_INT 2
49289: NEG
49290: PPUSH
49291: LD_INT 2
49293: PPUSH
49294: CALL_OW 12
49298: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49299: LD_ADDR_OWVAR 31
49303: PUSH
49304: LD_INT 1
49306: PPUSH
49307: LD_INT 3
49309: PPUSH
49310: CALL_OW 12
49314: PUSH
49315: LD_INT 1
49317: PPUSH
49318: LD_INT 3
49320: PPUSH
49321: CALL_OW 12
49325: PUSH
49326: LD_INT 0
49328: PUSH
49329: LD_INT 0
49331: PUSH
49332: EMPTY
49333: LIST
49334: LIST
49335: LIST
49336: LIST
49337: ST_TO_ADDR
// animal := CreateHuman ;
49338: LD_ADDR_VAR 0 12
49342: PUSH
49343: CALL_OW 44
49347: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49348: LD_VAR 0 12
49352: PPUSH
49353: LD_VAR 0 8
49357: PPUSH
49358: LD_INT 0
49360: PPUSH
49361: CALL 51147 0 3
// end ;
49365: GO 49263
49367: POP
49368: POP
// if enchidnas then
49369: LD_VAR 0 4
49373: IFFALSE 49440
// for i = 1 to enchidnas do
49375: LD_ADDR_VAR 0 11
49379: PUSH
49380: DOUBLE
49381: LD_INT 1
49383: DEC
49384: ST_TO_ADDR
49385: LD_VAR 0 4
49389: PUSH
49390: FOR_TO
49391: IFFALSE 49438
// begin hc_class = 13 ;
49393: LD_ADDR_OWVAR 28
49397: PUSH
49398: LD_INT 13
49400: ST_TO_ADDR
// hc_gallery =  ;
49401: LD_ADDR_OWVAR 33
49405: PUSH
49406: LD_STRING 
49408: ST_TO_ADDR
// animal := CreateHuman ;
49409: LD_ADDR_VAR 0 12
49413: PUSH
49414: CALL_OW 44
49418: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49419: LD_VAR 0 12
49423: PPUSH
49424: LD_VAR 0 8
49428: PPUSH
49429: LD_INT 0
49431: PPUSH
49432: CALL 51147 0 3
// end ;
49436: GO 49390
49438: POP
49439: POP
// if fishes then
49440: LD_VAR 0 7
49444: IFFALSE 49511
// for i = 1 to fishes do
49446: LD_ADDR_VAR 0 11
49450: PUSH
49451: DOUBLE
49452: LD_INT 1
49454: DEC
49455: ST_TO_ADDR
49456: LD_VAR 0 7
49460: PUSH
49461: FOR_TO
49462: IFFALSE 49509
// begin hc_class = 20 ;
49464: LD_ADDR_OWVAR 28
49468: PUSH
49469: LD_INT 20
49471: ST_TO_ADDR
// hc_gallery =  ;
49472: LD_ADDR_OWVAR 33
49476: PUSH
49477: LD_STRING 
49479: ST_TO_ADDR
// animal := CreateHuman ;
49480: LD_ADDR_VAR 0 12
49484: PUSH
49485: CALL_OW 44
49489: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49490: LD_VAR 0 12
49494: PPUSH
49495: LD_VAR 0 9
49499: PPUSH
49500: LD_INT 0
49502: PPUSH
49503: CALL 51147 0 3
// end ;
49507: GO 49461
49509: POP
49510: POP
// end ;
49511: LD_VAR 0 10
49515: RET
// export function WantHeal ( sci , unit ) ; begin
49516: LD_INT 0
49518: PPUSH
// if GetTaskList ( sci ) > 0 then
49519: LD_VAR 0 1
49523: PPUSH
49524: CALL_OW 437
49528: PUSH
49529: LD_INT 0
49531: GREATER
49532: IFFALSE 49602
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49534: LD_VAR 0 1
49538: PPUSH
49539: CALL_OW 437
49543: PUSH
49544: LD_INT 1
49546: ARRAY
49547: PUSH
49548: LD_INT 1
49550: ARRAY
49551: PUSH
49552: LD_STRING l
49554: EQUAL
49555: PUSH
49556: LD_VAR 0 1
49560: PPUSH
49561: CALL_OW 437
49565: PUSH
49566: LD_INT 1
49568: ARRAY
49569: PUSH
49570: LD_INT 4
49572: ARRAY
49573: PUSH
49574: LD_VAR 0 2
49578: EQUAL
49579: AND
49580: IFFALSE 49592
// result := true else
49582: LD_ADDR_VAR 0 3
49586: PUSH
49587: LD_INT 1
49589: ST_TO_ADDR
49590: GO 49600
// result := false ;
49592: LD_ADDR_VAR 0 3
49596: PUSH
49597: LD_INT 0
49599: ST_TO_ADDR
// end else
49600: GO 49610
// result := false ;
49602: LD_ADDR_VAR 0 3
49606: PUSH
49607: LD_INT 0
49609: ST_TO_ADDR
// end ;
49610: LD_VAR 0 3
49614: RET
// export function HealTarget ( sci ) ; begin
49615: LD_INT 0
49617: PPUSH
// if not sci then
49618: LD_VAR 0 1
49622: NOT
49623: IFFALSE 49627
// exit ;
49625: GO 49692
// result := 0 ;
49627: LD_ADDR_VAR 0 2
49631: PUSH
49632: LD_INT 0
49634: ST_TO_ADDR
// if GetTaskList ( sci ) then
49635: LD_VAR 0 1
49639: PPUSH
49640: CALL_OW 437
49644: IFFALSE 49692
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49646: LD_VAR 0 1
49650: PPUSH
49651: CALL_OW 437
49655: PUSH
49656: LD_INT 1
49658: ARRAY
49659: PUSH
49660: LD_INT 1
49662: ARRAY
49663: PUSH
49664: LD_STRING l
49666: EQUAL
49667: IFFALSE 49692
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49669: LD_ADDR_VAR 0 2
49673: PUSH
49674: LD_VAR 0 1
49678: PPUSH
49679: CALL_OW 437
49683: PUSH
49684: LD_INT 1
49686: ARRAY
49687: PUSH
49688: LD_INT 4
49690: ARRAY
49691: ST_TO_ADDR
// end ;
49692: LD_VAR 0 2
49696: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
49697: LD_INT 0
49699: PPUSH
49700: PPUSH
49701: PPUSH
49702: PPUSH
// if not base_units then
49703: LD_VAR 0 1
49707: NOT
49708: IFFALSE 49712
// exit ;
49710: GO 49799
// result := false ;
49712: LD_ADDR_VAR 0 2
49716: PUSH
49717: LD_INT 0
49719: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
49720: LD_ADDR_VAR 0 5
49724: PUSH
49725: LD_VAR 0 1
49729: PPUSH
49730: LD_INT 21
49732: PUSH
49733: LD_INT 3
49735: PUSH
49736: EMPTY
49737: LIST
49738: LIST
49739: PPUSH
49740: CALL_OW 72
49744: ST_TO_ADDR
// if not tmp then
49745: LD_VAR 0 5
49749: NOT
49750: IFFALSE 49754
// exit ;
49752: GO 49799
// for i in tmp do
49754: LD_ADDR_VAR 0 3
49758: PUSH
49759: LD_VAR 0 5
49763: PUSH
49764: FOR_IN
49765: IFFALSE 49797
// begin result := EnemyInRange ( i , 22 ) ;
49767: LD_ADDR_VAR 0 2
49771: PUSH
49772: LD_VAR 0 3
49776: PPUSH
49777: LD_INT 22
49779: PPUSH
49780: CALL 47485 0 2
49784: ST_TO_ADDR
// if result then
49785: LD_VAR 0 2
49789: IFFALSE 49795
// exit ;
49791: POP
49792: POP
49793: GO 49799
// end ;
49795: GO 49764
49797: POP
49798: POP
// end ;
49799: LD_VAR 0 2
49803: RET
// export function FilterByTag ( units , tag ) ; begin
49804: LD_INT 0
49806: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
49807: LD_ADDR_VAR 0 3
49811: PUSH
49812: LD_VAR 0 1
49816: PPUSH
49817: LD_INT 120
49819: PUSH
49820: LD_VAR 0 2
49824: PUSH
49825: EMPTY
49826: LIST
49827: LIST
49828: PPUSH
49829: CALL_OW 72
49833: ST_TO_ADDR
// end ;
49834: LD_VAR 0 3
49838: RET
// export function IsDriver ( un ) ; begin
49839: LD_INT 0
49841: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
49842: LD_ADDR_VAR 0 2
49846: PUSH
49847: LD_VAR 0 1
49851: PUSH
49852: LD_INT 55
49854: PUSH
49855: EMPTY
49856: LIST
49857: PPUSH
49858: CALL_OW 69
49862: IN
49863: ST_TO_ADDR
// end ;
49864: LD_VAR 0 2
49868: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
49869: LD_INT 0
49871: PPUSH
49872: PPUSH
// list := [ ] ;
49873: LD_ADDR_VAR 0 5
49877: PUSH
49878: EMPTY
49879: ST_TO_ADDR
// case d of 0 :
49880: LD_VAR 0 3
49884: PUSH
49885: LD_INT 0
49887: DOUBLE
49888: EQUAL
49889: IFTRUE 49893
49891: GO 50026
49893: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
49894: LD_ADDR_VAR 0 5
49898: PUSH
49899: LD_VAR 0 1
49903: PUSH
49904: LD_INT 4
49906: MINUS
49907: PUSH
49908: LD_VAR 0 2
49912: PUSH
49913: LD_INT 4
49915: MINUS
49916: PUSH
49917: LD_INT 2
49919: PUSH
49920: EMPTY
49921: LIST
49922: LIST
49923: LIST
49924: PUSH
49925: LD_VAR 0 1
49929: PUSH
49930: LD_INT 3
49932: MINUS
49933: PUSH
49934: LD_VAR 0 2
49938: PUSH
49939: LD_INT 1
49941: PUSH
49942: EMPTY
49943: LIST
49944: LIST
49945: LIST
49946: PUSH
49947: LD_VAR 0 1
49951: PUSH
49952: LD_INT 4
49954: PLUS
49955: PUSH
49956: LD_VAR 0 2
49960: PUSH
49961: LD_INT 4
49963: PUSH
49964: EMPTY
49965: LIST
49966: LIST
49967: LIST
49968: PUSH
49969: LD_VAR 0 1
49973: PUSH
49974: LD_INT 3
49976: PLUS
49977: PUSH
49978: LD_VAR 0 2
49982: PUSH
49983: LD_INT 3
49985: PLUS
49986: PUSH
49987: LD_INT 5
49989: PUSH
49990: EMPTY
49991: LIST
49992: LIST
49993: LIST
49994: PUSH
49995: LD_VAR 0 1
49999: PUSH
50000: LD_VAR 0 2
50004: PUSH
50005: LD_INT 4
50007: PLUS
50008: PUSH
50009: LD_INT 0
50011: PUSH
50012: EMPTY
50013: LIST
50014: LIST
50015: LIST
50016: PUSH
50017: EMPTY
50018: LIST
50019: LIST
50020: LIST
50021: LIST
50022: LIST
50023: ST_TO_ADDR
// end ; 1 :
50024: GO 50724
50026: LD_INT 1
50028: DOUBLE
50029: EQUAL
50030: IFTRUE 50034
50032: GO 50167
50034: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
50035: LD_ADDR_VAR 0 5
50039: PUSH
50040: LD_VAR 0 1
50044: PUSH
50045: LD_VAR 0 2
50049: PUSH
50050: LD_INT 4
50052: MINUS
50053: PUSH
50054: LD_INT 3
50056: PUSH
50057: EMPTY
50058: LIST
50059: LIST
50060: LIST
50061: PUSH
50062: LD_VAR 0 1
50066: PUSH
50067: LD_INT 3
50069: MINUS
50070: PUSH
50071: LD_VAR 0 2
50075: PUSH
50076: LD_INT 3
50078: MINUS
50079: PUSH
50080: LD_INT 2
50082: PUSH
50083: EMPTY
50084: LIST
50085: LIST
50086: LIST
50087: PUSH
50088: LD_VAR 0 1
50092: PUSH
50093: LD_INT 4
50095: MINUS
50096: PUSH
50097: LD_VAR 0 2
50101: PUSH
50102: LD_INT 1
50104: PUSH
50105: EMPTY
50106: LIST
50107: LIST
50108: LIST
50109: PUSH
50110: LD_VAR 0 1
50114: PUSH
50115: LD_VAR 0 2
50119: PUSH
50120: LD_INT 3
50122: PLUS
50123: PUSH
50124: LD_INT 0
50126: PUSH
50127: EMPTY
50128: LIST
50129: LIST
50130: LIST
50131: PUSH
50132: LD_VAR 0 1
50136: PUSH
50137: LD_INT 4
50139: PLUS
50140: PUSH
50141: LD_VAR 0 2
50145: PUSH
50146: LD_INT 4
50148: PLUS
50149: PUSH
50150: LD_INT 5
50152: PUSH
50153: EMPTY
50154: LIST
50155: LIST
50156: LIST
50157: PUSH
50158: EMPTY
50159: LIST
50160: LIST
50161: LIST
50162: LIST
50163: LIST
50164: ST_TO_ADDR
// end ; 2 :
50165: GO 50724
50167: LD_INT 2
50169: DOUBLE
50170: EQUAL
50171: IFTRUE 50175
50173: GO 50304
50175: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
50176: LD_ADDR_VAR 0 5
50180: PUSH
50181: LD_VAR 0 1
50185: PUSH
50186: LD_VAR 0 2
50190: PUSH
50191: LD_INT 3
50193: MINUS
50194: PUSH
50195: LD_INT 3
50197: PUSH
50198: EMPTY
50199: LIST
50200: LIST
50201: LIST
50202: PUSH
50203: LD_VAR 0 1
50207: PUSH
50208: LD_INT 4
50210: PLUS
50211: PUSH
50212: LD_VAR 0 2
50216: PUSH
50217: LD_INT 4
50219: PUSH
50220: EMPTY
50221: LIST
50222: LIST
50223: LIST
50224: PUSH
50225: LD_VAR 0 1
50229: PUSH
50230: LD_VAR 0 2
50234: PUSH
50235: LD_INT 4
50237: PLUS
50238: PUSH
50239: LD_INT 0
50241: PUSH
50242: EMPTY
50243: LIST
50244: LIST
50245: LIST
50246: PUSH
50247: LD_VAR 0 1
50251: PUSH
50252: LD_INT 3
50254: MINUS
50255: PUSH
50256: LD_VAR 0 2
50260: PUSH
50261: LD_INT 1
50263: PUSH
50264: EMPTY
50265: LIST
50266: LIST
50267: LIST
50268: PUSH
50269: LD_VAR 0 1
50273: PUSH
50274: LD_INT 4
50276: MINUS
50277: PUSH
50278: LD_VAR 0 2
50282: PUSH
50283: LD_INT 4
50285: MINUS
50286: PUSH
50287: LD_INT 2
50289: PUSH
50290: EMPTY
50291: LIST
50292: LIST
50293: LIST
50294: PUSH
50295: EMPTY
50296: LIST
50297: LIST
50298: LIST
50299: LIST
50300: LIST
50301: ST_TO_ADDR
// end ; 3 :
50302: GO 50724
50304: LD_INT 3
50306: DOUBLE
50307: EQUAL
50308: IFTRUE 50312
50310: GO 50445
50312: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
50313: LD_ADDR_VAR 0 5
50317: PUSH
50318: LD_VAR 0 1
50322: PUSH
50323: LD_INT 3
50325: PLUS
50326: PUSH
50327: LD_VAR 0 2
50331: PUSH
50332: LD_INT 4
50334: PUSH
50335: EMPTY
50336: LIST
50337: LIST
50338: LIST
50339: PUSH
50340: LD_VAR 0 1
50344: PUSH
50345: LD_INT 4
50347: PLUS
50348: PUSH
50349: LD_VAR 0 2
50353: PUSH
50354: LD_INT 4
50356: PLUS
50357: PUSH
50358: LD_INT 5
50360: PUSH
50361: EMPTY
50362: LIST
50363: LIST
50364: LIST
50365: PUSH
50366: LD_VAR 0 1
50370: PUSH
50371: LD_INT 4
50373: MINUS
50374: PUSH
50375: LD_VAR 0 2
50379: PUSH
50380: LD_INT 1
50382: PUSH
50383: EMPTY
50384: LIST
50385: LIST
50386: LIST
50387: PUSH
50388: LD_VAR 0 1
50392: PUSH
50393: LD_VAR 0 2
50397: PUSH
50398: LD_INT 4
50400: MINUS
50401: PUSH
50402: LD_INT 3
50404: PUSH
50405: EMPTY
50406: LIST
50407: LIST
50408: LIST
50409: PUSH
50410: LD_VAR 0 1
50414: PUSH
50415: LD_INT 3
50417: MINUS
50418: PUSH
50419: LD_VAR 0 2
50423: PUSH
50424: LD_INT 3
50426: MINUS
50427: PUSH
50428: LD_INT 2
50430: PUSH
50431: EMPTY
50432: LIST
50433: LIST
50434: LIST
50435: PUSH
50436: EMPTY
50437: LIST
50438: LIST
50439: LIST
50440: LIST
50441: LIST
50442: ST_TO_ADDR
// end ; 4 :
50443: GO 50724
50445: LD_INT 4
50447: DOUBLE
50448: EQUAL
50449: IFTRUE 50453
50451: GO 50586
50453: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
50454: LD_ADDR_VAR 0 5
50458: PUSH
50459: LD_VAR 0 1
50463: PUSH
50464: LD_VAR 0 2
50468: PUSH
50469: LD_INT 4
50471: PLUS
50472: PUSH
50473: LD_INT 0
50475: PUSH
50476: EMPTY
50477: LIST
50478: LIST
50479: LIST
50480: PUSH
50481: LD_VAR 0 1
50485: PUSH
50486: LD_INT 3
50488: PLUS
50489: PUSH
50490: LD_VAR 0 2
50494: PUSH
50495: LD_INT 3
50497: PLUS
50498: PUSH
50499: LD_INT 5
50501: PUSH
50502: EMPTY
50503: LIST
50504: LIST
50505: LIST
50506: PUSH
50507: LD_VAR 0 1
50511: PUSH
50512: LD_INT 4
50514: PLUS
50515: PUSH
50516: LD_VAR 0 2
50520: PUSH
50521: LD_INT 4
50523: PUSH
50524: EMPTY
50525: LIST
50526: LIST
50527: LIST
50528: PUSH
50529: LD_VAR 0 1
50533: PUSH
50534: LD_VAR 0 2
50538: PUSH
50539: LD_INT 3
50541: MINUS
50542: PUSH
50543: LD_INT 3
50545: PUSH
50546: EMPTY
50547: LIST
50548: LIST
50549: LIST
50550: PUSH
50551: LD_VAR 0 1
50555: PUSH
50556: LD_INT 4
50558: MINUS
50559: PUSH
50560: LD_VAR 0 2
50564: PUSH
50565: LD_INT 4
50567: MINUS
50568: PUSH
50569: LD_INT 2
50571: PUSH
50572: EMPTY
50573: LIST
50574: LIST
50575: LIST
50576: PUSH
50577: EMPTY
50578: LIST
50579: LIST
50580: LIST
50581: LIST
50582: LIST
50583: ST_TO_ADDR
// end ; 5 :
50584: GO 50724
50586: LD_INT 5
50588: DOUBLE
50589: EQUAL
50590: IFTRUE 50594
50592: GO 50723
50594: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
50595: LD_ADDR_VAR 0 5
50599: PUSH
50600: LD_VAR 0 1
50604: PUSH
50605: LD_INT 4
50607: MINUS
50608: PUSH
50609: LD_VAR 0 2
50613: PUSH
50614: LD_INT 1
50616: PUSH
50617: EMPTY
50618: LIST
50619: LIST
50620: LIST
50621: PUSH
50622: LD_VAR 0 1
50626: PUSH
50627: LD_VAR 0 2
50631: PUSH
50632: LD_INT 4
50634: MINUS
50635: PUSH
50636: LD_INT 3
50638: PUSH
50639: EMPTY
50640: LIST
50641: LIST
50642: LIST
50643: PUSH
50644: LD_VAR 0 1
50648: PUSH
50649: LD_INT 4
50651: PLUS
50652: PUSH
50653: LD_VAR 0 2
50657: PUSH
50658: LD_INT 4
50660: PLUS
50661: PUSH
50662: LD_INT 5
50664: PUSH
50665: EMPTY
50666: LIST
50667: LIST
50668: LIST
50669: PUSH
50670: LD_VAR 0 1
50674: PUSH
50675: LD_INT 3
50677: PLUS
50678: PUSH
50679: LD_VAR 0 2
50683: PUSH
50684: LD_INT 4
50686: PUSH
50687: EMPTY
50688: LIST
50689: LIST
50690: LIST
50691: PUSH
50692: LD_VAR 0 1
50696: PUSH
50697: LD_VAR 0 2
50701: PUSH
50702: LD_INT 3
50704: PLUS
50705: PUSH
50706: LD_INT 0
50708: PUSH
50709: EMPTY
50710: LIST
50711: LIST
50712: LIST
50713: PUSH
50714: EMPTY
50715: LIST
50716: LIST
50717: LIST
50718: LIST
50719: LIST
50720: ST_TO_ADDR
// end ; end ;
50721: GO 50724
50723: POP
// result := list ;
50724: LD_ADDR_VAR 0 4
50728: PUSH
50729: LD_VAR 0 5
50733: ST_TO_ADDR
// end ;
50734: LD_VAR 0 4
50738: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
50739: LD_INT 0
50741: PPUSH
50742: PPUSH
50743: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
50744: LD_VAR 0 1
50748: NOT
50749: PUSH
50750: LD_VAR 0 2
50754: PUSH
50755: LD_INT 1
50757: PUSH
50758: LD_INT 2
50760: PUSH
50761: LD_INT 3
50763: PUSH
50764: LD_INT 4
50766: PUSH
50767: EMPTY
50768: LIST
50769: LIST
50770: LIST
50771: LIST
50772: IN
50773: NOT
50774: OR
50775: IFFALSE 50779
// exit ;
50777: GO 50871
// tmp := [ ] ;
50779: LD_ADDR_VAR 0 5
50783: PUSH
50784: EMPTY
50785: ST_TO_ADDR
// for i in units do
50786: LD_ADDR_VAR 0 4
50790: PUSH
50791: LD_VAR 0 1
50795: PUSH
50796: FOR_IN
50797: IFFALSE 50840
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
50799: LD_ADDR_VAR 0 5
50803: PUSH
50804: LD_VAR 0 5
50808: PPUSH
50809: LD_VAR 0 5
50813: PUSH
50814: LD_INT 1
50816: PLUS
50817: PPUSH
50818: LD_VAR 0 4
50822: PPUSH
50823: LD_VAR 0 2
50827: PPUSH
50828: CALL_OW 259
50832: PPUSH
50833: CALL_OW 2
50837: ST_TO_ADDR
50838: GO 50796
50840: POP
50841: POP
// if not tmp then
50842: LD_VAR 0 5
50846: NOT
50847: IFFALSE 50851
// exit ;
50849: GO 50871
// result := SortListByListDesc ( units , tmp ) ;
50851: LD_ADDR_VAR 0 3
50855: PUSH
50856: LD_VAR 0 1
50860: PPUSH
50861: LD_VAR 0 5
50865: PPUSH
50866: CALL_OW 77
50870: ST_TO_ADDR
// end ;
50871: LD_VAR 0 3
50875: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
50876: LD_INT 0
50878: PPUSH
50879: PPUSH
50880: PPUSH
// result := false ;
50881: LD_ADDR_VAR 0 3
50885: PUSH
50886: LD_INT 0
50888: ST_TO_ADDR
// x := GetX ( building ) ;
50889: LD_ADDR_VAR 0 4
50893: PUSH
50894: LD_VAR 0 2
50898: PPUSH
50899: CALL_OW 250
50903: ST_TO_ADDR
// y := GetY ( building ) ;
50904: LD_ADDR_VAR 0 5
50908: PUSH
50909: LD_VAR 0 2
50913: PPUSH
50914: CALL_OW 251
50918: ST_TO_ADDR
// if not building or not x or not y then
50919: LD_VAR 0 2
50923: NOT
50924: PUSH
50925: LD_VAR 0 4
50929: NOT
50930: OR
50931: PUSH
50932: LD_VAR 0 5
50936: NOT
50937: OR
50938: IFFALSE 50942
// exit ;
50940: GO 51034
// if GetTaskList ( unit ) then
50942: LD_VAR 0 1
50946: PPUSH
50947: CALL_OW 437
50951: IFFALSE 51034
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50953: LD_STRING e
50955: PUSH
50956: LD_VAR 0 1
50960: PPUSH
50961: CALL_OW 437
50965: PUSH
50966: LD_INT 1
50968: ARRAY
50969: PUSH
50970: LD_INT 1
50972: ARRAY
50973: EQUAL
50974: PUSH
50975: LD_VAR 0 4
50979: PUSH
50980: LD_VAR 0 1
50984: PPUSH
50985: CALL_OW 437
50989: PUSH
50990: LD_INT 1
50992: ARRAY
50993: PUSH
50994: LD_INT 2
50996: ARRAY
50997: EQUAL
50998: AND
50999: PUSH
51000: LD_VAR 0 5
51004: PUSH
51005: LD_VAR 0 1
51009: PPUSH
51010: CALL_OW 437
51014: PUSH
51015: LD_INT 1
51017: ARRAY
51018: PUSH
51019: LD_INT 3
51021: ARRAY
51022: EQUAL
51023: AND
51024: IFFALSE 51034
// result := true end ;
51026: LD_ADDR_VAR 0 3
51030: PUSH
51031: LD_INT 1
51033: ST_TO_ADDR
// end ;
51034: LD_VAR 0 3
51038: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
51039: LD_INT 0
51041: PPUSH
// result := false ;
51042: LD_ADDR_VAR 0 4
51046: PUSH
51047: LD_INT 0
51049: ST_TO_ADDR
// if GetTaskList ( unit ) then
51050: LD_VAR 0 1
51054: PPUSH
51055: CALL_OW 437
51059: IFFALSE 51142
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
51061: LD_STRING M
51063: PUSH
51064: LD_VAR 0 1
51068: PPUSH
51069: CALL_OW 437
51073: PUSH
51074: LD_INT 1
51076: ARRAY
51077: PUSH
51078: LD_INT 1
51080: ARRAY
51081: EQUAL
51082: PUSH
51083: LD_VAR 0 2
51087: PUSH
51088: LD_VAR 0 1
51092: PPUSH
51093: CALL_OW 437
51097: PUSH
51098: LD_INT 1
51100: ARRAY
51101: PUSH
51102: LD_INT 2
51104: ARRAY
51105: EQUAL
51106: AND
51107: PUSH
51108: LD_VAR 0 3
51112: PUSH
51113: LD_VAR 0 1
51117: PPUSH
51118: CALL_OW 437
51122: PUSH
51123: LD_INT 1
51125: ARRAY
51126: PUSH
51127: LD_INT 3
51129: ARRAY
51130: EQUAL
51131: AND
51132: IFFALSE 51142
// result := true ;
51134: LD_ADDR_VAR 0 4
51138: PUSH
51139: LD_INT 1
51141: ST_TO_ADDR
// end ; end ;
51142: LD_VAR 0 4
51146: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
51147: LD_INT 0
51149: PPUSH
51150: PPUSH
51151: PPUSH
51152: PPUSH
// if not unit or not area then
51153: LD_VAR 0 1
51157: NOT
51158: PUSH
51159: LD_VAR 0 2
51163: NOT
51164: OR
51165: IFFALSE 51169
// exit ;
51167: GO 51333
// tmp := AreaToList ( area , i ) ;
51169: LD_ADDR_VAR 0 6
51173: PUSH
51174: LD_VAR 0 2
51178: PPUSH
51179: LD_VAR 0 5
51183: PPUSH
51184: CALL_OW 517
51188: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
51189: LD_ADDR_VAR 0 5
51193: PUSH
51194: DOUBLE
51195: LD_INT 1
51197: DEC
51198: ST_TO_ADDR
51199: LD_VAR 0 6
51203: PUSH
51204: LD_INT 1
51206: ARRAY
51207: PUSH
51208: FOR_TO
51209: IFFALSE 51331
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
51211: LD_ADDR_VAR 0 7
51215: PUSH
51216: LD_VAR 0 6
51220: PUSH
51221: LD_INT 1
51223: ARRAY
51224: PUSH
51225: LD_VAR 0 5
51229: ARRAY
51230: PUSH
51231: LD_VAR 0 6
51235: PUSH
51236: LD_INT 2
51238: ARRAY
51239: PUSH
51240: LD_VAR 0 5
51244: ARRAY
51245: PUSH
51246: EMPTY
51247: LIST
51248: LIST
51249: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
51250: LD_VAR 0 7
51254: PUSH
51255: LD_INT 1
51257: ARRAY
51258: PPUSH
51259: LD_VAR 0 7
51263: PUSH
51264: LD_INT 2
51266: ARRAY
51267: PPUSH
51268: CALL_OW 428
51272: PUSH
51273: LD_INT 0
51275: EQUAL
51276: IFFALSE 51329
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
51278: LD_VAR 0 1
51282: PPUSH
51283: LD_VAR 0 7
51287: PUSH
51288: LD_INT 1
51290: ARRAY
51291: PPUSH
51292: LD_VAR 0 7
51296: PUSH
51297: LD_INT 2
51299: ARRAY
51300: PPUSH
51301: LD_VAR 0 3
51305: PPUSH
51306: CALL_OW 48
// result := IsPlaced ( unit ) ;
51310: LD_ADDR_VAR 0 4
51314: PUSH
51315: LD_VAR 0 1
51319: PPUSH
51320: CALL_OW 305
51324: ST_TO_ADDR
// exit ;
51325: POP
51326: POP
51327: GO 51333
// end ; end ;
51329: GO 51208
51331: POP
51332: POP
// end ;
51333: LD_VAR 0 4
51337: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
51338: LD_INT 0
51340: PPUSH
51341: PPUSH
51342: PPUSH
// if not side or side > 8 then
51343: LD_VAR 0 1
51347: NOT
51348: PUSH
51349: LD_VAR 0 1
51353: PUSH
51354: LD_INT 8
51356: GREATER
51357: OR
51358: IFFALSE 51362
// exit ;
51360: GO 51549
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
51362: LD_ADDR_VAR 0 4
51366: PUSH
51367: LD_INT 22
51369: PUSH
51370: LD_VAR 0 1
51374: PUSH
51375: EMPTY
51376: LIST
51377: LIST
51378: PUSH
51379: LD_INT 21
51381: PUSH
51382: LD_INT 3
51384: PUSH
51385: EMPTY
51386: LIST
51387: LIST
51388: PUSH
51389: EMPTY
51390: LIST
51391: LIST
51392: PPUSH
51393: CALL_OW 69
51397: ST_TO_ADDR
// if not tmp then
51398: LD_VAR 0 4
51402: NOT
51403: IFFALSE 51407
// exit ;
51405: GO 51549
// enable_addtolog := true ;
51407: LD_ADDR_OWVAR 81
51411: PUSH
51412: LD_INT 1
51414: ST_TO_ADDR
// AddToLog ( [ ) ;
51415: LD_STRING [
51417: PPUSH
51418: CALL_OW 561
// for i in tmp do
51422: LD_ADDR_VAR 0 3
51426: PUSH
51427: LD_VAR 0 4
51431: PUSH
51432: FOR_IN
51433: IFFALSE 51540
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
51435: LD_STRING [
51437: PUSH
51438: LD_VAR 0 3
51442: PPUSH
51443: CALL_OW 266
51447: STR
51448: PUSH
51449: LD_STRING , 
51451: STR
51452: PUSH
51453: LD_VAR 0 3
51457: PPUSH
51458: CALL_OW 250
51462: STR
51463: PUSH
51464: LD_STRING , 
51466: STR
51467: PUSH
51468: LD_VAR 0 3
51472: PPUSH
51473: CALL_OW 251
51477: STR
51478: PUSH
51479: LD_STRING , 
51481: STR
51482: PUSH
51483: LD_VAR 0 3
51487: PPUSH
51488: CALL_OW 254
51492: STR
51493: PUSH
51494: LD_STRING , 
51496: STR
51497: PUSH
51498: LD_VAR 0 3
51502: PPUSH
51503: LD_INT 1
51505: PPUSH
51506: CALL_OW 268
51510: STR
51511: PUSH
51512: LD_STRING , 
51514: STR
51515: PUSH
51516: LD_VAR 0 3
51520: PPUSH
51521: LD_INT 2
51523: PPUSH
51524: CALL_OW 268
51528: STR
51529: PUSH
51530: LD_STRING ],
51532: STR
51533: PPUSH
51534: CALL_OW 561
// end ;
51538: GO 51432
51540: POP
51541: POP
// AddToLog ( ]; ) ;
51542: LD_STRING ];
51544: PPUSH
51545: CALL_OW 561
// end ;
51549: LD_VAR 0 2
51553: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
51554: LD_INT 0
51556: PPUSH
51557: PPUSH
51558: PPUSH
51559: PPUSH
51560: PPUSH
// if not area or not rate or not max then
51561: LD_VAR 0 1
51565: NOT
51566: PUSH
51567: LD_VAR 0 2
51571: NOT
51572: OR
51573: PUSH
51574: LD_VAR 0 4
51578: NOT
51579: OR
51580: IFFALSE 51584
// exit ;
51582: GO 51773
// while 1 do
51584: LD_INT 1
51586: IFFALSE 51773
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
51588: LD_ADDR_VAR 0 9
51592: PUSH
51593: LD_VAR 0 1
51597: PPUSH
51598: LD_INT 1
51600: PPUSH
51601: CALL_OW 287
51605: PUSH
51606: LD_INT 10
51608: MUL
51609: ST_TO_ADDR
// r := rate / 10 ;
51610: LD_ADDR_VAR 0 7
51614: PUSH
51615: LD_VAR 0 2
51619: PUSH
51620: LD_INT 10
51622: DIVREAL
51623: ST_TO_ADDR
// time := 1 1$00 ;
51624: LD_ADDR_VAR 0 8
51628: PUSH
51629: LD_INT 2100
51631: ST_TO_ADDR
// if amount < min then
51632: LD_VAR 0 9
51636: PUSH
51637: LD_VAR 0 3
51641: LESS
51642: IFFALSE 51660
// r := r * 2 else
51644: LD_ADDR_VAR 0 7
51648: PUSH
51649: LD_VAR 0 7
51653: PUSH
51654: LD_INT 2
51656: MUL
51657: ST_TO_ADDR
51658: GO 51686
// if amount > max then
51660: LD_VAR 0 9
51664: PUSH
51665: LD_VAR 0 4
51669: GREATER
51670: IFFALSE 51686
// r := r / 2 ;
51672: LD_ADDR_VAR 0 7
51676: PUSH
51677: LD_VAR 0 7
51681: PUSH
51682: LD_INT 2
51684: DIVREAL
51685: ST_TO_ADDR
// time := time / r ;
51686: LD_ADDR_VAR 0 8
51690: PUSH
51691: LD_VAR 0 8
51695: PUSH
51696: LD_VAR 0 7
51700: DIVREAL
51701: ST_TO_ADDR
// if time < 0 then
51702: LD_VAR 0 8
51706: PUSH
51707: LD_INT 0
51709: LESS
51710: IFFALSE 51727
// time := time * - 1 ;
51712: LD_ADDR_VAR 0 8
51716: PUSH
51717: LD_VAR 0 8
51721: PUSH
51722: LD_INT 1
51724: NEG
51725: MUL
51726: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
51727: LD_VAR 0 8
51731: PUSH
51732: LD_INT 35
51734: PPUSH
51735: LD_INT 875
51737: PPUSH
51738: CALL_OW 12
51742: PLUS
51743: PPUSH
51744: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
51748: LD_INT 1
51750: PPUSH
51751: LD_INT 5
51753: PPUSH
51754: CALL_OW 12
51758: PPUSH
51759: LD_VAR 0 1
51763: PPUSH
51764: LD_INT 1
51766: PPUSH
51767: CALL_OW 55
// end ;
51771: GO 51584
// end ;
51773: LD_VAR 0 5
51777: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
51778: LD_INT 0
51780: PPUSH
51781: PPUSH
51782: PPUSH
51783: PPUSH
51784: PPUSH
51785: PPUSH
51786: PPUSH
51787: PPUSH
// if not turrets or not factories then
51788: LD_VAR 0 1
51792: NOT
51793: PUSH
51794: LD_VAR 0 2
51798: NOT
51799: OR
51800: IFFALSE 51804
// exit ;
51802: GO 52111
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
51804: LD_ADDR_VAR 0 10
51808: PUSH
51809: LD_INT 5
51811: PUSH
51812: LD_INT 6
51814: PUSH
51815: EMPTY
51816: LIST
51817: LIST
51818: PUSH
51819: LD_INT 2
51821: PUSH
51822: LD_INT 4
51824: PUSH
51825: EMPTY
51826: LIST
51827: LIST
51828: PUSH
51829: LD_INT 3
51831: PUSH
51832: LD_INT 5
51834: PUSH
51835: EMPTY
51836: LIST
51837: LIST
51838: PUSH
51839: EMPTY
51840: LIST
51841: LIST
51842: LIST
51843: PUSH
51844: LD_INT 24
51846: PUSH
51847: LD_INT 25
51849: PUSH
51850: EMPTY
51851: LIST
51852: LIST
51853: PUSH
51854: LD_INT 23
51856: PUSH
51857: LD_INT 27
51859: PUSH
51860: EMPTY
51861: LIST
51862: LIST
51863: PUSH
51864: EMPTY
51865: LIST
51866: LIST
51867: PUSH
51868: LD_INT 42
51870: PUSH
51871: LD_INT 43
51873: PUSH
51874: EMPTY
51875: LIST
51876: LIST
51877: PUSH
51878: LD_INT 44
51880: PUSH
51881: LD_INT 46
51883: PUSH
51884: EMPTY
51885: LIST
51886: LIST
51887: PUSH
51888: LD_INT 45
51890: PUSH
51891: LD_INT 47
51893: PUSH
51894: EMPTY
51895: LIST
51896: LIST
51897: PUSH
51898: EMPTY
51899: LIST
51900: LIST
51901: LIST
51902: PUSH
51903: EMPTY
51904: LIST
51905: LIST
51906: LIST
51907: ST_TO_ADDR
// result := [ ] ;
51908: LD_ADDR_VAR 0 3
51912: PUSH
51913: EMPTY
51914: ST_TO_ADDR
// for i in turrets do
51915: LD_ADDR_VAR 0 4
51919: PUSH
51920: LD_VAR 0 1
51924: PUSH
51925: FOR_IN
51926: IFFALSE 52109
// begin nat := GetNation ( i ) ;
51928: LD_ADDR_VAR 0 7
51932: PUSH
51933: LD_VAR 0 4
51937: PPUSH
51938: CALL_OW 248
51942: ST_TO_ADDR
// weapon := 0 ;
51943: LD_ADDR_VAR 0 8
51947: PUSH
51948: LD_INT 0
51950: ST_TO_ADDR
// if not nat then
51951: LD_VAR 0 7
51955: NOT
51956: IFFALSE 51960
// continue ;
51958: GO 51925
// for j in list [ nat ] do
51960: LD_ADDR_VAR 0 5
51964: PUSH
51965: LD_VAR 0 10
51969: PUSH
51970: LD_VAR 0 7
51974: ARRAY
51975: PUSH
51976: FOR_IN
51977: IFFALSE 52018
// if GetBWeapon ( i ) = j [ 1 ] then
51979: LD_VAR 0 4
51983: PPUSH
51984: CALL_OW 269
51988: PUSH
51989: LD_VAR 0 5
51993: PUSH
51994: LD_INT 1
51996: ARRAY
51997: EQUAL
51998: IFFALSE 52016
// begin weapon := j [ 2 ] ;
52000: LD_ADDR_VAR 0 8
52004: PUSH
52005: LD_VAR 0 5
52009: PUSH
52010: LD_INT 2
52012: ARRAY
52013: ST_TO_ADDR
// break ;
52014: GO 52018
// end ;
52016: GO 51976
52018: POP
52019: POP
// if not weapon then
52020: LD_VAR 0 8
52024: NOT
52025: IFFALSE 52029
// continue ;
52027: GO 51925
// for k in factories do
52029: LD_ADDR_VAR 0 6
52033: PUSH
52034: LD_VAR 0 2
52038: PUSH
52039: FOR_IN
52040: IFFALSE 52105
// begin weapons := AvailableWeaponList ( k ) ;
52042: LD_ADDR_VAR 0 9
52046: PUSH
52047: LD_VAR 0 6
52051: PPUSH
52052: CALL_OW 478
52056: ST_TO_ADDR
// if not weapons then
52057: LD_VAR 0 9
52061: NOT
52062: IFFALSE 52066
// continue ;
52064: GO 52039
// if weapon in weapons then
52066: LD_VAR 0 8
52070: PUSH
52071: LD_VAR 0 9
52075: IN
52076: IFFALSE 52103
// begin result := [ i , weapon ] ;
52078: LD_ADDR_VAR 0 3
52082: PUSH
52083: LD_VAR 0 4
52087: PUSH
52088: LD_VAR 0 8
52092: PUSH
52093: EMPTY
52094: LIST
52095: LIST
52096: ST_TO_ADDR
// exit ;
52097: POP
52098: POP
52099: POP
52100: POP
52101: GO 52111
// end ; end ;
52103: GO 52039
52105: POP
52106: POP
// end ;
52107: GO 51925
52109: POP
52110: POP
// end ;
52111: LD_VAR 0 3
52115: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
52116: LD_INT 0
52118: PPUSH
// if not side or side > 8 then
52119: LD_VAR 0 3
52123: NOT
52124: PUSH
52125: LD_VAR 0 3
52129: PUSH
52130: LD_INT 8
52132: GREATER
52133: OR
52134: IFFALSE 52138
// exit ;
52136: GO 52197
// if not range then
52138: LD_VAR 0 4
52142: NOT
52143: IFFALSE 52154
// range := - 12 ;
52145: LD_ADDR_VAR 0 4
52149: PUSH
52150: LD_INT 12
52152: NEG
52153: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
52154: LD_VAR 0 1
52158: PPUSH
52159: LD_VAR 0 2
52163: PPUSH
52164: LD_VAR 0 3
52168: PPUSH
52169: LD_VAR 0 4
52173: PPUSH
52174: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
52178: LD_VAR 0 1
52182: PPUSH
52183: LD_VAR 0 2
52187: PPUSH
52188: LD_VAR 0 3
52192: PPUSH
52193: CALL_OW 331
// end ;
52197: LD_VAR 0 5
52201: RET
// export function Video ( mode ) ; begin
52202: LD_INT 0
52204: PPUSH
// ingame_video = mode ;
52205: LD_ADDR_OWVAR 52
52209: PUSH
52210: LD_VAR 0 1
52214: ST_TO_ADDR
// interface_hidden = mode ;
52215: LD_ADDR_OWVAR 54
52219: PUSH
52220: LD_VAR 0 1
52224: ST_TO_ADDR
// end ;
52225: LD_VAR 0 2
52229: RET
// export function Join ( array , element ) ; begin
52230: LD_INT 0
52232: PPUSH
// result := Replace ( array , array + 1 , element ) ;
52233: LD_ADDR_VAR 0 3
52237: PUSH
52238: LD_VAR 0 1
52242: PPUSH
52243: LD_VAR 0 1
52247: PUSH
52248: LD_INT 1
52250: PLUS
52251: PPUSH
52252: LD_VAR 0 2
52256: PPUSH
52257: CALL_OW 1
52261: ST_TO_ADDR
// end ;
52262: LD_VAR 0 3
52266: RET
// export function JoinUnion ( array , element ) ; begin
52267: LD_INT 0
52269: PPUSH
// result := array union element ;
52270: LD_ADDR_VAR 0 3
52274: PUSH
52275: LD_VAR 0 1
52279: PUSH
52280: LD_VAR 0 2
52284: UNION
52285: ST_TO_ADDR
// end ;
52286: LD_VAR 0 3
52290: RET
// export function GetBehemoths ( side ) ; begin
52291: LD_INT 0
52293: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
52294: LD_ADDR_VAR 0 2
52298: PUSH
52299: LD_INT 22
52301: PUSH
52302: LD_VAR 0 1
52306: PUSH
52307: EMPTY
52308: LIST
52309: LIST
52310: PUSH
52311: LD_INT 31
52313: PUSH
52314: LD_INT 25
52316: PUSH
52317: EMPTY
52318: LIST
52319: LIST
52320: PUSH
52321: EMPTY
52322: LIST
52323: LIST
52324: PPUSH
52325: CALL_OW 69
52329: ST_TO_ADDR
// end ;
52330: LD_VAR 0 2
52334: RET
// export function Shuffle ( array ) ; var i , index ; begin
52335: LD_INT 0
52337: PPUSH
52338: PPUSH
52339: PPUSH
// result := [ ] ;
52340: LD_ADDR_VAR 0 2
52344: PUSH
52345: EMPTY
52346: ST_TO_ADDR
// if not array then
52347: LD_VAR 0 1
52351: NOT
52352: IFFALSE 52356
// exit ;
52354: GO 52455
// Randomize ;
52356: CALL_OW 10
// for i = array downto 1 do
52360: LD_ADDR_VAR 0 3
52364: PUSH
52365: DOUBLE
52366: LD_VAR 0 1
52370: INC
52371: ST_TO_ADDR
52372: LD_INT 1
52374: PUSH
52375: FOR_DOWNTO
52376: IFFALSE 52453
// begin index := rand ( 1 , array ) ;
52378: LD_ADDR_VAR 0 4
52382: PUSH
52383: LD_INT 1
52385: PPUSH
52386: LD_VAR 0 1
52390: PPUSH
52391: CALL_OW 12
52395: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
52396: LD_ADDR_VAR 0 2
52400: PUSH
52401: LD_VAR 0 2
52405: PPUSH
52406: LD_VAR 0 2
52410: PUSH
52411: LD_INT 1
52413: PLUS
52414: PPUSH
52415: LD_VAR 0 1
52419: PUSH
52420: LD_VAR 0 4
52424: ARRAY
52425: PPUSH
52426: CALL_OW 2
52430: ST_TO_ADDR
// array := Delete ( array , index ) ;
52431: LD_ADDR_VAR 0 1
52435: PUSH
52436: LD_VAR 0 1
52440: PPUSH
52441: LD_VAR 0 4
52445: PPUSH
52446: CALL_OW 3
52450: ST_TO_ADDR
// end ;
52451: GO 52375
52453: POP
52454: POP
// end ;
52455: LD_VAR 0 2
52459: RET
// export function GetBaseMaterials ( base ) ; begin
52460: LD_INT 0
52462: PPUSH
// result := [ 0 , 0 , 0 ] ;
52463: LD_ADDR_VAR 0 2
52467: PUSH
52468: LD_INT 0
52470: PUSH
52471: LD_INT 0
52473: PUSH
52474: LD_INT 0
52476: PUSH
52477: EMPTY
52478: LIST
52479: LIST
52480: LIST
52481: ST_TO_ADDR
// if not base then
52482: LD_VAR 0 1
52486: NOT
52487: IFFALSE 52491
// exit ;
52489: GO 52540
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
52491: LD_ADDR_VAR 0 2
52495: PUSH
52496: LD_VAR 0 1
52500: PPUSH
52501: LD_INT 1
52503: PPUSH
52504: CALL_OW 275
52508: PUSH
52509: LD_VAR 0 1
52513: PPUSH
52514: LD_INT 2
52516: PPUSH
52517: CALL_OW 275
52521: PUSH
52522: LD_VAR 0 1
52526: PPUSH
52527: LD_INT 3
52529: PPUSH
52530: CALL_OW 275
52534: PUSH
52535: EMPTY
52536: LIST
52537: LIST
52538: LIST
52539: ST_TO_ADDR
// end ;
52540: LD_VAR 0 2
52544: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
52545: LD_INT 0
52547: PPUSH
52548: PPUSH
// result := array ;
52549: LD_ADDR_VAR 0 3
52553: PUSH
52554: LD_VAR 0 1
52558: ST_TO_ADDR
// if size >= result then
52559: LD_VAR 0 2
52563: PUSH
52564: LD_VAR 0 3
52568: GREATEREQUAL
52569: IFFALSE 52573
// exit ;
52571: GO 52623
// if size then
52573: LD_VAR 0 2
52577: IFFALSE 52623
// for i := array downto size do
52579: LD_ADDR_VAR 0 4
52583: PUSH
52584: DOUBLE
52585: LD_VAR 0 1
52589: INC
52590: ST_TO_ADDR
52591: LD_VAR 0 2
52595: PUSH
52596: FOR_DOWNTO
52597: IFFALSE 52621
// result := Delete ( result , result ) ;
52599: LD_ADDR_VAR 0 3
52603: PUSH
52604: LD_VAR 0 3
52608: PPUSH
52609: LD_VAR 0 3
52613: PPUSH
52614: CALL_OW 3
52618: ST_TO_ADDR
52619: GO 52596
52621: POP
52622: POP
// end ;
52623: LD_VAR 0 3
52627: RET
// export function ComExit ( unit ) ; var tmp ; begin
52628: LD_INT 0
52630: PPUSH
52631: PPUSH
// if not IsInUnit ( unit ) then
52632: LD_VAR 0 1
52636: PPUSH
52637: CALL_OW 310
52641: NOT
52642: IFFALSE 52646
// exit ;
52644: GO 52706
// tmp := IsInUnit ( unit ) ;
52646: LD_ADDR_VAR 0 3
52650: PUSH
52651: LD_VAR 0 1
52655: PPUSH
52656: CALL_OW 310
52660: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
52661: LD_VAR 0 3
52665: PPUSH
52666: CALL_OW 247
52670: PUSH
52671: LD_INT 2
52673: EQUAL
52674: IFFALSE 52687
// ComExitVehicle ( unit ) else
52676: LD_VAR 0 1
52680: PPUSH
52681: CALL_OW 121
52685: GO 52696
// ComExitBuilding ( unit ) ;
52687: LD_VAR 0 1
52691: PPUSH
52692: CALL_OW 122
// result := tmp ;
52696: LD_ADDR_VAR 0 2
52700: PUSH
52701: LD_VAR 0 3
52705: ST_TO_ADDR
// end ;
52706: LD_VAR 0 2
52710: RET
// export function ComExitAll ( units ) ; var i ; begin
52711: LD_INT 0
52713: PPUSH
52714: PPUSH
// if not units then
52715: LD_VAR 0 1
52719: NOT
52720: IFFALSE 52724
// exit ;
52722: GO 52750
// for i in units do
52724: LD_ADDR_VAR 0 3
52728: PUSH
52729: LD_VAR 0 1
52733: PUSH
52734: FOR_IN
52735: IFFALSE 52748
// ComExit ( i ) ;
52737: LD_VAR 0 3
52741: PPUSH
52742: CALL 52628 0 1
52746: GO 52734
52748: POP
52749: POP
// end ;
52750: LD_VAR 0 2
52754: RET
// export function ResetHc ; begin
52755: LD_INT 0
52757: PPUSH
// InitHc ;
52758: CALL_OW 19
// hc_importance := 0 ;
52762: LD_ADDR_OWVAR 32
52766: PUSH
52767: LD_INT 0
52769: ST_TO_ADDR
// end ;
52770: LD_VAR 0 1
52774: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
52775: LD_INT 0
52777: PPUSH
52778: PPUSH
52779: PPUSH
// _x := ( x1 + x2 ) div 2 ;
52780: LD_ADDR_VAR 0 6
52784: PUSH
52785: LD_VAR 0 1
52789: PUSH
52790: LD_VAR 0 3
52794: PLUS
52795: PUSH
52796: LD_INT 2
52798: DIV
52799: ST_TO_ADDR
// if _x < 0 then
52800: LD_VAR 0 6
52804: PUSH
52805: LD_INT 0
52807: LESS
52808: IFFALSE 52825
// _x := _x * - 1 ;
52810: LD_ADDR_VAR 0 6
52814: PUSH
52815: LD_VAR 0 6
52819: PUSH
52820: LD_INT 1
52822: NEG
52823: MUL
52824: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
52825: LD_ADDR_VAR 0 7
52829: PUSH
52830: LD_VAR 0 2
52834: PUSH
52835: LD_VAR 0 4
52839: PLUS
52840: PUSH
52841: LD_INT 2
52843: DIV
52844: ST_TO_ADDR
// if _y < 0 then
52845: LD_VAR 0 7
52849: PUSH
52850: LD_INT 0
52852: LESS
52853: IFFALSE 52870
// _y := _y * - 1 ;
52855: LD_ADDR_VAR 0 7
52859: PUSH
52860: LD_VAR 0 7
52864: PUSH
52865: LD_INT 1
52867: NEG
52868: MUL
52869: ST_TO_ADDR
// result := [ _x , _y ] ;
52870: LD_ADDR_VAR 0 5
52874: PUSH
52875: LD_VAR 0 6
52879: PUSH
52880: LD_VAR 0 7
52884: PUSH
52885: EMPTY
52886: LIST
52887: LIST
52888: ST_TO_ADDR
// end ;
52889: LD_VAR 0 5
52893: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
52894: LD_INT 0
52896: PPUSH
52897: PPUSH
52898: PPUSH
52899: PPUSH
// task := GetTaskList ( unit ) ;
52900: LD_ADDR_VAR 0 7
52904: PUSH
52905: LD_VAR 0 1
52909: PPUSH
52910: CALL_OW 437
52914: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
52915: LD_VAR 0 7
52919: NOT
52920: PUSH
52921: LD_VAR 0 1
52925: PPUSH
52926: LD_VAR 0 2
52930: PPUSH
52931: CALL_OW 308
52935: NOT
52936: AND
52937: IFFALSE 52941
// exit ;
52939: GO 53059
// if IsInArea ( unit , area ) then
52941: LD_VAR 0 1
52945: PPUSH
52946: LD_VAR 0 2
52950: PPUSH
52951: CALL_OW 308
52955: IFFALSE 52973
// begin ComMoveToArea ( unit , goAway ) ;
52957: LD_VAR 0 1
52961: PPUSH
52962: LD_VAR 0 3
52966: PPUSH
52967: CALL_OW 113
// exit ;
52971: GO 53059
// end ; if task [ 1 ] [ 1 ] <> M then
52973: LD_VAR 0 7
52977: PUSH
52978: LD_INT 1
52980: ARRAY
52981: PUSH
52982: LD_INT 1
52984: ARRAY
52985: PUSH
52986: LD_STRING M
52988: NONEQUAL
52989: IFFALSE 52993
// exit ;
52991: GO 53059
// x := task [ 1 ] [ 2 ] ;
52993: LD_ADDR_VAR 0 5
52997: PUSH
52998: LD_VAR 0 7
53002: PUSH
53003: LD_INT 1
53005: ARRAY
53006: PUSH
53007: LD_INT 2
53009: ARRAY
53010: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
53011: LD_ADDR_VAR 0 6
53015: PUSH
53016: LD_VAR 0 7
53020: PUSH
53021: LD_INT 1
53023: ARRAY
53024: PUSH
53025: LD_INT 3
53027: ARRAY
53028: ST_TO_ADDR
// if InArea ( x , y , area ) then
53029: LD_VAR 0 5
53033: PPUSH
53034: LD_VAR 0 6
53038: PPUSH
53039: LD_VAR 0 2
53043: PPUSH
53044: CALL_OW 309
53048: IFFALSE 53059
// ComStop ( unit ) ;
53050: LD_VAR 0 1
53054: PPUSH
53055: CALL_OW 141
// end ;
53059: LD_VAR 0 4
53063: RET
// export function Abs ( value ) ; begin
53064: LD_INT 0
53066: PPUSH
// result := value ;
53067: LD_ADDR_VAR 0 2
53071: PUSH
53072: LD_VAR 0 1
53076: ST_TO_ADDR
// if value < 0 then
53077: LD_VAR 0 1
53081: PUSH
53082: LD_INT 0
53084: LESS
53085: IFFALSE 53102
// result := value * - 1 ;
53087: LD_ADDR_VAR 0 2
53091: PUSH
53092: LD_VAR 0 1
53096: PUSH
53097: LD_INT 1
53099: NEG
53100: MUL
53101: ST_TO_ADDR
// end ;
53102: LD_VAR 0 2
53106: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
53107: LD_INT 0
53109: PPUSH
53110: PPUSH
53111: PPUSH
53112: PPUSH
53113: PPUSH
53114: PPUSH
53115: PPUSH
53116: PPUSH
// if not unit or not building then
53117: LD_VAR 0 1
53121: NOT
53122: PUSH
53123: LD_VAR 0 2
53127: NOT
53128: OR
53129: IFFALSE 53133
// exit ;
53131: GO 53359
// x := GetX ( building ) ;
53133: LD_ADDR_VAR 0 4
53137: PUSH
53138: LD_VAR 0 2
53142: PPUSH
53143: CALL_OW 250
53147: ST_TO_ADDR
// y := GetY ( building ) ;
53148: LD_ADDR_VAR 0 6
53152: PUSH
53153: LD_VAR 0 2
53157: PPUSH
53158: CALL_OW 251
53162: ST_TO_ADDR
// d := GetDir ( building ) ;
53163: LD_ADDR_VAR 0 8
53167: PUSH
53168: LD_VAR 0 2
53172: PPUSH
53173: CALL_OW 254
53177: ST_TO_ADDR
// r := 4 ;
53178: LD_ADDR_VAR 0 9
53182: PUSH
53183: LD_INT 4
53185: ST_TO_ADDR
// for i := 1 to 5 do
53186: LD_ADDR_VAR 0 10
53190: PUSH
53191: DOUBLE
53192: LD_INT 1
53194: DEC
53195: ST_TO_ADDR
53196: LD_INT 5
53198: PUSH
53199: FOR_TO
53200: IFFALSE 53357
// begin _x := ShiftX ( x , d , r + i ) ;
53202: LD_ADDR_VAR 0 5
53206: PUSH
53207: LD_VAR 0 4
53211: PPUSH
53212: LD_VAR 0 8
53216: PPUSH
53217: LD_VAR 0 9
53221: PUSH
53222: LD_VAR 0 10
53226: PLUS
53227: PPUSH
53228: CALL_OW 272
53232: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
53233: LD_ADDR_VAR 0 7
53237: PUSH
53238: LD_VAR 0 6
53242: PPUSH
53243: LD_VAR 0 8
53247: PPUSH
53248: LD_VAR 0 9
53252: PUSH
53253: LD_VAR 0 10
53257: PLUS
53258: PPUSH
53259: CALL_OW 273
53263: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
53264: LD_VAR 0 5
53268: PPUSH
53269: LD_VAR 0 7
53273: PPUSH
53274: CALL_OW 488
53278: PUSH
53279: LD_VAR 0 5
53283: PPUSH
53284: LD_VAR 0 7
53288: PPUSH
53289: CALL_OW 428
53293: PPUSH
53294: CALL_OW 247
53298: PUSH
53299: LD_INT 3
53301: PUSH
53302: LD_INT 2
53304: PUSH
53305: EMPTY
53306: LIST
53307: LIST
53308: IN
53309: NOT
53310: AND
53311: IFFALSE 53355
// begin ComMoveXY ( unit , _x , _y ) ;
53313: LD_VAR 0 1
53317: PPUSH
53318: LD_VAR 0 5
53322: PPUSH
53323: LD_VAR 0 7
53327: PPUSH
53328: CALL_OW 111
// result := [ _x , _y ] ;
53332: LD_ADDR_VAR 0 3
53336: PUSH
53337: LD_VAR 0 5
53341: PUSH
53342: LD_VAR 0 7
53346: PUSH
53347: EMPTY
53348: LIST
53349: LIST
53350: ST_TO_ADDR
// exit ;
53351: POP
53352: POP
53353: GO 53359
// end ; end ;
53355: GO 53199
53357: POP
53358: POP
// end ;
53359: LD_VAR 0 3
53363: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
53364: LD_INT 0
53366: PPUSH
53367: PPUSH
53368: PPUSH
// result := 0 ;
53369: LD_ADDR_VAR 0 3
53373: PUSH
53374: LD_INT 0
53376: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
53377: LD_VAR 0 1
53381: PUSH
53382: LD_INT 0
53384: LESS
53385: PUSH
53386: LD_VAR 0 1
53390: PUSH
53391: LD_INT 8
53393: GREATER
53394: OR
53395: PUSH
53396: LD_VAR 0 2
53400: PUSH
53401: LD_INT 0
53403: LESS
53404: OR
53405: PUSH
53406: LD_VAR 0 2
53410: PUSH
53411: LD_INT 8
53413: GREATER
53414: OR
53415: IFFALSE 53419
// exit ;
53417: GO 53494
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
53419: LD_ADDR_VAR 0 4
53423: PUSH
53424: LD_INT 22
53426: PUSH
53427: LD_VAR 0 2
53431: PUSH
53432: EMPTY
53433: LIST
53434: LIST
53435: PPUSH
53436: CALL_OW 69
53440: PUSH
53441: FOR_IN
53442: IFFALSE 53492
// begin un := UnitShoot ( i ) ;
53444: LD_ADDR_VAR 0 5
53448: PUSH
53449: LD_VAR 0 4
53453: PPUSH
53454: CALL_OW 504
53458: ST_TO_ADDR
// if GetSide ( un ) = side1 then
53459: LD_VAR 0 5
53463: PPUSH
53464: CALL_OW 255
53468: PUSH
53469: LD_VAR 0 1
53473: EQUAL
53474: IFFALSE 53490
// begin result := un ;
53476: LD_ADDR_VAR 0 3
53480: PUSH
53481: LD_VAR 0 5
53485: ST_TO_ADDR
// exit ;
53486: POP
53487: POP
53488: GO 53494
// end ; end ;
53490: GO 53441
53492: POP
53493: POP
// end ;
53494: LD_VAR 0 3
53498: RET
// export function GetCargoBay ( units ) ; begin
53499: LD_INT 0
53501: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
53502: LD_ADDR_VAR 0 2
53506: PUSH
53507: LD_VAR 0 1
53511: PPUSH
53512: LD_INT 2
53514: PUSH
53515: LD_INT 34
53517: PUSH
53518: LD_INT 12
53520: PUSH
53521: EMPTY
53522: LIST
53523: LIST
53524: PUSH
53525: LD_INT 34
53527: PUSH
53528: LD_INT 51
53530: PUSH
53531: EMPTY
53532: LIST
53533: LIST
53534: PUSH
53535: LD_INT 34
53537: PUSH
53538: LD_INT 32
53540: PUSH
53541: EMPTY
53542: LIST
53543: LIST
53544: PUSH
53545: LD_INT 34
53547: PUSH
53548: LD_INT 89
53550: PUSH
53551: EMPTY
53552: LIST
53553: LIST
53554: PUSH
53555: EMPTY
53556: LIST
53557: LIST
53558: LIST
53559: LIST
53560: LIST
53561: PPUSH
53562: CALL_OW 72
53566: ST_TO_ADDR
// end ;
53567: LD_VAR 0 2
53571: RET
// export function Negate ( value ) ; begin
53572: LD_INT 0
53574: PPUSH
// result := not value ;
53575: LD_ADDR_VAR 0 2
53579: PUSH
53580: LD_VAR 0 1
53584: NOT
53585: ST_TO_ADDR
// end ;
53586: LD_VAR 0 2
53590: RET
// export function Inc ( value ) ; begin
53591: LD_INT 0
53593: PPUSH
// result := value + 1 ;
53594: LD_ADDR_VAR 0 2
53598: PUSH
53599: LD_VAR 0 1
53603: PUSH
53604: LD_INT 1
53606: PLUS
53607: ST_TO_ADDR
// end ;
53608: LD_VAR 0 2
53612: RET
// export function Dec ( value ) ; begin
53613: LD_INT 0
53615: PPUSH
// result := value - 1 ;
53616: LD_ADDR_VAR 0 2
53620: PUSH
53621: LD_VAR 0 1
53625: PUSH
53626: LD_INT 1
53628: MINUS
53629: ST_TO_ADDR
// end ;
53630: LD_VAR 0 2
53634: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
53635: LD_INT 0
53637: PPUSH
53638: PPUSH
53639: PPUSH
53640: PPUSH
53641: PPUSH
53642: PPUSH
53643: PPUSH
53644: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
53645: LD_VAR 0 1
53649: PPUSH
53650: LD_VAR 0 2
53654: PPUSH
53655: CALL_OW 488
53659: NOT
53660: PUSH
53661: LD_VAR 0 3
53665: PPUSH
53666: LD_VAR 0 4
53670: PPUSH
53671: CALL_OW 488
53675: NOT
53676: OR
53677: IFFALSE 53690
// begin result := - 1 ;
53679: LD_ADDR_VAR 0 5
53683: PUSH
53684: LD_INT 1
53686: NEG
53687: ST_TO_ADDR
// exit ;
53688: GO 53925
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
53690: LD_ADDR_VAR 0 12
53694: PUSH
53695: LD_VAR 0 1
53699: PPUSH
53700: LD_VAR 0 2
53704: PPUSH
53705: LD_VAR 0 3
53709: PPUSH
53710: LD_VAR 0 4
53714: PPUSH
53715: CALL 52775 0 4
53719: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
53720: LD_ADDR_VAR 0 11
53724: PUSH
53725: LD_VAR 0 1
53729: PPUSH
53730: LD_VAR 0 2
53734: PPUSH
53735: LD_VAR 0 12
53739: PUSH
53740: LD_INT 1
53742: ARRAY
53743: PPUSH
53744: LD_VAR 0 12
53748: PUSH
53749: LD_INT 2
53751: ARRAY
53752: PPUSH
53753: CALL_OW 298
53757: ST_TO_ADDR
// distance := 9999 ;
53758: LD_ADDR_VAR 0 10
53762: PUSH
53763: LD_INT 9999
53765: ST_TO_ADDR
// for i := 0 to 5 do
53766: LD_ADDR_VAR 0 6
53770: PUSH
53771: DOUBLE
53772: LD_INT 0
53774: DEC
53775: ST_TO_ADDR
53776: LD_INT 5
53778: PUSH
53779: FOR_TO
53780: IFFALSE 53923
// begin _x := ShiftX ( x1 , i , centerDist ) ;
53782: LD_ADDR_VAR 0 7
53786: PUSH
53787: LD_VAR 0 1
53791: PPUSH
53792: LD_VAR 0 6
53796: PPUSH
53797: LD_VAR 0 11
53801: PPUSH
53802: CALL_OW 272
53806: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
53807: LD_ADDR_VAR 0 8
53811: PUSH
53812: LD_VAR 0 2
53816: PPUSH
53817: LD_VAR 0 6
53821: PPUSH
53822: LD_VAR 0 11
53826: PPUSH
53827: CALL_OW 273
53831: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53832: LD_VAR 0 7
53836: PPUSH
53837: LD_VAR 0 8
53841: PPUSH
53842: CALL_OW 488
53846: NOT
53847: IFFALSE 53851
// continue ;
53849: GO 53779
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
53851: LD_ADDR_VAR 0 9
53855: PUSH
53856: LD_VAR 0 12
53860: PUSH
53861: LD_INT 1
53863: ARRAY
53864: PPUSH
53865: LD_VAR 0 12
53869: PUSH
53870: LD_INT 2
53872: ARRAY
53873: PPUSH
53874: LD_VAR 0 7
53878: PPUSH
53879: LD_VAR 0 8
53883: PPUSH
53884: CALL_OW 298
53888: ST_TO_ADDR
// if tmp < distance then
53889: LD_VAR 0 9
53893: PUSH
53894: LD_VAR 0 10
53898: LESS
53899: IFFALSE 53921
// begin result := i ;
53901: LD_ADDR_VAR 0 5
53905: PUSH
53906: LD_VAR 0 6
53910: ST_TO_ADDR
// distance := tmp ;
53911: LD_ADDR_VAR 0 10
53915: PUSH
53916: LD_VAR 0 9
53920: ST_TO_ADDR
// end ; end ;
53921: GO 53779
53923: POP
53924: POP
// end ;
53925: LD_VAR 0 5
53929: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
53930: LD_INT 0
53932: PPUSH
53933: PPUSH
// if not driver or not IsInUnit ( driver ) then
53934: LD_VAR 0 1
53938: NOT
53939: PUSH
53940: LD_VAR 0 1
53944: PPUSH
53945: CALL_OW 310
53949: NOT
53950: OR
53951: IFFALSE 53955
// exit ;
53953: GO 54045
// vehicle := IsInUnit ( driver ) ;
53955: LD_ADDR_VAR 0 3
53959: PUSH
53960: LD_VAR 0 1
53964: PPUSH
53965: CALL_OW 310
53969: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
53970: LD_VAR 0 1
53974: PPUSH
53975: LD_STRING \
53977: PUSH
53978: LD_INT 0
53980: PUSH
53981: LD_INT 0
53983: PUSH
53984: LD_INT 0
53986: PUSH
53987: LD_INT 0
53989: PUSH
53990: LD_INT 0
53992: PUSH
53993: LD_INT 0
53995: PUSH
53996: EMPTY
53997: LIST
53998: LIST
53999: LIST
54000: LIST
54001: LIST
54002: LIST
54003: LIST
54004: PUSH
54005: LD_STRING E
54007: PUSH
54008: LD_INT 0
54010: PUSH
54011: LD_INT 0
54013: PUSH
54014: LD_VAR 0 3
54018: PUSH
54019: LD_INT 0
54021: PUSH
54022: LD_INT 0
54024: PUSH
54025: LD_INT 0
54027: PUSH
54028: EMPTY
54029: LIST
54030: LIST
54031: LIST
54032: LIST
54033: LIST
54034: LIST
54035: LIST
54036: PUSH
54037: EMPTY
54038: LIST
54039: LIST
54040: PPUSH
54041: CALL_OW 446
// end ;
54045: LD_VAR 0 2
54049: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
54050: LD_INT 0
54052: PPUSH
54053: PPUSH
// if not driver or not IsInUnit ( driver ) then
54054: LD_VAR 0 1
54058: NOT
54059: PUSH
54060: LD_VAR 0 1
54064: PPUSH
54065: CALL_OW 310
54069: NOT
54070: OR
54071: IFFALSE 54075
// exit ;
54073: GO 54165
// vehicle := IsInUnit ( driver ) ;
54075: LD_ADDR_VAR 0 3
54079: PUSH
54080: LD_VAR 0 1
54084: PPUSH
54085: CALL_OW 310
54089: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54090: LD_VAR 0 1
54094: PPUSH
54095: LD_STRING \
54097: PUSH
54098: LD_INT 0
54100: PUSH
54101: LD_INT 0
54103: PUSH
54104: LD_INT 0
54106: PUSH
54107: LD_INT 0
54109: PUSH
54110: LD_INT 0
54112: PUSH
54113: LD_INT 0
54115: PUSH
54116: EMPTY
54117: LIST
54118: LIST
54119: LIST
54120: LIST
54121: LIST
54122: LIST
54123: LIST
54124: PUSH
54125: LD_STRING E
54127: PUSH
54128: LD_INT 0
54130: PUSH
54131: LD_INT 0
54133: PUSH
54134: LD_VAR 0 3
54138: PUSH
54139: LD_INT 0
54141: PUSH
54142: LD_INT 0
54144: PUSH
54145: LD_INT 0
54147: PUSH
54148: EMPTY
54149: LIST
54150: LIST
54151: LIST
54152: LIST
54153: LIST
54154: LIST
54155: LIST
54156: PUSH
54157: EMPTY
54158: LIST
54159: LIST
54160: PPUSH
54161: CALL_OW 447
// end ;
54165: LD_VAR 0 2
54169: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
54170: LD_INT 0
54172: PPUSH
54173: PPUSH
54174: PPUSH
// tmp := [ ] ;
54175: LD_ADDR_VAR 0 5
54179: PUSH
54180: EMPTY
54181: ST_TO_ADDR
// for i in units do
54182: LD_ADDR_VAR 0 4
54186: PUSH
54187: LD_VAR 0 1
54191: PUSH
54192: FOR_IN
54193: IFFALSE 54231
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
54195: LD_ADDR_VAR 0 5
54199: PUSH
54200: LD_VAR 0 5
54204: PPUSH
54205: LD_VAR 0 5
54209: PUSH
54210: LD_INT 1
54212: PLUS
54213: PPUSH
54214: LD_VAR 0 4
54218: PPUSH
54219: CALL_OW 256
54223: PPUSH
54224: CALL_OW 2
54228: ST_TO_ADDR
54229: GO 54192
54231: POP
54232: POP
// if not tmp then
54233: LD_VAR 0 5
54237: NOT
54238: IFFALSE 54242
// exit ;
54240: GO 54290
// if asc then
54242: LD_VAR 0 2
54246: IFFALSE 54270
// result := SortListByListAsc ( units , tmp ) else
54248: LD_ADDR_VAR 0 3
54252: PUSH
54253: LD_VAR 0 1
54257: PPUSH
54258: LD_VAR 0 5
54262: PPUSH
54263: CALL_OW 76
54267: ST_TO_ADDR
54268: GO 54290
// result := SortListByListDesc ( units , tmp ) ;
54270: LD_ADDR_VAR 0 3
54274: PUSH
54275: LD_VAR 0 1
54279: PPUSH
54280: LD_VAR 0 5
54284: PPUSH
54285: CALL_OW 77
54289: ST_TO_ADDR
// end ;
54290: LD_VAR 0 3
54294: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
54295: LD_INT 0
54297: PPUSH
54298: PPUSH
// task := GetTaskList ( mech ) ;
54299: LD_ADDR_VAR 0 4
54303: PUSH
54304: LD_VAR 0 1
54308: PPUSH
54309: CALL_OW 437
54313: ST_TO_ADDR
// if not task then
54314: LD_VAR 0 4
54318: NOT
54319: IFFALSE 54323
// exit ;
54321: GO 54365
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
54323: LD_ADDR_VAR 0 3
54327: PUSH
54328: LD_VAR 0 4
54332: PUSH
54333: LD_INT 1
54335: ARRAY
54336: PUSH
54337: LD_INT 1
54339: ARRAY
54340: PUSH
54341: LD_STRING r
54343: EQUAL
54344: PUSH
54345: LD_VAR 0 4
54349: PUSH
54350: LD_INT 1
54352: ARRAY
54353: PUSH
54354: LD_INT 4
54356: ARRAY
54357: PUSH
54358: LD_VAR 0 2
54362: EQUAL
54363: AND
54364: ST_TO_ADDR
// end ;
54365: LD_VAR 0 3
54369: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
54370: LD_INT 0
54372: PPUSH
// SetDir ( unit , d ) ;
54373: LD_VAR 0 1
54377: PPUSH
54378: LD_VAR 0 4
54382: PPUSH
54383: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
54387: LD_VAR 0 1
54391: PPUSH
54392: LD_VAR 0 2
54396: PPUSH
54397: LD_VAR 0 3
54401: PPUSH
54402: LD_VAR 0 5
54406: PPUSH
54407: CALL_OW 48
// end ;
54411: LD_VAR 0 6
54415: RET
// export function ToNaturalNumber ( number ) ; begin
54416: LD_INT 0
54418: PPUSH
// result := number div 1 ;
54419: LD_ADDR_VAR 0 2
54423: PUSH
54424: LD_VAR 0 1
54428: PUSH
54429: LD_INT 1
54431: DIV
54432: ST_TO_ADDR
// if number < 0 then
54433: LD_VAR 0 1
54437: PUSH
54438: LD_INT 0
54440: LESS
54441: IFFALSE 54451
// result := 0 ;
54443: LD_ADDR_VAR 0 2
54447: PUSH
54448: LD_INT 0
54450: ST_TO_ADDR
// end ;
54451: LD_VAR 0 2
54455: RET
// export function SortByClass ( units , class ) ; var un ; begin
54456: LD_INT 0
54458: PPUSH
54459: PPUSH
// if not units or not class then
54460: LD_VAR 0 1
54464: NOT
54465: PUSH
54466: LD_VAR 0 2
54470: NOT
54471: OR
54472: IFFALSE 54476
// exit ;
54474: GO 54571
// result := [ ] ;
54476: LD_ADDR_VAR 0 3
54480: PUSH
54481: EMPTY
54482: ST_TO_ADDR
// for un in units do
54483: LD_ADDR_VAR 0 4
54487: PUSH
54488: LD_VAR 0 1
54492: PUSH
54493: FOR_IN
54494: IFFALSE 54569
// if GetClass ( un ) = class then
54496: LD_VAR 0 4
54500: PPUSH
54501: CALL_OW 257
54505: PUSH
54506: LD_VAR 0 2
54510: EQUAL
54511: IFFALSE 54538
// result := Insert ( result , 1 , un ) else
54513: LD_ADDR_VAR 0 3
54517: PUSH
54518: LD_VAR 0 3
54522: PPUSH
54523: LD_INT 1
54525: PPUSH
54526: LD_VAR 0 4
54530: PPUSH
54531: CALL_OW 2
54535: ST_TO_ADDR
54536: GO 54567
// result := Replace ( result , result + 1 , un ) ;
54538: LD_ADDR_VAR 0 3
54542: PUSH
54543: LD_VAR 0 3
54547: PPUSH
54548: LD_VAR 0 3
54552: PUSH
54553: LD_INT 1
54555: PLUS
54556: PPUSH
54557: LD_VAR 0 4
54561: PPUSH
54562: CALL_OW 1
54566: ST_TO_ADDR
54567: GO 54493
54569: POP
54570: POP
// end ;
54571: LD_VAR 0 3
54575: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
54576: LD_INT 0
54578: PPUSH
54579: PPUSH
54580: PPUSH
54581: PPUSH
54582: PPUSH
54583: PPUSH
54584: PPUSH
// result := [ ] ;
54585: LD_ADDR_VAR 0 4
54589: PUSH
54590: EMPTY
54591: ST_TO_ADDR
// if x - r < 0 then
54592: LD_VAR 0 1
54596: PUSH
54597: LD_VAR 0 3
54601: MINUS
54602: PUSH
54603: LD_INT 0
54605: LESS
54606: IFFALSE 54618
// min_x := 0 else
54608: LD_ADDR_VAR 0 8
54612: PUSH
54613: LD_INT 0
54615: ST_TO_ADDR
54616: GO 54634
// min_x := x - r ;
54618: LD_ADDR_VAR 0 8
54622: PUSH
54623: LD_VAR 0 1
54627: PUSH
54628: LD_VAR 0 3
54632: MINUS
54633: ST_TO_ADDR
// if y - r < 0 then
54634: LD_VAR 0 2
54638: PUSH
54639: LD_VAR 0 3
54643: MINUS
54644: PUSH
54645: LD_INT 0
54647: LESS
54648: IFFALSE 54660
// min_y := 0 else
54650: LD_ADDR_VAR 0 7
54654: PUSH
54655: LD_INT 0
54657: ST_TO_ADDR
54658: GO 54676
// min_y := y - r ;
54660: LD_ADDR_VAR 0 7
54664: PUSH
54665: LD_VAR 0 2
54669: PUSH
54670: LD_VAR 0 3
54674: MINUS
54675: ST_TO_ADDR
// max_x := x + r ;
54676: LD_ADDR_VAR 0 9
54680: PUSH
54681: LD_VAR 0 1
54685: PUSH
54686: LD_VAR 0 3
54690: PLUS
54691: ST_TO_ADDR
// max_y := y + r ;
54692: LD_ADDR_VAR 0 10
54696: PUSH
54697: LD_VAR 0 2
54701: PUSH
54702: LD_VAR 0 3
54706: PLUS
54707: ST_TO_ADDR
// for _x = min_x to max_x do
54708: LD_ADDR_VAR 0 5
54712: PUSH
54713: DOUBLE
54714: LD_VAR 0 8
54718: DEC
54719: ST_TO_ADDR
54720: LD_VAR 0 9
54724: PUSH
54725: FOR_TO
54726: IFFALSE 54827
// for _y = min_y to max_y do
54728: LD_ADDR_VAR 0 6
54732: PUSH
54733: DOUBLE
54734: LD_VAR 0 7
54738: DEC
54739: ST_TO_ADDR
54740: LD_VAR 0 10
54744: PUSH
54745: FOR_TO
54746: IFFALSE 54823
// begin if not ValidHex ( _x , _y ) then
54748: LD_VAR 0 5
54752: PPUSH
54753: LD_VAR 0 6
54757: PPUSH
54758: CALL_OW 488
54762: NOT
54763: IFFALSE 54767
// continue ;
54765: GO 54745
// if GetResourceTypeXY ( _x , _y ) then
54767: LD_VAR 0 5
54771: PPUSH
54772: LD_VAR 0 6
54776: PPUSH
54777: CALL_OW 283
54781: IFFALSE 54821
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
54783: LD_ADDR_VAR 0 4
54787: PUSH
54788: LD_VAR 0 4
54792: PPUSH
54793: LD_VAR 0 4
54797: PUSH
54798: LD_INT 1
54800: PLUS
54801: PPUSH
54802: LD_VAR 0 5
54806: PUSH
54807: LD_VAR 0 6
54811: PUSH
54812: EMPTY
54813: LIST
54814: LIST
54815: PPUSH
54816: CALL_OW 1
54820: ST_TO_ADDR
// end ;
54821: GO 54745
54823: POP
54824: POP
54825: GO 54725
54827: POP
54828: POP
// end ;
54829: LD_VAR 0 4
54833: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
54834: LD_INT 0
54836: PPUSH
54837: PPUSH
54838: PPUSH
54839: PPUSH
54840: PPUSH
54841: PPUSH
54842: PPUSH
54843: PPUSH
// if not units then
54844: LD_VAR 0 1
54848: NOT
54849: IFFALSE 54853
// exit ;
54851: GO 55377
// result := UnitFilter ( units , [ f_ok ] ) ;
54853: LD_ADDR_VAR 0 3
54857: PUSH
54858: LD_VAR 0 1
54862: PPUSH
54863: LD_INT 50
54865: PUSH
54866: EMPTY
54867: LIST
54868: PPUSH
54869: CALL_OW 72
54873: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
54874: LD_ADDR_VAR 0 8
54878: PUSH
54879: LD_VAR 0 1
54883: PUSH
54884: LD_INT 1
54886: ARRAY
54887: PPUSH
54888: CALL_OW 255
54892: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
54893: LD_ADDR_VAR 0 10
54897: PUSH
54898: LD_INT 29
54900: PUSH
54901: LD_INT 91
54903: PUSH
54904: LD_INT 49
54906: PUSH
54907: EMPTY
54908: LIST
54909: LIST
54910: LIST
54911: ST_TO_ADDR
// if not result then
54912: LD_VAR 0 3
54916: NOT
54917: IFFALSE 54921
// exit ;
54919: GO 55377
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
54921: LD_ADDR_VAR 0 5
54925: PUSH
54926: LD_INT 81
54928: PUSH
54929: LD_VAR 0 8
54933: PUSH
54934: EMPTY
54935: LIST
54936: LIST
54937: PPUSH
54938: CALL_OW 69
54942: ST_TO_ADDR
// for i in result do
54943: LD_ADDR_VAR 0 4
54947: PUSH
54948: LD_VAR 0 3
54952: PUSH
54953: FOR_IN
54954: IFFALSE 55375
// begin tag := GetTag ( i ) + 1 ;
54956: LD_ADDR_VAR 0 9
54960: PUSH
54961: LD_VAR 0 4
54965: PPUSH
54966: CALL_OW 110
54970: PUSH
54971: LD_INT 1
54973: PLUS
54974: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
54975: LD_ADDR_VAR 0 7
54979: PUSH
54980: LD_VAR 0 4
54984: PPUSH
54985: CALL_OW 250
54989: PPUSH
54990: LD_VAR 0 4
54994: PPUSH
54995: CALL_OW 251
54999: PPUSH
55000: LD_INT 6
55002: PPUSH
55003: CALL 54576 0 3
55007: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
55008: LD_VAR 0 4
55012: PPUSH
55013: CALL_OW 247
55017: PUSH
55018: LD_INT 2
55020: EQUAL
55021: PUSH
55022: LD_VAR 0 7
55026: AND
55027: PUSH
55028: LD_VAR 0 4
55032: PPUSH
55033: CALL_OW 264
55037: PUSH
55038: LD_VAR 0 10
55042: IN
55043: NOT
55044: AND
55045: IFFALSE 55084
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
55047: LD_VAR 0 4
55051: PPUSH
55052: LD_VAR 0 7
55056: PUSH
55057: LD_INT 1
55059: ARRAY
55060: PUSH
55061: LD_INT 1
55063: ARRAY
55064: PPUSH
55065: LD_VAR 0 7
55069: PUSH
55070: LD_INT 1
55072: ARRAY
55073: PUSH
55074: LD_INT 2
55076: ARRAY
55077: PPUSH
55078: CALL_OW 116
55082: GO 55373
// if path > tag then
55084: LD_VAR 0 2
55088: PUSH
55089: LD_VAR 0 9
55093: GREATER
55094: IFFALSE 55302
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
55096: LD_ADDR_VAR 0 6
55100: PUSH
55101: LD_VAR 0 5
55105: PPUSH
55106: LD_INT 91
55108: PUSH
55109: LD_VAR 0 4
55113: PUSH
55114: LD_INT 8
55116: PUSH
55117: EMPTY
55118: LIST
55119: LIST
55120: LIST
55121: PPUSH
55122: CALL_OW 72
55126: ST_TO_ADDR
// if nearEnemy then
55127: LD_VAR 0 6
55131: IFFALSE 55200
// begin if GetWeapon ( i ) = ru_time_lapser then
55133: LD_VAR 0 4
55137: PPUSH
55138: CALL_OW 264
55142: PUSH
55143: LD_INT 49
55145: EQUAL
55146: IFFALSE 55174
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
55148: LD_VAR 0 4
55152: PPUSH
55153: LD_VAR 0 6
55157: PPUSH
55158: LD_VAR 0 4
55162: PPUSH
55163: CALL_OW 74
55167: PPUSH
55168: CALL_OW 112
55172: GO 55198
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
55174: LD_VAR 0 4
55178: PPUSH
55179: LD_VAR 0 6
55183: PPUSH
55184: LD_VAR 0 4
55188: PPUSH
55189: CALL_OW 74
55193: PPUSH
55194: CALL_OW 115
// end else
55198: GO 55300
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
55200: LD_VAR 0 4
55204: PPUSH
55205: LD_VAR 0 2
55209: PUSH
55210: LD_VAR 0 9
55214: ARRAY
55215: PUSH
55216: LD_INT 1
55218: ARRAY
55219: PPUSH
55220: LD_VAR 0 2
55224: PUSH
55225: LD_VAR 0 9
55229: ARRAY
55230: PUSH
55231: LD_INT 2
55233: ARRAY
55234: PPUSH
55235: CALL_OW 297
55239: PUSH
55240: LD_INT 6
55242: GREATER
55243: IFFALSE 55286
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
55245: LD_VAR 0 4
55249: PPUSH
55250: LD_VAR 0 2
55254: PUSH
55255: LD_VAR 0 9
55259: ARRAY
55260: PUSH
55261: LD_INT 1
55263: ARRAY
55264: PPUSH
55265: LD_VAR 0 2
55269: PUSH
55270: LD_VAR 0 9
55274: ARRAY
55275: PUSH
55276: LD_INT 2
55278: ARRAY
55279: PPUSH
55280: CALL_OW 114
55284: GO 55300
// SetTag ( i , tag ) ;
55286: LD_VAR 0 4
55290: PPUSH
55291: LD_VAR 0 9
55295: PPUSH
55296: CALL_OW 109
// end else
55300: GO 55373
// if enemy then
55302: LD_VAR 0 5
55306: IFFALSE 55373
// begin if GetWeapon ( i ) = ru_time_lapser then
55308: LD_VAR 0 4
55312: PPUSH
55313: CALL_OW 264
55317: PUSH
55318: LD_INT 49
55320: EQUAL
55321: IFFALSE 55349
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
55323: LD_VAR 0 4
55327: PPUSH
55328: LD_VAR 0 5
55332: PPUSH
55333: LD_VAR 0 4
55337: PPUSH
55338: CALL_OW 74
55342: PPUSH
55343: CALL_OW 112
55347: GO 55373
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
55349: LD_VAR 0 4
55353: PPUSH
55354: LD_VAR 0 5
55358: PPUSH
55359: LD_VAR 0 4
55363: PPUSH
55364: CALL_OW 74
55368: PPUSH
55369: CALL_OW 115
// end ; end ;
55373: GO 54953
55375: POP
55376: POP
// end ;
55377: LD_VAR 0 3
55381: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
55382: LD_INT 0
55384: PPUSH
55385: PPUSH
55386: PPUSH
// if not unit or IsInUnit ( unit ) then
55387: LD_VAR 0 1
55391: NOT
55392: PUSH
55393: LD_VAR 0 1
55397: PPUSH
55398: CALL_OW 310
55402: OR
55403: IFFALSE 55407
// exit ;
55405: GO 55498
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
55407: LD_ADDR_VAR 0 4
55411: PUSH
55412: LD_VAR 0 1
55416: PPUSH
55417: CALL_OW 250
55421: PPUSH
55422: LD_VAR 0 2
55426: PPUSH
55427: LD_INT 1
55429: PPUSH
55430: CALL_OW 272
55434: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
55435: LD_ADDR_VAR 0 5
55439: PUSH
55440: LD_VAR 0 1
55444: PPUSH
55445: CALL_OW 251
55449: PPUSH
55450: LD_VAR 0 2
55454: PPUSH
55455: LD_INT 1
55457: PPUSH
55458: CALL_OW 273
55462: ST_TO_ADDR
// if ValidHex ( x , y ) then
55463: LD_VAR 0 4
55467: PPUSH
55468: LD_VAR 0 5
55472: PPUSH
55473: CALL_OW 488
55477: IFFALSE 55498
// ComTurnXY ( unit , x , y ) ;
55479: LD_VAR 0 1
55483: PPUSH
55484: LD_VAR 0 4
55488: PPUSH
55489: LD_VAR 0 5
55493: PPUSH
55494: CALL_OW 118
// end ;
55498: LD_VAR 0 3
55502: RET
// export function SeeUnits ( side , units ) ; var i ; begin
55503: LD_INT 0
55505: PPUSH
55506: PPUSH
// result := false ;
55507: LD_ADDR_VAR 0 3
55511: PUSH
55512: LD_INT 0
55514: ST_TO_ADDR
// if not units then
55515: LD_VAR 0 2
55519: NOT
55520: IFFALSE 55524
// exit ;
55522: GO 55569
// for i in units do
55524: LD_ADDR_VAR 0 4
55528: PUSH
55529: LD_VAR 0 2
55533: PUSH
55534: FOR_IN
55535: IFFALSE 55567
// if See ( side , i ) then
55537: LD_VAR 0 1
55541: PPUSH
55542: LD_VAR 0 4
55546: PPUSH
55547: CALL_OW 292
55551: IFFALSE 55565
// begin result := true ;
55553: LD_ADDR_VAR 0 3
55557: PUSH
55558: LD_INT 1
55560: ST_TO_ADDR
// exit ;
55561: POP
55562: POP
55563: GO 55569
// end ;
55565: GO 55534
55567: POP
55568: POP
// end ;
55569: LD_VAR 0 3
55573: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
55574: LD_INT 0
55576: PPUSH
55577: PPUSH
55578: PPUSH
55579: PPUSH
// if not unit or not points then
55580: LD_VAR 0 1
55584: NOT
55585: PUSH
55586: LD_VAR 0 2
55590: NOT
55591: OR
55592: IFFALSE 55596
// exit ;
55594: GO 55686
// dist := 99999 ;
55596: LD_ADDR_VAR 0 5
55600: PUSH
55601: LD_INT 99999
55603: ST_TO_ADDR
// for i in points do
55604: LD_ADDR_VAR 0 4
55608: PUSH
55609: LD_VAR 0 2
55613: PUSH
55614: FOR_IN
55615: IFFALSE 55684
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
55617: LD_ADDR_VAR 0 6
55621: PUSH
55622: LD_VAR 0 1
55626: PPUSH
55627: LD_VAR 0 4
55631: PUSH
55632: LD_INT 1
55634: ARRAY
55635: PPUSH
55636: LD_VAR 0 4
55640: PUSH
55641: LD_INT 2
55643: ARRAY
55644: PPUSH
55645: CALL_OW 297
55649: ST_TO_ADDR
// if tmpDist < dist then
55650: LD_VAR 0 6
55654: PUSH
55655: LD_VAR 0 5
55659: LESS
55660: IFFALSE 55682
// begin result := i ;
55662: LD_ADDR_VAR 0 3
55666: PUSH
55667: LD_VAR 0 4
55671: ST_TO_ADDR
// dist := tmpDist ;
55672: LD_ADDR_VAR 0 5
55676: PUSH
55677: LD_VAR 0 6
55681: ST_TO_ADDR
// end ; end ;
55682: GO 55614
55684: POP
55685: POP
// end ;
55686: LD_VAR 0 3
55690: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
55691: LD_INT 0
55693: PPUSH
// uc_side := side ;
55694: LD_ADDR_OWVAR 20
55698: PUSH
55699: LD_VAR 0 1
55703: ST_TO_ADDR
// uc_nation := 3 ;
55704: LD_ADDR_OWVAR 21
55708: PUSH
55709: LD_INT 3
55711: ST_TO_ADDR
// vc_chassis := 25 ;
55712: LD_ADDR_OWVAR 37
55716: PUSH
55717: LD_INT 25
55719: ST_TO_ADDR
// vc_engine := engine_siberite ;
55720: LD_ADDR_OWVAR 39
55724: PUSH
55725: LD_INT 3
55727: ST_TO_ADDR
// vc_control := control_computer ;
55728: LD_ADDR_OWVAR 38
55732: PUSH
55733: LD_INT 3
55735: ST_TO_ADDR
// vc_weapon := 59 ;
55736: LD_ADDR_OWVAR 40
55740: PUSH
55741: LD_INT 59
55743: ST_TO_ADDR
// result := CreateVehicle ;
55744: LD_ADDR_VAR 0 5
55748: PUSH
55749: CALL_OW 45
55753: ST_TO_ADDR
// SetDir ( result , d ) ;
55754: LD_VAR 0 5
55758: PPUSH
55759: LD_VAR 0 4
55763: PPUSH
55764: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
55768: LD_VAR 0 5
55772: PPUSH
55773: LD_VAR 0 2
55777: PPUSH
55778: LD_VAR 0 3
55782: PPUSH
55783: LD_INT 0
55785: PPUSH
55786: CALL_OW 48
// end ;
55790: LD_VAR 0 5
55794: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
55795: LD_INT 0
55797: PPUSH
55798: PPUSH
55799: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
55800: LD_ADDR_VAR 0 2
55804: PUSH
55805: LD_INT 0
55807: PUSH
55808: LD_INT 0
55810: PUSH
55811: LD_INT 0
55813: PUSH
55814: LD_INT 0
55816: PUSH
55817: EMPTY
55818: LIST
55819: LIST
55820: LIST
55821: LIST
55822: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
55823: LD_VAR 0 1
55827: NOT
55828: PUSH
55829: LD_VAR 0 1
55833: PPUSH
55834: CALL_OW 264
55838: PUSH
55839: LD_INT 12
55841: PUSH
55842: LD_INT 51
55844: PUSH
55845: LD_INT 32
55847: PUSH
55848: LD_INT 89
55850: PUSH
55851: EMPTY
55852: LIST
55853: LIST
55854: LIST
55855: LIST
55856: IN
55857: NOT
55858: OR
55859: IFFALSE 55863
// exit ;
55861: GO 55961
// for i := 1 to 3 do
55863: LD_ADDR_VAR 0 3
55867: PUSH
55868: DOUBLE
55869: LD_INT 1
55871: DEC
55872: ST_TO_ADDR
55873: LD_INT 3
55875: PUSH
55876: FOR_TO
55877: IFFALSE 55959
// begin tmp := GetCargo ( cargo , i ) ;
55879: LD_ADDR_VAR 0 4
55883: PUSH
55884: LD_VAR 0 1
55888: PPUSH
55889: LD_VAR 0 3
55893: PPUSH
55894: CALL_OW 289
55898: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
55899: LD_ADDR_VAR 0 2
55903: PUSH
55904: LD_VAR 0 2
55908: PPUSH
55909: LD_VAR 0 3
55913: PPUSH
55914: LD_VAR 0 4
55918: PPUSH
55919: CALL_OW 1
55923: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
55924: LD_ADDR_VAR 0 2
55928: PUSH
55929: LD_VAR 0 2
55933: PPUSH
55934: LD_INT 4
55936: PPUSH
55937: LD_VAR 0 2
55941: PUSH
55942: LD_INT 4
55944: ARRAY
55945: PUSH
55946: LD_VAR 0 4
55950: PLUS
55951: PPUSH
55952: CALL_OW 1
55956: ST_TO_ADDR
// end ;
55957: GO 55876
55959: POP
55960: POP
// end ;
55961: LD_VAR 0 2
55965: RET
// export function Length ( array ) ; begin
55966: LD_INT 0
55968: PPUSH
// result := array + 0 ;
55969: LD_ADDR_VAR 0 2
55973: PUSH
55974: LD_VAR 0 1
55978: PUSH
55979: LD_INT 0
55981: PLUS
55982: ST_TO_ADDR
// end ;
55983: LD_VAR 0 2
55987: RET
// export function PrepareArray ( array ) ; begin
55988: LD_INT 0
55990: PPUSH
// result := array diff 0 ;
55991: LD_ADDR_VAR 0 2
55995: PUSH
55996: LD_VAR 0 1
56000: PUSH
56001: LD_INT 0
56003: DIFF
56004: ST_TO_ADDR
// if not result [ 1 ] then
56005: LD_VAR 0 2
56009: PUSH
56010: LD_INT 1
56012: ARRAY
56013: NOT
56014: IFFALSE 56034
// result := Delete ( result , 1 ) ;
56016: LD_ADDR_VAR 0 2
56020: PUSH
56021: LD_VAR 0 2
56025: PPUSH
56026: LD_INT 1
56028: PPUSH
56029: CALL_OW 3
56033: ST_TO_ADDR
// end ; end_of_file
56034: LD_VAR 0 2
56038: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
56039: LD_INT 0
56041: PPUSH
56042: PPUSH
// skirmish := false ;
56043: LD_ADDR_EXP 58
56047: PUSH
56048: LD_INT 0
56050: ST_TO_ADDR
// debug_mc := false ;
56051: LD_ADDR_EXP 59
56055: PUSH
56056: LD_INT 0
56058: ST_TO_ADDR
// mc_bases := [ ] ;
56059: LD_ADDR_EXP 60
56063: PUSH
56064: EMPTY
56065: ST_TO_ADDR
// mc_sides := [ ] ;
56066: LD_ADDR_EXP 86
56070: PUSH
56071: EMPTY
56072: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56073: LD_ADDR_EXP 61
56077: PUSH
56078: EMPTY
56079: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56080: LD_ADDR_EXP 62
56084: PUSH
56085: EMPTY
56086: ST_TO_ADDR
// mc_need_heal := [ ] ;
56087: LD_ADDR_EXP 63
56091: PUSH
56092: EMPTY
56093: ST_TO_ADDR
// mc_healers := [ ] ;
56094: LD_ADDR_EXP 64
56098: PUSH
56099: EMPTY
56100: ST_TO_ADDR
// mc_build_list := [ ] ;
56101: LD_ADDR_EXP 65
56105: PUSH
56106: EMPTY
56107: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56108: LD_ADDR_EXP 92
56112: PUSH
56113: EMPTY
56114: ST_TO_ADDR
// mc_builders := [ ] ;
56115: LD_ADDR_EXP 66
56119: PUSH
56120: EMPTY
56121: ST_TO_ADDR
// mc_construct_list := [ ] ;
56122: LD_ADDR_EXP 67
56126: PUSH
56127: EMPTY
56128: ST_TO_ADDR
// mc_turret_list := [ ] ;
56129: LD_ADDR_EXP 68
56133: PUSH
56134: EMPTY
56135: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56136: LD_ADDR_EXP 69
56140: PUSH
56141: EMPTY
56142: ST_TO_ADDR
// mc_miners := [ ] ;
56143: LD_ADDR_EXP 74
56147: PUSH
56148: EMPTY
56149: ST_TO_ADDR
// mc_mines := [ ] ;
56150: LD_ADDR_EXP 73
56154: PUSH
56155: EMPTY
56156: ST_TO_ADDR
// mc_minefields := [ ] ;
56157: LD_ADDR_EXP 75
56161: PUSH
56162: EMPTY
56163: ST_TO_ADDR
// mc_crates := [ ] ;
56164: LD_ADDR_EXP 76
56168: PUSH
56169: EMPTY
56170: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56171: LD_ADDR_EXP 77
56175: PUSH
56176: EMPTY
56177: ST_TO_ADDR
// mc_crates_area := [ ] ;
56178: LD_ADDR_EXP 78
56182: PUSH
56183: EMPTY
56184: ST_TO_ADDR
// mc_vehicles := [ ] ;
56185: LD_ADDR_EXP 79
56189: PUSH
56190: EMPTY
56191: ST_TO_ADDR
// mc_attack := [ ] ;
56192: LD_ADDR_EXP 80
56196: PUSH
56197: EMPTY
56198: ST_TO_ADDR
// mc_produce := [ ] ;
56199: LD_ADDR_EXP 81
56203: PUSH
56204: EMPTY
56205: ST_TO_ADDR
// mc_defender := [ ] ;
56206: LD_ADDR_EXP 82
56210: PUSH
56211: EMPTY
56212: ST_TO_ADDR
// mc_parking := [ ] ;
56213: LD_ADDR_EXP 84
56217: PUSH
56218: EMPTY
56219: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56220: LD_ADDR_EXP 70
56224: PUSH
56225: EMPTY
56226: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56227: LD_ADDR_EXP 72
56231: PUSH
56232: EMPTY
56233: ST_TO_ADDR
// mc_scan := [ ] ;
56234: LD_ADDR_EXP 83
56238: PUSH
56239: EMPTY
56240: ST_TO_ADDR
// mc_scan_area := [ ] ;
56241: LD_ADDR_EXP 85
56245: PUSH
56246: EMPTY
56247: ST_TO_ADDR
// mc_tech := [ ] ;
56248: LD_ADDR_EXP 87
56252: PUSH
56253: EMPTY
56254: ST_TO_ADDR
// mc_class := [ ] ;
56255: LD_ADDR_EXP 101
56259: PUSH
56260: EMPTY
56261: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56262: LD_ADDR_EXP 102
56266: PUSH
56267: EMPTY
56268: ST_TO_ADDR
// mc_is_defending := [ ] ;
56269: LD_ADDR_EXP 103
56273: PUSH
56274: EMPTY
56275: ST_TO_ADDR
// end ;
56276: LD_VAR 0 1
56280: RET
// export function MC_Kill ( base ) ; begin
56281: LD_INT 0
56283: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56284: LD_ADDR_EXP 60
56288: PUSH
56289: LD_EXP 60
56293: PPUSH
56294: LD_VAR 0 1
56298: PPUSH
56299: EMPTY
56300: PPUSH
56301: CALL_OW 1
56305: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56306: LD_ADDR_EXP 61
56310: PUSH
56311: LD_EXP 61
56315: PPUSH
56316: LD_VAR 0 1
56320: PPUSH
56321: EMPTY
56322: PPUSH
56323: CALL_OW 1
56327: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56328: LD_ADDR_EXP 62
56332: PUSH
56333: LD_EXP 62
56337: PPUSH
56338: LD_VAR 0 1
56342: PPUSH
56343: EMPTY
56344: PPUSH
56345: CALL_OW 1
56349: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56350: LD_ADDR_EXP 63
56354: PUSH
56355: LD_EXP 63
56359: PPUSH
56360: LD_VAR 0 1
56364: PPUSH
56365: EMPTY
56366: PPUSH
56367: CALL_OW 1
56371: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56372: LD_ADDR_EXP 64
56376: PUSH
56377: LD_EXP 64
56381: PPUSH
56382: LD_VAR 0 1
56386: PPUSH
56387: EMPTY
56388: PPUSH
56389: CALL_OW 1
56393: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56394: LD_ADDR_EXP 65
56398: PUSH
56399: LD_EXP 65
56403: PPUSH
56404: LD_VAR 0 1
56408: PPUSH
56409: EMPTY
56410: PPUSH
56411: CALL_OW 1
56415: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56416: LD_ADDR_EXP 66
56420: PUSH
56421: LD_EXP 66
56425: PPUSH
56426: LD_VAR 0 1
56430: PPUSH
56431: EMPTY
56432: PPUSH
56433: CALL_OW 1
56437: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56438: LD_ADDR_EXP 67
56442: PUSH
56443: LD_EXP 67
56447: PPUSH
56448: LD_VAR 0 1
56452: PPUSH
56453: EMPTY
56454: PPUSH
56455: CALL_OW 1
56459: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56460: LD_ADDR_EXP 68
56464: PUSH
56465: LD_EXP 68
56469: PPUSH
56470: LD_VAR 0 1
56474: PPUSH
56475: EMPTY
56476: PPUSH
56477: CALL_OW 1
56481: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56482: LD_ADDR_EXP 69
56486: PUSH
56487: LD_EXP 69
56491: PPUSH
56492: LD_VAR 0 1
56496: PPUSH
56497: EMPTY
56498: PPUSH
56499: CALL_OW 1
56503: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56504: LD_ADDR_EXP 70
56508: PUSH
56509: LD_EXP 70
56513: PPUSH
56514: LD_VAR 0 1
56518: PPUSH
56519: EMPTY
56520: PPUSH
56521: CALL_OW 1
56525: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56526: LD_ADDR_EXP 71
56530: PUSH
56531: LD_EXP 71
56535: PPUSH
56536: LD_VAR 0 1
56540: PPUSH
56541: LD_INT 0
56543: PPUSH
56544: CALL_OW 1
56548: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56549: LD_ADDR_EXP 72
56553: PUSH
56554: LD_EXP 72
56558: PPUSH
56559: LD_VAR 0 1
56563: PPUSH
56564: EMPTY
56565: PPUSH
56566: CALL_OW 1
56570: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56571: LD_ADDR_EXP 73
56575: PUSH
56576: LD_EXP 73
56580: PPUSH
56581: LD_VAR 0 1
56585: PPUSH
56586: EMPTY
56587: PPUSH
56588: CALL_OW 1
56592: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56593: LD_ADDR_EXP 74
56597: PUSH
56598: LD_EXP 74
56602: PPUSH
56603: LD_VAR 0 1
56607: PPUSH
56608: EMPTY
56609: PPUSH
56610: CALL_OW 1
56614: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56615: LD_ADDR_EXP 75
56619: PUSH
56620: LD_EXP 75
56624: PPUSH
56625: LD_VAR 0 1
56629: PPUSH
56630: EMPTY
56631: PPUSH
56632: CALL_OW 1
56636: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56637: LD_ADDR_EXP 76
56641: PUSH
56642: LD_EXP 76
56646: PPUSH
56647: LD_VAR 0 1
56651: PPUSH
56652: EMPTY
56653: PPUSH
56654: CALL_OW 1
56658: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56659: LD_ADDR_EXP 77
56663: PUSH
56664: LD_EXP 77
56668: PPUSH
56669: LD_VAR 0 1
56673: PPUSH
56674: EMPTY
56675: PPUSH
56676: CALL_OW 1
56680: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56681: LD_ADDR_EXP 78
56685: PUSH
56686: LD_EXP 78
56690: PPUSH
56691: LD_VAR 0 1
56695: PPUSH
56696: EMPTY
56697: PPUSH
56698: CALL_OW 1
56702: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56703: LD_ADDR_EXP 79
56707: PUSH
56708: LD_EXP 79
56712: PPUSH
56713: LD_VAR 0 1
56717: PPUSH
56718: EMPTY
56719: PPUSH
56720: CALL_OW 1
56724: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56725: LD_ADDR_EXP 80
56729: PUSH
56730: LD_EXP 80
56734: PPUSH
56735: LD_VAR 0 1
56739: PPUSH
56740: EMPTY
56741: PPUSH
56742: CALL_OW 1
56746: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56747: LD_ADDR_EXP 81
56751: PUSH
56752: LD_EXP 81
56756: PPUSH
56757: LD_VAR 0 1
56761: PPUSH
56762: EMPTY
56763: PPUSH
56764: CALL_OW 1
56768: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56769: LD_ADDR_EXP 82
56773: PUSH
56774: LD_EXP 82
56778: PPUSH
56779: LD_VAR 0 1
56783: PPUSH
56784: EMPTY
56785: PPUSH
56786: CALL_OW 1
56790: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56791: LD_ADDR_EXP 83
56795: PUSH
56796: LD_EXP 83
56800: PPUSH
56801: LD_VAR 0 1
56805: PPUSH
56806: EMPTY
56807: PPUSH
56808: CALL_OW 1
56812: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56813: LD_ADDR_EXP 84
56817: PUSH
56818: LD_EXP 84
56822: PPUSH
56823: LD_VAR 0 1
56827: PPUSH
56828: EMPTY
56829: PPUSH
56830: CALL_OW 1
56834: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56835: LD_ADDR_EXP 85
56839: PUSH
56840: LD_EXP 85
56844: PPUSH
56845: LD_VAR 0 1
56849: PPUSH
56850: EMPTY
56851: PPUSH
56852: CALL_OW 1
56856: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56857: LD_ADDR_EXP 87
56861: PUSH
56862: LD_EXP 87
56866: PPUSH
56867: LD_VAR 0 1
56871: PPUSH
56872: EMPTY
56873: PPUSH
56874: CALL_OW 1
56878: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56879: LD_ADDR_EXP 89
56883: PUSH
56884: LD_EXP 89
56888: PPUSH
56889: LD_VAR 0 1
56893: PPUSH
56894: EMPTY
56895: PPUSH
56896: CALL_OW 1
56900: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56901: LD_ADDR_EXP 90
56905: PUSH
56906: LD_EXP 90
56910: PPUSH
56911: LD_VAR 0 1
56915: PPUSH
56916: EMPTY
56917: PPUSH
56918: CALL_OW 1
56922: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56923: LD_ADDR_EXP 91
56927: PUSH
56928: LD_EXP 91
56932: PPUSH
56933: LD_VAR 0 1
56937: PPUSH
56938: EMPTY
56939: PPUSH
56940: CALL_OW 1
56944: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56945: LD_ADDR_EXP 92
56949: PUSH
56950: LD_EXP 92
56954: PPUSH
56955: LD_VAR 0 1
56959: PPUSH
56960: EMPTY
56961: PPUSH
56962: CALL_OW 1
56966: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56967: LD_ADDR_EXP 93
56971: PUSH
56972: LD_EXP 93
56976: PPUSH
56977: LD_VAR 0 1
56981: PPUSH
56982: EMPTY
56983: PPUSH
56984: CALL_OW 1
56988: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56989: LD_ADDR_EXP 94
56993: PUSH
56994: LD_EXP 94
56998: PPUSH
56999: LD_VAR 0 1
57003: PPUSH
57004: EMPTY
57005: PPUSH
57006: CALL_OW 1
57010: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57011: LD_ADDR_EXP 95
57015: PUSH
57016: LD_EXP 95
57020: PPUSH
57021: LD_VAR 0 1
57025: PPUSH
57026: EMPTY
57027: PPUSH
57028: CALL_OW 1
57032: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57033: LD_ADDR_EXP 96
57037: PUSH
57038: LD_EXP 96
57042: PPUSH
57043: LD_VAR 0 1
57047: PPUSH
57048: EMPTY
57049: PPUSH
57050: CALL_OW 1
57054: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57055: LD_ADDR_EXP 97
57059: PUSH
57060: LD_EXP 97
57064: PPUSH
57065: LD_VAR 0 1
57069: PPUSH
57070: EMPTY
57071: PPUSH
57072: CALL_OW 1
57076: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57077: LD_ADDR_EXP 98
57081: PUSH
57082: LD_EXP 98
57086: PPUSH
57087: LD_VAR 0 1
57091: PPUSH
57092: EMPTY
57093: PPUSH
57094: CALL_OW 1
57098: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57099: LD_ADDR_EXP 99
57103: PUSH
57104: LD_EXP 99
57108: PPUSH
57109: LD_VAR 0 1
57113: PPUSH
57114: EMPTY
57115: PPUSH
57116: CALL_OW 1
57120: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57121: LD_ADDR_EXP 100
57125: PUSH
57126: LD_EXP 100
57130: PPUSH
57131: LD_VAR 0 1
57135: PPUSH
57136: EMPTY
57137: PPUSH
57138: CALL_OW 1
57142: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57143: LD_ADDR_EXP 101
57147: PUSH
57148: LD_EXP 101
57152: PPUSH
57153: LD_VAR 0 1
57157: PPUSH
57158: EMPTY
57159: PPUSH
57160: CALL_OW 1
57164: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57165: LD_ADDR_EXP 102
57169: PUSH
57170: LD_EXP 102
57174: PPUSH
57175: LD_VAR 0 1
57179: PPUSH
57180: LD_INT 0
57182: PPUSH
57183: CALL_OW 1
57187: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
57188: LD_ADDR_EXP 103
57192: PUSH
57193: LD_EXP 103
57197: PPUSH
57198: LD_VAR 0 1
57202: PPUSH
57203: LD_INT 0
57205: PPUSH
57206: CALL_OW 1
57210: ST_TO_ADDR
// end ;
57211: LD_VAR 0 2
57215: RET
// export function MC_Add ( side , units ) ; var base ; begin
57216: LD_INT 0
57218: PPUSH
57219: PPUSH
// base := mc_bases + 1 ;
57220: LD_ADDR_VAR 0 4
57224: PUSH
57225: LD_EXP 60
57229: PUSH
57230: LD_INT 1
57232: PLUS
57233: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
57234: LD_ADDR_EXP 86
57238: PUSH
57239: LD_EXP 86
57243: PPUSH
57244: LD_VAR 0 4
57248: PPUSH
57249: LD_VAR 0 1
57253: PPUSH
57254: CALL_OW 1
57258: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
57259: LD_ADDR_EXP 60
57263: PUSH
57264: LD_EXP 60
57268: PPUSH
57269: LD_VAR 0 4
57273: PPUSH
57274: LD_VAR 0 2
57278: PPUSH
57279: CALL_OW 1
57283: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57284: LD_ADDR_EXP 61
57288: PUSH
57289: LD_EXP 61
57293: PPUSH
57294: LD_VAR 0 4
57298: PPUSH
57299: EMPTY
57300: PPUSH
57301: CALL_OW 1
57305: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57306: LD_ADDR_EXP 62
57310: PUSH
57311: LD_EXP 62
57315: PPUSH
57316: LD_VAR 0 4
57320: PPUSH
57321: EMPTY
57322: PPUSH
57323: CALL_OW 1
57327: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57328: LD_ADDR_EXP 63
57332: PUSH
57333: LD_EXP 63
57337: PPUSH
57338: LD_VAR 0 4
57342: PPUSH
57343: EMPTY
57344: PPUSH
57345: CALL_OW 1
57349: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57350: LD_ADDR_EXP 64
57354: PUSH
57355: LD_EXP 64
57359: PPUSH
57360: LD_VAR 0 4
57364: PPUSH
57365: EMPTY
57366: PPUSH
57367: CALL_OW 1
57371: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57372: LD_ADDR_EXP 65
57376: PUSH
57377: LD_EXP 65
57381: PPUSH
57382: LD_VAR 0 4
57386: PPUSH
57387: EMPTY
57388: PPUSH
57389: CALL_OW 1
57393: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57394: LD_ADDR_EXP 66
57398: PUSH
57399: LD_EXP 66
57403: PPUSH
57404: LD_VAR 0 4
57408: PPUSH
57409: EMPTY
57410: PPUSH
57411: CALL_OW 1
57415: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57416: LD_ADDR_EXP 67
57420: PUSH
57421: LD_EXP 67
57425: PPUSH
57426: LD_VAR 0 4
57430: PPUSH
57431: EMPTY
57432: PPUSH
57433: CALL_OW 1
57437: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57438: LD_ADDR_EXP 68
57442: PUSH
57443: LD_EXP 68
57447: PPUSH
57448: LD_VAR 0 4
57452: PPUSH
57453: EMPTY
57454: PPUSH
57455: CALL_OW 1
57459: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57460: LD_ADDR_EXP 69
57464: PUSH
57465: LD_EXP 69
57469: PPUSH
57470: LD_VAR 0 4
57474: PPUSH
57475: EMPTY
57476: PPUSH
57477: CALL_OW 1
57481: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57482: LD_ADDR_EXP 70
57486: PUSH
57487: LD_EXP 70
57491: PPUSH
57492: LD_VAR 0 4
57496: PPUSH
57497: EMPTY
57498: PPUSH
57499: CALL_OW 1
57503: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57504: LD_ADDR_EXP 71
57508: PUSH
57509: LD_EXP 71
57513: PPUSH
57514: LD_VAR 0 4
57518: PPUSH
57519: LD_INT 0
57521: PPUSH
57522: CALL_OW 1
57526: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57527: LD_ADDR_EXP 72
57531: PUSH
57532: LD_EXP 72
57536: PPUSH
57537: LD_VAR 0 4
57541: PPUSH
57542: EMPTY
57543: PPUSH
57544: CALL_OW 1
57548: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57549: LD_ADDR_EXP 73
57553: PUSH
57554: LD_EXP 73
57558: PPUSH
57559: LD_VAR 0 4
57563: PPUSH
57564: EMPTY
57565: PPUSH
57566: CALL_OW 1
57570: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57571: LD_ADDR_EXP 74
57575: PUSH
57576: LD_EXP 74
57580: PPUSH
57581: LD_VAR 0 4
57585: PPUSH
57586: EMPTY
57587: PPUSH
57588: CALL_OW 1
57592: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57593: LD_ADDR_EXP 75
57597: PUSH
57598: LD_EXP 75
57602: PPUSH
57603: LD_VAR 0 4
57607: PPUSH
57608: EMPTY
57609: PPUSH
57610: CALL_OW 1
57614: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57615: LD_ADDR_EXP 76
57619: PUSH
57620: LD_EXP 76
57624: PPUSH
57625: LD_VAR 0 4
57629: PPUSH
57630: EMPTY
57631: PPUSH
57632: CALL_OW 1
57636: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57637: LD_ADDR_EXP 77
57641: PUSH
57642: LD_EXP 77
57646: PPUSH
57647: LD_VAR 0 4
57651: PPUSH
57652: EMPTY
57653: PPUSH
57654: CALL_OW 1
57658: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57659: LD_ADDR_EXP 78
57663: PUSH
57664: LD_EXP 78
57668: PPUSH
57669: LD_VAR 0 4
57673: PPUSH
57674: EMPTY
57675: PPUSH
57676: CALL_OW 1
57680: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57681: LD_ADDR_EXP 79
57685: PUSH
57686: LD_EXP 79
57690: PPUSH
57691: LD_VAR 0 4
57695: PPUSH
57696: EMPTY
57697: PPUSH
57698: CALL_OW 1
57702: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57703: LD_ADDR_EXP 80
57707: PUSH
57708: LD_EXP 80
57712: PPUSH
57713: LD_VAR 0 4
57717: PPUSH
57718: EMPTY
57719: PPUSH
57720: CALL_OW 1
57724: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57725: LD_ADDR_EXP 81
57729: PUSH
57730: LD_EXP 81
57734: PPUSH
57735: LD_VAR 0 4
57739: PPUSH
57740: EMPTY
57741: PPUSH
57742: CALL_OW 1
57746: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57747: LD_ADDR_EXP 82
57751: PUSH
57752: LD_EXP 82
57756: PPUSH
57757: LD_VAR 0 4
57761: PPUSH
57762: EMPTY
57763: PPUSH
57764: CALL_OW 1
57768: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57769: LD_ADDR_EXP 83
57773: PUSH
57774: LD_EXP 83
57778: PPUSH
57779: LD_VAR 0 4
57783: PPUSH
57784: EMPTY
57785: PPUSH
57786: CALL_OW 1
57790: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57791: LD_ADDR_EXP 84
57795: PUSH
57796: LD_EXP 84
57800: PPUSH
57801: LD_VAR 0 4
57805: PPUSH
57806: EMPTY
57807: PPUSH
57808: CALL_OW 1
57812: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57813: LD_ADDR_EXP 85
57817: PUSH
57818: LD_EXP 85
57822: PPUSH
57823: LD_VAR 0 4
57827: PPUSH
57828: EMPTY
57829: PPUSH
57830: CALL_OW 1
57834: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57835: LD_ADDR_EXP 87
57839: PUSH
57840: LD_EXP 87
57844: PPUSH
57845: LD_VAR 0 4
57849: PPUSH
57850: EMPTY
57851: PPUSH
57852: CALL_OW 1
57856: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57857: LD_ADDR_EXP 89
57861: PUSH
57862: LD_EXP 89
57866: PPUSH
57867: LD_VAR 0 4
57871: PPUSH
57872: EMPTY
57873: PPUSH
57874: CALL_OW 1
57878: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57879: LD_ADDR_EXP 90
57883: PUSH
57884: LD_EXP 90
57888: PPUSH
57889: LD_VAR 0 4
57893: PPUSH
57894: EMPTY
57895: PPUSH
57896: CALL_OW 1
57900: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57901: LD_ADDR_EXP 91
57905: PUSH
57906: LD_EXP 91
57910: PPUSH
57911: LD_VAR 0 4
57915: PPUSH
57916: EMPTY
57917: PPUSH
57918: CALL_OW 1
57922: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57923: LD_ADDR_EXP 92
57927: PUSH
57928: LD_EXP 92
57932: PPUSH
57933: LD_VAR 0 4
57937: PPUSH
57938: EMPTY
57939: PPUSH
57940: CALL_OW 1
57944: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57945: LD_ADDR_EXP 93
57949: PUSH
57950: LD_EXP 93
57954: PPUSH
57955: LD_VAR 0 4
57959: PPUSH
57960: EMPTY
57961: PPUSH
57962: CALL_OW 1
57966: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57967: LD_ADDR_EXP 94
57971: PUSH
57972: LD_EXP 94
57976: PPUSH
57977: LD_VAR 0 4
57981: PPUSH
57982: EMPTY
57983: PPUSH
57984: CALL_OW 1
57988: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57989: LD_ADDR_EXP 95
57993: PUSH
57994: LD_EXP 95
57998: PPUSH
57999: LD_VAR 0 4
58003: PPUSH
58004: EMPTY
58005: PPUSH
58006: CALL_OW 1
58010: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58011: LD_ADDR_EXP 96
58015: PUSH
58016: LD_EXP 96
58020: PPUSH
58021: LD_VAR 0 4
58025: PPUSH
58026: EMPTY
58027: PPUSH
58028: CALL_OW 1
58032: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58033: LD_ADDR_EXP 97
58037: PUSH
58038: LD_EXP 97
58042: PPUSH
58043: LD_VAR 0 4
58047: PPUSH
58048: EMPTY
58049: PPUSH
58050: CALL_OW 1
58054: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58055: LD_ADDR_EXP 98
58059: PUSH
58060: LD_EXP 98
58064: PPUSH
58065: LD_VAR 0 4
58069: PPUSH
58070: EMPTY
58071: PPUSH
58072: CALL_OW 1
58076: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58077: LD_ADDR_EXP 99
58081: PUSH
58082: LD_EXP 99
58086: PPUSH
58087: LD_VAR 0 4
58091: PPUSH
58092: EMPTY
58093: PPUSH
58094: CALL_OW 1
58098: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58099: LD_ADDR_EXP 100
58103: PUSH
58104: LD_EXP 100
58108: PPUSH
58109: LD_VAR 0 4
58113: PPUSH
58114: EMPTY
58115: PPUSH
58116: CALL_OW 1
58120: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58121: LD_ADDR_EXP 101
58125: PUSH
58126: LD_EXP 101
58130: PPUSH
58131: LD_VAR 0 4
58135: PPUSH
58136: EMPTY
58137: PPUSH
58138: CALL_OW 1
58142: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58143: LD_ADDR_EXP 102
58147: PUSH
58148: LD_EXP 102
58152: PPUSH
58153: LD_VAR 0 4
58157: PPUSH
58158: LD_INT 0
58160: PPUSH
58161: CALL_OW 1
58165: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
58166: LD_ADDR_EXP 103
58170: PUSH
58171: LD_EXP 103
58175: PPUSH
58176: LD_VAR 0 4
58180: PPUSH
58181: LD_INT 0
58183: PPUSH
58184: CALL_OW 1
58188: ST_TO_ADDR
// result := base ;
58189: LD_ADDR_VAR 0 3
58193: PUSH
58194: LD_VAR 0 4
58198: ST_TO_ADDR
// end ;
58199: LD_VAR 0 3
58203: RET
// export function MC_Start ( ) ; var i ; begin
58204: LD_INT 0
58206: PPUSH
58207: PPUSH
// for i = 1 to mc_bases do
58208: LD_ADDR_VAR 0 2
58212: PUSH
58213: DOUBLE
58214: LD_INT 1
58216: DEC
58217: ST_TO_ADDR
58218: LD_EXP 60
58222: PUSH
58223: FOR_TO
58224: IFFALSE 59324
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
58226: LD_ADDR_EXP 60
58230: PUSH
58231: LD_EXP 60
58235: PPUSH
58236: LD_VAR 0 2
58240: PPUSH
58241: LD_EXP 60
58245: PUSH
58246: LD_VAR 0 2
58250: ARRAY
58251: PUSH
58252: LD_INT 0
58254: DIFF
58255: PPUSH
58256: CALL_OW 1
58260: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
58261: LD_ADDR_EXP 61
58265: PUSH
58266: LD_EXP 61
58270: PPUSH
58271: LD_VAR 0 2
58275: PPUSH
58276: EMPTY
58277: PPUSH
58278: CALL_OW 1
58282: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
58283: LD_ADDR_EXP 62
58287: PUSH
58288: LD_EXP 62
58292: PPUSH
58293: LD_VAR 0 2
58297: PPUSH
58298: EMPTY
58299: PPUSH
58300: CALL_OW 1
58304: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
58305: LD_ADDR_EXP 63
58309: PUSH
58310: LD_EXP 63
58314: PPUSH
58315: LD_VAR 0 2
58319: PPUSH
58320: EMPTY
58321: PPUSH
58322: CALL_OW 1
58326: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
58327: LD_ADDR_EXP 64
58331: PUSH
58332: LD_EXP 64
58336: PPUSH
58337: LD_VAR 0 2
58341: PPUSH
58342: EMPTY
58343: PUSH
58344: EMPTY
58345: PUSH
58346: EMPTY
58347: LIST
58348: LIST
58349: PPUSH
58350: CALL_OW 1
58354: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
58355: LD_ADDR_EXP 65
58359: PUSH
58360: LD_EXP 65
58364: PPUSH
58365: LD_VAR 0 2
58369: PPUSH
58370: EMPTY
58371: PPUSH
58372: CALL_OW 1
58376: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
58377: LD_ADDR_EXP 92
58381: PUSH
58382: LD_EXP 92
58386: PPUSH
58387: LD_VAR 0 2
58391: PPUSH
58392: EMPTY
58393: PPUSH
58394: CALL_OW 1
58398: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
58399: LD_ADDR_EXP 66
58403: PUSH
58404: LD_EXP 66
58408: PPUSH
58409: LD_VAR 0 2
58413: PPUSH
58414: EMPTY
58415: PPUSH
58416: CALL_OW 1
58420: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
58421: LD_ADDR_EXP 67
58425: PUSH
58426: LD_EXP 67
58430: PPUSH
58431: LD_VAR 0 2
58435: PPUSH
58436: EMPTY
58437: PPUSH
58438: CALL_OW 1
58442: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
58443: LD_ADDR_EXP 68
58447: PUSH
58448: LD_EXP 68
58452: PPUSH
58453: LD_VAR 0 2
58457: PPUSH
58458: LD_EXP 60
58462: PUSH
58463: LD_VAR 0 2
58467: ARRAY
58468: PPUSH
58469: LD_INT 2
58471: PUSH
58472: LD_INT 30
58474: PUSH
58475: LD_INT 32
58477: PUSH
58478: EMPTY
58479: LIST
58480: LIST
58481: PUSH
58482: LD_INT 30
58484: PUSH
58485: LD_INT 33
58487: PUSH
58488: EMPTY
58489: LIST
58490: LIST
58491: PUSH
58492: EMPTY
58493: LIST
58494: LIST
58495: LIST
58496: PPUSH
58497: CALL_OW 72
58501: PPUSH
58502: CALL_OW 1
58506: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
58507: LD_ADDR_EXP 69
58511: PUSH
58512: LD_EXP 69
58516: PPUSH
58517: LD_VAR 0 2
58521: PPUSH
58522: LD_EXP 60
58526: PUSH
58527: LD_VAR 0 2
58531: ARRAY
58532: PPUSH
58533: LD_INT 2
58535: PUSH
58536: LD_INT 30
58538: PUSH
58539: LD_INT 32
58541: PUSH
58542: EMPTY
58543: LIST
58544: LIST
58545: PUSH
58546: LD_INT 30
58548: PUSH
58549: LD_INT 31
58551: PUSH
58552: EMPTY
58553: LIST
58554: LIST
58555: PUSH
58556: EMPTY
58557: LIST
58558: LIST
58559: LIST
58560: PUSH
58561: LD_INT 58
58563: PUSH
58564: EMPTY
58565: LIST
58566: PUSH
58567: EMPTY
58568: LIST
58569: LIST
58570: PPUSH
58571: CALL_OW 72
58575: PPUSH
58576: CALL_OW 1
58580: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
58581: LD_ADDR_EXP 70
58585: PUSH
58586: LD_EXP 70
58590: PPUSH
58591: LD_VAR 0 2
58595: PPUSH
58596: EMPTY
58597: PPUSH
58598: CALL_OW 1
58602: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
58603: LD_ADDR_EXP 74
58607: PUSH
58608: LD_EXP 74
58612: PPUSH
58613: LD_VAR 0 2
58617: PPUSH
58618: EMPTY
58619: PPUSH
58620: CALL_OW 1
58624: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
58625: LD_ADDR_EXP 73
58629: PUSH
58630: LD_EXP 73
58634: PPUSH
58635: LD_VAR 0 2
58639: PPUSH
58640: EMPTY
58641: PPUSH
58642: CALL_OW 1
58646: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
58647: LD_ADDR_EXP 75
58651: PUSH
58652: LD_EXP 75
58656: PPUSH
58657: LD_VAR 0 2
58661: PPUSH
58662: EMPTY
58663: PPUSH
58664: CALL_OW 1
58668: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
58669: LD_ADDR_EXP 76
58673: PUSH
58674: LD_EXP 76
58678: PPUSH
58679: LD_VAR 0 2
58683: PPUSH
58684: EMPTY
58685: PPUSH
58686: CALL_OW 1
58690: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
58691: LD_ADDR_EXP 77
58695: PUSH
58696: LD_EXP 77
58700: PPUSH
58701: LD_VAR 0 2
58705: PPUSH
58706: EMPTY
58707: PPUSH
58708: CALL_OW 1
58712: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
58713: LD_ADDR_EXP 78
58717: PUSH
58718: LD_EXP 78
58722: PPUSH
58723: LD_VAR 0 2
58727: PPUSH
58728: EMPTY
58729: PPUSH
58730: CALL_OW 1
58734: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
58735: LD_ADDR_EXP 79
58739: PUSH
58740: LD_EXP 79
58744: PPUSH
58745: LD_VAR 0 2
58749: PPUSH
58750: EMPTY
58751: PPUSH
58752: CALL_OW 1
58756: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
58757: LD_ADDR_EXP 80
58761: PUSH
58762: LD_EXP 80
58766: PPUSH
58767: LD_VAR 0 2
58771: PPUSH
58772: EMPTY
58773: PPUSH
58774: CALL_OW 1
58778: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
58779: LD_ADDR_EXP 81
58783: PUSH
58784: LD_EXP 81
58788: PPUSH
58789: LD_VAR 0 2
58793: PPUSH
58794: EMPTY
58795: PPUSH
58796: CALL_OW 1
58800: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
58801: LD_ADDR_EXP 82
58805: PUSH
58806: LD_EXP 82
58810: PPUSH
58811: LD_VAR 0 2
58815: PPUSH
58816: EMPTY
58817: PPUSH
58818: CALL_OW 1
58822: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
58823: LD_ADDR_EXP 71
58827: PUSH
58828: LD_EXP 71
58832: PPUSH
58833: LD_VAR 0 2
58837: PPUSH
58838: LD_INT 0
58840: PPUSH
58841: CALL_OW 1
58845: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
58846: LD_ADDR_EXP 84
58850: PUSH
58851: LD_EXP 84
58855: PPUSH
58856: LD_VAR 0 2
58860: PPUSH
58861: LD_INT 0
58863: PPUSH
58864: CALL_OW 1
58868: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
58869: LD_ADDR_EXP 72
58873: PUSH
58874: LD_EXP 72
58878: PPUSH
58879: LD_VAR 0 2
58883: PPUSH
58884: EMPTY
58885: PPUSH
58886: CALL_OW 1
58890: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
58891: LD_ADDR_EXP 83
58895: PUSH
58896: LD_EXP 83
58900: PPUSH
58901: LD_VAR 0 2
58905: PPUSH
58906: LD_INT 0
58908: PPUSH
58909: CALL_OW 1
58913: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
58914: LD_ADDR_EXP 85
58918: PUSH
58919: LD_EXP 85
58923: PPUSH
58924: LD_VAR 0 2
58928: PPUSH
58929: EMPTY
58930: PPUSH
58931: CALL_OW 1
58935: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
58936: LD_ADDR_EXP 88
58940: PUSH
58941: LD_EXP 88
58945: PPUSH
58946: LD_VAR 0 2
58950: PPUSH
58951: LD_INT 0
58953: PPUSH
58954: CALL_OW 1
58958: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
58959: LD_ADDR_EXP 89
58963: PUSH
58964: LD_EXP 89
58968: PPUSH
58969: LD_VAR 0 2
58973: PPUSH
58974: EMPTY
58975: PPUSH
58976: CALL_OW 1
58980: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
58981: LD_ADDR_EXP 90
58985: PUSH
58986: LD_EXP 90
58990: PPUSH
58991: LD_VAR 0 2
58995: PPUSH
58996: EMPTY
58997: PPUSH
58998: CALL_OW 1
59002: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59003: LD_ADDR_EXP 91
59007: PUSH
59008: LD_EXP 91
59012: PPUSH
59013: LD_VAR 0 2
59017: PPUSH
59018: EMPTY
59019: PPUSH
59020: CALL_OW 1
59024: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
59025: LD_ADDR_EXP 93
59029: PUSH
59030: LD_EXP 93
59034: PPUSH
59035: LD_VAR 0 2
59039: PPUSH
59040: LD_EXP 60
59044: PUSH
59045: LD_VAR 0 2
59049: ARRAY
59050: PPUSH
59051: LD_INT 2
59053: PUSH
59054: LD_INT 30
59056: PUSH
59057: LD_INT 6
59059: PUSH
59060: EMPTY
59061: LIST
59062: LIST
59063: PUSH
59064: LD_INT 30
59066: PUSH
59067: LD_INT 7
59069: PUSH
59070: EMPTY
59071: LIST
59072: LIST
59073: PUSH
59074: LD_INT 30
59076: PUSH
59077: LD_INT 8
59079: PUSH
59080: EMPTY
59081: LIST
59082: LIST
59083: PUSH
59084: EMPTY
59085: LIST
59086: LIST
59087: LIST
59088: LIST
59089: PPUSH
59090: CALL_OW 72
59094: PPUSH
59095: CALL_OW 1
59099: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
59100: LD_ADDR_EXP 94
59104: PUSH
59105: LD_EXP 94
59109: PPUSH
59110: LD_VAR 0 2
59114: PPUSH
59115: EMPTY
59116: PPUSH
59117: CALL_OW 1
59121: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
59122: LD_ADDR_EXP 95
59126: PUSH
59127: LD_EXP 95
59131: PPUSH
59132: LD_VAR 0 2
59136: PPUSH
59137: EMPTY
59138: PPUSH
59139: CALL_OW 1
59143: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
59144: LD_ADDR_EXP 96
59148: PUSH
59149: LD_EXP 96
59153: PPUSH
59154: LD_VAR 0 2
59158: PPUSH
59159: EMPTY
59160: PPUSH
59161: CALL_OW 1
59165: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
59166: LD_ADDR_EXP 97
59170: PUSH
59171: LD_EXP 97
59175: PPUSH
59176: LD_VAR 0 2
59180: PPUSH
59181: EMPTY
59182: PPUSH
59183: CALL_OW 1
59187: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59188: LD_ADDR_EXP 98
59192: PUSH
59193: LD_EXP 98
59197: PPUSH
59198: LD_VAR 0 2
59202: PPUSH
59203: EMPTY
59204: PPUSH
59205: CALL_OW 1
59209: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
59210: LD_ADDR_EXP 99
59214: PUSH
59215: LD_EXP 99
59219: PPUSH
59220: LD_VAR 0 2
59224: PPUSH
59225: EMPTY
59226: PPUSH
59227: CALL_OW 1
59231: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
59232: LD_ADDR_EXP 100
59236: PUSH
59237: LD_EXP 100
59241: PPUSH
59242: LD_VAR 0 2
59246: PPUSH
59247: EMPTY
59248: PPUSH
59249: CALL_OW 1
59253: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
59254: LD_ADDR_EXP 101
59258: PUSH
59259: LD_EXP 101
59263: PPUSH
59264: LD_VAR 0 2
59268: PPUSH
59269: EMPTY
59270: PPUSH
59271: CALL_OW 1
59275: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
59276: LD_ADDR_EXP 102
59280: PUSH
59281: LD_EXP 102
59285: PPUSH
59286: LD_VAR 0 2
59290: PPUSH
59291: LD_INT 0
59293: PPUSH
59294: CALL_OW 1
59298: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
59299: LD_ADDR_EXP 103
59303: PUSH
59304: LD_EXP 103
59308: PPUSH
59309: LD_VAR 0 2
59313: PPUSH
59314: LD_INT 0
59316: PPUSH
59317: CALL_OW 1
59321: ST_TO_ADDR
// end ;
59322: GO 58223
59324: POP
59325: POP
// MC_InitSides ( ) ;
59326: CALL 59612 0 0
// MC_InitResearch ( ) ;
59330: CALL 59351 0 0
// CustomInitMacro ( ) ;
59334: CALL 202 0 0
// skirmish := true ;
59338: LD_ADDR_EXP 58
59342: PUSH
59343: LD_INT 1
59345: ST_TO_ADDR
// end ;
59346: LD_VAR 0 1
59350: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
59351: LD_INT 0
59353: PPUSH
59354: PPUSH
59355: PPUSH
59356: PPUSH
59357: PPUSH
59358: PPUSH
// if not mc_bases then
59359: LD_EXP 60
59363: NOT
59364: IFFALSE 59368
// exit ;
59366: GO 59607
// for i = 1 to 8 do
59368: LD_ADDR_VAR 0 2
59372: PUSH
59373: DOUBLE
59374: LD_INT 1
59376: DEC
59377: ST_TO_ADDR
59378: LD_INT 8
59380: PUSH
59381: FOR_TO
59382: IFFALSE 59408
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
59384: LD_ADDR_EXP 87
59388: PUSH
59389: LD_EXP 87
59393: PPUSH
59394: LD_VAR 0 2
59398: PPUSH
59399: EMPTY
59400: PPUSH
59401: CALL_OW 1
59405: ST_TO_ADDR
59406: GO 59381
59408: POP
59409: POP
// tmp := [ ] ;
59410: LD_ADDR_VAR 0 5
59414: PUSH
59415: EMPTY
59416: ST_TO_ADDR
// for i = 1 to mc_sides do
59417: LD_ADDR_VAR 0 2
59421: PUSH
59422: DOUBLE
59423: LD_INT 1
59425: DEC
59426: ST_TO_ADDR
59427: LD_EXP 86
59431: PUSH
59432: FOR_TO
59433: IFFALSE 59491
// if not mc_sides [ i ] in tmp then
59435: LD_EXP 86
59439: PUSH
59440: LD_VAR 0 2
59444: ARRAY
59445: PUSH
59446: LD_VAR 0 5
59450: IN
59451: NOT
59452: IFFALSE 59489
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
59454: LD_ADDR_VAR 0 5
59458: PUSH
59459: LD_VAR 0 5
59463: PPUSH
59464: LD_VAR 0 5
59468: PUSH
59469: LD_INT 1
59471: PLUS
59472: PPUSH
59473: LD_EXP 86
59477: PUSH
59478: LD_VAR 0 2
59482: ARRAY
59483: PPUSH
59484: CALL_OW 2
59488: ST_TO_ADDR
59489: GO 59432
59491: POP
59492: POP
// if not tmp then
59493: LD_VAR 0 5
59497: NOT
59498: IFFALSE 59502
// exit ;
59500: GO 59607
// for j in tmp do
59502: LD_ADDR_VAR 0 3
59506: PUSH
59507: LD_VAR 0 5
59511: PUSH
59512: FOR_IN
59513: IFFALSE 59605
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
59515: LD_ADDR_VAR 0 6
59519: PUSH
59520: LD_INT 22
59522: PUSH
59523: LD_VAR 0 3
59527: PUSH
59528: EMPTY
59529: LIST
59530: LIST
59531: PPUSH
59532: CALL_OW 69
59536: ST_TO_ADDR
// if not un then
59537: LD_VAR 0 6
59541: NOT
59542: IFFALSE 59546
// continue ;
59544: GO 59512
// nation := GetNation ( un [ 1 ] ) ;
59546: LD_ADDR_VAR 0 4
59550: PUSH
59551: LD_VAR 0 6
59555: PUSH
59556: LD_INT 1
59558: ARRAY
59559: PPUSH
59560: CALL_OW 248
59564: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
59565: LD_ADDR_EXP 87
59569: PUSH
59570: LD_EXP 87
59574: PPUSH
59575: LD_VAR 0 3
59579: PPUSH
59580: LD_VAR 0 3
59584: PPUSH
59585: LD_VAR 0 4
59589: PPUSH
59590: LD_INT 1
59592: PPUSH
59593: CALL 14917 0 3
59597: PPUSH
59598: CALL_OW 1
59602: ST_TO_ADDR
// end ;
59603: GO 59512
59605: POP
59606: POP
// end ;
59607: LD_VAR 0 1
59611: RET
// export function MC_InitSides ( ) ; var i ; begin
59612: LD_INT 0
59614: PPUSH
59615: PPUSH
// if not mc_bases then
59616: LD_EXP 60
59620: NOT
59621: IFFALSE 59625
// exit ;
59623: GO 59699
// for i = 1 to mc_bases do
59625: LD_ADDR_VAR 0 2
59629: PUSH
59630: DOUBLE
59631: LD_INT 1
59633: DEC
59634: ST_TO_ADDR
59635: LD_EXP 60
59639: PUSH
59640: FOR_TO
59641: IFFALSE 59697
// if mc_bases [ i ] then
59643: LD_EXP 60
59647: PUSH
59648: LD_VAR 0 2
59652: ARRAY
59653: IFFALSE 59695
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
59655: LD_ADDR_EXP 86
59659: PUSH
59660: LD_EXP 86
59664: PPUSH
59665: LD_VAR 0 2
59669: PPUSH
59670: LD_EXP 60
59674: PUSH
59675: LD_VAR 0 2
59679: ARRAY
59680: PUSH
59681: LD_INT 1
59683: ARRAY
59684: PPUSH
59685: CALL_OW 255
59689: PPUSH
59690: CALL_OW 1
59694: ST_TO_ADDR
59695: GO 59640
59697: POP
59698: POP
// end ;
59699: LD_VAR 0 1
59703: RET
// every 0 0$03 trigger skirmish do
59704: LD_EXP 58
59708: IFFALSE 59862
59710: GO 59712
59712: DISABLE
// begin enable ;
59713: ENABLE
// MC_CheckBuildings ( ) ;
59714: CALL 64360 0 0
// MC_CheckPeopleLife ( ) ;
59718: CALL 64521 0 0
// RaiseSailEvent ( 100 ) ;
59722: LD_INT 100
59724: PPUSH
59725: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
59729: LD_INT 103
59731: PPUSH
59732: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
59736: LD_INT 104
59738: PPUSH
59739: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
59743: LD_INT 105
59745: PPUSH
59746: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
59750: LD_INT 106
59752: PPUSH
59753: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
59757: LD_INT 107
59759: PPUSH
59760: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
59764: LD_INT 108
59766: PPUSH
59767: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
59771: LD_INT 109
59773: PPUSH
59774: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
59778: LD_INT 110
59780: PPUSH
59781: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
59785: LD_INT 111
59787: PPUSH
59788: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
59792: LD_INT 112
59794: PPUSH
59795: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
59799: LD_INT 113
59801: PPUSH
59802: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
59806: LD_INT 120
59808: PPUSH
59809: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
59813: LD_INT 121
59815: PPUSH
59816: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
59820: LD_INT 122
59822: PPUSH
59823: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
59827: LD_INT 123
59829: PPUSH
59830: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
59834: LD_INT 124
59836: PPUSH
59837: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
59841: LD_INT 125
59843: PPUSH
59844: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
59848: LD_INT 126
59850: PPUSH
59851: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
59855: LD_INT 200
59857: PPUSH
59858: CALL_OW 427
// end ;
59862: END
// on SailEvent ( event ) do begin if event < 100 then
59863: LD_VAR 0 1
59867: PUSH
59868: LD_INT 100
59870: LESS
59871: IFFALSE 59882
// CustomEvent ( event ) ;
59873: LD_VAR 0 1
59877: PPUSH
59878: CALL 13532 0 1
// if event = 100 then
59882: LD_VAR 0 1
59886: PUSH
59887: LD_INT 100
59889: EQUAL
59890: IFFALSE 59896
// MC_ClassManager ( ) ;
59892: CALL 60288 0 0
// if event = 101 then
59896: LD_VAR 0 1
59900: PUSH
59901: LD_INT 101
59903: EQUAL
59904: IFFALSE 59910
// MC_RepairBuildings ( ) ;
59906: CALL 65106 0 0
// if event = 102 then
59910: LD_VAR 0 1
59914: PUSH
59915: LD_INT 102
59917: EQUAL
59918: IFFALSE 59924
// MC_Heal ( ) ;
59920: CALL 66009 0 0
// if event = 103 then
59924: LD_VAR 0 1
59928: PUSH
59929: LD_INT 103
59931: EQUAL
59932: IFFALSE 59938
// MC_Build ( ) ;
59934: CALL 66431 0 0
// if event = 104 then
59938: LD_VAR 0 1
59942: PUSH
59943: LD_INT 104
59945: EQUAL
59946: IFFALSE 59952
// MC_TurretWeapon ( ) ;
59948: CALL 68072 0 0
// if event = 105 then
59952: LD_VAR 0 1
59956: PUSH
59957: LD_INT 105
59959: EQUAL
59960: IFFALSE 59966
// MC_BuildUpgrade ( ) ;
59962: CALL 67623 0 0
// if event = 106 then
59966: LD_VAR 0 1
59970: PUSH
59971: LD_INT 106
59973: EQUAL
59974: IFFALSE 59980
// MC_PlantMines ( ) ;
59976: CALL 68502 0 0
// if event = 107 then
59980: LD_VAR 0 1
59984: PUSH
59985: LD_INT 107
59987: EQUAL
59988: IFFALSE 59994
// MC_CollectCrates ( ) ;
59990: CALL 69293 0 0
// if event = 108 then
59994: LD_VAR 0 1
59998: PUSH
59999: LD_INT 108
60001: EQUAL
60002: IFFALSE 60008
// MC_LinkRemoteControl ( ) ;
60004: CALL 71143 0 0
// if event = 109 then
60008: LD_VAR 0 1
60012: PUSH
60013: LD_INT 109
60015: EQUAL
60016: IFFALSE 60022
// MC_ProduceVehicle ( ) ;
60018: CALL 71324 0 0
// if event = 110 then
60022: LD_VAR 0 1
60026: PUSH
60027: LD_INT 110
60029: EQUAL
60030: IFFALSE 60036
// MC_SendAttack ( ) ;
60032: CALL 71790 0 0
// if event = 111 then
60036: LD_VAR 0 1
60040: PUSH
60041: LD_INT 111
60043: EQUAL
60044: IFFALSE 60050
// MC_Defend ( ) ;
60046: CALL 71898 0 0
// if event = 112 then
60050: LD_VAR 0 1
60054: PUSH
60055: LD_INT 112
60057: EQUAL
60058: IFFALSE 60064
// MC_Research ( ) ;
60060: CALL 72778 0 0
// if event = 113 then
60064: LD_VAR 0 1
60068: PUSH
60069: LD_INT 113
60071: EQUAL
60072: IFFALSE 60078
// MC_MinesTrigger ( ) ;
60074: CALL 73892 0 0
// if event = 120 then
60078: LD_VAR 0 1
60082: PUSH
60083: LD_INT 120
60085: EQUAL
60086: IFFALSE 60092
// MC_RepairVehicle ( ) ;
60088: CALL 73991 0 0
// if event = 121 then
60092: LD_VAR 0 1
60096: PUSH
60097: LD_INT 121
60099: EQUAL
60100: IFFALSE 60106
// MC_TameApe ( ) ;
60102: CALL 74732 0 0
// if event = 122 then
60106: LD_VAR 0 1
60110: PUSH
60111: LD_INT 122
60113: EQUAL
60114: IFFALSE 60120
// MC_ChangeApeClass ( ) ;
60116: CALL 75561 0 0
// if event = 123 then
60120: LD_VAR 0 1
60124: PUSH
60125: LD_INT 123
60127: EQUAL
60128: IFFALSE 60134
// MC_Bazooka ( ) ;
60130: CALL 76211 0 0
// if event = 124 then
60134: LD_VAR 0 1
60138: PUSH
60139: LD_INT 124
60141: EQUAL
60142: IFFALSE 60148
// MC_TeleportExit ( ) ;
60144: CALL 76409 0 0
// if event = 125 then
60148: LD_VAR 0 1
60152: PUSH
60153: LD_INT 125
60155: EQUAL
60156: IFFALSE 60162
// MC_Deposits ( ) ;
60158: CALL 77056 0 0
// if event = 126 then
60162: LD_VAR 0 1
60166: PUSH
60167: LD_INT 126
60169: EQUAL
60170: IFFALSE 60176
// MC_RemoteDriver ( ) ;
60172: CALL 77681 0 0
// if event = 200 then
60176: LD_VAR 0 1
60180: PUSH
60181: LD_INT 200
60183: EQUAL
60184: IFFALSE 60190
// MC_Idle ( ) ;
60186: CALL 79630 0 0
// end ;
60190: PPOPN 1
60192: END
// export function MC_Reset ( base , tag ) ; var i ; begin
60193: LD_INT 0
60195: PPUSH
60196: PPUSH
// if not mc_bases [ base ] or not tag then
60197: LD_EXP 60
60201: PUSH
60202: LD_VAR 0 1
60206: ARRAY
60207: NOT
60208: PUSH
60209: LD_VAR 0 2
60213: NOT
60214: OR
60215: IFFALSE 60219
// exit ;
60217: GO 60283
// for i in mc_bases [ base ] union mc_ape [ base ] do
60219: LD_ADDR_VAR 0 4
60223: PUSH
60224: LD_EXP 60
60228: PUSH
60229: LD_VAR 0 1
60233: ARRAY
60234: PUSH
60235: LD_EXP 89
60239: PUSH
60240: LD_VAR 0 1
60244: ARRAY
60245: UNION
60246: PUSH
60247: FOR_IN
60248: IFFALSE 60281
// if GetTag ( i ) = tag then
60250: LD_VAR 0 4
60254: PPUSH
60255: CALL_OW 110
60259: PUSH
60260: LD_VAR 0 2
60264: EQUAL
60265: IFFALSE 60279
// SetTag ( i , 0 ) ;
60267: LD_VAR 0 4
60271: PPUSH
60272: LD_INT 0
60274: PPUSH
60275: CALL_OW 109
60279: GO 60247
60281: POP
60282: POP
// end ;
60283: LD_VAR 0 3
60287: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
60288: LD_INT 0
60290: PPUSH
60291: PPUSH
60292: PPUSH
60293: PPUSH
60294: PPUSH
60295: PPUSH
60296: PPUSH
60297: PPUSH
// if not mc_bases then
60298: LD_EXP 60
60302: NOT
60303: IFFALSE 60307
// exit ;
60305: GO 60765
// for i = 1 to mc_bases do
60307: LD_ADDR_VAR 0 2
60311: PUSH
60312: DOUBLE
60313: LD_INT 1
60315: DEC
60316: ST_TO_ADDR
60317: LD_EXP 60
60321: PUSH
60322: FOR_TO
60323: IFFALSE 60763
// begin tmp := MC_ClassCheckReq ( i ) ;
60325: LD_ADDR_VAR 0 4
60329: PUSH
60330: LD_VAR 0 2
60334: PPUSH
60335: CALL 60770 0 1
60339: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
60340: LD_ADDR_EXP 101
60344: PUSH
60345: LD_EXP 101
60349: PPUSH
60350: LD_VAR 0 2
60354: PPUSH
60355: LD_VAR 0 4
60359: PPUSH
60360: CALL_OW 1
60364: ST_TO_ADDR
// if not tmp then
60365: LD_VAR 0 4
60369: NOT
60370: IFFALSE 60374
// continue ;
60372: GO 60322
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
60374: LD_ADDR_VAR 0 6
60378: PUSH
60379: LD_EXP 60
60383: PUSH
60384: LD_VAR 0 2
60388: ARRAY
60389: PPUSH
60390: LD_INT 2
60392: PUSH
60393: LD_INT 30
60395: PUSH
60396: LD_INT 4
60398: PUSH
60399: EMPTY
60400: LIST
60401: LIST
60402: PUSH
60403: LD_INT 30
60405: PUSH
60406: LD_INT 5
60408: PUSH
60409: EMPTY
60410: LIST
60411: LIST
60412: PUSH
60413: EMPTY
60414: LIST
60415: LIST
60416: LIST
60417: PPUSH
60418: CALL_OW 72
60422: PUSH
60423: LD_EXP 60
60427: PUSH
60428: LD_VAR 0 2
60432: ARRAY
60433: PPUSH
60434: LD_INT 2
60436: PUSH
60437: LD_INT 30
60439: PUSH
60440: LD_INT 0
60442: PUSH
60443: EMPTY
60444: LIST
60445: LIST
60446: PUSH
60447: LD_INT 30
60449: PUSH
60450: LD_INT 1
60452: PUSH
60453: EMPTY
60454: LIST
60455: LIST
60456: PUSH
60457: EMPTY
60458: LIST
60459: LIST
60460: LIST
60461: PPUSH
60462: CALL_OW 72
60466: PUSH
60467: LD_EXP 60
60471: PUSH
60472: LD_VAR 0 2
60476: ARRAY
60477: PPUSH
60478: LD_INT 30
60480: PUSH
60481: LD_INT 3
60483: PUSH
60484: EMPTY
60485: LIST
60486: LIST
60487: PPUSH
60488: CALL_OW 72
60492: PUSH
60493: LD_EXP 60
60497: PUSH
60498: LD_VAR 0 2
60502: ARRAY
60503: PPUSH
60504: LD_INT 2
60506: PUSH
60507: LD_INT 30
60509: PUSH
60510: LD_INT 6
60512: PUSH
60513: EMPTY
60514: LIST
60515: LIST
60516: PUSH
60517: LD_INT 30
60519: PUSH
60520: LD_INT 7
60522: PUSH
60523: EMPTY
60524: LIST
60525: LIST
60526: PUSH
60527: LD_INT 30
60529: PUSH
60530: LD_INT 8
60532: PUSH
60533: EMPTY
60534: LIST
60535: LIST
60536: PUSH
60537: EMPTY
60538: LIST
60539: LIST
60540: LIST
60541: LIST
60542: PPUSH
60543: CALL_OW 72
60547: PUSH
60548: EMPTY
60549: LIST
60550: LIST
60551: LIST
60552: LIST
60553: ST_TO_ADDR
// for j = 1 to 4 do
60554: LD_ADDR_VAR 0 3
60558: PUSH
60559: DOUBLE
60560: LD_INT 1
60562: DEC
60563: ST_TO_ADDR
60564: LD_INT 4
60566: PUSH
60567: FOR_TO
60568: IFFALSE 60759
// begin if not tmp [ j ] then
60570: LD_VAR 0 4
60574: PUSH
60575: LD_VAR 0 3
60579: ARRAY
60580: NOT
60581: IFFALSE 60585
// continue ;
60583: GO 60567
// for p in tmp [ j ] do
60585: LD_ADDR_VAR 0 5
60589: PUSH
60590: LD_VAR 0 4
60594: PUSH
60595: LD_VAR 0 3
60599: ARRAY
60600: PUSH
60601: FOR_IN
60602: IFFALSE 60755
// begin if not b [ j ] then
60604: LD_VAR 0 6
60608: PUSH
60609: LD_VAR 0 3
60613: ARRAY
60614: NOT
60615: IFFALSE 60619
// break ;
60617: GO 60755
// e := 0 ;
60619: LD_ADDR_VAR 0 7
60623: PUSH
60624: LD_INT 0
60626: ST_TO_ADDR
// for k in b [ j ] do
60627: LD_ADDR_VAR 0 8
60631: PUSH
60632: LD_VAR 0 6
60636: PUSH
60637: LD_VAR 0 3
60641: ARRAY
60642: PUSH
60643: FOR_IN
60644: IFFALSE 60671
// if IsNotFull ( k ) then
60646: LD_VAR 0 8
60650: PPUSH
60651: CALL 17070 0 1
60655: IFFALSE 60669
// begin e := k ;
60657: LD_ADDR_VAR 0 7
60661: PUSH
60662: LD_VAR 0 8
60666: ST_TO_ADDR
// break ;
60667: GO 60671
// end ;
60669: GO 60643
60671: POP
60672: POP
// if e and not UnitGoingToBuilding ( p , e ) then
60673: LD_VAR 0 7
60677: PUSH
60678: LD_VAR 0 5
60682: PPUSH
60683: LD_VAR 0 7
60687: PPUSH
60688: CALL 50876 0 2
60692: NOT
60693: AND
60694: IFFALSE 60753
// begin if IsInUnit ( p ) then
60696: LD_VAR 0 5
60700: PPUSH
60701: CALL_OW 310
60705: IFFALSE 60716
// ComExitBuilding ( p ) ;
60707: LD_VAR 0 5
60711: PPUSH
60712: CALL_OW 122
// ComEnterUnit ( p , e ) ;
60716: LD_VAR 0 5
60720: PPUSH
60721: LD_VAR 0 7
60725: PPUSH
60726: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
60730: LD_VAR 0 5
60734: PPUSH
60735: LD_VAR 0 3
60739: PPUSH
60740: CALL_OW 183
// AddComExitBuilding ( p ) ;
60744: LD_VAR 0 5
60748: PPUSH
60749: CALL_OW 182
// end ; end ;
60753: GO 60601
60755: POP
60756: POP
// end ;
60757: GO 60567
60759: POP
60760: POP
// end ;
60761: GO 60322
60763: POP
60764: POP
// end ;
60765: LD_VAR 0 1
60769: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
60770: LD_INT 0
60772: PPUSH
60773: PPUSH
60774: PPUSH
60775: PPUSH
60776: PPUSH
60777: PPUSH
60778: PPUSH
60779: PPUSH
60780: PPUSH
60781: PPUSH
60782: PPUSH
60783: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60784: LD_VAR 0 1
60788: NOT
60789: PUSH
60790: LD_EXP 60
60794: PUSH
60795: LD_VAR 0 1
60799: ARRAY
60800: NOT
60801: OR
60802: PUSH
60803: LD_EXP 60
60807: PUSH
60808: LD_VAR 0 1
60812: ARRAY
60813: PPUSH
60814: LD_INT 2
60816: PUSH
60817: LD_INT 30
60819: PUSH
60820: LD_INT 0
60822: PUSH
60823: EMPTY
60824: LIST
60825: LIST
60826: PUSH
60827: LD_INT 30
60829: PUSH
60830: LD_INT 1
60832: PUSH
60833: EMPTY
60834: LIST
60835: LIST
60836: PUSH
60837: EMPTY
60838: LIST
60839: LIST
60840: LIST
60841: PPUSH
60842: CALL_OW 72
60846: NOT
60847: OR
60848: IFFALSE 60852
// exit ;
60850: GO 64355
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
60852: LD_ADDR_VAR 0 4
60856: PUSH
60857: LD_EXP 60
60861: PUSH
60862: LD_VAR 0 1
60866: ARRAY
60867: PPUSH
60868: LD_INT 2
60870: PUSH
60871: LD_INT 25
60873: PUSH
60874: LD_INT 1
60876: PUSH
60877: EMPTY
60878: LIST
60879: LIST
60880: PUSH
60881: LD_INT 25
60883: PUSH
60884: LD_INT 2
60886: PUSH
60887: EMPTY
60888: LIST
60889: LIST
60890: PUSH
60891: LD_INT 25
60893: PUSH
60894: LD_INT 3
60896: PUSH
60897: EMPTY
60898: LIST
60899: LIST
60900: PUSH
60901: LD_INT 25
60903: PUSH
60904: LD_INT 4
60906: PUSH
60907: EMPTY
60908: LIST
60909: LIST
60910: PUSH
60911: LD_INT 25
60913: PUSH
60914: LD_INT 5
60916: PUSH
60917: EMPTY
60918: LIST
60919: LIST
60920: PUSH
60921: LD_INT 25
60923: PUSH
60924: LD_INT 8
60926: PUSH
60927: EMPTY
60928: LIST
60929: LIST
60930: PUSH
60931: LD_INT 25
60933: PUSH
60934: LD_INT 9
60936: PUSH
60937: EMPTY
60938: LIST
60939: LIST
60940: PUSH
60941: EMPTY
60942: LIST
60943: LIST
60944: LIST
60945: LIST
60946: LIST
60947: LIST
60948: LIST
60949: LIST
60950: PPUSH
60951: CALL_OW 72
60955: ST_TO_ADDR
// if not tmp then
60956: LD_VAR 0 4
60960: NOT
60961: IFFALSE 60965
// exit ;
60963: GO 64355
// for i in tmp do
60965: LD_ADDR_VAR 0 3
60969: PUSH
60970: LD_VAR 0 4
60974: PUSH
60975: FOR_IN
60976: IFFALSE 61007
// if GetTag ( i ) then
60978: LD_VAR 0 3
60982: PPUSH
60983: CALL_OW 110
60987: IFFALSE 61005
// tmp := tmp diff i ;
60989: LD_ADDR_VAR 0 4
60993: PUSH
60994: LD_VAR 0 4
60998: PUSH
60999: LD_VAR 0 3
61003: DIFF
61004: ST_TO_ADDR
61005: GO 60975
61007: POP
61008: POP
// if not tmp then
61009: LD_VAR 0 4
61013: NOT
61014: IFFALSE 61018
// exit ;
61016: GO 64355
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61018: LD_ADDR_VAR 0 5
61022: PUSH
61023: LD_EXP 60
61027: PUSH
61028: LD_VAR 0 1
61032: ARRAY
61033: PPUSH
61034: LD_INT 2
61036: PUSH
61037: LD_INT 25
61039: PUSH
61040: LD_INT 1
61042: PUSH
61043: EMPTY
61044: LIST
61045: LIST
61046: PUSH
61047: LD_INT 25
61049: PUSH
61050: LD_INT 5
61052: PUSH
61053: EMPTY
61054: LIST
61055: LIST
61056: PUSH
61057: LD_INT 25
61059: PUSH
61060: LD_INT 8
61062: PUSH
61063: EMPTY
61064: LIST
61065: LIST
61066: PUSH
61067: LD_INT 25
61069: PUSH
61070: LD_INT 9
61072: PUSH
61073: EMPTY
61074: LIST
61075: LIST
61076: PUSH
61077: EMPTY
61078: LIST
61079: LIST
61080: LIST
61081: LIST
61082: LIST
61083: PPUSH
61084: CALL_OW 72
61088: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
61089: LD_ADDR_VAR 0 6
61093: PUSH
61094: LD_EXP 60
61098: PUSH
61099: LD_VAR 0 1
61103: ARRAY
61104: PPUSH
61105: LD_INT 25
61107: PUSH
61108: LD_INT 2
61110: PUSH
61111: EMPTY
61112: LIST
61113: LIST
61114: PPUSH
61115: CALL_OW 72
61119: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
61120: LD_ADDR_VAR 0 7
61124: PUSH
61125: LD_EXP 60
61129: PUSH
61130: LD_VAR 0 1
61134: ARRAY
61135: PPUSH
61136: LD_INT 25
61138: PUSH
61139: LD_INT 3
61141: PUSH
61142: EMPTY
61143: LIST
61144: LIST
61145: PPUSH
61146: CALL_OW 72
61150: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
61151: LD_ADDR_VAR 0 8
61155: PUSH
61156: LD_EXP 60
61160: PUSH
61161: LD_VAR 0 1
61165: ARRAY
61166: PPUSH
61167: LD_INT 25
61169: PUSH
61170: LD_INT 4
61172: PUSH
61173: EMPTY
61174: LIST
61175: LIST
61176: PUSH
61177: LD_INT 24
61179: PUSH
61180: LD_INT 251
61182: PUSH
61183: EMPTY
61184: LIST
61185: LIST
61186: PUSH
61187: EMPTY
61188: LIST
61189: LIST
61190: PPUSH
61191: CALL_OW 72
61195: ST_TO_ADDR
// if mc_is_defending [ base ] then
61196: LD_EXP 103
61200: PUSH
61201: LD_VAR 0 1
61205: ARRAY
61206: IFFALSE 61667
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
61208: LD_ADDR_EXP 102
61212: PUSH
61213: LD_EXP 102
61217: PPUSH
61218: LD_VAR 0 1
61222: PPUSH
61223: LD_INT 4
61225: PPUSH
61226: CALL_OW 1
61230: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
61231: LD_ADDR_VAR 0 12
61235: PUSH
61236: LD_EXP 60
61240: PUSH
61241: LD_VAR 0 1
61245: ARRAY
61246: PPUSH
61247: LD_INT 2
61249: PUSH
61250: LD_INT 30
61252: PUSH
61253: LD_INT 4
61255: PUSH
61256: EMPTY
61257: LIST
61258: LIST
61259: PUSH
61260: LD_INT 30
61262: PUSH
61263: LD_INT 5
61265: PUSH
61266: EMPTY
61267: LIST
61268: LIST
61269: PUSH
61270: EMPTY
61271: LIST
61272: LIST
61273: LIST
61274: PPUSH
61275: CALL_OW 72
61279: ST_TO_ADDR
// if not b then
61280: LD_VAR 0 12
61284: NOT
61285: IFFALSE 61289
// exit ;
61287: GO 64355
// p := [ ] ;
61289: LD_ADDR_VAR 0 11
61293: PUSH
61294: EMPTY
61295: ST_TO_ADDR
// if sci >= 2 then
61296: LD_VAR 0 8
61300: PUSH
61301: LD_INT 2
61303: GREATEREQUAL
61304: IFFALSE 61335
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
61306: LD_ADDR_VAR 0 8
61310: PUSH
61311: LD_VAR 0 8
61315: PUSH
61316: LD_INT 1
61318: ARRAY
61319: PUSH
61320: LD_VAR 0 8
61324: PUSH
61325: LD_INT 2
61327: ARRAY
61328: PUSH
61329: EMPTY
61330: LIST
61331: LIST
61332: ST_TO_ADDR
61333: GO 61396
// if sci = 1 then
61335: LD_VAR 0 8
61339: PUSH
61340: LD_INT 1
61342: EQUAL
61343: IFFALSE 61364
// sci := [ sci [ 1 ] ] else
61345: LD_ADDR_VAR 0 8
61349: PUSH
61350: LD_VAR 0 8
61354: PUSH
61355: LD_INT 1
61357: ARRAY
61358: PUSH
61359: EMPTY
61360: LIST
61361: ST_TO_ADDR
61362: GO 61396
// if sci = 0 then
61364: LD_VAR 0 8
61368: PUSH
61369: LD_INT 0
61371: EQUAL
61372: IFFALSE 61396
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
61374: LD_ADDR_VAR 0 11
61378: PUSH
61379: LD_VAR 0 4
61383: PPUSH
61384: LD_INT 4
61386: PPUSH
61387: CALL 50739 0 2
61391: PUSH
61392: LD_INT 1
61394: ARRAY
61395: ST_TO_ADDR
// if eng > 4 then
61396: LD_VAR 0 6
61400: PUSH
61401: LD_INT 4
61403: GREATER
61404: IFFALSE 61450
// for i = eng downto 4 do
61406: LD_ADDR_VAR 0 3
61410: PUSH
61411: DOUBLE
61412: LD_VAR 0 6
61416: INC
61417: ST_TO_ADDR
61418: LD_INT 4
61420: PUSH
61421: FOR_DOWNTO
61422: IFFALSE 61448
// eng := eng diff eng [ i ] ;
61424: LD_ADDR_VAR 0 6
61428: PUSH
61429: LD_VAR 0 6
61433: PUSH
61434: LD_VAR 0 6
61438: PUSH
61439: LD_VAR 0 3
61443: ARRAY
61444: DIFF
61445: ST_TO_ADDR
61446: GO 61421
61448: POP
61449: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
61450: LD_ADDR_VAR 0 4
61454: PUSH
61455: LD_VAR 0 4
61459: PUSH
61460: LD_VAR 0 5
61464: PUSH
61465: LD_VAR 0 6
61469: UNION
61470: PUSH
61471: LD_VAR 0 7
61475: UNION
61476: PUSH
61477: LD_VAR 0 8
61481: UNION
61482: DIFF
61483: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
61484: LD_ADDR_VAR 0 13
61488: PUSH
61489: LD_EXP 60
61493: PUSH
61494: LD_VAR 0 1
61498: ARRAY
61499: PPUSH
61500: LD_INT 2
61502: PUSH
61503: LD_INT 30
61505: PUSH
61506: LD_INT 32
61508: PUSH
61509: EMPTY
61510: LIST
61511: LIST
61512: PUSH
61513: LD_INT 30
61515: PUSH
61516: LD_INT 31
61518: PUSH
61519: EMPTY
61520: LIST
61521: LIST
61522: PUSH
61523: EMPTY
61524: LIST
61525: LIST
61526: LIST
61527: PPUSH
61528: CALL_OW 72
61532: PUSH
61533: LD_EXP 60
61537: PUSH
61538: LD_VAR 0 1
61542: ARRAY
61543: PPUSH
61544: LD_INT 2
61546: PUSH
61547: LD_INT 30
61549: PUSH
61550: LD_INT 4
61552: PUSH
61553: EMPTY
61554: LIST
61555: LIST
61556: PUSH
61557: LD_INT 30
61559: PUSH
61560: LD_INT 5
61562: PUSH
61563: EMPTY
61564: LIST
61565: LIST
61566: PUSH
61567: EMPTY
61568: LIST
61569: LIST
61570: LIST
61571: PPUSH
61572: CALL_OW 72
61576: PUSH
61577: LD_INT 6
61579: MUL
61580: PLUS
61581: ST_TO_ADDR
// if bcount < tmp then
61582: LD_VAR 0 13
61586: PUSH
61587: LD_VAR 0 4
61591: LESS
61592: IFFALSE 61638
// for i = tmp downto bcount do
61594: LD_ADDR_VAR 0 3
61598: PUSH
61599: DOUBLE
61600: LD_VAR 0 4
61604: INC
61605: ST_TO_ADDR
61606: LD_VAR 0 13
61610: PUSH
61611: FOR_DOWNTO
61612: IFFALSE 61636
// tmp := Delete ( tmp , tmp ) ;
61614: LD_ADDR_VAR 0 4
61618: PUSH
61619: LD_VAR 0 4
61623: PPUSH
61624: LD_VAR 0 4
61628: PPUSH
61629: CALL_OW 3
61633: ST_TO_ADDR
61634: GO 61611
61636: POP
61637: POP
// result := [ tmp , 0 , 0 , p ] ;
61638: LD_ADDR_VAR 0 2
61642: PUSH
61643: LD_VAR 0 4
61647: PUSH
61648: LD_INT 0
61650: PUSH
61651: LD_INT 0
61653: PUSH
61654: LD_VAR 0 11
61658: PUSH
61659: EMPTY
61660: LIST
61661: LIST
61662: LIST
61663: LIST
61664: ST_TO_ADDR
// exit ;
61665: GO 64355
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61667: LD_EXP 60
61671: PUSH
61672: LD_VAR 0 1
61676: ARRAY
61677: PPUSH
61678: LD_INT 2
61680: PUSH
61681: LD_INT 30
61683: PUSH
61684: LD_INT 6
61686: PUSH
61687: EMPTY
61688: LIST
61689: LIST
61690: PUSH
61691: LD_INT 30
61693: PUSH
61694: LD_INT 7
61696: PUSH
61697: EMPTY
61698: LIST
61699: LIST
61700: PUSH
61701: LD_INT 30
61703: PUSH
61704: LD_INT 8
61706: PUSH
61707: EMPTY
61708: LIST
61709: LIST
61710: PUSH
61711: EMPTY
61712: LIST
61713: LIST
61714: LIST
61715: LIST
61716: PPUSH
61717: CALL_OW 72
61721: NOT
61722: PUSH
61723: LD_EXP 60
61727: PUSH
61728: LD_VAR 0 1
61732: ARRAY
61733: PPUSH
61734: LD_INT 30
61736: PUSH
61737: LD_INT 3
61739: PUSH
61740: EMPTY
61741: LIST
61742: LIST
61743: PPUSH
61744: CALL_OW 72
61748: NOT
61749: AND
61750: IFFALSE 61822
// begin if eng = tmp then
61752: LD_VAR 0 6
61756: PUSH
61757: LD_VAR 0 4
61761: EQUAL
61762: IFFALSE 61766
// exit ;
61764: GO 64355
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
61766: LD_ADDR_EXP 102
61770: PUSH
61771: LD_EXP 102
61775: PPUSH
61776: LD_VAR 0 1
61780: PPUSH
61781: LD_INT 1
61783: PPUSH
61784: CALL_OW 1
61788: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
61789: LD_ADDR_VAR 0 2
61793: PUSH
61794: LD_INT 0
61796: PUSH
61797: LD_VAR 0 4
61801: PUSH
61802: LD_VAR 0 6
61806: DIFF
61807: PUSH
61808: LD_INT 0
61810: PUSH
61811: LD_INT 0
61813: PUSH
61814: EMPTY
61815: LIST
61816: LIST
61817: LIST
61818: LIST
61819: ST_TO_ADDR
// exit ;
61820: GO 64355
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61822: LD_EXP 87
61826: PUSH
61827: LD_EXP 86
61831: PUSH
61832: LD_VAR 0 1
61836: ARRAY
61837: ARRAY
61838: PUSH
61839: LD_EXP 60
61843: PUSH
61844: LD_VAR 0 1
61848: ARRAY
61849: PPUSH
61850: LD_INT 2
61852: PUSH
61853: LD_INT 30
61855: PUSH
61856: LD_INT 6
61858: PUSH
61859: EMPTY
61860: LIST
61861: LIST
61862: PUSH
61863: LD_INT 30
61865: PUSH
61866: LD_INT 7
61868: PUSH
61869: EMPTY
61870: LIST
61871: LIST
61872: PUSH
61873: LD_INT 30
61875: PUSH
61876: LD_INT 8
61878: PUSH
61879: EMPTY
61880: LIST
61881: LIST
61882: PUSH
61883: EMPTY
61884: LIST
61885: LIST
61886: LIST
61887: LIST
61888: PPUSH
61889: CALL_OW 72
61893: AND
61894: PUSH
61895: LD_EXP 60
61899: PUSH
61900: LD_VAR 0 1
61904: ARRAY
61905: PPUSH
61906: LD_INT 30
61908: PUSH
61909: LD_INT 3
61911: PUSH
61912: EMPTY
61913: LIST
61914: LIST
61915: PPUSH
61916: CALL_OW 72
61920: NOT
61921: AND
61922: IFFALSE 62136
// begin if sci >= 6 then
61924: LD_VAR 0 8
61928: PUSH
61929: LD_INT 6
61931: GREATEREQUAL
61932: IFFALSE 61936
// exit ;
61934: GO 64355
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
61936: LD_ADDR_EXP 102
61940: PUSH
61941: LD_EXP 102
61945: PPUSH
61946: LD_VAR 0 1
61950: PPUSH
61951: LD_INT 2
61953: PPUSH
61954: CALL_OW 1
61958: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
61959: LD_ADDR_VAR 0 9
61963: PUSH
61964: LD_VAR 0 4
61968: PUSH
61969: LD_VAR 0 8
61973: DIFF
61974: PPUSH
61975: LD_INT 4
61977: PPUSH
61978: CALL 50739 0 2
61982: ST_TO_ADDR
// p := [ ] ;
61983: LD_ADDR_VAR 0 11
61987: PUSH
61988: EMPTY
61989: ST_TO_ADDR
// if sci < 6 and sort > 6 then
61990: LD_VAR 0 8
61994: PUSH
61995: LD_INT 6
61997: LESS
61998: PUSH
61999: LD_VAR 0 9
62003: PUSH
62004: LD_INT 6
62006: GREATER
62007: AND
62008: IFFALSE 62089
// begin for i = 1 to 6 - sci do
62010: LD_ADDR_VAR 0 3
62014: PUSH
62015: DOUBLE
62016: LD_INT 1
62018: DEC
62019: ST_TO_ADDR
62020: LD_INT 6
62022: PUSH
62023: LD_VAR 0 8
62027: MINUS
62028: PUSH
62029: FOR_TO
62030: IFFALSE 62085
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
62032: LD_ADDR_VAR 0 11
62036: PUSH
62037: LD_VAR 0 11
62041: PPUSH
62042: LD_VAR 0 11
62046: PUSH
62047: LD_INT 1
62049: PLUS
62050: PPUSH
62051: LD_VAR 0 9
62055: PUSH
62056: LD_INT 1
62058: ARRAY
62059: PPUSH
62060: CALL_OW 2
62064: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
62065: LD_ADDR_VAR 0 9
62069: PUSH
62070: LD_VAR 0 9
62074: PPUSH
62075: LD_INT 1
62077: PPUSH
62078: CALL_OW 3
62082: ST_TO_ADDR
// end ;
62083: GO 62029
62085: POP
62086: POP
// end else
62087: GO 62109
// if sort then
62089: LD_VAR 0 9
62093: IFFALSE 62109
// p := sort [ 1 ] ;
62095: LD_ADDR_VAR 0 11
62099: PUSH
62100: LD_VAR 0 9
62104: PUSH
62105: LD_INT 1
62107: ARRAY
62108: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
62109: LD_ADDR_VAR 0 2
62113: PUSH
62114: LD_INT 0
62116: PUSH
62117: LD_INT 0
62119: PUSH
62120: LD_INT 0
62122: PUSH
62123: LD_VAR 0 11
62127: PUSH
62128: EMPTY
62129: LIST
62130: LIST
62131: LIST
62132: LIST
62133: ST_TO_ADDR
// exit ;
62134: GO 64355
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62136: LD_EXP 87
62140: PUSH
62141: LD_EXP 86
62145: PUSH
62146: LD_VAR 0 1
62150: ARRAY
62151: ARRAY
62152: PUSH
62153: LD_EXP 60
62157: PUSH
62158: LD_VAR 0 1
62162: ARRAY
62163: PPUSH
62164: LD_INT 2
62166: PUSH
62167: LD_INT 30
62169: PUSH
62170: LD_INT 6
62172: PUSH
62173: EMPTY
62174: LIST
62175: LIST
62176: PUSH
62177: LD_INT 30
62179: PUSH
62180: LD_INT 7
62182: PUSH
62183: EMPTY
62184: LIST
62185: LIST
62186: PUSH
62187: LD_INT 30
62189: PUSH
62190: LD_INT 8
62192: PUSH
62193: EMPTY
62194: LIST
62195: LIST
62196: PUSH
62197: EMPTY
62198: LIST
62199: LIST
62200: LIST
62201: LIST
62202: PPUSH
62203: CALL_OW 72
62207: AND
62208: PUSH
62209: LD_EXP 60
62213: PUSH
62214: LD_VAR 0 1
62218: ARRAY
62219: PPUSH
62220: LD_INT 30
62222: PUSH
62223: LD_INT 3
62225: PUSH
62226: EMPTY
62227: LIST
62228: LIST
62229: PPUSH
62230: CALL_OW 72
62234: AND
62235: IFFALSE 62969
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
62237: LD_ADDR_EXP 102
62241: PUSH
62242: LD_EXP 102
62246: PPUSH
62247: LD_VAR 0 1
62251: PPUSH
62252: LD_INT 3
62254: PPUSH
62255: CALL_OW 1
62259: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62260: LD_ADDR_VAR 0 2
62264: PUSH
62265: LD_INT 0
62267: PUSH
62268: LD_INT 0
62270: PUSH
62271: LD_INT 0
62273: PUSH
62274: LD_INT 0
62276: PUSH
62277: EMPTY
62278: LIST
62279: LIST
62280: LIST
62281: LIST
62282: ST_TO_ADDR
// if not eng then
62283: LD_VAR 0 6
62287: NOT
62288: IFFALSE 62351
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
62290: LD_ADDR_VAR 0 11
62294: PUSH
62295: LD_VAR 0 4
62299: PPUSH
62300: LD_INT 2
62302: PPUSH
62303: CALL 50739 0 2
62307: PUSH
62308: LD_INT 1
62310: ARRAY
62311: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
62312: LD_ADDR_VAR 0 2
62316: PUSH
62317: LD_VAR 0 2
62321: PPUSH
62322: LD_INT 2
62324: PPUSH
62325: LD_VAR 0 11
62329: PPUSH
62330: CALL_OW 1
62334: ST_TO_ADDR
// tmp := tmp diff p ;
62335: LD_ADDR_VAR 0 4
62339: PUSH
62340: LD_VAR 0 4
62344: PUSH
62345: LD_VAR 0 11
62349: DIFF
62350: ST_TO_ADDR
// end ; if tmp and sci < 6 then
62351: LD_VAR 0 4
62355: PUSH
62356: LD_VAR 0 8
62360: PUSH
62361: LD_INT 6
62363: LESS
62364: AND
62365: IFFALSE 62553
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
62367: LD_ADDR_VAR 0 9
62371: PUSH
62372: LD_VAR 0 4
62376: PUSH
62377: LD_VAR 0 8
62381: PUSH
62382: LD_VAR 0 7
62386: UNION
62387: DIFF
62388: PPUSH
62389: LD_INT 4
62391: PPUSH
62392: CALL 50739 0 2
62396: ST_TO_ADDR
// p := [ ] ;
62397: LD_ADDR_VAR 0 11
62401: PUSH
62402: EMPTY
62403: ST_TO_ADDR
// if sort then
62404: LD_VAR 0 9
62408: IFFALSE 62524
// for i = 1 to 6 - sci do
62410: LD_ADDR_VAR 0 3
62414: PUSH
62415: DOUBLE
62416: LD_INT 1
62418: DEC
62419: ST_TO_ADDR
62420: LD_INT 6
62422: PUSH
62423: LD_VAR 0 8
62427: MINUS
62428: PUSH
62429: FOR_TO
62430: IFFALSE 62522
// begin if i = sort then
62432: LD_VAR 0 3
62436: PUSH
62437: LD_VAR 0 9
62441: EQUAL
62442: IFFALSE 62446
// break ;
62444: GO 62522
// if GetClass ( i ) = 4 then
62446: LD_VAR 0 3
62450: PPUSH
62451: CALL_OW 257
62455: PUSH
62456: LD_INT 4
62458: EQUAL
62459: IFFALSE 62463
// continue ;
62461: GO 62429
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62463: LD_ADDR_VAR 0 11
62467: PUSH
62468: LD_VAR 0 11
62472: PPUSH
62473: LD_VAR 0 11
62477: PUSH
62478: LD_INT 1
62480: PLUS
62481: PPUSH
62482: LD_VAR 0 9
62486: PUSH
62487: LD_VAR 0 3
62491: ARRAY
62492: PPUSH
62493: CALL_OW 2
62497: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62498: LD_ADDR_VAR 0 4
62502: PUSH
62503: LD_VAR 0 4
62507: PUSH
62508: LD_VAR 0 9
62512: PUSH
62513: LD_VAR 0 3
62517: ARRAY
62518: DIFF
62519: ST_TO_ADDR
// end ;
62520: GO 62429
62522: POP
62523: POP
// if p then
62524: LD_VAR 0 11
62528: IFFALSE 62553
// result := Replace ( result , 4 , p ) ;
62530: LD_ADDR_VAR 0 2
62534: PUSH
62535: LD_VAR 0 2
62539: PPUSH
62540: LD_INT 4
62542: PPUSH
62543: LD_VAR 0 11
62547: PPUSH
62548: CALL_OW 1
62552: ST_TO_ADDR
// end ; if tmp and mech < 6 then
62553: LD_VAR 0 4
62557: PUSH
62558: LD_VAR 0 7
62562: PUSH
62563: LD_INT 6
62565: LESS
62566: AND
62567: IFFALSE 62755
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62569: LD_ADDR_VAR 0 9
62573: PUSH
62574: LD_VAR 0 4
62578: PUSH
62579: LD_VAR 0 8
62583: PUSH
62584: LD_VAR 0 7
62588: UNION
62589: DIFF
62590: PPUSH
62591: LD_INT 3
62593: PPUSH
62594: CALL 50739 0 2
62598: ST_TO_ADDR
// p := [ ] ;
62599: LD_ADDR_VAR 0 11
62603: PUSH
62604: EMPTY
62605: ST_TO_ADDR
// if sort then
62606: LD_VAR 0 9
62610: IFFALSE 62726
// for i = 1 to 6 - mech do
62612: LD_ADDR_VAR 0 3
62616: PUSH
62617: DOUBLE
62618: LD_INT 1
62620: DEC
62621: ST_TO_ADDR
62622: LD_INT 6
62624: PUSH
62625: LD_VAR 0 7
62629: MINUS
62630: PUSH
62631: FOR_TO
62632: IFFALSE 62724
// begin if i = sort then
62634: LD_VAR 0 3
62638: PUSH
62639: LD_VAR 0 9
62643: EQUAL
62644: IFFALSE 62648
// break ;
62646: GO 62724
// if GetClass ( i ) = 3 then
62648: LD_VAR 0 3
62652: PPUSH
62653: CALL_OW 257
62657: PUSH
62658: LD_INT 3
62660: EQUAL
62661: IFFALSE 62665
// continue ;
62663: GO 62631
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62665: LD_ADDR_VAR 0 11
62669: PUSH
62670: LD_VAR 0 11
62674: PPUSH
62675: LD_VAR 0 11
62679: PUSH
62680: LD_INT 1
62682: PLUS
62683: PPUSH
62684: LD_VAR 0 9
62688: PUSH
62689: LD_VAR 0 3
62693: ARRAY
62694: PPUSH
62695: CALL_OW 2
62699: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62700: LD_ADDR_VAR 0 4
62704: PUSH
62705: LD_VAR 0 4
62709: PUSH
62710: LD_VAR 0 9
62714: PUSH
62715: LD_VAR 0 3
62719: ARRAY
62720: DIFF
62721: ST_TO_ADDR
// end ;
62722: GO 62631
62724: POP
62725: POP
// if p then
62726: LD_VAR 0 11
62730: IFFALSE 62755
// result := Replace ( result , 3 , p ) ;
62732: LD_ADDR_VAR 0 2
62736: PUSH
62737: LD_VAR 0 2
62741: PPUSH
62742: LD_INT 3
62744: PPUSH
62745: LD_VAR 0 11
62749: PPUSH
62750: CALL_OW 1
62754: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
62755: LD_VAR 0 4
62759: PUSH
62760: LD_INT 6
62762: GREATER
62763: PUSH
62764: LD_VAR 0 6
62768: PUSH
62769: LD_INT 6
62771: LESS
62772: AND
62773: IFFALSE 62967
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62775: LD_ADDR_VAR 0 9
62779: PUSH
62780: LD_VAR 0 4
62784: PUSH
62785: LD_VAR 0 8
62789: PUSH
62790: LD_VAR 0 7
62794: UNION
62795: PUSH
62796: LD_VAR 0 6
62800: UNION
62801: DIFF
62802: PPUSH
62803: LD_INT 2
62805: PPUSH
62806: CALL 50739 0 2
62810: ST_TO_ADDR
// p := [ ] ;
62811: LD_ADDR_VAR 0 11
62815: PUSH
62816: EMPTY
62817: ST_TO_ADDR
// if sort then
62818: LD_VAR 0 9
62822: IFFALSE 62938
// for i = 1 to 6 - eng do
62824: LD_ADDR_VAR 0 3
62828: PUSH
62829: DOUBLE
62830: LD_INT 1
62832: DEC
62833: ST_TO_ADDR
62834: LD_INT 6
62836: PUSH
62837: LD_VAR 0 6
62841: MINUS
62842: PUSH
62843: FOR_TO
62844: IFFALSE 62936
// begin if i = sort then
62846: LD_VAR 0 3
62850: PUSH
62851: LD_VAR 0 9
62855: EQUAL
62856: IFFALSE 62860
// break ;
62858: GO 62936
// if GetClass ( i ) = 2 then
62860: LD_VAR 0 3
62864: PPUSH
62865: CALL_OW 257
62869: PUSH
62870: LD_INT 2
62872: EQUAL
62873: IFFALSE 62877
// continue ;
62875: GO 62843
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62877: LD_ADDR_VAR 0 11
62881: PUSH
62882: LD_VAR 0 11
62886: PPUSH
62887: LD_VAR 0 11
62891: PUSH
62892: LD_INT 1
62894: PLUS
62895: PPUSH
62896: LD_VAR 0 9
62900: PUSH
62901: LD_VAR 0 3
62905: ARRAY
62906: PPUSH
62907: CALL_OW 2
62911: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62912: LD_ADDR_VAR 0 4
62916: PUSH
62917: LD_VAR 0 4
62921: PUSH
62922: LD_VAR 0 9
62926: PUSH
62927: LD_VAR 0 3
62931: ARRAY
62932: DIFF
62933: ST_TO_ADDR
// end ;
62934: GO 62843
62936: POP
62937: POP
// if p then
62938: LD_VAR 0 11
62942: IFFALSE 62967
// result := Replace ( result , 2 , p ) ;
62944: LD_ADDR_VAR 0 2
62948: PUSH
62949: LD_VAR 0 2
62953: PPUSH
62954: LD_INT 2
62956: PPUSH
62957: LD_VAR 0 11
62961: PPUSH
62962: CALL_OW 1
62966: ST_TO_ADDR
// end ; exit ;
62967: GO 64355
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
62969: LD_EXP 87
62973: PUSH
62974: LD_EXP 86
62978: PUSH
62979: LD_VAR 0 1
62983: ARRAY
62984: ARRAY
62985: NOT
62986: PUSH
62987: LD_EXP 60
62991: PUSH
62992: LD_VAR 0 1
62996: ARRAY
62997: PPUSH
62998: LD_INT 30
63000: PUSH
63001: LD_INT 3
63003: PUSH
63004: EMPTY
63005: LIST
63006: LIST
63007: PPUSH
63008: CALL_OW 72
63012: AND
63013: PUSH
63014: LD_EXP 65
63018: PUSH
63019: LD_VAR 0 1
63023: ARRAY
63024: AND
63025: IFFALSE 63633
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
63027: LD_ADDR_EXP 102
63031: PUSH
63032: LD_EXP 102
63036: PPUSH
63037: LD_VAR 0 1
63041: PPUSH
63042: LD_INT 5
63044: PPUSH
63045: CALL_OW 1
63049: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63050: LD_ADDR_VAR 0 2
63054: PUSH
63055: LD_INT 0
63057: PUSH
63058: LD_INT 0
63060: PUSH
63061: LD_INT 0
63063: PUSH
63064: LD_INT 0
63066: PUSH
63067: EMPTY
63068: LIST
63069: LIST
63070: LIST
63071: LIST
63072: ST_TO_ADDR
// if sci > 1 then
63073: LD_VAR 0 8
63077: PUSH
63078: LD_INT 1
63080: GREATER
63081: IFFALSE 63109
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
63083: LD_ADDR_VAR 0 4
63087: PUSH
63088: LD_VAR 0 4
63092: PUSH
63093: LD_VAR 0 8
63097: PUSH
63098: LD_VAR 0 8
63102: PUSH
63103: LD_INT 1
63105: ARRAY
63106: DIFF
63107: DIFF
63108: ST_TO_ADDR
// if tmp and not sci then
63109: LD_VAR 0 4
63113: PUSH
63114: LD_VAR 0 8
63118: NOT
63119: AND
63120: IFFALSE 63189
// begin sort := SortBySkill ( tmp , 4 ) ;
63122: LD_ADDR_VAR 0 9
63126: PUSH
63127: LD_VAR 0 4
63131: PPUSH
63132: LD_INT 4
63134: PPUSH
63135: CALL 50739 0 2
63139: ST_TO_ADDR
// if sort then
63140: LD_VAR 0 9
63144: IFFALSE 63160
// p := sort [ 1 ] ;
63146: LD_ADDR_VAR 0 11
63150: PUSH
63151: LD_VAR 0 9
63155: PUSH
63156: LD_INT 1
63158: ARRAY
63159: ST_TO_ADDR
// if p then
63160: LD_VAR 0 11
63164: IFFALSE 63189
// result := Replace ( result , 4 , p ) ;
63166: LD_ADDR_VAR 0 2
63170: PUSH
63171: LD_VAR 0 2
63175: PPUSH
63176: LD_INT 4
63178: PPUSH
63179: LD_VAR 0 11
63183: PPUSH
63184: CALL_OW 1
63188: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63189: LD_ADDR_VAR 0 4
63193: PUSH
63194: LD_VAR 0 4
63198: PUSH
63199: LD_VAR 0 7
63203: DIFF
63204: ST_TO_ADDR
// if tmp and mech < 6 then
63205: LD_VAR 0 4
63209: PUSH
63210: LD_VAR 0 7
63214: PUSH
63215: LD_INT 6
63217: LESS
63218: AND
63219: IFFALSE 63407
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63221: LD_ADDR_VAR 0 9
63225: PUSH
63226: LD_VAR 0 4
63230: PUSH
63231: LD_VAR 0 8
63235: PUSH
63236: LD_VAR 0 7
63240: UNION
63241: DIFF
63242: PPUSH
63243: LD_INT 3
63245: PPUSH
63246: CALL 50739 0 2
63250: ST_TO_ADDR
// p := [ ] ;
63251: LD_ADDR_VAR 0 11
63255: PUSH
63256: EMPTY
63257: ST_TO_ADDR
// if sort then
63258: LD_VAR 0 9
63262: IFFALSE 63378
// for i = 1 to 6 - mech do
63264: LD_ADDR_VAR 0 3
63268: PUSH
63269: DOUBLE
63270: LD_INT 1
63272: DEC
63273: ST_TO_ADDR
63274: LD_INT 6
63276: PUSH
63277: LD_VAR 0 7
63281: MINUS
63282: PUSH
63283: FOR_TO
63284: IFFALSE 63376
// begin if i = sort then
63286: LD_VAR 0 3
63290: PUSH
63291: LD_VAR 0 9
63295: EQUAL
63296: IFFALSE 63300
// break ;
63298: GO 63376
// if GetClass ( i ) = 3 then
63300: LD_VAR 0 3
63304: PPUSH
63305: CALL_OW 257
63309: PUSH
63310: LD_INT 3
63312: EQUAL
63313: IFFALSE 63317
// continue ;
63315: GO 63283
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63317: LD_ADDR_VAR 0 11
63321: PUSH
63322: LD_VAR 0 11
63326: PPUSH
63327: LD_VAR 0 11
63331: PUSH
63332: LD_INT 1
63334: PLUS
63335: PPUSH
63336: LD_VAR 0 9
63340: PUSH
63341: LD_VAR 0 3
63345: ARRAY
63346: PPUSH
63347: CALL_OW 2
63351: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63352: LD_ADDR_VAR 0 4
63356: PUSH
63357: LD_VAR 0 4
63361: PUSH
63362: LD_VAR 0 9
63366: PUSH
63367: LD_VAR 0 3
63371: ARRAY
63372: DIFF
63373: ST_TO_ADDR
// end ;
63374: GO 63283
63376: POP
63377: POP
// if p then
63378: LD_VAR 0 11
63382: IFFALSE 63407
// result := Replace ( result , 3 , p ) ;
63384: LD_ADDR_VAR 0 2
63388: PUSH
63389: LD_VAR 0 2
63393: PPUSH
63394: LD_INT 3
63396: PPUSH
63397: LD_VAR 0 11
63401: PPUSH
63402: CALL_OW 1
63406: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63407: LD_ADDR_VAR 0 4
63411: PUSH
63412: LD_VAR 0 4
63416: PUSH
63417: LD_VAR 0 6
63421: DIFF
63422: ST_TO_ADDR
// if tmp and eng < 6 then
63423: LD_VAR 0 4
63427: PUSH
63428: LD_VAR 0 6
63432: PUSH
63433: LD_INT 6
63435: LESS
63436: AND
63437: IFFALSE 63631
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63439: LD_ADDR_VAR 0 9
63443: PUSH
63444: LD_VAR 0 4
63448: PUSH
63449: LD_VAR 0 8
63453: PUSH
63454: LD_VAR 0 7
63458: UNION
63459: PUSH
63460: LD_VAR 0 6
63464: UNION
63465: DIFF
63466: PPUSH
63467: LD_INT 2
63469: PPUSH
63470: CALL 50739 0 2
63474: ST_TO_ADDR
// p := [ ] ;
63475: LD_ADDR_VAR 0 11
63479: PUSH
63480: EMPTY
63481: ST_TO_ADDR
// if sort then
63482: LD_VAR 0 9
63486: IFFALSE 63602
// for i = 1 to 6 - eng do
63488: LD_ADDR_VAR 0 3
63492: PUSH
63493: DOUBLE
63494: LD_INT 1
63496: DEC
63497: ST_TO_ADDR
63498: LD_INT 6
63500: PUSH
63501: LD_VAR 0 6
63505: MINUS
63506: PUSH
63507: FOR_TO
63508: IFFALSE 63600
// begin if i = sort then
63510: LD_VAR 0 3
63514: PUSH
63515: LD_VAR 0 9
63519: EQUAL
63520: IFFALSE 63524
// break ;
63522: GO 63600
// if GetClass ( i ) = 2 then
63524: LD_VAR 0 3
63528: PPUSH
63529: CALL_OW 257
63533: PUSH
63534: LD_INT 2
63536: EQUAL
63537: IFFALSE 63541
// continue ;
63539: GO 63507
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63541: LD_ADDR_VAR 0 11
63545: PUSH
63546: LD_VAR 0 11
63550: PPUSH
63551: LD_VAR 0 11
63555: PUSH
63556: LD_INT 1
63558: PLUS
63559: PPUSH
63560: LD_VAR 0 9
63564: PUSH
63565: LD_VAR 0 3
63569: ARRAY
63570: PPUSH
63571: CALL_OW 2
63575: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63576: LD_ADDR_VAR 0 4
63580: PUSH
63581: LD_VAR 0 4
63585: PUSH
63586: LD_VAR 0 9
63590: PUSH
63591: LD_VAR 0 3
63595: ARRAY
63596: DIFF
63597: ST_TO_ADDR
// end ;
63598: GO 63507
63600: POP
63601: POP
// if p then
63602: LD_VAR 0 11
63606: IFFALSE 63631
// result := Replace ( result , 2 , p ) ;
63608: LD_ADDR_VAR 0 2
63612: PUSH
63613: LD_VAR 0 2
63617: PPUSH
63618: LD_INT 2
63620: PPUSH
63621: LD_VAR 0 11
63625: PPUSH
63626: CALL_OW 1
63630: ST_TO_ADDR
// end ; exit ;
63631: GO 64355
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
63633: LD_EXP 87
63637: PUSH
63638: LD_EXP 86
63642: PUSH
63643: LD_VAR 0 1
63647: ARRAY
63648: ARRAY
63649: NOT
63650: PUSH
63651: LD_EXP 60
63655: PUSH
63656: LD_VAR 0 1
63660: ARRAY
63661: PPUSH
63662: LD_INT 30
63664: PUSH
63665: LD_INT 3
63667: PUSH
63668: EMPTY
63669: LIST
63670: LIST
63671: PPUSH
63672: CALL_OW 72
63676: AND
63677: PUSH
63678: LD_EXP 65
63682: PUSH
63683: LD_VAR 0 1
63687: ARRAY
63688: NOT
63689: AND
63690: IFFALSE 64355
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
63692: LD_ADDR_EXP 102
63696: PUSH
63697: LD_EXP 102
63701: PPUSH
63702: LD_VAR 0 1
63706: PPUSH
63707: LD_INT 6
63709: PPUSH
63710: CALL_OW 1
63714: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63715: LD_ADDR_VAR 0 2
63719: PUSH
63720: LD_INT 0
63722: PUSH
63723: LD_INT 0
63725: PUSH
63726: LD_INT 0
63728: PUSH
63729: LD_INT 0
63731: PUSH
63732: EMPTY
63733: LIST
63734: LIST
63735: LIST
63736: LIST
63737: ST_TO_ADDR
// if sci >= 1 then
63738: LD_VAR 0 8
63742: PUSH
63743: LD_INT 1
63745: GREATEREQUAL
63746: IFFALSE 63768
// tmp := tmp diff sci [ 1 ] ;
63748: LD_ADDR_VAR 0 4
63752: PUSH
63753: LD_VAR 0 4
63757: PUSH
63758: LD_VAR 0 8
63762: PUSH
63763: LD_INT 1
63765: ARRAY
63766: DIFF
63767: ST_TO_ADDR
// if tmp and not sci then
63768: LD_VAR 0 4
63772: PUSH
63773: LD_VAR 0 8
63777: NOT
63778: AND
63779: IFFALSE 63848
// begin sort := SortBySkill ( tmp , 4 ) ;
63781: LD_ADDR_VAR 0 9
63785: PUSH
63786: LD_VAR 0 4
63790: PPUSH
63791: LD_INT 4
63793: PPUSH
63794: CALL 50739 0 2
63798: ST_TO_ADDR
// if sort then
63799: LD_VAR 0 9
63803: IFFALSE 63819
// p := sort [ 1 ] ;
63805: LD_ADDR_VAR 0 11
63809: PUSH
63810: LD_VAR 0 9
63814: PUSH
63815: LD_INT 1
63817: ARRAY
63818: ST_TO_ADDR
// if p then
63819: LD_VAR 0 11
63823: IFFALSE 63848
// result := Replace ( result , 4 , p ) ;
63825: LD_ADDR_VAR 0 2
63829: PUSH
63830: LD_VAR 0 2
63834: PPUSH
63835: LD_INT 4
63837: PPUSH
63838: LD_VAR 0 11
63842: PPUSH
63843: CALL_OW 1
63847: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63848: LD_ADDR_VAR 0 4
63852: PUSH
63853: LD_VAR 0 4
63857: PUSH
63858: LD_VAR 0 7
63862: DIFF
63863: ST_TO_ADDR
// if tmp and mech < 6 then
63864: LD_VAR 0 4
63868: PUSH
63869: LD_VAR 0 7
63873: PUSH
63874: LD_INT 6
63876: LESS
63877: AND
63878: IFFALSE 64060
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
63880: LD_ADDR_VAR 0 9
63884: PUSH
63885: LD_VAR 0 4
63889: PUSH
63890: LD_VAR 0 7
63894: DIFF
63895: PPUSH
63896: LD_INT 3
63898: PPUSH
63899: CALL 50739 0 2
63903: ST_TO_ADDR
// p := [ ] ;
63904: LD_ADDR_VAR 0 11
63908: PUSH
63909: EMPTY
63910: ST_TO_ADDR
// if sort then
63911: LD_VAR 0 9
63915: IFFALSE 64031
// for i = 1 to 6 - mech do
63917: LD_ADDR_VAR 0 3
63921: PUSH
63922: DOUBLE
63923: LD_INT 1
63925: DEC
63926: ST_TO_ADDR
63927: LD_INT 6
63929: PUSH
63930: LD_VAR 0 7
63934: MINUS
63935: PUSH
63936: FOR_TO
63937: IFFALSE 64029
// begin if i = sort then
63939: LD_VAR 0 3
63943: PUSH
63944: LD_VAR 0 9
63948: EQUAL
63949: IFFALSE 63953
// break ;
63951: GO 64029
// if GetClass ( i ) = 3 then
63953: LD_VAR 0 3
63957: PPUSH
63958: CALL_OW 257
63962: PUSH
63963: LD_INT 3
63965: EQUAL
63966: IFFALSE 63970
// continue ;
63968: GO 63936
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63970: LD_ADDR_VAR 0 11
63974: PUSH
63975: LD_VAR 0 11
63979: PPUSH
63980: LD_VAR 0 11
63984: PUSH
63985: LD_INT 1
63987: PLUS
63988: PPUSH
63989: LD_VAR 0 9
63993: PUSH
63994: LD_VAR 0 3
63998: ARRAY
63999: PPUSH
64000: CALL_OW 2
64004: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64005: LD_ADDR_VAR 0 4
64009: PUSH
64010: LD_VAR 0 4
64014: PUSH
64015: LD_VAR 0 9
64019: PUSH
64020: LD_VAR 0 3
64024: ARRAY
64025: DIFF
64026: ST_TO_ADDR
// end ;
64027: GO 63936
64029: POP
64030: POP
// if p then
64031: LD_VAR 0 11
64035: IFFALSE 64060
// result := Replace ( result , 3 , p ) ;
64037: LD_ADDR_VAR 0 2
64041: PUSH
64042: LD_VAR 0 2
64046: PPUSH
64047: LD_INT 3
64049: PPUSH
64050: LD_VAR 0 11
64054: PPUSH
64055: CALL_OW 1
64059: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64060: LD_ADDR_VAR 0 4
64064: PUSH
64065: LD_VAR 0 4
64069: PUSH
64070: LD_VAR 0 6
64074: DIFF
64075: ST_TO_ADDR
// if tmp and eng < 4 then
64076: LD_VAR 0 4
64080: PUSH
64081: LD_VAR 0 6
64085: PUSH
64086: LD_INT 4
64088: LESS
64089: AND
64090: IFFALSE 64280
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
64092: LD_ADDR_VAR 0 9
64096: PUSH
64097: LD_VAR 0 4
64101: PUSH
64102: LD_VAR 0 7
64106: PUSH
64107: LD_VAR 0 6
64111: UNION
64112: DIFF
64113: PPUSH
64114: LD_INT 2
64116: PPUSH
64117: CALL 50739 0 2
64121: ST_TO_ADDR
// p := [ ] ;
64122: LD_ADDR_VAR 0 11
64126: PUSH
64127: EMPTY
64128: ST_TO_ADDR
// if sort then
64129: LD_VAR 0 9
64133: IFFALSE 64249
// for i = 1 to 4 - eng do
64135: LD_ADDR_VAR 0 3
64139: PUSH
64140: DOUBLE
64141: LD_INT 1
64143: DEC
64144: ST_TO_ADDR
64145: LD_INT 4
64147: PUSH
64148: LD_VAR 0 6
64152: MINUS
64153: PUSH
64154: FOR_TO
64155: IFFALSE 64247
// begin if i = sort then
64157: LD_VAR 0 3
64161: PUSH
64162: LD_VAR 0 9
64166: EQUAL
64167: IFFALSE 64171
// break ;
64169: GO 64247
// if GetClass ( i ) = 2 then
64171: LD_VAR 0 3
64175: PPUSH
64176: CALL_OW 257
64180: PUSH
64181: LD_INT 2
64183: EQUAL
64184: IFFALSE 64188
// continue ;
64186: GO 64154
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64188: LD_ADDR_VAR 0 11
64192: PUSH
64193: LD_VAR 0 11
64197: PPUSH
64198: LD_VAR 0 11
64202: PUSH
64203: LD_INT 1
64205: PLUS
64206: PPUSH
64207: LD_VAR 0 9
64211: PUSH
64212: LD_VAR 0 3
64216: ARRAY
64217: PPUSH
64218: CALL_OW 2
64222: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64223: LD_ADDR_VAR 0 4
64227: PUSH
64228: LD_VAR 0 4
64232: PUSH
64233: LD_VAR 0 9
64237: PUSH
64238: LD_VAR 0 3
64242: ARRAY
64243: DIFF
64244: ST_TO_ADDR
// end ;
64245: GO 64154
64247: POP
64248: POP
// if p then
64249: LD_VAR 0 11
64253: IFFALSE 64278
// result := Replace ( result , 2 , p ) ;
64255: LD_ADDR_VAR 0 2
64259: PUSH
64260: LD_VAR 0 2
64264: PPUSH
64265: LD_INT 2
64267: PPUSH
64268: LD_VAR 0 11
64272: PPUSH
64273: CALL_OW 1
64277: ST_TO_ADDR
// end else
64278: GO 64324
// for i = eng downto 5 do
64280: LD_ADDR_VAR 0 3
64284: PUSH
64285: DOUBLE
64286: LD_VAR 0 6
64290: INC
64291: ST_TO_ADDR
64292: LD_INT 5
64294: PUSH
64295: FOR_DOWNTO
64296: IFFALSE 64322
// tmp := tmp union eng [ i ] ;
64298: LD_ADDR_VAR 0 4
64302: PUSH
64303: LD_VAR 0 4
64307: PUSH
64308: LD_VAR 0 6
64312: PUSH
64313: LD_VAR 0 3
64317: ARRAY
64318: UNION
64319: ST_TO_ADDR
64320: GO 64295
64322: POP
64323: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
64324: LD_ADDR_VAR 0 2
64328: PUSH
64329: LD_VAR 0 2
64333: PPUSH
64334: LD_INT 1
64336: PPUSH
64337: LD_VAR 0 4
64341: PUSH
64342: LD_VAR 0 5
64346: DIFF
64347: PPUSH
64348: CALL_OW 1
64352: ST_TO_ADDR
// exit ;
64353: GO 64355
// end ; end ;
64355: LD_VAR 0 2
64359: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
64360: LD_INT 0
64362: PPUSH
64363: PPUSH
64364: PPUSH
// if not mc_bases then
64365: LD_EXP 60
64369: NOT
64370: IFFALSE 64374
// exit ;
64372: GO 64516
// for i = 1 to mc_bases do
64374: LD_ADDR_VAR 0 2
64378: PUSH
64379: DOUBLE
64380: LD_INT 1
64382: DEC
64383: ST_TO_ADDR
64384: LD_EXP 60
64388: PUSH
64389: FOR_TO
64390: IFFALSE 64507
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64392: LD_ADDR_VAR 0 3
64396: PUSH
64397: LD_EXP 60
64401: PUSH
64402: LD_VAR 0 2
64406: ARRAY
64407: PPUSH
64408: LD_INT 21
64410: PUSH
64411: LD_INT 3
64413: PUSH
64414: EMPTY
64415: LIST
64416: LIST
64417: PUSH
64418: LD_INT 3
64420: PUSH
64421: LD_INT 2
64423: PUSH
64424: LD_INT 30
64426: PUSH
64427: LD_INT 29
64429: PUSH
64430: EMPTY
64431: LIST
64432: LIST
64433: PUSH
64434: LD_INT 30
64436: PUSH
64437: LD_INT 30
64439: PUSH
64440: EMPTY
64441: LIST
64442: LIST
64443: PUSH
64444: EMPTY
64445: LIST
64446: LIST
64447: LIST
64448: PUSH
64449: EMPTY
64450: LIST
64451: LIST
64452: PUSH
64453: LD_INT 3
64455: PUSH
64456: LD_INT 24
64458: PUSH
64459: LD_INT 1000
64461: PUSH
64462: EMPTY
64463: LIST
64464: LIST
64465: PUSH
64466: EMPTY
64467: LIST
64468: LIST
64469: PUSH
64470: EMPTY
64471: LIST
64472: LIST
64473: LIST
64474: PPUSH
64475: CALL_OW 72
64479: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
64480: LD_ADDR_EXP 61
64484: PUSH
64485: LD_EXP 61
64489: PPUSH
64490: LD_VAR 0 2
64494: PPUSH
64495: LD_VAR 0 3
64499: PPUSH
64500: CALL_OW 1
64504: ST_TO_ADDR
// end ;
64505: GO 64389
64507: POP
64508: POP
// RaiseSailEvent ( 101 ) ;
64509: LD_INT 101
64511: PPUSH
64512: CALL_OW 427
// end ;
64516: LD_VAR 0 1
64520: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
64521: LD_INT 0
64523: PPUSH
64524: PPUSH
64525: PPUSH
64526: PPUSH
64527: PPUSH
64528: PPUSH
64529: PPUSH
// if not mc_bases then
64530: LD_EXP 60
64534: NOT
64535: IFFALSE 64539
// exit ;
64537: GO 65101
// for i = 1 to mc_bases do
64539: LD_ADDR_VAR 0 2
64543: PUSH
64544: DOUBLE
64545: LD_INT 1
64547: DEC
64548: ST_TO_ADDR
64549: LD_EXP 60
64553: PUSH
64554: FOR_TO
64555: IFFALSE 65092
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
64557: LD_ADDR_VAR 0 5
64561: PUSH
64562: LD_EXP 60
64566: PUSH
64567: LD_VAR 0 2
64571: ARRAY
64572: PUSH
64573: LD_EXP 89
64577: PUSH
64578: LD_VAR 0 2
64582: ARRAY
64583: UNION
64584: PPUSH
64585: LD_INT 21
64587: PUSH
64588: LD_INT 1
64590: PUSH
64591: EMPTY
64592: LIST
64593: LIST
64594: PUSH
64595: LD_INT 1
64597: PUSH
64598: LD_INT 3
64600: PUSH
64601: LD_INT 54
64603: PUSH
64604: EMPTY
64605: LIST
64606: PUSH
64607: EMPTY
64608: LIST
64609: LIST
64610: PUSH
64611: LD_INT 3
64613: PUSH
64614: LD_INT 24
64616: PUSH
64617: LD_INT 1000
64619: PUSH
64620: EMPTY
64621: LIST
64622: LIST
64623: PUSH
64624: EMPTY
64625: LIST
64626: LIST
64627: PUSH
64628: EMPTY
64629: LIST
64630: LIST
64631: LIST
64632: PUSH
64633: EMPTY
64634: LIST
64635: LIST
64636: PPUSH
64637: CALL_OW 72
64641: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
64642: LD_ADDR_VAR 0 6
64646: PUSH
64647: LD_EXP 60
64651: PUSH
64652: LD_VAR 0 2
64656: ARRAY
64657: PPUSH
64658: LD_INT 21
64660: PUSH
64661: LD_INT 1
64663: PUSH
64664: EMPTY
64665: LIST
64666: LIST
64667: PUSH
64668: LD_INT 1
64670: PUSH
64671: LD_INT 3
64673: PUSH
64674: LD_INT 54
64676: PUSH
64677: EMPTY
64678: LIST
64679: PUSH
64680: EMPTY
64681: LIST
64682: LIST
64683: PUSH
64684: LD_INT 3
64686: PUSH
64687: LD_INT 24
64689: PUSH
64690: LD_INT 250
64692: PUSH
64693: EMPTY
64694: LIST
64695: LIST
64696: PUSH
64697: EMPTY
64698: LIST
64699: LIST
64700: PUSH
64701: EMPTY
64702: LIST
64703: LIST
64704: LIST
64705: PUSH
64706: EMPTY
64707: LIST
64708: LIST
64709: PPUSH
64710: CALL_OW 72
64714: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
64715: LD_ADDR_VAR 0 7
64719: PUSH
64720: LD_VAR 0 5
64724: PUSH
64725: LD_VAR 0 6
64729: DIFF
64730: ST_TO_ADDR
// if not need_heal_1 then
64731: LD_VAR 0 6
64735: NOT
64736: IFFALSE 64769
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
64738: LD_ADDR_EXP 63
64742: PUSH
64743: LD_EXP 63
64747: PPUSH
64748: LD_VAR 0 2
64752: PUSH
64753: LD_INT 1
64755: PUSH
64756: EMPTY
64757: LIST
64758: LIST
64759: PPUSH
64760: EMPTY
64761: PPUSH
64762: CALL 19991 0 3
64766: ST_TO_ADDR
64767: GO 64839
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
64769: LD_ADDR_EXP 63
64773: PUSH
64774: LD_EXP 63
64778: PPUSH
64779: LD_VAR 0 2
64783: PUSH
64784: LD_INT 1
64786: PUSH
64787: EMPTY
64788: LIST
64789: LIST
64790: PPUSH
64791: LD_EXP 63
64795: PUSH
64796: LD_VAR 0 2
64800: ARRAY
64801: PUSH
64802: LD_INT 1
64804: ARRAY
64805: PPUSH
64806: LD_INT 3
64808: PUSH
64809: LD_INT 24
64811: PUSH
64812: LD_INT 1000
64814: PUSH
64815: EMPTY
64816: LIST
64817: LIST
64818: PUSH
64819: EMPTY
64820: LIST
64821: LIST
64822: PPUSH
64823: CALL_OW 72
64827: PUSH
64828: LD_VAR 0 6
64832: UNION
64833: PPUSH
64834: CALL 19991 0 3
64838: ST_TO_ADDR
// if not need_heal_2 then
64839: LD_VAR 0 7
64843: NOT
64844: IFFALSE 64877
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
64846: LD_ADDR_EXP 63
64850: PUSH
64851: LD_EXP 63
64855: PPUSH
64856: LD_VAR 0 2
64860: PUSH
64861: LD_INT 2
64863: PUSH
64864: EMPTY
64865: LIST
64866: LIST
64867: PPUSH
64868: EMPTY
64869: PPUSH
64870: CALL 19991 0 3
64874: ST_TO_ADDR
64875: GO 64909
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
64877: LD_ADDR_EXP 63
64881: PUSH
64882: LD_EXP 63
64886: PPUSH
64887: LD_VAR 0 2
64891: PUSH
64892: LD_INT 2
64894: PUSH
64895: EMPTY
64896: LIST
64897: LIST
64898: PPUSH
64899: LD_VAR 0 7
64903: PPUSH
64904: CALL 19991 0 3
64908: ST_TO_ADDR
// if need_heal_2 then
64909: LD_VAR 0 7
64913: IFFALSE 65074
// for j in need_heal_2 do
64915: LD_ADDR_VAR 0 3
64919: PUSH
64920: LD_VAR 0 7
64924: PUSH
64925: FOR_IN
64926: IFFALSE 65072
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64928: LD_ADDR_VAR 0 5
64932: PUSH
64933: LD_EXP 60
64937: PUSH
64938: LD_VAR 0 2
64942: ARRAY
64943: PPUSH
64944: LD_INT 2
64946: PUSH
64947: LD_INT 30
64949: PUSH
64950: LD_INT 6
64952: PUSH
64953: EMPTY
64954: LIST
64955: LIST
64956: PUSH
64957: LD_INT 30
64959: PUSH
64960: LD_INT 7
64962: PUSH
64963: EMPTY
64964: LIST
64965: LIST
64966: PUSH
64967: LD_INT 30
64969: PUSH
64970: LD_INT 8
64972: PUSH
64973: EMPTY
64974: LIST
64975: LIST
64976: PUSH
64977: LD_INT 30
64979: PUSH
64980: LD_INT 0
64982: PUSH
64983: EMPTY
64984: LIST
64985: LIST
64986: PUSH
64987: LD_INT 30
64989: PUSH
64990: LD_INT 1
64992: PUSH
64993: EMPTY
64994: LIST
64995: LIST
64996: PUSH
64997: EMPTY
64998: LIST
64999: LIST
65000: LIST
65001: LIST
65002: LIST
65003: LIST
65004: PPUSH
65005: CALL_OW 72
65009: ST_TO_ADDR
// if tmp then
65010: LD_VAR 0 5
65014: IFFALSE 65070
// begin k := NearestUnitToUnit ( tmp , j ) ;
65016: LD_ADDR_VAR 0 4
65020: PUSH
65021: LD_VAR 0 5
65025: PPUSH
65026: LD_VAR 0 3
65030: PPUSH
65031: CALL_OW 74
65035: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
65036: LD_VAR 0 3
65040: PPUSH
65041: LD_VAR 0 4
65045: PPUSH
65046: CALL_OW 296
65050: PUSH
65051: LD_INT 5
65053: GREATER
65054: IFFALSE 65070
// ComMoveToNearbyEntrance ( j , k ) ;
65056: LD_VAR 0 3
65060: PPUSH
65061: LD_VAR 0 4
65065: PPUSH
65066: CALL 53107 0 2
// end ; end ;
65070: GO 64925
65072: POP
65073: POP
// if not need_heal_1 and not need_heal_2 then
65074: LD_VAR 0 6
65078: NOT
65079: PUSH
65080: LD_VAR 0 7
65084: NOT
65085: AND
65086: IFFALSE 65090
// continue ;
65088: GO 64554
// end ;
65090: GO 64554
65092: POP
65093: POP
// RaiseSailEvent ( 102 ) ;
65094: LD_INT 102
65096: PPUSH
65097: CALL_OW 427
// end ;
65101: LD_VAR 0 1
65105: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
65106: LD_INT 0
65108: PPUSH
65109: PPUSH
65110: PPUSH
65111: PPUSH
65112: PPUSH
65113: PPUSH
65114: PPUSH
65115: PPUSH
// if not mc_bases then
65116: LD_EXP 60
65120: NOT
65121: IFFALSE 65125
// exit ;
65123: GO 66004
// for i = 1 to mc_bases do
65125: LD_ADDR_VAR 0 2
65129: PUSH
65130: DOUBLE
65131: LD_INT 1
65133: DEC
65134: ST_TO_ADDR
65135: LD_EXP 60
65139: PUSH
65140: FOR_TO
65141: IFFALSE 66002
// begin if not mc_building_need_repair [ i ] then
65143: LD_EXP 61
65147: PUSH
65148: LD_VAR 0 2
65152: ARRAY
65153: NOT
65154: IFFALSE 65339
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
65156: LD_ADDR_VAR 0 6
65160: PUSH
65161: LD_EXP 79
65165: PUSH
65166: LD_VAR 0 2
65170: ARRAY
65171: PPUSH
65172: LD_INT 3
65174: PUSH
65175: LD_INT 24
65177: PUSH
65178: LD_INT 1000
65180: PUSH
65181: EMPTY
65182: LIST
65183: LIST
65184: PUSH
65185: EMPTY
65186: LIST
65187: LIST
65188: PUSH
65189: LD_INT 2
65191: PUSH
65192: LD_INT 34
65194: PUSH
65195: LD_INT 13
65197: PUSH
65198: EMPTY
65199: LIST
65200: LIST
65201: PUSH
65202: LD_INT 34
65204: PUSH
65205: LD_INT 52
65207: PUSH
65208: EMPTY
65209: LIST
65210: LIST
65211: PUSH
65212: LD_INT 34
65214: PUSH
65215: LD_INT 88
65217: PUSH
65218: EMPTY
65219: LIST
65220: LIST
65221: PUSH
65222: EMPTY
65223: LIST
65224: LIST
65225: LIST
65226: LIST
65227: PUSH
65228: EMPTY
65229: LIST
65230: LIST
65231: PPUSH
65232: CALL_OW 72
65236: ST_TO_ADDR
// if cranes then
65237: LD_VAR 0 6
65241: IFFALSE 65303
// for j in cranes do
65243: LD_ADDR_VAR 0 3
65247: PUSH
65248: LD_VAR 0 6
65252: PUSH
65253: FOR_IN
65254: IFFALSE 65301
// if not IsInArea ( j , mc_parking [ i ] ) then
65256: LD_VAR 0 3
65260: PPUSH
65261: LD_EXP 84
65265: PUSH
65266: LD_VAR 0 2
65270: ARRAY
65271: PPUSH
65272: CALL_OW 308
65276: NOT
65277: IFFALSE 65299
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65279: LD_VAR 0 3
65283: PPUSH
65284: LD_EXP 84
65288: PUSH
65289: LD_VAR 0 2
65293: ARRAY
65294: PPUSH
65295: CALL_OW 113
65299: GO 65253
65301: POP
65302: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
65303: LD_ADDR_EXP 62
65307: PUSH
65308: LD_EXP 62
65312: PPUSH
65313: LD_VAR 0 2
65317: PPUSH
65318: EMPTY
65319: PPUSH
65320: CALL_OW 1
65324: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
65325: LD_VAR 0 2
65329: PPUSH
65330: LD_INT 101
65332: PPUSH
65333: CALL 60193 0 2
// continue ;
65337: GO 65140
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
65339: LD_ADDR_EXP 66
65343: PUSH
65344: LD_EXP 66
65348: PPUSH
65349: LD_VAR 0 2
65353: PPUSH
65354: EMPTY
65355: PPUSH
65356: CALL_OW 1
65360: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65361: LD_VAR 0 2
65365: PPUSH
65366: LD_INT 103
65368: PPUSH
65369: CALL 60193 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
65373: LD_ADDR_VAR 0 5
65377: PUSH
65378: LD_EXP 60
65382: PUSH
65383: LD_VAR 0 2
65387: ARRAY
65388: PUSH
65389: LD_EXP 89
65393: PUSH
65394: LD_VAR 0 2
65398: ARRAY
65399: UNION
65400: PPUSH
65401: LD_INT 2
65403: PUSH
65404: LD_INT 25
65406: PUSH
65407: LD_INT 2
65409: PUSH
65410: EMPTY
65411: LIST
65412: LIST
65413: PUSH
65414: LD_INT 25
65416: PUSH
65417: LD_INT 16
65419: PUSH
65420: EMPTY
65421: LIST
65422: LIST
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: LIST
65428: PUSH
65429: EMPTY
65430: LIST
65431: PPUSH
65432: CALL_OW 72
65436: ST_TO_ADDR
// if mc_need_heal [ i ] then
65437: LD_EXP 63
65441: PUSH
65442: LD_VAR 0 2
65446: ARRAY
65447: IFFALSE 65491
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
65449: LD_ADDR_VAR 0 5
65453: PUSH
65454: LD_VAR 0 5
65458: PUSH
65459: LD_EXP 63
65463: PUSH
65464: LD_VAR 0 2
65468: ARRAY
65469: PUSH
65470: LD_INT 1
65472: ARRAY
65473: PUSH
65474: LD_EXP 63
65478: PUSH
65479: LD_VAR 0 2
65483: ARRAY
65484: PUSH
65485: LD_INT 2
65487: ARRAY
65488: UNION
65489: DIFF
65490: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
65491: LD_ADDR_VAR 0 6
65495: PUSH
65496: LD_EXP 79
65500: PUSH
65501: LD_VAR 0 2
65505: ARRAY
65506: PPUSH
65507: LD_INT 2
65509: PUSH
65510: LD_INT 34
65512: PUSH
65513: LD_INT 13
65515: PUSH
65516: EMPTY
65517: LIST
65518: LIST
65519: PUSH
65520: LD_INT 34
65522: PUSH
65523: LD_INT 52
65525: PUSH
65526: EMPTY
65527: LIST
65528: LIST
65529: PUSH
65530: LD_INT 34
65532: PUSH
65533: LD_INT 88
65535: PUSH
65536: EMPTY
65537: LIST
65538: LIST
65539: PUSH
65540: EMPTY
65541: LIST
65542: LIST
65543: LIST
65544: LIST
65545: PPUSH
65546: CALL_OW 72
65550: ST_TO_ADDR
// if cranes then
65551: LD_VAR 0 6
65555: IFFALSE 65691
// begin for j in cranes do
65557: LD_ADDR_VAR 0 3
65561: PUSH
65562: LD_VAR 0 6
65566: PUSH
65567: FOR_IN
65568: IFFALSE 65689
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
65570: LD_VAR 0 3
65574: PPUSH
65575: CALL_OW 256
65579: PUSH
65580: LD_INT 1000
65582: EQUAL
65583: PUSH
65584: LD_VAR 0 3
65588: PPUSH
65589: CALL_OW 314
65593: NOT
65594: AND
65595: IFFALSE 65629
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
65597: LD_VAR 0 3
65601: PPUSH
65602: LD_EXP 61
65606: PUSH
65607: LD_VAR 0 2
65611: ARRAY
65612: PPUSH
65613: LD_VAR 0 3
65617: PPUSH
65618: CALL_OW 74
65622: PPUSH
65623: CALL_OW 130
65627: GO 65687
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
65629: LD_VAR 0 3
65633: PPUSH
65634: CALL_OW 256
65638: PUSH
65639: LD_INT 500
65641: LESS
65642: PUSH
65643: LD_VAR 0 3
65647: PPUSH
65648: LD_EXP 84
65652: PUSH
65653: LD_VAR 0 2
65657: ARRAY
65658: PPUSH
65659: CALL_OW 308
65663: NOT
65664: AND
65665: IFFALSE 65687
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65667: LD_VAR 0 3
65671: PPUSH
65672: LD_EXP 84
65676: PUSH
65677: LD_VAR 0 2
65681: ARRAY
65682: PPUSH
65683: CALL_OW 113
// end ;
65687: GO 65567
65689: POP
65690: POP
// end ; if tmp > 3 then
65691: LD_VAR 0 5
65695: PUSH
65696: LD_INT 3
65698: GREATER
65699: IFFALSE 65719
// tmp := ShrinkArray ( tmp , 4 ) ;
65701: LD_ADDR_VAR 0 5
65705: PUSH
65706: LD_VAR 0 5
65710: PPUSH
65711: LD_INT 4
65713: PPUSH
65714: CALL 52545 0 2
65718: ST_TO_ADDR
// if not tmp then
65719: LD_VAR 0 5
65723: NOT
65724: IFFALSE 65728
// continue ;
65726: GO 65140
// for j in tmp do
65728: LD_ADDR_VAR 0 3
65732: PUSH
65733: LD_VAR 0 5
65737: PUSH
65738: FOR_IN
65739: IFFALSE 65998
// begin if IsInUnit ( j ) then
65741: LD_VAR 0 3
65745: PPUSH
65746: CALL_OW 310
65750: IFFALSE 65761
// ComExitBuilding ( j ) ;
65752: LD_VAR 0 3
65756: PPUSH
65757: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
65761: LD_VAR 0 3
65765: PUSH
65766: LD_EXP 62
65770: PUSH
65771: LD_VAR 0 2
65775: ARRAY
65776: IN
65777: NOT
65778: IFFALSE 65836
// begin SetTag ( j , 101 ) ;
65780: LD_VAR 0 3
65784: PPUSH
65785: LD_INT 101
65787: PPUSH
65788: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
65792: LD_ADDR_EXP 62
65796: PUSH
65797: LD_EXP 62
65801: PPUSH
65802: LD_VAR 0 2
65806: PUSH
65807: LD_EXP 62
65811: PUSH
65812: LD_VAR 0 2
65816: ARRAY
65817: PUSH
65818: LD_INT 1
65820: PLUS
65821: PUSH
65822: EMPTY
65823: LIST
65824: LIST
65825: PPUSH
65826: LD_VAR 0 3
65830: PPUSH
65831: CALL 19991 0 3
65835: ST_TO_ADDR
// end ; wait ( 1 ) ;
65836: LD_INT 1
65838: PPUSH
65839: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
65843: LD_ADDR_VAR 0 7
65847: PUSH
65848: LD_EXP 61
65852: PUSH
65853: LD_VAR 0 2
65857: ARRAY
65858: ST_TO_ADDR
// if mc_scan [ i ] then
65859: LD_EXP 83
65863: PUSH
65864: LD_VAR 0 2
65868: ARRAY
65869: IFFALSE 65931
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
65871: LD_ADDR_VAR 0 7
65875: PUSH
65876: LD_EXP 61
65880: PUSH
65881: LD_VAR 0 2
65885: ARRAY
65886: PPUSH
65887: LD_INT 3
65889: PUSH
65890: LD_INT 30
65892: PUSH
65893: LD_INT 32
65895: PUSH
65896: EMPTY
65897: LIST
65898: LIST
65899: PUSH
65900: LD_INT 30
65902: PUSH
65903: LD_INT 33
65905: PUSH
65906: EMPTY
65907: LIST
65908: LIST
65909: PUSH
65910: LD_INT 30
65912: PUSH
65913: LD_INT 31
65915: PUSH
65916: EMPTY
65917: LIST
65918: LIST
65919: PUSH
65920: EMPTY
65921: LIST
65922: LIST
65923: LIST
65924: LIST
65925: PPUSH
65926: CALL_OW 72
65930: ST_TO_ADDR
// if not to_repair_tmp then
65931: LD_VAR 0 7
65935: NOT
65936: IFFALSE 65940
// continue ;
65938: GO 65738
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
65940: LD_ADDR_VAR 0 8
65944: PUSH
65945: LD_VAR 0 7
65949: PPUSH
65950: LD_VAR 0 3
65954: PPUSH
65955: CALL_OW 74
65959: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
65960: LD_VAR 0 8
65964: PPUSH
65965: LD_INT 16
65967: PPUSH
65968: CALL 22588 0 2
65972: PUSH
65973: LD_INT 4
65975: ARRAY
65976: PUSH
65977: LD_INT 10
65979: LESS
65980: IFFALSE 65996
// ComRepairBuilding ( j , to_repair ) ;
65982: LD_VAR 0 3
65986: PPUSH
65987: LD_VAR 0 8
65991: PPUSH
65992: CALL_OW 130
// end ;
65996: GO 65738
65998: POP
65999: POP
// end ;
66000: GO 65140
66002: POP
66003: POP
// end ;
66004: LD_VAR 0 1
66008: RET
// export function MC_Heal ; var i , j , tmp ; begin
66009: LD_INT 0
66011: PPUSH
66012: PPUSH
66013: PPUSH
66014: PPUSH
// if not mc_bases then
66015: LD_EXP 60
66019: NOT
66020: IFFALSE 66024
// exit ;
66022: GO 66426
// for i = 1 to mc_bases do
66024: LD_ADDR_VAR 0 2
66028: PUSH
66029: DOUBLE
66030: LD_INT 1
66032: DEC
66033: ST_TO_ADDR
66034: LD_EXP 60
66038: PUSH
66039: FOR_TO
66040: IFFALSE 66424
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
66042: LD_EXP 63
66046: PUSH
66047: LD_VAR 0 2
66051: ARRAY
66052: PUSH
66053: LD_INT 1
66055: ARRAY
66056: NOT
66057: PUSH
66058: LD_EXP 63
66062: PUSH
66063: LD_VAR 0 2
66067: ARRAY
66068: PUSH
66069: LD_INT 2
66071: ARRAY
66072: NOT
66073: AND
66074: IFFALSE 66112
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
66076: LD_ADDR_EXP 64
66080: PUSH
66081: LD_EXP 64
66085: PPUSH
66086: LD_VAR 0 2
66090: PPUSH
66091: EMPTY
66092: PPUSH
66093: CALL_OW 1
66097: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
66098: LD_VAR 0 2
66102: PPUSH
66103: LD_INT 102
66105: PPUSH
66106: CALL 60193 0 2
// continue ;
66110: GO 66039
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
66112: LD_ADDR_VAR 0 4
66116: PUSH
66117: LD_EXP 60
66121: PUSH
66122: LD_VAR 0 2
66126: ARRAY
66127: PPUSH
66128: LD_INT 25
66130: PUSH
66131: LD_INT 4
66133: PUSH
66134: EMPTY
66135: LIST
66136: LIST
66137: PPUSH
66138: CALL_OW 72
66142: ST_TO_ADDR
// if not tmp then
66143: LD_VAR 0 4
66147: NOT
66148: IFFALSE 66152
// continue ;
66150: GO 66039
// if mc_taming [ i ] then
66152: LD_EXP 91
66156: PUSH
66157: LD_VAR 0 2
66161: ARRAY
66162: IFFALSE 66186
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66164: LD_ADDR_EXP 91
66168: PUSH
66169: LD_EXP 91
66173: PPUSH
66174: LD_VAR 0 2
66178: PPUSH
66179: EMPTY
66180: PPUSH
66181: CALL_OW 1
66185: ST_TO_ADDR
// for j in tmp do
66186: LD_ADDR_VAR 0 3
66190: PUSH
66191: LD_VAR 0 4
66195: PUSH
66196: FOR_IN
66197: IFFALSE 66420
// begin if IsInUnit ( j ) then
66199: LD_VAR 0 3
66203: PPUSH
66204: CALL_OW 310
66208: IFFALSE 66219
// ComExitBuilding ( j ) ;
66210: LD_VAR 0 3
66214: PPUSH
66215: CALL_OW 122
// if not j in mc_healers [ i ] then
66219: LD_VAR 0 3
66223: PUSH
66224: LD_EXP 64
66228: PUSH
66229: LD_VAR 0 2
66233: ARRAY
66234: IN
66235: NOT
66236: IFFALSE 66282
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
66238: LD_ADDR_EXP 64
66242: PUSH
66243: LD_EXP 64
66247: PPUSH
66248: LD_VAR 0 2
66252: PUSH
66253: LD_EXP 64
66257: PUSH
66258: LD_VAR 0 2
66262: ARRAY
66263: PUSH
66264: LD_INT 1
66266: PLUS
66267: PUSH
66268: EMPTY
66269: LIST
66270: LIST
66271: PPUSH
66272: LD_VAR 0 3
66276: PPUSH
66277: CALL 19991 0 3
66281: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
66282: LD_VAR 0 3
66286: PPUSH
66287: CALL_OW 110
66291: PUSH
66292: LD_INT 102
66294: NONEQUAL
66295: IFFALSE 66309
// SetTag ( j , 102 ) ;
66297: LD_VAR 0 3
66301: PPUSH
66302: LD_INT 102
66304: PPUSH
66305: CALL_OW 109
// Wait ( 3 ) ;
66309: LD_INT 3
66311: PPUSH
66312: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
66316: LD_EXP 63
66320: PUSH
66321: LD_VAR 0 2
66325: ARRAY
66326: PUSH
66327: LD_INT 1
66329: ARRAY
66330: IFFALSE 66362
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
66332: LD_VAR 0 3
66336: PPUSH
66337: LD_EXP 63
66341: PUSH
66342: LD_VAR 0 2
66346: ARRAY
66347: PUSH
66348: LD_INT 1
66350: ARRAY
66351: PUSH
66352: LD_INT 1
66354: ARRAY
66355: PPUSH
66356: CALL_OW 128
66360: GO 66418
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
66362: LD_VAR 0 3
66366: PPUSH
66367: CALL_OW 314
66371: NOT
66372: PUSH
66373: LD_EXP 63
66377: PUSH
66378: LD_VAR 0 2
66382: ARRAY
66383: PUSH
66384: LD_INT 2
66386: ARRAY
66387: AND
66388: IFFALSE 66418
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
66390: LD_VAR 0 3
66394: PPUSH
66395: LD_EXP 63
66399: PUSH
66400: LD_VAR 0 2
66404: ARRAY
66405: PUSH
66406: LD_INT 2
66408: ARRAY
66409: PUSH
66410: LD_INT 1
66412: ARRAY
66413: PPUSH
66414: CALL_OW 128
// end ;
66418: GO 66196
66420: POP
66421: POP
// end ;
66422: GO 66039
66424: POP
66425: POP
// end ;
66426: LD_VAR 0 1
66430: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
66431: LD_INT 0
66433: PPUSH
66434: PPUSH
66435: PPUSH
66436: PPUSH
66437: PPUSH
// if not mc_bases then
66438: LD_EXP 60
66442: NOT
66443: IFFALSE 66447
// exit ;
66445: GO 67618
// for i = 1 to mc_bases do
66447: LD_ADDR_VAR 0 2
66451: PUSH
66452: DOUBLE
66453: LD_INT 1
66455: DEC
66456: ST_TO_ADDR
66457: LD_EXP 60
66461: PUSH
66462: FOR_TO
66463: IFFALSE 67616
// begin if mc_scan [ i ] then
66465: LD_EXP 83
66469: PUSH
66470: LD_VAR 0 2
66474: ARRAY
66475: IFFALSE 66479
// continue ;
66477: GO 66462
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
66479: LD_EXP 65
66483: PUSH
66484: LD_VAR 0 2
66488: ARRAY
66489: NOT
66490: PUSH
66491: LD_EXP 67
66495: PUSH
66496: LD_VAR 0 2
66500: ARRAY
66501: NOT
66502: AND
66503: PUSH
66504: LD_EXP 66
66508: PUSH
66509: LD_VAR 0 2
66513: ARRAY
66514: AND
66515: IFFALSE 66553
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
66517: LD_ADDR_EXP 66
66521: PUSH
66522: LD_EXP 66
66526: PPUSH
66527: LD_VAR 0 2
66531: PPUSH
66532: EMPTY
66533: PPUSH
66534: CALL_OW 1
66538: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66539: LD_VAR 0 2
66543: PPUSH
66544: LD_INT 103
66546: PPUSH
66547: CALL 60193 0 2
// continue ;
66551: GO 66462
// end ; if mc_construct_list [ i ] then
66553: LD_EXP 67
66557: PUSH
66558: LD_VAR 0 2
66562: ARRAY
66563: IFFALSE 66783
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66565: LD_ADDR_VAR 0 4
66569: PUSH
66570: LD_EXP 60
66574: PUSH
66575: LD_VAR 0 2
66579: ARRAY
66580: PPUSH
66581: LD_INT 25
66583: PUSH
66584: LD_INT 2
66586: PUSH
66587: EMPTY
66588: LIST
66589: LIST
66590: PPUSH
66591: CALL_OW 72
66595: PUSH
66596: LD_EXP 62
66600: PUSH
66601: LD_VAR 0 2
66605: ARRAY
66606: DIFF
66607: ST_TO_ADDR
// if not tmp then
66608: LD_VAR 0 4
66612: NOT
66613: IFFALSE 66617
// continue ;
66615: GO 66462
// for j in tmp do
66617: LD_ADDR_VAR 0 3
66621: PUSH
66622: LD_VAR 0 4
66626: PUSH
66627: FOR_IN
66628: IFFALSE 66779
// begin if not mc_builders [ i ] then
66630: LD_EXP 66
66634: PUSH
66635: LD_VAR 0 2
66639: ARRAY
66640: NOT
66641: IFFALSE 66699
// begin SetTag ( j , 103 ) ;
66643: LD_VAR 0 3
66647: PPUSH
66648: LD_INT 103
66650: PPUSH
66651: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66655: LD_ADDR_EXP 66
66659: PUSH
66660: LD_EXP 66
66664: PPUSH
66665: LD_VAR 0 2
66669: PUSH
66670: LD_EXP 66
66674: PUSH
66675: LD_VAR 0 2
66679: ARRAY
66680: PUSH
66681: LD_INT 1
66683: PLUS
66684: PUSH
66685: EMPTY
66686: LIST
66687: LIST
66688: PPUSH
66689: LD_VAR 0 3
66693: PPUSH
66694: CALL 19991 0 3
66698: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66699: LD_VAR 0 3
66703: PPUSH
66704: CALL_OW 310
66708: IFFALSE 66719
// ComExitBuilding ( j ) ;
66710: LD_VAR 0 3
66714: PPUSH
66715: CALL_OW 122
// wait ( 3 ) ;
66719: LD_INT 3
66721: PPUSH
66722: CALL_OW 67
// if not mc_construct_list [ i ] then
66726: LD_EXP 67
66730: PUSH
66731: LD_VAR 0 2
66735: ARRAY
66736: NOT
66737: IFFALSE 66741
// break ;
66739: GO 66779
// if not HasTask ( j ) then
66741: LD_VAR 0 3
66745: PPUSH
66746: CALL_OW 314
66750: NOT
66751: IFFALSE 66777
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
66753: LD_VAR 0 3
66757: PPUSH
66758: LD_EXP 67
66762: PUSH
66763: LD_VAR 0 2
66767: ARRAY
66768: PUSH
66769: LD_INT 1
66771: ARRAY
66772: PPUSH
66773: CALL 22852 0 2
// end ;
66777: GO 66627
66779: POP
66780: POP
// end else
66781: GO 67614
// if mc_build_list [ i ] then
66783: LD_EXP 65
66787: PUSH
66788: LD_VAR 0 2
66792: ARRAY
66793: IFFALSE 67614
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66795: LD_ADDR_VAR 0 5
66799: PUSH
66800: LD_EXP 60
66804: PUSH
66805: LD_VAR 0 2
66809: ARRAY
66810: PPUSH
66811: LD_INT 2
66813: PUSH
66814: LD_INT 30
66816: PUSH
66817: LD_INT 0
66819: PUSH
66820: EMPTY
66821: LIST
66822: LIST
66823: PUSH
66824: LD_INT 30
66826: PUSH
66827: LD_INT 1
66829: PUSH
66830: EMPTY
66831: LIST
66832: LIST
66833: PUSH
66834: EMPTY
66835: LIST
66836: LIST
66837: LIST
66838: PPUSH
66839: CALL_OW 72
66843: ST_TO_ADDR
// if depot then
66844: LD_VAR 0 5
66848: IFFALSE 66866
// depot := depot [ 1 ] else
66850: LD_ADDR_VAR 0 5
66854: PUSH
66855: LD_VAR 0 5
66859: PUSH
66860: LD_INT 1
66862: ARRAY
66863: ST_TO_ADDR
66864: GO 66874
// depot := 0 ;
66866: LD_ADDR_VAR 0 5
66870: PUSH
66871: LD_INT 0
66873: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
66874: LD_EXP 65
66878: PUSH
66879: LD_VAR 0 2
66883: ARRAY
66884: PUSH
66885: LD_INT 1
66887: ARRAY
66888: PUSH
66889: LD_INT 1
66891: ARRAY
66892: PPUSH
66893: CALL 22676 0 1
66897: PUSH
66898: LD_EXP 60
66902: PUSH
66903: LD_VAR 0 2
66907: ARRAY
66908: PPUSH
66909: LD_INT 2
66911: PUSH
66912: LD_INT 30
66914: PUSH
66915: LD_INT 2
66917: PUSH
66918: EMPTY
66919: LIST
66920: LIST
66921: PUSH
66922: LD_INT 30
66924: PUSH
66925: LD_INT 3
66927: PUSH
66928: EMPTY
66929: LIST
66930: LIST
66931: PUSH
66932: EMPTY
66933: LIST
66934: LIST
66935: LIST
66936: PPUSH
66937: CALL_OW 72
66941: NOT
66942: AND
66943: IFFALSE 67048
// begin for j = 1 to mc_build_list [ i ] do
66945: LD_ADDR_VAR 0 3
66949: PUSH
66950: DOUBLE
66951: LD_INT 1
66953: DEC
66954: ST_TO_ADDR
66955: LD_EXP 65
66959: PUSH
66960: LD_VAR 0 2
66964: ARRAY
66965: PUSH
66966: FOR_TO
66967: IFFALSE 67046
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
66969: LD_EXP 65
66973: PUSH
66974: LD_VAR 0 2
66978: ARRAY
66979: PUSH
66980: LD_VAR 0 3
66984: ARRAY
66985: PUSH
66986: LD_INT 1
66988: ARRAY
66989: PUSH
66990: LD_INT 2
66992: EQUAL
66993: IFFALSE 67044
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
66995: LD_ADDR_EXP 65
66999: PUSH
67000: LD_EXP 65
67004: PPUSH
67005: LD_VAR 0 2
67009: PPUSH
67010: LD_EXP 65
67014: PUSH
67015: LD_VAR 0 2
67019: ARRAY
67020: PPUSH
67021: LD_VAR 0 3
67025: PPUSH
67026: LD_INT 1
67028: PPUSH
67029: LD_INT 0
67031: PPUSH
67032: CALL 19409 0 4
67036: PPUSH
67037: CALL_OW 1
67041: ST_TO_ADDR
// break ;
67042: GO 67046
// end ;
67044: GO 66966
67046: POP
67047: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
67048: LD_EXP 65
67052: PUSH
67053: LD_VAR 0 2
67057: ARRAY
67058: PUSH
67059: LD_INT 1
67061: ARRAY
67062: PUSH
67063: LD_INT 1
67065: ARRAY
67066: PUSH
67067: LD_INT 0
67069: EQUAL
67070: PUSH
67071: LD_VAR 0 5
67075: PUSH
67076: LD_VAR 0 5
67080: PPUSH
67081: LD_EXP 65
67085: PUSH
67086: LD_VAR 0 2
67090: ARRAY
67091: PUSH
67092: LD_INT 1
67094: ARRAY
67095: PUSH
67096: LD_INT 1
67098: ARRAY
67099: PPUSH
67100: LD_EXP 65
67104: PUSH
67105: LD_VAR 0 2
67109: ARRAY
67110: PUSH
67111: LD_INT 1
67113: ARRAY
67114: PUSH
67115: LD_INT 2
67117: ARRAY
67118: PPUSH
67119: LD_EXP 65
67123: PUSH
67124: LD_VAR 0 2
67128: ARRAY
67129: PUSH
67130: LD_INT 1
67132: ARRAY
67133: PUSH
67134: LD_INT 3
67136: ARRAY
67137: PPUSH
67138: LD_EXP 65
67142: PUSH
67143: LD_VAR 0 2
67147: ARRAY
67148: PUSH
67149: LD_INT 1
67151: ARRAY
67152: PUSH
67153: LD_INT 4
67155: ARRAY
67156: PPUSH
67157: CALL 28088 0 5
67161: AND
67162: OR
67163: IFFALSE 67444
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67165: LD_ADDR_VAR 0 4
67169: PUSH
67170: LD_EXP 60
67174: PUSH
67175: LD_VAR 0 2
67179: ARRAY
67180: PPUSH
67181: LD_INT 25
67183: PUSH
67184: LD_INT 2
67186: PUSH
67187: EMPTY
67188: LIST
67189: LIST
67190: PPUSH
67191: CALL_OW 72
67195: PUSH
67196: LD_EXP 62
67200: PUSH
67201: LD_VAR 0 2
67205: ARRAY
67206: DIFF
67207: ST_TO_ADDR
// if not tmp then
67208: LD_VAR 0 4
67212: NOT
67213: IFFALSE 67217
// continue ;
67215: GO 66462
// for j in tmp do
67217: LD_ADDR_VAR 0 3
67221: PUSH
67222: LD_VAR 0 4
67226: PUSH
67227: FOR_IN
67228: IFFALSE 67440
// begin if not mc_builders [ i ] then
67230: LD_EXP 66
67234: PUSH
67235: LD_VAR 0 2
67239: ARRAY
67240: NOT
67241: IFFALSE 67299
// begin SetTag ( j , 103 ) ;
67243: LD_VAR 0 3
67247: PPUSH
67248: LD_INT 103
67250: PPUSH
67251: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67255: LD_ADDR_EXP 66
67259: PUSH
67260: LD_EXP 66
67264: PPUSH
67265: LD_VAR 0 2
67269: PUSH
67270: LD_EXP 66
67274: PUSH
67275: LD_VAR 0 2
67279: ARRAY
67280: PUSH
67281: LD_INT 1
67283: PLUS
67284: PUSH
67285: EMPTY
67286: LIST
67287: LIST
67288: PPUSH
67289: LD_VAR 0 3
67293: PPUSH
67294: CALL 19991 0 3
67298: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67299: LD_VAR 0 3
67303: PPUSH
67304: CALL_OW 310
67308: IFFALSE 67319
// ComExitBuilding ( j ) ;
67310: LD_VAR 0 3
67314: PPUSH
67315: CALL_OW 122
// wait ( 3 ) ;
67319: LD_INT 3
67321: PPUSH
67322: CALL_OW 67
// if not mc_build_list [ i ] then
67326: LD_EXP 65
67330: PUSH
67331: LD_VAR 0 2
67335: ARRAY
67336: NOT
67337: IFFALSE 67341
// break ;
67339: GO 67440
// if not HasTask ( j ) then
67341: LD_VAR 0 3
67345: PPUSH
67346: CALL_OW 314
67350: NOT
67351: IFFALSE 67438
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
67353: LD_VAR 0 3
67357: PPUSH
67358: LD_EXP 65
67362: PUSH
67363: LD_VAR 0 2
67367: ARRAY
67368: PUSH
67369: LD_INT 1
67371: ARRAY
67372: PUSH
67373: LD_INT 1
67375: ARRAY
67376: PPUSH
67377: LD_EXP 65
67381: PUSH
67382: LD_VAR 0 2
67386: ARRAY
67387: PUSH
67388: LD_INT 1
67390: ARRAY
67391: PUSH
67392: LD_INT 2
67394: ARRAY
67395: PPUSH
67396: LD_EXP 65
67400: PUSH
67401: LD_VAR 0 2
67405: ARRAY
67406: PUSH
67407: LD_INT 1
67409: ARRAY
67410: PUSH
67411: LD_INT 3
67413: ARRAY
67414: PPUSH
67415: LD_EXP 65
67419: PUSH
67420: LD_VAR 0 2
67424: ARRAY
67425: PUSH
67426: LD_INT 1
67428: ARRAY
67429: PUSH
67430: LD_INT 4
67432: ARRAY
67433: PPUSH
67434: CALL_OW 145
// end ;
67438: GO 67227
67440: POP
67441: POP
// end else
67442: GO 67614
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
67444: LD_EXP 60
67448: PUSH
67449: LD_VAR 0 2
67453: ARRAY
67454: PPUSH
67455: LD_EXP 65
67459: PUSH
67460: LD_VAR 0 2
67464: ARRAY
67465: PUSH
67466: LD_INT 1
67468: ARRAY
67469: PUSH
67470: LD_INT 1
67472: ARRAY
67473: PPUSH
67474: LD_EXP 65
67478: PUSH
67479: LD_VAR 0 2
67483: ARRAY
67484: PUSH
67485: LD_INT 1
67487: ARRAY
67488: PUSH
67489: LD_INT 2
67491: ARRAY
67492: PPUSH
67493: LD_EXP 65
67497: PUSH
67498: LD_VAR 0 2
67502: ARRAY
67503: PUSH
67504: LD_INT 1
67506: ARRAY
67507: PUSH
67508: LD_INT 3
67510: ARRAY
67511: PPUSH
67512: LD_EXP 65
67516: PUSH
67517: LD_VAR 0 2
67521: ARRAY
67522: PUSH
67523: LD_INT 1
67525: ARRAY
67526: PUSH
67527: LD_INT 4
67529: ARRAY
67530: PPUSH
67531: LD_EXP 60
67535: PUSH
67536: LD_VAR 0 2
67540: ARRAY
67541: PPUSH
67542: LD_INT 21
67544: PUSH
67545: LD_INT 3
67547: PUSH
67548: EMPTY
67549: LIST
67550: LIST
67551: PPUSH
67552: CALL_OW 72
67556: PPUSH
67557: EMPTY
67558: PPUSH
67559: CALL 26842 0 7
67563: NOT
67564: IFFALSE 67614
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
67566: LD_ADDR_EXP 65
67570: PUSH
67571: LD_EXP 65
67575: PPUSH
67576: LD_VAR 0 2
67580: PPUSH
67581: LD_EXP 65
67585: PUSH
67586: LD_VAR 0 2
67590: ARRAY
67591: PPUSH
67592: LD_INT 1
67594: PPUSH
67595: LD_INT 1
67597: NEG
67598: PPUSH
67599: LD_INT 0
67601: PPUSH
67602: CALL 19409 0 4
67606: PPUSH
67607: CALL_OW 1
67611: ST_TO_ADDR
// continue ;
67612: GO 66462
// end ; end ; end ;
67614: GO 66462
67616: POP
67617: POP
// end ;
67618: LD_VAR 0 1
67622: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
67623: LD_INT 0
67625: PPUSH
67626: PPUSH
67627: PPUSH
67628: PPUSH
67629: PPUSH
67630: PPUSH
// if not mc_bases then
67631: LD_EXP 60
67635: NOT
67636: IFFALSE 67640
// exit ;
67638: GO 68067
// for i = 1 to mc_bases do
67640: LD_ADDR_VAR 0 2
67644: PUSH
67645: DOUBLE
67646: LD_INT 1
67648: DEC
67649: ST_TO_ADDR
67650: LD_EXP 60
67654: PUSH
67655: FOR_TO
67656: IFFALSE 68065
// begin tmp := mc_build_upgrade [ i ] ;
67658: LD_ADDR_VAR 0 4
67662: PUSH
67663: LD_EXP 92
67667: PUSH
67668: LD_VAR 0 2
67672: ARRAY
67673: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
67674: LD_ADDR_VAR 0 6
67678: PUSH
67679: LD_EXP 93
67683: PUSH
67684: LD_VAR 0 2
67688: ARRAY
67689: PPUSH
67690: LD_INT 2
67692: PUSH
67693: LD_INT 30
67695: PUSH
67696: LD_INT 6
67698: PUSH
67699: EMPTY
67700: LIST
67701: LIST
67702: PUSH
67703: LD_INT 30
67705: PUSH
67706: LD_INT 7
67708: PUSH
67709: EMPTY
67710: LIST
67711: LIST
67712: PUSH
67713: EMPTY
67714: LIST
67715: LIST
67716: LIST
67717: PPUSH
67718: CALL_OW 72
67722: ST_TO_ADDR
// if not tmp and not lab then
67723: LD_VAR 0 4
67727: NOT
67728: PUSH
67729: LD_VAR 0 6
67733: NOT
67734: AND
67735: IFFALSE 67739
// continue ;
67737: GO 67655
// if tmp then
67739: LD_VAR 0 4
67743: IFFALSE 67863
// for j in tmp do
67745: LD_ADDR_VAR 0 3
67749: PUSH
67750: LD_VAR 0 4
67754: PUSH
67755: FOR_IN
67756: IFFALSE 67861
// begin if UpgradeCost ( j ) then
67758: LD_VAR 0 3
67762: PPUSH
67763: CALL 26502 0 1
67767: IFFALSE 67859
// begin ComUpgrade ( j ) ;
67769: LD_VAR 0 3
67773: PPUSH
67774: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
67778: LD_ADDR_EXP 92
67782: PUSH
67783: LD_EXP 92
67787: PPUSH
67788: LD_VAR 0 2
67792: PPUSH
67793: LD_EXP 92
67797: PUSH
67798: LD_VAR 0 2
67802: ARRAY
67803: PUSH
67804: LD_VAR 0 3
67808: DIFF
67809: PPUSH
67810: CALL_OW 1
67814: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
67815: LD_ADDR_EXP 67
67819: PUSH
67820: LD_EXP 67
67824: PPUSH
67825: LD_VAR 0 2
67829: PUSH
67830: LD_EXP 67
67834: PUSH
67835: LD_VAR 0 2
67839: ARRAY
67840: PUSH
67841: LD_INT 1
67843: PLUS
67844: PUSH
67845: EMPTY
67846: LIST
67847: LIST
67848: PPUSH
67849: LD_VAR 0 3
67853: PPUSH
67854: CALL 19991 0 3
67858: ST_TO_ADDR
// end ; end ;
67859: GO 67755
67861: POP
67862: POP
// if not lab or not mc_lab_upgrade [ i ] then
67863: LD_VAR 0 6
67867: NOT
67868: PUSH
67869: LD_EXP 94
67873: PUSH
67874: LD_VAR 0 2
67878: ARRAY
67879: NOT
67880: OR
67881: IFFALSE 67885
// continue ;
67883: GO 67655
// for j in lab do
67885: LD_ADDR_VAR 0 3
67889: PUSH
67890: LD_VAR 0 6
67894: PUSH
67895: FOR_IN
67896: IFFALSE 68061
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
67898: LD_VAR 0 3
67902: PPUSH
67903: CALL_OW 266
67907: PUSH
67908: LD_INT 6
67910: PUSH
67911: LD_INT 7
67913: PUSH
67914: EMPTY
67915: LIST
67916: LIST
67917: IN
67918: PUSH
67919: LD_VAR 0 3
67923: PPUSH
67924: CALL_OW 461
67928: PUSH
67929: LD_INT 1
67931: NONEQUAL
67932: AND
67933: IFFALSE 68059
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
67935: LD_VAR 0 3
67939: PPUSH
67940: LD_EXP 94
67944: PUSH
67945: LD_VAR 0 2
67949: ARRAY
67950: PUSH
67951: LD_INT 1
67953: ARRAY
67954: PPUSH
67955: CALL 26707 0 2
67959: IFFALSE 68059
// begin ComCancel ( j ) ;
67961: LD_VAR 0 3
67965: PPUSH
67966: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
67970: LD_VAR 0 3
67974: PPUSH
67975: LD_EXP 94
67979: PUSH
67980: LD_VAR 0 2
67984: ARRAY
67985: PUSH
67986: LD_INT 1
67988: ARRAY
67989: PPUSH
67990: CALL_OW 207
// if not j in mc_construct_list [ i ] then
67994: LD_VAR 0 3
67998: PUSH
67999: LD_EXP 67
68003: PUSH
68004: LD_VAR 0 2
68008: ARRAY
68009: IN
68010: NOT
68011: IFFALSE 68057
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68013: LD_ADDR_EXP 67
68017: PUSH
68018: LD_EXP 67
68022: PPUSH
68023: LD_VAR 0 2
68027: PUSH
68028: LD_EXP 67
68032: PUSH
68033: LD_VAR 0 2
68037: ARRAY
68038: PUSH
68039: LD_INT 1
68041: PLUS
68042: PUSH
68043: EMPTY
68044: LIST
68045: LIST
68046: PPUSH
68047: LD_VAR 0 3
68051: PPUSH
68052: CALL 19991 0 3
68056: ST_TO_ADDR
// break ;
68057: GO 68061
// end ; end ; end ;
68059: GO 67895
68061: POP
68062: POP
// end ;
68063: GO 67655
68065: POP
68066: POP
// end ;
68067: LD_VAR 0 1
68071: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
68072: LD_INT 0
68074: PPUSH
68075: PPUSH
68076: PPUSH
68077: PPUSH
68078: PPUSH
68079: PPUSH
68080: PPUSH
68081: PPUSH
68082: PPUSH
// if not mc_bases then
68083: LD_EXP 60
68087: NOT
68088: IFFALSE 68092
// exit ;
68090: GO 68497
// for i = 1 to mc_bases do
68092: LD_ADDR_VAR 0 2
68096: PUSH
68097: DOUBLE
68098: LD_INT 1
68100: DEC
68101: ST_TO_ADDR
68102: LD_EXP 60
68106: PUSH
68107: FOR_TO
68108: IFFALSE 68495
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
68110: LD_EXP 68
68114: PUSH
68115: LD_VAR 0 2
68119: ARRAY
68120: NOT
68121: PUSH
68122: LD_EXP 60
68126: PUSH
68127: LD_VAR 0 2
68131: ARRAY
68132: PPUSH
68133: LD_INT 30
68135: PUSH
68136: LD_INT 3
68138: PUSH
68139: EMPTY
68140: LIST
68141: LIST
68142: PPUSH
68143: CALL_OW 72
68147: NOT
68148: OR
68149: IFFALSE 68153
// continue ;
68151: GO 68107
// busy := false ;
68153: LD_ADDR_VAR 0 8
68157: PUSH
68158: LD_INT 0
68160: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68161: LD_ADDR_VAR 0 4
68165: PUSH
68166: LD_EXP 60
68170: PUSH
68171: LD_VAR 0 2
68175: ARRAY
68176: PPUSH
68177: LD_INT 30
68179: PUSH
68180: LD_INT 3
68182: PUSH
68183: EMPTY
68184: LIST
68185: LIST
68186: PPUSH
68187: CALL_OW 72
68191: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
68192: LD_ADDR_VAR 0 6
68196: PUSH
68197: LD_EXP 68
68201: PUSH
68202: LD_VAR 0 2
68206: ARRAY
68207: PPUSH
68208: LD_INT 2
68210: PUSH
68211: LD_INT 30
68213: PUSH
68214: LD_INT 32
68216: PUSH
68217: EMPTY
68218: LIST
68219: LIST
68220: PUSH
68221: LD_INT 30
68223: PUSH
68224: LD_INT 33
68226: PUSH
68227: EMPTY
68228: LIST
68229: LIST
68230: PUSH
68231: EMPTY
68232: LIST
68233: LIST
68234: LIST
68235: PPUSH
68236: CALL_OW 72
68240: ST_TO_ADDR
// if not t then
68241: LD_VAR 0 6
68245: NOT
68246: IFFALSE 68250
// continue ;
68248: GO 68107
// for j in tmp do
68250: LD_ADDR_VAR 0 3
68254: PUSH
68255: LD_VAR 0 4
68259: PUSH
68260: FOR_IN
68261: IFFALSE 68291
// if not BuildingStatus ( j ) = bs_idle then
68263: LD_VAR 0 3
68267: PPUSH
68268: CALL_OW 461
68272: PUSH
68273: LD_INT 2
68275: EQUAL
68276: NOT
68277: IFFALSE 68289
// begin busy := true ;
68279: LD_ADDR_VAR 0 8
68283: PUSH
68284: LD_INT 1
68286: ST_TO_ADDR
// break ;
68287: GO 68291
// end ;
68289: GO 68260
68291: POP
68292: POP
// if busy then
68293: LD_VAR 0 8
68297: IFFALSE 68301
// continue ;
68299: GO 68107
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
68301: LD_ADDR_VAR 0 7
68305: PUSH
68306: LD_VAR 0 6
68310: PPUSH
68311: LD_INT 35
68313: PUSH
68314: LD_INT 0
68316: PUSH
68317: EMPTY
68318: LIST
68319: LIST
68320: PPUSH
68321: CALL_OW 72
68325: ST_TO_ADDR
// if tw then
68326: LD_VAR 0 7
68330: IFFALSE 68407
// begin tw := tw [ 1 ] ;
68332: LD_ADDR_VAR 0 7
68336: PUSH
68337: LD_VAR 0 7
68341: PUSH
68342: LD_INT 1
68344: ARRAY
68345: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
68346: LD_ADDR_VAR 0 9
68350: PUSH
68351: LD_VAR 0 7
68355: PPUSH
68356: LD_EXP 85
68360: PUSH
68361: LD_VAR 0 2
68365: ARRAY
68366: PPUSH
68367: CALL 24999 0 2
68371: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
68372: LD_EXP 99
68376: PUSH
68377: LD_VAR 0 2
68381: ARRAY
68382: IFFALSE 68405
// if not weapon in mc_allowed_tower_weapons [ i ] then
68384: LD_VAR 0 9
68388: PUSH
68389: LD_EXP 99
68393: PUSH
68394: LD_VAR 0 2
68398: ARRAY
68399: IN
68400: NOT
68401: IFFALSE 68405
// continue ;
68403: GO 68107
// end else
68405: GO 68470
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
68407: LD_ADDR_VAR 0 5
68411: PUSH
68412: LD_EXP 68
68416: PUSH
68417: LD_VAR 0 2
68421: ARRAY
68422: PPUSH
68423: LD_VAR 0 4
68427: PPUSH
68428: CALL 51778 0 2
68432: ST_TO_ADDR
// if not tmp2 then
68433: LD_VAR 0 5
68437: NOT
68438: IFFALSE 68442
// continue ;
68440: GO 68107
// tw := tmp2 [ 1 ] ;
68442: LD_ADDR_VAR 0 7
68446: PUSH
68447: LD_VAR 0 5
68451: PUSH
68452: LD_INT 1
68454: ARRAY
68455: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
68456: LD_ADDR_VAR 0 9
68460: PUSH
68461: LD_VAR 0 5
68465: PUSH
68466: LD_INT 2
68468: ARRAY
68469: ST_TO_ADDR
// end ; if not weapon then
68470: LD_VAR 0 9
68474: NOT
68475: IFFALSE 68479
// continue ;
68477: GO 68107
// ComPlaceWeapon ( tw , weapon ) ;
68479: LD_VAR 0 7
68483: PPUSH
68484: LD_VAR 0 9
68488: PPUSH
68489: CALL_OW 148
// end ;
68493: GO 68107
68495: POP
68496: POP
// end ;
68497: LD_VAR 0 1
68501: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
68502: LD_INT 0
68504: PPUSH
68505: PPUSH
68506: PPUSH
68507: PPUSH
68508: PPUSH
68509: PPUSH
68510: PPUSH
// if not mc_bases then
68511: LD_EXP 60
68515: NOT
68516: IFFALSE 68520
// exit ;
68518: GO 69288
// for i = 1 to mc_bases do
68520: LD_ADDR_VAR 0 2
68524: PUSH
68525: DOUBLE
68526: LD_INT 1
68528: DEC
68529: ST_TO_ADDR
68530: LD_EXP 60
68534: PUSH
68535: FOR_TO
68536: IFFALSE 69286
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
68538: LD_EXP 73
68542: PUSH
68543: LD_VAR 0 2
68547: ARRAY
68548: NOT
68549: PUSH
68550: LD_EXP 73
68554: PUSH
68555: LD_VAR 0 2
68559: ARRAY
68560: PUSH
68561: LD_EXP 74
68565: PUSH
68566: LD_VAR 0 2
68570: ARRAY
68571: EQUAL
68572: OR
68573: PUSH
68574: LD_EXP 83
68578: PUSH
68579: LD_VAR 0 2
68583: ARRAY
68584: OR
68585: IFFALSE 68589
// continue ;
68587: GO 68535
// if mc_miners [ i ] then
68589: LD_EXP 74
68593: PUSH
68594: LD_VAR 0 2
68598: ARRAY
68599: IFFALSE 68973
// begin for j = mc_miners [ i ] downto 1 do
68601: LD_ADDR_VAR 0 3
68605: PUSH
68606: DOUBLE
68607: LD_EXP 74
68611: PUSH
68612: LD_VAR 0 2
68616: ARRAY
68617: INC
68618: ST_TO_ADDR
68619: LD_INT 1
68621: PUSH
68622: FOR_DOWNTO
68623: IFFALSE 68971
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
68625: LD_EXP 74
68629: PUSH
68630: LD_VAR 0 2
68634: ARRAY
68635: PUSH
68636: LD_VAR 0 3
68640: ARRAY
68641: PPUSH
68642: CALL_OW 301
68646: PUSH
68647: LD_EXP 74
68651: PUSH
68652: LD_VAR 0 2
68656: ARRAY
68657: PUSH
68658: LD_VAR 0 3
68662: ARRAY
68663: PPUSH
68664: CALL_OW 257
68668: PUSH
68669: LD_INT 1
68671: NONEQUAL
68672: OR
68673: IFFALSE 68736
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
68675: LD_ADDR_VAR 0 5
68679: PUSH
68680: LD_EXP 74
68684: PUSH
68685: LD_VAR 0 2
68689: ARRAY
68690: PUSH
68691: LD_EXP 74
68695: PUSH
68696: LD_VAR 0 2
68700: ARRAY
68701: PUSH
68702: LD_VAR 0 3
68706: ARRAY
68707: DIFF
68708: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
68709: LD_ADDR_EXP 74
68713: PUSH
68714: LD_EXP 74
68718: PPUSH
68719: LD_VAR 0 2
68723: PPUSH
68724: LD_VAR 0 5
68728: PPUSH
68729: CALL_OW 1
68733: ST_TO_ADDR
// continue ;
68734: GO 68622
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
68736: LD_EXP 74
68740: PUSH
68741: LD_VAR 0 2
68745: ARRAY
68746: PUSH
68747: LD_VAR 0 3
68751: ARRAY
68752: PPUSH
68753: CALL_OW 257
68757: PUSH
68758: LD_INT 1
68760: EQUAL
68761: PUSH
68762: LD_EXP 74
68766: PUSH
68767: LD_VAR 0 2
68771: ARRAY
68772: PUSH
68773: LD_VAR 0 3
68777: ARRAY
68778: PPUSH
68779: CALL_OW 459
68783: NOT
68784: AND
68785: PUSH
68786: LD_EXP 74
68790: PUSH
68791: LD_VAR 0 2
68795: ARRAY
68796: PUSH
68797: LD_VAR 0 3
68801: ARRAY
68802: PPUSH
68803: CALL_OW 314
68807: NOT
68808: AND
68809: IFFALSE 68969
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
68811: LD_EXP 74
68815: PUSH
68816: LD_VAR 0 2
68820: ARRAY
68821: PUSH
68822: LD_VAR 0 3
68826: ARRAY
68827: PPUSH
68828: CALL_OW 310
68832: IFFALSE 68855
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
68834: LD_EXP 74
68838: PUSH
68839: LD_VAR 0 2
68843: ARRAY
68844: PUSH
68845: LD_VAR 0 3
68849: ARRAY
68850: PPUSH
68851: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
68855: LD_EXP 74
68859: PUSH
68860: LD_VAR 0 2
68864: ARRAY
68865: PUSH
68866: LD_VAR 0 3
68870: ARRAY
68871: PPUSH
68872: CALL_OW 314
68876: NOT
68877: IFFALSE 68969
// begin r := rand ( 1 , mc_mines [ i ] ) ;
68879: LD_ADDR_VAR 0 7
68883: PUSH
68884: LD_INT 1
68886: PPUSH
68887: LD_EXP 73
68891: PUSH
68892: LD_VAR 0 2
68896: ARRAY
68897: PPUSH
68898: CALL_OW 12
68902: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
68903: LD_EXP 74
68907: PUSH
68908: LD_VAR 0 2
68912: ARRAY
68913: PUSH
68914: LD_VAR 0 3
68918: ARRAY
68919: PPUSH
68920: LD_EXP 73
68924: PUSH
68925: LD_VAR 0 2
68929: ARRAY
68930: PUSH
68931: LD_VAR 0 7
68935: ARRAY
68936: PUSH
68937: LD_INT 1
68939: ARRAY
68940: PPUSH
68941: LD_EXP 73
68945: PUSH
68946: LD_VAR 0 2
68950: ARRAY
68951: PUSH
68952: LD_VAR 0 7
68956: ARRAY
68957: PUSH
68958: LD_INT 2
68960: ARRAY
68961: PPUSH
68962: LD_INT 0
68964: PPUSH
68965: CALL_OW 193
// end ; end ; end ;
68969: GO 68622
68971: POP
68972: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
68973: LD_ADDR_VAR 0 5
68977: PUSH
68978: LD_EXP 60
68982: PUSH
68983: LD_VAR 0 2
68987: ARRAY
68988: PPUSH
68989: LD_INT 2
68991: PUSH
68992: LD_INT 30
68994: PUSH
68995: LD_INT 4
68997: PUSH
68998: EMPTY
68999: LIST
69000: LIST
69001: PUSH
69002: LD_INT 30
69004: PUSH
69005: LD_INT 5
69007: PUSH
69008: EMPTY
69009: LIST
69010: LIST
69011: PUSH
69012: LD_INT 30
69014: PUSH
69015: LD_INT 32
69017: PUSH
69018: EMPTY
69019: LIST
69020: LIST
69021: PUSH
69022: EMPTY
69023: LIST
69024: LIST
69025: LIST
69026: LIST
69027: PPUSH
69028: CALL_OW 72
69032: ST_TO_ADDR
// if not tmp then
69033: LD_VAR 0 5
69037: NOT
69038: IFFALSE 69042
// continue ;
69040: GO 68535
// list := [ ] ;
69042: LD_ADDR_VAR 0 6
69046: PUSH
69047: EMPTY
69048: ST_TO_ADDR
// for j in tmp do
69049: LD_ADDR_VAR 0 3
69053: PUSH
69054: LD_VAR 0 5
69058: PUSH
69059: FOR_IN
69060: IFFALSE 69129
// begin for k in UnitsInside ( j ) do
69062: LD_ADDR_VAR 0 4
69066: PUSH
69067: LD_VAR 0 3
69071: PPUSH
69072: CALL_OW 313
69076: PUSH
69077: FOR_IN
69078: IFFALSE 69125
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
69080: LD_VAR 0 4
69084: PPUSH
69085: CALL_OW 257
69089: PUSH
69090: LD_INT 1
69092: EQUAL
69093: PUSH
69094: LD_VAR 0 4
69098: PPUSH
69099: CALL_OW 459
69103: NOT
69104: AND
69105: IFFALSE 69123
// list := list ^ k ;
69107: LD_ADDR_VAR 0 6
69111: PUSH
69112: LD_VAR 0 6
69116: PUSH
69117: LD_VAR 0 4
69121: ADD
69122: ST_TO_ADDR
69123: GO 69077
69125: POP
69126: POP
// end ;
69127: GO 69059
69129: POP
69130: POP
// list := list diff mc_miners [ i ] ;
69131: LD_ADDR_VAR 0 6
69135: PUSH
69136: LD_VAR 0 6
69140: PUSH
69141: LD_EXP 74
69145: PUSH
69146: LD_VAR 0 2
69150: ARRAY
69151: DIFF
69152: ST_TO_ADDR
// if not list then
69153: LD_VAR 0 6
69157: NOT
69158: IFFALSE 69162
// continue ;
69160: GO 68535
// k := mc_mines [ i ] - mc_miners [ i ] ;
69162: LD_ADDR_VAR 0 4
69166: PUSH
69167: LD_EXP 73
69171: PUSH
69172: LD_VAR 0 2
69176: ARRAY
69177: PUSH
69178: LD_EXP 74
69182: PUSH
69183: LD_VAR 0 2
69187: ARRAY
69188: MINUS
69189: ST_TO_ADDR
// if k > list then
69190: LD_VAR 0 4
69194: PUSH
69195: LD_VAR 0 6
69199: GREATER
69200: IFFALSE 69212
// k := list ;
69202: LD_ADDR_VAR 0 4
69206: PUSH
69207: LD_VAR 0 6
69211: ST_TO_ADDR
// for j = 1 to k do
69212: LD_ADDR_VAR 0 3
69216: PUSH
69217: DOUBLE
69218: LD_INT 1
69220: DEC
69221: ST_TO_ADDR
69222: LD_VAR 0 4
69226: PUSH
69227: FOR_TO
69228: IFFALSE 69282
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
69230: LD_ADDR_EXP 74
69234: PUSH
69235: LD_EXP 74
69239: PPUSH
69240: LD_VAR 0 2
69244: PUSH
69245: LD_EXP 74
69249: PUSH
69250: LD_VAR 0 2
69254: ARRAY
69255: PUSH
69256: LD_INT 1
69258: PLUS
69259: PUSH
69260: EMPTY
69261: LIST
69262: LIST
69263: PPUSH
69264: LD_VAR 0 6
69268: PUSH
69269: LD_VAR 0 3
69273: ARRAY
69274: PPUSH
69275: CALL 19991 0 3
69279: ST_TO_ADDR
69280: GO 69227
69282: POP
69283: POP
// end ;
69284: GO 68535
69286: POP
69287: POP
// end ;
69288: LD_VAR 0 1
69292: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
69293: LD_INT 0
69295: PPUSH
69296: PPUSH
69297: PPUSH
69298: PPUSH
69299: PPUSH
69300: PPUSH
69301: PPUSH
69302: PPUSH
69303: PPUSH
69304: PPUSH
69305: PPUSH
// if not mc_bases then
69306: LD_EXP 60
69310: NOT
69311: IFFALSE 69315
// exit ;
69313: GO 71138
// for i = 1 to mc_bases do
69315: LD_ADDR_VAR 0 2
69319: PUSH
69320: DOUBLE
69321: LD_INT 1
69323: DEC
69324: ST_TO_ADDR
69325: LD_EXP 60
69329: PUSH
69330: FOR_TO
69331: IFFALSE 71136
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
69333: LD_EXP 60
69337: PUSH
69338: LD_VAR 0 2
69342: ARRAY
69343: NOT
69344: PUSH
69345: LD_EXP 67
69349: PUSH
69350: LD_VAR 0 2
69354: ARRAY
69355: OR
69356: IFFALSE 69360
// continue ;
69358: GO 69330
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
69360: LD_EXP 76
69364: PUSH
69365: LD_VAR 0 2
69369: ARRAY
69370: NOT
69371: PUSH
69372: LD_EXP 77
69376: PUSH
69377: LD_VAR 0 2
69381: ARRAY
69382: AND
69383: IFFALSE 69421
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
69385: LD_ADDR_EXP 77
69389: PUSH
69390: LD_EXP 77
69394: PPUSH
69395: LD_VAR 0 2
69399: PPUSH
69400: EMPTY
69401: PPUSH
69402: CALL_OW 1
69406: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
69407: LD_VAR 0 2
69411: PPUSH
69412: LD_INT 107
69414: PPUSH
69415: CALL 60193 0 2
// continue ;
69419: GO 69330
// end ; target := [ ] ;
69421: LD_ADDR_VAR 0 7
69425: PUSH
69426: EMPTY
69427: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69428: LD_ADDR_VAR 0 6
69432: PUSH
69433: LD_EXP 60
69437: PUSH
69438: LD_VAR 0 2
69442: ARRAY
69443: PUSH
69444: LD_INT 1
69446: ARRAY
69447: PPUSH
69448: CALL_OW 255
69452: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69453: LD_ADDR_VAR 0 9
69457: PUSH
69458: LD_EXP 60
69462: PUSH
69463: LD_VAR 0 2
69467: ARRAY
69468: PPUSH
69469: LD_INT 2
69471: PUSH
69472: LD_INT 30
69474: PUSH
69475: LD_INT 0
69477: PUSH
69478: EMPTY
69479: LIST
69480: LIST
69481: PUSH
69482: LD_INT 30
69484: PUSH
69485: LD_INT 1
69487: PUSH
69488: EMPTY
69489: LIST
69490: LIST
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: LIST
69496: PPUSH
69497: CALL_OW 72
69501: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
69502: LD_ADDR_VAR 0 3
69506: PUSH
69507: DOUBLE
69508: LD_EXP 76
69512: PUSH
69513: LD_VAR 0 2
69517: ARRAY
69518: INC
69519: ST_TO_ADDR
69520: LD_INT 1
69522: PUSH
69523: FOR_DOWNTO
69524: IFFALSE 69769
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
69526: LD_EXP 76
69530: PUSH
69531: LD_VAR 0 2
69535: ARRAY
69536: PUSH
69537: LD_VAR 0 3
69541: ARRAY
69542: PUSH
69543: LD_INT 2
69545: ARRAY
69546: PPUSH
69547: LD_EXP 76
69551: PUSH
69552: LD_VAR 0 2
69556: ARRAY
69557: PUSH
69558: LD_VAR 0 3
69562: ARRAY
69563: PUSH
69564: LD_INT 3
69566: ARRAY
69567: PPUSH
69568: CALL_OW 488
69572: PUSH
69573: LD_EXP 76
69577: PUSH
69578: LD_VAR 0 2
69582: ARRAY
69583: PUSH
69584: LD_VAR 0 3
69588: ARRAY
69589: PUSH
69590: LD_INT 2
69592: ARRAY
69593: PPUSH
69594: LD_EXP 76
69598: PUSH
69599: LD_VAR 0 2
69603: ARRAY
69604: PUSH
69605: LD_VAR 0 3
69609: ARRAY
69610: PUSH
69611: LD_INT 3
69613: ARRAY
69614: PPUSH
69615: CALL_OW 284
69619: PUSH
69620: LD_INT 0
69622: EQUAL
69623: AND
69624: IFFALSE 69679
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
69626: LD_ADDR_VAR 0 5
69630: PUSH
69631: LD_EXP 76
69635: PUSH
69636: LD_VAR 0 2
69640: ARRAY
69641: PPUSH
69642: LD_VAR 0 3
69646: PPUSH
69647: CALL_OW 3
69651: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
69652: LD_ADDR_EXP 76
69656: PUSH
69657: LD_EXP 76
69661: PPUSH
69662: LD_VAR 0 2
69666: PPUSH
69667: LD_VAR 0 5
69671: PPUSH
69672: CALL_OW 1
69676: ST_TO_ADDR
// continue ;
69677: GO 69523
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
69679: LD_VAR 0 6
69683: PPUSH
69684: LD_EXP 76
69688: PUSH
69689: LD_VAR 0 2
69693: ARRAY
69694: PUSH
69695: LD_VAR 0 3
69699: ARRAY
69700: PUSH
69701: LD_INT 2
69703: ARRAY
69704: PPUSH
69705: LD_EXP 76
69709: PUSH
69710: LD_VAR 0 2
69714: ARRAY
69715: PUSH
69716: LD_VAR 0 3
69720: ARRAY
69721: PUSH
69722: LD_INT 3
69724: ARRAY
69725: PPUSH
69726: LD_INT 30
69728: PPUSH
69729: CALL 20887 0 4
69733: PUSH
69734: LD_INT 4
69736: ARRAY
69737: PUSH
69738: LD_INT 0
69740: EQUAL
69741: IFFALSE 69767
// begin target := mc_crates [ i ] [ j ] ;
69743: LD_ADDR_VAR 0 7
69747: PUSH
69748: LD_EXP 76
69752: PUSH
69753: LD_VAR 0 2
69757: ARRAY
69758: PUSH
69759: LD_VAR 0 3
69763: ARRAY
69764: ST_TO_ADDR
// break ;
69765: GO 69769
// end ; end ;
69767: GO 69523
69769: POP
69770: POP
// if not target then
69771: LD_VAR 0 7
69775: NOT
69776: IFFALSE 69780
// continue ;
69778: GO 69330
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
69780: LD_ADDR_VAR 0 8
69784: PUSH
69785: LD_EXP 79
69789: PUSH
69790: LD_VAR 0 2
69794: ARRAY
69795: PPUSH
69796: LD_INT 2
69798: PUSH
69799: LD_INT 3
69801: PUSH
69802: LD_INT 58
69804: PUSH
69805: EMPTY
69806: LIST
69807: PUSH
69808: EMPTY
69809: LIST
69810: LIST
69811: PUSH
69812: LD_INT 61
69814: PUSH
69815: EMPTY
69816: LIST
69817: PUSH
69818: LD_INT 33
69820: PUSH
69821: LD_INT 5
69823: PUSH
69824: EMPTY
69825: LIST
69826: LIST
69827: PUSH
69828: LD_INT 33
69830: PUSH
69831: LD_INT 3
69833: PUSH
69834: EMPTY
69835: LIST
69836: LIST
69837: PUSH
69838: EMPTY
69839: LIST
69840: LIST
69841: LIST
69842: LIST
69843: LIST
69844: PUSH
69845: LD_INT 2
69847: PUSH
69848: LD_INT 34
69850: PUSH
69851: LD_INT 32
69853: PUSH
69854: EMPTY
69855: LIST
69856: LIST
69857: PUSH
69858: LD_INT 34
69860: PUSH
69861: LD_INT 51
69863: PUSH
69864: EMPTY
69865: LIST
69866: LIST
69867: PUSH
69868: LD_INT 34
69870: PUSH
69871: LD_INT 12
69873: PUSH
69874: EMPTY
69875: LIST
69876: LIST
69877: PUSH
69878: EMPTY
69879: LIST
69880: LIST
69881: LIST
69882: LIST
69883: PUSH
69884: EMPTY
69885: LIST
69886: LIST
69887: PPUSH
69888: CALL_OW 72
69892: ST_TO_ADDR
// if not cargo then
69893: LD_VAR 0 8
69897: NOT
69898: IFFALSE 70604
// begin if mc_crates_collector [ i ] < 5 then
69900: LD_EXP 77
69904: PUSH
69905: LD_VAR 0 2
69909: ARRAY
69910: PUSH
69911: LD_INT 5
69913: LESS
69914: IFFALSE 70280
// begin if mc_ape [ i ] then
69916: LD_EXP 89
69920: PUSH
69921: LD_VAR 0 2
69925: ARRAY
69926: IFFALSE 69973
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
69928: LD_ADDR_VAR 0 5
69932: PUSH
69933: LD_EXP 89
69937: PUSH
69938: LD_VAR 0 2
69942: ARRAY
69943: PPUSH
69944: LD_INT 25
69946: PUSH
69947: LD_INT 16
69949: PUSH
69950: EMPTY
69951: LIST
69952: LIST
69953: PUSH
69954: LD_INT 24
69956: PUSH
69957: LD_INT 750
69959: PUSH
69960: EMPTY
69961: LIST
69962: LIST
69963: PUSH
69964: EMPTY
69965: LIST
69966: LIST
69967: PPUSH
69968: CALL_OW 72
69972: ST_TO_ADDR
// if not tmp then
69973: LD_VAR 0 5
69977: NOT
69978: IFFALSE 70025
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
69980: LD_ADDR_VAR 0 5
69984: PUSH
69985: LD_EXP 60
69989: PUSH
69990: LD_VAR 0 2
69994: ARRAY
69995: PPUSH
69996: LD_INT 25
69998: PUSH
69999: LD_INT 2
70001: PUSH
70002: EMPTY
70003: LIST
70004: LIST
70005: PUSH
70006: LD_INT 24
70008: PUSH
70009: LD_INT 750
70011: PUSH
70012: EMPTY
70013: LIST
70014: LIST
70015: PUSH
70016: EMPTY
70017: LIST
70018: LIST
70019: PPUSH
70020: CALL_OW 72
70024: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
70025: LD_EXP 89
70029: PUSH
70030: LD_VAR 0 2
70034: ARRAY
70035: PUSH
70036: LD_EXP 60
70040: PUSH
70041: LD_VAR 0 2
70045: ARRAY
70046: PPUSH
70047: LD_INT 25
70049: PUSH
70050: LD_INT 2
70052: PUSH
70053: EMPTY
70054: LIST
70055: LIST
70056: PUSH
70057: LD_INT 24
70059: PUSH
70060: LD_INT 750
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: EMPTY
70068: LIST
70069: LIST
70070: PPUSH
70071: CALL_OW 72
70075: AND
70076: PUSH
70077: LD_VAR 0 5
70081: PUSH
70082: LD_INT 5
70084: LESS
70085: AND
70086: IFFALSE 70168
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
70088: LD_ADDR_VAR 0 3
70092: PUSH
70093: LD_EXP 60
70097: PUSH
70098: LD_VAR 0 2
70102: ARRAY
70103: PPUSH
70104: LD_INT 25
70106: PUSH
70107: LD_INT 2
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: LD_INT 24
70116: PUSH
70117: LD_INT 750
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: EMPTY
70125: LIST
70126: LIST
70127: PPUSH
70128: CALL_OW 72
70132: PUSH
70133: FOR_IN
70134: IFFALSE 70166
// begin tmp := tmp union j ;
70136: LD_ADDR_VAR 0 5
70140: PUSH
70141: LD_VAR 0 5
70145: PUSH
70146: LD_VAR 0 3
70150: UNION
70151: ST_TO_ADDR
// if tmp >= 5 then
70152: LD_VAR 0 5
70156: PUSH
70157: LD_INT 5
70159: GREATEREQUAL
70160: IFFALSE 70164
// break ;
70162: GO 70166
// end ;
70164: GO 70133
70166: POP
70167: POP
// end ; if not tmp then
70168: LD_VAR 0 5
70172: NOT
70173: IFFALSE 70177
// continue ;
70175: GO 69330
// for j in tmp do
70177: LD_ADDR_VAR 0 3
70181: PUSH
70182: LD_VAR 0 5
70186: PUSH
70187: FOR_IN
70188: IFFALSE 70278
// if not GetTag ( j ) then
70190: LD_VAR 0 3
70194: PPUSH
70195: CALL_OW 110
70199: NOT
70200: IFFALSE 70276
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
70202: LD_ADDR_EXP 77
70206: PUSH
70207: LD_EXP 77
70211: PPUSH
70212: LD_VAR 0 2
70216: PUSH
70217: LD_EXP 77
70221: PUSH
70222: LD_VAR 0 2
70226: ARRAY
70227: PUSH
70228: LD_INT 1
70230: PLUS
70231: PUSH
70232: EMPTY
70233: LIST
70234: LIST
70235: PPUSH
70236: LD_VAR 0 3
70240: PPUSH
70241: CALL 19991 0 3
70245: ST_TO_ADDR
// SetTag ( j , 107 ) ;
70246: LD_VAR 0 3
70250: PPUSH
70251: LD_INT 107
70253: PPUSH
70254: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
70258: LD_EXP 77
70262: PUSH
70263: LD_VAR 0 2
70267: ARRAY
70268: PUSH
70269: LD_INT 5
70271: GREATEREQUAL
70272: IFFALSE 70276
// break ;
70274: GO 70278
// end ;
70276: GO 70187
70278: POP
70279: POP
// end ; if mc_crates_collector [ i ] and target then
70280: LD_EXP 77
70284: PUSH
70285: LD_VAR 0 2
70289: ARRAY
70290: PUSH
70291: LD_VAR 0 7
70295: AND
70296: IFFALSE 70602
// begin if mc_crates_collector [ i ] < target [ 1 ] then
70298: LD_EXP 77
70302: PUSH
70303: LD_VAR 0 2
70307: ARRAY
70308: PUSH
70309: LD_VAR 0 7
70313: PUSH
70314: LD_INT 1
70316: ARRAY
70317: LESS
70318: IFFALSE 70338
// tmp := mc_crates_collector [ i ] else
70320: LD_ADDR_VAR 0 5
70324: PUSH
70325: LD_EXP 77
70329: PUSH
70330: LD_VAR 0 2
70334: ARRAY
70335: ST_TO_ADDR
70336: GO 70352
// tmp := target [ 1 ] ;
70338: LD_ADDR_VAR 0 5
70342: PUSH
70343: LD_VAR 0 7
70347: PUSH
70348: LD_INT 1
70350: ARRAY
70351: ST_TO_ADDR
// k := 0 ;
70352: LD_ADDR_VAR 0 4
70356: PUSH
70357: LD_INT 0
70359: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
70360: LD_ADDR_VAR 0 3
70364: PUSH
70365: LD_EXP 77
70369: PUSH
70370: LD_VAR 0 2
70374: ARRAY
70375: PUSH
70376: FOR_IN
70377: IFFALSE 70600
// begin k := k + 1 ;
70379: LD_ADDR_VAR 0 4
70383: PUSH
70384: LD_VAR 0 4
70388: PUSH
70389: LD_INT 1
70391: PLUS
70392: ST_TO_ADDR
// if k > tmp then
70393: LD_VAR 0 4
70397: PUSH
70398: LD_VAR 0 5
70402: GREATER
70403: IFFALSE 70407
// break ;
70405: GO 70600
// if not GetClass ( j ) in [ 2 , 16 ] then
70407: LD_VAR 0 3
70411: PPUSH
70412: CALL_OW 257
70416: PUSH
70417: LD_INT 2
70419: PUSH
70420: LD_INT 16
70422: PUSH
70423: EMPTY
70424: LIST
70425: LIST
70426: IN
70427: NOT
70428: IFFALSE 70481
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
70430: LD_ADDR_EXP 77
70434: PUSH
70435: LD_EXP 77
70439: PPUSH
70440: LD_VAR 0 2
70444: PPUSH
70445: LD_EXP 77
70449: PUSH
70450: LD_VAR 0 2
70454: ARRAY
70455: PUSH
70456: LD_VAR 0 3
70460: DIFF
70461: PPUSH
70462: CALL_OW 1
70466: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70467: LD_VAR 0 3
70471: PPUSH
70472: LD_INT 0
70474: PPUSH
70475: CALL_OW 109
// continue ;
70479: GO 70376
// end ; if IsInUnit ( j ) then
70481: LD_VAR 0 3
70485: PPUSH
70486: CALL_OW 310
70490: IFFALSE 70501
// ComExitBuilding ( j ) ;
70492: LD_VAR 0 3
70496: PPUSH
70497: CALL_OW 122
// wait ( 3 ) ;
70501: LD_INT 3
70503: PPUSH
70504: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
70508: LD_VAR 0 3
70512: PPUSH
70513: CALL_OW 314
70517: PUSH
70518: LD_VAR 0 6
70522: PPUSH
70523: LD_VAR 0 7
70527: PUSH
70528: LD_INT 2
70530: ARRAY
70531: PPUSH
70532: LD_VAR 0 7
70536: PUSH
70537: LD_INT 3
70539: ARRAY
70540: PPUSH
70541: LD_INT 30
70543: PPUSH
70544: CALL 20887 0 4
70548: PUSH
70549: LD_INT 4
70551: ARRAY
70552: AND
70553: IFFALSE 70571
// ComStandNearbyBuilding ( j , depot ) else
70555: LD_VAR 0 3
70559: PPUSH
70560: LD_VAR 0 9
70564: PPUSH
70565: CALL 16418 0 2
70569: GO 70598
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70571: LD_VAR 0 3
70575: PPUSH
70576: LD_VAR 0 7
70580: PUSH
70581: LD_INT 2
70583: ARRAY
70584: PPUSH
70585: LD_VAR 0 7
70589: PUSH
70590: LD_INT 3
70592: ARRAY
70593: PPUSH
70594: CALL_OW 117
// end ;
70598: GO 70376
70600: POP
70601: POP
// end ; end else
70602: GO 71134
// begin for j in cargo do
70604: LD_ADDR_VAR 0 3
70608: PUSH
70609: LD_VAR 0 8
70613: PUSH
70614: FOR_IN
70615: IFFALSE 71132
// begin if GetTag ( j ) <> 0 then
70617: LD_VAR 0 3
70621: PPUSH
70622: CALL_OW 110
70626: PUSH
70627: LD_INT 0
70629: NONEQUAL
70630: IFFALSE 70634
// continue ;
70632: GO 70614
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
70634: LD_VAR 0 3
70638: PPUSH
70639: CALL_OW 256
70643: PUSH
70644: LD_INT 1000
70646: LESS
70647: PUSH
70648: LD_VAR 0 3
70652: PPUSH
70653: LD_EXP 84
70657: PUSH
70658: LD_VAR 0 2
70662: ARRAY
70663: PPUSH
70664: CALL_OW 308
70668: NOT
70669: AND
70670: IFFALSE 70692
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70672: LD_VAR 0 3
70676: PPUSH
70677: LD_EXP 84
70681: PUSH
70682: LD_VAR 0 2
70686: ARRAY
70687: PPUSH
70688: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
70692: LD_VAR 0 3
70696: PPUSH
70697: CALL_OW 256
70701: PUSH
70702: LD_INT 1000
70704: LESS
70705: PUSH
70706: LD_VAR 0 3
70710: PPUSH
70711: LD_EXP 84
70715: PUSH
70716: LD_VAR 0 2
70720: ARRAY
70721: PPUSH
70722: CALL_OW 308
70726: AND
70727: IFFALSE 70731
// continue ;
70729: GO 70614
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
70731: LD_VAR 0 3
70735: PPUSH
70736: CALL_OW 262
70740: PUSH
70741: LD_INT 2
70743: EQUAL
70744: PUSH
70745: LD_VAR 0 3
70749: PPUSH
70750: CALL_OW 261
70754: PUSH
70755: LD_INT 15
70757: LESS
70758: AND
70759: IFFALSE 70763
// continue ;
70761: GO 70614
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
70763: LD_VAR 0 3
70767: PPUSH
70768: CALL_OW 262
70772: PUSH
70773: LD_INT 1
70775: EQUAL
70776: PUSH
70777: LD_VAR 0 3
70781: PPUSH
70782: CALL_OW 261
70786: PUSH
70787: LD_INT 10
70789: LESS
70790: AND
70791: IFFALSE 71071
// begin if not depot then
70793: LD_VAR 0 9
70797: NOT
70798: IFFALSE 70802
// continue ;
70800: GO 70614
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
70802: LD_VAR 0 3
70806: PPUSH
70807: LD_VAR 0 9
70811: PPUSH
70812: LD_VAR 0 3
70816: PPUSH
70817: CALL_OW 74
70821: PPUSH
70822: CALL_OW 296
70826: PUSH
70827: LD_INT 6
70829: LESS
70830: IFFALSE 70846
// SetFuel ( j , 100 ) else
70832: LD_VAR 0 3
70836: PPUSH
70837: LD_INT 100
70839: PPUSH
70840: CALL_OW 240
70844: GO 71071
// if GetFuel ( j ) = 0 then
70846: LD_VAR 0 3
70850: PPUSH
70851: CALL_OW 261
70855: PUSH
70856: LD_INT 0
70858: EQUAL
70859: IFFALSE 71071
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
70861: LD_ADDR_EXP 79
70865: PUSH
70866: LD_EXP 79
70870: PPUSH
70871: LD_VAR 0 2
70875: PPUSH
70876: LD_EXP 79
70880: PUSH
70881: LD_VAR 0 2
70885: ARRAY
70886: PUSH
70887: LD_VAR 0 3
70891: DIFF
70892: PPUSH
70893: CALL_OW 1
70897: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
70898: LD_VAR 0 3
70902: PPUSH
70903: CALL_OW 263
70907: PUSH
70908: LD_INT 1
70910: EQUAL
70911: IFFALSE 70927
// ComExitVehicle ( IsInUnit ( j ) ) ;
70913: LD_VAR 0 3
70917: PPUSH
70918: CALL_OW 310
70922: PPUSH
70923: CALL_OW 121
// if GetControl ( j ) = control_remote then
70927: LD_VAR 0 3
70931: PPUSH
70932: CALL_OW 263
70936: PUSH
70937: LD_INT 2
70939: EQUAL
70940: IFFALSE 70951
// ComUnlink ( j ) ;
70942: LD_VAR 0 3
70946: PPUSH
70947: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
70951: LD_ADDR_VAR 0 10
70955: PUSH
70956: LD_VAR 0 2
70960: PPUSH
70961: LD_INT 3
70963: PPUSH
70964: CALL 80710 0 2
70968: ST_TO_ADDR
// if fac then
70969: LD_VAR 0 10
70973: IFFALSE 71069
// begin for k in fac do
70975: LD_ADDR_VAR 0 4
70979: PUSH
70980: LD_VAR 0 10
70984: PUSH
70985: FOR_IN
70986: IFFALSE 71067
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
70988: LD_ADDR_VAR 0 11
70992: PUSH
70993: LD_VAR 0 10
70997: PPUSH
70998: LD_VAR 0 3
71002: PPUSH
71003: CALL_OW 265
71007: PPUSH
71008: LD_VAR 0 3
71012: PPUSH
71013: CALL_OW 262
71017: PPUSH
71018: LD_VAR 0 3
71022: PPUSH
71023: CALL_OW 263
71027: PPUSH
71028: LD_VAR 0 3
71032: PPUSH
71033: CALL_OW 264
71037: PPUSH
71038: CALL 17489 0 5
71042: ST_TO_ADDR
// if components then
71043: LD_VAR 0 11
71047: IFFALSE 71065
// begin MC_InsertProduceList ( i , components ) ;
71049: LD_VAR 0 2
71053: PPUSH
71054: LD_VAR 0 11
71058: PPUSH
71059: CALL 80255 0 2
// break ;
71063: GO 71067
// end ; end ;
71065: GO 70985
71067: POP
71068: POP
// end ; continue ;
71069: GO 70614
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
71071: LD_VAR 0 3
71075: PPUSH
71076: LD_INT 1
71078: PPUSH
71079: CALL_OW 289
71083: PUSH
71084: LD_INT 100
71086: LESS
71087: PUSH
71088: LD_VAR 0 3
71092: PPUSH
71093: CALL_OW 314
71097: NOT
71098: AND
71099: IFFALSE 71128
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71101: LD_VAR 0 3
71105: PPUSH
71106: LD_VAR 0 7
71110: PUSH
71111: LD_INT 2
71113: ARRAY
71114: PPUSH
71115: LD_VAR 0 7
71119: PUSH
71120: LD_INT 3
71122: ARRAY
71123: PPUSH
71124: CALL_OW 117
// break ;
71128: GO 71132
// end ;
71130: GO 70614
71132: POP
71133: POP
// end ; end ;
71134: GO 69330
71136: POP
71137: POP
// end ;
71138: LD_VAR 0 1
71142: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
71143: LD_INT 0
71145: PPUSH
71146: PPUSH
71147: PPUSH
71148: PPUSH
// if not mc_bases then
71149: LD_EXP 60
71153: NOT
71154: IFFALSE 71158
// exit ;
71156: GO 71319
// for i = 1 to mc_bases do
71158: LD_ADDR_VAR 0 2
71162: PUSH
71163: DOUBLE
71164: LD_INT 1
71166: DEC
71167: ST_TO_ADDR
71168: LD_EXP 60
71172: PUSH
71173: FOR_TO
71174: IFFALSE 71317
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
71176: LD_ADDR_VAR 0 4
71180: PUSH
71181: LD_EXP 79
71185: PUSH
71186: LD_VAR 0 2
71190: ARRAY
71191: PUSH
71192: LD_EXP 82
71196: PUSH
71197: LD_VAR 0 2
71201: ARRAY
71202: UNION
71203: PPUSH
71204: LD_INT 33
71206: PUSH
71207: LD_INT 2
71209: PUSH
71210: EMPTY
71211: LIST
71212: LIST
71213: PPUSH
71214: CALL_OW 72
71218: ST_TO_ADDR
// if tmp then
71219: LD_VAR 0 4
71223: IFFALSE 71315
// for j in tmp do
71225: LD_ADDR_VAR 0 3
71229: PUSH
71230: LD_VAR 0 4
71234: PUSH
71235: FOR_IN
71236: IFFALSE 71313
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
71238: LD_VAR 0 3
71242: PPUSH
71243: CALL_OW 312
71247: NOT
71248: PUSH
71249: LD_VAR 0 3
71253: PPUSH
71254: CALL_OW 256
71258: PUSH
71259: LD_INT 250
71261: GREATEREQUAL
71262: AND
71263: IFFALSE 71276
// Connect ( j ) else
71265: LD_VAR 0 3
71269: PPUSH
71270: CALL 22960 0 1
71274: GO 71311
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
71276: LD_VAR 0 3
71280: PPUSH
71281: CALL_OW 256
71285: PUSH
71286: LD_INT 250
71288: LESS
71289: PUSH
71290: LD_VAR 0 3
71294: PPUSH
71295: CALL_OW 312
71299: AND
71300: IFFALSE 71311
// ComUnlink ( j ) ;
71302: LD_VAR 0 3
71306: PPUSH
71307: CALL_OW 136
71311: GO 71235
71313: POP
71314: POP
// end ;
71315: GO 71173
71317: POP
71318: POP
// end ;
71319: LD_VAR 0 1
71323: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
71324: LD_INT 0
71326: PPUSH
71327: PPUSH
71328: PPUSH
71329: PPUSH
71330: PPUSH
// if not mc_bases then
71331: LD_EXP 60
71335: NOT
71336: IFFALSE 71340
// exit ;
71338: GO 71785
// for i = 1 to mc_bases do
71340: LD_ADDR_VAR 0 2
71344: PUSH
71345: DOUBLE
71346: LD_INT 1
71348: DEC
71349: ST_TO_ADDR
71350: LD_EXP 60
71354: PUSH
71355: FOR_TO
71356: IFFALSE 71783
// begin if not mc_produce [ i ] then
71358: LD_EXP 81
71362: PUSH
71363: LD_VAR 0 2
71367: ARRAY
71368: NOT
71369: IFFALSE 71373
// continue ;
71371: GO 71355
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71373: LD_ADDR_VAR 0 5
71377: PUSH
71378: LD_EXP 60
71382: PUSH
71383: LD_VAR 0 2
71387: ARRAY
71388: PPUSH
71389: LD_INT 30
71391: PUSH
71392: LD_INT 3
71394: PUSH
71395: EMPTY
71396: LIST
71397: LIST
71398: PPUSH
71399: CALL_OW 72
71403: ST_TO_ADDR
// if not fac then
71404: LD_VAR 0 5
71408: NOT
71409: IFFALSE 71413
// continue ;
71411: GO 71355
// for j in fac do
71413: LD_ADDR_VAR 0 3
71417: PUSH
71418: LD_VAR 0 5
71422: PUSH
71423: FOR_IN
71424: IFFALSE 71779
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
71426: LD_VAR 0 3
71430: PPUSH
71431: CALL_OW 461
71435: PUSH
71436: LD_INT 2
71438: NONEQUAL
71439: PUSH
71440: LD_VAR 0 3
71444: PPUSH
71445: LD_INT 15
71447: PPUSH
71448: CALL 22588 0 2
71452: PUSH
71453: LD_INT 4
71455: ARRAY
71456: OR
71457: IFFALSE 71461
// continue ;
71459: GO 71423
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
71461: LD_VAR 0 3
71465: PPUSH
71466: LD_EXP 81
71470: PUSH
71471: LD_VAR 0 2
71475: ARRAY
71476: PUSH
71477: LD_INT 1
71479: ARRAY
71480: PUSH
71481: LD_INT 1
71483: ARRAY
71484: PPUSH
71485: LD_EXP 81
71489: PUSH
71490: LD_VAR 0 2
71494: ARRAY
71495: PUSH
71496: LD_INT 1
71498: ARRAY
71499: PUSH
71500: LD_INT 2
71502: ARRAY
71503: PPUSH
71504: LD_EXP 81
71508: PUSH
71509: LD_VAR 0 2
71513: ARRAY
71514: PUSH
71515: LD_INT 1
71517: ARRAY
71518: PUSH
71519: LD_INT 3
71521: ARRAY
71522: PPUSH
71523: LD_EXP 81
71527: PUSH
71528: LD_VAR 0 2
71532: ARRAY
71533: PUSH
71534: LD_INT 1
71536: ARRAY
71537: PUSH
71538: LD_INT 4
71540: ARRAY
71541: PPUSH
71542: CALL_OW 448
71546: PUSH
71547: LD_VAR 0 3
71551: PPUSH
71552: LD_EXP 81
71556: PUSH
71557: LD_VAR 0 2
71561: ARRAY
71562: PUSH
71563: LD_INT 1
71565: ARRAY
71566: PUSH
71567: LD_INT 1
71569: ARRAY
71570: PUSH
71571: LD_EXP 81
71575: PUSH
71576: LD_VAR 0 2
71580: ARRAY
71581: PUSH
71582: LD_INT 1
71584: ARRAY
71585: PUSH
71586: LD_INT 2
71588: ARRAY
71589: PUSH
71590: LD_EXP 81
71594: PUSH
71595: LD_VAR 0 2
71599: ARRAY
71600: PUSH
71601: LD_INT 1
71603: ARRAY
71604: PUSH
71605: LD_INT 3
71607: ARRAY
71608: PUSH
71609: LD_EXP 81
71613: PUSH
71614: LD_VAR 0 2
71618: ARRAY
71619: PUSH
71620: LD_INT 1
71622: ARRAY
71623: PUSH
71624: LD_INT 4
71626: ARRAY
71627: PUSH
71628: EMPTY
71629: LIST
71630: LIST
71631: LIST
71632: LIST
71633: PPUSH
71634: CALL 26355 0 2
71638: AND
71639: IFFALSE 71777
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
71641: LD_VAR 0 3
71645: PPUSH
71646: LD_EXP 81
71650: PUSH
71651: LD_VAR 0 2
71655: ARRAY
71656: PUSH
71657: LD_INT 1
71659: ARRAY
71660: PUSH
71661: LD_INT 1
71663: ARRAY
71664: PPUSH
71665: LD_EXP 81
71669: PUSH
71670: LD_VAR 0 2
71674: ARRAY
71675: PUSH
71676: LD_INT 1
71678: ARRAY
71679: PUSH
71680: LD_INT 2
71682: ARRAY
71683: PPUSH
71684: LD_EXP 81
71688: PUSH
71689: LD_VAR 0 2
71693: ARRAY
71694: PUSH
71695: LD_INT 1
71697: ARRAY
71698: PUSH
71699: LD_INT 3
71701: ARRAY
71702: PPUSH
71703: LD_EXP 81
71707: PUSH
71708: LD_VAR 0 2
71712: ARRAY
71713: PUSH
71714: LD_INT 1
71716: ARRAY
71717: PUSH
71718: LD_INT 4
71720: ARRAY
71721: PPUSH
71722: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
71726: LD_ADDR_VAR 0 4
71730: PUSH
71731: LD_EXP 81
71735: PUSH
71736: LD_VAR 0 2
71740: ARRAY
71741: PPUSH
71742: LD_INT 1
71744: PPUSH
71745: CALL_OW 3
71749: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
71750: LD_ADDR_EXP 81
71754: PUSH
71755: LD_EXP 81
71759: PPUSH
71760: LD_VAR 0 2
71764: PPUSH
71765: LD_VAR 0 4
71769: PPUSH
71770: CALL_OW 1
71774: ST_TO_ADDR
// break ;
71775: GO 71779
// end ; end ;
71777: GO 71423
71779: POP
71780: POP
// end ;
71781: GO 71355
71783: POP
71784: POP
// end ;
71785: LD_VAR 0 1
71789: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
71790: LD_INT 0
71792: PPUSH
71793: PPUSH
71794: PPUSH
// if not mc_bases then
71795: LD_EXP 60
71799: NOT
71800: IFFALSE 71804
// exit ;
71802: GO 71893
// for i = 1 to mc_bases do
71804: LD_ADDR_VAR 0 2
71808: PUSH
71809: DOUBLE
71810: LD_INT 1
71812: DEC
71813: ST_TO_ADDR
71814: LD_EXP 60
71818: PUSH
71819: FOR_TO
71820: IFFALSE 71891
// begin if mc_attack [ i ] then
71822: LD_EXP 80
71826: PUSH
71827: LD_VAR 0 2
71831: ARRAY
71832: IFFALSE 71889
// begin tmp := mc_attack [ i ] [ 1 ] ;
71834: LD_ADDR_VAR 0 3
71838: PUSH
71839: LD_EXP 80
71843: PUSH
71844: LD_VAR 0 2
71848: ARRAY
71849: PUSH
71850: LD_INT 1
71852: ARRAY
71853: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
71854: LD_ADDR_EXP 80
71858: PUSH
71859: LD_EXP 80
71863: PPUSH
71864: LD_VAR 0 2
71868: PPUSH
71869: EMPTY
71870: PPUSH
71871: CALL_OW 1
71875: ST_TO_ADDR
// Attack ( tmp ) ;
71876: LD_VAR 0 3
71880: PPUSH
71881: CALL 106581 0 1
// exit ;
71885: POP
71886: POP
71887: GO 71893
// end ; end ;
71889: GO 71819
71891: POP
71892: POP
// end ;
71893: LD_VAR 0 1
71897: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
71898: LD_INT 0
71900: PPUSH
71901: PPUSH
71902: PPUSH
71903: PPUSH
71904: PPUSH
71905: PPUSH
71906: PPUSH
// if not mc_bases then
71907: LD_EXP 60
71911: NOT
71912: IFFALSE 71916
// exit ;
71914: GO 72773
// for i = 1 to mc_bases do
71916: LD_ADDR_VAR 0 2
71920: PUSH
71921: DOUBLE
71922: LD_INT 1
71924: DEC
71925: ST_TO_ADDR
71926: LD_EXP 60
71930: PUSH
71931: FOR_TO
71932: IFFALSE 72771
// begin if not mc_bases [ i ] then
71934: LD_EXP 60
71938: PUSH
71939: LD_VAR 0 2
71943: ARRAY
71944: NOT
71945: IFFALSE 71949
// continue ;
71947: GO 71931
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
71949: LD_ADDR_VAR 0 7
71953: PUSH
71954: LD_EXP 60
71958: PUSH
71959: LD_VAR 0 2
71963: ARRAY
71964: PUSH
71965: LD_INT 1
71967: ARRAY
71968: PPUSH
71969: CALL 16640 0 1
71973: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
71974: LD_ADDR_EXP 83
71978: PUSH
71979: LD_EXP 83
71983: PPUSH
71984: LD_VAR 0 2
71988: PPUSH
71989: LD_EXP 60
71993: PUSH
71994: LD_VAR 0 2
71998: ARRAY
71999: PUSH
72000: LD_INT 1
72002: ARRAY
72003: PPUSH
72004: CALL_OW 255
72008: PPUSH
72009: LD_EXP 85
72013: PUSH
72014: LD_VAR 0 2
72018: ARRAY
72019: PPUSH
72020: CALL 16605 0 2
72024: PPUSH
72025: CALL_OW 1
72029: ST_TO_ADDR
// if not mc_scan [ i ] then
72030: LD_EXP 83
72034: PUSH
72035: LD_VAR 0 2
72039: ARRAY
72040: NOT
72041: IFFALSE 72219
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
72043: LD_ADDR_EXP 103
72047: PUSH
72048: LD_EXP 103
72052: PPUSH
72053: LD_VAR 0 2
72057: PPUSH
72058: LD_INT 0
72060: PPUSH
72061: CALL_OW 1
72065: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72066: LD_ADDR_VAR 0 4
72070: PUSH
72071: LD_EXP 60
72075: PUSH
72076: LD_VAR 0 2
72080: ARRAY
72081: PPUSH
72082: LD_INT 2
72084: PUSH
72085: LD_INT 25
72087: PUSH
72088: LD_INT 5
72090: PUSH
72091: EMPTY
72092: LIST
72093: LIST
72094: PUSH
72095: LD_INT 25
72097: PUSH
72098: LD_INT 8
72100: PUSH
72101: EMPTY
72102: LIST
72103: LIST
72104: PUSH
72105: LD_INT 25
72107: PUSH
72108: LD_INT 9
72110: PUSH
72111: EMPTY
72112: LIST
72113: LIST
72114: PUSH
72115: EMPTY
72116: LIST
72117: LIST
72118: LIST
72119: LIST
72120: PPUSH
72121: CALL_OW 72
72125: ST_TO_ADDR
// if not tmp then
72126: LD_VAR 0 4
72130: NOT
72131: IFFALSE 72135
// continue ;
72133: GO 71931
// for j in tmp do
72135: LD_ADDR_VAR 0 3
72139: PUSH
72140: LD_VAR 0 4
72144: PUSH
72145: FOR_IN
72146: IFFALSE 72217
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
72148: LD_VAR 0 3
72152: PPUSH
72153: CALL_OW 310
72157: PPUSH
72158: CALL_OW 266
72162: PUSH
72163: LD_INT 5
72165: EQUAL
72166: PUSH
72167: LD_VAR 0 3
72171: PPUSH
72172: CALL_OW 257
72176: PUSH
72177: LD_INT 1
72179: EQUAL
72180: AND
72181: PUSH
72182: LD_VAR 0 3
72186: PPUSH
72187: CALL_OW 459
72191: NOT
72192: AND
72193: PUSH
72194: LD_VAR 0 7
72198: AND
72199: IFFALSE 72215
// ComChangeProfession ( j , class ) ;
72201: LD_VAR 0 3
72205: PPUSH
72206: LD_VAR 0 7
72210: PPUSH
72211: CALL_OW 123
72215: GO 72145
72217: POP
72218: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
72219: LD_EXP 83
72223: PUSH
72224: LD_VAR 0 2
72228: ARRAY
72229: PUSH
72230: LD_EXP 103
72234: PUSH
72235: LD_VAR 0 2
72239: ARRAY
72240: NOT
72241: AND
72242: PUSH
72243: LD_EXP 82
72247: PUSH
72248: LD_VAR 0 2
72252: ARRAY
72253: NOT
72254: AND
72255: PUSH
72256: LD_EXP 60
72260: PUSH
72261: LD_VAR 0 2
72265: ARRAY
72266: PPUSH
72267: LD_INT 50
72269: PUSH
72270: EMPTY
72271: LIST
72272: PUSH
72273: LD_INT 2
72275: PUSH
72276: LD_INT 30
72278: PUSH
72279: LD_INT 32
72281: PUSH
72282: EMPTY
72283: LIST
72284: LIST
72285: PUSH
72286: LD_INT 30
72288: PUSH
72289: LD_INT 33
72291: PUSH
72292: EMPTY
72293: LIST
72294: LIST
72295: PUSH
72296: LD_INT 30
72298: PUSH
72299: LD_INT 4
72301: PUSH
72302: EMPTY
72303: LIST
72304: LIST
72305: PUSH
72306: LD_INT 30
72308: PUSH
72309: LD_INT 5
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: PUSH
72316: EMPTY
72317: LIST
72318: LIST
72319: LIST
72320: LIST
72321: LIST
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: PPUSH
72327: CALL_OW 72
72331: PUSH
72332: LD_INT 4
72334: LESS
72335: PUSH
72336: LD_EXP 60
72340: PUSH
72341: LD_VAR 0 2
72345: ARRAY
72346: PPUSH
72347: LD_INT 3
72349: PUSH
72350: LD_INT 24
72352: PUSH
72353: LD_INT 1000
72355: PUSH
72356: EMPTY
72357: LIST
72358: LIST
72359: PUSH
72360: EMPTY
72361: LIST
72362: LIST
72363: PUSH
72364: LD_INT 2
72366: PUSH
72367: LD_INT 30
72369: PUSH
72370: LD_INT 0
72372: PUSH
72373: EMPTY
72374: LIST
72375: LIST
72376: PUSH
72377: LD_INT 30
72379: PUSH
72380: LD_INT 1
72382: PUSH
72383: EMPTY
72384: LIST
72385: LIST
72386: PUSH
72387: EMPTY
72388: LIST
72389: LIST
72390: LIST
72391: PUSH
72392: EMPTY
72393: LIST
72394: LIST
72395: PPUSH
72396: CALL_OW 72
72400: OR
72401: AND
72402: IFFALSE 72653
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
72404: LD_ADDR_EXP 103
72408: PUSH
72409: LD_EXP 103
72413: PPUSH
72414: LD_VAR 0 2
72418: PPUSH
72419: LD_INT 1
72421: PPUSH
72422: CALL_OW 1
72426: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72427: LD_ADDR_VAR 0 4
72431: PUSH
72432: LD_EXP 60
72436: PUSH
72437: LD_VAR 0 2
72441: ARRAY
72442: PPUSH
72443: LD_INT 2
72445: PUSH
72446: LD_INT 25
72448: PUSH
72449: LD_INT 1
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: PUSH
72456: LD_INT 25
72458: PUSH
72459: LD_INT 5
72461: PUSH
72462: EMPTY
72463: LIST
72464: LIST
72465: PUSH
72466: LD_INT 25
72468: PUSH
72469: LD_INT 8
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: PUSH
72476: LD_INT 25
72478: PUSH
72479: LD_INT 9
72481: PUSH
72482: EMPTY
72483: LIST
72484: LIST
72485: PUSH
72486: EMPTY
72487: LIST
72488: LIST
72489: LIST
72490: LIST
72491: LIST
72492: PPUSH
72493: CALL_OW 72
72497: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
72498: LD_ADDR_VAR 0 4
72502: PUSH
72503: LD_VAR 0 4
72507: PUSH
72508: LD_VAR 0 4
72512: PPUSH
72513: LD_INT 18
72515: PPUSH
72516: CALL 49804 0 2
72520: DIFF
72521: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
72522: LD_VAR 0 4
72526: NOT
72527: PUSH
72528: LD_EXP 60
72532: PUSH
72533: LD_VAR 0 2
72537: ARRAY
72538: PPUSH
72539: LD_INT 2
72541: PUSH
72542: LD_INT 30
72544: PUSH
72545: LD_INT 4
72547: PUSH
72548: EMPTY
72549: LIST
72550: LIST
72551: PUSH
72552: LD_INT 30
72554: PUSH
72555: LD_INT 5
72557: PUSH
72558: EMPTY
72559: LIST
72560: LIST
72561: PUSH
72562: EMPTY
72563: LIST
72564: LIST
72565: LIST
72566: PPUSH
72567: CALL_OW 72
72571: NOT
72572: AND
72573: IFFALSE 72635
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
72575: LD_ADDR_VAR 0 4
72579: PUSH
72580: LD_EXP 60
72584: PUSH
72585: LD_VAR 0 2
72589: ARRAY
72590: PPUSH
72591: LD_INT 2
72593: PUSH
72594: LD_INT 25
72596: PUSH
72597: LD_INT 2
72599: PUSH
72600: EMPTY
72601: LIST
72602: LIST
72603: PUSH
72604: LD_INT 25
72606: PUSH
72607: LD_INT 3
72609: PUSH
72610: EMPTY
72611: LIST
72612: LIST
72613: PUSH
72614: LD_INT 25
72616: PUSH
72617: LD_INT 4
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: EMPTY
72625: LIST
72626: LIST
72627: LIST
72628: LIST
72629: PPUSH
72630: CALL_OW 72
72634: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
72635: LD_VAR 0 2
72639: PPUSH
72640: LD_VAR 0 4
72644: PPUSH
72645: CALL 111290 0 2
// exit ;
72649: POP
72650: POP
72651: GO 72773
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
72653: LD_EXP 83
72657: PUSH
72658: LD_VAR 0 2
72662: ARRAY
72663: PUSH
72664: LD_EXP 103
72668: PUSH
72669: LD_VAR 0 2
72673: ARRAY
72674: NOT
72675: AND
72676: PUSH
72677: LD_EXP 82
72681: PUSH
72682: LD_VAR 0 2
72686: ARRAY
72687: AND
72688: IFFALSE 72769
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
72690: LD_ADDR_EXP 103
72694: PUSH
72695: LD_EXP 103
72699: PPUSH
72700: LD_VAR 0 2
72704: PPUSH
72705: LD_INT 1
72707: PPUSH
72708: CALL_OW 1
72712: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
72713: LD_ADDR_VAR 0 4
72717: PUSH
72718: LD_EXP 82
72722: PUSH
72723: LD_VAR 0 2
72727: ARRAY
72728: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
72729: LD_ADDR_EXP 82
72733: PUSH
72734: LD_EXP 82
72738: PPUSH
72739: LD_VAR 0 2
72743: PPUSH
72744: EMPTY
72745: PPUSH
72746: CALL_OW 1
72750: ST_TO_ADDR
// Defend ( i , tmp ) ;
72751: LD_VAR 0 2
72755: PPUSH
72756: LD_VAR 0 4
72760: PPUSH
72761: CALL 111886 0 2
// exit ;
72765: POP
72766: POP
72767: GO 72773
// end ; end ;
72769: GO 71931
72771: POP
72772: POP
// end ;
72773: LD_VAR 0 1
72777: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
72778: LD_INT 0
72780: PPUSH
72781: PPUSH
72782: PPUSH
72783: PPUSH
72784: PPUSH
72785: PPUSH
72786: PPUSH
72787: PPUSH
72788: PPUSH
72789: PPUSH
72790: PPUSH
// if not mc_bases then
72791: LD_EXP 60
72795: NOT
72796: IFFALSE 72800
// exit ;
72798: GO 73887
// for i = 1 to mc_bases do
72800: LD_ADDR_VAR 0 2
72804: PUSH
72805: DOUBLE
72806: LD_INT 1
72808: DEC
72809: ST_TO_ADDR
72810: LD_EXP 60
72814: PUSH
72815: FOR_TO
72816: IFFALSE 73885
// begin tmp := mc_lab [ i ] ;
72818: LD_ADDR_VAR 0 6
72822: PUSH
72823: LD_EXP 93
72827: PUSH
72828: LD_VAR 0 2
72832: ARRAY
72833: ST_TO_ADDR
// if not tmp then
72834: LD_VAR 0 6
72838: NOT
72839: IFFALSE 72843
// continue ;
72841: GO 72815
// idle_lab := 0 ;
72843: LD_ADDR_VAR 0 11
72847: PUSH
72848: LD_INT 0
72850: ST_TO_ADDR
// for j in tmp do
72851: LD_ADDR_VAR 0 3
72855: PUSH
72856: LD_VAR 0 6
72860: PUSH
72861: FOR_IN
72862: IFFALSE 73881
// begin researching := false ;
72864: LD_ADDR_VAR 0 10
72868: PUSH
72869: LD_INT 0
72871: ST_TO_ADDR
// side := GetSide ( j ) ;
72872: LD_ADDR_VAR 0 4
72876: PUSH
72877: LD_VAR 0 3
72881: PPUSH
72882: CALL_OW 255
72886: ST_TO_ADDR
// if not mc_tech [ side ] then
72887: LD_EXP 87
72891: PUSH
72892: LD_VAR 0 4
72896: ARRAY
72897: NOT
72898: IFFALSE 72902
// continue ;
72900: GO 72861
// if BuildingStatus ( j ) = bs_idle then
72902: LD_VAR 0 3
72906: PPUSH
72907: CALL_OW 461
72911: PUSH
72912: LD_INT 2
72914: EQUAL
72915: IFFALSE 73103
// begin if idle_lab and UnitsInside ( j ) < 6 then
72917: LD_VAR 0 11
72921: PUSH
72922: LD_VAR 0 3
72926: PPUSH
72927: CALL_OW 313
72931: PUSH
72932: LD_INT 6
72934: LESS
72935: AND
72936: IFFALSE 73007
// begin tmp2 := UnitsInside ( idle_lab ) ;
72938: LD_ADDR_VAR 0 9
72942: PUSH
72943: LD_VAR 0 11
72947: PPUSH
72948: CALL_OW 313
72952: ST_TO_ADDR
// if tmp2 then
72953: LD_VAR 0 9
72957: IFFALSE 72999
// for x in tmp2 do
72959: LD_ADDR_VAR 0 7
72963: PUSH
72964: LD_VAR 0 9
72968: PUSH
72969: FOR_IN
72970: IFFALSE 72997
// begin ComExitBuilding ( x ) ;
72972: LD_VAR 0 7
72976: PPUSH
72977: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72981: LD_VAR 0 7
72985: PPUSH
72986: LD_VAR 0 3
72990: PPUSH
72991: CALL_OW 180
// end ;
72995: GO 72969
72997: POP
72998: POP
// idle_lab := 0 ;
72999: LD_ADDR_VAR 0 11
73003: PUSH
73004: LD_INT 0
73006: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73007: LD_ADDR_VAR 0 5
73011: PUSH
73012: LD_EXP 87
73016: PUSH
73017: LD_VAR 0 4
73021: ARRAY
73022: PUSH
73023: FOR_IN
73024: IFFALSE 73084
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73026: LD_VAR 0 3
73030: PPUSH
73031: LD_VAR 0 5
73035: PPUSH
73036: CALL_OW 430
73040: PUSH
73041: LD_VAR 0 4
73045: PPUSH
73046: LD_VAR 0 5
73050: PPUSH
73051: CALL 15710 0 2
73055: AND
73056: IFFALSE 73082
// begin researching := true ;
73058: LD_ADDR_VAR 0 10
73062: PUSH
73063: LD_INT 1
73065: ST_TO_ADDR
// ComResearch ( j , t ) ;
73066: LD_VAR 0 3
73070: PPUSH
73071: LD_VAR 0 5
73075: PPUSH
73076: CALL_OW 124
// break ;
73080: GO 73084
// end ;
73082: GO 73023
73084: POP
73085: POP
// if not researching then
73086: LD_VAR 0 10
73090: NOT
73091: IFFALSE 73103
// idle_lab := j ;
73093: LD_ADDR_VAR 0 11
73097: PUSH
73098: LD_VAR 0 3
73102: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
73103: LD_VAR 0 3
73107: PPUSH
73108: CALL_OW 461
73112: PUSH
73113: LD_INT 10
73115: EQUAL
73116: IFFALSE 73704
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
73118: LD_EXP 89
73122: PUSH
73123: LD_VAR 0 2
73127: ARRAY
73128: NOT
73129: PUSH
73130: LD_EXP 90
73134: PUSH
73135: LD_VAR 0 2
73139: ARRAY
73140: NOT
73141: AND
73142: PUSH
73143: LD_EXP 87
73147: PUSH
73148: LD_VAR 0 4
73152: ARRAY
73153: PUSH
73154: LD_INT 1
73156: GREATER
73157: AND
73158: IFFALSE 73289
// begin ComCancel ( j ) ;
73160: LD_VAR 0 3
73164: PPUSH
73165: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
73169: LD_ADDR_EXP 87
73173: PUSH
73174: LD_EXP 87
73178: PPUSH
73179: LD_VAR 0 4
73183: PPUSH
73184: LD_EXP 87
73188: PUSH
73189: LD_VAR 0 4
73193: ARRAY
73194: PPUSH
73195: LD_EXP 87
73199: PUSH
73200: LD_VAR 0 4
73204: ARRAY
73205: PUSH
73206: LD_INT 1
73208: MINUS
73209: PPUSH
73210: LD_EXP 87
73214: PUSH
73215: LD_VAR 0 4
73219: ARRAY
73220: PPUSH
73221: LD_INT 0
73223: PPUSH
73224: CALL 19409 0 4
73228: PPUSH
73229: CALL_OW 1
73233: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
73234: LD_ADDR_EXP 87
73238: PUSH
73239: LD_EXP 87
73243: PPUSH
73244: LD_VAR 0 4
73248: PPUSH
73249: LD_EXP 87
73253: PUSH
73254: LD_VAR 0 4
73258: ARRAY
73259: PPUSH
73260: LD_EXP 87
73264: PUSH
73265: LD_VAR 0 4
73269: ARRAY
73270: PPUSH
73271: LD_INT 1
73273: PPUSH
73274: LD_INT 0
73276: PPUSH
73277: CALL 19409 0 4
73281: PPUSH
73282: CALL_OW 1
73286: ST_TO_ADDR
// continue ;
73287: GO 72861
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
73289: LD_EXP 89
73293: PUSH
73294: LD_VAR 0 2
73298: ARRAY
73299: PUSH
73300: LD_EXP 90
73304: PUSH
73305: LD_VAR 0 2
73309: ARRAY
73310: NOT
73311: AND
73312: IFFALSE 73439
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
73314: LD_ADDR_EXP 90
73318: PUSH
73319: LD_EXP 90
73323: PPUSH
73324: LD_VAR 0 2
73328: PUSH
73329: LD_EXP 90
73333: PUSH
73334: LD_VAR 0 2
73338: ARRAY
73339: PUSH
73340: LD_INT 1
73342: PLUS
73343: PUSH
73344: EMPTY
73345: LIST
73346: LIST
73347: PPUSH
73348: LD_EXP 89
73352: PUSH
73353: LD_VAR 0 2
73357: ARRAY
73358: PUSH
73359: LD_INT 1
73361: ARRAY
73362: PPUSH
73363: CALL 19991 0 3
73367: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
73368: LD_EXP 89
73372: PUSH
73373: LD_VAR 0 2
73377: ARRAY
73378: PUSH
73379: LD_INT 1
73381: ARRAY
73382: PPUSH
73383: LD_INT 112
73385: PPUSH
73386: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
73390: LD_ADDR_VAR 0 9
73394: PUSH
73395: LD_EXP 89
73399: PUSH
73400: LD_VAR 0 2
73404: ARRAY
73405: PPUSH
73406: LD_INT 1
73408: PPUSH
73409: CALL_OW 3
73413: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
73414: LD_ADDR_EXP 89
73418: PUSH
73419: LD_EXP 89
73423: PPUSH
73424: LD_VAR 0 2
73428: PPUSH
73429: LD_VAR 0 9
73433: PPUSH
73434: CALL_OW 1
73438: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
73439: LD_EXP 89
73443: PUSH
73444: LD_VAR 0 2
73448: ARRAY
73449: PUSH
73450: LD_EXP 90
73454: PUSH
73455: LD_VAR 0 2
73459: ARRAY
73460: AND
73461: PUSH
73462: LD_EXP 90
73466: PUSH
73467: LD_VAR 0 2
73471: ARRAY
73472: PUSH
73473: LD_INT 1
73475: ARRAY
73476: PPUSH
73477: CALL_OW 310
73481: NOT
73482: AND
73483: PUSH
73484: LD_VAR 0 3
73488: PPUSH
73489: CALL_OW 313
73493: PUSH
73494: LD_INT 6
73496: EQUAL
73497: AND
73498: IFFALSE 73554
// begin tmp2 := UnitsInside ( j ) ;
73500: LD_ADDR_VAR 0 9
73504: PUSH
73505: LD_VAR 0 3
73509: PPUSH
73510: CALL_OW 313
73514: ST_TO_ADDR
// if tmp2 = 6 then
73515: LD_VAR 0 9
73519: PUSH
73520: LD_INT 6
73522: EQUAL
73523: IFFALSE 73554
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
73525: LD_VAR 0 9
73529: PUSH
73530: LD_INT 1
73532: ARRAY
73533: PPUSH
73534: LD_INT 112
73536: PPUSH
73537: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
73541: LD_VAR 0 9
73545: PUSH
73546: LD_INT 1
73548: ARRAY
73549: PPUSH
73550: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
73554: LD_EXP 90
73558: PUSH
73559: LD_VAR 0 2
73563: ARRAY
73564: PUSH
73565: LD_EXP 90
73569: PUSH
73570: LD_VAR 0 2
73574: ARRAY
73575: PUSH
73576: LD_INT 1
73578: ARRAY
73579: PPUSH
73580: CALL_OW 314
73584: NOT
73585: AND
73586: PUSH
73587: LD_EXP 90
73591: PUSH
73592: LD_VAR 0 2
73596: ARRAY
73597: PUSH
73598: LD_INT 1
73600: ARRAY
73601: PPUSH
73602: CALL_OW 310
73606: NOT
73607: AND
73608: IFFALSE 73634
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
73610: LD_EXP 90
73614: PUSH
73615: LD_VAR 0 2
73619: ARRAY
73620: PUSH
73621: LD_INT 1
73623: ARRAY
73624: PPUSH
73625: LD_VAR 0 3
73629: PPUSH
73630: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
73634: LD_EXP 90
73638: PUSH
73639: LD_VAR 0 2
73643: ARRAY
73644: PUSH
73645: LD_INT 1
73647: ARRAY
73648: PPUSH
73649: CALL_OW 310
73653: PUSH
73654: LD_EXP 90
73658: PUSH
73659: LD_VAR 0 2
73663: ARRAY
73664: PUSH
73665: LD_INT 1
73667: ARRAY
73668: PPUSH
73669: CALL_OW 310
73673: PPUSH
73674: CALL_OW 461
73678: PUSH
73679: LD_INT 3
73681: NONEQUAL
73682: AND
73683: IFFALSE 73704
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
73685: LD_EXP 90
73689: PUSH
73690: LD_VAR 0 2
73694: ARRAY
73695: PUSH
73696: LD_INT 1
73698: ARRAY
73699: PPUSH
73700: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
73704: LD_VAR 0 3
73708: PPUSH
73709: CALL_OW 461
73713: PUSH
73714: LD_INT 6
73716: EQUAL
73717: PUSH
73718: LD_VAR 0 6
73722: PUSH
73723: LD_INT 1
73725: GREATER
73726: AND
73727: IFFALSE 73879
// begin sci := [ ] ;
73729: LD_ADDR_VAR 0 8
73733: PUSH
73734: EMPTY
73735: ST_TO_ADDR
// for x in ( tmp diff j ) do
73736: LD_ADDR_VAR 0 7
73740: PUSH
73741: LD_VAR 0 6
73745: PUSH
73746: LD_VAR 0 3
73750: DIFF
73751: PUSH
73752: FOR_IN
73753: IFFALSE 73805
// begin if sci = 6 then
73755: LD_VAR 0 8
73759: PUSH
73760: LD_INT 6
73762: EQUAL
73763: IFFALSE 73767
// break ;
73765: GO 73805
// if BuildingStatus ( x ) = bs_idle then
73767: LD_VAR 0 7
73771: PPUSH
73772: CALL_OW 461
73776: PUSH
73777: LD_INT 2
73779: EQUAL
73780: IFFALSE 73803
// sci := sci ^ UnitsInside ( x ) ;
73782: LD_ADDR_VAR 0 8
73786: PUSH
73787: LD_VAR 0 8
73791: PUSH
73792: LD_VAR 0 7
73796: PPUSH
73797: CALL_OW 313
73801: ADD
73802: ST_TO_ADDR
// end ;
73803: GO 73752
73805: POP
73806: POP
// if not sci then
73807: LD_VAR 0 8
73811: NOT
73812: IFFALSE 73816
// continue ;
73814: GO 72861
// for x in sci do
73816: LD_ADDR_VAR 0 7
73820: PUSH
73821: LD_VAR 0 8
73825: PUSH
73826: FOR_IN
73827: IFFALSE 73877
// if IsInUnit ( x ) and not HasTask ( x ) then
73829: LD_VAR 0 7
73833: PPUSH
73834: CALL_OW 310
73838: PUSH
73839: LD_VAR 0 7
73843: PPUSH
73844: CALL_OW 314
73848: NOT
73849: AND
73850: IFFALSE 73875
// begin ComExitBuilding ( x ) ;
73852: LD_VAR 0 7
73856: PPUSH
73857: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73861: LD_VAR 0 7
73865: PPUSH
73866: LD_VAR 0 3
73870: PPUSH
73871: CALL_OW 180
// end ;
73875: GO 73826
73877: POP
73878: POP
// end ; end ;
73879: GO 72861
73881: POP
73882: POP
// end ;
73883: GO 72815
73885: POP
73886: POP
// end ;
73887: LD_VAR 0 1
73891: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
73892: LD_INT 0
73894: PPUSH
73895: PPUSH
// if not mc_bases then
73896: LD_EXP 60
73900: NOT
73901: IFFALSE 73905
// exit ;
73903: GO 73986
// for i = 1 to mc_bases do
73905: LD_ADDR_VAR 0 2
73909: PUSH
73910: DOUBLE
73911: LD_INT 1
73913: DEC
73914: ST_TO_ADDR
73915: LD_EXP 60
73919: PUSH
73920: FOR_TO
73921: IFFALSE 73984
// if mc_mines [ i ] and mc_miners [ i ] then
73923: LD_EXP 73
73927: PUSH
73928: LD_VAR 0 2
73932: ARRAY
73933: PUSH
73934: LD_EXP 74
73938: PUSH
73939: LD_VAR 0 2
73943: ARRAY
73944: AND
73945: IFFALSE 73982
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
73947: LD_EXP 74
73951: PUSH
73952: LD_VAR 0 2
73956: ARRAY
73957: PUSH
73958: LD_INT 1
73960: ARRAY
73961: PPUSH
73962: CALL_OW 255
73966: PPUSH
73967: LD_EXP 73
73971: PUSH
73972: LD_VAR 0 2
73976: ARRAY
73977: PPUSH
73978: CALL 16793 0 2
73982: GO 73920
73984: POP
73985: POP
// end ;
73986: LD_VAR 0 1
73990: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
73991: LD_INT 0
73993: PPUSH
73994: PPUSH
73995: PPUSH
73996: PPUSH
73997: PPUSH
73998: PPUSH
73999: PPUSH
74000: PPUSH
// if not mc_bases or not mc_parking then
74001: LD_EXP 60
74005: NOT
74006: PUSH
74007: LD_EXP 84
74011: NOT
74012: OR
74013: IFFALSE 74017
// exit ;
74015: GO 74727
// for i = 1 to mc_bases do
74017: LD_ADDR_VAR 0 2
74021: PUSH
74022: DOUBLE
74023: LD_INT 1
74025: DEC
74026: ST_TO_ADDR
74027: LD_EXP 60
74031: PUSH
74032: FOR_TO
74033: IFFALSE 74725
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74035: LD_EXP 60
74039: PUSH
74040: LD_VAR 0 2
74044: ARRAY
74045: NOT
74046: PUSH
74047: LD_EXP 84
74051: PUSH
74052: LD_VAR 0 2
74056: ARRAY
74057: NOT
74058: OR
74059: IFFALSE 74063
// continue ;
74061: GO 74032
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74063: LD_ADDR_VAR 0 5
74067: PUSH
74068: LD_EXP 60
74072: PUSH
74073: LD_VAR 0 2
74077: ARRAY
74078: PUSH
74079: LD_INT 1
74081: ARRAY
74082: PPUSH
74083: CALL_OW 255
74087: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74088: LD_ADDR_VAR 0 6
74092: PUSH
74093: LD_EXP 60
74097: PUSH
74098: LD_VAR 0 2
74102: ARRAY
74103: PPUSH
74104: LD_INT 30
74106: PUSH
74107: LD_INT 3
74109: PUSH
74110: EMPTY
74111: LIST
74112: LIST
74113: PPUSH
74114: CALL_OW 72
74118: ST_TO_ADDR
// if not fac then
74119: LD_VAR 0 6
74123: NOT
74124: IFFALSE 74175
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74126: LD_ADDR_VAR 0 6
74130: PUSH
74131: LD_EXP 60
74135: PUSH
74136: LD_VAR 0 2
74140: ARRAY
74141: PPUSH
74142: LD_INT 2
74144: PUSH
74145: LD_INT 30
74147: PUSH
74148: LD_INT 0
74150: PUSH
74151: EMPTY
74152: LIST
74153: LIST
74154: PUSH
74155: LD_INT 30
74157: PUSH
74158: LD_INT 1
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: PUSH
74165: EMPTY
74166: LIST
74167: LIST
74168: LIST
74169: PPUSH
74170: CALL_OW 72
74174: ST_TO_ADDR
// if not fac then
74175: LD_VAR 0 6
74179: NOT
74180: IFFALSE 74184
// continue ;
74182: GO 74032
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74184: LD_ADDR_VAR 0 7
74188: PUSH
74189: LD_EXP 84
74193: PUSH
74194: LD_VAR 0 2
74198: ARRAY
74199: PPUSH
74200: LD_INT 22
74202: PUSH
74203: LD_VAR 0 5
74207: PUSH
74208: EMPTY
74209: LIST
74210: LIST
74211: PUSH
74212: LD_INT 21
74214: PUSH
74215: LD_INT 2
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 3
74224: PUSH
74225: LD_INT 24
74227: PUSH
74228: LD_INT 1000
74230: PUSH
74231: EMPTY
74232: LIST
74233: LIST
74234: PUSH
74235: EMPTY
74236: LIST
74237: LIST
74238: PUSH
74239: EMPTY
74240: LIST
74241: LIST
74242: LIST
74243: PPUSH
74244: CALL_OW 70
74248: ST_TO_ADDR
// for j in fac do
74249: LD_ADDR_VAR 0 3
74253: PUSH
74254: LD_VAR 0 6
74258: PUSH
74259: FOR_IN
74260: IFFALSE 74341
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74262: LD_ADDR_VAR 0 7
74266: PUSH
74267: LD_VAR 0 7
74271: PUSH
74272: LD_INT 22
74274: PUSH
74275: LD_VAR 0 5
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PUSH
74284: LD_INT 91
74286: PUSH
74287: LD_VAR 0 3
74291: PUSH
74292: LD_INT 15
74294: PUSH
74295: EMPTY
74296: LIST
74297: LIST
74298: LIST
74299: PUSH
74300: LD_INT 21
74302: PUSH
74303: LD_INT 2
74305: PUSH
74306: EMPTY
74307: LIST
74308: LIST
74309: PUSH
74310: LD_INT 3
74312: PUSH
74313: LD_INT 24
74315: PUSH
74316: LD_INT 1000
74318: PUSH
74319: EMPTY
74320: LIST
74321: LIST
74322: PUSH
74323: EMPTY
74324: LIST
74325: LIST
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: LIST
74331: LIST
74332: PPUSH
74333: CALL_OW 69
74337: UNION
74338: ST_TO_ADDR
74339: GO 74259
74341: POP
74342: POP
// if not vehs then
74343: LD_VAR 0 7
74347: NOT
74348: IFFALSE 74374
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
74350: LD_ADDR_EXP 72
74354: PUSH
74355: LD_EXP 72
74359: PPUSH
74360: LD_VAR 0 2
74364: PPUSH
74365: EMPTY
74366: PPUSH
74367: CALL_OW 1
74371: ST_TO_ADDR
// continue ;
74372: GO 74032
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74374: LD_ADDR_VAR 0 8
74378: PUSH
74379: LD_EXP 60
74383: PUSH
74384: LD_VAR 0 2
74388: ARRAY
74389: PPUSH
74390: LD_INT 30
74392: PUSH
74393: LD_INT 3
74395: PUSH
74396: EMPTY
74397: LIST
74398: LIST
74399: PPUSH
74400: CALL_OW 72
74404: ST_TO_ADDR
// if tmp then
74405: LD_VAR 0 8
74409: IFFALSE 74512
// begin for j in tmp do
74411: LD_ADDR_VAR 0 3
74415: PUSH
74416: LD_VAR 0 8
74420: PUSH
74421: FOR_IN
74422: IFFALSE 74510
// for k in UnitsInside ( j ) do
74424: LD_ADDR_VAR 0 4
74428: PUSH
74429: LD_VAR 0 3
74433: PPUSH
74434: CALL_OW 313
74438: PUSH
74439: FOR_IN
74440: IFFALSE 74506
// if k then
74442: LD_VAR 0 4
74446: IFFALSE 74504
// if not k in mc_repair_vehicle [ i ] then
74448: LD_VAR 0 4
74452: PUSH
74453: LD_EXP 72
74457: PUSH
74458: LD_VAR 0 2
74462: ARRAY
74463: IN
74464: NOT
74465: IFFALSE 74504
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
74467: LD_ADDR_EXP 72
74471: PUSH
74472: LD_EXP 72
74476: PPUSH
74477: LD_VAR 0 2
74481: PPUSH
74482: LD_EXP 72
74486: PUSH
74487: LD_VAR 0 2
74491: ARRAY
74492: PUSH
74493: LD_VAR 0 4
74497: UNION
74498: PPUSH
74499: CALL_OW 1
74503: ST_TO_ADDR
74504: GO 74439
74506: POP
74507: POP
74508: GO 74421
74510: POP
74511: POP
// end ; if not mc_repair_vehicle [ i ] then
74512: LD_EXP 72
74516: PUSH
74517: LD_VAR 0 2
74521: ARRAY
74522: NOT
74523: IFFALSE 74527
// continue ;
74525: GO 74032
// for j in mc_repair_vehicle [ i ] do
74527: LD_ADDR_VAR 0 3
74531: PUSH
74532: LD_EXP 72
74536: PUSH
74537: LD_VAR 0 2
74541: ARRAY
74542: PUSH
74543: FOR_IN
74544: IFFALSE 74721
// begin if GetClass ( j ) <> 3 then
74546: LD_VAR 0 3
74550: PPUSH
74551: CALL_OW 257
74555: PUSH
74556: LD_INT 3
74558: NONEQUAL
74559: IFFALSE 74600
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
74561: LD_ADDR_EXP 72
74565: PUSH
74566: LD_EXP 72
74570: PPUSH
74571: LD_VAR 0 2
74575: PPUSH
74576: LD_EXP 72
74580: PUSH
74581: LD_VAR 0 2
74585: ARRAY
74586: PUSH
74587: LD_VAR 0 3
74591: DIFF
74592: PPUSH
74593: CALL_OW 1
74597: ST_TO_ADDR
// continue ;
74598: GO 74543
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74600: LD_VAR 0 3
74604: PPUSH
74605: CALL_OW 311
74609: NOT
74610: PUSH
74611: LD_VAR 0 3
74615: PUSH
74616: LD_EXP 63
74620: PUSH
74621: LD_VAR 0 2
74625: ARRAY
74626: PUSH
74627: LD_INT 1
74629: ARRAY
74630: IN
74631: NOT
74632: AND
74633: PUSH
74634: LD_VAR 0 3
74638: PUSH
74639: LD_EXP 63
74643: PUSH
74644: LD_VAR 0 2
74648: ARRAY
74649: PUSH
74650: LD_INT 2
74652: ARRAY
74653: IN
74654: NOT
74655: AND
74656: IFFALSE 74719
// begin if IsInUnit ( j ) then
74658: LD_VAR 0 3
74662: PPUSH
74663: CALL_OW 310
74667: IFFALSE 74680
// ComExitBuilding ( j ) else
74669: LD_VAR 0 3
74673: PPUSH
74674: CALL_OW 122
74678: GO 74719
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
74680: LD_VAR 0 3
74684: PPUSH
74685: LD_VAR 0 7
74689: PUSH
74690: LD_INT 1
74692: ARRAY
74693: PPUSH
74694: CALL 54295 0 2
74698: NOT
74699: IFFALSE 74719
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
74701: LD_VAR 0 3
74705: PPUSH
74706: LD_VAR 0 7
74710: PUSH
74711: LD_INT 1
74713: ARRAY
74714: PPUSH
74715: CALL_OW 129
// end ; end ;
74719: GO 74543
74721: POP
74722: POP
// end ;
74723: GO 74032
74725: POP
74726: POP
// end ;
74727: LD_VAR 0 1
74731: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
74732: LD_INT 0
74734: PPUSH
74735: PPUSH
74736: PPUSH
74737: PPUSH
74738: PPUSH
74739: PPUSH
74740: PPUSH
74741: PPUSH
74742: PPUSH
74743: PPUSH
74744: PPUSH
// if not mc_bases then
74745: LD_EXP 60
74749: NOT
74750: IFFALSE 74754
// exit ;
74752: GO 75556
// for i = 1 to mc_bases do
74754: LD_ADDR_VAR 0 2
74758: PUSH
74759: DOUBLE
74760: LD_INT 1
74762: DEC
74763: ST_TO_ADDR
74764: LD_EXP 60
74768: PUSH
74769: FOR_TO
74770: IFFALSE 75554
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
74772: LD_EXP 88
74776: PUSH
74777: LD_VAR 0 2
74781: ARRAY
74782: NOT
74783: PUSH
74784: LD_EXP 63
74788: PUSH
74789: LD_VAR 0 2
74793: ARRAY
74794: PUSH
74795: LD_INT 1
74797: ARRAY
74798: OR
74799: PUSH
74800: LD_EXP 63
74804: PUSH
74805: LD_VAR 0 2
74809: ARRAY
74810: PUSH
74811: LD_INT 2
74813: ARRAY
74814: OR
74815: PUSH
74816: LD_EXP 86
74820: PUSH
74821: LD_VAR 0 2
74825: ARRAY
74826: PPUSH
74827: LD_INT 1
74829: PPUSH
74830: CALL_OW 325
74834: NOT
74835: OR
74836: PUSH
74837: LD_EXP 83
74841: PUSH
74842: LD_VAR 0 2
74846: ARRAY
74847: OR
74848: IFFALSE 74852
// continue ;
74850: GO 74769
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
74852: LD_ADDR_VAR 0 8
74856: PUSH
74857: LD_EXP 60
74861: PUSH
74862: LD_VAR 0 2
74866: ARRAY
74867: PPUSH
74868: LD_INT 25
74870: PUSH
74871: LD_INT 4
74873: PUSH
74874: EMPTY
74875: LIST
74876: LIST
74877: PUSH
74878: LD_INT 50
74880: PUSH
74881: EMPTY
74882: LIST
74883: PUSH
74884: LD_INT 3
74886: PUSH
74887: LD_INT 60
74889: PUSH
74890: EMPTY
74891: LIST
74892: PUSH
74893: EMPTY
74894: LIST
74895: LIST
74896: PUSH
74897: EMPTY
74898: LIST
74899: LIST
74900: LIST
74901: PPUSH
74902: CALL_OW 72
74906: PUSH
74907: LD_EXP 64
74911: PUSH
74912: LD_VAR 0 2
74916: ARRAY
74917: DIFF
74918: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74919: LD_ADDR_VAR 0 9
74923: PUSH
74924: LD_EXP 60
74928: PUSH
74929: LD_VAR 0 2
74933: ARRAY
74934: PPUSH
74935: LD_INT 2
74937: PUSH
74938: LD_INT 30
74940: PUSH
74941: LD_INT 0
74943: PUSH
74944: EMPTY
74945: LIST
74946: LIST
74947: PUSH
74948: LD_INT 30
74950: PUSH
74951: LD_INT 1
74953: PUSH
74954: EMPTY
74955: LIST
74956: LIST
74957: PUSH
74958: EMPTY
74959: LIST
74960: LIST
74961: LIST
74962: PPUSH
74963: CALL_OW 72
74967: ST_TO_ADDR
// if not tmp or not dep then
74968: LD_VAR 0 8
74972: NOT
74973: PUSH
74974: LD_VAR 0 9
74978: NOT
74979: OR
74980: IFFALSE 74984
// continue ;
74982: GO 74769
// side := GetSide ( tmp [ 1 ] ) ;
74984: LD_ADDR_VAR 0 11
74988: PUSH
74989: LD_VAR 0 8
74993: PUSH
74994: LD_INT 1
74996: ARRAY
74997: PPUSH
74998: CALL_OW 255
75002: ST_TO_ADDR
// dep := dep [ 1 ] ;
75003: LD_ADDR_VAR 0 9
75007: PUSH
75008: LD_VAR 0 9
75012: PUSH
75013: LD_INT 1
75015: ARRAY
75016: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75017: LD_ADDR_VAR 0 7
75021: PUSH
75022: LD_EXP 88
75026: PUSH
75027: LD_VAR 0 2
75031: ARRAY
75032: PPUSH
75033: LD_INT 22
75035: PUSH
75036: LD_INT 0
75038: PUSH
75039: EMPTY
75040: LIST
75041: LIST
75042: PUSH
75043: LD_INT 25
75045: PUSH
75046: LD_INT 12
75048: PUSH
75049: EMPTY
75050: LIST
75051: LIST
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PPUSH
75057: CALL_OW 70
75061: PUSH
75062: LD_INT 22
75064: PUSH
75065: LD_INT 0
75067: PUSH
75068: EMPTY
75069: LIST
75070: LIST
75071: PUSH
75072: LD_INT 25
75074: PUSH
75075: LD_INT 12
75077: PUSH
75078: EMPTY
75079: LIST
75080: LIST
75081: PUSH
75082: LD_INT 91
75084: PUSH
75085: LD_VAR 0 9
75089: PUSH
75090: LD_INT 20
75092: PUSH
75093: EMPTY
75094: LIST
75095: LIST
75096: LIST
75097: PUSH
75098: EMPTY
75099: LIST
75100: LIST
75101: LIST
75102: PPUSH
75103: CALL_OW 69
75107: UNION
75108: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
75109: LD_ADDR_VAR 0 10
75113: PUSH
75114: LD_EXP 88
75118: PUSH
75119: LD_VAR 0 2
75123: ARRAY
75124: PPUSH
75125: LD_INT 81
75127: PUSH
75128: LD_VAR 0 11
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: PPUSH
75137: CALL_OW 70
75141: ST_TO_ADDR
// if not apes or danger_at_area then
75142: LD_VAR 0 7
75146: NOT
75147: PUSH
75148: LD_VAR 0 10
75152: OR
75153: IFFALSE 75203
// begin if mc_taming [ i ] then
75155: LD_EXP 91
75159: PUSH
75160: LD_VAR 0 2
75164: ARRAY
75165: IFFALSE 75201
// begin MC_Reset ( i , 121 ) ;
75167: LD_VAR 0 2
75171: PPUSH
75172: LD_INT 121
75174: PPUSH
75175: CALL 60193 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
75179: LD_ADDR_EXP 91
75183: PUSH
75184: LD_EXP 91
75188: PPUSH
75189: LD_VAR 0 2
75193: PPUSH
75194: EMPTY
75195: PPUSH
75196: CALL_OW 1
75200: ST_TO_ADDR
// end ; continue ;
75201: GO 74769
// end ; for j in tmp do
75203: LD_ADDR_VAR 0 3
75207: PUSH
75208: LD_VAR 0 8
75212: PUSH
75213: FOR_IN
75214: IFFALSE 75550
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
75216: LD_VAR 0 3
75220: PUSH
75221: LD_EXP 91
75225: PUSH
75226: LD_VAR 0 2
75230: ARRAY
75231: IN
75232: NOT
75233: PUSH
75234: LD_EXP 91
75238: PUSH
75239: LD_VAR 0 2
75243: ARRAY
75244: PUSH
75245: LD_INT 3
75247: LESS
75248: AND
75249: IFFALSE 75307
// begin SetTag ( j , 121 ) ;
75251: LD_VAR 0 3
75255: PPUSH
75256: LD_INT 121
75258: PPUSH
75259: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
75263: LD_ADDR_EXP 91
75267: PUSH
75268: LD_EXP 91
75272: PPUSH
75273: LD_VAR 0 2
75277: PUSH
75278: LD_EXP 91
75282: PUSH
75283: LD_VAR 0 2
75287: ARRAY
75288: PUSH
75289: LD_INT 1
75291: PLUS
75292: PUSH
75293: EMPTY
75294: LIST
75295: LIST
75296: PPUSH
75297: LD_VAR 0 3
75301: PPUSH
75302: CALL 19991 0 3
75306: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
75307: LD_VAR 0 3
75311: PUSH
75312: LD_EXP 91
75316: PUSH
75317: LD_VAR 0 2
75321: ARRAY
75322: IN
75323: IFFALSE 75548
// begin if GetClass ( j ) <> 4 then
75325: LD_VAR 0 3
75329: PPUSH
75330: CALL_OW 257
75334: PUSH
75335: LD_INT 4
75337: NONEQUAL
75338: IFFALSE 75391
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
75340: LD_ADDR_EXP 91
75344: PUSH
75345: LD_EXP 91
75349: PPUSH
75350: LD_VAR 0 2
75354: PPUSH
75355: LD_EXP 91
75359: PUSH
75360: LD_VAR 0 2
75364: ARRAY
75365: PUSH
75366: LD_VAR 0 3
75370: DIFF
75371: PPUSH
75372: CALL_OW 1
75376: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75377: LD_VAR 0 3
75381: PPUSH
75382: LD_INT 0
75384: PPUSH
75385: CALL_OW 109
// continue ;
75389: GO 75213
// end ; if IsInUnit ( j ) then
75391: LD_VAR 0 3
75395: PPUSH
75396: CALL_OW 310
75400: IFFALSE 75411
// ComExitBuilding ( j ) ;
75402: LD_VAR 0 3
75406: PPUSH
75407: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
75411: LD_ADDR_VAR 0 6
75415: PUSH
75416: LD_VAR 0 7
75420: PPUSH
75421: LD_VAR 0 3
75425: PPUSH
75426: CALL_OW 74
75430: ST_TO_ADDR
// if not ape then
75431: LD_VAR 0 6
75435: NOT
75436: IFFALSE 75440
// break ;
75438: GO 75550
// x := GetX ( ape ) ;
75440: LD_ADDR_VAR 0 4
75444: PUSH
75445: LD_VAR 0 6
75449: PPUSH
75450: CALL_OW 250
75454: ST_TO_ADDR
// y := GetY ( ape ) ;
75455: LD_ADDR_VAR 0 5
75459: PUSH
75460: LD_VAR 0 6
75464: PPUSH
75465: CALL_OW 251
75469: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
75470: LD_VAR 0 4
75474: PPUSH
75475: LD_VAR 0 5
75479: PPUSH
75480: CALL_OW 488
75484: NOT
75485: PUSH
75486: LD_VAR 0 11
75490: PPUSH
75491: LD_VAR 0 4
75495: PPUSH
75496: LD_VAR 0 5
75500: PPUSH
75501: LD_INT 20
75503: PPUSH
75504: CALL 20887 0 4
75508: PUSH
75509: LD_INT 4
75511: ARRAY
75512: OR
75513: IFFALSE 75517
// break ;
75515: GO 75550
// if not HasTask ( j ) then
75517: LD_VAR 0 3
75521: PPUSH
75522: CALL_OW 314
75526: NOT
75527: IFFALSE 75548
// ComTameXY ( j , x , y ) ;
75529: LD_VAR 0 3
75533: PPUSH
75534: LD_VAR 0 4
75538: PPUSH
75539: LD_VAR 0 5
75543: PPUSH
75544: CALL_OW 131
// end ; end ;
75548: GO 75213
75550: POP
75551: POP
// end ;
75552: GO 74769
75554: POP
75555: POP
// end ;
75556: LD_VAR 0 1
75560: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
75561: LD_INT 0
75563: PPUSH
75564: PPUSH
75565: PPUSH
75566: PPUSH
75567: PPUSH
75568: PPUSH
75569: PPUSH
75570: PPUSH
// if not mc_bases then
75571: LD_EXP 60
75575: NOT
75576: IFFALSE 75580
// exit ;
75578: GO 76206
// for i = 1 to mc_bases do
75580: LD_ADDR_VAR 0 2
75584: PUSH
75585: DOUBLE
75586: LD_INT 1
75588: DEC
75589: ST_TO_ADDR
75590: LD_EXP 60
75594: PUSH
75595: FOR_TO
75596: IFFALSE 76204
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
75598: LD_EXP 89
75602: PUSH
75603: LD_VAR 0 2
75607: ARRAY
75608: NOT
75609: PUSH
75610: LD_EXP 89
75614: PUSH
75615: LD_VAR 0 2
75619: ARRAY
75620: PPUSH
75621: LD_INT 25
75623: PUSH
75624: LD_INT 12
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: PPUSH
75631: CALL_OW 72
75635: NOT
75636: OR
75637: IFFALSE 75641
// continue ;
75639: GO 75595
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
75641: LD_ADDR_VAR 0 5
75645: PUSH
75646: LD_EXP 89
75650: PUSH
75651: LD_VAR 0 2
75655: ARRAY
75656: PUSH
75657: LD_INT 1
75659: ARRAY
75660: PPUSH
75661: CALL_OW 255
75665: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
75666: LD_VAR 0 5
75670: PPUSH
75671: LD_INT 2
75673: PPUSH
75674: CALL_OW 325
75678: IFFALSE 75931
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75680: LD_ADDR_VAR 0 4
75684: PUSH
75685: LD_EXP 89
75689: PUSH
75690: LD_VAR 0 2
75694: ARRAY
75695: PPUSH
75696: LD_INT 25
75698: PUSH
75699: LD_INT 16
75701: PUSH
75702: EMPTY
75703: LIST
75704: LIST
75705: PPUSH
75706: CALL_OW 72
75710: ST_TO_ADDR
// if tmp < 6 then
75711: LD_VAR 0 4
75715: PUSH
75716: LD_INT 6
75718: LESS
75719: IFFALSE 75931
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75721: LD_ADDR_VAR 0 6
75725: PUSH
75726: LD_EXP 60
75730: PUSH
75731: LD_VAR 0 2
75735: ARRAY
75736: PPUSH
75737: LD_INT 2
75739: PUSH
75740: LD_INT 30
75742: PUSH
75743: LD_INT 0
75745: PUSH
75746: EMPTY
75747: LIST
75748: LIST
75749: PUSH
75750: LD_INT 30
75752: PUSH
75753: LD_INT 1
75755: PUSH
75756: EMPTY
75757: LIST
75758: LIST
75759: PUSH
75760: EMPTY
75761: LIST
75762: LIST
75763: LIST
75764: PPUSH
75765: CALL_OW 72
75769: ST_TO_ADDR
// if depot then
75770: LD_VAR 0 6
75774: IFFALSE 75931
// begin selected := 0 ;
75776: LD_ADDR_VAR 0 7
75780: PUSH
75781: LD_INT 0
75783: ST_TO_ADDR
// for j in depot do
75784: LD_ADDR_VAR 0 3
75788: PUSH
75789: LD_VAR 0 6
75793: PUSH
75794: FOR_IN
75795: IFFALSE 75826
// begin if UnitsInside ( j ) < 6 then
75797: LD_VAR 0 3
75801: PPUSH
75802: CALL_OW 313
75806: PUSH
75807: LD_INT 6
75809: LESS
75810: IFFALSE 75824
// begin selected := j ;
75812: LD_ADDR_VAR 0 7
75816: PUSH
75817: LD_VAR 0 3
75821: ST_TO_ADDR
// break ;
75822: GO 75826
// end ; end ;
75824: GO 75794
75826: POP
75827: POP
// if selected then
75828: LD_VAR 0 7
75832: IFFALSE 75931
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75834: LD_ADDR_VAR 0 3
75838: PUSH
75839: LD_EXP 89
75843: PUSH
75844: LD_VAR 0 2
75848: ARRAY
75849: PPUSH
75850: LD_INT 25
75852: PUSH
75853: LD_INT 12
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: PPUSH
75860: CALL_OW 72
75864: PUSH
75865: FOR_IN
75866: IFFALSE 75929
// if not HasTask ( j ) then
75868: LD_VAR 0 3
75872: PPUSH
75873: CALL_OW 314
75877: NOT
75878: IFFALSE 75927
// begin if not IsInUnit ( j ) then
75880: LD_VAR 0 3
75884: PPUSH
75885: CALL_OW 310
75889: NOT
75890: IFFALSE 75906
// ComEnterUnit ( j , selected ) ;
75892: LD_VAR 0 3
75896: PPUSH
75897: LD_VAR 0 7
75901: PPUSH
75902: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
75906: LD_VAR 0 3
75910: PPUSH
75911: LD_INT 16
75913: PPUSH
75914: CALL_OW 183
// AddComExitBuilding ( j ) ;
75918: LD_VAR 0 3
75922: PPUSH
75923: CALL_OW 182
// end ;
75927: GO 75865
75929: POP
75930: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
75931: LD_VAR 0 5
75935: PPUSH
75936: LD_INT 11
75938: PPUSH
75939: CALL_OW 325
75943: IFFALSE 76202
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75945: LD_ADDR_VAR 0 4
75949: PUSH
75950: LD_EXP 89
75954: PUSH
75955: LD_VAR 0 2
75959: ARRAY
75960: PPUSH
75961: LD_INT 25
75963: PUSH
75964: LD_INT 16
75966: PUSH
75967: EMPTY
75968: LIST
75969: LIST
75970: PPUSH
75971: CALL_OW 72
75975: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
75976: LD_VAR 0 4
75980: PUSH
75981: LD_INT 6
75983: GREATEREQUAL
75984: PUSH
75985: LD_VAR 0 5
75989: PPUSH
75990: LD_INT 2
75992: PPUSH
75993: CALL_OW 325
75997: NOT
75998: OR
75999: IFFALSE 76202
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76001: LD_ADDR_VAR 0 8
76005: PUSH
76006: LD_EXP 60
76010: PUSH
76011: LD_VAR 0 2
76015: ARRAY
76016: PPUSH
76017: LD_INT 2
76019: PUSH
76020: LD_INT 30
76022: PUSH
76023: LD_INT 4
76025: PUSH
76026: EMPTY
76027: LIST
76028: LIST
76029: PUSH
76030: LD_INT 30
76032: PUSH
76033: LD_INT 5
76035: PUSH
76036: EMPTY
76037: LIST
76038: LIST
76039: PUSH
76040: EMPTY
76041: LIST
76042: LIST
76043: LIST
76044: PPUSH
76045: CALL_OW 72
76049: ST_TO_ADDR
// if barracks then
76050: LD_VAR 0 8
76054: IFFALSE 76202
// begin selected := 0 ;
76056: LD_ADDR_VAR 0 7
76060: PUSH
76061: LD_INT 0
76063: ST_TO_ADDR
// for j in barracks do
76064: LD_ADDR_VAR 0 3
76068: PUSH
76069: LD_VAR 0 8
76073: PUSH
76074: FOR_IN
76075: IFFALSE 76106
// begin if UnitsInside ( j ) < 6 then
76077: LD_VAR 0 3
76081: PPUSH
76082: CALL_OW 313
76086: PUSH
76087: LD_INT 6
76089: LESS
76090: IFFALSE 76104
// begin selected := j ;
76092: LD_ADDR_VAR 0 7
76096: PUSH
76097: LD_VAR 0 3
76101: ST_TO_ADDR
// break ;
76102: GO 76106
// end ; end ;
76104: GO 76074
76106: POP
76107: POP
// if selected then
76108: LD_VAR 0 7
76112: IFFALSE 76202
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76114: LD_ADDR_VAR 0 3
76118: PUSH
76119: LD_EXP 89
76123: PUSH
76124: LD_VAR 0 2
76128: ARRAY
76129: PPUSH
76130: LD_INT 25
76132: PUSH
76133: LD_INT 12
76135: PUSH
76136: EMPTY
76137: LIST
76138: LIST
76139: PPUSH
76140: CALL_OW 72
76144: PUSH
76145: FOR_IN
76146: IFFALSE 76200
// if not IsInUnit ( j ) and not HasTask ( j ) then
76148: LD_VAR 0 3
76152: PPUSH
76153: CALL_OW 310
76157: NOT
76158: PUSH
76159: LD_VAR 0 3
76163: PPUSH
76164: CALL_OW 314
76168: NOT
76169: AND
76170: IFFALSE 76198
// begin ComEnterUnit ( j , selected ) ;
76172: LD_VAR 0 3
76176: PPUSH
76177: LD_VAR 0 7
76181: PPUSH
76182: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
76186: LD_VAR 0 3
76190: PPUSH
76191: LD_INT 15
76193: PPUSH
76194: CALL_OW 183
// end ;
76198: GO 76145
76200: POP
76201: POP
// end ; end ; end ; end ; end ;
76202: GO 75595
76204: POP
76205: POP
// end ;
76206: LD_VAR 0 1
76210: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
76211: LD_INT 0
76213: PPUSH
76214: PPUSH
76215: PPUSH
76216: PPUSH
// if not mc_bases then
76217: LD_EXP 60
76221: NOT
76222: IFFALSE 76226
// exit ;
76224: GO 76404
// for i = 1 to mc_bases do
76226: LD_ADDR_VAR 0 2
76230: PUSH
76231: DOUBLE
76232: LD_INT 1
76234: DEC
76235: ST_TO_ADDR
76236: LD_EXP 60
76240: PUSH
76241: FOR_TO
76242: IFFALSE 76402
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
76244: LD_ADDR_VAR 0 4
76248: PUSH
76249: LD_EXP 60
76253: PUSH
76254: LD_VAR 0 2
76258: ARRAY
76259: PPUSH
76260: LD_INT 25
76262: PUSH
76263: LD_INT 9
76265: PUSH
76266: EMPTY
76267: LIST
76268: LIST
76269: PPUSH
76270: CALL_OW 72
76274: ST_TO_ADDR
// if not tmp then
76275: LD_VAR 0 4
76279: NOT
76280: IFFALSE 76284
// continue ;
76282: GO 76241
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
76284: LD_EXP 86
76288: PUSH
76289: LD_VAR 0 2
76293: ARRAY
76294: PPUSH
76295: LD_INT 29
76297: PPUSH
76298: CALL_OW 325
76302: NOT
76303: PUSH
76304: LD_EXP 86
76308: PUSH
76309: LD_VAR 0 2
76313: ARRAY
76314: PPUSH
76315: LD_INT 28
76317: PPUSH
76318: CALL_OW 325
76322: NOT
76323: AND
76324: IFFALSE 76328
// continue ;
76326: GO 76241
// for j in tmp do
76328: LD_ADDR_VAR 0 3
76332: PUSH
76333: LD_VAR 0 4
76337: PUSH
76338: FOR_IN
76339: IFFALSE 76398
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
76341: LD_VAR 0 3
76345: PUSH
76346: LD_EXP 63
76350: PUSH
76351: LD_VAR 0 2
76355: ARRAY
76356: PUSH
76357: LD_INT 1
76359: ARRAY
76360: IN
76361: NOT
76362: PUSH
76363: LD_VAR 0 3
76367: PUSH
76368: LD_EXP 63
76372: PUSH
76373: LD_VAR 0 2
76377: ARRAY
76378: PUSH
76379: LD_INT 2
76381: ARRAY
76382: IN
76383: NOT
76384: AND
76385: IFFALSE 76396
// ComSpaceTimeShoot ( j ) ;
76387: LD_VAR 0 3
76391: PPUSH
76392: CALL 15801 0 1
76396: GO 76338
76398: POP
76399: POP
// end ;
76400: GO 76241
76402: POP
76403: POP
// end ;
76404: LD_VAR 0 1
76408: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
76409: LD_INT 0
76411: PPUSH
76412: PPUSH
76413: PPUSH
76414: PPUSH
76415: PPUSH
76416: PPUSH
76417: PPUSH
76418: PPUSH
76419: PPUSH
// if not mc_bases then
76420: LD_EXP 60
76424: NOT
76425: IFFALSE 76429
// exit ;
76427: GO 77051
// for i = 1 to mc_bases do
76429: LD_ADDR_VAR 0 2
76433: PUSH
76434: DOUBLE
76435: LD_INT 1
76437: DEC
76438: ST_TO_ADDR
76439: LD_EXP 60
76443: PUSH
76444: FOR_TO
76445: IFFALSE 77049
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
76447: LD_EXP 95
76451: PUSH
76452: LD_VAR 0 2
76456: ARRAY
76457: NOT
76458: PUSH
76459: LD_INT 38
76461: PPUSH
76462: LD_EXP 86
76466: PUSH
76467: LD_VAR 0 2
76471: ARRAY
76472: PPUSH
76473: CALL_OW 321
76477: PUSH
76478: LD_INT 2
76480: NONEQUAL
76481: OR
76482: IFFALSE 76486
// continue ;
76484: GO 76444
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
76486: LD_ADDR_VAR 0 8
76490: PUSH
76491: LD_EXP 60
76495: PUSH
76496: LD_VAR 0 2
76500: ARRAY
76501: PPUSH
76502: LD_INT 30
76504: PUSH
76505: LD_INT 34
76507: PUSH
76508: EMPTY
76509: LIST
76510: LIST
76511: PPUSH
76512: CALL_OW 72
76516: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
76517: LD_ADDR_VAR 0 9
76521: PUSH
76522: LD_EXP 60
76526: PUSH
76527: LD_VAR 0 2
76531: ARRAY
76532: PPUSH
76533: LD_INT 25
76535: PUSH
76536: LD_INT 4
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PPUSH
76543: CALL_OW 72
76547: PPUSH
76548: LD_INT 0
76550: PPUSH
76551: CALL 49804 0 2
76555: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
76556: LD_VAR 0 9
76560: NOT
76561: PUSH
76562: LD_VAR 0 8
76566: NOT
76567: OR
76568: PUSH
76569: LD_EXP 60
76573: PUSH
76574: LD_VAR 0 2
76578: ARRAY
76579: PPUSH
76580: LD_INT 124
76582: PPUSH
76583: CALL 49804 0 2
76587: OR
76588: IFFALSE 76592
// continue ;
76590: GO 76444
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
76592: LD_EXP 96
76596: PUSH
76597: LD_VAR 0 2
76601: ARRAY
76602: PUSH
76603: LD_EXP 95
76607: PUSH
76608: LD_VAR 0 2
76612: ARRAY
76613: LESS
76614: PUSH
76615: LD_EXP 96
76619: PUSH
76620: LD_VAR 0 2
76624: ARRAY
76625: PUSH
76626: LD_VAR 0 8
76630: LESS
76631: AND
76632: IFFALSE 77047
// begin tmp := sci [ 1 ] ;
76634: LD_ADDR_VAR 0 7
76638: PUSH
76639: LD_VAR 0 9
76643: PUSH
76644: LD_INT 1
76646: ARRAY
76647: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
76648: LD_VAR 0 7
76652: PPUSH
76653: LD_INT 124
76655: PPUSH
76656: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
76660: LD_ADDR_VAR 0 3
76664: PUSH
76665: DOUBLE
76666: LD_EXP 95
76670: PUSH
76671: LD_VAR 0 2
76675: ARRAY
76676: INC
76677: ST_TO_ADDR
76678: LD_EXP 95
76682: PUSH
76683: LD_VAR 0 2
76687: ARRAY
76688: PUSH
76689: FOR_DOWNTO
76690: IFFALSE 77033
// begin if IsInUnit ( tmp ) then
76692: LD_VAR 0 7
76696: PPUSH
76697: CALL_OW 310
76701: IFFALSE 76712
// ComExitBuilding ( tmp ) ;
76703: LD_VAR 0 7
76707: PPUSH
76708: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
76712: LD_INT 35
76714: PPUSH
76715: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
76719: LD_VAR 0 7
76723: PPUSH
76724: CALL_OW 310
76728: NOT
76729: PUSH
76730: LD_VAR 0 7
76734: PPUSH
76735: CALL_OW 314
76739: NOT
76740: AND
76741: IFFALSE 76712
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
76743: LD_ADDR_VAR 0 6
76747: PUSH
76748: LD_VAR 0 7
76752: PPUSH
76753: CALL_OW 250
76757: PUSH
76758: LD_VAR 0 7
76762: PPUSH
76763: CALL_OW 251
76767: PUSH
76768: EMPTY
76769: LIST
76770: LIST
76771: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
76772: LD_INT 35
76774: PPUSH
76775: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
76779: LD_ADDR_VAR 0 4
76783: PUSH
76784: LD_EXP 95
76788: PUSH
76789: LD_VAR 0 2
76793: ARRAY
76794: PUSH
76795: LD_VAR 0 3
76799: ARRAY
76800: PUSH
76801: LD_INT 1
76803: ARRAY
76804: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
76805: LD_ADDR_VAR 0 5
76809: PUSH
76810: LD_EXP 95
76814: PUSH
76815: LD_VAR 0 2
76819: ARRAY
76820: PUSH
76821: LD_VAR 0 3
76825: ARRAY
76826: PUSH
76827: LD_INT 2
76829: ARRAY
76830: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
76831: LD_VAR 0 7
76835: PPUSH
76836: LD_INT 10
76838: PPUSH
76839: CALL 22588 0 2
76843: PUSH
76844: LD_INT 4
76846: ARRAY
76847: IFFALSE 76885
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
76849: LD_VAR 0 7
76853: PPUSH
76854: LD_VAR 0 6
76858: PUSH
76859: LD_INT 1
76861: ARRAY
76862: PPUSH
76863: LD_VAR 0 6
76867: PUSH
76868: LD_INT 2
76870: ARRAY
76871: PPUSH
76872: CALL_OW 111
// wait ( 0 0$10 ) ;
76876: LD_INT 350
76878: PPUSH
76879: CALL_OW 67
// end else
76883: GO 76911
// begin ComMoveXY ( tmp , x , y ) ;
76885: LD_VAR 0 7
76889: PPUSH
76890: LD_VAR 0 4
76894: PPUSH
76895: LD_VAR 0 5
76899: PPUSH
76900: CALL_OW 111
// wait ( 0 0$3 ) ;
76904: LD_INT 105
76906: PPUSH
76907: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
76911: LD_VAR 0 7
76915: PPUSH
76916: LD_VAR 0 4
76920: PPUSH
76921: LD_VAR 0 5
76925: PPUSH
76926: CALL_OW 307
76930: IFFALSE 76772
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
76932: LD_VAR 0 7
76936: PPUSH
76937: LD_VAR 0 4
76941: PPUSH
76942: LD_VAR 0 5
76946: PPUSH
76947: LD_VAR 0 8
76951: PUSH
76952: LD_VAR 0 3
76956: ARRAY
76957: PPUSH
76958: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
76962: LD_INT 35
76964: PPUSH
76965: CALL_OW 67
// until not HasTask ( tmp ) ;
76969: LD_VAR 0 7
76973: PPUSH
76974: CALL_OW 314
76978: NOT
76979: IFFALSE 76962
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
76981: LD_ADDR_EXP 96
76985: PUSH
76986: LD_EXP 96
76990: PPUSH
76991: LD_VAR 0 2
76995: PUSH
76996: LD_EXP 96
77000: PUSH
77001: LD_VAR 0 2
77005: ARRAY
77006: PUSH
77007: LD_INT 1
77009: PLUS
77010: PUSH
77011: EMPTY
77012: LIST
77013: LIST
77014: PPUSH
77015: LD_VAR 0 8
77019: PUSH
77020: LD_VAR 0 3
77024: ARRAY
77025: PPUSH
77026: CALL 19991 0 3
77030: ST_TO_ADDR
// end ;
77031: GO 76689
77033: POP
77034: POP
// MC_Reset ( i , 124 ) ;
77035: LD_VAR 0 2
77039: PPUSH
77040: LD_INT 124
77042: PPUSH
77043: CALL 60193 0 2
// end ; end ;
77047: GO 76444
77049: POP
77050: POP
// end ;
77051: LD_VAR 0 1
77055: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77056: LD_INT 0
77058: PPUSH
77059: PPUSH
77060: PPUSH
// if not mc_bases then
77061: LD_EXP 60
77065: NOT
77066: IFFALSE 77070
// exit ;
77068: GO 77676
// for i = 1 to mc_bases do
77070: LD_ADDR_VAR 0 2
77074: PUSH
77075: DOUBLE
77076: LD_INT 1
77078: DEC
77079: ST_TO_ADDR
77080: LD_EXP 60
77084: PUSH
77085: FOR_TO
77086: IFFALSE 77674
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77088: LD_ADDR_VAR 0 3
77092: PUSH
77093: LD_EXP 60
77097: PUSH
77098: LD_VAR 0 2
77102: ARRAY
77103: PPUSH
77104: LD_INT 25
77106: PUSH
77107: LD_INT 4
77109: PUSH
77110: EMPTY
77111: LIST
77112: LIST
77113: PPUSH
77114: CALL_OW 72
77118: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
77119: LD_VAR 0 3
77123: NOT
77124: PUSH
77125: LD_EXP 97
77129: PUSH
77130: LD_VAR 0 2
77134: ARRAY
77135: NOT
77136: OR
77137: PUSH
77138: LD_EXP 60
77142: PUSH
77143: LD_VAR 0 2
77147: ARRAY
77148: PPUSH
77149: LD_INT 2
77151: PUSH
77152: LD_INT 30
77154: PUSH
77155: LD_INT 0
77157: PUSH
77158: EMPTY
77159: LIST
77160: LIST
77161: PUSH
77162: LD_INT 30
77164: PUSH
77165: LD_INT 1
77167: PUSH
77168: EMPTY
77169: LIST
77170: LIST
77171: PUSH
77172: EMPTY
77173: LIST
77174: LIST
77175: LIST
77176: PPUSH
77177: CALL_OW 72
77181: NOT
77182: OR
77183: IFFALSE 77233
// begin if mc_deposits_finder [ i ] then
77185: LD_EXP 98
77189: PUSH
77190: LD_VAR 0 2
77194: ARRAY
77195: IFFALSE 77231
// begin MC_Reset ( i , 125 ) ;
77197: LD_VAR 0 2
77201: PPUSH
77202: LD_INT 125
77204: PPUSH
77205: CALL 60193 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77209: LD_ADDR_EXP 98
77213: PUSH
77214: LD_EXP 98
77218: PPUSH
77219: LD_VAR 0 2
77223: PPUSH
77224: EMPTY
77225: PPUSH
77226: CALL_OW 1
77230: ST_TO_ADDR
// end ; continue ;
77231: GO 77085
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
77233: LD_EXP 97
77237: PUSH
77238: LD_VAR 0 2
77242: ARRAY
77243: PUSH
77244: LD_INT 1
77246: ARRAY
77247: PUSH
77248: LD_INT 3
77250: ARRAY
77251: PUSH
77252: LD_INT 1
77254: EQUAL
77255: PUSH
77256: LD_INT 20
77258: PPUSH
77259: LD_EXP 86
77263: PUSH
77264: LD_VAR 0 2
77268: ARRAY
77269: PPUSH
77270: CALL_OW 321
77274: PUSH
77275: LD_INT 2
77277: NONEQUAL
77278: AND
77279: IFFALSE 77329
// begin if mc_deposits_finder [ i ] then
77281: LD_EXP 98
77285: PUSH
77286: LD_VAR 0 2
77290: ARRAY
77291: IFFALSE 77327
// begin MC_Reset ( i , 125 ) ;
77293: LD_VAR 0 2
77297: PPUSH
77298: LD_INT 125
77300: PPUSH
77301: CALL 60193 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77305: LD_ADDR_EXP 98
77309: PUSH
77310: LD_EXP 98
77314: PPUSH
77315: LD_VAR 0 2
77319: PPUSH
77320: EMPTY
77321: PPUSH
77322: CALL_OW 1
77326: ST_TO_ADDR
// end ; continue ;
77327: GO 77085
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
77329: LD_EXP 97
77333: PUSH
77334: LD_VAR 0 2
77338: ARRAY
77339: PUSH
77340: LD_INT 1
77342: ARRAY
77343: PUSH
77344: LD_INT 1
77346: ARRAY
77347: PPUSH
77348: LD_EXP 97
77352: PUSH
77353: LD_VAR 0 2
77357: ARRAY
77358: PUSH
77359: LD_INT 1
77361: ARRAY
77362: PUSH
77363: LD_INT 2
77365: ARRAY
77366: PPUSH
77367: LD_EXP 86
77371: PUSH
77372: LD_VAR 0 2
77376: ARRAY
77377: PPUSH
77378: CALL_OW 440
77382: IFFALSE 77425
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
77384: LD_ADDR_EXP 97
77388: PUSH
77389: LD_EXP 97
77393: PPUSH
77394: LD_VAR 0 2
77398: PPUSH
77399: LD_EXP 97
77403: PUSH
77404: LD_VAR 0 2
77408: ARRAY
77409: PPUSH
77410: LD_INT 1
77412: PPUSH
77413: CALL_OW 3
77417: PPUSH
77418: CALL_OW 1
77422: ST_TO_ADDR
77423: GO 77672
// begin if not mc_deposits_finder [ i ] then
77425: LD_EXP 98
77429: PUSH
77430: LD_VAR 0 2
77434: ARRAY
77435: NOT
77436: IFFALSE 77488
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
77438: LD_ADDR_EXP 98
77442: PUSH
77443: LD_EXP 98
77447: PPUSH
77448: LD_VAR 0 2
77452: PPUSH
77453: LD_VAR 0 3
77457: PUSH
77458: LD_INT 1
77460: ARRAY
77461: PUSH
77462: EMPTY
77463: LIST
77464: PPUSH
77465: CALL_OW 1
77469: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
77470: LD_VAR 0 3
77474: PUSH
77475: LD_INT 1
77477: ARRAY
77478: PPUSH
77479: LD_INT 125
77481: PPUSH
77482: CALL_OW 109
// end else
77486: GO 77672
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
77488: LD_EXP 98
77492: PUSH
77493: LD_VAR 0 2
77497: ARRAY
77498: PUSH
77499: LD_INT 1
77501: ARRAY
77502: PPUSH
77503: CALL_OW 310
77507: IFFALSE 77530
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
77509: LD_EXP 98
77513: PUSH
77514: LD_VAR 0 2
77518: ARRAY
77519: PUSH
77520: LD_INT 1
77522: ARRAY
77523: PPUSH
77524: CALL_OW 122
77528: GO 77672
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
77530: LD_EXP 98
77534: PUSH
77535: LD_VAR 0 2
77539: ARRAY
77540: PUSH
77541: LD_INT 1
77543: ARRAY
77544: PPUSH
77545: CALL_OW 314
77549: NOT
77550: PUSH
77551: LD_EXP 98
77555: PUSH
77556: LD_VAR 0 2
77560: ARRAY
77561: PUSH
77562: LD_INT 1
77564: ARRAY
77565: PPUSH
77566: LD_EXP 97
77570: PUSH
77571: LD_VAR 0 2
77575: ARRAY
77576: PUSH
77577: LD_INT 1
77579: ARRAY
77580: PUSH
77581: LD_INT 1
77583: ARRAY
77584: PPUSH
77585: LD_EXP 97
77589: PUSH
77590: LD_VAR 0 2
77594: ARRAY
77595: PUSH
77596: LD_INT 1
77598: ARRAY
77599: PUSH
77600: LD_INT 2
77602: ARRAY
77603: PPUSH
77604: CALL_OW 297
77608: PUSH
77609: LD_INT 6
77611: GREATER
77612: AND
77613: IFFALSE 77672
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
77615: LD_EXP 98
77619: PUSH
77620: LD_VAR 0 2
77624: ARRAY
77625: PUSH
77626: LD_INT 1
77628: ARRAY
77629: PPUSH
77630: LD_EXP 97
77634: PUSH
77635: LD_VAR 0 2
77639: ARRAY
77640: PUSH
77641: LD_INT 1
77643: ARRAY
77644: PUSH
77645: LD_INT 1
77647: ARRAY
77648: PPUSH
77649: LD_EXP 97
77653: PUSH
77654: LD_VAR 0 2
77658: ARRAY
77659: PUSH
77660: LD_INT 1
77662: ARRAY
77663: PUSH
77664: LD_INT 2
77666: ARRAY
77667: PPUSH
77668: CALL_OW 111
// end ; end ; end ;
77672: GO 77085
77674: POP
77675: POP
// end ;
77676: LD_VAR 0 1
77680: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
77681: LD_INT 0
77683: PPUSH
77684: PPUSH
77685: PPUSH
77686: PPUSH
77687: PPUSH
77688: PPUSH
77689: PPUSH
77690: PPUSH
77691: PPUSH
77692: PPUSH
77693: PPUSH
// if not mc_bases then
77694: LD_EXP 60
77698: NOT
77699: IFFALSE 77703
// exit ;
77701: GO 78643
// for i = 1 to mc_bases do
77703: LD_ADDR_VAR 0 2
77707: PUSH
77708: DOUBLE
77709: LD_INT 1
77711: DEC
77712: ST_TO_ADDR
77713: LD_EXP 60
77717: PUSH
77718: FOR_TO
77719: IFFALSE 78641
// begin if not mc_bases [ i ] or mc_scan [ i ] then
77721: LD_EXP 60
77725: PUSH
77726: LD_VAR 0 2
77730: ARRAY
77731: NOT
77732: PUSH
77733: LD_EXP 83
77737: PUSH
77738: LD_VAR 0 2
77742: ARRAY
77743: OR
77744: IFFALSE 77748
// continue ;
77746: GO 77718
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
77748: LD_ADDR_VAR 0 7
77752: PUSH
77753: LD_EXP 60
77757: PUSH
77758: LD_VAR 0 2
77762: ARRAY
77763: PUSH
77764: LD_INT 1
77766: ARRAY
77767: PPUSH
77768: CALL_OW 248
77772: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
77773: LD_VAR 0 7
77777: PUSH
77778: LD_INT 3
77780: EQUAL
77781: PUSH
77782: LD_EXP 79
77786: PUSH
77787: LD_VAR 0 2
77791: ARRAY
77792: PUSH
77793: LD_EXP 82
77797: PUSH
77798: LD_VAR 0 2
77802: ARRAY
77803: UNION
77804: PPUSH
77805: LD_INT 33
77807: PUSH
77808: LD_INT 2
77810: PUSH
77811: EMPTY
77812: LIST
77813: LIST
77814: PPUSH
77815: CALL_OW 72
77819: NOT
77820: OR
77821: IFFALSE 77825
// continue ;
77823: GO 77718
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
77825: LD_ADDR_VAR 0 9
77829: PUSH
77830: LD_EXP 60
77834: PUSH
77835: LD_VAR 0 2
77839: ARRAY
77840: PPUSH
77841: LD_INT 30
77843: PUSH
77844: LD_INT 36
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PPUSH
77851: CALL_OW 72
77855: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
77856: LD_ADDR_VAR 0 10
77860: PUSH
77861: LD_EXP 79
77865: PUSH
77866: LD_VAR 0 2
77870: ARRAY
77871: PPUSH
77872: LD_INT 34
77874: PUSH
77875: LD_INT 31
77877: PUSH
77878: EMPTY
77879: LIST
77880: LIST
77881: PPUSH
77882: CALL_OW 72
77886: ST_TO_ADDR
// if not cts and not mcts then
77887: LD_VAR 0 9
77891: NOT
77892: PUSH
77893: LD_VAR 0 10
77897: NOT
77898: AND
77899: IFFALSE 77903
// continue ;
77901: GO 77718
// x := cts ;
77903: LD_ADDR_VAR 0 11
77907: PUSH
77908: LD_VAR 0 9
77912: ST_TO_ADDR
// if not x then
77913: LD_VAR 0 11
77917: NOT
77918: IFFALSE 77930
// x := mcts ;
77920: LD_ADDR_VAR 0 11
77924: PUSH
77925: LD_VAR 0 10
77929: ST_TO_ADDR
// if not x then
77930: LD_VAR 0 11
77934: NOT
77935: IFFALSE 77939
// continue ;
77937: GO 77718
// if mc_remote_driver [ i ] then
77939: LD_EXP 100
77943: PUSH
77944: LD_VAR 0 2
77948: ARRAY
77949: IFFALSE 78336
// for j in mc_remote_driver [ i ] do
77951: LD_ADDR_VAR 0 3
77955: PUSH
77956: LD_EXP 100
77960: PUSH
77961: LD_VAR 0 2
77965: ARRAY
77966: PUSH
77967: FOR_IN
77968: IFFALSE 78334
// begin if GetClass ( j ) <> 3 then
77970: LD_VAR 0 3
77974: PPUSH
77975: CALL_OW 257
77979: PUSH
77980: LD_INT 3
77982: NONEQUAL
77983: IFFALSE 78036
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
77985: LD_ADDR_EXP 100
77989: PUSH
77990: LD_EXP 100
77994: PPUSH
77995: LD_VAR 0 2
77999: PPUSH
78000: LD_EXP 100
78004: PUSH
78005: LD_VAR 0 2
78009: ARRAY
78010: PUSH
78011: LD_VAR 0 3
78015: DIFF
78016: PPUSH
78017: CALL_OW 1
78021: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78022: LD_VAR 0 3
78026: PPUSH
78027: LD_INT 0
78029: PPUSH
78030: CALL_OW 109
// continue ;
78034: GO 77967
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
78036: LD_EXP 79
78040: PUSH
78041: LD_VAR 0 2
78045: ARRAY
78046: PPUSH
78047: LD_INT 34
78049: PUSH
78050: LD_INT 31
78052: PUSH
78053: EMPTY
78054: LIST
78055: LIST
78056: PUSH
78057: LD_INT 58
78059: PUSH
78060: EMPTY
78061: LIST
78062: PUSH
78063: EMPTY
78064: LIST
78065: LIST
78066: PPUSH
78067: CALL_OW 72
78071: PUSH
78072: LD_VAR 0 3
78076: PPUSH
78077: CALL 49839 0 1
78081: NOT
78082: AND
78083: IFFALSE 78154
// begin if IsInUnit ( j ) then
78085: LD_VAR 0 3
78089: PPUSH
78090: CALL_OW 310
78094: IFFALSE 78105
// ComExitBuilding ( j ) ;
78096: LD_VAR 0 3
78100: PPUSH
78101: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
78105: LD_VAR 0 3
78109: PPUSH
78110: LD_EXP 79
78114: PUSH
78115: LD_VAR 0 2
78119: ARRAY
78120: PPUSH
78121: LD_INT 34
78123: PUSH
78124: LD_INT 31
78126: PUSH
78127: EMPTY
78128: LIST
78129: LIST
78130: PUSH
78131: LD_INT 58
78133: PUSH
78134: EMPTY
78135: LIST
78136: PUSH
78137: EMPTY
78138: LIST
78139: LIST
78140: PPUSH
78141: CALL_OW 72
78145: PUSH
78146: LD_INT 1
78148: ARRAY
78149: PPUSH
78150: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
78154: LD_VAR 0 3
78158: PPUSH
78159: CALL_OW 310
78163: NOT
78164: PUSH
78165: LD_VAR 0 3
78169: PPUSH
78170: CALL_OW 310
78174: PPUSH
78175: CALL_OW 266
78179: PUSH
78180: LD_INT 36
78182: NONEQUAL
78183: PUSH
78184: LD_VAR 0 3
78188: PPUSH
78189: CALL 49839 0 1
78193: NOT
78194: AND
78195: OR
78196: IFFALSE 78332
// begin if IsInUnit ( j ) then
78198: LD_VAR 0 3
78202: PPUSH
78203: CALL_OW 310
78207: IFFALSE 78218
// ComExitBuilding ( j ) ;
78209: LD_VAR 0 3
78213: PPUSH
78214: CALL_OW 122
// ct := 0 ;
78218: LD_ADDR_VAR 0 8
78222: PUSH
78223: LD_INT 0
78225: ST_TO_ADDR
// for k in x do
78226: LD_ADDR_VAR 0 4
78230: PUSH
78231: LD_VAR 0 11
78235: PUSH
78236: FOR_IN
78237: IFFALSE 78310
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
78239: LD_VAR 0 4
78243: PPUSH
78244: CALL_OW 264
78248: PUSH
78249: LD_INT 31
78251: EQUAL
78252: PUSH
78253: LD_VAR 0 4
78257: PPUSH
78258: CALL_OW 311
78262: NOT
78263: AND
78264: PUSH
78265: LD_VAR 0 4
78269: PPUSH
78270: CALL_OW 266
78274: PUSH
78275: LD_INT 36
78277: EQUAL
78278: PUSH
78279: LD_VAR 0 4
78283: PPUSH
78284: CALL_OW 313
78288: PUSH
78289: LD_INT 3
78291: LESS
78292: AND
78293: OR
78294: IFFALSE 78308
// begin ct := k ;
78296: LD_ADDR_VAR 0 8
78300: PUSH
78301: LD_VAR 0 4
78305: ST_TO_ADDR
// break ;
78306: GO 78310
// end ;
78308: GO 78236
78310: POP
78311: POP
// if ct then
78312: LD_VAR 0 8
78316: IFFALSE 78332
// ComEnterUnit ( j , ct ) ;
78318: LD_VAR 0 3
78322: PPUSH
78323: LD_VAR 0 8
78327: PPUSH
78328: CALL_OW 120
// end ; end ;
78332: GO 77967
78334: POP
78335: POP
// places := 0 ;
78336: LD_ADDR_VAR 0 5
78340: PUSH
78341: LD_INT 0
78343: ST_TO_ADDR
// for j = 1 to x do
78344: LD_ADDR_VAR 0 3
78348: PUSH
78349: DOUBLE
78350: LD_INT 1
78352: DEC
78353: ST_TO_ADDR
78354: LD_VAR 0 11
78358: PUSH
78359: FOR_TO
78360: IFFALSE 78436
// if GetWeapon ( x [ j ] ) = ar_control_tower then
78362: LD_VAR 0 11
78366: PUSH
78367: LD_VAR 0 3
78371: ARRAY
78372: PPUSH
78373: CALL_OW 264
78377: PUSH
78378: LD_INT 31
78380: EQUAL
78381: IFFALSE 78399
// places := places + 1 else
78383: LD_ADDR_VAR 0 5
78387: PUSH
78388: LD_VAR 0 5
78392: PUSH
78393: LD_INT 1
78395: PLUS
78396: ST_TO_ADDR
78397: GO 78434
// if GetBType ( x [ j ] ) = b_control_tower then
78399: LD_VAR 0 11
78403: PUSH
78404: LD_VAR 0 3
78408: ARRAY
78409: PPUSH
78410: CALL_OW 266
78414: PUSH
78415: LD_INT 36
78417: EQUAL
78418: IFFALSE 78434
// places := places + 3 ;
78420: LD_ADDR_VAR 0 5
78424: PUSH
78425: LD_VAR 0 5
78429: PUSH
78430: LD_INT 3
78432: PLUS
78433: ST_TO_ADDR
78434: GO 78359
78436: POP
78437: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
78438: LD_VAR 0 5
78442: PUSH
78443: LD_INT 0
78445: EQUAL
78446: PUSH
78447: LD_VAR 0 5
78451: PUSH
78452: LD_EXP 100
78456: PUSH
78457: LD_VAR 0 2
78461: ARRAY
78462: LESSEQUAL
78463: OR
78464: IFFALSE 78468
// continue ;
78466: GO 77718
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
78468: LD_ADDR_VAR 0 6
78472: PUSH
78473: LD_EXP 60
78477: PUSH
78478: LD_VAR 0 2
78482: ARRAY
78483: PPUSH
78484: LD_INT 25
78486: PUSH
78487: LD_INT 3
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: PPUSH
78494: CALL_OW 72
78498: PUSH
78499: LD_EXP 100
78503: PUSH
78504: LD_VAR 0 2
78508: ARRAY
78509: DIFF
78510: PPUSH
78511: LD_INT 3
78513: PPUSH
78514: CALL 50739 0 2
78518: ST_TO_ADDR
// for j in tmp do
78519: LD_ADDR_VAR 0 3
78523: PUSH
78524: LD_VAR 0 6
78528: PUSH
78529: FOR_IN
78530: IFFALSE 78565
// if GetTag ( j ) > 0 then
78532: LD_VAR 0 3
78536: PPUSH
78537: CALL_OW 110
78541: PUSH
78542: LD_INT 0
78544: GREATER
78545: IFFALSE 78563
// tmp := tmp diff j ;
78547: LD_ADDR_VAR 0 6
78551: PUSH
78552: LD_VAR 0 6
78556: PUSH
78557: LD_VAR 0 3
78561: DIFF
78562: ST_TO_ADDR
78563: GO 78529
78565: POP
78566: POP
// if not tmp then
78567: LD_VAR 0 6
78571: NOT
78572: IFFALSE 78576
// continue ;
78574: GO 77718
// if places then
78576: LD_VAR 0 5
78580: IFFALSE 78639
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
78582: LD_ADDR_EXP 100
78586: PUSH
78587: LD_EXP 100
78591: PPUSH
78592: LD_VAR 0 2
78596: PPUSH
78597: LD_EXP 100
78601: PUSH
78602: LD_VAR 0 2
78606: ARRAY
78607: PUSH
78608: LD_VAR 0 6
78612: PUSH
78613: LD_INT 1
78615: ARRAY
78616: UNION
78617: PPUSH
78618: CALL_OW 1
78622: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
78623: LD_VAR 0 6
78627: PUSH
78628: LD_INT 1
78630: ARRAY
78631: PPUSH
78632: LD_INT 126
78634: PPUSH
78635: CALL_OW 109
// end ; end ;
78639: GO 77718
78641: POP
78642: POP
// end ;
78643: LD_VAR 0 1
78647: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
78648: LD_INT 0
78650: PPUSH
78651: PPUSH
78652: PPUSH
78653: PPUSH
78654: PPUSH
78655: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
78656: LD_VAR 0 1
78660: NOT
78661: PUSH
78662: LD_VAR 0 2
78666: NOT
78667: OR
78668: PUSH
78669: LD_VAR 0 3
78673: NOT
78674: OR
78675: PUSH
78676: LD_VAR 0 4
78680: PUSH
78681: LD_INT 1
78683: PUSH
78684: LD_INT 2
78686: PUSH
78687: LD_INT 3
78689: PUSH
78690: LD_INT 4
78692: PUSH
78693: LD_INT 5
78695: PUSH
78696: LD_INT 8
78698: PUSH
78699: LD_INT 9
78701: PUSH
78702: LD_INT 15
78704: PUSH
78705: LD_INT 16
78707: PUSH
78708: EMPTY
78709: LIST
78710: LIST
78711: LIST
78712: LIST
78713: LIST
78714: LIST
78715: LIST
78716: LIST
78717: LIST
78718: IN
78719: NOT
78720: OR
78721: IFFALSE 78725
// exit ;
78723: GO 79625
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
78725: LD_ADDR_VAR 0 2
78729: PUSH
78730: LD_VAR 0 2
78734: PPUSH
78735: LD_INT 21
78737: PUSH
78738: LD_INT 3
78740: PUSH
78741: EMPTY
78742: LIST
78743: LIST
78744: PUSH
78745: LD_INT 24
78747: PUSH
78748: LD_INT 250
78750: PUSH
78751: EMPTY
78752: LIST
78753: LIST
78754: PUSH
78755: EMPTY
78756: LIST
78757: LIST
78758: PPUSH
78759: CALL_OW 72
78763: ST_TO_ADDR
// case class of 1 , 15 :
78764: LD_VAR 0 4
78768: PUSH
78769: LD_INT 1
78771: DOUBLE
78772: EQUAL
78773: IFTRUE 78783
78775: LD_INT 15
78777: DOUBLE
78778: EQUAL
78779: IFTRUE 78783
78781: GO 78868
78783: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
78784: LD_ADDR_VAR 0 8
78788: PUSH
78789: LD_VAR 0 2
78793: PPUSH
78794: LD_INT 2
78796: PUSH
78797: LD_INT 30
78799: PUSH
78800: LD_INT 32
78802: PUSH
78803: EMPTY
78804: LIST
78805: LIST
78806: PUSH
78807: LD_INT 30
78809: PUSH
78810: LD_INT 31
78812: PUSH
78813: EMPTY
78814: LIST
78815: LIST
78816: PUSH
78817: EMPTY
78818: LIST
78819: LIST
78820: LIST
78821: PPUSH
78822: CALL_OW 72
78826: PUSH
78827: LD_VAR 0 2
78831: PPUSH
78832: LD_INT 2
78834: PUSH
78835: LD_INT 30
78837: PUSH
78838: LD_INT 4
78840: PUSH
78841: EMPTY
78842: LIST
78843: LIST
78844: PUSH
78845: LD_INT 30
78847: PUSH
78848: LD_INT 5
78850: PUSH
78851: EMPTY
78852: LIST
78853: LIST
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: LIST
78859: PPUSH
78860: CALL_OW 72
78864: ADD
78865: ST_TO_ADDR
78866: GO 79114
78868: LD_INT 2
78870: DOUBLE
78871: EQUAL
78872: IFTRUE 78882
78874: LD_INT 16
78876: DOUBLE
78877: EQUAL
78878: IFTRUE 78882
78880: GO 78928
78882: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
78883: LD_ADDR_VAR 0 8
78887: PUSH
78888: LD_VAR 0 2
78892: PPUSH
78893: LD_INT 2
78895: PUSH
78896: LD_INT 30
78898: PUSH
78899: LD_INT 0
78901: PUSH
78902: EMPTY
78903: LIST
78904: LIST
78905: PUSH
78906: LD_INT 30
78908: PUSH
78909: LD_INT 1
78911: PUSH
78912: EMPTY
78913: LIST
78914: LIST
78915: PUSH
78916: EMPTY
78917: LIST
78918: LIST
78919: LIST
78920: PPUSH
78921: CALL_OW 72
78925: ST_TO_ADDR
78926: GO 79114
78928: LD_INT 3
78930: DOUBLE
78931: EQUAL
78932: IFTRUE 78936
78934: GO 78982
78936: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
78937: LD_ADDR_VAR 0 8
78941: PUSH
78942: LD_VAR 0 2
78946: PPUSH
78947: LD_INT 2
78949: PUSH
78950: LD_INT 30
78952: PUSH
78953: LD_INT 2
78955: PUSH
78956: EMPTY
78957: LIST
78958: LIST
78959: PUSH
78960: LD_INT 30
78962: PUSH
78963: LD_INT 3
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: LIST
78974: PPUSH
78975: CALL_OW 72
78979: ST_TO_ADDR
78980: GO 79114
78982: LD_INT 4
78984: DOUBLE
78985: EQUAL
78986: IFTRUE 78990
78988: GO 79047
78990: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
78991: LD_ADDR_VAR 0 8
78995: PUSH
78996: LD_VAR 0 2
79000: PPUSH
79001: LD_INT 2
79003: PUSH
79004: LD_INT 30
79006: PUSH
79007: LD_INT 6
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: PUSH
79014: LD_INT 30
79016: PUSH
79017: LD_INT 7
79019: PUSH
79020: EMPTY
79021: LIST
79022: LIST
79023: PUSH
79024: LD_INT 30
79026: PUSH
79027: LD_INT 8
79029: PUSH
79030: EMPTY
79031: LIST
79032: LIST
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: LIST
79038: LIST
79039: PPUSH
79040: CALL_OW 72
79044: ST_TO_ADDR
79045: GO 79114
79047: LD_INT 5
79049: DOUBLE
79050: EQUAL
79051: IFTRUE 79067
79053: LD_INT 8
79055: DOUBLE
79056: EQUAL
79057: IFTRUE 79067
79059: LD_INT 9
79061: DOUBLE
79062: EQUAL
79063: IFTRUE 79067
79065: GO 79113
79067: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79068: LD_ADDR_VAR 0 8
79072: PUSH
79073: LD_VAR 0 2
79077: PPUSH
79078: LD_INT 2
79080: PUSH
79081: LD_INT 30
79083: PUSH
79084: LD_INT 4
79086: PUSH
79087: EMPTY
79088: LIST
79089: LIST
79090: PUSH
79091: LD_INT 30
79093: PUSH
79094: LD_INT 5
79096: PUSH
79097: EMPTY
79098: LIST
79099: LIST
79100: PUSH
79101: EMPTY
79102: LIST
79103: LIST
79104: LIST
79105: PPUSH
79106: CALL_OW 72
79110: ST_TO_ADDR
79111: GO 79114
79113: POP
// if not tmp then
79114: LD_VAR 0 8
79118: NOT
79119: IFFALSE 79123
// exit ;
79121: GO 79625
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
79123: LD_VAR 0 4
79127: PUSH
79128: LD_INT 1
79130: PUSH
79131: LD_INT 15
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: IN
79138: PUSH
79139: LD_EXP 69
79143: PUSH
79144: LD_VAR 0 1
79148: ARRAY
79149: AND
79150: IFFALSE 79306
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
79152: LD_ADDR_VAR 0 9
79156: PUSH
79157: LD_EXP 69
79161: PUSH
79162: LD_VAR 0 1
79166: ARRAY
79167: PUSH
79168: LD_INT 1
79170: ARRAY
79171: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
79172: LD_VAR 0 9
79176: PUSH
79177: LD_EXP 70
79181: PUSH
79182: LD_VAR 0 1
79186: ARRAY
79187: IN
79188: NOT
79189: IFFALSE 79304
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
79191: LD_ADDR_EXP 70
79195: PUSH
79196: LD_EXP 70
79200: PPUSH
79201: LD_VAR 0 1
79205: PUSH
79206: LD_EXP 70
79210: PUSH
79211: LD_VAR 0 1
79215: ARRAY
79216: PUSH
79217: LD_INT 1
79219: PLUS
79220: PUSH
79221: EMPTY
79222: LIST
79223: LIST
79224: PPUSH
79225: LD_VAR 0 9
79229: PPUSH
79230: CALL 19991 0 3
79234: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
79235: LD_ADDR_EXP 69
79239: PUSH
79240: LD_EXP 69
79244: PPUSH
79245: LD_VAR 0 1
79249: PPUSH
79250: LD_EXP 69
79254: PUSH
79255: LD_VAR 0 1
79259: ARRAY
79260: PUSH
79261: LD_VAR 0 9
79265: DIFF
79266: PPUSH
79267: CALL_OW 1
79271: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
79272: LD_VAR 0 3
79276: PPUSH
79277: LD_EXP 70
79281: PUSH
79282: LD_VAR 0 1
79286: ARRAY
79287: PUSH
79288: LD_EXP 70
79292: PUSH
79293: LD_VAR 0 1
79297: ARRAY
79298: ARRAY
79299: PPUSH
79300: CALL_OW 120
// end ; exit ;
79304: GO 79625
// end ; if tmp > 1 then
79306: LD_VAR 0 8
79310: PUSH
79311: LD_INT 1
79313: GREATER
79314: IFFALSE 79418
// for i = 2 to tmp do
79316: LD_ADDR_VAR 0 6
79320: PUSH
79321: DOUBLE
79322: LD_INT 2
79324: DEC
79325: ST_TO_ADDR
79326: LD_VAR 0 8
79330: PUSH
79331: FOR_TO
79332: IFFALSE 79416
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
79334: LD_VAR 0 8
79338: PUSH
79339: LD_VAR 0 6
79343: ARRAY
79344: PPUSH
79345: CALL_OW 461
79349: PUSH
79350: LD_INT 6
79352: EQUAL
79353: IFFALSE 79414
// begin x := tmp [ i ] ;
79355: LD_ADDR_VAR 0 9
79359: PUSH
79360: LD_VAR 0 8
79364: PUSH
79365: LD_VAR 0 6
79369: ARRAY
79370: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
79371: LD_ADDR_VAR 0 8
79375: PUSH
79376: LD_VAR 0 8
79380: PPUSH
79381: LD_VAR 0 6
79385: PPUSH
79386: CALL_OW 3
79390: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
79391: LD_ADDR_VAR 0 8
79395: PUSH
79396: LD_VAR 0 8
79400: PPUSH
79401: LD_INT 1
79403: PPUSH
79404: LD_VAR 0 9
79408: PPUSH
79409: CALL_OW 2
79413: ST_TO_ADDR
// end ;
79414: GO 79331
79416: POP
79417: POP
// for i in tmp do
79418: LD_ADDR_VAR 0 6
79422: PUSH
79423: LD_VAR 0 8
79427: PUSH
79428: FOR_IN
79429: IFFALSE 79498
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
79431: LD_VAR 0 6
79435: PPUSH
79436: CALL_OW 313
79440: PUSH
79441: LD_INT 6
79443: LESS
79444: PUSH
79445: LD_VAR 0 6
79449: PPUSH
79450: CALL_OW 266
79454: PUSH
79455: LD_INT 31
79457: PUSH
79458: LD_INT 32
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: IN
79465: NOT
79466: AND
79467: PUSH
79468: LD_VAR 0 6
79472: PPUSH
79473: CALL_OW 313
79477: PUSH
79478: LD_INT 0
79480: EQUAL
79481: OR
79482: IFFALSE 79496
// begin j := i ;
79484: LD_ADDR_VAR 0 7
79488: PUSH
79489: LD_VAR 0 6
79493: ST_TO_ADDR
// break ;
79494: GO 79498
// end ; end ;
79496: GO 79428
79498: POP
79499: POP
// if j then
79500: LD_VAR 0 7
79504: IFFALSE 79522
// ComEnterUnit ( unit , j ) else
79506: LD_VAR 0 3
79510: PPUSH
79511: LD_VAR 0 7
79515: PPUSH
79516: CALL_OW 120
79520: GO 79625
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79522: LD_ADDR_VAR 0 10
79526: PUSH
79527: LD_VAR 0 2
79531: PPUSH
79532: LD_INT 2
79534: PUSH
79535: LD_INT 30
79537: PUSH
79538: LD_INT 0
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: PUSH
79545: LD_INT 30
79547: PUSH
79548: LD_INT 1
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: PUSH
79555: EMPTY
79556: LIST
79557: LIST
79558: LIST
79559: PPUSH
79560: CALL_OW 72
79564: ST_TO_ADDR
// if depot then
79565: LD_VAR 0 10
79569: IFFALSE 79625
// begin depot := NearestUnitToUnit ( depot , unit ) ;
79571: LD_ADDR_VAR 0 10
79575: PUSH
79576: LD_VAR 0 10
79580: PPUSH
79581: LD_VAR 0 3
79585: PPUSH
79586: CALL_OW 74
79590: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
79591: LD_VAR 0 3
79595: PPUSH
79596: LD_VAR 0 10
79600: PPUSH
79601: CALL_OW 296
79605: PUSH
79606: LD_INT 10
79608: GREATER
79609: IFFALSE 79625
// ComStandNearbyBuilding ( unit , depot ) ;
79611: LD_VAR 0 3
79615: PPUSH
79616: LD_VAR 0 10
79620: PPUSH
79621: CALL 16418 0 2
// end ; end ; end ;
79625: LD_VAR 0 5
79629: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
79630: LD_INT 0
79632: PPUSH
79633: PPUSH
79634: PPUSH
79635: PPUSH
// if not mc_bases then
79636: LD_EXP 60
79640: NOT
79641: IFFALSE 79645
// exit ;
79643: GO 79884
// for i = 1 to mc_bases do
79645: LD_ADDR_VAR 0 2
79649: PUSH
79650: DOUBLE
79651: LD_INT 1
79653: DEC
79654: ST_TO_ADDR
79655: LD_EXP 60
79659: PUSH
79660: FOR_TO
79661: IFFALSE 79882
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
79663: LD_ADDR_VAR 0 4
79667: PUSH
79668: LD_EXP 60
79672: PUSH
79673: LD_VAR 0 2
79677: ARRAY
79678: PPUSH
79679: LD_INT 21
79681: PUSH
79682: LD_INT 1
79684: PUSH
79685: EMPTY
79686: LIST
79687: LIST
79688: PPUSH
79689: CALL_OW 72
79693: PUSH
79694: LD_EXP 89
79698: PUSH
79699: LD_VAR 0 2
79703: ARRAY
79704: UNION
79705: ST_TO_ADDR
// if not tmp then
79706: LD_VAR 0 4
79710: NOT
79711: IFFALSE 79715
// continue ;
79713: GO 79660
// for j in tmp do
79715: LD_ADDR_VAR 0 3
79719: PUSH
79720: LD_VAR 0 4
79724: PUSH
79725: FOR_IN
79726: IFFALSE 79878
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
79728: LD_VAR 0 3
79732: PPUSH
79733: CALL_OW 110
79737: NOT
79738: PUSH
79739: LD_VAR 0 3
79743: PPUSH
79744: CALL_OW 314
79748: NOT
79749: AND
79750: PUSH
79751: LD_VAR 0 3
79755: PPUSH
79756: CALL_OW 311
79760: NOT
79761: AND
79762: PUSH
79763: LD_VAR 0 3
79767: PPUSH
79768: CALL_OW 310
79772: NOT
79773: AND
79774: PUSH
79775: LD_VAR 0 3
79779: PUSH
79780: LD_EXP 63
79784: PUSH
79785: LD_VAR 0 2
79789: ARRAY
79790: PUSH
79791: LD_INT 1
79793: ARRAY
79794: IN
79795: NOT
79796: AND
79797: PUSH
79798: LD_VAR 0 3
79802: PUSH
79803: LD_EXP 63
79807: PUSH
79808: LD_VAR 0 2
79812: ARRAY
79813: PUSH
79814: LD_INT 2
79816: ARRAY
79817: IN
79818: NOT
79819: AND
79820: PUSH
79821: LD_VAR 0 3
79825: PUSH
79826: LD_EXP 72
79830: PUSH
79831: LD_VAR 0 2
79835: ARRAY
79836: IN
79837: NOT
79838: AND
79839: IFFALSE 79876
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
79841: LD_VAR 0 2
79845: PPUSH
79846: LD_EXP 60
79850: PUSH
79851: LD_VAR 0 2
79855: ARRAY
79856: PPUSH
79857: LD_VAR 0 3
79861: PPUSH
79862: LD_VAR 0 3
79866: PPUSH
79867: CALL_OW 257
79871: PPUSH
79872: CALL 78648 0 4
// end ;
79876: GO 79725
79878: POP
79879: POP
// end ;
79880: GO 79660
79882: POP
79883: POP
// end ;
79884: LD_VAR 0 1
79888: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
79889: LD_INT 0
79891: PPUSH
79892: PPUSH
79893: PPUSH
79894: PPUSH
79895: PPUSH
79896: PPUSH
// if not mc_bases [ base ] then
79897: LD_EXP 60
79901: PUSH
79902: LD_VAR 0 1
79906: ARRAY
79907: NOT
79908: IFFALSE 79912
// exit ;
79910: GO 80094
// tmp := [ ] ;
79912: LD_ADDR_VAR 0 6
79916: PUSH
79917: EMPTY
79918: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
79919: LD_ADDR_VAR 0 7
79923: PUSH
79924: LD_VAR 0 3
79928: PPUSH
79929: LD_INT 0
79931: PPUSH
79932: CALL_OW 517
79936: ST_TO_ADDR
// if not list then
79937: LD_VAR 0 7
79941: NOT
79942: IFFALSE 79946
// exit ;
79944: GO 80094
// for i = 1 to amount do
79946: LD_ADDR_VAR 0 5
79950: PUSH
79951: DOUBLE
79952: LD_INT 1
79954: DEC
79955: ST_TO_ADDR
79956: LD_VAR 0 2
79960: PUSH
79961: FOR_TO
79962: IFFALSE 80042
// begin x := rand ( 1 , list [ 1 ] ) ;
79964: LD_ADDR_VAR 0 8
79968: PUSH
79969: LD_INT 1
79971: PPUSH
79972: LD_VAR 0 7
79976: PUSH
79977: LD_INT 1
79979: ARRAY
79980: PPUSH
79981: CALL_OW 12
79985: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
79986: LD_ADDR_VAR 0 6
79990: PUSH
79991: LD_VAR 0 6
79995: PPUSH
79996: LD_VAR 0 5
80000: PPUSH
80001: LD_VAR 0 7
80005: PUSH
80006: LD_INT 1
80008: ARRAY
80009: PUSH
80010: LD_VAR 0 8
80014: ARRAY
80015: PUSH
80016: LD_VAR 0 7
80020: PUSH
80021: LD_INT 2
80023: ARRAY
80024: PUSH
80025: LD_VAR 0 8
80029: ARRAY
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: PPUSH
80035: CALL_OW 1
80039: ST_TO_ADDR
// end ;
80040: GO 79961
80042: POP
80043: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80044: LD_ADDR_EXP 73
80048: PUSH
80049: LD_EXP 73
80053: PPUSH
80054: LD_VAR 0 1
80058: PPUSH
80059: LD_VAR 0 6
80063: PPUSH
80064: CALL_OW 1
80068: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80069: LD_ADDR_EXP 75
80073: PUSH
80074: LD_EXP 75
80078: PPUSH
80079: LD_VAR 0 1
80083: PPUSH
80084: LD_VAR 0 3
80088: PPUSH
80089: CALL_OW 1
80093: ST_TO_ADDR
// end ;
80094: LD_VAR 0 4
80098: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
80099: LD_INT 0
80101: PPUSH
// if not mc_bases [ base ] then
80102: LD_EXP 60
80106: PUSH
80107: LD_VAR 0 1
80111: ARRAY
80112: NOT
80113: IFFALSE 80117
// exit ;
80115: GO 80142
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
80117: LD_ADDR_EXP 65
80121: PUSH
80122: LD_EXP 65
80126: PPUSH
80127: LD_VAR 0 1
80131: PPUSH
80132: LD_VAR 0 2
80136: PPUSH
80137: CALL_OW 1
80141: ST_TO_ADDR
// end ;
80142: LD_VAR 0 3
80146: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
80147: LD_INT 0
80149: PPUSH
// if not mc_bases [ base ] then
80150: LD_EXP 60
80154: PUSH
80155: LD_VAR 0 1
80159: ARRAY
80160: NOT
80161: IFFALSE 80165
// exit ;
80163: GO 80202
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
80165: LD_ADDR_EXP 65
80169: PUSH
80170: LD_EXP 65
80174: PPUSH
80175: LD_VAR 0 1
80179: PPUSH
80180: LD_EXP 65
80184: PUSH
80185: LD_VAR 0 1
80189: ARRAY
80190: PUSH
80191: LD_VAR 0 2
80195: UNION
80196: PPUSH
80197: CALL_OW 1
80201: ST_TO_ADDR
// end ;
80202: LD_VAR 0 3
80206: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
80207: LD_INT 0
80209: PPUSH
// if not mc_bases [ base ] then
80210: LD_EXP 60
80214: PUSH
80215: LD_VAR 0 1
80219: ARRAY
80220: NOT
80221: IFFALSE 80225
// exit ;
80223: GO 80250
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
80225: LD_ADDR_EXP 81
80229: PUSH
80230: LD_EXP 81
80234: PPUSH
80235: LD_VAR 0 1
80239: PPUSH
80240: LD_VAR 0 2
80244: PPUSH
80245: CALL_OW 1
80249: ST_TO_ADDR
// end ;
80250: LD_VAR 0 3
80254: RET
// export function MC_InsertProduceList ( base , components ) ; begin
80255: LD_INT 0
80257: PPUSH
// if not mc_bases [ base ] then
80258: LD_EXP 60
80262: PUSH
80263: LD_VAR 0 1
80267: ARRAY
80268: NOT
80269: IFFALSE 80273
// exit ;
80271: GO 80310
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
80273: LD_ADDR_EXP 81
80277: PUSH
80278: LD_EXP 81
80282: PPUSH
80283: LD_VAR 0 1
80287: PPUSH
80288: LD_EXP 81
80292: PUSH
80293: LD_VAR 0 1
80297: ARRAY
80298: PUSH
80299: LD_VAR 0 2
80303: ADD
80304: PPUSH
80305: CALL_OW 1
80309: ST_TO_ADDR
// end ;
80310: LD_VAR 0 3
80314: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
80315: LD_INT 0
80317: PPUSH
// if not mc_bases [ base ] then
80318: LD_EXP 60
80322: PUSH
80323: LD_VAR 0 1
80327: ARRAY
80328: NOT
80329: IFFALSE 80333
// exit ;
80331: GO 80387
// mc_defender := Replace ( mc_defender , base , deflist ) ;
80333: LD_ADDR_EXP 82
80337: PUSH
80338: LD_EXP 82
80342: PPUSH
80343: LD_VAR 0 1
80347: PPUSH
80348: LD_VAR 0 2
80352: PPUSH
80353: CALL_OW 1
80357: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
80358: LD_ADDR_EXP 71
80362: PUSH
80363: LD_EXP 71
80367: PPUSH
80368: LD_VAR 0 1
80372: PPUSH
80373: LD_VAR 0 2
80377: PUSH
80378: LD_INT 0
80380: PLUS
80381: PPUSH
80382: CALL_OW 1
80386: ST_TO_ADDR
// end ;
80387: LD_VAR 0 3
80391: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
80392: LD_INT 0
80394: PPUSH
// if not mc_bases [ base ] then
80395: LD_EXP 60
80399: PUSH
80400: LD_VAR 0 1
80404: ARRAY
80405: NOT
80406: IFFALSE 80410
// exit ;
80408: GO 80435
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
80410: LD_ADDR_EXP 71
80414: PUSH
80415: LD_EXP 71
80419: PPUSH
80420: LD_VAR 0 1
80424: PPUSH
80425: LD_VAR 0 2
80429: PPUSH
80430: CALL_OW 1
80434: ST_TO_ADDR
// end ;
80435: LD_VAR 0 3
80439: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
80440: LD_INT 0
80442: PPUSH
80443: PPUSH
80444: PPUSH
80445: PPUSH
// if not mc_bases [ base ] then
80446: LD_EXP 60
80450: PUSH
80451: LD_VAR 0 1
80455: ARRAY
80456: NOT
80457: IFFALSE 80461
// exit ;
80459: GO 80526
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
80461: LD_ADDR_EXP 80
80465: PUSH
80466: LD_EXP 80
80470: PPUSH
80471: LD_VAR 0 1
80475: PUSH
80476: LD_EXP 80
80480: PUSH
80481: LD_VAR 0 1
80485: ARRAY
80486: PUSH
80487: LD_INT 1
80489: PLUS
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PPUSH
80495: LD_VAR 0 1
80499: PUSH
80500: LD_VAR 0 2
80504: PUSH
80505: LD_VAR 0 3
80509: PUSH
80510: LD_VAR 0 4
80514: PUSH
80515: EMPTY
80516: LIST
80517: LIST
80518: LIST
80519: LIST
80520: PPUSH
80521: CALL 19991 0 3
80525: ST_TO_ADDR
// end ;
80526: LD_VAR 0 5
80530: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
80531: LD_INT 0
80533: PPUSH
// if not mc_bases [ base ] then
80534: LD_EXP 60
80538: PUSH
80539: LD_VAR 0 1
80543: ARRAY
80544: NOT
80545: IFFALSE 80549
// exit ;
80547: GO 80574
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
80549: LD_ADDR_EXP 97
80553: PUSH
80554: LD_EXP 97
80558: PPUSH
80559: LD_VAR 0 1
80563: PPUSH
80564: LD_VAR 0 2
80568: PPUSH
80569: CALL_OW 1
80573: ST_TO_ADDR
// end ;
80574: LD_VAR 0 3
80578: RET
// export function MC_GetMinesField ( base ) ; begin
80579: LD_INT 0
80581: PPUSH
// result := mc_mines [ base ] ;
80582: LD_ADDR_VAR 0 2
80586: PUSH
80587: LD_EXP 73
80591: PUSH
80592: LD_VAR 0 1
80596: ARRAY
80597: ST_TO_ADDR
// end ;
80598: LD_VAR 0 2
80602: RET
// export function MC_GetProduceList ( base ) ; begin
80603: LD_INT 0
80605: PPUSH
// result := mc_produce [ base ] ;
80606: LD_ADDR_VAR 0 2
80610: PUSH
80611: LD_EXP 81
80615: PUSH
80616: LD_VAR 0 1
80620: ARRAY
80621: ST_TO_ADDR
// end ;
80622: LD_VAR 0 2
80626: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
80627: LD_INT 0
80629: PPUSH
80630: PPUSH
// if not mc_bases then
80631: LD_EXP 60
80635: NOT
80636: IFFALSE 80640
// exit ;
80638: GO 80705
// if mc_bases [ base ] then
80640: LD_EXP 60
80644: PUSH
80645: LD_VAR 0 1
80649: ARRAY
80650: IFFALSE 80705
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80652: LD_ADDR_VAR 0 3
80656: PUSH
80657: LD_EXP 60
80661: PUSH
80662: LD_VAR 0 1
80666: ARRAY
80667: PPUSH
80668: LD_INT 30
80670: PUSH
80671: LD_VAR 0 2
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PPUSH
80680: CALL_OW 72
80684: ST_TO_ADDR
// if result then
80685: LD_VAR 0 3
80689: IFFALSE 80705
// result := result [ 1 ] ;
80691: LD_ADDR_VAR 0 3
80695: PUSH
80696: LD_VAR 0 3
80700: PUSH
80701: LD_INT 1
80703: ARRAY
80704: ST_TO_ADDR
// end ; end ;
80705: LD_VAR 0 3
80709: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
80710: LD_INT 0
80712: PPUSH
80713: PPUSH
// if not mc_bases then
80714: LD_EXP 60
80718: NOT
80719: IFFALSE 80723
// exit ;
80721: GO 80768
// if mc_bases [ base ] then
80723: LD_EXP 60
80727: PUSH
80728: LD_VAR 0 1
80732: ARRAY
80733: IFFALSE 80768
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80735: LD_ADDR_VAR 0 3
80739: PUSH
80740: LD_EXP 60
80744: PUSH
80745: LD_VAR 0 1
80749: ARRAY
80750: PPUSH
80751: LD_INT 30
80753: PUSH
80754: LD_VAR 0 2
80758: PUSH
80759: EMPTY
80760: LIST
80761: LIST
80762: PPUSH
80763: CALL_OW 72
80767: ST_TO_ADDR
// end ;
80768: LD_VAR 0 3
80772: RET
// export function MC_SetTame ( base , area ) ; begin
80773: LD_INT 0
80775: PPUSH
// if not mc_bases or not base then
80776: LD_EXP 60
80780: NOT
80781: PUSH
80782: LD_VAR 0 1
80786: NOT
80787: OR
80788: IFFALSE 80792
// exit ;
80790: GO 80817
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
80792: LD_ADDR_EXP 88
80796: PUSH
80797: LD_EXP 88
80801: PPUSH
80802: LD_VAR 0 1
80806: PPUSH
80807: LD_VAR 0 2
80811: PPUSH
80812: CALL_OW 1
80816: ST_TO_ADDR
// end ;
80817: LD_VAR 0 3
80821: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
80822: LD_INT 0
80824: PPUSH
80825: PPUSH
// if not mc_bases or not base then
80826: LD_EXP 60
80830: NOT
80831: PUSH
80832: LD_VAR 0 1
80836: NOT
80837: OR
80838: IFFALSE 80842
// exit ;
80840: GO 80944
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80842: LD_ADDR_VAR 0 4
80846: PUSH
80847: LD_EXP 60
80851: PUSH
80852: LD_VAR 0 1
80856: ARRAY
80857: PPUSH
80858: LD_INT 30
80860: PUSH
80861: LD_VAR 0 2
80865: PUSH
80866: EMPTY
80867: LIST
80868: LIST
80869: PPUSH
80870: CALL_OW 72
80874: ST_TO_ADDR
// if not tmp then
80875: LD_VAR 0 4
80879: NOT
80880: IFFALSE 80884
// exit ;
80882: GO 80944
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
80884: LD_ADDR_EXP 92
80888: PUSH
80889: LD_EXP 92
80893: PPUSH
80894: LD_VAR 0 1
80898: PPUSH
80899: LD_EXP 92
80903: PUSH
80904: LD_VAR 0 1
80908: ARRAY
80909: PPUSH
80910: LD_EXP 92
80914: PUSH
80915: LD_VAR 0 1
80919: ARRAY
80920: PUSH
80921: LD_INT 1
80923: PLUS
80924: PPUSH
80925: LD_VAR 0 4
80929: PUSH
80930: LD_INT 1
80932: ARRAY
80933: PPUSH
80934: CALL_OW 2
80938: PPUSH
80939: CALL_OW 1
80943: ST_TO_ADDR
// end ;
80944: LD_VAR 0 3
80948: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
80949: LD_INT 0
80951: PPUSH
80952: PPUSH
// if not mc_bases or not base or not kinds then
80953: LD_EXP 60
80957: NOT
80958: PUSH
80959: LD_VAR 0 1
80963: NOT
80964: OR
80965: PUSH
80966: LD_VAR 0 2
80970: NOT
80971: OR
80972: IFFALSE 80976
// exit ;
80974: GO 81037
// for i in kinds do
80976: LD_ADDR_VAR 0 4
80980: PUSH
80981: LD_VAR 0 2
80985: PUSH
80986: FOR_IN
80987: IFFALSE 81035
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
80989: LD_ADDR_EXP 94
80993: PUSH
80994: LD_EXP 94
80998: PPUSH
80999: LD_VAR 0 1
81003: PUSH
81004: LD_EXP 94
81008: PUSH
81009: LD_VAR 0 1
81013: ARRAY
81014: PUSH
81015: LD_INT 1
81017: PLUS
81018: PUSH
81019: EMPTY
81020: LIST
81021: LIST
81022: PPUSH
81023: LD_VAR 0 4
81027: PPUSH
81028: CALL 19991 0 3
81032: ST_TO_ADDR
81033: GO 80986
81035: POP
81036: POP
// end ;
81037: LD_VAR 0 3
81041: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81042: LD_INT 0
81044: PPUSH
// if not mc_bases or not base or not areas then
81045: LD_EXP 60
81049: NOT
81050: PUSH
81051: LD_VAR 0 1
81055: NOT
81056: OR
81057: PUSH
81058: LD_VAR 0 2
81062: NOT
81063: OR
81064: IFFALSE 81068
// exit ;
81066: GO 81093
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81068: LD_ADDR_EXP 78
81072: PUSH
81073: LD_EXP 78
81077: PPUSH
81078: LD_VAR 0 1
81082: PPUSH
81083: LD_VAR 0 2
81087: PPUSH
81088: CALL_OW 1
81092: ST_TO_ADDR
// end ;
81093: LD_VAR 0 3
81097: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
81098: LD_INT 0
81100: PPUSH
// if not mc_bases or not base or not teleports_exit then
81101: LD_EXP 60
81105: NOT
81106: PUSH
81107: LD_VAR 0 1
81111: NOT
81112: OR
81113: PUSH
81114: LD_VAR 0 2
81118: NOT
81119: OR
81120: IFFALSE 81124
// exit ;
81122: GO 81149
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
81124: LD_ADDR_EXP 95
81128: PUSH
81129: LD_EXP 95
81133: PPUSH
81134: LD_VAR 0 1
81138: PPUSH
81139: LD_VAR 0 2
81143: PPUSH
81144: CALL_OW 1
81148: ST_TO_ADDR
// end ;
81149: LD_VAR 0 3
81153: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
81154: LD_INT 0
81156: PPUSH
81157: PPUSH
81158: PPUSH
// if not mc_bases or not base or not ext_list then
81159: LD_EXP 60
81163: NOT
81164: PUSH
81165: LD_VAR 0 1
81169: NOT
81170: OR
81171: PUSH
81172: LD_VAR 0 5
81176: NOT
81177: OR
81178: IFFALSE 81182
// exit ;
81180: GO 81355
// tmp := GetFacExtXYD ( x , y , d ) ;
81182: LD_ADDR_VAR 0 8
81186: PUSH
81187: LD_VAR 0 2
81191: PPUSH
81192: LD_VAR 0 3
81196: PPUSH
81197: LD_VAR 0 4
81201: PPUSH
81202: CALL 49869 0 3
81206: ST_TO_ADDR
// if not tmp then
81207: LD_VAR 0 8
81211: NOT
81212: IFFALSE 81216
// exit ;
81214: GO 81355
// for i in tmp do
81216: LD_ADDR_VAR 0 7
81220: PUSH
81221: LD_VAR 0 8
81225: PUSH
81226: FOR_IN
81227: IFFALSE 81353
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
81229: LD_ADDR_EXP 65
81233: PUSH
81234: LD_EXP 65
81238: PPUSH
81239: LD_VAR 0 1
81243: PPUSH
81244: LD_EXP 65
81248: PUSH
81249: LD_VAR 0 1
81253: ARRAY
81254: PPUSH
81255: LD_EXP 65
81259: PUSH
81260: LD_VAR 0 1
81264: ARRAY
81265: PUSH
81266: LD_INT 1
81268: PLUS
81269: PPUSH
81270: LD_VAR 0 5
81274: PUSH
81275: LD_INT 1
81277: ARRAY
81278: PUSH
81279: LD_VAR 0 7
81283: PUSH
81284: LD_INT 1
81286: ARRAY
81287: PUSH
81288: LD_VAR 0 7
81292: PUSH
81293: LD_INT 2
81295: ARRAY
81296: PUSH
81297: LD_VAR 0 7
81301: PUSH
81302: LD_INT 3
81304: ARRAY
81305: PUSH
81306: EMPTY
81307: LIST
81308: LIST
81309: LIST
81310: LIST
81311: PPUSH
81312: CALL_OW 2
81316: PPUSH
81317: CALL_OW 1
81321: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
81322: LD_ADDR_VAR 0 5
81326: PUSH
81327: LD_VAR 0 5
81331: PPUSH
81332: LD_INT 1
81334: PPUSH
81335: CALL_OW 3
81339: ST_TO_ADDR
// if not ext_list then
81340: LD_VAR 0 5
81344: NOT
81345: IFFALSE 81351
// exit ;
81347: POP
81348: POP
81349: GO 81355
// end ;
81351: GO 81226
81353: POP
81354: POP
// end ;
81355: LD_VAR 0 6
81359: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
81360: LD_INT 0
81362: PPUSH
// if not mc_bases or not base or not weapon_list then
81363: LD_EXP 60
81367: NOT
81368: PUSH
81369: LD_VAR 0 1
81373: NOT
81374: OR
81375: PUSH
81376: LD_VAR 0 2
81380: NOT
81381: OR
81382: IFFALSE 81386
// exit ;
81384: GO 81411
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
81386: LD_ADDR_EXP 99
81390: PUSH
81391: LD_EXP 99
81395: PPUSH
81396: LD_VAR 0 1
81400: PPUSH
81401: LD_VAR 0 2
81405: PPUSH
81406: CALL_OW 1
81410: ST_TO_ADDR
// end ;
81411: LD_VAR 0 3
81415: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
81416: LD_INT 0
81418: PPUSH
// if not mc_bases or not base or not tech_list then
81419: LD_EXP 60
81423: NOT
81424: PUSH
81425: LD_VAR 0 1
81429: NOT
81430: OR
81431: PUSH
81432: LD_VAR 0 2
81436: NOT
81437: OR
81438: IFFALSE 81442
// exit ;
81440: GO 81467
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
81442: LD_ADDR_EXP 87
81446: PUSH
81447: LD_EXP 87
81451: PPUSH
81452: LD_VAR 0 1
81456: PPUSH
81457: LD_VAR 0 2
81461: PPUSH
81462: CALL_OW 1
81466: ST_TO_ADDR
// end ;
81467: LD_VAR 0 3
81471: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
81472: LD_INT 0
81474: PPUSH
// if not mc_bases or not parking_area or not base then
81475: LD_EXP 60
81479: NOT
81480: PUSH
81481: LD_VAR 0 2
81485: NOT
81486: OR
81487: PUSH
81488: LD_VAR 0 1
81492: NOT
81493: OR
81494: IFFALSE 81498
// exit ;
81496: GO 81523
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
81498: LD_ADDR_EXP 84
81502: PUSH
81503: LD_EXP 84
81507: PPUSH
81508: LD_VAR 0 1
81512: PPUSH
81513: LD_VAR 0 2
81517: PPUSH
81518: CALL_OW 1
81522: ST_TO_ADDR
// end ;
81523: LD_VAR 0 3
81527: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
81528: LD_INT 0
81530: PPUSH
// if not mc_bases or not base or not scan_area then
81531: LD_EXP 60
81535: NOT
81536: PUSH
81537: LD_VAR 0 1
81541: NOT
81542: OR
81543: PUSH
81544: LD_VAR 0 2
81548: NOT
81549: OR
81550: IFFALSE 81554
// exit ;
81552: GO 81579
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
81554: LD_ADDR_EXP 85
81558: PUSH
81559: LD_EXP 85
81563: PPUSH
81564: LD_VAR 0 1
81568: PPUSH
81569: LD_VAR 0 2
81573: PPUSH
81574: CALL_OW 1
81578: ST_TO_ADDR
// end ;
81579: LD_VAR 0 3
81583: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
81584: LD_INT 0
81586: PPUSH
81587: PPUSH
// if not mc_bases or not base then
81588: LD_EXP 60
81592: NOT
81593: PUSH
81594: LD_VAR 0 1
81598: NOT
81599: OR
81600: IFFALSE 81604
// exit ;
81602: GO 81668
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
81604: LD_ADDR_VAR 0 3
81608: PUSH
81609: LD_INT 1
81611: PUSH
81612: LD_INT 2
81614: PUSH
81615: LD_INT 3
81617: PUSH
81618: LD_INT 4
81620: PUSH
81621: LD_INT 11
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: LIST
81628: LIST
81629: LIST
81630: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
81631: LD_ADDR_EXP 87
81635: PUSH
81636: LD_EXP 87
81640: PPUSH
81641: LD_VAR 0 1
81645: PPUSH
81646: LD_EXP 87
81650: PUSH
81651: LD_VAR 0 1
81655: ARRAY
81656: PUSH
81657: LD_VAR 0 3
81661: DIFF
81662: PPUSH
81663: CALL_OW 1
81667: ST_TO_ADDR
// end ;
81668: LD_VAR 0 2
81672: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
81673: LD_INT 0
81675: PPUSH
// result := mc_vehicles [ base ] ;
81676: LD_ADDR_VAR 0 3
81680: PUSH
81681: LD_EXP 79
81685: PUSH
81686: LD_VAR 0 1
81690: ARRAY
81691: ST_TO_ADDR
// if onlyCombat then
81692: LD_VAR 0 2
81696: IFFALSE 81868
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
81698: LD_ADDR_VAR 0 3
81702: PUSH
81703: LD_VAR 0 3
81707: PUSH
81708: LD_VAR 0 3
81712: PPUSH
81713: LD_INT 2
81715: PUSH
81716: LD_INT 34
81718: PUSH
81719: LD_INT 12
81721: PUSH
81722: EMPTY
81723: LIST
81724: LIST
81725: PUSH
81726: LD_INT 34
81728: PUSH
81729: LD_INT 51
81731: PUSH
81732: EMPTY
81733: LIST
81734: LIST
81735: PUSH
81736: LD_INT 34
81738: PUSH
81739: LD_INT 89
81741: PUSH
81742: EMPTY
81743: LIST
81744: LIST
81745: PUSH
81746: LD_INT 34
81748: PUSH
81749: LD_INT 32
81751: PUSH
81752: EMPTY
81753: LIST
81754: LIST
81755: PUSH
81756: LD_INT 34
81758: PUSH
81759: LD_INT 13
81761: PUSH
81762: EMPTY
81763: LIST
81764: LIST
81765: PUSH
81766: LD_INT 34
81768: PUSH
81769: LD_INT 52
81771: PUSH
81772: EMPTY
81773: LIST
81774: LIST
81775: PUSH
81776: LD_INT 34
81778: PUSH
81779: LD_INT 88
81781: PUSH
81782: EMPTY
81783: LIST
81784: LIST
81785: PUSH
81786: LD_INT 34
81788: PUSH
81789: LD_INT 14
81791: PUSH
81792: EMPTY
81793: LIST
81794: LIST
81795: PUSH
81796: LD_INT 34
81798: PUSH
81799: LD_INT 53
81801: PUSH
81802: EMPTY
81803: LIST
81804: LIST
81805: PUSH
81806: LD_INT 34
81808: PUSH
81809: LD_INT 98
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PUSH
81816: LD_INT 34
81818: PUSH
81819: LD_INT 31
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: LD_INT 34
81828: PUSH
81829: LD_INT 48
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PUSH
81836: LD_INT 34
81838: PUSH
81839: LD_INT 8
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: PUSH
81846: EMPTY
81847: LIST
81848: LIST
81849: LIST
81850: LIST
81851: LIST
81852: LIST
81853: LIST
81854: LIST
81855: LIST
81856: LIST
81857: LIST
81858: LIST
81859: LIST
81860: LIST
81861: PPUSH
81862: CALL_OW 72
81866: DIFF
81867: ST_TO_ADDR
// end ; end_of_file
81868: LD_VAR 0 3
81872: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
81873: LD_INT 0
81875: PPUSH
81876: PPUSH
81877: PPUSH
// if not mc_bases or not skirmish then
81878: LD_EXP 60
81882: NOT
81883: PUSH
81884: LD_EXP 58
81888: NOT
81889: OR
81890: IFFALSE 81894
// exit ;
81892: GO 82059
// for i = 1 to mc_bases do
81894: LD_ADDR_VAR 0 4
81898: PUSH
81899: DOUBLE
81900: LD_INT 1
81902: DEC
81903: ST_TO_ADDR
81904: LD_EXP 60
81908: PUSH
81909: FOR_TO
81910: IFFALSE 82057
// begin if sci in mc_bases [ i ] then
81912: LD_VAR 0 2
81916: PUSH
81917: LD_EXP 60
81921: PUSH
81922: LD_VAR 0 4
81926: ARRAY
81927: IN
81928: IFFALSE 82055
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
81930: LD_ADDR_EXP 89
81934: PUSH
81935: LD_EXP 89
81939: PPUSH
81940: LD_VAR 0 4
81944: PUSH
81945: LD_EXP 89
81949: PUSH
81950: LD_VAR 0 4
81954: ARRAY
81955: PUSH
81956: LD_INT 1
81958: PLUS
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: PPUSH
81964: LD_VAR 0 1
81968: PPUSH
81969: CALL 19991 0 3
81973: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
81974: LD_ADDR_VAR 0 5
81978: PUSH
81979: LD_EXP 60
81983: PUSH
81984: LD_VAR 0 4
81988: ARRAY
81989: PPUSH
81990: LD_INT 2
81992: PUSH
81993: LD_INT 30
81995: PUSH
81996: LD_INT 0
81998: PUSH
81999: EMPTY
82000: LIST
82001: LIST
82002: PUSH
82003: LD_INT 30
82005: PUSH
82006: LD_INT 1
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: EMPTY
82014: LIST
82015: LIST
82016: LIST
82017: PPUSH
82018: CALL_OW 72
82022: PPUSH
82023: LD_VAR 0 1
82027: PPUSH
82028: CALL_OW 74
82032: ST_TO_ADDR
// if tmp then
82033: LD_VAR 0 5
82037: IFFALSE 82053
// ComStandNearbyBuilding ( ape , tmp ) ;
82039: LD_VAR 0 1
82043: PPUSH
82044: LD_VAR 0 5
82048: PPUSH
82049: CALL 16418 0 2
// break ;
82053: GO 82057
// end ; end ;
82055: GO 81909
82057: POP
82058: POP
// end ;
82059: LD_VAR 0 3
82063: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82064: LD_INT 0
82066: PPUSH
82067: PPUSH
82068: PPUSH
// if not mc_bases or not skirmish then
82069: LD_EXP 60
82073: NOT
82074: PUSH
82075: LD_EXP 58
82079: NOT
82080: OR
82081: IFFALSE 82085
// exit ;
82083: GO 82174
// for i = 1 to mc_bases do
82085: LD_ADDR_VAR 0 4
82089: PUSH
82090: DOUBLE
82091: LD_INT 1
82093: DEC
82094: ST_TO_ADDR
82095: LD_EXP 60
82099: PUSH
82100: FOR_TO
82101: IFFALSE 82172
// begin if building in mc_busy_turret_list [ i ] then
82103: LD_VAR 0 1
82107: PUSH
82108: LD_EXP 70
82112: PUSH
82113: LD_VAR 0 4
82117: ARRAY
82118: IN
82119: IFFALSE 82170
// begin tmp := mc_busy_turret_list [ i ] diff building ;
82121: LD_ADDR_VAR 0 5
82125: PUSH
82126: LD_EXP 70
82130: PUSH
82131: LD_VAR 0 4
82135: ARRAY
82136: PUSH
82137: LD_VAR 0 1
82141: DIFF
82142: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
82143: LD_ADDR_EXP 70
82147: PUSH
82148: LD_EXP 70
82152: PPUSH
82153: LD_VAR 0 4
82157: PPUSH
82158: LD_VAR 0 5
82162: PPUSH
82163: CALL_OW 1
82167: ST_TO_ADDR
// break ;
82168: GO 82172
// end ; end ;
82170: GO 82100
82172: POP
82173: POP
// end ;
82174: LD_VAR 0 3
82178: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
82179: LD_INT 0
82181: PPUSH
82182: PPUSH
82183: PPUSH
// if not mc_bases or not skirmish then
82184: LD_EXP 60
82188: NOT
82189: PUSH
82190: LD_EXP 58
82194: NOT
82195: OR
82196: IFFALSE 82200
// exit ;
82198: GO 82399
// for i = 1 to mc_bases do
82200: LD_ADDR_VAR 0 5
82204: PUSH
82205: DOUBLE
82206: LD_INT 1
82208: DEC
82209: ST_TO_ADDR
82210: LD_EXP 60
82214: PUSH
82215: FOR_TO
82216: IFFALSE 82397
// if building in mc_bases [ i ] then
82218: LD_VAR 0 1
82222: PUSH
82223: LD_EXP 60
82227: PUSH
82228: LD_VAR 0 5
82232: ARRAY
82233: IN
82234: IFFALSE 82395
// begin tmp := mc_bases [ i ] diff building ;
82236: LD_ADDR_VAR 0 6
82240: PUSH
82241: LD_EXP 60
82245: PUSH
82246: LD_VAR 0 5
82250: ARRAY
82251: PUSH
82252: LD_VAR 0 1
82256: DIFF
82257: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
82258: LD_ADDR_EXP 60
82262: PUSH
82263: LD_EXP 60
82267: PPUSH
82268: LD_VAR 0 5
82272: PPUSH
82273: LD_VAR 0 6
82277: PPUSH
82278: CALL_OW 1
82282: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
82283: LD_VAR 0 1
82287: PUSH
82288: LD_EXP 68
82292: PUSH
82293: LD_VAR 0 5
82297: ARRAY
82298: IN
82299: IFFALSE 82338
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
82301: LD_ADDR_EXP 68
82305: PUSH
82306: LD_EXP 68
82310: PPUSH
82311: LD_VAR 0 5
82315: PPUSH
82316: LD_EXP 68
82320: PUSH
82321: LD_VAR 0 5
82325: ARRAY
82326: PUSH
82327: LD_VAR 0 1
82331: DIFF
82332: PPUSH
82333: CALL_OW 1
82337: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
82338: LD_VAR 0 1
82342: PUSH
82343: LD_EXP 69
82347: PUSH
82348: LD_VAR 0 5
82352: ARRAY
82353: IN
82354: IFFALSE 82393
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
82356: LD_ADDR_EXP 69
82360: PUSH
82361: LD_EXP 69
82365: PPUSH
82366: LD_VAR 0 5
82370: PPUSH
82371: LD_EXP 69
82375: PUSH
82376: LD_VAR 0 5
82380: ARRAY
82381: PUSH
82382: LD_VAR 0 1
82386: DIFF
82387: PPUSH
82388: CALL_OW 1
82392: ST_TO_ADDR
// break ;
82393: GO 82397
// end ;
82395: GO 82215
82397: POP
82398: POP
// end ;
82399: LD_VAR 0 4
82403: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
82404: LD_INT 0
82406: PPUSH
82407: PPUSH
82408: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
82409: LD_EXP 60
82413: NOT
82414: PUSH
82415: LD_EXP 58
82419: NOT
82420: OR
82421: PUSH
82422: LD_VAR 0 3
82426: PUSH
82427: LD_EXP 86
82431: IN
82432: NOT
82433: OR
82434: IFFALSE 82438
// exit ;
82436: GO 82561
// for i = 1 to mc_vehicles do
82438: LD_ADDR_VAR 0 6
82442: PUSH
82443: DOUBLE
82444: LD_INT 1
82446: DEC
82447: ST_TO_ADDR
82448: LD_EXP 79
82452: PUSH
82453: FOR_TO
82454: IFFALSE 82559
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
82456: LD_VAR 0 2
82460: PUSH
82461: LD_EXP 79
82465: PUSH
82466: LD_VAR 0 6
82470: ARRAY
82471: IN
82472: PUSH
82473: LD_VAR 0 1
82477: PUSH
82478: LD_EXP 79
82482: PUSH
82483: LD_VAR 0 6
82487: ARRAY
82488: IN
82489: OR
82490: IFFALSE 82557
// begin tmp := mc_vehicles [ i ] diff old ;
82492: LD_ADDR_VAR 0 7
82496: PUSH
82497: LD_EXP 79
82501: PUSH
82502: LD_VAR 0 6
82506: ARRAY
82507: PUSH
82508: LD_VAR 0 2
82512: DIFF
82513: ST_TO_ADDR
// tmp := tmp diff new ;
82514: LD_ADDR_VAR 0 7
82518: PUSH
82519: LD_VAR 0 7
82523: PUSH
82524: LD_VAR 0 1
82528: DIFF
82529: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
82530: LD_ADDR_EXP 79
82534: PUSH
82535: LD_EXP 79
82539: PPUSH
82540: LD_VAR 0 6
82544: PPUSH
82545: LD_VAR 0 7
82549: PPUSH
82550: CALL_OW 1
82554: ST_TO_ADDR
// break ;
82555: GO 82559
// end ;
82557: GO 82453
82559: POP
82560: POP
// end ;
82561: LD_VAR 0 5
82565: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
82566: LD_INT 0
82568: PPUSH
82569: PPUSH
82570: PPUSH
82571: PPUSH
// if not mc_bases or not skirmish then
82572: LD_EXP 60
82576: NOT
82577: PUSH
82578: LD_EXP 58
82582: NOT
82583: OR
82584: IFFALSE 82588
// exit ;
82586: GO 82970
// side := GetSide ( vehicle ) ;
82588: LD_ADDR_VAR 0 5
82592: PUSH
82593: LD_VAR 0 1
82597: PPUSH
82598: CALL_OW 255
82602: ST_TO_ADDR
// for i = 1 to mc_bases do
82603: LD_ADDR_VAR 0 4
82607: PUSH
82608: DOUBLE
82609: LD_INT 1
82611: DEC
82612: ST_TO_ADDR
82613: LD_EXP 60
82617: PUSH
82618: FOR_TO
82619: IFFALSE 82968
// begin if factory in mc_bases [ i ] then
82621: LD_VAR 0 2
82625: PUSH
82626: LD_EXP 60
82630: PUSH
82631: LD_VAR 0 4
82635: ARRAY
82636: IN
82637: IFFALSE 82966
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
82639: LD_EXP 82
82643: PUSH
82644: LD_VAR 0 4
82648: ARRAY
82649: PUSH
82650: LD_EXP 71
82654: PUSH
82655: LD_VAR 0 4
82659: ARRAY
82660: LESS
82661: PUSH
82662: LD_VAR 0 1
82666: PPUSH
82667: CALL_OW 264
82671: PUSH
82672: LD_INT 31
82674: PUSH
82675: LD_INT 32
82677: PUSH
82678: LD_INT 51
82680: PUSH
82681: LD_INT 89
82683: PUSH
82684: LD_INT 12
82686: PUSH
82687: LD_INT 30
82689: PUSH
82690: LD_INT 98
82692: PUSH
82693: LD_INT 11
82695: PUSH
82696: LD_INT 53
82698: PUSH
82699: LD_INT 14
82701: PUSH
82702: LD_INT 91
82704: PUSH
82705: LD_INT 29
82707: PUSH
82708: LD_INT 99
82710: PUSH
82711: LD_INT 13
82713: PUSH
82714: LD_INT 52
82716: PUSH
82717: LD_INT 88
82719: PUSH
82720: LD_INT 48
82722: PUSH
82723: LD_INT 8
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: LIST
82744: LIST
82745: IN
82746: NOT
82747: AND
82748: IFFALSE 82796
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
82750: LD_ADDR_EXP 82
82754: PUSH
82755: LD_EXP 82
82759: PPUSH
82760: LD_VAR 0 4
82764: PUSH
82765: LD_EXP 82
82769: PUSH
82770: LD_VAR 0 4
82774: ARRAY
82775: PUSH
82776: LD_INT 1
82778: PLUS
82779: PUSH
82780: EMPTY
82781: LIST
82782: LIST
82783: PPUSH
82784: LD_VAR 0 1
82788: PPUSH
82789: CALL 19991 0 3
82793: ST_TO_ADDR
82794: GO 82840
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
82796: LD_ADDR_EXP 79
82800: PUSH
82801: LD_EXP 79
82805: PPUSH
82806: LD_VAR 0 4
82810: PUSH
82811: LD_EXP 79
82815: PUSH
82816: LD_VAR 0 4
82820: ARRAY
82821: PUSH
82822: LD_INT 1
82824: PLUS
82825: PUSH
82826: EMPTY
82827: LIST
82828: LIST
82829: PPUSH
82830: LD_VAR 0 1
82834: PPUSH
82835: CALL 19991 0 3
82839: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
82840: LD_VAR 0 1
82844: PPUSH
82845: CALL_OW 263
82849: PUSH
82850: LD_INT 2
82852: EQUAL
82853: IFFALSE 82882
// begin repeat wait ( 0 0$3 ) ;
82855: LD_INT 105
82857: PPUSH
82858: CALL_OW 67
// Connect ( vehicle ) ;
82862: LD_VAR 0 1
82866: PPUSH
82867: CALL 22960 0 1
// until IsControledBy ( vehicle ) ;
82871: LD_VAR 0 1
82875: PPUSH
82876: CALL_OW 312
82880: IFFALSE 82855
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
82882: LD_VAR 0 1
82886: PPUSH
82887: LD_EXP 84
82891: PUSH
82892: LD_VAR 0 4
82896: ARRAY
82897: PPUSH
82898: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
82902: LD_VAR 0 1
82906: PPUSH
82907: CALL_OW 263
82911: PUSH
82912: LD_INT 1
82914: NONEQUAL
82915: IFFALSE 82919
// break ;
82917: GO 82968
// repeat wait ( 0 0$1 ) ;
82919: LD_INT 35
82921: PPUSH
82922: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
82926: LD_VAR 0 1
82930: PPUSH
82931: LD_EXP 84
82935: PUSH
82936: LD_VAR 0 4
82940: ARRAY
82941: PPUSH
82942: CALL_OW 308
82946: IFFALSE 82919
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
82948: LD_VAR 0 1
82952: PPUSH
82953: CALL_OW 311
82957: PPUSH
82958: CALL_OW 121
// exit ;
82962: POP
82963: POP
82964: GO 82970
// end ; end ;
82966: GO 82618
82968: POP
82969: POP
// end ;
82970: LD_VAR 0 3
82974: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
82975: LD_INT 0
82977: PPUSH
82978: PPUSH
82979: PPUSH
82980: PPUSH
// if not mc_bases or not skirmish then
82981: LD_EXP 60
82985: NOT
82986: PUSH
82987: LD_EXP 58
82991: NOT
82992: OR
82993: IFFALSE 82997
// exit ;
82995: GO 83350
// repeat wait ( 0 0$1 ) ;
82997: LD_INT 35
82999: PPUSH
83000: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83004: LD_VAR 0 2
83008: PPUSH
83009: LD_VAR 0 3
83013: PPUSH
83014: CALL_OW 284
83018: IFFALSE 82997
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83020: LD_VAR 0 2
83024: PPUSH
83025: LD_VAR 0 3
83029: PPUSH
83030: CALL_OW 283
83034: PUSH
83035: LD_INT 4
83037: EQUAL
83038: IFFALSE 83042
// exit ;
83040: GO 83350
// for i = 1 to mc_bases do
83042: LD_ADDR_VAR 0 7
83046: PUSH
83047: DOUBLE
83048: LD_INT 1
83050: DEC
83051: ST_TO_ADDR
83052: LD_EXP 60
83056: PUSH
83057: FOR_TO
83058: IFFALSE 83348
// begin if mc_crates_area [ i ] then
83060: LD_EXP 78
83064: PUSH
83065: LD_VAR 0 7
83069: ARRAY
83070: IFFALSE 83181
// for j in mc_crates_area [ i ] do
83072: LD_ADDR_VAR 0 8
83076: PUSH
83077: LD_EXP 78
83081: PUSH
83082: LD_VAR 0 7
83086: ARRAY
83087: PUSH
83088: FOR_IN
83089: IFFALSE 83179
// if InArea ( x , y , j ) then
83091: LD_VAR 0 2
83095: PPUSH
83096: LD_VAR 0 3
83100: PPUSH
83101: LD_VAR 0 8
83105: PPUSH
83106: CALL_OW 309
83110: IFFALSE 83177
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83112: LD_ADDR_EXP 76
83116: PUSH
83117: LD_EXP 76
83121: PPUSH
83122: LD_VAR 0 7
83126: PUSH
83127: LD_EXP 76
83131: PUSH
83132: LD_VAR 0 7
83136: ARRAY
83137: PUSH
83138: LD_INT 1
83140: PLUS
83141: PUSH
83142: EMPTY
83143: LIST
83144: LIST
83145: PPUSH
83146: LD_VAR 0 4
83150: PUSH
83151: LD_VAR 0 2
83155: PUSH
83156: LD_VAR 0 3
83160: PUSH
83161: EMPTY
83162: LIST
83163: LIST
83164: LIST
83165: PPUSH
83166: CALL 19991 0 3
83170: ST_TO_ADDR
// exit ;
83171: POP
83172: POP
83173: POP
83174: POP
83175: GO 83350
// end ;
83177: GO 83088
83179: POP
83180: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83181: LD_ADDR_VAR 0 9
83185: PUSH
83186: LD_EXP 60
83190: PUSH
83191: LD_VAR 0 7
83195: ARRAY
83196: PPUSH
83197: LD_INT 2
83199: PUSH
83200: LD_INT 30
83202: PUSH
83203: LD_INT 0
83205: PUSH
83206: EMPTY
83207: LIST
83208: LIST
83209: PUSH
83210: LD_INT 30
83212: PUSH
83213: LD_INT 1
83215: PUSH
83216: EMPTY
83217: LIST
83218: LIST
83219: PUSH
83220: EMPTY
83221: LIST
83222: LIST
83223: LIST
83224: PPUSH
83225: CALL_OW 72
83229: ST_TO_ADDR
// if not depot then
83230: LD_VAR 0 9
83234: NOT
83235: IFFALSE 83239
// continue ;
83237: GO 83057
// for j in depot do
83239: LD_ADDR_VAR 0 8
83243: PUSH
83244: LD_VAR 0 9
83248: PUSH
83249: FOR_IN
83250: IFFALSE 83344
// if GetDistUnitXY ( j , x , y ) < 30 then
83252: LD_VAR 0 8
83256: PPUSH
83257: LD_VAR 0 2
83261: PPUSH
83262: LD_VAR 0 3
83266: PPUSH
83267: CALL_OW 297
83271: PUSH
83272: LD_INT 30
83274: LESS
83275: IFFALSE 83342
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83277: LD_ADDR_EXP 76
83281: PUSH
83282: LD_EXP 76
83286: PPUSH
83287: LD_VAR 0 7
83291: PUSH
83292: LD_EXP 76
83296: PUSH
83297: LD_VAR 0 7
83301: ARRAY
83302: PUSH
83303: LD_INT 1
83305: PLUS
83306: PUSH
83307: EMPTY
83308: LIST
83309: LIST
83310: PPUSH
83311: LD_VAR 0 4
83315: PUSH
83316: LD_VAR 0 2
83320: PUSH
83321: LD_VAR 0 3
83325: PUSH
83326: EMPTY
83327: LIST
83328: LIST
83329: LIST
83330: PPUSH
83331: CALL 19991 0 3
83335: ST_TO_ADDR
// exit ;
83336: POP
83337: POP
83338: POP
83339: POP
83340: GO 83350
// end ;
83342: GO 83249
83344: POP
83345: POP
// end ;
83346: GO 83057
83348: POP
83349: POP
// end ;
83350: LD_VAR 0 6
83354: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
83355: LD_INT 0
83357: PPUSH
83358: PPUSH
83359: PPUSH
83360: PPUSH
// if not mc_bases or not skirmish then
83361: LD_EXP 60
83365: NOT
83366: PUSH
83367: LD_EXP 58
83371: NOT
83372: OR
83373: IFFALSE 83377
// exit ;
83375: GO 83654
// side := GetSide ( lab ) ;
83377: LD_ADDR_VAR 0 4
83381: PUSH
83382: LD_VAR 0 2
83386: PPUSH
83387: CALL_OW 255
83391: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
83392: LD_VAR 0 4
83396: PUSH
83397: LD_EXP 86
83401: IN
83402: NOT
83403: PUSH
83404: LD_EXP 87
83408: NOT
83409: OR
83410: PUSH
83411: LD_EXP 60
83415: NOT
83416: OR
83417: IFFALSE 83421
// exit ;
83419: GO 83654
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
83421: LD_ADDR_EXP 87
83425: PUSH
83426: LD_EXP 87
83430: PPUSH
83431: LD_VAR 0 4
83435: PPUSH
83436: LD_EXP 87
83440: PUSH
83441: LD_VAR 0 4
83445: ARRAY
83446: PUSH
83447: LD_VAR 0 1
83451: DIFF
83452: PPUSH
83453: CALL_OW 1
83457: ST_TO_ADDR
// for i = 1 to mc_bases do
83458: LD_ADDR_VAR 0 5
83462: PUSH
83463: DOUBLE
83464: LD_INT 1
83466: DEC
83467: ST_TO_ADDR
83468: LD_EXP 60
83472: PUSH
83473: FOR_TO
83474: IFFALSE 83652
// begin if lab in mc_bases [ i ] then
83476: LD_VAR 0 2
83480: PUSH
83481: LD_EXP 60
83485: PUSH
83486: LD_VAR 0 5
83490: ARRAY
83491: IN
83492: IFFALSE 83650
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
83494: LD_VAR 0 1
83498: PUSH
83499: LD_INT 11
83501: PUSH
83502: LD_INT 4
83504: PUSH
83505: LD_INT 3
83507: PUSH
83508: LD_INT 2
83510: PUSH
83511: EMPTY
83512: LIST
83513: LIST
83514: LIST
83515: LIST
83516: IN
83517: PUSH
83518: LD_EXP 90
83522: PUSH
83523: LD_VAR 0 5
83527: ARRAY
83528: AND
83529: IFFALSE 83650
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
83531: LD_ADDR_VAR 0 6
83535: PUSH
83536: LD_EXP 90
83540: PUSH
83541: LD_VAR 0 5
83545: ARRAY
83546: PUSH
83547: LD_INT 1
83549: ARRAY
83550: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83551: LD_ADDR_EXP 90
83555: PUSH
83556: LD_EXP 90
83560: PPUSH
83561: LD_VAR 0 5
83565: PPUSH
83566: EMPTY
83567: PPUSH
83568: CALL_OW 1
83572: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
83573: LD_VAR 0 6
83577: PPUSH
83578: LD_INT 0
83580: PPUSH
83581: CALL_OW 109
// ComExitBuilding ( tmp ) ;
83585: LD_VAR 0 6
83589: PPUSH
83590: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
83594: LD_ADDR_EXP 89
83598: PUSH
83599: LD_EXP 89
83603: PPUSH
83604: LD_VAR 0 5
83608: PPUSH
83609: LD_EXP 89
83613: PUSH
83614: LD_VAR 0 5
83618: ARRAY
83619: PPUSH
83620: LD_INT 1
83622: PPUSH
83623: LD_VAR 0 6
83627: PPUSH
83628: CALL_OW 2
83632: PPUSH
83633: CALL_OW 1
83637: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
83638: LD_VAR 0 5
83642: PPUSH
83643: LD_INT 112
83645: PPUSH
83646: CALL 60193 0 2
// end ; end ; end ;
83650: GO 83473
83652: POP
83653: POP
// end ;
83654: LD_VAR 0 3
83658: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
83659: LD_INT 0
83661: PPUSH
83662: PPUSH
83663: PPUSH
83664: PPUSH
83665: PPUSH
83666: PPUSH
83667: PPUSH
83668: PPUSH
// if not mc_bases or not skirmish then
83669: LD_EXP 60
83673: NOT
83674: PUSH
83675: LD_EXP 58
83679: NOT
83680: OR
83681: IFFALSE 83685
// exit ;
83683: GO 85054
// for i = 1 to mc_bases do
83685: LD_ADDR_VAR 0 3
83689: PUSH
83690: DOUBLE
83691: LD_INT 1
83693: DEC
83694: ST_TO_ADDR
83695: LD_EXP 60
83699: PUSH
83700: FOR_TO
83701: IFFALSE 85052
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
83703: LD_VAR 0 1
83707: PUSH
83708: LD_EXP 60
83712: PUSH
83713: LD_VAR 0 3
83717: ARRAY
83718: IN
83719: PUSH
83720: LD_VAR 0 1
83724: PUSH
83725: LD_EXP 67
83729: PUSH
83730: LD_VAR 0 3
83734: ARRAY
83735: IN
83736: OR
83737: PUSH
83738: LD_VAR 0 1
83742: PUSH
83743: LD_EXP 82
83747: PUSH
83748: LD_VAR 0 3
83752: ARRAY
83753: IN
83754: OR
83755: PUSH
83756: LD_VAR 0 1
83760: PUSH
83761: LD_EXP 79
83765: PUSH
83766: LD_VAR 0 3
83770: ARRAY
83771: IN
83772: OR
83773: PUSH
83774: LD_VAR 0 1
83778: PUSH
83779: LD_EXP 89
83783: PUSH
83784: LD_VAR 0 3
83788: ARRAY
83789: IN
83790: OR
83791: PUSH
83792: LD_VAR 0 1
83796: PUSH
83797: LD_EXP 90
83801: PUSH
83802: LD_VAR 0 3
83806: ARRAY
83807: IN
83808: OR
83809: IFFALSE 85050
// begin if un in mc_ape [ i ] then
83811: LD_VAR 0 1
83815: PUSH
83816: LD_EXP 89
83820: PUSH
83821: LD_VAR 0 3
83825: ARRAY
83826: IN
83827: IFFALSE 83866
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
83829: LD_ADDR_EXP 89
83833: PUSH
83834: LD_EXP 89
83838: PPUSH
83839: LD_VAR 0 3
83843: PPUSH
83844: LD_EXP 89
83848: PUSH
83849: LD_VAR 0 3
83853: ARRAY
83854: PUSH
83855: LD_VAR 0 1
83859: DIFF
83860: PPUSH
83861: CALL_OW 1
83865: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
83866: LD_VAR 0 1
83870: PUSH
83871: LD_EXP 90
83875: PUSH
83876: LD_VAR 0 3
83880: ARRAY
83881: IN
83882: IFFALSE 83906
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83884: LD_ADDR_EXP 90
83888: PUSH
83889: LD_EXP 90
83893: PPUSH
83894: LD_VAR 0 3
83898: PPUSH
83899: EMPTY
83900: PPUSH
83901: CALL_OW 1
83905: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
83906: LD_VAR 0 1
83910: PPUSH
83911: CALL_OW 247
83915: PUSH
83916: LD_INT 2
83918: EQUAL
83919: PUSH
83920: LD_VAR 0 1
83924: PPUSH
83925: CALL_OW 110
83929: PUSH
83930: LD_INT 20
83932: EQUAL
83933: PUSH
83934: LD_VAR 0 1
83938: PUSH
83939: LD_EXP 82
83943: PUSH
83944: LD_VAR 0 3
83948: ARRAY
83949: IN
83950: OR
83951: PUSH
83952: LD_VAR 0 1
83956: PPUSH
83957: CALL_OW 264
83961: PUSH
83962: LD_INT 12
83964: PUSH
83965: LD_INT 51
83967: PUSH
83968: LD_INT 89
83970: PUSH
83971: LD_INT 32
83973: PUSH
83974: LD_INT 13
83976: PUSH
83977: LD_INT 52
83979: PUSH
83980: LD_INT 31
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: LIST
83987: LIST
83988: LIST
83989: LIST
83990: LIST
83991: IN
83992: OR
83993: AND
83994: IFFALSE 84302
// begin if un in mc_defender [ i ] then
83996: LD_VAR 0 1
84000: PUSH
84001: LD_EXP 82
84005: PUSH
84006: LD_VAR 0 3
84010: ARRAY
84011: IN
84012: IFFALSE 84051
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84014: LD_ADDR_EXP 82
84018: PUSH
84019: LD_EXP 82
84023: PPUSH
84024: LD_VAR 0 3
84028: PPUSH
84029: LD_EXP 82
84033: PUSH
84034: LD_VAR 0 3
84038: ARRAY
84039: PUSH
84040: LD_VAR 0 1
84044: DIFF
84045: PPUSH
84046: CALL_OW 1
84050: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84051: LD_ADDR_VAR 0 8
84055: PUSH
84056: LD_VAR 0 3
84060: PPUSH
84061: LD_INT 3
84063: PPUSH
84064: CALL 80710 0 2
84068: ST_TO_ADDR
// if fac then
84069: LD_VAR 0 8
84073: IFFALSE 84302
// begin for j in fac do
84075: LD_ADDR_VAR 0 4
84079: PUSH
84080: LD_VAR 0 8
84084: PUSH
84085: FOR_IN
84086: IFFALSE 84300
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84088: LD_ADDR_VAR 0 9
84092: PUSH
84093: LD_VAR 0 8
84097: PPUSH
84098: LD_VAR 0 1
84102: PPUSH
84103: CALL_OW 265
84107: PPUSH
84108: LD_VAR 0 1
84112: PPUSH
84113: CALL_OW 262
84117: PPUSH
84118: LD_VAR 0 1
84122: PPUSH
84123: CALL_OW 263
84127: PPUSH
84128: LD_VAR 0 1
84132: PPUSH
84133: CALL_OW 264
84137: PPUSH
84138: CALL 17489 0 5
84142: ST_TO_ADDR
// if components then
84143: LD_VAR 0 9
84147: IFFALSE 84298
// begin if GetWeapon ( un ) = ar_control_tower then
84149: LD_VAR 0 1
84153: PPUSH
84154: CALL_OW 264
84158: PUSH
84159: LD_INT 31
84161: EQUAL
84162: IFFALSE 84279
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
84164: LD_VAR 0 1
84168: PPUSH
84169: CALL_OW 311
84173: PPUSH
84174: LD_INT 0
84176: PPUSH
84177: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
84181: LD_ADDR_EXP 100
84185: PUSH
84186: LD_EXP 100
84190: PPUSH
84191: LD_VAR 0 3
84195: PPUSH
84196: LD_EXP 100
84200: PUSH
84201: LD_VAR 0 3
84205: ARRAY
84206: PUSH
84207: LD_VAR 0 1
84211: PPUSH
84212: CALL_OW 311
84216: DIFF
84217: PPUSH
84218: CALL_OW 1
84222: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
84223: LD_ADDR_VAR 0 7
84227: PUSH
84228: LD_EXP 81
84232: PUSH
84233: LD_VAR 0 3
84237: ARRAY
84238: PPUSH
84239: LD_INT 1
84241: PPUSH
84242: LD_VAR 0 9
84246: PPUSH
84247: CALL_OW 2
84251: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
84252: LD_ADDR_EXP 81
84256: PUSH
84257: LD_EXP 81
84261: PPUSH
84262: LD_VAR 0 3
84266: PPUSH
84267: LD_VAR 0 7
84271: PPUSH
84272: CALL_OW 1
84276: ST_TO_ADDR
// end else
84277: GO 84296
// MC_InsertProduceList ( i , [ components ] ) ;
84279: LD_VAR 0 3
84283: PPUSH
84284: LD_VAR 0 9
84288: PUSH
84289: EMPTY
84290: LIST
84291: PPUSH
84292: CALL 80255 0 2
// break ;
84296: GO 84300
// end ; end ;
84298: GO 84085
84300: POP
84301: POP
// end ; end ; if GetType ( un ) = unit_building then
84302: LD_VAR 0 1
84306: PPUSH
84307: CALL_OW 247
84311: PUSH
84312: LD_INT 3
84314: EQUAL
84315: IFFALSE 84718
// begin btype := GetBType ( un ) ;
84317: LD_ADDR_VAR 0 5
84321: PUSH
84322: LD_VAR 0 1
84326: PPUSH
84327: CALL_OW 266
84331: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
84332: LD_VAR 0 5
84336: PUSH
84337: LD_INT 29
84339: PUSH
84340: LD_INT 30
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: IN
84347: IFFALSE 84420
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
84349: LD_VAR 0 1
84353: PPUSH
84354: CALL_OW 250
84358: PPUSH
84359: LD_VAR 0 1
84363: PPUSH
84364: CALL_OW 251
84368: PPUSH
84369: LD_VAR 0 1
84373: PPUSH
84374: CALL_OW 255
84378: PPUSH
84379: CALL_OW 440
84383: NOT
84384: IFFALSE 84420
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
84386: LD_VAR 0 1
84390: PPUSH
84391: CALL_OW 250
84395: PPUSH
84396: LD_VAR 0 1
84400: PPUSH
84401: CALL_OW 251
84405: PPUSH
84406: LD_VAR 0 1
84410: PPUSH
84411: CALL_OW 255
84415: PPUSH
84416: CALL_OW 441
// end ; if btype = b_warehouse then
84420: LD_VAR 0 5
84424: PUSH
84425: LD_INT 1
84427: EQUAL
84428: IFFALSE 84446
// begin btype := b_depot ;
84430: LD_ADDR_VAR 0 5
84434: PUSH
84435: LD_INT 0
84437: ST_TO_ADDR
// pos := 1 ;
84438: LD_ADDR_VAR 0 6
84442: PUSH
84443: LD_INT 1
84445: ST_TO_ADDR
// end ; if btype = b_factory then
84446: LD_VAR 0 5
84450: PUSH
84451: LD_INT 3
84453: EQUAL
84454: IFFALSE 84472
// begin btype := b_workshop ;
84456: LD_ADDR_VAR 0 5
84460: PUSH
84461: LD_INT 2
84463: ST_TO_ADDR
// pos := 1 ;
84464: LD_ADDR_VAR 0 6
84468: PUSH
84469: LD_INT 1
84471: ST_TO_ADDR
// end ; if btype = b_barracks then
84472: LD_VAR 0 5
84476: PUSH
84477: LD_INT 5
84479: EQUAL
84480: IFFALSE 84490
// btype := b_armoury ;
84482: LD_ADDR_VAR 0 5
84486: PUSH
84487: LD_INT 4
84489: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
84490: LD_VAR 0 5
84494: PUSH
84495: LD_INT 7
84497: PUSH
84498: LD_INT 8
84500: PUSH
84501: EMPTY
84502: LIST
84503: LIST
84504: IN
84505: IFFALSE 84515
// btype := b_lab ;
84507: LD_ADDR_VAR 0 5
84511: PUSH
84512: LD_INT 6
84514: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
84515: LD_ADDR_EXP 65
84519: PUSH
84520: LD_EXP 65
84524: PPUSH
84525: LD_VAR 0 3
84529: PUSH
84530: LD_EXP 65
84534: PUSH
84535: LD_VAR 0 3
84539: ARRAY
84540: PUSH
84541: LD_INT 1
84543: PLUS
84544: PUSH
84545: EMPTY
84546: LIST
84547: LIST
84548: PPUSH
84549: LD_VAR 0 5
84553: PUSH
84554: LD_VAR 0 1
84558: PPUSH
84559: CALL_OW 250
84563: PUSH
84564: LD_VAR 0 1
84568: PPUSH
84569: CALL_OW 251
84573: PUSH
84574: LD_VAR 0 1
84578: PPUSH
84579: CALL_OW 254
84583: PUSH
84584: EMPTY
84585: LIST
84586: LIST
84587: LIST
84588: LIST
84589: PPUSH
84590: CALL 19991 0 3
84594: ST_TO_ADDR
// if pos = 1 then
84595: LD_VAR 0 6
84599: PUSH
84600: LD_INT 1
84602: EQUAL
84603: IFFALSE 84718
// begin tmp := mc_build_list [ i ] ;
84605: LD_ADDR_VAR 0 7
84609: PUSH
84610: LD_EXP 65
84614: PUSH
84615: LD_VAR 0 3
84619: ARRAY
84620: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
84621: LD_VAR 0 7
84625: PPUSH
84626: LD_INT 2
84628: PUSH
84629: LD_INT 30
84631: PUSH
84632: LD_INT 0
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: PUSH
84639: LD_INT 30
84641: PUSH
84642: LD_INT 1
84644: PUSH
84645: EMPTY
84646: LIST
84647: LIST
84648: PUSH
84649: EMPTY
84650: LIST
84651: LIST
84652: LIST
84653: PPUSH
84654: CALL_OW 72
84658: IFFALSE 84668
// pos := 2 ;
84660: LD_ADDR_VAR 0 6
84664: PUSH
84665: LD_INT 2
84667: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
84668: LD_ADDR_VAR 0 7
84672: PUSH
84673: LD_VAR 0 7
84677: PPUSH
84678: LD_VAR 0 6
84682: PPUSH
84683: LD_VAR 0 7
84687: PPUSH
84688: CALL 20317 0 3
84692: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
84693: LD_ADDR_EXP 65
84697: PUSH
84698: LD_EXP 65
84702: PPUSH
84703: LD_VAR 0 3
84707: PPUSH
84708: LD_VAR 0 7
84712: PPUSH
84713: CALL_OW 1
84717: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
84718: LD_VAR 0 1
84722: PUSH
84723: LD_EXP 60
84727: PUSH
84728: LD_VAR 0 3
84732: ARRAY
84733: IN
84734: IFFALSE 84773
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
84736: LD_ADDR_EXP 60
84740: PUSH
84741: LD_EXP 60
84745: PPUSH
84746: LD_VAR 0 3
84750: PPUSH
84751: LD_EXP 60
84755: PUSH
84756: LD_VAR 0 3
84760: ARRAY
84761: PUSH
84762: LD_VAR 0 1
84766: DIFF
84767: PPUSH
84768: CALL_OW 1
84772: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
84773: LD_VAR 0 1
84777: PUSH
84778: LD_EXP 67
84782: PUSH
84783: LD_VAR 0 3
84787: ARRAY
84788: IN
84789: IFFALSE 84828
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
84791: LD_ADDR_EXP 67
84795: PUSH
84796: LD_EXP 67
84800: PPUSH
84801: LD_VAR 0 3
84805: PPUSH
84806: LD_EXP 67
84810: PUSH
84811: LD_VAR 0 3
84815: ARRAY
84816: PUSH
84817: LD_VAR 0 1
84821: DIFF
84822: PPUSH
84823: CALL_OW 1
84827: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
84828: LD_VAR 0 1
84832: PUSH
84833: LD_EXP 79
84837: PUSH
84838: LD_VAR 0 3
84842: ARRAY
84843: IN
84844: IFFALSE 84883
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
84846: LD_ADDR_EXP 79
84850: PUSH
84851: LD_EXP 79
84855: PPUSH
84856: LD_VAR 0 3
84860: PPUSH
84861: LD_EXP 79
84865: PUSH
84866: LD_VAR 0 3
84870: ARRAY
84871: PUSH
84872: LD_VAR 0 1
84876: DIFF
84877: PPUSH
84878: CALL_OW 1
84882: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
84883: LD_VAR 0 1
84887: PUSH
84888: LD_EXP 82
84892: PUSH
84893: LD_VAR 0 3
84897: ARRAY
84898: IN
84899: IFFALSE 84938
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84901: LD_ADDR_EXP 82
84905: PUSH
84906: LD_EXP 82
84910: PPUSH
84911: LD_VAR 0 3
84915: PPUSH
84916: LD_EXP 82
84920: PUSH
84921: LD_VAR 0 3
84925: ARRAY
84926: PUSH
84927: LD_VAR 0 1
84931: DIFF
84932: PPUSH
84933: CALL_OW 1
84937: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
84938: LD_VAR 0 1
84942: PUSH
84943: LD_EXP 69
84947: PUSH
84948: LD_VAR 0 3
84952: ARRAY
84953: IN
84954: IFFALSE 84993
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
84956: LD_ADDR_EXP 69
84960: PUSH
84961: LD_EXP 69
84965: PPUSH
84966: LD_VAR 0 3
84970: PPUSH
84971: LD_EXP 69
84975: PUSH
84976: LD_VAR 0 3
84980: ARRAY
84981: PUSH
84982: LD_VAR 0 1
84986: DIFF
84987: PPUSH
84988: CALL_OW 1
84992: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
84993: LD_VAR 0 1
84997: PUSH
84998: LD_EXP 68
85002: PUSH
85003: LD_VAR 0 3
85007: ARRAY
85008: IN
85009: IFFALSE 85048
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85011: LD_ADDR_EXP 68
85015: PUSH
85016: LD_EXP 68
85020: PPUSH
85021: LD_VAR 0 3
85025: PPUSH
85026: LD_EXP 68
85030: PUSH
85031: LD_VAR 0 3
85035: ARRAY
85036: PUSH
85037: LD_VAR 0 1
85041: DIFF
85042: PPUSH
85043: CALL_OW 1
85047: ST_TO_ADDR
// end ; break ;
85048: GO 85052
// end ;
85050: GO 83700
85052: POP
85053: POP
// end ;
85054: LD_VAR 0 2
85058: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85059: LD_INT 0
85061: PPUSH
85062: PPUSH
85063: PPUSH
// if not mc_bases or not skirmish then
85064: LD_EXP 60
85068: NOT
85069: PUSH
85070: LD_EXP 58
85074: NOT
85075: OR
85076: IFFALSE 85080
// exit ;
85078: GO 85295
// for i = 1 to mc_bases do
85080: LD_ADDR_VAR 0 3
85084: PUSH
85085: DOUBLE
85086: LD_INT 1
85088: DEC
85089: ST_TO_ADDR
85090: LD_EXP 60
85094: PUSH
85095: FOR_TO
85096: IFFALSE 85293
// begin if building in mc_construct_list [ i ] then
85098: LD_VAR 0 1
85102: PUSH
85103: LD_EXP 67
85107: PUSH
85108: LD_VAR 0 3
85112: ARRAY
85113: IN
85114: IFFALSE 85291
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85116: LD_ADDR_EXP 67
85120: PUSH
85121: LD_EXP 67
85125: PPUSH
85126: LD_VAR 0 3
85130: PPUSH
85131: LD_EXP 67
85135: PUSH
85136: LD_VAR 0 3
85140: ARRAY
85141: PUSH
85142: LD_VAR 0 1
85146: DIFF
85147: PPUSH
85148: CALL_OW 1
85152: ST_TO_ADDR
// if building in mc_lab [ i ] then
85153: LD_VAR 0 1
85157: PUSH
85158: LD_EXP 93
85162: PUSH
85163: LD_VAR 0 3
85167: ARRAY
85168: IN
85169: IFFALSE 85224
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
85171: LD_ADDR_EXP 94
85175: PUSH
85176: LD_EXP 94
85180: PPUSH
85181: LD_VAR 0 3
85185: PPUSH
85186: LD_EXP 94
85190: PUSH
85191: LD_VAR 0 3
85195: ARRAY
85196: PPUSH
85197: LD_INT 1
85199: PPUSH
85200: LD_EXP 94
85204: PUSH
85205: LD_VAR 0 3
85209: ARRAY
85210: PPUSH
85211: LD_INT 0
85213: PPUSH
85214: CALL 19409 0 4
85218: PPUSH
85219: CALL_OW 1
85223: ST_TO_ADDR
// if not building in mc_bases [ i ] then
85224: LD_VAR 0 1
85228: PUSH
85229: LD_EXP 60
85233: PUSH
85234: LD_VAR 0 3
85238: ARRAY
85239: IN
85240: NOT
85241: IFFALSE 85287
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85243: LD_ADDR_EXP 60
85247: PUSH
85248: LD_EXP 60
85252: PPUSH
85253: LD_VAR 0 3
85257: PUSH
85258: LD_EXP 60
85262: PUSH
85263: LD_VAR 0 3
85267: ARRAY
85268: PUSH
85269: LD_INT 1
85271: PLUS
85272: PUSH
85273: EMPTY
85274: LIST
85275: LIST
85276: PPUSH
85277: LD_VAR 0 1
85281: PPUSH
85282: CALL 19991 0 3
85286: ST_TO_ADDR
// exit ;
85287: POP
85288: POP
85289: GO 85295
// end ; end ;
85291: GO 85095
85293: POP
85294: POP
// end ;
85295: LD_VAR 0 2
85299: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
85300: LD_INT 0
85302: PPUSH
85303: PPUSH
85304: PPUSH
85305: PPUSH
85306: PPUSH
85307: PPUSH
85308: PPUSH
// if not mc_bases or not skirmish then
85309: LD_EXP 60
85313: NOT
85314: PUSH
85315: LD_EXP 58
85319: NOT
85320: OR
85321: IFFALSE 85325
// exit ;
85323: GO 85986
// for i = 1 to mc_bases do
85325: LD_ADDR_VAR 0 3
85329: PUSH
85330: DOUBLE
85331: LD_INT 1
85333: DEC
85334: ST_TO_ADDR
85335: LD_EXP 60
85339: PUSH
85340: FOR_TO
85341: IFFALSE 85984
// begin if building in mc_construct_list [ i ] then
85343: LD_VAR 0 1
85347: PUSH
85348: LD_EXP 67
85352: PUSH
85353: LD_VAR 0 3
85357: ARRAY
85358: IN
85359: IFFALSE 85982
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85361: LD_ADDR_EXP 67
85365: PUSH
85366: LD_EXP 67
85370: PPUSH
85371: LD_VAR 0 3
85375: PPUSH
85376: LD_EXP 67
85380: PUSH
85381: LD_VAR 0 3
85385: ARRAY
85386: PUSH
85387: LD_VAR 0 1
85391: DIFF
85392: PPUSH
85393: CALL_OW 1
85397: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85398: LD_ADDR_EXP 60
85402: PUSH
85403: LD_EXP 60
85407: PPUSH
85408: LD_VAR 0 3
85412: PUSH
85413: LD_EXP 60
85417: PUSH
85418: LD_VAR 0 3
85422: ARRAY
85423: PUSH
85424: LD_INT 1
85426: PLUS
85427: PUSH
85428: EMPTY
85429: LIST
85430: LIST
85431: PPUSH
85432: LD_VAR 0 1
85436: PPUSH
85437: CALL 19991 0 3
85441: ST_TO_ADDR
// btype := GetBType ( building ) ;
85442: LD_ADDR_VAR 0 5
85446: PUSH
85447: LD_VAR 0 1
85451: PPUSH
85452: CALL_OW 266
85456: ST_TO_ADDR
// side := GetSide ( building ) ;
85457: LD_ADDR_VAR 0 8
85461: PUSH
85462: LD_VAR 0 1
85466: PPUSH
85467: CALL_OW 255
85471: ST_TO_ADDR
// if btype = b_lab then
85472: LD_VAR 0 5
85476: PUSH
85477: LD_INT 6
85479: EQUAL
85480: IFFALSE 85530
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
85482: LD_ADDR_EXP 93
85486: PUSH
85487: LD_EXP 93
85491: PPUSH
85492: LD_VAR 0 3
85496: PUSH
85497: LD_EXP 93
85501: PUSH
85502: LD_VAR 0 3
85506: ARRAY
85507: PUSH
85508: LD_INT 1
85510: PLUS
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: PPUSH
85516: LD_VAR 0 1
85520: PPUSH
85521: CALL 19991 0 3
85525: ST_TO_ADDR
// exit ;
85526: POP
85527: POP
85528: GO 85986
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
85530: LD_VAR 0 5
85534: PUSH
85535: LD_INT 0
85537: PUSH
85538: LD_INT 2
85540: PUSH
85541: LD_INT 4
85543: PUSH
85544: EMPTY
85545: LIST
85546: LIST
85547: LIST
85548: IN
85549: IFFALSE 85673
// begin if btype = b_armoury then
85551: LD_VAR 0 5
85555: PUSH
85556: LD_INT 4
85558: EQUAL
85559: IFFALSE 85569
// btype := b_barracks ;
85561: LD_ADDR_VAR 0 5
85565: PUSH
85566: LD_INT 5
85568: ST_TO_ADDR
// if btype = b_depot then
85569: LD_VAR 0 5
85573: PUSH
85574: LD_INT 0
85576: EQUAL
85577: IFFALSE 85587
// btype := b_warehouse ;
85579: LD_ADDR_VAR 0 5
85583: PUSH
85584: LD_INT 1
85586: ST_TO_ADDR
// if btype = b_workshop then
85587: LD_VAR 0 5
85591: PUSH
85592: LD_INT 2
85594: EQUAL
85595: IFFALSE 85605
// btype := b_factory ;
85597: LD_ADDR_VAR 0 5
85601: PUSH
85602: LD_INT 3
85604: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
85605: LD_VAR 0 5
85609: PPUSH
85610: LD_VAR 0 8
85614: PPUSH
85615: CALL_OW 323
85619: PUSH
85620: LD_INT 1
85622: EQUAL
85623: IFFALSE 85669
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
85625: LD_ADDR_EXP 92
85629: PUSH
85630: LD_EXP 92
85634: PPUSH
85635: LD_VAR 0 3
85639: PUSH
85640: LD_EXP 92
85644: PUSH
85645: LD_VAR 0 3
85649: ARRAY
85650: PUSH
85651: LD_INT 1
85653: PLUS
85654: PUSH
85655: EMPTY
85656: LIST
85657: LIST
85658: PPUSH
85659: LD_VAR 0 1
85663: PPUSH
85664: CALL 19991 0 3
85668: ST_TO_ADDR
// exit ;
85669: POP
85670: POP
85671: GO 85986
// end ; if btype in [ b_bunker , b_turret ] then
85673: LD_VAR 0 5
85677: PUSH
85678: LD_INT 32
85680: PUSH
85681: LD_INT 33
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: IN
85688: IFFALSE 85978
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
85690: LD_ADDR_EXP 68
85694: PUSH
85695: LD_EXP 68
85699: PPUSH
85700: LD_VAR 0 3
85704: PUSH
85705: LD_EXP 68
85709: PUSH
85710: LD_VAR 0 3
85714: ARRAY
85715: PUSH
85716: LD_INT 1
85718: PLUS
85719: PUSH
85720: EMPTY
85721: LIST
85722: LIST
85723: PPUSH
85724: LD_VAR 0 1
85728: PPUSH
85729: CALL 19991 0 3
85733: ST_TO_ADDR
// if btype = b_bunker then
85734: LD_VAR 0 5
85738: PUSH
85739: LD_INT 32
85741: EQUAL
85742: IFFALSE 85978
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85744: LD_ADDR_EXP 69
85748: PUSH
85749: LD_EXP 69
85753: PPUSH
85754: LD_VAR 0 3
85758: PUSH
85759: LD_EXP 69
85763: PUSH
85764: LD_VAR 0 3
85768: ARRAY
85769: PUSH
85770: LD_INT 1
85772: PLUS
85773: PUSH
85774: EMPTY
85775: LIST
85776: LIST
85777: PPUSH
85778: LD_VAR 0 1
85782: PPUSH
85783: CALL 19991 0 3
85787: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
85788: LD_ADDR_VAR 0 6
85792: PUSH
85793: LD_EXP 60
85797: PUSH
85798: LD_VAR 0 3
85802: ARRAY
85803: PPUSH
85804: LD_INT 25
85806: PUSH
85807: LD_INT 1
85809: PUSH
85810: EMPTY
85811: LIST
85812: LIST
85813: PUSH
85814: LD_INT 3
85816: PUSH
85817: LD_INT 54
85819: PUSH
85820: EMPTY
85821: LIST
85822: PUSH
85823: EMPTY
85824: LIST
85825: LIST
85826: PUSH
85827: EMPTY
85828: LIST
85829: LIST
85830: PPUSH
85831: CALL_OW 72
85835: ST_TO_ADDR
// if tmp then
85836: LD_VAR 0 6
85840: IFFALSE 85846
// exit ;
85842: POP
85843: POP
85844: GO 85986
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
85846: LD_ADDR_VAR 0 6
85850: PUSH
85851: LD_EXP 60
85855: PUSH
85856: LD_VAR 0 3
85860: ARRAY
85861: PPUSH
85862: LD_INT 2
85864: PUSH
85865: LD_INT 30
85867: PUSH
85868: LD_INT 4
85870: PUSH
85871: EMPTY
85872: LIST
85873: LIST
85874: PUSH
85875: LD_INT 30
85877: PUSH
85878: LD_INT 5
85880: PUSH
85881: EMPTY
85882: LIST
85883: LIST
85884: PUSH
85885: EMPTY
85886: LIST
85887: LIST
85888: LIST
85889: PPUSH
85890: CALL_OW 72
85894: ST_TO_ADDR
// if not tmp then
85895: LD_VAR 0 6
85899: NOT
85900: IFFALSE 85906
// exit ;
85902: POP
85903: POP
85904: GO 85986
// for j in tmp do
85906: LD_ADDR_VAR 0 4
85910: PUSH
85911: LD_VAR 0 6
85915: PUSH
85916: FOR_IN
85917: IFFALSE 85976
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
85919: LD_ADDR_VAR 0 7
85923: PUSH
85924: LD_VAR 0 4
85928: PPUSH
85929: CALL_OW 313
85933: PPUSH
85934: LD_INT 25
85936: PUSH
85937: LD_INT 1
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PPUSH
85944: CALL_OW 72
85948: ST_TO_ADDR
// if units then
85949: LD_VAR 0 7
85953: IFFALSE 85974
// begin ComExitBuilding ( units [ 1 ] ) ;
85955: LD_VAR 0 7
85959: PUSH
85960: LD_INT 1
85962: ARRAY
85963: PPUSH
85964: CALL_OW 122
// exit ;
85968: POP
85969: POP
85970: POP
85971: POP
85972: GO 85986
// end ; end ;
85974: GO 85916
85976: POP
85977: POP
// end ; end ; exit ;
85978: POP
85979: POP
85980: GO 85986
// end ; end ;
85982: GO 85340
85984: POP
85985: POP
// end ;
85986: LD_VAR 0 2
85990: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
85991: LD_INT 0
85993: PPUSH
85994: PPUSH
85995: PPUSH
85996: PPUSH
85997: PPUSH
85998: PPUSH
85999: PPUSH
// if not mc_bases or not skirmish then
86000: LD_EXP 60
86004: NOT
86005: PUSH
86006: LD_EXP 58
86010: NOT
86011: OR
86012: IFFALSE 86016
// exit ;
86014: GO 86281
// btype := GetBType ( building ) ;
86016: LD_ADDR_VAR 0 6
86020: PUSH
86021: LD_VAR 0 1
86025: PPUSH
86026: CALL_OW 266
86030: ST_TO_ADDR
// x := GetX ( building ) ;
86031: LD_ADDR_VAR 0 7
86035: PUSH
86036: LD_VAR 0 1
86040: PPUSH
86041: CALL_OW 250
86045: ST_TO_ADDR
// y := GetY ( building ) ;
86046: LD_ADDR_VAR 0 8
86050: PUSH
86051: LD_VAR 0 1
86055: PPUSH
86056: CALL_OW 251
86060: ST_TO_ADDR
// d := GetDir ( building ) ;
86061: LD_ADDR_VAR 0 9
86065: PUSH
86066: LD_VAR 0 1
86070: PPUSH
86071: CALL_OW 254
86075: ST_TO_ADDR
// for i = 1 to mc_bases do
86076: LD_ADDR_VAR 0 4
86080: PUSH
86081: DOUBLE
86082: LD_INT 1
86084: DEC
86085: ST_TO_ADDR
86086: LD_EXP 60
86090: PUSH
86091: FOR_TO
86092: IFFALSE 86279
// begin if not mc_build_list [ i ] then
86094: LD_EXP 65
86098: PUSH
86099: LD_VAR 0 4
86103: ARRAY
86104: NOT
86105: IFFALSE 86109
// continue ;
86107: GO 86091
// for j := 1 to mc_build_list [ i ] do
86109: LD_ADDR_VAR 0 5
86113: PUSH
86114: DOUBLE
86115: LD_INT 1
86117: DEC
86118: ST_TO_ADDR
86119: LD_EXP 65
86123: PUSH
86124: LD_VAR 0 4
86128: ARRAY
86129: PUSH
86130: FOR_TO
86131: IFFALSE 86275
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
86133: LD_VAR 0 6
86137: PUSH
86138: LD_VAR 0 7
86142: PUSH
86143: LD_VAR 0 8
86147: PUSH
86148: LD_VAR 0 9
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: PPUSH
86159: LD_EXP 65
86163: PUSH
86164: LD_VAR 0 4
86168: ARRAY
86169: PUSH
86170: LD_VAR 0 5
86174: ARRAY
86175: PPUSH
86176: CALL 26171 0 2
86180: IFFALSE 86273
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
86182: LD_ADDR_EXP 65
86186: PUSH
86187: LD_EXP 65
86191: PPUSH
86192: LD_VAR 0 4
86196: PPUSH
86197: LD_EXP 65
86201: PUSH
86202: LD_VAR 0 4
86206: ARRAY
86207: PPUSH
86208: LD_VAR 0 5
86212: PPUSH
86213: CALL_OW 3
86217: PPUSH
86218: CALL_OW 1
86222: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
86223: LD_ADDR_EXP 67
86227: PUSH
86228: LD_EXP 67
86232: PPUSH
86233: LD_VAR 0 4
86237: PUSH
86238: LD_EXP 67
86242: PUSH
86243: LD_VAR 0 4
86247: ARRAY
86248: PUSH
86249: LD_INT 1
86251: PLUS
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PPUSH
86257: LD_VAR 0 1
86261: PPUSH
86262: CALL 19991 0 3
86266: ST_TO_ADDR
// exit ;
86267: POP
86268: POP
86269: POP
86270: POP
86271: GO 86281
// end ;
86273: GO 86130
86275: POP
86276: POP
// end ;
86277: GO 86091
86279: POP
86280: POP
// end ;
86281: LD_VAR 0 3
86285: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
86286: LD_INT 0
86288: PPUSH
86289: PPUSH
86290: PPUSH
// if not mc_bases or not skirmish then
86291: LD_EXP 60
86295: NOT
86296: PUSH
86297: LD_EXP 58
86301: NOT
86302: OR
86303: IFFALSE 86307
// exit ;
86305: GO 86497
// for i = 1 to mc_bases do
86307: LD_ADDR_VAR 0 4
86311: PUSH
86312: DOUBLE
86313: LD_INT 1
86315: DEC
86316: ST_TO_ADDR
86317: LD_EXP 60
86321: PUSH
86322: FOR_TO
86323: IFFALSE 86410
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
86325: LD_VAR 0 1
86329: PUSH
86330: LD_EXP 68
86334: PUSH
86335: LD_VAR 0 4
86339: ARRAY
86340: IN
86341: PUSH
86342: LD_VAR 0 1
86346: PUSH
86347: LD_EXP 69
86351: PUSH
86352: LD_VAR 0 4
86356: ARRAY
86357: IN
86358: NOT
86359: AND
86360: IFFALSE 86408
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86362: LD_ADDR_EXP 69
86366: PUSH
86367: LD_EXP 69
86371: PPUSH
86372: LD_VAR 0 4
86376: PUSH
86377: LD_EXP 69
86381: PUSH
86382: LD_VAR 0 4
86386: ARRAY
86387: PUSH
86388: LD_INT 1
86390: PLUS
86391: PUSH
86392: EMPTY
86393: LIST
86394: LIST
86395: PPUSH
86396: LD_VAR 0 1
86400: PPUSH
86401: CALL 19991 0 3
86405: ST_TO_ADDR
// break ;
86406: GO 86410
// end ; end ;
86408: GO 86322
86410: POP
86411: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
86412: LD_VAR 0 1
86416: PPUSH
86417: CALL_OW 257
86421: PUSH
86422: LD_EXP 86
86426: IN
86427: PUSH
86428: LD_VAR 0 1
86432: PPUSH
86433: CALL_OW 266
86437: PUSH
86438: LD_INT 5
86440: EQUAL
86441: AND
86442: PUSH
86443: LD_VAR 0 2
86447: PPUSH
86448: CALL_OW 110
86452: PUSH
86453: LD_INT 18
86455: NONEQUAL
86456: AND
86457: IFFALSE 86497
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
86459: LD_VAR 0 2
86463: PPUSH
86464: CALL_OW 257
86468: PUSH
86469: LD_INT 5
86471: PUSH
86472: LD_INT 8
86474: PUSH
86475: LD_INT 9
86477: PUSH
86478: EMPTY
86479: LIST
86480: LIST
86481: LIST
86482: IN
86483: IFFALSE 86497
// SetClass ( unit , 1 ) ;
86485: LD_VAR 0 2
86489: PPUSH
86490: LD_INT 1
86492: PPUSH
86493: CALL_OW 336
// end ;
86497: LD_VAR 0 3
86501: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
86502: LD_INT 0
86504: PPUSH
86505: PPUSH
// if not mc_bases or not skirmish then
86506: LD_EXP 60
86510: NOT
86511: PUSH
86512: LD_EXP 58
86516: NOT
86517: OR
86518: IFFALSE 86522
// exit ;
86520: GO 86638
// if GetLives ( abandoned_vehicle ) > 250 then
86522: LD_VAR 0 2
86526: PPUSH
86527: CALL_OW 256
86531: PUSH
86532: LD_INT 250
86534: GREATER
86535: IFFALSE 86539
// exit ;
86537: GO 86638
// for i = 1 to mc_bases do
86539: LD_ADDR_VAR 0 6
86543: PUSH
86544: DOUBLE
86545: LD_INT 1
86547: DEC
86548: ST_TO_ADDR
86549: LD_EXP 60
86553: PUSH
86554: FOR_TO
86555: IFFALSE 86636
// begin if driver in mc_bases [ i ] then
86557: LD_VAR 0 1
86561: PUSH
86562: LD_EXP 60
86566: PUSH
86567: LD_VAR 0 6
86571: ARRAY
86572: IN
86573: IFFALSE 86634
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
86575: LD_VAR 0 1
86579: PPUSH
86580: LD_EXP 60
86584: PUSH
86585: LD_VAR 0 6
86589: ARRAY
86590: PPUSH
86591: LD_INT 2
86593: PUSH
86594: LD_INT 30
86596: PUSH
86597: LD_INT 0
86599: PUSH
86600: EMPTY
86601: LIST
86602: LIST
86603: PUSH
86604: LD_INT 30
86606: PUSH
86607: LD_INT 1
86609: PUSH
86610: EMPTY
86611: LIST
86612: LIST
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: LIST
86618: PPUSH
86619: CALL_OW 72
86623: PUSH
86624: LD_INT 1
86626: ARRAY
86627: PPUSH
86628: CALL 53107 0 2
// break ;
86632: GO 86636
// end ; end ;
86634: GO 86554
86636: POP
86637: POP
// end ; end_of_file end_of_file
86638: LD_VAR 0 5
86642: RET
// every 0 0$1 do
86643: GO 86645
86645: DISABLE
// begin enable ;
86646: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
86647: LD_STRING updateTimer(
86649: PUSH
86650: LD_OWVAR 1
86654: STR
86655: PUSH
86656: LD_STRING );
86658: STR
86659: PPUSH
86660: CALL_OW 559
// end ;
86664: END
// export function SOS_MapStart ( ) ; begin
86665: LD_INT 0
86667: PPUSH
// if streamModeActive then
86668: LD_EXP 104
86672: IFFALSE 86681
// DefineStreamItems ( true ) ;
86674: LD_INT 1
86676: PPUSH
86677: CALL 88335 0 1
// UpdateFactoryWaypoints ( ) ;
86681: CALL 101196 0 0
// UpdateWarehouseGatheringPoints ( ) ;
86685: CALL 101453 0 0
// end ;
86689: LD_VAR 0 1
86693: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
86694: LD_INT 0
86696: PPUSH
// if p2 = 100 then
86697: LD_VAR 0 2
86701: PUSH
86702: LD_INT 100
86704: EQUAL
86705: IFFALSE 87708
// begin if not StreamModeActive then
86707: LD_EXP 104
86711: NOT
86712: IFFALSE 86722
// StreamModeActive := true ;
86714: LD_ADDR_EXP 104
86718: PUSH
86719: LD_INT 1
86721: ST_TO_ADDR
// if p3 = 0 then
86722: LD_VAR 0 3
86726: PUSH
86727: LD_INT 0
86729: EQUAL
86730: IFFALSE 86736
// InitStreamMode ;
86732: CALL 87871 0 0
// if p3 = 1 then
86736: LD_VAR 0 3
86740: PUSH
86741: LD_INT 1
86743: EQUAL
86744: IFFALSE 86754
// sRocket := true ;
86746: LD_ADDR_EXP 109
86750: PUSH
86751: LD_INT 1
86753: ST_TO_ADDR
// if p3 = 2 then
86754: LD_VAR 0 3
86758: PUSH
86759: LD_INT 2
86761: EQUAL
86762: IFFALSE 86772
// sSpeed := true ;
86764: LD_ADDR_EXP 108
86768: PUSH
86769: LD_INT 1
86771: ST_TO_ADDR
// if p3 = 3 then
86772: LD_VAR 0 3
86776: PUSH
86777: LD_INT 3
86779: EQUAL
86780: IFFALSE 86790
// sEngine := true ;
86782: LD_ADDR_EXP 110
86786: PUSH
86787: LD_INT 1
86789: ST_TO_ADDR
// if p3 = 4 then
86790: LD_VAR 0 3
86794: PUSH
86795: LD_INT 4
86797: EQUAL
86798: IFFALSE 86808
// sSpec := true ;
86800: LD_ADDR_EXP 107
86804: PUSH
86805: LD_INT 1
86807: ST_TO_ADDR
// if p3 = 5 then
86808: LD_VAR 0 3
86812: PUSH
86813: LD_INT 5
86815: EQUAL
86816: IFFALSE 86826
// sLevel := true ;
86818: LD_ADDR_EXP 111
86822: PUSH
86823: LD_INT 1
86825: ST_TO_ADDR
// if p3 = 6 then
86826: LD_VAR 0 3
86830: PUSH
86831: LD_INT 6
86833: EQUAL
86834: IFFALSE 86844
// sArmoury := true ;
86836: LD_ADDR_EXP 112
86840: PUSH
86841: LD_INT 1
86843: ST_TO_ADDR
// if p3 = 7 then
86844: LD_VAR 0 3
86848: PUSH
86849: LD_INT 7
86851: EQUAL
86852: IFFALSE 86862
// sRadar := true ;
86854: LD_ADDR_EXP 113
86858: PUSH
86859: LD_INT 1
86861: ST_TO_ADDR
// if p3 = 8 then
86862: LD_VAR 0 3
86866: PUSH
86867: LD_INT 8
86869: EQUAL
86870: IFFALSE 86880
// sBunker := true ;
86872: LD_ADDR_EXP 114
86876: PUSH
86877: LD_INT 1
86879: ST_TO_ADDR
// if p3 = 9 then
86880: LD_VAR 0 3
86884: PUSH
86885: LD_INT 9
86887: EQUAL
86888: IFFALSE 86898
// sHack := true ;
86890: LD_ADDR_EXP 115
86894: PUSH
86895: LD_INT 1
86897: ST_TO_ADDR
// if p3 = 10 then
86898: LD_VAR 0 3
86902: PUSH
86903: LD_INT 10
86905: EQUAL
86906: IFFALSE 86916
// sFire := true ;
86908: LD_ADDR_EXP 116
86912: PUSH
86913: LD_INT 1
86915: ST_TO_ADDR
// if p3 = 11 then
86916: LD_VAR 0 3
86920: PUSH
86921: LD_INT 11
86923: EQUAL
86924: IFFALSE 86934
// sRefresh := true ;
86926: LD_ADDR_EXP 117
86930: PUSH
86931: LD_INT 1
86933: ST_TO_ADDR
// if p3 = 12 then
86934: LD_VAR 0 3
86938: PUSH
86939: LD_INT 12
86941: EQUAL
86942: IFFALSE 86952
// sExp := true ;
86944: LD_ADDR_EXP 118
86948: PUSH
86949: LD_INT 1
86951: ST_TO_ADDR
// if p3 = 13 then
86952: LD_VAR 0 3
86956: PUSH
86957: LD_INT 13
86959: EQUAL
86960: IFFALSE 86970
// sDepot := true ;
86962: LD_ADDR_EXP 119
86966: PUSH
86967: LD_INT 1
86969: ST_TO_ADDR
// if p3 = 14 then
86970: LD_VAR 0 3
86974: PUSH
86975: LD_INT 14
86977: EQUAL
86978: IFFALSE 86988
// sFlag := true ;
86980: LD_ADDR_EXP 120
86984: PUSH
86985: LD_INT 1
86987: ST_TO_ADDR
// if p3 = 15 then
86988: LD_VAR 0 3
86992: PUSH
86993: LD_INT 15
86995: EQUAL
86996: IFFALSE 87006
// sKamikadze := true ;
86998: LD_ADDR_EXP 128
87002: PUSH
87003: LD_INT 1
87005: ST_TO_ADDR
// if p3 = 16 then
87006: LD_VAR 0 3
87010: PUSH
87011: LD_INT 16
87013: EQUAL
87014: IFFALSE 87024
// sTroll := true ;
87016: LD_ADDR_EXP 129
87020: PUSH
87021: LD_INT 1
87023: ST_TO_ADDR
// if p3 = 17 then
87024: LD_VAR 0 3
87028: PUSH
87029: LD_INT 17
87031: EQUAL
87032: IFFALSE 87042
// sSlow := true ;
87034: LD_ADDR_EXP 130
87038: PUSH
87039: LD_INT 1
87041: ST_TO_ADDR
// if p3 = 18 then
87042: LD_VAR 0 3
87046: PUSH
87047: LD_INT 18
87049: EQUAL
87050: IFFALSE 87060
// sLack := true ;
87052: LD_ADDR_EXP 131
87056: PUSH
87057: LD_INT 1
87059: ST_TO_ADDR
// if p3 = 19 then
87060: LD_VAR 0 3
87064: PUSH
87065: LD_INT 19
87067: EQUAL
87068: IFFALSE 87078
// sTank := true ;
87070: LD_ADDR_EXP 133
87074: PUSH
87075: LD_INT 1
87077: ST_TO_ADDR
// if p3 = 20 then
87078: LD_VAR 0 3
87082: PUSH
87083: LD_INT 20
87085: EQUAL
87086: IFFALSE 87096
// sRemote := true ;
87088: LD_ADDR_EXP 134
87092: PUSH
87093: LD_INT 1
87095: ST_TO_ADDR
// if p3 = 21 then
87096: LD_VAR 0 3
87100: PUSH
87101: LD_INT 21
87103: EQUAL
87104: IFFALSE 87114
// sPowell := true ;
87106: LD_ADDR_EXP 135
87110: PUSH
87111: LD_INT 1
87113: ST_TO_ADDR
// if p3 = 22 then
87114: LD_VAR 0 3
87118: PUSH
87119: LD_INT 22
87121: EQUAL
87122: IFFALSE 87132
// sTeleport := true ;
87124: LD_ADDR_EXP 138
87128: PUSH
87129: LD_INT 1
87131: ST_TO_ADDR
// if p3 = 23 then
87132: LD_VAR 0 3
87136: PUSH
87137: LD_INT 23
87139: EQUAL
87140: IFFALSE 87150
// sOilTower := true ;
87142: LD_ADDR_EXP 140
87146: PUSH
87147: LD_INT 1
87149: ST_TO_ADDR
// if p3 = 24 then
87150: LD_VAR 0 3
87154: PUSH
87155: LD_INT 24
87157: EQUAL
87158: IFFALSE 87168
// sShovel := true ;
87160: LD_ADDR_EXP 141
87164: PUSH
87165: LD_INT 1
87167: ST_TO_ADDR
// if p3 = 25 then
87168: LD_VAR 0 3
87172: PUSH
87173: LD_INT 25
87175: EQUAL
87176: IFFALSE 87186
// sSheik := true ;
87178: LD_ADDR_EXP 142
87182: PUSH
87183: LD_INT 1
87185: ST_TO_ADDR
// if p3 = 26 then
87186: LD_VAR 0 3
87190: PUSH
87191: LD_INT 26
87193: EQUAL
87194: IFFALSE 87204
// sEarthquake := true ;
87196: LD_ADDR_EXP 144
87200: PUSH
87201: LD_INT 1
87203: ST_TO_ADDR
// if p3 = 27 then
87204: LD_VAR 0 3
87208: PUSH
87209: LD_INT 27
87211: EQUAL
87212: IFFALSE 87222
// sAI := true ;
87214: LD_ADDR_EXP 145
87218: PUSH
87219: LD_INT 1
87221: ST_TO_ADDR
// if p3 = 28 then
87222: LD_VAR 0 3
87226: PUSH
87227: LD_INT 28
87229: EQUAL
87230: IFFALSE 87240
// sCargo := true ;
87232: LD_ADDR_EXP 148
87236: PUSH
87237: LD_INT 1
87239: ST_TO_ADDR
// if p3 = 29 then
87240: LD_VAR 0 3
87244: PUSH
87245: LD_INT 29
87247: EQUAL
87248: IFFALSE 87258
// sDLaser := true ;
87250: LD_ADDR_EXP 149
87254: PUSH
87255: LD_INT 1
87257: ST_TO_ADDR
// if p3 = 30 then
87258: LD_VAR 0 3
87262: PUSH
87263: LD_INT 30
87265: EQUAL
87266: IFFALSE 87276
// sExchange := true ;
87268: LD_ADDR_EXP 150
87272: PUSH
87273: LD_INT 1
87275: ST_TO_ADDR
// if p3 = 31 then
87276: LD_VAR 0 3
87280: PUSH
87281: LD_INT 31
87283: EQUAL
87284: IFFALSE 87294
// sFac := true ;
87286: LD_ADDR_EXP 151
87290: PUSH
87291: LD_INT 1
87293: ST_TO_ADDR
// if p3 = 32 then
87294: LD_VAR 0 3
87298: PUSH
87299: LD_INT 32
87301: EQUAL
87302: IFFALSE 87312
// sPower := true ;
87304: LD_ADDR_EXP 152
87308: PUSH
87309: LD_INT 1
87311: ST_TO_ADDR
// if p3 = 33 then
87312: LD_VAR 0 3
87316: PUSH
87317: LD_INT 33
87319: EQUAL
87320: IFFALSE 87330
// sRandom := true ;
87322: LD_ADDR_EXP 153
87326: PUSH
87327: LD_INT 1
87329: ST_TO_ADDR
// if p3 = 34 then
87330: LD_VAR 0 3
87334: PUSH
87335: LD_INT 34
87337: EQUAL
87338: IFFALSE 87348
// sShield := true ;
87340: LD_ADDR_EXP 154
87344: PUSH
87345: LD_INT 1
87347: ST_TO_ADDR
// if p3 = 35 then
87348: LD_VAR 0 3
87352: PUSH
87353: LD_INT 35
87355: EQUAL
87356: IFFALSE 87366
// sTime := true ;
87358: LD_ADDR_EXP 155
87362: PUSH
87363: LD_INT 1
87365: ST_TO_ADDR
// if p3 = 36 then
87366: LD_VAR 0 3
87370: PUSH
87371: LD_INT 36
87373: EQUAL
87374: IFFALSE 87384
// sTools := true ;
87376: LD_ADDR_EXP 156
87380: PUSH
87381: LD_INT 1
87383: ST_TO_ADDR
// if p3 = 101 then
87384: LD_VAR 0 3
87388: PUSH
87389: LD_INT 101
87391: EQUAL
87392: IFFALSE 87402
// sSold := true ;
87394: LD_ADDR_EXP 121
87398: PUSH
87399: LD_INT 1
87401: ST_TO_ADDR
// if p3 = 102 then
87402: LD_VAR 0 3
87406: PUSH
87407: LD_INT 102
87409: EQUAL
87410: IFFALSE 87420
// sDiff := true ;
87412: LD_ADDR_EXP 122
87416: PUSH
87417: LD_INT 1
87419: ST_TO_ADDR
// if p3 = 103 then
87420: LD_VAR 0 3
87424: PUSH
87425: LD_INT 103
87427: EQUAL
87428: IFFALSE 87438
// sFog := true ;
87430: LD_ADDR_EXP 125
87434: PUSH
87435: LD_INT 1
87437: ST_TO_ADDR
// if p3 = 104 then
87438: LD_VAR 0 3
87442: PUSH
87443: LD_INT 104
87445: EQUAL
87446: IFFALSE 87456
// sReset := true ;
87448: LD_ADDR_EXP 126
87452: PUSH
87453: LD_INT 1
87455: ST_TO_ADDR
// if p3 = 105 then
87456: LD_VAR 0 3
87460: PUSH
87461: LD_INT 105
87463: EQUAL
87464: IFFALSE 87474
// sSun := true ;
87466: LD_ADDR_EXP 127
87470: PUSH
87471: LD_INT 1
87473: ST_TO_ADDR
// if p3 = 106 then
87474: LD_VAR 0 3
87478: PUSH
87479: LD_INT 106
87481: EQUAL
87482: IFFALSE 87492
// sTiger := true ;
87484: LD_ADDR_EXP 123
87488: PUSH
87489: LD_INT 1
87491: ST_TO_ADDR
// if p3 = 107 then
87492: LD_VAR 0 3
87496: PUSH
87497: LD_INT 107
87499: EQUAL
87500: IFFALSE 87510
// sBomb := true ;
87502: LD_ADDR_EXP 124
87506: PUSH
87507: LD_INT 1
87509: ST_TO_ADDR
// if p3 = 108 then
87510: LD_VAR 0 3
87514: PUSH
87515: LD_INT 108
87517: EQUAL
87518: IFFALSE 87528
// sWound := true ;
87520: LD_ADDR_EXP 132
87524: PUSH
87525: LD_INT 1
87527: ST_TO_ADDR
// if p3 = 109 then
87528: LD_VAR 0 3
87532: PUSH
87533: LD_INT 109
87535: EQUAL
87536: IFFALSE 87546
// sBetray := true ;
87538: LD_ADDR_EXP 136
87542: PUSH
87543: LD_INT 1
87545: ST_TO_ADDR
// if p3 = 110 then
87546: LD_VAR 0 3
87550: PUSH
87551: LD_INT 110
87553: EQUAL
87554: IFFALSE 87564
// sContamin := true ;
87556: LD_ADDR_EXP 137
87560: PUSH
87561: LD_INT 1
87563: ST_TO_ADDR
// if p3 = 111 then
87564: LD_VAR 0 3
87568: PUSH
87569: LD_INT 111
87571: EQUAL
87572: IFFALSE 87582
// sOil := true ;
87574: LD_ADDR_EXP 139
87578: PUSH
87579: LD_INT 1
87581: ST_TO_ADDR
// if p3 = 112 then
87582: LD_VAR 0 3
87586: PUSH
87587: LD_INT 112
87589: EQUAL
87590: IFFALSE 87600
// sStu := true ;
87592: LD_ADDR_EXP 143
87596: PUSH
87597: LD_INT 1
87599: ST_TO_ADDR
// if p3 = 113 then
87600: LD_VAR 0 3
87604: PUSH
87605: LD_INT 113
87607: EQUAL
87608: IFFALSE 87618
// sBazooka := true ;
87610: LD_ADDR_EXP 146
87614: PUSH
87615: LD_INT 1
87617: ST_TO_ADDR
// if p3 = 114 then
87618: LD_VAR 0 3
87622: PUSH
87623: LD_INT 114
87625: EQUAL
87626: IFFALSE 87636
// sMortar := true ;
87628: LD_ADDR_EXP 147
87632: PUSH
87633: LD_INT 1
87635: ST_TO_ADDR
// if p3 = 115 then
87636: LD_VAR 0 3
87640: PUSH
87641: LD_INT 115
87643: EQUAL
87644: IFFALSE 87654
// sRanger := true ;
87646: LD_ADDR_EXP 157
87650: PUSH
87651: LD_INT 1
87653: ST_TO_ADDR
// if p3 = 116 then
87654: LD_VAR 0 3
87658: PUSH
87659: LD_INT 116
87661: EQUAL
87662: IFFALSE 87672
// sComputer := true ;
87664: LD_ADDR_EXP 158
87668: PUSH
87669: LD_INT 1
87671: ST_TO_ADDR
// if p3 = 117 then
87672: LD_VAR 0 3
87676: PUSH
87677: LD_INT 117
87679: EQUAL
87680: IFFALSE 87690
// s30 := true ;
87682: LD_ADDR_EXP 159
87686: PUSH
87687: LD_INT 1
87689: ST_TO_ADDR
// if p3 = 118 then
87690: LD_VAR 0 3
87694: PUSH
87695: LD_INT 118
87697: EQUAL
87698: IFFALSE 87708
// s60 := true ;
87700: LD_ADDR_EXP 160
87704: PUSH
87705: LD_INT 1
87707: ST_TO_ADDR
// end ; if p2 = 101 then
87708: LD_VAR 0 2
87712: PUSH
87713: LD_INT 101
87715: EQUAL
87716: IFFALSE 87844
// begin case p3 of 1 :
87718: LD_VAR 0 3
87722: PUSH
87723: LD_INT 1
87725: DOUBLE
87726: EQUAL
87727: IFTRUE 87731
87729: GO 87738
87731: POP
// hHackUnlimitedResources ; 2 :
87732: CALL 99942 0 0
87736: GO 87844
87738: LD_INT 2
87740: DOUBLE
87741: EQUAL
87742: IFTRUE 87746
87744: GO 87753
87746: POP
// hHackSetLevel10 ; 3 :
87747: CALL 100075 0 0
87751: GO 87844
87753: LD_INT 3
87755: DOUBLE
87756: EQUAL
87757: IFTRUE 87761
87759: GO 87768
87761: POP
// hHackSetLevel10YourUnits ; 4 :
87762: CALL 100160 0 0
87766: GO 87844
87768: LD_INT 4
87770: DOUBLE
87771: EQUAL
87772: IFTRUE 87776
87774: GO 87783
87776: POP
// hHackInvincible ; 5 :
87777: CALL 100608 0 0
87781: GO 87844
87783: LD_INT 5
87785: DOUBLE
87786: EQUAL
87787: IFTRUE 87791
87789: GO 87798
87791: POP
// hHackInvisible ; 6 :
87792: CALL 100719 0 0
87796: GO 87844
87798: LD_INT 6
87800: DOUBLE
87801: EQUAL
87802: IFTRUE 87806
87804: GO 87813
87806: POP
// hHackChangeYourSide ; 7 :
87807: CALL 100776 0 0
87811: GO 87844
87813: LD_INT 7
87815: DOUBLE
87816: EQUAL
87817: IFTRUE 87821
87819: GO 87828
87821: POP
// hHackChangeUnitSide ; 8 :
87822: CALL 100818 0 0
87826: GO 87844
87828: LD_INT 8
87830: DOUBLE
87831: EQUAL
87832: IFTRUE 87836
87834: GO 87843
87836: POP
// hHackFog ; end ;
87837: CALL 100919 0 0
87841: GO 87844
87843: POP
// end ; end ;
87844: LD_VAR 0 7
87848: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
87849: GO 87851
87851: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
87852: LD_STRING initStreamRollete();
87854: PPUSH
87855: CALL_OW 559
// InitStreamMode ;
87859: CALL 87871 0 0
// DefineStreamItems ( false ) ;
87863: LD_INT 0
87865: PPUSH
87866: CALL 88335 0 1
// end ;
87870: END
// function InitStreamMode ; begin
87871: LD_INT 0
87873: PPUSH
// streamModeActive := false ;
87874: LD_ADDR_EXP 104
87878: PUSH
87879: LD_INT 0
87881: ST_TO_ADDR
// normalCounter := 36 ;
87882: LD_ADDR_EXP 105
87886: PUSH
87887: LD_INT 36
87889: ST_TO_ADDR
// hardcoreCounter := 18 ;
87890: LD_ADDR_EXP 106
87894: PUSH
87895: LD_INT 18
87897: ST_TO_ADDR
// sRocket := false ;
87898: LD_ADDR_EXP 109
87902: PUSH
87903: LD_INT 0
87905: ST_TO_ADDR
// sSpeed := false ;
87906: LD_ADDR_EXP 108
87910: PUSH
87911: LD_INT 0
87913: ST_TO_ADDR
// sEngine := false ;
87914: LD_ADDR_EXP 110
87918: PUSH
87919: LD_INT 0
87921: ST_TO_ADDR
// sSpec := false ;
87922: LD_ADDR_EXP 107
87926: PUSH
87927: LD_INT 0
87929: ST_TO_ADDR
// sLevel := false ;
87930: LD_ADDR_EXP 111
87934: PUSH
87935: LD_INT 0
87937: ST_TO_ADDR
// sArmoury := false ;
87938: LD_ADDR_EXP 112
87942: PUSH
87943: LD_INT 0
87945: ST_TO_ADDR
// sRadar := false ;
87946: LD_ADDR_EXP 113
87950: PUSH
87951: LD_INT 0
87953: ST_TO_ADDR
// sBunker := false ;
87954: LD_ADDR_EXP 114
87958: PUSH
87959: LD_INT 0
87961: ST_TO_ADDR
// sHack := false ;
87962: LD_ADDR_EXP 115
87966: PUSH
87967: LD_INT 0
87969: ST_TO_ADDR
// sFire := false ;
87970: LD_ADDR_EXP 116
87974: PUSH
87975: LD_INT 0
87977: ST_TO_ADDR
// sRefresh := false ;
87978: LD_ADDR_EXP 117
87982: PUSH
87983: LD_INT 0
87985: ST_TO_ADDR
// sExp := false ;
87986: LD_ADDR_EXP 118
87990: PUSH
87991: LD_INT 0
87993: ST_TO_ADDR
// sDepot := false ;
87994: LD_ADDR_EXP 119
87998: PUSH
87999: LD_INT 0
88001: ST_TO_ADDR
// sFlag := false ;
88002: LD_ADDR_EXP 120
88006: PUSH
88007: LD_INT 0
88009: ST_TO_ADDR
// sKamikadze := false ;
88010: LD_ADDR_EXP 128
88014: PUSH
88015: LD_INT 0
88017: ST_TO_ADDR
// sTroll := false ;
88018: LD_ADDR_EXP 129
88022: PUSH
88023: LD_INT 0
88025: ST_TO_ADDR
// sSlow := false ;
88026: LD_ADDR_EXP 130
88030: PUSH
88031: LD_INT 0
88033: ST_TO_ADDR
// sLack := false ;
88034: LD_ADDR_EXP 131
88038: PUSH
88039: LD_INT 0
88041: ST_TO_ADDR
// sTank := false ;
88042: LD_ADDR_EXP 133
88046: PUSH
88047: LD_INT 0
88049: ST_TO_ADDR
// sRemote := false ;
88050: LD_ADDR_EXP 134
88054: PUSH
88055: LD_INT 0
88057: ST_TO_ADDR
// sPowell := false ;
88058: LD_ADDR_EXP 135
88062: PUSH
88063: LD_INT 0
88065: ST_TO_ADDR
// sTeleport := false ;
88066: LD_ADDR_EXP 138
88070: PUSH
88071: LD_INT 0
88073: ST_TO_ADDR
// sOilTower := false ;
88074: LD_ADDR_EXP 140
88078: PUSH
88079: LD_INT 0
88081: ST_TO_ADDR
// sShovel := false ;
88082: LD_ADDR_EXP 141
88086: PUSH
88087: LD_INT 0
88089: ST_TO_ADDR
// sSheik := false ;
88090: LD_ADDR_EXP 142
88094: PUSH
88095: LD_INT 0
88097: ST_TO_ADDR
// sEarthquake := false ;
88098: LD_ADDR_EXP 144
88102: PUSH
88103: LD_INT 0
88105: ST_TO_ADDR
// sAI := false ;
88106: LD_ADDR_EXP 145
88110: PUSH
88111: LD_INT 0
88113: ST_TO_ADDR
// sCargo := false ;
88114: LD_ADDR_EXP 148
88118: PUSH
88119: LD_INT 0
88121: ST_TO_ADDR
// sDLaser := false ;
88122: LD_ADDR_EXP 149
88126: PUSH
88127: LD_INT 0
88129: ST_TO_ADDR
// sExchange := false ;
88130: LD_ADDR_EXP 150
88134: PUSH
88135: LD_INT 0
88137: ST_TO_ADDR
// sFac := false ;
88138: LD_ADDR_EXP 151
88142: PUSH
88143: LD_INT 0
88145: ST_TO_ADDR
// sPower := false ;
88146: LD_ADDR_EXP 152
88150: PUSH
88151: LD_INT 0
88153: ST_TO_ADDR
// sRandom := false ;
88154: LD_ADDR_EXP 153
88158: PUSH
88159: LD_INT 0
88161: ST_TO_ADDR
// sShield := false ;
88162: LD_ADDR_EXP 154
88166: PUSH
88167: LD_INT 0
88169: ST_TO_ADDR
// sTime := false ;
88170: LD_ADDR_EXP 155
88174: PUSH
88175: LD_INT 0
88177: ST_TO_ADDR
// sTools := false ;
88178: LD_ADDR_EXP 156
88182: PUSH
88183: LD_INT 0
88185: ST_TO_ADDR
// sSold := false ;
88186: LD_ADDR_EXP 121
88190: PUSH
88191: LD_INT 0
88193: ST_TO_ADDR
// sDiff := false ;
88194: LD_ADDR_EXP 122
88198: PUSH
88199: LD_INT 0
88201: ST_TO_ADDR
// sFog := false ;
88202: LD_ADDR_EXP 125
88206: PUSH
88207: LD_INT 0
88209: ST_TO_ADDR
// sReset := false ;
88210: LD_ADDR_EXP 126
88214: PUSH
88215: LD_INT 0
88217: ST_TO_ADDR
// sSun := false ;
88218: LD_ADDR_EXP 127
88222: PUSH
88223: LD_INT 0
88225: ST_TO_ADDR
// sTiger := false ;
88226: LD_ADDR_EXP 123
88230: PUSH
88231: LD_INT 0
88233: ST_TO_ADDR
// sBomb := false ;
88234: LD_ADDR_EXP 124
88238: PUSH
88239: LD_INT 0
88241: ST_TO_ADDR
// sWound := false ;
88242: LD_ADDR_EXP 132
88246: PUSH
88247: LD_INT 0
88249: ST_TO_ADDR
// sBetray := false ;
88250: LD_ADDR_EXP 136
88254: PUSH
88255: LD_INT 0
88257: ST_TO_ADDR
// sContamin := false ;
88258: LD_ADDR_EXP 137
88262: PUSH
88263: LD_INT 0
88265: ST_TO_ADDR
// sOil := false ;
88266: LD_ADDR_EXP 139
88270: PUSH
88271: LD_INT 0
88273: ST_TO_ADDR
// sStu := false ;
88274: LD_ADDR_EXP 143
88278: PUSH
88279: LD_INT 0
88281: ST_TO_ADDR
// sBazooka := false ;
88282: LD_ADDR_EXP 146
88286: PUSH
88287: LD_INT 0
88289: ST_TO_ADDR
// sMortar := false ;
88290: LD_ADDR_EXP 147
88294: PUSH
88295: LD_INT 0
88297: ST_TO_ADDR
// sRanger := false ;
88298: LD_ADDR_EXP 157
88302: PUSH
88303: LD_INT 0
88305: ST_TO_ADDR
// sComputer := false ;
88306: LD_ADDR_EXP 158
88310: PUSH
88311: LD_INT 0
88313: ST_TO_ADDR
// s30 := false ;
88314: LD_ADDR_EXP 159
88318: PUSH
88319: LD_INT 0
88321: ST_TO_ADDR
// s60 := false ;
88322: LD_ADDR_EXP 160
88326: PUSH
88327: LD_INT 0
88329: ST_TO_ADDR
// end ;
88330: LD_VAR 0 1
88334: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
88335: LD_INT 0
88337: PPUSH
88338: PPUSH
88339: PPUSH
88340: PPUSH
88341: PPUSH
88342: PPUSH
88343: PPUSH
// result := [ ] ;
88344: LD_ADDR_VAR 0 2
88348: PUSH
88349: EMPTY
88350: ST_TO_ADDR
// if campaign_id = 1 then
88351: LD_OWVAR 69
88355: PUSH
88356: LD_INT 1
88358: EQUAL
88359: IFFALSE 91525
// begin case mission_number of 1 :
88361: LD_OWVAR 70
88365: PUSH
88366: LD_INT 1
88368: DOUBLE
88369: EQUAL
88370: IFTRUE 88374
88372: GO 88450
88374: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
88375: LD_ADDR_VAR 0 2
88379: PUSH
88380: LD_INT 2
88382: PUSH
88383: LD_INT 4
88385: PUSH
88386: LD_INT 11
88388: PUSH
88389: LD_INT 12
88391: PUSH
88392: LD_INT 15
88394: PUSH
88395: LD_INT 16
88397: PUSH
88398: LD_INT 22
88400: PUSH
88401: LD_INT 23
88403: PUSH
88404: LD_INT 26
88406: PUSH
88407: EMPTY
88408: LIST
88409: LIST
88410: LIST
88411: LIST
88412: LIST
88413: LIST
88414: LIST
88415: LIST
88416: LIST
88417: PUSH
88418: LD_INT 101
88420: PUSH
88421: LD_INT 102
88423: PUSH
88424: LD_INT 106
88426: PUSH
88427: LD_INT 116
88429: PUSH
88430: LD_INT 117
88432: PUSH
88433: LD_INT 118
88435: PUSH
88436: EMPTY
88437: LIST
88438: LIST
88439: LIST
88440: LIST
88441: LIST
88442: LIST
88443: PUSH
88444: EMPTY
88445: LIST
88446: LIST
88447: ST_TO_ADDR
88448: GO 91523
88450: LD_INT 2
88452: DOUBLE
88453: EQUAL
88454: IFTRUE 88458
88456: GO 88542
88458: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
88459: LD_ADDR_VAR 0 2
88463: PUSH
88464: LD_INT 2
88466: PUSH
88467: LD_INT 4
88469: PUSH
88470: LD_INT 11
88472: PUSH
88473: LD_INT 12
88475: PUSH
88476: LD_INT 15
88478: PUSH
88479: LD_INT 16
88481: PUSH
88482: LD_INT 22
88484: PUSH
88485: LD_INT 23
88487: PUSH
88488: LD_INT 26
88490: PUSH
88491: EMPTY
88492: LIST
88493: LIST
88494: LIST
88495: LIST
88496: LIST
88497: LIST
88498: LIST
88499: LIST
88500: LIST
88501: PUSH
88502: LD_INT 101
88504: PUSH
88505: LD_INT 102
88507: PUSH
88508: LD_INT 105
88510: PUSH
88511: LD_INT 106
88513: PUSH
88514: LD_INT 108
88516: PUSH
88517: LD_INT 116
88519: PUSH
88520: LD_INT 117
88522: PUSH
88523: LD_INT 118
88525: PUSH
88526: EMPTY
88527: LIST
88528: LIST
88529: LIST
88530: LIST
88531: LIST
88532: LIST
88533: LIST
88534: LIST
88535: PUSH
88536: EMPTY
88537: LIST
88538: LIST
88539: ST_TO_ADDR
88540: GO 91523
88542: LD_INT 3
88544: DOUBLE
88545: EQUAL
88546: IFTRUE 88550
88548: GO 88638
88550: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
88551: LD_ADDR_VAR 0 2
88555: PUSH
88556: LD_INT 2
88558: PUSH
88559: LD_INT 4
88561: PUSH
88562: LD_INT 5
88564: PUSH
88565: LD_INT 11
88567: PUSH
88568: LD_INT 12
88570: PUSH
88571: LD_INT 15
88573: PUSH
88574: LD_INT 16
88576: PUSH
88577: LD_INT 22
88579: PUSH
88580: LD_INT 26
88582: PUSH
88583: LD_INT 36
88585: PUSH
88586: EMPTY
88587: LIST
88588: LIST
88589: LIST
88590: LIST
88591: LIST
88592: LIST
88593: LIST
88594: LIST
88595: LIST
88596: LIST
88597: PUSH
88598: LD_INT 101
88600: PUSH
88601: LD_INT 102
88603: PUSH
88604: LD_INT 105
88606: PUSH
88607: LD_INT 106
88609: PUSH
88610: LD_INT 108
88612: PUSH
88613: LD_INT 116
88615: PUSH
88616: LD_INT 117
88618: PUSH
88619: LD_INT 118
88621: PUSH
88622: EMPTY
88623: LIST
88624: LIST
88625: LIST
88626: LIST
88627: LIST
88628: LIST
88629: LIST
88630: LIST
88631: PUSH
88632: EMPTY
88633: LIST
88634: LIST
88635: ST_TO_ADDR
88636: GO 91523
88638: LD_INT 4
88640: DOUBLE
88641: EQUAL
88642: IFTRUE 88646
88644: GO 88742
88646: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
88647: LD_ADDR_VAR 0 2
88651: PUSH
88652: LD_INT 2
88654: PUSH
88655: LD_INT 4
88657: PUSH
88658: LD_INT 5
88660: PUSH
88661: LD_INT 8
88663: PUSH
88664: LD_INT 11
88666: PUSH
88667: LD_INT 12
88669: PUSH
88670: LD_INT 15
88672: PUSH
88673: LD_INT 16
88675: PUSH
88676: LD_INT 22
88678: PUSH
88679: LD_INT 23
88681: PUSH
88682: LD_INT 26
88684: PUSH
88685: LD_INT 36
88687: PUSH
88688: EMPTY
88689: LIST
88690: LIST
88691: LIST
88692: LIST
88693: LIST
88694: LIST
88695: LIST
88696: LIST
88697: LIST
88698: LIST
88699: LIST
88700: LIST
88701: PUSH
88702: LD_INT 101
88704: PUSH
88705: LD_INT 102
88707: PUSH
88708: LD_INT 105
88710: PUSH
88711: LD_INT 106
88713: PUSH
88714: LD_INT 108
88716: PUSH
88717: LD_INT 116
88719: PUSH
88720: LD_INT 117
88722: PUSH
88723: LD_INT 118
88725: PUSH
88726: EMPTY
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: PUSH
88736: EMPTY
88737: LIST
88738: LIST
88739: ST_TO_ADDR
88740: GO 91523
88742: LD_INT 5
88744: DOUBLE
88745: EQUAL
88746: IFTRUE 88750
88748: GO 88862
88750: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
88751: LD_ADDR_VAR 0 2
88755: PUSH
88756: LD_INT 2
88758: PUSH
88759: LD_INT 4
88761: PUSH
88762: LD_INT 5
88764: PUSH
88765: LD_INT 6
88767: PUSH
88768: LD_INT 8
88770: PUSH
88771: LD_INT 11
88773: PUSH
88774: LD_INT 12
88776: PUSH
88777: LD_INT 15
88779: PUSH
88780: LD_INT 16
88782: PUSH
88783: LD_INT 22
88785: PUSH
88786: LD_INT 23
88788: PUSH
88789: LD_INT 25
88791: PUSH
88792: LD_INT 26
88794: PUSH
88795: LD_INT 36
88797: PUSH
88798: EMPTY
88799: LIST
88800: LIST
88801: LIST
88802: LIST
88803: LIST
88804: LIST
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: LIST
88813: PUSH
88814: LD_INT 101
88816: PUSH
88817: LD_INT 102
88819: PUSH
88820: LD_INT 105
88822: PUSH
88823: LD_INT 106
88825: PUSH
88826: LD_INT 108
88828: PUSH
88829: LD_INT 109
88831: PUSH
88832: LD_INT 112
88834: PUSH
88835: LD_INT 116
88837: PUSH
88838: LD_INT 117
88840: PUSH
88841: LD_INT 118
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: ST_TO_ADDR
88860: GO 91523
88862: LD_INT 6
88864: DOUBLE
88865: EQUAL
88866: IFTRUE 88870
88868: GO 89002
88870: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
88871: LD_ADDR_VAR 0 2
88875: PUSH
88876: LD_INT 2
88878: PUSH
88879: LD_INT 4
88881: PUSH
88882: LD_INT 5
88884: PUSH
88885: LD_INT 6
88887: PUSH
88888: LD_INT 8
88890: PUSH
88891: LD_INT 11
88893: PUSH
88894: LD_INT 12
88896: PUSH
88897: LD_INT 15
88899: PUSH
88900: LD_INT 16
88902: PUSH
88903: LD_INT 20
88905: PUSH
88906: LD_INT 21
88908: PUSH
88909: LD_INT 22
88911: PUSH
88912: LD_INT 23
88914: PUSH
88915: LD_INT 25
88917: PUSH
88918: LD_INT 26
88920: PUSH
88921: LD_INT 30
88923: PUSH
88924: LD_INT 31
88926: PUSH
88927: LD_INT 32
88929: PUSH
88930: LD_INT 36
88932: PUSH
88933: EMPTY
88934: LIST
88935: LIST
88936: LIST
88937: LIST
88938: LIST
88939: LIST
88940: LIST
88941: LIST
88942: LIST
88943: LIST
88944: LIST
88945: LIST
88946: LIST
88947: LIST
88948: LIST
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: PUSH
88954: LD_INT 101
88956: PUSH
88957: LD_INT 102
88959: PUSH
88960: LD_INT 105
88962: PUSH
88963: LD_INT 106
88965: PUSH
88966: LD_INT 108
88968: PUSH
88969: LD_INT 109
88971: PUSH
88972: LD_INT 112
88974: PUSH
88975: LD_INT 116
88977: PUSH
88978: LD_INT 117
88980: PUSH
88981: LD_INT 118
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: PUSH
88996: EMPTY
88997: LIST
88998: LIST
88999: ST_TO_ADDR
89000: GO 91523
89002: LD_INT 7
89004: DOUBLE
89005: EQUAL
89006: IFTRUE 89010
89008: GO 89122
89010: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
89011: LD_ADDR_VAR 0 2
89015: PUSH
89016: LD_INT 2
89018: PUSH
89019: LD_INT 4
89021: PUSH
89022: LD_INT 5
89024: PUSH
89025: LD_INT 7
89027: PUSH
89028: LD_INT 11
89030: PUSH
89031: LD_INT 12
89033: PUSH
89034: LD_INT 15
89036: PUSH
89037: LD_INT 16
89039: PUSH
89040: LD_INT 20
89042: PUSH
89043: LD_INT 21
89045: PUSH
89046: LD_INT 22
89048: PUSH
89049: LD_INT 23
89051: PUSH
89052: LD_INT 25
89054: PUSH
89055: LD_INT 26
89057: PUSH
89058: EMPTY
89059: LIST
89060: LIST
89061: LIST
89062: LIST
89063: LIST
89064: LIST
89065: LIST
89066: LIST
89067: LIST
89068: LIST
89069: LIST
89070: LIST
89071: LIST
89072: LIST
89073: PUSH
89074: LD_INT 101
89076: PUSH
89077: LD_INT 102
89079: PUSH
89080: LD_INT 103
89082: PUSH
89083: LD_INT 105
89085: PUSH
89086: LD_INT 106
89088: PUSH
89089: LD_INT 108
89091: PUSH
89092: LD_INT 112
89094: PUSH
89095: LD_INT 116
89097: PUSH
89098: LD_INT 117
89100: PUSH
89101: LD_INT 118
89103: PUSH
89104: EMPTY
89105: LIST
89106: LIST
89107: LIST
89108: LIST
89109: LIST
89110: LIST
89111: LIST
89112: LIST
89113: LIST
89114: LIST
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: ST_TO_ADDR
89120: GO 91523
89122: LD_INT 8
89124: DOUBLE
89125: EQUAL
89126: IFTRUE 89130
89128: GO 89270
89130: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
89131: LD_ADDR_VAR 0 2
89135: PUSH
89136: LD_INT 2
89138: PUSH
89139: LD_INT 4
89141: PUSH
89142: LD_INT 5
89144: PUSH
89145: LD_INT 6
89147: PUSH
89148: LD_INT 7
89150: PUSH
89151: LD_INT 8
89153: PUSH
89154: LD_INT 11
89156: PUSH
89157: LD_INT 12
89159: PUSH
89160: LD_INT 15
89162: PUSH
89163: LD_INT 16
89165: PUSH
89166: LD_INT 20
89168: PUSH
89169: LD_INT 21
89171: PUSH
89172: LD_INT 22
89174: PUSH
89175: LD_INT 23
89177: PUSH
89178: LD_INT 25
89180: PUSH
89181: LD_INT 26
89183: PUSH
89184: LD_INT 30
89186: PUSH
89187: LD_INT 31
89189: PUSH
89190: LD_INT 32
89192: PUSH
89193: LD_INT 36
89195: PUSH
89196: EMPTY
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: LIST
89209: LIST
89210: LIST
89211: LIST
89212: LIST
89213: LIST
89214: LIST
89215: LIST
89216: LIST
89217: PUSH
89218: LD_INT 101
89220: PUSH
89221: LD_INT 102
89223: PUSH
89224: LD_INT 103
89226: PUSH
89227: LD_INT 105
89229: PUSH
89230: LD_INT 106
89232: PUSH
89233: LD_INT 108
89235: PUSH
89236: LD_INT 109
89238: PUSH
89239: LD_INT 112
89241: PUSH
89242: LD_INT 116
89244: PUSH
89245: LD_INT 117
89247: PUSH
89248: LD_INT 118
89250: PUSH
89251: EMPTY
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: LIST
89262: LIST
89263: PUSH
89264: EMPTY
89265: LIST
89266: LIST
89267: ST_TO_ADDR
89268: GO 91523
89270: LD_INT 9
89272: DOUBLE
89273: EQUAL
89274: IFTRUE 89278
89276: GO 89426
89278: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
89279: LD_ADDR_VAR 0 2
89283: PUSH
89284: LD_INT 2
89286: PUSH
89287: LD_INT 4
89289: PUSH
89290: LD_INT 5
89292: PUSH
89293: LD_INT 6
89295: PUSH
89296: LD_INT 7
89298: PUSH
89299: LD_INT 8
89301: PUSH
89302: LD_INT 11
89304: PUSH
89305: LD_INT 12
89307: PUSH
89308: LD_INT 15
89310: PUSH
89311: LD_INT 16
89313: PUSH
89314: LD_INT 20
89316: PUSH
89317: LD_INT 21
89319: PUSH
89320: LD_INT 22
89322: PUSH
89323: LD_INT 23
89325: PUSH
89326: LD_INT 25
89328: PUSH
89329: LD_INT 26
89331: PUSH
89332: LD_INT 28
89334: PUSH
89335: LD_INT 30
89337: PUSH
89338: LD_INT 31
89340: PUSH
89341: LD_INT 32
89343: PUSH
89344: LD_INT 36
89346: PUSH
89347: EMPTY
89348: LIST
89349: LIST
89350: LIST
89351: LIST
89352: LIST
89353: LIST
89354: LIST
89355: LIST
89356: LIST
89357: LIST
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: LIST
89369: PUSH
89370: LD_INT 101
89372: PUSH
89373: LD_INT 102
89375: PUSH
89376: LD_INT 103
89378: PUSH
89379: LD_INT 105
89381: PUSH
89382: LD_INT 106
89384: PUSH
89385: LD_INT 108
89387: PUSH
89388: LD_INT 109
89390: PUSH
89391: LD_INT 112
89393: PUSH
89394: LD_INT 114
89396: PUSH
89397: LD_INT 116
89399: PUSH
89400: LD_INT 117
89402: PUSH
89403: LD_INT 118
89405: PUSH
89406: EMPTY
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: LIST
89412: LIST
89413: LIST
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: PUSH
89420: EMPTY
89421: LIST
89422: LIST
89423: ST_TO_ADDR
89424: GO 91523
89426: LD_INT 10
89428: DOUBLE
89429: EQUAL
89430: IFTRUE 89434
89432: GO 89630
89434: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
89435: LD_ADDR_VAR 0 2
89439: PUSH
89440: LD_INT 2
89442: PUSH
89443: LD_INT 4
89445: PUSH
89446: LD_INT 5
89448: PUSH
89449: LD_INT 6
89451: PUSH
89452: LD_INT 7
89454: PUSH
89455: LD_INT 8
89457: PUSH
89458: LD_INT 9
89460: PUSH
89461: LD_INT 10
89463: PUSH
89464: LD_INT 11
89466: PUSH
89467: LD_INT 12
89469: PUSH
89470: LD_INT 13
89472: PUSH
89473: LD_INT 14
89475: PUSH
89476: LD_INT 15
89478: PUSH
89479: LD_INT 16
89481: PUSH
89482: LD_INT 17
89484: PUSH
89485: LD_INT 18
89487: PUSH
89488: LD_INT 19
89490: PUSH
89491: LD_INT 20
89493: PUSH
89494: LD_INT 21
89496: PUSH
89497: LD_INT 22
89499: PUSH
89500: LD_INT 23
89502: PUSH
89503: LD_INT 24
89505: PUSH
89506: LD_INT 25
89508: PUSH
89509: LD_INT 26
89511: PUSH
89512: LD_INT 28
89514: PUSH
89515: LD_INT 30
89517: PUSH
89518: LD_INT 31
89520: PUSH
89521: LD_INT 32
89523: PUSH
89524: LD_INT 36
89526: PUSH
89527: EMPTY
89528: LIST
89529: LIST
89530: LIST
89531: LIST
89532: LIST
89533: LIST
89534: LIST
89535: LIST
89536: LIST
89537: LIST
89538: LIST
89539: LIST
89540: LIST
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: PUSH
89558: LD_INT 101
89560: PUSH
89561: LD_INT 102
89563: PUSH
89564: LD_INT 103
89566: PUSH
89567: LD_INT 104
89569: PUSH
89570: LD_INT 105
89572: PUSH
89573: LD_INT 106
89575: PUSH
89576: LD_INT 107
89578: PUSH
89579: LD_INT 108
89581: PUSH
89582: LD_INT 109
89584: PUSH
89585: LD_INT 110
89587: PUSH
89588: LD_INT 111
89590: PUSH
89591: LD_INT 112
89593: PUSH
89594: LD_INT 114
89596: PUSH
89597: LD_INT 116
89599: PUSH
89600: LD_INT 117
89602: PUSH
89603: LD_INT 118
89605: PUSH
89606: EMPTY
89607: LIST
89608: LIST
89609: LIST
89610: LIST
89611: LIST
89612: LIST
89613: LIST
89614: LIST
89615: LIST
89616: LIST
89617: LIST
89618: LIST
89619: LIST
89620: LIST
89621: LIST
89622: LIST
89623: PUSH
89624: EMPTY
89625: LIST
89626: LIST
89627: ST_TO_ADDR
89628: GO 91523
89630: LD_INT 11
89632: DOUBLE
89633: EQUAL
89634: IFTRUE 89638
89636: GO 89842
89638: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
89639: LD_ADDR_VAR 0 2
89643: PUSH
89644: LD_INT 2
89646: PUSH
89647: LD_INT 3
89649: PUSH
89650: LD_INT 4
89652: PUSH
89653: LD_INT 5
89655: PUSH
89656: LD_INT 6
89658: PUSH
89659: LD_INT 7
89661: PUSH
89662: LD_INT 8
89664: PUSH
89665: LD_INT 9
89667: PUSH
89668: LD_INT 10
89670: PUSH
89671: LD_INT 11
89673: PUSH
89674: LD_INT 12
89676: PUSH
89677: LD_INT 13
89679: PUSH
89680: LD_INT 14
89682: PUSH
89683: LD_INT 15
89685: PUSH
89686: LD_INT 16
89688: PUSH
89689: LD_INT 17
89691: PUSH
89692: LD_INT 18
89694: PUSH
89695: LD_INT 19
89697: PUSH
89698: LD_INT 20
89700: PUSH
89701: LD_INT 21
89703: PUSH
89704: LD_INT 22
89706: PUSH
89707: LD_INT 23
89709: PUSH
89710: LD_INT 24
89712: PUSH
89713: LD_INT 25
89715: PUSH
89716: LD_INT 26
89718: PUSH
89719: LD_INT 28
89721: PUSH
89722: LD_INT 30
89724: PUSH
89725: LD_INT 31
89727: PUSH
89728: LD_INT 32
89730: PUSH
89731: LD_INT 34
89733: PUSH
89734: LD_INT 36
89736: PUSH
89737: EMPTY
89738: LIST
89739: LIST
89740: LIST
89741: LIST
89742: LIST
89743: LIST
89744: LIST
89745: LIST
89746: LIST
89747: LIST
89748: LIST
89749: LIST
89750: LIST
89751: LIST
89752: LIST
89753: LIST
89754: LIST
89755: LIST
89756: LIST
89757: LIST
89758: LIST
89759: LIST
89760: LIST
89761: LIST
89762: LIST
89763: LIST
89764: LIST
89765: LIST
89766: LIST
89767: LIST
89768: LIST
89769: PUSH
89770: LD_INT 101
89772: PUSH
89773: LD_INT 102
89775: PUSH
89776: LD_INT 103
89778: PUSH
89779: LD_INT 104
89781: PUSH
89782: LD_INT 105
89784: PUSH
89785: LD_INT 106
89787: PUSH
89788: LD_INT 107
89790: PUSH
89791: LD_INT 108
89793: PUSH
89794: LD_INT 109
89796: PUSH
89797: LD_INT 110
89799: PUSH
89800: LD_INT 111
89802: PUSH
89803: LD_INT 112
89805: PUSH
89806: LD_INT 114
89808: PUSH
89809: LD_INT 116
89811: PUSH
89812: LD_INT 117
89814: PUSH
89815: LD_INT 118
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: LIST
89822: LIST
89823: LIST
89824: LIST
89825: LIST
89826: LIST
89827: LIST
89828: LIST
89829: LIST
89830: LIST
89831: LIST
89832: LIST
89833: LIST
89834: LIST
89835: PUSH
89836: EMPTY
89837: LIST
89838: LIST
89839: ST_TO_ADDR
89840: GO 91523
89842: LD_INT 12
89844: DOUBLE
89845: EQUAL
89846: IFTRUE 89850
89848: GO 90070
89850: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
89851: LD_ADDR_VAR 0 2
89855: PUSH
89856: LD_INT 1
89858: PUSH
89859: LD_INT 2
89861: PUSH
89862: LD_INT 3
89864: PUSH
89865: LD_INT 4
89867: PUSH
89868: LD_INT 5
89870: PUSH
89871: LD_INT 6
89873: PUSH
89874: LD_INT 7
89876: PUSH
89877: LD_INT 8
89879: PUSH
89880: LD_INT 9
89882: PUSH
89883: LD_INT 10
89885: PUSH
89886: LD_INT 11
89888: PUSH
89889: LD_INT 12
89891: PUSH
89892: LD_INT 13
89894: PUSH
89895: LD_INT 14
89897: PUSH
89898: LD_INT 15
89900: PUSH
89901: LD_INT 16
89903: PUSH
89904: LD_INT 17
89906: PUSH
89907: LD_INT 18
89909: PUSH
89910: LD_INT 19
89912: PUSH
89913: LD_INT 20
89915: PUSH
89916: LD_INT 21
89918: PUSH
89919: LD_INT 22
89921: PUSH
89922: LD_INT 23
89924: PUSH
89925: LD_INT 24
89927: PUSH
89928: LD_INT 25
89930: PUSH
89931: LD_INT 26
89933: PUSH
89934: LD_INT 27
89936: PUSH
89937: LD_INT 28
89939: PUSH
89940: LD_INT 30
89942: PUSH
89943: LD_INT 31
89945: PUSH
89946: LD_INT 32
89948: PUSH
89949: LD_INT 33
89951: PUSH
89952: LD_INT 34
89954: PUSH
89955: LD_INT 36
89957: PUSH
89958: EMPTY
89959: LIST
89960: LIST
89961: LIST
89962: LIST
89963: LIST
89964: LIST
89965: LIST
89966: LIST
89967: LIST
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: LIST
89976: LIST
89977: LIST
89978: LIST
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: LIST
89987: LIST
89988: LIST
89989: LIST
89990: LIST
89991: LIST
89992: LIST
89993: PUSH
89994: LD_INT 101
89996: PUSH
89997: LD_INT 102
89999: PUSH
90000: LD_INT 103
90002: PUSH
90003: LD_INT 104
90005: PUSH
90006: LD_INT 105
90008: PUSH
90009: LD_INT 106
90011: PUSH
90012: LD_INT 107
90014: PUSH
90015: LD_INT 108
90017: PUSH
90018: LD_INT 109
90020: PUSH
90021: LD_INT 110
90023: PUSH
90024: LD_INT 111
90026: PUSH
90027: LD_INT 112
90029: PUSH
90030: LD_INT 113
90032: PUSH
90033: LD_INT 114
90035: PUSH
90036: LD_INT 116
90038: PUSH
90039: LD_INT 117
90041: PUSH
90042: LD_INT 118
90044: PUSH
90045: EMPTY
90046: LIST
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: PUSH
90064: EMPTY
90065: LIST
90066: LIST
90067: ST_TO_ADDR
90068: GO 91523
90070: LD_INT 13
90072: DOUBLE
90073: EQUAL
90074: IFTRUE 90078
90076: GO 90286
90078: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
90079: LD_ADDR_VAR 0 2
90083: PUSH
90084: LD_INT 1
90086: PUSH
90087: LD_INT 2
90089: PUSH
90090: LD_INT 3
90092: PUSH
90093: LD_INT 4
90095: PUSH
90096: LD_INT 5
90098: PUSH
90099: LD_INT 8
90101: PUSH
90102: LD_INT 9
90104: PUSH
90105: LD_INT 10
90107: PUSH
90108: LD_INT 11
90110: PUSH
90111: LD_INT 12
90113: PUSH
90114: LD_INT 14
90116: PUSH
90117: LD_INT 15
90119: PUSH
90120: LD_INT 16
90122: PUSH
90123: LD_INT 17
90125: PUSH
90126: LD_INT 18
90128: PUSH
90129: LD_INT 19
90131: PUSH
90132: LD_INT 20
90134: PUSH
90135: LD_INT 21
90137: PUSH
90138: LD_INT 22
90140: PUSH
90141: LD_INT 23
90143: PUSH
90144: LD_INT 24
90146: PUSH
90147: LD_INT 25
90149: PUSH
90150: LD_INT 26
90152: PUSH
90153: LD_INT 27
90155: PUSH
90156: LD_INT 28
90158: PUSH
90159: LD_INT 30
90161: PUSH
90162: LD_INT 31
90164: PUSH
90165: LD_INT 32
90167: PUSH
90168: LD_INT 33
90170: PUSH
90171: LD_INT 34
90173: PUSH
90174: LD_INT 36
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: LIST
90181: LIST
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: LIST
90189: LIST
90190: LIST
90191: LIST
90192: LIST
90193: LIST
90194: LIST
90195: LIST
90196: LIST
90197: LIST
90198: LIST
90199: LIST
90200: LIST
90201: LIST
90202: LIST
90203: LIST
90204: LIST
90205: LIST
90206: LIST
90207: LIST
90208: LIST
90209: PUSH
90210: LD_INT 101
90212: PUSH
90213: LD_INT 102
90215: PUSH
90216: LD_INT 103
90218: PUSH
90219: LD_INT 104
90221: PUSH
90222: LD_INT 105
90224: PUSH
90225: LD_INT 106
90227: PUSH
90228: LD_INT 107
90230: PUSH
90231: LD_INT 108
90233: PUSH
90234: LD_INT 109
90236: PUSH
90237: LD_INT 110
90239: PUSH
90240: LD_INT 111
90242: PUSH
90243: LD_INT 112
90245: PUSH
90246: LD_INT 113
90248: PUSH
90249: LD_INT 114
90251: PUSH
90252: LD_INT 116
90254: PUSH
90255: LD_INT 117
90257: PUSH
90258: LD_INT 118
90260: PUSH
90261: EMPTY
90262: LIST
90263: LIST
90264: LIST
90265: LIST
90266: LIST
90267: LIST
90268: LIST
90269: LIST
90270: LIST
90271: LIST
90272: LIST
90273: LIST
90274: LIST
90275: LIST
90276: LIST
90277: LIST
90278: LIST
90279: PUSH
90280: EMPTY
90281: LIST
90282: LIST
90283: ST_TO_ADDR
90284: GO 91523
90286: LD_INT 14
90288: DOUBLE
90289: EQUAL
90290: IFTRUE 90294
90292: GO 90518
90294: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
90295: LD_ADDR_VAR 0 2
90299: PUSH
90300: LD_INT 1
90302: PUSH
90303: LD_INT 2
90305: PUSH
90306: LD_INT 3
90308: PUSH
90309: LD_INT 4
90311: PUSH
90312: LD_INT 5
90314: PUSH
90315: LD_INT 6
90317: PUSH
90318: LD_INT 7
90320: PUSH
90321: LD_INT 8
90323: PUSH
90324: LD_INT 9
90326: PUSH
90327: LD_INT 10
90329: PUSH
90330: LD_INT 11
90332: PUSH
90333: LD_INT 12
90335: PUSH
90336: LD_INT 13
90338: PUSH
90339: LD_INT 14
90341: PUSH
90342: LD_INT 15
90344: PUSH
90345: LD_INT 16
90347: PUSH
90348: LD_INT 17
90350: PUSH
90351: LD_INT 18
90353: PUSH
90354: LD_INT 19
90356: PUSH
90357: LD_INT 20
90359: PUSH
90360: LD_INT 21
90362: PUSH
90363: LD_INT 22
90365: PUSH
90366: LD_INT 23
90368: PUSH
90369: LD_INT 24
90371: PUSH
90372: LD_INT 25
90374: PUSH
90375: LD_INT 26
90377: PUSH
90378: LD_INT 27
90380: PUSH
90381: LD_INT 28
90383: PUSH
90384: LD_INT 29
90386: PUSH
90387: LD_INT 30
90389: PUSH
90390: LD_INT 31
90392: PUSH
90393: LD_INT 32
90395: PUSH
90396: LD_INT 33
90398: PUSH
90399: LD_INT 34
90401: PUSH
90402: LD_INT 36
90404: PUSH
90405: EMPTY
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: LIST
90416: LIST
90417: LIST
90418: LIST
90419: LIST
90420: LIST
90421: LIST
90422: LIST
90423: LIST
90424: LIST
90425: LIST
90426: LIST
90427: LIST
90428: LIST
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: LIST
90434: LIST
90435: LIST
90436: LIST
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: PUSH
90442: LD_INT 101
90444: PUSH
90445: LD_INT 102
90447: PUSH
90448: LD_INT 103
90450: PUSH
90451: LD_INT 104
90453: PUSH
90454: LD_INT 105
90456: PUSH
90457: LD_INT 106
90459: PUSH
90460: LD_INT 107
90462: PUSH
90463: LD_INT 108
90465: PUSH
90466: LD_INT 109
90468: PUSH
90469: LD_INT 110
90471: PUSH
90472: LD_INT 111
90474: PUSH
90475: LD_INT 112
90477: PUSH
90478: LD_INT 113
90480: PUSH
90481: LD_INT 114
90483: PUSH
90484: LD_INT 116
90486: PUSH
90487: LD_INT 117
90489: PUSH
90490: LD_INT 118
90492: PUSH
90493: EMPTY
90494: LIST
90495: LIST
90496: LIST
90497: LIST
90498: LIST
90499: LIST
90500: LIST
90501: LIST
90502: LIST
90503: LIST
90504: LIST
90505: LIST
90506: LIST
90507: LIST
90508: LIST
90509: LIST
90510: LIST
90511: PUSH
90512: EMPTY
90513: LIST
90514: LIST
90515: ST_TO_ADDR
90516: GO 91523
90518: LD_INT 15
90520: DOUBLE
90521: EQUAL
90522: IFTRUE 90526
90524: GO 90750
90526: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
90527: LD_ADDR_VAR 0 2
90531: PUSH
90532: LD_INT 1
90534: PUSH
90535: LD_INT 2
90537: PUSH
90538: LD_INT 3
90540: PUSH
90541: LD_INT 4
90543: PUSH
90544: LD_INT 5
90546: PUSH
90547: LD_INT 6
90549: PUSH
90550: LD_INT 7
90552: PUSH
90553: LD_INT 8
90555: PUSH
90556: LD_INT 9
90558: PUSH
90559: LD_INT 10
90561: PUSH
90562: LD_INT 11
90564: PUSH
90565: LD_INT 12
90567: PUSH
90568: LD_INT 13
90570: PUSH
90571: LD_INT 14
90573: PUSH
90574: LD_INT 15
90576: PUSH
90577: LD_INT 16
90579: PUSH
90580: LD_INT 17
90582: PUSH
90583: LD_INT 18
90585: PUSH
90586: LD_INT 19
90588: PUSH
90589: LD_INT 20
90591: PUSH
90592: LD_INT 21
90594: PUSH
90595: LD_INT 22
90597: PUSH
90598: LD_INT 23
90600: PUSH
90601: LD_INT 24
90603: PUSH
90604: LD_INT 25
90606: PUSH
90607: LD_INT 26
90609: PUSH
90610: LD_INT 27
90612: PUSH
90613: LD_INT 28
90615: PUSH
90616: LD_INT 29
90618: PUSH
90619: LD_INT 30
90621: PUSH
90622: LD_INT 31
90624: PUSH
90625: LD_INT 32
90627: PUSH
90628: LD_INT 33
90630: PUSH
90631: LD_INT 34
90633: PUSH
90634: LD_INT 36
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: LIST
90654: LIST
90655: LIST
90656: LIST
90657: LIST
90658: LIST
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: LIST
90666: LIST
90667: LIST
90668: LIST
90669: LIST
90670: LIST
90671: LIST
90672: LIST
90673: PUSH
90674: LD_INT 101
90676: PUSH
90677: LD_INT 102
90679: PUSH
90680: LD_INT 103
90682: PUSH
90683: LD_INT 104
90685: PUSH
90686: LD_INT 105
90688: PUSH
90689: LD_INT 106
90691: PUSH
90692: LD_INT 107
90694: PUSH
90695: LD_INT 108
90697: PUSH
90698: LD_INT 109
90700: PUSH
90701: LD_INT 110
90703: PUSH
90704: LD_INT 111
90706: PUSH
90707: LD_INT 112
90709: PUSH
90710: LD_INT 113
90712: PUSH
90713: LD_INT 114
90715: PUSH
90716: LD_INT 116
90718: PUSH
90719: LD_INT 117
90721: PUSH
90722: LD_INT 118
90724: PUSH
90725: EMPTY
90726: LIST
90727: LIST
90728: LIST
90729: LIST
90730: LIST
90731: LIST
90732: LIST
90733: LIST
90734: LIST
90735: LIST
90736: LIST
90737: LIST
90738: LIST
90739: LIST
90740: LIST
90741: LIST
90742: LIST
90743: PUSH
90744: EMPTY
90745: LIST
90746: LIST
90747: ST_TO_ADDR
90748: GO 91523
90750: LD_INT 16
90752: DOUBLE
90753: EQUAL
90754: IFTRUE 90758
90756: GO 90894
90758: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
90759: LD_ADDR_VAR 0 2
90763: PUSH
90764: LD_INT 2
90766: PUSH
90767: LD_INT 4
90769: PUSH
90770: LD_INT 5
90772: PUSH
90773: LD_INT 7
90775: PUSH
90776: LD_INT 11
90778: PUSH
90779: LD_INT 12
90781: PUSH
90782: LD_INT 15
90784: PUSH
90785: LD_INT 16
90787: PUSH
90788: LD_INT 20
90790: PUSH
90791: LD_INT 21
90793: PUSH
90794: LD_INT 22
90796: PUSH
90797: LD_INT 23
90799: PUSH
90800: LD_INT 25
90802: PUSH
90803: LD_INT 26
90805: PUSH
90806: LD_INT 30
90808: PUSH
90809: LD_INT 31
90811: PUSH
90812: LD_INT 32
90814: PUSH
90815: LD_INT 33
90817: PUSH
90818: LD_INT 34
90820: PUSH
90821: EMPTY
90822: LIST
90823: LIST
90824: LIST
90825: LIST
90826: LIST
90827: LIST
90828: LIST
90829: LIST
90830: LIST
90831: LIST
90832: LIST
90833: LIST
90834: LIST
90835: LIST
90836: LIST
90837: LIST
90838: LIST
90839: LIST
90840: LIST
90841: PUSH
90842: LD_INT 101
90844: PUSH
90845: LD_INT 102
90847: PUSH
90848: LD_INT 103
90850: PUSH
90851: LD_INT 106
90853: PUSH
90854: LD_INT 108
90856: PUSH
90857: LD_INT 112
90859: PUSH
90860: LD_INT 113
90862: PUSH
90863: LD_INT 114
90865: PUSH
90866: LD_INT 116
90868: PUSH
90869: LD_INT 117
90871: PUSH
90872: LD_INT 118
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: LIST
90879: LIST
90880: LIST
90881: LIST
90882: LIST
90883: LIST
90884: LIST
90885: LIST
90886: LIST
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: ST_TO_ADDR
90892: GO 91523
90894: LD_INT 17
90896: DOUBLE
90897: EQUAL
90898: IFTRUE 90902
90900: GO 91126
90902: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
90903: LD_ADDR_VAR 0 2
90907: PUSH
90908: LD_INT 1
90910: PUSH
90911: LD_INT 2
90913: PUSH
90914: LD_INT 3
90916: PUSH
90917: LD_INT 4
90919: PUSH
90920: LD_INT 5
90922: PUSH
90923: LD_INT 6
90925: PUSH
90926: LD_INT 7
90928: PUSH
90929: LD_INT 8
90931: PUSH
90932: LD_INT 9
90934: PUSH
90935: LD_INT 10
90937: PUSH
90938: LD_INT 11
90940: PUSH
90941: LD_INT 12
90943: PUSH
90944: LD_INT 13
90946: PUSH
90947: LD_INT 14
90949: PUSH
90950: LD_INT 15
90952: PUSH
90953: LD_INT 16
90955: PUSH
90956: LD_INT 17
90958: PUSH
90959: LD_INT 18
90961: PUSH
90962: LD_INT 19
90964: PUSH
90965: LD_INT 20
90967: PUSH
90968: LD_INT 21
90970: PUSH
90971: LD_INT 22
90973: PUSH
90974: LD_INT 23
90976: PUSH
90977: LD_INT 24
90979: PUSH
90980: LD_INT 25
90982: PUSH
90983: LD_INT 26
90985: PUSH
90986: LD_INT 27
90988: PUSH
90989: LD_INT 28
90991: PUSH
90992: LD_INT 29
90994: PUSH
90995: LD_INT 30
90997: PUSH
90998: LD_INT 31
91000: PUSH
91001: LD_INT 32
91003: PUSH
91004: LD_INT 33
91006: PUSH
91007: LD_INT 34
91009: PUSH
91010: LD_INT 36
91012: PUSH
91013: EMPTY
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: LIST
91030: LIST
91031: LIST
91032: LIST
91033: LIST
91034: LIST
91035: LIST
91036: LIST
91037: LIST
91038: LIST
91039: LIST
91040: LIST
91041: LIST
91042: LIST
91043: LIST
91044: LIST
91045: LIST
91046: LIST
91047: LIST
91048: LIST
91049: PUSH
91050: LD_INT 101
91052: PUSH
91053: LD_INT 102
91055: PUSH
91056: LD_INT 103
91058: PUSH
91059: LD_INT 104
91061: PUSH
91062: LD_INT 105
91064: PUSH
91065: LD_INT 106
91067: PUSH
91068: LD_INT 107
91070: PUSH
91071: LD_INT 108
91073: PUSH
91074: LD_INT 109
91076: PUSH
91077: LD_INT 110
91079: PUSH
91080: LD_INT 111
91082: PUSH
91083: LD_INT 112
91085: PUSH
91086: LD_INT 113
91088: PUSH
91089: LD_INT 114
91091: PUSH
91092: LD_INT 116
91094: PUSH
91095: LD_INT 117
91097: PUSH
91098: LD_INT 118
91100: PUSH
91101: EMPTY
91102: LIST
91103: LIST
91104: LIST
91105: LIST
91106: LIST
91107: LIST
91108: LIST
91109: LIST
91110: LIST
91111: LIST
91112: LIST
91113: LIST
91114: LIST
91115: LIST
91116: LIST
91117: LIST
91118: LIST
91119: PUSH
91120: EMPTY
91121: LIST
91122: LIST
91123: ST_TO_ADDR
91124: GO 91523
91126: LD_INT 18
91128: DOUBLE
91129: EQUAL
91130: IFTRUE 91134
91132: GO 91282
91134: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
91135: LD_ADDR_VAR 0 2
91139: PUSH
91140: LD_INT 2
91142: PUSH
91143: LD_INT 4
91145: PUSH
91146: LD_INT 5
91148: PUSH
91149: LD_INT 7
91151: PUSH
91152: LD_INT 11
91154: PUSH
91155: LD_INT 12
91157: PUSH
91158: LD_INT 15
91160: PUSH
91161: LD_INT 16
91163: PUSH
91164: LD_INT 20
91166: PUSH
91167: LD_INT 21
91169: PUSH
91170: LD_INT 22
91172: PUSH
91173: LD_INT 23
91175: PUSH
91176: LD_INT 25
91178: PUSH
91179: LD_INT 26
91181: PUSH
91182: LD_INT 30
91184: PUSH
91185: LD_INT 31
91187: PUSH
91188: LD_INT 32
91190: PUSH
91191: LD_INT 33
91193: PUSH
91194: LD_INT 34
91196: PUSH
91197: LD_INT 35
91199: PUSH
91200: LD_INT 36
91202: PUSH
91203: EMPTY
91204: LIST
91205: LIST
91206: LIST
91207: LIST
91208: LIST
91209: LIST
91210: LIST
91211: LIST
91212: LIST
91213: LIST
91214: LIST
91215: LIST
91216: LIST
91217: LIST
91218: LIST
91219: LIST
91220: LIST
91221: LIST
91222: LIST
91223: LIST
91224: LIST
91225: PUSH
91226: LD_INT 101
91228: PUSH
91229: LD_INT 102
91231: PUSH
91232: LD_INT 103
91234: PUSH
91235: LD_INT 106
91237: PUSH
91238: LD_INT 108
91240: PUSH
91241: LD_INT 112
91243: PUSH
91244: LD_INT 113
91246: PUSH
91247: LD_INT 114
91249: PUSH
91250: LD_INT 115
91252: PUSH
91253: LD_INT 116
91255: PUSH
91256: LD_INT 117
91258: PUSH
91259: LD_INT 118
91261: PUSH
91262: EMPTY
91263: LIST
91264: LIST
91265: LIST
91266: LIST
91267: LIST
91268: LIST
91269: LIST
91270: LIST
91271: LIST
91272: LIST
91273: LIST
91274: LIST
91275: PUSH
91276: EMPTY
91277: LIST
91278: LIST
91279: ST_TO_ADDR
91280: GO 91523
91282: LD_INT 19
91284: DOUBLE
91285: EQUAL
91286: IFTRUE 91290
91288: GO 91522
91290: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
91291: LD_ADDR_VAR 0 2
91295: PUSH
91296: LD_INT 1
91298: PUSH
91299: LD_INT 2
91301: PUSH
91302: LD_INT 3
91304: PUSH
91305: LD_INT 4
91307: PUSH
91308: LD_INT 5
91310: PUSH
91311: LD_INT 6
91313: PUSH
91314: LD_INT 7
91316: PUSH
91317: LD_INT 8
91319: PUSH
91320: LD_INT 9
91322: PUSH
91323: LD_INT 10
91325: PUSH
91326: LD_INT 11
91328: PUSH
91329: LD_INT 12
91331: PUSH
91332: LD_INT 13
91334: PUSH
91335: LD_INT 14
91337: PUSH
91338: LD_INT 15
91340: PUSH
91341: LD_INT 16
91343: PUSH
91344: LD_INT 17
91346: PUSH
91347: LD_INT 18
91349: PUSH
91350: LD_INT 19
91352: PUSH
91353: LD_INT 20
91355: PUSH
91356: LD_INT 21
91358: PUSH
91359: LD_INT 22
91361: PUSH
91362: LD_INT 23
91364: PUSH
91365: LD_INT 24
91367: PUSH
91368: LD_INT 25
91370: PUSH
91371: LD_INT 26
91373: PUSH
91374: LD_INT 27
91376: PUSH
91377: LD_INT 28
91379: PUSH
91380: LD_INT 29
91382: PUSH
91383: LD_INT 30
91385: PUSH
91386: LD_INT 31
91388: PUSH
91389: LD_INT 32
91391: PUSH
91392: LD_INT 33
91394: PUSH
91395: LD_INT 34
91397: PUSH
91398: LD_INT 35
91400: PUSH
91401: LD_INT 36
91403: PUSH
91404: EMPTY
91405: LIST
91406: LIST
91407: LIST
91408: LIST
91409: LIST
91410: LIST
91411: LIST
91412: LIST
91413: LIST
91414: LIST
91415: LIST
91416: LIST
91417: LIST
91418: LIST
91419: LIST
91420: LIST
91421: LIST
91422: LIST
91423: LIST
91424: LIST
91425: LIST
91426: LIST
91427: LIST
91428: LIST
91429: LIST
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: LIST
91441: PUSH
91442: LD_INT 101
91444: PUSH
91445: LD_INT 102
91447: PUSH
91448: LD_INT 103
91450: PUSH
91451: LD_INT 104
91453: PUSH
91454: LD_INT 105
91456: PUSH
91457: LD_INT 106
91459: PUSH
91460: LD_INT 107
91462: PUSH
91463: LD_INT 108
91465: PUSH
91466: LD_INT 109
91468: PUSH
91469: LD_INT 110
91471: PUSH
91472: LD_INT 111
91474: PUSH
91475: LD_INT 112
91477: PUSH
91478: LD_INT 113
91480: PUSH
91481: LD_INT 114
91483: PUSH
91484: LD_INT 115
91486: PUSH
91487: LD_INT 116
91489: PUSH
91490: LD_INT 117
91492: PUSH
91493: LD_INT 118
91495: PUSH
91496: EMPTY
91497: LIST
91498: LIST
91499: LIST
91500: LIST
91501: LIST
91502: LIST
91503: LIST
91504: LIST
91505: LIST
91506: LIST
91507: LIST
91508: LIST
91509: LIST
91510: LIST
91511: LIST
91512: LIST
91513: LIST
91514: LIST
91515: PUSH
91516: EMPTY
91517: LIST
91518: LIST
91519: ST_TO_ADDR
91520: GO 91523
91522: POP
// end else
91523: GO 91754
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
91525: LD_ADDR_VAR 0 2
91529: PUSH
91530: LD_INT 1
91532: PUSH
91533: LD_INT 2
91535: PUSH
91536: LD_INT 3
91538: PUSH
91539: LD_INT 4
91541: PUSH
91542: LD_INT 5
91544: PUSH
91545: LD_INT 6
91547: PUSH
91548: LD_INT 7
91550: PUSH
91551: LD_INT 8
91553: PUSH
91554: LD_INT 9
91556: PUSH
91557: LD_INT 10
91559: PUSH
91560: LD_INT 11
91562: PUSH
91563: LD_INT 12
91565: PUSH
91566: LD_INT 13
91568: PUSH
91569: LD_INT 14
91571: PUSH
91572: LD_INT 15
91574: PUSH
91575: LD_INT 16
91577: PUSH
91578: LD_INT 17
91580: PUSH
91581: LD_INT 18
91583: PUSH
91584: LD_INT 19
91586: PUSH
91587: LD_INT 20
91589: PUSH
91590: LD_INT 21
91592: PUSH
91593: LD_INT 22
91595: PUSH
91596: LD_INT 23
91598: PUSH
91599: LD_INT 24
91601: PUSH
91602: LD_INT 25
91604: PUSH
91605: LD_INT 26
91607: PUSH
91608: LD_INT 27
91610: PUSH
91611: LD_INT 28
91613: PUSH
91614: LD_INT 29
91616: PUSH
91617: LD_INT 30
91619: PUSH
91620: LD_INT 31
91622: PUSH
91623: LD_INT 32
91625: PUSH
91626: LD_INT 33
91628: PUSH
91629: LD_INT 34
91631: PUSH
91632: LD_INT 35
91634: PUSH
91635: LD_INT 36
91637: PUSH
91638: EMPTY
91639: LIST
91640: LIST
91641: LIST
91642: LIST
91643: LIST
91644: LIST
91645: LIST
91646: LIST
91647: LIST
91648: LIST
91649: LIST
91650: LIST
91651: LIST
91652: LIST
91653: LIST
91654: LIST
91655: LIST
91656: LIST
91657: LIST
91658: LIST
91659: LIST
91660: LIST
91661: LIST
91662: LIST
91663: LIST
91664: LIST
91665: LIST
91666: LIST
91667: LIST
91668: LIST
91669: LIST
91670: LIST
91671: LIST
91672: LIST
91673: LIST
91674: LIST
91675: PUSH
91676: LD_INT 101
91678: PUSH
91679: LD_INT 102
91681: PUSH
91682: LD_INT 103
91684: PUSH
91685: LD_INT 104
91687: PUSH
91688: LD_INT 105
91690: PUSH
91691: LD_INT 106
91693: PUSH
91694: LD_INT 107
91696: PUSH
91697: LD_INT 108
91699: PUSH
91700: LD_INT 109
91702: PUSH
91703: LD_INT 110
91705: PUSH
91706: LD_INT 111
91708: PUSH
91709: LD_INT 112
91711: PUSH
91712: LD_INT 113
91714: PUSH
91715: LD_INT 114
91717: PUSH
91718: LD_INT 115
91720: PUSH
91721: LD_INT 116
91723: PUSH
91724: LD_INT 117
91726: PUSH
91727: LD_INT 118
91729: PUSH
91730: EMPTY
91731: LIST
91732: LIST
91733: LIST
91734: LIST
91735: LIST
91736: LIST
91737: LIST
91738: LIST
91739: LIST
91740: LIST
91741: LIST
91742: LIST
91743: LIST
91744: LIST
91745: LIST
91746: LIST
91747: LIST
91748: LIST
91749: PUSH
91750: EMPTY
91751: LIST
91752: LIST
91753: ST_TO_ADDR
// if result then
91754: LD_VAR 0 2
91758: IFFALSE 92544
// begin normal :=  ;
91760: LD_ADDR_VAR 0 5
91764: PUSH
91765: LD_STRING 
91767: ST_TO_ADDR
// hardcore :=  ;
91768: LD_ADDR_VAR 0 6
91772: PUSH
91773: LD_STRING 
91775: ST_TO_ADDR
// active :=  ;
91776: LD_ADDR_VAR 0 7
91780: PUSH
91781: LD_STRING 
91783: ST_TO_ADDR
// for i = 1 to normalCounter do
91784: LD_ADDR_VAR 0 8
91788: PUSH
91789: DOUBLE
91790: LD_INT 1
91792: DEC
91793: ST_TO_ADDR
91794: LD_EXP 105
91798: PUSH
91799: FOR_TO
91800: IFFALSE 91901
// begin tmp := 0 ;
91802: LD_ADDR_VAR 0 3
91806: PUSH
91807: LD_STRING 0
91809: ST_TO_ADDR
// if result [ 1 ] then
91810: LD_VAR 0 2
91814: PUSH
91815: LD_INT 1
91817: ARRAY
91818: IFFALSE 91883
// if result [ 1 ] [ 1 ] = i then
91820: LD_VAR 0 2
91824: PUSH
91825: LD_INT 1
91827: ARRAY
91828: PUSH
91829: LD_INT 1
91831: ARRAY
91832: PUSH
91833: LD_VAR 0 8
91837: EQUAL
91838: IFFALSE 91883
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
91840: LD_ADDR_VAR 0 2
91844: PUSH
91845: LD_VAR 0 2
91849: PPUSH
91850: LD_INT 1
91852: PPUSH
91853: LD_VAR 0 2
91857: PUSH
91858: LD_INT 1
91860: ARRAY
91861: PPUSH
91862: LD_INT 1
91864: PPUSH
91865: CALL_OW 3
91869: PPUSH
91870: CALL_OW 1
91874: ST_TO_ADDR
// tmp := 1 ;
91875: LD_ADDR_VAR 0 3
91879: PUSH
91880: LD_STRING 1
91882: ST_TO_ADDR
// end ; normal := normal & tmp ;
91883: LD_ADDR_VAR 0 5
91887: PUSH
91888: LD_VAR 0 5
91892: PUSH
91893: LD_VAR 0 3
91897: STR
91898: ST_TO_ADDR
// end ;
91899: GO 91799
91901: POP
91902: POP
// for i = 1 to hardcoreCounter do
91903: LD_ADDR_VAR 0 8
91907: PUSH
91908: DOUBLE
91909: LD_INT 1
91911: DEC
91912: ST_TO_ADDR
91913: LD_EXP 106
91917: PUSH
91918: FOR_TO
91919: IFFALSE 92024
// begin tmp := 0 ;
91921: LD_ADDR_VAR 0 3
91925: PUSH
91926: LD_STRING 0
91928: ST_TO_ADDR
// if result [ 2 ] then
91929: LD_VAR 0 2
91933: PUSH
91934: LD_INT 2
91936: ARRAY
91937: IFFALSE 92006
// if result [ 2 ] [ 1 ] = 100 + i then
91939: LD_VAR 0 2
91943: PUSH
91944: LD_INT 2
91946: ARRAY
91947: PUSH
91948: LD_INT 1
91950: ARRAY
91951: PUSH
91952: LD_INT 100
91954: PUSH
91955: LD_VAR 0 8
91959: PLUS
91960: EQUAL
91961: IFFALSE 92006
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
91963: LD_ADDR_VAR 0 2
91967: PUSH
91968: LD_VAR 0 2
91972: PPUSH
91973: LD_INT 2
91975: PPUSH
91976: LD_VAR 0 2
91980: PUSH
91981: LD_INT 2
91983: ARRAY
91984: PPUSH
91985: LD_INT 1
91987: PPUSH
91988: CALL_OW 3
91992: PPUSH
91993: CALL_OW 1
91997: ST_TO_ADDR
// tmp := 1 ;
91998: LD_ADDR_VAR 0 3
92002: PUSH
92003: LD_STRING 1
92005: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
92006: LD_ADDR_VAR 0 6
92010: PUSH
92011: LD_VAR 0 6
92015: PUSH
92016: LD_VAR 0 3
92020: STR
92021: ST_TO_ADDR
// end ;
92022: GO 91918
92024: POP
92025: POP
// if isGameLoad then
92026: LD_VAR 0 1
92030: IFFALSE 92505
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
92032: LD_ADDR_VAR 0 4
92036: PUSH
92037: LD_EXP 109
92041: PUSH
92042: LD_EXP 108
92046: PUSH
92047: LD_EXP 110
92051: PUSH
92052: LD_EXP 107
92056: PUSH
92057: LD_EXP 111
92061: PUSH
92062: LD_EXP 112
92066: PUSH
92067: LD_EXP 113
92071: PUSH
92072: LD_EXP 114
92076: PUSH
92077: LD_EXP 115
92081: PUSH
92082: LD_EXP 116
92086: PUSH
92087: LD_EXP 117
92091: PUSH
92092: LD_EXP 118
92096: PUSH
92097: LD_EXP 119
92101: PUSH
92102: LD_EXP 120
92106: PUSH
92107: LD_EXP 128
92111: PUSH
92112: LD_EXP 129
92116: PUSH
92117: LD_EXP 130
92121: PUSH
92122: LD_EXP 131
92126: PUSH
92127: LD_EXP 133
92131: PUSH
92132: LD_EXP 134
92136: PUSH
92137: LD_EXP 135
92141: PUSH
92142: LD_EXP 138
92146: PUSH
92147: LD_EXP 140
92151: PUSH
92152: LD_EXP 141
92156: PUSH
92157: LD_EXP 142
92161: PUSH
92162: LD_EXP 144
92166: PUSH
92167: LD_EXP 145
92171: PUSH
92172: LD_EXP 148
92176: PUSH
92177: LD_EXP 149
92181: PUSH
92182: LD_EXP 150
92186: PUSH
92187: LD_EXP 151
92191: PUSH
92192: LD_EXP 152
92196: PUSH
92197: LD_EXP 153
92201: PUSH
92202: LD_EXP 154
92206: PUSH
92207: LD_EXP 155
92211: PUSH
92212: LD_EXP 156
92216: PUSH
92217: LD_EXP 121
92221: PUSH
92222: LD_EXP 122
92226: PUSH
92227: LD_EXP 125
92231: PUSH
92232: LD_EXP 126
92236: PUSH
92237: LD_EXP 127
92241: PUSH
92242: LD_EXP 123
92246: PUSH
92247: LD_EXP 124
92251: PUSH
92252: LD_EXP 132
92256: PUSH
92257: LD_EXP 136
92261: PUSH
92262: LD_EXP 137
92266: PUSH
92267: LD_EXP 139
92271: PUSH
92272: LD_EXP 143
92276: PUSH
92277: LD_EXP 146
92281: PUSH
92282: LD_EXP 147
92286: PUSH
92287: LD_EXP 157
92291: PUSH
92292: LD_EXP 158
92296: PUSH
92297: LD_EXP 159
92301: PUSH
92302: LD_EXP 160
92306: PUSH
92307: EMPTY
92308: LIST
92309: LIST
92310: LIST
92311: LIST
92312: LIST
92313: LIST
92314: LIST
92315: LIST
92316: LIST
92317: LIST
92318: LIST
92319: LIST
92320: LIST
92321: LIST
92322: LIST
92323: LIST
92324: LIST
92325: LIST
92326: LIST
92327: LIST
92328: LIST
92329: LIST
92330: LIST
92331: LIST
92332: LIST
92333: LIST
92334: LIST
92335: LIST
92336: LIST
92337: LIST
92338: LIST
92339: LIST
92340: LIST
92341: LIST
92342: LIST
92343: LIST
92344: LIST
92345: LIST
92346: LIST
92347: LIST
92348: LIST
92349: LIST
92350: LIST
92351: LIST
92352: LIST
92353: LIST
92354: LIST
92355: LIST
92356: LIST
92357: LIST
92358: LIST
92359: LIST
92360: LIST
92361: LIST
92362: ST_TO_ADDR
// tmp :=  ;
92363: LD_ADDR_VAR 0 3
92367: PUSH
92368: LD_STRING 
92370: ST_TO_ADDR
// for i = 1 to normalCounter do
92371: LD_ADDR_VAR 0 8
92375: PUSH
92376: DOUBLE
92377: LD_INT 1
92379: DEC
92380: ST_TO_ADDR
92381: LD_EXP 105
92385: PUSH
92386: FOR_TO
92387: IFFALSE 92423
// begin if flags [ i ] then
92389: LD_VAR 0 4
92393: PUSH
92394: LD_VAR 0 8
92398: ARRAY
92399: IFFALSE 92421
// tmp := tmp & i & ; ;
92401: LD_ADDR_VAR 0 3
92405: PUSH
92406: LD_VAR 0 3
92410: PUSH
92411: LD_VAR 0 8
92415: STR
92416: PUSH
92417: LD_STRING ;
92419: STR
92420: ST_TO_ADDR
// end ;
92421: GO 92386
92423: POP
92424: POP
// for i = 1 to hardcoreCounter do
92425: LD_ADDR_VAR 0 8
92429: PUSH
92430: DOUBLE
92431: LD_INT 1
92433: DEC
92434: ST_TO_ADDR
92435: LD_EXP 106
92439: PUSH
92440: FOR_TO
92441: IFFALSE 92487
// begin if flags [ normalCounter + i ] then
92443: LD_VAR 0 4
92447: PUSH
92448: LD_EXP 105
92452: PUSH
92453: LD_VAR 0 8
92457: PLUS
92458: ARRAY
92459: IFFALSE 92485
// tmp := tmp & ( 100 + i ) & ; ;
92461: LD_ADDR_VAR 0 3
92465: PUSH
92466: LD_VAR 0 3
92470: PUSH
92471: LD_INT 100
92473: PUSH
92474: LD_VAR 0 8
92478: PLUS
92479: STR
92480: PUSH
92481: LD_STRING ;
92483: STR
92484: ST_TO_ADDR
// end ;
92485: GO 92440
92487: POP
92488: POP
// if tmp then
92489: LD_VAR 0 3
92493: IFFALSE 92505
// active := tmp ;
92495: LD_ADDR_VAR 0 7
92499: PUSH
92500: LD_VAR 0 3
92504: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
92505: LD_STRING getStreamItemsFromMission("
92507: PUSH
92508: LD_VAR 0 5
92512: STR
92513: PUSH
92514: LD_STRING ","
92516: STR
92517: PUSH
92518: LD_VAR 0 6
92522: STR
92523: PUSH
92524: LD_STRING ","
92526: STR
92527: PUSH
92528: LD_VAR 0 7
92532: STR
92533: PUSH
92534: LD_STRING ")
92536: STR
92537: PPUSH
92538: CALL_OW 559
// end else
92542: GO 92551
// ToLua ( getStreamItemsFromMission("","","") ) ;
92544: LD_STRING getStreamItemsFromMission("","","")
92546: PPUSH
92547: CALL_OW 559
// end ;
92551: LD_VAR 0 2
92555: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
92556: LD_EXP 104
92560: PUSH
92561: LD_EXP 109
92565: AND
92566: IFFALSE 92690
92568: GO 92570
92570: DISABLE
92571: LD_INT 0
92573: PPUSH
92574: PPUSH
// begin enable ;
92575: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
92576: LD_ADDR_VAR 0 2
92580: PUSH
92581: LD_INT 22
92583: PUSH
92584: LD_OWVAR 2
92588: PUSH
92589: EMPTY
92590: LIST
92591: LIST
92592: PUSH
92593: LD_INT 2
92595: PUSH
92596: LD_INT 34
92598: PUSH
92599: LD_INT 7
92601: PUSH
92602: EMPTY
92603: LIST
92604: LIST
92605: PUSH
92606: LD_INT 34
92608: PUSH
92609: LD_INT 45
92611: PUSH
92612: EMPTY
92613: LIST
92614: LIST
92615: PUSH
92616: LD_INT 34
92618: PUSH
92619: LD_INT 28
92621: PUSH
92622: EMPTY
92623: LIST
92624: LIST
92625: PUSH
92626: LD_INT 34
92628: PUSH
92629: LD_INT 47
92631: PUSH
92632: EMPTY
92633: LIST
92634: LIST
92635: PUSH
92636: EMPTY
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: PUSH
92643: EMPTY
92644: LIST
92645: LIST
92646: PPUSH
92647: CALL_OW 69
92651: ST_TO_ADDR
// if not tmp then
92652: LD_VAR 0 2
92656: NOT
92657: IFFALSE 92661
// exit ;
92659: GO 92690
// for i in tmp do
92661: LD_ADDR_VAR 0 1
92665: PUSH
92666: LD_VAR 0 2
92670: PUSH
92671: FOR_IN
92672: IFFALSE 92688
// begin SetLives ( i , 0 ) ;
92674: LD_VAR 0 1
92678: PPUSH
92679: LD_INT 0
92681: PPUSH
92682: CALL_OW 234
// end ;
92686: GO 92671
92688: POP
92689: POP
// end ;
92690: PPOPN 2
92692: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
92693: LD_EXP 104
92697: PUSH
92698: LD_EXP 110
92702: AND
92703: IFFALSE 92787
92705: GO 92707
92707: DISABLE
92708: LD_INT 0
92710: PPUSH
92711: PPUSH
// begin enable ;
92712: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
92713: LD_ADDR_VAR 0 2
92717: PUSH
92718: LD_INT 22
92720: PUSH
92721: LD_OWVAR 2
92725: PUSH
92726: EMPTY
92727: LIST
92728: LIST
92729: PUSH
92730: LD_INT 32
92732: PUSH
92733: LD_INT 3
92735: PUSH
92736: EMPTY
92737: LIST
92738: LIST
92739: PUSH
92740: EMPTY
92741: LIST
92742: LIST
92743: PPUSH
92744: CALL_OW 69
92748: ST_TO_ADDR
// if not tmp then
92749: LD_VAR 0 2
92753: NOT
92754: IFFALSE 92758
// exit ;
92756: GO 92787
// for i in tmp do
92758: LD_ADDR_VAR 0 1
92762: PUSH
92763: LD_VAR 0 2
92767: PUSH
92768: FOR_IN
92769: IFFALSE 92785
// begin SetLives ( i , 0 ) ;
92771: LD_VAR 0 1
92775: PPUSH
92776: LD_INT 0
92778: PPUSH
92779: CALL_OW 234
// end ;
92783: GO 92768
92785: POP
92786: POP
// end ;
92787: PPOPN 2
92789: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
92790: LD_EXP 104
92794: PUSH
92795: LD_EXP 107
92799: AND
92800: IFFALSE 92893
92802: GO 92804
92804: DISABLE
92805: LD_INT 0
92807: PPUSH
// begin enable ;
92808: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
92809: LD_ADDR_VAR 0 1
92813: PUSH
92814: LD_INT 22
92816: PUSH
92817: LD_OWVAR 2
92821: PUSH
92822: EMPTY
92823: LIST
92824: LIST
92825: PUSH
92826: LD_INT 2
92828: PUSH
92829: LD_INT 25
92831: PUSH
92832: LD_INT 5
92834: PUSH
92835: EMPTY
92836: LIST
92837: LIST
92838: PUSH
92839: LD_INT 25
92841: PUSH
92842: LD_INT 9
92844: PUSH
92845: EMPTY
92846: LIST
92847: LIST
92848: PUSH
92849: LD_INT 25
92851: PUSH
92852: LD_INT 8
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: PUSH
92859: EMPTY
92860: LIST
92861: LIST
92862: LIST
92863: LIST
92864: PUSH
92865: EMPTY
92866: LIST
92867: LIST
92868: PPUSH
92869: CALL_OW 69
92873: PUSH
92874: FOR_IN
92875: IFFALSE 92891
// begin SetClass ( i , 1 ) ;
92877: LD_VAR 0 1
92881: PPUSH
92882: LD_INT 1
92884: PPUSH
92885: CALL_OW 336
// end ;
92889: GO 92874
92891: POP
92892: POP
// end ;
92893: PPOPN 1
92895: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
92896: LD_EXP 104
92900: PUSH
92901: LD_EXP 108
92905: AND
92906: PUSH
92907: LD_OWVAR 65
92911: PUSH
92912: LD_INT 7
92914: LESS
92915: AND
92916: IFFALSE 92930
92918: GO 92920
92920: DISABLE
// begin enable ;
92921: ENABLE
// game_speed := 7 ;
92922: LD_ADDR_OWVAR 65
92926: PUSH
92927: LD_INT 7
92929: ST_TO_ADDR
// end ;
92930: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
92931: LD_EXP 104
92935: PUSH
92936: LD_EXP 111
92940: AND
92941: IFFALSE 93143
92943: GO 92945
92945: DISABLE
92946: LD_INT 0
92948: PPUSH
92949: PPUSH
92950: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
92951: LD_ADDR_VAR 0 3
92955: PUSH
92956: LD_INT 81
92958: PUSH
92959: LD_OWVAR 2
92963: PUSH
92964: EMPTY
92965: LIST
92966: LIST
92967: PUSH
92968: LD_INT 21
92970: PUSH
92971: LD_INT 1
92973: PUSH
92974: EMPTY
92975: LIST
92976: LIST
92977: PUSH
92978: EMPTY
92979: LIST
92980: LIST
92981: PPUSH
92982: CALL_OW 69
92986: ST_TO_ADDR
// if not tmp then
92987: LD_VAR 0 3
92991: NOT
92992: IFFALSE 92996
// exit ;
92994: GO 93143
// if tmp > 5 then
92996: LD_VAR 0 3
93000: PUSH
93001: LD_INT 5
93003: GREATER
93004: IFFALSE 93016
// k := 5 else
93006: LD_ADDR_VAR 0 2
93010: PUSH
93011: LD_INT 5
93013: ST_TO_ADDR
93014: GO 93026
// k := tmp ;
93016: LD_ADDR_VAR 0 2
93020: PUSH
93021: LD_VAR 0 3
93025: ST_TO_ADDR
// for i := 1 to k do
93026: LD_ADDR_VAR 0 1
93030: PUSH
93031: DOUBLE
93032: LD_INT 1
93034: DEC
93035: ST_TO_ADDR
93036: LD_VAR 0 2
93040: PUSH
93041: FOR_TO
93042: IFFALSE 93141
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
93044: LD_VAR 0 3
93048: PUSH
93049: LD_VAR 0 1
93053: ARRAY
93054: PPUSH
93055: LD_VAR 0 1
93059: PUSH
93060: LD_INT 4
93062: MOD
93063: PUSH
93064: LD_INT 1
93066: PLUS
93067: PPUSH
93068: CALL_OW 259
93072: PUSH
93073: LD_INT 10
93075: LESS
93076: IFFALSE 93139
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
93078: LD_VAR 0 3
93082: PUSH
93083: LD_VAR 0 1
93087: ARRAY
93088: PPUSH
93089: LD_VAR 0 1
93093: PUSH
93094: LD_INT 4
93096: MOD
93097: PUSH
93098: LD_INT 1
93100: PLUS
93101: PPUSH
93102: LD_VAR 0 3
93106: PUSH
93107: LD_VAR 0 1
93111: ARRAY
93112: PPUSH
93113: LD_VAR 0 1
93117: PUSH
93118: LD_INT 4
93120: MOD
93121: PUSH
93122: LD_INT 1
93124: PLUS
93125: PPUSH
93126: CALL_OW 259
93130: PUSH
93131: LD_INT 1
93133: PLUS
93134: PPUSH
93135: CALL_OW 237
93139: GO 93041
93141: POP
93142: POP
// end ;
93143: PPOPN 3
93145: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
93146: LD_EXP 104
93150: PUSH
93151: LD_EXP 112
93155: AND
93156: IFFALSE 93176
93158: GO 93160
93160: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
93161: LD_INT 4
93163: PPUSH
93164: LD_OWVAR 2
93168: PPUSH
93169: LD_INT 0
93171: PPUSH
93172: CALL_OW 324
93176: END
// every 0 0$1 trigger StreamModeActive and sShovel do
93177: LD_EXP 104
93181: PUSH
93182: LD_EXP 141
93186: AND
93187: IFFALSE 93207
93189: GO 93191
93191: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
93192: LD_INT 19
93194: PPUSH
93195: LD_OWVAR 2
93199: PPUSH
93200: LD_INT 0
93202: PPUSH
93203: CALL_OW 324
93207: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
93208: LD_EXP 104
93212: PUSH
93213: LD_EXP 113
93217: AND
93218: IFFALSE 93320
93220: GO 93222
93222: DISABLE
93223: LD_INT 0
93225: PPUSH
93226: PPUSH
// begin enable ;
93227: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
93228: LD_ADDR_VAR 0 2
93232: PUSH
93233: LD_INT 22
93235: PUSH
93236: LD_OWVAR 2
93240: PUSH
93241: EMPTY
93242: LIST
93243: LIST
93244: PUSH
93245: LD_INT 2
93247: PUSH
93248: LD_INT 34
93250: PUSH
93251: LD_INT 11
93253: PUSH
93254: EMPTY
93255: LIST
93256: LIST
93257: PUSH
93258: LD_INT 34
93260: PUSH
93261: LD_INT 30
93263: PUSH
93264: EMPTY
93265: LIST
93266: LIST
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: LIST
93272: PUSH
93273: EMPTY
93274: LIST
93275: LIST
93276: PPUSH
93277: CALL_OW 69
93281: ST_TO_ADDR
// if not tmp then
93282: LD_VAR 0 2
93286: NOT
93287: IFFALSE 93291
// exit ;
93289: GO 93320
// for i in tmp do
93291: LD_ADDR_VAR 0 1
93295: PUSH
93296: LD_VAR 0 2
93300: PUSH
93301: FOR_IN
93302: IFFALSE 93318
// begin SetLives ( i , 0 ) ;
93304: LD_VAR 0 1
93308: PPUSH
93309: LD_INT 0
93311: PPUSH
93312: CALL_OW 234
// end ;
93316: GO 93301
93318: POP
93319: POP
// end ;
93320: PPOPN 2
93322: END
// every 0 0$1 trigger StreamModeActive and sBunker do
93323: LD_EXP 104
93327: PUSH
93328: LD_EXP 114
93332: AND
93333: IFFALSE 93353
93335: GO 93337
93337: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
93338: LD_INT 32
93340: PPUSH
93341: LD_OWVAR 2
93345: PPUSH
93346: LD_INT 0
93348: PPUSH
93349: CALL_OW 324
93353: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
93354: LD_EXP 104
93358: PUSH
93359: LD_EXP 115
93363: AND
93364: IFFALSE 93545
93366: GO 93368
93368: DISABLE
93369: LD_INT 0
93371: PPUSH
93372: PPUSH
93373: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
93374: LD_ADDR_VAR 0 2
93378: PUSH
93379: LD_INT 22
93381: PUSH
93382: LD_OWVAR 2
93386: PUSH
93387: EMPTY
93388: LIST
93389: LIST
93390: PUSH
93391: LD_INT 33
93393: PUSH
93394: LD_INT 3
93396: PUSH
93397: EMPTY
93398: LIST
93399: LIST
93400: PUSH
93401: EMPTY
93402: LIST
93403: LIST
93404: PPUSH
93405: CALL_OW 69
93409: ST_TO_ADDR
// if not tmp then
93410: LD_VAR 0 2
93414: NOT
93415: IFFALSE 93419
// exit ;
93417: GO 93545
// side := 0 ;
93419: LD_ADDR_VAR 0 3
93423: PUSH
93424: LD_INT 0
93426: ST_TO_ADDR
// for i := 1 to 8 do
93427: LD_ADDR_VAR 0 1
93431: PUSH
93432: DOUBLE
93433: LD_INT 1
93435: DEC
93436: ST_TO_ADDR
93437: LD_INT 8
93439: PUSH
93440: FOR_TO
93441: IFFALSE 93489
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
93443: LD_OWVAR 2
93447: PUSH
93448: LD_VAR 0 1
93452: NONEQUAL
93453: PUSH
93454: LD_OWVAR 2
93458: PPUSH
93459: LD_VAR 0 1
93463: PPUSH
93464: CALL_OW 81
93468: PUSH
93469: LD_INT 2
93471: EQUAL
93472: AND
93473: IFFALSE 93487
// begin side := i ;
93475: LD_ADDR_VAR 0 3
93479: PUSH
93480: LD_VAR 0 1
93484: ST_TO_ADDR
// break ;
93485: GO 93489
// end ;
93487: GO 93440
93489: POP
93490: POP
// if not side then
93491: LD_VAR 0 3
93495: NOT
93496: IFFALSE 93500
// exit ;
93498: GO 93545
// for i := 1 to tmp do
93500: LD_ADDR_VAR 0 1
93504: PUSH
93505: DOUBLE
93506: LD_INT 1
93508: DEC
93509: ST_TO_ADDR
93510: LD_VAR 0 2
93514: PUSH
93515: FOR_TO
93516: IFFALSE 93543
// if Prob ( 60 ) then
93518: LD_INT 60
93520: PPUSH
93521: CALL_OW 13
93525: IFFALSE 93541
// SetSide ( i , side ) ;
93527: LD_VAR 0 1
93531: PPUSH
93532: LD_VAR 0 3
93536: PPUSH
93537: CALL_OW 235
93541: GO 93515
93543: POP
93544: POP
// end ;
93545: PPOPN 3
93547: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
93548: LD_EXP 104
93552: PUSH
93553: LD_EXP 117
93557: AND
93558: IFFALSE 93677
93560: GO 93562
93562: DISABLE
93563: LD_INT 0
93565: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
93566: LD_ADDR_VAR 0 1
93570: PUSH
93571: LD_INT 22
93573: PUSH
93574: LD_OWVAR 2
93578: PUSH
93579: EMPTY
93580: LIST
93581: LIST
93582: PUSH
93583: LD_INT 21
93585: PUSH
93586: LD_INT 1
93588: PUSH
93589: EMPTY
93590: LIST
93591: LIST
93592: PUSH
93593: LD_INT 3
93595: PUSH
93596: LD_INT 23
93598: PUSH
93599: LD_INT 0
93601: PUSH
93602: EMPTY
93603: LIST
93604: LIST
93605: PUSH
93606: EMPTY
93607: LIST
93608: LIST
93609: PUSH
93610: EMPTY
93611: LIST
93612: LIST
93613: LIST
93614: PPUSH
93615: CALL_OW 69
93619: PUSH
93620: FOR_IN
93621: IFFALSE 93675
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
93623: LD_VAR 0 1
93627: PPUSH
93628: CALL_OW 257
93632: PUSH
93633: LD_INT 1
93635: PUSH
93636: LD_INT 2
93638: PUSH
93639: LD_INT 3
93641: PUSH
93642: LD_INT 4
93644: PUSH
93645: EMPTY
93646: LIST
93647: LIST
93648: LIST
93649: LIST
93650: IN
93651: IFFALSE 93673
// SetClass ( un , rand ( 1 , 4 ) ) ;
93653: LD_VAR 0 1
93657: PPUSH
93658: LD_INT 1
93660: PPUSH
93661: LD_INT 4
93663: PPUSH
93664: CALL_OW 12
93668: PPUSH
93669: CALL_OW 336
93673: GO 93620
93675: POP
93676: POP
// end ;
93677: PPOPN 1
93679: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
93680: LD_EXP 104
93684: PUSH
93685: LD_EXP 116
93689: AND
93690: IFFALSE 93769
93692: GO 93694
93694: DISABLE
93695: LD_INT 0
93697: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93698: LD_ADDR_VAR 0 1
93702: PUSH
93703: LD_INT 22
93705: PUSH
93706: LD_OWVAR 2
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: PUSH
93715: LD_INT 21
93717: PUSH
93718: LD_INT 3
93720: PUSH
93721: EMPTY
93722: LIST
93723: LIST
93724: PUSH
93725: EMPTY
93726: LIST
93727: LIST
93728: PPUSH
93729: CALL_OW 69
93733: ST_TO_ADDR
// if not tmp then
93734: LD_VAR 0 1
93738: NOT
93739: IFFALSE 93743
// exit ;
93741: GO 93769
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
93743: LD_VAR 0 1
93747: PUSH
93748: LD_INT 1
93750: PPUSH
93751: LD_VAR 0 1
93755: PPUSH
93756: CALL_OW 12
93760: ARRAY
93761: PPUSH
93762: LD_INT 100
93764: PPUSH
93765: CALL_OW 234
// end ;
93769: PPOPN 1
93771: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
93772: LD_EXP 104
93776: PUSH
93777: LD_EXP 118
93781: AND
93782: IFFALSE 93880
93784: GO 93786
93786: DISABLE
93787: LD_INT 0
93789: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93790: LD_ADDR_VAR 0 1
93794: PUSH
93795: LD_INT 22
93797: PUSH
93798: LD_OWVAR 2
93802: PUSH
93803: EMPTY
93804: LIST
93805: LIST
93806: PUSH
93807: LD_INT 21
93809: PUSH
93810: LD_INT 1
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: PUSH
93817: EMPTY
93818: LIST
93819: LIST
93820: PPUSH
93821: CALL_OW 69
93825: ST_TO_ADDR
// if not tmp then
93826: LD_VAR 0 1
93830: NOT
93831: IFFALSE 93835
// exit ;
93833: GO 93880
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
93835: LD_VAR 0 1
93839: PUSH
93840: LD_INT 1
93842: PPUSH
93843: LD_VAR 0 1
93847: PPUSH
93848: CALL_OW 12
93852: ARRAY
93853: PPUSH
93854: LD_INT 1
93856: PPUSH
93857: LD_INT 4
93859: PPUSH
93860: CALL_OW 12
93864: PPUSH
93865: LD_INT 3000
93867: PPUSH
93868: LD_INT 9000
93870: PPUSH
93871: CALL_OW 12
93875: PPUSH
93876: CALL_OW 492
// end ;
93880: PPOPN 1
93882: END
// every 0 0$1 trigger StreamModeActive and sDepot do
93883: LD_EXP 104
93887: PUSH
93888: LD_EXP 119
93892: AND
93893: IFFALSE 93913
93895: GO 93897
93897: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
93898: LD_INT 1
93900: PPUSH
93901: LD_OWVAR 2
93905: PPUSH
93906: LD_INT 0
93908: PPUSH
93909: CALL_OW 324
93913: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
93914: LD_EXP 104
93918: PUSH
93919: LD_EXP 120
93923: AND
93924: IFFALSE 94007
93926: GO 93928
93928: DISABLE
93929: LD_INT 0
93931: PPUSH
93932: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93933: LD_ADDR_VAR 0 2
93937: PUSH
93938: LD_INT 22
93940: PUSH
93941: LD_OWVAR 2
93945: PUSH
93946: EMPTY
93947: LIST
93948: LIST
93949: PUSH
93950: LD_INT 21
93952: PUSH
93953: LD_INT 3
93955: PUSH
93956: EMPTY
93957: LIST
93958: LIST
93959: PUSH
93960: EMPTY
93961: LIST
93962: LIST
93963: PPUSH
93964: CALL_OW 69
93968: ST_TO_ADDR
// if not tmp then
93969: LD_VAR 0 2
93973: NOT
93974: IFFALSE 93978
// exit ;
93976: GO 94007
// for i in tmp do
93978: LD_ADDR_VAR 0 1
93982: PUSH
93983: LD_VAR 0 2
93987: PUSH
93988: FOR_IN
93989: IFFALSE 94005
// SetBLevel ( i , 10 ) ;
93991: LD_VAR 0 1
93995: PPUSH
93996: LD_INT 10
93998: PPUSH
93999: CALL_OW 241
94003: GO 93988
94005: POP
94006: POP
// end ;
94007: PPOPN 2
94009: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
94010: LD_EXP 104
94014: PUSH
94015: LD_EXP 121
94019: AND
94020: IFFALSE 94131
94022: GO 94024
94024: DISABLE
94025: LD_INT 0
94027: PPUSH
94028: PPUSH
94029: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94030: LD_ADDR_VAR 0 3
94034: PUSH
94035: LD_INT 22
94037: PUSH
94038: LD_OWVAR 2
94042: PUSH
94043: EMPTY
94044: LIST
94045: LIST
94046: PUSH
94047: LD_INT 25
94049: PUSH
94050: LD_INT 1
94052: PUSH
94053: EMPTY
94054: LIST
94055: LIST
94056: PUSH
94057: EMPTY
94058: LIST
94059: LIST
94060: PPUSH
94061: CALL_OW 69
94065: ST_TO_ADDR
// if not tmp then
94066: LD_VAR 0 3
94070: NOT
94071: IFFALSE 94075
// exit ;
94073: GO 94131
// un := tmp [ rand ( 1 , tmp ) ] ;
94075: LD_ADDR_VAR 0 2
94079: PUSH
94080: LD_VAR 0 3
94084: PUSH
94085: LD_INT 1
94087: PPUSH
94088: LD_VAR 0 3
94092: PPUSH
94093: CALL_OW 12
94097: ARRAY
94098: ST_TO_ADDR
// if Crawls ( un ) then
94099: LD_VAR 0 2
94103: PPUSH
94104: CALL_OW 318
94108: IFFALSE 94119
// ComWalk ( un ) ;
94110: LD_VAR 0 2
94114: PPUSH
94115: CALL_OW 138
// SetClass ( un , class_sniper ) ;
94119: LD_VAR 0 2
94123: PPUSH
94124: LD_INT 5
94126: PPUSH
94127: CALL_OW 336
// end ;
94131: PPOPN 3
94133: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
94134: LD_EXP 104
94138: PUSH
94139: LD_EXP 122
94143: AND
94144: PUSH
94145: LD_OWVAR 67
94149: PUSH
94150: LD_INT 4
94152: LESS
94153: AND
94154: IFFALSE 94173
94156: GO 94158
94158: DISABLE
// begin Difficulty := Difficulty + 1 ;
94159: LD_ADDR_OWVAR 67
94163: PUSH
94164: LD_OWVAR 67
94168: PUSH
94169: LD_INT 1
94171: PLUS
94172: ST_TO_ADDR
// end ;
94173: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
94174: LD_EXP 104
94178: PUSH
94179: LD_EXP 123
94183: AND
94184: IFFALSE 94287
94186: GO 94188
94188: DISABLE
94189: LD_INT 0
94191: PPUSH
// begin for i := 1 to 5 do
94192: LD_ADDR_VAR 0 1
94196: PUSH
94197: DOUBLE
94198: LD_INT 1
94200: DEC
94201: ST_TO_ADDR
94202: LD_INT 5
94204: PUSH
94205: FOR_TO
94206: IFFALSE 94285
// begin uc_nation := nation_nature ;
94208: LD_ADDR_OWVAR 21
94212: PUSH
94213: LD_INT 0
94215: ST_TO_ADDR
// uc_side := 0 ;
94216: LD_ADDR_OWVAR 20
94220: PUSH
94221: LD_INT 0
94223: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94224: LD_ADDR_OWVAR 29
94228: PUSH
94229: LD_INT 12
94231: PUSH
94232: LD_INT 12
94234: PUSH
94235: EMPTY
94236: LIST
94237: LIST
94238: ST_TO_ADDR
// hc_agressivity := 20 ;
94239: LD_ADDR_OWVAR 35
94243: PUSH
94244: LD_INT 20
94246: ST_TO_ADDR
// hc_class := class_tiger ;
94247: LD_ADDR_OWVAR 28
94251: PUSH
94252: LD_INT 14
94254: ST_TO_ADDR
// hc_gallery :=  ;
94255: LD_ADDR_OWVAR 33
94259: PUSH
94260: LD_STRING 
94262: ST_TO_ADDR
// hc_name :=  ;
94263: LD_ADDR_OWVAR 26
94267: PUSH
94268: LD_STRING 
94270: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
94271: CALL_OW 44
94275: PPUSH
94276: LD_INT 0
94278: PPUSH
94279: CALL_OW 51
// end ;
94283: GO 94205
94285: POP
94286: POP
// end ;
94287: PPOPN 1
94289: END
// every 0 0$1 trigger StreamModeActive and sBomb do
94290: LD_EXP 104
94294: PUSH
94295: LD_EXP 124
94299: AND
94300: IFFALSE 94309
94302: GO 94304
94304: DISABLE
// StreamSibBomb ;
94305: CALL 94310 0 0
94309: END
// export function StreamSibBomb ; var i , x , y ; begin
94310: LD_INT 0
94312: PPUSH
94313: PPUSH
94314: PPUSH
94315: PPUSH
// result := false ;
94316: LD_ADDR_VAR 0 1
94320: PUSH
94321: LD_INT 0
94323: ST_TO_ADDR
// for i := 1 to 16 do
94324: LD_ADDR_VAR 0 2
94328: PUSH
94329: DOUBLE
94330: LD_INT 1
94332: DEC
94333: ST_TO_ADDR
94334: LD_INT 16
94336: PUSH
94337: FOR_TO
94338: IFFALSE 94537
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94340: LD_ADDR_VAR 0 3
94344: PUSH
94345: LD_INT 10
94347: PUSH
94348: LD_INT 20
94350: PUSH
94351: LD_INT 30
94353: PUSH
94354: LD_INT 40
94356: PUSH
94357: LD_INT 50
94359: PUSH
94360: LD_INT 60
94362: PUSH
94363: LD_INT 70
94365: PUSH
94366: LD_INT 80
94368: PUSH
94369: LD_INT 90
94371: PUSH
94372: LD_INT 100
94374: PUSH
94375: LD_INT 110
94377: PUSH
94378: LD_INT 120
94380: PUSH
94381: LD_INT 130
94383: PUSH
94384: LD_INT 140
94386: PUSH
94387: LD_INT 150
94389: PUSH
94390: EMPTY
94391: LIST
94392: LIST
94393: LIST
94394: LIST
94395: LIST
94396: LIST
94397: LIST
94398: LIST
94399: LIST
94400: LIST
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: PUSH
94407: LD_INT 1
94409: PPUSH
94410: LD_INT 15
94412: PPUSH
94413: CALL_OW 12
94417: ARRAY
94418: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94419: LD_ADDR_VAR 0 4
94423: PUSH
94424: LD_INT 10
94426: PUSH
94427: LD_INT 20
94429: PUSH
94430: LD_INT 30
94432: PUSH
94433: LD_INT 40
94435: PUSH
94436: LD_INT 50
94438: PUSH
94439: LD_INT 60
94441: PUSH
94442: LD_INT 70
94444: PUSH
94445: LD_INT 80
94447: PUSH
94448: LD_INT 90
94450: PUSH
94451: LD_INT 100
94453: PUSH
94454: LD_INT 110
94456: PUSH
94457: LD_INT 120
94459: PUSH
94460: LD_INT 130
94462: PUSH
94463: LD_INT 140
94465: PUSH
94466: LD_INT 150
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: PUSH
94486: LD_INT 1
94488: PPUSH
94489: LD_INT 15
94491: PPUSH
94492: CALL_OW 12
94496: ARRAY
94497: ST_TO_ADDR
// if ValidHex ( x , y ) then
94498: LD_VAR 0 3
94502: PPUSH
94503: LD_VAR 0 4
94507: PPUSH
94508: CALL_OW 488
94512: IFFALSE 94535
// begin result := [ x , y ] ;
94514: LD_ADDR_VAR 0 1
94518: PUSH
94519: LD_VAR 0 3
94523: PUSH
94524: LD_VAR 0 4
94528: PUSH
94529: EMPTY
94530: LIST
94531: LIST
94532: ST_TO_ADDR
// break ;
94533: GO 94537
// end ; end ;
94535: GO 94337
94537: POP
94538: POP
// if result then
94539: LD_VAR 0 1
94543: IFFALSE 94603
// begin ToLua ( playSibBomb() ) ;
94545: LD_STRING playSibBomb()
94547: PPUSH
94548: CALL_OW 559
// wait ( 0 0$14 ) ;
94552: LD_INT 490
94554: PPUSH
94555: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
94559: LD_VAR 0 1
94563: PUSH
94564: LD_INT 1
94566: ARRAY
94567: PPUSH
94568: LD_VAR 0 1
94572: PUSH
94573: LD_INT 2
94575: ARRAY
94576: PPUSH
94577: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
94581: LD_VAR 0 1
94585: PUSH
94586: LD_INT 1
94588: ARRAY
94589: PPUSH
94590: LD_VAR 0 1
94594: PUSH
94595: LD_INT 2
94597: ARRAY
94598: PPUSH
94599: CALL_OW 429
// end ; end ;
94603: LD_VAR 0 1
94607: RET
// every 0 0$1 trigger StreamModeActive and sReset do
94608: LD_EXP 104
94612: PUSH
94613: LD_EXP 126
94617: AND
94618: IFFALSE 94630
94620: GO 94622
94622: DISABLE
// YouLost (  ) ;
94623: LD_STRING 
94625: PPUSH
94626: CALL_OW 104
94630: END
// every 0 0$1 trigger StreamModeActive and sFog do
94631: LD_EXP 104
94635: PUSH
94636: LD_EXP 125
94640: AND
94641: IFFALSE 94655
94643: GO 94645
94645: DISABLE
// FogOff ( your_side ) ;
94646: LD_OWVAR 2
94650: PPUSH
94651: CALL_OW 344
94655: END
// every 0 0$1 trigger StreamModeActive and sSun do
94656: LD_EXP 104
94660: PUSH
94661: LD_EXP 127
94665: AND
94666: IFFALSE 94694
94668: GO 94670
94670: DISABLE
// begin solar_recharge_percent := 0 ;
94671: LD_ADDR_OWVAR 79
94675: PUSH
94676: LD_INT 0
94678: ST_TO_ADDR
// wait ( 5 5$00 ) ;
94679: LD_INT 10500
94681: PPUSH
94682: CALL_OW 67
// solar_recharge_percent := 100 ;
94686: LD_ADDR_OWVAR 79
94690: PUSH
94691: LD_INT 100
94693: ST_TO_ADDR
// end ;
94694: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
94695: LD_EXP 104
94699: PUSH
94700: LD_EXP 128
94704: AND
94705: IFFALSE 94944
94707: GO 94709
94709: DISABLE
94710: LD_INT 0
94712: PPUSH
94713: PPUSH
94714: PPUSH
// begin tmp := [ ] ;
94715: LD_ADDR_VAR 0 3
94719: PUSH
94720: EMPTY
94721: ST_TO_ADDR
// for i := 1 to 6 do
94722: LD_ADDR_VAR 0 1
94726: PUSH
94727: DOUBLE
94728: LD_INT 1
94730: DEC
94731: ST_TO_ADDR
94732: LD_INT 6
94734: PUSH
94735: FOR_TO
94736: IFFALSE 94841
// begin uc_nation := nation_nature ;
94738: LD_ADDR_OWVAR 21
94742: PUSH
94743: LD_INT 0
94745: ST_TO_ADDR
// uc_side := 0 ;
94746: LD_ADDR_OWVAR 20
94750: PUSH
94751: LD_INT 0
94753: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94754: LD_ADDR_OWVAR 29
94758: PUSH
94759: LD_INT 12
94761: PUSH
94762: LD_INT 12
94764: PUSH
94765: EMPTY
94766: LIST
94767: LIST
94768: ST_TO_ADDR
// hc_agressivity := 20 ;
94769: LD_ADDR_OWVAR 35
94773: PUSH
94774: LD_INT 20
94776: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
94777: LD_ADDR_OWVAR 28
94781: PUSH
94782: LD_INT 17
94784: ST_TO_ADDR
// hc_gallery :=  ;
94785: LD_ADDR_OWVAR 33
94789: PUSH
94790: LD_STRING 
94792: ST_TO_ADDR
// hc_name :=  ;
94793: LD_ADDR_OWVAR 26
94797: PUSH
94798: LD_STRING 
94800: ST_TO_ADDR
// un := CreateHuman ;
94801: LD_ADDR_VAR 0 2
94805: PUSH
94806: CALL_OW 44
94810: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
94811: LD_VAR 0 2
94815: PPUSH
94816: LD_INT 1
94818: PPUSH
94819: CALL_OW 51
// tmp := tmp ^ un ;
94823: LD_ADDR_VAR 0 3
94827: PUSH
94828: LD_VAR 0 3
94832: PUSH
94833: LD_VAR 0 2
94837: ADD
94838: ST_TO_ADDR
// end ;
94839: GO 94735
94841: POP
94842: POP
// repeat wait ( 0 0$1 ) ;
94843: LD_INT 35
94845: PPUSH
94846: CALL_OW 67
// for un in tmp do
94850: LD_ADDR_VAR 0 2
94854: PUSH
94855: LD_VAR 0 3
94859: PUSH
94860: FOR_IN
94861: IFFALSE 94935
// begin if IsDead ( un ) then
94863: LD_VAR 0 2
94867: PPUSH
94868: CALL_OW 301
94872: IFFALSE 94892
// begin tmp := tmp diff un ;
94874: LD_ADDR_VAR 0 3
94878: PUSH
94879: LD_VAR 0 3
94883: PUSH
94884: LD_VAR 0 2
94888: DIFF
94889: ST_TO_ADDR
// continue ;
94890: GO 94860
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
94892: LD_VAR 0 2
94896: PPUSH
94897: LD_INT 3
94899: PUSH
94900: LD_INT 22
94902: PUSH
94903: LD_INT 0
94905: PUSH
94906: EMPTY
94907: LIST
94908: LIST
94909: PUSH
94910: EMPTY
94911: LIST
94912: LIST
94913: PPUSH
94914: CALL_OW 69
94918: PPUSH
94919: LD_VAR 0 2
94923: PPUSH
94924: CALL_OW 74
94928: PPUSH
94929: CALL_OW 115
// end ;
94933: GO 94860
94935: POP
94936: POP
// until not tmp ;
94937: LD_VAR 0 3
94941: NOT
94942: IFFALSE 94843
// end ;
94944: PPOPN 3
94946: END
// every 0 0$1 trigger StreamModeActive and sTroll do
94947: LD_EXP 104
94951: PUSH
94952: LD_EXP 129
94956: AND
94957: IFFALSE 95011
94959: GO 94961
94961: DISABLE
// begin ToLua ( displayTroll(); ) ;
94962: LD_STRING displayTroll();
94964: PPUSH
94965: CALL_OW 559
// wait ( 3 3$00 ) ;
94969: LD_INT 6300
94971: PPUSH
94972: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94976: LD_STRING hideTroll();
94978: PPUSH
94979: CALL_OW 559
// wait ( 1 1$00 ) ;
94983: LD_INT 2100
94985: PPUSH
94986: CALL_OW 67
// ToLua ( displayTroll(); ) ;
94990: LD_STRING displayTroll();
94992: PPUSH
94993: CALL_OW 559
// wait ( 1 1$00 ) ;
94997: LD_INT 2100
94999: PPUSH
95000: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95004: LD_STRING hideTroll();
95006: PPUSH
95007: CALL_OW 559
// end ;
95011: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
95012: LD_EXP 104
95016: PUSH
95017: LD_EXP 130
95021: AND
95022: IFFALSE 95085
95024: GO 95026
95026: DISABLE
95027: LD_INT 0
95029: PPUSH
// begin p := 0 ;
95030: LD_ADDR_VAR 0 1
95034: PUSH
95035: LD_INT 0
95037: ST_TO_ADDR
// repeat game_speed := 1 ;
95038: LD_ADDR_OWVAR 65
95042: PUSH
95043: LD_INT 1
95045: ST_TO_ADDR
// wait ( 0 0$1 ) ;
95046: LD_INT 35
95048: PPUSH
95049: CALL_OW 67
// p := p + 1 ;
95053: LD_ADDR_VAR 0 1
95057: PUSH
95058: LD_VAR 0 1
95062: PUSH
95063: LD_INT 1
95065: PLUS
95066: ST_TO_ADDR
// until p >= 60 ;
95067: LD_VAR 0 1
95071: PUSH
95072: LD_INT 60
95074: GREATEREQUAL
95075: IFFALSE 95038
// game_speed := 4 ;
95077: LD_ADDR_OWVAR 65
95081: PUSH
95082: LD_INT 4
95084: ST_TO_ADDR
// end ;
95085: PPOPN 1
95087: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
95088: LD_EXP 104
95092: PUSH
95093: LD_EXP 131
95097: AND
95098: IFFALSE 95244
95100: GO 95102
95102: DISABLE
95103: LD_INT 0
95105: PPUSH
95106: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95107: LD_ADDR_VAR 0 1
95111: PUSH
95112: LD_INT 22
95114: PUSH
95115: LD_OWVAR 2
95119: PUSH
95120: EMPTY
95121: LIST
95122: LIST
95123: PUSH
95124: LD_INT 2
95126: PUSH
95127: LD_INT 30
95129: PUSH
95130: LD_INT 0
95132: PUSH
95133: EMPTY
95134: LIST
95135: LIST
95136: PUSH
95137: LD_INT 30
95139: PUSH
95140: LD_INT 1
95142: PUSH
95143: EMPTY
95144: LIST
95145: LIST
95146: PUSH
95147: EMPTY
95148: LIST
95149: LIST
95150: LIST
95151: PUSH
95152: EMPTY
95153: LIST
95154: LIST
95155: PPUSH
95156: CALL_OW 69
95160: ST_TO_ADDR
// if not depot then
95161: LD_VAR 0 1
95165: NOT
95166: IFFALSE 95170
// exit ;
95168: GO 95244
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
95170: LD_ADDR_VAR 0 2
95174: PUSH
95175: LD_VAR 0 1
95179: PUSH
95180: LD_INT 1
95182: PPUSH
95183: LD_VAR 0 1
95187: PPUSH
95188: CALL_OW 12
95192: ARRAY
95193: PPUSH
95194: CALL_OW 274
95198: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
95199: LD_VAR 0 2
95203: PPUSH
95204: LD_INT 1
95206: PPUSH
95207: LD_INT 0
95209: PPUSH
95210: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
95214: LD_VAR 0 2
95218: PPUSH
95219: LD_INT 2
95221: PPUSH
95222: LD_INT 0
95224: PPUSH
95225: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
95229: LD_VAR 0 2
95233: PPUSH
95234: LD_INT 3
95236: PPUSH
95237: LD_INT 0
95239: PPUSH
95240: CALL_OW 277
// end ;
95244: PPOPN 2
95246: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
95247: LD_EXP 104
95251: PUSH
95252: LD_EXP 132
95256: AND
95257: IFFALSE 95354
95259: GO 95261
95261: DISABLE
95262: LD_INT 0
95264: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95265: LD_ADDR_VAR 0 1
95269: PUSH
95270: LD_INT 22
95272: PUSH
95273: LD_OWVAR 2
95277: PUSH
95278: EMPTY
95279: LIST
95280: LIST
95281: PUSH
95282: LD_INT 21
95284: PUSH
95285: LD_INT 1
95287: PUSH
95288: EMPTY
95289: LIST
95290: LIST
95291: PUSH
95292: LD_INT 3
95294: PUSH
95295: LD_INT 23
95297: PUSH
95298: LD_INT 0
95300: PUSH
95301: EMPTY
95302: LIST
95303: LIST
95304: PUSH
95305: EMPTY
95306: LIST
95307: LIST
95308: PUSH
95309: EMPTY
95310: LIST
95311: LIST
95312: LIST
95313: PPUSH
95314: CALL_OW 69
95318: ST_TO_ADDR
// if not tmp then
95319: LD_VAR 0 1
95323: NOT
95324: IFFALSE 95328
// exit ;
95326: GO 95354
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
95328: LD_VAR 0 1
95332: PUSH
95333: LD_INT 1
95335: PPUSH
95336: LD_VAR 0 1
95340: PPUSH
95341: CALL_OW 12
95345: ARRAY
95346: PPUSH
95347: LD_INT 200
95349: PPUSH
95350: CALL_OW 234
// end ;
95354: PPOPN 1
95356: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
95357: LD_EXP 104
95361: PUSH
95362: LD_EXP 133
95366: AND
95367: IFFALSE 95446
95369: GO 95371
95371: DISABLE
95372: LD_INT 0
95374: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
95375: LD_ADDR_VAR 0 1
95379: PUSH
95380: LD_INT 22
95382: PUSH
95383: LD_OWVAR 2
95387: PUSH
95388: EMPTY
95389: LIST
95390: LIST
95391: PUSH
95392: LD_INT 21
95394: PUSH
95395: LD_INT 2
95397: PUSH
95398: EMPTY
95399: LIST
95400: LIST
95401: PUSH
95402: EMPTY
95403: LIST
95404: LIST
95405: PPUSH
95406: CALL_OW 69
95410: ST_TO_ADDR
// if not tmp then
95411: LD_VAR 0 1
95415: NOT
95416: IFFALSE 95420
// exit ;
95418: GO 95446
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
95420: LD_VAR 0 1
95424: PUSH
95425: LD_INT 1
95427: PPUSH
95428: LD_VAR 0 1
95432: PPUSH
95433: CALL_OW 12
95437: ARRAY
95438: PPUSH
95439: LD_INT 60
95441: PPUSH
95442: CALL_OW 234
// end ;
95446: PPOPN 1
95448: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
95449: LD_EXP 104
95453: PUSH
95454: LD_EXP 134
95458: AND
95459: IFFALSE 95558
95461: GO 95463
95463: DISABLE
95464: LD_INT 0
95466: PPUSH
95467: PPUSH
// begin enable ;
95468: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
95469: LD_ADDR_VAR 0 1
95473: PUSH
95474: LD_INT 22
95476: PUSH
95477: LD_OWVAR 2
95481: PUSH
95482: EMPTY
95483: LIST
95484: LIST
95485: PUSH
95486: LD_INT 61
95488: PUSH
95489: EMPTY
95490: LIST
95491: PUSH
95492: LD_INT 33
95494: PUSH
95495: LD_INT 2
95497: PUSH
95498: EMPTY
95499: LIST
95500: LIST
95501: PUSH
95502: EMPTY
95503: LIST
95504: LIST
95505: LIST
95506: PPUSH
95507: CALL_OW 69
95511: ST_TO_ADDR
// if not tmp then
95512: LD_VAR 0 1
95516: NOT
95517: IFFALSE 95521
// exit ;
95519: GO 95558
// for i in tmp do
95521: LD_ADDR_VAR 0 2
95525: PUSH
95526: LD_VAR 0 1
95530: PUSH
95531: FOR_IN
95532: IFFALSE 95556
// if IsControledBy ( i ) then
95534: LD_VAR 0 2
95538: PPUSH
95539: CALL_OW 312
95543: IFFALSE 95554
// ComUnlink ( i ) ;
95545: LD_VAR 0 2
95549: PPUSH
95550: CALL_OW 136
95554: GO 95531
95556: POP
95557: POP
// end ;
95558: PPOPN 2
95560: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
95561: LD_EXP 104
95565: PUSH
95566: LD_EXP 135
95570: AND
95571: IFFALSE 95711
95573: GO 95575
95575: DISABLE
95576: LD_INT 0
95578: PPUSH
95579: PPUSH
// begin ToLua ( displayPowell(); ) ;
95580: LD_STRING displayPowell();
95582: PPUSH
95583: CALL_OW 559
// uc_side := 0 ;
95587: LD_ADDR_OWVAR 20
95591: PUSH
95592: LD_INT 0
95594: ST_TO_ADDR
// uc_nation := 2 ;
95595: LD_ADDR_OWVAR 21
95599: PUSH
95600: LD_INT 2
95602: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
95603: LD_ADDR_OWVAR 37
95607: PUSH
95608: LD_INT 14
95610: ST_TO_ADDR
// vc_engine := engine_siberite ;
95611: LD_ADDR_OWVAR 39
95615: PUSH
95616: LD_INT 3
95618: ST_TO_ADDR
// vc_control := control_apeman ;
95619: LD_ADDR_OWVAR 38
95623: PUSH
95624: LD_INT 5
95626: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
95627: LD_ADDR_OWVAR 40
95631: PUSH
95632: LD_INT 29
95634: ST_TO_ADDR
// un := CreateVehicle ;
95635: LD_ADDR_VAR 0 2
95639: PUSH
95640: CALL_OW 45
95644: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95645: LD_VAR 0 2
95649: PPUSH
95650: LD_INT 1
95652: PPUSH
95653: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95657: LD_INT 35
95659: PPUSH
95660: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95664: LD_VAR 0 2
95668: PPUSH
95669: LD_INT 22
95671: PUSH
95672: LD_OWVAR 2
95676: PUSH
95677: EMPTY
95678: LIST
95679: LIST
95680: PPUSH
95681: CALL_OW 69
95685: PPUSH
95686: LD_VAR 0 2
95690: PPUSH
95691: CALL_OW 74
95695: PPUSH
95696: CALL_OW 115
// until IsDead ( un ) ;
95700: LD_VAR 0 2
95704: PPUSH
95705: CALL_OW 301
95709: IFFALSE 95657
// end ;
95711: PPOPN 2
95713: END
// every 0 0$1 trigger StreamModeActive and sStu do
95714: LD_EXP 104
95718: PUSH
95719: LD_EXP 143
95723: AND
95724: IFFALSE 95740
95726: GO 95728
95728: DISABLE
// begin ToLua ( displayStucuk(); ) ;
95729: LD_STRING displayStucuk();
95731: PPUSH
95732: CALL_OW 559
// ResetFog ;
95736: CALL_OW 335
// end ;
95740: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
95741: LD_EXP 104
95745: PUSH
95746: LD_EXP 136
95750: AND
95751: IFFALSE 95892
95753: GO 95755
95755: DISABLE
95756: LD_INT 0
95758: PPUSH
95759: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95760: LD_ADDR_VAR 0 2
95764: PUSH
95765: LD_INT 22
95767: PUSH
95768: LD_OWVAR 2
95772: PUSH
95773: EMPTY
95774: LIST
95775: LIST
95776: PUSH
95777: LD_INT 21
95779: PUSH
95780: LD_INT 1
95782: PUSH
95783: EMPTY
95784: LIST
95785: LIST
95786: PUSH
95787: EMPTY
95788: LIST
95789: LIST
95790: PPUSH
95791: CALL_OW 69
95795: ST_TO_ADDR
// if not tmp then
95796: LD_VAR 0 2
95800: NOT
95801: IFFALSE 95805
// exit ;
95803: GO 95892
// un := tmp [ rand ( 1 , tmp ) ] ;
95805: LD_ADDR_VAR 0 1
95809: PUSH
95810: LD_VAR 0 2
95814: PUSH
95815: LD_INT 1
95817: PPUSH
95818: LD_VAR 0 2
95822: PPUSH
95823: CALL_OW 12
95827: ARRAY
95828: ST_TO_ADDR
// SetSide ( un , 0 ) ;
95829: LD_VAR 0 1
95833: PPUSH
95834: LD_INT 0
95836: PPUSH
95837: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
95841: LD_VAR 0 1
95845: PPUSH
95846: LD_OWVAR 3
95850: PUSH
95851: LD_VAR 0 1
95855: DIFF
95856: PPUSH
95857: LD_VAR 0 1
95861: PPUSH
95862: CALL_OW 74
95866: PPUSH
95867: CALL_OW 115
// wait ( 0 0$20 ) ;
95871: LD_INT 700
95873: PPUSH
95874: CALL_OW 67
// SetSide ( un , your_side ) ;
95878: LD_VAR 0 1
95882: PPUSH
95883: LD_OWVAR 2
95887: PPUSH
95888: CALL_OW 235
// end ;
95892: PPOPN 2
95894: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
95895: LD_EXP 104
95899: PUSH
95900: LD_EXP 137
95904: AND
95905: IFFALSE 96011
95907: GO 95909
95909: DISABLE
95910: LD_INT 0
95912: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95913: LD_ADDR_VAR 0 1
95917: PUSH
95918: LD_INT 22
95920: PUSH
95921: LD_OWVAR 2
95925: PUSH
95926: EMPTY
95927: LIST
95928: LIST
95929: PUSH
95930: LD_INT 2
95932: PUSH
95933: LD_INT 30
95935: PUSH
95936: LD_INT 0
95938: PUSH
95939: EMPTY
95940: LIST
95941: LIST
95942: PUSH
95943: LD_INT 30
95945: PUSH
95946: LD_INT 1
95948: PUSH
95949: EMPTY
95950: LIST
95951: LIST
95952: PUSH
95953: EMPTY
95954: LIST
95955: LIST
95956: LIST
95957: PUSH
95958: EMPTY
95959: LIST
95960: LIST
95961: PPUSH
95962: CALL_OW 69
95966: ST_TO_ADDR
// if not depot then
95967: LD_VAR 0 1
95971: NOT
95972: IFFALSE 95976
// exit ;
95974: GO 96011
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
95976: LD_VAR 0 1
95980: PUSH
95981: LD_INT 1
95983: ARRAY
95984: PPUSH
95985: CALL_OW 250
95989: PPUSH
95990: LD_VAR 0 1
95994: PUSH
95995: LD_INT 1
95997: ARRAY
95998: PPUSH
95999: CALL_OW 251
96003: PPUSH
96004: LD_INT 70
96006: PPUSH
96007: CALL_OW 495
// end ;
96011: PPOPN 1
96013: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
96014: LD_EXP 104
96018: PUSH
96019: LD_EXP 138
96023: AND
96024: IFFALSE 96235
96026: GO 96028
96028: DISABLE
96029: LD_INT 0
96031: PPUSH
96032: PPUSH
96033: PPUSH
96034: PPUSH
96035: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96036: LD_ADDR_VAR 0 5
96040: PUSH
96041: LD_INT 22
96043: PUSH
96044: LD_OWVAR 2
96048: PUSH
96049: EMPTY
96050: LIST
96051: LIST
96052: PUSH
96053: LD_INT 21
96055: PUSH
96056: LD_INT 1
96058: PUSH
96059: EMPTY
96060: LIST
96061: LIST
96062: PUSH
96063: EMPTY
96064: LIST
96065: LIST
96066: PPUSH
96067: CALL_OW 69
96071: ST_TO_ADDR
// if not tmp then
96072: LD_VAR 0 5
96076: NOT
96077: IFFALSE 96081
// exit ;
96079: GO 96235
// for i in tmp do
96081: LD_ADDR_VAR 0 1
96085: PUSH
96086: LD_VAR 0 5
96090: PUSH
96091: FOR_IN
96092: IFFALSE 96233
// begin d := rand ( 0 , 5 ) ;
96094: LD_ADDR_VAR 0 4
96098: PUSH
96099: LD_INT 0
96101: PPUSH
96102: LD_INT 5
96104: PPUSH
96105: CALL_OW 12
96109: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
96110: LD_ADDR_VAR 0 2
96114: PUSH
96115: LD_VAR 0 1
96119: PPUSH
96120: CALL_OW 250
96124: PPUSH
96125: LD_VAR 0 4
96129: PPUSH
96130: LD_INT 3
96132: PPUSH
96133: LD_INT 12
96135: PPUSH
96136: CALL_OW 12
96140: PPUSH
96141: CALL_OW 272
96145: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
96146: LD_ADDR_VAR 0 3
96150: PUSH
96151: LD_VAR 0 1
96155: PPUSH
96156: CALL_OW 251
96160: PPUSH
96161: LD_VAR 0 4
96165: PPUSH
96166: LD_INT 3
96168: PPUSH
96169: LD_INT 12
96171: PPUSH
96172: CALL_OW 12
96176: PPUSH
96177: CALL_OW 273
96181: ST_TO_ADDR
// if ValidHex ( x , y ) then
96182: LD_VAR 0 2
96186: PPUSH
96187: LD_VAR 0 3
96191: PPUSH
96192: CALL_OW 488
96196: IFFALSE 96231
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
96198: LD_VAR 0 1
96202: PPUSH
96203: LD_VAR 0 2
96207: PPUSH
96208: LD_VAR 0 3
96212: PPUSH
96213: LD_INT 3
96215: PPUSH
96216: LD_INT 6
96218: PPUSH
96219: CALL_OW 12
96223: PPUSH
96224: LD_INT 1
96226: PPUSH
96227: CALL_OW 483
// end ;
96231: GO 96091
96233: POP
96234: POP
// end ;
96235: PPOPN 5
96237: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
96238: LD_EXP 104
96242: PUSH
96243: LD_EXP 139
96247: AND
96248: IFFALSE 96342
96250: GO 96252
96252: DISABLE
96253: LD_INT 0
96255: PPUSH
96256: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
96257: LD_ADDR_VAR 0 2
96261: PUSH
96262: LD_INT 22
96264: PUSH
96265: LD_OWVAR 2
96269: PUSH
96270: EMPTY
96271: LIST
96272: LIST
96273: PUSH
96274: LD_INT 32
96276: PUSH
96277: LD_INT 1
96279: PUSH
96280: EMPTY
96281: LIST
96282: LIST
96283: PUSH
96284: LD_INT 21
96286: PUSH
96287: LD_INT 2
96289: PUSH
96290: EMPTY
96291: LIST
96292: LIST
96293: PUSH
96294: EMPTY
96295: LIST
96296: LIST
96297: LIST
96298: PPUSH
96299: CALL_OW 69
96303: ST_TO_ADDR
// if not tmp then
96304: LD_VAR 0 2
96308: NOT
96309: IFFALSE 96313
// exit ;
96311: GO 96342
// for i in tmp do
96313: LD_ADDR_VAR 0 1
96317: PUSH
96318: LD_VAR 0 2
96322: PUSH
96323: FOR_IN
96324: IFFALSE 96340
// SetFuel ( i , 0 ) ;
96326: LD_VAR 0 1
96330: PPUSH
96331: LD_INT 0
96333: PPUSH
96334: CALL_OW 240
96338: GO 96323
96340: POP
96341: POP
// end ;
96342: PPOPN 2
96344: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
96345: LD_EXP 104
96349: PUSH
96350: LD_EXP 140
96354: AND
96355: IFFALSE 96421
96357: GO 96359
96359: DISABLE
96360: LD_INT 0
96362: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96363: LD_ADDR_VAR 0 1
96367: PUSH
96368: LD_INT 22
96370: PUSH
96371: LD_OWVAR 2
96375: PUSH
96376: EMPTY
96377: LIST
96378: LIST
96379: PUSH
96380: LD_INT 30
96382: PUSH
96383: LD_INT 29
96385: PUSH
96386: EMPTY
96387: LIST
96388: LIST
96389: PUSH
96390: EMPTY
96391: LIST
96392: LIST
96393: PPUSH
96394: CALL_OW 69
96398: ST_TO_ADDR
// if not tmp then
96399: LD_VAR 0 1
96403: NOT
96404: IFFALSE 96408
// exit ;
96406: GO 96421
// DestroyUnit ( tmp [ 1 ] ) ;
96408: LD_VAR 0 1
96412: PUSH
96413: LD_INT 1
96415: ARRAY
96416: PPUSH
96417: CALL_OW 65
// end ;
96421: PPOPN 1
96423: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
96424: LD_EXP 104
96428: PUSH
96429: LD_EXP 142
96433: AND
96434: IFFALSE 96563
96436: GO 96438
96438: DISABLE
96439: LD_INT 0
96441: PPUSH
// begin uc_side := 0 ;
96442: LD_ADDR_OWVAR 20
96446: PUSH
96447: LD_INT 0
96449: ST_TO_ADDR
// uc_nation := nation_arabian ;
96450: LD_ADDR_OWVAR 21
96454: PUSH
96455: LD_INT 2
96457: ST_TO_ADDR
// hc_gallery :=  ;
96458: LD_ADDR_OWVAR 33
96462: PUSH
96463: LD_STRING 
96465: ST_TO_ADDR
// hc_name :=  ;
96466: LD_ADDR_OWVAR 26
96470: PUSH
96471: LD_STRING 
96473: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
96474: LD_INT 1
96476: PPUSH
96477: LD_INT 11
96479: PPUSH
96480: LD_INT 10
96482: PPUSH
96483: CALL_OW 380
// un := CreateHuman ;
96487: LD_ADDR_VAR 0 1
96491: PUSH
96492: CALL_OW 44
96496: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96497: LD_VAR 0 1
96501: PPUSH
96502: LD_INT 1
96504: PPUSH
96505: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96509: LD_INT 35
96511: PPUSH
96512: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96516: LD_VAR 0 1
96520: PPUSH
96521: LD_INT 22
96523: PUSH
96524: LD_OWVAR 2
96528: PUSH
96529: EMPTY
96530: LIST
96531: LIST
96532: PPUSH
96533: CALL_OW 69
96537: PPUSH
96538: LD_VAR 0 1
96542: PPUSH
96543: CALL_OW 74
96547: PPUSH
96548: CALL_OW 115
// until IsDead ( un ) ;
96552: LD_VAR 0 1
96556: PPUSH
96557: CALL_OW 301
96561: IFFALSE 96509
// end ;
96563: PPOPN 1
96565: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
96566: LD_EXP 104
96570: PUSH
96571: LD_EXP 144
96575: AND
96576: IFFALSE 96588
96578: GO 96580
96580: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
96581: LD_STRING earthquake(getX(game), 0, 32)
96583: PPUSH
96584: CALL_OW 559
96588: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
96589: LD_EXP 104
96593: PUSH
96594: LD_EXP 145
96598: AND
96599: IFFALSE 96690
96601: GO 96603
96603: DISABLE
96604: LD_INT 0
96606: PPUSH
// begin enable ;
96607: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
96608: LD_ADDR_VAR 0 1
96612: PUSH
96613: LD_INT 22
96615: PUSH
96616: LD_OWVAR 2
96620: PUSH
96621: EMPTY
96622: LIST
96623: LIST
96624: PUSH
96625: LD_INT 21
96627: PUSH
96628: LD_INT 2
96630: PUSH
96631: EMPTY
96632: LIST
96633: LIST
96634: PUSH
96635: LD_INT 33
96637: PUSH
96638: LD_INT 3
96640: PUSH
96641: EMPTY
96642: LIST
96643: LIST
96644: PUSH
96645: EMPTY
96646: LIST
96647: LIST
96648: LIST
96649: PPUSH
96650: CALL_OW 69
96654: ST_TO_ADDR
// if not tmp then
96655: LD_VAR 0 1
96659: NOT
96660: IFFALSE 96664
// exit ;
96662: GO 96690
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96664: LD_VAR 0 1
96668: PUSH
96669: LD_INT 1
96671: PPUSH
96672: LD_VAR 0 1
96676: PPUSH
96677: CALL_OW 12
96681: ARRAY
96682: PPUSH
96683: LD_INT 1
96685: PPUSH
96686: CALL_OW 234
// end ;
96690: PPOPN 1
96692: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
96693: LD_EXP 104
96697: PUSH
96698: LD_EXP 146
96702: AND
96703: IFFALSE 96844
96705: GO 96707
96707: DISABLE
96708: LD_INT 0
96710: PPUSH
96711: PPUSH
96712: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96713: LD_ADDR_VAR 0 3
96717: PUSH
96718: LD_INT 22
96720: PUSH
96721: LD_OWVAR 2
96725: PUSH
96726: EMPTY
96727: LIST
96728: LIST
96729: PUSH
96730: LD_INT 25
96732: PUSH
96733: LD_INT 1
96735: PUSH
96736: EMPTY
96737: LIST
96738: LIST
96739: PUSH
96740: EMPTY
96741: LIST
96742: LIST
96743: PPUSH
96744: CALL_OW 69
96748: ST_TO_ADDR
// if not tmp then
96749: LD_VAR 0 3
96753: NOT
96754: IFFALSE 96758
// exit ;
96756: GO 96844
// un := tmp [ rand ( 1 , tmp ) ] ;
96758: LD_ADDR_VAR 0 2
96762: PUSH
96763: LD_VAR 0 3
96767: PUSH
96768: LD_INT 1
96770: PPUSH
96771: LD_VAR 0 3
96775: PPUSH
96776: CALL_OW 12
96780: ARRAY
96781: ST_TO_ADDR
// if Crawls ( un ) then
96782: LD_VAR 0 2
96786: PPUSH
96787: CALL_OW 318
96791: IFFALSE 96802
// ComWalk ( un ) ;
96793: LD_VAR 0 2
96797: PPUSH
96798: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
96802: LD_VAR 0 2
96806: PPUSH
96807: LD_INT 9
96809: PPUSH
96810: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
96814: LD_INT 28
96816: PPUSH
96817: LD_OWVAR 2
96821: PPUSH
96822: LD_INT 2
96824: PPUSH
96825: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
96829: LD_INT 29
96831: PPUSH
96832: LD_OWVAR 2
96836: PPUSH
96837: LD_INT 2
96839: PPUSH
96840: CALL_OW 322
// end ;
96844: PPOPN 3
96846: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
96847: LD_EXP 104
96851: PUSH
96852: LD_EXP 147
96856: AND
96857: IFFALSE 96968
96859: GO 96861
96861: DISABLE
96862: LD_INT 0
96864: PPUSH
96865: PPUSH
96866: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96867: LD_ADDR_VAR 0 3
96871: PUSH
96872: LD_INT 22
96874: PUSH
96875: LD_OWVAR 2
96879: PUSH
96880: EMPTY
96881: LIST
96882: LIST
96883: PUSH
96884: LD_INT 25
96886: PUSH
96887: LD_INT 1
96889: PUSH
96890: EMPTY
96891: LIST
96892: LIST
96893: PUSH
96894: EMPTY
96895: LIST
96896: LIST
96897: PPUSH
96898: CALL_OW 69
96902: ST_TO_ADDR
// if not tmp then
96903: LD_VAR 0 3
96907: NOT
96908: IFFALSE 96912
// exit ;
96910: GO 96968
// un := tmp [ rand ( 1 , tmp ) ] ;
96912: LD_ADDR_VAR 0 2
96916: PUSH
96917: LD_VAR 0 3
96921: PUSH
96922: LD_INT 1
96924: PPUSH
96925: LD_VAR 0 3
96929: PPUSH
96930: CALL_OW 12
96934: ARRAY
96935: ST_TO_ADDR
// if Crawls ( un ) then
96936: LD_VAR 0 2
96940: PPUSH
96941: CALL_OW 318
96945: IFFALSE 96956
// ComWalk ( un ) ;
96947: LD_VAR 0 2
96951: PPUSH
96952: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96956: LD_VAR 0 2
96960: PPUSH
96961: LD_INT 8
96963: PPUSH
96964: CALL_OW 336
// end ;
96968: PPOPN 3
96970: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
96971: LD_EXP 104
96975: PUSH
96976: LD_EXP 148
96980: AND
96981: IFFALSE 97125
96983: GO 96985
96985: DISABLE
96986: LD_INT 0
96988: PPUSH
96989: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
96990: LD_ADDR_VAR 0 2
96994: PUSH
96995: LD_INT 22
96997: PUSH
96998: LD_OWVAR 2
97002: PUSH
97003: EMPTY
97004: LIST
97005: LIST
97006: PUSH
97007: LD_INT 21
97009: PUSH
97010: LD_INT 2
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: PUSH
97017: LD_INT 2
97019: PUSH
97020: LD_INT 34
97022: PUSH
97023: LD_INT 12
97025: PUSH
97026: EMPTY
97027: LIST
97028: LIST
97029: PUSH
97030: LD_INT 34
97032: PUSH
97033: LD_INT 51
97035: PUSH
97036: EMPTY
97037: LIST
97038: LIST
97039: PUSH
97040: LD_INT 34
97042: PUSH
97043: LD_INT 32
97045: PUSH
97046: EMPTY
97047: LIST
97048: LIST
97049: PUSH
97050: EMPTY
97051: LIST
97052: LIST
97053: LIST
97054: LIST
97055: PUSH
97056: EMPTY
97057: LIST
97058: LIST
97059: LIST
97060: PPUSH
97061: CALL_OW 69
97065: ST_TO_ADDR
// if not tmp then
97066: LD_VAR 0 2
97070: NOT
97071: IFFALSE 97075
// exit ;
97073: GO 97125
// for i in tmp do
97075: LD_ADDR_VAR 0 1
97079: PUSH
97080: LD_VAR 0 2
97084: PUSH
97085: FOR_IN
97086: IFFALSE 97123
// if GetCargo ( i , mat_artifact ) = 0 then
97088: LD_VAR 0 1
97092: PPUSH
97093: LD_INT 4
97095: PPUSH
97096: CALL_OW 289
97100: PUSH
97101: LD_INT 0
97103: EQUAL
97104: IFFALSE 97121
// SetCargo ( i , mat_siberit , 100 ) ;
97106: LD_VAR 0 1
97110: PPUSH
97111: LD_INT 3
97113: PPUSH
97114: LD_INT 100
97116: PPUSH
97117: CALL_OW 290
97121: GO 97085
97123: POP
97124: POP
// end ;
97125: PPOPN 2
97127: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
97128: LD_EXP 104
97132: PUSH
97133: LD_EXP 149
97137: AND
97138: IFFALSE 97321
97140: GO 97142
97142: DISABLE
97143: LD_INT 0
97145: PPUSH
97146: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97147: LD_ADDR_VAR 0 2
97151: PUSH
97152: LD_INT 22
97154: PUSH
97155: LD_OWVAR 2
97159: PUSH
97160: EMPTY
97161: LIST
97162: LIST
97163: PPUSH
97164: CALL_OW 69
97168: ST_TO_ADDR
// if not tmp then
97169: LD_VAR 0 2
97173: NOT
97174: IFFALSE 97178
// exit ;
97176: GO 97321
// for i := 1 to 2 do
97178: LD_ADDR_VAR 0 1
97182: PUSH
97183: DOUBLE
97184: LD_INT 1
97186: DEC
97187: ST_TO_ADDR
97188: LD_INT 2
97190: PUSH
97191: FOR_TO
97192: IFFALSE 97319
// begin uc_side := your_side ;
97194: LD_ADDR_OWVAR 20
97198: PUSH
97199: LD_OWVAR 2
97203: ST_TO_ADDR
// uc_nation := nation_american ;
97204: LD_ADDR_OWVAR 21
97208: PUSH
97209: LD_INT 1
97211: ST_TO_ADDR
// vc_chassis := us_morphling ;
97212: LD_ADDR_OWVAR 37
97216: PUSH
97217: LD_INT 5
97219: ST_TO_ADDR
// vc_engine := engine_siberite ;
97220: LD_ADDR_OWVAR 39
97224: PUSH
97225: LD_INT 3
97227: ST_TO_ADDR
// vc_control := control_computer ;
97228: LD_ADDR_OWVAR 38
97232: PUSH
97233: LD_INT 3
97235: ST_TO_ADDR
// vc_weapon := us_double_laser ;
97236: LD_ADDR_OWVAR 40
97240: PUSH
97241: LD_INT 10
97243: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
97244: LD_VAR 0 2
97248: PUSH
97249: LD_INT 1
97251: ARRAY
97252: PPUSH
97253: CALL_OW 310
97257: NOT
97258: IFFALSE 97305
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
97260: CALL_OW 45
97264: PPUSH
97265: LD_VAR 0 2
97269: PUSH
97270: LD_INT 1
97272: ARRAY
97273: PPUSH
97274: CALL_OW 250
97278: PPUSH
97279: LD_VAR 0 2
97283: PUSH
97284: LD_INT 1
97286: ARRAY
97287: PPUSH
97288: CALL_OW 251
97292: PPUSH
97293: LD_INT 12
97295: PPUSH
97296: LD_INT 1
97298: PPUSH
97299: CALL_OW 50
97303: GO 97317
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
97305: CALL_OW 45
97309: PPUSH
97310: LD_INT 1
97312: PPUSH
97313: CALL_OW 51
// end ;
97317: GO 97191
97319: POP
97320: POP
// end ;
97321: PPOPN 2
97323: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
97324: LD_EXP 104
97328: PUSH
97329: LD_EXP 150
97333: AND
97334: IFFALSE 97556
97336: GO 97338
97338: DISABLE
97339: LD_INT 0
97341: PPUSH
97342: PPUSH
97343: PPUSH
97344: PPUSH
97345: PPUSH
97346: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97347: LD_ADDR_VAR 0 6
97351: PUSH
97352: LD_INT 22
97354: PUSH
97355: LD_OWVAR 2
97359: PUSH
97360: EMPTY
97361: LIST
97362: LIST
97363: PUSH
97364: LD_INT 21
97366: PUSH
97367: LD_INT 1
97369: PUSH
97370: EMPTY
97371: LIST
97372: LIST
97373: PUSH
97374: LD_INT 3
97376: PUSH
97377: LD_INT 23
97379: PUSH
97380: LD_INT 0
97382: PUSH
97383: EMPTY
97384: LIST
97385: LIST
97386: PUSH
97387: EMPTY
97388: LIST
97389: LIST
97390: PUSH
97391: EMPTY
97392: LIST
97393: LIST
97394: LIST
97395: PPUSH
97396: CALL_OW 69
97400: ST_TO_ADDR
// if not tmp then
97401: LD_VAR 0 6
97405: NOT
97406: IFFALSE 97410
// exit ;
97408: GO 97556
// s1 := rand ( 1 , 4 ) ;
97410: LD_ADDR_VAR 0 2
97414: PUSH
97415: LD_INT 1
97417: PPUSH
97418: LD_INT 4
97420: PPUSH
97421: CALL_OW 12
97425: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
97426: LD_ADDR_VAR 0 4
97430: PUSH
97431: LD_VAR 0 6
97435: PUSH
97436: LD_INT 1
97438: ARRAY
97439: PPUSH
97440: LD_VAR 0 2
97444: PPUSH
97445: CALL_OW 259
97449: ST_TO_ADDR
// if s1 = 1 then
97450: LD_VAR 0 2
97454: PUSH
97455: LD_INT 1
97457: EQUAL
97458: IFFALSE 97478
// s2 := rand ( 2 , 4 ) else
97460: LD_ADDR_VAR 0 3
97464: PUSH
97465: LD_INT 2
97467: PPUSH
97468: LD_INT 4
97470: PPUSH
97471: CALL_OW 12
97475: ST_TO_ADDR
97476: GO 97486
// s2 := 1 ;
97478: LD_ADDR_VAR 0 3
97482: PUSH
97483: LD_INT 1
97485: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
97486: LD_ADDR_VAR 0 5
97490: PUSH
97491: LD_VAR 0 6
97495: PUSH
97496: LD_INT 1
97498: ARRAY
97499: PPUSH
97500: LD_VAR 0 3
97504: PPUSH
97505: CALL_OW 259
97509: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
97510: LD_VAR 0 6
97514: PUSH
97515: LD_INT 1
97517: ARRAY
97518: PPUSH
97519: LD_VAR 0 2
97523: PPUSH
97524: LD_VAR 0 5
97528: PPUSH
97529: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
97533: LD_VAR 0 6
97537: PUSH
97538: LD_INT 1
97540: ARRAY
97541: PPUSH
97542: LD_VAR 0 3
97546: PPUSH
97547: LD_VAR 0 4
97551: PPUSH
97552: CALL_OW 237
// end ;
97556: PPOPN 6
97558: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
97559: LD_EXP 104
97563: PUSH
97564: LD_EXP 151
97568: AND
97569: IFFALSE 97648
97571: GO 97573
97573: DISABLE
97574: LD_INT 0
97576: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
97577: LD_ADDR_VAR 0 1
97581: PUSH
97582: LD_INT 22
97584: PUSH
97585: LD_OWVAR 2
97589: PUSH
97590: EMPTY
97591: LIST
97592: LIST
97593: PUSH
97594: LD_INT 30
97596: PUSH
97597: LD_INT 3
97599: PUSH
97600: EMPTY
97601: LIST
97602: LIST
97603: PUSH
97604: EMPTY
97605: LIST
97606: LIST
97607: PPUSH
97608: CALL_OW 69
97612: ST_TO_ADDR
// if not tmp then
97613: LD_VAR 0 1
97617: NOT
97618: IFFALSE 97622
// exit ;
97620: GO 97648
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97622: LD_VAR 0 1
97626: PUSH
97627: LD_INT 1
97629: PPUSH
97630: LD_VAR 0 1
97634: PPUSH
97635: CALL_OW 12
97639: ARRAY
97640: PPUSH
97641: LD_INT 1
97643: PPUSH
97644: CALL_OW 234
// end ;
97648: PPOPN 1
97650: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
97651: LD_EXP 104
97655: PUSH
97656: LD_EXP 152
97660: AND
97661: IFFALSE 97773
97663: GO 97665
97665: DISABLE
97666: LD_INT 0
97668: PPUSH
97669: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
97670: LD_ADDR_VAR 0 2
97674: PUSH
97675: LD_INT 22
97677: PUSH
97678: LD_OWVAR 2
97682: PUSH
97683: EMPTY
97684: LIST
97685: LIST
97686: PUSH
97687: LD_INT 2
97689: PUSH
97690: LD_INT 30
97692: PUSH
97693: LD_INT 27
97695: PUSH
97696: EMPTY
97697: LIST
97698: LIST
97699: PUSH
97700: LD_INT 30
97702: PUSH
97703: LD_INT 26
97705: PUSH
97706: EMPTY
97707: LIST
97708: LIST
97709: PUSH
97710: LD_INT 30
97712: PUSH
97713: LD_INT 28
97715: PUSH
97716: EMPTY
97717: LIST
97718: LIST
97719: PUSH
97720: EMPTY
97721: LIST
97722: LIST
97723: LIST
97724: LIST
97725: PUSH
97726: EMPTY
97727: LIST
97728: LIST
97729: PPUSH
97730: CALL_OW 69
97734: ST_TO_ADDR
// if not tmp then
97735: LD_VAR 0 2
97739: NOT
97740: IFFALSE 97744
// exit ;
97742: GO 97773
// for i in tmp do
97744: LD_ADDR_VAR 0 1
97748: PUSH
97749: LD_VAR 0 2
97753: PUSH
97754: FOR_IN
97755: IFFALSE 97771
// SetLives ( i , 1 ) ;
97757: LD_VAR 0 1
97761: PPUSH
97762: LD_INT 1
97764: PPUSH
97765: CALL_OW 234
97769: GO 97754
97771: POP
97772: POP
// end ;
97773: PPOPN 2
97775: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
97776: LD_EXP 104
97780: PUSH
97781: LD_EXP 153
97785: AND
97786: IFFALSE 98073
97788: GO 97790
97790: DISABLE
97791: LD_INT 0
97793: PPUSH
97794: PPUSH
97795: PPUSH
// begin i := rand ( 1 , 7 ) ;
97796: LD_ADDR_VAR 0 1
97800: PUSH
97801: LD_INT 1
97803: PPUSH
97804: LD_INT 7
97806: PPUSH
97807: CALL_OW 12
97811: ST_TO_ADDR
// case i of 1 :
97812: LD_VAR 0 1
97816: PUSH
97817: LD_INT 1
97819: DOUBLE
97820: EQUAL
97821: IFTRUE 97825
97823: GO 97835
97825: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
97826: LD_STRING earthquake(getX(game), 0, 32)
97828: PPUSH
97829: CALL_OW 559
97833: GO 98073
97835: LD_INT 2
97837: DOUBLE
97838: EQUAL
97839: IFTRUE 97843
97841: GO 97857
97843: POP
// begin ToLua ( displayStucuk(); ) ;
97844: LD_STRING displayStucuk();
97846: PPUSH
97847: CALL_OW 559
// ResetFog ;
97851: CALL_OW 335
// end ; 3 :
97855: GO 98073
97857: LD_INT 3
97859: DOUBLE
97860: EQUAL
97861: IFTRUE 97865
97863: GO 97969
97865: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97866: LD_ADDR_VAR 0 2
97870: PUSH
97871: LD_INT 22
97873: PUSH
97874: LD_OWVAR 2
97878: PUSH
97879: EMPTY
97880: LIST
97881: LIST
97882: PUSH
97883: LD_INT 25
97885: PUSH
97886: LD_INT 1
97888: PUSH
97889: EMPTY
97890: LIST
97891: LIST
97892: PUSH
97893: EMPTY
97894: LIST
97895: LIST
97896: PPUSH
97897: CALL_OW 69
97901: ST_TO_ADDR
// if not tmp then
97902: LD_VAR 0 2
97906: NOT
97907: IFFALSE 97911
// exit ;
97909: GO 98073
// un := tmp [ rand ( 1 , tmp ) ] ;
97911: LD_ADDR_VAR 0 3
97915: PUSH
97916: LD_VAR 0 2
97920: PUSH
97921: LD_INT 1
97923: PPUSH
97924: LD_VAR 0 2
97928: PPUSH
97929: CALL_OW 12
97933: ARRAY
97934: ST_TO_ADDR
// if Crawls ( un ) then
97935: LD_VAR 0 3
97939: PPUSH
97940: CALL_OW 318
97944: IFFALSE 97955
// ComWalk ( un ) ;
97946: LD_VAR 0 3
97950: PPUSH
97951: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97955: LD_VAR 0 3
97959: PPUSH
97960: LD_INT 8
97962: PPUSH
97963: CALL_OW 336
// end ; 4 :
97967: GO 98073
97969: LD_INT 4
97971: DOUBLE
97972: EQUAL
97973: IFTRUE 97977
97975: GO 98051
97977: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97978: LD_ADDR_VAR 0 2
97982: PUSH
97983: LD_INT 22
97985: PUSH
97986: LD_OWVAR 2
97990: PUSH
97991: EMPTY
97992: LIST
97993: LIST
97994: PUSH
97995: LD_INT 30
97997: PUSH
97998: LD_INT 29
98000: PUSH
98001: EMPTY
98002: LIST
98003: LIST
98004: PUSH
98005: EMPTY
98006: LIST
98007: LIST
98008: PPUSH
98009: CALL_OW 69
98013: ST_TO_ADDR
// if not tmp then
98014: LD_VAR 0 2
98018: NOT
98019: IFFALSE 98023
// exit ;
98021: GO 98073
// CenterNowOnUnits ( tmp [ 1 ] ) ;
98023: LD_VAR 0 2
98027: PUSH
98028: LD_INT 1
98030: ARRAY
98031: PPUSH
98032: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
98036: LD_VAR 0 2
98040: PUSH
98041: LD_INT 1
98043: ARRAY
98044: PPUSH
98045: CALL_OW 65
// end ; 5 .. 7 :
98049: GO 98073
98051: LD_INT 5
98053: DOUBLE
98054: GREATEREQUAL
98055: IFFALSE 98063
98057: LD_INT 7
98059: DOUBLE
98060: LESSEQUAL
98061: IFTRUE 98065
98063: GO 98072
98065: POP
// StreamSibBomb ; end ;
98066: CALL 94310 0 0
98070: GO 98073
98072: POP
// end ;
98073: PPOPN 3
98075: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
98076: LD_EXP 104
98080: PUSH
98081: LD_EXP 154
98085: AND
98086: IFFALSE 98242
98088: GO 98090
98090: DISABLE
98091: LD_INT 0
98093: PPUSH
98094: PPUSH
98095: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
98096: LD_ADDR_VAR 0 2
98100: PUSH
98101: LD_INT 81
98103: PUSH
98104: LD_OWVAR 2
98108: PUSH
98109: EMPTY
98110: LIST
98111: LIST
98112: PUSH
98113: LD_INT 2
98115: PUSH
98116: LD_INT 21
98118: PUSH
98119: LD_INT 1
98121: PUSH
98122: EMPTY
98123: LIST
98124: LIST
98125: PUSH
98126: LD_INT 21
98128: PUSH
98129: LD_INT 2
98131: PUSH
98132: EMPTY
98133: LIST
98134: LIST
98135: PUSH
98136: EMPTY
98137: LIST
98138: LIST
98139: LIST
98140: PUSH
98141: EMPTY
98142: LIST
98143: LIST
98144: PPUSH
98145: CALL_OW 69
98149: ST_TO_ADDR
// if not tmp then
98150: LD_VAR 0 2
98154: NOT
98155: IFFALSE 98159
// exit ;
98157: GO 98242
// p := 0 ;
98159: LD_ADDR_VAR 0 3
98163: PUSH
98164: LD_INT 0
98166: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98167: LD_INT 35
98169: PPUSH
98170: CALL_OW 67
// p := p + 1 ;
98174: LD_ADDR_VAR 0 3
98178: PUSH
98179: LD_VAR 0 3
98183: PUSH
98184: LD_INT 1
98186: PLUS
98187: ST_TO_ADDR
// for i in tmp do
98188: LD_ADDR_VAR 0 1
98192: PUSH
98193: LD_VAR 0 2
98197: PUSH
98198: FOR_IN
98199: IFFALSE 98230
// if GetLives ( i ) < 1000 then
98201: LD_VAR 0 1
98205: PPUSH
98206: CALL_OW 256
98210: PUSH
98211: LD_INT 1000
98213: LESS
98214: IFFALSE 98228
// SetLives ( i , 1000 ) ;
98216: LD_VAR 0 1
98220: PPUSH
98221: LD_INT 1000
98223: PPUSH
98224: CALL_OW 234
98228: GO 98198
98230: POP
98231: POP
// until p > 20 ;
98232: LD_VAR 0 3
98236: PUSH
98237: LD_INT 20
98239: GREATER
98240: IFFALSE 98167
// end ;
98242: PPOPN 3
98244: END
// every 0 0$1 trigger StreamModeActive and sTime do
98245: LD_EXP 104
98249: PUSH
98250: LD_EXP 155
98254: AND
98255: IFFALSE 98290
98257: GO 98259
98259: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
98260: LD_INT 28
98262: PPUSH
98263: LD_OWVAR 2
98267: PPUSH
98268: LD_INT 2
98270: PPUSH
98271: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
98275: LD_INT 30
98277: PPUSH
98278: LD_OWVAR 2
98282: PPUSH
98283: LD_INT 2
98285: PPUSH
98286: CALL_OW 322
// end ;
98290: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
98291: LD_EXP 104
98295: PUSH
98296: LD_EXP 156
98300: AND
98301: IFFALSE 98422
98303: GO 98305
98305: DISABLE
98306: LD_INT 0
98308: PPUSH
98309: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98310: LD_ADDR_VAR 0 2
98314: PUSH
98315: LD_INT 22
98317: PUSH
98318: LD_OWVAR 2
98322: PUSH
98323: EMPTY
98324: LIST
98325: LIST
98326: PUSH
98327: LD_INT 21
98329: PUSH
98330: LD_INT 1
98332: PUSH
98333: EMPTY
98334: LIST
98335: LIST
98336: PUSH
98337: LD_INT 3
98339: PUSH
98340: LD_INT 23
98342: PUSH
98343: LD_INT 0
98345: PUSH
98346: EMPTY
98347: LIST
98348: LIST
98349: PUSH
98350: EMPTY
98351: LIST
98352: LIST
98353: PUSH
98354: EMPTY
98355: LIST
98356: LIST
98357: LIST
98358: PPUSH
98359: CALL_OW 69
98363: ST_TO_ADDR
// if not tmp then
98364: LD_VAR 0 2
98368: NOT
98369: IFFALSE 98373
// exit ;
98371: GO 98422
// for i in tmp do
98373: LD_ADDR_VAR 0 1
98377: PUSH
98378: LD_VAR 0 2
98382: PUSH
98383: FOR_IN
98384: IFFALSE 98420
// begin if Crawls ( i ) then
98386: LD_VAR 0 1
98390: PPUSH
98391: CALL_OW 318
98395: IFFALSE 98406
// ComWalk ( i ) ;
98397: LD_VAR 0 1
98401: PPUSH
98402: CALL_OW 138
// SetClass ( i , 2 ) ;
98406: LD_VAR 0 1
98410: PPUSH
98411: LD_INT 2
98413: PPUSH
98414: CALL_OW 336
// end ;
98418: GO 98383
98420: POP
98421: POP
// end ;
98422: PPOPN 2
98424: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
98425: LD_EXP 104
98429: PUSH
98430: LD_EXP 157
98434: AND
98435: IFFALSE 98723
98437: GO 98439
98439: DISABLE
98440: LD_INT 0
98442: PPUSH
98443: PPUSH
98444: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
98445: LD_OWVAR 2
98449: PPUSH
98450: LD_INT 9
98452: PPUSH
98453: LD_INT 1
98455: PPUSH
98456: LD_INT 1
98458: PPUSH
98459: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
98463: LD_INT 9
98465: PPUSH
98466: LD_OWVAR 2
98470: PPUSH
98471: CALL_OW 343
// uc_side := 9 ;
98475: LD_ADDR_OWVAR 20
98479: PUSH
98480: LD_INT 9
98482: ST_TO_ADDR
// uc_nation := 2 ;
98483: LD_ADDR_OWVAR 21
98487: PUSH
98488: LD_INT 2
98490: ST_TO_ADDR
// hc_name := Dark Warrior ;
98491: LD_ADDR_OWVAR 26
98495: PUSH
98496: LD_STRING Dark Warrior
98498: ST_TO_ADDR
// hc_gallery :=  ;
98499: LD_ADDR_OWVAR 33
98503: PUSH
98504: LD_STRING 
98506: ST_TO_ADDR
// hc_noskilllimit := true ;
98507: LD_ADDR_OWVAR 76
98511: PUSH
98512: LD_INT 1
98514: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
98515: LD_ADDR_OWVAR 31
98519: PUSH
98520: LD_INT 30
98522: PUSH
98523: LD_INT 30
98525: PUSH
98526: LD_INT 30
98528: PUSH
98529: LD_INT 30
98531: PUSH
98532: EMPTY
98533: LIST
98534: LIST
98535: LIST
98536: LIST
98537: ST_TO_ADDR
// un := CreateHuman ;
98538: LD_ADDR_VAR 0 3
98542: PUSH
98543: CALL_OW 44
98547: ST_TO_ADDR
// hc_noskilllimit := false ;
98548: LD_ADDR_OWVAR 76
98552: PUSH
98553: LD_INT 0
98555: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98556: LD_VAR 0 3
98560: PPUSH
98561: LD_INT 1
98563: PPUSH
98564: CALL_OW 51
// ToLua ( playRanger() ) ;
98568: LD_STRING playRanger()
98570: PPUSH
98571: CALL_OW 559
// p := 0 ;
98575: LD_ADDR_VAR 0 2
98579: PUSH
98580: LD_INT 0
98582: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98583: LD_INT 35
98585: PPUSH
98586: CALL_OW 67
// p := p + 1 ;
98590: LD_ADDR_VAR 0 2
98594: PUSH
98595: LD_VAR 0 2
98599: PUSH
98600: LD_INT 1
98602: PLUS
98603: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
98604: LD_VAR 0 3
98608: PPUSH
98609: CALL_OW 256
98613: PUSH
98614: LD_INT 1000
98616: LESS
98617: IFFALSE 98631
// SetLives ( un , 1000 ) ;
98619: LD_VAR 0 3
98623: PPUSH
98624: LD_INT 1000
98626: PPUSH
98627: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
98631: LD_VAR 0 3
98635: PPUSH
98636: LD_INT 81
98638: PUSH
98639: LD_OWVAR 2
98643: PUSH
98644: EMPTY
98645: LIST
98646: LIST
98647: PUSH
98648: LD_INT 91
98650: PUSH
98651: LD_VAR 0 3
98655: PUSH
98656: LD_INT 30
98658: PUSH
98659: EMPTY
98660: LIST
98661: LIST
98662: LIST
98663: PUSH
98664: EMPTY
98665: LIST
98666: LIST
98667: PPUSH
98668: CALL_OW 69
98672: PPUSH
98673: LD_VAR 0 3
98677: PPUSH
98678: CALL_OW 74
98682: PPUSH
98683: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
98687: LD_VAR 0 2
98691: PUSH
98692: LD_INT 80
98694: GREATER
98695: PUSH
98696: LD_VAR 0 3
98700: PPUSH
98701: CALL_OW 301
98705: OR
98706: IFFALSE 98583
// if un then
98708: LD_VAR 0 3
98712: IFFALSE 98723
// RemoveUnit ( un ) ;
98714: LD_VAR 0 3
98718: PPUSH
98719: CALL_OW 64
// end ;
98723: PPOPN 3
98725: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
98726: LD_EXP 158
98730: IFFALSE 98846
98732: GO 98734
98734: DISABLE
98735: LD_INT 0
98737: PPUSH
98738: PPUSH
98739: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98740: LD_ADDR_VAR 0 2
98744: PUSH
98745: LD_INT 81
98747: PUSH
98748: LD_OWVAR 2
98752: PUSH
98753: EMPTY
98754: LIST
98755: LIST
98756: PUSH
98757: LD_INT 21
98759: PUSH
98760: LD_INT 1
98762: PUSH
98763: EMPTY
98764: LIST
98765: LIST
98766: PUSH
98767: EMPTY
98768: LIST
98769: LIST
98770: PPUSH
98771: CALL_OW 69
98775: ST_TO_ADDR
// ToLua ( playComputer() ) ;
98776: LD_STRING playComputer()
98778: PPUSH
98779: CALL_OW 559
// if not tmp then
98783: LD_VAR 0 2
98787: NOT
98788: IFFALSE 98792
// exit ;
98790: GO 98846
// for i in tmp do
98792: LD_ADDR_VAR 0 1
98796: PUSH
98797: LD_VAR 0 2
98801: PUSH
98802: FOR_IN
98803: IFFALSE 98844
// for j := 1 to 4 do
98805: LD_ADDR_VAR 0 3
98809: PUSH
98810: DOUBLE
98811: LD_INT 1
98813: DEC
98814: ST_TO_ADDR
98815: LD_INT 4
98817: PUSH
98818: FOR_TO
98819: IFFALSE 98840
// SetSkill ( i , j , 10 ) ;
98821: LD_VAR 0 1
98825: PPUSH
98826: LD_VAR 0 3
98830: PPUSH
98831: LD_INT 10
98833: PPUSH
98834: CALL_OW 237
98838: GO 98818
98840: POP
98841: POP
98842: GO 98802
98844: POP
98845: POP
// end ;
98846: PPOPN 3
98848: END
// every 0 0$1 trigger s30 do var i , tmp ;
98849: LD_EXP 159
98853: IFFALSE 98922
98855: GO 98857
98857: DISABLE
98858: LD_INT 0
98860: PPUSH
98861: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98862: LD_ADDR_VAR 0 2
98866: PUSH
98867: LD_INT 22
98869: PUSH
98870: LD_OWVAR 2
98874: PUSH
98875: EMPTY
98876: LIST
98877: LIST
98878: PPUSH
98879: CALL_OW 69
98883: ST_TO_ADDR
// if not tmp then
98884: LD_VAR 0 2
98888: NOT
98889: IFFALSE 98893
// exit ;
98891: GO 98922
// for i in tmp do
98893: LD_ADDR_VAR 0 1
98897: PUSH
98898: LD_VAR 0 2
98902: PUSH
98903: FOR_IN
98904: IFFALSE 98920
// SetLives ( i , 300 ) ;
98906: LD_VAR 0 1
98910: PPUSH
98911: LD_INT 300
98913: PPUSH
98914: CALL_OW 234
98918: GO 98903
98920: POP
98921: POP
// end ;
98922: PPOPN 2
98924: END
// every 0 0$1 trigger s60 do var i , tmp ;
98925: LD_EXP 160
98929: IFFALSE 98998
98931: GO 98933
98933: DISABLE
98934: LD_INT 0
98936: PPUSH
98937: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98938: LD_ADDR_VAR 0 2
98942: PUSH
98943: LD_INT 22
98945: PUSH
98946: LD_OWVAR 2
98950: PUSH
98951: EMPTY
98952: LIST
98953: LIST
98954: PPUSH
98955: CALL_OW 69
98959: ST_TO_ADDR
// if not tmp then
98960: LD_VAR 0 2
98964: NOT
98965: IFFALSE 98969
// exit ;
98967: GO 98998
// for i in tmp do
98969: LD_ADDR_VAR 0 1
98973: PUSH
98974: LD_VAR 0 2
98978: PUSH
98979: FOR_IN
98980: IFFALSE 98996
// SetLives ( i , 600 ) ;
98982: LD_VAR 0 1
98986: PPUSH
98987: LD_INT 600
98989: PPUSH
98990: CALL_OW 234
98994: GO 98979
98996: POP
98997: POP
// end ;
98998: PPOPN 2
99000: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
99001: LD_INT 0
99003: PPUSH
// case cmd of 301 :
99004: LD_VAR 0 1
99008: PUSH
99009: LD_INT 301
99011: DOUBLE
99012: EQUAL
99013: IFTRUE 99017
99015: GO 99049
99017: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
99018: LD_VAR 0 6
99022: PPUSH
99023: LD_VAR 0 7
99027: PPUSH
99028: LD_VAR 0 8
99032: PPUSH
99033: LD_VAR 0 4
99037: PPUSH
99038: LD_VAR 0 5
99042: PPUSH
99043: CALL 100250 0 5
99047: GO 99170
99049: LD_INT 302
99051: DOUBLE
99052: EQUAL
99053: IFTRUE 99057
99055: GO 99094
99057: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
99058: LD_VAR 0 6
99062: PPUSH
99063: LD_VAR 0 7
99067: PPUSH
99068: LD_VAR 0 8
99072: PPUSH
99073: LD_VAR 0 9
99077: PPUSH
99078: LD_VAR 0 4
99082: PPUSH
99083: LD_VAR 0 5
99087: PPUSH
99088: CALL 100341 0 6
99092: GO 99170
99094: LD_INT 303
99096: DOUBLE
99097: EQUAL
99098: IFTRUE 99102
99100: GO 99139
99102: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
99103: LD_VAR 0 6
99107: PPUSH
99108: LD_VAR 0 7
99112: PPUSH
99113: LD_VAR 0 8
99117: PPUSH
99118: LD_VAR 0 9
99122: PPUSH
99123: LD_VAR 0 4
99127: PPUSH
99128: LD_VAR 0 5
99132: PPUSH
99133: CALL 99175 0 6
99137: GO 99170
99139: LD_INT 304
99141: DOUBLE
99142: EQUAL
99143: IFTRUE 99147
99145: GO 99169
99147: POP
// hHackTeleport ( unit , x , y ) ; end ;
99148: LD_VAR 0 2
99152: PPUSH
99153: LD_VAR 0 4
99157: PPUSH
99158: LD_VAR 0 5
99162: PPUSH
99163: CALL 100934 0 3
99167: GO 99170
99169: POP
// end ;
99170: LD_VAR 0 12
99174: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
99175: LD_INT 0
99177: PPUSH
99178: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
99179: LD_VAR 0 1
99183: PUSH
99184: LD_INT 1
99186: LESS
99187: PUSH
99188: LD_VAR 0 1
99192: PUSH
99193: LD_INT 3
99195: GREATER
99196: OR
99197: PUSH
99198: LD_VAR 0 5
99202: PPUSH
99203: LD_VAR 0 6
99207: PPUSH
99208: CALL_OW 428
99212: OR
99213: IFFALSE 99217
// exit ;
99215: GO 99937
// uc_side := your_side ;
99217: LD_ADDR_OWVAR 20
99221: PUSH
99222: LD_OWVAR 2
99226: ST_TO_ADDR
// uc_nation := nation ;
99227: LD_ADDR_OWVAR 21
99231: PUSH
99232: LD_VAR 0 1
99236: ST_TO_ADDR
// bc_level = 1 ;
99237: LD_ADDR_OWVAR 43
99241: PUSH
99242: LD_INT 1
99244: ST_TO_ADDR
// case btype of 1 :
99245: LD_VAR 0 2
99249: PUSH
99250: LD_INT 1
99252: DOUBLE
99253: EQUAL
99254: IFTRUE 99258
99256: GO 99269
99258: POP
// bc_type := b_depot ; 2 :
99259: LD_ADDR_OWVAR 42
99263: PUSH
99264: LD_INT 0
99266: ST_TO_ADDR
99267: GO 99881
99269: LD_INT 2
99271: DOUBLE
99272: EQUAL
99273: IFTRUE 99277
99275: GO 99288
99277: POP
// bc_type := b_warehouse ; 3 :
99278: LD_ADDR_OWVAR 42
99282: PUSH
99283: LD_INT 1
99285: ST_TO_ADDR
99286: GO 99881
99288: LD_INT 3
99290: DOUBLE
99291: EQUAL
99292: IFTRUE 99296
99294: GO 99307
99296: POP
// bc_type := b_lab ; 4 .. 9 :
99297: LD_ADDR_OWVAR 42
99301: PUSH
99302: LD_INT 6
99304: ST_TO_ADDR
99305: GO 99881
99307: LD_INT 4
99309: DOUBLE
99310: GREATEREQUAL
99311: IFFALSE 99319
99313: LD_INT 9
99315: DOUBLE
99316: LESSEQUAL
99317: IFTRUE 99321
99319: GO 99373
99321: POP
// begin bc_type := b_lab_half ;
99322: LD_ADDR_OWVAR 42
99326: PUSH
99327: LD_INT 7
99329: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
99330: LD_ADDR_OWVAR 44
99334: PUSH
99335: LD_INT 10
99337: PUSH
99338: LD_INT 11
99340: PUSH
99341: LD_INT 12
99343: PUSH
99344: LD_INT 15
99346: PUSH
99347: LD_INT 14
99349: PUSH
99350: LD_INT 13
99352: PUSH
99353: EMPTY
99354: LIST
99355: LIST
99356: LIST
99357: LIST
99358: LIST
99359: LIST
99360: PUSH
99361: LD_VAR 0 2
99365: PUSH
99366: LD_INT 3
99368: MINUS
99369: ARRAY
99370: ST_TO_ADDR
// end ; 10 .. 13 :
99371: GO 99881
99373: LD_INT 10
99375: DOUBLE
99376: GREATEREQUAL
99377: IFFALSE 99385
99379: LD_INT 13
99381: DOUBLE
99382: LESSEQUAL
99383: IFTRUE 99387
99385: GO 99464
99387: POP
// begin bc_type := b_lab_full ;
99388: LD_ADDR_OWVAR 42
99392: PUSH
99393: LD_INT 8
99395: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
99396: LD_ADDR_OWVAR 44
99400: PUSH
99401: LD_INT 10
99403: PUSH
99404: LD_INT 12
99406: PUSH
99407: LD_INT 14
99409: PUSH
99410: LD_INT 13
99412: PUSH
99413: EMPTY
99414: LIST
99415: LIST
99416: LIST
99417: LIST
99418: PUSH
99419: LD_VAR 0 2
99423: PUSH
99424: LD_INT 9
99426: MINUS
99427: ARRAY
99428: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
99429: LD_ADDR_OWVAR 45
99433: PUSH
99434: LD_INT 11
99436: PUSH
99437: LD_INT 15
99439: PUSH
99440: LD_INT 12
99442: PUSH
99443: LD_INT 15
99445: PUSH
99446: EMPTY
99447: LIST
99448: LIST
99449: LIST
99450: LIST
99451: PUSH
99452: LD_VAR 0 2
99456: PUSH
99457: LD_INT 9
99459: MINUS
99460: ARRAY
99461: ST_TO_ADDR
// end ; 14 :
99462: GO 99881
99464: LD_INT 14
99466: DOUBLE
99467: EQUAL
99468: IFTRUE 99472
99470: GO 99483
99472: POP
// bc_type := b_workshop ; 15 :
99473: LD_ADDR_OWVAR 42
99477: PUSH
99478: LD_INT 2
99480: ST_TO_ADDR
99481: GO 99881
99483: LD_INT 15
99485: DOUBLE
99486: EQUAL
99487: IFTRUE 99491
99489: GO 99502
99491: POP
// bc_type := b_factory ; 16 :
99492: LD_ADDR_OWVAR 42
99496: PUSH
99497: LD_INT 3
99499: ST_TO_ADDR
99500: GO 99881
99502: LD_INT 16
99504: DOUBLE
99505: EQUAL
99506: IFTRUE 99510
99508: GO 99521
99510: POP
// bc_type := b_ext_gun ; 17 :
99511: LD_ADDR_OWVAR 42
99515: PUSH
99516: LD_INT 17
99518: ST_TO_ADDR
99519: GO 99881
99521: LD_INT 17
99523: DOUBLE
99524: EQUAL
99525: IFTRUE 99529
99527: GO 99557
99529: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
99530: LD_ADDR_OWVAR 42
99534: PUSH
99535: LD_INT 19
99537: PUSH
99538: LD_INT 23
99540: PUSH
99541: LD_INT 19
99543: PUSH
99544: EMPTY
99545: LIST
99546: LIST
99547: LIST
99548: PUSH
99549: LD_VAR 0 1
99553: ARRAY
99554: ST_TO_ADDR
99555: GO 99881
99557: LD_INT 18
99559: DOUBLE
99560: EQUAL
99561: IFTRUE 99565
99563: GO 99576
99565: POP
// bc_type := b_ext_radar ; 19 :
99566: LD_ADDR_OWVAR 42
99570: PUSH
99571: LD_INT 20
99573: ST_TO_ADDR
99574: GO 99881
99576: LD_INT 19
99578: DOUBLE
99579: EQUAL
99580: IFTRUE 99584
99582: GO 99595
99584: POP
// bc_type := b_ext_radio ; 20 :
99585: LD_ADDR_OWVAR 42
99589: PUSH
99590: LD_INT 22
99592: ST_TO_ADDR
99593: GO 99881
99595: LD_INT 20
99597: DOUBLE
99598: EQUAL
99599: IFTRUE 99603
99601: GO 99614
99603: POP
// bc_type := b_ext_siberium ; 21 :
99604: LD_ADDR_OWVAR 42
99608: PUSH
99609: LD_INT 21
99611: ST_TO_ADDR
99612: GO 99881
99614: LD_INT 21
99616: DOUBLE
99617: EQUAL
99618: IFTRUE 99622
99620: GO 99633
99622: POP
// bc_type := b_ext_computer ; 22 :
99623: LD_ADDR_OWVAR 42
99627: PUSH
99628: LD_INT 24
99630: ST_TO_ADDR
99631: GO 99881
99633: LD_INT 22
99635: DOUBLE
99636: EQUAL
99637: IFTRUE 99641
99639: GO 99652
99641: POP
// bc_type := b_ext_track ; 23 :
99642: LD_ADDR_OWVAR 42
99646: PUSH
99647: LD_INT 16
99649: ST_TO_ADDR
99650: GO 99881
99652: LD_INT 23
99654: DOUBLE
99655: EQUAL
99656: IFTRUE 99660
99658: GO 99671
99660: POP
// bc_type := b_ext_laser ; 24 :
99661: LD_ADDR_OWVAR 42
99665: PUSH
99666: LD_INT 25
99668: ST_TO_ADDR
99669: GO 99881
99671: LD_INT 24
99673: DOUBLE
99674: EQUAL
99675: IFTRUE 99679
99677: GO 99690
99679: POP
// bc_type := b_control_tower ; 25 :
99680: LD_ADDR_OWVAR 42
99684: PUSH
99685: LD_INT 36
99687: ST_TO_ADDR
99688: GO 99881
99690: LD_INT 25
99692: DOUBLE
99693: EQUAL
99694: IFTRUE 99698
99696: GO 99709
99698: POP
// bc_type := b_breastwork ; 26 :
99699: LD_ADDR_OWVAR 42
99703: PUSH
99704: LD_INT 31
99706: ST_TO_ADDR
99707: GO 99881
99709: LD_INT 26
99711: DOUBLE
99712: EQUAL
99713: IFTRUE 99717
99715: GO 99728
99717: POP
// bc_type := b_bunker ; 27 :
99718: LD_ADDR_OWVAR 42
99722: PUSH
99723: LD_INT 32
99725: ST_TO_ADDR
99726: GO 99881
99728: LD_INT 27
99730: DOUBLE
99731: EQUAL
99732: IFTRUE 99736
99734: GO 99747
99736: POP
// bc_type := b_turret ; 28 :
99737: LD_ADDR_OWVAR 42
99741: PUSH
99742: LD_INT 33
99744: ST_TO_ADDR
99745: GO 99881
99747: LD_INT 28
99749: DOUBLE
99750: EQUAL
99751: IFTRUE 99755
99753: GO 99766
99755: POP
// bc_type := b_armoury ; 29 :
99756: LD_ADDR_OWVAR 42
99760: PUSH
99761: LD_INT 4
99763: ST_TO_ADDR
99764: GO 99881
99766: LD_INT 29
99768: DOUBLE
99769: EQUAL
99770: IFTRUE 99774
99772: GO 99785
99774: POP
// bc_type := b_barracks ; 30 :
99775: LD_ADDR_OWVAR 42
99779: PUSH
99780: LD_INT 5
99782: ST_TO_ADDR
99783: GO 99881
99785: LD_INT 30
99787: DOUBLE
99788: EQUAL
99789: IFTRUE 99793
99791: GO 99804
99793: POP
// bc_type := b_solar_power ; 31 :
99794: LD_ADDR_OWVAR 42
99798: PUSH
99799: LD_INT 27
99801: ST_TO_ADDR
99802: GO 99881
99804: LD_INT 31
99806: DOUBLE
99807: EQUAL
99808: IFTRUE 99812
99810: GO 99823
99812: POP
// bc_type := b_oil_power ; 32 :
99813: LD_ADDR_OWVAR 42
99817: PUSH
99818: LD_INT 26
99820: ST_TO_ADDR
99821: GO 99881
99823: LD_INT 32
99825: DOUBLE
99826: EQUAL
99827: IFTRUE 99831
99829: GO 99842
99831: POP
// bc_type := b_siberite_power ; 33 :
99832: LD_ADDR_OWVAR 42
99836: PUSH
99837: LD_INT 28
99839: ST_TO_ADDR
99840: GO 99881
99842: LD_INT 33
99844: DOUBLE
99845: EQUAL
99846: IFTRUE 99850
99848: GO 99861
99850: POP
// bc_type := b_oil_mine ; 34 :
99851: LD_ADDR_OWVAR 42
99855: PUSH
99856: LD_INT 29
99858: ST_TO_ADDR
99859: GO 99881
99861: LD_INT 34
99863: DOUBLE
99864: EQUAL
99865: IFTRUE 99869
99867: GO 99880
99869: POP
// bc_type := b_siberite_mine ; end ;
99870: LD_ADDR_OWVAR 42
99874: PUSH
99875: LD_INT 30
99877: ST_TO_ADDR
99878: GO 99881
99880: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
99881: LD_ADDR_VAR 0 8
99885: PUSH
99886: LD_VAR 0 5
99890: PPUSH
99891: LD_VAR 0 6
99895: PPUSH
99896: LD_VAR 0 3
99900: PPUSH
99901: CALL_OW 47
99905: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
99906: LD_OWVAR 42
99910: PUSH
99911: LD_INT 32
99913: PUSH
99914: LD_INT 33
99916: PUSH
99917: EMPTY
99918: LIST
99919: LIST
99920: IN
99921: IFFALSE 99937
// PlaceWeaponTurret ( b , weapon ) ;
99923: LD_VAR 0 8
99927: PPUSH
99928: LD_VAR 0 4
99932: PPUSH
99933: CALL_OW 431
// end ;
99937: LD_VAR 0 7
99941: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
99942: LD_INT 0
99944: PPUSH
99945: PPUSH
99946: PPUSH
99947: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99948: LD_ADDR_VAR 0 4
99952: PUSH
99953: LD_INT 22
99955: PUSH
99956: LD_OWVAR 2
99960: PUSH
99961: EMPTY
99962: LIST
99963: LIST
99964: PUSH
99965: LD_INT 2
99967: PUSH
99968: LD_INT 30
99970: PUSH
99971: LD_INT 0
99973: PUSH
99974: EMPTY
99975: LIST
99976: LIST
99977: PUSH
99978: LD_INT 30
99980: PUSH
99981: LD_INT 1
99983: PUSH
99984: EMPTY
99985: LIST
99986: LIST
99987: PUSH
99988: EMPTY
99989: LIST
99990: LIST
99991: LIST
99992: PUSH
99993: EMPTY
99994: LIST
99995: LIST
99996: PPUSH
99997: CALL_OW 69
100001: ST_TO_ADDR
// if not tmp then
100002: LD_VAR 0 4
100006: NOT
100007: IFFALSE 100011
// exit ;
100009: GO 100070
// for i in tmp do
100011: LD_ADDR_VAR 0 2
100015: PUSH
100016: LD_VAR 0 4
100020: PUSH
100021: FOR_IN
100022: IFFALSE 100068
// for j = 1 to 3 do
100024: LD_ADDR_VAR 0 3
100028: PUSH
100029: DOUBLE
100030: LD_INT 1
100032: DEC
100033: ST_TO_ADDR
100034: LD_INT 3
100036: PUSH
100037: FOR_TO
100038: IFFALSE 100064
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
100040: LD_VAR 0 2
100044: PPUSH
100045: CALL_OW 274
100049: PPUSH
100050: LD_VAR 0 3
100054: PPUSH
100055: LD_INT 99999
100057: PPUSH
100058: CALL_OW 277
100062: GO 100037
100064: POP
100065: POP
100066: GO 100021
100068: POP
100069: POP
// end ;
100070: LD_VAR 0 1
100074: RET
// export function hHackSetLevel10 ; var i , j ; begin
100075: LD_INT 0
100077: PPUSH
100078: PPUSH
100079: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100080: LD_ADDR_VAR 0 2
100084: PUSH
100085: LD_INT 21
100087: PUSH
100088: LD_INT 1
100090: PUSH
100091: EMPTY
100092: LIST
100093: LIST
100094: PPUSH
100095: CALL_OW 69
100099: PUSH
100100: FOR_IN
100101: IFFALSE 100153
// if IsSelected ( i ) then
100103: LD_VAR 0 2
100107: PPUSH
100108: CALL_OW 306
100112: IFFALSE 100151
// begin for j := 1 to 4 do
100114: LD_ADDR_VAR 0 3
100118: PUSH
100119: DOUBLE
100120: LD_INT 1
100122: DEC
100123: ST_TO_ADDR
100124: LD_INT 4
100126: PUSH
100127: FOR_TO
100128: IFFALSE 100149
// SetSkill ( i , j , 10 ) ;
100130: LD_VAR 0 2
100134: PPUSH
100135: LD_VAR 0 3
100139: PPUSH
100140: LD_INT 10
100142: PPUSH
100143: CALL_OW 237
100147: GO 100127
100149: POP
100150: POP
// end ;
100151: GO 100100
100153: POP
100154: POP
// end ;
100155: LD_VAR 0 1
100159: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
100160: LD_INT 0
100162: PPUSH
100163: PPUSH
100164: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
100165: LD_ADDR_VAR 0 2
100169: PUSH
100170: LD_INT 22
100172: PUSH
100173: LD_OWVAR 2
100177: PUSH
100178: EMPTY
100179: LIST
100180: LIST
100181: PUSH
100182: LD_INT 21
100184: PUSH
100185: LD_INT 1
100187: PUSH
100188: EMPTY
100189: LIST
100190: LIST
100191: PUSH
100192: EMPTY
100193: LIST
100194: LIST
100195: PPUSH
100196: CALL_OW 69
100200: PUSH
100201: FOR_IN
100202: IFFALSE 100243
// begin for j := 1 to 4 do
100204: LD_ADDR_VAR 0 3
100208: PUSH
100209: DOUBLE
100210: LD_INT 1
100212: DEC
100213: ST_TO_ADDR
100214: LD_INT 4
100216: PUSH
100217: FOR_TO
100218: IFFALSE 100239
// SetSkill ( i , j , 10 ) ;
100220: LD_VAR 0 2
100224: PPUSH
100225: LD_VAR 0 3
100229: PPUSH
100230: LD_INT 10
100232: PPUSH
100233: CALL_OW 237
100237: GO 100217
100239: POP
100240: POP
// end ;
100241: GO 100201
100243: POP
100244: POP
// end ;
100245: LD_VAR 0 1
100249: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
100250: LD_INT 0
100252: PPUSH
// uc_side := your_side ;
100253: LD_ADDR_OWVAR 20
100257: PUSH
100258: LD_OWVAR 2
100262: ST_TO_ADDR
// uc_nation := nation ;
100263: LD_ADDR_OWVAR 21
100267: PUSH
100268: LD_VAR 0 1
100272: ST_TO_ADDR
// InitHc ;
100273: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
100277: LD_INT 0
100279: PPUSH
100280: LD_VAR 0 2
100284: PPUSH
100285: LD_VAR 0 3
100289: PPUSH
100290: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
100294: LD_VAR 0 4
100298: PPUSH
100299: LD_VAR 0 5
100303: PPUSH
100304: CALL_OW 428
100308: PUSH
100309: LD_INT 0
100311: EQUAL
100312: IFFALSE 100336
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
100314: CALL_OW 44
100318: PPUSH
100319: LD_VAR 0 4
100323: PPUSH
100324: LD_VAR 0 5
100328: PPUSH
100329: LD_INT 1
100331: PPUSH
100332: CALL_OW 48
// end ;
100336: LD_VAR 0 6
100340: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
100341: LD_INT 0
100343: PPUSH
100344: PPUSH
// uc_side := your_side ;
100345: LD_ADDR_OWVAR 20
100349: PUSH
100350: LD_OWVAR 2
100354: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
100355: LD_VAR 0 1
100359: PUSH
100360: LD_INT 1
100362: PUSH
100363: LD_INT 2
100365: PUSH
100366: LD_INT 3
100368: PUSH
100369: LD_INT 4
100371: PUSH
100372: LD_INT 5
100374: PUSH
100375: EMPTY
100376: LIST
100377: LIST
100378: LIST
100379: LIST
100380: LIST
100381: IN
100382: IFFALSE 100394
// uc_nation := nation_american else
100384: LD_ADDR_OWVAR 21
100388: PUSH
100389: LD_INT 1
100391: ST_TO_ADDR
100392: GO 100437
// if chassis in [ 11 , 12 , 13 , 14 ] then
100394: LD_VAR 0 1
100398: PUSH
100399: LD_INT 11
100401: PUSH
100402: LD_INT 12
100404: PUSH
100405: LD_INT 13
100407: PUSH
100408: LD_INT 14
100410: PUSH
100411: EMPTY
100412: LIST
100413: LIST
100414: LIST
100415: LIST
100416: IN
100417: IFFALSE 100429
// uc_nation := nation_arabian else
100419: LD_ADDR_OWVAR 21
100423: PUSH
100424: LD_INT 2
100426: ST_TO_ADDR
100427: GO 100437
// uc_nation := nation_russian ;
100429: LD_ADDR_OWVAR 21
100433: PUSH
100434: LD_INT 3
100436: ST_TO_ADDR
// vc_chassis := chassis ;
100437: LD_ADDR_OWVAR 37
100441: PUSH
100442: LD_VAR 0 1
100446: ST_TO_ADDR
// vc_engine := engine ;
100447: LD_ADDR_OWVAR 39
100451: PUSH
100452: LD_VAR 0 2
100456: ST_TO_ADDR
// vc_control := control ;
100457: LD_ADDR_OWVAR 38
100461: PUSH
100462: LD_VAR 0 3
100466: ST_TO_ADDR
// vc_weapon := weapon ;
100467: LD_ADDR_OWVAR 40
100471: PUSH
100472: LD_VAR 0 4
100476: ST_TO_ADDR
// un := CreateVehicle ;
100477: LD_ADDR_VAR 0 8
100481: PUSH
100482: CALL_OW 45
100486: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
100487: LD_VAR 0 8
100491: PPUSH
100492: LD_INT 0
100494: PPUSH
100495: LD_INT 5
100497: PPUSH
100498: CALL_OW 12
100502: PPUSH
100503: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
100507: LD_VAR 0 8
100511: PPUSH
100512: LD_VAR 0 5
100516: PPUSH
100517: LD_VAR 0 6
100521: PPUSH
100522: LD_INT 1
100524: PPUSH
100525: CALL_OW 48
// end ;
100529: LD_VAR 0 7
100533: RET
// export hInvincible ; every 1 do
100534: GO 100536
100536: DISABLE
// hInvincible := [ ] ;
100537: LD_ADDR_EXP 161
100541: PUSH
100542: EMPTY
100543: ST_TO_ADDR
100544: END
// every 10 do var i ;
100545: GO 100547
100547: DISABLE
100548: LD_INT 0
100550: PPUSH
// begin enable ;
100551: ENABLE
// if not hInvincible then
100552: LD_EXP 161
100556: NOT
100557: IFFALSE 100561
// exit ;
100559: GO 100605
// for i in hInvincible do
100561: LD_ADDR_VAR 0 1
100565: PUSH
100566: LD_EXP 161
100570: PUSH
100571: FOR_IN
100572: IFFALSE 100603
// if GetLives ( i ) < 1000 then
100574: LD_VAR 0 1
100578: PPUSH
100579: CALL_OW 256
100583: PUSH
100584: LD_INT 1000
100586: LESS
100587: IFFALSE 100601
// SetLives ( i , 1000 ) ;
100589: LD_VAR 0 1
100593: PPUSH
100594: LD_INT 1000
100596: PPUSH
100597: CALL_OW 234
100601: GO 100571
100603: POP
100604: POP
// end ;
100605: PPOPN 1
100607: END
// export function hHackInvincible ; var i ; begin
100608: LD_INT 0
100610: PPUSH
100611: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
100612: LD_ADDR_VAR 0 2
100616: PUSH
100617: LD_INT 2
100619: PUSH
100620: LD_INT 21
100622: PUSH
100623: LD_INT 1
100625: PUSH
100626: EMPTY
100627: LIST
100628: LIST
100629: PUSH
100630: LD_INT 21
100632: PUSH
100633: LD_INT 2
100635: PUSH
100636: EMPTY
100637: LIST
100638: LIST
100639: PUSH
100640: EMPTY
100641: LIST
100642: LIST
100643: LIST
100644: PPUSH
100645: CALL_OW 69
100649: PUSH
100650: FOR_IN
100651: IFFALSE 100712
// if IsSelected ( i ) then
100653: LD_VAR 0 2
100657: PPUSH
100658: CALL_OW 306
100662: IFFALSE 100710
// begin if i in hInvincible then
100664: LD_VAR 0 2
100668: PUSH
100669: LD_EXP 161
100673: IN
100674: IFFALSE 100694
// hInvincible := hInvincible diff i else
100676: LD_ADDR_EXP 161
100680: PUSH
100681: LD_EXP 161
100685: PUSH
100686: LD_VAR 0 2
100690: DIFF
100691: ST_TO_ADDR
100692: GO 100710
// hInvincible := hInvincible union i ;
100694: LD_ADDR_EXP 161
100698: PUSH
100699: LD_EXP 161
100703: PUSH
100704: LD_VAR 0 2
100708: UNION
100709: ST_TO_ADDR
// end ;
100710: GO 100650
100712: POP
100713: POP
// end ;
100714: LD_VAR 0 1
100718: RET
// export function hHackInvisible ; var i , j ; begin
100719: LD_INT 0
100721: PPUSH
100722: PPUSH
100723: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100724: LD_ADDR_VAR 0 2
100728: PUSH
100729: LD_INT 21
100731: PUSH
100732: LD_INT 1
100734: PUSH
100735: EMPTY
100736: LIST
100737: LIST
100738: PPUSH
100739: CALL_OW 69
100743: PUSH
100744: FOR_IN
100745: IFFALSE 100769
// if IsSelected ( i ) then
100747: LD_VAR 0 2
100751: PPUSH
100752: CALL_OW 306
100756: IFFALSE 100767
// ComForceInvisible ( i ) ;
100758: LD_VAR 0 2
100762: PPUSH
100763: CALL_OW 496
100767: GO 100744
100769: POP
100770: POP
// end ;
100771: LD_VAR 0 1
100775: RET
// export function hHackChangeYourSide ; begin
100776: LD_INT 0
100778: PPUSH
// if your_side = 8 then
100779: LD_OWVAR 2
100783: PUSH
100784: LD_INT 8
100786: EQUAL
100787: IFFALSE 100799
// your_side := 0 else
100789: LD_ADDR_OWVAR 2
100793: PUSH
100794: LD_INT 0
100796: ST_TO_ADDR
100797: GO 100813
// your_side := your_side + 1 ;
100799: LD_ADDR_OWVAR 2
100803: PUSH
100804: LD_OWVAR 2
100808: PUSH
100809: LD_INT 1
100811: PLUS
100812: ST_TO_ADDR
// end ;
100813: LD_VAR 0 1
100817: RET
// export function hHackChangeUnitSide ; var i , j ; begin
100818: LD_INT 0
100820: PPUSH
100821: PPUSH
100822: PPUSH
// for i in all_units do
100823: LD_ADDR_VAR 0 2
100827: PUSH
100828: LD_OWVAR 3
100832: PUSH
100833: FOR_IN
100834: IFFALSE 100912
// if IsSelected ( i ) then
100836: LD_VAR 0 2
100840: PPUSH
100841: CALL_OW 306
100845: IFFALSE 100910
// begin j := GetSide ( i ) ;
100847: LD_ADDR_VAR 0 3
100851: PUSH
100852: LD_VAR 0 2
100856: PPUSH
100857: CALL_OW 255
100861: ST_TO_ADDR
// if j = 8 then
100862: LD_VAR 0 3
100866: PUSH
100867: LD_INT 8
100869: EQUAL
100870: IFFALSE 100882
// j := 0 else
100872: LD_ADDR_VAR 0 3
100876: PUSH
100877: LD_INT 0
100879: ST_TO_ADDR
100880: GO 100896
// j := j + 1 ;
100882: LD_ADDR_VAR 0 3
100886: PUSH
100887: LD_VAR 0 3
100891: PUSH
100892: LD_INT 1
100894: PLUS
100895: ST_TO_ADDR
// SetSide ( i , j ) ;
100896: LD_VAR 0 2
100900: PPUSH
100901: LD_VAR 0 3
100905: PPUSH
100906: CALL_OW 235
// end ;
100910: GO 100833
100912: POP
100913: POP
// end ;
100914: LD_VAR 0 1
100918: RET
// export function hHackFog ; begin
100919: LD_INT 0
100921: PPUSH
// FogOff ( true ) ;
100922: LD_INT 1
100924: PPUSH
100925: CALL_OW 344
// end ;
100929: LD_VAR 0 1
100933: RET
// export function hHackTeleport ( unit , x , y ) ; begin
100934: LD_INT 0
100936: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
100937: LD_VAR 0 1
100941: PPUSH
100942: LD_VAR 0 2
100946: PPUSH
100947: LD_VAR 0 3
100951: PPUSH
100952: LD_INT 1
100954: PPUSH
100955: LD_INT 1
100957: PPUSH
100958: CALL_OW 483
// CenterOnXY ( x , y ) ;
100962: LD_VAR 0 2
100966: PPUSH
100967: LD_VAR 0 3
100971: PPUSH
100972: CALL_OW 84
// end ;
100976: LD_VAR 0 4
100980: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
100981: LD_INT 0
100983: PPUSH
100984: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
100985: LD_VAR 0 1
100989: NOT
100990: PUSH
100991: LD_VAR 0 2
100995: PPUSH
100996: LD_VAR 0 3
101000: PPUSH
101001: CALL_OW 488
101005: NOT
101006: OR
101007: PUSH
101008: LD_VAR 0 1
101012: PPUSH
101013: CALL_OW 266
101017: PUSH
101018: LD_INT 3
101020: NONEQUAL
101021: PUSH
101022: LD_VAR 0 1
101026: PPUSH
101027: CALL_OW 247
101031: PUSH
101032: LD_INT 1
101034: EQUAL
101035: NOT
101036: AND
101037: OR
101038: IFFALSE 101042
// exit ;
101040: GO 101191
// if GetType ( factory ) = unit_human then
101042: LD_VAR 0 1
101046: PPUSH
101047: CALL_OW 247
101051: PUSH
101052: LD_INT 1
101054: EQUAL
101055: IFFALSE 101072
// factory := IsInUnit ( factory ) ;
101057: LD_ADDR_VAR 0 1
101061: PUSH
101062: LD_VAR 0 1
101066: PPUSH
101067: CALL_OW 310
101071: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
101072: LD_VAR 0 1
101076: PPUSH
101077: CALL_OW 266
101081: PUSH
101082: LD_INT 3
101084: NONEQUAL
101085: IFFALSE 101089
// exit ;
101087: GO 101191
// if HexInfo ( x , y ) = factory then
101089: LD_VAR 0 2
101093: PPUSH
101094: LD_VAR 0 3
101098: PPUSH
101099: CALL_OW 428
101103: PUSH
101104: LD_VAR 0 1
101108: EQUAL
101109: IFFALSE 101136
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
101111: LD_ADDR_EXP 162
101115: PUSH
101116: LD_EXP 162
101120: PPUSH
101121: LD_VAR 0 1
101125: PPUSH
101126: LD_INT 0
101128: PPUSH
101129: CALL_OW 1
101133: ST_TO_ADDR
101134: GO 101187
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
101136: LD_ADDR_EXP 162
101140: PUSH
101141: LD_EXP 162
101145: PPUSH
101146: LD_VAR 0 1
101150: PPUSH
101151: LD_VAR 0 1
101155: PPUSH
101156: CALL_OW 255
101160: PUSH
101161: LD_VAR 0 1
101165: PUSH
101166: LD_VAR 0 2
101170: PUSH
101171: LD_VAR 0 3
101175: PUSH
101176: EMPTY
101177: LIST
101178: LIST
101179: LIST
101180: LIST
101181: PPUSH
101182: CALL_OW 1
101186: ST_TO_ADDR
// UpdateFactoryWaypoints ;
101187: CALL 101196 0 0
// end ;
101191: LD_VAR 0 4
101195: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
101196: LD_INT 0
101198: PPUSH
101199: PPUSH
101200: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
101201: LD_STRING resetFactoryWaypoint();
101203: PPUSH
101204: CALL_OW 559
// if factoryWaypoints then
101208: LD_EXP 162
101212: IFFALSE 101338
// begin list := PrepareArray ( factoryWaypoints ) ;
101214: LD_ADDR_VAR 0 3
101218: PUSH
101219: LD_EXP 162
101223: PPUSH
101224: CALL 55988 0 1
101228: ST_TO_ADDR
// for i := 1 to list do
101229: LD_ADDR_VAR 0 2
101233: PUSH
101234: DOUBLE
101235: LD_INT 1
101237: DEC
101238: ST_TO_ADDR
101239: LD_VAR 0 3
101243: PUSH
101244: FOR_TO
101245: IFFALSE 101336
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
101247: LD_STRING setFactoryWaypointXY(
101249: PUSH
101250: LD_VAR 0 3
101254: PUSH
101255: LD_VAR 0 2
101259: ARRAY
101260: PUSH
101261: LD_INT 1
101263: ARRAY
101264: STR
101265: PUSH
101266: LD_STRING ,
101268: STR
101269: PUSH
101270: LD_VAR 0 3
101274: PUSH
101275: LD_VAR 0 2
101279: ARRAY
101280: PUSH
101281: LD_INT 2
101283: ARRAY
101284: STR
101285: PUSH
101286: LD_STRING ,
101288: STR
101289: PUSH
101290: LD_VAR 0 3
101294: PUSH
101295: LD_VAR 0 2
101299: ARRAY
101300: PUSH
101301: LD_INT 3
101303: ARRAY
101304: STR
101305: PUSH
101306: LD_STRING ,
101308: STR
101309: PUSH
101310: LD_VAR 0 3
101314: PUSH
101315: LD_VAR 0 2
101319: ARRAY
101320: PUSH
101321: LD_INT 4
101323: ARRAY
101324: STR
101325: PUSH
101326: LD_STRING )
101328: STR
101329: PPUSH
101330: CALL_OW 559
101334: GO 101244
101336: POP
101337: POP
// end ; end ;
101338: LD_VAR 0 1
101342: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
101343: LD_INT 0
101345: PPUSH
// if HexInfo ( x , y ) = warehouse then
101346: LD_VAR 0 2
101350: PPUSH
101351: LD_VAR 0 3
101355: PPUSH
101356: CALL_OW 428
101360: PUSH
101361: LD_VAR 0 1
101365: EQUAL
101366: IFFALSE 101393
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
101368: LD_ADDR_EXP 163
101372: PUSH
101373: LD_EXP 163
101377: PPUSH
101378: LD_VAR 0 1
101382: PPUSH
101383: LD_INT 0
101385: PPUSH
101386: CALL_OW 1
101390: ST_TO_ADDR
101391: GO 101444
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
101393: LD_ADDR_EXP 163
101397: PUSH
101398: LD_EXP 163
101402: PPUSH
101403: LD_VAR 0 1
101407: PPUSH
101408: LD_VAR 0 1
101412: PPUSH
101413: CALL_OW 255
101417: PUSH
101418: LD_VAR 0 1
101422: PUSH
101423: LD_VAR 0 2
101427: PUSH
101428: LD_VAR 0 3
101432: PUSH
101433: EMPTY
101434: LIST
101435: LIST
101436: LIST
101437: LIST
101438: PPUSH
101439: CALL_OW 1
101443: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
101444: CALL 101453 0 0
// end ;
101448: LD_VAR 0 4
101452: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
101453: LD_INT 0
101455: PPUSH
101456: PPUSH
101457: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
101458: LD_STRING resetWarehouseGatheringPoints();
101460: PPUSH
101461: CALL_OW 559
// if warehouseGatheringPoints then
101465: LD_EXP 163
101469: IFFALSE 101595
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
101471: LD_ADDR_VAR 0 3
101475: PUSH
101476: LD_EXP 163
101480: PPUSH
101481: CALL 55988 0 1
101485: ST_TO_ADDR
// for i := 1 to list do
101486: LD_ADDR_VAR 0 2
101490: PUSH
101491: DOUBLE
101492: LD_INT 1
101494: DEC
101495: ST_TO_ADDR
101496: LD_VAR 0 3
101500: PUSH
101501: FOR_TO
101502: IFFALSE 101593
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
101504: LD_STRING setWarehouseGatheringPointXY(
101506: PUSH
101507: LD_VAR 0 3
101511: PUSH
101512: LD_VAR 0 2
101516: ARRAY
101517: PUSH
101518: LD_INT 1
101520: ARRAY
101521: STR
101522: PUSH
101523: LD_STRING ,
101525: STR
101526: PUSH
101527: LD_VAR 0 3
101531: PUSH
101532: LD_VAR 0 2
101536: ARRAY
101537: PUSH
101538: LD_INT 2
101540: ARRAY
101541: STR
101542: PUSH
101543: LD_STRING ,
101545: STR
101546: PUSH
101547: LD_VAR 0 3
101551: PUSH
101552: LD_VAR 0 2
101556: ARRAY
101557: PUSH
101558: LD_INT 3
101560: ARRAY
101561: STR
101562: PUSH
101563: LD_STRING ,
101565: STR
101566: PUSH
101567: LD_VAR 0 3
101571: PUSH
101572: LD_VAR 0 2
101576: ARRAY
101577: PUSH
101578: LD_INT 4
101580: ARRAY
101581: STR
101582: PUSH
101583: LD_STRING )
101585: STR
101586: PPUSH
101587: CALL_OW 559
101591: GO 101501
101593: POP
101594: POP
// end ; end ;
101595: LD_VAR 0 1
101599: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
101600: LD_EXP 163
101604: IFFALSE 102289
101606: GO 101608
101608: DISABLE
101609: LD_INT 0
101611: PPUSH
101612: PPUSH
101613: PPUSH
101614: PPUSH
101615: PPUSH
101616: PPUSH
101617: PPUSH
101618: PPUSH
101619: PPUSH
// begin enable ;
101620: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
101621: LD_ADDR_VAR 0 3
101625: PUSH
101626: LD_EXP 163
101630: PPUSH
101631: CALL 55988 0 1
101635: ST_TO_ADDR
// if not list then
101636: LD_VAR 0 3
101640: NOT
101641: IFFALSE 101645
// exit ;
101643: GO 102289
// for i := 1 to list do
101645: LD_ADDR_VAR 0 1
101649: PUSH
101650: DOUBLE
101651: LD_INT 1
101653: DEC
101654: ST_TO_ADDR
101655: LD_VAR 0 3
101659: PUSH
101660: FOR_TO
101661: IFFALSE 102287
// begin depot := list [ i ] [ 2 ] ;
101663: LD_ADDR_VAR 0 8
101667: PUSH
101668: LD_VAR 0 3
101672: PUSH
101673: LD_VAR 0 1
101677: ARRAY
101678: PUSH
101679: LD_INT 2
101681: ARRAY
101682: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
101683: LD_ADDR_VAR 0 5
101687: PUSH
101688: LD_VAR 0 3
101692: PUSH
101693: LD_VAR 0 1
101697: ARRAY
101698: PUSH
101699: LD_INT 1
101701: ARRAY
101702: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
101703: LD_VAR 0 8
101707: PPUSH
101708: CALL_OW 301
101712: PUSH
101713: LD_VAR 0 5
101717: PUSH
101718: LD_VAR 0 8
101722: PPUSH
101723: CALL_OW 255
101727: NONEQUAL
101728: OR
101729: IFFALSE 101758
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
101731: LD_ADDR_EXP 163
101735: PUSH
101736: LD_EXP 163
101740: PPUSH
101741: LD_VAR 0 8
101745: PPUSH
101746: LD_INT 0
101748: PPUSH
101749: CALL_OW 1
101753: ST_TO_ADDR
// exit ;
101754: POP
101755: POP
101756: GO 102289
// end ; x := list [ i ] [ 3 ] ;
101758: LD_ADDR_VAR 0 6
101762: PUSH
101763: LD_VAR 0 3
101767: PUSH
101768: LD_VAR 0 1
101772: ARRAY
101773: PUSH
101774: LD_INT 3
101776: ARRAY
101777: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
101778: LD_ADDR_VAR 0 7
101782: PUSH
101783: LD_VAR 0 3
101787: PUSH
101788: LD_VAR 0 1
101792: ARRAY
101793: PUSH
101794: LD_INT 4
101796: ARRAY
101797: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
101798: LD_ADDR_VAR 0 9
101802: PUSH
101803: LD_VAR 0 6
101807: PPUSH
101808: LD_VAR 0 7
101812: PPUSH
101813: LD_INT 16
101815: PPUSH
101816: CALL 54576 0 3
101820: ST_TO_ADDR
// if not cratesNearbyPoint then
101821: LD_VAR 0 9
101825: NOT
101826: IFFALSE 101832
// exit ;
101828: POP
101829: POP
101830: GO 102289
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
101832: LD_ADDR_VAR 0 4
101836: PUSH
101837: LD_INT 22
101839: PUSH
101840: LD_VAR 0 5
101844: PUSH
101845: EMPTY
101846: LIST
101847: LIST
101848: PUSH
101849: LD_INT 3
101851: PUSH
101852: LD_INT 60
101854: PUSH
101855: EMPTY
101856: LIST
101857: PUSH
101858: EMPTY
101859: LIST
101860: LIST
101861: PUSH
101862: LD_INT 91
101864: PUSH
101865: LD_VAR 0 8
101869: PUSH
101870: LD_INT 6
101872: PUSH
101873: EMPTY
101874: LIST
101875: LIST
101876: LIST
101877: PUSH
101878: LD_INT 2
101880: PUSH
101881: LD_INT 25
101883: PUSH
101884: LD_INT 2
101886: PUSH
101887: EMPTY
101888: LIST
101889: LIST
101890: PUSH
101891: LD_INT 25
101893: PUSH
101894: LD_INT 16
101896: PUSH
101897: EMPTY
101898: LIST
101899: LIST
101900: PUSH
101901: EMPTY
101902: LIST
101903: LIST
101904: LIST
101905: PUSH
101906: EMPTY
101907: LIST
101908: LIST
101909: LIST
101910: LIST
101911: PPUSH
101912: CALL_OW 69
101916: PUSH
101917: LD_VAR 0 8
101921: PPUSH
101922: CALL_OW 313
101926: PPUSH
101927: LD_INT 3
101929: PUSH
101930: LD_INT 60
101932: PUSH
101933: EMPTY
101934: LIST
101935: PUSH
101936: EMPTY
101937: LIST
101938: LIST
101939: PUSH
101940: LD_INT 2
101942: PUSH
101943: LD_INT 25
101945: PUSH
101946: LD_INT 2
101948: PUSH
101949: EMPTY
101950: LIST
101951: LIST
101952: PUSH
101953: LD_INT 25
101955: PUSH
101956: LD_INT 16
101958: PUSH
101959: EMPTY
101960: LIST
101961: LIST
101962: PUSH
101963: EMPTY
101964: LIST
101965: LIST
101966: LIST
101967: PUSH
101968: EMPTY
101969: LIST
101970: LIST
101971: PPUSH
101972: CALL_OW 72
101976: UNION
101977: ST_TO_ADDR
// if tmp then
101978: LD_VAR 0 4
101982: IFFALSE 102062
// begin tmp := ShrinkArray ( tmp , 3 ) ;
101984: LD_ADDR_VAR 0 4
101988: PUSH
101989: LD_VAR 0 4
101993: PPUSH
101994: LD_INT 3
101996: PPUSH
101997: CALL 52545 0 2
102001: ST_TO_ADDR
// for j in tmp do
102002: LD_ADDR_VAR 0 2
102006: PUSH
102007: LD_VAR 0 4
102011: PUSH
102012: FOR_IN
102013: IFFALSE 102056
// begin if IsInUnit ( j ) then
102015: LD_VAR 0 2
102019: PPUSH
102020: CALL_OW 310
102024: IFFALSE 102035
// ComExit ( j ) ;
102026: LD_VAR 0 2
102030: PPUSH
102031: CALL 52628 0 1
// AddComCollect ( j , x , y ) ;
102035: LD_VAR 0 2
102039: PPUSH
102040: LD_VAR 0 6
102044: PPUSH
102045: LD_VAR 0 7
102049: PPUSH
102050: CALL_OW 177
// end ;
102054: GO 102012
102056: POP
102057: POP
// exit ;
102058: POP
102059: POP
102060: GO 102289
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
102062: LD_ADDR_VAR 0 4
102066: PUSH
102067: LD_INT 22
102069: PUSH
102070: LD_VAR 0 5
102074: PUSH
102075: EMPTY
102076: LIST
102077: LIST
102078: PUSH
102079: LD_INT 91
102081: PUSH
102082: LD_VAR 0 8
102086: PUSH
102087: LD_INT 8
102089: PUSH
102090: EMPTY
102091: LIST
102092: LIST
102093: LIST
102094: PUSH
102095: LD_INT 2
102097: PUSH
102098: LD_INT 34
102100: PUSH
102101: LD_INT 12
102103: PUSH
102104: EMPTY
102105: LIST
102106: LIST
102107: PUSH
102108: LD_INT 34
102110: PUSH
102111: LD_INT 51
102113: PUSH
102114: EMPTY
102115: LIST
102116: LIST
102117: PUSH
102118: LD_INT 34
102120: PUSH
102121: LD_INT 32
102123: PUSH
102124: EMPTY
102125: LIST
102126: LIST
102127: PUSH
102128: LD_INT 34
102130: PUSH
102131: LD_INT 89
102133: PUSH
102134: EMPTY
102135: LIST
102136: LIST
102137: PUSH
102138: EMPTY
102139: LIST
102140: LIST
102141: LIST
102142: LIST
102143: LIST
102144: PUSH
102145: EMPTY
102146: LIST
102147: LIST
102148: LIST
102149: PPUSH
102150: CALL_OW 69
102154: ST_TO_ADDR
// if tmp then
102155: LD_VAR 0 4
102159: IFFALSE 102285
// begin for j in tmp do
102161: LD_ADDR_VAR 0 2
102165: PUSH
102166: LD_VAR 0 4
102170: PUSH
102171: FOR_IN
102172: IFFALSE 102283
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
102174: LD_VAR 0 2
102178: PPUSH
102179: CALL_OW 262
102183: PUSH
102184: LD_INT 3
102186: EQUAL
102187: PUSH
102188: LD_VAR 0 2
102192: PPUSH
102193: CALL_OW 261
102197: PUSH
102198: LD_INT 20
102200: GREATER
102201: OR
102202: PUSH
102203: LD_VAR 0 2
102207: PPUSH
102208: CALL_OW 314
102212: NOT
102213: AND
102214: PUSH
102215: LD_VAR 0 2
102219: PPUSH
102220: CALL_OW 263
102224: PUSH
102225: LD_INT 1
102227: NONEQUAL
102228: PUSH
102229: LD_VAR 0 2
102233: PPUSH
102234: CALL_OW 311
102238: OR
102239: AND
102240: IFFALSE 102281
// begin ComCollect ( j , x , y ) ;
102242: LD_VAR 0 2
102246: PPUSH
102247: LD_VAR 0 6
102251: PPUSH
102252: LD_VAR 0 7
102256: PPUSH
102257: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
102261: LD_VAR 0 2
102265: PPUSH
102266: LD_VAR 0 8
102270: PPUSH
102271: CALL_OW 172
// exit ;
102275: POP
102276: POP
102277: POP
102278: POP
102279: GO 102289
// end ;
102281: GO 102171
102283: POP
102284: POP
// end ; end ;
102285: GO 101660
102287: POP
102288: POP
// end ; end_of_file
102289: PPOPN 9
102291: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
102292: LD_INT 0
102294: PPUSH
102295: PPUSH
102296: PPUSH
102297: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
102298: LD_VAR 0 1
102302: PPUSH
102303: CALL_OW 264
102307: PUSH
102308: LD_INT 91
102310: EQUAL
102311: IFFALSE 102383
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
102313: LD_INT 68
102315: PPUSH
102316: LD_VAR 0 1
102320: PPUSH
102321: CALL_OW 255
102325: PPUSH
102326: CALL_OW 321
102330: PUSH
102331: LD_INT 2
102333: EQUAL
102334: IFFALSE 102346
// eff := 70 else
102336: LD_ADDR_VAR 0 4
102340: PUSH
102341: LD_INT 70
102343: ST_TO_ADDR
102344: GO 102354
// eff := 30 ;
102346: LD_ADDR_VAR 0 4
102350: PUSH
102351: LD_INT 30
102353: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
102354: LD_VAR 0 1
102358: PPUSH
102359: CALL_OW 250
102363: PPUSH
102364: LD_VAR 0 1
102368: PPUSH
102369: CALL_OW 251
102373: PPUSH
102374: LD_VAR 0 4
102378: PPUSH
102379: CALL_OW 495
// end ; end ;
102383: LD_VAR 0 2
102387: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
102388: LD_INT 0
102390: PPUSH
// end ;
102391: LD_VAR 0 4
102395: RET
// export function SOS_Command ( cmd ) ; begin
102396: LD_INT 0
102398: PPUSH
// end ;
102399: LD_VAR 0 2
102403: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
102404: LD_INT 0
102406: PPUSH
// end ;
102407: LD_VAR 0 6
102411: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
102412: LD_INT 0
102414: PPUSH
102415: PPUSH
// if not vehicle or not factory then
102416: LD_VAR 0 1
102420: NOT
102421: PUSH
102422: LD_VAR 0 2
102426: NOT
102427: OR
102428: IFFALSE 102432
// exit ;
102430: GO 102663
// if factoryWaypoints >= factory then
102432: LD_EXP 162
102436: PUSH
102437: LD_VAR 0 2
102441: GREATEREQUAL
102442: IFFALSE 102663
// if factoryWaypoints [ factory ] then
102444: LD_EXP 162
102448: PUSH
102449: LD_VAR 0 2
102453: ARRAY
102454: IFFALSE 102663
// begin if GetControl ( vehicle ) = control_manual then
102456: LD_VAR 0 1
102460: PPUSH
102461: CALL_OW 263
102465: PUSH
102466: LD_INT 1
102468: EQUAL
102469: IFFALSE 102550
// begin driver := IsDrivenBy ( vehicle ) ;
102471: LD_ADDR_VAR 0 4
102475: PUSH
102476: LD_VAR 0 1
102480: PPUSH
102481: CALL_OW 311
102485: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
102486: LD_VAR 0 4
102490: PPUSH
102491: LD_EXP 162
102495: PUSH
102496: LD_VAR 0 2
102500: ARRAY
102501: PUSH
102502: LD_INT 3
102504: ARRAY
102505: PPUSH
102506: LD_EXP 162
102510: PUSH
102511: LD_VAR 0 2
102515: ARRAY
102516: PUSH
102517: LD_INT 4
102519: ARRAY
102520: PPUSH
102521: CALL_OW 171
// AddComExitVehicle ( driver ) ;
102525: LD_VAR 0 4
102529: PPUSH
102530: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
102534: LD_VAR 0 4
102538: PPUSH
102539: LD_VAR 0 2
102543: PPUSH
102544: CALL_OW 180
// end else
102548: GO 102663
// if GetControl ( vehicle ) = control_remote then
102550: LD_VAR 0 1
102554: PPUSH
102555: CALL_OW 263
102559: PUSH
102560: LD_INT 2
102562: EQUAL
102563: IFFALSE 102624
// begin wait ( 0 0$2 ) ;
102565: LD_INT 70
102567: PPUSH
102568: CALL_OW 67
// if Connect ( vehicle ) then
102572: LD_VAR 0 1
102576: PPUSH
102577: CALL 22960 0 1
102581: IFFALSE 102622
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
102583: LD_VAR 0 1
102587: PPUSH
102588: LD_EXP 162
102592: PUSH
102593: LD_VAR 0 2
102597: ARRAY
102598: PUSH
102599: LD_INT 3
102601: ARRAY
102602: PPUSH
102603: LD_EXP 162
102607: PUSH
102608: LD_VAR 0 2
102612: ARRAY
102613: PUSH
102614: LD_INT 4
102616: ARRAY
102617: PPUSH
102618: CALL_OW 171
// end else
102622: GO 102663
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
102624: LD_VAR 0 1
102628: PPUSH
102629: LD_EXP 162
102633: PUSH
102634: LD_VAR 0 2
102638: ARRAY
102639: PUSH
102640: LD_INT 3
102642: ARRAY
102643: PPUSH
102644: LD_EXP 162
102648: PUSH
102649: LD_VAR 0 2
102653: ARRAY
102654: PUSH
102655: LD_INT 4
102657: ARRAY
102658: PPUSH
102659: CALL_OW 171
// end ; end ;
102663: LD_VAR 0 3
102667: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
102668: LD_INT 0
102670: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
102671: LD_VAR 0 1
102675: PUSH
102676: LD_INT 250
102678: EQUAL
102679: PUSH
102680: LD_VAR 0 2
102684: PPUSH
102685: CALL_OW 264
102689: PUSH
102690: LD_INT 81
102692: EQUAL
102693: AND
102694: IFFALSE 102715
// MinerPlaceMine ( unit , x , y ) ;
102696: LD_VAR 0 2
102700: PPUSH
102701: LD_VAR 0 4
102705: PPUSH
102706: LD_VAR 0 5
102710: PPUSH
102711: CALL 105100 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
102715: LD_VAR 0 1
102719: PUSH
102720: LD_INT 251
102722: EQUAL
102723: PUSH
102724: LD_VAR 0 2
102728: PPUSH
102729: CALL_OW 264
102733: PUSH
102734: LD_INT 81
102736: EQUAL
102737: AND
102738: IFFALSE 102759
// MinerDetonateMine ( unit , x , y ) ;
102740: LD_VAR 0 2
102744: PPUSH
102745: LD_VAR 0 4
102749: PPUSH
102750: LD_VAR 0 5
102754: PPUSH
102755: CALL 105375 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
102759: LD_VAR 0 1
102763: PUSH
102764: LD_INT 252
102766: EQUAL
102767: PUSH
102768: LD_VAR 0 2
102772: PPUSH
102773: CALL_OW 264
102777: PUSH
102778: LD_INT 81
102780: EQUAL
102781: AND
102782: IFFALSE 102803
// MinerCreateMinefield ( unit , x , y ) ;
102784: LD_VAR 0 2
102788: PPUSH
102789: LD_VAR 0 4
102793: PPUSH
102794: LD_VAR 0 5
102798: PPUSH
102799: CALL 105792 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
102803: LD_VAR 0 1
102807: PUSH
102808: LD_INT 253
102810: EQUAL
102811: PUSH
102812: LD_VAR 0 2
102816: PPUSH
102817: CALL_OW 257
102821: PUSH
102822: LD_INT 5
102824: EQUAL
102825: AND
102826: IFFALSE 102847
// ComBinocular ( unit , x , y ) ;
102828: LD_VAR 0 2
102832: PPUSH
102833: LD_VAR 0 4
102837: PPUSH
102838: LD_VAR 0 5
102842: PPUSH
102843: CALL 106161 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
102847: LD_VAR 0 1
102851: PUSH
102852: LD_INT 254
102854: EQUAL
102855: PUSH
102856: LD_VAR 0 2
102860: PPUSH
102861: CALL_OW 264
102865: PUSH
102866: LD_INT 99
102868: EQUAL
102869: AND
102870: PUSH
102871: LD_VAR 0 3
102875: PPUSH
102876: CALL_OW 263
102880: PUSH
102881: LD_INT 3
102883: EQUAL
102884: AND
102885: IFFALSE 102901
// HackDestroyVehicle ( unit , selectedUnit ) ;
102887: LD_VAR 0 2
102891: PPUSH
102892: LD_VAR 0 3
102896: PPUSH
102897: CALL 104464 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
102901: LD_VAR 0 1
102905: PUSH
102906: LD_INT 255
102908: EQUAL
102909: PUSH
102910: LD_VAR 0 2
102914: PPUSH
102915: CALL_OW 264
102919: PUSH
102920: LD_INT 14
102922: PUSH
102923: LD_INT 53
102925: PUSH
102926: EMPTY
102927: LIST
102928: LIST
102929: IN
102930: AND
102931: PUSH
102932: LD_VAR 0 4
102936: PPUSH
102937: LD_VAR 0 5
102941: PPUSH
102942: CALL_OW 488
102946: AND
102947: IFFALSE 102971
// CutTreeXYR ( unit , x , y , 12 ) ;
102949: LD_VAR 0 2
102953: PPUSH
102954: LD_VAR 0 4
102958: PPUSH
102959: LD_VAR 0 5
102963: PPUSH
102964: LD_INT 12
102966: PPUSH
102967: CALL 103034 0 4
// if cmd = 256 then
102971: LD_VAR 0 1
102975: PUSH
102976: LD_INT 256
102978: EQUAL
102979: IFFALSE 103000
// SetFactoryWaypoint ( unit , x , y ) ;
102981: LD_VAR 0 2
102985: PPUSH
102986: LD_VAR 0 4
102990: PPUSH
102991: LD_VAR 0 5
102995: PPUSH
102996: CALL 100981 0 3
// if cmd = 257 then
103000: LD_VAR 0 1
103004: PUSH
103005: LD_INT 257
103007: EQUAL
103008: IFFALSE 103029
// SetWarehouseGatheringPoint ( unit , x , y ) ;
103010: LD_VAR 0 2
103014: PPUSH
103015: LD_VAR 0 4
103019: PPUSH
103020: LD_VAR 0 5
103024: PPUSH
103025: CALL 101343 0 3
// end ;
103029: LD_VAR 0 6
103033: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
103034: LD_INT 0
103036: PPUSH
103037: PPUSH
103038: PPUSH
103039: PPUSH
103040: PPUSH
103041: PPUSH
103042: PPUSH
103043: PPUSH
103044: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
103045: LD_VAR 0 1
103049: NOT
103050: PUSH
103051: LD_VAR 0 2
103055: PPUSH
103056: LD_VAR 0 3
103060: PPUSH
103061: CALL_OW 488
103065: NOT
103066: OR
103067: PUSH
103068: LD_VAR 0 4
103072: NOT
103073: OR
103074: IFFALSE 103078
// exit ;
103076: GO 103418
// list := [ ] ;
103078: LD_ADDR_VAR 0 13
103082: PUSH
103083: EMPTY
103084: ST_TO_ADDR
// if x - r < 0 then
103085: LD_VAR 0 2
103089: PUSH
103090: LD_VAR 0 4
103094: MINUS
103095: PUSH
103096: LD_INT 0
103098: LESS
103099: IFFALSE 103111
// min_x := 0 else
103101: LD_ADDR_VAR 0 7
103105: PUSH
103106: LD_INT 0
103108: ST_TO_ADDR
103109: GO 103127
// min_x := x - r ;
103111: LD_ADDR_VAR 0 7
103115: PUSH
103116: LD_VAR 0 2
103120: PUSH
103121: LD_VAR 0 4
103125: MINUS
103126: ST_TO_ADDR
// if y - r < 0 then
103127: LD_VAR 0 3
103131: PUSH
103132: LD_VAR 0 4
103136: MINUS
103137: PUSH
103138: LD_INT 0
103140: LESS
103141: IFFALSE 103153
// min_y := 0 else
103143: LD_ADDR_VAR 0 8
103147: PUSH
103148: LD_INT 0
103150: ST_TO_ADDR
103151: GO 103169
// min_y := y - r ;
103153: LD_ADDR_VAR 0 8
103157: PUSH
103158: LD_VAR 0 3
103162: PUSH
103163: LD_VAR 0 4
103167: MINUS
103168: ST_TO_ADDR
// max_x := x + r ;
103169: LD_ADDR_VAR 0 9
103173: PUSH
103174: LD_VAR 0 2
103178: PUSH
103179: LD_VAR 0 4
103183: PLUS
103184: ST_TO_ADDR
// max_y := y + r ;
103185: LD_ADDR_VAR 0 10
103189: PUSH
103190: LD_VAR 0 3
103194: PUSH
103195: LD_VAR 0 4
103199: PLUS
103200: ST_TO_ADDR
// for _x = min_x to max_x do
103201: LD_ADDR_VAR 0 11
103205: PUSH
103206: DOUBLE
103207: LD_VAR 0 7
103211: DEC
103212: ST_TO_ADDR
103213: LD_VAR 0 9
103217: PUSH
103218: FOR_TO
103219: IFFALSE 103336
// for _y = min_y to max_y do
103221: LD_ADDR_VAR 0 12
103225: PUSH
103226: DOUBLE
103227: LD_VAR 0 8
103231: DEC
103232: ST_TO_ADDR
103233: LD_VAR 0 10
103237: PUSH
103238: FOR_TO
103239: IFFALSE 103332
// begin if not ValidHex ( _x , _y ) then
103241: LD_VAR 0 11
103245: PPUSH
103246: LD_VAR 0 12
103250: PPUSH
103251: CALL_OW 488
103255: NOT
103256: IFFALSE 103260
// continue ;
103258: GO 103238
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
103260: LD_VAR 0 11
103264: PPUSH
103265: LD_VAR 0 12
103269: PPUSH
103270: CALL_OW 351
103274: PUSH
103275: LD_VAR 0 11
103279: PPUSH
103280: LD_VAR 0 12
103284: PPUSH
103285: CALL_OW 554
103289: AND
103290: IFFALSE 103330
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
103292: LD_ADDR_VAR 0 13
103296: PUSH
103297: LD_VAR 0 13
103301: PPUSH
103302: LD_VAR 0 13
103306: PUSH
103307: LD_INT 1
103309: PLUS
103310: PPUSH
103311: LD_VAR 0 11
103315: PUSH
103316: LD_VAR 0 12
103320: PUSH
103321: EMPTY
103322: LIST
103323: LIST
103324: PPUSH
103325: CALL_OW 2
103329: ST_TO_ADDR
// end ;
103330: GO 103238
103332: POP
103333: POP
103334: GO 103218
103336: POP
103337: POP
// if not list then
103338: LD_VAR 0 13
103342: NOT
103343: IFFALSE 103347
// exit ;
103345: GO 103418
// for i in list do
103347: LD_ADDR_VAR 0 6
103351: PUSH
103352: LD_VAR 0 13
103356: PUSH
103357: FOR_IN
103358: IFFALSE 103416
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
103360: LD_VAR 0 1
103364: PPUSH
103365: LD_STRING M
103367: PUSH
103368: LD_VAR 0 6
103372: PUSH
103373: LD_INT 1
103375: ARRAY
103376: PUSH
103377: LD_VAR 0 6
103381: PUSH
103382: LD_INT 2
103384: ARRAY
103385: PUSH
103386: LD_INT 0
103388: PUSH
103389: LD_INT 0
103391: PUSH
103392: LD_INT 0
103394: PUSH
103395: LD_INT 0
103397: PUSH
103398: EMPTY
103399: LIST
103400: LIST
103401: LIST
103402: LIST
103403: LIST
103404: LIST
103405: LIST
103406: PUSH
103407: EMPTY
103408: LIST
103409: PPUSH
103410: CALL_OW 447
103414: GO 103357
103416: POP
103417: POP
// end ;
103418: LD_VAR 0 5
103422: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
103423: LD_EXP 165
103427: NOT
103428: IFFALSE 103478
103430: GO 103432
103432: DISABLE
// begin initHack := true ;
103433: LD_ADDR_EXP 165
103437: PUSH
103438: LD_INT 1
103440: ST_TO_ADDR
// hackTanks := [ ] ;
103441: LD_ADDR_EXP 166
103445: PUSH
103446: EMPTY
103447: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
103448: LD_ADDR_EXP 167
103452: PUSH
103453: EMPTY
103454: ST_TO_ADDR
// hackLimit := 3 ;
103455: LD_ADDR_EXP 168
103459: PUSH
103460: LD_INT 3
103462: ST_TO_ADDR
// hackDist := 12 ;
103463: LD_ADDR_EXP 169
103467: PUSH
103468: LD_INT 12
103470: ST_TO_ADDR
// hackCounter := [ ] ;
103471: LD_ADDR_EXP 170
103475: PUSH
103476: EMPTY
103477: ST_TO_ADDR
// end ;
103478: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
103479: LD_EXP 165
103483: PUSH
103484: LD_INT 34
103486: PUSH
103487: LD_INT 99
103489: PUSH
103490: EMPTY
103491: LIST
103492: LIST
103493: PPUSH
103494: CALL_OW 69
103498: AND
103499: IFFALSE 103752
103501: GO 103503
103503: DISABLE
103504: LD_INT 0
103506: PPUSH
103507: PPUSH
// begin enable ;
103508: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
103509: LD_ADDR_VAR 0 1
103513: PUSH
103514: LD_INT 34
103516: PUSH
103517: LD_INT 99
103519: PUSH
103520: EMPTY
103521: LIST
103522: LIST
103523: PPUSH
103524: CALL_OW 69
103528: PUSH
103529: FOR_IN
103530: IFFALSE 103750
// begin if not i in hackTanks then
103532: LD_VAR 0 1
103536: PUSH
103537: LD_EXP 166
103541: IN
103542: NOT
103543: IFFALSE 103626
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
103545: LD_ADDR_EXP 166
103549: PUSH
103550: LD_EXP 166
103554: PPUSH
103555: LD_EXP 166
103559: PUSH
103560: LD_INT 1
103562: PLUS
103563: PPUSH
103564: LD_VAR 0 1
103568: PPUSH
103569: CALL_OW 1
103573: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
103574: LD_ADDR_EXP 167
103578: PUSH
103579: LD_EXP 167
103583: PPUSH
103584: LD_EXP 167
103588: PUSH
103589: LD_INT 1
103591: PLUS
103592: PPUSH
103593: EMPTY
103594: PPUSH
103595: CALL_OW 1
103599: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
103600: LD_ADDR_EXP 170
103604: PUSH
103605: LD_EXP 170
103609: PPUSH
103610: LD_EXP 170
103614: PUSH
103615: LD_INT 1
103617: PLUS
103618: PPUSH
103619: EMPTY
103620: PPUSH
103621: CALL_OW 1
103625: ST_TO_ADDR
// end ; if not IsOk ( i ) then
103626: LD_VAR 0 1
103630: PPUSH
103631: CALL_OW 302
103635: NOT
103636: IFFALSE 103649
// begin HackUnlinkAll ( i ) ;
103638: LD_VAR 0 1
103642: PPUSH
103643: CALL 103755 0 1
// continue ;
103647: GO 103529
// end ; HackCheckCapturedStatus ( i ) ;
103649: LD_VAR 0 1
103653: PPUSH
103654: CALL 104198 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
103658: LD_ADDR_VAR 0 2
103662: PUSH
103663: LD_INT 81
103665: PUSH
103666: LD_VAR 0 1
103670: PPUSH
103671: CALL_OW 255
103675: PUSH
103676: EMPTY
103677: LIST
103678: LIST
103679: PUSH
103680: LD_INT 33
103682: PUSH
103683: LD_INT 3
103685: PUSH
103686: EMPTY
103687: LIST
103688: LIST
103689: PUSH
103690: LD_INT 91
103692: PUSH
103693: LD_VAR 0 1
103697: PUSH
103698: LD_EXP 169
103702: PUSH
103703: EMPTY
103704: LIST
103705: LIST
103706: LIST
103707: PUSH
103708: LD_INT 50
103710: PUSH
103711: EMPTY
103712: LIST
103713: PUSH
103714: EMPTY
103715: LIST
103716: LIST
103717: LIST
103718: LIST
103719: PPUSH
103720: CALL_OW 69
103724: ST_TO_ADDR
// if not tmp then
103725: LD_VAR 0 2
103729: NOT
103730: IFFALSE 103734
// continue ;
103732: GO 103529
// HackLink ( i , tmp ) ;
103734: LD_VAR 0 1
103738: PPUSH
103739: LD_VAR 0 2
103743: PPUSH
103744: CALL 103891 0 2
// end ;
103748: GO 103529
103750: POP
103751: POP
// end ;
103752: PPOPN 2
103754: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
103755: LD_INT 0
103757: PPUSH
103758: PPUSH
103759: PPUSH
// if not hack in hackTanks then
103760: LD_VAR 0 1
103764: PUSH
103765: LD_EXP 166
103769: IN
103770: NOT
103771: IFFALSE 103775
// exit ;
103773: GO 103886
// index := GetElementIndex ( hackTanks , hack ) ;
103775: LD_ADDR_VAR 0 4
103779: PUSH
103780: LD_EXP 166
103784: PPUSH
103785: LD_VAR 0 1
103789: PPUSH
103790: CALL 19776 0 2
103794: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
103795: LD_EXP 167
103799: PUSH
103800: LD_VAR 0 4
103804: ARRAY
103805: IFFALSE 103886
// begin for i in hackTanksCaptured [ index ] do
103807: LD_ADDR_VAR 0 3
103811: PUSH
103812: LD_EXP 167
103816: PUSH
103817: LD_VAR 0 4
103821: ARRAY
103822: PUSH
103823: FOR_IN
103824: IFFALSE 103850
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
103826: LD_VAR 0 3
103830: PUSH
103831: LD_INT 1
103833: ARRAY
103834: PPUSH
103835: LD_VAR 0 3
103839: PUSH
103840: LD_INT 2
103842: ARRAY
103843: PPUSH
103844: CALL_OW 235
103848: GO 103823
103850: POP
103851: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
103852: LD_ADDR_EXP 167
103856: PUSH
103857: LD_EXP 167
103861: PPUSH
103862: LD_VAR 0 4
103866: PPUSH
103867: EMPTY
103868: PPUSH
103869: CALL_OW 1
103873: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
103874: LD_VAR 0 1
103878: PPUSH
103879: LD_INT 0
103881: PPUSH
103882: CALL_OW 505
// end ; end ;
103886: LD_VAR 0 2
103890: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
103891: LD_INT 0
103893: PPUSH
103894: PPUSH
103895: PPUSH
// if not hack in hackTanks or not vehicles then
103896: LD_VAR 0 1
103900: PUSH
103901: LD_EXP 166
103905: IN
103906: NOT
103907: PUSH
103908: LD_VAR 0 2
103912: NOT
103913: OR
103914: IFFALSE 103918
// exit ;
103916: GO 104193
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
103918: LD_ADDR_VAR 0 2
103922: PUSH
103923: LD_VAR 0 1
103927: PPUSH
103928: LD_VAR 0 2
103932: PPUSH
103933: LD_INT 1
103935: PPUSH
103936: LD_INT 1
103938: PPUSH
103939: CALL 20426 0 4
103943: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
103944: LD_ADDR_VAR 0 5
103948: PUSH
103949: LD_EXP 166
103953: PPUSH
103954: LD_VAR 0 1
103958: PPUSH
103959: CALL 19776 0 2
103963: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
103964: LD_EXP 167
103968: PUSH
103969: LD_VAR 0 5
103973: ARRAY
103974: PUSH
103975: LD_EXP 168
103979: LESS
103980: IFFALSE 104169
// begin for i := 1 to vehicles do
103982: LD_ADDR_VAR 0 4
103986: PUSH
103987: DOUBLE
103988: LD_INT 1
103990: DEC
103991: ST_TO_ADDR
103992: LD_VAR 0 2
103996: PUSH
103997: FOR_TO
103998: IFFALSE 104167
// begin if hackTanksCaptured [ index ] = hackLimit then
104000: LD_EXP 167
104004: PUSH
104005: LD_VAR 0 5
104009: ARRAY
104010: PUSH
104011: LD_EXP 168
104015: EQUAL
104016: IFFALSE 104020
// break ;
104018: GO 104167
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
104020: LD_ADDR_EXP 170
104024: PUSH
104025: LD_EXP 170
104029: PPUSH
104030: LD_VAR 0 5
104034: PPUSH
104035: LD_EXP 170
104039: PUSH
104040: LD_VAR 0 5
104044: ARRAY
104045: PUSH
104046: LD_INT 1
104048: PLUS
104049: PPUSH
104050: CALL_OW 1
104054: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
104055: LD_ADDR_EXP 167
104059: PUSH
104060: LD_EXP 167
104064: PPUSH
104065: LD_VAR 0 5
104069: PUSH
104070: LD_EXP 167
104074: PUSH
104075: LD_VAR 0 5
104079: ARRAY
104080: PUSH
104081: LD_INT 1
104083: PLUS
104084: PUSH
104085: EMPTY
104086: LIST
104087: LIST
104088: PPUSH
104089: LD_VAR 0 2
104093: PUSH
104094: LD_VAR 0 4
104098: ARRAY
104099: PUSH
104100: LD_VAR 0 2
104104: PUSH
104105: LD_VAR 0 4
104109: ARRAY
104110: PPUSH
104111: CALL_OW 255
104115: PUSH
104116: EMPTY
104117: LIST
104118: LIST
104119: PPUSH
104120: CALL 19991 0 3
104124: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
104125: LD_VAR 0 2
104129: PUSH
104130: LD_VAR 0 4
104134: ARRAY
104135: PPUSH
104136: LD_VAR 0 1
104140: PPUSH
104141: CALL_OW 255
104145: PPUSH
104146: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
104150: LD_VAR 0 2
104154: PUSH
104155: LD_VAR 0 4
104159: ARRAY
104160: PPUSH
104161: CALL_OW 141
// end ;
104165: GO 103997
104167: POP
104168: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
104169: LD_VAR 0 1
104173: PPUSH
104174: LD_EXP 167
104178: PUSH
104179: LD_VAR 0 5
104183: ARRAY
104184: PUSH
104185: LD_INT 0
104187: PLUS
104188: PPUSH
104189: CALL_OW 505
// end ;
104193: LD_VAR 0 3
104197: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
104198: LD_INT 0
104200: PPUSH
104201: PPUSH
104202: PPUSH
104203: PPUSH
// if not hack in hackTanks then
104204: LD_VAR 0 1
104208: PUSH
104209: LD_EXP 166
104213: IN
104214: NOT
104215: IFFALSE 104219
// exit ;
104217: GO 104459
// index := GetElementIndex ( hackTanks , hack ) ;
104219: LD_ADDR_VAR 0 4
104223: PUSH
104224: LD_EXP 166
104228: PPUSH
104229: LD_VAR 0 1
104233: PPUSH
104234: CALL 19776 0 2
104238: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
104239: LD_ADDR_VAR 0 3
104243: PUSH
104244: DOUBLE
104245: LD_EXP 167
104249: PUSH
104250: LD_VAR 0 4
104254: ARRAY
104255: INC
104256: ST_TO_ADDR
104257: LD_INT 1
104259: PUSH
104260: FOR_DOWNTO
104261: IFFALSE 104433
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
104263: LD_ADDR_VAR 0 5
104267: PUSH
104268: LD_EXP 167
104272: PUSH
104273: LD_VAR 0 4
104277: ARRAY
104278: PUSH
104279: LD_VAR 0 3
104283: ARRAY
104284: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
104285: LD_VAR 0 5
104289: PUSH
104290: LD_INT 1
104292: ARRAY
104293: PPUSH
104294: CALL_OW 302
104298: NOT
104299: PUSH
104300: LD_VAR 0 5
104304: PUSH
104305: LD_INT 1
104307: ARRAY
104308: PPUSH
104309: CALL_OW 255
104313: PUSH
104314: LD_VAR 0 1
104318: PPUSH
104319: CALL_OW 255
104323: NONEQUAL
104324: OR
104325: IFFALSE 104431
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
104327: LD_VAR 0 5
104331: PUSH
104332: LD_INT 1
104334: ARRAY
104335: PPUSH
104336: CALL_OW 305
104340: PUSH
104341: LD_VAR 0 5
104345: PUSH
104346: LD_INT 1
104348: ARRAY
104349: PPUSH
104350: CALL_OW 255
104354: PUSH
104355: LD_VAR 0 1
104359: PPUSH
104360: CALL_OW 255
104364: EQUAL
104365: AND
104366: IFFALSE 104390
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
104368: LD_VAR 0 5
104372: PUSH
104373: LD_INT 1
104375: ARRAY
104376: PPUSH
104377: LD_VAR 0 5
104381: PUSH
104382: LD_INT 2
104384: ARRAY
104385: PPUSH
104386: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
104390: LD_ADDR_EXP 167
104394: PUSH
104395: LD_EXP 167
104399: PPUSH
104400: LD_VAR 0 4
104404: PPUSH
104405: LD_EXP 167
104409: PUSH
104410: LD_VAR 0 4
104414: ARRAY
104415: PPUSH
104416: LD_VAR 0 3
104420: PPUSH
104421: CALL_OW 3
104425: PPUSH
104426: CALL_OW 1
104430: ST_TO_ADDR
// end ; end ;
104431: GO 104260
104433: POP
104434: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
104435: LD_VAR 0 1
104439: PPUSH
104440: LD_EXP 167
104444: PUSH
104445: LD_VAR 0 4
104449: ARRAY
104450: PUSH
104451: LD_INT 0
104453: PLUS
104454: PPUSH
104455: CALL_OW 505
// end ;
104459: LD_VAR 0 2
104463: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
104464: LD_INT 0
104466: PPUSH
104467: PPUSH
104468: PPUSH
104469: PPUSH
// if not hack in hackTanks then
104470: LD_VAR 0 1
104474: PUSH
104475: LD_EXP 166
104479: IN
104480: NOT
104481: IFFALSE 104485
// exit ;
104483: GO 104570
// index := GetElementIndex ( hackTanks , hack ) ;
104485: LD_ADDR_VAR 0 5
104489: PUSH
104490: LD_EXP 166
104494: PPUSH
104495: LD_VAR 0 1
104499: PPUSH
104500: CALL 19776 0 2
104504: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
104505: LD_ADDR_VAR 0 4
104509: PUSH
104510: DOUBLE
104511: LD_INT 1
104513: DEC
104514: ST_TO_ADDR
104515: LD_EXP 167
104519: PUSH
104520: LD_VAR 0 5
104524: ARRAY
104525: PUSH
104526: FOR_TO
104527: IFFALSE 104568
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
104529: LD_EXP 167
104533: PUSH
104534: LD_VAR 0 5
104538: ARRAY
104539: PUSH
104540: LD_VAR 0 4
104544: ARRAY
104545: PUSH
104546: LD_INT 1
104548: ARRAY
104549: PUSH
104550: LD_VAR 0 2
104554: EQUAL
104555: IFFALSE 104566
// KillUnit ( vehicle ) ;
104557: LD_VAR 0 2
104561: PPUSH
104562: CALL_OW 66
104566: GO 104526
104568: POP
104569: POP
// end ;
104570: LD_VAR 0 3
104574: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
104575: LD_EXP 171
104579: NOT
104580: IFFALSE 104615
104582: GO 104584
104584: DISABLE
// begin initMiner := true ;
104585: LD_ADDR_EXP 171
104589: PUSH
104590: LD_INT 1
104592: ST_TO_ADDR
// minersList := [ ] ;
104593: LD_ADDR_EXP 172
104597: PUSH
104598: EMPTY
104599: ST_TO_ADDR
// minerMinesList := [ ] ;
104600: LD_ADDR_EXP 173
104604: PUSH
104605: EMPTY
104606: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
104607: LD_ADDR_EXP 174
104611: PUSH
104612: LD_INT 5
104614: ST_TO_ADDR
// end ;
104615: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
104616: LD_EXP 171
104620: PUSH
104621: LD_INT 34
104623: PUSH
104624: LD_INT 81
104626: PUSH
104627: EMPTY
104628: LIST
104629: LIST
104630: PPUSH
104631: CALL_OW 69
104635: AND
104636: IFFALSE 105097
104638: GO 104640
104640: DISABLE
104641: LD_INT 0
104643: PPUSH
104644: PPUSH
104645: PPUSH
104646: PPUSH
// begin enable ;
104647: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
104648: LD_ADDR_VAR 0 1
104652: PUSH
104653: LD_INT 34
104655: PUSH
104656: LD_INT 81
104658: PUSH
104659: EMPTY
104660: LIST
104661: LIST
104662: PPUSH
104663: CALL_OW 69
104667: PUSH
104668: FOR_IN
104669: IFFALSE 104741
// begin if not i in minersList then
104671: LD_VAR 0 1
104675: PUSH
104676: LD_EXP 172
104680: IN
104681: NOT
104682: IFFALSE 104739
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
104684: LD_ADDR_EXP 172
104688: PUSH
104689: LD_EXP 172
104693: PPUSH
104694: LD_EXP 172
104698: PUSH
104699: LD_INT 1
104701: PLUS
104702: PPUSH
104703: LD_VAR 0 1
104707: PPUSH
104708: CALL_OW 1
104712: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
104713: LD_ADDR_EXP 173
104717: PUSH
104718: LD_EXP 173
104722: PPUSH
104723: LD_EXP 173
104727: PUSH
104728: LD_INT 1
104730: PLUS
104731: PPUSH
104732: EMPTY
104733: PPUSH
104734: CALL_OW 1
104738: ST_TO_ADDR
// end end ;
104739: GO 104668
104741: POP
104742: POP
// for i := minerMinesList downto 1 do
104743: LD_ADDR_VAR 0 1
104747: PUSH
104748: DOUBLE
104749: LD_EXP 173
104753: INC
104754: ST_TO_ADDR
104755: LD_INT 1
104757: PUSH
104758: FOR_DOWNTO
104759: IFFALSE 105095
// begin if IsLive ( minersList [ i ] ) then
104761: LD_EXP 172
104765: PUSH
104766: LD_VAR 0 1
104770: ARRAY
104771: PPUSH
104772: CALL_OW 300
104776: IFFALSE 104804
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
104778: LD_EXP 172
104782: PUSH
104783: LD_VAR 0 1
104787: ARRAY
104788: PPUSH
104789: LD_EXP 173
104793: PUSH
104794: LD_VAR 0 1
104798: ARRAY
104799: PPUSH
104800: CALL_OW 505
// if not minerMinesList [ i ] then
104804: LD_EXP 173
104808: PUSH
104809: LD_VAR 0 1
104813: ARRAY
104814: NOT
104815: IFFALSE 104819
// continue ;
104817: GO 104758
// for j := minerMinesList [ i ] downto 1 do
104819: LD_ADDR_VAR 0 2
104823: PUSH
104824: DOUBLE
104825: LD_EXP 173
104829: PUSH
104830: LD_VAR 0 1
104834: ARRAY
104835: INC
104836: ST_TO_ADDR
104837: LD_INT 1
104839: PUSH
104840: FOR_DOWNTO
104841: IFFALSE 105091
// begin side := GetSide ( minersList [ i ] ) ;
104843: LD_ADDR_VAR 0 3
104847: PUSH
104848: LD_EXP 172
104852: PUSH
104853: LD_VAR 0 1
104857: ARRAY
104858: PPUSH
104859: CALL_OW 255
104863: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
104864: LD_ADDR_VAR 0 4
104868: PUSH
104869: LD_EXP 173
104873: PUSH
104874: LD_VAR 0 1
104878: ARRAY
104879: PUSH
104880: LD_VAR 0 2
104884: ARRAY
104885: PUSH
104886: LD_INT 1
104888: ARRAY
104889: PPUSH
104890: LD_EXP 173
104894: PUSH
104895: LD_VAR 0 1
104899: ARRAY
104900: PUSH
104901: LD_VAR 0 2
104905: ARRAY
104906: PUSH
104907: LD_INT 2
104909: ARRAY
104910: PPUSH
104911: CALL_OW 428
104915: ST_TO_ADDR
// if not tmp then
104916: LD_VAR 0 4
104920: NOT
104921: IFFALSE 104925
// continue ;
104923: GO 104840
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
104925: LD_VAR 0 4
104929: PUSH
104930: LD_INT 81
104932: PUSH
104933: LD_VAR 0 3
104937: PUSH
104938: EMPTY
104939: LIST
104940: LIST
104941: PPUSH
104942: CALL_OW 69
104946: IN
104947: PUSH
104948: LD_EXP 173
104952: PUSH
104953: LD_VAR 0 1
104957: ARRAY
104958: PUSH
104959: LD_VAR 0 2
104963: ARRAY
104964: PUSH
104965: LD_INT 1
104967: ARRAY
104968: PPUSH
104969: LD_EXP 173
104973: PUSH
104974: LD_VAR 0 1
104978: ARRAY
104979: PUSH
104980: LD_VAR 0 2
104984: ARRAY
104985: PUSH
104986: LD_INT 2
104988: ARRAY
104989: PPUSH
104990: CALL_OW 458
104994: AND
104995: IFFALSE 105089
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
104997: LD_EXP 173
105001: PUSH
105002: LD_VAR 0 1
105006: ARRAY
105007: PUSH
105008: LD_VAR 0 2
105012: ARRAY
105013: PUSH
105014: LD_INT 1
105016: ARRAY
105017: PPUSH
105018: LD_EXP 173
105022: PUSH
105023: LD_VAR 0 1
105027: ARRAY
105028: PUSH
105029: LD_VAR 0 2
105033: ARRAY
105034: PUSH
105035: LD_INT 2
105037: ARRAY
105038: PPUSH
105039: LD_VAR 0 3
105043: PPUSH
105044: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
105048: LD_ADDR_EXP 173
105052: PUSH
105053: LD_EXP 173
105057: PPUSH
105058: LD_VAR 0 1
105062: PPUSH
105063: LD_EXP 173
105067: PUSH
105068: LD_VAR 0 1
105072: ARRAY
105073: PPUSH
105074: LD_VAR 0 2
105078: PPUSH
105079: CALL_OW 3
105083: PPUSH
105084: CALL_OW 1
105088: ST_TO_ADDR
// end ; end ;
105089: GO 104840
105091: POP
105092: POP
// end ;
105093: GO 104758
105095: POP
105096: POP
// end ;
105097: PPOPN 4
105099: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
105100: LD_INT 0
105102: PPUSH
105103: PPUSH
// result := false ;
105104: LD_ADDR_VAR 0 4
105108: PUSH
105109: LD_INT 0
105111: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
105112: LD_VAR 0 1
105116: PPUSH
105117: CALL_OW 264
105121: PUSH
105122: LD_INT 81
105124: EQUAL
105125: NOT
105126: IFFALSE 105130
// exit ;
105128: GO 105370
// index := GetElementIndex ( minersList , unit ) ;
105130: LD_ADDR_VAR 0 5
105134: PUSH
105135: LD_EXP 172
105139: PPUSH
105140: LD_VAR 0 1
105144: PPUSH
105145: CALL 19776 0 2
105149: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
105150: LD_EXP 173
105154: PUSH
105155: LD_VAR 0 5
105159: ARRAY
105160: PUSH
105161: LD_EXP 174
105165: GREATEREQUAL
105166: IFFALSE 105170
// exit ;
105168: GO 105370
// ComMoveXY ( unit , x , y ) ;
105170: LD_VAR 0 1
105174: PPUSH
105175: LD_VAR 0 2
105179: PPUSH
105180: LD_VAR 0 3
105184: PPUSH
105185: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105189: LD_INT 35
105191: PPUSH
105192: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
105196: LD_VAR 0 1
105200: PPUSH
105201: LD_VAR 0 2
105205: PPUSH
105206: LD_VAR 0 3
105210: PPUSH
105211: CALL 51039 0 3
105215: NOT
105216: PUSH
105217: LD_VAR 0 1
105221: PPUSH
105222: CALL_OW 314
105226: AND
105227: IFFALSE 105231
// exit ;
105229: GO 105370
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
105231: LD_VAR 0 2
105235: PPUSH
105236: LD_VAR 0 3
105240: PPUSH
105241: CALL_OW 428
105245: PUSH
105246: LD_VAR 0 1
105250: EQUAL
105251: PUSH
105252: LD_VAR 0 1
105256: PPUSH
105257: CALL_OW 314
105261: NOT
105262: AND
105263: IFFALSE 105189
// PlaySoundXY ( x , y , PlantMine ) ;
105265: LD_VAR 0 2
105269: PPUSH
105270: LD_VAR 0 3
105274: PPUSH
105275: LD_STRING PlantMine
105277: PPUSH
105278: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
105282: LD_VAR 0 2
105286: PPUSH
105287: LD_VAR 0 3
105291: PPUSH
105292: LD_VAR 0 1
105296: PPUSH
105297: CALL_OW 255
105301: PPUSH
105302: LD_INT 0
105304: PPUSH
105305: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
105309: LD_ADDR_EXP 173
105313: PUSH
105314: LD_EXP 173
105318: PPUSH
105319: LD_VAR 0 5
105323: PUSH
105324: LD_EXP 173
105328: PUSH
105329: LD_VAR 0 5
105333: ARRAY
105334: PUSH
105335: LD_INT 1
105337: PLUS
105338: PUSH
105339: EMPTY
105340: LIST
105341: LIST
105342: PPUSH
105343: LD_VAR 0 2
105347: PUSH
105348: LD_VAR 0 3
105352: PUSH
105353: EMPTY
105354: LIST
105355: LIST
105356: PPUSH
105357: CALL 19991 0 3
105361: ST_TO_ADDR
// result := true ;
105362: LD_ADDR_VAR 0 4
105366: PUSH
105367: LD_INT 1
105369: ST_TO_ADDR
// end ;
105370: LD_VAR 0 4
105374: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
105375: LD_INT 0
105377: PPUSH
105378: PPUSH
105379: PPUSH
// if not unit in minersList then
105380: LD_VAR 0 1
105384: PUSH
105385: LD_EXP 172
105389: IN
105390: NOT
105391: IFFALSE 105395
// exit ;
105393: GO 105787
// index := GetElementIndex ( minersList , unit ) ;
105395: LD_ADDR_VAR 0 6
105399: PUSH
105400: LD_EXP 172
105404: PPUSH
105405: LD_VAR 0 1
105409: PPUSH
105410: CALL 19776 0 2
105414: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
105415: LD_ADDR_VAR 0 5
105419: PUSH
105420: DOUBLE
105421: LD_EXP 173
105425: PUSH
105426: LD_VAR 0 6
105430: ARRAY
105431: INC
105432: ST_TO_ADDR
105433: LD_INT 1
105435: PUSH
105436: FOR_DOWNTO
105437: IFFALSE 105598
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
105439: LD_EXP 173
105443: PUSH
105444: LD_VAR 0 6
105448: ARRAY
105449: PUSH
105450: LD_VAR 0 5
105454: ARRAY
105455: PUSH
105456: LD_INT 1
105458: ARRAY
105459: PUSH
105460: LD_VAR 0 2
105464: EQUAL
105465: PUSH
105466: LD_EXP 173
105470: PUSH
105471: LD_VAR 0 6
105475: ARRAY
105476: PUSH
105477: LD_VAR 0 5
105481: ARRAY
105482: PUSH
105483: LD_INT 2
105485: ARRAY
105486: PUSH
105487: LD_VAR 0 3
105491: EQUAL
105492: AND
105493: IFFALSE 105596
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
105495: LD_EXP 173
105499: PUSH
105500: LD_VAR 0 6
105504: ARRAY
105505: PUSH
105506: LD_VAR 0 5
105510: ARRAY
105511: PUSH
105512: LD_INT 1
105514: ARRAY
105515: PPUSH
105516: LD_EXP 173
105520: PUSH
105521: LD_VAR 0 6
105525: ARRAY
105526: PUSH
105527: LD_VAR 0 5
105531: ARRAY
105532: PUSH
105533: LD_INT 2
105535: ARRAY
105536: PPUSH
105537: LD_VAR 0 1
105541: PPUSH
105542: CALL_OW 255
105546: PPUSH
105547: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
105551: LD_ADDR_EXP 173
105555: PUSH
105556: LD_EXP 173
105560: PPUSH
105561: LD_VAR 0 6
105565: PPUSH
105566: LD_EXP 173
105570: PUSH
105571: LD_VAR 0 6
105575: ARRAY
105576: PPUSH
105577: LD_VAR 0 5
105581: PPUSH
105582: CALL_OW 3
105586: PPUSH
105587: CALL_OW 1
105591: ST_TO_ADDR
// exit ;
105592: POP
105593: POP
105594: GO 105787
// end ; end ;
105596: GO 105436
105598: POP
105599: POP
// for i := minerMinesList [ index ] downto 1 do
105600: LD_ADDR_VAR 0 5
105604: PUSH
105605: DOUBLE
105606: LD_EXP 173
105610: PUSH
105611: LD_VAR 0 6
105615: ARRAY
105616: INC
105617: ST_TO_ADDR
105618: LD_INT 1
105620: PUSH
105621: FOR_DOWNTO
105622: IFFALSE 105785
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
105624: LD_EXP 173
105628: PUSH
105629: LD_VAR 0 6
105633: ARRAY
105634: PUSH
105635: LD_VAR 0 5
105639: ARRAY
105640: PUSH
105641: LD_INT 1
105643: ARRAY
105644: PPUSH
105645: LD_EXP 173
105649: PUSH
105650: LD_VAR 0 6
105654: ARRAY
105655: PUSH
105656: LD_VAR 0 5
105660: ARRAY
105661: PUSH
105662: LD_INT 2
105664: ARRAY
105665: PPUSH
105666: LD_VAR 0 2
105670: PPUSH
105671: LD_VAR 0 3
105675: PPUSH
105676: CALL_OW 298
105680: PUSH
105681: LD_INT 6
105683: LESS
105684: IFFALSE 105783
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
105686: LD_EXP 173
105690: PUSH
105691: LD_VAR 0 6
105695: ARRAY
105696: PUSH
105697: LD_VAR 0 5
105701: ARRAY
105702: PUSH
105703: LD_INT 1
105705: ARRAY
105706: PPUSH
105707: LD_EXP 173
105711: PUSH
105712: LD_VAR 0 6
105716: ARRAY
105717: PUSH
105718: LD_VAR 0 5
105722: ARRAY
105723: PUSH
105724: LD_INT 2
105726: ARRAY
105727: PPUSH
105728: LD_VAR 0 1
105732: PPUSH
105733: CALL_OW 255
105737: PPUSH
105738: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
105742: LD_ADDR_EXP 173
105746: PUSH
105747: LD_EXP 173
105751: PPUSH
105752: LD_VAR 0 6
105756: PPUSH
105757: LD_EXP 173
105761: PUSH
105762: LD_VAR 0 6
105766: ARRAY
105767: PPUSH
105768: LD_VAR 0 5
105772: PPUSH
105773: CALL_OW 3
105777: PPUSH
105778: CALL_OW 1
105782: ST_TO_ADDR
// end ; end ;
105783: GO 105621
105785: POP
105786: POP
// end ;
105787: LD_VAR 0 4
105791: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
105792: LD_INT 0
105794: PPUSH
105795: PPUSH
105796: PPUSH
105797: PPUSH
105798: PPUSH
105799: PPUSH
105800: PPUSH
105801: PPUSH
105802: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
105803: LD_VAR 0 1
105807: PPUSH
105808: CALL_OW 264
105812: PUSH
105813: LD_INT 81
105815: EQUAL
105816: NOT
105817: PUSH
105818: LD_VAR 0 1
105822: PUSH
105823: LD_EXP 172
105827: IN
105828: NOT
105829: OR
105830: IFFALSE 105834
// exit ;
105832: GO 106156
// index := GetElementIndex ( minersList , unit ) ;
105834: LD_ADDR_VAR 0 6
105838: PUSH
105839: LD_EXP 172
105843: PPUSH
105844: LD_VAR 0 1
105848: PPUSH
105849: CALL 19776 0 2
105853: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
105854: LD_ADDR_VAR 0 8
105858: PUSH
105859: LD_EXP 174
105863: PUSH
105864: LD_EXP 173
105868: PUSH
105869: LD_VAR 0 6
105873: ARRAY
105874: MINUS
105875: ST_TO_ADDR
// if not minesFreeAmount then
105876: LD_VAR 0 8
105880: NOT
105881: IFFALSE 105885
// exit ;
105883: GO 106156
// tmp := [ ] ;
105885: LD_ADDR_VAR 0 7
105889: PUSH
105890: EMPTY
105891: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
105892: LD_ADDR_VAR 0 5
105896: PUSH
105897: DOUBLE
105898: LD_INT 1
105900: DEC
105901: ST_TO_ADDR
105902: LD_VAR 0 8
105906: PUSH
105907: FOR_TO
105908: IFFALSE 106103
// begin _d := rand ( 0 , 5 ) ;
105910: LD_ADDR_VAR 0 11
105914: PUSH
105915: LD_INT 0
105917: PPUSH
105918: LD_INT 5
105920: PPUSH
105921: CALL_OW 12
105925: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
105926: LD_ADDR_VAR 0 12
105930: PUSH
105931: LD_INT 2
105933: PPUSH
105934: LD_INT 6
105936: PPUSH
105937: CALL_OW 12
105941: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
105942: LD_ADDR_VAR 0 9
105946: PUSH
105947: LD_VAR 0 2
105951: PPUSH
105952: LD_VAR 0 11
105956: PPUSH
105957: LD_VAR 0 12
105961: PPUSH
105962: CALL_OW 272
105966: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
105967: LD_ADDR_VAR 0 10
105971: PUSH
105972: LD_VAR 0 3
105976: PPUSH
105977: LD_VAR 0 11
105981: PPUSH
105982: LD_VAR 0 12
105986: PPUSH
105987: CALL_OW 273
105991: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
105992: LD_VAR 0 9
105996: PPUSH
105997: LD_VAR 0 10
106001: PPUSH
106002: CALL_OW 488
106006: PUSH
106007: LD_VAR 0 9
106011: PUSH
106012: LD_VAR 0 10
106016: PUSH
106017: EMPTY
106018: LIST
106019: LIST
106020: PUSH
106021: LD_VAR 0 7
106025: IN
106026: NOT
106027: AND
106028: PUSH
106029: LD_VAR 0 9
106033: PPUSH
106034: LD_VAR 0 10
106038: PPUSH
106039: CALL_OW 458
106043: NOT
106044: AND
106045: IFFALSE 106087
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
106047: LD_ADDR_VAR 0 7
106051: PUSH
106052: LD_VAR 0 7
106056: PPUSH
106057: LD_VAR 0 7
106061: PUSH
106062: LD_INT 1
106064: PLUS
106065: PPUSH
106066: LD_VAR 0 9
106070: PUSH
106071: LD_VAR 0 10
106075: PUSH
106076: EMPTY
106077: LIST
106078: LIST
106079: PPUSH
106080: CALL_OW 1
106084: ST_TO_ADDR
106085: GO 106101
// i := i - 1 ;
106087: LD_ADDR_VAR 0 5
106091: PUSH
106092: LD_VAR 0 5
106096: PUSH
106097: LD_INT 1
106099: MINUS
106100: ST_TO_ADDR
// end ;
106101: GO 105907
106103: POP
106104: POP
// for i in tmp do
106105: LD_ADDR_VAR 0 5
106109: PUSH
106110: LD_VAR 0 7
106114: PUSH
106115: FOR_IN
106116: IFFALSE 106154
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
106118: LD_VAR 0 1
106122: PPUSH
106123: LD_VAR 0 5
106127: PUSH
106128: LD_INT 1
106130: ARRAY
106131: PPUSH
106132: LD_VAR 0 5
106136: PUSH
106137: LD_INT 2
106139: ARRAY
106140: PPUSH
106141: CALL 105100 0 3
106145: NOT
106146: IFFALSE 106152
// exit ;
106148: POP
106149: POP
106150: GO 106156
106152: GO 106115
106154: POP
106155: POP
// end ;
106156: LD_VAR 0 4
106160: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
106161: LD_INT 0
106163: PPUSH
106164: PPUSH
106165: PPUSH
106166: PPUSH
106167: PPUSH
106168: PPUSH
106169: PPUSH
// if not GetClass ( unit ) = class_sniper then
106170: LD_VAR 0 1
106174: PPUSH
106175: CALL_OW 257
106179: PUSH
106180: LD_INT 5
106182: EQUAL
106183: NOT
106184: IFFALSE 106188
// exit ;
106186: GO 106576
// dist := 8 ;
106188: LD_ADDR_VAR 0 5
106192: PUSH
106193: LD_INT 8
106195: ST_TO_ADDR
// viewRange := 12 ;
106196: LD_ADDR_VAR 0 7
106200: PUSH
106201: LD_INT 12
106203: ST_TO_ADDR
// side := GetSide ( unit ) ;
106204: LD_ADDR_VAR 0 6
106208: PUSH
106209: LD_VAR 0 1
106213: PPUSH
106214: CALL_OW 255
106218: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
106219: LD_INT 61
106221: PPUSH
106222: LD_VAR 0 6
106226: PPUSH
106227: CALL_OW 321
106231: PUSH
106232: LD_INT 2
106234: EQUAL
106235: IFFALSE 106245
// viewRange := 16 ;
106237: LD_ADDR_VAR 0 7
106241: PUSH
106242: LD_INT 16
106244: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
106245: LD_VAR 0 1
106249: PPUSH
106250: LD_VAR 0 2
106254: PPUSH
106255: LD_VAR 0 3
106259: PPUSH
106260: CALL_OW 297
106264: PUSH
106265: LD_VAR 0 5
106269: GREATER
106270: IFFALSE 106349
// begin ComMoveXY ( unit , x , y ) ;
106272: LD_VAR 0 1
106276: PPUSH
106277: LD_VAR 0 2
106281: PPUSH
106282: LD_VAR 0 3
106286: PPUSH
106287: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
106291: LD_INT 35
106293: PPUSH
106294: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
106298: LD_VAR 0 1
106302: PPUSH
106303: LD_VAR 0 2
106307: PPUSH
106308: LD_VAR 0 3
106312: PPUSH
106313: CALL 51039 0 3
106317: NOT
106318: IFFALSE 106322
// exit ;
106320: GO 106576
// until GetDistUnitXY ( unit , x , y ) < dist ;
106322: LD_VAR 0 1
106326: PPUSH
106327: LD_VAR 0 2
106331: PPUSH
106332: LD_VAR 0 3
106336: PPUSH
106337: CALL_OW 297
106341: PUSH
106342: LD_VAR 0 5
106346: LESS
106347: IFFALSE 106291
// end ; ComTurnXY ( unit , x , y ) ;
106349: LD_VAR 0 1
106353: PPUSH
106354: LD_VAR 0 2
106358: PPUSH
106359: LD_VAR 0 3
106363: PPUSH
106364: CALL_OW 118
// wait ( 5 ) ;
106368: LD_INT 5
106370: PPUSH
106371: CALL_OW 67
// _d := GetDir ( unit ) ;
106375: LD_ADDR_VAR 0 10
106379: PUSH
106380: LD_VAR 0 1
106384: PPUSH
106385: CALL_OW 254
106389: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
106390: LD_ADDR_VAR 0 8
106394: PUSH
106395: LD_VAR 0 1
106399: PPUSH
106400: CALL_OW 250
106404: PPUSH
106405: LD_VAR 0 10
106409: PPUSH
106410: LD_VAR 0 5
106414: PPUSH
106415: CALL_OW 272
106419: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
106420: LD_ADDR_VAR 0 9
106424: PUSH
106425: LD_VAR 0 1
106429: PPUSH
106430: CALL_OW 251
106434: PPUSH
106435: LD_VAR 0 10
106439: PPUSH
106440: LD_VAR 0 5
106444: PPUSH
106445: CALL_OW 273
106449: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106450: LD_VAR 0 8
106454: PPUSH
106455: LD_VAR 0 9
106459: PPUSH
106460: CALL_OW 488
106464: NOT
106465: IFFALSE 106469
// exit ;
106467: GO 106576
// ComAnimCustom ( unit , 1 ) ;
106469: LD_VAR 0 1
106473: PPUSH
106474: LD_INT 1
106476: PPUSH
106477: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
106481: LD_VAR 0 8
106485: PPUSH
106486: LD_VAR 0 9
106490: PPUSH
106491: LD_VAR 0 6
106495: PPUSH
106496: LD_VAR 0 7
106500: PPUSH
106501: CALL_OW 330
// repeat wait ( 1 ) ;
106505: LD_INT 1
106507: PPUSH
106508: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
106512: LD_VAR 0 1
106516: PPUSH
106517: CALL_OW 316
106521: PUSH
106522: LD_VAR 0 1
106526: PPUSH
106527: CALL_OW 314
106531: OR
106532: PUSH
106533: LD_VAR 0 1
106537: PPUSH
106538: CALL_OW 302
106542: NOT
106543: OR
106544: PUSH
106545: LD_VAR 0 1
106549: PPUSH
106550: CALL_OW 301
106554: OR
106555: IFFALSE 106505
// RemoveSeeing ( _x , _y , side ) ;
106557: LD_VAR 0 8
106561: PPUSH
106562: LD_VAR 0 9
106566: PPUSH
106567: LD_VAR 0 6
106571: PPUSH
106572: CALL_OW 331
// end ; end_of_file
106576: LD_VAR 0 4
106580: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
106581: LD_INT 0
106583: PPUSH
106584: PPUSH
106585: PPUSH
106586: PPUSH
106587: PPUSH
106588: PPUSH
106589: PPUSH
106590: PPUSH
106591: PPUSH
106592: PPUSH
106593: PPUSH
106594: PPUSH
106595: PPUSH
106596: PPUSH
106597: PPUSH
106598: PPUSH
106599: PPUSH
106600: PPUSH
106601: PPUSH
106602: PPUSH
106603: PPUSH
106604: PPUSH
106605: PPUSH
106606: PPUSH
106607: PPUSH
106608: PPUSH
106609: PPUSH
106610: PPUSH
106611: PPUSH
106612: PPUSH
106613: PPUSH
106614: PPUSH
106615: PPUSH
106616: PPUSH
// if not list then
106617: LD_VAR 0 1
106621: NOT
106622: IFFALSE 106626
// exit ;
106624: GO 111285
// base := list [ 1 ] ;
106626: LD_ADDR_VAR 0 3
106630: PUSH
106631: LD_VAR 0 1
106635: PUSH
106636: LD_INT 1
106638: ARRAY
106639: ST_TO_ADDR
// group := list [ 2 ] ;
106640: LD_ADDR_VAR 0 4
106644: PUSH
106645: LD_VAR 0 1
106649: PUSH
106650: LD_INT 2
106652: ARRAY
106653: ST_TO_ADDR
// path := list [ 3 ] ;
106654: LD_ADDR_VAR 0 5
106658: PUSH
106659: LD_VAR 0 1
106663: PUSH
106664: LD_INT 3
106666: ARRAY
106667: ST_TO_ADDR
// flags := list [ 4 ] ;
106668: LD_ADDR_VAR 0 6
106672: PUSH
106673: LD_VAR 0 1
106677: PUSH
106678: LD_INT 4
106680: ARRAY
106681: ST_TO_ADDR
// mined := [ ] ;
106682: LD_ADDR_VAR 0 27
106686: PUSH
106687: EMPTY
106688: ST_TO_ADDR
// bombed := [ ] ;
106689: LD_ADDR_VAR 0 28
106693: PUSH
106694: EMPTY
106695: ST_TO_ADDR
// healers := [ ] ;
106696: LD_ADDR_VAR 0 31
106700: PUSH
106701: EMPTY
106702: ST_TO_ADDR
// to_heal := [ ] ;
106703: LD_ADDR_VAR 0 30
106707: PUSH
106708: EMPTY
106709: ST_TO_ADDR
// repairs := [ ] ;
106710: LD_ADDR_VAR 0 33
106714: PUSH
106715: EMPTY
106716: ST_TO_ADDR
// to_repair := [ ] ;
106717: LD_ADDR_VAR 0 32
106721: PUSH
106722: EMPTY
106723: ST_TO_ADDR
// if not group or not path then
106724: LD_VAR 0 4
106728: NOT
106729: PUSH
106730: LD_VAR 0 5
106734: NOT
106735: OR
106736: IFFALSE 106740
// exit ;
106738: GO 111285
// side := GetSide ( group [ 1 ] ) ;
106740: LD_ADDR_VAR 0 35
106744: PUSH
106745: LD_VAR 0 4
106749: PUSH
106750: LD_INT 1
106752: ARRAY
106753: PPUSH
106754: CALL_OW 255
106758: ST_TO_ADDR
// if flags then
106759: LD_VAR 0 6
106763: IFFALSE 106907
// begin f_ignore_area := flags [ 1 ] ;
106765: LD_ADDR_VAR 0 17
106769: PUSH
106770: LD_VAR 0 6
106774: PUSH
106775: LD_INT 1
106777: ARRAY
106778: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
106779: LD_ADDR_VAR 0 18
106783: PUSH
106784: LD_VAR 0 6
106788: PUSH
106789: LD_INT 2
106791: ARRAY
106792: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
106793: LD_ADDR_VAR 0 19
106797: PUSH
106798: LD_VAR 0 6
106802: PUSH
106803: LD_INT 3
106805: ARRAY
106806: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
106807: LD_ADDR_VAR 0 20
106811: PUSH
106812: LD_VAR 0 6
106816: PUSH
106817: LD_INT 4
106819: ARRAY
106820: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
106821: LD_ADDR_VAR 0 21
106825: PUSH
106826: LD_VAR 0 6
106830: PUSH
106831: LD_INT 5
106833: ARRAY
106834: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
106835: LD_ADDR_VAR 0 22
106839: PUSH
106840: LD_VAR 0 6
106844: PUSH
106845: LD_INT 6
106847: ARRAY
106848: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
106849: LD_ADDR_VAR 0 23
106853: PUSH
106854: LD_VAR 0 6
106858: PUSH
106859: LD_INT 7
106861: ARRAY
106862: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
106863: LD_ADDR_VAR 0 24
106867: PUSH
106868: LD_VAR 0 6
106872: PUSH
106873: LD_INT 8
106875: ARRAY
106876: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
106877: LD_ADDR_VAR 0 25
106881: PUSH
106882: LD_VAR 0 6
106886: PUSH
106887: LD_INT 9
106889: ARRAY
106890: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
106891: LD_ADDR_VAR 0 26
106895: PUSH
106896: LD_VAR 0 6
106900: PUSH
106901: LD_INT 10
106903: ARRAY
106904: ST_TO_ADDR
// end else
106905: GO 106987
// begin f_ignore_area := false ;
106907: LD_ADDR_VAR 0 17
106911: PUSH
106912: LD_INT 0
106914: ST_TO_ADDR
// f_capture := false ;
106915: LD_ADDR_VAR 0 18
106919: PUSH
106920: LD_INT 0
106922: ST_TO_ADDR
// f_ignore_civ := false ;
106923: LD_ADDR_VAR 0 19
106927: PUSH
106928: LD_INT 0
106930: ST_TO_ADDR
// f_murder := false ;
106931: LD_ADDR_VAR 0 20
106935: PUSH
106936: LD_INT 0
106938: ST_TO_ADDR
// f_mines := false ;
106939: LD_ADDR_VAR 0 21
106943: PUSH
106944: LD_INT 0
106946: ST_TO_ADDR
// f_repair := false ;
106947: LD_ADDR_VAR 0 22
106951: PUSH
106952: LD_INT 0
106954: ST_TO_ADDR
// f_heal := false ;
106955: LD_ADDR_VAR 0 23
106959: PUSH
106960: LD_INT 0
106962: ST_TO_ADDR
// f_spacetime := false ;
106963: LD_ADDR_VAR 0 24
106967: PUSH
106968: LD_INT 0
106970: ST_TO_ADDR
// f_attack_depot := false ;
106971: LD_ADDR_VAR 0 25
106975: PUSH
106976: LD_INT 0
106978: ST_TO_ADDR
// f_crawl := false ;
106979: LD_ADDR_VAR 0 26
106983: PUSH
106984: LD_INT 0
106986: ST_TO_ADDR
// end ; if f_heal then
106987: LD_VAR 0 23
106991: IFFALSE 107018
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
106993: LD_ADDR_VAR 0 31
106997: PUSH
106998: LD_VAR 0 4
107002: PPUSH
107003: LD_INT 25
107005: PUSH
107006: LD_INT 4
107008: PUSH
107009: EMPTY
107010: LIST
107011: LIST
107012: PPUSH
107013: CALL_OW 72
107017: ST_TO_ADDR
// if f_repair then
107018: LD_VAR 0 22
107022: IFFALSE 107049
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
107024: LD_ADDR_VAR 0 33
107028: PUSH
107029: LD_VAR 0 4
107033: PPUSH
107034: LD_INT 25
107036: PUSH
107037: LD_INT 3
107039: PUSH
107040: EMPTY
107041: LIST
107042: LIST
107043: PPUSH
107044: CALL_OW 72
107048: ST_TO_ADDR
// units_path := [ ] ;
107049: LD_ADDR_VAR 0 16
107053: PUSH
107054: EMPTY
107055: ST_TO_ADDR
// for i = 1 to group do
107056: LD_ADDR_VAR 0 7
107060: PUSH
107061: DOUBLE
107062: LD_INT 1
107064: DEC
107065: ST_TO_ADDR
107066: LD_VAR 0 4
107070: PUSH
107071: FOR_TO
107072: IFFALSE 107101
// units_path := Replace ( units_path , i , path ) ;
107074: LD_ADDR_VAR 0 16
107078: PUSH
107079: LD_VAR 0 16
107083: PPUSH
107084: LD_VAR 0 7
107088: PPUSH
107089: LD_VAR 0 5
107093: PPUSH
107094: CALL_OW 1
107098: ST_TO_ADDR
107099: GO 107071
107101: POP
107102: POP
// repeat for i = group downto 1 do
107103: LD_ADDR_VAR 0 7
107107: PUSH
107108: DOUBLE
107109: LD_VAR 0 4
107113: INC
107114: ST_TO_ADDR
107115: LD_INT 1
107117: PUSH
107118: FOR_DOWNTO
107119: IFFALSE 111241
// begin wait ( 5 ) ;
107121: LD_INT 5
107123: PPUSH
107124: CALL_OW 67
// tmp := [ ] ;
107128: LD_ADDR_VAR 0 14
107132: PUSH
107133: EMPTY
107134: ST_TO_ADDR
// attacking := false ;
107135: LD_ADDR_VAR 0 29
107139: PUSH
107140: LD_INT 0
107142: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
107143: LD_VAR 0 4
107147: PUSH
107148: LD_VAR 0 7
107152: ARRAY
107153: PPUSH
107154: CALL_OW 301
107158: PUSH
107159: LD_VAR 0 4
107163: PUSH
107164: LD_VAR 0 7
107168: ARRAY
107169: NOT
107170: OR
107171: IFFALSE 107280
// begin if GetType ( group [ i ] ) = unit_human then
107173: LD_VAR 0 4
107177: PUSH
107178: LD_VAR 0 7
107182: ARRAY
107183: PPUSH
107184: CALL_OW 247
107188: PUSH
107189: LD_INT 1
107191: EQUAL
107192: IFFALSE 107238
// begin to_heal := to_heal diff group [ i ] ;
107194: LD_ADDR_VAR 0 30
107198: PUSH
107199: LD_VAR 0 30
107203: PUSH
107204: LD_VAR 0 4
107208: PUSH
107209: LD_VAR 0 7
107213: ARRAY
107214: DIFF
107215: ST_TO_ADDR
// healers := healers diff group [ i ] ;
107216: LD_ADDR_VAR 0 31
107220: PUSH
107221: LD_VAR 0 31
107225: PUSH
107226: LD_VAR 0 4
107230: PUSH
107231: LD_VAR 0 7
107235: ARRAY
107236: DIFF
107237: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
107238: LD_ADDR_VAR 0 4
107242: PUSH
107243: LD_VAR 0 4
107247: PPUSH
107248: LD_VAR 0 7
107252: PPUSH
107253: CALL_OW 3
107257: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
107258: LD_ADDR_VAR 0 16
107262: PUSH
107263: LD_VAR 0 16
107267: PPUSH
107268: LD_VAR 0 7
107272: PPUSH
107273: CALL_OW 3
107277: ST_TO_ADDR
// continue ;
107278: GO 107118
// end ; if f_repair then
107280: LD_VAR 0 22
107284: IFFALSE 107773
// begin if GetType ( group [ i ] ) = unit_vehicle then
107286: LD_VAR 0 4
107290: PUSH
107291: LD_VAR 0 7
107295: ARRAY
107296: PPUSH
107297: CALL_OW 247
107301: PUSH
107302: LD_INT 2
107304: EQUAL
107305: IFFALSE 107495
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
107307: LD_VAR 0 4
107311: PUSH
107312: LD_VAR 0 7
107316: ARRAY
107317: PPUSH
107318: CALL_OW 256
107322: PUSH
107323: LD_INT 700
107325: LESS
107326: PUSH
107327: LD_VAR 0 4
107331: PUSH
107332: LD_VAR 0 7
107336: ARRAY
107337: PUSH
107338: LD_VAR 0 32
107342: IN
107343: NOT
107344: AND
107345: IFFALSE 107369
// to_repair := to_repair union group [ i ] ;
107347: LD_ADDR_VAR 0 32
107351: PUSH
107352: LD_VAR 0 32
107356: PUSH
107357: LD_VAR 0 4
107361: PUSH
107362: LD_VAR 0 7
107366: ARRAY
107367: UNION
107368: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
107369: LD_VAR 0 4
107373: PUSH
107374: LD_VAR 0 7
107378: ARRAY
107379: PPUSH
107380: CALL_OW 256
107384: PUSH
107385: LD_INT 1000
107387: EQUAL
107388: PUSH
107389: LD_VAR 0 4
107393: PUSH
107394: LD_VAR 0 7
107398: ARRAY
107399: PUSH
107400: LD_VAR 0 32
107404: IN
107405: AND
107406: IFFALSE 107430
// to_repair := to_repair diff group [ i ] ;
107408: LD_ADDR_VAR 0 32
107412: PUSH
107413: LD_VAR 0 32
107417: PUSH
107418: LD_VAR 0 4
107422: PUSH
107423: LD_VAR 0 7
107427: ARRAY
107428: DIFF
107429: ST_TO_ADDR
// if group [ i ] in to_repair then
107430: LD_VAR 0 4
107434: PUSH
107435: LD_VAR 0 7
107439: ARRAY
107440: PUSH
107441: LD_VAR 0 32
107445: IN
107446: IFFALSE 107493
// begin if not IsInArea ( group [ i ] , f_repair ) then
107448: LD_VAR 0 4
107452: PUSH
107453: LD_VAR 0 7
107457: ARRAY
107458: PPUSH
107459: LD_VAR 0 22
107463: PPUSH
107464: CALL_OW 308
107468: NOT
107469: IFFALSE 107491
// ComMoveToArea ( group [ i ] , f_repair ) ;
107471: LD_VAR 0 4
107475: PUSH
107476: LD_VAR 0 7
107480: ARRAY
107481: PPUSH
107482: LD_VAR 0 22
107486: PPUSH
107487: CALL_OW 113
// continue ;
107491: GO 107118
// end ; end else
107493: GO 107773
// if group [ i ] in repairs then
107495: LD_VAR 0 4
107499: PUSH
107500: LD_VAR 0 7
107504: ARRAY
107505: PUSH
107506: LD_VAR 0 33
107510: IN
107511: IFFALSE 107773
// begin if IsInUnit ( group [ i ] ) then
107513: LD_VAR 0 4
107517: PUSH
107518: LD_VAR 0 7
107522: ARRAY
107523: PPUSH
107524: CALL_OW 310
107528: IFFALSE 107596
// begin z := IsInUnit ( group [ i ] ) ;
107530: LD_ADDR_VAR 0 13
107534: PUSH
107535: LD_VAR 0 4
107539: PUSH
107540: LD_VAR 0 7
107544: ARRAY
107545: PPUSH
107546: CALL_OW 310
107550: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
107551: LD_VAR 0 13
107555: PUSH
107556: LD_VAR 0 32
107560: IN
107561: PUSH
107562: LD_VAR 0 13
107566: PPUSH
107567: LD_VAR 0 22
107571: PPUSH
107572: CALL_OW 308
107576: AND
107577: IFFALSE 107594
// ComExitVehicle ( group [ i ] ) ;
107579: LD_VAR 0 4
107583: PUSH
107584: LD_VAR 0 7
107588: ARRAY
107589: PPUSH
107590: CALL_OW 121
// end else
107594: GO 107773
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
107596: LD_ADDR_VAR 0 13
107600: PUSH
107601: LD_VAR 0 4
107605: PPUSH
107606: LD_INT 95
107608: PUSH
107609: LD_VAR 0 22
107613: PUSH
107614: EMPTY
107615: LIST
107616: LIST
107617: PUSH
107618: LD_INT 58
107620: PUSH
107621: EMPTY
107622: LIST
107623: PUSH
107624: EMPTY
107625: LIST
107626: LIST
107627: PPUSH
107628: CALL_OW 72
107632: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
107633: LD_VAR 0 4
107637: PUSH
107638: LD_VAR 0 7
107642: ARRAY
107643: PPUSH
107644: CALL_OW 314
107648: NOT
107649: IFFALSE 107771
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
107651: LD_ADDR_VAR 0 10
107655: PUSH
107656: LD_VAR 0 13
107660: PPUSH
107661: LD_VAR 0 4
107665: PUSH
107666: LD_VAR 0 7
107670: ARRAY
107671: PPUSH
107672: CALL_OW 74
107676: ST_TO_ADDR
// if not x then
107677: LD_VAR 0 10
107681: NOT
107682: IFFALSE 107686
// continue ;
107684: GO 107118
// if GetLives ( x ) < 1000 then
107686: LD_VAR 0 10
107690: PPUSH
107691: CALL_OW 256
107695: PUSH
107696: LD_INT 1000
107698: LESS
107699: IFFALSE 107723
// ComRepairVehicle ( group [ i ] , x ) else
107701: LD_VAR 0 4
107705: PUSH
107706: LD_VAR 0 7
107710: ARRAY
107711: PPUSH
107712: LD_VAR 0 10
107716: PPUSH
107717: CALL_OW 129
107721: GO 107771
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
107723: LD_VAR 0 23
107727: PUSH
107728: LD_VAR 0 4
107732: PUSH
107733: LD_VAR 0 7
107737: ARRAY
107738: PPUSH
107739: CALL_OW 256
107743: PUSH
107744: LD_INT 1000
107746: LESS
107747: AND
107748: NOT
107749: IFFALSE 107771
// ComEnterUnit ( group [ i ] , x ) ;
107751: LD_VAR 0 4
107755: PUSH
107756: LD_VAR 0 7
107760: ARRAY
107761: PPUSH
107762: LD_VAR 0 10
107766: PPUSH
107767: CALL_OW 120
// end ; continue ;
107771: GO 107118
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
107773: LD_VAR 0 23
107777: PUSH
107778: LD_VAR 0 4
107782: PUSH
107783: LD_VAR 0 7
107787: ARRAY
107788: PPUSH
107789: CALL_OW 247
107793: PUSH
107794: LD_INT 1
107796: EQUAL
107797: AND
107798: IFFALSE 108276
// begin if group [ i ] in healers then
107800: LD_VAR 0 4
107804: PUSH
107805: LD_VAR 0 7
107809: ARRAY
107810: PUSH
107811: LD_VAR 0 31
107815: IN
107816: IFFALSE 108089
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
107818: LD_VAR 0 4
107822: PUSH
107823: LD_VAR 0 7
107827: ARRAY
107828: PPUSH
107829: LD_VAR 0 23
107833: PPUSH
107834: CALL_OW 308
107838: NOT
107839: PUSH
107840: LD_VAR 0 4
107844: PUSH
107845: LD_VAR 0 7
107849: ARRAY
107850: PPUSH
107851: CALL_OW 314
107855: NOT
107856: AND
107857: IFFALSE 107881
// ComMoveToArea ( group [ i ] , f_heal ) else
107859: LD_VAR 0 4
107863: PUSH
107864: LD_VAR 0 7
107868: ARRAY
107869: PPUSH
107870: LD_VAR 0 23
107874: PPUSH
107875: CALL_OW 113
107879: GO 108087
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
107881: LD_VAR 0 4
107885: PUSH
107886: LD_VAR 0 7
107890: ARRAY
107891: PPUSH
107892: CALL 49615 0 1
107896: PPUSH
107897: CALL_OW 256
107901: PUSH
107902: LD_INT 1000
107904: EQUAL
107905: IFFALSE 107924
// ComStop ( group [ i ] ) else
107907: LD_VAR 0 4
107911: PUSH
107912: LD_VAR 0 7
107916: ARRAY
107917: PPUSH
107918: CALL_OW 141
107922: GO 108087
// if not HasTask ( group [ i ] ) and to_heal then
107924: LD_VAR 0 4
107928: PUSH
107929: LD_VAR 0 7
107933: ARRAY
107934: PPUSH
107935: CALL_OW 314
107939: NOT
107940: PUSH
107941: LD_VAR 0 30
107945: AND
107946: IFFALSE 108087
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
107948: LD_ADDR_VAR 0 13
107952: PUSH
107953: LD_VAR 0 30
107957: PPUSH
107958: LD_INT 3
107960: PUSH
107961: LD_INT 54
107963: PUSH
107964: EMPTY
107965: LIST
107966: PUSH
107967: EMPTY
107968: LIST
107969: LIST
107970: PPUSH
107971: CALL_OW 72
107975: PPUSH
107976: LD_VAR 0 4
107980: PUSH
107981: LD_VAR 0 7
107985: ARRAY
107986: PPUSH
107987: CALL_OW 74
107991: ST_TO_ADDR
// if z then
107992: LD_VAR 0 13
107996: IFFALSE 108087
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
107998: LD_INT 91
108000: PUSH
108001: LD_VAR 0 13
108005: PUSH
108006: LD_INT 10
108008: PUSH
108009: EMPTY
108010: LIST
108011: LIST
108012: LIST
108013: PUSH
108014: LD_INT 81
108016: PUSH
108017: LD_VAR 0 13
108021: PPUSH
108022: CALL_OW 255
108026: PUSH
108027: EMPTY
108028: LIST
108029: LIST
108030: PUSH
108031: EMPTY
108032: LIST
108033: LIST
108034: PPUSH
108035: CALL_OW 69
108039: PUSH
108040: LD_INT 0
108042: EQUAL
108043: IFFALSE 108067
// ComHeal ( group [ i ] , z ) else
108045: LD_VAR 0 4
108049: PUSH
108050: LD_VAR 0 7
108054: ARRAY
108055: PPUSH
108056: LD_VAR 0 13
108060: PPUSH
108061: CALL_OW 128
108065: GO 108087
// ComMoveToArea ( group [ i ] , f_heal ) ;
108067: LD_VAR 0 4
108071: PUSH
108072: LD_VAR 0 7
108076: ARRAY
108077: PPUSH
108078: LD_VAR 0 23
108082: PPUSH
108083: CALL_OW 113
// end ; continue ;
108087: GO 107118
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
108089: LD_VAR 0 4
108093: PUSH
108094: LD_VAR 0 7
108098: ARRAY
108099: PPUSH
108100: CALL_OW 256
108104: PUSH
108105: LD_INT 700
108107: LESS
108108: PUSH
108109: LD_VAR 0 4
108113: PUSH
108114: LD_VAR 0 7
108118: ARRAY
108119: PUSH
108120: LD_VAR 0 30
108124: IN
108125: NOT
108126: AND
108127: IFFALSE 108151
// to_heal := to_heal union group [ i ] ;
108129: LD_ADDR_VAR 0 30
108133: PUSH
108134: LD_VAR 0 30
108138: PUSH
108139: LD_VAR 0 4
108143: PUSH
108144: LD_VAR 0 7
108148: ARRAY
108149: UNION
108150: ST_TO_ADDR
// if group [ i ] in to_heal then
108151: LD_VAR 0 4
108155: PUSH
108156: LD_VAR 0 7
108160: ARRAY
108161: PUSH
108162: LD_VAR 0 30
108166: IN
108167: IFFALSE 108276
// begin if GetLives ( group [ i ] ) = 1000 then
108169: LD_VAR 0 4
108173: PUSH
108174: LD_VAR 0 7
108178: ARRAY
108179: PPUSH
108180: CALL_OW 256
108184: PUSH
108185: LD_INT 1000
108187: EQUAL
108188: IFFALSE 108214
// to_heal := to_heal diff group [ i ] else
108190: LD_ADDR_VAR 0 30
108194: PUSH
108195: LD_VAR 0 30
108199: PUSH
108200: LD_VAR 0 4
108204: PUSH
108205: LD_VAR 0 7
108209: ARRAY
108210: DIFF
108211: ST_TO_ADDR
108212: GO 108276
// begin if not IsInArea ( group [ i ] , to_heal ) then
108214: LD_VAR 0 4
108218: PUSH
108219: LD_VAR 0 7
108223: ARRAY
108224: PPUSH
108225: LD_VAR 0 30
108229: PPUSH
108230: CALL_OW 308
108234: NOT
108235: IFFALSE 108259
// ComMoveToArea ( group [ i ] , f_heal ) else
108237: LD_VAR 0 4
108241: PUSH
108242: LD_VAR 0 7
108246: ARRAY
108247: PPUSH
108248: LD_VAR 0 23
108252: PPUSH
108253: CALL_OW 113
108257: GO 108274
// ComHold ( group [ i ] ) ;
108259: LD_VAR 0 4
108263: PUSH
108264: LD_VAR 0 7
108268: ARRAY
108269: PPUSH
108270: CALL_OW 140
// continue ;
108274: GO 107118
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
108276: LD_VAR 0 4
108280: PUSH
108281: LD_VAR 0 7
108285: ARRAY
108286: PPUSH
108287: LD_INT 10
108289: PPUSH
108290: CALL 47485 0 2
108294: NOT
108295: PUSH
108296: LD_VAR 0 16
108300: PUSH
108301: LD_VAR 0 7
108305: ARRAY
108306: PUSH
108307: EMPTY
108308: EQUAL
108309: NOT
108310: AND
108311: IFFALSE 108577
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
108313: LD_VAR 0 4
108317: PUSH
108318: LD_VAR 0 7
108322: ARRAY
108323: PPUSH
108324: CALL_OW 262
108328: PUSH
108329: LD_INT 1
108331: PUSH
108332: LD_INT 2
108334: PUSH
108335: EMPTY
108336: LIST
108337: LIST
108338: IN
108339: IFFALSE 108380
// if GetFuel ( group [ i ] ) < 10 then
108341: LD_VAR 0 4
108345: PUSH
108346: LD_VAR 0 7
108350: ARRAY
108351: PPUSH
108352: CALL_OW 261
108356: PUSH
108357: LD_INT 10
108359: LESS
108360: IFFALSE 108380
// SetFuel ( group [ i ] , 12 ) ;
108362: LD_VAR 0 4
108366: PUSH
108367: LD_VAR 0 7
108371: ARRAY
108372: PPUSH
108373: LD_INT 12
108375: PPUSH
108376: CALL_OW 240
// if units_path [ i ] then
108380: LD_VAR 0 16
108384: PUSH
108385: LD_VAR 0 7
108389: ARRAY
108390: IFFALSE 108575
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
108392: LD_VAR 0 4
108396: PUSH
108397: LD_VAR 0 7
108401: ARRAY
108402: PPUSH
108403: LD_VAR 0 16
108407: PUSH
108408: LD_VAR 0 7
108412: ARRAY
108413: PUSH
108414: LD_INT 1
108416: ARRAY
108417: PUSH
108418: LD_INT 1
108420: ARRAY
108421: PPUSH
108422: LD_VAR 0 16
108426: PUSH
108427: LD_VAR 0 7
108431: ARRAY
108432: PUSH
108433: LD_INT 1
108435: ARRAY
108436: PUSH
108437: LD_INT 2
108439: ARRAY
108440: PPUSH
108441: CALL_OW 297
108445: PUSH
108446: LD_INT 6
108448: GREATER
108449: IFFALSE 108524
// begin if not HasTask ( group [ i ] ) then
108451: LD_VAR 0 4
108455: PUSH
108456: LD_VAR 0 7
108460: ARRAY
108461: PPUSH
108462: CALL_OW 314
108466: NOT
108467: IFFALSE 108522
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
108469: LD_VAR 0 4
108473: PUSH
108474: LD_VAR 0 7
108478: ARRAY
108479: PPUSH
108480: LD_VAR 0 16
108484: PUSH
108485: LD_VAR 0 7
108489: ARRAY
108490: PUSH
108491: LD_INT 1
108493: ARRAY
108494: PUSH
108495: LD_INT 1
108497: ARRAY
108498: PPUSH
108499: LD_VAR 0 16
108503: PUSH
108504: LD_VAR 0 7
108508: ARRAY
108509: PUSH
108510: LD_INT 1
108512: ARRAY
108513: PUSH
108514: LD_INT 2
108516: ARRAY
108517: PPUSH
108518: CALL_OW 114
// end else
108522: GO 108575
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
108524: LD_ADDR_VAR 0 15
108528: PUSH
108529: LD_VAR 0 16
108533: PUSH
108534: LD_VAR 0 7
108538: ARRAY
108539: PPUSH
108540: LD_INT 1
108542: PPUSH
108543: CALL_OW 3
108547: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
108548: LD_ADDR_VAR 0 16
108552: PUSH
108553: LD_VAR 0 16
108557: PPUSH
108558: LD_VAR 0 7
108562: PPUSH
108563: LD_VAR 0 15
108567: PPUSH
108568: CALL_OW 1
108572: ST_TO_ADDR
// continue ;
108573: GO 107118
// end ; end ; end else
108575: GO 111239
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
108577: LD_ADDR_VAR 0 14
108581: PUSH
108582: LD_INT 81
108584: PUSH
108585: LD_VAR 0 4
108589: PUSH
108590: LD_VAR 0 7
108594: ARRAY
108595: PPUSH
108596: CALL_OW 255
108600: PUSH
108601: EMPTY
108602: LIST
108603: LIST
108604: PPUSH
108605: CALL_OW 69
108609: ST_TO_ADDR
// if not tmp then
108610: LD_VAR 0 14
108614: NOT
108615: IFFALSE 108619
// continue ;
108617: GO 107118
// if f_ignore_area then
108619: LD_VAR 0 17
108623: IFFALSE 108711
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
108625: LD_ADDR_VAR 0 15
108629: PUSH
108630: LD_VAR 0 14
108634: PPUSH
108635: LD_INT 3
108637: PUSH
108638: LD_INT 92
108640: PUSH
108641: LD_VAR 0 17
108645: PUSH
108646: LD_INT 1
108648: ARRAY
108649: PUSH
108650: LD_VAR 0 17
108654: PUSH
108655: LD_INT 2
108657: ARRAY
108658: PUSH
108659: LD_VAR 0 17
108663: PUSH
108664: LD_INT 3
108666: ARRAY
108667: PUSH
108668: EMPTY
108669: LIST
108670: LIST
108671: LIST
108672: LIST
108673: PUSH
108674: EMPTY
108675: LIST
108676: LIST
108677: PPUSH
108678: CALL_OW 72
108682: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
108683: LD_VAR 0 14
108687: PUSH
108688: LD_VAR 0 15
108692: DIFF
108693: IFFALSE 108711
// tmp := tmp diff tmp2 ;
108695: LD_ADDR_VAR 0 14
108699: PUSH
108700: LD_VAR 0 14
108704: PUSH
108705: LD_VAR 0 15
108709: DIFF
108710: ST_TO_ADDR
// end ; if not f_murder then
108711: LD_VAR 0 20
108715: NOT
108716: IFFALSE 108774
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
108718: LD_ADDR_VAR 0 15
108722: PUSH
108723: LD_VAR 0 14
108727: PPUSH
108728: LD_INT 3
108730: PUSH
108731: LD_INT 50
108733: PUSH
108734: EMPTY
108735: LIST
108736: PUSH
108737: EMPTY
108738: LIST
108739: LIST
108740: PPUSH
108741: CALL_OW 72
108745: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
108746: LD_VAR 0 14
108750: PUSH
108751: LD_VAR 0 15
108755: DIFF
108756: IFFALSE 108774
// tmp := tmp diff tmp2 ;
108758: LD_ADDR_VAR 0 14
108762: PUSH
108763: LD_VAR 0 14
108767: PUSH
108768: LD_VAR 0 15
108772: DIFF
108773: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
108774: LD_ADDR_VAR 0 14
108778: PUSH
108779: LD_VAR 0 4
108783: PUSH
108784: LD_VAR 0 7
108788: ARRAY
108789: PPUSH
108790: LD_VAR 0 14
108794: PPUSH
108795: LD_INT 1
108797: PPUSH
108798: LD_INT 1
108800: PPUSH
108801: CALL 20426 0 4
108805: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
108806: LD_VAR 0 4
108810: PUSH
108811: LD_VAR 0 7
108815: ARRAY
108816: PPUSH
108817: CALL_OW 257
108821: PUSH
108822: LD_INT 1
108824: EQUAL
108825: IFFALSE 109273
// begin if WantPlant ( group [ i ] ) then
108827: LD_VAR 0 4
108831: PUSH
108832: LD_VAR 0 7
108836: ARRAY
108837: PPUSH
108838: CALL 19927 0 1
108842: IFFALSE 108846
// continue ;
108844: GO 107118
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
108846: LD_VAR 0 18
108850: PUSH
108851: LD_VAR 0 4
108855: PUSH
108856: LD_VAR 0 7
108860: ARRAY
108861: PPUSH
108862: CALL_OW 310
108866: NOT
108867: AND
108868: PUSH
108869: LD_VAR 0 14
108873: PUSH
108874: LD_INT 1
108876: ARRAY
108877: PUSH
108878: LD_VAR 0 14
108882: PPUSH
108883: LD_INT 21
108885: PUSH
108886: LD_INT 2
108888: PUSH
108889: EMPTY
108890: LIST
108891: LIST
108892: PUSH
108893: LD_INT 58
108895: PUSH
108896: EMPTY
108897: LIST
108898: PUSH
108899: EMPTY
108900: LIST
108901: LIST
108902: PPUSH
108903: CALL_OW 72
108907: IN
108908: AND
108909: IFFALSE 108945
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
108911: LD_VAR 0 4
108915: PUSH
108916: LD_VAR 0 7
108920: ARRAY
108921: PPUSH
108922: LD_VAR 0 14
108926: PUSH
108927: LD_INT 1
108929: ARRAY
108930: PPUSH
108931: CALL_OW 120
// attacking := true ;
108935: LD_ADDR_VAR 0 29
108939: PUSH
108940: LD_INT 1
108942: ST_TO_ADDR
// continue ;
108943: GO 107118
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
108945: LD_VAR 0 26
108949: PUSH
108950: LD_VAR 0 4
108954: PUSH
108955: LD_VAR 0 7
108959: ARRAY
108960: PPUSH
108961: CALL_OW 257
108965: PUSH
108966: LD_INT 1
108968: EQUAL
108969: AND
108970: PUSH
108971: LD_VAR 0 4
108975: PUSH
108976: LD_VAR 0 7
108980: ARRAY
108981: PPUSH
108982: CALL_OW 256
108986: PUSH
108987: LD_INT 800
108989: LESS
108990: AND
108991: PUSH
108992: LD_VAR 0 4
108996: PUSH
108997: LD_VAR 0 7
109001: ARRAY
109002: PPUSH
109003: CALL_OW 318
109007: NOT
109008: AND
109009: IFFALSE 109026
// ComCrawl ( group [ i ] ) ;
109011: LD_VAR 0 4
109015: PUSH
109016: LD_VAR 0 7
109020: ARRAY
109021: PPUSH
109022: CALL_OW 137
// if f_mines then
109026: LD_VAR 0 21
109030: IFFALSE 109273
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
109032: LD_VAR 0 14
109036: PUSH
109037: LD_INT 1
109039: ARRAY
109040: PPUSH
109041: CALL_OW 247
109045: PUSH
109046: LD_INT 3
109048: EQUAL
109049: PUSH
109050: LD_VAR 0 14
109054: PUSH
109055: LD_INT 1
109057: ARRAY
109058: PUSH
109059: LD_VAR 0 27
109063: IN
109064: NOT
109065: AND
109066: IFFALSE 109273
// begin x := GetX ( tmp [ 1 ] ) ;
109068: LD_ADDR_VAR 0 10
109072: PUSH
109073: LD_VAR 0 14
109077: PUSH
109078: LD_INT 1
109080: ARRAY
109081: PPUSH
109082: CALL_OW 250
109086: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
109087: LD_ADDR_VAR 0 11
109091: PUSH
109092: LD_VAR 0 14
109096: PUSH
109097: LD_INT 1
109099: ARRAY
109100: PPUSH
109101: CALL_OW 251
109105: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
109106: LD_ADDR_VAR 0 12
109110: PUSH
109111: LD_VAR 0 4
109115: PUSH
109116: LD_VAR 0 7
109120: ARRAY
109121: PPUSH
109122: CALL 47570 0 1
109126: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
109127: LD_VAR 0 4
109131: PUSH
109132: LD_VAR 0 7
109136: ARRAY
109137: PPUSH
109138: LD_VAR 0 10
109142: PPUSH
109143: LD_VAR 0 11
109147: PPUSH
109148: LD_VAR 0 14
109152: PUSH
109153: LD_INT 1
109155: ARRAY
109156: PPUSH
109157: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
109161: LD_VAR 0 4
109165: PUSH
109166: LD_VAR 0 7
109170: ARRAY
109171: PPUSH
109172: LD_VAR 0 10
109176: PPUSH
109177: LD_VAR 0 12
109181: PPUSH
109182: LD_INT 7
109184: PPUSH
109185: CALL_OW 272
109189: PPUSH
109190: LD_VAR 0 11
109194: PPUSH
109195: LD_VAR 0 12
109199: PPUSH
109200: LD_INT 7
109202: PPUSH
109203: CALL_OW 273
109207: PPUSH
109208: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
109212: LD_VAR 0 4
109216: PUSH
109217: LD_VAR 0 7
109221: ARRAY
109222: PPUSH
109223: LD_INT 71
109225: PPUSH
109226: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
109230: LD_ADDR_VAR 0 27
109234: PUSH
109235: LD_VAR 0 27
109239: PPUSH
109240: LD_VAR 0 27
109244: PUSH
109245: LD_INT 1
109247: PLUS
109248: PPUSH
109249: LD_VAR 0 14
109253: PUSH
109254: LD_INT 1
109256: ARRAY
109257: PPUSH
109258: CALL_OW 1
109262: ST_TO_ADDR
// attacking := true ;
109263: LD_ADDR_VAR 0 29
109267: PUSH
109268: LD_INT 1
109270: ST_TO_ADDR
// continue ;
109271: GO 107118
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
109273: LD_VAR 0 4
109277: PUSH
109278: LD_VAR 0 7
109282: ARRAY
109283: PPUSH
109284: CALL_OW 257
109288: PUSH
109289: LD_INT 17
109291: EQUAL
109292: PUSH
109293: LD_VAR 0 4
109297: PUSH
109298: LD_VAR 0 7
109302: ARRAY
109303: PPUSH
109304: CALL_OW 110
109308: PUSH
109309: LD_INT 71
109311: EQUAL
109312: NOT
109313: AND
109314: IFFALSE 109460
// begin attacking := false ;
109316: LD_ADDR_VAR 0 29
109320: PUSH
109321: LD_INT 0
109323: ST_TO_ADDR
// k := 5 ;
109324: LD_ADDR_VAR 0 9
109328: PUSH
109329: LD_INT 5
109331: ST_TO_ADDR
// if tmp < k then
109332: LD_VAR 0 14
109336: PUSH
109337: LD_VAR 0 9
109341: LESS
109342: IFFALSE 109354
// k := tmp ;
109344: LD_ADDR_VAR 0 9
109348: PUSH
109349: LD_VAR 0 14
109353: ST_TO_ADDR
// for j = 1 to k do
109354: LD_ADDR_VAR 0 8
109358: PUSH
109359: DOUBLE
109360: LD_INT 1
109362: DEC
109363: ST_TO_ADDR
109364: LD_VAR 0 9
109368: PUSH
109369: FOR_TO
109370: IFFALSE 109458
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
109372: LD_VAR 0 14
109376: PUSH
109377: LD_VAR 0 8
109381: ARRAY
109382: PUSH
109383: LD_VAR 0 14
109387: PPUSH
109388: LD_INT 58
109390: PUSH
109391: EMPTY
109392: LIST
109393: PPUSH
109394: CALL_OW 72
109398: IN
109399: NOT
109400: IFFALSE 109456
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109402: LD_VAR 0 4
109406: PUSH
109407: LD_VAR 0 7
109411: ARRAY
109412: PPUSH
109413: LD_VAR 0 14
109417: PUSH
109418: LD_VAR 0 8
109422: ARRAY
109423: PPUSH
109424: CALL_OW 115
// attacking := true ;
109428: LD_ADDR_VAR 0 29
109432: PUSH
109433: LD_INT 1
109435: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
109436: LD_VAR 0 4
109440: PUSH
109441: LD_VAR 0 7
109445: ARRAY
109446: PPUSH
109447: LD_INT 71
109449: PPUSH
109450: CALL_OW 109
// continue ;
109454: GO 109369
// end ; end ;
109456: GO 109369
109458: POP
109459: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
109460: LD_VAR 0 4
109464: PUSH
109465: LD_VAR 0 7
109469: ARRAY
109470: PPUSH
109471: CALL_OW 257
109475: PUSH
109476: LD_INT 8
109478: EQUAL
109479: PUSH
109480: LD_VAR 0 4
109484: PUSH
109485: LD_VAR 0 7
109489: ARRAY
109490: PPUSH
109491: CALL_OW 264
109495: PUSH
109496: LD_INT 28
109498: PUSH
109499: LD_INT 45
109501: PUSH
109502: LD_INT 7
109504: PUSH
109505: LD_INT 47
109507: PUSH
109508: EMPTY
109509: LIST
109510: LIST
109511: LIST
109512: LIST
109513: IN
109514: OR
109515: IFFALSE 109771
// begin attacking := false ;
109517: LD_ADDR_VAR 0 29
109521: PUSH
109522: LD_INT 0
109524: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
109525: LD_VAR 0 14
109529: PUSH
109530: LD_INT 1
109532: ARRAY
109533: PPUSH
109534: CALL_OW 266
109538: PUSH
109539: LD_INT 32
109541: PUSH
109542: LD_INT 31
109544: PUSH
109545: LD_INT 33
109547: PUSH
109548: LD_INT 4
109550: PUSH
109551: LD_INT 5
109553: PUSH
109554: EMPTY
109555: LIST
109556: LIST
109557: LIST
109558: LIST
109559: LIST
109560: IN
109561: IFFALSE 109747
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
109563: LD_ADDR_VAR 0 9
109567: PUSH
109568: LD_VAR 0 14
109572: PUSH
109573: LD_INT 1
109575: ARRAY
109576: PPUSH
109577: CALL_OW 266
109581: PPUSH
109582: LD_VAR 0 14
109586: PUSH
109587: LD_INT 1
109589: ARRAY
109590: PPUSH
109591: CALL_OW 250
109595: PPUSH
109596: LD_VAR 0 14
109600: PUSH
109601: LD_INT 1
109603: ARRAY
109604: PPUSH
109605: CALL_OW 251
109609: PPUSH
109610: LD_VAR 0 14
109614: PUSH
109615: LD_INT 1
109617: ARRAY
109618: PPUSH
109619: CALL_OW 254
109623: PPUSH
109624: LD_VAR 0 14
109628: PUSH
109629: LD_INT 1
109631: ARRAY
109632: PPUSH
109633: CALL_OW 248
109637: PPUSH
109638: LD_INT 0
109640: PPUSH
109641: CALL 28940 0 6
109645: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
109646: LD_ADDR_VAR 0 8
109650: PUSH
109651: LD_VAR 0 4
109655: PUSH
109656: LD_VAR 0 7
109660: ARRAY
109661: PPUSH
109662: LD_VAR 0 9
109666: PPUSH
109667: CALL 47610 0 2
109671: ST_TO_ADDR
// if j then
109672: LD_VAR 0 8
109676: IFFALSE 109745
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
109678: LD_VAR 0 8
109682: PUSH
109683: LD_INT 1
109685: ARRAY
109686: PPUSH
109687: LD_VAR 0 8
109691: PUSH
109692: LD_INT 2
109694: ARRAY
109695: PPUSH
109696: CALL_OW 488
109700: IFFALSE 109745
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
109702: LD_VAR 0 4
109706: PUSH
109707: LD_VAR 0 7
109711: ARRAY
109712: PPUSH
109713: LD_VAR 0 8
109717: PUSH
109718: LD_INT 1
109720: ARRAY
109721: PPUSH
109722: LD_VAR 0 8
109726: PUSH
109727: LD_INT 2
109729: ARRAY
109730: PPUSH
109731: CALL_OW 116
// attacking := true ;
109735: LD_ADDR_VAR 0 29
109739: PUSH
109740: LD_INT 1
109742: ST_TO_ADDR
// continue ;
109743: GO 107118
// end ; end else
109745: GO 109771
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109747: LD_VAR 0 4
109751: PUSH
109752: LD_VAR 0 7
109756: ARRAY
109757: PPUSH
109758: LD_VAR 0 14
109762: PUSH
109763: LD_INT 1
109765: ARRAY
109766: PPUSH
109767: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
109771: LD_VAR 0 4
109775: PUSH
109776: LD_VAR 0 7
109780: ARRAY
109781: PPUSH
109782: CALL_OW 265
109786: PUSH
109787: LD_INT 11
109789: EQUAL
109790: IFFALSE 110068
// begin k := 10 ;
109792: LD_ADDR_VAR 0 9
109796: PUSH
109797: LD_INT 10
109799: ST_TO_ADDR
// x := 0 ;
109800: LD_ADDR_VAR 0 10
109804: PUSH
109805: LD_INT 0
109807: ST_TO_ADDR
// if tmp < k then
109808: LD_VAR 0 14
109812: PUSH
109813: LD_VAR 0 9
109817: LESS
109818: IFFALSE 109830
// k := tmp ;
109820: LD_ADDR_VAR 0 9
109824: PUSH
109825: LD_VAR 0 14
109829: ST_TO_ADDR
// for j = k downto 1 do
109830: LD_ADDR_VAR 0 8
109834: PUSH
109835: DOUBLE
109836: LD_VAR 0 9
109840: INC
109841: ST_TO_ADDR
109842: LD_INT 1
109844: PUSH
109845: FOR_DOWNTO
109846: IFFALSE 109921
// begin if GetType ( tmp [ j ] ) = unit_human then
109848: LD_VAR 0 14
109852: PUSH
109853: LD_VAR 0 8
109857: ARRAY
109858: PPUSH
109859: CALL_OW 247
109863: PUSH
109864: LD_INT 1
109866: EQUAL
109867: IFFALSE 109919
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
109869: LD_VAR 0 4
109873: PUSH
109874: LD_VAR 0 7
109878: ARRAY
109879: PPUSH
109880: LD_VAR 0 14
109884: PUSH
109885: LD_VAR 0 8
109889: ARRAY
109890: PPUSH
109891: CALL 47864 0 2
// x := tmp [ j ] ;
109895: LD_ADDR_VAR 0 10
109899: PUSH
109900: LD_VAR 0 14
109904: PUSH
109905: LD_VAR 0 8
109909: ARRAY
109910: ST_TO_ADDR
// attacking := true ;
109911: LD_ADDR_VAR 0 29
109915: PUSH
109916: LD_INT 1
109918: ST_TO_ADDR
// end ; end ;
109919: GO 109845
109921: POP
109922: POP
// if not x then
109923: LD_VAR 0 10
109927: NOT
109928: IFFALSE 110068
// begin attacking := true ;
109930: LD_ADDR_VAR 0 29
109934: PUSH
109935: LD_INT 1
109937: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
109938: LD_VAR 0 4
109942: PUSH
109943: LD_VAR 0 7
109947: ARRAY
109948: PPUSH
109949: CALL_OW 250
109953: PPUSH
109954: LD_VAR 0 4
109958: PUSH
109959: LD_VAR 0 7
109963: ARRAY
109964: PPUSH
109965: CALL_OW 251
109969: PPUSH
109970: CALL_OW 546
109974: PUSH
109975: LD_INT 2
109977: ARRAY
109978: PUSH
109979: LD_VAR 0 14
109983: PUSH
109984: LD_INT 1
109986: ARRAY
109987: PPUSH
109988: CALL_OW 250
109992: PPUSH
109993: LD_VAR 0 14
109997: PUSH
109998: LD_INT 1
110000: ARRAY
110001: PPUSH
110002: CALL_OW 251
110006: PPUSH
110007: CALL_OW 546
110011: PUSH
110012: LD_INT 2
110014: ARRAY
110015: EQUAL
110016: IFFALSE 110044
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
110018: LD_VAR 0 4
110022: PUSH
110023: LD_VAR 0 7
110027: ARRAY
110028: PPUSH
110029: LD_VAR 0 14
110033: PUSH
110034: LD_INT 1
110036: ARRAY
110037: PPUSH
110038: CALL 47864 0 2
110042: GO 110068
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110044: LD_VAR 0 4
110048: PUSH
110049: LD_VAR 0 7
110053: ARRAY
110054: PPUSH
110055: LD_VAR 0 14
110059: PUSH
110060: LD_INT 1
110062: ARRAY
110063: PPUSH
110064: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
110068: LD_VAR 0 4
110072: PUSH
110073: LD_VAR 0 7
110077: ARRAY
110078: PPUSH
110079: CALL_OW 264
110083: PUSH
110084: LD_INT 29
110086: EQUAL
110087: IFFALSE 110453
// begin if WantsToAttack ( group [ i ] ) in bombed then
110089: LD_VAR 0 4
110093: PUSH
110094: LD_VAR 0 7
110098: ARRAY
110099: PPUSH
110100: CALL_OW 319
110104: PUSH
110105: LD_VAR 0 28
110109: IN
110110: IFFALSE 110114
// continue ;
110112: GO 107118
// k := 8 ;
110114: LD_ADDR_VAR 0 9
110118: PUSH
110119: LD_INT 8
110121: ST_TO_ADDR
// x := 0 ;
110122: LD_ADDR_VAR 0 10
110126: PUSH
110127: LD_INT 0
110129: ST_TO_ADDR
// if tmp < k then
110130: LD_VAR 0 14
110134: PUSH
110135: LD_VAR 0 9
110139: LESS
110140: IFFALSE 110152
// k := tmp ;
110142: LD_ADDR_VAR 0 9
110146: PUSH
110147: LD_VAR 0 14
110151: ST_TO_ADDR
// for j = 1 to k do
110152: LD_ADDR_VAR 0 8
110156: PUSH
110157: DOUBLE
110158: LD_INT 1
110160: DEC
110161: ST_TO_ADDR
110162: LD_VAR 0 9
110166: PUSH
110167: FOR_TO
110168: IFFALSE 110300
// begin if GetType ( tmp [ j ] ) = unit_building then
110170: LD_VAR 0 14
110174: PUSH
110175: LD_VAR 0 8
110179: ARRAY
110180: PPUSH
110181: CALL_OW 247
110185: PUSH
110186: LD_INT 3
110188: EQUAL
110189: IFFALSE 110298
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
110191: LD_VAR 0 14
110195: PUSH
110196: LD_VAR 0 8
110200: ARRAY
110201: PUSH
110202: LD_VAR 0 28
110206: IN
110207: NOT
110208: PUSH
110209: LD_VAR 0 14
110213: PUSH
110214: LD_VAR 0 8
110218: ARRAY
110219: PPUSH
110220: CALL_OW 313
110224: AND
110225: IFFALSE 110298
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110227: LD_VAR 0 4
110231: PUSH
110232: LD_VAR 0 7
110236: ARRAY
110237: PPUSH
110238: LD_VAR 0 14
110242: PUSH
110243: LD_VAR 0 8
110247: ARRAY
110248: PPUSH
110249: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
110253: LD_ADDR_VAR 0 28
110257: PUSH
110258: LD_VAR 0 28
110262: PPUSH
110263: LD_VAR 0 28
110267: PUSH
110268: LD_INT 1
110270: PLUS
110271: PPUSH
110272: LD_VAR 0 14
110276: PUSH
110277: LD_VAR 0 8
110281: ARRAY
110282: PPUSH
110283: CALL_OW 1
110287: ST_TO_ADDR
// attacking := true ;
110288: LD_ADDR_VAR 0 29
110292: PUSH
110293: LD_INT 1
110295: ST_TO_ADDR
// break ;
110296: GO 110300
// end ; end ;
110298: GO 110167
110300: POP
110301: POP
// if not attacking and f_attack_depot then
110302: LD_VAR 0 29
110306: NOT
110307: PUSH
110308: LD_VAR 0 25
110312: AND
110313: IFFALSE 110408
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
110315: LD_ADDR_VAR 0 13
110319: PUSH
110320: LD_VAR 0 14
110324: PPUSH
110325: LD_INT 2
110327: PUSH
110328: LD_INT 30
110330: PUSH
110331: LD_INT 0
110333: PUSH
110334: EMPTY
110335: LIST
110336: LIST
110337: PUSH
110338: LD_INT 30
110340: PUSH
110341: LD_INT 1
110343: PUSH
110344: EMPTY
110345: LIST
110346: LIST
110347: PUSH
110348: EMPTY
110349: LIST
110350: LIST
110351: LIST
110352: PPUSH
110353: CALL_OW 72
110357: ST_TO_ADDR
// if z then
110358: LD_VAR 0 13
110362: IFFALSE 110408
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
110364: LD_VAR 0 4
110368: PUSH
110369: LD_VAR 0 7
110373: ARRAY
110374: PPUSH
110375: LD_VAR 0 13
110379: PPUSH
110380: LD_VAR 0 4
110384: PUSH
110385: LD_VAR 0 7
110389: ARRAY
110390: PPUSH
110391: CALL_OW 74
110395: PPUSH
110396: CALL_OW 115
// attacking := true ;
110400: LD_ADDR_VAR 0 29
110404: PUSH
110405: LD_INT 1
110407: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
110408: LD_VAR 0 4
110412: PUSH
110413: LD_VAR 0 7
110417: ARRAY
110418: PPUSH
110419: CALL_OW 256
110423: PUSH
110424: LD_INT 500
110426: LESS
110427: IFFALSE 110453
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110429: LD_VAR 0 4
110433: PUSH
110434: LD_VAR 0 7
110438: ARRAY
110439: PPUSH
110440: LD_VAR 0 14
110444: PUSH
110445: LD_INT 1
110447: ARRAY
110448: PPUSH
110449: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
110453: LD_VAR 0 4
110457: PUSH
110458: LD_VAR 0 7
110462: ARRAY
110463: PPUSH
110464: CALL_OW 264
110468: PUSH
110469: LD_INT 49
110471: EQUAL
110472: IFFALSE 110593
// begin if not HasTask ( group [ i ] ) then
110474: LD_VAR 0 4
110478: PUSH
110479: LD_VAR 0 7
110483: ARRAY
110484: PPUSH
110485: CALL_OW 314
110489: NOT
110490: IFFALSE 110593
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
110492: LD_ADDR_VAR 0 9
110496: PUSH
110497: LD_INT 81
110499: PUSH
110500: LD_VAR 0 4
110504: PUSH
110505: LD_VAR 0 7
110509: ARRAY
110510: PPUSH
110511: CALL_OW 255
110515: PUSH
110516: EMPTY
110517: LIST
110518: LIST
110519: PPUSH
110520: CALL_OW 69
110524: PPUSH
110525: LD_VAR 0 4
110529: PUSH
110530: LD_VAR 0 7
110534: ARRAY
110535: PPUSH
110536: CALL_OW 74
110540: ST_TO_ADDR
// if k then
110541: LD_VAR 0 9
110545: IFFALSE 110593
// if GetDistUnits ( group [ i ] , k ) > 10 then
110547: LD_VAR 0 4
110551: PUSH
110552: LD_VAR 0 7
110556: ARRAY
110557: PPUSH
110558: LD_VAR 0 9
110562: PPUSH
110563: CALL_OW 296
110567: PUSH
110568: LD_INT 10
110570: GREATER
110571: IFFALSE 110593
// ComMoveUnit ( group [ i ] , k ) ;
110573: LD_VAR 0 4
110577: PUSH
110578: LD_VAR 0 7
110582: ARRAY
110583: PPUSH
110584: LD_VAR 0 9
110588: PPUSH
110589: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
110593: LD_VAR 0 4
110597: PUSH
110598: LD_VAR 0 7
110602: ARRAY
110603: PPUSH
110604: CALL_OW 256
110608: PUSH
110609: LD_INT 250
110611: LESS
110612: PUSH
110613: LD_VAR 0 4
110617: PUSH
110618: LD_VAR 0 7
110622: ARRAY
110623: PUSH
110624: LD_INT 21
110626: PUSH
110627: LD_INT 2
110629: PUSH
110630: EMPTY
110631: LIST
110632: LIST
110633: PUSH
110634: LD_INT 23
110636: PUSH
110637: LD_INT 2
110639: PUSH
110640: EMPTY
110641: LIST
110642: LIST
110643: PUSH
110644: EMPTY
110645: LIST
110646: LIST
110647: PPUSH
110648: CALL_OW 69
110652: IN
110653: AND
110654: IFFALSE 110779
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
110656: LD_ADDR_VAR 0 9
110660: PUSH
110661: LD_OWVAR 3
110665: PUSH
110666: LD_VAR 0 4
110670: PUSH
110671: LD_VAR 0 7
110675: ARRAY
110676: DIFF
110677: PPUSH
110678: LD_VAR 0 4
110682: PUSH
110683: LD_VAR 0 7
110687: ARRAY
110688: PPUSH
110689: CALL_OW 74
110693: ST_TO_ADDR
// if not k then
110694: LD_VAR 0 9
110698: NOT
110699: IFFALSE 110703
// continue ;
110701: GO 107118
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
110703: LD_VAR 0 9
110707: PUSH
110708: LD_INT 81
110710: PUSH
110711: LD_VAR 0 4
110715: PUSH
110716: LD_VAR 0 7
110720: ARRAY
110721: PPUSH
110722: CALL_OW 255
110726: PUSH
110727: EMPTY
110728: LIST
110729: LIST
110730: PPUSH
110731: CALL_OW 69
110735: IN
110736: PUSH
110737: LD_VAR 0 9
110741: PPUSH
110742: LD_VAR 0 4
110746: PUSH
110747: LD_VAR 0 7
110751: ARRAY
110752: PPUSH
110753: CALL_OW 296
110757: PUSH
110758: LD_INT 5
110760: LESS
110761: AND
110762: IFFALSE 110779
// ComAutodestruct ( group [ i ] ) ;
110764: LD_VAR 0 4
110768: PUSH
110769: LD_VAR 0 7
110773: ARRAY
110774: PPUSH
110775: CALL 47762 0 1
// end ; if f_attack_depot then
110779: LD_VAR 0 25
110783: IFFALSE 110895
// begin k := 6 ;
110785: LD_ADDR_VAR 0 9
110789: PUSH
110790: LD_INT 6
110792: ST_TO_ADDR
// if tmp < k then
110793: LD_VAR 0 14
110797: PUSH
110798: LD_VAR 0 9
110802: LESS
110803: IFFALSE 110815
// k := tmp ;
110805: LD_ADDR_VAR 0 9
110809: PUSH
110810: LD_VAR 0 14
110814: ST_TO_ADDR
// for j = 1 to k do
110815: LD_ADDR_VAR 0 8
110819: PUSH
110820: DOUBLE
110821: LD_INT 1
110823: DEC
110824: ST_TO_ADDR
110825: LD_VAR 0 9
110829: PUSH
110830: FOR_TO
110831: IFFALSE 110893
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
110833: LD_VAR 0 8
110837: PPUSH
110838: CALL_OW 266
110842: PUSH
110843: LD_INT 0
110845: PUSH
110846: LD_INT 1
110848: PUSH
110849: EMPTY
110850: LIST
110851: LIST
110852: IN
110853: IFFALSE 110891
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110855: LD_VAR 0 4
110859: PUSH
110860: LD_VAR 0 7
110864: ARRAY
110865: PPUSH
110866: LD_VAR 0 14
110870: PUSH
110871: LD_VAR 0 8
110875: ARRAY
110876: PPUSH
110877: CALL_OW 115
// attacking := true ;
110881: LD_ADDR_VAR 0 29
110885: PUSH
110886: LD_INT 1
110888: ST_TO_ADDR
// break ;
110889: GO 110893
// end ;
110891: GO 110830
110893: POP
110894: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
110895: LD_VAR 0 4
110899: PUSH
110900: LD_VAR 0 7
110904: ARRAY
110905: PPUSH
110906: CALL_OW 302
110910: PUSH
110911: LD_VAR 0 29
110915: NOT
110916: AND
110917: IFFALSE 111239
// begin if GetTag ( group [ i ] ) = 71 then
110919: LD_VAR 0 4
110923: PUSH
110924: LD_VAR 0 7
110928: ARRAY
110929: PPUSH
110930: CALL_OW 110
110934: PUSH
110935: LD_INT 71
110937: EQUAL
110938: IFFALSE 110979
// begin if HasTask ( group [ i ] ) then
110940: LD_VAR 0 4
110944: PUSH
110945: LD_VAR 0 7
110949: ARRAY
110950: PPUSH
110951: CALL_OW 314
110955: IFFALSE 110961
// continue else
110957: GO 107118
110959: GO 110979
// SetTag ( group [ i ] , 0 ) ;
110961: LD_VAR 0 4
110965: PUSH
110966: LD_VAR 0 7
110970: ARRAY
110971: PPUSH
110972: LD_INT 0
110974: PPUSH
110975: CALL_OW 109
// end ; k := 8 ;
110979: LD_ADDR_VAR 0 9
110983: PUSH
110984: LD_INT 8
110986: ST_TO_ADDR
// x := 0 ;
110987: LD_ADDR_VAR 0 10
110991: PUSH
110992: LD_INT 0
110994: ST_TO_ADDR
// if tmp < k then
110995: LD_VAR 0 14
110999: PUSH
111000: LD_VAR 0 9
111004: LESS
111005: IFFALSE 111017
// k := tmp ;
111007: LD_ADDR_VAR 0 9
111011: PUSH
111012: LD_VAR 0 14
111016: ST_TO_ADDR
// for j = 1 to k do
111017: LD_ADDR_VAR 0 8
111021: PUSH
111022: DOUBLE
111023: LD_INT 1
111025: DEC
111026: ST_TO_ADDR
111027: LD_VAR 0 9
111031: PUSH
111032: FOR_TO
111033: IFFALSE 111131
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
111035: LD_VAR 0 14
111039: PUSH
111040: LD_VAR 0 8
111044: ARRAY
111045: PPUSH
111046: CALL_OW 247
111050: PUSH
111051: LD_INT 1
111053: EQUAL
111054: PUSH
111055: LD_VAR 0 14
111059: PUSH
111060: LD_VAR 0 8
111064: ARRAY
111065: PPUSH
111066: CALL_OW 256
111070: PUSH
111071: LD_INT 250
111073: LESS
111074: PUSH
111075: LD_VAR 0 20
111079: AND
111080: PUSH
111081: LD_VAR 0 20
111085: NOT
111086: PUSH
111087: LD_VAR 0 14
111091: PUSH
111092: LD_VAR 0 8
111096: ARRAY
111097: PPUSH
111098: CALL_OW 256
111102: PUSH
111103: LD_INT 250
111105: GREATEREQUAL
111106: AND
111107: OR
111108: AND
111109: IFFALSE 111129
// begin x := tmp [ j ] ;
111111: LD_ADDR_VAR 0 10
111115: PUSH
111116: LD_VAR 0 14
111120: PUSH
111121: LD_VAR 0 8
111125: ARRAY
111126: ST_TO_ADDR
// break ;
111127: GO 111131
// end ;
111129: GO 111032
111131: POP
111132: POP
// if x then
111133: LD_VAR 0 10
111137: IFFALSE 111161
// ComAttackUnit ( group [ i ] , x ) else
111139: LD_VAR 0 4
111143: PUSH
111144: LD_VAR 0 7
111148: ARRAY
111149: PPUSH
111150: LD_VAR 0 10
111154: PPUSH
111155: CALL_OW 115
111159: GO 111185
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111161: LD_VAR 0 4
111165: PUSH
111166: LD_VAR 0 7
111170: ARRAY
111171: PPUSH
111172: LD_VAR 0 14
111176: PUSH
111177: LD_INT 1
111179: ARRAY
111180: PPUSH
111181: CALL_OW 115
// if not HasTask ( group [ i ] ) then
111185: LD_VAR 0 4
111189: PUSH
111190: LD_VAR 0 7
111194: ARRAY
111195: PPUSH
111196: CALL_OW 314
111200: NOT
111201: IFFALSE 111239
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
111203: LD_VAR 0 4
111207: PUSH
111208: LD_VAR 0 7
111212: ARRAY
111213: PPUSH
111214: LD_VAR 0 14
111218: PPUSH
111219: LD_VAR 0 4
111223: PUSH
111224: LD_VAR 0 7
111228: ARRAY
111229: PPUSH
111230: CALL_OW 74
111234: PPUSH
111235: CALL_OW 115
// end ; end ; end ;
111239: GO 107118
111241: POP
111242: POP
// wait ( 0 0$2 ) ;
111243: LD_INT 70
111245: PPUSH
111246: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
111250: LD_VAR 0 4
111254: NOT
111255: PUSH
111256: LD_VAR 0 4
111260: PUSH
111261: EMPTY
111262: EQUAL
111263: OR
111264: PUSH
111265: LD_INT 81
111267: PUSH
111268: LD_VAR 0 35
111272: PUSH
111273: EMPTY
111274: LIST
111275: LIST
111276: PPUSH
111277: CALL_OW 69
111281: NOT
111282: OR
111283: IFFALSE 107103
// end ;
111285: LD_VAR 0 2
111289: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
111290: LD_INT 0
111292: PPUSH
111293: PPUSH
111294: PPUSH
111295: PPUSH
111296: PPUSH
111297: PPUSH
// if not base or not mc_bases [ base ] or not solds then
111298: LD_VAR 0 1
111302: NOT
111303: PUSH
111304: LD_EXP 60
111308: PUSH
111309: LD_VAR 0 1
111313: ARRAY
111314: NOT
111315: OR
111316: PUSH
111317: LD_VAR 0 2
111321: NOT
111322: OR
111323: IFFALSE 111327
// exit ;
111325: GO 111881
// side := mc_sides [ base ] ;
111327: LD_ADDR_VAR 0 6
111331: PUSH
111332: LD_EXP 86
111336: PUSH
111337: LD_VAR 0 1
111341: ARRAY
111342: ST_TO_ADDR
// if not side then
111343: LD_VAR 0 6
111347: NOT
111348: IFFALSE 111352
// exit ;
111350: GO 111881
// for i in solds do
111352: LD_ADDR_VAR 0 7
111356: PUSH
111357: LD_VAR 0 2
111361: PUSH
111362: FOR_IN
111363: IFFALSE 111424
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
111365: LD_VAR 0 7
111369: PPUSH
111370: CALL_OW 310
111374: PPUSH
111375: CALL_OW 266
111379: PUSH
111380: LD_INT 32
111382: PUSH
111383: LD_INT 31
111385: PUSH
111386: EMPTY
111387: LIST
111388: LIST
111389: IN
111390: IFFALSE 111410
// solds := solds diff i else
111392: LD_ADDR_VAR 0 2
111396: PUSH
111397: LD_VAR 0 2
111401: PUSH
111402: LD_VAR 0 7
111406: DIFF
111407: ST_TO_ADDR
111408: GO 111422
// SetTag ( i , 18 ) ;
111410: LD_VAR 0 7
111414: PPUSH
111415: LD_INT 18
111417: PPUSH
111418: CALL_OW 109
111422: GO 111362
111424: POP
111425: POP
// if not solds then
111426: LD_VAR 0 2
111430: NOT
111431: IFFALSE 111435
// exit ;
111433: GO 111881
// repeat wait ( 0 0$2 ) ;
111435: LD_INT 70
111437: PPUSH
111438: CALL_OW 67
// enemy := mc_scan [ base ] ;
111442: LD_ADDR_VAR 0 4
111446: PUSH
111447: LD_EXP 83
111451: PUSH
111452: LD_VAR 0 1
111456: ARRAY
111457: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111458: LD_EXP 60
111462: PUSH
111463: LD_VAR 0 1
111467: ARRAY
111468: NOT
111469: PUSH
111470: LD_EXP 60
111474: PUSH
111475: LD_VAR 0 1
111479: ARRAY
111480: PUSH
111481: EMPTY
111482: EQUAL
111483: OR
111484: IFFALSE 111521
// begin for i in solds do
111486: LD_ADDR_VAR 0 7
111490: PUSH
111491: LD_VAR 0 2
111495: PUSH
111496: FOR_IN
111497: IFFALSE 111510
// ComStop ( i ) ;
111499: LD_VAR 0 7
111503: PPUSH
111504: CALL_OW 141
111508: GO 111496
111510: POP
111511: POP
// solds := [ ] ;
111512: LD_ADDR_VAR 0 2
111516: PUSH
111517: EMPTY
111518: ST_TO_ADDR
// exit ;
111519: GO 111881
// end ; for i in solds do
111521: LD_ADDR_VAR 0 7
111525: PUSH
111526: LD_VAR 0 2
111530: PUSH
111531: FOR_IN
111532: IFFALSE 111853
// begin if IsInUnit ( i ) then
111534: LD_VAR 0 7
111538: PPUSH
111539: CALL_OW 310
111543: IFFALSE 111554
// ComExitBuilding ( i ) ;
111545: LD_VAR 0 7
111549: PPUSH
111550: CALL_OW 122
// if GetLives ( i ) > 500 then
111554: LD_VAR 0 7
111558: PPUSH
111559: CALL_OW 256
111563: PUSH
111564: LD_INT 500
111566: GREATER
111567: IFFALSE 111620
// begin e := NearestUnitToUnit ( enemy , i ) ;
111569: LD_ADDR_VAR 0 5
111573: PUSH
111574: LD_VAR 0 4
111578: PPUSH
111579: LD_VAR 0 7
111583: PPUSH
111584: CALL_OW 74
111588: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
111589: LD_VAR 0 7
111593: PPUSH
111594: LD_VAR 0 5
111598: PPUSH
111599: CALL_OW 250
111603: PPUSH
111604: LD_VAR 0 5
111608: PPUSH
111609: CALL_OW 251
111613: PPUSH
111614: CALL_OW 114
// end else
111618: GO 111851
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
111620: LD_VAR 0 7
111624: PPUSH
111625: LD_EXP 60
111629: PUSH
111630: LD_VAR 0 1
111634: ARRAY
111635: PPUSH
111636: LD_INT 2
111638: PUSH
111639: LD_INT 30
111641: PUSH
111642: LD_INT 0
111644: PUSH
111645: EMPTY
111646: LIST
111647: LIST
111648: PUSH
111649: LD_INT 30
111651: PUSH
111652: LD_INT 1
111654: PUSH
111655: EMPTY
111656: LIST
111657: LIST
111658: PUSH
111659: LD_INT 30
111661: PUSH
111662: LD_INT 6
111664: PUSH
111665: EMPTY
111666: LIST
111667: LIST
111668: PUSH
111669: EMPTY
111670: LIST
111671: LIST
111672: LIST
111673: LIST
111674: PPUSH
111675: CALL_OW 72
111679: PPUSH
111680: LD_VAR 0 7
111684: PPUSH
111685: CALL_OW 74
111689: PPUSH
111690: CALL_OW 296
111694: PUSH
111695: LD_INT 10
111697: GREATER
111698: IFFALSE 111851
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
111700: LD_ADDR_VAR 0 8
111704: PUSH
111705: LD_EXP 60
111709: PUSH
111710: LD_VAR 0 1
111714: ARRAY
111715: PPUSH
111716: LD_INT 2
111718: PUSH
111719: LD_INT 30
111721: PUSH
111722: LD_INT 0
111724: PUSH
111725: EMPTY
111726: LIST
111727: LIST
111728: PUSH
111729: LD_INT 30
111731: PUSH
111732: LD_INT 1
111734: PUSH
111735: EMPTY
111736: LIST
111737: LIST
111738: PUSH
111739: LD_INT 30
111741: PUSH
111742: LD_INT 6
111744: PUSH
111745: EMPTY
111746: LIST
111747: LIST
111748: PUSH
111749: EMPTY
111750: LIST
111751: LIST
111752: LIST
111753: LIST
111754: PPUSH
111755: CALL_OW 72
111759: PPUSH
111760: LD_VAR 0 7
111764: PPUSH
111765: CALL_OW 74
111769: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
111770: LD_VAR 0 7
111774: PPUSH
111775: LD_VAR 0 8
111779: PPUSH
111780: CALL_OW 250
111784: PPUSH
111785: LD_INT 3
111787: PPUSH
111788: LD_INT 5
111790: PPUSH
111791: CALL_OW 272
111795: PPUSH
111796: LD_VAR 0 8
111800: PPUSH
111801: CALL_OW 251
111805: PPUSH
111806: LD_INT 3
111808: PPUSH
111809: LD_INT 5
111811: PPUSH
111812: CALL_OW 273
111816: PPUSH
111817: CALL_OW 111
// SetTag ( i , 0 ) ;
111821: LD_VAR 0 7
111825: PPUSH
111826: LD_INT 0
111828: PPUSH
111829: CALL_OW 109
// solds := solds diff i ;
111833: LD_ADDR_VAR 0 2
111837: PUSH
111838: LD_VAR 0 2
111842: PUSH
111843: LD_VAR 0 7
111847: DIFF
111848: ST_TO_ADDR
// continue ;
111849: GO 111531
// end ; end ;
111851: GO 111531
111853: POP
111854: POP
// until not solds or not enemy ;
111855: LD_VAR 0 2
111859: NOT
111860: PUSH
111861: LD_VAR 0 4
111865: NOT
111866: OR
111867: IFFALSE 111435
// MC_Reset ( base , 18 ) ;
111869: LD_VAR 0 1
111873: PPUSH
111874: LD_INT 18
111876: PPUSH
111877: CALL 60193 0 2
// end ;
111881: LD_VAR 0 3
111885: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
111886: LD_INT 0
111888: PPUSH
111889: PPUSH
111890: PPUSH
111891: PPUSH
111892: PPUSH
111893: PPUSH
111894: PPUSH
111895: PPUSH
111896: PPUSH
111897: PPUSH
111898: PPUSH
111899: PPUSH
111900: PPUSH
111901: PPUSH
111902: PPUSH
111903: PPUSH
111904: PPUSH
111905: PPUSH
111906: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
111907: LD_ADDR_VAR 0 12
111911: PUSH
111912: LD_EXP 60
111916: PUSH
111917: LD_VAR 0 1
111921: ARRAY
111922: PPUSH
111923: LD_INT 25
111925: PUSH
111926: LD_INT 3
111928: PUSH
111929: EMPTY
111930: LIST
111931: LIST
111932: PPUSH
111933: CALL_OW 72
111937: ST_TO_ADDR
// if mc_remote_driver [ base ] then
111938: LD_EXP 100
111942: PUSH
111943: LD_VAR 0 1
111947: ARRAY
111948: IFFALSE 111972
// mechs := mechs diff mc_remote_driver [ base ] ;
111950: LD_ADDR_VAR 0 12
111954: PUSH
111955: LD_VAR 0 12
111959: PUSH
111960: LD_EXP 100
111964: PUSH
111965: LD_VAR 0 1
111969: ARRAY
111970: DIFF
111971: ST_TO_ADDR
// for i in mechs do
111972: LD_ADDR_VAR 0 4
111976: PUSH
111977: LD_VAR 0 12
111981: PUSH
111982: FOR_IN
111983: IFFALSE 112018
// if GetTag ( i ) > 0 then
111985: LD_VAR 0 4
111989: PPUSH
111990: CALL_OW 110
111994: PUSH
111995: LD_INT 0
111997: GREATER
111998: IFFALSE 112016
// mechs := mechs diff i ;
112000: LD_ADDR_VAR 0 12
112004: PUSH
112005: LD_VAR 0 12
112009: PUSH
112010: LD_VAR 0 4
112014: DIFF
112015: ST_TO_ADDR
112016: GO 111982
112018: POP
112019: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112020: LD_ADDR_VAR 0 8
112024: PUSH
112025: LD_EXP 60
112029: PUSH
112030: LD_VAR 0 1
112034: ARRAY
112035: PPUSH
112036: LD_INT 2
112038: PUSH
112039: LD_INT 25
112041: PUSH
112042: LD_INT 1
112044: PUSH
112045: EMPTY
112046: LIST
112047: LIST
112048: PUSH
112049: LD_INT 25
112051: PUSH
112052: LD_INT 5
112054: PUSH
112055: EMPTY
112056: LIST
112057: LIST
112058: PUSH
112059: LD_INT 25
112061: PUSH
112062: LD_INT 8
112064: PUSH
112065: EMPTY
112066: LIST
112067: LIST
112068: PUSH
112069: LD_INT 25
112071: PUSH
112072: LD_INT 9
112074: PUSH
112075: EMPTY
112076: LIST
112077: LIST
112078: PUSH
112079: EMPTY
112080: LIST
112081: LIST
112082: LIST
112083: LIST
112084: LIST
112085: PPUSH
112086: CALL_OW 72
112090: ST_TO_ADDR
// if not defenders and not solds then
112091: LD_VAR 0 2
112095: NOT
112096: PUSH
112097: LD_VAR 0 8
112101: NOT
112102: AND
112103: IFFALSE 112107
// exit ;
112105: GO 113877
// depot_under_attack := false ;
112107: LD_ADDR_VAR 0 16
112111: PUSH
112112: LD_INT 0
112114: ST_TO_ADDR
// sold_defenders := [ ] ;
112115: LD_ADDR_VAR 0 17
112119: PUSH
112120: EMPTY
112121: ST_TO_ADDR
// if mechs then
112122: LD_VAR 0 12
112126: IFFALSE 112279
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
112128: LD_ADDR_VAR 0 4
112132: PUSH
112133: LD_VAR 0 2
112137: PPUSH
112138: LD_INT 21
112140: PUSH
112141: LD_INT 2
112143: PUSH
112144: EMPTY
112145: LIST
112146: LIST
112147: PPUSH
112148: CALL_OW 72
112152: PUSH
112153: FOR_IN
112154: IFFALSE 112277
// begin if GetTag ( i ) <> 20 then
112156: LD_VAR 0 4
112160: PPUSH
112161: CALL_OW 110
112165: PUSH
112166: LD_INT 20
112168: NONEQUAL
112169: IFFALSE 112183
// SetTag ( i , 20 ) ;
112171: LD_VAR 0 4
112175: PPUSH
112176: LD_INT 20
112178: PPUSH
112179: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
112183: LD_VAR 0 4
112187: PPUSH
112188: CALL_OW 263
112192: PUSH
112193: LD_INT 1
112195: EQUAL
112196: PUSH
112197: LD_VAR 0 4
112201: PPUSH
112202: CALL_OW 311
112206: NOT
112207: AND
112208: IFFALSE 112275
// begin un := mechs [ 1 ] ;
112210: LD_ADDR_VAR 0 10
112214: PUSH
112215: LD_VAR 0 12
112219: PUSH
112220: LD_INT 1
112222: ARRAY
112223: ST_TO_ADDR
// ComExit ( un ) ;
112224: LD_VAR 0 10
112228: PPUSH
112229: CALL 52628 0 1
// AddComEnterUnit ( un , i ) ;
112233: LD_VAR 0 10
112237: PPUSH
112238: LD_VAR 0 4
112242: PPUSH
112243: CALL_OW 180
// SetTag ( un , 19 ) ;
112247: LD_VAR 0 10
112251: PPUSH
112252: LD_INT 19
112254: PPUSH
112255: CALL_OW 109
// mechs := mechs diff un ;
112259: LD_ADDR_VAR 0 12
112263: PUSH
112264: LD_VAR 0 12
112268: PUSH
112269: LD_VAR 0 10
112273: DIFF
112274: ST_TO_ADDR
// end ; end ;
112275: GO 112153
112277: POP
112278: POP
// if solds then
112279: LD_VAR 0 8
112283: IFFALSE 112342
// for i in solds do
112285: LD_ADDR_VAR 0 4
112289: PUSH
112290: LD_VAR 0 8
112294: PUSH
112295: FOR_IN
112296: IFFALSE 112340
// if not GetTag ( i ) then
112298: LD_VAR 0 4
112302: PPUSH
112303: CALL_OW 110
112307: NOT
112308: IFFALSE 112338
// begin defenders := defenders union i ;
112310: LD_ADDR_VAR 0 2
112314: PUSH
112315: LD_VAR 0 2
112319: PUSH
112320: LD_VAR 0 4
112324: UNION
112325: ST_TO_ADDR
// SetTag ( i , 18 ) ;
112326: LD_VAR 0 4
112330: PPUSH
112331: LD_INT 18
112333: PPUSH
112334: CALL_OW 109
// end ;
112338: GO 112295
112340: POP
112341: POP
// repeat wait ( 0 0$2 ) ;
112342: LD_INT 70
112344: PPUSH
112345: CALL_OW 67
// enemy := mc_scan [ base ] ;
112349: LD_ADDR_VAR 0 21
112353: PUSH
112354: LD_EXP 83
112358: PUSH
112359: LD_VAR 0 1
112363: ARRAY
112364: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112365: LD_EXP 60
112369: PUSH
112370: LD_VAR 0 1
112374: ARRAY
112375: NOT
112376: PUSH
112377: LD_EXP 60
112381: PUSH
112382: LD_VAR 0 1
112386: ARRAY
112387: PUSH
112388: EMPTY
112389: EQUAL
112390: OR
112391: IFFALSE 112428
// begin for i in defenders do
112393: LD_ADDR_VAR 0 4
112397: PUSH
112398: LD_VAR 0 2
112402: PUSH
112403: FOR_IN
112404: IFFALSE 112417
// ComStop ( i ) ;
112406: LD_VAR 0 4
112410: PPUSH
112411: CALL_OW 141
112415: GO 112403
112417: POP
112418: POP
// defenders := [ ] ;
112419: LD_ADDR_VAR 0 2
112423: PUSH
112424: EMPTY
112425: ST_TO_ADDR
// exit ;
112426: GO 113877
// end ; for i in defenders do
112428: LD_ADDR_VAR 0 4
112432: PUSH
112433: LD_VAR 0 2
112437: PUSH
112438: FOR_IN
112439: IFFALSE 113337
// begin e := NearestUnitToUnit ( enemy , i ) ;
112441: LD_ADDR_VAR 0 13
112445: PUSH
112446: LD_VAR 0 21
112450: PPUSH
112451: LD_VAR 0 4
112455: PPUSH
112456: CALL_OW 74
112460: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
112461: LD_ADDR_VAR 0 7
112465: PUSH
112466: LD_EXP 60
112470: PUSH
112471: LD_VAR 0 1
112475: ARRAY
112476: PPUSH
112477: LD_INT 2
112479: PUSH
112480: LD_INT 30
112482: PUSH
112483: LD_INT 0
112485: PUSH
112486: EMPTY
112487: LIST
112488: LIST
112489: PUSH
112490: LD_INT 30
112492: PUSH
112493: LD_INT 1
112495: PUSH
112496: EMPTY
112497: LIST
112498: LIST
112499: PUSH
112500: EMPTY
112501: LIST
112502: LIST
112503: LIST
112504: PPUSH
112505: CALL_OW 72
112509: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
112510: LD_ADDR_VAR 0 16
112514: PUSH
112515: LD_VAR 0 7
112519: NOT
112520: PUSH
112521: LD_VAR 0 7
112525: PPUSH
112526: LD_INT 3
112528: PUSH
112529: LD_INT 24
112531: PUSH
112532: LD_INT 600
112534: PUSH
112535: EMPTY
112536: LIST
112537: LIST
112538: PUSH
112539: EMPTY
112540: LIST
112541: LIST
112542: PPUSH
112543: CALL_OW 72
112547: OR
112548: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
112549: LD_VAR 0 4
112553: PPUSH
112554: CALL_OW 247
112558: PUSH
112559: LD_INT 2
112561: DOUBLE
112562: EQUAL
112563: IFTRUE 112567
112565: GO 112963
112567: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
112568: LD_VAR 0 4
112572: PPUSH
112573: CALL_OW 256
112577: PUSH
112578: LD_INT 1000
112580: EQUAL
112581: PUSH
112582: LD_VAR 0 4
112586: PPUSH
112587: LD_VAR 0 13
112591: PPUSH
112592: CALL_OW 296
112596: PUSH
112597: LD_INT 40
112599: LESS
112600: PUSH
112601: LD_VAR 0 13
112605: PPUSH
112606: LD_EXP 85
112610: PUSH
112611: LD_VAR 0 1
112615: ARRAY
112616: PPUSH
112617: CALL_OW 308
112621: OR
112622: AND
112623: IFFALSE 112745
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
112625: LD_VAR 0 4
112629: PPUSH
112630: CALL_OW 262
112634: PUSH
112635: LD_INT 1
112637: EQUAL
112638: PUSH
112639: LD_VAR 0 4
112643: PPUSH
112644: CALL_OW 261
112648: PUSH
112649: LD_INT 30
112651: LESS
112652: AND
112653: PUSH
112654: LD_VAR 0 7
112658: AND
112659: IFFALSE 112729
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
112661: LD_VAR 0 4
112665: PPUSH
112666: LD_VAR 0 7
112670: PPUSH
112671: LD_VAR 0 4
112675: PPUSH
112676: CALL_OW 74
112680: PPUSH
112681: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
112685: LD_VAR 0 4
112689: PPUSH
112690: LD_VAR 0 7
112694: PPUSH
112695: LD_VAR 0 4
112699: PPUSH
112700: CALL_OW 74
112704: PPUSH
112705: CALL_OW 296
112709: PUSH
112710: LD_INT 6
112712: LESS
112713: IFFALSE 112727
// SetFuel ( i , 100 ) ;
112715: LD_VAR 0 4
112719: PPUSH
112720: LD_INT 100
112722: PPUSH
112723: CALL_OW 240
// end else
112727: GO 112743
// ComAttackUnit ( i , e ) ;
112729: LD_VAR 0 4
112733: PPUSH
112734: LD_VAR 0 13
112738: PPUSH
112739: CALL_OW 115
// end else
112743: GO 112846
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
112745: LD_VAR 0 13
112749: PPUSH
112750: LD_EXP 85
112754: PUSH
112755: LD_VAR 0 1
112759: ARRAY
112760: PPUSH
112761: CALL_OW 308
112765: NOT
112766: PUSH
112767: LD_VAR 0 4
112771: PPUSH
112772: LD_VAR 0 13
112776: PPUSH
112777: CALL_OW 296
112781: PUSH
112782: LD_INT 40
112784: GREATEREQUAL
112785: AND
112786: PUSH
112787: LD_VAR 0 4
112791: PPUSH
112792: CALL_OW 256
112796: PUSH
112797: LD_INT 650
112799: LESSEQUAL
112800: OR
112801: PUSH
112802: LD_VAR 0 4
112806: PPUSH
112807: LD_EXP 84
112811: PUSH
112812: LD_VAR 0 1
112816: ARRAY
112817: PPUSH
112818: CALL_OW 308
112822: NOT
112823: AND
112824: IFFALSE 112846
// ComMoveToArea ( i , mc_parking [ base ] ) ;
112826: LD_VAR 0 4
112830: PPUSH
112831: LD_EXP 84
112835: PUSH
112836: LD_VAR 0 1
112840: ARRAY
112841: PPUSH
112842: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
112846: LD_VAR 0 4
112850: PPUSH
112851: CALL_OW 256
112855: PUSH
112856: LD_INT 1000
112858: LESS
112859: PUSH
112860: LD_VAR 0 4
112864: PPUSH
112865: CALL_OW 263
112869: PUSH
112870: LD_INT 1
112872: EQUAL
112873: AND
112874: PUSH
112875: LD_VAR 0 4
112879: PPUSH
112880: CALL_OW 311
112884: AND
112885: PUSH
112886: LD_VAR 0 4
112890: PPUSH
112891: LD_EXP 84
112895: PUSH
112896: LD_VAR 0 1
112900: ARRAY
112901: PPUSH
112902: CALL_OW 308
112906: AND
112907: IFFALSE 112961
// begin mech := IsDrivenBy ( i ) ;
112909: LD_ADDR_VAR 0 9
112913: PUSH
112914: LD_VAR 0 4
112918: PPUSH
112919: CALL_OW 311
112923: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
112924: LD_VAR 0 9
112928: PPUSH
112929: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
112933: LD_VAR 0 9
112937: PPUSH
112938: LD_VAR 0 4
112942: PPUSH
112943: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
112947: LD_VAR 0 9
112951: PPUSH
112952: LD_VAR 0 4
112956: PPUSH
112957: CALL_OW 180
// end ; end ; unit_human :
112961: GO 113308
112963: LD_INT 1
112965: DOUBLE
112966: EQUAL
112967: IFTRUE 112971
112969: GO 113307
112971: POP
// begin b := IsInUnit ( i ) ;
112972: LD_ADDR_VAR 0 18
112976: PUSH
112977: LD_VAR 0 4
112981: PPUSH
112982: CALL_OW 310
112986: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
112987: LD_ADDR_VAR 0 19
112991: PUSH
112992: LD_VAR 0 18
112996: NOT
112997: PUSH
112998: LD_VAR 0 18
113002: PPUSH
113003: CALL_OW 266
113007: PUSH
113008: LD_INT 32
113010: PUSH
113011: LD_INT 31
113013: PUSH
113014: EMPTY
113015: LIST
113016: LIST
113017: IN
113018: OR
113019: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
113020: LD_VAR 0 18
113024: PPUSH
113025: CALL_OW 266
113029: PUSH
113030: LD_INT 5
113032: EQUAL
113033: PUSH
113034: LD_VAR 0 4
113038: PPUSH
113039: CALL_OW 257
113043: PUSH
113044: LD_INT 1
113046: PUSH
113047: LD_INT 2
113049: PUSH
113050: LD_INT 3
113052: PUSH
113053: LD_INT 4
113055: PUSH
113056: EMPTY
113057: LIST
113058: LIST
113059: LIST
113060: LIST
113061: IN
113062: AND
113063: IFFALSE 113100
// begin class := AllowSpecClass ( i ) ;
113065: LD_ADDR_VAR 0 20
113069: PUSH
113070: LD_VAR 0 4
113074: PPUSH
113075: CALL 16640 0 1
113079: ST_TO_ADDR
// if class then
113080: LD_VAR 0 20
113084: IFFALSE 113100
// ComChangeProfession ( i , class ) ;
113086: LD_VAR 0 4
113090: PPUSH
113091: LD_VAR 0 20
113095: PPUSH
113096: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
113100: LD_VAR 0 16
113104: PUSH
113105: LD_VAR 0 2
113109: PPUSH
113110: LD_INT 21
113112: PUSH
113113: LD_INT 2
113115: PUSH
113116: EMPTY
113117: LIST
113118: LIST
113119: PPUSH
113120: CALL_OW 72
113124: PUSH
113125: LD_INT 1
113127: LESSEQUAL
113128: OR
113129: PUSH
113130: LD_VAR 0 19
113134: AND
113135: PUSH
113136: LD_VAR 0 4
113140: PUSH
113141: LD_VAR 0 17
113145: IN
113146: NOT
113147: AND
113148: IFFALSE 113241
// begin if b then
113150: LD_VAR 0 18
113154: IFFALSE 113203
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
113156: LD_VAR 0 18
113160: PPUSH
113161: LD_VAR 0 21
113165: PPUSH
113166: LD_VAR 0 18
113170: PPUSH
113171: CALL_OW 74
113175: PPUSH
113176: CALL_OW 296
113180: PUSH
113181: LD_INT 10
113183: LESS
113184: PUSH
113185: LD_VAR 0 18
113189: PPUSH
113190: CALL_OW 461
113194: PUSH
113195: LD_INT 7
113197: NONEQUAL
113198: AND
113199: IFFALSE 113203
// continue ;
113201: GO 112438
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
113203: LD_ADDR_VAR 0 17
113207: PUSH
113208: LD_VAR 0 17
113212: PPUSH
113213: LD_VAR 0 17
113217: PUSH
113218: LD_INT 1
113220: PLUS
113221: PPUSH
113222: LD_VAR 0 4
113226: PPUSH
113227: CALL_OW 1
113231: ST_TO_ADDR
// ComExitBuilding ( i ) ;
113232: LD_VAR 0 4
113236: PPUSH
113237: CALL_OW 122
// end ; if sold_defenders then
113241: LD_VAR 0 17
113245: IFFALSE 113305
// if i in sold_defenders then
113247: LD_VAR 0 4
113251: PUSH
113252: LD_VAR 0 17
113256: IN
113257: IFFALSE 113305
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
113259: LD_VAR 0 4
113263: PPUSH
113264: CALL_OW 314
113268: NOT
113269: PUSH
113270: LD_VAR 0 4
113274: PPUSH
113275: LD_VAR 0 13
113279: PPUSH
113280: CALL_OW 296
113284: PUSH
113285: LD_INT 30
113287: LESS
113288: AND
113289: IFFALSE 113305
// ComAttackUnit ( i , e ) ;
113291: LD_VAR 0 4
113295: PPUSH
113296: LD_VAR 0 13
113300: PPUSH
113301: CALL_OW 115
// end ; end ; end ;
113305: GO 113308
113307: POP
// if IsDead ( i ) then
113308: LD_VAR 0 4
113312: PPUSH
113313: CALL_OW 301
113317: IFFALSE 113335
// defenders := defenders diff i ;
113319: LD_ADDR_VAR 0 2
113323: PUSH
113324: LD_VAR 0 2
113328: PUSH
113329: LD_VAR 0 4
113333: DIFF
113334: ST_TO_ADDR
// end ;
113335: GO 112438
113337: POP
113338: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
113339: LD_VAR 0 21
113343: NOT
113344: PUSH
113345: LD_VAR 0 2
113349: NOT
113350: OR
113351: PUSH
113352: LD_EXP 60
113356: PUSH
113357: LD_VAR 0 1
113361: ARRAY
113362: NOT
113363: OR
113364: IFFALSE 112342
// MC_Reset ( base , 18 ) ;
113366: LD_VAR 0 1
113370: PPUSH
113371: LD_INT 18
113373: PPUSH
113374: CALL 60193 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
113378: LD_ADDR_VAR 0 2
113382: PUSH
113383: LD_VAR 0 2
113387: PUSH
113388: LD_VAR 0 2
113392: PPUSH
113393: LD_INT 2
113395: PUSH
113396: LD_INT 25
113398: PUSH
113399: LD_INT 1
113401: PUSH
113402: EMPTY
113403: LIST
113404: LIST
113405: PUSH
113406: LD_INT 25
113408: PUSH
113409: LD_INT 5
113411: PUSH
113412: EMPTY
113413: LIST
113414: LIST
113415: PUSH
113416: LD_INT 25
113418: PUSH
113419: LD_INT 8
113421: PUSH
113422: EMPTY
113423: LIST
113424: LIST
113425: PUSH
113426: LD_INT 25
113428: PUSH
113429: LD_INT 9
113431: PUSH
113432: EMPTY
113433: LIST
113434: LIST
113435: PUSH
113436: EMPTY
113437: LIST
113438: LIST
113439: LIST
113440: LIST
113441: LIST
113442: PPUSH
113443: CALL_OW 72
113447: DIFF
113448: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
113449: LD_VAR 0 21
113453: NOT
113454: PUSH
113455: LD_VAR 0 2
113459: PPUSH
113460: LD_INT 21
113462: PUSH
113463: LD_INT 2
113465: PUSH
113466: EMPTY
113467: LIST
113468: LIST
113469: PPUSH
113470: CALL_OW 72
113474: AND
113475: IFFALSE 113813
// begin tmp := FilterByTag ( defenders , 19 ) ;
113477: LD_ADDR_VAR 0 11
113481: PUSH
113482: LD_VAR 0 2
113486: PPUSH
113487: LD_INT 19
113489: PPUSH
113490: CALL 49804 0 2
113494: ST_TO_ADDR
// if tmp then
113495: LD_VAR 0 11
113499: IFFALSE 113569
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
113501: LD_ADDR_VAR 0 11
113505: PUSH
113506: LD_VAR 0 11
113510: PPUSH
113511: LD_INT 25
113513: PUSH
113514: LD_INT 3
113516: PUSH
113517: EMPTY
113518: LIST
113519: LIST
113520: PPUSH
113521: CALL_OW 72
113525: ST_TO_ADDR
// if tmp then
113526: LD_VAR 0 11
113530: IFFALSE 113569
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
113532: LD_ADDR_EXP 72
113536: PUSH
113537: LD_EXP 72
113541: PPUSH
113542: LD_VAR 0 1
113546: PPUSH
113547: LD_EXP 72
113551: PUSH
113552: LD_VAR 0 1
113556: ARRAY
113557: PUSH
113558: LD_VAR 0 11
113562: UNION
113563: PPUSH
113564: CALL_OW 1
113568: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
113569: LD_VAR 0 1
113573: PPUSH
113574: LD_INT 19
113576: PPUSH
113577: CALL 60193 0 2
// repeat wait ( 0 0$1 ) ;
113581: LD_INT 35
113583: PPUSH
113584: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113588: LD_EXP 60
113592: PUSH
113593: LD_VAR 0 1
113597: ARRAY
113598: NOT
113599: PUSH
113600: LD_EXP 60
113604: PUSH
113605: LD_VAR 0 1
113609: ARRAY
113610: PUSH
113611: EMPTY
113612: EQUAL
113613: OR
113614: IFFALSE 113651
// begin for i in defenders do
113616: LD_ADDR_VAR 0 4
113620: PUSH
113621: LD_VAR 0 2
113625: PUSH
113626: FOR_IN
113627: IFFALSE 113640
// ComStop ( i ) ;
113629: LD_VAR 0 4
113633: PPUSH
113634: CALL_OW 141
113638: GO 113626
113640: POP
113641: POP
// defenders := [ ] ;
113642: LD_ADDR_VAR 0 2
113646: PUSH
113647: EMPTY
113648: ST_TO_ADDR
// exit ;
113649: GO 113877
// end ; for i in defenders do
113651: LD_ADDR_VAR 0 4
113655: PUSH
113656: LD_VAR 0 2
113660: PUSH
113661: FOR_IN
113662: IFFALSE 113751
// begin if not IsInArea ( i , mc_parking [ base ] ) then
113664: LD_VAR 0 4
113668: PPUSH
113669: LD_EXP 84
113673: PUSH
113674: LD_VAR 0 1
113678: ARRAY
113679: PPUSH
113680: CALL_OW 308
113684: NOT
113685: IFFALSE 113709
// ComMoveToArea ( i , mc_parking [ base ] ) else
113687: LD_VAR 0 4
113691: PPUSH
113692: LD_EXP 84
113696: PUSH
113697: LD_VAR 0 1
113701: ARRAY
113702: PPUSH
113703: CALL_OW 113
113707: GO 113749
// if GetControl ( i ) = control_manual then
113709: LD_VAR 0 4
113713: PPUSH
113714: CALL_OW 263
113718: PUSH
113719: LD_INT 1
113721: EQUAL
113722: IFFALSE 113749
// if IsDrivenBy ( i ) then
113724: LD_VAR 0 4
113728: PPUSH
113729: CALL_OW 311
113733: IFFALSE 113749
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
113735: LD_VAR 0 4
113739: PPUSH
113740: CALL_OW 311
113744: PPUSH
113745: CALL_OW 121
// end ;
113749: GO 113661
113751: POP
113752: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
113753: LD_VAR 0 2
113757: PPUSH
113758: LD_INT 95
113760: PUSH
113761: LD_EXP 84
113765: PUSH
113766: LD_VAR 0 1
113770: ARRAY
113771: PUSH
113772: EMPTY
113773: LIST
113774: LIST
113775: PPUSH
113776: CALL_OW 72
113780: PUSH
113781: LD_VAR 0 2
113785: EQUAL
113786: PUSH
113787: LD_EXP 83
113791: PUSH
113792: LD_VAR 0 1
113796: ARRAY
113797: OR
113798: PUSH
113799: LD_EXP 60
113803: PUSH
113804: LD_VAR 0 1
113808: ARRAY
113809: NOT
113810: OR
113811: IFFALSE 113581
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
113813: LD_ADDR_EXP 82
113817: PUSH
113818: LD_EXP 82
113822: PPUSH
113823: LD_VAR 0 1
113827: PPUSH
113828: LD_VAR 0 2
113832: PPUSH
113833: LD_INT 21
113835: PUSH
113836: LD_INT 2
113838: PUSH
113839: EMPTY
113840: LIST
113841: LIST
113842: PPUSH
113843: CALL_OW 72
113847: PPUSH
113848: CALL_OW 1
113852: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
113853: LD_VAR 0 1
113857: PPUSH
113858: LD_INT 19
113860: PPUSH
113861: CALL 60193 0 2
// MC_Reset ( base , 20 ) ;
113865: LD_VAR 0 1
113869: PPUSH
113870: LD_INT 20
113872: PPUSH
113873: CALL 60193 0 2
// end ; end_of_file
113877: LD_VAR 0 3
113881: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
113882: LD_VAR 0 1
113886: PUSH
113887: LD_INT 200
113889: DOUBLE
113890: GREATEREQUAL
113891: IFFALSE 113899
113893: LD_INT 299
113895: DOUBLE
113896: LESSEQUAL
113897: IFTRUE 113901
113899: GO 113933
113901: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
113902: LD_VAR 0 1
113906: PPUSH
113907: LD_VAR 0 2
113911: PPUSH
113912: LD_VAR 0 3
113916: PPUSH
113917: LD_VAR 0 4
113921: PPUSH
113922: LD_VAR 0 5
113926: PPUSH
113927: CALL 102668 0 5
113931: GO 114010
113933: LD_INT 300
113935: DOUBLE
113936: GREATEREQUAL
113937: IFFALSE 113945
113939: LD_INT 399
113941: DOUBLE
113942: LESSEQUAL
113943: IFTRUE 113947
113945: GO 114009
113947: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
113948: LD_VAR 0 1
113952: PPUSH
113953: LD_VAR 0 2
113957: PPUSH
113958: LD_VAR 0 3
113962: PPUSH
113963: LD_VAR 0 4
113967: PPUSH
113968: LD_VAR 0 5
113972: PPUSH
113973: LD_VAR 0 6
113977: PPUSH
113978: LD_VAR 0 7
113982: PPUSH
113983: LD_VAR 0 8
113987: PPUSH
113988: LD_VAR 0 9
113992: PPUSH
113993: LD_VAR 0 10
113997: PPUSH
113998: LD_VAR 0 11
114002: PPUSH
114003: CALL 99001 0 11
114007: GO 114010
114009: POP
// end ;
114010: PPOPN 11
114012: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
114013: LD_VAR 0 1
114017: PPUSH
114018: LD_VAR 0 2
114022: PPUSH
114023: LD_VAR 0 3
114027: PPUSH
114028: LD_VAR 0 4
114032: PPUSH
114033: LD_VAR 0 5
114037: PPUSH
114038: CALL 102404 0 5
// end ; end_of_file
114042: PPOPN 5
114044: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
114045: LD_VAR 0 1
114049: PPUSH
114050: LD_VAR 0 2
114054: PPUSH
114055: LD_VAR 0 3
114059: PPUSH
114060: LD_VAR 0 4
114064: PPUSH
114065: LD_VAR 0 5
114069: PPUSH
114070: LD_VAR 0 6
114074: PPUSH
114075: CALL 86694 0 6
// end ;
114079: PPOPN 6
114081: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
114082: LD_INT 0
114084: PPUSH
// begin if not units then
114085: LD_VAR 0 1
114089: NOT
114090: IFFALSE 114094
// exit ;
114092: GO 114094
// end ;
114094: PPOPN 7
114096: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
114097: CALL 86665 0 0
// end ;
114101: PPOPN 1
114103: END
