// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 619 0 0
// InitMacro ;
  19: CALL 51104 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 46907 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 46907 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 46907 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 46907 0 9
// PrepareArabian ;
 147: CALL 3690 0 0
// PrepareRussian ;
 151: CALL 2825 0 0
// PrepareAlliance ;
 155: CALL 821 0 0
// MC_Start ( ) ;
 159: CALL 53216 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6853 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 83
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 84
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 74417 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 54
 252: PPUSH
 253: CALL 74843 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 75301 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 75570 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 74783 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 75477 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 51
 340: PPUSH
 341: CALL 74843 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 75301 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 75570 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 74627 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 22
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 3
 596: PUSH
 597: LD_INT 52
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL 74783 0 2
// end ;
 614: LD_VAR 0 1
 618: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 619: LD_INT 0
 621: PPUSH
// debug := false ;
 622: LD_ADDR_EXP 1
 626: PUSH
 627: LD_INT 0
 629: ST_TO_ADDR
// game := true ;
 630: LD_ADDR_EXP 2
 634: PUSH
 635: LD_INT 1
 637: ST_TO_ADDR
// gossudarov_arrive := false ;
 638: LD_ADDR_EXP 4
 642: PUSH
 643: LD_INT 0
 645: ST_TO_ADDR
// ru_lab_builded := false ;
 646: LD_ADDR_EXP 5
 650: PUSH
 651: LD_INT 0
 653: ST_TO_ADDR
// player_spotted := false ;
 654: LD_ADDR_EXP 6
 658: PUSH
 659: LD_INT 0
 661: ST_TO_ADDR
// first_attack := false ;
 662: LD_ADDR_EXP 7
 666: PUSH
 667: LD_INT 0
 669: ST_TO_ADDR
// ru_attackers := [ ] ;
 670: LD_ADDR_EXP 52
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// ar_base_spotted := false ;
 677: LD_ADDR_EXP 8
 681: PUSH
 682: LD_INT 0
 684: ST_TO_ADDR
// ar_active_attack := false ;
 685: LD_ADDR_EXP 9
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// ar_attackers := [ ] ;
 693: LD_ADDR_EXP 10
 697: PUSH
 698: EMPTY
 699: ST_TO_ADDR
// first_powell_attack := false ;
 700: LD_ADDR_EXP 11
 704: PUSH
 705: LD_INT 0
 707: ST_TO_ADDR
// abdul_escaped := true ;
 708: LD_ADDR_EXP 12
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// loss_counter := 0 ;
 716: LD_ADDR_EXP 13
 720: PUSH
 721: LD_INT 0
 723: ST_TO_ADDR
// hack_counter := 0 ;
 724: LD_ADDR_EXP 14
 728: PUSH
 729: LD_INT 0
 731: ST_TO_ADDR
// end ;
 732: LD_VAR 0 1
 736: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 737: LD_EXP 48
 741: PPUSH
 742: CALL_OW 255
 746: PUSH
 747: LD_INT 7
 749: EQUAL
 750: PUSH
 751: LD_EXP 47
 755: PPUSH
 756: CALL_OW 255
 760: PUSH
 761: LD_INT 7
 763: EQUAL
 764: AND
 765: PUSH
 766: LD_EXP 48
 770: PPUSH
 771: CALL_OW 302
 775: AND
 776: PUSH
 777: LD_EXP 47
 781: PPUSH
 782: CALL_OW 302
 786: AND
 787: IFFALSE 799
 789: GO 791
 791: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 792: LD_STRING ACH_COMRADE
 794: PPUSH
 795: CALL_OW 543
 799: END
// every 0 0$1 trigger hack_counter >= 10 do
 800: LD_EXP 14
 804: PUSH
 805: LD_INT 10
 807: GREATEREQUAL
 808: IFFALSE 820
 810: GO 812
 812: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 813: LD_STRING ACH_HACK
 815: PPUSH
 816: CALL_OW 543
 820: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 821: LD_INT 0
 823: PPUSH
 824: PPUSH
 825: PPUSH
 826: PPUSH
// uc_side := 7 ;
 827: LD_ADDR_OWVAR 20
 831: PUSH
 832: LD_INT 7
 834: ST_TO_ADDR
// uc_nation := 1 ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_INT 1
 842: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 843: LD_ADDR_EXP 15
 847: PUSH
 848: LD_STRING JMM
 850: PPUSH
 851: LD_EXP 1
 855: NOT
 856: PPUSH
 857: LD_STRING 12a_
 859: PPUSH
 860: CALL 14292 0 3
 864: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 865: LD_EXP 15
 869: PPUSH
 870: LD_INT 71
 872: PPUSH
 873: LD_INT 23
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 883: LD_EXP 15
 887: PPUSH
 888: LD_INT 2
 890: PPUSH
 891: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 895: LD_ADDR_EXP 16
 899: PUSH
 900: LD_STRING Roth
 902: PPUSH
 903: LD_EXP 1
 907: NOT
 908: PPUSH
 909: LD_STRING 12a_
 911: PPUSH
 912: CALL 14292 0 3
 916: ST_TO_ADDR
// if Roth then
 917: LD_EXP 16
 921: IFFALSE 941
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 923: LD_EXP 16
 927: PPUSH
 928: LD_INT 71
 930: PPUSH
 931: LD_INT 21
 933: PPUSH
 934: LD_INT 0
 936: PPUSH
 937: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING Lisa
 948: PPUSH
 949: LD_EXP 1
 953: NOT
 954: PPUSH
 955: LD_STRING 12a_
 957: PPUSH
 958: CALL 14292 0 3
 962: ST_TO_ADDR
// if Lisa then
 963: LD_EXP 17
 967: IFFALSE 984
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 969: LD_EXP 17
 973: PPUSH
 974: LD_INT 13
 976: PPUSH
 977: LD_INT 0
 979: PPUSH
 980: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 984: LD_ADDR_EXP 18
 988: PUSH
 989: LD_STRING Donaldson
 991: PPUSH
 992: LD_EXP 1
 996: NOT
 997: PPUSH
 998: LD_STRING 12a_
1000: PPUSH
1001: CALL 14292 0 3
1005: ST_TO_ADDR
// if Donaldson then
1006: LD_EXP 18
1010: IFFALSE 1027
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1012: LD_EXP 18
1016: PPUSH
1017: LD_INT 13
1019: PPUSH
1020: LD_INT 0
1022: PPUSH
1023: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1027: LD_ADDR_EXP 19
1031: PUSH
1032: LD_STRING Bobby
1034: PPUSH
1035: LD_EXP 1
1039: NOT
1040: PPUSH
1041: LD_STRING 12a_
1043: PPUSH
1044: CALL 14292 0 3
1048: ST_TO_ADDR
// if Bobby then
1049: LD_EXP 19
1053: IFFALSE 1070
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1055: LD_EXP 19
1059: PPUSH
1060: LD_INT 13
1062: PPUSH
1063: LD_INT 0
1065: PPUSH
1066: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1070: LD_ADDR_EXP 20
1074: PUSH
1075: LD_STRING Cyrus
1077: PPUSH
1078: LD_EXP 1
1082: NOT
1083: PPUSH
1084: LD_STRING 12a_
1086: PPUSH
1087: CALL 14292 0 3
1091: ST_TO_ADDR
// if Cyrus then
1092: LD_EXP 20
1096: IFFALSE 1113
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1098: LD_EXP 20
1102: PPUSH
1103: LD_INT 13
1105: PPUSH
1106: LD_INT 0
1108: PPUSH
1109: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1113: LD_ADDR_EXP 21
1117: PUSH
1118: LD_STRING Denis
1120: PPUSH
1121: LD_EXP 1
1125: NOT
1126: PPUSH
1127: LD_STRING 12a_
1129: PPUSH
1130: CALL 14292 0 3
1134: ST_TO_ADDR
// if Denis then
1135: LD_EXP 21
1139: IFFALSE 1156
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1141: LD_EXP 21
1145: PPUSH
1146: LD_INT 13
1148: PPUSH
1149: LD_INT 0
1151: PPUSH
1152: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1156: LD_ADDR_EXP 22
1160: PUSH
1161: LD_STRING Brown
1163: PPUSH
1164: LD_EXP 1
1168: NOT
1169: PPUSH
1170: LD_STRING 12a_
1172: PPUSH
1173: CALL 14292 0 3
1177: ST_TO_ADDR
// if Brown then
1178: LD_EXP 22
1182: IFFALSE 1199
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1184: LD_EXP 22
1188: PPUSH
1189: LD_INT 13
1191: PPUSH
1192: LD_INT 0
1194: PPUSH
1195: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1199: LD_ADDR_EXP 23
1203: PUSH
1204: LD_STRING Gladstone
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_STRING 12a_
1215: PPUSH
1216: CALL 14292 0 3
1220: ST_TO_ADDR
// if Gladstone then
1221: LD_EXP 23
1225: IFFALSE 1242
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1227: LD_EXP 23
1231: PPUSH
1232: LD_INT 13
1234: PPUSH
1235: LD_INT 0
1237: PPUSH
1238: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1242: LD_ADDR_EXP 24
1246: PUSH
1247: LD_STRING Houten
1249: PPUSH
1250: LD_EXP 1
1254: NOT
1255: PPUSH
1256: LD_STRING 12a_
1258: PPUSH
1259: CALL 14292 0 3
1263: ST_TO_ADDR
// if Houten then
1264: LD_EXP 24
1268: IFFALSE 1285
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1270: LD_EXP 24
1274: PPUSH
1275: LD_INT 13
1277: PPUSH
1278: LD_INT 0
1280: PPUSH
1281: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1285: LD_ADDR_EXP 25
1289: PUSH
1290: LD_STRING Cornell
1292: PPUSH
1293: LD_EXP 1
1297: NOT
1298: PPUSH
1299: LD_STRING 12a_
1301: PPUSH
1302: CALL 14292 0 3
1306: ST_TO_ADDR
// if Cornel then
1307: LD_EXP 25
1311: IFFALSE 1328
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1313: LD_EXP 25
1317: PPUSH
1318: LD_INT 13
1320: PPUSH
1321: LD_INT 0
1323: PPUSH
1324: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1328: LD_ADDR_EXP 26
1332: PUSH
1333: LD_STRING Gary
1335: PPUSH
1336: LD_EXP 1
1340: NOT
1341: PPUSH
1342: LD_STRING 12a_
1344: PPUSH
1345: CALL 14292 0 3
1349: ST_TO_ADDR
// if Gary then
1350: LD_EXP 26
1354: IFFALSE 1371
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1356: LD_EXP 26
1360: PPUSH
1361: LD_INT 13
1363: PPUSH
1364: LD_INT 0
1366: PPUSH
1367: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1371: LD_ADDR_EXP 27
1375: PUSH
1376: LD_STRING Frank
1378: PPUSH
1379: LD_EXP 1
1383: NOT
1384: PPUSH
1385: LD_STRING 12a_
1387: PPUSH
1388: CALL 14292 0 3
1392: ST_TO_ADDR
// if Frank then
1393: LD_EXP 27
1397: IFFALSE 1414
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1399: LD_EXP 27
1403: PPUSH
1404: LD_INT 13
1406: PPUSH
1407: LD_INT 0
1409: PPUSH
1410: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1414: LD_ADDR_EXP 28
1418: PUSH
1419: LD_STRING Kikuchi
1421: PPUSH
1422: LD_EXP 1
1426: NOT
1427: PPUSH
1428: LD_STRING 12a_
1430: PPUSH
1431: CALL 14292 0 3
1435: ST_TO_ADDR
// if Kikuchi then
1436: LD_EXP 28
1440: IFFALSE 1457
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1442: LD_EXP 28
1446: PPUSH
1447: LD_INT 13
1449: PPUSH
1450: LD_INT 0
1452: PPUSH
1453: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1457: LD_ADDR_EXP 29
1461: PUSH
1462: LD_STRING Simms
1464: PPUSH
1465: LD_EXP 1
1469: NOT
1470: PPUSH
1471: LD_STRING 12a_
1473: PPUSH
1474: CALL 14292 0 3
1478: ST_TO_ADDR
// if Simms then
1479: LD_EXP 29
1483: IFFALSE 1500
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1485: LD_EXP 29
1489: PPUSH
1490: LD_INT 13
1492: PPUSH
1493: LD_INT 0
1495: PPUSH
1496: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1500: LD_ADDR_EXP 30
1504: PUSH
1505: LD_STRING Joan
1507: PPUSH
1508: LD_EXP 1
1512: NOT
1513: PPUSH
1514: LD_STRING 12a_
1516: PPUSH
1517: CALL 14292 0 3
1521: ST_TO_ADDR
// if Joan then
1522: LD_EXP 30
1526: IFFALSE 1543
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1528: LD_EXP 30
1532: PPUSH
1533: LD_INT 13
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1543: LD_ADDR_EXP 31
1547: PUSH
1548: LD_STRING DeltaDoctor
1550: PPUSH
1551: LD_EXP 1
1555: NOT
1556: PPUSH
1557: LD_STRING 12a_
1559: PPUSH
1560: CALL 14292 0 3
1564: ST_TO_ADDR
// if DeltaDoctor then
1565: LD_EXP 31
1569: IFFALSE 1586
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1571: LD_EXP 31
1575: PPUSH
1576: LD_INT 13
1578: PPUSH
1579: LD_INT 0
1581: PPUSH
1582: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1586: LD_ADDR_VAR 0 4
1590: PUSH
1591: LD_STRING 12a_others
1593: PPUSH
1594: CALL_OW 31
1598: ST_TO_ADDR
// if tmp then
1599: LD_VAR 0 4
1603: IFFALSE 1637
// for i in tmp do
1605: LD_ADDR_VAR 0 3
1609: PUSH
1610: LD_VAR 0 4
1614: PUSH
1615: FOR_IN
1616: IFFALSE 1635
// PlaceUnitArea ( i , alliance_start , false ) ;
1618: LD_VAR 0 3
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
1633: GO 1615
1635: POP
1636: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 3
1642: PPUSH
1643: LD_INT 3
1645: PPUSH
1646: LD_INT 12
1648: PPUSH
1649: LD_INT 100
1651: PPUSH
1652: CALL 19116 0 5
// veh := CreateVehicle ;
1656: LD_ADDR_VAR 0 2
1660: PUSH
1661: CALL_OW 45
1665: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1666: LD_VAR 0 2
1670: PPUSH
1671: LD_INT 2
1673: PPUSH
1674: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1678: LD_VAR 0 2
1682: PPUSH
1683: LD_INT 60
1685: PPUSH
1686: LD_INT 6
1688: PPUSH
1689: LD_INT 0
1691: PPUSH
1692: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1696: LD_VAR 0 2
1700: PPUSH
1701: LD_INT 4
1703: PPUSH
1704: LD_INT 30
1706: PPUSH
1707: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1711: LD_STRING 11_artifact_captured
1713: PPUSH
1714: LD_INT 0
1716: PPUSH
1717: CALL_OW 30
1721: IFFALSE 1797
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1723: LD_INT 3
1725: PPUSH
1726: LD_INT 3
1728: PPUSH
1729: LD_INT 3
1731: PPUSH
1732: LD_INT 12
1734: PPUSH
1735: LD_INT 100
1737: PPUSH
1738: CALL 19116 0 5
// veh := CreateVehicle ;
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: CALL_OW 45
1751: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1752: LD_VAR 0 2
1756: PPUSH
1757: LD_INT 3
1759: PPUSH
1760: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1764: LD_VAR 0 2
1768: PPUSH
1769: LD_INT 75
1771: PPUSH
1772: LD_INT 6
1774: PPUSH
1775: LD_INT 0
1777: PPUSH
1778: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1782: LD_VAR 0 2
1786: PPUSH
1787: LD_INT 4
1789: PPUSH
1790: LD_INT 50
1792: PPUSH
1793: CALL_OW 290
// end ; end ;
1797: LD_VAR 0 1
1801: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1802: LD_INT 0
1804: PPUSH
1805: PPUSH
1806: PPUSH
1807: PPUSH
// uc_side := 6 ;
1808: LD_ADDR_OWVAR 20
1812: PUSH
1813: LD_INT 6
1815: ST_TO_ADDR
// uc_nation := 3 ;
1816: LD_ADDR_OWVAR 21
1820: PUSH
1821: LD_INT 3
1823: ST_TO_ADDR
// InitHc ;
1824: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1828: LD_ADDR_EXP 32
1832: PUSH
1833: LD_STRING Gossudarov
1835: PPUSH
1836: CALL_OW 25
1840: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1841: LD_ADDR_EXP 33
1845: PUSH
1846: LD_STRING Kirilenkova
1848: PPUSH
1849: CALL_OW 25
1853: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1854: LD_ADDR_EXP 34
1858: PUSH
1859: LD_STRING Titov
1861: PPUSH
1862: CALL_OW 25
1866: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1867: LD_ADDR_EXP 39
1871: PUSH
1872: LD_STRING Oblukov
1874: PPUSH
1875: CALL_OW 25
1879: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1880: LD_ADDR_EXP 36
1884: PUSH
1885: LD_STRING Dolgov
1887: PPUSH
1888: CALL_OW 25
1892: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1893: LD_ADDR_EXP 37
1897: PUSH
1898: LD_STRING Petrosyan
1900: PPUSH
1901: CALL_OW 25
1905: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1906: LD_ADDR_EXP 38
1910: PUSH
1911: LD_STRING Scholtze
1913: PPUSH
1914: CALL_OW 25
1918: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1919: LD_ADDR_EXP 40
1923: PUSH
1924: LD_STRING Kapitsova
1926: PPUSH
1927: CALL_OW 25
1931: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1932: LD_ADDR_VAR 0 2
1936: PUSH
1937: LD_EXP 32
1941: PUSH
1942: LD_EXP 33
1946: PUSH
1947: LD_EXP 34
1951: PUSH
1952: LD_EXP 39
1956: PUSH
1957: LD_EXP 36
1961: PUSH
1962: LD_EXP 37
1966: PUSH
1967: LD_EXP 38
1971: PUSH
1972: LD_EXP 40
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: LIST
1986: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1987: LD_INT 1
1989: PPUSH
1990: LD_INT 4
1992: PPUSH
1993: LD_INT 8
1995: PPUSH
1996: CALL_OW 380
// un := CreateHuman ;
2000: LD_ADDR_VAR 0 4
2004: PUSH
2005: CALL_OW 44
2009: ST_TO_ADDR
// tmp := tmp ^ un ;
2010: LD_ADDR_VAR 0 2
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_VAR 0 4
2024: ADD
2025: ST_TO_ADDR
// for i in tmp do
2026: LD_ADDR_VAR 0 3
2030: PUSH
2031: LD_VAR 0 2
2035: PUSH
2036: FOR_IN
2037: IFFALSE 2056
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2039: LD_VAR 0 3
2043: PPUSH
2044: LD_INT 14
2046: PPUSH
2047: LD_INT 0
2049: PPUSH
2050: CALL_OW 49
2054: GO 2036
2056: POP
2057: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_EXP 3
2067: PPUSH
2068: CALL_OW 250
2072: PPUSH
2073: LD_EXP 3
2077: PPUSH
2078: CALL_OW 251
2082: PPUSH
2083: CALL_OW 111
// end ;
2087: LD_VAR 0 1
2091: RET
// export function PrepareBelkov ; begin
2092: LD_INT 0
2094: PPUSH
// uc_side := 4 ;
2095: LD_ADDR_OWVAR 20
2099: PUSH
2100: LD_INT 4
2102: ST_TO_ADDR
// uc_nation := 3 ;
2103: LD_ADDR_OWVAR 21
2107: PUSH
2108: LD_INT 3
2110: ST_TO_ADDR
// InitHc ;
2111: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2115: LD_ADDR_EXP 47
2119: PUSH
2120: LD_STRING Belkov
2122: PPUSH
2123: CALL_OW 25
2127: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2128: LD_EXP 47
2132: PPUSH
2133: LD_INT 14
2135: PPUSH
2136: LD_INT 0
2138: PPUSH
2139: CALL_OW 49
// end ;
2143: LD_VAR 0 1
2147: RET
// export function PrepareGnyevko ; begin
2148: LD_INT 0
2150: PPUSH
// uc_side := 4 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 4
2158: ST_TO_ADDR
// uc_nation := 3 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 3
2166: ST_TO_ADDR
// InitHc ;
2167: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2171: LD_ADDR_EXP 48
2175: PUSH
2176: LD_STRING Gnyevko
2178: PPUSH
2179: CALL_OW 25
2183: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2184: LD_EXP 48
2188: PPUSH
2189: LD_INT 14
2191: PPUSH
2192: LD_INT 0
2194: PPUSH
2195: CALL_OW 49
// end ;
2199: LD_VAR 0 1
2203: RET
// export function PrepareBurlak ; var i , tmp ; begin
2204: LD_INT 0
2206: PPUSH
2207: PPUSH
2208: PPUSH
// uc_side := 4 ;
2209: LD_ADDR_OWVAR 20
2213: PUSH
2214: LD_INT 4
2216: ST_TO_ADDR
// uc_nation := 3 ;
2217: LD_ADDR_OWVAR 21
2221: PUSH
2222: LD_INT 3
2224: ST_TO_ADDR
// InitHc ;
2225: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2229: LD_ADDR_EXP 46
2233: PUSH
2234: LD_STRING Burlak
2236: PPUSH
2237: CALL_OW 25
2241: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2242: LD_INT 24
2244: PUSH
2245: LD_INT 23
2247: PUSH
2248: LD_INT 22
2250: PUSH
2251: EMPTY
2252: LIST
2253: LIST
2254: LIST
2255: PUSH
2256: LD_OWVAR 67
2260: ARRAY
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: LD_INT 1
2267: PPUSH
2268: LD_INT 45
2270: PUSH
2271: LD_INT 44
2273: PUSH
2274: LD_INT 43
2276: PUSH
2277: EMPTY
2278: LIST
2279: LIST
2280: LIST
2281: PUSH
2282: LD_OWVAR 67
2286: ARRAY
2287: PPUSH
2288: LD_INT 0
2290: PPUSH
2291: CALL 19116 0 5
// Masha := CreateVehicle ;
2295: LD_ADDR_EXP 49
2299: PUSH
2300: CALL_OW 45
2304: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2305: LD_EXP 49
2309: PUSH
2310: LD_EXP 46
2314: PUSH
2315: EMPTY
2316: LIST
2317: LIST
2318: PPUSH
2319: LD_INT 499
2321: PPUSH
2322: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2326: LD_EXP 49
2330: PPUSH
2331: LD_INT 3
2333: PPUSH
2334: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2338: LD_EXP 49
2342: PPUSH
2343: LD_INT 1
2345: PPUSH
2346: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2350: LD_INT 1
2352: PPUSH
2353: LD_INT 18
2355: PPUSH
2356: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2360: LD_INT 35
2362: PPUSH
2363: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 18
2374: PPUSH
2375: EMPTY
2376: PPUSH
2377: CALL_OW 70
2381: ST_TO_ADDR
// if tmp then
2382: LD_VAR 0 3
2386: IFFALSE 2420
// for i in tmp do
2388: LD_ADDR_VAR 0 2
2392: PUSH
2393: LD_VAR 0 3
2397: PUSH
2398: FOR_IN
2399: IFFALSE 2418
// ComMoveXY ( i , 114 , 9 ) ;
2401: LD_VAR 0 2
2405: PPUSH
2406: LD_INT 114
2408: PPUSH
2409: LD_INT 9
2411: PPUSH
2412: CALL_OW 111
2416: GO 2398
2418: POP
2419: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2420: LD_INT 18
2422: PPUSH
2423: EMPTY
2424: PPUSH
2425: CALL_OW 70
2429: NOT
2430: PUSH
2431: LD_INT 123
2433: PPUSH
2434: LD_INT 3
2436: PPUSH
2437: CALL_OW 428
2441: PUSH
2442: LD_INT 0
2444: EQUAL
2445: AND
2446: IFFALSE 2360
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2448: LD_EXP 49
2452: PPUSH
2453: LD_INT 123
2455: PPUSH
2456: LD_INT 3
2458: PPUSH
2459: LD_INT 0
2461: PPUSH
2462: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2466: LD_EXP 46
2470: PPUSH
2471: LD_INT 125
2473: PPUSH
2474: LD_INT 1
2476: PPUSH
2477: LD_INT 0
2479: PPUSH
2480: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2484: LD_EXP 46
2488: PPUSH
2489: LD_EXP 49
2493: PPUSH
2494: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2498: LD_INT 10
2500: PPUSH
2501: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2505: LD_EXP 49
2509: PPUSH
2510: LD_INT 110
2512: PPUSH
2513: LD_INT 10
2515: PPUSH
2516: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2520: LD_ADDR_EXP 42
2524: PUSH
2525: LD_STRING Petrovova
2527: PPUSH
2528: CALL_OW 25
2532: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2533: LD_ADDR_EXP 44
2537: PUSH
2538: LD_STRING Kuzmov
2540: PPUSH
2541: CALL_OW 25
2545: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2546: LD_ADDR_EXP 43
2550: PUSH
2551: LD_STRING Kovalyuk
2553: PPUSH
2554: CALL_OW 25
2558: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2559: LD_ADDR_EXP 41
2563: PUSH
2564: LD_STRING Lipshchin
2566: PPUSH
2567: CALL_OW 25
2571: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2572: LD_ADDR_EXP 45
2576: PUSH
2577: LD_STRING Karamazov
2579: PPUSH
2580: CALL_OW 25
2584: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2585: LD_ADDR_VAR 0 3
2589: PUSH
2590: LD_EXP 42
2594: PUSH
2595: LD_EXP 44
2599: PUSH
2600: LD_EXP 43
2604: PUSH
2605: LD_EXP 41
2609: PUSH
2610: LD_EXP 45
2614: PUSH
2615: EMPTY
2616: LIST
2617: LIST
2618: LIST
2619: LIST
2620: LIST
2621: ST_TO_ADDR
// for i in tmp do
2622: LD_ADDR_VAR 0 2
2626: PUSH
2627: LD_VAR 0 3
2631: PUSH
2632: FOR_IN
2633: IFFALSE 2672
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2635: LD_VAR 0 2
2639: PPUSH
2640: LD_INT 399
2642: PPUSH
2643: LD_INT 799
2645: PPUSH
2646: CALL_OW 12
2650: PPUSH
2651: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2655: LD_VAR 0 2
2659: PPUSH
2660: LD_INT 19
2662: PPUSH
2663: LD_INT 0
2665: PPUSH
2666: CALL_OW 49
// end ;
2670: GO 2632
2672: POP
2673: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2674: LD_VAR 0 3
2678: PPUSH
2679: LD_INT 116
2681: PPUSH
2682: LD_INT 8
2684: PPUSH
2685: CALL_OW 111
// AddComHold ( tmp ) ;
2689: LD_VAR 0 3
2693: PPUSH
2694: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2698: LD_ADDR_VAR 0 2
2702: PUSH
2703: LD_VAR 0 3
2707: PPUSH
2708: LD_INT 25
2710: PUSH
2711: LD_INT 1
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PPUSH
2718: CALL_OW 72
2722: PUSH
2723: FOR_IN
2724: IFFALSE 2764
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2726: LD_VAR 0 2
2730: PPUSH
2731: LD_INT 20
2733: PPUSH
2734: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2738: LD_VAR 0 2
2742: PPUSH
2743: LD_INT 147
2745: PPUSH
2746: LD_INT 45
2748: PPUSH
2749: CALL_OW 178
// AddComCrawl ( i ) ;
2753: LD_VAR 0 2
2757: PPUSH
2758: CALL_OW 197
// end ;
2762: GO 2723
2764: POP
2765: POP
// repeat wait ( 0 0$1 ) ;
2766: LD_INT 35
2768: PPUSH
2769: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2773: LD_EXP 49
2777: PPUSH
2778: LD_INT 110
2780: PPUSH
2781: LD_INT 10
2783: PPUSH
2784: CALL_OW 307
2788: PUSH
2789: LD_EXP 49
2793: PPUSH
2794: CALL_OW 305
2798: NOT
2799: OR
2800: IFFALSE 2766
// ComStop ( Burlak ) ;
2802: LD_EXP 46
2806: PPUSH
2807: CALL_OW 141
// AddComHold ( Burlak ) ;
2811: LD_EXP 46
2815: PPUSH
2816: CALL_OW 200
// end ; end_of_file
2820: LD_VAR 0 1
2824: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2825: LD_INT 0
2827: PPUSH
2828: PPUSH
2829: PPUSH
2830: PPUSH
// uc_side := 3 ;
2831: LD_ADDR_OWVAR 20
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// uc_nation := 3 ;
2839: LD_ADDR_OWVAR 21
2843: PUSH
2844: LD_INT 3
2846: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2847: LD_ADDR_EXP 50
2851: PUSH
2852: LD_INT 47
2854: PPUSH
2855: LD_INT 4
2857: PPUSH
2858: LD_STRING 
2860: PPUSH
2861: LD_INT 7
2863: PUSH
2864: LD_INT 8
2866: PUSH
2867: LD_INT 9
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: LIST
2874: PUSH
2875: LD_OWVAR 67
2879: ARRAY
2880: PPUSH
2881: LD_INT 10000
2883: PUSH
2884: LD_INT 3000
2886: PUSH
2887: LD_INT 300
2889: PUSH
2890: EMPTY
2891: LIST
2892: LIST
2893: LIST
2894: PPUSH
2895: LD_INT 9
2897: PUSH
2898: LD_INT 5
2900: PUSH
2901: LD_INT 6
2903: PUSH
2904: LD_INT 6
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: PPUSH
2913: CALL 22525 0 6
2917: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2918: LD_ADDR_EXP 59
2922: PUSH
2923: LD_EXP 59
2927: PPUSH
2928: LD_INT 2
2930: PPUSH
2931: LD_EXP 50
2935: PPUSH
2936: CALL_OW 1
2940: ST_TO_ADDR
// tmp := [ ] ;
2941: LD_ADDR_VAR 0 4
2945: PUSH
2946: EMPTY
2947: ST_TO_ADDR
// for i = 1 to 4 do
2948: LD_ADDR_VAR 0 2
2952: PUSH
2953: DOUBLE
2954: LD_INT 1
2956: DEC
2957: ST_TO_ADDR
2958: LD_INT 4
2960: PUSH
2961: FOR_TO
2962: IFFALSE 3055
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2964: LD_INT 22
2966: PPUSH
2967: LD_INT 3
2969: PPUSH
2970: LD_INT 3
2972: PPUSH
2973: LD_INT 43
2975: PUSH
2976: LD_INT 45
2978: PUSH
2979: LD_INT 45
2981: PUSH
2982: LD_INT 44
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: PUSH
2991: LD_VAR 0 2
2995: PUSH
2996: LD_INT 4
2998: MOD
2999: PUSH
3000: LD_INT 1
3002: PLUS
3003: ARRAY
3004: PPUSH
3005: LD_INT 100
3007: PPUSH
3008: CALL 19116 0 5
// veh := CreateVehicle ;
3012: LD_ADDR_VAR 0 3
3016: PUSH
3017: CALL_OW 45
3021: ST_TO_ADDR
// tmp := tmp ^ veh ;
3022: LD_ADDR_VAR 0 4
3026: PUSH
3027: LD_VAR 0 4
3031: PUSH
3032: LD_VAR 0 3
3036: ADD
3037: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3038: LD_VAR 0 3
3042: PPUSH
3043: LD_INT 2
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 49
// end ;
3053: GO 2961
3055: POP
3056: POP
// russian_guard := tmp ;
3057: LD_ADDR_EXP 51
3061: PUSH
3062: LD_VAR 0 4
3066: ST_TO_ADDR
// end ;
3067: LD_VAR 0 1
3071: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
3072: LD_INT 47
3074: PPUSH
3075: CALL_OW 302
3079: PUSH
3080: LD_EXP 6
3084: AND
3085: IFFALSE 3687
3087: GO 3089
3089: DISABLE
3090: LD_INT 0
3092: PPUSH
3093: PPUSH
3094: PPUSH
3095: PPUSH
3096: PPUSH
3097: PPUSH
// begin enable ;
3098: ENABLE
// base := 2 ;
3099: LD_ADDR_VAR 0 2
3103: PUSH
3104: LD_INT 2
3106: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3107: LD_ADDR_VAR 0 4
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: LD_INT 0
3117: PUSH
3118: LD_INT 0
3120: PUSH
3121: LD_INT 0
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 0
3129: PUSH
3130: LD_INT 0
3132: PUSH
3133: LD_INT 0
3135: PUSH
3136: LD_INT 1
3138: PUSH
3139: LD_INT 0
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3154: LD_ADDR_VAR 0 3
3158: PUSH
3159: LD_INT 22
3161: PUSH
3162: LD_INT 1
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: LD_INT 45
3170: PUSH
3171: EMPTY
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: PUSH
3177: LD_INT 21
3179: PUSH
3180: LD_INT 1
3182: PUSH
3183: LD_INT 3
3185: PUSH
3186: LD_INT 45
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 22
3197: PUSH
3198: LD_INT 1
3200: PUSH
3201: LD_INT 3
3203: PUSH
3204: LD_INT 45
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 23
3215: PUSH
3216: LD_INT 1
3218: PUSH
3219: LD_INT 3
3221: PUSH
3222: LD_INT 46
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: LIST
3229: LIST
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: LIST
3235: LIST
3236: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3237: LD_ADDR_VAR 0 1
3241: PUSH
3242: DOUBLE
3243: LD_INT 1
3245: DEC
3246: ST_TO_ADDR
3247: LD_OWVAR 67
3251: PUSH
3252: LD_OWVAR 1
3256: PUSH
3257: LD_INT 21000
3259: DIV
3260: PLUS
3261: PUSH
3262: FOR_TO
3263: IFFALSE 3351
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3265: LD_ADDR_VAR 0 3
3269: PUSH
3270: LD_VAR 0 3
3274: PPUSH
3275: LD_VAR 0 3
3279: PUSH
3280: LD_INT 1
3282: PLUS
3283: PPUSH
3284: LD_INT 23
3286: PUSH
3287: LD_INT 24
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: LD_INT 1
3296: PPUSH
3297: LD_INT 2
3299: PPUSH
3300: CALL_OW 12
3304: ARRAY
3305: PUSH
3306: LD_INT 1
3308: PUSH
3309: LD_INT 3
3311: PUSH
3312: LD_INT 46
3314: PUSH
3315: LD_INT 47
3317: PUSH
3318: LD_INT 45
3320: PUSH
3321: EMPTY
3322: LIST
3323: LIST
3324: LIST
3325: PUSH
3326: LD_INT 1
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: CALL_OW 12
3336: ARRAY
3337: PUSH
3338: EMPTY
3339: LIST
3340: LIST
3341: LIST
3342: LIST
3343: PPUSH
3344: CALL_OW 2
3348: ST_TO_ADDR
3349: GO 3262
3351: POP
3352: POP
// MC_InsertProduceList ( base , tmp ) ;
3353: LD_VAR 0 2
3357: PPUSH
3358: LD_VAR 0 3
3362: PPUSH
3363: CALL 74783 0 2
// repeat wait ( 0 0$1 ) ;
3367: LD_INT 35
3369: PPUSH
3370: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3374: LD_EXP 78
3378: PUSH
3379: LD_VAR 0 2
3383: ARRAY
3384: PUSH
3385: LD_INT 6
3387: GREATER
3388: IFFALSE 3367
// wait ( 0 0$20 ) ;
3390: LD_INT 700
3392: PPUSH
3393: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3397: LD_ADDR_VAR 0 5
3401: PUSH
3402: LD_INT 71
3404: PUSH
3405: LD_INT 19
3407: PUSH
3408: EMPTY
3409: LIST
3410: LIST
3411: PUSH
3412: LD_INT 91
3414: PUSH
3415: LD_INT 67
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: PUSH
3422: LD_INT 52
3424: PUSH
3425: LD_INT 44
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PUSH
3432: LD_INT 68
3434: PUSH
3435: LD_INT 48
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3448: LD_ADDR_VAR 0 6
3452: PUSH
3453: LD_EXP 78
3457: PUSH
3458: LD_VAR 0 2
3462: ARRAY
3463: PUSH
3464: LD_EXP 78
3468: PUSH
3469: LD_VAR 0 2
3473: ARRAY
3474: PPUSH
3475: LD_INT 2
3477: PUSH
3478: LD_INT 34
3480: PUSH
3481: LD_INT 51
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: PUSH
3488: LD_INT 34
3490: PUSH
3491: LD_INT 52
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: LIST
3502: PPUSH
3503: CALL_OW 72
3507: DIFF
3508: ST_TO_ADDR
// if not attackers then
3509: LD_VAR 0 6
3513: NOT
3514: IFFALSE 3518
// exit ;
3516: GO 3687
// ru_attackers := attackers ;
3518: LD_ADDR_EXP 52
3522: PUSH
3523: LD_VAR 0 6
3527: ST_TO_ADDR
// for i = 1 to attackers do
3528: LD_ADDR_VAR 0 1
3532: PUSH
3533: DOUBLE
3534: LD_INT 1
3536: DEC
3537: ST_TO_ADDR
3538: LD_VAR 0 6
3542: PUSH
3543: FOR_TO
3544: IFFALSE 3621
// begin case i mod 3 of 0 :
3546: LD_VAR 0 1
3550: PUSH
3551: LD_INT 3
3553: MOD
3554: PUSH
3555: LD_INT 0
3557: DOUBLE
3558: EQUAL
3559: IFTRUE 3563
3561: GO 3566
3563: POP
// ; 1 :
3564: GO 3619
3566: LD_INT 1
3568: DOUBLE
3569: EQUAL
3570: IFTRUE 3574
3572: GO 3592
3574: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3575: LD_VAR 0 1
3579: PPUSH
3580: LD_INT 32
3582: PPUSH
3583: LD_INT 49
3585: PPUSH
3586: CALL_OW 114
3590: GO 3619
3592: LD_INT 2
3594: DOUBLE
3595: EQUAL
3596: IFTRUE 3600
3598: GO 3618
3600: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3601: LD_VAR 0 1
3605: PPUSH
3606: LD_INT 117
3608: PPUSH
3609: LD_INT 107
3611: PPUSH
3612: CALL_OW 114
3616: GO 3619
3618: POP
// end ;
3619: GO 3543
3621: POP
3622: POP
// repeat wait ( 0 0$1 ) ;
3623: LD_INT 35
3625: PPUSH
3626: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3630: LD_VAR 0 6
3634: PPUSH
3635: LD_INT 60
3637: PUSH
3638: EMPTY
3639: LIST
3640: PPUSH
3641: CALL_OW 72
3645: NOT
3646: IFFALSE 3623
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3648: LD_VAR 0 2
3652: PPUSH
3653: LD_VAR 0 6
3657: PPUSH
3658: LD_VAR 0 5
3662: PPUSH
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL 74968 0 4
// if not first_attack then
3672: LD_EXP 7
3676: NOT
3677: IFFALSE 3687
// first_attack := true ;
3679: LD_ADDR_EXP 7
3683: PUSH
3684: LD_INT 1
3686: ST_TO_ADDR
// end ; end_of_file
3687: PPOPN 6
3689: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3690: LD_INT 0
3692: PPUSH
3693: PPUSH
3694: PPUSH
3695: PPUSH
3696: PPUSH
3697: PPUSH
3698: PPUSH
// uc_side := 2 ;
3699: LD_ADDR_OWVAR 20
3703: PUSH
3704: LD_INT 2
3706: ST_TO_ADDR
// uc_nation := 2 ;
3707: LD_ADDR_OWVAR 21
3711: PUSH
3712: LD_INT 2
3714: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3715: LD_ADDR_EXP 55
3719: PUSH
3720: LD_STRING Abdul
3722: PPUSH
3723: CALL_OW 25
3727: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3728: LD_EXP 55
3732: PPUSH
3733: LD_INT 11
3735: PPUSH
3736: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3740: LD_EXP 55
3744: PPUSH
3745: LD_INT 1
3747: PPUSH
3748: CALL_OW 52
// vc_chassis := 31 ;
3752: LD_ADDR_OWVAR 37
3756: PUSH
3757: LD_INT 31
3759: ST_TO_ADDR
// vc_control := control_rider ;
3760: LD_ADDR_OWVAR 38
3764: PUSH
3765: LD_INT 4
3767: ST_TO_ADDR
// mastodont := CreateVehicle ;
3768: LD_ADDR_EXP 56
3772: PUSH
3773: CALL_OW 45
3777: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3778: LD_EXP 56
3782: PPUSH
3783: LD_INT 153
3785: PPUSH
3786: LD_INT 71
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// InitVc ;
3796: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3800: LD_ADDR_EXP 53
3804: PUSH
3805: LD_INT 1
3807: PPUSH
3808: LD_INT 3
3810: PPUSH
3811: LD_STRING 
3813: PPUSH
3814: LD_INT 7
3816: PUSH
3817: LD_INT 8
3819: PUSH
3820: LD_INT 9
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: PUSH
3828: LD_OWVAR 67
3832: ARRAY
3833: PPUSH
3834: LD_INT 5000
3836: PUSH
3837: LD_INT 1000
3839: PUSH
3840: LD_INT 300
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: PPUSH
3848: LD_INT 22
3850: PUSH
3851: LD_INT 5
3853: PUSH
3854: LD_INT 6
3856: PUSH
3857: LD_INT 9
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: LIST
3864: LIST
3865: PPUSH
3866: CALL 22525 0 6
3870: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3871: LD_ADDR_EXP 59
3875: PUSH
3876: LD_EXP 59
3880: PPUSH
3881: LD_INT 1
3883: PPUSH
3884: LD_EXP 53
3888: PPUSH
3889: CALL_OW 1
3893: ST_TO_ADDR
// tmp := [ ] ;
3894: LD_ADDR_VAR 0 4
3898: PUSH
3899: EMPTY
3900: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3901: LD_ADDR_OWVAR 37
3905: PUSH
3906: LD_INT 14
3908: ST_TO_ADDR
// vc_engine := engine_siberite ;
3909: LD_ADDR_OWVAR 39
3913: PUSH
3914: LD_INT 3
3916: ST_TO_ADDR
// vc_control := control_manual ;
3917: LD_ADDR_OWVAR 38
3921: PUSH
3922: LD_INT 1
3924: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3925: LD_ADDR_OWVAR 40
3929: PUSH
3930: LD_INT 31
3932: ST_TO_ADDR
// for i = 1 to 3 do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: DOUBLE
3939: LD_INT 1
3941: DEC
3942: ST_TO_ADDR
3943: LD_INT 3
3945: PUSH
3946: FOR_TO
3947: IFFALSE 4191
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3949: LD_ADDR_VAR 0 5
3953: PUSH
3954: LD_INT 153
3956: PUSH
3957: LD_INT 71
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PUSH
3964: LD_INT 155
3966: PUSH
3967: LD_INT 81
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PUSH
3978: LD_VAR 0 2
3982: PUSH
3983: LD_INT 2
3985: MOD
3986: PUSH
3987: LD_INT 1
3989: PLUS
3990: ARRAY
3991: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3992: LD_INT 0
3994: PPUSH
3995: LD_INT 3
3997: PPUSH
3998: LD_INT 7
4000: PUSH
4001: LD_INT 8
4003: PUSH
4004: LD_INT 9
4006: PUSH
4007: EMPTY
4008: LIST
4009: LIST
4010: LIST
4011: PUSH
4012: LD_OWVAR 67
4016: ARRAY
4017: PPUSH
4018: CALL_OW 380
// un := CreateVehicle ;
4022: LD_ADDR_VAR 0 6
4026: PUSH
4027: CALL_OW 45
4031: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4032: LD_VAR 0 6
4036: PPUSH
4037: LD_INT 0
4039: PPUSH
4040: LD_INT 5
4042: PPUSH
4043: CALL_OW 12
4047: PPUSH
4048: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4052: LD_VAR 0 6
4056: PPUSH
4057: LD_VAR 0 5
4061: PUSH
4062: LD_INT 1
4064: ARRAY
4065: PPUSH
4066: LD_VAR 0 5
4070: PUSH
4071: LD_INT 2
4073: ARRAY
4074: PPUSH
4075: LD_INT 6
4077: PPUSH
4078: LD_INT 0
4080: PPUSH
4081: CALL_OW 50
// un2 := CreateHuman ;
4085: LD_ADDR_VAR 0 7
4089: PUSH
4090: CALL_OW 44
4094: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4095: LD_VAR 0 7
4099: PPUSH
4100: LD_VAR 0 6
4104: PPUSH
4105: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4109: LD_ADDR_EXP 59
4113: PUSH
4114: LD_EXP 59
4118: PPUSH
4119: LD_INT 1
4121: PUSH
4122: LD_EXP 59
4126: PUSH
4127: LD_INT 1
4129: ARRAY
4130: PUSH
4131: LD_INT 1
4133: PLUS
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: PPUSH
4139: LD_VAR 0 6
4143: PPUSH
4144: CALL 19238 0 3
4148: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4149: LD_ADDR_EXP 59
4153: PUSH
4154: LD_EXP 59
4158: PPUSH
4159: LD_INT 1
4161: PUSH
4162: LD_EXP 59
4166: PUSH
4167: LD_INT 1
4169: ARRAY
4170: PUSH
4171: LD_INT 1
4173: PLUS
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: PPUSH
4179: LD_VAR 0 7
4183: PPUSH
4184: CALL 19238 0 3
4188: ST_TO_ADDR
// end ;
4189: GO 3946
4191: POP
4192: POP
// for i = 1 to 5 do
4193: LD_ADDR_VAR 0 2
4197: PUSH
4198: DOUBLE
4199: LD_INT 1
4201: DEC
4202: ST_TO_ADDR
4203: LD_INT 5
4205: PUSH
4206: FOR_TO
4207: IFFALSE 4300
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4209: LD_INT 14
4211: PPUSH
4212: LD_INT 3
4214: PPUSH
4215: LD_INT 1
4217: PPUSH
4218: LD_INT 25
4220: PUSH
4221: LD_INT 28
4223: PUSH
4224: LD_INT 28
4226: PUSH
4227: LD_INT 26
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: LIST
4235: PUSH
4236: LD_VAR 0 2
4240: PUSH
4241: LD_INT 4
4243: MOD
4244: PUSH
4245: LD_INT 1
4247: PLUS
4248: ARRAY
4249: PPUSH
4250: LD_INT 100
4252: PPUSH
4253: CALL 19116 0 5
// veh := CreateVehicle ;
4257: LD_ADDR_VAR 0 3
4261: PUSH
4262: CALL_OW 45
4266: ST_TO_ADDR
// tmp := tmp ^ veh ;
4267: LD_ADDR_VAR 0 4
4271: PUSH
4272: LD_VAR 0 4
4276: PUSH
4277: LD_VAR 0 3
4281: ADD
4282: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4283: LD_VAR 0 3
4287: PPUSH
4288: LD_INT 1
4290: PPUSH
4291: LD_INT 0
4293: PPUSH
4294: CALL_OW 49
// end ;
4298: GO 4206
4300: POP
4301: POP
// arabian_guard := tmp ;
4302: LD_ADDR_EXP 54
4306: PUSH
4307: LD_VAR 0 4
4311: ST_TO_ADDR
// end ;
4312: LD_VAR 0 1
4316: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4317: LD_INT 22
4319: PUSH
4320: LD_INT 7
4322: PUSH
4323: EMPTY
4324: LIST
4325: LIST
4326: PUSH
4327: LD_INT 91
4329: PUSH
4330: LD_INT 1
4332: PUSH
4333: LD_INT 12
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: PPUSH
4345: CALL_OW 69
4349: PUSH
4350: LD_EXP 56
4354: PPUSH
4355: CALL_OW 256
4359: PUSH
4360: LD_INT 990
4362: LESS
4363: OR
4364: PUSH
4365: LD_EXP 55
4369: PPUSH
4370: CALL_OW 256
4374: PUSH
4375: LD_INT 990
4377: LESS
4378: OR
4379: IFFALSE 4522
4381: GO 4383
4383: DISABLE
// begin if IsInUnit ( Abdul ) then
4384: LD_EXP 55
4388: PPUSH
4389: CALL_OW 310
4393: IFFALSE 4404
// ComExitBuilding ( Abdul ) ;
4395: LD_EXP 55
4399: PPUSH
4400: CALL_OW 122
// if Mastodont then
4404: LD_EXP 56
4408: IFFALSE 4425
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4410: LD_EXP 56
4414: PPUSH
4415: LD_INT 205
4417: PPUSH
4418: LD_INT 132
4420: PPUSH
4421: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4425: LD_EXP 55
4429: PPUSH
4430: LD_INT 205
4432: PPUSH
4433: LD_INT 132
4435: PPUSH
4436: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4440: LD_INT 35
4442: PPUSH
4443: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4447: LD_EXP 55
4451: PPUSH
4452: LD_INT 21
4454: PPUSH
4455: CALL_OW 308
4459: IFFALSE 4440
// RemoveUnit ( Abdul ) ;
4461: LD_EXP 55
4465: PPUSH
4466: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4470: LD_INT 35
4472: PPUSH
4473: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4477: LD_EXP 56
4481: PPUSH
4482: LD_INT 21
4484: PPUSH
4485: CALL_OW 308
4489: PUSH
4490: LD_EXP 56
4494: PPUSH
4495: CALL_OW 301
4499: OR
4500: IFFALSE 4470
// if IsOk ( Mastodont ) then
4502: LD_EXP 56
4506: PPUSH
4507: CALL_OW 302
4511: IFFALSE 4522
// RemoveUnit ( Mastodont ) ;
4513: LD_EXP 56
4517: PPUSH
4518: CALL_OW 64
// end ;
4522: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4523: LD_EXP 55
4527: PPUSH
4528: CALL_OW 301
4532: PUSH
4533: LD_INT 22
4535: PUSH
4536: LD_INT 2
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: PUSH
4543: LD_INT 2
4545: PUSH
4546: LD_INT 25
4548: PUSH
4549: LD_INT 1
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 25
4558: PUSH
4559: LD_INT 2
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 25
4568: PUSH
4569: LD_INT 3
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: LD_INT 25
4578: PUSH
4579: LD_INT 4
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PUSH
4586: LD_INT 25
4588: PUSH
4589: LD_INT 8
4591: PUSH
4592: EMPTY
4593: LIST
4594: LIST
4595: PUSH
4596: EMPTY
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: PPUSH
4608: CALL_OW 69
4612: PUSH
4613: LD_INT 16
4615: PUSH
4616: LD_INT 19
4618: PUSH
4619: LD_INT 22
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: LIST
4626: PUSH
4627: LD_OWVAR 67
4631: ARRAY
4632: LESS
4633: OR
4634: IFFALSE 5307
4636: GO 4638
4638: DISABLE
4639: LD_INT 0
4641: PPUSH
4642: PPUSH
4643: PPUSH
4644: PPUSH
4645: PPUSH
4646: PPUSH
// begin MC_Kill ( 1 ) ;
4647: LD_INT 1
4649: PPUSH
4650: CALL 51339 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4654: LD_ADDR_VAR 0 2
4658: PUSH
4659: LD_INT 22
4661: PUSH
4662: LD_INT 2
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: LD_INT 25
4674: PUSH
4675: LD_INT 1
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: LD_INT 25
4684: PUSH
4685: LD_INT 2
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: PUSH
4692: LD_INT 25
4694: PUSH
4695: LD_INT 3
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PUSH
4702: LD_INT 25
4704: PUSH
4705: LD_INT 4
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: LD_INT 25
4714: PUSH
4715: LD_INT 8
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PPUSH
4734: CALL_OW 69
4738: ST_TO_ADDR
// for i in tmp do
4739: LD_ADDR_VAR 0 5
4743: PUSH
4744: LD_VAR 0 2
4748: PUSH
4749: FOR_IN
4750: IFFALSE 4766
// SetTag ( i , 10 ) ;
4752: LD_VAR 0 5
4756: PPUSH
4757: LD_INT 10
4759: PPUSH
4760: CALL_OW 109
4764: GO 4749
4766: POP
4767: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4768: LD_ADDR_VAR 0 3
4772: PUSH
4773: LD_INT 22
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: LD_INT 21
4785: PUSH
4786: LD_INT 1
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: PPUSH
4797: CALL_OW 69
4801: PUSH
4802: LD_VAR 0 2
4806: DIFF
4807: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4808: LD_ADDR_VAR 0 1
4812: PUSH
4813: LD_INT 22
4815: PUSH
4816: LD_INT 2
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: LD_INT 21
4825: PUSH
4826: LD_INT 2
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: PUSH
4833: LD_INT 24
4835: PUSH
4836: LD_INT 300
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: LIST
4847: PPUSH
4848: CALL_OW 69
4852: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4853: LD_ADDR_VAR 0 4
4857: PUSH
4858: LD_VAR 0 1
4862: PPUSH
4863: LD_INT 33
4865: PUSH
4866: LD_INT 1
4868: PUSH
4869: EMPTY
4870: LIST
4871: LIST
4872: PUSH
4873: LD_INT 58
4875: PUSH
4876: EMPTY
4877: LIST
4878: PUSH
4879: EMPTY
4880: LIST
4881: LIST
4882: PPUSH
4883: CALL_OW 72
4887: ST_TO_ADDR
// for i in tmp do
4888: LD_ADDR_VAR 0 5
4892: PUSH
4893: LD_VAR 0 2
4897: PUSH
4898: FOR_IN
4899: IFFALSE 5083
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4901: LD_VAR 0 5
4905: PUSH
4906: LD_INT 55
4908: PUSH
4909: EMPTY
4910: LIST
4911: PPUSH
4912: CALL_OW 69
4916: IN
4917: IFFALSE 4936
// begin AddComMoveXY ( i , 209 , 132 ) ;
4919: LD_VAR 0 5
4923: PPUSH
4924: LD_INT 209
4926: PPUSH
4927: LD_INT 132
4929: PPUSH
4930: CALL_OW 171
// continue ;
4934: GO 4898
// end ; if IsInUnit ( i ) then
4936: LD_VAR 0 5
4940: PPUSH
4941: CALL_OW 310
4945: IFFALSE 4963
// begin ComExitBuilding ( i ) ;
4947: LD_VAR 0 5
4951: PPUSH
4952: CALL_OW 122
// wait ( 3 ) ;
4956: LD_INT 3
4958: PPUSH
4959: CALL_OW 67
// end ; if tmp_empty then
4963: LD_VAR 0 4
4967: IFFALSE 5066
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4969: LD_VAR 0 5
4973: PPUSH
4974: LD_VAR 0 4
4978: PPUSH
4979: LD_VAR 0 5
4983: PPUSH
4984: CALL_OW 74
4988: PPUSH
4989: CALL_OW 296
4993: PUSH
4994: LD_INT 25
4996: LESS
4997: IFFALSE 5066
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4999: LD_ADDR_VAR 0 6
5003: PUSH
5004: LD_VAR 0 4
5008: PPUSH
5009: LD_VAR 0 5
5013: PPUSH
5014: CALL_OW 74
5018: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5019: LD_VAR 0 5
5023: PPUSH
5024: LD_VAR 0 6
5028: PPUSH
5029: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5033: LD_VAR 0 5
5037: PPUSH
5038: LD_INT 209
5040: PPUSH
5041: LD_INT 132
5043: PPUSH
5044: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5048: LD_ADDR_VAR 0 4
5052: PUSH
5053: LD_VAR 0 4
5057: PUSH
5058: LD_VAR 0 6
5062: DIFF
5063: ST_TO_ADDR
// continue ;
5064: GO 4898
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5066: LD_VAR 0 5
5070: PPUSH
5071: LD_INT 201
5073: PPUSH
5074: LD_INT 132
5076: PPUSH
5077: CALL_OW 171
// end ;
5081: GO 4898
5083: POP
5084: POP
// for i in tmp_ape do
5085: LD_ADDR_VAR 0 5
5089: PUSH
5090: LD_VAR 0 3
5094: PUSH
5095: FOR_IN
5096: IFFALSE 5135
// begin if IsInUnit ( i ) then
5098: LD_VAR 0 5
5102: PPUSH
5103: CALL_OW 310
5107: IFFALSE 5118
// ComExitBuilding ( i ) ;
5109: LD_VAR 0 5
5113: PPUSH
5114: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5118: LD_VAR 0 5
5122: PPUSH
5123: LD_INT 201
5125: PPUSH
5126: LD_INT 132
5128: PPUSH
5129: CALL_OW 171
// end ;
5133: GO 5095
5135: POP
5136: POP
// repeat wait ( 0 0$1 ) ;
5137: LD_INT 35
5139: PPUSH
5140: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5144: LD_ADDR_VAR 0 5
5148: PUSH
5149: LD_VAR 0 2
5153: PUSH
5154: LD_VAR 0 3
5158: UNION
5159: PUSH
5160: LD_VAR 0 1
5164: UNION
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5198
// if not HasTask ( i ) then
5169: LD_VAR 0 5
5173: PPUSH
5174: CALL_OW 314
5178: NOT
5179: IFFALSE 5196
// ComMoveXY ( i , 201 , 132 ) ;
5181: LD_VAR 0 5
5185: PPUSH
5186: LD_INT 201
5188: PPUSH
5189: LD_INT 132
5191: PPUSH
5192: CALL_OW 111
5196: GO 5166
5198: POP
5199: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5200: LD_INT 21
5202: PPUSH
5203: LD_INT 22
5205: PUSH
5206: LD_INT 2
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL_OW 70
5217: IFFALSE 5258
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5219: LD_ADDR_VAR 0 5
5223: PUSH
5224: LD_INT 21
5226: PPUSH
5227: LD_INT 22
5229: PUSH
5230: LD_INT 2
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: PPUSH
5237: CALL_OW 70
5241: PUSH
5242: FOR_IN
5243: IFFALSE 5256
// RemoveUnit ( i ) ;
5245: LD_VAR 0 5
5249: PPUSH
5250: CALL_OW 64
5254: GO 5242
5256: POP
5257: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5258: LD_INT 22
5260: PUSH
5261: LD_INT 2
5263: PUSH
5264: EMPTY
5265: LIST
5266: LIST
5267: PUSH
5268: LD_INT 2
5270: PUSH
5271: LD_INT 21
5273: PUSH
5274: LD_INT 1
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PUSH
5281: LD_INT 21
5283: PUSH
5284: LD_INT 2
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: LIST
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 69
5304: NOT
5305: IFFALSE 5137
// end ;
5307: PPOPN 6
5309: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5310: LD_EXP 9
5314: PUSH
5315: LD_INT 92
5317: PPUSH
5318: LD_INT 40
5320: PPUSH
5321: CALL_OW 428
5325: PPUSH
5326: CALL_OW 266
5330: PUSH
5331: LD_INT 30
5333: EQUAL
5334: AND
5335: IFFALSE 5531
5337: GO 5339
5339: DISABLE
5340: LD_INT 0
5342: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5343: LD_ADDR_VAR 0 1
5347: PUSH
5348: LD_EXP 59
5352: PUSH
5353: LD_INT 1
5355: ARRAY
5356: PPUSH
5357: LD_INT 25
5359: PUSH
5360: LD_INT 4
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PPUSH
5367: CALL_OW 72
5371: ST_TO_ADDR
// if not sci then
5372: LD_VAR 0 1
5376: NOT
5377: IFFALSE 5381
// exit ;
5379: GO 5531
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5381: LD_ADDR_EXP 59
5385: PUSH
5386: LD_EXP 59
5390: PPUSH
5391: LD_INT 1
5393: PPUSH
5394: LD_EXP 59
5398: PUSH
5399: LD_INT 1
5401: ARRAY
5402: PUSH
5403: LD_VAR 0 1
5407: PUSH
5408: LD_INT 1
5410: ARRAY
5411: DIFF
5412: PPUSH
5413: CALL_OW 1
5417: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5418: LD_VAR 0 1
5422: PUSH
5423: LD_INT 1
5425: ARRAY
5426: PPUSH
5427: CALL_OW 310
5431: IFFALSE 5446
// ComExitBuilding ( sci [ 1 ] ) ;
5433: LD_VAR 0 1
5437: PUSH
5438: LD_INT 1
5440: ARRAY
5441: PPUSH
5442: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5446: LD_INT 2
5448: PPUSH
5449: LD_INT 105
5451: PPUSH
5452: LD_INT 14
5454: PPUSH
5455: LD_INT 20
5457: PPUSH
5458: CALL 20134 0 4
5462: PUSH
5463: LD_INT 4
5465: ARRAY
5466: PUSH
5467: LD_INT 10
5469: LESS
5470: IFFALSE 5493
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5472: LD_VAR 0 1
5476: PUSH
5477: LD_INT 1
5479: ARRAY
5480: PPUSH
5481: LD_INT 105
5483: PPUSH
5484: LD_INT 14
5486: PPUSH
5487: CALL_OW 171
5491: GO 5512
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5493: LD_VAR 0 1
5497: PUSH
5498: LD_INT 1
5500: ARRAY
5501: PPUSH
5502: LD_INT 118
5504: PPUSH
5505: LD_INT 77
5507: PPUSH
5508: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5512: LD_VAR 0 1
5516: PUSH
5517: LD_INT 1
5519: ARRAY
5520: PPUSH
5521: LD_INT 92
5523: PPUSH
5524: LD_INT 40
5526: PPUSH
5527: CALL_OW 218
// end ;
5531: PPOPN 1
5533: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5534: LD_INT 1
5536: PPUSH
5537: CALL_OW 302
5541: PUSH
5542: LD_EXP 9
5546: AND
5547: IFFALSE 6006
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
5557: PPUSH
5558: PPUSH
5559: PPUSH
// begin enable ;
5560: ENABLE
// base := 1 ;
5561: LD_ADDR_VAR 0 2
5565: PUSH
5566: LD_INT 1
5568: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5569: LD_ADDR_VAR 0 4
5573: PUSH
5574: LD_INT 0
5576: PUSH
5577: LD_INT 0
5579: PUSH
5580: LD_INT 0
5582: PUSH
5583: LD_INT 0
5585: PUSH
5586: LD_INT 0
5588: PUSH
5589: LD_INT 0
5591: PUSH
5592: LD_INT 0
5594: PUSH
5595: LD_INT 0
5597: PUSH
5598: LD_INT 1
5600: PUSH
5601: LD_INT 0
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: LIST
5614: LIST
5615: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5616: LD_ADDR_VAR 0 3
5620: PUSH
5621: LD_INT 14
5623: PUSH
5624: LD_INT 1
5626: PUSH
5627: LD_INT 2
5629: PUSH
5630: LD_INT 26
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: PUSH
5639: LD_INT 14
5641: PUSH
5642: LD_INT 1
5644: PUSH
5645: LD_INT 2
5647: PUSH
5648: LD_INT 28
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: LD_INT 13
5659: PUSH
5660: LD_INT 1
5662: PUSH
5663: LD_INT 2
5665: PUSH
5666: LD_INT 29
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: LIST
5679: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5680: LD_ADDR_VAR 0 1
5684: PUSH
5685: DOUBLE
5686: LD_INT 1
5688: DEC
5689: ST_TO_ADDR
5690: LD_OWVAR 67
5694: PUSH
5695: LD_OWVAR 1
5699: PUSH
5700: LD_INT 21000
5702: DIV
5703: PLUS
5704: PUSH
5705: FOR_TO
5706: IFFALSE 5798
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5708: LD_ADDR_VAR 0 3
5712: PUSH
5713: LD_VAR 0 3
5717: PPUSH
5718: LD_VAR 0 3
5722: PUSH
5723: LD_INT 1
5725: PLUS
5726: PPUSH
5727: LD_INT 13
5729: PUSH
5730: LD_INT 14
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: PUSH
5737: LD_INT 1
5739: PPUSH
5740: LD_INT 2
5742: PPUSH
5743: CALL_OW 12
5747: ARRAY
5748: PUSH
5749: LD_INT 1
5751: PUSH
5752: LD_INT 2
5754: PUSH
5755: LD_INT 28
5757: PUSH
5758: LD_INT 29
5760: PUSH
5761: LD_INT 25
5763: PUSH
5764: LD_INT 26
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_INT 1
5775: PPUSH
5776: LD_INT 4
5778: PPUSH
5779: CALL_OW 12
5783: ARRAY
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PPUSH
5791: CALL_OW 2
5795: ST_TO_ADDR
5796: GO 5705
5798: POP
5799: POP
// MC_InsertProduceList ( base , tmp ) ;
5800: LD_VAR 0 2
5804: PPUSH
5805: LD_VAR 0 3
5809: PPUSH
5810: CALL 74783 0 2
// repeat wait ( 0 0$1 ) ;
5814: LD_INT 35
5816: PPUSH
5817: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5821: LD_EXP 78
5825: PUSH
5826: LD_VAR 0 2
5830: ARRAY
5831: PUSH
5832: LD_INT 6
5834: GREATER
5835: IFFALSE 5814
// wait ( 0 0$20 ) ;
5837: LD_INT 700
5839: PPUSH
5840: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5844: LD_ADDR_VAR 0 5
5848: PUSH
5849: LD_INT 124
5851: PUSH
5852: LD_INT 85
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: LD_INT 90
5861: PUSH
5862: LD_INT 61
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: PUSH
5869: LD_INT 69
5871: PUSH
5872: LD_INT 48
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: PUSH
5879: LD_INT 68
5881: PUSH
5882: LD_INT 48
5884: PUSH
5885: EMPTY
5886: LIST
5887: LIST
5888: PUSH
5889: EMPTY
5890: LIST
5891: LIST
5892: LIST
5893: LIST
5894: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5895: LD_ADDR_VAR 0 6
5899: PUSH
5900: LD_EXP 78
5904: PUSH
5905: LD_VAR 0 2
5909: ARRAY
5910: PUSH
5911: LD_EXP 78
5915: PUSH
5916: LD_VAR 0 2
5920: ARRAY
5921: PPUSH
5922: LD_INT 34
5924: PUSH
5925: LD_INT 32
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL_OW 72
5936: DIFF
5937: ST_TO_ADDR
// if not attackers then
5938: LD_VAR 0 6
5942: NOT
5943: IFFALSE 5947
// exit ;
5945: GO 6006
// ar_attackers := attackers ;
5947: LD_ADDR_EXP 10
5951: PUSH
5952: LD_VAR 0 6
5956: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5957: LD_INT 35
5959: PPUSH
5960: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5964: LD_VAR 0 6
5968: PPUSH
5969: LD_INT 60
5971: PUSH
5972: EMPTY
5973: LIST
5974: PPUSH
5975: CALL_OW 72
5979: NOT
5980: IFFALSE 5957
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5982: LD_VAR 0 2
5986: PPUSH
5987: LD_VAR 0 6
5991: PPUSH
5992: LD_VAR 0 5
5996: PPUSH
5997: LD_VAR 0 4
6001: PPUSH
6002: CALL 74968 0 4
// end ;
6006: PPOPN 6
6008: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6009: LD_INT 1
6011: PPUSH
6012: CALL_OW 302
6016: PUSH
6017: LD_EXP 9
6021: AND
6022: PUSH
6023: LD_EXP 49
6027: PPUSH
6028: LD_INT 22
6030: PPUSH
6031: CALL_OW 308
6035: AND
6036: PUSH
6037: LD_INT 1
6039: PPUSH
6040: CALL 75131 0 1
6044: PUSH
6045: LD_INT 0
6047: EQUAL
6048: AND
6049: PUSH
6050: LD_EXP 10
6054: NOT
6055: AND
6056: IFFALSE 6520
6058: GO 6060
6060: DISABLE
6061: LD_INT 0
6063: PPUSH
6064: PPUSH
6065: PPUSH
6066: PPUSH
6067: PPUSH
6068: PPUSH
6069: PPUSH
// begin base := 1 ;
6070: LD_ADDR_VAR 0 2
6074: PUSH
6075: LD_INT 1
6077: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6078: LD_ADDR_VAR 0 4
6082: PUSH
6083: LD_INT 0
6085: PUSH
6086: LD_INT 0
6088: PUSH
6089: LD_INT 0
6091: PUSH
6092: LD_INT 0
6094: PUSH
6095: LD_INT 0
6097: PUSH
6098: LD_INT 0
6100: PUSH
6101: LD_INT 0
6103: PUSH
6104: LD_INT 0
6106: PUSH
6107: LD_INT 1
6109: PUSH
6110: LD_INT 0
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6125: LD_ADDR_VAR 0 3
6129: PUSH
6130: LD_INT 13
6132: PUSH
6133: LD_INT 1
6135: PUSH
6136: LD_INT 2
6138: PUSH
6139: LD_INT 28
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 13
6150: PUSH
6151: LD_INT 1
6153: PUSH
6154: LD_INT 2
6156: PUSH
6157: LD_INT 27
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: PUSH
6166: LD_INT 13
6168: PUSH
6169: LD_INT 1
6171: PUSH
6172: LD_INT 2
6174: PUSH
6175: LD_INT 25
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 11
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 2
6192: PUSH
6193: LD_INT 24
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: PUSH
6202: LD_INT 11
6204: PUSH
6205: LD_INT 2
6207: PUSH
6208: LD_INT 2
6210: PUSH
6211: LD_INT 24
6213: PUSH
6214: EMPTY
6215: LIST
6216: LIST
6217: LIST
6218: LIST
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6227: LD_VAR 0 2
6231: PPUSH
6232: LD_VAR 0 3
6236: PPUSH
6237: CALL 74783 0 2
// repeat wait ( 0 0$1 ) ;
6241: LD_INT 35
6243: PPUSH
6244: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6248: LD_EXP 78
6252: PUSH
6253: LD_VAR 0 2
6257: ARRAY
6258: PUSH
6259: LD_INT 6
6261: GREATEREQUAL
6262: IFFALSE 6241
// wait ( 0 0$20 ) ;
6264: LD_INT 700
6266: PPUSH
6267: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6271: LD_ADDR_VAR 0 5
6275: PUSH
6276: LD_INT 119
6278: PUSH
6279: LD_INT 9
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: PUSH
6286: EMPTY
6287: LIST
6288: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6289: LD_ADDR_VAR 0 6
6293: PUSH
6294: LD_EXP 78
6298: PUSH
6299: LD_VAR 0 2
6303: ARRAY
6304: PUSH
6305: LD_EXP 78
6309: PUSH
6310: LD_VAR 0 2
6314: ARRAY
6315: PPUSH
6316: LD_INT 34
6318: PUSH
6319: LD_INT 32
6321: PUSH
6322: EMPTY
6323: LIST
6324: LIST
6325: PPUSH
6326: CALL_OW 72
6330: DIFF
6331: ST_TO_ADDR
// if not attackers then
6332: LD_VAR 0 6
6336: NOT
6337: IFFALSE 6341
// exit ;
6339: GO 6520
// uc_side := 2 ;
6341: LD_ADDR_OWVAR 20
6345: PUSH
6346: LD_INT 2
6348: ST_TO_ADDR
// uc_nation := 2 ;
6349: LD_ADDR_OWVAR 21
6353: PUSH
6354: LD_INT 2
6356: ST_TO_ADDR
// InitHc ;
6357: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6361: LD_ADDR_VAR 0 1
6365: PUSH
6366: DOUBLE
6367: LD_INT 1
6369: DEC
6370: ST_TO_ADDR
6371: LD_INT 4
6373: PUSH
6374: LD_INT 5
6376: PUSH
6377: LD_INT 6
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: LD_OWVAR 67
6389: ARRAY
6390: PUSH
6391: FOR_TO
6392: IFFALSE 6469
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6394: LD_INT 0
6396: PPUSH
6397: LD_INT 15
6399: PUSH
6400: LD_INT 17
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: CALL_OW 12
6417: ARRAY
6418: PPUSH
6419: LD_INT 8
6421: PPUSH
6422: CALL_OW 380
// un := CreateHuman ;
6426: LD_ADDR_VAR 0 7
6430: PUSH
6431: CALL_OW 44
6435: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6436: LD_VAR 0 7
6440: PPUSH
6441: LD_INT 23
6443: PPUSH
6444: LD_INT 0
6446: PPUSH
6447: CALL_OW 49
// attackers := attackers union un ;
6451: LD_ADDR_VAR 0 6
6455: PUSH
6456: LD_VAR 0 6
6460: PUSH
6461: LD_VAR 0 7
6465: UNION
6466: ST_TO_ADDR
// end ;
6467: GO 6391
6469: POP
6470: POP
// repeat wait ( 0 0$1 ) ;
6471: LD_INT 35
6473: PPUSH
6474: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6478: LD_VAR 0 6
6482: PPUSH
6483: LD_INT 60
6485: PUSH
6486: EMPTY
6487: LIST
6488: PPUSH
6489: CALL_OW 72
6493: NOT
6494: IFFALSE 6471
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6496: LD_VAR 0 2
6500: PPUSH
6501: LD_VAR 0 6
6505: PPUSH
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 4
6515: PPUSH
6516: CALL 74968 0 4
// end ; end_of_file
6520: PPOPN 7
6522: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6523: LD_INT 0
6525: PPUSH
6526: PPUSH
6527: PPUSH
6528: PPUSH
// uc_side := 1 ;
6529: LD_ADDR_OWVAR 20
6533: PUSH
6534: LD_INT 1
6536: ST_TO_ADDR
// uc_nation := 1 ;
6537: LD_ADDR_OWVAR 21
6541: PUSH
6542: LD_INT 1
6544: ST_TO_ADDR
// InitHc ;
6545: CALL_OW 19
// InitVc ;
6549: CALL_OW 20
// tmp := [ ] ;
6553: LD_ADDR_VAR 0 3
6557: PUSH
6558: EMPTY
6559: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6560: LD_ADDR_VAR 0 2
6564: PUSH
6565: DOUBLE
6566: LD_INT 1
6568: DEC
6569: ST_TO_ADDR
6570: LD_INT 5
6572: PUSH
6573: LD_INT 6
6575: PUSH
6576: LD_INT 6
6578: PUSH
6579: EMPTY
6580: LIST
6581: LIST
6582: LIST
6583: PUSH
6584: LD_OWVAR 67
6588: ARRAY
6589: PUSH
6590: FOR_TO
6591: IFFALSE 6728
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6593: LD_INT 2
6595: PUSH
6596: LD_INT 4
6598: PUSH
6599: LD_INT 5
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: LIST
6606: PUSH
6607: LD_INT 1
6609: PPUSH
6610: LD_INT 3
6612: PPUSH
6613: CALL_OW 12
6617: ARRAY
6618: PPUSH
6619: LD_INT 1
6621: PUSH
6622: LD_INT 3
6624: PUSH
6625: EMPTY
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 1
6631: PPUSH
6632: LD_INT 2
6634: PPUSH
6635: CALL_OW 12
6639: ARRAY
6640: PPUSH
6641: LD_INT 3
6643: PPUSH
6644: LD_INT 9
6646: PUSH
6647: LD_INT 7
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 1
6656: PPUSH
6657: LD_INT 2
6659: PPUSH
6660: CALL_OW 12
6664: ARRAY
6665: PPUSH
6666: LD_INT 78
6668: PPUSH
6669: CALL 19116 0 5
// veh := CreateVehicle ;
6673: LD_ADDR_VAR 0 4
6677: PUSH
6678: CALL_OW 45
6682: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6683: LD_VAR 0 4
6687: PPUSH
6688: LD_INT 2
6690: PPUSH
6691: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6695: LD_VAR 0 4
6699: PPUSH
6700: LD_INT 17
6702: PPUSH
6703: LD_INT 0
6705: PPUSH
6706: CALL_OW 49
// tmp := tmp ^ veh ;
6710: LD_ADDR_VAR 0 3
6714: PUSH
6715: LD_VAR 0 3
6719: PUSH
6720: LD_VAR 0 4
6724: ADD
6725: ST_TO_ADDR
// end ;
6726: GO 6590
6728: POP
6729: POP
// if not tmp then
6730: LD_VAR 0 3
6734: NOT
6735: IFFALSE 6739
// exit ;
6737: GO 6848
// if not first_powell_attack then
6739: LD_EXP 11
6743: NOT
6744: IFFALSE 6754
// first_powell_attack := true ;
6746: LD_ADDR_EXP 11
6750: PUSH
6751: LD_INT 1
6753: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6754: LD_INT 70
6756: PPUSH
6757: CALL_OW 67
// for i in tmp do
6761: LD_ADDR_VAR 0 2
6765: PUSH
6766: LD_VAR 0 3
6770: PUSH
6771: FOR_IN
6772: IFFALSE 6839
// if IsOk ( i ) then
6774: LD_VAR 0 2
6778: PPUSH
6779: CALL_OW 302
6783: IFFALSE 6821
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6785: LD_VAR 0 2
6789: PPUSH
6790: LD_INT 81
6792: PUSH
6793: LD_INT 1
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: PPUSH
6800: CALL_OW 69
6804: PPUSH
6805: LD_VAR 0 2
6809: PPUSH
6810: CALL_OW 74
6814: PPUSH
6815: CALL_OW 115
6819: GO 6837
// tmp := tmp diff i ;
6821: LD_ADDR_VAR 0 3
6825: PUSH
6826: LD_VAR 0 3
6830: PUSH
6831: LD_VAR 0 2
6835: DIFF
6836: ST_TO_ADDR
6837: GO 6771
6839: POP
6840: POP
// until not tmp ;
6841: LD_VAR 0 3
6845: NOT
6846: IFFALSE 6754
// end ; end_of_file
6848: LD_VAR 0 1
6852: RET
// export function Action ; var tmp , i , un ; begin
6853: LD_INT 0
6855: PPUSH
6856: PPUSH
6857: PPUSH
6858: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6859: LD_INT 68
6861: PPUSH
6862: LD_INT 39
6864: PPUSH
6865: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6869: LD_ADDR_VAR 0 2
6873: PUSH
6874: LD_INT 22
6876: PUSH
6877: LD_INT 7
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: PPUSH
6884: CALL_OW 69
6888: ST_TO_ADDR
// InGameOn ;
6889: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6893: LD_VAR 0 2
6897: PPUSH
6898: LD_INT 71
6900: PPUSH
6901: LD_INT 49
6903: PPUSH
6904: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6908: LD_INT 35
6910: PPUSH
6911: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6915: LD_INT 7
6917: PPUSH
6918: LD_INT 71
6920: PPUSH
6921: LD_INT 51
6923: PPUSH
6924: CALL_OW 293
6928: IFFALSE 6908
// DialogueOn ;
6930: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6934: LD_EXP 15
6938: PPUSH
6939: LD_STRING D1-JMM-1
6941: PPUSH
6942: CALL_OW 88
// if Joan then
6946: LD_EXP 30
6950: IFFALSE 6964
// Say ( Joan , D1-Joan-1 ) ;
6952: LD_EXP 30
6956: PPUSH
6957: LD_STRING D1-Joan-1
6959: PPUSH
6960: CALL_OW 88
// if Lisa then
6964: LD_EXP 17
6968: IFFALSE 6982
// Say ( Lisa , D1-Lisa-1 ) ;
6970: LD_EXP 17
6974: PPUSH
6975: LD_STRING D1-Lisa-1
6977: PPUSH
6978: CALL_OW 88
// if Joan or Lisa then
6982: LD_EXP 30
6986: PUSH
6987: LD_EXP 17
6991: OR
6992: IFFALSE 7006
// Say ( JMM , D1-JMM-2 ) ;
6994: LD_EXP 15
6998: PPUSH
6999: LD_STRING D1-JMM-2
7001: PPUSH
7002: CALL_OW 88
// DialogueOff ;
7006: CALL_OW 7
// InGameOff ;
7010: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7014: LD_INT 71
7016: PPUSH
7017: LD_INT 50
7019: PPUSH
7020: LD_INT 7
7022: PPUSH
7023: LD_INT 30
7025: NEG
7026: PPUSH
7027: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7031: LD_INT 71
7033: PPUSH
7034: LD_INT 50
7036: PPUSH
7037: LD_INT 7
7039: PPUSH
7040: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7044: LD_STRING M1
7046: PPUSH
7047: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7051: LD_INT 35
7053: PPUSH
7054: CALL_OW 67
// until freedom ;
7058: LD_EXP 3
7062: IFFALSE 7051
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7064: LD_INT 350
7066: PPUSH
7067: LD_INT 700
7069: PPUSH
7070: CALL_OW 12
7074: PPUSH
7075: CALL_OW 67
// PrepareGossudarov ;
7079: CALL 1802 0 0
// repeat wait ( 0 0$1 ) ;
7083: LD_INT 35
7085: PPUSH
7086: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7090: LD_INT 22
7092: PUSH
7093: LD_INT 6
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 24
7105: PUSH
7106: LD_INT 1000
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: PPUSH
7121: CALL_OW 69
7125: PUSH
7126: LD_INT 7
7128: PPUSH
7129: LD_EXP 32
7133: PPUSH
7134: CALL_OW 292
7138: OR
7139: IFFALSE 7083
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7141: LD_ADDR_VAR 0 2
7145: PUSH
7146: LD_INT 22
7148: PUSH
7149: LD_INT 6
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PPUSH
7156: CALL_OW 69
7160: ST_TO_ADDR
// for i in tmp do
7161: LD_ADDR_VAR 0 3
7165: PUSH
7166: LD_VAR 0 2
7170: PUSH
7171: FOR_IN
7172: IFFALSE 7188
// SetSide ( i , 7 ) ;
7174: LD_VAR 0 3
7178: PPUSH
7179: LD_INT 7
7181: PPUSH
7182: CALL_OW 235
7186: GO 7171
7188: POP
7189: POP
// DialogueOn ;
7190: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7194: LD_EXP 15
7198: PUSH
7199: LD_EXP 16
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: PPUSH
7208: LD_EXP 32
7212: PPUSH
7213: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7217: LD_EXP 32
7221: PPUSH
7222: CALL_OW 87
// if not Roth then
7226: LD_EXP 16
7230: NOT
7231: IFFALSE 7323
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7233: LD_VAR 0 2
7237: PPUSH
7238: LD_INT 3
7240: PUSH
7241: LD_INT 24
7243: PUSH
7244: LD_INT 1000
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PPUSH
7255: CALL_OW 72
7259: IFFALSE 7273
// Say ( JMM , D2-JMM-1 ) ;
7261: LD_EXP 15
7265: PPUSH
7266: LD_STRING D2-JMM-1
7268: PPUSH
7269: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7273: LD_EXP 15
7277: PPUSH
7278: LD_STRING D2-JMM-1b
7280: PPUSH
7281: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7285: LD_EXP 32
7289: PPUSH
7290: LD_STRING D2-Gos-1
7292: PPUSH
7293: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7297: LD_EXP 15
7301: PPUSH
7302: LD_STRING D2-JMM-2
7304: PPUSH
7305: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7309: LD_EXP 32
7313: PPUSH
7314: LD_STRING D2-Gos-2
7316: PPUSH
7317: CALL_OW 88
// end else
7321: GO 7475
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7323: LD_VAR 0 2
7327: PPUSH
7328: LD_INT 3
7330: PUSH
7331: LD_INT 24
7333: PUSH
7334: LD_INT 1000
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL_OW 72
7349: IFFALSE 7375
// begin Say ( Roth , D2-Roth-2 ) ;
7351: LD_EXP 16
7355: PPUSH
7356: LD_STRING D2-Roth-2
7358: PPUSH
7359: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7363: LD_EXP 15
7367: PPUSH
7368: LD_STRING D2-JMM-1a
7370: PPUSH
7371: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7375: LD_EXP 16
7379: PPUSH
7380: LD_STRING D2-Roth-2a
7382: PPUSH
7383: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7387: LD_EXP 16
7391: PPUSH
7392: LD_STRING D2-Roth-2b
7394: PPUSH
7395: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7399: LD_EXP 15
7403: PPUSH
7404: LD_STRING D2-JMM-3
7406: PPUSH
7407: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7411: LD_VAR 0 2
7415: PPUSH
7416: LD_INT 3
7418: PUSH
7419: LD_INT 24
7421: PUSH
7422: LD_INT 1000
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: PPUSH
7433: CALL_OW 72
7437: IFFALSE 7475
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7439: LD_EXP 32
7443: PPUSH
7444: LD_STRING D2-Gos-3
7446: PPUSH
7447: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7451: LD_EXP 15
7455: PPUSH
7456: LD_STRING D2-JMM-4
7458: PPUSH
7459: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7463: LD_EXP 32
7467: PPUSH
7468: LD_STRING D2-Gos-4
7470: PPUSH
7471: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7475: LD_EXP 15
7479: PPUSH
7480: LD_STRING D2-JMM-5
7482: PPUSH
7483: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7487: LD_EXP 32
7491: PPUSH
7492: LD_STRING D2-Gos-5
7494: PPUSH
7495: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7499: LD_EXP 15
7503: PPUSH
7504: LD_STRING D2-JMM-6
7506: PPUSH
7507: CALL_OW 88
// DialogueOff ;
7511: CALL_OW 7
// wait ( 0 0$2 ) ;
7515: LD_INT 70
7517: PPUSH
7518: CALL_OW 67
// if Kirilenkova then
7522: LD_EXP 33
7526: IFFALSE 7540
// Say ( Kirilenkova , D3-Kir-1 ) ;
7528: LD_EXP 33
7532: PPUSH
7533: LD_STRING D3-Kir-1
7535: PPUSH
7536: CALL_OW 88
// gossudarov_arrive := true ;
7540: LD_ADDR_EXP 4
7544: PUSH
7545: LD_INT 1
7547: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7548: LD_INT 35
7550: PPUSH
7551: CALL_OW 67
// until ru_lab_builded ;
7555: LD_EXP 5
7559: IFFALSE 7548
// DialogueOn ;
7561: CALL_OW 6
// if Kirilenkova then
7565: LD_EXP 33
7569: IFFALSE 7585
// Say ( Kirilenkova , D3a-Kir-1 ) else
7571: LD_EXP 33
7575: PPUSH
7576: LD_STRING D3a-Kir-1
7578: PPUSH
7579: CALL_OW 88
7583: GO 7607
// begin un := SciRu ;
7585: LD_ADDR_VAR 0 4
7589: PUSH
7590: CALL 12719 0 0
7594: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7595: LD_VAR 0 4
7599: PPUSH
7600: LD_STRING D3a-Sci1-1
7602: PPUSH
7603: CALL_OW 88
// end ; if Kirilenkova or un then
7607: LD_EXP 33
7611: PUSH
7612: LD_VAR 0 4
7616: OR
7617: IFFALSE 7631
// Say ( JMM , D3a-JMM-1 ) ;
7619: LD_EXP 15
7623: PPUSH
7624: LD_STRING D3a-JMM-1
7626: PPUSH
7627: CALL_OW 88
// DialogueOff ;
7631: CALL_OW 7
// end ;
7635: LD_VAR 0 1
7639: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7640: LD_EXP 4
7644: PUSH
7645: LD_INT 22
7647: PUSH
7648: LD_INT 7
7650: PUSH
7651: EMPTY
7652: LIST
7653: LIST
7654: PUSH
7655: LD_INT 2
7657: PUSH
7658: LD_INT 25
7660: PUSH
7661: LD_INT 1
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: LD_INT 25
7670: PUSH
7671: LD_INT 2
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: PUSH
7678: LD_INT 25
7680: PUSH
7681: LD_INT 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: LD_INT 25
7690: PUSH
7691: LD_INT 4
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: LD_INT 5
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: PUSH
7708: LD_INT 25
7710: PUSH
7711: LD_INT 8
7713: PUSH
7714: EMPTY
7715: LIST
7716: LIST
7717: PUSH
7718: LD_INT 25
7720: PUSH
7721: LD_INT 9
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: LIST
7736: LIST
7737: PUSH
7738: EMPTY
7739: LIST
7740: LIST
7741: PPUSH
7742: CALL_OW 69
7746: PUSH
7747: LD_INT 7
7749: LESS
7750: AND
7751: IFFALSE 7763
7753: GO 7755
7755: DISABLE
// YouLost ( TooMany ) ;
7756: LD_STRING TooMany
7758: PPUSH
7759: CALL_OW 104
7763: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7764: LD_EXP 32
7768: PPUSH
7769: CALL_OW 255
7773: PUSH
7774: LD_INT 7
7776: EQUAL
7777: IFFALSE 7977
7779: GO 7781
7781: DISABLE
7782: LD_INT 0
7784: PPUSH
7785: PPUSH
7786: PPUSH
// begin uc_side := 3 ;
7787: LD_ADDR_OWVAR 20
7791: PUSH
7792: LD_INT 3
7794: ST_TO_ADDR
// uc_nation := 3 ;
7795: LD_ADDR_OWVAR 21
7799: PUSH
7800: LD_INT 3
7802: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7803: LD_INT 21
7805: PPUSH
7806: LD_INT 3
7808: PPUSH
7809: LD_INT 3
7811: PPUSH
7812: LD_INT 42
7814: PPUSH
7815: LD_INT 100
7817: PPUSH
7818: CALL 19116 0 5
// un := CreateVehicle ;
7822: LD_ADDR_VAR 0 3
7826: PUSH
7827: CALL_OW 45
7831: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7832: LD_VAR 0 3
7836: PPUSH
7837: LD_INT 15
7839: PPUSH
7840: LD_INT 0
7842: PPUSH
7843: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7847: LD_VAR 0 3
7851: PPUSH
7852: LD_INT 67
7854: PPUSH
7855: LD_INT 45
7857: PPUSH
7858: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7862: LD_VAR 0 3
7866: PPUSH
7867: LD_INT 70
7869: PPUSH
7870: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7874: LD_VAR 0 3
7878: PPUSH
7879: LD_INT 69
7881: PPUSH
7882: LD_INT 18
7884: PPUSH
7885: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7889: LD_VAR 0 3
7893: PPUSH
7894: LD_INT 60
7896: PPUSH
7897: LD_INT 2
7899: PPUSH
7900: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7904: LD_INT 35
7906: PPUSH
7907: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7911: LD_VAR 0 3
7915: PPUSH
7916: CALL_OW 302
7920: NOT
7921: PUSH
7922: LD_VAR 0 3
7926: PPUSH
7927: LD_INT 17
7929: PPUSH
7930: CALL_OW 308
7934: OR
7935: IFFALSE 7904
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7937: LD_VAR 0 3
7941: PPUSH
7942: LD_INT 17
7944: PPUSH
7945: CALL_OW 308
7949: PUSH
7950: LD_VAR 0 3
7954: PPUSH
7955: LD_INT 60
7957: PPUSH
7958: LD_INT 2
7960: PPUSH
7961: CALL_OW 307
7965: OR
7966: IFFALSE 7977
// RemoveUnit ( un ) ;
7968: LD_VAR 0 3
7972: PPUSH
7973: CALL_OW 64
// end ;
7977: PPOPN 3
7979: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
7980: LD_EXP 4
7984: IFFALSE 8226
7986: GO 7988
7988: DISABLE
7989: LD_INT 0
7991: PPUSH
7992: PPUSH
7993: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7994: LD_INT 70
7996: PPUSH
7997: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8001: LD_ADDR_VAR 0 3
8005: PUSH
8006: LD_INT 22
8008: PUSH
8009: LD_INT 7
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: LD_INT 101
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: PPUSH
8030: CALL_OW 69
8034: ST_TO_ADDR
// until tmp ;
8035: LD_VAR 0 3
8039: IFFALSE 7994
// un := NearestUnitToUnit ( tmp , JMM ) ;
8041: LD_ADDR_VAR 0 2
8045: PUSH
8046: LD_VAR 0 3
8050: PPUSH
8051: LD_EXP 15
8055: PPUSH
8056: CALL_OW 74
8060: ST_TO_ADDR
// player_spotted := true ;
8061: LD_ADDR_EXP 6
8065: PUSH
8066: LD_INT 1
8068: ST_TO_ADDR
// tmp := SciRu ;
8069: LD_ADDR_VAR 0 3
8073: PUSH
8074: CALL 12719 0 0
8078: ST_TO_ADDR
// if not tmp then
8079: LD_VAR 0 3
8083: NOT
8084: IFFALSE 8096
// tmp := SolRu ;
8086: LD_ADDR_VAR 0 3
8090: PUSH
8091: CALL 12866 0 0
8095: ST_TO_ADDR
// DialogueOn ;
8096: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8100: LD_VAR 0 2
8104: PPUSH
8105: CALL_OW 250
8109: PPUSH
8110: LD_VAR 0 2
8114: PPUSH
8115: CALL_OW 251
8119: PPUSH
8120: LD_INT 7
8122: PPUSH
8123: LD_INT 8
8125: NEG
8126: PPUSH
8127: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8131: LD_VAR 0 2
8135: PPUSH
8136: CALL_OW 87
// if tmp then
8140: LD_VAR 0 3
8144: IFFALSE 8158
// Say ( tmp , D4-RSci1-1 ) ;
8146: LD_VAR 0 3
8150: PPUSH
8151: LD_STRING D4-RSci1-1
8153: PPUSH
8154: CALL_OW 88
// if Gossudarov then
8158: LD_EXP 32
8162: IFFALSE 8188
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8164: LD_EXP 32
8168: PPUSH
8169: LD_STRING D4-Gos-1
8171: PPUSH
8172: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8176: LD_EXP 15
8180: PPUSH
8181: LD_STRING D4-JMM-1
8183: PPUSH
8184: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8188: LD_VAR 0 2
8192: PPUSH
8193: CALL_OW 250
8197: PPUSH
8198: LD_VAR 0 2
8202: PPUSH
8203: CALL_OW 251
8207: PPUSH
8208: LD_INT 7
8210: PPUSH
8211: CALL_OW 331
// DialogueOff ;
8215: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8219: LD_STRING M5
8221: PPUSH
8222: CALL_OW 337
// end ;
8226: PPOPN 3
8228: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8229: LD_EXP 6
8233: IFFALSE 8822
8235: GO 8237
8237: DISABLE
8238: LD_INT 0
8240: PPUSH
8241: PPUSH
8242: PPUSH
// begin PrepareBelkov ;
8243: CALL 2092 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8247: LD_EXP 47
8251: PPUSH
8252: LD_INT 118
8254: PPUSH
8255: LD_INT 106
8257: PPUSH
8258: CALL_OW 111
// AddComHold ( Belkov ) ;
8262: LD_EXP 47
8266: PPUSH
8267: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8271: LD_INT 35
8273: PPUSH
8274: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8278: LD_EXP 47
8282: PPUSH
8283: LD_INT 118
8285: PPUSH
8286: LD_INT 106
8288: PPUSH
8289: CALL_OW 307
8293: IFFALSE 8271
// ChangeSideFog ( 4 , 7 ) ;
8295: LD_INT 4
8297: PPUSH
8298: LD_INT 7
8300: PPUSH
8301: CALL_OW 343
// if IsOk ( Belkov ) then
8305: LD_EXP 47
8309: PPUSH
8310: CALL_OW 302
8314: IFFALSE 8398
// begin InGameOn ;
8316: CALL_OW 8
// DialogueOn ;
8320: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8324: LD_EXP 47
8328: PPUSH
8329: LD_STRING D5-Bel-1
8331: PPUSH
8332: CALL_OW 94
// if Gossudarov then
8336: LD_EXP 32
8340: IFFALSE 8390
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8342: LD_EXP 32
8346: PPUSH
8347: LD_STRING D5-Gos-1
8349: PPUSH
8350: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8354: LD_EXP 15
8358: PPUSH
8359: LD_STRING D5-JMM-1
8361: PPUSH
8362: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8366: LD_EXP 32
8370: PPUSH
8371: LD_STRING D5-Gos-2
8373: PPUSH
8374: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8378: LD_EXP 15
8382: PPUSH
8383: LD_STRING D5-JMM-2
8385: PPUSH
8386: CALL_OW 88
// end ; DialogueOff ;
8390: CALL_OW 7
// InGameOff ;
8394: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8398: LD_STRING QSaveBelkov
8400: PPUSH
8401: CALL_OW 97
8405: PUSH
8406: LD_INT 1
8408: DOUBLE
8409: EQUAL
8410: IFTRUE 8414
8412: GO 8464
8414: POP
// begin DialogueOn ;
8415: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8419: LD_EXP 15
8423: PPUSH
8424: LD_STRING D5a-JMM-1
8426: PPUSH
8427: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8431: LD_EXP 47
8435: PPUSH
8436: LD_STRING D5a-Bel-1
8438: PPUSH
8439: CALL_OW 94
// DialogueOff ;
8443: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8447: LD_EXP 47
8451: PPUSH
8452: LD_INT 83
8454: PPUSH
8455: LD_INT 49
8457: PPUSH
8458: CALL_OW 111
// end ; 2 :
8462: GO 8497
8464: LD_INT 2
8466: DOUBLE
8467: EQUAL
8468: IFTRUE 8472
8470: GO 8496
8472: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8473: LD_EXP 15
8477: PPUSH
8478: LD_STRING D5a-JMM-2
8480: PPUSH
8481: CALL_OW 88
// ComHold ( Belkov ) ;
8485: LD_EXP 47
8489: PPUSH
8490: CALL_OW 140
// end ; end ;
8494: GO 8497
8496: POP
// time := 0 0$00 ;
8497: LD_ADDR_VAR 0 1
8501: PUSH
8502: LD_INT 0
8504: ST_TO_ADDR
// vehSpawned := false ;
8505: LD_ADDR_VAR 0 3
8509: PUSH
8510: LD_INT 0
8512: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8513: LD_INT 35
8515: PPUSH
8516: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8520: LD_VAR 0 1
8524: PUSH
8525: LD_INT 350
8527: PUSH
8528: LD_INT 175
8530: PUSH
8531: LD_INT 70
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: LIST
8538: PUSH
8539: LD_OWVAR 67
8543: ARRAY
8544: GREATEREQUAL
8545: PUSH
8546: LD_VAR 0 3
8550: NOT
8551: AND
8552: IFFALSE 8642
// begin vehSpawned := true ;
8554: LD_ADDR_VAR 0 3
8558: PUSH
8559: LD_INT 1
8561: ST_TO_ADDR
// uc_side := 3 ;
8562: LD_ADDR_OWVAR 20
8566: PUSH
8567: LD_INT 3
8569: ST_TO_ADDR
// uc_nation := 3 ;
8570: LD_ADDR_OWVAR 21
8574: PUSH
8575: LD_INT 3
8577: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8578: LD_INT 22
8580: PPUSH
8581: LD_INT 3
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: LD_INT 43
8589: PPUSH
8590: LD_INT 100
8592: PPUSH
8593: CALL 19116 0 5
// veh := CreateVehicle ;
8597: LD_ADDR_VAR 0 2
8601: PUSH
8602: CALL_OW 45
8606: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8607: LD_VAR 0 2
8611: PPUSH
8612: LD_INT 130
8614: PPUSH
8615: LD_INT 131
8617: PPUSH
8618: LD_INT 0
8620: PPUSH
8621: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8625: LD_VAR 0 2
8629: PPUSH
8630: LD_INT 100
8632: PPUSH
8633: LD_INT 82
8635: PPUSH
8636: CALL_OW 114
// end else
8640: GO 8656
// time := time + 0 0$1 ;
8642: LD_ADDR_VAR 0 1
8646: PUSH
8647: LD_VAR 0 1
8651: PUSH
8652: LD_INT 35
8654: PLUS
8655: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8656: LD_EXP 47
8660: PPUSH
8661: CALL_OW 301
8665: PUSH
8666: LD_EXP 47
8670: PPUSH
8671: CALL_OW 255
8675: PUSH
8676: LD_INT 4
8678: EQUAL
8679: AND
8680: PUSH
8681: LD_INT 22
8683: PUSH
8684: LD_INT 7
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: PPUSH
8691: CALL_OW 69
8695: PPUSH
8696: LD_EXP 47
8700: PPUSH
8701: CALL_OW 74
8705: PPUSH
8706: LD_EXP 47
8710: PPUSH
8711: CALL_OW 296
8715: PUSH
8716: LD_INT 10
8718: LESS
8719: OR
8720: IFFALSE 8513
// if IsDead ( Belkov ) then
8722: LD_EXP 47
8726: PPUSH
8727: CALL_OW 301
8731: IFFALSE 8756
// begin CenterNowOnUnits ( Belkov ) ;
8733: LD_EXP 47
8737: PPUSH
8738: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8742: LD_EXP 15
8746: PPUSH
8747: LD_STRING D5a-JMM-2a
8749: PPUSH
8750: CALL_OW 88
// exit ;
8754: GO 8822
// end ; if See ( 7 , Belkov ) then
8756: LD_INT 7
8758: PPUSH
8759: LD_EXP 47
8763: PPUSH
8764: CALL_OW 292
8768: IFFALSE 8782
// SetSide ( Belkov , 7 ) ;
8770: LD_EXP 47
8774: PPUSH
8775: LD_INT 7
8777: PPUSH
8778: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8782: LD_INT 35
8784: PPUSH
8785: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8789: LD_EXP 47
8793: PPUSH
8794: LD_INT 66
8796: PPUSH
8797: LD_INT 45
8799: PPUSH
8800: CALL_OW 297
8804: PUSH
8805: LD_INT 30
8807: LESS
8808: IFFALSE 8782
// Say ( Belkov , D6-Bel-1 ) ;
8810: LD_EXP 47
8814: PPUSH
8815: LD_STRING D6-Bel-1
8817: PPUSH
8818: CALL_OW 88
// end ;
8822: PPOPN 3
8824: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8825: LD_EXP 47
8829: PPUSH
8830: CALL_OW 302
8834: PUSH
8835: LD_EXP 47
8839: PPUSH
8840: CALL_OW 504
8844: PUSH
8845: LD_INT 2
8847: PUSH
8848: LD_INT 34
8850: PUSH
8851: LD_INT 47
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PUSH
8858: LD_INT 34
8860: PUSH
8861: LD_INT 45
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: LIST
8872: PPUSH
8873: CALL_OW 69
8877: IN
8878: AND
8879: IFFALSE 8896
8881: GO 8883
8883: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8884: LD_EXP 47
8888: PPUSH
8889: LD_STRING D7-Bel-1
8891: PPUSH
8892: CALL_OW 88
8896: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8897: LD_INT 22
8899: PUSH
8900: LD_INT 7
8902: PUSH
8903: EMPTY
8904: LIST
8905: LIST
8906: PUSH
8907: LD_INT 101
8909: PUSH
8910: LD_INT 2
8912: PUSH
8913: EMPTY
8914: LIST
8915: LIST
8916: PUSH
8917: EMPTY
8918: LIST
8919: LIST
8920: PPUSH
8921: CALL_OW 69
8925: PUSH
8926: LD_EXP 8
8930: NOT
8931: AND
8932: PUSH
8933: LD_EXP 46
8937: PPUSH
8938: CALL_OW 305
8942: NOT
8943: AND
8944: IFFALSE 9414
8946: GO 8948
8948: DISABLE
8949: LD_INT 0
8951: PPUSH
// begin ar_base_spotted := true ;
8952: LD_ADDR_EXP 8
8956: PUSH
8957: LD_INT 1
8959: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8960: LD_ADDR_VAR 0 1
8964: PUSH
8965: LD_INT 22
8967: PUSH
8968: LD_INT 2
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PUSH
8975: LD_INT 21
8977: PUSH
8978: LD_INT 3
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: PPUSH
8989: CALL_OW 69
8993: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8994: LD_ADDR_VAR 0 1
8998: PUSH
8999: LD_VAR 0 1
9003: PPUSH
9004: LD_EXP 15
9008: PPUSH
9009: CALL_OW 74
9013: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9014: LD_INT 7
9016: PPUSH
9017: LD_INT 3
9019: PPUSH
9020: CALL_OW 332
// DialogueOn ;
9024: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9028: LD_VAR 0 1
9032: PPUSH
9033: CALL_OW 250
9037: PPUSH
9038: LD_VAR 0 1
9042: PPUSH
9043: CALL_OW 251
9047: PPUSH
9048: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9052: LD_ADDR_VAR 0 1
9056: PUSH
9057: LD_INT 22
9059: PUSH
9060: LD_INT 7
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: PUSH
9067: LD_INT 23
9069: PUSH
9070: LD_INT 1
9072: PUSH
9073: EMPTY
9074: LIST
9075: LIST
9076: PUSH
9077: LD_INT 26
9079: PUSH
9080: LD_INT 1
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: LIST
9091: PPUSH
9092: CALL_OW 69
9096: PUSH
9097: LD_EXP 15
9101: PUSH
9102: LD_EXP 19
9106: PUSH
9107: LD_EXP 20
9111: PUSH
9112: LD_EXP 27
9116: PUSH
9117: LD_EXP 16
9121: PUSH
9122: LD_EXP 25
9126: PUSH
9127: LD_EXP 21
9131: PUSH
9132: LD_EXP 23
9136: PUSH
9137: EMPTY
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: DIFF
9147: ST_TO_ADDR
// if not tmp then
9148: LD_VAR 0 1
9152: NOT
9153: IFFALSE 9227
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9155: LD_ADDR_VAR 0 1
9159: PUSH
9160: LD_INT 22
9162: PUSH
9163: LD_INT 7
9165: PUSH
9166: EMPTY
9167: LIST
9168: LIST
9169: PUSH
9170: LD_INT 23
9172: PUSH
9173: LD_INT 1
9175: PUSH
9176: EMPTY
9177: LIST
9178: LIST
9179: PUSH
9180: LD_INT 26
9182: PUSH
9183: LD_INT 2
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: LIST
9194: PPUSH
9195: CALL_OW 69
9199: PUSH
9200: LD_EXP 30
9204: PUSH
9205: LD_EXP 17
9209: PUSH
9210: LD_EXP 28
9214: PUSH
9215: LD_EXP 29
9219: PUSH
9220: EMPTY
9221: LIST
9222: LIST
9223: LIST
9224: LIST
9225: DIFF
9226: ST_TO_ADDR
// if tmp then
9227: LD_VAR 0 1
9231: IFFALSE 9302
// case GetSex ( tmp [ 1 ] ) of sex_male :
9233: LD_VAR 0 1
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: CALL_OW 258
9246: PUSH
9247: LD_INT 1
9249: DOUBLE
9250: EQUAL
9251: IFTRUE 9255
9253: GO 9274
9255: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9256: LD_VAR 0 1
9260: PUSH
9261: LD_INT 1
9263: ARRAY
9264: PPUSH
9265: LD_STRING D9-Sol1-1
9267: PPUSH
9268: CALL_OW 88
9272: GO 9302
9274: LD_INT 2
9276: DOUBLE
9277: EQUAL
9278: IFTRUE 9282
9280: GO 9301
9282: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9283: LD_VAR 0 1
9287: PUSH
9288: LD_INT 1
9290: ARRAY
9291: PPUSH
9292: LD_STRING D9-FSol1-1
9294: PPUSH
9295: CALL_OW 88
9299: GO 9302
9301: POP
// if Frank then
9302: LD_EXP 27
9306: IFFALSE 9410
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9308: LD_EXP 56
9312: PPUSH
9313: CALL_OW 250
9317: PPUSH
9318: LD_EXP 56
9322: PPUSH
9323: CALL_OW 251
9327: PPUSH
9328: LD_INT 7
9330: PPUSH
9331: LD_INT 8
9333: PPUSH
9334: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9338: LD_EXP 56
9342: PPUSH
9343: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9347: LD_EXP 27
9351: PPUSH
9352: LD_STRING D9-Frank-1
9354: PPUSH
9355: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9359: LD_EXP 15
9363: PPUSH
9364: LD_STRING D9-JMM-1
9366: PPUSH
9367: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9371: LD_EXP 27
9375: PPUSH
9376: LD_STRING D9-Frank-2
9378: PPUSH
9379: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9383: LD_EXP 56
9387: PPUSH
9388: CALL_OW 250
9392: PPUSH
9393: LD_EXP 56
9397: PPUSH
9398: CALL_OW 251
9402: PPUSH
9403: LD_INT 7
9405: PPUSH
9406: CALL_OW 331
// end ; DialogueOff ;
9410: CALL_OW 7
// end ;
9414: PPOPN 1
9416: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9417: LD_EXP 7
9421: PUSH
9422: LD_OWVAR 1
9426: PUSH
9427: LD_INT 42000
9429: GREATEREQUAL
9430: OR
9431: IFFALSE 10458
9433: GO 9435
9435: DISABLE
9436: LD_INT 0
9438: PPUSH
9439: PPUSH
// begin selected_option := 1 ;
9440: LD_ADDR_VAR 0 2
9444: PUSH
9445: LD_INT 1
9447: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9448: LD_INT 10500
9450: PPUSH
9451: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9455: LD_INT 35
9457: PPUSH
9458: CALL_OW 67
// until not ru_attackers ;
9462: LD_EXP 52
9466: NOT
9467: IFFALSE 9455
// PrepareBurlak ;
9469: CALL 2204 0 0
// repeat wait ( 0 0$2 ) ;
9473: LD_INT 70
9475: PPUSH
9476: CALL_OW 67
// until not HasTask ( Burlak ) ;
9480: LD_EXP 46
9484: PPUSH
9485: CALL_OW 314
9489: NOT
9490: IFFALSE 9473
// InGameOn ;
9492: CALL_OW 8
// DialogueOn ;
9496: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9500: LD_EXP 49
9504: PPUSH
9505: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9509: LD_EXP 46
9513: PPUSH
9514: LD_STRING D10-Bur-1
9516: PPUSH
9517: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9521: LD_EXP 47
9525: PUSH
9526: LD_EXP 47
9530: PPUSH
9531: CALL_OW 255
9535: PUSH
9536: LD_INT 7
9538: EQUAL
9539: AND
9540: IFFALSE 9554
// Say ( Belkov , D10-Bel-1 ) ;
9542: LD_EXP 47
9546: PPUSH
9547: LD_STRING D10-Bel-1
9549: PPUSH
9550: CALL_OW 88
// if Gossudarov then
9554: LD_EXP 32
9558: IFFALSE 9572
// Say ( Gossudarov , D10-Gos-1 ) ;
9560: LD_EXP 32
9564: PPUSH
9565: LD_STRING D10-Gos-1
9567: PPUSH
9568: CALL_OW 88
// if Kirilenkova then
9572: LD_EXP 33
9576: IFFALSE 9590
// Say ( Kirilenkova , D10-Kir-1 ) ;
9578: LD_EXP 33
9582: PPUSH
9583: LD_STRING D10-Kir-1
9585: PPUSH
9586: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9590: CALL 12866 0 0
9594: PPUSH
9595: LD_STRING D10-RSol1-1
9597: PPUSH
9598: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9602: LD_EXP 46
9606: PPUSH
9607: LD_STRING D10-Bur-2
9609: PPUSH
9610: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9614: LD_EXP 15
9618: PPUSH
9619: LD_STRING D10-JMM-2
9621: PPUSH
9622: CALL_OW 88
// if Kirilenkova then
9626: LD_EXP 33
9630: IFFALSE 9646
// Say ( Kirilenkova , D10-Kir-2 ) else
9632: LD_EXP 33
9636: PPUSH
9637: LD_STRING D10-Kir-2
9639: PPUSH
9640: CALL_OW 88
9644: GO 9658
// Say ( SolRu , D10-RSol1-2 ) ;
9646: CALL 12866 0 0
9650: PPUSH
9651: LD_STRING D10-RSol1-2
9653: PPUSH
9654: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9658: LD_EXP 15
9662: PPUSH
9663: LD_STRING D10-JMM-3
9665: PPUSH
9666: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9670: LD_EXP 46
9674: PPUSH
9675: LD_STRING D10-Bur-3
9677: PPUSH
9678: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9682: LD_EXP 15
9686: PPUSH
9687: LD_STRING D10-JMM-4
9689: PPUSH
9690: CALL_OW 88
// DialogueOff ;
9694: CALL_OW 7
// InGameOff ;
9698: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9702: LD_STRING M2
9704: PPUSH
9705: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9709: LD_INT 35
9711: PPUSH
9712: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9716: LD_INT 22
9718: PUSH
9719: LD_INT 7
9721: PUSH
9722: EMPTY
9723: LIST
9724: LIST
9725: PUSH
9726: LD_INT 91
9728: PUSH
9729: LD_EXP 46
9733: PUSH
9734: LD_INT 8
9736: PUSH
9737: EMPTY
9738: LIST
9739: LIST
9740: LIST
9741: PUSH
9742: EMPTY
9743: LIST
9744: LIST
9745: PPUSH
9746: CALL_OW 69
9750: IFFALSE 9709
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9752: LD_ADDR_VAR 0 1
9756: PUSH
9757: LD_INT 22
9759: PUSH
9760: LD_INT 4
9762: PUSH
9763: EMPTY
9764: LIST
9765: LIST
9766: PPUSH
9767: CALL_OW 69
9771: PUSH
9772: FOR_IN
9773: IFFALSE 9789
// SetSide ( i , 7 ) ;
9775: LD_VAR 0 1
9779: PPUSH
9780: LD_INT 7
9782: PPUSH
9783: CALL_OW 235
9787: GO 9772
9789: POP
9790: POP
// ChangeMissionObjectives ( M3 ) ;
9791: LD_STRING M3
9793: PPUSH
9794: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9798: LD_INT 35
9800: PPUSH
9801: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9805: LD_EXP 15
9809: PPUSH
9810: LD_EXP 46
9814: PPUSH
9815: CALL_OW 296
9819: PUSH
9820: LD_INT 8
9822: LESS
9823: IFFALSE 9798
// ComTurnUnit ( JMM , Burlak ) ;
9825: LD_EXP 15
9829: PPUSH
9830: LD_EXP 46
9834: PPUSH
9835: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9839: LD_EXP 46
9843: PPUSH
9844: LD_EXP 15
9848: PPUSH
9849: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9853: LD_INT 10
9855: PPUSH
9856: CALL_OW 67
// DialogueOn ;
9860: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9864: LD_EXP 15
9868: PPUSH
9869: LD_STRING D11-JMM-1
9871: PPUSH
9872: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9876: LD_EXP 46
9880: PPUSH
9881: LD_STRING D11-Bur-1
9883: PPUSH
9884: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9888: LD_EXP 15
9892: PPUSH
9893: LD_STRING D11-JMM-2
9895: PPUSH
9896: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9900: LD_EXP 46
9904: PPUSH
9905: LD_STRING D11-Bur-2
9907: PPUSH
9908: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9912: LD_EXP 15
9916: PPUSH
9917: LD_STRING D11-JMM-3
9919: PPUSH
9920: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9924: LD_EXP 46
9928: PPUSH
9929: LD_STRING D11-Bur-3
9931: PPUSH
9932: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9936: LD_EXP 15
9940: PPUSH
9941: LD_STRING D11-JMM-4
9943: PPUSH
9944: CALL_OW 88
// if ar_base_spotted then
9948: LD_EXP 8
9952: IFFALSE 9968
// Say ( Burlak , D12-Bur-1 ) else
9954: LD_EXP 46
9958: PPUSH
9959: LD_STRING D12-Bur-1
9961: PPUSH
9962: CALL_OW 88
9966: GO 10007
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9968: LD_INT 7
9970: PPUSH
9971: LD_INT 3
9973: PPUSH
9974: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9978: LD_INT 127
9980: PPUSH
9981: LD_INT 45
9983: PPUSH
9984: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9988: LD_EXP 46
9992: PPUSH
9993: LD_STRING D12-Bur-1a
9995: PPUSH
9996: CALL_OW 88
// dwait ( 0 0$2 ) ;
10000: LD_INT 70
10002: PPUSH
10003: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10007: LD_EXP 46
10011: PPUSH
10012: LD_STRING D12-Bur-1b
10014: PPUSH
10015: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10019: LD_EXP 15
10023: PPUSH
10024: LD_STRING D12-JMM-1
10026: PPUSH
10027: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10031: LD_EXP 46
10035: PPUSH
10036: LD_STRING D12-Bur-2
10038: PPUSH
10039: CALL_OW 88
// if Roth then
10043: LD_EXP 16
10047: IFFALSE 10063
// Say ( Roth , D12-Roth-2 ) else
10049: LD_EXP 16
10053: PPUSH
10054: LD_STRING D12-Roth-2
10056: PPUSH
10057: CALL_OW 88
10061: GO 10075
// Say ( SciRu , D12-RSci1-2 ) ;
10063: CALL 12719 0 0
10067: PPUSH
10068: LD_STRING D12-RSci1-2
10070: PPUSH
10071: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10075: LD_EXP 15
10079: PPUSH
10080: LD_STRING D12-JMM-2
10082: PPUSH
10083: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10087: LD_EXP 46
10091: PPUSH
10092: LD_STRING D12-Bur-3
10094: PPUSH
10095: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10099: LD_EXP 15
10103: PPUSH
10104: LD_STRING D12-JMM-3
10106: PPUSH
10107: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10111: LD_EXP 46
10115: PPUSH
10116: LD_STRING D12-Bur-4
10118: PPUSH
10119: CALL_OW 88
// case Query ( QBase ) of 1 :
10123: LD_STRING QBase
10125: PPUSH
10126: CALL_OW 97
10130: PUSH
10131: LD_INT 1
10133: DOUBLE
10134: EQUAL
10135: IFTRUE 10139
10137: GO 10257
10139: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10140: LD_EXP 15
10144: PPUSH
10145: LD_STRING D13a-JMM-1
10147: PPUSH
10148: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10152: LD_EXP 46
10156: PPUSH
10157: LD_STRING D13a-Bur-1
10159: PPUSH
10160: CALL_OW 88
// if Roth then
10164: LD_EXP 16
10168: IFFALSE 10184
// Say ( Roth , D13a-Roth-1 ) else
10170: LD_EXP 16
10174: PPUSH
10175: LD_STRING D13a-Roth-1
10177: PPUSH
10178: CALL_OW 88
10182: GO 10196
// Say ( SciRu , D13a-RSci1-1 ) ;
10184: CALL 12719 0 0
10188: PPUSH
10189: LD_STRING D13a-RSci1-1
10191: PPUSH
10192: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10196: LD_EXP 15
10200: PPUSH
10201: LD_STRING D13a-JMM-2
10203: PPUSH
10204: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10208: LD_STRING QBaseAgain
10210: PPUSH
10211: CALL_OW 97
10215: PUSH
10216: LD_INT 1
10218: DOUBLE
10219: EQUAL
10220: IFTRUE 10224
10222: GO 10235
10224: POP
// selected_option := 2 ; 2 :
10225: LD_ADDR_VAR 0 2
10229: PUSH
10230: LD_INT 2
10232: ST_TO_ADDR
10233: GO 10255
10235: LD_INT 2
10237: DOUBLE
10238: EQUAL
10239: IFTRUE 10243
10241: GO 10254
10243: POP
// selected_option := 3 ; end ;
10244: LD_ADDR_VAR 0 2
10248: PUSH
10249: LD_INT 3
10251: ST_TO_ADDR
10252: GO 10255
10254: POP
// end ; 2 :
10255: GO 10296
10257: LD_INT 2
10259: DOUBLE
10260: EQUAL
10261: IFTRUE 10265
10263: GO 10276
10265: POP
// selected_option := 2 ; 3 :
10266: LD_ADDR_VAR 0 2
10270: PUSH
10271: LD_INT 2
10273: ST_TO_ADDR
10274: GO 10296
10276: LD_INT 3
10278: DOUBLE
10279: EQUAL
10280: IFTRUE 10284
10282: GO 10295
10284: POP
// selected_option := 3 ; end ;
10285: LD_ADDR_VAR 0 2
10289: PUSH
10290: LD_INT 3
10292: ST_TO_ADDR
10293: GO 10296
10295: POP
// if selected_option = 2 then
10296: LD_VAR 0 2
10300: PUSH
10301: LD_INT 2
10303: EQUAL
10304: IFFALSE 10398
// begin Say ( JMM , D13b-JMM-1 ) ;
10306: LD_EXP 15
10310: PPUSH
10311: LD_STRING D13b-JMM-1
10313: PPUSH
10314: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10318: LD_EXP 46
10322: PPUSH
10323: LD_STRING D13b-Bur-1
10325: PPUSH
10326: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10330: LD_EXP 15
10334: PPUSH
10335: LD_STRING D13b-JMM-2
10337: PPUSH
10338: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10342: LD_EXP 55
10346: PPUSH
10347: LD_STRING D13b-Abd-2
10349: PPUSH
10350: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10354: LD_EXP 15
10358: PPUSH
10359: LD_STRING D13b-JMM-3
10361: PPUSH
10362: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10366: LD_EXP 55
10370: PPUSH
10371: LD_STRING D13b-Abd-3
10373: PPUSH
10374: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10378: LD_EXP 15
10382: PPUSH
10383: LD_STRING D13b-JMM-4
10385: PPUSH
10386: CALL_OW 88
// ar_active_attack := true ;
10390: LD_ADDR_EXP 9
10394: PUSH
10395: LD_INT 1
10397: ST_TO_ADDR
// end ; if selected_option = 3 then
10398: LD_VAR 0 2
10402: PUSH
10403: LD_INT 3
10405: EQUAL
10406: IFFALSE 10432
// begin Say ( JMM , D13c-JMM-1 ) ;
10408: LD_EXP 15
10412: PPUSH
10413: LD_STRING D13c-JMM-1
10415: PPUSH
10416: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10420: LD_EXP 46
10424: PPUSH
10425: LD_STRING D13c-Bur-1
10427: PPUSH
10428: CALL_OW 88
// end ; DialogueOff ;
10432: CALL_OW 7
// if not ar_active_attack then
10436: LD_EXP 9
10440: NOT
10441: IFFALSE 10458
// begin wait ( 6 6$00 ) ;
10443: LD_INT 12600
10445: PPUSH
10446: CALL_OW 67
// ar_active_attack := true ;
10450: LD_ADDR_EXP 9
10454: PUSH
10455: LD_INT 1
10457: ST_TO_ADDR
// end ; end ;
10458: PPOPN 2
10460: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10461: LD_EXP 46
10465: PPUSH
10466: CALL_OW 305
10470: PUSH
10471: LD_EXP 46
10475: PPUSH
10476: CALL_OW 255
10480: PUSH
10481: LD_INT 7
10483: EQUAL
10484: AND
10485: IFFALSE 10681
10487: GO 10489
10489: DISABLE
10490: LD_INT 0
10492: PPUSH
// begin wait ( 4 4$40 ) ;
10493: LD_INT 9800
10495: PPUSH
10496: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10500: LD_INT 35
10502: PPUSH
10503: CALL_OW 67
// until not ru_attackers ;
10507: LD_EXP 52
10511: NOT
10512: IFFALSE 10500
// PrepareGnyevko ;
10514: CALL 2148 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10518: LD_EXP 48
10522: PPUSH
10523: LD_INT 124
10525: PPUSH
10526: LD_INT 118
10528: PPUSH
10529: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10533: LD_EXP 48
10537: PPUSH
10538: CALL_OW 200
// time := 0 0$00 ;
10542: LD_ADDR_VAR 0 1
10546: PUSH
10547: LD_INT 0
10549: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10550: LD_INT 35
10552: PPUSH
10553: CALL_OW 67
// time := time + 0 0$1 ;
10557: LD_ADDR_VAR 0 1
10561: PUSH
10562: LD_VAR 0 1
10566: PUSH
10567: LD_INT 35
10569: PLUS
10570: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10571: LD_EXP 48
10575: PPUSH
10576: LD_INT 124
10578: PPUSH
10579: LD_INT 118
10581: PPUSH
10582: CALL_OW 307
10586: PUSH
10587: LD_VAR 0 1
10591: PUSH
10592: LD_INT 1050
10594: GREATEREQUAL
10595: OR
10596: IFFALSE 10550
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10598: LD_EXP 48
10602: PPUSH
10603: LD_STRING DBelkov-Gny-1
10605: PPUSH
10606: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10610: LD_EXP 46
10614: PPUSH
10615: LD_STRING DBelkov-Bur-1a
10617: PPUSH
10618: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10622: LD_INT 35
10624: PPUSH
10625: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10629: LD_EXP 48
10633: PPUSH
10634: LD_INT 22
10636: PUSH
10637: LD_INT 7
10639: PUSH
10640: EMPTY
10641: LIST
10642: LIST
10643: PPUSH
10644: CALL_OW 69
10648: PPUSH
10649: LD_EXP 48
10653: PPUSH
10654: CALL_OW 74
10658: PPUSH
10659: CALL_OW 296
10663: PUSH
10664: LD_INT 8
10666: LESS
10667: IFFALSE 10622
// SetSide ( Gnyevko , 7 ) ;
10669: LD_EXP 48
10673: PPUSH
10674: LD_INT 7
10676: PPUSH
10677: CALL_OW 235
// end ;
10681: PPOPN 1
10683: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10684: LD_EXP 46
10688: PPUSH
10689: CALL_OW 255
10693: PUSH
10694: LD_INT 7
10696: EQUAL
10697: IFFALSE 10707
10699: GO 10701
10701: DISABLE
// begin enable ;
10702: ENABLE
// PrepareAmericanAttack ;
10703: CALL 6523 0 0
// end ;
10707: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10708: LD_INT 22
10710: PUSH
10711: LD_INT 1
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: PPUSH
10718: CALL_OW 69
10722: IFFALSE 10906
10724: GO 10726
10726: DISABLE
10727: LD_INT 0
10729: PPUSH
10730: PPUSH
// begin while true do
10731: LD_INT 1
10733: IFFALSE 10790
// begin wait ( 0 0$1 ) ;
10735: LD_INT 35
10737: PPUSH
10738: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10742: LD_ADDR_VAR 0 2
10746: PUSH
10747: LD_INT 22
10749: PUSH
10750: LD_INT 1
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: PPUSH
10757: CALL_OW 69
10761: PPUSH
10762: LD_EXP 15
10766: PPUSH
10767: CALL_OW 74
10771: ST_TO_ADDR
// if See ( 7 , tmp ) then
10772: LD_INT 7
10774: PPUSH
10775: LD_VAR 0 2
10779: PPUSH
10780: CALL_OW 292
10784: IFFALSE 10788
// break ;
10786: GO 10790
// end ;
10788: GO 10731
// DialogueOn ;
10790: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10794: LD_VAR 0 2
10798: PPUSH
10799: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10803: LD_VAR 0 2
10807: PPUSH
10808: CALL_OW 250
10812: PPUSH
10813: LD_VAR 0 2
10817: PPUSH
10818: CALL_OW 251
10822: PPUSH
10823: LD_INT 7
10825: PPUSH
10826: LD_INT 8
10828: PPUSH
10829: CALL_OW 330
// if Denis then
10833: LD_EXP 21
10837: IFFALSE 10851
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10839: LD_EXP 21
10843: PPUSH
10844: LD_STRING DAmerAttack-Pet-1
10846: PPUSH
10847: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10851: LD_EXP 15
10855: PPUSH
10856: LD_STRING DAmerAttack-JMM-1
10858: PPUSH
10859: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10863: LD_EXP 46
10867: PPUSH
10868: LD_STRING DStop-Bur-1
10870: PPUSH
10871: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10875: LD_VAR 0 2
10879: PPUSH
10880: CALL_OW 250
10884: PPUSH
10885: LD_VAR 0 2
10889: PPUSH
10890: CALL_OW 251
10894: PPUSH
10895: LD_INT 7
10897: PPUSH
10898: CALL_OW 331
// DialogueOff ;
10902: CALL_OW 7
// end ;
10906: PPOPN 2
10908: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10909: LD_INT 22
10911: PUSH
10912: LD_INT 3
10914: PUSH
10915: EMPTY
10916: LIST
10917: LIST
10918: PUSH
10919: LD_INT 21
10921: PUSH
10922: LD_INT 1
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: PUSH
10929: EMPTY
10930: LIST
10931: LIST
10932: PPUSH
10933: CALL_OW 69
10937: PUSH
10938: LD_INT 0
10940: EQUAL
10941: IFFALSE 10983
10943: GO 10945
10945: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10946: LD_STRING M5a
10948: PPUSH
10949: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10953: LD_EXP 15
10957: PPUSH
10958: LD_STRING D8-JMM-1
10960: PPUSH
10961: CALL_OW 88
// if Gossudarov then
10965: LD_EXP 32
10969: IFFALSE 10983
// Say ( Gossudarov , D8-Gos-1 ) ;
10971: LD_EXP 32
10975: PPUSH
10976: LD_STRING D8-Gos-1
10978: PPUSH
10979: CALL_OW 88
// end ;
10983: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10984: LD_INT 22
10986: PUSH
10987: LD_INT 2
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: PUSH
10994: LD_INT 21
10996: PUSH
10997: LD_INT 1
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: PPUSH
11008: CALL_OW 69
11012: PUSH
11013: LD_INT 0
11015: EQUAL
11016: IFFALSE 11066
11018: GO 11020
11020: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11021: LD_STRING M4c
11023: PPUSH
11024: CALL_OW 337
// if Roth then
11028: LD_EXP 16
11032: IFFALSE 11048
// Say ( Roth , DStop-Roth-1 ) else
11034: LD_EXP 16
11038: PPUSH
11039: LD_STRING DStop-Roth-1
11041: PPUSH
11042: CALL_OW 88
11046: GO 11066
// if Gossudarov then
11048: LD_EXP 32
11052: IFFALSE 11066
// Say ( Gossudarov , D8-Gos-1a ) ;
11054: LD_EXP 32
11058: PPUSH
11059: LD_STRING D8-Gos-1a
11061: PPUSH
11062: CALL_OW 88
// end ;
11066: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11067: LD_INT 7
11069: PPUSH
11070: LD_INT 1
11072: PPUSH
11073: LD_INT 1
11075: PPUSH
11076: CALL 14355 0 3
11080: PUSH
11081: LD_INT 0
11083: EQUAL
11084: PUSH
11085: LD_INT 7
11087: PPUSH
11088: LD_INT 3
11090: PPUSH
11091: LD_INT 1
11093: PPUSH
11094: CALL 14355 0 3
11098: PUSH
11099: LD_INT 0
11101: EQUAL
11102: AND
11103: IFFALSE 11115
11105: GO 11107
11107: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11108: LD_STRING M1a
11110: PPUSH
11111: CALL_OW 337
// end ;
11115: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11116: LD_INT 22
11118: PUSH
11119: LD_INT 2
11121: PUSH
11122: EMPTY
11123: LIST
11124: LIST
11125: PUSH
11126: LD_INT 21
11128: PUSH
11129: LD_INT 1
11131: PUSH
11132: EMPTY
11133: LIST
11134: LIST
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: PPUSH
11140: CALL_OW 69
11144: PUSH
11145: LD_INT 0
11147: EQUAL
11148: PUSH
11149: LD_INT 22
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: EMPTY
11156: LIST
11157: LIST
11158: PUSH
11159: LD_INT 21
11161: PUSH
11162: LD_INT 1
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: PPUSH
11173: CALL_OW 69
11177: PUSH
11178: LD_INT 0
11180: EQUAL
11181: AND
11182: PUSH
11183: LD_INT 22
11185: PUSH
11186: LD_INT 1
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: PPUSH
11193: CALL_OW 69
11197: PUSH
11198: LD_INT 0
11200: EQUAL
11201: AND
11202: PUSH
11203: LD_INT 7
11205: PPUSH
11206: LD_INT 1
11208: PPUSH
11209: LD_INT 1
11211: PPUSH
11212: CALL 14355 0 3
11216: PUSH
11217: LD_INT 0
11219: EQUAL
11220: AND
11221: PUSH
11222: LD_INT 7
11224: PPUSH
11225: LD_INT 3
11227: PPUSH
11228: LD_INT 1
11230: PPUSH
11231: CALL 14355 0 3
11235: PUSH
11236: LD_INT 0
11238: EQUAL
11239: AND
11240: IFFALSE 12716
11242: GO 11244
11244: DISABLE
11245: LD_INT 0
11247: PPUSH
11248: PPUSH
11249: PPUSH
11250: PPUSH
11251: PPUSH
11252: PPUSH
// begin m1 := false ;
11253: LD_ADDR_VAR 0 4
11257: PUSH
11258: LD_INT 0
11260: ST_TO_ADDR
// m2 := false ;
11261: LD_ADDR_VAR 0 5
11265: PUSH
11266: LD_INT 0
11268: ST_TO_ADDR
// m3 := false ;
11269: LD_ADDR_VAR 0 6
11273: PUSH
11274: LD_INT 0
11276: ST_TO_ADDR
// if tick < 40 40$00 then
11277: LD_OWVAR 1
11281: PUSH
11282: LD_INT 84000
11284: LESS
11285: IFFALSE 11294
// SetAchievement ( ACH_ASPEED_17 ) ;
11287: LD_STRING ACH_ASPEED_17
11289: PPUSH
11290: CALL_OW 543
// wait ( 0 0$1 ) ;
11294: LD_INT 35
11296: PPUSH
11297: CALL_OW 67
// if not IsDead ( Masha ) then
11301: LD_EXP 49
11305: PPUSH
11306: CALL_OW 301
11310: NOT
11311: IFFALSE 11333
// begin m1 := true ;
11313: LD_ADDR_VAR 0 4
11317: PUSH
11318: LD_INT 1
11320: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11321: LD_STRING Masha
11323: PPUSH
11324: LD_INT 1
11326: PPUSH
11327: CALL_OW 101
// end else
11331: GO 11344
// AddMedal ( Masha , - 1 ) ;
11333: LD_STRING Masha
11335: PPUSH
11336: LD_INT 1
11338: NEG
11339: PPUSH
11340: CALL_OW 101
// if abdul_escaped then
11344: LD_EXP 12
11348: IFFALSE 11363
// AddMedal ( Abdul , - 1 ) else
11350: LD_STRING Abdul
11352: PPUSH
11353: LD_INT 1
11355: NEG
11356: PPUSH
11357: CALL_OW 101
11361: GO 11381
// begin m2 := true ;
11363: LD_ADDR_VAR 0 5
11367: PUSH
11368: LD_INT 1
11370: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11371: LD_STRING Abdul
11373: PPUSH
11374: LD_INT 1
11376: PPUSH
11377: CALL_OW 101
// end ; if loss_counter = 0 then
11381: LD_EXP 13
11385: PUSH
11386: LD_INT 0
11388: EQUAL
11389: IFFALSE 11411
// begin m3 := true ;
11391: LD_ADDR_VAR 0 6
11395: PUSH
11396: LD_INT 1
11398: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11399: LD_STRING People
11401: PPUSH
11402: LD_INT 2
11404: PPUSH
11405: CALL_OW 101
// end else
11409: GO 11469
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11411: LD_EXP 13
11415: PUSH
11416: LD_INT 3
11418: PUSH
11419: LD_INT 2
11421: PUSH
11422: LD_INT 2
11424: PUSH
11425: EMPTY
11426: LIST
11427: LIST
11428: LIST
11429: PUSH
11430: LD_OWVAR 67
11434: ARRAY
11435: LESSEQUAL
11436: IFFALSE 11458
// begin AddMedal ( People , 1 ) ;
11438: LD_STRING People
11440: PPUSH
11441: LD_INT 1
11443: PPUSH
11444: CALL_OW 101
// m3 := true ;
11448: LD_ADDR_VAR 0 6
11452: PUSH
11453: LD_INT 1
11455: ST_TO_ADDR
// end else
11456: GO 11469
// AddMedal ( People , - 1 ) ;
11458: LD_STRING People
11460: PPUSH
11461: LD_INT 1
11463: NEG
11464: PPUSH
11465: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11469: LD_OWVAR 67
11473: PUSH
11474: LD_INT 3
11476: EQUAL
11477: PUSH
11478: LD_VAR 0 4
11482: AND
11483: PUSH
11484: LD_VAR 0 5
11488: AND
11489: PUSH
11490: LD_VAR 0 6
11494: AND
11495: IFFALSE 11507
// SetAchievementEX ( ACH_AMER , 17 ) ;
11497: LD_STRING ACH_AMER
11499: PPUSH
11500: LD_INT 17
11502: PPUSH
11503: CALL_OW 564
// GiveMedals ( MAIN ) ;
11507: LD_STRING MAIN
11509: PPUSH
11510: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11514: LD_ADDR_VAR 0 2
11518: PUSH
11519: LD_INT 22
11521: PUSH
11522: LD_INT 7
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: PUSH
11529: LD_INT 2
11531: PUSH
11532: LD_INT 25
11534: PUSH
11535: LD_INT 1
11537: PUSH
11538: EMPTY
11539: LIST
11540: LIST
11541: PUSH
11542: LD_INT 25
11544: PUSH
11545: LD_INT 2
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 25
11554: PUSH
11555: LD_INT 3
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 25
11564: PUSH
11565: LD_INT 4
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: LD_INT 25
11574: PUSH
11575: LD_INT 5
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: PUSH
11582: LD_INT 25
11584: PUSH
11585: LD_INT 8
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: PUSH
11592: LD_INT 25
11594: PUSH
11595: LD_INT 9
11597: PUSH
11598: EMPTY
11599: LIST
11600: LIST
11601: PUSH
11602: EMPTY
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PPUSH
11616: CALL_OW 69
11620: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11621: LD_VAR 0 2
11625: PPUSH
11626: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11630: LD_ADDR_VAR 0 3
11634: PUSH
11635: LD_EXP 15
11639: PUSH
11640: LD_EXP 16
11644: PUSH
11645: LD_EXP 17
11649: PUSH
11650: LD_EXP 18
11654: PUSH
11655: LD_EXP 19
11659: PUSH
11660: LD_EXP 20
11664: PUSH
11665: LD_EXP 21
11669: PUSH
11670: LD_EXP 22
11674: PUSH
11675: LD_EXP 23
11679: PUSH
11680: LD_EXP 24
11684: PUSH
11685: LD_EXP 25
11689: PUSH
11690: LD_EXP 26
11694: PUSH
11695: LD_EXP 27
11699: PUSH
11700: LD_EXP 28
11704: PUSH
11705: LD_EXP 29
11709: PUSH
11710: LD_EXP 30
11714: PUSH
11715: LD_EXP 31
11719: PUSH
11720: LD_EXP 32
11724: PUSH
11725: LD_EXP 33
11729: PUSH
11730: LD_EXP 34
11734: PUSH
11735: LD_EXP 36
11739: PUSH
11740: LD_EXP 37
11744: PUSH
11745: LD_EXP 38
11749: PUSH
11750: LD_EXP 39
11754: PUSH
11755: LD_EXP 40
11759: PUSH
11760: LD_EXP 41
11764: PUSH
11765: LD_EXP 42
11769: PUSH
11770: LD_EXP 43
11774: PUSH
11775: LD_EXP 44
11779: PUSH
11780: LD_EXP 45
11784: PUSH
11785: LD_EXP 46
11789: PUSH
11790: LD_EXP 47
11794: PUSH
11795: LD_EXP 48
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: LIST
11809: LIST
11810: LIST
11811: LIST
11812: LIST
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: LIST
11831: LIST
11832: LIST
11833: LIST
11834: ST_TO_ADDR
// if tmp diff tmp2 then
11835: LD_VAR 0 2
11839: PUSH
11840: LD_VAR 0 3
11844: DIFF
11845: IFFALSE 11865
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11847: LD_VAR 0 2
11851: PUSH
11852: LD_VAR 0 3
11856: DIFF
11857: PPUSH
11858: LD_STRING 13a_others
11860: PPUSH
11861: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11865: LD_EXP 15
11869: PPUSH
11870: LD_STRING 13a_JMM
11872: PPUSH
11873: CALL_OW 38
// if Titov then
11877: LD_EXP 34
11881: IFFALSE 11895
// SaveCharacters ( Titov , 13a_Titov ) ;
11883: LD_EXP 34
11887: PPUSH
11888: LD_STRING 13a_Titov
11890: PPUSH
11891: CALL_OW 38
// if Dolgov then
11895: LD_EXP 36
11899: IFFALSE 11913
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11901: LD_EXP 36
11905: PPUSH
11906: LD_STRING 13a_Dolgov
11908: PPUSH
11909: CALL_OW 38
// if Petrosyan then
11913: LD_EXP 37
11917: IFFALSE 11931
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11919: LD_EXP 37
11923: PPUSH
11924: LD_STRING 13a_Petrosyan
11926: PPUSH
11927: CALL_OW 38
// if Scholtze then
11931: LD_EXP 38
11935: IFFALSE 11949
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11937: LD_EXP 38
11941: PPUSH
11942: LD_STRING 13a_Scholtze
11944: PPUSH
11945: CALL_OW 38
// if Oblukov then
11949: LD_EXP 39
11953: IFFALSE 11967
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11955: LD_EXP 39
11959: PPUSH
11960: LD_STRING 13a_Oblukov
11962: PPUSH
11963: CALL_OW 38
// if Kapitsova then
11967: LD_EXP 40
11971: IFFALSE 11985
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11973: LD_EXP 40
11977: PPUSH
11978: LD_STRING 13a_Kapitsova
11980: PPUSH
11981: CALL_OW 38
// if Lipshchin then
11985: LD_EXP 41
11989: IFFALSE 12003
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11991: LD_EXP 41
11995: PPUSH
11996: LD_STRING 13a_Lipshchin
11998: PPUSH
11999: CALL_OW 38
// if Petrovova then
12003: LD_EXP 42
12007: IFFALSE 12021
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12009: LD_EXP 42
12013: PPUSH
12014: LD_STRING 13a_Petrovova
12016: PPUSH
12017: CALL_OW 38
// if Kovalyuk then
12021: LD_EXP 43
12025: IFFALSE 12039
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12027: LD_EXP 43
12031: PPUSH
12032: LD_STRING 13a_Kovalyuk
12034: PPUSH
12035: CALL_OW 38
// if Kuzmov then
12039: LD_EXP 44
12043: IFFALSE 12057
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12045: LD_EXP 44
12049: PPUSH
12050: LD_STRING 13a_Kuzmov
12052: PPUSH
12053: CALL_OW 38
// if Karamazov then
12057: LD_EXP 45
12061: IFFALSE 12075
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12063: LD_EXP 45
12067: PPUSH
12068: LD_STRING 13a_Karamazov
12070: PPUSH
12071: CALL_OW 38
// if Burlak then
12075: LD_EXP 46
12079: IFFALSE 12093
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12081: LD_EXP 46
12085: PPUSH
12086: LD_STRING 13a_Burlak
12088: PPUSH
12089: CALL_OW 38
// if Belkov then
12093: LD_EXP 47
12097: IFFALSE 12111
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12099: LD_EXP 47
12103: PPUSH
12104: LD_STRING 13a_Belkov
12106: PPUSH
12107: CALL_OW 38
// if Gnyevko then
12111: LD_EXP 48
12115: IFFALSE 12129
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12117: LD_EXP 48
12121: PPUSH
12122: LD_STRING 13a_Gnyevko
12124: PPUSH
12125: CALL_OW 38
// if Lisa then
12129: LD_EXP 17
12133: IFFALSE 12147
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12135: LD_EXP 17
12139: PPUSH
12140: LD_STRING 13a_Lisa
12142: PPUSH
12143: CALL_OW 38
// if Donaldson then
12147: LD_EXP 18
12151: IFFALSE 12165
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12153: LD_EXP 18
12157: PPUSH
12158: LD_STRING 13a_Donaldson
12160: PPUSH
12161: CALL_OW 38
// if Bobby then
12165: LD_EXP 19
12169: IFFALSE 12183
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12171: LD_EXP 19
12175: PPUSH
12176: LD_STRING 13a_Bobby
12178: PPUSH
12179: CALL_OW 38
// if Cyrus then
12183: LD_EXP 20
12187: IFFALSE 12201
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12189: LD_EXP 20
12193: PPUSH
12194: LD_STRING 13a_Cyrus
12196: PPUSH
12197: CALL_OW 38
// if Denis then
12201: LD_EXP 21
12205: IFFALSE 12219
// SaveCharacters ( Denis , 13a_Denis ) ;
12207: LD_EXP 21
12211: PPUSH
12212: LD_STRING 13a_Denis
12214: PPUSH
12215: CALL_OW 38
// if Brown then
12219: LD_EXP 22
12223: IFFALSE 12237
// SaveCharacters ( Brown , 13a_Brown ) ;
12225: LD_EXP 22
12229: PPUSH
12230: LD_STRING 13a_Brown
12232: PPUSH
12233: CALL_OW 38
// if Gladstone then
12237: LD_EXP 23
12241: IFFALSE 12255
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12243: LD_EXP 23
12247: PPUSH
12248: LD_STRING 13a_Gladstone
12250: PPUSH
12251: CALL_OW 38
// if Houten then
12255: LD_EXP 24
12259: IFFALSE 12273
// SaveCharacters ( Houten , 13a_Houten ) ;
12261: LD_EXP 24
12265: PPUSH
12266: LD_STRING 13a_Houten
12268: PPUSH
12269: CALL_OW 38
// if Cornel then
12273: LD_EXP 25
12277: IFFALSE 12291
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12279: LD_EXP 25
12283: PPUSH
12284: LD_STRING 13a_Cornel
12286: PPUSH
12287: CALL_OW 38
// if Gary then
12291: LD_EXP 26
12295: IFFALSE 12309
// SaveCharacters ( Gary , 13a_Gary ) ;
12297: LD_EXP 26
12301: PPUSH
12302: LD_STRING 13a_Gary
12304: PPUSH
12305: CALL_OW 38
// if Frank then
12309: LD_EXP 27
12313: IFFALSE 12327
// SaveCharacters ( Frank , 13a_Frank ) ;
12315: LD_EXP 27
12319: PPUSH
12320: LD_STRING 13a_Frank
12322: PPUSH
12323: CALL_OW 38
// if Kikuchi then
12327: LD_EXP 28
12331: IFFALSE 12345
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12333: LD_EXP 28
12337: PPUSH
12338: LD_STRING 13a_Kikuchi
12340: PPUSH
12341: CALL_OW 38
// if Simms then
12345: LD_EXP 29
12349: IFFALSE 12363
// SaveCharacters ( Simms , 13a_Simms ) ;
12351: LD_EXP 29
12355: PPUSH
12356: LD_STRING 13a_Simms
12358: PPUSH
12359: CALL_OW 38
// if Joan then
12363: LD_EXP 30
12367: IFFALSE 12381
// SaveCharacters ( Joan , 13a_Joan ) ;
12369: LD_EXP 30
12373: PPUSH
12374: LD_STRING 13a_Joan
12376: PPUSH
12377: CALL_OW 38
// if DeltaDoctor then
12381: LD_EXP 31
12385: IFFALSE 12399
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12387: LD_EXP 31
12391: PPUSH
12392: LD_STRING 13a_DeltaDoctor
12394: PPUSH
12395: CALL_OW 38
// if Gossudarov then
12399: LD_EXP 32
12403: IFFALSE 12417
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12405: LD_EXP 32
12409: PPUSH
12410: LD_STRING 13a_Gossudarov
12412: PPUSH
12413: CALL_OW 38
// if Kirilenkova then
12417: LD_EXP 33
12421: IFFALSE 12435
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12423: LD_EXP 33
12427: PPUSH
12428: LD_STRING 13a_Kirilenkova
12430: PPUSH
12431: CALL_OW 38
// if Roth then
12435: LD_EXP 16
12439: IFFALSE 12453
// SaveCharacters ( Roth , 13a_Roth ) ;
12441: LD_EXP 16
12445: PPUSH
12446: LD_STRING 13a_Roth
12448: PPUSH
12449: CALL_OW 38
// if Masha then
12453: LD_EXP 49
12457: IFFALSE 12512
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12459: LD_EXP 49
12463: PPUSH
12464: CALL_OW 265
12468: PUSH
12469: LD_EXP 49
12473: PPUSH
12474: CALL_OW 262
12478: PUSH
12479: LD_EXP 49
12483: PPUSH
12484: CALL_OW 263
12488: PUSH
12489: LD_EXP 49
12493: PPUSH
12494: CALL_OW 264
12498: PUSH
12499: EMPTY
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: PPUSH
12505: LD_STRING 13a_Masha
12507: PPUSH
12508: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12512: LD_ADDR_VAR 0 2
12516: PUSH
12517: LD_INT 21
12519: PUSH
12520: LD_INT 3
12522: PUSH
12523: EMPTY
12524: LIST
12525: LIST
12526: PPUSH
12527: CALL_OW 69
12531: ST_TO_ADDR
// tmp2 := [ ] ;
12532: LD_ADDR_VAR 0 3
12536: PUSH
12537: EMPTY
12538: ST_TO_ADDR
// if tmp then
12539: LD_VAR 0 2
12543: IFFALSE 12694
// for i in tmp do
12545: LD_ADDR_VAR 0 1
12549: PUSH
12550: LD_VAR 0 2
12554: PUSH
12555: FOR_IN
12556: IFFALSE 12692
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12558: LD_ADDR_VAR 0 3
12562: PUSH
12563: LD_VAR 0 3
12567: PUSH
12568: LD_VAR 0 1
12572: PPUSH
12573: CALL_OW 255
12577: PUSH
12578: LD_VAR 0 1
12582: PPUSH
12583: CALL_OW 248
12587: PUSH
12588: LD_VAR 0 1
12592: PPUSH
12593: CALL_OW 266
12597: PUSH
12598: LD_VAR 0 1
12602: PPUSH
12603: CALL_OW 250
12607: PUSH
12608: LD_VAR 0 1
12612: PPUSH
12613: CALL_OW 251
12617: PUSH
12618: LD_VAR 0 1
12622: PPUSH
12623: CALL_OW 254
12627: PUSH
12628: LD_VAR 0 1
12632: PPUSH
12633: CALL_OW 267
12637: PUSH
12638: LD_VAR 0 1
12642: PPUSH
12643: LD_INT 1
12645: PPUSH
12646: CALL_OW 268
12650: PUSH
12651: LD_VAR 0 1
12655: PPUSH
12656: LD_INT 2
12658: PPUSH
12659: CALL_OW 268
12663: PUSH
12664: LD_VAR 0 1
12668: PPUSH
12669: CALL_OW 269
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: PUSH
12686: EMPTY
12687: LIST
12688: ADD
12689: ST_TO_ADDR
12690: GO 12555
12692: POP
12693: POP
// if tmp2 then
12694: LD_VAR 0 3
12698: IFFALSE 12712
// SaveVariable ( tmp2 , 13a_buildings ) ;
12700: LD_VAR 0 3
12704: PPUSH
12705: LD_STRING 13a_buildings
12707: PPUSH
12708: CALL_OW 39
// YouWin ;
12712: CALL_OW 103
// end ;
12716: PPOPN 6
12718: END
// export function SciRu ; var tmp , t ; begin
12719: LD_INT 0
12721: PPUSH
12722: PPUSH
12723: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12724: LD_ADDR_VAR 0 3
12728: PUSH
12729: LD_EXP 32
12733: PUSH
12734: LD_EXP 46
12738: PUSH
12739: LD_EXP 34
12743: PUSH
12744: LD_EXP 47
12748: PUSH
12749: LD_EXP 48
12753: PUSH
12754: LD_EXP 37
12758: PUSH
12759: LD_EXP 38
12763: PUSH
12764: LD_EXP 36
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: LIST
12773: LIST
12774: LIST
12775: LIST
12776: LIST
12777: LIST
12778: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12779: LD_ADDR_VAR 0 2
12783: PUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 7
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 23
12796: PUSH
12797: LD_INT 3
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 25
12806: PUSH
12807: LD_INT 4
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: LD_INT 26
12816: PUSH
12817: LD_INT 1
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: PUSH
12824: EMPTY
12825: LIST
12826: LIST
12827: LIST
12828: LIST
12829: PPUSH
12830: CALL_OW 69
12834: PUSH
12835: LD_VAR 0 3
12839: DIFF
12840: ST_TO_ADDR
// if tmp then
12841: LD_VAR 0 2
12845: IFFALSE 12861
// result := tmp [ 1 ] ;
12847: LD_ADDR_VAR 0 1
12851: PUSH
12852: LD_VAR 0 2
12856: PUSH
12857: LD_INT 1
12859: ARRAY
12860: ST_TO_ADDR
// end ;
12861: LD_VAR 0 1
12865: RET
// export function SolRu ; var tmp , t ; begin
12866: LD_INT 0
12868: PPUSH
12869: PPUSH
12870: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12871: LD_ADDR_VAR 0 3
12875: PUSH
12876: LD_EXP 32
12880: PUSH
12881: LD_EXP 46
12885: PUSH
12886: LD_EXP 34
12890: PUSH
12891: LD_EXP 47
12895: PUSH
12896: LD_EXP 48
12900: PUSH
12901: LD_EXP 37
12905: PUSH
12906: LD_EXP 38
12910: PUSH
12911: LD_EXP 36
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: LIST
12924: LIST
12925: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12926: LD_ADDR_VAR 0 2
12930: PUSH
12931: LD_INT 22
12933: PUSH
12934: LD_INT 7
12936: PUSH
12937: EMPTY
12938: LIST
12939: LIST
12940: PUSH
12941: LD_INT 23
12943: PUSH
12944: LD_INT 3
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: PUSH
12951: LD_INT 25
12953: PUSH
12954: LD_INT 1
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: PUSH
12961: LD_INT 26
12963: PUSH
12964: LD_INT 1
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: LIST
12975: LIST
12976: PPUSH
12977: CALL_OW 69
12981: PUSH
12982: LD_VAR 0 3
12986: DIFF
12987: ST_TO_ADDR
// if tmp then
12988: LD_VAR 0 2
12992: IFFALSE 13008
// result := tmp [ 1 ] ;
12994: LD_ADDR_VAR 0 1
12998: PUSH
12999: LD_VAR 0 2
13003: PUSH
13004: LD_INT 1
13006: ARRAY
13007: ST_TO_ADDR
// end ; end_of_file
13008: LD_VAR 0 1
13012: RET
// export function CustomEvent ( event ) ; begin
13013: LD_INT 0
13015: PPUSH
// end ;
13016: LD_VAR 0 2
13020: RET
// on UnitDestroyed ( un ) do var i , side ;
13021: LD_INT 0
13023: PPUSH
13024: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13025: LD_VAR 0 1
13029: PUSH
13030: LD_INT 22
13032: PUSH
13033: LD_INT 7
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PUSH
13040: LD_INT 2
13042: PUSH
13043: LD_INT 25
13045: PUSH
13046: LD_INT 1
13048: PUSH
13049: EMPTY
13050: LIST
13051: LIST
13052: PUSH
13053: LD_INT 25
13055: PUSH
13056: LD_INT 2
13058: PUSH
13059: EMPTY
13060: LIST
13061: LIST
13062: PUSH
13063: LD_INT 25
13065: PUSH
13066: LD_INT 3
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: PUSH
13073: LD_INT 25
13075: PUSH
13076: LD_INT 4
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: PUSH
13083: LD_INT 25
13085: PUSH
13086: LD_INT 5
13088: PUSH
13089: EMPTY
13090: LIST
13091: LIST
13092: PUSH
13093: LD_INT 25
13095: PUSH
13096: LD_INT 8
13098: PUSH
13099: EMPTY
13100: LIST
13101: LIST
13102: PUSH
13103: LD_INT 25
13105: PUSH
13106: LD_INT 9
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: PUSH
13113: EMPTY
13114: LIST
13115: LIST
13116: LIST
13117: LIST
13118: LIST
13119: LIST
13120: LIST
13121: LIST
13122: PUSH
13123: EMPTY
13124: LIST
13125: LIST
13126: PPUSH
13127: CALL_OW 69
13131: IN
13132: IFFALSE 13148
// loss_counter := loss_counter + 1 ;
13134: LD_ADDR_EXP 13
13138: PUSH
13139: LD_EXP 13
13143: PUSH
13144: LD_INT 1
13146: PLUS
13147: ST_TO_ADDR
// if un = Abdul then
13148: LD_VAR 0 1
13152: PUSH
13153: LD_EXP 55
13157: EQUAL
13158: IFFALSE 13168
// abdul_escaped := false ;
13160: LD_ADDR_EXP 12
13164: PUSH
13165: LD_INT 0
13167: ST_TO_ADDR
// if un in ru_attackers then
13168: LD_VAR 0 1
13172: PUSH
13173: LD_EXP 52
13177: IN
13178: IFFALSE 13196
// ru_attackers := ru_attackers diff un ;
13180: LD_ADDR_EXP 52
13184: PUSH
13185: LD_EXP 52
13189: PUSH
13190: LD_VAR 0 1
13194: DIFF
13195: ST_TO_ADDR
// if un in ar_attackers then
13196: LD_VAR 0 1
13200: PUSH
13201: LD_EXP 10
13205: IN
13206: IFFALSE 13224
// ar_attackers := ar_attackers diff un ;
13208: LD_ADDR_EXP 10
13212: PUSH
13213: LD_EXP 10
13217: PUSH
13218: LD_VAR 0 1
13222: DIFF
13223: ST_TO_ADDR
// if un = JMM then
13224: LD_VAR 0 1
13228: PUSH
13229: LD_EXP 15
13233: EQUAL
13234: IFFALSE 13245
// begin YouLost ( JMM ) ;
13236: LD_STRING JMM
13238: PPUSH
13239: CALL_OW 104
// exit ;
13243: GO 13334
// end ; if un = Burlak then
13245: LD_VAR 0 1
13249: PUSH
13250: LD_EXP 46
13254: EQUAL
13255: IFFALSE 13266
// begin YouLost ( Burlak ) ;
13257: LD_STRING Burlak
13259: PPUSH
13260: CALL_OW 104
// exit ;
13264: GO 13334
// end ; if un = freedom then
13266: LD_VAR 0 1
13270: PUSH
13271: LD_EXP 3
13275: EQUAL
13276: IFFALSE 13287
// begin YouLost ( Destroyed ) ;
13278: LD_STRING Destroyed
13280: PPUSH
13281: CALL_OW 104
// exit ;
13285: GO 13334
// end ; if un = Masha then
13287: LD_VAR 0 1
13291: PUSH
13292: LD_EXP 49
13296: EQUAL
13297: IFFALSE 13306
// ChangeMissionObjectives ( M4b ) ;
13299: LD_STRING M4b
13301: PPUSH
13302: CALL_OW 337
// if un = Mastodont then
13306: LD_VAR 0 1
13310: PUSH
13311: LD_EXP 56
13315: EQUAL
13316: IFFALSE 13325
// ChangeMissionObjectives ( M4a ) ;
13318: LD_STRING M4a
13320: PPUSH
13321: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13325: LD_VAR 0 1
13329: PPUSH
13330: CALL 78175 0 1
// end ;
13334: PPOPN 3
13336: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13337: LD_VAR 0 1
13341: PPUSH
13342: LD_VAR 0 2
13346: PPUSH
13347: CALL 80509 0 2
// end ;
13351: PPOPN 2
13353: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13354: LD_VAR 0 1
13358: PPUSH
13359: CALL 79577 0 1
// end ;
13363: PPOPN 1
13365: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13366: LD_VAR 0 1
13370: PUSH
13371: LD_INT 22
13373: PUSH
13374: LD_INT 7
13376: PUSH
13377: EMPTY
13378: LIST
13379: LIST
13380: PUSH
13381: LD_INT 30
13383: PUSH
13384: LD_INT 0
13386: PUSH
13387: EMPTY
13388: LIST
13389: LIST
13390: PUSH
13391: EMPTY
13392: LIST
13393: LIST
13394: PPUSH
13395: CALL_OW 69
13399: IN
13400: IFFALSE 13439
// begin SetBName ( building , freedom ) ;
13402: LD_VAR 0 1
13406: PPUSH
13407: LD_STRING freedom
13409: PPUSH
13410: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13414: LD_INT 0
13416: PPUSH
13417: LD_INT 7
13419: PPUSH
13420: LD_INT 0
13422: PPUSH
13423: CALL_OW 324
// freedom := building ;
13427: LD_ADDR_EXP 3
13431: PUSH
13432: LD_VAR 0 1
13436: ST_TO_ADDR
// exit ;
13437: GO 13505
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13439: LD_VAR 0 1
13443: PUSH
13444: LD_INT 22
13446: PUSH
13447: LD_INT 7
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PUSH
13454: LD_INT 23
13456: PUSH
13457: LD_INT 3
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 30
13466: PUSH
13467: LD_INT 6
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: LIST
13478: PPUSH
13479: CALL_OW 69
13483: IN
13484: IFFALSE 13496
// begin ru_lab_builded := true ;
13486: LD_ADDR_EXP 5
13490: PUSH
13491: LD_INT 1
13493: ST_TO_ADDR
// exit ;
13494: GO 13505
// end ; MCE_BuildingComplete ( building ) ;
13496: LD_VAR 0 1
13500: PPUSH
13501: CALL 79818 0 1
// end ;
13505: PPOPN 1
13507: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13508: LD_VAR 0 1
13512: PPUSH
13513: LD_VAR 0 2
13517: PPUSH
13518: CALL 77871 0 2
// end ;
13522: PPOPN 2
13524: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13525: LD_VAR 0 1
13529: PPUSH
13530: LD_VAR 0 2
13534: PPUSH
13535: LD_VAR 0 3
13539: PPUSH
13540: LD_VAR 0 4
13544: PPUSH
13545: LD_VAR 0 5
13549: PPUSH
13550: CALL 77491 0 5
// end ;
13554: PPOPN 5
13556: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13557: LD_VAR 0 1
13561: PPUSH
13562: LD_VAR 0 2
13566: PPUSH
13567: CALL 77087 0 2
// end ;
13571: PPOPN 2
13573: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
13574: LD_VAR 0 1
13578: PPUSH
13579: CALL_OW 263
13583: PUSH
13584: LD_INT 3
13586: EQUAL
13587: PUSH
13588: LD_VAR 0 2
13592: PPUSH
13593: CALL_OW 263
13597: PUSH
13598: LD_INT 3
13600: EQUAL
13601: OR
13602: IFFALSE 13618
// hack_counter := hack_counter + 1 ;
13604: LD_ADDR_EXP 14
13608: PUSH
13609: LD_EXP 14
13613: PUSH
13614: LD_INT 1
13616: PLUS
13617: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13618: LD_VAR 0 1
13622: PPUSH
13623: LD_VAR 0 2
13627: PPUSH
13628: LD_VAR 0 3
13632: PPUSH
13633: LD_VAR 0 4
13637: PPUSH
13638: CALL 76925 0 4
// end ;
13642: PPOPN 4
13644: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13645: LD_VAR 0 1
13649: PPUSH
13650: LD_VAR 0 2
13654: PPUSH
13655: LD_VAR 0 3
13659: PPUSH
13660: CALL 76700 0 3
// end ;
13664: PPOPN 3
13666: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13667: LD_VAR 0 1
13671: PPUSH
13672: LD_VAR 0 2
13676: PPUSH
13677: CALL 76585 0 2
// end ;
13681: PPOPN 2
13683: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13684: LD_VAR 0 1
13688: PPUSH
13689: LD_VAR 0 2
13693: PPUSH
13694: CALL 80770 0 2
// end ;
13698: PPOPN 2
13700: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13701: LD_VAR 0 1
13705: PPUSH
13706: LD_VAR 0 2
13710: PPUSH
13711: LD_VAR 0 3
13715: PPUSH
13716: LD_VAR 0 4
13720: PPUSH
13721: CALL 80986 0 4
// end ;
13725: PPOPN 4
13727: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13728: LD_VAR 0 1
13732: PPUSH
13733: LD_VAR 0 2
13737: PPUSH
13738: CALL 76394 0 2
// end ;
13742: PPOPN 2
13744: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13745: LD_VAR 0 1
13749: PPUSH
13750: CALL 94544 0 1
// end ; end_of_file
13754: PPOPN 1
13756: END
// every 0 0$30 do var cr , time ;
13757: GO 13759
13759: DISABLE
13760: LD_INT 0
13762: PPUSH
13763: PPUSH
// begin time := 0 0$30 ;
13764: LD_ADDR_VAR 0 2
13768: PUSH
13769: LD_INT 1050
13771: ST_TO_ADDR
// while game do
13772: LD_EXP 2
13776: IFFALSE 13875
// begin wait ( time ) ;
13778: LD_VAR 0 2
13782: PPUSH
13783: CALL_OW 67
// if tick > 2 2$00 then
13787: LD_OWVAR 1
13791: PUSH
13792: LD_INT 4200
13794: GREATER
13795: IFFALSE 13828
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13797: LD_ADDR_VAR 0 2
13801: PUSH
13802: LD_VAR 0 2
13806: PUSH
13807: LD_INT 280
13809: PUSH
13810: LD_INT 420
13812: PUSH
13813: LD_INT 630
13815: PUSH
13816: EMPTY
13817: LIST
13818: LIST
13819: LIST
13820: PUSH
13821: LD_OWVAR 67
13825: ARRAY
13826: PLUS
13827: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13828: LD_INT 1
13830: PPUSH
13831: LD_INT 5
13833: PPUSH
13834: CALL_OW 12
13838: PPUSH
13839: LD_INT 70
13841: PPUSH
13842: LD_INT 49
13844: PPUSH
13845: LD_INT 25
13847: PPUSH
13848: LD_INT 1
13850: PPUSH
13851: CALL_OW 56
// if time > 5 5$00 then
13855: LD_VAR 0 2
13859: PUSH
13860: LD_INT 10500
13862: GREATER
13863: IFFALSE 13873
// time := 0 0$30 ;
13865: LD_ADDR_VAR 0 2
13869: PUSH
13870: LD_INT 1050
13872: ST_TO_ADDR
// end ;
13873: GO 13772
// end ;
13875: PPOPN 2
13877: END
// every 0 0$30 do var cr , time ;
13878: GO 13880
13880: DISABLE
13881: LD_INT 0
13883: PPUSH
13884: PPUSH
// begin time := 0 0$20 ;
13885: LD_ADDR_VAR 0 2
13889: PUSH
13890: LD_INT 700
13892: ST_TO_ADDR
// while game do
13893: LD_EXP 2
13897: IFFALSE 13986
// begin wait ( time ) ;
13899: LD_VAR 0 2
13903: PPUSH
13904: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13908: LD_ADDR_VAR 0 2
13912: PUSH
13913: LD_VAR 0 2
13917: PUSH
13918: LD_INT 490
13920: PUSH
13921: LD_INT 525
13923: PUSH
13924: LD_INT 560
13926: PUSH
13927: EMPTY
13928: LIST
13929: LIST
13930: LIST
13931: PUSH
13932: LD_OWVAR 67
13936: ARRAY
13937: PLUS
13938: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13939: LD_INT 3
13941: PPUSH
13942: LD_INT 5
13944: PPUSH
13945: CALL_OW 12
13949: PPUSH
13950: LD_INT 26
13952: PPUSH
13953: LD_INT 9
13955: PPUSH
13956: LD_INT 30
13958: PPUSH
13959: LD_INT 1
13961: PPUSH
13962: CALL_OW 56
// if time > 3 3$00 then
13966: LD_VAR 0 2
13970: PUSH
13971: LD_INT 6300
13973: GREATER
13974: IFFALSE 13984
// time := 0 0$20 ;
13976: LD_ADDR_VAR 0 2
13980: PUSH
13981: LD_INT 700
13983: ST_TO_ADDR
// end ;
13984: GO 13893
// end ;
13986: PPOPN 2
13988: END
// every 0 0$30 do var cr , time ;
13989: GO 13991
13991: DISABLE
13992: LD_INT 0
13994: PPUSH
13995: PPUSH
// begin time := 0 0$20 ;
13996: LD_ADDR_VAR 0 2
14000: PUSH
14001: LD_INT 700
14003: ST_TO_ADDR
// while game do
14004: LD_EXP 2
14008: IFFALSE 14133
// begin wait ( time ) ;
14010: LD_VAR 0 2
14014: PPUSH
14015: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14019: LD_ADDR_VAR 0 2
14023: PUSH
14024: LD_VAR 0 2
14028: PUSH
14029: LD_INT 175
14031: PUSH
14032: LD_INT 210
14034: PUSH
14035: LD_INT 280
14037: PUSH
14038: EMPTY
14039: LIST
14040: LIST
14041: LIST
14042: PUSH
14043: LD_OWVAR 67
14047: ARRAY
14048: PLUS
14049: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14050: LD_INT 1
14052: PPUSH
14053: LD_INT 5
14055: PPUSH
14056: CALL_OW 12
14060: PPUSH
14061: LD_INT 179
14063: PPUSH
14064: LD_INT 101
14066: PPUSH
14067: LD_INT 20
14069: PPUSH
14070: LD_INT 1
14072: PPUSH
14073: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14077: LD_INT 350
14079: PPUSH
14080: LD_INT 525
14082: PPUSH
14083: CALL_OW 12
14087: PPUSH
14088: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14092: LD_INT 1
14094: PPUSH
14095: LD_INT 5
14097: PPUSH
14098: CALL_OW 12
14102: PPUSH
14103: LD_INT 9
14105: PPUSH
14106: LD_INT 1
14108: PPUSH
14109: CALL_OW 55
// if time > 4 4$00 then
14113: LD_VAR 0 2
14117: PUSH
14118: LD_INT 8400
14120: GREATER
14121: IFFALSE 14131
// time := 0 0$30 ;
14123: LD_ADDR_VAR 0 2
14127: PUSH
14128: LD_INT 1050
14130: ST_TO_ADDR
// end ;
14131: GO 14004
// end ;
14133: PPOPN 2
14135: END
// every 0 0$30 do var cr , time ;
14136: GO 14138
14138: DISABLE
14139: LD_INT 0
14141: PPUSH
14142: PPUSH
// begin time := 0 0$10 ;
14143: LD_ADDR_VAR 0 2
14147: PUSH
14148: LD_INT 350
14150: ST_TO_ADDR
// while game do
14151: LD_EXP 2
14155: IFFALSE 14289
// begin wait ( time ) ;
14157: LD_VAR 0 2
14161: PPUSH
14162: CALL_OW 67
// time := time + 0 0$10 ;
14166: LD_ADDR_VAR 0 2
14170: PUSH
14171: LD_VAR 0 2
14175: PUSH
14176: LD_INT 350
14178: PLUS
14179: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14180: LD_INT 1
14182: PPUSH
14183: LD_INT 5
14185: PPUSH
14186: CALL_OW 12
14190: PPUSH
14191: LD_INT 11
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14201: LD_ADDR_VAR 0 1
14205: PUSH
14206: LD_INT 1
14208: PPUSH
14209: LD_INT 3
14211: PPUSH
14212: CALL_OW 12
14216: ST_TO_ADDR
// if cr = 1 then
14217: LD_VAR 0 1
14221: PUSH
14222: LD_INT 1
14224: EQUAL
14225: IFFALSE 14269
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14227: LD_INT 700
14229: PPUSH
14230: LD_INT 1575
14232: PPUSH
14233: CALL_OW 12
14237: PPUSH
14238: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14242: LD_INT 1
14244: PPUSH
14245: LD_INT 5
14247: PPUSH
14248: CALL_OW 12
14252: PPUSH
14253: LD_INT 34
14255: PPUSH
14256: LD_INT 50
14258: PPUSH
14259: LD_INT 7
14261: PPUSH
14262: LD_INT 1
14264: PPUSH
14265: CALL_OW 56
// end ; if time > 8 8$00 then
14269: LD_VAR 0 2
14273: PUSH
14274: LD_INT 16800
14276: GREATER
14277: IFFALSE 14287
// time := 0 0$40 ;
14279: LD_ADDR_VAR 0 2
14283: PUSH
14284: LD_INT 1400
14286: ST_TO_ADDR
// end ;
14287: GO 14151
// end ; end_of_file
14289: PPOPN 2
14291: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14292: LD_INT 0
14294: PPUSH
14295: PPUSH
// if exist_mode then
14296: LD_VAR 0 2
14300: IFFALSE 14325
// unit := CreateCharacter ( prefix & ident ) else
14302: LD_ADDR_VAR 0 5
14306: PUSH
14307: LD_VAR 0 3
14311: PUSH
14312: LD_VAR 0 1
14316: STR
14317: PPUSH
14318: CALL_OW 34
14322: ST_TO_ADDR
14323: GO 14340
// unit := NewCharacter ( ident ) ;
14325: LD_ADDR_VAR 0 5
14329: PUSH
14330: LD_VAR 0 1
14334: PPUSH
14335: CALL_OW 25
14339: ST_TO_ADDR
// result := unit ;
14340: LD_ADDR_VAR 0 4
14344: PUSH
14345: LD_VAR 0 5
14349: ST_TO_ADDR
// end ;
14350: LD_VAR 0 4
14354: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14355: LD_INT 0
14357: PPUSH
14358: PPUSH
// if not side or not nation then
14359: LD_VAR 0 1
14363: NOT
14364: PUSH
14365: LD_VAR 0 2
14369: NOT
14370: OR
14371: IFFALSE 14375
// exit ;
14373: GO 15139
// case nation of nation_american :
14375: LD_VAR 0 2
14379: PUSH
14380: LD_INT 1
14382: DOUBLE
14383: EQUAL
14384: IFTRUE 14388
14386: GO 14602
14388: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14389: LD_ADDR_VAR 0 4
14393: PUSH
14394: LD_INT 35
14396: PUSH
14397: LD_INT 45
14399: PUSH
14400: LD_INT 46
14402: PUSH
14403: LD_INT 47
14405: PUSH
14406: LD_INT 82
14408: PUSH
14409: LD_INT 83
14411: PUSH
14412: LD_INT 84
14414: PUSH
14415: LD_INT 85
14417: PUSH
14418: LD_INT 86
14420: PUSH
14421: LD_INT 1
14423: PUSH
14424: LD_INT 2
14426: PUSH
14427: LD_INT 6
14429: PUSH
14430: LD_INT 15
14432: PUSH
14433: LD_INT 16
14435: PUSH
14436: LD_INT 7
14438: PUSH
14439: LD_INT 12
14441: PUSH
14442: LD_INT 13
14444: PUSH
14445: LD_INT 10
14447: PUSH
14448: LD_INT 14
14450: PUSH
14451: LD_INT 20
14453: PUSH
14454: LD_INT 21
14456: PUSH
14457: LD_INT 22
14459: PUSH
14460: LD_INT 25
14462: PUSH
14463: LD_INT 32
14465: PUSH
14466: LD_INT 27
14468: PUSH
14469: LD_INT 36
14471: PUSH
14472: LD_INT 69
14474: PUSH
14475: LD_INT 39
14477: PUSH
14478: LD_INT 34
14480: PUSH
14481: LD_INT 40
14483: PUSH
14484: LD_INT 48
14486: PUSH
14487: LD_INT 49
14489: PUSH
14490: LD_INT 50
14492: PUSH
14493: LD_INT 51
14495: PUSH
14496: LD_INT 52
14498: PUSH
14499: LD_INT 53
14501: PUSH
14502: LD_INT 54
14504: PUSH
14505: LD_INT 55
14507: PUSH
14508: LD_INT 56
14510: PUSH
14511: LD_INT 57
14513: PUSH
14514: LD_INT 58
14516: PUSH
14517: LD_INT 59
14519: PUSH
14520: LD_INT 60
14522: PUSH
14523: LD_INT 61
14525: PUSH
14526: LD_INT 62
14528: PUSH
14529: LD_INT 80
14531: PUSH
14532: LD_INT 82
14534: PUSH
14535: LD_INT 83
14537: PUSH
14538: LD_INT 84
14540: PUSH
14541: LD_INT 85
14543: PUSH
14544: LD_INT 86
14546: PUSH
14547: EMPTY
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: LIST
14598: LIST
14599: ST_TO_ADDR
14600: GO 15063
14602: LD_INT 2
14604: DOUBLE
14605: EQUAL
14606: IFTRUE 14610
14608: GO 14832
14610: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
14611: LD_ADDR_VAR 0 4
14615: PUSH
14616: LD_INT 35
14618: PUSH
14619: LD_INT 45
14621: PUSH
14622: LD_INT 46
14624: PUSH
14625: LD_INT 47
14627: PUSH
14628: LD_INT 82
14630: PUSH
14631: LD_INT 83
14633: PUSH
14634: LD_INT 84
14636: PUSH
14637: LD_INT 85
14639: PUSH
14640: LD_INT 87
14642: PUSH
14643: LD_INT 70
14645: PUSH
14646: LD_INT 1
14648: PUSH
14649: LD_INT 11
14651: PUSH
14652: LD_INT 3
14654: PUSH
14655: LD_INT 4
14657: PUSH
14658: LD_INT 5
14660: PUSH
14661: LD_INT 6
14663: PUSH
14664: LD_INT 15
14666: PUSH
14667: LD_INT 18
14669: PUSH
14670: LD_INT 7
14672: PUSH
14673: LD_INT 17
14675: PUSH
14676: LD_INT 8
14678: PUSH
14679: LD_INT 20
14681: PUSH
14682: LD_INT 21
14684: PUSH
14685: LD_INT 22
14687: PUSH
14688: LD_INT 72
14690: PUSH
14691: LD_INT 26
14693: PUSH
14694: LD_INT 69
14696: PUSH
14697: LD_INT 39
14699: PUSH
14700: LD_INT 40
14702: PUSH
14703: LD_INT 41
14705: PUSH
14706: LD_INT 42
14708: PUSH
14709: LD_INT 43
14711: PUSH
14712: LD_INT 48
14714: PUSH
14715: LD_INT 49
14717: PUSH
14718: LD_INT 50
14720: PUSH
14721: LD_INT 51
14723: PUSH
14724: LD_INT 52
14726: PUSH
14727: LD_INT 53
14729: PUSH
14730: LD_INT 54
14732: PUSH
14733: LD_INT 55
14735: PUSH
14736: LD_INT 56
14738: PUSH
14739: LD_INT 60
14741: PUSH
14742: LD_INT 61
14744: PUSH
14745: LD_INT 62
14747: PUSH
14748: LD_INT 66
14750: PUSH
14751: LD_INT 67
14753: PUSH
14754: LD_INT 68
14756: PUSH
14757: LD_INT 81
14759: PUSH
14760: LD_INT 82
14762: PUSH
14763: LD_INT 83
14765: PUSH
14766: LD_INT 84
14768: PUSH
14769: LD_INT 85
14771: PUSH
14772: LD_INT 87
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: LIST
14779: LIST
14780: LIST
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: LIST
14795: LIST
14796: LIST
14797: LIST
14798: LIST
14799: LIST
14800: LIST
14801: LIST
14802: LIST
14803: LIST
14804: LIST
14805: LIST
14806: LIST
14807: LIST
14808: LIST
14809: LIST
14810: LIST
14811: LIST
14812: LIST
14813: LIST
14814: LIST
14815: LIST
14816: LIST
14817: LIST
14818: LIST
14819: LIST
14820: LIST
14821: LIST
14822: LIST
14823: LIST
14824: LIST
14825: LIST
14826: LIST
14827: LIST
14828: LIST
14829: ST_TO_ADDR
14830: GO 15063
14832: LD_INT 3
14834: DOUBLE
14835: EQUAL
14836: IFTRUE 14840
14838: GO 15062
14840: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14841: LD_ADDR_VAR 0 4
14845: PUSH
14846: LD_INT 46
14848: PUSH
14849: LD_INT 47
14851: PUSH
14852: LD_INT 1
14854: PUSH
14855: LD_INT 2
14857: PUSH
14858: LD_INT 82
14860: PUSH
14861: LD_INT 83
14863: PUSH
14864: LD_INT 84
14866: PUSH
14867: LD_INT 85
14869: PUSH
14870: LD_INT 86
14872: PUSH
14873: LD_INT 11
14875: PUSH
14876: LD_INT 9
14878: PUSH
14879: LD_INT 20
14881: PUSH
14882: LD_INT 19
14884: PUSH
14885: LD_INT 21
14887: PUSH
14888: LD_INT 24
14890: PUSH
14891: LD_INT 22
14893: PUSH
14894: LD_INT 25
14896: PUSH
14897: LD_INT 28
14899: PUSH
14900: LD_INT 29
14902: PUSH
14903: LD_INT 30
14905: PUSH
14906: LD_INT 31
14908: PUSH
14909: LD_INT 37
14911: PUSH
14912: LD_INT 38
14914: PUSH
14915: LD_INT 32
14917: PUSH
14918: LD_INT 27
14920: PUSH
14921: LD_INT 33
14923: PUSH
14924: LD_INT 69
14926: PUSH
14927: LD_INT 39
14929: PUSH
14930: LD_INT 34
14932: PUSH
14933: LD_INT 40
14935: PUSH
14936: LD_INT 71
14938: PUSH
14939: LD_INT 23
14941: PUSH
14942: LD_INT 44
14944: PUSH
14945: LD_INT 48
14947: PUSH
14948: LD_INT 49
14950: PUSH
14951: LD_INT 50
14953: PUSH
14954: LD_INT 51
14956: PUSH
14957: LD_INT 52
14959: PUSH
14960: LD_INT 53
14962: PUSH
14963: LD_INT 54
14965: PUSH
14966: LD_INT 55
14968: PUSH
14969: LD_INT 56
14971: PUSH
14972: LD_INT 57
14974: PUSH
14975: LD_INT 58
14977: PUSH
14978: LD_INT 59
14980: PUSH
14981: LD_INT 63
14983: PUSH
14984: LD_INT 64
14986: PUSH
14987: LD_INT 65
14989: PUSH
14990: LD_INT 82
14992: PUSH
14993: LD_INT 83
14995: PUSH
14996: LD_INT 84
14998: PUSH
14999: LD_INT 85
15001: PUSH
15002: LD_INT 86
15004: PUSH
15005: EMPTY
15006: LIST
15007: LIST
15008: LIST
15009: LIST
15010: LIST
15011: LIST
15012: LIST
15013: LIST
15014: LIST
15015: LIST
15016: LIST
15017: LIST
15018: LIST
15019: LIST
15020: LIST
15021: LIST
15022: LIST
15023: LIST
15024: LIST
15025: LIST
15026: LIST
15027: LIST
15028: LIST
15029: LIST
15030: LIST
15031: LIST
15032: LIST
15033: LIST
15034: LIST
15035: LIST
15036: LIST
15037: LIST
15038: LIST
15039: LIST
15040: LIST
15041: LIST
15042: LIST
15043: LIST
15044: LIST
15045: LIST
15046: LIST
15047: LIST
15048: LIST
15049: LIST
15050: LIST
15051: LIST
15052: LIST
15053: LIST
15054: LIST
15055: LIST
15056: LIST
15057: LIST
15058: LIST
15059: ST_TO_ADDR
15060: GO 15063
15062: POP
// if state > - 1 and state < 3 then
15063: LD_VAR 0 3
15067: PUSH
15068: LD_INT 1
15070: NEG
15071: GREATER
15072: PUSH
15073: LD_VAR 0 3
15077: PUSH
15078: LD_INT 3
15080: LESS
15081: AND
15082: IFFALSE 15139
// for i in result do
15084: LD_ADDR_VAR 0 5
15088: PUSH
15089: LD_VAR 0 4
15093: PUSH
15094: FOR_IN
15095: IFFALSE 15137
// if GetTech ( i , side ) <> state then
15097: LD_VAR 0 5
15101: PPUSH
15102: LD_VAR 0 1
15106: PPUSH
15107: CALL_OW 321
15111: PUSH
15112: LD_VAR 0 3
15116: NONEQUAL
15117: IFFALSE 15135
// result := result diff i ;
15119: LD_ADDR_VAR 0 4
15123: PUSH
15124: LD_VAR 0 4
15128: PUSH
15129: LD_VAR 0 5
15133: DIFF
15134: ST_TO_ADDR
15135: GO 15094
15137: POP
15138: POP
// end ;
15139: LD_VAR 0 4
15143: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15144: LD_INT 0
15146: PPUSH
15147: PPUSH
15148: PPUSH
// result := true ;
15149: LD_ADDR_VAR 0 3
15153: PUSH
15154: LD_INT 1
15156: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15157: LD_ADDR_VAR 0 5
15161: PUSH
15162: LD_VAR 0 2
15166: PPUSH
15167: CALL_OW 480
15171: ST_TO_ADDR
// if not tmp then
15172: LD_VAR 0 5
15176: NOT
15177: IFFALSE 15181
// exit ;
15179: GO 15230
// for i in tmp do
15181: LD_ADDR_VAR 0 4
15185: PUSH
15186: LD_VAR 0 5
15190: PUSH
15191: FOR_IN
15192: IFFALSE 15228
// if GetTech ( i , side ) <> state_researched then
15194: LD_VAR 0 4
15198: PPUSH
15199: LD_VAR 0 1
15203: PPUSH
15204: CALL_OW 321
15208: PUSH
15209: LD_INT 2
15211: NONEQUAL
15212: IFFALSE 15226
// begin result := false ;
15214: LD_ADDR_VAR 0 3
15218: PUSH
15219: LD_INT 0
15221: ST_TO_ADDR
// exit ;
15222: POP
15223: POP
15224: GO 15230
// end ;
15226: GO 15191
15228: POP
15229: POP
// end ;
15230: LD_VAR 0 3
15234: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15235: LD_INT 0
15237: PPUSH
15238: PPUSH
15239: PPUSH
15240: PPUSH
15241: PPUSH
15242: PPUSH
15243: PPUSH
15244: PPUSH
15245: PPUSH
15246: PPUSH
15247: PPUSH
15248: PPUSH
15249: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15250: LD_VAR 0 1
15254: NOT
15255: PUSH
15256: LD_VAR 0 1
15260: PPUSH
15261: CALL_OW 257
15265: PUSH
15266: LD_INT 9
15268: NONEQUAL
15269: OR
15270: IFFALSE 15274
// exit ;
15272: GO 15847
// side := GetSide ( unit ) ;
15274: LD_ADDR_VAR 0 9
15278: PUSH
15279: LD_VAR 0 1
15283: PPUSH
15284: CALL_OW 255
15288: ST_TO_ADDR
// tech_space := tech_spacanom ;
15289: LD_ADDR_VAR 0 12
15293: PUSH
15294: LD_INT 29
15296: ST_TO_ADDR
// tech_time := tech_taurad ;
15297: LD_ADDR_VAR 0 13
15301: PUSH
15302: LD_INT 28
15304: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15305: LD_ADDR_VAR 0 11
15309: PUSH
15310: LD_VAR 0 1
15314: PPUSH
15315: CALL_OW 310
15319: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15320: LD_VAR 0 11
15324: PPUSH
15325: CALL_OW 247
15329: PUSH
15330: LD_INT 2
15332: EQUAL
15333: IFFALSE 15337
// exit ;
15335: GO 15847
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15337: LD_ADDR_VAR 0 8
15341: PUSH
15342: LD_INT 81
15344: PUSH
15345: LD_VAR 0 9
15349: PUSH
15350: EMPTY
15351: LIST
15352: LIST
15353: PUSH
15354: LD_INT 3
15356: PUSH
15357: LD_INT 21
15359: PUSH
15360: LD_INT 3
15362: PUSH
15363: EMPTY
15364: LIST
15365: LIST
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: PPUSH
15375: CALL_OW 69
15379: ST_TO_ADDR
// if not tmp then
15380: LD_VAR 0 8
15384: NOT
15385: IFFALSE 15389
// exit ;
15387: GO 15847
// if in_unit then
15389: LD_VAR 0 11
15393: IFFALSE 15417
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15395: LD_ADDR_VAR 0 10
15399: PUSH
15400: LD_VAR 0 8
15404: PPUSH
15405: LD_VAR 0 11
15409: PPUSH
15410: CALL_OW 74
15414: ST_TO_ADDR
15415: GO 15437
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15417: LD_ADDR_VAR 0 10
15421: PUSH
15422: LD_VAR 0 8
15426: PPUSH
15427: LD_VAR 0 1
15431: PPUSH
15432: CALL_OW 74
15436: ST_TO_ADDR
// if not enemy then
15437: LD_VAR 0 10
15441: NOT
15442: IFFALSE 15446
// exit ;
15444: GO 15847
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15446: LD_VAR 0 11
15450: PUSH
15451: LD_VAR 0 11
15455: PPUSH
15456: LD_VAR 0 10
15460: PPUSH
15461: CALL_OW 296
15465: PUSH
15466: LD_INT 13
15468: GREATER
15469: AND
15470: PUSH
15471: LD_VAR 0 1
15475: PPUSH
15476: LD_VAR 0 10
15480: PPUSH
15481: CALL_OW 296
15485: PUSH
15486: LD_INT 12
15488: GREATER
15489: OR
15490: IFFALSE 15494
// exit ;
15492: GO 15847
// missile := [ 1 ] ;
15494: LD_ADDR_VAR 0 14
15498: PUSH
15499: LD_INT 1
15501: PUSH
15502: EMPTY
15503: LIST
15504: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15505: LD_VAR 0 9
15509: PPUSH
15510: LD_VAR 0 12
15514: PPUSH
15515: CALL_OW 325
15519: IFFALSE 15548
// missile := Insert ( missile , missile + 1 , 2 ) ;
15521: LD_ADDR_VAR 0 14
15525: PUSH
15526: LD_VAR 0 14
15530: PPUSH
15531: LD_VAR 0 14
15535: PUSH
15536: LD_INT 1
15538: PLUS
15539: PPUSH
15540: LD_INT 2
15542: PPUSH
15543: CALL_OW 2
15547: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15548: LD_VAR 0 9
15552: PPUSH
15553: LD_VAR 0 13
15557: PPUSH
15558: CALL_OW 325
15562: PUSH
15563: LD_VAR 0 10
15567: PPUSH
15568: CALL_OW 255
15572: PPUSH
15573: LD_VAR 0 13
15577: PPUSH
15578: CALL_OW 325
15582: NOT
15583: AND
15584: IFFALSE 15613
// missile := Insert ( missile , missile + 1 , 3 ) ;
15586: LD_ADDR_VAR 0 14
15590: PUSH
15591: LD_VAR 0 14
15595: PPUSH
15596: LD_VAR 0 14
15600: PUSH
15601: LD_INT 1
15603: PLUS
15604: PPUSH
15605: LD_INT 3
15607: PPUSH
15608: CALL_OW 2
15612: ST_TO_ADDR
// if missile < 2 then
15613: LD_VAR 0 14
15617: PUSH
15618: LD_INT 2
15620: LESS
15621: IFFALSE 15625
// exit ;
15623: GO 15847
// x := GetX ( enemy ) ;
15625: LD_ADDR_VAR 0 4
15629: PUSH
15630: LD_VAR 0 10
15634: PPUSH
15635: CALL_OW 250
15639: ST_TO_ADDR
// y := GetY ( enemy ) ;
15640: LD_ADDR_VAR 0 5
15644: PUSH
15645: LD_VAR 0 10
15649: PPUSH
15650: CALL_OW 251
15654: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15655: LD_ADDR_VAR 0 6
15659: PUSH
15660: LD_VAR 0 4
15664: PUSH
15665: LD_INT 1
15667: NEG
15668: PPUSH
15669: LD_INT 1
15671: PPUSH
15672: CALL_OW 12
15676: PLUS
15677: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15678: LD_ADDR_VAR 0 7
15682: PUSH
15683: LD_VAR 0 5
15687: PUSH
15688: LD_INT 1
15690: NEG
15691: PPUSH
15692: LD_INT 1
15694: PPUSH
15695: CALL_OW 12
15699: PLUS
15700: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15701: LD_VAR 0 6
15705: PPUSH
15706: LD_VAR 0 7
15710: PPUSH
15711: CALL_OW 488
15715: NOT
15716: IFFALSE 15738
// begin _x := x ;
15718: LD_ADDR_VAR 0 6
15722: PUSH
15723: LD_VAR 0 4
15727: ST_TO_ADDR
// _y := y ;
15728: LD_ADDR_VAR 0 7
15732: PUSH
15733: LD_VAR 0 5
15737: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15738: LD_ADDR_VAR 0 3
15742: PUSH
15743: LD_INT 1
15745: PPUSH
15746: LD_VAR 0 14
15750: PPUSH
15751: CALL_OW 12
15755: ST_TO_ADDR
// case i of 1 :
15756: LD_VAR 0 3
15760: PUSH
15761: LD_INT 1
15763: DOUBLE
15764: EQUAL
15765: IFTRUE 15769
15767: GO 15786
15769: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15770: LD_VAR 0 1
15774: PPUSH
15775: LD_VAR 0 10
15779: PPUSH
15780: CALL_OW 115
15784: GO 15847
15786: LD_INT 2
15788: DOUBLE
15789: EQUAL
15790: IFTRUE 15794
15792: GO 15816
15794: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15795: LD_VAR 0 1
15799: PPUSH
15800: LD_VAR 0 6
15804: PPUSH
15805: LD_VAR 0 7
15809: PPUSH
15810: CALL_OW 153
15814: GO 15847
15816: LD_INT 3
15818: DOUBLE
15819: EQUAL
15820: IFTRUE 15824
15822: GO 15846
15824: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15825: LD_VAR 0 1
15829: PPUSH
15830: LD_VAR 0 6
15834: PPUSH
15835: LD_VAR 0 7
15839: PPUSH
15840: CALL_OW 154
15844: GO 15847
15846: POP
// end ;
15847: LD_VAR 0 2
15851: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15852: LD_INT 0
15854: PPUSH
15855: PPUSH
15856: PPUSH
15857: PPUSH
15858: PPUSH
15859: PPUSH
// if not unit or not building then
15860: LD_VAR 0 1
15864: NOT
15865: PUSH
15866: LD_VAR 0 2
15870: NOT
15871: OR
15872: IFFALSE 15876
// exit ;
15874: GO 16034
// x := GetX ( building ) ;
15876: LD_ADDR_VAR 0 5
15880: PUSH
15881: LD_VAR 0 2
15885: PPUSH
15886: CALL_OW 250
15890: ST_TO_ADDR
// y := GetY ( building ) ;
15891: LD_ADDR_VAR 0 6
15895: PUSH
15896: LD_VAR 0 2
15900: PPUSH
15901: CALL_OW 251
15905: ST_TO_ADDR
// for i = 0 to 5 do
15906: LD_ADDR_VAR 0 4
15910: PUSH
15911: DOUBLE
15912: LD_INT 0
15914: DEC
15915: ST_TO_ADDR
15916: LD_INT 5
15918: PUSH
15919: FOR_TO
15920: IFFALSE 16032
// begin _x := ShiftX ( x , i , 3 ) ;
15922: LD_ADDR_VAR 0 7
15926: PUSH
15927: LD_VAR 0 5
15931: PPUSH
15932: LD_VAR 0 4
15936: PPUSH
15937: LD_INT 3
15939: PPUSH
15940: CALL_OW 272
15944: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15945: LD_ADDR_VAR 0 8
15949: PUSH
15950: LD_VAR 0 6
15954: PPUSH
15955: LD_VAR 0 4
15959: PPUSH
15960: LD_INT 3
15962: PPUSH
15963: CALL_OW 273
15967: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15968: LD_VAR 0 7
15972: PPUSH
15973: LD_VAR 0 8
15977: PPUSH
15978: CALL_OW 488
15982: NOT
15983: IFFALSE 15987
// continue ;
15985: GO 15919
// if HexInfo ( _x , _y ) = 0 then
15987: LD_VAR 0 7
15991: PPUSH
15992: LD_VAR 0 8
15996: PPUSH
15997: CALL_OW 428
16001: PUSH
16002: LD_INT 0
16004: EQUAL
16005: IFFALSE 16030
// begin ComMoveXY ( unit , _x , _y ) ;
16007: LD_VAR 0 1
16011: PPUSH
16012: LD_VAR 0 7
16016: PPUSH
16017: LD_VAR 0 8
16021: PPUSH
16022: CALL_OW 111
// exit ;
16026: POP
16027: POP
16028: GO 16034
// end ; end ;
16030: GO 15919
16032: POP
16033: POP
// end ;
16034: LD_VAR 0 3
16038: RET
// export function ScanBase ( side , base_area ) ; begin
16039: LD_INT 0
16041: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16042: LD_ADDR_VAR 0 3
16046: PUSH
16047: LD_VAR 0 2
16051: PPUSH
16052: LD_INT 81
16054: PUSH
16055: LD_VAR 0 1
16059: PUSH
16060: EMPTY
16061: LIST
16062: LIST
16063: PPUSH
16064: CALL_OW 70
16068: ST_TO_ADDR
// end ;
16069: LD_VAR 0 3
16073: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16074: LD_INT 0
16076: PPUSH
16077: PPUSH
16078: PPUSH
16079: PPUSH
// result := false ;
16080: LD_ADDR_VAR 0 2
16084: PUSH
16085: LD_INT 0
16087: ST_TO_ADDR
// side := GetSide ( unit ) ;
16088: LD_ADDR_VAR 0 3
16092: PUSH
16093: LD_VAR 0 1
16097: PPUSH
16098: CALL_OW 255
16102: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16103: LD_ADDR_VAR 0 4
16107: PUSH
16108: LD_VAR 0 1
16112: PPUSH
16113: CALL_OW 248
16117: ST_TO_ADDR
// case nat of 1 :
16118: LD_VAR 0 4
16122: PUSH
16123: LD_INT 1
16125: DOUBLE
16126: EQUAL
16127: IFTRUE 16131
16129: GO 16142
16131: POP
// tech := tech_lassight ; 2 :
16132: LD_ADDR_VAR 0 5
16136: PUSH
16137: LD_INT 12
16139: ST_TO_ADDR
16140: GO 16181
16142: LD_INT 2
16144: DOUBLE
16145: EQUAL
16146: IFTRUE 16150
16148: GO 16161
16150: POP
// tech := tech_mortar ; 3 :
16151: LD_ADDR_VAR 0 5
16155: PUSH
16156: LD_INT 41
16158: ST_TO_ADDR
16159: GO 16181
16161: LD_INT 3
16163: DOUBLE
16164: EQUAL
16165: IFTRUE 16169
16167: GO 16180
16169: POP
// tech := tech_bazooka ; end ;
16170: LD_ADDR_VAR 0 5
16174: PUSH
16175: LD_INT 44
16177: ST_TO_ADDR
16178: GO 16181
16180: POP
// if Researched ( side , tech ) then
16181: LD_VAR 0 3
16185: PPUSH
16186: LD_VAR 0 5
16190: PPUSH
16191: CALL_OW 325
16195: IFFALSE 16222
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16197: LD_ADDR_VAR 0 2
16201: PUSH
16202: LD_INT 5
16204: PUSH
16205: LD_INT 8
16207: PUSH
16208: LD_INT 9
16210: PUSH
16211: EMPTY
16212: LIST
16213: LIST
16214: LIST
16215: PUSH
16216: LD_VAR 0 4
16220: ARRAY
16221: ST_TO_ADDR
// end ;
16222: LD_VAR 0 2
16226: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16227: LD_INT 0
16229: PPUSH
16230: PPUSH
16231: PPUSH
// if not mines then
16232: LD_VAR 0 2
16236: NOT
16237: IFFALSE 16241
// exit ;
16239: GO 16385
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16241: LD_ADDR_VAR 0 5
16245: PUSH
16246: LD_INT 81
16248: PUSH
16249: LD_VAR 0 1
16253: PUSH
16254: EMPTY
16255: LIST
16256: LIST
16257: PUSH
16258: LD_INT 3
16260: PUSH
16261: LD_INT 21
16263: PUSH
16264: LD_INT 3
16266: PUSH
16267: EMPTY
16268: LIST
16269: LIST
16270: PUSH
16271: EMPTY
16272: LIST
16273: LIST
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: PPUSH
16279: CALL_OW 69
16283: ST_TO_ADDR
// for i in mines do
16284: LD_ADDR_VAR 0 4
16288: PUSH
16289: LD_VAR 0 2
16293: PUSH
16294: FOR_IN
16295: IFFALSE 16383
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16297: LD_VAR 0 4
16301: PUSH
16302: LD_INT 1
16304: ARRAY
16305: PPUSH
16306: LD_VAR 0 4
16310: PUSH
16311: LD_INT 2
16313: ARRAY
16314: PPUSH
16315: CALL_OW 458
16319: NOT
16320: IFFALSE 16324
// continue ;
16322: GO 16294
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16324: LD_VAR 0 4
16328: PUSH
16329: LD_INT 1
16331: ARRAY
16332: PPUSH
16333: LD_VAR 0 4
16337: PUSH
16338: LD_INT 2
16340: ARRAY
16341: PPUSH
16342: CALL_OW 428
16346: PUSH
16347: LD_VAR 0 5
16351: IN
16352: IFFALSE 16381
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16354: LD_VAR 0 4
16358: PUSH
16359: LD_INT 1
16361: ARRAY
16362: PPUSH
16363: LD_VAR 0 4
16367: PUSH
16368: LD_INT 2
16370: ARRAY
16371: PPUSH
16372: LD_VAR 0 1
16376: PPUSH
16377: CALL_OW 456
// end ;
16381: GO 16294
16383: POP
16384: POP
// end ;
16385: LD_VAR 0 3
16389: RET
// export function Count ( array ) ; var i ; begin
16390: LD_INT 0
16392: PPUSH
16393: PPUSH
// result := 0 ;
16394: LD_ADDR_VAR 0 2
16398: PUSH
16399: LD_INT 0
16401: ST_TO_ADDR
// for i in array do
16402: LD_ADDR_VAR 0 3
16406: PUSH
16407: LD_VAR 0 1
16411: PUSH
16412: FOR_IN
16413: IFFALSE 16437
// if i then
16415: LD_VAR 0 3
16419: IFFALSE 16435
// result := result + 1 ;
16421: LD_ADDR_VAR 0 2
16425: PUSH
16426: LD_VAR 0 2
16430: PUSH
16431: LD_INT 1
16433: PLUS
16434: ST_TO_ADDR
16435: GO 16412
16437: POP
16438: POP
// end ;
16439: LD_VAR 0 2
16443: RET
// export function IsEmpty ( building ) ; begin
16444: LD_INT 0
16446: PPUSH
// if not building then
16447: LD_VAR 0 1
16451: NOT
16452: IFFALSE 16456
// exit ;
16454: GO 16499
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
16456: LD_ADDR_VAR 0 2
16460: PUSH
16461: LD_VAR 0 1
16465: PUSH
16466: LD_INT 22
16468: PUSH
16469: LD_VAR 0 1
16473: PPUSH
16474: CALL_OW 255
16478: PUSH
16479: EMPTY
16480: LIST
16481: LIST
16482: PUSH
16483: LD_INT 58
16485: PUSH
16486: EMPTY
16487: LIST
16488: PUSH
16489: EMPTY
16490: LIST
16491: LIST
16492: PPUSH
16493: CALL_OW 69
16497: IN
16498: ST_TO_ADDR
// end ;
16499: LD_VAR 0 2
16503: RET
// export function IsNotFull ( building ) ; begin
16504: LD_INT 0
16506: PPUSH
// if not building then
16507: LD_VAR 0 1
16511: NOT
16512: IFFALSE 16516
// exit ;
16514: GO 16535
// result := UnitsInside ( building ) < 6 ;
16516: LD_ADDR_VAR 0 2
16520: PUSH
16521: LD_VAR 0 1
16525: PPUSH
16526: CALL_OW 313
16530: PUSH
16531: LD_INT 6
16533: LESS
16534: ST_TO_ADDR
// end ;
16535: LD_VAR 0 2
16539: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
16540: LD_INT 0
16542: PPUSH
16543: PPUSH
16544: PPUSH
16545: PPUSH
// tmp := [ ] ;
16546: LD_ADDR_VAR 0 3
16550: PUSH
16551: EMPTY
16552: ST_TO_ADDR
// list := [ ] ;
16553: LD_ADDR_VAR 0 5
16557: PUSH
16558: EMPTY
16559: ST_TO_ADDR
// for i = 16 to 25 do
16560: LD_ADDR_VAR 0 4
16564: PUSH
16565: DOUBLE
16566: LD_INT 16
16568: DEC
16569: ST_TO_ADDR
16570: LD_INT 25
16572: PUSH
16573: FOR_TO
16574: IFFALSE 16647
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
16576: LD_ADDR_VAR 0 3
16580: PUSH
16581: LD_VAR 0 3
16585: PUSH
16586: LD_INT 22
16588: PUSH
16589: LD_VAR 0 1
16593: PPUSH
16594: CALL_OW 255
16598: PUSH
16599: EMPTY
16600: LIST
16601: LIST
16602: PUSH
16603: LD_INT 91
16605: PUSH
16606: LD_VAR 0 1
16610: PUSH
16611: LD_INT 6
16613: PUSH
16614: EMPTY
16615: LIST
16616: LIST
16617: LIST
16618: PUSH
16619: LD_INT 30
16621: PUSH
16622: LD_VAR 0 4
16626: PUSH
16627: EMPTY
16628: LIST
16629: LIST
16630: PUSH
16631: EMPTY
16632: LIST
16633: LIST
16634: LIST
16635: PUSH
16636: EMPTY
16637: LIST
16638: PPUSH
16639: CALL_OW 69
16643: ADD
16644: ST_TO_ADDR
16645: GO 16573
16647: POP
16648: POP
// for i = 1 to tmp do
16649: LD_ADDR_VAR 0 4
16653: PUSH
16654: DOUBLE
16655: LD_INT 1
16657: DEC
16658: ST_TO_ADDR
16659: LD_VAR 0 3
16663: PUSH
16664: FOR_TO
16665: IFFALSE 16753
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
16667: LD_ADDR_VAR 0 5
16671: PUSH
16672: LD_VAR 0 5
16676: PUSH
16677: LD_VAR 0 3
16681: PUSH
16682: LD_VAR 0 4
16686: ARRAY
16687: PPUSH
16688: CALL_OW 266
16692: PUSH
16693: LD_VAR 0 3
16697: PUSH
16698: LD_VAR 0 4
16702: ARRAY
16703: PPUSH
16704: CALL_OW 250
16708: PUSH
16709: LD_VAR 0 3
16713: PUSH
16714: LD_VAR 0 4
16718: ARRAY
16719: PPUSH
16720: CALL_OW 251
16724: PUSH
16725: LD_VAR 0 3
16729: PUSH
16730: LD_VAR 0 4
16734: ARRAY
16735: PPUSH
16736: CALL_OW 254
16740: PUSH
16741: EMPTY
16742: LIST
16743: LIST
16744: LIST
16745: LIST
16746: PUSH
16747: EMPTY
16748: LIST
16749: ADD
16750: ST_TO_ADDR
16751: GO 16664
16753: POP
16754: POP
// result := list ;
16755: LD_ADDR_VAR 0 2
16759: PUSH
16760: LD_VAR 0 5
16764: ST_TO_ADDR
// end ;
16765: LD_VAR 0 2
16769: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16770: LD_INT 0
16772: PPUSH
16773: PPUSH
16774: PPUSH
16775: PPUSH
16776: PPUSH
16777: PPUSH
16778: PPUSH
// if not factory then
16779: LD_VAR 0 1
16783: NOT
16784: IFFALSE 16788
// exit ;
16786: GO 17381
// if control = control_apeman then
16788: LD_VAR 0 4
16792: PUSH
16793: LD_INT 5
16795: EQUAL
16796: IFFALSE 16905
// begin tmp := UnitsInside ( factory ) ;
16798: LD_ADDR_VAR 0 8
16802: PUSH
16803: LD_VAR 0 1
16807: PPUSH
16808: CALL_OW 313
16812: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16813: LD_VAR 0 8
16817: PPUSH
16818: LD_INT 25
16820: PUSH
16821: LD_INT 12
16823: PUSH
16824: EMPTY
16825: LIST
16826: LIST
16827: PPUSH
16828: CALL_OW 72
16832: NOT
16833: IFFALSE 16843
// control := control_manual ;
16835: LD_ADDR_VAR 0 4
16839: PUSH
16840: LD_INT 1
16842: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16843: LD_ADDR_VAR 0 8
16847: PUSH
16848: LD_VAR 0 1
16852: PPUSH
16853: CALL 16540 0 1
16857: ST_TO_ADDR
// if tmp then
16858: LD_VAR 0 8
16862: IFFALSE 16905
// begin for i in tmp do
16864: LD_ADDR_VAR 0 7
16868: PUSH
16869: LD_VAR 0 8
16873: PUSH
16874: FOR_IN
16875: IFFALSE 16903
// if i [ 1 ] = b_ext_radio then
16877: LD_VAR 0 7
16881: PUSH
16882: LD_INT 1
16884: ARRAY
16885: PUSH
16886: LD_INT 22
16888: EQUAL
16889: IFFALSE 16901
// begin control := control_remote ;
16891: LD_ADDR_VAR 0 4
16895: PUSH
16896: LD_INT 2
16898: ST_TO_ADDR
// break ;
16899: GO 16903
// end ;
16901: GO 16874
16903: POP
16904: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16905: LD_VAR 0 1
16909: PPUSH
16910: LD_VAR 0 2
16914: PPUSH
16915: LD_VAR 0 3
16919: PPUSH
16920: LD_VAR 0 4
16924: PPUSH
16925: LD_VAR 0 5
16929: PPUSH
16930: CALL_OW 448
16934: IFFALSE 16969
// begin result := [ chassis , engine , control , weapon ] ;
16936: LD_ADDR_VAR 0 6
16940: PUSH
16941: LD_VAR 0 2
16945: PUSH
16946: LD_VAR 0 3
16950: PUSH
16951: LD_VAR 0 4
16955: PUSH
16956: LD_VAR 0 5
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: LIST
16965: LIST
16966: ST_TO_ADDR
// exit ;
16967: GO 17381
// end ; _chassis := AvailableChassisList ( factory ) ;
16969: LD_ADDR_VAR 0 9
16973: PUSH
16974: LD_VAR 0 1
16978: PPUSH
16979: CALL_OW 475
16983: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16984: LD_ADDR_VAR 0 11
16988: PUSH
16989: LD_VAR 0 1
16993: PPUSH
16994: CALL_OW 476
16998: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16999: LD_ADDR_VAR 0 12
17003: PUSH
17004: LD_VAR 0 1
17008: PPUSH
17009: CALL_OW 477
17013: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17014: LD_ADDR_VAR 0 10
17018: PUSH
17019: LD_VAR 0 1
17023: PPUSH
17024: CALL_OW 478
17028: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17029: LD_VAR 0 9
17033: NOT
17034: PUSH
17035: LD_VAR 0 11
17039: NOT
17040: OR
17041: PUSH
17042: LD_VAR 0 12
17046: NOT
17047: OR
17048: PUSH
17049: LD_VAR 0 10
17053: NOT
17054: OR
17055: IFFALSE 17090
// begin result := [ chassis , engine , control , weapon ] ;
17057: LD_ADDR_VAR 0 6
17061: PUSH
17062: LD_VAR 0 2
17066: PUSH
17067: LD_VAR 0 3
17071: PUSH
17072: LD_VAR 0 4
17076: PUSH
17077: LD_VAR 0 5
17081: PUSH
17082: EMPTY
17083: LIST
17084: LIST
17085: LIST
17086: LIST
17087: ST_TO_ADDR
// exit ;
17088: GO 17381
// end ; if not chassis in _chassis then
17090: LD_VAR 0 2
17094: PUSH
17095: LD_VAR 0 9
17099: IN
17100: NOT
17101: IFFALSE 17127
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17103: LD_ADDR_VAR 0 2
17107: PUSH
17108: LD_VAR 0 9
17112: PUSH
17113: LD_INT 1
17115: PPUSH
17116: LD_VAR 0 9
17120: PPUSH
17121: CALL_OW 12
17125: ARRAY
17126: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17127: LD_VAR 0 2
17131: PPUSH
17132: LD_VAR 0 3
17136: PPUSH
17137: CALL 17386 0 2
17141: NOT
17142: IFFALSE 17201
// repeat engine := _engine [ 1 ] ;
17144: LD_ADDR_VAR 0 3
17148: PUSH
17149: LD_VAR 0 11
17153: PUSH
17154: LD_INT 1
17156: ARRAY
17157: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17158: LD_ADDR_VAR 0 11
17162: PUSH
17163: LD_VAR 0 11
17167: PPUSH
17168: LD_INT 1
17170: PPUSH
17171: CALL_OW 3
17175: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17176: LD_VAR 0 2
17180: PPUSH
17181: LD_VAR 0 3
17185: PPUSH
17186: CALL 17386 0 2
17190: PUSH
17191: LD_VAR 0 11
17195: PUSH
17196: EMPTY
17197: EQUAL
17198: OR
17199: IFFALSE 17144
// if not control in _control then
17201: LD_VAR 0 4
17205: PUSH
17206: LD_VAR 0 12
17210: IN
17211: NOT
17212: IFFALSE 17238
// control := _control [ rand ( 1 , _control ) ] ;
17214: LD_ADDR_VAR 0 4
17218: PUSH
17219: LD_VAR 0 12
17223: PUSH
17224: LD_INT 1
17226: PPUSH
17227: LD_VAR 0 12
17231: PPUSH
17232: CALL_OW 12
17236: ARRAY
17237: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17238: LD_VAR 0 2
17242: PPUSH
17243: LD_VAR 0 5
17247: PPUSH
17248: CALL 17606 0 2
17252: NOT
17253: IFFALSE 17312
// repeat weapon := _weapon [ 1 ] ;
17255: LD_ADDR_VAR 0 5
17259: PUSH
17260: LD_VAR 0 10
17264: PUSH
17265: LD_INT 1
17267: ARRAY
17268: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17269: LD_ADDR_VAR 0 10
17273: PUSH
17274: LD_VAR 0 10
17278: PPUSH
17279: LD_INT 1
17281: PPUSH
17282: CALL_OW 3
17286: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17287: LD_VAR 0 2
17291: PPUSH
17292: LD_VAR 0 5
17296: PPUSH
17297: CALL 17606 0 2
17301: PUSH
17302: LD_VAR 0 10
17306: PUSH
17307: EMPTY
17308: EQUAL
17309: OR
17310: IFFALSE 17255
// result := [ ] ;
17312: LD_ADDR_VAR 0 6
17316: PUSH
17317: EMPTY
17318: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17319: LD_VAR 0 1
17323: PPUSH
17324: LD_VAR 0 2
17328: PPUSH
17329: LD_VAR 0 3
17333: PPUSH
17334: LD_VAR 0 4
17338: PPUSH
17339: LD_VAR 0 5
17343: PPUSH
17344: CALL_OW 448
17348: IFFALSE 17381
// result := [ chassis , engine , control , weapon ] ;
17350: LD_ADDR_VAR 0 6
17354: PUSH
17355: LD_VAR 0 2
17359: PUSH
17360: LD_VAR 0 3
17364: PUSH
17365: LD_VAR 0 4
17369: PUSH
17370: LD_VAR 0 5
17374: PUSH
17375: EMPTY
17376: LIST
17377: LIST
17378: LIST
17379: LIST
17380: ST_TO_ADDR
// end ;
17381: LD_VAR 0 6
17385: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
17386: LD_INT 0
17388: PPUSH
// if not chassis or not engine then
17389: LD_VAR 0 1
17393: NOT
17394: PUSH
17395: LD_VAR 0 2
17399: NOT
17400: OR
17401: IFFALSE 17405
// exit ;
17403: GO 17601
// case engine of engine_solar :
17405: LD_VAR 0 2
17409: PUSH
17410: LD_INT 2
17412: DOUBLE
17413: EQUAL
17414: IFTRUE 17418
17416: GO 17456
17418: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
17419: LD_ADDR_VAR 0 3
17423: PUSH
17424: LD_INT 11
17426: PUSH
17427: LD_INT 12
17429: PUSH
17430: LD_INT 13
17432: PUSH
17433: LD_INT 14
17435: PUSH
17436: LD_INT 1
17438: PUSH
17439: LD_INT 2
17441: PUSH
17442: LD_INT 3
17444: PUSH
17445: EMPTY
17446: LIST
17447: LIST
17448: LIST
17449: LIST
17450: LIST
17451: LIST
17452: LIST
17453: ST_TO_ADDR
17454: GO 17585
17456: LD_INT 1
17458: DOUBLE
17459: EQUAL
17460: IFTRUE 17464
17462: GO 17526
17464: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
17465: LD_ADDR_VAR 0 3
17469: PUSH
17470: LD_INT 11
17472: PUSH
17473: LD_INT 12
17475: PUSH
17476: LD_INT 13
17478: PUSH
17479: LD_INT 14
17481: PUSH
17482: LD_INT 1
17484: PUSH
17485: LD_INT 2
17487: PUSH
17488: LD_INT 3
17490: PUSH
17491: LD_INT 4
17493: PUSH
17494: LD_INT 5
17496: PUSH
17497: LD_INT 21
17499: PUSH
17500: LD_INT 23
17502: PUSH
17503: LD_INT 22
17505: PUSH
17506: LD_INT 24
17508: PUSH
17509: EMPTY
17510: LIST
17511: LIST
17512: LIST
17513: LIST
17514: LIST
17515: LIST
17516: LIST
17517: LIST
17518: LIST
17519: LIST
17520: LIST
17521: LIST
17522: LIST
17523: ST_TO_ADDR
17524: GO 17585
17526: LD_INT 3
17528: DOUBLE
17529: EQUAL
17530: IFTRUE 17534
17532: GO 17584
17534: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17535: LD_ADDR_VAR 0 3
17539: PUSH
17540: LD_INT 13
17542: PUSH
17543: LD_INT 14
17545: PUSH
17546: LD_INT 2
17548: PUSH
17549: LD_INT 3
17551: PUSH
17552: LD_INT 4
17554: PUSH
17555: LD_INT 5
17557: PUSH
17558: LD_INT 21
17560: PUSH
17561: LD_INT 22
17563: PUSH
17564: LD_INT 23
17566: PUSH
17567: LD_INT 24
17569: PUSH
17570: EMPTY
17571: LIST
17572: LIST
17573: LIST
17574: LIST
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: ST_TO_ADDR
17582: GO 17585
17584: POP
// result := ( chassis in result ) ;
17585: LD_ADDR_VAR 0 3
17589: PUSH
17590: LD_VAR 0 1
17594: PUSH
17595: LD_VAR 0 3
17599: IN
17600: ST_TO_ADDR
// end ;
17601: LD_VAR 0 3
17605: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
17606: LD_INT 0
17608: PPUSH
// if not chassis or not weapon then
17609: LD_VAR 0 1
17613: NOT
17614: PUSH
17615: LD_VAR 0 2
17619: NOT
17620: OR
17621: IFFALSE 17625
// exit ;
17623: GO 18651
// case weapon of us_machine_gun :
17625: LD_VAR 0 2
17629: PUSH
17630: LD_INT 2
17632: DOUBLE
17633: EQUAL
17634: IFTRUE 17638
17636: GO 17668
17638: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
17639: LD_ADDR_VAR 0 3
17643: PUSH
17644: LD_INT 1
17646: PUSH
17647: LD_INT 2
17649: PUSH
17650: LD_INT 3
17652: PUSH
17653: LD_INT 4
17655: PUSH
17656: LD_INT 5
17658: PUSH
17659: EMPTY
17660: LIST
17661: LIST
17662: LIST
17663: LIST
17664: LIST
17665: ST_TO_ADDR
17666: GO 18635
17668: LD_INT 3
17670: DOUBLE
17671: EQUAL
17672: IFTRUE 17676
17674: GO 17706
17676: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
17677: LD_ADDR_VAR 0 3
17681: PUSH
17682: LD_INT 1
17684: PUSH
17685: LD_INT 2
17687: PUSH
17688: LD_INT 3
17690: PUSH
17691: LD_INT 4
17693: PUSH
17694: LD_INT 5
17696: PUSH
17697: EMPTY
17698: LIST
17699: LIST
17700: LIST
17701: LIST
17702: LIST
17703: ST_TO_ADDR
17704: GO 18635
17706: LD_INT 11
17708: DOUBLE
17709: EQUAL
17710: IFTRUE 17714
17712: GO 17744
17714: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17715: LD_ADDR_VAR 0 3
17719: PUSH
17720: LD_INT 1
17722: PUSH
17723: LD_INT 2
17725: PUSH
17726: LD_INT 3
17728: PUSH
17729: LD_INT 4
17731: PUSH
17732: LD_INT 5
17734: PUSH
17735: EMPTY
17736: LIST
17737: LIST
17738: LIST
17739: LIST
17740: LIST
17741: ST_TO_ADDR
17742: GO 18635
17744: LD_INT 4
17746: DOUBLE
17747: EQUAL
17748: IFTRUE 17752
17750: GO 17778
17752: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17753: LD_ADDR_VAR 0 3
17757: PUSH
17758: LD_INT 2
17760: PUSH
17761: LD_INT 3
17763: PUSH
17764: LD_INT 4
17766: PUSH
17767: LD_INT 5
17769: PUSH
17770: EMPTY
17771: LIST
17772: LIST
17773: LIST
17774: LIST
17775: ST_TO_ADDR
17776: GO 18635
17778: LD_INT 5
17780: DOUBLE
17781: EQUAL
17782: IFTRUE 17786
17784: GO 17812
17786: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17787: LD_ADDR_VAR 0 3
17791: PUSH
17792: LD_INT 2
17794: PUSH
17795: LD_INT 3
17797: PUSH
17798: LD_INT 4
17800: PUSH
17801: LD_INT 5
17803: PUSH
17804: EMPTY
17805: LIST
17806: LIST
17807: LIST
17808: LIST
17809: ST_TO_ADDR
17810: GO 18635
17812: LD_INT 9
17814: DOUBLE
17815: EQUAL
17816: IFTRUE 17820
17818: GO 17846
17820: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17821: LD_ADDR_VAR 0 3
17825: PUSH
17826: LD_INT 2
17828: PUSH
17829: LD_INT 3
17831: PUSH
17832: LD_INT 4
17834: PUSH
17835: LD_INT 5
17837: PUSH
17838: EMPTY
17839: LIST
17840: LIST
17841: LIST
17842: LIST
17843: ST_TO_ADDR
17844: GO 18635
17846: LD_INT 7
17848: DOUBLE
17849: EQUAL
17850: IFTRUE 17854
17852: GO 17880
17854: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17855: LD_ADDR_VAR 0 3
17859: PUSH
17860: LD_INT 2
17862: PUSH
17863: LD_INT 3
17865: PUSH
17866: LD_INT 4
17868: PUSH
17869: LD_INT 5
17871: PUSH
17872: EMPTY
17873: LIST
17874: LIST
17875: LIST
17876: LIST
17877: ST_TO_ADDR
17878: GO 18635
17880: LD_INT 12
17882: DOUBLE
17883: EQUAL
17884: IFTRUE 17888
17886: GO 17914
17888: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17889: LD_ADDR_VAR 0 3
17893: PUSH
17894: LD_INT 2
17896: PUSH
17897: LD_INT 3
17899: PUSH
17900: LD_INT 4
17902: PUSH
17903: LD_INT 5
17905: PUSH
17906: EMPTY
17907: LIST
17908: LIST
17909: LIST
17910: LIST
17911: ST_TO_ADDR
17912: GO 18635
17914: LD_INT 13
17916: DOUBLE
17917: EQUAL
17918: IFTRUE 17922
17920: GO 17948
17922: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17923: LD_ADDR_VAR 0 3
17927: PUSH
17928: LD_INT 2
17930: PUSH
17931: LD_INT 3
17933: PUSH
17934: LD_INT 4
17936: PUSH
17937: LD_INT 5
17939: PUSH
17940: EMPTY
17941: LIST
17942: LIST
17943: LIST
17944: LIST
17945: ST_TO_ADDR
17946: GO 18635
17948: LD_INT 14
17950: DOUBLE
17951: EQUAL
17952: IFTRUE 17956
17954: GO 17974
17956: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17957: LD_ADDR_VAR 0 3
17961: PUSH
17962: LD_INT 4
17964: PUSH
17965: LD_INT 5
17967: PUSH
17968: EMPTY
17969: LIST
17970: LIST
17971: ST_TO_ADDR
17972: GO 18635
17974: LD_INT 6
17976: DOUBLE
17977: EQUAL
17978: IFTRUE 17982
17980: GO 18000
17982: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17983: LD_ADDR_VAR 0 3
17987: PUSH
17988: LD_INT 4
17990: PUSH
17991: LD_INT 5
17993: PUSH
17994: EMPTY
17995: LIST
17996: LIST
17997: ST_TO_ADDR
17998: GO 18635
18000: LD_INT 10
18002: DOUBLE
18003: EQUAL
18004: IFTRUE 18008
18006: GO 18026
18008: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18009: LD_ADDR_VAR 0 3
18013: PUSH
18014: LD_INT 4
18016: PUSH
18017: LD_INT 5
18019: PUSH
18020: EMPTY
18021: LIST
18022: LIST
18023: ST_TO_ADDR
18024: GO 18635
18026: LD_INT 22
18028: DOUBLE
18029: EQUAL
18030: IFTRUE 18034
18032: GO 18060
18034: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18035: LD_ADDR_VAR 0 3
18039: PUSH
18040: LD_INT 11
18042: PUSH
18043: LD_INT 12
18045: PUSH
18046: LD_INT 13
18048: PUSH
18049: LD_INT 14
18051: PUSH
18052: EMPTY
18053: LIST
18054: LIST
18055: LIST
18056: LIST
18057: ST_TO_ADDR
18058: GO 18635
18060: LD_INT 23
18062: DOUBLE
18063: EQUAL
18064: IFTRUE 18068
18066: GO 18094
18068: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18069: LD_ADDR_VAR 0 3
18073: PUSH
18074: LD_INT 11
18076: PUSH
18077: LD_INT 12
18079: PUSH
18080: LD_INT 13
18082: PUSH
18083: LD_INT 14
18085: PUSH
18086: EMPTY
18087: LIST
18088: LIST
18089: LIST
18090: LIST
18091: ST_TO_ADDR
18092: GO 18635
18094: LD_INT 24
18096: DOUBLE
18097: EQUAL
18098: IFTRUE 18102
18100: GO 18128
18102: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18103: LD_ADDR_VAR 0 3
18107: PUSH
18108: LD_INT 11
18110: PUSH
18111: LD_INT 12
18113: PUSH
18114: LD_INT 13
18116: PUSH
18117: LD_INT 14
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: LIST
18125: ST_TO_ADDR
18126: GO 18635
18128: LD_INT 30
18130: DOUBLE
18131: EQUAL
18132: IFTRUE 18136
18134: GO 18162
18136: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18137: LD_ADDR_VAR 0 3
18141: PUSH
18142: LD_INT 11
18144: PUSH
18145: LD_INT 12
18147: PUSH
18148: LD_INT 13
18150: PUSH
18151: LD_INT 14
18153: PUSH
18154: EMPTY
18155: LIST
18156: LIST
18157: LIST
18158: LIST
18159: ST_TO_ADDR
18160: GO 18635
18162: LD_INT 25
18164: DOUBLE
18165: EQUAL
18166: IFTRUE 18170
18168: GO 18188
18170: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18171: LD_ADDR_VAR 0 3
18175: PUSH
18176: LD_INT 13
18178: PUSH
18179: LD_INT 14
18181: PUSH
18182: EMPTY
18183: LIST
18184: LIST
18185: ST_TO_ADDR
18186: GO 18635
18188: LD_INT 27
18190: DOUBLE
18191: EQUAL
18192: IFTRUE 18196
18194: GO 18214
18196: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18197: LD_ADDR_VAR 0 3
18201: PUSH
18202: LD_INT 13
18204: PUSH
18205: LD_INT 14
18207: PUSH
18208: EMPTY
18209: LIST
18210: LIST
18211: ST_TO_ADDR
18212: GO 18635
18214: LD_INT 28
18216: DOUBLE
18217: EQUAL
18218: IFTRUE 18222
18220: GO 18240
18222: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18223: LD_ADDR_VAR 0 3
18227: PUSH
18228: LD_INT 13
18230: PUSH
18231: LD_INT 14
18233: PUSH
18234: EMPTY
18235: LIST
18236: LIST
18237: ST_TO_ADDR
18238: GO 18635
18240: LD_INT 29
18242: DOUBLE
18243: EQUAL
18244: IFTRUE 18248
18246: GO 18266
18248: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18249: LD_ADDR_VAR 0 3
18253: PUSH
18254: LD_INT 13
18256: PUSH
18257: LD_INT 14
18259: PUSH
18260: EMPTY
18261: LIST
18262: LIST
18263: ST_TO_ADDR
18264: GO 18635
18266: LD_INT 31
18268: DOUBLE
18269: EQUAL
18270: IFTRUE 18274
18272: GO 18292
18274: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18275: LD_ADDR_VAR 0 3
18279: PUSH
18280: LD_INT 13
18282: PUSH
18283: LD_INT 14
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: ST_TO_ADDR
18290: GO 18635
18292: LD_INT 26
18294: DOUBLE
18295: EQUAL
18296: IFTRUE 18300
18298: GO 18318
18300: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18301: LD_ADDR_VAR 0 3
18305: PUSH
18306: LD_INT 13
18308: PUSH
18309: LD_INT 14
18311: PUSH
18312: EMPTY
18313: LIST
18314: LIST
18315: ST_TO_ADDR
18316: GO 18635
18318: LD_INT 42
18320: DOUBLE
18321: EQUAL
18322: IFTRUE 18326
18324: GO 18352
18326: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
18327: LD_ADDR_VAR 0 3
18331: PUSH
18332: LD_INT 21
18334: PUSH
18335: LD_INT 22
18337: PUSH
18338: LD_INT 23
18340: PUSH
18341: LD_INT 24
18343: PUSH
18344: EMPTY
18345: LIST
18346: LIST
18347: LIST
18348: LIST
18349: ST_TO_ADDR
18350: GO 18635
18352: LD_INT 43
18354: DOUBLE
18355: EQUAL
18356: IFTRUE 18360
18358: GO 18386
18360: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
18361: LD_ADDR_VAR 0 3
18365: PUSH
18366: LD_INT 21
18368: PUSH
18369: LD_INT 22
18371: PUSH
18372: LD_INT 23
18374: PUSH
18375: LD_INT 24
18377: PUSH
18378: EMPTY
18379: LIST
18380: LIST
18381: LIST
18382: LIST
18383: ST_TO_ADDR
18384: GO 18635
18386: LD_INT 44
18388: DOUBLE
18389: EQUAL
18390: IFTRUE 18394
18392: GO 18420
18394: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
18395: LD_ADDR_VAR 0 3
18399: PUSH
18400: LD_INT 21
18402: PUSH
18403: LD_INT 22
18405: PUSH
18406: LD_INT 23
18408: PUSH
18409: LD_INT 24
18411: PUSH
18412: EMPTY
18413: LIST
18414: LIST
18415: LIST
18416: LIST
18417: ST_TO_ADDR
18418: GO 18635
18420: LD_INT 45
18422: DOUBLE
18423: EQUAL
18424: IFTRUE 18428
18426: GO 18454
18428: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
18429: LD_ADDR_VAR 0 3
18433: PUSH
18434: LD_INT 21
18436: PUSH
18437: LD_INT 22
18439: PUSH
18440: LD_INT 23
18442: PUSH
18443: LD_INT 24
18445: PUSH
18446: EMPTY
18447: LIST
18448: LIST
18449: LIST
18450: LIST
18451: ST_TO_ADDR
18452: GO 18635
18454: LD_INT 49
18456: DOUBLE
18457: EQUAL
18458: IFTRUE 18462
18460: GO 18488
18462: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
18463: LD_ADDR_VAR 0 3
18467: PUSH
18468: LD_INT 21
18470: PUSH
18471: LD_INT 22
18473: PUSH
18474: LD_INT 23
18476: PUSH
18477: LD_INT 24
18479: PUSH
18480: EMPTY
18481: LIST
18482: LIST
18483: LIST
18484: LIST
18485: ST_TO_ADDR
18486: GO 18635
18488: LD_INT 51
18490: DOUBLE
18491: EQUAL
18492: IFTRUE 18496
18494: GO 18522
18496: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
18497: LD_ADDR_VAR 0 3
18501: PUSH
18502: LD_INT 21
18504: PUSH
18505: LD_INT 22
18507: PUSH
18508: LD_INT 23
18510: PUSH
18511: LD_INT 24
18513: PUSH
18514: EMPTY
18515: LIST
18516: LIST
18517: LIST
18518: LIST
18519: ST_TO_ADDR
18520: GO 18635
18522: LD_INT 52
18524: DOUBLE
18525: EQUAL
18526: IFTRUE 18530
18528: GO 18556
18530: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
18531: LD_ADDR_VAR 0 3
18535: PUSH
18536: LD_INT 21
18538: PUSH
18539: LD_INT 22
18541: PUSH
18542: LD_INT 23
18544: PUSH
18545: LD_INT 24
18547: PUSH
18548: EMPTY
18549: LIST
18550: LIST
18551: LIST
18552: LIST
18553: ST_TO_ADDR
18554: GO 18635
18556: LD_INT 53
18558: DOUBLE
18559: EQUAL
18560: IFTRUE 18564
18562: GO 18582
18564: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
18565: LD_ADDR_VAR 0 3
18569: PUSH
18570: LD_INT 23
18572: PUSH
18573: LD_INT 24
18575: PUSH
18576: EMPTY
18577: LIST
18578: LIST
18579: ST_TO_ADDR
18580: GO 18635
18582: LD_INT 46
18584: DOUBLE
18585: EQUAL
18586: IFTRUE 18590
18588: GO 18608
18590: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
18591: LD_ADDR_VAR 0 3
18595: PUSH
18596: LD_INT 23
18598: PUSH
18599: LD_INT 24
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: ST_TO_ADDR
18606: GO 18635
18608: LD_INT 47
18610: DOUBLE
18611: EQUAL
18612: IFTRUE 18616
18614: GO 18634
18616: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18617: LD_ADDR_VAR 0 3
18621: PUSH
18622: LD_INT 23
18624: PUSH
18625: LD_INT 24
18627: PUSH
18628: EMPTY
18629: LIST
18630: LIST
18631: ST_TO_ADDR
18632: GO 18635
18634: POP
// result := ( chassis in result ) ;
18635: LD_ADDR_VAR 0 3
18639: PUSH
18640: LD_VAR 0 1
18644: PUSH
18645: LD_VAR 0 3
18649: IN
18650: ST_TO_ADDR
// end ;
18651: LD_VAR 0 3
18655: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
18656: LD_INT 0
18658: PPUSH
18659: PPUSH
18660: PPUSH
18661: PPUSH
18662: PPUSH
18663: PPUSH
18664: PPUSH
// result := array ;
18665: LD_ADDR_VAR 0 5
18669: PUSH
18670: LD_VAR 0 1
18674: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18675: LD_VAR 0 1
18679: NOT
18680: PUSH
18681: LD_VAR 0 2
18685: NOT
18686: OR
18687: PUSH
18688: LD_VAR 0 3
18692: NOT
18693: OR
18694: PUSH
18695: LD_VAR 0 2
18699: PUSH
18700: LD_VAR 0 1
18704: GREATER
18705: OR
18706: PUSH
18707: LD_VAR 0 3
18711: PUSH
18712: LD_VAR 0 1
18716: GREATER
18717: OR
18718: IFFALSE 18722
// exit ;
18720: GO 19018
// if direction then
18722: LD_VAR 0 4
18726: IFFALSE 18790
// begin d := 1 ;
18728: LD_ADDR_VAR 0 9
18732: PUSH
18733: LD_INT 1
18735: ST_TO_ADDR
// if i_from > i_to then
18736: LD_VAR 0 2
18740: PUSH
18741: LD_VAR 0 3
18745: GREATER
18746: IFFALSE 18772
// length := ( array - i_from ) + i_to else
18748: LD_ADDR_VAR 0 11
18752: PUSH
18753: LD_VAR 0 1
18757: PUSH
18758: LD_VAR 0 2
18762: MINUS
18763: PUSH
18764: LD_VAR 0 3
18768: PLUS
18769: ST_TO_ADDR
18770: GO 18788
// length := i_to - i_from ;
18772: LD_ADDR_VAR 0 11
18776: PUSH
18777: LD_VAR 0 3
18781: PUSH
18782: LD_VAR 0 2
18786: MINUS
18787: ST_TO_ADDR
// end else
18788: GO 18851
// begin d := - 1 ;
18790: LD_ADDR_VAR 0 9
18794: PUSH
18795: LD_INT 1
18797: NEG
18798: ST_TO_ADDR
// if i_from > i_to then
18799: LD_VAR 0 2
18803: PUSH
18804: LD_VAR 0 3
18808: GREATER
18809: IFFALSE 18829
// length := i_from - i_to else
18811: LD_ADDR_VAR 0 11
18815: PUSH
18816: LD_VAR 0 2
18820: PUSH
18821: LD_VAR 0 3
18825: MINUS
18826: ST_TO_ADDR
18827: GO 18851
// length := ( array - i_to ) + i_from ;
18829: LD_ADDR_VAR 0 11
18833: PUSH
18834: LD_VAR 0 1
18838: PUSH
18839: LD_VAR 0 3
18843: MINUS
18844: PUSH
18845: LD_VAR 0 2
18849: PLUS
18850: ST_TO_ADDR
// end ; if not length then
18851: LD_VAR 0 11
18855: NOT
18856: IFFALSE 18860
// exit ;
18858: GO 19018
// tmp := array ;
18860: LD_ADDR_VAR 0 10
18864: PUSH
18865: LD_VAR 0 1
18869: ST_TO_ADDR
// for i = 1 to length do
18870: LD_ADDR_VAR 0 6
18874: PUSH
18875: DOUBLE
18876: LD_INT 1
18878: DEC
18879: ST_TO_ADDR
18880: LD_VAR 0 11
18884: PUSH
18885: FOR_TO
18886: IFFALSE 19006
// begin for j = 1 to array do
18888: LD_ADDR_VAR 0 7
18892: PUSH
18893: DOUBLE
18894: LD_INT 1
18896: DEC
18897: ST_TO_ADDR
18898: LD_VAR 0 1
18902: PUSH
18903: FOR_TO
18904: IFFALSE 18992
// begin k := j + d ;
18906: LD_ADDR_VAR 0 8
18910: PUSH
18911: LD_VAR 0 7
18915: PUSH
18916: LD_VAR 0 9
18920: PLUS
18921: ST_TO_ADDR
// if k > array then
18922: LD_VAR 0 8
18926: PUSH
18927: LD_VAR 0 1
18931: GREATER
18932: IFFALSE 18942
// k := 1 ;
18934: LD_ADDR_VAR 0 8
18938: PUSH
18939: LD_INT 1
18941: ST_TO_ADDR
// if not k then
18942: LD_VAR 0 8
18946: NOT
18947: IFFALSE 18959
// k := array ;
18949: LD_ADDR_VAR 0 8
18953: PUSH
18954: LD_VAR 0 1
18958: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18959: LD_ADDR_VAR 0 10
18963: PUSH
18964: LD_VAR 0 10
18968: PPUSH
18969: LD_VAR 0 8
18973: PPUSH
18974: LD_VAR 0 1
18978: PUSH
18979: LD_VAR 0 7
18983: ARRAY
18984: PPUSH
18985: CALL_OW 1
18989: ST_TO_ADDR
// end ;
18990: GO 18903
18992: POP
18993: POP
// array := tmp ;
18994: LD_ADDR_VAR 0 1
18998: PUSH
18999: LD_VAR 0 10
19003: ST_TO_ADDR
// end ;
19004: GO 18885
19006: POP
19007: POP
// result := array ;
19008: LD_ADDR_VAR 0 5
19012: PUSH
19013: LD_VAR 0 1
19017: ST_TO_ADDR
// end ;
19018: LD_VAR 0 5
19022: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19023: LD_INT 0
19025: PPUSH
19026: PPUSH
// result := 0 ;
19027: LD_ADDR_VAR 0 3
19031: PUSH
19032: LD_INT 0
19034: ST_TO_ADDR
// if not array or not value in array then
19035: LD_VAR 0 1
19039: NOT
19040: PUSH
19041: LD_VAR 0 2
19045: PUSH
19046: LD_VAR 0 1
19050: IN
19051: NOT
19052: OR
19053: IFFALSE 19057
// exit ;
19055: GO 19111
// for i = 1 to array do
19057: LD_ADDR_VAR 0 4
19061: PUSH
19062: DOUBLE
19063: LD_INT 1
19065: DEC
19066: ST_TO_ADDR
19067: LD_VAR 0 1
19071: PUSH
19072: FOR_TO
19073: IFFALSE 19109
// if value = array [ i ] then
19075: LD_VAR 0 2
19079: PUSH
19080: LD_VAR 0 1
19084: PUSH
19085: LD_VAR 0 4
19089: ARRAY
19090: EQUAL
19091: IFFALSE 19107
// begin result := i ;
19093: LD_ADDR_VAR 0 3
19097: PUSH
19098: LD_VAR 0 4
19102: ST_TO_ADDR
// exit ;
19103: POP
19104: POP
19105: GO 19111
// end ;
19107: GO 19072
19109: POP
19110: POP
// end ;
19111: LD_VAR 0 3
19115: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19116: LD_INT 0
19118: PPUSH
// vc_chassis := chassis ;
19119: LD_ADDR_OWVAR 37
19123: PUSH
19124: LD_VAR 0 1
19128: ST_TO_ADDR
// vc_engine := engine ;
19129: LD_ADDR_OWVAR 39
19133: PUSH
19134: LD_VAR 0 2
19138: ST_TO_ADDR
// vc_control := control ;
19139: LD_ADDR_OWVAR 38
19143: PUSH
19144: LD_VAR 0 3
19148: ST_TO_ADDR
// vc_weapon := weapon ;
19149: LD_ADDR_OWVAR 40
19153: PUSH
19154: LD_VAR 0 4
19158: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19159: LD_ADDR_OWVAR 41
19163: PUSH
19164: LD_VAR 0 5
19168: ST_TO_ADDR
// end ;
19169: LD_VAR 0 6
19173: RET
// export function WantPlant ( unit ) ; var task ; begin
19174: LD_INT 0
19176: PPUSH
19177: PPUSH
// result := false ;
19178: LD_ADDR_VAR 0 2
19182: PUSH
19183: LD_INT 0
19185: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19186: LD_ADDR_VAR 0 3
19190: PUSH
19191: LD_VAR 0 1
19195: PPUSH
19196: CALL_OW 437
19200: ST_TO_ADDR
// if task then
19201: LD_VAR 0 3
19205: IFFALSE 19233
// if task [ 1 ] [ 1 ] = p then
19207: LD_VAR 0 3
19211: PUSH
19212: LD_INT 1
19214: ARRAY
19215: PUSH
19216: LD_INT 1
19218: ARRAY
19219: PUSH
19220: LD_STRING p
19222: EQUAL
19223: IFFALSE 19233
// result := true ;
19225: LD_ADDR_VAR 0 2
19229: PUSH
19230: LD_INT 1
19232: ST_TO_ADDR
// end ;
19233: LD_VAR 0 2
19237: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19238: LD_INT 0
19240: PPUSH
19241: PPUSH
19242: PPUSH
19243: PPUSH
// if pos < 1 then
19244: LD_VAR 0 2
19248: PUSH
19249: LD_INT 1
19251: LESS
19252: IFFALSE 19256
// exit ;
19254: GO 19559
// if pos = 1 then
19256: LD_VAR 0 2
19260: PUSH
19261: LD_INT 1
19263: EQUAL
19264: IFFALSE 19297
// result := Replace ( arr , pos [ 1 ] , value ) else
19266: LD_ADDR_VAR 0 4
19270: PUSH
19271: LD_VAR 0 1
19275: PPUSH
19276: LD_VAR 0 2
19280: PUSH
19281: LD_INT 1
19283: ARRAY
19284: PPUSH
19285: LD_VAR 0 3
19289: PPUSH
19290: CALL_OW 1
19294: ST_TO_ADDR
19295: GO 19559
// begin tmp := arr ;
19297: LD_ADDR_VAR 0 6
19301: PUSH
19302: LD_VAR 0 1
19306: ST_TO_ADDR
// s_arr := [ tmp ] ;
19307: LD_ADDR_VAR 0 7
19311: PUSH
19312: LD_VAR 0 6
19316: PUSH
19317: EMPTY
19318: LIST
19319: ST_TO_ADDR
// for i = 1 to pos - 1 do
19320: LD_ADDR_VAR 0 5
19324: PUSH
19325: DOUBLE
19326: LD_INT 1
19328: DEC
19329: ST_TO_ADDR
19330: LD_VAR 0 2
19334: PUSH
19335: LD_INT 1
19337: MINUS
19338: PUSH
19339: FOR_TO
19340: IFFALSE 19385
// begin tmp := tmp [ pos [ i ] ] ;
19342: LD_ADDR_VAR 0 6
19346: PUSH
19347: LD_VAR 0 6
19351: PUSH
19352: LD_VAR 0 2
19356: PUSH
19357: LD_VAR 0 5
19361: ARRAY
19362: ARRAY
19363: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
19364: LD_ADDR_VAR 0 7
19368: PUSH
19369: LD_VAR 0 7
19373: PUSH
19374: LD_VAR 0 6
19378: PUSH
19379: EMPTY
19380: LIST
19381: ADD
19382: ST_TO_ADDR
// end ;
19383: GO 19339
19385: POP
19386: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
19387: LD_ADDR_VAR 0 6
19391: PUSH
19392: LD_VAR 0 6
19396: PPUSH
19397: LD_VAR 0 2
19401: PUSH
19402: LD_VAR 0 2
19406: ARRAY
19407: PPUSH
19408: LD_VAR 0 3
19412: PPUSH
19413: CALL_OW 1
19417: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
19418: LD_ADDR_VAR 0 7
19422: PUSH
19423: LD_VAR 0 7
19427: PPUSH
19428: LD_VAR 0 7
19432: PPUSH
19433: LD_VAR 0 6
19437: PPUSH
19438: CALL_OW 1
19442: ST_TO_ADDR
// for i = s_arr downto 2 do
19443: LD_ADDR_VAR 0 5
19447: PUSH
19448: DOUBLE
19449: LD_VAR 0 7
19453: INC
19454: ST_TO_ADDR
19455: LD_INT 2
19457: PUSH
19458: FOR_DOWNTO
19459: IFFALSE 19543
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
19461: LD_ADDR_VAR 0 6
19465: PUSH
19466: LD_VAR 0 7
19470: PUSH
19471: LD_VAR 0 5
19475: PUSH
19476: LD_INT 1
19478: MINUS
19479: ARRAY
19480: PPUSH
19481: LD_VAR 0 2
19485: PUSH
19486: LD_VAR 0 5
19490: PUSH
19491: LD_INT 1
19493: MINUS
19494: ARRAY
19495: PPUSH
19496: LD_VAR 0 7
19500: PUSH
19501: LD_VAR 0 5
19505: ARRAY
19506: PPUSH
19507: CALL_OW 1
19511: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
19512: LD_ADDR_VAR 0 7
19516: PUSH
19517: LD_VAR 0 7
19521: PPUSH
19522: LD_VAR 0 5
19526: PUSH
19527: LD_INT 1
19529: MINUS
19530: PPUSH
19531: LD_VAR 0 6
19535: PPUSH
19536: CALL_OW 1
19540: ST_TO_ADDR
// end ;
19541: GO 19458
19543: POP
19544: POP
// result := s_arr [ 1 ] ;
19545: LD_ADDR_VAR 0 4
19549: PUSH
19550: LD_VAR 0 7
19554: PUSH
19555: LD_INT 1
19557: ARRAY
19558: ST_TO_ADDR
// end ; end ;
19559: LD_VAR 0 4
19563: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
19564: LD_INT 0
19566: PPUSH
19567: PPUSH
// if not list then
19568: LD_VAR 0 1
19572: NOT
19573: IFFALSE 19577
// exit ;
19575: GO 19668
// i := list [ pos1 ] ;
19577: LD_ADDR_VAR 0 5
19581: PUSH
19582: LD_VAR 0 1
19586: PUSH
19587: LD_VAR 0 2
19591: ARRAY
19592: ST_TO_ADDR
// if not i then
19593: LD_VAR 0 5
19597: NOT
19598: IFFALSE 19602
// exit ;
19600: GO 19668
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
19602: LD_ADDR_VAR 0 1
19606: PUSH
19607: LD_VAR 0 1
19611: PPUSH
19612: LD_VAR 0 2
19616: PPUSH
19617: LD_VAR 0 1
19621: PUSH
19622: LD_VAR 0 3
19626: ARRAY
19627: PPUSH
19628: CALL_OW 1
19632: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
19633: LD_ADDR_VAR 0 1
19637: PUSH
19638: LD_VAR 0 1
19642: PPUSH
19643: LD_VAR 0 3
19647: PPUSH
19648: LD_VAR 0 5
19652: PPUSH
19653: CALL_OW 1
19657: ST_TO_ADDR
// result := list ;
19658: LD_ADDR_VAR 0 4
19662: PUSH
19663: LD_VAR 0 1
19667: ST_TO_ADDR
// end ;
19668: LD_VAR 0 4
19672: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19673: LD_INT 0
19675: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19676: LD_ADDR_VAR 0 5
19680: PUSH
19681: LD_VAR 0 1
19685: PPUSH
19686: CALL_OW 250
19690: PPUSH
19691: LD_VAR 0 1
19695: PPUSH
19696: CALL_OW 251
19700: PPUSH
19701: LD_VAR 0 2
19705: PPUSH
19706: LD_VAR 0 3
19710: PPUSH
19711: LD_VAR 0 4
19715: PPUSH
19716: CALL 19726 0 5
19720: ST_TO_ADDR
// end ;
19721: LD_VAR 0 5
19725: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19726: LD_INT 0
19728: PPUSH
19729: PPUSH
19730: PPUSH
19731: PPUSH
// if not list then
19732: LD_VAR 0 3
19736: NOT
19737: IFFALSE 19741
// exit ;
19739: GO 20129
// result := [ ] ;
19741: LD_ADDR_VAR 0 6
19745: PUSH
19746: EMPTY
19747: ST_TO_ADDR
// for i in list do
19748: LD_ADDR_VAR 0 7
19752: PUSH
19753: LD_VAR 0 3
19757: PUSH
19758: FOR_IN
19759: IFFALSE 19961
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19761: LD_ADDR_VAR 0 9
19765: PUSH
19766: LD_VAR 0 7
19770: PPUSH
19771: LD_VAR 0 1
19775: PPUSH
19776: LD_VAR 0 2
19780: PPUSH
19781: CALL_OW 297
19785: ST_TO_ADDR
// if not result then
19786: LD_VAR 0 6
19790: NOT
19791: IFFALSE 19817
// result := [ [ i , tmp ] ] else
19793: LD_ADDR_VAR 0 6
19797: PUSH
19798: LD_VAR 0 7
19802: PUSH
19803: LD_VAR 0 9
19807: PUSH
19808: EMPTY
19809: LIST
19810: LIST
19811: PUSH
19812: EMPTY
19813: LIST
19814: ST_TO_ADDR
19815: GO 19959
// begin if result [ result ] [ 2 ] < tmp then
19817: LD_VAR 0 6
19821: PUSH
19822: LD_VAR 0 6
19826: ARRAY
19827: PUSH
19828: LD_INT 2
19830: ARRAY
19831: PUSH
19832: LD_VAR 0 9
19836: LESS
19837: IFFALSE 19879
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19839: LD_ADDR_VAR 0 6
19843: PUSH
19844: LD_VAR 0 6
19848: PPUSH
19849: LD_VAR 0 6
19853: PUSH
19854: LD_INT 1
19856: PLUS
19857: PPUSH
19858: LD_VAR 0 7
19862: PUSH
19863: LD_VAR 0 9
19867: PUSH
19868: EMPTY
19869: LIST
19870: LIST
19871: PPUSH
19872: CALL_OW 2
19876: ST_TO_ADDR
19877: GO 19959
// for j = 1 to result do
19879: LD_ADDR_VAR 0 8
19883: PUSH
19884: DOUBLE
19885: LD_INT 1
19887: DEC
19888: ST_TO_ADDR
19889: LD_VAR 0 6
19893: PUSH
19894: FOR_TO
19895: IFFALSE 19957
// begin if tmp < result [ j ] [ 2 ] then
19897: LD_VAR 0 9
19901: PUSH
19902: LD_VAR 0 6
19906: PUSH
19907: LD_VAR 0 8
19911: ARRAY
19912: PUSH
19913: LD_INT 2
19915: ARRAY
19916: LESS
19917: IFFALSE 19955
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19919: LD_ADDR_VAR 0 6
19923: PUSH
19924: LD_VAR 0 6
19928: PPUSH
19929: LD_VAR 0 8
19933: PPUSH
19934: LD_VAR 0 7
19938: PUSH
19939: LD_VAR 0 9
19943: PUSH
19944: EMPTY
19945: LIST
19946: LIST
19947: PPUSH
19948: CALL_OW 2
19952: ST_TO_ADDR
// break ;
19953: GO 19957
// end ; end ;
19955: GO 19894
19957: POP
19958: POP
// end ; end ;
19959: GO 19758
19961: POP
19962: POP
// if result and not asc then
19963: LD_VAR 0 6
19967: PUSH
19968: LD_VAR 0 4
19972: NOT
19973: AND
19974: IFFALSE 20049
// begin tmp := result ;
19976: LD_ADDR_VAR 0 9
19980: PUSH
19981: LD_VAR 0 6
19985: ST_TO_ADDR
// for i = tmp downto 1 do
19986: LD_ADDR_VAR 0 7
19990: PUSH
19991: DOUBLE
19992: LD_VAR 0 9
19996: INC
19997: ST_TO_ADDR
19998: LD_INT 1
20000: PUSH
20001: FOR_DOWNTO
20002: IFFALSE 20047
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20004: LD_ADDR_VAR 0 6
20008: PUSH
20009: LD_VAR 0 6
20013: PPUSH
20014: LD_VAR 0 9
20018: PUSH
20019: LD_VAR 0 7
20023: MINUS
20024: PUSH
20025: LD_INT 1
20027: PLUS
20028: PPUSH
20029: LD_VAR 0 9
20033: PUSH
20034: LD_VAR 0 7
20038: ARRAY
20039: PPUSH
20040: CALL_OW 1
20044: ST_TO_ADDR
20045: GO 20001
20047: POP
20048: POP
// end ; tmp := [ ] ;
20049: LD_ADDR_VAR 0 9
20053: PUSH
20054: EMPTY
20055: ST_TO_ADDR
// if mode then
20056: LD_VAR 0 5
20060: IFFALSE 20129
// begin for i = 1 to result do
20062: LD_ADDR_VAR 0 7
20066: PUSH
20067: DOUBLE
20068: LD_INT 1
20070: DEC
20071: ST_TO_ADDR
20072: LD_VAR 0 6
20076: PUSH
20077: FOR_TO
20078: IFFALSE 20117
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20080: LD_ADDR_VAR 0 9
20084: PUSH
20085: LD_VAR 0 9
20089: PPUSH
20090: LD_VAR 0 7
20094: PPUSH
20095: LD_VAR 0 6
20099: PUSH
20100: LD_VAR 0 7
20104: ARRAY
20105: PUSH
20106: LD_INT 1
20108: ARRAY
20109: PPUSH
20110: CALL_OW 1
20114: ST_TO_ADDR
20115: GO 20077
20117: POP
20118: POP
// result := tmp ;
20119: LD_ADDR_VAR 0 6
20123: PUSH
20124: LD_VAR 0 9
20128: ST_TO_ADDR
// end ; end ;
20129: LD_VAR 0 6
20133: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20134: LD_INT 0
20136: PPUSH
20137: PPUSH
20138: PPUSH
20139: PPUSH
20140: PPUSH
20141: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20142: LD_ADDR_VAR 0 5
20146: PUSH
20147: LD_INT 0
20149: PUSH
20150: LD_INT 0
20152: PUSH
20153: LD_INT 0
20155: PUSH
20156: EMPTY
20157: PUSH
20158: EMPTY
20159: LIST
20160: LIST
20161: LIST
20162: LIST
20163: ST_TO_ADDR
// if not x or not y then
20164: LD_VAR 0 2
20168: NOT
20169: PUSH
20170: LD_VAR 0 3
20174: NOT
20175: OR
20176: IFFALSE 20180
// exit ;
20178: GO 21826
// if not range then
20180: LD_VAR 0 4
20184: NOT
20185: IFFALSE 20195
// range := 10 ;
20187: LD_ADDR_VAR 0 4
20191: PUSH
20192: LD_INT 10
20194: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20195: LD_ADDR_VAR 0 8
20199: PUSH
20200: LD_INT 81
20202: PUSH
20203: LD_VAR 0 1
20207: PUSH
20208: EMPTY
20209: LIST
20210: LIST
20211: PUSH
20212: LD_INT 92
20214: PUSH
20215: LD_VAR 0 2
20219: PUSH
20220: LD_VAR 0 3
20224: PUSH
20225: LD_VAR 0 4
20229: PUSH
20230: EMPTY
20231: LIST
20232: LIST
20233: LIST
20234: LIST
20235: PUSH
20236: LD_INT 3
20238: PUSH
20239: LD_INT 21
20241: PUSH
20242: LD_INT 3
20244: PUSH
20245: EMPTY
20246: LIST
20247: LIST
20248: PUSH
20249: EMPTY
20250: LIST
20251: LIST
20252: PUSH
20253: EMPTY
20254: LIST
20255: LIST
20256: LIST
20257: PPUSH
20258: CALL_OW 69
20262: ST_TO_ADDR
// if not tmp then
20263: LD_VAR 0 8
20267: NOT
20268: IFFALSE 20272
// exit ;
20270: GO 21826
// for i in tmp do
20272: LD_ADDR_VAR 0 6
20276: PUSH
20277: LD_VAR 0 8
20281: PUSH
20282: FOR_IN
20283: IFFALSE 21801
// begin points := [ 0 , 0 , 0 ] ;
20285: LD_ADDR_VAR 0 9
20289: PUSH
20290: LD_INT 0
20292: PUSH
20293: LD_INT 0
20295: PUSH
20296: LD_INT 0
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: LIST
20303: ST_TO_ADDR
// bpoints := 1 ;
20304: LD_ADDR_VAR 0 10
20308: PUSH
20309: LD_INT 1
20311: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20312: LD_VAR 0 6
20316: PPUSH
20317: CALL_OW 247
20321: PUSH
20322: LD_INT 1
20324: DOUBLE
20325: EQUAL
20326: IFTRUE 20330
20328: GO 20908
20330: POP
// begin if GetClass ( i ) = 1 then
20331: LD_VAR 0 6
20335: PPUSH
20336: CALL_OW 257
20340: PUSH
20341: LD_INT 1
20343: EQUAL
20344: IFFALSE 20365
// points := [ 10 , 5 , 3 ] ;
20346: LD_ADDR_VAR 0 9
20350: PUSH
20351: LD_INT 10
20353: PUSH
20354: LD_INT 5
20356: PUSH
20357: LD_INT 3
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: LIST
20364: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
20365: LD_VAR 0 6
20369: PPUSH
20370: CALL_OW 257
20374: PUSH
20375: LD_INT 2
20377: PUSH
20378: LD_INT 3
20380: PUSH
20381: LD_INT 4
20383: PUSH
20384: EMPTY
20385: LIST
20386: LIST
20387: LIST
20388: IN
20389: IFFALSE 20410
// points := [ 3 , 2 , 1 ] ;
20391: LD_ADDR_VAR 0 9
20395: PUSH
20396: LD_INT 3
20398: PUSH
20399: LD_INT 2
20401: PUSH
20402: LD_INT 1
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: LIST
20409: ST_TO_ADDR
// if GetClass ( i ) = 5 then
20410: LD_VAR 0 6
20414: PPUSH
20415: CALL_OW 257
20419: PUSH
20420: LD_INT 5
20422: EQUAL
20423: IFFALSE 20444
// points := [ 130 , 5 , 2 ] ;
20425: LD_ADDR_VAR 0 9
20429: PUSH
20430: LD_INT 130
20432: PUSH
20433: LD_INT 5
20435: PUSH
20436: LD_INT 2
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: LIST
20443: ST_TO_ADDR
// if GetClass ( i ) = 8 then
20444: LD_VAR 0 6
20448: PPUSH
20449: CALL_OW 257
20453: PUSH
20454: LD_INT 8
20456: EQUAL
20457: IFFALSE 20478
// points := [ 35 , 35 , 30 ] ;
20459: LD_ADDR_VAR 0 9
20463: PUSH
20464: LD_INT 35
20466: PUSH
20467: LD_INT 35
20469: PUSH
20470: LD_INT 30
20472: PUSH
20473: EMPTY
20474: LIST
20475: LIST
20476: LIST
20477: ST_TO_ADDR
// if GetClass ( i ) = 9 then
20478: LD_VAR 0 6
20482: PPUSH
20483: CALL_OW 257
20487: PUSH
20488: LD_INT 9
20490: EQUAL
20491: IFFALSE 20512
// points := [ 20 , 55 , 40 ] ;
20493: LD_ADDR_VAR 0 9
20497: PUSH
20498: LD_INT 20
20500: PUSH
20501: LD_INT 55
20503: PUSH
20504: LD_INT 40
20506: PUSH
20507: EMPTY
20508: LIST
20509: LIST
20510: LIST
20511: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
20512: LD_VAR 0 6
20516: PPUSH
20517: CALL_OW 257
20521: PUSH
20522: LD_INT 12
20524: PUSH
20525: LD_INT 16
20527: PUSH
20528: EMPTY
20529: LIST
20530: LIST
20531: IN
20532: IFFALSE 20553
// points := [ 5 , 3 , 2 ] ;
20534: LD_ADDR_VAR 0 9
20538: PUSH
20539: LD_INT 5
20541: PUSH
20542: LD_INT 3
20544: PUSH
20545: LD_INT 2
20547: PUSH
20548: EMPTY
20549: LIST
20550: LIST
20551: LIST
20552: ST_TO_ADDR
// if GetClass ( i ) = 17 then
20553: LD_VAR 0 6
20557: PPUSH
20558: CALL_OW 257
20562: PUSH
20563: LD_INT 17
20565: EQUAL
20566: IFFALSE 20587
// points := [ 100 , 50 , 75 ] ;
20568: LD_ADDR_VAR 0 9
20572: PUSH
20573: LD_INT 100
20575: PUSH
20576: LD_INT 50
20578: PUSH
20579: LD_INT 75
20581: PUSH
20582: EMPTY
20583: LIST
20584: LIST
20585: LIST
20586: ST_TO_ADDR
// if GetClass ( i ) = 15 then
20587: LD_VAR 0 6
20591: PPUSH
20592: CALL_OW 257
20596: PUSH
20597: LD_INT 15
20599: EQUAL
20600: IFFALSE 20621
// points := [ 10 , 5 , 3 ] ;
20602: LD_ADDR_VAR 0 9
20606: PUSH
20607: LD_INT 10
20609: PUSH
20610: LD_INT 5
20612: PUSH
20613: LD_INT 3
20615: PUSH
20616: EMPTY
20617: LIST
20618: LIST
20619: LIST
20620: ST_TO_ADDR
// if GetClass ( i ) = 14 then
20621: LD_VAR 0 6
20625: PPUSH
20626: CALL_OW 257
20630: PUSH
20631: LD_INT 14
20633: EQUAL
20634: IFFALSE 20655
// points := [ 10 , 0 , 0 ] ;
20636: LD_ADDR_VAR 0 9
20640: PUSH
20641: LD_INT 10
20643: PUSH
20644: LD_INT 0
20646: PUSH
20647: LD_INT 0
20649: PUSH
20650: EMPTY
20651: LIST
20652: LIST
20653: LIST
20654: ST_TO_ADDR
// if GetClass ( i ) = 11 then
20655: LD_VAR 0 6
20659: PPUSH
20660: CALL_OW 257
20664: PUSH
20665: LD_INT 11
20667: EQUAL
20668: IFFALSE 20689
// points := [ 30 , 10 , 5 ] ;
20670: LD_ADDR_VAR 0 9
20674: PUSH
20675: LD_INT 30
20677: PUSH
20678: LD_INT 10
20680: PUSH
20681: LD_INT 5
20683: PUSH
20684: EMPTY
20685: LIST
20686: LIST
20687: LIST
20688: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20689: LD_VAR 0 1
20693: PPUSH
20694: LD_INT 5
20696: PPUSH
20697: CALL_OW 321
20701: PUSH
20702: LD_INT 2
20704: EQUAL
20705: IFFALSE 20722
// bpoints := bpoints * 1.8 ;
20707: LD_ADDR_VAR 0 10
20711: PUSH
20712: LD_VAR 0 10
20716: PUSH
20717: LD_REAL  1.80000000000000E+0000
20720: MUL
20721: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20722: LD_VAR 0 6
20726: PPUSH
20727: CALL_OW 257
20731: PUSH
20732: LD_INT 1
20734: PUSH
20735: LD_INT 2
20737: PUSH
20738: LD_INT 3
20740: PUSH
20741: LD_INT 4
20743: PUSH
20744: EMPTY
20745: LIST
20746: LIST
20747: LIST
20748: LIST
20749: IN
20750: PUSH
20751: LD_VAR 0 1
20755: PPUSH
20756: LD_INT 51
20758: PPUSH
20759: CALL_OW 321
20763: PUSH
20764: LD_INT 2
20766: EQUAL
20767: AND
20768: IFFALSE 20785
// bpoints := bpoints * 1.2 ;
20770: LD_ADDR_VAR 0 10
20774: PUSH
20775: LD_VAR 0 10
20779: PUSH
20780: LD_REAL  1.20000000000000E+0000
20783: MUL
20784: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20785: LD_VAR 0 6
20789: PPUSH
20790: CALL_OW 257
20794: PUSH
20795: LD_INT 5
20797: PUSH
20798: LD_INT 7
20800: PUSH
20801: LD_INT 9
20803: PUSH
20804: EMPTY
20805: LIST
20806: LIST
20807: LIST
20808: IN
20809: PUSH
20810: LD_VAR 0 1
20814: PPUSH
20815: LD_INT 52
20817: PPUSH
20818: CALL_OW 321
20822: PUSH
20823: LD_INT 2
20825: EQUAL
20826: AND
20827: IFFALSE 20844
// bpoints := bpoints * 1.5 ;
20829: LD_ADDR_VAR 0 10
20833: PUSH
20834: LD_VAR 0 10
20838: PUSH
20839: LD_REAL  1.50000000000000E+0000
20842: MUL
20843: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20844: LD_VAR 0 1
20848: PPUSH
20849: LD_INT 66
20851: PPUSH
20852: CALL_OW 321
20856: PUSH
20857: LD_INT 2
20859: EQUAL
20860: IFFALSE 20877
// bpoints := bpoints * 1.1 ;
20862: LD_ADDR_VAR 0 10
20866: PUSH
20867: LD_VAR 0 10
20871: PUSH
20872: LD_REAL  1.10000000000000E+0000
20875: MUL
20876: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20877: LD_ADDR_VAR 0 10
20881: PUSH
20882: LD_VAR 0 10
20886: PUSH
20887: LD_VAR 0 6
20891: PPUSH
20892: LD_INT 1
20894: PPUSH
20895: CALL_OW 259
20899: PUSH
20900: LD_REAL  1.15000000000000E+0000
20903: MUL
20904: MUL
20905: ST_TO_ADDR
// end ; unit_vehicle :
20906: GO 21730
20908: LD_INT 2
20910: DOUBLE
20911: EQUAL
20912: IFTRUE 20916
20914: GO 21718
20916: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20917: LD_VAR 0 6
20921: PPUSH
20922: CALL_OW 264
20926: PUSH
20927: LD_INT 2
20929: PUSH
20930: LD_INT 42
20932: PUSH
20933: LD_INT 24
20935: PUSH
20936: EMPTY
20937: LIST
20938: LIST
20939: LIST
20940: IN
20941: IFFALSE 20962
// points := [ 25 , 5 , 3 ] ;
20943: LD_ADDR_VAR 0 9
20947: PUSH
20948: LD_INT 25
20950: PUSH
20951: LD_INT 5
20953: PUSH
20954: LD_INT 3
20956: PUSH
20957: EMPTY
20958: LIST
20959: LIST
20960: LIST
20961: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20962: LD_VAR 0 6
20966: PPUSH
20967: CALL_OW 264
20971: PUSH
20972: LD_INT 4
20974: PUSH
20975: LD_INT 43
20977: PUSH
20978: LD_INT 25
20980: PUSH
20981: EMPTY
20982: LIST
20983: LIST
20984: LIST
20985: IN
20986: IFFALSE 21007
// points := [ 40 , 15 , 5 ] ;
20988: LD_ADDR_VAR 0 9
20992: PUSH
20993: LD_INT 40
20995: PUSH
20996: LD_INT 15
20998: PUSH
20999: LD_INT 5
21001: PUSH
21002: EMPTY
21003: LIST
21004: LIST
21005: LIST
21006: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21007: LD_VAR 0 6
21011: PPUSH
21012: CALL_OW 264
21016: PUSH
21017: LD_INT 3
21019: PUSH
21020: LD_INT 23
21022: PUSH
21023: EMPTY
21024: LIST
21025: LIST
21026: IN
21027: IFFALSE 21048
// points := [ 7 , 25 , 8 ] ;
21029: LD_ADDR_VAR 0 9
21033: PUSH
21034: LD_INT 7
21036: PUSH
21037: LD_INT 25
21039: PUSH
21040: LD_INT 8
21042: PUSH
21043: EMPTY
21044: LIST
21045: LIST
21046: LIST
21047: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21048: LD_VAR 0 6
21052: PPUSH
21053: CALL_OW 264
21057: PUSH
21058: LD_INT 5
21060: PUSH
21061: LD_INT 27
21063: PUSH
21064: LD_INT 44
21066: PUSH
21067: EMPTY
21068: LIST
21069: LIST
21070: LIST
21071: IN
21072: IFFALSE 21093
// points := [ 14 , 50 , 16 ] ;
21074: LD_ADDR_VAR 0 9
21078: PUSH
21079: LD_INT 14
21081: PUSH
21082: LD_INT 50
21084: PUSH
21085: LD_INT 16
21087: PUSH
21088: EMPTY
21089: LIST
21090: LIST
21091: LIST
21092: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21093: LD_VAR 0 6
21097: PPUSH
21098: CALL_OW 264
21102: PUSH
21103: LD_INT 6
21105: PUSH
21106: LD_INT 46
21108: PUSH
21109: EMPTY
21110: LIST
21111: LIST
21112: IN
21113: IFFALSE 21134
// points := [ 32 , 120 , 70 ] ;
21115: LD_ADDR_VAR 0 9
21119: PUSH
21120: LD_INT 32
21122: PUSH
21123: LD_INT 120
21125: PUSH
21126: LD_INT 70
21128: PUSH
21129: EMPTY
21130: LIST
21131: LIST
21132: LIST
21133: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
21134: LD_VAR 0 6
21138: PPUSH
21139: CALL_OW 264
21143: PUSH
21144: LD_INT 7
21146: PUSH
21147: LD_INT 28
21149: PUSH
21150: LD_INT 45
21152: PUSH
21153: EMPTY
21154: LIST
21155: LIST
21156: LIST
21157: IN
21158: IFFALSE 21179
// points := [ 35 , 20 , 45 ] ;
21160: LD_ADDR_VAR 0 9
21164: PUSH
21165: LD_INT 35
21167: PUSH
21168: LD_INT 20
21170: PUSH
21171: LD_INT 45
21173: PUSH
21174: EMPTY
21175: LIST
21176: LIST
21177: LIST
21178: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21179: LD_VAR 0 6
21183: PPUSH
21184: CALL_OW 264
21188: PUSH
21189: LD_INT 47
21191: PUSH
21192: EMPTY
21193: LIST
21194: IN
21195: IFFALSE 21216
// points := [ 67 , 45 , 75 ] ;
21197: LD_ADDR_VAR 0 9
21201: PUSH
21202: LD_INT 67
21204: PUSH
21205: LD_INT 45
21207: PUSH
21208: LD_INT 75
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: LIST
21215: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21216: LD_VAR 0 6
21220: PPUSH
21221: CALL_OW 264
21225: PUSH
21226: LD_INT 26
21228: PUSH
21229: EMPTY
21230: LIST
21231: IN
21232: IFFALSE 21253
// points := [ 120 , 30 , 80 ] ;
21234: LD_ADDR_VAR 0 9
21238: PUSH
21239: LD_INT 120
21241: PUSH
21242: LD_INT 30
21244: PUSH
21245: LD_INT 80
21247: PUSH
21248: EMPTY
21249: LIST
21250: LIST
21251: LIST
21252: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21253: LD_VAR 0 6
21257: PPUSH
21258: CALL_OW 264
21262: PUSH
21263: LD_INT 22
21265: PUSH
21266: EMPTY
21267: LIST
21268: IN
21269: IFFALSE 21290
// points := [ 40 , 1 , 1 ] ;
21271: LD_ADDR_VAR 0 9
21275: PUSH
21276: LD_INT 40
21278: PUSH
21279: LD_INT 1
21281: PUSH
21282: LD_INT 1
21284: PUSH
21285: EMPTY
21286: LIST
21287: LIST
21288: LIST
21289: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21290: LD_VAR 0 6
21294: PPUSH
21295: CALL_OW 264
21299: PUSH
21300: LD_INT 29
21302: PUSH
21303: EMPTY
21304: LIST
21305: IN
21306: IFFALSE 21327
// points := [ 70 , 200 , 400 ] ;
21308: LD_ADDR_VAR 0 9
21312: PUSH
21313: LD_INT 70
21315: PUSH
21316: LD_INT 200
21318: PUSH
21319: LD_INT 400
21321: PUSH
21322: EMPTY
21323: LIST
21324: LIST
21325: LIST
21326: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
21327: LD_VAR 0 6
21331: PPUSH
21332: CALL_OW 264
21336: PUSH
21337: LD_INT 14
21339: PUSH
21340: LD_INT 53
21342: PUSH
21343: EMPTY
21344: LIST
21345: LIST
21346: IN
21347: IFFALSE 21368
// points := [ 40 , 10 , 20 ] ;
21349: LD_ADDR_VAR 0 9
21353: PUSH
21354: LD_INT 40
21356: PUSH
21357: LD_INT 10
21359: PUSH
21360: LD_INT 20
21362: PUSH
21363: EMPTY
21364: LIST
21365: LIST
21366: LIST
21367: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
21368: LD_VAR 0 6
21372: PPUSH
21373: CALL_OW 264
21377: PUSH
21378: LD_INT 9
21380: PUSH
21381: EMPTY
21382: LIST
21383: IN
21384: IFFALSE 21405
// points := [ 5 , 70 , 20 ] ;
21386: LD_ADDR_VAR 0 9
21390: PUSH
21391: LD_INT 5
21393: PUSH
21394: LD_INT 70
21396: PUSH
21397: LD_INT 20
21399: PUSH
21400: EMPTY
21401: LIST
21402: LIST
21403: LIST
21404: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
21405: LD_VAR 0 6
21409: PPUSH
21410: CALL_OW 264
21414: PUSH
21415: LD_INT 10
21417: PUSH
21418: EMPTY
21419: LIST
21420: IN
21421: IFFALSE 21442
// points := [ 35 , 110 , 70 ] ;
21423: LD_ADDR_VAR 0 9
21427: PUSH
21428: LD_INT 35
21430: PUSH
21431: LD_INT 110
21433: PUSH
21434: LD_INT 70
21436: PUSH
21437: EMPTY
21438: LIST
21439: LIST
21440: LIST
21441: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
21442: LD_VAR 0 6
21446: PPUSH
21447: CALL_OW 265
21451: PUSH
21452: LD_INT 25
21454: EQUAL
21455: IFFALSE 21476
// points := [ 80 , 65 , 100 ] ;
21457: LD_ADDR_VAR 0 9
21461: PUSH
21462: LD_INT 80
21464: PUSH
21465: LD_INT 65
21467: PUSH
21468: LD_INT 100
21470: PUSH
21471: EMPTY
21472: LIST
21473: LIST
21474: LIST
21475: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
21476: LD_VAR 0 6
21480: PPUSH
21481: CALL_OW 263
21485: PUSH
21486: LD_INT 1
21488: EQUAL
21489: IFFALSE 21524
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
21491: LD_ADDR_VAR 0 10
21495: PUSH
21496: LD_VAR 0 10
21500: PUSH
21501: LD_VAR 0 6
21505: PPUSH
21506: CALL_OW 311
21510: PPUSH
21511: LD_INT 3
21513: PPUSH
21514: CALL_OW 259
21518: PUSH
21519: LD_INT 4
21521: MUL
21522: MUL
21523: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
21524: LD_VAR 0 6
21528: PPUSH
21529: CALL_OW 263
21533: PUSH
21534: LD_INT 2
21536: EQUAL
21537: IFFALSE 21588
// begin j := IsControledBy ( i ) ;
21539: LD_ADDR_VAR 0 7
21543: PUSH
21544: LD_VAR 0 6
21548: PPUSH
21549: CALL_OW 312
21553: ST_TO_ADDR
// if j then
21554: LD_VAR 0 7
21558: IFFALSE 21588
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
21560: LD_ADDR_VAR 0 10
21564: PUSH
21565: LD_VAR 0 10
21569: PUSH
21570: LD_VAR 0 7
21574: PPUSH
21575: LD_INT 3
21577: PPUSH
21578: CALL_OW 259
21582: PUSH
21583: LD_INT 3
21585: MUL
21586: MUL
21587: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
21588: LD_VAR 0 6
21592: PPUSH
21593: CALL_OW 264
21597: PUSH
21598: LD_INT 5
21600: PUSH
21601: LD_INT 6
21603: PUSH
21604: LD_INT 46
21606: PUSH
21607: LD_INT 44
21609: PUSH
21610: LD_INT 47
21612: PUSH
21613: LD_INT 45
21615: PUSH
21616: LD_INT 28
21618: PUSH
21619: LD_INT 7
21621: PUSH
21622: LD_INT 27
21624: PUSH
21625: LD_INT 29
21627: PUSH
21628: EMPTY
21629: LIST
21630: LIST
21631: LIST
21632: LIST
21633: LIST
21634: LIST
21635: LIST
21636: LIST
21637: LIST
21638: LIST
21639: IN
21640: PUSH
21641: LD_VAR 0 1
21645: PPUSH
21646: LD_INT 52
21648: PPUSH
21649: CALL_OW 321
21653: PUSH
21654: LD_INT 2
21656: EQUAL
21657: AND
21658: IFFALSE 21675
// bpoints := bpoints * 1.2 ;
21660: LD_ADDR_VAR 0 10
21664: PUSH
21665: LD_VAR 0 10
21669: PUSH
21670: LD_REAL  1.20000000000000E+0000
21673: MUL
21674: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21675: LD_VAR 0 6
21679: PPUSH
21680: CALL_OW 264
21684: PUSH
21685: LD_INT 6
21687: PUSH
21688: LD_INT 46
21690: PUSH
21691: LD_INT 47
21693: PUSH
21694: EMPTY
21695: LIST
21696: LIST
21697: LIST
21698: IN
21699: IFFALSE 21716
// bpoints := bpoints * 1.2 ;
21701: LD_ADDR_VAR 0 10
21705: PUSH
21706: LD_VAR 0 10
21710: PUSH
21711: LD_REAL  1.20000000000000E+0000
21714: MUL
21715: ST_TO_ADDR
// end ; unit_building :
21716: GO 21730
21718: LD_INT 3
21720: DOUBLE
21721: EQUAL
21722: IFTRUE 21726
21724: GO 21729
21726: POP
// ; end ;
21727: GO 21730
21729: POP
// for j = 1 to 3 do
21730: LD_ADDR_VAR 0 7
21734: PUSH
21735: DOUBLE
21736: LD_INT 1
21738: DEC
21739: ST_TO_ADDR
21740: LD_INT 3
21742: PUSH
21743: FOR_TO
21744: IFFALSE 21797
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21746: LD_ADDR_VAR 0 5
21750: PUSH
21751: LD_VAR 0 5
21755: PPUSH
21756: LD_VAR 0 7
21760: PPUSH
21761: LD_VAR 0 5
21765: PUSH
21766: LD_VAR 0 7
21770: ARRAY
21771: PUSH
21772: LD_VAR 0 9
21776: PUSH
21777: LD_VAR 0 7
21781: ARRAY
21782: PUSH
21783: LD_VAR 0 10
21787: MUL
21788: PLUS
21789: PPUSH
21790: CALL_OW 1
21794: ST_TO_ADDR
21795: GO 21743
21797: POP
21798: POP
// end ;
21799: GO 20282
21801: POP
21802: POP
// result := Replace ( result , 4 , tmp ) ;
21803: LD_ADDR_VAR 0 5
21807: PUSH
21808: LD_VAR 0 5
21812: PPUSH
21813: LD_INT 4
21815: PPUSH
21816: LD_VAR 0 8
21820: PPUSH
21821: CALL_OW 1
21825: ST_TO_ADDR
// end ;
21826: LD_VAR 0 5
21830: RET
// export function DangerAtRange ( unit , range ) ; begin
21831: LD_INT 0
21833: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21834: LD_ADDR_VAR 0 3
21838: PUSH
21839: LD_VAR 0 1
21843: PPUSH
21844: CALL_OW 255
21848: PPUSH
21849: LD_VAR 0 1
21853: PPUSH
21854: CALL_OW 250
21858: PPUSH
21859: LD_VAR 0 1
21863: PPUSH
21864: CALL_OW 251
21868: PPUSH
21869: LD_VAR 0 2
21873: PPUSH
21874: CALL 20134 0 4
21878: ST_TO_ADDR
// end ;
21879: LD_VAR 0 3
21883: RET
// export function DangerInArea ( side , area ) ; begin
21884: LD_INT 0
21886: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21887: LD_ADDR_VAR 0 3
21891: PUSH
21892: LD_VAR 0 2
21896: PPUSH
21897: LD_INT 81
21899: PUSH
21900: LD_VAR 0 1
21904: PUSH
21905: EMPTY
21906: LIST
21907: LIST
21908: PPUSH
21909: CALL_OW 70
21913: ST_TO_ADDR
// end ;
21914: LD_VAR 0 3
21918: RET
// export function IsExtension ( b ) ; begin
21919: LD_INT 0
21921: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21922: LD_ADDR_VAR 0 2
21926: PUSH
21927: LD_VAR 0 1
21931: PUSH
21932: LD_INT 23
21934: PUSH
21935: LD_INT 20
21937: PUSH
21938: LD_INT 22
21940: PUSH
21941: LD_INT 17
21943: PUSH
21944: LD_INT 24
21946: PUSH
21947: LD_INT 21
21949: PUSH
21950: LD_INT 19
21952: PUSH
21953: LD_INT 16
21955: PUSH
21956: LD_INT 25
21958: PUSH
21959: LD_INT 18
21961: PUSH
21962: EMPTY
21963: LIST
21964: LIST
21965: LIST
21966: LIST
21967: LIST
21968: LIST
21969: LIST
21970: LIST
21971: LIST
21972: LIST
21973: IN
21974: ST_TO_ADDR
// end ;
21975: LD_VAR 0 2
21979: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
21980: LD_INT 0
21982: PPUSH
21983: PPUSH
21984: PPUSH
// result := [ ] ;
21985: LD_ADDR_VAR 0 3
21989: PUSH
21990: EMPTY
21991: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21992: LD_ADDR_VAR 0 4
21996: PUSH
21997: LD_VAR 0 2
22001: PPUSH
22002: LD_INT 21
22004: PUSH
22005: LD_INT 3
22007: PUSH
22008: EMPTY
22009: LIST
22010: LIST
22011: PPUSH
22012: CALL_OW 70
22016: ST_TO_ADDR
// if not tmp then
22017: LD_VAR 0 4
22021: NOT
22022: IFFALSE 22026
// exit ;
22024: GO 22084
// for i in tmp do
22026: LD_ADDR_VAR 0 5
22030: PUSH
22031: LD_VAR 0 4
22035: PUSH
22036: FOR_IN
22037: IFFALSE 22072
// if GetBase ( i ) <> base then
22039: LD_VAR 0 5
22043: PPUSH
22044: CALL_OW 274
22048: PUSH
22049: LD_VAR 0 1
22053: NONEQUAL
22054: IFFALSE 22070
// ComLinkToBase ( base , i ) ;
22056: LD_VAR 0 1
22060: PPUSH
22061: LD_VAR 0 5
22065: PPUSH
22066: CALL_OW 169
22070: GO 22036
22072: POP
22073: POP
// result := tmp ;
22074: LD_ADDR_VAR 0 3
22078: PUSH
22079: LD_VAR 0 4
22083: ST_TO_ADDR
// end ;
22084: LD_VAR 0 3
22088: RET
// export function ComComplete ( unit , b ) ; var i ; begin
22089: LD_INT 0
22091: PPUSH
22092: PPUSH
// if BuildingStatus ( b ) = bs_build then
22093: LD_VAR 0 2
22097: PPUSH
22098: CALL_OW 461
22102: PUSH
22103: LD_INT 1
22105: EQUAL
22106: IFFALSE 22166
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22108: LD_VAR 0 1
22112: PPUSH
22113: LD_STRING h
22115: PUSH
22116: LD_VAR 0 2
22120: PPUSH
22121: CALL_OW 250
22125: PUSH
22126: LD_VAR 0 2
22130: PPUSH
22131: CALL_OW 251
22135: PUSH
22136: LD_VAR 0 2
22140: PUSH
22141: LD_INT 0
22143: PUSH
22144: LD_INT 0
22146: PUSH
22147: LD_INT 0
22149: PUSH
22150: EMPTY
22151: LIST
22152: LIST
22153: LIST
22154: LIST
22155: LIST
22156: LIST
22157: LIST
22158: PUSH
22159: EMPTY
22160: LIST
22161: PPUSH
22162: CALL_OW 446
// end ;
22166: LD_VAR 0 3
22170: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22171: LD_INT 0
22173: PPUSH
22174: PPUSH
22175: PPUSH
22176: PPUSH
22177: PPUSH
22178: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
22179: LD_VAR 0 1
22183: NOT
22184: PUSH
22185: LD_VAR 0 1
22189: PPUSH
22190: CALL_OW 263
22194: PUSH
22195: LD_INT 2
22197: EQUAL
22198: NOT
22199: OR
22200: IFFALSE 22204
// exit ;
22202: GO 22520
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22204: LD_ADDR_VAR 0 6
22208: PUSH
22209: LD_INT 22
22211: PUSH
22212: LD_VAR 0 1
22216: PPUSH
22217: CALL_OW 255
22221: PUSH
22222: EMPTY
22223: LIST
22224: LIST
22225: PUSH
22226: LD_INT 2
22228: PUSH
22229: LD_INT 30
22231: PUSH
22232: LD_INT 36
22234: PUSH
22235: EMPTY
22236: LIST
22237: LIST
22238: PUSH
22239: LD_INT 34
22241: PUSH
22242: LD_INT 31
22244: PUSH
22245: EMPTY
22246: LIST
22247: LIST
22248: PUSH
22249: EMPTY
22250: LIST
22251: LIST
22252: LIST
22253: PUSH
22254: EMPTY
22255: LIST
22256: LIST
22257: PPUSH
22258: CALL_OW 69
22262: ST_TO_ADDR
// if not tmp then
22263: LD_VAR 0 6
22267: NOT
22268: IFFALSE 22272
// exit ;
22270: GO 22520
// result := [ ] ;
22272: LD_ADDR_VAR 0 2
22276: PUSH
22277: EMPTY
22278: ST_TO_ADDR
// for i in tmp do
22279: LD_ADDR_VAR 0 3
22283: PUSH
22284: LD_VAR 0 6
22288: PUSH
22289: FOR_IN
22290: IFFALSE 22361
// begin t := UnitsInside ( i ) ;
22292: LD_ADDR_VAR 0 4
22296: PUSH
22297: LD_VAR 0 3
22301: PPUSH
22302: CALL_OW 313
22306: ST_TO_ADDR
// if t then
22307: LD_VAR 0 4
22311: IFFALSE 22359
// for j in t do
22313: LD_ADDR_VAR 0 7
22317: PUSH
22318: LD_VAR 0 4
22322: PUSH
22323: FOR_IN
22324: IFFALSE 22357
// result := Insert ( result , result + 1 , j ) ;
22326: LD_ADDR_VAR 0 2
22330: PUSH
22331: LD_VAR 0 2
22335: PPUSH
22336: LD_VAR 0 2
22340: PUSH
22341: LD_INT 1
22343: PLUS
22344: PPUSH
22345: LD_VAR 0 7
22349: PPUSH
22350: CALL_OW 2
22354: ST_TO_ADDR
22355: GO 22323
22357: POP
22358: POP
// end ;
22359: GO 22289
22361: POP
22362: POP
// if not result then
22363: LD_VAR 0 2
22367: NOT
22368: IFFALSE 22372
// exit ;
22370: GO 22520
// mech := result [ 1 ] ;
22372: LD_ADDR_VAR 0 5
22376: PUSH
22377: LD_VAR 0 2
22381: PUSH
22382: LD_INT 1
22384: ARRAY
22385: ST_TO_ADDR
// if result > 1 then
22386: LD_VAR 0 2
22390: PUSH
22391: LD_INT 1
22393: GREATER
22394: IFFALSE 22506
// for i = 2 to result do
22396: LD_ADDR_VAR 0 3
22400: PUSH
22401: DOUBLE
22402: LD_INT 2
22404: DEC
22405: ST_TO_ADDR
22406: LD_VAR 0 2
22410: PUSH
22411: FOR_TO
22412: IFFALSE 22504
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
22414: LD_ADDR_VAR 0 4
22418: PUSH
22419: LD_VAR 0 2
22423: PUSH
22424: LD_VAR 0 3
22428: ARRAY
22429: PPUSH
22430: LD_INT 3
22432: PPUSH
22433: CALL_OW 259
22437: PUSH
22438: LD_VAR 0 2
22442: PUSH
22443: LD_VAR 0 3
22447: ARRAY
22448: PPUSH
22449: CALL_OW 432
22453: MINUS
22454: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
22455: LD_VAR 0 4
22459: PUSH
22460: LD_VAR 0 5
22464: PPUSH
22465: LD_INT 3
22467: PPUSH
22468: CALL_OW 259
22472: PUSH
22473: LD_VAR 0 5
22477: PPUSH
22478: CALL_OW 432
22482: MINUS
22483: GREATEREQUAL
22484: IFFALSE 22502
// mech := result [ i ] ;
22486: LD_ADDR_VAR 0 5
22490: PUSH
22491: LD_VAR 0 2
22495: PUSH
22496: LD_VAR 0 3
22500: ARRAY
22501: ST_TO_ADDR
// end ;
22502: GO 22411
22504: POP
22505: POP
// ComLinkTo ( vehicle , mech ) ;
22506: LD_VAR 0 1
22510: PPUSH
22511: LD_VAR 0 5
22515: PPUSH
22516: CALL_OW 135
// end ;
22520: LD_VAR 0 2
22524: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
22525: LD_INT 0
22527: PPUSH
22528: PPUSH
22529: PPUSH
22530: PPUSH
22531: PPUSH
22532: PPUSH
22533: PPUSH
22534: PPUSH
22535: PPUSH
22536: PPUSH
22537: PPUSH
22538: PPUSH
22539: PPUSH
// result := [ ] ;
22540: LD_ADDR_VAR 0 7
22544: PUSH
22545: EMPTY
22546: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
22547: LD_VAR 0 1
22551: PPUSH
22552: CALL_OW 266
22556: PUSH
22557: LD_INT 0
22559: PUSH
22560: LD_INT 1
22562: PUSH
22563: EMPTY
22564: LIST
22565: LIST
22566: IN
22567: NOT
22568: IFFALSE 22572
// exit ;
22570: GO 24203
// if name then
22572: LD_VAR 0 3
22576: IFFALSE 22592
// SetBName ( base_dep , name ) ;
22578: LD_VAR 0 1
22582: PPUSH
22583: LD_VAR 0 3
22587: PPUSH
22588: CALL_OW 500
// base := GetBase ( base_dep ) ;
22592: LD_ADDR_VAR 0 15
22596: PUSH
22597: LD_VAR 0 1
22601: PPUSH
22602: CALL_OW 274
22606: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
22607: LD_ADDR_VAR 0 16
22611: PUSH
22612: LD_VAR 0 1
22616: PPUSH
22617: CALL_OW 255
22621: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
22622: LD_ADDR_VAR 0 17
22626: PUSH
22627: LD_VAR 0 1
22631: PPUSH
22632: CALL_OW 248
22636: ST_TO_ADDR
// if sources then
22637: LD_VAR 0 5
22641: IFFALSE 22688
// for i = 1 to 3 do
22643: LD_ADDR_VAR 0 8
22647: PUSH
22648: DOUBLE
22649: LD_INT 1
22651: DEC
22652: ST_TO_ADDR
22653: LD_INT 3
22655: PUSH
22656: FOR_TO
22657: IFFALSE 22686
// AddResourceType ( base , i , sources [ i ] ) ;
22659: LD_VAR 0 15
22663: PPUSH
22664: LD_VAR 0 8
22668: PPUSH
22669: LD_VAR 0 5
22673: PUSH
22674: LD_VAR 0 8
22678: ARRAY
22679: PPUSH
22680: CALL_OW 276
22684: GO 22656
22686: POP
22687: POP
// buildings := GetBaseBuildings ( base , area ) ;
22688: LD_ADDR_VAR 0 18
22692: PUSH
22693: LD_VAR 0 15
22697: PPUSH
22698: LD_VAR 0 2
22702: PPUSH
22703: CALL 21980 0 2
22707: ST_TO_ADDR
// InitHc ;
22708: CALL_OW 19
// InitUc ;
22712: CALL_OW 18
// uc_side := side ;
22716: LD_ADDR_OWVAR 20
22720: PUSH
22721: LD_VAR 0 16
22725: ST_TO_ADDR
// uc_nation := nation ;
22726: LD_ADDR_OWVAR 21
22730: PUSH
22731: LD_VAR 0 17
22735: ST_TO_ADDR
// if buildings then
22736: LD_VAR 0 18
22740: IFFALSE 24062
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22742: LD_ADDR_VAR 0 19
22746: PUSH
22747: LD_VAR 0 18
22751: PPUSH
22752: LD_INT 2
22754: PUSH
22755: LD_INT 30
22757: PUSH
22758: LD_INT 29
22760: PUSH
22761: EMPTY
22762: LIST
22763: LIST
22764: PUSH
22765: LD_INT 30
22767: PUSH
22768: LD_INT 30
22770: PUSH
22771: EMPTY
22772: LIST
22773: LIST
22774: PUSH
22775: EMPTY
22776: LIST
22777: LIST
22778: LIST
22779: PPUSH
22780: CALL_OW 72
22784: ST_TO_ADDR
// if tmp then
22785: LD_VAR 0 19
22789: IFFALSE 22837
// for i in tmp do
22791: LD_ADDR_VAR 0 8
22795: PUSH
22796: LD_VAR 0 19
22800: PUSH
22801: FOR_IN
22802: IFFALSE 22835
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22804: LD_VAR 0 8
22808: PPUSH
22809: CALL_OW 250
22813: PPUSH
22814: LD_VAR 0 8
22818: PPUSH
22819: CALL_OW 251
22823: PPUSH
22824: LD_VAR 0 16
22828: PPUSH
22829: CALL_OW 441
22833: GO 22801
22835: POP
22836: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22837: LD_VAR 0 18
22841: PPUSH
22842: LD_INT 2
22844: PUSH
22845: LD_INT 30
22847: PUSH
22848: LD_INT 32
22850: PUSH
22851: EMPTY
22852: LIST
22853: LIST
22854: PUSH
22855: LD_INT 30
22857: PUSH
22858: LD_INT 33
22860: PUSH
22861: EMPTY
22862: LIST
22863: LIST
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: LIST
22869: PPUSH
22870: CALL_OW 72
22874: IFFALSE 22962
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22876: LD_ADDR_VAR 0 8
22880: PUSH
22881: LD_VAR 0 18
22885: PPUSH
22886: LD_INT 2
22888: PUSH
22889: LD_INT 30
22891: PUSH
22892: LD_INT 32
22894: PUSH
22895: EMPTY
22896: LIST
22897: LIST
22898: PUSH
22899: LD_INT 30
22901: PUSH
22902: LD_INT 33
22904: PUSH
22905: EMPTY
22906: LIST
22907: LIST
22908: PUSH
22909: EMPTY
22910: LIST
22911: LIST
22912: LIST
22913: PPUSH
22914: CALL_OW 72
22918: PUSH
22919: FOR_IN
22920: IFFALSE 22960
// begin if not GetBWeapon ( i ) then
22922: LD_VAR 0 8
22926: PPUSH
22927: CALL_OW 269
22931: NOT
22932: IFFALSE 22958
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22934: LD_VAR 0 8
22938: PPUSH
22939: LD_VAR 0 8
22943: PPUSH
22944: LD_VAR 0 2
22948: PPUSH
22949: CALL 24208 0 2
22953: PPUSH
22954: CALL_OW 431
// end ;
22958: GO 22919
22960: POP
22961: POP
// end ; for i = 1 to personel do
22962: LD_ADDR_VAR 0 8
22966: PUSH
22967: DOUBLE
22968: LD_INT 1
22970: DEC
22971: ST_TO_ADDR
22972: LD_VAR 0 6
22976: PUSH
22977: FOR_TO
22978: IFFALSE 24042
// begin if i > 4 then
22980: LD_VAR 0 8
22984: PUSH
22985: LD_INT 4
22987: GREATER
22988: IFFALSE 22992
// break ;
22990: GO 24042
// case i of 1 :
22992: LD_VAR 0 8
22996: PUSH
22997: LD_INT 1
22999: DOUBLE
23000: EQUAL
23001: IFTRUE 23005
23003: GO 23085
23005: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23006: LD_ADDR_VAR 0 12
23010: PUSH
23011: LD_VAR 0 18
23015: PPUSH
23016: LD_INT 22
23018: PUSH
23019: LD_VAR 0 16
23023: PUSH
23024: EMPTY
23025: LIST
23026: LIST
23027: PUSH
23028: LD_INT 58
23030: PUSH
23031: EMPTY
23032: LIST
23033: PUSH
23034: LD_INT 2
23036: PUSH
23037: LD_INT 30
23039: PUSH
23040: LD_INT 32
23042: PUSH
23043: EMPTY
23044: LIST
23045: LIST
23046: PUSH
23047: LD_INT 30
23049: PUSH
23050: LD_INT 4
23052: PUSH
23053: EMPTY
23054: LIST
23055: LIST
23056: PUSH
23057: LD_INT 30
23059: PUSH
23060: LD_INT 5
23062: PUSH
23063: EMPTY
23064: LIST
23065: LIST
23066: PUSH
23067: EMPTY
23068: LIST
23069: LIST
23070: LIST
23071: LIST
23072: PUSH
23073: EMPTY
23074: LIST
23075: LIST
23076: LIST
23077: PPUSH
23078: CALL_OW 72
23082: ST_TO_ADDR
23083: GO 23307
23085: LD_INT 2
23087: DOUBLE
23088: EQUAL
23089: IFTRUE 23093
23091: GO 23155
23093: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23094: LD_ADDR_VAR 0 12
23098: PUSH
23099: LD_VAR 0 18
23103: PPUSH
23104: LD_INT 22
23106: PUSH
23107: LD_VAR 0 16
23111: PUSH
23112: EMPTY
23113: LIST
23114: LIST
23115: PUSH
23116: LD_INT 2
23118: PUSH
23119: LD_INT 30
23121: PUSH
23122: LD_INT 0
23124: PUSH
23125: EMPTY
23126: LIST
23127: LIST
23128: PUSH
23129: LD_INT 30
23131: PUSH
23132: LD_INT 1
23134: PUSH
23135: EMPTY
23136: LIST
23137: LIST
23138: PUSH
23139: EMPTY
23140: LIST
23141: LIST
23142: LIST
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: PPUSH
23148: CALL_OW 72
23152: ST_TO_ADDR
23153: GO 23307
23155: LD_INT 3
23157: DOUBLE
23158: EQUAL
23159: IFTRUE 23163
23161: GO 23225
23163: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23164: LD_ADDR_VAR 0 12
23168: PUSH
23169: LD_VAR 0 18
23173: PPUSH
23174: LD_INT 22
23176: PUSH
23177: LD_VAR 0 16
23181: PUSH
23182: EMPTY
23183: LIST
23184: LIST
23185: PUSH
23186: LD_INT 2
23188: PUSH
23189: LD_INT 30
23191: PUSH
23192: LD_INT 2
23194: PUSH
23195: EMPTY
23196: LIST
23197: LIST
23198: PUSH
23199: LD_INT 30
23201: PUSH
23202: LD_INT 3
23204: PUSH
23205: EMPTY
23206: LIST
23207: LIST
23208: PUSH
23209: EMPTY
23210: LIST
23211: LIST
23212: LIST
23213: PUSH
23214: EMPTY
23215: LIST
23216: LIST
23217: PPUSH
23218: CALL_OW 72
23222: ST_TO_ADDR
23223: GO 23307
23225: LD_INT 4
23227: DOUBLE
23228: EQUAL
23229: IFTRUE 23233
23231: GO 23306
23233: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23234: LD_ADDR_VAR 0 12
23238: PUSH
23239: LD_VAR 0 18
23243: PPUSH
23244: LD_INT 22
23246: PUSH
23247: LD_VAR 0 16
23251: PUSH
23252: EMPTY
23253: LIST
23254: LIST
23255: PUSH
23256: LD_INT 2
23258: PUSH
23259: LD_INT 30
23261: PUSH
23262: LD_INT 6
23264: PUSH
23265: EMPTY
23266: LIST
23267: LIST
23268: PUSH
23269: LD_INT 30
23271: PUSH
23272: LD_INT 7
23274: PUSH
23275: EMPTY
23276: LIST
23277: LIST
23278: PUSH
23279: LD_INT 30
23281: PUSH
23282: LD_INT 8
23284: PUSH
23285: EMPTY
23286: LIST
23287: LIST
23288: PUSH
23289: EMPTY
23290: LIST
23291: LIST
23292: LIST
23293: LIST
23294: PUSH
23295: EMPTY
23296: LIST
23297: LIST
23298: PPUSH
23299: CALL_OW 72
23303: ST_TO_ADDR
23304: GO 23307
23306: POP
// if i = 1 then
23307: LD_VAR 0 8
23311: PUSH
23312: LD_INT 1
23314: EQUAL
23315: IFFALSE 23426
// begin tmp := [ ] ;
23317: LD_ADDR_VAR 0 19
23321: PUSH
23322: EMPTY
23323: ST_TO_ADDR
// for j in f do
23324: LD_ADDR_VAR 0 9
23328: PUSH
23329: LD_VAR 0 12
23333: PUSH
23334: FOR_IN
23335: IFFALSE 23408
// if GetBType ( j ) = b_bunker then
23337: LD_VAR 0 9
23341: PPUSH
23342: CALL_OW 266
23346: PUSH
23347: LD_INT 32
23349: EQUAL
23350: IFFALSE 23377
// tmp := Insert ( tmp , 1 , j ) else
23352: LD_ADDR_VAR 0 19
23356: PUSH
23357: LD_VAR 0 19
23361: PPUSH
23362: LD_INT 1
23364: PPUSH
23365: LD_VAR 0 9
23369: PPUSH
23370: CALL_OW 2
23374: ST_TO_ADDR
23375: GO 23406
// tmp := Insert ( tmp , tmp + 1 , j ) ;
23377: LD_ADDR_VAR 0 19
23381: PUSH
23382: LD_VAR 0 19
23386: PPUSH
23387: LD_VAR 0 19
23391: PUSH
23392: LD_INT 1
23394: PLUS
23395: PPUSH
23396: LD_VAR 0 9
23400: PPUSH
23401: CALL_OW 2
23405: ST_TO_ADDR
23406: GO 23334
23408: POP
23409: POP
// if tmp then
23410: LD_VAR 0 19
23414: IFFALSE 23426
// f := tmp ;
23416: LD_ADDR_VAR 0 12
23420: PUSH
23421: LD_VAR 0 19
23425: ST_TO_ADDR
// end ; x := personel [ i ] ;
23426: LD_ADDR_VAR 0 13
23430: PUSH
23431: LD_VAR 0 6
23435: PUSH
23436: LD_VAR 0 8
23440: ARRAY
23441: ST_TO_ADDR
// if x = - 1 then
23442: LD_VAR 0 13
23446: PUSH
23447: LD_INT 1
23449: NEG
23450: EQUAL
23451: IFFALSE 23660
// begin for j in f do
23453: LD_ADDR_VAR 0 9
23457: PUSH
23458: LD_VAR 0 12
23462: PUSH
23463: FOR_IN
23464: IFFALSE 23656
// repeat InitHc ;
23466: CALL_OW 19
// if GetBType ( j ) = b_barracks then
23470: LD_VAR 0 9
23474: PPUSH
23475: CALL_OW 266
23479: PUSH
23480: LD_INT 5
23482: EQUAL
23483: IFFALSE 23553
// begin if UnitsInside ( j ) < 3 then
23485: LD_VAR 0 9
23489: PPUSH
23490: CALL_OW 313
23494: PUSH
23495: LD_INT 3
23497: LESS
23498: IFFALSE 23534
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23500: LD_INT 0
23502: PPUSH
23503: LD_INT 5
23505: PUSH
23506: LD_INT 8
23508: PUSH
23509: LD_INT 9
23511: PUSH
23512: EMPTY
23513: LIST
23514: LIST
23515: LIST
23516: PUSH
23517: LD_VAR 0 17
23521: ARRAY
23522: PPUSH
23523: LD_VAR 0 4
23527: PPUSH
23528: CALL_OW 380
23532: GO 23551
// PrepareHuman ( false , i , skill ) ;
23534: LD_INT 0
23536: PPUSH
23537: LD_VAR 0 8
23541: PPUSH
23542: LD_VAR 0 4
23546: PPUSH
23547: CALL_OW 380
// end else
23551: GO 23570
// PrepareHuman ( false , i , skill ) ;
23553: LD_INT 0
23555: PPUSH
23556: LD_VAR 0 8
23560: PPUSH
23561: LD_VAR 0 4
23565: PPUSH
23566: CALL_OW 380
// un := CreateHuman ;
23570: LD_ADDR_VAR 0 14
23574: PUSH
23575: CALL_OW 44
23579: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23580: LD_ADDR_VAR 0 7
23584: PUSH
23585: LD_VAR 0 7
23589: PPUSH
23590: LD_INT 1
23592: PPUSH
23593: LD_VAR 0 14
23597: PPUSH
23598: CALL_OW 2
23602: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
23603: LD_VAR 0 14
23607: PPUSH
23608: LD_VAR 0 9
23612: PPUSH
23613: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
23617: LD_VAR 0 9
23621: PPUSH
23622: CALL_OW 313
23626: PUSH
23627: LD_INT 6
23629: EQUAL
23630: PUSH
23631: LD_VAR 0 9
23635: PPUSH
23636: CALL_OW 266
23640: PUSH
23641: LD_INT 32
23643: PUSH
23644: LD_INT 31
23646: PUSH
23647: EMPTY
23648: LIST
23649: LIST
23650: IN
23651: OR
23652: IFFALSE 23466
23654: GO 23463
23656: POP
23657: POP
// end else
23658: GO 24040
// for j = 1 to x do
23660: LD_ADDR_VAR 0 9
23664: PUSH
23665: DOUBLE
23666: LD_INT 1
23668: DEC
23669: ST_TO_ADDR
23670: LD_VAR 0 13
23674: PUSH
23675: FOR_TO
23676: IFFALSE 24038
// begin InitHc ;
23678: CALL_OW 19
// if not f then
23682: LD_VAR 0 12
23686: NOT
23687: IFFALSE 23776
// begin PrepareHuman ( false , i , skill ) ;
23689: LD_INT 0
23691: PPUSH
23692: LD_VAR 0 8
23696: PPUSH
23697: LD_VAR 0 4
23701: PPUSH
23702: CALL_OW 380
// un := CreateHuman ;
23706: LD_ADDR_VAR 0 14
23710: PUSH
23711: CALL_OW 44
23715: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23716: LD_ADDR_VAR 0 7
23720: PUSH
23721: LD_VAR 0 7
23725: PPUSH
23726: LD_INT 1
23728: PPUSH
23729: LD_VAR 0 14
23733: PPUSH
23734: CALL_OW 2
23738: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23739: LD_VAR 0 14
23743: PPUSH
23744: LD_VAR 0 1
23748: PPUSH
23749: CALL_OW 250
23753: PPUSH
23754: LD_VAR 0 1
23758: PPUSH
23759: CALL_OW 251
23763: PPUSH
23764: LD_INT 10
23766: PPUSH
23767: LD_INT 0
23769: PPUSH
23770: CALL_OW 50
// continue ;
23774: GO 23675
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23776: LD_VAR 0 12
23780: PUSH
23781: LD_INT 1
23783: ARRAY
23784: PPUSH
23785: CALL_OW 313
23789: PUSH
23790: LD_VAR 0 12
23794: PUSH
23795: LD_INT 1
23797: ARRAY
23798: PPUSH
23799: CALL_OW 266
23803: PUSH
23804: LD_INT 32
23806: PUSH
23807: LD_INT 31
23809: PUSH
23810: EMPTY
23811: LIST
23812: LIST
23813: IN
23814: AND
23815: PUSH
23816: LD_VAR 0 12
23820: PUSH
23821: LD_INT 1
23823: ARRAY
23824: PPUSH
23825: CALL_OW 313
23829: PUSH
23830: LD_INT 6
23832: EQUAL
23833: OR
23834: IFFALSE 23854
// f := Delete ( f , 1 ) ;
23836: LD_ADDR_VAR 0 12
23840: PUSH
23841: LD_VAR 0 12
23845: PPUSH
23846: LD_INT 1
23848: PPUSH
23849: CALL_OW 3
23853: ST_TO_ADDR
// if not f then
23854: LD_VAR 0 12
23858: NOT
23859: IFFALSE 23877
// begin x := x + 2 ;
23861: LD_ADDR_VAR 0 13
23865: PUSH
23866: LD_VAR 0 13
23870: PUSH
23871: LD_INT 2
23873: PLUS
23874: ST_TO_ADDR
// continue ;
23875: GO 23675
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23877: LD_VAR 0 12
23881: PUSH
23882: LD_INT 1
23884: ARRAY
23885: PPUSH
23886: CALL_OW 266
23890: PUSH
23891: LD_INT 5
23893: EQUAL
23894: IFFALSE 23968
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23896: LD_VAR 0 12
23900: PUSH
23901: LD_INT 1
23903: ARRAY
23904: PPUSH
23905: CALL_OW 313
23909: PUSH
23910: LD_INT 3
23912: LESS
23913: IFFALSE 23949
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23915: LD_INT 0
23917: PPUSH
23918: LD_INT 5
23920: PUSH
23921: LD_INT 8
23923: PUSH
23924: LD_INT 9
23926: PUSH
23927: EMPTY
23928: LIST
23929: LIST
23930: LIST
23931: PUSH
23932: LD_VAR 0 17
23936: ARRAY
23937: PPUSH
23938: LD_VAR 0 4
23942: PPUSH
23943: CALL_OW 380
23947: GO 23966
// PrepareHuman ( false , i , skill ) ;
23949: LD_INT 0
23951: PPUSH
23952: LD_VAR 0 8
23956: PPUSH
23957: LD_VAR 0 4
23961: PPUSH
23962: CALL_OW 380
// end else
23966: GO 23985
// PrepareHuman ( false , i , skill ) ;
23968: LD_INT 0
23970: PPUSH
23971: LD_VAR 0 8
23975: PPUSH
23976: LD_VAR 0 4
23980: PPUSH
23981: CALL_OW 380
// un := CreateHuman ;
23985: LD_ADDR_VAR 0 14
23989: PUSH
23990: CALL_OW 44
23994: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23995: LD_ADDR_VAR 0 7
23999: PUSH
24000: LD_VAR 0 7
24004: PPUSH
24005: LD_INT 1
24007: PPUSH
24008: LD_VAR 0 14
24012: PPUSH
24013: CALL_OW 2
24017: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24018: LD_VAR 0 14
24022: PPUSH
24023: LD_VAR 0 12
24027: PUSH
24028: LD_INT 1
24030: ARRAY
24031: PPUSH
24032: CALL_OW 52
// end ;
24036: GO 23675
24038: POP
24039: POP
// end ;
24040: GO 22977
24042: POP
24043: POP
// result := result ^ buildings ;
24044: LD_ADDR_VAR 0 7
24048: PUSH
24049: LD_VAR 0 7
24053: PUSH
24054: LD_VAR 0 18
24058: ADD
24059: ST_TO_ADDR
// end else
24060: GO 24203
// begin for i = 1 to personel do
24062: LD_ADDR_VAR 0 8
24066: PUSH
24067: DOUBLE
24068: LD_INT 1
24070: DEC
24071: ST_TO_ADDR
24072: LD_VAR 0 6
24076: PUSH
24077: FOR_TO
24078: IFFALSE 24201
// begin if i > 4 then
24080: LD_VAR 0 8
24084: PUSH
24085: LD_INT 4
24087: GREATER
24088: IFFALSE 24092
// break ;
24090: GO 24201
// x := personel [ i ] ;
24092: LD_ADDR_VAR 0 13
24096: PUSH
24097: LD_VAR 0 6
24101: PUSH
24102: LD_VAR 0 8
24106: ARRAY
24107: ST_TO_ADDR
// if x = - 1 then
24108: LD_VAR 0 13
24112: PUSH
24113: LD_INT 1
24115: NEG
24116: EQUAL
24117: IFFALSE 24121
// continue ;
24119: GO 24077
// PrepareHuman ( false , i , skill ) ;
24121: LD_INT 0
24123: PPUSH
24124: LD_VAR 0 8
24128: PPUSH
24129: LD_VAR 0 4
24133: PPUSH
24134: CALL_OW 380
// un := CreateHuman ;
24138: LD_ADDR_VAR 0 14
24142: PUSH
24143: CALL_OW 44
24147: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24148: LD_VAR 0 14
24152: PPUSH
24153: LD_VAR 0 1
24157: PPUSH
24158: CALL_OW 250
24162: PPUSH
24163: LD_VAR 0 1
24167: PPUSH
24168: CALL_OW 251
24172: PPUSH
24173: LD_INT 10
24175: PPUSH
24176: LD_INT 0
24178: PPUSH
24179: CALL_OW 50
// result := result ^ un ;
24183: LD_ADDR_VAR 0 7
24187: PUSH
24188: LD_VAR 0 7
24192: PUSH
24193: LD_VAR 0 14
24197: ADD
24198: ST_TO_ADDR
// end ;
24199: GO 24077
24201: POP
24202: POP
// end ; end ;
24203: LD_VAR 0 7
24207: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24208: LD_INT 0
24210: PPUSH
24211: PPUSH
24212: PPUSH
24213: PPUSH
24214: PPUSH
24215: PPUSH
24216: PPUSH
24217: PPUSH
24218: PPUSH
24219: PPUSH
24220: PPUSH
24221: PPUSH
24222: PPUSH
24223: PPUSH
24224: PPUSH
24225: PPUSH
// result := false ;
24226: LD_ADDR_VAR 0 3
24230: PUSH
24231: LD_INT 0
24233: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24234: LD_VAR 0 1
24238: NOT
24239: PUSH
24240: LD_VAR 0 1
24244: PPUSH
24245: CALL_OW 266
24249: PUSH
24250: LD_INT 32
24252: PUSH
24253: LD_INT 33
24255: PUSH
24256: EMPTY
24257: LIST
24258: LIST
24259: IN
24260: NOT
24261: OR
24262: IFFALSE 24266
// exit ;
24264: GO 25402
// nat := GetNation ( tower ) ;
24266: LD_ADDR_VAR 0 12
24270: PUSH
24271: LD_VAR 0 1
24275: PPUSH
24276: CALL_OW 248
24280: ST_TO_ADDR
// side := GetSide ( tower ) ;
24281: LD_ADDR_VAR 0 16
24285: PUSH
24286: LD_VAR 0 1
24290: PPUSH
24291: CALL_OW 255
24295: ST_TO_ADDR
// x := GetX ( tower ) ;
24296: LD_ADDR_VAR 0 10
24300: PUSH
24301: LD_VAR 0 1
24305: PPUSH
24306: CALL_OW 250
24310: ST_TO_ADDR
// y := GetY ( tower ) ;
24311: LD_ADDR_VAR 0 11
24315: PUSH
24316: LD_VAR 0 1
24320: PPUSH
24321: CALL_OW 251
24325: ST_TO_ADDR
// if not x or not y then
24326: LD_VAR 0 10
24330: NOT
24331: PUSH
24332: LD_VAR 0 11
24336: NOT
24337: OR
24338: IFFALSE 24342
// exit ;
24340: GO 25402
// weapon := 0 ;
24342: LD_ADDR_VAR 0 18
24346: PUSH
24347: LD_INT 0
24349: ST_TO_ADDR
// fac_list := [ ] ;
24350: LD_ADDR_VAR 0 17
24354: PUSH
24355: EMPTY
24356: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
24357: LD_ADDR_VAR 0 6
24361: PUSH
24362: LD_VAR 0 1
24366: PPUSH
24367: CALL_OW 274
24371: PPUSH
24372: LD_VAR 0 2
24376: PPUSH
24377: CALL 21980 0 2
24381: PPUSH
24382: LD_INT 30
24384: PUSH
24385: LD_INT 3
24387: PUSH
24388: EMPTY
24389: LIST
24390: LIST
24391: PPUSH
24392: CALL_OW 72
24396: ST_TO_ADDR
// if not factories then
24397: LD_VAR 0 6
24401: NOT
24402: IFFALSE 24406
// exit ;
24404: GO 25402
// for i in factories do
24406: LD_ADDR_VAR 0 8
24410: PUSH
24411: LD_VAR 0 6
24415: PUSH
24416: FOR_IN
24417: IFFALSE 24442
// fac_list := fac_list union AvailableWeaponList ( i ) ;
24419: LD_ADDR_VAR 0 17
24423: PUSH
24424: LD_VAR 0 17
24428: PUSH
24429: LD_VAR 0 8
24433: PPUSH
24434: CALL_OW 478
24438: UNION
24439: ST_TO_ADDR
24440: GO 24416
24442: POP
24443: POP
// if not fac_list then
24444: LD_VAR 0 17
24448: NOT
24449: IFFALSE 24453
// exit ;
24451: GO 25402
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
24453: LD_ADDR_VAR 0 5
24457: PUSH
24458: LD_INT 4
24460: PUSH
24461: LD_INT 5
24463: PUSH
24464: LD_INT 9
24466: PUSH
24467: LD_INT 10
24469: PUSH
24470: LD_INT 6
24472: PUSH
24473: LD_INT 7
24475: PUSH
24476: LD_INT 11
24478: PUSH
24479: EMPTY
24480: LIST
24481: LIST
24482: LIST
24483: LIST
24484: LIST
24485: LIST
24486: LIST
24487: PUSH
24488: LD_INT 27
24490: PUSH
24491: LD_INT 28
24493: PUSH
24494: LD_INT 26
24496: PUSH
24497: LD_INT 30
24499: PUSH
24500: EMPTY
24501: LIST
24502: LIST
24503: LIST
24504: LIST
24505: PUSH
24506: LD_INT 43
24508: PUSH
24509: LD_INT 44
24511: PUSH
24512: LD_INT 46
24514: PUSH
24515: LD_INT 45
24517: PUSH
24518: LD_INT 47
24520: PUSH
24521: LD_INT 49
24523: PUSH
24524: EMPTY
24525: LIST
24526: LIST
24527: LIST
24528: LIST
24529: LIST
24530: LIST
24531: PUSH
24532: EMPTY
24533: LIST
24534: LIST
24535: LIST
24536: PUSH
24537: LD_VAR 0 12
24541: ARRAY
24542: ST_TO_ADDR
// for i in list do
24543: LD_ADDR_VAR 0 8
24547: PUSH
24548: LD_VAR 0 5
24552: PUSH
24553: FOR_IN
24554: IFFALSE 24587
// if not i in fac_list then
24556: LD_VAR 0 8
24560: PUSH
24561: LD_VAR 0 17
24565: IN
24566: NOT
24567: IFFALSE 24585
// list := list diff i ;
24569: LD_ADDR_VAR 0 5
24573: PUSH
24574: LD_VAR 0 5
24578: PUSH
24579: LD_VAR 0 8
24583: DIFF
24584: ST_TO_ADDR
24585: GO 24553
24587: POP
24588: POP
// if not list then
24589: LD_VAR 0 5
24593: NOT
24594: IFFALSE 24598
// exit ;
24596: GO 25402
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
24598: LD_VAR 0 12
24602: PUSH
24603: LD_INT 3
24605: EQUAL
24606: PUSH
24607: LD_INT 49
24609: PUSH
24610: LD_VAR 0 5
24614: IN
24615: AND
24616: PUSH
24617: LD_INT 31
24619: PPUSH
24620: LD_VAR 0 16
24624: PPUSH
24625: CALL_OW 321
24629: PUSH
24630: LD_INT 2
24632: EQUAL
24633: AND
24634: IFFALSE 24694
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
24636: LD_INT 22
24638: PUSH
24639: LD_VAR 0 16
24643: PUSH
24644: EMPTY
24645: LIST
24646: LIST
24647: PUSH
24648: LD_INT 35
24650: PUSH
24651: LD_INT 49
24653: PUSH
24654: EMPTY
24655: LIST
24656: LIST
24657: PUSH
24658: LD_INT 91
24660: PUSH
24661: LD_VAR 0 1
24665: PUSH
24666: LD_INT 10
24668: PUSH
24669: EMPTY
24670: LIST
24671: LIST
24672: LIST
24673: PUSH
24674: EMPTY
24675: LIST
24676: LIST
24677: LIST
24678: PPUSH
24679: CALL_OW 69
24683: NOT
24684: IFFALSE 24694
// weapon := ru_time_lapser ;
24686: LD_ADDR_VAR 0 18
24690: PUSH
24691: LD_INT 49
24693: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24694: LD_VAR 0 12
24698: PUSH
24699: LD_INT 1
24701: PUSH
24702: LD_INT 2
24704: PUSH
24705: EMPTY
24706: LIST
24707: LIST
24708: IN
24709: PUSH
24710: LD_INT 11
24712: PUSH
24713: LD_VAR 0 5
24717: IN
24718: PUSH
24719: LD_INT 30
24721: PUSH
24722: LD_VAR 0 5
24726: IN
24727: OR
24728: AND
24729: PUSH
24730: LD_INT 6
24732: PPUSH
24733: LD_VAR 0 16
24737: PPUSH
24738: CALL_OW 321
24742: PUSH
24743: LD_INT 2
24745: EQUAL
24746: AND
24747: IFFALSE 24912
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24749: LD_INT 22
24751: PUSH
24752: LD_VAR 0 16
24756: PUSH
24757: EMPTY
24758: LIST
24759: LIST
24760: PUSH
24761: LD_INT 2
24763: PUSH
24764: LD_INT 35
24766: PUSH
24767: LD_INT 11
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: PUSH
24774: LD_INT 35
24776: PUSH
24777: LD_INT 30
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: PUSH
24784: EMPTY
24785: LIST
24786: LIST
24787: LIST
24788: PUSH
24789: LD_INT 91
24791: PUSH
24792: LD_VAR 0 1
24796: PUSH
24797: LD_INT 18
24799: PUSH
24800: EMPTY
24801: LIST
24802: LIST
24803: LIST
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: LIST
24809: PPUSH
24810: CALL_OW 69
24814: NOT
24815: PUSH
24816: LD_INT 22
24818: PUSH
24819: LD_VAR 0 16
24823: PUSH
24824: EMPTY
24825: LIST
24826: LIST
24827: PUSH
24828: LD_INT 2
24830: PUSH
24831: LD_INT 30
24833: PUSH
24834: LD_INT 32
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: LD_INT 30
24843: PUSH
24844: LD_INT 33
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: LIST
24855: PUSH
24856: LD_INT 91
24858: PUSH
24859: LD_VAR 0 1
24863: PUSH
24864: LD_INT 12
24866: PUSH
24867: EMPTY
24868: LIST
24869: LIST
24870: LIST
24871: PUSH
24872: EMPTY
24873: LIST
24874: LIST
24875: LIST
24876: PUSH
24877: EMPTY
24878: LIST
24879: PPUSH
24880: CALL_OW 69
24884: PUSH
24885: LD_INT 2
24887: GREATER
24888: AND
24889: IFFALSE 24912
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24891: LD_ADDR_VAR 0 18
24895: PUSH
24896: LD_INT 11
24898: PUSH
24899: LD_INT 30
24901: PUSH
24902: EMPTY
24903: LIST
24904: LIST
24905: PUSH
24906: LD_VAR 0 12
24910: ARRAY
24911: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24912: LD_VAR 0 18
24916: NOT
24917: PUSH
24918: LD_INT 40
24920: PPUSH
24921: LD_VAR 0 16
24925: PPUSH
24926: CALL_OW 321
24930: PUSH
24931: LD_INT 2
24933: EQUAL
24934: AND
24935: PUSH
24936: LD_INT 7
24938: PUSH
24939: LD_VAR 0 5
24943: IN
24944: PUSH
24945: LD_INT 28
24947: PUSH
24948: LD_VAR 0 5
24952: IN
24953: OR
24954: PUSH
24955: LD_INT 45
24957: PUSH
24958: LD_VAR 0 5
24962: IN
24963: OR
24964: AND
24965: IFFALSE 25219
// begin hex := GetHexInfo ( x , y ) ;
24967: LD_ADDR_VAR 0 4
24971: PUSH
24972: LD_VAR 0 10
24976: PPUSH
24977: LD_VAR 0 11
24981: PPUSH
24982: CALL_OW 546
24986: ST_TO_ADDR
// if hex [ 1 ] then
24987: LD_VAR 0 4
24991: PUSH
24992: LD_INT 1
24994: ARRAY
24995: IFFALSE 24999
// exit ;
24997: GO 25402
// height := hex [ 2 ] ;
24999: LD_ADDR_VAR 0 15
25003: PUSH
25004: LD_VAR 0 4
25008: PUSH
25009: LD_INT 2
25011: ARRAY
25012: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25013: LD_ADDR_VAR 0 14
25017: PUSH
25018: LD_INT 0
25020: PUSH
25021: LD_INT 2
25023: PUSH
25024: LD_INT 3
25026: PUSH
25027: LD_INT 5
25029: PUSH
25030: EMPTY
25031: LIST
25032: LIST
25033: LIST
25034: LIST
25035: ST_TO_ADDR
// for i in tmp do
25036: LD_ADDR_VAR 0 8
25040: PUSH
25041: LD_VAR 0 14
25045: PUSH
25046: FOR_IN
25047: IFFALSE 25217
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25049: LD_ADDR_VAR 0 9
25053: PUSH
25054: LD_VAR 0 10
25058: PPUSH
25059: LD_VAR 0 8
25063: PPUSH
25064: LD_INT 5
25066: PPUSH
25067: CALL_OW 272
25071: PUSH
25072: LD_VAR 0 11
25076: PPUSH
25077: LD_VAR 0 8
25081: PPUSH
25082: LD_INT 5
25084: PPUSH
25085: CALL_OW 273
25089: PUSH
25090: EMPTY
25091: LIST
25092: LIST
25093: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25094: LD_VAR 0 9
25098: PUSH
25099: LD_INT 1
25101: ARRAY
25102: PPUSH
25103: LD_VAR 0 9
25107: PUSH
25108: LD_INT 2
25110: ARRAY
25111: PPUSH
25112: CALL_OW 488
25116: IFFALSE 25215
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25118: LD_ADDR_VAR 0 4
25122: PUSH
25123: LD_VAR 0 9
25127: PUSH
25128: LD_INT 1
25130: ARRAY
25131: PPUSH
25132: LD_VAR 0 9
25136: PUSH
25137: LD_INT 2
25139: ARRAY
25140: PPUSH
25141: CALL_OW 546
25145: ST_TO_ADDR
// if hex [ 1 ] then
25146: LD_VAR 0 4
25150: PUSH
25151: LD_INT 1
25153: ARRAY
25154: IFFALSE 25158
// continue ;
25156: GO 25046
// h := hex [ 2 ] ;
25158: LD_ADDR_VAR 0 13
25162: PUSH
25163: LD_VAR 0 4
25167: PUSH
25168: LD_INT 2
25170: ARRAY
25171: ST_TO_ADDR
// if h + 7 < height then
25172: LD_VAR 0 13
25176: PUSH
25177: LD_INT 7
25179: PLUS
25180: PUSH
25181: LD_VAR 0 15
25185: LESS
25186: IFFALSE 25215
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25188: LD_ADDR_VAR 0 18
25192: PUSH
25193: LD_INT 7
25195: PUSH
25196: LD_INT 28
25198: PUSH
25199: LD_INT 45
25201: PUSH
25202: EMPTY
25203: LIST
25204: LIST
25205: LIST
25206: PUSH
25207: LD_VAR 0 12
25211: ARRAY
25212: ST_TO_ADDR
// break ;
25213: GO 25217
// end ; end ; end ;
25215: GO 25046
25217: POP
25218: POP
// end ; if not weapon then
25219: LD_VAR 0 18
25223: NOT
25224: IFFALSE 25284
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25226: LD_ADDR_VAR 0 5
25230: PUSH
25231: LD_VAR 0 5
25235: PUSH
25236: LD_INT 11
25238: PUSH
25239: LD_INT 30
25241: PUSH
25242: LD_INT 49
25244: PUSH
25245: EMPTY
25246: LIST
25247: LIST
25248: LIST
25249: DIFF
25250: ST_TO_ADDR
// if not list then
25251: LD_VAR 0 5
25255: NOT
25256: IFFALSE 25260
// exit ;
25258: GO 25402
// weapon := list [ rand ( 1 , list ) ] ;
25260: LD_ADDR_VAR 0 18
25264: PUSH
25265: LD_VAR 0 5
25269: PUSH
25270: LD_INT 1
25272: PPUSH
25273: LD_VAR 0 5
25277: PPUSH
25278: CALL_OW 12
25282: ARRAY
25283: ST_TO_ADDR
// end ; if weapon then
25284: LD_VAR 0 18
25288: IFFALSE 25402
// begin tmp := CostOfWeapon ( weapon ) ;
25290: LD_ADDR_VAR 0 14
25294: PUSH
25295: LD_VAR 0 18
25299: PPUSH
25300: CALL_OW 451
25304: ST_TO_ADDR
// j := GetBase ( tower ) ;
25305: LD_ADDR_VAR 0 9
25309: PUSH
25310: LD_VAR 0 1
25314: PPUSH
25315: CALL_OW 274
25319: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
25320: LD_VAR 0 9
25324: PPUSH
25325: LD_INT 1
25327: PPUSH
25328: CALL_OW 275
25332: PUSH
25333: LD_VAR 0 14
25337: PUSH
25338: LD_INT 1
25340: ARRAY
25341: GREATEREQUAL
25342: PUSH
25343: LD_VAR 0 9
25347: PPUSH
25348: LD_INT 2
25350: PPUSH
25351: CALL_OW 275
25355: PUSH
25356: LD_VAR 0 14
25360: PUSH
25361: LD_INT 2
25363: ARRAY
25364: GREATEREQUAL
25365: AND
25366: PUSH
25367: LD_VAR 0 9
25371: PPUSH
25372: LD_INT 3
25374: PPUSH
25375: CALL_OW 275
25379: PUSH
25380: LD_VAR 0 14
25384: PUSH
25385: LD_INT 3
25387: ARRAY
25388: GREATEREQUAL
25389: AND
25390: IFFALSE 25402
// result := weapon ;
25392: LD_ADDR_VAR 0 3
25396: PUSH
25397: LD_VAR 0 18
25401: ST_TO_ADDR
// end ; end ;
25402: LD_VAR 0 3
25406: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25407: LD_INT 0
25409: PPUSH
25410: PPUSH
// result := true ;
25411: LD_ADDR_VAR 0 3
25415: PUSH
25416: LD_INT 1
25418: ST_TO_ADDR
// if array1 = array2 then
25419: LD_VAR 0 1
25423: PUSH
25424: LD_VAR 0 2
25428: EQUAL
25429: IFFALSE 25489
// begin for i = 1 to array1 do
25431: LD_ADDR_VAR 0 4
25435: PUSH
25436: DOUBLE
25437: LD_INT 1
25439: DEC
25440: ST_TO_ADDR
25441: LD_VAR 0 1
25445: PUSH
25446: FOR_TO
25447: IFFALSE 25485
// if array1 [ i ] <> array2 [ i ] then
25449: LD_VAR 0 1
25453: PUSH
25454: LD_VAR 0 4
25458: ARRAY
25459: PUSH
25460: LD_VAR 0 2
25464: PUSH
25465: LD_VAR 0 4
25469: ARRAY
25470: NONEQUAL
25471: IFFALSE 25483
// begin result := false ;
25473: LD_ADDR_VAR 0 3
25477: PUSH
25478: LD_INT 0
25480: ST_TO_ADDR
// break ;
25481: GO 25485
// end ;
25483: GO 25446
25485: POP
25486: POP
// end else
25487: GO 25497
// result := false ;
25489: LD_ADDR_VAR 0 3
25493: PUSH
25494: LD_INT 0
25496: ST_TO_ADDR
// end ;
25497: LD_VAR 0 3
25501: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
25502: LD_INT 0
25504: PPUSH
25505: PPUSH
25506: PPUSH
// pom := GetBase ( fac ) ;
25507: LD_ADDR_VAR 0 5
25511: PUSH
25512: LD_VAR 0 1
25516: PPUSH
25517: CALL_OW 274
25521: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25522: LD_ADDR_VAR 0 4
25526: PUSH
25527: LD_VAR 0 2
25531: PUSH
25532: LD_INT 1
25534: ARRAY
25535: PPUSH
25536: LD_VAR 0 2
25540: PUSH
25541: LD_INT 2
25543: ARRAY
25544: PPUSH
25545: LD_VAR 0 2
25549: PUSH
25550: LD_INT 3
25552: ARRAY
25553: PPUSH
25554: LD_VAR 0 2
25558: PUSH
25559: LD_INT 4
25561: ARRAY
25562: PPUSH
25563: CALL_OW 449
25567: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25568: LD_ADDR_VAR 0 3
25572: PUSH
25573: LD_VAR 0 5
25577: PPUSH
25578: LD_INT 1
25580: PPUSH
25581: CALL_OW 275
25585: PUSH
25586: LD_VAR 0 4
25590: PUSH
25591: LD_INT 1
25593: ARRAY
25594: GREATEREQUAL
25595: PUSH
25596: LD_VAR 0 5
25600: PPUSH
25601: LD_INT 2
25603: PPUSH
25604: CALL_OW 275
25608: PUSH
25609: LD_VAR 0 4
25613: PUSH
25614: LD_INT 2
25616: ARRAY
25617: GREATEREQUAL
25618: AND
25619: PUSH
25620: LD_VAR 0 5
25624: PPUSH
25625: LD_INT 3
25627: PPUSH
25628: CALL_OW 275
25632: PUSH
25633: LD_VAR 0 4
25637: PUSH
25638: LD_INT 3
25640: ARRAY
25641: GREATEREQUAL
25642: AND
25643: ST_TO_ADDR
// end ;
25644: LD_VAR 0 3
25648: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25649: LD_INT 0
25651: PPUSH
25652: PPUSH
25653: PPUSH
25654: PPUSH
// pom := GetBase ( building ) ;
25655: LD_ADDR_VAR 0 3
25659: PUSH
25660: LD_VAR 0 1
25664: PPUSH
25665: CALL_OW 274
25669: ST_TO_ADDR
// if not pom then
25670: LD_VAR 0 3
25674: NOT
25675: IFFALSE 25679
// exit ;
25677: GO 25849
// btype := GetBType ( building ) ;
25679: LD_ADDR_VAR 0 5
25683: PUSH
25684: LD_VAR 0 1
25688: PPUSH
25689: CALL_OW 266
25693: ST_TO_ADDR
// if btype = b_armoury then
25694: LD_VAR 0 5
25698: PUSH
25699: LD_INT 4
25701: EQUAL
25702: IFFALSE 25712
// btype := b_barracks ;
25704: LD_ADDR_VAR 0 5
25708: PUSH
25709: LD_INT 5
25711: ST_TO_ADDR
// if btype = b_depot then
25712: LD_VAR 0 5
25716: PUSH
25717: LD_INT 0
25719: EQUAL
25720: IFFALSE 25730
// btype := b_warehouse ;
25722: LD_ADDR_VAR 0 5
25726: PUSH
25727: LD_INT 1
25729: ST_TO_ADDR
// if btype = b_workshop then
25730: LD_VAR 0 5
25734: PUSH
25735: LD_INT 2
25737: EQUAL
25738: IFFALSE 25748
// btype := b_factory ;
25740: LD_ADDR_VAR 0 5
25744: PUSH
25745: LD_INT 3
25747: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25748: LD_ADDR_VAR 0 4
25752: PUSH
25753: LD_VAR 0 5
25757: PPUSH
25758: LD_VAR 0 1
25762: PPUSH
25763: CALL_OW 248
25767: PPUSH
25768: CALL_OW 450
25772: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25773: LD_ADDR_VAR 0 2
25777: PUSH
25778: LD_VAR 0 3
25782: PPUSH
25783: LD_INT 1
25785: PPUSH
25786: CALL_OW 275
25790: PUSH
25791: LD_VAR 0 4
25795: PUSH
25796: LD_INT 1
25798: ARRAY
25799: GREATEREQUAL
25800: PUSH
25801: LD_VAR 0 3
25805: PPUSH
25806: LD_INT 2
25808: PPUSH
25809: CALL_OW 275
25813: PUSH
25814: LD_VAR 0 4
25818: PUSH
25819: LD_INT 2
25821: ARRAY
25822: GREATEREQUAL
25823: AND
25824: PUSH
25825: LD_VAR 0 3
25829: PPUSH
25830: LD_INT 3
25832: PPUSH
25833: CALL_OW 275
25837: PUSH
25838: LD_VAR 0 4
25842: PUSH
25843: LD_INT 3
25845: ARRAY
25846: GREATEREQUAL
25847: AND
25848: ST_TO_ADDR
// end ;
25849: LD_VAR 0 2
25853: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25854: LD_INT 0
25856: PPUSH
25857: PPUSH
25858: PPUSH
// pom := GetBase ( building ) ;
25859: LD_ADDR_VAR 0 4
25863: PUSH
25864: LD_VAR 0 1
25868: PPUSH
25869: CALL_OW 274
25873: ST_TO_ADDR
// if not pom then
25874: LD_VAR 0 4
25878: NOT
25879: IFFALSE 25883
// exit ;
25881: GO 25984
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25883: LD_ADDR_VAR 0 5
25887: PUSH
25888: LD_VAR 0 2
25892: PPUSH
25893: LD_VAR 0 1
25897: PPUSH
25898: CALL_OW 248
25902: PPUSH
25903: CALL_OW 450
25907: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25908: LD_ADDR_VAR 0 3
25912: PUSH
25913: LD_VAR 0 4
25917: PPUSH
25918: LD_INT 1
25920: PPUSH
25921: CALL_OW 275
25925: PUSH
25926: LD_VAR 0 5
25930: PUSH
25931: LD_INT 1
25933: ARRAY
25934: GREATEREQUAL
25935: PUSH
25936: LD_VAR 0 4
25940: PPUSH
25941: LD_INT 2
25943: PPUSH
25944: CALL_OW 275
25948: PUSH
25949: LD_VAR 0 5
25953: PUSH
25954: LD_INT 2
25956: ARRAY
25957: GREATEREQUAL
25958: AND
25959: PUSH
25960: LD_VAR 0 4
25964: PPUSH
25965: LD_INT 3
25967: PPUSH
25968: CALL_OW 275
25972: PUSH
25973: LD_VAR 0 5
25977: PUSH
25978: LD_INT 3
25980: ARRAY
25981: GREATEREQUAL
25982: AND
25983: ST_TO_ADDR
// end ;
25984: LD_VAR 0 3
25988: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
25989: LD_INT 0
25991: PPUSH
25992: PPUSH
25993: PPUSH
25994: PPUSH
25995: PPUSH
25996: PPUSH
25997: PPUSH
25998: PPUSH
25999: PPUSH
26000: PPUSH
// result := false ;
26001: LD_ADDR_VAR 0 6
26005: PUSH
26006: LD_INT 0
26008: ST_TO_ADDR
// if not base or not btype or not x or not y then
26009: LD_VAR 0 1
26013: NOT
26014: PUSH
26015: LD_VAR 0 2
26019: NOT
26020: OR
26021: PUSH
26022: LD_VAR 0 3
26026: NOT
26027: OR
26028: PUSH
26029: LD_VAR 0 4
26033: NOT
26034: OR
26035: IFFALSE 26039
// exit ;
26037: GO 26648
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
26039: LD_ADDR_VAR 0 12
26043: PUSH
26044: LD_VAR 0 2
26048: PPUSH
26049: LD_VAR 0 3
26053: PPUSH
26054: LD_VAR 0 4
26058: PPUSH
26059: LD_VAR 0 5
26063: PPUSH
26064: LD_VAR 0 1
26068: PUSH
26069: LD_INT 1
26071: ARRAY
26072: PPUSH
26073: CALL_OW 248
26077: PPUSH
26078: LD_INT 0
26080: PPUSH
26081: CALL 27485 0 6
26085: ST_TO_ADDR
// if not hexes then
26086: LD_VAR 0 12
26090: NOT
26091: IFFALSE 26095
// exit ;
26093: GO 26648
// for i = 1 to hexes do
26095: LD_ADDR_VAR 0 7
26099: PUSH
26100: DOUBLE
26101: LD_INT 1
26103: DEC
26104: ST_TO_ADDR
26105: LD_VAR 0 12
26109: PUSH
26110: FOR_TO
26111: IFFALSE 26646
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26113: LD_ADDR_VAR 0 11
26117: PUSH
26118: LD_VAR 0 12
26122: PUSH
26123: LD_VAR 0 7
26127: ARRAY
26128: PUSH
26129: LD_INT 1
26131: ARRAY
26132: PPUSH
26133: LD_VAR 0 12
26137: PUSH
26138: LD_VAR 0 7
26142: ARRAY
26143: PUSH
26144: LD_INT 2
26146: ARRAY
26147: PPUSH
26148: CALL_OW 428
26152: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26153: LD_VAR 0 12
26157: PUSH
26158: LD_VAR 0 7
26162: ARRAY
26163: PUSH
26164: LD_INT 1
26166: ARRAY
26167: PPUSH
26168: LD_VAR 0 12
26172: PUSH
26173: LD_VAR 0 7
26177: ARRAY
26178: PUSH
26179: LD_INT 2
26181: ARRAY
26182: PPUSH
26183: CALL_OW 351
26187: PUSH
26188: LD_VAR 0 12
26192: PUSH
26193: LD_VAR 0 7
26197: ARRAY
26198: PUSH
26199: LD_INT 1
26201: ARRAY
26202: PPUSH
26203: LD_VAR 0 12
26207: PUSH
26208: LD_VAR 0 7
26212: ARRAY
26213: PUSH
26214: LD_INT 2
26216: ARRAY
26217: PPUSH
26218: CALL_OW 488
26222: NOT
26223: OR
26224: PUSH
26225: LD_VAR 0 11
26229: PPUSH
26230: CALL_OW 247
26234: PUSH
26235: LD_INT 3
26237: EQUAL
26238: OR
26239: IFFALSE 26245
// exit ;
26241: POP
26242: POP
26243: GO 26648
// if not tmp or not tmp in base then
26245: LD_VAR 0 11
26249: NOT
26250: PUSH
26251: LD_VAR 0 11
26255: PUSH
26256: LD_VAR 0 1
26260: IN
26261: NOT
26262: OR
26263: IFFALSE 26267
// continue ;
26265: GO 26110
// result := true ;
26267: LD_ADDR_VAR 0 6
26271: PUSH
26272: LD_INT 1
26274: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26275: LD_ADDR_VAR 0 15
26279: PUSH
26280: LD_VAR 0 1
26284: PPUSH
26285: LD_INT 22
26287: PUSH
26288: LD_VAR 0 11
26292: PPUSH
26293: CALL_OW 255
26297: PUSH
26298: EMPTY
26299: LIST
26300: LIST
26301: PUSH
26302: LD_INT 2
26304: PUSH
26305: LD_INT 30
26307: PUSH
26308: LD_INT 0
26310: PUSH
26311: EMPTY
26312: LIST
26313: LIST
26314: PUSH
26315: LD_INT 30
26317: PUSH
26318: LD_INT 1
26320: PUSH
26321: EMPTY
26322: LIST
26323: LIST
26324: PUSH
26325: EMPTY
26326: LIST
26327: LIST
26328: LIST
26329: PUSH
26330: EMPTY
26331: LIST
26332: LIST
26333: PPUSH
26334: CALL_OW 72
26338: ST_TO_ADDR
// if dep then
26339: LD_VAR 0 15
26343: IFFALSE 26479
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
26345: LD_ADDR_VAR 0 14
26349: PUSH
26350: LD_VAR 0 15
26354: PUSH
26355: LD_INT 1
26357: ARRAY
26358: PPUSH
26359: CALL_OW 250
26363: PPUSH
26364: LD_VAR 0 15
26368: PUSH
26369: LD_INT 1
26371: ARRAY
26372: PPUSH
26373: CALL_OW 254
26377: PPUSH
26378: LD_INT 5
26380: PPUSH
26381: CALL_OW 272
26385: PUSH
26386: LD_VAR 0 15
26390: PUSH
26391: LD_INT 1
26393: ARRAY
26394: PPUSH
26395: CALL_OW 251
26399: PPUSH
26400: LD_VAR 0 15
26404: PUSH
26405: LD_INT 1
26407: ARRAY
26408: PPUSH
26409: CALL_OW 254
26413: PPUSH
26414: LD_INT 5
26416: PPUSH
26417: CALL_OW 273
26421: PUSH
26422: EMPTY
26423: LIST
26424: LIST
26425: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26426: LD_VAR 0 14
26430: PUSH
26431: LD_INT 1
26433: ARRAY
26434: PPUSH
26435: LD_VAR 0 14
26439: PUSH
26440: LD_INT 2
26442: ARRAY
26443: PPUSH
26444: CALL_OW 488
26448: IFFALSE 26479
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26450: LD_VAR 0 11
26454: PPUSH
26455: LD_VAR 0 14
26459: PUSH
26460: LD_INT 1
26462: ARRAY
26463: PPUSH
26464: LD_VAR 0 14
26468: PUSH
26469: LD_INT 2
26471: ARRAY
26472: PPUSH
26473: CALL_OW 111
// continue ;
26477: GO 26110
// end ; end ; r := GetDir ( tmp ) ;
26479: LD_ADDR_VAR 0 13
26483: PUSH
26484: LD_VAR 0 11
26488: PPUSH
26489: CALL_OW 254
26493: ST_TO_ADDR
// if r = 5 then
26494: LD_VAR 0 13
26498: PUSH
26499: LD_INT 5
26501: EQUAL
26502: IFFALSE 26512
// r := 0 ;
26504: LD_ADDR_VAR 0 13
26508: PUSH
26509: LD_INT 0
26511: ST_TO_ADDR
// for j = r to 5 do
26512: LD_ADDR_VAR 0 8
26516: PUSH
26517: DOUBLE
26518: LD_VAR 0 13
26522: DEC
26523: ST_TO_ADDR
26524: LD_INT 5
26526: PUSH
26527: FOR_TO
26528: IFFALSE 26642
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26530: LD_ADDR_VAR 0 9
26534: PUSH
26535: LD_VAR 0 11
26539: PPUSH
26540: CALL_OW 250
26544: PPUSH
26545: LD_VAR 0 8
26549: PPUSH
26550: LD_INT 2
26552: PPUSH
26553: CALL_OW 272
26557: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26558: LD_ADDR_VAR 0 10
26562: PUSH
26563: LD_VAR 0 11
26567: PPUSH
26568: CALL_OW 251
26572: PPUSH
26573: LD_VAR 0 8
26577: PPUSH
26578: LD_INT 2
26580: PPUSH
26581: CALL_OW 273
26585: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26586: LD_VAR 0 9
26590: PPUSH
26591: LD_VAR 0 10
26595: PPUSH
26596: CALL_OW 488
26600: PUSH
26601: LD_VAR 0 9
26605: PPUSH
26606: LD_VAR 0 10
26610: PPUSH
26611: CALL_OW 428
26615: NOT
26616: AND
26617: IFFALSE 26640
// begin ComMoveXY ( tmp , _x , _y ) ;
26619: LD_VAR 0 11
26623: PPUSH
26624: LD_VAR 0 9
26628: PPUSH
26629: LD_VAR 0 10
26633: PPUSH
26634: CALL_OW 111
// break ;
26638: GO 26642
// end ; end ;
26640: GO 26527
26642: POP
26643: POP
// end ;
26644: GO 26110
26646: POP
26647: POP
// end ;
26648: LD_VAR 0 6
26652: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
26653: LD_INT 0
26655: PPUSH
26656: PPUSH
26657: PPUSH
26658: PPUSH
26659: PPUSH
26660: PPUSH
26661: PPUSH
26662: PPUSH
26663: PPUSH
26664: PPUSH
// result := false ;
26665: LD_ADDR_VAR 0 6
26669: PUSH
26670: LD_INT 0
26672: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26673: LD_VAR 0 1
26677: NOT
26678: PUSH
26679: LD_VAR 0 1
26683: PPUSH
26684: CALL_OW 266
26688: PUSH
26689: LD_INT 0
26691: PUSH
26692: LD_INT 1
26694: PUSH
26695: EMPTY
26696: LIST
26697: LIST
26698: IN
26699: NOT
26700: OR
26701: PUSH
26702: LD_VAR 0 2
26706: NOT
26707: OR
26708: PUSH
26709: LD_VAR 0 5
26713: PUSH
26714: LD_INT 0
26716: PUSH
26717: LD_INT 1
26719: PUSH
26720: LD_INT 2
26722: PUSH
26723: LD_INT 3
26725: PUSH
26726: LD_INT 4
26728: PUSH
26729: LD_INT 5
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: LIST
26736: LIST
26737: LIST
26738: LIST
26739: IN
26740: NOT
26741: OR
26742: PUSH
26743: LD_VAR 0 3
26747: PPUSH
26748: LD_VAR 0 4
26752: PPUSH
26753: CALL_OW 488
26757: NOT
26758: OR
26759: IFFALSE 26763
// exit ;
26761: GO 27480
// pom := GetBase ( depot ) ;
26763: LD_ADDR_VAR 0 10
26767: PUSH
26768: LD_VAR 0 1
26772: PPUSH
26773: CALL_OW 274
26777: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26778: LD_ADDR_VAR 0 11
26782: PUSH
26783: LD_VAR 0 2
26787: PPUSH
26788: LD_VAR 0 1
26792: PPUSH
26793: CALL_OW 248
26797: PPUSH
26798: CALL_OW 450
26802: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26803: LD_VAR 0 10
26807: PPUSH
26808: LD_INT 1
26810: PPUSH
26811: CALL_OW 275
26815: PUSH
26816: LD_VAR 0 11
26820: PUSH
26821: LD_INT 1
26823: ARRAY
26824: GREATEREQUAL
26825: PUSH
26826: LD_VAR 0 10
26830: PPUSH
26831: LD_INT 2
26833: PPUSH
26834: CALL_OW 275
26838: PUSH
26839: LD_VAR 0 11
26843: PUSH
26844: LD_INT 2
26846: ARRAY
26847: GREATEREQUAL
26848: AND
26849: PUSH
26850: LD_VAR 0 10
26854: PPUSH
26855: LD_INT 3
26857: PPUSH
26858: CALL_OW 275
26862: PUSH
26863: LD_VAR 0 11
26867: PUSH
26868: LD_INT 3
26870: ARRAY
26871: GREATEREQUAL
26872: AND
26873: NOT
26874: IFFALSE 26878
// exit ;
26876: GO 27480
// if GetBType ( depot ) = b_depot then
26878: LD_VAR 0 1
26882: PPUSH
26883: CALL_OW 266
26887: PUSH
26888: LD_INT 0
26890: EQUAL
26891: IFFALSE 26903
// dist := 28 else
26893: LD_ADDR_VAR 0 14
26897: PUSH
26898: LD_INT 28
26900: ST_TO_ADDR
26901: GO 26911
// dist := 36 ;
26903: LD_ADDR_VAR 0 14
26907: PUSH
26908: LD_INT 36
26910: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26911: LD_VAR 0 1
26915: PPUSH
26916: LD_VAR 0 3
26920: PPUSH
26921: LD_VAR 0 4
26925: PPUSH
26926: CALL_OW 297
26930: PUSH
26931: LD_VAR 0 14
26935: GREATER
26936: IFFALSE 26940
// exit ;
26938: GO 27480
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
26940: LD_ADDR_VAR 0 12
26944: PUSH
26945: LD_VAR 0 2
26949: PPUSH
26950: LD_VAR 0 3
26954: PPUSH
26955: LD_VAR 0 4
26959: PPUSH
26960: LD_VAR 0 5
26964: PPUSH
26965: LD_VAR 0 1
26969: PPUSH
26970: CALL_OW 248
26974: PPUSH
26975: LD_INT 0
26977: PPUSH
26978: CALL 27485 0 6
26982: ST_TO_ADDR
// if not hexes then
26983: LD_VAR 0 12
26987: NOT
26988: IFFALSE 26992
// exit ;
26990: GO 27480
// hex := GetHexInfo ( x , y ) ;
26992: LD_ADDR_VAR 0 15
26996: PUSH
26997: LD_VAR 0 3
27001: PPUSH
27002: LD_VAR 0 4
27006: PPUSH
27007: CALL_OW 546
27011: ST_TO_ADDR
// if hex [ 1 ] then
27012: LD_VAR 0 15
27016: PUSH
27017: LD_INT 1
27019: ARRAY
27020: IFFALSE 27024
// exit ;
27022: GO 27480
// height := hex [ 2 ] ;
27024: LD_ADDR_VAR 0 13
27028: PUSH
27029: LD_VAR 0 15
27033: PUSH
27034: LD_INT 2
27036: ARRAY
27037: ST_TO_ADDR
// for i = 1 to hexes do
27038: LD_ADDR_VAR 0 7
27042: PUSH
27043: DOUBLE
27044: LD_INT 1
27046: DEC
27047: ST_TO_ADDR
27048: LD_VAR 0 12
27052: PUSH
27053: FOR_TO
27054: IFFALSE 27384
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27056: LD_VAR 0 12
27060: PUSH
27061: LD_VAR 0 7
27065: ARRAY
27066: PUSH
27067: LD_INT 1
27069: ARRAY
27070: PPUSH
27071: LD_VAR 0 12
27075: PUSH
27076: LD_VAR 0 7
27080: ARRAY
27081: PUSH
27082: LD_INT 2
27084: ARRAY
27085: PPUSH
27086: CALL_OW 488
27090: NOT
27091: PUSH
27092: LD_VAR 0 12
27096: PUSH
27097: LD_VAR 0 7
27101: ARRAY
27102: PUSH
27103: LD_INT 1
27105: ARRAY
27106: PPUSH
27107: LD_VAR 0 12
27111: PUSH
27112: LD_VAR 0 7
27116: ARRAY
27117: PUSH
27118: LD_INT 2
27120: ARRAY
27121: PPUSH
27122: CALL_OW 428
27126: PUSH
27127: LD_INT 0
27129: GREATER
27130: OR
27131: PUSH
27132: LD_VAR 0 12
27136: PUSH
27137: LD_VAR 0 7
27141: ARRAY
27142: PUSH
27143: LD_INT 1
27145: ARRAY
27146: PPUSH
27147: LD_VAR 0 12
27151: PUSH
27152: LD_VAR 0 7
27156: ARRAY
27157: PUSH
27158: LD_INT 2
27160: ARRAY
27161: PPUSH
27162: CALL_OW 351
27166: OR
27167: IFFALSE 27173
// exit ;
27169: POP
27170: POP
27171: GO 27480
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27173: LD_ADDR_VAR 0 8
27177: PUSH
27178: LD_VAR 0 12
27182: PUSH
27183: LD_VAR 0 7
27187: ARRAY
27188: PUSH
27189: LD_INT 1
27191: ARRAY
27192: PPUSH
27193: LD_VAR 0 12
27197: PUSH
27198: LD_VAR 0 7
27202: ARRAY
27203: PUSH
27204: LD_INT 2
27206: ARRAY
27207: PPUSH
27208: CALL_OW 546
27212: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27213: LD_VAR 0 8
27217: PUSH
27218: LD_INT 1
27220: ARRAY
27221: PUSH
27222: LD_VAR 0 8
27226: PUSH
27227: LD_INT 2
27229: ARRAY
27230: PUSH
27231: LD_VAR 0 13
27235: PUSH
27236: LD_INT 2
27238: PLUS
27239: GREATER
27240: OR
27241: PUSH
27242: LD_VAR 0 8
27246: PUSH
27247: LD_INT 2
27249: ARRAY
27250: PUSH
27251: LD_VAR 0 13
27255: PUSH
27256: LD_INT 2
27258: MINUS
27259: LESS
27260: OR
27261: PUSH
27262: LD_VAR 0 8
27266: PUSH
27267: LD_INT 3
27269: ARRAY
27270: PUSH
27271: LD_INT 0
27273: PUSH
27274: LD_INT 8
27276: PUSH
27277: LD_INT 9
27279: PUSH
27280: LD_INT 10
27282: PUSH
27283: LD_INT 11
27285: PUSH
27286: LD_INT 12
27288: PUSH
27289: LD_INT 13
27291: PUSH
27292: LD_INT 16
27294: PUSH
27295: LD_INT 17
27297: PUSH
27298: LD_INT 18
27300: PUSH
27301: LD_INT 19
27303: PUSH
27304: LD_INT 20
27306: PUSH
27307: LD_INT 21
27309: PUSH
27310: EMPTY
27311: LIST
27312: LIST
27313: LIST
27314: LIST
27315: LIST
27316: LIST
27317: LIST
27318: LIST
27319: LIST
27320: LIST
27321: LIST
27322: LIST
27323: LIST
27324: IN
27325: NOT
27326: OR
27327: PUSH
27328: LD_VAR 0 8
27332: PUSH
27333: LD_INT 5
27335: ARRAY
27336: NOT
27337: OR
27338: PUSH
27339: LD_VAR 0 8
27343: PUSH
27344: LD_INT 6
27346: ARRAY
27347: PUSH
27348: LD_INT 1
27350: PUSH
27351: LD_INT 2
27353: PUSH
27354: LD_INT 7
27356: PUSH
27357: LD_INT 9
27359: PUSH
27360: LD_INT 10
27362: PUSH
27363: LD_INT 11
27365: PUSH
27366: EMPTY
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: LIST
27372: LIST
27373: IN
27374: NOT
27375: OR
27376: IFFALSE 27382
// exit ;
27378: POP
27379: POP
27380: GO 27480
// end ;
27382: GO 27053
27384: POP
27385: POP
// side := GetSide ( depot ) ;
27386: LD_ADDR_VAR 0 9
27390: PUSH
27391: LD_VAR 0 1
27395: PPUSH
27396: CALL_OW 255
27400: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27401: LD_VAR 0 9
27405: PPUSH
27406: LD_VAR 0 3
27410: PPUSH
27411: LD_VAR 0 4
27415: PPUSH
27416: LD_INT 20
27418: PPUSH
27419: CALL 20134 0 4
27423: PUSH
27424: LD_INT 4
27426: ARRAY
27427: IFFALSE 27431
// exit ;
27429: GO 27480
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27431: LD_VAR 0 2
27435: PUSH
27436: LD_INT 29
27438: PUSH
27439: LD_INT 30
27441: PUSH
27442: EMPTY
27443: LIST
27444: LIST
27445: IN
27446: PUSH
27447: LD_VAR 0 3
27451: PPUSH
27452: LD_VAR 0 4
27456: PPUSH
27457: LD_VAR 0 9
27461: PPUSH
27462: CALL_OW 440
27466: NOT
27467: AND
27468: IFFALSE 27472
// exit ;
27470: GO 27480
// result := true ;
27472: LD_ADDR_VAR 0 6
27476: PUSH
27477: LD_INT 1
27479: ST_TO_ADDR
// end ;
27480: LD_VAR 0 6
27484: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
27485: LD_INT 0
27487: PPUSH
27488: PPUSH
27489: PPUSH
27490: PPUSH
27491: PPUSH
27492: PPUSH
27493: PPUSH
27494: PPUSH
27495: PPUSH
27496: PPUSH
27497: PPUSH
27498: PPUSH
27499: PPUSH
27500: PPUSH
27501: PPUSH
27502: PPUSH
27503: PPUSH
27504: PPUSH
27505: PPUSH
27506: PPUSH
27507: PPUSH
27508: PPUSH
27509: PPUSH
27510: PPUSH
27511: PPUSH
27512: PPUSH
27513: PPUSH
27514: PPUSH
27515: PPUSH
27516: PPUSH
27517: PPUSH
27518: PPUSH
27519: PPUSH
27520: PPUSH
27521: PPUSH
27522: PPUSH
27523: PPUSH
27524: PPUSH
27525: PPUSH
27526: PPUSH
27527: PPUSH
27528: PPUSH
27529: PPUSH
27530: PPUSH
27531: PPUSH
27532: PPUSH
27533: PPUSH
27534: PPUSH
27535: PPUSH
27536: PPUSH
27537: PPUSH
27538: PPUSH
27539: PPUSH
27540: PPUSH
27541: PPUSH
27542: PPUSH
27543: PPUSH
27544: PPUSH
// result = [ ] ;
27545: LD_ADDR_VAR 0 7
27549: PUSH
27550: EMPTY
27551: ST_TO_ADDR
// temp_list = [ ] ;
27552: LD_ADDR_VAR 0 9
27556: PUSH
27557: EMPTY
27558: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27559: LD_VAR 0 4
27563: PUSH
27564: LD_INT 0
27566: PUSH
27567: LD_INT 1
27569: PUSH
27570: LD_INT 2
27572: PUSH
27573: LD_INT 3
27575: PUSH
27576: LD_INT 4
27578: PUSH
27579: LD_INT 5
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: LIST
27589: IN
27590: NOT
27591: PUSH
27592: LD_VAR 0 1
27596: PUSH
27597: LD_INT 0
27599: PUSH
27600: LD_INT 1
27602: PUSH
27603: EMPTY
27604: LIST
27605: LIST
27606: IN
27607: PUSH
27608: LD_VAR 0 5
27612: PUSH
27613: LD_INT 1
27615: PUSH
27616: LD_INT 2
27618: PUSH
27619: LD_INT 3
27621: PUSH
27622: EMPTY
27623: LIST
27624: LIST
27625: LIST
27626: IN
27627: NOT
27628: AND
27629: OR
27630: IFFALSE 27634
// exit ;
27632: GO 46025
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
27634: LD_VAR 0 1
27638: PUSH
27639: LD_INT 6
27641: PUSH
27642: LD_INT 7
27644: PUSH
27645: LD_INT 8
27647: PUSH
27648: LD_INT 13
27650: PUSH
27651: LD_INT 12
27653: PUSH
27654: LD_INT 15
27656: PUSH
27657: LD_INT 11
27659: PUSH
27660: LD_INT 14
27662: PUSH
27663: LD_INT 10
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: LIST
27670: LIST
27671: LIST
27672: LIST
27673: LIST
27674: LIST
27675: LIST
27676: IN
27677: IFFALSE 27687
// btype = b_lab ;
27679: LD_ADDR_VAR 0 1
27683: PUSH
27684: LD_INT 6
27686: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27687: LD_VAR 0 6
27691: PUSH
27692: LD_INT 0
27694: PUSH
27695: LD_INT 1
27697: PUSH
27698: LD_INT 2
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: LIST
27705: IN
27706: NOT
27707: PUSH
27708: LD_VAR 0 1
27712: PUSH
27713: LD_INT 0
27715: PUSH
27716: LD_INT 1
27718: PUSH
27719: LD_INT 2
27721: PUSH
27722: LD_INT 3
27724: PUSH
27725: LD_INT 6
27727: PUSH
27728: LD_INT 36
27730: PUSH
27731: LD_INT 4
27733: PUSH
27734: LD_INT 5
27736: PUSH
27737: LD_INT 31
27739: PUSH
27740: LD_INT 32
27742: PUSH
27743: LD_INT 33
27745: PUSH
27746: EMPTY
27747: LIST
27748: LIST
27749: LIST
27750: LIST
27751: LIST
27752: LIST
27753: LIST
27754: LIST
27755: LIST
27756: LIST
27757: LIST
27758: IN
27759: NOT
27760: PUSH
27761: LD_VAR 0 6
27765: PUSH
27766: LD_INT 1
27768: EQUAL
27769: AND
27770: OR
27771: PUSH
27772: LD_VAR 0 1
27776: PUSH
27777: LD_INT 2
27779: PUSH
27780: LD_INT 3
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: IN
27787: NOT
27788: PUSH
27789: LD_VAR 0 6
27793: PUSH
27794: LD_INT 2
27796: EQUAL
27797: AND
27798: OR
27799: IFFALSE 27809
// mode = 0 ;
27801: LD_ADDR_VAR 0 6
27805: PUSH
27806: LD_INT 0
27808: ST_TO_ADDR
// case mode of 0 :
27809: LD_VAR 0 6
27813: PUSH
27814: LD_INT 0
27816: DOUBLE
27817: EQUAL
27818: IFTRUE 27822
27820: GO 39275
27822: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27823: LD_ADDR_VAR 0 11
27827: PUSH
27828: LD_INT 0
27830: PUSH
27831: LD_INT 0
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: LD_INT 0
27840: PUSH
27841: LD_INT 1
27843: NEG
27844: PUSH
27845: EMPTY
27846: LIST
27847: LIST
27848: PUSH
27849: LD_INT 1
27851: PUSH
27852: LD_INT 0
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: PUSH
27859: LD_INT 1
27861: PUSH
27862: LD_INT 1
27864: PUSH
27865: EMPTY
27866: LIST
27867: LIST
27868: PUSH
27869: LD_INT 0
27871: PUSH
27872: LD_INT 1
27874: PUSH
27875: EMPTY
27876: LIST
27877: LIST
27878: PUSH
27879: LD_INT 1
27881: NEG
27882: PUSH
27883: LD_INT 0
27885: PUSH
27886: EMPTY
27887: LIST
27888: LIST
27889: PUSH
27890: LD_INT 1
27892: NEG
27893: PUSH
27894: LD_INT 1
27896: NEG
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: PUSH
27902: LD_INT 1
27904: NEG
27905: PUSH
27906: LD_INT 2
27908: NEG
27909: PUSH
27910: EMPTY
27911: LIST
27912: LIST
27913: PUSH
27914: LD_INT 0
27916: PUSH
27917: LD_INT 2
27919: NEG
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: PUSH
27925: LD_INT 1
27927: PUSH
27928: LD_INT 1
27930: NEG
27931: PUSH
27932: EMPTY
27933: LIST
27934: LIST
27935: PUSH
27936: LD_INT 1
27938: PUSH
27939: LD_INT 2
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: PUSH
27946: LD_INT 0
27948: PUSH
27949: LD_INT 2
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PUSH
27956: LD_INT 1
27958: NEG
27959: PUSH
27960: LD_INT 1
27962: PUSH
27963: EMPTY
27964: LIST
27965: LIST
27966: PUSH
27967: LD_INT 1
27969: PUSH
27970: LD_INT 3
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: PUSH
27977: LD_INT 0
27979: PUSH
27980: LD_INT 3
27982: PUSH
27983: EMPTY
27984: LIST
27985: LIST
27986: PUSH
27987: LD_INT 1
27989: NEG
27990: PUSH
27991: LD_INT 2
27993: PUSH
27994: EMPTY
27995: LIST
27996: LIST
27997: PUSH
27998: EMPTY
27999: LIST
28000: LIST
28001: LIST
28002: LIST
28003: LIST
28004: LIST
28005: LIST
28006: LIST
28007: LIST
28008: LIST
28009: LIST
28010: LIST
28011: LIST
28012: LIST
28013: LIST
28014: LIST
28015: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28016: LD_ADDR_VAR 0 12
28020: PUSH
28021: LD_INT 0
28023: PUSH
28024: LD_INT 0
28026: PUSH
28027: EMPTY
28028: LIST
28029: LIST
28030: PUSH
28031: LD_INT 0
28033: PUSH
28034: LD_INT 1
28036: NEG
28037: PUSH
28038: EMPTY
28039: LIST
28040: LIST
28041: PUSH
28042: LD_INT 1
28044: PUSH
28045: LD_INT 0
28047: PUSH
28048: EMPTY
28049: LIST
28050: LIST
28051: PUSH
28052: LD_INT 1
28054: PUSH
28055: LD_INT 1
28057: PUSH
28058: EMPTY
28059: LIST
28060: LIST
28061: PUSH
28062: LD_INT 0
28064: PUSH
28065: LD_INT 1
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: PUSH
28072: LD_INT 1
28074: NEG
28075: PUSH
28076: LD_INT 0
28078: PUSH
28079: EMPTY
28080: LIST
28081: LIST
28082: PUSH
28083: LD_INT 1
28085: NEG
28086: PUSH
28087: LD_INT 1
28089: NEG
28090: PUSH
28091: EMPTY
28092: LIST
28093: LIST
28094: PUSH
28095: LD_INT 1
28097: PUSH
28098: LD_INT 1
28100: NEG
28101: PUSH
28102: EMPTY
28103: LIST
28104: LIST
28105: PUSH
28106: LD_INT 2
28108: PUSH
28109: LD_INT 0
28111: PUSH
28112: EMPTY
28113: LIST
28114: LIST
28115: PUSH
28116: LD_INT 2
28118: PUSH
28119: LD_INT 1
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 1
28128: NEG
28129: PUSH
28130: LD_INT 1
28132: PUSH
28133: EMPTY
28134: LIST
28135: LIST
28136: PUSH
28137: LD_INT 2
28139: NEG
28140: PUSH
28141: LD_INT 0
28143: PUSH
28144: EMPTY
28145: LIST
28146: LIST
28147: PUSH
28148: LD_INT 2
28150: NEG
28151: PUSH
28152: LD_INT 1
28154: NEG
28155: PUSH
28156: EMPTY
28157: LIST
28158: LIST
28159: PUSH
28160: LD_INT 2
28162: NEG
28163: PUSH
28164: LD_INT 1
28166: PUSH
28167: EMPTY
28168: LIST
28169: LIST
28170: PUSH
28171: LD_INT 3
28173: NEG
28174: PUSH
28175: LD_INT 0
28177: PUSH
28178: EMPTY
28179: LIST
28180: LIST
28181: PUSH
28182: LD_INT 3
28184: NEG
28185: PUSH
28186: LD_INT 1
28188: NEG
28189: PUSH
28190: EMPTY
28191: LIST
28192: LIST
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: LIST
28198: LIST
28199: LIST
28200: LIST
28201: LIST
28202: LIST
28203: LIST
28204: LIST
28205: LIST
28206: LIST
28207: LIST
28208: LIST
28209: LIST
28210: LIST
28211: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28212: LD_ADDR_VAR 0 13
28216: PUSH
28217: LD_INT 0
28219: PUSH
28220: LD_INT 0
28222: PUSH
28223: EMPTY
28224: LIST
28225: LIST
28226: PUSH
28227: LD_INT 0
28229: PUSH
28230: LD_INT 1
28232: NEG
28233: PUSH
28234: EMPTY
28235: LIST
28236: LIST
28237: PUSH
28238: LD_INT 1
28240: PUSH
28241: LD_INT 0
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PUSH
28248: LD_INT 1
28250: PUSH
28251: LD_INT 1
28253: PUSH
28254: EMPTY
28255: LIST
28256: LIST
28257: PUSH
28258: LD_INT 0
28260: PUSH
28261: LD_INT 1
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PUSH
28268: LD_INT 1
28270: NEG
28271: PUSH
28272: LD_INT 0
28274: PUSH
28275: EMPTY
28276: LIST
28277: LIST
28278: PUSH
28279: LD_INT 1
28281: NEG
28282: PUSH
28283: LD_INT 1
28285: NEG
28286: PUSH
28287: EMPTY
28288: LIST
28289: LIST
28290: PUSH
28291: LD_INT 1
28293: NEG
28294: PUSH
28295: LD_INT 2
28297: NEG
28298: PUSH
28299: EMPTY
28300: LIST
28301: LIST
28302: PUSH
28303: LD_INT 2
28305: PUSH
28306: LD_INT 1
28308: PUSH
28309: EMPTY
28310: LIST
28311: LIST
28312: PUSH
28313: LD_INT 2
28315: PUSH
28316: LD_INT 2
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PUSH
28323: LD_INT 1
28325: PUSH
28326: LD_INT 2
28328: PUSH
28329: EMPTY
28330: LIST
28331: LIST
28332: PUSH
28333: LD_INT 2
28335: NEG
28336: PUSH
28337: LD_INT 1
28339: NEG
28340: PUSH
28341: EMPTY
28342: LIST
28343: LIST
28344: PUSH
28345: LD_INT 2
28347: NEG
28348: PUSH
28349: LD_INT 2
28351: NEG
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: PUSH
28357: LD_INT 2
28359: NEG
28360: PUSH
28361: LD_INT 3
28363: NEG
28364: PUSH
28365: EMPTY
28366: LIST
28367: LIST
28368: PUSH
28369: LD_INT 3
28371: NEG
28372: PUSH
28373: LD_INT 2
28375: NEG
28376: PUSH
28377: EMPTY
28378: LIST
28379: LIST
28380: PUSH
28381: LD_INT 3
28383: NEG
28384: PUSH
28385: LD_INT 3
28387: NEG
28388: PUSH
28389: EMPTY
28390: LIST
28391: LIST
28392: PUSH
28393: EMPTY
28394: LIST
28395: LIST
28396: LIST
28397: LIST
28398: LIST
28399: LIST
28400: LIST
28401: LIST
28402: LIST
28403: LIST
28404: LIST
28405: LIST
28406: LIST
28407: LIST
28408: LIST
28409: LIST
28410: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28411: LD_ADDR_VAR 0 14
28415: PUSH
28416: LD_INT 0
28418: PUSH
28419: LD_INT 0
28421: PUSH
28422: EMPTY
28423: LIST
28424: LIST
28425: PUSH
28426: LD_INT 0
28428: PUSH
28429: LD_INT 1
28431: NEG
28432: PUSH
28433: EMPTY
28434: LIST
28435: LIST
28436: PUSH
28437: LD_INT 1
28439: PUSH
28440: LD_INT 0
28442: PUSH
28443: EMPTY
28444: LIST
28445: LIST
28446: PUSH
28447: LD_INT 1
28449: PUSH
28450: LD_INT 1
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: PUSH
28457: LD_INT 0
28459: PUSH
28460: LD_INT 1
28462: PUSH
28463: EMPTY
28464: LIST
28465: LIST
28466: PUSH
28467: LD_INT 1
28469: NEG
28470: PUSH
28471: LD_INT 0
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: LD_INT 1
28480: NEG
28481: PUSH
28482: LD_INT 1
28484: NEG
28485: PUSH
28486: EMPTY
28487: LIST
28488: LIST
28489: PUSH
28490: LD_INT 1
28492: NEG
28493: PUSH
28494: LD_INT 2
28496: NEG
28497: PUSH
28498: EMPTY
28499: LIST
28500: LIST
28501: PUSH
28502: LD_INT 0
28504: PUSH
28505: LD_INT 2
28507: NEG
28508: PUSH
28509: EMPTY
28510: LIST
28511: LIST
28512: PUSH
28513: LD_INT 1
28515: PUSH
28516: LD_INT 1
28518: NEG
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: PUSH
28524: LD_INT 1
28526: PUSH
28527: LD_INT 2
28529: PUSH
28530: EMPTY
28531: LIST
28532: LIST
28533: PUSH
28534: LD_INT 0
28536: PUSH
28537: LD_INT 2
28539: PUSH
28540: EMPTY
28541: LIST
28542: LIST
28543: PUSH
28544: LD_INT 1
28546: NEG
28547: PUSH
28548: LD_INT 1
28550: PUSH
28551: EMPTY
28552: LIST
28553: LIST
28554: PUSH
28555: LD_INT 1
28557: NEG
28558: PUSH
28559: LD_INT 3
28561: NEG
28562: PUSH
28563: EMPTY
28564: LIST
28565: LIST
28566: PUSH
28567: LD_INT 0
28569: PUSH
28570: LD_INT 3
28572: NEG
28573: PUSH
28574: EMPTY
28575: LIST
28576: LIST
28577: PUSH
28578: LD_INT 1
28580: PUSH
28581: LD_INT 2
28583: NEG
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: LIST
28593: LIST
28594: LIST
28595: LIST
28596: LIST
28597: LIST
28598: LIST
28599: LIST
28600: LIST
28601: LIST
28602: LIST
28603: LIST
28604: LIST
28605: LIST
28606: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28607: LD_ADDR_VAR 0 15
28611: PUSH
28612: LD_INT 0
28614: PUSH
28615: LD_INT 0
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: PUSH
28622: LD_INT 0
28624: PUSH
28625: LD_INT 1
28627: NEG
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: PUSH
28633: LD_INT 1
28635: PUSH
28636: LD_INT 0
28638: PUSH
28639: EMPTY
28640: LIST
28641: LIST
28642: PUSH
28643: LD_INT 1
28645: PUSH
28646: LD_INT 1
28648: PUSH
28649: EMPTY
28650: LIST
28651: LIST
28652: PUSH
28653: LD_INT 0
28655: PUSH
28656: LD_INT 1
28658: PUSH
28659: EMPTY
28660: LIST
28661: LIST
28662: PUSH
28663: LD_INT 1
28665: NEG
28666: PUSH
28667: LD_INT 0
28669: PUSH
28670: EMPTY
28671: LIST
28672: LIST
28673: PUSH
28674: LD_INT 1
28676: NEG
28677: PUSH
28678: LD_INT 1
28680: NEG
28681: PUSH
28682: EMPTY
28683: LIST
28684: LIST
28685: PUSH
28686: LD_INT 1
28688: PUSH
28689: LD_INT 1
28691: NEG
28692: PUSH
28693: EMPTY
28694: LIST
28695: LIST
28696: PUSH
28697: LD_INT 2
28699: PUSH
28700: LD_INT 0
28702: PUSH
28703: EMPTY
28704: LIST
28705: LIST
28706: PUSH
28707: LD_INT 2
28709: PUSH
28710: LD_INT 1
28712: PUSH
28713: EMPTY
28714: LIST
28715: LIST
28716: PUSH
28717: LD_INT 1
28719: NEG
28720: PUSH
28721: LD_INT 1
28723: PUSH
28724: EMPTY
28725: LIST
28726: LIST
28727: PUSH
28728: LD_INT 2
28730: NEG
28731: PUSH
28732: LD_INT 0
28734: PUSH
28735: EMPTY
28736: LIST
28737: LIST
28738: PUSH
28739: LD_INT 2
28741: NEG
28742: PUSH
28743: LD_INT 1
28745: NEG
28746: PUSH
28747: EMPTY
28748: LIST
28749: LIST
28750: PUSH
28751: LD_INT 2
28753: PUSH
28754: LD_INT 1
28756: NEG
28757: PUSH
28758: EMPTY
28759: LIST
28760: LIST
28761: PUSH
28762: LD_INT 3
28764: PUSH
28765: LD_INT 0
28767: PUSH
28768: EMPTY
28769: LIST
28770: LIST
28771: PUSH
28772: LD_INT 3
28774: PUSH
28775: LD_INT 1
28777: PUSH
28778: EMPTY
28779: LIST
28780: LIST
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: LIST
28786: LIST
28787: LIST
28788: LIST
28789: LIST
28790: LIST
28791: LIST
28792: LIST
28793: LIST
28794: LIST
28795: LIST
28796: LIST
28797: LIST
28798: LIST
28799: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28800: LD_ADDR_VAR 0 16
28804: PUSH
28805: LD_INT 0
28807: PUSH
28808: LD_INT 0
28810: PUSH
28811: EMPTY
28812: LIST
28813: LIST
28814: PUSH
28815: LD_INT 0
28817: PUSH
28818: LD_INT 1
28820: NEG
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: PUSH
28826: LD_INT 1
28828: PUSH
28829: LD_INT 0
28831: PUSH
28832: EMPTY
28833: LIST
28834: LIST
28835: PUSH
28836: LD_INT 1
28838: PUSH
28839: LD_INT 1
28841: PUSH
28842: EMPTY
28843: LIST
28844: LIST
28845: PUSH
28846: LD_INT 0
28848: PUSH
28849: LD_INT 1
28851: PUSH
28852: EMPTY
28853: LIST
28854: LIST
28855: PUSH
28856: LD_INT 1
28858: NEG
28859: PUSH
28860: LD_INT 0
28862: PUSH
28863: EMPTY
28864: LIST
28865: LIST
28866: PUSH
28867: LD_INT 1
28869: NEG
28870: PUSH
28871: LD_INT 1
28873: NEG
28874: PUSH
28875: EMPTY
28876: LIST
28877: LIST
28878: PUSH
28879: LD_INT 1
28881: NEG
28882: PUSH
28883: LD_INT 2
28885: NEG
28886: PUSH
28887: EMPTY
28888: LIST
28889: LIST
28890: PUSH
28891: LD_INT 2
28893: PUSH
28894: LD_INT 1
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: PUSH
28901: LD_INT 2
28903: PUSH
28904: LD_INT 2
28906: PUSH
28907: EMPTY
28908: LIST
28909: LIST
28910: PUSH
28911: LD_INT 1
28913: PUSH
28914: LD_INT 2
28916: PUSH
28917: EMPTY
28918: LIST
28919: LIST
28920: PUSH
28921: LD_INT 2
28923: NEG
28924: PUSH
28925: LD_INT 1
28927: NEG
28928: PUSH
28929: EMPTY
28930: LIST
28931: LIST
28932: PUSH
28933: LD_INT 2
28935: NEG
28936: PUSH
28937: LD_INT 2
28939: NEG
28940: PUSH
28941: EMPTY
28942: LIST
28943: LIST
28944: PUSH
28945: LD_INT 3
28947: PUSH
28948: LD_INT 2
28950: PUSH
28951: EMPTY
28952: LIST
28953: LIST
28954: PUSH
28955: LD_INT 3
28957: PUSH
28958: LD_INT 3
28960: PUSH
28961: EMPTY
28962: LIST
28963: LIST
28964: PUSH
28965: LD_INT 2
28967: PUSH
28968: LD_INT 3
28970: PUSH
28971: EMPTY
28972: LIST
28973: LIST
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: LIST
28979: LIST
28980: LIST
28981: LIST
28982: LIST
28983: LIST
28984: LIST
28985: LIST
28986: LIST
28987: LIST
28988: LIST
28989: LIST
28990: LIST
28991: LIST
28992: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28993: LD_ADDR_VAR 0 17
28997: PUSH
28998: LD_INT 0
29000: PUSH
29001: LD_INT 0
29003: PUSH
29004: EMPTY
29005: LIST
29006: LIST
29007: PUSH
29008: LD_INT 0
29010: PUSH
29011: LD_INT 1
29013: NEG
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: PUSH
29019: LD_INT 1
29021: PUSH
29022: LD_INT 0
29024: PUSH
29025: EMPTY
29026: LIST
29027: LIST
29028: PUSH
29029: LD_INT 1
29031: PUSH
29032: LD_INT 1
29034: PUSH
29035: EMPTY
29036: LIST
29037: LIST
29038: PUSH
29039: LD_INT 0
29041: PUSH
29042: LD_INT 1
29044: PUSH
29045: EMPTY
29046: LIST
29047: LIST
29048: PUSH
29049: LD_INT 1
29051: NEG
29052: PUSH
29053: LD_INT 0
29055: PUSH
29056: EMPTY
29057: LIST
29058: LIST
29059: PUSH
29060: LD_INT 1
29062: NEG
29063: PUSH
29064: LD_INT 1
29066: NEG
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 1
29074: NEG
29075: PUSH
29076: LD_INT 2
29078: NEG
29079: PUSH
29080: EMPTY
29081: LIST
29082: LIST
29083: PUSH
29084: LD_INT 0
29086: PUSH
29087: LD_INT 2
29089: NEG
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: PUSH
29095: LD_INT 1
29097: PUSH
29098: LD_INT 1
29100: NEG
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 2
29108: PUSH
29109: LD_INT 0
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: LD_INT 2
29118: PUSH
29119: LD_INT 1
29121: PUSH
29122: EMPTY
29123: LIST
29124: LIST
29125: PUSH
29126: LD_INT 2
29128: PUSH
29129: LD_INT 2
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: PUSH
29136: LD_INT 1
29138: PUSH
29139: LD_INT 2
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PUSH
29146: LD_INT 0
29148: PUSH
29149: LD_INT 2
29151: PUSH
29152: EMPTY
29153: LIST
29154: LIST
29155: PUSH
29156: LD_INT 1
29158: NEG
29159: PUSH
29160: LD_INT 1
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: PUSH
29167: LD_INT 2
29169: NEG
29170: PUSH
29171: LD_INT 0
29173: PUSH
29174: EMPTY
29175: LIST
29176: LIST
29177: PUSH
29178: LD_INT 2
29180: NEG
29181: PUSH
29182: LD_INT 1
29184: NEG
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: LD_INT 2
29192: NEG
29193: PUSH
29194: LD_INT 2
29196: NEG
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: LIST
29220: LIST
29221: LIST
29222: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29223: LD_ADDR_VAR 0 18
29227: PUSH
29228: LD_INT 0
29230: PUSH
29231: LD_INT 0
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 0
29240: PUSH
29241: LD_INT 1
29243: NEG
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: PUSH
29249: LD_INT 1
29251: PUSH
29252: LD_INT 0
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: PUSH
29259: LD_INT 1
29261: PUSH
29262: LD_INT 1
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 0
29271: PUSH
29272: LD_INT 1
29274: PUSH
29275: EMPTY
29276: LIST
29277: LIST
29278: PUSH
29279: LD_INT 1
29281: NEG
29282: PUSH
29283: LD_INT 0
29285: PUSH
29286: EMPTY
29287: LIST
29288: LIST
29289: PUSH
29290: LD_INT 1
29292: NEG
29293: PUSH
29294: LD_INT 1
29296: NEG
29297: PUSH
29298: EMPTY
29299: LIST
29300: LIST
29301: PUSH
29302: LD_INT 1
29304: NEG
29305: PUSH
29306: LD_INT 2
29308: NEG
29309: PUSH
29310: EMPTY
29311: LIST
29312: LIST
29313: PUSH
29314: LD_INT 0
29316: PUSH
29317: LD_INT 2
29319: NEG
29320: PUSH
29321: EMPTY
29322: LIST
29323: LIST
29324: PUSH
29325: LD_INT 1
29327: PUSH
29328: LD_INT 1
29330: NEG
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 2
29338: PUSH
29339: LD_INT 0
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: LD_INT 2
29348: PUSH
29349: LD_INT 1
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 2
29358: PUSH
29359: LD_INT 2
29361: PUSH
29362: EMPTY
29363: LIST
29364: LIST
29365: PUSH
29366: LD_INT 1
29368: PUSH
29369: LD_INT 2
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PUSH
29376: LD_INT 0
29378: PUSH
29379: LD_INT 2
29381: PUSH
29382: EMPTY
29383: LIST
29384: LIST
29385: PUSH
29386: LD_INT 1
29388: NEG
29389: PUSH
29390: LD_INT 1
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: PUSH
29397: LD_INT 2
29399: NEG
29400: PUSH
29401: LD_INT 0
29403: PUSH
29404: EMPTY
29405: LIST
29406: LIST
29407: PUSH
29408: LD_INT 2
29410: NEG
29411: PUSH
29412: LD_INT 1
29414: NEG
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 2
29422: NEG
29423: PUSH
29424: LD_INT 2
29426: NEG
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: LIST
29436: LIST
29437: LIST
29438: LIST
29439: LIST
29440: LIST
29441: LIST
29442: LIST
29443: LIST
29444: LIST
29445: LIST
29446: LIST
29447: LIST
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29453: LD_ADDR_VAR 0 19
29457: PUSH
29458: LD_INT 0
29460: PUSH
29461: LD_INT 0
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: PUSH
29468: LD_INT 0
29470: PUSH
29471: LD_INT 1
29473: NEG
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 1
29481: PUSH
29482: LD_INT 0
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: LD_INT 1
29491: PUSH
29492: LD_INT 1
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 0
29501: PUSH
29502: LD_INT 1
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: PUSH
29509: LD_INT 1
29511: NEG
29512: PUSH
29513: LD_INT 0
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: LD_INT 1
29522: NEG
29523: PUSH
29524: LD_INT 1
29526: NEG
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: LD_INT 1
29534: NEG
29535: PUSH
29536: LD_INT 2
29538: NEG
29539: PUSH
29540: EMPTY
29541: LIST
29542: LIST
29543: PUSH
29544: LD_INT 0
29546: PUSH
29547: LD_INT 2
29549: NEG
29550: PUSH
29551: EMPTY
29552: LIST
29553: LIST
29554: PUSH
29555: LD_INT 1
29557: PUSH
29558: LD_INT 1
29560: NEG
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 2
29568: PUSH
29569: LD_INT 0
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 2
29578: PUSH
29579: LD_INT 1
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 2
29588: PUSH
29589: LD_INT 2
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: LD_INT 1
29598: PUSH
29599: LD_INT 2
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: PUSH
29606: LD_INT 0
29608: PUSH
29609: LD_INT 2
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PUSH
29616: LD_INT 1
29618: NEG
29619: PUSH
29620: LD_INT 1
29622: PUSH
29623: EMPTY
29624: LIST
29625: LIST
29626: PUSH
29627: LD_INT 2
29629: NEG
29630: PUSH
29631: LD_INT 0
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: PUSH
29638: LD_INT 2
29640: NEG
29641: PUSH
29642: LD_INT 1
29644: NEG
29645: PUSH
29646: EMPTY
29647: LIST
29648: LIST
29649: PUSH
29650: LD_INT 2
29652: NEG
29653: PUSH
29654: LD_INT 2
29656: NEG
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PUSH
29662: EMPTY
29663: LIST
29664: LIST
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: LIST
29670: LIST
29671: LIST
29672: LIST
29673: LIST
29674: LIST
29675: LIST
29676: LIST
29677: LIST
29678: LIST
29679: LIST
29680: LIST
29681: LIST
29682: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29683: LD_ADDR_VAR 0 20
29687: PUSH
29688: LD_INT 0
29690: PUSH
29691: LD_INT 0
29693: PUSH
29694: EMPTY
29695: LIST
29696: LIST
29697: PUSH
29698: LD_INT 0
29700: PUSH
29701: LD_INT 1
29703: NEG
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 1
29711: PUSH
29712: LD_INT 0
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 1
29721: PUSH
29722: LD_INT 1
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: LD_INT 0
29731: PUSH
29732: LD_INT 1
29734: PUSH
29735: EMPTY
29736: LIST
29737: LIST
29738: PUSH
29739: LD_INT 1
29741: NEG
29742: PUSH
29743: LD_INT 0
29745: PUSH
29746: EMPTY
29747: LIST
29748: LIST
29749: PUSH
29750: LD_INT 1
29752: NEG
29753: PUSH
29754: LD_INT 1
29756: NEG
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 1
29764: NEG
29765: PUSH
29766: LD_INT 2
29768: NEG
29769: PUSH
29770: EMPTY
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 0
29776: PUSH
29777: LD_INT 2
29779: NEG
29780: PUSH
29781: EMPTY
29782: LIST
29783: LIST
29784: PUSH
29785: LD_INT 1
29787: PUSH
29788: LD_INT 1
29790: NEG
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 2
29798: PUSH
29799: LD_INT 0
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 2
29808: PUSH
29809: LD_INT 1
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 2
29818: PUSH
29819: LD_INT 2
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 1
29828: PUSH
29829: LD_INT 2
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 0
29838: PUSH
29839: LD_INT 2
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: PUSH
29846: LD_INT 1
29848: NEG
29849: PUSH
29850: LD_INT 1
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PUSH
29857: LD_INT 2
29859: NEG
29860: PUSH
29861: LD_INT 0
29863: PUSH
29864: EMPTY
29865: LIST
29866: LIST
29867: PUSH
29868: LD_INT 2
29870: NEG
29871: PUSH
29872: LD_INT 1
29874: NEG
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: PUSH
29880: LD_INT 2
29882: NEG
29883: PUSH
29884: LD_INT 2
29886: NEG
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: EMPTY
29893: LIST
29894: LIST
29895: LIST
29896: LIST
29897: LIST
29898: LIST
29899: LIST
29900: LIST
29901: LIST
29902: LIST
29903: LIST
29904: LIST
29905: LIST
29906: LIST
29907: LIST
29908: LIST
29909: LIST
29910: LIST
29911: LIST
29912: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29913: LD_ADDR_VAR 0 21
29917: PUSH
29918: LD_INT 0
29920: PUSH
29921: LD_INT 0
29923: PUSH
29924: EMPTY
29925: LIST
29926: LIST
29927: PUSH
29928: LD_INT 0
29930: PUSH
29931: LD_INT 1
29933: NEG
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PUSH
29939: LD_INT 1
29941: PUSH
29942: LD_INT 0
29944: PUSH
29945: EMPTY
29946: LIST
29947: LIST
29948: PUSH
29949: LD_INT 1
29951: PUSH
29952: LD_INT 1
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PUSH
29959: LD_INT 0
29961: PUSH
29962: LD_INT 1
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: LD_INT 1
29971: NEG
29972: PUSH
29973: LD_INT 0
29975: PUSH
29976: EMPTY
29977: LIST
29978: LIST
29979: PUSH
29980: LD_INT 1
29982: NEG
29983: PUSH
29984: LD_INT 1
29986: NEG
29987: PUSH
29988: EMPTY
29989: LIST
29990: LIST
29991: PUSH
29992: LD_INT 1
29994: NEG
29995: PUSH
29996: LD_INT 2
29998: NEG
29999: PUSH
30000: EMPTY
30001: LIST
30002: LIST
30003: PUSH
30004: LD_INT 0
30006: PUSH
30007: LD_INT 2
30009: NEG
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: PUSH
30015: LD_INT 1
30017: PUSH
30018: LD_INT 1
30020: NEG
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: LD_INT 2
30028: PUSH
30029: LD_INT 0
30031: PUSH
30032: EMPTY
30033: LIST
30034: LIST
30035: PUSH
30036: LD_INT 2
30038: PUSH
30039: LD_INT 1
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: PUSH
30046: LD_INT 2
30048: PUSH
30049: LD_INT 2
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: PUSH
30056: LD_INT 1
30058: PUSH
30059: LD_INT 2
30061: PUSH
30062: EMPTY
30063: LIST
30064: LIST
30065: PUSH
30066: LD_INT 0
30068: PUSH
30069: LD_INT 2
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: LD_INT 1
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: PUSH
30087: LD_INT 2
30089: NEG
30090: PUSH
30091: LD_INT 0
30093: PUSH
30094: EMPTY
30095: LIST
30096: LIST
30097: PUSH
30098: LD_INT 2
30100: NEG
30101: PUSH
30102: LD_INT 1
30104: NEG
30105: PUSH
30106: EMPTY
30107: LIST
30108: LIST
30109: PUSH
30110: LD_INT 2
30112: NEG
30113: PUSH
30114: LD_INT 2
30116: NEG
30117: PUSH
30118: EMPTY
30119: LIST
30120: LIST
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: LIST
30126: LIST
30127: LIST
30128: LIST
30129: LIST
30130: LIST
30131: LIST
30132: LIST
30133: LIST
30134: LIST
30135: LIST
30136: LIST
30137: LIST
30138: LIST
30139: LIST
30140: LIST
30141: LIST
30142: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30143: LD_ADDR_VAR 0 22
30147: PUSH
30148: LD_INT 0
30150: PUSH
30151: LD_INT 0
30153: PUSH
30154: EMPTY
30155: LIST
30156: LIST
30157: PUSH
30158: LD_INT 0
30160: PUSH
30161: LD_INT 1
30163: NEG
30164: PUSH
30165: EMPTY
30166: LIST
30167: LIST
30168: PUSH
30169: LD_INT 1
30171: PUSH
30172: LD_INT 0
30174: PUSH
30175: EMPTY
30176: LIST
30177: LIST
30178: PUSH
30179: LD_INT 1
30181: PUSH
30182: LD_INT 1
30184: PUSH
30185: EMPTY
30186: LIST
30187: LIST
30188: PUSH
30189: LD_INT 0
30191: PUSH
30192: LD_INT 1
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: PUSH
30199: LD_INT 1
30201: NEG
30202: PUSH
30203: LD_INT 0
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 1
30212: NEG
30213: PUSH
30214: LD_INT 1
30216: NEG
30217: PUSH
30218: EMPTY
30219: LIST
30220: LIST
30221: PUSH
30222: LD_INT 1
30224: NEG
30225: PUSH
30226: LD_INT 2
30228: NEG
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: PUSH
30234: LD_INT 0
30236: PUSH
30237: LD_INT 2
30239: NEG
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 1
30247: PUSH
30248: LD_INT 1
30250: NEG
30251: PUSH
30252: EMPTY
30253: LIST
30254: LIST
30255: PUSH
30256: LD_INT 2
30258: PUSH
30259: LD_INT 0
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: LD_INT 2
30268: PUSH
30269: LD_INT 1
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 2
30278: PUSH
30279: LD_INT 2
30281: PUSH
30282: EMPTY
30283: LIST
30284: LIST
30285: PUSH
30286: LD_INT 1
30288: PUSH
30289: LD_INT 2
30291: PUSH
30292: EMPTY
30293: LIST
30294: LIST
30295: PUSH
30296: LD_INT 0
30298: PUSH
30299: LD_INT 2
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: PUSH
30306: LD_INT 1
30308: NEG
30309: PUSH
30310: LD_INT 1
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: PUSH
30317: LD_INT 2
30319: NEG
30320: PUSH
30321: LD_INT 0
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: PUSH
30328: LD_INT 2
30330: NEG
30331: PUSH
30332: LD_INT 1
30334: NEG
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PUSH
30340: LD_INT 2
30342: NEG
30343: PUSH
30344: LD_INT 2
30346: NEG
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: LIST
30368: LIST
30369: LIST
30370: LIST
30371: LIST
30372: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30373: LD_ADDR_VAR 0 23
30377: PUSH
30378: LD_INT 0
30380: PUSH
30381: LD_INT 0
30383: PUSH
30384: EMPTY
30385: LIST
30386: LIST
30387: PUSH
30388: LD_INT 0
30390: PUSH
30391: LD_INT 1
30393: NEG
30394: PUSH
30395: EMPTY
30396: LIST
30397: LIST
30398: PUSH
30399: LD_INT 1
30401: PUSH
30402: LD_INT 0
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: LD_INT 1
30411: PUSH
30412: LD_INT 1
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 0
30421: PUSH
30422: LD_INT 1
30424: PUSH
30425: EMPTY
30426: LIST
30427: LIST
30428: PUSH
30429: LD_INT 1
30431: NEG
30432: PUSH
30433: LD_INT 0
30435: PUSH
30436: EMPTY
30437: LIST
30438: LIST
30439: PUSH
30440: LD_INT 1
30442: NEG
30443: PUSH
30444: LD_INT 1
30446: NEG
30447: PUSH
30448: EMPTY
30449: LIST
30450: LIST
30451: PUSH
30452: LD_INT 1
30454: NEG
30455: PUSH
30456: LD_INT 2
30458: NEG
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: PUSH
30464: LD_INT 0
30466: PUSH
30467: LD_INT 2
30469: NEG
30470: PUSH
30471: EMPTY
30472: LIST
30473: LIST
30474: PUSH
30475: LD_INT 1
30477: PUSH
30478: LD_INT 1
30480: NEG
30481: PUSH
30482: EMPTY
30483: LIST
30484: LIST
30485: PUSH
30486: LD_INT 2
30488: PUSH
30489: LD_INT 0
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: PUSH
30496: LD_INT 2
30498: PUSH
30499: LD_INT 1
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 2
30508: PUSH
30509: LD_INT 2
30511: PUSH
30512: EMPTY
30513: LIST
30514: LIST
30515: PUSH
30516: LD_INT 1
30518: PUSH
30519: LD_INT 2
30521: PUSH
30522: EMPTY
30523: LIST
30524: LIST
30525: PUSH
30526: LD_INT 0
30528: PUSH
30529: LD_INT 2
30531: PUSH
30532: EMPTY
30533: LIST
30534: LIST
30535: PUSH
30536: LD_INT 1
30538: NEG
30539: PUSH
30540: LD_INT 1
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: LD_INT 2
30549: NEG
30550: PUSH
30551: LD_INT 0
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: LD_INT 2
30560: NEG
30561: PUSH
30562: LD_INT 1
30564: NEG
30565: PUSH
30566: EMPTY
30567: LIST
30568: LIST
30569: PUSH
30570: LD_INT 2
30572: NEG
30573: PUSH
30574: LD_INT 2
30576: NEG
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 2
30584: NEG
30585: PUSH
30586: LD_INT 3
30588: NEG
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 1
30596: NEG
30597: PUSH
30598: LD_INT 3
30600: NEG
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 1
30608: PUSH
30609: LD_INT 2
30611: NEG
30612: PUSH
30613: EMPTY
30614: LIST
30615: LIST
30616: PUSH
30617: LD_INT 2
30619: PUSH
30620: LD_INT 1
30622: NEG
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: EMPTY
30629: LIST
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: LIST
30635: LIST
30636: LIST
30637: LIST
30638: LIST
30639: LIST
30640: LIST
30641: LIST
30642: LIST
30643: LIST
30644: LIST
30645: LIST
30646: LIST
30647: LIST
30648: LIST
30649: LIST
30650: LIST
30651: LIST
30652: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
30653: LD_ADDR_VAR 0 24
30657: PUSH
30658: LD_INT 0
30660: PUSH
30661: LD_INT 0
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: PUSH
30668: LD_INT 0
30670: PUSH
30671: LD_INT 1
30673: NEG
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: PUSH
30679: LD_INT 1
30681: PUSH
30682: LD_INT 0
30684: PUSH
30685: EMPTY
30686: LIST
30687: LIST
30688: PUSH
30689: LD_INT 1
30691: PUSH
30692: LD_INT 1
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: LD_INT 0
30701: PUSH
30702: LD_INT 1
30704: PUSH
30705: EMPTY
30706: LIST
30707: LIST
30708: PUSH
30709: LD_INT 1
30711: NEG
30712: PUSH
30713: LD_INT 0
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: PUSH
30720: LD_INT 1
30722: NEG
30723: PUSH
30724: LD_INT 1
30726: NEG
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 1
30734: NEG
30735: PUSH
30736: LD_INT 2
30738: NEG
30739: PUSH
30740: EMPTY
30741: LIST
30742: LIST
30743: PUSH
30744: LD_INT 0
30746: PUSH
30747: LD_INT 2
30749: NEG
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: LD_INT 1
30757: PUSH
30758: LD_INT 1
30760: NEG
30761: PUSH
30762: EMPTY
30763: LIST
30764: LIST
30765: PUSH
30766: LD_INT 2
30768: PUSH
30769: LD_INT 0
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: PUSH
30776: LD_INT 2
30778: PUSH
30779: LD_INT 1
30781: PUSH
30782: EMPTY
30783: LIST
30784: LIST
30785: PUSH
30786: LD_INT 2
30788: PUSH
30789: LD_INT 2
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 1
30798: PUSH
30799: LD_INT 2
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: PUSH
30806: LD_INT 0
30808: PUSH
30809: LD_INT 2
30811: PUSH
30812: EMPTY
30813: LIST
30814: LIST
30815: PUSH
30816: LD_INT 1
30818: NEG
30819: PUSH
30820: LD_INT 1
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: LD_INT 2
30829: NEG
30830: PUSH
30831: LD_INT 0
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: LD_INT 2
30840: NEG
30841: PUSH
30842: LD_INT 1
30844: NEG
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 2
30852: NEG
30853: PUSH
30854: LD_INT 2
30856: NEG
30857: PUSH
30858: EMPTY
30859: LIST
30860: LIST
30861: PUSH
30862: LD_INT 1
30864: PUSH
30865: LD_INT 2
30867: NEG
30868: PUSH
30869: EMPTY
30870: LIST
30871: LIST
30872: PUSH
30873: LD_INT 2
30875: PUSH
30876: LD_INT 1
30878: NEG
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: PUSH
30884: LD_INT 3
30886: PUSH
30887: LD_INT 1
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: LD_INT 3
30896: PUSH
30897: LD_INT 2
30899: PUSH
30900: EMPTY
30901: LIST
30902: LIST
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: LIST
30908: LIST
30909: LIST
30910: LIST
30911: LIST
30912: LIST
30913: LIST
30914: LIST
30915: LIST
30916: LIST
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: LIST
30922: LIST
30923: LIST
30924: LIST
30925: LIST
30926: LIST
30927: LIST
30928: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30929: LD_ADDR_VAR 0 25
30933: PUSH
30934: LD_INT 0
30936: PUSH
30937: LD_INT 0
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: LD_INT 0
30946: PUSH
30947: LD_INT 1
30949: NEG
30950: PUSH
30951: EMPTY
30952: LIST
30953: LIST
30954: PUSH
30955: LD_INT 1
30957: PUSH
30958: LD_INT 0
30960: PUSH
30961: EMPTY
30962: LIST
30963: LIST
30964: PUSH
30965: LD_INT 1
30967: PUSH
30968: LD_INT 1
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 0
30977: PUSH
30978: LD_INT 1
30980: PUSH
30981: EMPTY
30982: LIST
30983: LIST
30984: PUSH
30985: LD_INT 1
30987: NEG
30988: PUSH
30989: LD_INT 0
30991: PUSH
30992: EMPTY
30993: LIST
30994: LIST
30995: PUSH
30996: LD_INT 1
30998: NEG
30999: PUSH
31000: LD_INT 1
31002: NEG
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: PUSH
31008: LD_INT 1
31010: NEG
31011: PUSH
31012: LD_INT 2
31014: NEG
31015: PUSH
31016: EMPTY
31017: LIST
31018: LIST
31019: PUSH
31020: LD_INT 0
31022: PUSH
31023: LD_INT 2
31025: NEG
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: LD_INT 1
31036: NEG
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PUSH
31042: LD_INT 2
31044: PUSH
31045: LD_INT 0
31047: PUSH
31048: EMPTY
31049: LIST
31050: LIST
31051: PUSH
31052: LD_INT 2
31054: PUSH
31055: LD_INT 1
31057: PUSH
31058: EMPTY
31059: LIST
31060: LIST
31061: PUSH
31062: LD_INT 2
31064: PUSH
31065: LD_INT 2
31067: PUSH
31068: EMPTY
31069: LIST
31070: LIST
31071: PUSH
31072: LD_INT 1
31074: PUSH
31075: LD_INT 2
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PUSH
31082: LD_INT 0
31084: PUSH
31085: LD_INT 2
31087: PUSH
31088: EMPTY
31089: LIST
31090: LIST
31091: PUSH
31092: LD_INT 1
31094: NEG
31095: PUSH
31096: LD_INT 1
31098: PUSH
31099: EMPTY
31100: LIST
31101: LIST
31102: PUSH
31103: LD_INT 2
31105: NEG
31106: PUSH
31107: LD_INT 0
31109: PUSH
31110: EMPTY
31111: LIST
31112: LIST
31113: PUSH
31114: LD_INT 2
31116: NEG
31117: PUSH
31118: LD_INT 1
31120: NEG
31121: PUSH
31122: EMPTY
31123: LIST
31124: LIST
31125: PUSH
31126: LD_INT 2
31128: NEG
31129: PUSH
31130: LD_INT 2
31132: NEG
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: LD_INT 3
31140: PUSH
31141: LD_INT 1
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 3
31150: PUSH
31151: LD_INT 2
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PUSH
31158: LD_INT 2
31160: PUSH
31161: LD_INT 3
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: PUSH
31168: LD_INT 1
31170: PUSH
31171: LD_INT 3
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: LIST
31182: LIST
31183: LIST
31184: LIST
31185: LIST
31186: LIST
31187: LIST
31188: LIST
31189: LIST
31190: LIST
31191: LIST
31192: LIST
31193: LIST
31194: LIST
31195: LIST
31196: LIST
31197: LIST
31198: LIST
31199: LIST
31200: LIST
31201: LIST
31202: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31203: LD_ADDR_VAR 0 26
31207: PUSH
31208: LD_INT 0
31210: PUSH
31211: LD_INT 0
31213: PUSH
31214: EMPTY
31215: LIST
31216: LIST
31217: PUSH
31218: LD_INT 0
31220: PUSH
31221: LD_INT 1
31223: NEG
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 1
31231: PUSH
31232: LD_INT 0
31234: PUSH
31235: EMPTY
31236: LIST
31237: LIST
31238: PUSH
31239: LD_INT 1
31241: PUSH
31242: LD_INT 1
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: PUSH
31249: LD_INT 0
31251: PUSH
31252: LD_INT 1
31254: PUSH
31255: EMPTY
31256: LIST
31257: LIST
31258: PUSH
31259: LD_INT 1
31261: NEG
31262: PUSH
31263: LD_INT 0
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: PUSH
31270: LD_INT 1
31272: NEG
31273: PUSH
31274: LD_INT 1
31276: NEG
31277: PUSH
31278: EMPTY
31279: LIST
31280: LIST
31281: PUSH
31282: LD_INT 1
31284: NEG
31285: PUSH
31286: LD_INT 2
31288: NEG
31289: PUSH
31290: EMPTY
31291: LIST
31292: LIST
31293: PUSH
31294: LD_INT 0
31296: PUSH
31297: LD_INT 2
31299: NEG
31300: PUSH
31301: EMPTY
31302: LIST
31303: LIST
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: LD_INT 1
31310: NEG
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: PUSH
31316: LD_INT 2
31318: PUSH
31319: LD_INT 0
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: LD_INT 2
31328: PUSH
31329: LD_INT 1
31331: PUSH
31332: EMPTY
31333: LIST
31334: LIST
31335: PUSH
31336: LD_INT 2
31338: PUSH
31339: LD_INT 2
31341: PUSH
31342: EMPTY
31343: LIST
31344: LIST
31345: PUSH
31346: LD_INT 1
31348: PUSH
31349: LD_INT 2
31351: PUSH
31352: EMPTY
31353: LIST
31354: LIST
31355: PUSH
31356: LD_INT 0
31358: PUSH
31359: LD_INT 2
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: LD_INT 1
31368: NEG
31369: PUSH
31370: LD_INT 1
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: PUSH
31377: LD_INT 2
31379: NEG
31380: PUSH
31381: LD_INT 0
31383: PUSH
31384: EMPTY
31385: LIST
31386: LIST
31387: PUSH
31388: LD_INT 2
31390: NEG
31391: PUSH
31392: LD_INT 1
31394: NEG
31395: PUSH
31396: EMPTY
31397: LIST
31398: LIST
31399: PUSH
31400: LD_INT 2
31402: NEG
31403: PUSH
31404: LD_INT 2
31406: NEG
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 2
31414: PUSH
31415: LD_INT 3
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 1
31424: PUSH
31425: LD_INT 3
31427: PUSH
31428: EMPTY
31429: LIST
31430: LIST
31431: PUSH
31432: LD_INT 1
31434: NEG
31435: PUSH
31436: LD_INT 2
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 2
31445: NEG
31446: PUSH
31447: LD_INT 1
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: LIST
31458: LIST
31459: LIST
31460: LIST
31461: LIST
31462: LIST
31463: LIST
31464: LIST
31465: LIST
31466: LIST
31467: LIST
31468: LIST
31469: LIST
31470: LIST
31471: LIST
31472: LIST
31473: LIST
31474: LIST
31475: LIST
31476: LIST
31477: LIST
31478: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31479: LD_ADDR_VAR 0 27
31483: PUSH
31484: LD_INT 0
31486: PUSH
31487: LD_INT 0
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 0
31496: PUSH
31497: LD_INT 1
31499: NEG
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 1
31507: PUSH
31508: LD_INT 0
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: PUSH
31515: LD_INT 1
31517: PUSH
31518: LD_INT 1
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 0
31527: PUSH
31528: LD_INT 1
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: PUSH
31535: LD_INT 1
31537: NEG
31538: PUSH
31539: LD_INT 0
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: PUSH
31546: LD_INT 1
31548: NEG
31549: PUSH
31550: LD_INT 1
31552: NEG
31553: PUSH
31554: EMPTY
31555: LIST
31556: LIST
31557: PUSH
31558: LD_INT 1
31560: NEG
31561: PUSH
31562: LD_INT 2
31564: NEG
31565: PUSH
31566: EMPTY
31567: LIST
31568: LIST
31569: PUSH
31570: LD_INT 0
31572: PUSH
31573: LD_INT 2
31575: NEG
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 1
31583: PUSH
31584: LD_INT 1
31586: NEG
31587: PUSH
31588: EMPTY
31589: LIST
31590: LIST
31591: PUSH
31592: LD_INT 2
31594: PUSH
31595: LD_INT 0
31597: PUSH
31598: EMPTY
31599: LIST
31600: LIST
31601: PUSH
31602: LD_INT 2
31604: PUSH
31605: LD_INT 1
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: LD_INT 2
31614: PUSH
31615: LD_INT 2
31617: PUSH
31618: EMPTY
31619: LIST
31620: LIST
31621: PUSH
31622: LD_INT 1
31624: PUSH
31625: LD_INT 2
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 0
31634: PUSH
31635: LD_INT 2
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: LD_INT 1
31644: NEG
31645: PUSH
31646: LD_INT 1
31648: PUSH
31649: EMPTY
31650: LIST
31651: LIST
31652: PUSH
31653: LD_INT 2
31655: NEG
31656: PUSH
31657: LD_INT 0
31659: PUSH
31660: EMPTY
31661: LIST
31662: LIST
31663: PUSH
31664: LD_INT 2
31666: NEG
31667: PUSH
31668: LD_INT 1
31670: NEG
31671: PUSH
31672: EMPTY
31673: LIST
31674: LIST
31675: PUSH
31676: LD_INT 2
31678: NEG
31679: PUSH
31680: LD_INT 2
31682: NEG
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 1
31690: NEG
31691: PUSH
31692: LD_INT 2
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 2
31701: NEG
31702: PUSH
31703: LD_INT 1
31705: PUSH
31706: EMPTY
31707: LIST
31708: LIST
31709: PUSH
31710: LD_INT 3
31712: NEG
31713: PUSH
31714: LD_INT 1
31716: NEG
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: LD_INT 3
31724: NEG
31725: PUSH
31726: LD_INT 2
31728: NEG
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PUSH
31734: EMPTY
31735: LIST
31736: LIST
31737: LIST
31738: LIST
31739: LIST
31740: LIST
31741: LIST
31742: LIST
31743: LIST
31744: LIST
31745: LIST
31746: LIST
31747: LIST
31748: LIST
31749: LIST
31750: LIST
31751: LIST
31752: LIST
31753: LIST
31754: LIST
31755: LIST
31756: LIST
31757: LIST
31758: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31759: LD_ADDR_VAR 0 28
31763: PUSH
31764: LD_INT 0
31766: PUSH
31767: LD_INT 0
31769: PUSH
31770: EMPTY
31771: LIST
31772: LIST
31773: PUSH
31774: LD_INT 0
31776: PUSH
31777: LD_INT 1
31779: NEG
31780: PUSH
31781: EMPTY
31782: LIST
31783: LIST
31784: PUSH
31785: LD_INT 1
31787: PUSH
31788: LD_INT 0
31790: PUSH
31791: EMPTY
31792: LIST
31793: LIST
31794: PUSH
31795: LD_INT 1
31797: PUSH
31798: LD_INT 1
31800: PUSH
31801: EMPTY
31802: LIST
31803: LIST
31804: PUSH
31805: LD_INT 0
31807: PUSH
31808: LD_INT 1
31810: PUSH
31811: EMPTY
31812: LIST
31813: LIST
31814: PUSH
31815: LD_INT 1
31817: NEG
31818: PUSH
31819: LD_INT 0
31821: PUSH
31822: EMPTY
31823: LIST
31824: LIST
31825: PUSH
31826: LD_INT 1
31828: NEG
31829: PUSH
31830: LD_INT 1
31832: NEG
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: PUSH
31838: LD_INT 1
31840: NEG
31841: PUSH
31842: LD_INT 2
31844: NEG
31845: PUSH
31846: EMPTY
31847: LIST
31848: LIST
31849: PUSH
31850: LD_INT 0
31852: PUSH
31853: LD_INT 2
31855: NEG
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: PUSH
31861: LD_INT 1
31863: PUSH
31864: LD_INT 1
31866: NEG
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 2
31874: PUSH
31875: LD_INT 0
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 2
31884: PUSH
31885: LD_INT 1
31887: PUSH
31888: EMPTY
31889: LIST
31890: LIST
31891: PUSH
31892: LD_INT 2
31894: PUSH
31895: LD_INT 2
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 1
31904: PUSH
31905: LD_INT 2
31907: PUSH
31908: EMPTY
31909: LIST
31910: LIST
31911: PUSH
31912: LD_INT 0
31914: PUSH
31915: LD_INT 2
31917: PUSH
31918: EMPTY
31919: LIST
31920: LIST
31921: PUSH
31922: LD_INT 1
31924: NEG
31925: PUSH
31926: LD_INT 1
31928: PUSH
31929: EMPTY
31930: LIST
31931: LIST
31932: PUSH
31933: LD_INT 2
31935: NEG
31936: PUSH
31937: LD_INT 0
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: PUSH
31944: LD_INT 2
31946: NEG
31947: PUSH
31948: LD_INT 1
31950: NEG
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 2
31958: NEG
31959: PUSH
31960: LD_INT 2
31962: NEG
31963: PUSH
31964: EMPTY
31965: LIST
31966: LIST
31967: PUSH
31968: LD_INT 2
31970: NEG
31971: PUSH
31972: LD_INT 3
31974: NEG
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: PUSH
31980: LD_INT 1
31982: NEG
31983: PUSH
31984: LD_INT 3
31986: NEG
31987: PUSH
31988: EMPTY
31989: LIST
31990: LIST
31991: PUSH
31992: LD_INT 3
31994: NEG
31995: PUSH
31996: LD_INT 1
31998: NEG
31999: PUSH
32000: EMPTY
32001: LIST
32002: LIST
32003: PUSH
32004: LD_INT 3
32006: NEG
32007: PUSH
32008: LD_INT 2
32010: NEG
32011: PUSH
32012: EMPTY
32013: LIST
32014: LIST
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: LIST
32020: LIST
32021: LIST
32022: LIST
32023: LIST
32024: LIST
32025: LIST
32026: LIST
32027: LIST
32028: LIST
32029: LIST
32030: LIST
32031: LIST
32032: LIST
32033: LIST
32034: LIST
32035: LIST
32036: LIST
32037: LIST
32038: LIST
32039: LIST
32040: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32041: LD_ADDR_VAR 0 29
32045: PUSH
32046: LD_INT 0
32048: PUSH
32049: LD_INT 0
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 0
32058: PUSH
32059: LD_INT 1
32061: NEG
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 1
32069: PUSH
32070: LD_INT 0
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 1
32079: PUSH
32080: LD_INT 1
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 0
32089: PUSH
32090: LD_INT 1
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: LD_INT 1
32099: NEG
32100: PUSH
32101: LD_INT 0
32103: PUSH
32104: EMPTY
32105: LIST
32106: LIST
32107: PUSH
32108: LD_INT 1
32110: NEG
32111: PUSH
32112: LD_INT 1
32114: NEG
32115: PUSH
32116: EMPTY
32117: LIST
32118: LIST
32119: PUSH
32120: LD_INT 1
32122: NEG
32123: PUSH
32124: LD_INT 2
32126: NEG
32127: PUSH
32128: EMPTY
32129: LIST
32130: LIST
32131: PUSH
32132: LD_INT 0
32134: PUSH
32135: LD_INT 2
32137: NEG
32138: PUSH
32139: EMPTY
32140: LIST
32141: LIST
32142: PUSH
32143: LD_INT 1
32145: PUSH
32146: LD_INT 1
32148: NEG
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: LD_INT 2
32156: PUSH
32157: LD_INT 0
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: LD_INT 2
32166: PUSH
32167: LD_INT 1
32169: PUSH
32170: EMPTY
32171: LIST
32172: LIST
32173: PUSH
32174: LD_INT 1
32176: PUSH
32177: LD_INT 2
32179: PUSH
32180: EMPTY
32181: LIST
32182: LIST
32183: PUSH
32184: LD_INT 0
32186: PUSH
32187: LD_INT 2
32189: PUSH
32190: EMPTY
32191: LIST
32192: LIST
32193: PUSH
32194: LD_INT 1
32196: NEG
32197: PUSH
32198: LD_INT 1
32200: PUSH
32201: EMPTY
32202: LIST
32203: LIST
32204: PUSH
32205: LD_INT 2
32207: NEG
32208: PUSH
32209: LD_INT 1
32211: NEG
32212: PUSH
32213: EMPTY
32214: LIST
32215: LIST
32216: PUSH
32217: LD_INT 2
32219: NEG
32220: PUSH
32221: LD_INT 2
32223: NEG
32224: PUSH
32225: EMPTY
32226: LIST
32227: LIST
32228: PUSH
32229: LD_INT 2
32231: NEG
32232: PUSH
32233: LD_INT 3
32235: NEG
32236: PUSH
32237: EMPTY
32238: LIST
32239: LIST
32240: PUSH
32241: LD_INT 2
32243: PUSH
32244: LD_INT 1
32246: NEG
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 3
32254: PUSH
32255: LD_INT 1
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 1
32264: PUSH
32265: LD_INT 3
32267: PUSH
32268: EMPTY
32269: LIST
32270: LIST
32271: PUSH
32272: LD_INT 1
32274: NEG
32275: PUSH
32276: LD_INT 2
32278: PUSH
32279: EMPTY
32280: LIST
32281: LIST
32282: PUSH
32283: LD_INT 3
32285: NEG
32286: PUSH
32287: LD_INT 2
32289: NEG
32290: PUSH
32291: EMPTY
32292: LIST
32293: LIST
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: LIST
32303: LIST
32304: LIST
32305: LIST
32306: LIST
32307: LIST
32308: LIST
32309: LIST
32310: LIST
32311: LIST
32312: LIST
32313: LIST
32314: LIST
32315: LIST
32316: LIST
32317: LIST
32318: LIST
32319: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32320: LD_ADDR_VAR 0 30
32324: PUSH
32325: LD_INT 0
32327: PUSH
32328: LD_INT 0
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: PUSH
32335: LD_INT 0
32337: PUSH
32338: LD_INT 1
32340: NEG
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PUSH
32346: LD_INT 1
32348: PUSH
32349: LD_INT 0
32351: PUSH
32352: EMPTY
32353: LIST
32354: LIST
32355: PUSH
32356: LD_INT 1
32358: PUSH
32359: LD_INT 1
32361: PUSH
32362: EMPTY
32363: LIST
32364: LIST
32365: PUSH
32366: LD_INT 0
32368: PUSH
32369: LD_INT 1
32371: PUSH
32372: EMPTY
32373: LIST
32374: LIST
32375: PUSH
32376: LD_INT 1
32378: NEG
32379: PUSH
32380: LD_INT 0
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: LD_INT 1
32389: NEG
32390: PUSH
32391: LD_INT 1
32393: NEG
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: PUSH
32399: LD_INT 1
32401: NEG
32402: PUSH
32403: LD_INT 2
32405: NEG
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PUSH
32411: LD_INT 0
32413: PUSH
32414: LD_INT 2
32416: NEG
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: LD_INT 1
32424: PUSH
32425: LD_INT 1
32427: NEG
32428: PUSH
32429: EMPTY
32430: LIST
32431: LIST
32432: PUSH
32433: LD_INT 2
32435: PUSH
32436: LD_INT 0
32438: PUSH
32439: EMPTY
32440: LIST
32441: LIST
32442: PUSH
32443: LD_INT 2
32445: PUSH
32446: LD_INT 1
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PUSH
32453: LD_INT 2
32455: PUSH
32456: LD_INT 2
32458: PUSH
32459: EMPTY
32460: LIST
32461: LIST
32462: PUSH
32463: LD_INT 1
32465: PUSH
32466: LD_INT 2
32468: PUSH
32469: EMPTY
32470: LIST
32471: LIST
32472: PUSH
32473: LD_INT 1
32475: NEG
32476: PUSH
32477: LD_INT 1
32479: PUSH
32480: EMPTY
32481: LIST
32482: LIST
32483: PUSH
32484: LD_INT 2
32486: NEG
32487: PUSH
32488: LD_INT 0
32490: PUSH
32491: EMPTY
32492: LIST
32493: LIST
32494: PUSH
32495: LD_INT 2
32497: NEG
32498: PUSH
32499: LD_INT 1
32501: NEG
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 1
32509: NEG
32510: PUSH
32511: LD_INT 3
32513: NEG
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: PUSH
32522: LD_INT 2
32524: NEG
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 3
32532: PUSH
32533: LD_INT 2
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: LD_INT 2
32542: PUSH
32543: LD_INT 3
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: LD_INT 2
32552: NEG
32553: PUSH
32554: LD_INT 1
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PUSH
32561: LD_INT 3
32563: NEG
32564: PUSH
32565: LD_INT 1
32567: NEG
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: LIST
32577: LIST
32578: LIST
32579: LIST
32580: LIST
32581: LIST
32582: LIST
32583: LIST
32584: LIST
32585: LIST
32586: LIST
32587: LIST
32588: LIST
32589: LIST
32590: LIST
32591: LIST
32592: LIST
32593: LIST
32594: LIST
32595: LIST
32596: LIST
32597: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32598: LD_ADDR_VAR 0 31
32602: PUSH
32603: LD_INT 0
32605: PUSH
32606: LD_INT 0
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: LD_INT 0
32615: PUSH
32616: LD_INT 1
32618: NEG
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 1
32626: PUSH
32627: LD_INT 0
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: PUSH
32634: LD_INT 1
32636: PUSH
32637: LD_INT 1
32639: PUSH
32640: EMPTY
32641: LIST
32642: LIST
32643: PUSH
32644: LD_INT 0
32646: PUSH
32647: LD_INT 1
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: PUSH
32654: LD_INT 1
32656: NEG
32657: PUSH
32658: LD_INT 0
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 1
32667: NEG
32668: PUSH
32669: LD_INT 1
32671: NEG
32672: PUSH
32673: EMPTY
32674: LIST
32675: LIST
32676: PUSH
32677: LD_INT 1
32679: NEG
32680: PUSH
32681: LD_INT 2
32683: NEG
32684: PUSH
32685: EMPTY
32686: LIST
32687: LIST
32688: PUSH
32689: LD_INT 1
32691: PUSH
32692: LD_INT 1
32694: NEG
32695: PUSH
32696: EMPTY
32697: LIST
32698: LIST
32699: PUSH
32700: LD_INT 2
32702: PUSH
32703: LD_INT 0
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 2
32712: PUSH
32713: LD_INT 1
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 2
32722: PUSH
32723: LD_INT 2
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: PUSH
32730: LD_INT 1
32732: PUSH
32733: LD_INT 2
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: PUSH
32740: LD_INT 0
32742: PUSH
32743: LD_INT 2
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: PUSH
32750: LD_INT 1
32752: NEG
32753: PUSH
32754: LD_INT 1
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: PUSH
32761: LD_INT 2
32763: NEG
32764: PUSH
32765: LD_INT 1
32767: NEG
32768: PUSH
32769: EMPTY
32770: LIST
32771: LIST
32772: PUSH
32773: LD_INT 2
32775: NEG
32776: PUSH
32777: LD_INT 2
32779: NEG
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PUSH
32785: LD_INT 2
32787: NEG
32788: PUSH
32789: LD_INT 3
32791: NEG
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 2
32799: PUSH
32800: LD_INT 1
32802: NEG
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 3
32810: PUSH
32811: LD_INT 1
32813: PUSH
32814: EMPTY
32815: LIST
32816: LIST
32817: PUSH
32818: LD_INT 1
32820: PUSH
32821: LD_INT 3
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 1
32830: NEG
32831: PUSH
32832: LD_INT 2
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 3
32841: NEG
32842: PUSH
32843: LD_INT 2
32845: NEG
32846: PUSH
32847: EMPTY
32848: LIST
32849: LIST
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: LIST
32855: LIST
32856: LIST
32857: LIST
32858: LIST
32859: LIST
32860: LIST
32861: LIST
32862: LIST
32863: LIST
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32876: LD_ADDR_VAR 0 32
32880: PUSH
32881: LD_INT 0
32883: PUSH
32884: LD_INT 0
32886: PUSH
32887: EMPTY
32888: LIST
32889: LIST
32890: PUSH
32891: LD_INT 0
32893: PUSH
32894: LD_INT 1
32896: NEG
32897: PUSH
32898: EMPTY
32899: LIST
32900: LIST
32901: PUSH
32902: LD_INT 1
32904: PUSH
32905: LD_INT 0
32907: PUSH
32908: EMPTY
32909: LIST
32910: LIST
32911: PUSH
32912: LD_INT 1
32914: PUSH
32915: LD_INT 1
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: PUSH
32922: LD_INT 0
32924: PUSH
32925: LD_INT 1
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: PUSH
32932: LD_INT 1
32934: NEG
32935: PUSH
32936: LD_INT 0
32938: PUSH
32939: EMPTY
32940: LIST
32941: LIST
32942: PUSH
32943: LD_INT 1
32945: NEG
32946: PUSH
32947: LD_INT 1
32949: NEG
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 1
32957: NEG
32958: PUSH
32959: LD_INT 2
32961: NEG
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 0
32969: PUSH
32970: LD_INT 2
32972: NEG
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 1
32980: PUSH
32981: LD_INT 1
32983: NEG
32984: PUSH
32985: EMPTY
32986: LIST
32987: LIST
32988: PUSH
32989: LD_INT 2
32991: PUSH
32992: LD_INT 1
32994: PUSH
32995: EMPTY
32996: LIST
32997: LIST
32998: PUSH
32999: LD_INT 2
33001: PUSH
33002: LD_INT 2
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: PUSH
33009: LD_INT 1
33011: PUSH
33012: LD_INT 2
33014: PUSH
33015: EMPTY
33016: LIST
33017: LIST
33018: PUSH
33019: LD_INT 0
33021: PUSH
33022: LD_INT 2
33024: PUSH
33025: EMPTY
33026: LIST
33027: LIST
33028: PUSH
33029: LD_INT 1
33031: NEG
33032: PUSH
33033: LD_INT 1
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: LD_INT 2
33042: NEG
33043: PUSH
33044: LD_INT 0
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: LD_INT 2
33053: NEG
33054: PUSH
33055: LD_INT 1
33057: NEG
33058: PUSH
33059: EMPTY
33060: LIST
33061: LIST
33062: PUSH
33063: LD_INT 1
33065: NEG
33066: PUSH
33067: LD_INT 3
33069: NEG
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: PUSH
33075: LD_INT 1
33077: PUSH
33078: LD_INT 2
33080: NEG
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 3
33088: PUSH
33089: LD_INT 2
33091: PUSH
33092: EMPTY
33093: LIST
33094: LIST
33095: PUSH
33096: LD_INT 2
33098: PUSH
33099: LD_INT 3
33101: PUSH
33102: EMPTY
33103: LIST
33104: LIST
33105: PUSH
33106: LD_INT 2
33108: NEG
33109: PUSH
33110: LD_INT 1
33112: PUSH
33113: EMPTY
33114: LIST
33115: LIST
33116: PUSH
33117: LD_INT 3
33119: NEG
33120: PUSH
33121: LD_INT 1
33123: NEG
33124: PUSH
33125: EMPTY
33126: LIST
33127: LIST
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: LIST
33133: LIST
33134: LIST
33135: LIST
33136: LIST
33137: LIST
33138: LIST
33139: LIST
33140: LIST
33141: LIST
33142: LIST
33143: LIST
33144: LIST
33145: LIST
33146: LIST
33147: LIST
33148: LIST
33149: LIST
33150: LIST
33151: LIST
33152: LIST
33153: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33154: LD_ADDR_VAR 0 33
33158: PUSH
33159: LD_INT 0
33161: PUSH
33162: LD_INT 0
33164: PUSH
33165: EMPTY
33166: LIST
33167: LIST
33168: PUSH
33169: LD_INT 0
33171: PUSH
33172: LD_INT 1
33174: NEG
33175: PUSH
33176: EMPTY
33177: LIST
33178: LIST
33179: PUSH
33180: LD_INT 1
33182: PUSH
33183: LD_INT 0
33185: PUSH
33186: EMPTY
33187: LIST
33188: LIST
33189: PUSH
33190: LD_INT 1
33192: PUSH
33193: LD_INT 1
33195: PUSH
33196: EMPTY
33197: LIST
33198: LIST
33199: PUSH
33200: LD_INT 0
33202: PUSH
33203: LD_INT 1
33205: PUSH
33206: EMPTY
33207: LIST
33208: LIST
33209: PUSH
33210: LD_INT 1
33212: NEG
33213: PUSH
33214: LD_INT 0
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: PUSH
33221: LD_INT 1
33223: NEG
33224: PUSH
33225: LD_INT 1
33227: NEG
33228: PUSH
33229: EMPTY
33230: LIST
33231: LIST
33232: PUSH
33233: LD_INT 1
33235: NEG
33236: PUSH
33237: LD_INT 2
33239: NEG
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 1
33247: PUSH
33248: LD_INT 1
33250: NEG
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PUSH
33256: LD_INT 2
33258: PUSH
33259: LD_INT 0
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 2
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 1
33278: PUSH
33279: LD_INT 2
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: PUSH
33286: LD_INT 0
33288: PUSH
33289: LD_INT 2
33291: PUSH
33292: EMPTY
33293: LIST
33294: LIST
33295: PUSH
33296: LD_INT 1
33298: NEG
33299: PUSH
33300: LD_INT 1
33302: PUSH
33303: EMPTY
33304: LIST
33305: LIST
33306: PUSH
33307: LD_INT 2
33309: NEG
33310: PUSH
33311: LD_INT 0
33313: PUSH
33314: EMPTY
33315: LIST
33316: LIST
33317: PUSH
33318: LD_INT 2
33320: NEG
33321: PUSH
33322: LD_INT 1
33324: NEG
33325: PUSH
33326: EMPTY
33327: LIST
33328: LIST
33329: PUSH
33330: LD_INT 2
33332: NEG
33333: PUSH
33334: LD_INT 2
33336: NEG
33337: PUSH
33338: EMPTY
33339: LIST
33340: LIST
33341: PUSH
33342: LD_INT 2
33344: NEG
33345: PUSH
33346: LD_INT 3
33348: NEG
33349: PUSH
33350: EMPTY
33351: LIST
33352: LIST
33353: PUSH
33354: LD_INT 2
33356: PUSH
33357: LD_INT 1
33359: NEG
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 3
33367: PUSH
33368: LD_INT 1
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PUSH
33375: LD_INT 1
33377: PUSH
33378: LD_INT 3
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: LD_INT 1
33387: NEG
33388: PUSH
33389: LD_INT 2
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 3
33398: NEG
33399: PUSH
33400: LD_INT 2
33402: NEG
33403: PUSH
33404: EMPTY
33405: LIST
33406: LIST
33407: PUSH
33408: EMPTY
33409: LIST
33410: LIST
33411: LIST
33412: LIST
33413: LIST
33414: LIST
33415: LIST
33416: LIST
33417: LIST
33418: LIST
33419: LIST
33420: LIST
33421: LIST
33422: LIST
33423: LIST
33424: LIST
33425: LIST
33426: LIST
33427: LIST
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33433: LD_ADDR_VAR 0 34
33437: PUSH
33438: LD_INT 0
33440: PUSH
33441: LD_INT 0
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 0
33450: PUSH
33451: LD_INT 1
33453: NEG
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PUSH
33459: LD_INT 1
33461: PUSH
33462: LD_INT 0
33464: PUSH
33465: EMPTY
33466: LIST
33467: LIST
33468: PUSH
33469: LD_INT 1
33471: PUSH
33472: LD_INT 1
33474: PUSH
33475: EMPTY
33476: LIST
33477: LIST
33478: PUSH
33479: LD_INT 0
33481: PUSH
33482: LD_INT 1
33484: PUSH
33485: EMPTY
33486: LIST
33487: LIST
33488: PUSH
33489: LD_INT 1
33491: NEG
33492: PUSH
33493: LD_INT 0
33495: PUSH
33496: EMPTY
33497: LIST
33498: LIST
33499: PUSH
33500: LD_INT 1
33502: NEG
33503: PUSH
33504: LD_INT 1
33506: NEG
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 1
33514: NEG
33515: PUSH
33516: LD_INT 2
33518: NEG
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 0
33526: PUSH
33527: LD_INT 2
33529: NEG
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: PUSH
33535: LD_INT 1
33537: PUSH
33538: LD_INT 1
33540: NEG
33541: PUSH
33542: EMPTY
33543: LIST
33544: LIST
33545: PUSH
33546: LD_INT 2
33548: PUSH
33549: LD_INT 1
33551: PUSH
33552: EMPTY
33553: LIST
33554: LIST
33555: PUSH
33556: LD_INT 2
33558: PUSH
33559: LD_INT 2
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: PUSH
33566: LD_INT 1
33568: PUSH
33569: LD_INT 2
33571: PUSH
33572: EMPTY
33573: LIST
33574: LIST
33575: PUSH
33576: LD_INT 1
33578: NEG
33579: PUSH
33580: LD_INT 1
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: LD_INT 2
33589: NEG
33590: PUSH
33591: LD_INT 0
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 2
33600: NEG
33601: PUSH
33602: LD_INT 1
33604: NEG
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: PUSH
33610: LD_INT 2
33612: NEG
33613: PUSH
33614: LD_INT 2
33616: NEG
33617: PUSH
33618: EMPTY
33619: LIST
33620: LIST
33621: PUSH
33622: LD_INT 1
33624: NEG
33625: PUSH
33626: LD_INT 3
33628: NEG
33629: PUSH
33630: EMPTY
33631: LIST
33632: LIST
33633: PUSH
33634: LD_INT 1
33636: PUSH
33637: LD_INT 2
33639: NEG
33640: PUSH
33641: EMPTY
33642: LIST
33643: LIST
33644: PUSH
33645: LD_INT 3
33647: PUSH
33648: LD_INT 2
33650: PUSH
33651: EMPTY
33652: LIST
33653: LIST
33654: PUSH
33655: LD_INT 2
33657: PUSH
33658: LD_INT 3
33660: PUSH
33661: EMPTY
33662: LIST
33663: LIST
33664: PUSH
33665: LD_INT 2
33667: NEG
33668: PUSH
33669: LD_INT 1
33671: PUSH
33672: EMPTY
33673: LIST
33674: LIST
33675: PUSH
33676: LD_INT 3
33678: NEG
33679: PUSH
33680: LD_INT 1
33682: NEG
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: LIST
33702: LIST
33703: LIST
33704: LIST
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33713: LD_ADDR_VAR 0 35
33717: PUSH
33718: LD_INT 0
33720: PUSH
33721: LD_INT 0
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 0
33730: PUSH
33731: LD_INT 1
33733: NEG
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 1
33741: PUSH
33742: LD_INT 0
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: PUSH
33749: LD_INT 1
33751: PUSH
33752: LD_INT 1
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PUSH
33759: LD_INT 0
33761: PUSH
33762: LD_INT 1
33764: PUSH
33765: EMPTY
33766: LIST
33767: LIST
33768: PUSH
33769: LD_INT 1
33771: NEG
33772: PUSH
33773: LD_INT 0
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: LD_INT 1
33782: NEG
33783: PUSH
33784: LD_INT 1
33786: NEG
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 2
33794: PUSH
33795: LD_INT 1
33797: PUSH
33798: EMPTY
33799: LIST
33800: LIST
33801: PUSH
33802: LD_INT 2
33804: NEG
33805: PUSH
33806: LD_INT 1
33808: NEG
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: LIST
33818: LIST
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33825: LD_ADDR_VAR 0 36
33829: PUSH
33830: LD_INT 0
33832: PUSH
33833: LD_INT 0
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 0
33842: PUSH
33843: LD_INT 1
33845: NEG
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 1
33853: PUSH
33854: LD_INT 0
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 1
33863: PUSH
33864: LD_INT 1
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 0
33873: PUSH
33874: LD_INT 1
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: LD_INT 1
33883: NEG
33884: PUSH
33885: LD_INT 0
33887: PUSH
33888: EMPTY
33889: LIST
33890: LIST
33891: PUSH
33892: LD_INT 1
33894: NEG
33895: PUSH
33896: LD_INT 1
33898: NEG
33899: PUSH
33900: EMPTY
33901: LIST
33902: LIST
33903: PUSH
33904: LD_INT 1
33906: NEG
33907: PUSH
33908: LD_INT 2
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 1
33918: PUSH
33919: LD_INT 2
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: LIST
33930: LIST
33931: LIST
33932: LIST
33933: LIST
33934: LIST
33935: LIST
33936: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33937: LD_ADDR_VAR 0 37
33941: PUSH
33942: LD_INT 0
33944: PUSH
33945: LD_INT 0
33947: PUSH
33948: EMPTY
33949: LIST
33950: LIST
33951: PUSH
33952: LD_INT 0
33954: PUSH
33955: LD_INT 1
33957: NEG
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: LD_INT 1
33965: PUSH
33966: LD_INT 0
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: LD_INT 1
33975: PUSH
33976: LD_INT 1
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 0
33985: PUSH
33986: LD_INT 1
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 1
33995: NEG
33996: PUSH
33997: LD_INT 0
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 1
34006: NEG
34007: PUSH
34008: LD_INT 1
34010: NEG
34011: PUSH
34012: EMPTY
34013: LIST
34014: LIST
34015: PUSH
34016: LD_INT 1
34018: PUSH
34019: LD_INT 1
34021: NEG
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: LD_INT 1
34029: NEG
34030: PUSH
34031: LD_INT 1
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: PUSH
34038: EMPTY
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34049: LD_ADDR_VAR 0 38
34053: PUSH
34054: LD_INT 0
34056: PUSH
34057: LD_INT 0
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 0
34066: PUSH
34067: LD_INT 1
34069: NEG
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PUSH
34075: LD_INT 1
34077: PUSH
34078: LD_INT 0
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 1
34087: PUSH
34088: LD_INT 1
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: LD_INT 0
34097: PUSH
34098: LD_INT 1
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: LD_INT 1
34107: NEG
34108: PUSH
34109: LD_INT 0
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: LD_INT 1
34122: NEG
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 2
34130: PUSH
34131: LD_INT 1
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 2
34140: NEG
34141: PUSH
34142: LD_INT 1
34144: NEG
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: EMPTY
34151: LIST
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34161: LD_ADDR_VAR 0 39
34165: PUSH
34166: LD_INT 0
34168: PUSH
34169: LD_INT 0
34171: PUSH
34172: EMPTY
34173: LIST
34174: LIST
34175: PUSH
34176: LD_INT 0
34178: PUSH
34179: LD_INT 1
34181: NEG
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PUSH
34187: LD_INT 1
34189: PUSH
34190: LD_INT 0
34192: PUSH
34193: EMPTY
34194: LIST
34195: LIST
34196: PUSH
34197: LD_INT 1
34199: PUSH
34200: LD_INT 1
34202: PUSH
34203: EMPTY
34204: LIST
34205: LIST
34206: PUSH
34207: LD_INT 0
34209: PUSH
34210: LD_INT 1
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 1
34219: NEG
34220: PUSH
34221: LD_INT 0
34223: PUSH
34224: EMPTY
34225: LIST
34226: LIST
34227: PUSH
34228: LD_INT 1
34230: NEG
34231: PUSH
34232: LD_INT 1
34234: NEG
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: PUSH
34240: LD_INT 1
34242: NEG
34243: PUSH
34244: LD_INT 2
34246: NEG
34247: PUSH
34248: EMPTY
34249: LIST
34250: LIST
34251: PUSH
34252: LD_INT 1
34254: PUSH
34255: LD_INT 2
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34273: LD_ADDR_VAR 0 40
34277: PUSH
34278: LD_INT 0
34280: PUSH
34281: LD_INT 0
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: PUSH
34288: LD_INT 0
34290: PUSH
34291: LD_INT 1
34293: NEG
34294: PUSH
34295: EMPTY
34296: LIST
34297: LIST
34298: PUSH
34299: LD_INT 1
34301: PUSH
34302: LD_INT 0
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: PUSH
34309: LD_INT 1
34311: PUSH
34312: LD_INT 1
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 0
34321: PUSH
34322: LD_INT 1
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 1
34331: NEG
34332: PUSH
34333: LD_INT 0
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 1
34342: NEG
34343: PUSH
34344: LD_INT 1
34346: NEG
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 1
34354: PUSH
34355: LD_INT 1
34357: NEG
34358: PUSH
34359: EMPTY
34360: LIST
34361: LIST
34362: PUSH
34363: LD_INT 1
34365: NEG
34366: PUSH
34367: LD_INT 1
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: LIST
34381: LIST
34382: LIST
34383: LIST
34384: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34385: LD_ADDR_VAR 0 41
34389: PUSH
34390: LD_INT 0
34392: PUSH
34393: LD_INT 0
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: LD_INT 0
34402: PUSH
34403: LD_INT 1
34405: NEG
34406: PUSH
34407: EMPTY
34408: LIST
34409: LIST
34410: PUSH
34411: LD_INT 1
34413: PUSH
34414: LD_INT 0
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: PUSH
34424: LD_INT 1
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 0
34433: PUSH
34434: LD_INT 1
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 1
34443: NEG
34444: PUSH
34445: LD_INT 0
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 1
34454: NEG
34455: PUSH
34456: LD_INT 1
34458: NEG
34459: PUSH
34460: EMPTY
34461: LIST
34462: LIST
34463: PUSH
34464: LD_INT 1
34466: NEG
34467: PUSH
34468: LD_INT 2
34470: NEG
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PUSH
34476: LD_INT 1
34478: PUSH
34479: LD_INT 1
34481: NEG
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: PUSH
34487: LD_INT 2
34489: PUSH
34490: LD_INT 0
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 2
34499: PUSH
34500: LD_INT 1
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 2
34509: PUSH
34510: LD_INT 2
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: PUSH
34517: LD_INT 1
34519: PUSH
34520: LD_INT 2
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 1
34529: NEG
34530: PUSH
34531: LD_INT 1
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 2
34540: NEG
34541: PUSH
34542: LD_INT 0
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 2
34551: NEG
34552: PUSH
34553: LD_INT 1
34555: NEG
34556: PUSH
34557: EMPTY
34558: LIST
34559: LIST
34560: PUSH
34561: LD_INT 2
34563: NEG
34564: PUSH
34565: LD_INT 2
34567: NEG
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 2
34575: NEG
34576: PUSH
34577: LD_INT 3
34579: NEG
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 2
34587: PUSH
34588: LD_INT 1
34590: NEG
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 3
34598: PUSH
34599: LD_INT 0
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 3
34608: PUSH
34609: LD_INT 1
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 3
34618: PUSH
34619: LD_INT 2
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 3
34628: PUSH
34629: LD_INT 3
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PUSH
34636: LD_INT 2
34638: PUSH
34639: LD_INT 3
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: LD_INT 2
34648: NEG
34649: PUSH
34650: LD_INT 1
34652: PUSH
34653: EMPTY
34654: LIST
34655: LIST
34656: PUSH
34657: LD_INT 3
34659: NEG
34660: PUSH
34661: LD_INT 0
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: LD_INT 3
34670: NEG
34671: PUSH
34672: LD_INT 1
34674: NEG
34675: PUSH
34676: EMPTY
34677: LIST
34678: LIST
34679: PUSH
34680: LD_INT 3
34682: NEG
34683: PUSH
34684: LD_INT 2
34686: NEG
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 3
34694: NEG
34695: PUSH
34696: LD_INT 3
34698: NEG
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: EMPTY
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34735: LD_ADDR_VAR 0 42
34739: PUSH
34740: LD_INT 0
34742: PUSH
34743: LD_INT 0
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 0
34752: PUSH
34753: LD_INT 1
34755: NEG
34756: PUSH
34757: EMPTY
34758: LIST
34759: LIST
34760: PUSH
34761: LD_INT 1
34763: PUSH
34764: LD_INT 0
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: LD_INT 1
34773: PUSH
34774: LD_INT 1
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 0
34783: PUSH
34784: LD_INT 1
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: PUSH
34791: LD_INT 1
34793: NEG
34794: PUSH
34795: LD_INT 0
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: PUSH
34802: LD_INT 1
34804: NEG
34805: PUSH
34806: LD_INT 1
34808: NEG
34809: PUSH
34810: EMPTY
34811: LIST
34812: LIST
34813: PUSH
34814: LD_INT 1
34816: NEG
34817: PUSH
34818: LD_INT 2
34820: NEG
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PUSH
34826: LD_INT 0
34828: PUSH
34829: LD_INT 2
34831: NEG
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: PUSH
34837: LD_INT 1
34839: PUSH
34840: LD_INT 1
34842: NEG
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 2
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 2
34860: PUSH
34861: LD_INT 2
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 1
34870: PUSH
34871: LD_INT 2
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 0
34880: PUSH
34881: LD_INT 2
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 1
34890: NEG
34891: PUSH
34892: LD_INT 1
34894: PUSH
34895: EMPTY
34896: LIST
34897: LIST
34898: PUSH
34899: LD_INT 2
34901: NEG
34902: PUSH
34903: LD_INT 1
34905: NEG
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 2
34913: NEG
34914: PUSH
34915: LD_INT 2
34917: NEG
34918: PUSH
34919: EMPTY
34920: LIST
34921: LIST
34922: PUSH
34923: LD_INT 2
34925: NEG
34926: PUSH
34927: LD_INT 3
34929: NEG
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: LD_INT 1
34937: NEG
34938: PUSH
34939: LD_INT 3
34941: NEG
34942: PUSH
34943: EMPTY
34944: LIST
34945: LIST
34946: PUSH
34947: LD_INT 0
34949: PUSH
34950: LD_INT 3
34952: NEG
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: LD_INT 1
34960: PUSH
34961: LD_INT 2
34963: NEG
34964: PUSH
34965: EMPTY
34966: LIST
34967: LIST
34968: PUSH
34969: LD_INT 3
34971: PUSH
34972: LD_INT 2
34974: PUSH
34975: EMPTY
34976: LIST
34977: LIST
34978: PUSH
34979: LD_INT 3
34981: PUSH
34982: LD_INT 3
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: PUSH
34989: LD_INT 2
34991: PUSH
34992: LD_INT 3
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 1
35001: PUSH
35002: LD_INT 3
35004: PUSH
35005: EMPTY
35006: LIST
35007: LIST
35008: PUSH
35009: LD_INT 0
35011: PUSH
35012: LD_INT 3
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 1
35021: NEG
35022: PUSH
35023: LD_INT 2
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 3
35032: NEG
35033: PUSH
35034: LD_INT 2
35036: NEG
35037: PUSH
35038: EMPTY
35039: LIST
35040: LIST
35041: PUSH
35042: LD_INT 3
35044: NEG
35045: PUSH
35046: LD_INT 3
35048: NEG
35049: PUSH
35050: EMPTY
35051: LIST
35052: LIST
35053: PUSH
35054: EMPTY
35055: LIST
35056: LIST
35057: LIST
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: LIST
35063: LIST
35064: LIST
35065: LIST
35066: LIST
35067: LIST
35068: LIST
35069: LIST
35070: LIST
35071: LIST
35072: LIST
35073: LIST
35074: LIST
35075: LIST
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35085: LD_ADDR_VAR 0 43
35089: PUSH
35090: LD_INT 0
35092: PUSH
35093: LD_INT 0
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 0
35102: PUSH
35103: LD_INT 1
35105: NEG
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 1
35113: PUSH
35114: LD_INT 0
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PUSH
35121: LD_INT 1
35123: PUSH
35124: LD_INT 1
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: LD_INT 0
35133: PUSH
35134: LD_INT 1
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: LD_INT 1
35143: NEG
35144: PUSH
35145: LD_INT 0
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 1
35154: NEG
35155: PUSH
35156: LD_INT 1
35158: NEG
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 1
35166: NEG
35167: PUSH
35168: LD_INT 2
35170: NEG
35171: PUSH
35172: EMPTY
35173: LIST
35174: LIST
35175: PUSH
35176: LD_INT 0
35178: PUSH
35179: LD_INT 2
35181: NEG
35182: PUSH
35183: EMPTY
35184: LIST
35185: LIST
35186: PUSH
35187: LD_INT 1
35189: PUSH
35190: LD_INT 1
35192: NEG
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 2
35200: PUSH
35201: LD_INT 0
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 2
35210: PUSH
35211: LD_INT 1
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 1
35220: PUSH
35221: LD_INT 2
35223: PUSH
35224: EMPTY
35225: LIST
35226: LIST
35227: PUSH
35228: LD_INT 0
35230: PUSH
35231: LD_INT 2
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: LD_INT 1
35244: PUSH
35245: EMPTY
35246: LIST
35247: LIST
35248: PUSH
35249: LD_INT 2
35251: NEG
35252: PUSH
35253: LD_INT 0
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 2
35262: NEG
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: LD_INT 1
35274: NEG
35275: PUSH
35276: LD_INT 3
35278: NEG
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: PUSH
35284: LD_INT 0
35286: PUSH
35287: LD_INT 3
35289: NEG
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 1
35297: PUSH
35298: LD_INT 2
35300: NEG
35301: PUSH
35302: EMPTY
35303: LIST
35304: LIST
35305: PUSH
35306: LD_INT 2
35308: PUSH
35309: LD_INT 1
35311: NEG
35312: PUSH
35313: EMPTY
35314: LIST
35315: LIST
35316: PUSH
35317: LD_INT 3
35319: PUSH
35320: LD_INT 0
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: LD_INT 3
35329: PUSH
35330: LD_INT 1
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: LD_INT 1
35339: PUSH
35340: LD_INT 3
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 0
35349: PUSH
35350: LD_INT 3
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 1
35359: NEG
35360: PUSH
35361: LD_INT 2
35363: PUSH
35364: EMPTY
35365: LIST
35366: LIST
35367: PUSH
35368: LD_INT 2
35370: NEG
35371: PUSH
35372: LD_INT 1
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 3
35381: NEG
35382: PUSH
35383: LD_INT 0
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 3
35392: NEG
35393: PUSH
35394: LD_INT 1
35396: NEG
35397: PUSH
35398: EMPTY
35399: LIST
35400: LIST
35401: PUSH
35402: EMPTY
35403: LIST
35404: LIST
35405: LIST
35406: LIST
35407: LIST
35408: LIST
35409: LIST
35410: LIST
35411: LIST
35412: LIST
35413: LIST
35414: LIST
35415: LIST
35416: LIST
35417: LIST
35418: LIST
35419: LIST
35420: LIST
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35433: LD_ADDR_VAR 0 44
35437: PUSH
35438: LD_INT 0
35440: PUSH
35441: LD_INT 0
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 0
35450: PUSH
35451: LD_INT 1
35453: NEG
35454: PUSH
35455: EMPTY
35456: LIST
35457: LIST
35458: PUSH
35459: LD_INT 1
35461: PUSH
35462: LD_INT 0
35464: PUSH
35465: EMPTY
35466: LIST
35467: LIST
35468: PUSH
35469: LD_INT 1
35471: PUSH
35472: LD_INT 1
35474: PUSH
35475: EMPTY
35476: LIST
35477: LIST
35478: PUSH
35479: LD_INT 0
35481: PUSH
35482: LD_INT 1
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 1
35491: NEG
35492: PUSH
35493: LD_INT 0
35495: PUSH
35496: EMPTY
35497: LIST
35498: LIST
35499: PUSH
35500: LD_INT 1
35502: NEG
35503: PUSH
35504: LD_INT 1
35506: NEG
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 1
35514: NEG
35515: PUSH
35516: LD_INT 2
35518: NEG
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 1
35526: PUSH
35527: LD_INT 1
35529: NEG
35530: PUSH
35531: EMPTY
35532: LIST
35533: LIST
35534: PUSH
35535: LD_INT 2
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: LD_INT 2
35547: PUSH
35548: LD_INT 1
35550: PUSH
35551: EMPTY
35552: LIST
35553: LIST
35554: PUSH
35555: LD_INT 2
35557: PUSH
35558: LD_INT 2
35560: PUSH
35561: EMPTY
35562: LIST
35563: LIST
35564: PUSH
35565: LD_INT 1
35567: PUSH
35568: LD_INT 2
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: PUSH
35575: LD_INT 1
35577: NEG
35578: PUSH
35579: LD_INT 1
35581: PUSH
35582: EMPTY
35583: LIST
35584: LIST
35585: PUSH
35586: LD_INT 2
35588: NEG
35589: PUSH
35590: LD_INT 0
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: PUSH
35597: LD_INT 2
35599: NEG
35600: PUSH
35601: LD_INT 1
35603: NEG
35604: PUSH
35605: EMPTY
35606: LIST
35607: LIST
35608: PUSH
35609: LD_INT 2
35611: NEG
35612: PUSH
35613: LD_INT 2
35615: NEG
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 2
35623: NEG
35624: PUSH
35625: LD_INT 3
35627: NEG
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 2
35635: PUSH
35636: LD_INT 1
35638: NEG
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 3
35646: PUSH
35647: LD_INT 0
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: PUSH
35654: LD_INT 3
35656: PUSH
35657: LD_INT 1
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: PUSH
35664: LD_INT 3
35666: PUSH
35667: LD_INT 2
35669: PUSH
35670: EMPTY
35671: LIST
35672: LIST
35673: PUSH
35674: LD_INT 3
35676: PUSH
35677: LD_INT 3
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 2
35686: PUSH
35687: LD_INT 3
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 2
35696: NEG
35697: PUSH
35698: LD_INT 1
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 3
35707: NEG
35708: PUSH
35709: LD_INT 0
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 3
35718: NEG
35719: PUSH
35720: LD_INT 1
35722: NEG
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: PUSH
35728: LD_INT 3
35730: NEG
35731: PUSH
35732: LD_INT 2
35734: NEG
35735: PUSH
35736: EMPTY
35737: LIST
35738: LIST
35739: PUSH
35740: LD_INT 3
35742: NEG
35743: PUSH
35744: LD_INT 3
35746: NEG
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: LIST
35756: LIST
35757: LIST
35758: LIST
35759: LIST
35760: LIST
35761: LIST
35762: LIST
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: LIST
35768: LIST
35769: LIST
35770: LIST
35771: LIST
35772: LIST
35773: LIST
35774: LIST
35775: LIST
35776: LIST
35777: LIST
35778: LIST
35779: LIST
35780: LIST
35781: LIST
35782: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35783: LD_ADDR_VAR 0 45
35787: PUSH
35788: LD_INT 0
35790: PUSH
35791: LD_INT 0
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 0
35800: PUSH
35801: LD_INT 1
35803: NEG
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 1
35811: PUSH
35812: LD_INT 0
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: LD_INT 1
35821: PUSH
35822: LD_INT 1
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 0
35831: PUSH
35832: LD_INT 1
35834: PUSH
35835: EMPTY
35836: LIST
35837: LIST
35838: PUSH
35839: LD_INT 1
35841: NEG
35842: PUSH
35843: LD_INT 0
35845: PUSH
35846: EMPTY
35847: LIST
35848: LIST
35849: PUSH
35850: LD_INT 1
35852: NEG
35853: PUSH
35854: LD_INT 1
35856: NEG
35857: PUSH
35858: EMPTY
35859: LIST
35860: LIST
35861: PUSH
35862: LD_INT 1
35864: NEG
35865: PUSH
35866: LD_INT 2
35868: NEG
35869: PUSH
35870: EMPTY
35871: LIST
35872: LIST
35873: PUSH
35874: LD_INT 0
35876: PUSH
35877: LD_INT 2
35879: NEG
35880: PUSH
35881: EMPTY
35882: LIST
35883: LIST
35884: PUSH
35885: LD_INT 1
35887: PUSH
35888: LD_INT 1
35890: NEG
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: LD_INT 1
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 2
35908: PUSH
35909: LD_INT 2
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 1
35918: PUSH
35919: LD_INT 2
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 0
35928: PUSH
35929: LD_INT 2
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 1
35938: NEG
35939: PUSH
35940: LD_INT 1
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 2
35949: NEG
35950: PUSH
35951: LD_INT 1
35953: NEG
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PUSH
35959: LD_INT 2
35961: NEG
35962: PUSH
35963: LD_INT 2
35965: NEG
35966: PUSH
35967: EMPTY
35968: LIST
35969: LIST
35970: PUSH
35971: LD_INT 2
35973: NEG
35974: PUSH
35975: LD_INT 3
35977: NEG
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 1
35985: NEG
35986: PUSH
35987: LD_INT 3
35989: NEG
35990: PUSH
35991: EMPTY
35992: LIST
35993: LIST
35994: PUSH
35995: LD_INT 0
35997: PUSH
35998: LD_INT 3
36000: NEG
36001: PUSH
36002: EMPTY
36003: LIST
36004: LIST
36005: PUSH
36006: LD_INT 1
36008: PUSH
36009: LD_INT 2
36011: NEG
36012: PUSH
36013: EMPTY
36014: LIST
36015: LIST
36016: PUSH
36017: LD_INT 3
36019: PUSH
36020: LD_INT 2
36022: PUSH
36023: EMPTY
36024: LIST
36025: LIST
36026: PUSH
36027: LD_INT 3
36029: PUSH
36030: LD_INT 3
36032: PUSH
36033: EMPTY
36034: LIST
36035: LIST
36036: PUSH
36037: LD_INT 2
36039: PUSH
36040: LD_INT 3
36042: PUSH
36043: EMPTY
36044: LIST
36045: LIST
36046: PUSH
36047: LD_INT 1
36049: PUSH
36050: LD_INT 3
36052: PUSH
36053: EMPTY
36054: LIST
36055: LIST
36056: PUSH
36057: LD_INT 0
36059: PUSH
36060: LD_INT 3
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: PUSH
36067: LD_INT 1
36069: NEG
36070: PUSH
36071: LD_INT 2
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 3
36080: NEG
36081: PUSH
36082: LD_INT 2
36084: NEG
36085: PUSH
36086: EMPTY
36087: LIST
36088: LIST
36089: PUSH
36090: LD_INT 3
36092: NEG
36093: PUSH
36094: LD_INT 3
36096: NEG
36097: PUSH
36098: EMPTY
36099: LIST
36100: LIST
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: LIST
36106: LIST
36107: LIST
36108: LIST
36109: LIST
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36133: LD_ADDR_VAR 0 46
36137: PUSH
36138: LD_INT 0
36140: PUSH
36141: LD_INT 0
36143: PUSH
36144: EMPTY
36145: LIST
36146: LIST
36147: PUSH
36148: LD_INT 0
36150: PUSH
36151: LD_INT 1
36153: NEG
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PUSH
36159: LD_INT 1
36161: PUSH
36162: LD_INT 0
36164: PUSH
36165: EMPTY
36166: LIST
36167: LIST
36168: PUSH
36169: LD_INT 1
36171: PUSH
36172: LD_INT 1
36174: PUSH
36175: EMPTY
36176: LIST
36177: LIST
36178: PUSH
36179: LD_INT 0
36181: PUSH
36182: LD_INT 1
36184: PUSH
36185: EMPTY
36186: LIST
36187: LIST
36188: PUSH
36189: LD_INT 1
36191: NEG
36192: PUSH
36193: LD_INT 0
36195: PUSH
36196: EMPTY
36197: LIST
36198: LIST
36199: PUSH
36200: LD_INT 1
36202: NEG
36203: PUSH
36204: LD_INT 1
36206: NEG
36207: PUSH
36208: EMPTY
36209: LIST
36210: LIST
36211: PUSH
36212: LD_INT 1
36214: NEG
36215: PUSH
36216: LD_INT 2
36218: NEG
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 0
36226: PUSH
36227: LD_INT 2
36229: NEG
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 1
36237: PUSH
36238: LD_INT 1
36240: NEG
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 2
36248: PUSH
36249: LD_INT 0
36251: PUSH
36252: EMPTY
36253: LIST
36254: LIST
36255: PUSH
36256: LD_INT 2
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: PUSH
36266: LD_INT 1
36268: PUSH
36269: LD_INT 2
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 0
36278: PUSH
36279: LD_INT 2
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 1
36288: NEG
36289: PUSH
36290: LD_INT 1
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 2
36299: NEG
36300: PUSH
36301: LD_INT 0
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 2
36310: NEG
36311: PUSH
36312: LD_INT 1
36314: NEG
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 1
36322: NEG
36323: PUSH
36324: LD_INT 3
36326: NEG
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 0
36334: PUSH
36335: LD_INT 3
36337: NEG
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: PUSH
36343: LD_INT 1
36345: PUSH
36346: LD_INT 2
36348: NEG
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 2
36356: PUSH
36357: LD_INT 1
36359: NEG
36360: PUSH
36361: EMPTY
36362: LIST
36363: LIST
36364: PUSH
36365: LD_INT 3
36367: PUSH
36368: LD_INT 0
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 3
36377: PUSH
36378: LD_INT 1
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: PUSH
36385: LD_INT 1
36387: PUSH
36388: LD_INT 3
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: LD_INT 0
36397: PUSH
36398: LD_INT 3
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 1
36407: NEG
36408: PUSH
36409: LD_INT 2
36411: PUSH
36412: EMPTY
36413: LIST
36414: LIST
36415: PUSH
36416: LD_INT 2
36418: NEG
36419: PUSH
36420: LD_INT 1
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 3
36429: NEG
36430: PUSH
36431: LD_INT 0
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 3
36440: NEG
36441: PUSH
36442: LD_INT 1
36444: NEG
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: LIST
36454: LIST
36455: LIST
36456: LIST
36457: LIST
36458: LIST
36459: LIST
36460: LIST
36461: LIST
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36481: LD_ADDR_VAR 0 47
36485: PUSH
36486: LD_INT 0
36488: PUSH
36489: LD_INT 0
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 0
36498: PUSH
36499: LD_INT 1
36501: NEG
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: LD_INT 1
36509: PUSH
36510: LD_INT 0
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 1
36519: PUSH
36520: LD_INT 1
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: LD_INT 0
36529: PUSH
36530: LD_INT 1
36532: PUSH
36533: EMPTY
36534: LIST
36535: LIST
36536: PUSH
36537: LD_INT 1
36539: NEG
36540: PUSH
36541: LD_INT 0
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: LD_INT 1
36550: NEG
36551: PUSH
36552: LD_INT 1
36554: NEG
36555: PUSH
36556: EMPTY
36557: LIST
36558: LIST
36559: PUSH
36560: LD_INT 1
36562: NEG
36563: PUSH
36564: LD_INT 2
36566: NEG
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 0
36574: PUSH
36575: LD_INT 2
36577: NEG
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 1
36585: PUSH
36586: LD_INT 1
36588: NEG
36589: PUSH
36590: EMPTY
36591: LIST
36592: LIST
36593: PUSH
36594: LD_INT 2
36596: NEG
36597: PUSH
36598: LD_INT 1
36600: NEG
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: LD_INT 2
36608: NEG
36609: PUSH
36610: LD_INT 2
36612: NEG
36613: PUSH
36614: EMPTY
36615: LIST
36616: LIST
36617: PUSH
36618: EMPTY
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: LIST
36628: LIST
36629: LIST
36630: LIST
36631: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36632: LD_ADDR_VAR 0 48
36636: PUSH
36637: LD_INT 0
36639: PUSH
36640: LD_INT 0
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: LD_INT 0
36649: PUSH
36650: LD_INT 1
36652: NEG
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: PUSH
36658: LD_INT 1
36660: PUSH
36661: LD_INT 0
36663: PUSH
36664: EMPTY
36665: LIST
36666: LIST
36667: PUSH
36668: LD_INT 1
36670: PUSH
36671: LD_INT 1
36673: PUSH
36674: EMPTY
36675: LIST
36676: LIST
36677: PUSH
36678: LD_INT 0
36680: PUSH
36681: LD_INT 1
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 1
36690: NEG
36691: PUSH
36692: LD_INT 0
36694: PUSH
36695: EMPTY
36696: LIST
36697: LIST
36698: PUSH
36699: LD_INT 1
36701: NEG
36702: PUSH
36703: LD_INT 1
36705: NEG
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 1
36713: NEG
36714: PUSH
36715: LD_INT 2
36717: NEG
36718: PUSH
36719: EMPTY
36720: LIST
36721: LIST
36722: PUSH
36723: LD_INT 0
36725: PUSH
36726: LD_INT 2
36728: NEG
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: PUSH
36734: LD_INT 1
36736: PUSH
36737: LD_INT 1
36739: NEG
36740: PUSH
36741: EMPTY
36742: LIST
36743: LIST
36744: PUSH
36745: LD_INT 2
36747: PUSH
36748: LD_INT 0
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_INT 2
36757: PUSH
36758: LD_INT 1
36760: PUSH
36761: EMPTY
36762: LIST
36763: LIST
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: LIST
36769: LIST
36770: LIST
36771: LIST
36772: LIST
36773: LIST
36774: LIST
36775: LIST
36776: LIST
36777: LIST
36778: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36779: LD_ADDR_VAR 0 49
36783: PUSH
36784: LD_INT 0
36786: PUSH
36787: LD_INT 0
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 0
36796: PUSH
36797: LD_INT 1
36799: NEG
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: PUSH
36805: LD_INT 1
36807: PUSH
36808: LD_INT 0
36810: PUSH
36811: EMPTY
36812: LIST
36813: LIST
36814: PUSH
36815: LD_INT 1
36817: PUSH
36818: LD_INT 1
36820: PUSH
36821: EMPTY
36822: LIST
36823: LIST
36824: PUSH
36825: LD_INT 0
36827: PUSH
36828: LD_INT 1
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 1
36837: NEG
36838: PUSH
36839: LD_INT 0
36841: PUSH
36842: EMPTY
36843: LIST
36844: LIST
36845: PUSH
36846: LD_INT 1
36848: NEG
36849: PUSH
36850: LD_INT 1
36852: NEG
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: LD_INT 1
36860: PUSH
36861: LD_INT 1
36863: NEG
36864: PUSH
36865: EMPTY
36866: LIST
36867: LIST
36868: PUSH
36869: LD_INT 2
36871: PUSH
36872: LD_INT 0
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: PUSH
36879: LD_INT 2
36881: PUSH
36882: LD_INT 1
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 2
36891: PUSH
36892: LD_INT 2
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 1
36901: PUSH
36902: LD_INT 2
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: LIST
36913: LIST
36914: LIST
36915: LIST
36916: LIST
36917: LIST
36918: LIST
36919: LIST
36920: LIST
36921: LIST
36922: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36923: LD_ADDR_VAR 0 50
36927: PUSH
36928: LD_INT 0
36930: PUSH
36931: LD_INT 0
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 0
36940: PUSH
36941: LD_INT 1
36943: NEG
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: LD_INT 1
36951: PUSH
36952: LD_INT 0
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: LD_INT 1
36961: PUSH
36962: LD_INT 1
36964: PUSH
36965: EMPTY
36966: LIST
36967: LIST
36968: PUSH
36969: LD_INT 0
36971: PUSH
36972: LD_INT 1
36974: PUSH
36975: EMPTY
36976: LIST
36977: LIST
36978: PUSH
36979: LD_INT 1
36981: NEG
36982: PUSH
36983: LD_INT 0
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: PUSH
36990: LD_INT 1
36992: NEG
36993: PUSH
36994: LD_INT 1
36996: NEG
36997: PUSH
36998: EMPTY
36999: LIST
37000: LIST
37001: PUSH
37002: LD_INT 2
37004: PUSH
37005: LD_INT 1
37007: PUSH
37008: EMPTY
37009: LIST
37010: LIST
37011: PUSH
37012: LD_INT 2
37014: PUSH
37015: LD_INT 2
37017: PUSH
37018: EMPTY
37019: LIST
37020: LIST
37021: PUSH
37022: LD_INT 1
37024: PUSH
37025: LD_INT 2
37027: PUSH
37028: EMPTY
37029: LIST
37030: LIST
37031: PUSH
37032: LD_INT 0
37034: PUSH
37035: LD_INT 2
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 1
37044: NEG
37045: PUSH
37046: LD_INT 1
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: LIST
37057: LIST
37058: LIST
37059: LIST
37060: LIST
37061: LIST
37062: LIST
37063: LIST
37064: LIST
37065: LIST
37066: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37067: LD_ADDR_VAR 0 51
37071: PUSH
37072: LD_INT 0
37074: PUSH
37075: LD_INT 0
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 0
37084: PUSH
37085: LD_INT 1
37087: NEG
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: LD_INT 1
37095: PUSH
37096: LD_INT 0
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 1
37105: PUSH
37106: LD_INT 1
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 0
37115: PUSH
37116: LD_INT 1
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 1
37125: NEG
37126: PUSH
37127: LD_INT 0
37129: PUSH
37130: EMPTY
37131: LIST
37132: LIST
37133: PUSH
37134: LD_INT 1
37136: NEG
37137: PUSH
37138: LD_INT 1
37140: NEG
37141: PUSH
37142: EMPTY
37143: LIST
37144: LIST
37145: PUSH
37146: LD_INT 1
37148: PUSH
37149: LD_INT 2
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 0
37158: PUSH
37159: LD_INT 2
37161: PUSH
37162: EMPTY
37163: LIST
37164: LIST
37165: PUSH
37166: LD_INT 1
37168: NEG
37169: PUSH
37170: LD_INT 1
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PUSH
37177: LD_INT 2
37179: NEG
37180: PUSH
37181: LD_INT 0
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: PUSH
37188: LD_INT 2
37190: NEG
37191: PUSH
37192: LD_INT 1
37194: NEG
37195: PUSH
37196: EMPTY
37197: LIST
37198: LIST
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: LIST
37204: LIST
37205: LIST
37206: LIST
37207: LIST
37208: LIST
37209: LIST
37210: LIST
37211: LIST
37212: LIST
37213: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37214: LD_ADDR_VAR 0 52
37218: PUSH
37219: LD_INT 0
37221: PUSH
37222: LD_INT 0
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: PUSH
37229: LD_INT 0
37231: PUSH
37232: LD_INT 1
37234: NEG
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: PUSH
37240: LD_INT 1
37242: PUSH
37243: LD_INT 0
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 1
37252: PUSH
37253: LD_INT 1
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 0
37262: PUSH
37263: LD_INT 1
37265: PUSH
37266: EMPTY
37267: LIST
37268: LIST
37269: PUSH
37270: LD_INT 1
37272: NEG
37273: PUSH
37274: LD_INT 0
37276: PUSH
37277: EMPTY
37278: LIST
37279: LIST
37280: PUSH
37281: LD_INT 1
37283: NEG
37284: PUSH
37285: LD_INT 1
37287: NEG
37288: PUSH
37289: EMPTY
37290: LIST
37291: LIST
37292: PUSH
37293: LD_INT 1
37295: NEG
37296: PUSH
37297: LD_INT 2
37299: NEG
37300: PUSH
37301: EMPTY
37302: LIST
37303: LIST
37304: PUSH
37305: LD_INT 1
37307: NEG
37308: PUSH
37309: LD_INT 1
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: LD_INT 2
37318: NEG
37319: PUSH
37320: LD_INT 0
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: LD_INT 2
37329: NEG
37330: PUSH
37331: LD_INT 1
37333: NEG
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: PUSH
37339: LD_INT 2
37341: NEG
37342: PUSH
37343: LD_INT 2
37345: NEG
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: EMPTY
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37365: LD_ADDR_VAR 0 53
37369: PUSH
37370: LD_INT 0
37372: PUSH
37373: LD_INT 0
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PUSH
37380: LD_INT 0
37382: PUSH
37383: LD_INT 1
37385: NEG
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 1
37393: PUSH
37394: LD_INT 0
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: LD_INT 1
37403: PUSH
37404: LD_INT 1
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PUSH
37411: LD_INT 0
37413: PUSH
37414: LD_INT 1
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: PUSH
37421: LD_INT 1
37423: NEG
37424: PUSH
37425: LD_INT 0
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: LD_INT 1
37438: NEG
37439: PUSH
37440: EMPTY
37441: LIST
37442: LIST
37443: PUSH
37444: LD_INT 1
37446: NEG
37447: PUSH
37448: LD_INT 2
37450: NEG
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: LD_INT 0
37458: PUSH
37459: LD_INT 2
37461: NEG
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: LD_INT 1
37469: PUSH
37470: LD_INT 1
37472: NEG
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 2
37480: PUSH
37481: LD_INT 0
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PUSH
37488: LD_INT 2
37490: PUSH
37491: LD_INT 1
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 2
37500: PUSH
37501: LD_INT 2
37503: PUSH
37504: EMPTY
37505: LIST
37506: LIST
37507: PUSH
37508: LD_INT 1
37510: PUSH
37511: LD_INT 2
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 0
37520: PUSH
37521: LD_INT 2
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: LD_INT 1
37530: NEG
37531: PUSH
37532: LD_INT 1
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: PUSH
37539: LD_INT 2
37541: NEG
37542: PUSH
37543: LD_INT 0
37545: PUSH
37546: EMPTY
37547: LIST
37548: LIST
37549: PUSH
37550: LD_INT 2
37552: NEG
37553: PUSH
37554: LD_INT 1
37556: NEG
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 2
37564: NEG
37565: PUSH
37566: LD_INT 2
37568: NEG
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: LIST
37585: LIST
37586: LIST
37587: LIST
37588: LIST
37589: LIST
37590: LIST
37591: LIST
37592: LIST
37593: LIST
37594: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37595: LD_ADDR_VAR 0 54
37599: PUSH
37600: LD_INT 0
37602: PUSH
37603: LD_INT 0
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 0
37612: PUSH
37613: LD_INT 1
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: PUSH
37624: LD_INT 0
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 1
37633: PUSH
37634: LD_INT 1
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 0
37643: PUSH
37644: LD_INT 1
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 1
37653: NEG
37654: PUSH
37655: LD_INT 0
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 1
37664: NEG
37665: PUSH
37666: LD_INT 1
37668: NEG
37669: PUSH
37670: EMPTY
37671: LIST
37672: LIST
37673: PUSH
37674: LD_INT 1
37676: NEG
37677: PUSH
37678: LD_INT 2
37680: NEG
37681: PUSH
37682: EMPTY
37683: LIST
37684: LIST
37685: PUSH
37686: LD_INT 0
37688: PUSH
37689: LD_INT 2
37691: NEG
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: LD_INT 1
37699: PUSH
37700: LD_INT 1
37702: NEG
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: LD_INT 2
37710: PUSH
37711: LD_INT 0
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: LD_INT 2
37720: PUSH
37721: LD_INT 1
37723: PUSH
37724: EMPTY
37725: LIST
37726: LIST
37727: PUSH
37728: LD_INT 2
37730: PUSH
37731: LD_INT 2
37733: PUSH
37734: EMPTY
37735: LIST
37736: LIST
37737: PUSH
37738: LD_INT 1
37740: PUSH
37741: LD_INT 2
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: LD_INT 2
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 1
37760: NEG
37761: PUSH
37762: LD_INT 1
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 2
37771: NEG
37772: PUSH
37773: LD_INT 0
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: LD_INT 2
37782: NEG
37783: PUSH
37784: LD_INT 1
37786: NEG
37787: PUSH
37788: EMPTY
37789: LIST
37790: LIST
37791: PUSH
37792: LD_INT 2
37794: NEG
37795: PUSH
37796: LD_INT 2
37798: NEG
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: LIST
37810: LIST
37811: LIST
37812: LIST
37813: LIST
37814: LIST
37815: LIST
37816: LIST
37817: LIST
37818: LIST
37819: LIST
37820: LIST
37821: LIST
37822: LIST
37823: LIST
37824: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37825: LD_ADDR_VAR 0 55
37829: PUSH
37830: LD_INT 0
37832: PUSH
37833: LD_INT 0
37835: PUSH
37836: EMPTY
37837: LIST
37838: LIST
37839: PUSH
37840: LD_INT 0
37842: PUSH
37843: LD_INT 1
37845: NEG
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 1
37853: PUSH
37854: LD_INT 0
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 1
37863: PUSH
37864: LD_INT 1
37866: PUSH
37867: EMPTY
37868: LIST
37869: LIST
37870: PUSH
37871: LD_INT 0
37873: PUSH
37874: LD_INT 1
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 1
37883: NEG
37884: PUSH
37885: LD_INT 0
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: PUSH
37892: LD_INT 1
37894: NEG
37895: PUSH
37896: LD_INT 1
37898: NEG
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: LD_INT 1
37906: NEG
37907: PUSH
37908: LD_INT 2
37910: NEG
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: PUSH
37916: LD_INT 0
37918: PUSH
37919: LD_INT 2
37921: NEG
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: PUSH
37927: LD_INT 1
37929: PUSH
37930: LD_INT 1
37932: NEG
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 2
37940: PUSH
37941: LD_INT 0
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 2
37950: PUSH
37951: LD_INT 1
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: LD_INT 2
37960: PUSH
37961: LD_INT 2
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 1
37970: PUSH
37971: LD_INT 2
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 0
37980: PUSH
37981: LD_INT 2
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: PUSH
37988: LD_INT 1
37990: NEG
37991: PUSH
37992: LD_INT 1
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 2
38001: NEG
38002: PUSH
38003: LD_INT 0
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 2
38012: NEG
38013: PUSH
38014: LD_INT 1
38016: NEG
38017: PUSH
38018: EMPTY
38019: LIST
38020: LIST
38021: PUSH
38022: LD_INT 2
38024: NEG
38025: PUSH
38026: LD_INT 2
38028: NEG
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38055: LD_ADDR_VAR 0 56
38059: PUSH
38060: LD_INT 0
38062: PUSH
38063: LD_INT 0
38065: PUSH
38066: EMPTY
38067: LIST
38068: LIST
38069: PUSH
38070: LD_INT 0
38072: PUSH
38073: LD_INT 1
38075: NEG
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 1
38083: PUSH
38084: LD_INT 0
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 1
38093: PUSH
38094: LD_INT 1
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: LD_INT 0
38103: PUSH
38104: LD_INT 1
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PUSH
38111: LD_INT 1
38113: NEG
38114: PUSH
38115: LD_INT 0
38117: PUSH
38118: EMPTY
38119: LIST
38120: LIST
38121: PUSH
38122: LD_INT 1
38124: NEG
38125: PUSH
38126: LD_INT 1
38128: NEG
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: LD_INT 1
38136: NEG
38137: PUSH
38138: LD_INT 2
38140: NEG
38141: PUSH
38142: EMPTY
38143: LIST
38144: LIST
38145: PUSH
38146: LD_INT 0
38148: PUSH
38149: LD_INT 2
38151: NEG
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: LD_INT 1
38159: PUSH
38160: LD_INT 1
38162: NEG
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 2
38170: PUSH
38171: LD_INT 0
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: LD_INT 2
38180: PUSH
38181: LD_INT 1
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: LD_INT 2
38190: PUSH
38191: LD_INT 2
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: LD_INT 1
38200: PUSH
38201: LD_INT 2
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: PUSH
38208: LD_INT 0
38210: PUSH
38211: LD_INT 2
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 1
38220: NEG
38221: PUSH
38222: LD_INT 1
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: PUSH
38229: LD_INT 2
38231: NEG
38232: PUSH
38233: LD_INT 0
38235: PUSH
38236: EMPTY
38237: LIST
38238: LIST
38239: PUSH
38240: LD_INT 2
38242: NEG
38243: PUSH
38244: LD_INT 1
38246: NEG
38247: PUSH
38248: EMPTY
38249: LIST
38250: LIST
38251: PUSH
38252: LD_INT 2
38254: NEG
38255: PUSH
38256: LD_INT 2
38258: NEG
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: LIST
38275: LIST
38276: LIST
38277: LIST
38278: LIST
38279: LIST
38280: LIST
38281: LIST
38282: LIST
38283: LIST
38284: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38285: LD_ADDR_VAR 0 57
38289: PUSH
38290: LD_INT 0
38292: PUSH
38293: LD_INT 0
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 0
38302: PUSH
38303: LD_INT 1
38305: NEG
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 1
38313: PUSH
38314: LD_INT 0
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 1
38323: PUSH
38324: LD_INT 1
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: LD_INT 0
38333: PUSH
38334: LD_INT 1
38336: PUSH
38337: EMPTY
38338: LIST
38339: LIST
38340: PUSH
38341: LD_INT 1
38343: NEG
38344: PUSH
38345: LD_INT 0
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: PUSH
38352: LD_INT 1
38354: NEG
38355: PUSH
38356: LD_INT 1
38358: NEG
38359: PUSH
38360: EMPTY
38361: LIST
38362: LIST
38363: PUSH
38364: LD_INT 1
38366: NEG
38367: PUSH
38368: LD_INT 2
38370: NEG
38371: PUSH
38372: EMPTY
38373: LIST
38374: LIST
38375: PUSH
38376: LD_INT 0
38378: PUSH
38379: LD_INT 2
38381: NEG
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: LD_INT 1
38392: NEG
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 2
38400: PUSH
38401: LD_INT 0
38403: PUSH
38404: EMPTY
38405: LIST
38406: LIST
38407: PUSH
38408: LD_INT 2
38410: PUSH
38411: LD_INT 1
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 2
38420: PUSH
38421: LD_INT 2
38423: PUSH
38424: EMPTY
38425: LIST
38426: LIST
38427: PUSH
38428: LD_INT 1
38430: PUSH
38431: LD_INT 2
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 0
38440: PUSH
38441: LD_INT 2
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 1
38450: NEG
38451: PUSH
38452: LD_INT 1
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PUSH
38459: LD_INT 2
38461: NEG
38462: PUSH
38463: LD_INT 0
38465: PUSH
38466: EMPTY
38467: LIST
38468: LIST
38469: PUSH
38470: LD_INT 2
38472: NEG
38473: PUSH
38474: LD_INT 1
38476: NEG
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 2
38484: NEG
38485: PUSH
38486: LD_INT 2
38488: NEG
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: LIST
38498: LIST
38499: LIST
38500: LIST
38501: LIST
38502: LIST
38503: LIST
38504: LIST
38505: LIST
38506: LIST
38507: LIST
38508: LIST
38509: LIST
38510: LIST
38511: LIST
38512: LIST
38513: LIST
38514: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38515: LD_ADDR_VAR 0 58
38519: PUSH
38520: LD_INT 0
38522: PUSH
38523: LD_INT 0
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: LD_INT 0
38532: PUSH
38533: LD_INT 1
38535: NEG
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 1
38543: PUSH
38544: LD_INT 0
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 1
38553: PUSH
38554: LD_INT 1
38556: PUSH
38557: EMPTY
38558: LIST
38559: LIST
38560: PUSH
38561: LD_INT 0
38563: PUSH
38564: LD_INT 1
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: LD_INT 1
38573: NEG
38574: PUSH
38575: LD_INT 0
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: LD_INT 1
38588: NEG
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 1
38596: NEG
38597: PUSH
38598: LD_INT 2
38600: NEG
38601: PUSH
38602: EMPTY
38603: LIST
38604: LIST
38605: PUSH
38606: LD_INT 0
38608: PUSH
38609: LD_INT 2
38611: NEG
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 1
38619: PUSH
38620: LD_INT 1
38622: NEG
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PUSH
38628: LD_INT 2
38630: PUSH
38631: LD_INT 0
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 2
38640: PUSH
38641: LD_INT 1
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 2
38650: PUSH
38651: LD_INT 2
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 1
38660: PUSH
38661: LD_INT 2
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 0
38670: PUSH
38671: LD_INT 2
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 1
38680: NEG
38681: PUSH
38682: LD_INT 1
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 2
38691: NEG
38692: PUSH
38693: LD_INT 0
38695: PUSH
38696: EMPTY
38697: LIST
38698: LIST
38699: PUSH
38700: LD_INT 2
38702: NEG
38703: PUSH
38704: LD_INT 1
38706: NEG
38707: PUSH
38708: EMPTY
38709: LIST
38710: LIST
38711: PUSH
38712: LD_INT 2
38714: NEG
38715: PUSH
38716: LD_INT 2
38718: NEG
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: LIST
38728: LIST
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: LIST
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: LIST
38744: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38745: LD_ADDR_VAR 0 59
38749: PUSH
38750: LD_INT 0
38752: PUSH
38753: LD_INT 0
38755: PUSH
38756: EMPTY
38757: LIST
38758: LIST
38759: PUSH
38760: LD_INT 0
38762: PUSH
38763: LD_INT 1
38765: NEG
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 1
38773: PUSH
38774: LD_INT 0
38776: PUSH
38777: EMPTY
38778: LIST
38779: LIST
38780: PUSH
38781: LD_INT 1
38783: PUSH
38784: LD_INT 1
38786: PUSH
38787: EMPTY
38788: LIST
38789: LIST
38790: PUSH
38791: LD_INT 0
38793: PUSH
38794: LD_INT 1
38796: PUSH
38797: EMPTY
38798: LIST
38799: LIST
38800: PUSH
38801: LD_INT 1
38803: NEG
38804: PUSH
38805: LD_INT 0
38807: PUSH
38808: EMPTY
38809: LIST
38810: LIST
38811: PUSH
38812: LD_INT 1
38814: NEG
38815: PUSH
38816: LD_INT 1
38818: NEG
38819: PUSH
38820: EMPTY
38821: LIST
38822: LIST
38823: PUSH
38824: EMPTY
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38833: LD_ADDR_VAR 0 60
38837: PUSH
38838: LD_INT 0
38840: PUSH
38841: LD_INT 0
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 0
38850: PUSH
38851: LD_INT 1
38853: NEG
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 1
38861: PUSH
38862: LD_INT 0
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: PUSH
38869: LD_INT 1
38871: PUSH
38872: LD_INT 1
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: LD_INT 0
38881: PUSH
38882: LD_INT 1
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: LD_INT 1
38891: NEG
38892: PUSH
38893: LD_INT 0
38895: PUSH
38896: EMPTY
38897: LIST
38898: LIST
38899: PUSH
38900: LD_INT 1
38902: NEG
38903: PUSH
38904: LD_INT 1
38906: NEG
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: EMPTY
38913: LIST
38914: LIST
38915: LIST
38916: LIST
38917: LIST
38918: LIST
38919: LIST
38920: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38921: LD_ADDR_VAR 0 61
38925: PUSH
38926: LD_INT 0
38928: PUSH
38929: LD_INT 0
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: PUSH
38936: LD_INT 0
38938: PUSH
38939: LD_INT 1
38941: NEG
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PUSH
38947: LD_INT 1
38949: PUSH
38950: LD_INT 0
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: PUSH
38957: LD_INT 1
38959: PUSH
38960: LD_INT 1
38962: PUSH
38963: EMPTY
38964: LIST
38965: LIST
38966: PUSH
38967: LD_INT 0
38969: PUSH
38970: LD_INT 1
38972: PUSH
38973: EMPTY
38974: LIST
38975: LIST
38976: PUSH
38977: LD_INT 1
38979: NEG
38980: PUSH
38981: LD_INT 0
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 1
38990: NEG
38991: PUSH
38992: LD_INT 1
38994: NEG
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: LIST
39004: LIST
39005: LIST
39006: LIST
39007: LIST
39008: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39009: LD_ADDR_VAR 0 62
39013: PUSH
39014: LD_INT 0
39016: PUSH
39017: LD_INT 0
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PUSH
39024: LD_INT 0
39026: PUSH
39027: LD_INT 1
39029: NEG
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 1
39037: PUSH
39038: LD_INT 0
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 1
39047: PUSH
39048: LD_INT 1
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: LD_INT 0
39057: PUSH
39058: LD_INT 1
39060: PUSH
39061: EMPTY
39062: LIST
39063: LIST
39064: PUSH
39065: LD_INT 1
39067: NEG
39068: PUSH
39069: LD_INT 0
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: PUSH
39076: LD_INT 1
39078: NEG
39079: PUSH
39080: LD_INT 1
39082: NEG
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: LIST
39096: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39097: LD_ADDR_VAR 0 63
39101: PUSH
39102: LD_INT 0
39104: PUSH
39105: LD_INT 0
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 0
39114: PUSH
39115: LD_INT 1
39117: NEG
39118: PUSH
39119: EMPTY
39120: LIST
39121: LIST
39122: PUSH
39123: LD_INT 1
39125: PUSH
39126: LD_INT 0
39128: PUSH
39129: EMPTY
39130: LIST
39131: LIST
39132: PUSH
39133: LD_INT 1
39135: PUSH
39136: LD_INT 1
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 0
39145: PUSH
39146: LD_INT 1
39148: PUSH
39149: EMPTY
39150: LIST
39151: LIST
39152: PUSH
39153: LD_INT 1
39155: NEG
39156: PUSH
39157: LD_INT 0
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 1
39166: NEG
39167: PUSH
39168: LD_INT 1
39170: NEG
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: LIST
39180: LIST
39181: LIST
39182: LIST
39183: LIST
39184: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39185: LD_ADDR_VAR 0 64
39189: PUSH
39190: LD_INT 0
39192: PUSH
39193: LD_INT 0
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 0
39202: PUSH
39203: LD_INT 1
39205: NEG
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: PUSH
39211: LD_INT 1
39213: PUSH
39214: LD_INT 0
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 1
39223: PUSH
39224: LD_INT 1
39226: PUSH
39227: EMPTY
39228: LIST
39229: LIST
39230: PUSH
39231: LD_INT 0
39233: PUSH
39234: LD_INT 1
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: PUSH
39241: LD_INT 1
39243: NEG
39244: PUSH
39245: LD_INT 0
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 1
39254: NEG
39255: PUSH
39256: LD_INT 1
39258: NEG
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: PUSH
39264: EMPTY
39265: LIST
39266: LIST
39267: LIST
39268: LIST
39269: LIST
39270: LIST
39271: LIST
39272: ST_TO_ADDR
// end ; 1 :
39273: GO 45170
39275: LD_INT 1
39277: DOUBLE
39278: EQUAL
39279: IFTRUE 39283
39281: GO 41906
39283: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39284: LD_ADDR_VAR 0 11
39288: PUSH
39289: LD_INT 1
39291: NEG
39292: PUSH
39293: LD_INT 3
39295: NEG
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: LD_INT 0
39303: PUSH
39304: LD_INT 3
39306: NEG
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 1
39314: PUSH
39315: LD_INT 2
39317: NEG
39318: PUSH
39319: EMPTY
39320: LIST
39321: LIST
39322: PUSH
39323: EMPTY
39324: LIST
39325: LIST
39326: LIST
39327: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39328: LD_ADDR_VAR 0 12
39332: PUSH
39333: LD_INT 2
39335: PUSH
39336: LD_INT 1
39338: NEG
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 3
39346: PUSH
39347: LD_INT 0
39349: PUSH
39350: EMPTY
39351: LIST
39352: LIST
39353: PUSH
39354: LD_INT 3
39356: PUSH
39357: LD_INT 1
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: LIST
39368: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39369: LD_ADDR_VAR 0 13
39373: PUSH
39374: LD_INT 3
39376: PUSH
39377: LD_INT 2
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 3
39386: PUSH
39387: LD_INT 3
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 2
39396: PUSH
39397: LD_INT 3
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: LIST
39408: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39409: LD_ADDR_VAR 0 14
39413: PUSH
39414: LD_INT 1
39416: PUSH
39417: LD_INT 3
39419: PUSH
39420: EMPTY
39421: LIST
39422: LIST
39423: PUSH
39424: LD_INT 0
39426: PUSH
39427: LD_INT 3
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PUSH
39434: LD_INT 1
39436: NEG
39437: PUSH
39438: LD_INT 2
39440: PUSH
39441: EMPTY
39442: LIST
39443: LIST
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: LIST
39449: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39450: LD_ADDR_VAR 0 15
39454: PUSH
39455: LD_INT 2
39457: NEG
39458: PUSH
39459: LD_INT 1
39461: PUSH
39462: EMPTY
39463: LIST
39464: LIST
39465: PUSH
39466: LD_INT 3
39468: NEG
39469: PUSH
39470: LD_INT 0
39472: PUSH
39473: EMPTY
39474: LIST
39475: LIST
39476: PUSH
39477: LD_INT 3
39479: NEG
39480: PUSH
39481: LD_INT 1
39483: NEG
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: LIST
39493: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39494: LD_ADDR_VAR 0 16
39498: PUSH
39499: LD_INT 2
39501: NEG
39502: PUSH
39503: LD_INT 3
39505: NEG
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PUSH
39511: LD_INT 3
39513: NEG
39514: PUSH
39515: LD_INT 2
39517: NEG
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 3
39525: NEG
39526: PUSH
39527: LD_INT 3
39529: NEG
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: LIST
39539: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39540: LD_ADDR_VAR 0 17
39544: PUSH
39545: LD_INT 1
39547: NEG
39548: PUSH
39549: LD_INT 3
39551: NEG
39552: PUSH
39553: EMPTY
39554: LIST
39555: LIST
39556: PUSH
39557: LD_INT 0
39559: PUSH
39560: LD_INT 3
39562: NEG
39563: PUSH
39564: EMPTY
39565: LIST
39566: LIST
39567: PUSH
39568: LD_INT 1
39570: PUSH
39571: LD_INT 2
39573: NEG
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: LIST
39583: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39584: LD_ADDR_VAR 0 18
39588: PUSH
39589: LD_INT 2
39591: PUSH
39592: LD_INT 1
39594: NEG
39595: PUSH
39596: EMPTY
39597: LIST
39598: LIST
39599: PUSH
39600: LD_INT 3
39602: PUSH
39603: LD_INT 0
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: PUSH
39610: LD_INT 3
39612: PUSH
39613: LD_INT 1
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: LIST
39624: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39625: LD_ADDR_VAR 0 19
39629: PUSH
39630: LD_INT 3
39632: PUSH
39633: LD_INT 2
39635: PUSH
39636: EMPTY
39637: LIST
39638: LIST
39639: PUSH
39640: LD_INT 3
39642: PUSH
39643: LD_INT 3
39645: PUSH
39646: EMPTY
39647: LIST
39648: LIST
39649: PUSH
39650: LD_INT 2
39652: PUSH
39653: LD_INT 3
39655: PUSH
39656: EMPTY
39657: LIST
39658: LIST
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: LIST
39664: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39665: LD_ADDR_VAR 0 20
39669: PUSH
39670: LD_INT 1
39672: PUSH
39673: LD_INT 3
39675: PUSH
39676: EMPTY
39677: LIST
39678: LIST
39679: PUSH
39680: LD_INT 0
39682: PUSH
39683: LD_INT 3
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 1
39692: NEG
39693: PUSH
39694: LD_INT 2
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: LIST
39705: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39706: LD_ADDR_VAR 0 21
39710: PUSH
39711: LD_INT 2
39713: NEG
39714: PUSH
39715: LD_INT 1
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: PUSH
39722: LD_INT 3
39724: NEG
39725: PUSH
39726: LD_INT 0
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PUSH
39733: LD_INT 3
39735: NEG
39736: PUSH
39737: LD_INT 1
39739: NEG
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: LIST
39749: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39750: LD_ADDR_VAR 0 22
39754: PUSH
39755: LD_INT 2
39757: NEG
39758: PUSH
39759: LD_INT 3
39761: NEG
39762: PUSH
39763: EMPTY
39764: LIST
39765: LIST
39766: PUSH
39767: LD_INT 3
39769: NEG
39770: PUSH
39771: LD_INT 2
39773: NEG
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 3
39781: NEG
39782: PUSH
39783: LD_INT 3
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: LIST
39795: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39796: LD_ADDR_VAR 0 23
39800: PUSH
39801: LD_INT 0
39803: PUSH
39804: LD_INT 3
39806: NEG
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 1
39814: NEG
39815: PUSH
39816: LD_INT 4
39818: NEG
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 1
39826: PUSH
39827: LD_INT 3
39829: NEG
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: LIST
39839: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39840: LD_ADDR_VAR 0 24
39844: PUSH
39845: LD_INT 3
39847: PUSH
39848: LD_INT 0
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 3
39857: PUSH
39858: LD_INT 1
39860: NEG
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 4
39868: PUSH
39869: LD_INT 1
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: LIST
39880: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39881: LD_ADDR_VAR 0 25
39885: PUSH
39886: LD_INT 3
39888: PUSH
39889: LD_INT 3
39891: PUSH
39892: EMPTY
39893: LIST
39894: LIST
39895: PUSH
39896: LD_INT 4
39898: PUSH
39899: LD_INT 3
39901: PUSH
39902: EMPTY
39903: LIST
39904: LIST
39905: PUSH
39906: LD_INT 3
39908: PUSH
39909: LD_INT 4
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: LIST
39920: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39921: LD_ADDR_VAR 0 26
39925: PUSH
39926: LD_INT 0
39928: PUSH
39929: LD_INT 3
39931: PUSH
39932: EMPTY
39933: LIST
39934: LIST
39935: PUSH
39936: LD_INT 1
39938: PUSH
39939: LD_INT 4
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PUSH
39946: LD_INT 1
39948: NEG
39949: PUSH
39950: LD_INT 3
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: LIST
39961: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
39962: LD_ADDR_VAR 0 27
39966: PUSH
39967: LD_INT 3
39969: NEG
39970: PUSH
39971: LD_INT 0
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: PUSH
39978: LD_INT 3
39980: NEG
39981: PUSH
39982: LD_INT 1
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 4
39991: NEG
39992: PUSH
39993: LD_INT 1
39995: NEG
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: EMPTY
40002: LIST
40003: LIST
40004: LIST
40005: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40006: LD_ADDR_VAR 0 28
40010: PUSH
40011: LD_INT 3
40013: NEG
40014: PUSH
40015: LD_INT 3
40017: NEG
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PUSH
40023: LD_INT 3
40025: NEG
40026: PUSH
40027: LD_INT 4
40029: NEG
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PUSH
40035: LD_INT 4
40037: NEG
40038: PUSH
40039: LD_INT 3
40041: NEG
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: LIST
40051: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40052: LD_ADDR_VAR 0 29
40056: PUSH
40057: LD_INT 1
40059: NEG
40060: PUSH
40061: LD_INT 3
40063: NEG
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 0
40071: PUSH
40072: LD_INT 3
40074: NEG
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: LD_INT 1
40082: PUSH
40083: LD_INT 2
40085: NEG
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 1
40093: NEG
40094: PUSH
40095: LD_INT 4
40097: NEG
40098: PUSH
40099: EMPTY
40100: LIST
40101: LIST
40102: PUSH
40103: LD_INT 0
40105: PUSH
40106: LD_INT 4
40108: NEG
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PUSH
40114: LD_INT 1
40116: PUSH
40117: LD_INT 3
40119: NEG
40120: PUSH
40121: EMPTY
40122: LIST
40123: LIST
40124: PUSH
40125: LD_INT 1
40127: NEG
40128: PUSH
40129: LD_INT 5
40131: NEG
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PUSH
40137: LD_INT 0
40139: PUSH
40140: LD_INT 5
40142: NEG
40143: PUSH
40144: EMPTY
40145: LIST
40146: LIST
40147: PUSH
40148: LD_INT 1
40150: PUSH
40151: LD_INT 4
40153: NEG
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: PUSH
40159: LD_INT 1
40161: NEG
40162: PUSH
40163: LD_INT 6
40165: NEG
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: PUSH
40171: LD_INT 0
40173: PUSH
40174: LD_INT 6
40176: NEG
40177: PUSH
40178: EMPTY
40179: LIST
40180: LIST
40181: PUSH
40182: LD_INT 1
40184: PUSH
40185: LD_INT 5
40187: NEG
40188: PUSH
40189: EMPTY
40190: LIST
40191: LIST
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: LIST
40197: LIST
40198: LIST
40199: LIST
40200: LIST
40201: LIST
40202: LIST
40203: LIST
40204: LIST
40205: LIST
40206: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40207: LD_ADDR_VAR 0 30
40211: PUSH
40212: LD_INT 2
40214: PUSH
40215: LD_INT 1
40217: NEG
40218: PUSH
40219: EMPTY
40220: LIST
40221: LIST
40222: PUSH
40223: LD_INT 3
40225: PUSH
40226: LD_INT 0
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: LD_INT 3
40235: PUSH
40236: LD_INT 1
40238: PUSH
40239: EMPTY
40240: LIST
40241: LIST
40242: PUSH
40243: LD_INT 3
40245: PUSH
40246: LD_INT 1
40248: NEG
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 4
40256: PUSH
40257: LD_INT 0
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 4
40266: PUSH
40267: LD_INT 1
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 4
40276: PUSH
40277: LD_INT 1
40279: NEG
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 5
40287: PUSH
40288: LD_INT 0
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 5
40297: PUSH
40298: LD_INT 1
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: LD_INT 5
40307: PUSH
40308: LD_INT 1
40310: NEG
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: LD_INT 6
40318: PUSH
40319: LD_INT 0
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 6
40328: PUSH
40329: LD_INT 1
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: LIST
40340: LIST
40341: LIST
40342: LIST
40343: LIST
40344: LIST
40345: LIST
40346: LIST
40347: LIST
40348: LIST
40349: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
40350: LD_ADDR_VAR 0 31
40354: PUSH
40355: LD_INT 3
40357: PUSH
40358: LD_INT 2
40360: PUSH
40361: EMPTY
40362: LIST
40363: LIST
40364: PUSH
40365: LD_INT 3
40367: PUSH
40368: LD_INT 3
40370: PUSH
40371: EMPTY
40372: LIST
40373: LIST
40374: PUSH
40375: LD_INT 2
40377: PUSH
40378: LD_INT 3
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: LD_INT 4
40387: PUSH
40388: LD_INT 3
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: PUSH
40395: LD_INT 4
40397: PUSH
40398: LD_INT 4
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 3
40407: PUSH
40408: LD_INT 4
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: PUSH
40415: LD_INT 5
40417: PUSH
40418: LD_INT 4
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: PUSH
40425: LD_INT 5
40427: PUSH
40428: LD_INT 5
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: PUSH
40435: LD_INT 4
40437: PUSH
40438: LD_INT 5
40440: PUSH
40441: EMPTY
40442: LIST
40443: LIST
40444: PUSH
40445: LD_INT 6
40447: PUSH
40448: LD_INT 5
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: LD_INT 6
40457: PUSH
40458: LD_INT 6
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: LD_INT 5
40467: PUSH
40468: LD_INT 6
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: LIST
40479: LIST
40480: LIST
40481: LIST
40482: LIST
40483: LIST
40484: LIST
40485: LIST
40486: LIST
40487: LIST
40488: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40489: LD_ADDR_VAR 0 32
40493: PUSH
40494: LD_INT 1
40496: PUSH
40497: LD_INT 3
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 0
40506: PUSH
40507: LD_INT 3
40509: PUSH
40510: EMPTY
40511: LIST
40512: LIST
40513: PUSH
40514: LD_INT 1
40516: NEG
40517: PUSH
40518: LD_INT 2
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 1
40527: PUSH
40528: LD_INT 4
40530: PUSH
40531: EMPTY
40532: LIST
40533: LIST
40534: PUSH
40535: LD_INT 0
40537: PUSH
40538: LD_INT 4
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: PUSH
40545: LD_INT 1
40547: NEG
40548: PUSH
40549: LD_INT 3
40551: PUSH
40552: EMPTY
40553: LIST
40554: LIST
40555: PUSH
40556: LD_INT 1
40558: PUSH
40559: LD_INT 5
40561: PUSH
40562: EMPTY
40563: LIST
40564: LIST
40565: PUSH
40566: LD_INT 0
40568: PUSH
40569: LD_INT 5
40571: PUSH
40572: EMPTY
40573: LIST
40574: LIST
40575: PUSH
40576: LD_INT 1
40578: NEG
40579: PUSH
40580: LD_INT 4
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: PUSH
40587: LD_INT 1
40589: PUSH
40590: LD_INT 6
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: PUSH
40597: LD_INT 0
40599: PUSH
40600: LD_INT 6
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PUSH
40607: LD_INT 1
40609: NEG
40610: PUSH
40611: LD_INT 5
40613: PUSH
40614: EMPTY
40615: LIST
40616: LIST
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: LIST
40622: LIST
40623: LIST
40624: LIST
40625: LIST
40626: LIST
40627: LIST
40628: LIST
40629: LIST
40630: LIST
40631: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
40632: LD_ADDR_VAR 0 33
40636: PUSH
40637: LD_INT 2
40639: NEG
40640: PUSH
40641: LD_INT 1
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: PUSH
40648: LD_INT 3
40650: NEG
40651: PUSH
40652: LD_INT 0
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 3
40661: NEG
40662: PUSH
40663: LD_INT 1
40665: NEG
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PUSH
40671: LD_INT 3
40673: NEG
40674: PUSH
40675: LD_INT 1
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PUSH
40682: LD_INT 4
40684: NEG
40685: PUSH
40686: LD_INT 0
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: PUSH
40693: LD_INT 4
40695: NEG
40696: PUSH
40697: LD_INT 1
40699: NEG
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: PUSH
40705: LD_INT 4
40707: NEG
40708: PUSH
40709: LD_INT 1
40711: PUSH
40712: EMPTY
40713: LIST
40714: LIST
40715: PUSH
40716: LD_INT 5
40718: NEG
40719: PUSH
40720: LD_INT 0
40722: PUSH
40723: EMPTY
40724: LIST
40725: LIST
40726: PUSH
40727: LD_INT 5
40729: NEG
40730: PUSH
40731: LD_INT 1
40733: NEG
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: LD_INT 5
40741: NEG
40742: PUSH
40743: LD_INT 1
40745: PUSH
40746: EMPTY
40747: LIST
40748: LIST
40749: PUSH
40750: LD_INT 6
40752: NEG
40753: PUSH
40754: LD_INT 0
40756: PUSH
40757: EMPTY
40758: LIST
40759: LIST
40760: PUSH
40761: LD_INT 6
40763: NEG
40764: PUSH
40765: LD_INT 1
40767: NEG
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: LIST
40777: LIST
40778: LIST
40779: LIST
40780: LIST
40781: LIST
40782: LIST
40783: LIST
40784: LIST
40785: LIST
40786: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40787: LD_ADDR_VAR 0 34
40791: PUSH
40792: LD_INT 2
40794: NEG
40795: PUSH
40796: LD_INT 3
40798: NEG
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 3
40806: NEG
40807: PUSH
40808: LD_INT 2
40810: NEG
40811: PUSH
40812: EMPTY
40813: LIST
40814: LIST
40815: PUSH
40816: LD_INT 3
40818: NEG
40819: PUSH
40820: LD_INT 3
40822: NEG
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: LD_INT 3
40830: NEG
40831: PUSH
40832: LD_INT 4
40834: NEG
40835: PUSH
40836: EMPTY
40837: LIST
40838: LIST
40839: PUSH
40840: LD_INT 4
40842: NEG
40843: PUSH
40844: LD_INT 3
40846: NEG
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 4
40854: NEG
40855: PUSH
40856: LD_INT 4
40858: NEG
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: PUSH
40864: LD_INT 4
40866: NEG
40867: PUSH
40868: LD_INT 5
40870: NEG
40871: PUSH
40872: EMPTY
40873: LIST
40874: LIST
40875: PUSH
40876: LD_INT 5
40878: NEG
40879: PUSH
40880: LD_INT 4
40882: NEG
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 5
40890: NEG
40891: PUSH
40892: LD_INT 5
40894: NEG
40895: PUSH
40896: EMPTY
40897: LIST
40898: LIST
40899: PUSH
40900: LD_INT 5
40902: NEG
40903: PUSH
40904: LD_INT 6
40906: NEG
40907: PUSH
40908: EMPTY
40909: LIST
40910: LIST
40911: PUSH
40912: LD_INT 6
40914: NEG
40915: PUSH
40916: LD_INT 5
40918: NEG
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: LD_INT 6
40926: NEG
40927: PUSH
40928: LD_INT 6
40930: NEG
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: LIST
40940: LIST
40941: LIST
40942: LIST
40943: LIST
40944: LIST
40945: LIST
40946: LIST
40947: LIST
40948: LIST
40949: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
40950: LD_ADDR_VAR 0 41
40954: PUSH
40955: LD_INT 0
40957: PUSH
40958: LD_INT 2
40960: NEG
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 1
40968: NEG
40969: PUSH
40970: LD_INT 3
40972: NEG
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: PUSH
40978: LD_INT 1
40980: PUSH
40981: LD_INT 2
40983: NEG
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: PUSH
40989: EMPTY
40990: LIST
40991: LIST
40992: LIST
40993: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
40994: LD_ADDR_VAR 0 42
40998: PUSH
40999: LD_INT 2
41001: PUSH
41002: LD_INT 0
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 2
41011: PUSH
41012: LD_INT 1
41014: NEG
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: PUSH
41020: LD_INT 3
41022: PUSH
41023: LD_INT 1
41025: PUSH
41026: EMPTY
41027: LIST
41028: LIST
41029: PUSH
41030: EMPTY
41031: LIST
41032: LIST
41033: LIST
41034: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41035: LD_ADDR_VAR 0 43
41039: PUSH
41040: LD_INT 2
41042: PUSH
41043: LD_INT 2
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: PUSH
41050: LD_INT 3
41052: PUSH
41053: LD_INT 2
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 2
41062: PUSH
41063: LD_INT 3
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: EMPTY
41071: LIST
41072: LIST
41073: LIST
41074: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41075: LD_ADDR_VAR 0 44
41079: PUSH
41080: LD_INT 0
41082: PUSH
41083: LD_INT 2
41085: PUSH
41086: EMPTY
41087: LIST
41088: LIST
41089: PUSH
41090: LD_INT 1
41092: PUSH
41093: LD_INT 3
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 1
41102: NEG
41103: PUSH
41104: LD_INT 2
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: LIST
41115: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41116: LD_ADDR_VAR 0 45
41120: PUSH
41121: LD_INT 2
41123: NEG
41124: PUSH
41125: LD_INT 0
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: LD_INT 2
41134: NEG
41135: PUSH
41136: LD_INT 1
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PUSH
41143: LD_INT 3
41145: NEG
41146: PUSH
41147: LD_INT 1
41149: NEG
41150: PUSH
41151: EMPTY
41152: LIST
41153: LIST
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: LIST
41159: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41160: LD_ADDR_VAR 0 46
41164: PUSH
41165: LD_INT 2
41167: NEG
41168: PUSH
41169: LD_INT 2
41171: NEG
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 2
41179: NEG
41180: PUSH
41181: LD_INT 3
41183: NEG
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: LD_INT 3
41191: NEG
41192: PUSH
41193: LD_INT 2
41195: NEG
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: EMPTY
41202: LIST
41203: LIST
41204: LIST
41205: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41206: LD_ADDR_VAR 0 47
41210: PUSH
41211: LD_INT 2
41213: NEG
41214: PUSH
41215: LD_INT 3
41217: NEG
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: LD_INT 1
41225: NEG
41226: PUSH
41227: LD_INT 3
41229: NEG
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: EMPTY
41236: LIST
41237: LIST
41238: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41239: LD_ADDR_VAR 0 48
41243: PUSH
41244: LD_INT 1
41246: PUSH
41247: LD_INT 2
41249: NEG
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: PUSH
41255: LD_INT 2
41257: PUSH
41258: LD_INT 1
41260: NEG
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: EMPTY
41267: LIST
41268: LIST
41269: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
41270: LD_ADDR_VAR 0 49
41274: PUSH
41275: LD_INT 3
41277: PUSH
41278: LD_INT 1
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: LD_INT 3
41287: PUSH
41288: LD_INT 2
41290: PUSH
41291: EMPTY
41292: LIST
41293: LIST
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
41299: LD_ADDR_VAR 0 50
41303: PUSH
41304: LD_INT 2
41306: PUSH
41307: LD_INT 3
41309: PUSH
41310: EMPTY
41311: LIST
41312: LIST
41313: PUSH
41314: LD_INT 1
41316: PUSH
41317: LD_INT 3
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
41328: LD_ADDR_VAR 0 51
41332: PUSH
41333: LD_INT 1
41335: NEG
41336: PUSH
41337: LD_INT 2
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: LD_INT 2
41346: NEG
41347: PUSH
41348: LD_INT 1
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41359: LD_ADDR_VAR 0 52
41363: PUSH
41364: LD_INT 3
41366: NEG
41367: PUSH
41368: LD_INT 1
41370: NEG
41371: PUSH
41372: EMPTY
41373: LIST
41374: LIST
41375: PUSH
41376: LD_INT 3
41378: NEG
41379: PUSH
41380: LD_INT 2
41382: NEG
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41392: LD_ADDR_VAR 0 53
41396: PUSH
41397: LD_INT 1
41399: NEG
41400: PUSH
41401: LD_INT 3
41403: NEG
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 0
41411: PUSH
41412: LD_INT 3
41414: NEG
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 1
41422: PUSH
41423: LD_INT 2
41425: NEG
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: PUSH
41431: EMPTY
41432: LIST
41433: LIST
41434: LIST
41435: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41436: LD_ADDR_VAR 0 54
41440: PUSH
41441: LD_INT 2
41443: PUSH
41444: LD_INT 1
41446: NEG
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: PUSH
41452: LD_INT 3
41454: PUSH
41455: LD_INT 0
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: LD_INT 3
41464: PUSH
41465: LD_INT 1
41467: PUSH
41468: EMPTY
41469: LIST
41470: LIST
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: LIST
41476: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41477: LD_ADDR_VAR 0 55
41481: PUSH
41482: LD_INT 3
41484: PUSH
41485: LD_INT 2
41487: PUSH
41488: EMPTY
41489: LIST
41490: LIST
41491: PUSH
41492: LD_INT 3
41494: PUSH
41495: LD_INT 3
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: PUSH
41502: LD_INT 2
41504: PUSH
41505: LD_INT 3
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: PUSH
41512: EMPTY
41513: LIST
41514: LIST
41515: LIST
41516: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41517: LD_ADDR_VAR 0 56
41521: PUSH
41522: LD_INT 1
41524: PUSH
41525: LD_INT 3
41527: PUSH
41528: EMPTY
41529: LIST
41530: LIST
41531: PUSH
41532: LD_INT 0
41534: PUSH
41535: LD_INT 3
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: PUSH
41542: LD_INT 1
41544: NEG
41545: PUSH
41546: LD_INT 2
41548: PUSH
41549: EMPTY
41550: LIST
41551: LIST
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: LIST
41557: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41558: LD_ADDR_VAR 0 57
41562: PUSH
41563: LD_INT 2
41565: NEG
41566: PUSH
41567: LD_INT 1
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: PUSH
41574: LD_INT 3
41576: NEG
41577: PUSH
41578: LD_INT 0
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: LD_INT 3
41587: NEG
41588: PUSH
41589: LD_INT 1
41591: NEG
41592: PUSH
41593: EMPTY
41594: LIST
41595: LIST
41596: PUSH
41597: EMPTY
41598: LIST
41599: LIST
41600: LIST
41601: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41602: LD_ADDR_VAR 0 58
41606: PUSH
41607: LD_INT 2
41609: NEG
41610: PUSH
41611: LD_INT 3
41613: NEG
41614: PUSH
41615: EMPTY
41616: LIST
41617: LIST
41618: PUSH
41619: LD_INT 3
41621: NEG
41622: PUSH
41623: LD_INT 2
41625: NEG
41626: PUSH
41627: EMPTY
41628: LIST
41629: LIST
41630: PUSH
41631: LD_INT 3
41633: NEG
41634: PUSH
41635: LD_INT 3
41637: NEG
41638: PUSH
41639: EMPTY
41640: LIST
41641: LIST
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: LIST
41647: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
41648: LD_ADDR_VAR 0 59
41652: PUSH
41653: LD_INT 1
41655: NEG
41656: PUSH
41657: LD_INT 2
41659: NEG
41660: PUSH
41661: EMPTY
41662: LIST
41663: LIST
41664: PUSH
41665: LD_INT 0
41667: PUSH
41668: LD_INT 2
41670: NEG
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 1
41678: PUSH
41679: LD_INT 1
41681: NEG
41682: PUSH
41683: EMPTY
41684: LIST
41685: LIST
41686: PUSH
41687: EMPTY
41688: LIST
41689: LIST
41690: LIST
41691: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41692: LD_ADDR_VAR 0 60
41696: PUSH
41697: LD_INT 1
41699: PUSH
41700: LD_INT 1
41702: NEG
41703: PUSH
41704: EMPTY
41705: LIST
41706: LIST
41707: PUSH
41708: LD_INT 2
41710: PUSH
41711: LD_INT 0
41713: PUSH
41714: EMPTY
41715: LIST
41716: LIST
41717: PUSH
41718: LD_INT 2
41720: PUSH
41721: LD_INT 1
41723: PUSH
41724: EMPTY
41725: LIST
41726: LIST
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: LIST
41732: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41733: LD_ADDR_VAR 0 61
41737: PUSH
41738: LD_INT 2
41740: PUSH
41741: LD_INT 1
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PUSH
41748: LD_INT 2
41750: PUSH
41751: LD_INT 2
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PUSH
41758: LD_INT 1
41760: PUSH
41761: LD_INT 2
41763: PUSH
41764: EMPTY
41765: LIST
41766: LIST
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: LIST
41772: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41773: LD_ADDR_VAR 0 62
41777: PUSH
41778: LD_INT 1
41780: PUSH
41781: LD_INT 2
41783: PUSH
41784: EMPTY
41785: LIST
41786: LIST
41787: PUSH
41788: LD_INT 0
41790: PUSH
41791: LD_INT 2
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PUSH
41798: LD_INT 1
41800: NEG
41801: PUSH
41802: LD_INT 1
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: LIST
41813: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41814: LD_ADDR_VAR 0 63
41818: PUSH
41819: LD_INT 1
41821: NEG
41822: PUSH
41823: LD_INT 1
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 2
41832: NEG
41833: PUSH
41834: LD_INT 0
41836: PUSH
41837: EMPTY
41838: LIST
41839: LIST
41840: PUSH
41841: LD_INT 2
41843: NEG
41844: PUSH
41845: LD_INT 1
41847: NEG
41848: PUSH
41849: EMPTY
41850: LIST
41851: LIST
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: LIST
41857: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41858: LD_ADDR_VAR 0 64
41862: PUSH
41863: LD_INT 1
41865: NEG
41866: PUSH
41867: LD_INT 2
41869: NEG
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 2
41877: NEG
41878: PUSH
41879: LD_INT 1
41881: NEG
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: LD_INT 2
41889: NEG
41890: PUSH
41891: LD_INT 2
41893: NEG
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: LIST
41903: ST_TO_ADDR
// end ; 2 :
41904: GO 45170
41906: LD_INT 2
41908: DOUBLE
41909: EQUAL
41910: IFTRUE 41914
41912: GO 45169
41914: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41915: LD_ADDR_VAR 0 29
41919: PUSH
41920: LD_INT 4
41922: PUSH
41923: LD_INT 0
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: LD_INT 4
41932: PUSH
41933: LD_INT 1
41935: NEG
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PUSH
41941: LD_INT 5
41943: PUSH
41944: LD_INT 0
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PUSH
41951: LD_INT 5
41953: PUSH
41954: LD_INT 1
41956: PUSH
41957: EMPTY
41958: LIST
41959: LIST
41960: PUSH
41961: LD_INT 4
41963: PUSH
41964: LD_INT 1
41966: PUSH
41967: EMPTY
41968: LIST
41969: LIST
41970: PUSH
41971: LD_INT 3
41973: PUSH
41974: LD_INT 0
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: PUSH
41981: LD_INT 3
41983: PUSH
41984: LD_INT 1
41986: NEG
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: LD_INT 3
41994: PUSH
41995: LD_INT 2
41997: NEG
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: PUSH
42003: LD_INT 5
42005: PUSH
42006: LD_INT 2
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: PUSH
42013: LD_INT 3
42015: PUSH
42016: LD_INT 3
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: PUSH
42023: LD_INT 3
42025: PUSH
42026: LD_INT 2
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: PUSH
42033: LD_INT 4
42035: PUSH
42036: LD_INT 3
42038: PUSH
42039: EMPTY
42040: LIST
42041: LIST
42042: PUSH
42043: LD_INT 4
42045: PUSH
42046: LD_INT 4
42048: PUSH
42049: EMPTY
42050: LIST
42051: LIST
42052: PUSH
42053: LD_INT 3
42055: PUSH
42056: LD_INT 4
42058: PUSH
42059: EMPTY
42060: LIST
42061: LIST
42062: PUSH
42063: LD_INT 2
42065: PUSH
42066: LD_INT 3
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: PUSH
42073: LD_INT 2
42075: PUSH
42076: LD_INT 2
42078: PUSH
42079: EMPTY
42080: LIST
42081: LIST
42082: PUSH
42083: LD_INT 4
42085: PUSH
42086: LD_INT 2
42088: PUSH
42089: EMPTY
42090: LIST
42091: LIST
42092: PUSH
42093: LD_INT 2
42095: PUSH
42096: LD_INT 4
42098: PUSH
42099: EMPTY
42100: LIST
42101: LIST
42102: PUSH
42103: LD_INT 0
42105: PUSH
42106: LD_INT 4
42108: PUSH
42109: EMPTY
42110: LIST
42111: LIST
42112: PUSH
42113: LD_INT 0
42115: PUSH
42116: LD_INT 3
42118: PUSH
42119: EMPTY
42120: LIST
42121: LIST
42122: PUSH
42123: LD_INT 1
42125: PUSH
42126: LD_INT 4
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: PUSH
42133: LD_INT 1
42135: PUSH
42136: LD_INT 5
42138: PUSH
42139: EMPTY
42140: LIST
42141: LIST
42142: PUSH
42143: LD_INT 0
42145: PUSH
42146: LD_INT 5
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PUSH
42153: LD_INT 1
42155: NEG
42156: PUSH
42157: LD_INT 4
42159: PUSH
42160: EMPTY
42161: LIST
42162: LIST
42163: PUSH
42164: LD_INT 1
42166: NEG
42167: PUSH
42168: LD_INT 3
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: PUSH
42175: LD_INT 2
42177: PUSH
42178: LD_INT 5
42180: PUSH
42181: EMPTY
42182: LIST
42183: LIST
42184: PUSH
42185: LD_INT 2
42187: NEG
42188: PUSH
42189: LD_INT 3
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: LD_INT 3
42198: NEG
42199: PUSH
42200: LD_INT 0
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: LD_INT 3
42209: NEG
42210: PUSH
42211: LD_INT 1
42213: NEG
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: PUSH
42219: LD_INT 2
42221: NEG
42222: PUSH
42223: LD_INT 0
42225: PUSH
42226: EMPTY
42227: LIST
42228: LIST
42229: PUSH
42230: LD_INT 2
42232: NEG
42233: PUSH
42234: LD_INT 1
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 3
42243: NEG
42244: PUSH
42245: LD_INT 1
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 4
42254: NEG
42255: PUSH
42256: LD_INT 0
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 4
42265: NEG
42266: PUSH
42267: LD_INT 1
42269: NEG
42270: PUSH
42271: EMPTY
42272: LIST
42273: LIST
42274: PUSH
42275: LD_INT 4
42277: NEG
42278: PUSH
42279: LD_INT 2
42281: NEG
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: PUSH
42287: LD_INT 2
42289: NEG
42290: PUSH
42291: LD_INT 2
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: PUSH
42298: LD_INT 4
42300: NEG
42301: PUSH
42302: LD_INT 4
42304: NEG
42305: PUSH
42306: EMPTY
42307: LIST
42308: LIST
42309: PUSH
42310: LD_INT 4
42312: NEG
42313: PUSH
42314: LD_INT 5
42316: NEG
42317: PUSH
42318: EMPTY
42319: LIST
42320: LIST
42321: PUSH
42322: LD_INT 3
42324: NEG
42325: PUSH
42326: LD_INT 4
42328: NEG
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: PUSH
42334: LD_INT 3
42336: NEG
42337: PUSH
42338: LD_INT 3
42340: NEG
42341: PUSH
42342: EMPTY
42343: LIST
42344: LIST
42345: PUSH
42346: LD_INT 4
42348: NEG
42349: PUSH
42350: LD_INT 3
42352: NEG
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 5
42360: NEG
42361: PUSH
42362: LD_INT 4
42364: NEG
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 5
42372: NEG
42373: PUSH
42374: LD_INT 5
42376: NEG
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: PUSH
42382: LD_INT 3
42384: NEG
42385: PUSH
42386: LD_INT 5
42388: NEG
42389: PUSH
42390: EMPTY
42391: LIST
42392: LIST
42393: PUSH
42394: LD_INT 5
42396: NEG
42397: PUSH
42398: LD_INT 3
42400: NEG
42401: PUSH
42402: EMPTY
42403: LIST
42404: LIST
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: LIST
42410: LIST
42411: LIST
42412: LIST
42413: LIST
42414: LIST
42415: LIST
42416: LIST
42417: LIST
42418: LIST
42419: LIST
42420: LIST
42421: LIST
42422: LIST
42423: LIST
42424: LIST
42425: LIST
42426: LIST
42427: LIST
42428: LIST
42429: LIST
42430: LIST
42431: LIST
42432: LIST
42433: LIST
42434: LIST
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: LIST
42443: LIST
42444: LIST
42445: LIST
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42453: LD_ADDR_VAR 0 30
42457: PUSH
42458: LD_INT 4
42460: PUSH
42461: LD_INT 4
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: PUSH
42468: LD_INT 4
42470: PUSH
42471: LD_INT 3
42473: PUSH
42474: EMPTY
42475: LIST
42476: LIST
42477: PUSH
42478: LD_INT 5
42480: PUSH
42481: LD_INT 4
42483: PUSH
42484: EMPTY
42485: LIST
42486: LIST
42487: PUSH
42488: LD_INT 5
42490: PUSH
42491: LD_INT 5
42493: PUSH
42494: EMPTY
42495: LIST
42496: LIST
42497: PUSH
42498: LD_INT 4
42500: PUSH
42501: LD_INT 5
42503: PUSH
42504: EMPTY
42505: LIST
42506: LIST
42507: PUSH
42508: LD_INT 3
42510: PUSH
42511: LD_INT 4
42513: PUSH
42514: EMPTY
42515: LIST
42516: LIST
42517: PUSH
42518: LD_INT 3
42520: PUSH
42521: LD_INT 3
42523: PUSH
42524: EMPTY
42525: LIST
42526: LIST
42527: PUSH
42528: LD_INT 5
42530: PUSH
42531: LD_INT 3
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: LD_INT 3
42540: PUSH
42541: LD_INT 5
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PUSH
42548: LD_INT 0
42550: PUSH
42551: LD_INT 3
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PUSH
42558: LD_INT 0
42560: PUSH
42561: LD_INT 2
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: PUSH
42568: LD_INT 1
42570: PUSH
42571: LD_INT 3
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: PUSH
42578: LD_INT 1
42580: PUSH
42581: LD_INT 4
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: PUSH
42588: LD_INT 0
42590: PUSH
42591: LD_INT 4
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: LD_INT 1
42600: NEG
42601: PUSH
42602: LD_INT 3
42604: PUSH
42605: EMPTY
42606: LIST
42607: LIST
42608: PUSH
42609: LD_INT 1
42611: NEG
42612: PUSH
42613: LD_INT 2
42615: PUSH
42616: EMPTY
42617: LIST
42618: LIST
42619: PUSH
42620: LD_INT 2
42622: PUSH
42623: LD_INT 4
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: PUSH
42630: LD_INT 2
42632: NEG
42633: PUSH
42634: LD_INT 2
42636: PUSH
42637: EMPTY
42638: LIST
42639: LIST
42640: PUSH
42641: LD_INT 4
42643: NEG
42644: PUSH
42645: LD_INT 0
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: PUSH
42652: LD_INT 4
42654: NEG
42655: PUSH
42656: LD_INT 1
42658: NEG
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 3
42666: NEG
42667: PUSH
42668: LD_INT 0
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: PUSH
42675: LD_INT 3
42677: NEG
42678: PUSH
42679: LD_INT 1
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: PUSH
42686: LD_INT 4
42688: NEG
42689: PUSH
42690: LD_INT 1
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 5
42699: NEG
42700: PUSH
42701: LD_INT 0
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PUSH
42708: LD_INT 5
42710: NEG
42711: PUSH
42712: LD_INT 1
42714: NEG
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 5
42722: NEG
42723: PUSH
42724: LD_INT 2
42726: NEG
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: PUSH
42732: LD_INT 3
42734: NEG
42735: PUSH
42736: LD_INT 2
42738: PUSH
42739: EMPTY
42740: LIST
42741: LIST
42742: PUSH
42743: LD_INT 3
42745: NEG
42746: PUSH
42747: LD_INT 3
42749: NEG
42750: PUSH
42751: EMPTY
42752: LIST
42753: LIST
42754: PUSH
42755: LD_INT 3
42757: NEG
42758: PUSH
42759: LD_INT 4
42761: NEG
42762: PUSH
42763: EMPTY
42764: LIST
42765: LIST
42766: PUSH
42767: LD_INT 2
42769: NEG
42770: PUSH
42771: LD_INT 3
42773: NEG
42774: PUSH
42775: EMPTY
42776: LIST
42777: LIST
42778: PUSH
42779: LD_INT 2
42781: NEG
42782: PUSH
42783: LD_INT 2
42785: NEG
42786: PUSH
42787: EMPTY
42788: LIST
42789: LIST
42790: PUSH
42791: LD_INT 3
42793: NEG
42794: PUSH
42795: LD_INT 2
42797: NEG
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 4
42805: NEG
42806: PUSH
42807: LD_INT 3
42809: NEG
42810: PUSH
42811: EMPTY
42812: LIST
42813: LIST
42814: PUSH
42815: LD_INT 4
42817: NEG
42818: PUSH
42819: LD_INT 4
42821: NEG
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: PUSH
42827: LD_INT 2
42829: NEG
42830: PUSH
42831: LD_INT 4
42833: NEG
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PUSH
42839: LD_INT 4
42841: NEG
42842: PUSH
42843: LD_INT 2
42845: NEG
42846: PUSH
42847: EMPTY
42848: LIST
42849: LIST
42850: PUSH
42851: LD_INT 0
42853: PUSH
42854: LD_INT 4
42856: NEG
42857: PUSH
42858: EMPTY
42859: LIST
42860: LIST
42861: PUSH
42862: LD_INT 0
42864: PUSH
42865: LD_INT 5
42867: NEG
42868: PUSH
42869: EMPTY
42870: LIST
42871: LIST
42872: PUSH
42873: LD_INT 1
42875: PUSH
42876: LD_INT 4
42878: NEG
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: PUSH
42884: LD_INT 1
42886: PUSH
42887: LD_INT 3
42889: NEG
42890: PUSH
42891: EMPTY
42892: LIST
42893: LIST
42894: PUSH
42895: LD_INT 0
42897: PUSH
42898: LD_INT 3
42900: NEG
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: PUSH
42906: LD_INT 1
42908: NEG
42909: PUSH
42910: LD_INT 4
42912: NEG
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: LD_INT 1
42920: NEG
42921: PUSH
42922: LD_INT 5
42924: NEG
42925: PUSH
42926: EMPTY
42927: LIST
42928: LIST
42929: PUSH
42930: LD_INT 2
42932: PUSH
42933: LD_INT 3
42935: NEG
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: PUSH
42941: LD_INT 2
42943: NEG
42944: PUSH
42945: LD_INT 5
42947: NEG
42948: PUSH
42949: EMPTY
42950: LIST
42951: LIST
42952: PUSH
42953: EMPTY
42954: LIST
42955: LIST
42956: LIST
42957: LIST
42958: LIST
42959: LIST
42960: LIST
42961: LIST
42962: LIST
42963: LIST
42964: LIST
42965: LIST
42966: LIST
42967: LIST
42968: LIST
42969: LIST
42970: LIST
42971: LIST
42972: LIST
42973: LIST
42974: LIST
42975: LIST
42976: LIST
42977: LIST
42978: LIST
42979: LIST
42980: LIST
42981: LIST
42982: LIST
42983: LIST
42984: LIST
42985: LIST
42986: LIST
42987: LIST
42988: LIST
42989: LIST
42990: LIST
42991: LIST
42992: LIST
42993: LIST
42994: LIST
42995: LIST
42996: LIST
42997: LIST
42998: LIST
42999: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43000: LD_ADDR_VAR 0 31
43004: PUSH
43005: LD_INT 0
43007: PUSH
43008: LD_INT 4
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: PUSH
43015: LD_INT 0
43017: PUSH
43018: LD_INT 3
43020: PUSH
43021: EMPTY
43022: LIST
43023: LIST
43024: PUSH
43025: LD_INT 1
43027: PUSH
43028: LD_INT 4
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 1
43037: PUSH
43038: LD_INT 5
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: LD_INT 0
43047: PUSH
43048: LD_INT 5
43050: PUSH
43051: EMPTY
43052: LIST
43053: LIST
43054: PUSH
43055: LD_INT 1
43057: NEG
43058: PUSH
43059: LD_INT 4
43061: PUSH
43062: EMPTY
43063: LIST
43064: LIST
43065: PUSH
43066: LD_INT 1
43068: NEG
43069: PUSH
43070: LD_INT 3
43072: PUSH
43073: EMPTY
43074: LIST
43075: LIST
43076: PUSH
43077: LD_INT 2
43079: PUSH
43080: LD_INT 5
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: PUSH
43087: LD_INT 2
43089: NEG
43090: PUSH
43091: LD_INT 3
43093: PUSH
43094: EMPTY
43095: LIST
43096: LIST
43097: PUSH
43098: LD_INT 3
43100: NEG
43101: PUSH
43102: LD_INT 0
43104: PUSH
43105: EMPTY
43106: LIST
43107: LIST
43108: PUSH
43109: LD_INT 3
43111: NEG
43112: PUSH
43113: LD_INT 1
43115: NEG
43116: PUSH
43117: EMPTY
43118: LIST
43119: LIST
43120: PUSH
43121: LD_INT 2
43123: NEG
43124: PUSH
43125: LD_INT 0
43127: PUSH
43128: EMPTY
43129: LIST
43130: LIST
43131: PUSH
43132: LD_INT 2
43134: NEG
43135: PUSH
43136: LD_INT 1
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 3
43145: NEG
43146: PUSH
43147: LD_INT 1
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_INT 4
43156: NEG
43157: PUSH
43158: LD_INT 0
43160: PUSH
43161: EMPTY
43162: LIST
43163: LIST
43164: PUSH
43165: LD_INT 4
43167: NEG
43168: PUSH
43169: LD_INT 1
43171: NEG
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: LD_INT 4
43179: NEG
43180: PUSH
43181: LD_INT 2
43183: NEG
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PUSH
43189: LD_INT 2
43191: NEG
43192: PUSH
43193: LD_INT 2
43195: PUSH
43196: EMPTY
43197: LIST
43198: LIST
43199: PUSH
43200: LD_INT 4
43202: NEG
43203: PUSH
43204: LD_INT 4
43206: NEG
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: PUSH
43212: LD_INT 4
43214: NEG
43215: PUSH
43216: LD_INT 5
43218: NEG
43219: PUSH
43220: EMPTY
43221: LIST
43222: LIST
43223: PUSH
43224: LD_INT 3
43226: NEG
43227: PUSH
43228: LD_INT 4
43230: NEG
43231: PUSH
43232: EMPTY
43233: LIST
43234: LIST
43235: PUSH
43236: LD_INT 3
43238: NEG
43239: PUSH
43240: LD_INT 3
43242: NEG
43243: PUSH
43244: EMPTY
43245: LIST
43246: LIST
43247: PUSH
43248: LD_INT 4
43250: NEG
43251: PUSH
43252: LD_INT 3
43254: NEG
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: PUSH
43260: LD_INT 5
43262: NEG
43263: PUSH
43264: LD_INT 4
43266: NEG
43267: PUSH
43268: EMPTY
43269: LIST
43270: LIST
43271: PUSH
43272: LD_INT 5
43274: NEG
43275: PUSH
43276: LD_INT 5
43278: NEG
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: PUSH
43284: LD_INT 3
43286: NEG
43287: PUSH
43288: LD_INT 5
43290: NEG
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: PUSH
43296: LD_INT 5
43298: NEG
43299: PUSH
43300: LD_INT 3
43302: NEG
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PUSH
43308: LD_INT 0
43310: PUSH
43311: LD_INT 3
43313: NEG
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: PUSH
43319: LD_INT 0
43321: PUSH
43322: LD_INT 4
43324: NEG
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 1
43332: PUSH
43333: LD_INT 3
43335: NEG
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 1
43343: PUSH
43344: LD_INT 2
43346: NEG
43347: PUSH
43348: EMPTY
43349: LIST
43350: LIST
43351: PUSH
43352: LD_INT 0
43354: PUSH
43355: LD_INT 2
43357: NEG
43358: PUSH
43359: EMPTY
43360: LIST
43361: LIST
43362: PUSH
43363: LD_INT 1
43365: NEG
43366: PUSH
43367: LD_INT 3
43369: NEG
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: PUSH
43375: LD_INT 1
43377: NEG
43378: PUSH
43379: LD_INT 4
43381: NEG
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: LD_INT 2
43389: PUSH
43390: LD_INT 2
43392: NEG
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: PUSH
43398: LD_INT 2
43400: NEG
43401: PUSH
43402: LD_INT 4
43404: NEG
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: PUSH
43410: LD_INT 4
43412: PUSH
43413: LD_INT 0
43415: PUSH
43416: EMPTY
43417: LIST
43418: LIST
43419: PUSH
43420: LD_INT 4
43422: PUSH
43423: LD_INT 1
43425: NEG
43426: PUSH
43427: EMPTY
43428: LIST
43429: LIST
43430: PUSH
43431: LD_INT 5
43433: PUSH
43434: LD_INT 0
43436: PUSH
43437: EMPTY
43438: LIST
43439: LIST
43440: PUSH
43441: LD_INT 5
43443: PUSH
43444: LD_INT 1
43446: PUSH
43447: EMPTY
43448: LIST
43449: LIST
43450: PUSH
43451: LD_INT 4
43453: PUSH
43454: LD_INT 1
43456: PUSH
43457: EMPTY
43458: LIST
43459: LIST
43460: PUSH
43461: LD_INT 3
43463: PUSH
43464: LD_INT 0
43466: PUSH
43467: EMPTY
43468: LIST
43469: LIST
43470: PUSH
43471: LD_INT 3
43473: PUSH
43474: LD_INT 1
43476: NEG
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: LD_INT 3
43484: PUSH
43485: LD_INT 2
43487: NEG
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: PUSH
43493: LD_INT 5
43495: PUSH
43496: LD_INT 2
43498: PUSH
43499: EMPTY
43500: LIST
43501: LIST
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: LIST
43507: LIST
43508: LIST
43509: LIST
43510: LIST
43511: LIST
43512: LIST
43513: LIST
43514: LIST
43515: LIST
43516: LIST
43517: LIST
43518: LIST
43519: LIST
43520: LIST
43521: LIST
43522: LIST
43523: LIST
43524: LIST
43525: LIST
43526: LIST
43527: LIST
43528: LIST
43529: LIST
43530: LIST
43531: LIST
43532: LIST
43533: LIST
43534: LIST
43535: LIST
43536: LIST
43537: LIST
43538: LIST
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: LIST
43549: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43550: LD_ADDR_VAR 0 32
43554: PUSH
43555: LD_INT 4
43557: NEG
43558: PUSH
43559: LD_INT 0
43561: PUSH
43562: EMPTY
43563: LIST
43564: LIST
43565: PUSH
43566: LD_INT 4
43568: NEG
43569: PUSH
43570: LD_INT 1
43572: NEG
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 3
43580: NEG
43581: PUSH
43582: LD_INT 0
43584: PUSH
43585: EMPTY
43586: LIST
43587: LIST
43588: PUSH
43589: LD_INT 3
43591: NEG
43592: PUSH
43593: LD_INT 1
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: PUSH
43600: LD_INT 4
43602: NEG
43603: PUSH
43604: LD_INT 1
43606: PUSH
43607: EMPTY
43608: LIST
43609: LIST
43610: PUSH
43611: LD_INT 5
43613: NEG
43614: PUSH
43615: LD_INT 0
43617: PUSH
43618: EMPTY
43619: LIST
43620: LIST
43621: PUSH
43622: LD_INT 5
43624: NEG
43625: PUSH
43626: LD_INT 1
43628: NEG
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 5
43636: NEG
43637: PUSH
43638: LD_INT 2
43640: NEG
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: LD_INT 3
43648: NEG
43649: PUSH
43650: LD_INT 2
43652: PUSH
43653: EMPTY
43654: LIST
43655: LIST
43656: PUSH
43657: LD_INT 3
43659: NEG
43660: PUSH
43661: LD_INT 3
43663: NEG
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: PUSH
43669: LD_INT 3
43671: NEG
43672: PUSH
43673: LD_INT 4
43675: NEG
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: PUSH
43681: LD_INT 2
43683: NEG
43684: PUSH
43685: LD_INT 3
43687: NEG
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: LD_INT 2
43695: NEG
43696: PUSH
43697: LD_INT 2
43699: NEG
43700: PUSH
43701: EMPTY
43702: LIST
43703: LIST
43704: PUSH
43705: LD_INT 3
43707: NEG
43708: PUSH
43709: LD_INT 2
43711: NEG
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: PUSH
43717: LD_INT 4
43719: NEG
43720: PUSH
43721: LD_INT 3
43723: NEG
43724: PUSH
43725: EMPTY
43726: LIST
43727: LIST
43728: PUSH
43729: LD_INT 4
43731: NEG
43732: PUSH
43733: LD_INT 4
43735: NEG
43736: PUSH
43737: EMPTY
43738: LIST
43739: LIST
43740: PUSH
43741: LD_INT 2
43743: NEG
43744: PUSH
43745: LD_INT 4
43747: NEG
43748: PUSH
43749: EMPTY
43750: LIST
43751: LIST
43752: PUSH
43753: LD_INT 4
43755: NEG
43756: PUSH
43757: LD_INT 2
43759: NEG
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 0
43767: PUSH
43768: LD_INT 4
43770: NEG
43771: PUSH
43772: EMPTY
43773: LIST
43774: LIST
43775: PUSH
43776: LD_INT 0
43778: PUSH
43779: LD_INT 5
43781: NEG
43782: PUSH
43783: EMPTY
43784: LIST
43785: LIST
43786: PUSH
43787: LD_INT 1
43789: PUSH
43790: LD_INT 4
43792: NEG
43793: PUSH
43794: EMPTY
43795: LIST
43796: LIST
43797: PUSH
43798: LD_INT 1
43800: PUSH
43801: LD_INT 3
43803: NEG
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 0
43811: PUSH
43812: LD_INT 3
43814: NEG
43815: PUSH
43816: EMPTY
43817: LIST
43818: LIST
43819: PUSH
43820: LD_INT 1
43822: NEG
43823: PUSH
43824: LD_INT 4
43826: NEG
43827: PUSH
43828: EMPTY
43829: LIST
43830: LIST
43831: PUSH
43832: LD_INT 1
43834: NEG
43835: PUSH
43836: LD_INT 5
43838: NEG
43839: PUSH
43840: EMPTY
43841: LIST
43842: LIST
43843: PUSH
43844: LD_INT 2
43846: PUSH
43847: LD_INT 3
43849: NEG
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: LD_INT 2
43857: NEG
43858: PUSH
43859: LD_INT 5
43861: NEG
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 3
43869: PUSH
43870: LD_INT 0
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: LD_INT 3
43879: PUSH
43880: LD_INT 1
43882: NEG
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PUSH
43888: LD_INT 4
43890: PUSH
43891: LD_INT 0
43893: PUSH
43894: EMPTY
43895: LIST
43896: LIST
43897: PUSH
43898: LD_INT 4
43900: PUSH
43901: LD_INT 1
43903: PUSH
43904: EMPTY
43905: LIST
43906: LIST
43907: PUSH
43908: LD_INT 3
43910: PUSH
43911: LD_INT 1
43913: PUSH
43914: EMPTY
43915: LIST
43916: LIST
43917: PUSH
43918: LD_INT 2
43920: PUSH
43921: LD_INT 0
43923: PUSH
43924: EMPTY
43925: LIST
43926: LIST
43927: PUSH
43928: LD_INT 2
43930: PUSH
43931: LD_INT 1
43933: NEG
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PUSH
43939: LD_INT 2
43941: PUSH
43942: LD_INT 2
43944: NEG
43945: PUSH
43946: EMPTY
43947: LIST
43948: LIST
43949: PUSH
43950: LD_INT 4
43952: PUSH
43953: LD_INT 2
43955: PUSH
43956: EMPTY
43957: LIST
43958: LIST
43959: PUSH
43960: LD_INT 4
43962: PUSH
43963: LD_INT 4
43965: PUSH
43966: EMPTY
43967: LIST
43968: LIST
43969: PUSH
43970: LD_INT 4
43972: PUSH
43973: LD_INT 3
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: LD_INT 5
43982: PUSH
43983: LD_INT 4
43985: PUSH
43986: EMPTY
43987: LIST
43988: LIST
43989: PUSH
43990: LD_INT 5
43992: PUSH
43993: LD_INT 5
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: PUSH
44000: LD_INT 4
44002: PUSH
44003: LD_INT 5
44005: PUSH
44006: EMPTY
44007: LIST
44008: LIST
44009: PUSH
44010: LD_INT 3
44012: PUSH
44013: LD_INT 4
44015: PUSH
44016: EMPTY
44017: LIST
44018: LIST
44019: PUSH
44020: LD_INT 3
44022: PUSH
44023: LD_INT 3
44025: PUSH
44026: EMPTY
44027: LIST
44028: LIST
44029: PUSH
44030: LD_INT 5
44032: PUSH
44033: LD_INT 3
44035: PUSH
44036: EMPTY
44037: LIST
44038: LIST
44039: PUSH
44040: LD_INT 3
44042: PUSH
44043: LD_INT 5
44045: PUSH
44046: EMPTY
44047: LIST
44048: LIST
44049: PUSH
44050: EMPTY
44051: LIST
44052: LIST
44053: LIST
44054: LIST
44055: LIST
44056: LIST
44057: LIST
44058: LIST
44059: LIST
44060: LIST
44061: LIST
44062: LIST
44063: LIST
44064: LIST
44065: LIST
44066: LIST
44067: LIST
44068: LIST
44069: LIST
44070: LIST
44071: LIST
44072: LIST
44073: LIST
44074: LIST
44075: LIST
44076: LIST
44077: LIST
44078: LIST
44079: LIST
44080: LIST
44081: LIST
44082: LIST
44083: LIST
44084: LIST
44085: LIST
44086: LIST
44087: LIST
44088: LIST
44089: LIST
44090: LIST
44091: LIST
44092: LIST
44093: LIST
44094: LIST
44095: LIST
44096: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44097: LD_ADDR_VAR 0 33
44101: PUSH
44102: LD_INT 4
44104: NEG
44105: PUSH
44106: LD_INT 4
44108: NEG
44109: PUSH
44110: EMPTY
44111: LIST
44112: LIST
44113: PUSH
44114: LD_INT 4
44116: NEG
44117: PUSH
44118: LD_INT 5
44120: NEG
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: PUSH
44126: LD_INT 3
44128: NEG
44129: PUSH
44130: LD_INT 4
44132: NEG
44133: PUSH
44134: EMPTY
44135: LIST
44136: LIST
44137: PUSH
44138: LD_INT 3
44140: NEG
44141: PUSH
44142: LD_INT 3
44144: NEG
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: LD_INT 4
44152: NEG
44153: PUSH
44154: LD_INT 3
44156: NEG
44157: PUSH
44158: EMPTY
44159: LIST
44160: LIST
44161: PUSH
44162: LD_INT 5
44164: NEG
44165: PUSH
44166: LD_INT 4
44168: NEG
44169: PUSH
44170: EMPTY
44171: LIST
44172: LIST
44173: PUSH
44174: LD_INT 5
44176: NEG
44177: PUSH
44178: LD_INT 5
44180: NEG
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: PUSH
44186: LD_INT 3
44188: NEG
44189: PUSH
44190: LD_INT 5
44192: NEG
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: PUSH
44198: LD_INT 5
44200: NEG
44201: PUSH
44202: LD_INT 3
44204: NEG
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 0
44212: PUSH
44213: LD_INT 3
44215: NEG
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: PUSH
44221: LD_INT 0
44223: PUSH
44224: LD_INT 4
44226: NEG
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: LD_INT 1
44234: PUSH
44235: LD_INT 3
44237: NEG
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 1
44245: PUSH
44246: LD_INT 2
44248: NEG
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 0
44256: PUSH
44257: LD_INT 2
44259: NEG
44260: PUSH
44261: EMPTY
44262: LIST
44263: LIST
44264: PUSH
44265: LD_INT 1
44267: NEG
44268: PUSH
44269: LD_INT 3
44271: NEG
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: PUSH
44277: LD_INT 1
44279: NEG
44280: PUSH
44281: LD_INT 4
44283: NEG
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: LD_INT 2
44291: PUSH
44292: LD_INT 2
44294: NEG
44295: PUSH
44296: EMPTY
44297: LIST
44298: LIST
44299: PUSH
44300: LD_INT 2
44302: NEG
44303: PUSH
44304: LD_INT 4
44306: NEG
44307: PUSH
44308: EMPTY
44309: LIST
44310: LIST
44311: PUSH
44312: LD_INT 4
44314: PUSH
44315: LD_INT 0
44317: PUSH
44318: EMPTY
44319: LIST
44320: LIST
44321: PUSH
44322: LD_INT 4
44324: PUSH
44325: LD_INT 1
44327: NEG
44328: PUSH
44329: EMPTY
44330: LIST
44331: LIST
44332: PUSH
44333: LD_INT 5
44335: PUSH
44336: LD_INT 0
44338: PUSH
44339: EMPTY
44340: LIST
44341: LIST
44342: PUSH
44343: LD_INT 5
44345: PUSH
44346: LD_INT 1
44348: PUSH
44349: EMPTY
44350: LIST
44351: LIST
44352: PUSH
44353: LD_INT 4
44355: PUSH
44356: LD_INT 1
44358: PUSH
44359: EMPTY
44360: LIST
44361: LIST
44362: PUSH
44363: LD_INT 3
44365: PUSH
44366: LD_INT 0
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 3
44375: PUSH
44376: LD_INT 1
44378: NEG
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 3
44386: PUSH
44387: LD_INT 2
44389: NEG
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: PUSH
44395: LD_INT 5
44397: PUSH
44398: LD_INT 2
44400: PUSH
44401: EMPTY
44402: LIST
44403: LIST
44404: PUSH
44405: LD_INT 3
44407: PUSH
44408: LD_INT 3
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: LD_INT 3
44417: PUSH
44418: LD_INT 2
44420: PUSH
44421: EMPTY
44422: LIST
44423: LIST
44424: PUSH
44425: LD_INT 4
44427: PUSH
44428: LD_INT 3
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: PUSH
44435: LD_INT 4
44437: PUSH
44438: LD_INT 4
44440: PUSH
44441: EMPTY
44442: LIST
44443: LIST
44444: PUSH
44445: LD_INT 3
44447: PUSH
44448: LD_INT 4
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: PUSH
44455: LD_INT 2
44457: PUSH
44458: LD_INT 3
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: PUSH
44465: LD_INT 2
44467: PUSH
44468: LD_INT 2
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: LD_INT 4
44477: PUSH
44478: LD_INT 2
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 2
44487: PUSH
44488: LD_INT 4
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PUSH
44495: LD_INT 0
44497: PUSH
44498: LD_INT 4
44500: PUSH
44501: EMPTY
44502: LIST
44503: LIST
44504: PUSH
44505: LD_INT 0
44507: PUSH
44508: LD_INT 3
44510: PUSH
44511: EMPTY
44512: LIST
44513: LIST
44514: PUSH
44515: LD_INT 1
44517: PUSH
44518: LD_INT 4
44520: PUSH
44521: EMPTY
44522: LIST
44523: LIST
44524: PUSH
44525: LD_INT 1
44527: PUSH
44528: LD_INT 5
44530: PUSH
44531: EMPTY
44532: LIST
44533: LIST
44534: PUSH
44535: LD_INT 0
44537: PUSH
44538: LD_INT 5
44540: PUSH
44541: EMPTY
44542: LIST
44543: LIST
44544: PUSH
44545: LD_INT 1
44547: NEG
44548: PUSH
44549: LD_INT 4
44551: PUSH
44552: EMPTY
44553: LIST
44554: LIST
44555: PUSH
44556: LD_INT 1
44558: NEG
44559: PUSH
44560: LD_INT 3
44562: PUSH
44563: EMPTY
44564: LIST
44565: LIST
44566: PUSH
44567: LD_INT 2
44569: PUSH
44570: LD_INT 5
44572: PUSH
44573: EMPTY
44574: LIST
44575: LIST
44576: PUSH
44577: LD_INT 2
44579: NEG
44580: PUSH
44581: LD_INT 3
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: LIST
44592: LIST
44593: LIST
44594: LIST
44595: LIST
44596: LIST
44597: LIST
44598: LIST
44599: LIST
44600: LIST
44601: LIST
44602: LIST
44603: LIST
44604: LIST
44605: LIST
44606: LIST
44607: LIST
44608: LIST
44609: LIST
44610: LIST
44611: LIST
44612: LIST
44613: LIST
44614: LIST
44615: LIST
44616: LIST
44617: LIST
44618: LIST
44619: LIST
44620: LIST
44621: LIST
44622: LIST
44623: LIST
44624: LIST
44625: LIST
44626: LIST
44627: LIST
44628: LIST
44629: LIST
44630: LIST
44631: LIST
44632: LIST
44633: LIST
44634: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
44635: LD_ADDR_VAR 0 34
44639: PUSH
44640: LD_INT 0
44642: PUSH
44643: LD_INT 4
44645: NEG
44646: PUSH
44647: EMPTY
44648: LIST
44649: LIST
44650: PUSH
44651: LD_INT 0
44653: PUSH
44654: LD_INT 5
44656: NEG
44657: PUSH
44658: EMPTY
44659: LIST
44660: LIST
44661: PUSH
44662: LD_INT 1
44664: PUSH
44665: LD_INT 4
44667: NEG
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 1
44675: PUSH
44676: LD_INT 3
44678: NEG
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PUSH
44684: LD_INT 0
44686: PUSH
44687: LD_INT 3
44689: NEG
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PUSH
44695: LD_INT 1
44697: NEG
44698: PUSH
44699: LD_INT 4
44701: NEG
44702: PUSH
44703: EMPTY
44704: LIST
44705: LIST
44706: PUSH
44707: LD_INT 1
44709: NEG
44710: PUSH
44711: LD_INT 5
44713: NEG
44714: PUSH
44715: EMPTY
44716: LIST
44717: LIST
44718: PUSH
44719: LD_INT 2
44721: PUSH
44722: LD_INT 3
44724: NEG
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: PUSH
44730: LD_INT 2
44732: NEG
44733: PUSH
44734: LD_INT 5
44736: NEG
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: PUSH
44742: LD_INT 3
44744: PUSH
44745: LD_INT 0
44747: PUSH
44748: EMPTY
44749: LIST
44750: LIST
44751: PUSH
44752: LD_INT 3
44754: PUSH
44755: LD_INT 1
44757: NEG
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: PUSH
44763: LD_INT 4
44765: PUSH
44766: LD_INT 0
44768: PUSH
44769: EMPTY
44770: LIST
44771: LIST
44772: PUSH
44773: LD_INT 4
44775: PUSH
44776: LD_INT 1
44778: PUSH
44779: EMPTY
44780: LIST
44781: LIST
44782: PUSH
44783: LD_INT 3
44785: PUSH
44786: LD_INT 1
44788: PUSH
44789: EMPTY
44790: LIST
44791: LIST
44792: PUSH
44793: LD_INT 2
44795: PUSH
44796: LD_INT 0
44798: PUSH
44799: EMPTY
44800: LIST
44801: LIST
44802: PUSH
44803: LD_INT 2
44805: PUSH
44806: LD_INT 1
44808: NEG
44809: PUSH
44810: EMPTY
44811: LIST
44812: LIST
44813: PUSH
44814: LD_INT 2
44816: PUSH
44817: LD_INT 2
44819: NEG
44820: PUSH
44821: EMPTY
44822: LIST
44823: LIST
44824: PUSH
44825: LD_INT 4
44827: PUSH
44828: LD_INT 2
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: PUSH
44835: LD_INT 4
44837: PUSH
44838: LD_INT 4
44840: PUSH
44841: EMPTY
44842: LIST
44843: LIST
44844: PUSH
44845: LD_INT 4
44847: PUSH
44848: LD_INT 3
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: PUSH
44855: LD_INT 5
44857: PUSH
44858: LD_INT 4
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PUSH
44865: LD_INT 5
44867: PUSH
44868: LD_INT 5
44870: PUSH
44871: EMPTY
44872: LIST
44873: LIST
44874: PUSH
44875: LD_INT 4
44877: PUSH
44878: LD_INT 5
44880: PUSH
44881: EMPTY
44882: LIST
44883: LIST
44884: PUSH
44885: LD_INT 3
44887: PUSH
44888: LD_INT 4
44890: PUSH
44891: EMPTY
44892: LIST
44893: LIST
44894: PUSH
44895: LD_INT 3
44897: PUSH
44898: LD_INT 3
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: PUSH
44905: LD_INT 5
44907: PUSH
44908: LD_INT 3
44910: PUSH
44911: EMPTY
44912: LIST
44913: LIST
44914: PUSH
44915: LD_INT 3
44917: PUSH
44918: LD_INT 5
44920: PUSH
44921: EMPTY
44922: LIST
44923: LIST
44924: PUSH
44925: LD_INT 0
44927: PUSH
44928: LD_INT 3
44930: PUSH
44931: EMPTY
44932: LIST
44933: LIST
44934: PUSH
44935: LD_INT 0
44937: PUSH
44938: LD_INT 2
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: PUSH
44945: LD_INT 1
44947: PUSH
44948: LD_INT 3
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 1
44957: PUSH
44958: LD_INT 4
44960: PUSH
44961: EMPTY
44962: LIST
44963: LIST
44964: PUSH
44965: LD_INT 0
44967: PUSH
44968: LD_INT 4
44970: PUSH
44971: EMPTY
44972: LIST
44973: LIST
44974: PUSH
44975: LD_INT 1
44977: NEG
44978: PUSH
44979: LD_INT 3
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: PUSH
44986: LD_INT 1
44988: NEG
44989: PUSH
44990: LD_INT 2
44992: PUSH
44993: EMPTY
44994: LIST
44995: LIST
44996: PUSH
44997: LD_INT 2
44999: PUSH
45000: LD_INT 4
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: PUSH
45007: LD_INT 2
45009: NEG
45010: PUSH
45011: LD_INT 2
45013: PUSH
45014: EMPTY
45015: LIST
45016: LIST
45017: PUSH
45018: LD_INT 4
45020: NEG
45021: PUSH
45022: LD_INT 0
45024: PUSH
45025: EMPTY
45026: LIST
45027: LIST
45028: PUSH
45029: LD_INT 4
45031: NEG
45032: PUSH
45033: LD_INT 1
45035: NEG
45036: PUSH
45037: EMPTY
45038: LIST
45039: LIST
45040: PUSH
45041: LD_INT 3
45043: NEG
45044: PUSH
45045: LD_INT 0
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: PUSH
45052: LD_INT 3
45054: NEG
45055: PUSH
45056: LD_INT 1
45058: PUSH
45059: EMPTY
45060: LIST
45061: LIST
45062: PUSH
45063: LD_INT 4
45065: NEG
45066: PUSH
45067: LD_INT 1
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PUSH
45074: LD_INT 5
45076: NEG
45077: PUSH
45078: LD_INT 0
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PUSH
45085: LD_INT 5
45087: NEG
45088: PUSH
45089: LD_INT 1
45091: NEG
45092: PUSH
45093: EMPTY
45094: LIST
45095: LIST
45096: PUSH
45097: LD_INT 5
45099: NEG
45100: PUSH
45101: LD_INT 2
45103: NEG
45104: PUSH
45105: EMPTY
45106: LIST
45107: LIST
45108: PUSH
45109: LD_INT 3
45111: NEG
45112: PUSH
45113: LD_INT 2
45115: PUSH
45116: EMPTY
45117: LIST
45118: LIST
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: LIST
45124: LIST
45125: LIST
45126: LIST
45127: LIST
45128: LIST
45129: LIST
45130: LIST
45131: LIST
45132: LIST
45133: LIST
45134: LIST
45135: LIST
45136: LIST
45137: LIST
45138: LIST
45139: LIST
45140: LIST
45141: LIST
45142: LIST
45143: LIST
45144: LIST
45145: LIST
45146: LIST
45147: LIST
45148: LIST
45149: LIST
45150: LIST
45151: LIST
45152: LIST
45153: LIST
45154: LIST
45155: LIST
45156: LIST
45157: LIST
45158: LIST
45159: LIST
45160: LIST
45161: LIST
45162: LIST
45163: LIST
45164: LIST
45165: LIST
45166: ST_TO_ADDR
// end ; end ;
45167: GO 45170
45169: POP
// case btype of b_depot , b_warehouse :
45170: LD_VAR 0 1
45174: PUSH
45175: LD_INT 0
45177: DOUBLE
45178: EQUAL
45179: IFTRUE 45189
45181: LD_INT 1
45183: DOUBLE
45184: EQUAL
45185: IFTRUE 45189
45187: GO 45390
45189: POP
// case nation of nation_american :
45190: LD_VAR 0 5
45194: PUSH
45195: LD_INT 1
45197: DOUBLE
45198: EQUAL
45199: IFTRUE 45203
45201: GO 45259
45203: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
45204: LD_ADDR_VAR 0 9
45208: PUSH
45209: LD_VAR 0 11
45213: PUSH
45214: LD_VAR 0 12
45218: PUSH
45219: LD_VAR 0 13
45223: PUSH
45224: LD_VAR 0 14
45228: PUSH
45229: LD_VAR 0 15
45233: PUSH
45234: LD_VAR 0 16
45238: PUSH
45239: EMPTY
45240: LIST
45241: LIST
45242: LIST
45243: LIST
45244: LIST
45245: LIST
45246: PUSH
45247: LD_VAR 0 4
45251: PUSH
45252: LD_INT 1
45254: PLUS
45255: ARRAY
45256: ST_TO_ADDR
45257: GO 45388
45259: LD_INT 2
45261: DOUBLE
45262: EQUAL
45263: IFTRUE 45267
45265: GO 45323
45267: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
45268: LD_ADDR_VAR 0 9
45272: PUSH
45273: LD_VAR 0 17
45277: PUSH
45278: LD_VAR 0 18
45282: PUSH
45283: LD_VAR 0 19
45287: PUSH
45288: LD_VAR 0 20
45292: PUSH
45293: LD_VAR 0 21
45297: PUSH
45298: LD_VAR 0 22
45302: PUSH
45303: EMPTY
45304: LIST
45305: LIST
45306: LIST
45307: LIST
45308: LIST
45309: LIST
45310: PUSH
45311: LD_VAR 0 4
45315: PUSH
45316: LD_INT 1
45318: PLUS
45319: ARRAY
45320: ST_TO_ADDR
45321: GO 45388
45323: LD_INT 3
45325: DOUBLE
45326: EQUAL
45327: IFTRUE 45331
45329: GO 45387
45331: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
45332: LD_ADDR_VAR 0 9
45336: PUSH
45337: LD_VAR 0 23
45341: PUSH
45342: LD_VAR 0 24
45346: PUSH
45347: LD_VAR 0 25
45351: PUSH
45352: LD_VAR 0 26
45356: PUSH
45357: LD_VAR 0 27
45361: PUSH
45362: LD_VAR 0 28
45366: PUSH
45367: EMPTY
45368: LIST
45369: LIST
45370: LIST
45371: LIST
45372: LIST
45373: LIST
45374: PUSH
45375: LD_VAR 0 4
45379: PUSH
45380: LD_INT 1
45382: PLUS
45383: ARRAY
45384: ST_TO_ADDR
45385: GO 45388
45387: POP
45388: GO 45943
45390: LD_INT 2
45392: DOUBLE
45393: EQUAL
45394: IFTRUE 45404
45396: LD_INT 3
45398: DOUBLE
45399: EQUAL
45400: IFTRUE 45404
45402: GO 45460
45404: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45405: LD_ADDR_VAR 0 9
45409: PUSH
45410: LD_VAR 0 29
45414: PUSH
45415: LD_VAR 0 30
45419: PUSH
45420: LD_VAR 0 31
45424: PUSH
45425: LD_VAR 0 32
45429: PUSH
45430: LD_VAR 0 33
45434: PUSH
45435: LD_VAR 0 34
45439: PUSH
45440: EMPTY
45441: LIST
45442: LIST
45443: LIST
45444: LIST
45445: LIST
45446: LIST
45447: PUSH
45448: LD_VAR 0 4
45452: PUSH
45453: LD_INT 1
45455: PLUS
45456: ARRAY
45457: ST_TO_ADDR
45458: GO 45943
45460: LD_INT 16
45462: DOUBLE
45463: EQUAL
45464: IFTRUE 45522
45466: LD_INT 17
45468: DOUBLE
45469: EQUAL
45470: IFTRUE 45522
45472: LD_INT 18
45474: DOUBLE
45475: EQUAL
45476: IFTRUE 45522
45478: LD_INT 19
45480: DOUBLE
45481: EQUAL
45482: IFTRUE 45522
45484: LD_INT 22
45486: DOUBLE
45487: EQUAL
45488: IFTRUE 45522
45490: LD_INT 20
45492: DOUBLE
45493: EQUAL
45494: IFTRUE 45522
45496: LD_INT 21
45498: DOUBLE
45499: EQUAL
45500: IFTRUE 45522
45502: LD_INT 23
45504: DOUBLE
45505: EQUAL
45506: IFTRUE 45522
45508: LD_INT 24
45510: DOUBLE
45511: EQUAL
45512: IFTRUE 45522
45514: LD_INT 25
45516: DOUBLE
45517: EQUAL
45518: IFTRUE 45522
45520: GO 45578
45522: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45523: LD_ADDR_VAR 0 9
45527: PUSH
45528: LD_VAR 0 35
45532: PUSH
45533: LD_VAR 0 36
45537: PUSH
45538: LD_VAR 0 37
45542: PUSH
45543: LD_VAR 0 38
45547: PUSH
45548: LD_VAR 0 39
45552: PUSH
45553: LD_VAR 0 40
45557: PUSH
45558: EMPTY
45559: LIST
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: LIST
45565: PUSH
45566: LD_VAR 0 4
45570: PUSH
45571: LD_INT 1
45573: PLUS
45574: ARRAY
45575: ST_TO_ADDR
45576: GO 45943
45578: LD_INT 6
45580: DOUBLE
45581: EQUAL
45582: IFTRUE 45634
45584: LD_INT 7
45586: DOUBLE
45587: EQUAL
45588: IFTRUE 45634
45590: LD_INT 8
45592: DOUBLE
45593: EQUAL
45594: IFTRUE 45634
45596: LD_INT 13
45598: DOUBLE
45599: EQUAL
45600: IFTRUE 45634
45602: LD_INT 12
45604: DOUBLE
45605: EQUAL
45606: IFTRUE 45634
45608: LD_INT 15
45610: DOUBLE
45611: EQUAL
45612: IFTRUE 45634
45614: LD_INT 11
45616: DOUBLE
45617: EQUAL
45618: IFTRUE 45634
45620: LD_INT 14
45622: DOUBLE
45623: EQUAL
45624: IFTRUE 45634
45626: LD_INT 10
45628: DOUBLE
45629: EQUAL
45630: IFTRUE 45634
45632: GO 45690
45634: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
45635: LD_ADDR_VAR 0 9
45639: PUSH
45640: LD_VAR 0 41
45644: PUSH
45645: LD_VAR 0 42
45649: PUSH
45650: LD_VAR 0 43
45654: PUSH
45655: LD_VAR 0 44
45659: PUSH
45660: LD_VAR 0 45
45664: PUSH
45665: LD_VAR 0 46
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: LIST
45677: PUSH
45678: LD_VAR 0 4
45682: PUSH
45683: LD_INT 1
45685: PLUS
45686: ARRAY
45687: ST_TO_ADDR
45688: GO 45943
45690: LD_INT 36
45692: DOUBLE
45693: EQUAL
45694: IFTRUE 45698
45696: GO 45754
45698: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45699: LD_ADDR_VAR 0 9
45703: PUSH
45704: LD_VAR 0 47
45708: PUSH
45709: LD_VAR 0 48
45713: PUSH
45714: LD_VAR 0 49
45718: PUSH
45719: LD_VAR 0 50
45723: PUSH
45724: LD_VAR 0 51
45728: PUSH
45729: LD_VAR 0 52
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: LIST
45738: LIST
45739: LIST
45740: LIST
45741: PUSH
45742: LD_VAR 0 4
45746: PUSH
45747: LD_INT 1
45749: PLUS
45750: ARRAY
45751: ST_TO_ADDR
45752: GO 45943
45754: LD_INT 4
45756: DOUBLE
45757: EQUAL
45758: IFTRUE 45780
45760: LD_INT 5
45762: DOUBLE
45763: EQUAL
45764: IFTRUE 45780
45766: LD_INT 34
45768: DOUBLE
45769: EQUAL
45770: IFTRUE 45780
45772: LD_INT 37
45774: DOUBLE
45775: EQUAL
45776: IFTRUE 45780
45778: GO 45836
45780: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45781: LD_ADDR_VAR 0 9
45785: PUSH
45786: LD_VAR 0 53
45790: PUSH
45791: LD_VAR 0 54
45795: PUSH
45796: LD_VAR 0 55
45800: PUSH
45801: LD_VAR 0 56
45805: PUSH
45806: LD_VAR 0 57
45810: PUSH
45811: LD_VAR 0 58
45815: PUSH
45816: EMPTY
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: PUSH
45824: LD_VAR 0 4
45828: PUSH
45829: LD_INT 1
45831: PLUS
45832: ARRAY
45833: ST_TO_ADDR
45834: GO 45943
45836: LD_INT 31
45838: DOUBLE
45839: EQUAL
45840: IFTRUE 45886
45842: LD_INT 32
45844: DOUBLE
45845: EQUAL
45846: IFTRUE 45886
45848: LD_INT 33
45850: DOUBLE
45851: EQUAL
45852: IFTRUE 45886
45854: LD_INT 27
45856: DOUBLE
45857: EQUAL
45858: IFTRUE 45886
45860: LD_INT 26
45862: DOUBLE
45863: EQUAL
45864: IFTRUE 45886
45866: LD_INT 28
45868: DOUBLE
45869: EQUAL
45870: IFTRUE 45886
45872: LD_INT 29
45874: DOUBLE
45875: EQUAL
45876: IFTRUE 45886
45878: LD_INT 30
45880: DOUBLE
45881: EQUAL
45882: IFTRUE 45886
45884: GO 45942
45886: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
45887: LD_ADDR_VAR 0 9
45891: PUSH
45892: LD_VAR 0 59
45896: PUSH
45897: LD_VAR 0 60
45901: PUSH
45902: LD_VAR 0 61
45906: PUSH
45907: LD_VAR 0 62
45911: PUSH
45912: LD_VAR 0 63
45916: PUSH
45917: LD_VAR 0 64
45921: PUSH
45922: EMPTY
45923: LIST
45924: LIST
45925: LIST
45926: LIST
45927: LIST
45928: LIST
45929: PUSH
45930: LD_VAR 0 4
45934: PUSH
45935: LD_INT 1
45937: PLUS
45938: ARRAY
45939: ST_TO_ADDR
45940: GO 45943
45942: POP
// temp_list2 = [ ] ;
45943: LD_ADDR_VAR 0 10
45947: PUSH
45948: EMPTY
45949: ST_TO_ADDR
// for i in temp_list do
45950: LD_ADDR_VAR 0 8
45954: PUSH
45955: LD_VAR 0 9
45959: PUSH
45960: FOR_IN
45961: IFFALSE 46013
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
45963: LD_ADDR_VAR 0 10
45967: PUSH
45968: LD_VAR 0 10
45972: PUSH
45973: LD_VAR 0 8
45977: PUSH
45978: LD_INT 1
45980: ARRAY
45981: PUSH
45982: LD_VAR 0 2
45986: PLUS
45987: PUSH
45988: LD_VAR 0 8
45992: PUSH
45993: LD_INT 2
45995: ARRAY
45996: PUSH
45997: LD_VAR 0 3
46001: PLUS
46002: PUSH
46003: EMPTY
46004: LIST
46005: LIST
46006: PUSH
46007: EMPTY
46008: LIST
46009: ADD
46010: ST_TO_ADDR
46011: GO 45960
46013: POP
46014: POP
// result = temp_list2 ;
46015: LD_ADDR_VAR 0 7
46019: PUSH
46020: LD_VAR 0 10
46024: ST_TO_ADDR
// end ;
46025: LD_VAR 0 7
46029: RET
// export function EnemyInRange ( unit , dist ) ; begin
46030: LD_INT 0
46032: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46033: LD_ADDR_VAR 0 3
46037: PUSH
46038: LD_VAR 0 1
46042: PPUSH
46043: CALL_OW 255
46047: PPUSH
46048: LD_VAR 0 1
46052: PPUSH
46053: CALL_OW 250
46057: PPUSH
46058: LD_VAR 0 1
46062: PPUSH
46063: CALL_OW 251
46067: PPUSH
46068: LD_VAR 0 2
46072: PPUSH
46073: CALL 20134 0 4
46077: PUSH
46078: LD_INT 4
46080: ARRAY
46081: ST_TO_ADDR
// end ;
46082: LD_VAR 0 3
46086: RET
// export function PlayerSeeMe ( unit ) ; begin
46087: LD_INT 0
46089: PPUSH
// result := See ( your_side , unit ) ;
46090: LD_ADDR_VAR 0 2
46094: PUSH
46095: LD_OWVAR 2
46099: PPUSH
46100: LD_VAR 0 1
46104: PPUSH
46105: CALL_OW 292
46109: ST_TO_ADDR
// end ;
46110: LD_VAR 0 2
46114: RET
// export function ReverseDir ( unit ) ; begin
46115: LD_INT 0
46117: PPUSH
// if not unit then
46118: LD_VAR 0 1
46122: NOT
46123: IFFALSE 46127
// exit ;
46125: GO 46150
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46127: LD_ADDR_VAR 0 2
46131: PUSH
46132: LD_VAR 0 1
46136: PPUSH
46137: CALL_OW 254
46141: PUSH
46142: LD_INT 3
46144: PLUS
46145: PUSH
46146: LD_INT 6
46148: MOD
46149: ST_TO_ADDR
// end ;
46150: LD_VAR 0 2
46154: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
46155: LD_INT 0
46157: PPUSH
46158: PPUSH
46159: PPUSH
46160: PPUSH
46161: PPUSH
// if not hexes then
46162: LD_VAR 0 2
46166: NOT
46167: IFFALSE 46171
// exit ;
46169: GO 46319
// dist := 9999 ;
46171: LD_ADDR_VAR 0 5
46175: PUSH
46176: LD_INT 9999
46178: ST_TO_ADDR
// for i = 1 to hexes do
46179: LD_ADDR_VAR 0 4
46183: PUSH
46184: DOUBLE
46185: LD_INT 1
46187: DEC
46188: ST_TO_ADDR
46189: LD_VAR 0 2
46193: PUSH
46194: FOR_TO
46195: IFFALSE 46307
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
46197: LD_VAR 0 1
46201: PPUSH
46202: LD_VAR 0 2
46206: PUSH
46207: LD_VAR 0 4
46211: ARRAY
46212: PUSH
46213: LD_INT 1
46215: ARRAY
46216: PPUSH
46217: LD_VAR 0 2
46221: PUSH
46222: LD_VAR 0 4
46226: ARRAY
46227: PUSH
46228: LD_INT 2
46230: ARRAY
46231: PPUSH
46232: CALL_OW 297
46236: PUSH
46237: LD_VAR 0 5
46241: LESS
46242: IFFALSE 46305
// begin hex := hexes [ i ] ;
46244: LD_ADDR_VAR 0 7
46248: PUSH
46249: LD_VAR 0 2
46253: PUSH
46254: LD_VAR 0 4
46258: ARRAY
46259: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46260: LD_ADDR_VAR 0 5
46264: PUSH
46265: LD_VAR 0 1
46269: PPUSH
46270: LD_VAR 0 2
46274: PUSH
46275: LD_VAR 0 4
46279: ARRAY
46280: PUSH
46281: LD_INT 1
46283: ARRAY
46284: PPUSH
46285: LD_VAR 0 2
46289: PUSH
46290: LD_VAR 0 4
46294: ARRAY
46295: PUSH
46296: LD_INT 2
46298: ARRAY
46299: PPUSH
46300: CALL_OW 297
46304: ST_TO_ADDR
// end ; end ;
46305: GO 46194
46307: POP
46308: POP
// result := hex ;
46309: LD_ADDR_VAR 0 3
46313: PUSH
46314: LD_VAR 0 7
46318: ST_TO_ADDR
// end ;
46319: LD_VAR 0 3
46323: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
46324: LD_INT 0
46326: PPUSH
46327: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
46328: LD_VAR 0 1
46332: NOT
46333: PUSH
46334: LD_VAR 0 1
46338: PUSH
46339: LD_INT 21
46341: PUSH
46342: LD_INT 2
46344: PUSH
46345: EMPTY
46346: LIST
46347: LIST
46348: PUSH
46349: LD_INT 23
46351: PUSH
46352: LD_INT 2
46354: PUSH
46355: EMPTY
46356: LIST
46357: LIST
46358: PUSH
46359: EMPTY
46360: LIST
46361: LIST
46362: PPUSH
46363: CALL_OW 69
46367: IN
46368: NOT
46369: OR
46370: IFFALSE 46374
// exit ;
46372: GO 46421
// for i = 1 to 3 do
46374: LD_ADDR_VAR 0 3
46378: PUSH
46379: DOUBLE
46380: LD_INT 1
46382: DEC
46383: ST_TO_ADDR
46384: LD_INT 3
46386: PUSH
46387: FOR_TO
46388: IFFALSE 46419
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46390: LD_VAR 0 1
46394: PPUSH
46395: CALL_OW 250
46399: PPUSH
46400: LD_VAR 0 1
46404: PPUSH
46405: CALL_OW 251
46409: PPUSH
46410: LD_INT 1
46412: PPUSH
46413: CALL_OW 453
46417: GO 46387
46419: POP
46420: POP
// end ;
46421: LD_VAR 0 2
46425: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46426: LD_INT 0
46428: PPUSH
46429: PPUSH
46430: PPUSH
46431: PPUSH
46432: PPUSH
46433: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46434: LD_VAR 0 1
46438: NOT
46439: PUSH
46440: LD_VAR 0 2
46444: NOT
46445: OR
46446: PUSH
46447: LD_VAR 0 1
46451: PPUSH
46452: CALL_OW 314
46456: OR
46457: IFFALSE 46461
// exit ;
46459: GO 46902
// x := GetX ( enemy_unit ) ;
46461: LD_ADDR_VAR 0 7
46465: PUSH
46466: LD_VAR 0 2
46470: PPUSH
46471: CALL_OW 250
46475: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46476: LD_ADDR_VAR 0 8
46480: PUSH
46481: LD_VAR 0 2
46485: PPUSH
46486: CALL_OW 251
46490: ST_TO_ADDR
// if not x or not y then
46491: LD_VAR 0 7
46495: NOT
46496: PUSH
46497: LD_VAR 0 8
46501: NOT
46502: OR
46503: IFFALSE 46507
// exit ;
46505: GO 46902
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46507: LD_ADDR_VAR 0 6
46511: PUSH
46512: LD_VAR 0 7
46516: PPUSH
46517: LD_INT 0
46519: PPUSH
46520: LD_INT 4
46522: PPUSH
46523: CALL_OW 272
46527: PUSH
46528: LD_VAR 0 8
46532: PPUSH
46533: LD_INT 0
46535: PPUSH
46536: LD_INT 4
46538: PPUSH
46539: CALL_OW 273
46543: PUSH
46544: EMPTY
46545: LIST
46546: LIST
46547: PUSH
46548: LD_VAR 0 7
46552: PPUSH
46553: LD_INT 1
46555: PPUSH
46556: LD_INT 4
46558: PPUSH
46559: CALL_OW 272
46563: PUSH
46564: LD_VAR 0 8
46568: PPUSH
46569: LD_INT 1
46571: PPUSH
46572: LD_INT 4
46574: PPUSH
46575: CALL_OW 273
46579: PUSH
46580: EMPTY
46581: LIST
46582: LIST
46583: PUSH
46584: LD_VAR 0 7
46588: PPUSH
46589: LD_INT 2
46591: PPUSH
46592: LD_INT 4
46594: PPUSH
46595: CALL_OW 272
46599: PUSH
46600: LD_VAR 0 8
46604: PPUSH
46605: LD_INT 2
46607: PPUSH
46608: LD_INT 4
46610: PPUSH
46611: CALL_OW 273
46615: PUSH
46616: EMPTY
46617: LIST
46618: LIST
46619: PUSH
46620: LD_VAR 0 7
46624: PPUSH
46625: LD_INT 3
46627: PPUSH
46628: LD_INT 4
46630: PPUSH
46631: CALL_OW 272
46635: PUSH
46636: LD_VAR 0 8
46640: PPUSH
46641: LD_INT 3
46643: PPUSH
46644: LD_INT 4
46646: PPUSH
46647: CALL_OW 273
46651: PUSH
46652: EMPTY
46653: LIST
46654: LIST
46655: PUSH
46656: LD_VAR 0 7
46660: PPUSH
46661: LD_INT 4
46663: PPUSH
46664: LD_INT 4
46666: PPUSH
46667: CALL_OW 272
46671: PUSH
46672: LD_VAR 0 8
46676: PPUSH
46677: LD_INT 4
46679: PPUSH
46680: LD_INT 4
46682: PPUSH
46683: CALL_OW 273
46687: PUSH
46688: EMPTY
46689: LIST
46690: LIST
46691: PUSH
46692: LD_VAR 0 7
46696: PPUSH
46697: LD_INT 5
46699: PPUSH
46700: LD_INT 4
46702: PPUSH
46703: CALL_OW 272
46707: PUSH
46708: LD_VAR 0 8
46712: PPUSH
46713: LD_INT 5
46715: PPUSH
46716: LD_INT 4
46718: PPUSH
46719: CALL_OW 273
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: PUSH
46728: EMPTY
46729: LIST
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: ST_TO_ADDR
// for i = tmp downto 1 do
46736: LD_ADDR_VAR 0 4
46740: PUSH
46741: DOUBLE
46742: LD_VAR 0 6
46746: INC
46747: ST_TO_ADDR
46748: LD_INT 1
46750: PUSH
46751: FOR_DOWNTO
46752: IFFALSE 46853
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46754: LD_VAR 0 6
46758: PUSH
46759: LD_VAR 0 4
46763: ARRAY
46764: PUSH
46765: LD_INT 1
46767: ARRAY
46768: PPUSH
46769: LD_VAR 0 6
46773: PUSH
46774: LD_VAR 0 4
46778: ARRAY
46779: PUSH
46780: LD_INT 2
46782: ARRAY
46783: PPUSH
46784: CALL_OW 488
46788: NOT
46789: PUSH
46790: LD_VAR 0 6
46794: PUSH
46795: LD_VAR 0 4
46799: ARRAY
46800: PUSH
46801: LD_INT 1
46803: ARRAY
46804: PPUSH
46805: LD_VAR 0 6
46809: PUSH
46810: LD_VAR 0 4
46814: ARRAY
46815: PUSH
46816: LD_INT 2
46818: ARRAY
46819: PPUSH
46820: CALL_OW 428
46824: PUSH
46825: LD_INT 0
46827: NONEQUAL
46828: OR
46829: IFFALSE 46851
// tmp := Delete ( tmp , i ) ;
46831: LD_ADDR_VAR 0 6
46835: PUSH
46836: LD_VAR 0 6
46840: PPUSH
46841: LD_VAR 0 4
46845: PPUSH
46846: CALL_OW 3
46850: ST_TO_ADDR
46851: GO 46751
46853: POP
46854: POP
// j := GetClosestHex ( unit , tmp ) ;
46855: LD_ADDR_VAR 0 5
46859: PUSH
46860: LD_VAR 0 1
46864: PPUSH
46865: LD_VAR 0 6
46869: PPUSH
46870: CALL 46155 0 2
46874: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46875: LD_VAR 0 1
46879: PPUSH
46880: LD_VAR 0 5
46884: PUSH
46885: LD_INT 1
46887: ARRAY
46888: PPUSH
46889: LD_VAR 0 5
46893: PUSH
46894: LD_INT 2
46896: ARRAY
46897: PPUSH
46898: CALL_OW 111
// end ;
46902: LD_VAR 0 3
46906: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46907: LD_INT 0
46909: PPUSH
46910: PPUSH
46911: PPUSH
// uc_side = 0 ;
46912: LD_ADDR_OWVAR 20
46916: PUSH
46917: LD_INT 0
46919: ST_TO_ADDR
// uc_nation = 0 ;
46920: LD_ADDR_OWVAR 21
46924: PUSH
46925: LD_INT 0
46927: ST_TO_ADDR
// InitHc_All ( ) ;
46928: CALL_OW 584
// InitVc ;
46932: CALL_OW 20
// if mastodonts then
46936: LD_VAR 0 6
46940: IFFALSE 47007
// for i = 1 to mastodonts do
46942: LD_ADDR_VAR 0 11
46946: PUSH
46947: DOUBLE
46948: LD_INT 1
46950: DEC
46951: ST_TO_ADDR
46952: LD_VAR 0 6
46956: PUSH
46957: FOR_TO
46958: IFFALSE 47005
// begin vc_chassis := 31 ;
46960: LD_ADDR_OWVAR 37
46964: PUSH
46965: LD_INT 31
46967: ST_TO_ADDR
// vc_control := control_rider ;
46968: LD_ADDR_OWVAR 38
46972: PUSH
46973: LD_INT 4
46975: ST_TO_ADDR
// animal := CreateVehicle ;
46976: LD_ADDR_VAR 0 12
46980: PUSH
46981: CALL_OW 45
46985: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46986: LD_VAR 0 12
46990: PPUSH
46991: LD_VAR 0 8
46995: PPUSH
46996: LD_INT 0
46998: PPUSH
46999: CALL 49195 0 3
// end ;
47003: GO 46957
47005: POP
47006: POP
// if horses then
47007: LD_VAR 0 5
47011: IFFALSE 47078
// for i = 1 to horses do
47013: LD_ADDR_VAR 0 11
47017: PUSH
47018: DOUBLE
47019: LD_INT 1
47021: DEC
47022: ST_TO_ADDR
47023: LD_VAR 0 5
47027: PUSH
47028: FOR_TO
47029: IFFALSE 47076
// begin hc_class := 21 ;
47031: LD_ADDR_OWVAR 28
47035: PUSH
47036: LD_INT 21
47038: ST_TO_ADDR
// hc_gallery :=  ;
47039: LD_ADDR_OWVAR 33
47043: PUSH
47044: LD_STRING 
47046: ST_TO_ADDR
// animal := CreateHuman ;
47047: LD_ADDR_VAR 0 12
47051: PUSH
47052: CALL_OW 44
47056: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47057: LD_VAR 0 12
47061: PPUSH
47062: LD_VAR 0 8
47066: PPUSH
47067: LD_INT 0
47069: PPUSH
47070: CALL 49195 0 3
// end ;
47074: GO 47028
47076: POP
47077: POP
// if birds then
47078: LD_VAR 0 1
47082: IFFALSE 47149
// for i = 1 to birds do
47084: LD_ADDR_VAR 0 11
47088: PUSH
47089: DOUBLE
47090: LD_INT 1
47092: DEC
47093: ST_TO_ADDR
47094: LD_VAR 0 1
47098: PUSH
47099: FOR_TO
47100: IFFALSE 47147
// begin hc_class = 18 ;
47102: LD_ADDR_OWVAR 28
47106: PUSH
47107: LD_INT 18
47109: ST_TO_ADDR
// hc_gallery =  ;
47110: LD_ADDR_OWVAR 33
47114: PUSH
47115: LD_STRING 
47117: ST_TO_ADDR
// animal := CreateHuman ;
47118: LD_ADDR_VAR 0 12
47122: PUSH
47123: CALL_OW 44
47127: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47128: LD_VAR 0 12
47132: PPUSH
47133: LD_VAR 0 8
47137: PPUSH
47138: LD_INT 0
47140: PPUSH
47141: CALL 49195 0 3
// end ;
47145: GO 47099
47147: POP
47148: POP
// if tigers then
47149: LD_VAR 0 2
47153: IFFALSE 47237
// for i = 1 to tigers do
47155: LD_ADDR_VAR 0 11
47159: PUSH
47160: DOUBLE
47161: LD_INT 1
47163: DEC
47164: ST_TO_ADDR
47165: LD_VAR 0 2
47169: PUSH
47170: FOR_TO
47171: IFFALSE 47235
// begin hc_class = class_tiger ;
47173: LD_ADDR_OWVAR 28
47177: PUSH
47178: LD_INT 14
47180: ST_TO_ADDR
// hc_gallery =  ;
47181: LD_ADDR_OWVAR 33
47185: PUSH
47186: LD_STRING 
47188: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47189: LD_ADDR_OWVAR 35
47193: PUSH
47194: LD_INT 7
47196: NEG
47197: PPUSH
47198: LD_INT 7
47200: PPUSH
47201: CALL_OW 12
47205: ST_TO_ADDR
// animal := CreateHuman ;
47206: LD_ADDR_VAR 0 12
47210: PUSH
47211: CALL_OW 44
47215: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47216: LD_VAR 0 12
47220: PPUSH
47221: LD_VAR 0 8
47225: PPUSH
47226: LD_INT 0
47228: PPUSH
47229: CALL 49195 0 3
// end ;
47233: GO 47170
47235: POP
47236: POP
// if apemans then
47237: LD_VAR 0 3
47241: IFFALSE 47364
// for i = 1 to apemans do
47243: LD_ADDR_VAR 0 11
47247: PUSH
47248: DOUBLE
47249: LD_INT 1
47251: DEC
47252: ST_TO_ADDR
47253: LD_VAR 0 3
47257: PUSH
47258: FOR_TO
47259: IFFALSE 47362
// begin hc_class = class_apeman ;
47261: LD_ADDR_OWVAR 28
47265: PUSH
47266: LD_INT 12
47268: ST_TO_ADDR
// hc_gallery =  ;
47269: LD_ADDR_OWVAR 33
47273: PUSH
47274: LD_STRING 
47276: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
47277: LD_ADDR_OWVAR 35
47281: PUSH
47282: LD_INT 5
47284: NEG
47285: PPUSH
47286: LD_INT 5
47288: PPUSH
47289: CALL_OW 12
47293: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
47294: LD_ADDR_OWVAR 31
47298: PUSH
47299: LD_INT 1
47301: PPUSH
47302: LD_INT 3
47304: PPUSH
47305: CALL_OW 12
47309: PUSH
47310: LD_INT 1
47312: PPUSH
47313: LD_INT 3
47315: PPUSH
47316: CALL_OW 12
47320: PUSH
47321: LD_INT 0
47323: PUSH
47324: LD_INT 0
47326: PUSH
47327: EMPTY
47328: LIST
47329: LIST
47330: LIST
47331: LIST
47332: ST_TO_ADDR
// animal := CreateHuman ;
47333: LD_ADDR_VAR 0 12
47337: PUSH
47338: CALL_OW 44
47342: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47343: LD_VAR 0 12
47347: PPUSH
47348: LD_VAR 0 8
47352: PPUSH
47353: LD_INT 0
47355: PPUSH
47356: CALL 49195 0 3
// end ;
47360: GO 47258
47362: POP
47363: POP
// if enchidnas then
47364: LD_VAR 0 4
47368: IFFALSE 47435
// for i = 1 to enchidnas do
47370: LD_ADDR_VAR 0 11
47374: PUSH
47375: DOUBLE
47376: LD_INT 1
47378: DEC
47379: ST_TO_ADDR
47380: LD_VAR 0 4
47384: PUSH
47385: FOR_TO
47386: IFFALSE 47433
// begin hc_class = 13 ;
47388: LD_ADDR_OWVAR 28
47392: PUSH
47393: LD_INT 13
47395: ST_TO_ADDR
// hc_gallery =  ;
47396: LD_ADDR_OWVAR 33
47400: PUSH
47401: LD_STRING 
47403: ST_TO_ADDR
// animal := CreateHuman ;
47404: LD_ADDR_VAR 0 12
47408: PUSH
47409: CALL_OW 44
47413: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47414: LD_VAR 0 12
47418: PPUSH
47419: LD_VAR 0 8
47423: PPUSH
47424: LD_INT 0
47426: PPUSH
47427: CALL 49195 0 3
// end ;
47431: GO 47385
47433: POP
47434: POP
// if fishes then
47435: LD_VAR 0 7
47439: IFFALSE 47506
// for i = 1 to fishes do
47441: LD_ADDR_VAR 0 11
47445: PUSH
47446: DOUBLE
47447: LD_INT 1
47449: DEC
47450: ST_TO_ADDR
47451: LD_VAR 0 7
47455: PUSH
47456: FOR_TO
47457: IFFALSE 47504
// begin hc_class = 20 ;
47459: LD_ADDR_OWVAR 28
47463: PUSH
47464: LD_INT 20
47466: ST_TO_ADDR
// hc_gallery =  ;
47467: LD_ADDR_OWVAR 33
47471: PUSH
47472: LD_STRING 
47474: ST_TO_ADDR
// animal := CreateHuman ;
47475: LD_ADDR_VAR 0 12
47479: PUSH
47480: CALL_OW 44
47484: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
47485: LD_VAR 0 12
47489: PPUSH
47490: LD_VAR 0 9
47494: PPUSH
47495: LD_INT 0
47497: PPUSH
47498: CALL 49195 0 3
// end ;
47502: GO 47456
47504: POP
47505: POP
// end ;
47506: LD_VAR 0 10
47510: RET
// export function WantHeal ( sci , unit ) ; begin
47511: LD_INT 0
47513: PPUSH
// if GetTaskList ( sci ) > 0 then
47514: LD_VAR 0 1
47518: PPUSH
47519: CALL_OW 437
47523: PUSH
47524: LD_INT 0
47526: GREATER
47527: IFFALSE 47597
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
47529: LD_VAR 0 1
47533: PPUSH
47534: CALL_OW 437
47538: PUSH
47539: LD_INT 1
47541: ARRAY
47542: PUSH
47543: LD_INT 1
47545: ARRAY
47546: PUSH
47547: LD_STRING l
47549: EQUAL
47550: PUSH
47551: LD_VAR 0 1
47555: PPUSH
47556: CALL_OW 437
47560: PUSH
47561: LD_INT 1
47563: ARRAY
47564: PUSH
47565: LD_INT 4
47567: ARRAY
47568: PUSH
47569: LD_VAR 0 2
47573: EQUAL
47574: AND
47575: IFFALSE 47587
// result := true else
47577: LD_ADDR_VAR 0 3
47581: PUSH
47582: LD_INT 1
47584: ST_TO_ADDR
47585: GO 47595
// result := false ;
47587: LD_ADDR_VAR 0 3
47591: PUSH
47592: LD_INT 0
47594: ST_TO_ADDR
// end else
47595: GO 47605
// result := false ;
47597: LD_ADDR_VAR 0 3
47601: PUSH
47602: LD_INT 0
47604: ST_TO_ADDR
// end ;
47605: LD_VAR 0 3
47609: RET
// export function HealTarget ( sci ) ; begin
47610: LD_INT 0
47612: PPUSH
// if not sci then
47613: LD_VAR 0 1
47617: NOT
47618: IFFALSE 47622
// exit ;
47620: GO 47687
// result := 0 ;
47622: LD_ADDR_VAR 0 2
47626: PUSH
47627: LD_INT 0
47629: ST_TO_ADDR
// if GetTaskList ( sci ) then
47630: LD_VAR 0 1
47634: PPUSH
47635: CALL_OW 437
47639: IFFALSE 47687
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
47641: LD_VAR 0 1
47645: PPUSH
47646: CALL_OW 437
47650: PUSH
47651: LD_INT 1
47653: ARRAY
47654: PUSH
47655: LD_INT 1
47657: ARRAY
47658: PUSH
47659: LD_STRING l
47661: EQUAL
47662: IFFALSE 47687
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
47664: LD_ADDR_VAR 0 2
47668: PUSH
47669: LD_VAR 0 1
47673: PPUSH
47674: CALL_OW 437
47678: PUSH
47679: LD_INT 1
47681: ARRAY
47682: PUSH
47683: LD_INT 4
47685: ARRAY
47686: ST_TO_ADDR
// end ;
47687: LD_VAR 0 2
47691: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
47692: LD_INT 0
47694: PPUSH
47695: PPUSH
47696: PPUSH
47697: PPUSH
// if not base_units then
47698: LD_VAR 0 1
47702: NOT
47703: IFFALSE 47707
// exit ;
47705: GO 47794
// result := false ;
47707: LD_ADDR_VAR 0 2
47711: PUSH
47712: LD_INT 0
47714: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
47715: LD_ADDR_VAR 0 5
47719: PUSH
47720: LD_VAR 0 1
47724: PPUSH
47725: LD_INT 21
47727: PUSH
47728: LD_INT 3
47730: PUSH
47731: EMPTY
47732: LIST
47733: LIST
47734: PPUSH
47735: CALL_OW 72
47739: ST_TO_ADDR
// if not tmp then
47740: LD_VAR 0 5
47744: NOT
47745: IFFALSE 47749
// exit ;
47747: GO 47794
// for i in tmp do
47749: LD_ADDR_VAR 0 3
47753: PUSH
47754: LD_VAR 0 5
47758: PUSH
47759: FOR_IN
47760: IFFALSE 47792
// begin result := EnemyInRange ( i , 22 ) ;
47762: LD_ADDR_VAR 0 2
47766: PUSH
47767: LD_VAR 0 3
47771: PPUSH
47772: LD_INT 22
47774: PPUSH
47775: CALL 46030 0 2
47779: ST_TO_ADDR
// if result then
47780: LD_VAR 0 2
47784: IFFALSE 47790
// exit ;
47786: POP
47787: POP
47788: GO 47794
// end ;
47790: GO 47759
47792: POP
47793: POP
// end ;
47794: LD_VAR 0 2
47798: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
47799: LD_INT 0
47801: PPUSH
47802: PPUSH
// if not units then
47803: LD_VAR 0 1
47807: NOT
47808: IFFALSE 47812
// exit ;
47810: GO 47882
// result := [ ] ;
47812: LD_ADDR_VAR 0 3
47816: PUSH
47817: EMPTY
47818: ST_TO_ADDR
// for i in units do
47819: LD_ADDR_VAR 0 4
47823: PUSH
47824: LD_VAR 0 1
47828: PUSH
47829: FOR_IN
47830: IFFALSE 47880
// if GetTag ( i ) = tag then
47832: LD_VAR 0 4
47836: PPUSH
47837: CALL_OW 110
47841: PUSH
47842: LD_VAR 0 2
47846: EQUAL
47847: IFFALSE 47878
// result := Insert ( result , result + 1 , i ) ;
47849: LD_ADDR_VAR 0 3
47853: PUSH
47854: LD_VAR 0 3
47858: PPUSH
47859: LD_VAR 0 3
47863: PUSH
47864: LD_INT 1
47866: PLUS
47867: PPUSH
47868: LD_VAR 0 4
47872: PPUSH
47873: CALL_OW 2
47877: ST_TO_ADDR
47878: GO 47829
47880: POP
47881: POP
// end ;
47882: LD_VAR 0 3
47886: RET
// export function IsDriver ( un ) ; begin
47887: LD_INT 0
47889: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
47890: LD_ADDR_VAR 0 2
47894: PUSH
47895: LD_VAR 0 1
47899: PUSH
47900: LD_INT 55
47902: PUSH
47903: EMPTY
47904: LIST
47905: PPUSH
47906: CALL_OW 69
47910: IN
47911: ST_TO_ADDR
// end ;
47912: LD_VAR 0 2
47916: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
47917: LD_INT 0
47919: PPUSH
47920: PPUSH
// list := [ ] ;
47921: LD_ADDR_VAR 0 5
47925: PUSH
47926: EMPTY
47927: ST_TO_ADDR
// case d of 0 :
47928: LD_VAR 0 3
47932: PUSH
47933: LD_INT 0
47935: DOUBLE
47936: EQUAL
47937: IFTRUE 47941
47939: GO 48074
47941: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
47942: LD_ADDR_VAR 0 5
47946: PUSH
47947: LD_VAR 0 1
47951: PUSH
47952: LD_INT 4
47954: MINUS
47955: PUSH
47956: LD_VAR 0 2
47960: PUSH
47961: LD_INT 4
47963: MINUS
47964: PUSH
47965: LD_INT 2
47967: PUSH
47968: EMPTY
47969: LIST
47970: LIST
47971: LIST
47972: PUSH
47973: LD_VAR 0 1
47977: PUSH
47978: LD_INT 3
47980: MINUS
47981: PUSH
47982: LD_VAR 0 2
47986: PUSH
47987: LD_INT 1
47989: PUSH
47990: EMPTY
47991: LIST
47992: LIST
47993: LIST
47994: PUSH
47995: LD_VAR 0 1
47999: PUSH
48000: LD_INT 4
48002: PLUS
48003: PUSH
48004: LD_VAR 0 2
48008: PUSH
48009: LD_INT 4
48011: PUSH
48012: EMPTY
48013: LIST
48014: LIST
48015: LIST
48016: PUSH
48017: LD_VAR 0 1
48021: PUSH
48022: LD_INT 3
48024: PLUS
48025: PUSH
48026: LD_VAR 0 2
48030: PUSH
48031: LD_INT 3
48033: PLUS
48034: PUSH
48035: LD_INT 5
48037: PUSH
48038: EMPTY
48039: LIST
48040: LIST
48041: LIST
48042: PUSH
48043: LD_VAR 0 1
48047: PUSH
48048: LD_VAR 0 2
48052: PUSH
48053: LD_INT 4
48055: PLUS
48056: PUSH
48057: LD_INT 0
48059: PUSH
48060: EMPTY
48061: LIST
48062: LIST
48063: LIST
48064: PUSH
48065: EMPTY
48066: LIST
48067: LIST
48068: LIST
48069: LIST
48070: LIST
48071: ST_TO_ADDR
// end ; 1 :
48072: GO 48772
48074: LD_INT 1
48076: DOUBLE
48077: EQUAL
48078: IFTRUE 48082
48080: GO 48215
48082: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48083: LD_ADDR_VAR 0 5
48087: PUSH
48088: LD_VAR 0 1
48092: PUSH
48093: LD_VAR 0 2
48097: PUSH
48098: LD_INT 4
48100: MINUS
48101: PUSH
48102: LD_INT 3
48104: PUSH
48105: EMPTY
48106: LIST
48107: LIST
48108: LIST
48109: PUSH
48110: LD_VAR 0 1
48114: PUSH
48115: LD_INT 3
48117: MINUS
48118: PUSH
48119: LD_VAR 0 2
48123: PUSH
48124: LD_INT 3
48126: MINUS
48127: PUSH
48128: LD_INT 2
48130: PUSH
48131: EMPTY
48132: LIST
48133: LIST
48134: LIST
48135: PUSH
48136: LD_VAR 0 1
48140: PUSH
48141: LD_INT 4
48143: MINUS
48144: PUSH
48145: LD_VAR 0 2
48149: PUSH
48150: LD_INT 1
48152: PUSH
48153: EMPTY
48154: LIST
48155: LIST
48156: LIST
48157: PUSH
48158: LD_VAR 0 1
48162: PUSH
48163: LD_VAR 0 2
48167: PUSH
48168: LD_INT 3
48170: PLUS
48171: PUSH
48172: LD_INT 0
48174: PUSH
48175: EMPTY
48176: LIST
48177: LIST
48178: LIST
48179: PUSH
48180: LD_VAR 0 1
48184: PUSH
48185: LD_INT 4
48187: PLUS
48188: PUSH
48189: LD_VAR 0 2
48193: PUSH
48194: LD_INT 4
48196: PLUS
48197: PUSH
48198: LD_INT 5
48200: PUSH
48201: EMPTY
48202: LIST
48203: LIST
48204: LIST
48205: PUSH
48206: EMPTY
48207: LIST
48208: LIST
48209: LIST
48210: LIST
48211: LIST
48212: ST_TO_ADDR
// end ; 2 :
48213: GO 48772
48215: LD_INT 2
48217: DOUBLE
48218: EQUAL
48219: IFTRUE 48223
48221: GO 48352
48223: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48224: LD_ADDR_VAR 0 5
48228: PUSH
48229: LD_VAR 0 1
48233: PUSH
48234: LD_VAR 0 2
48238: PUSH
48239: LD_INT 3
48241: MINUS
48242: PUSH
48243: LD_INT 3
48245: PUSH
48246: EMPTY
48247: LIST
48248: LIST
48249: LIST
48250: PUSH
48251: LD_VAR 0 1
48255: PUSH
48256: LD_INT 4
48258: PLUS
48259: PUSH
48260: LD_VAR 0 2
48264: PUSH
48265: LD_INT 4
48267: PUSH
48268: EMPTY
48269: LIST
48270: LIST
48271: LIST
48272: PUSH
48273: LD_VAR 0 1
48277: PUSH
48278: LD_VAR 0 2
48282: PUSH
48283: LD_INT 4
48285: PLUS
48286: PUSH
48287: LD_INT 0
48289: PUSH
48290: EMPTY
48291: LIST
48292: LIST
48293: LIST
48294: PUSH
48295: LD_VAR 0 1
48299: PUSH
48300: LD_INT 3
48302: MINUS
48303: PUSH
48304: LD_VAR 0 2
48308: PUSH
48309: LD_INT 1
48311: PUSH
48312: EMPTY
48313: LIST
48314: LIST
48315: LIST
48316: PUSH
48317: LD_VAR 0 1
48321: PUSH
48322: LD_INT 4
48324: MINUS
48325: PUSH
48326: LD_VAR 0 2
48330: PUSH
48331: LD_INT 4
48333: MINUS
48334: PUSH
48335: LD_INT 2
48337: PUSH
48338: EMPTY
48339: LIST
48340: LIST
48341: LIST
48342: PUSH
48343: EMPTY
48344: LIST
48345: LIST
48346: LIST
48347: LIST
48348: LIST
48349: ST_TO_ADDR
// end ; 3 :
48350: GO 48772
48352: LD_INT 3
48354: DOUBLE
48355: EQUAL
48356: IFTRUE 48360
48358: GO 48493
48360: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
48361: LD_ADDR_VAR 0 5
48365: PUSH
48366: LD_VAR 0 1
48370: PUSH
48371: LD_INT 3
48373: PLUS
48374: PUSH
48375: LD_VAR 0 2
48379: PUSH
48380: LD_INT 4
48382: PUSH
48383: EMPTY
48384: LIST
48385: LIST
48386: LIST
48387: PUSH
48388: LD_VAR 0 1
48392: PUSH
48393: LD_INT 4
48395: PLUS
48396: PUSH
48397: LD_VAR 0 2
48401: PUSH
48402: LD_INT 4
48404: PLUS
48405: PUSH
48406: LD_INT 5
48408: PUSH
48409: EMPTY
48410: LIST
48411: LIST
48412: LIST
48413: PUSH
48414: LD_VAR 0 1
48418: PUSH
48419: LD_INT 4
48421: MINUS
48422: PUSH
48423: LD_VAR 0 2
48427: PUSH
48428: LD_INT 1
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: LIST
48435: PUSH
48436: LD_VAR 0 1
48440: PUSH
48441: LD_VAR 0 2
48445: PUSH
48446: LD_INT 4
48448: MINUS
48449: PUSH
48450: LD_INT 3
48452: PUSH
48453: EMPTY
48454: LIST
48455: LIST
48456: LIST
48457: PUSH
48458: LD_VAR 0 1
48462: PUSH
48463: LD_INT 3
48465: MINUS
48466: PUSH
48467: LD_VAR 0 2
48471: PUSH
48472: LD_INT 3
48474: MINUS
48475: PUSH
48476: LD_INT 2
48478: PUSH
48479: EMPTY
48480: LIST
48481: LIST
48482: LIST
48483: PUSH
48484: EMPTY
48485: LIST
48486: LIST
48487: LIST
48488: LIST
48489: LIST
48490: ST_TO_ADDR
// end ; 4 :
48491: GO 48772
48493: LD_INT 4
48495: DOUBLE
48496: EQUAL
48497: IFTRUE 48501
48499: GO 48634
48501: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
48502: LD_ADDR_VAR 0 5
48506: PUSH
48507: LD_VAR 0 1
48511: PUSH
48512: LD_VAR 0 2
48516: PUSH
48517: LD_INT 4
48519: PLUS
48520: PUSH
48521: LD_INT 0
48523: PUSH
48524: EMPTY
48525: LIST
48526: LIST
48527: LIST
48528: PUSH
48529: LD_VAR 0 1
48533: PUSH
48534: LD_INT 3
48536: PLUS
48537: PUSH
48538: LD_VAR 0 2
48542: PUSH
48543: LD_INT 3
48545: PLUS
48546: PUSH
48547: LD_INT 5
48549: PUSH
48550: EMPTY
48551: LIST
48552: LIST
48553: LIST
48554: PUSH
48555: LD_VAR 0 1
48559: PUSH
48560: LD_INT 4
48562: PLUS
48563: PUSH
48564: LD_VAR 0 2
48568: PUSH
48569: LD_INT 4
48571: PUSH
48572: EMPTY
48573: LIST
48574: LIST
48575: LIST
48576: PUSH
48577: LD_VAR 0 1
48581: PUSH
48582: LD_VAR 0 2
48586: PUSH
48587: LD_INT 3
48589: MINUS
48590: PUSH
48591: LD_INT 3
48593: PUSH
48594: EMPTY
48595: LIST
48596: LIST
48597: LIST
48598: PUSH
48599: LD_VAR 0 1
48603: PUSH
48604: LD_INT 4
48606: MINUS
48607: PUSH
48608: LD_VAR 0 2
48612: PUSH
48613: LD_INT 4
48615: MINUS
48616: PUSH
48617: LD_INT 2
48619: PUSH
48620: EMPTY
48621: LIST
48622: LIST
48623: LIST
48624: PUSH
48625: EMPTY
48626: LIST
48627: LIST
48628: LIST
48629: LIST
48630: LIST
48631: ST_TO_ADDR
// end ; 5 :
48632: GO 48772
48634: LD_INT 5
48636: DOUBLE
48637: EQUAL
48638: IFTRUE 48642
48640: GO 48771
48642: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
48643: LD_ADDR_VAR 0 5
48647: PUSH
48648: LD_VAR 0 1
48652: PUSH
48653: LD_INT 4
48655: MINUS
48656: PUSH
48657: LD_VAR 0 2
48661: PUSH
48662: LD_INT 1
48664: PUSH
48665: EMPTY
48666: LIST
48667: LIST
48668: LIST
48669: PUSH
48670: LD_VAR 0 1
48674: PUSH
48675: LD_VAR 0 2
48679: PUSH
48680: LD_INT 4
48682: MINUS
48683: PUSH
48684: LD_INT 3
48686: PUSH
48687: EMPTY
48688: LIST
48689: LIST
48690: LIST
48691: PUSH
48692: LD_VAR 0 1
48696: PUSH
48697: LD_INT 4
48699: PLUS
48700: PUSH
48701: LD_VAR 0 2
48705: PUSH
48706: LD_INT 4
48708: PLUS
48709: PUSH
48710: LD_INT 5
48712: PUSH
48713: EMPTY
48714: LIST
48715: LIST
48716: LIST
48717: PUSH
48718: LD_VAR 0 1
48722: PUSH
48723: LD_INT 3
48725: PLUS
48726: PUSH
48727: LD_VAR 0 2
48731: PUSH
48732: LD_INT 4
48734: PUSH
48735: EMPTY
48736: LIST
48737: LIST
48738: LIST
48739: PUSH
48740: LD_VAR 0 1
48744: PUSH
48745: LD_VAR 0 2
48749: PUSH
48750: LD_INT 3
48752: PLUS
48753: PUSH
48754: LD_INT 0
48756: PUSH
48757: EMPTY
48758: LIST
48759: LIST
48760: LIST
48761: PUSH
48762: EMPTY
48763: LIST
48764: LIST
48765: LIST
48766: LIST
48767: LIST
48768: ST_TO_ADDR
// end ; end ;
48769: GO 48772
48771: POP
// result := list ;
48772: LD_ADDR_VAR 0 4
48776: PUSH
48777: LD_VAR 0 5
48781: ST_TO_ADDR
// end ;
48782: LD_VAR 0 4
48786: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
48787: LD_INT 0
48789: PPUSH
48790: PPUSH
48791: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
48792: LD_VAR 0 1
48796: NOT
48797: PUSH
48798: LD_VAR 0 2
48802: PUSH
48803: LD_INT 1
48805: PUSH
48806: LD_INT 2
48808: PUSH
48809: LD_INT 3
48811: PUSH
48812: LD_INT 4
48814: PUSH
48815: EMPTY
48816: LIST
48817: LIST
48818: LIST
48819: LIST
48820: IN
48821: NOT
48822: OR
48823: IFFALSE 48827
// exit ;
48825: GO 48919
// tmp := [ ] ;
48827: LD_ADDR_VAR 0 5
48831: PUSH
48832: EMPTY
48833: ST_TO_ADDR
// for i in units do
48834: LD_ADDR_VAR 0 4
48838: PUSH
48839: LD_VAR 0 1
48843: PUSH
48844: FOR_IN
48845: IFFALSE 48888
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
48847: LD_ADDR_VAR 0 5
48851: PUSH
48852: LD_VAR 0 5
48856: PPUSH
48857: LD_VAR 0 5
48861: PUSH
48862: LD_INT 1
48864: PLUS
48865: PPUSH
48866: LD_VAR 0 4
48870: PPUSH
48871: LD_VAR 0 2
48875: PPUSH
48876: CALL_OW 259
48880: PPUSH
48881: CALL_OW 2
48885: ST_TO_ADDR
48886: GO 48844
48888: POP
48889: POP
// if not tmp then
48890: LD_VAR 0 5
48894: NOT
48895: IFFALSE 48899
// exit ;
48897: GO 48919
// result := SortListByListDesc ( units , tmp ) ;
48899: LD_ADDR_VAR 0 3
48903: PUSH
48904: LD_VAR 0 1
48908: PPUSH
48909: LD_VAR 0 5
48913: PPUSH
48914: CALL_OW 77
48918: ST_TO_ADDR
// end ;
48919: LD_VAR 0 3
48923: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
48924: LD_INT 0
48926: PPUSH
48927: PPUSH
48928: PPUSH
// result := false ;
48929: LD_ADDR_VAR 0 3
48933: PUSH
48934: LD_INT 0
48936: ST_TO_ADDR
// x := GetX ( building ) ;
48937: LD_ADDR_VAR 0 4
48941: PUSH
48942: LD_VAR 0 2
48946: PPUSH
48947: CALL_OW 250
48951: ST_TO_ADDR
// y := GetY ( building ) ;
48952: LD_ADDR_VAR 0 5
48956: PUSH
48957: LD_VAR 0 2
48961: PPUSH
48962: CALL_OW 251
48966: ST_TO_ADDR
// if not building or not x or not y then
48967: LD_VAR 0 2
48971: NOT
48972: PUSH
48973: LD_VAR 0 4
48977: NOT
48978: OR
48979: PUSH
48980: LD_VAR 0 5
48984: NOT
48985: OR
48986: IFFALSE 48990
// exit ;
48988: GO 49082
// if GetTaskList ( unit ) then
48990: LD_VAR 0 1
48994: PPUSH
48995: CALL_OW 437
48999: IFFALSE 49082
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49001: LD_STRING e
49003: PUSH
49004: LD_VAR 0 1
49008: PPUSH
49009: CALL_OW 437
49013: PUSH
49014: LD_INT 1
49016: ARRAY
49017: PUSH
49018: LD_INT 1
49020: ARRAY
49021: EQUAL
49022: PUSH
49023: LD_VAR 0 4
49027: PUSH
49028: LD_VAR 0 1
49032: PPUSH
49033: CALL_OW 437
49037: PUSH
49038: LD_INT 1
49040: ARRAY
49041: PUSH
49042: LD_INT 2
49044: ARRAY
49045: EQUAL
49046: AND
49047: PUSH
49048: LD_VAR 0 5
49052: PUSH
49053: LD_VAR 0 1
49057: PPUSH
49058: CALL_OW 437
49062: PUSH
49063: LD_INT 1
49065: ARRAY
49066: PUSH
49067: LD_INT 3
49069: ARRAY
49070: EQUAL
49071: AND
49072: IFFALSE 49082
// result := true end ;
49074: LD_ADDR_VAR 0 3
49078: PUSH
49079: LD_INT 1
49081: ST_TO_ADDR
// end ;
49082: LD_VAR 0 3
49086: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
49087: LD_INT 0
49089: PPUSH
// result := false ;
49090: LD_ADDR_VAR 0 4
49094: PUSH
49095: LD_INT 0
49097: ST_TO_ADDR
// if GetTaskList ( unit ) then
49098: LD_VAR 0 1
49102: PPUSH
49103: CALL_OW 437
49107: IFFALSE 49190
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49109: LD_STRING M
49111: PUSH
49112: LD_VAR 0 1
49116: PPUSH
49117: CALL_OW 437
49121: PUSH
49122: LD_INT 1
49124: ARRAY
49125: PUSH
49126: LD_INT 1
49128: ARRAY
49129: EQUAL
49130: PUSH
49131: LD_VAR 0 2
49135: PUSH
49136: LD_VAR 0 1
49140: PPUSH
49141: CALL_OW 437
49145: PUSH
49146: LD_INT 1
49148: ARRAY
49149: PUSH
49150: LD_INT 2
49152: ARRAY
49153: EQUAL
49154: AND
49155: PUSH
49156: LD_VAR 0 3
49160: PUSH
49161: LD_VAR 0 1
49165: PPUSH
49166: CALL_OW 437
49170: PUSH
49171: LD_INT 1
49173: ARRAY
49174: PUSH
49175: LD_INT 3
49177: ARRAY
49178: EQUAL
49179: AND
49180: IFFALSE 49190
// result := true ;
49182: LD_ADDR_VAR 0 4
49186: PUSH
49187: LD_INT 1
49189: ST_TO_ADDR
// end ; end ;
49190: LD_VAR 0 4
49194: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49195: LD_INT 0
49197: PPUSH
49198: PPUSH
49199: PPUSH
49200: PPUSH
// if not unit or not area then
49201: LD_VAR 0 1
49205: NOT
49206: PUSH
49207: LD_VAR 0 2
49211: NOT
49212: OR
49213: IFFALSE 49217
// exit ;
49215: GO 49381
// tmp := AreaToList ( area , i ) ;
49217: LD_ADDR_VAR 0 6
49221: PUSH
49222: LD_VAR 0 2
49226: PPUSH
49227: LD_VAR 0 5
49231: PPUSH
49232: CALL_OW 517
49236: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49237: LD_ADDR_VAR 0 5
49241: PUSH
49242: DOUBLE
49243: LD_INT 1
49245: DEC
49246: ST_TO_ADDR
49247: LD_VAR 0 6
49251: PUSH
49252: LD_INT 1
49254: ARRAY
49255: PUSH
49256: FOR_TO
49257: IFFALSE 49379
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
49259: LD_ADDR_VAR 0 7
49263: PUSH
49264: LD_VAR 0 6
49268: PUSH
49269: LD_INT 1
49271: ARRAY
49272: PUSH
49273: LD_VAR 0 5
49277: ARRAY
49278: PUSH
49279: LD_VAR 0 6
49283: PUSH
49284: LD_INT 2
49286: ARRAY
49287: PUSH
49288: LD_VAR 0 5
49292: ARRAY
49293: PUSH
49294: EMPTY
49295: LIST
49296: LIST
49297: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
49298: LD_VAR 0 7
49302: PUSH
49303: LD_INT 1
49305: ARRAY
49306: PPUSH
49307: LD_VAR 0 7
49311: PUSH
49312: LD_INT 2
49314: ARRAY
49315: PPUSH
49316: CALL_OW 428
49320: PUSH
49321: LD_INT 0
49323: EQUAL
49324: IFFALSE 49377
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
49326: LD_VAR 0 1
49330: PPUSH
49331: LD_VAR 0 7
49335: PUSH
49336: LD_INT 1
49338: ARRAY
49339: PPUSH
49340: LD_VAR 0 7
49344: PUSH
49345: LD_INT 2
49347: ARRAY
49348: PPUSH
49349: LD_VAR 0 3
49353: PPUSH
49354: CALL_OW 48
// result := IsPlaced ( unit ) ;
49358: LD_ADDR_VAR 0 4
49362: PUSH
49363: LD_VAR 0 1
49367: PPUSH
49368: CALL_OW 305
49372: ST_TO_ADDR
// exit ;
49373: POP
49374: POP
49375: GO 49381
// end ; end ;
49377: GO 49256
49379: POP
49380: POP
// end ;
49381: LD_VAR 0 4
49385: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
49386: LD_INT 0
49388: PPUSH
49389: PPUSH
49390: PPUSH
// if not side or side > 8 then
49391: LD_VAR 0 1
49395: NOT
49396: PUSH
49397: LD_VAR 0 1
49401: PUSH
49402: LD_INT 8
49404: GREATER
49405: OR
49406: IFFALSE 49410
// exit ;
49408: GO 49597
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
49410: LD_ADDR_VAR 0 4
49414: PUSH
49415: LD_INT 22
49417: PUSH
49418: LD_VAR 0 1
49422: PUSH
49423: EMPTY
49424: LIST
49425: LIST
49426: PUSH
49427: LD_INT 21
49429: PUSH
49430: LD_INT 3
49432: PUSH
49433: EMPTY
49434: LIST
49435: LIST
49436: PUSH
49437: EMPTY
49438: LIST
49439: LIST
49440: PPUSH
49441: CALL_OW 69
49445: ST_TO_ADDR
// if not tmp then
49446: LD_VAR 0 4
49450: NOT
49451: IFFALSE 49455
// exit ;
49453: GO 49597
// enable_addtolog := true ;
49455: LD_ADDR_OWVAR 81
49459: PUSH
49460: LD_INT 1
49462: ST_TO_ADDR
// AddToLog ( [ ) ;
49463: LD_STRING [
49465: PPUSH
49466: CALL_OW 561
// for i in tmp do
49470: LD_ADDR_VAR 0 3
49474: PUSH
49475: LD_VAR 0 4
49479: PUSH
49480: FOR_IN
49481: IFFALSE 49588
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
49483: LD_STRING [
49485: PUSH
49486: LD_VAR 0 3
49490: PPUSH
49491: CALL_OW 266
49495: STR
49496: PUSH
49497: LD_STRING , 
49499: STR
49500: PUSH
49501: LD_VAR 0 3
49505: PPUSH
49506: CALL_OW 250
49510: STR
49511: PUSH
49512: LD_STRING , 
49514: STR
49515: PUSH
49516: LD_VAR 0 3
49520: PPUSH
49521: CALL_OW 251
49525: STR
49526: PUSH
49527: LD_STRING , 
49529: STR
49530: PUSH
49531: LD_VAR 0 3
49535: PPUSH
49536: CALL_OW 254
49540: STR
49541: PUSH
49542: LD_STRING , 
49544: STR
49545: PUSH
49546: LD_VAR 0 3
49550: PPUSH
49551: LD_INT 1
49553: PPUSH
49554: CALL_OW 268
49558: STR
49559: PUSH
49560: LD_STRING , 
49562: STR
49563: PUSH
49564: LD_VAR 0 3
49568: PPUSH
49569: LD_INT 2
49571: PPUSH
49572: CALL_OW 268
49576: STR
49577: PUSH
49578: LD_STRING ],
49580: STR
49581: PPUSH
49582: CALL_OW 561
// end ;
49586: GO 49480
49588: POP
49589: POP
// AddToLog ( ]; ) ;
49590: LD_STRING ];
49592: PPUSH
49593: CALL_OW 561
// end ;
49597: LD_VAR 0 2
49601: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
49602: LD_INT 0
49604: PPUSH
49605: PPUSH
49606: PPUSH
49607: PPUSH
49608: PPUSH
// if not area or not rate or not max then
49609: LD_VAR 0 1
49613: NOT
49614: PUSH
49615: LD_VAR 0 2
49619: NOT
49620: OR
49621: PUSH
49622: LD_VAR 0 4
49626: NOT
49627: OR
49628: IFFALSE 49632
// exit ;
49630: GO 49824
// while 1 do
49632: LD_INT 1
49634: IFFALSE 49824
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
49636: LD_ADDR_VAR 0 9
49640: PUSH
49641: LD_VAR 0 1
49645: PPUSH
49646: LD_INT 1
49648: PPUSH
49649: CALL_OW 287
49653: PUSH
49654: LD_INT 10
49656: MUL
49657: ST_TO_ADDR
// r := rate / 10 ;
49658: LD_ADDR_VAR 0 7
49662: PUSH
49663: LD_VAR 0 2
49667: PUSH
49668: LD_INT 10
49670: DIVREAL
49671: ST_TO_ADDR
// time := 1 1$00 ;
49672: LD_ADDR_VAR 0 8
49676: PUSH
49677: LD_INT 2100
49679: ST_TO_ADDR
// if amount < min then
49680: LD_VAR 0 9
49684: PUSH
49685: LD_VAR 0 3
49689: LESS
49690: IFFALSE 49708
// r := r * 2 else
49692: LD_ADDR_VAR 0 7
49696: PUSH
49697: LD_VAR 0 7
49701: PUSH
49702: LD_INT 2
49704: MUL
49705: ST_TO_ADDR
49706: GO 49734
// if amount > max then
49708: LD_VAR 0 9
49712: PUSH
49713: LD_VAR 0 4
49717: GREATER
49718: IFFALSE 49734
// r := r / 2 ;
49720: LD_ADDR_VAR 0 7
49724: PUSH
49725: LD_VAR 0 7
49729: PUSH
49730: LD_INT 2
49732: DIVREAL
49733: ST_TO_ADDR
// time := time / r ;
49734: LD_ADDR_VAR 0 8
49738: PUSH
49739: LD_VAR 0 8
49743: PUSH
49744: LD_VAR 0 7
49748: DIVREAL
49749: ST_TO_ADDR
// if time < 0 then
49750: LD_VAR 0 8
49754: PUSH
49755: LD_INT 0
49757: LESS
49758: IFFALSE 49775
// time := time * - 1 ;
49760: LD_ADDR_VAR 0 8
49764: PUSH
49765: LD_VAR 0 8
49769: PUSH
49770: LD_INT 1
49772: NEG
49773: MUL
49774: ST_TO_ADDR
// wait ( time ) ;
49775: LD_VAR 0 8
49779: PPUSH
49780: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
49784: LD_INT 35
49786: PPUSH
49787: LD_INT 875
49789: PPUSH
49790: CALL_OW 12
49794: PPUSH
49795: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
49799: LD_INT 1
49801: PPUSH
49802: LD_INT 5
49804: PPUSH
49805: CALL_OW 12
49809: PPUSH
49810: LD_VAR 0 1
49814: PPUSH
49815: LD_INT 1
49817: PPUSH
49818: CALL_OW 55
// end ;
49822: GO 49632
// end ;
49824: LD_VAR 0 5
49828: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
49829: LD_INT 0
49831: PPUSH
49832: PPUSH
49833: PPUSH
49834: PPUSH
49835: PPUSH
49836: PPUSH
49837: PPUSH
49838: PPUSH
// if not turrets or not factories then
49839: LD_VAR 0 1
49843: NOT
49844: PUSH
49845: LD_VAR 0 2
49849: NOT
49850: OR
49851: IFFALSE 49855
// exit ;
49853: GO 50162
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
49855: LD_ADDR_VAR 0 10
49859: PUSH
49860: LD_INT 5
49862: PUSH
49863: LD_INT 6
49865: PUSH
49866: EMPTY
49867: LIST
49868: LIST
49869: PUSH
49870: LD_INT 2
49872: PUSH
49873: LD_INT 4
49875: PUSH
49876: EMPTY
49877: LIST
49878: LIST
49879: PUSH
49880: LD_INT 3
49882: PUSH
49883: LD_INT 5
49885: PUSH
49886: EMPTY
49887: LIST
49888: LIST
49889: PUSH
49890: EMPTY
49891: LIST
49892: LIST
49893: LIST
49894: PUSH
49895: LD_INT 24
49897: PUSH
49898: LD_INT 25
49900: PUSH
49901: EMPTY
49902: LIST
49903: LIST
49904: PUSH
49905: LD_INT 23
49907: PUSH
49908: LD_INT 27
49910: PUSH
49911: EMPTY
49912: LIST
49913: LIST
49914: PUSH
49915: EMPTY
49916: LIST
49917: LIST
49918: PUSH
49919: LD_INT 42
49921: PUSH
49922: LD_INT 43
49924: PUSH
49925: EMPTY
49926: LIST
49927: LIST
49928: PUSH
49929: LD_INT 44
49931: PUSH
49932: LD_INT 46
49934: PUSH
49935: EMPTY
49936: LIST
49937: LIST
49938: PUSH
49939: LD_INT 45
49941: PUSH
49942: LD_INT 47
49944: PUSH
49945: EMPTY
49946: LIST
49947: LIST
49948: PUSH
49949: EMPTY
49950: LIST
49951: LIST
49952: LIST
49953: PUSH
49954: EMPTY
49955: LIST
49956: LIST
49957: LIST
49958: ST_TO_ADDR
// result := [ ] ;
49959: LD_ADDR_VAR 0 3
49963: PUSH
49964: EMPTY
49965: ST_TO_ADDR
// for i in turrets do
49966: LD_ADDR_VAR 0 4
49970: PUSH
49971: LD_VAR 0 1
49975: PUSH
49976: FOR_IN
49977: IFFALSE 50160
// begin nat := GetNation ( i ) ;
49979: LD_ADDR_VAR 0 7
49983: PUSH
49984: LD_VAR 0 4
49988: PPUSH
49989: CALL_OW 248
49993: ST_TO_ADDR
// weapon := 0 ;
49994: LD_ADDR_VAR 0 8
49998: PUSH
49999: LD_INT 0
50001: ST_TO_ADDR
// if not nat then
50002: LD_VAR 0 7
50006: NOT
50007: IFFALSE 50011
// continue ;
50009: GO 49976
// for j in list [ nat ] do
50011: LD_ADDR_VAR 0 5
50015: PUSH
50016: LD_VAR 0 10
50020: PUSH
50021: LD_VAR 0 7
50025: ARRAY
50026: PUSH
50027: FOR_IN
50028: IFFALSE 50069
// if GetBWeapon ( i ) = j [ 1 ] then
50030: LD_VAR 0 4
50034: PPUSH
50035: CALL_OW 269
50039: PUSH
50040: LD_VAR 0 5
50044: PUSH
50045: LD_INT 1
50047: ARRAY
50048: EQUAL
50049: IFFALSE 50067
// begin weapon := j [ 2 ] ;
50051: LD_ADDR_VAR 0 8
50055: PUSH
50056: LD_VAR 0 5
50060: PUSH
50061: LD_INT 2
50063: ARRAY
50064: ST_TO_ADDR
// break ;
50065: GO 50069
// end ;
50067: GO 50027
50069: POP
50070: POP
// if not weapon then
50071: LD_VAR 0 8
50075: NOT
50076: IFFALSE 50080
// continue ;
50078: GO 49976
// for k in factories do
50080: LD_ADDR_VAR 0 6
50084: PUSH
50085: LD_VAR 0 2
50089: PUSH
50090: FOR_IN
50091: IFFALSE 50156
// begin weapons := AvailableWeaponList ( k ) ;
50093: LD_ADDR_VAR 0 9
50097: PUSH
50098: LD_VAR 0 6
50102: PPUSH
50103: CALL_OW 478
50107: ST_TO_ADDR
// if not weapons then
50108: LD_VAR 0 9
50112: NOT
50113: IFFALSE 50117
// continue ;
50115: GO 50090
// if weapon in weapons then
50117: LD_VAR 0 8
50121: PUSH
50122: LD_VAR 0 9
50126: IN
50127: IFFALSE 50154
// begin result := [ i , weapon ] ;
50129: LD_ADDR_VAR 0 3
50133: PUSH
50134: LD_VAR 0 4
50138: PUSH
50139: LD_VAR 0 8
50143: PUSH
50144: EMPTY
50145: LIST
50146: LIST
50147: ST_TO_ADDR
// exit ;
50148: POP
50149: POP
50150: POP
50151: POP
50152: GO 50162
// end ; end ;
50154: GO 50090
50156: POP
50157: POP
// end ;
50158: GO 49976
50160: POP
50161: POP
// end ;
50162: LD_VAR 0 3
50166: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50167: LD_INT 0
50169: PPUSH
// if not side or side > 8 then
50170: LD_VAR 0 3
50174: NOT
50175: PUSH
50176: LD_VAR 0 3
50180: PUSH
50181: LD_INT 8
50183: GREATER
50184: OR
50185: IFFALSE 50189
// exit ;
50187: GO 50248
// if not range then
50189: LD_VAR 0 4
50193: NOT
50194: IFFALSE 50205
// range := - 12 ;
50196: LD_ADDR_VAR 0 4
50200: PUSH
50201: LD_INT 12
50203: NEG
50204: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50205: LD_VAR 0 1
50209: PPUSH
50210: LD_VAR 0 2
50214: PPUSH
50215: LD_VAR 0 3
50219: PPUSH
50220: LD_VAR 0 4
50224: PPUSH
50225: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50229: LD_VAR 0 1
50233: PPUSH
50234: LD_VAR 0 2
50238: PPUSH
50239: LD_VAR 0 3
50243: PPUSH
50244: CALL_OW 331
// end ;
50248: LD_VAR 0 5
50252: RET
// export function Video ( mode ) ; begin
50253: LD_INT 0
50255: PPUSH
// ingame_video = mode ;
50256: LD_ADDR_OWVAR 52
50260: PUSH
50261: LD_VAR 0 1
50265: ST_TO_ADDR
// interface_hidden = mode ;
50266: LD_ADDR_OWVAR 54
50270: PUSH
50271: LD_VAR 0 1
50275: ST_TO_ADDR
// end ;
50276: LD_VAR 0 2
50280: RET
// export function Join ( array , element ) ; begin
50281: LD_INT 0
50283: PPUSH
// result := Replace ( array , array + 1 , element ) ;
50284: LD_ADDR_VAR 0 3
50288: PUSH
50289: LD_VAR 0 1
50293: PPUSH
50294: LD_VAR 0 1
50298: PUSH
50299: LD_INT 1
50301: PLUS
50302: PPUSH
50303: LD_VAR 0 2
50307: PPUSH
50308: CALL_OW 1
50312: ST_TO_ADDR
// end ;
50313: LD_VAR 0 3
50317: RET
// export function JoinUnion ( array , element ) ; begin
50318: LD_INT 0
50320: PPUSH
// result := array union element ;
50321: LD_ADDR_VAR 0 3
50325: PUSH
50326: LD_VAR 0 1
50330: PUSH
50331: LD_VAR 0 2
50335: UNION
50336: ST_TO_ADDR
// end ;
50337: LD_VAR 0 3
50341: RET
// export function GetBehemoths ( side ) ; begin
50342: LD_INT 0
50344: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
50345: LD_ADDR_VAR 0 2
50349: PUSH
50350: LD_INT 22
50352: PUSH
50353: LD_VAR 0 1
50357: PUSH
50358: EMPTY
50359: LIST
50360: LIST
50361: PUSH
50362: LD_INT 31
50364: PUSH
50365: LD_INT 25
50367: PUSH
50368: EMPTY
50369: LIST
50370: LIST
50371: PUSH
50372: EMPTY
50373: LIST
50374: LIST
50375: PPUSH
50376: CALL_OW 69
50380: ST_TO_ADDR
// end ;
50381: LD_VAR 0 2
50385: RET
// export function Shuffle ( array ) ; var i , index ; begin
50386: LD_INT 0
50388: PPUSH
50389: PPUSH
50390: PPUSH
// result := [ ] ;
50391: LD_ADDR_VAR 0 2
50395: PUSH
50396: EMPTY
50397: ST_TO_ADDR
// if not array then
50398: LD_VAR 0 1
50402: NOT
50403: IFFALSE 50407
// exit ;
50405: GO 50506
// Randomize ;
50407: CALL_OW 10
// for i = array downto 1 do
50411: LD_ADDR_VAR 0 3
50415: PUSH
50416: DOUBLE
50417: LD_VAR 0 1
50421: INC
50422: ST_TO_ADDR
50423: LD_INT 1
50425: PUSH
50426: FOR_DOWNTO
50427: IFFALSE 50504
// begin index := rand ( 1 , array ) ;
50429: LD_ADDR_VAR 0 4
50433: PUSH
50434: LD_INT 1
50436: PPUSH
50437: LD_VAR 0 1
50441: PPUSH
50442: CALL_OW 12
50446: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
50447: LD_ADDR_VAR 0 2
50451: PUSH
50452: LD_VAR 0 2
50456: PPUSH
50457: LD_VAR 0 2
50461: PUSH
50462: LD_INT 1
50464: PLUS
50465: PPUSH
50466: LD_VAR 0 1
50470: PUSH
50471: LD_VAR 0 4
50475: ARRAY
50476: PPUSH
50477: CALL_OW 2
50481: ST_TO_ADDR
// array := Delete ( array , index ) ;
50482: LD_ADDR_VAR 0 1
50486: PUSH
50487: LD_VAR 0 1
50491: PPUSH
50492: LD_VAR 0 4
50496: PPUSH
50497: CALL_OW 3
50501: ST_TO_ADDR
// end ;
50502: GO 50426
50504: POP
50505: POP
// end ;
50506: LD_VAR 0 2
50510: RET
// export function GetBaseMaterials ( base ) ; begin
50511: LD_INT 0
50513: PPUSH
// result := [ 0 , 0 , 0 ] ;
50514: LD_ADDR_VAR 0 2
50518: PUSH
50519: LD_INT 0
50521: PUSH
50522: LD_INT 0
50524: PUSH
50525: LD_INT 0
50527: PUSH
50528: EMPTY
50529: LIST
50530: LIST
50531: LIST
50532: ST_TO_ADDR
// if not base then
50533: LD_VAR 0 1
50537: NOT
50538: IFFALSE 50542
// exit ;
50540: GO 50591
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
50542: LD_ADDR_VAR 0 2
50546: PUSH
50547: LD_VAR 0 1
50551: PPUSH
50552: LD_INT 1
50554: PPUSH
50555: CALL_OW 275
50559: PUSH
50560: LD_VAR 0 1
50564: PPUSH
50565: LD_INT 2
50567: PPUSH
50568: CALL_OW 275
50572: PUSH
50573: LD_VAR 0 1
50577: PPUSH
50578: LD_INT 3
50580: PPUSH
50581: CALL_OW 275
50585: PUSH
50586: EMPTY
50587: LIST
50588: LIST
50589: LIST
50590: ST_TO_ADDR
// end ;
50591: LD_VAR 0 2
50595: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
50596: LD_INT 0
50598: PPUSH
50599: PPUSH
// result := array ;
50600: LD_ADDR_VAR 0 3
50604: PUSH
50605: LD_VAR 0 1
50609: ST_TO_ADDR
// if size > 0 then
50610: LD_VAR 0 2
50614: PUSH
50615: LD_INT 0
50617: GREATER
50618: IFFALSE 50664
// for i := array downto size do
50620: LD_ADDR_VAR 0 4
50624: PUSH
50625: DOUBLE
50626: LD_VAR 0 1
50630: INC
50631: ST_TO_ADDR
50632: LD_VAR 0 2
50636: PUSH
50637: FOR_DOWNTO
50638: IFFALSE 50662
// result := Delete ( result , result ) ;
50640: LD_ADDR_VAR 0 3
50644: PUSH
50645: LD_VAR 0 3
50649: PPUSH
50650: LD_VAR 0 3
50654: PPUSH
50655: CALL_OW 3
50659: ST_TO_ADDR
50660: GO 50637
50662: POP
50663: POP
// end ;
50664: LD_VAR 0 3
50668: RET
// export function ComExit ( unit ) ; var tmp ; begin
50669: LD_INT 0
50671: PPUSH
50672: PPUSH
// if not IsInUnit ( unit ) then
50673: LD_VAR 0 1
50677: PPUSH
50678: CALL_OW 310
50682: NOT
50683: IFFALSE 50687
// exit ;
50685: GO 50747
// tmp := IsInUnit ( unit ) ;
50687: LD_ADDR_VAR 0 3
50691: PUSH
50692: LD_VAR 0 1
50696: PPUSH
50697: CALL_OW 310
50701: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
50702: LD_VAR 0 3
50706: PPUSH
50707: CALL_OW 247
50711: PUSH
50712: LD_INT 2
50714: EQUAL
50715: IFFALSE 50728
// ComExitVehicle ( unit ) else
50717: LD_VAR 0 1
50721: PPUSH
50722: CALL_OW 121
50726: GO 50737
// ComExitBuilding ( unit ) ;
50728: LD_VAR 0 1
50732: PPUSH
50733: CALL_OW 122
// result := tmp ;
50737: LD_ADDR_VAR 0 2
50741: PUSH
50742: LD_VAR 0 3
50746: ST_TO_ADDR
// end ;
50747: LD_VAR 0 2
50751: RET
// export function ResetHc ; begin
50752: LD_INT 0
50754: PPUSH
// InitHc ;
50755: CALL_OW 19
// hc_importance := 0 ;
50759: LD_ADDR_OWVAR 32
50763: PUSH
50764: LD_INT 0
50766: ST_TO_ADDR
// end ;
50767: LD_VAR 0 1
50771: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
50772: LD_INT 0
50774: PPUSH
50775: PPUSH
50776: PPUSH
// _x := ( x1 + x2 ) div 2 ;
50777: LD_ADDR_VAR 0 6
50781: PUSH
50782: LD_VAR 0 1
50786: PUSH
50787: LD_VAR 0 3
50791: PLUS
50792: PUSH
50793: LD_INT 2
50795: DIV
50796: ST_TO_ADDR
// if _x < 0 then
50797: LD_VAR 0 6
50801: PUSH
50802: LD_INT 0
50804: LESS
50805: IFFALSE 50822
// _x := _x * - 1 ;
50807: LD_ADDR_VAR 0 6
50811: PUSH
50812: LD_VAR 0 6
50816: PUSH
50817: LD_INT 1
50819: NEG
50820: MUL
50821: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
50822: LD_ADDR_VAR 0 7
50826: PUSH
50827: LD_VAR 0 2
50831: PUSH
50832: LD_VAR 0 4
50836: PLUS
50837: PUSH
50838: LD_INT 2
50840: DIV
50841: ST_TO_ADDR
// if _y < 0 then
50842: LD_VAR 0 7
50846: PUSH
50847: LD_INT 0
50849: LESS
50850: IFFALSE 50867
// _y := _y * - 1 ;
50852: LD_ADDR_VAR 0 7
50856: PUSH
50857: LD_VAR 0 7
50861: PUSH
50862: LD_INT 1
50864: NEG
50865: MUL
50866: ST_TO_ADDR
// result := [ _x , _y ] ;
50867: LD_ADDR_VAR 0 5
50871: PUSH
50872: LD_VAR 0 6
50876: PUSH
50877: LD_VAR 0 7
50881: PUSH
50882: EMPTY
50883: LIST
50884: LIST
50885: ST_TO_ADDR
// end ;
50886: LD_VAR 0 5
50890: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
50891: LD_INT 0
50893: PPUSH
50894: PPUSH
50895: PPUSH
50896: PPUSH
// task := GetTaskList ( unit ) ;
50897: LD_ADDR_VAR 0 7
50901: PUSH
50902: LD_VAR 0 1
50906: PPUSH
50907: CALL_OW 437
50911: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
50912: LD_VAR 0 7
50916: NOT
50917: PUSH
50918: LD_VAR 0 1
50922: PPUSH
50923: LD_VAR 0 2
50927: PPUSH
50928: CALL_OW 308
50932: NOT
50933: AND
50934: IFFALSE 50938
// exit ;
50936: GO 51056
// if IsInArea ( unit , area ) then
50938: LD_VAR 0 1
50942: PPUSH
50943: LD_VAR 0 2
50947: PPUSH
50948: CALL_OW 308
50952: IFFALSE 50970
// begin ComMoveToArea ( unit , goAway ) ;
50954: LD_VAR 0 1
50958: PPUSH
50959: LD_VAR 0 3
50963: PPUSH
50964: CALL_OW 113
// exit ;
50968: GO 51056
// end ; if task [ 1 ] [ 1 ] <> M then
50970: LD_VAR 0 7
50974: PUSH
50975: LD_INT 1
50977: ARRAY
50978: PUSH
50979: LD_INT 1
50981: ARRAY
50982: PUSH
50983: LD_STRING M
50985: NONEQUAL
50986: IFFALSE 50990
// exit ;
50988: GO 51056
// x := task [ 1 ] [ 2 ] ;
50990: LD_ADDR_VAR 0 5
50994: PUSH
50995: LD_VAR 0 7
50999: PUSH
51000: LD_INT 1
51002: ARRAY
51003: PUSH
51004: LD_INT 2
51006: ARRAY
51007: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
51008: LD_ADDR_VAR 0 6
51012: PUSH
51013: LD_VAR 0 7
51017: PUSH
51018: LD_INT 1
51020: ARRAY
51021: PUSH
51022: LD_INT 3
51024: ARRAY
51025: ST_TO_ADDR
// if InArea ( x , y , area ) then
51026: LD_VAR 0 5
51030: PPUSH
51031: LD_VAR 0 6
51035: PPUSH
51036: LD_VAR 0 2
51040: PPUSH
51041: CALL_OW 309
51045: IFFALSE 51056
// ComStop ( unit ) ;
51047: LD_VAR 0 1
51051: PPUSH
51052: CALL_OW 141
// end ;
51056: LD_VAR 0 4
51060: RET
// export function Abs ( value ) ; begin
51061: LD_INT 0
51063: PPUSH
// result := value ;
51064: LD_ADDR_VAR 0 2
51068: PUSH
51069: LD_VAR 0 1
51073: ST_TO_ADDR
// if value < 0 then
51074: LD_VAR 0 1
51078: PUSH
51079: LD_INT 0
51081: LESS
51082: IFFALSE 51099
// result := value * - 1 ;
51084: LD_ADDR_VAR 0 2
51088: PUSH
51089: LD_VAR 0 1
51093: PUSH
51094: LD_INT 1
51096: NEG
51097: MUL
51098: ST_TO_ADDR
// end ; end_of_file
51099: LD_VAR 0 2
51103: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
51104: LD_INT 0
51106: PPUSH
51107: PPUSH
// skirmish := false ;
51108: LD_ADDR_EXP 57
51112: PUSH
51113: LD_INT 0
51115: ST_TO_ADDR
// debug_mc := false ;
51116: LD_ADDR_EXP 58
51120: PUSH
51121: LD_INT 0
51123: ST_TO_ADDR
// mc_bases := [ ] ;
51124: LD_ADDR_EXP 59
51128: PUSH
51129: EMPTY
51130: ST_TO_ADDR
// mc_sides := [ ] ;
51131: LD_ADDR_EXP 85
51135: PUSH
51136: EMPTY
51137: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
51138: LD_ADDR_EXP 60
51142: PUSH
51143: EMPTY
51144: ST_TO_ADDR
// mc_building_repairs := [ ] ;
51145: LD_ADDR_EXP 61
51149: PUSH
51150: EMPTY
51151: ST_TO_ADDR
// mc_need_heal := [ ] ;
51152: LD_ADDR_EXP 62
51156: PUSH
51157: EMPTY
51158: ST_TO_ADDR
// mc_healers := [ ] ;
51159: LD_ADDR_EXP 63
51163: PUSH
51164: EMPTY
51165: ST_TO_ADDR
// mc_build_list := [ ] ;
51166: LD_ADDR_EXP 64
51170: PUSH
51171: EMPTY
51172: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
51173: LD_ADDR_EXP 91
51177: PUSH
51178: EMPTY
51179: ST_TO_ADDR
// mc_builders := [ ] ;
51180: LD_ADDR_EXP 65
51184: PUSH
51185: EMPTY
51186: ST_TO_ADDR
// mc_construct_list := [ ] ;
51187: LD_ADDR_EXP 66
51191: PUSH
51192: EMPTY
51193: ST_TO_ADDR
// mc_turret_list := [ ] ;
51194: LD_ADDR_EXP 67
51198: PUSH
51199: EMPTY
51200: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
51201: LD_ADDR_EXP 68
51205: PUSH
51206: EMPTY
51207: ST_TO_ADDR
// mc_miners := [ ] ;
51208: LD_ADDR_EXP 73
51212: PUSH
51213: EMPTY
51214: ST_TO_ADDR
// mc_mines := [ ] ;
51215: LD_ADDR_EXP 72
51219: PUSH
51220: EMPTY
51221: ST_TO_ADDR
// mc_minefields := [ ] ;
51222: LD_ADDR_EXP 74
51226: PUSH
51227: EMPTY
51228: ST_TO_ADDR
// mc_crates := [ ] ;
51229: LD_ADDR_EXP 75
51233: PUSH
51234: EMPTY
51235: ST_TO_ADDR
// mc_crates_collector := [ ] ;
51236: LD_ADDR_EXP 76
51240: PUSH
51241: EMPTY
51242: ST_TO_ADDR
// mc_crates_area := [ ] ;
51243: LD_ADDR_EXP 77
51247: PUSH
51248: EMPTY
51249: ST_TO_ADDR
// mc_vehicles := [ ] ;
51250: LD_ADDR_EXP 78
51254: PUSH
51255: EMPTY
51256: ST_TO_ADDR
// mc_attack := [ ] ;
51257: LD_ADDR_EXP 79
51261: PUSH
51262: EMPTY
51263: ST_TO_ADDR
// mc_produce := [ ] ;
51264: LD_ADDR_EXP 80
51268: PUSH
51269: EMPTY
51270: ST_TO_ADDR
// mc_defender := [ ] ;
51271: LD_ADDR_EXP 81
51275: PUSH
51276: EMPTY
51277: ST_TO_ADDR
// mc_parking := [ ] ;
51278: LD_ADDR_EXP 83
51282: PUSH
51283: EMPTY
51284: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
51285: LD_ADDR_EXP 69
51289: PUSH
51290: EMPTY
51291: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51292: LD_ADDR_EXP 71
51296: PUSH
51297: EMPTY
51298: ST_TO_ADDR
// mc_scan := [ ] ;
51299: LD_ADDR_EXP 82
51303: PUSH
51304: EMPTY
51305: ST_TO_ADDR
// mc_scan_area := [ ] ;
51306: LD_ADDR_EXP 84
51310: PUSH
51311: EMPTY
51312: ST_TO_ADDR
// mc_tech := [ ] ;
51313: LD_ADDR_EXP 86
51317: PUSH
51318: EMPTY
51319: ST_TO_ADDR
// mc_class := [ ] ;
51320: LD_ADDR_EXP 100
51324: PUSH
51325: EMPTY
51326: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51327: LD_ADDR_EXP 101
51331: PUSH
51332: EMPTY
51333: ST_TO_ADDR
// end ;
51334: LD_VAR 0 1
51338: RET
// export function MC_Kill ( base ) ; begin
51339: LD_INT 0
51341: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51342: LD_ADDR_EXP 59
51346: PUSH
51347: LD_EXP 59
51351: PPUSH
51352: LD_VAR 0 1
51356: PPUSH
51357: EMPTY
51358: PPUSH
51359: CALL_OW 1
51363: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51364: LD_ADDR_EXP 60
51368: PUSH
51369: LD_EXP 60
51373: PPUSH
51374: LD_VAR 0 1
51378: PPUSH
51379: EMPTY
51380: PPUSH
51381: CALL_OW 1
51385: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51386: LD_ADDR_EXP 61
51390: PUSH
51391: LD_EXP 61
51395: PPUSH
51396: LD_VAR 0 1
51400: PPUSH
51401: EMPTY
51402: PPUSH
51403: CALL_OW 1
51407: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51408: LD_ADDR_EXP 62
51412: PUSH
51413: LD_EXP 62
51417: PPUSH
51418: LD_VAR 0 1
51422: PPUSH
51423: EMPTY
51424: PPUSH
51425: CALL_OW 1
51429: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51430: LD_ADDR_EXP 63
51434: PUSH
51435: LD_EXP 63
51439: PPUSH
51440: LD_VAR 0 1
51444: PPUSH
51445: EMPTY
51446: PPUSH
51447: CALL_OW 1
51451: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51452: LD_ADDR_EXP 64
51456: PUSH
51457: LD_EXP 64
51461: PPUSH
51462: LD_VAR 0 1
51466: PPUSH
51467: EMPTY
51468: PPUSH
51469: CALL_OW 1
51473: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51474: LD_ADDR_EXP 65
51478: PUSH
51479: LD_EXP 65
51483: PPUSH
51484: LD_VAR 0 1
51488: PPUSH
51489: EMPTY
51490: PPUSH
51491: CALL_OW 1
51495: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51496: LD_ADDR_EXP 66
51500: PUSH
51501: LD_EXP 66
51505: PPUSH
51506: LD_VAR 0 1
51510: PPUSH
51511: EMPTY
51512: PPUSH
51513: CALL_OW 1
51517: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51518: LD_ADDR_EXP 67
51522: PUSH
51523: LD_EXP 67
51527: PPUSH
51528: LD_VAR 0 1
51532: PPUSH
51533: EMPTY
51534: PPUSH
51535: CALL_OW 1
51539: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51540: LD_ADDR_EXP 68
51544: PUSH
51545: LD_EXP 68
51549: PPUSH
51550: LD_VAR 0 1
51554: PPUSH
51555: EMPTY
51556: PPUSH
51557: CALL_OW 1
51561: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51562: LD_ADDR_EXP 69
51566: PUSH
51567: LD_EXP 69
51571: PPUSH
51572: LD_VAR 0 1
51576: PPUSH
51577: EMPTY
51578: PPUSH
51579: CALL_OW 1
51583: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51584: LD_ADDR_EXP 70
51588: PUSH
51589: LD_EXP 70
51593: PPUSH
51594: LD_VAR 0 1
51598: PPUSH
51599: LD_INT 0
51601: PPUSH
51602: CALL_OW 1
51606: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51607: LD_ADDR_EXP 71
51611: PUSH
51612: LD_EXP 71
51616: PPUSH
51617: LD_VAR 0 1
51621: PPUSH
51622: EMPTY
51623: PPUSH
51624: CALL_OW 1
51628: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51629: LD_ADDR_EXP 72
51633: PUSH
51634: LD_EXP 72
51638: PPUSH
51639: LD_VAR 0 1
51643: PPUSH
51644: EMPTY
51645: PPUSH
51646: CALL_OW 1
51650: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51651: LD_ADDR_EXP 73
51655: PUSH
51656: LD_EXP 73
51660: PPUSH
51661: LD_VAR 0 1
51665: PPUSH
51666: EMPTY
51667: PPUSH
51668: CALL_OW 1
51672: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51673: LD_ADDR_EXP 74
51677: PUSH
51678: LD_EXP 74
51682: PPUSH
51683: LD_VAR 0 1
51687: PPUSH
51688: EMPTY
51689: PPUSH
51690: CALL_OW 1
51694: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51695: LD_ADDR_EXP 75
51699: PUSH
51700: LD_EXP 75
51704: PPUSH
51705: LD_VAR 0 1
51709: PPUSH
51710: EMPTY
51711: PPUSH
51712: CALL_OW 1
51716: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51717: LD_ADDR_EXP 76
51721: PUSH
51722: LD_EXP 76
51726: PPUSH
51727: LD_VAR 0 1
51731: PPUSH
51732: EMPTY
51733: PPUSH
51734: CALL_OW 1
51738: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51739: LD_ADDR_EXP 77
51743: PUSH
51744: LD_EXP 77
51748: PPUSH
51749: LD_VAR 0 1
51753: PPUSH
51754: EMPTY
51755: PPUSH
51756: CALL_OW 1
51760: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51761: LD_ADDR_EXP 78
51765: PUSH
51766: LD_EXP 78
51770: PPUSH
51771: LD_VAR 0 1
51775: PPUSH
51776: EMPTY
51777: PPUSH
51778: CALL_OW 1
51782: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51783: LD_ADDR_EXP 79
51787: PUSH
51788: LD_EXP 79
51792: PPUSH
51793: LD_VAR 0 1
51797: PPUSH
51798: EMPTY
51799: PPUSH
51800: CALL_OW 1
51804: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51805: LD_ADDR_EXP 80
51809: PUSH
51810: LD_EXP 80
51814: PPUSH
51815: LD_VAR 0 1
51819: PPUSH
51820: EMPTY
51821: PPUSH
51822: CALL_OW 1
51826: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51827: LD_ADDR_EXP 81
51831: PUSH
51832: LD_EXP 81
51836: PPUSH
51837: LD_VAR 0 1
51841: PPUSH
51842: EMPTY
51843: PPUSH
51844: CALL_OW 1
51848: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51849: LD_ADDR_EXP 82
51853: PUSH
51854: LD_EXP 82
51858: PPUSH
51859: LD_VAR 0 1
51863: PPUSH
51864: EMPTY
51865: PPUSH
51866: CALL_OW 1
51870: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51871: LD_ADDR_EXP 83
51875: PUSH
51876: LD_EXP 83
51880: PPUSH
51881: LD_VAR 0 1
51885: PPUSH
51886: EMPTY
51887: PPUSH
51888: CALL_OW 1
51892: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51893: LD_ADDR_EXP 84
51897: PUSH
51898: LD_EXP 84
51902: PPUSH
51903: LD_VAR 0 1
51907: PPUSH
51908: EMPTY
51909: PPUSH
51910: CALL_OW 1
51914: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51915: LD_ADDR_EXP 86
51919: PUSH
51920: LD_EXP 86
51924: PPUSH
51925: LD_VAR 0 1
51929: PPUSH
51930: EMPTY
51931: PPUSH
51932: CALL_OW 1
51936: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51937: LD_ADDR_EXP 88
51941: PUSH
51942: LD_EXP 88
51946: PPUSH
51947: LD_VAR 0 1
51951: PPUSH
51952: EMPTY
51953: PPUSH
51954: CALL_OW 1
51958: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51959: LD_ADDR_EXP 89
51963: PUSH
51964: LD_EXP 89
51968: PPUSH
51969: LD_VAR 0 1
51973: PPUSH
51974: EMPTY
51975: PPUSH
51976: CALL_OW 1
51980: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51981: LD_ADDR_EXP 90
51985: PUSH
51986: LD_EXP 90
51990: PPUSH
51991: LD_VAR 0 1
51995: PPUSH
51996: EMPTY
51997: PPUSH
51998: CALL_OW 1
52002: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52003: LD_ADDR_EXP 91
52007: PUSH
52008: LD_EXP 91
52012: PPUSH
52013: LD_VAR 0 1
52017: PPUSH
52018: EMPTY
52019: PPUSH
52020: CALL_OW 1
52024: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52025: LD_ADDR_EXP 92
52029: PUSH
52030: LD_EXP 92
52034: PPUSH
52035: LD_VAR 0 1
52039: PPUSH
52040: EMPTY
52041: PPUSH
52042: CALL_OW 1
52046: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52047: LD_ADDR_EXP 93
52051: PUSH
52052: LD_EXP 93
52056: PPUSH
52057: LD_VAR 0 1
52061: PPUSH
52062: EMPTY
52063: PPUSH
52064: CALL_OW 1
52068: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52069: LD_ADDR_EXP 94
52073: PUSH
52074: LD_EXP 94
52078: PPUSH
52079: LD_VAR 0 1
52083: PPUSH
52084: EMPTY
52085: PPUSH
52086: CALL_OW 1
52090: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52091: LD_ADDR_EXP 95
52095: PUSH
52096: LD_EXP 95
52100: PPUSH
52101: LD_VAR 0 1
52105: PPUSH
52106: EMPTY
52107: PPUSH
52108: CALL_OW 1
52112: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52113: LD_ADDR_EXP 96
52117: PUSH
52118: LD_EXP 96
52122: PPUSH
52123: LD_VAR 0 1
52127: PPUSH
52128: EMPTY
52129: PPUSH
52130: CALL_OW 1
52134: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52135: LD_ADDR_EXP 97
52139: PUSH
52140: LD_EXP 97
52144: PPUSH
52145: LD_VAR 0 1
52149: PPUSH
52150: EMPTY
52151: PPUSH
52152: CALL_OW 1
52156: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52157: LD_ADDR_EXP 98
52161: PUSH
52162: LD_EXP 98
52166: PPUSH
52167: LD_VAR 0 1
52171: PPUSH
52172: EMPTY
52173: PPUSH
52174: CALL_OW 1
52178: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52179: LD_ADDR_EXP 99
52183: PUSH
52184: LD_EXP 99
52188: PPUSH
52189: LD_VAR 0 1
52193: PPUSH
52194: EMPTY
52195: PPUSH
52196: CALL_OW 1
52200: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52201: LD_ADDR_EXP 100
52205: PUSH
52206: LD_EXP 100
52210: PPUSH
52211: LD_VAR 0 1
52215: PPUSH
52216: EMPTY
52217: PPUSH
52218: CALL_OW 1
52222: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52223: LD_ADDR_EXP 101
52227: PUSH
52228: LD_EXP 101
52232: PPUSH
52233: LD_VAR 0 1
52237: PPUSH
52238: LD_INT 0
52240: PPUSH
52241: CALL_OW 1
52245: ST_TO_ADDR
// end ;
52246: LD_VAR 0 2
52250: RET
// export function MC_Add ( side , units ) ; var base ; begin
52251: LD_INT 0
52253: PPUSH
52254: PPUSH
// base := mc_bases + 1 ;
52255: LD_ADDR_VAR 0 4
52259: PUSH
52260: LD_EXP 59
52264: PUSH
52265: LD_INT 1
52267: PLUS
52268: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
52269: LD_ADDR_EXP 85
52273: PUSH
52274: LD_EXP 85
52278: PPUSH
52279: LD_VAR 0 4
52283: PPUSH
52284: LD_VAR 0 1
52288: PPUSH
52289: CALL_OW 1
52293: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52294: LD_ADDR_EXP 59
52298: PUSH
52299: LD_EXP 59
52303: PPUSH
52304: LD_VAR 0 4
52308: PPUSH
52309: LD_VAR 0 2
52313: PPUSH
52314: CALL_OW 1
52318: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52319: LD_ADDR_EXP 60
52323: PUSH
52324: LD_EXP 60
52328: PPUSH
52329: LD_VAR 0 4
52333: PPUSH
52334: EMPTY
52335: PPUSH
52336: CALL_OW 1
52340: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52341: LD_ADDR_EXP 61
52345: PUSH
52346: LD_EXP 61
52350: PPUSH
52351: LD_VAR 0 4
52355: PPUSH
52356: EMPTY
52357: PPUSH
52358: CALL_OW 1
52362: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52363: LD_ADDR_EXP 62
52367: PUSH
52368: LD_EXP 62
52372: PPUSH
52373: LD_VAR 0 4
52377: PPUSH
52378: EMPTY
52379: PPUSH
52380: CALL_OW 1
52384: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52385: LD_ADDR_EXP 63
52389: PUSH
52390: LD_EXP 63
52394: PPUSH
52395: LD_VAR 0 4
52399: PPUSH
52400: EMPTY
52401: PPUSH
52402: CALL_OW 1
52406: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52407: LD_ADDR_EXP 64
52411: PUSH
52412: LD_EXP 64
52416: PPUSH
52417: LD_VAR 0 4
52421: PPUSH
52422: EMPTY
52423: PPUSH
52424: CALL_OW 1
52428: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52429: LD_ADDR_EXP 65
52433: PUSH
52434: LD_EXP 65
52438: PPUSH
52439: LD_VAR 0 4
52443: PPUSH
52444: EMPTY
52445: PPUSH
52446: CALL_OW 1
52450: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52451: LD_ADDR_EXP 66
52455: PUSH
52456: LD_EXP 66
52460: PPUSH
52461: LD_VAR 0 4
52465: PPUSH
52466: EMPTY
52467: PPUSH
52468: CALL_OW 1
52472: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52473: LD_ADDR_EXP 67
52477: PUSH
52478: LD_EXP 67
52482: PPUSH
52483: LD_VAR 0 4
52487: PPUSH
52488: EMPTY
52489: PPUSH
52490: CALL_OW 1
52494: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52495: LD_ADDR_EXP 68
52499: PUSH
52500: LD_EXP 68
52504: PPUSH
52505: LD_VAR 0 4
52509: PPUSH
52510: EMPTY
52511: PPUSH
52512: CALL_OW 1
52516: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52517: LD_ADDR_EXP 69
52521: PUSH
52522: LD_EXP 69
52526: PPUSH
52527: LD_VAR 0 4
52531: PPUSH
52532: EMPTY
52533: PPUSH
52534: CALL_OW 1
52538: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52539: LD_ADDR_EXP 70
52543: PUSH
52544: LD_EXP 70
52548: PPUSH
52549: LD_VAR 0 4
52553: PPUSH
52554: LD_INT 0
52556: PPUSH
52557: CALL_OW 1
52561: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52562: LD_ADDR_EXP 71
52566: PUSH
52567: LD_EXP 71
52571: PPUSH
52572: LD_VAR 0 4
52576: PPUSH
52577: EMPTY
52578: PPUSH
52579: CALL_OW 1
52583: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52584: LD_ADDR_EXP 72
52588: PUSH
52589: LD_EXP 72
52593: PPUSH
52594: LD_VAR 0 4
52598: PPUSH
52599: EMPTY
52600: PPUSH
52601: CALL_OW 1
52605: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52606: LD_ADDR_EXP 73
52610: PUSH
52611: LD_EXP 73
52615: PPUSH
52616: LD_VAR 0 4
52620: PPUSH
52621: EMPTY
52622: PPUSH
52623: CALL_OW 1
52627: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52628: LD_ADDR_EXP 74
52632: PUSH
52633: LD_EXP 74
52637: PPUSH
52638: LD_VAR 0 4
52642: PPUSH
52643: EMPTY
52644: PPUSH
52645: CALL_OW 1
52649: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52650: LD_ADDR_EXP 75
52654: PUSH
52655: LD_EXP 75
52659: PPUSH
52660: LD_VAR 0 4
52664: PPUSH
52665: EMPTY
52666: PPUSH
52667: CALL_OW 1
52671: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52672: LD_ADDR_EXP 76
52676: PUSH
52677: LD_EXP 76
52681: PPUSH
52682: LD_VAR 0 4
52686: PPUSH
52687: EMPTY
52688: PPUSH
52689: CALL_OW 1
52693: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52694: LD_ADDR_EXP 77
52698: PUSH
52699: LD_EXP 77
52703: PPUSH
52704: LD_VAR 0 4
52708: PPUSH
52709: EMPTY
52710: PPUSH
52711: CALL_OW 1
52715: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52716: LD_ADDR_EXP 78
52720: PUSH
52721: LD_EXP 78
52725: PPUSH
52726: LD_VAR 0 4
52730: PPUSH
52731: EMPTY
52732: PPUSH
52733: CALL_OW 1
52737: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52738: LD_ADDR_EXP 79
52742: PUSH
52743: LD_EXP 79
52747: PPUSH
52748: LD_VAR 0 4
52752: PPUSH
52753: EMPTY
52754: PPUSH
52755: CALL_OW 1
52759: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52760: LD_ADDR_EXP 80
52764: PUSH
52765: LD_EXP 80
52769: PPUSH
52770: LD_VAR 0 4
52774: PPUSH
52775: EMPTY
52776: PPUSH
52777: CALL_OW 1
52781: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52782: LD_ADDR_EXP 81
52786: PUSH
52787: LD_EXP 81
52791: PPUSH
52792: LD_VAR 0 4
52796: PPUSH
52797: EMPTY
52798: PPUSH
52799: CALL_OW 1
52803: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52804: LD_ADDR_EXP 82
52808: PUSH
52809: LD_EXP 82
52813: PPUSH
52814: LD_VAR 0 4
52818: PPUSH
52819: EMPTY
52820: PPUSH
52821: CALL_OW 1
52825: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52826: LD_ADDR_EXP 83
52830: PUSH
52831: LD_EXP 83
52835: PPUSH
52836: LD_VAR 0 4
52840: PPUSH
52841: EMPTY
52842: PPUSH
52843: CALL_OW 1
52847: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52848: LD_ADDR_EXP 84
52852: PUSH
52853: LD_EXP 84
52857: PPUSH
52858: LD_VAR 0 4
52862: PPUSH
52863: EMPTY
52864: PPUSH
52865: CALL_OW 1
52869: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52870: LD_ADDR_EXP 86
52874: PUSH
52875: LD_EXP 86
52879: PPUSH
52880: LD_VAR 0 4
52884: PPUSH
52885: EMPTY
52886: PPUSH
52887: CALL_OW 1
52891: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52892: LD_ADDR_EXP 88
52896: PUSH
52897: LD_EXP 88
52901: PPUSH
52902: LD_VAR 0 4
52906: PPUSH
52907: EMPTY
52908: PPUSH
52909: CALL_OW 1
52913: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52914: LD_ADDR_EXP 89
52918: PUSH
52919: LD_EXP 89
52923: PPUSH
52924: LD_VAR 0 4
52928: PPUSH
52929: EMPTY
52930: PPUSH
52931: CALL_OW 1
52935: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52936: LD_ADDR_EXP 90
52940: PUSH
52941: LD_EXP 90
52945: PPUSH
52946: LD_VAR 0 4
52950: PPUSH
52951: EMPTY
52952: PPUSH
52953: CALL_OW 1
52957: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52958: LD_ADDR_EXP 91
52962: PUSH
52963: LD_EXP 91
52967: PPUSH
52968: LD_VAR 0 4
52972: PPUSH
52973: EMPTY
52974: PPUSH
52975: CALL_OW 1
52979: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52980: LD_ADDR_EXP 92
52984: PUSH
52985: LD_EXP 92
52989: PPUSH
52990: LD_VAR 0 4
52994: PPUSH
52995: EMPTY
52996: PPUSH
52997: CALL_OW 1
53001: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53002: LD_ADDR_EXP 93
53006: PUSH
53007: LD_EXP 93
53011: PPUSH
53012: LD_VAR 0 4
53016: PPUSH
53017: EMPTY
53018: PPUSH
53019: CALL_OW 1
53023: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53024: LD_ADDR_EXP 94
53028: PUSH
53029: LD_EXP 94
53033: PPUSH
53034: LD_VAR 0 4
53038: PPUSH
53039: EMPTY
53040: PPUSH
53041: CALL_OW 1
53045: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53046: LD_ADDR_EXP 95
53050: PUSH
53051: LD_EXP 95
53055: PPUSH
53056: LD_VAR 0 4
53060: PPUSH
53061: EMPTY
53062: PPUSH
53063: CALL_OW 1
53067: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53068: LD_ADDR_EXP 96
53072: PUSH
53073: LD_EXP 96
53077: PPUSH
53078: LD_VAR 0 4
53082: PPUSH
53083: EMPTY
53084: PPUSH
53085: CALL_OW 1
53089: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53090: LD_ADDR_EXP 97
53094: PUSH
53095: LD_EXP 97
53099: PPUSH
53100: LD_VAR 0 4
53104: PPUSH
53105: EMPTY
53106: PPUSH
53107: CALL_OW 1
53111: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53112: LD_ADDR_EXP 98
53116: PUSH
53117: LD_EXP 98
53121: PPUSH
53122: LD_VAR 0 4
53126: PPUSH
53127: EMPTY
53128: PPUSH
53129: CALL_OW 1
53133: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53134: LD_ADDR_EXP 99
53138: PUSH
53139: LD_EXP 99
53143: PPUSH
53144: LD_VAR 0 4
53148: PPUSH
53149: EMPTY
53150: PPUSH
53151: CALL_OW 1
53155: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53156: LD_ADDR_EXP 100
53160: PUSH
53161: LD_EXP 100
53165: PPUSH
53166: LD_VAR 0 4
53170: PPUSH
53171: EMPTY
53172: PPUSH
53173: CALL_OW 1
53177: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53178: LD_ADDR_EXP 101
53182: PUSH
53183: LD_EXP 101
53187: PPUSH
53188: LD_VAR 0 4
53192: PPUSH
53193: LD_INT 0
53195: PPUSH
53196: CALL_OW 1
53200: ST_TO_ADDR
// result := base ;
53201: LD_ADDR_VAR 0 3
53205: PUSH
53206: LD_VAR 0 4
53210: ST_TO_ADDR
// end ;
53211: LD_VAR 0 3
53215: RET
// export function MC_Start ( ) ; var i ; begin
53216: LD_INT 0
53218: PPUSH
53219: PPUSH
// for i = 1 to mc_bases do
53220: LD_ADDR_VAR 0 2
53224: PUSH
53225: DOUBLE
53226: LD_INT 1
53228: DEC
53229: ST_TO_ADDR
53230: LD_EXP 59
53234: PUSH
53235: FOR_TO
53236: IFFALSE 54313
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
53238: LD_ADDR_EXP 59
53242: PUSH
53243: LD_EXP 59
53247: PPUSH
53248: LD_VAR 0 2
53252: PPUSH
53253: LD_EXP 59
53257: PUSH
53258: LD_VAR 0 2
53262: ARRAY
53263: PUSH
53264: LD_INT 0
53266: DIFF
53267: PPUSH
53268: CALL_OW 1
53272: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
53273: LD_ADDR_EXP 60
53277: PUSH
53278: LD_EXP 60
53282: PPUSH
53283: LD_VAR 0 2
53287: PPUSH
53288: EMPTY
53289: PPUSH
53290: CALL_OW 1
53294: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53295: LD_ADDR_EXP 61
53299: PUSH
53300: LD_EXP 61
53304: PPUSH
53305: LD_VAR 0 2
53309: PPUSH
53310: EMPTY
53311: PPUSH
53312: CALL_OW 1
53316: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
53317: LD_ADDR_EXP 62
53321: PUSH
53322: LD_EXP 62
53326: PPUSH
53327: LD_VAR 0 2
53331: PPUSH
53332: EMPTY
53333: PPUSH
53334: CALL_OW 1
53338: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
53339: LD_ADDR_EXP 63
53343: PUSH
53344: LD_EXP 63
53348: PPUSH
53349: LD_VAR 0 2
53353: PPUSH
53354: EMPTY
53355: PUSH
53356: EMPTY
53357: PUSH
53358: EMPTY
53359: LIST
53360: LIST
53361: PPUSH
53362: CALL_OW 1
53366: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
53367: LD_ADDR_EXP 64
53371: PUSH
53372: LD_EXP 64
53376: PPUSH
53377: LD_VAR 0 2
53381: PPUSH
53382: EMPTY
53383: PPUSH
53384: CALL_OW 1
53388: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
53389: LD_ADDR_EXP 91
53393: PUSH
53394: LD_EXP 91
53398: PPUSH
53399: LD_VAR 0 2
53403: PPUSH
53404: EMPTY
53405: PPUSH
53406: CALL_OW 1
53410: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
53411: LD_ADDR_EXP 65
53415: PUSH
53416: LD_EXP 65
53420: PPUSH
53421: LD_VAR 0 2
53425: PPUSH
53426: EMPTY
53427: PPUSH
53428: CALL_OW 1
53432: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
53433: LD_ADDR_EXP 66
53437: PUSH
53438: LD_EXP 66
53442: PPUSH
53443: LD_VAR 0 2
53447: PPUSH
53448: EMPTY
53449: PPUSH
53450: CALL_OW 1
53454: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53455: LD_ADDR_EXP 67
53459: PUSH
53460: LD_EXP 67
53464: PPUSH
53465: LD_VAR 0 2
53469: PPUSH
53470: LD_EXP 59
53474: PUSH
53475: LD_VAR 0 2
53479: ARRAY
53480: PPUSH
53481: LD_INT 2
53483: PUSH
53484: LD_INT 30
53486: PUSH
53487: LD_INT 32
53489: PUSH
53490: EMPTY
53491: LIST
53492: LIST
53493: PUSH
53494: LD_INT 30
53496: PUSH
53497: LD_INT 33
53499: PUSH
53500: EMPTY
53501: LIST
53502: LIST
53503: PUSH
53504: EMPTY
53505: LIST
53506: LIST
53507: LIST
53508: PPUSH
53509: CALL_OW 72
53513: PPUSH
53514: CALL_OW 1
53518: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53519: LD_ADDR_EXP 68
53523: PUSH
53524: LD_EXP 68
53528: PPUSH
53529: LD_VAR 0 2
53533: PPUSH
53534: LD_EXP 59
53538: PUSH
53539: LD_VAR 0 2
53543: ARRAY
53544: PPUSH
53545: LD_INT 2
53547: PUSH
53548: LD_INT 30
53550: PUSH
53551: LD_INT 32
53553: PUSH
53554: EMPTY
53555: LIST
53556: LIST
53557: PUSH
53558: LD_INT 30
53560: PUSH
53561: LD_INT 31
53563: PUSH
53564: EMPTY
53565: LIST
53566: LIST
53567: PUSH
53568: EMPTY
53569: LIST
53570: LIST
53571: LIST
53572: PUSH
53573: LD_INT 58
53575: PUSH
53576: EMPTY
53577: LIST
53578: PUSH
53579: EMPTY
53580: LIST
53581: LIST
53582: PPUSH
53583: CALL_OW 72
53587: PPUSH
53588: CALL_OW 1
53592: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53593: LD_ADDR_EXP 69
53597: PUSH
53598: LD_EXP 69
53602: PPUSH
53603: LD_VAR 0 2
53607: PPUSH
53608: EMPTY
53609: PPUSH
53610: CALL_OW 1
53614: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53615: LD_ADDR_EXP 73
53619: PUSH
53620: LD_EXP 73
53624: PPUSH
53625: LD_VAR 0 2
53629: PPUSH
53630: EMPTY
53631: PPUSH
53632: CALL_OW 1
53636: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53637: LD_ADDR_EXP 72
53641: PUSH
53642: LD_EXP 72
53646: PPUSH
53647: LD_VAR 0 2
53651: PPUSH
53652: EMPTY
53653: PPUSH
53654: CALL_OW 1
53658: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53659: LD_ADDR_EXP 74
53663: PUSH
53664: LD_EXP 74
53668: PPUSH
53669: LD_VAR 0 2
53673: PPUSH
53674: EMPTY
53675: PPUSH
53676: CALL_OW 1
53680: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53681: LD_ADDR_EXP 75
53685: PUSH
53686: LD_EXP 75
53690: PPUSH
53691: LD_VAR 0 2
53695: PPUSH
53696: EMPTY
53697: PPUSH
53698: CALL_OW 1
53702: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53703: LD_ADDR_EXP 76
53707: PUSH
53708: LD_EXP 76
53712: PPUSH
53713: LD_VAR 0 2
53717: PPUSH
53718: EMPTY
53719: PPUSH
53720: CALL_OW 1
53724: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53725: LD_ADDR_EXP 77
53729: PUSH
53730: LD_EXP 77
53734: PPUSH
53735: LD_VAR 0 2
53739: PPUSH
53740: EMPTY
53741: PPUSH
53742: CALL_OW 1
53746: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53747: LD_ADDR_EXP 78
53751: PUSH
53752: LD_EXP 78
53756: PPUSH
53757: LD_VAR 0 2
53761: PPUSH
53762: EMPTY
53763: PPUSH
53764: CALL_OW 1
53768: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53769: LD_ADDR_EXP 79
53773: PUSH
53774: LD_EXP 79
53778: PPUSH
53779: LD_VAR 0 2
53783: PPUSH
53784: EMPTY
53785: PPUSH
53786: CALL_OW 1
53790: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
53791: LD_ADDR_EXP 80
53795: PUSH
53796: LD_EXP 80
53800: PPUSH
53801: LD_VAR 0 2
53805: PPUSH
53806: EMPTY
53807: PPUSH
53808: CALL_OW 1
53812: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53813: LD_ADDR_EXP 81
53817: PUSH
53818: LD_EXP 81
53822: PPUSH
53823: LD_VAR 0 2
53827: PPUSH
53828: EMPTY
53829: PPUSH
53830: CALL_OW 1
53834: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
53835: LD_ADDR_EXP 70
53839: PUSH
53840: LD_EXP 70
53844: PPUSH
53845: LD_VAR 0 2
53849: PPUSH
53850: LD_INT 0
53852: PPUSH
53853: CALL_OW 1
53857: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
53858: LD_ADDR_EXP 83
53862: PUSH
53863: LD_EXP 83
53867: PPUSH
53868: LD_VAR 0 2
53872: PPUSH
53873: LD_INT 0
53875: PPUSH
53876: CALL_OW 1
53880: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53881: LD_ADDR_EXP 71
53885: PUSH
53886: LD_EXP 71
53890: PPUSH
53891: LD_VAR 0 2
53895: PPUSH
53896: EMPTY
53897: PPUSH
53898: CALL_OW 1
53902: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
53903: LD_ADDR_EXP 82
53907: PUSH
53908: LD_EXP 82
53912: PPUSH
53913: LD_VAR 0 2
53917: PPUSH
53918: LD_INT 0
53920: PPUSH
53921: CALL_OW 1
53925: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
53926: LD_ADDR_EXP 84
53930: PUSH
53931: LD_EXP 84
53935: PPUSH
53936: LD_VAR 0 2
53940: PPUSH
53941: EMPTY
53942: PPUSH
53943: CALL_OW 1
53947: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
53948: LD_ADDR_EXP 87
53952: PUSH
53953: LD_EXP 87
53957: PPUSH
53958: LD_VAR 0 2
53962: PPUSH
53963: LD_INT 0
53965: PPUSH
53966: CALL_OW 1
53970: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
53971: LD_ADDR_EXP 88
53975: PUSH
53976: LD_EXP 88
53980: PPUSH
53981: LD_VAR 0 2
53985: PPUSH
53986: EMPTY
53987: PPUSH
53988: CALL_OW 1
53992: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
53993: LD_ADDR_EXP 89
53997: PUSH
53998: LD_EXP 89
54002: PPUSH
54003: LD_VAR 0 2
54007: PPUSH
54008: EMPTY
54009: PPUSH
54010: CALL_OW 1
54014: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54015: LD_ADDR_EXP 90
54019: PUSH
54020: LD_EXP 90
54024: PPUSH
54025: LD_VAR 0 2
54029: PPUSH
54030: EMPTY
54031: PPUSH
54032: CALL_OW 1
54036: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
54037: LD_ADDR_EXP 92
54041: PUSH
54042: LD_EXP 92
54046: PPUSH
54047: LD_VAR 0 2
54051: PPUSH
54052: LD_EXP 59
54056: PUSH
54057: LD_VAR 0 2
54061: ARRAY
54062: PPUSH
54063: LD_INT 2
54065: PUSH
54066: LD_INT 30
54068: PUSH
54069: LD_INT 6
54071: PUSH
54072: EMPTY
54073: LIST
54074: LIST
54075: PUSH
54076: LD_INT 30
54078: PUSH
54079: LD_INT 7
54081: PUSH
54082: EMPTY
54083: LIST
54084: LIST
54085: PUSH
54086: LD_INT 30
54088: PUSH
54089: LD_INT 8
54091: PUSH
54092: EMPTY
54093: LIST
54094: LIST
54095: PUSH
54096: EMPTY
54097: LIST
54098: LIST
54099: LIST
54100: LIST
54101: PPUSH
54102: CALL_OW 72
54106: PPUSH
54107: CALL_OW 1
54111: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
54112: LD_ADDR_EXP 93
54116: PUSH
54117: LD_EXP 93
54121: PPUSH
54122: LD_VAR 0 2
54126: PPUSH
54127: EMPTY
54128: PPUSH
54129: CALL_OW 1
54133: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
54134: LD_ADDR_EXP 94
54138: PUSH
54139: LD_EXP 94
54143: PPUSH
54144: LD_VAR 0 2
54148: PPUSH
54149: EMPTY
54150: PPUSH
54151: CALL_OW 1
54155: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
54156: LD_ADDR_EXP 95
54160: PUSH
54161: LD_EXP 95
54165: PPUSH
54166: LD_VAR 0 2
54170: PPUSH
54171: EMPTY
54172: PPUSH
54173: CALL_OW 1
54177: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
54178: LD_ADDR_EXP 96
54182: PUSH
54183: LD_EXP 96
54187: PPUSH
54188: LD_VAR 0 2
54192: PPUSH
54193: EMPTY
54194: PPUSH
54195: CALL_OW 1
54199: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54200: LD_ADDR_EXP 97
54204: PUSH
54205: LD_EXP 97
54209: PPUSH
54210: LD_VAR 0 2
54214: PPUSH
54215: EMPTY
54216: PPUSH
54217: CALL_OW 1
54221: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
54222: LD_ADDR_EXP 98
54226: PUSH
54227: LD_EXP 98
54231: PPUSH
54232: LD_VAR 0 2
54236: PPUSH
54237: EMPTY
54238: PPUSH
54239: CALL_OW 1
54243: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
54244: LD_ADDR_EXP 99
54248: PUSH
54249: LD_EXP 99
54253: PPUSH
54254: LD_VAR 0 2
54258: PPUSH
54259: EMPTY
54260: PPUSH
54261: CALL_OW 1
54265: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
54266: LD_ADDR_EXP 100
54270: PUSH
54271: LD_EXP 100
54275: PPUSH
54276: LD_VAR 0 2
54280: PPUSH
54281: EMPTY
54282: PPUSH
54283: CALL_OW 1
54287: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
54288: LD_ADDR_EXP 101
54292: PUSH
54293: LD_EXP 101
54297: PPUSH
54298: LD_VAR 0 2
54302: PPUSH
54303: LD_INT 0
54305: PPUSH
54306: CALL_OW 1
54310: ST_TO_ADDR
// end ;
54311: GO 53235
54313: POP
54314: POP
// MC_InitSides ( ) ;
54315: CALL 54601 0 0
// MC_InitResearch ( ) ;
54319: CALL 54340 0 0
// CustomInitMacro ( ) ;
54323: CALL 181 0 0
// skirmish := true ;
54327: LD_ADDR_EXP 57
54331: PUSH
54332: LD_INT 1
54334: ST_TO_ADDR
// end ;
54335: LD_VAR 0 1
54339: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
54340: LD_INT 0
54342: PPUSH
54343: PPUSH
54344: PPUSH
54345: PPUSH
54346: PPUSH
54347: PPUSH
// if not mc_bases then
54348: LD_EXP 59
54352: NOT
54353: IFFALSE 54357
// exit ;
54355: GO 54596
// for i = 1 to 8 do
54357: LD_ADDR_VAR 0 2
54361: PUSH
54362: DOUBLE
54363: LD_INT 1
54365: DEC
54366: ST_TO_ADDR
54367: LD_INT 8
54369: PUSH
54370: FOR_TO
54371: IFFALSE 54397
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
54373: LD_ADDR_EXP 86
54377: PUSH
54378: LD_EXP 86
54382: PPUSH
54383: LD_VAR 0 2
54387: PPUSH
54388: EMPTY
54389: PPUSH
54390: CALL_OW 1
54394: ST_TO_ADDR
54395: GO 54370
54397: POP
54398: POP
// tmp := [ ] ;
54399: LD_ADDR_VAR 0 5
54403: PUSH
54404: EMPTY
54405: ST_TO_ADDR
// for i = 1 to mc_sides do
54406: LD_ADDR_VAR 0 2
54410: PUSH
54411: DOUBLE
54412: LD_INT 1
54414: DEC
54415: ST_TO_ADDR
54416: LD_EXP 85
54420: PUSH
54421: FOR_TO
54422: IFFALSE 54480
// if not mc_sides [ i ] in tmp then
54424: LD_EXP 85
54428: PUSH
54429: LD_VAR 0 2
54433: ARRAY
54434: PUSH
54435: LD_VAR 0 5
54439: IN
54440: NOT
54441: IFFALSE 54478
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
54443: LD_ADDR_VAR 0 5
54447: PUSH
54448: LD_VAR 0 5
54452: PPUSH
54453: LD_VAR 0 5
54457: PUSH
54458: LD_INT 1
54460: PLUS
54461: PPUSH
54462: LD_EXP 85
54466: PUSH
54467: LD_VAR 0 2
54471: ARRAY
54472: PPUSH
54473: CALL_OW 2
54477: ST_TO_ADDR
54478: GO 54421
54480: POP
54481: POP
// if not tmp then
54482: LD_VAR 0 5
54486: NOT
54487: IFFALSE 54491
// exit ;
54489: GO 54596
// for j in tmp do
54491: LD_ADDR_VAR 0 3
54495: PUSH
54496: LD_VAR 0 5
54500: PUSH
54501: FOR_IN
54502: IFFALSE 54594
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54504: LD_ADDR_VAR 0 6
54508: PUSH
54509: LD_INT 22
54511: PUSH
54512: LD_VAR 0 3
54516: PUSH
54517: EMPTY
54518: LIST
54519: LIST
54520: PPUSH
54521: CALL_OW 69
54525: ST_TO_ADDR
// if not un then
54526: LD_VAR 0 6
54530: NOT
54531: IFFALSE 54535
// continue ;
54533: GO 54501
// nation := GetNation ( un [ 1 ] ) ;
54535: LD_ADDR_VAR 0 4
54539: PUSH
54540: LD_VAR 0 6
54544: PUSH
54545: LD_INT 1
54547: ARRAY
54548: PPUSH
54549: CALL_OW 248
54553: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54554: LD_ADDR_EXP 86
54558: PUSH
54559: LD_EXP 86
54563: PPUSH
54564: LD_VAR 0 3
54568: PPUSH
54569: LD_VAR 0 3
54573: PPUSH
54574: LD_VAR 0 4
54578: PPUSH
54579: LD_INT 1
54581: PPUSH
54582: CALL 14355 0 3
54586: PPUSH
54587: CALL_OW 1
54591: ST_TO_ADDR
// end ;
54592: GO 54501
54594: POP
54595: POP
// end ;
54596: LD_VAR 0 1
54600: RET
// export function MC_InitSides ( ) ; var i ; begin
54601: LD_INT 0
54603: PPUSH
54604: PPUSH
// if not mc_bases then
54605: LD_EXP 59
54609: NOT
54610: IFFALSE 54614
// exit ;
54612: GO 54688
// for i = 1 to mc_bases do
54614: LD_ADDR_VAR 0 2
54618: PUSH
54619: DOUBLE
54620: LD_INT 1
54622: DEC
54623: ST_TO_ADDR
54624: LD_EXP 59
54628: PUSH
54629: FOR_TO
54630: IFFALSE 54686
// if mc_bases [ i ] then
54632: LD_EXP 59
54636: PUSH
54637: LD_VAR 0 2
54641: ARRAY
54642: IFFALSE 54684
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54644: LD_ADDR_EXP 85
54648: PUSH
54649: LD_EXP 85
54653: PPUSH
54654: LD_VAR 0 2
54658: PPUSH
54659: LD_EXP 59
54663: PUSH
54664: LD_VAR 0 2
54668: ARRAY
54669: PUSH
54670: LD_INT 1
54672: ARRAY
54673: PPUSH
54674: CALL_OW 255
54678: PPUSH
54679: CALL_OW 1
54683: ST_TO_ADDR
54684: GO 54629
54686: POP
54687: POP
// end ;
54688: LD_VAR 0 1
54692: RET
// every 0 0$01 trigger skirmish do
54693: LD_EXP 57
54697: IFFALSE 54851
54699: GO 54701
54701: DISABLE
// begin enable ;
54702: ENABLE
// MC_CheckBuildings ( ) ;
54703: CALL 59349 0 0
// MC_CheckPeopleLife ( ) ;
54707: CALL 59474 0 0
// RaiseSailEvent ( 100 ) ;
54711: LD_INT 100
54713: PPUSH
54714: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
54718: LD_INT 103
54720: PPUSH
54721: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
54725: LD_INT 104
54727: PPUSH
54728: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
54732: LD_INT 105
54734: PPUSH
54735: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
54739: LD_INT 106
54741: PPUSH
54742: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
54746: LD_INT 107
54748: PPUSH
54749: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
54753: LD_INT 108
54755: PPUSH
54756: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
54760: LD_INT 109
54762: PPUSH
54763: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
54767: LD_INT 110
54769: PPUSH
54770: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
54774: LD_INT 111
54776: PPUSH
54777: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
54781: LD_INT 112
54783: PPUSH
54784: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
54788: LD_INT 113
54790: PPUSH
54791: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
54795: LD_INT 120
54797: PPUSH
54798: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
54802: LD_INT 121
54804: PPUSH
54805: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
54809: LD_INT 122
54811: PPUSH
54812: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
54816: LD_INT 123
54818: PPUSH
54819: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
54823: LD_INT 124
54825: PPUSH
54826: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
54830: LD_INT 125
54832: PPUSH
54833: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
54837: LD_INT 126
54839: PPUSH
54840: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
54844: LD_INT 200
54846: PPUSH
54847: CALL_OW 427
// end ;
54851: END
// on SailEvent ( event ) do begin if event < 100 then
54852: LD_VAR 0 1
54856: PUSH
54857: LD_INT 100
54859: LESS
54860: IFFALSE 54871
// CustomEvent ( event ) ;
54862: LD_VAR 0 1
54866: PPUSH
54867: CALL 13013 0 1
// if event = 100 then
54871: LD_VAR 0 1
54875: PUSH
54876: LD_INT 100
54878: EQUAL
54879: IFFALSE 54885
// MC_ClassManager ( ) ;
54881: CALL 55277 0 0
// if event = 101 then
54885: LD_VAR 0 1
54889: PUSH
54890: LD_INT 101
54892: EQUAL
54893: IFFALSE 54899
// MC_RepairBuildings ( ) ;
54895: CALL 60059 0 0
// if event = 102 then
54899: LD_VAR 0 1
54903: PUSH
54904: LD_INT 102
54906: EQUAL
54907: IFFALSE 54913
// MC_Heal ( ) ;
54909: CALL 60918 0 0
// if event = 103 then
54913: LD_VAR 0 1
54917: PUSH
54918: LD_INT 103
54920: EQUAL
54921: IFFALSE 54927
// MC_Build ( ) ;
54923: CALL 61340 0 0
// if event = 104 then
54927: LD_VAR 0 1
54931: PUSH
54932: LD_INT 104
54934: EQUAL
54935: IFFALSE 54941
// MC_TurretWeapon ( ) ;
54937: CALL 62953 0 0
// if event = 105 then
54941: LD_VAR 0 1
54945: PUSH
54946: LD_INT 105
54948: EQUAL
54949: IFFALSE 54955
// MC_BuildUpgrade ( ) ;
54951: CALL 62504 0 0
// if event = 106 then
54955: LD_VAR 0 1
54959: PUSH
54960: LD_INT 106
54962: EQUAL
54963: IFFALSE 54969
// MC_PlantMines ( ) ;
54965: CALL 63383 0 0
// if event = 107 then
54969: LD_VAR 0 1
54973: PUSH
54974: LD_INT 107
54976: EQUAL
54977: IFFALSE 54983
// MC_CollectCrates ( ) ;
54979: CALL 64181 0 0
// if event = 108 then
54983: LD_VAR 0 1
54987: PUSH
54988: LD_INT 108
54990: EQUAL
54991: IFFALSE 54997
// MC_LinkRemoteControl ( ) ;
54993: CALL 65957 0 0
// if event = 109 then
54997: LD_VAR 0 1
55001: PUSH
55002: LD_INT 109
55004: EQUAL
55005: IFFALSE 55011
// MC_ProduceVehicle ( ) ;
55007: CALL 66138 0 0
// if event = 110 then
55011: LD_VAR 0 1
55015: PUSH
55016: LD_INT 110
55018: EQUAL
55019: IFFALSE 55025
// MC_SendAttack ( ) ;
55021: CALL 66604 0 0
// if event = 111 then
55025: LD_VAR 0 1
55029: PUSH
55030: LD_INT 111
55032: EQUAL
55033: IFFALSE 55039
// MC_Defend ( ) ;
55035: CALL 66712 0 0
// if event = 112 then
55039: LD_VAR 0 1
55043: PUSH
55044: LD_INT 112
55046: EQUAL
55047: IFFALSE 55053
// MC_Research ( ) ;
55049: CALL 67317 0 0
// if event = 113 then
55053: LD_VAR 0 1
55057: PUSH
55058: LD_INT 113
55060: EQUAL
55061: IFFALSE 55067
// MC_MinesTrigger ( ) ;
55063: CALL 68431 0 0
// if event = 120 then
55067: LD_VAR 0 1
55071: PUSH
55072: LD_INT 120
55074: EQUAL
55075: IFFALSE 55081
// MC_RepairVehicle ( ) ;
55077: CALL 68530 0 0
// if event = 121 then
55081: LD_VAR 0 1
55085: PUSH
55086: LD_INT 121
55088: EQUAL
55089: IFFALSE 55095
// MC_TameApe ( ) ;
55091: CALL 69260 0 0
// if event = 122 then
55095: LD_VAR 0 1
55099: PUSH
55100: LD_INT 122
55102: EQUAL
55103: IFFALSE 55109
// MC_ChangeApeClass ( ) ;
55105: CALL 70089 0 0
// if event = 123 then
55109: LD_VAR 0 1
55113: PUSH
55114: LD_INT 123
55116: EQUAL
55117: IFFALSE 55123
// MC_Bazooka ( ) ;
55119: CALL 70739 0 0
// if event = 124 then
55123: LD_VAR 0 1
55127: PUSH
55128: LD_INT 124
55130: EQUAL
55131: IFFALSE 55137
// MC_TeleportExit ( ) ;
55133: CALL 70937 0 0
// if event = 125 then
55137: LD_VAR 0 1
55141: PUSH
55142: LD_INT 125
55144: EQUAL
55145: IFFALSE 55151
// MC_Deposits ( ) ;
55147: CALL 71584 0 0
// if event = 126 then
55151: LD_VAR 0 1
55155: PUSH
55156: LD_INT 126
55158: EQUAL
55159: IFFALSE 55165
// MC_RemoteDriver ( ) ;
55161: CALL 72209 0 0
// if event = 200 then
55165: LD_VAR 0 1
55169: PUSH
55170: LD_INT 200
55172: EQUAL
55173: IFFALSE 55179
// MC_Idle ( ) ;
55175: CALL 74158 0 0
// end ;
55179: PPOPN 1
55181: END
// export function MC_Reset ( base , tag ) ; var i ; begin
55182: LD_INT 0
55184: PPUSH
55185: PPUSH
// if not mc_bases [ base ] or not tag then
55186: LD_EXP 59
55190: PUSH
55191: LD_VAR 0 1
55195: ARRAY
55196: NOT
55197: PUSH
55198: LD_VAR 0 2
55202: NOT
55203: OR
55204: IFFALSE 55208
// exit ;
55206: GO 55272
// for i in mc_bases [ base ] union mc_ape [ base ] do
55208: LD_ADDR_VAR 0 4
55212: PUSH
55213: LD_EXP 59
55217: PUSH
55218: LD_VAR 0 1
55222: ARRAY
55223: PUSH
55224: LD_EXP 88
55228: PUSH
55229: LD_VAR 0 1
55233: ARRAY
55234: UNION
55235: PUSH
55236: FOR_IN
55237: IFFALSE 55270
// if GetTag ( i ) = tag then
55239: LD_VAR 0 4
55243: PPUSH
55244: CALL_OW 110
55248: PUSH
55249: LD_VAR 0 2
55253: EQUAL
55254: IFFALSE 55268
// SetTag ( i , 0 ) ;
55256: LD_VAR 0 4
55260: PPUSH
55261: LD_INT 0
55263: PPUSH
55264: CALL_OW 109
55268: GO 55236
55270: POP
55271: POP
// end ;
55272: LD_VAR 0 3
55276: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
55277: LD_INT 0
55279: PPUSH
55280: PPUSH
55281: PPUSH
55282: PPUSH
55283: PPUSH
55284: PPUSH
55285: PPUSH
55286: PPUSH
// if not mc_bases then
55287: LD_EXP 59
55291: NOT
55292: IFFALSE 55296
// exit ;
55294: GO 55754
// for i = 1 to mc_bases do
55296: LD_ADDR_VAR 0 2
55300: PUSH
55301: DOUBLE
55302: LD_INT 1
55304: DEC
55305: ST_TO_ADDR
55306: LD_EXP 59
55310: PUSH
55311: FOR_TO
55312: IFFALSE 55752
// begin tmp := MC_ClassCheckReq ( i ) ;
55314: LD_ADDR_VAR 0 4
55318: PUSH
55319: LD_VAR 0 2
55323: PPUSH
55324: CALL 55759 0 1
55328: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
55329: LD_ADDR_EXP 100
55333: PUSH
55334: LD_EXP 100
55338: PPUSH
55339: LD_VAR 0 2
55343: PPUSH
55344: LD_VAR 0 4
55348: PPUSH
55349: CALL_OW 1
55353: ST_TO_ADDR
// if not tmp then
55354: LD_VAR 0 4
55358: NOT
55359: IFFALSE 55363
// continue ;
55361: GO 55311
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
55363: LD_ADDR_VAR 0 6
55367: PUSH
55368: LD_EXP 59
55372: PUSH
55373: LD_VAR 0 2
55377: ARRAY
55378: PPUSH
55379: LD_INT 2
55381: PUSH
55382: LD_INT 30
55384: PUSH
55385: LD_INT 4
55387: PUSH
55388: EMPTY
55389: LIST
55390: LIST
55391: PUSH
55392: LD_INT 30
55394: PUSH
55395: LD_INT 5
55397: PUSH
55398: EMPTY
55399: LIST
55400: LIST
55401: PUSH
55402: EMPTY
55403: LIST
55404: LIST
55405: LIST
55406: PPUSH
55407: CALL_OW 72
55411: PUSH
55412: LD_EXP 59
55416: PUSH
55417: LD_VAR 0 2
55421: ARRAY
55422: PPUSH
55423: LD_INT 2
55425: PUSH
55426: LD_INT 30
55428: PUSH
55429: LD_INT 0
55431: PUSH
55432: EMPTY
55433: LIST
55434: LIST
55435: PUSH
55436: LD_INT 30
55438: PUSH
55439: LD_INT 1
55441: PUSH
55442: EMPTY
55443: LIST
55444: LIST
55445: PUSH
55446: EMPTY
55447: LIST
55448: LIST
55449: LIST
55450: PPUSH
55451: CALL_OW 72
55455: PUSH
55456: LD_EXP 59
55460: PUSH
55461: LD_VAR 0 2
55465: ARRAY
55466: PPUSH
55467: LD_INT 30
55469: PUSH
55470: LD_INT 3
55472: PUSH
55473: EMPTY
55474: LIST
55475: LIST
55476: PPUSH
55477: CALL_OW 72
55481: PUSH
55482: LD_EXP 59
55486: PUSH
55487: LD_VAR 0 2
55491: ARRAY
55492: PPUSH
55493: LD_INT 2
55495: PUSH
55496: LD_INT 30
55498: PUSH
55499: LD_INT 6
55501: PUSH
55502: EMPTY
55503: LIST
55504: LIST
55505: PUSH
55506: LD_INT 30
55508: PUSH
55509: LD_INT 7
55511: PUSH
55512: EMPTY
55513: LIST
55514: LIST
55515: PUSH
55516: LD_INT 30
55518: PUSH
55519: LD_INT 8
55521: PUSH
55522: EMPTY
55523: LIST
55524: LIST
55525: PUSH
55526: EMPTY
55527: LIST
55528: LIST
55529: LIST
55530: LIST
55531: PPUSH
55532: CALL_OW 72
55536: PUSH
55537: EMPTY
55538: LIST
55539: LIST
55540: LIST
55541: LIST
55542: ST_TO_ADDR
// for j = 1 to 4 do
55543: LD_ADDR_VAR 0 3
55547: PUSH
55548: DOUBLE
55549: LD_INT 1
55551: DEC
55552: ST_TO_ADDR
55553: LD_INT 4
55555: PUSH
55556: FOR_TO
55557: IFFALSE 55748
// begin if not tmp [ j ] then
55559: LD_VAR 0 4
55563: PUSH
55564: LD_VAR 0 3
55568: ARRAY
55569: NOT
55570: IFFALSE 55574
// continue ;
55572: GO 55556
// for p in tmp [ j ] do
55574: LD_ADDR_VAR 0 5
55578: PUSH
55579: LD_VAR 0 4
55583: PUSH
55584: LD_VAR 0 3
55588: ARRAY
55589: PUSH
55590: FOR_IN
55591: IFFALSE 55744
// begin if not b [ j ] then
55593: LD_VAR 0 6
55597: PUSH
55598: LD_VAR 0 3
55602: ARRAY
55603: NOT
55604: IFFALSE 55608
// break ;
55606: GO 55744
// e := 0 ;
55608: LD_ADDR_VAR 0 7
55612: PUSH
55613: LD_INT 0
55615: ST_TO_ADDR
// for k in b [ j ] do
55616: LD_ADDR_VAR 0 8
55620: PUSH
55621: LD_VAR 0 6
55625: PUSH
55626: LD_VAR 0 3
55630: ARRAY
55631: PUSH
55632: FOR_IN
55633: IFFALSE 55660
// if IsNotFull ( k ) then
55635: LD_VAR 0 8
55639: PPUSH
55640: CALL 16504 0 1
55644: IFFALSE 55658
// begin e := k ;
55646: LD_ADDR_VAR 0 7
55650: PUSH
55651: LD_VAR 0 8
55655: ST_TO_ADDR
// break ;
55656: GO 55660
// end ;
55658: GO 55632
55660: POP
55661: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55662: LD_VAR 0 7
55666: PUSH
55667: LD_VAR 0 5
55671: PPUSH
55672: LD_VAR 0 7
55676: PPUSH
55677: CALL 48924 0 2
55681: NOT
55682: AND
55683: IFFALSE 55742
// begin if IsInUnit ( p ) then
55685: LD_VAR 0 5
55689: PPUSH
55690: CALL_OW 310
55694: IFFALSE 55705
// ComExitBuilding ( p ) ;
55696: LD_VAR 0 5
55700: PPUSH
55701: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55705: LD_VAR 0 5
55709: PPUSH
55710: LD_VAR 0 7
55714: PPUSH
55715: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
55719: LD_VAR 0 5
55723: PPUSH
55724: LD_VAR 0 3
55728: PPUSH
55729: CALL_OW 183
// AddComExitBuilding ( p ) ;
55733: LD_VAR 0 5
55737: PPUSH
55738: CALL_OW 182
// end ; end ;
55742: GO 55590
55744: POP
55745: POP
// end ;
55746: GO 55556
55748: POP
55749: POP
// end ;
55750: GO 55311
55752: POP
55753: POP
// end ;
55754: LD_VAR 0 1
55758: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
55759: LD_INT 0
55761: PPUSH
55762: PPUSH
55763: PPUSH
55764: PPUSH
55765: PPUSH
55766: PPUSH
55767: PPUSH
55768: PPUSH
55769: PPUSH
55770: PPUSH
55771: PPUSH
55772: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55773: LD_VAR 0 1
55777: NOT
55778: PUSH
55779: LD_EXP 59
55783: PUSH
55784: LD_VAR 0 1
55788: ARRAY
55789: NOT
55790: OR
55791: PUSH
55792: LD_EXP 59
55796: PUSH
55797: LD_VAR 0 1
55801: ARRAY
55802: PPUSH
55803: LD_INT 2
55805: PUSH
55806: LD_INT 30
55808: PUSH
55809: LD_INT 0
55811: PUSH
55812: EMPTY
55813: LIST
55814: LIST
55815: PUSH
55816: LD_INT 30
55818: PUSH
55819: LD_INT 1
55821: PUSH
55822: EMPTY
55823: LIST
55824: LIST
55825: PUSH
55826: EMPTY
55827: LIST
55828: LIST
55829: LIST
55830: PPUSH
55831: CALL_OW 72
55835: NOT
55836: OR
55837: IFFALSE 55841
// exit ;
55839: GO 59344
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55841: LD_ADDR_VAR 0 4
55845: PUSH
55846: LD_EXP 59
55850: PUSH
55851: LD_VAR 0 1
55855: ARRAY
55856: PPUSH
55857: LD_INT 2
55859: PUSH
55860: LD_INT 25
55862: PUSH
55863: LD_INT 1
55865: PUSH
55866: EMPTY
55867: LIST
55868: LIST
55869: PUSH
55870: LD_INT 25
55872: PUSH
55873: LD_INT 2
55875: PUSH
55876: EMPTY
55877: LIST
55878: LIST
55879: PUSH
55880: LD_INT 25
55882: PUSH
55883: LD_INT 3
55885: PUSH
55886: EMPTY
55887: LIST
55888: LIST
55889: PUSH
55890: LD_INT 25
55892: PUSH
55893: LD_INT 4
55895: PUSH
55896: EMPTY
55897: LIST
55898: LIST
55899: PUSH
55900: LD_INT 25
55902: PUSH
55903: LD_INT 5
55905: PUSH
55906: EMPTY
55907: LIST
55908: LIST
55909: PUSH
55910: LD_INT 25
55912: PUSH
55913: LD_INT 8
55915: PUSH
55916: EMPTY
55917: LIST
55918: LIST
55919: PUSH
55920: LD_INT 25
55922: PUSH
55923: LD_INT 9
55925: PUSH
55926: EMPTY
55927: LIST
55928: LIST
55929: PUSH
55930: EMPTY
55931: LIST
55932: LIST
55933: LIST
55934: LIST
55935: LIST
55936: LIST
55937: LIST
55938: LIST
55939: PPUSH
55940: CALL_OW 72
55944: ST_TO_ADDR
// if not tmp then
55945: LD_VAR 0 4
55949: NOT
55950: IFFALSE 55954
// exit ;
55952: GO 59344
// for i in tmp do
55954: LD_ADDR_VAR 0 3
55958: PUSH
55959: LD_VAR 0 4
55963: PUSH
55964: FOR_IN
55965: IFFALSE 55996
// if GetTag ( i ) then
55967: LD_VAR 0 3
55971: PPUSH
55972: CALL_OW 110
55976: IFFALSE 55994
// tmp := tmp diff i ;
55978: LD_ADDR_VAR 0 4
55982: PUSH
55983: LD_VAR 0 4
55987: PUSH
55988: LD_VAR 0 3
55992: DIFF
55993: ST_TO_ADDR
55994: GO 55964
55996: POP
55997: POP
// if not tmp then
55998: LD_VAR 0 4
56002: NOT
56003: IFFALSE 56007
// exit ;
56005: GO 59344
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56007: LD_ADDR_VAR 0 5
56011: PUSH
56012: LD_EXP 59
56016: PUSH
56017: LD_VAR 0 1
56021: ARRAY
56022: PPUSH
56023: LD_INT 2
56025: PUSH
56026: LD_INT 25
56028: PUSH
56029: LD_INT 1
56031: PUSH
56032: EMPTY
56033: LIST
56034: LIST
56035: PUSH
56036: LD_INT 25
56038: PUSH
56039: LD_INT 5
56041: PUSH
56042: EMPTY
56043: LIST
56044: LIST
56045: PUSH
56046: LD_INT 25
56048: PUSH
56049: LD_INT 8
56051: PUSH
56052: EMPTY
56053: LIST
56054: LIST
56055: PUSH
56056: LD_INT 25
56058: PUSH
56059: LD_INT 9
56061: PUSH
56062: EMPTY
56063: LIST
56064: LIST
56065: PUSH
56066: EMPTY
56067: LIST
56068: LIST
56069: LIST
56070: LIST
56071: LIST
56072: PPUSH
56073: CALL_OW 72
56077: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
56078: LD_ADDR_VAR 0 6
56082: PUSH
56083: LD_EXP 59
56087: PUSH
56088: LD_VAR 0 1
56092: ARRAY
56093: PPUSH
56094: LD_INT 25
56096: PUSH
56097: LD_INT 2
56099: PUSH
56100: EMPTY
56101: LIST
56102: LIST
56103: PPUSH
56104: CALL_OW 72
56108: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56109: LD_ADDR_VAR 0 7
56113: PUSH
56114: LD_EXP 59
56118: PUSH
56119: LD_VAR 0 1
56123: ARRAY
56124: PPUSH
56125: LD_INT 25
56127: PUSH
56128: LD_INT 3
56130: PUSH
56131: EMPTY
56132: LIST
56133: LIST
56134: PPUSH
56135: CALL_OW 72
56139: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
56140: LD_ADDR_VAR 0 8
56144: PUSH
56145: LD_EXP 59
56149: PUSH
56150: LD_VAR 0 1
56154: ARRAY
56155: PPUSH
56156: LD_INT 25
56158: PUSH
56159: LD_INT 4
56161: PUSH
56162: EMPTY
56163: LIST
56164: LIST
56165: PUSH
56166: LD_INT 24
56168: PUSH
56169: LD_INT 251
56171: PUSH
56172: EMPTY
56173: LIST
56174: LIST
56175: PUSH
56176: EMPTY
56177: LIST
56178: LIST
56179: PPUSH
56180: CALL_OW 72
56184: ST_TO_ADDR
// if mc_scan [ base ] then
56185: LD_EXP 82
56189: PUSH
56190: LD_VAR 0 1
56194: ARRAY
56195: IFFALSE 56656
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
56197: LD_ADDR_EXP 101
56201: PUSH
56202: LD_EXP 101
56206: PPUSH
56207: LD_VAR 0 1
56211: PPUSH
56212: LD_INT 4
56214: PPUSH
56215: CALL_OW 1
56219: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56220: LD_ADDR_VAR 0 12
56224: PUSH
56225: LD_EXP 59
56229: PUSH
56230: LD_VAR 0 1
56234: ARRAY
56235: PPUSH
56236: LD_INT 2
56238: PUSH
56239: LD_INT 30
56241: PUSH
56242: LD_INT 4
56244: PUSH
56245: EMPTY
56246: LIST
56247: LIST
56248: PUSH
56249: LD_INT 30
56251: PUSH
56252: LD_INT 5
56254: PUSH
56255: EMPTY
56256: LIST
56257: LIST
56258: PUSH
56259: EMPTY
56260: LIST
56261: LIST
56262: LIST
56263: PPUSH
56264: CALL_OW 72
56268: ST_TO_ADDR
// if not b then
56269: LD_VAR 0 12
56273: NOT
56274: IFFALSE 56278
// exit ;
56276: GO 59344
// p := [ ] ;
56278: LD_ADDR_VAR 0 11
56282: PUSH
56283: EMPTY
56284: ST_TO_ADDR
// if sci >= 2 then
56285: LD_VAR 0 8
56289: PUSH
56290: LD_INT 2
56292: GREATEREQUAL
56293: IFFALSE 56324
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
56295: LD_ADDR_VAR 0 8
56299: PUSH
56300: LD_VAR 0 8
56304: PUSH
56305: LD_INT 1
56307: ARRAY
56308: PUSH
56309: LD_VAR 0 8
56313: PUSH
56314: LD_INT 2
56316: ARRAY
56317: PUSH
56318: EMPTY
56319: LIST
56320: LIST
56321: ST_TO_ADDR
56322: GO 56385
// if sci = 1 then
56324: LD_VAR 0 8
56328: PUSH
56329: LD_INT 1
56331: EQUAL
56332: IFFALSE 56353
// sci := [ sci [ 1 ] ] else
56334: LD_ADDR_VAR 0 8
56338: PUSH
56339: LD_VAR 0 8
56343: PUSH
56344: LD_INT 1
56346: ARRAY
56347: PUSH
56348: EMPTY
56349: LIST
56350: ST_TO_ADDR
56351: GO 56385
// if sci = 0 then
56353: LD_VAR 0 8
56357: PUSH
56358: LD_INT 0
56360: EQUAL
56361: IFFALSE 56385
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
56363: LD_ADDR_VAR 0 11
56367: PUSH
56368: LD_VAR 0 4
56372: PPUSH
56373: LD_INT 4
56375: PPUSH
56376: CALL 48787 0 2
56380: PUSH
56381: LD_INT 1
56383: ARRAY
56384: ST_TO_ADDR
// if eng > 4 then
56385: LD_VAR 0 6
56389: PUSH
56390: LD_INT 4
56392: GREATER
56393: IFFALSE 56439
// for i = eng downto 4 do
56395: LD_ADDR_VAR 0 3
56399: PUSH
56400: DOUBLE
56401: LD_VAR 0 6
56405: INC
56406: ST_TO_ADDR
56407: LD_INT 4
56409: PUSH
56410: FOR_DOWNTO
56411: IFFALSE 56437
// eng := eng diff eng [ i ] ;
56413: LD_ADDR_VAR 0 6
56417: PUSH
56418: LD_VAR 0 6
56422: PUSH
56423: LD_VAR 0 6
56427: PUSH
56428: LD_VAR 0 3
56432: ARRAY
56433: DIFF
56434: ST_TO_ADDR
56435: GO 56410
56437: POP
56438: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
56439: LD_ADDR_VAR 0 4
56443: PUSH
56444: LD_VAR 0 4
56448: PUSH
56449: LD_VAR 0 5
56453: PUSH
56454: LD_VAR 0 6
56458: UNION
56459: PUSH
56460: LD_VAR 0 7
56464: UNION
56465: PUSH
56466: LD_VAR 0 8
56470: UNION
56471: DIFF
56472: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56473: LD_ADDR_VAR 0 13
56477: PUSH
56478: LD_EXP 59
56482: PUSH
56483: LD_VAR 0 1
56487: ARRAY
56488: PPUSH
56489: LD_INT 2
56491: PUSH
56492: LD_INT 30
56494: PUSH
56495: LD_INT 32
56497: PUSH
56498: EMPTY
56499: LIST
56500: LIST
56501: PUSH
56502: LD_INT 30
56504: PUSH
56505: LD_INT 31
56507: PUSH
56508: EMPTY
56509: LIST
56510: LIST
56511: PUSH
56512: EMPTY
56513: LIST
56514: LIST
56515: LIST
56516: PPUSH
56517: CALL_OW 72
56521: PUSH
56522: LD_EXP 59
56526: PUSH
56527: LD_VAR 0 1
56531: ARRAY
56532: PPUSH
56533: LD_INT 2
56535: PUSH
56536: LD_INT 30
56538: PUSH
56539: LD_INT 4
56541: PUSH
56542: EMPTY
56543: LIST
56544: LIST
56545: PUSH
56546: LD_INT 30
56548: PUSH
56549: LD_INT 5
56551: PUSH
56552: EMPTY
56553: LIST
56554: LIST
56555: PUSH
56556: EMPTY
56557: LIST
56558: LIST
56559: LIST
56560: PPUSH
56561: CALL_OW 72
56565: PUSH
56566: LD_INT 6
56568: MUL
56569: PLUS
56570: ST_TO_ADDR
// if bcount < tmp then
56571: LD_VAR 0 13
56575: PUSH
56576: LD_VAR 0 4
56580: LESS
56581: IFFALSE 56627
// for i = tmp downto bcount do
56583: LD_ADDR_VAR 0 3
56587: PUSH
56588: DOUBLE
56589: LD_VAR 0 4
56593: INC
56594: ST_TO_ADDR
56595: LD_VAR 0 13
56599: PUSH
56600: FOR_DOWNTO
56601: IFFALSE 56625
// tmp := Delete ( tmp , tmp ) ;
56603: LD_ADDR_VAR 0 4
56607: PUSH
56608: LD_VAR 0 4
56612: PPUSH
56613: LD_VAR 0 4
56617: PPUSH
56618: CALL_OW 3
56622: ST_TO_ADDR
56623: GO 56600
56625: POP
56626: POP
// result := [ tmp , 0 , 0 , p ] ;
56627: LD_ADDR_VAR 0 2
56631: PUSH
56632: LD_VAR 0 4
56636: PUSH
56637: LD_INT 0
56639: PUSH
56640: LD_INT 0
56642: PUSH
56643: LD_VAR 0 11
56647: PUSH
56648: EMPTY
56649: LIST
56650: LIST
56651: LIST
56652: LIST
56653: ST_TO_ADDR
// exit ;
56654: GO 59344
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56656: LD_EXP 59
56660: PUSH
56661: LD_VAR 0 1
56665: ARRAY
56666: PPUSH
56667: LD_INT 2
56669: PUSH
56670: LD_INT 30
56672: PUSH
56673: LD_INT 6
56675: PUSH
56676: EMPTY
56677: LIST
56678: LIST
56679: PUSH
56680: LD_INT 30
56682: PUSH
56683: LD_INT 7
56685: PUSH
56686: EMPTY
56687: LIST
56688: LIST
56689: PUSH
56690: LD_INT 30
56692: PUSH
56693: LD_INT 8
56695: PUSH
56696: EMPTY
56697: LIST
56698: LIST
56699: PUSH
56700: EMPTY
56701: LIST
56702: LIST
56703: LIST
56704: LIST
56705: PPUSH
56706: CALL_OW 72
56710: NOT
56711: PUSH
56712: LD_EXP 59
56716: PUSH
56717: LD_VAR 0 1
56721: ARRAY
56722: PPUSH
56723: LD_INT 30
56725: PUSH
56726: LD_INT 3
56728: PUSH
56729: EMPTY
56730: LIST
56731: LIST
56732: PPUSH
56733: CALL_OW 72
56737: NOT
56738: AND
56739: IFFALSE 56811
// begin if eng = tmp then
56741: LD_VAR 0 6
56745: PUSH
56746: LD_VAR 0 4
56750: EQUAL
56751: IFFALSE 56755
// exit ;
56753: GO 59344
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
56755: LD_ADDR_EXP 101
56759: PUSH
56760: LD_EXP 101
56764: PPUSH
56765: LD_VAR 0 1
56769: PPUSH
56770: LD_INT 1
56772: PPUSH
56773: CALL_OW 1
56777: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
56778: LD_ADDR_VAR 0 2
56782: PUSH
56783: LD_INT 0
56785: PUSH
56786: LD_VAR 0 4
56790: PUSH
56791: LD_VAR 0 6
56795: DIFF
56796: PUSH
56797: LD_INT 0
56799: PUSH
56800: LD_INT 0
56802: PUSH
56803: EMPTY
56804: LIST
56805: LIST
56806: LIST
56807: LIST
56808: ST_TO_ADDR
// exit ;
56809: GO 59344
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56811: LD_EXP 86
56815: PUSH
56816: LD_EXP 85
56820: PUSH
56821: LD_VAR 0 1
56825: ARRAY
56826: ARRAY
56827: PUSH
56828: LD_EXP 59
56832: PUSH
56833: LD_VAR 0 1
56837: ARRAY
56838: PPUSH
56839: LD_INT 2
56841: PUSH
56842: LD_INT 30
56844: PUSH
56845: LD_INT 6
56847: PUSH
56848: EMPTY
56849: LIST
56850: LIST
56851: PUSH
56852: LD_INT 30
56854: PUSH
56855: LD_INT 7
56857: PUSH
56858: EMPTY
56859: LIST
56860: LIST
56861: PUSH
56862: LD_INT 30
56864: PUSH
56865: LD_INT 8
56867: PUSH
56868: EMPTY
56869: LIST
56870: LIST
56871: PUSH
56872: EMPTY
56873: LIST
56874: LIST
56875: LIST
56876: LIST
56877: PPUSH
56878: CALL_OW 72
56882: AND
56883: PUSH
56884: LD_EXP 59
56888: PUSH
56889: LD_VAR 0 1
56893: ARRAY
56894: PPUSH
56895: LD_INT 30
56897: PUSH
56898: LD_INT 3
56900: PUSH
56901: EMPTY
56902: LIST
56903: LIST
56904: PPUSH
56905: CALL_OW 72
56909: NOT
56910: AND
56911: IFFALSE 57125
// begin if sci >= 6 then
56913: LD_VAR 0 8
56917: PUSH
56918: LD_INT 6
56920: GREATEREQUAL
56921: IFFALSE 56925
// exit ;
56923: GO 59344
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
56925: LD_ADDR_EXP 101
56929: PUSH
56930: LD_EXP 101
56934: PPUSH
56935: LD_VAR 0 1
56939: PPUSH
56940: LD_INT 2
56942: PPUSH
56943: CALL_OW 1
56947: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
56948: LD_ADDR_VAR 0 9
56952: PUSH
56953: LD_VAR 0 4
56957: PUSH
56958: LD_VAR 0 8
56962: DIFF
56963: PPUSH
56964: LD_INT 4
56966: PPUSH
56967: CALL 48787 0 2
56971: ST_TO_ADDR
// p := [ ] ;
56972: LD_ADDR_VAR 0 11
56976: PUSH
56977: EMPTY
56978: ST_TO_ADDR
// if sci < 6 and sort > 6 then
56979: LD_VAR 0 8
56983: PUSH
56984: LD_INT 6
56986: LESS
56987: PUSH
56988: LD_VAR 0 9
56992: PUSH
56993: LD_INT 6
56995: GREATER
56996: AND
56997: IFFALSE 57078
// begin for i = 1 to 6 - sci do
56999: LD_ADDR_VAR 0 3
57003: PUSH
57004: DOUBLE
57005: LD_INT 1
57007: DEC
57008: ST_TO_ADDR
57009: LD_INT 6
57011: PUSH
57012: LD_VAR 0 8
57016: MINUS
57017: PUSH
57018: FOR_TO
57019: IFFALSE 57074
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57021: LD_ADDR_VAR 0 11
57025: PUSH
57026: LD_VAR 0 11
57030: PPUSH
57031: LD_VAR 0 11
57035: PUSH
57036: LD_INT 1
57038: PLUS
57039: PPUSH
57040: LD_VAR 0 9
57044: PUSH
57045: LD_INT 1
57047: ARRAY
57048: PPUSH
57049: CALL_OW 2
57053: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
57054: LD_ADDR_VAR 0 9
57058: PUSH
57059: LD_VAR 0 9
57063: PPUSH
57064: LD_INT 1
57066: PPUSH
57067: CALL_OW 3
57071: ST_TO_ADDR
// end ;
57072: GO 57018
57074: POP
57075: POP
// end else
57076: GO 57098
// if sort then
57078: LD_VAR 0 9
57082: IFFALSE 57098
// p := sort [ 1 ] ;
57084: LD_ADDR_VAR 0 11
57088: PUSH
57089: LD_VAR 0 9
57093: PUSH
57094: LD_INT 1
57096: ARRAY
57097: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
57098: LD_ADDR_VAR 0 2
57102: PUSH
57103: LD_INT 0
57105: PUSH
57106: LD_INT 0
57108: PUSH
57109: LD_INT 0
57111: PUSH
57112: LD_VAR 0 11
57116: PUSH
57117: EMPTY
57118: LIST
57119: LIST
57120: LIST
57121: LIST
57122: ST_TO_ADDR
// exit ;
57123: GO 59344
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57125: LD_EXP 86
57129: PUSH
57130: LD_EXP 85
57134: PUSH
57135: LD_VAR 0 1
57139: ARRAY
57140: ARRAY
57141: PUSH
57142: LD_EXP 59
57146: PUSH
57147: LD_VAR 0 1
57151: ARRAY
57152: PPUSH
57153: LD_INT 2
57155: PUSH
57156: LD_INT 30
57158: PUSH
57159: LD_INT 6
57161: PUSH
57162: EMPTY
57163: LIST
57164: LIST
57165: PUSH
57166: LD_INT 30
57168: PUSH
57169: LD_INT 7
57171: PUSH
57172: EMPTY
57173: LIST
57174: LIST
57175: PUSH
57176: LD_INT 30
57178: PUSH
57179: LD_INT 8
57181: PUSH
57182: EMPTY
57183: LIST
57184: LIST
57185: PUSH
57186: EMPTY
57187: LIST
57188: LIST
57189: LIST
57190: LIST
57191: PPUSH
57192: CALL_OW 72
57196: AND
57197: PUSH
57198: LD_EXP 59
57202: PUSH
57203: LD_VAR 0 1
57207: ARRAY
57208: PPUSH
57209: LD_INT 30
57211: PUSH
57212: LD_INT 3
57214: PUSH
57215: EMPTY
57216: LIST
57217: LIST
57218: PPUSH
57219: CALL_OW 72
57223: AND
57224: IFFALSE 57958
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
57226: LD_ADDR_EXP 101
57230: PUSH
57231: LD_EXP 101
57235: PPUSH
57236: LD_VAR 0 1
57240: PPUSH
57241: LD_INT 3
57243: PPUSH
57244: CALL_OW 1
57248: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57249: LD_ADDR_VAR 0 2
57253: PUSH
57254: LD_INT 0
57256: PUSH
57257: LD_INT 0
57259: PUSH
57260: LD_INT 0
57262: PUSH
57263: LD_INT 0
57265: PUSH
57266: EMPTY
57267: LIST
57268: LIST
57269: LIST
57270: LIST
57271: ST_TO_ADDR
// if not eng then
57272: LD_VAR 0 6
57276: NOT
57277: IFFALSE 57340
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
57279: LD_ADDR_VAR 0 11
57283: PUSH
57284: LD_VAR 0 4
57288: PPUSH
57289: LD_INT 2
57291: PPUSH
57292: CALL 48787 0 2
57296: PUSH
57297: LD_INT 1
57299: ARRAY
57300: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
57301: LD_ADDR_VAR 0 2
57305: PUSH
57306: LD_VAR 0 2
57310: PPUSH
57311: LD_INT 2
57313: PPUSH
57314: LD_VAR 0 11
57318: PPUSH
57319: CALL_OW 1
57323: ST_TO_ADDR
// tmp := tmp diff p ;
57324: LD_ADDR_VAR 0 4
57328: PUSH
57329: LD_VAR 0 4
57333: PUSH
57334: LD_VAR 0 11
57338: DIFF
57339: ST_TO_ADDR
// end ; if tmp and sci < 6 then
57340: LD_VAR 0 4
57344: PUSH
57345: LD_VAR 0 8
57349: PUSH
57350: LD_INT 6
57352: LESS
57353: AND
57354: IFFALSE 57542
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
57356: LD_ADDR_VAR 0 9
57360: PUSH
57361: LD_VAR 0 4
57365: PUSH
57366: LD_VAR 0 8
57370: PUSH
57371: LD_VAR 0 7
57375: UNION
57376: DIFF
57377: PPUSH
57378: LD_INT 4
57380: PPUSH
57381: CALL 48787 0 2
57385: ST_TO_ADDR
// p := [ ] ;
57386: LD_ADDR_VAR 0 11
57390: PUSH
57391: EMPTY
57392: ST_TO_ADDR
// if sort then
57393: LD_VAR 0 9
57397: IFFALSE 57513
// for i = 1 to 6 - sci do
57399: LD_ADDR_VAR 0 3
57403: PUSH
57404: DOUBLE
57405: LD_INT 1
57407: DEC
57408: ST_TO_ADDR
57409: LD_INT 6
57411: PUSH
57412: LD_VAR 0 8
57416: MINUS
57417: PUSH
57418: FOR_TO
57419: IFFALSE 57511
// begin if i = sort then
57421: LD_VAR 0 3
57425: PUSH
57426: LD_VAR 0 9
57430: EQUAL
57431: IFFALSE 57435
// break ;
57433: GO 57511
// if GetClass ( i ) = 4 then
57435: LD_VAR 0 3
57439: PPUSH
57440: CALL_OW 257
57444: PUSH
57445: LD_INT 4
57447: EQUAL
57448: IFFALSE 57452
// continue ;
57450: GO 57418
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57452: LD_ADDR_VAR 0 11
57456: PUSH
57457: LD_VAR 0 11
57461: PPUSH
57462: LD_VAR 0 11
57466: PUSH
57467: LD_INT 1
57469: PLUS
57470: PPUSH
57471: LD_VAR 0 9
57475: PUSH
57476: LD_VAR 0 3
57480: ARRAY
57481: PPUSH
57482: CALL_OW 2
57486: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57487: LD_ADDR_VAR 0 4
57491: PUSH
57492: LD_VAR 0 4
57496: PUSH
57497: LD_VAR 0 9
57501: PUSH
57502: LD_VAR 0 3
57506: ARRAY
57507: DIFF
57508: ST_TO_ADDR
// end ;
57509: GO 57418
57511: POP
57512: POP
// if p then
57513: LD_VAR 0 11
57517: IFFALSE 57542
// result := Replace ( result , 4 , p ) ;
57519: LD_ADDR_VAR 0 2
57523: PUSH
57524: LD_VAR 0 2
57528: PPUSH
57529: LD_INT 4
57531: PPUSH
57532: LD_VAR 0 11
57536: PPUSH
57537: CALL_OW 1
57541: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57542: LD_VAR 0 4
57546: PUSH
57547: LD_VAR 0 7
57551: PUSH
57552: LD_INT 6
57554: LESS
57555: AND
57556: IFFALSE 57744
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57558: LD_ADDR_VAR 0 9
57562: PUSH
57563: LD_VAR 0 4
57567: PUSH
57568: LD_VAR 0 8
57572: PUSH
57573: LD_VAR 0 7
57577: UNION
57578: DIFF
57579: PPUSH
57580: LD_INT 3
57582: PPUSH
57583: CALL 48787 0 2
57587: ST_TO_ADDR
// p := [ ] ;
57588: LD_ADDR_VAR 0 11
57592: PUSH
57593: EMPTY
57594: ST_TO_ADDR
// if sort then
57595: LD_VAR 0 9
57599: IFFALSE 57715
// for i = 1 to 6 - mech do
57601: LD_ADDR_VAR 0 3
57605: PUSH
57606: DOUBLE
57607: LD_INT 1
57609: DEC
57610: ST_TO_ADDR
57611: LD_INT 6
57613: PUSH
57614: LD_VAR 0 7
57618: MINUS
57619: PUSH
57620: FOR_TO
57621: IFFALSE 57713
// begin if i = sort then
57623: LD_VAR 0 3
57627: PUSH
57628: LD_VAR 0 9
57632: EQUAL
57633: IFFALSE 57637
// break ;
57635: GO 57713
// if GetClass ( i ) = 3 then
57637: LD_VAR 0 3
57641: PPUSH
57642: CALL_OW 257
57646: PUSH
57647: LD_INT 3
57649: EQUAL
57650: IFFALSE 57654
// continue ;
57652: GO 57620
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57654: LD_ADDR_VAR 0 11
57658: PUSH
57659: LD_VAR 0 11
57663: PPUSH
57664: LD_VAR 0 11
57668: PUSH
57669: LD_INT 1
57671: PLUS
57672: PPUSH
57673: LD_VAR 0 9
57677: PUSH
57678: LD_VAR 0 3
57682: ARRAY
57683: PPUSH
57684: CALL_OW 2
57688: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57689: LD_ADDR_VAR 0 4
57693: PUSH
57694: LD_VAR 0 4
57698: PUSH
57699: LD_VAR 0 9
57703: PUSH
57704: LD_VAR 0 3
57708: ARRAY
57709: DIFF
57710: ST_TO_ADDR
// end ;
57711: GO 57620
57713: POP
57714: POP
// if p then
57715: LD_VAR 0 11
57719: IFFALSE 57744
// result := Replace ( result , 3 , p ) ;
57721: LD_ADDR_VAR 0 2
57725: PUSH
57726: LD_VAR 0 2
57730: PPUSH
57731: LD_INT 3
57733: PPUSH
57734: LD_VAR 0 11
57738: PPUSH
57739: CALL_OW 1
57743: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
57744: LD_VAR 0 4
57748: PUSH
57749: LD_INT 6
57751: GREATER
57752: PUSH
57753: LD_VAR 0 6
57757: PUSH
57758: LD_INT 6
57760: LESS
57761: AND
57762: IFFALSE 57956
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57764: LD_ADDR_VAR 0 9
57768: PUSH
57769: LD_VAR 0 4
57773: PUSH
57774: LD_VAR 0 8
57778: PUSH
57779: LD_VAR 0 7
57783: UNION
57784: PUSH
57785: LD_VAR 0 6
57789: UNION
57790: DIFF
57791: PPUSH
57792: LD_INT 2
57794: PPUSH
57795: CALL 48787 0 2
57799: ST_TO_ADDR
// p := [ ] ;
57800: LD_ADDR_VAR 0 11
57804: PUSH
57805: EMPTY
57806: ST_TO_ADDR
// if sort then
57807: LD_VAR 0 9
57811: IFFALSE 57927
// for i = 1 to 6 - eng do
57813: LD_ADDR_VAR 0 3
57817: PUSH
57818: DOUBLE
57819: LD_INT 1
57821: DEC
57822: ST_TO_ADDR
57823: LD_INT 6
57825: PUSH
57826: LD_VAR 0 6
57830: MINUS
57831: PUSH
57832: FOR_TO
57833: IFFALSE 57925
// begin if i = sort then
57835: LD_VAR 0 3
57839: PUSH
57840: LD_VAR 0 9
57844: EQUAL
57845: IFFALSE 57849
// break ;
57847: GO 57925
// if GetClass ( i ) = 2 then
57849: LD_VAR 0 3
57853: PPUSH
57854: CALL_OW 257
57858: PUSH
57859: LD_INT 2
57861: EQUAL
57862: IFFALSE 57866
// continue ;
57864: GO 57832
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57866: LD_ADDR_VAR 0 11
57870: PUSH
57871: LD_VAR 0 11
57875: PPUSH
57876: LD_VAR 0 11
57880: PUSH
57881: LD_INT 1
57883: PLUS
57884: PPUSH
57885: LD_VAR 0 9
57889: PUSH
57890: LD_VAR 0 3
57894: ARRAY
57895: PPUSH
57896: CALL_OW 2
57900: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57901: LD_ADDR_VAR 0 4
57905: PUSH
57906: LD_VAR 0 4
57910: PUSH
57911: LD_VAR 0 9
57915: PUSH
57916: LD_VAR 0 3
57920: ARRAY
57921: DIFF
57922: ST_TO_ADDR
// end ;
57923: GO 57832
57925: POP
57926: POP
// if p then
57927: LD_VAR 0 11
57931: IFFALSE 57956
// result := Replace ( result , 2 , p ) ;
57933: LD_ADDR_VAR 0 2
57937: PUSH
57938: LD_VAR 0 2
57942: PPUSH
57943: LD_INT 2
57945: PPUSH
57946: LD_VAR 0 11
57950: PPUSH
57951: CALL_OW 1
57955: ST_TO_ADDR
// end ; exit ;
57956: GO 59344
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
57958: LD_EXP 86
57962: PUSH
57963: LD_EXP 85
57967: PUSH
57968: LD_VAR 0 1
57972: ARRAY
57973: ARRAY
57974: NOT
57975: PUSH
57976: LD_EXP 59
57980: PUSH
57981: LD_VAR 0 1
57985: ARRAY
57986: PPUSH
57987: LD_INT 30
57989: PUSH
57990: LD_INT 3
57992: PUSH
57993: EMPTY
57994: LIST
57995: LIST
57996: PPUSH
57997: CALL_OW 72
58001: AND
58002: PUSH
58003: LD_EXP 64
58007: PUSH
58008: LD_VAR 0 1
58012: ARRAY
58013: AND
58014: IFFALSE 58622
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58016: LD_ADDR_EXP 101
58020: PUSH
58021: LD_EXP 101
58025: PPUSH
58026: LD_VAR 0 1
58030: PPUSH
58031: LD_INT 5
58033: PPUSH
58034: CALL_OW 1
58038: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58039: LD_ADDR_VAR 0 2
58043: PUSH
58044: LD_INT 0
58046: PUSH
58047: LD_INT 0
58049: PUSH
58050: LD_INT 0
58052: PUSH
58053: LD_INT 0
58055: PUSH
58056: EMPTY
58057: LIST
58058: LIST
58059: LIST
58060: LIST
58061: ST_TO_ADDR
// if sci > 1 then
58062: LD_VAR 0 8
58066: PUSH
58067: LD_INT 1
58069: GREATER
58070: IFFALSE 58098
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
58072: LD_ADDR_VAR 0 4
58076: PUSH
58077: LD_VAR 0 4
58081: PUSH
58082: LD_VAR 0 8
58086: PUSH
58087: LD_VAR 0 8
58091: PUSH
58092: LD_INT 1
58094: ARRAY
58095: DIFF
58096: DIFF
58097: ST_TO_ADDR
// if tmp and not sci then
58098: LD_VAR 0 4
58102: PUSH
58103: LD_VAR 0 8
58107: NOT
58108: AND
58109: IFFALSE 58178
// begin sort := SortBySkill ( tmp , 4 ) ;
58111: LD_ADDR_VAR 0 9
58115: PUSH
58116: LD_VAR 0 4
58120: PPUSH
58121: LD_INT 4
58123: PPUSH
58124: CALL 48787 0 2
58128: ST_TO_ADDR
// if sort then
58129: LD_VAR 0 9
58133: IFFALSE 58149
// p := sort [ 1 ] ;
58135: LD_ADDR_VAR 0 11
58139: PUSH
58140: LD_VAR 0 9
58144: PUSH
58145: LD_INT 1
58147: ARRAY
58148: ST_TO_ADDR
// if p then
58149: LD_VAR 0 11
58153: IFFALSE 58178
// result := Replace ( result , 4 , p ) ;
58155: LD_ADDR_VAR 0 2
58159: PUSH
58160: LD_VAR 0 2
58164: PPUSH
58165: LD_INT 4
58167: PPUSH
58168: LD_VAR 0 11
58172: PPUSH
58173: CALL_OW 1
58177: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58178: LD_ADDR_VAR 0 4
58182: PUSH
58183: LD_VAR 0 4
58187: PUSH
58188: LD_VAR 0 7
58192: DIFF
58193: ST_TO_ADDR
// if tmp and mech < 6 then
58194: LD_VAR 0 4
58198: PUSH
58199: LD_VAR 0 7
58203: PUSH
58204: LD_INT 6
58206: LESS
58207: AND
58208: IFFALSE 58396
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58210: LD_ADDR_VAR 0 9
58214: PUSH
58215: LD_VAR 0 4
58219: PUSH
58220: LD_VAR 0 8
58224: PUSH
58225: LD_VAR 0 7
58229: UNION
58230: DIFF
58231: PPUSH
58232: LD_INT 3
58234: PPUSH
58235: CALL 48787 0 2
58239: ST_TO_ADDR
// p := [ ] ;
58240: LD_ADDR_VAR 0 11
58244: PUSH
58245: EMPTY
58246: ST_TO_ADDR
// if sort then
58247: LD_VAR 0 9
58251: IFFALSE 58367
// for i = 1 to 6 - mech do
58253: LD_ADDR_VAR 0 3
58257: PUSH
58258: DOUBLE
58259: LD_INT 1
58261: DEC
58262: ST_TO_ADDR
58263: LD_INT 6
58265: PUSH
58266: LD_VAR 0 7
58270: MINUS
58271: PUSH
58272: FOR_TO
58273: IFFALSE 58365
// begin if i = sort then
58275: LD_VAR 0 3
58279: PUSH
58280: LD_VAR 0 9
58284: EQUAL
58285: IFFALSE 58289
// break ;
58287: GO 58365
// if GetClass ( i ) = 3 then
58289: LD_VAR 0 3
58293: PPUSH
58294: CALL_OW 257
58298: PUSH
58299: LD_INT 3
58301: EQUAL
58302: IFFALSE 58306
// continue ;
58304: GO 58272
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58306: LD_ADDR_VAR 0 11
58310: PUSH
58311: LD_VAR 0 11
58315: PPUSH
58316: LD_VAR 0 11
58320: PUSH
58321: LD_INT 1
58323: PLUS
58324: PPUSH
58325: LD_VAR 0 9
58329: PUSH
58330: LD_VAR 0 3
58334: ARRAY
58335: PPUSH
58336: CALL_OW 2
58340: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58341: LD_ADDR_VAR 0 4
58345: PUSH
58346: LD_VAR 0 4
58350: PUSH
58351: LD_VAR 0 9
58355: PUSH
58356: LD_VAR 0 3
58360: ARRAY
58361: DIFF
58362: ST_TO_ADDR
// end ;
58363: GO 58272
58365: POP
58366: POP
// if p then
58367: LD_VAR 0 11
58371: IFFALSE 58396
// result := Replace ( result , 3 , p ) ;
58373: LD_ADDR_VAR 0 2
58377: PUSH
58378: LD_VAR 0 2
58382: PPUSH
58383: LD_INT 3
58385: PPUSH
58386: LD_VAR 0 11
58390: PPUSH
58391: CALL_OW 1
58395: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58396: LD_ADDR_VAR 0 4
58400: PUSH
58401: LD_VAR 0 4
58405: PUSH
58406: LD_VAR 0 6
58410: DIFF
58411: ST_TO_ADDR
// if tmp and eng < 6 then
58412: LD_VAR 0 4
58416: PUSH
58417: LD_VAR 0 6
58421: PUSH
58422: LD_INT 6
58424: LESS
58425: AND
58426: IFFALSE 58620
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58428: LD_ADDR_VAR 0 9
58432: PUSH
58433: LD_VAR 0 4
58437: PUSH
58438: LD_VAR 0 8
58442: PUSH
58443: LD_VAR 0 7
58447: UNION
58448: PUSH
58449: LD_VAR 0 6
58453: UNION
58454: DIFF
58455: PPUSH
58456: LD_INT 2
58458: PPUSH
58459: CALL 48787 0 2
58463: ST_TO_ADDR
// p := [ ] ;
58464: LD_ADDR_VAR 0 11
58468: PUSH
58469: EMPTY
58470: ST_TO_ADDR
// if sort then
58471: LD_VAR 0 9
58475: IFFALSE 58591
// for i = 1 to 6 - eng do
58477: LD_ADDR_VAR 0 3
58481: PUSH
58482: DOUBLE
58483: LD_INT 1
58485: DEC
58486: ST_TO_ADDR
58487: LD_INT 6
58489: PUSH
58490: LD_VAR 0 6
58494: MINUS
58495: PUSH
58496: FOR_TO
58497: IFFALSE 58589
// begin if i = sort then
58499: LD_VAR 0 3
58503: PUSH
58504: LD_VAR 0 9
58508: EQUAL
58509: IFFALSE 58513
// break ;
58511: GO 58589
// if GetClass ( i ) = 2 then
58513: LD_VAR 0 3
58517: PPUSH
58518: CALL_OW 257
58522: PUSH
58523: LD_INT 2
58525: EQUAL
58526: IFFALSE 58530
// continue ;
58528: GO 58496
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58530: LD_ADDR_VAR 0 11
58534: PUSH
58535: LD_VAR 0 11
58539: PPUSH
58540: LD_VAR 0 11
58544: PUSH
58545: LD_INT 1
58547: PLUS
58548: PPUSH
58549: LD_VAR 0 9
58553: PUSH
58554: LD_VAR 0 3
58558: ARRAY
58559: PPUSH
58560: CALL_OW 2
58564: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58565: LD_ADDR_VAR 0 4
58569: PUSH
58570: LD_VAR 0 4
58574: PUSH
58575: LD_VAR 0 9
58579: PUSH
58580: LD_VAR 0 3
58584: ARRAY
58585: DIFF
58586: ST_TO_ADDR
// end ;
58587: GO 58496
58589: POP
58590: POP
// if p then
58591: LD_VAR 0 11
58595: IFFALSE 58620
// result := Replace ( result , 2 , p ) ;
58597: LD_ADDR_VAR 0 2
58601: PUSH
58602: LD_VAR 0 2
58606: PPUSH
58607: LD_INT 2
58609: PPUSH
58610: LD_VAR 0 11
58614: PPUSH
58615: CALL_OW 1
58619: ST_TO_ADDR
// end ; exit ;
58620: GO 59344
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58622: LD_EXP 86
58626: PUSH
58627: LD_EXP 85
58631: PUSH
58632: LD_VAR 0 1
58636: ARRAY
58637: ARRAY
58638: NOT
58639: PUSH
58640: LD_EXP 59
58644: PUSH
58645: LD_VAR 0 1
58649: ARRAY
58650: PPUSH
58651: LD_INT 30
58653: PUSH
58654: LD_INT 3
58656: PUSH
58657: EMPTY
58658: LIST
58659: LIST
58660: PPUSH
58661: CALL_OW 72
58665: AND
58666: PUSH
58667: LD_EXP 64
58671: PUSH
58672: LD_VAR 0 1
58676: ARRAY
58677: NOT
58678: AND
58679: IFFALSE 59344
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58681: LD_ADDR_EXP 101
58685: PUSH
58686: LD_EXP 101
58690: PPUSH
58691: LD_VAR 0 1
58695: PPUSH
58696: LD_INT 6
58698: PPUSH
58699: CALL_OW 1
58703: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58704: LD_ADDR_VAR 0 2
58708: PUSH
58709: LD_INT 0
58711: PUSH
58712: LD_INT 0
58714: PUSH
58715: LD_INT 0
58717: PUSH
58718: LD_INT 0
58720: PUSH
58721: EMPTY
58722: LIST
58723: LIST
58724: LIST
58725: LIST
58726: ST_TO_ADDR
// if sci >= 1 then
58727: LD_VAR 0 8
58731: PUSH
58732: LD_INT 1
58734: GREATEREQUAL
58735: IFFALSE 58757
// tmp := tmp diff sci [ 1 ] ;
58737: LD_ADDR_VAR 0 4
58741: PUSH
58742: LD_VAR 0 4
58746: PUSH
58747: LD_VAR 0 8
58751: PUSH
58752: LD_INT 1
58754: ARRAY
58755: DIFF
58756: ST_TO_ADDR
// if tmp and not sci then
58757: LD_VAR 0 4
58761: PUSH
58762: LD_VAR 0 8
58766: NOT
58767: AND
58768: IFFALSE 58837
// begin sort := SortBySkill ( tmp , 4 ) ;
58770: LD_ADDR_VAR 0 9
58774: PUSH
58775: LD_VAR 0 4
58779: PPUSH
58780: LD_INT 4
58782: PPUSH
58783: CALL 48787 0 2
58787: ST_TO_ADDR
// if sort then
58788: LD_VAR 0 9
58792: IFFALSE 58808
// p := sort [ 1 ] ;
58794: LD_ADDR_VAR 0 11
58798: PUSH
58799: LD_VAR 0 9
58803: PUSH
58804: LD_INT 1
58806: ARRAY
58807: ST_TO_ADDR
// if p then
58808: LD_VAR 0 11
58812: IFFALSE 58837
// result := Replace ( result , 4 , p ) ;
58814: LD_ADDR_VAR 0 2
58818: PUSH
58819: LD_VAR 0 2
58823: PPUSH
58824: LD_INT 4
58826: PPUSH
58827: LD_VAR 0 11
58831: PPUSH
58832: CALL_OW 1
58836: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58837: LD_ADDR_VAR 0 4
58841: PUSH
58842: LD_VAR 0 4
58846: PUSH
58847: LD_VAR 0 7
58851: DIFF
58852: ST_TO_ADDR
// if tmp and mech < 6 then
58853: LD_VAR 0 4
58857: PUSH
58858: LD_VAR 0 7
58862: PUSH
58863: LD_INT 6
58865: LESS
58866: AND
58867: IFFALSE 59049
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
58869: LD_ADDR_VAR 0 9
58873: PUSH
58874: LD_VAR 0 4
58878: PUSH
58879: LD_VAR 0 7
58883: DIFF
58884: PPUSH
58885: LD_INT 3
58887: PPUSH
58888: CALL 48787 0 2
58892: ST_TO_ADDR
// p := [ ] ;
58893: LD_ADDR_VAR 0 11
58897: PUSH
58898: EMPTY
58899: ST_TO_ADDR
// if sort then
58900: LD_VAR 0 9
58904: IFFALSE 59020
// for i = 1 to 6 - mech do
58906: LD_ADDR_VAR 0 3
58910: PUSH
58911: DOUBLE
58912: LD_INT 1
58914: DEC
58915: ST_TO_ADDR
58916: LD_INT 6
58918: PUSH
58919: LD_VAR 0 7
58923: MINUS
58924: PUSH
58925: FOR_TO
58926: IFFALSE 59018
// begin if i = sort then
58928: LD_VAR 0 3
58932: PUSH
58933: LD_VAR 0 9
58937: EQUAL
58938: IFFALSE 58942
// break ;
58940: GO 59018
// if GetClass ( i ) = 3 then
58942: LD_VAR 0 3
58946: PPUSH
58947: CALL_OW 257
58951: PUSH
58952: LD_INT 3
58954: EQUAL
58955: IFFALSE 58959
// continue ;
58957: GO 58925
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58959: LD_ADDR_VAR 0 11
58963: PUSH
58964: LD_VAR 0 11
58968: PPUSH
58969: LD_VAR 0 11
58973: PUSH
58974: LD_INT 1
58976: PLUS
58977: PPUSH
58978: LD_VAR 0 9
58982: PUSH
58983: LD_VAR 0 3
58987: ARRAY
58988: PPUSH
58989: CALL_OW 2
58993: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58994: LD_ADDR_VAR 0 4
58998: PUSH
58999: LD_VAR 0 4
59003: PUSH
59004: LD_VAR 0 9
59008: PUSH
59009: LD_VAR 0 3
59013: ARRAY
59014: DIFF
59015: ST_TO_ADDR
// end ;
59016: GO 58925
59018: POP
59019: POP
// if p then
59020: LD_VAR 0 11
59024: IFFALSE 59049
// result := Replace ( result , 3 , p ) ;
59026: LD_ADDR_VAR 0 2
59030: PUSH
59031: LD_VAR 0 2
59035: PPUSH
59036: LD_INT 3
59038: PPUSH
59039: LD_VAR 0 11
59043: PPUSH
59044: CALL_OW 1
59048: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59049: LD_ADDR_VAR 0 4
59053: PUSH
59054: LD_VAR 0 4
59058: PUSH
59059: LD_VAR 0 6
59063: DIFF
59064: ST_TO_ADDR
// if tmp and eng < 4 then
59065: LD_VAR 0 4
59069: PUSH
59070: LD_VAR 0 6
59074: PUSH
59075: LD_INT 4
59077: LESS
59078: AND
59079: IFFALSE 59269
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
59081: LD_ADDR_VAR 0 9
59085: PUSH
59086: LD_VAR 0 4
59090: PUSH
59091: LD_VAR 0 7
59095: PUSH
59096: LD_VAR 0 6
59100: UNION
59101: DIFF
59102: PPUSH
59103: LD_INT 2
59105: PPUSH
59106: CALL 48787 0 2
59110: ST_TO_ADDR
// p := [ ] ;
59111: LD_ADDR_VAR 0 11
59115: PUSH
59116: EMPTY
59117: ST_TO_ADDR
// if sort then
59118: LD_VAR 0 9
59122: IFFALSE 59238
// for i = 1 to 4 - eng do
59124: LD_ADDR_VAR 0 3
59128: PUSH
59129: DOUBLE
59130: LD_INT 1
59132: DEC
59133: ST_TO_ADDR
59134: LD_INT 4
59136: PUSH
59137: LD_VAR 0 6
59141: MINUS
59142: PUSH
59143: FOR_TO
59144: IFFALSE 59236
// begin if i = sort then
59146: LD_VAR 0 3
59150: PUSH
59151: LD_VAR 0 9
59155: EQUAL
59156: IFFALSE 59160
// break ;
59158: GO 59236
// if GetClass ( i ) = 2 then
59160: LD_VAR 0 3
59164: PPUSH
59165: CALL_OW 257
59169: PUSH
59170: LD_INT 2
59172: EQUAL
59173: IFFALSE 59177
// continue ;
59175: GO 59143
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59177: LD_ADDR_VAR 0 11
59181: PUSH
59182: LD_VAR 0 11
59186: PPUSH
59187: LD_VAR 0 11
59191: PUSH
59192: LD_INT 1
59194: PLUS
59195: PPUSH
59196: LD_VAR 0 9
59200: PUSH
59201: LD_VAR 0 3
59205: ARRAY
59206: PPUSH
59207: CALL_OW 2
59211: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59212: LD_ADDR_VAR 0 4
59216: PUSH
59217: LD_VAR 0 4
59221: PUSH
59222: LD_VAR 0 9
59226: PUSH
59227: LD_VAR 0 3
59231: ARRAY
59232: DIFF
59233: ST_TO_ADDR
// end ;
59234: GO 59143
59236: POP
59237: POP
// if p then
59238: LD_VAR 0 11
59242: IFFALSE 59267
// result := Replace ( result , 2 , p ) ;
59244: LD_ADDR_VAR 0 2
59248: PUSH
59249: LD_VAR 0 2
59253: PPUSH
59254: LD_INT 2
59256: PPUSH
59257: LD_VAR 0 11
59261: PPUSH
59262: CALL_OW 1
59266: ST_TO_ADDR
// end else
59267: GO 59313
// for i = eng downto 5 do
59269: LD_ADDR_VAR 0 3
59273: PUSH
59274: DOUBLE
59275: LD_VAR 0 6
59279: INC
59280: ST_TO_ADDR
59281: LD_INT 5
59283: PUSH
59284: FOR_DOWNTO
59285: IFFALSE 59311
// tmp := tmp union eng [ i ] ;
59287: LD_ADDR_VAR 0 4
59291: PUSH
59292: LD_VAR 0 4
59296: PUSH
59297: LD_VAR 0 6
59301: PUSH
59302: LD_VAR 0 3
59306: ARRAY
59307: UNION
59308: ST_TO_ADDR
59309: GO 59284
59311: POP
59312: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
59313: LD_ADDR_VAR 0 2
59317: PUSH
59318: LD_VAR 0 2
59322: PPUSH
59323: LD_INT 1
59325: PPUSH
59326: LD_VAR 0 4
59330: PUSH
59331: LD_VAR 0 5
59335: DIFF
59336: PPUSH
59337: CALL_OW 1
59341: ST_TO_ADDR
// exit ;
59342: GO 59344
// end ; end ;
59344: LD_VAR 0 2
59348: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
59349: LD_INT 0
59351: PPUSH
59352: PPUSH
59353: PPUSH
// if not mc_bases then
59354: LD_EXP 59
59358: NOT
59359: IFFALSE 59363
// exit ;
59361: GO 59469
// for i = 1 to mc_bases do
59363: LD_ADDR_VAR 0 2
59367: PUSH
59368: DOUBLE
59369: LD_INT 1
59371: DEC
59372: ST_TO_ADDR
59373: LD_EXP 59
59377: PUSH
59378: FOR_TO
59379: IFFALSE 59460
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59381: LD_ADDR_VAR 0 3
59385: PUSH
59386: LD_EXP 59
59390: PUSH
59391: LD_VAR 0 2
59395: ARRAY
59396: PPUSH
59397: LD_INT 21
59399: PUSH
59400: LD_INT 3
59402: PUSH
59403: EMPTY
59404: LIST
59405: LIST
59406: PUSH
59407: LD_INT 3
59409: PUSH
59410: LD_INT 24
59412: PUSH
59413: LD_INT 1000
59415: PUSH
59416: EMPTY
59417: LIST
59418: LIST
59419: PUSH
59420: EMPTY
59421: LIST
59422: LIST
59423: PUSH
59424: EMPTY
59425: LIST
59426: LIST
59427: PPUSH
59428: CALL_OW 72
59432: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59433: LD_ADDR_EXP 60
59437: PUSH
59438: LD_EXP 60
59442: PPUSH
59443: LD_VAR 0 2
59447: PPUSH
59448: LD_VAR 0 3
59452: PPUSH
59453: CALL_OW 1
59457: ST_TO_ADDR
// end ;
59458: GO 59378
59460: POP
59461: POP
// RaiseSailEvent ( 101 ) ;
59462: LD_INT 101
59464: PPUSH
59465: CALL_OW 427
// end ;
59469: LD_VAR 0 1
59473: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59474: LD_INT 0
59476: PPUSH
59477: PPUSH
59478: PPUSH
59479: PPUSH
59480: PPUSH
59481: PPUSH
59482: PPUSH
// if not mc_bases then
59483: LD_EXP 59
59487: NOT
59488: IFFALSE 59492
// exit ;
59490: GO 60054
// for i = 1 to mc_bases do
59492: LD_ADDR_VAR 0 2
59496: PUSH
59497: DOUBLE
59498: LD_INT 1
59500: DEC
59501: ST_TO_ADDR
59502: LD_EXP 59
59506: PUSH
59507: FOR_TO
59508: IFFALSE 60045
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
59510: LD_ADDR_VAR 0 5
59514: PUSH
59515: LD_EXP 59
59519: PUSH
59520: LD_VAR 0 2
59524: ARRAY
59525: PUSH
59526: LD_EXP 88
59530: PUSH
59531: LD_VAR 0 2
59535: ARRAY
59536: UNION
59537: PPUSH
59538: LD_INT 21
59540: PUSH
59541: LD_INT 1
59543: PUSH
59544: EMPTY
59545: LIST
59546: LIST
59547: PUSH
59548: LD_INT 1
59550: PUSH
59551: LD_INT 3
59553: PUSH
59554: LD_INT 54
59556: PUSH
59557: EMPTY
59558: LIST
59559: PUSH
59560: EMPTY
59561: LIST
59562: LIST
59563: PUSH
59564: LD_INT 3
59566: PUSH
59567: LD_INT 24
59569: PUSH
59570: LD_INT 800
59572: PUSH
59573: EMPTY
59574: LIST
59575: LIST
59576: PUSH
59577: EMPTY
59578: LIST
59579: LIST
59580: PUSH
59581: EMPTY
59582: LIST
59583: LIST
59584: LIST
59585: PUSH
59586: EMPTY
59587: LIST
59588: LIST
59589: PPUSH
59590: CALL_OW 72
59594: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59595: LD_ADDR_VAR 0 6
59599: PUSH
59600: LD_EXP 59
59604: PUSH
59605: LD_VAR 0 2
59609: ARRAY
59610: PPUSH
59611: LD_INT 21
59613: PUSH
59614: LD_INT 1
59616: PUSH
59617: EMPTY
59618: LIST
59619: LIST
59620: PUSH
59621: LD_INT 1
59623: PUSH
59624: LD_INT 3
59626: PUSH
59627: LD_INT 54
59629: PUSH
59630: EMPTY
59631: LIST
59632: PUSH
59633: EMPTY
59634: LIST
59635: LIST
59636: PUSH
59637: LD_INT 3
59639: PUSH
59640: LD_INT 24
59642: PUSH
59643: LD_INT 250
59645: PUSH
59646: EMPTY
59647: LIST
59648: LIST
59649: PUSH
59650: EMPTY
59651: LIST
59652: LIST
59653: PUSH
59654: EMPTY
59655: LIST
59656: LIST
59657: LIST
59658: PUSH
59659: EMPTY
59660: LIST
59661: LIST
59662: PPUSH
59663: CALL_OW 72
59667: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59668: LD_ADDR_VAR 0 7
59672: PUSH
59673: LD_VAR 0 5
59677: PUSH
59678: LD_VAR 0 6
59682: DIFF
59683: ST_TO_ADDR
// if not need_heal_1 then
59684: LD_VAR 0 6
59688: NOT
59689: IFFALSE 59722
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59691: LD_ADDR_EXP 62
59695: PUSH
59696: LD_EXP 62
59700: PPUSH
59701: LD_VAR 0 2
59705: PUSH
59706: LD_INT 1
59708: PUSH
59709: EMPTY
59710: LIST
59711: LIST
59712: PPUSH
59713: EMPTY
59714: PPUSH
59715: CALL 19238 0 3
59719: ST_TO_ADDR
59720: GO 59792
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
59722: LD_ADDR_EXP 62
59726: PUSH
59727: LD_EXP 62
59731: PPUSH
59732: LD_VAR 0 2
59736: PUSH
59737: LD_INT 1
59739: PUSH
59740: EMPTY
59741: LIST
59742: LIST
59743: PPUSH
59744: LD_EXP 62
59748: PUSH
59749: LD_VAR 0 2
59753: ARRAY
59754: PUSH
59755: LD_INT 1
59757: ARRAY
59758: PPUSH
59759: LD_INT 3
59761: PUSH
59762: LD_INT 24
59764: PUSH
59765: LD_INT 1000
59767: PUSH
59768: EMPTY
59769: LIST
59770: LIST
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: PPUSH
59776: CALL_OW 72
59780: PUSH
59781: LD_VAR 0 6
59785: UNION
59786: PPUSH
59787: CALL 19238 0 3
59791: ST_TO_ADDR
// if not need_heal_2 then
59792: LD_VAR 0 7
59796: NOT
59797: IFFALSE 59830
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
59799: LD_ADDR_EXP 62
59803: PUSH
59804: LD_EXP 62
59808: PPUSH
59809: LD_VAR 0 2
59813: PUSH
59814: LD_INT 2
59816: PUSH
59817: EMPTY
59818: LIST
59819: LIST
59820: PPUSH
59821: EMPTY
59822: PPUSH
59823: CALL 19238 0 3
59827: ST_TO_ADDR
59828: GO 59862
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
59830: LD_ADDR_EXP 62
59834: PUSH
59835: LD_EXP 62
59839: PPUSH
59840: LD_VAR 0 2
59844: PUSH
59845: LD_INT 2
59847: PUSH
59848: EMPTY
59849: LIST
59850: LIST
59851: PPUSH
59852: LD_VAR 0 7
59856: PPUSH
59857: CALL 19238 0 3
59861: ST_TO_ADDR
// if need_heal_2 then
59862: LD_VAR 0 7
59866: IFFALSE 60027
// for j in need_heal_2 do
59868: LD_ADDR_VAR 0 3
59872: PUSH
59873: LD_VAR 0 7
59877: PUSH
59878: FOR_IN
59879: IFFALSE 60025
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59881: LD_ADDR_VAR 0 5
59885: PUSH
59886: LD_EXP 59
59890: PUSH
59891: LD_VAR 0 2
59895: ARRAY
59896: PPUSH
59897: LD_INT 2
59899: PUSH
59900: LD_INT 30
59902: PUSH
59903: LD_INT 6
59905: PUSH
59906: EMPTY
59907: LIST
59908: LIST
59909: PUSH
59910: LD_INT 30
59912: PUSH
59913: LD_INT 7
59915: PUSH
59916: EMPTY
59917: LIST
59918: LIST
59919: PUSH
59920: LD_INT 30
59922: PUSH
59923: LD_INT 8
59925: PUSH
59926: EMPTY
59927: LIST
59928: LIST
59929: PUSH
59930: LD_INT 30
59932: PUSH
59933: LD_INT 0
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: PUSH
59940: LD_INT 30
59942: PUSH
59943: LD_INT 1
59945: PUSH
59946: EMPTY
59947: LIST
59948: LIST
59949: PUSH
59950: EMPTY
59951: LIST
59952: LIST
59953: LIST
59954: LIST
59955: LIST
59956: LIST
59957: PPUSH
59958: CALL_OW 72
59962: ST_TO_ADDR
// if tmp then
59963: LD_VAR 0 5
59967: IFFALSE 60023
// begin k := NearestUnitToUnit ( tmp , j ) ;
59969: LD_ADDR_VAR 0 4
59973: PUSH
59974: LD_VAR 0 5
59978: PPUSH
59979: LD_VAR 0 3
59983: PPUSH
59984: CALL_OW 74
59988: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
59989: LD_VAR 0 3
59993: PPUSH
59994: LD_VAR 0 4
59998: PPUSH
59999: CALL_OW 296
60003: PUSH
60004: LD_INT 5
60006: GREATER
60007: IFFALSE 60023
// ComMoveUnit ( j , k ) ;
60009: LD_VAR 0 3
60013: PPUSH
60014: LD_VAR 0 4
60018: PPUSH
60019: CALL_OW 112
// end ; end ;
60023: GO 59878
60025: POP
60026: POP
// if not need_heal_1 and not need_heal_2 then
60027: LD_VAR 0 6
60031: NOT
60032: PUSH
60033: LD_VAR 0 7
60037: NOT
60038: AND
60039: IFFALSE 60043
// continue ;
60041: GO 59507
// end ;
60043: GO 59507
60045: POP
60046: POP
// RaiseSailEvent ( 102 ) ;
60047: LD_INT 102
60049: PPUSH
60050: CALL_OW 427
// end ;
60054: LD_VAR 0 1
60058: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
60059: LD_INT 0
60061: PPUSH
60062: PPUSH
60063: PPUSH
60064: PPUSH
60065: PPUSH
60066: PPUSH
60067: PPUSH
60068: PPUSH
// if not mc_bases then
60069: LD_EXP 59
60073: NOT
60074: IFFALSE 60078
// exit ;
60076: GO 60913
// for i = 1 to mc_bases do
60078: LD_ADDR_VAR 0 2
60082: PUSH
60083: DOUBLE
60084: LD_INT 1
60086: DEC
60087: ST_TO_ADDR
60088: LD_EXP 59
60092: PUSH
60093: FOR_TO
60094: IFFALSE 60911
// begin if not mc_building_need_repair [ i ] then
60096: LD_EXP 60
60100: PUSH
60101: LD_VAR 0 2
60105: ARRAY
60106: NOT
60107: IFFALSE 60281
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
60109: LD_ADDR_VAR 0 6
60113: PUSH
60114: LD_EXP 78
60118: PUSH
60119: LD_VAR 0 2
60123: ARRAY
60124: PPUSH
60125: LD_INT 3
60127: PUSH
60128: LD_INT 24
60130: PUSH
60131: LD_INT 1000
60133: PUSH
60134: EMPTY
60135: LIST
60136: LIST
60137: PUSH
60138: EMPTY
60139: LIST
60140: LIST
60141: PUSH
60142: LD_INT 2
60144: PUSH
60145: LD_INT 34
60147: PUSH
60148: LD_INT 13
60150: PUSH
60151: EMPTY
60152: LIST
60153: LIST
60154: PUSH
60155: LD_INT 34
60157: PUSH
60158: LD_INT 52
60160: PUSH
60161: EMPTY
60162: LIST
60163: LIST
60164: PUSH
60165: EMPTY
60166: LIST
60167: LIST
60168: LIST
60169: PUSH
60170: EMPTY
60171: LIST
60172: LIST
60173: PPUSH
60174: CALL_OW 72
60178: ST_TO_ADDR
// if cranes then
60179: LD_VAR 0 6
60183: IFFALSE 60245
// for j in cranes do
60185: LD_ADDR_VAR 0 3
60189: PUSH
60190: LD_VAR 0 6
60194: PUSH
60195: FOR_IN
60196: IFFALSE 60243
// if not IsInArea ( j , mc_parking [ i ] ) then
60198: LD_VAR 0 3
60202: PPUSH
60203: LD_EXP 83
60207: PUSH
60208: LD_VAR 0 2
60212: ARRAY
60213: PPUSH
60214: CALL_OW 308
60218: NOT
60219: IFFALSE 60241
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60221: LD_VAR 0 3
60225: PPUSH
60226: LD_EXP 83
60230: PUSH
60231: LD_VAR 0 2
60235: ARRAY
60236: PPUSH
60237: CALL_OW 113
60241: GO 60195
60243: POP
60244: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60245: LD_ADDR_EXP 61
60249: PUSH
60250: LD_EXP 61
60254: PPUSH
60255: LD_VAR 0 2
60259: PPUSH
60260: EMPTY
60261: PPUSH
60262: CALL_OW 1
60266: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
60267: LD_VAR 0 2
60271: PPUSH
60272: LD_INT 101
60274: PPUSH
60275: CALL 55182 0 2
// continue ;
60279: GO 60093
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
60281: LD_ADDR_EXP 65
60285: PUSH
60286: LD_EXP 65
60290: PPUSH
60291: LD_VAR 0 2
60295: PPUSH
60296: EMPTY
60297: PPUSH
60298: CALL_OW 1
60302: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60303: LD_VAR 0 2
60307: PPUSH
60308: LD_INT 103
60310: PPUSH
60311: CALL 55182 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
60315: LD_ADDR_VAR 0 5
60319: PUSH
60320: LD_EXP 59
60324: PUSH
60325: LD_VAR 0 2
60329: ARRAY
60330: PUSH
60331: LD_EXP 88
60335: PUSH
60336: LD_VAR 0 2
60340: ARRAY
60341: UNION
60342: PPUSH
60343: LD_INT 2
60345: PUSH
60346: LD_INT 25
60348: PUSH
60349: LD_INT 2
60351: PUSH
60352: EMPTY
60353: LIST
60354: LIST
60355: PUSH
60356: LD_INT 25
60358: PUSH
60359: LD_INT 16
60361: PUSH
60362: EMPTY
60363: LIST
60364: LIST
60365: PUSH
60366: EMPTY
60367: LIST
60368: LIST
60369: LIST
60370: PUSH
60371: EMPTY
60372: LIST
60373: PPUSH
60374: CALL_OW 72
60378: PUSH
60379: LD_EXP 62
60383: PUSH
60384: LD_VAR 0 2
60388: ARRAY
60389: PUSH
60390: LD_INT 1
60392: ARRAY
60393: PUSH
60394: LD_EXP 62
60398: PUSH
60399: LD_VAR 0 2
60403: ARRAY
60404: PUSH
60405: LD_INT 2
60407: ARRAY
60408: UNION
60409: DIFF
60410: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
60411: LD_ADDR_VAR 0 6
60415: PUSH
60416: LD_EXP 78
60420: PUSH
60421: LD_VAR 0 2
60425: ARRAY
60426: PPUSH
60427: LD_INT 2
60429: PUSH
60430: LD_INT 34
60432: PUSH
60433: LD_INT 13
60435: PUSH
60436: EMPTY
60437: LIST
60438: LIST
60439: PUSH
60440: LD_INT 34
60442: PUSH
60443: LD_INT 52
60445: PUSH
60446: EMPTY
60447: LIST
60448: LIST
60449: PUSH
60450: EMPTY
60451: LIST
60452: LIST
60453: LIST
60454: PPUSH
60455: CALL_OW 72
60459: ST_TO_ADDR
// if cranes then
60460: LD_VAR 0 6
60464: IFFALSE 60600
// begin for j in cranes do
60466: LD_ADDR_VAR 0 3
60470: PUSH
60471: LD_VAR 0 6
60475: PUSH
60476: FOR_IN
60477: IFFALSE 60598
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
60479: LD_VAR 0 3
60483: PPUSH
60484: CALL_OW 256
60488: PUSH
60489: LD_INT 500
60491: GREATEREQUAL
60492: PUSH
60493: LD_VAR 0 3
60497: PPUSH
60498: CALL_OW 314
60502: NOT
60503: AND
60504: IFFALSE 60538
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
60506: LD_VAR 0 3
60510: PPUSH
60511: LD_EXP 60
60515: PUSH
60516: LD_VAR 0 2
60520: ARRAY
60521: PPUSH
60522: LD_VAR 0 3
60526: PPUSH
60527: CALL_OW 74
60531: PPUSH
60532: CALL_OW 130
60536: GO 60596
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60538: LD_VAR 0 3
60542: PPUSH
60543: CALL_OW 256
60547: PUSH
60548: LD_INT 500
60550: LESS
60551: PUSH
60552: LD_VAR 0 3
60556: PPUSH
60557: LD_EXP 83
60561: PUSH
60562: LD_VAR 0 2
60566: ARRAY
60567: PPUSH
60568: CALL_OW 308
60572: NOT
60573: AND
60574: IFFALSE 60596
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60576: LD_VAR 0 3
60580: PPUSH
60581: LD_EXP 83
60585: PUSH
60586: LD_VAR 0 2
60590: ARRAY
60591: PPUSH
60592: CALL_OW 113
60596: GO 60476
60598: POP
60599: POP
// end ; if tmp > 3 then
60600: LD_VAR 0 5
60604: PUSH
60605: LD_INT 3
60607: GREATER
60608: IFFALSE 60628
// tmp := ShrinkArray ( tmp , 4 ) ;
60610: LD_ADDR_VAR 0 5
60614: PUSH
60615: LD_VAR 0 5
60619: PPUSH
60620: LD_INT 4
60622: PPUSH
60623: CALL 50596 0 2
60627: ST_TO_ADDR
// if not tmp then
60628: LD_VAR 0 5
60632: NOT
60633: IFFALSE 60637
// continue ;
60635: GO 60093
// for j in tmp do
60637: LD_ADDR_VAR 0 3
60641: PUSH
60642: LD_VAR 0 5
60646: PUSH
60647: FOR_IN
60648: IFFALSE 60907
// begin if IsInUnit ( j ) then
60650: LD_VAR 0 3
60654: PPUSH
60655: CALL_OW 310
60659: IFFALSE 60670
// ComExitBuilding ( j ) ;
60661: LD_VAR 0 3
60665: PPUSH
60666: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
60670: LD_VAR 0 3
60674: PUSH
60675: LD_EXP 61
60679: PUSH
60680: LD_VAR 0 2
60684: ARRAY
60685: IN
60686: NOT
60687: IFFALSE 60745
// begin SetTag ( j , 101 ) ;
60689: LD_VAR 0 3
60693: PPUSH
60694: LD_INT 101
60696: PPUSH
60697: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
60701: LD_ADDR_EXP 61
60705: PUSH
60706: LD_EXP 61
60710: PPUSH
60711: LD_VAR 0 2
60715: PUSH
60716: LD_EXP 61
60720: PUSH
60721: LD_VAR 0 2
60725: ARRAY
60726: PUSH
60727: LD_INT 1
60729: PLUS
60730: PUSH
60731: EMPTY
60732: LIST
60733: LIST
60734: PPUSH
60735: LD_VAR 0 3
60739: PPUSH
60740: CALL 19238 0 3
60744: ST_TO_ADDR
// end ; wait ( 1 ) ;
60745: LD_INT 1
60747: PPUSH
60748: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
60752: LD_ADDR_VAR 0 7
60756: PUSH
60757: LD_EXP 60
60761: PUSH
60762: LD_VAR 0 2
60766: ARRAY
60767: ST_TO_ADDR
// if mc_scan [ i ] then
60768: LD_EXP 82
60772: PUSH
60773: LD_VAR 0 2
60777: ARRAY
60778: IFFALSE 60840
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
60780: LD_ADDR_VAR 0 7
60784: PUSH
60785: LD_EXP 60
60789: PUSH
60790: LD_VAR 0 2
60794: ARRAY
60795: PPUSH
60796: LD_INT 3
60798: PUSH
60799: LD_INT 30
60801: PUSH
60802: LD_INT 32
60804: PUSH
60805: EMPTY
60806: LIST
60807: LIST
60808: PUSH
60809: LD_INT 30
60811: PUSH
60812: LD_INT 33
60814: PUSH
60815: EMPTY
60816: LIST
60817: LIST
60818: PUSH
60819: LD_INT 30
60821: PUSH
60822: LD_INT 31
60824: PUSH
60825: EMPTY
60826: LIST
60827: LIST
60828: PUSH
60829: EMPTY
60830: LIST
60831: LIST
60832: LIST
60833: LIST
60834: PPUSH
60835: CALL_OW 72
60839: ST_TO_ADDR
// if not to_repair_tmp then
60840: LD_VAR 0 7
60844: NOT
60845: IFFALSE 60849
// continue ;
60847: GO 60647
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
60849: LD_ADDR_VAR 0 8
60853: PUSH
60854: LD_VAR 0 7
60858: PPUSH
60859: LD_VAR 0 3
60863: PPUSH
60864: CALL_OW 74
60868: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
60869: LD_VAR 0 8
60873: PPUSH
60874: LD_INT 16
60876: PPUSH
60877: CALL 21831 0 2
60881: PUSH
60882: LD_INT 4
60884: ARRAY
60885: PUSH
60886: LD_INT 5
60888: LESS
60889: IFFALSE 60905
// ComRepairBuilding ( j , to_repair ) ;
60891: LD_VAR 0 3
60895: PPUSH
60896: LD_VAR 0 8
60900: PPUSH
60901: CALL_OW 130
// end ;
60905: GO 60647
60907: POP
60908: POP
// end ;
60909: GO 60093
60911: POP
60912: POP
// end ;
60913: LD_VAR 0 1
60917: RET
// export function MC_Heal ; var i , j , tmp ; begin
60918: LD_INT 0
60920: PPUSH
60921: PPUSH
60922: PPUSH
60923: PPUSH
// if not mc_bases then
60924: LD_EXP 59
60928: NOT
60929: IFFALSE 60933
// exit ;
60931: GO 61335
// for i = 1 to mc_bases do
60933: LD_ADDR_VAR 0 2
60937: PUSH
60938: DOUBLE
60939: LD_INT 1
60941: DEC
60942: ST_TO_ADDR
60943: LD_EXP 59
60947: PUSH
60948: FOR_TO
60949: IFFALSE 61333
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
60951: LD_EXP 62
60955: PUSH
60956: LD_VAR 0 2
60960: ARRAY
60961: PUSH
60962: LD_INT 1
60964: ARRAY
60965: NOT
60966: PUSH
60967: LD_EXP 62
60971: PUSH
60972: LD_VAR 0 2
60976: ARRAY
60977: PUSH
60978: LD_INT 2
60980: ARRAY
60981: NOT
60982: AND
60983: IFFALSE 61021
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
60985: LD_ADDR_EXP 63
60989: PUSH
60990: LD_EXP 63
60994: PPUSH
60995: LD_VAR 0 2
60999: PPUSH
61000: EMPTY
61001: PPUSH
61002: CALL_OW 1
61006: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61007: LD_VAR 0 2
61011: PPUSH
61012: LD_INT 102
61014: PPUSH
61015: CALL 55182 0 2
// continue ;
61019: GO 60948
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61021: LD_ADDR_VAR 0 4
61025: PUSH
61026: LD_EXP 59
61030: PUSH
61031: LD_VAR 0 2
61035: ARRAY
61036: PPUSH
61037: LD_INT 25
61039: PUSH
61040: LD_INT 4
61042: PUSH
61043: EMPTY
61044: LIST
61045: LIST
61046: PPUSH
61047: CALL_OW 72
61051: ST_TO_ADDR
// if not tmp then
61052: LD_VAR 0 4
61056: NOT
61057: IFFALSE 61061
// continue ;
61059: GO 60948
// if mc_taming [ i ] then
61061: LD_EXP 90
61065: PUSH
61066: LD_VAR 0 2
61070: ARRAY
61071: IFFALSE 61095
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61073: LD_ADDR_EXP 90
61077: PUSH
61078: LD_EXP 90
61082: PPUSH
61083: LD_VAR 0 2
61087: PPUSH
61088: EMPTY
61089: PPUSH
61090: CALL_OW 1
61094: ST_TO_ADDR
// for j in tmp do
61095: LD_ADDR_VAR 0 3
61099: PUSH
61100: LD_VAR 0 4
61104: PUSH
61105: FOR_IN
61106: IFFALSE 61329
// begin if IsInUnit ( j ) then
61108: LD_VAR 0 3
61112: PPUSH
61113: CALL_OW 310
61117: IFFALSE 61128
// ComExitBuilding ( j ) ;
61119: LD_VAR 0 3
61123: PPUSH
61124: CALL_OW 122
// if not j in mc_healers [ i ] then
61128: LD_VAR 0 3
61132: PUSH
61133: LD_EXP 63
61137: PUSH
61138: LD_VAR 0 2
61142: ARRAY
61143: IN
61144: NOT
61145: IFFALSE 61191
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
61147: LD_ADDR_EXP 63
61151: PUSH
61152: LD_EXP 63
61156: PPUSH
61157: LD_VAR 0 2
61161: PUSH
61162: LD_EXP 63
61166: PUSH
61167: LD_VAR 0 2
61171: ARRAY
61172: PUSH
61173: LD_INT 1
61175: PLUS
61176: PUSH
61177: EMPTY
61178: LIST
61179: LIST
61180: PPUSH
61181: LD_VAR 0 3
61185: PPUSH
61186: CALL 19238 0 3
61190: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
61191: LD_VAR 0 3
61195: PPUSH
61196: CALL_OW 110
61200: PUSH
61201: LD_INT 102
61203: NONEQUAL
61204: IFFALSE 61218
// SetTag ( j , 102 ) ;
61206: LD_VAR 0 3
61210: PPUSH
61211: LD_INT 102
61213: PPUSH
61214: CALL_OW 109
// Wait ( 3 ) ;
61218: LD_INT 3
61220: PPUSH
61221: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
61225: LD_EXP 62
61229: PUSH
61230: LD_VAR 0 2
61234: ARRAY
61235: PUSH
61236: LD_INT 1
61238: ARRAY
61239: IFFALSE 61271
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
61241: LD_VAR 0 3
61245: PPUSH
61246: LD_EXP 62
61250: PUSH
61251: LD_VAR 0 2
61255: ARRAY
61256: PUSH
61257: LD_INT 1
61259: ARRAY
61260: PUSH
61261: LD_INT 1
61263: ARRAY
61264: PPUSH
61265: CALL_OW 128
61269: GO 61327
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
61271: LD_VAR 0 3
61275: PPUSH
61276: CALL_OW 314
61280: NOT
61281: PUSH
61282: LD_EXP 62
61286: PUSH
61287: LD_VAR 0 2
61291: ARRAY
61292: PUSH
61293: LD_INT 2
61295: ARRAY
61296: AND
61297: IFFALSE 61327
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
61299: LD_VAR 0 3
61303: PPUSH
61304: LD_EXP 62
61308: PUSH
61309: LD_VAR 0 2
61313: ARRAY
61314: PUSH
61315: LD_INT 2
61317: ARRAY
61318: PUSH
61319: LD_INT 1
61321: ARRAY
61322: PPUSH
61323: CALL_OW 128
// end ;
61327: GO 61105
61329: POP
61330: POP
// end ;
61331: GO 60948
61333: POP
61334: POP
// end ;
61335: LD_VAR 0 1
61339: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
61340: LD_INT 0
61342: PPUSH
61343: PPUSH
61344: PPUSH
61345: PPUSH
61346: PPUSH
// if not mc_bases then
61347: LD_EXP 59
61351: NOT
61352: IFFALSE 61356
// exit ;
61354: GO 62499
// for i = 1 to mc_bases do
61356: LD_ADDR_VAR 0 2
61360: PUSH
61361: DOUBLE
61362: LD_INT 1
61364: DEC
61365: ST_TO_ADDR
61366: LD_EXP 59
61370: PUSH
61371: FOR_TO
61372: IFFALSE 62497
// begin if mc_scan [ i ] then
61374: LD_EXP 82
61378: PUSH
61379: LD_VAR 0 2
61383: ARRAY
61384: IFFALSE 61388
// continue ;
61386: GO 61371
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61388: LD_EXP 64
61392: PUSH
61393: LD_VAR 0 2
61397: ARRAY
61398: NOT
61399: PUSH
61400: LD_EXP 66
61404: PUSH
61405: LD_VAR 0 2
61409: ARRAY
61410: NOT
61411: AND
61412: PUSH
61413: LD_EXP 65
61417: PUSH
61418: LD_VAR 0 2
61422: ARRAY
61423: AND
61424: IFFALSE 61462
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61426: LD_ADDR_EXP 65
61430: PUSH
61431: LD_EXP 65
61435: PPUSH
61436: LD_VAR 0 2
61440: PPUSH
61441: EMPTY
61442: PPUSH
61443: CALL_OW 1
61447: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61448: LD_VAR 0 2
61452: PPUSH
61453: LD_INT 103
61455: PPUSH
61456: CALL 55182 0 2
// continue ;
61460: GO 61371
// end ; if mc_construct_list [ i ] then
61462: LD_EXP 66
61466: PUSH
61467: LD_VAR 0 2
61471: ARRAY
61472: IFFALSE 61692
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61474: LD_ADDR_VAR 0 4
61478: PUSH
61479: LD_EXP 59
61483: PUSH
61484: LD_VAR 0 2
61488: ARRAY
61489: PPUSH
61490: LD_INT 25
61492: PUSH
61493: LD_INT 2
61495: PUSH
61496: EMPTY
61497: LIST
61498: LIST
61499: PPUSH
61500: CALL_OW 72
61504: PUSH
61505: LD_EXP 61
61509: PUSH
61510: LD_VAR 0 2
61514: ARRAY
61515: DIFF
61516: ST_TO_ADDR
// if not tmp then
61517: LD_VAR 0 4
61521: NOT
61522: IFFALSE 61526
// continue ;
61524: GO 61371
// for j in tmp do
61526: LD_ADDR_VAR 0 3
61530: PUSH
61531: LD_VAR 0 4
61535: PUSH
61536: FOR_IN
61537: IFFALSE 61688
// begin if not mc_builders [ i ] then
61539: LD_EXP 65
61543: PUSH
61544: LD_VAR 0 2
61548: ARRAY
61549: NOT
61550: IFFALSE 61608
// begin SetTag ( j , 103 ) ;
61552: LD_VAR 0 3
61556: PPUSH
61557: LD_INT 103
61559: PPUSH
61560: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61564: LD_ADDR_EXP 65
61568: PUSH
61569: LD_EXP 65
61573: PPUSH
61574: LD_VAR 0 2
61578: PUSH
61579: LD_EXP 65
61583: PUSH
61584: LD_VAR 0 2
61588: ARRAY
61589: PUSH
61590: LD_INT 1
61592: PLUS
61593: PUSH
61594: EMPTY
61595: LIST
61596: LIST
61597: PPUSH
61598: LD_VAR 0 3
61602: PPUSH
61603: CALL 19238 0 3
61607: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61608: LD_VAR 0 3
61612: PPUSH
61613: CALL_OW 310
61617: IFFALSE 61628
// ComExitBuilding ( j ) ;
61619: LD_VAR 0 3
61623: PPUSH
61624: CALL_OW 122
// wait ( 3 ) ;
61628: LD_INT 3
61630: PPUSH
61631: CALL_OW 67
// if not mc_construct_list [ i ] then
61635: LD_EXP 66
61639: PUSH
61640: LD_VAR 0 2
61644: ARRAY
61645: NOT
61646: IFFALSE 61650
// break ;
61648: GO 61688
// if not HasTask ( j ) then
61650: LD_VAR 0 3
61654: PPUSH
61655: CALL_OW 314
61659: NOT
61660: IFFALSE 61686
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
61662: LD_VAR 0 3
61666: PPUSH
61667: LD_EXP 66
61671: PUSH
61672: LD_VAR 0 2
61676: ARRAY
61677: PUSH
61678: LD_INT 1
61680: ARRAY
61681: PPUSH
61682: CALL 22089 0 2
// end ;
61686: GO 61536
61688: POP
61689: POP
// end else
61690: GO 62495
// if mc_build_list [ i ] then
61692: LD_EXP 64
61696: PUSH
61697: LD_VAR 0 2
61701: ARRAY
61702: IFFALSE 62495
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61704: LD_ADDR_VAR 0 5
61708: PUSH
61709: LD_EXP 59
61713: PUSH
61714: LD_VAR 0 2
61718: ARRAY
61719: PPUSH
61720: LD_INT 2
61722: PUSH
61723: LD_INT 30
61725: PUSH
61726: LD_INT 0
61728: PUSH
61729: EMPTY
61730: LIST
61731: LIST
61732: PUSH
61733: LD_INT 30
61735: PUSH
61736: LD_INT 1
61738: PUSH
61739: EMPTY
61740: LIST
61741: LIST
61742: PUSH
61743: EMPTY
61744: LIST
61745: LIST
61746: LIST
61747: PPUSH
61748: CALL_OW 72
61752: ST_TO_ADDR
// if depot then
61753: LD_VAR 0 5
61757: IFFALSE 61775
// depot := depot [ 1 ] else
61759: LD_ADDR_VAR 0 5
61763: PUSH
61764: LD_VAR 0 5
61768: PUSH
61769: LD_INT 1
61771: ARRAY
61772: ST_TO_ADDR
61773: GO 61783
// depot := 0 ;
61775: LD_ADDR_VAR 0 5
61779: PUSH
61780: LD_INT 0
61782: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
61783: LD_EXP 64
61787: PUSH
61788: LD_VAR 0 2
61792: ARRAY
61793: PUSH
61794: LD_INT 1
61796: ARRAY
61797: PUSH
61798: LD_INT 1
61800: ARRAY
61801: PPUSH
61802: CALL 21919 0 1
61806: PUSH
61807: LD_EXP 59
61811: PUSH
61812: LD_VAR 0 2
61816: ARRAY
61817: PPUSH
61818: LD_INT 2
61820: PUSH
61821: LD_INT 30
61823: PUSH
61824: LD_INT 2
61826: PUSH
61827: EMPTY
61828: LIST
61829: LIST
61830: PUSH
61831: LD_INT 30
61833: PUSH
61834: LD_INT 3
61836: PUSH
61837: EMPTY
61838: LIST
61839: LIST
61840: PUSH
61841: EMPTY
61842: LIST
61843: LIST
61844: LIST
61845: PPUSH
61846: CALL_OW 72
61850: NOT
61851: AND
61852: IFFALSE 61957
// begin for j = 1 to mc_build_list [ i ] do
61854: LD_ADDR_VAR 0 3
61858: PUSH
61859: DOUBLE
61860: LD_INT 1
61862: DEC
61863: ST_TO_ADDR
61864: LD_EXP 64
61868: PUSH
61869: LD_VAR 0 2
61873: ARRAY
61874: PUSH
61875: FOR_TO
61876: IFFALSE 61955
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
61878: LD_EXP 64
61882: PUSH
61883: LD_VAR 0 2
61887: ARRAY
61888: PUSH
61889: LD_VAR 0 3
61893: ARRAY
61894: PUSH
61895: LD_INT 1
61897: ARRAY
61898: PUSH
61899: LD_INT 2
61901: EQUAL
61902: IFFALSE 61953
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
61904: LD_ADDR_EXP 64
61908: PUSH
61909: LD_EXP 64
61913: PPUSH
61914: LD_VAR 0 2
61918: PPUSH
61919: LD_EXP 64
61923: PUSH
61924: LD_VAR 0 2
61928: ARRAY
61929: PPUSH
61930: LD_VAR 0 3
61934: PPUSH
61935: LD_INT 1
61937: PPUSH
61938: LD_INT 0
61940: PPUSH
61941: CALL 18656 0 4
61945: PPUSH
61946: CALL_OW 1
61950: ST_TO_ADDR
// break ;
61951: GO 61955
// end ;
61953: GO 61875
61955: POP
61956: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
61957: LD_EXP 64
61961: PUSH
61962: LD_VAR 0 2
61966: ARRAY
61967: PUSH
61968: LD_INT 1
61970: ARRAY
61971: PUSH
61972: LD_INT 1
61974: ARRAY
61975: PUSH
61976: LD_INT 0
61978: EQUAL
61979: PUSH
61980: LD_VAR 0 5
61984: PUSH
61985: LD_VAR 0 5
61989: PPUSH
61990: LD_EXP 64
61994: PUSH
61995: LD_VAR 0 2
61999: ARRAY
62000: PUSH
62001: LD_INT 1
62003: ARRAY
62004: PUSH
62005: LD_INT 1
62007: ARRAY
62008: PPUSH
62009: LD_EXP 64
62013: PUSH
62014: LD_VAR 0 2
62018: ARRAY
62019: PUSH
62020: LD_INT 1
62022: ARRAY
62023: PUSH
62024: LD_INT 2
62026: ARRAY
62027: PPUSH
62028: LD_EXP 64
62032: PUSH
62033: LD_VAR 0 2
62037: ARRAY
62038: PUSH
62039: LD_INT 1
62041: ARRAY
62042: PUSH
62043: LD_INT 3
62045: ARRAY
62046: PPUSH
62047: LD_EXP 64
62051: PUSH
62052: LD_VAR 0 2
62056: ARRAY
62057: PUSH
62058: LD_INT 1
62060: ARRAY
62061: PUSH
62062: LD_INT 4
62064: ARRAY
62065: PPUSH
62066: CALL 26653 0 5
62070: AND
62071: OR
62072: IFFALSE 62353
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62074: LD_ADDR_VAR 0 4
62078: PUSH
62079: LD_EXP 59
62083: PUSH
62084: LD_VAR 0 2
62088: ARRAY
62089: PPUSH
62090: LD_INT 25
62092: PUSH
62093: LD_INT 2
62095: PUSH
62096: EMPTY
62097: LIST
62098: LIST
62099: PPUSH
62100: CALL_OW 72
62104: PUSH
62105: LD_EXP 61
62109: PUSH
62110: LD_VAR 0 2
62114: ARRAY
62115: DIFF
62116: ST_TO_ADDR
// if not tmp then
62117: LD_VAR 0 4
62121: NOT
62122: IFFALSE 62126
// continue ;
62124: GO 61371
// for j in tmp do
62126: LD_ADDR_VAR 0 3
62130: PUSH
62131: LD_VAR 0 4
62135: PUSH
62136: FOR_IN
62137: IFFALSE 62349
// begin if not mc_builders [ i ] then
62139: LD_EXP 65
62143: PUSH
62144: LD_VAR 0 2
62148: ARRAY
62149: NOT
62150: IFFALSE 62208
// begin SetTag ( j , 103 ) ;
62152: LD_VAR 0 3
62156: PPUSH
62157: LD_INT 103
62159: PPUSH
62160: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62164: LD_ADDR_EXP 65
62168: PUSH
62169: LD_EXP 65
62173: PPUSH
62174: LD_VAR 0 2
62178: PUSH
62179: LD_EXP 65
62183: PUSH
62184: LD_VAR 0 2
62188: ARRAY
62189: PUSH
62190: LD_INT 1
62192: PLUS
62193: PUSH
62194: EMPTY
62195: LIST
62196: LIST
62197: PPUSH
62198: LD_VAR 0 3
62202: PPUSH
62203: CALL 19238 0 3
62207: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62208: LD_VAR 0 3
62212: PPUSH
62213: CALL_OW 310
62217: IFFALSE 62228
// ComExitBuilding ( j ) ;
62219: LD_VAR 0 3
62223: PPUSH
62224: CALL_OW 122
// wait ( 3 ) ;
62228: LD_INT 3
62230: PPUSH
62231: CALL_OW 67
// if not mc_build_list [ i ] then
62235: LD_EXP 64
62239: PUSH
62240: LD_VAR 0 2
62244: ARRAY
62245: NOT
62246: IFFALSE 62250
// break ;
62248: GO 62349
// if not HasTask ( j ) then
62250: LD_VAR 0 3
62254: PPUSH
62255: CALL_OW 314
62259: NOT
62260: IFFALSE 62347
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
62262: LD_VAR 0 3
62266: PPUSH
62267: LD_EXP 64
62271: PUSH
62272: LD_VAR 0 2
62276: ARRAY
62277: PUSH
62278: LD_INT 1
62280: ARRAY
62281: PUSH
62282: LD_INT 1
62284: ARRAY
62285: PPUSH
62286: LD_EXP 64
62290: PUSH
62291: LD_VAR 0 2
62295: ARRAY
62296: PUSH
62297: LD_INT 1
62299: ARRAY
62300: PUSH
62301: LD_INT 2
62303: ARRAY
62304: PPUSH
62305: LD_EXP 64
62309: PUSH
62310: LD_VAR 0 2
62314: ARRAY
62315: PUSH
62316: LD_INT 1
62318: ARRAY
62319: PUSH
62320: LD_INT 3
62322: ARRAY
62323: PPUSH
62324: LD_EXP 64
62328: PUSH
62329: LD_VAR 0 2
62333: ARRAY
62334: PUSH
62335: LD_INT 1
62337: ARRAY
62338: PUSH
62339: LD_INT 4
62341: ARRAY
62342: PPUSH
62343: CALL_OW 145
// end ;
62347: GO 62136
62349: POP
62350: POP
// end else
62351: GO 62495
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
62353: LD_EXP 59
62357: PUSH
62358: LD_VAR 0 2
62362: ARRAY
62363: PPUSH
62364: LD_EXP 64
62368: PUSH
62369: LD_VAR 0 2
62373: ARRAY
62374: PUSH
62375: LD_INT 1
62377: ARRAY
62378: PUSH
62379: LD_INT 1
62381: ARRAY
62382: PPUSH
62383: LD_EXP 64
62387: PUSH
62388: LD_VAR 0 2
62392: ARRAY
62393: PUSH
62394: LD_INT 1
62396: ARRAY
62397: PUSH
62398: LD_INT 2
62400: ARRAY
62401: PPUSH
62402: LD_EXP 64
62406: PUSH
62407: LD_VAR 0 2
62411: ARRAY
62412: PUSH
62413: LD_INT 1
62415: ARRAY
62416: PUSH
62417: LD_INT 3
62419: ARRAY
62420: PPUSH
62421: LD_EXP 64
62425: PUSH
62426: LD_VAR 0 2
62430: ARRAY
62431: PUSH
62432: LD_INT 1
62434: ARRAY
62435: PUSH
62436: LD_INT 4
62438: ARRAY
62439: PPUSH
62440: CALL 25989 0 5
62444: NOT
62445: IFFALSE 62495
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62447: LD_ADDR_EXP 64
62451: PUSH
62452: LD_EXP 64
62456: PPUSH
62457: LD_VAR 0 2
62461: PPUSH
62462: LD_EXP 64
62466: PUSH
62467: LD_VAR 0 2
62471: ARRAY
62472: PPUSH
62473: LD_INT 1
62475: PPUSH
62476: LD_INT 1
62478: NEG
62479: PPUSH
62480: LD_INT 0
62482: PPUSH
62483: CALL 18656 0 4
62487: PPUSH
62488: CALL_OW 1
62492: ST_TO_ADDR
// continue ;
62493: GO 61371
// end ; end ; end ;
62495: GO 61371
62497: POP
62498: POP
// end ;
62499: LD_VAR 0 1
62503: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62504: LD_INT 0
62506: PPUSH
62507: PPUSH
62508: PPUSH
62509: PPUSH
62510: PPUSH
62511: PPUSH
// if not mc_bases then
62512: LD_EXP 59
62516: NOT
62517: IFFALSE 62521
// exit ;
62519: GO 62948
// for i = 1 to mc_bases do
62521: LD_ADDR_VAR 0 2
62525: PUSH
62526: DOUBLE
62527: LD_INT 1
62529: DEC
62530: ST_TO_ADDR
62531: LD_EXP 59
62535: PUSH
62536: FOR_TO
62537: IFFALSE 62946
// begin tmp := mc_build_upgrade [ i ] ;
62539: LD_ADDR_VAR 0 4
62543: PUSH
62544: LD_EXP 91
62548: PUSH
62549: LD_VAR 0 2
62553: ARRAY
62554: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62555: LD_ADDR_VAR 0 6
62559: PUSH
62560: LD_EXP 92
62564: PUSH
62565: LD_VAR 0 2
62569: ARRAY
62570: PPUSH
62571: LD_INT 2
62573: PUSH
62574: LD_INT 30
62576: PUSH
62577: LD_INT 6
62579: PUSH
62580: EMPTY
62581: LIST
62582: LIST
62583: PUSH
62584: LD_INT 30
62586: PUSH
62587: LD_INT 7
62589: PUSH
62590: EMPTY
62591: LIST
62592: LIST
62593: PUSH
62594: EMPTY
62595: LIST
62596: LIST
62597: LIST
62598: PPUSH
62599: CALL_OW 72
62603: ST_TO_ADDR
// if not tmp and not lab then
62604: LD_VAR 0 4
62608: NOT
62609: PUSH
62610: LD_VAR 0 6
62614: NOT
62615: AND
62616: IFFALSE 62620
// continue ;
62618: GO 62536
// if tmp then
62620: LD_VAR 0 4
62624: IFFALSE 62744
// for j in tmp do
62626: LD_ADDR_VAR 0 3
62630: PUSH
62631: LD_VAR 0 4
62635: PUSH
62636: FOR_IN
62637: IFFALSE 62742
// begin if UpgradeCost ( j ) then
62639: LD_VAR 0 3
62643: PPUSH
62644: CALL 25649 0 1
62648: IFFALSE 62740
// begin ComUpgrade ( j ) ;
62650: LD_VAR 0 3
62654: PPUSH
62655: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
62659: LD_ADDR_EXP 91
62663: PUSH
62664: LD_EXP 91
62668: PPUSH
62669: LD_VAR 0 2
62673: PPUSH
62674: LD_EXP 91
62678: PUSH
62679: LD_VAR 0 2
62683: ARRAY
62684: PUSH
62685: LD_VAR 0 3
62689: DIFF
62690: PPUSH
62691: CALL_OW 1
62695: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62696: LD_ADDR_EXP 66
62700: PUSH
62701: LD_EXP 66
62705: PPUSH
62706: LD_VAR 0 2
62710: PUSH
62711: LD_EXP 66
62715: PUSH
62716: LD_VAR 0 2
62720: ARRAY
62721: PUSH
62722: LD_INT 1
62724: PLUS
62725: PUSH
62726: EMPTY
62727: LIST
62728: LIST
62729: PPUSH
62730: LD_VAR 0 3
62734: PPUSH
62735: CALL 19238 0 3
62739: ST_TO_ADDR
// end ; end ;
62740: GO 62636
62742: POP
62743: POP
// if not lab or not mc_lab_upgrade [ i ] then
62744: LD_VAR 0 6
62748: NOT
62749: PUSH
62750: LD_EXP 93
62754: PUSH
62755: LD_VAR 0 2
62759: ARRAY
62760: NOT
62761: OR
62762: IFFALSE 62766
// continue ;
62764: GO 62536
// for j in lab do
62766: LD_ADDR_VAR 0 3
62770: PUSH
62771: LD_VAR 0 6
62775: PUSH
62776: FOR_IN
62777: IFFALSE 62942
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
62779: LD_VAR 0 3
62783: PPUSH
62784: CALL_OW 266
62788: PUSH
62789: LD_INT 6
62791: PUSH
62792: LD_INT 7
62794: PUSH
62795: EMPTY
62796: LIST
62797: LIST
62798: IN
62799: PUSH
62800: LD_VAR 0 3
62804: PPUSH
62805: CALL_OW 461
62809: PUSH
62810: LD_INT 1
62812: NONEQUAL
62813: AND
62814: IFFALSE 62940
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
62816: LD_VAR 0 3
62820: PPUSH
62821: LD_EXP 93
62825: PUSH
62826: LD_VAR 0 2
62830: ARRAY
62831: PUSH
62832: LD_INT 1
62834: ARRAY
62835: PPUSH
62836: CALL 25854 0 2
62840: IFFALSE 62940
// begin ComCancel ( j ) ;
62842: LD_VAR 0 3
62846: PPUSH
62847: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
62851: LD_VAR 0 3
62855: PPUSH
62856: LD_EXP 93
62860: PUSH
62861: LD_VAR 0 2
62865: ARRAY
62866: PUSH
62867: LD_INT 1
62869: ARRAY
62870: PPUSH
62871: CALL_OW 207
// if not j in mc_construct_list [ i ] then
62875: LD_VAR 0 3
62879: PUSH
62880: LD_EXP 66
62884: PUSH
62885: LD_VAR 0 2
62889: ARRAY
62890: IN
62891: NOT
62892: IFFALSE 62938
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62894: LD_ADDR_EXP 66
62898: PUSH
62899: LD_EXP 66
62903: PPUSH
62904: LD_VAR 0 2
62908: PUSH
62909: LD_EXP 66
62913: PUSH
62914: LD_VAR 0 2
62918: ARRAY
62919: PUSH
62920: LD_INT 1
62922: PLUS
62923: PUSH
62924: EMPTY
62925: LIST
62926: LIST
62927: PPUSH
62928: LD_VAR 0 3
62932: PPUSH
62933: CALL 19238 0 3
62937: ST_TO_ADDR
// break ;
62938: GO 62942
// end ; end ; end ;
62940: GO 62776
62942: POP
62943: POP
// end ;
62944: GO 62536
62946: POP
62947: POP
// end ;
62948: LD_VAR 0 1
62952: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
62953: LD_INT 0
62955: PPUSH
62956: PPUSH
62957: PPUSH
62958: PPUSH
62959: PPUSH
62960: PPUSH
62961: PPUSH
62962: PPUSH
62963: PPUSH
// if not mc_bases then
62964: LD_EXP 59
62968: NOT
62969: IFFALSE 62973
// exit ;
62971: GO 63378
// for i = 1 to mc_bases do
62973: LD_ADDR_VAR 0 2
62977: PUSH
62978: DOUBLE
62979: LD_INT 1
62981: DEC
62982: ST_TO_ADDR
62983: LD_EXP 59
62987: PUSH
62988: FOR_TO
62989: IFFALSE 63376
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
62991: LD_EXP 67
62995: PUSH
62996: LD_VAR 0 2
63000: ARRAY
63001: NOT
63002: PUSH
63003: LD_EXP 59
63007: PUSH
63008: LD_VAR 0 2
63012: ARRAY
63013: PPUSH
63014: LD_INT 30
63016: PUSH
63017: LD_INT 3
63019: PUSH
63020: EMPTY
63021: LIST
63022: LIST
63023: PPUSH
63024: CALL_OW 72
63028: NOT
63029: OR
63030: IFFALSE 63034
// continue ;
63032: GO 62988
// busy := false ;
63034: LD_ADDR_VAR 0 8
63038: PUSH
63039: LD_INT 0
63041: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63042: LD_ADDR_VAR 0 4
63046: PUSH
63047: LD_EXP 59
63051: PUSH
63052: LD_VAR 0 2
63056: ARRAY
63057: PPUSH
63058: LD_INT 30
63060: PUSH
63061: LD_INT 3
63063: PUSH
63064: EMPTY
63065: LIST
63066: LIST
63067: PPUSH
63068: CALL_OW 72
63072: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
63073: LD_ADDR_VAR 0 6
63077: PUSH
63078: LD_EXP 67
63082: PUSH
63083: LD_VAR 0 2
63087: ARRAY
63088: PPUSH
63089: LD_INT 2
63091: PUSH
63092: LD_INT 30
63094: PUSH
63095: LD_INT 32
63097: PUSH
63098: EMPTY
63099: LIST
63100: LIST
63101: PUSH
63102: LD_INT 30
63104: PUSH
63105: LD_INT 33
63107: PUSH
63108: EMPTY
63109: LIST
63110: LIST
63111: PUSH
63112: EMPTY
63113: LIST
63114: LIST
63115: LIST
63116: PPUSH
63117: CALL_OW 72
63121: ST_TO_ADDR
// if not t then
63122: LD_VAR 0 6
63126: NOT
63127: IFFALSE 63131
// continue ;
63129: GO 62988
// for j in tmp do
63131: LD_ADDR_VAR 0 3
63135: PUSH
63136: LD_VAR 0 4
63140: PUSH
63141: FOR_IN
63142: IFFALSE 63172
// if not BuildingStatus ( j ) = bs_idle then
63144: LD_VAR 0 3
63148: PPUSH
63149: CALL_OW 461
63153: PUSH
63154: LD_INT 2
63156: EQUAL
63157: NOT
63158: IFFALSE 63170
// begin busy := true ;
63160: LD_ADDR_VAR 0 8
63164: PUSH
63165: LD_INT 1
63167: ST_TO_ADDR
// break ;
63168: GO 63172
// end ;
63170: GO 63141
63172: POP
63173: POP
// if busy then
63174: LD_VAR 0 8
63178: IFFALSE 63182
// continue ;
63180: GO 62988
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
63182: LD_ADDR_VAR 0 7
63186: PUSH
63187: LD_VAR 0 6
63191: PPUSH
63192: LD_INT 35
63194: PUSH
63195: LD_INT 0
63197: PUSH
63198: EMPTY
63199: LIST
63200: LIST
63201: PPUSH
63202: CALL_OW 72
63206: ST_TO_ADDR
// if tw then
63207: LD_VAR 0 7
63211: IFFALSE 63288
// begin tw := tw [ 1 ] ;
63213: LD_ADDR_VAR 0 7
63217: PUSH
63218: LD_VAR 0 7
63222: PUSH
63223: LD_INT 1
63225: ARRAY
63226: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
63227: LD_ADDR_VAR 0 9
63231: PUSH
63232: LD_VAR 0 7
63236: PPUSH
63237: LD_EXP 84
63241: PUSH
63242: LD_VAR 0 2
63246: ARRAY
63247: PPUSH
63248: CALL 24208 0 2
63252: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
63253: LD_EXP 98
63257: PUSH
63258: LD_VAR 0 2
63262: ARRAY
63263: IFFALSE 63286
// if not weapon in mc_allowed_tower_weapons [ i ] then
63265: LD_VAR 0 9
63269: PUSH
63270: LD_EXP 98
63274: PUSH
63275: LD_VAR 0 2
63279: ARRAY
63280: IN
63281: NOT
63282: IFFALSE 63286
// continue ;
63284: GO 62988
// end else
63286: GO 63351
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
63288: LD_ADDR_VAR 0 5
63292: PUSH
63293: LD_EXP 67
63297: PUSH
63298: LD_VAR 0 2
63302: ARRAY
63303: PPUSH
63304: LD_VAR 0 4
63308: PPUSH
63309: CALL 49829 0 2
63313: ST_TO_ADDR
// if not tmp2 then
63314: LD_VAR 0 5
63318: NOT
63319: IFFALSE 63323
// continue ;
63321: GO 62988
// tw := tmp2 [ 1 ] ;
63323: LD_ADDR_VAR 0 7
63327: PUSH
63328: LD_VAR 0 5
63332: PUSH
63333: LD_INT 1
63335: ARRAY
63336: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
63337: LD_ADDR_VAR 0 9
63341: PUSH
63342: LD_VAR 0 5
63346: PUSH
63347: LD_INT 2
63349: ARRAY
63350: ST_TO_ADDR
// end ; if not weapon then
63351: LD_VAR 0 9
63355: NOT
63356: IFFALSE 63360
// continue ;
63358: GO 62988
// ComPlaceWeapon ( tw , weapon ) ;
63360: LD_VAR 0 7
63364: PPUSH
63365: LD_VAR 0 9
63369: PPUSH
63370: CALL_OW 148
// end ;
63374: GO 62988
63376: POP
63377: POP
// end ;
63378: LD_VAR 0 1
63382: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
63383: LD_INT 0
63385: PPUSH
63386: PPUSH
63387: PPUSH
63388: PPUSH
63389: PPUSH
63390: PPUSH
// if not mc_bases then
63391: LD_EXP 59
63395: NOT
63396: IFFALSE 63400
// exit ;
63398: GO 64176
// for i = 1 to mc_bases do
63400: LD_ADDR_VAR 0 2
63404: PUSH
63405: DOUBLE
63406: LD_INT 1
63408: DEC
63409: ST_TO_ADDR
63410: LD_EXP 59
63414: PUSH
63415: FOR_TO
63416: IFFALSE 64174
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63418: LD_EXP 72
63422: PUSH
63423: LD_VAR 0 2
63427: ARRAY
63428: NOT
63429: PUSH
63430: LD_EXP 72
63434: PUSH
63435: LD_VAR 0 2
63439: ARRAY
63440: PUSH
63441: LD_EXP 73
63445: PUSH
63446: LD_VAR 0 2
63450: ARRAY
63451: EQUAL
63452: OR
63453: PUSH
63454: LD_EXP 82
63458: PUSH
63459: LD_VAR 0 2
63463: ARRAY
63464: OR
63465: IFFALSE 63469
// continue ;
63467: GO 63415
// if mc_miners [ i ] then
63469: LD_EXP 73
63473: PUSH
63474: LD_VAR 0 2
63478: ARRAY
63479: IFFALSE 63861
// begin for j = mc_miners [ i ] downto 1 do
63481: LD_ADDR_VAR 0 3
63485: PUSH
63486: DOUBLE
63487: LD_EXP 73
63491: PUSH
63492: LD_VAR 0 2
63496: ARRAY
63497: INC
63498: ST_TO_ADDR
63499: LD_INT 1
63501: PUSH
63502: FOR_DOWNTO
63503: IFFALSE 63859
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63505: LD_EXP 73
63509: PUSH
63510: LD_VAR 0 2
63514: ARRAY
63515: PUSH
63516: LD_VAR 0 3
63520: ARRAY
63521: PPUSH
63522: CALL_OW 301
63526: PUSH
63527: LD_EXP 73
63531: PUSH
63532: LD_VAR 0 2
63536: ARRAY
63537: PUSH
63538: LD_VAR 0 3
63542: ARRAY
63543: PPUSH
63544: CALL_OW 257
63548: PUSH
63549: LD_INT 1
63551: NONEQUAL
63552: OR
63553: IFFALSE 63616
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63555: LD_ADDR_VAR 0 5
63559: PUSH
63560: LD_EXP 73
63564: PUSH
63565: LD_VAR 0 2
63569: ARRAY
63570: PUSH
63571: LD_EXP 73
63575: PUSH
63576: LD_VAR 0 2
63580: ARRAY
63581: PUSH
63582: LD_VAR 0 3
63586: ARRAY
63587: DIFF
63588: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63589: LD_ADDR_EXP 73
63593: PUSH
63594: LD_EXP 73
63598: PPUSH
63599: LD_VAR 0 2
63603: PPUSH
63604: LD_VAR 0 5
63608: PPUSH
63609: CALL_OW 1
63613: ST_TO_ADDR
// continue ;
63614: GO 63502
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
63616: LD_EXP 73
63620: PUSH
63621: LD_VAR 0 2
63625: ARRAY
63626: PUSH
63627: LD_VAR 0 3
63631: ARRAY
63632: PPUSH
63633: CALL_OW 257
63637: PUSH
63638: LD_INT 1
63640: EQUAL
63641: PUSH
63642: LD_EXP 73
63646: PUSH
63647: LD_VAR 0 2
63651: ARRAY
63652: PUSH
63653: LD_VAR 0 3
63657: ARRAY
63658: PPUSH
63659: CALL_OW 459
63663: NOT
63664: AND
63665: PUSH
63666: LD_EXP 73
63670: PUSH
63671: LD_VAR 0 2
63675: ARRAY
63676: PUSH
63677: LD_VAR 0 3
63681: ARRAY
63682: PPUSH
63683: CALL_OW 314
63687: NOT
63688: AND
63689: IFFALSE 63857
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
63691: LD_EXP 73
63695: PUSH
63696: LD_VAR 0 2
63700: ARRAY
63701: PUSH
63702: LD_VAR 0 3
63706: ARRAY
63707: PPUSH
63708: CALL_OW 310
63712: IFFALSE 63735
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
63714: LD_EXP 73
63718: PUSH
63719: LD_VAR 0 2
63723: ARRAY
63724: PUSH
63725: LD_VAR 0 3
63729: ARRAY
63730: PPUSH
63731: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
63735: LD_EXP 73
63739: PUSH
63740: LD_VAR 0 2
63744: ARRAY
63745: PUSH
63746: LD_VAR 0 3
63750: ARRAY
63751: PPUSH
63752: CALL_OW 314
63756: NOT
63757: IFFALSE 63857
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
63759: LD_EXP 73
63763: PUSH
63764: LD_VAR 0 2
63768: ARRAY
63769: PUSH
63770: LD_VAR 0 3
63774: ARRAY
63775: PPUSH
63776: LD_EXP 72
63780: PUSH
63781: LD_VAR 0 2
63785: ARRAY
63786: PUSH
63787: LD_VAR 0 3
63791: PUSH
63792: LD_EXP 72
63796: PUSH
63797: LD_VAR 0 2
63801: ARRAY
63802: MOD
63803: PUSH
63804: LD_INT 1
63806: PLUS
63807: ARRAY
63808: PUSH
63809: LD_INT 1
63811: ARRAY
63812: PPUSH
63813: LD_EXP 72
63817: PUSH
63818: LD_VAR 0 2
63822: ARRAY
63823: PUSH
63824: LD_VAR 0 3
63828: PUSH
63829: LD_EXP 72
63833: PUSH
63834: LD_VAR 0 2
63838: ARRAY
63839: MOD
63840: PUSH
63841: LD_INT 1
63843: PLUS
63844: ARRAY
63845: PUSH
63846: LD_INT 2
63848: ARRAY
63849: PPUSH
63850: LD_INT 0
63852: PPUSH
63853: CALL_OW 193
// end ; end ;
63857: GO 63502
63859: POP
63860: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
63861: LD_ADDR_VAR 0 5
63865: PUSH
63866: LD_EXP 59
63870: PUSH
63871: LD_VAR 0 2
63875: ARRAY
63876: PPUSH
63877: LD_INT 2
63879: PUSH
63880: LD_INT 30
63882: PUSH
63883: LD_INT 4
63885: PUSH
63886: EMPTY
63887: LIST
63888: LIST
63889: PUSH
63890: LD_INT 30
63892: PUSH
63893: LD_INT 5
63895: PUSH
63896: EMPTY
63897: LIST
63898: LIST
63899: PUSH
63900: LD_INT 30
63902: PUSH
63903: LD_INT 32
63905: PUSH
63906: EMPTY
63907: LIST
63908: LIST
63909: PUSH
63910: EMPTY
63911: LIST
63912: LIST
63913: LIST
63914: LIST
63915: PPUSH
63916: CALL_OW 72
63920: ST_TO_ADDR
// if not tmp then
63921: LD_VAR 0 5
63925: NOT
63926: IFFALSE 63930
// continue ;
63928: GO 63415
// list := [ ] ;
63930: LD_ADDR_VAR 0 6
63934: PUSH
63935: EMPTY
63936: ST_TO_ADDR
// for j in tmp do
63937: LD_ADDR_VAR 0 3
63941: PUSH
63942: LD_VAR 0 5
63946: PUSH
63947: FOR_IN
63948: IFFALSE 64017
// begin for k in UnitsInside ( j ) do
63950: LD_ADDR_VAR 0 4
63954: PUSH
63955: LD_VAR 0 3
63959: PPUSH
63960: CALL_OW 313
63964: PUSH
63965: FOR_IN
63966: IFFALSE 64013
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
63968: LD_VAR 0 4
63972: PPUSH
63973: CALL_OW 257
63977: PUSH
63978: LD_INT 1
63980: EQUAL
63981: PUSH
63982: LD_VAR 0 4
63986: PPUSH
63987: CALL_OW 459
63991: NOT
63992: AND
63993: IFFALSE 64011
// list := list ^ k ;
63995: LD_ADDR_VAR 0 6
63999: PUSH
64000: LD_VAR 0 6
64004: PUSH
64005: LD_VAR 0 4
64009: ADD
64010: ST_TO_ADDR
64011: GO 63965
64013: POP
64014: POP
// end ;
64015: GO 63947
64017: POP
64018: POP
// list := list diff mc_miners [ i ] ;
64019: LD_ADDR_VAR 0 6
64023: PUSH
64024: LD_VAR 0 6
64028: PUSH
64029: LD_EXP 73
64033: PUSH
64034: LD_VAR 0 2
64038: ARRAY
64039: DIFF
64040: ST_TO_ADDR
// if not list then
64041: LD_VAR 0 6
64045: NOT
64046: IFFALSE 64050
// continue ;
64048: GO 63415
// k := mc_mines [ i ] - mc_miners [ i ] ;
64050: LD_ADDR_VAR 0 4
64054: PUSH
64055: LD_EXP 72
64059: PUSH
64060: LD_VAR 0 2
64064: ARRAY
64065: PUSH
64066: LD_EXP 73
64070: PUSH
64071: LD_VAR 0 2
64075: ARRAY
64076: MINUS
64077: ST_TO_ADDR
// if k > list then
64078: LD_VAR 0 4
64082: PUSH
64083: LD_VAR 0 6
64087: GREATER
64088: IFFALSE 64100
// k := list ;
64090: LD_ADDR_VAR 0 4
64094: PUSH
64095: LD_VAR 0 6
64099: ST_TO_ADDR
// for j = 1 to k do
64100: LD_ADDR_VAR 0 3
64104: PUSH
64105: DOUBLE
64106: LD_INT 1
64108: DEC
64109: ST_TO_ADDR
64110: LD_VAR 0 4
64114: PUSH
64115: FOR_TO
64116: IFFALSE 64170
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
64118: LD_ADDR_EXP 73
64122: PUSH
64123: LD_EXP 73
64127: PPUSH
64128: LD_VAR 0 2
64132: PUSH
64133: LD_EXP 73
64137: PUSH
64138: LD_VAR 0 2
64142: ARRAY
64143: PUSH
64144: LD_INT 1
64146: PLUS
64147: PUSH
64148: EMPTY
64149: LIST
64150: LIST
64151: PPUSH
64152: LD_VAR 0 6
64156: PUSH
64157: LD_VAR 0 3
64161: ARRAY
64162: PPUSH
64163: CALL 19238 0 3
64167: ST_TO_ADDR
64168: GO 64115
64170: POP
64171: POP
// end ;
64172: GO 63415
64174: POP
64175: POP
// end ;
64176: LD_VAR 0 1
64180: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
64181: LD_INT 0
64183: PPUSH
64184: PPUSH
64185: PPUSH
64186: PPUSH
64187: PPUSH
64188: PPUSH
64189: PPUSH
64190: PPUSH
64191: PPUSH
64192: PPUSH
// if not mc_bases then
64193: LD_EXP 59
64197: NOT
64198: IFFALSE 64202
// exit ;
64200: GO 65952
// for i = 1 to mc_bases do
64202: LD_ADDR_VAR 0 2
64206: PUSH
64207: DOUBLE
64208: LD_INT 1
64210: DEC
64211: ST_TO_ADDR
64212: LD_EXP 59
64216: PUSH
64217: FOR_TO
64218: IFFALSE 65950
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
64220: LD_EXP 59
64224: PUSH
64225: LD_VAR 0 2
64229: ARRAY
64230: NOT
64231: PUSH
64232: LD_EXP 66
64236: PUSH
64237: LD_VAR 0 2
64241: ARRAY
64242: OR
64243: IFFALSE 64247
// continue ;
64245: GO 64217
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
64247: LD_EXP 75
64251: PUSH
64252: LD_VAR 0 2
64256: ARRAY
64257: NOT
64258: PUSH
64259: LD_EXP 76
64263: PUSH
64264: LD_VAR 0 2
64268: ARRAY
64269: AND
64270: IFFALSE 64308
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64272: LD_ADDR_EXP 76
64276: PUSH
64277: LD_EXP 76
64281: PPUSH
64282: LD_VAR 0 2
64286: PPUSH
64287: EMPTY
64288: PPUSH
64289: CALL_OW 1
64293: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
64294: LD_VAR 0 2
64298: PPUSH
64299: LD_INT 107
64301: PPUSH
64302: CALL 55182 0 2
// continue ;
64306: GO 64217
// end ; target := [ ] ;
64308: LD_ADDR_VAR 0 6
64312: PUSH
64313: EMPTY
64314: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64315: LD_ADDR_VAR 0 3
64319: PUSH
64320: DOUBLE
64321: LD_EXP 75
64325: PUSH
64326: LD_VAR 0 2
64330: ARRAY
64331: INC
64332: ST_TO_ADDR
64333: LD_INT 1
64335: PUSH
64336: FOR_DOWNTO
64337: IFFALSE 64597
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64339: LD_EXP 75
64343: PUSH
64344: LD_VAR 0 2
64348: ARRAY
64349: PUSH
64350: LD_VAR 0 3
64354: ARRAY
64355: PUSH
64356: LD_INT 2
64358: ARRAY
64359: PPUSH
64360: LD_EXP 75
64364: PUSH
64365: LD_VAR 0 2
64369: ARRAY
64370: PUSH
64371: LD_VAR 0 3
64375: ARRAY
64376: PUSH
64377: LD_INT 3
64379: ARRAY
64380: PPUSH
64381: CALL_OW 488
64385: PUSH
64386: LD_EXP 75
64390: PUSH
64391: LD_VAR 0 2
64395: ARRAY
64396: PUSH
64397: LD_VAR 0 3
64401: ARRAY
64402: PUSH
64403: LD_INT 2
64405: ARRAY
64406: PPUSH
64407: LD_EXP 75
64411: PUSH
64412: LD_VAR 0 2
64416: ARRAY
64417: PUSH
64418: LD_VAR 0 3
64422: ARRAY
64423: PUSH
64424: LD_INT 3
64426: ARRAY
64427: PPUSH
64428: CALL_OW 284
64432: PUSH
64433: LD_INT 0
64435: EQUAL
64436: AND
64437: IFFALSE 64492
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
64439: LD_ADDR_VAR 0 5
64443: PUSH
64444: LD_EXP 75
64448: PUSH
64449: LD_VAR 0 2
64453: ARRAY
64454: PPUSH
64455: LD_VAR 0 3
64459: PPUSH
64460: CALL_OW 3
64464: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64465: LD_ADDR_EXP 75
64469: PUSH
64470: LD_EXP 75
64474: PPUSH
64475: LD_VAR 0 2
64479: PPUSH
64480: LD_VAR 0 5
64484: PPUSH
64485: CALL_OW 1
64489: ST_TO_ADDR
// continue ;
64490: GO 64336
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64492: LD_EXP 59
64496: PUSH
64497: LD_VAR 0 2
64501: ARRAY
64502: PUSH
64503: LD_INT 1
64505: ARRAY
64506: PPUSH
64507: CALL_OW 255
64511: PPUSH
64512: LD_EXP 75
64516: PUSH
64517: LD_VAR 0 2
64521: ARRAY
64522: PUSH
64523: LD_VAR 0 3
64527: ARRAY
64528: PUSH
64529: LD_INT 2
64531: ARRAY
64532: PPUSH
64533: LD_EXP 75
64537: PUSH
64538: LD_VAR 0 2
64542: ARRAY
64543: PUSH
64544: LD_VAR 0 3
64548: ARRAY
64549: PUSH
64550: LD_INT 3
64552: ARRAY
64553: PPUSH
64554: LD_INT 30
64556: PPUSH
64557: CALL 20134 0 4
64561: PUSH
64562: LD_INT 4
64564: ARRAY
64565: PUSH
64566: LD_INT 0
64568: EQUAL
64569: IFFALSE 64595
// begin target := mc_crates [ i ] [ j ] ;
64571: LD_ADDR_VAR 0 6
64575: PUSH
64576: LD_EXP 75
64580: PUSH
64581: LD_VAR 0 2
64585: ARRAY
64586: PUSH
64587: LD_VAR 0 3
64591: ARRAY
64592: ST_TO_ADDR
// break ;
64593: GO 64597
// end ; end ;
64595: GO 64336
64597: POP
64598: POP
// if not target then
64599: LD_VAR 0 6
64603: NOT
64604: IFFALSE 64608
// continue ;
64606: GO 64217
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
64608: LD_ADDR_VAR 0 7
64612: PUSH
64613: LD_EXP 78
64617: PUSH
64618: LD_VAR 0 2
64622: ARRAY
64623: PPUSH
64624: LD_INT 2
64626: PUSH
64627: LD_INT 3
64629: PUSH
64630: LD_INT 58
64632: PUSH
64633: EMPTY
64634: LIST
64635: PUSH
64636: EMPTY
64637: LIST
64638: LIST
64639: PUSH
64640: LD_INT 61
64642: PUSH
64643: EMPTY
64644: LIST
64645: PUSH
64646: LD_INT 33
64648: PUSH
64649: LD_INT 5
64651: PUSH
64652: EMPTY
64653: LIST
64654: LIST
64655: PUSH
64656: LD_INT 33
64658: PUSH
64659: LD_INT 3
64661: PUSH
64662: EMPTY
64663: LIST
64664: LIST
64665: PUSH
64666: EMPTY
64667: LIST
64668: LIST
64669: LIST
64670: LIST
64671: LIST
64672: PUSH
64673: LD_INT 2
64675: PUSH
64676: LD_INT 34
64678: PUSH
64679: LD_INT 32
64681: PUSH
64682: EMPTY
64683: LIST
64684: LIST
64685: PUSH
64686: LD_INT 34
64688: PUSH
64689: LD_INT 51
64691: PUSH
64692: EMPTY
64693: LIST
64694: LIST
64695: PUSH
64696: LD_INT 34
64698: PUSH
64699: LD_INT 12
64701: PUSH
64702: EMPTY
64703: LIST
64704: LIST
64705: PUSH
64706: EMPTY
64707: LIST
64708: LIST
64709: LIST
64710: LIST
64711: PUSH
64712: EMPTY
64713: LIST
64714: LIST
64715: PPUSH
64716: CALL_OW 72
64720: ST_TO_ADDR
// if not cargo then
64721: LD_VAR 0 7
64725: NOT
64726: IFFALSE 65369
// begin if mc_crates_collector [ i ] < 5 then
64728: LD_EXP 76
64732: PUSH
64733: LD_VAR 0 2
64737: ARRAY
64738: PUSH
64739: LD_INT 5
64741: LESS
64742: IFFALSE 65108
// begin if mc_ape [ i ] then
64744: LD_EXP 88
64748: PUSH
64749: LD_VAR 0 2
64753: ARRAY
64754: IFFALSE 64801
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
64756: LD_ADDR_VAR 0 5
64760: PUSH
64761: LD_EXP 88
64765: PUSH
64766: LD_VAR 0 2
64770: ARRAY
64771: PPUSH
64772: LD_INT 25
64774: PUSH
64775: LD_INT 16
64777: PUSH
64778: EMPTY
64779: LIST
64780: LIST
64781: PUSH
64782: LD_INT 24
64784: PUSH
64785: LD_INT 750
64787: PUSH
64788: EMPTY
64789: LIST
64790: LIST
64791: PUSH
64792: EMPTY
64793: LIST
64794: LIST
64795: PPUSH
64796: CALL_OW 72
64800: ST_TO_ADDR
// if not tmp then
64801: LD_VAR 0 5
64805: NOT
64806: IFFALSE 64853
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
64808: LD_ADDR_VAR 0 5
64812: PUSH
64813: LD_EXP 59
64817: PUSH
64818: LD_VAR 0 2
64822: ARRAY
64823: PPUSH
64824: LD_INT 25
64826: PUSH
64827: LD_INT 2
64829: PUSH
64830: EMPTY
64831: LIST
64832: LIST
64833: PUSH
64834: LD_INT 24
64836: PUSH
64837: LD_INT 750
64839: PUSH
64840: EMPTY
64841: LIST
64842: LIST
64843: PUSH
64844: EMPTY
64845: LIST
64846: LIST
64847: PPUSH
64848: CALL_OW 72
64852: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
64853: LD_EXP 88
64857: PUSH
64858: LD_VAR 0 2
64862: ARRAY
64863: PUSH
64864: LD_EXP 59
64868: PUSH
64869: LD_VAR 0 2
64873: ARRAY
64874: PPUSH
64875: LD_INT 25
64877: PUSH
64878: LD_INT 2
64880: PUSH
64881: EMPTY
64882: LIST
64883: LIST
64884: PUSH
64885: LD_INT 24
64887: PUSH
64888: LD_INT 750
64890: PUSH
64891: EMPTY
64892: LIST
64893: LIST
64894: PUSH
64895: EMPTY
64896: LIST
64897: LIST
64898: PPUSH
64899: CALL_OW 72
64903: AND
64904: PUSH
64905: LD_VAR 0 5
64909: PUSH
64910: LD_INT 5
64912: LESS
64913: AND
64914: IFFALSE 64996
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
64916: LD_ADDR_VAR 0 3
64920: PUSH
64921: LD_EXP 59
64925: PUSH
64926: LD_VAR 0 2
64930: ARRAY
64931: PPUSH
64932: LD_INT 25
64934: PUSH
64935: LD_INT 2
64937: PUSH
64938: EMPTY
64939: LIST
64940: LIST
64941: PUSH
64942: LD_INT 24
64944: PUSH
64945: LD_INT 750
64947: PUSH
64948: EMPTY
64949: LIST
64950: LIST
64951: PUSH
64952: EMPTY
64953: LIST
64954: LIST
64955: PPUSH
64956: CALL_OW 72
64960: PUSH
64961: FOR_IN
64962: IFFALSE 64994
// begin tmp := tmp union j ;
64964: LD_ADDR_VAR 0 5
64968: PUSH
64969: LD_VAR 0 5
64973: PUSH
64974: LD_VAR 0 3
64978: UNION
64979: ST_TO_ADDR
// if tmp >= 5 then
64980: LD_VAR 0 5
64984: PUSH
64985: LD_INT 5
64987: GREATEREQUAL
64988: IFFALSE 64992
// break ;
64990: GO 64994
// end ;
64992: GO 64961
64994: POP
64995: POP
// end ; if not tmp then
64996: LD_VAR 0 5
65000: NOT
65001: IFFALSE 65005
// continue ;
65003: GO 64217
// for j in tmp do
65005: LD_ADDR_VAR 0 3
65009: PUSH
65010: LD_VAR 0 5
65014: PUSH
65015: FOR_IN
65016: IFFALSE 65106
// if not GetTag ( j ) then
65018: LD_VAR 0 3
65022: PPUSH
65023: CALL_OW 110
65027: NOT
65028: IFFALSE 65104
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65030: LD_ADDR_EXP 76
65034: PUSH
65035: LD_EXP 76
65039: PPUSH
65040: LD_VAR 0 2
65044: PUSH
65045: LD_EXP 76
65049: PUSH
65050: LD_VAR 0 2
65054: ARRAY
65055: PUSH
65056: LD_INT 1
65058: PLUS
65059: PUSH
65060: EMPTY
65061: LIST
65062: LIST
65063: PPUSH
65064: LD_VAR 0 3
65068: PPUSH
65069: CALL 19238 0 3
65073: ST_TO_ADDR
// SetTag ( j , 107 ) ;
65074: LD_VAR 0 3
65078: PPUSH
65079: LD_INT 107
65081: PPUSH
65082: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
65086: LD_EXP 76
65090: PUSH
65091: LD_VAR 0 2
65095: ARRAY
65096: PUSH
65097: LD_INT 5
65099: GREATEREQUAL
65100: IFFALSE 65104
// break ;
65102: GO 65106
// end ;
65104: GO 65015
65106: POP
65107: POP
// end ; if mc_crates_collector [ i ] and target then
65108: LD_EXP 76
65112: PUSH
65113: LD_VAR 0 2
65117: ARRAY
65118: PUSH
65119: LD_VAR 0 6
65123: AND
65124: IFFALSE 65367
// begin if mc_crates_collector [ i ] < target [ 1 ] then
65126: LD_EXP 76
65130: PUSH
65131: LD_VAR 0 2
65135: ARRAY
65136: PUSH
65137: LD_VAR 0 6
65141: PUSH
65142: LD_INT 1
65144: ARRAY
65145: LESS
65146: IFFALSE 65166
// tmp := mc_crates_collector [ i ] else
65148: LD_ADDR_VAR 0 5
65152: PUSH
65153: LD_EXP 76
65157: PUSH
65158: LD_VAR 0 2
65162: ARRAY
65163: ST_TO_ADDR
65164: GO 65180
// tmp := target [ 1 ] ;
65166: LD_ADDR_VAR 0 5
65170: PUSH
65171: LD_VAR 0 6
65175: PUSH
65176: LD_INT 1
65178: ARRAY
65179: ST_TO_ADDR
// k := 0 ;
65180: LD_ADDR_VAR 0 4
65184: PUSH
65185: LD_INT 0
65187: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
65188: LD_ADDR_VAR 0 3
65192: PUSH
65193: LD_EXP 76
65197: PUSH
65198: LD_VAR 0 2
65202: ARRAY
65203: PUSH
65204: FOR_IN
65205: IFFALSE 65365
// begin k := k + 1 ;
65207: LD_ADDR_VAR 0 4
65211: PUSH
65212: LD_VAR 0 4
65216: PUSH
65217: LD_INT 1
65219: PLUS
65220: ST_TO_ADDR
// if k > tmp then
65221: LD_VAR 0 4
65225: PUSH
65226: LD_VAR 0 5
65230: GREATER
65231: IFFALSE 65235
// break ;
65233: GO 65365
// if not GetClass ( j ) in [ 2 , 16 ] then
65235: LD_VAR 0 3
65239: PPUSH
65240: CALL_OW 257
65244: PUSH
65245: LD_INT 2
65247: PUSH
65248: LD_INT 16
65250: PUSH
65251: EMPTY
65252: LIST
65253: LIST
65254: IN
65255: NOT
65256: IFFALSE 65309
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
65258: LD_ADDR_EXP 76
65262: PUSH
65263: LD_EXP 76
65267: PPUSH
65268: LD_VAR 0 2
65272: PPUSH
65273: LD_EXP 76
65277: PUSH
65278: LD_VAR 0 2
65282: ARRAY
65283: PUSH
65284: LD_VAR 0 3
65288: DIFF
65289: PPUSH
65290: CALL_OW 1
65294: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65295: LD_VAR 0 3
65299: PPUSH
65300: LD_INT 0
65302: PPUSH
65303: CALL_OW 109
// continue ;
65307: GO 65204
// end ; if IsInUnit ( j ) then
65309: LD_VAR 0 3
65313: PPUSH
65314: CALL_OW 310
65318: IFFALSE 65329
// ComExitBuilding ( j ) ;
65320: LD_VAR 0 3
65324: PPUSH
65325: CALL_OW 122
// wait ( 3 ) ;
65329: LD_INT 3
65331: PPUSH
65332: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65336: LD_VAR 0 3
65340: PPUSH
65341: LD_VAR 0 6
65345: PUSH
65346: LD_INT 2
65348: ARRAY
65349: PPUSH
65350: LD_VAR 0 6
65354: PUSH
65355: LD_INT 3
65357: ARRAY
65358: PPUSH
65359: CALL_OW 117
// end ;
65363: GO 65204
65365: POP
65366: POP
// end ; end else
65367: GO 65948
// begin for j in cargo do
65369: LD_ADDR_VAR 0 3
65373: PUSH
65374: LD_VAR 0 7
65378: PUSH
65379: FOR_IN
65380: IFFALSE 65946
// begin if GetTag ( j ) <> 0 then
65382: LD_VAR 0 3
65386: PPUSH
65387: CALL_OW 110
65391: PUSH
65392: LD_INT 0
65394: NONEQUAL
65395: IFFALSE 65399
// continue ;
65397: GO 65379
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
65399: LD_VAR 0 3
65403: PPUSH
65404: CALL_OW 256
65408: PUSH
65409: LD_INT 1000
65411: LESS
65412: PUSH
65413: LD_VAR 0 3
65417: PPUSH
65418: LD_EXP 83
65422: PUSH
65423: LD_VAR 0 2
65427: ARRAY
65428: PPUSH
65429: CALL_OW 308
65433: NOT
65434: AND
65435: IFFALSE 65457
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65437: LD_VAR 0 3
65441: PPUSH
65442: LD_EXP 83
65446: PUSH
65447: LD_VAR 0 2
65451: ARRAY
65452: PPUSH
65453: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65457: LD_VAR 0 3
65461: PPUSH
65462: CALL_OW 256
65466: PUSH
65467: LD_INT 1000
65469: LESS
65470: PUSH
65471: LD_VAR 0 3
65475: PPUSH
65476: LD_EXP 83
65480: PUSH
65481: LD_VAR 0 2
65485: ARRAY
65486: PPUSH
65487: CALL_OW 308
65491: AND
65492: IFFALSE 65496
// continue ;
65494: GO 65379
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
65496: LD_VAR 0 3
65500: PPUSH
65501: CALL_OW 262
65505: PUSH
65506: LD_INT 2
65508: EQUAL
65509: PUSH
65510: LD_VAR 0 3
65514: PPUSH
65515: CALL_OW 261
65519: PUSH
65520: LD_INT 15
65522: LESS
65523: AND
65524: IFFALSE 65528
// continue ;
65526: GO 65379
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
65528: LD_VAR 0 3
65532: PPUSH
65533: CALL_OW 262
65537: PUSH
65538: LD_INT 1
65540: EQUAL
65541: PUSH
65542: LD_VAR 0 3
65546: PPUSH
65547: CALL_OW 261
65551: PUSH
65552: LD_INT 10
65554: LESS
65555: AND
65556: IFFALSE 65885
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65558: LD_ADDR_VAR 0 8
65562: PUSH
65563: LD_EXP 59
65567: PUSH
65568: LD_VAR 0 2
65572: ARRAY
65573: PPUSH
65574: LD_INT 2
65576: PUSH
65577: LD_INT 30
65579: PUSH
65580: LD_INT 0
65582: PUSH
65583: EMPTY
65584: LIST
65585: LIST
65586: PUSH
65587: LD_INT 30
65589: PUSH
65590: LD_INT 1
65592: PUSH
65593: EMPTY
65594: LIST
65595: LIST
65596: PUSH
65597: EMPTY
65598: LIST
65599: LIST
65600: LIST
65601: PPUSH
65602: CALL_OW 72
65606: ST_TO_ADDR
// if not depot then
65607: LD_VAR 0 8
65611: NOT
65612: IFFALSE 65616
// continue ;
65614: GO 65379
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
65616: LD_VAR 0 3
65620: PPUSH
65621: LD_VAR 0 8
65625: PPUSH
65626: LD_VAR 0 3
65630: PPUSH
65631: CALL_OW 74
65635: PPUSH
65636: CALL_OW 296
65640: PUSH
65641: LD_INT 6
65643: LESS
65644: IFFALSE 65660
// SetFuel ( j , 100 ) else
65646: LD_VAR 0 3
65650: PPUSH
65651: LD_INT 100
65653: PPUSH
65654: CALL_OW 240
65658: GO 65885
// if GetFuel ( j ) = 0 then
65660: LD_VAR 0 3
65664: PPUSH
65665: CALL_OW 261
65669: PUSH
65670: LD_INT 0
65672: EQUAL
65673: IFFALSE 65885
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
65675: LD_ADDR_EXP 78
65679: PUSH
65680: LD_EXP 78
65684: PPUSH
65685: LD_VAR 0 2
65689: PPUSH
65690: LD_EXP 78
65694: PUSH
65695: LD_VAR 0 2
65699: ARRAY
65700: PUSH
65701: LD_VAR 0 3
65705: DIFF
65706: PPUSH
65707: CALL_OW 1
65711: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
65712: LD_VAR 0 3
65716: PPUSH
65717: CALL_OW 263
65721: PUSH
65722: LD_INT 1
65724: EQUAL
65725: IFFALSE 65741
// ComExitVehicle ( IsInUnit ( j ) ) ;
65727: LD_VAR 0 3
65731: PPUSH
65732: CALL_OW 310
65736: PPUSH
65737: CALL_OW 121
// if GetControl ( j ) = control_remote then
65741: LD_VAR 0 3
65745: PPUSH
65746: CALL_OW 263
65750: PUSH
65751: LD_INT 2
65753: EQUAL
65754: IFFALSE 65765
// ComUnlink ( j ) ;
65756: LD_VAR 0 3
65760: PPUSH
65761: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
65765: LD_ADDR_VAR 0 9
65769: PUSH
65770: LD_VAR 0 2
65774: PPUSH
65775: LD_INT 3
65777: PPUSH
65778: CALL 75238 0 2
65782: ST_TO_ADDR
// if fac then
65783: LD_VAR 0 9
65787: IFFALSE 65883
// begin for k in fac do
65789: LD_ADDR_VAR 0 4
65793: PUSH
65794: LD_VAR 0 9
65798: PUSH
65799: FOR_IN
65800: IFFALSE 65881
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
65802: LD_ADDR_VAR 0 10
65806: PUSH
65807: LD_VAR 0 9
65811: PPUSH
65812: LD_VAR 0 3
65816: PPUSH
65817: CALL_OW 265
65821: PPUSH
65822: LD_VAR 0 3
65826: PPUSH
65827: CALL_OW 262
65831: PPUSH
65832: LD_VAR 0 3
65836: PPUSH
65837: CALL_OW 263
65841: PPUSH
65842: LD_VAR 0 3
65846: PPUSH
65847: CALL_OW 264
65851: PPUSH
65852: CALL 16770 0 5
65856: ST_TO_ADDR
// if components then
65857: LD_VAR 0 10
65861: IFFALSE 65879
// begin MC_InsertProduceList ( i , components ) ;
65863: LD_VAR 0 2
65867: PPUSH
65868: LD_VAR 0 10
65872: PPUSH
65873: CALL 74783 0 2
// break ;
65877: GO 65881
// end ; end ;
65879: GO 65799
65881: POP
65882: POP
// end ; continue ;
65883: GO 65379
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
65885: LD_VAR 0 3
65889: PPUSH
65890: LD_INT 1
65892: PPUSH
65893: CALL_OW 289
65897: PUSH
65898: LD_INT 100
65900: LESS
65901: PUSH
65902: LD_VAR 0 3
65906: PPUSH
65907: CALL_OW 314
65911: NOT
65912: AND
65913: IFFALSE 65942
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65915: LD_VAR 0 3
65919: PPUSH
65920: LD_VAR 0 6
65924: PUSH
65925: LD_INT 2
65927: ARRAY
65928: PPUSH
65929: LD_VAR 0 6
65933: PUSH
65934: LD_INT 3
65936: ARRAY
65937: PPUSH
65938: CALL_OW 117
// break ;
65942: GO 65946
// end ;
65944: GO 65379
65946: POP
65947: POP
// end ; end ;
65948: GO 64217
65950: POP
65951: POP
// end ;
65952: LD_VAR 0 1
65956: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
65957: LD_INT 0
65959: PPUSH
65960: PPUSH
65961: PPUSH
65962: PPUSH
// if not mc_bases then
65963: LD_EXP 59
65967: NOT
65968: IFFALSE 65972
// exit ;
65970: GO 66133
// for i = 1 to mc_bases do
65972: LD_ADDR_VAR 0 2
65976: PUSH
65977: DOUBLE
65978: LD_INT 1
65980: DEC
65981: ST_TO_ADDR
65982: LD_EXP 59
65986: PUSH
65987: FOR_TO
65988: IFFALSE 66131
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
65990: LD_ADDR_VAR 0 4
65994: PUSH
65995: LD_EXP 78
65999: PUSH
66000: LD_VAR 0 2
66004: ARRAY
66005: PUSH
66006: LD_EXP 81
66010: PUSH
66011: LD_VAR 0 2
66015: ARRAY
66016: UNION
66017: PPUSH
66018: LD_INT 33
66020: PUSH
66021: LD_INT 2
66023: PUSH
66024: EMPTY
66025: LIST
66026: LIST
66027: PPUSH
66028: CALL_OW 72
66032: ST_TO_ADDR
// if tmp then
66033: LD_VAR 0 4
66037: IFFALSE 66129
// for j in tmp do
66039: LD_ADDR_VAR 0 3
66043: PUSH
66044: LD_VAR 0 4
66048: PUSH
66049: FOR_IN
66050: IFFALSE 66127
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66052: LD_VAR 0 3
66056: PPUSH
66057: CALL_OW 312
66061: NOT
66062: PUSH
66063: LD_VAR 0 3
66067: PPUSH
66068: CALL_OW 256
66072: PUSH
66073: LD_INT 250
66075: GREATEREQUAL
66076: AND
66077: IFFALSE 66090
// Connect ( j ) else
66079: LD_VAR 0 3
66083: PPUSH
66084: CALL 22171 0 1
66088: GO 66125
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
66090: LD_VAR 0 3
66094: PPUSH
66095: CALL_OW 256
66099: PUSH
66100: LD_INT 250
66102: LESS
66103: PUSH
66104: LD_VAR 0 3
66108: PPUSH
66109: CALL_OW 312
66113: AND
66114: IFFALSE 66125
// ComUnlink ( j ) ;
66116: LD_VAR 0 3
66120: PPUSH
66121: CALL_OW 136
66125: GO 66049
66127: POP
66128: POP
// end ;
66129: GO 65987
66131: POP
66132: POP
// end ;
66133: LD_VAR 0 1
66137: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
66138: LD_INT 0
66140: PPUSH
66141: PPUSH
66142: PPUSH
66143: PPUSH
66144: PPUSH
// if not mc_bases then
66145: LD_EXP 59
66149: NOT
66150: IFFALSE 66154
// exit ;
66152: GO 66599
// for i = 1 to mc_bases do
66154: LD_ADDR_VAR 0 2
66158: PUSH
66159: DOUBLE
66160: LD_INT 1
66162: DEC
66163: ST_TO_ADDR
66164: LD_EXP 59
66168: PUSH
66169: FOR_TO
66170: IFFALSE 66597
// begin if not mc_produce [ i ] then
66172: LD_EXP 80
66176: PUSH
66177: LD_VAR 0 2
66181: ARRAY
66182: NOT
66183: IFFALSE 66187
// continue ;
66185: GO 66169
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66187: LD_ADDR_VAR 0 5
66191: PUSH
66192: LD_EXP 59
66196: PUSH
66197: LD_VAR 0 2
66201: ARRAY
66202: PPUSH
66203: LD_INT 30
66205: PUSH
66206: LD_INT 3
66208: PUSH
66209: EMPTY
66210: LIST
66211: LIST
66212: PPUSH
66213: CALL_OW 72
66217: ST_TO_ADDR
// if not fac then
66218: LD_VAR 0 5
66222: NOT
66223: IFFALSE 66227
// continue ;
66225: GO 66169
// for j in fac do
66227: LD_ADDR_VAR 0 3
66231: PUSH
66232: LD_VAR 0 5
66236: PUSH
66237: FOR_IN
66238: IFFALSE 66593
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
66240: LD_VAR 0 3
66244: PPUSH
66245: CALL_OW 461
66249: PUSH
66250: LD_INT 2
66252: NONEQUAL
66253: PUSH
66254: LD_VAR 0 3
66258: PPUSH
66259: LD_INT 15
66261: PPUSH
66262: CALL 21831 0 2
66266: PUSH
66267: LD_INT 4
66269: ARRAY
66270: OR
66271: IFFALSE 66275
// continue ;
66273: GO 66237
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
66275: LD_VAR 0 3
66279: PPUSH
66280: LD_EXP 80
66284: PUSH
66285: LD_VAR 0 2
66289: ARRAY
66290: PUSH
66291: LD_INT 1
66293: ARRAY
66294: PUSH
66295: LD_INT 1
66297: ARRAY
66298: PPUSH
66299: LD_EXP 80
66303: PUSH
66304: LD_VAR 0 2
66308: ARRAY
66309: PUSH
66310: LD_INT 1
66312: ARRAY
66313: PUSH
66314: LD_INT 2
66316: ARRAY
66317: PPUSH
66318: LD_EXP 80
66322: PUSH
66323: LD_VAR 0 2
66327: ARRAY
66328: PUSH
66329: LD_INT 1
66331: ARRAY
66332: PUSH
66333: LD_INT 3
66335: ARRAY
66336: PPUSH
66337: LD_EXP 80
66341: PUSH
66342: LD_VAR 0 2
66346: ARRAY
66347: PUSH
66348: LD_INT 1
66350: ARRAY
66351: PUSH
66352: LD_INT 4
66354: ARRAY
66355: PPUSH
66356: CALL_OW 448
66360: PUSH
66361: LD_VAR 0 3
66365: PPUSH
66366: LD_EXP 80
66370: PUSH
66371: LD_VAR 0 2
66375: ARRAY
66376: PUSH
66377: LD_INT 1
66379: ARRAY
66380: PUSH
66381: LD_INT 1
66383: ARRAY
66384: PUSH
66385: LD_EXP 80
66389: PUSH
66390: LD_VAR 0 2
66394: ARRAY
66395: PUSH
66396: LD_INT 1
66398: ARRAY
66399: PUSH
66400: LD_INT 2
66402: ARRAY
66403: PUSH
66404: LD_EXP 80
66408: PUSH
66409: LD_VAR 0 2
66413: ARRAY
66414: PUSH
66415: LD_INT 1
66417: ARRAY
66418: PUSH
66419: LD_INT 3
66421: ARRAY
66422: PUSH
66423: LD_EXP 80
66427: PUSH
66428: LD_VAR 0 2
66432: ARRAY
66433: PUSH
66434: LD_INT 1
66436: ARRAY
66437: PUSH
66438: LD_INT 4
66440: ARRAY
66441: PUSH
66442: EMPTY
66443: LIST
66444: LIST
66445: LIST
66446: LIST
66447: PPUSH
66448: CALL 25502 0 2
66452: AND
66453: IFFALSE 66591
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66455: LD_VAR 0 3
66459: PPUSH
66460: LD_EXP 80
66464: PUSH
66465: LD_VAR 0 2
66469: ARRAY
66470: PUSH
66471: LD_INT 1
66473: ARRAY
66474: PUSH
66475: LD_INT 1
66477: ARRAY
66478: PPUSH
66479: LD_EXP 80
66483: PUSH
66484: LD_VAR 0 2
66488: ARRAY
66489: PUSH
66490: LD_INT 1
66492: ARRAY
66493: PUSH
66494: LD_INT 2
66496: ARRAY
66497: PPUSH
66498: LD_EXP 80
66502: PUSH
66503: LD_VAR 0 2
66507: ARRAY
66508: PUSH
66509: LD_INT 1
66511: ARRAY
66512: PUSH
66513: LD_INT 3
66515: ARRAY
66516: PPUSH
66517: LD_EXP 80
66521: PUSH
66522: LD_VAR 0 2
66526: ARRAY
66527: PUSH
66528: LD_INT 1
66530: ARRAY
66531: PUSH
66532: LD_INT 4
66534: ARRAY
66535: PPUSH
66536: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66540: LD_ADDR_VAR 0 4
66544: PUSH
66545: LD_EXP 80
66549: PUSH
66550: LD_VAR 0 2
66554: ARRAY
66555: PPUSH
66556: LD_INT 1
66558: PPUSH
66559: CALL_OW 3
66563: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66564: LD_ADDR_EXP 80
66568: PUSH
66569: LD_EXP 80
66573: PPUSH
66574: LD_VAR 0 2
66578: PPUSH
66579: LD_VAR 0 4
66583: PPUSH
66584: CALL_OW 1
66588: ST_TO_ADDR
// break ;
66589: GO 66593
// end ; end ;
66591: GO 66237
66593: POP
66594: POP
// end ;
66595: GO 66169
66597: POP
66598: POP
// end ;
66599: LD_VAR 0 1
66603: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
66604: LD_INT 0
66606: PPUSH
66607: PPUSH
66608: PPUSH
// if not mc_bases then
66609: LD_EXP 59
66613: NOT
66614: IFFALSE 66618
// exit ;
66616: GO 66707
// for i = 1 to mc_bases do
66618: LD_ADDR_VAR 0 2
66622: PUSH
66623: DOUBLE
66624: LD_INT 1
66626: DEC
66627: ST_TO_ADDR
66628: LD_EXP 59
66632: PUSH
66633: FOR_TO
66634: IFFALSE 66705
// begin if mc_attack [ i ] then
66636: LD_EXP 79
66640: PUSH
66641: LD_VAR 0 2
66645: ARRAY
66646: IFFALSE 66703
// begin tmp := mc_attack [ i ] [ 1 ] ;
66648: LD_ADDR_VAR 0 3
66652: PUSH
66653: LD_EXP 79
66657: PUSH
66658: LD_VAR 0 2
66662: ARRAY
66663: PUSH
66664: LD_INT 1
66666: ARRAY
66667: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
66668: LD_ADDR_EXP 79
66672: PUSH
66673: LD_EXP 79
66677: PPUSH
66678: LD_VAR 0 2
66682: PPUSH
66683: EMPTY
66684: PPUSH
66685: CALL_OW 1
66689: ST_TO_ADDR
// Attack ( tmp ) ;
66690: LD_VAR 0 3
66694: PPUSH
66695: CALL 98427 0 1
// exit ;
66699: POP
66700: POP
66701: GO 66707
// end ; end ;
66703: GO 66633
66705: POP
66706: POP
// end ;
66707: LD_VAR 0 1
66711: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
66712: LD_INT 0
66714: PPUSH
66715: PPUSH
66716: PPUSH
66717: PPUSH
66718: PPUSH
66719: PPUSH
66720: PPUSH
// if not mc_bases then
66721: LD_EXP 59
66725: NOT
66726: IFFALSE 66730
// exit ;
66728: GO 67312
// for i = 1 to mc_bases do
66730: LD_ADDR_VAR 0 2
66734: PUSH
66735: DOUBLE
66736: LD_INT 1
66738: DEC
66739: ST_TO_ADDR
66740: LD_EXP 59
66744: PUSH
66745: FOR_TO
66746: IFFALSE 67310
// begin if not mc_bases [ i ] then
66748: LD_EXP 59
66752: PUSH
66753: LD_VAR 0 2
66757: ARRAY
66758: NOT
66759: IFFALSE 66763
// continue ;
66761: GO 66745
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
66763: LD_ADDR_VAR 0 7
66767: PUSH
66768: LD_EXP 59
66772: PUSH
66773: LD_VAR 0 2
66777: ARRAY
66778: PUSH
66779: LD_INT 1
66781: ARRAY
66782: PPUSH
66783: CALL 16074 0 1
66787: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
66788: LD_ADDR_EXP 82
66792: PUSH
66793: LD_EXP 82
66797: PPUSH
66798: LD_VAR 0 2
66802: PPUSH
66803: LD_EXP 59
66807: PUSH
66808: LD_VAR 0 2
66812: ARRAY
66813: PUSH
66814: LD_INT 1
66816: ARRAY
66817: PPUSH
66818: CALL_OW 255
66822: PPUSH
66823: LD_EXP 84
66827: PUSH
66828: LD_VAR 0 2
66832: ARRAY
66833: PPUSH
66834: CALL 16039 0 2
66838: PPUSH
66839: CALL_OW 1
66843: ST_TO_ADDR
// if not mc_scan [ i ] then
66844: LD_EXP 82
66848: PUSH
66849: LD_VAR 0 2
66853: ARRAY
66854: NOT
66855: IFFALSE 67010
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66857: LD_ADDR_VAR 0 4
66861: PUSH
66862: LD_EXP 59
66866: PUSH
66867: LD_VAR 0 2
66871: ARRAY
66872: PPUSH
66873: LD_INT 2
66875: PUSH
66876: LD_INT 25
66878: PUSH
66879: LD_INT 5
66881: PUSH
66882: EMPTY
66883: LIST
66884: LIST
66885: PUSH
66886: LD_INT 25
66888: PUSH
66889: LD_INT 8
66891: PUSH
66892: EMPTY
66893: LIST
66894: LIST
66895: PUSH
66896: LD_INT 25
66898: PUSH
66899: LD_INT 9
66901: PUSH
66902: EMPTY
66903: LIST
66904: LIST
66905: PUSH
66906: EMPTY
66907: LIST
66908: LIST
66909: LIST
66910: LIST
66911: PPUSH
66912: CALL_OW 72
66916: ST_TO_ADDR
// if not tmp then
66917: LD_VAR 0 4
66921: NOT
66922: IFFALSE 66926
// continue ;
66924: GO 66745
// for j in tmp do
66926: LD_ADDR_VAR 0 3
66930: PUSH
66931: LD_VAR 0 4
66935: PUSH
66936: FOR_IN
66937: IFFALSE 67008
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
66939: LD_VAR 0 3
66943: PPUSH
66944: CALL_OW 310
66948: PPUSH
66949: CALL_OW 266
66953: PUSH
66954: LD_INT 5
66956: EQUAL
66957: PUSH
66958: LD_VAR 0 3
66962: PPUSH
66963: CALL_OW 257
66967: PUSH
66968: LD_INT 1
66970: EQUAL
66971: AND
66972: PUSH
66973: LD_VAR 0 3
66977: PPUSH
66978: CALL_OW 459
66982: NOT
66983: AND
66984: PUSH
66985: LD_VAR 0 7
66989: AND
66990: IFFALSE 67006
// ComChangeProfession ( j , class ) ;
66992: LD_VAR 0 3
66996: PPUSH
66997: LD_VAR 0 7
67001: PPUSH
67002: CALL_OW 123
67006: GO 66936
67008: POP
67009: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67010: LD_EXP 82
67014: PUSH
67015: LD_VAR 0 2
67019: ARRAY
67020: PUSH
67021: LD_EXP 81
67025: PUSH
67026: LD_VAR 0 2
67030: ARRAY
67031: NOT
67032: AND
67033: PUSH
67034: LD_EXP 59
67038: PUSH
67039: LD_VAR 0 2
67043: ARRAY
67044: PPUSH
67045: LD_INT 30
67047: PUSH
67048: LD_INT 32
67050: PUSH
67051: EMPTY
67052: LIST
67053: LIST
67054: PPUSH
67055: CALL_OW 72
67059: NOT
67060: AND
67061: PUSH
67062: LD_EXP 59
67066: PUSH
67067: LD_VAR 0 2
67071: ARRAY
67072: PPUSH
67073: LD_INT 2
67075: PUSH
67076: LD_INT 30
67078: PUSH
67079: LD_INT 4
67081: PUSH
67082: EMPTY
67083: LIST
67084: LIST
67085: PUSH
67086: LD_INT 30
67088: PUSH
67089: LD_INT 5
67091: PUSH
67092: EMPTY
67093: LIST
67094: LIST
67095: PUSH
67096: EMPTY
67097: LIST
67098: LIST
67099: LIST
67100: PPUSH
67101: CALL_OW 72
67105: NOT
67106: AND
67107: IFFALSE 67239
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67109: LD_ADDR_VAR 0 4
67113: PUSH
67114: LD_EXP 59
67118: PUSH
67119: LD_VAR 0 2
67123: ARRAY
67124: PPUSH
67125: LD_INT 2
67127: PUSH
67128: LD_INT 25
67130: PUSH
67131: LD_INT 1
67133: PUSH
67134: EMPTY
67135: LIST
67136: LIST
67137: PUSH
67138: LD_INT 25
67140: PUSH
67141: LD_INT 5
67143: PUSH
67144: EMPTY
67145: LIST
67146: LIST
67147: PUSH
67148: LD_INT 25
67150: PUSH
67151: LD_INT 8
67153: PUSH
67154: EMPTY
67155: LIST
67156: LIST
67157: PUSH
67158: LD_INT 25
67160: PUSH
67161: LD_INT 9
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: PUSH
67168: EMPTY
67169: LIST
67170: LIST
67171: LIST
67172: LIST
67173: LIST
67174: PPUSH
67175: CALL_OW 72
67179: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
67180: LD_ADDR_VAR 0 4
67184: PUSH
67185: LD_VAR 0 4
67189: PUSH
67190: LD_VAR 0 4
67194: PPUSH
67195: LD_INT 18
67197: PPUSH
67198: CALL 47799 0 2
67202: DIFF
67203: ST_TO_ADDR
// if tmp then
67204: LD_VAR 0 4
67208: IFFALSE 67239
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
67210: LD_VAR 0 2
67214: PPUSH
67215: LD_VAR 0 4
67219: PPUSH
67220: LD_EXP 84
67224: PUSH
67225: LD_VAR 0 2
67229: ARRAY
67230: PPUSH
67231: CALL 103136 0 3
// exit ;
67235: POP
67236: POP
67237: GO 67312
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
67239: LD_EXP 82
67243: PUSH
67244: LD_VAR 0 2
67248: ARRAY
67249: PUSH
67250: LD_EXP 81
67254: PUSH
67255: LD_VAR 0 2
67259: ARRAY
67260: AND
67261: IFFALSE 67308
// begin tmp := mc_defender [ i ] ;
67263: LD_ADDR_VAR 0 4
67267: PUSH
67268: LD_EXP 81
67272: PUSH
67273: LD_VAR 0 2
67277: ARRAY
67278: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
67279: LD_VAR 0 2
67283: PPUSH
67284: LD_VAR 0 4
67288: PPUSH
67289: LD_EXP 82
67293: PUSH
67294: LD_VAR 0 2
67298: ARRAY
67299: PPUSH
67300: CALL 103697 0 3
// exit ;
67304: POP
67305: POP
67306: GO 67312
// end ; end ;
67308: GO 66745
67310: POP
67311: POP
// end ;
67312: LD_VAR 0 1
67316: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
67317: LD_INT 0
67319: PPUSH
67320: PPUSH
67321: PPUSH
67322: PPUSH
67323: PPUSH
67324: PPUSH
67325: PPUSH
67326: PPUSH
67327: PPUSH
67328: PPUSH
67329: PPUSH
// if not mc_bases then
67330: LD_EXP 59
67334: NOT
67335: IFFALSE 67339
// exit ;
67337: GO 68426
// for i = 1 to mc_bases do
67339: LD_ADDR_VAR 0 2
67343: PUSH
67344: DOUBLE
67345: LD_INT 1
67347: DEC
67348: ST_TO_ADDR
67349: LD_EXP 59
67353: PUSH
67354: FOR_TO
67355: IFFALSE 68424
// begin tmp := mc_lab [ i ] ;
67357: LD_ADDR_VAR 0 6
67361: PUSH
67362: LD_EXP 92
67366: PUSH
67367: LD_VAR 0 2
67371: ARRAY
67372: ST_TO_ADDR
// if not tmp then
67373: LD_VAR 0 6
67377: NOT
67378: IFFALSE 67382
// continue ;
67380: GO 67354
// idle_lab := 0 ;
67382: LD_ADDR_VAR 0 11
67386: PUSH
67387: LD_INT 0
67389: ST_TO_ADDR
// for j in tmp do
67390: LD_ADDR_VAR 0 3
67394: PUSH
67395: LD_VAR 0 6
67399: PUSH
67400: FOR_IN
67401: IFFALSE 68420
// begin researching := false ;
67403: LD_ADDR_VAR 0 10
67407: PUSH
67408: LD_INT 0
67410: ST_TO_ADDR
// side := GetSide ( j ) ;
67411: LD_ADDR_VAR 0 4
67415: PUSH
67416: LD_VAR 0 3
67420: PPUSH
67421: CALL_OW 255
67425: ST_TO_ADDR
// if not mc_tech [ side ] then
67426: LD_EXP 86
67430: PUSH
67431: LD_VAR 0 4
67435: ARRAY
67436: NOT
67437: IFFALSE 67441
// continue ;
67439: GO 67400
// if BuildingStatus ( j ) = bs_idle then
67441: LD_VAR 0 3
67445: PPUSH
67446: CALL_OW 461
67450: PUSH
67451: LD_INT 2
67453: EQUAL
67454: IFFALSE 67642
// begin if idle_lab and UnitsInside ( j ) < 6 then
67456: LD_VAR 0 11
67460: PUSH
67461: LD_VAR 0 3
67465: PPUSH
67466: CALL_OW 313
67470: PUSH
67471: LD_INT 6
67473: LESS
67474: AND
67475: IFFALSE 67546
// begin tmp2 := UnitsInside ( idle_lab ) ;
67477: LD_ADDR_VAR 0 9
67481: PUSH
67482: LD_VAR 0 11
67486: PPUSH
67487: CALL_OW 313
67491: ST_TO_ADDR
// if tmp2 then
67492: LD_VAR 0 9
67496: IFFALSE 67538
// for x in tmp2 do
67498: LD_ADDR_VAR 0 7
67502: PUSH
67503: LD_VAR 0 9
67507: PUSH
67508: FOR_IN
67509: IFFALSE 67536
// begin ComExitBuilding ( x ) ;
67511: LD_VAR 0 7
67515: PPUSH
67516: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
67520: LD_VAR 0 7
67524: PPUSH
67525: LD_VAR 0 3
67529: PPUSH
67530: CALL_OW 180
// end ;
67534: GO 67508
67536: POP
67537: POP
// idle_lab := 0 ;
67538: LD_ADDR_VAR 0 11
67542: PUSH
67543: LD_INT 0
67545: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
67546: LD_ADDR_VAR 0 5
67550: PUSH
67551: LD_EXP 86
67555: PUSH
67556: LD_VAR 0 4
67560: ARRAY
67561: PUSH
67562: FOR_IN
67563: IFFALSE 67623
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
67565: LD_VAR 0 3
67569: PPUSH
67570: LD_VAR 0 5
67574: PPUSH
67575: CALL_OW 430
67579: PUSH
67580: LD_VAR 0 4
67584: PPUSH
67585: LD_VAR 0 5
67589: PPUSH
67590: CALL 15144 0 2
67594: AND
67595: IFFALSE 67621
// begin researching := true ;
67597: LD_ADDR_VAR 0 10
67601: PUSH
67602: LD_INT 1
67604: ST_TO_ADDR
// ComResearch ( j , t ) ;
67605: LD_VAR 0 3
67609: PPUSH
67610: LD_VAR 0 5
67614: PPUSH
67615: CALL_OW 124
// break ;
67619: GO 67623
// end ;
67621: GO 67562
67623: POP
67624: POP
// if not researching then
67625: LD_VAR 0 10
67629: NOT
67630: IFFALSE 67642
// idle_lab := j ;
67632: LD_ADDR_VAR 0 11
67636: PUSH
67637: LD_VAR 0 3
67641: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
67642: LD_VAR 0 3
67646: PPUSH
67647: CALL_OW 461
67651: PUSH
67652: LD_INT 10
67654: EQUAL
67655: IFFALSE 68243
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
67657: LD_EXP 88
67661: PUSH
67662: LD_VAR 0 2
67666: ARRAY
67667: NOT
67668: PUSH
67669: LD_EXP 89
67673: PUSH
67674: LD_VAR 0 2
67678: ARRAY
67679: NOT
67680: AND
67681: PUSH
67682: LD_EXP 86
67686: PUSH
67687: LD_VAR 0 4
67691: ARRAY
67692: PUSH
67693: LD_INT 1
67695: GREATER
67696: AND
67697: IFFALSE 67828
// begin ComCancel ( j ) ;
67699: LD_VAR 0 3
67703: PPUSH
67704: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
67708: LD_ADDR_EXP 86
67712: PUSH
67713: LD_EXP 86
67717: PPUSH
67718: LD_VAR 0 4
67722: PPUSH
67723: LD_EXP 86
67727: PUSH
67728: LD_VAR 0 4
67732: ARRAY
67733: PPUSH
67734: LD_EXP 86
67738: PUSH
67739: LD_VAR 0 4
67743: ARRAY
67744: PUSH
67745: LD_INT 1
67747: MINUS
67748: PPUSH
67749: LD_EXP 86
67753: PUSH
67754: LD_VAR 0 4
67758: ARRAY
67759: PPUSH
67760: LD_INT 0
67762: PPUSH
67763: CALL 18656 0 4
67767: PPUSH
67768: CALL_OW 1
67772: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
67773: LD_ADDR_EXP 86
67777: PUSH
67778: LD_EXP 86
67782: PPUSH
67783: LD_VAR 0 4
67787: PPUSH
67788: LD_EXP 86
67792: PUSH
67793: LD_VAR 0 4
67797: ARRAY
67798: PPUSH
67799: LD_EXP 86
67803: PUSH
67804: LD_VAR 0 4
67808: ARRAY
67809: PPUSH
67810: LD_INT 1
67812: PPUSH
67813: LD_INT 0
67815: PPUSH
67816: CALL 18656 0 4
67820: PPUSH
67821: CALL_OW 1
67825: ST_TO_ADDR
// continue ;
67826: GO 67400
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
67828: LD_EXP 88
67832: PUSH
67833: LD_VAR 0 2
67837: ARRAY
67838: PUSH
67839: LD_EXP 89
67843: PUSH
67844: LD_VAR 0 2
67848: ARRAY
67849: NOT
67850: AND
67851: IFFALSE 67978
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
67853: LD_ADDR_EXP 89
67857: PUSH
67858: LD_EXP 89
67862: PPUSH
67863: LD_VAR 0 2
67867: PUSH
67868: LD_EXP 89
67872: PUSH
67873: LD_VAR 0 2
67877: ARRAY
67878: PUSH
67879: LD_INT 1
67881: PLUS
67882: PUSH
67883: EMPTY
67884: LIST
67885: LIST
67886: PPUSH
67887: LD_EXP 88
67891: PUSH
67892: LD_VAR 0 2
67896: ARRAY
67897: PUSH
67898: LD_INT 1
67900: ARRAY
67901: PPUSH
67902: CALL 19238 0 3
67906: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
67907: LD_EXP 88
67911: PUSH
67912: LD_VAR 0 2
67916: ARRAY
67917: PUSH
67918: LD_INT 1
67920: ARRAY
67921: PPUSH
67922: LD_INT 112
67924: PPUSH
67925: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
67929: LD_ADDR_VAR 0 9
67933: PUSH
67934: LD_EXP 88
67938: PUSH
67939: LD_VAR 0 2
67943: ARRAY
67944: PPUSH
67945: LD_INT 1
67947: PPUSH
67948: CALL_OW 3
67952: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
67953: LD_ADDR_EXP 88
67957: PUSH
67958: LD_EXP 88
67962: PPUSH
67963: LD_VAR 0 2
67967: PPUSH
67968: LD_VAR 0 9
67972: PPUSH
67973: CALL_OW 1
67977: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
67978: LD_EXP 88
67982: PUSH
67983: LD_VAR 0 2
67987: ARRAY
67988: PUSH
67989: LD_EXP 89
67993: PUSH
67994: LD_VAR 0 2
67998: ARRAY
67999: AND
68000: PUSH
68001: LD_EXP 89
68005: PUSH
68006: LD_VAR 0 2
68010: ARRAY
68011: PUSH
68012: LD_INT 1
68014: ARRAY
68015: PPUSH
68016: CALL_OW 310
68020: NOT
68021: AND
68022: PUSH
68023: LD_VAR 0 3
68027: PPUSH
68028: CALL_OW 313
68032: PUSH
68033: LD_INT 6
68035: EQUAL
68036: AND
68037: IFFALSE 68093
// begin tmp2 := UnitsInside ( j ) ;
68039: LD_ADDR_VAR 0 9
68043: PUSH
68044: LD_VAR 0 3
68048: PPUSH
68049: CALL_OW 313
68053: ST_TO_ADDR
// if tmp2 = 6 then
68054: LD_VAR 0 9
68058: PUSH
68059: LD_INT 6
68061: EQUAL
68062: IFFALSE 68093
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
68064: LD_VAR 0 9
68068: PUSH
68069: LD_INT 1
68071: ARRAY
68072: PPUSH
68073: LD_INT 112
68075: PPUSH
68076: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
68080: LD_VAR 0 9
68084: PUSH
68085: LD_INT 1
68087: ARRAY
68088: PPUSH
68089: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
68093: LD_EXP 89
68097: PUSH
68098: LD_VAR 0 2
68102: ARRAY
68103: PUSH
68104: LD_EXP 89
68108: PUSH
68109: LD_VAR 0 2
68113: ARRAY
68114: PUSH
68115: LD_INT 1
68117: ARRAY
68118: PPUSH
68119: CALL_OW 314
68123: NOT
68124: AND
68125: PUSH
68126: LD_EXP 89
68130: PUSH
68131: LD_VAR 0 2
68135: ARRAY
68136: PUSH
68137: LD_INT 1
68139: ARRAY
68140: PPUSH
68141: CALL_OW 310
68145: NOT
68146: AND
68147: IFFALSE 68173
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
68149: LD_EXP 89
68153: PUSH
68154: LD_VAR 0 2
68158: ARRAY
68159: PUSH
68160: LD_INT 1
68162: ARRAY
68163: PPUSH
68164: LD_VAR 0 3
68168: PPUSH
68169: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
68173: LD_EXP 89
68177: PUSH
68178: LD_VAR 0 2
68182: ARRAY
68183: PUSH
68184: LD_INT 1
68186: ARRAY
68187: PPUSH
68188: CALL_OW 310
68192: PUSH
68193: LD_EXP 89
68197: PUSH
68198: LD_VAR 0 2
68202: ARRAY
68203: PUSH
68204: LD_INT 1
68206: ARRAY
68207: PPUSH
68208: CALL_OW 310
68212: PPUSH
68213: CALL_OW 461
68217: PUSH
68218: LD_INT 3
68220: NONEQUAL
68221: AND
68222: IFFALSE 68243
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
68224: LD_EXP 89
68228: PUSH
68229: LD_VAR 0 2
68233: ARRAY
68234: PUSH
68235: LD_INT 1
68237: ARRAY
68238: PPUSH
68239: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
68243: LD_VAR 0 3
68247: PPUSH
68248: CALL_OW 461
68252: PUSH
68253: LD_INT 6
68255: EQUAL
68256: PUSH
68257: LD_VAR 0 6
68261: PUSH
68262: LD_INT 1
68264: GREATER
68265: AND
68266: IFFALSE 68418
// begin sci := [ ] ;
68268: LD_ADDR_VAR 0 8
68272: PUSH
68273: EMPTY
68274: ST_TO_ADDR
// for x in ( tmp diff j ) do
68275: LD_ADDR_VAR 0 7
68279: PUSH
68280: LD_VAR 0 6
68284: PUSH
68285: LD_VAR 0 3
68289: DIFF
68290: PUSH
68291: FOR_IN
68292: IFFALSE 68344
// begin if sci = 6 then
68294: LD_VAR 0 8
68298: PUSH
68299: LD_INT 6
68301: EQUAL
68302: IFFALSE 68306
// break ;
68304: GO 68344
// if BuildingStatus ( x ) = bs_idle then
68306: LD_VAR 0 7
68310: PPUSH
68311: CALL_OW 461
68315: PUSH
68316: LD_INT 2
68318: EQUAL
68319: IFFALSE 68342
// sci := sci ^ UnitsInside ( x ) ;
68321: LD_ADDR_VAR 0 8
68325: PUSH
68326: LD_VAR 0 8
68330: PUSH
68331: LD_VAR 0 7
68335: PPUSH
68336: CALL_OW 313
68340: ADD
68341: ST_TO_ADDR
// end ;
68342: GO 68291
68344: POP
68345: POP
// if not sci then
68346: LD_VAR 0 8
68350: NOT
68351: IFFALSE 68355
// continue ;
68353: GO 67400
// for x in sci do
68355: LD_ADDR_VAR 0 7
68359: PUSH
68360: LD_VAR 0 8
68364: PUSH
68365: FOR_IN
68366: IFFALSE 68416
// if IsInUnit ( x ) and not HasTask ( x ) then
68368: LD_VAR 0 7
68372: PPUSH
68373: CALL_OW 310
68377: PUSH
68378: LD_VAR 0 7
68382: PPUSH
68383: CALL_OW 314
68387: NOT
68388: AND
68389: IFFALSE 68414
// begin ComExitBuilding ( x ) ;
68391: LD_VAR 0 7
68395: PPUSH
68396: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68400: LD_VAR 0 7
68404: PPUSH
68405: LD_VAR 0 3
68409: PPUSH
68410: CALL_OW 180
// end ;
68414: GO 68365
68416: POP
68417: POP
// end ; end ;
68418: GO 67400
68420: POP
68421: POP
// end ;
68422: GO 67354
68424: POP
68425: POP
// end ;
68426: LD_VAR 0 1
68430: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
68431: LD_INT 0
68433: PPUSH
68434: PPUSH
// if not mc_bases then
68435: LD_EXP 59
68439: NOT
68440: IFFALSE 68444
// exit ;
68442: GO 68525
// for i = 1 to mc_bases do
68444: LD_ADDR_VAR 0 2
68448: PUSH
68449: DOUBLE
68450: LD_INT 1
68452: DEC
68453: ST_TO_ADDR
68454: LD_EXP 59
68458: PUSH
68459: FOR_TO
68460: IFFALSE 68523
// if mc_mines [ i ] and mc_miners [ i ] then
68462: LD_EXP 72
68466: PUSH
68467: LD_VAR 0 2
68471: ARRAY
68472: PUSH
68473: LD_EXP 73
68477: PUSH
68478: LD_VAR 0 2
68482: ARRAY
68483: AND
68484: IFFALSE 68521
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
68486: LD_EXP 73
68490: PUSH
68491: LD_VAR 0 2
68495: ARRAY
68496: PUSH
68497: LD_INT 1
68499: ARRAY
68500: PPUSH
68501: CALL_OW 255
68505: PPUSH
68506: LD_EXP 72
68510: PUSH
68511: LD_VAR 0 2
68515: ARRAY
68516: PPUSH
68517: CALL 16227 0 2
68521: GO 68459
68523: POP
68524: POP
// end ;
68525: LD_VAR 0 1
68529: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
68530: LD_INT 0
68532: PPUSH
68533: PPUSH
68534: PPUSH
68535: PPUSH
68536: PPUSH
68537: PPUSH
68538: PPUSH
68539: PPUSH
// if not mc_bases or not mc_parking then
68540: LD_EXP 59
68544: NOT
68545: PUSH
68546: LD_EXP 83
68550: NOT
68551: OR
68552: IFFALSE 68556
// exit ;
68554: GO 69255
// for i = 1 to mc_bases do
68556: LD_ADDR_VAR 0 2
68560: PUSH
68561: DOUBLE
68562: LD_INT 1
68564: DEC
68565: ST_TO_ADDR
68566: LD_EXP 59
68570: PUSH
68571: FOR_TO
68572: IFFALSE 69253
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
68574: LD_EXP 59
68578: PUSH
68579: LD_VAR 0 2
68583: ARRAY
68584: NOT
68585: PUSH
68586: LD_EXP 83
68590: PUSH
68591: LD_VAR 0 2
68595: ARRAY
68596: NOT
68597: OR
68598: IFFALSE 68602
// continue ;
68600: GO 68571
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68602: LD_ADDR_VAR 0 5
68606: PUSH
68607: LD_EXP 59
68611: PUSH
68612: LD_VAR 0 2
68616: ARRAY
68617: PUSH
68618: LD_INT 1
68620: ARRAY
68621: PPUSH
68622: CALL_OW 255
68626: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68627: LD_ADDR_VAR 0 6
68631: PUSH
68632: LD_EXP 59
68636: PUSH
68637: LD_VAR 0 2
68641: ARRAY
68642: PPUSH
68643: LD_INT 30
68645: PUSH
68646: LD_INT 3
68648: PUSH
68649: EMPTY
68650: LIST
68651: LIST
68652: PPUSH
68653: CALL_OW 72
68657: ST_TO_ADDR
// if not fac then
68658: LD_VAR 0 6
68662: NOT
68663: IFFALSE 68714
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68665: LD_ADDR_VAR 0 6
68669: PUSH
68670: LD_EXP 59
68674: PUSH
68675: LD_VAR 0 2
68679: ARRAY
68680: PPUSH
68681: LD_INT 2
68683: PUSH
68684: LD_INT 30
68686: PUSH
68687: LD_INT 0
68689: PUSH
68690: EMPTY
68691: LIST
68692: LIST
68693: PUSH
68694: LD_INT 30
68696: PUSH
68697: LD_INT 1
68699: PUSH
68700: EMPTY
68701: LIST
68702: LIST
68703: PUSH
68704: EMPTY
68705: LIST
68706: LIST
68707: LIST
68708: PPUSH
68709: CALL_OW 72
68713: ST_TO_ADDR
// if not fac then
68714: LD_VAR 0 6
68718: NOT
68719: IFFALSE 68723
// continue ;
68721: GO 68571
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68723: LD_ADDR_VAR 0 7
68727: PUSH
68728: LD_EXP 83
68732: PUSH
68733: LD_VAR 0 2
68737: ARRAY
68738: PPUSH
68739: LD_INT 22
68741: PUSH
68742: LD_VAR 0 5
68746: PUSH
68747: EMPTY
68748: LIST
68749: LIST
68750: PUSH
68751: LD_INT 21
68753: PUSH
68754: LD_INT 2
68756: PUSH
68757: EMPTY
68758: LIST
68759: LIST
68760: PUSH
68761: LD_INT 3
68763: PUSH
68764: LD_INT 24
68766: PUSH
68767: LD_INT 1000
68769: PUSH
68770: EMPTY
68771: LIST
68772: LIST
68773: PUSH
68774: EMPTY
68775: LIST
68776: LIST
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: LIST
68782: PPUSH
68783: CALL_OW 70
68787: ST_TO_ADDR
// for j in fac do
68788: LD_ADDR_VAR 0 3
68792: PUSH
68793: LD_VAR 0 6
68797: PUSH
68798: FOR_IN
68799: IFFALSE 68880
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68801: LD_ADDR_VAR 0 7
68805: PUSH
68806: LD_VAR 0 7
68810: PUSH
68811: LD_INT 22
68813: PUSH
68814: LD_VAR 0 5
68818: PUSH
68819: EMPTY
68820: LIST
68821: LIST
68822: PUSH
68823: LD_INT 91
68825: PUSH
68826: LD_VAR 0 3
68830: PUSH
68831: LD_INT 15
68833: PUSH
68834: EMPTY
68835: LIST
68836: LIST
68837: LIST
68838: PUSH
68839: LD_INT 21
68841: PUSH
68842: LD_INT 2
68844: PUSH
68845: EMPTY
68846: LIST
68847: LIST
68848: PUSH
68849: LD_INT 3
68851: PUSH
68852: LD_INT 24
68854: PUSH
68855: LD_INT 1000
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: PUSH
68862: EMPTY
68863: LIST
68864: LIST
68865: PUSH
68866: EMPTY
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: PPUSH
68872: CALL_OW 69
68876: UNION
68877: ST_TO_ADDR
68878: GO 68798
68880: POP
68881: POP
// if not vehs then
68882: LD_VAR 0 7
68886: NOT
68887: IFFALSE 68913
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
68889: LD_ADDR_EXP 71
68893: PUSH
68894: LD_EXP 71
68898: PPUSH
68899: LD_VAR 0 2
68903: PPUSH
68904: EMPTY
68905: PPUSH
68906: CALL_OW 1
68910: ST_TO_ADDR
// continue ;
68911: GO 68571
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68913: LD_ADDR_VAR 0 8
68917: PUSH
68918: LD_EXP 59
68922: PUSH
68923: LD_VAR 0 2
68927: ARRAY
68928: PPUSH
68929: LD_INT 30
68931: PUSH
68932: LD_INT 3
68934: PUSH
68935: EMPTY
68936: LIST
68937: LIST
68938: PPUSH
68939: CALL_OW 72
68943: ST_TO_ADDR
// if tmp then
68944: LD_VAR 0 8
68948: IFFALSE 69051
// begin for j in tmp do
68950: LD_ADDR_VAR 0 3
68954: PUSH
68955: LD_VAR 0 8
68959: PUSH
68960: FOR_IN
68961: IFFALSE 69049
// for k in UnitsInside ( j ) do
68963: LD_ADDR_VAR 0 4
68967: PUSH
68968: LD_VAR 0 3
68972: PPUSH
68973: CALL_OW 313
68977: PUSH
68978: FOR_IN
68979: IFFALSE 69045
// if k then
68981: LD_VAR 0 4
68985: IFFALSE 69043
// if not k in mc_repair_vehicle [ i ] then
68987: LD_VAR 0 4
68991: PUSH
68992: LD_EXP 71
68996: PUSH
68997: LD_VAR 0 2
69001: ARRAY
69002: IN
69003: NOT
69004: IFFALSE 69043
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
69006: LD_ADDR_EXP 71
69010: PUSH
69011: LD_EXP 71
69015: PPUSH
69016: LD_VAR 0 2
69020: PPUSH
69021: LD_EXP 71
69025: PUSH
69026: LD_VAR 0 2
69030: ARRAY
69031: PUSH
69032: LD_VAR 0 4
69036: UNION
69037: PPUSH
69038: CALL_OW 1
69042: ST_TO_ADDR
69043: GO 68978
69045: POP
69046: POP
69047: GO 68960
69049: POP
69050: POP
// end ; if not mc_repair_vehicle [ i ] then
69051: LD_EXP 71
69055: PUSH
69056: LD_VAR 0 2
69060: ARRAY
69061: NOT
69062: IFFALSE 69066
// continue ;
69064: GO 68571
// for j in mc_repair_vehicle [ i ] do
69066: LD_ADDR_VAR 0 3
69070: PUSH
69071: LD_EXP 71
69075: PUSH
69076: LD_VAR 0 2
69080: ARRAY
69081: PUSH
69082: FOR_IN
69083: IFFALSE 69249
// begin if GetClass ( j ) <> 3 then
69085: LD_VAR 0 3
69089: PPUSH
69090: CALL_OW 257
69094: PUSH
69095: LD_INT 3
69097: NONEQUAL
69098: IFFALSE 69139
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
69100: LD_ADDR_EXP 71
69104: PUSH
69105: LD_EXP 71
69109: PPUSH
69110: LD_VAR 0 2
69114: PPUSH
69115: LD_EXP 71
69119: PUSH
69120: LD_VAR 0 2
69124: ARRAY
69125: PUSH
69126: LD_VAR 0 3
69130: DIFF
69131: PPUSH
69132: CALL_OW 1
69136: ST_TO_ADDR
// continue ;
69137: GO 69082
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69139: LD_VAR 0 3
69143: PPUSH
69144: CALL_OW 311
69148: NOT
69149: PUSH
69150: LD_VAR 0 3
69154: PUSH
69155: LD_EXP 62
69159: PUSH
69160: LD_VAR 0 2
69164: ARRAY
69165: PUSH
69166: LD_INT 1
69168: ARRAY
69169: IN
69170: NOT
69171: AND
69172: PUSH
69173: LD_VAR 0 3
69177: PUSH
69178: LD_EXP 62
69182: PUSH
69183: LD_VAR 0 2
69187: ARRAY
69188: PUSH
69189: LD_INT 2
69191: ARRAY
69192: IN
69193: NOT
69194: AND
69195: IFFALSE 69247
// begin if IsInUnit ( j ) then
69197: LD_VAR 0 3
69201: PPUSH
69202: CALL_OW 310
69206: IFFALSE 69217
// ComExitBuilding ( j ) ;
69208: LD_VAR 0 3
69212: PPUSH
69213: CALL_OW 122
// if not HasTask ( j ) then
69217: LD_VAR 0 3
69221: PPUSH
69222: CALL_OW 314
69226: NOT
69227: IFFALSE 69247
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
69229: LD_VAR 0 3
69233: PPUSH
69234: LD_VAR 0 7
69238: PUSH
69239: LD_INT 1
69241: ARRAY
69242: PPUSH
69243: CALL_OW 189
// end ; end ;
69247: GO 69082
69249: POP
69250: POP
// end ;
69251: GO 68571
69253: POP
69254: POP
// end ;
69255: LD_VAR 0 1
69259: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
69260: LD_INT 0
69262: PPUSH
69263: PPUSH
69264: PPUSH
69265: PPUSH
69266: PPUSH
69267: PPUSH
69268: PPUSH
69269: PPUSH
69270: PPUSH
69271: PPUSH
69272: PPUSH
// if not mc_bases then
69273: LD_EXP 59
69277: NOT
69278: IFFALSE 69282
// exit ;
69280: GO 70084
// for i = 1 to mc_bases do
69282: LD_ADDR_VAR 0 2
69286: PUSH
69287: DOUBLE
69288: LD_INT 1
69290: DEC
69291: ST_TO_ADDR
69292: LD_EXP 59
69296: PUSH
69297: FOR_TO
69298: IFFALSE 70082
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
69300: LD_EXP 87
69304: PUSH
69305: LD_VAR 0 2
69309: ARRAY
69310: NOT
69311: PUSH
69312: LD_EXP 62
69316: PUSH
69317: LD_VAR 0 2
69321: ARRAY
69322: PUSH
69323: LD_INT 1
69325: ARRAY
69326: OR
69327: PUSH
69328: LD_EXP 62
69332: PUSH
69333: LD_VAR 0 2
69337: ARRAY
69338: PUSH
69339: LD_INT 2
69341: ARRAY
69342: OR
69343: PUSH
69344: LD_EXP 85
69348: PUSH
69349: LD_VAR 0 2
69353: ARRAY
69354: PPUSH
69355: LD_INT 1
69357: PPUSH
69358: CALL_OW 325
69362: NOT
69363: OR
69364: PUSH
69365: LD_EXP 82
69369: PUSH
69370: LD_VAR 0 2
69374: ARRAY
69375: OR
69376: IFFALSE 69380
// continue ;
69378: GO 69297
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
69380: LD_ADDR_VAR 0 8
69384: PUSH
69385: LD_EXP 59
69389: PUSH
69390: LD_VAR 0 2
69394: ARRAY
69395: PPUSH
69396: LD_INT 25
69398: PUSH
69399: LD_INT 4
69401: PUSH
69402: EMPTY
69403: LIST
69404: LIST
69405: PUSH
69406: LD_INT 50
69408: PUSH
69409: EMPTY
69410: LIST
69411: PUSH
69412: LD_INT 3
69414: PUSH
69415: LD_INT 60
69417: PUSH
69418: EMPTY
69419: LIST
69420: PUSH
69421: EMPTY
69422: LIST
69423: LIST
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: LIST
69429: PPUSH
69430: CALL_OW 72
69434: PUSH
69435: LD_EXP 63
69439: PUSH
69440: LD_VAR 0 2
69444: ARRAY
69445: DIFF
69446: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69447: LD_ADDR_VAR 0 9
69451: PUSH
69452: LD_EXP 59
69456: PUSH
69457: LD_VAR 0 2
69461: ARRAY
69462: PPUSH
69463: LD_INT 2
69465: PUSH
69466: LD_INT 30
69468: PUSH
69469: LD_INT 0
69471: PUSH
69472: EMPTY
69473: LIST
69474: LIST
69475: PUSH
69476: LD_INT 30
69478: PUSH
69479: LD_INT 1
69481: PUSH
69482: EMPTY
69483: LIST
69484: LIST
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: LIST
69490: PPUSH
69491: CALL_OW 72
69495: ST_TO_ADDR
// if not tmp or not dep then
69496: LD_VAR 0 8
69500: NOT
69501: PUSH
69502: LD_VAR 0 9
69506: NOT
69507: OR
69508: IFFALSE 69512
// continue ;
69510: GO 69297
// side := GetSide ( tmp [ 1 ] ) ;
69512: LD_ADDR_VAR 0 11
69516: PUSH
69517: LD_VAR 0 8
69521: PUSH
69522: LD_INT 1
69524: ARRAY
69525: PPUSH
69526: CALL_OW 255
69530: ST_TO_ADDR
// dep := dep [ 1 ] ;
69531: LD_ADDR_VAR 0 9
69535: PUSH
69536: LD_VAR 0 9
69540: PUSH
69541: LD_INT 1
69543: ARRAY
69544: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
69545: LD_ADDR_VAR 0 7
69549: PUSH
69550: LD_EXP 87
69554: PUSH
69555: LD_VAR 0 2
69559: ARRAY
69560: PPUSH
69561: LD_INT 22
69563: PUSH
69564: LD_INT 0
69566: PUSH
69567: EMPTY
69568: LIST
69569: LIST
69570: PUSH
69571: LD_INT 25
69573: PUSH
69574: LD_INT 12
69576: PUSH
69577: EMPTY
69578: LIST
69579: LIST
69580: PUSH
69581: EMPTY
69582: LIST
69583: LIST
69584: PPUSH
69585: CALL_OW 70
69589: PUSH
69590: LD_INT 22
69592: PUSH
69593: LD_INT 0
69595: PUSH
69596: EMPTY
69597: LIST
69598: LIST
69599: PUSH
69600: LD_INT 25
69602: PUSH
69603: LD_INT 12
69605: PUSH
69606: EMPTY
69607: LIST
69608: LIST
69609: PUSH
69610: LD_INT 91
69612: PUSH
69613: LD_VAR 0 9
69617: PUSH
69618: LD_INT 20
69620: PUSH
69621: EMPTY
69622: LIST
69623: LIST
69624: LIST
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: LIST
69630: PPUSH
69631: CALL_OW 69
69635: UNION
69636: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
69637: LD_ADDR_VAR 0 10
69641: PUSH
69642: LD_EXP 87
69646: PUSH
69647: LD_VAR 0 2
69651: ARRAY
69652: PPUSH
69653: LD_INT 81
69655: PUSH
69656: LD_VAR 0 11
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PPUSH
69665: CALL_OW 70
69669: ST_TO_ADDR
// if not apes or danger_at_area then
69670: LD_VAR 0 7
69674: NOT
69675: PUSH
69676: LD_VAR 0 10
69680: OR
69681: IFFALSE 69731
// begin if mc_taming [ i ] then
69683: LD_EXP 90
69687: PUSH
69688: LD_VAR 0 2
69692: ARRAY
69693: IFFALSE 69729
// begin MC_Reset ( i , 121 ) ;
69695: LD_VAR 0 2
69699: PPUSH
69700: LD_INT 121
69702: PPUSH
69703: CALL 55182 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
69707: LD_ADDR_EXP 90
69711: PUSH
69712: LD_EXP 90
69716: PPUSH
69717: LD_VAR 0 2
69721: PPUSH
69722: EMPTY
69723: PPUSH
69724: CALL_OW 1
69728: ST_TO_ADDR
// end ; continue ;
69729: GO 69297
// end ; for j in tmp do
69731: LD_ADDR_VAR 0 3
69735: PUSH
69736: LD_VAR 0 8
69740: PUSH
69741: FOR_IN
69742: IFFALSE 70078
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
69744: LD_VAR 0 3
69748: PUSH
69749: LD_EXP 90
69753: PUSH
69754: LD_VAR 0 2
69758: ARRAY
69759: IN
69760: NOT
69761: PUSH
69762: LD_EXP 90
69766: PUSH
69767: LD_VAR 0 2
69771: ARRAY
69772: PUSH
69773: LD_INT 3
69775: LESS
69776: AND
69777: IFFALSE 69835
// begin SetTag ( j , 121 ) ;
69779: LD_VAR 0 3
69783: PPUSH
69784: LD_INT 121
69786: PPUSH
69787: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
69791: LD_ADDR_EXP 90
69795: PUSH
69796: LD_EXP 90
69800: PPUSH
69801: LD_VAR 0 2
69805: PUSH
69806: LD_EXP 90
69810: PUSH
69811: LD_VAR 0 2
69815: ARRAY
69816: PUSH
69817: LD_INT 1
69819: PLUS
69820: PUSH
69821: EMPTY
69822: LIST
69823: LIST
69824: PPUSH
69825: LD_VAR 0 3
69829: PPUSH
69830: CALL 19238 0 3
69834: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
69835: LD_VAR 0 3
69839: PUSH
69840: LD_EXP 90
69844: PUSH
69845: LD_VAR 0 2
69849: ARRAY
69850: IN
69851: IFFALSE 70076
// begin if GetClass ( j ) <> 4 then
69853: LD_VAR 0 3
69857: PPUSH
69858: CALL_OW 257
69862: PUSH
69863: LD_INT 4
69865: NONEQUAL
69866: IFFALSE 69919
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
69868: LD_ADDR_EXP 90
69872: PUSH
69873: LD_EXP 90
69877: PPUSH
69878: LD_VAR 0 2
69882: PPUSH
69883: LD_EXP 90
69887: PUSH
69888: LD_VAR 0 2
69892: ARRAY
69893: PUSH
69894: LD_VAR 0 3
69898: DIFF
69899: PPUSH
69900: CALL_OW 1
69904: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69905: LD_VAR 0 3
69909: PPUSH
69910: LD_INT 0
69912: PPUSH
69913: CALL_OW 109
// continue ;
69917: GO 69741
// end ; if IsInUnit ( j ) then
69919: LD_VAR 0 3
69923: PPUSH
69924: CALL_OW 310
69928: IFFALSE 69939
// ComExitBuilding ( j ) ;
69930: LD_VAR 0 3
69934: PPUSH
69935: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
69939: LD_ADDR_VAR 0 6
69943: PUSH
69944: LD_VAR 0 7
69948: PPUSH
69949: LD_VAR 0 3
69953: PPUSH
69954: CALL_OW 74
69958: ST_TO_ADDR
// if not ape then
69959: LD_VAR 0 6
69963: NOT
69964: IFFALSE 69968
// break ;
69966: GO 70078
// x := GetX ( ape ) ;
69968: LD_ADDR_VAR 0 4
69972: PUSH
69973: LD_VAR 0 6
69977: PPUSH
69978: CALL_OW 250
69982: ST_TO_ADDR
// y := GetY ( ape ) ;
69983: LD_ADDR_VAR 0 5
69987: PUSH
69988: LD_VAR 0 6
69992: PPUSH
69993: CALL_OW 251
69997: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
69998: LD_VAR 0 4
70002: PPUSH
70003: LD_VAR 0 5
70007: PPUSH
70008: CALL_OW 488
70012: NOT
70013: PUSH
70014: LD_VAR 0 11
70018: PPUSH
70019: LD_VAR 0 4
70023: PPUSH
70024: LD_VAR 0 5
70028: PPUSH
70029: LD_INT 20
70031: PPUSH
70032: CALL 20134 0 4
70036: PUSH
70037: LD_INT 4
70039: ARRAY
70040: OR
70041: IFFALSE 70045
// break ;
70043: GO 70078
// if not HasTask ( j ) then
70045: LD_VAR 0 3
70049: PPUSH
70050: CALL_OW 314
70054: NOT
70055: IFFALSE 70076
// ComTameXY ( j , x , y ) ;
70057: LD_VAR 0 3
70061: PPUSH
70062: LD_VAR 0 4
70066: PPUSH
70067: LD_VAR 0 5
70071: PPUSH
70072: CALL_OW 131
// end ; end ;
70076: GO 69741
70078: POP
70079: POP
// end ;
70080: GO 69297
70082: POP
70083: POP
// end ;
70084: LD_VAR 0 1
70088: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
70089: LD_INT 0
70091: PPUSH
70092: PPUSH
70093: PPUSH
70094: PPUSH
70095: PPUSH
70096: PPUSH
70097: PPUSH
70098: PPUSH
// if not mc_bases then
70099: LD_EXP 59
70103: NOT
70104: IFFALSE 70108
// exit ;
70106: GO 70734
// for i = 1 to mc_bases do
70108: LD_ADDR_VAR 0 2
70112: PUSH
70113: DOUBLE
70114: LD_INT 1
70116: DEC
70117: ST_TO_ADDR
70118: LD_EXP 59
70122: PUSH
70123: FOR_TO
70124: IFFALSE 70732
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
70126: LD_EXP 88
70130: PUSH
70131: LD_VAR 0 2
70135: ARRAY
70136: NOT
70137: PUSH
70138: LD_EXP 88
70142: PUSH
70143: LD_VAR 0 2
70147: ARRAY
70148: PPUSH
70149: LD_INT 25
70151: PUSH
70152: LD_INT 12
70154: PUSH
70155: EMPTY
70156: LIST
70157: LIST
70158: PPUSH
70159: CALL_OW 72
70163: NOT
70164: OR
70165: IFFALSE 70169
// continue ;
70167: GO 70123
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
70169: LD_ADDR_VAR 0 5
70173: PUSH
70174: LD_EXP 88
70178: PUSH
70179: LD_VAR 0 2
70183: ARRAY
70184: PUSH
70185: LD_INT 1
70187: ARRAY
70188: PPUSH
70189: CALL_OW 255
70193: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
70194: LD_VAR 0 5
70198: PPUSH
70199: LD_INT 2
70201: PPUSH
70202: CALL_OW 325
70206: IFFALSE 70459
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70208: LD_ADDR_VAR 0 4
70212: PUSH
70213: LD_EXP 88
70217: PUSH
70218: LD_VAR 0 2
70222: ARRAY
70223: PPUSH
70224: LD_INT 25
70226: PUSH
70227: LD_INT 16
70229: PUSH
70230: EMPTY
70231: LIST
70232: LIST
70233: PPUSH
70234: CALL_OW 72
70238: ST_TO_ADDR
// if tmp < 6 then
70239: LD_VAR 0 4
70243: PUSH
70244: LD_INT 6
70246: LESS
70247: IFFALSE 70459
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70249: LD_ADDR_VAR 0 6
70253: PUSH
70254: LD_EXP 59
70258: PUSH
70259: LD_VAR 0 2
70263: ARRAY
70264: PPUSH
70265: LD_INT 2
70267: PUSH
70268: LD_INT 30
70270: PUSH
70271: LD_INT 0
70273: PUSH
70274: EMPTY
70275: LIST
70276: LIST
70277: PUSH
70278: LD_INT 30
70280: PUSH
70281: LD_INT 1
70283: PUSH
70284: EMPTY
70285: LIST
70286: LIST
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: LIST
70292: PPUSH
70293: CALL_OW 72
70297: ST_TO_ADDR
// if depot then
70298: LD_VAR 0 6
70302: IFFALSE 70459
// begin selected := 0 ;
70304: LD_ADDR_VAR 0 7
70308: PUSH
70309: LD_INT 0
70311: ST_TO_ADDR
// for j in depot do
70312: LD_ADDR_VAR 0 3
70316: PUSH
70317: LD_VAR 0 6
70321: PUSH
70322: FOR_IN
70323: IFFALSE 70354
// begin if UnitsInside ( j ) < 6 then
70325: LD_VAR 0 3
70329: PPUSH
70330: CALL_OW 313
70334: PUSH
70335: LD_INT 6
70337: LESS
70338: IFFALSE 70352
// begin selected := j ;
70340: LD_ADDR_VAR 0 7
70344: PUSH
70345: LD_VAR 0 3
70349: ST_TO_ADDR
// break ;
70350: GO 70354
// end ; end ;
70352: GO 70322
70354: POP
70355: POP
// if selected then
70356: LD_VAR 0 7
70360: IFFALSE 70459
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70362: LD_ADDR_VAR 0 3
70366: PUSH
70367: LD_EXP 88
70371: PUSH
70372: LD_VAR 0 2
70376: ARRAY
70377: PPUSH
70378: LD_INT 25
70380: PUSH
70381: LD_INT 12
70383: PUSH
70384: EMPTY
70385: LIST
70386: LIST
70387: PPUSH
70388: CALL_OW 72
70392: PUSH
70393: FOR_IN
70394: IFFALSE 70457
// if not HasTask ( j ) then
70396: LD_VAR 0 3
70400: PPUSH
70401: CALL_OW 314
70405: NOT
70406: IFFALSE 70455
// begin if not IsInUnit ( j ) then
70408: LD_VAR 0 3
70412: PPUSH
70413: CALL_OW 310
70417: NOT
70418: IFFALSE 70434
// ComEnterUnit ( j , selected ) ;
70420: LD_VAR 0 3
70424: PPUSH
70425: LD_VAR 0 7
70429: PPUSH
70430: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
70434: LD_VAR 0 3
70438: PPUSH
70439: LD_INT 16
70441: PPUSH
70442: CALL_OW 183
// AddComExitBuilding ( j ) ;
70446: LD_VAR 0 3
70450: PPUSH
70451: CALL_OW 182
// end ;
70455: GO 70393
70457: POP
70458: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
70459: LD_VAR 0 5
70463: PPUSH
70464: LD_INT 11
70466: PPUSH
70467: CALL_OW 325
70471: IFFALSE 70730
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70473: LD_ADDR_VAR 0 4
70477: PUSH
70478: LD_EXP 88
70482: PUSH
70483: LD_VAR 0 2
70487: ARRAY
70488: PPUSH
70489: LD_INT 25
70491: PUSH
70492: LD_INT 16
70494: PUSH
70495: EMPTY
70496: LIST
70497: LIST
70498: PPUSH
70499: CALL_OW 72
70503: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
70504: LD_VAR 0 4
70508: PUSH
70509: LD_INT 6
70511: GREATEREQUAL
70512: PUSH
70513: LD_VAR 0 5
70517: PPUSH
70518: LD_INT 2
70520: PPUSH
70521: CALL_OW 325
70525: NOT
70526: OR
70527: IFFALSE 70730
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
70529: LD_ADDR_VAR 0 8
70533: PUSH
70534: LD_EXP 59
70538: PUSH
70539: LD_VAR 0 2
70543: ARRAY
70544: PPUSH
70545: LD_INT 2
70547: PUSH
70548: LD_INT 30
70550: PUSH
70551: LD_INT 4
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: PUSH
70558: LD_INT 30
70560: PUSH
70561: LD_INT 5
70563: PUSH
70564: EMPTY
70565: LIST
70566: LIST
70567: PUSH
70568: EMPTY
70569: LIST
70570: LIST
70571: LIST
70572: PPUSH
70573: CALL_OW 72
70577: ST_TO_ADDR
// if barracks then
70578: LD_VAR 0 8
70582: IFFALSE 70730
// begin selected := 0 ;
70584: LD_ADDR_VAR 0 7
70588: PUSH
70589: LD_INT 0
70591: ST_TO_ADDR
// for j in barracks do
70592: LD_ADDR_VAR 0 3
70596: PUSH
70597: LD_VAR 0 8
70601: PUSH
70602: FOR_IN
70603: IFFALSE 70634
// begin if UnitsInside ( j ) < 6 then
70605: LD_VAR 0 3
70609: PPUSH
70610: CALL_OW 313
70614: PUSH
70615: LD_INT 6
70617: LESS
70618: IFFALSE 70632
// begin selected := j ;
70620: LD_ADDR_VAR 0 7
70624: PUSH
70625: LD_VAR 0 3
70629: ST_TO_ADDR
// break ;
70630: GO 70634
// end ; end ;
70632: GO 70602
70634: POP
70635: POP
// if selected then
70636: LD_VAR 0 7
70640: IFFALSE 70730
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70642: LD_ADDR_VAR 0 3
70646: PUSH
70647: LD_EXP 88
70651: PUSH
70652: LD_VAR 0 2
70656: ARRAY
70657: PPUSH
70658: LD_INT 25
70660: PUSH
70661: LD_INT 12
70663: PUSH
70664: EMPTY
70665: LIST
70666: LIST
70667: PPUSH
70668: CALL_OW 72
70672: PUSH
70673: FOR_IN
70674: IFFALSE 70728
// if not IsInUnit ( j ) and not HasTask ( j ) then
70676: LD_VAR 0 3
70680: PPUSH
70681: CALL_OW 310
70685: NOT
70686: PUSH
70687: LD_VAR 0 3
70691: PPUSH
70692: CALL_OW 314
70696: NOT
70697: AND
70698: IFFALSE 70726
// begin ComEnterUnit ( j , selected ) ;
70700: LD_VAR 0 3
70704: PPUSH
70705: LD_VAR 0 7
70709: PPUSH
70710: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
70714: LD_VAR 0 3
70718: PPUSH
70719: LD_INT 15
70721: PPUSH
70722: CALL_OW 183
// end ;
70726: GO 70673
70728: POP
70729: POP
// end ; end ; end ; end ; end ;
70730: GO 70123
70732: POP
70733: POP
// end ;
70734: LD_VAR 0 1
70738: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
70739: LD_INT 0
70741: PPUSH
70742: PPUSH
70743: PPUSH
70744: PPUSH
// if not mc_bases then
70745: LD_EXP 59
70749: NOT
70750: IFFALSE 70754
// exit ;
70752: GO 70932
// for i = 1 to mc_bases do
70754: LD_ADDR_VAR 0 2
70758: PUSH
70759: DOUBLE
70760: LD_INT 1
70762: DEC
70763: ST_TO_ADDR
70764: LD_EXP 59
70768: PUSH
70769: FOR_TO
70770: IFFALSE 70930
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
70772: LD_ADDR_VAR 0 4
70776: PUSH
70777: LD_EXP 59
70781: PUSH
70782: LD_VAR 0 2
70786: ARRAY
70787: PPUSH
70788: LD_INT 25
70790: PUSH
70791: LD_INT 9
70793: PUSH
70794: EMPTY
70795: LIST
70796: LIST
70797: PPUSH
70798: CALL_OW 72
70802: ST_TO_ADDR
// if not tmp then
70803: LD_VAR 0 4
70807: NOT
70808: IFFALSE 70812
// continue ;
70810: GO 70769
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
70812: LD_EXP 85
70816: PUSH
70817: LD_VAR 0 2
70821: ARRAY
70822: PPUSH
70823: LD_INT 29
70825: PPUSH
70826: CALL_OW 325
70830: NOT
70831: PUSH
70832: LD_EXP 85
70836: PUSH
70837: LD_VAR 0 2
70841: ARRAY
70842: PPUSH
70843: LD_INT 28
70845: PPUSH
70846: CALL_OW 325
70850: NOT
70851: AND
70852: IFFALSE 70856
// continue ;
70854: GO 70769
// for j in tmp do
70856: LD_ADDR_VAR 0 3
70860: PUSH
70861: LD_VAR 0 4
70865: PUSH
70866: FOR_IN
70867: IFFALSE 70926
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70869: LD_VAR 0 3
70873: PUSH
70874: LD_EXP 62
70878: PUSH
70879: LD_VAR 0 2
70883: ARRAY
70884: PUSH
70885: LD_INT 1
70887: ARRAY
70888: IN
70889: NOT
70890: PUSH
70891: LD_VAR 0 3
70895: PUSH
70896: LD_EXP 62
70900: PUSH
70901: LD_VAR 0 2
70905: ARRAY
70906: PUSH
70907: LD_INT 2
70909: ARRAY
70910: IN
70911: NOT
70912: AND
70913: IFFALSE 70924
// ComSpaceTimeShoot ( j ) ;
70915: LD_VAR 0 3
70919: PPUSH
70920: CALL 15235 0 1
70924: GO 70866
70926: POP
70927: POP
// end ;
70928: GO 70769
70930: POP
70931: POP
// end ;
70932: LD_VAR 0 1
70936: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
70937: LD_INT 0
70939: PPUSH
70940: PPUSH
70941: PPUSH
70942: PPUSH
70943: PPUSH
70944: PPUSH
70945: PPUSH
70946: PPUSH
70947: PPUSH
// if not mc_bases then
70948: LD_EXP 59
70952: NOT
70953: IFFALSE 70957
// exit ;
70955: GO 71579
// for i = 1 to mc_bases do
70957: LD_ADDR_VAR 0 2
70961: PUSH
70962: DOUBLE
70963: LD_INT 1
70965: DEC
70966: ST_TO_ADDR
70967: LD_EXP 59
70971: PUSH
70972: FOR_TO
70973: IFFALSE 71577
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
70975: LD_EXP 94
70979: PUSH
70980: LD_VAR 0 2
70984: ARRAY
70985: NOT
70986: PUSH
70987: LD_INT 38
70989: PPUSH
70990: LD_EXP 85
70994: PUSH
70995: LD_VAR 0 2
70999: ARRAY
71000: PPUSH
71001: CALL_OW 321
71005: PUSH
71006: LD_INT 2
71008: NONEQUAL
71009: OR
71010: IFFALSE 71014
// continue ;
71012: GO 70972
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71014: LD_ADDR_VAR 0 8
71018: PUSH
71019: LD_EXP 59
71023: PUSH
71024: LD_VAR 0 2
71028: ARRAY
71029: PPUSH
71030: LD_INT 30
71032: PUSH
71033: LD_INT 34
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PPUSH
71040: CALL_OW 72
71044: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
71045: LD_ADDR_VAR 0 9
71049: PUSH
71050: LD_EXP 59
71054: PUSH
71055: LD_VAR 0 2
71059: ARRAY
71060: PPUSH
71061: LD_INT 25
71063: PUSH
71064: LD_INT 4
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PPUSH
71071: CALL_OW 72
71075: PPUSH
71076: LD_INT 0
71078: PPUSH
71079: CALL 47799 0 2
71083: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
71084: LD_VAR 0 9
71088: NOT
71089: PUSH
71090: LD_VAR 0 8
71094: NOT
71095: OR
71096: PUSH
71097: LD_EXP 59
71101: PUSH
71102: LD_VAR 0 2
71106: ARRAY
71107: PPUSH
71108: LD_INT 124
71110: PPUSH
71111: CALL 47799 0 2
71115: OR
71116: IFFALSE 71120
// continue ;
71118: GO 70972
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
71120: LD_EXP 95
71124: PUSH
71125: LD_VAR 0 2
71129: ARRAY
71130: PUSH
71131: LD_EXP 94
71135: PUSH
71136: LD_VAR 0 2
71140: ARRAY
71141: LESS
71142: PUSH
71143: LD_EXP 95
71147: PUSH
71148: LD_VAR 0 2
71152: ARRAY
71153: PUSH
71154: LD_VAR 0 8
71158: LESS
71159: AND
71160: IFFALSE 71575
// begin tmp := sci [ 1 ] ;
71162: LD_ADDR_VAR 0 7
71166: PUSH
71167: LD_VAR 0 9
71171: PUSH
71172: LD_INT 1
71174: ARRAY
71175: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
71176: LD_VAR 0 7
71180: PPUSH
71181: LD_INT 124
71183: PPUSH
71184: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
71188: LD_ADDR_VAR 0 3
71192: PUSH
71193: DOUBLE
71194: LD_EXP 94
71198: PUSH
71199: LD_VAR 0 2
71203: ARRAY
71204: INC
71205: ST_TO_ADDR
71206: LD_EXP 94
71210: PUSH
71211: LD_VAR 0 2
71215: ARRAY
71216: PUSH
71217: FOR_DOWNTO
71218: IFFALSE 71561
// begin if IsInUnit ( tmp ) then
71220: LD_VAR 0 7
71224: PPUSH
71225: CALL_OW 310
71229: IFFALSE 71240
// ComExitBuilding ( tmp ) ;
71231: LD_VAR 0 7
71235: PPUSH
71236: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
71240: LD_INT 35
71242: PPUSH
71243: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
71247: LD_VAR 0 7
71251: PPUSH
71252: CALL_OW 310
71256: NOT
71257: PUSH
71258: LD_VAR 0 7
71262: PPUSH
71263: CALL_OW 314
71267: NOT
71268: AND
71269: IFFALSE 71240
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
71271: LD_ADDR_VAR 0 6
71275: PUSH
71276: LD_VAR 0 7
71280: PPUSH
71281: CALL_OW 250
71285: PUSH
71286: LD_VAR 0 7
71290: PPUSH
71291: CALL_OW 251
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
71300: LD_INT 35
71302: PPUSH
71303: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
71307: LD_ADDR_VAR 0 4
71311: PUSH
71312: LD_EXP 94
71316: PUSH
71317: LD_VAR 0 2
71321: ARRAY
71322: PUSH
71323: LD_VAR 0 3
71327: ARRAY
71328: PUSH
71329: LD_INT 1
71331: ARRAY
71332: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
71333: LD_ADDR_VAR 0 5
71337: PUSH
71338: LD_EXP 94
71342: PUSH
71343: LD_VAR 0 2
71347: ARRAY
71348: PUSH
71349: LD_VAR 0 3
71353: ARRAY
71354: PUSH
71355: LD_INT 2
71357: ARRAY
71358: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
71359: LD_VAR 0 7
71363: PPUSH
71364: LD_INT 10
71366: PPUSH
71367: CALL 21831 0 2
71371: PUSH
71372: LD_INT 4
71374: ARRAY
71375: IFFALSE 71413
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
71377: LD_VAR 0 7
71381: PPUSH
71382: LD_VAR 0 6
71386: PUSH
71387: LD_INT 1
71389: ARRAY
71390: PPUSH
71391: LD_VAR 0 6
71395: PUSH
71396: LD_INT 2
71398: ARRAY
71399: PPUSH
71400: CALL_OW 111
// wait ( 0 0$10 ) ;
71404: LD_INT 350
71406: PPUSH
71407: CALL_OW 67
// end else
71411: GO 71439
// begin ComMoveXY ( tmp , x , y ) ;
71413: LD_VAR 0 7
71417: PPUSH
71418: LD_VAR 0 4
71422: PPUSH
71423: LD_VAR 0 5
71427: PPUSH
71428: CALL_OW 111
// wait ( 0 0$3 ) ;
71432: LD_INT 105
71434: PPUSH
71435: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
71439: LD_VAR 0 7
71443: PPUSH
71444: LD_VAR 0 4
71448: PPUSH
71449: LD_VAR 0 5
71453: PPUSH
71454: CALL_OW 307
71458: IFFALSE 71300
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
71460: LD_VAR 0 7
71464: PPUSH
71465: LD_VAR 0 4
71469: PPUSH
71470: LD_VAR 0 5
71474: PPUSH
71475: LD_VAR 0 8
71479: PUSH
71480: LD_VAR 0 3
71484: ARRAY
71485: PPUSH
71486: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
71490: LD_INT 35
71492: PPUSH
71493: CALL_OW 67
// until not HasTask ( tmp ) ;
71497: LD_VAR 0 7
71501: PPUSH
71502: CALL_OW 314
71506: NOT
71507: IFFALSE 71490
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
71509: LD_ADDR_EXP 95
71513: PUSH
71514: LD_EXP 95
71518: PPUSH
71519: LD_VAR 0 2
71523: PUSH
71524: LD_EXP 95
71528: PUSH
71529: LD_VAR 0 2
71533: ARRAY
71534: PUSH
71535: LD_INT 1
71537: PLUS
71538: PUSH
71539: EMPTY
71540: LIST
71541: LIST
71542: PPUSH
71543: LD_VAR 0 8
71547: PUSH
71548: LD_VAR 0 3
71552: ARRAY
71553: PPUSH
71554: CALL 19238 0 3
71558: ST_TO_ADDR
// end ;
71559: GO 71217
71561: POP
71562: POP
// MC_Reset ( i , 124 ) ;
71563: LD_VAR 0 2
71567: PPUSH
71568: LD_INT 124
71570: PPUSH
71571: CALL 55182 0 2
// end ; end ;
71575: GO 70972
71577: POP
71578: POP
// end ;
71579: LD_VAR 0 1
71583: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
71584: LD_INT 0
71586: PPUSH
71587: PPUSH
71588: PPUSH
// if not mc_bases then
71589: LD_EXP 59
71593: NOT
71594: IFFALSE 71598
// exit ;
71596: GO 72204
// for i = 1 to mc_bases do
71598: LD_ADDR_VAR 0 2
71602: PUSH
71603: DOUBLE
71604: LD_INT 1
71606: DEC
71607: ST_TO_ADDR
71608: LD_EXP 59
71612: PUSH
71613: FOR_TO
71614: IFFALSE 72202
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71616: LD_ADDR_VAR 0 3
71620: PUSH
71621: LD_EXP 59
71625: PUSH
71626: LD_VAR 0 2
71630: ARRAY
71631: PPUSH
71632: LD_INT 25
71634: PUSH
71635: LD_INT 4
71637: PUSH
71638: EMPTY
71639: LIST
71640: LIST
71641: PPUSH
71642: CALL_OW 72
71646: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
71647: LD_VAR 0 3
71651: NOT
71652: PUSH
71653: LD_EXP 96
71657: PUSH
71658: LD_VAR 0 2
71662: ARRAY
71663: NOT
71664: OR
71665: PUSH
71666: LD_EXP 59
71670: PUSH
71671: LD_VAR 0 2
71675: ARRAY
71676: PPUSH
71677: LD_INT 2
71679: PUSH
71680: LD_INT 30
71682: PUSH
71683: LD_INT 0
71685: PUSH
71686: EMPTY
71687: LIST
71688: LIST
71689: PUSH
71690: LD_INT 30
71692: PUSH
71693: LD_INT 1
71695: PUSH
71696: EMPTY
71697: LIST
71698: LIST
71699: PUSH
71700: EMPTY
71701: LIST
71702: LIST
71703: LIST
71704: PPUSH
71705: CALL_OW 72
71709: NOT
71710: OR
71711: IFFALSE 71761
// begin if mc_deposits_finder [ i ] then
71713: LD_EXP 97
71717: PUSH
71718: LD_VAR 0 2
71722: ARRAY
71723: IFFALSE 71759
// begin MC_Reset ( i , 125 ) ;
71725: LD_VAR 0 2
71729: PPUSH
71730: LD_INT 125
71732: PPUSH
71733: CALL 55182 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71737: LD_ADDR_EXP 97
71741: PUSH
71742: LD_EXP 97
71746: PPUSH
71747: LD_VAR 0 2
71751: PPUSH
71752: EMPTY
71753: PPUSH
71754: CALL_OW 1
71758: ST_TO_ADDR
// end ; continue ;
71759: GO 71613
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
71761: LD_EXP 96
71765: PUSH
71766: LD_VAR 0 2
71770: ARRAY
71771: PUSH
71772: LD_INT 1
71774: ARRAY
71775: PUSH
71776: LD_INT 3
71778: ARRAY
71779: PUSH
71780: LD_INT 1
71782: EQUAL
71783: PUSH
71784: LD_INT 20
71786: PPUSH
71787: LD_EXP 85
71791: PUSH
71792: LD_VAR 0 2
71796: ARRAY
71797: PPUSH
71798: CALL_OW 321
71802: PUSH
71803: LD_INT 2
71805: NONEQUAL
71806: AND
71807: IFFALSE 71857
// begin if mc_deposits_finder [ i ] then
71809: LD_EXP 97
71813: PUSH
71814: LD_VAR 0 2
71818: ARRAY
71819: IFFALSE 71855
// begin MC_Reset ( i , 125 ) ;
71821: LD_VAR 0 2
71825: PPUSH
71826: LD_INT 125
71828: PPUSH
71829: CALL 55182 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71833: LD_ADDR_EXP 97
71837: PUSH
71838: LD_EXP 97
71842: PPUSH
71843: LD_VAR 0 2
71847: PPUSH
71848: EMPTY
71849: PPUSH
71850: CALL_OW 1
71854: ST_TO_ADDR
// end ; continue ;
71855: GO 71613
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
71857: LD_EXP 96
71861: PUSH
71862: LD_VAR 0 2
71866: ARRAY
71867: PUSH
71868: LD_INT 1
71870: ARRAY
71871: PUSH
71872: LD_INT 1
71874: ARRAY
71875: PPUSH
71876: LD_EXP 96
71880: PUSH
71881: LD_VAR 0 2
71885: ARRAY
71886: PUSH
71887: LD_INT 1
71889: ARRAY
71890: PUSH
71891: LD_INT 2
71893: ARRAY
71894: PPUSH
71895: LD_EXP 85
71899: PUSH
71900: LD_VAR 0 2
71904: ARRAY
71905: PPUSH
71906: CALL_OW 440
71910: IFFALSE 71953
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
71912: LD_ADDR_EXP 96
71916: PUSH
71917: LD_EXP 96
71921: PPUSH
71922: LD_VAR 0 2
71926: PPUSH
71927: LD_EXP 96
71931: PUSH
71932: LD_VAR 0 2
71936: ARRAY
71937: PPUSH
71938: LD_INT 1
71940: PPUSH
71941: CALL_OW 3
71945: PPUSH
71946: CALL_OW 1
71950: ST_TO_ADDR
71951: GO 72200
// begin if not mc_deposits_finder [ i ] then
71953: LD_EXP 97
71957: PUSH
71958: LD_VAR 0 2
71962: ARRAY
71963: NOT
71964: IFFALSE 72016
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
71966: LD_ADDR_EXP 97
71970: PUSH
71971: LD_EXP 97
71975: PPUSH
71976: LD_VAR 0 2
71980: PPUSH
71981: LD_VAR 0 3
71985: PUSH
71986: LD_INT 1
71988: ARRAY
71989: PUSH
71990: EMPTY
71991: LIST
71992: PPUSH
71993: CALL_OW 1
71997: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
71998: LD_VAR 0 3
72002: PUSH
72003: LD_INT 1
72005: ARRAY
72006: PPUSH
72007: LD_INT 125
72009: PPUSH
72010: CALL_OW 109
// end else
72014: GO 72200
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72016: LD_EXP 97
72020: PUSH
72021: LD_VAR 0 2
72025: ARRAY
72026: PUSH
72027: LD_INT 1
72029: ARRAY
72030: PPUSH
72031: CALL_OW 310
72035: IFFALSE 72058
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72037: LD_EXP 97
72041: PUSH
72042: LD_VAR 0 2
72046: ARRAY
72047: PUSH
72048: LD_INT 1
72050: ARRAY
72051: PPUSH
72052: CALL_OW 122
72056: GO 72200
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
72058: LD_EXP 97
72062: PUSH
72063: LD_VAR 0 2
72067: ARRAY
72068: PUSH
72069: LD_INT 1
72071: ARRAY
72072: PPUSH
72073: CALL_OW 314
72077: NOT
72078: PUSH
72079: LD_EXP 97
72083: PUSH
72084: LD_VAR 0 2
72088: ARRAY
72089: PUSH
72090: LD_INT 1
72092: ARRAY
72093: PPUSH
72094: LD_EXP 96
72098: PUSH
72099: LD_VAR 0 2
72103: ARRAY
72104: PUSH
72105: LD_INT 1
72107: ARRAY
72108: PUSH
72109: LD_INT 1
72111: ARRAY
72112: PPUSH
72113: LD_EXP 96
72117: PUSH
72118: LD_VAR 0 2
72122: ARRAY
72123: PUSH
72124: LD_INT 1
72126: ARRAY
72127: PUSH
72128: LD_INT 2
72130: ARRAY
72131: PPUSH
72132: CALL_OW 297
72136: PUSH
72137: LD_INT 6
72139: GREATER
72140: AND
72141: IFFALSE 72200
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
72143: LD_EXP 97
72147: PUSH
72148: LD_VAR 0 2
72152: ARRAY
72153: PUSH
72154: LD_INT 1
72156: ARRAY
72157: PPUSH
72158: LD_EXP 96
72162: PUSH
72163: LD_VAR 0 2
72167: ARRAY
72168: PUSH
72169: LD_INT 1
72171: ARRAY
72172: PUSH
72173: LD_INT 1
72175: ARRAY
72176: PPUSH
72177: LD_EXP 96
72181: PUSH
72182: LD_VAR 0 2
72186: ARRAY
72187: PUSH
72188: LD_INT 1
72190: ARRAY
72191: PUSH
72192: LD_INT 2
72194: ARRAY
72195: PPUSH
72196: CALL_OW 111
// end ; end ; end ;
72200: GO 71613
72202: POP
72203: POP
// end ;
72204: LD_VAR 0 1
72208: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
72209: LD_INT 0
72211: PPUSH
72212: PPUSH
72213: PPUSH
72214: PPUSH
72215: PPUSH
72216: PPUSH
72217: PPUSH
72218: PPUSH
72219: PPUSH
72220: PPUSH
72221: PPUSH
// if not mc_bases then
72222: LD_EXP 59
72226: NOT
72227: IFFALSE 72231
// exit ;
72229: GO 73171
// for i = 1 to mc_bases do
72231: LD_ADDR_VAR 0 2
72235: PUSH
72236: DOUBLE
72237: LD_INT 1
72239: DEC
72240: ST_TO_ADDR
72241: LD_EXP 59
72245: PUSH
72246: FOR_TO
72247: IFFALSE 73169
// begin if not mc_bases [ i ] or mc_scan [ i ] then
72249: LD_EXP 59
72253: PUSH
72254: LD_VAR 0 2
72258: ARRAY
72259: NOT
72260: PUSH
72261: LD_EXP 82
72265: PUSH
72266: LD_VAR 0 2
72270: ARRAY
72271: OR
72272: IFFALSE 72276
// continue ;
72274: GO 72246
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
72276: LD_ADDR_VAR 0 7
72280: PUSH
72281: LD_EXP 59
72285: PUSH
72286: LD_VAR 0 2
72290: ARRAY
72291: PUSH
72292: LD_INT 1
72294: ARRAY
72295: PPUSH
72296: CALL_OW 248
72300: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
72301: LD_VAR 0 7
72305: PUSH
72306: LD_INT 3
72308: EQUAL
72309: PUSH
72310: LD_EXP 78
72314: PUSH
72315: LD_VAR 0 2
72319: ARRAY
72320: PUSH
72321: LD_EXP 81
72325: PUSH
72326: LD_VAR 0 2
72330: ARRAY
72331: UNION
72332: PPUSH
72333: LD_INT 33
72335: PUSH
72336: LD_INT 2
72338: PUSH
72339: EMPTY
72340: LIST
72341: LIST
72342: PPUSH
72343: CALL_OW 72
72347: NOT
72348: OR
72349: IFFALSE 72353
// continue ;
72351: GO 72246
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
72353: LD_ADDR_VAR 0 9
72357: PUSH
72358: LD_EXP 59
72362: PUSH
72363: LD_VAR 0 2
72367: ARRAY
72368: PPUSH
72369: LD_INT 30
72371: PUSH
72372: LD_INT 36
72374: PUSH
72375: EMPTY
72376: LIST
72377: LIST
72378: PPUSH
72379: CALL_OW 72
72383: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
72384: LD_ADDR_VAR 0 10
72388: PUSH
72389: LD_EXP 78
72393: PUSH
72394: LD_VAR 0 2
72398: ARRAY
72399: PPUSH
72400: LD_INT 34
72402: PUSH
72403: LD_INT 31
72405: PUSH
72406: EMPTY
72407: LIST
72408: LIST
72409: PPUSH
72410: CALL_OW 72
72414: ST_TO_ADDR
// if not cts and not mcts then
72415: LD_VAR 0 9
72419: NOT
72420: PUSH
72421: LD_VAR 0 10
72425: NOT
72426: AND
72427: IFFALSE 72431
// continue ;
72429: GO 72246
// x := cts ;
72431: LD_ADDR_VAR 0 11
72435: PUSH
72436: LD_VAR 0 9
72440: ST_TO_ADDR
// if not x then
72441: LD_VAR 0 11
72445: NOT
72446: IFFALSE 72458
// x := mcts ;
72448: LD_ADDR_VAR 0 11
72452: PUSH
72453: LD_VAR 0 10
72457: ST_TO_ADDR
// if not x then
72458: LD_VAR 0 11
72462: NOT
72463: IFFALSE 72467
// continue ;
72465: GO 72246
// if mc_remote_driver [ i ] then
72467: LD_EXP 99
72471: PUSH
72472: LD_VAR 0 2
72476: ARRAY
72477: IFFALSE 72864
// for j in mc_remote_driver [ i ] do
72479: LD_ADDR_VAR 0 3
72483: PUSH
72484: LD_EXP 99
72488: PUSH
72489: LD_VAR 0 2
72493: ARRAY
72494: PUSH
72495: FOR_IN
72496: IFFALSE 72862
// begin if GetClass ( j ) <> 3 then
72498: LD_VAR 0 3
72502: PPUSH
72503: CALL_OW 257
72507: PUSH
72508: LD_INT 3
72510: NONEQUAL
72511: IFFALSE 72564
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
72513: LD_ADDR_EXP 99
72517: PUSH
72518: LD_EXP 99
72522: PPUSH
72523: LD_VAR 0 2
72527: PPUSH
72528: LD_EXP 99
72532: PUSH
72533: LD_VAR 0 2
72537: ARRAY
72538: PUSH
72539: LD_VAR 0 3
72543: DIFF
72544: PPUSH
72545: CALL_OW 1
72549: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72550: LD_VAR 0 3
72554: PPUSH
72555: LD_INT 0
72557: PPUSH
72558: CALL_OW 109
// continue ;
72562: GO 72495
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
72564: LD_EXP 78
72568: PUSH
72569: LD_VAR 0 2
72573: ARRAY
72574: PPUSH
72575: LD_INT 34
72577: PUSH
72578: LD_INT 31
72580: PUSH
72581: EMPTY
72582: LIST
72583: LIST
72584: PUSH
72585: LD_INT 58
72587: PUSH
72588: EMPTY
72589: LIST
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PPUSH
72595: CALL_OW 72
72599: PUSH
72600: LD_VAR 0 3
72604: PPUSH
72605: CALL 47887 0 1
72609: NOT
72610: AND
72611: IFFALSE 72682
// begin if IsInUnit ( j ) then
72613: LD_VAR 0 3
72617: PPUSH
72618: CALL_OW 310
72622: IFFALSE 72633
// ComExitBuilding ( j ) ;
72624: LD_VAR 0 3
72628: PPUSH
72629: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
72633: LD_VAR 0 3
72637: PPUSH
72638: LD_EXP 78
72642: PUSH
72643: LD_VAR 0 2
72647: ARRAY
72648: PPUSH
72649: LD_INT 34
72651: PUSH
72652: LD_INT 31
72654: PUSH
72655: EMPTY
72656: LIST
72657: LIST
72658: PUSH
72659: LD_INT 58
72661: PUSH
72662: EMPTY
72663: LIST
72664: PUSH
72665: EMPTY
72666: LIST
72667: LIST
72668: PPUSH
72669: CALL_OW 72
72673: PUSH
72674: LD_INT 1
72676: ARRAY
72677: PPUSH
72678: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
72682: LD_VAR 0 3
72686: PPUSH
72687: CALL_OW 310
72691: NOT
72692: PUSH
72693: LD_VAR 0 3
72697: PPUSH
72698: CALL_OW 310
72702: PPUSH
72703: CALL_OW 266
72707: PUSH
72708: LD_INT 36
72710: NONEQUAL
72711: PUSH
72712: LD_VAR 0 3
72716: PPUSH
72717: CALL 47887 0 1
72721: NOT
72722: AND
72723: OR
72724: IFFALSE 72860
// begin if IsInUnit ( j ) then
72726: LD_VAR 0 3
72730: PPUSH
72731: CALL_OW 310
72735: IFFALSE 72746
// ComExitBuilding ( j ) ;
72737: LD_VAR 0 3
72741: PPUSH
72742: CALL_OW 122
// ct := 0 ;
72746: LD_ADDR_VAR 0 8
72750: PUSH
72751: LD_INT 0
72753: ST_TO_ADDR
// for k in x do
72754: LD_ADDR_VAR 0 4
72758: PUSH
72759: LD_VAR 0 11
72763: PUSH
72764: FOR_IN
72765: IFFALSE 72838
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
72767: LD_VAR 0 4
72771: PPUSH
72772: CALL_OW 264
72776: PUSH
72777: LD_INT 31
72779: EQUAL
72780: PUSH
72781: LD_VAR 0 4
72785: PPUSH
72786: CALL_OW 311
72790: NOT
72791: AND
72792: PUSH
72793: LD_VAR 0 4
72797: PPUSH
72798: CALL_OW 266
72802: PUSH
72803: LD_INT 36
72805: EQUAL
72806: PUSH
72807: LD_VAR 0 4
72811: PPUSH
72812: CALL_OW 313
72816: PUSH
72817: LD_INT 3
72819: LESS
72820: AND
72821: OR
72822: IFFALSE 72836
// begin ct := k ;
72824: LD_ADDR_VAR 0 8
72828: PUSH
72829: LD_VAR 0 4
72833: ST_TO_ADDR
// break ;
72834: GO 72838
// end ;
72836: GO 72764
72838: POP
72839: POP
// if ct then
72840: LD_VAR 0 8
72844: IFFALSE 72860
// ComEnterUnit ( j , ct ) ;
72846: LD_VAR 0 3
72850: PPUSH
72851: LD_VAR 0 8
72855: PPUSH
72856: CALL_OW 120
// end ; end ;
72860: GO 72495
72862: POP
72863: POP
// places := 0 ;
72864: LD_ADDR_VAR 0 5
72868: PUSH
72869: LD_INT 0
72871: ST_TO_ADDR
// for j = 1 to x do
72872: LD_ADDR_VAR 0 3
72876: PUSH
72877: DOUBLE
72878: LD_INT 1
72880: DEC
72881: ST_TO_ADDR
72882: LD_VAR 0 11
72886: PUSH
72887: FOR_TO
72888: IFFALSE 72964
// if GetWeapon ( x [ j ] ) = ar_control_tower then
72890: LD_VAR 0 11
72894: PUSH
72895: LD_VAR 0 3
72899: ARRAY
72900: PPUSH
72901: CALL_OW 264
72905: PUSH
72906: LD_INT 31
72908: EQUAL
72909: IFFALSE 72927
// places := places + 1 else
72911: LD_ADDR_VAR 0 5
72915: PUSH
72916: LD_VAR 0 5
72920: PUSH
72921: LD_INT 1
72923: PLUS
72924: ST_TO_ADDR
72925: GO 72962
// if GetBType ( x [ j ] ) = b_control_tower then
72927: LD_VAR 0 11
72931: PUSH
72932: LD_VAR 0 3
72936: ARRAY
72937: PPUSH
72938: CALL_OW 266
72942: PUSH
72943: LD_INT 36
72945: EQUAL
72946: IFFALSE 72962
// places := places + 3 ;
72948: LD_ADDR_VAR 0 5
72952: PUSH
72953: LD_VAR 0 5
72957: PUSH
72958: LD_INT 3
72960: PLUS
72961: ST_TO_ADDR
72962: GO 72887
72964: POP
72965: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
72966: LD_VAR 0 5
72970: PUSH
72971: LD_INT 0
72973: EQUAL
72974: PUSH
72975: LD_VAR 0 5
72979: PUSH
72980: LD_EXP 99
72984: PUSH
72985: LD_VAR 0 2
72989: ARRAY
72990: LESSEQUAL
72991: OR
72992: IFFALSE 72996
// continue ;
72994: GO 72246
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
72996: LD_ADDR_VAR 0 6
73000: PUSH
73001: LD_EXP 59
73005: PUSH
73006: LD_VAR 0 2
73010: ARRAY
73011: PPUSH
73012: LD_INT 25
73014: PUSH
73015: LD_INT 3
73017: PUSH
73018: EMPTY
73019: LIST
73020: LIST
73021: PPUSH
73022: CALL_OW 72
73026: PUSH
73027: LD_EXP 99
73031: PUSH
73032: LD_VAR 0 2
73036: ARRAY
73037: DIFF
73038: PPUSH
73039: LD_INT 3
73041: PPUSH
73042: CALL 48787 0 2
73046: ST_TO_ADDR
// for j in tmp do
73047: LD_ADDR_VAR 0 3
73051: PUSH
73052: LD_VAR 0 6
73056: PUSH
73057: FOR_IN
73058: IFFALSE 73093
// if GetTag ( j ) > 0 then
73060: LD_VAR 0 3
73064: PPUSH
73065: CALL_OW 110
73069: PUSH
73070: LD_INT 0
73072: GREATER
73073: IFFALSE 73091
// tmp := tmp diff j ;
73075: LD_ADDR_VAR 0 6
73079: PUSH
73080: LD_VAR 0 6
73084: PUSH
73085: LD_VAR 0 3
73089: DIFF
73090: ST_TO_ADDR
73091: GO 73057
73093: POP
73094: POP
// if not tmp then
73095: LD_VAR 0 6
73099: NOT
73100: IFFALSE 73104
// continue ;
73102: GO 72246
// if places then
73104: LD_VAR 0 5
73108: IFFALSE 73167
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
73110: LD_ADDR_EXP 99
73114: PUSH
73115: LD_EXP 99
73119: PPUSH
73120: LD_VAR 0 2
73124: PPUSH
73125: LD_EXP 99
73129: PUSH
73130: LD_VAR 0 2
73134: ARRAY
73135: PUSH
73136: LD_VAR 0 6
73140: PUSH
73141: LD_INT 1
73143: ARRAY
73144: UNION
73145: PPUSH
73146: CALL_OW 1
73150: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
73151: LD_VAR 0 6
73155: PUSH
73156: LD_INT 1
73158: ARRAY
73159: PPUSH
73160: LD_INT 126
73162: PPUSH
73163: CALL_OW 109
// end ; end ;
73167: GO 72246
73169: POP
73170: POP
// end ;
73171: LD_VAR 0 1
73175: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
73176: LD_INT 0
73178: PPUSH
73179: PPUSH
73180: PPUSH
73181: PPUSH
73182: PPUSH
73183: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
73184: LD_VAR 0 1
73188: NOT
73189: PUSH
73190: LD_VAR 0 2
73194: NOT
73195: OR
73196: PUSH
73197: LD_VAR 0 3
73201: NOT
73202: OR
73203: PUSH
73204: LD_VAR 0 4
73208: PUSH
73209: LD_INT 1
73211: PUSH
73212: LD_INT 2
73214: PUSH
73215: LD_INT 3
73217: PUSH
73218: LD_INT 4
73220: PUSH
73221: LD_INT 5
73223: PUSH
73224: LD_INT 8
73226: PUSH
73227: LD_INT 9
73229: PUSH
73230: LD_INT 15
73232: PUSH
73233: LD_INT 16
73235: PUSH
73236: EMPTY
73237: LIST
73238: LIST
73239: LIST
73240: LIST
73241: LIST
73242: LIST
73243: LIST
73244: LIST
73245: LIST
73246: IN
73247: NOT
73248: OR
73249: IFFALSE 73253
// exit ;
73251: GO 74153
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
73253: LD_ADDR_VAR 0 2
73257: PUSH
73258: LD_VAR 0 2
73262: PPUSH
73263: LD_INT 21
73265: PUSH
73266: LD_INT 3
73268: PUSH
73269: EMPTY
73270: LIST
73271: LIST
73272: PUSH
73273: LD_INT 24
73275: PUSH
73276: LD_INT 250
73278: PUSH
73279: EMPTY
73280: LIST
73281: LIST
73282: PUSH
73283: EMPTY
73284: LIST
73285: LIST
73286: PPUSH
73287: CALL_OW 72
73291: ST_TO_ADDR
// case class of 1 , 15 :
73292: LD_VAR 0 4
73296: PUSH
73297: LD_INT 1
73299: DOUBLE
73300: EQUAL
73301: IFTRUE 73311
73303: LD_INT 15
73305: DOUBLE
73306: EQUAL
73307: IFTRUE 73311
73309: GO 73396
73311: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
73312: LD_ADDR_VAR 0 8
73316: PUSH
73317: LD_VAR 0 2
73321: PPUSH
73322: LD_INT 2
73324: PUSH
73325: LD_INT 30
73327: PUSH
73328: LD_INT 32
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: PUSH
73335: LD_INT 30
73337: PUSH
73338: LD_INT 31
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: PUSH
73345: EMPTY
73346: LIST
73347: LIST
73348: LIST
73349: PPUSH
73350: CALL_OW 72
73354: PUSH
73355: LD_VAR 0 2
73359: PPUSH
73360: LD_INT 2
73362: PUSH
73363: LD_INT 30
73365: PUSH
73366: LD_INT 4
73368: PUSH
73369: EMPTY
73370: LIST
73371: LIST
73372: PUSH
73373: LD_INT 30
73375: PUSH
73376: LD_INT 5
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: LIST
73387: PPUSH
73388: CALL_OW 72
73392: ADD
73393: ST_TO_ADDR
73394: GO 73642
73396: LD_INT 2
73398: DOUBLE
73399: EQUAL
73400: IFTRUE 73410
73402: LD_INT 16
73404: DOUBLE
73405: EQUAL
73406: IFTRUE 73410
73408: GO 73456
73410: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
73411: LD_ADDR_VAR 0 8
73415: PUSH
73416: LD_VAR 0 2
73420: PPUSH
73421: LD_INT 2
73423: PUSH
73424: LD_INT 30
73426: PUSH
73427: LD_INT 0
73429: PUSH
73430: EMPTY
73431: LIST
73432: LIST
73433: PUSH
73434: LD_INT 30
73436: PUSH
73437: LD_INT 1
73439: PUSH
73440: EMPTY
73441: LIST
73442: LIST
73443: PUSH
73444: EMPTY
73445: LIST
73446: LIST
73447: LIST
73448: PPUSH
73449: CALL_OW 72
73453: ST_TO_ADDR
73454: GO 73642
73456: LD_INT 3
73458: DOUBLE
73459: EQUAL
73460: IFTRUE 73464
73462: GO 73510
73464: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
73465: LD_ADDR_VAR 0 8
73469: PUSH
73470: LD_VAR 0 2
73474: PPUSH
73475: LD_INT 2
73477: PUSH
73478: LD_INT 30
73480: PUSH
73481: LD_INT 2
73483: PUSH
73484: EMPTY
73485: LIST
73486: LIST
73487: PUSH
73488: LD_INT 30
73490: PUSH
73491: LD_INT 3
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PUSH
73498: EMPTY
73499: LIST
73500: LIST
73501: LIST
73502: PPUSH
73503: CALL_OW 72
73507: ST_TO_ADDR
73508: GO 73642
73510: LD_INT 4
73512: DOUBLE
73513: EQUAL
73514: IFTRUE 73518
73516: GO 73575
73518: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
73519: LD_ADDR_VAR 0 8
73523: PUSH
73524: LD_VAR 0 2
73528: PPUSH
73529: LD_INT 2
73531: PUSH
73532: LD_INT 30
73534: PUSH
73535: LD_INT 6
73537: PUSH
73538: EMPTY
73539: LIST
73540: LIST
73541: PUSH
73542: LD_INT 30
73544: PUSH
73545: LD_INT 7
73547: PUSH
73548: EMPTY
73549: LIST
73550: LIST
73551: PUSH
73552: LD_INT 30
73554: PUSH
73555: LD_INT 8
73557: PUSH
73558: EMPTY
73559: LIST
73560: LIST
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: LIST
73566: LIST
73567: PPUSH
73568: CALL_OW 72
73572: ST_TO_ADDR
73573: GO 73642
73575: LD_INT 5
73577: DOUBLE
73578: EQUAL
73579: IFTRUE 73595
73581: LD_INT 8
73583: DOUBLE
73584: EQUAL
73585: IFTRUE 73595
73587: LD_INT 9
73589: DOUBLE
73590: EQUAL
73591: IFTRUE 73595
73593: GO 73641
73595: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
73596: LD_ADDR_VAR 0 8
73600: PUSH
73601: LD_VAR 0 2
73605: PPUSH
73606: LD_INT 2
73608: PUSH
73609: LD_INT 30
73611: PUSH
73612: LD_INT 4
73614: PUSH
73615: EMPTY
73616: LIST
73617: LIST
73618: PUSH
73619: LD_INT 30
73621: PUSH
73622: LD_INT 5
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: PUSH
73629: EMPTY
73630: LIST
73631: LIST
73632: LIST
73633: PPUSH
73634: CALL_OW 72
73638: ST_TO_ADDR
73639: GO 73642
73641: POP
// if not tmp then
73642: LD_VAR 0 8
73646: NOT
73647: IFFALSE 73651
// exit ;
73649: GO 74153
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
73651: LD_VAR 0 4
73655: PUSH
73656: LD_INT 1
73658: PUSH
73659: LD_INT 15
73661: PUSH
73662: EMPTY
73663: LIST
73664: LIST
73665: IN
73666: PUSH
73667: LD_EXP 68
73671: PUSH
73672: LD_VAR 0 1
73676: ARRAY
73677: AND
73678: IFFALSE 73834
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
73680: LD_ADDR_VAR 0 9
73684: PUSH
73685: LD_EXP 68
73689: PUSH
73690: LD_VAR 0 1
73694: ARRAY
73695: PUSH
73696: LD_INT 1
73698: ARRAY
73699: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
73700: LD_VAR 0 9
73704: PUSH
73705: LD_EXP 69
73709: PUSH
73710: LD_VAR 0 1
73714: ARRAY
73715: IN
73716: NOT
73717: IFFALSE 73832
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
73719: LD_ADDR_EXP 69
73723: PUSH
73724: LD_EXP 69
73728: PPUSH
73729: LD_VAR 0 1
73733: PUSH
73734: LD_EXP 69
73738: PUSH
73739: LD_VAR 0 1
73743: ARRAY
73744: PUSH
73745: LD_INT 1
73747: PLUS
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: PPUSH
73753: LD_VAR 0 9
73757: PPUSH
73758: CALL 19238 0 3
73762: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
73763: LD_ADDR_EXP 68
73767: PUSH
73768: LD_EXP 68
73772: PPUSH
73773: LD_VAR 0 1
73777: PPUSH
73778: LD_EXP 68
73782: PUSH
73783: LD_VAR 0 1
73787: ARRAY
73788: PUSH
73789: LD_VAR 0 9
73793: DIFF
73794: PPUSH
73795: CALL_OW 1
73799: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
73800: LD_VAR 0 3
73804: PPUSH
73805: LD_EXP 69
73809: PUSH
73810: LD_VAR 0 1
73814: ARRAY
73815: PUSH
73816: LD_EXP 69
73820: PUSH
73821: LD_VAR 0 1
73825: ARRAY
73826: ARRAY
73827: PPUSH
73828: CALL_OW 120
// end ; exit ;
73832: GO 74153
// end ; if tmp > 1 then
73834: LD_VAR 0 8
73838: PUSH
73839: LD_INT 1
73841: GREATER
73842: IFFALSE 73946
// for i = 2 to tmp do
73844: LD_ADDR_VAR 0 6
73848: PUSH
73849: DOUBLE
73850: LD_INT 2
73852: DEC
73853: ST_TO_ADDR
73854: LD_VAR 0 8
73858: PUSH
73859: FOR_TO
73860: IFFALSE 73944
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
73862: LD_VAR 0 8
73866: PUSH
73867: LD_VAR 0 6
73871: ARRAY
73872: PPUSH
73873: CALL_OW 461
73877: PUSH
73878: LD_INT 6
73880: EQUAL
73881: IFFALSE 73942
// begin x := tmp [ i ] ;
73883: LD_ADDR_VAR 0 9
73887: PUSH
73888: LD_VAR 0 8
73892: PUSH
73893: LD_VAR 0 6
73897: ARRAY
73898: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
73899: LD_ADDR_VAR 0 8
73903: PUSH
73904: LD_VAR 0 8
73908: PPUSH
73909: LD_VAR 0 6
73913: PPUSH
73914: CALL_OW 3
73918: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
73919: LD_ADDR_VAR 0 8
73923: PUSH
73924: LD_VAR 0 8
73928: PPUSH
73929: LD_INT 1
73931: PPUSH
73932: LD_VAR 0 9
73936: PPUSH
73937: CALL_OW 2
73941: ST_TO_ADDR
// end ;
73942: GO 73859
73944: POP
73945: POP
// for i in tmp do
73946: LD_ADDR_VAR 0 6
73950: PUSH
73951: LD_VAR 0 8
73955: PUSH
73956: FOR_IN
73957: IFFALSE 74026
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
73959: LD_VAR 0 6
73963: PPUSH
73964: CALL_OW 313
73968: PUSH
73969: LD_INT 6
73971: LESS
73972: PUSH
73973: LD_VAR 0 6
73977: PPUSH
73978: CALL_OW 266
73982: PUSH
73983: LD_INT 31
73985: PUSH
73986: LD_INT 32
73988: PUSH
73989: EMPTY
73990: LIST
73991: LIST
73992: IN
73993: NOT
73994: AND
73995: PUSH
73996: LD_VAR 0 6
74000: PPUSH
74001: CALL_OW 313
74005: PUSH
74006: LD_INT 0
74008: EQUAL
74009: OR
74010: IFFALSE 74024
// begin j := i ;
74012: LD_ADDR_VAR 0 7
74016: PUSH
74017: LD_VAR 0 6
74021: ST_TO_ADDR
// break ;
74022: GO 74026
// end ; end ;
74024: GO 73956
74026: POP
74027: POP
// if j then
74028: LD_VAR 0 7
74032: IFFALSE 74050
// ComEnterUnit ( unit , j ) else
74034: LD_VAR 0 3
74038: PPUSH
74039: LD_VAR 0 7
74043: PPUSH
74044: CALL_OW 120
74048: GO 74153
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74050: LD_ADDR_VAR 0 10
74054: PUSH
74055: LD_VAR 0 2
74059: PPUSH
74060: LD_INT 2
74062: PUSH
74063: LD_INT 30
74065: PUSH
74066: LD_INT 0
74068: PUSH
74069: EMPTY
74070: LIST
74071: LIST
74072: PUSH
74073: LD_INT 30
74075: PUSH
74076: LD_INT 1
74078: PUSH
74079: EMPTY
74080: LIST
74081: LIST
74082: PUSH
74083: EMPTY
74084: LIST
74085: LIST
74086: LIST
74087: PPUSH
74088: CALL_OW 72
74092: ST_TO_ADDR
// if depot then
74093: LD_VAR 0 10
74097: IFFALSE 74153
// begin depot := NearestUnitToUnit ( depot , unit ) ;
74099: LD_ADDR_VAR 0 10
74103: PUSH
74104: LD_VAR 0 10
74108: PPUSH
74109: LD_VAR 0 3
74113: PPUSH
74114: CALL_OW 74
74118: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
74119: LD_VAR 0 3
74123: PPUSH
74124: LD_VAR 0 10
74128: PPUSH
74129: CALL_OW 296
74133: PUSH
74134: LD_INT 10
74136: GREATER
74137: IFFALSE 74153
// ComStandNearbyBuilding ( unit , depot ) ;
74139: LD_VAR 0 3
74143: PPUSH
74144: LD_VAR 0 10
74148: PPUSH
74149: CALL 15852 0 2
// end ; end ; end ;
74153: LD_VAR 0 5
74157: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
74158: LD_INT 0
74160: PPUSH
74161: PPUSH
74162: PPUSH
74163: PPUSH
// if not mc_bases then
74164: LD_EXP 59
74168: NOT
74169: IFFALSE 74173
// exit ;
74171: GO 74412
// for i = 1 to mc_bases do
74173: LD_ADDR_VAR 0 2
74177: PUSH
74178: DOUBLE
74179: LD_INT 1
74181: DEC
74182: ST_TO_ADDR
74183: LD_EXP 59
74187: PUSH
74188: FOR_TO
74189: IFFALSE 74410
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
74191: LD_ADDR_VAR 0 4
74195: PUSH
74196: LD_EXP 59
74200: PUSH
74201: LD_VAR 0 2
74205: ARRAY
74206: PPUSH
74207: LD_INT 21
74209: PUSH
74210: LD_INT 1
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: PPUSH
74217: CALL_OW 72
74221: PUSH
74222: LD_EXP 88
74226: PUSH
74227: LD_VAR 0 2
74231: ARRAY
74232: UNION
74233: ST_TO_ADDR
// if not tmp then
74234: LD_VAR 0 4
74238: NOT
74239: IFFALSE 74243
// continue ;
74241: GO 74188
// for j in tmp do
74243: LD_ADDR_VAR 0 3
74247: PUSH
74248: LD_VAR 0 4
74252: PUSH
74253: FOR_IN
74254: IFFALSE 74406
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
74256: LD_VAR 0 3
74260: PPUSH
74261: CALL_OW 110
74265: NOT
74266: PUSH
74267: LD_VAR 0 3
74271: PPUSH
74272: CALL_OW 314
74276: NOT
74277: AND
74278: PUSH
74279: LD_VAR 0 3
74283: PPUSH
74284: CALL_OW 311
74288: NOT
74289: AND
74290: PUSH
74291: LD_VAR 0 3
74295: PPUSH
74296: CALL_OW 310
74300: NOT
74301: AND
74302: PUSH
74303: LD_VAR 0 3
74307: PUSH
74308: LD_EXP 62
74312: PUSH
74313: LD_VAR 0 2
74317: ARRAY
74318: PUSH
74319: LD_INT 1
74321: ARRAY
74322: IN
74323: NOT
74324: AND
74325: PUSH
74326: LD_VAR 0 3
74330: PUSH
74331: LD_EXP 62
74335: PUSH
74336: LD_VAR 0 2
74340: ARRAY
74341: PUSH
74342: LD_INT 2
74344: ARRAY
74345: IN
74346: NOT
74347: AND
74348: PUSH
74349: LD_VAR 0 3
74353: PUSH
74354: LD_EXP 71
74358: PUSH
74359: LD_VAR 0 2
74363: ARRAY
74364: IN
74365: NOT
74366: AND
74367: IFFALSE 74404
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
74369: LD_VAR 0 2
74373: PPUSH
74374: LD_EXP 59
74378: PUSH
74379: LD_VAR 0 2
74383: ARRAY
74384: PPUSH
74385: LD_VAR 0 3
74389: PPUSH
74390: LD_VAR 0 3
74394: PPUSH
74395: CALL_OW 257
74399: PPUSH
74400: CALL 73176 0 4
// end ;
74404: GO 74253
74406: POP
74407: POP
// end ;
74408: GO 74188
74410: POP
74411: POP
// end ;
74412: LD_VAR 0 1
74416: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
74417: LD_INT 0
74419: PPUSH
74420: PPUSH
74421: PPUSH
74422: PPUSH
74423: PPUSH
74424: PPUSH
// if not mc_bases [ base ] then
74425: LD_EXP 59
74429: PUSH
74430: LD_VAR 0 1
74434: ARRAY
74435: NOT
74436: IFFALSE 74440
// exit ;
74438: GO 74622
// tmp := [ ] ;
74440: LD_ADDR_VAR 0 6
74444: PUSH
74445: EMPTY
74446: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
74447: LD_ADDR_VAR 0 7
74451: PUSH
74452: LD_VAR 0 3
74456: PPUSH
74457: LD_INT 0
74459: PPUSH
74460: CALL_OW 517
74464: ST_TO_ADDR
// if not list then
74465: LD_VAR 0 7
74469: NOT
74470: IFFALSE 74474
// exit ;
74472: GO 74622
// for i = 1 to amount do
74474: LD_ADDR_VAR 0 5
74478: PUSH
74479: DOUBLE
74480: LD_INT 1
74482: DEC
74483: ST_TO_ADDR
74484: LD_VAR 0 2
74488: PUSH
74489: FOR_TO
74490: IFFALSE 74570
// begin x := rand ( 1 , list [ 1 ] ) ;
74492: LD_ADDR_VAR 0 8
74496: PUSH
74497: LD_INT 1
74499: PPUSH
74500: LD_VAR 0 7
74504: PUSH
74505: LD_INT 1
74507: ARRAY
74508: PPUSH
74509: CALL_OW 12
74513: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
74514: LD_ADDR_VAR 0 6
74518: PUSH
74519: LD_VAR 0 6
74523: PPUSH
74524: LD_VAR 0 5
74528: PPUSH
74529: LD_VAR 0 7
74533: PUSH
74534: LD_INT 1
74536: ARRAY
74537: PUSH
74538: LD_VAR 0 8
74542: ARRAY
74543: PUSH
74544: LD_VAR 0 7
74548: PUSH
74549: LD_INT 2
74551: ARRAY
74552: PUSH
74553: LD_VAR 0 8
74557: ARRAY
74558: PUSH
74559: EMPTY
74560: LIST
74561: LIST
74562: PPUSH
74563: CALL_OW 1
74567: ST_TO_ADDR
// end ;
74568: GO 74489
74570: POP
74571: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
74572: LD_ADDR_EXP 72
74576: PUSH
74577: LD_EXP 72
74581: PPUSH
74582: LD_VAR 0 1
74586: PPUSH
74587: LD_VAR 0 6
74591: PPUSH
74592: CALL_OW 1
74596: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
74597: LD_ADDR_EXP 74
74601: PUSH
74602: LD_EXP 74
74606: PPUSH
74607: LD_VAR 0 1
74611: PPUSH
74612: LD_VAR 0 3
74616: PPUSH
74617: CALL_OW 1
74621: ST_TO_ADDR
// end ;
74622: LD_VAR 0 4
74626: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
74627: LD_INT 0
74629: PPUSH
// if not mc_bases [ base ] then
74630: LD_EXP 59
74634: PUSH
74635: LD_VAR 0 1
74639: ARRAY
74640: NOT
74641: IFFALSE 74645
// exit ;
74643: GO 74670
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
74645: LD_ADDR_EXP 64
74649: PUSH
74650: LD_EXP 64
74654: PPUSH
74655: LD_VAR 0 1
74659: PPUSH
74660: LD_VAR 0 2
74664: PPUSH
74665: CALL_OW 1
74669: ST_TO_ADDR
// end ;
74670: LD_VAR 0 3
74674: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
74675: LD_INT 0
74677: PPUSH
// if not mc_bases [ base ] then
74678: LD_EXP 59
74682: PUSH
74683: LD_VAR 0 1
74687: ARRAY
74688: NOT
74689: IFFALSE 74693
// exit ;
74691: GO 74730
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
74693: LD_ADDR_EXP 64
74697: PUSH
74698: LD_EXP 64
74702: PPUSH
74703: LD_VAR 0 1
74707: PPUSH
74708: LD_EXP 64
74712: PUSH
74713: LD_VAR 0 1
74717: ARRAY
74718: PUSH
74719: LD_VAR 0 2
74723: UNION
74724: PPUSH
74725: CALL_OW 1
74729: ST_TO_ADDR
// end ;
74730: LD_VAR 0 3
74734: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
74735: LD_INT 0
74737: PPUSH
// if not mc_bases [ base ] then
74738: LD_EXP 59
74742: PUSH
74743: LD_VAR 0 1
74747: ARRAY
74748: NOT
74749: IFFALSE 74753
// exit ;
74751: GO 74778
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
74753: LD_ADDR_EXP 80
74757: PUSH
74758: LD_EXP 80
74762: PPUSH
74763: LD_VAR 0 1
74767: PPUSH
74768: LD_VAR 0 2
74772: PPUSH
74773: CALL_OW 1
74777: ST_TO_ADDR
// end ;
74778: LD_VAR 0 3
74782: RET
// export function MC_InsertProduceList ( base , components ) ; begin
74783: LD_INT 0
74785: PPUSH
// if not mc_bases [ base ] then
74786: LD_EXP 59
74790: PUSH
74791: LD_VAR 0 1
74795: ARRAY
74796: NOT
74797: IFFALSE 74801
// exit ;
74799: GO 74838
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
74801: LD_ADDR_EXP 80
74805: PUSH
74806: LD_EXP 80
74810: PPUSH
74811: LD_VAR 0 1
74815: PPUSH
74816: LD_EXP 80
74820: PUSH
74821: LD_VAR 0 1
74825: ARRAY
74826: PUSH
74827: LD_VAR 0 2
74831: ADD
74832: PPUSH
74833: CALL_OW 1
74837: ST_TO_ADDR
// end ;
74838: LD_VAR 0 3
74842: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
74843: LD_INT 0
74845: PPUSH
// if not mc_bases [ base ] then
74846: LD_EXP 59
74850: PUSH
74851: LD_VAR 0 1
74855: ARRAY
74856: NOT
74857: IFFALSE 74861
// exit ;
74859: GO 74915
// mc_defender := Replace ( mc_defender , base , deflist ) ;
74861: LD_ADDR_EXP 81
74865: PUSH
74866: LD_EXP 81
74870: PPUSH
74871: LD_VAR 0 1
74875: PPUSH
74876: LD_VAR 0 2
74880: PPUSH
74881: CALL_OW 1
74885: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
74886: LD_ADDR_EXP 70
74890: PUSH
74891: LD_EXP 70
74895: PPUSH
74896: LD_VAR 0 1
74900: PPUSH
74901: LD_VAR 0 2
74905: PUSH
74906: LD_INT 0
74908: PLUS
74909: PPUSH
74910: CALL_OW 1
74914: ST_TO_ADDR
// end ;
74915: LD_VAR 0 3
74919: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
74920: LD_INT 0
74922: PPUSH
// if not mc_bases [ base ] then
74923: LD_EXP 59
74927: PUSH
74928: LD_VAR 0 1
74932: ARRAY
74933: NOT
74934: IFFALSE 74938
// exit ;
74936: GO 74963
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
74938: LD_ADDR_EXP 70
74942: PUSH
74943: LD_EXP 70
74947: PPUSH
74948: LD_VAR 0 1
74952: PPUSH
74953: LD_VAR 0 2
74957: PPUSH
74958: CALL_OW 1
74962: ST_TO_ADDR
// end ;
74963: LD_VAR 0 3
74967: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
74968: LD_INT 0
74970: PPUSH
74971: PPUSH
74972: PPUSH
74973: PPUSH
// if not mc_bases [ base ] then
74974: LD_EXP 59
74978: PUSH
74979: LD_VAR 0 1
74983: ARRAY
74984: NOT
74985: IFFALSE 74989
// exit ;
74987: GO 75054
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
74989: LD_ADDR_EXP 79
74993: PUSH
74994: LD_EXP 79
74998: PPUSH
74999: LD_VAR 0 1
75003: PUSH
75004: LD_EXP 79
75008: PUSH
75009: LD_VAR 0 1
75013: ARRAY
75014: PUSH
75015: LD_INT 1
75017: PLUS
75018: PUSH
75019: EMPTY
75020: LIST
75021: LIST
75022: PPUSH
75023: LD_VAR 0 1
75027: PUSH
75028: LD_VAR 0 2
75032: PUSH
75033: LD_VAR 0 3
75037: PUSH
75038: LD_VAR 0 4
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: LIST
75047: LIST
75048: PPUSH
75049: CALL 19238 0 3
75053: ST_TO_ADDR
// end ;
75054: LD_VAR 0 5
75058: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
75059: LD_INT 0
75061: PPUSH
// if not mc_bases [ base ] then
75062: LD_EXP 59
75066: PUSH
75067: LD_VAR 0 1
75071: ARRAY
75072: NOT
75073: IFFALSE 75077
// exit ;
75075: GO 75102
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
75077: LD_ADDR_EXP 96
75081: PUSH
75082: LD_EXP 96
75086: PPUSH
75087: LD_VAR 0 1
75091: PPUSH
75092: LD_VAR 0 2
75096: PPUSH
75097: CALL_OW 1
75101: ST_TO_ADDR
// end ;
75102: LD_VAR 0 3
75106: RET
// export function MC_GetMinesField ( base ) ; begin
75107: LD_INT 0
75109: PPUSH
// result := mc_mines [ base ] ;
75110: LD_ADDR_VAR 0 2
75114: PUSH
75115: LD_EXP 72
75119: PUSH
75120: LD_VAR 0 1
75124: ARRAY
75125: ST_TO_ADDR
// end ;
75126: LD_VAR 0 2
75130: RET
// export function MC_GetProduceList ( base ) ; begin
75131: LD_INT 0
75133: PPUSH
// result := mc_produce [ base ] ;
75134: LD_ADDR_VAR 0 2
75138: PUSH
75139: LD_EXP 80
75143: PUSH
75144: LD_VAR 0 1
75148: ARRAY
75149: ST_TO_ADDR
// end ;
75150: LD_VAR 0 2
75154: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
75155: LD_INT 0
75157: PPUSH
75158: PPUSH
// if not mc_bases then
75159: LD_EXP 59
75163: NOT
75164: IFFALSE 75168
// exit ;
75166: GO 75233
// if mc_bases [ base ] then
75168: LD_EXP 59
75172: PUSH
75173: LD_VAR 0 1
75177: ARRAY
75178: IFFALSE 75233
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75180: LD_ADDR_VAR 0 3
75184: PUSH
75185: LD_EXP 59
75189: PUSH
75190: LD_VAR 0 1
75194: ARRAY
75195: PPUSH
75196: LD_INT 30
75198: PUSH
75199: LD_VAR 0 2
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: PPUSH
75208: CALL_OW 72
75212: ST_TO_ADDR
// if result then
75213: LD_VAR 0 3
75217: IFFALSE 75233
// result := result [ 1 ] ;
75219: LD_ADDR_VAR 0 3
75223: PUSH
75224: LD_VAR 0 3
75228: PUSH
75229: LD_INT 1
75231: ARRAY
75232: ST_TO_ADDR
// end ; end ;
75233: LD_VAR 0 3
75237: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
75238: LD_INT 0
75240: PPUSH
75241: PPUSH
// if not mc_bases then
75242: LD_EXP 59
75246: NOT
75247: IFFALSE 75251
// exit ;
75249: GO 75296
// if mc_bases [ base ] then
75251: LD_EXP 59
75255: PUSH
75256: LD_VAR 0 1
75260: ARRAY
75261: IFFALSE 75296
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75263: LD_ADDR_VAR 0 3
75267: PUSH
75268: LD_EXP 59
75272: PUSH
75273: LD_VAR 0 1
75277: ARRAY
75278: PPUSH
75279: LD_INT 30
75281: PUSH
75282: LD_VAR 0 2
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: PPUSH
75291: CALL_OW 72
75295: ST_TO_ADDR
// end ;
75296: LD_VAR 0 3
75300: RET
// export function MC_SetTame ( base , area ) ; begin
75301: LD_INT 0
75303: PPUSH
// if not mc_bases or not base then
75304: LD_EXP 59
75308: NOT
75309: PUSH
75310: LD_VAR 0 1
75314: NOT
75315: OR
75316: IFFALSE 75320
// exit ;
75318: GO 75345
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
75320: LD_ADDR_EXP 87
75324: PUSH
75325: LD_EXP 87
75329: PPUSH
75330: LD_VAR 0 1
75334: PPUSH
75335: LD_VAR 0 2
75339: PPUSH
75340: CALL_OW 1
75344: ST_TO_ADDR
// end ;
75345: LD_VAR 0 3
75349: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
75350: LD_INT 0
75352: PPUSH
75353: PPUSH
// if not mc_bases or not base then
75354: LD_EXP 59
75358: NOT
75359: PUSH
75360: LD_VAR 0 1
75364: NOT
75365: OR
75366: IFFALSE 75370
// exit ;
75368: GO 75472
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75370: LD_ADDR_VAR 0 4
75374: PUSH
75375: LD_EXP 59
75379: PUSH
75380: LD_VAR 0 1
75384: ARRAY
75385: PPUSH
75386: LD_INT 30
75388: PUSH
75389: LD_VAR 0 2
75393: PUSH
75394: EMPTY
75395: LIST
75396: LIST
75397: PPUSH
75398: CALL_OW 72
75402: ST_TO_ADDR
// if not tmp then
75403: LD_VAR 0 4
75407: NOT
75408: IFFALSE 75412
// exit ;
75410: GO 75472
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
75412: LD_ADDR_EXP 91
75416: PUSH
75417: LD_EXP 91
75421: PPUSH
75422: LD_VAR 0 1
75426: PPUSH
75427: LD_EXP 91
75431: PUSH
75432: LD_VAR 0 1
75436: ARRAY
75437: PPUSH
75438: LD_EXP 91
75442: PUSH
75443: LD_VAR 0 1
75447: ARRAY
75448: PUSH
75449: LD_INT 1
75451: PLUS
75452: PPUSH
75453: LD_VAR 0 4
75457: PUSH
75458: LD_INT 1
75460: ARRAY
75461: PPUSH
75462: CALL_OW 2
75466: PPUSH
75467: CALL_OW 1
75471: ST_TO_ADDR
// end ;
75472: LD_VAR 0 3
75476: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
75477: LD_INT 0
75479: PPUSH
75480: PPUSH
// if not mc_bases or not base or not kinds then
75481: LD_EXP 59
75485: NOT
75486: PUSH
75487: LD_VAR 0 1
75491: NOT
75492: OR
75493: PUSH
75494: LD_VAR 0 2
75498: NOT
75499: OR
75500: IFFALSE 75504
// exit ;
75502: GO 75565
// for i in kinds do
75504: LD_ADDR_VAR 0 4
75508: PUSH
75509: LD_VAR 0 2
75513: PUSH
75514: FOR_IN
75515: IFFALSE 75563
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
75517: LD_ADDR_EXP 93
75521: PUSH
75522: LD_EXP 93
75526: PPUSH
75527: LD_VAR 0 1
75531: PUSH
75532: LD_EXP 93
75536: PUSH
75537: LD_VAR 0 1
75541: ARRAY
75542: PUSH
75543: LD_INT 1
75545: PLUS
75546: PUSH
75547: EMPTY
75548: LIST
75549: LIST
75550: PPUSH
75551: LD_VAR 0 4
75555: PPUSH
75556: CALL 19238 0 3
75560: ST_TO_ADDR
75561: GO 75514
75563: POP
75564: POP
// end ;
75565: LD_VAR 0 3
75569: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
75570: LD_INT 0
75572: PPUSH
// if not mc_bases or not base or not areas then
75573: LD_EXP 59
75577: NOT
75578: PUSH
75579: LD_VAR 0 1
75583: NOT
75584: OR
75585: PUSH
75586: LD_VAR 0 2
75590: NOT
75591: OR
75592: IFFALSE 75596
// exit ;
75594: GO 75621
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
75596: LD_ADDR_EXP 77
75600: PUSH
75601: LD_EXP 77
75605: PPUSH
75606: LD_VAR 0 1
75610: PPUSH
75611: LD_VAR 0 2
75615: PPUSH
75616: CALL_OW 1
75620: ST_TO_ADDR
// end ;
75621: LD_VAR 0 3
75625: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
75626: LD_INT 0
75628: PPUSH
// if not mc_bases or not base or not teleports_exit then
75629: LD_EXP 59
75633: NOT
75634: PUSH
75635: LD_VAR 0 1
75639: NOT
75640: OR
75641: PUSH
75642: LD_VAR 0 2
75646: NOT
75647: OR
75648: IFFALSE 75652
// exit ;
75650: GO 75677
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
75652: LD_ADDR_EXP 94
75656: PUSH
75657: LD_EXP 94
75661: PPUSH
75662: LD_VAR 0 1
75666: PPUSH
75667: LD_VAR 0 2
75671: PPUSH
75672: CALL_OW 1
75676: ST_TO_ADDR
// end ;
75677: LD_VAR 0 3
75681: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
75682: LD_INT 0
75684: PPUSH
75685: PPUSH
75686: PPUSH
// if not mc_bases or not base or not ext_list then
75687: LD_EXP 59
75691: NOT
75692: PUSH
75693: LD_VAR 0 1
75697: NOT
75698: OR
75699: PUSH
75700: LD_VAR 0 5
75704: NOT
75705: OR
75706: IFFALSE 75710
// exit ;
75708: GO 75883
// tmp := GetFacExtXYD ( x , y , d ) ;
75710: LD_ADDR_VAR 0 8
75714: PUSH
75715: LD_VAR 0 2
75719: PPUSH
75720: LD_VAR 0 3
75724: PPUSH
75725: LD_VAR 0 4
75729: PPUSH
75730: CALL 47917 0 3
75734: ST_TO_ADDR
// if not tmp then
75735: LD_VAR 0 8
75739: NOT
75740: IFFALSE 75744
// exit ;
75742: GO 75883
// for i in tmp do
75744: LD_ADDR_VAR 0 7
75748: PUSH
75749: LD_VAR 0 8
75753: PUSH
75754: FOR_IN
75755: IFFALSE 75881
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
75757: LD_ADDR_EXP 64
75761: PUSH
75762: LD_EXP 64
75766: PPUSH
75767: LD_VAR 0 1
75771: PPUSH
75772: LD_EXP 64
75776: PUSH
75777: LD_VAR 0 1
75781: ARRAY
75782: PPUSH
75783: LD_EXP 64
75787: PUSH
75788: LD_VAR 0 1
75792: ARRAY
75793: PUSH
75794: LD_INT 1
75796: PLUS
75797: PPUSH
75798: LD_VAR 0 5
75802: PUSH
75803: LD_INT 1
75805: ARRAY
75806: PUSH
75807: LD_VAR 0 7
75811: PUSH
75812: LD_INT 1
75814: ARRAY
75815: PUSH
75816: LD_VAR 0 7
75820: PUSH
75821: LD_INT 2
75823: ARRAY
75824: PUSH
75825: LD_VAR 0 7
75829: PUSH
75830: LD_INT 3
75832: ARRAY
75833: PUSH
75834: EMPTY
75835: LIST
75836: LIST
75837: LIST
75838: LIST
75839: PPUSH
75840: CALL_OW 2
75844: PPUSH
75845: CALL_OW 1
75849: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
75850: LD_ADDR_VAR 0 5
75854: PUSH
75855: LD_VAR 0 5
75859: PPUSH
75860: LD_INT 1
75862: PPUSH
75863: CALL_OW 3
75867: ST_TO_ADDR
// if not ext_list then
75868: LD_VAR 0 5
75872: NOT
75873: IFFALSE 75879
// exit ;
75875: POP
75876: POP
75877: GO 75883
// end ;
75879: GO 75754
75881: POP
75882: POP
// end ;
75883: LD_VAR 0 6
75887: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
75888: LD_INT 0
75890: PPUSH
// if not mc_bases or not base or not weapon_list then
75891: LD_EXP 59
75895: NOT
75896: PUSH
75897: LD_VAR 0 1
75901: NOT
75902: OR
75903: PUSH
75904: LD_VAR 0 2
75908: NOT
75909: OR
75910: IFFALSE 75914
// exit ;
75912: GO 75939
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
75914: LD_ADDR_EXP 98
75918: PUSH
75919: LD_EXP 98
75923: PPUSH
75924: LD_VAR 0 1
75928: PPUSH
75929: LD_VAR 0 2
75933: PPUSH
75934: CALL_OW 1
75938: ST_TO_ADDR
// end ;
75939: LD_VAR 0 3
75943: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
75944: LD_INT 0
75946: PPUSH
// if not mc_bases or not base or not tech_list then
75947: LD_EXP 59
75951: NOT
75952: PUSH
75953: LD_VAR 0 1
75957: NOT
75958: OR
75959: PUSH
75960: LD_VAR 0 2
75964: NOT
75965: OR
75966: IFFALSE 75970
// exit ;
75968: GO 75995
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
75970: LD_ADDR_EXP 86
75974: PUSH
75975: LD_EXP 86
75979: PPUSH
75980: LD_VAR 0 1
75984: PPUSH
75985: LD_VAR 0 2
75989: PPUSH
75990: CALL_OW 1
75994: ST_TO_ADDR
// end ;
75995: LD_VAR 0 3
75999: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
76000: LD_INT 0
76002: PPUSH
// if not mc_bases or not parking_area or not base then
76003: LD_EXP 59
76007: NOT
76008: PUSH
76009: LD_VAR 0 2
76013: NOT
76014: OR
76015: PUSH
76016: LD_VAR 0 1
76020: NOT
76021: OR
76022: IFFALSE 76026
// exit ;
76024: GO 76051
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76026: LD_ADDR_EXP 83
76030: PUSH
76031: LD_EXP 83
76035: PPUSH
76036: LD_VAR 0 1
76040: PPUSH
76041: LD_VAR 0 2
76045: PPUSH
76046: CALL_OW 1
76050: ST_TO_ADDR
// end ;
76051: LD_VAR 0 3
76055: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
76056: LD_INT 0
76058: PPUSH
// if not mc_bases or not base or not scan_area then
76059: LD_EXP 59
76063: NOT
76064: PUSH
76065: LD_VAR 0 1
76069: NOT
76070: OR
76071: PUSH
76072: LD_VAR 0 2
76076: NOT
76077: OR
76078: IFFALSE 76082
// exit ;
76080: GO 76107
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
76082: LD_ADDR_EXP 84
76086: PUSH
76087: LD_EXP 84
76091: PPUSH
76092: LD_VAR 0 1
76096: PPUSH
76097: LD_VAR 0 2
76101: PPUSH
76102: CALL_OW 1
76106: ST_TO_ADDR
// end ;
76107: LD_VAR 0 3
76111: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
76112: LD_INT 0
76114: PPUSH
76115: PPUSH
// if not mc_bases or not base then
76116: LD_EXP 59
76120: NOT
76121: PUSH
76122: LD_VAR 0 1
76126: NOT
76127: OR
76128: IFFALSE 76132
// exit ;
76130: GO 76196
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
76132: LD_ADDR_VAR 0 3
76136: PUSH
76137: LD_INT 1
76139: PUSH
76140: LD_INT 2
76142: PUSH
76143: LD_INT 3
76145: PUSH
76146: LD_INT 4
76148: PUSH
76149: LD_INT 11
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: LIST
76156: LIST
76157: LIST
76158: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
76159: LD_ADDR_EXP 86
76163: PUSH
76164: LD_EXP 86
76168: PPUSH
76169: LD_VAR 0 1
76173: PPUSH
76174: LD_EXP 86
76178: PUSH
76179: LD_VAR 0 1
76183: ARRAY
76184: PUSH
76185: LD_VAR 0 3
76189: DIFF
76190: PPUSH
76191: CALL_OW 1
76195: ST_TO_ADDR
// end ;
76196: LD_VAR 0 2
76200: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
76201: LD_INT 0
76203: PPUSH
// result := mc_vehicles [ base ] ;
76204: LD_ADDR_VAR 0 3
76208: PUSH
76209: LD_EXP 78
76213: PUSH
76214: LD_VAR 0 1
76218: ARRAY
76219: ST_TO_ADDR
// if onlyCombat then
76220: LD_VAR 0 2
76224: IFFALSE 76389
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
76226: LD_ADDR_VAR 0 3
76230: PUSH
76231: LD_VAR 0 3
76235: PUSH
76236: LD_VAR 0 3
76240: PPUSH
76241: LD_INT 2
76243: PUSH
76244: LD_INT 34
76246: PUSH
76247: LD_INT 12
76249: PUSH
76250: EMPTY
76251: LIST
76252: LIST
76253: PUSH
76254: LD_INT 34
76256: PUSH
76257: LD_INT 51
76259: PUSH
76260: EMPTY
76261: LIST
76262: LIST
76263: PUSH
76264: LD_INT 34
76266: PUSH
76267: LD_EXP 103
76271: PUSH
76272: EMPTY
76273: LIST
76274: LIST
76275: PUSH
76276: LD_INT 34
76278: PUSH
76279: LD_INT 32
76281: PUSH
76282: EMPTY
76283: LIST
76284: LIST
76285: PUSH
76286: LD_INT 34
76288: PUSH
76289: LD_INT 13
76291: PUSH
76292: EMPTY
76293: LIST
76294: LIST
76295: PUSH
76296: LD_INT 34
76298: PUSH
76299: LD_INT 52
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: PUSH
76306: LD_INT 34
76308: PUSH
76309: LD_INT 14
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: PUSH
76316: LD_INT 34
76318: PUSH
76319: LD_INT 53
76321: PUSH
76322: EMPTY
76323: LIST
76324: LIST
76325: PUSH
76326: LD_INT 34
76328: PUSH
76329: LD_EXP 102
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PUSH
76338: LD_INT 34
76340: PUSH
76341: LD_INT 31
76343: PUSH
76344: EMPTY
76345: LIST
76346: LIST
76347: PUSH
76348: LD_INT 34
76350: PUSH
76351: LD_INT 48
76353: PUSH
76354: EMPTY
76355: LIST
76356: LIST
76357: PUSH
76358: LD_INT 34
76360: PUSH
76361: LD_INT 8
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: PUSH
76368: EMPTY
76369: LIST
76370: LIST
76371: LIST
76372: LIST
76373: LIST
76374: LIST
76375: LIST
76376: LIST
76377: LIST
76378: LIST
76379: LIST
76380: LIST
76381: LIST
76382: PPUSH
76383: CALL_OW 72
76387: DIFF
76388: ST_TO_ADDR
// end ; end_of_file
76389: LD_VAR 0 3
76393: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
76394: LD_INT 0
76396: PPUSH
76397: PPUSH
76398: PPUSH
// if not mc_bases or not skirmish then
76399: LD_EXP 59
76403: NOT
76404: PUSH
76405: LD_EXP 57
76409: NOT
76410: OR
76411: IFFALSE 76415
// exit ;
76413: GO 76580
// for i = 1 to mc_bases do
76415: LD_ADDR_VAR 0 4
76419: PUSH
76420: DOUBLE
76421: LD_INT 1
76423: DEC
76424: ST_TO_ADDR
76425: LD_EXP 59
76429: PUSH
76430: FOR_TO
76431: IFFALSE 76578
// begin if sci in mc_bases [ i ] then
76433: LD_VAR 0 2
76437: PUSH
76438: LD_EXP 59
76442: PUSH
76443: LD_VAR 0 4
76447: ARRAY
76448: IN
76449: IFFALSE 76576
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
76451: LD_ADDR_EXP 88
76455: PUSH
76456: LD_EXP 88
76460: PPUSH
76461: LD_VAR 0 4
76465: PUSH
76466: LD_EXP 88
76470: PUSH
76471: LD_VAR 0 4
76475: ARRAY
76476: PUSH
76477: LD_INT 1
76479: PLUS
76480: PUSH
76481: EMPTY
76482: LIST
76483: LIST
76484: PPUSH
76485: LD_VAR 0 1
76489: PPUSH
76490: CALL 19238 0 3
76494: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
76495: LD_ADDR_VAR 0 5
76499: PUSH
76500: LD_EXP 59
76504: PUSH
76505: LD_VAR 0 4
76509: ARRAY
76510: PPUSH
76511: LD_INT 2
76513: PUSH
76514: LD_INT 30
76516: PUSH
76517: LD_INT 0
76519: PUSH
76520: EMPTY
76521: LIST
76522: LIST
76523: PUSH
76524: LD_INT 30
76526: PUSH
76527: LD_INT 1
76529: PUSH
76530: EMPTY
76531: LIST
76532: LIST
76533: PUSH
76534: EMPTY
76535: LIST
76536: LIST
76537: LIST
76538: PPUSH
76539: CALL_OW 72
76543: PPUSH
76544: LD_VAR 0 1
76548: PPUSH
76549: CALL_OW 74
76553: ST_TO_ADDR
// if tmp then
76554: LD_VAR 0 5
76558: IFFALSE 76574
// ComStandNearbyBuilding ( ape , tmp ) ;
76560: LD_VAR 0 1
76564: PPUSH
76565: LD_VAR 0 5
76569: PPUSH
76570: CALL 15852 0 2
// break ;
76574: GO 76578
// end ; end ;
76576: GO 76430
76578: POP
76579: POP
// end ;
76580: LD_VAR 0 3
76584: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
76585: LD_INT 0
76587: PPUSH
76588: PPUSH
76589: PPUSH
// if not mc_bases or not skirmish then
76590: LD_EXP 59
76594: NOT
76595: PUSH
76596: LD_EXP 57
76600: NOT
76601: OR
76602: IFFALSE 76606
// exit ;
76604: GO 76695
// for i = 1 to mc_bases do
76606: LD_ADDR_VAR 0 4
76610: PUSH
76611: DOUBLE
76612: LD_INT 1
76614: DEC
76615: ST_TO_ADDR
76616: LD_EXP 59
76620: PUSH
76621: FOR_TO
76622: IFFALSE 76693
// begin if building in mc_busy_turret_list [ i ] then
76624: LD_VAR 0 1
76628: PUSH
76629: LD_EXP 69
76633: PUSH
76634: LD_VAR 0 4
76638: ARRAY
76639: IN
76640: IFFALSE 76691
// begin tmp := mc_busy_turret_list [ i ] diff building ;
76642: LD_ADDR_VAR 0 5
76646: PUSH
76647: LD_EXP 69
76651: PUSH
76652: LD_VAR 0 4
76656: ARRAY
76657: PUSH
76658: LD_VAR 0 1
76662: DIFF
76663: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
76664: LD_ADDR_EXP 69
76668: PUSH
76669: LD_EXP 69
76673: PPUSH
76674: LD_VAR 0 4
76678: PPUSH
76679: LD_VAR 0 5
76683: PPUSH
76684: CALL_OW 1
76688: ST_TO_ADDR
// break ;
76689: GO 76693
// end ; end ;
76691: GO 76621
76693: POP
76694: POP
// end ;
76695: LD_VAR 0 3
76699: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
76700: LD_INT 0
76702: PPUSH
76703: PPUSH
76704: PPUSH
// if not mc_bases or not skirmish then
76705: LD_EXP 59
76709: NOT
76710: PUSH
76711: LD_EXP 57
76715: NOT
76716: OR
76717: IFFALSE 76721
// exit ;
76719: GO 76920
// for i = 1 to mc_bases do
76721: LD_ADDR_VAR 0 5
76725: PUSH
76726: DOUBLE
76727: LD_INT 1
76729: DEC
76730: ST_TO_ADDR
76731: LD_EXP 59
76735: PUSH
76736: FOR_TO
76737: IFFALSE 76918
// if building in mc_bases [ i ] then
76739: LD_VAR 0 1
76743: PUSH
76744: LD_EXP 59
76748: PUSH
76749: LD_VAR 0 5
76753: ARRAY
76754: IN
76755: IFFALSE 76916
// begin tmp := mc_bases [ i ] diff building ;
76757: LD_ADDR_VAR 0 6
76761: PUSH
76762: LD_EXP 59
76766: PUSH
76767: LD_VAR 0 5
76771: ARRAY
76772: PUSH
76773: LD_VAR 0 1
76777: DIFF
76778: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
76779: LD_ADDR_EXP 59
76783: PUSH
76784: LD_EXP 59
76788: PPUSH
76789: LD_VAR 0 5
76793: PPUSH
76794: LD_VAR 0 6
76798: PPUSH
76799: CALL_OW 1
76803: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
76804: LD_VAR 0 1
76808: PUSH
76809: LD_EXP 67
76813: PUSH
76814: LD_VAR 0 5
76818: ARRAY
76819: IN
76820: IFFALSE 76859
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
76822: LD_ADDR_EXP 67
76826: PUSH
76827: LD_EXP 67
76831: PPUSH
76832: LD_VAR 0 5
76836: PPUSH
76837: LD_EXP 67
76841: PUSH
76842: LD_VAR 0 5
76846: ARRAY
76847: PUSH
76848: LD_VAR 0 1
76852: DIFF
76853: PPUSH
76854: CALL_OW 1
76858: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
76859: LD_VAR 0 1
76863: PUSH
76864: LD_EXP 68
76868: PUSH
76869: LD_VAR 0 5
76873: ARRAY
76874: IN
76875: IFFALSE 76914
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
76877: LD_ADDR_EXP 68
76881: PUSH
76882: LD_EXP 68
76886: PPUSH
76887: LD_VAR 0 5
76891: PPUSH
76892: LD_EXP 68
76896: PUSH
76897: LD_VAR 0 5
76901: ARRAY
76902: PUSH
76903: LD_VAR 0 1
76907: DIFF
76908: PPUSH
76909: CALL_OW 1
76913: ST_TO_ADDR
// break ;
76914: GO 76918
// end ;
76916: GO 76736
76918: POP
76919: POP
// end ;
76920: LD_VAR 0 4
76924: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
76925: LD_INT 0
76927: PPUSH
76928: PPUSH
76929: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
76930: LD_EXP 59
76934: NOT
76935: PUSH
76936: LD_EXP 57
76940: NOT
76941: OR
76942: PUSH
76943: LD_VAR 0 3
76947: PUSH
76948: LD_EXP 85
76952: IN
76953: NOT
76954: OR
76955: IFFALSE 76959
// exit ;
76957: GO 77082
// for i = 1 to mc_vehicles do
76959: LD_ADDR_VAR 0 6
76963: PUSH
76964: DOUBLE
76965: LD_INT 1
76967: DEC
76968: ST_TO_ADDR
76969: LD_EXP 78
76973: PUSH
76974: FOR_TO
76975: IFFALSE 77080
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
76977: LD_VAR 0 2
76981: PUSH
76982: LD_EXP 78
76986: PUSH
76987: LD_VAR 0 6
76991: ARRAY
76992: IN
76993: PUSH
76994: LD_VAR 0 1
76998: PUSH
76999: LD_EXP 78
77003: PUSH
77004: LD_VAR 0 6
77008: ARRAY
77009: IN
77010: OR
77011: IFFALSE 77078
// begin tmp := mc_vehicles [ i ] diff old ;
77013: LD_ADDR_VAR 0 7
77017: PUSH
77018: LD_EXP 78
77022: PUSH
77023: LD_VAR 0 6
77027: ARRAY
77028: PUSH
77029: LD_VAR 0 2
77033: DIFF
77034: ST_TO_ADDR
// tmp := tmp diff new ;
77035: LD_ADDR_VAR 0 7
77039: PUSH
77040: LD_VAR 0 7
77044: PUSH
77045: LD_VAR 0 1
77049: DIFF
77050: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
77051: LD_ADDR_EXP 78
77055: PUSH
77056: LD_EXP 78
77060: PPUSH
77061: LD_VAR 0 6
77065: PPUSH
77066: LD_VAR 0 7
77070: PPUSH
77071: CALL_OW 1
77075: ST_TO_ADDR
// break ;
77076: GO 77080
// end ;
77078: GO 76974
77080: POP
77081: POP
// end ;
77082: LD_VAR 0 5
77086: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
77087: LD_INT 0
77089: PPUSH
77090: PPUSH
77091: PPUSH
77092: PPUSH
// if not mc_bases or not skirmish then
77093: LD_EXP 59
77097: NOT
77098: PUSH
77099: LD_EXP 57
77103: NOT
77104: OR
77105: IFFALSE 77109
// exit ;
77107: GO 77486
// side := GetSide ( vehicle ) ;
77109: LD_ADDR_VAR 0 5
77113: PUSH
77114: LD_VAR 0 1
77118: PPUSH
77119: CALL_OW 255
77123: ST_TO_ADDR
// for i = 1 to mc_bases do
77124: LD_ADDR_VAR 0 4
77128: PUSH
77129: DOUBLE
77130: LD_INT 1
77132: DEC
77133: ST_TO_ADDR
77134: LD_EXP 59
77138: PUSH
77139: FOR_TO
77140: IFFALSE 77484
// begin if factory in mc_bases [ i ] then
77142: LD_VAR 0 2
77146: PUSH
77147: LD_EXP 59
77151: PUSH
77152: LD_VAR 0 4
77156: ARRAY
77157: IN
77158: IFFALSE 77482
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
77160: LD_EXP 81
77164: PUSH
77165: LD_VAR 0 4
77169: ARRAY
77170: PUSH
77171: LD_EXP 70
77175: PUSH
77176: LD_VAR 0 4
77180: ARRAY
77181: LESS
77182: PUSH
77183: LD_VAR 0 1
77187: PPUSH
77188: CALL_OW 264
77192: PUSH
77193: LD_INT 31
77195: PUSH
77196: LD_INT 32
77198: PUSH
77199: LD_INT 51
77201: PUSH
77202: LD_EXP 103
77206: PUSH
77207: LD_INT 12
77209: PUSH
77210: LD_INT 30
77212: PUSH
77213: LD_EXP 102
77217: PUSH
77218: LD_INT 11
77220: PUSH
77221: LD_INT 53
77223: PUSH
77224: LD_INT 14
77226: PUSH
77227: LD_EXP 106
77231: PUSH
77232: LD_INT 29
77234: PUSH
77235: LD_EXP 104
77239: PUSH
77240: LD_INT 13
77242: PUSH
77243: LD_INT 52
77245: PUSH
77246: LD_INT 48
77248: PUSH
77249: LD_INT 8
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: LIST
77256: LIST
77257: LIST
77258: LIST
77259: LIST
77260: LIST
77261: LIST
77262: LIST
77263: LIST
77264: LIST
77265: LIST
77266: LIST
77267: LIST
77268: LIST
77269: LIST
77270: IN
77271: NOT
77272: AND
77273: IFFALSE 77321
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
77275: LD_ADDR_EXP 81
77279: PUSH
77280: LD_EXP 81
77284: PPUSH
77285: LD_VAR 0 4
77289: PUSH
77290: LD_EXP 81
77294: PUSH
77295: LD_VAR 0 4
77299: ARRAY
77300: PUSH
77301: LD_INT 1
77303: PLUS
77304: PUSH
77305: EMPTY
77306: LIST
77307: LIST
77308: PPUSH
77309: LD_VAR 0 1
77313: PPUSH
77314: CALL 19238 0 3
77318: ST_TO_ADDR
77319: GO 77365
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
77321: LD_ADDR_EXP 78
77325: PUSH
77326: LD_EXP 78
77330: PPUSH
77331: LD_VAR 0 4
77335: PUSH
77336: LD_EXP 78
77340: PUSH
77341: LD_VAR 0 4
77345: ARRAY
77346: PUSH
77347: LD_INT 1
77349: PLUS
77350: PUSH
77351: EMPTY
77352: LIST
77353: LIST
77354: PPUSH
77355: LD_VAR 0 1
77359: PPUSH
77360: CALL 19238 0 3
77364: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
77365: LD_VAR 0 1
77369: PPUSH
77370: CALL_OW 263
77374: PUSH
77375: LD_INT 2
77377: EQUAL
77378: IFFALSE 77398
// begin repeat wait ( 0 0$1 ) ;
77380: LD_INT 35
77382: PPUSH
77383: CALL_OW 67
// until IsControledBy ( vehicle ) ;
77387: LD_VAR 0 1
77391: PPUSH
77392: CALL_OW 312
77396: IFFALSE 77380
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
77398: LD_VAR 0 1
77402: PPUSH
77403: LD_EXP 83
77407: PUSH
77408: LD_VAR 0 4
77412: ARRAY
77413: PPUSH
77414: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
77418: LD_VAR 0 1
77422: PPUSH
77423: CALL_OW 263
77427: PUSH
77428: LD_INT 1
77430: NONEQUAL
77431: IFFALSE 77435
// break ;
77433: GO 77484
// repeat wait ( 0 0$1 ) ;
77435: LD_INT 35
77437: PPUSH
77438: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
77442: LD_VAR 0 1
77446: PPUSH
77447: LD_EXP 83
77451: PUSH
77452: LD_VAR 0 4
77456: ARRAY
77457: PPUSH
77458: CALL_OW 308
77462: IFFALSE 77435
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
77464: LD_VAR 0 1
77468: PPUSH
77469: CALL_OW 311
77473: PPUSH
77474: CALL_OW 121
// exit ;
77478: POP
77479: POP
77480: GO 77486
// end ; end ;
77482: GO 77139
77484: POP
77485: POP
// end ;
77486: LD_VAR 0 3
77490: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
77491: LD_INT 0
77493: PPUSH
77494: PPUSH
77495: PPUSH
77496: PPUSH
// if not mc_bases or not skirmish then
77497: LD_EXP 59
77501: NOT
77502: PUSH
77503: LD_EXP 57
77507: NOT
77508: OR
77509: IFFALSE 77513
// exit ;
77511: GO 77866
// repeat wait ( 0 0$1 ) ;
77513: LD_INT 35
77515: PPUSH
77516: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
77520: LD_VAR 0 2
77524: PPUSH
77525: LD_VAR 0 3
77529: PPUSH
77530: CALL_OW 284
77534: IFFALSE 77513
// if GetResourceTypeXY ( x , y ) = mat_artefact then
77536: LD_VAR 0 2
77540: PPUSH
77541: LD_VAR 0 3
77545: PPUSH
77546: CALL_OW 283
77550: PUSH
77551: LD_INT 4
77553: EQUAL
77554: IFFALSE 77558
// exit ;
77556: GO 77866
// for i = 1 to mc_bases do
77558: LD_ADDR_VAR 0 7
77562: PUSH
77563: DOUBLE
77564: LD_INT 1
77566: DEC
77567: ST_TO_ADDR
77568: LD_EXP 59
77572: PUSH
77573: FOR_TO
77574: IFFALSE 77864
// begin if mc_crates_area [ i ] then
77576: LD_EXP 77
77580: PUSH
77581: LD_VAR 0 7
77585: ARRAY
77586: IFFALSE 77697
// for j in mc_crates_area [ i ] do
77588: LD_ADDR_VAR 0 8
77592: PUSH
77593: LD_EXP 77
77597: PUSH
77598: LD_VAR 0 7
77602: ARRAY
77603: PUSH
77604: FOR_IN
77605: IFFALSE 77695
// if InArea ( x , y , j ) then
77607: LD_VAR 0 2
77611: PPUSH
77612: LD_VAR 0 3
77616: PPUSH
77617: LD_VAR 0 8
77621: PPUSH
77622: CALL_OW 309
77626: IFFALSE 77693
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77628: LD_ADDR_EXP 75
77632: PUSH
77633: LD_EXP 75
77637: PPUSH
77638: LD_VAR 0 7
77642: PUSH
77643: LD_EXP 75
77647: PUSH
77648: LD_VAR 0 7
77652: ARRAY
77653: PUSH
77654: LD_INT 1
77656: PLUS
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: PPUSH
77662: LD_VAR 0 4
77666: PUSH
77667: LD_VAR 0 2
77671: PUSH
77672: LD_VAR 0 3
77676: PUSH
77677: EMPTY
77678: LIST
77679: LIST
77680: LIST
77681: PPUSH
77682: CALL 19238 0 3
77686: ST_TO_ADDR
// exit ;
77687: POP
77688: POP
77689: POP
77690: POP
77691: GO 77866
// end ;
77693: GO 77604
77695: POP
77696: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77697: LD_ADDR_VAR 0 9
77701: PUSH
77702: LD_EXP 59
77706: PUSH
77707: LD_VAR 0 7
77711: ARRAY
77712: PPUSH
77713: LD_INT 2
77715: PUSH
77716: LD_INT 30
77718: PUSH
77719: LD_INT 0
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: LD_INT 30
77728: PUSH
77729: LD_INT 1
77731: PUSH
77732: EMPTY
77733: LIST
77734: LIST
77735: PUSH
77736: EMPTY
77737: LIST
77738: LIST
77739: LIST
77740: PPUSH
77741: CALL_OW 72
77745: ST_TO_ADDR
// if not depot then
77746: LD_VAR 0 9
77750: NOT
77751: IFFALSE 77755
// continue ;
77753: GO 77573
// for j in depot do
77755: LD_ADDR_VAR 0 8
77759: PUSH
77760: LD_VAR 0 9
77764: PUSH
77765: FOR_IN
77766: IFFALSE 77860
// if GetDistUnitXY ( j , x , y ) < 30 then
77768: LD_VAR 0 8
77772: PPUSH
77773: LD_VAR 0 2
77777: PPUSH
77778: LD_VAR 0 3
77782: PPUSH
77783: CALL_OW 297
77787: PUSH
77788: LD_INT 30
77790: LESS
77791: IFFALSE 77858
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77793: LD_ADDR_EXP 75
77797: PUSH
77798: LD_EXP 75
77802: PPUSH
77803: LD_VAR 0 7
77807: PUSH
77808: LD_EXP 75
77812: PUSH
77813: LD_VAR 0 7
77817: ARRAY
77818: PUSH
77819: LD_INT 1
77821: PLUS
77822: PUSH
77823: EMPTY
77824: LIST
77825: LIST
77826: PPUSH
77827: LD_VAR 0 4
77831: PUSH
77832: LD_VAR 0 2
77836: PUSH
77837: LD_VAR 0 3
77841: PUSH
77842: EMPTY
77843: LIST
77844: LIST
77845: LIST
77846: PPUSH
77847: CALL 19238 0 3
77851: ST_TO_ADDR
// exit ;
77852: POP
77853: POP
77854: POP
77855: POP
77856: GO 77866
// end ;
77858: GO 77765
77860: POP
77861: POP
// end ;
77862: GO 77573
77864: POP
77865: POP
// end ;
77866: LD_VAR 0 6
77870: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
77871: LD_INT 0
77873: PPUSH
77874: PPUSH
77875: PPUSH
77876: PPUSH
// if not mc_bases or not skirmish then
77877: LD_EXP 59
77881: NOT
77882: PUSH
77883: LD_EXP 57
77887: NOT
77888: OR
77889: IFFALSE 77893
// exit ;
77891: GO 78170
// side := GetSide ( lab ) ;
77893: LD_ADDR_VAR 0 4
77897: PUSH
77898: LD_VAR 0 2
77902: PPUSH
77903: CALL_OW 255
77907: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
77908: LD_VAR 0 4
77912: PUSH
77913: LD_EXP 85
77917: IN
77918: NOT
77919: PUSH
77920: LD_EXP 86
77924: NOT
77925: OR
77926: PUSH
77927: LD_EXP 59
77931: NOT
77932: OR
77933: IFFALSE 77937
// exit ;
77935: GO 78170
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
77937: LD_ADDR_EXP 86
77941: PUSH
77942: LD_EXP 86
77946: PPUSH
77947: LD_VAR 0 4
77951: PPUSH
77952: LD_EXP 86
77956: PUSH
77957: LD_VAR 0 4
77961: ARRAY
77962: PUSH
77963: LD_VAR 0 1
77967: DIFF
77968: PPUSH
77969: CALL_OW 1
77973: ST_TO_ADDR
// for i = 1 to mc_bases do
77974: LD_ADDR_VAR 0 5
77978: PUSH
77979: DOUBLE
77980: LD_INT 1
77982: DEC
77983: ST_TO_ADDR
77984: LD_EXP 59
77988: PUSH
77989: FOR_TO
77990: IFFALSE 78168
// begin if lab in mc_bases [ i ] then
77992: LD_VAR 0 2
77996: PUSH
77997: LD_EXP 59
78001: PUSH
78002: LD_VAR 0 5
78006: ARRAY
78007: IN
78008: IFFALSE 78166
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78010: LD_VAR 0 1
78014: PUSH
78015: LD_INT 11
78017: PUSH
78018: LD_INT 4
78020: PUSH
78021: LD_INT 3
78023: PUSH
78024: LD_INT 2
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: LIST
78031: LIST
78032: IN
78033: PUSH
78034: LD_EXP 89
78038: PUSH
78039: LD_VAR 0 5
78043: ARRAY
78044: AND
78045: IFFALSE 78166
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
78047: LD_ADDR_VAR 0 6
78051: PUSH
78052: LD_EXP 89
78056: PUSH
78057: LD_VAR 0 5
78061: ARRAY
78062: PUSH
78063: LD_INT 1
78065: ARRAY
78066: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78067: LD_ADDR_EXP 89
78071: PUSH
78072: LD_EXP 89
78076: PPUSH
78077: LD_VAR 0 5
78081: PPUSH
78082: EMPTY
78083: PPUSH
78084: CALL_OW 1
78088: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
78089: LD_VAR 0 6
78093: PPUSH
78094: LD_INT 0
78096: PPUSH
78097: CALL_OW 109
// ComExitBuilding ( tmp ) ;
78101: LD_VAR 0 6
78105: PPUSH
78106: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
78110: LD_ADDR_EXP 88
78114: PUSH
78115: LD_EXP 88
78119: PPUSH
78120: LD_VAR 0 5
78124: PPUSH
78125: LD_EXP 88
78129: PUSH
78130: LD_VAR 0 5
78134: ARRAY
78135: PPUSH
78136: LD_INT 1
78138: PPUSH
78139: LD_VAR 0 6
78143: PPUSH
78144: CALL_OW 2
78148: PPUSH
78149: CALL_OW 1
78153: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
78154: LD_VAR 0 5
78158: PPUSH
78159: LD_INT 112
78161: PPUSH
78162: CALL 55182 0 2
// end ; end ; end ;
78166: GO 77989
78168: POP
78169: POP
// end ;
78170: LD_VAR 0 3
78174: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
78175: LD_INT 0
78177: PPUSH
78178: PPUSH
78179: PPUSH
78180: PPUSH
78181: PPUSH
78182: PPUSH
78183: PPUSH
78184: PPUSH
// if not mc_bases or not skirmish then
78185: LD_EXP 59
78189: NOT
78190: PUSH
78191: LD_EXP 57
78195: NOT
78196: OR
78197: IFFALSE 78201
// exit ;
78199: GO 79572
// for i = 1 to mc_bases do
78201: LD_ADDR_VAR 0 3
78205: PUSH
78206: DOUBLE
78207: LD_INT 1
78209: DEC
78210: ST_TO_ADDR
78211: LD_EXP 59
78215: PUSH
78216: FOR_TO
78217: IFFALSE 79570
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
78219: LD_VAR 0 1
78223: PUSH
78224: LD_EXP 59
78228: PUSH
78229: LD_VAR 0 3
78233: ARRAY
78234: IN
78235: PUSH
78236: LD_VAR 0 1
78240: PUSH
78241: LD_EXP 66
78245: PUSH
78246: LD_VAR 0 3
78250: ARRAY
78251: IN
78252: OR
78253: PUSH
78254: LD_VAR 0 1
78258: PUSH
78259: LD_EXP 81
78263: PUSH
78264: LD_VAR 0 3
78268: ARRAY
78269: IN
78270: OR
78271: PUSH
78272: LD_VAR 0 1
78276: PUSH
78277: LD_EXP 78
78281: PUSH
78282: LD_VAR 0 3
78286: ARRAY
78287: IN
78288: OR
78289: PUSH
78290: LD_VAR 0 1
78294: PUSH
78295: LD_EXP 88
78299: PUSH
78300: LD_VAR 0 3
78304: ARRAY
78305: IN
78306: OR
78307: PUSH
78308: LD_VAR 0 1
78312: PUSH
78313: LD_EXP 89
78317: PUSH
78318: LD_VAR 0 3
78322: ARRAY
78323: IN
78324: OR
78325: IFFALSE 79568
// begin if un in mc_ape [ i ] then
78327: LD_VAR 0 1
78331: PUSH
78332: LD_EXP 88
78336: PUSH
78337: LD_VAR 0 3
78341: ARRAY
78342: IN
78343: IFFALSE 78382
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
78345: LD_ADDR_EXP 88
78349: PUSH
78350: LD_EXP 88
78354: PPUSH
78355: LD_VAR 0 3
78359: PPUSH
78360: LD_EXP 88
78364: PUSH
78365: LD_VAR 0 3
78369: ARRAY
78370: PUSH
78371: LD_VAR 0 1
78375: DIFF
78376: PPUSH
78377: CALL_OW 1
78381: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
78382: LD_VAR 0 1
78386: PUSH
78387: LD_EXP 89
78391: PUSH
78392: LD_VAR 0 3
78396: ARRAY
78397: IN
78398: IFFALSE 78422
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78400: LD_ADDR_EXP 89
78404: PUSH
78405: LD_EXP 89
78409: PPUSH
78410: LD_VAR 0 3
78414: PPUSH
78415: EMPTY
78416: PPUSH
78417: CALL_OW 1
78421: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
78422: LD_VAR 0 1
78426: PPUSH
78427: CALL_OW 247
78431: PUSH
78432: LD_INT 2
78434: EQUAL
78435: PUSH
78436: LD_VAR 0 1
78440: PPUSH
78441: CALL_OW 110
78445: PUSH
78446: LD_INT 20
78448: EQUAL
78449: PUSH
78450: LD_VAR 0 1
78454: PUSH
78455: LD_EXP 81
78459: PUSH
78460: LD_VAR 0 3
78464: ARRAY
78465: IN
78466: OR
78467: PUSH
78468: LD_VAR 0 1
78472: PPUSH
78473: CALL_OW 264
78477: PUSH
78478: LD_INT 12
78480: PUSH
78481: LD_INT 51
78483: PUSH
78484: LD_EXP 103
78488: PUSH
78489: LD_INT 32
78491: PUSH
78492: LD_INT 13
78494: PUSH
78495: LD_INT 52
78497: PUSH
78498: LD_INT 31
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: LIST
78505: LIST
78506: LIST
78507: LIST
78508: LIST
78509: IN
78510: OR
78511: AND
78512: IFFALSE 78820
// begin if un in mc_defender [ i ] then
78514: LD_VAR 0 1
78518: PUSH
78519: LD_EXP 81
78523: PUSH
78524: LD_VAR 0 3
78528: ARRAY
78529: IN
78530: IFFALSE 78569
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78532: LD_ADDR_EXP 81
78536: PUSH
78537: LD_EXP 81
78541: PPUSH
78542: LD_VAR 0 3
78546: PPUSH
78547: LD_EXP 81
78551: PUSH
78552: LD_VAR 0 3
78556: ARRAY
78557: PUSH
78558: LD_VAR 0 1
78562: DIFF
78563: PPUSH
78564: CALL_OW 1
78568: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
78569: LD_ADDR_VAR 0 8
78573: PUSH
78574: LD_VAR 0 3
78578: PPUSH
78579: LD_INT 3
78581: PPUSH
78582: CALL 75238 0 2
78586: ST_TO_ADDR
// if fac then
78587: LD_VAR 0 8
78591: IFFALSE 78820
// begin for j in fac do
78593: LD_ADDR_VAR 0 4
78597: PUSH
78598: LD_VAR 0 8
78602: PUSH
78603: FOR_IN
78604: IFFALSE 78818
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
78606: LD_ADDR_VAR 0 9
78610: PUSH
78611: LD_VAR 0 8
78615: PPUSH
78616: LD_VAR 0 1
78620: PPUSH
78621: CALL_OW 265
78625: PPUSH
78626: LD_VAR 0 1
78630: PPUSH
78631: CALL_OW 262
78635: PPUSH
78636: LD_VAR 0 1
78640: PPUSH
78641: CALL_OW 263
78645: PPUSH
78646: LD_VAR 0 1
78650: PPUSH
78651: CALL_OW 264
78655: PPUSH
78656: CALL 16770 0 5
78660: ST_TO_ADDR
// if components then
78661: LD_VAR 0 9
78665: IFFALSE 78816
// begin if GetWeapon ( un ) = ar_control_tower then
78667: LD_VAR 0 1
78671: PPUSH
78672: CALL_OW 264
78676: PUSH
78677: LD_INT 31
78679: EQUAL
78680: IFFALSE 78797
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
78682: LD_VAR 0 1
78686: PPUSH
78687: CALL_OW 311
78691: PPUSH
78692: LD_INT 0
78694: PPUSH
78695: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
78699: LD_ADDR_EXP 99
78703: PUSH
78704: LD_EXP 99
78708: PPUSH
78709: LD_VAR 0 3
78713: PPUSH
78714: LD_EXP 99
78718: PUSH
78719: LD_VAR 0 3
78723: ARRAY
78724: PUSH
78725: LD_VAR 0 1
78729: PPUSH
78730: CALL_OW 311
78734: DIFF
78735: PPUSH
78736: CALL_OW 1
78740: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
78741: LD_ADDR_VAR 0 7
78745: PUSH
78746: LD_EXP 80
78750: PUSH
78751: LD_VAR 0 3
78755: ARRAY
78756: PPUSH
78757: LD_INT 1
78759: PPUSH
78760: LD_VAR 0 9
78764: PPUSH
78765: CALL_OW 2
78769: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
78770: LD_ADDR_EXP 80
78774: PUSH
78775: LD_EXP 80
78779: PPUSH
78780: LD_VAR 0 3
78784: PPUSH
78785: LD_VAR 0 7
78789: PPUSH
78790: CALL_OW 1
78794: ST_TO_ADDR
// end else
78795: GO 78814
// MC_InsertProduceList ( i , [ components ] ) ;
78797: LD_VAR 0 3
78801: PPUSH
78802: LD_VAR 0 9
78806: PUSH
78807: EMPTY
78808: LIST
78809: PPUSH
78810: CALL 74783 0 2
// break ;
78814: GO 78818
// end ; end ;
78816: GO 78603
78818: POP
78819: POP
// end ; end ; if GetType ( un ) = unit_building then
78820: LD_VAR 0 1
78824: PPUSH
78825: CALL_OW 247
78829: PUSH
78830: LD_INT 3
78832: EQUAL
78833: IFFALSE 79236
// begin btype := GetBType ( un ) ;
78835: LD_ADDR_VAR 0 5
78839: PUSH
78840: LD_VAR 0 1
78844: PPUSH
78845: CALL_OW 266
78849: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
78850: LD_VAR 0 5
78854: PUSH
78855: LD_INT 29
78857: PUSH
78858: LD_INT 30
78860: PUSH
78861: EMPTY
78862: LIST
78863: LIST
78864: IN
78865: IFFALSE 78938
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
78867: LD_VAR 0 1
78871: PPUSH
78872: CALL_OW 250
78876: PPUSH
78877: LD_VAR 0 1
78881: PPUSH
78882: CALL_OW 251
78886: PPUSH
78887: LD_VAR 0 1
78891: PPUSH
78892: CALL_OW 255
78896: PPUSH
78897: CALL_OW 440
78901: NOT
78902: IFFALSE 78938
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
78904: LD_VAR 0 1
78908: PPUSH
78909: CALL_OW 250
78913: PPUSH
78914: LD_VAR 0 1
78918: PPUSH
78919: CALL_OW 251
78923: PPUSH
78924: LD_VAR 0 1
78928: PPUSH
78929: CALL_OW 255
78933: PPUSH
78934: CALL_OW 441
// end ; if btype = b_warehouse then
78938: LD_VAR 0 5
78942: PUSH
78943: LD_INT 1
78945: EQUAL
78946: IFFALSE 78964
// begin btype := b_depot ;
78948: LD_ADDR_VAR 0 5
78952: PUSH
78953: LD_INT 0
78955: ST_TO_ADDR
// pos := 1 ;
78956: LD_ADDR_VAR 0 6
78960: PUSH
78961: LD_INT 1
78963: ST_TO_ADDR
// end ; if btype = b_factory then
78964: LD_VAR 0 5
78968: PUSH
78969: LD_INT 3
78971: EQUAL
78972: IFFALSE 78990
// begin btype := b_workshop ;
78974: LD_ADDR_VAR 0 5
78978: PUSH
78979: LD_INT 2
78981: ST_TO_ADDR
// pos := 1 ;
78982: LD_ADDR_VAR 0 6
78986: PUSH
78987: LD_INT 1
78989: ST_TO_ADDR
// end ; if btype = b_barracks then
78990: LD_VAR 0 5
78994: PUSH
78995: LD_INT 5
78997: EQUAL
78998: IFFALSE 79008
// btype := b_armoury ;
79000: LD_ADDR_VAR 0 5
79004: PUSH
79005: LD_INT 4
79007: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79008: LD_VAR 0 5
79012: PUSH
79013: LD_INT 7
79015: PUSH
79016: LD_INT 8
79018: PUSH
79019: EMPTY
79020: LIST
79021: LIST
79022: IN
79023: IFFALSE 79033
// btype := b_lab ;
79025: LD_ADDR_VAR 0 5
79029: PUSH
79030: LD_INT 6
79032: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
79033: LD_ADDR_EXP 64
79037: PUSH
79038: LD_EXP 64
79042: PPUSH
79043: LD_VAR 0 3
79047: PUSH
79048: LD_EXP 64
79052: PUSH
79053: LD_VAR 0 3
79057: ARRAY
79058: PUSH
79059: LD_INT 1
79061: PLUS
79062: PUSH
79063: EMPTY
79064: LIST
79065: LIST
79066: PPUSH
79067: LD_VAR 0 5
79071: PUSH
79072: LD_VAR 0 1
79076: PPUSH
79077: CALL_OW 250
79081: PUSH
79082: LD_VAR 0 1
79086: PPUSH
79087: CALL_OW 251
79091: PUSH
79092: LD_VAR 0 1
79096: PPUSH
79097: CALL_OW 254
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: LIST
79106: LIST
79107: PPUSH
79108: CALL 19238 0 3
79112: ST_TO_ADDR
// if pos = 1 then
79113: LD_VAR 0 6
79117: PUSH
79118: LD_INT 1
79120: EQUAL
79121: IFFALSE 79236
// begin tmp := mc_build_list [ i ] ;
79123: LD_ADDR_VAR 0 7
79127: PUSH
79128: LD_EXP 64
79132: PUSH
79133: LD_VAR 0 3
79137: ARRAY
79138: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79139: LD_VAR 0 7
79143: PPUSH
79144: LD_INT 2
79146: PUSH
79147: LD_INT 30
79149: PUSH
79150: LD_INT 0
79152: PUSH
79153: EMPTY
79154: LIST
79155: LIST
79156: PUSH
79157: LD_INT 30
79159: PUSH
79160: LD_INT 1
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: LIST
79171: PPUSH
79172: CALL_OW 72
79176: IFFALSE 79186
// pos := 2 ;
79178: LD_ADDR_VAR 0 6
79182: PUSH
79183: LD_INT 2
79185: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
79186: LD_ADDR_VAR 0 7
79190: PUSH
79191: LD_VAR 0 7
79195: PPUSH
79196: LD_VAR 0 6
79200: PPUSH
79201: LD_VAR 0 7
79205: PPUSH
79206: CALL 19564 0 3
79210: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
79211: LD_ADDR_EXP 64
79215: PUSH
79216: LD_EXP 64
79220: PPUSH
79221: LD_VAR 0 3
79225: PPUSH
79226: LD_VAR 0 7
79230: PPUSH
79231: CALL_OW 1
79235: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
79236: LD_VAR 0 1
79240: PUSH
79241: LD_EXP 59
79245: PUSH
79246: LD_VAR 0 3
79250: ARRAY
79251: IN
79252: IFFALSE 79291
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
79254: LD_ADDR_EXP 59
79258: PUSH
79259: LD_EXP 59
79263: PPUSH
79264: LD_VAR 0 3
79268: PPUSH
79269: LD_EXP 59
79273: PUSH
79274: LD_VAR 0 3
79278: ARRAY
79279: PUSH
79280: LD_VAR 0 1
79284: DIFF
79285: PPUSH
79286: CALL_OW 1
79290: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
79291: LD_VAR 0 1
79295: PUSH
79296: LD_EXP 66
79300: PUSH
79301: LD_VAR 0 3
79305: ARRAY
79306: IN
79307: IFFALSE 79346
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
79309: LD_ADDR_EXP 66
79313: PUSH
79314: LD_EXP 66
79318: PPUSH
79319: LD_VAR 0 3
79323: PPUSH
79324: LD_EXP 66
79328: PUSH
79329: LD_VAR 0 3
79333: ARRAY
79334: PUSH
79335: LD_VAR 0 1
79339: DIFF
79340: PPUSH
79341: CALL_OW 1
79345: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
79346: LD_VAR 0 1
79350: PUSH
79351: LD_EXP 78
79355: PUSH
79356: LD_VAR 0 3
79360: ARRAY
79361: IN
79362: IFFALSE 79401
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
79364: LD_ADDR_EXP 78
79368: PUSH
79369: LD_EXP 78
79373: PPUSH
79374: LD_VAR 0 3
79378: PPUSH
79379: LD_EXP 78
79383: PUSH
79384: LD_VAR 0 3
79388: ARRAY
79389: PUSH
79390: LD_VAR 0 1
79394: DIFF
79395: PPUSH
79396: CALL_OW 1
79400: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
79401: LD_VAR 0 1
79405: PUSH
79406: LD_EXP 81
79410: PUSH
79411: LD_VAR 0 3
79415: ARRAY
79416: IN
79417: IFFALSE 79456
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79419: LD_ADDR_EXP 81
79423: PUSH
79424: LD_EXP 81
79428: PPUSH
79429: LD_VAR 0 3
79433: PPUSH
79434: LD_EXP 81
79438: PUSH
79439: LD_VAR 0 3
79443: ARRAY
79444: PUSH
79445: LD_VAR 0 1
79449: DIFF
79450: PPUSH
79451: CALL_OW 1
79455: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
79456: LD_VAR 0 1
79460: PUSH
79461: LD_EXP 68
79465: PUSH
79466: LD_VAR 0 3
79470: ARRAY
79471: IN
79472: IFFALSE 79511
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
79474: LD_ADDR_EXP 68
79478: PUSH
79479: LD_EXP 68
79483: PPUSH
79484: LD_VAR 0 3
79488: PPUSH
79489: LD_EXP 68
79493: PUSH
79494: LD_VAR 0 3
79498: ARRAY
79499: PUSH
79500: LD_VAR 0 1
79504: DIFF
79505: PPUSH
79506: CALL_OW 1
79510: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
79511: LD_VAR 0 1
79515: PUSH
79516: LD_EXP 67
79520: PUSH
79521: LD_VAR 0 3
79525: ARRAY
79526: IN
79527: IFFALSE 79566
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
79529: LD_ADDR_EXP 67
79533: PUSH
79534: LD_EXP 67
79538: PPUSH
79539: LD_VAR 0 3
79543: PPUSH
79544: LD_EXP 67
79548: PUSH
79549: LD_VAR 0 3
79553: ARRAY
79554: PUSH
79555: LD_VAR 0 1
79559: DIFF
79560: PPUSH
79561: CALL_OW 1
79565: ST_TO_ADDR
// end ; break ;
79566: GO 79570
// end ;
79568: GO 78216
79570: POP
79571: POP
// end ;
79572: LD_VAR 0 2
79576: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
79577: LD_INT 0
79579: PPUSH
79580: PPUSH
79581: PPUSH
// if not mc_bases or not skirmish then
79582: LD_EXP 59
79586: NOT
79587: PUSH
79588: LD_EXP 57
79592: NOT
79593: OR
79594: IFFALSE 79598
// exit ;
79596: GO 79813
// for i = 1 to mc_bases do
79598: LD_ADDR_VAR 0 3
79602: PUSH
79603: DOUBLE
79604: LD_INT 1
79606: DEC
79607: ST_TO_ADDR
79608: LD_EXP 59
79612: PUSH
79613: FOR_TO
79614: IFFALSE 79811
// begin if building in mc_construct_list [ i ] then
79616: LD_VAR 0 1
79620: PUSH
79621: LD_EXP 66
79625: PUSH
79626: LD_VAR 0 3
79630: ARRAY
79631: IN
79632: IFFALSE 79809
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79634: LD_ADDR_EXP 66
79638: PUSH
79639: LD_EXP 66
79643: PPUSH
79644: LD_VAR 0 3
79648: PPUSH
79649: LD_EXP 66
79653: PUSH
79654: LD_VAR 0 3
79658: ARRAY
79659: PUSH
79660: LD_VAR 0 1
79664: DIFF
79665: PPUSH
79666: CALL_OW 1
79670: ST_TO_ADDR
// if building in mc_lab [ i ] then
79671: LD_VAR 0 1
79675: PUSH
79676: LD_EXP 92
79680: PUSH
79681: LD_VAR 0 3
79685: ARRAY
79686: IN
79687: IFFALSE 79742
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
79689: LD_ADDR_EXP 93
79693: PUSH
79694: LD_EXP 93
79698: PPUSH
79699: LD_VAR 0 3
79703: PPUSH
79704: LD_EXP 93
79708: PUSH
79709: LD_VAR 0 3
79713: ARRAY
79714: PPUSH
79715: LD_INT 1
79717: PPUSH
79718: LD_EXP 93
79722: PUSH
79723: LD_VAR 0 3
79727: ARRAY
79728: PPUSH
79729: LD_INT 0
79731: PPUSH
79732: CALL 18656 0 4
79736: PPUSH
79737: CALL_OW 1
79741: ST_TO_ADDR
// if not building in mc_bases [ i ] then
79742: LD_VAR 0 1
79746: PUSH
79747: LD_EXP 59
79751: PUSH
79752: LD_VAR 0 3
79756: ARRAY
79757: IN
79758: NOT
79759: IFFALSE 79805
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79761: LD_ADDR_EXP 59
79765: PUSH
79766: LD_EXP 59
79770: PPUSH
79771: LD_VAR 0 3
79775: PUSH
79776: LD_EXP 59
79780: PUSH
79781: LD_VAR 0 3
79785: ARRAY
79786: PUSH
79787: LD_INT 1
79789: PLUS
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PPUSH
79795: LD_VAR 0 1
79799: PPUSH
79800: CALL 19238 0 3
79804: ST_TO_ADDR
// exit ;
79805: POP
79806: POP
79807: GO 79813
// end ; end ;
79809: GO 79613
79811: POP
79812: POP
// end ;
79813: LD_VAR 0 2
79817: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
79818: LD_INT 0
79820: PPUSH
79821: PPUSH
79822: PPUSH
79823: PPUSH
79824: PPUSH
79825: PPUSH
79826: PPUSH
// if not mc_bases or not skirmish then
79827: LD_EXP 59
79831: NOT
79832: PUSH
79833: LD_EXP 57
79837: NOT
79838: OR
79839: IFFALSE 79843
// exit ;
79841: GO 80504
// for i = 1 to mc_bases do
79843: LD_ADDR_VAR 0 3
79847: PUSH
79848: DOUBLE
79849: LD_INT 1
79851: DEC
79852: ST_TO_ADDR
79853: LD_EXP 59
79857: PUSH
79858: FOR_TO
79859: IFFALSE 80502
// begin if building in mc_construct_list [ i ] then
79861: LD_VAR 0 1
79865: PUSH
79866: LD_EXP 66
79870: PUSH
79871: LD_VAR 0 3
79875: ARRAY
79876: IN
79877: IFFALSE 80500
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79879: LD_ADDR_EXP 66
79883: PUSH
79884: LD_EXP 66
79888: PPUSH
79889: LD_VAR 0 3
79893: PPUSH
79894: LD_EXP 66
79898: PUSH
79899: LD_VAR 0 3
79903: ARRAY
79904: PUSH
79905: LD_VAR 0 1
79909: DIFF
79910: PPUSH
79911: CALL_OW 1
79915: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79916: LD_ADDR_EXP 59
79920: PUSH
79921: LD_EXP 59
79925: PPUSH
79926: LD_VAR 0 3
79930: PUSH
79931: LD_EXP 59
79935: PUSH
79936: LD_VAR 0 3
79940: ARRAY
79941: PUSH
79942: LD_INT 1
79944: PLUS
79945: PUSH
79946: EMPTY
79947: LIST
79948: LIST
79949: PPUSH
79950: LD_VAR 0 1
79954: PPUSH
79955: CALL 19238 0 3
79959: ST_TO_ADDR
// btype := GetBType ( building ) ;
79960: LD_ADDR_VAR 0 5
79964: PUSH
79965: LD_VAR 0 1
79969: PPUSH
79970: CALL_OW 266
79974: ST_TO_ADDR
// side := GetSide ( building ) ;
79975: LD_ADDR_VAR 0 8
79979: PUSH
79980: LD_VAR 0 1
79984: PPUSH
79985: CALL_OW 255
79989: ST_TO_ADDR
// if btype = b_lab then
79990: LD_VAR 0 5
79994: PUSH
79995: LD_INT 6
79997: EQUAL
79998: IFFALSE 80048
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80000: LD_ADDR_EXP 92
80004: PUSH
80005: LD_EXP 92
80009: PPUSH
80010: LD_VAR 0 3
80014: PUSH
80015: LD_EXP 92
80019: PUSH
80020: LD_VAR 0 3
80024: ARRAY
80025: PUSH
80026: LD_INT 1
80028: PLUS
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: PPUSH
80034: LD_VAR 0 1
80038: PPUSH
80039: CALL 19238 0 3
80043: ST_TO_ADDR
// exit ;
80044: POP
80045: POP
80046: GO 80504
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
80048: LD_VAR 0 5
80052: PUSH
80053: LD_INT 0
80055: PUSH
80056: LD_INT 2
80058: PUSH
80059: LD_INT 4
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: LIST
80066: IN
80067: IFFALSE 80191
// begin if btype = b_armoury then
80069: LD_VAR 0 5
80073: PUSH
80074: LD_INT 4
80076: EQUAL
80077: IFFALSE 80087
// btype := b_barracks ;
80079: LD_ADDR_VAR 0 5
80083: PUSH
80084: LD_INT 5
80086: ST_TO_ADDR
// if btype = b_depot then
80087: LD_VAR 0 5
80091: PUSH
80092: LD_INT 0
80094: EQUAL
80095: IFFALSE 80105
// btype := b_warehouse ;
80097: LD_ADDR_VAR 0 5
80101: PUSH
80102: LD_INT 1
80104: ST_TO_ADDR
// if btype = b_workshop then
80105: LD_VAR 0 5
80109: PUSH
80110: LD_INT 2
80112: EQUAL
80113: IFFALSE 80123
// btype := b_factory ;
80115: LD_ADDR_VAR 0 5
80119: PUSH
80120: LD_INT 3
80122: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
80123: LD_VAR 0 5
80127: PPUSH
80128: LD_VAR 0 8
80132: PPUSH
80133: CALL_OW 323
80137: PUSH
80138: LD_INT 1
80140: EQUAL
80141: IFFALSE 80187
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
80143: LD_ADDR_EXP 91
80147: PUSH
80148: LD_EXP 91
80152: PPUSH
80153: LD_VAR 0 3
80157: PUSH
80158: LD_EXP 91
80162: PUSH
80163: LD_VAR 0 3
80167: ARRAY
80168: PUSH
80169: LD_INT 1
80171: PLUS
80172: PUSH
80173: EMPTY
80174: LIST
80175: LIST
80176: PPUSH
80177: LD_VAR 0 1
80181: PPUSH
80182: CALL 19238 0 3
80186: ST_TO_ADDR
// exit ;
80187: POP
80188: POP
80189: GO 80504
// end ; if btype in [ b_bunker , b_turret ] then
80191: LD_VAR 0 5
80195: PUSH
80196: LD_INT 32
80198: PUSH
80199: LD_INT 33
80201: PUSH
80202: EMPTY
80203: LIST
80204: LIST
80205: IN
80206: IFFALSE 80496
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
80208: LD_ADDR_EXP 67
80212: PUSH
80213: LD_EXP 67
80217: PPUSH
80218: LD_VAR 0 3
80222: PUSH
80223: LD_EXP 67
80227: PUSH
80228: LD_VAR 0 3
80232: ARRAY
80233: PUSH
80234: LD_INT 1
80236: PLUS
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: PPUSH
80242: LD_VAR 0 1
80246: PPUSH
80247: CALL 19238 0 3
80251: ST_TO_ADDR
// if btype = b_bunker then
80252: LD_VAR 0 5
80256: PUSH
80257: LD_INT 32
80259: EQUAL
80260: IFFALSE 80496
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80262: LD_ADDR_EXP 68
80266: PUSH
80267: LD_EXP 68
80271: PPUSH
80272: LD_VAR 0 3
80276: PUSH
80277: LD_EXP 68
80281: PUSH
80282: LD_VAR 0 3
80286: ARRAY
80287: PUSH
80288: LD_INT 1
80290: PLUS
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: PPUSH
80296: LD_VAR 0 1
80300: PPUSH
80301: CALL 19238 0 3
80305: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
80306: LD_ADDR_VAR 0 6
80310: PUSH
80311: LD_EXP 59
80315: PUSH
80316: LD_VAR 0 3
80320: ARRAY
80321: PPUSH
80322: LD_INT 25
80324: PUSH
80325: LD_INT 1
80327: PUSH
80328: EMPTY
80329: LIST
80330: LIST
80331: PUSH
80332: LD_INT 3
80334: PUSH
80335: LD_INT 54
80337: PUSH
80338: EMPTY
80339: LIST
80340: PUSH
80341: EMPTY
80342: LIST
80343: LIST
80344: PUSH
80345: EMPTY
80346: LIST
80347: LIST
80348: PPUSH
80349: CALL_OW 72
80353: ST_TO_ADDR
// if tmp then
80354: LD_VAR 0 6
80358: IFFALSE 80364
// exit ;
80360: POP
80361: POP
80362: GO 80504
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
80364: LD_ADDR_VAR 0 6
80368: PUSH
80369: LD_EXP 59
80373: PUSH
80374: LD_VAR 0 3
80378: ARRAY
80379: PPUSH
80380: LD_INT 2
80382: PUSH
80383: LD_INT 30
80385: PUSH
80386: LD_INT 4
80388: PUSH
80389: EMPTY
80390: LIST
80391: LIST
80392: PUSH
80393: LD_INT 30
80395: PUSH
80396: LD_INT 5
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: EMPTY
80404: LIST
80405: LIST
80406: LIST
80407: PPUSH
80408: CALL_OW 72
80412: ST_TO_ADDR
// if not tmp then
80413: LD_VAR 0 6
80417: NOT
80418: IFFALSE 80424
// exit ;
80420: POP
80421: POP
80422: GO 80504
// for j in tmp do
80424: LD_ADDR_VAR 0 4
80428: PUSH
80429: LD_VAR 0 6
80433: PUSH
80434: FOR_IN
80435: IFFALSE 80494
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
80437: LD_ADDR_VAR 0 7
80441: PUSH
80442: LD_VAR 0 4
80446: PPUSH
80447: CALL_OW 313
80451: PPUSH
80452: LD_INT 25
80454: PUSH
80455: LD_INT 1
80457: PUSH
80458: EMPTY
80459: LIST
80460: LIST
80461: PPUSH
80462: CALL_OW 72
80466: ST_TO_ADDR
// if units then
80467: LD_VAR 0 7
80471: IFFALSE 80492
// begin ComExitBuilding ( units [ 1 ] ) ;
80473: LD_VAR 0 7
80477: PUSH
80478: LD_INT 1
80480: ARRAY
80481: PPUSH
80482: CALL_OW 122
// exit ;
80486: POP
80487: POP
80488: POP
80489: POP
80490: GO 80504
// end ; end ;
80492: GO 80434
80494: POP
80495: POP
// end ; end ; exit ;
80496: POP
80497: POP
80498: GO 80504
// end ; end ;
80500: GO 79858
80502: POP
80503: POP
// end ;
80504: LD_VAR 0 2
80508: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
80509: LD_INT 0
80511: PPUSH
80512: PPUSH
80513: PPUSH
80514: PPUSH
80515: PPUSH
80516: PPUSH
80517: PPUSH
// if not mc_bases or not skirmish then
80518: LD_EXP 59
80522: NOT
80523: PUSH
80524: LD_EXP 57
80528: NOT
80529: OR
80530: IFFALSE 80534
// exit ;
80532: GO 80765
// btype := GetBType ( building ) ;
80534: LD_ADDR_VAR 0 6
80538: PUSH
80539: LD_VAR 0 1
80543: PPUSH
80544: CALL_OW 266
80548: ST_TO_ADDR
// x := GetX ( building ) ;
80549: LD_ADDR_VAR 0 7
80553: PUSH
80554: LD_VAR 0 1
80558: PPUSH
80559: CALL_OW 250
80563: ST_TO_ADDR
// y := GetY ( building ) ;
80564: LD_ADDR_VAR 0 8
80568: PUSH
80569: LD_VAR 0 1
80573: PPUSH
80574: CALL_OW 251
80578: ST_TO_ADDR
// d := GetDir ( building ) ;
80579: LD_ADDR_VAR 0 9
80583: PUSH
80584: LD_VAR 0 1
80588: PPUSH
80589: CALL_OW 254
80593: ST_TO_ADDR
// for i = 1 to mc_bases do
80594: LD_ADDR_VAR 0 4
80598: PUSH
80599: DOUBLE
80600: LD_INT 1
80602: DEC
80603: ST_TO_ADDR
80604: LD_EXP 59
80608: PUSH
80609: FOR_TO
80610: IFFALSE 80763
// begin if not mc_build_list [ i ] then
80612: LD_EXP 64
80616: PUSH
80617: LD_VAR 0 4
80621: ARRAY
80622: NOT
80623: IFFALSE 80627
// continue ;
80625: GO 80609
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
80627: LD_VAR 0 6
80631: PUSH
80632: LD_VAR 0 7
80636: PUSH
80637: LD_VAR 0 8
80641: PUSH
80642: LD_VAR 0 9
80646: PUSH
80647: EMPTY
80648: LIST
80649: LIST
80650: LIST
80651: LIST
80652: PPUSH
80653: LD_EXP 64
80657: PUSH
80658: LD_VAR 0 4
80662: ARRAY
80663: PUSH
80664: LD_INT 1
80666: ARRAY
80667: PPUSH
80668: CALL 25407 0 2
80672: IFFALSE 80761
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
80674: LD_ADDR_EXP 64
80678: PUSH
80679: LD_EXP 64
80683: PPUSH
80684: LD_VAR 0 4
80688: PPUSH
80689: LD_EXP 64
80693: PUSH
80694: LD_VAR 0 4
80698: ARRAY
80699: PPUSH
80700: LD_INT 1
80702: PPUSH
80703: CALL_OW 3
80707: PPUSH
80708: CALL_OW 1
80712: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
80713: LD_ADDR_EXP 66
80717: PUSH
80718: LD_EXP 66
80722: PPUSH
80723: LD_VAR 0 4
80727: PUSH
80728: LD_EXP 66
80732: PUSH
80733: LD_VAR 0 4
80737: ARRAY
80738: PUSH
80739: LD_INT 1
80741: PLUS
80742: PUSH
80743: EMPTY
80744: LIST
80745: LIST
80746: PPUSH
80747: LD_VAR 0 1
80751: PPUSH
80752: CALL 19238 0 3
80756: ST_TO_ADDR
// exit ;
80757: POP
80758: POP
80759: GO 80765
// end ; end ;
80761: GO 80609
80763: POP
80764: POP
// end ;
80765: LD_VAR 0 3
80769: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
80770: LD_INT 0
80772: PPUSH
80773: PPUSH
80774: PPUSH
// if not mc_bases or not skirmish then
80775: LD_EXP 59
80779: NOT
80780: PUSH
80781: LD_EXP 57
80785: NOT
80786: OR
80787: IFFALSE 80791
// exit ;
80789: GO 80981
// for i = 1 to mc_bases do
80791: LD_ADDR_VAR 0 4
80795: PUSH
80796: DOUBLE
80797: LD_INT 1
80799: DEC
80800: ST_TO_ADDR
80801: LD_EXP 59
80805: PUSH
80806: FOR_TO
80807: IFFALSE 80894
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
80809: LD_VAR 0 1
80813: PUSH
80814: LD_EXP 67
80818: PUSH
80819: LD_VAR 0 4
80823: ARRAY
80824: IN
80825: PUSH
80826: LD_VAR 0 1
80830: PUSH
80831: LD_EXP 68
80835: PUSH
80836: LD_VAR 0 4
80840: ARRAY
80841: IN
80842: NOT
80843: AND
80844: IFFALSE 80892
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80846: LD_ADDR_EXP 68
80850: PUSH
80851: LD_EXP 68
80855: PPUSH
80856: LD_VAR 0 4
80860: PUSH
80861: LD_EXP 68
80865: PUSH
80866: LD_VAR 0 4
80870: ARRAY
80871: PUSH
80872: LD_INT 1
80874: PLUS
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: PPUSH
80880: LD_VAR 0 1
80884: PPUSH
80885: CALL 19238 0 3
80889: ST_TO_ADDR
// break ;
80890: GO 80894
// end ; end ;
80892: GO 80806
80894: POP
80895: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
80896: LD_VAR 0 1
80900: PPUSH
80901: CALL_OW 257
80905: PUSH
80906: LD_EXP 85
80910: IN
80911: PUSH
80912: LD_VAR 0 1
80916: PPUSH
80917: CALL_OW 266
80921: PUSH
80922: LD_INT 5
80924: EQUAL
80925: AND
80926: PUSH
80927: LD_VAR 0 2
80931: PPUSH
80932: CALL_OW 110
80936: PUSH
80937: LD_INT 18
80939: NONEQUAL
80940: AND
80941: IFFALSE 80981
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
80943: LD_VAR 0 2
80947: PPUSH
80948: CALL_OW 257
80952: PUSH
80953: LD_INT 5
80955: PUSH
80956: LD_INT 8
80958: PUSH
80959: LD_INT 9
80961: PUSH
80962: EMPTY
80963: LIST
80964: LIST
80965: LIST
80966: IN
80967: IFFALSE 80981
// SetClass ( unit , 1 ) ;
80969: LD_VAR 0 2
80973: PPUSH
80974: LD_INT 1
80976: PPUSH
80977: CALL_OW 336
// end ;
80981: LD_VAR 0 3
80985: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
80986: LD_INT 0
80988: PPUSH
80989: PPUSH
// if not mc_bases or not skirmish then
80990: LD_EXP 59
80994: NOT
80995: PUSH
80996: LD_EXP 57
81000: NOT
81001: OR
81002: IFFALSE 81006
// exit ;
81004: GO 81122
// if GetLives ( abandoned_vehicle ) > 250 then
81006: LD_VAR 0 2
81010: PPUSH
81011: CALL_OW 256
81015: PUSH
81016: LD_INT 250
81018: GREATER
81019: IFFALSE 81023
// exit ;
81021: GO 81122
// for i = 1 to mc_bases do
81023: LD_ADDR_VAR 0 6
81027: PUSH
81028: DOUBLE
81029: LD_INT 1
81031: DEC
81032: ST_TO_ADDR
81033: LD_EXP 59
81037: PUSH
81038: FOR_TO
81039: IFFALSE 81120
// begin if driver in mc_bases [ i ] then
81041: LD_VAR 0 1
81045: PUSH
81046: LD_EXP 59
81050: PUSH
81051: LD_VAR 0 6
81055: ARRAY
81056: IN
81057: IFFALSE 81118
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
81059: LD_VAR 0 1
81063: PPUSH
81064: LD_EXP 59
81068: PUSH
81069: LD_VAR 0 6
81073: ARRAY
81074: PPUSH
81075: LD_INT 2
81077: PUSH
81078: LD_INT 30
81080: PUSH
81081: LD_INT 0
81083: PUSH
81084: EMPTY
81085: LIST
81086: LIST
81087: PUSH
81088: LD_INT 30
81090: PUSH
81091: LD_INT 1
81093: PUSH
81094: EMPTY
81095: LIST
81096: LIST
81097: PUSH
81098: EMPTY
81099: LIST
81100: LIST
81101: LIST
81102: PPUSH
81103: CALL_OW 72
81107: PUSH
81108: LD_INT 1
81110: ARRAY
81111: PPUSH
81112: CALL_OW 112
// break ;
81116: GO 81120
// end ; end ;
81118: GO 81038
81120: POP
81121: POP
// end ; end_of_file
81122: LD_VAR 0 5
81126: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
81127: LD_INT 0
81129: PPUSH
// ar_miner := 81 ;
81130: LD_ADDR_EXP 109
81134: PUSH
81135: LD_INT 81
81137: ST_TO_ADDR
// ar_crane := 88 ;
81138: LD_ADDR_EXP 108
81142: PUSH
81143: LD_INT 88
81145: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
81146: LD_ADDR_EXP 103
81150: PUSH
81151: LD_INT 89
81153: ST_TO_ADDR
// us_hack := 99 ;
81154: LD_ADDR_EXP 104
81158: PUSH
81159: LD_INT 99
81161: ST_TO_ADDR
// us_artillery := 97 ;
81162: LD_ADDR_EXP 105
81166: PUSH
81167: LD_INT 97
81169: ST_TO_ADDR
// ar_bio_bomb := 91 ;
81170: LD_ADDR_EXP 106
81174: PUSH
81175: LD_INT 91
81177: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
81178: LD_ADDR_EXP 107
81182: PUSH
81183: LD_INT 92
81185: ST_TO_ADDR
// ru_radar := 98 ;
81186: LD_ADDR_EXP 102
81190: PUSH
81191: LD_INT 98
81193: ST_TO_ADDR
// tech_Artillery := 80 ;
81194: LD_ADDR_EXP 110
81198: PUSH
81199: LD_INT 80
81201: ST_TO_ADDR
// tech_RadMat := 81 ;
81202: LD_ADDR_EXP 111
81206: PUSH
81207: LD_INT 81
81209: ST_TO_ADDR
// tech_BasicTools := 82 ;
81210: LD_ADDR_EXP 112
81214: PUSH
81215: LD_INT 82
81217: ST_TO_ADDR
// tech_Cargo := 83 ;
81218: LD_ADDR_EXP 113
81222: PUSH
81223: LD_INT 83
81225: ST_TO_ADDR
// tech_Track := 84 ;
81226: LD_ADDR_EXP 114
81230: PUSH
81231: LD_INT 84
81233: ST_TO_ADDR
// tech_Crane := 85 ;
81234: LD_ADDR_EXP 115
81238: PUSH
81239: LD_INT 85
81241: ST_TO_ADDR
// tech_Bulldozer := 86 ;
81242: LD_ADDR_EXP 116
81246: PUSH
81247: LD_INT 86
81249: ST_TO_ADDR
// tech_Hovercraft := 87 ;
81250: LD_ADDR_EXP 117
81254: PUSH
81255: LD_INT 87
81257: ST_TO_ADDR
// end ;
81258: LD_VAR 0 1
81262: RET
// every 1 do
81263: GO 81265
81265: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
81266: CALL 81127 0 0
81270: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
81271: LD_VAR 0 2
81275: PUSH
81276: LD_INT 100
81278: EQUAL
81279: IFFALSE 82228
// begin if not StreamModeActive then
81281: LD_EXP 118
81285: NOT
81286: IFFALSE 81296
// StreamModeActive := true ;
81288: LD_ADDR_EXP 118
81292: PUSH
81293: LD_INT 1
81295: ST_TO_ADDR
// if p3 = 0 then
81296: LD_VAR 0 3
81300: PUSH
81301: LD_INT 0
81303: EQUAL
81304: IFFALSE 81310
// InitStreamMode ;
81306: CALL 82386 0 0
// if p3 = 1 then
81310: LD_VAR 0 3
81314: PUSH
81315: LD_INT 1
81317: EQUAL
81318: IFFALSE 81328
// sRocket := true ;
81320: LD_ADDR_EXP 123
81324: PUSH
81325: LD_INT 1
81327: ST_TO_ADDR
// if p3 = 2 then
81328: LD_VAR 0 3
81332: PUSH
81333: LD_INT 2
81335: EQUAL
81336: IFFALSE 81346
// sSpeed := true ;
81338: LD_ADDR_EXP 122
81342: PUSH
81343: LD_INT 1
81345: ST_TO_ADDR
// if p3 = 3 then
81346: LD_VAR 0 3
81350: PUSH
81351: LD_INT 3
81353: EQUAL
81354: IFFALSE 81364
// sEngine := true ;
81356: LD_ADDR_EXP 124
81360: PUSH
81361: LD_INT 1
81363: ST_TO_ADDR
// if p3 = 4 then
81364: LD_VAR 0 3
81368: PUSH
81369: LD_INT 4
81371: EQUAL
81372: IFFALSE 81382
// sSpec := true ;
81374: LD_ADDR_EXP 121
81378: PUSH
81379: LD_INT 1
81381: ST_TO_ADDR
// if p3 = 5 then
81382: LD_VAR 0 3
81386: PUSH
81387: LD_INT 5
81389: EQUAL
81390: IFFALSE 81400
// sLevel := true ;
81392: LD_ADDR_EXP 125
81396: PUSH
81397: LD_INT 1
81399: ST_TO_ADDR
// if p3 = 6 then
81400: LD_VAR 0 3
81404: PUSH
81405: LD_INT 6
81407: EQUAL
81408: IFFALSE 81418
// sArmoury := true ;
81410: LD_ADDR_EXP 126
81414: PUSH
81415: LD_INT 1
81417: ST_TO_ADDR
// if p3 = 7 then
81418: LD_VAR 0 3
81422: PUSH
81423: LD_INT 7
81425: EQUAL
81426: IFFALSE 81436
// sRadar := true ;
81428: LD_ADDR_EXP 127
81432: PUSH
81433: LD_INT 1
81435: ST_TO_ADDR
// if p3 = 8 then
81436: LD_VAR 0 3
81440: PUSH
81441: LD_INT 8
81443: EQUAL
81444: IFFALSE 81454
// sBunker := true ;
81446: LD_ADDR_EXP 128
81450: PUSH
81451: LD_INT 1
81453: ST_TO_ADDR
// if p3 = 9 then
81454: LD_VAR 0 3
81458: PUSH
81459: LD_INT 9
81461: EQUAL
81462: IFFALSE 81472
// sHack := true ;
81464: LD_ADDR_EXP 129
81468: PUSH
81469: LD_INT 1
81471: ST_TO_ADDR
// if p3 = 10 then
81472: LD_VAR 0 3
81476: PUSH
81477: LD_INT 10
81479: EQUAL
81480: IFFALSE 81490
// sFire := true ;
81482: LD_ADDR_EXP 130
81486: PUSH
81487: LD_INT 1
81489: ST_TO_ADDR
// if p3 = 11 then
81490: LD_VAR 0 3
81494: PUSH
81495: LD_INT 11
81497: EQUAL
81498: IFFALSE 81508
// sRefresh := true ;
81500: LD_ADDR_EXP 131
81504: PUSH
81505: LD_INT 1
81507: ST_TO_ADDR
// if p3 = 12 then
81508: LD_VAR 0 3
81512: PUSH
81513: LD_INT 12
81515: EQUAL
81516: IFFALSE 81526
// sExp := true ;
81518: LD_ADDR_EXP 132
81522: PUSH
81523: LD_INT 1
81525: ST_TO_ADDR
// if p3 = 13 then
81526: LD_VAR 0 3
81530: PUSH
81531: LD_INT 13
81533: EQUAL
81534: IFFALSE 81544
// sDepot := true ;
81536: LD_ADDR_EXP 133
81540: PUSH
81541: LD_INT 1
81543: ST_TO_ADDR
// if p3 = 14 then
81544: LD_VAR 0 3
81548: PUSH
81549: LD_INT 14
81551: EQUAL
81552: IFFALSE 81562
// sFlag := true ;
81554: LD_ADDR_EXP 134
81558: PUSH
81559: LD_INT 1
81561: ST_TO_ADDR
// if p3 = 15 then
81562: LD_VAR 0 3
81566: PUSH
81567: LD_INT 15
81569: EQUAL
81570: IFFALSE 81580
// sKamikadze := true ;
81572: LD_ADDR_EXP 142
81576: PUSH
81577: LD_INT 1
81579: ST_TO_ADDR
// if p3 = 16 then
81580: LD_VAR 0 3
81584: PUSH
81585: LD_INT 16
81587: EQUAL
81588: IFFALSE 81598
// sTroll := true ;
81590: LD_ADDR_EXP 143
81594: PUSH
81595: LD_INT 1
81597: ST_TO_ADDR
// if p3 = 17 then
81598: LD_VAR 0 3
81602: PUSH
81603: LD_INT 17
81605: EQUAL
81606: IFFALSE 81616
// sSlow := true ;
81608: LD_ADDR_EXP 144
81612: PUSH
81613: LD_INT 1
81615: ST_TO_ADDR
// if p3 = 18 then
81616: LD_VAR 0 3
81620: PUSH
81621: LD_INT 18
81623: EQUAL
81624: IFFALSE 81634
// sLack := true ;
81626: LD_ADDR_EXP 145
81630: PUSH
81631: LD_INT 1
81633: ST_TO_ADDR
// if p3 = 19 then
81634: LD_VAR 0 3
81638: PUSH
81639: LD_INT 19
81641: EQUAL
81642: IFFALSE 81652
// sTank := true ;
81644: LD_ADDR_EXP 147
81648: PUSH
81649: LD_INT 1
81651: ST_TO_ADDR
// if p3 = 20 then
81652: LD_VAR 0 3
81656: PUSH
81657: LD_INT 20
81659: EQUAL
81660: IFFALSE 81670
// sRemote := true ;
81662: LD_ADDR_EXP 148
81666: PUSH
81667: LD_INT 1
81669: ST_TO_ADDR
// if p3 = 21 then
81670: LD_VAR 0 3
81674: PUSH
81675: LD_INT 21
81677: EQUAL
81678: IFFALSE 81688
// sPowell := true ;
81680: LD_ADDR_EXP 149
81684: PUSH
81685: LD_INT 1
81687: ST_TO_ADDR
// if p3 = 22 then
81688: LD_VAR 0 3
81692: PUSH
81693: LD_INT 22
81695: EQUAL
81696: IFFALSE 81706
// sTeleport := true ;
81698: LD_ADDR_EXP 152
81702: PUSH
81703: LD_INT 1
81705: ST_TO_ADDR
// if p3 = 23 then
81706: LD_VAR 0 3
81710: PUSH
81711: LD_INT 23
81713: EQUAL
81714: IFFALSE 81724
// sOilTower := true ;
81716: LD_ADDR_EXP 154
81720: PUSH
81721: LD_INT 1
81723: ST_TO_ADDR
// if p3 = 24 then
81724: LD_VAR 0 3
81728: PUSH
81729: LD_INT 24
81731: EQUAL
81732: IFFALSE 81742
// sShovel := true ;
81734: LD_ADDR_EXP 155
81738: PUSH
81739: LD_INT 1
81741: ST_TO_ADDR
// if p3 = 25 then
81742: LD_VAR 0 3
81746: PUSH
81747: LD_INT 25
81749: EQUAL
81750: IFFALSE 81760
// sSheik := true ;
81752: LD_ADDR_EXP 156
81756: PUSH
81757: LD_INT 1
81759: ST_TO_ADDR
// if p3 = 26 then
81760: LD_VAR 0 3
81764: PUSH
81765: LD_INT 26
81767: EQUAL
81768: IFFALSE 81778
// sEarthquake := true ;
81770: LD_ADDR_EXP 158
81774: PUSH
81775: LD_INT 1
81777: ST_TO_ADDR
// if p3 = 27 then
81778: LD_VAR 0 3
81782: PUSH
81783: LD_INT 27
81785: EQUAL
81786: IFFALSE 81796
// sAI := true ;
81788: LD_ADDR_EXP 159
81792: PUSH
81793: LD_INT 1
81795: ST_TO_ADDR
// if p3 = 28 then
81796: LD_VAR 0 3
81800: PUSH
81801: LD_INT 28
81803: EQUAL
81804: IFFALSE 81814
// sCargo := true ;
81806: LD_ADDR_EXP 162
81810: PUSH
81811: LD_INT 1
81813: ST_TO_ADDR
// if p3 = 29 then
81814: LD_VAR 0 3
81818: PUSH
81819: LD_INT 29
81821: EQUAL
81822: IFFALSE 81832
// sDLaser := true ;
81824: LD_ADDR_EXP 163
81828: PUSH
81829: LD_INT 1
81831: ST_TO_ADDR
// if p3 = 30 then
81832: LD_VAR 0 3
81836: PUSH
81837: LD_INT 30
81839: EQUAL
81840: IFFALSE 81850
// sExchange := true ;
81842: LD_ADDR_EXP 164
81846: PUSH
81847: LD_INT 1
81849: ST_TO_ADDR
// if p3 = 31 then
81850: LD_VAR 0 3
81854: PUSH
81855: LD_INT 31
81857: EQUAL
81858: IFFALSE 81868
// sFac := true ;
81860: LD_ADDR_EXP 165
81864: PUSH
81865: LD_INT 1
81867: ST_TO_ADDR
// if p3 = 32 then
81868: LD_VAR 0 3
81872: PUSH
81873: LD_INT 32
81875: EQUAL
81876: IFFALSE 81886
// sPower := true ;
81878: LD_ADDR_EXP 166
81882: PUSH
81883: LD_INT 1
81885: ST_TO_ADDR
// if p3 = 33 then
81886: LD_VAR 0 3
81890: PUSH
81891: LD_INT 33
81893: EQUAL
81894: IFFALSE 81904
// sRandom := true ;
81896: LD_ADDR_EXP 167
81900: PUSH
81901: LD_INT 1
81903: ST_TO_ADDR
// if p3 = 34 then
81904: LD_VAR 0 3
81908: PUSH
81909: LD_INT 34
81911: EQUAL
81912: IFFALSE 81922
// sShield := true ;
81914: LD_ADDR_EXP 168
81918: PUSH
81919: LD_INT 1
81921: ST_TO_ADDR
// if p3 = 35 then
81922: LD_VAR 0 3
81926: PUSH
81927: LD_INT 35
81929: EQUAL
81930: IFFALSE 81940
// sTime := true ;
81932: LD_ADDR_EXP 169
81936: PUSH
81937: LD_INT 1
81939: ST_TO_ADDR
// if p3 = 36 then
81940: LD_VAR 0 3
81944: PUSH
81945: LD_INT 36
81947: EQUAL
81948: IFFALSE 81958
// sTools := true ;
81950: LD_ADDR_EXP 170
81954: PUSH
81955: LD_INT 1
81957: ST_TO_ADDR
// if p3 = 101 then
81958: LD_VAR 0 3
81962: PUSH
81963: LD_INT 101
81965: EQUAL
81966: IFFALSE 81976
// sSold := true ;
81968: LD_ADDR_EXP 135
81972: PUSH
81973: LD_INT 1
81975: ST_TO_ADDR
// if p3 = 102 then
81976: LD_VAR 0 3
81980: PUSH
81981: LD_INT 102
81983: EQUAL
81984: IFFALSE 81994
// sDiff := true ;
81986: LD_ADDR_EXP 136
81990: PUSH
81991: LD_INT 1
81993: ST_TO_ADDR
// if p3 = 103 then
81994: LD_VAR 0 3
81998: PUSH
81999: LD_INT 103
82001: EQUAL
82002: IFFALSE 82012
// sFog := true ;
82004: LD_ADDR_EXP 139
82008: PUSH
82009: LD_INT 1
82011: ST_TO_ADDR
// if p3 = 104 then
82012: LD_VAR 0 3
82016: PUSH
82017: LD_INT 104
82019: EQUAL
82020: IFFALSE 82030
// sReset := true ;
82022: LD_ADDR_EXP 140
82026: PUSH
82027: LD_INT 1
82029: ST_TO_ADDR
// if p3 = 105 then
82030: LD_VAR 0 3
82034: PUSH
82035: LD_INT 105
82037: EQUAL
82038: IFFALSE 82048
// sSun := true ;
82040: LD_ADDR_EXP 141
82044: PUSH
82045: LD_INT 1
82047: ST_TO_ADDR
// if p3 = 106 then
82048: LD_VAR 0 3
82052: PUSH
82053: LD_INT 106
82055: EQUAL
82056: IFFALSE 82066
// sTiger := true ;
82058: LD_ADDR_EXP 137
82062: PUSH
82063: LD_INT 1
82065: ST_TO_ADDR
// if p3 = 107 then
82066: LD_VAR 0 3
82070: PUSH
82071: LD_INT 107
82073: EQUAL
82074: IFFALSE 82084
// sBomb := true ;
82076: LD_ADDR_EXP 138
82080: PUSH
82081: LD_INT 1
82083: ST_TO_ADDR
// if p3 = 108 then
82084: LD_VAR 0 3
82088: PUSH
82089: LD_INT 108
82091: EQUAL
82092: IFFALSE 82102
// sWound := true ;
82094: LD_ADDR_EXP 146
82098: PUSH
82099: LD_INT 1
82101: ST_TO_ADDR
// if p3 = 109 then
82102: LD_VAR 0 3
82106: PUSH
82107: LD_INT 109
82109: EQUAL
82110: IFFALSE 82120
// sBetray := true ;
82112: LD_ADDR_EXP 150
82116: PUSH
82117: LD_INT 1
82119: ST_TO_ADDR
// if p3 = 110 then
82120: LD_VAR 0 3
82124: PUSH
82125: LD_INT 110
82127: EQUAL
82128: IFFALSE 82138
// sContamin := true ;
82130: LD_ADDR_EXP 151
82134: PUSH
82135: LD_INT 1
82137: ST_TO_ADDR
// if p3 = 111 then
82138: LD_VAR 0 3
82142: PUSH
82143: LD_INT 111
82145: EQUAL
82146: IFFALSE 82156
// sOil := true ;
82148: LD_ADDR_EXP 153
82152: PUSH
82153: LD_INT 1
82155: ST_TO_ADDR
// if p3 = 112 then
82156: LD_VAR 0 3
82160: PUSH
82161: LD_INT 112
82163: EQUAL
82164: IFFALSE 82174
// sStu := true ;
82166: LD_ADDR_EXP 157
82170: PUSH
82171: LD_INT 1
82173: ST_TO_ADDR
// if p3 = 113 then
82174: LD_VAR 0 3
82178: PUSH
82179: LD_INT 113
82181: EQUAL
82182: IFFALSE 82192
// sBazooka := true ;
82184: LD_ADDR_EXP 160
82188: PUSH
82189: LD_INT 1
82191: ST_TO_ADDR
// if p3 = 114 then
82192: LD_VAR 0 3
82196: PUSH
82197: LD_INT 114
82199: EQUAL
82200: IFFALSE 82210
// sMortar := true ;
82202: LD_ADDR_EXP 161
82206: PUSH
82207: LD_INT 1
82209: ST_TO_ADDR
// if p3 = 115 then
82210: LD_VAR 0 3
82214: PUSH
82215: LD_INT 115
82217: EQUAL
82218: IFFALSE 82228
// sRanger := true ;
82220: LD_ADDR_EXP 171
82224: PUSH
82225: LD_INT 1
82227: ST_TO_ADDR
// end ; if p2 = 101 then
82228: LD_VAR 0 2
82232: PUSH
82233: LD_INT 101
82235: EQUAL
82236: IFFALSE 82364
// begin case p3 of 1 :
82238: LD_VAR 0 3
82242: PUSH
82243: LD_INT 1
82245: DOUBLE
82246: EQUAL
82247: IFTRUE 82251
82249: GO 82258
82251: POP
// hHackUnlimitedResources ; 2 :
82252: CALL 93399 0 0
82256: GO 82364
82258: LD_INT 2
82260: DOUBLE
82261: EQUAL
82262: IFTRUE 82266
82264: GO 82273
82266: POP
// hHackSetLevel10 ; 3 :
82267: CALL 93532 0 0
82271: GO 82364
82273: LD_INT 3
82275: DOUBLE
82276: EQUAL
82277: IFTRUE 82281
82279: GO 82288
82281: POP
// hHackSetLevel10YourUnits ; 4 :
82282: CALL 93617 0 0
82286: GO 82364
82288: LD_INT 4
82290: DOUBLE
82291: EQUAL
82292: IFTRUE 82296
82294: GO 82303
82296: POP
// hHackInvincible ; 5 :
82297: CALL 94065 0 0
82301: GO 82364
82303: LD_INT 5
82305: DOUBLE
82306: EQUAL
82307: IFTRUE 82311
82309: GO 82318
82311: POP
// hHackInvisible ; 6 :
82312: CALL 94176 0 0
82316: GO 82364
82318: LD_INT 6
82320: DOUBLE
82321: EQUAL
82322: IFTRUE 82326
82324: GO 82333
82326: POP
// hHackChangeYourSide ; 7 :
82327: CALL 94233 0 0
82331: GO 82364
82333: LD_INT 7
82335: DOUBLE
82336: EQUAL
82337: IFTRUE 82341
82339: GO 82348
82341: POP
// hHackChangeUnitSide ; 8 :
82342: CALL 94275 0 0
82346: GO 82364
82348: LD_INT 8
82350: DOUBLE
82351: EQUAL
82352: IFTRUE 82356
82354: GO 82363
82356: POP
// hHackFog ; end ;
82357: CALL 94376 0 0
82361: GO 82364
82363: POP
// end ; end ;
82364: PPOPN 6
82366: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
82367: GO 82369
82369: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
82370: LD_STRING initStreamRollete();
82372: PPUSH
82373: CALL_OW 559
// InitStreamMode ;
82377: CALL 82386 0 0
// DefineStreamItems ( ) ;
82381: CALL 82826 0 0
// end ;
82385: END
// function InitStreamMode ; begin
82386: LD_INT 0
82388: PPUSH
// streamModeActive := false ;
82389: LD_ADDR_EXP 118
82393: PUSH
82394: LD_INT 0
82396: ST_TO_ADDR
// normalCounter := 36 ;
82397: LD_ADDR_EXP 119
82401: PUSH
82402: LD_INT 36
82404: ST_TO_ADDR
// hardcoreCounter := 16 ;
82405: LD_ADDR_EXP 120
82409: PUSH
82410: LD_INT 16
82412: ST_TO_ADDR
// sRocket := false ;
82413: LD_ADDR_EXP 123
82417: PUSH
82418: LD_INT 0
82420: ST_TO_ADDR
// sSpeed := false ;
82421: LD_ADDR_EXP 122
82425: PUSH
82426: LD_INT 0
82428: ST_TO_ADDR
// sEngine := false ;
82429: LD_ADDR_EXP 124
82433: PUSH
82434: LD_INT 0
82436: ST_TO_ADDR
// sSpec := false ;
82437: LD_ADDR_EXP 121
82441: PUSH
82442: LD_INT 0
82444: ST_TO_ADDR
// sLevel := false ;
82445: LD_ADDR_EXP 125
82449: PUSH
82450: LD_INT 0
82452: ST_TO_ADDR
// sArmoury := false ;
82453: LD_ADDR_EXP 126
82457: PUSH
82458: LD_INT 0
82460: ST_TO_ADDR
// sRadar := false ;
82461: LD_ADDR_EXP 127
82465: PUSH
82466: LD_INT 0
82468: ST_TO_ADDR
// sBunker := false ;
82469: LD_ADDR_EXP 128
82473: PUSH
82474: LD_INT 0
82476: ST_TO_ADDR
// sHack := false ;
82477: LD_ADDR_EXP 129
82481: PUSH
82482: LD_INT 0
82484: ST_TO_ADDR
// sFire := false ;
82485: LD_ADDR_EXP 130
82489: PUSH
82490: LD_INT 0
82492: ST_TO_ADDR
// sRefresh := false ;
82493: LD_ADDR_EXP 131
82497: PUSH
82498: LD_INT 0
82500: ST_TO_ADDR
// sExp := false ;
82501: LD_ADDR_EXP 132
82505: PUSH
82506: LD_INT 0
82508: ST_TO_ADDR
// sDepot := false ;
82509: LD_ADDR_EXP 133
82513: PUSH
82514: LD_INT 0
82516: ST_TO_ADDR
// sFlag := false ;
82517: LD_ADDR_EXP 134
82521: PUSH
82522: LD_INT 0
82524: ST_TO_ADDR
// sKamikadze := false ;
82525: LD_ADDR_EXP 142
82529: PUSH
82530: LD_INT 0
82532: ST_TO_ADDR
// sTroll := false ;
82533: LD_ADDR_EXP 143
82537: PUSH
82538: LD_INT 0
82540: ST_TO_ADDR
// sSlow := false ;
82541: LD_ADDR_EXP 144
82545: PUSH
82546: LD_INT 0
82548: ST_TO_ADDR
// sLack := false ;
82549: LD_ADDR_EXP 145
82553: PUSH
82554: LD_INT 0
82556: ST_TO_ADDR
// sTank := false ;
82557: LD_ADDR_EXP 147
82561: PUSH
82562: LD_INT 0
82564: ST_TO_ADDR
// sRemote := false ;
82565: LD_ADDR_EXP 148
82569: PUSH
82570: LD_INT 0
82572: ST_TO_ADDR
// sPowell := false ;
82573: LD_ADDR_EXP 149
82577: PUSH
82578: LD_INT 0
82580: ST_TO_ADDR
// sTeleport := false ;
82581: LD_ADDR_EXP 152
82585: PUSH
82586: LD_INT 0
82588: ST_TO_ADDR
// sOilTower := false ;
82589: LD_ADDR_EXP 154
82593: PUSH
82594: LD_INT 0
82596: ST_TO_ADDR
// sShovel := false ;
82597: LD_ADDR_EXP 155
82601: PUSH
82602: LD_INT 0
82604: ST_TO_ADDR
// sSheik := false ;
82605: LD_ADDR_EXP 156
82609: PUSH
82610: LD_INT 0
82612: ST_TO_ADDR
// sEarthquake := false ;
82613: LD_ADDR_EXP 158
82617: PUSH
82618: LD_INT 0
82620: ST_TO_ADDR
// sAI := false ;
82621: LD_ADDR_EXP 159
82625: PUSH
82626: LD_INT 0
82628: ST_TO_ADDR
// sCargo := false ;
82629: LD_ADDR_EXP 162
82633: PUSH
82634: LD_INT 0
82636: ST_TO_ADDR
// sDLaser := false ;
82637: LD_ADDR_EXP 163
82641: PUSH
82642: LD_INT 0
82644: ST_TO_ADDR
// sExchange := false ;
82645: LD_ADDR_EXP 164
82649: PUSH
82650: LD_INT 0
82652: ST_TO_ADDR
// sFac := false ;
82653: LD_ADDR_EXP 165
82657: PUSH
82658: LD_INT 0
82660: ST_TO_ADDR
// sPower := false ;
82661: LD_ADDR_EXP 166
82665: PUSH
82666: LD_INT 0
82668: ST_TO_ADDR
// sRandom := false ;
82669: LD_ADDR_EXP 167
82673: PUSH
82674: LD_INT 0
82676: ST_TO_ADDR
// sShield := false ;
82677: LD_ADDR_EXP 168
82681: PUSH
82682: LD_INT 0
82684: ST_TO_ADDR
// sTime := false ;
82685: LD_ADDR_EXP 169
82689: PUSH
82690: LD_INT 0
82692: ST_TO_ADDR
// sTools := false ;
82693: LD_ADDR_EXP 170
82697: PUSH
82698: LD_INT 0
82700: ST_TO_ADDR
// sSold := false ;
82701: LD_ADDR_EXP 135
82705: PUSH
82706: LD_INT 0
82708: ST_TO_ADDR
// sDiff := false ;
82709: LD_ADDR_EXP 136
82713: PUSH
82714: LD_INT 0
82716: ST_TO_ADDR
// sFog := false ;
82717: LD_ADDR_EXP 139
82721: PUSH
82722: LD_INT 0
82724: ST_TO_ADDR
// sReset := false ;
82725: LD_ADDR_EXP 140
82729: PUSH
82730: LD_INT 0
82732: ST_TO_ADDR
// sSun := false ;
82733: LD_ADDR_EXP 141
82737: PUSH
82738: LD_INT 0
82740: ST_TO_ADDR
// sTiger := false ;
82741: LD_ADDR_EXP 137
82745: PUSH
82746: LD_INT 0
82748: ST_TO_ADDR
// sBomb := false ;
82749: LD_ADDR_EXP 138
82753: PUSH
82754: LD_INT 0
82756: ST_TO_ADDR
// sWound := false ;
82757: LD_ADDR_EXP 146
82761: PUSH
82762: LD_INT 0
82764: ST_TO_ADDR
// sBetray := false ;
82765: LD_ADDR_EXP 150
82769: PUSH
82770: LD_INT 0
82772: ST_TO_ADDR
// sContamin := false ;
82773: LD_ADDR_EXP 151
82777: PUSH
82778: LD_INT 0
82780: ST_TO_ADDR
// sOil := false ;
82781: LD_ADDR_EXP 153
82785: PUSH
82786: LD_INT 0
82788: ST_TO_ADDR
// sStu := false ;
82789: LD_ADDR_EXP 157
82793: PUSH
82794: LD_INT 0
82796: ST_TO_ADDR
// sBazooka := false ;
82797: LD_ADDR_EXP 160
82801: PUSH
82802: LD_INT 0
82804: ST_TO_ADDR
// sMortar := false ;
82805: LD_ADDR_EXP 161
82809: PUSH
82810: LD_INT 0
82812: ST_TO_ADDR
// sRanger := false ;
82813: LD_ADDR_EXP 171
82817: PUSH
82818: LD_INT 0
82820: ST_TO_ADDR
// end ;
82821: LD_VAR 0 1
82825: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
82826: LD_INT 0
82828: PPUSH
82829: PPUSH
82830: PPUSH
82831: PPUSH
82832: PPUSH
// result := [ ] ;
82833: LD_ADDR_VAR 0 1
82837: PUSH
82838: EMPTY
82839: ST_TO_ADDR
// if campaign_id = 1 then
82840: LD_OWVAR 69
82844: PUSH
82845: LD_INT 1
82847: EQUAL
82848: IFFALSE 85786
// begin case mission_number of 1 :
82850: LD_OWVAR 70
82854: PUSH
82855: LD_INT 1
82857: DOUBLE
82858: EQUAL
82859: IFTRUE 82863
82861: GO 82927
82863: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
82864: LD_ADDR_VAR 0 1
82868: PUSH
82869: LD_INT 2
82871: PUSH
82872: LD_INT 4
82874: PUSH
82875: LD_INT 11
82877: PUSH
82878: LD_INT 12
82880: PUSH
82881: LD_INT 15
82883: PUSH
82884: LD_INT 16
82886: PUSH
82887: LD_INT 22
82889: PUSH
82890: LD_INT 23
82892: PUSH
82893: LD_INT 26
82895: PUSH
82896: EMPTY
82897: LIST
82898: LIST
82899: LIST
82900: LIST
82901: LIST
82902: LIST
82903: LIST
82904: LIST
82905: LIST
82906: PUSH
82907: LD_INT 101
82909: PUSH
82910: LD_INT 102
82912: PUSH
82913: LD_INT 106
82915: PUSH
82916: EMPTY
82917: LIST
82918: LIST
82919: LIST
82920: PUSH
82921: EMPTY
82922: LIST
82923: LIST
82924: ST_TO_ADDR
82925: GO 85784
82927: LD_INT 2
82929: DOUBLE
82930: EQUAL
82931: IFTRUE 82935
82933: GO 83007
82935: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
82936: LD_ADDR_VAR 0 1
82940: PUSH
82941: LD_INT 2
82943: PUSH
82944: LD_INT 4
82946: PUSH
82947: LD_INT 11
82949: PUSH
82950: LD_INT 12
82952: PUSH
82953: LD_INT 15
82955: PUSH
82956: LD_INT 16
82958: PUSH
82959: LD_INT 22
82961: PUSH
82962: LD_INT 23
82964: PUSH
82965: LD_INT 26
82967: PUSH
82968: EMPTY
82969: LIST
82970: LIST
82971: LIST
82972: LIST
82973: LIST
82974: LIST
82975: LIST
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 101
82981: PUSH
82982: LD_INT 102
82984: PUSH
82985: LD_INT 105
82987: PUSH
82988: LD_INT 106
82990: PUSH
82991: LD_INT 108
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: LIST
82998: LIST
82999: LIST
83000: PUSH
83001: EMPTY
83002: LIST
83003: LIST
83004: ST_TO_ADDR
83005: GO 85784
83007: LD_INT 3
83009: DOUBLE
83010: EQUAL
83011: IFTRUE 83015
83013: GO 83091
83015: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
83016: LD_ADDR_VAR 0 1
83020: PUSH
83021: LD_INT 2
83023: PUSH
83024: LD_INT 4
83026: PUSH
83027: LD_INT 5
83029: PUSH
83030: LD_INT 11
83032: PUSH
83033: LD_INT 12
83035: PUSH
83036: LD_INT 15
83038: PUSH
83039: LD_INT 16
83041: PUSH
83042: LD_INT 22
83044: PUSH
83045: LD_INT 26
83047: PUSH
83048: LD_INT 36
83050: PUSH
83051: EMPTY
83052: LIST
83053: LIST
83054: LIST
83055: LIST
83056: LIST
83057: LIST
83058: LIST
83059: LIST
83060: LIST
83061: LIST
83062: PUSH
83063: LD_INT 101
83065: PUSH
83066: LD_INT 102
83068: PUSH
83069: LD_INT 105
83071: PUSH
83072: LD_INT 106
83074: PUSH
83075: LD_INT 108
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: LIST
83082: LIST
83083: LIST
83084: PUSH
83085: EMPTY
83086: LIST
83087: LIST
83088: ST_TO_ADDR
83089: GO 85784
83091: LD_INT 4
83093: DOUBLE
83094: EQUAL
83095: IFTRUE 83099
83097: GO 83183
83099: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
83100: LD_ADDR_VAR 0 1
83104: PUSH
83105: LD_INT 2
83107: PUSH
83108: LD_INT 4
83110: PUSH
83111: LD_INT 5
83113: PUSH
83114: LD_INT 8
83116: PUSH
83117: LD_INT 11
83119: PUSH
83120: LD_INT 12
83122: PUSH
83123: LD_INT 15
83125: PUSH
83126: LD_INT 16
83128: PUSH
83129: LD_INT 22
83131: PUSH
83132: LD_INT 23
83134: PUSH
83135: LD_INT 26
83137: PUSH
83138: LD_INT 36
83140: PUSH
83141: EMPTY
83142: LIST
83143: LIST
83144: LIST
83145: LIST
83146: LIST
83147: LIST
83148: LIST
83149: LIST
83150: LIST
83151: LIST
83152: LIST
83153: LIST
83154: PUSH
83155: LD_INT 101
83157: PUSH
83158: LD_INT 102
83160: PUSH
83161: LD_INT 105
83163: PUSH
83164: LD_INT 106
83166: PUSH
83167: LD_INT 108
83169: PUSH
83170: EMPTY
83171: LIST
83172: LIST
83173: LIST
83174: LIST
83175: LIST
83176: PUSH
83177: EMPTY
83178: LIST
83179: LIST
83180: ST_TO_ADDR
83181: GO 85784
83183: LD_INT 5
83185: DOUBLE
83186: EQUAL
83187: IFTRUE 83191
83189: GO 83291
83191: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
83192: LD_ADDR_VAR 0 1
83196: PUSH
83197: LD_INT 2
83199: PUSH
83200: LD_INT 4
83202: PUSH
83203: LD_INT 5
83205: PUSH
83206: LD_INT 6
83208: PUSH
83209: LD_INT 8
83211: PUSH
83212: LD_INT 11
83214: PUSH
83215: LD_INT 12
83217: PUSH
83218: LD_INT 15
83220: PUSH
83221: LD_INT 16
83223: PUSH
83224: LD_INT 22
83226: PUSH
83227: LD_INT 23
83229: PUSH
83230: LD_INT 25
83232: PUSH
83233: LD_INT 26
83235: PUSH
83236: LD_INT 36
83238: PUSH
83239: EMPTY
83240: LIST
83241: LIST
83242: LIST
83243: LIST
83244: LIST
83245: LIST
83246: LIST
83247: LIST
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: LIST
83253: LIST
83254: PUSH
83255: LD_INT 101
83257: PUSH
83258: LD_INT 102
83260: PUSH
83261: LD_INT 105
83263: PUSH
83264: LD_INT 106
83266: PUSH
83267: LD_INT 108
83269: PUSH
83270: LD_INT 109
83272: PUSH
83273: LD_INT 112
83275: PUSH
83276: EMPTY
83277: LIST
83278: LIST
83279: LIST
83280: LIST
83281: LIST
83282: LIST
83283: LIST
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: ST_TO_ADDR
83289: GO 85784
83291: LD_INT 6
83293: DOUBLE
83294: EQUAL
83295: IFTRUE 83299
83297: GO 83419
83299: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
83300: LD_ADDR_VAR 0 1
83304: PUSH
83305: LD_INT 2
83307: PUSH
83308: LD_INT 4
83310: PUSH
83311: LD_INT 5
83313: PUSH
83314: LD_INT 6
83316: PUSH
83317: LD_INT 8
83319: PUSH
83320: LD_INT 11
83322: PUSH
83323: LD_INT 12
83325: PUSH
83326: LD_INT 15
83328: PUSH
83329: LD_INT 16
83331: PUSH
83332: LD_INT 20
83334: PUSH
83335: LD_INT 21
83337: PUSH
83338: LD_INT 22
83340: PUSH
83341: LD_INT 23
83343: PUSH
83344: LD_INT 25
83346: PUSH
83347: LD_INT 26
83349: PUSH
83350: LD_INT 30
83352: PUSH
83353: LD_INT 31
83355: PUSH
83356: LD_INT 32
83358: PUSH
83359: LD_INT 36
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: LIST
83366: LIST
83367: LIST
83368: LIST
83369: LIST
83370: LIST
83371: LIST
83372: LIST
83373: LIST
83374: LIST
83375: LIST
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: LIST
83382: PUSH
83383: LD_INT 101
83385: PUSH
83386: LD_INT 102
83388: PUSH
83389: LD_INT 105
83391: PUSH
83392: LD_INT 106
83394: PUSH
83395: LD_INT 108
83397: PUSH
83398: LD_INT 109
83400: PUSH
83401: LD_INT 112
83403: PUSH
83404: EMPTY
83405: LIST
83406: LIST
83407: LIST
83408: LIST
83409: LIST
83410: LIST
83411: LIST
83412: PUSH
83413: EMPTY
83414: LIST
83415: LIST
83416: ST_TO_ADDR
83417: GO 85784
83419: LD_INT 7
83421: DOUBLE
83422: EQUAL
83423: IFTRUE 83427
83425: GO 83527
83427: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
83428: LD_ADDR_VAR 0 1
83432: PUSH
83433: LD_INT 2
83435: PUSH
83436: LD_INT 4
83438: PUSH
83439: LD_INT 5
83441: PUSH
83442: LD_INT 7
83444: PUSH
83445: LD_INT 11
83447: PUSH
83448: LD_INT 12
83450: PUSH
83451: LD_INT 15
83453: PUSH
83454: LD_INT 16
83456: PUSH
83457: LD_INT 20
83459: PUSH
83460: LD_INT 21
83462: PUSH
83463: LD_INT 22
83465: PUSH
83466: LD_INT 23
83468: PUSH
83469: LD_INT 25
83471: PUSH
83472: LD_INT 26
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: LIST
83479: LIST
83480: LIST
83481: LIST
83482: LIST
83483: LIST
83484: LIST
83485: LIST
83486: LIST
83487: LIST
83488: LIST
83489: LIST
83490: PUSH
83491: LD_INT 101
83493: PUSH
83494: LD_INT 102
83496: PUSH
83497: LD_INT 103
83499: PUSH
83500: LD_INT 105
83502: PUSH
83503: LD_INT 106
83505: PUSH
83506: LD_INT 108
83508: PUSH
83509: LD_INT 112
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: LIST
83516: LIST
83517: LIST
83518: LIST
83519: LIST
83520: PUSH
83521: EMPTY
83522: LIST
83523: LIST
83524: ST_TO_ADDR
83525: GO 85784
83527: LD_INT 8
83529: DOUBLE
83530: EQUAL
83531: IFTRUE 83535
83533: GO 83663
83535: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
83536: LD_ADDR_VAR 0 1
83540: PUSH
83541: LD_INT 2
83543: PUSH
83544: LD_INT 4
83546: PUSH
83547: LD_INT 5
83549: PUSH
83550: LD_INT 6
83552: PUSH
83553: LD_INT 7
83555: PUSH
83556: LD_INT 8
83558: PUSH
83559: LD_INT 11
83561: PUSH
83562: LD_INT 12
83564: PUSH
83565: LD_INT 15
83567: PUSH
83568: LD_INT 16
83570: PUSH
83571: LD_INT 20
83573: PUSH
83574: LD_INT 21
83576: PUSH
83577: LD_INT 22
83579: PUSH
83580: LD_INT 23
83582: PUSH
83583: LD_INT 25
83585: PUSH
83586: LD_INT 26
83588: PUSH
83589: LD_INT 30
83591: PUSH
83592: LD_INT 31
83594: PUSH
83595: LD_INT 32
83597: PUSH
83598: LD_INT 36
83600: PUSH
83601: EMPTY
83602: LIST
83603: LIST
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: LIST
83613: LIST
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: PUSH
83623: LD_INT 101
83625: PUSH
83626: LD_INT 102
83628: PUSH
83629: LD_INT 103
83631: PUSH
83632: LD_INT 105
83634: PUSH
83635: LD_INT 106
83637: PUSH
83638: LD_INT 108
83640: PUSH
83641: LD_INT 109
83643: PUSH
83644: LD_INT 112
83646: PUSH
83647: EMPTY
83648: LIST
83649: LIST
83650: LIST
83651: LIST
83652: LIST
83653: LIST
83654: LIST
83655: LIST
83656: PUSH
83657: EMPTY
83658: LIST
83659: LIST
83660: ST_TO_ADDR
83661: GO 85784
83663: LD_INT 9
83665: DOUBLE
83666: EQUAL
83667: IFTRUE 83671
83669: GO 83807
83671: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
83672: LD_ADDR_VAR 0 1
83676: PUSH
83677: LD_INT 2
83679: PUSH
83680: LD_INT 4
83682: PUSH
83683: LD_INT 5
83685: PUSH
83686: LD_INT 6
83688: PUSH
83689: LD_INT 7
83691: PUSH
83692: LD_INT 8
83694: PUSH
83695: LD_INT 11
83697: PUSH
83698: LD_INT 12
83700: PUSH
83701: LD_INT 15
83703: PUSH
83704: LD_INT 16
83706: PUSH
83707: LD_INT 20
83709: PUSH
83710: LD_INT 21
83712: PUSH
83713: LD_INT 22
83715: PUSH
83716: LD_INT 23
83718: PUSH
83719: LD_INT 25
83721: PUSH
83722: LD_INT 26
83724: PUSH
83725: LD_INT 28
83727: PUSH
83728: LD_INT 30
83730: PUSH
83731: LD_INT 31
83733: PUSH
83734: LD_INT 32
83736: PUSH
83737: LD_INT 36
83739: PUSH
83740: EMPTY
83741: LIST
83742: LIST
83743: LIST
83744: LIST
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: LIST
83755: LIST
83756: LIST
83757: LIST
83758: LIST
83759: LIST
83760: LIST
83761: LIST
83762: PUSH
83763: LD_INT 101
83765: PUSH
83766: LD_INT 102
83768: PUSH
83769: LD_INT 103
83771: PUSH
83772: LD_INT 105
83774: PUSH
83775: LD_INT 106
83777: PUSH
83778: LD_INT 108
83780: PUSH
83781: LD_INT 109
83783: PUSH
83784: LD_INT 112
83786: PUSH
83787: LD_INT 114
83789: PUSH
83790: EMPTY
83791: LIST
83792: LIST
83793: LIST
83794: LIST
83795: LIST
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: PUSH
83801: EMPTY
83802: LIST
83803: LIST
83804: ST_TO_ADDR
83805: GO 85784
83807: LD_INT 10
83809: DOUBLE
83810: EQUAL
83811: IFTRUE 83815
83813: GO 83999
83815: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
83816: LD_ADDR_VAR 0 1
83820: PUSH
83821: LD_INT 2
83823: PUSH
83824: LD_INT 4
83826: PUSH
83827: LD_INT 5
83829: PUSH
83830: LD_INT 6
83832: PUSH
83833: LD_INT 7
83835: PUSH
83836: LD_INT 8
83838: PUSH
83839: LD_INT 9
83841: PUSH
83842: LD_INT 10
83844: PUSH
83845: LD_INT 11
83847: PUSH
83848: LD_INT 12
83850: PUSH
83851: LD_INT 13
83853: PUSH
83854: LD_INT 14
83856: PUSH
83857: LD_INT 15
83859: PUSH
83860: LD_INT 16
83862: PUSH
83863: LD_INT 17
83865: PUSH
83866: LD_INT 18
83868: PUSH
83869: LD_INT 19
83871: PUSH
83872: LD_INT 20
83874: PUSH
83875: LD_INT 21
83877: PUSH
83878: LD_INT 22
83880: PUSH
83881: LD_INT 23
83883: PUSH
83884: LD_INT 24
83886: PUSH
83887: LD_INT 25
83889: PUSH
83890: LD_INT 26
83892: PUSH
83893: LD_INT 28
83895: PUSH
83896: LD_INT 30
83898: PUSH
83899: LD_INT 31
83901: PUSH
83902: LD_INT 32
83904: PUSH
83905: LD_INT 36
83907: PUSH
83908: EMPTY
83909: LIST
83910: LIST
83911: LIST
83912: LIST
83913: LIST
83914: LIST
83915: LIST
83916: LIST
83917: LIST
83918: LIST
83919: LIST
83920: LIST
83921: LIST
83922: LIST
83923: LIST
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: LIST
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: PUSH
83939: LD_INT 101
83941: PUSH
83942: LD_INT 102
83944: PUSH
83945: LD_INT 103
83947: PUSH
83948: LD_INT 104
83950: PUSH
83951: LD_INT 105
83953: PUSH
83954: LD_INT 106
83956: PUSH
83957: LD_INT 107
83959: PUSH
83960: LD_INT 108
83962: PUSH
83963: LD_INT 109
83965: PUSH
83966: LD_INT 110
83968: PUSH
83969: LD_INT 111
83971: PUSH
83972: LD_INT 112
83974: PUSH
83975: LD_INT 114
83977: PUSH
83978: EMPTY
83979: LIST
83980: LIST
83981: LIST
83982: LIST
83983: LIST
83984: LIST
83985: LIST
83986: LIST
83987: LIST
83988: LIST
83989: LIST
83990: LIST
83991: LIST
83992: PUSH
83993: EMPTY
83994: LIST
83995: LIST
83996: ST_TO_ADDR
83997: GO 85784
83999: LD_INT 11
84001: DOUBLE
84002: EQUAL
84003: IFTRUE 84007
84005: GO 84199
84007: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
84008: LD_ADDR_VAR 0 1
84012: PUSH
84013: LD_INT 2
84015: PUSH
84016: LD_INT 3
84018: PUSH
84019: LD_INT 4
84021: PUSH
84022: LD_INT 5
84024: PUSH
84025: LD_INT 6
84027: PUSH
84028: LD_INT 7
84030: PUSH
84031: LD_INT 8
84033: PUSH
84034: LD_INT 9
84036: PUSH
84037: LD_INT 10
84039: PUSH
84040: LD_INT 11
84042: PUSH
84043: LD_INT 12
84045: PUSH
84046: LD_INT 13
84048: PUSH
84049: LD_INT 14
84051: PUSH
84052: LD_INT 15
84054: PUSH
84055: LD_INT 16
84057: PUSH
84058: LD_INT 17
84060: PUSH
84061: LD_INT 18
84063: PUSH
84064: LD_INT 19
84066: PUSH
84067: LD_INT 20
84069: PUSH
84070: LD_INT 21
84072: PUSH
84073: LD_INT 22
84075: PUSH
84076: LD_INT 23
84078: PUSH
84079: LD_INT 24
84081: PUSH
84082: LD_INT 25
84084: PUSH
84085: LD_INT 26
84087: PUSH
84088: LD_INT 28
84090: PUSH
84091: LD_INT 30
84093: PUSH
84094: LD_INT 31
84096: PUSH
84097: LD_INT 32
84099: PUSH
84100: LD_INT 34
84102: PUSH
84103: LD_INT 36
84105: PUSH
84106: EMPTY
84107: LIST
84108: LIST
84109: LIST
84110: LIST
84111: LIST
84112: LIST
84113: LIST
84114: LIST
84115: LIST
84116: LIST
84117: LIST
84118: LIST
84119: LIST
84120: LIST
84121: LIST
84122: LIST
84123: LIST
84124: LIST
84125: LIST
84126: LIST
84127: LIST
84128: LIST
84129: LIST
84130: LIST
84131: LIST
84132: LIST
84133: LIST
84134: LIST
84135: LIST
84136: LIST
84137: LIST
84138: PUSH
84139: LD_INT 101
84141: PUSH
84142: LD_INT 102
84144: PUSH
84145: LD_INT 103
84147: PUSH
84148: LD_INT 104
84150: PUSH
84151: LD_INT 105
84153: PUSH
84154: LD_INT 106
84156: PUSH
84157: LD_INT 107
84159: PUSH
84160: LD_INT 108
84162: PUSH
84163: LD_INT 109
84165: PUSH
84166: LD_INT 110
84168: PUSH
84169: LD_INT 111
84171: PUSH
84172: LD_INT 112
84174: PUSH
84175: LD_INT 114
84177: PUSH
84178: EMPTY
84179: LIST
84180: LIST
84181: LIST
84182: LIST
84183: LIST
84184: LIST
84185: LIST
84186: LIST
84187: LIST
84188: LIST
84189: LIST
84190: LIST
84191: LIST
84192: PUSH
84193: EMPTY
84194: LIST
84195: LIST
84196: ST_TO_ADDR
84197: GO 85784
84199: LD_INT 12
84201: DOUBLE
84202: EQUAL
84203: IFTRUE 84207
84205: GO 84415
84207: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
84208: LD_ADDR_VAR 0 1
84212: PUSH
84213: LD_INT 1
84215: PUSH
84216: LD_INT 2
84218: PUSH
84219: LD_INT 3
84221: PUSH
84222: LD_INT 4
84224: PUSH
84225: LD_INT 5
84227: PUSH
84228: LD_INT 6
84230: PUSH
84231: LD_INT 7
84233: PUSH
84234: LD_INT 8
84236: PUSH
84237: LD_INT 9
84239: PUSH
84240: LD_INT 10
84242: PUSH
84243: LD_INT 11
84245: PUSH
84246: LD_INT 12
84248: PUSH
84249: LD_INT 13
84251: PUSH
84252: LD_INT 14
84254: PUSH
84255: LD_INT 15
84257: PUSH
84258: LD_INT 16
84260: PUSH
84261: LD_INT 17
84263: PUSH
84264: LD_INT 18
84266: PUSH
84267: LD_INT 19
84269: PUSH
84270: LD_INT 20
84272: PUSH
84273: LD_INT 21
84275: PUSH
84276: LD_INT 22
84278: PUSH
84279: LD_INT 23
84281: PUSH
84282: LD_INT 24
84284: PUSH
84285: LD_INT 25
84287: PUSH
84288: LD_INT 26
84290: PUSH
84291: LD_INT 27
84293: PUSH
84294: LD_INT 28
84296: PUSH
84297: LD_INT 30
84299: PUSH
84300: LD_INT 31
84302: PUSH
84303: LD_INT 32
84305: PUSH
84306: LD_INT 33
84308: PUSH
84309: LD_INT 34
84311: PUSH
84312: LD_INT 36
84314: PUSH
84315: EMPTY
84316: LIST
84317: LIST
84318: LIST
84319: LIST
84320: LIST
84321: LIST
84322: LIST
84323: LIST
84324: LIST
84325: LIST
84326: LIST
84327: LIST
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: LIST
84335: LIST
84336: LIST
84337: LIST
84338: LIST
84339: LIST
84340: LIST
84341: LIST
84342: LIST
84343: LIST
84344: LIST
84345: LIST
84346: LIST
84347: LIST
84348: LIST
84349: LIST
84350: PUSH
84351: LD_INT 101
84353: PUSH
84354: LD_INT 102
84356: PUSH
84357: LD_INT 103
84359: PUSH
84360: LD_INT 104
84362: PUSH
84363: LD_INT 105
84365: PUSH
84366: LD_INT 106
84368: PUSH
84369: LD_INT 107
84371: PUSH
84372: LD_INT 108
84374: PUSH
84375: LD_INT 109
84377: PUSH
84378: LD_INT 110
84380: PUSH
84381: LD_INT 111
84383: PUSH
84384: LD_INT 112
84386: PUSH
84387: LD_INT 113
84389: PUSH
84390: LD_INT 114
84392: PUSH
84393: EMPTY
84394: LIST
84395: LIST
84396: LIST
84397: LIST
84398: LIST
84399: LIST
84400: LIST
84401: LIST
84402: LIST
84403: LIST
84404: LIST
84405: LIST
84406: LIST
84407: LIST
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: ST_TO_ADDR
84413: GO 85784
84415: LD_INT 13
84417: DOUBLE
84418: EQUAL
84419: IFTRUE 84423
84421: GO 84619
84423: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
84424: LD_ADDR_VAR 0 1
84428: PUSH
84429: LD_INT 1
84431: PUSH
84432: LD_INT 2
84434: PUSH
84435: LD_INT 3
84437: PUSH
84438: LD_INT 4
84440: PUSH
84441: LD_INT 5
84443: PUSH
84444: LD_INT 8
84446: PUSH
84447: LD_INT 9
84449: PUSH
84450: LD_INT 10
84452: PUSH
84453: LD_INT 11
84455: PUSH
84456: LD_INT 12
84458: PUSH
84459: LD_INT 14
84461: PUSH
84462: LD_INT 15
84464: PUSH
84465: LD_INT 16
84467: PUSH
84468: LD_INT 17
84470: PUSH
84471: LD_INT 18
84473: PUSH
84474: LD_INT 19
84476: PUSH
84477: LD_INT 20
84479: PUSH
84480: LD_INT 21
84482: PUSH
84483: LD_INT 22
84485: PUSH
84486: LD_INT 23
84488: PUSH
84489: LD_INT 24
84491: PUSH
84492: LD_INT 25
84494: PUSH
84495: LD_INT 26
84497: PUSH
84498: LD_INT 27
84500: PUSH
84501: LD_INT 28
84503: PUSH
84504: LD_INT 30
84506: PUSH
84507: LD_INT 31
84509: PUSH
84510: LD_INT 32
84512: PUSH
84513: LD_INT 33
84515: PUSH
84516: LD_INT 34
84518: PUSH
84519: LD_INT 36
84521: PUSH
84522: EMPTY
84523: LIST
84524: LIST
84525: LIST
84526: LIST
84527: LIST
84528: LIST
84529: LIST
84530: LIST
84531: LIST
84532: LIST
84533: LIST
84534: LIST
84535: LIST
84536: LIST
84537: LIST
84538: LIST
84539: LIST
84540: LIST
84541: LIST
84542: LIST
84543: LIST
84544: LIST
84545: LIST
84546: LIST
84547: LIST
84548: LIST
84549: LIST
84550: LIST
84551: LIST
84552: LIST
84553: LIST
84554: PUSH
84555: LD_INT 101
84557: PUSH
84558: LD_INT 102
84560: PUSH
84561: LD_INT 103
84563: PUSH
84564: LD_INT 104
84566: PUSH
84567: LD_INT 105
84569: PUSH
84570: LD_INT 106
84572: PUSH
84573: LD_INT 107
84575: PUSH
84576: LD_INT 108
84578: PUSH
84579: LD_INT 109
84581: PUSH
84582: LD_INT 110
84584: PUSH
84585: LD_INT 111
84587: PUSH
84588: LD_INT 112
84590: PUSH
84591: LD_INT 113
84593: PUSH
84594: LD_INT 114
84596: PUSH
84597: EMPTY
84598: LIST
84599: LIST
84600: LIST
84601: LIST
84602: LIST
84603: LIST
84604: LIST
84605: LIST
84606: LIST
84607: LIST
84608: LIST
84609: LIST
84610: LIST
84611: LIST
84612: PUSH
84613: EMPTY
84614: LIST
84615: LIST
84616: ST_TO_ADDR
84617: GO 85784
84619: LD_INT 14
84621: DOUBLE
84622: EQUAL
84623: IFTRUE 84627
84625: GO 84839
84627: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
84628: LD_ADDR_VAR 0 1
84632: PUSH
84633: LD_INT 1
84635: PUSH
84636: LD_INT 2
84638: PUSH
84639: LD_INT 3
84641: PUSH
84642: LD_INT 4
84644: PUSH
84645: LD_INT 5
84647: PUSH
84648: LD_INT 6
84650: PUSH
84651: LD_INT 7
84653: PUSH
84654: LD_INT 8
84656: PUSH
84657: LD_INT 9
84659: PUSH
84660: LD_INT 10
84662: PUSH
84663: LD_INT 11
84665: PUSH
84666: LD_INT 12
84668: PUSH
84669: LD_INT 13
84671: PUSH
84672: LD_INT 14
84674: PUSH
84675: LD_INT 15
84677: PUSH
84678: LD_INT 16
84680: PUSH
84681: LD_INT 17
84683: PUSH
84684: LD_INT 18
84686: PUSH
84687: LD_INT 19
84689: PUSH
84690: LD_INT 20
84692: PUSH
84693: LD_INT 21
84695: PUSH
84696: LD_INT 22
84698: PUSH
84699: LD_INT 23
84701: PUSH
84702: LD_INT 24
84704: PUSH
84705: LD_INT 25
84707: PUSH
84708: LD_INT 26
84710: PUSH
84711: LD_INT 27
84713: PUSH
84714: LD_INT 28
84716: PUSH
84717: LD_INT 29
84719: PUSH
84720: LD_INT 30
84722: PUSH
84723: LD_INT 31
84725: PUSH
84726: LD_INT 32
84728: PUSH
84729: LD_INT 33
84731: PUSH
84732: LD_INT 34
84734: PUSH
84735: LD_INT 36
84737: PUSH
84738: EMPTY
84739: LIST
84740: LIST
84741: LIST
84742: LIST
84743: LIST
84744: LIST
84745: LIST
84746: LIST
84747: LIST
84748: LIST
84749: LIST
84750: LIST
84751: LIST
84752: LIST
84753: LIST
84754: LIST
84755: LIST
84756: LIST
84757: LIST
84758: LIST
84759: LIST
84760: LIST
84761: LIST
84762: LIST
84763: LIST
84764: LIST
84765: LIST
84766: LIST
84767: LIST
84768: LIST
84769: LIST
84770: LIST
84771: LIST
84772: LIST
84773: LIST
84774: PUSH
84775: LD_INT 101
84777: PUSH
84778: LD_INT 102
84780: PUSH
84781: LD_INT 103
84783: PUSH
84784: LD_INT 104
84786: PUSH
84787: LD_INT 105
84789: PUSH
84790: LD_INT 106
84792: PUSH
84793: LD_INT 107
84795: PUSH
84796: LD_INT 108
84798: PUSH
84799: LD_INT 109
84801: PUSH
84802: LD_INT 110
84804: PUSH
84805: LD_INT 111
84807: PUSH
84808: LD_INT 112
84810: PUSH
84811: LD_INT 113
84813: PUSH
84814: LD_INT 114
84816: PUSH
84817: EMPTY
84818: LIST
84819: LIST
84820: LIST
84821: LIST
84822: LIST
84823: LIST
84824: LIST
84825: LIST
84826: LIST
84827: LIST
84828: LIST
84829: LIST
84830: LIST
84831: LIST
84832: PUSH
84833: EMPTY
84834: LIST
84835: LIST
84836: ST_TO_ADDR
84837: GO 85784
84839: LD_INT 15
84841: DOUBLE
84842: EQUAL
84843: IFTRUE 84847
84845: GO 85059
84847: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
84848: LD_ADDR_VAR 0 1
84852: PUSH
84853: LD_INT 1
84855: PUSH
84856: LD_INT 2
84858: PUSH
84859: LD_INT 3
84861: PUSH
84862: LD_INT 4
84864: PUSH
84865: LD_INT 5
84867: PUSH
84868: LD_INT 6
84870: PUSH
84871: LD_INT 7
84873: PUSH
84874: LD_INT 8
84876: PUSH
84877: LD_INT 9
84879: PUSH
84880: LD_INT 10
84882: PUSH
84883: LD_INT 11
84885: PUSH
84886: LD_INT 12
84888: PUSH
84889: LD_INT 13
84891: PUSH
84892: LD_INT 14
84894: PUSH
84895: LD_INT 15
84897: PUSH
84898: LD_INT 16
84900: PUSH
84901: LD_INT 17
84903: PUSH
84904: LD_INT 18
84906: PUSH
84907: LD_INT 19
84909: PUSH
84910: LD_INT 20
84912: PUSH
84913: LD_INT 21
84915: PUSH
84916: LD_INT 22
84918: PUSH
84919: LD_INT 23
84921: PUSH
84922: LD_INT 24
84924: PUSH
84925: LD_INT 25
84927: PUSH
84928: LD_INT 26
84930: PUSH
84931: LD_INT 27
84933: PUSH
84934: LD_INT 28
84936: PUSH
84937: LD_INT 29
84939: PUSH
84940: LD_INT 30
84942: PUSH
84943: LD_INT 31
84945: PUSH
84946: LD_INT 32
84948: PUSH
84949: LD_INT 33
84951: PUSH
84952: LD_INT 34
84954: PUSH
84955: LD_INT 36
84957: PUSH
84958: EMPTY
84959: LIST
84960: LIST
84961: LIST
84962: LIST
84963: LIST
84964: LIST
84965: LIST
84966: LIST
84967: LIST
84968: LIST
84969: LIST
84970: LIST
84971: LIST
84972: LIST
84973: LIST
84974: LIST
84975: LIST
84976: LIST
84977: LIST
84978: LIST
84979: LIST
84980: LIST
84981: LIST
84982: LIST
84983: LIST
84984: LIST
84985: LIST
84986: LIST
84987: LIST
84988: LIST
84989: LIST
84990: LIST
84991: LIST
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 101
84997: PUSH
84998: LD_INT 102
85000: PUSH
85001: LD_INT 103
85003: PUSH
85004: LD_INT 104
85006: PUSH
85007: LD_INT 105
85009: PUSH
85010: LD_INT 106
85012: PUSH
85013: LD_INT 107
85015: PUSH
85016: LD_INT 108
85018: PUSH
85019: LD_INT 109
85021: PUSH
85022: LD_INT 110
85024: PUSH
85025: LD_INT 111
85027: PUSH
85028: LD_INT 112
85030: PUSH
85031: LD_INT 113
85033: PUSH
85034: LD_INT 114
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: LIST
85041: LIST
85042: LIST
85043: LIST
85044: LIST
85045: LIST
85046: LIST
85047: LIST
85048: LIST
85049: LIST
85050: LIST
85051: LIST
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: ST_TO_ADDR
85057: GO 85784
85059: LD_INT 16
85061: DOUBLE
85062: EQUAL
85063: IFTRUE 85067
85065: GO 85191
85067: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
85068: LD_ADDR_VAR 0 1
85072: PUSH
85073: LD_INT 2
85075: PUSH
85076: LD_INT 4
85078: PUSH
85079: LD_INT 5
85081: PUSH
85082: LD_INT 7
85084: PUSH
85085: LD_INT 11
85087: PUSH
85088: LD_INT 12
85090: PUSH
85091: LD_INT 15
85093: PUSH
85094: LD_INT 16
85096: PUSH
85097: LD_INT 20
85099: PUSH
85100: LD_INT 21
85102: PUSH
85103: LD_INT 22
85105: PUSH
85106: LD_INT 23
85108: PUSH
85109: LD_INT 25
85111: PUSH
85112: LD_INT 26
85114: PUSH
85115: LD_INT 30
85117: PUSH
85118: LD_INT 31
85120: PUSH
85121: LD_INT 32
85123: PUSH
85124: LD_INT 33
85126: PUSH
85127: LD_INT 34
85129: PUSH
85130: EMPTY
85131: LIST
85132: LIST
85133: LIST
85134: LIST
85135: LIST
85136: LIST
85137: LIST
85138: LIST
85139: LIST
85140: LIST
85141: LIST
85142: LIST
85143: LIST
85144: LIST
85145: LIST
85146: LIST
85147: LIST
85148: LIST
85149: LIST
85150: PUSH
85151: LD_INT 101
85153: PUSH
85154: LD_INT 102
85156: PUSH
85157: LD_INT 103
85159: PUSH
85160: LD_INT 106
85162: PUSH
85163: LD_INT 108
85165: PUSH
85166: LD_INT 112
85168: PUSH
85169: LD_INT 113
85171: PUSH
85172: LD_INT 114
85174: PUSH
85175: EMPTY
85176: LIST
85177: LIST
85178: LIST
85179: LIST
85180: LIST
85181: LIST
85182: LIST
85183: LIST
85184: PUSH
85185: EMPTY
85186: LIST
85187: LIST
85188: ST_TO_ADDR
85189: GO 85784
85191: LD_INT 17
85193: DOUBLE
85194: EQUAL
85195: IFTRUE 85199
85197: GO 85411
85199: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
85200: LD_ADDR_VAR 0 1
85204: PUSH
85205: LD_INT 1
85207: PUSH
85208: LD_INT 2
85210: PUSH
85211: LD_INT 3
85213: PUSH
85214: LD_INT 4
85216: PUSH
85217: LD_INT 5
85219: PUSH
85220: LD_INT 6
85222: PUSH
85223: LD_INT 7
85225: PUSH
85226: LD_INT 8
85228: PUSH
85229: LD_INT 9
85231: PUSH
85232: LD_INT 10
85234: PUSH
85235: LD_INT 11
85237: PUSH
85238: LD_INT 12
85240: PUSH
85241: LD_INT 13
85243: PUSH
85244: LD_INT 14
85246: PUSH
85247: LD_INT 15
85249: PUSH
85250: LD_INT 16
85252: PUSH
85253: LD_INT 17
85255: PUSH
85256: LD_INT 18
85258: PUSH
85259: LD_INT 19
85261: PUSH
85262: LD_INT 20
85264: PUSH
85265: LD_INT 21
85267: PUSH
85268: LD_INT 22
85270: PUSH
85271: LD_INT 23
85273: PUSH
85274: LD_INT 24
85276: PUSH
85277: LD_INT 25
85279: PUSH
85280: LD_INT 26
85282: PUSH
85283: LD_INT 27
85285: PUSH
85286: LD_INT 28
85288: PUSH
85289: LD_INT 29
85291: PUSH
85292: LD_INT 30
85294: PUSH
85295: LD_INT 31
85297: PUSH
85298: LD_INT 32
85300: PUSH
85301: LD_INT 33
85303: PUSH
85304: LD_INT 34
85306: PUSH
85307: LD_INT 36
85309: PUSH
85310: EMPTY
85311: LIST
85312: LIST
85313: LIST
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: LIST
85328: LIST
85329: LIST
85330: LIST
85331: LIST
85332: LIST
85333: LIST
85334: LIST
85335: LIST
85336: LIST
85337: LIST
85338: LIST
85339: LIST
85340: LIST
85341: LIST
85342: LIST
85343: LIST
85344: LIST
85345: LIST
85346: PUSH
85347: LD_INT 101
85349: PUSH
85350: LD_INT 102
85352: PUSH
85353: LD_INT 103
85355: PUSH
85356: LD_INT 104
85358: PUSH
85359: LD_INT 105
85361: PUSH
85362: LD_INT 106
85364: PUSH
85365: LD_INT 107
85367: PUSH
85368: LD_INT 108
85370: PUSH
85371: LD_INT 109
85373: PUSH
85374: LD_INT 110
85376: PUSH
85377: LD_INT 111
85379: PUSH
85380: LD_INT 112
85382: PUSH
85383: LD_INT 113
85385: PUSH
85386: LD_INT 114
85388: PUSH
85389: EMPTY
85390: LIST
85391: LIST
85392: LIST
85393: LIST
85394: LIST
85395: LIST
85396: LIST
85397: LIST
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: LIST
85404: PUSH
85405: EMPTY
85406: LIST
85407: LIST
85408: ST_TO_ADDR
85409: GO 85784
85411: LD_INT 18
85413: DOUBLE
85414: EQUAL
85415: IFTRUE 85419
85417: GO 85555
85419: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
85420: LD_ADDR_VAR 0 1
85424: PUSH
85425: LD_INT 2
85427: PUSH
85428: LD_INT 4
85430: PUSH
85431: LD_INT 5
85433: PUSH
85434: LD_INT 7
85436: PUSH
85437: LD_INT 11
85439: PUSH
85440: LD_INT 12
85442: PUSH
85443: LD_INT 15
85445: PUSH
85446: LD_INT 16
85448: PUSH
85449: LD_INT 20
85451: PUSH
85452: LD_INT 21
85454: PUSH
85455: LD_INT 22
85457: PUSH
85458: LD_INT 23
85460: PUSH
85461: LD_INT 25
85463: PUSH
85464: LD_INT 26
85466: PUSH
85467: LD_INT 30
85469: PUSH
85470: LD_INT 31
85472: PUSH
85473: LD_INT 32
85475: PUSH
85476: LD_INT 33
85478: PUSH
85479: LD_INT 34
85481: PUSH
85482: LD_INT 35
85484: PUSH
85485: LD_INT 36
85487: PUSH
85488: EMPTY
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: LIST
85495: LIST
85496: LIST
85497: LIST
85498: LIST
85499: LIST
85500: LIST
85501: LIST
85502: LIST
85503: LIST
85504: LIST
85505: LIST
85506: LIST
85507: LIST
85508: LIST
85509: LIST
85510: PUSH
85511: LD_INT 101
85513: PUSH
85514: LD_INT 102
85516: PUSH
85517: LD_INT 103
85519: PUSH
85520: LD_INT 106
85522: PUSH
85523: LD_INT 108
85525: PUSH
85526: LD_INT 112
85528: PUSH
85529: LD_INT 113
85531: PUSH
85532: LD_INT 114
85534: PUSH
85535: LD_INT 115
85537: PUSH
85538: EMPTY
85539: LIST
85540: LIST
85541: LIST
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: LIST
85548: PUSH
85549: EMPTY
85550: LIST
85551: LIST
85552: ST_TO_ADDR
85553: GO 85784
85555: LD_INT 19
85557: DOUBLE
85558: EQUAL
85559: IFTRUE 85563
85561: GO 85783
85563: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
85564: LD_ADDR_VAR 0 1
85568: PUSH
85569: LD_INT 1
85571: PUSH
85572: LD_INT 2
85574: PUSH
85575: LD_INT 3
85577: PUSH
85578: LD_INT 4
85580: PUSH
85581: LD_INT 5
85583: PUSH
85584: LD_INT 6
85586: PUSH
85587: LD_INT 7
85589: PUSH
85590: LD_INT 8
85592: PUSH
85593: LD_INT 9
85595: PUSH
85596: LD_INT 10
85598: PUSH
85599: LD_INT 11
85601: PUSH
85602: LD_INT 12
85604: PUSH
85605: LD_INT 13
85607: PUSH
85608: LD_INT 14
85610: PUSH
85611: LD_INT 15
85613: PUSH
85614: LD_INT 16
85616: PUSH
85617: LD_INT 17
85619: PUSH
85620: LD_INT 18
85622: PUSH
85623: LD_INT 19
85625: PUSH
85626: LD_INT 20
85628: PUSH
85629: LD_INT 21
85631: PUSH
85632: LD_INT 22
85634: PUSH
85635: LD_INT 23
85637: PUSH
85638: LD_INT 24
85640: PUSH
85641: LD_INT 25
85643: PUSH
85644: LD_INT 26
85646: PUSH
85647: LD_INT 27
85649: PUSH
85650: LD_INT 28
85652: PUSH
85653: LD_INT 29
85655: PUSH
85656: LD_INT 30
85658: PUSH
85659: LD_INT 31
85661: PUSH
85662: LD_INT 32
85664: PUSH
85665: LD_INT 33
85667: PUSH
85668: LD_INT 34
85670: PUSH
85671: LD_INT 35
85673: PUSH
85674: LD_INT 36
85676: PUSH
85677: EMPTY
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: LIST
85683: LIST
85684: LIST
85685: LIST
85686: LIST
85687: LIST
85688: LIST
85689: LIST
85690: LIST
85691: LIST
85692: LIST
85693: LIST
85694: LIST
85695: LIST
85696: LIST
85697: LIST
85698: LIST
85699: LIST
85700: LIST
85701: LIST
85702: LIST
85703: LIST
85704: LIST
85705: LIST
85706: LIST
85707: LIST
85708: LIST
85709: LIST
85710: LIST
85711: LIST
85712: LIST
85713: LIST
85714: PUSH
85715: LD_INT 101
85717: PUSH
85718: LD_INT 102
85720: PUSH
85721: LD_INT 103
85723: PUSH
85724: LD_INT 104
85726: PUSH
85727: LD_INT 105
85729: PUSH
85730: LD_INT 106
85732: PUSH
85733: LD_INT 107
85735: PUSH
85736: LD_INT 108
85738: PUSH
85739: LD_INT 109
85741: PUSH
85742: LD_INT 110
85744: PUSH
85745: LD_INT 111
85747: PUSH
85748: LD_INT 112
85750: PUSH
85751: LD_INT 113
85753: PUSH
85754: LD_INT 114
85756: PUSH
85757: LD_INT 115
85759: PUSH
85760: EMPTY
85761: LIST
85762: LIST
85763: LIST
85764: LIST
85765: LIST
85766: LIST
85767: LIST
85768: LIST
85769: LIST
85770: LIST
85771: LIST
85772: LIST
85773: LIST
85774: LIST
85775: LIST
85776: PUSH
85777: EMPTY
85778: LIST
85779: LIST
85780: ST_TO_ADDR
85781: GO 85784
85783: POP
// end else
85784: GO 86003
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
85786: LD_ADDR_VAR 0 1
85790: PUSH
85791: LD_INT 1
85793: PUSH
85794: LD_INT 2
85796: PUSH
85797: LD_INT 3
85799: PUSH
85800: LD_INT 4
85802: PUSH
85803: LD_INT 5
85805: PUSH
85806: LD_INT 6
85808: PUSH
85809: LD_INT 7
85811: PUSH
85812: LD_INT 8
85814: PUSH
85815: LD_INT 9
85817: PUSH
85818: LD_INT 10
85820: PUSH
85821: LD_INT 11
85823: PUSH
85824: LD_INT 12
85826: PUSH
85827: LD_INT 13
85829: PUSH
85830: LD_INT 14
85832: PUSH
85833: LD_INT 15
85835: PUSH
85836: LD_INT 16
85838: PUSH
85839: LD_INT 17
85841: PUSH
85842: LD_INT 18
85844: PUSH
85845: LD_INT 19
85847: PUSH
85848: LD_INT 20
85850: PUSH
85851: LD_INT 21
85853: PUSH
85854: LD_INT 22
85856: PUSH
85857: LD_INT 23
85859: PUSH
85860: LD_INT 24
85862: PUSH
85863: LD_INT 25
85865: PUSH
85866: LD_INT 26
85868: PUSH
85869: LD_INT 27
85871: PUSH
85872: LD_INT 28
85874: PUSH
85875: LD_INT 29
85877: PUSH
85878: LD_INT 30
85880: PUSH
85881: LD_INT 31
85883: PUSH
85884: LD_INT 32
85886: PUSH
85887: LD_INT 33
85889: PUSH
85890: LD_INT 34
85892: PUSH
85893: LD_INT 35
85895: PUSH
85896: LD_INT 36
85898: PUSH
85899: EMPTY
85900: LIST
85901: LIST
85902: LIST
85903: LIST
85904: LIST
85905: LIST
85906: LIST
85907: LIST
85908: LIST
85909: LIST
85910: LIST
85911: LIST
85912: LIST
85913: LIST
85914: LIST
85915: LIST
85916: LIST
85917: LIST
85918: LIST
85919: LIST
85920: LIST
85921: LIST
85922: LIST
85923: LIST
85924: LIST
85925: LIST
85926: LIST
85927: LIST
85928: LIST
85929: LIST
85930: LIST
85931: LIST
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: PUSH
85937: LD_INT 101
85939: PUSH
85940: LD_INT 102
85942: PUSH
85943: LD_INT 103
85945: PUSH
85946: LD_INT 104
85948: PUSH
85949: LD_INT 105
85951: PUSH
85952: LD_INT 106
85954: PUSH
85955: LD_INT 107
85957: PUSH
85958: LD_INT 108
85960: PUSH
85961: LD_INT 109
85963: PUSH
85964: LD_INT 110
85966: PUSH
85967: LD_INT 111
85969: PUSH
85970: LD_INT 112
85972: PUSH
85973: LD_INT 113
85975: PUSH
85976: LD_INT 114
85978: PUSH
85979: LD_INT 115
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: LIST
85986: LIST
85987: LIST
85988: LIST
85989: LIST
85990: LIST
85991: LIST
85992: LIST
85993: LIST
85994: LIST
85995: LIST
85996: LIST
85997: LIST
85998: PUSH
85999: EMPTY
86000: LIST
86001: LIST
86002: ST_TO_ADDR
// if result then
86003: LD_VAR 0 1
86007: IFFALSE 86296
// begin normal :=  ;
86009: LD_ADDR_VAR 0 3
86013: PUSH
86014: LD_STRING 
86016: ST_TO_ADDR
// hardcore :=  ;
86017: LD_ADDR_VAR 0 4
86021: PUSH
86022: LD_STRING 
86024: ST_TO_ADDR
// for i = 1 to normalCounter do
86025: LD_ADDR_VAR 0 5
86029: PUSH
86030: DOUBLE
86031: LD_INT 1
86033: DEC
86034: ST_TO_ADDR
86035: LD_EXP 119
86039: PUSH
86040: FOR_TO
86041: IFFALSE 86142
// begin tmp := 0 ;
86043: LD_ADDR_VAR 0 2
86047: PUSH
86048: LD_STRING 0
86050: ST_TO_ADDR
// if result [ 1 ] then
86051: LD_VAR 0 1
86055: PUSH
86056: LD_INT 1
86058: ARRAY
86059: IFFALSE 86124
// if result [ 1 ] [ 1 ] = i then
86061: LD_VAR 0 1
86065: PUSH
86066: LD_INT 1
86068: ARRAY
86069: PUSH
86070: LD_INT 1
86072: ARRAY
86073: PUSH
86074: LD_VAR 0 5
86078: EQUAL
86079: IFFALSE 86124
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
86081: LD_ADDR_VAR 0 1
86085: PUSH
86086: LD_VAR 0 1
86090: PPUSH
86091: LD_INT 1
86093: PPUSH
86094: LD_VAR 0 1
86098: PUSH
86099: LD_INT 1
86101: ARRAY
86102: PPUSH
86103: LD_INT 1
86105: PPUSH
86106: CALL_OW 3
86110: PPUSH
86111: CALL_OW 1
86115: ST_TO_ADDR
// tmp := 1 ;
86116: LD_ADDR_VAR 0 2
86120: PUSH
86121: LD_STRING 1
86123: ST_TO_ADDR
// end ; normal := normal & tmp ;
86124: LD_ADDR_VAR 0 3
86128: PUSH
86129: LD_VAR 0 3
86133: PUSH
86134: LD_VAR 0 2
86138: STR
86139: ST_TO_ADDR
// end ;
86140: GO 86040
86142: POP
86143: POP
// for i = 1 to hardcoreCounter do
86144: LD_ADDR_VAR 0 5
86148: PUSH
86149: DOUBLE
86150: LD_INT 1
86152: DEC
86153: ST_TO_ADDR
86154: LD_EXP 120
86158: PUSH
86159: FOR_TO
86160: IFFALSE 86265
// begin tmp := 0 ;
86162: LD_ADDR_VAR 0 2
86166: PUSH
86167: LD_STRING 0
86169: ST_TO_ADDR
// if result [ 2 ] then
86170: LD_VAR 0 1
86174: PUSH
86175: LD_INT 2
86177: ARRAY
86178: IFFALSE 86247
// if result [ 2 ] [ 1 ] = 100 + i then
86180: LD_VAR 0 1
86184: PUSH
86185: LD_INT 2
86187: ARRAY
86188: PUSH
86189: LD_INT 1
86191: ARRAY
86192: PUSH
86193: LD_INT 100
86195: PUSH
86196: LD_VAR 0 5
86200: PLUS
86201: EQUAL
86202: IFFALSE 86247
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
86204: LD_ADDR_VAR 0 1
86208: PUSH
86209: LD_VAR 0 1
86213: PPUSH
86214: LD_INT 2
86216: PPUSH
86217: LD_VAR 0 1
86221: PUSH
86222: LD_INT 2
86224: ARRAY
86225: PPUSH
86226: LD_INT 1
86228: PPUSH
86229: CALL_OW 3
86233: PPUSH
86234: CALL_OW 1
86238: ST_TO_ADDR
// tmp := 1 ;
86239: LD_ADDR_VAR 0 2
86243: PUSH
86244: LD_STRING 1
86246: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
86247: LD_ADDR_VAR 0 4
86251: PUSH
86252: LD_VAR 0 4
86256: PUSH
86257: LD_VAR 0 2
86261: STR
86262: ST_TO_ADDR
// end ;
86263: GO 86159
86265: POP
86266: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
86267: LD_STRING getStreamItemsFromMission("
86269: PUSH
86270: LD_VAR 0 3
86274: STR
86275: PUSH
86276: LD_STRING ","
86278: STR
86279: PUSH
86280: LD_VAR 0 4
86284: STR
86285: PUSH
86286: LD_STRING ")
86288: STR
86289: PPUSH
86290: CALL_OW 559
// end else
86294: GO 86303
// ToLua ( getStreamItemsFromMission("","") ) ;
86296: LD_STRING getStreamItemsFromMission("","")
86298: PPUSH
86299: CALL_OW 559
// end ;
86303: LD_VAR 0 1
86307: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
86308: LD_EXP 118
86312: PUSH
86313: LD_EXP 123
86317: AND
86318: IFFALSE 86442
86320: GO 86322
86322: DISABLE
86323: LD_INT 0
86325: PPUSH
86326: PPUSH
// begin enable ;
86327: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
86328: LD_ADDR_VAR 0 2
86332: PUSH
86333: LD_INT 22
86335: PUSH
86336: LD_OWVAR 2
86340: PUSH
86341: EMPTY
86342: LIST
86343: LIST
86344: PUSH
86345: LD_INT 2
86347: PUSH
86348: LD_INT 34
86350: PUSH
86351: LD_INT 7
86353: PUSH
86354: EMPTY
86355: LIST
86356: LIST
86357: PUSH
86358: LD_INT 34
86360: PUSH
86361: LD_INT 45
86363: PUSH
86364: EMPTY
86365: LIST
86366: LIST
86367: PUSH
86368: LD_INT 34
86370: PUSH
86371: LD_INT 28
86373: PUSH
86374: EMPTY
86375: LIST
86376: LIST
86377: PUSH
86378: LD_INT 34
86380: PUSH
86381: LD_INT 47
86383: PUSH
86384: EMPTY
86385: LIST
86386: LIST
86387: PUSH
86388: EMPTY
86389: LIST
86390: LIST
86391: LIST
86392: LIST
86393: LIST
86394: PUSH
86395: EMPTY
86396: LIST
86397: LIST
86398: PPUSH
86399: CALL_OW 69
86403: ST_TO_ADDR
// if not tmp then
86404: LD_VAR 0 2
86408: NOT
86409: IFFALSE 86413
// exit ;
86411: GO 86442
// for i in tmp do
86413: LD_ADDR_VAR 0 1
86417: PUSH
86418: LD_VAR 0 2
86422: PUSH
86423: FOR_IN
86424: IFFALSE 86440
// begin SetLives ( i , 0 ) ;
86426: LD_VAR 0 1
86430: PPUSH
86431: LD_INT 0
86433: PPUSH
86434: CALL_OW 234
// end ;
86438: GO 86423
86440: POP
86441: POP
// end ;
86442: PPOPN 2
86444: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
86445: LD_EXP 118
86449: PUSH
86450: LD_EXP 124
86454: AND
86455: IFFALSE 86539
86457: GO 86459
86459: DISABLE
86460: LD_INT 0
86462: PPUSH
86463: PPUSH
// begin enable ;
86464: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
86465: LD_ADDR_VAR 0 2
86469: PUSH
86470: LD_INT 22
86472: PUSH
86473: LD_OWVAR 2
86477: PUSH
86478: EMPTY
86479: LIST
86480: LIST
86481: PUSH
86482: LD_INT 32
86484: PUSH
86485: LD_INT 3
86487: PUSH
86488: EMPTY
86489: LIST
86490: LIST
86491: PUSH
86492: EMPTY
86493: LIST
86494: LIST
86495: PPUSH
86496: CALL_OW 69
86500: ST_TO_ADDR
// if not tmp then
86501: LD_VAR 0 2
86505: NOT
86506: IFFALSE 86510
// exit ;
86508: GO 86539
// for i in tmp do
86510: LD_ADDR_VAR 0 1
86514: PUSH
86515: LD_VAR 0 2
86519: PUSH
86520: FOR_IN
86521: IFFALSE 86537
// begin SetLives ( i , 0 ) ;
86523: LD_VAR 0 1
86527: PPUSH
86528: LD_INT 0
86530: PPUSH
86531: CALL_OW 234
// end ;
86535: GO 86520
86537: POP
86538: POP
// end ;
86539: PPOPN 2
86541: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
86542: LD_EXP 118
86546: PUSH
86547: LD_EXP 121
86551: AND
86552: IFFALSE 86645
86554: GO 86556
86556: DISABLE
86557: LD_INT 0
86559: PPUSH
// begin enable ;
86560: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
86561: LD_ADDR_VAR 0 1
86565: PUSH
86566: LD_INT 22
86568: PUSH
86569: LD_OWVAR 2
86573: PUSH
86574: EMPTY
86575: LIST
86576: LIST
86577: PUSH
86578: LD_INT 2
86580: PUSH
86581: LD_INT 25
86583: PUSH
86584: LD_INT 5
86586: PUSH
86587: EMPTY
86588: LIST
86589: LIST
86590: PUSH
86591: LD_INT 25
86593: PUSH
86594: LD_INT 9
86596: PUSH
86597: EMPTY
86598: LIST
86599: LIST
86600: PUSH
86601: LD_INT 25
86603: PUSH
86604: LD_INT 8
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: PUSH
86611: EMPTY
86612: LIST
86613: LIST
86614: LIST
86615: LIST
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PPUSH
86621: CALL_OW 69
86625: PUSH
86626: FOR_IN
86627: IFFALSE 86643
// begin SetClass ( i , 1 ) ;
86629: LD_VAR 0 1
86633: PPUSH
86634: LD_INT 1
86636: PPUSH
86637: CALL_OW 336
// end ;
86641: GO 86626
86643: POP
86644: POP
// end ;
86645: PPOPN 1
86647: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
86648: LD_EXP 118
86652: PUSH
86653: LD_EXP 122
86657: AND
86658: PUSH
86659: LD_OWVAR 65
86663: PUSH
86664: LD_INT 7
86666: LESS
86667: AND
86668: IFFALSE 86682
86670: GO 86672
86672: DISABLE
// begin enable ;
86673: ENABLE
// game_speed := 7 ;
86674: LD_ADDR_OWVAR 65
86678: PUSH
86679: LD_INT 7
86681: ST_TO_ADDR
// end ;
86682: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
86683: LD_EXP 118
86687: PUSH
86688: LD_EXP 125
86692: AND
86693: IFFALSE 86895
86695: GO 86697
86697: DISABLE
86698: LD_INT 0
86700: PPUSH
86701: PPUSH
86702: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
86703: LD_ADDR_VAR 0 3
86707: PUSH
86708: LD_INT 81
86710: PUSH
86711: LD_OWVAR 2
86715: PUSH
86716: EMPTY
86717: LIST
86718: LIST
86719: PUSH
86720: LD_INT 21
86722: PUSH
86723: LD_INT 1
86725: PUSH
86726: EMPTY
86727: LIST
86728: LIST
86729: PUSH
86730: EMPTY
86731: LIST
86732: LIST
86733: PPUSH
86734: CALL_OW 69
86738: ST_TO_ADDR
// if not tmp then
86739: LD_VAR 0 3
86743: NOT
86744: IFFALSE 86748
// exit ;
86746: GO 86895
// if tmp > 5 then
86748: LD_VAR 0 3
86752: PUSH
86753: LD_INT 5
86755: GREATER
86756: IFFALSE 86768
// k := 5 else
86758: LD_ADDR_VAR 0 2
86762: PUSH
86763: LD_INT 5
86765: ST_TO_ADDR
86766: GO 86778
// k := tmp ;
86768: LD_ADDR_VAR 0 2
86772: PUSH
86773: LD_VAR 0 3
86777: ST_TO_ADDR
// for i := 1 to k do
86778: LD_ADDR_VAR 0 1
86782: PUSH
86783: DOUBLE
86784: LD_INT 1
86786: DEC
86787: ST_TO_ADDR
86788: LD_VAR 0 2
86792: PUSH
86793: FOR_TO
86794: IFFALSE 86893
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
86796: LD_VAR 0 3
86800: PUSH
86801: LD_VAR 0 1
86805: ARRAY
86806: PPUSH
86807: LD_VAR 0 1
86811: PUSH
86812: LD_INT 4
86814: MOD
86815: PUSH
86816: LD_INT 1
86818: PLUS
86819: PPUSH
86820: CALL_OW 259
86824: PUSH
86825: LD_INT 10
86827: LESS
86828: IFFALSE 86891
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
86830: LD_VAR 0 3
86834: PUSH
86835: LD_VAR 0 1
86839: ARRAY
86840: PPUSH
86841: LD_VAR 0 1
86845: PUSH
86846: LD_INT 4
86848: MOD
86849: PUSH
86850: LD_INT 1
86852: PLUS
86853: PPUSH
86854: LD_VAR 0 3
86858: PUSH
86859: LD_VAR 0 1
86863: ARRAY
86864: PPUSH
86865: LD_VAR 0 1
86869: PUSH
86870: LD_INT 4
86872: MOD
86873: PUSH
86874: LD_INT 1
86876: PLUS
86877: PPUSH
86878: CALL_OW 259
86882: PUSH
86883: LD_INT 1
86885: PLUS
86886: PPUSH
86887: CALL_OW 237
86891: GO 86793
86893: POP
86894: POP
// end ;
86895: PPOPN 3
86897: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
86898: LD_EXP 118
86902: PUSH
86903: LD_EXP 126
86907: AND
86908: IFFALSE 86928
86910: GO 86912
86912: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
86913: LD_INT 4
86915: PPUSH
86916: LD_OWVAR 2
86920: PPUSH
86921: LD_INT 0
86923: PPUSH
86924: CALL_OW 324
86928: END
// every 0 0$1 trigger StreamModeActive and sShovel do
86929: LD_EXP 118
86933: PUSH
86934: LD_EXP 155
86938: AND
86939: IFFALSE 86959
86941: GO 86943
86943: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
86944: LD_INT 19
86946: PPUSH
86947: LD_OWVAR 2
86951: PPUSH
86952: LD_INT 0
86954: PPUSH
86955: CALL_OW 324
86959: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
86960: LD_EXP 118
86964: PUSH
86965: LD_EXP 127
86969: AND
86970: IFFALSE 87072
86972: GO 86974
86974: DISABLE
86975: LD_INT 0
86977: PPUSH
86978: PPUSH
// begin enable ;
86979: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
86980: LD_ADDR_VAR 0 2
86984: PUSH
86985: LD_INT 22
86987: PUSH
86988: LD_OWVAR 2
86992: PUSH
86993: EMPTY
86994: LIST
86995: LIST
86996: PUSH
86997: LD_INT 2
86999: PUSH
87000: LD_INT 34
87002: PUSH
87003: LD_INT 11
87005: PUSH
87006: EMPTY
87007: LIST
87008: LIST
87009: PUSH
87010: LD_INT 34
87012: PUSH
87013: LD_INT 30
87015: PUSH
87016: EMPTY
87017: LIST
87018: LIST
87019: PUSH
87020: EMPTY
87021: LIST
87022: LIST
87023: LIST
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: PPUSH
87029: CALL_OW 69
87033: ST_TO_ADDR
// if not tmp then
87034: LD_VAR 0 2
87038: NOT
87039: IFFALSE 87043
// exit ;
87041: GO 87072
// for i in tmp do
87043: LD_ADDR_VAR 0 1
87047: PUSH
87048: LD_VAR 0 2
87052: PUSH
87053: FOR_IN
87054: IFFALSE 87070
// begin SetLives ( i , 0 ) ;
87056: LD_VAR 0 1
87060: PPUSH
87061: LD_INT 0
87063: PPUSH
87064: CALL_OW 234
// end ;
87068: GO 87053
87070: POP
87071: POP
// end ;
87072: PPOPN 2
87074: END
// every 0 0$1 trigger StreamModeActive and sBunker do
87075: LD_EXP 118
87079: PUSH
87080: LD_EXP 128
87084: AND
87085: IFFALSE 87105
87087: GO 87089
87089: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
87090: LD_INT 32
87092: PPUSH
87093: LD_OWVAR 2
87097: PPUSH
87098: LD_INT 0
87100: PPUSH
87101: CALL_OW 324
87105: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
87106: LD_EXP 118
87110: PUSH
87111: LD_EXP 129
87115: AND
87116: IFFALSE 87297
87118: GO 87120
87120: DISABLE
87121: LD_INT 0
87123: PPUSH
87124: PPUSH
87125: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
87126: LD_ADDR_VAR 0 2
87130: PUSH
87131: LD_INT 22
87133: PUSH
87134: LD_OWVAR 2
87138: PUSH
87139: EMPTY
87140: LIST
87141: LIST
87142: PUSH
87143: LD_INT 33
87145: PUSH
87146: LD_INT 3
87148: PUSH
87149: EMPTY
87150: LIST
87151: LIST
87152: PUSH
87153: EMPTY
87154: LIST
87155: LIST
87156: PPUSH
87157: CALL_OW 69
87161: ST_TO_ADDR
// if not tmp then
87162: LD_VAR 0 2
87166: NOT
87167: IFFALSE 87171
// exit ;
87169: GO 87297
// side := 0 ;
87171: LD_ADDR_VAR 0 3
87175: PUSH
87176: LD_INT 0
87178: ST_TO_ADDR
// for i := 1 to 8 do
87179: LD_ADDR_VAR 0 1
87183: PUSH
87184: DOUBLE
87185: LD_INT 1
87187: DEC
87188: ST_TO_ADDR
87189: LD_INT 8
87191: PUSH
87192: FOR_TO
87193: IFFALSE 87241
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
87195: LD_OWVAR 2
87199: PUSH
87200: LD_VAR 0 1
87204: NONEQUAL
87205: PUSH
87206: LD_OWVAR 2
87210: PPUSH
87211: LD_VAR 0 1
87215: PPUSH
87216: CALL_OW 81
87220: PUSH
87221: LD_INT 2
87223: EQUAL
87224: AND
87225: IFFALSE 87239
// begin side := i ;
87227: LD_ADDR_VAR 0 3
87231: PUSH
87232: LD_VAR 0 1
87236: ST_TO_ADDR
// break ;
87237: GO 87241
// end ;
87239: GO 87192
87241: POP
87242: POP
// if not side then
87243: LD_VAR 0 3
87247: NOT
87248: IFFALSE 87252
// exit ;
87250: GO 87297
// for i := 1 to tmp do
87252: LD_ADDR_VAR 0 1
87256: PUSH
87257: DOUBLE
87258: LD_INT 1
87260: DEC
87261: ST_TO_ADDR
87262: LD_VAR 0 2
87266: PUSH
87267: FOR_TO
87268: IFFALSE 87295
// if Prob ( 60 ) then
87270: LD_INT 60
87272: PPUSH
87273: CALL_OW 13
87277: IFFALSE 87293
// SetSide ( i , side ) ;
87279: LD_VAR 0 1
87283: PPUSH
87284: LD_VAR 0 3
87288: PPUSH
87289: CALL_OW 235
87293: GO 87267
87295: POP
87296: POP
// end ;
87297: PPOPN 3
87299: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
87300: LD_EXP 118
87304: PUSH
87305: LD_EXP 131
87309: AND
87310: IFFALSE 87429
87312: GO 87314
87314: DISABLE
87315: LD_INT 0
87317: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
87318: LD_ADDR_VAR 0 1
87322: PUSH
87323: LD_INT 22
87325: PUSH
87326: LD_OWVAR 2
87330: PUSH
87331: EMPTY
87332: LIST
87333: LIST
87334: PUSH
87335: LD_INT 21
87337: PUSH
87338: LD_INT 1
87340: PUSH
87341: EMPTY
87342: LIST
87343: LIST
87344: PUSH
87345: LD_INT 3
87347: PUSH
87348: LD_INT 23
87350: PUSH
87351: LD_INT 0
87353: PUSH
87354: EMPTY
87355: LIST
87356: LIST
87357: PUSH
87358: EMPTY
87359: LIST
87360: LIST
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: LIST
87366: PPUSH
87367: CALL_OW 69
87371: PUSH
87372: FOR_IN
87373: IFFALSE 87427
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
87375: LD_VAR 0 1
87379: PPUSH
87380: CALL_OW 257
87384: PUSH
87385: LD_INT 1
87387: PUSH
87388: LD_INT 2
87390: PUSH
87391: LD_INT 3
87393: PUSH
87394: LD_INT 4
87396: PUSH
87397: EMPTY
87398: LIST
87399: LIST
87400: LIST
87401: LIST
87402: IN
87403: IFFALSE 87425
// SetClass ( un , rand ( 1 , 4 ) ) ;
87405: LD_VAR 0 1
87409: PPUSH
87410: LD_INT 1
87412: PPUSH
87413: LD_INT 4
87415: PPUSH
87416: CALL_OW 12
87420: PPUSH
87421: CALL_OW 336
87425: GO 87372
87427: POP
87428: POP
// end ;
87429: PPOPN 1
87431: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
87432: LD_EXP 118
87436: PUSH
87437: LD_EXP 130
87441: AND
87442: IFFALSE 87521
87444: GO 87446
87446: DISABLE
87447: LD_INT 0
87449: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
87450: LD_ADDR_VAR 0 1
87454: PUSH
87455: LD_INT 22
87457: PUSH
87458: LD_OWVAR 2
87462: PUSH
87463: EMPTY
87464: LIST
87465: LIST
87466: PUSH
87467: LD_INT 21
87469: PUSH
87470: LD_INT 3
87472: PUSH
87473: EMPTY
87474: LIST
87475: LIST
87476: PUSH
87477: EMPTY
87478: LIST
87479: LIST
87480: PPUSH
87481: CALL_OW 69
87485: ST_TO_ADDR
// if not tmp then
87486: LD_VAR 0 1
87490: NOT
87491: IFFALSE 87495
// exit ;
87493: GO 87521
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
87495: LD_VAR 0 1
87499: PUSH
87500: LD_INT 1
87502: PPUSH
87503: LD_VAR 0 1
87507: PPUSH
87508: CALL_OW 12
87512: ARRAY
87513: PPUSH
87514: LD_INT 100
87516: PPUSH
87517: CALL_OW 234
// end ;
87521: PPOPN 1
87523: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
87524: LD_EXP 118
87528: PUSH
87529: LD_EXP 132
87533: AND
87534: IFFALSE 87632
87536: GO 87538
87538: DISABLE
87539: LD_INT 0
87541: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
87542: LD_ADDR_VAR 0 1
87546: PUSH
87547: LD_INT 22
87549: PUSH
87550: LD_OWVAR 2
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PUSH
87559: LD_INT 21
87561: PUSH
87562: LD_INT 1
87564: PUSH
87565: EMPTY
87566: LIST
87567: LIST
87568: PUSH
87569: EMPTY
87570: LIST
87571: LIST
87572: PPUSH
87573: CALL_OW 69
87577: ST_TO_ADDR
// if not tmp then
87578: LD_VAR 0 1
87582: NOT
87583: IFFALSE 87587
// exit ;
87585: GO 87632
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
87587: LD_VAR 0 1
87591: PUSH
87592: LD_INT 1
87594: PPUSH
87595: LD_VAR 0 1
87599: PPUSH
87600: CALL_OW 12
87604: ARRAY
87605: PPUSH
87606: LD_INT 1
87608: PPUSH
87609: LD_INT 4
87611: PPUSH
87612: CALL_OW 12
87616: PPUSH
87617: LD_INT 3000
87619: PPUSH
87620: LD_INT 9000
87622: PPUSH
87623: CALL_OW 12
87627: PPUSH
87628: CALL_OW 492
// end ;
87632: PPOPN 1
87634: END
// every 0 0$1 trigger StreamModeActive and sDepot do
87635: LD_EXP 118
87639: PUSH
87640: LD_EXP 133
87644: AND
87645: IFFALSE 87665
87647: GO 87649
87649: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
87650: LD_INT 1
87652: PPUSH
87653: LD_OWVAR 2
87657: PPUSH
87658: LD_INT 0
87660: PPUSH
87661: CALL_OW 324
87665: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
87666: LD_EXP 118
87670: PUSH
87671: LD_EXP 134
87675: AND
87676: IFFALSE 87759
87678: GO 87680
87680: DISABLE
87681: LD_INT 0
87683: PPUSH
87684: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
87685: LD_ADDR_VAR 0 2
87689: PUSH
87690: LD_INT 22
87692: PUSH
87693: LD_OWVAR 2
87697: PUSH
87698: EMPTY
87699: LIST
87700: LIST
87701: PUSH
87702: LD_INT 21
87704: PUSH
87705: LD_INT 3
87707: PUSH
87708: EMPTY
87709: LIST
87710: LIST
87711: PUSH
87712: EMPTY
87713: LIST
87714: LIST
87715: PPUSH
87716: CALL_OW 69
87720: ST_TO_ADDR
// if not tmp then
87721: LD_VAR 0 2
87725: NOT
87726: IFFALSE 87730
// exit ;
87728: GO 87759
// for i in tmp do
87730: LD_ADDR_VAR 0 1
87734: PUSH
87735: LD_VAR 0 2
87739: PUSH
87740: FOR_IN
87741: IFFALSE 87757
// SetBLevel ( i , 10 ) ;
87743: LD_VAR 0 1
87747: PPUSH
87748: LD_INT 10
87750: PPUSH
87751: CALL_OW 241
87755: GO 87740
87757: POP
87758: POP
// end ;
87759: PPOPN 2
87761: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
87762: LD_EXP 118
87766: PUSH
87767: LD_EXP 135
87771: AND
87772: IFFALSE 87883
87774: GO 87776
87776: DISABLE
87777: LD_INT 0
87779: PPUSH
87780: PPUSH
87781: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
87782: LD_ADDR_VAR 0 3
87786: PUSH
87787: LD_INT 22
87789: PUSH
87790: LD_OWVAR 2
87794: PUSH
87795: EMPTY
87796: LIST
87797: LIST
87798: PUSH
87799: LD_INT 25
87801: PUSH
87802: LD_INT 1
87804: PUSH
87805: EMPTY
87806: LIST
87807: LIST
87808: PUSH
87809: EMPTY
87810: LIST
87811: LIST
87812: PPUSH
87813: CALL_OW 69
87817: ST_TO_ADDR
// if not tmp then
87818: LD_VAR 0 3
87822: NOT
87823: IFFALSE 87827
// exit ;
87825: GO 87883
// un := tmp [ rand ( 1 , tmp ) ] ;
87827: LD_ADDR_VAR 0 2
87831: PUSH
87832: LD_VAR 0 3
87836: PUSH
87837: LD_INT 1
87839: PPUSH
87840: LD_VAR 0 3
87844: PPUSH
87845: CALL_OW 12
87849: ARRAY
87850: ST_TO_ADDR
// if Crawls ( un ) then
87851: LD_VAR 0 2
87855: PPUSH
87856: CALL_OW 318
87860: IFFALSE 87871
// ComWalk ( un ) ;
87862: LD_VAR 0 2
87866: PPUSH
87867: CALL_OW 138
// SetClass ( un , class_sniper ) ;
87871: LD_VAR 0 2
87875: PPUSH
87876: LD_INT 5
87878: PPUSH
87879: CALL_OW 336
// end ;
87883: PPOPN 3
87885: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
87886: LD_EXP 118
87890: PUSH
87891: LD_EXP 136
87895: AND
87896: PUSH
87897: LD_OWVAR 67
87901: PUSH
87902: LD_INT 3
87904: LESS
87905: AND
87906: IFFALSE 87925
87908: GO 87910
87910: DISABLE
// Difficulty := Difficulty + 1 ;
87911: LD_ADDR_OWVAR 67
87915: PUSH
87916: LD_OWVAR 67
87920: PUSH
87921: LD_INT 1
87923: PLUS
87924: ST_TO_ADDR
87925: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
87926: LD_EXP 118
87930: PUSH
87931: LD_EXP 137
87935: AND
87936: IFFALSE 88039
87938: GO 87940
87940: DISABLE
87941: LD_INT 0
87943: PPUSH
// begin for i := 1 to 5 do
87944: LD_ADDR_VAR 0 1
87948: PUSH
87949: DOUBLE
87950: LD_INT 1
87952: DEC
87953: ST_TO_ADDR
87954: LD_INT 5
87956: PUSH
87957: FOR_TO
87958: IFFALSE 88037
// begin uc_nation := nation_nature ;
87960: LD_ADDR_OWVAR 21
87964: PUSH
87965: LD_INT 0
87967: ST_TO_ADDR
// uc_side := 0 ;
87968: LD_ADDR_OWVAR 20
87972: PUSH
87973: LD_INT 0
87975: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
87976: LD_ADDR_OWVAR 29
87980: PUSH
87981: LD_INT 12
87983: PUSH
87984: LD_INT 12
87986: PUSH
87987: EMPTY
87988: LIST
87989: LIST
87990: ST_TO_ADDR
// hc_agressivity := 20 ;
87991: LD_ADDR_OWVAR 35
87995: PUSH
87996: LD_INT 20
87998: ST_TO_ADDR
// hc_class := class_tiger ;
87999: LD_ADDR_OWVAR 28
88003: PUSH
88004: LD_INT 14
88006: ST_TO_ADDR
// hc_gallery :=  ;
88007: LD_ADDR_OWVAR 33
88011: PUSH
88012: LD_STRING 
88014: ST_TO_ADDR
// hc_name :=  ;
88015: LD_ADDR_OWVAR 26
88019: PUSH
88020: LD_STRING 
88022: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
88023: CALL_OW 44
88027: PPUSH
88028: LD_INT 0
88030: PPUSH
88031: CALL_OW 51
// end ;
88035: GO 87957
88037: POP
88038: POP
// end ;
88039: PPOPN 1
88041: END
// every 0 0$1 trigger StreamModeActive and sBomb do
88042: LD_EXP 118
88046: PUSH
88047: LD_EXP 138
88051: AND
88052: IFFALSE 88061
88054: GO 88056
88056: DISABLE
// StreamSibBomb ;
88057: CALL 88062 0 0
88061: END
// export function StreamSibBomb ; var i , x , y ; begin
88062: LD_INT 0
88064: PPUSH
88065: PPUSH
88066: PPUSH
88067: PPUSH
// result := false ;
88068: LD_ADDR_VAR 0 1
88072: PUSH
88073: LD_INT 0
88075: ST_TO_ADDR
// for i := 1 to 16 do
88076: LD_ADDR_VAR 0 2
88080: PUSH
88081: DOUBLE
88082: LD_INT 1
88084: DEC
88085: ST_TO_ADDR
88086: LD_INT 16
88088: PUSH
88089: FOR_TO
88090: IFFALSE 88289
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
88092: LD_ADDR_VAR 0 3
88096: PUSH
88097: LD_INT 10
88099: PUSH
88100: LD_INT 20
88102: PUSH
88103: LD_INT 30
88105: PUSH
88106: LD_INT 40
88108: PUSH
88109: LD_INT 50
88111: PUSH
88112: LD_INT 60
88114: PUSH
88115: LD_INT 70
88117: PUSH
88118: LD_INT 80
88120: PUSH
88121: LD_INT 90
88123: PUSH
88124: LD_INT 100
88126: PUSH
88127: LD_INT 110
88129: PUSH
88130: LD_INT 120
88132: PUSH
88133: LD_INT 130
88135: PUSH
88136: LD_INT 140
88138: PUSH
88139: LD_INT 150
88141: PUSH
88142: EMPTY
88143: LIST
88144: LIST
88145: LIST
88146: LIST
88147: LIST
88148: LIST
88149: LIST
88150: LIST
88151: LIST
88152: LIST
88153: LIST
88154: LIST
88155: LIST
88156: LIST
88157: LIST
88158: PUSH
88159: LD_INT 1
88161: PPUSH
88162: LD_INT 15
88164: PPUSH
88165: CALL_OW 12
88169: ARRAY
88170: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
88171: LD_ADDR_VAR 0 4
88175: PUSH
88176: LD_INT 10
88178: PUSH
88179: LD_INT 20
88181: PUSH
88182: LD_INT 30
88184: PUSH
88185: LD_INT 40
88187: PUSH
88188: LD_INT 50
88190: PUSH
88191: LD_INT 60
88193: PUSH
88194: LD_INT 70
88196: PUSH
88197: LD_INT 80
88199: PUSH
88200: LD_INT 90
88202: PUSH
88203: LD_INT 100
88205: PUSH
88206: LD_INT 110
88208: PUSH
88209: LD_INT 120
88211: PUSH
88212: LD_INT 130
88214: PUSH
88215: LD_INT 140
88217: PUSH
88218: LD_INT 150
88220: PUSH
88221: EMPTY
88222: LIST
88223: LIST
88224: LIST
88225: LIST
88226: LIST
88227: LIST
88228: LIST
88229: LIST
88230: LIST
88231: LIST
88232: LIST
88233: LIST
88234: LIST
88235: LIST
88236: LIST
88237: PUSH
88238: LD_INT 1
88240: PPUSH
88241: LD_INT 15
88243: PPUSH
88244: CALL_OW 12
88248: ARRAY
88249: ST_TO_ADDR
// if ValidHex ( x , y ) then
88250: LD_VAR 0 3
88254: PPUSH
88255: LD_VAR 0 4
88259: PPUSH
88260: CALL_OW 488
88264: IFFALSE 88287
// begin result := [ x , y ] ;
88266: LD_ADDR_VAR 0 1
88270: PUSH
88271: LD_VAR 0 3
88275: PUSH
88276: LD_VAR 0 4
88280: PUSH
88281: EMPTY
88282: LIST
88283: LIST
88284: ST_TO_ADDR
// break ;
88285: GO 88289
// end ; end ;
88287: GO 88089
88289: POP
88290: POP
// if result then
88291: LD_VAR 0 1
88295: IFFALSE 88355
// begin ToLua ( playSibBomb() ) ;
88297: LD_STRING playSibBomb()
88299: PPUSH
88300: CALL_OW 559
// wait ( 0 0$14 ) ;
88304: LD_INT 490
88306: PPUSH
88307: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
88311: LD_VAR 0 1
88315: PUSH
88316: LD_INT 1
88318: ARRAY
88319: PPUSH
88320: LD_VAR 0 1
88324: PUSH
88325: LD_INT 2
88327: ARRAY
88328: PPUSH
88329: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
88333: LD_VAR 0 1
88337: PUSH
88338: LD_INT 1
88340: ARRAY
88341: PPUSH
88342: LD_VAR 0 1
88346: PUSH
88347: LD_INT 2
88349: ARRAY
88350: PPUSH
88351: CALL_OW 429
// end ; end ;
88355: LD_VAR 0 1
88359: RET
// every 0 0$1 trigger StreamModeActive and sReset do
88360: LD_EXP 118
88364: PUSH
88365: LD_EXP 140
88369: AND
88370: IFFALSE 88382
88372: GO 88374
88374: DISABLE
// YouLost (  ) ;
88375: LD_STRING 
88377: PPUSH
88378: CALL_OW 104
88382: END
// every 0 0$1 trigger StreamModeActive and sFog do
88383: LD_EXP 118
88387: PUSH
88388: LD_EXP 139
88392: AND
88393: IFFALSE 88407
88395: GO 88397
88397: DISABLE
// FogOff ( your_side ) ;
88398: LD_OWVAR 2
88402: PPUSH
88403: CALL_OW 344
88407: END
// every 0 0$1 trigger StreamModeActive and sSun do
88408: LD_EXP 118
88412: PUSH
88413: LD_EXP 141
88417: AND
88418: IFFALSE 88446
88420: GO 88422
88422: DISABLE
// begin solar_recharge_percent := 0 ;
88423: LD_ADDR_OWVAR 79
88427: PUSH
88428: LD_INT 0
88430: ST_TO_ADDR
// wait ( 5 5$00 ) ;
88431: LD_INT 10500
88433: PPUSH
88434: CALL_OW 67
// solar_recharge_percent := 100 ;
88438: LD_ADDR_OWVAR 79
88442: PUSH
88443: LD_INT 100
88445: ST_TO_ADDR
// end ;
88446: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
88447: LD_EXP 118
88451: PUSH
88452: LD_EXP 142
88456: AND
88457: IFFALSE 88696
88459: GO 88461
88461: DISABLE
88462: LD_INT 0
88464: PPUSH
88465: PPUSH
88466: PPUSH
// begin tmp := [ ] ;
88467: LD_ADDR_VAR 0 3
88471: PUSH
88472: EMPTY
88473: ST_TO_ADDR
// for i := 1 to 6 do
88474: LD_ADDR_VAR 0 1
88478: PUSH
88479: DOUBLE
88480: LD_INT 1
88482: DEC
88483: ST_TO_ADDR
88484: LD_INT 6
88486: PUSH
88487: FOR_TO
88488: IFFALSE 88593
// begin uc_nation := nation_nature ;
88490: LD_ADDR_OWVAR 21
88494: PUSH
88495: LD_INT 0
88497: ST_TO_ADDR
// uc_side := 0 ;
88498: LD_ADDR_OWVAR 20
88502: PUSH
88503: LD_INT 0
88505: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
88506: LD_ADDR_OWVAR 29
88510: PUSH
88511: LD_INT 12
88513: PUSH
88514: LD_INT 12
88516: PUSH
88517: EMPTY
88518: LIST
88519: LIST
88520: ST_TO_ADDR
// hc_agressivity := 20 ;
88521: LD_ADDR_OWVAR 35
88525: PUSH
88526: LD_INT 20
88528: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
88529: LD_ADDR_OWVAR 28
88533: PUSH
88534: LD_INT 17
88536: ST_TO_ADDR
// hc_gallery :=  ;
88537: LD_ADDR_OWVAR 33
88541: PUSH
88542: LD_STRING 
88544: ST_TO_ADDR
// hc_name :=  ;
88545: LD_ADDR_OWVAR 26
88549: PUSH
88550: LD_STRING 
88552: ST_TO_ADDR
// un := CreateHuman ;
88553: LD_ADDR_VAR 0 2
88557: PUSH
88558: CALL_OW 44
88562: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
88563: LD_VAR 0 2
88567: PPUSH
88568: LD_INT 1
88570: PPUSH
88571: CALL_OW 51
// tmp := tmp ^ un ;
88575: LD_ADDR_VAR 0 3
88579: PUSH
88580: LD_VAR 0 3
88584: PUSH
88585: LD_VAR 0 2
88589: ADD
88590: ST_TO_ADDR
// end ;
88591: GO 88487
88593: POP
88594: POP
// repeat wait ( 0 0$1 ) ;
88595: LD_INT 35
88597: PPUSH
88598: CALL_OW 67
// for un in tmp do
88602: LD_ADDR_VAR 0 2
88606: PUSH
88607: LD_VAR 0 3
88611: PUSH
88612: FOR_IN
88613: IFFALSE 88687
// begin if IsDead ( un ) then
88615: LD_VAR 0 2
88619: PPUSH
88620: CALL_OW 301
88624: IFFALSE 88644
// begin tmp := tmp diff un ;
88626: LD_ADDR_VAR 0 3
88630: PUSH
88631: LD_VAR 0 3
88635: PUSH
88636: LD_VAR 0 2
88640: DIFF
88641: ST_TO_ADDR
// continue ;
88642: GO 88612
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
88644: LD_VAR 0 2
88648: PPUSH
88649: LD_INT 3
88651: PUSH
88652: LD_INT 22
88654: PUSH
88655: LD_INT 0
88657: PUSH
88658: EMPTY
88659: LIST
88660: LIST
88661: PUSH
88662: EMPTY
88663: LIST
88664: LIST
88665: PPUSH
88666: CALL_OW 69
88670: PPUSH
88671: LD_VAR 0 2
88675: PPUSH
88676: CALL_OW 74
88680: PPUSH
88681: CALL_OW 115
// end ;
88685: GO 88612
88687: POP
88688: POP
// until not tmp ;
88689: LD_VAR 0 3
88693: NOT
88694: IFFALSE 88595
// end ;
88696: PPOPN 3
88698: END
// every 0 0$1 trigger StreamModeActive and sTroll do
88699: LD_EXP 118
88703: PUSH
88704: LD_EXP 143
88708: AND
88709: IFFALSE 88763
88711: GO 88713
88713: DISABLE
// begin ToLua ( displayTroll(); ) ;
88714: LD_STRING displayTroll();
88716: PPUSH
88717: CALL_OW 559
// wait ( 3 3$00 ) ;
88721: LD_INT 6300
88723: PPUSH
88724: CALL_OW 67
// ToLua ( hideTroll(); ) ;
88728: LD_STRING hideTroll();
88730: PPUSH
88731: CALL_OW 559
// wait ( 1 1$00 ) ;
88735: LD_INT 2100
88737: PPUSH
88738: CALL_OW 67
// ToLua ( displayTroll(); ) ;
88742: LD_STRING displayTroll();
88744: PPUSH
88745: CALL_OW 559
// wait ( 1 1$00 ) ;
88749: LD_INT 2100
88751: PPUSH
88752: CALL_OW 67
// ToLua ( hideTroll(); ) ;
88756: LD_STRING hideTroll();
88758: PPUSH
88759: CALL_OW 559
// end ;
88763: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
88764: LD_EXP 118
88768: PUSH
88769: LD_EXP 144
88773: AND
88774: IFFALSE 88837
88776: GO 88778
88778: DISABLE
88779: LD_INT 0
88781: PPUSH
// begin p := 0 ;
88782: LD_ADDR_VAR 0 1
88786: PUSH
88787: LD_INT 0
88789: ST_TO_ADDR
// repeat game_speed := 1 ;
88790: LD_ADDR_OWVAR 65
88794: PUSH
88795: LD_INT 1
88797: ST_TO_ADDR
// wait ( 0 0$1 ) ;
88798: LD_INT 35
88800: PPUSH
88801: CALL_OW 67
// p := p + 1 ;
88805: LD_ADDR_VAR 0 1
88809: PUSH
88810: LD_VAR 0 1
88814: PUSH
88815: LD_INT 1
88817: PLUS
88818: ST_TO_ADDR
// until p >= 60 ;
88819: LD_VAR 0 1
88823: PUSH
88824: LD_INT 60
88826: GREATEREQUAL
88827: IFFALSE 88790
// game_speed := 4 ;
88829: LD_ADDR_OWVAR 65
88833: PUSH
88834: LD_INT 4
88836: ST_TO_ADDR
// end ;
88837: PPOPN 1
88839: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
88840: LD_EXP 118
88844: PUSH
88845: LD_EXP 145
88849: AND
88850: IFFALSE 88996
88852: GO 88854
88854: DISABLE
88855: LD_INT 0
88857: PPUSH
88858: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
88859: LD_ADDR_VAR 0 1
88863: PUSH
88864: LD_INT 22
88866: PUSH
88867: LD_OWVAR 2
88871: PUSH
88872: EMPTY
88873: LIST
88874: LIST
88875: PUSH
88876: LD_INT 2
88878: PUSH
88879: LD_INT 30
88881: PUSH
88882: LD_INT 0
88884: PUSH
88885: EMPTY
88886: LIST
88887: LIST
88888: PUSH
88889: LD_INT 30
88891: PUSH
88892: LD_INT 1
88894: PUSH
88895: EMPTY
88896: LIST
88897: LIST
88898: PUSH
88899: EMPTY
88900: LIST
88901: LIST
88902: LIST
88903: PUSH
88904: EMPTY
88905: LIST
88906: LIST
88907: PPUSH
88908: CALL_OW 69
88912: ST_TO_ADDR
// if not depot then
88913: LD_VAR 0 1
88917: NOT
88918: IFFALSE 88922
// exit ;
88920: GO 88996
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
88922: LD_ADDR_VAR 0 2
88926: PUSH
88927: LD_VAR 0 1
88931: PUSH
88932: LD_INT 1
88934: PPUSH
88935: LD_VAR 0 1
88939: PPUSH
88940: CALL_OW 12
88944: ARRAY
88945: PPUSH
88946: CALL_OW 274
88950: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
88951: LD_VAR 0 2
88955: PPUSH
88956: LD_INT 1
88958: PPUSH
88959: LD_INT 0
88961: PPUSH
88962: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
88966: LD_VAR 0 2
88970: PPUSH
88971: LD_INT 2
88973: PPUSH
88974: LD_INT 0
88976: PPUSH
88977: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
88981: LD_VAR 0 2
88985: PPUSH
88986: LD_INT 3
88988: PPUSH
88989: LD_INT 0
88991: PPUSH
88992: CALL_OW 277
// end ;
88996: PPOPN 2
88998: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
88999: LD_EXP 118
89003: PUSH
89004: LD_EXP 146
89008: AND
89009: IFFALSE 89106
89011: GO 89013
89013: DISABLE
89014: LD_INT 0
89016: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
89017: LD_ADDR_VAR 0 1
89021: PUSH
89022: LD_INT 22
89024: PUSH
89025: LD_OWVAR 2
89029: PUSH
89030: EMPTY
89031: LIST
89032: LIST
89033: PUSH
89034: LD_INT 21
89036: PUSH
89037: LD_INT 1
89039: PUSH
89040: EMPTY
89041: LIST
89042: LIST
89043: PUSH
89044: LD_INT 3
89046: PUSH
89047: LD_INT 23
89049: PUSH
89050: LD_INT 0
89052: PUSH
89053: EMPTY
89054: LIST
89055: LIST
89056: PUSH
89057: EMPTY
89058: LIST
89059: LIST
89060: PUSH
89061: EMPTY
89062: LIST
89063: LIST
89064: LIST
89065: PPUSH
89066: CALL_OW 69
89070: ST_TO_ADDR
// if not tmp then
89071: LD_VAR 0 1
89075: NOT
89076: IFFALSE 89080
// exit ;
89078: GO 89106
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
89080: LD_VAR 0 1
89084: PUSH
89085: LD_INT 1
89087: PPUSH
89088: LD_VAR 0 1
89092: PPUSH
89093: CALL_OW 12
89097: ARRAY
89098: PPUSH
89099: LD_INT 200
89101: PPUSH
89102: CALL_OW 234
// end ;
89106: PPOPN 1
89108: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
89109: LD_EXP 118
89113: PUSH
89114: LD_EXP 147
89118: AND
89119: IFFALSE 89198
89121: GO 89123
89123: DISABLE
89124: LD_INT 0
89126: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
89127: LD_ADDR_VAR 0 1
89131: PUSH
89132: LD_INT 22
89134: PUSH
89135: LD_OWVAR 2
89139: PUSH
89140: EMPTY
89141: LIST
89142: LIST
89143: PUSH
89144: LD_INT 21
89146: PUSH
89147: LD_INT 2
89149: PUSH
89150: EMPTY
89151: LIST
89152: LIST
89153: PUSH
89154: EMPTY
89155: LIST
89156: LIST
89157: PPUSH
89158: CALL_OW 69
89162: ST_TO_ADDR
// if not tmp then
89163: LD_VAR 0 1
89167: NOT
89168: IFFALSE 89172
// exit ;
89170: GO 89198
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
89172: LD_VAR 0 1
89176: PUSH
89177: LD_INT 1
89179: PPUSH
89180: LD_VAR 0 1
89184: PPUSH
89185: CALL_OW 12
89189: ARRAY
89190: PPUSH
89191: LD_INT 60
89193: PPUSH
89194: CALL_OW 234
// end ;
89198: PPOPN 1
89200: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
89201: LD_EXP 118
89205: PUSH
89206: LD_EXP 148
89210: AND
89211: IFFALSE 89310
89213: GO 89215
89215: DISABLE
89216: LD_INT 0
89218: PPUSH
89219: PPUSH
// begin enable ;
89220: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
89221: LD_ADDR_VAR 0 1
89225: PUSH
89226: LD_INT 22
89228: PUSH
89229: LD_OWVAR 2
89233: PUSH
89234: EMPTY
89235: LIST
89236: LIST
89237: PUSH
89238: LD_INT 61
89240: PUSH
89241: EMPTY
89242: LIST
89243: PUSH
89244: LD_INT 33
89246: PUSH
89247: LD_INT 2
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: PUSH
89254: EMPTY
89255: LIST
89256: LIST
89257: LIST
89258: PPUSH
89259: CALL_OW 69
89263: ST_TO_ADDR
// if not tmp then
89264: LD_VAR 0 1
89268: NOT
89269: IFFALSE 89273
// exit ;
89271: GO 89310
// for i in tmp do
89273: LD_ADDR_VAR 0 2
89277: PUSH
89278: LD_VAR 0 1
89282: PUSH
89283: FOR_IN
89284: IFFALSE 89308
// if IsControledBy ( i ) then
89286: LD_VAR 0 2
89290: PPUSH
89291: CALL_OW 312
89295: IFFALSE 89306
// ComUnlink ( i ) ;
89297: LD_VAR 0 2
89301: PPUSH
89302: CALL_OW 136
89306: GO 89283
89308: POP
89309: POP
// end ;
89310: PPOPN 2
89312: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
89313: LD_EXP 118
89317: PUSH
89318: LD_EXP 149
89322: AND
89323: IFFALSE 89463
89325: GO 89327
89327: DISABLE
89328: LD_INT 0
89330: PPUSH
89331: PPUSH
// begin ToLua ( displayPowell(); ) ;
89332: LD_STRING displayPowell();
89334: PPUSH
89335: CALL_OW 559
// uc_side := 0 ;
89339: LD_ADDR_OWVAR 20
89343: PUSH
89344: LD_INT 0
89346: ST_TO_ADDR
// uc_nation := 2 ;
89347: LD_ADDR_OWVAR 21
89351: PUSH
89352: LD_INT 2
89354: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
89355: LD_ADDR_OWVAR 37
89359: PUSH
89360: LD_INT 14
89362: ST_TO_ADDR
// vc_engine := engine_siberite ;
89363: LD_ADDR_OWVAR 39
89367: PUSH
89368: LD_INT 3
89370: ST_TO_ADDR
// vc_control := control_apeman ;
89371: LD_ADDR_OWVAR 38
89375: PUSH
89376: LD_INT 5
89378: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
89379: LD_ADDR_OWVAR 40
89383: PUSH
89384: LD_INT 29
89386: ST_TO_ADDR
// un := CreateVehicle ;
89387: LD_ADDR_VAR 0 2
89391: PUSH
89392: CALL_OW 45
89396: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
89397: LD_VAR 0 2
89401: PPUSH
89402: LD_INT 1
89404: PPUSH
89405: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
89409: LD_INT 35
89411: PPUSH
89412: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
89416: LD_VAR 0 2
89420: PPUSH
89421: LD_INT 22
89423: PUSH
89424: LD_OWVAR 2
89428: PUSH
89429: EMPTY
89430: LIST
89431: LIST
89432: PPUSH
89433: CALL_OW 69
89437: PPUSH
89438: LD_VAR 0 2
89442: PPUSH
89443: CALL_OW 74
89447: PPUSH
89448: CALL_OW 115
// until IsDead ( un ) ;
89452: LD_VAR 0 2
89456: PPUSH
89457: CALL_OW 301
89461: IFFALSE 89409
// end ;
89463: PPOPN 2
89465: END
// every 0 0$1 trigger StreamModeActive and sStu do
89466: LD_EXP 118
89470: PUSH
89471: LD_EXP 157
89475: AND
89476: IFFALSE 89492
89478: GO 89480
89480: DISABLE
// begin ToLua ( displayStucuk(); ) ;
89481: LD_STRING displayStucuk();
89483: PPUSH
89484: CALL_OW 559
// ResetFog ;
89488: CALL_OW 335
// end ;
89492: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
89493: LD_EXP 118
89497: PUSH
89498: LD_EXP 150
89502: AND
89503: IFFALSE 89644
89505: GO 89507
89507: DISABLE
89508: LD_INT 0
89510: PPUSH
89511: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89512: LD_ADDR_VAR 0 2
89516: PUSH
89517: LD_INT 22
89519: PUSH
89520: LD_OWVAR 2
89524: PUSH
89525: EMPTY
89526: LIST
89527: LIST
89528: PUSH
89529: LD_INT 21
89531: PUSH
89532: LD_INT 1
89534: PUSH
89535: EMPTY
89536: LIST
89537: LIST
89538: PUSH
89539: EMPTY
89540: LIST
89541: LIST
89542: PPUSH
89543: CALL_OW 69
89547: ST_TO_ADDR
// if not tmp then
89548: LD_VAR 0 2
89552: NOT
89553: IFFALSE 89557
// exit ;
89555: GO 89644
// un := tmp [ rand ( 1 , tmp ) ] ;
89557: LD_ADDR_VAR 0 1
89561: PUSH
89562: LD_VAR 0 2
89566: PUSH
89567: LD_INT 1
89569: PPUSH
89570: LD_VAR 0 2
89574: PPUSH
89575: CALL_OW 12
89579: ARRAY
89580: ST_TO_ADDR
// SetSide ( un , 0 ) ;
89581: LD_VAR 0 1
89585: PPUSH
89586: LD_INT 0
89588: PPUSH
89589: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
89593: LD_VAR 0 1
89597: PPUSH
89598: LD_OWVAR 3
89602: PUSH
89603: LD_VAR 0 1
89607: DIFF
89608: PPUSH
89609: LD_VAR 0 1
89613: PPUSH
89614: CALL_OW 74
89618: PPUSH
89619: CALL_OW 115
// wait ( 0 0$20 ) ;
89623: LD_INT 700
89625: PPUSH
89626: CALL_OW 67
// SetSide ( un , your_side ) ;
89630: LD_VAR 0 1
89634: PPUSH
89635: LD_OWVAR 2
89639: PPUSH
89640: CALL_OW 235
// end ;
89644: PPOPN 2
89646: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
89647: LD_EXP 118
89651: PUSH
89652: LD_EXP 151
89656: AND
89657: IFFALSE 89763
89659: GO 89661
89661: DISABLE
89662: LD_INT 0
89664: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
89665: LD_ADDR_VAR 0 1
89669: PUSH
89670: LD_INT 22
89672: PUSH
89673: LD_OWVAR 2
89677: PUSH
89678: EMPTY
89679: LIST
89680: LIST
89681: PUSH
89682: LD_INT 2
89684: PUSH
89685: LD_INT 30
89687: PUSH
89688: LD_INT 0
89690: PUSH
89691: EMPTY
89692: LIST
89693: LIST
89694: PUSH
89695: LD_INT 30
89697: PUSH
89698: LD_INT 1
89700: PUSH
89701: EMPTY
89702: LIST
89703: LIST
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: LIST
89709: PUSH
89710: EMPTY
89711: LIST
89712: LIST
89713: PPUSH
89714: CALL_OW 69
89718: ST_TO_ADDR
// if not depot then
89719: LD_VAR 0 1
89723: NOT
89724: IFFALSE 89728
// exit ;
89726: GO 89763
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
89728: LD_VAR 0 1
89732: PUSH
89733: LD_INT 1
89735: ARRAY
89736: PPUSH
89737: CALL_OW 250
89741: PPUSH
89742: LD_VAR 0 1
89746: PUSH
89747: LD_INT 1
89749: ARRAY
89750: PPUSH
89751: CALL_OW 251
89755: PPUSH
89756: LD_INT 70
89758: PPUSH
89759: CALL_OW 495
// end ;
89763: PPOPN 1
89765: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
89766: LD_EXP 118
89770: PUSH
89771: LD_EXP 152
89775: AND
89776: IFFALSE 89987
89778: GO 89780
89780: DISABLE
89781: LD_INT 0
89783: PPUSH
89784: PPUSH
89785: PPUSH
89786: PPUSH
89787: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89788: LD_ADDR_VAR 0 5
89792: PUSH
89793: LD_INT 22
89795: PUSH
89796: LD_OWVAR 2
89800: PUSH
89801: EMPTY
89802: LIST
89803: LIST
89804: PUSH
89805: LD_INT 21
89807: PUSH
89808: LD_INT 1
89810: PUSH
89811: EMPTY
89812: LIST
89813: LIST
89814: PUSH
89815: EMPTY
89816: LIST
89817: LIST
89818: PPUSH
89819: CALL_OW 69
89823: ST_TO_ADDR
// if not tmp then
89824: LD_VAR 0 5
89828: NOT
89829: IFFALSE 89833
// exit ;
89831: GO 89987
// for i in tmp do
89833: LD_ADDR_VAR 0 1
89837: PUSH
89838: LD_VAR 0 5
89842: PUSH
89843: FOR_IN
89844: IFFALSE 89985
// begin d := rand ( 0 , 5 ) ;
89846: LD_ADDR_VAR 0 4
89850: PUSH
89851: LD_INT 0
89853: PPUSH
89854: LD_INT 5
89856: PPUSH
89857: CALL_OW 12
89861: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
89862: LD_ADDR_VAR 0 2
89866: PUSH
89867: LD_VAR 0 1
89871: PPUSH
89872: CALL_OW 250
89876: PPUSH
89877: LD_VAR 0 4
89881: PPUSH
89882: LD_INT 3
89884: PPUSH
89885: LD_INT 12
89887: PPUSH
89888: CALL_OW 12
89892: PPUSH
89893: CALL_OW 272
89897: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
89898: LD_ADDR_VAR 0 3
89902: PUSH
89903: LD_VAR 0 1
89907: PPUSH
89908: CALL_OW 251
89912: PPUSH
89913: LD_VAR 0 4
89917: PPUSH
89918: LD_INT 3
89920: PPUSH
89921: LD_INT 12
89923: PPUSH
89924: CALL_OW 12
89928: PPUSH
89929: CALL_OW 273
89933: ST_TO_ADDR
// if ValidHex ( x , y ) then
89934: LD_VAR 0 2
89938: PPUSH
89939: LD_VAR 0 3
89943: PPUSH
89944: CALL_OW 488
89948: IFFALSE 89983
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
89950: LD_VAR 0 1
89954: PPUSH
89955: LD_VAR 0 2
89959: PPUSH
89960: LD_VAR 0 3
89964: PPUSH
89965: LD_INT 3
89967: PPUSH
89968: LD_INT 6
89970: PPUSH
89971: CALL_OW 12
89975: PPUSH
89976: LD_INT 1
89978: PPUSH
89979: CALL_OW 483
// end ;
89983: GO 89843
89985: POP
89986: POP
// end ;
89987: PPOPN 5
89989: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
89990: LD_EXP 118
89994: PUSH
89995: LD_EXP 153
89999: AND
90000: IFFALSE 90094
90002: GO 90004
90004: DISABLE
90005: LD_INT 0
90007: PPUSH
90008: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
90009: LD_ADDR_VAR 0 2
90013: PUSH
90014: LD_INT 22
90016: PUSH
90017: LD_OWVAR 2
90021: PUSH
90022: EMPTY
90023: LIST
90024: LIST
90025: PUSH
90026: LD_INT 32
90028: PUSH
90029: LD_INT 1
90031: PUSH
90032: EMPTY
90033: LIST
90034: LIST
90035: PUSH
90036: LD_INT 21
90038: PUSH
90039: LD_INT 2
90041: PUSH
90042: EMPTY
90043: LIST
90044: LIST
90045: PUSH
90046: EMPTY
90047: LIST
90048: LIST
90049: LIST
90050: PPUSH
90051: CALL_OW 69
90055: ST_TO_ADDR
// if not tmp then
90056: LD_VAR 0 2
90060: NOT
90061: IFFALSE 90065
// exit ;
90063: GO 90094
// for i in tmp do
90065: LD_ADDR_VAR 0 1
90069: PUSH
90070: LD_VAR 0 2
90074: PUSH
90075: FOR_IN
90076: IFFALSE 90092
// SetFuel ( i , 0 ) ;
90078: LD_VAR 0 1
90082: PPUSH
90083: LD_INT 0
90085: PPUSH
90086: CALL_OW 240
90090: GO 90075
90092: POP
90093: POP
// end ;
90094: PPOPN 2
90096: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
90097: LD_EXP 118
90101: PUSH
90102: LD_EXP 154
90106: AND
90107: IFFALSE 90173
90109: GO 90111
90111: DISABLE
90112: LD_INT 0
90114: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
90115: LD_ADDR_VAR 0 1
90119: PUSH
90120: LD_INT 22
90122: PUSH
90123: LD_OWVAR 2
90127: PUSH
90128: EMPTY
90129: LIST
90130: LIST
90131: PUSH
90132: LD_INT 30
90134: PUSH
90135: LD_INT 29
90137: PUSH
90138: EMPTY
90139: LIST
90140: LIST
90141: PUSH
90142: EMPTY
90143: LIST
90144: LIST
90145: PPUSH
90146: CALL_OW 69
90150: ST_TO_ADDR
// if not tmp then
90151: LD_VAR 0 1
90155: NOT
90156: IFFALSE 90160
// exit ;
90158: GO 90173
// DestroyUnit ( tmp [ 1 ] ) ;
90160: LD_VAR 0 1
90164: PUSH
90165: LD_INT 1
90167: ARRAY
90168: PPUSH
90169: CALL_OW 65
// end ;
90173: PPOPN 1
90175: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
90176: LD_EXP 118
90180: PUSH
90181: LD_EXP 156
90185: AND
90186: IFFALSE 90315
90188: GO 90190
90190: DISABLE
90191: LD_INT 0
90193: PPUSH
// begin uc_side := 0 ;
90194: LD_ADDR_OWVAR 20
90198: PUSH
90199: LD_INT 0
90201: ST_TO_ADDR
// uc_nation := nation_arabian ;
90202: LD_ADDR_OWVAR 21
90206: PUSH
90207: LD_INT 2
90209: ST_TO_ADDR
// hc_gallery :=  ;
90210: LD_ADDR_OWVAR 33
90214: PUSH
90215: LD_STRING 
90217: ST_TO_ADDR
// hc_name :=  ;
90218: LD_ADDR_OWVAR 26
90222: PUSH
90223: LD_STRING 
90225: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
90226: LD_INT 1
90228: PPUSH
90229: LD_INT 11
90231: PPUSH
90232: LD_INT 10
90234: PPUSH
90235: CALL_OW 380
// un := CreateHuman ;
90239: LD_ADDR_VAR 0 1
90243: PUSH
90244: CALL_OW 44
90248: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
90249: LD_VAR 0 1
90253: PPUSH
90254: LD_INT 1
90256: PPUSH
90257: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
90261: LD_INT 35
90263: PPUSH
90264: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
90268: LD_VAR 0 1
90272: PPUSH
90273: LD_INT 22
90275: PUSH
90276: LD_OWVAR 2
90280: PUSH
90281: EMPTY
90282: LIST
90283: LIST
90284: PPUSH
90285: CALL_OW 69
90289: PPUSH
90290: LD_VAR 0 1
90294: PPUSH
90295: CALL_OW 74
90299: PPUSH
90300: CALL_OW 115
// until IsDead ( un ) ;
90304: LD_VAR 0 1
90308: PPUSH
90309: CALL_OW 301
90313: IFFALSE 90261
// end ;
90315: PPOPN 1
90317: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
90318: LD_EXP 118
90322: PUSH
90323: LD_EXP 158
90327: AND
90328: IFFALSE 90340
90330: GO 90332
90332: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
90333: LD_STRING earthquake(getX(game), 0, 32)
90335: PPUSH
90336: CALL_OW 559
90340: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
90341: LD_EXP 118
90345: PUSH
90346: LD_EXP 159
90350: AND
90351: IFFALSE 90442
90353: GO 90355
90355: DISABLE
90356: LD_INT 0
90358: PPUSH
// begin enable ;
90359: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
90360: LD_ADDR_VAR 0 1
90364: PUSH
90365: LD_INT 22
90367: PUSH
90368: LD_OWVAR 2
90372: PUSH
90373: EMPTY
90374: LIST
90375: LIST
90376: PUSH
90377: LD_INT 21
90379: PUSH
90380: LD_INT 2
90382: PUSH
90383: EMPTY
90384: LIST
90385: LIST
90386: PUSH
90387: LD_INT 33
90389: PUSH
90390: LD_INT 3
90392: PUSH
90393: EMPTY
90394: LIST
90395: LIST
90396: PUSH
90397: EMPTY
90398: LIST
90399: LIST
90400: LIST
90401: PPUSH
90402: CALL_OW 69
90406: ST_TO_ADDR
// if not tmp then
90407: LD_VAR 0 1
90411: NOT
90412: IFFALSE 90416
// exit ;
90414: GO 90442
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
90416: LD_VAR 0 1
90420: PUSH
90421: LD_INT 1
90423: PPUSH
90424: LD_VAR 0 1
90428: PPUSH
90429: CALL_OW 12
90433: ARRAY
90434: PPUSH
90435: LD_INT 1
90437: PPUSH
90438: CALL_OW 234
// end ;
90442: PPOPN 1
90444: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
90445: LD_EXP 118
90449: PUSH
90450: LD_EXP 160
90454: AND
90455: IFFALSE 90596
90457: GO 90459
90459: DISABLE
90460: LD_INT 0
90462: PPUSH
90463: PPUSH
90464: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90465: LD_ADDR_VAR 0 3
90469: PUSH
90470: LD_INT 22
90472: PUSH
90473: LD_OWVAR 2
90477: PUSH
90478: EMPTY
90479: LIST
90480: LIST
90481: PUSH
90482: LD_INT 25
90484: PUSH
90485: LD_INT 1
90487: PUSH
90488: EMPTY
90489: LIST
90490: LIST
90491: PUSH
90492: EMPTY
90493: LIST
90494: LIST
90495: PPUSH
90496: CALL_OW 69
90500: ST_TO_ADDR
// if not tmp then
90501: LD_VAR 0 3
90505: NOT
90506: IFFALSE 90510
// exit ;
90508: GO 90596
// un := tmp [ rand ( 1 , tmp ) ] ;
90510: LD_ADDR_VAR 0 2
90514: PUSH
90515: LD_VAR 0 3
90519: PUSH
90520: LD_INT 1
90522: PPUSH
90523: LD_VAR 0 3
90527: PPUSH
90528: CALL_OW 12
90532: ARRAY
90533: ST_TO_ADDR
// if Crawls ( un ) then
90534: LD_VAR 0 2
90538: PPUSH
90539: CALL_OW 318
90543: IFFALSE 90554
// ComWalk ( un ) ;
90545: LD_VAR 0 2
90549: PPUSH
90550: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
90554: LD_VAR 0 2
90558: PPUSH
90559: LD_INT 9
90561: PPUSH
90562: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
90566: LD_INT 28
90568: PPUSH
90569: LD_OWVAR 2
90573: PPUSH
90574: LD_INT 2
90576: PPUSH
90577: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
90581: LD_INT 29
90583: PPUSH
90584: LD_OWVAR 2
90588: PPUSH
90589: LD_INT 2
90591: PPUSH
90592: CALL_OW 322
// end ;
90596: PPOPN 3
90598: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
90599: LD_EXP 118
90603: PUSH
90604: LD_EXP 161
90608: AND
90609: IFFALSE 90720
90611: GO 90613
90613: DISABLE
90614: LD_INT 0
90616: PPUSH
90617: PPUSH
90618: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90619: LD_ADDR_VAR 0 3
90623: PUSH
90624: LD_INT 22
90626: PUSH
90627: LD_OWVAR 2
90631: PUSH
90632: EMPTY
90633: LIST
90634: LIST
90635: PUSH
90636: LD_INT 25
90638: PUSH
90639: LD_INT 1
90641: PUSH
90642: EMPTY
90643: LIST
90644: LIST
90645: PUSH
90646: EMPTY
90647: LIST
90648: LIST
90649: PPUSH
90650: CALL_OW 69
90654: ST_TO_ADDR
// if not tmp then
90655: LD_VAR 0 3
90659: NOT
90660: IFFALSE 90664
// exit ;
90662: GO 90720
// un := tmp [ rand ( 1 , tmp ) ] ;
90664: LD_ADDR_VAR 0 2
90668: PUSH
90669: LD_VAR 0 3
90673: PUSH
90674: LD_INT 1
90676: PPUSH
90677: LD_VAR 0 3
90681: PPUSH
90682: CALL_OW 12
90686: ARRAY
90687: ST_TO_ADDR
// if Crawls ( un ) then
90688: LD_VAR 0 2
90692: PPUSH
90693: CALL_OW 318
90697: IFFALSE 90708
// ComWalk ( un ) ;
90699: LD_VAR 0 2
90703: PPUSH
90704: CALL_OW 138
// SetClass ( un , class_mortar ) ;
90708: LD_VAR 0 2
90712: PPUSH
90713: LD_INT 8
90715: PPUSH
90716: CALL_OW 336
// end ;
90720: PPOPN 3
90722: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
90723: LD_EXP 118
90727: PUSH
90728: LD_EXP 162
90732: AND
90733: IFFALSE 90877
90735: GO 90737
90737: DISABLE
90738: LD_INT 0
90740: PPUSH
90741: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
90742: LD_ADDR_VAR 0 2
90746: PUSH
90747: LD_INT 22
90749: PUSH
90750: LD_OWVAR 2
90754: PUSH
90755: EMPTY
90756: LIST
90757: LIST
90758: PUSH
90759: LD_INT 21
90761: PUSH
90762: LD_INT 2
90764: PUSH
90765: EMPTY
90766: LIST
90767: LIST
90768: PUSH
90769: LD_INT 2
90771: PUSH
90772: LD_INT 34
90774: PUSH
90775: LD_INT 12
90777: PUSH
90778: EMPTY
90779: LIST
90780: LIST
90781: PUSH
90782: LD_INT 34
90784: PUSH
90785: LD_INT 51
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: LD_INT 34
90794: PUSH
90795: LD_INT 32
90797: PUSH
90798: EMPTY
90799: LIST
90800: LIST
90801: PUSH
90802: EMPTY
90803: LIST
90804: LIST
90805: LIST
90806: LIST
90807: PUSH
90808: EMPTY
90809: LIST
90810: LIST
90811: LIST
90812: PPUSH
90813: CALL_OW 69
90817: ST_TO_ADDR
// if not tmp then
90818: LD_VAR 0 2
90822: NOT
90823: IFFALSE 90827
// exit ;
90825: GO 90877
// for i in tmp do
90827: LD_ADDR_VAR 0 1
90831: PUSH
90832: LD_VAR 0 2
90836: PUSH
90837: FOR_IN
90838: IFFALSE 90875
// if GetCargo ( i , mat_artifact ) = 0 then
90840: LD_VAR 0 1
90844: PPUSH
90845: LD_INT 4
90847: PPUSH
90848: CALL_OW 289
90852: PUSH
90853: LD_INT 0
90855: EQUAL
90856: IFFALSE 90873
// SetCargo ( i , mat_siberit , 100 ) ;
90858: LD_VAR 0 1
90862: PPUSH
90863: LD_INT 3
90865: PPUSH
90866: LD_INT 100
90868: PPUSH
90869: CALL_OW 290
90873: GO 90837
90875: POP
90876: POP
// end ;
90877: PPOPN 2
90879: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
90880: LD_EXP 118
90884: PUSH
90885: LD_EXP 163
90889: AND
90890: IFFALSE 91073
90892: GO 90894
90894: DISABLE
90895: LD_INT 0
90897: PPUSH
90898: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
90899: LD_ADDR_VAR 0 2
90903: PUSH
90904: LD_INT 22
90906: PUSH
90907: LD_OWVAR 2
90911: PUSH
90912: EMPTY
90913: LIST
90914: LIST
90915: PPUSH
90916: CALL_OW 69
90920: ST_TO_ADDR
// if not tmp then
90921: LD_VAR 0 2
90925: NOT
90926: IFFALSE 90930
// exit ;
90928: GO 91073
// for i := 1 to 2 do
90930: LD_ADDR_VAR 0 1
90934: PUSH
90935: DOUBLE
90936: LD_INT 1
90938: DEC
90939: ST_TO_ADDR
90940: LD_INT 2
90942: PUSH
90943: FOR_TO
90944: IFFALSE 91071
// begin uc_side := your_side ;
90946: LD_ADDR_OWVAR 20
90950: PUSH
90951: LD_OWVAR 2
90955: ST_TO_ADDR
// uc_nation := nation_american ;
90956: LD_ADDR_OWVAR 21
90960: PUSH
90961: LD_INT 1
90963: ST_TO_ADDR
// vc_chassis := us_morphling ;
90964: LD_ADDR_OWVAR 37
90968: PUSH
90969: LD_INT 5
90971: ST_TO_ADDR
// vc_engine := engine_siberite ;
90972: LD_ADDR_OWVAR 39
90976: PUSH
90977: LD_INT 3
90979: ST_TO_ADDR
// vc_control := control_computer ;
90980: LD_ADDR_OWVAR 38
90984: PUSH
90985: LD_INT 3
90987: ST_TO_ADDR
// vc_weapon := us_double_laser ;
90988: LD_ADDR_OWVAR 40
90992: PUSH
90993: LD_INT 10
90995: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
90996: LD_VAR 0 2
91000: PUSH
91001: LD_INT 1
91003: ARRAY
91004: PPUSH
91005: CALL_OW 310
91009: NOT
91010: IFFALSE 91057
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
91012: CALL_OW 45
91016: PPUSH
91017: LD_VAR 0 2
91021: PUSH
91022: LD_INT 1
91024: ARRAY
91025: PPUSH
91026: CALL_OW 250
91030: PPUSH
91031: LD_VAR 0 2
91035: PUSH
91036: LD_INT 1
91038: ARRAY
91039: PPUSH
91040: CALL_OW 251
91044: PPUSH
91045: LD_INT 12
91047: PPUSH
91048: LD_INT 1
91050: PPUSH
91051: CALL_OW 50
91055: GO 91069
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
91057: CALL_OW 45
91061: PPUSH
91062: LD_INT 1
91064: PPUSH
91065: CALL_OW 51
// end ;
91069: GO 90943
91071: POP
91072: POP
// end ;
91073: PPOPN 2
91075: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
91076: LD_EXP 118
91080: PUSH
91081: LD_EXP 164
91085: AND
91086: IFFALSE 91308
91088: GO 91090
91090: DISABLE
91091: LD_INT 0
91093: PPUSH
91094: PPUSH
91095: PPUSH
91096: PPUSH
91097: PPUSH
91098: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
91099: LD_ADDR_VAR 0 6
91103: PUSH
91104: LD_INT 22
91106: PUSH
91107: LD_OWVAR 2
91111: PUSH
91112: EMPTY
91113: LIST
91114: LIST
91115: PUSH
91116: LD_INT 21
91118: PUSH
91119: LD_INT 1
91121: PUSH
91122: EMPTY
91123: LIST
91124: LIST
91125: PUSH
91126: LD_INT 3
91128: PUSH
91129: LD_INT 23
91131: PUSH
91132: LD_INT 0
91134: PUSH
91135: EMPTY
91136: LIST
91137: LIST
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PUSH
91143: EMPTY
91144: LIST
91145: LIST
91146: LIST
91147: PPUSH
91148: CALL_OW 69
91152: ST_TO_ADDR
// if not tmp then
91153: LD_VAR 0 6
91157: NOT
91158: IFFALSE 91162
// exit ;
91160: GO 91308
// s1 := rand ( 1 , 4 ) ;
91162: LD_ADDR_VAR 0 2
91166: PUSH
91167: LD_INT 1
91169: PPUSH
91170: LD_INT 4
91172: PPUSH
91173: CALL_OW 12
91177: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
91178: LD_ADDR_VAR 0 4
91182: PUSH
91183: LD_VAR 0 6
91187: PUSH
91188: LD_INT 1
91190: ARRAY
91191: PPUSH
91192: LD_VAR 0 2
91196: PPUSH
91197: CALL_OW 259
91201: ST_TO_ADDR
// if s1 = 1 then
91202: LD_VAR 0 2
91206: PUSH
91207: LD_INT 1
91209: EQUAL
91210: IFFALSE 91230
// s2 := rand ( 2 , 4 ) else
91212: LD_ADDR_VAR 0 3
91216: PUSH
91217: LD_INT 2
91219: PPUSH
91220: LD_INT 4
91222: PPUSH
91223: CALL_OW 12
91227: ST_TO_ADDR
91228: GO 91238
// s2 := 1 ;
91230: LD_ADDR_VAR 0 3
91234: PUSH
91235: LD_INT 1
91237: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
91238: LD_ADDR_VAR 0 5
91242: PUSH
91243: LD_VAR 0 6
91247: PUSH
91248: LD_INT 1
91250: ARRAY
91251: PPUSH
91252: LD_VAR 0 3
91256: PPUSH
91257: CALL_OW 259
91261: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
91262: LD_VAR 0 6
91266: PUSH
91267: LD_INT 1
91269: ARRAY
91270: PPUSH
91271: LD_VAR 0 2
91275: PPUSH
91276: LD_VAR 0 5
91280: PPUSH
91281: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
91285: LD_VAR 0 6
91289: PUSH
91290: LD_INT 1
91292: ARRAY
91293: PPUSH
91294: LD_VAR 0 3
91298: PPUSH
91299: LD_VAR 0 4
91303: PPUSH
91304: CALL_OW 237
// end ;
91308: PPOPN 6
91310: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
91311: LD_EXP 118
91315: PUSH
91316: LD_EXP 165
91320: AND
91321: IFFALSE 91400
91323: GO 91325
91325: DISABLE
91326: LD_INT 0
91328: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
91329: LD_ADDR_VAR 0 1
91333: PUSH
91334: LD_INT 22
91336: PUSH
91337: LD_OWVAR 2
91341: PUSH
91342: EMPTY
91343: LIST
91344: LIST
91345: PUSH
91346: LD_INT 30
91348: PUSH
91349: LD_INT 3
91351: PUSH
91352: EMPTY
91353: LIST
91354: LIST
91355: PUSH
91356: EMPTY
91357: LIST
91358: LIST
91359: PPUSH
91360: CALL_OW 69
91364: ST_TO_ADDR
// if not tmp then
91365: LD_VAR 0 1
91369: NOT
91370: IFFALSE 91374
// exit ;
91372: GO 91400
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
91374: LD_VAR 0 1
91378: PUSH
91379: LD_INT 1
91381: PPUSH
91382: LD_VAR 0 1
91386: PPUSH
91387: CALL_OW 12
91391: ARRAY
91392: PPUSH
91393: LD_INT 1
91395: PPUSH
91396: CALL_OW 234
// end ;
91400: PPOPN 1
91402: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
91403: LD_EXP 118
91407: PUSH
91408: LD_EXP 166
91412: AND
91413: IFFALSE 91525
91415: GO 91417
91417: DISABLE
91418: LD_INT 0
91420: PPUSH
91421: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
91422: LD_ADDR_VAR 0 2
91426: PUSH
91427: LD_INT 22
91429: PUSH
91430: LD_OWVAR 2
91434: PUSH
91435: EMPTY
91436: LIST
91437: LIST
91438: PUSH
91439: LD_INT 2
91441: PUSH
91442: LD_INT 30
91444: PUSH
91445: LD_INT 27
91447: PUSH
91448: EMPTY
91449: LIST
91450: LIST
91451: PUSH
91452: LD_INT 30
91454: PUSH
91455: LD_INT 26
91457: PUSH
91458: EMPTY
91459: LIST
91460: LIST
91461: PUSH
91462: LD_INT 30
91464: PUSH
91465: LD_INT 28
91467: PUSH
91468: EMPTY
91469: LIST
91470: LIST
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: LIST
91476: LIST
91477: PUSH
91478: EMPTY
91479: LIST
91480: LIST
91481: PPUSH
91482: CALL_OW 69
91486: ST_TO_ADDR
// if not tmp then
91487: LD_VAR 0 2
91491: NOT
91492: IFFALSE 91496
// exit ;
91494: GO 91525
// for i in tmp do
91496: LD_ADDR_VAR 0 1
91500: PUSH
91501: LD_VAR 0 2
91505: PUSH
91506: FOR_IN
91507: IFFALSE 91523
// SetLives ( i , 1 ) ;
91509: LD_VAR 0 1
91513: PPUSH
91514: LD_INT 1
91516: PPUSH
91517: CALL_OW 234
91521: GO 91506
91523: POP
91524: POP
// end ;
91525: PPOPN 2
91527: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
91528: LD_EXP 118
91532: PUSH
91533: LD_EXP 167
91537: AND
91538: IFFALSE 91812
91540: GO 91542
91542: DISABLE
91543: LD_INT 0
91545: PPUSH
91546: PPUSH
91547: PPUSH
// begin i := rand ( 1 , 7 ) ;
91548: LD_ADDR_VAR 0 1
91552: PUSH
91553: LD_INT 1
91555: PPUSH
91556: LD_INT 7
91558: PPUSH
91559: CALL_OW 12
91563: ST_TO_ADDR
// case i of 1 :
91564: LD_VAR 0 1
91568: PUSH
91569: LD_INT 1
91571: DOUBLE
91572: EQUAL
91573: IFTRUE 91577
91575: GO 91587
91577: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
91578: LD_STRING earthquake(getX(game), 0, 32)
91580: PPUSH
91581: CALL_OW 559
91585: GO 91812
91587: LD_INT 2
91589: DOUBLE
91590: EQUAL
91591: IFTRUE 91595
91593: GO 91609
91595: POP
// begin ToLua ( displayStucuk(); ) ;
91596: LD_STRING displayStucuk();
91598: PPUSH
91599: CALL_OW 559
// ResetFog ;
91603: CALL_OW 335
// end ; 3 :
91607: GO 91812
91609: LD_INT 3
91611: DOUBLE
91612: EQUAL
91613: IFTRUE 91617
91615: GO 91721
91617: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91618: LD_ADDR_VAR 0 2
91622: PUSH
91623: LD_INT 22
91625: PUSH
91626: LD_OWVAR 2
91630: PUSH
91631: EMPTY
91632: LIST
91633: LIST
91634: PUSH
91635: LD_INT 25
91637: PUSH
91638: LD_INT 1
91640: PUSH
91641: EMPTY
91642: LIST
91643: LIST
91644: PUSH
91645: EMPTY
91646: LIST
91647: LIST
91648: PPUSH
91649: CALL_OW 69
91653: ST_TO_ADDR
// if not tmp then
91654: LD_VAR 0 2
91658: NOT
91659: IFFALSE 91663
// exit ;
91661: GO 91812
// un := tmp [ rand ( 1 , tmp ) ] ;
91663: LD_ADDR_VAR 0 3
91667: PUSH
91668: LD_VAR 0 2
91672: PUSH
91673: LD_INT 1
91675: PPUSH
91676: LD_VAR 0 2
91680: PPUSH
91681: CALL_OW 12
91685: ARRAY
91686: ST_TO_ADDR
// if Crawls ( un ) then
91687: LD_VAR 0 3
91691: PPUSH
91692: CALL_OW 318
91696: IFFALSE 91707
// ComWalk ( un ) ;
91698: LD_VAR 0 3
91702: PPUSH
91703: CALL_OW 138
// SetClass ( un , class_mortar ) ;
91707: LD_VAR 0 3
91711: PPUSH
91712: LD_INT 8
91714: PPUSH
91715: CALL_OW 336
// end ; 4 :
91719: GO 91812
91721: LD_INT 4
91723: DOUBLE
91724: EQUAL
91725: IFTRUE 91729
91727: GO 91790
91729: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
91730: LD_ADDR_VAR 0 2
91734: PUSH
91735: LD_INT 22
91737: PUSH
91738: LD_OWVAR 2
91742: PUSH
91743: EMPTY
91744: LIST
91745: LIST
91746: PUSH
91747: LD_INT 30
91749: PUSH
91750: LD_INT 29
91752: PUSH
91753: EMPTY
91754: LIST
91755: LIST
91756: PUSH
91757: EMPTY
91758: LIST
91759: LIST
91760: PPUSH
91761: CALL_OW 69
91765: ST_TO_ADDR
// if not tmp then
91766: LD_VAR 0 2
91770: NOT
91771: IFFALSE 91775
// exit ;
91773: GO 91812
// DestroyUnit ( tmp [ 1 ] ) ;
91775: LD_VAR 0 2
91779: PUSH
91780: LD_INT 1
91782: ARRAY
91783: PPUSH
91784: CALL_OW 65
// end ; 5 .. 7 :
91788: GO 91812
91790: LD_INT 5
91792: DOUBLE
91793: GREATEREQUAL
91794: IFFALSE 91802
91796: LD_INT 7
91798: DOUBLE
91799: LESSEQUAL
91800: IFTRUE 91804
91802: GO 91811
91804: POP
// StreamSibBomb ; end ;
91805: CALL 88062 0 0
91809: GO 91812
91811: POP
// end ;
91812: PPOPN 3
91814: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
91815: LD_EXP 118
91819: PUSH
91820: LD_EXP 168
91824: AND
91825: IFFALSE 91981
91827: GO 91829
91829: DISABLE
91830: LD_INT 0
91832: PPUSH
91833: PPUSH
91834: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
91835: LD_ADDR_VAR 0 2
91839: PUSH
91840: LD_INT 81
91842: PUSH
91843: LD_OWVAR 2
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: LD_INT 2
91854: PUSH
91855: LD_INT 21
91857: PUSH
91858: LD_INT 1
91860: PUSH
91861: EMPTY
91862: LIST
91863: LIST
91864: PUSH
91865: LD_INT 21
91867: PUSH
91868: LD_INT 2
91870: PUSH
91871: EMPTY
91872: LIST
91873: LIST
91874: PUSH
91875: EMPTY
91876: LIST
91877: LIST
91878: LIST
91879: PUSH
91880: EMPTY
91881: LIST
91882: LIST
91883: PPUSH
91884: CALL_OW 69
91888: ST_TO_ADDR
// if not tmp then
91889: LD_VAR 0 2
91893: NOT
91894: IFFALSE 91898
// exit ;
91896: GO 91981
// p := 0 ;
91898: LD_ADDR_VAR 0 3
91902: PUSH
91903: LD_INT 0
91905: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
91906: LD_INT 35
91908: PPUSH
91909: CALL_OW 67
// p := p + 1 ;
91913: LD_ADDR_VAR 0 3
91917: PUSH
91918: LD_VAR 0 3
91922: PUSH
91923: LD_INT 1
91925: PLUS
91926: ST_TO_ADDR
// for i in tmp do
91927: LD_ADDR_VAR 0 1
91931: PUSH
91932: LD_VAR 0 2
91936: PUSH
91937: FOR_IN
91938: IFFALSE 91969
// if GetLives ( i ) < 1000 then
91940: LD_VAR 0 1
91944: PPUSH
91945: CALL_OW 256
91949: PUSH
91950: LD_INT 1000
91952: LESS
91953: IFFALSE 91967
// SetLives ( i , 1000 ) ;
91955: LD_VAR 0 1
91959: PPUSH
91960: LD_INT 1000
91962: PPUSH
91963: CALL_OW 234
91967: GO 91937
91969: POP
91970: POP
// until p > 20 ;
91971: LD_VAR 0 3
91975: PUSH
91976: LD_INT 20
91978: GREATER
91979: IFFALSE 91906
// end ;
91981: PPOPN 3
91983: END
// every 0 0$1 trigger StreamModeActive and sTime do
91984: LD_EXP 118
91988: PUSH
91989: LD_EXP 169
91993: AND
91994: IFFALSE 92029
91996: GO 91998
91998: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
91999: LD_INT 28
92001: PPUSH
92002: LD_OWVAR 2
92006: PPUSH
92007: LD_INT 2
92009: PPUSH
92010: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
92014: LD_INT 30
92016: PPUSH
92017: LD_OWVAR 2
92021: PPUSH
92022: LD_INT 2
92024: PPUSH
92025: CALL_OW 322
// end ;
92029: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
92030: LD_EXP 118
92034: PUSH
92035: LD_EXP 170
92039: AND
92040: IFFALSE 92161
92042: GO 92044
92044: DISABLE
92045: LD_INT 0
92047: PPUSH
92048: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92049: LD_ADDR_VAR 0 2
92053: PUSH
92054: LD_INT 22
92056: PUSH
92057: LD_OWVAR 2
92061: PUSH
92062: EMPTY
92063: LIST
92064: LIST
92065: PUSH
92066: LD_INT 21
92068: PUSH
92069: LD_INT 1
92071: PUSH
92072: EMPTY
92073: LIST
92074: LIST
92075: PUSH
92076: LD_INT 3
92078: PUSH
92079: LD_INT 23
92081: PUSH
92082: LD_INT 0
92084: PUSH
92085: EMPTY
92086: LIST
92087: LIST
92088: PUSH
92089: EMPTY
92090: LIST
92091: LIST
92092: PUSH
92093: EMPTY
92094: LIST
92095: LIST
92096: LIST
92097: PPUSH
92098: CALL_OW 69
92102: ST_TO_ADDR
// if not tmp then
92103: LD_VAR 0 2
92107: NOT
92108: IFFALSE 92112
// exit ;
92110: GO 92161
// for i in tmp do
92112: LD_ADDR_VAR 0 1
92116: PUSH
92117: LD_VAR 0 2
92121: PUSH
92122: FOR_IN
92123: IFFALSE 92159
// begin if Crawls ( i ) then
92125: LD_VAR 0 1
92129: PPUSH
92130: CALL_OW 318
92134: IFFALSE 92145
// ComWalk ( i ) ;
92136: LD_VAR 0 1
92140: PPUSH
92141: CALL_OW 138
// SetClass ( i , 2 ) ;
92145: LD_VAR 0 1
92149: PPUSH
92150: LD_INT 2
92152: PPUSH
92153: CALL_OW 336
// end ;
92157: GO 92122
92159: POP
92160: POP
// end ;
92161: PPOPN 2
92163: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
92164: LD_EXP 118
92168: PUSH
92169: LD_EXP 171
92173: AND
92174: IFFALSE 92455
92176: GO 92178
92178: DISABLE
92179: LD_INT 0
92181: PPUSH
92182: PPUSH
92183: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
92184: LD_OWVAR 2
92188: PPUSH
92189: LD_INT 9
92191: PPUSH
92192: LD_INT 1
92194: PPUSH
92195: LD_INT 1
92197: PPUSH
92198: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
92202: LD_INT 9
92204: PPUSH
92205: LD_OWVAR 2
92209: PPUSH
92210: CALL_OW 343
// uc_side := 9 ;
92214: LD_ADDR_OWVAR 20
92218: PUSH
92219: LD_INT 9
92221: ST_TO_ADDR
// uc_nation := 2 ;
92222: LD_ADDR_OWVAR 21
92226: PUSH
92227: LD_INT 2
92229: ST_TO_ADDR
// hc_name := Dark Warrior ;
92230: LD_ADDR_OWVAR 26
92234: PUSH
92235: LD_STRING Dark Warrior
92237: ST_TO_ADDR
// hc_gallery :=  ;
92238: LD_ADDR_OWVAR 33
92242: PUSH
92243: LD_STRING 
92245: ST_TO_ADDR
// hc_noskilllimit := true ;
92246: LD_ADDR_OWVAR 76
92250: PUSH
92251: LD_INT 1
92253: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
92254: LD_ADDR_OWVAR 31
92258: PUSH
92259: LD_INT 30
92261: PUSH
92262: LD_INT 30
92264: PUSH
92265: LD_INT 30
92267: PUSH
92268: LD_INT 30
92270: PUSH
92271: EMPTY
92272: LIST
92273: LIST
92274: LIST
92275: LIST
92276: ST_TO_ADDR
// un := CreateHuman ;
92277: LD_ADDR_VAR 0 3
92281: PUSH
92282: CALL_OW 44
92286: ST_TO_ADDR
// hc_noskilllimit := false ;
92287: LD_ADDR_OWVAR 76
92291: PUSH
92292: LD_INT 0
92294: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92295: LD_VAR 0 3
92299: PPUSH
92300: LD_INT 1
92302: PPUSH
92303: CALL_OW 51
// p := 0 ;
92307: LD_ADDR_VAR 0 2
92311: PUSH
92312: LD_INT 0
92314: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
92315: LD_INT 35
92317: PPUSH
92318: CALL_OW 67
// p := p + 1 ;
92322: LD_ADDR_VAR 0 2
92326: PUSH
92327: LD_VAR 0 2
92331: PUSH
92332: LD_INT 1
92334: PLUS
92335: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
92336: LD_VAR 0 3
92340: PPUSH
92341: CALL_OW 256
92345: PUSH
92346: LD_INT 1000
92348: LESS
92349: IFFALSE 92363
// SetLives ( un , 1000 ) ;
92351: LD_VAR 0 3
92355: PPUSH
92356: LD_INT 1000
92358: PPUSH
92359: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
92363: LD_VAR 0 3
92367: PPUSH
92368: LD_INT 81
92370: PUSH
92371: LD_OWVAR 2
92375: PUSH
92376: EMPTY
92377: LIST
92378: LIST
92379: PUSH
92380: LD_INT 91
92382: PUSH
92383: LD_VAR 0 3
92387: PUSH
92388: LD_INT 30
92390: PUSH
92391: EMPTY
92392: LIST
92393: LIST
92394: LIST
92395: PUSH
92396: EMPTY
92397: LIST
92398: LIST
92399: PPUSH
92400: CALL_OW 69
92404: PPUSH
92405: LD_VAR 0 3
92409: PPUSH
92410: CALL_OW 74
92414: PPUSH
92415: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
92419: LD_VAR 0 2
92423: PUSH
92424: LD_INT 60
92426: GREATER
92427: PUSH
92428: LD_VAR 0 3
92432: PPUSH
92433: CALL_OW 301
92437: OR
92438: IFFALSE 92315
// if un then
92440: LD_VAR 0 3
92444: IFFALSE 92455
// RemoveUnit ( un ) ;
92446: LD_VAR 0 3
92450: PPUSH
92451: CALL_OW 64
// end ;
92455: PPOPN 3
92457: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92458: LD_INT 0
92460: PPUSH
// case cmd of 301 :
92461: LD_VAR 0 1
92465: PUSH
92466: LD_INT 301
92468: DOUBLE
92469: EQUAL
92470: IFTRUE 92474
92472: GO 92506
92474: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
92475: LD_VAR 0 6
92479: PPUSH
92480: LD_VAR 0 7
92484: PPUSH
92485: LD_VAR 0 8
92489: PPUSH
92490: LD_VAR 0 4
92494: PPUSH
92495: LD_VAR 0 5
92499: PPUSH
92500: CALL 93707 0 5
92504: GO 92627
92506: LD_INT 302
92508: DOUBLE
92509: EQUAL
92510: IFTRUE 92514
92512: GO 92551
92514: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
92515: LD_VAR 0 6
92519: PPUSH
92520: LD_VAR 0 7
92524: PPUSH
92525: LD_VAR 0 8
92529: PPUSH
92530: LD_VAR 0 9
92534: PPUSH
92535: LD_VAR 0 4
92539: PPUSH
92540: LD_VAR 0 5
92544: PPUSH
92545: CALL 93798 0 6
92549: GO 92627
92551: LD_INT 303
92553: DOUBLE
92554: EQUAL
92555: IFTRUE 92559
92557: GO 92596
92559: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
92560: LD_VAR 0 6
92564: PPUSH
92565: LD_VAR 0 7
92569: PPUSH
92570: LD_VAR 0 8
92574: PPUSH
92575: LD_VAR 0 9
92579: PPUSH
92580: LD_VAR 0 4
92584: PPUSH
92585: LD_VAR 0 5
92589: PPUSH
92590: CALL 92632 0 6
92594: GO 92627
92596: LD_INT 304
92598: DOUBLE
92599: EQUAL
92600: IFTRUE 92604
92602: GO 92626
92604: POP
// hHackTeleport ( unit , x , y ) ; end ;
92605: LD_VAR 0 2
92609: PPUSH
92610: LD_VAR 0 4
92614: PPUSH
92615: LD_VAR 0 5
92619: PPUSH
92620: CALL 94391 0 3
92624: GO 92627
92626: POP
// end ;
92627: LD_VAR 0 12
92631: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
92632: LD_INT 0
92634: PPUSH
92635: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
92636: LD_VAR 0 1
92640: PUSH
92641: LD_INT 1
92643: LESS
92644: PUSH
92645: LD_VAR 0 1
92649: PUSH
92650: LD_INT 3
92652: GREATER
92653: OR
92654: PUSH
92655: LD_VAR 0 5
92659: PPUSH
92660: LD_VAR 0 6
92664: PPUSH
92665: CALL_OW 428
92669: OR
92670: IFFALSE 92674
// exit ;
92672: GO 93394
// uc_side := your_side ;
92674: LD_ADDR_OWVAR 20
92678: PUSH
92679: LD_OWVAR 2
92683: ST_TO_ADDR
// uc_nation := nation ;
92684: LD_ADDR_OWVAR 21
92688: PUSH
92689: LD_VAR 0 1
92693: ST_TO_ADDR
// bc_level = 1 ;
92694: LD_ADDR_OWVAR 43
92698: PUSH
92699: LD_INT 1
92701: ST_TO_ADDR
// case btype of 1 :
92702: LD_VAR 0 2
92706: PUSH
92707: LD_INT 1
92709: DOUBLE
92710: EQUAL
92711: IFTRUE 92715
92713: GO 92726
92715: POP
// bc_type := b_depot ; 2 :
92716: LD_ADDR_OWVAR 42
92720: PUSH
92721: LD_INT 0
92723: ST_TO_ADDR
92724: GO 93338
92726: LD_INT 2
92728: DOUBLE
92729: EQUAL
92730: IFTRUE 92734
92732: GO 92745
92734: POP
// bc_type := b_warehouse ; 3 :
92735: LD_ADDR_OWVAR 42
92739: PUSH
92740: LD_INT 1
92742: ST_TO_ADDR
92743: GO 93338
92745: LD_INT 3
92747: DOUBLE
92748: EQUAL
92749: IFTRUE 92753
92751: GO 92764
92753: POP
// bc_type := b_lab ; 4 .. 9 :
92754: LD_ADDR_OWVAR 42
92758: PUSH
92759: LD_INT 6
92761: ST_TO_ADDR
92762: GO 93338
92764: LD_INT 4
92766: DOUBLE
92767: GREATEREQUAL
92768: IFFALSE 92776
92770: LD_INT 9
92772: DOUBLE
92773: LESSEQUAL
92774: IFTRUE 92778
92776: GO 92830
92778: POP
// begin bc_type := b_lab_half ;
92779: LD_ADDR_OWVAR 42
92783: PUSH
92784: LD_INT 7
92786: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
92787: LD_ADDR_OWVAR 44
92791: PUSH
92792: LD_INT 10
92794: PUSH
92795: LD_INT 11
92797: PUSH
92798: LD_INT 12
92800: PUSH
92801: LD_INT 15
92803: PUSH
92804: LD_INT 14
92806: PUSH
92807: LD_INT 13
92809: PUSH
92810: EMPTY
92811: LIST
92812: LIST
92813: LIST
92814: LIST
92815: LIST
92816: LIST
92817: PUSH
92818: LD_VAR 0 2
92822: PUSH
92823: LD_INT 3
92825: MINUS
92826: ARRAY
92827: ST_TO_ADDR
// end ; 10 .. 13 :
92828: GO 93338
92830: LD_INT 10
92832: DOUBLE
92833: GREATEREQUAL
92834: IFFALSE 92842
92836: LD_INT 13
92838: DOUBLE
92839: LESSEQUAL
92840: IFTRUE 92844
92842: GO 92921
92844: POP
// begin bc_type := b_lab_full ;
92845: LD_ADDR_OWVAR 42
92849: PUSH
92850: LD_INT 8
92852: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
92853: LD_ADDR_OWVAR 44
92857: PUSH
92858: LD_INT 10
92860: PUSH
92861: LD_INT 12
92863: PUSH
92864: LD_INT 14
92866: PUSH
92867: LD_INT 13
92869: PUSH
92870: EMPTY
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: PUSH
92876: LD_VAR 0 2
92880: PUSH
92881: LD_INT 9
92883: MINUS
92884: ARRAY
92885: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
92886: LD_ADDR_OWVAR 45
92890: PUSH
92891: LD_INT 11
92893: PUSH
92894: LD_INT 15
92896: PUSH
92897: LD_INT 12
92899: PUSH
92900: LD_INT 15
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: PUSH
92909: LD_VAR 0 2
92913: PUSH
92914: LD_INT 9
92916: MINUS
92917: ARRAY
92918: ST_TO_ADDR
// end ; 14 :
92919: GO 93338
92921: LD_INT 14
92923: DOUBLE
92924: EQUAL
92925: IFTRUE 92929
92927: GO 92940
92929: POP
// bc_type := b_workshop ; 15 :
92930: LD_ADDR_OWVAR 42
92934: PUSH
92935: LD_INT 2
92937: ST_TO_ADDR
92938: GO 93338
92940: LD_INT 15
92942: DOUBLE
92943: EQUAL
92944: IFTRUE 92948
92946: GO 92959
92948: POP
// bc_type := b_factory ; 16 :
92949: LD_ADDR_OWVAR 42
92953: PUSH
92954: LD_INT 3
92956: ST_TO_ADDR
92957: GO 93338
92959: LD_INT 16
92961: DOUBLE
92962: EQUAL
92963: IFTRUE 92967
92965: GO 92978
92967: POP
// bc_type := b_ext_gun ; 17 :
92968: LD_ADDR_OWVAR 42
92972: PUSH
92973: LD_INT 17
92975: ST_TO_ADDR
92976: GO 93338
92978: LD_INT 17
92980: DOUBLE
92981: EQUAL
92982: IFTRUE 92986
92984: GO 93014
92986: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
92987: LD_ADDR_OWVAR 42
92991: PUSH
92992: LD_INT 19
92994: PUSH
92995: LD_INT 23
92997: PUSH
92998: LD_INT 19
93000: PUSH
93001: EMPTY
93002: LIST
93003: LIST
93004: LIST
93005: PUSH
93006: LD_VAR 0 1
93010: ARRAY
93011: ST_TO_ADDR
93012: GO 93338
93014: LD_INT 18
93016: DOUBLE
93017: EQUAL
93018: IFTRUE 93022
93020: GO 93033
93022: POP
// bc_type := b_ext_radar ; 19 :
93023: LD_ADDR_OWVAR 42
93027: PUSH
93028: LD_INT 20
93030: ST_TO_ADDR
93031: GO 93338
93033: LD_INT 19
93035: DOUBLE
93036: EQUAL
93037: IFTRUE 93041
93039: GO 93052
93041: POP
// bc_type := b_ext_radio ; 20 :
93042: LD_ADDR_OWVAR 42
93046: PUSH
93047: LD_INT 22
93049: ST_TO_ADDR
93050: GO 93338
93052: LD_INT 20
93054: DOUBLE
93055: EQUAL
93056: IFTRUE 93060
93058: GO 93071
93060: POP
// bc_type := b_ext_siberium ; 21 :
93061: LD_ADDR_OWVAR 42
93065: PUSH
93066: LD_INT 21
93068: ST_TO_ADDR
93069: GO 93338
93071: LD_INT 21
93073: DOUBLE
93074: EQUAL
93075: IFTRUE 93079
93077: GO 93090
93079: POP
// bc_type := b_ext_computer ; 22 :
93080: LD_ADDR_OWVAR 42
93084: PUSH
93085: LD_INT 24
93087: ST_TO_ADDR
93088: GO 93338
93090: LD_INT 22
93092: DOUBLE
93093: EQUAL
93094: IFTRUE 93098
93096: GO 93109
93098: POP
// bc_type := b_ext_track ; 23 :
93099: LD_ADDR_OWVAR 42
93103: PUSH
93104: LD_INT 16
93106: ST_TO_ADDR
93107: GO 93338
93109: LD_INT 23
93111: DOUBLE
93112: EQUAL
93113: IFTRUE 93117
93115: GO 93128
93117: POP
// bc_type := b_ext_laser ; 24 :
93118: LD_ADDR_OWVAR 42
93122: PUSH
93123: LD_INT 25
93125: ST_TO_ADDR
93126: GO 93338
93128: LD_INT 24
93130: DOUBLE
93131: EQUAL
93132: IFTRUE 93136
93134: GO 93147
93136: POP
// bc_type := b_control_tower ; 25 :
93137: LD_ADDR_OWVAR 42
93141: PUSH
93142: LD_INT 36
93144: ST_TO_ADDR
93145: GO 93338
93147: LD_INT 25
93149: DOUBLE
93150: EQUAL
93151: IFTRUE 93155
93153: GO 93166
93155: POP
// bc_type := b_breastwork ; 26 :
93156: LD_ADDR_OWVAR 42
93160: PUSH
93161: LD_INT 31
93163: ST_TO_ADDR
93164: GO 93338
93166: LD_INT 26
93168: DOUBLE
93169: EQUAL
93170: IFTRUE 93174
93172: GO 93185
93174: POP
// bc_type := b_bunker ; 27 :
93175: LD_ADDR_OWVAR 42
93179: PUSH
93180: LD_INT 32
93182: ST_TO_ADDR
93183: GO 93338
93185: LD_INT 27
93187: DOUBLE
93188: EQUAL
93189: IFTRUE 93193
93191: GO 93204
93193: POP
// bc_type := b_turret ; 28 :
93194: LD_ADDR_OWVAR 42
93198: PUSH
93199: LD_INT 33
93201: ST_TO_ADDR
93202: GO 93338
93204: LD_INT 28
93206: DOUBLE
93207: EQUAL
93208: IFTRUE 93212
93210: GO 93223
93212: POP
// bc_type := b_armoury ; 29 :
93213: LD_ADDR_OWVAR 42
93217: PUSH
93218: LD_INT 4
93220: ST_TO_ADDR
93221: GO 93338
93223: LD_INT 29
93225: DOUBLE
93226: EQUAL
93227: IFTRUE 93231
93229: GO 93242
93231: POP
// bc_type := b_barracks ; 30 :
93232: LD_ADDR_OWVAR 42
93236: PUSH
93237: LD_INT 5
93239: ST_TO_ADDR
93240: GO 93338
93242: LD_INT 30
93244: DOUBLE
93245: EQUAL
93246: IFTRUE 93250
93248: GO 93261
93250: POP
// bc_type := b_solar_power ; 31 :
93251: LD_ADDR_OWVAR 42
93255: PUSH
93256: LD_INT 27
93258: ST_TO_ADDR
93259: GO 93338
93261: LD_INT 31
93263: DOUBLE
93264: EQUAL
93265: IFTRUE 93269
93267: GO 93280
93269: POP
// bc_type := b_oil_power ; 32 :
93270: LD_ADDR_OWVAR 42
93274: PUSH
93275: LD_INT 26
93277: ST_TO_ADDR
93278: GO 93338
93280: LD_INT 32
93282: DOUBLE
93283: EQUAL
93284: IFTRUE 93288
93286: GO 93299
93288: POP
// bc_type := b_siberite_power ; 33 :
93289: LD_ADDR_OWVAR 42
93293: PUSH
93294: LD_INT 28
93296: ST_TO_ADDR
93297: GO 93338
93299: LD_INT 33
93301: DOUBLE
93302: EQUAL
93303: IFTRUE 93307
93305: GO 93318
93307: POP
// bc_type := b_oil_mine ; 34 :
93308: LD_ADDR_OWVAR 42
93312: PUSH
93313: LD_INT 29
93315: ST_TO_ADDR
93316: GO 93338
93318: LD_INT 34
93320: DOUBLE
93321: EQUAL
93322: IFTRUE 93326
93324: GO 93337
93326: POP
// bc_type := b_siberite_mine ; end ;
93327: LD_ADDR_OWVAR 42
93331: PUSH
93332: LD_INT 30
93334: ST_TO_ADDR
93335: GO 93338
93337: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
93338: LD_ADDR_VAR 0 8
93342: PUSH
93343: LD_VAR 0 5
93347: PPUSH
93348: LD_VAR 0 6
93352: PPUSH
93353: LD_VAR 0 3
93357: PPUSH
93358: CALL_OW 47
93362: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
93363: LD_OWVAR 42
93367: PUSH
93368: LD_INT 32
93370: PUSH
93371: LD_INT 33
93373: PUSH
93374: EMPTY
93375: LIST
93376: LIST
93377: IN
93378: IFFALSE 93394
// PlaceWeaponTurret ( b , weapon ) ;
93380: LD_VAR 0 8
93384: PPUSH
93385: LD_VAR 0 4
93389: PPUSH
93390: CALL_OW 431
// end ;
93394: LD_VAR 0 7
93398: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
93399: LD_INT 0
93401: PPUSH
93402: PPUSH
93403: PPUSH
93404: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93405: LD_ADDR_VAR 0 4
93409: PUSH
93410: LD_INT 22
93412: PUSH
93413: LD_OWVAR 2
93417: PUSH
93418: EMPTY
93419: LIST
93420: LIST
93421: PUSH
93422: LD_INT 2
93424: PUSH
93425: LD_INT 30
93427: PUSH
93428: LD_INT 0
93430: PUSH
93431: EMPTY
93432: LIST
93433: LIST
93434: PUSH
93435: LD_INT 30
93437: PUSH
93438: LD_INT 1
93440: PUSH
93441: EMPTY
93442: LIST
93443: LIST
93444: PUSH
93445: EMPTY
93446: LIST
93447: LIST
93448: LIST
93449: PUSH
93450: EMPTY
93451: LIST
93452: LIST
93453: PPUSH
93454: CALL_OW 69
93458: ST_TO_ADDR
// if not tmp then
93459: LD_VAR 0 4
93463: NOT
93464: IFFALSE 93468
// exit ;
93466: GO 93527
// for i in tmp do
93468: LD_ADDR_VAR 0 2
93472: PUSH
93473: LD_VAR 0 4
93477: PUSH
93478: FOR_IN
93479: IFFALSE 93525
// for j = 1 to 3 do
93481: LD_ADDR_VAR 0 3
93485: PUSH
93486: DOUBLE
93487: LD_INT 1
93489: DEC
93490: ST_TO_ADDR
93491: LD_INT 3
93493: PUSH
93494: FOR_TO
93495: IFFALSE 93521
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
93497: LD_VAR 0 2
93501: PPUSH
93502: CALL_OW 274
93506: PPUSH
93507: LD_VAR 0 3
93511: PPUSH
93512: LD_INT 99999
93514: PPUSH
93515: CALL_OW 277
93519: GO 93494
93521: POP
93522: POP
93523: GO 93478
93525: POP
93526: POP
// end ;
93527: LD_VAR 0 1
93531: RET
// export function hHackSetLevel10 ; var i , j ; begin
93532: LD_INT 0
93534: PPUSH
93535: PPUSH
93536: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
93537: LD_ADDR_VAR 0 2
93541: PUSH
93542: LD_INT 21
93544: PUSH
93545: LD_INT 1
93547: PUSH
93548: EMPTY
93549: LIST
93550: LIST
93551: PPUSH
93552: CALL_OW 69
93556: PUSH
93557: FOR_IN
93558: IFFALSE 93610
// if IsSelected ( i ) then
93560: LD_VAR 0 2
93564: PPUSH
93565: CALL_OW 306
93569: IFFALSE 93608
// begin for j := 1 to 4 do
93571: LD_ADDR_VAR 0 3
93575: PUSH
93576: DOUBLE
93577: LD_INT 1
93579: DEC
93580: ST_TO_ADDR
93581: LD_INT 4
93583: PUSH
93584: FOR_TO
93585: IFFALSE 93606
// SetSkill ( i , j , 10 ) ;
93587: LD_VAR 0 2
93591: PPUSH
93592: LD_VAR 0 3
93596: PPUSH
93597: LD_INT 10
93599: PPUSH
93600: CALL_OW 237
93604: GO 93584
93606: POP
93607: POP
// end ;
93608: GO 93557
93610: POP
93611: POP
// end ;
93612: LD_VAR 0 1
93616: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
93617: LD_INT 0
93619: PPUSH
93620: PPUSH
93621: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
93622: LD_ADDR_VAR 0 2
93626: PUSH
93627: LD_INT 22
93629: PUSH
93630: LD_OWVAR 2
93634: PUSH
93635: EMPTY
93636: LIST
93637: LIST
93638: PUSH
93639: LD_INT 21
93641: PUSH
93642: LD_INT 1
93644: PUSH
93645: EMPTY
93646: LIST
93647: LIST
93648: PUSH
93649: EMPTY
93650: LIST
93651: LIST
93652: PPUSH
93653: CALL_OW 69
93657: PUSH
93658: FOR_IN
93659: IFFALSE 93700
// begin for j := 1 to 4 do
93661: LD_ADDR_VAR 0 3
93665: PUSH
93666: DOUBLE
93667: LD_INT 1
93669: DEC
93670: ST_TO_ADDR
93671: LD_INT 4
93673: PUSH
93674: FOR_TO
93675: IFFALSE 93696
// SetSkill ( i , j , 10 ) ;
93677: LD_VAR 0 2
93681: PPUSH
93682: LD_VAR 0 3
93686: PPUSH
93687: LD_INT 10
93689: PPUSH
93690: CALL_OW 237
93694: GO 93674
93696: POP
93697: POP
// end ;
93698: GO 93658
93700: POP
93701: POP
// end ;
93702: LD_VAR 0 1
93706: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
93707: LD_INT 0
93709: PPUSH
// uc_side := your_side ;
93710: LD_ADDR_OWVAR 20
93714: PUSH
93715: LD_OWVAR 2
93719: ST_TO_ADDR
// uc_nation := nation ;
93720: LD_ADDR_OWVAR 21
93724: PUSH
93725: LD_VAR 0 1
93729: ST_TO_ADDR
// InitHc ;
93730: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
93734: LD_INT 0
93736: PPUSH
93737: LD_VAR 0 2
93741: PPUSH
93742: LD_VAR 0 3
93746: PPUSH
93747: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
93751: LD_VAR 0 4
93755: PPUSH
93756: LD_VAR 0 5
93760: PPUSH
93761: CALL_OW 428
93765: PUSH
93766: LD_INT 0
93768: EQUAL
93769: IFFALSE 93793
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
93771: CALL_OW 44
93775: PPUSH
93776: LD_VAR 0 4
93780: PPUSH
93781: LD_VAR 0 5
93785: PPUSH
93786: LD_INT 1
93788: PPUSH
93789: CALL_OW 48
// end ;
93793: LD_VAR 0 6
93797: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
93798: LD_INT 0
93800: PPUSH
93801: PPUSH
// uc_side := your_side ;
93802: LD_ADDR_OWVAR 20
93806: PUSH
93807: LD_OWVAR 2
93811: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
93812: LD_VAR 0 1
93816: PUSH
93817: LD_INT 1
93819: PUSH
93820: LD_INT 2
93822: PUSH
93823: LD_INT 3
93825: PUSH
93826: LD_INT 4
93828: PUSH
93829: LD_INT 5
93831: PUSH
93832: EMPTY
93833: LIST
93834: LIST
93835: LIST
93836: LIST
93837: LIST
93838: IN
93839: IFFALSE 93851
// uc_nation := nation_american else
93841: LD_ADDR_OWVAR 21
93845: PUSH
93846: LD_INT 1
93848: ST_TO_ADDR
93849: GO 93894
// if chassis in [ 11 , 12 , 13 , 14 ] then
93851: LD_VAR 0 1
93855: PUSH
93856: LD_INT 11
93858: PUSH
93859: LD_INT 12
93861: PUSH
93862: LD_INT 13
93864: PUSH
93865: LD_INT 14
93867: PUSH
93868: EMPTY
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: IN
93874: IFFALSE 93886
// uc_nation := nation_arabian else
93876: LD_ADDR_OWVAR 21
93880: PUSH
93881: LD_INT 2
93883: ST_TO_ADDR
93884: GO 93894
// uc_nation := nation_russian ;
93886: LD_ADDR_OWVAR 21
93890: PUSH
93891: LD_INT 3
93893: ST_TO_ADDR
// vc_chassis := chassis ;
93894: LD_ADDR_OWVAR 37
93898: PUSH
93899: LD_VAR 0 1
93903: ST_TO_ADDR
// vc_engine := engine ;
93904: LD_ADDR_OWVAR 39
93908: PUSH
93909: LD_VAR 0 2
93913: ST_TO_ADDR
// vc_control := control ;
93914: LD_ADDR_OWVAR 38
93918: PUSH
93919: LD_VAR 0 3
93923: ST_TO_ADDR
// vc_weapon := weapon ;
93924: LD_ADDR_OWVAR 40
93928: PUSH
93929: LD_VAR 0 4
93933: ST_TO_ADDR
// un := CreateVehicle ;
93934: LD_ADDR_VAR 0 8
93938: PUSH
93939: CALL_OW 45
93943: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
93944: LD_VAR 0 8
93948: PPUSH
93949: LD_INT 0
93951: PPUSH
93952: LD_INT 5
93954: PPUSH
93955: CALL_OW 12
93959: PPUSH
93960: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
93964: LD_VAR 0 8
93968: PPUSH
93969: LD_VAR 0 5
93973: PPUSH
93974: LD_VAR 0 6
93978: PPUSH
93979: LD_INT 1
93981: PPUSH
93982: CALL_OW 48
// end ;
93986: LD_VAR 0 7
93990: RET
// export hInvincible ; every 1 do
93991: GO 93993
93993: DISABLE
// hInvincible := [ ] ;
93994: LD_ADDR_EXP 172
93998: PUSH
93999: EMPTY
94000: ST_TO_ADDR
94001: END
// every 10 do var i ;
94002: GO 94004
94004: DISABLE
94005: LD_INT 0
94007: PPUSH
// begin enable ;
94008: ENABLE
// if not hInvincible then
94009: LD_EXP 172
94013: NOT
94014: IFFALSE 94018
// exit ;
94016: GO 94062
// for i in hInvincible do
94018: LD_ADDR_VAR 0 1
94022: PUSH
94023: LD_EXP 172
94027: PUSH
94028: FOR_IN
94029: IFFALSE 94060
// if GetLives ( i ) < 1000 then
94031: LD_VAR 0 1
94035: PPUSH
94036: CALL_OW 256
94040: PUSH
94041: LD_INT 1000
94043: LESS
94044: IFFALSE 94058
// SetLives ( i , 1000 ) ;
94046: LD_VAR 0 1
94050: PPUSH
94051: LD_INT 1000
94053: PPUSH
94054: CALL_OW 234
94058: GO 94028
94060: POP
94061: POP
// end ;
94062: PPOPN 1
94064: END
// export function hHackInvincible ; var i ; begin
94065: LD_INT 0
94067: PPUSH
94068: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
94069: LD_ADDR_VAR 0 2
94073: PUSH
94074: LD_INT 2
94076: PUSH
94077: LD_INT 21
94079: PUSH
94080: LD_INT 1
94082: PUSH
94083: EMPTY
94084: LIST
94085: LIST
94086: PUSH
94087: LD_INT 21
94089: PUSH
94090: LD_INT 2
94092: PUSH
94093: EMPTY
94094: LIST
94095: LIST
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: LIST
94101: PPUSH
94102: CALL_OW 69
94106: PUSH
94107: FOR_IN
94108: IFFALSE 94169
// if IsSelected ( i ) then
94110: LD_VAR 0 2
94114: PPUSH
94115: CALL_OW 306
94119: IFFALSE 94167
// begin if i in hInvincible then
94121: LD_VAR 0 2
94125: PUSH
94126: LD_EXP 172
94130: IN
94131: IFFALSE 94151
// hInvincible := hInvincible diff i else
94133: LD_ADDR_EXP 172
94137: PUSH
94138: LD_EXP 172
94142: PUSH
94143: LD_VAR 0 2
94147: DIFF
94148: ST_TO_ADDR
94149: GO 94167
// hInvincible := hInvincible union i ;
94151: LD_ADDR_EXP 172
94155: PUSH
94156: LD_EXP 172
94160: PUSH
94161: LD_VAR 0 2
94165: UNION
94166: ST_TO_ADDR
// end ;
94167: GO 94107
94169: POP
94170: POP
// end ;
94171: LD_VAR 0 1
94175: RET
// export function hHackInvisible ; var i , j ; begin
94176: LD_INT 0
94178: PPUSH
94179: PPUSH
94180: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
94181: LD_ADDR_VAR 0 2
94185: PUSH
94186: LD_INT 21
94188: PUSH
94189: LD_INT 1
94191: PUSH
94192: EMPTY
94193: LIST
94194: LIST
94195: PPUSH
94196: CALL_OW 69
94200: PUSH
94201: FOR_IN
94202: IFFALSE 94226
// if IsSelected ( i ) then
94204: LD_VAR 0 2
94208: PPUSH
94209: CALL_OW 306
94213: IFFALSE 94224
// ComForceInvisible ( i ) ;
94215: LD_VAR 0 2
94219: PPUSH
94220: CALL_OW 496
94224: GO 94201
94226: POP
94227: POP
// end ;
94228: LD_VAR 0 1
94232: RET
// export function hHackChangeYourSide ; begin
94233: LD_INT 0
94235: PPUSH
// if your_side = 8 then
94236: LD_OWVAR 2
94240: PUSH
94241: LD_INT 8
94243: EQUAL
94244: IFFALSE 94256
// your_side := 0 else
94246: LD_ADDR_OWVAR 2
94250: PUSH
94251: LD_INT 0
94253: ST_TO_ADDR
94254: GO 94270
// your_side := your_side + 1 ;
94256: LD_ADDR_OWVAR 2
94260: PUSH
94261: LD_OWVAR 2
94265: PUSH
94266: LD_INT 1
94268: PLUS
94269: ST_TO_ADDR
// end ;
94270: LD_VAR 0 1
94274: RET
// export function hHackChangeUnitSide ; var i , j ; begin
94275: LD_INT 0
94277: PPUSH
94278: PPUSH
94279: PPUSH
// for i in all_units do
94280: LD_ADDR_VAR 0 2
94284: PUSH
94285: LD_OWVAR 3
94289: PUSH
94290: FOR_IN
94291: IFFALSE 94369
// if IsSelected ( i ) then
94293: LD_VAR 0 2
94297: PPUSH
94298: CALL_OW 306
94302: IFFALSE 94367
// begin j := GetSide ( i ) ;
94304: LD_ADDR_VAR 0 3
94308: PUSH
94309: LD_VAR 0 2
94313: PPUSH
94314: CALL_OW 255
94318: ST_TO_ADDR
// if j = 8 then
94319: LD_VAR 0 3
94323: PUSH
94324: LD_INT 8
94326: EQUAL
94327: IFFALSE 94339
// j := 0 else
94329: LD_ADDR_VAR 0 3
94333: PUSH
94334: LD_INT 0
94336: ST_TO_ADDR
94337: GO 94353
// j := j + 1 ;
94339: LD_ADDR_VAR 0 3
94343: PUSH
94344: LD_VAR 0 3
94348: PUSH
94349: LD_INT 1
94351: PLUS
94352: ST_TO_ADDR
// SetSide ( i , j ) ;
94353: LD_VAR 0 2
94357: PPUSH
94358: LD_VAR 0 3
94362: PPUSH
94363: CALL_OW 235
// end ;
94367: GO 94290
94369: POP
94370: POP
// end ;
94371: LD_VAR 0 1
94375: RET
// export function hHackFog ; begin
94376: LD_INT 0
94378: PPUSH
// FogOff ( true ) ;
94379: LD_INT 1
94381: PPUSH
94382: CALL_OW 344
// end ;
94386: LD_VAR 0 1
94390: RET
// export function hHackTeleport ( unit , x , y ) ; begin
94391: LD_INT 0
94393: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
94394: LD_VAR 0 1
94398: PPUSH
94399: LD_VAR 0 2
94403: PPUSH
94404: LD_VAR 0 3
94408: PPUSH
94409: LD_INT 1
94411: PPUSH
94412: LD_INT 1
94414: PPUSH
94415: CALL_OW 483
// CenterOnXY ( x , y ) ;
94419: LD_VAR 0 2
94423: PPUSH
94424: LD_VAR 0 3
94428: PPUSH
94429: CALL_OW 84
// end ; end_of_file
94433: LD_VAR 0 4
94437: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
94438: LD_INT 0
94440: PPUSH
94441: PPUSH
94442: PPUSH
94443: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
94444: LD_VAR 0 1
94448: PPUSH
94449: CALL_OW 264
94453: PUSH
94454: LD_EXP 106
94458: EQUAL
94459: IFFALSE 94531
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
94461: LD_INT 68
94463: PPUSH
94464: LD_VAR 0 1
94468: PPUSH
94469: CALL_OW 255
94473: PPUSH
94474: CALL_OW 321
94478: PUSH
94479: LD_INT 2
94481: EQUAL
94482: IFFALSE 94494
// eff := 70 else
94484: LD_ADDR_VAR 0 4
94488: PUSH
94489: LD_INT 70
94491: ST_TO_ADDR
94492: GO 94502
// eff := 30 ;
94494: LD_ADDR_VAR 0 4
94498: PUSH
94499: LD_INT 30
94501: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
94502: LD_VAR 0 1
94506: PPUSH
94507: CALL_OW 250
94511: PPUSH
94512: LD_VAR 0 1
94516: PPUSH
94517: CALL_OW 251
94521: PPUSH
94522: LD_VAR 0 4
94526: PPUSH
94527: CALL_OW 495
// end ; end ;
94531: LD_VAR 0 2
94535: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
94536: LD_INT 0
94538: PPUSH
// end ;
94539: LD_VAR 0 4
94543: RET
// export function SOS_Command ( cmd ) ; begin
94544: LD_INT 0
94546: PPUSH
// end ;
94547: LD_VAR 0 2
94551: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
94552: LD_INT 0
94554: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
94555: LD_VAR 0 1
94559: PUSH
94560: LD_INT 250
94562: EQUAL
94563: PUSH
94564: LD_VAR 0 2
94568: PPUSH
94569: CALL_OW 264
94573: PUSH
94574: LD_EXP 109
94578: EQUAL
94579: AND
94580: IFFALSE 94601
// MinerPlaceMine ( unit , x , y ) ;
94582: LD_VAR 0 2
94586: PPUSH
94587: LD_VAR 0 4
94591: PPUSH
94592: LD_VAR 0 5
94596: PPUSH
94597: CALL 96942 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
94601: LD_VAR 0 1
94605: PUSH
94606: LD_INT 251
94608: EQUAL
94609: PUSH
94610: LD_VAR 0 2
94614: PPUSH
94615: CALL_OW 264
94619: PUSH
94620: LD_EXP 109
94624: EQUAL
94625: AND
94626: IFFALSE 94647
// MinerDetonateMine ( unit , x , y ) ;
94628: LD_VAR 0 2
94632: PPUSH
94633: LD_VAR 0 4
94637: PPUSH
94638: LD_VAR 0 5
94642: PPUSH
94643: CALL 97219 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
94647: LD_VAR 0 1
94651: PUSH
94652: LD_INT 252
94654: EQUAL
94655: PUSH
94656: LD_VAR 0 2
94660: PPUSH
94661: CALL_OW 264
94665: PUSH
94666: LD_EXP 109
94670: EQUAL
94671: AND
94672: IFFALSE 94693
// MinerCreateMinefield ( unit , x , y ) ;
94674: LD_VAR 0 2
94678: PPUSH
94679: LD_VAR 0 4
94683: PPUSH
94684: LD_VAR 0 5
94688: PPUSH
94689: CALL 97636 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
94693: LD_VAR 0 1
94697: PUSH
94698: LD_INT 253
94700: EQUAL
94701: PUSH
94702: LD_VAR 0 2
94706: PPUSH
94707: CALL_OW 257
94711: PUSH
94712: LD_INT 5
94714: EQUAL
94715: AND
94716: IFFALSE 94737
// ComBinocular ( unit , x , y ) ;
94718: LD_VAR 0 2
94722: PPUSH
94723: LD_VAR 0 4
94727: PPUSH
94728: LD_VAR 0 5
94732: PPUSH
94733: CALL 98007 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
94737: LD_VAR 0 1
94741: PUSH
94742: LD_INT 254
94744: EQUAL
94745: PUSH
94746: LD_VAR 0 2
94750: PPUSH
94751: CALL_OW 264
94755: PUSH
94756: LD_EXP 104
94760: EQUAL
94761: AND
94762: PUSH
94763: LD_VAR 0 3
94767: PPUSH
94768: CALL_OW 263
94772: PUSH
94773: LD_INT 3
94775: EQUAL
94776: AND
94777: IFFALSE 94793
// HackDestroyVehicle ( unit , selectedUnit ) ;
94779: LD_VAR 0 2
94783: PPUSH
94784: LD_VAR 0 3
94788: PPUSH
94789: CALL 96302 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
94793: LD_VAR 0 1
94797: PUSH
94798: LD_INT 255
94800: EQUAL
94801: PUSH
94802: LD_VAR 0 2
94806: PPUSH
94807: CALL_OW 264
94811: PUSH
94812: LD_INT 14
94814: PUSH
94815: LD_INT 53
94817: PUSH
94818: EMPTY
94819: LIST
94820: LIST
94821: IN
94822: AND
94823: PUSH
94824: LD_VAR 0 4
94828: PPUSH
94829: LD_VAR 0 5
94833: PPUSH
94834: CALL_OW 488
94838: AND
94839: IFFALSE 94863
// CutTreeXYR ( unit , x , y , 12 ) ;
94841: LD_VAR 0 2
94845: PPUSH
94846: LD_VAR 0 4
94850: PPUSH
94851: LD_VAR 0 5
94855: PPUSH
94856: LD_INT 12
94858: PPUSH
94859: CALL 94868 0 4
// end ;
94863: LD_VAR 0 6
94867: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
94868: LD_INT 0
94870: PPUSH
94871: PPUSH
94872: PPUSH
94873: PPUSH
94874: PPUSH
94875: PPUSH
94876: PPUSH
94877: PPUSH
94878: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
94879: LD_VAR 0 1
94883: NOT
94884: PUSH
94885: LD_VAR 0 2
94889: PPUSH
94890: LD_VAR 0 3
94894: PPUSH
94895: CALL_OW 488
94899: NOT
94900: OR
94901: PUSH
94902: LD_VAR 0 4
94906: NOT
94907: OR
94908: IFFALSE 94912
// exit ;
94910: GO 95252
// list := [ ] ;
94912: LD_ADDR_VAR 0 13
94916: PUSH
94917: EMPTY
94918: ST_TO_ADDR
// if x - r < 0 then
94919: LD_VAR 0 2
94923: PUSH
94924: LD_VAR 0 4
94928: MINUS
94929: PUSH
94930: LD_INT 0
94932: LESS
94933: IFFALSE 94945
// min_x := 0 else
94935: LD_ADDR_VAR 0 7
94939: PUSH
94940: LD_INT 0
94942: ST_TO_ADDR
94943: GO 94961
// min_x := x - r ;
94945: LD_ADDR_VAR 0 7
94949: PUSH
94950: LD_VAR 0 2
94954: PUSH
94955: LD_VAR 0 4
94959: MINUS
94960: ST_TO_ADDR
// if y - r < 0 then
94961: LD_VAR 0 3
94965: PUSH
94966: LD_VAR 0 4
94970: MINUS
94971: PUSH
94972: LD_INT 0
94974: LESS
94975: IFFALSE 94987
// min_y := 0 else
94977: LD_ADDR_VAR 0 8
94981: PUSH
94982: LD_INT 0
94984: ST_TO_ADDR
94985: GO 95003
// min_y := y - r ;
94987: LD_ADDR_VAR 0 8
94991: PUSH
94992: LD_VAR 0 3
94996: PUSH
94997: LD_VAR 0 4
95001: MINUS
95002: ST_TO_ADDR
// max_x := x + r ;
95003: LD_ADDR_VAR 0 9
95007: PUSH
95008: LD_VAR 0 2
95012: PUSH
95013: LD_VAR 0 4
95017: PLUS
95018: ST_TO_ADDR
// max_y := y + r ;
95019: LD_ADDR_VAR 0 10
95023: PUSH
95024: LD_VAR 0 3
95028: PUSH
95029: LD_VAR 0 4
95033: PLUS
95034: ST_TO_ADDR
// for _x = min_x to max_x do
95035: LD_ADDR_VAR 0 11
95039: PUSH
95040: DOUBLE
95041: LD_VAR 0 7
95045: DEC
95046: ST_TO_ADDR
95047: LD_VAR 0 9
95051: PUSH
95052: FOR_TO
95053: IFFALSE 95170
// for _y = min_y to max_y do
95055: LD_ADDR_VAR 0 12
95059: PUSH
95060: DOUBLE
95061: LD_VAR 0 8
95065: DEC
95066: ST_TO_ADDR
95067: LD_VAR 0 10
95071: PUSH
95072: FOR_TO
95073: IFFALSE 95166
// begin if not ValidHex ( _x , _y ) then
95075: LD_VAR 0 11
95079: PPUSH
95080: LD_VAR 0 12
95084: PPUSH
95085: CALL_OW 488
95089: NOT
95090: IFFALSE 95094
// continue ;
95092: GO 95072
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
95094: LD_VAR 0 11
95098: PPUSH
95099: LD_VAR 0 12
95103: PPUSH
95104: CALL_OW 351
95108: PUSH
95109: LD_VAR 0 11
95113: PPUSH
95114: LD_VAR 0 12
95118: PPUSH
95119: CALL_OW 554
95123: AND
95124: IFFALSE 95164
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
95126: LD_ADDR_VAR 0 13
95130: PUSH
95131: LD_VAR 0 13
95135: PPUSH
95136: LD_VAR 0 13
95140: PUSH
95141: LD_INT 1
95143: PLUS
95144: PPUSH
95145: LD_VAR 0 11
95149: PUSH
95150: LD_VAR 0 12
95154: PUSH
95155: EMPTY
95156: LIST
95157: LIST
95158: PPUSH
95159: CALL_OW 2
95163: ST_TO_ADDR
// end ;
95164: GO 95072
95166: POP
95167: POP
95168: GO 95052
95170: POP
95171: POP
// if not list then
95172: LD_VAR 0 13
95176: NOT
95177: IFFALSE 95181
// exit ;
95179: GO 95252
// for i in list do
95181: LD_ADDR_VAR 0 6
95185: PUSH
95186: LD_VAR 0 13
95190: PUSH
95191: FOR_IN
95192: IFFALSE 95250
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
95194: LD_VAR 0 1
95198: PPUSH
95199: LD_STRING M
95201: PUSH
95202: LD_VAR 0 6
95206: PUSH
95207: LD_INT 1
95209: ARRAY
95210: PUSH
95211: LD_VAR 0 6
95215: PUSH
95216: LD_INT 2
95218: ARRAY
95219: PUSH
95220: LD_INT 0
95222: PUSH
95223: LD_INT 0
95225: PUSH
95226: LD_INT 0
95228: PUSH
95229: LD_INT 0
95231: PUSH
95232: EMPTY
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: PUSH
95241: EMPTY
95242: LIST
95243: PPUSH
95244: CALL_OW 447
95248: GO 95191
95250: POP
95251: POP
// end ;
95252: LD_VAR 0 5
95256: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
95257: LD_EXP 173
95261: NOT
95262: IFFALSE 95312
95264: GO 95266
95266: DISABLE
// begin initHack := true ;
95267: LD_ADDR_EXP 173
95271: PUSH
95272: LD_INT 1
95274: ST_TO_ADDR
// hackTanks := [ ] ;
95275: LD_ADDR_EXP 174
95279: PUSH
95280: EMPTY
95281: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
95282: LD_ADDR_EXP 175
95286: PUSH
95287: EMPTY
95288: ST_TO_ADDR
// hackLimit := 3 ;
95289: LD_ADDR_EXP 176
95293: PUSH
95294: LD_INT 3
95296: ST_TO_ADDR
// hackDist := 12 ;
95297: LD_ADDR_EXP 177
95301: PUSH
95302: LD_INT 12
95304: ST_TO_ADDR
// hackCounter := [ ] ;
95305: LD_ADDR_EXP 178
95309: PUSH
95310: EMPTY
95311: ST_TO_ADDR
// end ;
95312: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
95313: LD_EXP 173
95317: PUSH
95318: LD_INT 34
95320: PUSH
95321: LD_EXP 104
95325: PUSH
95326: EMPTY
95327: LIST
95328: LIST
95329: PPUSH
95330: CALL_OW 69
95334: AND
95335: IFFALSE 95590
95337: GO 95339
95339: DISABLE
95340: LD_INT 0
95342: PPUSH
95343: PPUSH
// begin enable ;
95344: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
95345: LD_ADDR_VAR 0 1
95349: PUSH
95350: LD_INT 34
95352: PUSH
95353: LD_EXP 104
95357: PUSH
95358: EMPTY
95359: LIST
95360: LIST
95361: PPUSH
95362: CALL_OW 69
95366: PUSH
95367: FOR_IN
95368: IFFALSE 95588
// begin if not i in hackTanks then
95370: LD_VAR 0 1
95374: PUSH
95375: LD_EXP 174
95379: IN
95380: NOT
95381: IFFALSE 95464
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
95383: LD_ADDR_EXP 174
95387: PUSH
95388: LD_EXP 174
95392: PPUSH
95393: LD_EXP 174
95397: PUSH
95398: LD_INT 1
95400: PLUS
95401: PPUSH
95402: LD_VAR 0 1
95406: PPUSH
95407: CALL_OW 1
95411: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
95412: LD_ADDR_EXP 175
95416: PUSH
95417: LD_EXP 175
95421: PPUSH
95422: LD_EXP 175
95426: PUSH
95427: LD_INT 1
95429: PLUS
95430: PPUSH
95431: EMPTY
95432: PPUSH
95433: CALL_OW 1
95437: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
95438: LD_ADDR_EXP 178
95442: PUSH
95443: LD_EXP 178
95447: PPUSH
95448: LD_EXP 178
95452: PUSH
95453: LD_INT 1
95455: PLUS
95456: PPUSH
95457: EMPTY
95458: PPUSH
95459: CALL_OW 1
95463: ST_TO_ADDR
// end ; if not IsOk ( i ) then
95464: LD_VAR 0 1
95468: PPUSH
95469: CALL_OW 302
95473: NOT
95474: IFFALSE 95487
// begin HackUnlinkAll ( i ) ;
95476: LD_VAR 0 1
95480: PPUSH
95481: CALL 95593 0 1
// continue ;
95485: GO 95367
// end ; HackCheckCapturedStatus ( i ) ;
95487: LD_VAR 0 1
95491: PPUSH
95492: CALL 96036 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
95496: LD_ADDR_VAR 0 2
95500: PUSH
95501: LD_INT 81
95503: PUSH
95504: LD_VAR 0 1
95508: PPUSH
95509: CALL_OW 255
95513: PUSH
95514: EMPTY
95515: LIST
95516: LIST
95517: PUSH
95518: LD_INT 33
95520: PUSH
95521: LD_INT 3
95523: PUSH
95524: EMPTY
95525: LIST
95526: LIST
95527: PUSH
95528: LD_INT 91
95530: PUSH
95531: LD_VAR 0 1
95535: PUSH
95536: LD_EXP 177
95540: PUSH
95541: EMPTY
95542: LIST
95543: LIST
95544: LIST
95545: PUSH
95546: LD_INT 50
95548: PUSH
95549: EMPTY
95550: LIST
95551: PUSH
95552: EMPTY
95553: LIST
95554: LIST
95555: LIST
95556: LIST
95557: PPUSH
95558: CALL_OW 69
95562: ST_TO_ADDR
// if not tmp then
95563: LD_VAR 0 2
95567: NOT
95568: IFFALSE 95572
// continue ;
95570: GO 95367
// HackLink ( i , tmp ) ;
95572: LD_VAR 0 1
95576: PPUSH
95577: LD_VAR 0 2
95581: PPUSH
95582: CALL 95729 0 2
// end ;
95586: GO 95367
95588: POP
95589: POP
// end ;
95590: PPOPN 2
95592: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
95593: LD_INT 0
95595: PPUSH
95596: PPUSH
95597: PPUSH
// if not hack in hackTanks then
95598: LD_VAR 0 1
95602: PUSH
95603: LD_EXP 174
95607: IN
95608: NOT
95609: IFFALSE 95613
// exit ;
95611: GO 95724
// index := GetElementIndex ( hackTanks , hack ) ;
95613: LD_ADDR_VAR 0 4
95617: PUSH
95618: LD_EXP 174
95622: PPUSH
95623: LD_VAR 0 1
95627: PPUSH
95628: CALL 19023 0 2
95632: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
95633: LD_EXP 175
95637: PUSH
95638: LD_VAR 0 4
95642: ARRAY
95643: IFFALSE 95724
// begin for i in hackTanksCaptured [ index ] do
95645: LD_ADDR_VAR 0 3
95649: PUSH
95650: LD_EXP 175
95654: PUSH
95655: LD_VAR 0 4
95659: ARRAY
95660: PUSH
95661: FOR_IN
95662: IFFALSE 95688
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
95664: LD_VAR 0 3
95668: PUSH
95669: LD_INT 1
95671: ARRAY
95672: PPUSH
95673: LD_VAR 0 3
95677: PUSH
95678: LD_INT 2
95680: ARRAY
95681: PPUSH
95682: CALL_OW 235
95686: GO 95661
95688: POP
95689: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
95690: LD_ADDR_EXP 175
95694: PUSH
95695: LD_EXP 175
95699: PPUSH
95700: LD_VAR 0 4
95704: PPUSH
95705: EMPTY
95706: PPUSH
95707: CALL_OW 1
95711: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
95712: LD_VAR 0 1
95716: PPUSH
95717: LD_INT 0
95719: PPUSH
95720: CALL_OW 505
// end ; end ;
95724: LD_VAR 0 2
95728: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
95729: LD_INT 0
95731: PPUSH
95732: PPUSH
95733: PPUSH
// if not hack in hackTanks or not vehicles then
95734: LD_VAR 0 1
95738: PUSH
95739: LD_EXP 174
95743: IN
95744: NOT
95745: PUSH
95746: LD_VAR 0 2
95750: NOT
95751: OR
95752: IFFALSE 95756
// exit ;
95754: GO 96031
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
95756: LD_ADDR_VAR 0 2
95760: PUSH
95761: LD_VAR 0 1
95765: PPUSH
95766: LD_VAR 0 2
95770: PPUSH
95771: LD_INT 1
95773: PPUSH
95774: LD_INT 1
95776: PPUSH
95777: CALL 19673 0 4
95781: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
95782: LD_ADDR_VAR 0 5
95786: PUSH
95787: LD_EXP 174
95791: PPUSH
95792: LD_VAR 0 1
95796: PPUSH
95797: CALL 19023 0 2
95801: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
95802: LD_EXP 175
95806: PUSH
95807: LD_VAR 0 5
95811: ARRAY
95812: PUSH
95813: LD_EXP 176
95817: LESS
95818: IFFALSE 96007
// begin for i := 1 to vehicles do
95820: LD_ADDR_VAR 0 4
95824: PUSH
95825: DOUBLE
95826: LD_INT 1
95828: DEC
95829: ST_TO_ADDR
95830: LD_VAR 0 2
95834: PUSH
95835: FOR_TO
95836: IFFALSE 96005
// begin if hackTanksCaptured [ index ] = hackLimit then
95838: LD_EXP 175
95842: PUSH
95843: LD_VAR 0 5
95847: ARRAY
95848: PUSH
95849: LD_EXP 176
95853: EQUAL
95854: IFFALSE 95858
// break ;
95856: GO 96005
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
95858: LD_ADDR_EXP 178
95862: PUSH
95863: LD_EXP 178
95867: PPUSH
95868: LD_VAR 0 5
95872: PPUSH
95873: LD_EXP 178
95877: PUSH
95878: LD_VAR 0 5
95882: ARRAY
95883: PUSH
95884: LD_INT 1
95886: PLUS
95887: PPUSH
95888: CALL_OW 1
95892: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
95893: LD_ADDR_EXP 175
95897: PUSH
95898: LD_EXP 175
95902: PPUSH
95903: LD_VAR 0 5
95907: PUSH
95908: LD_EXP 175
95912: PUSH
95913: LD_VAR 0 5
95917: ARRAY
95918: PUSH
95919: LD_INT 1
95921: PLUS
95922: PUSH
95923: EMPTY
95924: LIST
95925: LIST
95926: PPUSH
95927: LD_VAR 0 2
95931: PUSH
95932: LD_VAR 0 4
95936: ARRAY
95937: PUSH
95938: LD_VAR 0 2
95942: PUSH
95943: LD_VAR 0 4
95947: ARRAY
95948: PPUSH
95949: CALL_OW 255
95953: PUSH
95954: EMPTY
95955: LIST
95956: LIST
95957: PPUSH
95958: CALL 19238 0 3
95962: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
95963: LD_VAR 0 2
95967: PUSH
95968: LD_VAR 0 4
95972: ARRAY
95973: PPUSH
95974: LD_VAR 0 1
95978: PPUSH
95979: CALL_OW 255
95983: PPUSH
95984: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
95988: LD_VAR 0 2
95992: PUSH
95993: LD_VAR 0 4
95997: ARRAY
95998: PPUSH
95999: CALL_OW 141
// end ;
96003: GO 95835
96005: POP
96006: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
96007: LD_VAR 0 1
96011: PPUSH
96012: LD_EXP 175
96016: PUSH
96017: LD_VAR 0 5
96021: ARRAY
96022: PUSH
96023: LD_INT 0
96025: PLUS
96026: PPUSH
96027: CALL_OW 505
// end ;
96031: LD_VAR 0 3
96035: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
96036: LD_INT 0
96038: PPUSH
96039: PPUSH
96040: PPUSH
96041: PPUSH
// if not hack in hackTanks then
96042: LD_VAR 0 1
96046: PUSH
96047: LD_EXP 174
96051: IN
96052: NOT
96053: IFFALSE 96057
// exit ;
96055: GO 96297
// index := GetElementIndex ( hackTanks , hack ) ;
96057: LD_ADDR_VAR 0 4
96061: PUSH
96062: LD_EXP 174
96066: PPUSH
96067: LD_VAR 0 1
96071: PPUSH
96072: CALL 19023 0 2
96076: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
96077: LD_ADDR_VAR 0 3
96081: PUSH
96082: DOUBLE
96083: LD_EXP 175
96087: PUSH
96088: LD_VAR 0 4
96092: ARRAY
96093: INC
96094: ST_TO_ADDR
96095: LD_INT 1
96097: PUSH
96098: FOR_DOWNTO
96099: IFFALSE 96271
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
96101: LD_ADDR_VAR 0 5
96105: PUSH
96106: LD_EXP 175
96110: PUSH
96111: LD_VAR 0 4
96115: ARRAY
96116: PUSH
96117: LD_VAR 0 3
96121: ARRAY
96122: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
96123: LD_VAR 0 5
96127: PUSH
96128: LD_INT 1
96130: ARRAY
96131: PPUSH
96132: CALL_OW 302
96136: NOT
96137: PUSH
96138: LD_VAR 0 5
96142: PUSH
96143: LD_INT 1
96145: ARRAY
96146: PPUSH
96147: CALL_OW 255
96151: PUSH
96152: LD_VAR 0 1
96156: PPUSH
96157: CALL_OW 255
96161: NONEQUAL
96162: OR
96163: IFFALSE 96269
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
96165: LD_VAR 0 5
96169: PUSH
96170: LD_INT 1
96172: ARRAY
96173: PPUSH
96174: CALL_OW 305
96178: PUSH
96179: LD_VAR 0 5
96183: PUSH
96184: LD_INT 1
96186: ARRAY
96187: PPUSH
96188: CALL_OW 255
96192: PUSH
96193: LD_VAR 0 1
96197: PPUSH
96198: CALL_OW 255
96202: EQUAL
96203: AND
96204: IFFALSE 96228
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
96206: LD_VAR 0 5
96210: PUSH
96211: LD_INT 1
96213: ARRAY
96214: PPUSH
96215: LD_VAR 0 5
96219: PUSH
96220: LD_INT 2
96222: ARRAY
96223: PPUSH
96224: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
96228: LD_ADDR_EXP 175
96232: PUSH
96233: LD_EXP 175
96237: PPUSH
96238: LD_VAR 0 4
96242: PPUSH
96243: LD_EXP 175
96247: PUSH
96248: LD_VAR 0 4
96252: ARRAY
96253: PPUSH
96254: LD_VAR 0 3
96258: PPUSH
96259: CALL_OW 3
96263: PPUSH
96264: CALL_OW 1
96268: ST_TO_ADDR
// end ; end ;
96269: GO 96098
96271: POP
96272: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
96273: LD_VAR 0 1
96277: PPUSH
96278: LD_EXP 175
96282: PUSH
96283: LD_VAR 0 4
96287: ARRAY
96288: PUSH
96289: LD_INT 0
96291: PLUS
96292: PPUSH
96293: CALL_OW 505
// end ;
96297: LD_VAR 0 2
96301: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
96302: LD_INT 0
96304: PPUSH
96305: PPUSH
96306: PPUSH
96307: PPUSH
// if not hack in hackTanks then
96308: LD_VAR 0 1
96312: PUSH
96313: LD_EXP 174
96317: IN
96318: NOT
96319: IFFALSE 96323
// exit ;
96321: GO 96408
// index := GetElementIndex ( hackTanks , hack ) ;
96323: LD_ADDR_VAR 0 5
96327: PUSH
96328: LD_EXP 174
96332: PPUSH
96333: LD_VAR 0 1
96337: PPUSH
96338: CALL 19023 0 2
96342: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
96343: LD_ADDR_VAR 0 4
96347: PUSH
96348: DOUBLE
96349: LD_INT 1
96351: DEC
96352: ST_TO_ADDR
96353: LD_EXP 175
96357: PUSH
96358: LD_VAR 0 5
96362: ARRAY
96363: PUSH
96364: FOR_TO
96365: IFFALSE 96406
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
96367: LD_EXP 175
96371: PUSH
96372: LD_VAR 0 5
96376: ARRAY
96377: PUSH
96378: LD_VAR 0 4
96382: ARRAY
96383: PUSH
96384: LD_INT 1
96386: ARRAY
96387: PUSH
96388: LD_VAR 0 2
96392: EQUAL
96393: IFFALSE 96404
// KillUnit ( vehicle ) ;
96395: LD_VAR 0 2
96399: PPUSH
96400: CALL_OW 66
96404: GO 96364
96406: POP
96407: POP
// end ;
96408: LD_VAR 0 3
96412: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
96413: LD_EXP 179
96417: NOT
96418: IFFALSE 96453
96420: GO 96422
96422: DISABLE
// begin initMiner := true ;
96423: LD_ADDR_EXP 179
96427: PUSH
96428: LD_INT 1
96430: ST_TO_ADDR
// minersList := [ ] ;
96431: LD_ADDR_EXP 180
96435: PUSH
96436: EMPTY
96437: ST_TO_ADDR
// minerMinesList := [ ] ;
96438: LD_ADDR_EXP 181
96442: PUSH
96443: EMPTY
96444: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
96445: LD_ADDR_EXP 182
96449: PUSH
96450: LD_INT 5
96452: ST_TO_ADDR
// end ;
96453: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
96454: LD_EXP 179
96458: PUSH
96459: LD_INT 34
96461: PUSH
96462: LD_EXP 109
96466: PUSH
96467: EMPTY
96468: LIST
96469: LIST
96470: PPUSH
96471: CALL_OW 69
96475: AND
96476: IFFALSE 96939
96478: GO 96480
96480: DISABLE
96481: LD_INT 0
96483: PPUSH
96484: PPUSH
96485: PPUSH
96486: PPUSH
// begin enable ;
96487: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
96488: LD_ADDR_VAR 0 1
96492: PUSH
96493: LD_INT 34
96495: PUSH
96496: LD_EXP 109
96500: PUSH
96501: EMPTY
96502: LIST
96503: LIST
96504: PPUSH
96505: CALL_OW 69
96509: PUSH
96510: FOR_IN
96511: IFFALSE 96583
// begin if not i in minersList then
96513: LD_VAR 0 1
96517: PUSH
96518: LD_EXP 180
96522: IN
96523: NOT
96524: IFFALSE 96581
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
96526: LD_ADDR_EXP 180
96530: PUSH
96531: LD_EXP 180
96535: PPUSH
96536: LD_EXP 180
96540: PUSH
96541: LD_INT 1
96543: PLUS
96544: PPUSH
96545: LD_VAR 0 1
96549: PPUSH
96550: CALL_OW 1
96554: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
96555: LD_ADDR_EXP 181
96559: PUSH
96560: LD_EXP 181
96564: PPUSH
96565: LD_EXP 181
96569: PUSH
96570: LD_INT 1
96572: PLUS
96573: PPUSH
96574: EMPTY
96575: PPUSH
96576: CALL_OW 1
96580: ST_TO_ADDR
// end end ;
96581: GO 96510
96583: POP
96584: POP
// for i := minerMinesList downto 1 do
96585: LD_ADDR_VAR 0 1
96589: PUSH
96590: DOUBLE
96591: LD_EXP 181
96595: INC
96596: ST_TO_ADDR
96597: LD_INT 1
96599: PUSH
96600: FOR_DOWNTO
96601: IFFALSE 96937
// begin if IsLive ( minersList [ i ] ) then
96603: LD_EXP 180
96607: PUSH
96608: LD_VAR 0 1
96612: ARRAY
96613: PPUSH
96614: CALL_OW 300
96618: IFFALSE 96646
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
96620: LD_EXP 180
96624: PUSH
96625: LD_VAR 0 1
96629: ARRAY
96630: PPUSH
96631: LD_EXP 181
96635: PUSH
96636: LD_VAR 0 1
96640: ARRAY
96641: PPUSH
96642: CALL_OW 505
// if not minerMinesList [ i ] then
96646: LD_EXP 181
96650: PUSH
96651: LD_VAR 0 1
96655: ARRAY
96656: NOT
96657: IFFALSE 96661
// continue ;
96659: GO 96600
// for j := minerMinesList [ i ] downto 1 do
96661: LD_ADDR_VAR 0 2
96665: PUSH
96666: DOUBLE
96667: LD_EXP 181
96671: PUSH
96672: LD_VAR 0 1
96676: ARRAY
96677: INC
96678: ST_TO_ADDR
96679: LD_INT 1
96681: PUSH
96682: FOR_DOWNTO
96683: IFFALSE 96933
// begin side := GetSide ( minersList [ i ] ) ;
96685: LD_ADDR_VAR 0 3
96689: PUSH
96690: LD_EXP 180
96694: PUSH
96695: LD_VAR 0 1
96699: ARRAY
96700: PPUSH
96701: CALL_OW 255
96705: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
96706: LD_ADDR_VAR 0 4
96710: PUSH
96711: LD_EXP 181
96715: PUSH
96716: LD_VAR 0 1
96720: ARRAY
96721: PUSH
96722: LD_VAR 0 2
96726: ARRAY
96727: PUSH
96728: LD_INT 1
96730: ARRAY
96731: PPUSH
96732: LD_EXP 181
96736: PUSH
96737: LD_VAR 0 1
96741: ARRAY
96742: PUSH
96743: LD_VAR 0 2
96747: ARRAY
96748: PUSH
96749: LD_INT 2
96751: ARRAY
96752: PPUSH
96753: CALL_OW 428
96757: ST_TO_ADDR
// if not tmp then
96758: LD_VAR 0 4
96762: NOT
96763: IFFALSE 96767
// continue ;
96765: GO 96682
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
96767: LD_VAR 0 4
96771: PUSH
96772: LD_INT 81
96774: PUSH
96775: LD_VAR 0 3
96779: PUSH
96780: EMPTY
96781: LIST
96782: LIST
96783: PPUSH
96784: CALL_OW 69
96788: IN
96789: PUSH
96790: LD_EXP 181
96794: PUSH
96795: LD_VAR 0 1
96799: ARRAY
96800: PUSH
96801: LD_VAR 0 2
96805: ARRAY
96806: PUSH
96807: LD_INT 1
96809: ARRAY
96810: PPUSH
96811: LD_EXP 181
96815: PUSH
96816: LD_VAR 0 1
96820: ARRAY
96821: PUSH
96822: LD_VAR 0 2
96826: ARRAY
96827: PUSH
96828: LD_INT 2
96830: ARRAY
96831: PPUSH
96832: CALL_OW 458
96836: AND
96837: IFFALSE 96931
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
96839: LD_EXP 181
96843: PUSH
96844: LD_VAR 0 1
96848: ARRAY
96849: PUSH
96850: LD_VAR 0 2
96854: ARRAY
96855: PUSH
96856: LD_INT 1
96858: ARRAY
96859: PPUSH
96860: LD_EXP 181
96864: PUSH
96865: LD_VAR 0 1
96869: ARRAY
96870: PUSH
96871: LD_VAR 0 2
96875: ARRAY
96876: PUSH
96877: LD_INT 2
96879: ARRAY
96880: PPUSH
96881: LD_VAR 0 3
96885: PPUSH
96886: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
96890: LD_ADDR_EXP 181
96894: PUSH
96895: LD_EXP 181
96899: PPUSH
96900: LD_VAR 0 1
96904: PPUSH
96905: LD_EXP 181
96909: PUSH
96910: LD_VAR 0 1
96914: ARRAY
96915: PPUSH
96916: LD_VAR 0 2
96920: PPUSH
96921: CALL_OW 3
96925: PPUSH
96926: CALL_OW 1
96930: ST_TO_ADDR
// end ; end ;
96931: GO 96682
96933: POP
96934: POP
// end ;
96935: GO 96600
96937: POP
96938: POP
// end ;
96939: PPOPN 4
96941: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
96942: LD_INT 0
96944: PPUSH
96945: PPUSH
// result := false ;
96946: LD_ADDR_VAR 0 4
96950: PUSH
96951: LD_INT 0
96953: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
96954: LD_VAR 0 1
96958: PPUSH
96959: CALL_OW 264
96963: PUSH
96964: LD_EXP 109
96968: EQUAL
96969: NOT
96970: IFFALSE 96974
// exit ;
96972: GO 97214
// index := GetElementIndex ( minersList , unit ) ;
96974: LD_ADDR_VAR 0 5
96978: PUSH
96979: LD_EXP 180
96983: PPUSH
96984: LD_VAR 0 1
96988: PPUSH
96989: CALL 19023 0 2
96993: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
96994: LD_EXP 181
96998: PUSH
96999: LD_VAR 0 5
97003: ARRAY
97004: PUSH
97005: LD_EXP 182
97009: GREATEREQUAL
97010: IFFALSE 97014
// exit ;
97012: GO 97214
// ComMoveXY ( unit , x , y ) ;
97014: LD_VAR 0 1
97018: PPUSH
97019: LD_VAR 0 2
97023: PPUSH
97024: LD_VAR 0 3
97028: PPUSH
97029: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
97033: LD_INT 35
97035: PPUSH
97036: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
97040: LD_VAR 0 1
97044: PPUSH
97045: LD_VAR 0 2
97049: PPUSH
97050: LD_VAR 0 3
97054: PPUSH
97055: CALL 49087 0 3
97059: NOT
97060: PUSH
97061: LD_VAR 0 1
97065: PPUSH
97066: CALL_OW 314
97070: AND
97071: IFFALSE 97075
// exit ;
97073: GO 97214
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
97075: LD_VAR 0 2
97079: PPUSH
97080: LD_VAR 0 3
97084: PPUSH
97085: CALL_OW 428
97089: PUSH
97090: LD_VAR 0 1
97094: EQUAL
97095: PUSH
97096: LD_VAR 0 1
97100: PPUSH
97101: CALL_OW 314
97105: NOT
97106: AND
97107: IFFALSE 97033
// PlaySoundXY ( x , y , PlantMine ) ;
97109: LD_VAR 0 2
97113: PPUSH
97114: LD_VAR 0 3
97118: PPUSH
97119: LD_STRING PlantMine
97121: PPUSH
97122: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
97126: LD_VAR 0 2
97130: PPUSH
97131: LD_VAR 0 3
97135: PPUSH
97136: LD_VAR 0 1
97140: PPUSH
97141: CALL_OW 255
97145: PPUSH
97146: LD_INT 0
97148: PPUSH
97149: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
97153: LD_ADDR_EXP 181
97157: PUSH
97158: LD_EXP 181
97162: PPUSH
97163: LD_VAR 0 5
97167: PUSH
97168: LD_EXP 181
97172: PUSH
97173: LD_VAR 0 5
97177: ARRAY
97178: PUSH
97179: LD_INT 1
97181: PLUS
97182: PUSH
97183: EMPTY
97184: LIST
97185: LIST
97186: PPUSH
97187: LD_VAR 0 2
97191: PUSH
97192: LD_VAR 0 3
97196: PUSH
97197: EMPTY
97198: LIST
97199: LIST
97200: PPUSH
97201: CALL 19238 0 3
97205: ST_TO_ADDR
// result := true ;
97206: LD_ADDR_VAR 0 4
97210: PUSH
97211: LD_INT 1
97213: ST_TO_ADDR
// end ;
97214: LD_VAR 0 4
97218: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
97219: LD_INT 0
97221: PPUSH
97222: PPUSH
97223: PPUSH
// if not unit in minersList then
97224: LD_VAR 0 1
97228: PUSH
97229: LD_EXP 180
97233: IN
97234: NOT
97235: IFFALSE 97239
// exit ;
97237: GO 97631
// index := GetElementIndex ( minersList , unit ) ;
97239: LD_ADDR_VAR 0 6
97243: PUSH
97244: LD_EXP 180
97248: PPUSH
97249: LD_VAR 0 1
97253: PPUSH
97254: CALL 19023 0 2
97258: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
97259: LD_ADDR_VAR 0 5
97263: PUSH
97264: DOUBLE
97265: LD_EXP 181
97269: PUSH
97270: LD_VAR 0 6
97274: ARRAY
97275: INC
97276: ST_TO_ADDR
97277: LD_INT 1
97279: PUSH
97280: FOR_DOWNTO
97281: IFFALSE 97442
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
97283: LD_EXP 181
97287: PUSH
97288: LD_VAR 0 6
97292: ARRAY
97293: PUSH
97294: LD_VAR 0 5
97298: ARRAY
97299: PUSH
97300: LD_INT 1
97302: ARRAY
97303: PUSH
97304: LD_VAR 0 2
97308: EQUAL
97309: PUSH
97310: LD_EXP 181
97314: PUSH
97315: LD_VAR 0 6
97319: ARRAY
97320: PUSH
97321: LD_VAR 0 5
97325: ARRAY
97326: PUSH
97327: LD_INT 2
97329: ARRAY
97330: PUSH
97331: LD_VAR 0 3
97335: EQUAL
97336: AND
97337: IFFALSE 97440
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
97339: LD_EXP 181
97343: PUSH
97344: LD_VAR 0 6
97348: ARRAY
97349: PUSH
97350: LD_VAR 0 5
97354: ARRAY
97355: PUSH
97356: LD_INT 1
97358: ARRAY
97359: PPUSH
97360: LD_EXP 181
97364: PUSH
97365: LD_VAR 0 6
97369: ARRAY
97370: PUSH
97371: LD_VAR 0 5
97375: ARRAY
97376: PUSH
97377: LD_INT 2
97379: ARRAY
97380: PPUSH
97381: LD_VAR 0 1
97385: PPUSH
97386: CALL_OW 255
97390: PPUSH
97391: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
97395: LD_ADDR_EXP 181
97399: PUSH
97400: LD_EXP 181
97404: PPUSH
97405: LD_VAR 0 6
97409: PPUSH
97410: LD_EXP 181
97414: PUSH
97415: LD_VAR 0 6
97419: ARRAY
97420: PPUSH
97421: LD_VAR 0 5
97425: PPUSH
97426: CALL_OW 3
97430: PPUSH
97431: CALL_OW 1
97435: ST_TO_ADDR
// exit ;
97436: POP
97437: POP
97438: GO 97631
// end ; end ;
97440: GO 97280
97442: POP
97443: POP
// for i := minerMinesList [ index ] downto 1 do
97444: LD_ADDR_VAR 0 5
97448: PUSH
97449: DOUBLE
97450: LD_EXP 181
97454: PUSH
97455: LD_VAR 0 6
97459: ARRAY
97460: INC
97461: ST_TO_ADDR
97462: LD_INT 1
97464: PUSH
97465: FOR_DOWNTO
97466: IFFALSE 97629
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
97468: LD_EXP 181
97472: PUSH
97473: LD_VAR 0 6
97477: ARRAY
97478: PUSH
97479: LD_VAR 0 5
97483: ARRAY
97484: PUSH
97485: LD_INT 1
97487: ARRAY
97488: PPUSH
97489: LD_EXP 181
97493: PUSH
97494: LD_VAR 0 6
97498: ARRAY
97499: PUSH
97500: LD_VAR 0 5
97504: ARRAY
97505: PUSH
97506: LD_INT 2
97508: ARRAY
97509: PPUSH
97510: LD_VAR 0 2
97514: PPUSH
97515: LD_VAR 0 3
97519: PPUSH
97520: CALL_OW 298
97524: PUSH
97525: LD_INT 6
97527: LESS
97528: IFFALSE 97627
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
97530: LD_EXP 181
97534: PUSH
97535: LD_VAR 0 6
97539: ARRAY
97540: PUSH
97541: LD_VAR 0 5
97545: ARRAY
97546: PUSH
97547: LD_INT 1
97549: ARRAY
97550: PPUSH
97551: LD_EXP 181
97555: PUSH
97556: LD_VAR 0 6
97560: ARRAY
97561: PUSH
97562: LD_VAR 0 5
97566: ARRAY
97567: PUSH
97568: LD_INT 2
97570: ARRAY
97571: PPUSH
97572: LD_VAR 0 1
97576: PPUSH
97577: CALL_OW 255
97581: PPUSH
97582: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
97586: LD_ADDR_EXP 181
97590: PUSH
97591: LD_EXP 181
97595: PPUSH
97596: LD_VAR 0 6
97600: PPUSH
97601: LD_EXP 181
97605: PUSH
97606: LD_VAR 0 6
97610: ARRAY
97611: PPUSH
97612: LD_VAR 0 5
97616: PPUSH
97617: CALL_OW 3
97621: PPUSH
97622: CALL_OW 1
97626: ST_TO_ADDR
// end ; end ;
97627: GO 97465
97629: POP
97630: POP
// end ;
97631: LD_VAR 0 4
97635: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
97636: LD_INT 0
97638: PPUSH
97639: PPUSH
97640: PPUSH
97641: PPUSH
97642: PPUSH
97643: PPUSH
97644: PPUSH
97645: PPUSH
97646: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
97647: LD_VAR 0 1
97651: PPUSH
97652: CALL_OW 264
97656: PUSH
97657: LD_EXP 109
97661: EQUAL
97662: NOT
97663: PUSH
97664: LD_VAR 0 1
97668: PUSH
97669: LD_EXP 180
97673: IN
97674: NOT
97675: OR
97676: IFFALSE 97680
// exit ;
97678: GO 98002
// index := GetElementIndex ( minersList , unit ) ;
97680: LD_ADDR_VAR 0 6
97684: PUSH
97685: LD_EXP 180
97689: PPUSH
97690: LD_VAR 0 1
97694: PPUSH
97695: CALL 19023 0 2
97699: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
97700: LD_ADDR_VAR 0 8
97704: PUSH
97705: LD_EXP 182
97709: PUSH
97710: LD_EXP 181
97714: PUSH
97715: LD_VAR 0 6
97719: ARRAY
97720: MINUS
97721: ST_TO_ADDR
// if not minesFreeAmount then
97722: LD_VAR 0 8
97726: NOT
97727: IFFALSE 97731
// exit ;
97729: GO 98002
// tmp := [ ] ;
97731: LD_ADDR_VAR 0 7
97735: PUSH
97736: EMPTY
97737: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
97738: LD_ADDR_VAR 0 5
97742: PUSH
97743: DOUBLE
97744: LD_INT 1
97746: DEC
97747: ST_TO_ADDR
97748: LD_VAR 0 8
97752: PUSH
97753: FOR_TO
97754: IFFALSE 97949
// begin _d := rand ( 0 , 5 ) ;
97756: LD_ADDR_VAR 0 11
97760: PUSH
97761: LD_INT 0
97763: PPUSH
97764: LD_INT 5
97766: PPUSH
97767: CALL_OW 12
97771: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
97772: LD_ADDR_VAR 0 12
97776: PUSH
97777: LD_INT 2
97779: PPUSH
97780: LD_INT 6
97782: PPUSH
97783: CALL_OW 12
97787: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
97788: LD_ADDR_VAR 0 9
97792: PUSH
97793: LD_VAR 0 2
97797: PPUSH
97798: LD_VAR 0 11
97802: PPUSH
97803: LD_VAR 0 12
97807: PPUSH
97808: CALL_OW 272
97812: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
97813: LD_ADDR_VAR 0 10
97817: PUSH
97818: LD_VAR 0 3
97822: PPUSH
97823: LD_VAR 0 11
97827: PPUSH
97828: LD_VAR 0 12
97832: PPUSH
97833: CALL_OW 273
97837: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
97838: LD_VAR 0 9
97842: PPUSH
97843: LD_VAR 0 10
97847: PPUSH
97848: CALL_OW 488
97852: PUSH
97853: LD_VAR 0 9
97857: PUSH
97858: LD_VAR 0 10
97862: PUSH
97863: EMPTY
97864: LIST
97865: LIST
97866: PUSH
97867: LD_VAR 0 7
97871: IN
97872: NOT
97873: AND
97874: PUSH
97875: LD_VAR 0 9
97879: PPUSH
97880: LD_VAR 0 10
97884: PPUSH
97885: CALL_OW 458
97889: NOT
97890: AND
97891: IFFALSE 97933
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
97893: LD_ADDR_VAR 0 7
97897: PUSH
97898: LD_VAR 0 7
97902: PPUSH
97903: LD_VAR 0 7
97907: PUSH
97908: LD_INT 1
97910: PLUS
97911: PPUSH
97912: LD_VAR 0 9
97916: PUSH
97917: LD_VAR 0 10
97921: PUSH
97922: EMPTY
97923: LIST
97924: LIST
97925: PPUSH
97926: CALL_OW 1
97930: ST_TO_ADDR
97931: GO 97947
// i := i - 1 ;
97933: LD_ADDR_VAR 0 5
97937: PUSH
97938: LD_VAR 0 5
97942: PUSH
97943: LD_INT 1
97945: MINUS
97946: ST_TO_ADDR
// end ;
97947: GO 97753
97949: POP
97950: POP
// for i in tmp do
97951: LD_ADDR_VAR 0 5
97955: PUSH
97956: LD_VAR 0 7
97960: PUSH
97961: FOR_IN
97962: IFFALSE 98000
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
97964: LD_VAR 0 1
97968: PPUSH
97969: LD_VAR 0 5
97973: PUSH
97974: LD_INT 1
97976: ARRAY
97977: PPUSH
97978: LD_VAR 0 5
97982: PUSH
97983: LD_INT 2
97985: ARRAY
97986: PPUSH
97987: CALL 96942 0 3
97991: NOT
97992: IFFALSE 97998
// exit ;
97994: POP
97995: POP
97996: GO 98002
97998: GO 97961
98000: POP
98001: POP
// end ;
98002: LD_VAR 0 4
98006: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
98007: LD_INT 0
98009: PPUSH
98010: PPUSH
98011: PPUSH
98012: PPUSH
98013: PPUSH
98014: PPUSH
98015: PPUSH
// if not GetClass ( unit ) = class_sniper then
98016: LD_VAR 0 1
98020: PPUSH
98021: CALL_OW 257
98025: PUSH
98026: LD_INT 5
98028: EQUAL
98029: NOT
98030: IFFALSE 98034
// exit ;
98032: GO 98422
// dist := 8 ;
98034: LD_ADDR_VAR 0 5
98038: PUSH
98039: LD_INT 8
98041: ST_TO_ADDR
// viewRange := 12 ;
98042: LD_ADDR_VAR 0 7
98046: PUSH
98047: LD_INT 12
98049: ST_TO_ADDR
// side := GetSide ( unit ) ;
98050: LD_ADDR_VAR 0 6
98054: PUSH
98055: LD_VAR 0 1
98059: PPUSH
98060: CALL_OW 255
98064: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
98065: LD_INT 61
98067: PPUSH
98068: LD_VAR 0 6
98072: PPUSH
98073: CALL_OW 321
98077: PUSH
98078: LD_INT 2
98080: EQUAL
98081: IFFALSE 98091
// viewRange := 16 ;
98083: LD_ADDR_VAR 0 7
98087: PUSH
98088: LD_INT 16
98090: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
98091: LD_VAR 0 1
98095: PPUSH
98096: LD_VAR 0 2
98100: PPUSH
98101: LD_VAR 0 3
98105: PPUSH
98106: CALL_OW 297
98110: PUSH
98111: LD_VAR 0 5
98115: GREATER
98116: IFFALSE 98195
// begin ComMoveXY ( unit , x , y ) ;
98118: LD_VAR 0 1
98122: PPUSH
98123: LD_VAR 0 2
98127: PPUSH
98128: LD_VAR 0 3
98132: PPUSH
98133: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
98137: LD_INT 35
98139: PPUSH
98140: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
98144: LD_VAR 0 1
98148: PPUSH
98149: LD_VAR 0 2
98153: PPUSH
98154: LD_VAR 0 3
98158: PPUSH
98159: CALL 49087 0 3
98163: NOT
98164: IFFALSE 98168
// exit ;
98166: GO 98422
// until GetDistUnitXY ( unit , x , y ) < dist ;
98168: LD_VAR 0 1
98172: PPUSH
98173: LD_VAR 0 2
98177: PPUSH
98178: LD_VAR 0 3
98182: PPUSH
98183: CALL_OW 297
98187: PUSH
98188: LD_VAR 0 5
98192: LESS
98193: IFFALSE 98137
// end ; ComTurnXY ( unit , x , y ) ;
98195: LD_VAR 0 1
98199: PPUSH
98200: LD_VAR 0 2
98204: PPUSH
98205: LD_VAR 0 3
98209: PPUSH
98210: CALL_OW 118
// wait ( 5 ) ;
98214: LD_INT 5
98216: PPUSH
98217: CALL_OW 67
// _d := GetDir ( unit ) ;
98221: LD_ADDR_VAR 0 10
98225: PUSH
98226: LD_VAR 0 1
98230: PPUSH
98231: CALL_OW 254
98235: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
98236: LD_ADDR_VAR 0 8
98240: PUSH
98241: LD_VAR 0 1
98245: PPUSH
98246: CALL_OW 250
98250: PPUSH
98251: LD_VAR 0 10
98255: PPUSH
98256: LD_VAR 0 5
98260: PPUSH
98261: CALL_OW 272
98265: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
98266: LD_ADDR_VAR 0 9
98270: PUSH
98271: LD_VAR 0 1
98275: PPUSH
98276: CALL_OW 251
98280: PPUSH
98281: LD_VAR 0 10
98285: PPUSH
98286: LD_VAR 0 5
98290: PPUSH
98291: CALL_OW 273
98295: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
98296: LD_VAR 0 8
98300: PPUSH
98301: LD_VAR 0 9
98305: PPUSH
98306: CALL_OW 488
98310: NOT
98311: IFFALSE 98315
// exit ;
98313: GO 98422
// ComAnimCustom ( unit , 1 ) ;
98315: LD_VAR 0 1
98319: PPUSH
98320: LD_INT 1
98322: PPUSH
98323: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
98327: LD_VAR 0 8
98331: PPUSH
98332: LD_VAR 0 9
98336: PPUSH
98337: LD_VAR 0 6
98341: PPUSH
98342: LD_VAR 0 7
98346: PPUSH
98347: CALL_OW 330
// repeat wait ( 1 ) ;
98351: LD_INT 1
98353: PPUSH
98354: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
98358: LD_VAR 0 1
98362: PPUSH
98363: CALL_OW 316
98367: PUSH
98368: LD_VAR 0 1
98372: PPUSH
98373: CALL_OW 314
98377: OR
98378: PUSH
98379: LD_VAR 0 1
98383: PPUSH
98384: CALL_OW 302
98388: NOT
98389: OR
98390: PUSH
98391: LD_VAR 0 1
98395: PPUSH
98396: CALL_OW 301
98400: OR
98401: IFFALSE 98351
// RemoveSeeing ( _x , _y , side ) ;
98403: LD_VAR 0 8
98407: PPUSH
98408: LD_VAR 0 9
98412: PPUSH
98413: LD_VAR 0 6
98417: PPUSH
98418: CALL_OW 331
// end ; end_of_file
98422: LD_VAR 0 4
98426: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
98427: LD_INT 0
98429: PPUSH
98430: PPUSH
98431: PPUSH
98432: PPUSH
98433: PPUSH
98434: PPUSH
98435: PPUSH
98436: PPUSH
98437: PPUSH
98438: PPUSH
98439: PPUSH
98440: PPUSH
98441: PPUSH
98442: PPUSH
98443: PPUSH
98444: PPUSH
98445: PPUSH
98446: PPUSH
98447: PPUSH
98448: PPUSH
98449: PPUSH
98450: PPUSH
98451: PPUSH
98452: PPUSH
98453: PPUSH
98454: PPUSH
98455: PPUSH
98456: PPUSH
98457: PPUSH
98458: PPUSH
98459: PPUSH
98460: PPUSH
98461: PPUSH
98462: PPUSH
// if not list then
98463: LD_VAR 0 1
98467: NOT
98468: IFFALSE 98472
// exit ;
98470: GO 103131
// base := list [ 1 ] ;
98472: LD_ADDR_VAR 0 3
98476: PUSH
98477: LD_VAR 0 1
98481: PUSH
98482: LD_INT 1
98484: ARRAY
98485: ST_TO_ADDR
// group := list [ 2 ] ;
98486: LD_ADDR_VAR 0 4
98490: PUSH
98491: LD_VAR 0 1
98495: PUSH
98496: LD_INT 2
98498: ARRAY
98499: ST_TO_ADDR
// path := list [ 3 ] ;
98500: LD_ADDR_VAR 0 5
98504: PUSH
98505: LD_VAR 0 1
98509: PUSH
98510: LD_INT 3
98512: ARRAY
98513: ST_TO_ADDR
// flags := list [ 4 ] ;
98514: LD_ADDR_VAR 0 6
98518: PUSH
98519: LD_VAR 0 1
98523: PUSH
98524: LD_INT 4
98526: ARRAY
98527: ST_TO_ADDR
// mined := [ ] ;
98528: LD_ADDR_VAR 0 27
98532: PUSH
98533: EMPTY
98534: ST_TO_ADDR
// bombed := [ ] ;
98535: LD_ADDR_VAR 0 28
98539: PUSH
98540: EMPTY
98541: ST_TO_ADDR
// healers := [ ] ;
98542: LD_ADDR_VAR 0 31
98546: PUSH
98547: EMPTY
98548: ST_TO_ADDR
// to_heal := [ ] ;
98549: LD_ADDR_VAR 0 30
98553: PUSH
98554: EMPTY
98555: ST_TO_ADDR
// repairs := [ ] ;
98556: LD_ADDR_VAR 0 33
98560: PUSH
98561: EMPTY
98562: ST_TO_ADDR
// to_repair := [ ] ;
98563: LD_ADDR_VAR 0 32
98567: PUSH
98568: EMPTY
98569: ST_TO_ADDR
// if not group or not path then
98570: LD_VAR 0 4
98574: NOT
98575: PUSH
98576: LD_VAR 0 5
98580: NOT
98581: OR
98582: IFFALSE 98586
// exit ;
98584: GO 103131
// side := GetSide ( group [ 1 ] ) ;
98586: LD_ADDR_VAR 0 35
98590: PUSH
98591: LD_VAR 0 4
98595: PUSH
98596: LD_INT 1
98598: ARRAY
98599: PPUSH
98600: CALL_OW 255
98604: ST_TO_ADDR
// if flags then
98605: LD_VAR 0 6
98609: IFFALSE 98753
// begin f_ignore_area := flags [ 1 ] ;
98611: LD_ADDR_VAR 0 17
98615: PUSH
98616: LD_VAR 0 6
98620: PUSH
98621: LD_INT 1
98623: ARRAY
98624: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
98625: LD_ADDR_VAR 0 18
98629: PUSH
98630: LD_VAR 0 6
98634: PUSH
98635: LD_INT 2
98637: ARRAY
98638: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
98639: LD_ADDR_VAR 0 19
98643: PUSH
98644: LD_VAR 0 6
98648: PUSH
98649: LD_INT 3
98651: ARRAY
98652: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
98653: LD_ADDR_VAR 0 20
98657: PUSH
98658: LD_VAR 0 6
98662: PUSH
98663: LD_INT 4
98665: ARRAY
98666: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
98667: LD_ADDR_VAR 0 21
98671: PUSH
98672: LD_VAR 0 6
98676: PUSH
98677: LD_INT 5
98679: ARRAY
98680: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
98681: LD_ADDR_VAR 0 22
98685: PUSH
98686: LD_VAR 0 6
98690: PUSH
98691: LD_INT 6
98693: ARRAY
98694: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
98695: LD_ADDR_VAR 0 23
98699: PUSH
98700: LD_VAR 0 6
98704: PUSH
98705: LD_INT 7
98707: ARRAY
98708: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
98709: LD_ADDR_VAR 0 24
98713: PUSH
98714: LD_VAR 0 6
98718: PUSH
98719: LD_INT 8
98721: ARRAY
98722: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
98723: LD_ADDR_VAR 0 25
98727: PUSH
98728: LD_VAR 0 6
98732: PUSH
98733: LD_INT 9
98735: ARRAY
98736: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
98737: LD_ADDR_VAR 0 26
98741: PUSH
98742: LD_VAR 0 6
98746: PUSH
98747: LD_INT 10
98749: ARRAY
98750: ST_TO_ADDR
// end else
98751: GO 98833
// begin f_ignore_area := false ;
98753: LD_ADDR_VAR 0 17
98757: PUSH
98758: LD_INT 0
98760: ST_TO_ADDR
// f_capture := false ;
98761: LD_ADDR_VAR 0 18
98765: PUSH
98766: LD_INT 0
98768: ST_TO_ADDR
// f_ignore_civ := false ;
98769: LD_ADDR_VAR 0 19
98773: PUSH
98774: LD_INT 0
98776: ST_TO_ADDR
// f_murder := false ;
98777: LD_ADDR_VAR 0 20
98781: PUSH
98782: LD_INT 0
98784: ST_TO_ADDR
// f_mines := false ;
98785: LD_ADDR_VAR 0 21
98789: PUSH
98790: LD_INT 0
98792: ST_TO_ADDR
// f_repair := false ;
98793: LD_ADDR_VAR 0 22
98797: PUSH
98798: LD_INT 0
98800: ST_TO_ADDR
// f_heal := false ;
98801: LD_ADDR_VAR 0 23
98805: PUSH
98806: LD_INT 0
98808: ST_TO_ADDR
// f_spacetime := false ;
98809: LD_ADDR_VAR 0 24
98813: PUSH
98814: LD_INT 0
98816: ST_TO_ADDR
// f_attack_depot := false ;
98817: LD_ADDR_VAR 0 25
98821: PUSH
98822: LD_INT 0
98824: ST_TO_ADDR
// f_crawl := false ;
98825: LD_ADDR_VAR 0 26
98829: PUSH
98830: LD_INT 0
98832: ST_TO_ADDR
// end ; if f_heal then
98833: LD_VAR 0 23
98837: IFFALSE 98864
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
98839: LD_ADDR_VAR 0 31
98843: PUSH
98844: LD_VAR 0 4
98848: PPUSH
98849: LD_INT 25
98851: PUSH
98852: LD_INT 4
98854: PUSH
98855: EMPTY
98856: LIST
98857: LIST
98858: PPUSH
98859: CALL_OW 72
98863: ST_TO_ADDR
// if f_repair then
98864: LD_VAR 0 22
98868: IFFALSE 98895
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
98870: LD_ADDR_VAR 0 33
98874: PUSH
98875: LD_VAR 0 4
98879: PPUSH
98880: LD_INT 25
98882: PUSH
98883: LD_INT 3
98885: PUSH
98886: EMPTY
98887: LIST
98888: LIST
98889: PPUSH
98890: CALL_OW 72
98894: ST_TO_ADDR
// units_path := [ ] ;
98895: LD_ADDR_VAR 0 16
98899: PUSH
98900: EMPTY
98901: ST_TO_ADDR
// for i = 1 to group do
98902: LD_ADDR_VAR 0 7
98906: PUSH
98907: DOUBLE
98908: LD_INT 1
98910: DEC
98911: ST_TO_ADDR
98912: LD_VAR 0 4
98916: PUSH
98917: FOR_TO
98918: IFFALSE 98947
// units_path := Replace ( units_path , i , path ) ;
98920: LD_ADDR_VAR 0 16
98924: PUSH
98925: LD_VAR 0 16
98929: PPUSH
98930: LD_VAR 0 7
98934: PPUSH
98935: LD_VAR 0 5
98939: PPUSH
98940: CALL_OW 1
98944: ST_TO_ADDR
98945: GO 98917
98947: POP
98948: POP
// repeat for i = group downto 1 do
98949: LD_ADDR_VAR 0 7
98953: PUSH
98954: DOUBLE
98955: LD_VAR 0 4
98959: INC
98960: ST_TO_ADDR
98961: LD_INT 1
98963: PUSH
98964: FOR_DOWNTO
98965: IFFALSE 103087
// begin wait ( 5 ) ;
98967: LD_INT 5
98969: PPUSH
98970: CALL_OW 67
// tmp := [ ] ;
98974: LD_ADDR_VAR 0 14
98978: PUSH
98979: EMPTY
98980: ST_TO_ADDR
// attacking := false ;
98981: LD_ADDR_VAR 0 29
98985: PUSH
98986: LD_INT 0
98988: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
98989: LD_VAR 0 4
98993: PUSH
98994: LD_VAR 0 7
98998: ARRAY
98999: PPUSH
99000: CALL_OW 301
99004: PUSH
99005: LD_VAR 0 4
99009: PUSH
99010: LD_VAR 0 7
99014: ARRAY
99015: NOT
99016: OR
99017: IFFALSE 99126
// begin if GetType ( group [ i ] ) = unit_human then
99019: LD_VAR 0 4
99023: PUSH
99024: LD_VAR 0 7
99028: ARRAY
99029: PPUSH
99030: CALL_OW 247
99034: PUSH
99035: LD_INT 1
99037: EQUAL
99038: IFFALSE 99084
// begin to_heal := to_heal diff group [ i ] ;
99040: LD_ADDR_VAR 0 30
99044: PUSH
99045: LD_VAR 0 30
99049: PUSH
99050: LD_VAR 0 4
99054: PUSH
99055: LD_VAR 0 7
99059: ARRAY
99060: DIFF
99061: ST_TO_ADDR
// healers := healers diff group [ i ] ;
99062: LD_ADDR_VAR 0 31
99066: PUSH
99067: LD_VAR 0 31
99071: PUSH
99072: LD_VAR 0 4
99076: PUSH
99077: LD_VAR 0 7
99081: ARRAY
99082: DIFF
99083: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
99084: LD_ADDR_VAR 0 4
99088: PUSH
99089: LD_VAR 0 4
99093: PPUSH
99094: LD_VAR 0 7
99098: PPUSH
99099: CALL_OW 3
99103: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
99104: LD_ADDR_VAR 0 16
99108: PUSH
99109: LD_VAR 0 16
99113: PPUSH
99114: LD_VAR 0 7
99118: PPUSH
99119: CALL_OW 3
99123: ST_TO_ADDR
// continue ;
99124: GO 98964
// end ; if f_repair then
99126: LD_VAR 0 22
99130: IFFALSE 99619
// begin if GetType ( group [ i ] ) = unit_vehicle then
99132: LD_VAR 0 4
99136: PUSH
99137: LD_VAR 0 7
99141: ARRAY
99142: PPUSH
99143: CALL_OW 247
99147: PUSH
99148: LD_INT 2
99150: EQUAL
99151: IFFALSE 99341
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
99153: LD_VAR 0 4
99157: PUSH
99158: LD_VAR 0 7
99162: ARRAY
99163: PPUSH
99164: CALL_OW 256
99168: PUSH
99169: LD_INT 700
99171: LESS
99172: PUSH
99173: LD_VAR 0 4
99177: PUSH
99178: LD_VAR 0 7
99182: ARRAY
99183: PUSH
99184: LD_VAR 0 32
99188: IN
99189: NOT
99190: AND
99191: IFFALSE 99215
// to_repair := to_repair union group [ i ] ;
99193: LD_ADDR_VAR 0 32
99197: PUSH
99198: LD_VAR 0 32
99202: PUSH
99203: LD_VAR 0 4
99207: PUSH
99208: LD_VAR 0 7
99212: ARRAY
99213: UNION
99214: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
99215: LD_VAR 0 4
99219: PUSH
99220: LD_VAR 0 7
99224: ARRAY
99225: PPUSH
99226: CALL_OW 256
99230: PUSH
99231: LD_INT 1000
99233: EQUAL
99234: PUSH
99235: LD_VAR 0 4
99239: PUSH
99240: LD_VAR 0 7
99244: ARRAY
99245: PUSH
99246: LD_VAR 0 32
99250: IN
99251: AND
99252: IFFALSE 99276
// to_repair := to_repair diff group [ i ] ;
99254: LD_ADDR_VAR 0 32
99258: PUSH
99259: LD_VAR 0 32
99263: PUSH
99264: LD_VAR 0 4
99268: PUSH
99269: LD_VAR 0 7
99273: ARRAY
99274: DIFF
99275: ST_TO_ADDR
// if group [ i ] in to_repair then
99276: LD_VAR 0 4
99280: PUSH
99281: LD_VAR 0 7
99285: ARRAY
99286: PUSH
99287: LD_VAR 0 32
99291: IN
99292: IFFALSE 99339
// begin if not IsInArea ( group [ i ] , f_repair ) then
99294: LD_VAR 0 4
99298: PUSH
99299: LD_VAR 0 7
99303: ARRAY
99304: PPUSH
99305: LD_VAR 0 22
99309: PPUSH
99310: CALL_OW 308
99314: NOT
99315: IFFALSE 99337
// ComMoveToArea ( group [ i ] , f_repair ) ;
99317: LD_VAR 0 4
99321: PUSH
99322: LD_VAR 0 7
99326: ARRAY
99327: PPUSH
99328: LD_VAR 0 22
99332: PPUSH
99333: CALL_OW 113
// continue ;
99337: GO 98964
// end ; end else
99339: GO 99619
// if group [ i ] in repairs then
99341: LD_VAR 0 4
99345: PUSH
99346: LD_VAR 0 7
99350: ARRAY
99351: PUSH
99352: LD_VAR 0 33
99356: IN
99357: IFFALSE 99619
// begin if IsInUnit ( group [ i ] ) then
99359: LD_VAR 0 4
99363: PUSH
99364: LD_VAR 0 7
99368: ARRAY
99369: PPUSH
99370: CALL_OW 310
99374: IFFALSE 99442
// begin z := IsInUnit ( group [ i ] ) ;
99376: LD_ADDR_VAR 0 13
99380: PUSH
99381: LD_VAR 0 4
99385: PUSH
99386: LD_VAR 0 7
99390: ARRAY
99391: PPUSH
99392: CALL_OW 310
99396: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
99397: LD_VAR 0 13
99401: PUSH
99402: LD_VAR 0 32
99406: IN
99407: PUSH
99408: LD_VAR 0 13
99412: PPUSH
99413: LD_VAR 0 22
99417: PPUSH
99418: CALL_OW 308
99422: AND
99423: IFFALSE 99440
// ComExitVehicle ( group [ i ] ) ;
99425: LD_VAR 0 4
99429: PUSH
99430: LD_VAR 0 7
99434: ARRAY
99435: PPUSH
99436: CALL_OW 121
// end else
99440: GO 99619
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
99442: LD_ADDR_VAR 0 13
99446: PUSH
99447: LD_VAR 0 4
99451: PPUSH
99452: LD_INT 95
99454: PUSH
99455: LD_VAR 0 22
99459: PUSH
99460: EMPTY
99461: LIST
99462: LIST
99463: PUSH
99464: LD_INT 58
99466: PUSH
99467: EMPTY
99468: LIST
99469: PUSH
99470: EMPTY
99471: LIST
99472: LIST
99473: PPUSH
99474: CALL_OW 72
99478: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
99479: LD_VAR 0 4
99483: PUSH
99484: LD_VAR 0 7
99488: ARRAY
99489: PPUSH
99490: CALL_OW 314
99494: NOT
99495: IFFALSE 99617
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
99497: LD_ADDR_VAR 0 10
99501: PUSH
99502: LD_VAR 0 13
99506: PPUSH
99507: LD_VAR 0 4
99511: PUSH
99512: LD_VAR 0 7
99516: ARRAY
99517: PPUSH
99518: CALL_OW 74
99522: ST_TO_ADDR
// if not x then
99523: LD_VAR 0 10
99527: NOT
99528: IFFALSE 99532
// continue ;
99530: GO 98964
// if GetLives ( x ) < 1000 then
99532: LD_VAR 0 10
99536: PPUSH
99537: CALL_OW 256
99541: PUSH
99542: LD_INT 1000
99544: LESS
99545: IFFALSE 99569
// ComRepairVehicle ( group [ i ] , x ) else
99547: LD_VAR 0 4
99551: PUSH
99552: LD_VAR 0 7
99556: ARRAY
99557: PPUSH
99558: LD_VAR 0 10
99562: PPUSH
99563: CALL_OW 129
99567: GO 99617
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
99569: LD_VAR 0 23
99573: PUSH
99574: LD_VAR 0 4
99578: PUSH
99579: LD_VAR 0 7
99583: ARRAY
99584: PPUSH
99585: CALL_OW 256
99589: PUSH
99590: LD_INT 1000
99592: LESS
99593: AND
99594: NOT
99595: IFFALSE 99617
// ComEnterUnit ( group [ i ] , x ) ;
99597: LD_VAR 0 4
99601: PUSH
99602: LD_VAR 0 7
99606: ARRAY
99607: PPUSH
99608: LD_VAR 0 10
99612: PPUSH
99613: CALL_OW 120
// end ; continue ;
99617: GO 98964
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
99619: LD_VAR 0 23
99623: PUSH
99624: LD_VAR 0 4
99628: PUSH
99629: LD_VAR 0 7
99633: ARRAY
99634: PPUSH
99635: CALL_OW 247
99639: PUSH
99640: LD_INT 1
99642: EQUAL
99643: AND
99644: IFFALSE 100122
// begin if group [ i ] in healers then
99646: LD_VAR 0 4
99650: PUSH
99651: LD_VAR 0 7
99655: ARRAY
99656: PUSH
99657: LD_VAR 0 31
99661: IN
99662: IFFALSE 99935
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
99664: LD_VAR 0 4
99668: PUSH
99669: LD_VAR 0 7
99673: ARRAY
99674: PPUSH
99675: LD_VAR 0 23
99679: PPUSH
99680: CALL_OW 308
99684: NOT
99685: PUSH
99686: LD_VAR 0 4
99690: PUSH
99691: LD_VAR 0 7
99695: ARRAY
99696: PPUSH
99697: CALL_OW 314
99701: NOT
99702: AND
99703: IFFALSE 99727
// ComMoveToArea ( group [ i ] , f_heal ) else
99705: LD_VAR 0 4
99709: PUSH
99710: LD_VAR 0 7
99714: ARRAY
99715: PPUSH
99716: LD_VAR 0 23
99720: PPUSH
99721: CALL_OW 113
99725: GO 99933
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
99727: LD_VAR 0 4
99731: PUSH
99732: LD_VAR 0 7
99736: ARRAY
99737: PPUSH
99738: CALL 47610 0 1
99742: PPUSH
99743: CALL_OW 256
99747: PUSH
99748: LD_INT 1000
99750: EQUAL
99751: IFFALSE 99770
// ComStop ( group [ i ] ) else
99753: LD_VAR 0 4
99757: PUSH
99758: LD_VAR 0 7
99762: ARRAY
99763: PPUSH
99764: CALL_OW 141
99768: GO 99933
// if not HasTask ( group [ i ] ) and to_heal then
99770: LD_VAR 0 4
99774: PUSH
99775: LD_VAR 0 7
99779: ARRAY
99780: PPUSH
99781: CALL_OW 314
99785: NOT
99786: PUSH
99787: LD_VAR 0 30
99791: AND
99792: IFFALSE 99933
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
99794: LD_ADDR_VAR 0 13
99798: PUSH
99799: LD_VAR 0 30
99803: PPUSH
99804: LD_INT 3
99806: PUSH
99807: LD_INT 54
99809: PUSH
99810: EMPTY
99811: LIST
99812: PUSH
99813: EMPTY
99814: LIST
99815: LIST
99816: PPUSH
99817: CALL_OW 72
99821: PPUSH
99822: LD_VAR 0 4
99826: PUSH
99827: LD_VAR 0 7
99831: ARRAY
99832: PPUSH
99833: CALL_OW 74
99837: ST_TO_ADDR
// if z then
99838: LD_VAR 0 13
99842: IFFALSE 99933
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
99844: LD_INT 91
99846: PUSH
99847: LD_VAR 0 13
99851: PUSH
99852: LD_INT 10
99854: PUSH
99855: EMPTY
99856: LIST
99857: LIST
99858: LIST
99859: PUSH
99860: LD_INT 81
99862: PUSH
99863: LD_VAR 0 13
99867: PPUSH
99868: CALL_OW 255
99872: PUSH
99873: EMPTY
99874: LIST
99875: LIST
99876: PUSH
99877: EMPTY
99878: LIST
99879: LIST
99880: PPUSH
99881: CALL_OW 69
99885: PUSH
99886: LD_INT 0
99888: EQUAL
99889: IFFALSE 99913
// ComHeal ( group [ i ] , z ) else
99891: LD_VAR 0 4
99895: PUSH
99896: LD_VAR 0 7
99900: ARRAY
99901: PPUSH
99902: LD_VAR 0 13
99906: PPUSH
99907: CALL_OW 128
99911: GO 99933
// ComMoveToArea ( group [ i ] , f_heal ) ;
99913: LD_VAR 0 4
99917: PUSH
99918: LD_VAR 0 7
99922: ARRAY
99923: PPUSH
99924: LD_VAR 0 23
99928: PPUSH
99929: CALL_OW 113
// end ; continue ;
99933: GO 98964
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
99935: LD_VAR 0 4
99939: PUSH
99940: LD_VAR 0 7
99944: ARRAY
99945: PPUSH
99946: CALL_OW 256
99950: PUSH
99951: LD_INT 700
99953: LESS
99954: PUSH
99955: LD_VAR 0 4
99959: PUSH
99960: LD_VAR 0 7
99964: ARRAY
99965: PUSH
99966: LD_VAR 0 30
99970: IN
99971: NOT
99972: AND
99973: IFFALSE 99997
// to_heal := to_heal union group [ i ] ;
99975: LD_ADDR_VAR 0 30
99979: PUSH
99980: LD_VAR 0 30
99984: PUSH
99985: LD_VAR 0 4
99989: PUSH
99990: LD_VAR 0 7
99994: ARRAY
99995: UNION
99996: ST_TO_ADDR
// if group [ i ] in to_heal then
99997: LD_VAR 0 4
100001: PUSH
100002: LD_VAR 0 7
100006: ARRAY
100007: PUSH
100008: LD_VAR 0 30
100012: IN
100013: IFFALSE 100122
// begin if GetLives ( group [ i ] ) = 1000 then
100015: LD_VAR 0 4
100019: PUSH
100020: LD_VAR 0 7
100024: ARRAY
100025: PPUSH
100026: CALL_OW 256
100030: PUSH
100031: LD_INT 1000
100033: EQUAL
100034: IFFALSE 100060
// to_heal := to_heal diff group [ i ] else
100036: LD_ADDR_VAR 0 30
100040: PUSH
100041: LD_VAR 0 30
100045: PUSH
100046: LD_VAR 0 4
100050: PUSH
100051: LD_VAR 0 7
100055: ARRAY
100056: DIFF
100057: ST_TO_ADDR
100058: GO 100122
// begin if not IsInArea ( group [ i ] , to_heal ) then
100060: LD_VAR 0 4
100064: PUSH
100065: LD_VAR 0 7
100069: ARRAY
100070: PPUSH
100071: LD_VAR 0 30
100075: PPUSH
100076: CALL_OW 308
100080: NOT
100081: IFFALSE 100105
// ComMoveToArea ( group [ i ] , f_heal ) else
100083: LD_VAR 0 4
100087: PUSH
100088: LD_VAR 0 7
100092: ARRAY
100093: PPUSH
100094: LD_VAR 0 23
100098: PPUSH
100099: CALL_OW 113
100103: GO 100120
// ComHold ( group [ i ] ) ;
100105: LD_VAR 0 4
100109: PUSH
100110: LD_VAR 0 7
100114: ARRAY
100115: PPUSH
100116: CALL_OW 140
// continue ;
100120: GO 98964
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
100122: LD_VAR 0 4
100126: PUSH
100127: LD_VAR 0 7
100131: ARRAY
100132: PPUSH
100133: LD_INT 10
100135: PPUSH
100136: CALL 46030 0 2
100140: NOT
100141: PUSH
100142: LD_VAR 0 16
100146: PUSH
100147: LD_VAR 0 7
100151: ARRAY
100152: PUSH
100153: EMPTY
100154: EQUAL
100155: NOT
100156: AND
100157: IFFALSE 100423
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
100159: LD_VAR 0 4
100163: PUSH
100164: LD_VAR 0 7
100168: ARRAY
100169: PPUSH
100170: CALL_OW 262
100174: PUSH
100175: LD_INT 1
100177: PUSH
100178: LD_INT 2
100180: PUSH
100181: EMPTY
100182: LIST
100183: LIST
100184: IN
100185: IFFALSE 100226
// if GetFuel ( group [ i ] ) < 10 then
100187: LD_VAR 0 4
100191: PUSH
100192: LD_VAR 0 7
100196: ARRAY
100197: PPUSH
100198: CALL_OW 261
100202: PUSH
100203: LD_INT 10
100205: LESS
100206: IFFALSE 100226
// SetFuel ( group [ i ] , 12 ) ;
100208: LD_VAR 0 4
100212: PUSH
100213: LD_VAR 0 7
100217: ARRAY
100218: PPUSH
100219: LD_INT 12
100221: PPUSH
100222: CALL_OW 240
// if units_path [ i ] then
100226: LD_VAR 0 16
100230: PUSH
100231: LD_VAR 0 7
100235: ARRAY
100236: IFFALSE 100421
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
100238: LD_VAR 0 4
100242: PUSH
100243: LD_VAR 0 7
100247: ARRAY
100248: PPUSH
100249: LD_VAR 0 16
100253: PUSH
100254: LD_VAR 0 7
100258: ARRAY
100259: PUSH
100260: LD_INT 1
100262: ARRAY
100263: PUSH
100264: LD_INT 1
100266: ARRAY
100267: PPUSH
100268: LD_VAR 0 16
100272: PUSH
100273: LD_VAR 0 7
100277: ARRAY
100278: PUSH
100279: LD_INT 1
100281: ARRAY
100282: PUSH
100283: LD_INT 2
100285: ARRAY
100286: PPUSH
100287: CALL_OW 297
100291: PUSH
100292: LD_INT 6
100294: GREATER
100295: IFFALSE 100370
// begin if not HasTask ( group [ i ] ) then
100297: LD_VAR 0 4
100301: PUSH
100302: LD_VAR 0 7
100306: ARRAY
100307: PPUSH
100308: CALL_OW 314
100312: NOT
100313: IFFALSE 100368
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
100315: LD_VAR 0 4
100319: PUSH
100320: LD_VAR 0 7
100324: ARRAY
100325: PPUSH
100326: LD_VAR 0 16
100330: PUSH
100331: LD_VAR 0 7
100335: ARRAY
100336: PUSH
100337: LD_INT 1
100339: ARRAY
100340: PUSH
100341: LD_INT 1
100343: ARRAY
100344: PPUSH
100345: LD_VAR 0 16
100349: PUSH
100350: LD_VAR 0 7
100354: ARRAY
100355: PUSH
100356: LD_INT 1
100358: ARRAY
100359: PUSH
100360: LD_INT 2
100362: ARRAY
100363: PPUSH
100364: CALL_OW 114
// end else
100368: GO 100421
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
100370: LD_ADDR_VAR 0 15
100374: PUSH
100375: LD_VAR 0 16
100379: PUSH
100380: LD_VAR 0 7
100384: ARRAY
100385: PPUSH
100386: LD_INT 1
100388: PPUSH
100389: CALL_OW 3
100393: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
100394: LD_ADDR_VAR 0 16
100398: PUSH
100399: LD_VAR 0 16
100403: PPUSH
100404: LD_VAR 0 7
100408: PPUSH
100409: LD_VAR 0 15
100413: PPUSH
100414: CALL_OW 1
100418: ST_TO_ADDR
// continue ;
100419: GO 98964
// end ; end ; end else
100421: GO 103085
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
100423: LD_ADDR_VAR 0 14
100427: PUSH
100428: LD_INT 81
100430: PUSH
100431: LD_VAR 0 4
100435: PUSH
100436: LD_VAR 0 7
100440: ARRAY
100441: PPUSH
100442: CALL_OW 255
100446: PUSH
100447: EMPTY
100448: LIST
100449: LIST
100450: PPUSH
100451: CALL_OW 69
100455: ST_TO_ADDR
// if not tmp then
100456: LD_VAR 0 14
100460: NOT
100461: IFFALSE 100465
// continue ;
100463: GO 98964
// if f_ignore_area then
100465: LD_VAR 0 17
100469: IFFALSE 100557
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
100471: LD_ADDR_VAR 0 15
100475: PUSH
100476: LD_VAR 0 14
100480: PPUSH
100481: LD_INT 3
100483: PUSH
100484: LD_INT 92
100486: PUSH
100487: LD_VAR 0 17
100491: PUSH
100492: LD_INT 1
100494: ARRAY
100495: PUSH
100496: LD_VAR 0 17
100500: PUSH
100501: LD_INT 2
100503: ARRAY
100504: PUSH
100505: LD_VAR 0 17
100509: PUSH
100510: LD_INT 3
100512: ARRAY
100513: PUSH
100514: EMPTY
100515: LIST
100516: LIST
100517: LIST
100518: LIST
100519: PUSH
100520: EMPTY
100521: LIST
100522: LIST
100523: PPUSH
100524: CALL_OW 72
100528: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100529: LD_VAR 0 14
100533: PUSH
100534: LD_VAR 0 15
100538: DIFF
100539: IFFALSE 100557
// tmp := tmp diff tmp2 ;
100541: LD_ADDR_VAR 0 14
100545: PUSH
100546: LD_VAR 0 14
100550: PUSH
100551: LD_VAR 0 15
100555: DIFF
100556: ST_TO_ADDR
// end ; if not f_murder then
100557: LD_VAR 0 20
100561: NOT
100562: IFFALSE 100620
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
100564: LD_ADDR_VAR 0 15
100568: PUSH
100569: LD_VAR 0 14
100573: PPUSH
100574: LD_INT 3
100576: PUSH
100577: LD_INT 50
100579: PUSH
100580: EMPTY
100581: LIST
100582: PUSH
100583: EMPTY
100584: LIST
100585: LIST
100586: PPUSH
100587: CALL_OW 72
100591: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100592: LD_VAR 0 14
100596: PUSH
100597: LD_VAR 0 15
100601: DIFF
100602: IFFALSE 100620
// tmp := tmp diff tmp2 ;
100604: LD_ADDR_VAR 0 14
100608: PUSH
100609: LD_VAR 0 14
100613: PUSH
100614: LD_VAR 0 15
100618: DIFF
100619: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
100620: LD_ADDR_VAR 0 14
100624: PUSH
100625: LD_VAR 0 4
100629: PUSH
100630: LD_VAR 0 7
100634: ARRAY
100635: PPUSH
100636: LD_VAR 0 14
100640: PPUSH
100641: LD_INT 1
100643: PPUSH
100644: LD_INT 1
100646: PPUSH
100647: CALL 19673 0 4
100651: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
100652: LD_VAR 0 4
100656: PUSH
100657: LD_VAR 0 7
100661: ARRAY
100662: PPUSH
100663: CALL_OW 257
100667: PUSH
100668: LD_INT 1
100670: EQUAL
100671: IFFALSE 101119
// begin if WantPlant ( group [ i ] ) then
100673: LD_VAR 0 4
100677: PUSH
100678: LD_VAR 0 7
100682: ARRAY
100683: PPUSH
100684: CALL 19174 0 1
100688: IFFALSE 100692
// continue ;
100690: GO 98964
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
100692: LD_VAR 0 18
100696: PUSH
100697: LD_VAR 0 4
100701: PUSH
100702: LD_VAR 0 7
100706: ARRAY
100707: PPUSH
100708: CALL_OW 310
100712: NOT
100713: AND
100714: PUSH
100715: LD_VAR 0 14
100719: PUSH
100720: LD_INT 1
100722: ARRAY
100723: PUSH
100724: LD_VAR 0 14
100728: PPUSH
100729: LD_INT 21
100731: PUSH
100732: LD_INT 2
100734: PUSH
100735: EMPTY
100736: LIST
100737: LIST
100738: PUSH
100739: LD_INT 58
100741: PUSH
100742: EMPTY
100743: LIST
100744: PUSH
100745: EMPTY
100746: LIST
100747: LIST
100748: PPUSH
100749: CALL_OW 72
100753: IN
100754: AND
100755: IFFALSE 100791
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
100757: LD_VAR 0 4
100761: PUSH
100762: LD_VAR 0 7
100766: ARRAY
100767: PPUSH
100768: LD_VAR 0 14
100772: PUSH
100773: LD_INT 1
100775: ARRAY
100776: PPUSH
100777: CALL_OW 120
// attacking := true ;
100781: LD_ADDR_VAR 0 29
100785: PUSH
100786: LD_INT 1
100788: ST_TO_ADDR
// continue ;
100789: GO 98964
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
100791: LD_VAR 0 26
100795: PUSH
100796: LD_VAR 0 4
100800: PUSH
100801: LD_VAR 0 7
100805: ARRAY
100806: PPUSH
100807: CALL_OW 257
100811: PUSH
100812: LD_INT 1
100814: EQUAL
100815: AND
100816: PUSH
100817: LD_VAR 0 4
100821: PUSH
100822: LD_VAR 0 7
100826: ARRAY
100827: PPUSH
100828: CALL_OW 256
100832: PUSH
100833: LD_INT 800
100835: LESS
100836: AND
100837: PUSH
100838: LD_VAR 0 4
100842: PUSH
100843: LD_VAR 0 7
100847: ARRAY
100848: PPUSH
100849: CALL_OW 318
100853: NOT
100854: AND
100855: IFFALSE 100872
// ComCrawl ( group [ i ] ) ;
100857: LD_VAR 0 4
100861: PUSH
100862: LD_VAR 0 7
100866: ARRAY
100867: PPUSH
100868: CALL_OW 137
// if f_mines then
100872: LD_VAR 0 21
100876: IFFALSE 101119
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
100878: LD_VAR 0 14
100882: PUSH
100883: LD_INT 1
100885: ARRAY
100886: PPUSH
100887: CALL_OW 247
100891: PUSH
100892: LD_INT 3
100894: EQUAL
100895: PUSH
100896: LD_VAR 0 14
100900: PUSH
100901: LD_INT 1
100903: ARRAY
100904: PUSH
100905: LD_VAR 0 27
100909: IN
100910: NOT
100911: AND
100912: IFFALSE 101119
// begin x := GetX ( tmp [ 1 ] ) ;
100914: LD_ADDR_VAR 0 10
100918: PUSH
100919: LD_VAR 0 14
100923: PUSH
100924: LD_INT 1
100926: ARRAY
100927: PPUSH
100928: CALL_OW 250
100932: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
100933: LD_ADDR_VAR 0 11
100937: PUSH
100938: LD_VAR 0 14
100942: PUSH
100943: LD_INT 1
100945: ARRAY
100946: PPUSH
100947: CALL_OW 251
100951: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
100952: LD_ADDR_VAR 0 12
100956: PUSH
100957: LD_VAR 0 4
100961: PUSH
100962: LD_VAR 0 7
100966: ARRAY
100967: PPUSH
100968: CALL 46115 0 1
100972: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
100973: LD_VAR 0 4
100977: PUSH
100978: LD_VAR 0 7
100982: ARRAY
100983: PPUSH
100984: LD_VAR 0 10
100988: PPUSH
100989: LD_VAR 0 11
100993: PPUSH
100994: LD_VAR 0 14
100998: PUSH
100999: LD_INT 1
101001: ARRAY
101002: PPUSH
101003: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
101007: LD_VAR 0 4
101011: PUSH
101012: LD_VAR 0 7
101016: ARRAY
101017: PPUSH
101018: LD_VAR 0 10
101022: PPUSH
101023: LD_VAR 0 12
101027: PPUSH
101028: LD_INT 7
101030: PPUSH
101031: CALL_OW 272
101035: PPUSH
101036: LD_VAR 0 11
101040: PPUSH
101041: LD_VAR 0 12
101045: PPUSH
101046: LD_INT 7
101048: PPUSH
101049: CALL_OW 273
101053: PPUSH
101054: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
101058: LD_VAR 0 4
101062: PUSH
101063: LD_VAR 0 7
101067: ARRAY
101068: PPUSH
101069: LD_INT 71
101071: PPUSH
101072: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
101076: LD_ADDR_VAR 0 27
101080: PUSH
101081: LD_VAR 0 27
101085: PPUSH
101086: LD_VAR 0 27
101090: PUSH
101091: LD_INT 1
101093: PLUS
101094: PPUSH
101095: LD_VAR 0 14
101099: PUSH
101100: LD_INT 1
101102: ARRAY
101103: PPUSH
101104: CALL_OW 1
101108: ST_TO_ADDR
// attacking := true ;
101109: LD_ADDR_VAR 0 29
101113: PUSH
101114: LD_INT 1
101116: ST_TO_ADDR
// continue ;
101117: GO 98964
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
101119: LD_VAR 0 4
101123: PUSH
101124: LD_VAR 0 7
101128: ARRAY
101129: PPUSH
101130: CALL_OW 257
101134: PUSH
101135: LD_INT 17
101137: EQUAL
101138: PUSH
101139: LD_VAR 0 4
101143: PUSH
101144: LD_VAR 0 7
101148: ARRAY
101149: PPUSH
101150: CALL_OW 110
101154: PUSH
101155: LD_INT 71
101157: EQUAL
101158: NOT
101159: AND
101160: IFFALSE 101306
// begin attacking := false ;
101162: LD_ADDR_VAR 0 29
101166: PUSH
101167: LD_INT 0
101169: ST_TO_ADDR
// k := 5 ;
101170: LD_ADDR_VAR 0 9
101174: PUSH
101175: LD_INT 5
101177: ST_TO_ADDR
// if tmp < k then
101178: LD_VAR 0 14
101182: PUSH
101183: LD_VAR 0 9
101187: LESS
101188: IFFALSE 101200
// k := tmp ;
101190: LD_ADDR_VAR 0 9
101194: PUSH
101195: LD_VAR 0 14
101199: ST_TO_ADDR
// for j = 1 to k do
101200: LD_ADDR_VAR 0 8
101204: PUSH
101205: DOUBLE
101206: LD_INT 1
101208: DEC
101209: ST_TO_ADDR
101210: LD_VAR 0 9
101214: PUSH
101215: FOR_TO
101216: IFFALSE 101304
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
101218: LD_VAR 0 14
101222: PUSH
101223: LD_VAR 0 8
101227: ARRAY
101228: PUSH
101229: LD_VAR 0 14
101233: PPUSH
101234: LD_INT 58
101236: PUSH
101237: EMPTY
101238: LIST
101239: PPUSH
101240: CALL_OW 72
101244: IN
101245: NOT
101246: IFFALSE 101302
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101248: LD_VAR 0 4
101252: PUSH
101253: LD_VAR 0 7
101257: ARRAY
101258: PPUSH
101259: LD_VAR 0 14
101263: PUSH
101264: LD_VAR 0 8
101268: ARRAY
101269: PPUSH
101270: CALL_OW 115
// attacking := true ;
101274: LD_ADDR_VAR 0 29
101278: PUSH
101279: LD_INT 1
101281: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
101282: LD_VAR 0 4
101286: PUSH
101287: LD_VAR 0 7
101291: ARRAY
101292: PPUSH
101293: LD_INT 71
101295: PPUSH
101296: CALL_OW 109
// continue ;
101300: GO 101215
// end ; end ;
101302: GO 101215
101304: POP
101305: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
101306: LD_VAR 0 4
101310: PUSH
101311: LD_VAR 0 7
101315: ARRAY
101316: PPUSH
101317: CALL_OW 257
101321: PUSH
101322: LD_INT 8
101324: EQUAL
101325: PUSH
101326: LD_VAR 0 4
101330: PUSH
101331: LD_VAR 0 7
101335: ARRAY
101336: PPUSH
101337: CALL_OW 264
101341: PUSH
101342: LD_INT 28
101344: PUSH
101345: LD_INT 45
101347: PUSH
101348: LD_INT 7
101350: PUSH
101351: LD_INT 47
101353: PUSH
101354: EMPTY
101355: LIST
101356: LIST
101357: LIST
101358: LIST
101359: IN
101360: OR
101361: IFFALSE 101617
// begin attacking := false ;
101363: LD_ADDR_VAR 0 29
101367: PUSH
101368: LD_INT 0
101370: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
101371: LD_VAR 0 14
101375: PUSH
101376: LD_INT 1
101378: ARRAY
101379: PPUSH
101380: CALL_OW 266
101384: PUSH
101385: LD_INT 32
101387: PUSH
101388: LD_INT 31
101390: PUSH
101391: LD_INT 33
101393: PUSH
101394: LD_INT 4
101396: PUSH
101397: LD_INT 5
101399: PUSH
101400: EMPTY
101401: LIST
101402: LIST
101403: LIST
101404: LIST
101405: LIST
101406: IN
101407: IFFALSE 101593
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
101409: LD_ADDR_VAR 0 9
101413: PUSH
101414: LD_VAR 0 14
101418: PUSH
101419: LD_INT 1
101421: ARRAY
101422: PPUSH
101423: CALL_OW 266
101427: PPUSH
101428: LD_VAR 0 14
101432: PUSH
101433: LD_INT 1
101435: ARRAY
101436: PPUSH
101437: CALL_OW 250
101441: PPUSH
101442: LD_VAR 0 14
101446: PUSH
101447: LD_INT 1
101449: ARRAY
101450: PPUSH
101451: CALL_OW 251
101455: PPUSH
101456: LD_VAR 0 14
101460: PUSH
101461: LD_INT 1
101463: ARRAY
101464: PPUSH
101465: CALL_OW 254
101469: PPUSH
101470: LD_VAR 0 14
101474: PUSH
101475: LD_INT 1
101477: ARRAY
101478: PPUSH
101479: CALL_OW 248
101483: PPUSH
101484: LD_INT 0
101486: PPUSH
101487: CALL 27485 0 6
101491: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
101492: LD_ADDR_VAR 0 8
101496: PUSH
101497: LD_VAR 0 4
101501: PUSH
101502: LD_VAR 0 7
101506: ARRAY
101507: PPUSH
101508: LD_VAR 0 9
101512: PPUSH
101513: CALL 46155 0 2
101517: ST_TO_ADDR
// if j then
101518: LD_VAR 0 8
101522: IFFALSE 101591
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
101524: LD_VAR 0 8
101528: PUSH
101529: LD_INT 1
101531: ARRAY
101532: PPUSH
101533: LD_VAR 0 8
101537: PUSH
101538: LD_INT 2
101540: ARRAY
101541: PPUSH
101542: CALL_OW 488
101546: IFFALSE 101591
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
101548: LD_VAR 0 4
101552: PUSH
101553: LD_VAR 0 7
101557: ARRAY
101558: PPUSH
101559: LD_VAR 0 8
101563: PUSH
101564: LD_INT 1
101566: ARRAY
101567: PPUSH
101568: LD_VAR 0 8
101572: PUSH
101573: LD_INT 2
101575: ARRAY
101576: PPUSH
101577: CALL_OW 116
// attacking := true ;
101581: LD_ADDR_VAR 0 29
101585: PUSH
101586: LD_INT 1
101588: ST_TO_ADDR
// continue ;
101589: GO 98964
// end ; end else
101591: GO 101617
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101593: LD_VAR 0 4
101597: PUSH
101598: LD_VAR 0 7
101602: ARRAY
101603: PPUSH
101604: LD_VAR 0 14
101608: PUSH
101609: LD_INT 1
101611: ARRAY
101612: PPUSH
101613: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
101617: LD_VAR 0 4
101621: PUSH
101622: LD_VAR 0 7
101626: ARRAY
101627: PPUSH
101628: CALL_OW 265
101632: PUSH
101633: LD_INT 11
101635: EQUAL
101636: IFFALSE 101914
// begin k := 10 ;
101638: LD_ADDR_VAR 0 9
101642: PUSH
101643: LD_INT 10
101645: ST_TO_ADDR
// x := 0 ;
101646: LD_ADDR_VAR 0 10
101650: PUSH
101651: LD_INT 0
101653: ST_TO_ADDR
// if tmp < k then
101654: LD_VAR 0 14
101658: PUSH
101659: LD_VAR 0 9
101663: LESS
101664: IFFALSE 101676
// k := tmp ;
101666: LD_ADDR_VAR 0 9
101670: PUSH
101671: LD_VAR 0 14
101675: ST_TO_ADDR
// for j = k downto 1 do
101676: LD_ADDR_VAR 0 8
101680: PUSH
101681: DOUBLE
101682: LD_VAR 0 9
101686: INC
101687: ST_TO_ADDR
101688: LD_INT 1
101690: PUSH
101691: FOR_DOWNTO
101692: IFFALSE 101767
// begin if GetType ( tmp [ j ] ) = unit_human then
101694: LD_VAR 0 14
101698: PUSH
101699: LD_VAR 0 8
101703: ARRAY
101704: PPUSH
101705: CALL_OW 247
101709: PUSH
101710: LD_INT 1
101712: EQUAL
101713: IFFALSE 101765
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
101715: LD_VAR 0 4
101719: PUSH
101720: LD_VAR 0 7
101724: ARRAY
101725: PPUSH
101726: LD_VAR 0 14
101730: PUSH
101731: LD_VAR 0 8
101735: ARRAY
101736: PPUSH
101737: CALL 46426 0 2
// x := tmp [ j ] ;
101741: LD_ADDR_VAR 0 10
101745: PUSH
101746: LD_VAR 0 14
101750: PUSH
101751: LD_VAR 0 8
101755: ARRAY
101756: ST_TO_ADDR
// attacking := true ;
101757: LD_ADDR_VAR 0 29
101761: PUSH
101762: LD_INT 1
101764: ST_TO_ADDR
// end ; end ;
101765: GO 101691
101767: POP
101768: POP
// if not x then
101769: LD_VAR 0 10
101773: NOT
101774: IFFALSE 101914
// begin attacking := true ;
101776: LD_ADDR_VAR 0 29
101780: PUSH
101781: LD_INT 1
101783: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
101784: LD_VAR 0 4
101788: PUSH
101789: LD_VAR 0 7
101793: ARRAY
101794: PPUSH
101795: CALL_OW 250
101799: PPUSH
101800: LD_VAR 0 4
101804: PUSH
101805: LD_VAR 0 7
101809: ARRAY
101810: PPUSH
101811: CALL_OW 251
101815: PPUSH
101816: CALL_OW 546
101820: PUSH
101821: LD_INT 2
101823: ARRAY
101824: PUSH
101825: LD_VAR 0 14
101829: PUSH
101830: LD_INT 1
101832: ARRAY
101833: PPUSH
101834: CALL_OW 250
101838: PPUSH
101839: LD_VAR 0 14
101843: PUSH
101844: LD_INT 1
101846: ARRAY
101847: PPUSH
101848: CALL_OW 251
101852: PPUSH
101853: CALL_OW 546
101857: PUSH
101858: LD_INT 2
101860: ARRAY
101861: EQUAL
101862: IFFALSE 101890
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
101864: LD_VAR 0 4
101868: PUSH
101869: LD_VAR 0 7
101873: ARRAY
101874: PPUSH
101875: LD_VAR 0 14
101879: PUSH
101880: LD_INT 1
101882: ARRAY
101883: PPUSH
101884: CALL 46426 0 2
101888: GO 101914
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101890: LD_VAR 0 4
101894: PUSH
101895: LD_VAR 0 7
101899: ARRAY
101900: PPUSH
101901: LD_VAR 0 14
101905: PUSH
101906: LD_INT 1
101908: ARRAY
101909: PPUSH
101910: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
101914: LD_VAR 0 4
101918: PUSH
101919: LD_VAR 0 7
101923: ARRAY
101924: PPUSH
101925: CALL_OW 264
101929: PUSH
101930: LD_INT 29
101932: EQUAL
101933: IFFALSE 102299
// begin if WantsToAttack ( group [ i ] ) in bombed then
101935: LD_VAR 0 4
101939: PUSH
101940: LD_VAR 0 7
101944: ARRAY
101945: PPUSH
101946: CALL_OW 319
101950: PUSH
101951: LD_VAR 0 28
101955: IN
101956: IFFALSE 101960
// continue ;
101958: GO 98964
// k := 8 ;
101960: LD_ADDR_VAR 0 9
101964: PUSH
101965: LD_INT 8
101967: ST_TO_ADDR
// x := 0 ;
101968: LD_ADDR_VAR 0 10
101972: PUSH
101973: LD_INT 0
101975: ST_TO_ADDR
// if tmp < k then
101976: LD_VAR 0 14
101980: PUSH
101981: LD_VAR 0 9
101985: LESS
101986: IFFALSE 101998
// k := tmp ;
101988: LD_ADDR_VAR 0 9
101992: PUSH
101993: LD_VAR 0 14
101997: ST_TO_ADDR
// for j = 1 to k do
101998: LD_ADDR_VAR 0 8
102002: PUSH
102003: DOUBLE
102004: LD_INT 1
102006: DEC
102007: ST_TO_ADDR
102008: LD_VAR 0 9
102012: PUSH
102013: FOR_TO
102014: IFFALSE 102146
// begin if GetType ( tmp [ j ] ) = unit_building then
102016: LD_VAR 0 14
102020: PUSH
102021: LD_VAR 0 8
102025: ARRAY
102026: PPUSH
102027: CALL_OW 247
102031: PUSH
102032: LD_INT 3
102034: EQUAL
102035: IFFALSE 102144
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
102037: LD_VAR 0 14
102041: PUSH
102042: LD_VAR 0 8
102046: ARRAY
102047: PUSH
102048: LD_VAR 0 28
102052: IN
102053: NOT
102054: PUSH
102055: LD_VAR 0 14
102059: PUSH
102060: LD_VAR 0 8
102064: ARRAY
102065: PPUSH
102066: CALL_OW 313
102070: AND
102071: IFFALSE 102144
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102073: LD_VAR 0 4
102077: PUSH
102078: LD_VAR 0 7
102082: ARRAY
102083: PPUSH
102084: LD_VAR 0 14
102088: PUSH
102089: LD_VAR 0 8
102093: ARRAY
102094: PPUSH
102095: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
102099: LD_ADDR_VAR 0 28
102103: PUSH
102104: LD_VAR 0 28
102108: PPUSH
102109: LD_VAR 0 28
102113: PUSH
102114: LD_INT 1
102116: PLUS
102117: PPUSH
102118: LD_VAR 0 14
102122: PUSH
102123: LD_VAR 0 8
102127: ARRAY
102128: PPUSH
102129: CALL_OW 1
102133: ST_TO_ADDR
// attacking := true ;
102134: LD_ADDR_VAR 0 29
102138: PUSH
102139: LD_INT 1
102141: ST_TO_ADDR
// break ;
102142: GO 102146
// end ; end ;
102144: GO 102013
102146: POP
102147: POP
// if not attacking and f_attack_depot then
102148: LD_VAR 0 29
102152: NOT
102153: PUSH
102154: LD_VAR 0 25
102158: AND
102159: IFFALSE 102254
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
102161: LD_ADDR_VAR 0 13
102165: PUSH
102166: LD_VAR 0 14
102170: PPUSH
102171: LD_INT 2
102173: PUSH
102174: LD_INT 30
102176: PUSH
102177: LD_INT 0
102179: PUSH
102180: EMPTY
102181: LIST
102182: LIST
102183: PUSH
102184: LD_INT 30
102186: PUSH
102187: LD_INT 1
102189: PUSH
102190: EMPTY
102191: LIST
102192: LIST
102193: PUSH
102194: EMPTY
102195: LIST
102196: LIST
102197: LIST
102198: PPUSH
102199: CALL_OW 72
102203: ST_TO_ADDR
// if z then
102204: LD_VAR 0 13
102208: IFFALSE 102254
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
102210: LD_VAR 0 4
102214: PUSH
102215: LD_VAR 0 7
102219: ARRAY
102220: PPUSH
102221: LD_VAR 0 13
102225: PPUSH
102226: LD_VAR 0 4
102230: PUSH
102231: LD_VAR 0 7
102235: ARRAY
102236: PPUSH
102237: CALL_OW 74
102241: PPUSH
102242: CALL_OW 115
// attacking := true ;
102246: LD_ADDR_VAR 0 29
102250: PUSH
102251: LD_INT 1
102253: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
102254: LD_VAR 0 4
102258: PUSH
102259: LD_VAR 0 7
102263: ARRAY
102264: PPUSH
102265: CALL_OW 256
102269: PUSH
102270: LD_INT 500
102272: LESS
102273: IFFALSE 102299
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102275: LD_VAR 0 4
102279: PUSH
102280: LD_VAR 0 7
102284: ARRAY
102285: PPUSH
102286: LD_VAR 0 14
102290: PUSH
102291: LD_INT 1
102293: ARRAY
102294: PPUSH
102295: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
102299: LD_VAR 0 4
102303: PUSH
102304: LD_VAR 0 7
102308: ARRAY
102309: PPUSH
102310: CALL_OW 264
102314: PUSH
102315: LD_INT 49
102317: EQUAL
102318: IFFALSE 102439
// begin if not HasTask ( group [ i ] ) then
102320: LD_VAR 0 4
102324: PUSH
102325: LD_VAR 0 7
102329: ARRAY
102330: PPUSH
102331: CALL_OW 314
102335: NOT
102336: IFFALSE 102439
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
102338: LD_ADDR_VAR 0 9
102342: PUSH
102343: LD_INT 81
102345: PUSH
102346: LD_VAR 0 4
102350: PUSH
102351: LD_VAR 0 7
102355: ARRAY
102356: PPUSH
102357: CALL_OW 255
102361: PUSH
102362: EMPTY
102363: LIST
102364: LIST
102365: PPUSH
102366: CALL_OW 69
102370: PPUSH
102371: LD_VAR 0 4
102375: PUSH
102376: LD_VAR 0 7
102380: ARRAY
102381: PPUSH
102382: CALL_OW 74
102386: ST_TO_ADDR
// if k then
102387: LD_VAR 0 9
102391: IFFALSE 102439
// if GetDistUnits ( group [ i ] , k ) > 10 then
102393: LD_VAR 0 4
102397: PUSH
102398: LD_VAR 0 7
102402: ARRAY
102403: PPUSH
102404: LD_VAR 0 9
102408: PPUSH
102409: CALL_OW 296
102413: PUSH
102414: LD_INT 10
102416: GREATER
102417: IFFALSE 102439
// ComMoveUnit ( group [ i ] , k ) ;
102419: LD_VAR 0 4
102423: PUSH
102424: LD_VAR 0 7
102428: ARRAY
102429: PPUSH
102430: LD_VAR 0 9
102434: PPUSH
102435: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102439: LD_VAR 0 4
102443: PUSH
102444: LD_VAR 0 7
102448: ARRAY
102449: PPUSH
102450: CALL_OW 256
102454: PUSH
102455: LD_INT 250
102457: LESS
102458: PUSH
102459: LD_VAR 0 4
102463: PUSH
102464: LD_VAR 0 7
102468: ARRAY
102469: PUSH
102470: LD_INT 21
102472: PUSH
102473: LD_INT 2
102475: PUSH
102476: EMPTY
102477: LIST
102478: LIST
102479: PUSH
102480: LD_INT 23
102482: PUSH
102483: LD_INT 2
102485: PUSH
102486: EMPTY
102487: LIST
102488: LIST
102489: PUSH
102490: EMPTY
102491: LIST
102492: LIST
102493: PPUSH
102494: CALL_OW 69
102498: IN
102499: AND
102500: IFFALSE 102625
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
102502: LD_ADDR_VAR 0 9
102506: PUSH
102507: LD_OWVAR 3
102511: PUSH
102512: LD_VAR 0 4
102516: PUSH
102517: LD_VAR 0 7
102521: ARRAY
102522: DIFF
102523: PPUSH
102524: LD_VAR 0 4
102528: PUSH
102529: LD_VAR 0 7
102533: ARRAY
102534: PPUSH
102535: CALL_OW 74
102539: ST_TO_ADDR
// if not k then
102540: LD_VAR 0 9
102544: NOT
102545: IFFALSE 102549
// continue ;
102547: GO 98964
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
102549: LD_VAR 0 9
102553: PUSH
102554: LD_INT 81
102556: PUSH
102557: LD_VAR 0 4
102561: PUSH
102562: LD_VAR 0 7
102566: ARRAY
102567: PPUSH
102568: CALL_OW 255
102572: PUSH
102573: EMPTY
102574: LIST
102575: LIST
102576: PPUSH
102577: CALL_OW 69
102581: IN
102582: PUSH
102583: LD_VAR 0 9
102587: PPUSH
102588: LD_VAR 0 4
102592: PUSH
102593: LD_VAR 0 7
102597: ARRAY
102598: PPUSH
102599: CALL_OW 296
102603: PUSH
102604: LD_INT 5
102606: LESS
102607: AND
102608: IFFALSE 102625
// ComAutodestruct ( group [ i ] ) ;
102610: LD_VAR 0 4
102614: PUSH
102615: LD_VAR 0 7
102619: ARRAY
102620: PPUSH
102621: CALL 46324 0 1
// end ; if f_attack_depot then
102625: LD_VAR 0 25
102629: IFFALSE 102741
// begin k := 6 ;
102631: LD_ADDR_VAR 0 9
102635: PUSH
102636: LD_INT 6
102638: ST_TO_ADDR
// if tmp < k then
102639: LD_VAR 0 14
102643: PUSH
102644: LD_VAR 0 9
102648: LESS
102649: IFFALSE 102661
// k := tmp ;
102651: LD_ADDR_VAR 0 9
102655: PUSH
102656: LD_VAR 0 14
102660: ST_TO_ADDR
// for j = 1 to k do
102661: LD_ADDR_VAR 0 8
102665: PUSH
102666: DOUBLE
102667: LD_INT 1
102669: DEC
102670: ST_TO_ADDR
102671: LD_VAR 0 9
102675: PUSH
102676: FOR_TO
102677: IFFALSE 102739
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
102679: LD_VAR 0 8
102683: PPUSH
102684: CALL_OW 266
102688: PUSH
102689: LD_INT 0
102691: PUSH
102692: LD_INT 1
102694: PUSH
102695: EMPTY
102696: LIST
102697: LIST
102698: IN
102699: IFFALSE 102737
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102701: LD_VAR 0 4
102705: PUSH
102706: LD_VAR 0 7
102710: ARRAY
102711: PPUSH
102712: LD_VAR 0 14
102716: PUSH
102717: LD_VAR 0 8
102721: ARRAY
102722: PPUSH
102723: CALL_OW 115
// attacking := true ;
102727: LD_ADDR_VAR 0 29
102731: PUSH
102732: LD_INT 1
102734: ST_TO_ADDR
// break ;
102735: GO 102739
// end ;
102737: GO 102676
102739: POP
102740: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
102741: LD_VAR 0 4
102745: PUSH
102746: LD_VAR 0 7
102750: ARRAY
102751: PPUSH
102752: CALL_OW 302
102756: PUSH
102757: LD_VAR 0 29
102761: NOT
102762: AND
102763: IFFALSE 103085
// begin if GetTag ( group [ i ] ) = 71 then
102765: LD_VAR 0 4
102769: PUSH
102770: LD_VAR 0 7
102774: ARRAY
102775: PPUSH
102776: CALL_OW 110
102780: PUSH
102781: LD_INT 71
102783: EQUAL
102784: IFFALSE 102825
// begin if HasTask ( group [ i ] ) then
102786: LD_VAR 0 4
102790: PUSH
102791: LD_VAR 0 7
102795: ARRAY
102796: PPUSH
102797: CALL_OW 314
102801: IFFALSE 102807
// continue else
102803: GO 98964
102805: GO 102825
// SetTag ( group [ i ] , 0 ) ;
102807: LD_VAR 0 4
102811: PUSH
102812: LD_VAR 0 7
102816: ARRAY
102817: PPUSH
102818: LD_INT 0
102820: PPUSH
102821: CALL_OW 109
// end ; k := 8 ;
102825: LD_ADDR_VAR 0 9
102829: PUSH
102830: LD_INT 8
102832: ST_TO_ADDR
// x := 0 ;
102833: LD_ADDR_VAR 0 10
102837: PUSH
102838: LD_INT 0
102840: ST_TO_ADDR
// if tmp < k then
102841: LD_VAR 0 14
102845: PUSH
102846: LD_VAR 0 9
102850: LESS
102851: IFFALSE 102863
// k := tmp ;
102853: LD_ADDR_VAR 0 9
102857: PUSH
102858: LD_VAR 0 14
102862: ST_TO_ADDR
// for j = 1 to k do
102863: LD_ADDR_VAR 0 8
102867: PUSH
102868: DOUBLE
102869: LD_INT 1
102871: DEC
102872: ST_TO_ADDR
102873: LD_VAR 0 9
102877: PUSH
102878: FOR_TO
102879: IFFALSE 102977
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
102881: LD_VAR 0 14
102885: PUSH
102886: LD_VAR 0 8
102890: ARRAY
102891: PPUSH
102892: CALL_OW 247
102896: PUSH
102897: LD_INT 1
102899: EQUAL
102900: PUSH
102901: LD_VAR 0 14
102905: PUSH
102906: LD_VAR 0 8
102910: ARRAY
102911: PPUSH
102912: CALL_OW 256
102916: PUSH
102917: LD_INT 250
102919: LESS
102920: PUSH
102921: LD_VAR 0 20
102925: AND
102926: PUSH
102927: LD_VAR 0 20
102931: NOT
102932: PUSH
102933: LD_VAR 0 14
102937: PUSH
102938: LD_VAR 0 8
102942: ARRAY
102943: PPUSH
102944: CALL_OW 256
102948: PUSH
102949: LD_INT 250
102951: GREATEREQUAL
102952: AND
102953: OR
102954: AND
102955: IFFALSE 102975
// begin x := tmp [ j ] ;
102957: LD_ADDR_VAR 0 10
102961: PUSH
102962: LD_VAR 0 14
102966: PUSH
102967: LD_VAR 0 8
102971: ARRAY
102972: ST_TO_ADDR
// break ;
102973: GO 102977
// end ;
102975: GO 102878
102977: POP
102978: POP
// if x then
102979: LD_VAR 0 10
102983: IFFALSE 103007
// ComAttackUnit ( group [ i ] , x ) else
102985: LD_VAR 0 4
102989: PUSH
102990: LD_VAR 0 7
102994: ARRAY
102995: PPUSH
102996: LD_VAR 0 10
103000: PPUSH
103001: CALL_OW 115
103005: GO 103031
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103007: LD_VAR 0 4
103011: PUSH
103012: LD_VAR 0 7
103016: ARRAY
103017: PPUSH
103018: LD_VAR 0 14
103022: PUSH
103023: LD_INT 1
103025: ARRAY
103026: PPUSH
103027: CALL_OW 115
// if not HasTask ( group [ i ] ) then
103031: LD_VAR 0 4
103035: PUSH
103036: LD_VAR 0 7
103040: ARRAY
103041: PPUSH
103042: CALL_OW 314
103046: NOT
103047: IFFALSE 103085
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
103049: LD_VAR 0 4
103053: PUSH
103054: LD_VAR 0 7
103058: ARRAY
103059: PPUSH
103060: LD_VAR 0 14
103064: PPUSH
103065: LD_VAR 0 4
103069: PUSH
103070: LD_VAR 0 7
103074: ARRAY
103075: PPUSH
103076: CALL_OW 74
103080: PPUSH
103081: CALL_OW 115
// end ; end ; end ;
103085: GO 98964
103087: POP
103088: POP
// wait ( 0 0$2 ) ;
103089: LD_INT 70
103091: PPUSH
103092: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
103096: LD_VAR 0 4
103100: NOT
103101: PUSH
103102: LD_VAR 0 4
103106: PUSH
103107: EMPTY
103108: EQUAL
103109: OR
103110: PUSH
103111: LD_INT 81
103113: PUSH
103114: LD_VAR 0 35
103118: PUSH
103119: EMPTY
103120: LIST
103121: LIST
103122: PPUSH
103123: CALL_OW 69
103127: NOT
103128: OR
103129: IFFALSE 98949
// end ;
103131: LD_VAR 0 2
103135: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
103136: LD_INT 0
103138: PPUSH
103139: PPUSH
103140: PPUSH
103141: PPUSH
103142: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
103143: LD_VAR 0 1
103147: NOT
103148: PUSH
103149: LD_EXP 59
103153: PUSH
103154: LD_VAR 0 1
103158: ARRAY
103159: NOT
103160: OR
103161: PUSH
103162: LD_VAR 0 2
103166: NOT
103167: OR
103168: PUSH
103169: LD_VAR 0 3
103173: NOT
103174: OR
103175: IFFALSE 103179
// exit ;
103177: GO 103692
// side := mc_sides [ base ] ;
103179: LD_ADDR_VAR 0 6
103183: PUSH
103184: LD_EXP 85
103188: PUSH
103189: LD_VAR 0 1
103193: ARRAY
103194: ST_TO_ADDR
// if not side then
103195: LD_VAR 0 6
103199: NOT
103200: IFFALSE 103204
// exit ;
103202: GO 103692
// for i in solds do
103204: LD_ADDR_VAR 0 7
103208: PUSH
103209: LD_VAR 0 2
103213: PUSH
103214: FOR_IN
103215: IFFALSE 103276
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
103217: LD_VAR 0 7
103221: PPUSH
103222: CALL_OW 310
103226: PPUSH
103227: CALL_OW 266
103231: PUSH
103232: LD_INT 32
103234: PUSH
103235: LD_INT 31
103237: PUSH
103238: EMPTY
103239: LIST
103240: LIST
103241: IN
103242: IFFALSE 103262
// solds := solds diff i else
103244: LD_ADDR_VAR 0 2
103248: PUSH
103249: LD_VAR 0 2
103253: PUSH
103254: LD_VAR 0 7
103258: DIFF
103259: ST_TO_ADDR
103260: GO 103274
// SetTag ( i , 18 ) ;
103262: LD_VAR 0 7
103266: PPUSH
103267: LD_INT 18
103269: PPUSH
103270: CALL_OW 109
103274: GO 103214
103276: POP
103277: POP
// if not solds then
103278: LD_VAR 0 2
103282: NOT
103283: IFFALSE 103287
// exit ;
103285: GO 103692
// repeat wait ( 0 0$1 ) ;
103287: LD_INT 35
103289: PPUSH
103290: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
103294: LD_ADDR_VAR 0 5
103298: PUSH
103299: LD_VAR 0 6
103303: PPUSH
103304: LD_VAR 0 3
103308: PPUSH
103309: CALL 16039 0 2
103313: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
103314: LD_EXP 59
103318: PUSH
103319: LD_VAR 0 1
103323: ARRAY
103324: NOT
103325: PUSH
103326: LD_EXP 59
103330: PUSH
103331: LD_VAR 0 1
103335: ARRAY
103336: PUSH
103337: EMPTY
103338: EQUAL
103339: OR
103340: IFFALSE 103377
// begin for i in solds do
103342: LD_ADDR_VAR 0 7
103346: PUSH
103347: LD_VAR 0 2
103351: PUSH
103352: FOR_IN
103353: IFFALSE 103366
// ComStop ( i ) ;
103355: LD_VAR 0 7
103359: PPUSH
103360: CALL_OW 141
103364: GO 103352
103366: POP
103367: POP
// solds := [ ] ;
103368: LD_ADDR_VAR 0 2
103372: PUSH
103373: EMPTY
103374: ST_TO_ADDR
// exit ;
103375: GO 103692
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
103377: LD_VAR 0 5
103381: NOT
103382: PUSH
103383: LD_VAR 0 5
103387: PUSH
103388: LD_INT 3
103390: GREATER
103391: OR
103392: PUSH
103393: LD_EXP 81
103397: PUSH
103398: LD_VAR 0 1
103402: ARRAY
103403: OR
103404: IFFALSE 103445
// begin for i in solds do
103406: LD_ADDR_VAR 0 7
103410: PUSH
103411: LD_VAR 0 2
103415: PUSH
103416: FOR_IN
103417: IFFALSE 103441
// if HasTask ( i ) then
103419: LD_VAR 0 7
103423: PPUSH
103424: CALL_OW 314
103428: IFFALSE 103439
// ComStop ( i ) ;
103430: LD_VAR 0 7
103434: PPUSH
103435: CALL_OW 141
103439: GO 103416
103441: POP
103442: POP
// break ;
103443: GO 103680
// end ; for i in solds do
103445: LD_ADDR_VAR 0 7
103449: PUSH
103450: LD_VAR 0 2
103454: PUSH
103455: FOR_IN
103456: IFFALSE 103672
// begin if IsInUnit ( i ) then
103458: LD_VAR 0 7
103462: PPUSH
103463: CALL_OW 310
103467: IFFALSE 103478
// ComExitBuilding ( i ) ;
103469: LD_VAR 0 7
103473: PPUSH
103474: CALL_OW 122
// if GetLives ( i ) > 333 then
103478: LD_VAR 0 7
103482: PPUSH
103483: CALL_OW 256
103487: PUSH
103488: LD_INT 333
103490: GREATER
103491: IFFALSE 103519
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
103493: LD_VAR 0 7
103497: PPUSH
103498: LD_VAR 0 5
103502: PPUSH
103503: LD_VAR 0 7
103507: PPUSH
103508: CALL_OW 74
103512: PPUSH
103513: CALL_OW 115
103517: GO 103670
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
103519: LD_ADDR_VAR 0 8
103523: PUSH
103524: LD_EXP 59
103528: PUSH
103529: LD_VAR 0 1
103533: ARRAY
103534: PPUSH
103535: LD_INT 2
103537: PUSH
103538: LD_INT 30
103540: PUSH
103541: LD_INT 0
103543: PUSH
103544: EMPTY
103545: LIST
103546: LIST
103547: PUSH
103548: LD_INT 30
103550: PUSH
103551: LD_INT 1
103553: PUSH
103554: EMPTY
103555: LIST
103556: LIST
103557: PUSH
103558: LD_INT 30
103560: PUSH
103561: LD_INT 6
103563: PUSH
103564: EMPTY
103565: LIST
103566: LIST
103567: PUSH
103568: EMPTY
103569: LIST
103570: LIST
103571: LIST
103572: LIST
103573: PPUSH
103574: CALL_OW 72
103578: PPUSH
103579: LD_VAR 0 7
103583: PPUSH
103584: CALL_OW 74
103588: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
103589: LD_VAR 0 7
103593: PPUSH
103594: LD_VAR 0 8
103598: PPUSH
103599: CALL_OW 250
103603: PPUSH
103604: LD_INT 3
103606: PPUSH
103607: LD_INT 5
103609: PPUSH
103610: CALL_OW 272
103614: PPUSH
103615: LD_VAR 0 8
103619: PPUSH
103620: CALL_OW 251
103624: PPUSH
103625: LD_INT 3
103627: PPUSH
103628: LD_INT 5
103630: PPUSH
103631: CALL_OW 273
103635: PPUSH
103636: CALL_OW 111
// SetTag ( i , 0 ) ;
103640: LD_VAR 0 7
103644: PPUSH
103645: LD_INT 0
103647: PPUSH
103648: CALL_OW 109
// solds := solds diff i ;
103652: LD_ADDR_VAR 0 2
103656: PUSH
103657: LD_VAR 0 2
103661: PUSH
103662: LD_VAR 0 7
103666: DIFF
103667: ST_TO_ADDR
// continue ;
103668: GO 103455
// end ; end ;
103670: GO 103455
103672: POP
103673: POP
// until solds ;
103674: LD_VAR 0 2
103678: IFFALSE 103287
// MC_Reset ( base , 18 ) ;
103680: LD_VAR 0 1
103684: PPUSH
103685: LD_INT 18
103687: PPUSH
103688: CALL 55182 0 2
// end ;
103692: LD_VAR 0 4
103696: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
103697: LD_INT 0
103699: PPUSH
103700: PPUSH
103701: PPUSH
103702: PPUSH
103703: PPUSH
103704: PPUSH
103705: PPUSH
103706: PPUSH
103707: PPUSH
103708: PPUSH
103709: PPUSH
103710: PPUSH
103711: PPUSH
103712: PPUSH
103713: PPUSH
103714: PPUSH
103715: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
103716: LD_ADDR_VAR 0 13
103720: PUSH
103721: LD_EXP 59
103725: PUSH
103726: LD_VAR 0 1
103730: ARRAY
103731: PPUSH
103732: LD_INT 25
103734: PUSH
103735: LD_INT 3
103737: PUSH
103738: EMPTY
103739: LIST
103740: LIST
103741: PPUSH
103742: CALL_OW 72
103746: ST_TO_ADDR
// if mc_remote_driver [ base ] then
103747: LD_EXP 99
103751: PUSH
103752: LD_VAR 0 1
103756: ARRAY
103757: IFFALSE 103781
// mechs := mechs diff mc_remote_driver [ base ] ;
103759: LD_ADDR_VAR 0 13
103763: PUSH
103764: LD_VAR 0 13
103768: PUSH
103769: LD_EXP 99
103773: PUSH
103774: LD_VAR 0 1
103778: ARRAY
103779: DIFF
103780: ST_TO_ADDR
// for i in mechs do
103781: LD_ADDR_VAR 0 5
103785: PUSH
103786: LD_VAR 0 13
103790: PUSH
103791: FOR_IN
103792: IFFALSE 103827
// if GetTag ( i ) > 0 then
103794: LD_VAR 0 5
103798: PPUSH
103799: CALL_OW 110
103803: PUSH
103804: LD_INT 0
103806: GREATER
103807: IFFALSE 103825
// mechs := mechs diff i ;
103809: LD_ADDR_VAR 0 13
103813: PUSH
103814: LD_VAR 0 13
103818: PUSH
103819: LD_VAR 0 5
103823: DIFF
103824: ST_TO_ADDR
103825: GO 103791
103827: POP
103828: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
103829: LD_ADDR_VAR 0 9
103833: PUSH
103834: LD_EXP 59
103838: PUSH
103839: LD_VAR 0 1
103843: ARRAY
103844: PPUSH
103845: LD_INT 2
103847: PUSH
103848: LD_INT 25
103850: PUSH
103851: LD_INT 1
103853: PUSH
103854: EMPTY
103855: LIST
103856: LIST
103857: PUSH
103858: LD_INT 25
103860: PUSH
103861: LD_INT 5
103863: PUSH
103864: EMPTY
103865: LIST
103866: LIST
103867: PUSH
103868: LD_INT 25
103870: PUSH
103871: LD_INT 8
103873: PUSH
103874: EMPTY
103875: LIST
103876: LIST
103877: PUSH
103878: LD_INT 25
103880: PUSH
103881: LD_INT 9
103883: PUSH
103884: EMPTY
103885: LIST
103886: LIST
103887: PUSH
103888: EMPTY
103889: LIST
103890: LIST
103891: LIST
103892: LIST
103893: LIST
103894: PPUSH
103895: CALL_OW 72
103899: ST_TO_ADDR
// if not defenders and not solds then
103900: LD_VAR 0 2
103904: NOT
103905: PUSH
103906: LD_VAR 0 9
103910: NOT
103911: AND
103912: IFFALSE 103916
// exit ;
103914: GO 105542
// depot_under_attack := false ;
103916: LD_ADDR_VAR 0 17
103920: PUSH
103921: LD_INT 0
103923: ST_TO_ADDR
// sold_defenders := [ ] ;
103924: LD_ADDR_VAR 0 18
103928: PUSH
103929: EMPTY
103930: ST_TO_ADDR
// if mechs then
103931: LD_VAR 0 13
103935: IFFALSE 104064
// for i in defenders do
103937: LD_ADDR_VAR 0 5
103941: PUSH
103942: LD_VAR 0 2
103946: PUSH
103947: FOR_IN
103948: IFFALSE 104062
// begin SetTag ( i , 20 ) ;
103950: LD_VAR 0 5
103954: PPUSH
103955: LD_INT 20
103957: PPUSH
103958: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
103962: LD_VAR 0 5
103966: PPUSH
103967: CALL_OW 263
103971: PUSH
103972: LD_INT 1
103974: EQUAL
103975: PUSH
103976: LD_VAR 0 5
103980: PPUSH
103981: CALL_OW 311
103985: NOT
103986: AND
103987: PUSH
103988: LD_VAR 0 13
103992: AND
103993: IFFALSE 104060
// begin un := mechs [ 1 ] ;
103995: LD_ADDR_VAR 0 11
103999: PUSH
104000: LD_VAR 0 13
104004: PUSH
104005: LD_INT 1
104007: ARRAY
104008: ST_TO_ADDR
// ComExitBuilding ( un ) ;
104009: LD_VAR 0 11
104013: PPUSH
104014: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
104018: LD_VAR 0 11
104022: PPUSH
104023: LD_VAR 0 5
104027: PPUSH
104028: CALL_OW 180
// SetTag ( un , 19 ) ;
104032: LD_VAR 0 11
104036: PPUSH
104037: LD_INT 19
104039: PPUSH
104040: CALL_OW 109
// mechs := mechs diff un ;
104044: LD_ADDR_VAR 0 13
104048: PUSH
104049: LD_VAR 0 13
104053: PUSH
104054: LD_VAR 0 11
104058: DIFF
104059: ST_TO_ADDR
// end ; end ;
104060: GO 103947
104062: POP
104063: POP
// if solds then
104064: LD_VAR 0 9
104068: IFFALSE 104127
// for i in solds do
104070: LD_ADDR_VAR 0 5
104074: PUSH
104075: LD_VAR 0 9
104079: PUSH
104080: FOR_IN
104081: IFFALSE 104125
// if not GetTag ( i ) then
104083: LD_VAR 0 5
104087: PPUSH
104088: CALL_OW 110
104092: NOT
104093: IFFALSE 104123
// begin defenders := defenders union i ;
104095: LD_ADDR_VAR 0 2
104099: PUSH
104100: LD_VAR 0 2
104104: PUSH
104105: LD_VAR 0 5
104109: UNION
104110: ST_TO_ADDR
// SetTag ( i , 18 ) ;
104111: LD_VAR 0 5
104115: PPUSH
104116: LD_INT 18
104118: PPUSH
104119: CALL_OW 109
// end ;
104123: GO 104080
104125: POP
104126: POP
// repeat wait ( 0 0$1 ) ;
104127: LD_INT 35
104129: PPUSH
104130: CALL_OW 67
// enemy := mc_scan [ base ] ;
104134: LD_ADDR_VAR 0 3
104138: PUSH
104139: LD_EXP 82
104143: PUSH
104144: LD_VAR 0 1
104148: ARRAY
104149: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
104150: LD_EXP 59
104154: PUSH
104155: LD_VAR 0 1
104159: ARRAY
104160: NOT
104161: PUSH
104162: LD_EXP 59
104166: PUSH
104167: LD_VAR 0 1
104171: ARRAY
104172: PUSH
104173: EMPTY
104174: EQUAL
104175: OR
104176: IFFALSE 104213
// begin for i in defenders do
104178: LD_ADDR_VAR 0 5
104182: PUSH
104183: LD_VAR 0 2
104187: PUSH
104188: FOR_IN
104189: IFFALSE 104202
// ComStop ( i ) ;
104191: LD_VAR 0 5
104195: PPUSH
104196: CALL_OW 141
104200: GO 104188
104202: POP
104203: POP
// defenders := [ ] ;
104204: LD_ADDR_VAR 0 2
104208: PUSH
104209: EMPTY
104210: ST_TO_ADDR
// exit ;
104211: GO 105542
// end ; for i in defenders do
104213: LD_ADDR_VAR 0 5
104217: PUSH
104218: LD_VAR 0 2
104222: PUSH
104223: FOR_IN
104224: IFFALSE 105042
// begin e := NearestUnitToUnit ( enemy , i ) ;
104226: LD_ADDR_VAR 0 14
104230: PUSH
104231: LD_VAR 0 3
104235: PPUSH
104236: LD_VAR 0 5
104240: PPUSH
104241: CALL_OW 74
104245: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104246: LD_ADDR_VAR 0 8
104250: PUSH
104251: LD_EXP 59
104255: PUSH
104256: LD_VAR 0 1
104260: ARRAY
104261: PPUSH
104262: LD_INT 2
104264: PUSH
104265: LD_INT 30
104267: PUSH
104268: LD_INT 0
104270: PUSH
104271: EMPTY
104272: LIST
104273: LIST
104274: PUSH
104275: LD_INT 30
104277: PUSH
104278: LD_INT 1
104280: PUSH
104281: EMPTY
104282: LIST
104283: LIST
104284: PUSH
104285: EMPTY
104286: LIST
104287: LIST
104288: LIST
104289: PPUSH
104290: CALL_OW 72
104294: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
104295: LD_ADDR_VAR 0 17
104299: PUSH
104300: LD_VAR 0 8
104304: NOT
104305: PUSH
104306: LD_VAR 0 8
104310: PPUSH
104311: LD_INT 3
104313: PUSH
104314: LD_INT 24
104316: PUSH
104317: LD_INT 600
104319: PUSH
104320: EMPTY
104321: LIST
104322: LIST
104323: PUSH
104324: EMPTY
104325: LIST
104326: LIST
104327: PPUSH
104328: CALL_OW 72
104332: OR
104333: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
104334: LD_VAR 0 5
104338: PPUSH
104339: CALL_OW 247
104343: PUSH
104344: LD_INT 2
104346: DOUBLE
104347: EQUAL
104348: IFTRUE 104352
104350: GO 104748
104352: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
104353: LD_VAR 0 5
104357: PPUSH
104358: CALL_OW 256
104362: PUSH
104363: LD_INT 650
104365: GREATER
104366: PUSH
104367: LD_VAR 0 5
104371: PPUSH
104372: LD_VAR 0 14
104376: PPUSH
104377: CALL_OW 296
104381: PUSH
104382: LD_INT 40
104384: LESS
104385: PUSH
104386: LD_VAR 0 14
104390: PPUSH
104391: LD_EXP 84
104395: PUSH
104396: LD_VAR 0 1
104400: ARRAY
104401: PPUSH
104402: CALL_OW 308
104406: OR
104407: AND
104408: IFFALSE 104530
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
104410: LD_VAR 0 5
104414: PPUSH
104415: CALL_OW 262
104419: PUSH
104420: LD_INT 1
104422: EQUAL
104423: PUSH
104424: LD_VAR 0 5
104428: PPUSH
104429: CALL_OW 261
104433: PUSH
104434: LD_INT 30
104436: LESS
104437: AND
104438: PUSH
104439: LD_VAR 0 8
104443: AND
104444: IFFALSE 104514
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
104446: LD_VAR 0 5
104450: PPUSH
104451: LD_VAR 0 8
104455: PPUSH
104456: LD_VAR 0 5
104460: PPUSH
104461: CALL_OW 74
104465: PPUSH
104466: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
104470: LD_VAR 0 5
104474: PPUSH
104475: LD_VAR 0 8
104479: PPUSH
104480: LD_VAR 0 5
104484: PPUSH
104485: CALL_OW 74
104489: PPUSH
104490: CALL_OW 296
104494: PUSH
104495: LD_INT 6
104497: LESS
104498: IFFALSE 104512
// SetFuel ( i , 100 ) ;
104500: LD_VAR 0 5
104504: PPUSH
104505: LD_INT 100
104507: PPUSH
104508: CALL_OW 240
// end else
104512: GO 104528
// ComAttackUnit ( i , e ) ;
104514: LD_VAR 0 5
104518: PPUSH
104519: LD_VAR 0 14
104523: PPUSH
104524: CALL_OW 115
// end else
104528: GO 104631
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
104530: LD_VAR 0 14
104534: PPUSH
104535: LD_EXP 84
104539: PUSH
104540: LD_VAR 0 1
104544: ARRAY
104545: PPUSH
104546: CALL_OW 308
104550: NOT
104551: PUSH
104552: LD_VAR 0 5
104556: PPUSH
104557: LD_VAR 0 14
104561: PPUSH
104562: CALL_OW 296
104566: PUSH
104567: LD_INT 40
104569: GREATEREQUAL
104570: AND
104571: PUSH
104572: LD_VAR 0 5
104576: PPUSH
104577: CALL_OW 256
104581: PUSH
104582: LD_INT 650
104584: LESSEQUAL
104585: OR
104586: PUSH
104587: LD_VAR 0 5
104591: PPUSH
104592: LD_EXP 83
104596: PUSH
104597: LD_VAR 0 1
104601: ARRAY
104602: PPUSH
104603: CALL_OW 308
104607: NOT
104608: AND
104609: IFFALSE 104631
// ComMoveToArea ( i , mc_parking [ base ] ) ;
104611: LD_VAR 0 5
104615: PPUSH
104616: LD_EXP 83
104620: PUSH
104621: LD_VAR 0 1
104625: ARRAY
104626: PPUSH
104627: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
104631: LD_VAR 0 5
104635: PPUSH
104636: CALL_OW 256
104640: PUSH
104641: LD_INT 998
104643: LESS
104644: PUSH
104645: LD_VAR 0 5
104649: PPUSH
104650: CALL_OW 263
104654: PUSH
104655: LD_INT 1
104657: EQUAL
104658: AND
104659: PUSH
104660: LD_VAR 0 5
104664: PPUSH
104665: CALL_OW 311
104669: AND
104670: PUSH
104671: LD_VAR 0 5
104675: PPUSH
104676: LD_EXP 83
104680: PUSH
104681: LD_VAR 0 1
104685: ARRAY
104686: PPUSH
104687: CALL_OW 308
104691: AND
104692: IFFALSE 104746
// begin mech := IsDrivenBy ( i ) ;
104694: LD_ADDR_VAR 0 10
104698: PUSH
104699: LD_VAR 0 5
104703: PPUSH
104704: CALL_OW 311
104708: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
104709: LD_VAR 0 10
104713: PPUSH
104714: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
104718: LD_VAR 0 10
104722: PPUSH
104723: LD_VAR 0 5
104727: PPUSH
104728: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
104732: LD_VAR 0 10
104736: PPUSH
104737: LD_VAR 0 5
104741: PPUSH
104742: CALL_OW 180
// end ; end ; unit_human :
104746: GO 105013
104748: LD_INT 1
104750: DOUBLE
104751: EQUAL
104752: IFTRUE 104756
104754: GO 105012
104756: POP
// begin b := IsInUnit ( i ) ;
104757: LD_ADDR_VAR 0 19
104761: PUSH
104762: LD_VAR 0 5
104766: PPUSH
104767: CALL_OW 310
104771: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
104772: LD_ADDR_VAR 0 20
104776: PUSH
104777: LD_VAR 0 19
104781: NOT
104782: PUSH
104783: LD_VAR 0 19
104787: PPUSH
104788: CALL_OW 266
104792: PUSH
104793: LD_INT 32
104795: PUSH
104796: LD_INT 31
104798: PUSH
104799: EMPTY
104800: LIST
104801: LIST
104802: IN
104803: OR
104804: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
104805: LD_VAR 0 17
104809: PUSH
104810: LD_VAR 0 2
104814: PPUSH
104815: LD_INT 21
104817: PUSH
104818: LD_INT 2
104820: PUSH
104821: EMPTY
104822: LIST
104823: LIST
104824: PPUSH
104825: CALL_OW 72
104829: PUSH
104830: LD_INT 1
104832: LESSEQUAL
104833: OR
104834: PUSH
104835: LD_VAR 0 20
104839: AND
104840: PUSH
104841: LD_VAR 0 5
104845: PUSH
104846: LD_VAR 0 18
104850: IN
104851: NOT
104852: AND
104853: IFFALSE 104946
// begin if b then
104855: LD_VAR 0 19
104859: IFFALSE 104908
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
104861: LD_VAR 0 19
104865: PPUSH
104866: LD_VAR 0 3
104870: PPUSH
104871: LD_VAR 0 19
104875: PPUSH
104876: CALL_OW 74
104880: PPUSH
104881: CALL_OW 296
104885: PUSH
104886: LD_INT 10
104888: LESS
104889: PUSH
104890: LD_VAR 0 19
104894: PPUSH
104895: CALL_OW 461
104899: PUSH
104900: LD_INT 7
104902: NONEQUAL
104903: AND
104904: IFFALSE 104908
// continue ;
104906: GO 104223
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
104908: LD_ADDR_VAR 0 18
104912: PUSH
104913: LD_VAR 0 18
104917: PPUSH
104918: LD_VAR 0 18
104922: PUSH
104923: LD_INT 1
104925: PLUS
104926: PPUSH
104927: LD_VAR 0 5
104931: PPUSH
104932: CALL_OW 1
104936: ST_TO_ADDR
// ComExitBuilding ( i ) ;
104937: LD_VAR 0 5
104941: PPUSH
104942: CALL_OW 122
// end ; if sold_defenders then
104946: LD_VAR 0 18
104950: IFFALSE 105010
// if i in sold_defenders then
104952: LD_VAR 0 5
104956: PUSH
104957: LD_VAR 0 18
104961: IN
104962: IFFALSE 105010
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
104964: LD_VAR 0 5
104968: PPUSH
104969: CALL_OW 314
104973: NOT
104974: PUSH
104975: LD_VAR 0 5
104979: PPUSH
104980: LD_VAR 0 14
104984: PPUSH
104985: CALL_OW 296
104989: PUSH
104990: LD_INT 30
104992: LESS
104993: AND
104994: IFFALSE 105010
// ComAttackUnit ( i , e ) ;
104996: LD_VAR 0 5
105000: PPUSH
105001: LD_VAR 0 14
105005: PPUSH
105006: CALL_OW 115
// end ; end ; end ;
105010: GO 105013
105012: POP
// if IsDead ( i ) then
105013: LD_VAR 0 5
105017: PPUSH
105018: CALL_OW 301
105022: IFFALSE 105040
// defenders := defenders diff i ;
105024: LD_ADDR_VAR 0 2
105028: PUSH
105029: LD_VAR 0 2
105033: PUSH
105034: LD_VAR 0 5
105038: DIFF
105039: ST_TO_ADDR
// end ;
105040: GO 104223
105042: POP
105043: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
105044: LD_VAR 0 3
105048: NOT
105049: PUSH
105050: LD_VAR 0 2
105054: NOT
105055: OR
105056: PUSH
105057: LD_EXP 59
105061: PUSH
105062: LD_VAR 0 1
105066: ARRAY
105067: NOT
105068: OR
105069: IFFALSE 104127
// MC_Reset ( base , 18 ) ;
105071: LD_VAR 0 1
105075: PPUSH
105076: LD_INT 18
105078: PPUSH
105079: CALL 55182 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
105083: LD_ADDR_VAR 0 2
105087: PUSH
105088: LD_VAR 0 2
105092: PUSH
105093: LD_VAR 0 2
105097: PPUSH
105098: LD_INT 2
105100: PUSH
105101: LD_INT 25
105103: PUSH
105104: LD_INT 1
105106: PUSH
105107: EMPTY
105108: LIST
105109: LIST
105110: PUSH
105111: LD_INT 25
105113: PUSH
105114: LD_INT 5
105116: PUSH
105117: EMPTY
105118: LIST
105119: LIST
105120: PUSH
105121: LD_INT 25
105123: PUSH
105124: LD_INT 8
105126: PUSH
105127: EMPTY
105128: LIST
105129: LIST
105130: PUSH
105131: LD_INT 25
105133: PUSH
105134: LD_INT 9
105136: PUSH
105137: EMPTY
105138: LIST
105139: LIST
105140: PUSH
105141: EMPTY
105142: LIST
105143: LIST
105144: LIST
105145: LIST
105146: LIST
105147: PPUSH
105148: CALL_OW 72
105152: DIFF
105153: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
105154: LD_VAR 0 3
105158: NOT
105159: PUSH
105160: LD_VAR 0 2
105164: PPUSH
105165: LD_INT 21
105167: PUSH
105168: LD_INT 2
105170: PUSH
105171: EMPTY
105172: LIST
105173: LIST
105174: PPUSH
105175: CALL_OW 72
105179: AND
105180: IFFALSE 105518
// begin tmp := FilterByTag ( defenders , 19 ) ;
105182: LD_ADDR_VAR 0 12
105186: PUSH
105187: LD_VAR 0 2
105191: PPUSH
105192: LD_INT 19
105194: PPUSH
105195: CALL 47799 0 2
105199: ST_TO_ADDR
// if tmp then
105200: LD_VAR 0 12
105204: IFFALSE 105274
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
105206: LD_ADDR_VAR 0 12
105210: PUSH
105211: LD_VAR 0 12
105215: PPUSH
105216: LD_INT 25
105218: PUSH
105219: LD_INT 3
105221: PUSH
105222: EMPTY
105223: LIST
105224: LIST
105225: PPUSH
105226: CALL_OW 72
105230: ST_TO_ADDR
// if tmp then
105231: LD_VAR 0 12
105235: IFFALSE 105274
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
105237: LD_ADDR_EXP 71
105241: PUSH
105242: LD_EXP 71
105246: PPUSH
105247: LD_VAR 0 1
105251: PPUSH
105252: LD_EXP 71
105256: PUSH
105257: LD_VAR 0 1
105261: ARRAY
105262: PUSH
105263: LD_VAR 0 12
105267: UNION
105268: PPUSH
105269: CALL_OW 1
105273: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
105274: LD_VAR 0 1
105278: PPUSH
105279: LD_INT 19
105281: PPUSH
105282: CALL 55182 0 2
// repeat wait ( 0 0$1 ) ;
105286: LD_INT 35
105288: PPUSH
105289: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
105293: LD_EXP 59
105297: PUSH
105298: LD_VAR 0 1
105302: ARRAY
105303: NOT
105304: PUSH
105305: LD_EXP 59
105309: PUSH
105310: LD_VAR 0 1
105314: ARRAY
105315: PUSH
105316: EMPTY
105317: EQUAL
105318: OR
105319: IFFALSE 105356
// begin for i in defenders do
105321: LD_ADDR_VAR 0 5
105325: PUSH
105326: LD_VAR 0 2
105330: PUSH
105331: FOR_IN
105332: IFFALSE 105345
// ComStop ( i ) ;
105334: LD_VAR 0 5
105338: PPUSH
105339: CALL_OW 141
105343: GO 105331
105345: POP
105346: POP
// defenders := [ ] ;
105347: LD_ADDR_VAR 0 2
105351: PUSH
105352: EMPTY
105353: ST_TO_ADDR
// exit ;
105354: GO 105542
// end ; for i in defenders do
105356: LD_ADDR_VAR 0 5
105360: PUSH
105361: LD_VAR 0 2
105365: PUSH
105366: FOR_IN
105367: IFFALSE 105456
// begin if not IsInArea ( i , mc_parking [ base ] ) then
105369: LD_VAR 0 5
105373: PPUSH
105374: LD_EXP 83
105378: PUSH
105379: LD_VAR 0 1
105383: ARRAY
105384: PPUSH
105385: CALL_OW 308
105389: NOT
105390: IFFALSE 105414
// ComMoveToArea ( i , mc_parking [ base ] ) else
105392: LD_VAR 0 5
105396: PPUSH
105397: LD_EXP 83
105401: PUSH
105402: LD_VAR 0 1
105406: ARRAY
105407: PPUSH
105408: CALL_OW 113
105412: GO 105454
// if GetControl ( i ) = control_manual then
105414: LD_VAR 0 5
105418: PPUSH
105419: CALL_OW 263
105423: PUSH
105424: LD_INT 1
105426: EQUAL
105427: IFFALSE 105454
// if IsDrivenBy ( i ) then
105429: LD_VAR 0 5
105433: PPUSH
105434: CALL_OW 311
105438: IFFALSE 105454
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
105440: LD_VAR 0 5
105444: PPUSH
105445: CALL_OW 311
105449: PPUSH
105450: CALL_OW 121
// end ;
105454: GO 105366
105456: POP
105457: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
105458: LD_VAR 0 2
105462: PPUSH
105463: LD_INT 95
105465: PUSH
105466: LD_EXP 83
105470: PUSH
105471: LD_VAR 0 1
105475: ARRAY
105476: PUSH
105477: EMPTY
105478: LIST
105479: LIST
105480: PPUSH
105481: CALL_OW 72
105485: PUSH
105486: LD_VAR 0 2
105490: EQUAL
105491: PUSH
105492: LD_EXP 82
105496: PUSH
105497: LD_VAR 0 1
105501: ARRAY
105502: OR
105503: PUSH
105504: LD_EXP 59
105508: PUSH
105509: LD_VAR 0 1
105513: ARRAY
105514: NOT
105515: OR
105516: IFFALSE 105286
// end ; MC_Reset ( base , 19 ) ;
105518: LD_VAR 0 1
105522: PPUSH
105523: LD_INT 19
105525: PPUSH
105526: CALL 55182 0 2
// MC_Reset ( base , 20 ) ;
105530: LD_VAR 0 1
105534: PPUSH
105535: LD_INT 20
105537: PPUSH
105538: CALL 55182 0 2
// end ; end_of_file
105542: LD_VAR 0 4
105546: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
105547: LD_VAR 0 1
105551: PUSH
105552: LD_INT 200
105554: DOUBLE
105555: GREATEREQUAL
105556: IFFALSE 105564
105558: LD_INT 299
105560: DOUBLE
105561: LESSEQUAL
105562: IFTRUE 105566
105564: GO 105598
105566: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
105567: LD_VAR 0 1
105571: PPUSH
105572: LD_VAR 0 2
105576: PPUSH
105577: LD_VAR 0 3
105581: PPUSH
105582: LD_VAR 0 4
105586: PPUSH
105587: LD_VAR 0 5
105591: PPUSH
105592: CALL 94552 0 5
105596: GO 105675
105598: LD_INT 300
105600: DOUBLE
105601: GREATEREQUAL
105602: IFFALSE 105610
105604: LD_INT 399
105606: DOUBLE
105607: LESSEQUAL
105608: IFTRUE 105612
105610: GO 105674
105612: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
105613: LD_VAR 0 1
105617: PPUSH
105618: LD_VAR 0 2
105622: PPUSH
105623: LD_VAR 0 3
105627: PPUSH
105628: LD_VAR 0 4
105632: PPUSH
105633: LD_VAR 0 5
105637: PPUSH
105638: LD_VAR 0 6
105642: PPUSH
105643: LD_VAR 0 7
105647: PPUSH
105648: LD_VAR 0 8
105652: PPUSH
105653: LD_VAR 0 9
105657: PPUSH
105658: LD_VAR 0 10
105662: PPUSH
105663: LD_VAR 0 11
105667: PPUSH
105668: CALL 92458 0 11
105672: GO 105675
105674: POP
// end ;
105675: PPOPN 11
105677: END
