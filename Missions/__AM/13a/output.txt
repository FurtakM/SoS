// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 682 0 0
// InitGlobalVariables ;
  19: CALL 84093 0 0
// InitMacro ;
  23: CALL 53614 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  27: LD_INT 3
  29: PPUSH
  30: LD_INT 3
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: LD_INT 4
  38: PPUSH
  39: LD_INT 3
  41: PPUSH
  42: LD_INT 0
  44: PPUSH
  45: LD_INT 0
  47: PPUSH
  48: LD_INT 5
  50: PPUSH
  51: LD_INT 0
  53: PPUSH
  54: CALL 48103 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  58: LD_INT 0
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 5
  66: PPUSH
  67: LD_INT 0
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 8
  81: PPUSH
  82: LD_INT 0
  84: PPUSH
  85: CALL 48103 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  89: LD_INT 0
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 6
  97: PPUSH
  98: LD_INT 0
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 1
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 6
 112: PPUSH
 113: LD_INT 0
 115: PPUSH
 116: CALL 48103 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 120: LD_INT 0
 122: PPUSH
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 4
 128: PUSH
 129: LD_INT 3
 131: PUSH
 132: LD_INT 2
 134: PUSH
 135: EMPTY
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 48103 0 9
// PrepareArabian ;
 168: CALL 3932 0 0
// PrepareRussian ;
 172: CALL 2911 0 0
// PrepareAlliance ;
 176: CALL 884 0 0
// MC_Start ( ) ;
 180: CALL 55779 0 0
// if debug then
 184: LD_EXP 1
 188: IFFALSE 197
// FogOff ( 1 ) ;
 190: LD_INT 1
 192: PPUSH
 193: CALL_OW 344
// Action ;
 197: CALL 7274 0 0
// end ;
 201: END
// export function CustomInitMacro ; var i ; begin
 202: LD_INT 0
 204: PPUSH
 205: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 206: LD_ADDR_EXP 83
 210: PUSH
 211: LD_INT 1
 213: PUSH
 214: LD_INT 2
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 221: LD_ADDR_EXP 84
 225: PUSH
 226: LD_INT 3
 228: PUSH
 229: LD_INT 4
 231: PUSH
 232: EMPTY
 233: LIST
 234: LIST
 235: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 236: LD_INT 1
 238: PPUSH
 239: LD_INT 12
 241: PUSH
 242: LD_INT 15
 244: PUSH
 245: LD_INT 18
 247: PUSH
 248: EMPTY
 249: LIST
 250: LIST
 251: LIST
 252: PUSH
 253: LD_OWVAR 67
 257: ARRAY
 258: PPUSH
 259: LD_INT 7
 261: PPUSH
 262: CALL 77321 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 266: LD_INT 1
 268: PPUSH
 269: LD_EXP 54
 273: PPUSH
 274: CALL 77747 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 278: LD_INT 1
 280: PPUSH
 281: LD_INT 6
 283: PPUSH
 284: CALL 78205 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 288: LD_INT 1
 290: PPUSH
 291: LD_INT 9
 293: PUSH
 294: EMPTY
 295: LIST
 296: PPUSH
 297: CALL 78474 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 301: LD_INT 1
 303: PPUSH
 304: LD_INT 13
 306: PUSH
 307: LD_INT 1
 309: PUSH
 310: LD_INT 2
 312: PUSH
 313: LD_INT 32
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PUSH
 322: LD_INT 13
 324: PUSH
 325: LD_INT 1
 327: PUSH
 328: LD_INT 2
 330: PUSH
 331: LD_EXP 109
 335: PUSH
 336: EMPTY
 337: LIST
 338: LIST
 339: LIST
 340: LIST
 341: PUSH
 342: EMPTY
 343: LIST
 344: LIST
 345: PPUSH
 346: CALL 77687 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 350: LD_INT 2
 352: PPUSH
 353: LD_INT 12
 355: PUSH
 356: LD_INT 14
 358: PUSH
 359: LD_INT 10
 361: PUSH
 362: LD_INT 11
 364: PUSH
 365: EMPTY
 366: LIST
 367: LIST
 368: LIST
 369: LIST
 370: PPUSH
 371: CALL 78381 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 375: LD_INT 2
 377: PPUSH
 378: LD_EXP 51
 382: PPUSH
 383: CALL 77747 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 387: LD_INT 2
 389: PPUSH
 390: LD_INT 8
 392: PPUSH
 393: CALL 78205 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 397: LD_INT 2
 399: PPUSH
 400: LD_INT 10
 402: PUSH
 403: EMPTY
 404: LIST
 405: PPUSH
 406: CALL 78474 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 410: LD_INT 2
 412: PPUSH
 413: LD_INT 6
 415: PUSH
 416: LD_INT 71
 418: PUSH
 419: LD_INT 116
 421: PUSH
 422: LD_INT 4
 424: PUSH
 425: EMPTY
 426: LIST
 427: LIST
 428: LIST
 429: LIST
 430: PUSH
 431: LD_INT 4
 433: PUSH
 434: LD_INT 85
 436: PUSH
 437: LD_INT 116
 439: PUSH
 440: LD_INT 4
 442: PUSH
 443: EMPTY
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: PUSH
 449: LD_INT 32
 451: PUSH
 452: LD_INT 83
 454: PUSH
 455: LD_INT 111
 457: PUSH
 458: LD_INT 4
 460: PUSH
 461: EMPTY
 462: LIST
 463: LIST
 464: LIST
 465: LIST
 466: PUSH
 467: LD_INT 32
 469: PUSH
 470: LD_INT 87
 472: PUSH
 473: LD_INT 121
 475: PUSH
 476: LD_INT 4
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: LIST
 483: LIST
 484: PUSH
 485: LD_INT 33
 487: PUSH
 488: LD_INT 88
 490: PUSH
 491: LD_INT 128
 493: PUSH
 494: LD_INT 4
 496: PUSH
 497: EMPTY
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: PUSH
 503: LD_INT 32
 505: PUSH
 506: LD_INT 59
 508: PUSH
 509: LD_INT 89
 511: PUSH
 512: LD_INT 3
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PUSH
 521: LD_INT 33
 523: PUSH
 524: LD_INT 69
 526: PUSH
 527: LD_INT 98
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: LIST
 538: PUSH
 539: LD_INT 33
 541: PUSH
 542: LD_INT 77
 544: PUSH
 545: LD_INT 103
 547: PUSH
 548: LD_INT 3
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: PUSH
 557: LD_INT 33
 559: PUSH
 560: LD_INT 83
 562: PUSH
 563: LD_INT 105
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: EMPTY
 570: LIST
 571: LIST
 572: LIST
 573: LIST
 574: PUSH
 575: LD_INT 33
 577: PUSH
 578: LD_INT 71
 580: PUSH
 581: LD_INT 125
 583: PUSH
 584: LD_INT 5
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: PPUSH
 605: CALL 77531 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 609: LD_INT 2
 611: PPUSH
 612: LD_INT 43
 614: PUSH
 615: LD_INT 47
 617: PUSH
 618: LD_INT 46
 620: PUSH
 621: EMPTY
 622: LIST
 623: LIST
 624: LIST
 625: PPUSH
 626: CALL 78792 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 630: LD_INT 2
 632: PPUSH
 633: LD_INT 21
 635: PUSH
 636: LD_INT 1
 638: PUSH
 639: LD_INT 3
 641: PUSH
 642: LD_INT 51
 644: PUSH
 645: EMPTY
 646: LIST
 647: LIST
 648: LIST
 649: LIST
 650: PUSH
 651: LD_INT 22
 653: PUSH
 654: LD_INT 1
 656: PUSH
 657: LD_INT 3
 659: PUSH
 660: LD_INT 52
 662: PUSH
 663: EMPTY
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PUSH
 669: EMPTY
 670: LIST
 671: LIST
 672: PPUSH
 673: CALL 77687 0 2
// end ;
 677: LD_VAR 0 1
 681: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 682: LD_INT 0
 684: PPUSH
// debug := false ;
 685: LD_ADDR_EXP 1
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// game := true ;
 693: LD_ADDR_EXP 2
 697: PUSH
 698: LD_INT 1
 700: ST_TO_ADDR
// gossudarov_arrive := false ;
 701: LD_ADDR_EXP 4
 705: PUSH
 706: LD_INT 0
 708: ST_TO_ADDR
// ru_lab_builded := false ;
 709: LD_ADDR_EXP 5
 713: PUSH
 714: LD_INT 0
 716: ST_TO_ADDR
// player_spotted := false ;
 717: LD_ADDR_EXP 6
 721: PUSH
 722: LD_INT 0
 724: ST_TO_ADDR
// first_attack := false ;
 725: LD_ADDR_EXP 7
 729: PUSH
 730: LD_INT 0
 732: ST_TO_ADDR
// ru_attackers := [ ] ;
 733: LD_ADDR_EXP 52
 737: PUSH
 738: EMPTY
 739: ST_TO_ADDR
// ar_base_spotted := false ;
 740: LD_ADDR_EXP 8
 744: PUSH
 745: LD_INT 0
 747: ST_TO_ADDR
// ar_active_attack := false ;
 748: LD_ADDR_EXP 9
 752: PUSH
 753: LD_INT 0
 755: ST_TO_ADDR
// ar_attackers := [ ] ;
 756: LD_ADDR_EXP 10
 760: PUSH
 761: EMPTY
 762: ST_TO_ADDR
// first_powell_attack := false ;
 763: LD_ADDR_EXP 11
 767: PUSH
 768: LD_INT 0
 770: ST_TO_ADDR
// abdul_escaped := true ;
 771: LD_ADDR_EXP 12
 775: PUSH
 776: LD_INT 1
 778: ST_TO_ADDR
// loss_counter := 0 ;
 779: LD_ADDR_EXP 13
 783: PUSH
 784: LD_INT 0
 786: ST_TO_ADDR
// hack_counter := 0 ;
 787: LD_ADDR_EXP 14
 791: PUSH
 792: LD_INT 0
 794: ST_TO_ADDR
// end ;
 795: LD_VAR 0 1
 799: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 800: LD_EXP 48
 804: PPUSH
 805: CALL_OW 255
 809: PUSH
 810: LD_INT 7
 812: EQUAL
 813: PUSH
 814: LD_EXP 47
 818: PPUSH
 819: CALL_OW 255
 823: PUSH
 824: LD_INT 7
 826: EQUAL
 827: AND
 828: PUSH
 829: LD_EXP 48
 833: PPUSH
 834: CALL_OW 302
 838: AND
 839: PUSH
 840: LD_EXP 47
 844: PPUSH
 845: CALL_OW 302
 849: AND
 850: IFFALSE 862
 852: GO 854
 854: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 855: LD_STRING ACH_COMRADE
 857: PPUSH
 858: CALL_OW 543
 862: END
// every 0 0$1 trigger hack_counter >= 10 do
 863: LD_EXP 14
 867: PUSH
 868: LD_INT 10
 870: GREATEREQUAL
 871: IFFALSE 883
 873: GO 875
 875: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 876: LD_STRING ACH_HACK
 878: PPUSH
 879: CALL_OW 543
 883: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 884: LD_INT 0
 886: PPUSH
 887: PPUSH
 888: PPUSH
 889: PPUSH
// uc_side := 7 ;
 890: LD_ADDR_OWVAR 20
 894: PUSH
 895: LD_INT 7
 897: ST_TO_ADDR
// uc_nation := 1 ;
 898: LD_ADDR_OWVAR 21
 902: PUSH
 903: LD_INT 1
 905: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 906: LD_ADDR_EXP 15
 910: PUSH
 911: LD_STRING JMM
 913: PPUSH
 914: LD_EXP 1
 918: NOT
 919: PPUSH
 920: LD_STRING 12a_
 922: PPUSH
 923: CALL 14740 0 3
 927: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 928: LD_EXP 15
 932: PPUSH
 933: LD_INT 71
 935: PPUSH
 936: LD_INT 23
 938: PPUSH
 939: LD_INT 0
 941: PPUSH
 942: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 946: LD_EXP 15
 950: PPUSH
 951: LD_INT 2
 953: PPUSH
 954: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 958: LD_ADDR_EXP 16
 962: PUSH
 963: LD_STRING Roth
 965: PPUSH
 966: LD_EXP 1
 970: NOT
 971: PPUSH
 972: LD_STRING 12a_
 974: PPUSH
 975: CALL 14740 0 3
 979: ST_TO_ADDR
// if Roth then
 980: LD_EXP 16
 984: IFFALSE 1004
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 986: LD_EXP 16
 990: PPUSH
 991: LD_INT 71
 993: PPUSH
 994: LD_INT 21
 996: PPUSH
 997: LD_INT 0
 999: PPUSH
1000: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1004: LD_ADDR_EXP 17
1008: PUSH
1009: LD_STRING Lisa
1011: PPUSH
1012: LD_EXP 1
1016: NOT
1017: PPUSH
1018: LD_STRING 12a_
1020: PPUSH
1021: CALL 14740 0 3
1025: ST_TO_ADDR
// if Lisa then
1026: LD_EXP 17
1030: IFFALSE 1047
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1032: LD_EXP 17
1036: PPUSH
1037: LD_INT 13
1039: PPUSH
1040: LD_INT 0
1042: PPUSH
1043: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1047: LD_ADDR_EXP 18
1051: PUSH
1052: LD_STRING Donaldson
1054: PPUSH
1055: LD_EXP 1
1059: NOT
1060: PPUSH
1061: LD_STRING 12a_
1063: PPUSH
1064: CALL 14740 0 3
1068: ST_TO_ADDR
// if Donaldson then
1069: LD_EXP 18
1073: IFFALSE 1090
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1075: LD_EXP 18
1079: PPUSH
1080: LD_INT 13
1082: PPUSH
1083: LD_INT 0
1085: PPUSH
1086: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1090: LD_ADDR_EXP 19
1094: PUSH
1095: LD_STRING Bobby
1097: PPUSH
1098: LD_EXP 1
1102: NOT
1103: PPUSH
1104: LD_STRING 12a_
1106: PPUSH
1107: CALL 14740 0 3
1111: ST_TO_ADDR
// if Bobby then
1112: LD_EXP 19
1116: IFFALSE 1133
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1118: LD_EXP 19
1122: PPUSH
1123: LD_INT 13
1125: PPUSH
1126: LD_INT 0
1128: PPUSH
1129: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1133: LD_ADDR_EXP 20
1137: PUSH
1138: LD_STRING Cyrus
1140: PPUSH
1141: LD_EXP 1
1145: NOT
1146: PPUSH
1147: LD_STRING 12a_
1149: PPUSH
1150: CALL 14740 0 3
1154: ST_TO_ADDR
// if Cyrus then
1155: LD_EXP 20
1159: IFFALSE 1176
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1161: LD_EXP 20
1165: PPUSH
1166: LD_INT 13
1168: PPUSH
1169: LD_INT 0
1171: PPUSH
1172: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1176: LD_ADDR_EXP 21
1180: PUSH
1181: LD_STRING Denis
1183: PPUSH
1184: LD_EXP 1
1188: NOT
1189: PPUSH
1190: LD_STRING 12a_
1192: PPUSH
1193: CALL 14740 0 3
1197: ST_TO_ADDR
// if Denis then
1198: LD_EXP 21
1202: IFFALSE 1219
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1204: LD_EXP 21
1208: PPUSH
1209: LD_INT 13
1211: PPUSH
1212: LD_INT 0
1214: PPUSH
1215: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1219: LD_ADDR_EXP 22
1223: PUSH
1224: LD_STRING Brown
1226: PPUSH
1227: LD_EXP 1
1231: NOT
1232: PPUSH
1233: LD_STRING 12a_
1235: PPUSH
1236: CALL 14740 0 3
1240: ST_TO_ADDR
// if Brown then
1241: LD_EXP 22
1245: IFFALSE 1262
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1247: LD_EXP 22
1251: PPUSH
1252: LD_INT 13
1254: PPUSH
1255: LD_INT 0
1257: PPUSH
1258: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1262: LD_ADDR_EXP 23
1266: PUSH
1267: LD_STRING Gladstone
1269: PPUSH
1270: LD_EXP 1
1274: NOT
1275: PPUSH
1276: LD_STRING 12a_
1278: PPUSH
1279: CALL 14740 0 3
1283: ST_TO_ADDR
// if Gladstone then
1284: LD_EXP 23
1288: IFFALSE 1305
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1290: LD_EXP 23
1294: PPUSH
1295: LD_INT 13
1297: PPUSH
1298: LD_INT 0
1300: PPUSH
1301: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1305: LD_ADDR_EXP 24
1309: PUSH
1310: LD_STRING Houten
1312: PPUSH
1313: LD_EXP 1
1317: NOT
1318: PPUSH
1319: LD_STRING 12a_
1321: PPUSH
1322: CALL 14740 0 3
1326: ST_TO_ADDR
// if Houten then
1327: LD_EXP 24
1331: IFFALSE 1348
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1333: LD_EXP 24
1337: PPUSH
1338: LD_INT 13
1340: PPUSH
1341: LD_INT 0
1343: PPUSH
1344: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1348: LD_ADDR_EXP 25
1352: PUSH
1353: LD_STRING Cornell
1355: PPUSH
1356: LD_EXP 1
1360: NOT
1361: PPUSH
1362: LD_STRING 12a_
1364: PPUSH
1365: CALL 14740 0 3
1369: ST_TO_ADDR
// if Cornel then
1370: LD_EXP 25
1374: IFFALSE 1391
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1376: LD_EXP 25
1380: PPUSH
1381: LD_INT 13
1383: PPUSH
1384: LD_INT 0
1386: PPUSH
1387: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1391: LD_ADDR_EXP 26
1395: PUSH
1396: LD_STRING Gary
1398: PPUSH
1399: LD_EXP 1
1403: NOT
1404: PPUSH
1405: LD_STRING 12a_
1407: PPUSH
1408: CALL 14740 0 3
1412: ST_TO_ADDR
// if Gary then
1413: LD_EXP 26
1417: IFFALSE 1434
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1419: LD_EXP 26
1423: PPUSH
1424: LD_INT 13
1426: PPUSH
1427: LD_INT 0
1429: PPUSH
1430: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1434: LD_ADDR_EXP 27
1438: PUSH
1439: LD_STRING Frank
1441: PPUSH
1442: LD_EXP 1
1446: NOT
1447: PPUSH
1448: LD_STRING 12a_
1450: PPUSH
1451: CALL 14740 0 3
1455: ST_TO_ADDR
// if Frank then
1456: LD_EXP 27
1460: IFFALSE 1477
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1462: LD_EXP 27
1466: PPUSH
1467: LD_INT 13
1469: PPUSH
1470: LD_INT 0
1472: PPUSH
1473: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1477: LD_ADDR_EXP 28
1481: PUSH
1482: LD_STRING Kikuchi
1484: PPUSH
1485: LD_EXP 1
1489: NOT
1490: PPUSH
1491: LD_STRING 12a_
1493: PPUSH
1494: CALL 14740 0 3
1498: ST_TO_ADDR
// if Kikuchi then
1499: LD_EXP 28
1503: IFFALSE 1520
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1505: LD_EXP 28
1509: PPUSH
1510: LD_INT 13
1512: PPUSH
1513: LD_INT 0
1515: PPUSH
1516: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1520: LD_ADDR_EXP 29
1524: PUSH
1525: LD_STRING Simms
1527: PPUSH
1528: LD_EXP 1
1532: NOT
1533: PPUSH
1534: LD_STRING 12a_
1536: PPUSH
1537: CALL 14740 0 3
1541: ST_TO_ADDR
// if Simms then
1542: LD_EXP 29
1546: IFFALSE 1563
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1548: LD_EXP 29
1552: PPUSH
1553: LD_INT 13
1555: PPUSH
1556: LD_INT 0
1558: PPUSH
1559: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1563: LD_ADDR_EXP 30
1567: PUSH
1568: LD_STRING Joan
1570: PPUSH
1571: LD_EXP 1
1575: NOT
1576: PPUSH
1577: LD_STRING 12a_
1579: PPUSH
1580: CALL 14740 0 3
1584: ST_TO_ADDR
// if Joan then
1585: LD_EXP 30
1589: IFFALSE 1606
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1591: LD_EXP 30
1595: PPUSH
1596: LD_INT 13
1598: PPUSH
1599: LD_INT 0
1601: PPUSH
1602: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1606: LD_ADDR_EXP 31
1610: PUSH
1611: LD_STRING DeltaDoctor
1613: PPUSH
1614: LD_EXP 1
1618: NOT
1619: PPUSH
1620: LD_STRING 12a_
1622: PPUSH
1623: CALL 14740 0 3
1627: ST_TO_ADDR
// if DeltaDoctor then
1628: LD_EXP 31
1632: IFFALSE 1649
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1634: LD_EXP 31
1638: PPUSH
1639: LD_INT 13
1641: PPUSH
1642: LD_INT 0
1644: PPUSH
1645: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1649: LD_ADDR_VAR 0 4
1653: PUSH
1654: LD_STRING 12a_others
1656: PPUSH
1657: CALL_OW 31
1661: ST_TO_ADDR
// if tmp then
1662: LD_VAR 0 4
1666: IFFALSE 1700
// for i in tmp do
1668: LD_ADDR_VAR 0 3
1672: PUSH
1673: LD_VAR 0 4
1677: PUSH
1678: FOR_IN
1679: IFFALSE 1698
// PlaceUnitArea ( i , alliance_start , false ) ;
1681: LD_VAR 0 3
1685: PPUSH
1686: LD_INT 13
1688: PPUSH
1689: LD_INT 0
1691: PPUSH
1692: CALL_OW 49
1696: GO 1678
1698: POP
1699: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1700: LD_INT 3
1702: PPUSH
1703: LD_INT 3
1705: PPUSH
1706: LD_INT 3
1708: PPUSH
1709: LD_INT 12
1711: PPUSH
1712: LD_INT 100
1714: PPUSH
1715: CALL 19604 0 5
// veh := CreateVehicle ;
1719: LD_ADDR_VAR 0 2
1723: PUSH
1724: CALL_OW 45
1728: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1729: LD_VAR 0 2
1733: PPUSH
1734: LD_INT 2
1736: PPUSH
1737: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1741: LD_VAR 0 2
1745: PPUSH
1746: LD_INT 60
1748: PPUSH
1749: LD_INT 6
1751: PPUSH
1752: LD_INT 0
1754: PPUSH
1755: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1759: LD_VAR 0 2
1763: PPUSH
1764: LD_INT 4
1766: PPUSH
1767: LD_INT 30
1769: PPUSH
1770: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1774: LD_STRING 11_artifact_captured
1776: PPUSH
1777: LD_INT 0
1779: PPUSH
1780: CALL_OW 30
1784: IFFALSE 1860
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1786: LD_INT 3
1788: PPUSH
1789: LD_INT 3
1791: PPUSH
1792: LD_INT 3
1794: PPUSH
1795: LD_INT 12
1797: PPUSH
1798: LD_INT 100
1800: PPUSH
1801: CALL 19604 0 5
// veh := CreateVehicle ;
1805: LD_ADDR_VAR 0 2
1809: PUSH
1810: CALL_OW 45
1814: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1815: LD_VAR 0 2
1819: PPUSH
1820: LD_INT 3
1822: PPUSH
1823: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1827: LD_VAR 0 2
1831: PPUSH
1832: LD_INT 75
1834: PPUSH
1835: LD_INT 6
1837: PPUSH
1838: LD_INT 0
1840: PPUSH
1841: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1845: LD_VAR 0 2
1849: PPUSH
1850: LD_INT 4
1852: PPUSH
1853: LD_INT 50
1855: PPUSH
1856: CALL_OW 290
// end ; end ;
1860: LD_VAR 0 1
1864: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1865: LD_INT 0
1867: PPUSH
1868: PPUSH
1869: PPUSH
1870: PPUSH
// uc_side := 6 ;
1871: LD_ADDR_OWVAR 20
1875: PUSH
1876: LD_INT 6
1878: ST_TO_ADDR
// uc_nation := 3 ;
1879: LD_ADDR_OWVAR 21
1883: PUSH
1884: LD_INT 3
1886: ST_TO_ADDR
// InitHc ;
1887: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1891: LD_ADDR_EXP 32
1895: PUSH
1896: LD_STRING Gossudarov
1898: PPUSH
1899: CALL_OW 25
1903: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1904: LD_ADDR_EXP 33
1908: PUSH
1909: LD_STRING Kirilenkova
1911: PPUSH
1912: CALL_OW 25
1916: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1917: LD_ADDR_EXP 34
1921: PUSH
1922: LD_STRING Titov
1924: PPUSH
1925: CALL_OW 25
1929: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1930: LD_ADDR_EXP 39
1934: PUSH
1935: LD_STRING Oblukov
1937: PPUSH
1938: CALL_OW 25
1942: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1943: LD_ADDR_EXP 36
1947: PUSH
1948: LD_STRING Dolgov
1950: PPUSH
1951: CALL_OW 25
1955: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1956: LD_ADDR_EXP 37
1960: PUSH
1961: LD_STRING Petrosyan
1963: PPUSH
1964: CALL_OW 25
1968: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1969: LD_ADDR_EXP 38
1973: PUSH
1974: LD_STRING Scholtze
1976: PPUSH
1977: CALL_OW 25
1981: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1982: LD_ADDR_EXP 40
1986: PUSH
1987: LD_STRING Kapitsova
1989: PPUSH
1990: CALL_OW 25
1994: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1995: LD_ADDR_VAR 0 2
1999: PUSH
2000: LD_EXP 32
2004: PUSH
2005: LD_EXP 33
2009: PUSH
2010: LD_EXP 34
2014: PUSH
2015: LD_EXP 39
2019: PUSH
2020: LD_EXP 36
2024: PUSH
2025: LD_EXP 37
2029: PUSH
2030: LD_EXP 38
2034: PUSH
2035: LD_EXP 40
2039: PUSH
2040: EMPTY
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: LIST
2049: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2050: LD_INT 1
2052: PPUSH
2053: LD_INT 4
2055: PPUSH
2056: LD_INT 8
2058: PPUSH
2059: CALL_OW 380
// un := CreateHuman ;
2063: LD_ADDR_VAR 0 4
2067: PUSH
2068: CALL_OW 44
2072: ST_TO_ADDR
// tmp := tmp ^ un ;
2073: LD_ADDR_VAR 0 2
2077: PUSH
2078: LD_VAR 0 2
2082: PUSH
2083: LD_VAR 0 4
2087: ADD
2088: ST_TO_ADDR
// for i in tmp do
2089: LD_ADDR_VAR 0 3
2093: PUSH
2094: LD_VAR 0 2
2098: PUSH
2099: FOR_IN
2100: IFFALSE 2119
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2102: LD_VAR 0 3
2106: PPUSH
2107: LD_INT 14
2109: PPUSH
2110: LD_INT 0
2112: PPUSH
2113: CALL_OW 49
2117: GO 2099
2119: POP
2120: POP
// if freedom then
2121: LD_EXP 3
2125: IFFALSE 2158
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2127: LD_VAR 0 2
2131: PPUSH
2132: LD_EXP 3
2136: PPUSH
2137: CALL_OW 250
2141: PPUSH
2142: LD_EXP 3
2146: PPUSH
2147: CALL_OW 251
2151: PPUSH
2152: CALL_OW 111
2156: GO 2173
// ComMoveXY ( tmp , 70 , 48 ) ;
2158: LD_VAR 0 2
2162: PPUSH
2163: LD_INT 70
2165: PPUSH
2166: LD_INT 48
2168: PPUSH
2169: CALL_OW 111
// end ;
2173: LD_VAR 0 1
2177: RET
// export function PrepareBelkov ; begin
2178: LD_INT 0
2180: PPUSH
// uc_side := 4 ;
2181: LD_ADDR_OWVAR 20
2185: PUSH
2186: LD_INT 4
2188: ST_TO_ADDR
// uc_nation := 3 ;
2189: LD_ADDR_OWVAR 21
2193: PUSH
2194: LD_INT 3
2196: ST_TO_ADDR
// InitHc ;
2197: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2201: LD_ADDR_EXP 47
2205: PUSH
2206: LD_STRING Belkov
2208: PPUSH
2209: CALL_OW 25
2213: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2214: LD_EXP 47
2218: PPUSH
2219: LD_INT 14
2221: PPUSH
2222: LD_INT 0
2224: PPUSH
2225: CALL_OW 49
// end ;
2229: LD_VAR 0 1
2233: RET
// export function PrepareGnyevko ; begin
2234: LD_INT 0
2236: PPUSH
// uc_side := 4 ;
2237: LD_ADDR_OWVAR 20
2241: PUSH
2242: LD_INT 4
2244: ST_TO_ADDR
// uc_nation := 3 ;
2245: LD_ADDR_OWVAR 21
2249: PUSH
2250: LD_INT 3
2252: ST_TO_ADDR
// InitHc ;
2253: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2257: LD_ADDR_EXP 48
2261: PUSH
2262: LD_STRING Gnyevko
2264: PPUSH
2265: CALL_OW 25
2269: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2270: LD_EXP 48
2274: PPUSH
2275: LD_INT 14
2277: PPUSH
2278: LD_INT 0
2280: PPUSH
2281: CALL_OW 49
// end ;
2285: LD_VAR 0 1
2289: RET
// export function PrepareBurlak ; var i , tmp ; begin
2290: LD_INT 0
2292: PPUSH
2293: PPUSH
2294: PPUSH
// uc_side := 4 ;
2295: LD_ADDR_OWVAR 20
2299: PUSH
2300: LD_INT 4
2302: ST_TO_ADDR
// uc_nation := 3 ;
2303: LD_ADDR_OWVAR 21
2307: PUSH
2308: LD_INT 3
2310: ST_TO_ADDR
// InitHc ;
2311: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2315: LD_ADDR_EXP 46
2319: PUSH
2320: LD_STRING Burlak
2322: PPUSH
2323: CALL_OW 25
2327: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2328: LD_INT 24
2330: PUSH
2331: LD_INT 23
2333: PUSH
2334: LD_INT 22
2336: PUSH
2337: EMPTY
2338: LIST
2339: LIST
2340: LIST
2341: PUSH
2342: LD_OWVAR 67
2346: ARRAY
2347: PPUSH
2348: LD_INT 1
2350: PPUSH
2351: LD_INT 1
2353: PPUSH
2354: LD_INT 45
2356: PUSH
2357: LD_INT 44
2359: PUSH
2360: LD_INT 43
2362: PUSH
2363: EMPTY
2364: LIST
2365: LIST
2366: LIST
2367: PUSH
2368: LD_OWVAR 67
2372: ARRAY
2373: PPUSH
2374: LD_INT 0
2376: PPUSH
2377: CALL 19604 0 5
// Masha := CreateVehicle ;
2381: LD_ADDR_EXP 49
2385: PUSH
2386: CALL_OW 45
2390: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2391: LD_EXP 49
2395: PUSH
2396: LD_EXP 46
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PPUSH
2405: LD_INT 499
2407: PPUSH
2408: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2412: LD_EXP 49
2416: PPUSH
2417: LD_INT 3
2419: PPUSH
2420: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2424: LD_EXP 49
2428: PPUSH
2429: LD_INT 1
2431: PPUSH
2432: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2436: LD_INT 1
2438: PPUSH
2439: LD_INT 18
2441: PPUSH
2442: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2446: LD_INT 35
2448: PPUSH
2449: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2453: LD_ADDR_VAR 0 3
2457: PUSH
2458: LD_INT 18
2460: PPUSH
2461: EMPTY
2462: PPUSH
2463: CALL_OW 70
2467: ST_TO_ADDR
// if tmp then
2468: LD_VAR 0 3
2472: IFFALSE 2506
// for i in tmp do
2474: LD_ADDR_VAR 0 2
2478: PUSH
2479: LD_VAR 0 3
2483: PUSH
2484: FOR_IN
2485: IFFALSE 2504
// ComMoveXY ( i , 114 , 9 ) ;
2487: LD_VAR 0 2
2491: PPUSH
2492: LD_INT 114
2494: PPUSH
2495: LD_INT 9
2497: PPUSH
2498: CALL_OW 111
2502: GO 2484
2504: POP
2505: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2506: LD_INT 18
2508: PPUSH
2509: EMPTY
2510: PPUSH
2511: CALL_OW 70
2515: NOT
2516: PUSH
2517: LD_INT 123
2519: PPUSH
2520: LD_INT 3
2522: PPUSH
2523: CALL_OW 428
2527: PUSH
2528: LD_INT 0
2530: EQUAL
2531: AND
2532: IFFALSE 2446
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2534: LD_EXP 49
2538: PPUSH
2539: LD_INT 123
2541: PPUSH
2542: LD_INT 3
2544: PPUSH
2545: LD_INT 0
2547: PPUSH
2548: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2552: LD_EXP 46
2556: PPUSH
2557: LD_INT 125
2559: PPUSH
2560: LD_INT 1
2562: PPUSH
2563: LD_INT 0
2565: PPUSH
2566: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2570: LD_EXP 46
2574: PPUSH
2575: LD_EXP 49
2579: PPUSH
2580: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2584: LD_INT 10
2586: PPUSH
2587: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2591: LD_EXP 49
2595: PPUSH
2596: LD_INT 110
2598: PPUSH
2599: LD_INT 10
2601: PPUSH
2602: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2606: LD_ADDR_EXP 42
2610: PUSH
2611: LD_STRING Petrovova
2613: PPUSH
2614: CALL_OW 25
2618: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2619: LD_ADDR_EXP 44
2623: PUSH
2624: LD_STRING Kuzmov
2626: PPUSH
2627: CALL_OW 25
2631: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2632: LD_ADDR_EXP 43
2636: PUSH
2637: LD_STRING Kovalyuk
2639: PPUSH
2640: CALL_OW 25
2644: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2645: LD_ADDR_EXP 41
2649: PUSH
2650: LD_STRING Lipshchin
2652: PPUSH
2653: CALL_OW 25
2657: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2658: LD_ADDR_EXP 45
2662: PUSH
2663: LD_STRING Karamazov
2665: PPUSH
2666: CALL_OW 25
2670: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: LD_EXP 42
2680: PUSH
2681: LD_EXP 44
2685: PUSH
2686: LD_EXP 43
2690: PUSH
2691: LD_EXP 41
2695: PUSH
2696: LD_EXP 45
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: LIST
2705: LIST
2706: LIST
2707: ST_TO_ADDR
// for i in tmp do
2708: LD_ADDR_VAR 0 2
2712: PUSH
2713: LD_VAR 0 3
2717: PUSH
2718: FOR_IN
2719: IFFALSE 2758
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2721: LD_VAR 0 2
2725: PPUSH
2726: LD_INT 399
2728: PPUSH
2729: LD_INT 799
2731: PPUSH
2732: CALL_OW 12
2736: PPUSH
2737: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2741: LD_VAR 0 2
2745: PPUSH
2746: LD_INT 19
2748: PPUSH
2749: LD_INT 0
2751: PPUSH
2752: CALL_OW 49
// end ;
2756: GO 2718
2758: POP
2759: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2760: LD_VAR 0 3
2764: PPUSH
2765: LD_INT 116
2767: PPUSH
2768: LD_INT 8
2770: PPUSH
2771: CALL_OW 111
// AddComHold ( tmp ) ;
2775: LD_VAR 0 3
2779: PPUSH
2780: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2784: LD_ADDR_VAR 0 2
2788: PUSH
2789: LD_VAR 0 3
2793: PPUSH
2794: LD_INT 25
2796: PUSH
2797: LD_INT 1
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: PPUSH
2804: CALL_OW 72
2808: PUSH
2809: FOR_IN
2810: IFFALSE 2850
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2812: LD_VAR 0 2
2816: PPUSH
2817: LD_INT 20
2819: PPUSH
2820: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2824: LD_VAR 0 2
2828: PPUSH
2829: LD_INT 147
2831: PPUSH
2832: LD_INT 45
2834: PPUSH
2835: CALL_OW 178
// AddComCrawl ( i ) ;
2839: LD_VAR 0 2
2843: PPUSH
2844: CALL_OW 197
// end ;
2848: GO 2809
2850: POP
2851: POP
// repeat wait ( 0 0$1 ) ;
2852: LD_INT 35
2854: PPUSH
2855: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2859: LD_EXP 49
2863: PPUSH
2864: LD_INT 110
2866: PPUSH
2867: LD_INT 10
2869: PPUSH
2870: CALL_OW 307
2874: PUSH
2875: LD_EXP 49
2879: PPUSH
2880: CALL_OW 305
2884: NOT
2885: OR
2886: IFFALSE 2852
// ComStop ( Burlak ) ;
2888: LD_EXP 46
2892: PPUSH
2893: CALL_OW 141
// AddComHold ( Burlak ) ;
2897: LD_EXP 46
2901: PPUSH
2902: CALL_OW 200
// end ; end_of_file
2906: LD_VAR 0 1
2910: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2911: LD_INT 0
2913: PPUSH
2914: PPUSH
2915: PPUSH
2916: PPUSH
2917: PPUSH
// uc_side := 3 ;
2918: LD_ADDR_OWVAR 20
2922: PUSH
2923: LD_INT 3
2925: ST_TO_ADDR
// uc_nation := 3 ;
2926: LD_ADDR_OWVAR 21
2930: PUSH
2931: LD_INT 3
2933: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2934: LD_ADDR_EXP 50
2938: PUSH
2939: LD_INT 47
2941: PPUSH
2942: LD_INT 4
2944: PPUSH
2945: LD_STRING 
2947: PPUSH
2948: LD_INT 7
2950: PUSH
2951: LD_INT 8
2953: PUSH
2954: LD_INT 10
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: LIST
2961: PUSH
2962: LD_OWVAR 67
2966: ARRAY
2967: PPUSH
2968: LD_INT 10000
2970: PUSH
2971: LD_INT 3000
2973: PUSH
2974: LD_INT 300
2976: PUSH
2977: EMPTY
2978: LIST
2979: LIST
2980: LIST
2981: PPUSH
2982: LD_INT 9
2984: PUSH
2985: LD_INT 5
2987: PUSH
2988: LD_INT 6
2990: PUSH
2991: LD_INT 6
2993: PUSH
2994: EMPTY
2995: LIST
2996: LIST
2997: LIST
2998: LIST
2999: PPUSH
3000: CALL 23050 0 6
3004: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3005: LD_ADDR_EXP 59
3009: PUSH
3010: LD_EXP 59
3014: PPUSH
3015: LD_INT 2
3017: PPUSH
3018: LD_EXP 50
3022: PPUSH
3023: CALL_OW 1
3027: ST_TO_ADDR
// tmp := [ ] ;
3028: LD_ADDR_VAR 0 4
3032: PUSH
3033: EMPTY
3034: ST_TO_ADDR
// for i = 1 to 4 do
3035: LD_ADDR_VAR 0 2
3039: PUSH
3040: DOUBLE
3041: LD_INT 1
3043: DEC
3044: ST_TO_ADDR
3045: LD_INT 4
3047: PUSH
3048: FOR_TO
3049: IFFALSE 3142
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3051: LD_INT 22
3053: PPUSH
3054: LD_INT 3
3056: PPUSH
3057: LD_INT 3
3059: PPUSH
3060: LD_INT 43
3062: PUSH
3063: LD_INT 45
3065: PUSH
3066: LD_INT 45
3068: PUSH
3069: LD_INT 44
3071: PUSH
3072: EMPTY
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: PUSH
3078: LD_VAR 0 2
3082: PUSH
3083: LD_INT 4
3085: MOD
3086: PUSH
3087: LD_INT 1
3089: PLUS
3090: ARRAY
3091: PPUSH
3092: LD_INT 100
3094: PPUSH
3095: CALL 19604 0 5
// veh := CreateVehicle ;
3099: LD_ADDR_VAR 0 3
3103: PUSH
3104: CALL_OW 45
3108: ST_TO_ADDR
// tmp := tmp ^ veh ;
3109: LD_ADDR_VAR 0 4
3113: PUSH
3114: LD_VAR 0 4
3118: PUSH
3119: LD_VAR 0 3
3123: ADD
3124: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3125: LD_VAR 0 3
3129: PPUSH
3130: LD_INT 2
3132: PPUSH
3133: LD_INT 0
3135: PPUSH
3136: CALL_OW 49
// end ;
3140: GO 3048
3142: POP
3143: POP
// russian_guard := tmp ;
3144: LD_ADDR_EXP 51
3148: PUSH
3149: LD_VAR 0 4
3153: ST_TO_ADDR
// if Difficulty = 3 then
3154: LD_OWVAR 67
3158: PUSH
3159: LD_INT 3
3161: EQUAL
3162: IFFALSE 3226
// begin bc_type := b_breastwork ;
3164: LD_ADDR_OWVAR 42
3168: PUSH
3169: LD_INT 31
3171: ST_TO_ADDR
// bc_level := 10 ;
3172: LD_ADDR_OWVAR 43
3176: PUSH
3177: LD_INT 10
3179: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3180: LD_ADDR_VAR 0 5
3184: PUSH
3185: LD_INT 96
3187: PPUSH
3188: LD_INT 105
3190: PPUSH
3191: LD_INT 3
3193: PPUSH
3194: CALL_OW 47
3198: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3199: LD_INT 0
3201: PPUSH
3202: LD_INT 9
3204: PPUSH
3205: LD_INT 10
3207: PPUSH
3208: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3212: CALL_OW 44
3216: PPUSH
3217: LD_VAR 0 5
3221: PPUSH
3222: CALL_OW 52
// end ; end ;
3226: LD_VAR 0 1
3230: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers , amount ;
3231: LD_INT 47
3233: PPUSH
3234: CALL_OW 302
3238: PUSH
3239: LD_EXP 6
3243: AND
3244: IFFALSE 3929
3246: GO 3248
3248: DISABLE
3249: LD_INT 0
3251: PPUSH
3252: PPUSH
3253: PPUSH
3254: PPUSH
3255: PPUSH
3256: PPUSH
3257: PPUSH
// begin enable ;
3258: ENABLE
// base := 2 ;
3259: LD_ADDR_VAR 0 2
3263: PUSH
3264: LD_INT 2
3266: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3267: LD_ADDR_VAR 0 4
3271: PUSH
3272: LD_INT 0
3274: PUSH
3275: LD_INT 0
3277: PUSH
3278: LD_INT 0
3280: PUSH
3281: LD_INT 0
3283: PUSH
3284: LD_INT 0
3286: PUSH
3287: LD_INT 0
3289: PUSH
3290: LD_INT 0
3292: PUSH
3293: LD_INT 0
3295: PUSH
3296: LD_INT 1
3298: PUSH
3299: LD_INT 0
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: LIST
3306: LIST
3307: LIST
3308: LIST
3309: LIST
3310: LIST
3311: LIST
3312: LIST
3313: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3314: LD_ADDR_VAR 0 3
3318: PUSH
3319: LD_INT 22
3321: PUSH
3322: LD_INT 1
3324: PUSH
3325: LD_INT 3
3327: PUSH
3328: LD_INT 45
3330: PUSH
3331: EMPTY
3332: LIST
3333: LIST
3334: LIST
3335: LIST
3336: PUSH
3337: LD_INT 21
3339: PUSH
3340: LD_INT 1
3342: PUSH
3343: LD_INT 3
3345: PUSH
3346: LD_INT 45
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: LIST
3354: PUSH
3355: LD_INT 22
3357: PUSH
3358: LD_INT 1
3360: PUSH
3361: LD_INT 3
3363: PUSH
3364: LD_INT 45
3366: PUSH
3367: EMPTY
3368: LIST
3369: LIST
3370: LIST
3371: LIST
3372: PUSH
3373: LD_INT 23
3375: PUSH
3376: LD_INT 1
3378: PUSH
3379: LD_INT 3
3381: PUSH
3382: LD_INT 46
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: LIST
3389: LIST
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: ST_TO_ADDR
// amount := Difficulty ;
3397: LD_ADDR_VAR 0 7
3401: PUSH
3402: LD_OWVAR 67
3406: ST_TO_ADDR
// if tick > 30 30$00 then
3407: LD_OWVAR 1
3411: PUSH
3412: LD_INT 63000
3414: GREATER
3415: IFFALSE 3448
// amount := amount + [ 2 , 3 , 4 ] [ Difficulty ] ;
3417: LD_ADDR_VAR 0 7
3421: PUSH
3422: LD_VAR 0 7
3426: PUSH
3427: LD_INT 2
3429: PUSH
3430: LD_INT 3
3432: PUSH
3433: LD_INT 4
3435: PUSH
3436: EMPTY
3437: LIST
3438: LIST
3439: LIST
3440: PUSH
3441: LD_OWVAR 67
3445: ARRAY
3446: PLUS
3447: ST_TO_ADDR
// for i = 1 to amount do
3448: LD_ADDR_VAR 0 1
3452: PUSH
3453: DOUBLE
3454: LD_INT 1
3456: DEC
3457: ST_TO_ADDR
3458: LD_VAR 0 7
3462: PUSH
3463: FOR_TO
3464: IFFALSE 3552
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3466: LD_ADDR_VAR 0 3
3470: PUSH
3471: LD_VAR 0 3
3475: PPUSH
3476: LD_VAR 0 3
3480: PUSH
3481: LD_INT 1
3483: PLUS
3484: PPUSH
3485: LD_INT 23
3487: PUSH
3488: LD_INT 24
3490: PUSH
3491: EMPTY
3492: LIST
3493: LIST
3494: PUSH
3495: LD_INT 1
3497: PPUSH
3498: LD_INT 2
3500: PPUSH
3501: CALL_OW 12
3505: ARRAY
3506: PUSH
3507: LD_INT 1
3509: PUSH
3510: LD_INT 3
3512: PUSH
3513: LD_INT 46
3515: PUSH
3516: LD_INT 47
3518: PUSH
3519: LD_INT 45
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: LIST
3526: PUSH
3527: LD_INT 1
3529: PPUSH
3530: LD_INT 3
3532: PPUSH
3533: CALL_OW 12
3537: ARRAY
3538: PUSH
3539: EMPTY
3540: LIST
3541: LIST
3542: LIST
3543: LIST
3544: PPUSH
3545: CALL_OW 2
3549: ST_TO_ADDR
3550: GO 3463
3552: POP
3553: POP
// MC_InsertProduceList ( base , tmp ) ;
3554: LD_VAR 0 2
3558: PPUSH
3559: LD_VAR 0 3
3563: PPUSH
3564: CALL 77687 0 2
// repeat wait ( 0 0$1 ) ;
3568: LD_INT 35
3570: PPUSH
3571: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3575: LD_VAR 0 2
3579: PPUSH
3580: LD_INT 1
3582: PPUSH
3583: CALL 79105 0 2
3587: PUSH
3588: LD_VAR 0 7
3592: GREATEREQUAL
3593: IFFALSE 3568
// wait ( 0 0$30 ) ;
3595: LD_INT 1050
3597: PPUSH
3598: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3602: LD_ADDR_VAR 0 5
3606: PUSH
3607: LD_INT 71
3609: PUSH
3610: LD_INT 19
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PUSH
3617: LD_INT 91
3619: PUSH
3620: LD_INT 67
3622: PUSH
3623: EMPTY
3624: LIST
3625: LIST
3626: PUSH
3627: LD_INT 52
3629: PUSH
3630: LD_INT 44
3632: PUSH
3633: EMPTY
3634: LIST
3635: LIST
3636: PUSH
3637: LD_INT 68
3639: PUSH
3640: LD_INT 48
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: LIST
3651: LIST
3652: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3653: LD_ADDR_VAR 0 6
3657: PUSH
3658: LD_EXP 78
3662: PUSH
3663: LD_VAR 0 2
3667: ARRAY
3668: PUSH
3669: LD_EXP 78
3673: PUSH
3674: LD_VAR 0 2
3678: ARRAY
3679: PPUSH
3680: LD_INT 2
3682: PUSH
3683: LD_INT 34
3685: PUSH
3686: LD_INT 51
3688: PUSH
3689: EMPTY
3690: LIST
3691: LIST
3692: PUSH
3693: LD_INT 34
3695: PUSH
3696: LD_INT 52
3698: PUSH
3699: EMPTY
3700: LIST
3701: LIST
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: LIST
3707: PPUSH
3708: CALL_OW 72
3712: DIFF
3713: ST_TO_ADDR
// if not attackers then
3714: LD_VAR 0 6
3718: NOT
3719: IFFALSE 3723
// exit ;
3721: GO 3929
// ru_attackers := attackers ;
3723: LD_ADDR_EXP 52
3727: PUSH
3728: LD_VAR 0 6
3732: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3733: LD_ADDR_EXP 78
3737: PUSH
3738: LD_EXP 78
3742: PPUSH
3743: LD_VAR 0 2
3747: PPUSH
3748: LD_EXP 78
3752: PUSH
3753: LD_VAR 0 2
3757: ARRAY
3758: PUSH
3759: LD_VAR 0 6
3763: DIFF
3764: PPUSH
3765: CALL_OW 1
3769: ST_TO_ADDR
// for i = 1 to attackers do
3770: LD_ADDR_VAR 0 1
3774: PUSH
3775: DOUBLE
3776: LD_INT 1
3778: DEC
3779: ST_TO_ADDR
3780: LD_VAR 0 6
3784: PUSH
3785: FOR_TO
3786: IFFALSE 3863
// begin case i mod 3 of 0 :
3788: LD_VAR 0 1
3792: PUSH
3793: LD_INT 3
3795: MOD
3796: PUSH
3797: LD_INT 0
3799: DOUBLE
3800: EQUAL
3801: IFTRUE 3805
3803: GO 3808
3805: POP
// ; 1 :
3806: GO 3861
3808: LD_INT 1
3810: DOUBLE
3811: EQUAL
3812: IFTRUE 3816
3814: GO 3834
3816: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3817: LD_VAR 0 1
3821: PPUSH
3822: LD_INT 32
3824: PPUSH
3825: LD_INT 49
3827: PPUSH
3828: CALL_OW 114
3832: GO 3861
3834: LD_INT 2
3836: DOUBLE
3837: EQUAL
3838: IFTRUE 3842
3840: GO 3860
3842: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3843: LD_VAR 0 1
3847: PPUSH
3848: LD_INT 117
3850: PPUSH
3851: LD_INT 107
3853: PPUSH
3854: CALL_OW 114
3858: GO 3861
3860: POP
// end ;
3861: GO 3785
3863: POP
3864: POP
// repeat wait ( 0 0$1 ) ;
3865: LD_INT 35
3867: PPUSH
3868: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3872: LD_VAR 0 6
3876: PPUSH
3877: LD_INT 60
3879: PUSH
3880: EMPTY
3881: LIST
3882: PPUSH
3883: CALL_OW 72
3887: NOT
3888: IFFALSE 3865
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3890: LD_VAR 0 2
3894: PPUSH
3895: LD_VAR 0 6
3899: PPUSH
3900: LD_VAR 0 5
3904: PPUSH
3905: LD_VAR 0 4
3909: PPUSH
3910: CALL 77872 0 4
// if not first_attack then
3914: LD_EXP 7
3918: NOT
3919: IFFALSE 3929
// first_attack := true ;
3921: LD_ADDR_EXP 7
3925: PUSH
3926: LD_INT 1
3928: ST_TO_ADDR
// end ; end_of_file
3929: PPOPN 7
3931: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3932: LD_INT 0
3934: PPUSH
3935: PPUSH
3936: PPUSH
3937: PPUSH
3938: PPUSH
3939: PPUSH
3940: PPUSH
// uc_side := 2 ;
3941: LD_ADDR_OWVAR 20
3945: PUSH
3946: LD_INT 2
3948: ST_TO_ADDR
// uc_nation := 2 ;
3949: LD_ADDR_OWVAR 21
3953: PUSH
3954: LD_INT 2
3956: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3957: LD_ADDR_EXP 55
3961: PUSH
3962: LD_STRING Abdul
3964: PPUSH
3965: CALL_OW 25
3969: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3970: LD_EXP 55
3974: PPUSH
3975: LD_INT 11
3977: PPUSH
3978: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3982: LD_EXP 55
3986: PPUSH
3987: LD_INT 1
3989: PPUSH
3990: CALL_OW 52
// vc_chassis := 31 ;
3994: LD_ADDR_OWVAR 37
3998: PUSH
3999: LD_INT 31
4001: ST_TO_ADDR
// vc_control := control_rider ;
4002: LD_ADDR_OWVAR 38
4006: PUSH
4007: LD_INT 4
4009: ST_TO_ADDR
// mastodont := CreateVehicle ;
4010: LD_ADDR_EXP 56
4014: PUSH
4015: CALL_OW 45
4019: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4020: LD_EXP 56
4024: PPUSH
4025: LD_INT 153
4027: PPUSH
4028: LD_INT 71
4030: PPUSH
4031: LD_INT 0
4033: PPUSH
4034: CALL_OW 48
// InitVc ;
4038: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4042: LD_ADDR_EXP 53
4046: PUSH
4047: LD_INT 1
4049: PPUSH
4050: LD_INT 3
4052: PPUSH
4053: LD_STRING 
4055: PPUSH
4056: LD_INT 7
4058: PUSH
4059: LD_INT 8
4061: PUSH
4062: LD_INT 10
4064: PUSH
4065: EMPTY
4066: LIST
4067: LIST
4068: LIST
4069: PUSH
4070: LD_OWVAR 67
4074: ARRAY
4075: PPUSH
4076: LD_INT 5000
4078: PUSH
4079: LD_INT 1000
4081: PUSH
4082: LD_INT 300
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: LIST
4089: PPUSH
4090: LD_INT 18
4092: PUSH
4093: LD_INT 5
4095: PUSH
4096: LD_INT 6
4098: PUSH
4099: LD_INT 9
4101: PUSH
4102: EMPTY
4103: LIST
4104: LIST
4105: LIST
4106: LIST
4107: PPUSH
4108: CALL 23050 0 6
4112: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4113: LD_ADDR_EXP 59
4117: PUSH
4118: LD_EXP 59
4122: PPUSH
4123: LD_INT 1
4125: PPUSH
4126: LD_EXP 53
4130: PPUSH
4131: CALL_OW 1
4135: ST_TO_ADDR
// tmp := [ ] ;
4136: LD_ADDR_VAR 0 4
4140: PUSH
4141: EMPTY
4142: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4143: LD_ADDR_OWVAR 37
4147: PUSH
4148: LD_INT 14
4150: ST_TO_ADDR
// vc_engine := engine_siberite ;
4151: LD_ADDR_OWVAR 39
4155: PUSH
4156: LD_INT 3
4158: ST_TO_ADDR
// vc_control := control_manual ;
4159: LD_ADDR_OWVAR 38
4163: PUSH
4164: LD_INT 1
4166: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4167: LD_ADDR_OWVAR 40
4171: PUSH
4172: LD_INT 31
4174: ST_TO_ADDR
// for i = 1 to 3 do
4175: LD_ADDR_VAR 0 2
4179: PUSH
4180: DOUBLE
4181: LD_INT 1
4183: DEC
4184: ST_TO_ADDR
4185: LD_INT 3
4187: PUSH
4188: FOR_TO
4189: IFFALSE 4433
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4191: LD_ADDR_VAR 0 5
4195: PUSH
4196: LD_INT 153
4198: PUSH
4199: LD_INT 71
4201: PUSH
4202: EMPTY
4203: LIST
4204: LIST
4205: PUSH
4206: LD_INT 155
4208: PUSH
4209: LD_INT 81
4211: PUSH
4212: EMPTY
4213: LIST
4214: LIST
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PUSH
4220: LD_VAR 0 2
4224: PUSH
4225: LD_INT 2
4227: MOD
4228: PUSH
4229: LD_INT 1
4231: PLUS
4232: ARRAY
4233: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 ] [ Difficulty ] ) ;
4234: LD_INT 0
4236: PPUSH
4237: LD_INT 3
4239: PPUSH
4240: LD_INT 7
4242: PUSH
4243: LD_INT 8
4245: PUSH
4246: LD_INT 10
4248: PUSH
4249: EMPTY
4250: LIST
4251: LIST
4252: LIST
4253: PUSH
4254: LD_OWVAR 67
4258: ARRAY
4259: PPUSH
4260: CALL_OW 380
// un := CreateVehicle ;
4264: LD_ADDR_VAR 0 6
4268: PUSH
4269: CALL_OW 45
4273: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4274: LD_VAR 0 6
4278: PPUSH
4279: LD_INT 0
4281: PPUSH
4282: LD_INT 5
4284: PPUSH
4285: CALL_OW 12
4289: PPUSH
4290: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4294: LD_VAR 0 6
4298: PPUSH
4299: LD_VAR 0 5
4303: PUSH
4304: LD_INT 1
4306: ARRAY
4307: PPUSH
4308: LD_VAR 0 5
4312: PUSH
4313: LD_INT 2
4315: ARRAY
4316: PPUSH
4317: LD_INT 6
4319: PPUSH
4320: LD_INT 0
4322: PPUSH
4323: CALL_OW 50
// un2 := CreateHuman ;
4327: LD_ADDR_VAR 0 7
4331: PUSH
4332: CALL_OW 44
4336: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4337: LD_VAR 0 7
4341: PPUSH
4342: LD_VAR 0 6
4346: PPUSH
4347: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4351: LD_ADDR_EXP 59
4355: PUSH
4356: LD_EXP 59
4360: PPUSH
4361: LD_INT 1
4363: PUSH
4364: LD_EXP 59
4368: PUSH
4369: LD_INT 1
4371: ARRAY
4372: PUSH
4373: LD_INT 1
4375: PLUS
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: PPUSH
4381: LD_VAR 0 6
4385: PPUSH
4386: CALL 19726 0 3
4390: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4391: LD_ADDR_EXP 59
4395: PUSH
4396: LD_EXP 59
4400: PPUSH
4401: LD_INT 1
4403: PUSH
4404: LD_EXP 59
4408: PUSH
4409: LD_INT 1
4411: ARRAY
4412: PUSH
4413: LD_INT 1
4415: PLUS
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PPUSH
4421: LD_VAR 0 7
4425: PPUSH
4426: CALL 19726 0 3
4430: ST_TO_ADDR
// end ;
4431: GO 4188
4433: POP
4434: POP
// for i = 1 to 5 do
4435: LD_ADDR_VAR 0 2
4439: PUSH
4440: DOUBLE
4441: LD_INT 1
4443: DEC
4444: ST_TO_ADDR
4445: LD_INT 5
4447: PUSH
4448: FOR_TO
4449: IFFALSE 4542
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4451: LD_INT 14
4453: PPUSH
4454: LD_INT 3
4456: PPUSH
4457: LD_INT 1
4459: PPUSH
4460: LD_INT 25
4462: PUSH
4463: LD_INT 28
4465: PUSH
4466: LD_INT 28
4468: PUSH
4469: LD_INT 26
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: LIST
4476: LIST
4477: PUSH
4478: LD_VAR 0 2
4482: PUSH
4483: LD_INT 4
4485: MOD
4486: PUSH
4487: LD_INT 1
4489: PLUS
4490: ARRAY
4491: PPUSH
4492: LD_INT 100
4494: PPUSH
4495: CALL 19604 0 5
// veh := CreateVehicle ;
4499: LD_ADDR_VAR 0 3
4503: PUSH
4504: CALL_OW 45
4508: ST_TO_ADDR
// tmp := tmp ^ veh ;
4509: LD_ADDR_VAR 0 4
4513: PUSH
4514: LD_VAR 0 4
4518: PUSH
4519: LD_VAR 0 3
4523: ADD
4524: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4525: LD_VAR 0 3
4529: PPUSH
4530: LD_INT 1
4532: PPUSH
4533: LD_INT 0
4535: PPUSH
4536: CALL_OW 49
// end ;
4540: GO 4448
4542: POP
4543: POP
// arabian_guard := tmp ;
4544: LD_ADDR_EXP 54
4548: PUSH
4549: LD_VAR 0 4
4553: ST_TO_ADDR
// end ;
4554: LD_VAR 0 1
4558: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4559: LD_INT 22
4561: PUSH
4562: LD_INT 7
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PUSH
4569: LD_INT 91
4571: PUSH
4572: LD_INT 1
4574: PUSH
4575: LD_INT 12
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: LIST
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PPUSH
4587: CALL_OW 69
4591: PUSH
4592: LD_EXP 56
4596: PPUSH
4597: CALL_OW 256
4601: PUSH
4602: LD_INT 990
4604: LESS
4605: OR
4606: PUSH
4607: LD_EXP 55
4611: PPUSH
4612: CALL_OW 256
4616: PUSH
4617: LD_INT 990
4619: LESS
4620: OR
4621: IFFALSE 4764
4623: GO 4625
4625: DISABLE
// begin if IsInUnit ( Abdul ) then
4626: LD_EXP 55
4630: PPUSH
4631: CALL_OW 310
4635: IFFALSE 4646
// ComExitBuilding ( Abdul ) ;
4637: LD_EXP 55
4641: PPUSH
4642: CALL_OW 122
// if Mastodont then
4646: LD_EXP 56
4650: IFFALSE 4667
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4652: LD_EXP 56
4656: PPUSH
4657: LD_INT 205
4659: PPUSH
4660: LD_INT 132
4662: PPUSH
4663: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4667: LD_EXP 55
4671: PPUSH
4672: LD_INT 205
4674: PPUSH
4675: LD_INT 132
4677: PPUSH
4678: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4682: LD_INT 35
4684: PPUSH
4685: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4689: LD_EXP 55
4693: PPUSH
4694: LD_INT 21
4696: PPUSH
4697: CALL_OW 308
4701: IFFALSE 4682
// RemoveUnit ( Abdul ) ;
4703: LD_EXP 55
4707: PPUSH
4708: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4712: LD_INT 35
4714: PPUSH
4715: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4719: LD_EXP 56
4723: PPUSH
4724: LD_INT 21
4726: PPUSH
4727: CALL_OW 308
4731: PUSH
4732: LD_EXP 56
4736: PPUSH
4737: CALL_OW 301
4741: OR
4742: IFFALSE 4712
// if IsOk ( Mastodont ) then
4744: LD_EXP 56
4748: PPUSH
4749: CALL_OW 302
4753: IFFALSE 4764
// RemoveUnit ( Mastodont ) ;
4755: LD_EXP 56
4759: PPUSH
4760: CALL_OW 64
// end ;
4764: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4765: LD_EXP 55
4769: PPUSH
4770: CALL_OW 301
4774: PUSH
4775: LD_INT 22
4777: PUSH
4778: LD_INT 2
4780: PUSH
4781: EMPTY
4782: LIST
4783: LIST
4784: PUSH
4785: LD_INT 2
4787: PUSH
4788: LD_INT 25
4790: PUSH
4791: LD_INT 1
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: PUSH
4798: LD_INT 25
4800: PUSH
4801: LD_INT 2
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 25
4810: PUSH
4811: LD_INT 3
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 25
4820: PUSH
4821: LD_INT 4
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: LD_INT 25
4830: PUSH
4831: LD_INT 8
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PUSH
4838: EMPTY
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: PUSH
4846: EMPTY
4847: LIST
4848: LIST
4849: PPUSH
4850: CALL_OW 69
4854: PUSH
4855: LD_INT 16
4857: PUSH
4858: LD_INT 19
4860: PUSH
4861: LD_INT 22
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: LIST
4868: PUSH
4869: LD_OWVAR 67
4873: ARRAY
4874: LESS
4875: OR
4876: IFFALSE 5549
4878: GO 4880
4880: DISABLE
4881: LD_INT 0
4883: PPUSH
4884: PPUSH
4885: PPUSH
4886: PPUSH
4887: PPUSH
4888: PPUSH
// begin MC_Kill ( 1 ) ;
4889: LD_INT 1
4891: PPUSH
4892: CALL 53856 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4896: LD_ADDR_VAR 0 2
4900: PUSH
4901: LD_INT 22
4903: PUSH
4904: LD_INT 2
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: LD_INT 2
4913: PUSH
4914: LD_INT 25
4916: PUSH
4917: LD_INT 1
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: PUSH
4924: LD_INT 25
4926: PUSH
4927: LD_INT 2
4929: PUSH
4930: EMPTY
4931: LIST
4932: LIST
4933: PUSH
4934: LD_INT 25
4936: PUSH
4937: LD_INT 3
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: PUSH
4944: LD_INT 25
4946: PUSH
4947: LD_INT 4
4949: PUSH
4950: EMPTY
4951: LIST
4952: LIST
4953: PUSH
4954: LD_INT 25
4956: PUSH
4957: LD_INT 8
4959: PUSH
4960: EMPTY
4961: LIST
4962: LIST
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: LIST
4968: LIST
4969: LIST
4970: LIST
4971: PUSH
4972: EMPTY
4973: LIST
4974: LIST
4975: PPUSH
4976: CALL_OW 69
4980: ST_TO_ADDR
// for i in tmp do
4981: LD_ADDR_VAR 0 5
4985: PUSH
4986: LD_VAR 0 2
4990: PUSH
4991: FOR_IN
4992: IFFALSE 5008
// SetTag ( i , 10 ) ;
4994: LD_VAR 0 5
4998: PPUSH
4999: LD_INT 10
5001: PPUSH
5002: CALL_OW 109
5006: GO 4991
5008: POP
5009: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5010: LD_ADDR_VAR 0 3
5014: PUSH
5015: LD_INT 22
5017: PUSH
5018: LD_INT 2
5020: PUSH
5021: EMPTY
5022: LIST
5023: LIST
5024: PUSH
5025: LD_INT 21
5027: PUSH
5028: LD_INT 1
5030: PUSH
5031: EMPTY
5032: LIST
5033: LIST
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: PPUSH
5039: CALL_OW 69
5043: PUSH
5044: LD_VAR 0 2
5048: DIFF
5049: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5050: LD_ADDR_VAR 0 1
5054: PUSH
5055: LD_INT 22
5057: PUSH
5058: LD_INT 2
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: PUSH
5065: LD_INT 21
5067: PUSH
5068: LD_INT 2
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PUSH
5075: LD_INT 24
5077: PUSH
5078: LD_INT 300
5080: PUSH
5081: EMPTY
5082: LIST
5083: LIST
5084: PUSH
5085: EMPTY
5086: LIST
5087: LIST
5088: LIST
5089: PPUSH
5090: CALL_OW 69
5094: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5095: LD_ADDR_VAR 0 4
5099: PUSH
5100: LD_VAR 0 1
5104: PPUSH
5105: LD_INT 33
5107: PUSH
5108: LD_INT 1
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: PUSH
5115: LD_INT 58
5117: PUSH
5118: EMPTY
5119: LIST
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PPUSH
5125: CALL_OW 72
5129: ST_TO_ADDR
// for i in tmp do
5130: LD_ADDR_VAR 0 5
5134: PUSH
5135: LD_VAR 0 2
5139: PUSH
5140: FOR_IN
5141: IFFALSE 5325
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5143: LD_VAR 0 5
5147: PUSH
5148: LD_INT 55
5150: PUSH
5151: EMPTY
5152: LIST
5153: PPUSH
5154: CALL_OW 69
5158: IN
5159: IFFALSE 5178
// begin AddComMoveXY ( i , 209 , 132 ) ;
5161: LD_VAR 0 5
5165: PPUSH
5166: LD_INT 209
5168: PPUSH
5169: LD_INT 132
5171: PPUSH
5172: CALL_OW 171
// continue ;
5176: GO 5140
// end ; if IsInUnit ( i ) then
5178: LD_VAR 0 5
5182: PPUSH
5183: CALL_OW 310
5187: IFFALSE 5205
// begin ComExitBuilding ( i ) ;
5189: LD_VAR 0 5
5193: PPUSH
5194: CALL_OW 122
// wait ( 3 ) ;
5198: LD_INT 3
5200: PPUSH
5201: CALL_OW 67
// end ; if tmp_empty then
5205: LD_VAR 0 4
5209: IFFALSE 5308
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5211: LD_VAR 0 5
5215: PPUSH
5216: LD_VAR 0 4
5220: PPUSH
5221: LD_VAR 0 5
5225: PPUSH
5226: CALL_OW 74
5230: PPUSH
5231: CALL_OW 296
5235: PUSH
5236: LD_INT 25
5238: LESS
5239: IFFALSE 5308
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5241: LD_ADDR_VAR 0 6
5245: PUSH
5246: LD_VAR 0 4
5250: PPUSH
5251: LD_VAR 0 5
5255: PPUSH
5256: CALL_OW 74
5260: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5261: LD_VAR 0 5
5265: PPUSH
5266: LD_VAR 0 6
5270: PPUSH
5271: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5275: LD_VAR 0 5
5279: PPUSH
5280: LD_INT 209
5282: PPUSH
5283: LD_INT 132
5285: PPUSH
5286: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5290: LD_ADDR_VAR 0 4
5294: PUSH
5295: LD_VAR 0 4
5299: PUSH
5300: LD_VAR 0 6
5304: DIFF
5305: ST_TO_ADDR
// continue ;
5306: GO 5140
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5308: LD_VAR 0 5
5312: PPUSH
5313: LD_INT 201
5315: PPUSH
5316: LD_INT 132
5318: PPUSH
5319: CALL_OW 171
// end ;
5323: GO 5140
5325: POP
5326: POP
// for i in tmp_ape do
5327: LD_ADDR_VAR 0 5
5331: PUSH
5332: LD_VAR 0 3
5336: PUSH
5337: FOR_IN
5338: IFFALSE 5377
// begin if IsInUnit ( i ) then
5340: LD_VAR 0 5
5344: PPUSH
5345: CALL_OW 310
5349: IFFALSE 5360
// ComExitBuilding ( i ) ;
5351: LD_VAR 0 5
5355: PPUSH
5356: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5360: LD_VAR 0 5
5364: PPUSH
5365: LD_INT 201
5367: PPUSH
5368: LD_INT 132
5370: PPUSH
5371: CALL_OW 171
// end ;
5375: GO 5337
5377: POP
5378: POP
// repeat wait ( 0 0$1 ) ;
5379: LD_INT 35
5381: PPUSH
5382: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5386: LD_ADDR_VAR 0 5
5390: PUSH
5391: LD_VAR 0 2
5395: PUSH
5396: LD_VAR 0 3
5400: UNION
5401: PUSH
5402: LD_VAR 0 1
5406: UNION
5407: PUSH
5408: FOR_IN
5409: IFFALSE 5440
// if not HasTask ( i ) then
5411: LD_VAR 0 5
5415: PPUSH
5416: CALL_OW 314
5420: NOT
5421: IFFALSE 5438
// ComMoveXY ( i , 201 , 132 ) ;
5423: LD_VAR 0 5
5427: PPUSH
5428: LD_INT 201
5430: PPUSH
5431: LD_INT 132
5433: PPUSH
5434: CALL_OW 111
5438: GO 5408
5440: POP
5441: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5442: LD_INT 21
5444: PPUSH
5445: LD_INT 22
5447: PUSH
5448: LD_INT 2
5450: PUSH
5451: EMPTY
5452: LIST
5453: LIST
5454: PPUSH
5455: CALL_OW 70
5459: IFFALSE 5500
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5461: LD_ADDR_VAR 0 5
5465: PUSH
5466: LD_INT 21
5468: PPUSH
5469: LD_INT 22
5471: PUSH
5472: LD_INT 2
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PPUSH
5479: CALL_OW 70
5483: PUSH
5484: FOR_IN
5485: IFFALSE 5498
// RemoveUnit ( i ) ;
5487: LD_VAR 0 5
5491: PPUSH
5492: CALL_OW 64
5496: GO 5484
5498: POP
5499: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5500: LD_INT 22
5502: PUSH
5503: LD_INT 2
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: PUSH
5510: LD_INT 2
5512: PUSH
5513: LD_INT 21
5515: PUSH
5516: LD_INT 1
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PUSH
5523: LD_INT 21
5525: PUSH
5526: LD_INT 2
5528: PUSH
5529: EMPTY
5530: LIST
5531: LIST
5532: PUSH
5533: EMPTY
5534: LIST
5535: LIST
5536: LIST
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PPUSH
5542: CALL_OW 69
5546: NOT
5547: IFFALSE 5379
// end ;
5549: PPOPN 6
5551: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5552: LD_EXP 9
5556: PUSH
5557: LD_INT 92
5559: PPUSH
5560: LD_INT 40
5562: PPUSH
5563: CALL_OW 428
5567: PPUSH
5568: CALL_OW 266
5572: PUSH
5573: LD_INT 30
5575: EQUAL
5576: AND
5577: IFFALSE 5773
5579: GO 5581
5581: DISABLE
5582: LD_INT 0
5584: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5585: LD_ADDR_VAR 0 1
5589: PUSH
5590: LD_EXP 59
5594: PUSH
5595: LD_INT 1
5597: ARRAY
5598: PPUSH
5599: LD_INT 25
5601: PUSH
5602: LD_INT 4
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PPUSH
5609: CALL_OW 72
5613: ST_TO_ADDR
// if not sci then
5614: LD_VAR 0 1
5618: NOT
5619: IFFALSE 5623
// exit ;
5621: GO 5773
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5623: LD_ADDR_EXP 59
5627: PUSH
5628: LD_EXP 59
5632: PPUSH
5633: LD_INT 1
5635: PPUSH
5636: LD_EXP 59
5640: PUSH
5641: LD_INT 1
5643: ARRAY
5644: PUSH
5645: LD_VAR 0 1
5649: PUSH
5650: LD_INT 1
5652: ARRAY
5653: DIFF
5654: PPUSH
5655: CALL_OW 1
5659: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5660: LD_VAR 0 1
5664: PUSH
5665: LD_INT 1
5667: ARRAY
5668: PPUSH
5669: CALL_OW 310
5673: IFFALSE 5688
// ComExitBuilding ( sci [ 1 ] ) ;
5675: LD_VAR 0 1
5679: PUSH
5680: LD_INT 1
5682: ARRAY
5683: PPUSH
5684: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5688: LD_INT 2
5690: PPUSH
5691: LD_INT 105
5693: PPUSH
5694: LD_INT 14
5696: PPUSH
5697: LD_INT 20
5699: PPUSH
5700: CALL 20622 0 4
5704: PUSH
5705: LD_INT 4
5707: ARRAY
5708: PUSH
5709: LD_INT 10
5711: LESS
5712: IFFALSE 5735
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5714: LD_VAR 0 1
5718: PUSH
5719: LD_INT 1
5721: ARRAY
5722: PPUSH
5723: LD_INT 105
5725: PPUSH
5726: LD_INT 14
5728: PPUSH
5729: CALL_OW 171
5733: GO 5754
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5735: LD_VAR 0 1
5739: PUSH
5740: LD_INT 1
5742: ARRAY
5743: PPUSH
5744: LD_INT 118
5746: PPUSH
5747: LD_INT 77
5749: PPUSH
5750: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5754: LD_VAR 0 1
5758: PUSH
5759: LD_INT 1
5761: ARRAY
5762: PPUSH
5763: LD_INT 92
5765: PPUSH
5766: LD_INT 40
5768: PPUSH
5769: CALL_OW 218
// end ;
5773: PPOPN 1
5775: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5776: LD_INT 1
5778: PPUSH
5779: CALL_OW 302
5783: PUSH
5784: LD_EXP 9
5788: AND
5789: IFFALSE 6268
5791: GO 5793
5793: DISABLE
5794: LD_INT 0
5796: PPUSH
5797: PPUSH
5798: PPUSH
5799: PPUSH
5800: PPUSH
5801: PPUSH
// begin enable ;
5802: ENABLE
// base := 1 ;
5803: LD_ADDR_VAR 0 2
5807: PUSH
5808: LD_INT 1
5810: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5811: LD_ADDR_VAR 0 4
5815: PUSH
5816: LD_INT 0
5818: PUSH
5819: LD_INT 0
5821: PUSH
5822: LD_INT 0
5824: PUSH
5825: LD_INT 0
5827: PUSH
5828: LD_INT 0
5830: PUSH
5831: LD_INT 0
5833: PUSH
5834: LD_INT 0
5836: PUSH
5837: LD_INT 0
5839: PUSH
5840: LD_INT 1
5842: PUSH
5843: LD_INT 0
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: LIST
5855: LIST
5856: LIST
5857: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5858: LD_ADDR_VAR 0 3
5862: PUSH
5863: LD_INT 14
5865: PUSH
5866: LD_INT 1
5868: PUSH
5869: LD_INT 2
5871: PUSH
5872: LD_INT 26
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: LIST
5879: LIST
5880: PUSH
5881: LD_INT 14
5883: PUSH
5884: LD_INT 1
5886: PUSH
5887: LD_INT 2
5889: PUSH
5890: LD_INT 28
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: LD_INT 13
5901: PUSH
5902: LD_INT 1
5904: PUSH
5905: LD_INT 2
5907: PUSH
5908: LD_INT 29
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: LIST
5915: LIST
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5922: LD_ADDR_VAR 0 1
5926: PUSH
5927: DOUBLE
5928: LD_INT 1
5930: DEC
5931: ST_TO_ADDR
5932: LD_OWVAR 67
5936: PUSH
5937: LD_OWVAR 1
5941: PUSH
5942: LD_INT 21000
5944: DIV
5945: PLUS
5946: PUSH
5947: FOR_TO
5948: IFFALSE 6040
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5950: LD_ADDR_VAR 0 3
5954: PUSH
5955: LD_VAR 0 3
5959: PPUSH
5960: LD_VAR 0 3
5964: PUSH
5965: LD_INT 1
5967: PLUS
5968: PPUSH
5969: LD_INT 13
5971: PUSH
5972: LD_INT 14
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: PUSH
5979: LD_INT 1
5981: PPUSH
5982: LD_INT 2
5984: PPUSH
5985: CALL_OW 12
5989: ARRAY
5990: PUSH
5991: LD_INT 1
5993: PUSH
5994: LD_INT 2
5996: PUSH
5997: LD_INT 28
5999: PUSH
6000: LD_INT 29
6002: PUSH
6003: LD_INT 25
6005: PUSH
6006: LD_INT 26
6008: PUSH
6009: EMPTY
6010: LIST
6011: LIST
6012: LIST
6013: LIST
6014: PUSH
6015: LD_INT 1
6017: PPUSH
6018: LD_INT 4
6020: PPUSH
6021: CALL_OW 12
6025: ARRAY
6026: PUSH
6027: EMPTY
6028: LIST
6029: LIST
6030: LIST
6031: LIST
6032: PPUSH
6033: CALL_OW 2
6037: ST_TO_ADDR
6038: GO 5947
6040: POP
6041: POP
// MC_InsertProduceList ( base , tmp ) ;
6042: LD_VAR 0 2
6046: PPUSH
6047: LD_VAR 0 3
6051: PPUSH
6052: CALL 77687 0 2
// repeat wait ( 0 0$1 ) ;
6056: LD_INT 35
6058: PPUSH
6059: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
6063: LD_EXP 78
6067: PUSH
6068: LD_VAR 0 2
6072: ARRAY
6073: PUSH
6074: LD_INT 6
6076: GREATER
6077: IFFALSE 6056
// wait ( 0 0$20 ) ;
6079: LD_INT 700
6081: PPUSH
6082: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6086: LD_ADDR_VAR 0 5
6090: PUSH
6091: LD_INT 124
6093: PUSH
6094: LD_INT 85
6096: PUSH
6097: EMPTY
6098: LIST
6099: LIST
6100: PUSH
6101: LD_INT 90
6103: PUSH
6104: LD_INT 61
6106: PUSH
6107: EMPTY
6108: LIST
6109: LIST
6110: PUSH
6111: LD_INT 69
6113: PUSH
6114: LD_INT 48
6116: PUSH
6117: EMPTY
6118: LIST
6119: LIST
6120: PUSH
6121: LD_INT 68
6123: PUSH
6124: LD_INT 48
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: LIST
6135: LIST
6136: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6137: LD_ADDR_VAR 0 6
6141: PUSH
6142: LD_EXP 78
6146: PUSH
6147: LD_VAR 0 2
6151: ARRAY
6152: PUSH
6153: LD_EXP 78
6157: PUSH
6158: LD_VAR 0 2
6162: ARRAY
6163: PPUSH
6164: LD_INT 2
6166: PUSH
6167: LD_INT 34
6169: PUSH
6170: LD_INT 32
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: PUSH
6177: LD_INT 34
6179: PUSH
6180: LD_EXP 109
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: PUSH
6189: EMPTY
6190: LIST
6191: LIST
6192: LIST
6193: PPUSH
6194: CALL_OW 72
6198: DIFF
6199: ST_TO_ADDR
// if not attackers then
6200: LD_VAR 0 6
6204: NOT
6205: IFFALSE 6209
// exit ;
6207: GO 6268
// ar_attackers := attackers ;
6209: LD_ADDR_EXP 10
6213: PUSH
6214: LD_VAR 0 6
6218: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6219: LD_INT 35
6221: PPUSH
6222: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6226: LD_VAR 0 6
6230: PPUSH
6231: LD_INT 60
6233: PUSH
6234: EMPTY
6235: LIST
6236: PPUSH
6237: CALL_OW 72
6241: NOT
6242: IFFALSE 6219
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6244: LD_VAR 0 2
6248: PPUSH
6249: LD_VAR 0 6
6253: PPUSH
6254: LD_VAR 0 5
6258: PPUSH
6259: LD_VAR 0 4
6263: PPUSH
6264: CALL 77872 0 4
// end ;
6268: PPOPN 6
6270: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6271: LD_INT 1
6273: PPUSH
6274: CALL_OW 302
6278: PUSH
6279: LD_EXP 9
6283: AND
6284: PUSH
6285: LD_EXP 49
6289: PPUSH
6290: LD_INT 22
6292: PPUSH
6293: CALL_OW 308
6297: AND
6298: PUSH
6299: LD_INT 1
6301: PPUSH
6302: CALL 78035 0 1
6306: PUSH
6307: LD_INT 0
6309: EQUAL
6310: AND
6311: PUSH
6312: LD_EXP 10
6316: NOT
6317: AND
6318: IFFALSE 6802
6320: GO 6322
6322: DISABLE
6323: LD_INT 0
6325: PPUSH
6326: PPUSH
6327: PPUSH
6328: PPUSH
6329: PPUSH
6330: PPUSH
6331: PPUSH
// begin base := 1 ;
6332: LD_ADDR_VAR 0 2
6336: PUSH
6337: LD_INT 1
6339: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6340: LD_ADDR_VAR 0 4
6344: PUSH
6345: LD_INT 0
6347: PUSH
6348: LD_INT 0
6350: PUSH
6351: LD_INT 0
6353: PUSH
6354: LD_INT 0
6356: PUSH
6357: LD_INT 0
6359: PUSH
6360: LD_INT 0
6362: PUSH
6363: LD_INT 0
6365: PUSH
6366: LD_INT 0
6368: PUSH
6369: LD_INT 1
6371: PUSH
6372: LD_INT 0
6374: PUSH
6375: EMPTY
6376: LIST
6377: LIST
6378: LIST
6379: LIST
6380: LIST
6381: LIST
6382: LIST
6383: LIST
6384: LIST
6385: LIST
6386: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6387: LD_ADDR_VAR 0 3
6391: PUSH
6392: LD_INT 13
6394: PUSH
6395: LD_INT 1
6397: PUSH
6398: LD_INT 2
6400: PUSH
6401: LD_INT 28
6403: PUSH
6404: EMPTY
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: PUSH
6410: LD_INT 13
6412: PUSH
6413: LD_INT 1
6415: PUSH
6416: LD_INT 2
6418: PUSH
6419: LD_INT 27
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: PUSH
6428: LD_INT 13
6430: PUSH
6431: LD_INT 1
6433: PUSH
6434: LD_INT 2
6436: PUSH
6437: LD_INT 25
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 11
6448: PUSH
6449: LD_INT 2
6451: PUSH
6452: LD_INT 2
6454: PUSH
6455: LD_INT 24
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 11
6466: PUSH
6467: LD_INT 2
6469: PUSH
6470: LD_INT 2
6472: PUSH
6473: LD_INT 24
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: LIST
6480: LIST
6481: PUSH
6482: EMPTY
6483: LIST
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6489: LD_VAR 0 2
6493: PPUSH
6494: LD_VAR 0 3
6498: PPUSH
6499: CALL 77687 0 2
// repeat wait ( 0 0$1 ) ;
6503: LD_INT 35
6505: PPUSH
6506: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6510: LD_EXP 78
6514: PUSH
6515: LD_VAR 0 2
6519: ARRAY
6520: PUSH
6521: LD_INT 6
6523: GREATEREQUAL
6524: IFFALSE 6503
// wait ( 0 0$20 ) ;
6526: LD_INT 700
6528: PPUSH
6529: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6533: LD_ADDR_VAR 0 5
6537: PUSH
6538: LD_INT 119
6540: PUSH
6541: LD_INT 9
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: PUSH
6548: EMPTY
6549: LIST
6550: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6551: LD_ADDR_VAR 0 6
6555: PUSH
6556: LD_EXP 78
6560: PUSH
6561: LD_VAR 0 2
6565: ARRAY
6566: PUSH
6567: LD_EXP 78
6571: PUSH
6572: LD_VAR 0 2
6576: ARRAY
6577: PPUSH
6578: LD_INT 2
6580: PUSH
6581: LD_INT 34
6583: PUSH
6584: LD_INT 32
6586: PUSH
6587: EMPTY
6588: LIST
6589: LIST
6590: PUSH
6591: LD_INT 34
6593: PUSH
6594: LD_EXP 109
6598: PUSH
6599: EMPTY
6600: LIST
6601: LIST
6602: PUSH
6603: EMPTY
6604: LIST
6605: LIST
6606: LIST
6607: PPUSH
6608: CALL_OW 72
6612: DIFF
6613: ST_TO_ADDR
// if not attackers then
6614: LD_VAR 0 6
6618: NOT
6619: IFFALSE 6623
// exit ;
6621: GO 6802
// uc_side := 2 ;
6623: LD_ADDR_OWVAR 20
6627: PUSH
6628: LD_INT 2
6630: ST_TO_ADDR
// uc_nation := 2 ;
6631: LD_ADDR_OWVAR 21
6635: PUSH
6636: LD_INT 2
6638: ST_TO_ADDR
// InitHc ;
6639: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6643: LD_ADDR_VAR 0 1
6647: PUSH
6648: DOUBLE
6649: LD_INT 1
6651: DEC
6652: ST_TO_ADDR
6653: LD_INT 4
6655: PUSH
6656: LD_INT 5
6658: PUSH
6659: LD_INT 6
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: LIST
6666: PUSH
6667: LD_OWVAR 67
6671: ARRAY
6672: PUSH
6673: FOR_TO
6674: IFFALSE 6751
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6676: LD_INT 0
6678: PPUSH
6679: LD_INT 15
6681: PUSH
6682: LD_INT 17
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: PUSH
6689: LD_INT 1
6691: PPUSH
6692: LD_INT 2
6694: PPUSH
6695: CALL_OW 12
6699: ARRAY
6700: PPUSH
6701: LD_INT 8
6703: PPUSH
6704: CALL_OW 380
// un := CreateHuman ;
6708: LD_ADDR_VAR 0 7
6712: PUSH
6713: CALL_OW 44
6717: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6718: LD_VAR 0 7
6722: PPUSH
6723: LD_INT 23
6725: PPUSH
6726: LD_INT 0
6728: PPUSH
6729: CALL_OW 49
// attackers := attackers union un ;
6733: LD_ADDR_VAR 0 6
6737: PUSH
6738: LD_VAR 0 6
6742: PUSH
6743: LD_VAR 0 7
6747: UNION
6748: ST_TO_ADDR
// end ;
6749: GO 6673
6751: POP
6752: POP
// repeat wait ( 0 0$1 ) ;
6753: LD_INT 35
6755: PPUSH
6756: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6760: LD_VAR 0 6
6764: PPUSH
6765: LD_INT 60
6767: PUSH
6768: EMPTY
6769: LIST
6770: PPUSH
6771: CALL_OW 72
6775: NOT
6776: IFFALSE 6753
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6778: LD_VAR 0 2
6782: PPUSH
6783: LD_VAR 0 6
6787: PPUSH
6788: LD_VAR 0 5
6792: PPUSH
6793: LD_VAR 0 4
6797: PPUSH
6798: CALL 77872 0 4
// end ; end_of_file
6802: PPOPN 7
6804: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
6805: LD_INT 0
6807: PPUSH
6808: PPUSH
6809: PPUSH
6810: PPUSH
6811: PPUSH
6812: PPUSH
// uc_side := 1 ;
6813: LD_ADDR_OWVAR 20
6817: PUSH
6818: LD_INT 1
6820: ST_TO_ADDR
// uc_nation := 1 ;
6821: LD_ADDR_OWVAR 21
6825: PUSH
6826: LD_INT 1
6828: ST_TO_ADDR
// InitHc ;
6829: CALL_OW 19
// InitVc ;
6833: CALL_OW 20
// tmp := [ ] ;
6837: LD_ADDR_VAR 0 3
6841: PUSH
6842: EMPTY
6843: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 ] [ Difficulty ] do
6844: LD_ADDR_VAR 0 2
6848: PUSH
6849: DOUBLE
6850: LD_INT 1
6852: DEC
6853: ST_TO_ADDR
6854: LD_INT 6
6856: PUSH
6857: LD_INT 8
6859: PUSH
6860: LD_INT 10
6862: PUSH
6863: EMPTY
6864: LIST
6865: LIST
6866: LIST
6867: PUSH
6868: LD_OWVAR 67
6872: ARRAY
6873: PUSH
6874: FOR_TO
6875: IFFALSE 7149
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
6877: LD_ADDR_VAR 0 5
6881: PUSH
6882: LD_INT 2
6884: PUSH
6885: LD_INT 4
6887: PUSH
6888: LD_INT 5
6890: PUSH
6891: EMPTY
6892: LIST
6893: LIST
6894: LIST
6895: PUSH
6896: LD_INT 1
6898: PPUSH
6899: LD_INT 3
6901: PPUSH
6902: CALL_OW 12
6906: ARRAY
6907: ST_TO_ADDR
// case chassis of us_medium_wheeled :
6908: LD_VAR 0 5
6912: PUSH
6913: LD_INT 2
6915: DOUBLE
6916: EQUAL
6917: IFTRUE 6921
6919: GO 6955
6921: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
6922: LD_ADDR_VAR 0 6
6926: PUSH
6927: LD_INT 9
6929: PUSH
6930: LD_INT 5
6932: PUSH
6933: LD_INT 7
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: LIST
6940: PUSH
6941: LD_INT 1
6943: PPUSH
6944: LD_INT 3
6946: PPUSH
6947: CALL_OW 12
6951: ARRAY
6952: ST_TO_ADDR
6953: GO 7044
6955: LD_INT 4
6957: DOUBLE
6958: EQUAL
6959: IFTRUE 6963
6961: GO 7001
6963: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
6964: LD_ADDR_VAR 0 6
6968: PUSH
6969: LD_INT 9
6971: PUSH
6972: LD_INT 6
6974: PUSH
6975: LD_INT 6
6977: PUSH
6978: LD_INT 7
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: LIST
6985: LIST
6986: PUSH
6987: LD_INT 1
6989: PPUSH
6990: LD_INT 4
6992: PPUSH
6993: CALL_OW 12
6997: ARRAY
6998: ST_TO_ADDR
6999: GO 7044
7001: LD_INT 5
7003: DOUBLE
7004: EQUAL
7005: IFTRUE 7009
7007: GO 7043
7009: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7010: LD_ADDR_VAR 0 6
7014: PUSH
7015: LD_INT 9
7017: PUSH
7018: LD_INT 6
7020: PUSH
7021: LD_INT 7
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: LIST
7028: PUSH
7029: LD_INT 1
7031: PPUSH
7032: LD_INT 3
7034: PPUSH
7035: CALL_OW 12
7039: ARRAY
7040: ST_TO_ADDR
7041: GO 7044
7043: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7044: LD_VAR 0 5
7048: PPUSH
7049: LD_INT 1
7051: PUSH
7052: LD_INT 3
7054: PUSH
7055: EMPTY
7056: LIST
7057: LIST
7058: PUSH
7059: LD_INT 1
7061: PPUSH
7062: LD_INT 2
7064: PPUSH
7065: CALL_OW 12
7069: ARRAY
7070: PPUSH
7071: LD_INT 3
7073: PPUSH
7074: LD_VAR 0 6
7078: PPUSH
7079: LD_INT 70
7081: PPUSH
7082: LD_INT 90
7084: PPUSH
7085: CALL_OW 12
7089: PPUSH
7090: CALL 19604 0 5
// veh := CreateVehicle ;
7094: LD_ADDR_VAR 0 4
7098: PUSH
7099: CALL_OW 45
7103: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7104: LD_VAR 0 4
7108: PPUSH
7109: LD_INT 2
7111: PPUSH
7112: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7116: LD_VAR 0 4
7120: PPUSH
7121: LD_INT 17
7123: PPUSH
7124: LD_INT 0
7126: PPUSH
7127: CALL_OW 49
// tmp := tmp ^ veh ;
7131: LD_ADDR_VAR 0 3
7135: PUSH
7136: LD_VAR 0 3
7140: PUSH
7141: LD_VAR 0 4
7145: ADD
7146: ST_TO_ADDR
// end ;
7147: GO 6874
7149: POP
7150: POP
// if not tmp then
7151: LD_VAR 0 3
7155: NOT
7156: IFFALSE 7160
// exit ;
7158: GO 7269
// if not first_powell_attack then
7160: LD_EXP 11
7164: NOT
7165: IFFALSE 7175
// first_powell_attack := true ;
7167: LD_ADDR_EXP 11
7171: PUSH
7172: LD_INT 1
7174: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7175: LD_INT 70
7177: PPUSH
7178: CALL_OW 67
// for i in tmp do
7182: LD_ADDR_VAR 0 2
7186: PUSH
7187: LD_VAR 0 3
7191: PUSH
7192: FOR_IN
7193: IFFALSE 7260
// if IsOk ( i ) then
7195: LD_VAR 0 2
7199: PPUSH
7200: CALL_OW 302
7204: IFFALSE 7242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7206: LD_VAR 0 2
7210: PPUSH
7211: LD_INT 81
7213: PUSH
7214: LD_INT 1
7216: PUSH
7217: EMPTY
7218: LIST
7219: LIST
7220: PPUSH
7221: CALL_OW 69
7225: PPUSH
7226: LD_VAR 0 2
7230: PPUSH
7231: CALL_OW 74
7235: PPUSH
7236: CALL_OW 115
7240: GO 7258
// tmp := tmp diff i ;
7242: LD_ADDR_VAR 0 3
7246: PUSH
7247: LD_VAR 0 3
7251: PUSH
7252: LD_VAR 0 2
7256: DIFF
7257: ST_TO_ADDR
7258: GO 7192
7260: POP
7261: POP
// until not tmp ;
7262: LD_VAR 0 3
7266: NOT
7267: IFFALSE 7175
// end ; end_of_file
7269: LD_VAR 0 1
7273: RET
// export function Action ; var tmp , i , un ; begin
7274: LD_INT 0
7276: PPUSH
7277: PPUSH
7278: PPUSH
7279: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7280: LD_INT 68
7282: PPUSH
7283: LD_INT 39
7285: PPUSH
7286: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7290: LD_ADDR_VAR 0 2
7294: PUSH
7295: LD_INT 22
7297: PUSH
7298: LD_INT 7
7300: PUSH
7301: EMPTY
7302: LIST
7303: LIST
7304: PPUSH
7305: CALL_OW 69
7309: ST_TO_ADDR
// InGameOn ;
7310: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7314: LD_VAR 0 2
7318: PPUSH
7319: LD_INT 71
7321: PPUSH
7322: LD_INT 49
7324: PPUSH
7325: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7329: LD_INT 35
7331: PPUSH
7332: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7336: LD_INT 7
7338: PPUSH
7339: LD_INT 71
7341: PPUSH
7342: LD_INT 51
7344: PPUSH
7345: CALL_OW 293
7349: IFFALSE 7329
// DialogueOn ;
7351: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7355: LD_EXP 15
7359: PPUSH
7360: LD_STRING D1-JMM-1
7362: PPUSH
7363: CALL_OW 88
// if Joan then
7367: LD_EXP 30
7371: IFFALSE 7385
// Say ( Joan , D1-Joan-1 ) ;
7373: LD_EXP 30
7377: PPUSH
7378: LD_STRING D1-Joan-1
7380: PPUSH
7381: CALL_OW 88
// if Lisa then
7385: LD_EXP 17
7389: IFFALSE 7403
// Say ( Lisa , D1-Lisa-1 ) ;
7391: LD_EXP 17
7395: PPUSH
7396: LD_STRING D1-Lisa-1
7398: PPUSH
7399: CALL_OW 88
// if Joan or Lisa then
7403: LD_EXP 30
7407: PUSH
7408: LD_EXP 17
7412: OR
7413: IFFALSE 7427
// Say ( JMM , D1-JMM-2 ) ;
7415: LD_EXP 15
7419: PPUSH
7420: LD_STRING D1-JMM-2
7422: PPUSH
7423: CALL_OW 88
// DialogueOff ;
7427: CALL_OW 7
// InGameOff ;
7431: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7435: LD_INT 71
7437: PPUSH
7438: LD_INT 50
7440: PPUSH
7441: LD_INT 7
7443: PPUSH
7444: LD_INT 30
7446: NEG
7447: PPUSH
7448: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7452: LD_INT 71
7454: PPUSH
7455: LD_INT 50
7457: PPUSH
7458: LD_INT 7
7460: PPUSH
7461: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7465: LD_STRING M1
7467: PPUSH
7468: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7472: LD_INT 35
7474: PPUSH
7475: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7479: LD_EXP 3
7483: PUSH
7484: LD_OWVAR 1
7488: PUSH
7489: LD_INT 2100
7491: GREATER
7492: OR
7493: IFFALSE 7472
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7495: LD_INT 350
7497: PPUSH
7498: LD_INT 700
7500: PPUSH
7501: CALL_OW 12
7505: PPUSH
7506: CALL_OW 67
// PrepareGossudarov ;
7510: CALL 1865 0 0
// repeat wait ( 0 0$1 ) ;
7514: LD_INT 35
7516: PPUSH
7517: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7521: LD_INT 22
7523: PUSH
7524: LD_INT 6
7526: PUSH
7527: EMPTY
7528: LIST
7529: LIST
7530: PUSH
7531: LD_INT 3
7533: PUSH
7534: LD_INT 24
7536: PUSH
7537: LD_INT 1000
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: PPUSH
7552: CALL_OW 69
7556: PUSH
7557: LD_INT 7
7559: PPUSH
7560: LD_EXP 32
7564: PPUSH
7565: CALL_OW 292
7569: OR
7570: IFFALSE 7514
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7572: LD_ADDR_VAR 0 2
7576: PUSH
7577: LD_INT 22
7579: PUSH
7580: LD_INT 6
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: PPUSH
7587: CALL_OW 69
7591: ST_TO_ADDR
// for i in tmp do
7592: LD_ADDR_VAR 0 3
7596: PUSH
7597: LD_VAR 0 2
7601: PUSH
7602: FOR_IN
7603: IFFALSE 7619
// SetSide ( i , 7 ) ;
7605: LD_VAR 0 3
7609: PPUSH
7610: LD_INT 7
7612: PPUSH
7613: CALL_OW 235
7617: GO 7602
7619: POP
7620: POP
// DialogueOn ;
7621: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7625: LD_EXP 15
7629: PUSH
7630: LD_EXP 16
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: PPUSH
7639: LD_EXP 32
7643: PPUSH
7644: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7648: LD_EXP 32
7652: PPUSH
7653: CALL_OW 87
// if not Roth then
7657: LD_EXP 16
7661: NOT
7662: IFFALSE 7754
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7664: LD_VAR 0 2
7668: PPUSH
7669: LD_INT 3
7671: PUSH
7672: LD_INT 24
7674: PUSH
7675: LD_INT 1000
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: PPUSH
7686: CALL_OW 72
7690: IFFALSE 7704
// Say ( JMM , D2-JMM-1 ) ;
7692: LD_EXP 15
7696: PPUSH
7697: LD_STRING D2-JMM-1
7699: PPUSH
7700: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7704: LD_EXP 15
7708: PPUSH
7709: LD_STRING D2-JMM-1b
7711: PPUSH
7712: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7716: LD_EXP 32
7720: PPUSH
7721: LD_STRING D2-Gos-1
7723: PPUSH
7724: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7728: LD_EXP 15
7732: PPUSH
7733: LD_STRING D2-JMM-2
7735: PPUSH
7736: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7740: LD_EXP 32
7744: PPUSH
7745: LD_STRING D2-Gos-2
7747: PPUSH
7748: CALL_OW 88
// end else
7752: GO 7906
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7754: LD_VAR 0 2
7758: PPUSH
7759: LD_INT 3
7761: PUSH
7762: LD_INT 24
7764: PUSH
7765: LD_INT 1000
7767: PUSH
7768: EMPTY
7769: LIST
7770: LIST
7771: PUSH
7772: EMPTY
7773: LIST
7774: LIST
7775: PPUSH
7776: CALL_OW 72
7780: IFFALSE 7806
// begin Say ( Roth , D2-Roth-2 ) ;
7782: LD_EXP 16
7786: PPUSH
7787: LD_STRING D2-Roth-2
7789: PPUSH
7790: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7794: LD_EXP 15
7798: PPUSH
7799: LD_STRING D2-JMM-1a
7801: PPUSH
7802: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7806: LD_EXP 16
7810: PPUSH
7811: LD_STRING D2-Roth-2a
7813: PPUSH
7814: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7818: LD_EXP 16
7822: PPUSH
7823: LD_STRING D2-Roth-2b
7825: PPUSH
7826: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7830: LD_EXP 15
7834: PPUSH
7835: LD_STRING D2-JMM-3
7837: PPUSH
7838: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7842: LD_VAR 0 2
7846: PPUSH
7847: LD_INT 3
7849: PUSH
7850: LD_INT 24
7852: PUSH
7853: LD_INT 1000
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PUSH
7860: EMPTY
7861: LIST
7862: LIST
7863: PPUSH
7864: CALL_OW 72
7868: IFFALSE 7906
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7870: LD_EXP 32
7874: PPUSH
7875: LD_STRING D2-Gos-3
7877: PPUSH
7878: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7882: LD_EXP 15
7886: PPUSH
7887: LD_STRING D2-JMM-4
7889: PPUSH
7890: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7894: LD_EXP 32
7898: PPUSH
7899: LD_STRING D2-Gos-4
7901: PPUSH
7902: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7906: LD_EXP 15
7910: PPUSH
7911: LD_STRING D2-JMM-5
7913: PPUSH
7914: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7918: LD_EXP 32
7922: PPUSH
7923: LD_STRING D2-Gos-5
7925: PPUSH
7926: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7930: LD_EXP 15
7934: PPUSH
7935: LD_STRING D2-JMM-6
7937: PPUSH
7938: CALL_OW 88
// DialogueOff ;
7942: CALL_OW 7
// wait ( 0 0$2 ) ;
7946: LD_INT 70
7948: PPUSH
7949: CALL_OW 67
// if Kirilenkova then
7953: LD_EXP 33
7957: IFFALSE 7971
// Say ( Kirilenkova , D3-Kir-1 ) ;
7959: LD_EXP 33
7963: PPUSH
7964: LD_STRING D3-Kir-1
7966: PPUSH
7967: CALL_OW 88
// gossudarov_arrive := true ;
7971: LD_ADDR_EXP 4
7975: PUSH
7976: LD_INT 1
7978: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7979: LD_INT 35
7981: PPUSH
7982: CALL_OW 67
// until ru_lab_builded ;
7986: LD_EXP 5
7990: IFFALSE 7979
// DialogueOn ;
7992: CALL_OW 6
// if Kirilenkova then
7996: LD_EXP 33
8000: IFFALSE 8016
// Say ( Kirilenkova , D3a-Kir-1 ) else
8002: LD_EXP 33
8006: PPUSH
8007: LD_STRING D3a-Kir-1
8009: PPUSH
8010: CALL_OW 88
8014: GO 8038
// begin un := SciRu ;
8016: LD_ADDR_VAR 0 4
8020: PUSH
8021: CALL 13167 0 0
8025: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8026: LD_VAR 0 4
8030: PPUSH
8031: LD_STRING D3a-Sci1-1
8033: PPUSH
8034: CALL_OW 88
// end ; if Kirilenkova or un then
8038: LD_EXP 33
8042: PUSH
8043: LD_VAR 0 4
8047: OR
8048: IFFALSE 8062
// Say ( JMM , D3a-JMM-1 ) ;
8050: LD_EXP 15
8054: PPUSH
8055: LD_STRING D3a-JMM-1
8057: PPUSH
8058: CALL_OW 88
// DialogueOff ;
8062: CALL_OW 7
// end ;
8066: LD_VAR 0 1
8070: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8071: LD_EXP 4
8075: PUSH
8076: LD_INT 22
8078: PUSH
8079: LD_INT 7
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: PUSH
8086: LD_INT 2
8088: PUSH
8089: LD_INT 25
8091: PUSH
8092: LD_INT 1
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: PUSH
8099: LD_INT 25
8101: PUSH
8102: LD_INT 2
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: PUSH
8109: LD_INT 25
8111: PUSH
8112: LD_INT 3
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PUSH
8119: LD_INT 25
8121: PUSH
8122: LD_INT 4
8124: PUSH
8125: EMPTY
8126: LIST
8127: LIST
8128: PUSH
8129: LD_INT 25
8131: PUSH
8132: LD_INT 5
8134: PUSH
8135: EMPTY
8136: LIST
8137: LIST
8138: PUSH
8139: LD_INT 25
8141: PUSH
8142: LD_INT 8
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: PUSH
8149: LD_INT 25
8151: PUSH
8152: LD_INT 9
8154: PUSH
8155: EMPTY
8156: LIST
8157: LIST
8158: PUSH
8159: EMPTY
8160: LIST
8161: LIST
8162: LIST
8163: LIST
8164: LIST
8165: LIST
8166: LIST
8167: LIST
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: PPUSH
8173: CALL_OW 69
8177: PUSH
8178: LD_INT 7
8180: LESS
8181: AND
8182: IFFALSE 8194
8184: GO 8186
8186: DISABLE
// YouLost ( TooMany ) ;
8187: LD_STRING TooMany
8189: PPUSH
8190: CALL_OW 104
8194: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8195: LD_EXP 32
8199: PPUSH
8200: CALL_OW 255
8204: PUSH
8205: LD_INT 7
8207: EQUAL
8208: IFFALSE 8425
8210: GO 8212
8212: DISABLE
8213: LD_INT 0
8215: PPUSH
8216: PPUSH
8217: PPUSH
// begin uc_side := 3 ;
8218: LD_ADDR_OWVAR 20
8222: PUSH
8223: LD_INT 3
8225: ST_TO_ADDR
// uc_nation := 3 ;
8226: LD_ADDR_OWVAR 21
8230: PUSH
8231: LD_INT 3
8233: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8234: LD_INT 21
8236: PPUSH
8237: LD_INT 3
8239: PPUSH
8240: LD_INT 3
8242: PPUSH
8243: LD_INT 42
8245: PPUSH
8246: LD_INT 100
8248: PPUSH
8249: CALL 19604 0 5
// un := CreateVehicle ;
8253: LD_ADDR_VAR 0 3
8257: PUSH
8258: CALL_OW 45
8262: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8263: LD_VAR 0 3
8267: PPUSH
8268: LD_INT 15
8270: PPUSH
8271: LD_INT 0
8273: PPUSH
8274: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8278: LD_VAR 0 3
8282: PPUSH
8283: LD_INT 67
8285: PPUSH
8286: LD_INT 45
8288: PPUSH
8289: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8293: LD_VAR 0 3
8297: PPUSH
8298: LD_INT 70
8300: PPUSH
8301: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8305: LD_VAR 0 3
8309: PPUSH
8310: LD_INT 69
8312: PPUSH
8313: LD_INT 18
8315: PPUSH
8316: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8320: LD_VAR 0 3
8324: PPUSH
8325: LD_INT 60
8327: PPUSH
8328: LD_INT 3
8330: PPUSH
8331: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8335: LD_INT 35
8337: PPUSH
8338: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8342: LD_VAR 0 3
8346: PPUSH
8347: CALL_OW 302
8351: NOT
8352: PUSH
8353: LD_VAR 0 3
8357: PPUSH
8358: LD_INT 17
8360: PPUSH
8361: CALL_OW 308
8365: OR
8366: PUSH
8367: LD_VAR 0 3
8371: PPUSH
8372: LD_INT 60
8374: PPUSH
8375: LD_INT 3
8377: PPUSH
8378: CALL_OW 307
8382: OR
8383: IFFALSE 8335
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8385: LD_VAR 0 3
8389: PPUSH
8390: LD_INT 17
8392: PPUSH
8393: CALL_OW 308
8397: PUSH
8398: LD_VAR 0 3
8402: PPUSH
8403: LD_INT 60
8405: PPUSH
8406: LD_INT 3
8408: PPUSH
8409: CALL_OW 307
8413: OR
8414: IFFALSE 8425
// RemoveUnit ( un ) ;
8416: LD_VAR 0 3
8420: PPUSH
8421: CALL_OW 64
// end ;
8425: PPOPN 3
8427: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8428: LD_EXP 4
8432: IFFALSE 8674
8434: GO 8436
8436: DISABLE
8437: LD_INT 0
8439: PPUSH
8440: PPUSH
8441: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8442: LD_INT 70
8444: PPUSH
8445: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8449: LD_ADDR_VAR 0 3
8453: PUSH
8454: LD_INT 22
8456: PUSH
8457: LD_INT 7
8459: PUSH
8460: EMPTY
8461: LIST
8462: LIST
8463: PUSH
8464: LD_INT 101
8466: PUSH
8467: LD_INT 3
8469: PUSH
8470: EMPTY
8471: LIST
8472: LIST
8473: PUSH
8474: EMPTY
8475: LIST
8476: LIST
8477: PPUSH
8478: CALL_OW 69
8482: ST_TO_ADDR
// until tmp ;
8483: LD_VAR 0 3
8487: IFFALSE 8442
// un := NearestUnitToUnit ( tmp , JMM ) ;
8489: LD_ADDR_VAR 0 2
8493: PUSH
8494: LD_VAR 0 3
8498: PPUSH
8499: LD_EXP 15
8503: PPUSH
8504: CALL_OW 74
8508: ST_TO_ADDR
// player_spotted := true ;
8509: LD_ADDR_EXP 6
8513: PUSH
8514: LD_INT 1
8516: ST_TO_ADDR
// tmp := SciRu ;
8517: LD_ADDR_VAR 0 3
8521: PUSH
8522: CALL 13167 0 0
8526: ST_TO_ADDR
// if not tmp then
8527: LD_VAR 0 3
8531: NOT
8532: IFFALSE 8544
// tmp := SolRu ;
8534: LD_ADDR_VAR 0 3
8538: PUSH
8539: CALL 13314 0 0
8543: ST_TO_ADDR
// DialogueOn ;
8544: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8548: LD_VAR 0 2
8552: PPUSH
8553: CALL_OW 250
8557: PPUSH
8558: LD_VAR 0 2
8562: PPUSH
8563: CALL_OW 251
8567: PPUSH
8568: LD_INT 7
8570: PPUSH
8571: LD_INT 8
8573: NEG
8574: PPUSH
8575: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8579: LD_VAR 0 2
8583: PPUSH
8584: CALL_OW 87
// if tmp then
8588: LD_VAR 0 3
8592: IFFALSE 8606
// Say ( tmp , D4-RSci1-1 ) ;
8594: LD_VAR 0 3
8598: PPUSH
8599: LD_STRING D4-RSci1-1
8601: PPUSH
8602: CALL_OW 88
// if Gossudarov then
8606: LD_EXP 32
8610: IFFALSE 8636
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8612: LD_EXP 32
8616: PPUSH
8617: LD_STRING D4-Gos-1
8619: PPUSH
8620: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8624: LD_EXP 15
8628: PPUSH
8629: LD_STRING D4-JMM-1
8631: PPUSH
8632: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8636: LD_VAR 0 2
8640: PPUSH
8641: CALL_OW 250
8645: PPUSH
8646: LD_VAR 0 2
8650: PPUSH
8651: CALL_OW 251
8655: PPUSH
8656: LD_INT 7
8658: PPUSH
8659: CALL_OW 331
// DialogueOff ;
8663: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8667: LD_STRING M5
8669: PPUSH
8670: CALL_OW 337
// end ;
8674: PPOPN 3
8676: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8677: LD_EXP 6
8681: IFFALSE 9270
8683: GO 8685
8685: DISABLE
8686: LD_INT 0
8688: PPUSH
8689: PPUSH
8690: PPUSH
// begin PrepareBelkov ;
8691: CALL 2178 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8695: LD_EXP 47
8699: PPUSH
8700: LD_INT 118
8702: PPUSH
8703: LD_INT 106
8705: PPUSH
8706: CALL_OW 111
// AddComHold ( Belkov ) ;
8710: LD_EXP 47
8714: PPUSH
8715: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8719: LD_INT 35
8721: PPUSH
8722: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8726: LD_EXP 47
8730: PPUSH
8731: LD_INT 118
8733: PPUSH
8734: LD_INT 106
8736: PPUSH
8737: CALL_OW 307
8741: IFFALSE 8719
// ChangeSideFog ( 4 , 7 ) ;
8743: LD_INT 4
8745: PPUSH
8746: LD_INT 7
8748: PPUSH
8749: CALL_OW 343
// if IsOk ( Belkov ) then
8753: LD_EXP 47
8757: PPUSH
8758: CALL_OW 302
8762: IFFALSE 8846
// begin InGameOn ;
8764: CALL_OW 8
// DialogueOn ;
8768: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8772: LD_EXP 47
8776: PPUSH
8777: LD_STRING D5-Bel-1
8779: PPUSH
8780: CALL_OW 94
// if Gossudarov then
8784: LD_EXP 32
8788: IFFALSE 8838
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8790: LD_EXP 32
8794: PPUSH
8795: LD_STRING D5-Gos-1
8797: PPUSH
8798: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8802: LD_EXP 15
8806: PPUSH
8807: LD_STRING D5-JMM-1
8809: PPUSH
8810: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8814: LD_EXP 32
8818: PPUSH
8819: LD_STRING D5-Gos-2
8821: PPUSH
8822: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8826: LD_EXP 15
8830: PPUSH
8831: LD_STRING D5-JMM-2
8833: PPUSH
8834: CALL_OW 88
// end ; DialogueOff ;
8838: CALL_OW 7
// InGameOff ;
8842: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8846: LD_STRING QSaveBelkov
8848: PPUSH
8849: CALL_OW 97
8853: PUSH
8854: LD_INT 1
8856: DOUBLE
8857: EQUAL
8858: IFTRUE 8862
8860: GO 8912
8862: POP
// begin DialogueOn ;
8863: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8867: LD_EXP 15
8871: PPUSH
8872: LD_STRING D5a-JMM-1
8874: PPUSH
8875: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8879: LD_EXP 47
8883: PPUSH
8884: LD_STRING D5a-Bel-1
8886: PPUSH
8887: CALL_OW 94
// DialogueOff ;
8891: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8895: LD_EXP 47
8899: PPUSH
8900: LD_INT 83
8902: PPUSH
8903: LD_INT 49
8905: PPUSH
8906: CALL_OW 111
// end ; 2 :
8910: GO 8945
8912: LD_INT 2
8914: DOUBLE
8915: EQUAL
8916: IFTRUE 8920
8918: GO 8944
8920: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8921: LD_EXP 15
8925: PPUSH
8926: LD_STRING D5a-JMM-2
8928: PPUSH
8929: CALL_OW 88
// ComHold ( Belkov ) ;
8933: LD_EXP 47
8937: PPUSH
8938: CALL_OW 140
// end ; end ;
8942: GO 8945
8944: POP
// time := 0 0$00 ;
8945: LD_ADDR_VAR 0 1
8949: PUSH
8950: LD_INT 0
8952: ST_TO_ADDR
// vehSpawned := false ;
8953: LD_ADDR_VAR 0 3
8957: PUSH
8958: LD_INT 0
8960: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8961: LD_INT 35
8963: PPUSH
8964: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8968: LD_VAR 0 1
8972: PUSH
8973: LD_INT 350
8975: PUSH
8976: LD_INT 175
8978: PUSH
8979: LD_INT 70
8981: PUSH
8982: EMPTY
8983: LIST
8984: LIST
8985: LIST
8986: PUSH
8987: LD_OWVAR 67
8991: ARRAY
8992: GREATEREQUAL
8993: PUSH
8994: LD_VAR 0 3
8998: NOT
8999: AND
9000: IFFALSE 9090
// begin vehSpawned := true ;
9002: LD_ADDR_VAR 0 3
9006: PUSH
9007: LD_INT 1
9009: ST_TO_ADDR
// uc_side := 3 ;
9010: LD_ADDR_OWVAR 20
9014: PUSH
9015: LD_INT 3
9017: ST_TO_ADDR
// uc_nation := 3 ;
9018: LD_ADDR_OWVAR 21
9022: PUSH
9023: LD_INT 3
9025: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9026: LD_INT 22
9028: PPUSH
9029: LD_INT 3
9031: PPUSH
9032: LD_INT 3
9034: PPUSH
9035: LD_INT 43
9037: PPUSH
9038: LD_INT 100
9040: PPUSH
9041: CALL 19604 0 5
// veh := CreateVehicle ;
9045: LD_ADDR_VAR 0 2
9049: PUSH
9050: CALL_OW 45
9054: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9055: LD_VAR 0 2
9059: PPUSH
9060: LD_INT 130
9062: PPUSH
9063: LD_INT 131
9065: PPUSH
9066: LD_INT 0
9068: PPUSH
9069: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9073: LD_VAR 0 2
9077: PPUSH
9078: LD_INT 100
9080: PPUSH
9081: LD_INT 82
9083: PPUSH
9084: CALL_OW 114
// end else
9088: GO 9104
// time := time + 0 0$1 ;
9090: LD_ADDR_VAR 0 1
9094: PUSH
9095: LD_VAR 0 1
9099: PUSH
9100: LD_INT 35
9102: PLUS
9103: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9104: LD_EXP 47
9108: PPUSH
9109: CALL_OW 301
9113: PUSH
9114: LD_EXP 47
9118: PPUSH
9119: CALL_OW 255
9123: PUSH
9124: LD_INT 4
9126: EQUAL
9127: AND
9128: PUSH
9129: LD_INT 22
9131: PUSH
9132: LD_INT 7
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: PPUSH
9139: CALL_OW 69
9143: PPUSH
9144: LD_EXP 47
9148: PPUSH
9149: CALL_OW 74
9153: PPUSH
9154: LD_EXP 47
9158: PPUSH
9159: CALL_OW 296
9163: PUSH
9164: LD_INT 10
9166: LESS
9167: OR
9168: IFFALSE 8961
// if IsDead ( Belkov ) then
9170: LD_EXP 47
9174: PPUSH
9175: CALL_OW 301
9179: IFFALSE 9204
// begin CenterNowOnUnits ( Belkov ) ;
9181: LD_EXP 47
9185: PPUSH
9186: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9190: LD_EXP 15
9194: PPUSH
9195: LD_STRING D5a-JMM-2a
9197: PPUSH
9198: CALL_OW 88
// exit ;
9202: GO 9270
// end ; if See ( 7 , Belkov ) then
9204: LD_INT 7
9206: PPUSH
9207: LD_EXP 47
9211: PPUSH
9212: CALL_OW 292
9216: IFFALSE 9230
// SetSide ( Belkov , 7 ) ;
9218: LD_EXP 47
9222: PPUSH
9223: LD_INT 7
9225: PPUSH
9226: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9230: LD_INT 35
9232: PPUSH
9233: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9237: LD_EXP 47
9241: PPUSH
9242: LD_INT 66
9244: PPUSH
9245: LD_INT 45
9247: PPUSH
9248: CALL_OW 297
9252: PUSH
9253: LD_INT 30
9255: LESS
9256: IFFALSE 9230
// Say ( Belkov , D6-Bel-1 ) ;
9258: LD_EXP 47
9262: PPUSH
9263: LD_STRING D6-Bel-1
9265: PPUSH
9266: CALL_OW 88
// end ;
9270: PPOPN 3
9272: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9273: LD_EXP 47
9277: PPUSH
9278: CALL_OW 302
9282: PUSH
9283: LD_EXP 47
9287: PPUSH
9288: CALL_OW 504
9292: PUSH
9293: LD_INT 2
9295: PUSH
9296: LD_INT 34
9298: PUSH
9299: LD_INT 47
9301: PUSH
9302: EMPTY
9303: LIST
9304: LIST
9305: PUSH
9306: LD_INT 34
9308: PUSH
9309: LD_INT 45
9311: PUSH
9312: EMPTY
9313: LIST
9314: LIST
9315: PUSH
9316: EMPTY
9317: LIST
9318: LIST
9319: LIST
9320: PPUSH
9321: CALL_OW 69
9325: IN
9326: AND
9327: IFFALSE 9344
9329: GO 9331
9331: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9332: LD_EXP 47
9336: PPUSH
9337: LD_STRING D7-Bel-1
9339: PPUSH
9340: CALL_OW 88
9344: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9345: LD_INT 22
9347: PUSH
9348: LD_INT 7
9350: PUSH
9351: EMPTY
9352: LIST
9353: LIST
9354: PUSH
9355: LD_INT 101
9357: PUSH
9358: LD_INT 2
9360: PUSH
9361: EMPTY
9362: LIST
9363: LIST
9364: PUSH
9365: EMPTY
9366: LIST
9367: LIST
9368: PPUSH
9369: CALL_OW 69
9373: PUSH
9374: LD_EXP 8
9378: NOT
9379: AND
9380: PUSH
9381: LD_EXP 46
9385: PPUSH
9386: CALL_OW 305
9390: NOT
9391: AND
9392: IFFALSE 9862
9394: GO 9396
9396: DISABLE
9397: LD_INT 0
9399: PPUSH
// begin ar_base_spotted := true ;
9400: LD_ADDR_EXP 8
9404: PUSH
9405: LD_INT 1
9407: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9408: LD_ADDR_VAR 0 1
9412: PUSH
9413: LD_INT 22
9415: PUSH
9416: LD_INT 2
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: PUSH
9423: LD_INT 21
9425: PUSH
9426: LD_INT 3
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: PPUSH
9437: CALL_OW 69
9441: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9442: LD_ADDR_VAR 0 1
9446: PUSH
9447: LD_VAR 0 1
9451: PPUSH
9452: LD_EXP 15
9456: PPUSH
9457: CALL_OW 74
9461: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9462: LD_INT 7
9464: PPUSH
9465: LD_INT 3
9467: PPUSH
9468: CALL_OW 332
// DialogueOn ;
9472: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9476: LD_VAR 0 1
9480: PPUSH
9481: CALL_OW 250
9485: PPUSH
9486: LD_VAR 0 1
9490: PPUSH
9491: CALL_OW 251
9495: PPUSH
9496: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9500: LD_ADDR_VAR 0 1
9504: PUSH
9505: LD_INT 22
9507: PUSH
9508: LD_INT 7
9510: PUSH
9511: EMPTY
9512: LIST
9513: LIST
9514: PUSH
9515: LD_INT 23
9517: PUSH
9518: LD_INT 1
9520: PUSH
9521: EMPTY
9522: LIST
9523: LIST
9524: PUSH
9525: LD_INT 26
9527: PUSH
9528: LD_INT 1
9530: PUSH
9531: EMPTY
9532: LIST
9533: LIST
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: LIST
9539: PPUSH
9540: CALL_OW 69
9544: PUSH
9545: LD_EXP 15
9549: PUSH
9550: LD_EXP 19
9554: PUSH
9555: LD_EXP 20
9559: PUSH
9560: LD_EXP 27
9564: PUSH
9565: LD_EXP 16
9569: PUSH
9570: LD_EXP 25
9574: PUSH
9575: LD_EXP 21
9579: PUSH
9580: LD_EXP 23
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: LIST
9589: LIST
9590: LIST
9591: LIST
9592: LIST
9593: LIST
9594: DIFF
9595: ST_TO_ADDR
// if not tmp then
9596: LD_VAR 0 1
9600: NOT
9601: IFFALSE 9675
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9603: LD_ADDR_VAR 0 1
9607: PUSH
9608: LD_INT 22
9610: PUSH
9611: LD_INT 7
9613: PUSH
9614: EMPTY
9615: LIST
9616: LIST
9617: PUSH
9618: LD_INT 23
9620: PUSH
9621: LD_INT 1
9623: PUSH
9624: EMPTY
9625: LIST
9626: LIST
9627: PUSH
9628: LD_INT 26
9630: PUSH
9631: LD_INT 2
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: PUSH
9638: EMPTY
9639: LIST
9640: LIST
9641: LIST
9642: PPUSH
9643: CALL_OW 69
9647: PUSH
9648: LD_EXP 30
9652: PUSH
9653: LD_EXP 17
9657: PUSH
9658: LD_EXP 28
9662: PUSH
9663: LD_EXP 29
9667: PUSH
9668: EMPTY
9669: LIST
9670: LIST
9671: LIST
9672: LIST
9673: DIFF
9674: ST_TO_ADDR
// if tmp then
9675: LD_VAR 0 1
9679: IFFALSE 9750
// case GetSex ( tmp [ 1 ] ) of sex_male :
9681: LD_VAR 0 1
9685: PUSH
9686: LD_INT 1
9688: ARRAY
9689: PPUSH
9690: CALL_OW 258
9694: PUSH
9695: LD_INT 1
9697: DOUBLE
9698: EQUAL
9699: IFTRUE 9703
9701: GO 9722
9703: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9704: LD_VAR 0 1
9708: PUSH
9709: LD_INT 1
9711: ARRAY
9712: PPUSH
9713: LD_STRING D9-Sol1-1
9715: PPUSH
9716: CALL_OW 88
9720: GO 9750
9722: LD_INT 2
9724: DOUBLE
9725: EQUAL
9726: IFTRUE 9730
9728: GO 9749
9730: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9731: LD_VAR 0 1
9735: PUSH
9736: LD_INT 1
9738: ARRAY
9739: PPUSH
9740: LD_STRING D9-FSol1-1
9742: PPUSH
9743: CALL_OW 88
9747: GO 9750
9749: POP
// if Frank then
9750: LD_EXP 27
9754: IFFALSE 9858
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9756: LD_EXP 56
9760: PPUSH
9761: CALL_OW 250
9765: PPUSH
9766: LD_EXP 56
9770: PPUSH
9771: CALL_OW 251
9775: PPUSH
9776: LD_INT 7
9778: PPUSH
9779: LD_INT 8
9781: PPUSH
9782: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9786: LD_EXP 56
9790: PPUSH
9791: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9795: LD_EXP 27
9799: PPUSH
9800: LD_STRING D9-Frank-1
9802: PPUSH
9803: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9807: LD_EXP 15
9811: PPUSH
9812: LD_STRING D9-JMM-1
9814: PPUSH
9815: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9819: LD_EXP 27
9823: PPUSH
9824: LD_STRING D9-Frank-2
9826: PPUSH
9827: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9831: LD_EXP 56
9835: PPUSH
9836: CALL_OW 250
9840: PPUSH
9841: LD_EXP 56
9845: PPUSH
9846: CALL_OW 251
9850: PPUSH
9851: LD_INT 7
9853: PPUSH
9854: CALL_OW 331
// end ; DialogueOff ;
9858: CALL_OW 7
// end ;
9862: PPOPN 1
9864: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9865: LD_EXP 7
9869: PUSH
9870: LD_OWVAR 1
9874: PUSH
9875: LD_INT 42000
9877: GREATEREQUAL
9878: OR
9879: IFFALSE 10906
9881: GO 9883
9883: DISABLE
9884: LD_INT 0
9886: PPUSH
9887: PPUSH
// begin selected_option := 1 ;
9888: LD_ADDR_VAR 0 2
9892: PUSH
9893: LD_INT 1
9895: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9896: LD_INT 10500
9898: PPUSH
9899: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9903: LD_INT 35
9905: PPUSH
9906: CALL_OW 67
// until not ru_attackers ;
9910: LD_EXP 52
9914: NOT
9915: IFFALSE 9903
// PrepareBurlak ;
9917: CALL 2290 0 0
// repeat wait ( 0 0$2 ) ;
9921: LD_INT 70
9923: PPUSH
9924: CALL_OW 67
// until not HasTask ( Burlak ) ;
9928: LD_EXP 46
9932: PPUSH
9933: CALL_OW 314
9937: NOT
9938: IFFALSE 9921
// InGameOn ;
9940: CALL_OW 8
// DialogueOn ;
9944: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9948: LD_EXP 49
9952: PPUSH
9953: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9957: LD_EXP 46
9961: PPUSH
9962: LD_STRING D10-Bur-1
9964: PPUSH
9965: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9969: LD_EXP 47
9973: PUSH
9974: LD_EXP 47
9978: PPUSH
9979: CALL_OW 255
9983: PUSH
9984: LD_INT 7
9986: EQUAL
9987: AND
9988: IFFALSE 10002
// Say ( Belkov , D10-Bel-1 ) ;
9990: LD_EXP 47
9994: PPUSH
9995: LD_STRING D10-Bel-1
9997: PPUSH
9998: CALL_OW 88
// if Gossudarov then
10002: LD_EXP 32
10006: IFFALSE 10020
// Say ( Gossudarov , D10-Gos-1 ) ;
10008: LD_EXP 32
10012: PPUSH
10013: LD_STRING D10-Gos-1
10015: PPUSH
10016: CALL_OW 88
// if Kirilenkova then
10020: LD_EXP 33
10024: IFFALSE 10038
// Say ( Kirilenkova , D10-Kir-1 ) ;
10026: LD_EXP 33
10030: PPUSH
10031: LD_STRING D10-Kir-1
10033: PPUSH
10034: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10038: CALL 13314 0 0
10042: PPUSH
10043: LD_STRING D10-RSol1-1
10045: PPUSH
10046: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10050: LD_EXP 46
10054: PPUSH
10055: LD_STRING D10-Bur-2
10057: PPUSH
10058: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10062: LD_EXP 15
10066: PPUSH
10067: LD_STRING D10-JMM-2
10069: PPUSH
10070: CALL_OW 88
// if Kirilenkova then
10074: LD_EXP 33
10078: IFFALSE 10094
// Say ( Kirilenkova , D10-Kir-2 ) else
10080: LD_EXP 33
10084: PPUSH
10085: LD_STRING D10-Kir-2
10087: PPUSH
10088: CALL_OW 88
10092: GO 10106
// Say ( SolRu , D10-RSol1-2 ) ;
10094: CALL 13314 0 0
10098: PPUSH
10099: LD_STRING D10-RSol1-2
10101: PPUSH
10102: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10106: LD_EXP 15
10110: PPUSH
10111: LD_STRING D10-JMM-3
10113: PPUSH
10114: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10118: LD_EXP 46
10122: PPUSH
10123: LD_STRING D10-Bur-3
10125: PPUSH
10126: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10130: LD_EXP 15
10134: PPUSH
10135: LD_STRING D10-JMM-4
10137: PPUSH
10138: CALL_OW 88
// DialogueOff ;
10142: CALL_OW 7
// InGameOff ;
10146: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10150: LD_STRING M2
10152: PPUSH
10153: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10157: LD_INT 35
10159: PPUSH
10160: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10164: LD_INT 22
10166: PUSH
10167: LD_INT 7
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PUSH
10174: LD_INT 91
10176: PUSH
10177: LD_EXP 46
10181: PUSH
10182: LD_INT 8
10184: PUSH
10185: EMPTY
10186: LIST
10187: LIST
10188: LIST
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: PPUSH
10194: CALL_OW 69
10198: IFFALSE 10157
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10200: LD_ADDR_VAR 0 1
10204: PUSH
10205: LD_INT 22
10207: PUSH
10208: LD_INT 4
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: PPUSH
10215: CALL_OW 69
10219: PUSH
10220: FOR_IN
10221: IFFALSE 10237
// SetSide ( i , 7 ) ;
10223: LD_VAR 0 1
10227: PPUSH
10228: LD_INT 7
10230: PPUSH
10231: CALL_OW 235
10235: GO 10220
10237: POP
10238: POP
// ChangeMissionObjectives ( M3 ) ;
10239: LD_STRING M3
10241: PPUSH
10242: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10253: LD_EXP 15
10257: PPUSH
10258: LD_EXP 46
10262: PPUSH
10263: CALL_OW 296
10267: PUSH
10268: LD_INT 8
10270: LESS
10271: IFFALSE 10246
// ComTurnUnit ( JMM , Burlak ) ;
10273: LD_EXP 15
10277: PPUSH
10278: LD_EXP 46
10282: PPUSH
10283: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10287: LD_EXP 46
10291: PPUSH
10292: LD_EXP 15
10296: PPUSH
10297: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10301: LD_INT 10
10303: PPUSH
10304: CALL_OW 67
// DialogueOn ;
10308: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10312: LD_EXP 15
10316: PPUSH
10317: LD_STRING D11-JMM-1
10319: PPUSH
10320: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10324: LD_EXP 46
10328: PPUSH
10329: LD_STRING D11-Bur-1
10331: PPUSH
10332: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10336: LD_EXP 15
10340: PPUSH
10341: LD_STRING D11-JMM-2
10343: PPUSH
10344: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10348: LD_EXP 46
10352: PPUSH
10353: LD_STRING D11-Bur-2
10355: PPUSH
10356: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10360: LD_EXP 15
10364: PPUSH
10365: LD_STRING D11-JMM-3
10367: PPUSH
10368: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10372: LD_EXP 46
10376: PPUSH
10377: LD_STRING D11-Bur-3
10379: PPUSH
10380: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10384: LD_EXP 15
10388: PPUSH
10389: LD_STRING D11-JMM-4
10391: PPUSH
10392: CALL_OW 88
// if ar_base_spotted then
10396: LD_EXP 8
10400: IFFALSE 10416
// Say ( Burlak , D12-Bur-1 ) else
10402: LD_EXP 46
10406: PPUSH
10407: LD_STRING D12-Bur-1
10409: PPUSH
10410: CALL_OW 88
10414: GO 10455
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10416: LD_INT 7
10418: PPUSH
10419: LD_INT 3
10421: PPUSH
10422: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10426: LD_INT 127
10428: PPUSH
10429: LD_INT 45
10431: PPUSH
10432: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10436: LD_EXP 46
10440: PPUSH
10441: LD_STRING D12-Bur-1a
10443: PPUSH
10444: CALL_OW 88
// dwait ( 0 0$2 ) ;
10448: LD_INT 70
10450: PPUSH
10451: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10455: LD_EXP 46
10459: PPUSH
10460: LD_STRING D12-Bur-1b
10462: PPUSH
10463: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10467: LD_EXP 15
10471: PPUSH
10472: LD_STRING D12-JMM-1
10474: PPUSH
10475: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10479: LD_EXP 46
10483: PPUSH
10484: LD_STRING D12-Bur-2
10486: PPUSH
10487: CALL_OW 88
// if Roth then
10491: LD_EXP 16
10495: IFFALSE 10511
// Say ( Roth , D12-Roth-2 ) else
10497: LD_EXP 16
10501: PPUSH
10502: LD_STRING D12-Roth-2
10504: PPUSH
10505: CALL_OW 88
10509: GO 10523
// Say ( SciRu , D12-RSci1-2 ) ;
10511: CALL 13167 0 0
10515: PPUSH
10516: LD_STRING D12-RSci1-2
10518: PPUSH
10519: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10523: LD_EXP 15
10527: PPUSH
10528: LD_STRING D12-JMM-2
10530: PPUSH
10531: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10535: LD_EXP 46
10539: PPUSH
10540: LD_STRING D12-Bur-3
10542: PPUSH
10543: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10547: LD_EXP 15
10551: PPUSH
10552: LD_STRING D12-JMM-3
10554: PPUSH
10555: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10559: LD_EXP 46
10563: PPUSH
10564: LD_STRING D12-Bur-4
10566: PPUSH
10567: CALL_OW 88
// case Query ( QBase ) of 1 :
10571: LD_STRING QBase
10573: PPUSH
10574: CALL_OW 97
10578: PUSH
10579: LD_INT 1
10581: DOUBLE
10582: EQUAL
10583: IFTRUE 10587
10585: GO 10705
10587: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10588: LD_EXP 15
10592: PPUSH
10593: LD_STRING D13a-JMM-1
10595: PPUSH
10596: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10600: LD_EXP 46
10604: PPUSH
10605: LD_STRING D13a-Bur-1
10607: PPUSH
10608: CALL_OW 88
// if Roth then
10612: LD_EXP 16
10616: IFFALSE 10632
// Say ( Roth , D13a-Roth-1 ) else
10618: LD_EXP 16
10622: PPUSH
10623: LD_STRING D13a-Roth-1
10625: PPUSH
10626: CALL_OW 88
10630: GO 10644
// Say ( SciRu , D13a-RSci1-1 ) ;
10632: CALL 13167 0 0
10636: PPUSH
10637: LD_STRING D13a-RSci1-1
10639: PPUSH
10640: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10644: LD_EXP 15
10648: PPUSH
10649: LD_STRING D13a-JMM-2
10651: PPUSH
10652: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10656: LD_STRING QBaseAgain
10658: PPUSH
10659: CALL_OW 97
10663: PUSH
10664: LD_INT 1
10666: DOUBLE
10667: EQUAL
10668: IFTRUE 10672
10670: GO 10683
10672: POP
// selected_option := 2 ; 2 :
10673: LD_ADDR_VAR 0 2
10677: PUSH
10678: LD_INT 2
10680: ST_TO_ADDR
10681: GO 10703
10683: LD_INT 2
10685: DOUBLE
10686: EQUAL
10687: IFTRUE 10691
10689: GO 10702
10691: POP
// selected_option := 3 ; end ;
10692: LD_ADDR_VAR 0 2
10696: PUSH
10697: LD_INT 3
10699: ST_TO_ADDR
10700: GO 10703
10702: POP
// end ; 2 :
10703: GO 10744
10705: LD_INT 2
10707: DOUBLE
10708: EQUAL
10709: IFTRUE 10713
10711: GO 10724
10713: POP
// selected_option := 2 ; 3 :
10714: LD_ADDR_VAR 0 2
10718: PUSH
10719: LD_INT 2
10721: ST_TO_ADDR
10722: GO 10744
10724: LD_INT 3
10726: DOUBLE
10727: EQUAL
10728: IFTRUE 10732
10730: GO 10743
10732: POP
// selected_option := 3 ; end ;
10733: LD_ADDR_VAR 0 2
10737: PUSH
10738: LD_INT 3
10740: ST_TO_ADDR
10741: GO 10744
10743: POP
// if selected_option = 2 then
10744: LD_VAR 0 2
10748: PUSH
10749: LD_INT 2
10751: EQUAL
10752: IFFALSE 10846
// begin Say ( JMM , D13b-JMM-1 ) ;
10754: LD_EXP 15
10758: PPUSH
10759: LD_STRING D13b-JMM-1
10761: PPUSH
10762: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10766: LD_EXP 46
10770: PPUSH
10771: LD_STRING D13b-Bur-1
10773: PPUSH
10774: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10778: LD_EXP 15
10782: PPUSH
10783: LD_STRING D13b-JMM-2
10785: PPUSH
10786: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10790: LD_EXP 55
10794: PPUSH
10795: LD_STRING D13b-Abd-2
10797: PPUSH
10798: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10802: LD_EXP 15
10806: PPUSH
10807: LD_STRING D13b-JMM-3
10809: PPUSH
10810: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10814: LD_EXP 55
10818: PPUSH
10819: LD_STRING D13b-Abd-3
10821: PPUSH
10822: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10826: LD_EXP 15
10830: PPUSH
10831: LD_STRING D13b-JMM-4
10833: PPUSH
10834: CALL_OW 88
// ar_active_attack := true ;
10838: LD_ADDR_EXP 9
10842: PUSH
10843: LD_INT 1
10845: ST_TO_ADDR
// end ; if selected_option = 3 then
10846: LD_VAR 0 2
10850: PUSH
10851: LD_INT 3
10853: EQUAL
10854: IFFALSE 10880
// begin Say ( JMM , D13c-JMM-1 ) ;
10856: LD_EXP 15
10860: PPUSH
10861: LD_STRING D13c-JMM-1
10863: PPUSH
10864: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10868: LD_EXP 46
10872: PPUSH
10873: LD_STRING D13c-Bur-1
10875: PPUSH
10876: CALL_OW 88
// end ; DialogueOff ;
10880: CALL_OW 7
// if not ar_active_attack then
10884: LD_EXP 9
10888: NOT
10889: IFFALSE 10906
// begin wait ( 6 6$00 ) ;
10891: LD_INT 12600
10893: PPUSH
10894: CALL_OW 67
// ar_active_attack := true ;
10898: LD_ADDR_EXP 9
10902: PUSH
10903: LD_INT 1
10905: ST_TO_ADDR
// end ; end ;
10906: PPOPN 2
10908: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10909: LD_EXP 46
10913: PPUSH
10914: CALL_OW 305
10918: PUSH
10919: LD_EXP 46
10923: PPUSH
10924: CALL_OW 255
10928: PUSH
10929: LD_INT 7
10931: EQUAL
10932: AND
10933: IFFALSE 11129
10935: GO 10937
10937: DISABLE
10938: LD_INT 0
10940: PPUSH
// begin wait ( 4 4$40 ) ;
10941: LD_INT 9800
10943: PPUSH
10944: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10948: LD_INT 35
10950: PPUSH
10951: CALL_OW 67
// until not ru_attackers ;
10955: LD_EXP 52
10959: NOT
10960: IFFALSE 10948
// PrepareGnyevko ;
10962: CALL 2234 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10966: LD_EXP 48
10970: PPUSH
10971: LD_INT 124
10973: PPUSH
10974: LD_INT 118
10976: PPUSH
10977: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10981: LD_EXP 48
10985: PPUSH
10986: CALL_OW 200
// time := 0 0$00 ;
10990: LD_ADDR_VAR 0 1
10994: PUSH
10995: LD_INT 0
10997: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10998: LD_INT 35
11000: PPUSH
11001: CALL_OW 67
// time := time + 0 0$1 ;
11005: LD_ADDR_VAR 0 1
11009: PUSH
11010: LD_VAR 0 1
11014: PUSH
11015: LD_INT 35
11017: PLUS
11018: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11019: LD_EXP 48
11023: PPUSH
11024: LD_INT 124
11026: PPUSH
11027: LD_INT 118
11029: PPUSH
11030: CALL_OW 307
11034: PUSH
11035: LD_VAR 0 1
11039: PUSH
11040: LD_INT 1050
11042: GREATEREQUAL
11043: OR
11044: IFFALSE 10998
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11046: LD_EXP 48
11050: PPUSH
11051: LD_STRING DBelkov-Gny-1
11053: PPUSH
11054: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11058: LD_EXP 46
11062: PPUSH
11063: LD_STRING DBelkov-Bur-1a
11065: PPUSH
11066: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11070: LD_INT 35
11072: PPUSH
11073: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11077: LD_EXP 48
11081: PPUSH
11082: LD_INT 22
11084: PUSH
11085: LD_INT 7
11087: PUSH
11088: EMPTY
11089: LIST
11090: LIST
11091: PPUSH
11092: CALL_OW 69
11096: PPUSH
11097: LD_EXP 48
11101: PPUSH
11102: CALL_OW 74
11106: PPUSH
11107: CALL_OW 296
11111: PUSH
11112: LD_INT 8
11114: LESS
11115: IFFALSE 11070
// SetSide ( Gnyevko , 7 ) ;
11117: LD_EXP 48
11121: PPUSH
11122: LD_INT 7
11124: PPUSH
11125: CALL_OW 235
// end ;
11129: PPOPN 1
11131: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11132: LD_EXP 46
11136: PPUSH
11137: CALL_OW 255
11141: PUSH
11142: LD_INT 7
11144: EQUAL
11145: IFFALSE 11155
11147: GO 11149
11149: DISABLE
// begin enable ;
11150: ENABLE
// PrepareAmericanAttack ;
11151: CALL 6805 0 0
// end ;
11155: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11156: LD_INT 22
11158: PUSH
11159: LD_INT 1
11161: PUSH
11162: EMPTY
11163: LIST
11164: LIST
11165: PPUSH
11166: CALL_OW 69
11170: IFFALSE 11354
11172: GO 11174
11174: DISABLE
11175: LD_INT 0
11177: PPUSH
11178: PPUSH
// begin while true do
11179: LD_INT 1
11181: IFFALSE 11238
// begin wait ( 0 0$1 ) ;
11183: LD_INT 35
11185: PPUSH
11186: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11190: LD_ADDR_VAR 0 2
11194: PUSH
11195: LD_INT 22
11197: PUSH
11198: LD_INT 1
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PPUSH
11205: CALL_OW 69
11209: PPUSH
11210: LD_EXP 15
11214: PPUSH
11215: CALL_OW 74
11219: ST_TO_ADDR
// if See ( 7 , tmp ) then
11220: LD_INT 7
11222: PPUSH
11223: LD_VAR 0 2
11227: PPUSH
11228: CALL_OW 292
11232: IFFALSE 11236
// break ;
11234: GO 11238
// end ;
11236: GO 11179
// DialogueOn ;
11238: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11242: LD_VAR 0 2
11246: PPUSH
11247: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11251: LD_VAR 0 2
11255: PPUSH
11256: CALL_OW 250
11260: PPUSH
11261: LD_VAR 0 2
11265: PPUSH
11266: CALL_OW 251
11270: PPUSH
11271: LD_INT 7
11273: PPUSH
11274: LD_INT 8
11276: PPUSH
11277: CALL_OW 330
// if Denis then
11281: LD_EXP 21
11285: IFFALSE 11299
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11287: LD_EXP 21
11291: PPUSH
11292: LD_STRING DAmerAttack-Pet-1
11294: PPUSH
11295: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11299: LD_EXP 15
11303: PPUSH
11304: LD_STRING DAmerAttack-JMM-1
11306: PPUSH
11307: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11311: LD_EXP 46
11315: PPUSH
11316: LD_STRING DStop-Bur-1
11318: PPUSH
11319: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11323: LD_VAR 0 2
11327: PPUSH
11328: CALL_OW 250
11332: PPUSH
11333: LD_VAR 0 2
11337: PPUSH
11338: CALL_OW 251
11342: PPUSH
11343: LD_INT 7
11345: PPUSH
11346: CALL_OW 331
// DialogueOff ;
11350: CALL_OW 7
// end ;
11354: PPOPN 2
11356: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11357: LD_INT 22
11359: PUSH
11360: LD_INT 3
11362: PUSH
11363: EMPTY
11364: LIST
11365: LIST
11366: PUSH
11367: LD_INT 21
11369: PUSH
11370: LD_INT 1
11372: PUSH
11373: EMPTY
11374: LIST
11375: LIST
11376: PUSH
11377: EMPTY
11378: LIST
11379: LIST
11380: PPUSH
11381: CALL_OW 69
11385: PUSH
11386: LD_INT 0
11388: EQUAL
11389: IFFALSE 11431
11391: GO 11393
11393: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11394: LD_STRING M5a
11396: PPUSH
11397: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11401: LD_EXP 15
11405: PPUSH
11406: LD_STRING D8-JMM-1
11408: PPUSH
11409: CALL_OW 88
// if Gossudarov then
11413: LD_EXP 32
11417: IFFALSE 11431
// Say ( Gossudarov , D8-Gos-1 ) ;
11419: LD_EXP 32
11423: PPUSH
11424: LD_STRING D8-Gos-1
11426: PPUSH
11427: CALL_OW 88
// end ;
11431: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11432: LD_INT 22
11434: PUSH
11435: LD_INT 2
11437: PUSH
11438: EMPTY
11439: LIST
11440: LIST
11441: PUSH
11442: LD_INT 21
11444: PUSH
11445: LD_INT 1
11447: PUSH
11448: EMPTY
11449: LIST
11450: LIST
11451: PUSH
11452: EMPTY
11453: LIST
11454: LIST
11455: PPUSH
11456: CALL_OW 69
11460: PUSH
11461: LD_INT 0
11463: EQUAL
11464: IFFALSE 11514
11466: GO 11468
11468: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11469: LD_STRING M4c
11471: PPUSH
11472: CALL_OW 337
// if Roth then
11476: LD_EXP 16
11480: IFFALSE 11496
// Say ( Roth , DStop-Roth-1 ) else
11482: LD_EXP 16
11486: PPUSH
11487: LD_STRING DStop-Roth-1
11489: PPUSH
11490: CALL_OW 88
11494: GO 11514
// if Gossudarov then
11496: LD_EXP 32
11500: IFFALSE 11514
// Say ( Gossudarov , D8-Gos-1a ) ;
11502: LD_EXP 32
11506: PPUSH
11507: LD_STRING D8-Gos-1a
11509: PPUSH
11510: CALL_OW 88
// end ;
11514: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11515: LD_INT 7
11517: PPUSH
11518: LD_INT 1
11520: PPUSH
11521: LD_INT 1
11523: PPUSH
11524: CALL 14803 0 3
11528: PUSH
11529: LD_INT 0
11531: EQUAL
11532: PUSH
11533: LD_INT 7
11535: PPUSH
11536: LD_INT 3
11538: PPUSH
11539: LD_INT 1
11541: PPUSH
11542: CALL 14803 0 3
11546: PUSH
11547: LD_INT 0
11549: EQUAL
11550: AND
11551: IFFALSE 11563
11553: GO 11555
11555: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11556: LD_STRING M1a
11558: PPUSH
11559: CALL_OW 337
// end ;
11563: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11564: LD_INT 22
11566: PUSH
11567: LD_INT 2
11569: PUSH
11570: EMPTY
11571: LIST
11572: LIST
11573: PUSH
11574: LD_INT 21
11576: PUSH
11577: LD_INT 1
11579: PUSH
11580: EMPTY
11581: LIST
11582: LIST
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: PPUSH
11588: CALL_OW 69
11592: PUSH
11593: LD_INT 0
11595: EQUAL
11596: PUSH
11597: LD_INT 22
11599: PUSH
11600: LD_INT 3
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PUSH
11607: LD_INT 21
11609: PUSH
11610: LD_INT 1
11612: PUSH
11613: EMPTY
11614: LIST
11615: LIST
11616: PUSH
11617: EMPTY
11618: LIST
11619: LIST
11620: PPUSH
11621: CALL_OW 69
11625: PUSH
11626: LD_INT 0
11628: EQUAL
11629: AND
11630: PUSH
11631: LD_INT 22
11633: PUSH
11634: LD_INT 1
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: PPUSH
11641: CALL_OW 69
11645: PUSH
11646: LD_INT 0
11648: EQUAL
11649: AND
11650: PUSH
11651: LD_INT 7
11653: PPUSH
11654: LD_INT 1
11656: PPUSH
11657: LD_INT 1
11659: PPUSH
11660: CALL 14803 0 3
11664: PUSH
11665: LD_INT 0
11667: EQUAL
11668: AND
11669: PUSH
11670: LD_INT 7
11672: PPUSH
11673: LD_INT 3
11675: PPUSH
11676: LD_INT 1
11678: PPUSH
11679: CALL 14803 0 3
11683: PUSH
11684: LD_INT 0
11686: EQUAL
11687: AND
11688: IFFALSE 13164
11690: GO 11692
11692: DISABLE
11693: LD_INT 0
11695: PPUSH
11696: PPUSH
11697: PPUSH
11698: PPUSH
11699: PPUSH
11700: PPUSH
// begin m1 := false ;
11701: LD_ADDR_VAR 0 4
11705: PUSH
11706: LD_INT 0
11708: ST_TO_ADDR
// m2 := false ;
11709: LD_ADDR_VAR 0 5
11713: PUSH
11714: LD_INT 0
11716: ST_TO_ADDR
// m3 := false ;
11717: LD_ADDR_VAR 0 6
11721: PUSH
11722: LD_INT 0
11724: ST_TO_ADDR
// if tick < 40 40$00 then
11725: LD_OWVAR 1
11729: PUSH
11730: LD_INT 84000
11732: LESS
11733: IFFALSE 11742
// SetAchievement ( ACH_ASPEED_17 ) ;
11735: LD_STRING ACH_ASPEED_17
11737: PPUSH
11738: CALL_OW 543
// wait ( 0 0$5 ) ;
11742: LD_INT 175
11744: PPUSH
11745: CALL_OW 67
// if not IsDead ( Masha ) then
11749: LD_EXP 49
11753: PPUSH
11754: CALL_OW 301
11758: NOT
11759: IFFALSE 11781
// begin m1 := true ;
11761: LD_ADDR_VAR 0 4
11765: PUSH
11766: LD_INT 1
11768: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11769: LD_STRING Masha
11771: PPUSH
11772: LD_INT 1
11774: PPUSH
11775: CALL_OW 101
// end else
11779: GO 11792
// AddMedal ( Masha , - 1 ) ;
11781: LD_STRING Masha
11783: PPUSH
11784: LD_INT 1
11786: NEG
11787: PPUSH
11788: CALL_OW 101
// if abdul_escaped then
11792: LD_EXP 12
11796: IFFALSE 11811
// AddMedal ( Abdul , - 1 ) else
11798: LD_STRING Abdul
11800: PPUSH
11801: LD_INT 1
11803: NEG
11804: PPUSH
11805: CALL_OW 101
11809: GO 11829
// begin m2 := true ;
11811: LD_ADDR_VAR 0 5
11815: PUSH
11816: LD_INT 1
11818: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11819: LD_STRING Abdul
11821: PPUSH
11822: LD_INT 1
11824: PPUSH
11825: CALL_OW 101
// end ; if loss_counter = 0 then
11829: LD_EXP 13
11833: PUSH
11834: LD_INT 0
11836: EQUAL
11837: IFFALSE 11859
// begin m3 := true ;
11839: LD_ADDR_VAR 0 6
11843: PUSH
11844: LD_INT 1
11846: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11847: LD_STRING People
11849: PPUSH
11850: LD_INT 2
11852: PPUSH
11853: CALL_OW 101
// end else
11857: GO 11917
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11859: LD_EXP 13
11863: PUSH
11864: LD_INT 3
11866: PUSH
11867: LD_INT 2
11869: PUSH
11870: LD_INT 2
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: LIST
11877: PUSH
11878: LD_OWVAR 67
11882: ARRAY
11883: LESSEQUAL
11884: IFFALSE 11906
// begin AddMedal ( People , 1 ) ;
11886: LD_STRING People
11888: PPUSH
11889: LD_INT 1
11891: PPUSH
11892: CALL_OW 101
// m3 := true ;
11896: LD_ADDR_VAR 0 6
11900: PUSH
11901: LD_INT 1
11903: ST_TO_ADDR
// end else
11904: GO 11917
// AddMedal ( People , - 1 ) ;
11906: LD_STRING People
11908: PPUSH
11909: LD_INT 1
11911: NEG
11912: PPUSH
11913: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11917: LD_OWVAR 67
11921: PUSH
11922: LD_INT 3
11924: EQUAL
11925: PUSH
11926: LD_VAR 0 4
11930: AND
11931: PUSH
11932: LD_VAR 0 5
11936: AND
11937: PUSH
11938: LD_VAR 0 6
11942: AND
11943: IFFALSE 11955
// SetAchievementEX ( ACH_AMER , 17 ) ;
11945: LD_STRING ACH_AMER
11947: PPUSH
11948: LD_INT 17
11950: PPUSH
11951: CALL_OW 564
// GiveMedals ( MAIN ) ;
11955: LD_STRING MAIN
11957: PPUSH
11958: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11962: LD_ADDR_VAR 0 2
11966: PUSH
11967: LD_INT 22
11969: PUSH
11970: LD_INT 7
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: PUSH
11977: LD_INT 2
11979: PUSH
11980: LD_INT 25
11982: PUSH
11983: LD_INT 1
11985: PUSH
11986: EMPTY
11987: LIST
11988: LIST
11989: PUSH
11990: LD_INT 25
11992: PUSH
11993: LD_INT 2
11995: PUSH
11996: EMPTY
11997: LIST
11998: LIST
11999: PUSH
12000: LD_INT 25
12002: PUSH
12003: LD_INT 3
12005: PUSH
12006: EMPTY
12007: LIST
12008: LIST
12009: PUSH
12010: LD_INT 25
12012: PUSH
12013: LD_INT 4
12015: PUSH
12016: EMPTY
12017: LIST
12018: LIST
12019: PUSH
12020: LD_INT 25
12022: PUSH
12023: LD_INT 5
12025: PUSH
12026: EMPTY
12027: LIST
12028: LIST
12029: PUSH
12030: LD_INT 25
12032: PUSH
12033: LD_INT 8
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: PUSH
12040: LD_INT 25
12042: PUSH
12043: LD_INT 9
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: PUSH
12050: EMPTY
12051: LIST
12052: LIST
12053: LIST
12054: LIST
12055: LIST
12056: LIST
12057: LIST
12058: LIST
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PPUSH
12064: CALL_OW 69
12068: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12069: LD_VAR 0 2
12073: PPUSH
12074: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
12078: LD_ADDR_VAR 0 3
12082: PUSH
12083: LD_EXP 15
12087: PUSH
12088: LD_EXP 16
12092: PUSH
12093: LD_EXP 17
12097: PUSH
12098: LD_EXP 18
12102: PUSH
12103: LD_EXP 19
12107: PUSH
12108: LD_EXP 20
12112: PUSH
12113: LD_EXP 21
12117: PUSH
12118: LD_EXP 22
12122: PUSH
12123: LD_EXP 23
12127: PUSH
12128: LD_EXP 24
12132: PUSH
12133: LD_EXP 25
12137: PUSH
12138: LD_EXP 26
12142: PUSH
12143: LD_EXP 27
12147: PUSH
12148: LD_EXP 28
12152: PUSH
12153: LD_EXP 29
12157: PUSH
12158: LD_EXP 30
12162: PUSH
12163: LD_EXP 31
12167: PUSH
12168: LD_EXP 32
12172: PUSH
12173: LD_EXP 33
12177: PUSH
12178: LD_EXP 34
12182: PUSH
12183: LD_EXP 36
12187: PUSH
12188: LD_EXP 37
12192: PUSH
12193: LD_EXP 38
12197: PUSH
12198: LD_EXP 39
12202: PUSH
12203: LD_EXP 40
12207: PUSH
12208: LD_EXP 41
12212: PUSH
12213: LD_EXP 42
12217: PUSH
12218: LD_EXP 43
12222: PUSH
12223: LD_EXP 44
12227: PUSH
12228: LD_EXP 45
12232: PUSH
12233: LD_EXP 46
12237: PUSH
12238: LD_EXP 47
12242: PUSH
12243: LD_EXP 48
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: LIST
12258: LIST
12259: LIST
12260: LIST
12261: LIST
12262: LIST
12263: LIST
12264: LIST
12265: LIST
12266: LIST
12267: LIST
12268: LIST
12269: LIST
12270: LIST
12271: LIST
12272: LIST
12273: LIST
12274: LIST
12275: LIST
12276: LIST
12277: LIST
12278: LIST
12279: LIST
12280: LIST
12281: LIST
12282: ST_TO_ADDR
// if tmp diff tmp2 then
12283: LD_VAR 0 2
12287: PUSH
12288: LD_VAR 0 3
12292: DIFF
12293: IFFALSE 12313
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12295: LD_VAR 0 2
12299: PUSH
12300: LD_VAR 0 3
12304: DIFF
12305: PPUSH
12306: LD_STRING 13a_others
12308: PPUSH
12309: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12313: LD_EXP 15
12317: PPUSH
12318: LD_STRING 13a_JMM
12320: PPUSH
12321: CALL_OW 38
// if Titov then
12325: LD_EXP 34
12329: IFFALSE 12343
// SaveCharacters ( Titov , 13a_Titov ) ;
12331: LD_EXP 34
12335: PPUSH
12336: LD_STRING 13a_Titov
12338: PPUSH
12339: CALL_OW 38
// if Dolgov then
12343: LD_EXP 36
12347: IFFALSE 12361
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12349: LD_EXP 36
12353: PPUSH
12354: LD_STRING 13a_Dolgov
12356: PPUSH
12357: CALL_OW 38
// if Petrosyan then
12361: LD_EXP 37
12365: IFFALSE 12379
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12367: LD_EXP 37
12371: PPUSH
12372: LD_STRING 13a_Petrosyan
12374: PPUSH
12375: CALL_OW 38
// if Scholtze then
12379: LD_EXP 38
12383: IFFALSE 12397
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12385: LD_EXP 38
12389: PPUSH
12390: LD_STRING 13a_Scholtze
12392: PPUSH
12393: CALL_OW 38
// if Oblukov then
12397: LD_EXP 39
12401: IFFALSE 12415
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12403: LD_EXP 39
12407: PPUSH
12408: LD_STRING 13a_Oblukov
12410: PPUSH
12411: CALL_OW 38
// if Kapitsova then
12415: LD_EXP 40
12419: IFFALSE 12433
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12421: LD_EXP 40
12425: PPUSH
12426: LD_STRING 13a_Kapitsova
12428: PPUSH
12429: CALL_OW 38
// if Lipshchin then
12433: LD_EXP 41
12437: IFFALSE 12451
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12439: LD_EXP 41
12443: PPUSH
12444: LD_STRING 13a_Lipshchin
12446: PPUSH
12447: CALL_OW 38
// if Petrovova then
12451: LD_EXP 42
12455: IFFALSE 12469
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12457: LD_EXP 42
12461: PPUSH
12462: LD_STRING 13a_Petrovova
12464: PPUSH
12465: CALL_OW 38
// if Kovalyuk then
12469: LD_EXP 43
12473: IFFALSE 12487
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12475: LD_EXP 43
12479: PPUSH
12480: LD_STRING 13a_Kovalyuk
12482: PPUSH
12483: CALL_OW 38
// if Kuzmov then
12487: LD_EXP 44
12491: IFFALSE 12505
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12493: LD_EXP 44
12497: PPUSH
12498: LD_STRING 13a_Kuzmov
12500: PPUSH
12501: CALL_OW 38
// if Karamazov then
12505: LD_EXP 45
12509: IFFALSE 12523
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12511: LD_EXP 45
12515: PPUSH
12516: LD_STRING 13a_Karamazov
12518: PPUSH
12519: CALL_OW 38
// if Burlak then
12523: LD_EXP 46
12527: IFFALSE 12541
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12529: LD_EXP 46
12533: PPUSH
12534: LD_STRING 13a_Burlak
12536: PPUSH
12537: CALL_OW 38
// if Belkov then
12541: LD_EXP 47
12545: IFFALSE 12559
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12547: LD_EXP 47
12551: PPUSH
12552: LD_STRING 13a_Belkov
12554: PPUSH
12555: CALL_OW 38
// if Gnyevko then
12559: LD_EXP 48
12563: IFFALSE 12577
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12565: LD_EXP 48
12569: PPUSH
12570: LD_STRING 13a_Gnyevko
12572: PPUSH
12573: CALL_OW 38
// if Lisa then
12577: LD_EXP 17
12581: IFFALSE 12595
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12583: LD_EXP 17
12587: PPUSH
12588: LD_STRING 13a_Lisa
12590: PPUSH
12591: CALL_OW 38
// if Donaldson then
12595: LD_EXP 18
12599: IFFALSE 12613
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12601: LD_EXP 18
12605: PPUSH
12606: LD_STRING 13a_Donaldson
12608: PPUSH
12609: CALL_OW 38
// if Bobby then
12613: LD_EXP 19
12617: IFFALSE 12631
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12619: LD_EXP 19
12623: PPUSH
12624: LD_STRING 13a_Bobby
12626: PPUSH
12627: CALL_OW 38
// if Cyrus then
12631: LD_EXP 20
12635: IFFALSE 12649
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12637: LD_EXP 20
12641: PPUSH
12642: LD_STRING 13a_Cyrus
12644: PPUSH
12645: CALL_OW 38
// if Denis then
12649: LD_EXP 21
12653: IFFALSE 12667
// SaveCharacters ( Denis , 13a_Denis ) ;
12655: LD_EXP 21
12659: PPUSH
12660: LD_STRING 13a_Denis
12662: PPUSH
12663: CALL_OW 38
// if Brown then
12667: LD_EXP 22
12671: IFFALSE 12685
// SaveCharacters ( Brown , 13a_Brown ) ;
12673: LD_EXP 22
12677: PPUSH
12678: LD_STRING 13a_Brown
12680: PPUSH
12681: CALL_OW 38
// if Gladstone then
12685: LD_EXP 23
12689: IFFALSE 12703
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12691: LD_EXP 23
12695: PPUSH
12696: LD_STRING 13a_Gladstone
12698: PPUSH
12699: CALL_OW 38
// if Houten then
12703: LD_EXP 24
12707: IFFALSE 12721
// SaveCharacters ( Houten , 13a_Houten ) ;
12709: LD_EXP 24
12713: PPUSH
12714: LD_STRING 13a_Houten
12716: PPUSH
12717: CALL_OW 38
// if Cornel then
12721: LD_EXP 25
12725: IFFALSE 12739
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12727: LD_EXP 25
12731: PPUSH
12732: LD_STRING 13a_Cornel
12734: PPUSH
12735: CALL_OW 38
// if Gary then
12739: LD_EXP 26
12743: IFFALSE 12757
// SaveCharacters ( Gary , 13a_Gary ) ;
12745: LD_EXP 26
12749: PPUSH
12750: LD_STRING 13a_Gary
12752: PPUSH
12753: CALL_OW 38
// if Frank then
12757: LD_EXP 27
12761: IFFALSE 12775
// SaveCharacters ( Frank , 13a_Frank ) ;
12763: LD_EXP 27
12767: PPUSH
12768: LD_STRING 13a_Frank
12770: PPUSH
12771: CALL_OW 38
// if Kikuchi then
12775: LD_EXP 28
12779: IFFALSE 12793
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12781: LD_EXP 28
12785: PPUSH
12786: LD_STRING 13a_Kikuchi
12788: PPUSH
12789: CALL_OW 38
// if Simms then
12793: LD_EXP 29
12797: IFFALSE 12811
// SaveCharacters ( Simms , 13a_Simms ) ;
12799: LD_EXP 29
12803: PPUSH
12804: LD_STRING 13a_Simms
12806: PPUSH
12807: CALL_OW 38
// if Joan then
12811: LD_EXP 30
12815: IFFALSE 12829
// SaveCharacters ( Joan , 13a_Joan ) ;
12817: LD_EXP 30
12821: PPUSH
12822: LD_STRING 13a_Joan
12824: PPUSH
12825: CALL_OW 38
// if DeltaDoctor then
12829: LD_EXP 31
12833: IFFALSE 12847
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12835: LD_EXP 31
12839: PPUSH
12840: LD_STRING 13a_DeltaDoctor
12842: PPUSH
12843: CALL_OW 38
// if Gossudarov then
12847: LD_EXP 32
12851: IFFALSE 12865
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12853: LD_EXP 32
12857: PPUSH
12858: LD_STRING 13a_Gossudarov
12860: PPUSH
12861: CALL_OW 38
// if Kirilenkova then
12865: LD_EXP 33
12869: IFFALSE 12883
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12871: LD_EXP 33
12875: PPUSH
12876: LD_STRING 13a_Kirilenkova
12878: PPUSH
12879: CALL_OW 38
// if Roth then
12883: LD_EXP 16
12887: IFFALSE 12901
// SaveCharacters ( Roth , 13a_Roth ) ;
12889: LD_EXP 16
12893: PPUSH
12894: LD_STRING 13a_Roth
12896: PPUSH
12897: CALL_OW 38
// if Masha then
12901: LD_EXP 49
12905: IFFALSE 12960
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12907: LD_EXP 49
12911: PPUSH
12912: CALL_OW 265
12916: PUSH
12917: LD_EXP 49
12921: PPUSH
12922: CALL_OW 262
12926: PUSH
12927: LD_EXP 49
12931: PPUSH
12932: CALL_OW 263
12936: PUSH
12937: LD_EXP 49
12941: PPUSH
12942: CALL_OW 264
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: LIST
12951: LIST
12952: PPUSH
12953: LD_STRING 13a_Masha
12955: PPUSH
12956: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12960: LD_ADDR_VAR 0 2
12964: PUSH
12965: LD_INT 21
12967: PUSH
12968: LD_INT 3
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: PPUSH
12975: CALL_OW 69
12979: ST_TO_ADDR
// tmp2 := [ ] ;
12980: LD_ADDR_VAR 0 3
12984: PUSH
12985: EMPTY
12986: ST_TO_ADDR
// if tmp then
12987: LD_VAR 0 2
12991: IFFALSE 13142
// for i in tmp do
12993: LD_ADDR_VAR 0 1
12997: PUSH
12998: LD_VAR 0 2
13002: PUSH
13003: FOR_IN
13004: IFFALSE 13140
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13006: LD_ADDR_VAR 0 3
13010: PUSH
13011: LD_VAR 0 3
13015: PUSH
13016: LD_VAR 0 1
13020: PPUSH
13021: CALL_OW 255
13025: PUSH
13026: LD_VAR 0 1
13030: PPUSH
13031: CALL_OW 248
13035: PUSH
13036: LD_VAR 0 1
13040: PPUSH
13041: CALL_OW 266
13045: PUSH
13046: LD_VAR 0 1
13050: PPUSH
13051: CALL_OW 250
13055: PUSH
13056: LD_VAR 0 1
13060: PPUSH
13061: CALL_OW 251
13065: PUSH
13066: LD_VAR 0 1
13070: PPUSH
13071: CALL_OW 254
13075: PUSH
13076: LD_VAR 0 1
13080: PPUSH
13081: CALL_OW 267
13085: PUSH
13086: LD_VAR 0 1
13090: PPUSH
13091: LD_INT 1
13093: PPUSH
13094: CALL_OW 268
13098: PUSH
13099: LD_VAR 0 1
13103: PPUSH
13104: LD_INT 2
13106: PPUSH
13107: CALL_OW 268
13111: PUSH
13112: LD_VAR 0 1
13116: PPUSH
13117: CALL_OW 269
13121: PUSH
13122: EMPTY
13123: LIST
13124: LIST
13125: LIST
13126: LIST
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: LIST
13132: LIST
13133: PUSH
13134: EMPTY
13135: LIST
13136: ADD
13137: ST_TO_ADDR
13138: GO 13003
13140: POP
13141: POP
// if tmp2 then
13142: LD_VAR 0 3
13146: IFFALSE 13160
// SaveVariable ( tmp2 , 13a_buildings ) ;
13148: LD_VAR 0 3
13152: PPUSH
13153: LD_STRING 13a_buildings
13155: PPUSH
13156: CALL_OW 39
// YouWin ;
13160: CALL_OW 103
// end ;
13164: PPOPN 6
13166: END
// export function SciRu ; var tmp , t ; begin
13167: LD_INT 0
13169: PPUSH
13170: PPUSH
13171: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13172: LD_ADDR_VAR 0 3
13176: PUSH
13177: LD_EXP 32
13181: PUSH
13182: LD_EXP 46
13186: PUSH
13187: LD_EXP 34
13191: PUSH
13192: LD_EXP 47
13196: PUSH
13197: LD_EXP 48
13201: PUSH
13202: LD_EXP 37
13206: PUSH
13207: LD_EXP 38
13211: PUSH
13212: LD_EXP 36
13216: PUSH
13217: EMPTY
13218: LIST
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: LIST
13225: LIST
13226: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13227: LD_ADDR_VAR 0 2
13231: PUSH
13232: LD_INT 22
13234: PUSH
13235: LD_INT 7
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: PUSH
13242: LD_INT 23
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: PUSH
13252: LD_INT 25
13254: PUSH
13255: LD_INT 4
13257: PUSH
13258: EMPTY
13259: LIST
13260: LIST
13261: PUSH
13262: LD_INT 26
13264: PUSH
13265: LD_INT 1
13267: PUSH
13268: EMPTY
13269: LIST
13270: LIST
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: PPUSH
13278: CALL_OW 69
13282: PUSH
13283: LD_VAR 0 3
13287: DIFF
13288: ST_TO_ADDR
// if tmp then
13289: LD_VAR 0 2
13293: IFFALSE 13309
// result := tmp [ 1 ] ;
13295: LD_ADDR_VAR 0 1
13299: PUSH
13300: LD_VAR 0 2
13304: PUSH
13305: LD_INT 1
13307: ARRAY
13308: ST_TO_ADDR
// end ;
13309: LD_VAR 0 1
13313: RET
// export function SolRu ; var tmp , t ; begin
13314: LD_INT 0
13316: PPUSH
13317: PPUSH
13318: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13319: LD_ADDR_VAR 0 3
13323: PUSH
13324: LD_EXP 32
13328: PUSH
13329: LD_EXP 46
13333: PUSH
13334: LD_EXP 34
13338: PUSH
13339: LD_EXP 47
13343: PUSH
13344: LD_EXP 48
13348: PUSH
13349: LD_EXP 37
13353: PUSH
13354: LD_EXP 38
13358: PUSH
13359: LD_EXP 36
13363: PUSH
13364: EMPTY
13365: LIST
13366: LIST
13367: LIST
13368: LIST
13369: LIST
13370: LIST
13371: LIST
13372: LIST
13373: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
13374: LD_ADDR_VAR 0 2
13378: PUSH
13379: LD_INT 22
13381: PUSH
13382: LD_INT 7
13384: PUSH
13385: EMPTY
13386: LIST
13387: LIST
13388: PUSH
13389: LD_INT 23
13391: PUSH
13392: LD_INT 3
13394: PUSH
13395: EMPTY
13396: LIST
13397: LIST
13398: PUSH
13399: LD_INT 25
13401: PUSH
13402: LD_INT 1
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: PUSH
13409: LD_INT 26
13411: PUSH
13412: LD_INT 1
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: PUSH
13419: EMPTY
13420: LIST
13421: LIST
13422: LIST
13423: LIST
13424: PPUSH
13425: CALL_OW 69
13429: PUSH
13430: LD_VAR 0 3
13434: DIFF
13435: ST_TO_ADDR
// if tmp then
13436: LD_VAR 0 2
13440: IFFALSE 13456
// result := tmp [ 1 ] ;
13442: LD_ADDR_VAR 0 1
13446: PUSH
13447: LD_VAR 0 2
13451: PUSH
13452: LD_INT 1
13454: ARRAY
13455: ST_TO_ADDR
// end ; end_of_file
13456: LD_VAR 0 1
13460: RET
// export function CustomEvent ( event ) ; begin
13461: LD_INT 0
13463: PPUSH
// end ;
13464: LD_VAR 0 2
13468: RET
// on UnitDestroyed ( un ) do var i , side ;
13469: LD_INT 0
13471: PPUSH
13472: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13473: LD_VAR 0 1
13477: PUSH
13478: LD_INT 22
13480: PUSH
13481: LD_INT 7
13483: PUSH
13484: EMPTY
13485: LIST
13486: LIST
13487: PUSH
13488: LD_INT 2
13490: PUSH
13491: LD_INT 25
13493: PUSH
13494: LD_INT 1
13496: PUSH
13497: EMPTY
13498: LIST
13499: LIST
13500: PUSH
13501: LD_INT 25
13503: PUSH
13504: LD_INT 2
13506: PUSH
13507: EMPTY
13508: LIST
13509: LIST
13510: PUSH
13511: LD_INT 25
13513: PUSH
13514: LD_INT 3
13516: PUSH
13517: EMPTY
13518: LIST
13519: LIST
13520: PUSH
13521: LD_INT 25
13523: PUSH
13524: LD_INT 4
13526: PUSH
13527: EMPTY
13528: LIST
13529: LIST
13530: PUSH
13531: LD_INT 25
13533: PUSH
13534: LD_INT 5
13536: PUSH
13537: EMPTY
13538: LIST
13539: LIST
13540: PUSH
13541: LD_INT 25
13543: PUSH
13544: LD_INT 8
13546: PUSH
13547: EMPTY
13548: LIST
13549: LIST
13550: PUSH
13551: LD_INT 25
13553: PUSH
13554: LD_INT 9
13556: PUSH
13557: EMPTY
13558: LIST
13559: LIST
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: LIST
13565: LIST
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: PPUSH
13575: CALL_OW 69
13579: IN
13580: IFFALSE 13596
// loss_counter := loss_counter + 1 ;
13582: LD_ADDR_EXP 13
13586: PUSH
13587: LD_EXP 13
13591: PUSH
13592: LD_INT 1
13594: PLUS
13595: ST_TO_ADDR
// if un = Abdul then
13596: LD_VAR 0 1
13600: PUSH
13601: LD_EXP 55
13605: EQUAL
13606: IFFALSE 13616
// abdul_escaped := false ;
13608: LD_ADDR_EXP 12
13612: PUSH
13613: LD_INT 0
13615: ST_TO_ADDR
// if un in ru_attackers then
13616: LD_VAR 0 1
13620: PUSH
13621: LD_EXP 52
13625: IN
13626: IFFALSE 13644
// ru_attackers := ru_attackers diff un ;
13628: LD_ADDR_EXP 52
13632: PUSH
13633: LD_EXP 52
13637: PUSH
13638: LD_VAR 0 1
13642: DIFF
13643: ST_TO_ADDR
// if un in ar_attackers then
13644: LD_VAR 0 1
13648: PUSH
13649: LD_EXP 10
13653: IN
13654: IFFALSE 13672
// ar_attackers := ar_attackers diff un ;
13656: LD_ADDR_EXP 10
13660: PUSH
13661: LD_EXP 10
13665: PUSH
13666: LD_VAR 0 1
13670: DIFF
13671: ST_TO_ADDR
// if un = JMM then
13672: LD_VAR 0 1
13676: PUSH
13677: LD_EXP 15
13681: EQUAL
13682: IFFALSE 13693
// begin YouLost ( JMM ) ;
13684: LD_STRING JMM
13686: PPUSH
13687: CALL_OW 104
// exit ;
13691: GO 13782
// end ; if un = Burlak then
13693: LD_VAR 0 1
13697: PUSH
13698: LD_EXP 46
13702: EQUAL
13703: IFFALSE 13714
// begin YouLost ( Burlak ) ;
13705: LD_STRING Burlak
13707: PPUSH
13708: CALL_OW 104
// exit ;
13712: GO 13782
// end ; if un = freedom then
13714: LD_VAR 0 1
13718: PUSH
13719: LD_EXP 3
13723: EQUAL
13724: IFFALSE 13735
// begin YouLost ( Destroyed ) ;
13726: LD_STRING Destroyed
13728: PPUSH
13729: CALL_OW 104
// exit ;
13733: GO 13782
// end ; if un = Masha then
13735: LD_VAR 0 1
13739: PUSH
13740: LD_EXP 49
13744: EQUAL
13745: IFFALSE 13754
// ChangeMissionObjectives ( M4b ) ;
13747: LD_STRING M4b
13749: PPUSH
13750: CALL_OW 337
// if un = Mastodont then
13754: LD_VAR 0 1
13758: PUSH
13759: LD_EXP 56
13763: EQUAL
13764: IFFALSE 13773
// ChangeMissionObjectives ( M4a ) ;
13766: LD_STRING M4a
13768: PPUSH
13769: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13773: LD_VAR 0 1
13777: PPUSH
13778: CALL 81107 0 1
// end ;
13782: PPOPN 3
13784: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13785: LD_VAR 0 1
13789: PPUSH
13790: LD_VAR 0 2
13794: PPUSH
13795: CALL 83441 0 2
// end ;
13799: PPOPN 2
13801: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13802: LD_VAR 0 1
13806: PPUSH
13807: CALL 82509 0 1
// end ;
13811: PPOPN 1
13813: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13814: LD_VAR 0 1
13818: PUSH
13819: LD_INT 22
13821: PUSH
13822: LD_INT 7
13824: PUSH
13825: EMPTY
13826: LIST
13827: LIST
13828: PUSH
13829: LD_INT 30
13831: PUSH
13832: LD_INT 0
13834: PUSH
13835: EMPTY
13836: LIST
13837: LIST
13838: PUSH
13839: EMPTY
13840: LIST
13841: LIST
13842: PPUSH
13843: CALL_OW 69
13847: IN
13848: IFFALSE 13887
// begin SetBName ( building , freedom ) ;
13850: LD_VAR 0 1
13854: PPUSH
13855: LD_STRING freedom
13857: PPUSH
13858: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13862: LD_INT 0
13864: PPUSH
13865: LD_INT 7
13867: PPUSH
13868: LD_INT 0
13870: PPUSH
13871: CALL_OW 324
// freedom := building ;
13875: LD_ADDR_EXP 3
13879: PUSH
13880: LD_VAR 0 1
13884: ST_TO_ADDR
// exit ;
13885: GO 13953
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13887: LD_VAR 0 1
13891: PUSH
13892: LD_INT 22
13894: PUSH
13895: LD_INT 7
13897: PUSH
13898: EMPTY
13899: LIST
13900: LIST
13901: PUSH
13902: LD_INT 23
13904: PUSH
13905: LD_INT 3
13907: PUSH
13908: EMPTY
13909: LIST
13910: LIST
13911: PUSH
13912: LD_INT 30
13914: PUSH
13915: LD_INT 6
13917: PUSH
13918: EMPTY
13919: LIST
13920: LIST
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: LIST
13926: PPUSH
13927: CALL_OW 69
13931: IN
13932: IFFALSE 13944
// begin ru_lab_builded := true ;
13934: LD_ADDR_EXP 5
13938: PUSH
13939: LD_INT 1
13941: ST_TO_ADDR
// exit ;
13942: GO 13953
// end ; MCE_BuildingComplete ( building ) ;
13944: LD_VAR 0 1
13948: PPUSH
13949: CALL 82750 0 1
// end ;
13953: PPOPN 1
13955: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13956: LD_VAR 0 1
13960: PPUSH
13961: LD_VAR 0 2
13965: PPUSH
13966: CALL 80803 0 2
// end ;
13970: PPOPN 2
13972: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13973: LD_VAR 0 1
13977: PPUSH
13978: LD_VAR 0 2
13982: PPUSH
13983: LD_VAR 0 3
13987: PPUSH
13988: LD_VAR 0 4
13992: PPUSH
13993: LD_VAR 0 5
13997: PPUSH
13998: CALL 80423 0 5
// end ;
14002: PPOPN 5
14004: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
14005: LD_VAR 0 1
14009: PPUSH
14010: LD_VAR 0 2
14014: PPUSH
14015: CALL 80004 0 2
// end ;
14019: PPOPN 2
14021: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14022: LD_VAR 0 1
14026: PPUSH
14027: CALL_OW 263
14031: PUSH
14032: LD_INT 3
14034: EQUAL
14035: PUSH
14036: LD_VAR 0 2
14040: PPUSH
14041: CALL_OW 263
14045: PUSH
14046: LD_INT 3
14048: EQUAL
14049: OR
14050: IFFALSE 14066
// hack_counter := hack_counter + 1 ;
14052: LD_ADDR_EXP 14
14056: PUSH
14057: LD_EXP 14
14061: PUSH
14062: LD_INT 1
14064: PLUS
14065: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14066: LD_VAR 0 1
14070: PPUSH
14071: LD_VAR 0 2
14075: PPUSH
14076: LD_VAR 0 3
14080: PPUSH
14081: LD_VAR 0 4
14085: PPUSH
14086: CALL 79842 0 4
// end ;
14090: PPOPN 4
14092: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14093: LD_VAR 0 1
14097: PPUSH
14098: LD_VAR 0 2
14102: PPUSH
14103: LD_VAR 0 3
14107: PPUSH
14108: CALL 79617 0 3
// end ;
14112: PPOPN 3
14114: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14115: LD_VAR 0 1
14119: PPUSH
14120: LD_VAR 0 2
14124: PPUSH
14125: CALL 79502 0 2
// end ;
14129: PPOPN 2
14131: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14132: LD_VAR 0 1
14136: PPUSH
14137: LD_VAR 0 2
14141: PPUSH
14142: CALL 83736 0 2
// end ;
14146: PPOPN 2
14148: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14149: LD_VAR 0 1
14153: PPUSH
14154: LD_VAR 0 2
14158: PPUSH
14159: LD_VAR 0 3
14163: PPUSH
14164: LD_VAR 0 4
14168: PPUSH
14169: CALL 83952 0 4
// end ;
14173: PPOPN 4
14175: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14176: LD_VAR 0 1
14180: PPUSH
14181: LD_VAR 0 2
14185: PPUSH
14186: CALL 79311 0 2
// end ;
14190: PPOPN 2
14192: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14193: LD_VAR 0 1
14197: PPUSH
14198: CALL 97539 0 1
// end ; end_of_file
14202: PPOPN 1
14204: END
// every 0 0$30 do var cr , time ;
14205: GO 14207
14207: DISABLE
14208: LD_INT 0
14210: PPUSH
14211: PPUSH
// begin time := 0 0$20 ;
14212: LD_ADDR_VAR 0 2
14216: PUSH
14217: LD_INT 700
14219: ST_TO_ADDR
// while game do
14220: LD_EXP 2
14224: IFFALSE 14323
// begin wait ( time ) ;
14226: LD_VAR 0 2
14230: PPUSH
14231: CALL_OW 67
// if tick > 2 2$00 then
14235: LD_OWVAR 1
14239: PUSH
14240: LD_INT 4200
14242: GREATER
14243: IFFALSE 14276
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 ] [ Difficulty ] ;
14245: LD_ADDR_VAR 0 2
14249: PUSH
14250: LD_VAR 0 2
14254: PUSH
14255: LD_INT 140
14257: PUSH
14258: LD_INT 140
14260: PUSH
14261: LD_INT 210
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: LIST
14268: PUSH
14269: LD_OWVAR 67
14273: ARRAY
14274: PLUS
14275: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
14276: LD_INT 1
14278: PPUSH
14279: LD_INT 5
14281: PPUSH
14282: CALL_OW 12
14286: PPUSH
14287: LD_INT 70
14289: PPUSH
14290: LD_INT 49
14292: PPUSH
14293: LD_INT 25
14295: PPUSH
14296: LD_INT 1
14298: PPUSH
14299: CALL_OW 56
// if time > 3 3$00 then
14303: LD_VAR 0 2
14307: PUSH
14308: LD_INT 6300
14310: GREATER
14311: IFFALSE 14321
// time := 0 0$30 ;
14313: LD_ADDR_VAR 0 2
14317: PUSH
14318: LD_INT 1050
14320: ST_TO_ADDR
// end ;
14321: GO 14220
// end ;
14323: PPOPN 2
14325: END
// every 0 0$30 do var cr , time ;
14326: GO 14328
14328: DISABLE
14329: LD_INT 0
14331: PPUSH
14332: PPUSH
// begin time := 0 0$20 ;
14333: LD_ADDR_VAR 0 2
14337: PUSH
14338: LD_INT 700
14340: ST_TO_ADDR
// while game do
14341: LD_EXP 2
14345: IFFALSE 14434
// begin wait ( time ) ;
14347: LD_VAR 0 2
14351: PPUSH
14352: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 ] [ Difficulty ] ;
14356: LD_ADDR_VAR 0 2
14360: PUSH
14361: LD_VAR 0 2
14365: PUSH
14366: LD_INT 140
14368: PUSH
14369: LD_INT 175
14371: PUSH
14372: LD_INT 210
14374: PUSH
14375: EMPTY
14376: LIST
14377: LIST
14378: LIST
14379: PUSH
14380: LD_OWVAR 67
14384: ARRAY
14385: PLUS
14386: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
14387: LD_INT 3
14389: PPUSH
14390: LD_INT 5
14392: PPUSH
14393: CALL_OW 12
14397: PPUSH
14398: LD_INT 26
14400: PPUSH
14401: LD_INT 9
14403: PPUSH
14404: LD_INT 30
14406: PPUSH
14407: LD_INT 1
14409: PPUSH
14410: CALL_OW 56
// if time > 3 3$00 then
14414: LD_VAR 0 2
14418: PUSH
14419: LD_INT 6300
14421: GREATER
14422: IFFALSE 14432
// time := 0 0$20 ;
14424: LD_ADDR_VAR 0 2
14428: PUSH
14429: LD_INT 700
14431: ST_TO_ADDR
// end ;
14432: GO 14341
// end ;
14434: PPOPN 2
14436: END
// every 0 0$30 do var cr , time ;
14437: GO 14439
14439: DISABLE
14440: LD_INT 0
14442: PPUSH
14443: PPUSH
// begin time := 0 0$20 ;
14444: LD_ADDR_VAR 0 2
14448: PUSH
14449: LD_INT 700
14451: ST_TO_ADDR
// while game do
14452: LD_EXP 2
14456: IFFALSE 14581
// begin wait ( time ) ;
14458: LD_VAR 0 2
14462: PPUSH
14463: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14467: LD_ADDR_VAR 0 2
14471: PUSH
14472: LD_VAR 0 2
14476: PUSH
14477: LD_INT 175
14479: PUSH
14480: LD_INT 210
14482: PUSH
14483: LD_INT 280
14485: PUSH
14486: EMPTY
14487: LIST
14488: LIST
14489: LIST
14490: PUSH
14491: LD_OWVAR 67
14495: ARRAY
14496: PLUS
14497: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14498: LD_INT 1
14500: PPUSH
14501: LD_INT 5
14503: PPUSH
14504: CALL_OW 12
14508: PPUSH
14509: LD_INT 179
14511: PPUSH
14512: LD_INT 101
14514: PPUSH
14515: LD_INT 20
14517: PPUSH
14518: LD_INT 1
14520: PPUSH
14521: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14525: LD_INT 350
14527: PPUSH
14528: LD_INT 525
14530: PPUSH
14531: CALL_OW 12
14535: PPUSH
14536: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14540: LD_INT 1
14542: PPUSH
14543: LD_INT 5
14545: PPUSH
14546: CALL_OW 12
14550: PPUSH
14551: LD_INT 9
14553: PPUSH
14554: LD_INT 1
14556: PPUSH
14557: CALL_OW 55
// if time > 4 4$00 then
14561: LD_VAR 0 2
14565: PUSH
14566: LD_INT 8400
14568: GREATER
14569: IFFALSE 14579
// time := 0 0$30 ;
14571: LD_ADDR_VAR 0 2
14575: PUSH
14576: LD_INT 1050
14578: ST_TO_ADDR
// end ;
14579: GO 14452
// end ;
14581: PPOPN 2
14583: END
// every 0 0$30 do var cr , time ;
14584: GO 14586
14586: DISABLE
14587: LD_INT 0
14589: PPUSH
14590: PPUSH
// begin time := 0 0$10 ;
14591: LD_ADDR_VAR 0 2
14595: PUSH
14596: LD_INT 350
14598: ST_TO_ADDR
// while game do
14599: LD_EXP 2
14603: IFFALSE 14737
// begin wait ( time ) ;
14605: LD_VAR 0 2
14609: PPUSH
14610: CALL_OW 67
// time := time + 0 0$10 ;
14614: LD_ADDR_VAR 0 2
14618: PUSH
14619: LD_VAR 0 2
14623: PUSH
14624: LD_INT 350
14626: PLUS
14627: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14628: LD_INT 1
14630: PPUSH
14631: LD_INT 5
14633: PPUSH
14634: CALL_OW 12
14638: PPUSH
14639: LD_INT 11
14641: PPUSH
14642: LD_INT 1
14644: PPUSH
14645: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14649: LD_ADDR_VAR 0 1
14653: PUSH
14654: LD_INT 1
14656: PPUSH
14657: LD_INT 3
14659: PPUSH
14660: CALL_OW 12
14664: ST_TO_ADDR
// if cr = 1 then
14665: LD_VAR 0 1
14669: PUSH
14670: LD_INT 1
14672: EQUAL
14673: IFFALSE 14717
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14675: LD_INT 700
14677: PPUSH
14678: LD_INT 1575
14680: PPUSH
14681: CALL_OW 12
14685: PPUSH
14686: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14690: LD_INT 1
14692: PPUSH
14693: LD_INT 5
14695: PPUSH
14696: CALL_OW 12
14700: PPUSH
14701: LD_INT 34
14703: PPUSH
14704: LD_INT 50
14706: PPUSH
14707: LD_INT 7
14709: PPUSH
14710: LD_INT 1
14712: PPUSH
14713: CALL_OW 56
// end ; if time > 4 4$00 then
14717: LD_VAR 0 2
14721: PUSH
14722: LD_INT 8400
14724: GREATER
14725: IFFALSE 14735
// time := 0 0$40 ;
14727: LD_ADDR_VAR 0 2
14731: PUSH
14732: LD_INT 1400
14734: ST_TO_ADDR
// end ;
14735: GO 14599
// end ; end_of_file
14737: PPOPN 2
14739: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14740: LD_INT 0
14742: PPUSH
14743: PPUSH
// if exist_mode then
14744: LD_VAR 0 2
14748: IFFALSE 14773
// unit := CreateCharacter ( prefix & ident ) else
14750: LD_ADDR_VAR 0 5
14754: PUSH
14755: LD_VAR 0 3
14759: PUSH
14760: LD_VAR 0 1
14764: STR
14765: PPUSH
14766: CALL_OW 34
14770: ST_TO_ADDR
14771: GO 14788
// unit := NewCharacter ( ident ) ;
14773: LD_ADDR_VAR 0 5
14777: PUSH
14778: LD_VAR 0 1
14782: PPUSH
14783: CALL_OW 25
14787: ST_TO_ADDR
// result := unit ;
14788: LD_ADDR_VAR 0 4
14792: PUSH
14793: LD_VAR 0 5
14797: ST_TO_ADDR
// end ;
14798: LD_VAR 0 4
14802: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14803: LD_INT 0
14805: PPUSH
14806: PPUSH
// if not side or not nation then
14807: LD_VAR 0 1
14811: NOT
14812: PUSH
14813: LD_VAR 0 2
14817: NOT
14818: OR
14819: IFFALSE 14823
// exit ;
14821: GO 15591
// case nation of nation_american :
14823: LD_VAR 0 2
14827: PUSH
14828: LD_INT 1
14830: DOUBLE
14831: EQUAL
14832: IFTRUE 14836
14834: GO 15050
14836: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14837: LD_ADDR_VAR 0 4
14841: PUSH
14842: LD_INT 35
14844: PUSH
14845: LD_INT 45
14847: PUSH
14848: LD_INT 46
14850: PUSH
14851: LD_INT 47
14853: PUSH
14854: LD_INT 82
14856: PUSH
14857: LD_INT 83
14859: PUSH
14860: LD_INT 84
14862: PUSH
14863: LD_INT 85
14865: PUSH
14866: LD_INT 86
14868: PUSH
14869: LD_INT 1
14871: PUSH
14872: LD_INT 2
14874: PUSH
14875: LD_INT 6
14877: PUSH
14878: LD_INT 15
14880: PUSH
14881: LD_INT 16
14883: PUSH
14884: LD_INT 7
14886: PUSH
14887: LD_INT 12
14889: PUSH
14890: LD_INT 13
14892: PUSH
14893: LD_INT 10
14895: PUSH
14896: LD_INT 14
14898: PUSH
14899: LD_INT 20
14901: PUSH
14902: LD_INT 21
14904: PUSH
14905: LD_INT 22
14907: PUSH
14908: LD_INT 25
14910: PUSH
14911: LD_INT 32
14913: PUSH
14914: LD_INT 27
14916: PUSH
14917: LD_INT 36
14919: PUSH
14920: LD_INT 69
14922: PUSH
14923: LD_INT 39
14925: PUSH
14926: LD_INT 34
14928: PUSH
14929: LD_INT 40
14931: PUSH
14932: LD_INT 48
14934: PUSH
14935: LD_INT 49
14937: PUSH
14938: LD_INT 50
14940: PUSH
14941: LD_INT 51
14943: PUSH
14944: LD_INT 52
14946: PUSH
14947: LD_INT 53
14949: PUSH
14950: LD_INT 54
14952: PUSH
14953: LD_INT 55
14955: PUSH
14956: LD_INT 56
14958: PUSH
14959: LD_INT 57
14961: PUSH
14962: LD_INT 58
14964: PUSH
14965: LD_INT 59
14967: PUSH
14968: LD_INT 60
14970: PUSH
14971: LD_INT 61
14973: PUSH
14974: LD_INT 62
14976: PUSH
14977: LD_INT 80
14979: PUSH
14980: LD_INT 82
14982: PUSH
14983: LD_INT 83
14985: PUSH
14986: LD_INT 84
14988: PUSH
14989: LD_INT 85
14991: PUSH
14992: LD_INT 86
14994: PUSH
14995: EMPTY
14996: LIST
14997: LIST
14998: LIST
14999: LIST
15000: LIST
15001: LIST
15002: LIST
15003: LIST
15004: LIST
15005: LIST
15006: LIST
15007: LIST
15008: LIST
15009: LIST
15010: LIST
15011: LIST
15012: LIST
15013: LIST
15014: LIST
15015: LIST
15016: LIST
15017: LIST
15018: LIST
15019: LIST
15020: LIST
15021: LIST
15022: LIST
15023: LIST
15024: LIST
15025: LIST
15026: LIST
15027: LIST
15028: LIST
15029: LIST
15030: LIST
15031: LIST
15032: LIST
15033: LIST
15034: LIST
15035: LIST
15036: LIST
15037: LIST
15038: LIST
15039: LIST
15040: LIST
15041: LIST
15042: LIST
15043: LIST
15044: LIST
15045: LIST
15046: LIST
15047: ST_TO_ADDR
15048: GO 15515
15050: LD_INT 2
15052: DOUBLE
15053: EQUAL
15054: IFTRUE 15058
15056: GO 15284
15058: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15059: LD_ADDR_VAR 0 4
15063: PUSH
15064: LD_INT 35
15066: PUSH
15067: LD_INT 45
15069: PUSH
15070: LD_INT 46
15072: PUSH
15073: LD_INT 47
15075: PUSH
15076: LD_INT 82
15078: PUSH
15079: LD_INT 83
15081: PUSH
15082: LD_INT 84
15084: PUSH
15085: LD_INT 85
15087: PUSH
15088: LD_INT 87
15090: PUSH
15091: LD_INT 70
15093: PUSH
15094: LD_INT 1
15096: PUSH
15097: LD_INT 11
15099: PUSH
15100: LD_INT 3
15102: PUSH
15103: LD_INT 4
15105: PUSH
15106: LD_INT 5
15108: PUSH
15109: LD_INT 6
15111: PUSH
15112: LD_INT 15
15114: PUSH
15115: LD_INT 18
15117: PUSH
15118: LD_INT 7
15120: PUSH
15121: LD_INT 17
15123: PUSH
15124: LD_INT 8
15126: PUSH
15127: LD_INT 20
15129: PUSH
15130: LD_INT 21
15132: PUSH
15133: LD_INT 22
15135: PUSH
15136: LD_INT 72
15138: PUSH
15139: LD_INT 26
15141: PUSH
15142: LD_INT 69
15144: PUSH
15145: LD_INT 39
15147: PUSH
15148: LD_INT 40
15150: PUSH
15151: LD_INT 41
15153: PUSH
15154: LD_INT 42
15156: PUSH
15157: LD_INT 43
15159: PUSH
15160: LD_INT 48
15162: PUSH
15163: LD_INT 49
15165: PUSH
15166: LD_INT 50
15168: PUSH
15169: LD_INT 51
15171: PUSH
15172: LD_INT 52
15174: PUSH
15175: LD_INT 53
15177: PUSH
15178: LD_INT 54
15180: PUSH
15181: LD_INT 55
15183: PUSH
15184: LD_INT 56
15186: PUSH
15187: LD_INT 60
15189: PUSH
15190: LD_INT 61
15192: PUSH
15193: LD_INT 62
15195: PUSH
15196: LD_INT 66
15198: PUSH
15199: LD_INT 67
15201: PUSH
15202: LD_INT 68
15204: PUSH
15205: LD_INT 81
15207: PUSH
15208: LD_INT 82
15210: PUSH
15211: LD_INT 83
15213: PUSH
15214: LD_INT 84
15216: PUSH
15217: LD_INT 85
15219: PUSH
15220: LD_INT 87
15222: PUSH
15223: LD_INT 88
15225: PUSH
15226: EMPTY
15227: LIST
15228: LIST
15229: LIST
15230: LIST
15231: LIST
15232: LIST
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: LIST
15238: LIST
15239: LIST
15240: LIST
15241: LIST
15242: LIST
15243: LIST
15244: LIST
15245: LIST
15246: LIST
15247: LIST
15248: LIST
15249: LIST
15250: LIST
15251: LIST
15252: LIST
15253: LIST
15254: LIST
15255: LIST
15256: LIST
15257: LIST
15258: LIST
15259: LIST
15260: LIST
15261: LIST
15262: LIST
15263: LIST
15264: LIST
15265: LIST
15266: LIST
15267: LIST
15268: LIST
15269: LIST
15270: LIST
15271: LIST
15272: LIST
15273: LIST
15274: LIST
15275: LIST
15276: LIST
15277: LIST
15278: LIST
15279: LIST
15280: LIST
15281: ST_TO_ADDR
15282: GO 15515
15284: LD_INT 3
15286: DOUBLE
15287: EQUAL
15288: IFTRUE 15292
15290: GO 15514
15292: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
15293: LD_ADDR_VAR 0 4
15297: PUSH
15298: LD_INT 46
15300: PUSH
15301: LD_INT 47
15303: PUSH
15304: LD_INT 1
15306: PUSH
15307: LD_INT 2
15309: PUSH
15310: LD_INT 82
15312: PUSH
15313: LD_INT 83
15315: PUSH
15316: LD_INT 84
15318: PUSH
15319: LD_INT 85
15321: PUSH
15322: LD_INT 86
15324: PUSH
15325: LD_INT 11
15327: PUSH
15328: LD_INT 9
15330: PUSH
15331: LD_INT 20
15333: PUSH
15334: LD_INT 19
15336: PUSH
15337: LD_INT 21
15339: PUSH
15340: LD_INT 24
15342: PUSH
15343: LD_INT 22
15345: PUSH
15346: LD_INT 25
15348: PUSH
15349: LD_INT 28
15351: PUSH
15352: LD_INT 29
15354: PUSH
15355: LD_INT 30
15357: PUSH
15358: LD_INT 31
15360: PUSH
15361: LD_INT 37
15363: PUSH
15364: LD_INT 38
15366: PUSH
15367: LD_INT 32
15369: PUSH
15370: LD_INT 27
15372: PUSH
15373: LD_INT 33
15375: PUSH
15376: LD_INT 69
15378: PUSH
15379: LD_INT 39
15381: PUSH
15382: LD_INT 34
15384: PUSH
15385: LD_INT 40
15387: PUSH
15388: LD_INT 71
15390: PUSH
15391: LD_INT 23
15393: PUSH
15394: LD_INT 44
15396: PUSH
15397: LD_INT 48
15399: PUSH
15400: LD_INT 49
15402: PUSH
15403: LD_INT 50
15405: PUSH
15406: LD_INT 51
15408: PUSH
15409: LD_INT 52
15411: PUSH
15412: LD_INT 53
15414: PUSH
15415: LD_INT 54
15417: PUSH
15418: LD_INT 55
15420: PUSH
15421: LD_INT 56
15423: PUSH
15424: LD_INT 57
15426: PUSH
15427: LD_INT 58
15429: PUSH
15430: LD_INT 59
15432: PUSH
15433: LD_INT 63
15435: PUSH
15436: LD_INT 64
15438: PUSH
15439: LD_INT 65
15441: PUSH
15442: LD_INT 82
15444: PUSH
15445: LD_INT 83
15447: PUSH
15448: LD_INT 84
15450: PUSH
15451: LD_INT 85
15453: PUSH
15454: LD_INT 86
15456: PUSH
15457: EMPTY
15458: LIST
15459: LIST
15460: LIST
15461: LIST
15462: LIST
15463: LIST
15464: LIST
15465: LIST
15466: LIST
15467: LIST
15468: LIST
15469: LIST
15470: LIST
15471: LIST
15472: LIST
15473: LIST
15474: LIST
15475: LIST
15476: LIST
15477: LIST
15478: LIST
15479: LIST
15480: LIST
15481: LIST
15482: LIST
15483: LIST
15484: LIST
15485: LIST
15486: LIST
15487: LIST
15488: LIST
15489: LIST
15490: LIST
15491: LIST
15492: LIST
15493: LIST
15494: LIST
15495: LIST
15496: LIST
15497: LIST
15498: LIST
15499: LIST
15500: LIST
15501: LIST
15502: LIST
15503: LIST
15504: LIST
15505: LIST
15506: LIST
15507: LIST
15508: LIST
15509: LIST
15510: LIST
15511: ST_TO_ADDR
15512: GO 15515
15514: POP
// if state > - 1 and state < 3 then
15515: LD_VAR 0 3
15519: PUSH
15520: LD_INT 1
15522: NEG
15523: GREATER
15524: PUSH
15525: LD_VAR 0 3
15529: PUSH
15530: LD_INT 3
15532: LESS
15533: AND
15534: IFFALSE 15591
// for i in result do
15536: LD_ADDR_VAR 0 5
15540: PUSH
15541: LD_VAR 0 4
15545: PUSH
15546: FOR_IN
15547: IFFALSE 15589
// if GetTech ( i , side ) <> state then
15549: LD_VAR 0 5
15553: PPUSH
15554: LD_VAR 0 1
15558: PPUSH
15559: CALL_OW 321
15563: PUSH
15564: LD_VAR 0 3
15568: NONEQUAL
15569: IFFALSE 15587
// result := result diff i ;
15571: LD_ADDR_VAR 0 4
15575: PUSH
15576: LD_VAR 0 4
15580: PUSH
15581: LD_VAR 0 5
15585: DIFF
15586: ST_TO_ADDR
15587: GO 15546
15589: POP
15590: POP
// end ;
15591: LD_VAR 0 4
15595: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15596: LD_INT 0
15598: PPUSH
15599: PPUSH
15600: PPUSH
// result := true ;
15601: LD_ADDR_VAR 0 3
15605: PUSH
15606: LD_INT 1
15608: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15609: LD_ADDR_VAR 0 5
15613: PUSH
15614: LD_VAR 0 2
15618: PPUSH
15619: CALL_OW 480
15623: ST_TO_ADDR
// if not tmp then
15624: LD_VAR 0 5
15628: NOT
15629: IFFALSE 15633
// exit ;
15631: GO 15682
// for i in tmp do
15633: LD_ADDR_VAR 0 4
15637: PUSH
15638: LD_VAR 0 5
15642: PUSH
15643: FOR_IN
15644: IFFALSE 15680
// if GetTech ( i , side ) <> state_researched then
15646: LD_VAR 0 4
15650: PPUSH
15651: LD_VAR 0 1
15655: PPUSH
15656: CALL_OW 321
15660: PUSH
15661: LD_INT 2
15663: NONEQUAL
15664: IFFALSE 15678
// begin result := false ;
15666: LD_ADDR_VAR 0 3
15670: PUSH
15671: LD_INT 0
15673: ST_TO_ADDR
// exit ;
15674: POP
15675: POP
15676: GO 15682
// end ;
15678: GO 15643
15680: POP
15681: POP
// end ;
15682: LD_VAR 0 3
15686: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15687: LD_INT 0
15689: PPUSH
15690: PPUSH
15691: PPUSH
15692: PPUSH
15693: PPUSH
15694: PPUSH
15695: PPUSH
15696: PPUSH
15697: PPUSH
15698: PPUSH
15699: PPUSH
15700: PPUSH
15701: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15702: LD_VAR 0 1
15706: NOT
15707: PUSH
15708: LD_VAR 0 1
15712: PPUSH
15713: CALL_OW 257
15717: PUSH
15718: LD_INT 9
15720: NONEQUAL
15721: OR
15722: IFFALSE 15726
// exit ;
15724: GO 16299
// side := GetSide ( unit ) ;
15726: LD_ADDR_VAR 0 9
15730: PUSH
15731: LD_VAR 0 1
15735: PPUSH
15736: CALL_OW 255
15740: ST_TO_ADDR
// tech_space := tech_spacanom ;
15741: LD_ADDR_VAR 0 12
15745: PUSH
15746: LD_INT 29
15748: ST_TO_ADDR
// tech_time := tech_taurad ;
15749: LD_ADDR_VAR 0 13
15753: PUSH
15754: LD_INT 28
15756: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15757: LD_ADDR_VAR 0 11
15761: PUSH
15762: LD_VAR 0 1
15766: PPUSH
15767: CALL_OW 310
15771: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15772: LD_VAR 0 11
15776: PPUSH
15777: CALL_OW 247
15781: PUSH
15782: LD_INT 2
15784: EQUAL
15785: IFFALSE 15789
// exit ;
15787: GO 16299
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15789: LD_ADDR_VAR 0 8
15793: PUSH
15794: LD_INT 81
15796: PUSH
15797: LD_VAR 0 9
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: PUSH
15806: LD_INT 3
15808: PUSH
15809: LD_INT 21
15811: PUSH
15812: LD_INT 3
15814: PUSH
15815: EMPTY
15816: LIST
15817: LIST
15818: PUSH
15819: EMPTY
15820: LIST
15821: LIST
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PPUSH
15827: CALL_OW 69
15831: ST_TO_ADDR
// if not tmp then
15832: LD_VAR 0 8
15836: NOT
15837: IFFALSE 15841
// exit ;
15839: GO 16299
// if in_unit then
15841: LD_VAR 0 11
15845: IFFALSE 15869
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15847: LD_ADDR_VAR 0 10
15851: PUSH
15852: LD_VAR 0 8
15856: PPUSH
15857: LD_VAR 0 11
15861: PPUSH
15862: CALL_OW 74
15866: ST_TO_ADDR
15867: GO 15889
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15869: LD_ADDR_VAR 0 10
15873: PUSH
15874: LD_VAR 0 8
15878: PPUSH
15879: LD_VAR 0 1
15883: PPUSH
15884: CALL_OW 74
15888: ST_TO_ADDR
// if not enemy then
15889: LD_VAR 0 10
15893: NOT
15894: IFFALSE 15898
// exit ;
15896: GO 16299
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15898: LD_VAR 0 11
15902: PUSH
15903: LD_VAR 0 11
15907: PPUSH
15908: LD_VAR 0 10
15912: PPUSH
15913: CALL_OW 296
15917: PUSH
15918: LD_INT 13
15920: GREATER
15921: AND
15922: PUSH
15923: LD_VAR 0 1
15927: PPUSH
15928: LD_VAR 0 10
15932: PPUSH
15933: CALL_OW 296
15937: PUSH
15938: LD_INT 12
15940: GREATER
15941: OR
15942: IFFALSE 15946
// exit ;
15944: GO 16299
// missile := [ 1 ] ;
15946: LD_ADDR_VAR 0 14
15950: PUSH
15951: LD_INT 1
15953: PUSH
15954: EMPTY
15955: LIST
15956: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15957: LD_VAR 0 9
15961: PPUSH
15962: LD_VAR 0 12
15966: PPUSH
15967: CALL_OW 325
15971: IFFALSE 16000
// missile := Insert ( missile , missile + 1 , 2 ) ;
15973: LD_ADDR_VAR 0 14
15977: PUSH
15978: LD_VAR 0 14
15982: PPUSH
15983: LD_VAR 0 14
15987: PUSH
15988: LD_INT 1
15990: PLUS
15991: PPUSH
15992: LD_INT 2
15994: PPUSH
15995: CALL_OW 2
15999: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16000: LD_VAR 0 9
16004: PPUSH
16005: LD_VAR 0 13
16009: PPUSH
16010: CALL_OW 325
16014: PUSH
16015: LD_VAR 0 10
16019: PPUSH
16020: CALL_OW 255
16024: PPUSH
16025: LD_VAR 0 13
16029: PPUSH
16030: CALL_OW 325
16034: NOT
16035: AND
16036: IFFALSE 16065
// missile := Insert ( missile , missile + 1 , 3 ) ;
16038: LD_ADDR_VAR 0 14
16042: PUSH
16043: LD_VAR 0 14
16047: PPUSH
16048: LD_VAR 0 14
16052: PUSH
16053: LD_INT 1
16055: PLUS
16056: PPUSH
16057: LD_INT 3
16059: PPUSH
16060: CALL_OW 2
16064: ST_TO_ADDR
// if missile < 2 then
16065: LD_VAR 0 14
16069: PUSH
16070: LD_INT 2
16072: LESS
16073: IFFALSE 16077
// exit ;
16075: GO 16299
// x := GetX ( enemy ) ;
16077: LD_ADDR_VAR 0 4
16081: PUSH
16082: LD_VAR 0 10
16086: PPUSH
16087: CALL_OW 250
16091: ST_TO_ADDR
// y := GetY ( enemy ) ;
16092: LD_ADDR_VAR 0 5
16096: PUSH
16097: LD_VAR 0 10
16101: PPUSH
16102: CALL_OW 251
16106: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16107: LD_ADDR_VAR 0 6
16111: PUSH
16112: LD_VAR 0 4
16116: PUSH
16117: LD_INT 1
16119: NEG
16120: PPUSH
16121: LD_INT 1
16123: PPUSH
16124: CALL_OW 12
16128: PLUS
16129: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16130: LD_ADDR_VAR 0 7
16134: PUSH
16135: LD_VAR 0 5
16139: PUSH
16140: LD_INT 1
16142: NEG
16143: PPUSH
16144: LD_INT 1
16146: PPUSH
16147: CALL_OW 12
16151: PLUS
16152: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16153: LD_VAR 0 6
16157: PPUSH
16158: LD_VAR 0 7
16162: PPUSH
16163: CALL_OW 488
16167: NOT
16168: IFFALSE 16190
// begin _x := x ;
16170: LD_ADDR_VAR 0 6
16174: PUSH
16175: LD_VAR 0 4
16179: ST_TO_ADDR
// _y := y ;
16180: LD_ADDR_VAR 0 7
16184: PUSH
16185: LD_VAR 0 5
16189: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16190: LD_ADDR_VAR 0 3
16194: PUSH
16195: LD_INT 1
16197: PPUSH
16198: LD_VAR 0 14
16202: PPUSH
16203: CALL_OW 12
16207: ST_TO_ADDR
// case i of 1 :
16208: LD_VAR 0 3
16212: PUSH
16213: LD_INT 1
16215: DOUBLE
16216: EQUAL
16217: IFTRUE 16221
16219: GO 16238
16221: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16222: LD_VAR 0 1
16226: PPUSH
16227: LD_VAR 0 10
16231: PPUSH
16232: CALL_OW 115
16236: GO 16299
16238: LD_INT 2
16240: DOUBLE
16241: EQUAL
16242: IFTRUE 16246
16244: GO 16268
16246: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
16247: LD_VAR 0 1
16251: PPUSH
16252: LD_VAR 0 6
16256: PPUSH
16257: LD_VAR 0 7
16261: PPUSH
16262: CALL_OW 153
16266: GO 16299
16268: LD_INT 3
16270: DOUBLE
16271: EQUAL
16272: IFTRUE 16276
16274: GO 16298
16276: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
16277: LD_VAR 0 1
16281: PPUSH
16282: LD_VAR 0 6
16286: PPUSH
16287: LD_VAR 0 7
16291: PPUSH
16292: CALL_OW 154
16296: GO 16299
16298: POP
// end ;
16299: LD_VAR 0 2
16303: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
16304: LD_INT 0
16306: PPUSH
16307: PPUSH
16308: PPUSH
16309: PPUSH
16310: PPUSH
16311: PPUSH
// if not unit or not building then
16312: LD_VAR 0 1
16316: NOT
16317: PUSH
16318: LD_VAR 0 2
16322: NOT
16323: OR
16324: IFFALSE 16328
// exit ;
16326: GO 16486
// x := GetX ( building ) ;
16328: LD_ADDR_VAR 0 5
16332: PUSH
16333: LD_VAR 0 2
16337: PPUSH
16338: CALL_OW 250
16342: ST_TO_ADDR
// y := GetY ( building ) ;
16343: LD_ADDR_VAR 0 6
16347: PUSH
16348: LD_VAR 0 2
16352: PPUSH
16353: CALL_OW 251
16357: ST_TO_ADDR
// for i = 0 to 5 do
16358: LD_ADDR_VAR 0 4
16362: PUSH
16363: DOUBLE
16364: LD_INT 0
16366: DEC
16367: ST_TO_ADDR
16368: LD_INT 5
16370: PUSH
16371: FOR_TO
16372: IFFALSE 16484
// begin _x := ShiftX ( x , i , 3 ) ;
16374: LD_ADDR_VAR 0 7
16378: PUSH
16379: LD_VAR 0 5
16383: PPUSH
16384: LD_VAR 0 4
16388: PPUSH
16389: LD_INT 3
16391: PPUSH
16392: CALL_OW 272
16396: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
16397: LD_ADDR_VAR 0 8
16401: PUSH
16402: LD_VAR 0 6
16406: PPUSH
16407: LD_VAR 0 4
16411: PPUSH
16412: LD_INT 3
16414: PPUSH
16415: CALL_OW 273
16419: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16420: LD_VAR 0 7
16424: PPUSH
16425: LD_VAR 0 8
16429: PPUSH
16430: CALL_OW 488
16434: NOT
16435: IFFALSE 16439
// continue ;
16437: GO 16371
// if HexInfo ( _x , _y ) = 0 then
16439: LD_VAR 0 7
16443: PPUSH
16444: LD_VAR 0 8
16448: PPUSH
16449: CALL_OW 428
16453: PUSH
16454: LD_INT 0
16456: EQUAL
16457: IFFALSE 16482
// begin ComMoveXY ( unit , _x , _y ) ;
16459: LD_VAR 0 1
16463: PPUSH
16464: LD_VAR 0 7
16468: PPUSH
16469: LD_VAR 0 8
16473: PPUSH
16474: CALL_OW 111
// exit ;
16478: POP
16479: POP
16480: GO 16486
// end ; end ;
16482: GO 16371
16484: POP
16485: POP
// end ;
16486: LD_VAR 0 3
16490: RET
// export function ScanBase ( side , base_area ) ; begin
16491: LD_INT 0
16493: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16494: LD_ADDR_VAR 0 3
16498: PUSH
16499: LD_VAR 0 2
16503: PPUSH
16504: LD_INT 81
16506: PUSH
16507: LD_VAR 0 1
16511: PUSH
16512: EMPTY
16513: LIST
16514: LIST
16515: PPUSH
16516: CALL_OW 70
16520: ST_TO_ADDR
// end ;
16521: LD_VAR 0 3
16525: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16526: LD_INT 0
16528: PPUSH
16529: PPUSH
16530: PPUSH
16531: PPUSH
// result := false ;
16532: LD_ADDR_VAR 0 2
16536: PUSH
16537: LD_INT 0
16539: ST_TO_ADDR
// side := GetSide ( unit ) ;
16540: LD_ADDR_VAR 0 3
16544: PUSH
16545: LD_VAR 0 1
16549: PPUSH
16550: CALL_OW 255
16554: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16555: LD_ADDR_VAR 0 4
16559: PUSH
16560: LD_VAR 0 1
16564: PPUSH
16565: CALL_OW 248
16569: ST_TO_ADDR
// case nat of 1 :
16570: LD_VAR 0 4
16574: PUSH
16575: LD_INT 1
16577: DOUBLE
16578: EQUAL
16579: IFTRUE 16583
16581: GO 16594
16583: POP
// tech := tech_lassight ; 2 :
16584: LD_ADDR_VAR 0 5
16588: PUSH
16589: LD_INT 12
16591: ST_TO_ADDR
16592: GO 16633
16594: LD_INT 2
16596: DOUBLE
16597: EQUAL
16598: IFTRUE 16602
16600: GO 16613
16602: POP
// tech := tech_mortar ; 3 :
16603: LD_ADDR_VAR 0 5
16607: PUSH
16608: LD_INT 41
16610: ST_TO_ADDR
16611: GO 16633
16613: LD_INT 3
16615: DOUBLE
16616: EQUAL
16617: IFTRUE 16621
16619: GO 16632
16621: POP
// tech := tech_bazooka ; end ;
16622: LD_ADDR_VAR 0 5
16626: PUSH
16627: LD_INT 44
16629: ST_TO_ADDR
16630: GO 16633
16632: POP
// if Researched ( side , tech ) then
16633: LD_VAR 0 3
16637: PPUSH
16638: LD_VAR 0 5
16642: PPUSH
16643: CALL_OW 325
16647: IFFALSE 16674
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16649: LD_ADDR_VAR 0 2
16653: PUSH
16654: LD_INT 5
16656: PUSH
16657: LD_INT 8
16659: PUSH
16660: LD_INT 9
16662: PUSH
16663: EMPTY
16664: LIST
16665: LIST
16666: LIST
16667: PUSH
16668: LD_VAR 0 4
16672: ARRAY
16673: ST_TO_ADDR
// end ;
16674: LD_VAR 0 2
16678: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16679: LD_INT 0
16681: PPUSH
16682: PPUSH
16683: PPUSH
// if not mines then
16684: LD_VAR 0 2
16688: NOT
16689: IFFALSE 16693
// exit ;
16691: GO 16837
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16693: LD_ADDR_VAR 0 5
16697: PUSH
16698: LD_INT 81
16700: PUSH
16701: LD_VAR 0 1
16705: PUSH
16706: EMPTY
16707: LIST
16708: LIST
16709: PUSH
16710: LD_INT 3
16712: PUSH
16713: LD_INT 21
16715: PUSH
16716: LD_INT 3
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: PUSH
16723: EMPTY
16724: LIST
16725: LIST
16726: PUSH
16727: EMPTY
16728: LIST
16729: LIST
16730: PPUSH
16731: CALL_OW 69
16735: ST_TO_ADDR
// for i in mines do
16736: LD_ADDR_VAR 0 4
16740: PUSH
16741: LD_VAR 0 2
16745: PUSH
16746: FOR_IN
16747: IFFALSE 16835
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16749: LD_VAR 0 4
16753: PUSH
16754: LD_INT 1
16756: ARRAY
16757: PPUSH
16758: LD_VAR 0 4
16762: PUSH
16763: LD_INT 2
16765: ARRAY
16766: PPUSH
16767: CALL_OW 458
16771: NOT
16772: IFFALSE 16776
// continue ;
16774: GO 16746
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16776: LD_VAR 0 4
16780: PUSH
16781: LD_INT 1
16783: ARRAY
16784: PPUSH
16785: LD_VAR 0 4
16789: PUSH
16790: LD_INT 2
16792: ARRAY
16793: PPUSH
16794: CALL_OW 428
16798: PUSH
16799: LD_VAR 0 5
16803: IN
16804: IFFALSE 16833
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16806: LD_VAR 0 4
16810: PUSH
16811: LD_INT 1
16813: ARRAY
16814: PPUSH
16815: LD_VAR 0 4
16819: PUSH
16820: LD_INT 2
16822: ARRAY
16823: PPUSH
16824: LD_VAR 0 1
16828: PPUSH
16829: CALL_OW 456
// end ;
16833: GO 16746
16835: POP
16836: POP
// end ;
16837: LD_VAR 0 3
16841: RET
// export function Count ( array ) ; var i ; begin
16842: LD_INT 0
16844: PPUSH
16845: PPUSH
// result := 0 ;
16846: LD_ADDR_VAR 0 2
16850: PUSH
16851: LD_INT 0
16853: ST_TO_ADDR
// for i in array do
16854: LD_ADDR_VAR 0 3
16858: PUSH
16859: LD_VAR 0 1
16863: PUSH
16864: FOR_IN
16865: IFFALSE 16889
// if i then
16867: LD_VAR 0 3
16871: IFFALSE 16887
// result := result + 1 ;
16873: LD_ADDR_VAR 0 2
16877: PUSH
16878: LD_VAR 0 2
16882: PUSH
16883: LD_INT 1
16885: PLUS
16886: ST_TO_ADDR
16887: GO 16864
16889: POP
16890: POP
// end ;
16891: LD_VAR 0 2
16895: RET
// export function IsEmpty ( building ) ; begin
16896: LD_INT 0
16898: PPUSH
// if not building then
16899: LD_VAR 0 1
16903: NOT
16904: IFFALSE 16908
// exit ;
16906: GO 16951
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
16908: LD_ADDR_VAR 0 2
16912: PUSH
16913: LD_VAR 0 1
16917: PUSH
16918: LD_INT 22
16920: PUSH
16921: LD_VAR 0 1
16925: PPUSH
16926: CALL_OW 255
16930: PUSH
16931: EMPTY
16932: LIST
16933: LIST
16934: PUSH
16935: LD_INT 58
16937: PUSH
16938: EMPTY
16939: LIST
16940: PUSH
16941: EMPTY
16942: LIST
16943: LIST
16944: PPUSH
16945: CALL_OW 69
16949: IN
16950: ST_TO_ADDR
// end ;
16951: LD_VAR 0 2
16955: RET
// export function IsNotFull ( building ) ; begin
16956: LD_INT 0
16958: PPUSH
// if not building then
16959: LD_VAR 0 1
16963: NOT
16964: IFFALSE 16968
// exit ;
16966: GO 16987
// result := UnitsInside ( building ) < 6 ;
16968: LD_ADDR_VAR 0 2
16972: PUSH
16973: LD_VAR 0 1
16977: PPUSH
16978: CALL_OW 313
16982: PUSH
16983: LD_INT 6
16985: LESS
16986: ST_TO_ADDR
// end ;
16987: LD_VAR 0 2
16991: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
16992: LD_INT 0
16994: PPUSH
16995: PPUSH
16996: PPUSH
16997: PPUSH
// tmp := [ ] ;
16998: LD_ADDR_VAR 0 3
17002: PUSH
17003: EMPTY
17004: ST_TO_ADDR
// list := [ ] ;
17005: LD_ADDR_VAR 0 5
17009: PUSH
17010: EMPTY
17011: ST_TO_ADDR
// for i = 16 to 25 do
17012: LD_ADDR_VAR 0 4
17016: PUSH
17017: DOUBLE
17018: LD_INT 16
17020: DEC
17021: ST_TO_ADDR
17022: LD_INT 25
17024: PUSH
17025: FOR_TO
17026: IFFALSE 17099
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17028: LD_ADDR_VAR 0 3
17032: PUSH
17033: LD_VAR 0 3
17037: PUSH
17038: LD_INT 22
17040: PUSH
17041: LD_VAR 0 1
17045: PPUSH
17046: CALL_OW 255
17050: PUSH
17051: EMPTY
17052: LIST
17053: LIST
17054: PUSH
17055: LD_INT 91
17057: PUSH
17058: LD_VAR 0 1
17062: PUSH
17063: LD_INT 6
17065: PUSH
17066: EMPTY
17067: LIST
17068: LIST
17069: LIST
17070: PUSH
17071: LD_INT 30
17073: PUSH
17074: LD_VAR 0 4
17078: PUSH
17079: EMPTY
17080: LIST
17081: LIST
17082: PUSH
17083: EMPTY
17084: LIST
17085: LIST
17086: LIST
17087: PUSH
17088: EMPTY
17089: LIST
17090: PPUSH
17091: CALL_OW 69
17095: ADD
17096: ST_TO_ADDR
17097: GO 17025
17099: POP
17100: POP
// for i = 1 to tmp do
17101: LD_ADDR_VAR 0 4
17105: PUSH
17106: DOUBLE
17107: LD_INT 1
17109: DEC
17110: ST_TO_ADDR
17111: LD_VAR 0 3
17115: PUSH
17116: FOR_TO
17117: IFFALSE 17205
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17119: LD_ADDR_VAR 0 5
17123: PUSH
17124: LD_VAR 0 5
17128: PUSH
17129: LD_VAR 0 3
17133: PUSH
17134: LD_VAR 0 4
17138: ARRAY
17139: PPUSH
17140: CALL_OW 266
17144: PUSH
17145: LD_VAR 0 3
17149: PUSH
17150: LD_VAR 0 4
17154: ARRAY
17155: PPUSH
17156: CALL_OW 250
17160: PUSH
17161: LD_VAR 0 3
17165: PUSH
17166: LD_VAR 0 4
17170: ARRAY
17171: PPUSH
17172: CALL_OW 251
17176: PUSH
17177: LD_VAR 0 3
17181: PUSH
17182: LD_VAR 0 4
17186: ARRAY
17187: PPUSH
17188: CALL_OW 254
17192: PUSH
17193: EMPTY
17194: LIST
17195: LIST
17196: LIST
17197: LIST
17198: PUSH
17199: EMPTY
17200: LIST
17201: ADD
17202: ST_TO_ADDR
17203: GO 17116
17205: POP
17206: POP
// result := list ;
17207: LD_ADDR_VAR 0 2
17211: PUSH
17212: LD_VAR 0 5
17216: ST_TO_ADDR
// end ;
17217: LD_VAR 0 2
17221: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17222: LD_INT 0
17224: PPUSH
17225: PPUSH
17226: PPUSH
17227: PPUSH
17228: PPUSH
17229: PPUSH
17230: PPUSH
// if not factory then
17231: LD_VAR 0 1
17235: NOT
17236: IFFALSE 17240
// exit ;
17238: GO 17833
// if control = control_apeman then
17240: LD_VAR 0 4
17244: PUSH
17245: LD_INT 5
17247: EQUAL
17248: IFFALSE 17357
// begin tmp := UnitsInside ( factory ) ;
17250: LD_ADDR_VAR 0 8
17254: PUSH
17255: LD_VAR 0 1
17259: PPUSH
17260: CALL_OW 313
17264: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17265: LD_VAR 0 8
17269: PPUSH
17270: LD_INT 25
17272: PUSH
17273: LD_INT 12
17275: PUSH
17276: EMPTY
17277: LIST
17278: LIST
17279: PPUSH
17280: CALL_OW 72
17284: NOT
17285: IFFALSE 17295
// control := control_manual ;
17287: LD_ADDR_VAR 0 4
17291: PUSH
17292: LD_INT 1
17294: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17295: LD_ADDR_VAR 0 8
17299: PUSH
17300: LD_VAR 0 1
17304: PPUSH
17305: CALL 16992 0 1
17309: ST_TO_ADDR
// if tmp then
17310: LD_VAR 0 8
17314: IFFALSE 17357
// begin for i in tmp do
17316: LD_ADDR_VAR 0 7
17320: PUSH
17321: LD_VAR 0 8
17325: PUSH
17326: FOR_IN
17327: IFFALSE 17355
// if i [ 1 ] = b_ext_radio then
17329: LD_VAR 0 7
17333: PUSH
17334: LD_INT 1
17336: ARRAY
17337: PUSH
17338: LD_INT 22
17340: EQUAL
17341: IFFALSE 17353
// begin control := control_remote ;
17343: LD_ADDR_VAR 0 4
17347: PUSH
17348: LD_INT 2
17350: ST_TO_ADDR
// break ;
17351: GO 17355
// end ;
17353: GO 17326
17355: POP
17356: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17357: LD_VAR 0 1
17361: PPUSH
17362: LD_VAR 0 2
17366: PPUSH
17367: LD_VAR 0 3
17371: PPUSH
17372: LD_VAR 0 4
17376: PPUSH
17377: LD_VAR 0 5
17381: PPUSH
17382: CALL_OW 448
17386: IFFALSE 17421
// begin result := [ chassis , engine , control , weapon ] ;
17388: LD_ADDR_VAR 0 6
17392: PUSH
17393: LD_VAR 0 2
17397: PUSH
17398: LD_VAR 0 3
17402: PUSH
17403: LD_VAR 0 4
17407: PUSH
17408: LD_VAR 0 5
17412: PUSH
17413: EMPTY
17414: LIST
17415: LIST
17416: LIST
17417: LIST
17418: ST_TO_ADDR
// exit ;
17419: GO 17833
// end ; _chassis := AvailableChassisList ( factory ) ;
17421: LD_ADDR_VAR 0 9
17425: PUSH
17426: LD_VAR 0 1
17430: PPUSH
17431: CALL_OW 475
17435: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17436: LD_ADDR_VAR 0 11
17440: PUSH
17441: LD_VAR 0 1
17445: PPUSH
17446: CALL_OW 476
17450: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17451: LD_ADDR_VAR 0 12
17455: PUSH
17456: LD_VAR 0 1
17460: PPUSH
17461: CALL_OW 477
17465: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17466: LD_ADDR_VAR 0 10
17470: PUSH
17471: LD_VAR 0 1
17475: PPUSH
17476: CALL_OW 478
17480: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17481: LD_VAR 0 9
17485: NOT
17486: PUSH
17487: LD_VAR 0 11
17491: NOT
17492: OR
17493: PUSH
17494: LD_VAR 0 12
17498: NOT
17499: OR
17500: PUSH
17501: LD_VAR 0 10
17505: NOT
17506: OR
17507: IFFALSE 17542
// begin result := [ chassis , engine , control , weapon ] ;
17509: LD_ADDR_VAR 0 6
17513: PUSH
17514: LD_VAR 0 2
17518: PUSH
17519: LD_VAR 0 3
17523: PUSH
17524: LD_VAR 0 4
17528: PUSH
17529: LD_VAR 0 5
17533: PUSH
17534: EMPTY
17535: LIST
17536: LIST
17537: LIST
17538: LIST
17539: ST_TO_ADDR
// exit ;
17540: GO 17833
// end ; if not chassis in _chassis then
17542: LD_VAR 0 2
17546: PUSH
17547: LD_VAR 0 9
17551: IN
17552: NOT
17553: IFFALSE 17579
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17555: LD_ADDR_VAR 0 2
17559: PUSH
17560: LD_VAR 0 9
17564: PUSH
17565: LD_INT 1
17567: PPUSH
17568: LD_VAR 0 9
17572: PPUSH
17573: CALL_OW 12
17577: ARRAY
17578: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17579: LD_VAR 0 2
17583: PPUSH
17584: LD_VAR 0 3
17588: PPUSH
17589: CALL 17838 0 2
17593: NOT
17594: IFFALSE 17653
// repeat engine := _engine [ 1 ] ;
17596: LD_ADDR_VAR 0 3
17600: PUSH
17601: LD_VAR 0 11
17605: PUSH
17606: LD_INT 1
17608: ARRAY
17609: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17610: LD_ADDR_VAR 0 11
17614: PUSH
17615: LD_VAR 0 11
17619: PPUSH
17620: LD_INT 1
17622: PPUSH
17623: CALL_OW 3
17627: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17628: LD_VAR 0 2
17632: PPUSH
17633: LD_VAR 0 3
17637: PPUSH
17638: CALL 17838 0 2
17642: PUSH
17643: LD_VAR 0 11
17647: PUSH
17648: EMPTY
17649: EQUAL
17650: OR
17651: IFFALSE 17596
// if not control in _control then
17653: LD_VAR 0 4
17657: PUSH
17658: LD_VAR 0 12
17662: IN
17663: NOT
17664: IFFALSE 17690
// control := _control [ rand ( 1 , _control ) ] ;
17666: LD_ADDR_VAR 0 4
17670: PUSH
17671: LD_VAR 0 12
17675: PUSH
17676: LD_INT 1
17678: PPUSH
17679: LD_VAR 0 12
17683: PPUSH
17684: CALL_OW 12
17688: ARRAY
17689: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17690: LD_VAR 0 2
17694: PPUSH
17695: LD_VAR 0 5
17699: PPUSH
17700: CALL 18058 0 2
17704: NOT
17705: IFFALSE 17764
// repeat weapon := _weapon [ 1 ] ;
17707: LD_ADDR_VAR 0 5
17711: PUSH
17712: LD_VAR 0 10
17716: PUSH
17717: LD_INT 1
17719: ARRAY
17720: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17721: LD_ADDR_VAR 0 10
17725: PUSH
17726: LD_VAR 0 10
17730: PPUSH
17731: LD_INT 1
17733: PPUSH
17734: CALL_OW 3
17738: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17739: LD_VAR 0 2
17743: PPUSH
17744: LD_VAR 0 5
17748: PPUSH
17749: CALL 18058 0 2
17753: PUSH
17754: LD_VAR 0 10
17758: PUSH
17759: EMPTY
17760: EQUAL
17761: OR
17762: IFFALSE 17707
// result := [ ] ;
17764: LD_ADDR_VAR 0 6
17768: PUSH
17769: EMPTY
17770: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17771: LD_VAR 0 1
17775: PPUSH
17776: LD_VAR 0 2
17780: PPUSH
17781: LD_VAR 0 3
17785: PPUSH
17786: LD_VAR 0 4
17790: PPUSH
17791: LD_VAR 0 5
17795: PPUSH
17796: CALL_OW 448
17800: IFFALSE 17833
// result := [ chassis , engine , control , weapon ] ;
17802: LD_ADDR_VAR 0 6
17806: PUSH
17807: LD_VAR 0 2
17811: PUSH
17812: LD_VAR 0 3
17816: PUSH
17817: LD_VAR 0 4
17821: PUSH
17822: LD_VAR 0 5
17826: PUSH
17827: EMPTY
17828: LIST
17829: LIST
17830: LIST
17831: LIST
17832: ST_TO_ADDR
// end ;
17833: LD_VAR 0 6
17837: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
17838: LD_INT 0
17840: PPUSH
// if not chassis or not engine then
17841: LD_VAR 0 1
17845: NOT
17846: PUSH
17847: LD_VAR 0 2
17851: NOT
17852: OR
17853: IFFALSE 17857
// exit ;
17855: GO 18053
// case engine of engine_solar :
17857: LD_VAR 0 2
17861: PUSH
17862: LD_INT 2
17864: DOUBLE
17865: EQUAL
17866: IFTRUE 17870
17868: GO 17908
17870: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
17871: LD_ADDR_VAR 0 3
17875: PUSH
17876: LD_INT 11
17878: PUSH
17879: LD_INT 12
17881: PUSH
17882: LD_INT 13
17884: PUSH
17885: LD_INT 14
17887: PUSH
17888: LD_INT 1
17890: PUSH
17891: LD_INT 2
17893: PUSH
17894: LD_INT 3
17896: PUSH
17897: EMPTY
17898: LIST
17899: LIST
17900: LIST
17901: LIST
17902: LIST
17903: LIST
17904: LIST
17905: ST_TO_ADDR
17906: GO 18037
17908: LD_INT 1
17910: DOUBLE
17911: EQUAL
17912: IFTRUE 17916
17914: GO 17978
17916: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
17917: LD_ADDR_VAR 0 3
17921: PUSH
17922: LD_INT 11
17924: PUSH
17925: LD_INT 12
17927: PUSH
17928: LD_INT 13
17930: PUSH
17931: LD_INT 14
17933: PUSH
17934: LD_INT 1
17936: PUSH
17937: LD_INT 2
17939: PUSH
17940: LD_INT 3
17942: PUSH
17943: LD_INT 4
17945: PUSH
17946: LD_INT 5
17948: PUSH
17949: LD_INT 21
17951: PUSH
17952: LD_INT 23
17954: PUSH
17955: LD_INT 22
17957: PUSH
17958: LD_INT 24
17960: PUSH
17961: EMPTY
17962: LIST
17963: LIST
17964: LIST
17965: LIST
17966: LIST
17967: LIST
17968: LIST
17969: LIST
17970: LIST
17971: LIST
17972: LIST
17973: LIST
17974: LIST
17975: ST_TO_ADDR
17976: GO 18037
17978: LD_INT 3
17980: DOUBLE
17981: EQUAL
17982: IFTRUE 17986
17984: GO 18036
17986: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17987: LD_ADDR_VAR 0 3
17991: PUSH
17992: LD_INT 13
17994: PUSH
17995: LD_INT 14
17997: PUSH
17998: LD_INT 2
18000: PUSH
18001: LD_INT 3
18003: PUSH
18004: LD_INT 4
18006: PUSH
18007: LD_INT 5
18009: PUSH
18010: LD_INT 21
18012: PUSH
18013: LD_INT 22
18015: PUSH
18016: LD_INT 23
18018: PUSH
18019: LD_INT 24
18021: PUSH
18022: EMPTY
18023: LIST
18024: LIST
18025: LIST
18026: LIST
18027: LIST
18028: LIST
18029: LIST
18030: LIST
18031: LIST
18032: LIST
18033: ST_TO_ADDR
18034: GO 18037
18036: POP
// result := ( chassis in result ) ;
18037: LD_ADDR_VAR 0 3
18041: PUSH
18042: LD_VAR 0 1
18046: PUSH
18047: LD_VAR 0 3
18051: IN
18052: ST_TO_ADDR
// end ;
18053: LD_VAR 0 3
18057: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18058: LD_INT 0
18060: PPUSH
// if not chassis or not weapon then
18061: LD_VAR 0 1
18065: NOT
18066: PUSH
18067: LD_VAR 0 2
18071: NOT
18072: OR
18073: IFFALSE 18077
// exit ;
18075: GO 19139
// case weapon of us_machine_gun :
18077: LD_VAR 0 2
18081: PUSH
18082: LD_INT 2
18084: DOUBLE
18085: EQUAL
18086: IFTRUE 18090
18088: GO 18120
18090: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18091: LD_ADDR_VAR 0 3
18095: PUSH
18096: LD_INT 1
18098: PUSH
18099: LD_INT 2
18101: PUSH
18102: LD_INT 3
18104: PUSH
18105: LD_INT 4
18107: PUSH
18108: LD_INT 5
18110: PUSH
18111: EMPTY
18112: LIST
18113: LIST
18114: LIST
18115: LIST
18116: LIST
18117: ST_TO_ADDR
18118: GO 19123
18120: LD_INT 3
18122: DOUBLE
18123: EQUAL
18124: IFTRUE 18128
18126: GO 18158
18128: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18129: LD_ADDR_VAR 0 3
18133: PUSH
18134: LD_INT 1
18136: PUSH
18137: LD_INT 2
18139: PUSH
18140: LD_INT 3
18142: PUSH
18143: LD_INT 4
18145: PUSH
18146: LD_INT 5
18148: PUSH
18149: EMPTY
18150: LIST
18151: LIST
18152: LIST
18153: LIST
18154: LIST
18155: ST_TO_ADDR
18156: GO 19123
18158: LD_INT 11
18160: DOUBLE
18161: EQUAL
18162: IFTRUE 18166
18164: GO 18196
18166: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18167: LD_ADDR_VAR 0 3
18171: PUSH
18172: LD_INT 1
18174: PUSH
18175: LD_INT 2
18177: PUSH
18178: LD_INT 3
18180: PUSH
18181: LD_INT 4
18183: PUSH
18184: LD_INT 5
18186: PUSH
18187: EMPTY
18188: LIST
18189: LIST
18190: LIST
18191: LIST
18192: LIST
18193: ST_TO_ADDR
18194: GO 19123
18196: LD_INT 4
18198: DOUBLE
18199: EQUAL
18200: IFTRUE 18204
18202: GO 18230
18204: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18205: LD_ADDR_VAR 0 3
18209: PUSH
18210: LD_INT 2
18212: PUSH
18213: LD_INT 3
18215: PUSH
18216: LD_INT 4
18218: PUSH
18219: LD_INT 5
18221: PUSH
18222: EMPTY
18223: LIST
18224: LIST
18225: LIST
18226: LIST
18227: ST_TO_ADDR
18228: GO 19123
18230: LD_INT 5
18232: DOUBLE
18233: EQUAL
18234: IFTRUE 18238
18236: GO 18264
18238: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18239: LD_ADDR_VAR 0 3
18243: PUSH
18244: LD_INT 2
18246: PUSH
18247: LD_INT 3
18249: PUSH
18250: LD_INT 4
18252: PUSH
18253: LD_INT 5
18255: PUSH
18256: EMPTY
18257: LIST
18258: LIST
18259: LIST
18260: LIST
18261: ST_TO_ADDR
18262: GO 19123
18264: LD_INT 9
18266: DOUBLE
18267: EQUAL
18268: IFTRUE 18272
18270: GO 18298
18272: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18273: LD_ADDR_VAR 0 3
18277: PUSH
18278: LD_INT 2
18280: PUSH
18281: LD_INT 3
18283: PUSH
18284: LD_INT 4
18286: PUSH
18287: LD_INT 5
18289: PUSH
18290: EMPTY
18291: LIST
18292: LIST
18293: LIST
18294: LIST
18295: ST_TO_ADDR
18296: GO 19123
18298: LD_INT 7
18300: DOUBLE
18301: EQUAL
18302: IFTRUE 18306
18304: GO 18332
18306: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18307: LD_ADDR_VAR 0 3
18311: PUSH
18312: LD_INT 2
18314: PUSH
18315: LD_INT 3
18317: PUSH
18318: LD_INT 4
18320: PUSH
18321: LD_INT 5
18323: PUSH
18324: EMPTY
18325: LIST
18326: LIST
18327: LIST
18328: LIST
18329: ST_TO_ADDR
18330: GO 19123
18332: LD_INT 12
18334: DOUBLE
18335: EQUAL
18336: IFTRUE 18340
18338: GO 18366
18340: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18341: LD_ADDR_VAR 0 3
18345: PUSH
18346: LD_INT 2
18348: PUSH
18349: LD_INT 3
18351: PUSH
18352: LD_INT 4
18354: PUSH
18355: LD_INT 5
18357: PUSH
18358: EMPTY
18359: LIST
18360: LIST
18361: LIST
18362: LIST
18363: ST_TO_ADDR
18364: GO 19123
18366: LD_INT 13
18368: DOUBLE
18369: EQUAL
18370: IFTRUE 18374
18372: GO 18400
18374: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18375: LD_ADDR_VAR 0 3
18379: PUSH
18380: LD_INT 2
18382: PUSH
18383: LD_INT 3
18385: PUSH
18386: LD_INT 4
18388: PUSH
18389: LD_INT 5
18391: PUSH
18392: EMPTY
18393: LIST
18394: LIST
18395: LIST
18396: LIST
18397: ST_TO_ADDR
18398: GO 19123
18400: LD_INT 14
18402: DOUBLE
18403: EQUAL
18404: IFTRUE 18408
18406: GO 18426
18408: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18409: LD_ADDR_VAR 0 3
18413: PUSH
18414: LD_INT 4
18416: PUSH
18417: LD_INT 5
18419: PUSH
18420: EMPTY
18421: LIST
18422: LIST
18423: ST_TO_ADDR
18424: GO 19123
18426: LD_INT 6
18428: DOUBLE
18429: EQUAL
18430: IFTRUE 18434
18432: GO 18452
18434: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18435: LD_ADDR_VAR 0 3
18439: PUSH
18440: LD_INT 4
18442: PUSH
18443: LD_INT 5
18445: PUSH
18446: EMPTY
18447: LIST
18448: LIST
18449: ST_TO_ADDR
18450: GO 19123
18452: LD_INT 10
18454: DOUBLE
18455: EQUAL
18456: IFTRUE 18460
18458: GO 18478
18460: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18461: LD_ADDR_VAR 0 3
18465: PUSH
18466: LD_INT 4
18468: PUSH
18469: LD_INT 5
18471: PUSH
18472: EMPTY
18473: LIST
18474: LIST
18475: ST_TO_ADDR
18476: GO 19123
18478: LD_INT 22
18480: DOUBLE
18481: EQUAL
18482: IFTRUE 18486
18484: GO 18512
18486: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18487: LD_ADDR_VAR 0 3
18491: PUSH
18492: LD_INT 11
18494: PUSH
18495: LD_INT 12
18497: PUSH
18498: LD_INT 13
18500: PUSH
18501: LD_INT 14
18503: PUSH
18504: EMPTY
18505: LIST
18506: LIST
18507: LIST
18508: LIST
18509: ST_TO_ADDR
18510: GO 19123
18512: LD_INT 23
18514: DOUBLE
18515: EQUAL
18516: IFTRUE 18520
18518: GO 18546
18520: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18521: LD_ADDR_VAR 0 3
18525: PUSH
18526: LD_INT 11
18528: PUSH
18529: LD_INT 12
18531: PUSH
18532: LD_INT 13
18534: PUSH
18535: LD_INT 14
18537: PUSH
18538: EMPTY
18539: LIST
18540: LIST
18541: LIST
18542: LIST
18543: ST_TO_ADDR
18544: GO 19123
18546: LD_INT 24
18548: DOUBLE
18549: EQUAL
18550: IFTRUE 18554
18552: GO 18580
18554: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18555: LD_ADDR_VAR 0 3
18559: PUSH
18560: LD_INT 11
18562: PUSH
18563: LD_INT 12
18565: PUSH
18566: LD_INT 13
18568: PUSH
18569: LD_INT 14
18571: PUSH
18572: EMPTY
18573: LIST
18574: LIST
18575: LIST
18576: LIST
18577: ST_TO_ADDR
18578: GO 19123
18580: LD_INT 30
18582: DOUBLE
18583: EQUAL
18584: IFTRUE 18588
18586: GO 18614
18588: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18589: LD_ADDR_VAR 0 3
18593: PUSH
18594: LD_INT 11
18596: PUSH
18597: LD_INT 12
18599: PUSH
18600: LD_INT 13
18602: PUSH
18603: LD_INT 14
18605: PUSH
18606: EMPTY
18607: LIST
18608: LIST
18609: LIST
18610: LIST
18611: ST_TO_ADDR
18612: GO 19123
18614: LD_INT 25
18616: DOUBLE
18617: EQUAL
18618: IFTRUE 18622
18620: GO 18640
18622: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18623: LD_ADDR_VAR 0 3
18627: PUSH
18628: LD_INT 13
18630: PUSH
18631: LD_INT 14
18633: PUSH
18634: EMPTY
18635: LIST
18636: LIST
18637: ST_TO_ADDR
18638: GO 19123
18640: LD_INT 27
18642: DOUBLE
18643: EQUAL
18644: IFTRUE 18648
18646: GO 18666
18648: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
18649: LD_ADDR_VAR 0 3
18653: PUSH
18654: LD_INT 13
18656: PUSH
18657: LD_INT 14
18659: PUSH
18660: EMPTY
18661: LIST
18662: LIST
18663: ST_TO_ADDR
18664: GO 19123
18666: LD_EXP 108
18670: DOUBLE
18671: EQUAL
18672: IFTRUE 18676
18674: GO 18702
18676: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18677: LD_ADDR_VAR 0 3
18681: PUSH
18682: LD_INT 11
18684: PUSH
18685: LD_INT 12
18687: PUSH
18688: LD_INT 13
18690: PUSH
18691: LD_INT 14
18693: PUSH
18694: EMPTY
18695: LIST
18696: LIST
18697: LIST
18698: LIST
18699: ST_TO_ADDR
18700: GO 19123
18702: LD_INT 28
18704: DOUBLE
18705: EQUAL
18706: IFTRUE 18710
18708: GO 18728
18710: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18711: LD_ADDR_VAR 0 3
18715: PUSH
18716: LD_INT 13
18718: PUSH
18719: LD_INT 14
18721: PUSH
18722: EMPTY
18723: LIST
18724: LIST
18725: ST_TO_ADDR
18726: GO 19123
18728: LD_INT 29
18730: DOUBLE
18731: EQUAL
18732: IFTRUE 18736
18734: GO 18754
18736: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18737: LD_ADDR_VAR 0 3
18741: PUSH
18742: LD_INT 13
18744: PUSH
18745: LD_INT 14
18747: PUSH
18748: EMPTY
18749: LIST
18750: LIST
18751: ST_TO_ADDR
18752: GO 19123
18754: LD_INT 31
18756: DOUBLE
18757: EQUAL
18758: IFTRUE 18762
18760: GO 18780
18762: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18763: LD_ADDR_VAR 0 3
18767: PUSH
18768: LD_INT 13
18770: PUSH
18771: LD_INT 14
18773: PUSH
18774: EMPTY
18775: LIST
18776: LIST
18777: ST_TO_ADDR
18778: GO 19123
18780: LD_INT 26
18782: DOUBLE
18783: EQUAL
18784: IFTRUE 18788
18786: GO 18806
18788: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18789: LD_ADDR_VAR 0 3
18793: PUSH
18794: LD_INT 13
18796: PUSH
18797: LD_INT 14
18799: PUSH
18800: EMPTY
18801: LIST
18802: LIST
18803: ST_TO_ADDR
18804: GO 19123
18806: LD_INT 42
18808: DOUBLE
18809: EQUAL
18810: IFTRUE 18814
18812: GO 18840
18814: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
18815: LD_ADDR_VAR 0 3
18819: PUSH
18820: LD_INT 21
18822: PUSH
18823: LD_INT 22
18825: PUSH
18826: LD_INT 23
18828: PUSH
18829: LD_INT 24
18831: PUSH
18832: EMPTY
18833: LIST
18834: LIST
18835: LIST
18836: LIST
18837: ST_TO_ADDR
18838: GO 19123
18840: LD_INT 43
18842: DOUBLE
18843: EQUAL
18844: IFTRUE 18848
18846: GO 18874
18848: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
18849: LD_ADDR_VAR 0 3
18853: PUSH
18854: LD_INT 21
18856: PUSH
18857: LD_INT 22
18859: PUSH
18860: LD_INT 23
18862: PUSH
18863: LD_INT 24
18865: PUSH
18866: EMPTY
18867: LIST
18868: LIST
18869: LIST
18870: LIST
18871: ST_TO_ADDR
18872: GO 19123
18874: LD_INT 44
18876: DOUBLE
18877: EQUAL
18878: IFTRUE 18882
18880: GO 18908
18882: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
18883: LD_ADDR_VAR 0 3
18887: PUSH
18888: LD_INT 21
18890: PUSH
18891: LD_INT 22
18893: PUSH
18894: LD_INT 23
18896: PUSH
18897: LD_INT 24
18899: PUSH
18900: EMPTY
18901: LIST
18902: LIST
18903: LIST
18904: LIST
18905: ST_TO_ADDR
18906: GO 19123
18908: LD_INT 45
18910: DOUBLE
18911: EQUAL
18912: IFTRUE 18916
18914: GO 18942
18916: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
18917: LD_ADDR_VAR 0 3
18921: PUSH
18922: LD_INT 21
18924: PUSH
18925: LD_INT 22
18927: PUSH
18928: LD_INT 23
18930: PUSH
18931: LD_INT 24
18933: PUSH
18934: EMPTY
18935: LIST
18936: LIST
18937: LIST
18938: LIST
18939: ST_TO_ADDR
18940: GO 19123
18942: LD_INT 49
18944: DOUBLE
18945: EQUAL
18946: IFTRUE 18950
18948: GO 18976
18950: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
18951: LD_ADDR_VAR 0 3
18955: PUSH
18956: LD_INT 21
18958: PUSH
18959: LD_INT 22
18961: PUSH
18962: LD_INT 23
18964: PUSH
18965: LD_INT 24
18967: PUSH
18968: EMPTY
18969: LIST
18970: LIST
18971: LIST
18972: LIST
18973: ST_TO_ADDR
18974: GO 19123
18976: LD_INT 51
18978: DOUBLE
18979: EQUAL
18980: IFTRUE 18984
18982: GO 19010
18984: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
18985: LD_ADDR_VAR 0 3
18989: PUSH
18990: LD_INT 21
18992: PUSH
18993: LD_INT 22
18995: PUSH
18996: LD_INT 23
18998: PUSH
18999: LD_INT 24
19001: PUSH
19002: EMPTY
19003: LIST
19004: LIST
19005: LIST
19006: LIST
19007: ST_TO_ADDR
19008: GO 19123
19010: LD_INT 52
19012: DOUBLE
19013: EQUAL
19014: IFTRUE 19018
19016: GO 19044
19018: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19019: LD_ADDR_VAR 0 3
19023: PUSH
19024: LD_INT 21
19026: PUSH
19027: LD_INT 22
19029: PUSH
19030: LD_INT 23
19032: PUSH
19033: LD_INT 24
19035: PUSH
19036: EMPTY
19037: LIST
19038: LIST
19039: LIST
19040: LIST
19041: ST_TO_ADDR
19042: GO 19123
19044: LD_INT 53
19046: DOUBLE
19047: EQUAL
19048: IFTRUE 19052
19050: GO 19070
19052: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19053: LD_ADDR_VAR 0 3
19057: PUSH
19058: LD_INT 23
19060: PUSH
19061: LD_INT 24
19063: PUSH
19064: EMPTY
19065: LIST
19066: LIST
19067: ST_TO_ADDR
19068: GO 19123
19070: LD_INT 46
19072: DOUBLE
19073: EQUAL
19074: IFTRUE 19078
19076: GO 19096
19078: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19079: LD_ADDR_VAR 0 3
19083: PUSH
19084: LD_INT 23
19086: PUSH
19087: LD_INT 24
19089: PUSH
19090: EMPTY
19091: LIST
19092: LIST
19093: ST_TO_ADDR
19094: GO 19123
19096: LD_INT 47
19098: DOUBLE
19099: EQUAL
19100: IFTRUE 19104
19102: GO 19122
19104: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19105: LD_ADDR_VAR 0 3
19109: PUSH
19110: LD_INT 23
19112: PUSH
19113: LD_INT 24
19115: PUSH
19116: EMPTY
19117: LIST
19118: LIST
19119: ST_TO_ADDR
19120: GO 19123
19122: POP
// result := ( chassis in result ) ;
19123: LD_ADDR_VAR 0 3
19127: PUSH
19128: LD_VAR 0 1
19132: PUSH
19133: LD_VAR 0 3
19137: IN
19138: ST_TO_ADDR
// end ;
19139: LD_VAR 0 3
19143: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19144: LD_INT 0
19146: PPUSH
19147: PPUSH
19148: PPUSH
19149: PPUSH
19150: PPUSH
19151: PPUSH
19152: PPUSH
// result := array ;
19153: LD_ADDR_VAR 0 5
19157: PUSH
19158: LD_VAR 0 1
19162: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19163: LD_VAR 0 1
19167: NOT
19168: PUSH
19169: LD_VAR 0 2
19173: NOT
19174: OR
19175: PUSH
19176: LD_VAR 0 3
19180: NOT
19181: OR
19182: PUSH
19183: LD_VAR 0 2
19187: PUSH
19188: LD_VAR 0 1
19192: GREATER
19193: OR
19194: PUSH
19195: LD_VAR 0 3
19199: PUSH
19200: LD_VAR 0 1
19204: GREATER
19205: OR
19206: IFFALSE 19210
// exit ;
19208: GO 19506
// if direction then
19210: LD_VAR 0 4
19214: IFFALSE 19278
// begin d := 1 ;
19216: LD_ADDR_VAR 0 9
19220: PUSH
19221: LD_INT 1
19223: ST_TO_ADDR
// if i_from > i_to then
19224: LD_VAR 0 2
19228: PUSH
19229: LD_VAR 0 3
19233: GREATER
19234: IFFALSE 19260
// length := ( array - i_from ) + i_to else
19236: LD_ADDR_VAR 0 11
19240: PUSH
19241: LD_VAR 0 1
19245: PUSH
19246: LD_VAR 0 2
19250: MINUS
19251: PUSH
19252: LD_VAR 0 3
19256: PLUS
19257: ST_TO_ADDR
19258: GO 19276
// length := i_to - i_from ;
19260: LD_ADDR_VAR 0 11
19264: PUSH
19265: LD_VAR 0 3
19269: PUSH
19270: LD_VAR 0 2
19274: MINUS
19275: ST_TO_ADDR
// end else
19276: GO 19339
// begin d := - 1 ;
19278: LD_ADDR_VAR 0 9
19282: PUSH
19283: LD_INT 1
19285: NEG
19286: ST_TO_ADDR
// if i_from > i_to then
19287: LD_VAR 0 2
19291: PUSH
19292: LD_VAR 0 3
19296: GREATER
19297: IFFALSE 19317
// length := i_from - i_to else
19299: LD_ADDR_VAR 0 11
19303: PUSH
19304: LD_VAR 0 2
19308: PUSH
19309: LD_VAR 0 3
19313: MINUS
19314: ST_TO_ADDR
19315: GO 19339
// length := ( array - i_to ) + i_from ;
19317: LD_ADDR_VAR 0 11
19321: PUSH
19322: LD_VAR 0 1
19326: PUSH
19327: LD_VAR 0 3
19331: MINUS
19332: PUSH
19333: LD_VAR 0 2
19337: PLUS
19338: ST_TO_ADDR
// end ; if not length then
19339: LD_VAR 0 11
19343: NOT
19344: IFFALSE 19348
// exit ;
19346: GO 19506
// tmp := array ;
19348: LD_ADDR_VAR 0 10
19352: PUSH
19353: LD_VAR 0 1
19357: ST_TO_ADDR
// for i = 1 to length do
19358: LD_ADDR_VAR 0 6
19362: PUSH
19363: DOUBLE
19364: LD_INT 1
19366: DEC
19367: ST_TO_ADDR
19368: LD_VAR 0 11
19372: PUSH
19373: FOR_TO
19374: IFFALSE 19494
// begin for j = 1 to array do
19376: LD_ADDR_VAR 0 7
19380: PUSH
19381: DOUBLE
19382: LD_INT 1
19384: DEC
19385: ST_TO_ADDR
19386: LD_VAR 0 1
19390: PUSH
19391: FOR_TO
19392: IFFALSE 19480
// begin k := j + d ;
19394: LD_ADDR_VAR 0 8
19398: PUSH
19399: LD_VAR 0 7
19403: PUSH
19404: LD_VAR 0 9
19408: PLUS
19409: ST_TO_ADDR
// if k > array then
19410: LD_VAR 0 8
19414: PUSH
19415: LD_VAR 0 1
19419: GREATER
19420: IFFALSE 19430
// k := 1 ;
19422: LD_ADDR_VAR 0 8
19426: PUSH
19427: LD_INT 1
19429: ST_TO_ADDR
// if not k then
19430: LD_VAR 0 8
19434: NOT
19435: IFFALSE 19447
// k := array ;
19437: LD_ADDR_VAR 0 8
19441: PUSH
19442: LD_VAR 0 1
19446: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19447: LD_ADDR_VAR 0 10
19451: PUSH
19452: LD_VAR 0 10
19456: PPUSH
19457: LD_VAR 0 8
19461: PPUSH
19462: LD_VAR 0 1
19466: PUSH
19467: LD_VAR 0 7
19471: ARRAY
19472: PPUSH
19473: CALL_OW 1
19477: ST_TO_ADDR
// end ;
19478: GO 19391
19480: POP
19481: POP
// array := tmp ;
19482: LD_ADDR_VAR 0 1
19486: PUSH
19487: LD_VAR 0 10
19491: ST_TO_ADDR
// end ;
19492: GO 19373
19494: POP
19495: POP
// result := array ;
19496: LD_ADDR_VAR 0 5
19500: PUSH
19501: LD_VAR 0 1
19505: ST_TO_ADDR
// end ;
19506: LD_VAR 0 5
19510: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19511: LD_INT 0
19513: PPUSH
19514: PPUSH
// result := 0 ;
19515: LD_ADDR_VAR 0 3
19519: PUSH
19520: LD_INT 0
19522: ST_TO_ADDR
// if not array or not value in array then
19523: LD_VAR 0 1
19527: NOT
19528: PUSH
19529: LD_VAR 0 2
19533: PUSH
19534: LD_VAR 0 1
19538: IN
19539: NOT
19540: OR
19541: IFFALSE 19545
// exit ;
19543: GO 19599
// for i = 1 to array do
19545: LD_ADDR_VAR 0 4
19549: PUSH
19550: DOUBLE
19551: LD_INT 1
19553: DEC
19554: ST_TO_ADDR
19555: LD_VAR 0 1
19559: PUSH
19560: FOR_TO
19561: IFFALSE 19597
// if value = array [ i ] then
19563: LD_VAR 0 2
19567: PUSH
19568: LD_VAR 0 1
19572: PUSH
19573: LD_VAR 0 4
19577: ARRAY
19578: EQUAL
19579: IFFALSE 19595
// begin result := i ;
19581: LD_ADDR_VAR 0 3
19585: PUSH
19586: LD_VAR 0 4
19590: ST_TO_ADDR
// exit ;
19591: POP
19592: POP
19593: GO 19599
// end ;
19595: GO 19560
19597: POP
19598: POP
// end ;
19599: LD_VAR 0 3
19603: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19604: LD_INT 0
19606: PPUSH
// vc_chassis := chassis ;
19607: LD_ADDR_OWVAR 37
19611: PUSH
19612: LD_VAR 0 1
19616: ST_TO_ADDR
// vc_engine := engine ;
19617: LD_ADDR_OWVAR 39
19621: PUSH
19622: LD_VAR 0 2
19626: ST_TO_ADDR
// vc_control := control ;
19627: LD_ADDR_OWVAR 38
19631: PUSH
19632: LD_VAR 0 3
19636: ST_TO_ADDR
// vc_weapon := weapon ;
19637: LD_ADDR_OWVAR 40
19641: PUSH
19642: LD_VAR 0 4
19646: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19647: LD_ADDR_OWVAR 41
19651: PUSH
19652: LD_VAR 0 5
19656: ST_TO_ADDR
// end ;
19657: LD_VAR 0 6
19661: RET
// export function WantPlant ( unit ) ; var task ; begin
19662: LD_INT 0
19664: PPUSH
19665: PPUSH
// result := false ;
19666: LD_ADDR_VAR 0 2
19670: PUSH
19671: LD_INT 0
19673: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19674: LD_ADDR_VAR 0 3
19678: PUSH
19679: LD_VAR 0 1
19683: PPUSH
19684: CALL_OW 437
19688: ST_TO_ADDR
// if task then
19689: LD_VAR 0 3
19693: IFFALSE 19721
// if task [ 1 ] [ 1 ] = p then
19695: LD_VAR 0 3
19699: PUSH
19700: LD_INT 1
19702: ARRAY
19703: PUSH
19704: LD_INT 1
19706: ARRAY
19707: PUSH
19708: LD_STRING p
19710: EQUAL
19711: IFFALSE 19721
// result := true ;
19713: LD_ADDR_VAR 0 2
19717: PUSH
19718: LD_INT 1
19720: ST_TO_ADDR
// end ;
19721: LD_VAR 0 2
19725: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19726: LD_INT 0
19728: PPUSH
19729: PPUSH
19730: PPUSH
19731: PPUSH
// if pos < 1 then
19732: LD_VAR 0 2
19736: PUSH
19737: LD_INT 1
19739: LESS
19740: IFFALSE 19744
// exit ;
19742: GO 20047
// if pos = 1 then
19744: LD_VAR 0 2
19748: PUSH
19749: LD_INT 1
19751: EQUAL
19752: IFFALSE 19785
// result := Replace ( arr , pos [ 1 ] , value ) else
19754: LD_ADDR_VAR 0 4
19758: PUSH
19759: LD_VAR 0 1
19763: PPUSH
19764: LD_VAR 0 2
19768: PUSH
19769: LD_INT 1
19771: ARRAY
19772: PPUSH
19773: LD_VAR 0 3
19777: PPUSH
19778: CALL_OW 1
19782: ST_TO_ADDR
19783: GO 20047
// begin tmp := arr ;
19785: LD_ADDR_VAR 0 6
19789: PUSH
19790: LD_VAR 0 1
19794: ST_TO_ADDR
// s_arr := [ tmp ] ;
19795: LD_ADDR_VAR 0 7
19799: PUSH
19800: LD_VAR 0 6
19804: PUSH
19805: EMPTY
19806: LIST
19807: ST_TO_ADDR
// for i = 1 to pos - 1 do
19808: LD_ADDR_VAR 0 5
19812: PUSH
19813: DOUBLE
19814: LD_INT 1
19816: DEC
19817: ST_TO_ADDR
19818: LD_VAR 0 2
19822: PUSH
19823: LD_INT 1
19825: MINUS
19826: PUSH
19827: FOR_TO
19828: IFFALSE 19873
// begin tmp := tmp [ pos [ i ] ] ;
19830: LD_ADDR_VAR 0 6
19834: PUSH
19835: LD_VAR 0 6
19839: PUSH
19840: LD_VAR 0 2
19844: PUSH
19845: LD_VAR 0 5
19849: ARRAY
19850: ARRAY
19851: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
19852: LD_ADDR_VAR 0 7
19856: PUSH
19857: LD_VAR 0 7
19861: PUSH
19862: LD_VAR 0 6
19866: PUSH
19867: EMPTY
19868: LIST
19869: ADD
19870: ST_TO_ADDR
// end ;
19871: GO 19827
19873: POP
19874: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
19875: LD_ADDR_VAR 0 6
19879: PUSH
19880: LD_VAR 0 6
19884: PPUSH
19885: LD_VAR 0 2
19889: PUSH
19890: LD_VAR 0 2
19894: ARRAY
19895: PPUSH
19896: LD_VAR 0 3
19900: PPUSH
19901: CALL_OW 1
19905: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
19906: LD_ADDR_VAR 0 7
19910: PUSH
19911: LD_VAR 0 7
19915: PPUSH
19916: LD_VAR 0 7
19920: PPUSH
19921: LD_VAR 0 6
19925: PPUSH
19926: CALL_OW 1
19930: ST_TO_ADDR
// for i = s_arr downto 2 do
19931: LD_ADDR_VAR 0 5
19935: PUSH
19936: DOUBLE
19937: LD_VAR 0 7
19941: INC
19942: ST_TO_ADDR
19943: LD_INT 2
19945: PUSH
19946: FOR_DOWNTO
19947: IFFALSE 20031
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
19949: LD_ADDR_VAR 0 6
19953: PUSH
19954: LD_VAR 0 7
19958: PUSH
19959: LD_VAR 0 5
19963: PUSH
19964: LD_INT 1
19966: MINUS
19967: ARRAY
19968: PPUSH
19969: LD_VAR 0 2
19973: PUSH
19974: LD_VAR 0 5
19978: PUSH
19979: LD_INT 1
19981: MINUS
19982: ARRAY
19983: PPUSH
19984: LD_VAR 0 7
19988: PUSH
19989: LD_VAR 0 5
19993: ARRAY
19994: PPUSH
19995: CALL_OW 1
19999: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20000: LD_ADDR_VAR 0 7
20004: PUSH
20005: LD_VAR 0 7
20009: PPUSH
20010: LD_VAR 0 5
20014: PUSH
20015: LD_INT 1
20017: MINUS
20018: PPUSH
20019: LD_VAR 0 6
20023: PPUSH
20024: CALL_OW 1
20028: ST_TO_ADDR
// end ;
20029: GO 19946
20031: POP
20032: POP
// result := s_arr [ 1 ] ;
20033: LD_ADDR_VAR 0 4
20037: PUSH
20038: LD_VAR 0 7
20042: PUSH
20043: LD_INT 1
20045: ARRAY
20046: ST_TO_ADDR
// end ; end ;
20047: LD_VAR 0 4
20051: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20052: LD_INT 0
20054: PPUSH
20055: PPUSH
// if not list then
20056: LD_VAR 0 1
20060: NOT
20061: IFFALSE 20065
// exit ;
20063: GO 20156
// i := list [ pos1 ] ;
20065: LD_ADDR_VAR 0 5
20069: PUSH
20070: LD_VAR 0 1
20074: PUSH
20075: LD_VAR 0 2
20079: ARRAY
20080: ST_TO_ADDR
// if not i then
20081: LD_VAR 0 5
20085: NOT
20086: IFFALSE 20090
// exit ;
20088: GO 20156
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20090: LD_ADDR_VAR 0 1
20094: PUSH
20095: LD_VAR 0 1
20099: PPUSH
20100: LD_VAR 0 2
20104: PPUSH
20105: LD_VAR 0 1
20109: PUSH
20110: LD_VAR 0 3
20114: ARRAY
20115: PPUSH
20116: CALL_OW 1
20120: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20121: LD_ADDR_VAR 0 1
20125: PUSH
20126: LD_VAR 0 1
20130: PPUSH
20131: LD_VAR 0 3
20135: PPUSH
20136: LD_VAR 0 5
20140: PPUSH
20141: CALL_OW 1
20145: ST_TO_ADDR
// result := list ;
20146: LD_ADDR_VAR 0 4
20150: PUSH
20151: LD_VAR 0 1
20155: ST_TO_ADDR
// end ;
20156: LD_VAR 0 4
20160: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20161: LD_INT 0
20163: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20164: LD_ADDR_VAR 0 5
20168: PUSH
20169: LD_VAR 0 1
20173: PPUSH
20174: CALL_OW 250
20178: PPUSH
20179: LD_VAR 0 1
20183: PPUSH
20184: CALL_OW 251
20188: PPUSH
20189: LD_VAR 0 2
20193: PPUSH
20194: LD_VAR 0 3
20198: PPUSH
20199: LD_VAR 0 4
20203: PPUSH
20204: CALL 20214 0 5
20208: ST_TO_ADDR
// end ;
20209: LD_VAR 0 5
20213: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20214: LD_INT 0
20216: PPUSH
20217: PPUSH
20218: PPUSH
20219: PPUSH
// if not list then
20220: LD_VAR 0 3
20224: NOT
20225: IFFALSE 20229
// exit ;
20227: GO 20617
// result := [ ] ;
20229: LD_ADDR_VAR 0 6
20233: PUSH
20234: EMPTY
20235: ST_TO_ADDR
// for i in list do
20236: LD_ADDR_VAR 0 7
20240: PUSH
20241: LD_VAR 0 3
20245: PUSH
20246: FOR_IN
20247: IFFALSE 20449
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20249: LD_ADDR_VAR 0 9
20253: PUSH
20254: LD_VAR 0 7
20258: PPUSH
20259: LD_VAR 0 1
20263: PPUSH
20264: LD_VAR 0 2
20268: PPUSH
20269: CALL_OW 297
20273: ST_TO_ADDR
// if not result then
20274: LD_VAR 0 6
20278: NOT
20279: IFFALSE 20305
// result := [ [ i , tmp ] ] else
20281: LD_ADDR_VAR 0 6
20285: PUSH
20286: LD_VAR 0 7
20290: PUSH
20291: LD_VAR 0 9
20295: PUSH
20296: EMPTY
20297: LIST
20298: LIST
20299: PUSH
20300: EMPTY
20301: LIST
20302: ST_TO_ADDR
20303: GO 20447
// begin if result [ result ] [ 2 ] < tmp then
20305: LD_VAR 0 6
20309: PUSH
20310: LD_VAR 0 6
20314: ARRAY
20315: PUSH
20316: LD_INT 2
20318: ARRAY
20319: PUSH
20320: LD_VAR 0 9
20324: LESS
20325: IFFALSE 20367
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20327: LD_ADDR_VAR 0 6
20331: PUSH
20332: LD_VAR 0 6
20336: PPUSH
20337: LD_VAR 0 6
20341: PUSH
20342: LD_INT 1
20344: PLUS
20345: PPUSH
20346: LD_VAR 0 7
20350: PUSH
20351: LD_VAR 0 9
20355: PUSH
20356: EMPTY
20357: LIST
20358: LIST
20359: PPUSH
20360: CALL_OW 2
20364: ST_TO_ADDR
20365: GO 20447
// for j = 1 to result do
20367: LD_ADDR_VAR 0 8
20371: PUSH
20372: DOUBLE
20373: LD_INT 1
20375: DEC
20376: ST_TO_ADDR
20377: LD_VAR 0 6
20381: PUSH
20382: FOR_TO
20383: IFFALSE 20445
// begin if tmp < result [ j ] [ 2 ] then
20385: LD_VAR 0 9
20389: PUSH
20390: LD_VAR 0 6
20394: PUSH
20395: LD_VAR 0 8
20399: ARRAY
20400: PUSH
20401: LD_INT 2
20403: ARRAY
20404: LESS
20405: IFFALSE 20443
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20407: LD_ADDR_VAR 0 6
20411: PUSH
20412: LD_VAR 0 6
20416: PPUSH
20417: LD_VAR 0 8
20421: PPUSH
20422: LD_VAR 0 7
20426: PUSH
20427: LD_VAR 0 9
20431: PUSH
20432: EMPTY
20433: LIST
20434: LIST
20435: PPUSH
20436: CALL_OW 2
20440: ST_TO_ADDR
// break ;
20441: GO 20445
// end ; end ;
20443: GO 20382
20445: POP
20446: POP
// end ; end ;
20447: GO 20246
20449: POP
20450: POP
// if result and not asc then
20451: LD_VAR 0 6
20455: PUSH
20456: LD_VAR 0 4
20460: NOT
20461: AND
20462: IFFALSE 20537
// begin tmp := result ;
20464: LD_ADDR_VAR 0 9
20468: PUSH
20469: LD_VAR 0 6
20473: ST_TO_ADDR
// for i = tmp downto 1 do
20474: LD_ADDR_VAR 0 7
20478: PUSH
20479: DOUBLE
20480: LD_VAR 0 9
20484: INC
20485: ST_TO_ADDR
20486: LD_INT 1
20488: PUSH
20489: FOR_DOWNTO
20490: IFFALSE 20535
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20492: LD_ADDR_VAR 0 6
20496: PUSH
20497: LD_VAR 0 6
20501: PPUSH
20502: LD_VAR 0 9
20506: PUSH
20507: LD_VAR 0 7
20511: MINUS
20512: PUSH
20513: LD_INT 1
20515: PLUS
20516: PPUSH
20517: LD_VAR 0 9
20521: PUSH
20522: LD_VAR 0 7
20526: ARRAY
20527: PPUSH
20528: CALL_OW 1
20532: ST_TO_ADDR
20533: GO 20489
20535: POP
20536: POP
// end ; tmp := [ ] ;
20537: LD_ADDR_VAR 0 9
20541: PUSH
20542: EMPTY
20543: ST_TO_ADDR
// if mode then
20544: LD_VAR 0 5
20548: IFFALSE 20617
// begin for i = 1 to result do
20550: LD_ADDR_VAR 0 7
20554: PUSH
20555: DOUBLE
20556: LD_INT 1
20558: DEC
20559: ST_TO_ADDR
20560: LD_VAR 0 6
20564: PUSH
20565: FOR_TO
20566: IFFALSE 20605
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20568: LD_ADDR_VAR 0 9
20572: PUSH
20573: LD_VAR 0 9
20577: PPUSH
20578: LD_VAR 0 7
20582: PPUSH
20583: LD_VAR 0 6
20587: PUSH
20588: LD_VAR 0 7
20592: ARRAY
20593: PUSH
20594: LD_INT 1
20596: ARRAY
20597: PPUSH
20598: CALL_OW 1
20602: ST_TO_ADDR
20603: GO 20565
20605: POP
20606: POP
// result := tmp ;
20607: LD_ADDR_VAR 0 6
20611: PUSH
20612: LD_VAR 0 9
20616: ST_TO_ADDR
// end ; end ;
20617: LD_VAR 0 6
20621: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20622: LD_INT 0
20624: PPUSH
20625: PPUSH
20626: PPUSH
20627: PPUSH
20628: PPUSH
20629: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20630: LD_ADDR_VAR 0 5
20634: PUSH
20635: LD_INT 0
20637: PUSH
20638: LD_INT 0
20640: PUSH
20641: LD_INT 0
20643: PUSH
20644: EMPTY
20645: PUSH
20646: EMPTY
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: ST_TO_ADDR
// if not x or not y then
20652: LD_VAR 0 2
20656: NOT
20657: PUSH
20658: LD_VAR 0 3
20662: NOT
20663: OR
20664: IFFALSE 20668
// exit ;
20666: GO 22320
// if not range then
20668: LD_VAR 0 4
20672: NOT
20673: IFFALSE 20683
// range := 10 ;
20675: LD_ADDR_VAR 0 4
20679: PUSH
20680: LD_INT 10
20682: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20683: LD_ADDR_VAR 0 8
20687: PUSH
20688: LD_INT 81
20690: PUSH
20691: LD_VAR 0 1
20695: PUSH
20696: EMPTY
20697: LIST
20698: LIST
20699: PUSH
20700: LD_INT 92
20702: PUSH
20703: LD_VAR 0 2
20707: PUSH
20708: LD_VAR 0 3
20712: PUSH
20713: LD_VAR 0 4
20717: PUSH
20718: EMPTY
20719: LIST
20720: LIST
20721: LIST
20722: LIST
20723: PUSH
20724: LD_INT 3
20726: PUSH
20727: LD_INT 21
20729: PUSH
20730: LD_INT 3
20732: PUSH
20733: EMPTY
20734: LIST
20735: LIST
20736: PUSH
20737: EMPTY
20738: LIST
20739: LIST
20740: PUSH
20741: EMPTY
20742: LIST
20743: LIST
20744: LIST
20745: PPUSH
20746: CALL_OW 69
20750: ST_TO_ADDR
// if not tmp then
20751: LD_VAR 0 8
20755: NOT
20756: IFFALSE 20760
// exit ;
20758: GO 22320
// for i in tmp do
20760: LD_ADDR_VAR 0 6
20764: PUSH
20765: LD_VAR 0 8
20769: PUSH
20770: FOR_IN
20771: IFFALSE 22295
// begin points := [ 0 , 0 , 0 ] ;
20773: LD_ADDR_VAR 0 9
20777: PUSH
20778: LD_INT 0
20780: PUSH
20781: LD_INT 0
20783: PUSH
20784: LD_INT 0
20786: PUSH
20787: EMPTY
20788: LIST
20789: LIST
20790: LIST
20791: ST_TO_ADDR
// bpoints := 1 ;
20792: LD_ADDR_VAR 0 10
20796: PUSH
20797: LD_INT 1
20799: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20800: LD_VAR 0 6
20804: PPUSH
20805: CALL_OW 247
20809: PUSH
20810: LD_INT 1
20812: DOUBLE
20813: EQUAL
20814: IFTRUE 20818
20816: GO 21396
20818: POP
// begin if GetClass ( i ) = 1 then
20819: LD_VAR 0 6
20823: PPUSH
20824: CALL_OW 257
20828: PUSH
20829: LD_INT 1
20831: EQUAL
20832: IFFALSE 20853
// points := [ 10 , 5 , 3 ] ;
20834: LD_ADDR_VAR 0 9
20838: PUSH
20839: LD_INT 10
20841: PUSH
20842: LD_INT 5
20844: PUSH
20845: LD_INT 3
20847: PUSH
20848: EMPTY
20849: LIST
20850: LIST
20851: LIST
20852: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
20853: LD_VAR 0 6
20857: PPUSH
20858: CALL_OW 257
20862: PUSH
20863: LD_INT 2
20865: PUSH
20866: LD_INT 3
20868: PUSH
20869: LD_INT 4
20871: PUSH
20872: EMPTY
20873: LIST
20874: LIST
20875: LIST
20876: IN
20877: IFFALSE 20898
// points := [ 3 , 2 , 1 ] ;
20879: LD_ADDR_VAR 0 9
20883: PUSH
20884: LD_INT 3
20886: PUSH
20887: LD_INT 2
20889: PUSH
20890: LD_INT 1
20892: PUSH
20893: EMPTY
20894: LIST
20895: LIST
20896: LIST
20897: ST_TO_ADDR
// if GetClass ( i ) = 5 then
20898: LD_VAR 0 6
20902: PPUSH
20903: CALL_OW 257
20907: PUSH
20908: LD_INT 5
20910: EQUAL
20911: IFFALSE 20932
// points := [ 130 , 5 , 2 ] ;
20913: LD_ADDR_VAR 0 9
20917: PUSH
20918: LD_INT 130
20920: PUSH
20921: LD_INT 5
20923: PUSH
20924: LD_INT 2
20926: PUSH
20927: EMPTY
20928: LIST
20929: LIST
20930: LIST
20931: ST_TO_ADDR
// if GetClass ( i ) = 8 then
20932: LD_VAR 0 6
20936: PPUSH
20937: CALL_OW 257
20941: PUSH
20942: LD_INT 8
20944: EQUAL
20945: IFFALSE 20966
// points := [ 35 , 35 , 30 ] ;
20947: LD_ADDR_VAR 0 9
20951: PUSH
20952: LD_INT 35
20954: PUSH
20955: LD_INT 35
20957: PUSH
20958: LD_INT 30
20960: PUSH
20961: EMPTY
20962: LIST
20963: LIST
20964: LIST
20965: ST_TO_ADDR
// if GetClass ( i ) = 9 then
20966: LD_VAR 0 6
20970: PPUSH
20971: CALL_OW 257
20975: PUSH
20976: LD_INT 9
20978: EQUAL
20979: IFFALSE 21000
// points := [ 20 , 55 , 40 ] ;
20981: LD_ADDR_VAR 0 9
20985: PUSH
20986: LD_INT 20
20988: PUSH
20989: LD_INT 55
20991: PUSH
20992: LD_INT 40
20994: PUSH
20995: EMPTY
20996: LIST
20997: LIST
20998: LIST
20999: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21000: LD_VAR 0 6
21004: PPUSH
21005: CALL_OW 257
21009: PUSH
21010: LD_INT 12
21012: PUSH
21013: LD_INT 16
21015: PUSH
21016: EMPTY
21017: LIST
21018: LIST
21019: IN
21020: IFFALSE 21041
// points := [ 5 , 3 , 2 ] ;
21022: LD_ADDR_VAR 0 9
21026: PUSH
21027: LD_INT 5
21029: PUSH
21030: LD_INT 3
21032: PUSH
21033: LD_INT 2
21035: PUSH
21036: EMPTY
21037: LIST
21038: LIST
21039: LIST
21040: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21041: LD_VAR 0 6
21045: PPUSH
21046: CALL_OW 257
21050: PUSH
21051: LD_INT 17
21053: EQUAL
21054: IFFALSE 21075
// points := [ 100 , 50 , 75 ] ;
21056: LD_ADDR_VAR 0 9
21060: PUSH
21061: LD_INT 100
21063: PUSH
21064: LD_INT 50
21066: PUSH
21067: LD_INT 75
21069: PUSH
21070: EMPTY
21071: LIST
21072: LIST
21073: LIST
21074: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21075: LD_VAR 0 6
21079: PPUSH
21080: CALL_OW 257
21084: PUSH
21085: LD_INT 15
21087: EQUAL
21088: IFFALSE 21109
// points := [ 10 , 5 , 3 ] ;
21090: LD_ADDR_VAR 0 9
21094: PUSH
21095: LD_INT 10
21097: PUSH
21098: LD_INT 5
21100: PUSH
21101: LD_INT 3
21103: PUSH
21104: EMPTY
21105: LIST
21106: LIST
21107: LIST
21108: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21109: LD_VAR 0 6
21113: PPUSH
21114: CALL_OW 257
21118: PUSH
21119: LD_INT 14
21121: EQUAL
21122: IFFALSE 21143
// points := [ 10 , 0 , 0 ] ;
21124: LD_ADDR_VAR 0 9
21128: PUSH
21129: LD_INT 10
21131: PUSH
21132: LD_INT 0
21134: PUSH
21135: LD_INT 0
21137: PUSH
21138: EMPTY
21139: LIST
21140: LIST
21141: LIST
21142: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21143: LD_VAR 0 6
21147: PPUSH
21148: CALL_OW 257
21152: PUSH
21153: LD_INT 11
21155: EQUAL
21156: IFFALSE 21177
// points := [ 30 , 10 , 5 ] ;
21158: LD_ADDR_VAR 0 9
21162: PUSH
21163: LD_INT 30
21165: PUSH
21166: LD_INT 10
21168: PUSH
21169: LD_INT 5
21171: PUSH
21172: EMPTY
21173: LIST
21174: LIST
21175: LIST
21176: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21177: LD_VAR 0 1
21181: PPUSH
21182: LD_INT 5
21184: PPUSH
21185: CALL_OW 321
21189: PUSH
21190: LD_INT 2
21192: EQUAL
21193: IFFALSE 21210
// bpoints := bpoints * 1.8 ;
21195: LD_ADDR_VAR 0 10
21199: PUSH
21200: LD_VAR 0 10
21204: PUSH
21205: LD_REAL  1.80000000000000E+0000
21208: MUL
21209: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21210: LD_VAR 0 6
21214: PPUSH
21215: CALL_OW 257
21219: PUSH
21220: LD_INT 1
21222: PUSH
21223: LD_INT 2
21225: PUSH
21226: LD_INT 3
21228: PUSH
21229: LD_INT 4
21231: PUSH
21232: EMPTY
21233: LIST
21234: LIST
21235: LIST
21236: LIST
21237: IN
21238: PUSH
21239: LD_VAR 0 1
21243: PPUSH
21244: LD_INT 51
21246: PPUSH
21247: CALL_OW 321
21251: PUSH
21252: LD_INT 2
21254: EQUAL
21255: AND
21256: IFFALSE 21273
// bpoints := bpoints * 1.2 ;
21258: LD_ADDR_VAR 0 10
21262: PUSH
21263: LD_VAR 0 10
21267: PUSH
21268: LD_REAL  1.20000000000000E+0000
21271: MUL
21272: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21273: LD_VAR 0 6
21277: PPUSH
21278: CALL_OW 257
21282: PUSH
21283: LD_INT 5
21285: PUSH
21286: LD_INT 7
21288: PUSH
21289: LD_INT 9
21291: PUSH
21292: EMPTY
21293: LIST
21294: LIST
21295: LIST
21296: IN
21297: PUSH
21298: LD_VAR 0 1
21302: PPUSH
21303: LD_INT 52
21305: PPUSH
21306: CALL_OW 321
21310: PUSH
21311: LD_INT 2
21313: EQUAL
21314: AND
21315: IFFALSE 21332
// bpoints := bpoints * 1.5 ;
21317: LD_ADDR_VAR 0 10
21321: PUSH
21322: LD_VAR 0 10
21326: PUSH
21327: LD_REAL  1.50000000000000E+0000
21330: MUL
21331: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21332: LD_VAR 0 1
21336: PPUSH
21337: LD_INT 66
21339: PPUSH
21340: CALL_OW 321
21344: PUSH
21345: LD_INT 2
21347: EQUAL
21348: IFFALSE 21365
// bpoints := bpoints * 1.1 ;
21350: LD_ADDR_VAR 0 10
21354: PUSH
21355: LD_VAR 0 10
21359: PUSH
21360: LD_REAL  1.10000000000000E+0000
21363: MUL
21364: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21365: LD_ADDR_VAR 0 10
21369: PUSH
21370: LD_VAR 0 10
21374: PUSH
21375: LD_VAR 0 6
21379: PPUSH
21380: LD_INT 1
21382: PPUSH
21383: CALL_OW 259
21387: PUSH
21388: LD_REAL  1.15000000000000E+0000
21391: MUL
21392: MUL
21393: ST_TO_ADDR
// end ; unit_vehicle :
21394: GO 22224
21396: LD_INT 2
21398: DOUBLE
21399: EQUAL
21400: IFTRUE 21404
21402: GO 22212
21404: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21405: LD_VAR 0 6
21409: PPUSH
21410: CALL_OW 264
21414: PUSH
21415: LD_INT 2
21417: PUSH
21418: LD_INT 42
21420: PUSH
21421: LD_INT 24
21423: PUSH
21424: EMPTY
21425: LIST
21426: LIST
21427: LIST
21428: IN
21429: IFFALSE 21450
// points := [ 25 , 5 , 3 ] ;
21431: LD_ADDR_VAR 0 9
21435: PUSH
21436: LD_INT 25
21438: PUSH
21439: LD_INT 5
21441: PUSH
21442: LD_INT 3
21444: PUSH
21445: EMPTY
21446: LIST
21447: LIST
21448: LIST
21449: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21450: LD_VAR 0 6
21454: PPUSH
21455: CALL_OW 264
21459: PUSH
21460: LD_INT 4
21462: PUSH
21463: LD_INT 43
21465: PUSH
21466: LD_INT 25
21468: PUSH
21469: EMPTY
21470: LIST
21471: LIST
21472: LIST
21473: IN
21474: IFFALSE 21495
// points := [ 40 , 15 , 5 ] ;
21476: LD_ADDR_VAR 0 9
21480: PUSH
21481: LD_INT 40
21483: PUSH
21484: LD_INT 15
21486: PUSH
21487: LD_INT 5
21489: PUSH
21490: EMPTY
21491: LIST
21492: LIST
21493: LIST
21494: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21495: LD_VAR 0 6
21499: PPUSH
21500: CALL_OW 264
21504: PUSH
21505: LD_INT 3
21507: PUSH
21508: LD_INT 23
21510: PUSH
21511: EMPTY
21512: LIST
21513: LIST
21514: IN
21515: IFFALSE 21536
// points := [ 7 , 25 , 8 ] ;
21517: LD_ADDR_VAR 0 9
21521: PUSH
21522: LD_INT 7
21524: PUSH
21525: LD_INT 25
21527: PUSH
21528: LD_INT 8
21530: PUSH
21531: EMPTY
21532: LIST
21533: LIST
21534: LIST
21535: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21536: LD_VAR 0 6
21540: PPUSH
21541: CALL_OW 264
21545: PUSH
21546: LD_INT 5
21548: PUSH
21549: LD_INT 27
21551: PUSH
21552: LD_INT 44
21554: PUSH
21555: EMPTY
21556: LIST
21557: LIST
21558: LIST
21559: IN
21560: IFFALSE 21581
// points := [ 14 , 50 , 16 ] ;
21562: LD_ADDR_VAR 0 9
21566: PUSH
21567: LD_INT 14
21569: PUSH
21570: LD_INT 50
21572: PUSH
21573: LD_INT 16
21575: PUSH
21576: EMPTY
21577: LIST
21578: LIST
21579: LIST
21580: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21581: LD_VAR 0 6
21585: PPUSH
21586: CALL_OW 264
21590: PUSH
21591: LD_INT 6
21593: PUSH
21594: LD_INT 46
21596: PUSH
21597: EMPTY
21598: LIST
21599: LIST
21600: IN
21601: IFFALSE 21622
// points := [ 32 , 120 , 70 ] ;
21603: LD_ADDR_VAR 0 9
21607: PUSH
21608: LD_INT 32
21610: PUSH
21611: LD_INT 120
21613: PUSH
21614: LD_INT 70
21616: PUSH
21617: EMPTY
21618: LIST
21619: LIST
21620: LIST
21621: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
21622: LD_VAR 0 6
21626: PPUSH
21627: CALL_OW 264
21631: PUSH
21632: LD_INT 7
21634: PUSH
21635: LD_INT 28
21637: PUSH
21638: LD_INT 45
21640: PUSH
21641: LD_EXP 108
21645: PUSH
21646: EMPTY
21647: LIST
21648: LIST
21649: LIST
21650: LIST
21651: IN
21652: IFFALSE 21673
// points := [ 35 , 20 , 45 ] ;
21654: LD_ADDR_VAR 0 9
21658: PUSH
21659: LD_INT 35
21661: PUSH
21662: LD_INT 20
21664: PUSH
21665: LD_INT 45
21667: PUSH
21668: EMPTY
21669: LIST
21670: LIST
21671: LIST
21672: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21673: LD_VAR 0 6
21677: PPUSH
21678: CALL_OW 264
21682: PUSH
21683: LD_INT 47
21685: PUSH
21686: EMPTY
21687: LIST
21688: IN
21689: IFFALSE 21710
// points := [ 67 , 45 , 75 ] ;
21691: LD_ADDR_VAR 0 9
21695: PUSH
21696: LD_INT 67
21698: PUSH
21699: LD_INT 45
21701: PUSH
21702: LD_INT 75
21704: PUSH
21705: EMPTY
21706: LIST
21707: LIST
21708: LIST
21709: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21710: LD_VAR 0 6
21714: PPUSH
21715: CALL_OW 264
21719: PUSH
21720: LD_INT 26
21722: PUSH
21723: EMPTY
21724: LIST
21725: IN
21726: IFFALSE 21747
// points := [ 120 , 30 , 80 ] ;
21728: LD_ADDR_VAR 0 9
21732: PUSH
21733: LD_INT 120
21735: PUSH
21736: LD_INT 30
21738: PUSH
21739: LD_INT 80
21741: PUSH
21742: EMPTY
21743: LIST
21744: LIST
21745: LIST
21746: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21747: LD_VAR 0 6
21751: PPUSH
21752: CALL_OW 264
21756: PUSH
21757: LD_INT 22
21759: PUSH
21760: EMPTY
21761: LIST
21762: IN
21763: IFFALSE 21784
// points := [ 40 , 1 , 1 ] ;
21765: LD_ADDR_VAR 0 9
21769: PUSH
21770: LD_INT 40
21772: PUSH
21773: LD_INT 1
21775: PUSH
21776: LD_INT 1
21778: PUSH
21779: EMPTY
21780: LIST
21781: LIST
21782: LIST
21783: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21784: LD_VAR 0 6
21788: PPUSH
21789: CALL_OW 264
21793: PUSH
21794: LD_INT 29
21796: PUSH
21797: EMPTY
21798: LIST
21799: IN
21800: IFFALSE 21821
// points := [ 70 , 200 , 400 ] ;
21802: LD_ADDR_VAR 0 9
21806: PUSH
21807: LD_INT 70
21809: PUSH
21810: LD_INT 200
21812: PUSH
21813: LD_INT 400
21815: PUSH
21816: EMPTY
21817: LIST
21818: LIST
21819: LIST
21820: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
21821: LD_VAR 0 6
21825: PPUSH
21826: CALL_OW 264
21830: PUSH
21831: LD_INT 14
21833: PUSH
21834: LD_INT 53
21836: PUSH
21837: EMPTY
21838: LIST
21839: LIST
21840: IN
21841: IFFALSE 21862
// points := [ 40 , 10 , 20 ] ;
21843: LD_ADDR_VAR 0 9
21847: PUSH
21848: LD_INT 40
21850: PUSH
21851: LD_INT 10
21853: PUSH
21854: LD_INT 20
21856: PUSH
21857: EMPTY
21858: LIST
21859: LIST
21860: LIST
21861: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
21862: LD_VAR 0 6
21866: PPUSH
21867: CALL_OW 264
21871: PUSH
21872: LD_INT 9
21874: PUSH
21875: EMPTY
21876: LIST
21877: IN
21878: IFFALSE 21899
// points := [ 5 , 70 , 20 ] ;
21880: LD_ADDR_VAR 0 9
21884: PUSH
21885: LD_INT 5
21887: PUSH
21888: LD_INT 70
21890: PUSH
21891: LD_INT 20
21893: PUSH
21894: EMPTY
21895: LIST
21896: LIST
21897: LIST
21898: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
21899: LD_VAR 0 6
21903: PPUSH
21904: CALL_OW 264
21908: PUSH
21909: LD_INT 10
21911: PUSH
21912: EMPTY
21913: LIST
21914: IN
21915: IFFALSE 21936
// points := [ 35 , 110 , 70 ] ;
21917: LD_ADDR_VAR 0 9
21921: PUSH
21922: LD_INT 35
21924: PUSH
21925: LD_INT 110
21927: PUSH
21928: LD_INT 70
21930: PUSH
21931: EMPTY
21932: LIST
21933: LIST
21934: LIST
21935: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
21936: LD_VAR 0 6
21940: PPUSH
21941: CALL_OW 265
21945: PUSH
21946: LD_INT 25
21948: EQUAL
21949: IFFALSE 21970
// points := [ 80 , 65 , 100 ] ;
21951: LD_ADDR_VAR 0 9
21955: PUSH
21956: LD_INT 80
21958: PUSH
21959: LD_INT 65
21961: PUSH
21962: LD_INT 100
21964: PUSH
21965: EMPTY
21966: LIST
21967: LIST
21968: LIST
21969: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
21970: LD_VAR 0 6
21974: PPUSH
21975: CALL_OW 263
21979: PUSH
21980: LD_INT 1
21982: EQUAL
21983: IFFALSE 22018
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
21985: LD_ADDR_VAR 0 10
21989: PUSH
21990: LD_VAR 0 10
21994: PUSH
21995: LD_VAR 0 6
21999: PPUSH
22000: CALL_OW 311
22004: PPUSH
22005: LD_INT 3
22007: PPUSH
22008: CALL_OW 259
22012: PUSH
22013: LD_INT 4
22015: MUL
22016: MUL
22017: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22018: LD_VAR 0 6
22022: PPUSH
22023: CALL_OW 263
22027: PUSH
22028: LD_INT 2
22030: EQUAL
22031: IFFALSE 22082
// begin j := IsControledBy ( i ) ;
22033: LD_ADDR_VAR 0 7
22037: PUSH
22038: LD_VAR 0 6
22042: PPUSH
22043: CALL_OW 312
22047: ST_TO_ADDR
// if j then
22048: LD_VAR 0 7
22052: IFFALSE 22082
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22054: LD_ADDR_VAR 0 10
22058: PUSH
22059: LD_VAR 0 10
22063: PUSH
22064: LD_VAR 0 7
22068: PPUSH
22069: LD_INT 3
22071: PPUSH
22072: CALL_OW 259
22076: PUSH
22077: LD_INT 3
22079: MUL
22080: MUL
22081: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22082: LD_VAR 0 6
22086: PPUSH
22087: CALL_OW 264
22091: PUSH
22092: LD_INT 5
22094: PUSH
22095: LD_INT 6
22097: PUSH
22098: LD_INT 46
22100: PUSH
22101: LD_INT 44
22103: PUSH
22104: LD_INT 47
22106: PUSH
22107: LD_INT 45
22109: PUSH
22110: LD_INT 28
22112: PUSH
22113: LD_INT 7
22115: PUSH
22116: LD_INT 27
22118: PUSH
22119: LD_INT 29
22121: PUSH
22122: EMPTY
22123: LIST
22124: LIST
22125: LIST
22126: LIST
22127: LIST
22128: LIST
22129: LIST
22130: LIST
22131: LIST
22132: LIST
22133: IN
22134: PUSH
22135: LD_VAR 0 1
22139: PPUSH
22140: LD_INT 52
22142: PPUSH
22143: CALL_OW 321
22147: PUSH
22148: LD_INT 2
22150: EQUAL
22151: AND
22152: IFFALSE 22169
// bpoints := bpoints * 1.2 ;
22154: LD_ADDR_VAR 0 10
22158: PUSH
22159: LD_VAR 0 10
22163: PUSH
22164: LD_REAL  1.20000000000000E+0000
22167: MUL
22168: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22169: LD_VAR 0 6
22173: PPUSH
22174: CALL_OW 264
22178: PUSH
22179: LD_INT 6
22181: PUSH
22182: LD_INT 46
22184: PUSH
22185: LD_INT 47
22187: PUSH
22188: EMPTY
22189: LIST
22190: LIST
22191: LIST
22192: IN
22193: IFFALSE 22210
// bpoints := bpoints * 1.2 ;
22195: LD_ADDR_VAR 0 10
22199: PUSH
22200: LD_VAR 0 10
22204: PUSH
22205: LD_REAL  1.20000000000000E+0000
22208: MUL
22209: ST_TO_ADDR
// end ; unit_building :
22210: GO 22224
22212: LD_INT 3
22214: DOUBLE
22215: EQUAL
22216: IFTRUE 22220
22218: GO 22223
22220: POP
// ; end ;
22221: GO 22224
22223: POP
// for j = 1 to 3 do
22224: LD_ADDR_VAR 0 7
22228: PUSH
22229: DOUBLE
22230: LD_INT 1
22232: DEC
22233: ST_TO_ADDR
22234: LD_INT 3
22236: PUSH
22237: FOR_TO
22238: IFFALSE 22291
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22240: LD_ADDR_VAR 0 5
22244: PUSH
22245: LD_VAR 0 5
22249: PPUSH
22250: LD_VAR 0 7
22254: PPUSH
22255: LD_VAR 0 5
22259: PUSH
22260: LD_VAR 0 7
22264: ARRAY
22265: PUSH
22266: LD_VAR 0 9
22270: PUSH
22271: LD_VAR 0 7
22275: ARRAY
22276: PUSH
22277: LD_VAR 0 10
22281: MUL
22282: PLUS
22283: PPUSH
22284: CALL_OW 1
22288: ST_TO_ADDR
22289: GO 22237
22291: POP
22292: POP
// end ;
22293: GO 20770
22295: POP
22296: POP
// result := Replace ( result , 4 , tmp ) ;
22297: LD_ADDR_VAR 0 5
22301: PUSH
22302: LD_VAR 0 5
22306: PPUSH
22307: LD_INT 4
22309: PPUSH
22310: LD_VAR 0 8
22314: PPUSH
22315: CALL_OW 1
22319: ST_TO_ADDR
// end ;
22320: LD_VAR 0 5
22324: RET
// export function DangerAtRange ( unit , range ) ; begin
22325: LD_INT 0
22327: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22328: LD_ADDR_VAR 0 3
22332: PUSH
22333: LD_VAR 0 1
22337: PPUSH
22338: CALL_OW 255
22342: PPUSH
22343: LD_VAR 0 1
22347: PPUSH
22348: CALL_OW 250
22352: PPUSH
22353: LD_VAR 0 1
22357: PPUSH
22358: CALL_OW 251
22362: PPUSH
22363: LD_VAR 0 2
22367: PPUSH
22368: CALL 20622 0 4
22372: ST_TO_ADDR
// end ;
22373: LD_VAR 0 3
22377: RET
// export function DangerInArea ( side , area ) ; begin
22378: LD_INT 0
22380: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22381: LD_ADDR_VAR 0 3
22385: PUSH
22386: LD_VAR 0 2
22390: PPUSH
22391: LD_INT 81
22393: PUSH
22394: LD_VAR 0 1
22398: PUSH
22399: EMPTY
22400: LIST
22401: LIST
22402: PPUSH
22403: CALL_OW 70
22407: ST_TO_ADDR
// end ;
22408: LD_VAR 0 3
22412: RET
// export function IsExtension ( b ) ; begin
22413: LD_INT 0
22415: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22416: LD_ADDR_VAR 0 2
22420: PUSH
22421: LD_VAR 0 1
22425: PUSH
22426: LD_INT 23
22428: PUSH
22429: LD_INT 20
22431: PUSH
22432: LD_INT 22
22434: PUSH
22435: LD_INT 17
22437: PUSH
22438: LD_INT 24
22440: PUSH
22441: LD_INT 21
22443: PUSH
22444: LD_INT 19
22446: PUSH
22447: LD_INT 16
22449: PUSH
22450: LD_INT 25
22452: PUSH
22453: LD_INT 18
22455: PUSH
22456: EMPTY
22457: LIST
22458: LIST
22459: LIST
22460: LIST
22461: LIST
22462: LIST
22463: LIST
22464: LIST
22465: LIST
22466: LIST
22467: IN
22468: ST_TO_ADDR
// end ;
22469: LD_VAR 0 2
22473: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22474: LD_INT 0
22476: PPUSH
22477: PPUSH
22478: PPUSH
// result := [ ] ;
22479: LD_ADDR_VAR 0 4
22483: PUSH
22484: EMPTY
22485: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22486: LD_ADDR_VAR 0 5
22490: PUSH
22491: LD_VAR 0 2
22495: PPUSH
22496: LD_INT 21
22498: PUSH
22499: LD_INT 3
22501: PUSH
22502: EMPTY
22503: LIST
22504: LIST
22505: PPUSH
22506: CALL_OW 70
22510: ST_TO_ADDR
// if not tmp then
22511: LD_VAR 0 5
22515: NOT
22516: IFFALSE 22520
// exit ;
22518: GO 22584
// if checkLink then
22520: LD_VAR 0 3
22524: IFFALSE 22574
// begin for i in tmp do
22526: LD_ADDR_VAR 0 6
22530: PUSH
22531: LD_VAR 0 5
22535: PUSH
22536: FOR_IN
22537: IFFALSE 22572
// if GetBase ( i ) <> base then
22539: LD_VAR 0 6
22543: PPUSH
22544: CALL_OW 274
22548: PUSH
22549: LD_VAR 0 1
22553: NONEQUAL
22554: IFFALSE 22570
// ComLinkToBase ( base , i ) ;
22556: LD_VAR 0 1
22560: PPUSH
22561: LD_VAR 0 6
22565: PPUSH
22566: CALL_OW 169
22570: GO 22536
22572: POP
22573: POP
// end ; result := tmp ;
22574: LD_ADDR_VAR 0 4
22578: PUSH
22579: LD_VAR 0 5
22583: ST_TO_ADDR
// end ;
22584: LD_VAR 0 4
22588: RET
// export function ComComplete ( units , b ) ; var i ; begin
22589: LD_INT 0
22591: PPUSH
22592: PPUSH
// if not units then
22593: LD_VAR 0 1
22597: NOT
22598: IFFALSE 22602
// exit ;
22600: GO 22692
// for i in units do
22602: LD_ADDR_VAR 0 4
22606: PUSH
22607: LD_VAR 0 1
22611: PUSH
22612: FOR_IN
22613: IFFALSE 22690
// if BuildingStatus ( b ) = bs_build then
22615: LD_VAR 0 2
22619: PPUSH
22620: CALL_OW 461
22624: PUSH
22625: LD_INT 1
22627: EQUAL
22628: IFFALSE 22688
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22630: LD_VAR 0 4
22634: PPUSH
22635: LD_STRING h
22637: PUSH
22638: LD_VAR 0 2
22642: PPUSH
22643: CALL_OW 250
22647: PUSH
22648: LD_VAR 0 2
22652: PPUSH
22653: CALL_OW 251
22657: PUSH
22658: LD_VAR 0 2
22662: PUSH
22663: LD_INT 0
22665: PUSH
22666: LD_INT 0
22668: PUSH
22669: LD_INT 0
22671: PUSH
22672: EMPTY
22673: LIST
22674: LIST
22675: LIST
22676: LIST
22677: LIST
22678: LIST
22679: LIST
22680: PUSH
22681: EMPTY
22682: LIST
22683: PPUSH
22684: CALL_OW 446
22688: GO 22612
22690: POP
22691: POP
// end ;
22692: LD_VAR 0 3
22696: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22697: LD_INT 0
22699: PPUSH
22700: PPUSH
22701: PPUSH
22702: PPUSH
22703: PPUSH
22704: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
22705: LD_VAR 0 1
22709: NOT
22710: PUSH
22711: LD_VAR 0 1
22715: PPUSH
22716: CALL_OW 263
22720: PUSH
22721: LD_INT 2
22723: NONEQUAL
22724: OR
22725: IFFALSE 22729
// exit ;
22727: GO 23045
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22729: LD_ADDR_VAR 0 6
22733: PUSH
22734: LD_INT 22
22736: PUSH
22737: LD_VAR 0 1
22741: PPUSH
22742: CALL_OW 255
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PUSH
22751: LD_INT 2
22753: PUSH
22754: LD_INT 30
22756: PUSH
22757: LD_INT 36
22759: PUSH
22760: EMPTY
22761: LIST
22762: LIST
22763: PUSH
22764: LD_INT 34
22766: PUSH
22767: LD_INT 31
22769: PUSH
22770: EMPTY
22771: LIST
22772: LIST
22773: PUSH
22774: EMPTY
22775: LIST
22776: LIST
22777: LIST
22778: PUSH
22779: EMPTY
22780: LIST
22781: LIST
22782: PPUSH
22783: CALL_OW 69
22787: ST_TO_ADDR
// if not tmp then
22788: LD_VAR 0 6
22792: NOT
22793: IFFALSE 22797
// exit ;
22795: GO 23045
// result := [ ] ;
22797: LD_ADDR_VAR 0 2
22801: PUSH
22802: EMPTY
22803: ST_TO_ADDR
// for i in tmp do
22804: LD_ADDR_VAR 0 3
22808: PUSH
22809: LD_VAR 0 6
22813: PUSH
22814: FOR_IN
22815: IFFALSE 22886
// begin t := UnitsInside ( i ) ;
22817: LD_ADDR_VAR 0 4
22821: PUSH
22822: LD_VAR 0 3
22826: PPUSH
22827: CALL_OW 313
22831: ST_TO_ADDR
// if t then
22832: LD_VAR 0 4
22836: IFFALSE 22884
// for j in t do
22838: LD_ADDR_VAR 0 7
22842: PUSH
22843: LD_VAR 0 4
22847: PUSH
22848: FOR_IN
22849: IFFALSE 22882
// result := Replace ( result , result + 1 , j ) ;
22851: LD_ADDR_VAR 0 2
22855: PUSH
22856: LD_VAR 0 2
22860: PPUSH
22861: LD_VAR 0 2
22865: PUSH
22866: LD_INT 1
22868: PLUS
22869: PPUSH
22870: LD_VAR 0 7
22874: PPUSH
22875: CALL_OW 1
22879: ST_TO_ADDR
22880: GO 22848
22882: POP
22883: POP
// end ;
22884: GO 22814
22886: POP
22887: POP
// if not result then
22888: LD_VAR 0 2
22892: NOT
22893: IFFALSE 22897
// exit ;
22895: GO 23045
// mech := result [ 1 ] ;
22897: LD_ADDR_VAR 0 5
22901: PUSH
22902: LD_VAR 0 2
22906: PUSH
22907: LD_INT 1
22909: ARRAY
22910: ST_TO_ADDR
// if result > 1 then
22911: LD_VAR 0 2
22915: PUSH
22916: LD_INT 1
22918: GREATER
22919: IFFALSE 23031
// begin for i = 2 to result do
22921: LD_ADDR_VAR 0 3
22925: PUSH
22926: DOUBLE
22927: LD_INT 2
22929: DEC
22930: ST_TO_ADDR
22931: LD_VAR 0 2
22935: PUSH
22936: FOR_TO
22937: IFFALSE 23029
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
22939: LD_ADDR_VAR 0 4
22943: PUSH
22944: LD_VAR 0 2
22948: PUSH
22949: LD_VAR 0 3
22953: ARRAY
22954: PPUSH
22955: LD_INT 3
22957: PPUSH
22958: CALL_OW 259
22962: PUSH
22963: LD_VAR 0 2
22967: PUSH
22968: LD_VAR 0 3
22972: ARRAY
22973: PPUSH
22974: CALL_OW 432
22978: MINUS
22979: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
22980: LD_VAR 0 4
22984: PUSH
22985: LD_VAR 0 5
22989: PPUSH
22990: LD_INT 3
22992: PPUSH
22993: CALL_OW 259
22997: PUSH
22998: LD_VAR 0 5
23002: PPUSH
23003: CALL_OW 432
23007: MINUS
23008: GREATEREQUAL
23009: IFFALSE 23027
// mech := result [ i ] ;
23011: LD_ADDR_VAR 0 5
23015: PUSH
23016: LD_VAR 0 2
23020: PUSH
23021: LD_VAR 0 3
23025: ARRAY
23026: ST_TO_ADDR
// end ;
23027: GO 22936
23029: POP
23030: POP
// end ; ComLinkTo ( vehicle , mech ) ;
23031: LD_VAR 0 1
23035: PPUSH
23036: LD_VAR 0 5
23040: PPUSH
23041: CALL_OW 135
// end ;
23045: LD_VAR 0 2
23049: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23050: LD_INT 0
23052: PPUSH
23053: PPUSH
23054: PPUSH
23055: PPUSH
23056: PPUSH
23057: PPUSH
23058: PPUSH
23059: PPUSH
23060: PPUSH
23061: PPUSH
23062: PPUSH
23063: PPUSH
23064: PPUSH
// result := [ ] ;
23065: LD_ADDR_VAR 0 7
23069: PUSH
23070: EMPTY
23071: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23072: LD_VAR 0 1
23076: PPUSH
23077: CALL_OW 266
23081: PUSH
23082: LD_INT 0
23084: PUSH
23085: LD_INT 1
23087: PUSH
23088: EMPTY
23089: LIST
23090: LIST
23091: IN
23092: NOT
23093: IFFALSE 23097
// exit ;
23095: GO 24731
// if name then
23097: LD_VAR 0 3
23101: IFFALSE 23117
// SetBName ( base_dep , name ) ;
23103: LD_VAR 0 1
23107: PPUSH
23108: LD_VAR 0 3
23112: PPUSH
23113: CALL_OW 500
// base := GetBase ( base_dep ) ;
23117: LD_ADDR_VAR 0 15
23121: PUSH
23122: LD_VAR 0 1
23126: PPUSH
23127: CALL_OW 274
23131: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23132: LD_ADDR_VAR 0 16
23136: PUSH
23137: LD_VAR 0 1
23141: PPUSH
23142: CALL_OW 255
23146: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23147: LD_ADDR_VAR 0 17
23151: PUSH
23152: LD_VAR 0 1
23156: PPUSH
23157: CALL_OW 248
23161: ST_TO_ADDR
// if sources then
23162: LD_VAR 0 5
23166: IFFALSE 23213
// for i = 1 to 3 do
23168: LD_ADDR_VAR 0 8
23172: PUSH
23173: DOUBLE
23174: LD_INT 1
23176: DEC
23177: ST_TO_ADDR
23178: LD_INT 3
23180: PUSH
23181: FOR_TO
23182: IFFALSE 23211
// AddResourceType ( base , i , sources [ i ] ) ;
23184: LD_VAR 0 15
23188: PPUSH
23189: LD_VAR 0 8
23193: PPUSH
23194: LD_VAR 0 5
23198: PUSH
23199: LD_VAR 0 8
23203: ARRAY
23204: PPUSH
23205: CALL_OW 276
23209: GO 23181
23211: POP
23212: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23213: LD_ADDR_VAR 0 18
23217: PUSH
23218: LD_VAR 0 15
23222: PPUSH
23223: LD_VAR 0 2
23227: PPUSH
23228: LD_INT 1
23230: PPUSH
23231: CALL 22474 0 3
23235: ST_TO_ADDR
// InitHc ;
23236: CALL_OW 19
// InitUc ;
23240: CALL_OW 18
// uc_side := side ;
23244: LD_ADDR_OWVAR 20
23248: PUSH
23249: LD_VAR 0 16
23253: ST_TO_ADDR
// uc_nation := nation ;
23254: LD_ADDR_OWVAR 21
23258: PUSH
23259: LD_VAR 0 17
23263: ST_TO_ADDR
// if buildings then
23264: LD_VAR 0 18
23268: IFFALSE 24590
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23270: LD_ADDR_VAR 0 19
23274: PUSH
23275: LD_VAR 0 18
23279: PPUSH
23280: LD_INT 2
23282: PUSH
23283: LD_INT 30
23285: PUSH
23286: LD_INT 29
23288: PUSH
23289: EMPTY
23290: LIST
23291: LIST
23292: PUSH
23293: LD_INT 30
23295: PUSH
23296: LD_INT 30
23298: PUSH
23299: EMPTY
23300: LIST
23301: LIST
23302: PUSH
23303: EMPTY
23304: LIST
23305: LIST
23306: LIST
23307: PPUSH
23308: CALL_OW 72
23312: ST_TO_ADDR
// if tmp then
23313: LD_VAR 0 19
23317: IFFALSE 23365
// for i in tmp do
23319: LD_ADDR_VAR 0 8
23323: PUSH
23324: LD_VAR 0 19
23328: PUSH
23329: FOR_IN
23330: IFFALSE 23363
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23332: LD_VAR 0 8
23336: PPUSH
23337: CALL_OW 250
23341: PPUSH
23342: LD_VAR 0 8
23346: PPUSH
23347: CALL_OW 251
23351: PPUSH
23352: LD_VAR 0 16
23356: PPUSH
23357: CALL_OW 441
23361: GO 23329
23363: POP
23364: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23365: LD_VAR 0 18
23369: PPUSH
23370: LD_INT 2
23372: PUSH
23373: LD_INT 30
23375: PUSH
23376: LD_INT 32
23378: PUSH
23379: EMPTY
23380: LIST
23381: LIST
23382: PUSH
23383: LD_INT 30
23385: PUSH
23386: LD_INT 33
23388: PUSH
23389: EMPTY
23390: LIST
23391: LIST
23392: PUSH
23393: EMPTY
23394: LIST
23395: LIST
23396: LIST
23397: PPUSH
23398: CALL_OW 72
23402: IFFALSE 23490
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23404: LD_ADDR_VAR 0 8
23408: PUSH
23409: LD_VAR 0 18
23413: PPUSH
23414: LD_INT 2
23416: PUSH
23417: LD_INT 30
23419: PUSH
23420: LD_INT 32
23422: PUSH
23423: EMPTY
23424: LIST
23425: LIST
23426: PUSH
23427: LD_INT 30
23429: PUSH
23430: LD_INT 33
23432: PUSH
23433: EMPTY
23434: LIST
23435: LIST
23436: PUSH
23437: EMPTY
23438: LIST
23439: LIST
23440: LIST
23441: PPUSH
23442: CALL_OW 72
23446: PUSH
23447: FOR_IN
23448: IFFALSE 23488
// begin if not GetBWeapon ( i ) then
23450: LD_VAR 0 8
23454: PPUSH
23455: CALL_OW 269
23459: NOT
23460: IFFALSE 23486
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23462: LD_VAR 0 8
23466: PPUSH
23467: LD_VAR 0 8
23471: PPUSH
23472: LD_VAR 0 2
23476: PPUSH
23477: CALL 24736 0 2
23481: PPUSH
23482: CALL_OW 431
// end ;
23486: GO 23447
23488: POP
23489: POP
// end ; for i = 1 to personel do
23490: LD_ADDR_VAR 0 8
23494: PUSH
23495: DOUBLE
23496: LD_INT 1
23498: DEC
23499: ST_TO_ADDR
23500: LD_VAR 0 6
23504: PUSH
23505: FOR_TO
23506: IFFALSE 24570
// begin if i > 4 then
23508: LD_VAR 0 8
23512: PUSH
23513: LD_INT 4
23515: GREATER
23516: IFFALSE 23520
// break ;
23518: GO 24570
// case i of 1 :
23520: LD_VAR 0 8
23524: PUSH
23525: LD_INT 1
23527: DOUBLE
23528: EQUAL
23529: IFTRUE 23533
23531: GO 23613
23533: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23534: LD_ADDR_VAR 0 12
23538: PUSH
23539: LD_VAR 0 18
23543: PPUSH
23544: LD_INT 22
23546: PUSH
23547: LD_VAR 0 16
23551: PUSH
23552: EMPTY
23553: LIST
23554: LIST
23555: PUSH
23556: LD_INT 58
23558: PUSH
23559: EMPTY
23560: LIST
23561: PUSH
23562: LD_INT 2
23564: PUSH
23565: LD_INT 30
23567: PUSH
23568: LD_INT 32
23570: PUSH
23571: EMPTY
23572: LIST
23573: LIST
23574: PUSH
23575: LD_INT 30
23577: PUSH
23578: LD_INT 4
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: PUSH
23585: LD_INT 30
23587: PUSH
23588: LD_INT 5
23590: PUSH
23591: EMPTY
23592: LIST
23593: LIST
23594: PUSH
23595: EMPTY
23596: LIST
23597: LIST
23598: LIST
23599: LIST
23600: PUSH
23601: EMPTY
23602: LIST
23603: LIST
23604: LIST
23605: PPUSH
23606: CALL_OW 72
23610: ST_TO_ADDR
23611: GO 23835
23613: LD_INT 2
23615: DOUBLE
23616: EQUAL
23617: IFTRUE 23621
23619: GO 23683
23621: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23622: LD_ADDR_VAR 0 12
23626: PUSH
23627: LD_VAR 0 18
23631: PPUSH
23632: LD_INT 22
23634: PUSH
23635: LD_VAR 0 16
23639: PUSH
23640: EMPTY
23641: LIST
23642: LIST
23643: PUSH
23644: LD_INT 2
23646: PUSH
23647: LD_INT 30
23649: PUSH
23650: LD_INT 0
23652: PUSH
23653: EMPTY
23654: LIST
23655: LIST
23656: PUSH
23657: LD_INT 30
23659: PUSH
23660: LD_INT 1
23662: PUSH
23663: EMPTY
23664: LIST
23665: LIST
23666: PUSH
23667: EMPTY
23668: LIST
23669: LIST
23670: LIST
23671: PUSH
23672: EMPTY
23673: LIST
23674: LIST
23675: PPUSH
23676: CALL_OW 72
23680: ST_TO_ADDR
23681: GO 23835
23683: LD_INT 3
23685: DOUBLE
23686: EQUAL
23687: IFTRUE 23691
23689: GO 23753
23691: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23692: LD_ADDR_VAR 0 12
23696: PUSH
23697: LD_VAR 0 18
23701: PPUSH
23702: LD_INT 22
23704: PUSH
23705: LD_VAR 0 16
23709: PUSH
23710: EMPTY
23711: LIST
23712: LIST
23713: PUSH
23714: LD_INT 2
23716: PUSH
23717: LD_INT 30
23719: PUSH
23720: LD_INT 2
23722: PUSH
23723: EMPTY
23724: LIST
23725: LIST
23726: PUSH
23727: LD_INT 30
23729: PUSH
23730: LD_INT 3
23732: PUSH
23733: EMPTY
23734: LIST
23735: LIST
23736: PUSH
23737: EMPTY
23738: LIST
23739: LIST
23740: LIST
23741: PUSH
23742: EMPTY
23743: LIST
23744: LIST
23745: PPUSH
23746: CALL_OW 72
23750: ST_TO_ADDR
23751: GO 23835
23753: LD_INT 4
23755: DOUBLE
23756: EQUAL
23757: IFTRUE 23761
23759: GO 23834
23761: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23762: LD_ADDR_VAR 0 12
23766: PUSH
23767: LD_VAR 0 18
23771: PPUSH
23772: LD_INT 22
23774: PUSH
23775: LD_VAR 0 16
23779: PUSH
23780: EMPTY
23781: LIST
23782: LIST
23783: PUSH
23784: LD_INT 2
23786: PUSH
23787: LD_INT 30
23789: PUSH
23790: LD_INT 6
23792: PUSH
23793: EMPTY
23794: LIST
23795: LIST
23796: PUSH
23797: LD_INT 30
23799: PUSH
23800: LD_INT 7
23802: PUSH
23803: EMPTY
23804: LIST
23805: LIST
23806: PUSH
23807: LD_INT 30
23809: PUSH
23810: LD_INT 8
23812: PUSH
23813: EMPTY
23814: LIST
23815: LIST
23816: PUSH
23817: EMPTY
23818: LIST
23819: LIST
23820: LIST
23821: LIST
23822: PUSH
23823: EMPTY
23824: LIST
23825: LIST
23826: PPUSH
23827: CALL_OW 72
23831: ST_TO_ADDR
23832: GO 23835
23834: POP
// if i = 1 then
23835: LD_VAR 0 8
23839: PUSH
23840: LD_INT 1
23842: EQUAL
23843: IFFALSE 23954
// begin tmp := [ ] ;
23845: LD_ADDR_VAR 0 19
23849: PUSH
23850: EMPTY
23851: ST_TO_ADDR
// for j in f do
23852: LD_ADDR_VAR 0 9
23856: PUSH
23857: LD_VAR 0 12
23861: PUSH
23862: FOR_IN
23863: IFFALSE 23936
// if GetBType ( j ) = b_bunker then
23865: LD_VAR 0 9
23869: PPUSH
23870: CALL_OW 266
23874: PUSH
23875: LD_INT 32
23877: EQUAL
23878: IFFALSE 23905
// tmp := Insert ( tmp , 1 , j ) else
23880: LD_ADDR_VAR 0 19
23884: PUSH
23885: LD_VAR 0 19
23889: PPUSH
23890: LD_INT 1
23892: PPUSH
23893: LD_VAR 0 9
23897: PPUSH
23898: CALL_OW 2
23902: ST_TO_ADDR
23903: GO 23934
// tmp := Insert ( tmp , tmp + 1 , j ) ;
23905: LD_ADDR_VAR 0 19
23909: PUSH
23910: LD_VAR 0 19
23914: PPUSH
23915: LD_VAR 0 19
23919: PUSH
23920: LD_INT 1
23922: PLUS
23923: PPUSH
23924: LD_VAR 0 9
23928: PPUSH
23929: CALL_OW 2
23933: ST_TO_ADDR
23934: GO 23862
23936: POP
23937: POP
// if tmp then
23938: LD_VAR 0 19
23942: IFFALSE 23954
// f := tmp ;
23944: LD_ADDR_VAR 0 12
23948: PUSH
23949: LD_VAR 0 19
23953: ST_TO_ADDR
// end ; x := personel [ i ] ;
23954: LD_ADDR_VAR 0 13
23958: PUSH
23959: LD_VAR 0 6
23963: PUSH
23964: LD_VAR 0 8
23968: ARRAY
23969: ST_TO_ADDR
// if x = - 1 then
23970: LD_VAR 0 13
23974: PUSH
23975: LD_INT 1
23977: NEG
23978: EQUAL
23979: IFFALSE 24188
// begin for j in f do
23981: LD_ADDR_VAR 0 9
23985: PUSH
23986: LD_VAR 0 12
23990: PUSH
23991: FOR_IN
23992: IFFALSE 24184
// repeat InitHc ;
23994: CALL_OW 19
// if GetBType ( j ) = b_barracks then
23998: LD_VAR 0 9
24002: PPUSH
24003: CALL_OW 266
24007: PUSH
24008: LD_INT 5
24010: EQUAL
24011: IFFALSE 24081
// begin if UnitsInside ( j ) < 3 then
24013: LD_VAR 0 9
24017: PPUSH
24018: CALL_OW 313
24022: PUSH
24023: LD_INT 3
24025: LESS
24026: IFFALSE 24062
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24028: LD_INT 0
24030: PPUSH
24031: LD_INT 5
24033: PUSH
24034: LD_INT 8
24036: PUSH
24037: LD_INT 9
24039: PUSH
24040: EMPTY
24041: LIST
24042: LIST
24043: LIST
24044: PUSH
24045: LD_VAR 0 17
24049: ARRAY
24050: PPUSH
24051: LD_VAR 0 4
24055: PPUSH
24056: CALL_OW 380
24060: GO 24079
// PrepareHuman ( false , i , skill ) ;
24062: LD_INT 0
24064: PPUSH
24065: LD_VAR 0 8
24069: PPUSH
24070: LD_VAR 0 4
24074: PPUSH
24075: CALL_OW 380
// end else
24079: GO 24098
// PrepareHuman ( false , i , skill ) ;
24081: LD_INT 0
24083: PPUSH
24084: LD_VAR 0 8
24088: PPUSH
24089: LD_VAR 0 4
24093: PPUSH
24094: CALL_OW 380
// un := CreateHuman ;
24098: LD_ADDR_VAR 0 14
24102: PUSH
24103: CALL_OW 44
24107: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24108: LD_ADDR_VAR 0 7
24112: PUSH
24113: LD_VAR 0 7
24117: PPUSH
24118: LD_INT 1
24120: PPUSH
24121: LD_VAR 0 14
24125: PPUSH
24126: CALL_OW 2
24130: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24131: LD_VAR 0 14
24135: PPUSH
24136: LD_VAR 0 9
24140: PPUSH
24141: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24145: LD_VAR 0 9
24149: PPUSH
24150: CALL_OW 313
24154: PUSH
24155: LD_INT 6
24157: EQUAL
24158: PUSH
24159: LD_VAR 0 9
24163: PPUSH
24164: CALL_OW 266
24168: PUSH
24169: LD_INT 32
24171: PUSH
24172: LD_INT 31
24174: PUSH
24175: EMPTY
24176: LIST
24177: LIST
24178: IN
24179: OR
24180: IFFALSE 23994
24182: GO 23991
24184: POP
24185: POP
// end else
24186: GO 24568
// for j = 1 to x do
24188: LD_ADDR_VAR 0 9
24192: PUSH
24193: DOUBLE
24194: LD_INT 1
24196: DEC
24197: ST_TO_ADDR
24198: LD_VAR 0 13
24202: PUSH
24203: FOR_TO
24204: IFFALSE 24566
// begin InitHc ;
24206: CALL_OW 19
// if not f then
24210: LD_VAR 0 12
24214: NOT
24215: IFFALSE 24304
// begin PrepareHuman ( false , i , skill ) ;
24217: LD_INT 0
24219: PPUSH
24220: LD_VAR 0 8
24224: PPUSH
24225: LD_VAR 0 4
24229: PPUSH
24230: CALL_OW 380
// un := CreateHuman ;
24234: LD_ADDR_VAR 0 14
24238: PUSH
24239: CALL_OW 44
24243: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24244: LD_ADDR_VAR 0 7
24248: PUSH
24249: LD_VAR 0 7
24253: PPUSH
24254: LD_INT 1
24256: PPUSH
24257: LD_VAR 0 14
24261: PPUSH
24262: CALL_OW 2
24266: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24267: LD_VAR 0 14
24271: PPUSH
24272: LD_VAR 0 1
24276: PPUSH
24277: CALL_OW 250
24281: PPUSH
24282: LD_VAR 0 1
24286: PPUSH
24287: CALL_OW 251
24291: PPUSH
24292: LD_INT 10
24294: PPUSH
24295: LD_INT 0
24297: PPUSH
24298: CALL_OW 50
// continue ;
24302: GO 24203
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24304: LD_VAR 0 12
24308: PUSH
24309: LD_INT 1
24311: ARRAY
24312: PPUSH
24313: CALL_OW 313
24317: PUSH
24318: LD_VAR 0 12
24322: PUSH
24323: LD_INT 1
24325: ARRAY
24326: PPUSH
24327: CALL_OW 266
24331: PUSH
24332: LD_INT 32
24334: PUSH
24335: LD_INT 31
24337: PUSH
24338: EMPTY
24339: LIST
24340: LIST
24341: IN
24342: AND
24343: PUSH
24344: LD_VAR 0 12
24348: PUSH
24349: LD_INT 1
24351: ARRAY
24352: PPUSH
24353: CALL_OW 313
24357: PUSH
24358: LD_INT 6
24360: EQUAL
24361: OR
24362: IFFALSE 24382
// f := Delete ( f , 1 ) ;
24364: LD_ADDR_VAR 0 12
24368: PUSH
24369: LD_VAR 0 12
24373: PPUSH
24374: LD_INT 1
24376: PPUSH
24377: CALL_OW 3
24381: ST_TO_ADDR
// if not f then
24382: LD_VAR 0 12
24386: NOT
24387: IFFALSE 24405
// begin x := x + 2 ;
24389: LD_ADDR_VAR 0 13
24393: PUSH
24394: LD_VAR 0 13
24398: PUSH
24399: LD_INT 2
24401: PLUS
24402: ST_TO_ADDR
// continue ;
24403: GO 24203
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24405: LD_VAR 0 12
24409: PUSH
24410: LD_INT 1
24412: ARRAY
24413: PPUSH
24414: CALL_OW 266
24418: PUSH
24419: LD_INT 5
24421: EQUAL
24422: IFFALSE 24496
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24424: LD_VAR 0 12
24428: PUSH
24429: LD_INT 1
24431: ARRAY
24432: PPUSH
24433: CALL_OW 313
24437: PUSH
24438: LD_INT 3
24440: LESS
24441: IFFALSE 24477
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24443: LD_INT 0
24445: PPUSH
24446: LD_INT 5
24448: PUSH
24449: LD_INT 8
24451: PUSH
24452: LD_INT 9
24454: PUSH
24455: EMPTY
24456: LIST
24457: LIST
24458: LIST
24459: PUSH
24460: LD_VAR 0 17
24464: ARRAY
24465: PPUSH
24466: LD_VAR 0 4
24470: PPUSH
24471: CALL_OW 380
24475: GO 24494
// PrepareHuman ( false , i , skill ) ;
24477: LD_INT 0
24479: PPUSH
24480: LD_VAR 0 8
24484: PPUSH
24485: LD_VAR 0 4
24489: PPUSH
24490: CALL_OW 380
// end else
24494: GO 24513
// PrepareHuman ( false , i , skill ) ;
24496: LD_INT 0
24498: PPUSH
24499: LD_VAR 0 8
24503: PPUSH
24504: LD_VAR 0 4
24508: PPUSH
24509: CALL_OW 380
// un := CreateHuman ;
24513: LD_ADDR_VAR 0 14
24517: PUSH
24518: CALL_OW 44
24522: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24523: LD_ADDR_VAR 0 7
24527: PUSH
24528: LD_VAR 0 7
24532: PPUSH
24533: LD_INT 1
24535: PPUSH
24536: LD_VAR 0 14
24540: PPUSH
24541: CALL_OW 2
24545: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24546: LD_VAR 0 14
24550: PPUSH
24551: LD_VAR 0 12
24555: PUSH
24556: LD_INT 1
24558: ARRAY
24559: PPUSH
24560: CALL_OW 52
// end ;
24564: GO 24203
24566: POP
24567: POP
// end ;
24568: GO 23505
24570: POP
24571: POP
// result := result ^ buildings ;
24572: LD_ADDR_VAR 0 7
24576: PUSH
24577: LD_VAR 0 7
24581: PUSH
24582: LD_VAR 0 18
24586: ADD
24587: ST_TO_ADDR
// end else
24588: GO 24731
// begin for i = 1 to personel do
24590: LD_ADDR_VAR 0 8
24594: PUSH
24595: DOUBLE
24596: LD_INT 1
24598: DEC
24599: ST_TO_ADDR
24600: LD_VAR 0 6
24604: PUSH
24605: FOR_TO
24606: IFFALSE 24729
// begin if i > 4 then
24608: LD_VAR 0 8
24612: PUSH
24613: LD_INT 4
24615: GREATER
24616: IFFALSE 24620
// break ;
24618: GO 24729
// x := personel [ i ] ;
24620: LD_ADDR_VAR 0 13
24624: PUSH
24625: LD_VAR 0 6
24629: PUSH
24630: LD_VAR 0 8
24634: ARRAY
24635: ST_TO_ADDR
// if x = - 1 then
24636: LD_VAR 0 13
24640: PUSH
24641: LD_INT 1
24643: NEG
24644: EQUAL
24645: IFFALSE 24649
// continue ;
24647: GO 24605
// PrepareHuman ( false , i , skill ) ;
24649: LD_INT 0
24651: PPUSH
24652: LD_VAR 0 8
24656: PPUSH
24657: LD_VAR 0 4
24661: PPUSH
24662: CALL_OW 380
// un := CreateHuman ;
24666: LD_ADDR_VAR 0 14
24670: PUSH
24671: CALL_OW 44
24675: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24676: LD_VAR 0 14
24680: PPUSH
24681: LD_VAR 0 1
24685: PPUSH
24686: CALL_OW 250
24690: PPUSH
24691: LD_VAR 0 1
24695: PPUSH
24696: CALL_OW 251
24700: PPUSH
24701: LD_INT 10
24703: PPUSH
24704: LD_INT 0
24706: PPUSH
24707: CALL_OW 50
// result := result ^ un ;
24711: LD_ADDR_VAR 0 7
24715: PUSH
24716: LD_VAR 0 7
24720: PUSH
24721: LD_VAR 0 14
24725: ADD
24726: ST_TO_ADDR
// end ;
24727: GO 24605
24729: POP
24730: POP
// end ; end ;
24731: LD_VAR 0 7
24735: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24736: LD_INT 0
24738: PPUSH
24739: PPUSH
24740: PPUSH
24741: PPUSH
24742: PPUSH
24743: PPUSH
24744: PPUSH
24745: PPUSH
24746: PPUSH
24747: PPUSH
24748: PPUSH
24749: PPUSH
24750: PPUSH
24751: PPUSH
24752: PPUSH
24753: PPUSH
// result := false ;
24754: LD_ADDR_VAR 0 3
24758: PUSH
24759: LD_INT 0
24761: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24762: LD_VAR 0 1
24766: NOT
24767: PUSH
24768: LD_VAR 0 1
24772: PPUSH
24773: CALL_OW 266
24777: PUSH
24778: LD_INT 32
24780: PUSH
24781: LD_INT 33
24783: PUSH
24784: EMPTY
24785: LIST
24786: LIST
24787: IN
24788: NOT
24789: OR
24790: IFFALSE 24794
// exit ;
24792: GO 25903
// nat := GetNation ( tower ) ;
24794: LD_ADDR_VAR 0 12
24798: PUSH
24799: LD_VAR 0 1
24803: PPUSH
24804: CALL_OW 248
24808: ST_TO_ADDR
// side := GetSide ( tower ) ;
24809: LD_ADDR_VAR 0 16
24813: PUSH
24814: LD_VAR 0 1
24818: PPUSH
24819: CALL_OW 255
24823: ST_TO_ADDR
// x := GetX ( tower ) ;
24824: LD_ADDR_VAR 0 10
24828: PUSH
24829: LD_VAR 0 1
24833: PPUSH
24834: CALL_OW 250
24838: ST_TO_ADDR
// y := GetY ( tower ) ;
24839: LD_ADDR_VAR 0 11
24843: PUSH
24844: LD_VAR 0 1
24848: PPUSH
24849: CALL_OW 251
24853: ST_TO_ADDR
// if not x or not y then
24854: LD_VAR 0 10
24858: NOT
24859: PUSH
24860: LD_VAR 0 11
24864: NOT
24865: OR
24866: IFFALSE 24870
// exit ;
24868: GO 25903
// weapon := 0 ;
24870: LD_ADDR_VAR 0 18
24874: PUSH
24875: LD_INT 0
24877: ST_TO_ADDR
// fac_list := [ ] ;
24878: LD_ADDR_VAR 0 17
24882: PUSH
24883: EMPTY
24884: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
24885: LD_ADDR_VAR 0 6
24889: PUSH
24890: LD_VAR 0 1
24894: PPUSH
24895: CALL_OW 274
24899: PPUSH
24900: LD_VAR 0 2
24904: PPUSH
24905: LD_INT 0
24907: PPUSH
24908: CALL 22474 0 3
24912: PPUSH
24913: LD_INT 30
24915: PUSH
24916: LD_INT 3
24918: PUSH
24919: EMPTY
24920: LIST
24921: LIST
24922: PPUSH
24923: CALL_OW 72
24927: ST_TO_ADDR
// if not factories then
24928: LD_VAR 0 6
24932: NOT
24933: IFFALSE 24937
// exit ;
24935: GO 25903
// for i in factories do
24937: LD_ADDR_VAR 0 8
24941: PUSH
24942: LD_VAR 0 6
24946: PUSH
24947: FOR_IN
24948: IFFALSE 24973
// fac_list := fac_list union AvailableWeaponList ( i ) ;
24950: LD_ADDR_VAR 0 17
24954: PUSH
24955: LD_VAR 0 17
24959: PUSH
24960: LD_VAR 0 8
24964: PPUSH
24965: CALL_OW 478
24969: UNION
24970: ST_TO_ADDR
24971: GO 24947
24973: POP
24974: POP
// if not fac_list then
24975: LD_VAR 0 17
24979: NOT
24980: IFFALSE 24984
// exit ;
24982: GO 25903
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
24984: LD_ADDR_VAR 0 5
24988: PUSH
24989: LD_INT 4
24991: PUSH
24992: LD_INT 5
24994: PUSH
24995: LD_INT 9
24997: PUSH
24998: LD_INT 10
25000: PUSH
25001: LD_INT 6
25003: PUSH
25004: LD_INT 7
25006: PUSH
25007: LD_INT 11
25009: PUSH
25010: EMPTY
25011: LIST
25012: LIST
25013: LIST
25014: LIST
25015: LIST
25016: LIST
25017: LIST
25018: PUSH
25019: LD_INT 27
25021: PUSH
25022: LD_INT 28
25024: PUSH
25025: LD_INT 26
25027: PUSH
25028: LD_INT 30
25030: PUSH
25031: EMPTY
25032: LIST
25033: LIST
25034: LIST
25035: LIST
25036: PUSH
25037: LD_INT 43
25039: PUSH
25040: LD_INT 44
25042: PUSH
25043: LD_INT 46
25045: PUSH
25046: LD_INT 45
25048: PUSH
25049: LD_INT 47
25051: PUSH
25052: LD_INT 49
25054: PUSH
25055: EMPTY
25056: LIST
25057: LIST
25058: LIST
25059: LIST
25060: LIST
25061: LIST
25062: PUSH
25063: EMPTY
25064: LIST
25065: LIST
25066: LIST
25067: PUSH
25068: LD_VAR 0 12
25072: ARRAY
25073: ST_TO_ADDR
// list := list isect fac_list ;
25074: LD_ADDR_VAR 0 5
25078: PUSH
25079: LD_VAR 0 5
25083: PUSH
25084: LD_VAR 0 17
25088: ISECT
25089: ST_TO_ADDR
// if not list then
25090: LD_VAR 0 5
25094: NOT
25095: IFFALSE 25099
// exit ;
25097: GO 25903
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25099: LD_VAR 0 12
25103: PUSH
25104: LD_INT 3
25106: EQUAL
25107: PUSH
25108: LD_INT 49
25110: PUSH
25111: LD_VAR 0 5
25115: IN
25116: AND
25117: PUSH
25118: LD_INT 31
25120: PPUSH
25121: LD_VAR 0 16
25125: PPUSH
25126: CALL_OW 321
25130: PUSH
25131: LD_INT 2
25133: EQUAL
25134: AND
25135: IFFALSE 25195
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25137: LD_INT 22
25139: PUSH
25140: LD_VAR 0 16
25144: PUSH
25145: EMPTY
25146: LIST
25147: LIST
25148: PUSH
25149: LD_INT 35
25151: PUSH
25152: LD_INT 49
25154: PUSH
25155: EMPTY
25156: LIST
25157: LIST
25158: PUSH
25159: LD_INT 91
25161: PUSH
25162: LD_VAR 0 1
25166: PUSH
25167: LD_INT 10
25169: PUSH
25170: EMPTY
25171: LIST
25172: LIST
25173: LIST
25174: PUSH
25175: EMPTY
25176: LIST
25177: LIST
25178: LIST
25179: PPUSH
25180: CALL_OW 69
25184: NOT
25185: IFFALSE 25195
// weapon := ru_time_lapser ;
25187: LD_ADDR_VAR 0 18
25191: PUSH
25192: LD_INT 49
25194: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25195: LD_VAR 0 12
25199: PUSH
25200: LD_INT 1
25202: PUSH
25203: LD_INT 2
25205: PUSH
25206: EMPTY
25207: LIST
25208: LIST
25209: IN
25210: PUSH
25211: LD_INT 11
25213: PUSH
25214: LD_VAR 0 5
25218: IN
25219: PUSH
25220: LD_INT 30
25222: PUSH
25223: LD_VAR 0 5
25227: IN
25228: OR
25229: AND
25230: PUSH
25231: LD_INT 6
25233: PPUSH
25234: LD_VAR 0 16
25238: PPUSH
25239: CALL_OW 321
25243: PUSH
25244: LD_INT 2
25246: EQUAL
25247: AND
25248: IFFALSE 25413
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25250: LD_INT 22
25252: PUSH
25253: LD_VAR 0 16
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PUSH
25262: LD_INT 2
25264: PUSH
25265: LD_INT 35
25267: PUSH
25268: LD_INT 11
25270: PUSH
25271: EMPTY
25272: LIST
25273: LIST
25274: PUSH
25275: LD_INT 35
25277: PUSH
25278: LD_INT 30
25280: PUSH
25281: EMPTY
25282: LIST
25283: LIST
25284: PUSH
25285: EMPTY
25286: LIST
25287: LIST
25288: LIST
25289: PUSH
25290: LD_INT 91
25292: PUSH
25293: LD_VAR 0 1
25297: PUSH
25298: LD_INT 18
25300: PUSH
25301: EMPTY
25302: LIST
25303: LIST
25304: LIST
25305: PUSH
25306: EMPTY
25307: LIST
25308: LIST
25309: LIST
25310: PPUSH
25311: CALL_OW 69
25315: NOT
25316: PUSH
25317: LD_INT 22
25319: PUSH
25320: LD_VAR 0 16
25324: PUSH
25325: EMPTY
25326: LIST
25327: LIST
25328: PUSH
25329: LD_INT 2
25331: PUSH
25332: LD_INT 30
25334: PUSH
25335: LD_INT 32
25337: PUSH
25338: EMPTY
25339: LIST
25340: LIST
25341: PUSH
25342: LD_INT 30
25344: PUSH
25345: LD_INT 33
25347: PUSH
25348: EMPTY
25349: LIST
25350: LIST
25351: PUSH
25352: EMPTY
25353: LIST
25354: LIST
25355: LIST
25356: PUSH
25357: LD_INT 91
25359: PUSH
25360: LD_VAR 0 1
25364: PUSH
25365: LD_INT 12
25367: PUSH
25368: EMPTY
25369: LIST
25370: LIST
25371: LIST
25372: PUSH
25373: EMPTY
25374: LIST
25375: LIST
25376: LIST
25377: PUSH
25378: EMPTY
25379: LIST
25380: PPUSH
25381: CALL_OW 69
25385: PUSH
25386: LD_INT 2
25388: GREATER
25389: AND
25390: IFFALSE 25413
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25392: LD_ADDR_VAR 0 18
25396: PUSH
25397: LD_INT 11
25399: PUSH
25400: LD_INT 30
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: LD_VAR 0 12
25411: ARRAY
25412: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25413: LD_VAR 0 18
25417: NOT
25418: PUSH
25419: LD_INT 40
25421: PPUSH
25422: LD_VAR 0 16
25426: PPUSH
25427: CALL_OW 321
25431: PUSH
25432: LD_INT 2
25434: EQUAL
25435: AND
25436: PUSH
25437: LD_INT 7
25439: PUSH
25440: LD_VAR 0 5
25444: IN
25445: PUSH
25446: LD_INT 28
25448: PUSH
25449: LD_VAR 0 5
25453: IN
25454: OR
25455: PUSH
25456: LD_INT 45
25458: PUSH
25459: LD_VAR 0 5
25463: IN
25464: OR
25465: AND
25466: IFFALSE 25720
// begin hex := GetHexInfo ( x , y ) ;
25468: LD_ADDR_VAR 0 4
25472: PUSH
25473: LD_VAR 0 10
25477: PPUSH
25478: LD_VAR 0 11
25482: PPUSH
25483: CALL_OW 546
25487: ST_TO_ADDR
// if hex [ 1 ] then
25488: LD_VAR 0 4
25492: PUSH
25493: LD_INT 1
25495: ARRAY
25496: IFFALSE 25500
// exit ;
25498: GO 25903
// height := hex [ 2 ] ;
25500: LD_ADDR_VAR 0 15
25504: PUSH
25505: LD_VAR 0 4
25509: PUSH
25510: LD_INT 2
25512: ARRAY
25513: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25514: LD_ADDR_VAR 0 14
25518: PUSH
25519: LD_INT 0
25521: PUSH
25522: LD_INT 2
25524: PUSH
25525: LD_INT 3
25527: PUSH
25528: LD_INT 5
25530: PUSH
25531: EMPTY
25532: LIST
25533: LIST
25534: LIST
25535: LIST
25536: ST_TO_ADDR
// for i in tmp do
25537: LD_ADDR_VAR 0 8
25541: PUSH
25542: LD_VAR 0 14
25546: PUSH
25547: FOR_IN
25548: IFFALSE 25718
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25550: LD_ADDR_VAR 0 9
25554: PUSH
25555: LD_VAR 0 10
25559: PPUSH
25560: LD_VAR 0 8
25564: PPUSH
25565: LD_INT 5
25567: PPUSH
25568: CALL_OW 272
25572: PUSH
25573: LD_VAR 0 11
25577: PPUSH
25578: LD_VAR 0 8
25582: PPUSH
25583: LD_INT 5
25585: PPUSH
25586: CALL_OW 273
25590: PUSH
25591: EMPTY
25592: LIST
25593: LIST
25594: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25595: LD_VAR 0 9
25599: PUSH
25600: LD_INT 1
25602: ARRAY
25603: PPUSH
25604: LD_VAR 0 9
25608: PUSH
25609: LD_INT 2
25611: ARRAY
25612: PPUSH
25613: CALL_OW 488
25617: IFFALSE 25716
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25619: LD_ADDR_VAR 0 4
25623: PUSH
25624: LD_VAR 0 9
25628: PUSH
25629: LD_INT 1
25631: ARRAY
25632: PPUSH
25633: LD_VAR 0 9
25637: PUSH
25638: LD_INT 2
25640: ARRAY
25641: PPUSH
25642: CALL_OW 546
25646: ST_TO_ADDR
// if hex [ 1 ] then
25647: LD_VAR 0 4
25651: PUSH
25652: LD_INT 1
25654: ARRAY
25655: IFFALSE 25659
// continue ;
25657: GO 25547
// h := hex [ 2 ] ;
25659: LD_ADDR_VAR 0 13
25663: PUSH
25664: LD_VAR 0 4
25668: PUSH
25669: LD_INT 2
25671: ARRAY
25672: ST_TO_ADDR
// if h + 7 < height then
25673: LD_VAR 0 13
25677: PUSH
25678: LD_INT 7
25680: PLUS
25681: PUSH
25682: LD_VAR 0 15
25686: LESS
25687: IFFALSE 25716
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25689: LD_ADDR_VAR 0 18
25693: PUSH
25694: LD_INT 7
25696: PUSH
25697: LD_INT 28
25699: PUSH
25700: LD_INT 45
25702: PUSH
25703: EMPTY
25704: LIST
25705: LIST
25706: LIST
25707: PUSH
25708: LD_VAR 0 12
25712: ARRAY
25713: ST_TO_ADDR
// break ;
25714: GO 25718
// end ; end ; end ;
25716: GO 25547
25718: POP
25719: POP
// end ; if not weapon then
25720: LD_VAR 0 18
25724: NOT
25725: IFFALSE 25785
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25727: LD_ADDR_VAR 0 5
25731: PUSH
25732: LD_VAR 0 5
25736: PUSH
25737: LD_INT 11
25739: PUSH
25740: LD_INT 30
25742: PUSH
25743: LD_INT 49
25745: PUSH
25746: EMPTY
25747: LIST
25748: LIST
25749: LIST
25750: DIFF
25751: ST_TO_ADDR
// if not list then
25752: LD_VAR 0 5
25756: NOT
25757: IFFALSE 25761
// exit ;
25759: GO 25903
// weapon := list [ rand ( 1 , list ) ] ;
25761: LD_ADDR_VAR 0 18
25765: PUSH
25766: LD_VAR 0 5
25770: PUSH
25771: LD_INT 1
25773: PPUSH
25774: LD_VAR 0 5
25778: PPUSH
25779: CALL_OW 12
25783: ARRAY
25784: ST_TO_ADDR
// end ; if weapon then
25785: LD_VAR 0 18
25789: IFFALSE 25903
// begin tmp := CostOfWeapon ( weapon ) ;
25791: LD_ADDR_VAR 0 14
25795: PUSH
25796: LD_VAR 0 18
25800: PPUSH
25801: CALL_OW 451
25805: ST_TO_ADDR
// j := GetBase ( tower ) ;
25806: LD_ADDR_VAR 0 9
25810: PUSH
25811: LD_VAR 0 1
25815: PPUSH
25816: CALL_OW 274
25820: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
25821: LD_VAR 0 9
25825: PPUSH
25826: LD_INT 1
25828: PPUSH
25829: CALL_OW 275
25833: PUSH
25834: LD_VAR 0 14
25838: PUSH
25839: LD_INT 1
25841: ARRAY
25842: GREATEREQUAL
25843: PUSH
25844: LD_VAR 0 9
25848: PPUSH
25849: LD_INT 2
25851: PPUSH
25852: CALL_OW 275
25856: PUSH
25857: LD_VAR 0 14
25861: PUSH
25862: LD_INT 2
25864: ARRAY
25865: GREATEREQUAL
25866: AND
25867: PUSH
25868: LD_VAR 0 9
25872: PPUSH
25873: LD_INT 3
25875: PPUSH
25876: CALL_OW 275
25880: PUSH
25881: LD_VAR 0 14
25885: PUSH
25886: LD_INT 3
25888: ARRAY
25889: GREATEREQUAL
25890: AND
25891: IFFALSE 25903
// result := weapon ;
25893: LD_ADDR_VAR 0 3
25897: PUSH
25898: LD_VAR 0 18
25902: ST_TO_ADDR
// end ; end ;
25903: LD_VAR 0 3
25907: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25908: LD_INT 0
25910: PPUSH
25911: PPUSH
// result := true ;
25912: LD_ADDR_VAR 0 3
25916: PUSH
25917: LD_INT 1
25919: ST_TO_ADDR
// if array1 = array2 then
25920: LD_VAR 0 1
25924: PUSH
25925: LD_VAR 0 2
25929: EQUAL
25930: IFFALSE 25990
// begin for i = 1 to array1 do
25932: LD_ADDR_VAR 0 4
25936: PUSH
25937: DOUBLE
25938: LD_INT 1
25940: DEC
25941: ST_TO_ADDR
25942: LD_VAR 0 1
25946: PUSH
25947: FOR_TO
25948: IFFALSE 25986
// if array1 [ i ] <> array2 [ i ] then
25950: LD_VAR 0 1
25954: PUSH
25955: LD_VAR 0 4
25959: ARRAY
25960: PUSH
25961: LD_VAR 0 2
25965: PUSH
25966: LD_VAR 0 4
25970: ARRAY
25971: NONEQUAL
25972: IFFALSE 25984
// begin result := false ;
25974: LD_ADDR_VAR 0 3
25978: PUSH
25979: LD_INT 0
25981: ST_TO_ADDR
// break ;
25982: GO 25986
// end ;
25984: GO 25947
25986: POP
25987: POP
// end else
25988: GO 25998
// result := false ;
25990: LD_ADDR_VAR 0 3
25994: PUSH
25995: LD_INT 0
25997: ST_TO_ADDR
// end ;
25998: LD_VAR 0 3
26002: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
26003: LD_INT 0
26005: PPUSH
26006: PPUSH
// if not array1 or not array2 then
26007: LD_VAR 0 1
26011: NOT
26012: PUSH
26013: LD_VAR 0 2
26017: NOT
26018: OR
26019: IFFALSE 26023
// exit ;
26021: GO 26087
// result := true ;
26023: LD_ADDR_VAR 0 3
26027: PUSH
26028: LD_INT 1
26030: ST_TO_ADDR
// for i = 1 to array1 do
26031: LD_ADDR_VAR 0 4
26035: PUSH
26036: DOUBLE
26037: LD_INT 1
26039: DEC
26040: ST_TO_ADDR
26041: LD_VAR 0 1
26045: PUSH
26046: FOR_TO
26047: IFFALSE 26085
// if array1 [ i ] <> array2 [ i ] then
26049: LD_VAR 0 1
26053: PUSH
26054: LD_VAR 0 4
26058: ARRAY
26059: PUSH
26060: LD_VAR 0 2
26064: PUSH
26065: LD_VAR 0 4
26069: ARRAY
26070: NONEQUAL
26071: IFFALSE 26083
// begin result := false ;
26073: LD_ADDR_VAR 0 3
26077: PUSH
26078: LD_INT 0
26080: ST_TO_ADDR
// break ;
26081: GO 26085
// end ;
26083: GO 26046
26085: POP
26086: POP
// end ;
26087: LD_VAR 0 3
26091: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26092: LD_INT 0
26094: PPUSH
26095: PPUSH
26096: PPUSH
// pom := GetBase ( fac ) ;
26097: LD_ADDR_VAR 0 5
26101: PUSH
26102: LD_VAR 0 1
26106: PPUSH
26107: CALL_OW 274
26111: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26112: LD_ADDR_VAR 0 4
26116: PUSH
26117: LD_VAR 0 2
26121: PUSH
26122: LD_INT 1
26124: ARRAY
26125: PPUSH
26126: LD_VAR 0 2
26130: PUSH
26131: LD_INT 2
26133: ARRAY
26134: PPUSH
26135: LD_VAR 0 2
26139: PUSH
26140: LD_INT 3
26142: ARRAY
26143: PPUSH
26144: LD_VAR 0 2
26148: PUSH
26149: LD_INT 4
26151: ARRAY
26152: PPUSH
26153: CALL_OW 449
26157: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26158: LD_ADDR_VAR 0 3
26162: PUSH
26163: LD_VAR 0 5
26167: PPUSH
26168: LD_INT 1
26170: PPUSH
26171: CALL_OW 275
26175: PUSH
26176: LD_VAR 0 4
26180: PUSH
26181: LD_INT 1
26183: ARRAY
26184: GREATEREQUAL
26185: PUSH
26186: LD_VAR 0 5
26190: PPUSH
26191: LD_INT 2
26193: PPUSH
26194: CALL_OW 275
26198: PUSH
26199: LD_VAR 0 4
26203: PUSH
26204: LD_INT 2
26206: ARRAY
26207: GREATEREQUAL
26208: AND
26209: PUSH
26210: LD_VAR 0 5
26214: PPUSH
26215: LD_INT 3
26217: PPUSH
26218: CALL_OW 275
26222: PUSH
26223: LD_VAR 0 4
26227: PUSH
26228: LD_INT 3
26230: ARRAY
26231: GREATEREQUAL
26232: AND
26233: ST_TO_ADDR
// end ;
26234: LD_VAR 0 3
26238: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26239: LD_INT 0
26241: PPUSH
26242: PPUSH
26243: PPUSH
26244: PPUSH
// pom := GetBase ( building ) ;
26245: LD_ADDR_VAR 0 3
26249: PUSH
26250: LD_VAR 0 1
26254: PPUSH
26255: CALL_OW 274
26259: ST_TO_ADDR
// if not pom then
26260: LD_VAR 0 3
26264: NOT
26265: IFFALSE 26269
// exit ;
26267: GO 26439
// btype := GetBType ( building ) ;
26269: LD_ADDR_VAR 0 5
26273: PUSH
26274: LD_VAR 0 1
26278: PPUSH
26279: CALL_OW 266
26283: ST_TO_ADDR
// if btype = b_armoury then
26284: LD_VAR 0 5
26288: PUSH
26289: LD_INT 4
26291: EQUAL
26292: IFFALSE 26302
// btype := b_barracks ;
26294: LD_ADDR_VAR 0 5
26298: PUSH
26299: LD_INT 5
26301: ST_TO_ADDR
// if btype = b_depot then
26302: LD_VAR 0 5
26306: PUSH
26307: LD_INT 0
26309: EQUAL
26310: IFFALSE 26320
// btype := b_warehouse ;
26312: LD_ADDR_VAR 0 5
26316: PUSH
26317: LD_INT 1
26319: ST_TO_ADDR
// if btype = b_workshop then
26320: LD_VAR 0 5
26324: PUSH
26325: LD_INT 2
26327: EQUAL
26328: IFFALSE 26338
// btype := b_factory ;
26330: LD_ADDR_VAR 0 5
26334: PUSH
26335: LD_INT 3
26337: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26338: LD_ADDR_VAR 0 4
26342: PUSH
26343: LD_VAR 0 5
26347: PPUSH
26348: LD_VAR 0 1
26352: PPUSH
26353: CALL_OW 248
26357: PPUSH
26358: CALL_OW 450
26362: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26363: LD_ADDR_VAR 0 2
26367: PUSH
26368: LD_VAR 0 3
26372: PPUSH
26373: LD_INT 1
26375: PPUSH
26376: CALL_OW 275
26380: PUSH
26381: LD_VAR 0 4
26385: PUSH
26386: LD_INT 1
26388: ARRAY
26389: GREATEREQUAL
26390: PUSH
26391: LD_VAR 0 3
26395: PPUSH
26396: LD_INT 2
26398: PPUSH
26399: CALL_OW 275
26403: PUSH
26404: LD_VAR 0 4
26408: PUSH
26409: LD_INT 2
26411: ARRAY
26412: GREATEREQUAL
26413: AND
26414: PUSH
26415: LD_VAR 0 3
26419: PPUSH
26420: LD_INT 3
26422: PPUSH
26423: CALL_OW 275
26427: PUSH
26428: LD_VAR 0 4
26432: PUSH
26433: LD_INT 3
26435: ARRAY
26436: GREATEREQUAL
26437: AND
26438: ST_TO_ADDR
// end ;
26439: LD_VAR 0 2
26443: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26444: LD_INT 0
26446: PPUSH
26447: PPUSH
26448: PPUSH
// pom := GetBase ( building ) ;
26449: LD_ADDR_VAR 0 4
26453: PUSH
26454: LD_VAR 0 1
26458: PPUSH
26459: CALL_OW 274
26463: ST_TO_ADDR
// if not pom then
26464: LD_VAR 0 4
26468: NOT
26469: IFFALSE 26473
// exit ;
26471: GO 26574
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26473: LD_ADDR_VAR 0 5
26477: PUSH
26478: LD_VAR 0 2
26482: PPUSH
26483: LD_VAR 0 1
26487: PPUSH
26488: CALL_OW 248
26492: PPUSH
26493: CALL_OW 450
26497: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26498: LD_ADDR_VAR 0 3
26502: PUSH
26503: LD_VAR 0 4
26507: PPUSH
26508: LD_INT 1
26510: PPUSH
26511: CALL_OW 275
26515: PUSH
26516: LD_VAR 0 5
26520: PUSH
26521: LD_INT 1
26523: ARRAY
26524: GREATEREQUAL
26525: PUSH
26526: LD_VAR 0 4
26530: PPUSH
26531: LD_INT 2
26533: PPUSH
26534: CALL_OW 275
26538: PUSH
26539: LD_VAR 0 5
26543: PUSH
26544: LD_INT 2
26546: ARRAY
26547: GREATEREQUAL
26548: AND
26549: PUSH
26550: LD_VAR 0 4
26554: PPUSH
26555: LD_INT 3
26557: PPUSH
26558: CALL_OW 275
26562: PUSH
26563: LD_VAR 0 5
26567: PUSH
26568: LD_INT 3
26570: ARRAY
26571: GREATEREQUAL
26572: AND
26573: ST_TO_ADDR
// end ;
26574: LD_VAR 0 3
26578: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26579: LD_INT 0
26581: PPUSH
26582: PPUSH
26583: PPUSH
26584: PPUSH
26585: PPUSH
26586: PPUSH
26587: PPUSH
26588: PPUSH
26589: PPUSH
26590: PPUSH
26591: PPUSH
// result := false ;
26592: LD_ADDR_VAR 0 8
26596: PUSH
26597: LD_INT 0
26599: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26600: LD_VAR 0 5
26604: NOT
26605: PUSH
26606: LD_VAR 0 1
26610: NOT
26611: OR
26612: PUSH
26613: LD_VAR 0 2
26617: NOT
26618: OR
26619: PUSH
26620: LD_VAR 0 3
26624: NOT
26625: OR
26626: IFFALSE 26630
// exit ;
26628: GO 27444
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26630: LD_ADDR_VAR 0 14
26634: PUSH
26635: LD_VAR 0 1
26639: PPUSH
26640: LD_VAR 0 2
26644: PPUSH
26645: LD_VAR 0 3
26649: PPUSH
26650: LD_VAR 0 4
26654: PPUSH
26655: LD_VAR 0 5
26659: PUSH
26660: LD_INT 1
26662: ARRAY
26663: PPUSH
26664: CALL_OW 248
26668: PPUSH
26669: LD_INT 0
26671: PPUSH
26672: CALL 28681 0 6
26676: ST_TO_ADDR
// if not hexes then
26677: LD_VAR 0 14
26681: NOT
26682: IFFALSE 26686
// exit ;
26684: GO 27444
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26686: LD_ADDR_VAR 0 17
26690: PUSH
26691: LD_VAR 0 5
26695: PPUSH
26696: LD_INT 22
26698: PUSH
26699: LD_VAR 0 13
26703: PPUSH
26704: CALL_OW 255
26708: PUSH
26709: EMPTY
26710: LIST
26711: LIST
26712: PUSH
26713: LD_INT 2
26715: PUSH
26716: LD_INT 30
26718: PUSH
26719: LD_INT 0
26721: PUSH
26722: EMPTY
26723: LIST
26724: LIST
26725: PUSH
26726: LD_INT 30
26728: PUSH
26729: LD_INT 1
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: PUSH
26736: EMPTY
26737: LIST
26738: LIST
26739: LIST
26740: PUSH
26741: EMPTY
26742: LIST
26743: LIST
26744: PPUSH
26745: CALL_OW 72
26749: ST_TO_ADDR
// for i = 1 to hexes do
26750: LD_ADDR_VAR 0 9
26754: PUSH
26755: DOUBLE
26756: LD_INT 1
26758: DEC
26759: ST_TO_ADDR
26760: LD_VAR 0 14
26764: PUSH
26765: FOR_TO
26766: IFFALSE 27442
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26768: LD_ADDR_VAR 0 13
26772: PUSH
26773: LD_VAR 0 14
26777: PUSH
26778: LD_VAR 0 9
26782: ARRAY
26783: PUSH
26784: LD_INT 1
26786: ARRAY
26787: PPUSH
26788: LD_VAR 0 14
26792: PUSH
26793: LD_VAR 0 9
26797: ARRAY
26798: PUSH
26799: LD_INT 2
26801: ARRAY
26802: PPUSH
26803: CALL_OW 428
26807: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26808: LD_VAR 0 14
26812: PUSH
26813: LD_VAR 0 9
26817: ARRAY
26818: PUSH
26819: LD_INT 1
26821: ARRAY
26822: PPUSH
26823: LD_VAR 0 14
26827: PUSH
26828: LD_VAR 0 9
26832: ARRAY
26833: PUSH
26834: LD_INT 2
26836: ARRAY
26837: PPUSH
26838: CALL_OW 351
26842: PUSH
26843: LD_VAR 0 14
26847: PUSH
26848: LD_VAR 0 9
26852: ARRAY
26853: PUSH
26854: LD_INT 1
26856: ARRAY
26857: PPUSH
26858: LD_VAR 0 14
26862: PUSH
26863: LD_VAR 0 9
26867: ARRAY
26868: PUSH
26869: LD_INT 2
26871: ARRAY
26872: PPUSH
26873: CALL_OW 488
26877: NOT
26878: OR
26879: PUSH
26880: LD_VAR 0 13
26884: PPUSH
26885: CALL_OW 247
26889: PUSH
26890: LD_INT 3
26892: EQUAL
26893: OR
26894: IFFALSE 26900
// exit ;
26896: POP
26897: POP
26898: GO 27444
// if not tmp then
26900: LD_VAR 0 13
26904: NOT
26905: IFFALSE 26909
// continue ;
26907: GO 26765
// result := true ;
26909: LD_ADDR_VAR 0 8
26913: PUSH
26914: LD_INT 1
26916: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
26917: LD_VAR 0 6
26921: PUSH
26922: LD_VAR 0 13
26926: PPUSH
26927: CALL_OW 247
26931: PUSH
26932: LD_INT 2
26934: EQUAL
26935: AND
26936: PUSH
26937: LD_VAR 0 13
26941: PPUSH
26942: CALL_OW 263
26946: PUSH
26947: LD_INT 1
26949: EQUAL
26950: AND
26951: IFFALSE 27115
// begin if IsDrivenBy ( tmp ) then
26953: LD_VAR 0 13
26957: PPUSH
26958: CALL_OW 311
26962: IFFALSE 26966
// continue ;
26964: GO 26765
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
26966: LD_VAR 0 6
26970: PPUSH
26971: LD_INT 3
26973: PUSH
26974: LD_INT 60
26976: PUSH
26977: EMPTY
26978: LIST
26979: PUSH
26980: EMPTY
26981: LIST
26982: LIST
26983: PUSH
26984: LD_INT 3
26986: PUSH
26987: LD_INT 55
26989: PUSH
26990: EMPTY
26991: LIST
26992: PUSH
26993: EMPTY
26994: LIST
26995: LIST
26996: PUSH
26997: EMPTY
26998: LIST
26999: LIST
27000: PPUSH
27001: CALL_OW 72
27005: IFFALSE 27113
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
27007: LD_ADDR_VAR 0 18
27011: PUSH
27012: LD_VAR 0 6
27016: PPUSH
27017: LD_INT 3
27019: PUSH
27020: LD_INT 60
27022: PUSH
27023: EMPTY
27024: LIST
27025: PUSH
27026: EMPTY
27027: LIST
27028: LIST
27029: PUSH
27030: LD_INT 3
27032: PUSH
27033: LD_INT 55
27035: PUSH
27036: EMPTY
27037: LIST
27038: PUSH
27039: EMPTY
27040: LIST
27041: LIST
27042: PUSH
27043: EMPTY
27044: LIST
27045: LIST
27046: PPUSH
27047: CALL_OW 72
27051: PUSH
27052: LD_INT 1
27054: ARRAY
27055: ST_TO_ADDR
// if IsInUnit ( driver ) then
27056: LD_VAR 0 18
27060: PPUSH
27061: CALL_OW 310
27065: IFFALSE 27076
// ComExit ( driver ) ;
27067: LD_VAR 0 18
27071: PPUSH
27072: CALL 51865 0 1
// AddComEnterUnit ( driver , tmp ) ;
27076: LD_VAR 0 18
27080: PPUSH
27081: LD_VAR 0 13
27085: PPUSH
27086: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27090: LD_VAR 0 18
27094: PPUSH
27095: LD_VAR 0 7
27099: PPUSH
27100: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27104: LD_VAR 0 18
27108: PPUSH
27109: CALL_OW 181
// end ; continue ;
27113: GO 26765
// end ; if not cleaners or not tmp in cleaners then
27115: LD_VAR 0 6
27119: NOT
27120: PUSH
27121: LD_VAR 0 13
27125: PUSH
27126: LD_VAR 0 6
27130: IN
27131: NOT
27132: OR
27133: IFFALSE 27440
// begin if dep then
27135: LD_VAR 0 17
27139: IFFALSE 27275
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27141: LD_ADDR_VAR 0 16
27145: PUSH
27146: LD_VAR 0 17
27150: PUSH
27151: LD_INT 1
27153: ARRAY
27154: PPUSH
27155: CALL_OW 250
27159: PPUSH
27160: LD_VAR 0 17
27164: PUSH
27165: LD_INT 1
27167: ARRAY
27168: PPUSH
27169: CALL_OW 254
27173: PPUSH
27174: LD_INT 5
27176: PPUSH
27177: CALL_OW 272
27181: PUSH
27182: LD_VAR 0 17
27186: PUSH
27187: LD_INT 1
27189: ARRAY
27190: PPUSH
27191: CALL_OW 251
27195: PPUSH
27196: LD_VAR 0 17
27200: PUSH
27201: LD_INT 1
27203: ARRAY
27204: PPUSH
27205: CALL_OW 254
27209: PPUSH
27210: LD_INT 5
27212: PPUSH
27213: CALL_OW 273
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27222: LD_VAR 0 16
27226: PUSH
27227: LD_INT 1
27229: ARRAY
27230: PPUSH
27231: LD_VAR 0 16
27235: PUSH
27236: LD_INT 2
27238: ARRAY
27239: PPUSH
27240: CALL_OW 488
27244: IFFALSE 27275
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27246: LD_VAR 0 13
27250: PPUSH
27251: LD_VAR 0 16
27255: PUSH
27256: LD_INT 1
27258: ARRAY
27259: PPUSH
27260: LD_VAR 0 16
27264: PUSH
27265: LD_INT 2
27267: ARRAY
27268: PPUSH
27269: CALL_OW 111
// continue ;
27273: GO 26765
// end ; end ; r := GetDir ( tmp ) ;
27275: LD_ADDR_VAR 0 15
27279: PUSH
27280: LD_VAR 0 13
27284: PPUSH
27285: CALL_OW 254
27289: ST_TO_ADDR
// if r = 5 then
27290: LD_VAR 0 15
27294: PUSH
27295: LD_INT 5
27297: EQUAL
27298: IFFALSE 27308
// r := 0 ;
27300: LD_ADDR_VAR 0 15
27304: PUSH
27305: LD_INT 0
27307: ST_TO_ADDR
// for j = r to 5 do
27308: LD_ADDR_VAR 0 10
27312: PUSH
27313: DOUBLE
27314: LD_VAR 0 15
27318: DEC
27319: ST_TO_ADDR
27320: LD_INT 5
27322: PUSH
27323: FOR_TO
27324: IFFALSE 27438
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27326: LD_ADDR_VAR 0 11
27330: PUSH
27331: LD_VAR 0 13
27335: PPUSH
27336: CALL_OW 250
27340: PPUSH
27341: LD_VAR 0 10
27345: PPUSH
27346: LD_INT 2
27348: PPUSH
27349: CALL_OW 272
27353: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27354: LD_ADDR_VAR 0 12
27358: PUSH
27359: LD_VAR 0 13
27363: PPUSH
27364: CALL_OW 251
27368: PPUSH
27369: LD_VAR 0 10
27373: PPUSH
27374: LD_INT 2
27376: PPUSH
27377: CALL_OW 273
27381: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27382: LD_VAR 0 11
27386: PPUSH
27387: LD_VAR 0 12
27391: PPUSH
27392: CALL_OW 488
27396: PUSH
27397: LD_VAR 0 11
27401: PPUSH
27402: LD_VAR 0 12
27406: PPUSH
27407: CALL_OW 428
27411: NOT
27412: AND
27413: IFFALSE 27436
// begin ComMoveXY ( tmp , _x , _y ) ;
27415: LD_VAR 0 13
27419: PPUSH
27420: LD_VAR 0 11
27424: PPUSH
27425: LD_VAR 0 12
27429: PPUSH
27430: CALL_OW 111
// break ;
27434: GO 27438
// end ; end ;
27436: GO 27323
27438: POP
27439: POP
// end ; end ;
27440: GO 26765
27442: POP
27443: POP
// end ;
27444: LD_VAR 0 8
27448: RET
// export function BuildingTechInvented ( side , btype ) ; begin
27449: LD_INT 0
27451: PPUSH
// result := true ;
27452: LD_ADDR_VAR 0 3
27456: PUSH
27457: LD_INT 1
27459: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
27460: LD_VAR 0 2
27464: PUSH
27465: LD_INT 24
27467: DOUBLE
27468: EQUAL
27469: IFTRUE 27479
27471: LD_INT 33
27473: DOUBLE
27474: EQUAL
27475: IFTRUE 27479
27477: GO 27504
27479: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
27480: LD_ADDR_VAR 0 3
27484: PUSH
27485: LD_INT 32
27487: PPUSH
27488: LD_VAR 0 1
27492: PPUSH
27493: CALL_OW 321
27497: PUSH
27498: LD_INT 2
27500: EQUAL
27501: ST_TO_ADDR
27502: GO 27824
27504: LD_INT 20
27506: DOUBLE
27507: EQUAL
27508: IFTRUE 27512
27510: GO 27537
27512: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
27513: LD_ADDR_VAR 0 3
27517: PUSH
27518: LD_INT 6
27520: PPUSH
27521: LD_VAR 0 1
27525: PPUSH
27526: CALL_OW 321
27530: PUSH
27531: LD_INT 2
27533: EQUAL
27534: ST_TO_ADDR
27535: GO 27824
27537: LD_INT 22
27539: DOUBLE
27540: EQUAL
27541: IFTRUE 27551
27543: LD_INT 36
27545: DOUBLE
27546: EQUAL
27547: IFTRUE 27551
27549: GO 27576
27551: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
27552: LD_ADDR_VAR 0 3
27556: PUSH
27557: LD_INT 15
27559: PPUSH
27560: LD_VAR 0 1
27564: PPUSH
27565: CALL_OW 321
27569: PUSH
27570: LD_INT 2
27572: EQUAL
27573: ST_TO_ADDR
27574: GO 27824
27576: LD_INT 30
27578: DOUBLE
27579: EQUAL
27580: IFTRUE 27584
27582: GO 27609
27584: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
27585: LD_ADDR_VAR 0 3
27589: PUSH
27590: LD_INT 20
27592: PPUSH
27593: LD_VAR 0 1
27597: PPUSH
27598: CALL_OW 321
27602: PUSH
27603: LD_INT 2
27605: EQUAL
27606: ST_TO_ADDR
27607: GO 27824
27609: LD_INT 28
27611: DOUBLE
27612: EQUAL
27613: IFTRUE 27623
27615: LD_INT 21
27617: DOUBLE
27618: EQUAL
27619: IFTRUE 27623
27621: GO 27648
27623: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
27624: LD_ADDR_VAR 0 3
27628: PUSH
27629: LD_INT 21
27631: PPUSH
27632: LD_VAR 0 1
27636: PPUSH
27637: CALL_OW 321
27641: PUSH
27642: LD_INT 2
27644: EQUAL
27645: ST_TO_ADDR
27646: GO 27824
27648: LD_INT 16
27650: DOUBLE
27651: EQUAL
27652: IFTRUE 27656
27654: GO 27683
27656: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
27657: LD_ADDR_VAR 0 3
27661: PUSH
27662: LD_EXP 115
27666: PPUSH
27667: LD_VAR 0 1
27671: PPUSH
27672: CALL_OW 321
27676: PUSH
27677: LD_INT 2
27679: EQUAL
27680: ST_TO_ADDR
27681: GO 27824
27683: LD_INT 19
27685: DOUBLE
27686: EQUAL
27687: IFTRUE 27697
27689: LD_INT 23
27691: DOUBLE
27692: EQUAL
27693: IFTRUE 27697
27695: GO 27724
27697: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
27698: LD_ADDR_VAR 0 3
27702: PUSH
27703: LD_EXP 114
27707: PPUSH
27708: LD_VAR 0 1
27712: PPUSH
27713: CALL_OW 321
27717: PUSH
27718: LD_INT 2
27720: EQUAL
27721: ST_TO_ADDR
27722: GO 27824
27724: LD_INT 17
27726: DOUBLE
27727: EQUAL
27728: IFTRUE 27732
27730: GO 27757
27732: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
27733: LD_ADDR_VAR 0 3
27737: PUSH
27738: LD_INT 39
27740: PPUSH
27741: LD_VAR 0 1
27745: PPUSH
27746: CALL_OW 321
27750: PUSH
27751: LD_INT 2
27753: EQUAL
27754: ST_TO_ADDR
27755: GO 27824
27757: LD_INT 18
27759: DOUBLE
27760: EQUAL
27761: IFTRUE 27765
27763: GO 27790
27765: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
27766: LD_ADDR_VAR 0 3
27770: PUSH
27771: LD_INT 40
27773: PPUSH
27774: LD_VAR 0 1
27778: PPUSH
27779: CALL_OW 321
27783: PUSH
27784: LD_INT 2
27786: EQUAL
27787: ST_TO_ADDR
27788: GO 27824
27790: LD_INT 27
27792: DOUBLE
27793: EQUAL
27794: IFTRUE 27798
27796: GO 27823
27798: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
27799: LD_ADDR_VAR 0 3
27803: PUSH
27804: LD_INT 35
27806: PPUSH
27807: LD_VAR 0 1
27811: PPUSH
27812: CALL_OW 321
27816: PUSH
27817: LD_INT 2
27819: EQUAL
27820: ST_TO_ADDR
27821: GO 27824
27823: POP
// end ;
27824: LD_VAR 0 3
27828: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
27829: LD_INT 0
27831: PPUSH
27832: PPUSH
27833: PPUSH
27834: PPUSH
27835: PPUSH
27836: PPUSH
27837: PPUSH
27838: PPUSH
27839: PPUSH
27840: PPUSH
27841: PPUSH
// result := false ;
27842: LD_ADDR_VAR 0 6
27846: PUSH
27847: LD_INT 0
27849: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27850: LD_VAR 0 1
27854: NOT
27855: PUSH
27856: LD_VAR 0 1
27860: PPUSH
27861: CALL_OW 266
27865: PUSH
27866: LD_INT 0
27868: PUSH
27869: LD_INT 1
27871: PUSH
27872: EMPTY
27873: LIST
27874: LIST
27875: IN
27876: NOT
27877: OR
27878: PUSH
27879: LD_VAR 0 2
27883: NOT
27884: OR
27885: PUSH
27886: LD_VAR 0 5
27890: PUSH
27891: LD_INT 0
27893: PUSH
27894: LD_INT 1
27896: PUSH
27897: LD_INT 2
27899: PUSH
27900: LD_INT 3
27902: PUSH
27903: LD_INT 4
27905: PUSH
27906: LD_INT 5
27908: PUSH
27909: EMPTY
27910: LIST
27911: LIST
27912: LIST
27913: LIST
27914: LIST
27915: LIST
27916: IN
27917: NOT
27918: OR
27919: PUSH
27920: LD_VAR 0 3
27924: PPUSH
27925: LD_VAR 0 4
27929: PPUSH
27930: CALL_OW 488
27934: NOT
27935: OR
27936: IFFALSE 27940
// exit ;
27938: GO 28676
// side := GetSide ( depot ) ;
27940: LD_ADDR_VAR 0 9
27944: PUSH
27945: LD_VAR 0 1
27949: PPUSH
27950: CALL_OW 255
27954: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
27955: LD_VAR 0 9
27959: PPUSH
27960: LD_VAR 0 2
27964: PPUSH
27965: CALL 27449 0 2
27969: NOT
27970: IFFALSE 27974
// exit ;
27972: GO 28676
// pom := GetBase ( depot ) ;
27974: LD_ADDR_VAR 0 10
27978: PUSH
27979: LD_VAR 0 1
27983: PPUSH
27984: CALL_OW 274
27988: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
27989: LD_ADDR_VAR 0 11
27993: PUSH
27994: LD_VAR 0 2
27998: PPUSH
27999: LD_VAR 0 1
28003: PPUSH
28004: CALL_OW 248
28008: PPUSH
28009: CALL_OW 450
28013: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28014: LD_VAR 0 10
28018: PPUSH
28019: LD_INT 1
28021: PPUSH
28022: CALL_OW 275
28026: PUSH
28027: LD_VAR 0 11
28031: PUSH
28032: LD_INT 1
28034: ARRAY
28035: GREATEREQUAL
28036: PUSH
28037: LD_VAR 0 10
28041: PPUSH
28042: LD_INT 2
28044: PPUSH
28045: CALL_OW 275
28049: PUSH
28050: LD_VAR 0 11
28054: PUSH
28055: LD_INT 2
28057: ARRAY
28058: GREATEREQUAL
28059: AND
28060: PUSH
28061: LD_VAR 0 10
28065: PPUSH
28066: LD_INT 3
28068: PPUSH
28069: CALL_OW 275
28073: PUSH
28074: LD_VAR 0 11
28078: PUSH
28079: LD_INT 3
28081: ARRAY
28082: GREATEREQUAL
28083: AND
28084: NOT
28085: IFFALSE 28089
// exit ;
28087: GO 28676
// if GetBType ( depot ) = b_depot then
28089: LD_VAR 0 1
28093: PPUSH
28094: CALL_OW 266
28098: PUSH
28099: LD_INT 0
28101: EQUAL
28102: IFFALSE 28114
// dist := 28 else
28104: LD_ADDR_VAR 0 14
28108: PUSH
28109: LD_INT 28
28111: ST_TO_ADDR
28112: GO 28122
// dist := 36 ;
28114: LD_ADDR_VAR 0 14
28118: PUSH
28119: LD_INT 36
28121: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28122: LD_VAR 0 1
28126: PPUSH
28127: LD_VAR 0 3
28131: PPUSH
28132: LD_VAR 0 4
28136: PPUSH
28137: CALL_OW 297
28141: PUSH
28142: LD_VAR 0 14
28146: GREATER
28147: IFFALSE 28151
// exit ;
28149: GO 28676
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28151: LD_ADDR_VAR 0 12
28155: PUSH
28156: LD_VAR 0 2
28160: PPUSH
28161: LD_VAR 0 3
28165: PPUSH
28166: LD_VAR 0 4
28170: PPUSH
28171: LD_VAR 0 5
28175: PPUSH
28176: LD_VAR 0 1
28180: PPUSH
28181: CALL_OW 248
28185: PPUSH
28186: LD_INT 0
28188: PPUSH
28189: CALL 28681 0 6
28193: ST_TO_ADDR
// if not hexes then
28194: LD_VAR 0 12
28198: NOT
28199: IFFALSE 28203
// exit ;
28201: GO 28676
// hex := GetHexInfo ( x , y ) ;
28203: LD_ADDR_VAR 0 15
28207: PUSH
28208: LD_VAR 0 3
28212: PPUSH
28213: LD_VAR 0 4
28217: PPUSH
28218: CALL_OW 546
28222: ST_TO_ADDR
// if hex [ 1 ] then
28223: LD_VAR 0 15
28227: PUSH
28228: LD_INT 1
28230: ARRAY
28231: IFFALSE 28235
// exit ;
28233: GO 28676
// height := hex [ 2 ] ;
28235: LD_ADDR_VAR 0 13
28239: PUSH
28240: LD_VAR 0 15
28244: PUSH
28245: LD_INT 2
28247: ARRAY
28248: ST_TO_ADDR
// for i = 1 to hexes do
28249: LD_ADDR_VAR 0 7
28253: PUSH
28254: DOUBLE
28255: LD_INT 1
28257: DEC
28258: ST_TO_ADDR
28259: LD_VAR 0 12
28263: PUSH
28264: FOR_TO
28265: IFFALSE 28595
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28267: LD_VAR 0 12
28271: PUSH
28272: LD_VAR 0 7
28276: ARRAY
28277: PUSH
28278: LD_INT 1
28280: ARRAY
28281: PPUSH
28282: LD_VAR 0 12
28286: PUSH
28287: LD_VAR 0 7
28291: ARRAY
28292: PUSH
28293: LD_INT 2
28295: ARRAY
28296: PPUSH
28297: CALL_OW 488
28301: NOT
28302: PUSH
28303: LD_VAR 0 12
28307: PUSH
28308: LD_VAR 0 7
28312: ARRAY
28313: PUSH
28314: LD_INT 1
28316: ARRAY
28317: PPUSH
28318: LD_VAR 0 12
28322: PUSH
28323: LD_VAR 0 7
28327: ARRAY
28328: PUSH
28329: LD_INT 2
28331: ARRAY
28332: PPUSH
28333: CALL_OW 428
28337: PUSH
28338: LD_INT 0
28340: GREATER
28341: OR
28342: PUSH
28343: LD_VAR 0 12
28347: PUSH
28348: LD_VAR 0 7
28352: ARRAY
28353: PUSH
28354: LD_INT 1
28356: ARRAY
28357: PPUSH
28358: LD_VAR 0 12
28362: PUSH
28363: LD_VAR 0 7
28367: ARRAY
28368: PUSH
28369: LD_INT 2
28371: ARRAY
28372: PPUSH
28373: CALL_OW 351
28377: OR
28378: IFFALSE 28384
// exit ;
28380: POP
28381: POP
28382: GO 28676
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28384: LD_ADDR_VAR 0 8
28388: PUSH
28389: LD_VAR 0 12
28393: PUSH
28394: LD_VAR 0 7
28398: ARRAY
28399: PUSH
28400: LD_INT 1
28402: ARRAY
28403: PPUSH
28404: LD_VAR 0 12
28408: PUSH
28409: LD_VAR 0 7
28413: ARRAY
28414: PUSH
28415: LD_INT 2
28417: ARRAY
28418: PPUSH
28419: CALL_OW 546
28423: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28424: LD_VAR 0 8
28428: PUSH
28429: LD_INT 1
28431: ARRAY
28432: PUSH
28433: LD_VAR 0 8
28437: PUSH
28438: LD_INT 2
28440: ARRAY
28441: PUSH
28442: LD_VAR 0 13
28446: PUSH
28447: LD_INT 2
28449: PLUS
28450: GREATER
28451: OR
28452: PUSH
28453: LD_VAR 0 8
28457: PUSH
28458: LD_INT 2
28460: ARRAY
28461: PUSH
28462: LD_VAR 0 13
28466: PUSH
28467: LD_INT 2
28469: MINUS
28470: LESS
28471: OR
28472: PUSH
28473: LD_VAR 0 8
28477: PUSH
28478: LD_INT 3
28480: ARRAY
28481: PUSH
28482: LD_INT 0
28484: PUSH
28485: LD_INT 8
28487: PUSH
28488: LD_INT 9
28490: PUSH
28491: LD_INT 10
28493: PUSH
28494: LD_INT 11
28496: PUSH
28497: LD_INT 12
28499: PUSH
28500: LD_INT 13
28502: PUSH
28503: LD_INT 16
28505: PUSH
28506: LD_INT 17
28508: PUSH
28509: LD_INT 18
28511: PUSH
28512: LD_INT 19
28514: PUSH
28515: LD_INT 20
28517: PUSH
28518: LD_INT 21
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: LIST
28525: LIST
28526: LIST
28527: LIST
28528: LIST
28529: LIST
28530: LIST
28531: LIST
28532: LIST
28533: LIST
28534: LIST
28535: IN
28536: NOT
28537: OR
28538: PUSH
28539: LD_VAR 0 8
28543: PUSH
28544: LD_INT 5
28546: ARRAY
28547: NOT
28548: OR
28549: PUSH
28550: LD_VAR 0 8
28554: PUSH
28555: LD_INT 6
28557: ARRAY
28558: PUSH
28559: LD_INT 1
28561: PUSH
28562: LD_INT 2
28564: PUSH
28565: LD_INT 7
28567: PUSH
28568: LD_INT 9
28570: PUSH
28571: LD_INT 10
28573: PUSH
28574: LD_INT 11
28576: PUSH
28577: EMPTY
28578: LIST
28579: LIST
28580: LIST
28581: LIST
28582: LIST
28583: LIST
28584: IN
28585: NOT
28586: OR
28587: IFFALSE 28593
// exit ;
28589: POP
28590: POP
28591: GO 28676
// end ;
28593: GO 28264
28595: POP
28596: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28597: LD_VAR 0 9
28601: PPUSH
28602: LD_VAR 0 3
28606: PPUSH
28607: LD_VAR 0 4
28611: PPUSH
28612: LD_INT 20
28614: PPUSH
28615: CALL 20622 0 4
28619: PUSH
28620: LD_INT 4
28622: ARRAY
28623: IFFALSE 28627
// exit ;
28625: GO 28676
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28627: LD_VAR 0 2
28631: PUSH
28632: LD_INT 29
28634: PUSH
28635: LD_INT 30
28637: PUSH
28638: EMPTY
28639: LIST
28640: LIST
28641: IN
28642: PUSH
28643: LD_VAR 0 3
28647: PPUSH
28648: LD_VAR 0 4
28652: PPUSH
28653: LD_VAR 0 9
28657: PPUSH
28658: CALL_OW 440
28662: NOT
28663: AND
28664: IFFALSE 28668
// exit ;
28666: GO 28676
// result := true ;
28668: LD_ADDR_VAR 0 6
28672: PUSH
28673: LD_INT 1
28675: ST_TO_ADDR
// end ;
28676: LD_VAR 0 6
28680: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
28681: LD_INT 0
28683: PPUSH
28684: PPUSH
28685: PPUSH
28686: PPUSH
28687: PPUSH
28688: PPUSH
28689: PPUSH
28690: PPUSH
28691: PPUSH
28692: PPUSH
28693: PPUSH
28694: PPUSH
28695: PPUSH
28696: PPUSH
28697: PPUSH
28698: PPUSH
28699: PPUSH
28700: PPUSH
28701: PPUSH
28702: PPUSH
28703: PPUSH
28704: PPUSH
28705: PPUSH
28706: PPUSH
28707: PPUSH
28708: PPUSH
28709: PPUSH
28710: PPUSH
28711: PPUSH
28712: PPUSH
28713: PPUSH
28714: PPUSH
28715: PPUSH
28716: PPUSH
28717: PPUSH
28718: PPUSH
28719: PPUSH
28720: PPUSH
28721: PPUSH
28722: PPUSH
28723: PPUSH
28724: PPUSH
28725: PPUSH
28726: PPUSH
28727: PPUSH
28728: PPUSH
28729: PPUSH
28730: PPUSH
28731: PPUSH
28732: PPUSH
28733: PPUSH
28734: PPUSH
28735: PPUSH
28736: PPUSH
28737: PPUSH
28738: PPUSH
28739: PPUSH
28740: PPUSH
// result = [ ] ;
28741: LD_ADDR_VAR 0 7
28745: PUSH
28746: EMPTY
28747: ST_TO_ADDR
// temp_list = [ ] ;
28748: LD_ADDR_VAR 0 9
28752: PUSH
28753: EMPTY
28754: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28755: LD_VAR 0 4
28759: PUSH
28760: LD_INT 0
28762: PUSH
28763: LD_INT 1
28765: PUSH
28766: LD_INT 2
28768: PUSH
28769: LD_INT 3
28771: PUSH
28772: LD_INT 4
28774: PUSH
28775: LD_INT 5
28777: PUSH
28778: EMPTY
28779: LIST
28780: LIST
28781: LIST
28782: LIST
28783: LIST
28784: LIST
28785: IN
28786: NOT
28787: PUSH
28788: LD_VAR 0 1
28792: PUSH
28793: LD_INT 0
28795: PUSH
28796: LD_INT 1
28798: PUSH
28799: EMPTY
28800: LIST
28801: LIST
28802: IN
28803: PUSH
28804: LD_VAR 0 5
28808: PUSH
28809: LD_INT 1
28811: PUSH
28812: LD_INT 2
28814: PUSH
28815: LD_INT 3
28817: PUSH
28818: EMPTY
28819: LIST
28820: LIST
28821: LIST
28822: IN
28823: NOT
28824: AND
28825: OR
28826: IFFALSE 28830
// exit ;
28828: GO 47221
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28830: LD_VAR 0 1
28834: PUSH
28835: LD_INT 6
28837: PUSH
28838: LD_INT 7
28840: PUSH
28841: LD_INT 8
28843: PUSH
28844: LD_INT 13
28846: PUSH
28847: LD_INT 12
28849: PUSH
28850: LD_INT 15
28852: PUSH
28853: LD_INT 11
28855: PUSH
28856: LD_INT 14
28858: PUSH
28859: LD_INT 10
28861: PUSH
28862: EMPTY
28863: LIST
28864: LIST
28865: LIST
28866: LIST
28867: LIST
28868: LIST
28869: LIST
28870: LIST
28871: LIST
28872: IN
28873: IFFALSE 28883
// btype = b_lab ;
28875: LD_ADDR_VAR 0 1
28879: PUSH
28880: LD_INT 6
28882: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28883: LD_VAR 0 6
28887: PUSH
28888: LD_INT 0
28890: PUSH
28891: LD_INT 1
28893: PUSH
28894: LD_INT 2
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: LIST
28901: IN
28902: NOT
28903: PUSH
28904: LD_VAR 0 1
28908: PUSH
28909: LD_INT 0
28911: PUSH
28912: LD_INT 1
28914: PUSH
28915: LD_INT 2
28917: PUSH
28918: LD_INT 3
28920: PUSH
28921: LD_INT 6
28923: PUSH
28924: LD_INT 36
28926: PUSH
28927: LD_INT 4
28929: PUSH
28930: LD_INT 5
28932: PUSH
28933: LD_INT 31
28935: PUSH
28936: LD_INT 32
28938: PUSH
28939: LD_INT 33
28941: PUSH
28942: EMPTY
28943: LIST
28944: LIST
28945: LIST
28946: LIST
28947: LIST
28948: LIST
28949: LIST
28950: LIST
28951: LIST
28952: LIST
28953: LIST
28954: IN
28955: NOT
28956: PUSH
28957: LD_VAR 0 6
28961: PUSH
28962: LD_INT 1
28964: EQUAL
28965: AND
28966: OR
28967: PUSH
28968: LD_VAR 0 1
28972: PUSH
28973: LD_INT 2
28975: PUSH
28976: LD_INT 3
28978: PUSH
28979: EMPTY
28980: LIST
28981: LIST
28982: IN
28983: NOT
28984: PUSH
28985: LD_VAR 0 6
28989: PUSH
28990: LD_INT 2
28992: EQUAL
28993: AND
28994: OR
28995: IFFALSE 29005
// mode = 0 ;
28997: LD_ADDR_VAR 0 6
29001: PUSH
29002: LD_INT 0
29004: ST_TO_ADDR
// case mode of 0 :
29005: LD_VAR 0 6
29009: PUSH
29010: LD_INT 0
29012: DOUBLE
29013: EQUAL
29014: IFTRUE 29018
29016: GO 40471
29018: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29019: LD_ADDR_VAR 0 11
29023: PUSH
29024: LD_INT 0
29026: PUSH
29027: LD_INT 0
29029: PUSH
29030: EMPTY
29031: LIST
29032: LIST
29033: PUSH
29034: LD_INT 0
29036: PUSH
29037: LD_INT 1
29039: NEG
29040: PUSH
29041: EMPTY
29042: LIST
29043: LIST
29044: PUSH
29045: LD_INT 1
29047: PUSH
29048: LD_INT 0
29050: PUSH
29051: EMPTY
29052: LIST
29053: LIST
29054: PUSH
29055: LD_INT 1
29057: PUSH
29058: LD_INT 1
29060: PUSH
29061: EMPTY
29062: LIST
29063: LIST
29064: PUSH
29065: LD_INT 0
29067: PUSH
29068: LD_INT 1
29070: PUSH
29071: EMPTY
29072: LIST
29073: LIST
29074: PUSH
29075: LD_INT 1
29077: NEG
29078: PUSH
29079: LD_INT 0
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: PUSH
29086: LD_INT 1
29088: NEG
29089: PUSH
29090: LD_INT 1
29092: NEG
29093: PUSH
29094: EMPTY
29095: LIST
29096: LIST
29097: PUSH
29098: LD_INT 1
29100: NEG
29101: PUSH
29102: LD_INT 2
29104: NEG
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: LD_INT 0
29112: PUSH
29113: LD_INT 2
29115: NEG
29116: PUSH
29117: EMPTY
29118: LIST
29119: LIST
29120: PUSH
29121: LD_INT 1
29123: PUSH
29124: LD_INT 1
29126: NEG
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: PUSH
29132: LD_INT 1
29134: PUSH
29135: LD_INT 2
29137: PUSH
29138: EMPTY
29139: LIST
29140: LIST
29141: PUSH
29142: LD_INT 0
29144: PUSH
29145: LD_INT 2
29147: PUSH
29148: EMPTY
29149: LIST
29150: LIST
29151: PUSH
29152: LD_INT 1
29154: NEG
29155: PUSH
29156: LD_INT 1
29158: PUSH
29159: EMPTY
29160: LIST
29161: LIST
29162: PUSH
29163: LD_INT 1
29165: PUSH
29166: LD_INT 3
29168: PUSH
29169: EMPTY
29170: LIST
29171: LIST
29172: PUSH
29173: LD_INT 0
29175: PUSH
29176: LD_INT 3
29178: PUSH
29179: EMPTY
29180: LIST
29181: LIST
29182: PUSH
29183: LD_INT 1
29185: NEG
29186: PUSH
29187: LD_INT 2
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: LIST
29198: LIST
29199: LIST
29200: LIST
29201: LIST
29202: LIST
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29212: LD_ADDR_VAR 0 12
29216: PUSH
29217: LD_INT 0
29219: PUSH
29220: LD_INT 0
29222: PUSH
29223: EMPTY
29224: LIST
29225: LIST
29226: PUSH
29227: LD_INT 0
29229: PUSH
29230: LD_INT 1
29232: NEG
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 1
29240: PUSH
29241: LD_INT 0
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PUSH
29248: LD_INT 1
29250: PUSH
29251: LD_INT 1
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: LD_INT 0
29260: PUSH
29261: LD_INT 1
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: PUSH
29268: LD_INT 1
29270: NEG
29271: PUSH
29272: LD_INT 0
29274: PUSH
29275: EMPTY
29276: LIST
29277: LIST
29278: PUSH
29279: LD_INT 1
29281: NEG
29282: PUSH
29283: LD_INT 1
29285: NEG
29286: PUSH
29287: EMPTY
29288: LIST
29289: LIST
29290: PUSH
29291: LD_INT 1
29293: PUSH
29294: LD_INT 1
29296: NEG
29297: PUSH
29298: EMPTY
29299: LIST
29300: LIST
29301: PUSH
29302: LD_INT 2
29304: PUSH
29305: LD_INT 0
29307: PUSH
29308: EMPTY
29309: LIST
29310: LIST
29311: PUSH
29312: LD_INT 2
29314: PUSH
29315: LD_INT 1
29317: PUSH
29318: EMPTY
29319: LIST
29320: LIST
29321: PUSH
29322: LD_INT 1
29324: NEG
29325: PUSH
29326: LD_INT 1
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: PUSH
29333: LD_INT 2
29335: NEG
29336: PUSH
29337: LD_INT 0
29339: PUSH
29340: EMPTY
29341: LIST
29342: LIST
29343: PUSH
29344: LD_INT 2
29346: NEG
29347: PUSH
29348: LD_INT 1
29350: NEG
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 2
29358: NEG
29359: PUSH
29360: LD_INT 1
29362: PUSH
29363: EMPTY
29364: LIST
29365: LIST
29366: PUSH
29367: LD_INT 3
29369: NEG
29370: PUSH
29371: LD_INT 0
29373: PUSH
29374: EMPTY
29375: LIST
29376: LIST
29377: PUSH
29378: LD_INT 3
29380: NEG
29381: PUSH
29382: LD_INT 1
29384: NEG
29385: PUSH
29386: EMPTY
29387: LIST
29388: LIST
29389: PUSH
29390: EMPTY
29391: LIST
29392: LIST
29393: LIST
29394: LIST
29395: LIST
29396: LIST
29397: LIST
29398: LIST
29399: LIST
29400: LIST
29401: LIST
29402: LIST
29403: LIST
29404: LIST
29405: LIST
29406: LIST
29407: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29408: LD_ADDR_VAR 0 13
29412: PUSH
29413: LD_INT 0
29415: PUSH
29416: LD_INT 0
29418: PUSH
29419: EMPTY
29420: LIST
29421: LIST
29422: PUSH
29423: LD_INT 0
29425: PUSH
29426: LD_INT 1
29428: NEG
29429: PUSH
29430: EMPTY
29431: LIST
29432: LIST
29433: PUSH
29434: LD_INT 1
29436: PUSH
29437: LD_INT 0
29439: PUSH
29440: EMPTY
29441: LIST
29442: LIST
29443: PUSH
29444: LD_INT 1
29446: PUSH
29447: LD_INT 1
29449: PUSH
29450: EMPTY
29451: LIST
29452: LIST
29453: PUSH
29454: LD_INT 0
29456: PUSH
29457: LD_INT 1
29459: PUSH
29460: EMPTY
29461: LIST
29462: LIST
29463: PUSH
29464: LD_INT 1
29466: NEG
29467: PUSH
29468: LD_INT 0
29470: PUSH
29471: EMPTY
29472: LIST
29473: LIST
29474: PUSH
29475: LD_INT 1
29477: NEG
29478: PUSH
29479: LD_INT 1
29481: NEG
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PUSH
29487: LD_INT 1
29489: NEG
29490: PUSH
29491: LD_INT 2
29493: NEG
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 2
29501: PUSH
29502: LD_INT 1
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: PUSH
29509: LD_INT 2
29511: PUSH
29512: LD_INT 2
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: PUSH
29519: LD_INT 1
29521: PUSH
29522: LD_INT 2
29524: PUSH
29525: EMPTY
29526: LIST
29527: LIST
29528: PUSH
29529: LD_INT 2
29531: NEG
29532: PUSH
29533: LD_INT 1
29535: NEG
29536: PUSH
29537: EMPTY
29538: LIST
29539: LIST
29540: PUSH
29541: LD_INT 2
29543: NEG
29544: PUSH
29545: LD_INT 2
29547: NEG
29548: PUSH
29549: EMPTY
29550: LIST
29551: LIST
29552: PUSH
29553: LD_INT 2
29555: NEG
29556: PUSH
29557: LD_INT 3
29559: NEG
29560: PUSH
29561: EMPTY
29562: LIST
29563: LIST
29564: PUSH
29565: LD_INT 3
29567: NEG
29568: PUSH
29569: LD_INT 2
29571: NEG
29572: PUSH
29573: EMPTY
29574: LIST
29575: LIST
29576: PUSH
29577: LD_INT 3
29579: NEG
29580: PUSH
29581: LD_INT 3
29583: NEG
29584: PUSH
29585: EMPTY
29586: LIST
29587: LIST
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: LIST
29593: LIST
29594: LIST
29595: LIST
29596: LIST
29597: LIST
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29607: LD_ADDR_VAR 0 14
29611: PUSH
29612: LD_INT 0
29614: PUSH
29615: LD_INT 0
29617: PUSH
29618: EMPTY
29619: LIST
29620: LIST
29621: PUSH
29622: LD_INT 0
29624: PUSH
29625: LD_INT 1
29627: NEG
29628: PUSH
29629: EMPTY
29630: LIST
29631: LIST
29632: PUSH
29633: LD_INT 1
29635: PUSH
29636: LD_INT 0
29638: PUSH
29639: EMPTY
29640: LIST
29641: LIST
29642: PUSH
29643: LD_INT 1
29645: PUSH
29646: LD_INT 1
29648: PUSH
29649: EMPTY
29650: LIST
29651: LIST
29652: PUSH
29653: LD_INT 0
29655: PUSH
29656: LD_INT 1
29658: PUSH
29659: EMPTY
29660: LIST
29661: LIST
29662: PUSH
29663: LD_INT 1
29665: NEG
29666: PUSH
29667: LD_INT 0
29669: PUSH
29670: EMPTY
29671: LIST
29672: LIST
29673: PUSH
29674: LD_INT 1
29676: NEG
29677: PUSH
29678: LD_INT 1
29680: NEG
29681: PUSH
29682: EMPTY
29683: LIST
29684: LIST
29685: PUSH
29686: LD_INT 1
29688: NEG
29689: PUSH
29690: LD_INT 2
29692: NEG
29693: PUSH
29694: EMPTY
29695: LIST
29696: LIST
29697: PUSH
29698: LD_INT 0
29700: PUSH
29701: LD_INT 2
29703: NEG
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 1
29711: PUSH
29712: LD_INT 1
29714: NEG
29715: PUSH
29716: EMPTY
29717: LIST
29718: LIST
29719: PUSH
29720: LD_INT 1
29722: PUSH
29723: LD_INT 2
29725: PUSH
29726: EMPTY
29727: LIST
29728: LIST
29729: PUSH
29730: LD_INT 0
29732: PUSH
29733: LD_INT 2
29735: PUSH
29736: EMPTY
29737: LIST
29738: LIST
29739: PUSH
29740: LD_INT 1
29742: NEG
29743: PUSH
29744: LD_INT 1
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: PUSH
29751: LD_INT 1
29753: NEG
29754: PUSH
29755: LD_INT 3
29757: NEG
29758: PUSH
29759: EMPTY
29760: LIST
29761: LIST
29762: PUSH
29763: LD_INT 0
29765: PUSH
29766: LD_INT 3
29768: NEG
29769: PUSH
29770: EMPTY
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 1
29776: PUSH
29777: LD_INT 2
29779: NEG
29780: PUSH
29781: EMPTY
29782: LIST
29783: LIST
29784: PUSH
29785: EMPTY
29786: LIST
29787: LIST
29788: LIST
29789: LIST
29790: LIST
29791: LIST
29792: LIST
29793: LIST
29794: LIST
29795: LIST
29796: LIST
29797: LIST
29798: LIST
29799: LIST
29800: LIST
29801: LIST
29802: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29803: LD_ADDR_VAR 0 15
29807: PUSH
29808: LD_INT 0
29810: PUSH
29811: LD_INT 0
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: LD_INT 0
29820: PUSH
29821: LD_INT 1
29823: NEG
29824: PUSH
29825: EMPTY
29826: LIST
29827: LIST
29828: PUSH
29829: LD_INT 1
29831: PUSH
29832: LD_INT 0
29834: PUSH
29835: EMPTY
29836: LIST
29837: LIST
29838: PUSH
29839: LD_INT 1
29841: PUSH
29842: LD_INT 1
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: PUSH
29849: LD_INT 0
29851: PUSH
29852: LD_INT 1
29854: PUSH
29855: EMPTY
29856: LIST
29857: LIST
29858: PUSH
29859: LD_INT 1
29861: NEG
29862: PUSH
29863: LD_INT 0
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: PUSH
29870: LD_INT 1
29872: NEG
29873: PUSH
29874: LD_INT 1
29876: NEG
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 1
29884: PUSH
29885: LD_INT 1
29887: NEG
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 2
29895: PUSH
29896: LD_INT 0
29898: PUSH
29899: EMPTY
29900: LIST
29901: LIST
29902: PUSH
29903: LD_INT 2
29905: PUSH
29906: LD_INT 1
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: PUSH
29913: LD_INT 1
29915: NEG
29916: PUSH
29917: LD_INT 1
29919: PUSH
29920: EMPTY
29921: LIST
29922: LIST
29923: PUSH
29924: LD_INT 2
29926: NEG
29927: PUSH
29928: LD_INT 0
29930: PUSH
29931: EMPTY
29932: LIST
29933: LIST
29934: PUSH
29935: LD_INT 2
29937: NEG
29938: PUSH
29939: LD_INT 1
29941: NEG
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 2
29949: PUSH
29950: LD_INT 1
29952: NEG
29953: PUSH
29954: EMPTY
29955: LIST
29956: LIST
29957: PUSH
29958: LD_INT 3
29960: PUSH
29961: LD_INT 0
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: LD_INT 3
29970: PUSH
29971: LD_INT 1
29973: PUSH
29974: EMPTY
29975: LIST
29976: LIST
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: LIST
29982: LIST
29983: LIST
29984: LIST
29985: LIST
29986: LIST
29987: LIST
29988: LIST
29989: LIST
29990: LIST
29991: LIST
29992: LIST
29993: LIST
29994: LIST
29995: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29996: LD_ADDR_VAR 0 16
30000: PUSH
30001: LD_INT 0
30003: PUSH
30004: LD_INT 0
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PUSH
30011: LD_INT 0
30013: PUSH
30014: LD_INT 1
30016: NEG
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PUSH
30022: LD_INT 1
30024: PUSH
30025: LD_INT 0
30027: PUSH
30028: EMPTY
30029: LIST
30030: LIST
30031: PUSH
30032: LD_INT 1
30034: PUSH
30035: LD_INT 1
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: LD_INT 0
30044: PUSH
30045: LD_INT 1
30047: PUSH
30048: EMPTY
30049: LIST
30050: LIST
30051: PUSH
30052: LD_INT 1
30054: NEG
30055: PUSH
30056: LD_INT 0
30058: PUSH
30059: EMPTY
30060: LIST
30061: LIST
30062: PUSH
30063: LD_INT 1
30065: NEG
30066: PUSH
30067: LD_INT 1
30069: NEG
30070: PUSH
30071: EMPTY
30072: LIST
30073: LIST
30074: PUSH
30075: LD_INT 1
30077: NEG
30078: PUSH
30079: LD_INT 2
30081: NEG
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: PUSH
30087: LD_INT 2
30089: PUSH
30090: LD_INT 1
30092: PUSH
30093: EMPTY
30094: LIST
30095: LIST
30096: PUSH
30097: LD_INT 2
30099: PUSH
30100: LD_INT 2
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: LD_INT 1
30109: PUSH
30110: LD_INT 2
30112: PUSH
30113: EMPTY
30114: LIST
30115: LIST
30116: PUSH
30117: LD_INT 2
30119: NEG
30120: PUSH
30121: LD_INT 1
30123: NEG
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: PUSH
30129: LD_INT 2
30131: NEG
30132: PUSH
30133: LD_INT 2
30135: NEG
30136: PUSH
30137: EMPTY
30138: LIST
30139: LIST
30140: PUSH
30141: LD_INT 3
30143: PUSH
30144: LD_INT 2
30146: PUSH
30147: EMPTY
30148: LIST
30149: LIST
30150: PUSH
30151: LD_INT 3
30153: PUSH
30154: LD_INT 3
30156: PUSH
30157: EMPTY
30158: LIST
30159: LIST
30160: PUSH
30161: LD_INT 2
30163: PUSH
30164: LD_INT 3
30166: PUSH
30167: EMPTY
30168: LIST
30169: LIST
30170: PUSH
30171: EMPTY
30172: LIST
30173: LIST
30174: LIST
30175: LIST
30176: LIST
30177: LIST
30178: LIST
30179: LIST
30180: LIST
30181: LIST
30182: LIST
30183: LIST
30184: LIST
30185: LIST
30186: LIST
30187: LIST
30188: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30189: LD_ADDR_VAR 0 17
30193: PUSH
30194: LD_INT 0
30196: PUSH
30197: LD_INT 0
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 0
30206: PUSH
30207: LD_INT 1
30209: NEG
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PUSH
30215: LD_INT 1
30217: PUSH
30218: LD_INT 0
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 1
30227: PUSH
30228: LD_INT 1
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 0
30237: PUSH
30238: LD_INT 1
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 1
30247: NEG
30248: PUSH
30249: LD_INT 0
30251: PUSH
30252: EMPTY
30253: LIST
30254: LIST
30255: PUSH
30256: LD_INT 1
30258: NEG
30259: PUSH
30260: LD_INT 1
30262: NEG
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: LD_INT 1
30270: NEG
30271: PUSH
30272: LD_INT 2
30274: NEG
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 0
30282: PUSH
30283: LD_INT 2
30285: NEG
30286: PUSH
30287: EMPTY
30288: LIST
30289: LIST
30290: PUSH
30291: LD_INT 1
30293: PUSH
30294: LD_INT 1
30296: NEG
30297: PUSH
30298: EMPTY
30299: LIST
30300: LIST
30301: PUSH
30302: LD_INT 2
30304: PUSH
30305: LD_INT 0
30307: PUSH
30308: EMPTY
30309: LIST
30310: LIST
30311: PUSH
30312: LD_INT 2
30314: PUSH
30315: LD_INT 1
30317: PUSH
30318: EMPTY
30319: LIST
30320: LIST
30321: PUSH
30322: LD_INT 2
30324: PUSH
30325: LD_INT 2
30327: PUSH
30328: EMPTY
30329: LIST
30330: LIST
30331: PUSH
30332: LD_INT 1
30334: PUSH
30335: LD_INT 2
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: LD_INT 0
30344: PUSH
30345: LD_INT 2
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 1
30354: NEG
30355: PUSH
30356: LD_INT 1
30358: PUSH
30359: EMPTY
30360: LIST
30361: LIST
30362: PUSH
30363: LD_INT 2
30365: NEG
30366: PUSH
30367: LD_INT 0
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: PUSH
30374: LD_INT 2
30376: NEG
30377: PUSH
30378: LD_INT 1
30380: NEG
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: LD_INT 2
30388: NEG
30389: PUSH
30390: LD_INT 2
30392: NEG
30393: PUSH
30394: EMPTY
30395: LIST
30396: LIST
30397: PUSH
30398: EMPTY
30399: LIST
30400: LIST
30401: LIST
30402: LIST
30403: LIST
30404: LIST
30405: LIST
30406: LIST
30407: LIST
30408: LIST
30409: LIST
30410: LIST
30411: LIST
30412: LIST
30413: LIST
30414: LIST
30415: LIST
30416: LIST
30417: LIST
30418: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30419: LD_ADDR_VAR 0 18
30423: PUSH
30424: LD_INT 0
30426: PUSH
30427: LD_INT 0
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: LD_INT 0
30436: PUSH
30437: LD_INT 1
30439: NEG
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 1
30447: PUSH
30448: LD_INT 0
30450: PUSH
30451: EMPTY
30452: LIST
30453: LIST
30454: PUSH
30455: LD_INT 1
30457: PUSH
30458: LD_INT 1
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 0
30467: PUSH
30468: LD_INT 1
30470: PUSH
30471: EMPTY
30472: LIST
30473: LIST
30474: PUSH
30475: LD_INT 1
30477: NEG
30478: PUSH
30479: LD_INT 0
30481: PUSH
30482: EMPTY
30483: LIST
30484: LIST
30485: PUSH
30486: LD_INT 1
30488: NEG
30489: PUSH
30490: LD_INT 1
30492: NEG
30493: PUSH
30494: EMPTY
30495: LIST
30496: LIST
30497: PUSH
30498: LD_INT 1
30500: NEG
30501: PUSH
30502: LD_INT 2
30504: NEG
30505: PUSH
30506: EMPTY
30507: LIST
30508: LIST
30509: PUSH
30510: LD_INT 0
30512: PUSH
30513: LD_INT 2
30515: NEG
30516: PUSH
30517: EMPTY
30518: LIST
30519: LIST
30520: PUSH
30521: LD_INT 1
30523: PUSH
30524: LD_INT 1
30526: NEG
30527: PUSH
30528: EMPTY
30529: LIST
30530: LIST
30531: PUSH
30532: LD_INT 2
30534: PUSH
30535: LD_INT 0
30537: PUSH
30538: EMPTY
30539: LIST
30540: LIST
30541: PUSH
30542: LD_INT 2
30544: PUSH
30545: LD_INT 1
30547: PUSH
30548: EMPTY
30549: LIST
30550: LIST
30551: PUSH
30552: LD_INT 2
30554: PUSH
30555: LD_INT 2
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PUSH
30562: LD_INT 1
30564: PUSH
30565: LD_INT 2
30567: PUSH
30568: EMPTY
30569: LIST
30570: LIST
30571: PUSH
30572: LD_INT 0
30574: PUSH
30575: LD_INT 2
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 1
30584: NEG
30585: PUSH
30586: LD_INT 1
30588: PUSH
30589: EMPTY
30590: LIST
30591: LIST
30592: PUSH
30593: LD_INT 2
30595: NEG
30596: PUSH
30597: LD_INT 0
30599: PUSH
30600: EMPTY
30601: LIST
30602: LIST
30603: PUSH
30604: LD_INT 2
30606: NEG
30607: PUSH
30608: LD_INT 1
30610: NEG
30611: PUSH
30612: EMPTY
30613: LIST
30614: LIST
30615: PUSH
30616: LD_INT 2
30618: NEG
30619: PUSH
30620: LD_INT 2
30622: NEG
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: EMPTY
30629: LIST
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: LIST
30635: LIST
30636: LIST
30637: LIST
30638: LIST
30639: LIST
30640: LIST
30641: LIST
30642: LIST
30643: LIST
30644: LIST
30645: LIST
30646: LIST
30647: LIST
30648: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30649: LD_ADDR_VAR 0 19
30653: PUSH
30654: LD_INT 0
30656: PUSH
30657: LD_INT 0
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: LD_INT 0
30666: PUSH
30667: LD_INT 1
30669: NEG
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: PUSH
30675: LD_INT 1
30677: PUSH
30678: LD_INT 0
30680: PUSH
30681: EMPTY
30682: LIST
30683: LIST
30684: PUSH
30685: LD_INT 1
30687: PUSH
30688: LD_INT 1
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PUSH
30695: LD_INT 0
30697: PUSH
30698: LD_INT 1
30700: PUSH
30701: EMPTY
30702: LIST
30703: LIST
30704: PUSH
30705: LD_INT 1
30707: NEG
30708: PUSH
30709: LD_INT 0
30711: PUSH
30712: EMPTY
30713: LIST
30714: LIST
30715: PUSH
30716: LD_INT 1
30718: NEG
30719: PUSH
30720: LD_INT 1
30722: NEG
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PUSH
30728: LD_INT 1
30730: NEG
30731: PUSH
30732: LD_INT 2
30734: NEG
30735: PUSH
30736: EMPTY
30737: LIST
30738: LIST
30739: PUSH
30740: LD_INT 0
30742: PUSH
30743: LD_INT 2
30745: NEG
30746: PUSH
30747: EMPTY
30748: LIST
30749: LIST
30750: PUSH
30751: LD_INT 1
30753: PUSH
30754: LD_INT 1
30756: NEG
30757: PUSH
30758: EMPTY
30759: LIST
30760: LIST
30761: PUSH
30762: LD_INT 2
30764: PUSH
30765: LD_INT 0
30767: PUSH
30768: EMPTY
30769: LIST
30770: LIST
30771: PUSH
30772: LD_INT 2
30774: PUSH
30775: LD_INT 1
30777: PUSH
30778: EMPTY
30779: LIST
30780: LIST
30781: PUSH
30782: LD_INT 2
30784: PUSH
30785: LD_INT 2
30787: PUSH
30788: EMPTY
30789: LIST
30790: LIST
30791: PUSH
30792: LD_INT 1
30794: PUSH
30795: LD_INT 2
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 0
30804: PUSH
30805: LD_INT 2
30807: PUSH
30808: EMPTY
30809: LIST
30810: LIST
30811: PUSH
30812: LD_INT 1
30814: NEG
30815: PUSH
30816: LD_INT 1
30818: PUSH
30819: EMPTY
30820: LIST
30821: LIST
30822: PUSH
30823: LD_INT 2
30825: NEG
30826: PUSH
30827: LD_INT 0
30829: PUSH
30830: EMPTY
30831: LIST
30832: LIST
30833: PUSH
30834: LD_INT 2
30836: NEG
30837: PUSH
30838: LD_INT 1
30840: NEG
30841: PUSH
30842: EMPTY
30843: LIST
30844: LIST
30845: PUSH
30846: LD_INT 2
30848: NEG
30849: PUSH
30850: LD_INT 2
30852: NEG
30853: PUSH
30854: EMPTY
30855: LIST
30856: LIST
30857: PUSH
30858: EMPTY
30859: LIST
30860: LIST
30861: LIST
30862: LIST
30863: LIST
30864: LIST
30865: LIST
30866: LIST
30867: LIST
30868: LIST
30869: LIST
30870: LIST
30871: LIST
30872: LIST
30873: LIST
30874: LIST
30875: LIST
30876: LIST
30877: LIST
30878: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30879: LD_ADDR_VAR 0 20
30883: PUSH
30884: LD_INT 0
30886: PUSH
30887: LD_INT 0
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: LD_INT 0
30896: PUSH
30897: LD_INT 1
30899: NEG
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PUSH
30905: LD_INT 1
30907: PUSH
30908: LD_INT 0
30910: PUSH
30911: EMPTY
30912: LIST
30913: LIST
30914: PUSH
30915: LD_INT 1
30917: PUSH
30918: LD_INT 1
30920: PUSH
30921: EMPTY
30922: LIST
30923: LIST
30924: PUSH
30925: LD_INT 0
30927: PUSH
30928: LD_INT 1
30930: PUSH
30931: EMPTY
30932: LIST
30933: LIST
30934: PUSH
30935: LD_INT 1
30937: NEG
30938: PUSH
30939: LD_INT 0
30941: PUSH
30942: EMPTY
30943: LIST
30944: LIST
30945: PUSH
30946: LD_INT 1
30948: NEG
30949: PUSH
30950: LD_INT 1
30952: NEG
30953: PUSH
30954: EMPTY
30955: LIST
30956: LIST
30957: PUSH
30958: LD_INT 1
30960: NEG
30961: PUSH
30962: LD_INT 2
30964: NEG
30965: PUSH
30966: EMPTY
30967: LIST
30968: LIST
30969: PUSH
30970: LD_INT 0
30972: PUSH
30973: LD_INT 2
30975: NEG
30976: PUSH
30977: EMPTY
30978: LIST
30979: LIST
30980: PUSH
30981: LD_INT 1
30983: PUSH
30984: LD_INT 1
30986: NEG
30987: PUSH
30988: EMPTY
30989: LIST
30990: LIST
30991: PUSH
30992: LD_INT 2
30994: PUSH
30995: LD_INT 0
30997: PUSH
30998: EMPTY
30999: LIST
31000: LIST
31001: PUSH
31002: LD_INT 2
31004: PUSH
31005: LD_INT 1
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PUSH
31012: LD_INT 2
31014: PUSH
31015: LD_INT 2
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: PUSH
31022: LD_INT 1
31024: PUSH
31025: LD_INT 2
31027: PUSH
31028: EMPTY
31029: LIST
31030: LIST
31031: PUSH
31032: LD_INT 0
31034: PUSH
31035: LD_INT 2
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PUSH
31042: LD_INT 1
31044: NEG
31045: PUSH
31046: LD_INT 1
31048: PUSH
31049: EMPTY
31050: LIST
31051: LIST
31052: PUSH
31053: LD_INT 2
31055: NEG
31056: PUSH
31057: LD_INT 0
31059: PUSH
31060: EMPTY
31061: LIST
31062: LIST
31063: PUSH
31064: LD_INT 2
31066: NEG
31067: PUSH
31068: LD_INT 1
31070: NEG
31071: PUSH
31072: EMPTY
31073: LIST
31074: LIST
31075: PUSH
31076: LD_INT 2
31078: NEG
31079: PUSH
31080: LD_INT 2
31082: NEG
31083: PUSH
31084: EMPTY
31085: LIST
31086: LIST
31087: PUSH
31088: EMPTY
31089: LIST
31090: LIST
31091: LIST
31092: LIST
31093: LIST
31094: LIST
31095: LIST
31096: LIST
31097: LIST
31098: LIST
31099: LIST
31100: LIST
31101: LIST
31102: LIST
31103: LIST
31104: LIST
31105: LIST
31106: LIST
31107: LIST
31108: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31109: LD_ADDR_VAR 0 21
31113: PUSH
31114: LD_INT 0
31116: PUSH
31117: LD_INT 0
31119: PUSH
31120: EMPTY
31121: LIST
31122: LIST
31123: PUSH
31124: LD_INT 0
31126: PUSH
31127: LD_INT 1
31129: NEG
31130: PUSH
31131: EMPTY
31132: LIST
31133: LIST
31134: PUSH
31135: LD_INT 1
31137: PUSH
31138: LD_INT 0
31140: PUSH
31141: EMPTY
31142: LIST
31143: LIST
31144: PUSH
31145: LD_INT 1
31147: PUSH
31148: LD_INT 1
31150: PUSH
31151: EMPTY
31152: LIST
31153: LIST
31154: PUSH
31155: LD_INT 0
31157: PUSH
31158: LD_INT 1
31160: PUSH
31161: EMPTY
31162: LIST
31163: LIST
31164: PUSH
31165: LD_INT 1
31167: NEG
31168: PUSH
31169: LD_INT 0
31171: PUSH
31172: EMPTY
31173: LIST
31174: LIST
31175: PUSH
31176: LD_INT 1
31178: NEG
31179: PUSH
31180: LD_INT 1
31182: NEG
31183: PUSH
31184: EMPTY
31185: LIST
31186: LIST
31187: PUSH
31188: LD_INT 1
31190: NEG
31191: PUSH
31192: LD_INT 2
31194: NEG
31195: PUSH
31196: EMPTY
31197: LIST
31198: LIST
31199: PUSH
31200: LD_INT 0
31202: PUSH
31203: LD_INT 2
31205: NEG
31206: PUSH
31207: EMPTY
31208: LIST
31209: LIST
31210: PUSH
31211: LD_INT 1
31213: PUSH
31214: LD_INT 1
31216: NEG
31217: PUSH
31218: EMPTY
31219: LIST
31220: LIST
31221: PUSH
31222: LD_INT 2
31224: PUSH
31225: LD_INT 0
31227: PUSH
31228: EMPTY
31229: LIST
31230: LIST
31231: PUSH
31232: LD_INT 2
31234: PUSH
31235: LD_INT 1
31237: PUSH
31238: EMPTY
31239: LIST
31240: LIST
31241: PUSH
31242: LD_INT 2
31244: PUSH
31245: LD_INT 2
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: PUSH
31252: LD_INT 1
31254: PUSH
31255: LD_INT 2
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: LD_INT 0
31264: PUSH
31265: LD_INT 2
31267: PUSH
31268: EMPTY
31269: LIST
31270: LIST
31271: PUSH
31272: LD_INT 1
31274: NEG
31275: PUSH
31276: LD_INT 1
31278: PUSH
31279: EMPTY
31280: LIST
31281: LIST
31282: PUSH
31283: LD_INT 2
31285: NEG
31286: PUSH
31287: LD_INT 0
31289: PUSH
31290: EMPTY
31291: LIST
31292: LIST
31293: PUSH
31294: LD_INT 2
31296: NEG
31297: PUSH
31298: LD_INT 1
31300: NEG
31301: PUSH
31302: EMPTY
31303: LIST
31304: LIST
31305: PUSH
31306: LD_INT 2
31308: NEG
31309: PUSH
31310: LD_INT 2
31312: NEG
31313: PUSH
31314: EMPTY
31315: LIST
31316: LIST
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: LIST
31322: LIST
31323: LIST
31324: LIST
31325: LIST
31326: LIST
31327: LIST
31328: LIST
31329: LIST
31330: LIST
31331: LIST
31332: LIST
31333: LIST
31334: LIST
31335: LIST
31336: LIST
31337: LIST
31338: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31339: LD_ADDR_VAR 0 22
31343: PUSH
31344: LD_INT 0
31346: PUSH
31347: LD_INT 0
31349: PUSH
31350: EMPTY
31351: LIST
31352: LIST
31353: PUSH
31354: LD_INT 0
31356: PUSH
31357: LD_INT 1
31359: NEG
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: LD_INT 1
31367: PUSH
31368: LD_INT 0
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 1
31377: PUSH
31378: LD_INT 1
31380: PUSH
31381: EMPTY
31382: LIST
31383: LIST
31384: PUSH
31385: LD_INT 0
31387: PUSH
31388: LD_INT 1
31390: PUSH
31391: EMPTY
31392: LIST
31393: LIST
31394: PUSH
31395: LD_INT 1
31397: NEG
31398: PUSH
31399: LD_INT 0
31401: PUSH
31402: EMPTY
31403: LIST
31404: LIST
31405: PUSH
31406: LD_INT 1
31408: NEG
31409: PUSH
31410: LD_INT 1
31412: NEG
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 1
31420: NEG
31421: PUSH
31422: LD_INT 2
31424: NEG
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: LD_INT 0
31432: PUSH
31433: LD_INT 2
31435: NEG
31436: PUSH
31437: EMPTY
31438: LIST
31439: LIST
31440: PUSH
31441: LD_INT 1
31443: PUSH
31444: LD_INT 1
31446: NEG
31447: PUSH
31448: EMPTY
31449: LIST
31450: LIST
31451: PUSH
31452: LD_INT 2
31454: PUSH
31455: LD_INT 0
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: PUSH
31462: LD_INT 2
31464: PUSH
31465: LD_INT 1
31467: PUSH
31468: EMPTY
31469: LIST
31470: LIST
31471: PUSH
31472: LD_INT 2
31474: PUSH
31475: LD_INT 2
31477: PUSH
31478: EMPTY
31479: LIST
31480: LIST
31481: PUSH
31482: LD_INT 1
31484: PUSH
31485: LD_INT 2
31487: PUSH
31488: EMPTY
31489: LIST
31490: LIST
31491: PUSH
31492: LD_INT 0
31494: PUSH
31495: LD_INT 2
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: PUSH
31502: LD_INT 1
31504: NEG
31505: PUSH
31506: LD_INT 1
31508: PUSH
31509: EMPTY
31510: LIST
31511: LIST
31512: PUSH
31513: LD_INT 2
31515: NEG
31516: PUSH
31517: LD_INT 0
31519: PUSH
31520: EMPTY
31521: LIST
31522: LIST
31523: PUSH
31524: LD_INT 2
31526: NEG
31527: PUSH
31528: LD_INT 1
31530: NEG
31531: PUSH
31532: EMPTY
31533: LIST
31534: LIST
31535: PUSH
31536: LD_INT 2
31538: NEG
31539: PUSH
31540: LD_INT 2
31542: NEG
31543: PUSH
31544: EMPTY
31545: LIST
31546: LIST
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: LIST
31552: LIST
31553: LIST
31554: LIST
31555: LIST
31556: LIST
31557: LIST
31558: LIST
31559: LIST
31560: LIST
31561: LIST
31562: LIST
31563: LIST
31564: LIST
31565: LIST
31566: LIST
31567: LIST
31568: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31569: LD_ADDR_VAR 0 23
31573: PUSH
31574: LD_INT 0
31576: PUSH
31577: LD_INT 0
31579: PUSH
31580: EMPTY
31581: LIST
31582: LIST
31583: PUSH
31584: LD_INT 0
31586: PUSH
31587: LD_INT 1
31589: NEG
31590: PUSH
31591: EMPTY
31592: LIST
31593: LIST
31594: PUSH
31595: LD_INT 1
31597: PUSH
31598: LD_INT 0
31600: PUSH
31601: EMPTY
31602: LIST
31603: LIST
31604: PUSH
31605: LD_INT 1
31607: PUSH
31608: LD_INT 1
31610: PUSH
31611: EMPTY
31612: LIST
31613: LIST
31614: PUSH
31615: LD_INT 0
31617: PUSH
31618: LD_INT 1
31620: PUSH
31621: EMPTY
31622: LIST
31623: LIST
31624: PUSH
31625: LD_INT 1
31627: NEG
31628: PUSH
31629: LD_INT 0
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PUSH
31636: LD_INT 1
31638: NEG
31639: PUSH
31640: LD_INT 1
31642: NEG
31643: PUSH
31644: EMPTY
31645: LIST
31646: LIST
31647: PUSH
31648: LD_INT 1
31650: NEG
31651: PUSH
31652: LD_INT 2
31654: NEG
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: PUSH
31660: LD_INT 0
31662: PUSH
31663: LD_INT 2
31665: NEG
31666: PUSH
31667: EMPTY
31668: LIST
31669: LIST
31670: PUSH
31671: LD_INT 1
31673: PUSH
31674: LD_INT 1
31676: NEG
31677: PUSH
31678: EMPTY
31679: LIST
31680: LIST
31681: PUSH
31682: LD_INT 2
31684: PUSH
31685: LD_INT 0
31687: PUSH
31688: EMPTY
31689: LIST
31690: LIST
31691: PUSH
31692: LD_INT 2
31694: PUSH
31695: LD_INT 1
31697: PUSH
31698: EMPTY
31699: LIST
31700: LIST
31701: PUSH
31702: LD_INT 2
31704: PUSH
31705: LD_INT 2
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 1
31714: PUSH
31715: LD_INT 2
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: LD_INT 0
31724: PUSH
31725: LD_INT 2
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PUSH
31732: LD_INT 1
31734: NEG
31735: PUSH
31736: LD_INT 1
31738: PUSH
31739: EMPTY
31740: LIST
31741: LIST
31742: PUSH
31743: LD_INT 2
31745: NEG
31746: PUSH
31747: LD_INT 0
31749: PUSH
31750: EMPTY
31751: LIST
31752: LIST
31753: PUSH
31754: LD_INT 2
31756: NEG
31757: PUSH
31758: LD_INT 1
31760: NEG
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 2
31768: NEG
31769: PUSH
31770: LD_INT 2
31772: NEG
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: PUSH
31778: LD_INT 2
31780: NEG
31781: PUSH
31782: LD_INT 3
31784: NEG
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 1
31792: NEG
31793: PUSH
31794: LD_INT 3
31796: NEG
31797: PUSH
31798: EMPTY
31799: LIST
31800: LIST
31801: PUSH
31802: LD_INT 1
31804: PUSH
31805: LD_INT 2
31807: NEG
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 2
31815: PUSH
31816: LD_INT 1
31818: NEG
31819: PUSH
31820: EMPTY
31821: LIST
31822: LIST
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: LIST
31828: LIST
31829: LIST
31830: LIST
31831: LIST
31832: LIST
31833: LIST
31834: LIST
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: LIST
31843: LIST
31844: LIST
31845: LIST
31846: LIST
31847: LIST
31848: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31849: LD_ADDR_VAR 0 24
31853: PUSH
31854: LD_INT 0
31856: PUSH
31857: LD_INT 0
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PUSH
31864: LD_INT 0
31866: PUSH
31867: LD_INT 1
31869: NEG
31870: PUSH
31871: EMPTY
31872: LIST
31873: LIST
31874: PUSH
31875: LD_INT 1
31877: PUSH
31878: LD_INT 0
31880: PUSH
31881: EMPTY
31882: LIST
31883: LIST
31884: PUSH
31885: LD_INT 1
31887: PUSH
31888: LD_INT 1
31890: PUSH
31891: EMPTY
31892: LIST
31893: LIST
31894: PUSH
31895: LD_INT 0
31897: PUSH
31898: LD_INT 1
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 1
31907: NEG
31908: PUSH
31909: LD_INT 0
31911: PUSH
31912: EMPTY
31913: LIST
31914: LIST
31915: PUSH
31916: LD_INT 1
31918: NEG
31919: PUSH
31920: LD_INT 1
31922: NEG
31923: PUSH
31924: EMPTY
31925: LIST
31926: LIST
31927: PUSH
31928: LD_INT 1
31930: NEG
31931: PUSH
31932: LD_INT 2
31934: NEG
31935: PUSH
31936: EMPTY
31937: LIST
31938: LIST
31939: PUSH
31940: LD_INT 0
31942: PUSH
31943: LD_INT 2
31945: NEG
31946: PUSH
31947: EMPTY
31948: LIST
31949: LIST
31950: PUSH
31951: LD_INT 1
31953: PUSH
31954: LD_INT 1
31956: NEG
31957: PUSH
31958: EMPTY
31959: LIST
31960: LIST
31961: PUSH
31962: LD_INT 2
31964: PUSH
31965: LD_INT 0
31967: PUSH
31968: EMPTY
31969: LIST
31970: LIST
31971: PUSH
31972: LD_INT 2
31974: PUSH
31975: LD_INT 1
31977: PUSH
31978: EMPTY
31979: LIST
31980: LIST
31981: PUSH
31982: LD_INT 2
31984: PUSH
31985: LD_INT 2
31987: PUSH
31988: EMPTY
31989: LIST
31990: LIST
31991: PUSH
31992: LD_INT 1
31994: PUSH
31995: LD_INT 2
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: PUSH
32002: LD_INT 0
32004: PUSH
32005: LD_INT 2
32007: PUSH
32008: EMPTY
32009: LIST
32010: LIST
32011: PUSH
32012: LD_INT 1
32014: NEG
32015: PUSH
32016: LD_INT 1
32018: PUSH
32019: EMPTY
32020: LIST
32021: LIST
32022: PUSH
32023: LD_INT 2
32025: NEG
32026: PUSH
32027: LD_INT 0
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: PUSH
32034: LD_INT 2
32036: NEG
32037: PUSH
32038: LD_INT 1
32040: NEG
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: PUSH
32046: LD_INT 2
32048: NEG
32049: PUSH
32050: LD_INT 2
32052: NEG
32053: PUSH
32054: EMPTY
32055: LIST
32056: LIST
32057: PUSH
32058: LD_INT 1
32060: PUSH
32061: LD_INT 2
32063: NEG
32064: PUSH
32065: EMPTY
32066: LIST
32067: LIST
32068: PUSH
32069: LD_INT 2
32071: PUSH
32072: LD_INT 1
32074: NEG
32075: PUSH
32076: EMPTY
32077: LIST
32078: LIST
32079: PUSH
32080: LD_INT 3
32082: PUSH
32083: LD_INT 1
32085: PUSH
32086: EMPTY
32087: LIST
32088: LIST
32089: PUSH
32090: LD_INT 3
32092: PUSH
32093: LD_INT 2
32095: PUSH
32096: EMPTY
32097: LIST
32098: LIST
32099: PUSH
32100: EMPTY
32101: LIST
32102: LIST
32103: LIST
32104: LIST
32105: LIST
32106: LIST
32107: LIST
32108: LIST
32109: LIST
32110: LIST
32111: LIST
32112: LIST
32113: LIST
32114: LIST
32115: LIST
32116: LIST
32117: LIST
32118: LIST
32119: LIST
32120: LIST
32121: LIST
32122: LIST
32123: LIST
32124: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32125: LD_ADDR_VAR 0 25
32129: PUSH
32130: LD_INT 0
32132: PUSH
32133: LD_INT 0
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 0
32142: PUSH
32143: LD_INT 1
32145: NEG
32146: PUSH
32147: EMPTY
32148: LIST
32149: LIST
32150: PUSH
32151: LD_INT 1
32153: PUSH
32154: LD_INT 0
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: PUSH
32161: LD_INT 1
32163: PUSH
32164: LD_INT 1
32166: PUSH
32167: EMPTY
32168: LIST
32169: LIST
32170: PUSH
32171: LD_INT 0
32173: PUSH
32174: LD_INT 1
32176: PUSH
32177: EMPTY
32178: LIST
32179: LIST
32180: PUSH
32181: LD_INT 1
32183: NEG
32184: PUSH
32185: LD_INT 0
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 1
32194: NEG
32195: PUSH
32196: LD_INT 1
32198: NEG
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: LD_INT 1
32206: NEG
32207: PUSH
32208: LD_INT 2
32210: NEG
32211: PUSH
32212: EMPTY
32213: LIST
32214: LIST
32215: PUSH
32216: LD_INT 0
32218: PUSH
32219: LD_INT 2
32221: NEG
32222: PUSH
32223: EMPTY
32224: LIST
32225: LIST
32226: PUSH
32227: LD_INT 1
32229: PUSH
32230: LD_INT 1
32232: NEG
32233: PUSH
32234: EMPTY
32235: LIST
32236: LIST
32237: PUSH
32238: LD_INT 2
32240: PUSH
32241: LD_INT 0
32243: PUSH
32244: EMPTY
32245: LIST
32246: LIST
32247: PUSH
32248: LD_INT 2
32250: PUSH
32251: LD_INT 1
32253: PUSH
32254: EMPTY
32255: LIST
32256: LIST
32257: PUSH
32258: LD_INT 2
32260: PUSH
32261: LD_INT 2
32263: PUSH
32264: EMPTY
32265: LIST
32266: LIST
32267: PUSH
32268: LD_INT 1
32270: PUSH
32271: LD_INT 2
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PUSH
32278: LD_INT 0
32280: PUSH
32281: LD_INT 2
32283: PUSH
32284: EMPTY
32285: LIST
32286: LIST
32287: PUSH
32288: LD_INT 1
32290: NEG
32291: PUSH
32292: LD_INT 1
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PUSH
32299: LD_INT 2
32301: NEG
32302: PUSH
32303: LD_INT 0
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: LD_INT 2
32312: NEG
32313: PUSH
32314: LD_INT 1
32316: NEG
32317: PUSH
32318: EMPTY
32319: LIST
32320: LIST
32321: PUSH
32322: LD_INT 2
32324: NEG
32325: PUSH
32326: LD_INT 2
32328: NEG
32329: PUSH
32330: EMPTY
32331: LIST
32332: LIST
32333: PUSH
32334: LD_INT 3
32336: PUSH
32337: LD_INT 1
32339: PUSH
32340: EMPTY
32341: LIST
32342: LIST
32343: PUSH
32344: LD_INT 3
32346: PUSH
32347: LD_INT 2
32349: PUSH
32350: EMPTY
32351: LIST
32352: LIST
32353: PUSH
32354: LD_INT 2
32356: PUSH
32357: LD_INT 3
32359: PUSH
32360: EMPTY
32361: LIST
32362: LIST
32363: PUSH
32364: LD_INT 1
32366: PUSH
32367: LD_INT 3
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: EMPTY
32375: LIST
32376: LIST
32377: LIST
32378: LIST
32379: LIST
32380: LIST
32381: LIST
32382: LIST
32383: LIST
32384: LIST
32385: LIST
32386: LIST
32387: LIST
32388: LIST
32389: LIST
32390: LIST
32391: LIST
32392: LIST
32393: LIST
32394: LIST
32395: LIST
32396: LIST
32397: LIST
32398: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32399: LD_ADDR_VAR 0 26
32403: PUSH
32404: LD_INT 0
32406: PUSH
32407: LD_INT 0
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 0
32416: PUSH
32417: LD_INT 1
32419: NEG
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 1
32427: PUSH
32428: LD_INT 0
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: LD_INT 1
32437: PUSH
32438: LD_INT 1
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: PUSH
32445: LD_INT 0
32447: PUSH
32448: LD_INT 1
32450: PUSH
32451: EMPTY
32452: LIST
32453: LIST
32454: PUSH
32455: LD_INT 1
32457: NEG
32458: PUSH
32459: LD_INT 0
32461: PUSH
32462: EMPTY
32463: LIST
32464: LIST
32465: PUSH
32466: LD_INT 1
32468: NEG
32469: PUSH
32470: LD_INT 1
32472: NEG
32473: PUSH
32474: EMPTY
32475: LIST
32476: LIST
32477: PUSH
32478: LD_INT 1
32480: NEG
32481: PUSH
32482: LD_INT 2
32484: NEG
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 0
32492: PUSH
32493: LD_INT 2
32495: NEG
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 1
32503: PUSH
32504: LD_INT 1
32506: NEG
32507: PUSH
32508: EMPTY
32509: LIST
32510: LIST
32511: PUSH
32512: LD_INT 2
32514: PUSH
32515: LD_INT 0
32517: PUSH
32518: EMPTY
32519: LIST
32520: LIST
32521: PUSH
32522: LD_INT 2
32524: PUSH
32525: LD_INT 1
32527: PUSH
32528: EMPTY
32529: LIST
32530: LIST
32531: PUSH
32532: LD_INT 2
32534: PUSH
32535: LD_INT 2
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 1
32544: PUSH
32545: LD_INT 2
32547: PUSH
32548: EMPTY
32549: LIST
32550: LIST
32551: PUSH
32552: LD_INT 0
32554: PUSH
32555: LD_INT 2
32557: PUSH
32558: EMPTY
32559: LIST
32560: LIST
32561: PUSH
32562: LD_INT 1
32564: NEG
32565: PUSH
32566: LD_INT 1
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: LD_INT 2
32575: NEG
32576: PUSH
32577: LD_INT 0
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: PUSH
32584: LD_INT 2
32586: NEG
32587: PUSH
32588: LD_INT 1
32590: NEG
32591: PUSH
32592: EMPTY
32593: LIST
32594: LIST
32595: PUSH
32596: LD_INT 2
32598: NEG
32599: PUSH
32600: LD_INT 2
32602: NEG
32603: PUSH
32604: EMPTY
32605: LIST
32606: LIST
32607: PUSH
32608: LD_INT 2
32610: PUSH
32611: LD_INT 3
32613: PUSH
32614: EMPTY
32615: LIST
32616: LIST
32617: PUSH
32618: LD_INT 1
32620: PUSH
32621: LD_INT 3
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: PUSH
32628: LD_INT 1
32630: NEG
32631: PUSH
32632: LD_INT 2
32634: PUSH
32635: EMPTY
32636: LIST
32637: LIST
32638: PUSH
32639: LD_INT 2
32641: NEG
32642: PUSH
32643: LD_INT 1
32645: PUSH
32646: EMPTY
32647: LIST
32648: LIST
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: LIST
32657: LIST
32658: LIST
32659: LIST
32660: LIST
32661: LIST
32662: LIST
32663: LIST
32664: LIST
32665: LIST
32666: LIST
32667: LIST
32668: LIST
32669: LIST
32670: LIST
32671: LIST
32672: LIST
32673: LIST
32674: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32675: LD_ADDR_VAR 0 27
32679: PUSH
32680: LD_INT 0
32682: PUSH
32683: LD_INT 0
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PUSH
32690: LD_INT 0
32692: PUSH
32693: LD_INT 1
32695: NEG
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: PUSH
32701: LD_INT 1
32703: PUSH
32704: LD_INT 0
32706: PUSH
32707: EMPTY
32708: LIST
32709: LIST
32710: PUSH
32711: LD_INT 1
32713: PUSH
32714: LD_INT 1
32716: PUSH
32717: EMPTY
32718: LIST
32719: LIST
32720: PUSH
32721: LD_INT 0
32723: PUSH
32724: LD_INT 1
32726: PUSH
32727: EMPTY
32728: LIST
32729: LIST
32730: PUSH
32731: LD_INT 1
32733: NEG
32734: PUSH
32735: LD_INT 0
32737: PUSH
32738: EMPTY
32739: LIST
32740: LIST
32741: PUSH
32742: LD_INT 1
32744: NEG
32745: PUSH
32746: LD_INT 1
32748: NEG
32749: PUSH
32750: EMPTY
32751: LIST
32752: LIST
32753: PUSH
32754: LD_INT 1
32756: NEG
32757: PUSH
32758: LD_INT 2
32760: NEG
32761: PUSH
32762: EMPTY
32763: LIST
32764: LIST
32765: PUSH
32766: LD_INT 0
32768: PUSH
32769: LD_INT 2
32771: NEG
32772: PUSH
32773: EMPTY
32774: LIST
32775: LIST
32776: PUSH
32777: LD_INT 1
32779: PUSH
32780: LD_INT 1
32782: NEG
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 2
32790: PUSH
32791: LD_INT 0
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: PUSH
32798: LD_INT 2
32800: PUSH
32801: LD_INT 1
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 2
32810: PUSH
32811: LD_INT 2
32813: PUSH
32814: EMPTY
32815: LIST
32816: LIST
32817: PUSH
32818: LD_INT 1
32820: PUSH
32821: LD_INT 2
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 0
32830: PUSH
32831: LD_INT 2
32833: PUSH
32834: EMPTY
32835: LIST
32836: LIST
32837: PUSH
32838: LD_INT 1
32840: NEG
32841: PUSH
32842: LD_INT 1
32844: PUSH
32845: EMPTY
32846: LIST
32847: LIST
32848: PUSH
32849: LD_INT 2
32851: NEG
32852: PUSH
32853: LD_INT 0
32855: PUSH
32856: EMPTY
32857: LIST
32858: LIST
32859: PUSH
32860: LD_INT 2
32862: NEG
32863: PUSH
32864: LD_INT 1
32866: NEG
32867: PUSH
32868: EMPTY
32869: LIST
32870: LIST
32871: PUSH
32872: LD_INT 2
32874: NEG
32875: PUSH
32876: LD_INT 2
32878: NEG
32879: PUSH
32880: EMPTY
32881: LIST
32882: LIST
32883: PUSH
32884: LD_INT 1
32886: NEG
32887: PUSH
32888: LD_INT 2
32890: PUSH
32891: EMPTY
32892: LIST
32893: LIST
32894: PUSH
32895: LD_INT 2
32897: NEG
32898: PUSH
32899: LD_INT 1
32901: PUSH
32902: EMPTY
32903: LIST
32904: LIST
32905: PUSH
32906: LD_INT 3
32908: NEG
32909: PUSH
32910: LD_INT 1
32912: NEG
32913: PUSH
32914: EMPTY
32915: LIST
32916: LIST
32917: PUSH
32918: LD_INT 3
32920: NEG
32921: PUSH
32922: LD_INT 2
32924: NEG
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PUSH
32930: EMPTY
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: LIST
32941: LIST
32942: LIST
32943: LIST
32944: LIST
32945: LIST
32946: LIST
32947: LIST
32948: LIST
32949: LIST
32950: LIST
32951: LIST
32952: LIST
32953: LIST
32954: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32955: LD_ADDR_VAR 0 28
32959: PUSH
32960: LD_INT 0
32962: PUSH
32963: LD_INT 0
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 0
32972: PUSH
32973: LD_INT 1
32975: NEG
32976: PUSH
32977: EMPTY
32978: LIST
32979: LIST
32980: PUSH
32981: LD_INT 1
32983: PUSH
32984: LD_INT 0
32986: PUSH
32987: EMPTY
32988: LIST
32989: LIST
32990: PUSH
32991: LD_INT 1
32993: PUSH
32994: LD_INT 1
32996: PUSH
32997: EMPTY
32998: LIST
32999: LIST
33000: PUSH
33001: LD_INT 0
33003: PUSH
33004: LD_INT 1
33006: PUSH
33007: EMPTY
33008: LIST
33009: LIST
33010: PUSH
33011: LD_INT 1
33013: NEG
33014: PUSH
33015: LD_INT 0
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: PUSH
33022: LD_INT 1
33024: NEG
33025: PUSH
33026: LD_INT 1
33028: NEG
33029: PUSH
33030: EMPTY
33031: LIST
33032: LIST
33033: PUSH
33034: LD_INT 1
33036: NEG
33037: PUSH
33038: LD_INT 2
33040: NEG
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: PUSH
33046: LD_INT 0
33048: PUSH
33049: LD_INT 2
33051: NEG
33052: PUSH
33053: EMPTY
33054: LIST
33055: LIST
33056: PUSH
33057: LD_INT 1
33059: PUSH
33060: LD_INT 1
33062: NEG
33063: PUSH
33064: EMPTY
33065: LIST
33066: LIST
33067: PUSH
33068: LD_INT 2
33070: PUSH
33071: LD_INT 0
33073: PUSH
33074: EMPTY
33075: LIST
33076: LIST
33077: PUSH
33078: LD_INT 2
33080: PUSH
33081: LD_INT 1
33083: PUSH
33084: EMPTY
33085: LIST
33086: LIST
33087: PUSH
33088: LD_INT 2
33090: PUSH
33091: LD_INT 2
33093: PUSH
33094: EMPTY
33095: LIST
33096: LIST
33097: PUSH
33098: LD_INT 1
33100: PUSH
33101: LD_INT 2
33103: PUSH
33104: EMPTY
33105: LIST
33106: LIST
33107: PUSH
33108: LD_INT 0
33110: PUSH
33111: LD_INT 2
33113: PUSH
33114: EMPTY
33115: LIST
33116: LIST
33117: PUSH
33118: LD_INT 1
33120: NEG
33121: PUSH
33122: LD_INT 1
33124: PUSH
33125: EMPTY
33126: LIST
33127: LIST
33128: PUSH
33129: LD_INT 2
33131: NEG
33132: PUSH
33133: LD_INT 0
33135: PUSH
33136: EMPTY
33137: LIST
33138: LIST
33139: PUSH
33140: LD_INT 2
33142: NEG
33143: PUSH
33144: LD_INT 1
33146: NEG
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 2
33154: NEG
33155: PUSH
33156: LD_INT 2
33158: NEG
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: PUSH
33164: LD_INT 2
33166: NEG
33167: PUSH
33168: LD_INT 3
33170: NEG
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: LD_INT 1
33178: NEG
33179: PUSH
33180: LD_INT 3
33182: NEG
33183: PUSH
33184: EMPTY
33185: LIST
33186: LIST
33187: PUSH
33188: LD_INT 3
33190: NEG
33191: PUSH
33192: LD_INT 1
33194: NEG
33195: PUSH
33196: EMPTY
33197: LIST
33198: LIST
33199: PUSH
33200: LD_INT 3
33202: NEG
33203: PUSH
33204: LD_INT 2
33206: NEG
33207: PUSH
33208: EMPTY
33209: LIST
33210: LIST
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: LIST
33216: LIST
33217: LIST
33218: LIST
33219: LIST
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: LIST
33230: LIST
33231: LIST
33232: LIST
33233: LIST
33234: LIST
33235: LIST
33236: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33237: LD_ADDR_VAR 0 29
33241: PUSH
33242: LD_INT 0
33244: PUSH
33245: LD_INT 0
33247: PUSH
33248: EMPTY
33249: LIST
33250: LIST
33251: PUSH
33252: LD_INT 0
33254: PUSH
33255: LD_INT 1
33257: NEG
33258: PUSH
33259: EMPTY
33260: LIST
33261: LIST
33262: PUSH
33263: LD_INT 1
33265: PUSH
33266: LD_INT 0
33268: PUSH
33269: EMPTY
33270: LIST
33271: LIST
33272: PUSH
33273: LD_INT 1
33275: PUSH
33276: LD_INT 1
33278: PUSH
33279: EMPTY
33280: LIST
33281: LIST
33282: PUSH
33283: LD_INT 0
33285: PUSH
33286: LD_INT 1
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PUSH
33293: LD_INT 1
33295: NEG
33296: PUSH
33297: LD_INT 0
33299: PUSH
33300: EMPTY
33301: LIST
33302: LIST
33303: PUSH
33304: LD_INT 1
33306: NEG
33307: PUSH
33308: LD_INT 1
33310: NEG
33311: PUSH
33312: EMPTY
33313: LIST
33314: LIST
33315: PUSH
33316: LD_INT 1
33318: NEG
33319: PUSH
33320: LD_INT 2
33322: NEG
33323: PUSH
33324: EMPTY
33325: LIST
33326: LIST
33327: PUSH
33328: LD_INT 0
33330: PUSH
33331: LD_INT 2
33333: NEG
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 1
33341: PUSH
33342: LD_INT 1
33344: NEG
33345: PUSH
33346: EMPTY
33347: LIST
33348: LIST
33349: PUSH
33350: LD_INT 2
33352: PUSH
33353: LD_INT 0
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: LD_INT 2
33362: PUSH
33363: LD_INT 1
33365: PUSH
33366: EMPTY
33367: LIST
33368: LIST
33369: PUSH
33370: LD_INT 1
33372: PUSH
33373: LD_INT 2
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: LD_INT 0
33382: PUSH
33383: LD_INT 2
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 1
33392: NEG
33393: PUSH
33394: LD_INT 1
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 2
33403: NEG
33404: PUSH
33405: LD_INT 1
33407: NEG
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 2
33415: NEG
33416: PUSH
33417: LD_INT 2
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 2
33427: NEG
33428: PUSH
33429: LD_INT 3
33431: NEG
33432: PUSH
33433: EMPTY
33434: LIST
33435: LIST
33436: PUSH
33437: LD_INT 2
33439: PUSH
33440: LD_INT 1
33442: NEG
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 3
33450: PUSH
33451: LD_INT 1
33453: PUSH
33454: EMPTY
33455: LIST
33456: LIST
33457: PUSH
33458: LD_INT 1
33460: PUSH
33461: LD_INT 3
33463: PUSH
33464: EMPTY
33465: LIST
33466: LIST
33467: PUSH
33468: LD_INT 1
33470: NEG
33471: PUSH
33472: LD_INT 2
33474: PUSH
33475: EMPTY
33476: LIST
33477: LIST
33478: PUSH
33479: LD_INT 3
33481: NEG
33482: PUSH
33483: LD_INT 2
33485: NEG
33486: PUSH
33487: EMPTY
33488: LIST
33489: LIST
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: LIST
33495: LIST
33496: LIST
33497: LIST
33498: LIST
33499: LIST
33500: LIST
33501: LIST
33502: LIST
33503: LIST
33504: LIST
33505: LIST
33506: LIST
33507: LIST
33508: LIST
33509: LIST
33510: LIST
33511: LIST
33512: LIST
33513: LIST
33514: LIST
33515: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33516: LD_ADDR_VAR 0 30
33520: PUSH
33521: LD_INT 0
33523: PUSH
33524: LD_INT 0
33526: PUSH
33527: EMPTY
33528: LIST
33529: LIST
33530: PUSH
33531: LD_INT 0
33533: PUSH
33534: LD_INT 1
33536: NEG
33537: PUSH
33538: EMPTY
33539: LIST
33540: LIST
33541: PUSH
33542: LD_INT 1
33544: PUSH
33545: LD_INT 0
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PUSH
33552: LD_INT 1
33554: PUSH
33555: LD_INT 1
33557: PUSH
33558: EMPTY
33559: LIST
33560: LIST
33561: PUSH
33562: LD_INT 0
33564: PUSH
33565: LD_INT 1
33567: PUSH
33568: EMPTY
33569: LIST
33570: LIST
33571: PUSH
33572: LD_INT 1
33574: NEG
33575: PUSH
33576: LD_INT 0
33578: PUSH
33579: EMPTY
33580: LIST
33581: LIST
33582: PUSH
33583: LD_INT 1
33585: NEG
33586: PUSH
33587: LD_INT 1
33589: NEG
33590: PUSH
33591: EMPTY
33592: LIST
33593: LIST
33594: PUSH
33595: LD_INT 1
33597: NEG
33598: PUSH
33599: LD_INT 2
33601: NEG
33602: PUSH
33603: EMPTY
33604: LIST
33605: LIST
33606: PUSH
33607: LD_INT 0
33609: PUSH
33610: LD_INT 2
33612: NEG
33613: PUSH
33614: EMPTY
33615: LIST
33616: LIST
33617: PUSH
33618: LD_INT 1
33620: PUSH
33621: LD_INT 1
33623: NEG
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 2
33631: PUSH
33632: LD_INT 0
33634: PUSH
33635: EMPTY
33636: LIST
33637: LIST
33638: PUSH
33639: LD_INT 2
33641: PUSH
33642: LD_INT 1
33644: PUSH
33645: EMPTY
33646: LIST
33647: LIST
33648: PUSH
33649: LD_INT 2
33651: PUSH
33652: LD_INT 2
33654: PUSH
33655: EMPTY
33656: LIST
33657: LIST
33658: PUSH
33659: LD_INT 1
33661: PUSH
33662: LD_INT 2
33664: PUSH
33665: EMPTY
33666: LIST
33667: LIST
33668: PUSH
33669: LD_INT 1
33671: NEG
33672: PUSH
33673: LD_INT 1
33675: PUSH
33676: EMPTY
33677: LIST
33678: LIST
33679: PUSH
33680: LD_INT 2
33682: NEG
33683: PUSH
33684: LD_INT 0
33686: PUSH
33687: EMPTY
33688: LIST
33689: LIST
33690: PUSH
33691: LD_INT 2
33693: NEG
33694: PUSH
33695: LD_INT 1
33697: NEG
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 1
33705: NEG
33706: PUSH
33707: LD_INT 3
33709: NEG
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PUSH
33715: LD_INT 1
33717: PUSH
33718: LD_INT 2
33720: NEG
33721: PUSH
33722: EMPTY
33723: LIST
33724: LIST
33725: PUSH
33726: LD_INT 3
33728: PUSH
33729: LD_INT 2
33731: PUSH
33732: EMPTY
33733: LIST
33734: LIST
33735: PUSH
33736: LD_INT 2
33738: PUSH
33739: LD_INT 3
33741: PUSH
33742: EMPTY
33743: LIST
33744: LIST
33745: PUSH
33746: LD_INT 2
33748: NEG
33749: PUSH
33750: LD_INT 1
33752: PUSH
33753: EMPTY
33754: LIST
33755: LIST
33756: PUSH
33757: LD_INT 3
33759: NEG
33760: PUSH
33761: LD_INT 1
33763: NEG
33764: PUSH
33765: EMPTY
33766: LIST
33767: LIST
33768: PUSH
33769: EMPTY
33770: LIST
33771: LIST
33772: LIST
33773: LIST
33774: LIST
33775: LIST
33776: LIST
33777: LIST
33778: LIST
33779: LIST
33780: LIST
33781: LIST
33782: LIST
33783: LIST
33784: LIST
33785: LIST
33786: LIST
33787: LIST
33788: LIST
33789: LIST
33790: LIST
33791: LIST
33792: LIST
33793: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33794: LD_ADDR_VAR 0 31
33798: PUSH
33799: LD_INT 0
33801: PUSH
33802: LD_INT 0
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 0
33811: PUSH
33812: LD_INT 1
33814: NEG
33815: PUSH
33816: EMPTY
33817: LIST
33818: LIST
33819: PUSH
33820: LD_INT 1
33822: PUSH
33823: LD_INT 0
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 1
33832: PUSH
33833: LD_INT 1
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 0
33842: PUSH
33843: LD_INT 1
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 1
33852: NEG
33853: PUSH
33854: LD_INT 0
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 1
33863: NEG
33864: PUSH
33865: LD_INT 1
33867: NEG
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: PUSH
33873: LD_INT 1
33875: NEG
33876: PUSH
33877: LD_INT 2
33879: NEG
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 1
33887: PUSH
33888: LD_INT 1
33890: NEG
33891: PUSH
33892: EMPTY
33893: LIST
33894: LIST
33895: PUSH
33896: LD_INT 2
33898: PUSH
33899: LD_INT 0
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 2
33908: PUSH
33909: LD_INT 1
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 2
33918: PUSH
33919: LD_INT 2
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 1
33928: PUSH
33929: LD_INT 2
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 0
33938: PUSH
33939: LD_INT 2
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 1
33948: NEG
33949: PUSH
33950: LD_INT 1
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 2
33959: NEG
33960: PUSH
33961: LD_INT 1
33963: NEG
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 2
33971: NEG
33972: PUSH
33973: LD_INT 2
33975: NEG
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 2
33983: NEG
33984: PUSH
33985: LD_INT 3
33987: NEG
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 2
33995: PUSH
33996: LD_INT 1
33998: NEG
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 3
34006: PUSH
34007: LD_INT 1
34009: PUSH
34010: EMPTY
34011: LIST
34012: LIST
34013: PUSH
34014: LD_INT 1
34016: PUSH
34017: LD_INT 3
34019: PUSH
34020: EMPTY
34021: LIST
34022: LIST
34023: PUSH
34024: LD_INT 1
34026: NEG
34027: PUSH
34028: LD_INT 2
34030: PUSH
34031: EMPTY
34032: LIST
34033: LIST
34034: PUSH
34035: LD_INT 3
34037: NEG
34038: PUSH
34039: LD_INT 2
34041: NEG
34042: PUSH
34043: EMPTY
34044: LIST
34045: LIST
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: LIST
34053: LIST
34054: LIST
34055: LIST
34056: LIST
34057: LIST
34058: LIST
34059: LIST
34060: LIST
34061: LIST
34062: LIST
34063: LIST
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: LIST
34071: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34072: LD_ADDR_VAR 0 32
34076: PUSH
34077: LD_INT 0
34079: PUSH
34080: LD_INT 0
34082: PUSH
34083: EMPTY
34084: LIST
34085: LIST
34086: PUSH
34087: LD_INT 0
34089: PUSH
34090: LD_INT 1
34092: NEG
34093: PUSH
34094: EMPTY
34095: LIST
34096: LIST
34097: PUSH
34098: LD_INT 1
34100: PUSH
34101: LD_INT 0
34103: PUSH
34104: EMPTY
34105: LIST
34106: LIST
34107: PUSH
34108: LD_INT 1
34110: PUSH
34111: LD_INT 1
34113: PUSH
34114: EMPTY
34115: LIST
34116: LIST
34117: PUSH
34118: LD_INT 0
34120: PUSH
34121: LD_INT 1
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 1
34130: NEG
34131: PUSH
34132: LD_INT 0
34134: PUSH
34135: EMPTY
34136: LIST
34137: LIST
34138: PUSH
34139: LD_INT 1
34141: NEG
34142: PUSH
34143: LD_INT 1
34145: NEG
34146: PUSH
34147: EMPTY
34148: LIST
34149: LIST
34150: PUSH
34151: LD_INT 1
34153: NEG
34154: PUSH
34155: LD_INT 2
34157: NEG
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PUSH
34163: LD_INT 0
34165: PUSH
34166: LD_INT 2
34168: NEG
34169: PUSH
34170: EMPTY
34171: LIST
34172: LIST
34173: PUSH
34174: LD_INT 1
34176: PUSH
34177: LD_INT 1
34179: NEG
34180: PUSH
34181: EMPTY
34182: LIST
34183: LIST
34184: PUSH
34185: LD_INT 2
34187: PUSH
34188: LD_INT 1
34190: PUSH
34191: EMPTY
34192: LIST
34193: LIST
34194: PUSH
34195: LD_INT 2
34197: PUSH
34198: LD_INT 2
34200: PUSH
34201: EMPTY
34202: LIST
34203: LIST
34204: PUSH
34205: LD_INT 1
34207: PUSH
34208: LD_INT 2
34210: PUSH
34211: EMPTY
34212: LIST
34213: LIST
34214: PUSH
34215: LD_INT 0
34217: PUSH
34218: LD_INT 2
34220: PUSH
34221: EMPTY
34222: LIST
34223: LIST
34224: PUSH
34225: LD_INT 1
34227: NEG
34228: PUSH
34229: LD_INT 1
34231: PUSH
34232: EMPTY
34233: LIST
34234: LIST
34235: PUSH
34236: LD_INT 2
34238: NEG
34239: PUSH
34240: LD_INT 0
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 2
34249: NEG
34250: PUSH
34251: LD_INT 1
34253: NEG
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 1
34261: NEG
34262: PUSH
34263: LD_INT 3
34265: NEG
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PUSH
34271: LD_INT 1
34273: PUSH
34274: LD_INT 2
34276: NEG
34277: PUSH
34278: EMPTY
34279: LIST
34280: LIST
34281: PUSH
34282: LD_INT 3
34284: PUSH
34285: LD_INT 2
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: PUSH
34292: LD_INT 2
34294: PUSH
34295: LD_INT 3
34297: PUSH
34298: EMPTY
34299: LIST
34300: LIST
34301: PUSH
34302: LD_INT 2
34304: NEG
34305: PUSH
34306: LD_INT 1
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PUSH
34313: LD_INT 3
34315: NEG
34316: PUSH
34317: LD_INT 1
34319: NEG
34320: PUSH
34321: EMPTY
34322: LIST
34323: LIST
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: LIST
34329: LIST
34330: LIST
34331: LIST
34332: LIST
34333: LIST
34334: LIST
34335: LIST
34336: LIST
34337: LIST
34338: LIST
34339: LIST
34340: LIST
34341: LIST
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: LIST
34349: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34350: LD_ADDR_VAR 0 33
34354: PUSH
34355: LD_INT 0
34357: PUSH
34358: LD_INT 0
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: LD_INT 0
34367: PUSH
34368: LD_INT 1
34370: NEG
34371: PUSH
34372: EMPTY
34373: LIST
34374: LIST
34375: PUSH
34376: LD_INT 1
34378: PUSH
34379: LD_INT 0
34381: PUSH
34382: EMPTY
34383: LIST
34384: LIST
34385: PUSH
34386: LD_INT 1
34388: PUSH
34389: LD_INT 1
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: PUSH
34396: LD_INT 0
34398: PUSH
34399: LD_INT 1
34401: PUSH
34402: EMPTY
34403: LIST
34404: LIST
34405: PUSH
34406: LD_INT 1
34408: NEG
34409: PUSH
34410: LD_INT 0
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: PUSH
34417: LD_INT 1
34419: NEG
34420: PUSH
34421: LD_INT 1
34423: NEG
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 1
34431: NEG
34432: PUSH
34433: LD_INT 2
34435: NEG
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 1
34443: PUSH
34444: LD_INT 1
34446: NEG
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 2
34454: PUSH
34455: LD_INT 0
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 2
34464: PUSH
34465: LD_INT 1
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 1
34474: PUSH
34475: LD_INT 2
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 0
34484: PUSH
34485: LD_INT 2
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 1
34494: NEG
34495: PUSH
34496: LD_INT 1
34498: PUSH
34499: EMPTY
34500: LIST
34501: LIST
34502: PUSH
34503: LD_INT 2
34505: NEG
34506: PUSH
34507: LD_INT 0
34509: PUSH
34510: EMPTY
34511: LIST
34512: LIST
34513: PUSH
34514: LD_INT 2
34516: NEG
34517: PUSH
34518: LD_INT 1
34520: NEG
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 2
34528: NEG
34529: PUSH
34530: LD_INT 2
34532: NEG
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 2
34540: NEG
34541: PUSH
34542: LD_INT 3
34544: NEG
34545: PUSH
34546: EMPTY
34547: LIST
34548: LIST
34549: PUSH
34550: LD_INT 2
34552: PUSH
34553: LD_INT 1
34555: NEG
34556: PUSH
34557: EMPTY
34558: LIST
34559: LIST
34560: PUSH
34561: LD_INT 3
34563: PUSH
34564: LD_INT 1
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: LD_INT 1
34573: PUSH
34574: LD_INT 3
34576: PUSH
34577: EMPTY
34578: LIST
34579: LIST
34580: PUSH
34581: LD_INT 1
34583: NEG
34584: PUSH
34585: LD_INT 2
34587: PUSH
34588: EMPTY
34589: LIST
34590: LIST
34591: PUSH
34592: LD_INT 3
34594: NEG
34595: PUSH
34596: LD_INT 2
34598: NEG
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: EMPTY
34605: LIST
34606: LIST
34607: LIST
34608: LIST
34609: LIST
34610: LIST
34611: LIST
34612: LIST
34613: LIST
34614: LIST
34615: LIST
34616: LIST
34617: LIST
34618: LIST
34619: LIST
34620: LIST
34621: LIST
34622: LIST
34623: LIST
34624: LIST
34625: LIST
34626: LIST
34627: LIST
34628: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34629: LD_ADDR_VAR 0 34
34633: PUSH
34634: LD_INT 0
34636: PUSH
34637: LD_INT 0
34639: PUSH
34640: EMPTY
34641: LIST
34642: LIST
34643: PUSH
34644: LD_INT 0
34646: PUSH
34647: LD_INT 1
34649: NEG
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: LD_INT 1
34657: PUSH
34658: LD_INT 0
34660: PUSH
34661: EMPTY
34662: LIST
34663: LIST
34664: PUSH
34665: LD_INT 1
34667: PUSH
34668: LD_INT 1
34670: PUSH
34671: EMPTY
34672: LIST
34673: LIST
34674: PUSH
34675: LD_INT 0
34677: PUSH
34678: LD_INT 1
34680: PUSH
34681: EMPTY
34682: LIST
34683: LIST
34684: PUSH
34685: LD_INT 1
34687: NEG
34688: PUSH
34689: LD_INT 0
34691: PUSH
34692: EMPTY
34693: LIST
34694: LIST
34695: PUSH
34696: LD_INT 1
34698: NEG
34699: PUSH
34700: LD_INT 1
34702: NEG
34703: PUSH
34704: EMPTY
34705: LIST
34706: LIST
34707: PUSH
34708: LD_INT 1
34710: NEG
34711: PUSH
34712: LD_INT 2
34714: NEG
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: LD_INT 0
34722: PUSH
34723: LD_INT 2
34725: NEG
34726: PUSH
34727: EMPTY
34728: LIST
34729: LIST
34730: PUSH
34731: LD_INT 1
34733: PUSH
34734: LD_INT 1
34736: NEG
34737: PUSH
34738: EMPTY
34739: LIST
34740: LIST
34741: PUSH
34742: LD_INT 2
34744: PUSH
34745: LD_INT 1
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PUSH
34752: LD_INT 2
34754: PUSH
34755: LD_INT 2
34757: PUSH
34758: EMPTY
34759: LIST
34760: LIST
34761: PUSH
34762: LD_INT 1
34764: PUSH
34765: LD_INT 2
34767: PUSH
34768: EMPTY
34769: LIST
34770: LIST
34771: PUSH
34772: LD_INT 1
34774: NEG
34775: PUSH
34776: LD_INT 1
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 2
34785: NEG
34786: PUSH
34787: LD_INT 0
34789: PUSH
34790: EMPTY
34791: LIST
34792: LIST
34793: PUSH
34794: LD_INT 2
34796: NEG
34797: PUSH
34798: LD_INT 1
34800: NEG
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 2
34808: NEG
34809: PUSH
34810: LD_INT 2
34812: NEG
34813: PUSH
34814: EMPTY
34815: LIST
34816: LIST
34817: PUSH
34818: LD_INT 1
34820: NEG
34821: PUSH
34822: LD_INT 3
34824: NEG
34825: PUSH
34826: EMPTY
34827: LIST
34828: LIST
34829: PUSH
34830: LD_INT 1
34832: PUSH
34833: LD_INT 2
34835: NEG
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 3
34843: PUSH
34844: LD_INT 2
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 2
34853: PUSH
34854: LD_INT 3
34856: PUSH
34857: EMPTY
34858: LIST
34859: LIST
34860: PUSH
34861: LD_INT 2
34863: NEG
34864: PUSH
34865: LD_INT 1
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: LD_INT 3
34874: NEG
34875: PUSH
34876: LD_INT 1
34878: NEG
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: LIST
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: LIST
34901: LIST
34902: LIST
34903: LIST
34904: LIST
34905: LIST
34906: LIST
34907: LIST
34908: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34909: LD_ADDR_VAR 0 35
34913: PUSH
34914: LD_INT 0
34916: PUSH
34917: LD_INT 0
34919: PUSH
34920: EMPTY
34921: LIST
34922: LIST
34923: PUSH
34924: LD_INT 0
34926: PUSH
34927: LD_INT 1
34929: NEG
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: LD_INT 1
34937: PUSH
34938: LD_INT 0
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 1
34947: PUSH
34948: LD_INT 1
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 0
34957: PUSH
34958: LD_INT 1
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 1
34967: NEG
34968: PUSH
34969: LD_INT 0
34971: PUSH
34972: EMPTY
34973: LIST
34974: LIST
34975: PUSH
34976: LD_INT 1
34978: NEG
34979: PUSH
34980: LD_INT 1
34982: NEG
34983: PUSH
34984: EMPTY
34985: LIST
34986: LIST
34987: PUSH
34988: LD_INT 2
34990: PUSH
34991: LD_INT 1
34993: PUSH
34994: EMPTY
34995: LIST
34996: LIST
34997: PUSH
34998: LD_INT 2
35000: NEG
35001: PUSH
35002: LD_INT 1
35004: NEG
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: LIST
35014: LIST
35015: LIST
35016: LIST
35017: LIST
35018: LIST
35019: LIST
35020: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35021: LD_ADDR_VAR 0 36
35025: PUSH
35026: LD_INT 0
35028: PUSH
35029: LD_INT 0
35031: PUSH
35032: EMPTY
35033: LIST
35034: LIST
35035: PUSH
35036: LD_INT 0
35038: PUSH
35039: LD_INT 1
35041: NEG
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: PUSH
35047: LD_INT 1
35049: PUSH
35050: LD_INT 0
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: LD_INT 1
35059: PUSH
35060: LD_INT 1
35062: PUSH
35063: EMPTY
35064: LIST
35065: LIST
35066: PUSH
35067: LD_INT 0
35069: PUSH
35070: LD_INT 1
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 1
35079: NEG
35080: PUSH
35081: LD_INT 0
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 1
35090: NEG
35091: PUSH
35092: LD_INT 1
35094: NEG
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 1
35102: NEG
35103: PUSH
35104: LD_INT 2
35106: NEG
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: LD_INT 1
35114: PUSH
35115: LD_INT 2
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: EMPTY
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35133: LD_ADDR_VAR 0 37
35137: PUSH
35138: LD_INT 0
35140: PUSH
35141: LD_INT 0
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 0
35150: PUSH
35151: LD_INT 1
35153: NEG
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 1
35161: PUSH
35162: LD_INT 0
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 1
35171: PUSH
35172: LD_INT 1
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: LD_INT 0
35181: PUSH
35182: LD_INT 1
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 1
35191: NEG
35192: PUSH
35193: LD_INT 0
35195: PUSH
35196: EMPTY
35197: LIST
35198: LIST
35199: PUSH
35200: LD_INT 1
35202: NEG
35203: PUSH
35204: LD_INT 1
35206: NEG
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 1
35214: PUSH
35215: LD_INT 1
35217: NEG
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 1
35225: NEG
35226: PUSH
35227: LD_INT 1
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: LIST
35238: LIST
35239: LIST
35240: LIST
35241: LIST
35242: LIST
35243: LIST
35244: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35245: LD_ADDR_VAR 0 38
35249: PUSH
35250: LD_INT 0
35252: PUSH
35253: LD_INT 0
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 0
35262: PUSH
35263: LD_INT 1
35265: NEG
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: PUSH
35271: LD_INT 1
35273: PUSH
35274: LD_INT 0
35276: PUSH
35277: EMPTY
35278: LIST
35279: LIST
35280: PUSH
35281: LD_INT 1
35283: PUSH
35284: LD_INT 1
35286: PUSH
35287: EMPTY
35288: LIST
35289: LIST
35290: PUSH
35291: LD_INT 0
35293: PUSH
35294: LD_INT 1
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: PUSH
35301: LD_INT 1
35303: NEG
35304: PUSH
35305: LD_INT 0
35307: PUSH
35308: EMPTY
35309: LIST
35310: LIST
35311: PUSH
35312: LD_INT 1
35314: NEG
35315: PUSH
35316: LD_INT 1
35318: NEG
35319: PUSH
35320: EMPTY
35321: LIST
35322: LIST
35323: PUSH
35324: LD_INT 2
35326: PUSH
35327: LD_INT 1
35329: PUSH
35330: EMPTY
35331: LIST
35332: LIST
35333: PUSH
35334: LD_INT 2
35336: NEG
35337: PUSH
35338: LD_INT 1
35340: NEG
35341: PUSH
35342: EMPTY
35343: LIST
35344: LIST
35345: PUSH
35346: EMPTY
35347: LIST
35348: LIST
35349: LIST
35350: LIST
35351: LIST
35352: LIST
35353: LIST
35354: LIST
35355: LIST
35356: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35357: LD_ADDR_VAR 0 39
35361: PUSH
35362: LD_INT 0
35364: PUSH
35365: LD_INT 0
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 0
35374: PUSH
35375: LD_INT 1
35377: NEG
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: LD_INT 1
35385: PUSH
35386: LD_INT 0
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: PUSH
35393: LD_INT 1
35395: PUSH
35396: LD_INT 1
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 0
35405: PUSH
35406: LD_INT 1
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: LD_INT 1
35415: NEG
35416: PUSH
35417: LD_INT 0
35419: PUSH
35420: EMPTY
35421: LIST
35422: LIST
35423: PUSH
35424: LD_INT 1
35426: NEG
35427: PUSH
35428: LD_INT 1
35430: NEG
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 1
35438: NEG
35439: PUSH
35440: LD_INT 2
35442: NEG
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 1
35450: PUSH
35451: LD_INT 2
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PUSH
35458: EMPTY
35459: LIST
35460: LIST
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35469: LD_ADDR_VAR 0 40
35473: PUSH
35474: LD_INT 0
35476: PUSH
35477: LD_INT 0
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PUSH
35484: LD_INT 0
35486: PUSH
35487: LD_INT 1
35489: NEG
35490: PUSH
35491: EMPTY
35492: LIST
35493: LIST
35494: PUSH
35495: LD_INT 1
35497: PUSH
35498: LD_INT 0
35500: PUSH
35501: EMPTY
35502: LIST
35503: LIST
35504: PUSH
35505: LD_INT 1
35507: PUSH
35508: LD_INT 1
35510: PUSH
35511: EMPTY
35512: LIST
35513: LIST
35514: PUSH
35515: LD_INT 0
35517: PUSH
35518: LD_INT 1
35520: PUSH
35521: EMPTY
35522: LIST
35523: LIST
35524: PUSH
35525: LD_INT 1
35527: NEG
35528: PUSH
35529: LD_INT 0
35531: PUSH
35532: EMPTY
35533: LIST
35534: LIST
35535: PUSH
35536: LD_INT 1
35538: NEG
35539: PUSH
35540: LD_INT 1
35542: NEG
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 1
35550: PUSH
35551: LD_INT 1
35553: NEG
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 1
35561: NEG
35562: PUSH
35563: LD_INT 1
35565: PUSH
35566: EMPTY
35567: LIST
35568: LIST
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: LIST
35580: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35581: LD_ADDR_VAR 0 41
35585: PUSH
35586: LD_INT 0
35588: PUSH
35589: LD_INT 0
35591: PUSH
35592: EMPTY
35593: LIST
35594: LIST
35595: PUSH
35596: LD_INT 0
35598: PUSH
35599: LD_INT 1
35601: NEG
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: PUSH
35607: LD_INT 1
35609: PUSH
35610: LD_INT 0
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PUSH
35617: LD_INT 1
35619: PUSH
35620: LD_INT 1
35622: PUSH
35623: EMPTY
35624: LIST
35625: LIST
35626: PUSH
35627: LD_INT 0
35629: PUSH
35630: LD_INT 1
35632: PUSH
35633: EMPTY
35634: LIST
35635: LIST
35636: PUSH
35637: LD_INT 1
35639: NEG
35640: PUSH
35641: LD_INT 0
35643: PUSH
35644: EMPTY
35645: LIST
35646: LIST
35647: PUSH
35648: LD_INT 1
35650: NEG
35651: PUSH
35652: LD_INT 1
35654: NEG
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 1
35662: NEG
35663: PUSH
35664: LD_INT 2
35666: NEG
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: PUSH
35672: LD_INT 1
35674: PUSH
35675: LD_INT 1
35677: NEG
35678: PUSH
35679: EMPTY
35680: LIST
35681: LIST
35682: PUSH
35683: LD_INT 2
35685: PUSH
35686: LD_INT 0
35688: PUSH
35689: EMPTY
35690: LIST
35691: LIST
35692: PUSH
35693: LD_INT 2
35695: PUSH
35696: LD_INT 1
35698: PUSH
35699: EMPTY
35700: LIST
35701: LIST
35702: PUSH
35703: LD_INT 2
35705: PUSH
35706: LD_INT 2
35708: PUSH
35709: EMPTY
35710: LIST
35711: LIST
35712: PUSH
35713: LD_INT 1
35715: PUSH
35716: LD_INT 2
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: PUSH
35723: LD_INT 1
35725: NEG
35726: PUSH
35727: LD_INT 1
35729: PUSH
35730: EMPTY
35731: LIST
35732: LIST
35733: PUSH
35734: LD_INT 2
35736: NEG
35737: PUSH
35738: LD_INT 0
35740: PUSH
35741: EMPTY
35742: LIST
35743: LIST
35744: PUSH
35745: LD_INT 2
35747: NEG
35748: PUSH
35749: LD_INT 1
35751: NEG
35752: PUSH
35753: EMPTY
35754: LIST
35755: LIST
35756: PUSH
35757: LD_INT 2
35759: NEG
35760: PUSH
35761: LD_INT 2
35763: NEG
35764: PUSH
35765: EMPTY
35766: LIST
35767: LIST
35768: PUSH
35769: LD_INT 2
35771: NEG
35772: PUSH
35773: LD_INT 3
35775: NEG
35776: PUSH
35777: EMPTY
35778: LIST
35779: LIST
35780: PUSH
35781: LD_INT 2
35783: PUSH
35784: LD_INT 1
35786: NEG
35787: PUSH
35788: EMPTY
35789: LIST
35790: LIST
35791: PUSH
35792: LD_INT 3
35794: PUSH
35795: LD_INT 0
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: LD_INT 3
35804: PUSH
35805: LD_INT 1
35807: PUSH
35808: EMPTY
35809: LIST
35810: LIST
35811: PUSH
35812: LD_INT 3
35814: PUSH
35815: LD_INT 2
35817: PUSH
35818: EMPTY
35819: LIST
35820: LIST
35821: PUSH
35822: LD_INT 3
35824: PUSH
35825: LD_INT 3
35827: PUSH
35828: EMPTY
35829: LIST
35830: LIST
35831: PUSH
35832: LD_INT 2
35834: PUSH
35835: LD_INT 3
35837: PUSH
35838: EMPTY
35839: LIST
35840: LIST
35841: PUSH
35842: LD_INT 2
35844: NEG
35845: PUSH
35846: LD_INT 1
35848: PUSH
35849: EMPTY
35850: LIST
35851: LIST
35852: PUSH
35853: LD_INT 3
35855: NEG
35856: PUSH
35857: LD_INT 0
35859: PUSH
35860: EMPTY
35861: LIST
35862: LIST
35863: PUSH
35864: LD_INT 3
35866: NEG
35867: PUSH
35868: LD_INT 1
35870: NEG
35871: PUSH
35872: EMPTY
35873: LIST
35874: LIST
35875: PUSH
35876: LD_INT 3
35878: NEG
35879: PUSH
35880: LD_INT 2
35882: NEG
35883: PUSH
35884: EMPTY
35885: LIST
35886: LIST
35887: PUSH
35888: LD_INT 3
35890: NEG
35891: PUSH
35892: LD_INT 3
35894: NEG
35895: PUSH
35896: EMPTY
35897: LIST
35898: LIST
35899: PUSH
35900: EMPTY
35901: LIST
35902: LIST
35903: LIST
35904: LIST
35905: LIST
35906: LIST
35907: LIST
35908: LIST
35909: LIST
35910: LIST
35911: LIST
35912: LIST
35913: LIST
35914: LIST
35915: LIST
35916: LIST
35917: LIST
35918: LIST
35919: LIST
35920: LIST
35921: LIST
35922: LIST
35923: LIST
35924: LIST
35925: LIST
35926: LIST
35927: LIST
35928: LIST
35929: LIST
35930: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35931: LD_ADDR_VAR 0 42
35935: PUSH
35936: LD_INT 0
35938: PUSH
35939: LD_INT 0
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 0
35948: PUSH
35949: LD_INT 1
35951: NEG
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 1
35959: PUSH
35960: LD_INT 0
35962: PUSH
35963: EMPTY
35964: LIST
35965: LIST
35966: PUSH
35967: LD_INT 1
35969: PUSH
35970: LD_INT 1
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 0
35979: PUSH
35980: LD_INT 1
35982: PUSH
35983: EMPTY
35984: LIST
35985: LIST
35986: PUSH
35987: LD_INT 1
35989: NEG
35990: PUSH
35991: LD_INT 0
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: PUSH
35998: LD_INT 1
36000: NEG
36001: PUSH
36002: LD_INT 1
36004: NEG
36005: PUSH
36006: EMPTY
36007: LIST
36008: LIST
36009: PUSH
36010: LD_INT 1
36012: NEG
36013: PUSH
36014: LD_INT 2
36016: NEG
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 0
36024: PUSH
36025: LD_INT 2
36027: NEG
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: LD_INT 1
36035: PUSH
36036: LD_INT 1
36038: NEG
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 2
36046: PUSH
36047: LD_INT 1
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: LD_INT 2
36056: PUSH
36057: LD_INT 2
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: LD_INT 1
36066: PUSH
36067: LD_INT 2
36069: PUSH
36070: EMPTY
36071: LIST
36072: LIST
36073: PUSH
36074: LD_INT 0
36076: PUSH
36077: LD_INT 2
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: PUSH
36084: LD_INT 1
36086: NEG
36087: PUSH
36088: LD_INT 1
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: LD_INT 2
36097: NEG
36098: PUSH
36099: LD_INT 1
36101: NEG
36102: PUSH
36103: EMPTY
36104: LIST
36105: LIST
36106: PUSH
36107: LD_INT 2
36109: NEG
36110: PUSH
36111: LD_INT 2
36113: NEG
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 2
36121: NEG
36122: PUSH
36123: LD_INT 3
36125: NEG
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 1
36133: NEG
36134: PUSH
36135: LD_INT 3
36137: NEG
36138: PUSH
36139: EMPTY
36140: LIST
36141: LIST
36142: PUSH
36143: LD_INT 0
36145: PUSH
36146: LD_INT 3
36148: NEG
36149: PUSH
36150: EMPTY
36151: LIST
36152: LIST
36153: PUSH
36154: LD_INT 1
36156: PUSH
36157: LD_INT 2
36159: NEG
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: PUSH
36165: LD_INT 3
36167: PUSH
36168: LD_INT 2
36170: PUSH
36171: EMPTY
36172: LIST
36173: LIST
36174: PUSH
36175: LD_INT 3
36177: PUSH
36178: LD_INT 3
36180: PUSH
36181: EMPTY
36182: LIST
36183: LIST
36184: PUSH
36185: LD_INT 2
36187: PUSH
36188: LD_INT 3
36190: PUSH
36191: EMPTY
36192: LIST
36193: LIST
36194: PUSH
36195: LD_INT 1
36197: PUSH
36198: LD_INT 3
36200: PUSH
36201: EMPTY
36202: LIST
36203: LIST
36204: PUSH
36205: LD_INT 0
36207: PUSH
36208: LD_INT 3
36210: PUSH
36211: EMPTY
36212: LIST
36213: LIST
36214: PUSH
36215: LD_INT 1
36217: NEG
36218: PUSH
36219: LD_INT 2
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 3
36228: NEG
36229: PUSH
36230: LD_INT 2
36232: NEG
36233: PUSH
36234: EMPTY
36235: LIST
36236: LIST
36237: PUSH
36238: LD_INT 3
36240: NEG
36241: PUSH
36242: LD_INT 3
36244: NEG
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: LIST
36254: LIST
36255: LIST
36256: LIST
36257: LIST
36258: LIST
36259: LIST
36260: LIST
36261: LIST
36262: LIST
36263: LIST
36264: LIST
36265: LIST
36266: LIST
36267: LIST
36268: LIST
36269: LIST
36270: LIST
36271: LIST
36272: LIST
36273: LIST
36274: LIST
36275: LIST
36276: LIST
36277: LIST
36278: LIST
36279: LIST
36280: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36281: LD_ADDR_VAR 0 43
36285: PUSH
36286: LD_INT 0
36288: PUSH
36289: LD_INT 0
36291: PUSH
36292: EMPTY
36293: LIST
36294: LIST
36295: PUSH
36296: LD_INT 0
36298: PUSH
36299: LD_INT 1
36301: NEG
36302: PUSH
36303: EMPTY
36304: LIST
36305: LIST
36306: PUSH
36307: LD_INT 1
36309: PUSH
36310: LD_INT 0
36312: PUSH
36313: EMPTY
36314: LIST
36315: LIST
36316: PUSH
36317: LD_INT 1
36319: PUSH
36320: LD_INT 1
36322: PUSH
36323: EMPTY
36324: LIST
36325: LIST
36326: PUSH
36327: LD_INT 0
36329: PUSH
36330: LD_INT 1
36332: PUSH
36333: EMPTY
36334: LIST
36335: LIST
36336: PUSH
36337: LD_INT 1
36339: NEG
36340: PUSH
36341: LD_INT 0
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: LD_INT 1
36350: NEG
36351: PUSH
36352: LD_INT 1
36354: NEG
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: LD_INT 1
36362: NEG
36363: PUSH
36364: LD_INT 2
36366: NEG
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: LD_INT 0
36374: PUSH
36375: LD_INT 2
36377: NEG
36378: PUSH
36379: EMPTY
36380: LIST
36381: LIST
36382: PUSH
36383: LD_INT 1
36385: PUSH
36386: LD_INT 1
36388: NEG
36389: PUSH
36390: EMPTY
36391: LIST
36392: LIST
36393: PUSH
36394: LD_INT 2
36396: PUSH
36397: LD_INT 0
36399: PUSH
36400: EMPTY
36401: LIST
36402: LIST
36403: PUSH
36404: LD_INT 2
36406: PUSH
36407: LD_INT 1
36409: PUSH
36410: EMPTY
36411: LIST
36412: LIST
36413: PUSH
36414: LD_INT 1
36416: PUSH
36417: LD_INT 2
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: PUSH
36424: LD_INT 0
36426: PUSH
36427: LD_INT 2
36429: PUSH
36430: EMPTY
36431: LIST
36432: LIST
36433: PUSH
36434: LD_INT 1
36436: NEG
36437: PUSH
36438: LD_INT 1
36440: PUSH
36441: EMPTY
36442: LIST
36443: LIST
36444: PUSH
36445: LD_INT 2
36447: NEG
36448: PUSH
36449: LD_INT 0
36451: PUSH
36452: EMPTY
36453: LIST
36454: LIST
36455: PUSH
36456: LD_INT 2
36458: NEG
36459: PUSH
36460: LD_INT 1
36462: NEG
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 1
36470: NEG
36471: PUSH
36472: LD_INT 3
36474: NEG
36475: PUSH
36476: EMPTY
36477: LIST
36478: LIST
36479: PUSH
36480: LD_INT 0
36482: PUSH
36483: LD_INT 3
36485: NEG
36486: PUSH
36487: EMPTY
36488: LIST
36489: LIST
36490: PUSH
36491: LD_INT 1
36493: PUSH
36494: LD_INT 2
36496: NEG
36497: PUSH
36498: EMPTY
36499: LIST
36500: LIST
36501: PUSH
36502: LD_INT 2
36504: PUSH
36505: LD_INT 1
36507: NEG
36508: PUSH
36509: EMPTY
36510: LIST
36511: LIST
36512: PUSH
36513: LD_INT 3
36515: PUSH
36516: LD_INT 0
36518: PUSH
36519: EMPTY
36520: LIST
36521: LIST
36522: PUSH
36523: LD_INT 3
36525: PUSH
36526: LD_INT 1
36528: PUSH
36529: EMPTY
36530: LIST
36531: LIST
36532: PUSH
36533: LD_INT 1
36535: PUSH
36536: LD_INT 3
36538: PUSH
36539: EMPTY
36540: LIST
36541: LIST
36542: PUSH
36543: LD_INT 0
36545: PUSH
36546: LD_INT 3
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: PUSH
36553: LD_INT 1
36555: NEG
36556: PUSH
36557: LD_INT 2
36559: PUSH
36560: EMPTY
36561: LIST
36562: LIST
36563: PUSH
36564: LD_INT 2
36566: NEG
36567: PUSH
36568: LD_INT 1
36570: PUSH
36571: EMPTY
36572: LIST
36573: LIST
36574: PUSH
36575: LD_INT 3
36577: NEG
36578: PUSH
36579: LD_INT 0
36581: PUSH
36582: EMPTY
36583: LIST
36584: LIST
36585: PUSH
36586: LD_INT 3
36588: NEG
36589: PUSH
36590: LD_INT 1
36592: NEG
36593: PUSH
36594: EMPTY
36595: LIST
36596: LIST
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: LIST
36602: LIST
36603: LIST
36604: LIST
36605: LIST
36606: LIST
36607: LIST
36608: LIST
36609: LIST
36610: LIST
36611: LIST
36612: LIST
36613: LIST
36614: LIST
36615: LIST
36616: LIST
36617: LIST
36618: LIST
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: LIST
36628: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36629: LD_ADDR_VAR 0 44
36633: PUSH
36634: LD_INT 0
36636: PUSH
36637: LD_INT 0
36639: PUSH
36640: EMPTY
36641: LIST
36642: LIST
36643: PUSH
36644: LD_INT 0
36646: PUSH
36647: LD_INT 1
36649: NEG
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 1
36657: PUSH
36658: LD_INT 0
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 1
36667: PUSH
36668: LD_INT 1
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PUSH
36675: LD_INT 0
36677: PUSH
36678: LD_INT 1
36680: PUSH
36681: EMPTY
36682: LIST
36683: LIST
36684: PUSH
36685: LD_INT 1
36687: NEG
36688: PUSH
36689: LD_INT 0
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: PUSH
36696: LD_INT 1
36698: NEG
36699: PUSH
36700: LD_INT 1
36702: NEG
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 1
36710: NEG
36711: PUSH
36712: LD_INT 2
36714: NEG
36715: PUSH
36716: EMPTY
36717: LIST
36718: LIST
36719: PUSH
36720: LD_INT 1
36722: PUSH
36723: LD_INT 1
36725: NEG
36726: PUSH
36727: EMPTY
36728: LIST
36729: LIST
36730: PUSH
36731: LD_INT 2
36733: PUSH
36734: LD_INT 0
36736: PUSH
36737: EMPTY
36738: LIST
36739: LIST
36740: PUSH
36741: LD_INT 2
36743: PUSH
36744: LD_INT 1
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 2
36753: PUSH
36754: LD_INT 2
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 1
36763: PUSH
36764: LD_INT 2
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: PUSH
36771: LD_INT 1
36773: NEG
36774: PUSH
36775: LD_INT 1
36777: PUSH
36778: EMPTY
36779: LIST
36780: LIST
36781: PUSH
36782: LD_INT 2
36784: NEG
36785: PUSH
36786: LD_INT 0
36788: PUSH
36789: EMPTY
36790: LIST
36791: LIST
36792: PUSH
36793: LD_INT 2
36795: NEG
36796: PUSH
36797: LD_INT 1
36799: NEG
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: PUSH
36805: LD_INT 2
36807: NEG
36808: PUSH
36809: LD_INT 2
36811: NEG
36812: PUSH
36813: EMPTY
36814: LIST
36815: LIST
36816: PUSH
36817: LD_INT 2
36819: NEG
36820: PUSH
36821: LD_INT 3
36823: NEG
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 2
36831: PUSH
36832: LD_INT 1
36834: NEG
36835: PUSH
36836: EMPTY
36837: LIST
36838: LIST
36839: PUSH
36840: LD_INT 3
36842: PUSH
36843: LD_INT 0
36845: PUSH
36846: EMPTY
36847: LIST
36848: LIST
36849: PUSH
36850: LD_INT 3
36852: PUSH
36853: LD_INT 1
36855: PUSH
36856: EMPTY
36857: LIST
36858: LIST
36859: PUSH
36860: LD_INT 3
36862: PUSH
36863: LD_INT 2
36865: PUSH
36866: EMPTY
36867: LIST
36868: LIST
36869: PUSH
36870: LD_INT 3
36872: PUSH
36873: LD_INT 3
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: LD_INT 2
36882: PUSH
36883: LD_INT 3
36885: PUSH
36886: EMPTY
36887: LIST
36888: LIST
36889: PUSH
36890: LD_INT 2
36892: NEG
36893: PUSH
36894: LD_INT 1
36896: PUSH
36897: EMPTY
36898: LIST
36899: LIST
36900: PUSH
36901: LD_INT 3
36903: NEG
36904: PUSH
36905: LD_INT 0
36907: PUSH
36908: EMPTY
36909: LIST
36910: LIST
36911: PUSH
36912: LD_INT 3
36914: NEG
36915: PUSH
36916: LD_INT 1
36918: NEG
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: PUSH
36924: LD_INT 3
36926: NEG
36927: PUSH
36928: LD_INT 2
36930: NEG
36931: PUSH
36932: EMPTY
36933: LIST
36934: LIST
36935: PUSH
36936: LD_INT 3
36938: NEG
36939: PUSH
36940: LD_INT 3
36942: NEG
36943: PUSH
36944: EMPTY
36945: LIST
36946: LIST
36947: PUSH
36948: EMPTY
36949: LIST
36950: LIST
36951: LIST
36952: LIST
36953: LIST
36954: LIST
36955: LIST
36956: LIST
36957: LIST
36958: LIST
36959: LIST
36960: LIST
36961: LIST
36962: LIST
36963: LIST
36964: LIST
36965: LIST
36966: LIST
36967: LIST
36968: LIST
36969: LIST
36970: LIST
36971: LIST
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36979: LD_ADDR_VAR 0 45
36983: PUSH
36984: LD_INT 0
36986: PUSH
36987: LD_INT 0
36989: PUSH
36990: EMPTY
36991: LIST
36992: LIST
36993: PUSH
36994: LD_INT 0
36996: PUSH
36997: LD_INT 1
36999: NEG
37000: PUSH
37001: EMPTY
37002: LIST
37003: LIST
37004: PUSH
37005: LD_INT 1
37007: PUSH
37008: LD_INT 0
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PUSH
37015: LD_INT 1
37017: PUSH
37018: LD_INT 1
37020: PUSH
37021: EMPTY
37022: LIST
37023: LIST
37024: PUSH
37025: LD_INT 0
37027: PUSH
37028: LD_INT 1
37030: PUSH
37031: EMPTY
37032: LIST
37033: LIST
37034: PUSH
37035: LD_INT 1
37037: NEG
37038: PUSH
37039: LD_INT 0
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: LD_INT 1
37048: NEG
37049: PUSH
37050: LD_INT 1
37052: NEG
37053: PUSH
37054: EMPTY
37055: LIST
37056: LIST
37057: PUSH
37058: LD_INT 1
37060: NEG
37061: PUSH
37062: LD_INT 2
37064: NEG
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 0
37072: PUSH
37073: LD_INT 2
37075: NEG
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 1
37083: PUSH
37084: LD_INT 1
37086: NEG
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 2
37094: PUSH
37095: LD_INT 1
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 2
37104: PUSH
37105: LD_INT 2
37107: PUSH
37108: EMPTY
37109: LIST
37110: LIST
37111: PUSH
37112: LD_INT 1
37114: PUSH
37115: LD_INT 2
37117: PUSH
37118: EMPTY
37119: LIST
37120: LIST
37121: PUSH
37122: LD_INT 0
37124: PUSH
37125: LD_INT 2
37127: PUSH
37128: EMPTY
37129: LIST
37130: LIST
37131: PUSH
37132: LD_INT 1
37134: NEG
37135: PUSH
37136: LD_INT 1
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: LD_INT 2
37145: NEG
37146: PUSH
37147: LD_INT 1
37149: NEG
37150: PUSH
37151: EMPTY
37152: LIST
37153: LIST
37154: PUSH
37155: LD_INT 2
37157: NEG
37158: PUSH
37159: LD_INT 2
37161: NEG
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: PUSH
37167: LD_INT 2
37169: NEG
37170: PUSH
37171: LD_INT 3
37173: NEG
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PUSH
37179: LD_INT 1
37181: NEG
37182: PUSH
37183: LD_INT 3
37185: NEG
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 0
37193: PUSH
37194: LD_INT 3
37196: NEG
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 1
37204: PUSH
37205: LD_INT 2
37207: NEG
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: LD_INT 3
37215: PUSH
37216: LD_INT 2
37218: PUSH
37219: EMPTY
37220: LIST
37221: LIST
37222: PUSH
37223: LD_INT 3
37225: PUSH
37226: LD_INT 3
37228: PUSH
37229: EMPTY
37230: LIST
37231: LIST
37232: PUSH
37233: LD_INT 2
37235: PUSH
37236: LD_INT 3
37238: PUSH
37239: EMPTY
37240: LIST
37241: LIST
37242: PUSH
37243: LD_INT 1
37245: PUSH
37246: LD_INT 3
37248: PUSH
37249: EMPTY
37250: LIST
37251: LIST
37252: PUSH
37253: LD_INT 0
37255: PUSH
37256: LD_INT 3
37258: PUSH
37259: EMPTY
37260: LIST
37261: LIST
37262: PUSH
37263: LD_INT 1
37265: NEG
37266: PUSH
37267: LD_INT 2
37269: PUSH
37270: EMPTY
37271: LIST
37272: LIST
37273: PUSH
37274: LD_INT 3
37276: NEG
37277: PUSH
37278: LD_INT 2
37280: NEG
37281: PUSH
37282: EMPTY
37283: LIST
37284: LIST
37285: PUSH
37286: LD_INT 3
37288: NEG
37289: PUSH
37290: LD_INT 3
37292: NEG
37293: PUSH
37294: EMPTY
37295: LIST
37296: LIST
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: LIST
37302: LIST
37303: LIST
37304: LIST
37305: LIST
37306: LIST
37307: LIST
37308: LIST
37309: LIST
37310: LIST
37311: LIST
37312: LIST
37313: LIST
37314: LIST
37315: LIST
37316: LIST
37317: LIST
37318: LIST
37319: LIST
37320: LIST
37321: LIST
37322: LIST
37323: LIST
37324: LIST
37325: LIST
37326: LIST
37327: LIST
37328: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37329: LD_ADDR_VAR 0 46
37333: PUSH
37334: LD_INT 0
37336: PUSH
37337: LD_INT 0
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PUSH
37344: LD_INT 0
37346: PUSH
37347: LD_INT 1
37349: NEG
37350: PUSH
37351: EMPTY
37352: LIST
37353: LIST
37354: PUSH
37355: LD_INT 1
37357: PUSH
37358: LD_INT 0
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: PUSH
37365: LD_INT 1
37367: PUSH
37368: LD_INT 1
37370: PUSH
37371: EMPTY
37372: LIST
37373: LIST
37374: PUSH
37375: LD_INT 0
37377: PUSH
37378: LD_INT 1
37380: PUSH
37381: EMPTY
37382: LIST
37383: LIST
37384: PUSH
37385: LD_INT 1
37387: NEG
37388: PUSH
37389: LD_INT 0
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 1
37398: NEG
37399: PUSH
37400: LD_INT 1
37402: NEG
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PUSH
37408: LD_INT 1
37410: NEG
37411: PUSH
37412: LD_INT 2
37414: NEG
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PUSH
37420: LD_INT 0
37422: PUSH
37423: LD_INT 2
37425: NEG
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: PUSH
37431: LD_INT 1
37433: PUSH
37434: LD_INT 1
37436: NEG
37437: PUSH
37438: EMPTY
37439: LIST
37440: LIST
37441: PUSH
37442: LD_INT 2
37444: PUSH
37445: LD_INT 0
37447: PUSH
37448: EMPTY
37449: LIST
37450: LIST
37451: PUSH
37452: LD_INT 2
37454: PUSH
37455: LD_INT 1
37457: PUSH
37458: EMPTY
37459: LIST
37460: LIST
37461: PUSH
37462: LD_INT 1
37464: PUSH
37465: LD_INT 2
37467: PUSH
37468: EMPTY
37469: LIST
37470: LIST
37471: PUSH
37472: LD_INT 0
37474: PUSH
37475: LD_INT 2
37477: PUSH
37478: EMPTY
37479: LIST
37480: LIST
37481: PUSH
37482: LD_INT 1
37484: NEG
37485: PUSH
37486: LD_INT 1
37488: PUSH
37489: EMPTY
37490: LIST
37491: LIST
37492: PUSH
37493: LD_INT 2
37495: NEG
37496: PUSH
37497: LD_INT 0
37499: PUSH
37500: EMPTY
37501: LIST
37502: LIST
37503: PUSH
37504: LD_INT 2
37506: NEG
37507: PUSH
37508: LD_INT 1
37510: NEG
37511: PUSH
37512: EMPTY
37513: LIST
37514: LIST
37515: PUSH
37516: LD_INT 1
37518: NEG
37519: PUSH
37520: LD_INT 3
37522: NEG
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: LD_INT 0
37530: PUSH
37531: LD_INT 3
37533: NEG
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: PUSH
37539: LD_INT 1
37541: PUSH
37542: LD_INT 2
37544: NEG
37545: PUSH
37546: EMPTY
37547: LIST
37548: LIST
37549: PUSH
37550: LD_INT 2
37552: PUSH
37553: LD_INT 1
37555: NEG
37556: PUSH
37557: EMPTY
37558: LIST
37559: LIST
37560: PUSH
37561: LD_INT 3
37563: PUSH
37564: LD_INT 0
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: PUSH
37571: LD_INT 3
37573: PUSH
37574: LD_INT 1
37576: PUSH
37577: EMPTY
37578: LIST
37579: LIST
37580: PUSH
37581: LD_INT 1
37583: PUSH
37584: LD_INT 3
37586: PUSH
37587: EMPTY
37588: LIST
37589: LIST
37590: PUSH
37591: LD_INT 0
37593: PUSH
37594: LD_INT 3
37596: PUSH
37597: EMPTY
37598: LIST
37599: LIST
37600: PUSH
37601: LD_INT 1
37603: NEG
37604: PUSH
37605: LD_INT 2
37607: PUSH
37608: EMPTY
37609: LIST
37610: LIST
37611: PUSH
37612: LD_INT 2
37614: NEG
37615: PUSH
37616: LD_INT 1
37618: PUSH
37619: EMPTY
37620: LIST
37621: LIST
37622: PUSH
37623: LD_INT 3
37625: NEG
37626: PUSH
37627: LD_INT 0
37629: PUSH
37630: EMPTY
37631: LIST
37632: LIST
37633: PUSH
37634: LD_INT 3
37636: NEG
37637: PUSH
37638: LD_INT 1
37640: NEG
37641: PUSH
37642: EMPTY
37643: LIST
37644: LIST
37645: PUSH
37646: EMPTY
37647: LIST
37648: LIST
37649: LIST
37650: LIST
37651: LIST
37652: LIST
37653: LIST
37654: LIST
37655: LIST
37656: LIST
37657: LIST
37658: LIST
37659: LIST
37660: LIST
37661: LIST
37662: LIST
37663: LIST
37664: LIST
37665: LIST
37666: LIST
37667: LIST
37668: LIST
37669: LIST
37670: LIST
37671: LIST
37672: LIST
37673: LIST
37674: LIST
37675: LIST
37676: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37677: LD_ADDR_VAR 0 47
37681: PUSH
37682: LD_INT 0
37684: PUSH
37685: LD_INT 0
37687: PUSH
37688: EMPTY
37689: LIST
37690: LIST
37691: PUSH
37692: LD_INT 0
37694: PUSH
37695: LD_INT 1
37697: NEG
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 1
37705: PUSH
37706: LD_INT 0
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: LD_INT 1
37715: PUSH
37716: LD_INT 1
37718: PUSH
37719: EMPTY
37720: LIST
37721: LIST
37722: PUSH
37723: LD_INT 0
37725: PUSH
37726: LD_INT 1
37728: PUSH
37729: EMPTY
37730: LIST
37731: LIST
37732: PUSH
37733: LD_INT 1
37735: NEG
37736: PUSH
37737: LD_INT 0
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 1
37746: NEG
37747: PUSH
37748: LD_INT 1
37750: NEG
37751: PUSH
37752: EMPTY
37753: LIST
37754: LIST
37755: PUSH
37756: LD_INT 1
37758: NEG
37759: PUSH
37760: LD_INT 2
37762: NEG
37763: PUSH
37764: EMPTY
37765: LIST
37766: LIST
37767: PUSH
37768: LD_INT 0
37770: PUSH
37771: LD_INT 2
37773: NEG
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: LD_INT 1
37781: PUSH
37782: LD_INT 1
37784: NEG
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: LD_INT 2
37792: NEG
37793: PUSH
37794: LD_INT 1
37796: NEG
37797: PUSH
37798: EMPTY
37799: LIST
37800: LIST
37801: PUSH
37802: LD_INT 2
37804: NEG
37805: PUSH
37806: LD_INT 2
37808: NEG
37809: PUSH
37810: EMPTY
37811: LIST
37812: LIST
37813: PUSH
37814: EMPTY
37815: LIST
37816: LIST
37817: LIST
37818: LIST
37819: LIST
37820: LIST
37821: LIST
37822: LIST
37823: LIST
37824: LIST
37825: LIST
37826: LIST
37827: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37828: LD_ADDR_VAR 0 48
37832: PUSH
37833: LD_INT 0
37835: PUSH
37836: LD_INT 0
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 0
37845: PUSH
37846: LD_INT 1
37848: NEG
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 1
37856: PUSH
37857: LD_INT 0
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: LD_INT 1
37866: PUSH
37867: LD_INT 1
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 0
37876: PUSH
37877: LD_INT 1
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 1
37886: NEG
37887: PUSH
37888: LD_INT 0
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: PUSH
37895: LD_INT 1
37897: NEG
37898: PUSH
37899: LD_INT 1
37901: NEG
37902: PUSH
37903: EMPTY
37904: LIST
37905: LIST
37906: PUSH
37907: LD_INT 1
37909: NEG
37910: PUSH
37911: LD_INT 2
37913: NEG
37914: PUSH
37915: EMPTY
37916: LIST
37917: LIST
37918: PUSH
37919: LD_INT 0
37921: PUSH
37922: LD_INT 2
37924: NEG
37925: PUSH
37926: EMPTY
37927: LIST
37928: LIST
37929: PUSH
37930: LD_INT 1
37932: PUSH
37933: LD_INT 1
37935: NEG
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 2
37943: PUSH
37944: LD_INT 0
37946: PUSH
37947: EMPTY
37948: LIST
37949: LIST
37950: PUSH
37951: LD_INT 2
37953: PUSH
37954: LD_INT 1
37956: PUSH
37957: EMPTY
37958: LIST
37959: LIST
37960: PUSH
37961: EMPTY
37962: LIST
37963: LIST
37964: LIST
37965: LIST
37966: LIST
37967: LIST
37968: LIST
37969: LIST
37970: LIST
37971: LIST
37972: LIST
37973: LIST
37974: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37975: LD_ADDR_VAR 0 49
37979: PUSH
37980: LD_INT 0
37982: PUSH
37983: LD_INT 0
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: LD_INT 0
37992: PUSH
37993: LD_INT 1
37995: NEG
37996: PUSH
37997: EMPTY
37998: LIST
37999: LIST
38000: PUSH
38001: LD_INT 1
38003: PUSH
38004: LD_INT 0
38006: PUSH
38007: EMPTY
38008: LIST
38009: LIST
38010: PUSH
38011: LD_INT 1
38013: PUSH
38014: LD_INT 1
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: PUSH
38021: LD_INT 0
38023: PUSH
38024: LD_INT 1
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: LD_INT 1
38033: NEG
38034: PUSH
38035: LD_INT 0
38037: PUSH
38038: EMPTY
38039: LIST
38040: LIST
38041: PUSH
38042: LD_INT 1
38044: NEG
38045: PUSH
38046: LD_INT 1
38048: NEG
38049: PUSH
38050: EMPTY
38051: LIST
38052: LIST
38053: PUSH
38054: LD_INT 1
38056: PUSH
38057: LD_INT 1
38059: NEG
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: LD_INT 2
38067: PUSH
38068: LD_INT 0
38070: PUSH
38071: EMPTY
38072: LIST
38073: LIST
38074: PUSH
38075: LD_INT 2
38077: PUSH
38078: LD_INT 1
38080: PUSH
38081: EMPTY
38082: LIST
38083: LIST
38084: PUSH
38085: LD_INT 2
38087: PUSH
38088: LD_INT 2
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 1
38097: PUSH
38098: LD_INT 2
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PUSH
38105: EMPTY
38106: LIST
38107: LIST
38108: LIST
38109: LIST
38110: LIST
38111: LIST
38112: LIST
38113: LIST
38114: LIST
38115: LIST
38116: LIST
38117: LIST
38118: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38119: LD_ADDR_VAR 0 50
38123: PUSH
38124: LD_INT 0
38126: PUSH
38127: LD_INT 0
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: LD_INT 0
38136: PUSH
38137: LD_INT 1
38139: NEG
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: PUSH
38145: LD_INT 1
38147: PUSH
38148: LD_INT 0
38150: PUSH
38151: EMPTY
38152: LIST
38153: LIST
38154: PUSH
38155: LD_INT 1
38157: PUSH
38158: LD_INT 1
38160: PUSH
38161: EMPTY
38162: LIST
38163: LIST
38164: PUSH
38165: LD_INT 0
38167: PUSH
38168: LD_INT 1
38170: PUSH
38171: EMPTY
38172: LIST
38173: LIST
38174: PUSH
38175: LD_INT 1
38177: NEG
38178: PUSH
38179: LD_INT 0
38181: PUSH
38182: EMPTY
38183: LIST
38184: LIST
38185: PUSH
38186: LD_INT 1
38188: NEG
38189: PUSH
38190: LD_INT 1
38192: NEG
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: LD_INT 2
38200: PUSH
38201: LD_INT 1
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: PUSH
38208: LD_INT 2
38210: PUSH
38211: LD_INT 2
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 1
38220: PUSH
38221: LD_INT 2
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: PUSH
38228: LD_INT 0
38230: PUSH
38231: LD_INT 2
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: PUSH
38238: LD_INT 1
38240: NEG
38241: PUSH
38242: LD_INT 1
38244: PUSH
38245: EMPTY
38246: LIST
38247: LIST
38248: PUSH
38249: EMPTY
38250: LIST
38251: LIST
38252: LIST
38253: LIST
38254: LIST
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: LIST
38261: LIST
38262: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38263: LD_ADDR_VAR 0 51
38267: PUSH
38268: LD_INT 0
38270: PUSH
38271: LD_INT 0
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 0
38280: PUSH
38281: LD_INT 1
38283: NEG
38284: PUSH
38285: EMPTY
38286: LIST
38287: LIST
38288: PUSH
38289: LD_INT 1
38291: PUSH
38292: LD_INT 0
38294: PUSH
38295: EMPTY
38296: LIST
38297: LIST
38298: PUSH
38299: LD_INT 1
38301: PUSH
38302: LD_INT 1
38304: PUSH
38305: EMPTY
38306: LIST
38307: LIST
38308: PUSH
38309: LD_INT 0
38311: PUSH
38312: LD_INT 1
38314: PUSH
38315: EMPTY
38316: LIST
38317: LIST
38318: PUSH
38319: LD_INT 1
38321: NEG
38322: PUSH
38323: LD_INT 0
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: LD_INT 1
38332: NEG
38333: PUSH
38334: LD_INT 1
38336: NEG
38337: PUSH
38338: EMPTY
38339: LIST
38340: LIST
38341: PUSH
38342: LD_INT 1
38344: PUSH
38345: LD_INT 2
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: PUSH
38352: LD_INT 0
38354: PUSH
38355: LD_INT 2
38357: PUSH
38358: EMPTY
38359: LIST
38360: LIST
38361: PUSH
38362: LD_INT 1
38364: NEG
38365: PUSH
38366: LD_INT 1
38368: PUSH
38369: EMPTY
38370: LIST
38371: LIST
38372: PUSH
38373: LD_INT 2
38375: NEG
38376: PUSH
38377: LD_INT 0
38379: PUSH
38380: EMPTY
38381: LIST
38382: LIST
38383: PUSH
38384: LD_INT 2
38386: NEG
38387: PUSH
38388: LD_INT 1
38390: NEG
38391: PUSH
38392: EMPTY
38393: LIST
38394: LIST
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: LIST
38408: LIST
38409: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38410: LD_ADDR_VAR 0 52
38414: PUSH
38415: LD_INT 0
38417: PUSH
38418: LD_INT 0
38420: PUSH
38421: EMPTY
38422: LIST
38423: LIST
38424: PUSH
38425: LD_INT 0
38427: PUSH
38428: LD_INT 1
38430: NEG
38431: PUSH
38432: EMPTY
38433: LIST
38434: LIST
38435: PUSH
38436: LD_INT 1
38438: PUSH
38439: LD_INT 0
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: PUSH
38446: LD_INT 1
38448: PUSH
38449: LD_INT 1
38451: PUSH
38452: EMPTY
38453: LIST
38454: LIST
38455: PUSH
38456: LD_INT 0
38458: PUSH
38459: LD_INT 1
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: PUSH
38466: LD_INT 1
38468: NEG
38469: PUSH
38470: LD_INT 0
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 1
38479: NEG
38480: PUSH
38481: LD_INT 1
38483: NEG
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: LD_INT 1
38491: NEG
38492: PUSH
38493: LD_INT 2
38495: NEG
38496: PUSH
38497: EMPTY
38498: LIST
38499: LIST
38500: PUSH
38501: LD_INT 1
38503: NEG
38504: PUSH
38505: LD_INT 1
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 2
38514: NEG
38515: PUSH
38516: LD_INT 0
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: PUSH
38523: LD_INT 2
38525: NEG
38526: PUSH
38527: LD_INT 1
38529: NEG
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: PUSH
38535: LD_INT 2
38537: NEG
38538: PUSH
38539: LD_INT 2
38541: NEG
38542: PUSH
38543: EMPTY
38544: LIST
38545: LIST
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: LIST
38551: LIST
38552: LIST
38553: LIST
38554: LIST
38555: LIST
38556: LIST
38557: LIST
38558: LIST
38559: LIST
38560: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38561: LD_ADDR_VAR 0 53
38565: PUSH
38566: LD_INT 0
38568: PUSH
38569: LD_INT 0
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 0
38578: PUSH
38579: LD_INT 1
38581: NEG
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PUSH
38587: LD_INT 1
38589: PUSH
38590: LD_INT 0
38592: PUSH
38593: EMPTY
38594: LIST
38595: LIST
38596: PUSH
38597: LD_INT 1
38599: PUSH
38600: LD_INT 1
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 0
38609: PUSH
38610: LD_INT 1
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 1
38619: NEG
38620: PUSH
38621: LD_INT 0
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PUSH
38628: LD_INT 1
38630: NEG
38631: PUSH
38632: LD_INT 1
38634: NEG
38635: PUSH
38636: EMPTY
38637: LIST
38638: LIST
38639: PUSH
38640: LD_INT 1
38642: NEG
38643: PUSH
38644: LD_INT 2
38646: NEG
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: PUSH
38652: LD_INT 0
38654: PUSH
38655: LD_INT 2
38657: NEG
38658: PUSH
38659: EMPTY
38660: LIST
38661: LIST
38662: PUSH
38663: LD_INT 1
38665: PUSH
38666: LD_INT 1
38668: NEG
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: PUSH
38674: LD_INT 2
38676: PUSH
38677: LD_INT 0
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: PUSH
38684: LD_INT 2
38686: PUSH
38687: LD_INT 1
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: PUSH
38694: LD_INT 2
38696: PUSH
38697: LD_INT 2
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: LD_INT 1
38706: PUSH
38707: LD_INT 2
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 0
38716: PUSH
38717: LD_INT 2
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: LD_INT 1
38726: NEG
38727: PUSH
38728: LD_INT 1
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PUSH
38735: LD_INT 2
38737: NEG
38738: PUSH
38739: LD_INT 0
38741: PUSH
38742: EMPTY
38743: LIST
38744: LIST
38745: PUSH
38746: LD_INT 2
38748: NEG
38749: PUSH
38750: LD_INT 1
38752: NEG
38753: PUSH
38754: EMPTY
38755: LIST
38756: LIST
38757: PUSH
38758: LD_INT 2
38760: NEG
38761: PUSH
38762: LD_INT 2
38764: NEG
38765: PUSH
38766: EMPTY
38767: LIST
38768: LIST
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: LIST
38774: LIST
38775: LIST
38776: LIST
38777: LIST
38778: LIST
38779: LIST
38780: LIST
38781: LIST
38782: LIST
38783: LIST
38784: LIST
38785: LIST
38786: LIST
38787: LIST
38788: LIST
38789: LIST
38790: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38791: LD_ADDR_VAR 0 54
38795: PUSH
38796: LD_INT 0
38798: PUSH
38799: LD_INT 0
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PUSH
38806: LD_INT 0
38808: PUSH
38809: LD_INT 1
38811: NEG
38812: PUSH
38813: EMPTY
38814: LIST
38815: LIST
38816: PUSH
38817: LD_INT 1
38819: PUSH
38820: LD_INT 0
38822: PUSH
38823: EMPTY
38824: LIST
38825: LIST
38826: PUSH
38827: LD_INT 1
38829: PUSH
38830: LD_INT 1
38832: PUSH
38833: EMPTY
38834: LIST
38835: LIST
38836: PUSH
38837: LD_INT 0
38839: PUSH
38840: LD_INT 1
38842: PUSH
38843: EMPTY
38844: LIST
38845: LIST
38846: PUSH
38847: LD_INT 1
38849: NEG
38850: PUSH
38851: LD_INT 0
38853: PUSH
38854: EMPTY
38855: LIST
38856: LIST
38857: PUSH
38858: LD_INT 1
38860: NEG
38861: PUSH
38862: LD_INT 1
38864: NEG
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: LD_INT 1
38872: NEG
38873: PUSH
38874: LD_INT 2
38876: NEG
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: LD_INT 0
38884: PUSH
38885: LD_INT 2
38887: NEG
38888: PUSH
38889: EMPTY
38890: LIST
38891: LIST
38892: PUSH
38893: LD_INT 1
38895: PUSH
38896: LD_INT 1
38898: NEG
38899: PUSH
38900: EMPTY
38901: LIST
38902: LIST
38903: PUSH
38904: LD_INT 2
38906: PUSH
38907: LD_INT 0
38909: PUSH
38910: EMPTY
38911: LIST
38912: LIST
38913: PUSH
38914: LD_INT 2
38916: PUSH
38917: LD_INT 1
38919: PUSH
38920: EMPTY
38921: LIST
38922: LIST
38923: PUSH
38924: LD_INT 2
38926: PUSH
38927: LD_INT 2
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 1
38936: PUSH
38937: LD_INT 2
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: LD_INT 0
38946: PUSH
38947: LD_INT 2
38949: PUSH
38950: EMPTY
38951: LIST
38952: LIST
38953: PUSH
38954: LD_INT 1
38956: NEG
38957: PUSH
38958: LD_INT 1
38960: PUSH
38961: EMPTY
38962: LIST
38963: LIST
38964: PUSH
38965: LD_INT 2
38967: NEG
38968: PUSH
38969: LD_INT 0
38971: PUSH
38972: EMPTY
38973: LIST
38974: LIST
38975: PUSH
38976: LD_INT 2
38978: NEG
38979: PUSH
38980: LD_INT 1
38982: NEG
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 2
38990: NEG
38991: PUSH
38992: LD_INT 2
38994: NEG
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: LIST
39004: LIST
39005: LIST
39006: LIST
39007: LIST
39008: LIST
39009: LIST
39010: LIST
39011: LIST
39012: LIST
39013: LIST
39014: LIST
39015: LIST
39016: LIST
39017: LIST
39018: LIST
39019: LIST
39020: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39021: LD_ADDR_VAR 0 55
39025: PUSH
39026: LD_INT 0
39028: PUSH
39029: LD_INT 0
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: LD_INT 0
39038: PUSH
39039: LD_INT 1
39041: NEG
39042: PUSH
39043: EMPTY
39044: LIST
39045: LIST
39046: PUSH
39047: LD_INT 1
39049: PUSH
39050: LD_INT 0
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: PUSH
39057: LD_INT 1
39059: PUSH
39060: LD_INT 1
39062: PUSH
39063: EMPTY
39064: LIST
39065: LIST
39066: PUSH
39067: LD_INT 0
39069: PUSH
39070: LD_INT 1
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PUSH
39077: LD_INT 1
39079: NEG
39080: PUSH
39081: LD_INT 0
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: LD_INT 1
39090: NEG
39091: PUSH
39092: LD_INT 1
39094: NEG
39095: PUSH
39096: EMPTY
39097: LIST
39098: LIST
39099: PUSH
39100: LD_INT 1
39102: NEG
39103: PUSH
39104: LD_INT 2
39106: NEG
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 0
39114: PUSH
39115: LD_INT 2
39117: NEG
39118: PUSH
39119: EMPTY
39120: LIST
39121: LIST
39122: PUSH
39123: LD_INT 1
39125: PUSH
39126: LD_INT 1
39128: NEG
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 2
39136: PUSH
39137: LD_INT 0
39139: PUSH
39140: EMPTY
39141: LIST
39142: LIST
39143: PUSH
39144: LD_INT 2
39146: PUSH
39147: LD_INT 1
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: LD_INT 2
39156: PUSH
39157: LD_INT 2
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 1
39166: PUSH
39167: LD_INT 2
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 0
39176: PUSH
39177: LD_INT 2
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: PUSH
39184: LD_INT 1
39186: NEG
39187: PUSH
39188: LD_INT 1
39190: PUSH
39191: EMPTY
39192: LIST
39193: LIST
39194: PUSH
39195: LD_INT 2
39197: NEG
39198: PUSH
39199: LD_INT 0
39201: PUSH
39202: EMPTY
39203: LIST
39204: LIST
39205: PUSH
39206: LD_INT 2
39208: NEG
39209: PUSH
39210: LD_INT 1
39212: NEG
39213: PUSH
39214: EMPTY
39215: LIST
39216: LIST
39217: PUSH
39218: LD_INT 2
39220: NEG
39221: PUSH
39222: LD_INT 2
39224: NEG
39225: PUSH
39226: EMPTY
39227: LIST
39228: LIST
39229: PUSH
39230: EMPTY
39231: LIST
39232: LIST
39233: LIST
39234: LIST
39235: LIST
39236: LIST
39237: LIST
39238: LIST
39239: LIST
39240: LIST
39241: LIST
39242: LIST
39243: LIST
39244: LIST
39245: LIST
39246: LIST
39247: LIST
39248: LIST
39249: LIST
39250: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39251: LD_ADDR_VAR 0 56
39255: PUSH
39256: LD_INT 0
39258: PUSH
39259: LD_INT 0
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: PUSH
39266: LD_INT 0
39268: PUSH
39269: LD_INT 1
39271: NEG
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: LD_INT 1
39279: PUSH
39280: LD_INT 0
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PUSH
39287: LD_INT 1
39289: PUSH
39290: LD_INT 1
39292: PUSH
39293: EMPTY
39294: LIST
39295: LIST
39296: PUSH
39297: LD_INT 0
39299: PUSH
39300: LD_INT 1
39302: PUSH
39303: EMPTY
39304: LIST
39305: LIST
39306: PUSH
39307: LD_INT 1
39309: NEG
39310: PUSH
39311: LD_INT 0
39313: PUSH
39314: EMPTY
39315: LIST
39316: LIST
39317: PUSH
39318: LD_INT 1
39320: NEG
39321: PUSH
39322: LD_INT 1
39324: NEG
39325: PUSH
39326: EMPTY
39327: LIST
39328: LIST
39329: PUSH
39330: LD_INT 1
39332: NEG
39333: PUSH
39334: LD_INT 2
39336: NEG
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: PUSH
39342: LD_INT 0
39344: PUSH
39345: LD_INT 2
39347: NEG
39348: PUSH
39349: EMPTY
39350: LIST
39351: LIST
39352: PUSH
39353: LD_INT 1
39355: PUSH
39356: LD_INT 1
39358: NEG
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: LD_INT 2
39366: PUSH
39367: LD_INT 0
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: PUSH
39374: LD_INT 2
39376: PUSH
39377: LD_INT 1
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 2
39386: PUSH
39387: LD_INT 2
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 1
39396: PUSH
39397: LD_INT 2
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: LD_INT 0
39406: PUSH
39407: LD_INT 2
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: LD_INT 1
39416: NEG
39417: PUSH
39418: LD_INT 1
39420: PUSH
39421: EMPTY
39422: LIST
39423: LIST
39424: PUSH
39425: LD_INT 2
39427: NEG
39428: PUSH
39429: LD_INT 0
39431: PUSH
39432: EMPTY
39433: LIST
39434: LIST
39435: PUSH
39436: LD_INT 2
39438: NEG
39439: PUSH
39440: LD_INT 1
39442: NEG
39443: PUSH
39444: EMPTY
39445: LIST
39446: LIST
39447: PUSH
39448: LD_INT 2
39450: NEG
39451: PUSH
39452: LD_INT 2
39454: NEG
39455: PUSH
39456: EMPTY
39457: LIST
39458: LIST
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: LIST
39464: LIST
39465: LIST
39466: LIST
39467: LIST
39468: LIST
39469: LIST
39470: LIST
39471: LIST
39472: LIST
39473: LIST
39474: LIST
39475: LIST
39476: LIST
39477: LIST
39478: LIST
39479: LIST
39480: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39481: LD_ADDR_VAR 0 57
39485: PUSH
39486: LD_INT 0
39488: PUSH
39489: LD_INT 0
39491: PUSH
39492: EMPTY
39493: LIST
39494: LIST
39495: PUSH
39496: LD_INT 0
39498: PUSH
39499: LD_INT 1
39501: NEG
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: LD_INT 1
39509: PUSH
39510: LD_INT 0
39512: PUSH
39513: EMPTY
39514: LIST
39515: LIST
39516: PUSH
39517: LD_INT 1
39519: PUSH
39520: LD_INT 1
39522: PUSH
39523: EMPTY
39524: LIST
39525: LIST
39526: PUSH
39527: LD_INT 0
39529: PUSH
39530: LD_INT 1
39532: PUSH
39533: EMPTY
39534: LIST
39535: LIST
39536: PUSH
39537: LD_INT 1
39539: NEG
39540: PUSH
39541: LD_INT 0
39543: PUSH
39544: EMPTY
39545: LIST
39546: LIST
39547: PUSH
39548: LD_INT 1
39550: NEG
39551: PUSH
39552: LD_INT 1
39554: NEG
39555: PUSH
39556: EMPTY
39557: LIST
39558: LIST
39559: PUSH
39560: LD_INT 1
39562: NEG
39563: PUSH
39564: LD_INT 2
39566: NEG
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: PUSH
39572: LD_INT 0
39574: PUSH
39575: LD_INT 2
39577: NEG
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: PUSH
39583: LD_INT 1
39585: PUSH
39586: LD_INT 1
39588: NEG
39589: PUSH
39590: EMPTY
39591: LIST
39592: LIST
39593: PUSH
39594: LD_INT 2
39596: PUSH
39597: LD_INT 0
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: LD_INT 2
39606: PUSH
39607: LD_INT 1
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: LD_INT 2
39616: PUSH
39617: LD_INT 2
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: LD_INT 1
39626: PUSH
39627: LD_INT 2
39629: PUSH
39630: EMPTY
39631: LIST
39632: LIST
39633: PUSH
39634: LD_INT 0
39636: PUSH
39637: LD_INT 2
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: PUSH
39644: LD_INT 1
39646: NEG
39647: PUSH
39648: LD_INT 1
39650: PUSH
39651: EMPTY
39652: LIST
39653: LIST
39654: PUSH
39655: LD_INT 2
39657: NEG
39658: PUSH
39659: LD_INT 0
39661: PUSH
39662: EMPTY
39663: LIST
39664: LIST
39665: PUSH
39666: LD_INT 2
39668: NEG
39669: PUSH
39670: LD_INT 1
39672: NEG
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: LD_INT 2
39680: NEG
39681: PUSH
39682: LD_INT 2
39684: NEG
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: EMPTY
39691: LIST
39692: LIST
39693: LIST
39694: LIST
39695: LIST
39696: LIST
39697: LIST
39698: LIST
39699: LIST
39700: LIST
39701: LIST
39702: LIST
39703: LIST
39704: LIST
39705: LIST
39706: LIST
39707: LIST
39708: LIST
39709: LIST
39710: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39711: LD_ADDR_VAR 0 58
39715: PUSH
39716: LD_INT 0
39718: PUSH
39719: LD_INT 0
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: PUSH
39726: LD_INT 0
39728: PUSH
39729: LD_INT 1
39731: NEG
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: PUSH
39737: LD_INT 1
39739: PUSH
39740: LD_INT 0
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 1
39749: PUSH
39750: LD_INT 1
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PUSH
39757: LD_INT 0
39759: PUSH
39760: LD_INT 1
39762: PUSH
39763: EMPTY
39764: LIST
39765: LIST
39766: PUSH
39767: LD_INT 1
39769: NEG
39770: PUSH
39771: LD_INT 0
39773: PUSH
39774: EMPTY
39775: LIST
39776: LIST
39777: PUSH
39778: LD_INT 1
39780: NEG
39781: PUSH
39782: LD_INT 1
39784: NEG
39785: PUSH
39786: EMPTY
39787: LIST
39788: LIST
39789: PUSH
39790: LD_INT 1
39792: NEG
39793: PUSH
39794: LD_INT 2
39796: NEG
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: PUSH
39802: LD_INT 0
39804: PUSH
39805: LD_INT 2
39807: NEG
39808: PUSH
39809: EMPTY
39810: LIST
39811: LIST
39812: PUSH
39813: LD_INT 1
39815: PUSH
39816: LD_INT 1
39818: NEG
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 2
39826: PUSH
39827: LD_INT 0
39829: PUSH
39830: EMPTY
39831: LIST
39832: LIST
39833: PUSH
39834: LD_INT 2
39836: PUSH
39837: LD_INT 1
39839: PUSH
39840: EMPTY
39841: LIST
39842: LIST
39843: PUSH
39844: LD_INT 2
39846: PUSH
39847: LD_INT 2
39849: PUSH
39850: EMPTY
39851: LIST
39852: LIST
39853: PUSH
39854: LD_INT 1
39856: PUSH
39857: LD_INT 2
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: PUSH
39864: LD_INT 0
39866: PUSH
39867: LD_INT 2
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: LD_INT 1
39876: NEG
39877: PUSH
39878: LD_INT 1
39880: PUSH
39881: EMPTY
39882: LIST
39883: LIST
39884: PUSH
39885: LD_INT 2
39887: NEG
39888: PUSH
39889: LD_INT 0
39891: PUSH
39892: EMPTY
39893: LIST
39894: LIST
39895: PUSH
39896: LD_INT 2
39898: NEG
39899: PUSH
39900: LD_INT 1
39902: NEG
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 2
39910: NEG
39911: PUSH
39912: LD_INT 2
39914: NEG
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: LIST
39924: LIST
39925: LIST
39926: LIST
39927: LIST
39928: LIST
39929: LIST
39930: LIST
39931: LIST
39932: LIST
39933: LIST
39934: LIST
39935: LIST
39936: LIST
39937: LIST
39938: LIST
39939: LIST
39940: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39941: LD_ADDR_VAR 0 59
39945: PUSH
39946: LD_INT 0
39948: PUSH
39949: LD_INT 0
39951: PUSH
39952: EMPTY
39953: LIST
39954: LIST
39955: PUSH
39956: LD_INT 0
39958: PUSH
39959: LD_INT 1
39961: NEG
39962: PUSH
39963: EMPTY
39964: LIST
39965: LIST
39966: PUSH
39967: LD_INT 1
39969: PUSH
39970: LD_INT 0
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PUSH
39977: LD_INT 1
39979: PUSH
39980: LD_INT 1
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: PUSH
39987: LD_INT 0
39989: PUSH
39990: LD_INT 1
39992: PUSH
39993: EMPTY
39994: LIST
39995: LIST
39996: PUSH
39997: LD_INT 1
39999: NEG
40000: PUSH
40001: LD_INT 0
40003: PUSH
40004: EMPTY
40005: LIST
40006: LIST
40007: PUSH
40008: LD_INT 1
40010: NEG
40011: PUSH
40012: LD_INT 1
40014: NEG
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: EMPTY
40021: LIST
40022: LIST
40023: LIST
40024: LIST
40025: LIST
40026: LIST
40027: LIST
40028: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40029: LD_ADDR_VAR 0 60
40033: PUSH
40034: LD_INT 0
40036: PUSH
40037: LD_INT 0
40039: PUSH
40040: EMPTY
40041: LIST
40042: LIST
40043: PUSH
40044: LD_INT 0
40046: PUSH
40047: LD_INT 1
40049: NEG
40050: PUSH
40051: EMPTY
40052: LIST
40053: LIST
40054: PUSH
40055: LD_INT 1
40057: PUSH
40058: LD_INT 0
40060: PUSH
40061: EMPTY
40062: LIST
40063: LIST
40064: PUSH
40065: LD_INT 1
40067: PUSH
40068: LD_INT 1
40070: PUSH
40071: EMPTY
40072: LIST
40073: LIST
40074: PUSH
40075: LD_INT 0
40077: PUSH
40078: LD_INT 1
40080: PUSH
40081: EMPTY
40082: LIST
40083: LIST
40084: PUSH
40085: LD_INT 1
40087: NEG
40088: PUSH
40089: LD_INT 0
40091: PUSH
40092: EMPTY
40093: LIST
40094: LIST
40095: PUSH
40096: LD_INT 1
40098: NEG
40099: PUSH
40100: LD_INT 1
40102: NEG
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: EMPTY
40109: LIST
40110: LIST
40111: LIST
40112: LIST
40113: LIST
40114: LIST
40115: LIST
40116: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40117: LD_ADDR_VAR 0 61
40121: PUSH
40122: LD_INT 0
40124: PUSH
40125: LD_INT 0
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: PUSH
40132: LD_INT 0
40134: PUSH
40135: LD_INT 1
40137: NEG
40138: PUSH
40139: EMPTY
40140: LIST
40141: LIST
40142: PUSH
40143: LD_INT 1
40145: PUSH
40146: LD_INT 0
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PUSH
40153: LD_INT 1
40155: PUSH
40156: LD_INT 1
40158: PUSH
40159: EMPTY
40160: LIST
40161: LIST
40162: PUSH
40163: LD_INT 0
40165: PUSH
40166: LD_INT 1
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: PUSH
40173: LD_INT 1
40175: NEG
40176: PUSH
40177: LD_INT 0
40179: PUSH
40180: EMPTY
40181: LIST
40182: LIST
40183: PUSH
40184: LD_INT 1
40186: NEG
40187: PUSH
40188: LD_INT 1
40190: NEG
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: EMPTY
40197: LIST
40198: LIST
40199: LIST
40200: LIST
40201: LIST
40202: LIST
40203: LIST
40204: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40205: LD_ADDR_VAR 0 62
40209: PUSH
40210: LD_INT 0
40212: PUSH
40213: LD_INT 0
40215: PUSH
40216: EMPTY
40217: LIST
40218: LIST
40219: PUSH
40220: LD_INT 0
40222: PUSH
40223: LD_INT 1
40225: NEG
40226: PUSH
40227: EMPTY
40228: LIST
40229: LIST
40230: PUSH
40231: LD_INT 1
40233: PUSH
40234: LD_INT 0
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 1
40243: PUSH
40244: LD_INT 1
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: LD_INT 0
40253: PUSH
40254: LD_INT 1
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 1
40263: NEG
40264: PUSH
40265: LD_INT 0
40267: PUSH
40268: EMPTY
40269: LIST
40270: LIST
40271: PUSH
40272: LD_INT 1
40274: NEG
40275: PUSH
40276: LD_INT 1
40278: NEG
40279: PUSH
40280: EMPTY
40281: LIST
40282: LIST
40283: PUSH
40284: EMPTY
40285: LIST
40286: LIST
40287: LIST
40288: LIST
40289: LIST
40290: LIST
40291: LIST
40292: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40293: LD_ADDR_VAR 0 63
40297: PUSH
40298: LD_INT 0
40300: PUSH
40301: LD_INT 0
40303: PUSH
40304: EMPTY
40305: LIST
40306: LIST
40307: PUSH
40308: LD_INT 0
40310: PUSH
40311: LD_INT 1
40313: NEG
40314: PUSH
40315: EMPTY
40316: LIST
40317: LIST
40318: PUSH
40319: LD_INT 1
40321: PUSH
40322: LD_INT 0
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PUSH
40329: LD_INT 1
40331: PUSH
40332: LD_INT 1
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: PUSH
40339: LD_INT 0
40341: PUSH
40342: LD_INT 1
40344: PUSH
40345: EMPTY
40346: LIST
40347: LIST
40348: PUSH
40349: LD_INT 1
40351: NEG
40352: PUSH
40353: LD_INT 0
40355: PUSH
40356: EMPTY
40357: LIST
40358: LIST
40359: PUSH
40360: LD_INT 1
40362: NEG
40363: PUSH
40364: LD_INT 1
40366: NEG
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: LIST
40376: LIST
40377: LIST
40378: LIST
40379: LIST
40380: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40381: LD_ADDR_VAR 0 64
40385: PUSH
40386: LD_INT 0
40388: PUSH
40389: LD_INT 0
40391: PUSH
40392: EMPTY
40393: LIST
40394: LIST
40395: PUSH
40396: LD_INT 0
40398: PUSH
40399: LD_INT 1
40401: NEG
40402: PUSH
40403: EMPTY
40404: LIST
40405: LIST
40406: PUSH
40407: LD_INT 1
40409: PUSH
40410: LD_INT 0
40412: PUSH
40413: EMPTY
40414: LIST
40415: LIST
40416: PUSH
40417: LD_INT 1
40419: PUSH
40420: LD_INT 1
40422: PUSH
40423: EMPTY
40424: LIST
40425: LIST
40426: PUSH
40427: LD_INT 0
40429: PUSH
40430: LD_INT 1
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: LD_INT 1
40439: NEG
40440: PUSH
40441: LD_INT 0
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 1
40450: NEG
40451: PUSH
40452: LD_INT 1
40454: NEG
40455: PUSH
40456: EMPTY
40457: LIST
40458: LIST
40459: PUSH
40460: EMPTY
40461: LIST
40462: LIST
40463: LIST
40464: LIST
40465: LIST
40466: LIST
40467: LIST
40468: ST_TO_ADDR
// end ; 1 :
40469: GO 46366
40471: LD_INT 1
40473: DOUBLE
40474: EQUAL
40475: IFTRUE 40479
40477: GO 43102
40479: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40480: LD_ADDR_VAR 0 11
40484: PUSH
40485: LD_INT 1
40487: NEG
40488: PUSH
40489: LD_INT 3
40491: NEG
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: PUSH
40497: LD_INT 0
40499: PUSH
40500: LD_INT 3
40502: NEG
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: PUSH
40508: LD_INT 1
40510: PUSH
40511: LD_INT 2
40513: NEG
40514: PUSH
40515: EMPTY
40516: LIST
40517: LIST
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: LIST
40523: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40524: LD_ADDR_VAR 0 12
40528: PUSH
40529: LD_INT 2
40531: PUSH
40532: LD_INT 1
40534: NEG
40535: PUSH
40536: EMPTY
40537: LIST
40538: LIST
40539: PUSH
40540: LD_INT 3
40542: PUSH
40543: LD_INT 0
40545: PUSH
40546: EMPTY
40547: LIST
40548: LIST
40549: PUSH
40550: LD_INT 3
40552: PUSH
40553: LD_INT 1
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: PUSH
40560: EMPTY
40561: LIST
40562: LIST
40563: LIST
40564: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40565: LD_ADDR_VAR 0 13
40569: PUSH
40570: LD_INT 3
40572: PUSH
40573: LD_INT 2
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: LD_INT 3
40582: PUSH
40583: LD_INT 3
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: LD_INT 2
40592: PUSH
40593: LD_INT 3
40595: PUSH
40596: EMPTY
40597: LIST
40598: LIST
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: LIST
40604: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40605: LD_ADDR_VAR 0 14
40609: PUSH
40610: LD_INT 1
40612: PUSH
40613: LD_INT 3
40615: PUSH
40616: EMPTY
40617: LIST
40618: LIST
40619: PUSH
40620: LD_INT 0
40622: PUSH
40623: LD_INT 3
40625: PUSH
40626: EMPTY
40627: LIST
40628: LIST
40629: PUSH
40630: LD_INT 1
40632: NEG
40633: PUSH
40634: LD_INT 2
40636: PUSH
40637: EMPTY
40638: LIST
40639: LIST
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: LIST
40645: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40646: LD_ADDR_VAR 0 15
40650: PUSH
40651: LD_INT 2
40653: NEG
40654: PUSH
40655: LD_INT 1
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: PUSH
40662: LD_INT 3
40664: NEG
40665: PUSH
40666: LD_INT 0
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: LD_INT 3
40675: NEG
40676: PUSH
40677: LD_INT 1
40679: NEG
40680: PUSH
40681: EMPTY
40682: LIST
40683: LIST
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: LIST
40689: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40690: LD_ADDR_VAR 0 16
40694: PUSH
40695: LD_INT 2
40697: NEG
40698: PUSH
40699: LD_INT 3
40701: NEG
40702: PUSH
40703: EMPTY
40704: LIST
40705: LIST
40706: PUSH
40707: LD_INT 3
40709: NEG
40710: PUSH
40711: LD_INT 2
40713: NEG
40714: PUSH
40715: EMPTY
40716: LIST
40717: LIST
40718: PUSH
40719: LD_INT 3
40721: NEG
40722: PUSH
40723: LD_INT 3
40725: NEG
40726: PUSH
40727: EMPTY
40728: LIST
40729: LIST
40730: PUSH
40731: EMPTY
40732: LIST
40733: LIST
40734: LIST
40735: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40736: LD_ADDR_VAR 0 17
40740: PUSH
40741: LD_INT 1
40743: NEG
40744: PUSH
40745: LD_INT 3
40747: NEG
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: PUSH
40753: LD_INT 0
40755: PUSH
40756: LD_INT 3
40758: NEG
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: PUSH
40764: LD_INT 1
40766: PUSH
40767: LD_INT 2
40769: NEG
40770: PUSH
40771: EMPTY
40772: LIST
40773: LIST
40774: PUSH
40775: EMPTY
40776: LIST
40777: LIST
40778: LIST
40779: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40780: LD_ADDR_VAR 0 18
40784: PUSH
40785: LD_INT 2
40787: PUSH
40788: LD_INT 1
40790: NEG
40791: PUSH
40792: EMPTY
40793: LIST
40794: LIST
40795: PUSH
40796: LD_INT 3
40798: PUSH
40799: LD_INT 0
40801: PUSH
40802: EMPTY
40803: LIST
40804: LIST
40805: PUSH
40806: LD_INT 3
40808: PUSH
40809: LD_INT 1
40811: PUSH
40812: EMPTY
40813: LIST
40814: LIST
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: LIST
40820: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40821: LD_ADDR_VAR 0 19
40825: PUSH
40826: LD_INT 3
40828: PUSH
40829: LD_INT 2
40831: PUSH
40832: EMPTY
40833: LIST
40834: LIST
40835: PUSH
40836: LD_INT 3
40838: PUSH
40839: LD_INT 3
40841: PUSH
40842: EMPTY
40843: LIST
40844: LIST
40845: PUSH
40846: LD_INT 2
40848: PUSH
40849: LD_INT 3
40851: PUSH
40852: EMPTY
40853: LIST
40854: LIST
40855: PUSH
40856: EMPTY
40857: LIST
40858: LIST
40859: LIST
40860: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40861: LD_ADDR_VAR 0 20
40865: PUSH
40866: LD_INT 1
40868: PUSH
40869: LD_INT 3
40871: PUSH
40872: EMPTY
40873: LIST
40874: LIST
40875: PUSH
40876: LD_INT 0
40878: PUSH
40879: LD_INT 3
40881: PUSH
40882: EMPTY
40883: LIST
40884: LIST
40885: PUSH
40886: LD_INT 1
40888: NEG
40889: PUSH
40890: LD_INT 2
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: PUSH
40897: EMPTY
40898: LIST
40899: LIST
40900: LIST
40901: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40902: LD_ADDR_VAR 0 21
40906: PUSH
40907: LD_INT 2
40909: NEG
40910: PUSH
40911: LD_INT 1
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: LD_INT 3
40920: NEG
40921: PUSH
40922: LD_INT 0
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: PUSH
40929: LD_INT 3
40931: NEG
40932: PUSH
40933: LD_INT 1
40935: NEG
40936: PUSH
40937: EMPTY
40938: LIST
40939: LIST
40940: PUSH
40941: EMPTY
40942: LIST
40943: LIST
40944: LIST
40945: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40946: LD_ADDR_VAR 0 22
40950: PUSH
40951: LD_INT 2
40953: NEG
40954: PUSH
40955: LD_INT 3
40957: NEG
40958: PUSH
40959: EMPTY
40960: LIST
40961: LIST
40962: PUSH
40963: LD_INT 3
40965: NEG
40966: PUSH
40967: LD_INT 2
40969: NEG
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: PUSH
40975: LD_INT 3
40977: NEG
40978: PUSH
40979: LD_INT 3
40981: NEG
40982: PUSH
40983: EMPTY
40984: LIST
40985: LIST
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: LIST
40991: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
40992: LD_ADDR_VAR 0 23
40996: PUSH
40997: LD_INT 0
40999: PUSH
41000: LD_INT 3
41002: NEG
41003: PUSH
41004: EMPTY
41005: LIST
41006: LIST
41007: PUSH
41008: LD_INT 1
41010: NEG
41011: PUSH
41012: LD_INT 4
41014: NEG
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: PUSH
41020: LD_INT 1
41022: PUSH
41023: LD_INT 3
41025: NEG
41026: PUSH
41027: EMPTY
41028: LIST
41029: LIST
41030: PUSH
41031: EMPTY
41032: LIST
41033: LIST
41034: LIST
41035: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41036: LD_ADDR_VAR 0 24
41040: PUSH
41041: LD_INT 3
41043: PUSH
41044: LD_INT 0
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: PUSH
41051: LD_INT 3
41053: PUSH
41054: LD_INT 1
41056: NEG
41057: PUSH
41058: EMPTY
41059: LIST
41060: LIST
41061: PUSH
41062: LD_INT 4
41064: PUSH
41065: LD_INT 1
41067: PUSH
41068: EMPTY
41069: LIST
41070: LIST
41071: PUSH
41072: EMPTY
41073: LIST
41074: LIST
41075: LIST
41076: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41077: LD_ADDR_VAR 0 25
41081: PUSH
41082: LD_INT 3
41084: PUSH
41085: LD_INT 3
41087: PUSH
41088: EMPTY
41089: LIST
41090: LIST
41091: PUSH
41092: LD_INT 4
41094: PUSH
41095: LD_INT 3
41097: PUSH
41098: EMPTY
41099: LIST
41100: LIST
41101: PUSH
41102: LD_INT 3
41104: PUSH
41105: LD_INT 4
41107: PUSH
41108: EMPTY
41109: LIST
41110: LIST
41111: PUSH
41112: EMPTY
41113: LIST
41114: LIST
41115: LIST
41116: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41117: LD_ADDR_VAR 0 26
41121: PUSH
41122: LD_INT 0
41124: PUSH
41125: LD_INT 3
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: LD_INT 1
41134: PUSH
41135: LD_INT 4
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 1
41144: NEG
41145: PUSH
41146: LD_INT 3
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: EMPTY
41154: LIST
41155: LIST
41156: LIST
41157: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41158: LD_ADDR_VAR 0 27
41162: PUSH
41163: LD_INT 3
41165: NEG
41166: PUSH
41167: LD_INT 0
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: LD_INT 3
41176: NEG
41177: PUSH
41178: LD_INT 1
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: LD_INT 4
41187: NEG
41188: PUSH
41189: LD_INT 1
41191: NEG
41192: PUSH
41193: EMPTY
41194: LIST
41195: LIST
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: LIST
41201: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41202: LD_ADDR_VAR 0 28
41206: PUSH
41207: LD_INT 3
41209: NEG
41210: PUSH
41211: LD_INT 3
41213: NEG
41214: PUSH
41215: EMPTY
41216: LIST
41217: LIST
41218: PUSH
41219: LD_INT 3
41221: NEG
41222: PUSH
41223: LD_INT 4
41225: NEG
41226: PUSH
41227: EMPTY
41228: LIST
41229: LIST
41230: PUSH
41231: LD_INT 4
41233: NEG
41234: PUSH
41235: LD_INT 3
41237: NEG
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: LIST
41247: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41248: LD_ADDR_VAR 0 29
41252: PUSH
41253: LD_INT 1
41255: NEG
41256: PUSH
41257: LD_INT 3
41259: NEG
41260: PUSH
41261: EMPTY
41262: LIST
41263: LIST
41264: PUSH
41265: LD_INT 0
41267: PUSH
41268: LD_INT 3
41270: NEG
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: PUSH
41276: LD_INT 1
41278: PUSH
41279: LD_INT 2
41281: NEG
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: LD_INT 1
41289: NEG
41290: PUSH
41291: LD_INT 4
41293: NEG
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: PUSH
41299: LD_INT 0
41301: PUSH
41302: LD_INT 4
41304: NEG
41305: PUSH
41306: EMPTY
41307: LIST
41308: LIST
41309: PUSH
41310: LD_INT 1
41312: PUSH
41313: LD_INT 3
41315: NEG
41316: PUSH
41317: EMPTY
41318: LIST
41319: LIST
41320: PUSH
41321: LD_INT 1
41323: NEG
41324: PUSH
41325: LD_INT 5
41327: NEG
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: LD_INT 0
41335: PUSH
41336: LD_INT 5
41338: NEG
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: LD_INT 1
41346: PUSH
41347: LD_INT 4
41349: NEG
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: PUSH
41355: LD_INT 1
41357: NEG
41358: PUSH
41359: LD_INT 6
41361: NEG
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: PUSH
41367: LD_INT 0
41369: PUSH
41370: LD_INT 6
41372: NEG
41373: PUSH
41374: EMPTY
41375: LIST
41376: LIST
41377: PUSH
41378: LD_INT 1
41380: PUSH
41381: LD_INT 5
41383: NEG
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: EMPTY
41390: LIST
41391: LIST
41392: LIST
41393: LIST
41394: LIST
41395: LIST
41396: LIST
41397: LIST
41398: LIST
41399: LIST
41400: LIST
41401: LIST
41402: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41403: LD_ADDR_VAR 0 30
41407: PUSH
41408: LD_INT 2
41410: PUSH
41411: LD_INT 1
41413: NEG
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 3
41421: PUSH
41422: LD_INT 0
41424: PUSH
41425: EMPTY
41426: LIST
41427: LIST
41428: PUSH
41429: LD_INT 3
41431: PUSH
41432: LD_INT 1
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 3
41441: PUSH
41442: LD_INT 1
41444: NEG
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PUSH
41450: LD_INT 4
41452: PUSH
41453: LD_INT 0
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: PUSH
41460: LD_INT 4
41462: PUSH
41463: LD_INT 1
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: PUSH
41470: LD_INT 4
41472: PUSH
41473: LD_INT 1
41475: NEG
41476: PUSH
41477: EMPTY
41478: LIST
41479: LIST
41480: PUSH
41481: LD_INT 5
41483: PUSH
41484: LD_INT 0
41486: PUSH
41487: EMPTY
41488: LIST
41489: LIST
41490: PUSH
41491: LD_INT 5
41493: PUSH
41494: LD_INT 1
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: PUSH
41501: LD_INT 5
41503: PUSH
41504: LD_INT 1
41506: NEG
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: PUSH
41512: LD_INT 6
41514: PUSH
41515: LD_INT 0
41517: PUSH
41518: EMPTY
41519: LIST
41520: LIST
41521: PUSH
41522: LD_INT 6
41524: PUSH
41525: LD_INT 1
41527: PUSH
41528: EMPTY
41529: LIST
41530: LIST
41531: PUSH
41532: EMPTY
41533: LIST
41534: LIST
41535: LIST
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41546: LD_ADDR_VAR 0 31
41550: PUSH
41551: LD_INT 3
41553: PUSH
41554: LD_INT 2
41556: PUSH
41557: EMPTY
41558: LIST
41559: LIST
41560: PUSH
41561: LD_INT 3
41563: PUSH
41564: LD_INT 3
41566: PUSH
41567: EMPTY
41568: LIST
41569: LIST
41570: PUSH
41571: LD_INT 2
41573: PUSH
41574: LD_INT 3
41576: PUSH
41577: EMPTY
41578: LIST
41579: LIST
41580: PUSH
41581: LD_INT 4
41583: PUSH
41584: LD_INT 3
41586: PUSH
41587: EMPTY
41588: LIST
41589: LIST
41590: PUSH
41591: LD_INT 4
41593: PUSH
41594: LD_INT 4
41596: PUSH
41597: EMPTY
41598: LIST
41599: LIST
41600: PUSH
41601: LD_INT 3
41603: PUSH
41604: LD_INT 4
41606: PUSH
41607: EMPTY
41608: LIST
41609: LIST
41610: PUSH
41611: LD_INT 5
41613: PUSH
41614: LD_INT 4
41616: PUSH
41617: EMPTY
41618: LIST
41619: LIST
41620: PUSH
41621: LD_INT 5
41623: PUSH
41624: LD_INT 5
41626: PUSH
41627: EMPTY
41628: LIST
41629: LIST
41630: PUSH
41631: LD_INT 4
41633: PUSH
41634: LD_INT 5
41636: PUSH
41637: EMPTY
41638: LIST
41639: LIST
41640: PUSH
41641: LD_INT 6
41643: PUSH
41644: LD_INT 5
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PUSH
41651: LD_INT 6
41653: PUSH
41654: LD_INT 6
41656: PUSH
41657: EMPTY
41658: LIST
41659: LIST
41660: PUSH
41661: LD_INT 5
41663: PUSH
41664: LD_INT 6
41666: PUSH
41667: EMPTY
41668: LIST
41669: LIST
41670: PUSH
41671: EMPTY
41672: LIST
41673: LIST
41674: LIST
41675: LIST
41676: LIST
41677: LIST
41678: LIST
41679: LIST
41680: LIST
41681: LIST
41682: LIST
41683: LIST
41684: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41685: LD_ADDR_VAR 0 32
41689: PUSH
41690: LD_INT 1
41692: PUSH
41693: LD_INT 3
41695: PUSH
41696: EMPTY
41697: LIST
41698: LIST
41699: PUSH
41700: LD_INT 0
41702: PUSH
41703: LD_INT 3
41705: PUSH
41706: EMPTY
41707: LIST
41708: LIST
41709: PUSH
41710: LD_INT 1
41712: NEG
41713: PUSH
41714: LD_INT 2
41716: PUSH
41717: EMPTY
41718: LIST
41719: LIST
41720: PUSH
41721: LD_INT 1
41723: PUSH
41724: LD_INT 4
41726: PUSH
41727: EMPTY
41728: LIST
41729: LIST
41730: PUSH
41731: LD_INT 0
41733: PUSH
41734: LD_INT 4
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: PUSH
41741: LD_INT 1
41743: NEG
41744: PUSH
41745: LD_INT 3
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: PUSH
41752: LD_INT 1
41754: PUSH
41755: LD_INT 5
41757: PUSH
41758: EMPTY
41759: LIST
41760: LIST
41761: PUSH
41762: LD_INT 0
41764: PUSH
41765: LD_INT 5
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: LD_INT 1
41774: NEG
41775: PUSH
41776: LD_INT 4
41778: PUSH
41779: EMPTY
41780: LIST
41781: LIST
41782: PUSH
41783: LD_INT 1
41785: PUSH
41786: LD_INT 6
41788: PUSH
41789: EMPTY
41790: LIST
41791: LIST
41792: PUSH
41793: LD_INT 0
41795: PUSH
41796: LD_INT 6
41798: PUSH
41799: EMPTY
41800: LIST
41801: LIST
41802: PUSH
41803: LD_INT 1
41805: NEG
41806: PUSH
41807: LD_INT 5
41809: PUSH
41810: EMPTY
41811: LIST
41812: LIST
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: LIST
41818: LIST
41819: LIST
41820: LIST
41821: LIST
41822: LIST
41823: LIST
41824: LIST
41825: LIST
41826: LIST
41827: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41828: LD_ADDR_VAR 0 33
41832: PUSH
41833: LD_INT 2
41835: NEG
41836: PUSH
41837: LD_INT 1
41839: PUSH
41840: EMPTY
41841: LIST
41842: LIST
41843: PUSH
41844: LD_INT 3
41846: NEG
41847: PUSH
41848: LD_INT 0
41850: PUSH
41851: EMPTY
41852: LIST
41853: LIST
41854: PUSH
41855: LD_INT 3
41857: NEG
41858: PUSH
41859: LD_INT 1
41861: NEG
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: PUSH
41867: LD_INT 3
41869: NEG
41870: PUSH
41871: LD_INT 1
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: LD_INT 4
41880: NEG
41881: PUSH
41882: LD_INT 0
41884: PUSH
41885: EMPTY
41886: LIST
41887: LIST
41888: PUSH
41889: LD_INT 4
41891: NEG
41892: PUSH
41893: LD_INT 1
41895: NEG
41896: PUSH
41897: EMPTY
41898: LIST
41899: LIST
41900: PUSH
41901: LD_INT 4
41903: NEG
41904: PUSH
41905: LD_INT 1
41907: PUSH
41908: EMPTY
41909: LIST
41910: LIST
41911: PUSH
41912: LD_INT 5
41914: NEG
41915: PUSH
41916: LD_INT 0
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: PUSH
41923: LD_INT 5
41925: NEG
41926: PUSH
41927: LD_INT 1
41929: NEG
41930: PUSH
41931: EMPTY
41932: LIST
41933: LIST
41934: PUSH
41935: LD_INT 5
41937: NEG
41938: PUSH
41939: LD_INT 1
41941: PUSH
41942: EMPTY
41943: LIST
41944: LIST
41945: PUSH
41946: LD_INT 6
41948: NEG
41949: PUSH
41950: LD_INT 0
41952: PUSH
41953: EMPTY
41954: LIST
41955: LIST
41956: PUSH
41957: LD_INT 6
41959: NEG
41960: PUSH
41961: LD_INT 1
41963: NEG
41964: PUSH
41965: EMPTY
41966: LIST
41967: LIST
41968: PUSH
41969: EMPTY
41970: LIST
41971: LIST
41972: LIST
41973: LIST
41974: LIST
41975: LIST
41976: LIST
41977: LIST
41978: LIST
41979: LIST
41980: LIST
41981: LIST
41982: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
41983: LD_ADDR_VAR 0 34
41987: PUSH
41988: LD_INT 2
41990: NEG
41991: PUSH
41992: LD_INT 3
41994: NEG
41995: PUSH
41996: EMPTY
41997: LIST
41998: LIST
41999: PUSH
42000: LD_INT 3
42002: NEG
42003: PUSH
42004: LD_INT 2
42006: NEG
42007: PUSH
42008: EMPTY
42009: LIST
42010: LIST
42011: PUSH
42012: LD_INT 3
42014: NEG
42015: PUSH
42016: LD_INT 3
42018: NEG
42019: PUSH
42020: EMPTY
42021: LIST
42022: LIST
42023: PUSH
42024: LD_INT 3
42026: NEG
42027: PUSH
42028: LD_INT 4
42030: NEG
42031: PUSH
42032: EMPTY
42033: LIST
42034: LIST
42035: PUSH
42036: LD_INT 4
42038: NEG
42039: PUSH
42040: LD_INT 3
42042: NEG
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: PUSH
42048: LD_INT 4
42050: NEG
42051: PUSH
42052: LD_INT 4
42054: NEG
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PUSH
42060: LD_INT 4
42062: NEG
42063: PUSH
42064: LD_INT 5
42066: NEG
42067: PUSH
42068: EMPTY
42069: LIST
42070: LIST
42071: PUSH
42072: LD_INT 5
42074: NEG
42075: PUSH
42076: LD_INT 4
42078: NEG
42079: PUSH
42080: EMPTY
42081: LIST
42082: LIST
42083: PUSH
42084: LD_INT 5
42086: NEG
42087: PUSH
42088: LD_INT 5
42090: NEG
42091: PUSH
42092: EMPTY
42093: LIST
42094: LIST
42095: PUSH
42096: LD_INT 5
42098: NEG
42099: PUSH
42100: LD_INT 6
42102: NEG
42103: PUSH
42104: EMPTY
42105: LIST
42106: LIST
42107: PUSH
42108: LD_INT 6
42110: NEG
42111: PUSH
42112: LD_INT 5
42114: NEG
42115: PUSH
42116: EMPTY
42117: LIST
42118: LIST
42119: PUSH
42120: LD_INT 6
42122: NEG
42123: PUSH
42124: LD_INT 6
42126: NEG
42127: PUSH
42128: EMPTY
42129: LIST
42130: LIST
42131: PUSH
42132: EMPTY
42133: LIST
42134: LIST
42135: LIST
42136: LIST
42137: LIST
42138: LIST
42139: LIST
42140: LIST
42141: LIST
42142: LIST
42143: LIST
42144: LIST
42145: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42146: LD_ADDR_VAR 0 41
42150: PUSH
42151: LD_INT 0
42153: PUSH
42154: LD_INT 2
42156: NEG
42157: PUSH
42158: EMPTY
42159: LIST
42160: LIST
42161: PUSH
42162: LD_INT 1
42164: NEG
42165: PUSH
42166: LD_INT 3
42168: NEG
42169: PUSH
42170: EMPTY
42171: LIST
42172: LIST
42173: PUSH
42174: LD_INT 1
42176: PUSH
42177: LD_INT 2
42179: NEG
42180: PUSH
42181: EMPTY
42182: LIST
42183: LIST
42184: PUSH
42185: EMPTY
42186: LIST
42187: LIST
42188: LIST
42189: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42190: LD_ADDR_VAR 0 42
42194: PUSH
42195: LD_INT 2
42197: PUSH
42198: LD_INT 0
42200: PUSH
42201: EMPTY
42202: LIST
42203: LIST
42204: PUSH
42205: LD_INT 2
42207: PUSH
42208: LD_INT 1
42210: NEG
42211: PUSH
42212: EMPTY
42213: LIST
42214: LIST
42215: PUSH
42216: LD_INT 3
42218: PUSH
42219: LD_INT 1
42221: PUSH
42222: EMPTY
42223: LIST
42224: LIST
42225: PUSH
42226: EMPTY
42227: LIST
42228: LIST
42229: LIST
42230: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42231: LD_ADDR_VAR 0 43
42235: PUSH
42236: LD_INT 2
42238: PUSH
42239: LD_INT 2
42241: PUSH
42242: EMPTY
42243: LIST
42244: LIST
42245: PUSH
42246: LD_INT 3
42248: PUSH
42249: LD_INT 2
42251: PUSH
42252: EMPTY
42253: LIST
42254: LIST
42255: PUSH
42256: LD_INT 2
42258: PUSH
42259: LD_INT 3
42261: PUSH
42262: EMPTY
42263: LIST
42264: LIST
42265: PUSH
42266: EMPTY
42267: LIST
42268: LIST
42269: LIST
42270: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42271: LD_ADDR_VAR 0 44
42275: PUSH
42276: LD_INT 0
42278: PUSH
42279: LD_INT 2
42281: PUSH
42282: EMPTY
42283: LIST
42284: LIST
42285: PUSH
42286: LD_INT 1
42288: PUSH
42289: LD_INT 3
42291: PUSH
42292: EMPTY
42293: LIST
42294: LIST
42295: PUSH
42296: LD_INT 1
42298: NEG
42299: PUSH
42300: LD_INT 2
42302: PUSH
42303: EMPTY
42304: LIST
42305: LIST
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: LIST
42311: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42312: LD_ADDR_VAR 0 45
42316: PUSH
42317: LD_INT 2
42319: NEG
42320: PUSH
42321: LD_INT 0
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: PUSH
42328: LD_INT 2
42330: NEG
42331: PUSH
42332: LD_INT 1
42334: PUSH
42335: EMPTY
42336: LIST
42337: LIST
42338: PUSH
42339: LD_INT 3
42341: NEG
42342: PUSH
42343: LD_INT 1
42345: NEG
42346: PUSH
42347: EMPTY
42348: LIST
42349: LIST
42350: PUSH
42351: EMPTY
42352: LIST
42353: LIST
42354: LIST
42355: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42356: LD_ADDR_VAR 0 46
42360: PUSH
42361: LD_INT 2
42363: NEG
42364: PUSH
42365: LD_INT 2
42367: NEG
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: PUSH
42373: LD_INT 2
42375: NEG
42376: PUSH
42377: LD_INT 3
42379: NEG
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: PUSH
42385: LD_INT 3
42387: NEG
42388: PUSH
42389: LD_INT 2
42391: NEG
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: LIST
42401: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42402: LD_ADDR_VAR 0 47
42406: PUSH
42407: LD_INT 2
42409: NEG
42410: PUSH
42411: LD_INT 3
42413: NEG
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: PUSH
42419: LD_INT 1
42421: NEG
42422: PUSH
42423: LD_INT 3
42425: NEG
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42435: LD_ADDR_VAR 0 48
42439: PUSH
42440: LD_INT 1
42442: PUSH
42443: LD_INT 2
42445: NEG
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PUSH
42451: LD_INT 2
42453: PUSH
42454: LD_INT 1
42456: NEG
42457: PUSH
42458: EMPTY
42459: LIST
42460: LIST
42461: PUSH
42462: EMPTY
42463: LIST
42464: LIST
42465: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42466: LD_ADDR_VAR 0 49
42470: PUSH
42471: LD_INT 3
42473: PUSH
42474: LD_INT 1
42476: PUSH
42477: EMPTY
42478: LIST
42479: LIST
42480: PUSH
42481: LD_INT 3
42483: PUSH
42484: LD_INT 2
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42495: LD_ADDR_VAR 0 50
42499: PUSH
42500: LD_INT 2
42502: PUSH
42503: LD_INT 3
42505: PUSH
42506: EMPTY
42507: LIST
42508: LIST
42509: PUSH
42510: LD_INT 1
42512: PUSH
42513: LD_INT 3
42515: PUSH
42516: EMPTY
42517: LIST
42518: LIST
42519: PUSH
42520: EMPTY
42521: LIST
42522: LIST
42523: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42524: LD_ADDR_VAR 0 51
42528: PUSH
42529: LD_INT 1
42531: NEG
42532: PUSH
42533: LD_INT 2
42535: PUSH
42536: EMPTY
42537: LIST
42538: LIST
42539: PUSH
42540: LD_INT 2
42542: NEG
42543: PUSH
42544: LD_INT 1
42546: PUSH
42547: EMPTY
42548: LIST
42549: LIST
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42555: LD_ADDR_VAR 0 52
42559: PUSH
42560: LD_INT 3
42562: NEG
42563: PUSH
42564: LD_INT 1
42566: NEG
42567: PUSH
42568: EMPTY
42569: LIST
42570: LIST
42571: PUSH
42572: LD_INT 3
42574: NEG
42575: PUSH
42576: LD_INT 2
42578: NEG
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42588: LD_ADDR_VAR 0 53
42592: PUSH
42593: LD_INT 1
42595: NEG
42596: PUSH
42597: LD_INT 3
42599: NEG
42600: PUSH
42601: EMPTY
42602: LIST
42603: LIST
42604: PUSH
42605: LD_INT 0
42607: PUSH
42608: LD_INT 3
42610: NEG
42611: PUSH
42612: EMPTY
42613: LIST
42614: LIST
42615: PUSH
42616: LD_INT 1
42618: PUSH
42619: LD_INT 2
42621: NEG
42622: PUSH
42623: EMPTY
42624: LIST
42625: LIST
42626: PUSH
42627: EMPTY
42628: LIST
42629: LIST
42630: LIST
42631: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42632: LD_ADDR_VAR 0 54
42636: PUSH
42637: LD_INT 2
42639: PUSH
42640: LD_INT 1
42642: NEG
42643: PUSH
42644: EMPTY
42645: LIST
42646: LIST
42647: PUSH
42648: LD_INT 3
42650: PUSH
42651: LD_INT 0
42653: PUSH
42654: EMPTY
42655: LIST
42656: LIST
42657: PUSH
42658: LD_INT 3
42660: PUSH
42661: LD_INT 1
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: PUSH
42668: EMPTY
42669: LIST
42670: LIST
42671: LIST
42672: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42673: LD_ADDR_VAR 0 55
42677: PUSH
42678: LD_INT 3
42680: PUSH
42681: LD_INT 2
42683: PUSH
42684: EMPTY
42685: LIST
42686: LIST
42687: PUSH
42688: LD_INT 3
42690: PUSH
42691: LD_INT 3
42693: PUSH
42694: EMPTY
42695: LIST
42696: LIST
42697: PUSH
42698: LD_INT 2
42700: PUSH
42701: LD_INT 3
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: LIST
42712: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42713: LD_ADDR_VAR 0 56
42717: PUSH
42718: LD_INT 1
42720: PUSH
42721: LD_INT 3
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: PUSH
42728: LD_INT 0
42730: PUSH
42731: LD_INT 3
42733: PUSH
42734: EMPTY
42735: LIST
42736: LIST
42737: PUSH
42738: LD_INT 1
42740: NEG
42741: PUSH
42742: LD_INT 2
42744: PUSH
42745: EMPTY
42746: LIST
42747: LIST
42748: PUSH
42749: EMPTY
42750: LIST
42751: LIST
42752: LIST
42753: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42754: LD_ADDR_VAR 0 57
42758: PUSH
42759: LD_INT 2
42761: NEG
42762: PUSH
42763: LD_INT 1
42765: PUSH
42766: EMPTY
42767: LIST
42768: LIST
42769: PUSH
42770: LD_INT 3
42772: NEG
42773: PUSH
42774: LD_INT 0
42776: PUSH
42777: EMPTY
42778: LIST
42779: LIST
42780: PUSH
42781: LD_INT 3
42783: NEG
42784: PUSH
42785: LD_INT 1
42787: NEG
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: LIST
42797: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42798: LD_ADDR_VAR 0 58
42802: PUSH
42803: LD_INT 2
42805: NEG
42806: PUSH
42807: LD_INT 3
42809: NEG
42810: PUSH
42811: EMPTY
42812: LIST
42813: LIST
42814: PUSH
42815: LD_INT 3
42817: NEG
42818: PUSH
42819: LD_INT 2
42821: NEG
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: PUSH
42827: LD_INT 3
42829: NEG
42830: PUSH
42831: LD_INT 3
42833: NEG
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PUSH
42839: EMPTY
42840: LIST
42841: LIST
42842: LIST
42843: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42844: LD_ADDR_VAR 0 59
42848: PUSH
42849: LD_INT 1
42851: NEG
42852: PUSH
42853: LD_INT 2
42855: NEG
42856: PUSH
42857: EMPTY
42858: LIST
42859: LIST
42860: PUSH
42861: LD_INT 0
42863: PUSH
42864: LD_INT 2
42866: NEG
42867: PUSH
42868: EMPTY
42869: LIST
42870: LIST
42871: PUSH
42872: LD_INT 1
42874: PUSH
42875: LD_INT 1
42877: NEG
42878: PUSH
42879: EMPTY
42880: LIST
42881: LIST
42882: PUSH
42883: EMPTY
42884: LIST
42885: LIST
42886: LIST
42887: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42888: LD_ADDR_VAR 0 60
42892: PUSH
42893: LD_INT 1
42895: PUSH
42896: LD_INT 1
42898: NEG
42899: PUSH
42900: EMPTY
42901: LIST
42902: LIST
42903: PUSH
42904: LD_INT 2
42906: PUSH
42907: LD_INT 0
42909: PUSH
42910: EMPTY
42911: LIST
42912: LIST
42913: PUSH
42914: LD_INT 2
42916: PUSH
42917: LD_INT 1
42919: PUSH
42920: EMPTY
42921: LIST
42922: LIST
42923: PUSH
42924: EMPTY
42925: LIST
42926: LIST
42927: LIST
42928: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42929: LD_ADDR_VAR 0 61
42933: PUSH
42934: LD_INT 2
42936: PUSH
42937: LD_INT 1
42939: PUSH
42940: EMPTY
42941: LIST
42942: LIST
42943: PUSH
42944: LD_INT 2
42946: PUSH
42947: LD_INT 2
42949: PUSH
42950: EMPTY
42951: LIST
42952: LIST
42953: PUSH
42954: LD_INT 1
42956: PUSH
42957: LD_INT 2
42959: PUSH
42960: EMPTY
42961: LIST
42962: LIST
42963: PUSH
42964: EMPTY
42965: LIST
42966: LIST
42967: LIST
42968: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42969: LD_ADDR_VAR 0 62
42973: PUSH
42974: LD_INT 1
42976: PUSH
42977: LD_INT 2
42979: PUSH
42980: EMPTY
42981: LIST
42982: LIST
42983: PUSH
42984: LD_INT 0
42986: PUSH
42987: LD_INT 2
42989: PUSH
42990: EMPTY
42991: LIST
42992: LIST
42993: PUSH
42994: LD_INT 1
42996: NEG
42997: PUSH
42998: LD_INT 1
43000: PUSH
43001: EMPTY
43002: LIST
43003: LIST
43004: PUSH
43005: EMPTY
43006: LIST
43007: LIST
43008: LIST
43009: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43010: LD_ADDR_VAR 0 63
43014: PUSH
43015: LD_INT 1
43017: NEG
43018: PUSH
43019: LD_INT 1
43021: PUSH
43022: EMPTY
43023: LIST
43024: LIST
43025: PUSH
43026: LD_INT 2
43028: NEG
43029: PUSH
43030: LD_INT 0
43032: PUSH
43033: EMPTY
43034: LIST
43035: LIST
43036: PUSH
43037: LD_INT 2
43039: NEG
43040: PUSH
43041: LD_INT 1
43043: NEG
43044: PUSH
43045: EMPTY
43046: LIST
43047: LIST
43048: PUSH
43049: EMPTY
43050: LIST
43051: LIST
43052: LIST
43053: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43054: LD_ADDR_VAR 0 64
43058: PUSH
43059: LD_INT 1
43061: NEG
43062: PUSH
43063: LD_INT 2
43065: NEG
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: PUSH
43071: LD_INT 2
43073: NEG
43074: PUSH
43075: LD_INT 1
43077: NEG
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_INT 2
43085: NEG
43086: PUSH
43087: LD_INT 2
43089: NEG
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: PUSH
43095: EMPTY
43096: LIST
43097: LIST
43098: LIST
43099: ST_TO_ADDR
// end ; 2 :
43100: GO 46366
43102: LD_INT 2
43104: DOUBLE
43105: EQUAL
43106: IFTRUE 43110
43108: GO 46365
43110: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43111: LD_ADDR_VAR 0 29
43115: PUSH
43116: LD_INT 4
43118: PUSH
43119: LD_INT 0
43121: PUSH
43122: EMPTY
43123: LIST
43124: LIST
43125: PUSH
43126: LD_INT 4
43128: PUSH
43129: LD_INT 1
43131: NEG
43132: PUSH
43133: EMPTY
43134: LIST
43135: LIST
43136: PUSH
43137: LD_INT 5
43139: PUSH
43140: LD_INT 0
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: LD_INT 5
43149: PUSH
43150: LD_INT 1
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: LD_INT 4
43159: PUSH
43160: LD_INT 1
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 3
43169: PUSH
43170: LD_INT 0
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: LD_INT 3
43179: PUSH
43180: LD_INT 1
43182: NEG
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: PUSH
43188: LD_INT 3
43190: PUSH
43191: LD_INT 2
43193: NEG
43194: PUSH
43195: EMPTY
43196: LIST
43197: LIST
43198: PUSH
43199: LD_INT 5
43201: PUSH
43202: LD_INT 2
43204: PUSH
43205: EMPTY
43206: LIST
43207: LIST
43208: PUSH
43209: LD_INT 3
43211: PUSH
43212: LD_INT 3
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PUSH
43219: LD_INT 3
43221: PUSH
43222: LD_INT 2
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: PUSH
43229: LD_INT 4
43231: PUSH
43232: LD_INT 3
43234: PUSH
43235: EMPTY
43236: LIST
43237: LIST
43238: PUSH
43239: LD_INT 4
43241: PUSH
43242: LD_INT 4
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: PUSH
43249: LD_INT 3
43251: PUSH
43252: LD_INT 4
43254: PUSH
43255: EMPTY
43256: LIST
43257: LIST
43258: PUSH
43259: LD_INT 2
43261: PUSH
43262: LD_INT 3
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: PUSH
43269: LD_INT 2
43271: PUSH
43272: LD_INT 2
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: PUSH
43279: LD_INT 4
43281: PUSH
43282: LD_INT 2
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: LD_INT 2
43291: PUSH
43292: LD_INT 4
43294: PUSH
43295: EMPTY
43296: LIST
43297: LIST
43298: PUSH
43299: LD_INT 0
43301: PUSH
43302: LD_INT 4
43304: PUSH
43305: EMPTY
43306: LIST
43307: LIST
43308: PUSH
43309: LD_INT 0
43311: PUSH
43312: LD_INT 3
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: PUSH
43319: LD_INT 1
43321: PUSH
43322: LD_INT 4
43324: PUSH
43325: EMPTY
43326: LIST
43327: LIST
43328: PUSH
43329: LD_INT 1
43331: PUSH
43332: LD_INT 5
43334: PUSH
43335: EMPTY
43336: LIST
43337: LIST
43338: PUSH
43339: LD_INT 0
43341: PUSH
43342: LD_INT 5
43344: PUSH
43345: EMPTY
43346: LIST
43347: LIST
43348: PUSH
43349: LD_INT 1
43351: NEG
43352: PUSH
43353: LD_INT 4
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 1
43362: NEG
43363: PUSH
43364: LD_INT 3
43366: PUSH
43367: EMPTY
43368: LIST
43369: LIST
43370: PUSH
43371: LD_INT 2
43373: PUSH
43374: LD_INT 5
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: PUSH
43381: LD_INT 2
43383: NEG
43384: PUSH
43385: LD_INT 3
43387: PUSH
43388: EMPTY
43389: LIST
43390: LIST
43391: PUSH
43392: LD_INT 3
43394: NEG
43395: PUSH
43396: LD_INT 0
43398: PUSH
43399: EMPTY
43400: LIST
43401: LIST
43402: PUSH
43403: LD_INT 3
43405: NEG
43406: PUSH
43407: LD_INT 1
43409: NEG
43410: PUSH
43411: EMPTY
43412: LIST
43413: LIST
43414: PUSH
43415: LD_INT 2
43417: NEG
43418: PUSH
43419: LD_INT 0
43421: PUSH
43422: EMPTY
43423: LIST
43424: LIST
43425: PUSH
43426: LD_INT 2
43428: NEG
43429: PUSH
43430: LD_INT 1
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: PUSH
43437: LD_INT 3
43439: NEG
43440: PUSH
43441: LD_INT 1
43443: PUSH
43444: EMPTY
43445: LIST
43446: LIST
43447: PUSH
43448: LD_INT 4
43450: NEG
43451: PUSH
43452: LD_INT 0
43454: PUSH
43455: EMPTY
43456: LIST
43457: LIST
43458: PUSH
43459: LD_INT 4
43461: NEG
43462: PUSH
43463: LD_INT 1
43465: NEG
43466: PUSH
43467: EMPTY
43468: LIST
43469: LIST
43470: PUSH
43471: LD_INT 4
43473: NEG
43474: PUSH
43475: LD_INT 2
43477: NEG
43478: PUSH
43479: EMPTY
43480: LIST
43481: LIST
43482: PUSH
43483: LD_INT 2
43485: NEG
43486: PUSH
43487: LD_INT 2
43489: PUSH
43490: EMPTY
43491: LIST
43492: LIST
43493: PUSH
43494: LD_INT 4
43496: NEG
43497: PUSH
43498: LD_INT 4
43500: NEG
43501: PUSH
43502: EMPTY
43503: LIST
43504: LIST
43505: PUSH
43506: LD_INT 4
43508: NEG
43509: PUSH
43510: LD_INT 5
43512: NEG
43513: PUSH
43514: EMPTY
43515: LIST
43516: LIST
43517: PUSH
43518: LD_INT 3
43520: NEG
43521: PUSH
43522: LD_INT 4
43524: NEG
43525: PUSH
43526: EMPTY
43527: LIST
43528: LIST
43529: PUSH
43530: LD_INT 3
43532: NEG
43533: PUSH
43534: LD_INT 3
43536: NEG
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 4
43544: NEG
43545: PUSH
43546: LD_INT 3
43548: NEG
43549: PUSH
43550: EMPTY
43551: LIST
43552: LIST
43553: PUSH
43554: LD_INT 5
43556: NEG
43557: PUSH
43558: LD_INT 4
43560: NEG
43561: PUSH
43562: EMPTY
43563: LIST
43564: LIST
43565: PUSH
43566: LD_INT 5
43568: NEG
43569: PUSH
43570: LD_INT 5
43572: NEG
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 3
43580: NEG
43581: PUSH
43582: LD_INT 5
43584: NEG
43585: PUSH
43586: EMPTY
43587: LIST
43588: LIST
43589: PUSH
43590: LD_INT 5
43592: NEG
43593: PUSH
43594: LD_INT 3
43596: NEG
43597: PUSH
43598: EMPTY
43599: LIST
43600: LIST
43601: PUSH
43602: EMPTY
43603: LIST
43604: LIST
43605: LIST
43606: LIST
43607: LIST
43608: LIST
43609: LIST
43610: LIST
43611: LIST
43612: LIST
43613: LIST
43614: LIST
43615: LIST
43616: LIST
43617: LIST
43618: LIST
43619: LIST
43620: LIST
43621: LIST
43622: LIST
43623: LIST
43624: LIST
43625: LIST
43626: LIST
43627: LIST
43628: LIST
43629: LIST
43630: LIST
43631: LIST
43632: LIST
43633: LIST
43634: LIST
43635: LIST
43636: LIST
43637: LIST
43638: LIST
43639: LIST
43640: LIST
43641: LIST
43642: LIST
43643: LIST
43644: LIST
43645: LIST
43646: LIST
43647: LIST
43648: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43649: LD_ADDR_VAR 0 30
43653: PUSH
43654: LD_INT 4
43656: PUSH
43657: LD_INT 4
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: LD_INT 4
43666: PUSH
43667: LD_INT 3
43669: PUSH
43670: EMPTY
43671: LIST
43672: LIST
43673: PUSH
43674: LD_INT 5
43676: PUSH
43677: LD_INT 4
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 5
43686: PUSH
43687: LD_INT 5
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 4
43696: PUSH
43697: LD_INT 5
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 3
43706: PUSH
43707: LD_INT 4
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 3
43716: PUSH
43717: LD_INT 3
43719: PUSH
43720: EMPTY
43721: LIST
43722: LIST
43723: PUSH
43724: LD_INT 5
43726: PUSH
43727: LD_INT 3
43729: PUSH
43730: EMPTY
43731: LIST
43732: LIST
43733: PUSH
43734: LD_INT 3
43736: PUSH
43737: LD_INT 5
43739: PUSH
43740: EMPTY
43741: LIST
43742: LIST
43743: PUSH
43744: LD_INT 0
43746: PUSH
43747: LD_INT 3
43749: PUSH
43750: EMPTY
43751: LIST
43752: LIST
43753: PUSH
43754: LD_INT 0
43756: PUSH
43757: LD_INT 2
43759: PUSH
43760: EMPTY
43761: LIST
43762: LIST
43763: PUSH
43764: LD_INT 1
43766: PUSH
43767: LD_INT 3
43769: PUSH
43770: EMPTY
43771: LIST
43772: LIST
43773: PUSH
43774: LD_INT 1
43776: PUSH
43777: LD_INT 4
43779: PUSH
43780: EMPTY
43781: LIST
43782: LIST
43783: PUSH
43784: LD_INT 0
43786: PUSH
43787: LD_INT 4
43789: PUSH
43790: EMPTY
43791: LIST
43792: LIST
43793: PUSH
43794: LD_INT 1
43796: NEG
43797: PUSH
43798: LD_INT 3
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: LD_INT 1
43807: NEG
43808: PUSH
43809: LD_INT 2
43811: PUSH
43812: EMPTY
43813: LIST
43814: LIST
43815: PUSH
43816: LD_INT 2
43818: PUSH
43819: LD_INT 4
43821: PUSH
43822: EMPTY
43823: LIST
43824: LIST
43825: PUSH
43826: LD_INT 2
43828: NEG
43829: PUSH
43830: LD_INT 2
43832: PUSH
43833: EMPTY
43834: LIST
43835: LIST
43836: PUSH
43837: LD_INT 4
43839: NEG
43840: PUSH
43841: LD_INT 0
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: PUSH
43848: LD_INT 4
43850: NEG
43851: PUSH
43852: LD_INT 1
43854: NEG
43855: PUSH
43856: EMPTY
43857: LIST
43858: LIST
43859: PUSH
43860: LD_INT 3
43862: NEG
43863: PUSH
43864: LD_INT 0
43866: PUSH
43867: EMPTY
43868: LIST
43869: LIST
43870: PUSH
43871: LD_INT 3
43873: NEG
43874: PUSH
43875: LD_INT 1
43877: PUSH
43878: EMPTY
43879: LIST
43880: LIST
43881: PUSH
43882: LD_INT 4
43884: NEG
43885: PUSH
43886: LD_INT 1
43888: PUSH
43889: EMPTY
43890: LIST
43891: LIST
43892: PUSH
43893: LD_INT 5
43895: NEG
43896: PUSH
43897: LD_INT 0
43899: PUSH
43900: EMPTY
43901: LIST
43902: LIST
43903: PUSH
43904: LD_INT 5
43906: NEG
43907: PUSH
43908: LD_INT 1
43910: NEG
43911: PUSH
43912: EMPTY
43913: LIST
43914: LIST
43915: PUSH
43916: LD_INT 5
43918: NEG
43919: PUSH
43920: LD_INT 2
43922: NEG
43923: PUSH
43924: EMPTY
43925: LIST
43926: LIST
43927: PUSH
43928: LD_INT 3
43930: NEG
43931: PUSH
43932: LD_INT 2
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PUSH
43939: LD_INT 3
43941: NEG
43942: PUSH
43943: LD_INT 3
43945: NEG
43946: PUSH
43947: EMPTY
43948: LIST
43949: LIST
43950: PUSH
43951: LD_INT 3
43953: NEG
43954: PUSH
43955: LD_INT 4
43957: NEG
43958: PUSH
43959: EMPTY
43960: LIST
43961: LIST
43962: PUSH
43963: LD_INT 2
43965: NEG
43966: PUSH
43967: LD_INT 3
43969: NEG
43970: PUSH
43971: EMPTY
43972: LIST
43973: LIST
43974: PUSH
43975: LD_INT 2
43977: NEG
43978: PUSH
43979: LD_INT 2
43981: NEG
43982: PUSH
43983: EMPTY
43984: LIST
43985: LIST
43986: PUSH
43987: LD_INT 3
43989: NEG
43990: PUSH
43991: LD_INT 2
43993: NEG
43994: PUSH
43995: EMPTY
43996: LIST
43997: LIST
43998: PUSH
43999: LD_INT 4
44001: NEG
44002: PUSH
44003: LD_INT 3
44005: NEG
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: LD_INT 4
44013: NEG
44014: PUSH
44015: LD_INT 4
44017: NEG
44018: PUSH
44019: EMPTY
44020: LIST
44021: LIST
44022: PUSH
44023: LD_INT 2
44025: NEG
44026: PUSH
44027: LD_INT 4
44029: NEG
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PUSH
44035: LD_INT 4
44037: NEG
44038: PUSH
44039: LD_INT 2
44041: NEG
44042: PUSH
44043: EMPTY
44044: LIST
44045: LIST
44046: PUSH
44047: LD_INT 0
44049: PUSH
44050: LD_INT 4
44052: NEG
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: LD_INT 0
44060: PUSH
44061: LD_INT 5
44063: NEG
44064: PUSH
44065: EMPTY
44066: LIST
44067: LIST
44068: PUSH
44069: LD_INT 1
44071: PUSH
44072: LD_INT 4
44074: NEG
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_INT 1
44082: PUSH
44083: LD_INT 3
44085: NEG
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: LD_INT 0
44093: PUSH
44094: LD_INT 3
44096: NEG
44097: PUSH
44098: EMPTY
44099: LIST
44100: LIST
44101: PUSH
44102: LD_INT 1
44104: NEG
44105: PUSH
44106: LD_INT 4
44108: NEG
44109: PUSH
44110: EMPTY
44111: LIST
44112: LIST
44113: PUSH
44114: LD_INT 1
44116: NEG
44117: PUSH
44118: LD_INT 5
44120: NEG
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: PUSH
44126: LD_INT 2
44128: PUSH
44129: LD_INT 3
44131: NEG
44132: PUSH
44133: EMPTY
44134: LIST
44135: LIST
44136: PUSH
44137: LD_INT 2
44139: NEG
44140: PUSH
44141: LD_INT 5
44143: NEG
44144: PUSH
44145: EMPTY
44146: LIST
44147: LIST
44148: PUSH
44149: EMPTY
44150: LIST
44151: LIST
44152: LIST
44153: LIST
44154: LIST
44155: LIST
44156: LIST
44157: LIST
44158: LIST
44159: LIST
44160: LIST
44161: LIST
44162: LIST
44163: LIST
44164: LIST
44165: LIST
44166: LIST
44167: LIST
44168: LIST
44169: LIST
44170: LIST
44171: LIST
44172: LIST
44173: LIST
44174: LIST
44175: LIST
44176: LIST
44177: LIST
44178: LIST
44179: LIST
44180: LIST
44181: LIST
44182: LIST
44183: LIST
44184: LIST
44185: LIST
44186: LIST
44187: LIST
44188: LIST
44189: LIST
44190: LIST
44191: LIST
44192: LIST
44193: LIST
44194: LIST
44195: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44196: LD_ADDR_VAR 0 31
44200: PUSH
44201: LD_INT 0
44203: PUSH
44204: LD_INT 4
44206: PUSH
44207: EMPTY
44208: LIST
44209: LIST
44210: PUSH
44211: LD_INT 0
44213: PUSH
44214: LD_INT 3
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: PUSH
44221: LD_INT 1
44223: PUSH
44224: LD_INT 4
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 1
44233: PUSH
44234: LD_INT 5
44236: PUSH
44237: EMPTY
44238: LIST
44239: LIST
44240: PUSH
44241: LD_INT 0
44243: PUSH
44244: LD_INT 5
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: PUSH
44251: LD_INT 1
44253: NEG
44254: PUSH
44255: LD_INT 4
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: PUSH
44262: LD_INT 1
44264: NEG
44265: PUSH
44266: LD_INT 3
44268: PUSH
44269: EMPTY
44270: LIST
44271: LIST
44272: PUSH
44273: LD_INT 2
44275: PUSH
44276: LD_INT 5
44278: PUSH
44279: EMPTY
44280: LIST
44281: LIST
44282: PUSH
44283: LD_INT 2
44285: NEG
44286: PUSH
44287: LD_INT 3
44289: PUSH
44290: EMPTY
44291: LIST
44292: LIST
44293: PUSH
44294: LD_INT 3
44296: NEG
44297: PUSH
44298: LD_INT 0
44300: PUSH
44301: EMPTY
44302: LIST
44303: LIST
44304: PUSH
44305: LD_INT 3
44307: NEG
44308: PUSH
44309: LD_INT 1
44311: NEG
44312: PUSH
44313: EMPTY
44314: LIST
44315: LIST
44316: PUSH
44317: LD_INT 2
44319: NEG
44320: PUSH
44321: LD_INT 0
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_INT 2
44330: NEG
44331: PUSH
44332: LD_INT 1
44334: PUSH
44335: EMPTY
44336: LIST
44337: LIST
44338: PUSH
44339: LD_INT 3
44341: NEG
44342: PUSH
44343: LD_INT 1
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: LD_INT 4
44352: NEG
44353: PUSH
44354: LD_INT 0
44356: PUSH
44357: EMPTY
44358: LIST
44359: LIST
44360: PUSH
44361: LD_INT 4
44363: NEG
44364: PUSH
44365: LD_INT 1
44367: NEG
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 4
44375: NEG
44376: PUSH
44377: LD_INT 2
44379: NEG
44380: PUSH
44381: EMPTY
44382: LIST
44383: LIST
44384: PUSH
44385: LD_INT 2
44387: NEG
44388: PUSH
44389: LD_INT 2
44391: PUSH
44392: EMPTY
44393: LIST
44394: LIST
44395: PUSH
44396: LD_INT 4
44398: NEG
44399: PUSH
44400: LD_INT 4
44402: NEG
44403: PUSH
44404: EMPTY
44405: LIST
44406: LIST
44407: PUSH
44408: LD_INT 4
44410: NEG
44411: PUSH
44412: LD_INT 5
44414: NEG
44415: PUSH
44416: EMPTY
44417: LIST
44418: LIST
44419: PUSH
44420: LD_INT 3
44422: NEG
44423: PUSH
44424: LD_INT 4
44426: NEG
44427: PUSH
44428: EMPTY
44429: LIST
44430: LIST
44431: PUSH
44432: LD_INT 3
44434: NEG
44435: PUSH
44436: LD_INT 3
44438: NEG
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: LD_INT 4
44446: NEG
44447: PUSH
44448: LD_INT 3
44450: NEG
44451: PUSH
44452: EMPTY
44453: LIST
44454: LIST
44455: PUSH
44456: LD_INT 5
44458: NEG
44459: PUSH
44460: LD_INT 4
44462: NEG
44463: PUSH
44464: EMPTY
44465: LIST
44466: LIST
44467: PUSH
44468: LD_INT 5
44470: NEG
44471: PUSH
44472: LD_INT 5
44474: NEG
44475: PUSH
44476: EMPTY
44477: LIST
44478: LIST
44479: PUSH
44480: LD_INT 3
44482: NEG
44483: PUSH
44484: LD_INT 5
44486: NEG
44487: PUSH
44488: EMPTY
44489: LIST
44490: LIST
44491: PUSH
44492: LD_INT 5
44494: NEG
44495: PUSH
44496: LD_INT 3
44498: NEG
44499: PUSH
44500: EMPTY
44501: LIST
44502: LIST
44503: PUSH
44504: LD_INT 0
44506: PUSH
44507: LD_INT 3
44509: NEG
44510: PUSH
44511: EMPTY
44512: LIST
44513: LIST
44514: PUSH
44515: LD_INT 0
44517: PUSH
44518: LD_INT 4
44520: NEG
44521: PUSH
44522: EMPTY
44523: LIST
44524: LIST
44525: PUSH
44526: LD_INT 1
44528: PUSH
44529: LD_INT 3
44531: NEG
44532: PUSH
44533: EMPTY
44534: LIST
44535: LIST
44536: PUSH
44537: LD_INT 1
44539: PUSH
44540: LD_INT 2
44542: NEG
44543: PUSH
44544: EMPTY
44545: LIST
44546: LIST
44547: PUSH
44548: LD_INT 0
44550: PUSH
44551: LD_INT 2
44553: NEG
44554: PUSH
44555: EMPTY
44556: LIST
44557: LIST
44558: PUSH
44559: LD_INT 1
44561: NEG
44562: PUSH
44563: LD_INT 3
44565: NEG
44566: PUSH
44567: EMPTY
44568: LIST
44569: LIST
44570: PUSH
44571: LD_INT 1
44573: NEG
44574: PUSH
44575: LD_INT 4
44577: NEG
44578: PUSH
44579: EMPTY
44580: LIST
44581: LIST
44582: PUSH
44583: LD_INT 2
44585: PUSH
44586: LD_INT 2
44588: NEG
44589: PUSH
44590: EMPTY
44591: LIST
44592: LIST
44593: PUSH
44594: LD_INT 2
44596: NEG
44597: PUSH
44598: LD_INT 4
44600: NEG
44601: PUSH
44602: EMPTY
44603: LIST
44604: LIST
44605: PUSH
44606: LD_INT 4
44608: PUSH
44609: LD_INT 0
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: LD_INT 4
44618: PUSH
44619: LD_INT 1
44621: NEG
44622: PUSH
44623: EMPTY
44624: LIST
44625: LIST
44626: PUSH
44627: LD_INT 5
44629: PUSH
44630: LD_INT 0
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PUSH
44637: LD_INT 5
44639: PUSH
44640: LD_INT 1
44642: PUSH
44643: EMPTY
44644: LIST
44645: LIST
44646: PUSH
44647: LD_INT 4
44649: PUSH
44650: LD_INT 1
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: LD_INT 3
44659: PUSH
44660: LD_INT 0
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: PUSH
44667: LD_INT 3
44669: PUSH
44670: LD_INT 1
44672: NEG
44673: PUSH
44674: EMPTY
44675: LIST
44676: LIST
44677: PUSH
44678: LD_INT 3
44680: PUSH
44681: LD_INT 2
44683: NEG
44684: PUSH
44685: EMPTY
44686: LIST
44687: LIST
44688: PUSH
44689: LD_INT 5
44691: PUSH
44692: LD_INT 2
44694: PUSH
44695: EMPTY
44696: LIST
44697: LIST
44698: PUSH
44699: EMPTY
44700: LIST
44701: LIST
44702: LIST
44703: LIST
44704: LIST
44705: LIST
44706: LIST
44707: LIST
44708: LIST
44709: LIST
44710: LIST
44711: LIST
44712: LIST
44713: LIST
44714: LIST
44715: LIST
44716: LIST
44717: LIST
44718: LIST
44719: LIST
44720: LIST
44721: LIST
44722: LIST
44723: LIST
44724: LIST
44725: LIST
44726: LIST
44727: LIST
44728: LIST
44729: LIST
44730: LIST
44731: LIST
44732: LIST
44733: LIST
44734: LIST
44735: LIST
44736: LIST
44737: LIST
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: LIST
44745: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44746: LD_ADDR_VAR 0 32
44750: PUSH
44751: LD_INT 4
44753: NEG
44754: PUSH
44755: LD_INT 0
44757: PUSH
44758: EMPTY
44759: LIST
44760: LIST
44761: PUSH
44762: LD_INT 4
44764: NEG
44765: PUSH
44766: LD_INT 1
44768: NEG
44769: PUSH
44770: EMPTY
44771: LIST
44772: LIST
44773: PUSH
44774: LD_INT 3
44776: NEG
44777: PUSH
44778: LD_INT 0
44780: PUSH
44781: EMPTY
44782: LIST
44783: LIST
44784: PUSH
44785: LD_INT 3
44787: NEG
44788: PUSH
44789: LD_INT 1
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PUSH
44796: LD_INT 4
44798: NEG
44799: PUSH
44800: LD_INT 1
44802: PUSH
44803: EMPTY
44804: LIST
44805: LIST
44806: PUSH
44807: LD_INT 5
44809: NEG
44810: PUSH
44811: LD_INT 0
44813: PUSH
44814: EMPTY
44815: LIST
44816: LIST
44817: PUSH
44818: LD_INT 5
44820: NEG
44821: PUSH
44822: LD_INT 1
44824: NEG
44825: PUSH
44826: EMPTY
44827: LIST
44828: LIST
44829: PUSH
44830: LD_INT 5
44832: NEG
44833: PUSH
44834: LD_INT 2
44836: NEG
44837: PUSH
44838: EMPTY
44839: LIST
44840: LIST
44841: PUSH
44842: LD_INT 3
44844: NEG
44845: PUSH
44846: LD_INT 2
44848: PUSH
44849: EMPTY
44850: LIST
44851: LIST
44852: PUSH
44853: LD_INT 3
44855: NEG
44856: PUSH
44857: LD_INT 3
44859: NEG
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PUSH
44865: LD_INT 3
44867: NEG
44868: PUSH
44869: LD_INT 4
44871: NEG
44872: PUSH
44873: EMPTY
44874: LIST
44875: LIST
44876: PUSH
44877: LD_INT 2
44879: NEG
44880: PUSH
44881: LD_INT 3
44883: NEG
44884: PUSH
44885: EMPTY
44886: LIST
44887: LIST
44888: PUSH
44889: LD_INT 2
44891: NEG
44892: PUSH
44893: LD_INT 2
44895: NEG
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: LD_INT 3
44903: NEG
44904: PUSH
44905: LD_INT 2
44907: NEG
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: LD_INT 4
44915: NEG
44916: PUSH
44917: LD_INT 3
44919: NEG
44920: PUSH
44921: EMPTY
44922: LIST
44923: LIST
44924: PUSH
44925: LD_INT 4
44927: NEG
44928: PUSH
44929: LD_INT 4
44931: NEG
44932: PUSH
44933: EMPTY
44934: LIST
44935: LIST
44936: PUSH
44937: LD_INT 2
44939: NEG
44940: PUSH
44941: LD_INT 4
44943: NEG
44944: PUSH
44945: EMPTY
44946: LIST
44947: LIST
44948: PUSH
44949: LD_INT 4
44951: NEG
44952: PUSH
44953: LD_INT 2
44955: NEG
44956: PUSH
44957: EMPTY
44958: LIST
44959: LIST
44960: PUSH
44961: LD_INT 0
44963: PUSH
44964: LD_INT 4
44966: NEG
44967: PUSH
44968: EMPTY
44969: LIST
44970: LIST
44971: PUSH
44972: LD_INT 0
44974: PUSH
44975: LD_INT 5
44977: NEG
44978: PUSH
44979: EMPTY
44980: LIST
44981: LIST
44982: PUSH
44983: LD_INT 1
44985: PUSH
44986: LD_INT 4
44988: NEG
44989: PUSH
44990: EMPTY
44991: LIST
44992: LIST
44993: PUSH
44994: LD_INT 1
44996: PUSH
44997: LD_INT 3
44999: NEG
45000: PUSH
45001: EMPTY
45002: LIST
45003: LIST
45004: PUSH
45005: LD_INT 0
45007: PUSH
45008: LD_INT 3
45010: NEG
45011: PUSH
45012: EMPTY
45013: LIST
45014: LIST
45015: PUSH
45016: LD_INT 1
45018: NEG
45019: PUSH
45020: LD_INT 4
45022: NEG
45023: PUSH
45024: EMPTY
45025: LIST
45026: LIST
45027: PUSH
45028: LD_INT 1
45030: NEG
45031: PUSH
45032: LD_INT 5
45034: NEG
45035: PUSH
45036: EMPTY
45037: LIST
45038: LIST
45039: PUSH
45040: LD_INT 2
45042: PUSH
45043: LD_INT 3
45045: NEG
45046: PUSH
45047: EMPTY
45048: LIST
45049: LIST
45050: PUSH
45051: LD_INT 2
45053: NEG
45054: PUSH
45055: LD_INT 5
45057: NEG
45058: PUSH
45059: EMPTY
45060: LIST
45061: LIST
45062: PUSH
45063: LD_INT 3
45065: PUSH
45066: LD_INT 0
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: PUSH
45073: LD_INT 3
45075: PUSH
45076: LD_INT 1
45078: NEG
45079: PUSH
45080: EMPTY
45081: LIST
45082: LIST
45083: PUSH
45084: LD_INT 4
45086: PUSH
45087: LD_INT 0
45089: PUSH
45090: EMPTY
45091: LIST
45092: LIST
45093: PUSH
45094: LD_INT 4
45096: PUSH
45097: LD_INT 1
45099: PUSH
45100: EMPTY
45101: LIST
45102: LIST
45103: PUSH
45104: LD_INT 3
45106: PUSH
45107: LD_INT 1
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: PUSH
45114: LD_INT 2
45116: PUSH
45117: LD_INT 0
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: PUSH
45124: LD_INT 2
45126: PUSH
45127: LD_INT 1
45129: NEG
45130: PUSH
45131: EMPTY
45132: LIST
45133: LIST
45134: PUSH
45135: LD_INT 2
45137: PUSH
45138: LD_INT 2
45140: NEG
45141: PUSH
45142: EMPTY
45143: LIST
45144: LIST
45145: PUSH
45146: LD_INT 4
45148: PUSH
45149: LD_INT 2
45151: PUSH
45152: EMPTY
45153: LIST
45154: LIST
45155: PUSH
45156: LD_INT 4
45158: PUSH
45159: LD_INT 4
45161: PUSH
45162: EMPTY
45163: LIST
45164: LIST
45165: PUSH
45166: LD_INT 4
45168: PUSH
45169: LD_INT 3
45171: PUSH
45172: EMPTY
45173: LIST
45174: LIST
45175: PUSH
45176: LD_INT 5
45178: PUSH
45179: LD_INT 4
45181: PUSH
45182: EMPTY
45183: LIST
45184: LIST
45185: PUSH
45186: LD_INT 5
45188: PUSH
45189: LD_INT 5
45191: PUSH
45192: EMPTY
45193: LIST
45194: LIST
45195: PUSH
45196: LD_INT 4
45198: PUSH
45199: LD_INT 5
45201: PUSH
45202: EMPTY
45203: LIST
45204: LIST
45205: PUSH
45206: LD_INT 3
45208: PUSH
45209: LD_INT 4
45211: PUSH
45212: EMPTY
45213: LIST
45214: LIST
45215: PUSH
45216: LD_INT 3
45218: PUSH
45219: LD_INT 3
45221: PUSH
45222: EMPTY
45223: LIST
45224: LIST
45225: PUSH
45226: LD_INT 5
45228: PUSH
45229: LD_INT 3
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: PUSH
45236: LD_INT 3
45238: PUSH
45239: LD_INT 5
45241: PUSH
45242: EMPTY
45243: LIST
45244: LIST
45245: PUSH
45246: EMPTY
45247: LIST
45248: LIST
45249: LIST
45250: LIST
45251: LIST
45252: LIST
45253: LIST
45254: LIST
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: LIST
45261: LIST
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: LIST
45271: LIST
45272: LIST
45273: LIST
45274: LIST
45275: LIST
45276: LIST
45277: LIST
45278: LIST
45279: LIST
45280: LIST
45281: LIST
45282: LIST
45283: LIST
45284: LIST
45285: LIST
45286: LIST
45287: LIST
45288: LIST
45289: LIST
45290: LIST
45291: LIST
45292: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45293: LD_ADDR_VAR 0 33
45297: PUSH
45298: LD_INT 4
45300: NEG
45301: PUSH
45302: LD_INT 4
45304: NEG
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: PUSH
45310: LD_INT 4
45312: NEG
45313: PUSH
45314: LD_INT 5
45316: NEG
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PUSH
45322: LD_INT 3
45324: NEG
45325: PUSH
45326: LD_INT 4
45328: NEG
45329: PUSH
45330: EMPTY
45331: LIST
45332: LIST
45333: PUSH
45334: LD_INT 3
45336: NEG
45337: PUSH
45338: LD_INT 3
45340: NEG
45341: PUSH
45342: EMPTY
45343: LIST
45344: LIST
45345: PUSH
45346: LD_INT 4
45348: NEG
45349: PUSH
45350: LD_INT 3
45352: NEG
45353: PUSH
45354: EMPTY
45355: LIST
45356: LIST
45357: PUSH
45358: LD_INT 5
45360: NEG
45361: PUSH
45362: LD_INT 4
45364: NEG
45365: PUSH
45366: EMPTY
45367: LIST
45368: LIST
45369: PUSH
45370: LD_INT 5
45372: NEG
45373: PUSH
45374: LD_INT 5
45376: NEG
45377: PUSH
45378: EMPTY
45379: LIST
45380: LIST
45381: PUSH
45382: LD_INT 3
45384: NEG
45385: PUSH
45386: LD_INT 5
45388: NEG
45389: PUSH
45390: EMPTY
45391: LIST
45392: LIST
45393: PUSH
45394: LD_INT 5
45396: NEG
45397: PUSH
45398: LD_INT 3
45400: NEG
45401: PUSH
45402: EMPTY
45403: LIST
45404: LIST
45405: PUSH
45406: LD_INT 0
45408: PUSH
45409: LD_INT 3
45411: NEG
45412: PUSH
45413: EMPTY
45414: LIST
45415: LIST
45416: PUSH
45417: LD_INT 0
45419: PUSH
45420: LD_INT 4
45422: NEG
45423: PUSH
45424: EMPTY
45425: LIST
45426: LIST
45427: PUSH
45428: LD_INT 1
45430: PUSH
45431: LD_INT 3
45433: NEG
45434: PUSH
45435: EMPTY
45436: LIST
45437: LIST
45438: PUSH
45439: LD_INT 1
45441: PUSH
45442: LD_INT 2
45444: NEG
45445: PUSH
45446: EMPTY
45447: LIST
45448: LIST
45449: PUSH
45450: LD_INT 0
45452: PUSH
45453: LD_INT 2
45455: NEG
45456: PUSH
45457: EMPTY
45458: LIST
45459: LIST
45460: PUSH
45461: LD_INT 1
45463: NEG
45464: PUSH
45465: LD_INT 3
45467: NEG
45468: PUSH
45469: EMPTY
45470: LIST
45471: LIST
45472: PUSH
45473: LD_INT 1
45475: NEG
45476: PUSH
45477: LD_INT 4
45479: NEG
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: PUSH
45485: LD_INT 2
45487: PUSH
45488: LD_INT 2
45490: NEG
45491: PUSH
45492: EMPTY
45493: LIST
45494: LIST
45495: PUSH
45496: LD_INT 2
45498: NEG
45499: PUSH
45500: LD_INT 4
45502: NEG
45503: PUSH
45504: EMPTY
45505: LIST
45506: LIST
45507: PUSH
45508: LD_INT 4
45510: PUSH
45511: LD_INT 0
45513: PUSH
45514: EMPTY
45515: LIST
45516: LIST
45517: PUSH
45518: LD_INT 4
45520: PUSH
45521: LD_INT 1
45523: NEG
45524: PUSH
45525: EMPTY
45526: LIST
45527: LIST
45528: PUSH
45529: LD_INT 5
45531: PUSH
45532: LD_INT 0
45534: PUSH
45535: EMPTY
45536: LIST
45537: LIST
45538: PUSH
45539: LD_INT 5
45541: PUSH
45542: LD_INT 1
45544: PUSH
45545: EMPTY
45546: LIST
45547: LIST
45548: PUSH
45549: LD_INT 4
45551: PUSH
45552: LD_INT 1
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: LD_INT 3
45561: PUSH
45562: LD_INT 0
45564: PUSH
45565: EMPTY
45566: LIST
45567: LIST
45568: PUSH
45569: LD_INT 3
45571: PUSH
45572: LD_INT 1
45574: NEG
45575: PUSH
45576: EMPTY
45577: LIST
45578: LIST
45579: PUSH
45580: LD_INT 3
45582: PUSH
45583: LD_INT 2
45585: NEG
45586: PUSH
45587: EMPTY
45588: LIST
45589: LIST
45590: PUSH
45591: LD_INT 5
45593: PUSH
45594: LD_INT 2
45596: PUSH
45597: EMPTY
45598: LIST
45599: LIST
45600: PUSH
45601: LD_INT 3
45603: PUSH
45604: LD_INT 3
45606: PUSH
45607: EMPTY
45608: LIST
45609: LIST
45610: PUSH
45611: LD_INT 3
45613: PUSH
45614: LD_INT 2
45616: PUSH
45617: EMPTY
45618: LIST
45619: LIST
45620: PUSH
45621: LD_INT 4
45623: PUSH
45624: LD_INT 3
45626: PUSH
45627: EMPTY
45628: LIST
45629: LIST
45630: PUSH
45631: LD_INT 4
45633: PUSH
45634: LD_INT 4
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: PUSH
45641: LD_INT 3
45643: PUSH
45644: LD_INT 4
45646: PUSH
45647: EMPTY
45648: LIST
45649: LIST
45650: PUSH
45651: LD_INT 2
45653: PUSH
45654: LD_INT 3
45656: PUSH
45657: EMPTY
45658: LIST
45659: LIST
45660: PUSH
45661: LD_INT 2
45663: PUSH
45664: LD_INT 2
45666: PUSH
45667: EMPTY
45668: LIST
45669: LIST
45670: PUSH
45671: LD_INT 4
45673: PUSH
45674: LD_INT 2
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: LD_INT 2
45683: PUSH
45684: LD_INT 4
45686: PUSH
45687: EMPTY
45688: LIST
45689: LIST
45690: PUSH
45691: LD_INT 0
45693: PUSH
45694: LD_INT 4
45696: PUSH
45697: EMPTY
45698: LIST
45699: LIST
45700: PUSH
45701: LD_INT 0
45703: PUSH
45704: LD_INT 3
45706: PUSH
45707: EMPTY
45708: LIST
45709: LIST
45710: PUSH
45711: LD_INT 1
45713: PUSH
45714: LD_INT 4
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: PUSH
45721: LD_INT 1
45723: PUSH
45724: LD_INT 5
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: PUSH
45731: LD_INT 0
45733: PUSH
45734: LD_INT 5
45736: PUSH
45737: EMPTY
45738: LIST
45739: LIST
45740: PUSH
45741: LD_INT 1
45743: NEG
45744: PUSH
45745: LD_INT 4
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PUSH
45752: LD_INT 1
45754: NEG
45755: PUSH
45756: LD_INT 3
45758: PUSH
45759: EMPTY
45760: LIST
45761: LIST
45762: PUSH
45763: LD_INT 2
45765: PUSH
45766: LD_INT 5
45768: PUSH
45769: EMPTY
45770: LIST
45771: LIST
45772: PUSH
45773: LD_INT 2
45775: NEG
45776: PUSH
45777: LD_INT 3
45779: PUSH
45780: EMPTY
45781: LIST
45782: LIST
45783: PUSH
45784: EMPTY
45785: LIST
45786: LIST
45787: LIST
45788: LIST
45789: LIST
45790: LIST
45791: LIST
45792: LIST
45793: LIST
45794: LIST
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: LIST
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: LIST
45810: LIST
45811: LIST
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: LIST
45824: LIST
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: LIST
45830: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45831: LD_ADDR_VAR 0 34
45835: PUSH
45836: LD_INT 0
45838: PUSH
45839: LD_INT 4
45841: NEG
45842: PUSH
45843: EMPTY
45844: LIST
45845: LIST
45846: PUSH
45847: LD_INT 0
45849: PUSH
45850: LD_INT 5
45852: NEG
45853: PUSH
45854: EMPTY
45855: LIST
45856: LIST
45857: PUSH
45858: LD_INT 1
45860: PUSH
45861: LD_INT 4
45863: NEG
45864: PUSH
45865: EMPTY
45866: LIST
45867: LIST
45868: PUSH
45869: LD_INT 1
45871: PUSH
45872: LD_INT 3
45874: NEG
45875: PUSH
45876: EMPTY
45877: LIST
45878: LIST
45879: PUSH
45880: LD_INT 0
45882: PUSH
45883: LD_INT 3
45885: NEG
45886: PUSH
45887: EMPTY
45888: LIST
45889: LIST
45890: PUSH
45891: LD_INT 1
45893: NEG
45894: PUSH
45895: LD_INT 4
45897: NEG
45898: PUSH
45899: EMPTY
45900: LIST
45901: LIST
45902: PUSH
45903: LD_INT 1
45905: NEG
45906: PUSH
45907: LD_INT 5
45909: NEG
45910: PUSH
45911: EMPTY
45912: LIST
45913: LIST
45914: PUSH
45915: LD_INT 2
45917: PUSH
45918: LD_INT 3
45920: NEG
45921: PUSH
45922: EMPTY
45923: LIST
45924: LIST
45925: PUSH
45926: LD_INT 2
45928: NEG
45929: PUSH
45930: LD_INT 5
45932: NEG
45933: PUSH
45934: EMPTY
45935: LIST
45936: LIST
45937: PUSH
45938: LD_INT 3
45940: PUSH
45941: LD_INT 0
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: PUSH
45948: LD_INT 3
45950: PUSH
45951: LD_INT 1
45953: NEG
45954: PUSH
45955: EMPTY
45956: LIST
45957: LIST
45958: PUSH
45959: LD_INT 4
45961: PUSH
45962: LD_INT 0
45964: PUSH
45965: EMPTY
45966: LIST
45967: LIST
45968: PUSH
45969: LD_INT 4
45971: PUSH
45972: LD_INT 1
45974: PUSH
45975: EMPTY
45976: LIST
45977: LIST
45978: PUSH
45979: LD_INT 3
45981: PUSH
45982: LD_INT 1
45984: PUSH
45985: EMPTY
45986: LIST
45987: LIST
45988: PUSH
45989: LD_INT 2
45991: PUSH
45992: LD_INT 0
45994: PUSH
45995: EMPTY
45996: LIST
45997: LIST
45998: PUSH
45999: LD_INT 2
46001: PUSH
46002: LD_INT 1
46004: NEG
46005: PUSH
46006: EMPTY
46007: LIST
46008: LIST
46009: PUSH
46010: LD_INT 2
46012: PUSH
46013: LD_INT 2
46015: NEG
46016: PUSH
46017: EMPTY
46018: LIST
46019: LIST
46020: PUSH
46021: LD_INT 4
46023: PUSH
46024: LD_INT 2
46026: PUSH
46027: EMPTY
46028: LIST
46029: LIST
46030: PUSH
46031: LD_INT 4
46033: PUSH
46034: LD_INT 4
46036: PUSH
46037: EMPTY
46038: LIST
46039: LIST
46040: PUSH
46041: LD_INT 4
46043: PUSH
46044: LD_INT 3
46046: PUSH
46047: EMPTY
46048: LIST
46049: LIST
46050: PUSH
46051: LD_INT 5
46053: PUSH
46054: LD_INT 4
46056: PUSH
46057: EMPTY
46058: LIST
46059: LIST
46060: PUSH
46061: LD_INT 5
46063: PUSH
46064: LD_INT 5
46066: PUSH
46067: EMPTY
46068: LIST
46069: LIST
46070: PUSH
46071: LD_INT 4
46073: PUSH
46074: LD_INT 5
46076: PUSH
46077: EMPTY
46078: LIST
46079: LIST
46080: PUSH
46081: LD_INT 3
46083: PUSH
46084: LD_INT 4
46086: PUSH
46087: EMPTY
46088: LIST
46089: LIST
46090: PUSH
46091: LD_INT 3
46093: PUSH
46094: LD_INT 3
46096: PUSH
46097: EMPTY
46098: LIST
46099: LIST
46100: PUSH
46101: LD_INT 5
46103: PUSH
46104: LD_INT 3
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 3
46113: PUSH
46114: LD_INT 5
46116: PUSH
46117: EMPTY
46118: LIST
46119: LIST
46120: PUSH
46121: LD_INT 0
46123: PUSH
46124: LD_INT 3
46126: PUSH
46127: EMPTY
46128: LIST
46129: LIST
46130: PUSH
46131: LD_INT 0
46133: PUSH
46134: LD_INT 2
46136: PUSH
46137: EMPTY
46138: LIST
46139: LIST
46140: PUSH
46141: LD_INT 1
46143: PUSH
46144: LD_INT 3
46146: PUSH
46147: EMPTY
46148: LIST
46149: LIST
46150: PUSH
46151: LD_INT 1
46153: PUSH
46154: LD_INT 4
46156: PUSH
46157: EMPTY
46158: LIST
46159: LIST
46160: PUSH
46161: LD_INT 0
46163: PUSH
46164: LD_INT 4
46166: PUSH
46167: EMPTY
46168: LIST
46169: LIST
46170: PUSH
46171: LD_INT 1
46173: NEG
46174: PUSH
46175: LD_INT 3
46177: PUSH
46178: EMPTY
46179: LIST
46180: LIST
46181: PUSH
46182: LD_INT 1
46184: NEG
46185: PUSH
46186: LD_INT 2
46188: PUSH
46189: EMPTY
46190: LIST
46191: LIST
46192: PUSH
46193: LD_INT 2
46195: PUSH
46196: LD_INT 4
46198: PUSH
46199: EMPTY
46200: LIST
46201: LIST
46202: PUSH
46203: LD_INT 2
46205: NEG
46206: PUSH
46207: LD_INT 2
46209: PUSH
46210: EMPTY
46211: LIST
46212: LIST
46213: PUSH
46214: LD_INT 4
46216: NEG
46217: PUSH
46218: LD_INT 0
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: PUSH
46225: LD_INT 4
46227: NEG
46228: PUSH
46229: LD_INT 1
46231: NEG
46232: PUSH
46233: EMPTY
46234: LIST
46235: LIST
46236: PUSH
46237: LD_INT 3
46239: NEG
46240: PUSH
46241: LD_INT 0
46243: PUSH
46244: EMPTY
46245: LIST
46246: LIST
46247: PUSH
46248: LD_INT 3
46250: NEG
46251: PUSH
46252: LD_INT 1
46254: PUSH
46255: EMPTY
46256: LIST
46257: LIST
46258: PUSH
46259: LD_INT 4
46261: NEG
46262: PUSH
46263: LD_INT 1
46265: PUSH
46266: EMPTY
46267: LIST
46268: LIST
46269: PUSH
46270: LD_INT 5
46272: NEG
46273: PUSH
46274: LD_INT 0
46276: PUSH
46277: EMPTY
46278: LIST
46279: LIST
46280: PUSH
46281: LD_INT 5
46283: NEG
46284: PUSH
46285: LD_INT 1
46287: NEG
46288: PUSH
46289: EMPTY
46290: LIST
46291: LIST
46292: PUSH
46293: LD_INT 5
46295: NEG
46296: PUSH
46297: LD_INT 2
46299: NEG
46300: PUSH
46301: EMPTY
46302: LIST
46303: LIST
46304: PUSH
46305: LD_INT 3
46307: NEG
46308: PUSH
46309: LD_INT 2
46311: PUSH
46312: EMPTY
46313: LIST
46314: LIST
46315: PUSH
46316: EMPTY
46317: LIST
46318: LIST
46319: LIST
46320: LIST
46321: LIST
46322: LIST
46323: LIST
46324: LIST
46325: LIST
46326: LIST
46327: LIST
46328: LIST
46329: LIST
46330: LIST
46331: LIST
46332: LIST
46333: LIST
46334: LIST
46335: LIST
46336: LIST
46337: LIST
46338: LIST
46339: LIST
46340: LIST
46341: LIST
46342: LIST
46343: LIST
46344: LIST
46345: LIST
46346: LIST
46347: LIST
46348: LIST
46349: LIST
46350: LIST
46351: LIST
46352: LIST
46353: LIST
46354: LIST
46355: LIST
46356: LIST
46357: LIST
46358: LIST
46359: LIST
46360: LIST
46361: LIST
46362: ST_TO_ADDR
// end ; end ;
46363: GO 46366
46365: POP
// case btype of b_depot , b_warehouse :
46366: LD_VAR 0 1
46370: PUSH
46371: LD_INT 0
46373: DOUBLE
46374: EQUAL
46375: IFTRUE 46385
46377: LD_INT 1
46379: DOUBLE
46380: EQUAL
46381: IFTRUE 46385
46383: GO 46586
46385: POP
// case nation of nation_american :
46386: LD_VAR 0 5
46390: PUSH
46391: LD_INT 1
46393: DOUBLE
46394: EQUAL
46395: IFTRUE 46399
46397: GO 46455
46399: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
46400: LD_ADDR_VAR 0 9
46404: PUSH
46405: LD_VAR 0 11
46409: PUSH
46410: LD_VAR 0 12
46414: PUSH
46415: LD_VAR 0 13
46419: PUSH
46420: LD_VAR 0 14
46424: PUSH
46425: LD_VAR 0 15
46429: PUSH
46430: LD_VAR 0 16
46434: PUSH
46435: EMPTY
46436: LIST
46437: LIST
46438: LIST
46439: LIST
46440: LIST
46441: LIST
46442: PUSH
46443: LD_VAR 0 4
46447: PUSH
46448: LD_INT 1
46450: PLUS
46451: ARRAY
46452: ST_TO_ADDR
46453: GO 46584
46455: LD_INT 2
46457: DOUBLE
46458: EQUAL
46459: IFTRUE 46463
46461: GO 46519
46463: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
46464: LD_ADDR_VAR 0 9
46468: PUSH
46469: LD_VAR 0 17
46473: PUSH
46474: LD_VAR 0 18
46478: PUSH
46479: LD_VAR 0 19
46483: PUSH
46484: LD_VAR 0 20
46488: PUSH
46489: LD_VAR 0 21
46493: PUSH
46494: LD_VAR 0 22
46498: PUSH
46499: EMPTY
46500: LIST
46501: LIST
46502: LIST
46503: LIST
46504: LIST
46505: LIST
46506: PUSH
46507: LD_VAR 0 4
46511: PUSH
46512: LD_INT 1
46514: PLUS
46515: ARRAY
46516: ST_TO_ADDR
46517: GO 46584
46519: LD_INT 3
46521: DOUBLE
46522: EQUAL
46523: IFTRUE 46527
46525: GO 46583
46527: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46528: LD_ADDR_VAR 0 9
46532: PUSH
46533: LD_VAR 0 23
46537: PUSH
46538: LD_VAR 0 24
46542: PUSH
46543: LD_VAR 0 25
46547: PUSH
46548: LD_VAR 0 26
46552: PUSH
46553: LD_VAR 0 27
46557: PUSH
46558: LD_VAR 0 28
46562: PUSH
46563: EMPTY
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: LIST
46569: LIST
46570: PUSH
46571: LD_VAR 0 4
46575: PUSH
46576: LD_INT 1
46578: PLUS
46579: ARRAY
46580: ST_TO_ADDR
46581: GO 46584
46583: POP
46584: GO 47139
46586: LD_INT 2
46588: DOUBLE
46589: EQUAL
46590: IFTRUE 46600
46592: LD_INT 3
46594: DOUBLE
46595: EQUAL
46596: IFTRUE 46600
46598: GO 46656
46600: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46601: LD_ADDR_VAR 0 9
46605: PUSH
46606: LD_VAR 0 29
46610: PUSH
46611: LD_VAR 0 30
46615: PUSH
46616: LD_VAR 0 31
46620: PUSH
46621: LD_VAR 0 32
46625: PUSH
46626: LD_VAR 0 33
46630: PUSH
46631: LD_VAR 0 34
46635: PUSH
46636: EMPTY
46637: LIST
46638: LIST
46639: LIST
46640: LIST
46641: LIST
46642: LIST
46643: PUSH
46644: LD_VAR 0 4
46648: PUSH
46649: LD_INT 1
46651: PLUS
46652: ARRAY
46653: ST_TO_ADDR
46654: GO 47139
46656: LD_INT 16
46658: DOUBLE
46659: EQUAL
46660: IFTRUE 46718
46662: LD_INT 17
46664: DOUBLE
46665: EQUAL
46666: IFTRUE 46718
46668: LD_INT 18
46670: DOUBLE
46671: EQUAL
46672: IFTRUE 46718
46674: LD_INT 19
46676: DOUBLE
46677: EQUAL
46678: IFTRUE 46718
46680: LD_INT 22
46682: DOUBLE
46683: EQUAL
46684: IFTRUE 46718
46686: LD_INT 20
46688: DOUBLE
46689: EQUAL
46690: IFTRUE 46718
46692: LD_INT 21
46694: DOUBLE
46695: EQUAL
46696: IFTRUE 46718
46698: LD_INT 23
46700: DOUBLE
46701: EQUAL
46702: IFTRUE 46718
46704: LD_INT 24
46706: DOUBLE
46707: EQUAL
46708: IFTRUE 46718
46710: LD_INT 25
46712: DOUBLE
46713: EQUAL
46714: IFTRUE 46718
46716: GO 46774
46718: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46719: LD_ADDR_VAR 0 9
46723: PUSH
46724: LD_VAR 0 35
46728: PUSH
46729: LD_VAR 0 36
46733: PUSH
46734: LD_VAR 0 37
46738: PUSH
46739: LD_VAR 0 38
46743: PUSH
46744: LD_VAR 0 39
46748: PUSH
46749: LD_VAR 0 40
46753: PUSH
46754: EMPTY
46755: LIST
46756: LIST
46757: LIST
46758: LIST
46759: LIST
46760: LIST
46761: PUSH
46762: LD_VAR 0 4
46766: PUSH
46767: LD_INT 1
46769: PLUS
46770: ARRAY
46771: ST_TO_ADDR
46772: GO 47139
46774: LD_INT 6
46776: DOUBLE
46777: EQUAL
46778: IFTRUE 46830
46780: LD_INT 7
46782: DOUBLE
46783: EQUAL
46784: IFTRUE 46830
46786: LD_INT 8
46788: DOUBLE
46789: EQUAL
46790: IFTRUE 46830
46792: LD_INT 13
46794: DOUBLE
46795: EQUAL
46796: IFTRUE 46830
46798: LD_INT 12
46800: DOUBLE
46801: EQUAL
46802: IFTRUE 46830
46804: LD_INT 15
46806: DOUBLE
46807: EQUAL
46808: IFTRUE 46830
46810: LD_INT 11
46812: DOUBLE
46813: EQUAL
46814: IFTRUE 46830
46816: LD_INT 14
46818: DOUBLE
46819: EQUAL
46820: IFTRUE 46830
46822: LD_INT 10
46824: DOUBLE
46825: EQUAL
46826: IFTRUE 46830
46828: GO 46886
46830: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
46831: LD_ADDR_VAR 0 9
46835: PUSH
46836: LD_VAR 0 41
46840: PUSH
46841: LD_VAR 0 42
46845: PUSH
46846: LD_VAR 0 43
46850: PUSH
46851: LD_VAR 0 44
46855: PUSH
46856: LD_VAR 0 45
46860: PUSH
46861: LD_VAR 0 46
46865: PUSH
46866: EMPTY
46867: LIST
46868: LIST
46869: LIST
46870: LIST
46871: LIST
46872: LIST
46873: PUSH
46874: LD_VAR 0 4
46878: PUSH
46879: LD_INT 1
46881: PLUS
46882: ARRAY
46883: ST_TO_ADDR
46884: GO 47139
46886: LD_INT 36
46888: DOUBLE
46889: EQUAL
46890: IFTRUE 46894
46892: GO 46950
46894: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46895: LD_ADDR_VAR 0 9
46899: PUSH
46900: LD_VAR 0 47
46904: PUSH
46905: LD_VAR 0 48
46909: PUSH
46910: LD_VAR 0 49
46914: PUSH
46915: LD_VAR 0 50
46919: PUSH
46920: LD_VAR 0 51
46924: PUSH
46925: LD_VAR 0 52
46929: PUSH
46930: EMPTY
46931: LIST
46932: LIST
46933: LIST
46934: LIST
46935: LIST
46936: LIST
46937: PUSH
46938: LD_VAR 0 4
46942: PUSH
46943: LD_INT 1
46945: PLUS
46946: ARRAY
46947: ST_TO_ADDR
46948: GO 47139
46950: LD_INT 4
46952: DOUBLE
46953: EQUAL
46954: IFTRUE 46976
46956: LD_INT 5
46958: DOUBLE
46959: EQUAL
46960: IFTRUE 46976
46962: LD_INT 34
46964: DOUBLE
46965: EQUAL
46966: IFTRUE 46976
46968: LD_INT 37
46970: DOUBLE
46971: EQUAL
46972: IFTRUE 46976
46974: GO 47032
46976: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
46977: LD_ADDR_VAR 0 9
46981: PUSH
46982: LD_VAR 0 53
46986: PUSH
46987: LD_VAR 0 54
46991: PUSH
46992: LD_VAR 0 55
46996: PUSH
46997: LD_VAR 0 56
47001: PUSH
47002: LD_VAR 0 57
47006: PUSH
47007: LD_VAR 0 58
47011: PUSH
47012: EMPTY
47013: LIST
47014: LIST
47015: LIST
47016: LIST
47017: LIST
47018: LIST
47019: PUSH
47020: LD_VAR 0 4
47024: PUSH
47025: LD_INT 1
47027: PLUS
47028: ARRAY
47029: ST_TO_ADDR
47030: GO 47139
47032: LD_INT 31
47034: DOUBLE
47035: EQUAL
47036: IFTRUE 47082
47038: LD_INT 32
47040: DOUBLE
47041: EQUAL
47042: IFTRUE 47082
47044: LD_INT 33
47046: DOUBLE
47047: EQUAL
47048: IFTRUE 47082
47050: LD_INT 27
47052: DOUBLE
47053: EQUAL
47054: IFTRUE 47082
47056: LD_INT 26
47058: DOUBLE
47059: EQUAL
47060: IFTRUE 47082
47062: LD_INT 28
47064: DOUBLE
47065: EQUAL
47066: IFTRUE 47082
47068: LD_INT 29
47070: DOUBLE
47071: EQUAL
47072: IFTRUE 47082
47074: LD_INT 30
47076: DOUBLE
47077: EQUAL
47078: IFTRUE 47082
47080: GO 47138
47082: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
47083: LD_ADDR_VAR 0 9
47087: PUSH
47088: LD_VAR 0 59
47092: PUSH
47093: LD_VAR 0 60
47097: PUSH
47098: LD_VAR 0 61
47102: PUSH
47103: LD_VAR 0 62
47107: PUSH
47108: LD_VAR 0 63
47112: PUSH
47113: LD_VAR 0 64
47117: PUSH
47118: EMPTY
47119: LIST
47120: LIST
47121: LIST
47122: LIST
47123: LIST
47124: LIST
47125: PUSH
47126: LD_VAR 0 4
47130: PUSH
47131: LD_INT 1
47133: PLUS
47134: ARRAY
47135: ST_TO_ADDR
47136: GO 47139
47138: POP
// temp_list2 = [ ] ;
47139: LD_ADDR_VAR 0 10
47143: PUSH
47144: EMPTY
47145: ST_TO_ADDR
// for i in temp_list do
47146: LD_ADDR_VAR 0 8
47150: PUSH
47151: LD_VAR 0 9
47155: PUSH
47156: FOR_IN
47157: IFFALSE 47209
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47159: LD_ADDR_VAR 0 10
47163: PUSH
47164: LD_VAR 0 10
47168: PUSH
47169: LD_VAR 0 8
47173: PUSH
47174: LD_INT 1
47176: ARRAY
47177: PUSH
47178: LD_VAR 0 2
47182: PLUS
47183: PUSH
47184: LD_VAR 0 8
47188: PUSH
47189: LD_INT 2
47191: ARRAY
47192: PUSH
47193: LD_VAR 0 3
47197: PLUS
47198: PUSH
47199: EMPTY
47200: LIST
47201: LIST
47202: PUSH
47203: EMPTY
47204: LIST
47205: ADD
47206: ST_TO_ADDR
47207: GO 47156
47209: POP
47210: POP
// result = temp_list2 ;
47211: LD_ADDR_VAR 0 7
47215: PUSH
47216: LD_VAR 0 10
47220: ST_TO_ADDR
// end ;
47221: LD_VAR 0 7
47225: RET
// export function EnemyInRange ( unit , dist ) ; begin
47226: LD_INT 0
47228: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47229: LD_ADDR_VAR 0 3
47233: PUSH
47234: LD_VAR 0 1
47238: PPUSH
47239: CALL_OW 255
47243: PPUSH
47244: LD_VAR 0 1
47248: PPUSH
47249: CALL_OW 250
47253: PPUSH
47254: LD_VAR 0 1
47258: PPUSH
47259: CALL_OW 251
47263: PPUSH
47264: LD_VAR 0 2
47268: PPUSH
47269: CALL 20622 0 4
47273: PUSH
47274: LD_INT 4
47276: ARRAY
47277: ST_TO_ADDR
// end ;
47278: LD_VAR 0 3
47282: RET
// export function PlayerSeeMe ( unit ) ; begin
47283: LD_INT 0
47285: PPUSH
// result := See ( your_side , unit ) ;
47286: LD_ADDR_VAR 0 2
47290: PUSH
47291: LD_OWVAR 2
47295: PPUSH
47296: LD_VAR 0 1
47300: PPUSH
47301: CALL_OW 292
47305: ST_TO_ADDR
// end ;
47306: LD_VAR 0 2
47310: RET
// export function ReverseDir ( unit ) ; begin
47311: LD_INT 0
47313: PPUSH
// if not unit then
47314: LD_VAR 0 1
47318: NOT
47319: IFFALSE 47323
// exit ;
47321: GO 47346
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
47323: LD_ADDR_VAR 0 2
47327: PUSH
47328: LD_VAR 0 1
47332: PPUSH
47333: CALL_OW 254
47337: PUSH
47338: LD_INT 3
47340: PLUS
47341: PUSH
47342: LD_INT 6
47344: MOD
47345: ST_TO_ADDR
// end ;
47346: LD_VAR 0 2
47350: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47351: LD_INT 0
47353: PPUSH
47354: PPUSH
47355: PPUSH
47356: PPUSH
47357: PPUSH
// if not hexes then
47358: LD_VAR 0 2
47362: NOT
47363: IFFALSE 47367
// exit ;
47365: GO 47515
// dist := 9999 ;
47367: LD_ADDR_VAR 0 5
47371: PUSH
47372: LD_INT 9999
47374: ST_TO_ADDR
// for i = 1 to hexes do
47375: LD_ADDR_VAR 0 4
47379: PUSH
47380: DOUBLE
47381: LD_INT 1
47383: DEC
47384: ST_TO_ADDR
47385: LD_VAR 0 2
47389: PUSH
47390: FOR_TO
47391: IFFALSE 47503
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47393: LD_VAR 0 1
47397: PPUSH
47398: LD_VAR 0 2
47402: PUSH
47403: LD_VAR 0 4
47407: ARRAY
47408: PUSH
47409: LD_INT 1
47411: ARRAY
47412: PPUSH
47413: LD_VAR 0 2
47417: PUSH
47418: LD_VAR 0 4
47422: ARRAY
47423: PUSH
47424: LD_INT 2
47426: ARRAY
47427: PPUSH
47428: CALL_OW 297
47432: PUSH
47433: LD_VAR 0 5
47437: LESS
47438: IFFALSE 47501
// begin hex := hexes [ i ] ;
47440: LD_ADDR_VAR 0 7
47444: PUSH
47445: LD_VAR 0 2
47449: PUSH
47450: LD_VAR 0 4
47454: ARRAY
47455: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47456: LD_ADDR_VAR 0 5
47460: PUSH
47461: LD_VAR 0 1
47465: PPUSH
47466: LD_VAR 0 2
47470: PUSH
47471: LD_VAR 0 4
47475: ARRAY
47476: PUSH
47477: LD_INT 1
47479: ARRAY
47480: PPUSH
47481: LD_VAR 0 2
47485: PUSH
47486: LD_VAR 0 4
47490: ARRAY
47491: PUSH
47492: LD_INT 2
47494: ARRAY
47495: PPUSH
47496: CALL_OW 297
47500: ST_TO_ADDR
// end ; end ;
47501: GO 47390
47503: POP
47504: POP
// result := hex ;
47505: LD_ADDR_VAR 0 3
47509: PUSH
47510: LD_VAR 0 7
47514: ST_TO_ADDR
// end ;
47515: LD_VAR 0 3
47519: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47520: LD_INT 0
47522: PPUSH
47523: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47524: LD_VAR 0 1
47528: NOT
47529: PUSH
47530: LD_VAR 0 1
47534: PUSH
47535: LD_INT 21
47537: PUSH
47538: LD_INT 2
47540: PUSH
47541: EMPTY
47542: LIST
47543: LIST
47544: PUSH
47545: LD_INT 23
47547: PUSH
47548: LD_INT 2
47550: PUSH
47551: EMPTY
47552: LIST
47553: LIST
47554: PUSH
47555: EMPTY
47556: LIST
47557: LIST
47558: PPUSH
47559: CALL_OW 69
47563: IN
47564: NOT
47565: OR
47566: IFFALSE 47570
// exit ;
47568: GO 47617
// for i = 1 to 3 do
47570: LD_ADDR_VAR 0 3
47574: PUSH
47575: DOUBLE
47576: LD_INT 1
47578: DEC
47579: ST_TO_ADDR
47580: LD_INT 3
47582: PUSH
47583: FOR_TO
47584: IFFALSE 47615
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47586: LD_VAR 0 1
47590: PPUSH
47591: CALL_OW 250
47595: PPUSH
47596: LD_VAR 0 1
47600: PPUSH
47601: CALL_OW 251
47605: PPUSH
47606: LD_INT 1
47608: PPUSH
47609: CALL_OW 453
47613: GO 47583
47615: POP
47616: POP
// end ;
47617: LD_VAR 0 2
47621: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47622: LD_INT 0
47624: PPUSH
47625: PPUSH
47626: PPUSH
47627: PPUSH
47628: PPUSH
47629: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47630: LD_VAR 0 1
47634: NOT
47635: PUSH
47636: LD_VAR 0 2
47640: NOT
47641: OR
47642: PUSH
47643: LD_VAR 0 1
47647: PPUSH
47648: CALL_OW 314
47652: OR
47653: IFFALSE 47657
// exit ;
47655: GO 48098
// x := GetX ( enemy_unit ) ;
47657: LD_ADDR_VAR 0 7
47661: PUSH
47662: LD_VAR 0 2
47666: PPUSH
47667: CALL_OW 250
47671: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47672: LD_ADDR_VAR 0 8
47676: PUSH
47677: LD_VAR 0 2
47681: PPUSH
47682: CALL_OW 251
47686: ST_TO_ADDR
// if not x or not y then
47687: LD_VAR 0 7
47691: NOT
47692: PUSH
47693: LD_VAR 0 8
47697: NOT
47698: OR
47699: IFFALSE 47703
// exit ;
47701: GO 48098
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47703: LD_ADDR_VAR 0 6
47707: PUSH
47708: LD_VAR 0 7
47712: PPUSH
47713: LD_INT 0
47715: PPUSH
47716: LD_INT 4
47718: PPUSH
47719: CALL_OW 272
47723: PUSH
47724: LD_VAR 0 8
47728: PPUSH
47729: LD_INT 0
47731: PPUSH
47732: LD_INT 4
47734: PPUSH
47735: CALL_OW 273
47739: PUSH
47740: EMPTY
47741: LIST
47742: LIST
47743: PUSH
47744: LD_VAR 0 7
47748: PPUSH
47749: LD_INT 1
47751: PPUSH
47752: LD_INT 4
47754: PPUSH
47755: CALL_OW 272
47759: PUSH
47760: LD_VAR 0 8
47764: PPUSH
47765: LD_INT 1
47767: PPUSH
47768: LD_INT 4
47770: PPUSH
47771: CALL_OW 273
47775: PUSH
47776: EMPTY
47777: LIST
47778: LIST
47779: PUSH
47780: LD_VAR 0 7
47784: PPUSH
47785: LD_INT 2
47787: PPUSH
47788: LD_INT 4
47790: PPUSH
47791: CALL_OW 272
47795: PUSH
47796: LD_VAR 0 8
47800: PPUSH
47801: LD_INT 2
47803: PPUSH
47804: LD_INT 4
47806: PPUSH
47807: CALL_OW 273
47811: PUSH
47812: EMPTY
47813: LIST
47814: LIST
47815: PUSH
47816: LD_VAR 0 7
47820: PPUSH
47821: LD_INT 3
47823: PPUSH
47824: LD_INT 4
47826: PPUSH
47827: CALL_OW 272
47831: PUSH
47832: LD_VAR 0 8
47836: PPUSH
47837: LD_INT 3
47839: PPUSH
47840: LD_INT 4
47842: PPUSH
47843: CALL_OW 273
47847: PUSH
47848: EMPTY
47849: LIST
47850: LIST
47851: PUSH
47852: LD_VAR 0 7
47856: PPUSH
47857: LD_INT 4
47859: PPUSH
47860: LD_INT 4
47862: PPUSH
47863: CALL_OW 272
47867: PUSH
47868: LD_VAR 0 8
47872: PPUSH
47873: LD_INT 4
47875: PPUSH
47876: LD_INT 4
47878: PPUSH
47879: CALL_OW 273
47883: PUSH
47884: EMPTY
47885: LIST
47886: LIST
47887: PUSH
47888: LD_VAR 0 7
47892: PPUSH
47893: LD_INT 5
47895: PPUSH
47896: LD_INT 4
47898: PPUSH
47899: CALL_OW 272
47903: PUSH
47904: LD_VAR 0 8
47908: PPUSH
47909: LD_INT 5
47911: PPUSH
47912: LD_INT 4
47914: PPUSH
47915: CALL_OW 273
47919: PUSH
47920: EMPTY
47921: LIST
47922: LIST
47923: PUSH
47924: EMPTY
47925: LIST
47926: LIST
47927: LIST
47928: LIST
47929: LIST
47930: LIST
47931: ST_TO_ADDR
// for i = tmp downto 1 do
47932: LD_ADDR_VAR 0 4
47936: PUSH
47937: DOUBLE
47938: LD_VAR 0 6
47942: INC
47943: ST_TO_ADDR
47944: LD_INT 1
47946: PUSH
47947: FOR_DOWNTO
47948: IFFALSE 48049
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
47950: LD_VAR 0 6
47954: PUSH
47955: LD_VAR 0 4
47959: ARRAY
47960: PUSH
47961: LD_INT 1
47963: ARRAY
47964: PPUSH
47965: LD_VAR 0 6
47969: PUSH
47970: LD_VAR 0 4
47974: ARRAY
47975: PUSH
47976: LD_INT 2
47978: ARRAY
47979: PPUSH
47980: CALL_OW 488
47984: NOT
47985: PUSH
47986: LD_VAR 0 6
47990: PUSH
47991: LD_VAR 0 4
47995: ARRAY
47996: PUSH
47997: LD_INT 1
47999: ARRAY
48000: PPUSH
48001: LD_VAR 0 6
48005: PUSH
48006: LD_VAR 0 4
48010: ARRAY
48011: PUSH
48012: LD_INT 2
48014: ARRAY
48015: PPUSH
48016: CALL_OW 428
48020: PUSH
48021: LD_INT 0
48023: NONEQUAL
48024: OR
48025: IFFALSE 48047
// tmp := Delete ( tmp , i ) ;
48027: LD_ADDR_VAR 0 6
48031: PUSH
48032: LD_VAR 0 6
48036: PPUSH
48037: LD_VAR 0 4
48041: PPUSH
48042: CALL_OW 3
48046: ST_TO_ADDR
48047: GO 47947
48049: POP
48050: POP
// j := GetClosestHex ( unit , tmp ) ;
48051: LD_ADDR_VAR 0 5
48055: PUSH
48056: LD_VAR 0 1
48060: PPUSH
48061: LD_VAR 0 6
48065: PPUSH
48066: CALL 47351 0 2
48070: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48071: LD_VAR 0 1
48075: PPUSH
48076: LD_VAR 0 5
48080: PUSH
48081: LD_INT 1
48083: ARRAY
48084: PPUSH
48085: LD_VAR 0 5
48089: PUSH
48090: LD_INT 2
48092: ARRAY
48093: PPUSH
48094: CALL_OW 111
// end ;
48098: LD_VAR 0 3
48102: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48103: LD_INT 0
48105: PPUSH
48106: PPUSH
48107: PPUSH
// uc_side = 0 ;
48108: LD_ADDR_OWVAR 20
48112: PUSH
48113: LD_INT 0
48115: ST_TO_ADDR
// uc_nation = 0 ;
48116: LD_ADDR_OWVAR 21
48120: PUSH
48121: LD_INT 0
48123: ST_TO_ADDR
// InitHc_All ( ) ;
48124: CALL_OW 584
// InitVc ;
48128: CALL_OW 20
// if mastodonts then
48132: LD_VAR 0 6
48136: IFFALSE 48203
// for i = 1 to mastodonts do
48138: LD_ADDR_VAR 0 11
48142: PUSH
48143: DOUBLE
48144: LD_INT 1
48146: DEC
48147: ST_TO_ADDR
48148: LD_VAR 0 6
48152: PUSH
48153: FOR_TO
48154: IFFALSE 48201
// begin vc_chassis := 31 ;
48156: LD_ADDR_OWVAR 37
48160: PUSH
48161: LD_INT 31
48163: ST_TO_ADDR
// vc_control := control_rider ;
48164: LD_ADDR_OWVAR 38
48168: PUSH
48169: LD_INT 4
48171: ST_TO_ADDR
// animal := CreateVehicle ;
48172: LD_ADDR_VAR 0 12
48176: PUSH
48177: CALL_OW 45
48181: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48182: LD_VAR 0 12
48186: PPUSH
48187: LD_VAR 0 8
48191: PPUSH
48192: LD_INT 0
48194: PPUSH
48195: CALL 50391 0 3
// end ;
48199: GO 48153
48201: POP
48202: POP
// if horses then
48203: LD_VAR 0 5
48207: IFFALSE 48274
// for i = 1 to horses do
48209: LD_ADDR_VAR 0 11
48213: PUSH
48214: DOUBLE
48215: LD_INT 1
48217: DEC
48218: ST_TO_ADDR
48219: LD_VAR 0 5
48223: PUSH
48224: FOR_TO
48225: IFFALSE 48272
// begin hc_class := 21 ;
48227: LD_ADDR_OWVAR 28
48231: PUSH
48232: LD_INT 21
48234: ST_TO_ADDR
// hc_gallery :=  ;
48235: LD_ADDR_OWVAR 33
48239: PUSH
48240: LD_STRING 
48242: ST_TO_ADDR
// animal := CreateHuman ;
48243: LD_ADDR_VAR 0 12
48247: PUSH
48248: CALL_OW 44
48252: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48253: LD_VAR 0 12
48257: PPUSH
48258: LD_VAR 0 8
48262: PPUSH
48263: LD_INT 0
48265: PPUSH
48266: CALL 50391 0 3
// end ;
48270: GO 48224
48272: POP
48273: POP
// if birds then
48274: LD_VAR 0 1
48278: IFFALSE 48345
// for i = 1 to birds do
48280: LD_ADDR_VAR 0 11
48284: PUSH
48285: DOUBLE
48286: LD_INT 1
48288: DEC
48289: ST_TO_ADDR
48290: LD_VAR 0 1
48294: PUSH
48295: FOR_TO
48296: IFFALSE 48343
// begin hc_class = 18 ;
48298: LD_ADDR_OWVAR 28
48302: PUSH
48303: LD_INT 18
48305: ST_TO_ADDR
// hc_gallery =  ;
48306: LD_ADDR_OWVAR 33
48310: PUSH
48311: LD_STRING 
48313: ST_TO_ADDR
// animal := CreateHuman ;
48314: LD_ADDR_VAR 0 12
48318: PUSH
48319: CALL_OW 44
48323: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48324: LD_VAR 0 12
48328: PPUSH
48329: LD_VAR 0 8
48333: PPUSH
48334: LD_INT 0
48336: PPUSH
48337: CALL 50391 0 3
// end ;
48341: GO 48295
48343: POP
48344: POP
// if tigers then
48345: LD_VAR 0 2
48349: IFFALSE 48433
// for i = 1 to tigers do
48351: LD_ADDR_VAR 0 11
48355: PUSH
48356: DOUBLE
48357: LD_INT 1
48359: DEC
48360: ST_TO_ADDR
48361: LD_VAR 0 2
48365: PUSH
48366: FOR_TO
48367: IFFALSE 48431
// begin hc_class = class_tiger ;
48369: LD_ADDR_OWVAR 28
48373: PUSH
48374: LD_INT 14
48376: ST_TO_ADDR
// hc_gallery =  ;
48377: LD_ADDR_OWVAR 33
48381: PUSH
48382: LD_STRING 
48384: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48385: LD_ADDR_OWVAR 35
48389: PUSH
48390: LD_INT 7
48392: NEG
48393: PPUSH
48394: LD_INT 7
48396: PPUSH
48397: CALL_OW 12
48401: ST_TO_ADDR
// animal := CreateHuman ;
48402: LD_ADDR_VAR 0 12
48406: PUSH
48407: CALL_OW 44
48411: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48412: LD_VAR 0 12
48416: PPUSH
48417: LD_VAR 0 8
48421: PPUSH
48422: LD_INT 0
48424: PPUSH
48425: CALL 50391 0 3
// end ;
48429: GO 48366
48431: POP
48432: POP
// if apemans then
48433: LD_VAR 0 3
48437: IFFALSE 48560
// for i = 1 to apemans do
48439: LD_ADDR_VAR 0 11
48443: PUSH
48444: DOUBLE
48445: LD_INT 1
48447: DEC
48448: ST_TO_ADDR
48449: LD_VAR 0 3
48453: PUSH
48454: FOR_TO
48455: IFFALSE 48558
// begin hc_class = class_apeman ;
48457: LD_ADDR_OWVAR 28
48461: PUSH
48462: LD_INT 12
48464: ST_TO_ADDR
// hc_gallery =  ;
48465: LD_ADDR_OWVAR 33
48469: PUSH
48470: LD_STRING 
48472: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
48473: LD_ADDR_OWVAR 35
48477: PUSH
48478: LD_INT 2
48480: NEG
48481: PPUSH
48482: LD_INT 2
48484: PPUSH
48485: CALL_OW 12
48489: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48490: LD_ADDR_OWVAR 31
48494: PUSH
48495: LD_INT 1
48497: PPUSH
48498: LD_INT 3
48500: PPUSH
48501: CALL_OW 12
48505: PUSH
48506: LD_INT 1
48508: PPUSH
48509: LD_INT 3
48511: PPUSH
48512: CALL_OW 12
48516: PUSH
48517: LD_INT 0
48519: PUSH
48520: LD_INT 0
48522: PUSH
48523: EMPTY
48524: LIST
48525: LIST
48526: LIST
48527: LIST
48528: ST_TO_ADDR
// animal := CreateHuman ;
48529: LD_ADDR_VAR 0 12
48533: PUSH
48534: CALL_OW 44
48538: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48539: LD_VAR 0 12
48543: PPUSH
48544: LD_VAR 0 8
48548: PPUSH
48549: LD_INT 0
48551: PPUSH
48552: CALL 50391 0 3
// end ;
48556: GO 48454
48558: POP
48559: POP
// if enchidnas then
48560: LD_VAR 0 4
48564: IFFALSE 48631
// for i = 1 to enchidnas do
48566: LD_ADDR_VAR 0 11
48570: PUSH
48571: DOUBLE
48572: LD_INT 1
48574: DEC
48575: ST_TO_ADDR
48576: LD_VAR 0 4
48580: PUSH
48581: FOR_TO
48582: IFFALSE 48629
// begin hc_class = 13 ;
48584: LD_ADDR_OWVAR 28
48588: PUSH
48589: LD_INT 13
48591: ST_TO_ADDR
// hc_gallery =  ;
48592: LD_ADDR_OWVAR 33
48596: PUSH
48597: LD_STRING 
48599: ST_TO_ADDR
// animal := CreateHuman ;
48600: LD_ADDR_VAR 0 12
48604: PUSH
48605: CALL_OW 44
48609: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48610: LD_VAR 0 12
48614: PPUSH
48615: LD_VAR 0 8
48619: PPUSH
48620: LD_INT 0
48622: PPUSH
48623: CALL 50391 0 3
// end ;
48627: GO 48581
48629: POP
48630: POP
// if fishes then
48631: LD_VAR 0 7
48635: IFFALSE 48702
// for i = 1 to fishes do
48637: LD_ADDR_VAR 0 11
48641: PUSH
48642: DOUBLE
48643: LD_INT 1
48645: DEC
48646: ST_TO_ADDR
48647: LD_VAR 0 7
48651: PUSH
48652: FOR_TO
48653: IFFALSE 48700
// begin hc_class = 20 ;
48655: LD_ADDR_OWVAR 28
48659: PUSH
48660: LD_INT 20
48662: ST_TO_ADDR
// hc_gallery =  ;
48663: LD_ADDR_OWVAR 33
48667: PUSH
48668: LD_STRING 
48670: ST_TO_ADDR
// animal := CreateHuman ;
48671: LD_ADDR_VAR 0 12
48675: PUSH
48676: CALL_OW 44
48680: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48681: LD_VAR 0 12
48685: PPUSH
48686: LD_VAR 0 9
48690: PPUSH
48691: LD_INT 0
48693: PPUSH
48694: CALL 50391 0 3
// end ;
48698: GO 48652
48700: POP
48701: POP
// end ;
48702: LD_VAR 0 10
48706: RET
// export function WantHeal ( sci , unit ) ; begin
48707: LD_INT 0
48709: PPUSH
// if GetTaskList ( sci ) > 0 then
48710: LD_VAR 0 1
48714: PPUSH
48715: CALL_OW 437
48719: PUSH
48720: LD_INT 0
48722: GREATER
48723: IFFALSE 48793
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48725: LD_VAR 0 1
48729: PPUSH
48730: CALL_OW 437
48734: PUSH
48735: LD_INT 1
48737: ARRAY
48738: PUSH
48739: LD_INT 1
48741: ARRAY
48742: PUSH
48743: LD_STRING l
48745: EQUAL
48746: PUSH
48747: LD_VAR 0 1
48751: PPUSH
48752: CALL_OW 437
48756: PUSH
48757: LD_INT 1
48759: ARRAY
48760: PUSH
48761: LD_INT 4
48763: ARRAY
48764: PUSH
48765: LD_VAR 0 2
48769: EQUAL
48770: AND
48771: IFFALSE 48783
// result := true else
48773: LD_ADDR_VAR 0 3
48777: PUSH
48778: LD_INT 1
48780: ST_TO_ADDR
48781: GO 48791
// result := false ;
48783: LD_ADDR_VAR 0 3
48787: PUSH
48788: LD_INT 0
48790: ST_TO_ADDR
// end else
48791: GO 48801
// result := false ;
48793: LD_ADDR_VAR 0 3
48797: PUSH
48798: LD_INT 0
48800: ST_TO_ADDR
// end ;
48801: LD_VAR 0 3
48805: RET
// export function HealTarget ( sci ) ; begin
48806: LD_INT 0
48808: PPUSH
// if not sci then
48809: LD_VAR 0 1
48813: NOT
48814: IFFALSE 48818
// exit ;
48816: GO 48883
// result := 0 ;
48818: LD_ADDR_VAR 0 2
48822: PUSH
48823: LD_INT 0
48825: ST_TO_ADDR
// if GetTaskList ( sci ) then
48826: LD_VAR 0 1
48830: PPUSH
48831: CALL_OW 437
48835: IFFALSE 48883
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48837: LD_VAR 0 1
48841: PPUSH
48842: CALL_OW 437
48846: PUSH
48847: LD_INT 1
48849: ARRAY
48850: PUSH
48851: LD_INT 1
48853: ARRAY
48854: PUSH
48855: LD_STRING l
48857: EQUAL
48858: IFFALSE 48883
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48860: LD_ADDR_VAR 0 2
48864: PUSH
48865: LD_VAR 0 1
48869: PPUSH
48870: CALL_OW 437
48874: PUSH
48875: LD_INT 1
48877: ARRAY
48878: PUSH
48879: LD_INT 4
48881: ARRAY
48882: ST_TO_ADDR
// end ;
48883: LD_VAR 0 2
48887: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
48888: LD_INT 0
48890: PPUSH
48891: PPUSH
48892: PPUSH
48893: PPUSH
// if not base_units then
48894: LD_VAR 0 1
48898: NOT
48899: IFFALSE 48903
// exit ;
48901: GO 48990
// result := false ;
48903: LD_ADDR_VAR 0 2
48907: PUSH
48908: LD_INT 0
48910: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
48911: LD_ADDR_VAR 0 5
48915: PUSH
48916: LD_VAR 0 1
48920: PPUSH
48921: LD_INT 21
48923: PUSH
48924: LD_INT 3
48926: PUSH
48927: EMPTY
48928: LIST
48929: LIST
48930: PPUSH
48931: CALL_OW 72
48935: ST_TO_ADDR
// if not tmp then
48936: LD_VAR 0 5
48940: NOT
48941: IFFALSE 48945
// exit ;
48943: GO 48990
// for i in tmp do
48945: LD_ADDR_VAR 0 3
48949: PUSH
48950: LD_VAR 0 5
48954: PUSH
48955: FOR_IN
48956: IFFALSE 48988
// begin result := EnemyInRange ( i , 22 ) ;
48958: LD_ADDR_VAR 0 2
48962: PUSH
48963: LD_VAR 0 3
48967: PPUSH
48968: LD_INT 22
48970: PPUSH
48971: CALL 47226 0 2
48975: ST_TO_ADDR
// if result then
48976: LD_VAR 0 2
48980: IFFALSE 48986
// exit ;
48982: POP
48983: POP
48984: GO 48990
// end ;
48986: GO 48955
48988: POP
48989: POP
// end ;
48990: LD_VAR 0 2
48994: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
48995: LD_INT 0
48997: PPUSH
48998: PPUSH
// if not units then
48999: LD_VAR 0 1
49003: NOT
49004: IFFALSE 49008
// exit ;
49006: GO 49078
// result := [ ] ;
49008: LD_ADDR_VAR 0 3
49012: PUSH
49013: EMPTY
49014: ST_TO_ADDR
// for i in units do
49015: LD_ADDR_VAR 0 4
49019: PUSH
49020: LD_VAR 0 1
49024: PUSH
49025: FOR_IN
49026: IFFALSE 49076
// if GetTag ( i ) = tag then
49028: LD_VAR 0 4
49032: PPUSH
49033: CALL_OW 110
49037: PUSH
49038: LD_VAR 0 2
49042: EQUAL
49043: IFFALSE 49074
// result := Replace ( result , result + 1 , i ) ;
49045: LD_ADDR_VAR 0 3
49049: PUSH
49050: LD_VAR 0 3
49054: PPUSH
49055: LD_VAR 0 3
49059: PUSH
49060: LD_INT 1
49062: PLUS
49063: PPUSH
49064: LD_VAR 0 4
49068: PPUSH
49069: CALL_OW 1
49073: ST_TO_ADDR
49074: GO 49025
49076: POP
49077: POP
// end ;
49078: LD_VAR 0 3
49082: RET
// export function IsDriver ( un ) ; begin
49083: LD_INT 0
49085: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
49086: LD_ADDR_VAR 0 2
49090: PUSH
49091: LD_VAR 0 1
49095: PUSH
49096: LD_INT 55
49098: PUSH
49099: EMPTY
49100: LIST
49101: PPUSH
49102: CALL_OW 69
49106: IN
49107: ST_TO_ADDR
// end ;
49108: LD_VAR 0 2
49112: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
49113: LD_INT 0
49115: PPUSH
49116: PPUSH
// list := [ ] ;
49117: LD_ADDR_VAR 0 5
49121: PUSH
49122: EMPTY
49123: ST_TO_ADDR
// case d of 0 :
49124: LD_VAR 0 3
49128: PUSH
49129: LD_INT 0
49131: DOUBLE
49132: EQUAL
49133: IFTRUE 49137
49135: GO 49270
49137: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
49138: LD_ADDR_VAR 0 5
49142: PUSH
49143: LD_VAR 0 1
49147: PUSH
49148: LD_INT 4
49150: MINUS
49151: PUSH
49152: LD_VAR 0 2
49156: PUSH
49157: LD_INT 4
49159: MINUS
49160: PUSH
49161: LD_INT 2
49163: PUSH
49164: EMPTY
49165: LIST
49166: LIST
49167: LIST
49168: PUSH
49169: LD_VAR 0 1
49173: PUSH
49174: LD_INT 3
49176: MINUS
49177: PUSH
49178: LD_VAR 0 2
49182: PUSH
49183: LD_INT 1
49185: PUSH
49186: EMPTY
49187: LIST
49188: LIST
49189: LIST
49190: PUSH
49191: LD_VAR 0 1
49195: PUSH
49196: LD_INT 4
49198: PLUS
49199: PUSH
49200: LD_VAR 0 2
49204: PUSH
49205: LD_INT 4
49207: PUSH
49208: EMPTY
49209: LIST
49210: LIST
49211: LIST
49212: PUSH
49213: LD_VAR 0 1
49217: PUSH
49218: LD_INT 3
49220: PLUS
49221: PUSH
49222: LD_VAR 0 2
49226: PUSH
49227: LD_INT 3
49229: PLUS
49230: PUSH
49231: LD_INT 5
49233: PUSH
49234: EMPTY
49235: LIST
49236: LIST
49237: LIST
49238: PUSH
49239: LD_VAR 0 1
49243: PUSH
49244: LD_VAR 0 2
49248: PUSH
49249: LD_INT 4
49251: PLUS
49252: PUSH
49253: LD_INT 0
49255: PUSH
49256: EMPTY
49257: LIST
49258: LIST
49259: LIST
49260: PUSH
49261: EMPTY
49262: LIST
49263: LIST
49264: LIST
49265: LIST
49266: LIST
49267: ST_TO_ADDR
// end ; 1 :
49268: GO 49968
49270: LD_INT 1
49272: DOUBLE
49273: EQUAL
49274: IFTRUE 49278
49276: GO 49411
49278: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
49279: LD_ADDR_VAR 0 5
49283: PUSH
49284: LD_VAR 0 1
49288: PUSH
49289: LD_VAR 0 2
49293: PUSH
49294: LD_INT 4
49296: MINUS
49297: PUSH
49298: LD_INT 3
49300: PUSH
49301: EMPTY
49302: LIST
49303: LIST
49304: LIST
49305: PUSH
49306: LD_VAR 0 1
49310: PUSH
49311: LD_INT 3
49313: MINUS
49314: PUSH
49315: LD_VAR 0 2
49319: PUSH
49320: LD_INT 3
49322: MINUS
49323: PUSH
49324: LD_INT 2
49326: PUSH
49327: EMPTY
49328: LIST
49329: LIST
49330: LIST
49331: PUSH
49332: LD_VAR 0 1
49336: PUSH
49337: LD_INT 4
49339: MINUS
49340: PUSH
49341: LD_VAR 0 2
49345: PUSH
49346: LD_INT 1
49348: PUSH
49349: EMPTY
49350: LIST
49351: LIST
49352: LIST
49353: PUSH
49354: LD_VAR 0 1
49358: PUSH
49359: LD_VAR 0 2
49363: PUSH
49364: LD_INT 3
49366: PLUS
49367: PUSH
49368: LD_INT 0
49370: PUSH
49371: EMPTY
49372: LIST
49373: LIST
49374: LIST
49375: PUSH
49376: LD_VAR 0 1
49380: PUSH
49381: LD_INT 4
49383: PLUS
49384: PUSH
49385: LD_VAR 0 2
49389: PUSH
49390: LD_INT 4
49392: PLUS
49393: PUSH
49394: LD_INT 5
49396: PUSH
49397: EMPTY
49398: LIST
49399: LIST
49400: LIST
49401: PUSH
49402: EMPTY
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: ST_TO_ADDR
// end ; 2 :
49409: GO 49968
49411: LD_INT 2
49413: DOUBLE
49414: EQUAL
49415: IFTRUE 49419
49417: GO 49548
49419: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
49420: LD_ADDR_VAR 0 5
49424: PUSH
49425: LD_VAR 0 1
49429: PUSH
49430: LD_VAR 0 2
49434: PUSH
49435: LD_INT 3
49437: MINUS
49438: PUSH
49439: LD_INT 3
49441: PUSH
49442: EMPTY
49443: LIST
49444: LIST
49445: LIST
49446: PUSH
49447: LD_VAR 0 1
49451: PUSH
49452: LD_INT 4
49454: PLUS
49455: PUSH
49456: LD_VAR 0 2
49460: PUSH
49461: LD_INT 4
49463: PUSH
49464: EMPTY
49465: LIST
49466: LIST
49467: LIST
49468: PUSH
49469: LD_VAR 0 1
49473: PUSH
49474: LD_VAR 0 2
49478: PUSH
49479: LD_INT 4
49481: PLUS
49482: PUSH
49483: LD_INT 0
49485: PUSH
49486: EMPTY
49487: LIST
49488: LIST
49489: LIST
49490: PUSH
49491: LD_VAR 0 1
49495: PUSH
49496: LD_INT 3
49498: MINUS
49499: PUSH
49500: LD_VAR 0 2
49504: PUSH
49505: LD_INT 1
49507: PUSH
49508: EMPTY
49509: LIST
49510: LIST
49511: LIST
49512: PUSH
49513: LD_VAR 0 1
49517: PUSH
49518: LD_INT 4
49520: MINUS
49521: PUSH
49522: LD_VAR 0 2
49526: PUSH
49527: LD_INT 4
49529: MINUS
49530: PUSH
49531: LD_INT 2
49533: PUSH
49534: EMPTY
49535: LIST
49536: LIST
49537: LIST
49538: PUSH
49539: EMPTY
49540: LIST
49541: LIST
49542: LIST
49543: LIST
49544: LIST
49545: ST_TO_ADDR
// end ; 3 :
49546: GO 49968
49548: LD_INT 3
49550: DOUBLE
49551: EQUAL
49552: IFTRUE 49556
49554: GO 49689
49556: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
49557: LD_ADDR_VAR 0 5
49561: PUSH
49562: LD_VAR 0 1
49566: PUSH
49567: LD_INT 3
49569: PLUS
49570: PUSH
49571: LD_VAR 0 2
49575: PUSH
49576: LD_INT 4
49578: PUSH
49579: EMPTY
49580: LIST
49581: LIST
49582: LIST
49583: PUSH
49584: LD_VAR 0 1
49588: PUSH
49589: LD_INT 4
49591: PLUS
49592: PUSH
49593: LD_VAR 0 2
49597: PUSH
49598: LD_INT 4
49600: PLUS
49601: PUSH
49602: LD_INT 5
49604: PUSH
49605: EMPTY
49606: LIST
49607: LIST
49608: LIST
49609: PUSH
49610: LD_VAR 0 1
49614: PUSH
49615: LD_INT 4
49617: MINUS
49618: PUSH
49619: LD_VAR 0 2
49623: PUSH
49624: LD_INT 1
49626: PUSH
49627: EMPTY
49628: LIST
49629: LIST
49630: LIST
49631: PUSH
49632: LD_VAR 0 1
49636: PUSH
49637: LD_VAR 0 2
49641: PUSH
49642: LD_INT 4
49644: MINUS
49645: PUSH
49646: LD_INT 3
49648: PUSH
49649: EMPTY
49650: LIST
49651: LIST
49652: LIST
49653: PUSH
49654: LD_VAR 0 1
49658: PUSH
49659: LD_INT 3
49661: MINUS
49662: PUSH
49663: LD_VAR 0 2
49667: PUSH
49668: LD_INT 3
49670: MINUS
49671: PUSH
49672: LD_INT 2
49674: PUSH
49675: EMPTY
49676: LIST
49677: LIST
49678: LIST
49679: PUSH
49680: EMPTY
49681: LIST
49682: LIST
49683: LIST
49684: LIST
49685: LIST
49686: ST_TO_ADDR
// end ; 4 :
49687: GO 49968
49689: LD_INT 4
49691: DOUBLE
49692: EQUAL
49693: IFTRUE 49697
49695: GO 49830
49697: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
49698: LD_ADDR_VAR 0 5
49702: PUSH
49703: LD_VAR 0 1
49707: PUSH
49708: LD_VAR 0 2
49712: PUSH
49713: LD_INT 4
49715: PLUS
49716: PUSH
49717: LD_INT 0
49719: PUSH
49720: EMPTY
49721: LIST
49722: LIST
49723: LIST
49724: PUSH
49725: LD_VAR 0 1
49729: PUSH
49730: LD_INT 3
49732: PLUS
49733: PUSH
49734: LD_VAR 0 2
49738: PUSH
49739: LD_INT 3
49741: PLUS
49742: PUSH
49743: LD_INT 5
49745: PUSH
49746: EMPTY
49747: LIST
49748: LIST
49749: LIST
49750: PUSH
49751: LD_VAR 0 1
49755: PUSH
49756: LD_INT 4
49758: PLUS
49759: PUSH
49760: LD_VAR 0 2
49764: PUSH
49765: LD_INT 4
49767: PUSH
49768: EMPTY
49769: LIST
49770: LIST
49771: LIST
49772: PUSH
49773: LD_VAR 0 1
49777: PUSH
49778: LD_VAR 0 2
49782: PUSH
49783: LD_INT 3
49785: MINUS
49786: PUSH
49787: LD_INT 3
49789: PUSH
49790: EMPTY
49791: LIST
49792: LIST
49793: LIST
49794: PUSH
49795: LD_VAR 0 1
49799: PUSH
49800: LD_INT 4
49802: MINUS
49803: PUSH
49804: LD_VAR 0 2
49808: PUSH
49809: LD_INT 4
49811: MINUS
49812: PUSH
49813: LD_INT 2
49815: PUSH
49816: EMPTY
49817: LIST
49818: LIST
49819: LIST
49820: PUSH
49821: EMPTY
49822: LIST
49823: LIST
49824: LIST
49825: LIST
49826: LIST
49827: ST_TO_ADDR
// end ; 5 :
49828: GO 49968
49830: LD_INT 5
49832: DOUBLE
49833: EQUAL
49834: IFTRUE 49838
49836: GO 49967
49838: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
49839: LD_ADDR_VAR 0 5
49843: PUSH
49844: LD_VAR 0 1
49848: PUSH
49849: LD_INT 4
49851: MINUS
49852: PUSH
49853: LD_VAR 0 2
49857: PUSH
49858: LD_INT 1
49860: PUSH
49861: EMPTY
49862: LIST
49863: LIST
49864: LIST
49865: PUSH
49866: LD_VAR 0 1
49870: PUSH
49871: LD_VAR 0 2
49875: PUSH
49876: LD_INT 4
49878: MINUS
49879: PUSH
49880: LD_INT 3
49882: PUSH
49883: EMPTY
49884: LIST
49885: LIST
49886: LIST
49887: PUSH
49888: LD_VAR 0 1
49892: PUSH
49893: LD_INT 4
49895: PLUS
49896: PUSH
49897: LD_VAR 0 2
49901: PUSH
49902: LD_INT 4
49904: PLUS
49905: PUSH
49906: LD_INT 5
49908: PUSH
49909: EMPTY
49910: LIST
49911: LIST
49912: LIST
49913: PUSH
49914: LD_VAR 0 1
49918: PUSH
49919: LD_INT 3
49921: PLUS
49922: PUSH
49923: LD_VAR 0 2
49927: PUSH
49928: LD_INT 4
49930: PUSH
49931: EMPTY
49932: LIST
49933: LIST
49934: LIST
49935: PUSH
49936: LD_VAR 0 1
49940: PUSH
49941: LD_VAR 0 2
49945: PUSH
49946: LD_INT 3
49948: PLUS
49949: PUSH
49950: LD_INT 0
49952: PUSH
49953: EMPTY
49954: LIST
49955: LIST
49956: LIST
49957: PUSH
49958: EMPTY
49959: LIST
49960: LIST
49961: LIST
49962: LIST
49963: LIST
49964: ST_TO_ADDR
// end ; end ;
49965: GO 49968
49967: POP
// result := list ;
49968: LD_ADDR_VAR 0 4
49972: PUSH
49973: LD_VAR 0 5
49977: ST_TO_ADDR
// end ;
49978: LD_VAR 0 4
49982: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
49983: LD_INT 0
49985: PPUSH
49986: PPUSH
49987: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
49988: LD_VAR 0 1
49992: NOT
49993: PUSH
49994: LD_VAR 0 2
49998: PUSH
49999: LD_INT 1
50001: PUSH
50002: LD_INT 2
50004: PUSH
50005: LD_INT 3
50007: PUSH
50008: LD_INT 4
50010: PUSH
50011: EMPTY
50012: LIST
50013: LIST
50014: LIST
50015: LIST
50016: IN
50017: NOT
50018: OR
50019: IFFALSE 50023
// exit ;
50021: GO 50115
// tmp := [ ] ;
50023: LD_ADDR_VAR 0 5
50027: PUSH
50028: EMPTY
50029: ST_TO_ADDR
// for i in units do
50030: LD_ADDR_VAR 0 4
50034: PUSH
50035: LD_VAR 0 1
50039: PUSH
50040: FOR_IN
50041: IFFALSE 50084
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
50043: LD_ADDR_VAR 0 5
50047: PUSH
50048: LD_VAR 0 5
50052: PPUSH
50053: LD_VAR 0 5
50057: PUSH
50058: LD_INT 1
50060: PLUS
50061: PPUSH
50062: LD_VAR 0 4
50066: PPUSH
50067: LD_VAR 0 2
50071: PPUSH
50072: CALL_OW 259
50076: PPUSH
50077: CALL_OW 2
50081: ST_TO_ADDR
50082: GO 50040
50084: POP
50085: POP
// if not tmp then
50086: LD_VAR 0 5
50090: NOT
50091: IFFALSE 50095
// exit ;
50093: GO 50115
// result := SortListByListDesc ( units , tmp ) ;
50095: LD_ADDR_VAR 0 3
50099: PUSH
50100: LD_VAR 0 1
50104: PPUSH
50105: LD_VAR 0 5
50109: PPUSH
50110: CALL_OW 77
50114: ST_TO_ADDR
// end ;
50115: LD_VAR 0 3
50119: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
50120: LD_INT 0
50122: PPUSH
50123: PPUSH
50124: PPUSH
// result := false ;
50125: LD_ADDR_VAR 0 3
50129: PUSH
50130: LD_INT 0
50132: ST_TO_ADDR
// x := GetX ( building ) ;
50133: LD_ADDR_VAR 0 4
50137: PUSH
50138: LD_VAR 0 2
50142: PPUSH
50143: CALL_OW 250
50147: ST_TO_ADDR
// y := GetY ( building ) ;
50148: LD_ADDR_VAR 0 5
50152: PUSH
50153: LD_VAR 0 2
50157: PPUSH
50158: CALL_OW 251
50162: ST_TO_ADDR
// if not building or not x or not y then
50163: LD_VAR 0 2
50167: NOT
50168: PUSH
50169: LD_VAR 0 4
50173: NOT
50174: OR
50175: PUSH
50176: LD_VAR 0 5
50180: NOT
50181: OR
50182: IFFALSE 50186
// exit ;
50184: GO 50278
// if GetTaskList ( unit ) then
50186: LD_VAR 0 1
50190: PPUSH
50191: CALL_OW 437
50195: IFFALSE 50278
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50197: LD_STRING e
50199: PUSH
50200: LD_VAR 0 1
50204: PPUSH
50205: CALL_OW 437
50209: PUSH
50210: LD_INT 1
50212: ARRAY
50213: PUSH
50214: LD_INT 1
50216: ARRAY
50217: EQUAL
50218: PUSH
50219: LD_VAR 0 4
50223: PUSH
50224: LD_VAR 0 1
50228: PPUSH
50229: CALL_OW 437
50233: PUSH
50234: LD_INT 1
50236: ARRAY
50237: PUSH
50238: LD_INT 2
50240: ARRAY
50241: EQUAL
50242: AND
50243: PUSH
50244: LD_VAR 0 5
50248: PUSH
50249: LD_VAR 0 1
50253: PPUSH
50254: CALL_OW 437
50258: PUSH
50259: LD_INT 1
50261: ARRAY
50262: PUSH
50263: LD_INT 3
50265: ARRAY
50266: EQUAL
50267: AND
50268: IFFALSE 50278
// result := true end ;
50270: LD_ADDR_VAR 0 3
50274: PUSH
50275: LD_INT 1
50277: ST_TO_ADDR
// end ;
50278: LD_VAR 0 3
50282: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
50283: LD_INT 0
50285: PPUSH
// result := false ;
50286: LD_ADDR_VAR 0 4
50290: PUSH
50291: LD_INT 0
50293: ST_TO_ADDR
// if GetTaskList ( unit ) then
50294: LD_VAR 0 1
50298: PPUSH
50299: CALL_OW 437
50303: IFFALSE 50386
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50305: LD_STRING M
50307: PUSH
50308: LD_VAR 0 1
50312: PPUSH
50313: CALL_OW 437
50317: PUSH
50318: LD_INT 1
50320: ARRAY
50321: PUSH
50322: LD_INT 1
50324: ARRAY
50325: EQUAL
50326: PUSH
50327: LD_VAR 0 2
50331: PUSH
50332: LD_VAR 0 1
50336: PPUSH
50337: CALL_OW 437
50341: PUSH
50342: LD_INT 1
50344: ARRAY
50345: PUSH
50346: LD_INT 2
50348: ARRAY
50349: EQUAL
50350: AND
50351: PUSH
50352: LD_VAR 0 3
50356: PUSH
50357: LD_VAR 0 1
50361: PPUSH
50362: CALL_OW 437
50366: PUSH
50367: LD_INT 1
50369: ARRAY
50370: PUSH
50371: LD_INT 3
50373: ARRAY
50374: EQUAL
50375: AND
50376: IFFALSE 50386
// result := true ;
50378: LD_ADDR_VAR 0 4
50382: PUSH
50383: LD_INT 1
50385: ST_TO_ADDR
// end ; end ;
50386: LD_VAR 0 4
50390: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
50391: LD_INT 0
50393: PPUSH
50394: PPUSH
50395: PPUSH
50396: PPUSH
// if not unit or not area then
50397: LD_VAR 0 1
50401: NOT
50402: PUSH
50403: LD_VAR 0 2
50407: NOT
50408: OR
50409: IFFALSE 50413
// exit ;
50411: GO 50577
// tmp := AreaToList ( area , i ) ;
50413: LD_ADDR_VAR 0 6
50417: PUSH
50418: LD_VAR 0 2
50422: PPUSH
50423: LD_VAR 0 5
50427: PPUSH
50428: CALL_OW 517
50432: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
50433: LD_ADDR_VAR 0 5
50437: PUSH
50438: DOUBLE
50439: LD_INT 1
50441: DEC
50442: ST_TO_ADDR
50443: LD_VAR 0 6
50447: PUSH
50448: LD_INT 1
50450: ARRAY
50451: PUSH
50452: FOR_TO
50453: IFFALSE 50575
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
50455: LD_ADDR_VAR 0 7
50459: PUSH
50460: LD_VAR 0 6
50464: PUSH
50465: LD_INT 1
50467: ARRAY
50468: PUSH
50469: LD_VAR 0 5
50473: ARRAY
50474: PUSH
50475: LD_VAR 0 6
50479: PUSH
50480: LD_INT 2
50482: ARRAY
50483: PUSH
50484: LD_VAR 0 5
50488: ARRAY
50489: PUSH
50490: EMPTY
50491: LIST
50492: LIST
50493: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
50494: LD_VAR 0 7
50498: PUSH
50499: LD_INT 1
50501: ARRAY
50502: PPUSH
50503: LD_VAR 0 7
50507: PUSH
50508: LD_INT 2
50510: ARRAY
50511: PPUSH
50512: CALL_OW 428
50516: PUSH
50517: LD_INT 0
50519: EQUAL
50520: IFFALSE 50573
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
50522: LD_VAR 0 1
50526: PPUSH
50527: LD_VAR 0 7
50531: PUSH
50532: LD_INT 1
50534: ARRAY
50535: PPUSH
50536: LD_VAR 0 7
50540: PUSH
50541: LD_INT 2
50543: ARRAY
50544: PPUSH
50545: LD_VAR 0 3
50549: PPUSH
50550: CALL_OW 48
// result := IsPlaced ( unit ) ;
50554: LD_ADDR_VAR 0 4
50558: PUSH
50559: LD_VAR 0 1
50563: PPUSH
50564: CALL_OW 305
50568: ST_TO_ADDR
// exit ;
50569: POP
50570: POP
50571: GO 50577
// end ; end ;
50573: GO 50452
50575: POP
50576: POP
// end ;
50577: LD_VAR 0 4
50581: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
50582: LD_INT 0
50584: PPUSH
50585: PPUSH
50586: PPUSH
// if not side or side > 8 then
50587: LD_VAR 0 1
50591: NOT
50592: PUSH
50593: LD_VAR 0 1
50597: PUSH
50598: LD_INT 8
50600: GREATER
50601: OR
50602: IFFALSE 50606
// exit ;
50604: GO 50793
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
50606: LD_ADDR_VAR 0 4
50610: PUSH
50611: LD_INT 22
50613: PUSH
50614: LD_VAR 0 1
50618: PUSH
50619: EMPTY
50620: LIST
50621: LIST
50622: PUSH
50623: LD_INT 21
50625: PUSH
50626: LD_INT 3
50628: PUSH
50629: EMPTY
50630: LIST
50631: LIST
50632: PUSH
50633: EMPTY
50634: LIST
50635: LIST
50636: PPUSH
50637: CALL_OW 69
50641: ST_TO_ADDR
// if not tmp then
50642: LD_VAR 0 4
50646: NOT
50647: IFFALSE 50651
// exit ;
50649: GO 50793
// enable_addtolog := true ;
50651: LD_ADDR_OWVAR 81
50655: PUSH
50656: LD_INT 1
50658: ST_TO_ADDR
// AddToLog ( [ ) ;
50659: LD_STRING [
50661: PPUSH
50662: CALL_OW 561
// for i in tmp do
50666: LD_ADDR_VAR 0 3
50670: PUSH
50671: LD_VAR 0 4
50675: PUSH
50676: FOR_IN
50677: IFFALSE 50784
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
50679: LD_STRING [
50681: PUSH
50682: LD_VAR 0 3
50686: PPUSH
50687: CALL_OW 266
50691: STR
50692: PUSH
50693: LD_STRING , 
50695: STR
50696: PUSH
50697: LD_VAR 0 3
50701: PPUSH
50702: CALL_OW 250
50706: STR
50707: PUSH
50708: LD_STRING , 
50710: STR
50711: PUSH
50712: LD_VAR 0 3
50716: PPUSH
50717: CALL_OW 251
50721: STR
50722: PUSH
50723: LD_STRING , 
50725: STR
50726: PUSH
50727: LD_VAR 0 3
50731: PPUSH
50732: CALL_OW 254
50736: STR
50737: PUSH
50738: LD_STRING , 
50740: STR
50741: PUSH
50742: LD_VAR 0 3
50746: PPUSH
50747: LD_INT 1
50749: PPUSH
50750: CALL_OW 268
50754: STR
50755: PUSH
50756: LD_STRING , 
50758: STR
50759: PUSH
50760: LD_VAR 0 3
50764: PPUSH
50765: LD_INT 2
50767: PPUSH
50768: CALL_OW 268
50772: STR
50773: PUSH
50774: LD_STRING ],
50776: STR
50777: PPUSH
50778: CALL_OW 561
// end ;
50782: GO 50676
50784: POP
50785: POP
// AddToLog ( ]; ) ;
50786: LD_STRING ];
50788: PPUSH
50789: CALL_OW 561
// end ;
50793: LD_VAR 0 2
50797: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
50798: LD_INT 0
50800: PPUSH
50801: PPUSH
50802: PPUSH
50803: PPUSH
50804: PPUSH
// if not area or not rate or not max then
50805: LD_VAR 0 1
50809: NOT
50810: PUSH
50811: LD_VAR 0 2
50815: NOT
50816: OR
50817: PUSH
50818: LD_VAR 0 4
50822: NOT
50823: OR
50824: IFFALSE 50828
// exit ;
50826: GO 51020
// while 1 do
50828: LD_INT 1
50830: IFFALSE 51020
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
50832: LD_ADDR_VAR 0 9
50836: PUSH
50837: LD_VAR 0 1
50841: PPUSH
50842: LD_INT 1
50844: PPUSH
50845: CALL_OW 287
50849: PUSH
50850: LD_INT 10
50852: MUL
50853: ST_TO_ADDR
// r := rate / 10 ;
50854: LD_ADDR_VAR 0 7
50858: PUSH
50859: LD_VAR 0 2
50863: PUSH
50864: LD_INT 10
50866: DIVREAL
50867: ST_TO_ADDR
// time := 1 1$00 ;
50868: LD_ADDR_VAR 0 8
50872: PUSH
50873: LD_INT 2100
50875: ST_TO_ADDR
// if amount < min then
50876: LD_VAR 0 9
50880: PUSH
50881: LD_VAR 0 3
50885: LESS
50886: IFFALSE 50904
// r := r * 2 else
50888: LD_ADDR_VAR 0 7
50892: PUSH
50893: LD_VAR 0 7
50897: PUSH
50898: LD_INT 2
50900: MUL
50901: ST_TO_ADDR
50902: GO 50930
// if amount > max then
50904: LD_VAR 0 9
50908: PUSH
50909: LD_VAR 0 4
50913: GREATER
50914: IFFALSE 50930
// r := r / 2 ;
50916: LD_ADDR_VAR 0 7
50920: PUSH
50921: LD_VAR 0 7
50925: PUSH
50926: LD_INT 2
50928: DIVREAL
50929: ST_TO_ADDR
// time := time / r ;
50930: LD_ADDR_VAR 0 8
50934: PUSH
50935: LD_VAR 0 8
50939: PUSH
50940: LD_VAR 0 7
50944: DIVREAL
50945: ST_TO_ADDR
// if time < 0 then
50946: LD_VAR 0 8
50950: PUSH
50951: LD_INT 0
50953: LESS
50954: IFFALSE 50971
// time := time * - 1 ;
50956: LD_ADDR_VAR 0 8
50960: PUSH
50961: LD_VAR 0 8
50965: PUSH
50966: LD_INT 1
50968: NEG
50969: MUL
50970: ST_TO_ADDR
// wait ( time ) ;
50971: LD_VAR 0 8
50975: PPUSH
50976: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
50980: LD_INT 35
50982: PPUSH
50983: LD_INT 875
50985: PPUSH
50986: CALL_OW 12
50990: PPUSH
50991: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
50995: LD_INT 1
50997: PPUSH
50998: LD_INT 5
51000: PPUSH
51001: CALL_OW 12
51005: PPUSH
51006: LD_VAR 0 1
51010: PPUSH
51011: LD_INT 1
51013: PPUSH
51014: CALL_OW 55
// end ;
51018: GO 50828
// end ;
51020: LD_VAR 0 5
51024: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
51025: LD_INT 0
51027: PPUSH
51028: PPUSH
51029: PPUSH
51030: PPUSH
51031: PPUSH
51032: PPUSH
51033: PPUSH
51034: PPUSH
// if not turrets or not factories then
51035: LD_VAR 0 1
51039: NOT
51040: PUSH
51041: LD_VAR 0 2
51045: NOT
51046: OR
51047: IFFALSE 51051
// exit ;
51049: GO 51358
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
51051: LD_ADDR_VAR 0 10
51055: PUSH
51056: LD_INT 5
51058: PUSH
51059: LD_INT 6
51061: PUSH
51062: EMPTY
51063: LIST
51064: LIST
51065: PUSH
51066: LD_INT 2
51068: PUSH
51069: LD_INT 4
51071: PUSH
51072: EMPTY
51073: LIST
51074: LIST
51075: PUSH
51076: LD_INT 3
51078: PUSH
51079: LD_INT 5
51081: PUSH
51082: EMPTY
51083: LIST
51084: LIST
51085: PUSH
51086: EMPTY
51087: LIST
51088: LIST
51089: LIST
51090: PUSH
51091: LD_INT 24
51093: PUSH
51094: LD_INT 25
51096: PUSH
51097: EMPTY
51098: LIST
51099: LIST
51100: PUSH
51101: LD_INT 23
51103: PUSH
51104: LD_INT 27
51106: PUSH
51107: EMPTY
51108: LIST
51109: LIST
51110: PUSH
51111: EMPTY
51112: LIST
51113: LIST
51114: PUSH
51115: LD_INT 42
51117: PUSH
51118: LD_INT 43
51120: PUSH
51121: EMPTY
51122: LIST
51123: LIST
51124: PUSH
51125: LD_INT 44
51127: PUSH
51128: LD_INT 46
51130: PUSH
51131: EMPTY
51132: LIST
51133: LIST
51134: PUSH
51135: LD_INT 45
51137: PUSH
51138: LD_INT 47
51140: PUSH
51141: EMPTY
51142: LIST
51143: LIST
51144: PUSH
51145: EMPTY
51146: LIST
51147: LIST
51148: LIST
51149: PUSH
51150: EMPTY
51151: LIST
51152: LIST
51153: LIST
51154: ST_TO_ADDR
// result := [ ] ;
51155: LD_ADDR_VAR 0 3
51159: PUSH
51160: EMPTY
51161: ST_TO_ADDR
// for i in turrets do
51162: LD_ADDR_VAR 0 4
51166: PUSH
51167: LD_VAR 0 1
51171: PUSH
51172: FOR_IN
51173: IFFALSE 51356
// begin nat := GetNation ( i ) ;
51175: LD_ADDR_VAR 0 7
51179: PUSH
51180: LD_VAR 0 4
51184: PPUSH
51185: CALL_OW 248
51189: ST_TO_ADDR
// weapon := 0 ;
51190: LD_ADDR_VAR 0 8
51194: PUSH
51195: LD_INT 0
51197: ST_TO_ADDR
// if not nat then
51198: LD_VAR 0 7
51202: NOT
51203: IFFALSE 51207
// continue ;
51205: GO 51172
// for j in list [ nat ] do
51207: LD_ADDR_VAR 0 5
51211: PUSH
51212: LD_VAR 0 10
51216: PUSH
51217: LD_VAR 0 7
51221: ARRAY
51222: PUSH
51223: FOR_IN
51224: IFFALSE 51265
// if GetBWeapon ( i ) = j [ 1 ] then
51226: LD_VAR 0 4
51230: PPUSH
51231: CALL_OW 269
51235: PUSH
51236: LD_VAR 0 5
51240: PUSH
51241: LD_INT 1
51243: ARRAY
51244: EQUAL
51245: IFFALSE 51263
// begin weapon := j [ 2 ] ;
51247: LD_ADDR_VAR 0 8
51251: PUSH
51252: LD_VAR 0 5
51256: PUSH
51257: LD_INT 2
51259: ARRAY
51260: ST_TO_ADDR
// break ;
51261: GO 51265
// end ;
51263: GO 51223
51265: POP
51266: POP
// if not weapon then
51267: LD_VAR 0 8
51271: NOT
51272: IFFALSE 51276
// continue ;
51274: GO 51172
// for k in factories do
51276: LD_ADDR_VAR 0 6
51280: PUSH
51281: LD_VAR 0 2
51285: PUSH
51286: FOR_IN
51287: IFFALSE 51352
// begin weapons := AvailableWeaponList ( k ) ;
51289: LD_ADDR_VAR 0 9
51293: PUSH
51294: LD_VAR 0 6
51298: PPUSH
51299: CALL_OW 478
51303: ST_TO_ADDR
// if not weapons then
51304: LD_VAR 0 9
51308: NOT
51309: IFFALSE 51313
// continue ;
51311: GO 51286
// if weapon in weapons then
51313: LD_VAR 0 8
51317: PUSH
51318: LD_VAR 0 9
51322: IN
51323: IFFALSE 51350
// begin result := [ i , weapon ] ;
51325: LD_ADDR_VAR 0 3
51329: PUSH
51330: LD_VAR 0 4
51334: PUSH
51335: LD_VAR 0 8
51339: PUSH
51340: EMPTY
51341: LIST
51342: LIST
51343: ST_TO_ADDR
// exit ;
51344: POP
51345: POP
51346: POP
51347: POP
51348: GO 51358
// end ; end ;
51350: GO 51286
51352: POP
51353: POP
// end ;
51354: GO 51172
51356: POP
51357: POP
// end ;
51358: LD_VAR 0 3
51362: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
51363: LD_INT 0
51365: PPUSH
// if not side or side > 8 then
51366: LD_VAR 0 3
51370: NOT
51371: PUSH
51372: LD_VAR 0 3
51376: PUSH
51377: LD_INT 8
51379: GREATER
51380: OR
51381: IFFALSE 51385
// exit ;
51383: GO 51444
// if not range then
51385: LD_VAR 0 4
51389: NOT
51390: IFFALSE 51401
// range := - 12 ;
51392: LD_ADDR_VAR 0 4
51396: PUSH
51397: LD_INT 12
51399: NEG
51400: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
51401: LD_VAR 0 1
51405: PPUSH
51406: LD_VAR 0 2
51410: PPUSH
51411: LD_VAR 0 3
51415: PPUSH
51416: LD_VAR 0 4
51420: PPUSH
51421: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
51425: LD_VAR 0 1
51429: PPUSH
51430: LD_VAR 0 2
51434: PPUSH
51435: LD_VAR 0 3
51439: PPUSH
51440: CALL_OW 331
// end ;
51444: LD_VAR 0 5
51448: RET
// export function Video ( mode ) ; begin
51449: LD_INT 0
51451: PPUSH
// ingame_video = mode ;
51452: LD_ADDR_OWVAR 52
51456: PUSH
51457: LD_VAR 0 1
51461: ST_TO_ADDR
// interface_hidden = mode ;
51462: LD_ADDR_OWVAR 54
51466: PUSH
51467: LD_VAR 0 1
51471: ST_TO_ADDR
// end ;
51472: LD_VAR 0 2
51476: RET
// export function Join ( array , element ) ; begin
51477: LD_INT 0
51479: PPUSH
// result := Replace ( array , array + 1 , element ) ;
51480: LD_ADDR_VAR 0 3
51484: PUSH
51485: LD_VAR 0 1
51489: PPUSH
51490: LD_VAR 0 1
51494: PUSH
51495: LD_INT 1
51497: PLUS
51498: PPUSH
51499: LD_VAR 0 2
51503: PPUSH
51504: CALL_OW 1
51508: ST_TO_ADDR
// end ;
51509: LD_VAR 0 3
51513: RET
// export function JoinUnion ( array , element ) ; begin
51514: LD_INT 0
51516: PPUSH
// result := array union element ;
51517: LD_ADDR_VAR 0 3
51521: PUSH
51522: LD_VAR 0 1
51526: PUSH
51527: LD_VAR 0 2
51531: UNION
51532: ST_TO_ADDR
// end ;
51533: LD_VAR 0 3
51537: RET
// export function GetBehemoths ( side ) ; begin
51538: LD_INT 0
51540: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
51541: LD_ADDR_VAR 0 2
51545: PUSH
51546: LD_INT 22
51548: PUSH
51549: LD_VAR 0 1
51553: PUSH
51554: EMPTY
51555: LIST
51556: LIST
51557: PUSH
51558: LD_INT 31
51560: PUSH
51561: LD_INT 25
51563: PUSH
51564: EMPTY
51565: LIST
51566: LIST
51567: PUSH
51568: EMPTY
51569: LIST
51570: LIST
51571: PPUSH
51572: CALL_OW 69
51576: ST_TO_ADDR
// end ;
51577: LD_VAR 0 2
51581: RET
// export function Shuffle ( array ) ; var i , index ; begin
51582: LD_INT 0
51584: PPUSH
51585: PPUSH
51586: PPUSH
// result := [ ] ;
51587: LD_ADDR_VAR 0 2
51591: PUSH
51592: EMPTY
51593: ST_TO_ADDR
// if not array then
51594: LD_VAR 0 1
51598: NOT
51599: IFFALSE 51603
// exit ;
51601: GO 51702
// Randomize ;
51603: CALL_OW 10
// for i = array downto 1 do
51607: LD_ADDR_VAR 0 3
51611: PUSH
51612: DOUBLE
51613: LD_VAR 0 1
51617: INC
51618: ST_TO_ADDR
51619: LD_INT 1
51621: PUSH
51622: FOR_DOWNTO
51623: IFFALSE 51700
// begin index := rand ( 1 , array ) ;
51625: LD_ADDR_VAR 0 4
51629: PUSH
51630: LD_INT 1
51632: PPUSH
51633: LD_VAR 0 1
51637: PPUSH
51638: CALL_OW 12
51642: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
51643: LD_ADDR_VAR 0 2
51647: PUSH
51648: LD_VAR 0 2
51652: PPUSH
51653: LD_VAR 0 2
51657: PUSH
51658: LD_INT 1
51660: PLUS
51661: PPUSH
51662: LD_VAR 0 1
51666: PUSH
51667: LD_VAR 0 4
51671: ARRAY
51672: PPUSH
51673: CALL_OW 2
51677: ST_TO_ADDR
// array := Delete ( array , index ) ;
51678: LD_ADDR_VAR 0 1
51682: PUSH
51683: LD_VAR 0 1
51687: PPUSH
51688: LD_VAR 0 4
51692: PPUSH
51693: CALL_OW 3
51697: ST_TO_ADDR
// end ;
51698: GO 51622
51700: POP
51701: POP
// end ;
51702: LD_VAR 0 2
51706: RET
// export function GetBaseMaterials ( base ) ; begin
51707: LD_INT 0
51709: PPUSH
// result := [ 0 , 0 , 0 ] ;
51710: LD_ADDR_VAR 0 2
51714: PUSH
51715: LD_INT 0
51717: PUSH
51718: LD_INT 0
51720: PUSH
51721: LD_INT 0
51723: PUSH
51724: EMPTY
51725: LIST
51726: LIST
51727: LIST
51728: ST_TO_ADDR
// if not base then
51729: LD_VAR 0 1
51733: NOT
51734: IFFALSE 51738
// exit ;
51736: GO 51787
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
51738: LD_ADDR_VAR 0 2
51742: PUSH
51743: LD_VAR 0 1
51747: PPUSH
51748: LD_INT 1
51750: PPUSH
51751: CALL_OW 275
51755: PUSH
51756: LD_VAR 0 1
51760: PPUSH
51761: LD_INT 2
51763: PPUSH
51764: CALL_OW 275
51768: PUSH
51769: LD_VAR 0 1
51773: PPUSH
51774: LD_INT 3
51776: PPUSH
51777: CALL_OW 275
51781: PUSH
51782: EMPTY
51783: LIST
51784: LIST
51785: LIST
51786: ST_TO_ADDR
// end ;
51787: LD_VAR 0 2
51791: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
51792: LD_INT 0
51794: PPUSH
51795: PPUSH
// result := array ;
51796: LD_ADDR_VAR 0 3
51800: PUSH
51801: LD_VAR 0 1
51805: ST_TO_ADDR
// if size > 0 then
51806: LD_VAR 0 2
51810: PUSH
51811: LD_INT 0
51813: GREATER
51814: IFFALSE 51860
// for i := array downto size do
51816: LD_ADDR_VAR 0 4
51820: PUSH
51821: DOUBLE
51822: LD_VAR 0 1
51826: INC
51827: ST_TO_ADDR
51828: LD_VAR 0 2
51832: PUSH
51833: FOR_DOWNTO
51834: IFFALSE 51858
// result := Delete ( result , result ) ;
51836: LD_ADDR_VAR 0 3
51840: PUSH
51841: LD_VAR 0 3
51845: PPUSH
51846: LD_VAR 0 3
51850: PPUSH
51851: CALL_OW 3
51855: ST_TO_ADDR
51856: GO 51833
51858: POP
51859: POP
// end ;
51860: LD_VAR 0 3
51864: RET
// export function ComExit ( unit ) ; var tmp ; begin
51865: LD_INT 0
51867: PPUSH
51868: PPUSH
// if not IsInUnit ( unit ) then
51869: LD_VAR 0 1
51873: PPUSH
51874: CALL_OW 310
51878: NOT
51879: IFFALSE 51883
// exit ;
51881: GO 51943
// tmp := IsInUnit ( unit ) ;
51883: LD_ADDR_VAR 0 3
51887: PUSH
51888: LD_VAR 0 1
51892: PPUSH
51893: CALL_OW 310
51897: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
51898: LD_VAR 0 3
51902: PPUSH
51903: CALL_OW 247
51907: PUSH
51908: LD_INT 2
51910: EQUAL
51911: IFFALSE 51924
// ComExitVehicle ( unit ) else
51913: LD_VAR 0 1
51917: PPUSH
51918: CALL_OW 121
51922: GO 51933
// ComExitBuilding ( unit ) ;
51924: LD_VAR 0 1
51928: PPUSH
51929: CALL_OW 122
// result := tmp ;
51933: LD_ADDR_VAR 0 2
51937: PUSH
51938: LD_VAR 0 3
51942: ST_TO_ADDR
// end ;
51943: LD_VAR 0 2
51947: RET
// export function ComExitAll ( units ) ; var i ; begin
51948: LD_INT 0
51950: PPUSH
51951: PPUSH
// if not units then
51952: LD_VAR 0 1
51956: NOT
51957: IFFALSE 51961
// exit ;
51959: GO 51987
// for i in units do
51961: LD_ADDR_VAR 0 3
51965: PUSH
51966: LD_VAR 0 1
51970: PUSH
51971: FOR_IN
51972: IFFALSE 51985
// ComExit ( i ) ;
51974: LD_VAR 0 3
51978: PPUSH
51979: CALL 51865 0 1
51983: GO 51971
51985: POP
51986: POP
// end ;
51987: LD_VAR 0 2
51991: RET
// export function ResetHc ; begin
51992: LD_INT 0
51994: PPUSH
// InitHc ;
51995: CALL_OW 19
// hc_importance := 0 ;
51999: LD_ADDR_OWVAR 32
52003: PUSH
52004: LD_INT 0
52006: ST_TO_ADDR
// end ;
52007: LD_VAR 0 1
52011: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
52012: LD_INT 0
52014: PPUSH
52015: PPUSH
52016: PPUSH
// _x := ( x1 + x2 ) div 2 ;
52017: LD_ADDR_VAR 0 6
52021: PUSH
52022: LD_VAR 0 1
52026: PUSH
52027: LD_VAR 0 3
52031: PLUS
52032: PUSH
52033: LD_INT 2
52035: DIV
52036: ST_TO_ADDR
// if _x < 0 then
52037: LD_VAR 0 6
52041: PUSH
52042: LD_INT 0
52044: LESS
52045: IFFALSE 52062
// _x := _x * - 1 ;
52047: LD_ADDR_VAR 0 6
52051: PUSH
52052: LD_VAR 0 6
52056: PUSH
52057: LD_INT 1
52059: NEG
52060: MUL
52061: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
52062: LD_ADDR_VAR 0 7
52066: PUSH
52067: LD_VAR 0 2
52071: PUSH
52072: LD_VAR 0 4
52076: PLUS
52077: PUSH
52078: LD_INT 2
52080: DIV
52081: ST_TO_ADDR
// if _y < 0 then
52082: LD_VAR 0 7
52086: PUSH
52087: LD_INT 0
52089: LESS
52090: IFFALSE 52107
// _y := _y * - 1 ;
52092: LD_ADDR_VAR 0 7
52096: PUSH
52097: LD_VAR 0 7
52101: PUSH
52102: LD_INT 1
52104: NEG
52105: MUL
52106: ST_TO_ADDR
// result := [ _x , _y ] ;
52107: LD_ADDR_VAR 0 5
52111: PUSH
52112: LD_VAR 0 6
52116: PUSH
52117: LD_VAR 0 7
52121: PUSH
52122: EMPTY
52123: LIST
52124: LIST
52125: ST_TO_ADDR
// end ;
52126: LD_VAR 0 5
52130: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
52131: LD_INT 0
52133: PPUSH
52134: PPUSH
52135: PPUSH
52136: PPUSH
// task := GetTaskList ( unit ) ;
52137: LD_ADDR_VAR 0 7
52141: PUSH
52142: LD_VAR 0 1
52146: PPUSH
52147: CALL_OW 437
52151: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
52152: LD_VAR 0 7
52156: NOT
52157: PUSH
52158: LD_VAR 0 1
52162: PPUSH
52163: LD_VAR 0 2
52167: PPUSH
52168: CALL_OW 308
52172: NOT
52173: AND
52174: IFFALSE 52178
// exit ;
52176: GO 52296
// if IsInArea ( unit , area ) then
52178: LD_VAR 0 1
52182: PPUSH
52183: LD_VAR 0 2
52187: PPUSH
52188: CALL_OW 308
52192: IFFALSE 52210
// begin ComMoveToArea ( unit , goAway ) ;
52194: LD_VAR 0 1
52198: PPUSH
52199: LD_VAR 0 3
52203: PPUSH
52204: CALL_OW 113
// exit ;
52208: GO 52296
// end ; if task [ 1 ] [ 1 ] <> M then
52210: LD_VAR 0 7
52214: PUSH
52215: LD_INT 1
52217: ARRAY
52218: PUSH
52219: LD_INT 1
52221: ARRAY
52222: PUSH
52223: LD_STRING M
52225: NONEQUAL
52226: IFFALSE 52230
// exit ;
52228: GO 52296
// x := task [ 1 ] [ 2 ] ;
52230: LD_ADDR_VAR 0 5
52234: PUSH
52235: LD_VAR 0 7
52239: PUSH
52240: LD_INT 1
52242: ARRAY
52243: PUSH
52244: LD_INT 2
52246: ARRAY
52247: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
52248: LD_ADDR_VAR 0 6
52252: PUSH
52253: LD_VAR 0 7
52257: PUSH
52258: LD_INT 1
52260: ARRAY
52261: PUSH
52262: LD_INT 3
52264: ARRAY
52265: ST_TO_ADDR
// if InArea ( x , y , area ) then
52266: LD_VAR 0 5
52270: PPUSH
52271: LD_VAR 0 6
52275: PPUSH
52276: LD_VAR 0 2
52280: PPUSH
52281: CALL_OW 309
52285: IFFALSE 52296
// ComStop ( unit ) ;
52287: LD_VAR 0 1
52291: PPUSH
52292: CALL_OW 141
// end ;
52296: LD_VAR 0 4
52300: RET
// export function Abs ( value ) ; begin
52301: LD_INT 0
52303: PPUSH
// result := value ;
52304: LD_ADDR_VAR 0 2
52308: PUSH
52309: LD_VAR 0 1
52313: ST_TO_ADDR
// if value < 0 then
52314: LD_VAR 0 1
52318: PUSH
52319: LD_INT 0
52321: LESS
52322: IFFALSE 52339
// result := value * - 1 ;
52324: LD_ADDR_VAR 0 2
52328: PUSH
52329: LD_VAR 0 1
52333: PUSH
52334: LD_INT 1
52336: NEG
52337: MUL
52338: ST_TO_ADDR
// end ;
52339: LD_VAR 0 2
52343: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
52344: LD_INT 0
52346: PPUSH
52347: PPUSH
52348: PPUSH
52349: PPUSH
52350: PPUSH
52351: PPUSH
52352: PPUSH
52353: PPUSH
// if not unit or not building then
52354: LD_VAR 0 1
52358: NOT
52359: PUSH
52360: LD_VAR 0 2
52364: NOT
52365: OR
52366: IFFALSE 52370
// exit ;
52368: GO 52596
// x := GetX ( building ) ;
52370: LD_ADDR_VAR 0 4
52374: PUSH
52375: LD_VAR 0 2
52379: PPUSH
52380: CALL_OW 250
52384: ST_TO_ADDR
// y := GetY ( building ) ;
52385: LD_ADDR_VAR 0 6
52389: PUSH
52390: LD_VAR 0 2
52394: PPUSH
52395: CALL_OW 251
52399: ST_TO_ADDR
// d := GetDir ( building ) ;
52400: LD_ADDR_VAR 0 8
52404: PUSH
52405: LD_VAR 0 2
52409: PPUSH
52410: CALL_OW 254
52414: ST_TO_ADDR
// r := 4 ;
52415: LD_ADDR_VAR 0 9
52419: PUSH
52420: LD_INT 4
52422: ST_TO_ADDR
// for i := 1 to 5 do
52423: LD_ADDR_VAR 0 10
52427: PUSH
52428: DOUBLE
52429: LD_INT 1
52431: DEC
52432: ST_TO_ADDR
52433: LD_INT 5
52435: PUSH
52436: FOR_TO
52437: IFFALSE 52594
// begin _x := ShiftX ( x , d , r + i ) ;
52439: LD_ADDR_VAR 0 5
52443: PUSH
52444: LD_VAR 0 4
52448: PPUSH
52449: LD_VAR 0 8
52453: PPUSH
52454: LD_VAR 0 9
52458: PUSH
52459: LD_VAR 0 10
52463: PLUS
52464: PPUSH
52465: CALL_OW 272
52469: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
52470: LD_ADDR_VAR 0 7
52474: PUSH
52475: LD_VAR 0 6
52479: PPUSH
52480: LD_VAR 0 8
52484: PPUSH
52485: LD_VAR 0 9
52489: PUSH
52490: LD_VAR 0 10
52494: PLUS
52495: PPUSH
52496: CALL_OW 273
52500: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
52501: LD_VAR 0 5
52505: PPUSH
52506: LD_VAR 0 7
52510: PPUSH
52511: CALL_OW 488
52515: PUSH
52516: LD_VAR 0 5
52520: PPUSH
52521: LD_VAR 0 7
52525: PPUSH
52526: CALL_OW 428
52530: PPUSH
52531: CALL_OW 247
52535: PUSH
52536: LD_INT 3
52538: PUSH
52539: LD_INT 2
52541: PUSH
52542: EMPTY
52543: LIST
52544: LIST
52545: IN
52546: NOT
52547: AND
52548: IFFALSE 52592
// begin ComMoveXY ( unit , _x , _y ) ;
52550: LD_VAR 0 1
52554: PPUSH
52555: LD_VAR 0 5
52559: PPUSH
52560: LD_VAR 0 7
52564: PPUSH
52565: CALL_OW 111
// result := [ _x , _y ] ;
52569: LD_ADDR_VAR 0 3
52573: PUSH
52574: LD_VAR 0 5
52578: PUSH
52579: LD_VAR 0 7
52583: PUSH
52584: EMPTY
52585: LIST
52586: LIST
52587: ST_TO_ADDR
// exit ;
52588: POP
52589: POP
52590: GO 52596
// end ; end ;
52592: GO 52436
52594: POP
52595: POP
// end ;
52596: LD_VAR 0 3
52600: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
52601: LD_INT 0
52603: PPUSH
52604: PPUSH
52605: PPUSH
// result := 0 ;
52606: LD_ADDR_VAR 0 3
52610: PUSH
52611: LD_INT 0
52613: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
52614: LD_VAR 0 1
52618: PUSH
52619: LD_INT 0
52621: LESS
52622: PUSH
52623: LD_VAR 0 1
52627: PUSH
52628: LD_INT 8
52630: GREATER
52631: OR
52632: PUSH
52633: LD_VAR 0 2
52637: PUSH
52638: LD_INT 0
52640: LESS
52641: OR
52642: PUSH
52643: LD_VAR 0 2
52647: PUSH
52648: LD_INT 8
52650: GREATER
52651: OR
52652: IFFALSE 52656
// exit ;
52654: GO 52731
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
52656: LD_ADDR_VAR 0 4
52660: PUSH
52661: LD_INT 22
52663: PUSH
52664: LD_VAR 0 2
52668: PUSH
52669: EMPTY
52670: LIST
52671: LIST
52672: PPUSH
52673: CALL_OW 69
52677: PUSH
52678: FOR_IN
52679: IFFALSE 52729
// begin un := UnitShoot ( i ) ;
52681: LD_ADDR_VAR 0 5
52685: PUSH
52686: LD_VAR 0 4
52690: PPUSH
52691: CALL_OW 504
52695: ST_TO_ADDR
// if GetSide ( un ) = side1 then
52696: LD_VAR 0 5
52700: PPUSH
52701: CALL_OW 255
52705: PUSH
52706: LD_VAR 0 1
52710: EQUAL
52711: IFFALSE 52727
// begin result := un ;
52713: LD_ADDR_VAR 0 3
52717: PUSH
52718: LD_VAR 0 5
52722: ST_TO_ADDR
// exit ;
52723: POP
52724: POP
52725: GO 52731
// end ; end ;
52727: GO 52678
52729: POP
52730: POP
// end ;
52731: LD_VAR 0 3
52735: RET
// export function GetCargoBay ( units ) ; begin
52736: LD_INT 0
52738: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
52739: LD_ADDR_VAR 0 2
52743: PUSH
52744: LD_VAR 0 1
52748: PPUSH
52749: LD_INT 2
52751: PUSH
52752: LD_INT 34
52754: PUSH
52755: LD_INT 12
52757: PUSH
52758: EMPTY
52759: LIST
52760: LIST
52761: PUSH
52762: LD_INT 34
52764: PUSH
52765: LD_INT 51
52767: PUSH
52768: EMPTY
52769: LIST
52770: LIST
52771: PUSH
52772: LD_INT 34
52774: PUSH
52775: LD_INT 32
52777: PUSH
52778: EMPTY
52779: LIST
52780: LIST
52781: PUSH
52782: LD_INT 34
52784: PUSH
52785: LD_EXP 104
52789: PUSH
52790: EMPTY
52791: LIST
52792: LIST
52793: PUSH
52794: EMPTY
52795: LIST
52796: LIST
52797: LIST
52798: LIST
52799: LIST
52800: PPUSH
52801: CALL_OW 72
52805: ST_TO_ADDR
// end ;
52806: LD_VAR 0 2
52810: RET
// export function Negate ( value ) ; begin
52811: LD_INT 0
52813: PPUSH
// result := not value ;
52814: LD_ADDR_VAR 0 2
52818: PUSH
52819: LD_VAR 0 1
52823: NOT
52824: ST_TO_ADDR
// end ;
52825: LD_VAR 0 2
52829: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
52830: LD_INT 0
52832: PPUSH
// if x1 = x2 then
52833: LD_VAR 0 1
52837: PUSH
52838: LD_VAR 0 3
52842: EQUAL
52843: IFFALSE 52877
// begin if y1 > y2 then
52845: LD_VAR 0 2
52849: PUSH
52850: LD_VAR 0 4
52854: GREATER
52855: IFFALSE 52867
// result := 0 else
52857: LD_ADDR_VAR 0 5
52861: PUSH
52862: LD_INT 0
52864: ST_TO_ADDR
52865: GO 52875
// result := 3 ;
52867: LD_ADDR_VAR 0 5
52871: PUSH
52872: LD_INT 3
52874: ST_TO_ADDR
// exit ;
52875: GO 52963
// end ; if y1 = y2 then
52877: LD_VAR 0 2
52881: PUSH
52882: LD_VAR 0 4
52886: EQUAL
52887: IFFALSE 52921
// begin if x1 > x2 then
52889: LD_VAR 0 1
52893: PUSH
52894: LD_VAR 0 3
52898: GREATER
52899: IFFALSE 52911
// result := 1 else
52901: LD_ADDR_VAR 0 5
52905: PUSH
52906: LD_INT 1
52908: ST_TO_ADDR
52909: GO 52919
// result := 4 ;
52911: LD_ADDR_VAR 0 5
52915: PUSH
52916: LD_INT 4
52918: ST_TO_ADDR
// exit ;
52919: GO 52963
// end ; if x1 > x2 and y1 > y2 then
52921: LD_VAR 0 1
52925: PUSH
52926: LD_VAR 0 3
52930: GREATER
52931: PUSH
52932: LD_VAR 0 2
52936: PUSH
52937: LD_VAR 0 4
52941: GREATER
52942: AND
52943: IFFALSE 52955
// result := 2 else
52945: LD_ADDR_VAR 0 5
52949: PUSH
52950: LD_INT 2
52952: ST_TO_ADDR
52953: GO 52963
// result := 5 ;
52955: LD_ADDR_VAR 0 5
52959: PUSH
52960: LD_INT 5
52962: ST_TO_ADDR
// end ;
52963: LD_VAR 0 5
52967: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
52968: LD_INT 0
52970: PPUSH
52971: PPUSH
// if not driver or not IsInUnit ( driver ) then
52972: LD_VAR 0 1
52976: NOT
52977: PUSH
52978: LD_VAR 0 1
52982: PPUSH
52983: CALL_OW 310
52987: NOT
52988: OR
52989: IFFALSE 52993
// exit ;
52991: GO 53083
// vehicle := IsInUnit ( driver ) ;
52993: LD_ADDR_VAR 0 3
52997: PUSH
52998: LD_VAR 0 1
53002: PPUSH
53003: CALL_OW 310
53007: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
53008: LD_VAR 0 1
53012: PPUSH
53013: LD_STRING \
53015: PUSH
53016: LD_INT 0
53018: PUSH
53019: LD_INT 0
53021: PUSH
53022: LD_INT 0
53024: PUSH
53025: LD_INT 0
53027: PUSH
53028: LD_INT 0
53030: PUSH
53031: LD_INT 0
53033: PUSH
53034: EMPTY
53035: LIST
53036: LIST
53037: LIST
53038: LIST
53039: LIST
53040: LIST
53041: LIST
53042: PUSH
53043: LD_STRING E
53045: PUSH
53046: LD_INT 0
53048: PUSH
53049: LD_INT 0
53051: PUSH
53052: LD_VAR 0 3
53056: PUSH
53057: LD_INT 0
53059: PUSH
53060: LD_INT 0
53062: PUSH
53063: LD_INT 0
53065: PUSH
53066: EMPTY
53067: LIST
53068: LIST
53069: LIST
53070: LIST
53071: LIST
53072: LIST
53073: LIST
53074: PUSH
53075: EMPTY
53076: LIST
53077: LIST
53078: PPUSH
53079: CALL_OW 446
// end ;
53083: LD_VAR 0 2
53087: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
53088: LD_INT 0
53090: PPUSH
53091: PPUSH
// if not driver or not IsInUnit ( driver ) then
53092: LD_VAR 0 1
53096: NOT
53097: PUSH
53098: LD_VAR 0 1
53102: PPUSH
53103: CALL_OW 310
53107: NOT
53108: OR
53109: IFFALSE 53113
// exit ;
53111: GO 53203
// vehicle := IsInUnit ( driver ) ;
53113: LD_ADDR_VAR 0 3
53117: PUSH
53118: LD_VAR 0 1
53122: PPUSH
53123: CALL_OW 310
53127: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
53128: LD_VAR 0 1
53132: PPUSH
53133: LD_STRING \
53135: PUSH
53136: LD_INT 0
53138: PUSH
53139: LD_INT 0
53141: PUSH
53142: LD_INT 0
53144: PUSH
53145: LD_INT 0
53147: PUSH
53148: LD_INT 0
53150: PUSH
53151: LD_INT 0
53153: PUSH
53154: EMPTY
53155: LIST
53156: LIST
53157: LIST
53158: LIST
53159: LIST
53160: LIST
53161: LIST
53162: PUSH
53163: LD_STRING E
53165: PUSH
53166: LD_INT 0
53168: PUSH
53169: LD_INT 0
53171: PUSH
53172: LD_VAR 0 3
53176: PUSH
53177: LD_INT 0
53179: PUSH
53180: LD_INT 0
53182: PUSH
53183: LD_INT 0
53185: PUSH
53186: EMPTY
53187: LIST
53188: LIST
53189: LIST
53190: LIST
53191: LIST
53192: LIST
53193: LIST
53194: PUSH
53195: EMPTY
53196: LIST
53197: LIST
53198: PPUSH
53199: CALL_OW 447
// end ;
53203: LD_VAR 0 2
53207: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
53208: LD_INT 0
53210: PPUSH
53211: PPUSH
53212: PPUSH
// tmp := [ ] ;
53213: LD_ADDR_VAR 0 5
53217: PUSH
53218: EMPTY
53219: ST_TO_ADDR
// for i in units do
53220: LD_ADDR_VAR 0 4
53224: PUSH
53225: LD_VAR 0 1
53229: PUSH
53230: FOR_IN
53231: IFFALSE 53269
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
53233: LD_ADDR_VAR 0 5
53237: PUSH
53238: LD_VAR 0 5
53242: PPUSH
53243: LD_VAR 0 5
53247: PUSH
53248: LD_INT 1
53250: PLUS
53251: PPUSH
53252: LD_VAR 0 4
53256: PPUSH
53257: CALL_OW 256
53261: PPUSH
53262: CALL_OW 2
53266: ST_TO_ADDR
53267: GO 53230
53269: POP
53270: POP
// if not tmp then
53271: LD_VAR 0 5
53275: NOT
53276: IFFALSE 53280
// exit ;
53278: GO 53328
// if asc then
53280: LD_VAR 0 2
53284: IFFALSE 53308
// result := SortListByListAsc ( units , tmp ) else
53286: LD_ADDR_VAR 0 3
53290: PUSH
53291: LD_VAR 0 1
53295: PPUSH
53296: LD_VAR 0 5
53300: PPUSH
53301: CALL_OW 76
53305: ST_TO_ADDR
53306: GO 53328
// result := SortListByListDesc ( units , tmp ) ;
53308: LD_ADDR_VAR 0 3
53312: PUSH
53313: LD_VAR 0 1
53317: PPUSH
53318: LD_VAR 0 5
53322: PPUSH
53323: CALL_OW 77
53327: ST_TO_ADDR
// end ;
53328: LD_VAR 0 3
53332: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
53333: LD_INT 0
53335: PPUSH
53336: PPUSH
// task := GetTaskList ( mech ) ;
53337: LD_ADDR_VAR 0 4
53341: PUSH
53342: LD_VAR 0 1
53346: PPUSH
53347: CALL_OW 437
53351: ST_TO_ADDR
// if not task then
53352: LD_VAR 0 4
53356: NOT
53357: IFFALSE 53361
// exit ;
53359: GO 53403
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
53361: LD_ADDR_VAR 0 3
53365: PUSH
53366: LD_VAR 0 4
53370: PUSH
53371: LD_INT 1
53373: ARRAY
53374: PUSH
53375: LD_INT 1
53377: ARRAY
53378: PUSH
53379: LD_STRING r
53381: EQUAL
53382: PUSH
53383: LD_VAR 0 4
53387: PUSH
53388: LD_INT 1
53390: ARRAY
53391: PUSH
53392: LD_INT 4
53394: ARRAY
53395: PUSH
53396: LD_VAR 0 2
53400: EQUAL
53401: AND
53402: ST_TO_ADDR
// end ;
53403: LD_VAR 0 3
53407: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
53408: LD_INT 0
53410: PPUSH
// SetDir ( unit , d ) ;
53411: LD_VAR 0 1
53415: PPUSH
53416: LD_VAR 0 4
53420: PPUSH
53421: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
53425: LD_VAR 0 1
53429: PPUSH
53430: LD_VAR 0 2
53434: PPUSH
53435: LD_VAR 0 3
53439: PPUSH
53440: LD_VAR 0 5
53444: PPUSH
53445: CALL_OW 48
// end ;
53449: LD_VAR 0 6
53453: RET
// export function ToNaturalNumber ( number ) ; begin
53454: LD_INT 0
53456: PPUSH
// result := number div 1 ;
53457: LD_ADDR_VAR 0 2
53461: PUSH
53462: LD_VAR 0 1
53466: PUSH
53467: LD_INT 1
53469: DIV
53470: ST_TO_ADDR
// if number < 0 then
53471: LD_VAR 0 1
53475: PUSH
53476: LD_INT 0
53478: LESS
53479: IFFALSE 53489
// result := 0 ;
53481: LD_ADDR_VAR 0 2
53485: PUSH
53486: LD_INT 0
53488: ST_TO_ADDR
// end ;
53489: LD_VAR 0 2
53493: RET
// export function SortByClass ( units , class ) ; var un ; begin
53494: LD_INT 0
53496: PPUSH
53497: PPUSH
// if not units or not class then
53498: LD_VAR 0 1
53502: NOT
53503: PUSH
53504: LD_VAR 0 2
53508: NOT
53509: OR
53510: IFFALSE 53514
// exit ;
53512: GO 53609
// result := [ ] ;
53514: LD_ADDR_VAR 0 3
53518: PUSH
53519: EMPTY
53520: ST_TO_ADDR
// for un in units do
53521: LD_ADDR_VAR 0 4
53525: PUSH
53526: LD_VAR 0 1
53530: PUSH
53531: FOR_IN
53532: IFFALSE 53607
// if GetClass ( un ) = class then
53534: LD_VAR 0 4
53538: PPUSH
53539: CALL_OW 257
53543: PUSH
53544: LD_VAR 0 2
53548: EQUAL
53549: IFFALSE 53576
// result := Insert ( result , 1 , un ) else
53551: LD_ADDR_VAR 0 3
53555: PUSH
53556: LD_VAR 0 3
53560: PPUSH
53561: LD_INT 1
53563: PPUSH
53564: LD_VAR 0 4
53568: PPUSH
53569: CALL_OW 2
53573: ST_TO_ADDR
53574: GO 53605
// result := Replace ( result , result + 1 , un ) ;
53576: LD_ADDR_VAR 0 3
53580: PUSH
53581: LD_VAR 0 3
53585: PPUSH
53586: LD_VAR 0 3
53590: PUSH
53591: LD_INT 1
53593: PLUS
53594: PPUSH
53595: LD_VAR 0 4
53599: PPUSH
53600: CALL_OW 1
53604: ST_TO_ADDR
53605: GO 53531
53607: POP
53608: POP
// end ; end_of_file
53609: LD_VAR 0 3
53613: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
53614: LD_INT 0
53616: PPUSH
53617: PPUSH
// skirmish := false ;
53618: LD_ADDR_EXP 57
53622: PUSH
53623: LD_INT 0
53625: ST_TO_ADDR
// debug_mc := false ;
53626: LD_ADDR_EXP 58
53630: PUSH
53631: LD_INT 0
53633: ST_TO_ADDR
// mc_bases := [ ] ;
53634: LD_ADDR_EXP 59
53638: PUSH
53639: EMPTY
53640: ST_TO_ADDR
// mc_sides := [ ] ;
53641: LD_ADDR_EXP 85
53645: PUSH
53646: EMPTY
53647: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
53648: LD_ADDR_EXP 60
53652: PUSH
53653: EMPTY
53654: ST_TO_ADDR
// mc_building_repairs := [ ] ;
53655: LD_ADDR_EXP 61
53659: PUSH
53660: EMPTY
53661: ST_TO_ADDR
// mc_need_heal := [ ] ;
53662: LD_ADDR_EXP 62
53666: PUSH
53667: EMPTY
53668: ST_TO_ADDR
// mc_healers := [ ] ;
53669: LD_ADDR_EXP 63
53673: PUSH
53674: EMPTY
53675: ST_TO_ADDR
// mc_build_list := [ ] ;
53676: LD_ADDR_EXP 64
53680: PUSH
53681: EMPTY
53682: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
53683: LD_ADDR_EXP 91
53687: PUSH
53688: EMPTY
53689: ST_TO_ADDR
// mc_builders := [ ] ;
53690: LD_ADDR_EXP 65
53694: PUSH
53695: EMPTY
53696: ST_TO_ADDR
// mc_construct_list := [ ] ;
53697: LD_ADDR_EXP 66
53701: PUSH
53702: EMPTY
53703: ST_TO_ADDR
// mc_turret_list := [ ] ;
53704: LD_ADDR_EXP 67
53708: PUSH
53709: EMPTY
53710: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
53711: LD_ADDR_EXP 68
53715: PUSH
53716: EMPTY
53717: ST_TO_ADDR
// mc_miners := [ ] ;
53718: LD_ADDR_EXP 73
53722: PUSH
53723: EMPTY
53724: ST_TO_ADDR
// mc_mines := [ ] ;
53725: LD_ADDR_EXP 72
53729: PUSH
53730: EMPTY
53731: ST_TO_ADDR
// mc_minefields := [ ] ;
53732: LD_ADDR_EXP 74
53736: PUSH
53737: EMPTY
53738: ST_TO_ADDR
// mc_crates := [ ] ;
53739: LD_ADDR_EXP 75
53743: PUSH
53744: EMPTY
53745: ST_TO_ADDR
// mc_crates_collector := [ ] ;
53746: LD_ADDR_EXP 76
53750: PUSH
53751: EMPTY
53752: ST_TO_ADDR
// mc_crates_area := [ ] ;
53753: LD_ADDR_EXP 77
53757: PUSH
53758: EMPTY
53759: ST_TO_ADDR
// mc_vehicles := [ ] ;
53760: LD_ADDR_EXP 78
53764: PUSH
53765: EMPTY
53766: ST_TO_ADDR
// mc_attack := [ ] ;
53767: LD_ADDR_EXP 79
53771: PUSH
53772: EMPTY
53773: ST_TO_ADDR
// mc_produce := [ ] ;
53774: LD_ADDR_EXP 80
53778: PUSH
53779: EMPTY
53780: ST_TO_ADDR
// mc_defender := [ ] ;
53781: LD_ADDR_EXP 81
53785: PUSH
53786: EMPTY
53787: ST_TO_ADDR
// mc_parking := [ ] ;
53788: LD_ADDR_EXP 83
53792: PUSH
53793: EMPTY
53794: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
53795: LD_ADDR_EXP 69
53799: PUSH
53800: EMPTY
53801: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
53802: LD_ADDR_EXP 71
53806: PUSH
53807: EMPTY
53808: ST_TO_ADDR
// mc_scan := [ ] ;
53809: LD_ADDR_EXP 82
53813: PUSH
53814: EMPTY
53815: ST_TO_ADDR
// mc_scan_area := [ ] ;
53816: LD_ADDR_EXP 84
53820: PUSH
53821: EMPTY
53822: ST_TO_ADDR
// mc_tech := [ ] ;
53823: LD_ADDR_EXP 86
53827: PUSH
53828: EMPTY
53829: ST_TO_ADDR
// mc_class := [ ] ;
53830: LD_ADDR_EXP 100
53834: PUSH
53835: EMPTY
53836: ST_TO_ADDR
// mc_class_case_use := [ ] ;
53837: LD_ADDR_EXP 101
53841: PUSH
53842: EMPTY
53843: ST_TO_ADDR
// mc_is_defending := [ ] ;
53844: LD_ADDR_EXP 102
53848: PUSH
53849: EMPTY
53850: ST_TO_ADDR
// end ;
53851: LD_VAR 0 1
53855: RET
// export function MC_Kill ( base ) ; begin
53856: LD_INT 0
53858: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
53859: LD_ADDR_EXP 59
53863: PUSH
53864: LD_EXP 59
53868: PPUSH
53869: LD_VAR 0 1
53873: PPUSH
53874: EMPTY
53875: PPUSH
53876: CALL_OW 1
53880: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53881: LD_ADDR_EXP 60
53885: PUSH
53886: LD_EXP 60
53890: PPUSH
53891: LD_VAR 0 1
53895: PPUSH
53896: EMPTY
53897: PPUSH
53898: CALL_OW 1
53902: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53903: LD_ADDR_EXP 61
53907: PUSH
53908: LD_EXP 61
53912: PPUSH
53913: LD_VAR 0 1
53917: PPUSH
53918: EMPTY
53919: PPUSH
53920: CALL_OW 1
53924: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53925: LD_ADDR_EXP 62
53929: PUSH
53930: LD_EXP 62
53934: PPUSH
53935: LD_VAR 0 1
53939: PPUSH
53940: EMPTY
53941: PPUSH
53942: CALL_OW 1
53946: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53947: LD_ADDR_EXP 63
53951: PUSH
53952: LD_EXP 63
53956: PPUSH
53957: LD_VAR 0 1
53961: PPUSH
53962: EMPTY
53963: PPUSH
53964: CALL_OW 1
53968: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53969: LD_ADDR_EXP 64
53973: PUSH
53974: LD_EXP 64
53978: PPUSH
53979: LD_VAR 0 1
53983: PPUSH
53984: EMPTY
53985: PPUSH
53986: CALL_OW 1
53990: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53991: LD_ADDR_EXP 65
53995: PUSH
53996: LD_EXP 65
54000: PPUSH
54001: LD_VAR 0 1
54005: PPUSH
54006: EMPTY
54007: PPUSH
54008: CALL_OW 1
54012: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
54013: LD_ADDR_EXP 66
54017: PUSH
54018: LD_EXP 66
54022: PPUSH
54023: LD_VAR 0 1
54027: PPUSH
54028: EMPTY
54029: PPUSH
54030: CALL_OW 1
54034: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
54035: LD_ADDR_EXP 67
54039: PUSH
54040: LD_EXP 67
54044: PPUSH
54045: LD_VAR 0 1
54049: PPUSH
54050: EMPTY
54051: PPUSH
54052: CALL_OW 1
54056: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
54057: LD_ADDR_EXP 68
54061: PUSH
54062: LD_EXP 68
54066: PPUSH
54067: LD_VAR 0 1
54071: PPUSH
54072: EMPTY
54073: PPUSH
54074: CALL_OW 1
54078: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
54079: LD_ADDR_EXP 69
54083: PUSH
54084: LD_EXP 69
54088: PPUSH
54089: LD_VAR 0 1
54093: PPUSH
54094: EMPTY
54095: PPUSH
54096: CALL_OW 1
54100: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
54101: LD_ADDR_EXP 70
54105: PUSH
54106: LD_EXP 70
54110: PPUSH
54111: LD_VAR 0 1
54115: PPUSH
54116: LD_INT 0
54118: PPUSH
54119: CALL_OW 1
54123: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
54124: LD_ADDR_EXP 71
54128: PUSH
54129: LD_EXP 71
54133: PPUSH
54134: LD_VAR 0 1
54138: PPUSH
54139: EMPTY
54140: PPUSH
54141: CALL_OW 1
54145: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
54146: LD_ADDR_EXP 72
54150: PUSH
54151: LD_EXP 72
54155: PPUSH
54156: LD_VAR 0 1
54160: PPUSH
54161: EMPTY
54162: PPUSH
54163: CALL_OW 1
54167: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
54168: LD_ADDR_EXP 73
54172: PUSH
54173: LD_EXP 73
54177: PPUSH
54178: LD_VAR 0 1
54182: PPUSH
54183: EMPTY
54184: PPUSH
54185: CALL_OW 1
54189: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
54190: LD_ADDR_EXP 74
54194: PUSH
54195: LD_EXP 74
54199: PPUSH
54200: LD_VAR 0 1
54204: PPUSH
54205: EMPTY
54206: PPUSH
54207: CALL_OW 1
54211: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
54212: LD_ADDR_EXP 75
54216: PUSH
54217: LD_EXP 75
54221: PPUSH
54222: LD_VAR 0 1
54226: PPUSH
54227: EMPTY
54228: PPUSH
54229: CALL_OW 1
54233: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
54234: LD_ADDR_EXP 76
54238: PUSH
54239: LD_EXP 76
54243: PPUSH
54244: LD_VAR 0 1
54248: PPUSH
54249: EMPTY
54250: PPUSH
54251: CALL_OW 1
54255: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
54256: LD_ADDR_EXP 77
54260: PUSH
54261: LD_EXP 77
54265: PPUSH
54266: LD_VAR 0 1
54270: PPUSH
54271: EMPTY
54272: PPUSH
54273: CALL_OW 1
54277: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
54278: LD_ADDR_EXP 78
54282: PUSH
54283: LD_EXP 78
54287: PPUSH
54288: LD_VAR 0 1
54292: PPUSH
54293: EMPTY
54294: PPUSH
54295: CALL_OW 1
54299: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54300: LD_ADDR_EXP 79
54304: PUSH
54305: LD_EXP 79
54309: PPUSH
54310: LD_VAR 0 1
54314: PPUSH
54315: EMPTY
54316: PPUSH
54317: CALL_OW 1
54321: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54322: LD_ADDR_EXP 80
54326: PUSH
54327: LD_EXP 80
54331: PPUSH
54332: LD_VAR 0 1
54336: PPUSH
54337: EMPTY
54338: PPUSH
54339: CALL_OW 1
54343: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54344: LD_ADDR_EXP 81
54348: PUSH
54349: LD_EXP 81
54353: PPUSH
54354: LD_VAR 0 1
54358: PPUSH
54359: EMPTY
54360: PPUSH
54361: CALL_OW 1
54365: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54366: LD_ADDR_EXP 82
54370: PUSH
54371: LD_EXP 82
54375: PPUSH
54376: LD_VAR 0 1
54380: PPUSH
54381: EMPTY
54382: PPUSH
54383: CALL_OW 1
54387: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54388: LD_ADDR_EXP 83
54392: PUSH
54393: LD_EXP 83
54397: PPUSH
54398: LD_VAR 0 1
54402: PPUSH
54403: EMPTY
54404: PPUSH
54405: CALL_OW 1
54409: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54410: LD_ADDR_EXP 84
54414: PUSH
54415: LD_EXP 84
54419: PPUSH
54420: LD_VAR 0 1
54424: PPUSH
54425: EMPTY
54426: PPUSH
54427: CALL_OW 1
54431: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54432: LD_ADDR_EXP 86
54436: PUSH
54437: LD_EXP 86
54441: PPUSH
54442: LD_VAR 0 1
54446: PPUSH
54447: EMPTY
54448: PPUSH
54449: CALL_OW 1
54453: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54454: LD_ADDR_EXP 88
54458: PUSH
54459: LD_EXP 88
54463: PPUSH
54464: LD_VAR 0 1
54468: PPUSH
54469: EMPTY
54470: PPUSH
54471: CALL_OW 1
54475: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54476: LD_ADDR_EXP 89
54480: PUSH
54481: LD_EXP 89
54485: PPUSH
54486: LD_VAR 0 1
54490: PPUSH
54491: EMPTY
54492: PPUSH
54493: CALL_OW 1
54497: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54498: LD_ADDR_EXP 90
54502: PUSH
54503: LD_EXP 90
54507: PPUSH
54508: LD_VAR 0 1
54512: PPUSH
54513: EMPTY
54514: PPUSH
54515: CALL_OW 1
54519: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54520: LD_ADDR_EXP 91
54524: PUSH
54525: LD_EXP 91
54529: PPUSH
54530: LD_VAR 0 1
54534: PPUSH
54535: EMPTY
54536: PPUSH
54537: CALL_OW 1
54541: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54542: LD_ADDR_EXP 92
54546: PUSH
54547: LD_EXP 92
54551: PPUSH
54552: LD_VAR 0 1
54556: PPUSH
54557: EMPTY
54558: PPUSH
54559: CALL_OW 1
54563: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54564: LD_ADDR_EXP 93
54568: PUSH
54569: LD_EXP 93
54573: PPUSH
54574: LD_VAR 0 1
54578: PPUSH
54579: EMPTY
54580: PPUSH
54581: CALL_OW 1
54585: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54586: LD_ADDR_EXP 94
54590: PUSH
54591: LD_EXP 94
54595: PPUSH
54596: LD_VAR 0 1
54600: PPUSH
54601: EMPTY
54602: PPUSH
54603: CALL_OW 1
54607: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54608: LD_ADDR_EXP 95
54612: PUSH
54613: LD_EXP 95
54617: PPUSH
54618: LD_VAR 0 1
54622: PPUSH
54623: EMPTY
54624: PPUSH
54625: CALL_OW 1
54629: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54630: LD_ADDR_EXP 96
54634: PUSH
54635: LD_EXP 96
54639: PPUSH
54640: LD_VAR 0 1
54644: PPUSH
54645: EMPTY
54646: PPUSH
54647: CALL_OW 1
54651: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54652: LD_ADDR_EXP 97
54656: PUSH
54657: LD_EXP 97
54661: PPUSH
54662: LD_VAR 0 1
54666: PPUSH
54667: EMPTY
54668: PPUSH
54669: CALL_OW 1
54673: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54674: LD_ADDR_EXP 98
54678: PUSH
54679: LD_EXP 98
54683: PPUSH
54684: LD_VAR 0 1
54688: PPUSH
54689: EMPTY
54690: PPUSH
54691: CALL_OW 1
54695: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54696: LD_ADDR_EXP 99
54700: PUSH
54701: LD_EXP 99
54705: PPUSH
54706: LD_VAR 0 1
54710: PPUSH
54711: EMPTY
54712: PPUSH
54713: CALL_OW 1
54717: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54718: LD_ADDR_EXP 100
54722: PUSH
54723: LD_EXP 100
54727: PPUSH
54728: LD_VAR 0 1
54732: PPUSH
54733: EMPTY
54734: PPUSH
54735: CALL_OW 1
54739: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54740: LD_ADDR_EXP 101
54744: PUSH
54745: LD_EXP 101
54749: PPUSH
54750: LD_VAR 0 1
54754: PPUSH
54755: LD_INT 0
54757: PPUSH
54758: CALL_OW 1
54762: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
54763: LD_ADDR_EXP 102
54767: PUSH
54768: LD_EXP 102
54772: PPUSH
54773: LD_VAR 0 1
54777: PPUSH
54778: LD_INT 0
54780: PPUSH
54781: CALL_OW 1
54785: ST_TO_ADDR
// end ;
54786: LD_VAR 0 2
54790: RET
// export function MC_Add ( side , units ) ; var base ; begin
54791: LD_INT 0
54793: PPUSH
54794: PPUSH
// base := mc_bases + 1 ;
54795: LD_ADDR_VAR 0 4
54799: PUSH
54800: LD_EXP 59
54804: PUSH
54805: LD_INT 1
54807: PLUS
54808: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
54809: LD_ADDR_EXP 85
54813: PUSH
54814: LD_EXP 85
54818: PPUSH
54819: LD_VAR 0 4
54823: PPUSH
54824: LD_VAR 0 1
54828: PPUSH
54829: CALL_OW 1
54833: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
54834: LD_ADDR_EXP 59
54838: PUSH
54839: LD_EXP 59
54843: PPUSH
54844: LD_VAR 0 4
54848: PPUSH
54849: LD_VAR 0 2
54853: PPUSH
54854: CALL_OW 1
54858: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
54859: LD_ADDR_EXP 60
54863: PUSH
54864: LD_EXP 60
54868: PPUSH
54869: LD_VAR 0 4
54873: PPUSH
54874: EMPTY
54875: PPUSH
54876: CALL_OW 1
54880: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
54881: LD_ADDR_EXP 61
54885: PUSH
54886: LD_EXP 61
54890: PPUSH
54891: LD_VAR 0 4
54895: PPUSH
54896: EMPTY
54897: PPUSH
54898: CALL_OW 1
54902: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
54903: LD_ADDR_EXP 62
54907: PUSH
54908: LD_EXP 62
54912: PPUSH
54913: LD_VAR 0 4
54917: PPUSH
54918: EMPTY
54919: PPUSH
54920: CALL_OW 1
54924: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
54925: LD_ADDR_EXP 63
54929: PUSH
54930: LD_EXP 63
54934: PPUSH
54935: LD_VAR 0 4
54939: PPUSH
54940: EMPTY
54941: PPUSH
54942: CALL_OW 1
54946: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
54947: LD_ADDR_EXP 64
54951: PUSH
54952: LD_EXP 64
54956: PPUSH
54957: LD_VAR 0 4
54961: PPUSH
54962: EMPTY
54963: PPUSH
54964: CALL_OW 1
54968: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
54969: LD_ADDR_EXP 65
54973: PUSH
54974: LD_EXP 65
54978: PPUSH
54979: LD_VAR 0 4
54983: PPUSH
54984: EMPTY
54985: PPUSH
54986: CALL_OW 1
54990: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
54991: LD_ADDR_EXP 66
54995: PUSH
54996: LD_EXP 66
55000: PPUSH
55001: LD_VAR 0 4
55005: PPUSH
55006: EMPTY
55007: PPUSH
55008: CALL_OW 1
55012: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55013: LD_ADDR_EXP 67
55017: PUSH
55018: LD_EXP 67
55022: PPUSH
55023: LD_VAR 0 4
55027: PPUSH
55028: EMPTY
55029: PPUSH
55030: CALL_OW 1
55034: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55035: LD_ADDR_EXP 68
55039: PUSH
55040: LD_EXP 68
55044: PPUSH
55045: LD_VAR 0 4
55049: PPUSH
55050: EMPTY
55051: PPUSH
55052: CALL_OW 1
55056: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55057: LD_ADDR_EXP 69
55061: PUSH
55062: LD_EXP 69
55066: PPUSH
55067: LD_VAR 0 4
55071: PPUSH
55072: EMPTY
55073: PPUSH
55074: CALL_OW 1
55078: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55079: LD_ADDR_EXP 70
55083: PUSH
55084: LD_EXP 70
55088: PPUSH
55089: LD_VAR 0 4
55093: PPUSH
55094: LD_INT 0
55096: PPUSH
55097: CALL_OW 1
55101: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55102: LD_ADDR_EXP 71
55106: PUSH
55107: LD_EXP 71
55111: PPUSH
55112: LD_VAR 0 4
55116: PPUSH
55117: EMPTY
55118: PPUSH
55119: CALL_OW 1
55123: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55124: LD_ADDR_EXP 72
55128: PUSH
55129: LD_EXP 72
55133: PPUSH
55134: LD_VAR 0 4
55138: PPUSH
55139: EMPTY
55140: PPUSH
55141: CALL_OW 1
55145: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55146: LD_ADDR_EXP 73
55150: PUSH
55151: LD_EXP 73
55155: PPUSH
55156: LD_VAR 0 4
55160: PPUSH
55161: EMPTY
55162: PPUSH
55163: CALL_OW 1
55167: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55168: LD_ADDR_EXP 74
55172: PUSH
55173: LD_EXP 74
55177: PPUSH
55178: LD_VAR 0 4
55182: PPUSH
55183: EMPTY
55184: PPUSH
55185: CALL_OW 1
55189: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55190: LD_ADDR_EXP 75
55194: PUSH
55195: LD_EXP 75
55199: PPUSH
55200: LD_VAR 0 4
55204: PPUSH
55205: EMPTY
55206: PPUSH
55207: CALL_OW 1
55211: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55212: LD_ADDR_EXP 76
55216: PUSH
55217: LD_EXP 76
55221: PPUSH
55222: LD_VAR 0 4
55226: PPUSH
55227: EMPTY
55228: PPUSH
55229: CALL_OW 1
55233: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55234: LD_ADDR_EXP 77
55238: PUSH
55239: LD_EXP 77
55243: PPUSH
55244: LD_VAR 0 4
55248: PPUSH
55249: EMPTY
55250: PPUSH
55251: CALL_OW 1
55255: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55256: LD_ADDR_EXP 78
55260: PUSH
55261: LD_EXP 78
55265: PPUSH
55266: LD_VAR 0 4
55270: PPUSH
55271: EMPTY
55272: PPUSH
55273: CALL_OW 1
55277: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55278: LD_ADDR_EXP 79
55282: PUSH
55283: LD_EXP 79
55287: PPUSH
55288: LD_VAR 0 4
55292: PPUSH
55293: EMPTY
55294: PPUSH
55295: CALL_OW 1
55299: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55300: LD_ADDR_EXP 80
55304: PUSH
55305: LD_EXP 80
55309: PPUSH
55310: LD_VAR 0 4
55314: PPUSH
55315: EMPTY
55316: PPUSH
55317: CALL_OW 1
55321: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55322: LD_ADDR_EXP 81
55326: PUSH
55327: LD_EXP 81
55331: PPUSH
55332: LD_VAR 0 4
55336: PPUSH
55337: EMPTY
55338: PPUSH
55339: CALL_OW 1
55343: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55344: LD_ADDR_EXP 82
55348: PUSH
55349: LD_EXP 82
55353: PPUSH
55354: LD_VAR 0 4
55358: PPUSH
55359: EMPTY
55360: PPUSH
55361: CALL_OW 1
55365: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55366: LD_ADDR_EXP 83
55370: PUSH
55371: LD_EXP 83
55375: PPUSH
55376: LD_VAR 0 4
55380: PPUSH
55381: EMPTY
55382: PPUSH
55383: CALL_OW 1
55387: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55388: LD_ADDR_EXP 84
55392: PUSH
55393: LD_EXP 84
55397: PPUSH
55398: LD_VAR 0 4
55402: PPUSH
55403: EMPTY
55404: PPUSH
55405: CALL_OW 1
55409: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55410: LD_ADDR_EXP 86
55414: PUSH
55415: LD_EXP 86
55419: PPUSH
55420: LD_VAR 0 4
55424: PPUSH
55425: EMPTY
55426: PPUSH
55427: CALL_OW 1
55431: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55432: LD_ADDR_EXP 88
55436: PUSH
55437: LD_EXP 88
55441: PPUSH
55442: LD_VAR 0 4
55446: PPUSH
55447: EMPTY
55448: PPUSH
55449: CALL_OW 1
55453: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55454: LD_ADDR_EXP 89
55458: PUSH
55459: LD_EXP 89
55463: PPUSH
55464: LD_VAR 0 4
55468: PPUSH
55469: EMPTY
55470: PPUSH
55471: CALL_OW 1
55475: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55476: LD_ADDR_EXP 90
55480: PUSH
55481: LD_EXP 90
55485: PPUSH
55486: LD_VAR 0 4
55490: PPUSH
55491: EMPTY
55492: PPUSH
55493: CALL_OW 1
55497: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55498: LD_ADDR_EXP 91
55502: PUSH
55503: LD_EXP 91
55507: PPUSH
55508: LD_VAR 0 4
55512: PPUSH
55513: EMPTY
55514: PPUSH
55515: CALL_OW 1
55519: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55520: LD_ADDR_EXP 92
55524: PUSH
55525: LD_EXP 92
55529: PPUSH
55530: LD_VAR 0 4
55534: PPUSH
55535: EMPTY
55536: PPUSH
55537: CALL_OW 1
55541: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55542: LD_ADDR_EXP 93
55546: PUSH
55547: LD_EXP 93
55551: PPUSH
55552: LD_VAR 0 4
55556: PPUSH
55557: EMPTY
55558: PPUSH
55559: CALL_OW 1
55563: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55564: LD_ADDR_EXP 94
55568: PUSH
55569: LD_EXP 94
55573: PPUSH
55574: LD_VAR 0 4
55578: PPUSH
55579: EMPTY
55580: PPUSH
55581: CALL_OW 1
55585: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55586: LD_ADDR_EXP 95
55590: PUSH
55591: LD_EXP 95
55595: PPUSH
55596: LD_VAR 0 4
55600: PPUSH
55601: EMPTY
55602: PPUSH
55603: CALL_OW 1
55607: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55608: LD_ADDR_EXP 96
55612: PUSH
55613: LD_EXP 96
55617: PPUSH
55618: LD_VAR 0 4
55622: PPUSH
55623: EMPTY
55624: PPUSH
55625: CALL_OW 1
55629: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55630: LD_ADDR_EXP 97
55634: PUSH
55635: LD_EXP 97
55639: PPUSH
55640: LD_VAR 0 4
55644: PPUSH
55645: EMPTY
55646: PPUSH
55647: CALL_OW 1
55651: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55652: LD_ADDR_EXP 98
55656: PUSH
55657: LD_EXP 98
55661: PPUSH
55662: LD_VAR 0 4
55666: PPUSH
55667: EMPTY
55668: PPUSH
55669: CALL_OW 1
55673: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55674: LD_ADDR_EXP 99
55678: PUSH
55679: LD_EXP 99
55683: PPUSH
55684: LD_VAR 0 4
55688: PPUSH
55689: EMPTY
55690: PPUSH
55691: CALL_OW 1
55695: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55696: LD_ADDR_EXP 100
55700: PUSH
55701: LD_EXP 100
55705: PPUSH
55706: LD_VAR 0 4
55710: PPUSH
55711: EMPTY
55712: PPUSH
55713: CALL_OW 1
55717: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
55718: LD_ADDR_EXP 101
55722: PUSH
55723: LD_EXP 101
55727: PPUSH
55728: LD_VAR 0 4
55732: PPUSH
55733: LD_INT 0
55735: PPUSH
55736: CALL_OW 1
55740: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
55741: LD_ADDR_EXP 102
55745: PUSH
55746: LD_EXP 102
55750: PPUSH
55751: LD_VAR 0 4
55755: PPUSH
55756: LD_INT 0
55758: PPUSH
55759: CALL_OW 1
55763: ST_TO_ADDR
// result := base ;
55764: LD_ADDR_VAR 0 3
55768: PUSH
55769: LD_VAR 0 4
55773: ST_TO_ADDR
// end ;
55774: LD_VAR 0 3
55778: RET
// export function MC_Start ( ) ; var i ; begin
55779: LD_INT 0
55781: PPUSH
55782: PPUSH
// for i = 1 to mc_bases do
55783: LD_ADDR_VAR 0 2
55787: PUSH
55788: DOUBLE
55789: LD_INT 1
55791: DEC
55792: ST_TO_ADDR
55793: LD_EXP 59
55797: PUSH
55798: FOR_TO
55799: IFFALSE 56899
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
55801: LD_ADDR_EXP 59
55805: PUSH
55806: LD_EXP 59
55810: PPUSH
55811: LD_VAR 0 2
55815: PPUSH
55816: LD_EXP 59
55820: PUSH
55821: LD_VAR 0 2
55825: ARRAY
55826: PUSH
55827: LD_INT 0
55829: DIFF
55830: PPUSH
55831: CALL_OW 1
55835: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
55836: LD_ADDR_EXP 60
55840: PUSH
55841: LD_EXP 60
55845: PPUSH
55846: LD_VAR 0 2
55850: PPUSH
55851: EMPTY
55852: PPUSH
55853: CALL_OW 1
55857: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
55858: LD_ADDR_EXP 61
55862: PUSH
55863: LD_EXP 61
55867: PPUSH
55868: LD_VAR 0 2
55872: PPUSH
55873: EMPTY
55874: PPUSH
55875: CALL_OW 1
55879: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
55880: LD_ADDR_EXP 62
55884: PUSH
55885: LD_EXP 62
55889: PPUSH
55890: LD_VAR 0 2
55894: PPUSH
55895: EMPTY
55896: PPUSH
55897: CALL_OW 1
55901: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
55902: LD_ADDR_EXP 63
55906: PUSH
55907: LD_EXP 63
55911: PPUSH
55912: LD_VAR 0 2
55916: PPUSH
55917: EMPTY
55918: PUSH
55919: EMPTY
55920: PUSH
55921: EMPTY
55922: LIST
55923: LIST
55924: PPUSH
55925: CALL_OW 1
55929: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
55930: LD_ADDR_EXP 64
55934: PUSH
55935: LD_EXP 64
55939: PPUSH
55940: LD_VAR 0 2
55944: PPUSH
55945: EMPTY
55946: PPUSH
55947: CALL_OW 1
55951: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
55952: LD_ADDR_EXP 91
55956: PUSH
55957: LD_EXP 91
55961: PPUSH
55962: LD_VAR 0 2
55966: PPUSH
55967: EMPTY
55968: PPUSH
55969: CALL_OW 1
55973: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
55974: LD_ADDR_EXP 65
55978: PUSH
55979: LD_EXP 65
55983: PPUSH
55984: LD_VAR 0 2
55988: PPUSH
55989: EMPTY
55990: PPUSH
55991: CALL_OW 1
55995: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
55996: LD_ADDR_EXP 66
56000: PUSH
56001: LD_EXP 66
56005: PPUSH
56006: LD_VAR 0 2
56010: PPUSH
56011: EMPTY
56012: PPUSH
56013: CALL_OW 1
56017: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
56018: LD_ADDR_EXP 67
56022: PUSH
56023: LD_EXP 67
56027: PPUSH
56028: LD_VAR 0 2
56032: PPUSH
56033: LD_EXP 59
56037: PUSH
56038: LD_VAR 0 2
56042: ARRAY
56043: PPUSH
56044: LD_INT 2
56046: PUSH
56047: LD_INT 30
56049: PUSH
56050: LD_INT 32
56052: PUSH
56053: EMPTY
56054: LIST
56055: LIST
56056: PUSH
56057: LD_INT 30
56059: PUSH
56060: LD_INT 33
56062: PUSH
56063: EMPTY
56064: LIST
56065: LIST
56066: PUSH
56067: EMPTY
56068: LIST
56069: LIST
56070: LIST
56071: PPUSH
56072: CALL_OW 72
56076: PPUSH
56077: CALL_OW 1
56081: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
56082: LD_ADDR_EXP 68
56086: PUSH
56087: LD_EXP 68
56091: PPUSH
56092: LD_VAR 0 2
56096: PPUSH
56097: LD_EXP 59
56101: PUSH
56102: LD_VAR 0 2
56106: ARRAY
56107: PPUSH
56108: LD_INT 2
56110: PUSH
56111: LD_INT 30
56113: PUSH
56114: LD_INT 32
56116: PUSH
56117: EMPTY
56118: LIST
56119: LIST
56120: PUSH
56121: LD_INT 30
56123: PUSH
56124: LD_INT 31
56126: PUSH
56127: EMPTY
56128: LIST
56129: LIST
56130: PUSH
56131: EMPTY
56132: LIST
56133: LIST
56134: LIST
56135: PUSH
56136: LD_INT 58
56138: PUSH
56139: EMPTY
56140: LIST
56141: PUSH
56142: EMPTY
56143: LIST
56144: LIST
56145: PPUSH
56146: CALL_OW 72
56150: PPUSH
56151: CALL_OW 1
56155: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
56156: LD_ADDR_EXP 69
56160: PUSH
56161: LD_EXP 69
56165: PPUSH
56166: LD_VAR 0 2
56170: PPUSH
56171: EMPTY
56172: PPUSH
56173: CALL_OW 1
56177: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
56178: LD_ADDR_EXP 73
56182: PUSH
56183: LD_EXP 73
56187: PPUSH
56188: LD_VAR 0 2
56192: PPUSH
56193: EMPTY
56194: PPUSH
56195: CALL_OW 1
56199: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
56200: LD_ADDR_EXP 72
56204: PUSH
56205: LD_EXP 72
56209: PPUSH
56210: LD_VAR 0 2
56214: PPUSH
56215: EMPTY
56216: PPUSH
56217: CALL_OW 1
56221: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
56222: LD_ADDR_EXP 74
56226: PUSH
56227: LD_EXP 74
56231: PPUSH
56232: LD_VAR 0 2
56236: PPUSH
56237: EMPTY
56238: PPUSH
56239: CALL_OW 1
56243: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
56244: LD_ADDR_EXP 75
56248: PUSH
56249: LD_EXP 75
56253: PPUSH
56254: LD_VAR 0 2
56258: PPUSH
56259: EMPTY
56260: PPUSH
56261: CALL_OW 1
56265: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
56266: LD_ADDR_EXP 76
56270: PUSH
56271: LD_EXP 76
56275: PPUSH
56276: LD_VAR 0 2
56280: PPUSH
56281: EMPTY
56282: PPUSH
56283: CALL_OW 1
56287: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
56288: LD_ADDR_EXP 77
56292: PUSH
56293: LD_EXP 77
56297: PPUSH
56298: LD_VAR 0 2
56302: PPUSH
56303: EMPTY
56304: PPUSH
56305: CALL_OW 1
56309: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
56310: LD_ADDR_EXP 78
56314: PUSH
56315: LD_EXP 78
56319: PPUSH
56320: LD_VAR 0 2
56324: PPUSH
56325: EMPTY
56326: PPUSH
56327: CALL_OW 1
56331: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
56332: LD_ADDR_EXP 79
56336: PUSH
56337: LD_EXP 79
56341: PPUSH
56342: LD_VAR 0 2
56346: PPUSH
56347: EMPTY
56348: PPUSH
56349: CALL_OW 1
56353: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
56354: LD_ADDR_EXP 80
56358: PUSH
56359: LD_EXP 80
56363: PPUSH
56364: LD_VAR 0 2
56368: PPUSH
56369: EMPTY
56370: PPUSH
56371: CALL_OW 1
56375: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
56376: LD_ADDR_EXP 81
56380: PUSH
56381: LD_EXP 81
56385: PPUSH
56386: LD_VAR 0 2
56390: PPUSH
56391: EMPTY
56392: PPUSH
56393: CALL_OW 1
56397: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
56398: LD_ADDR_EXP 70
56402: PUSH
56403: LD_EXP 70
56407: PPUSH
56408: LD_VAR 0 2
56412: PPUSH
56413: LD_INT 0
56415: PPUSH
56416: CALL_OW 1
56420: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
56421: LD_ADDR_EXP 83
56425: PUSH
56426: LD_EXP 83
56430: PPUSH
56431: LD_VAR 0 2
56435: PPUSH
56436: LD_INT 0
56438: PPUSH
56439: CALL_OW 1
56443: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
56444: LD_ADDR_EXP 71
56448: PUSH
56449: LD_EXP 71
56453: PPUSH
56454: LD_VAR 0 2
56458: PPUSH
56459: EMPTY
56460: PPUSH
56461: CALL_OW 1
56465: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
56466: LD_ADDR_EXP 82
56470: PUSH
56471: LD_EXP 82
56475: PPUSH
56476: LD_VAR 0 2
56480: PPUSH
56481: LD_INT 0
56483: PPUSH
56484: CALL_OW 1
56488: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
56489: LD_ADDR_EXP 84
56493: PUSH
56494: LD_EXP 84
56498: PPUSH
56499: LD_VAR 0 2
56503: PPUSH
56504: EMPTY
56505: PPUSH
56506: CALL_OW 1
56510: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
56511: LD_ADDR_EXP 87
56515: PUSH
56516: LD_EXP 87
56520: PPUSH
56521: LD_VAR 0 2
56525: PPUSH
56526: LD_INT 0
56528: PPUSH
56529: CALL_OW 1
56533: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
56534: LD_ADDR_EXP 88
56538: PUSH
56539: LD_EXP 88
56543: PPUSH
56544: LD_VAR 0 2
56548: PPUSH
56549: EMPTY
56550: PPUSH
56551: CALL_OW 1
56555: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
56556: LD_ADDR_EXP 89
56560: PUSH
56561: LD_EXP 89
56565: PPUSH
56566: LD_VAR 0 2
56570: PPUSH
56571: EMPTY
56572: PPUSH
56573: CALL_OW 1
56577: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
56578: LD_ADDR_EXP 90
56582: PUSH
56583: LD_EXP 90
56587: PPUSH
56588: LD_VAR 0 2
56592: PPUSH
56593: EMPTY
56594: PPUSH
56595: CALL_OW 1
56599: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
56600: LD_ADDR_EXP 92
56604: PUSH
56605: LD_EXP 92
56609: PPUSH
56610: LD_VAR 0 2
56614: PPUSH
56615: LD_EXP 59
56619: PUSH
56620: LD_VAR 0 2
56624: ARRAY
56625: PPUSH
56626: LD_INT 2
56628: PUSH
56629: LD_INT 30
56631: PUSH
56632: LD_INT 6
56634: PUSH
56635: EMPTY
56636: LIST
56637: LIST
56638: PUSH
56639: LD_INT 30
56641: PUSH
56642: LD_INT 7
56644: PUSH
56645: EMPTY
56646: LIST
56647: LIST
56648: PUSH
56649: LD_INT 30
56651: PUSH
56652: LD_INT 8
56654: PUSH
56655: EMPTY
56656: LIST
56657: LIST
56658: PUSH
56659: EMPTY
56660: LIST
56661: LIST
56662: LIST
56663: LIST
56664: PPUSH
56665: CALL_OW 72
56669: PPUSH
56670: CALL_OW 1
56674: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
56675: LD_ADDR_EXP 93
56679: PUSH
56680: LD_EXP 93
56684: PPUSH
56685: LD_VAR 0 2
56689: PPUSH
56690: EMPTY
56691: PPUSH
56692: CALL_OW 1
56696: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
56697: LD_ADDR_EXP 94
56701: PUSH
56702: LD_EXP 94
56706: PPUSH
56707: LD_VAR 0 2
56711: PPUSH
56712: EMPTY
56713: PPUSH
56714: CALL_OW 1
56718: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
56719: LD_ADDR_EXP 95
56723: PUSH
56724: LD_EXP 95
56728: PPUSH
56729: LD_VAR 0 2
56733: PPUSH
56734: EMPTY
56735: PPUSH
56736: CALL_OW 1
56740: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
56741: LD_ADDR_EXP 96
56745: PUSH
56746: LD_EXP 96
56750: PPUSH
56751: LD_VAR 0 2
56755: PPUSH
56756: EMPTY
56757: PPUSH
56758: CALL_OW 1
56762: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56763: LD_ADDR_EXP 97
56767: PUSH
56768: LD_EXP 97
56772: PPUSH
56773: LD_VAR 0 2
56777: PPUSH
56778: EMPTY
56779: PPUSH
56780: CALL_OW 1
56784: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
56785: LD_ADDR_EXP 98
56789: PUSH
56790: LD_EXP 98
56794: PPUSH
56795: LD_VAR 0 2
56799: PPUSH
56800: EMPTY
56801: PPUSH
56802: CALL_OW 1
56806: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
56807: LD_ADDR_EXP 99
56811: PUSH
56812: LD_EXP 99
56816: PPUSH
56817: LD_VAR 0 2
56821: PPUSH
56822: EMPTY
56823: PPUSH
56824: CALL_OW 1
56828: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
56829: LD_ADDR_EXP 100
56833: PUSH
56834: LD_EXP 100
56838: PPUSH
56839: LD_VAR 0 2
56843: PPUSH
56844: EMPTY
56845: PPUSH
56846: CALL_OW 1
56850: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
56851: LD_ADDR_EXP 101
56855: PUSH
56856: LD_EXP 101
56860: PPUSH
56861: LD_VAR 0 2
56865: PPUSH
56866: LD_INT 0
56868: PPUSH
56869: CALL_OW 1
56873: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
56874: LD_ADDR_EXP 102
56878: PUSH
56879: LD_EXP 102
56883: PPUSH
56884: LD_VAR 0 2
56888: PPUSH
56889: LD_INT 0
56891: PPUSH
56892: CALL_OW 1
56896: ST_TO_ADDR
// end ;
56897: GO 55798
56899: POP
56900: POP
// MC_InitSides ( ) ;
56901: CALL 57187 0 0
// MC_InitResearch ( ) ;
56905: CALL 56926 0 0
// CustomInitMacro ( ) ;
56909: CALL 202 0 0
// skirmish := true ;
56913: LD_ADDR_EXP 57
56917: PUSH
56918: LD_INT 1
56920: ST_TO_ADDR
// end ;
56921: LD_VAR 0 1
56925: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
56926: LD_INT 0
56928: PPUSH
56929: PPUSH
56930: PPUSH
56931: PPUSH
56932: PPUSH
56933: PPUSH
// if not mc_bases then
56934: LD_EXP 59
56938: NOT
56939: IFFALSE 56943
// exit ;
56941: GO 57182
// for i = 1 to 8 do
56943: LD_ADDR_VAR 0 2
56947: PUSH
56948: DOUBLE
56949: LD_INT 1
56951: DEC
56952: ST_TO_ADDR
56953: LD_INT 8
56955: PUSH
56956: FOR_TO
56957: IFFALSE 56983
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
56959: LD_ADDR_EXP 86
56963: PUSH
56964: LD_EXP 86
56968: PPUSH
56969: LD_VAR 0 2
56973: PPUSH
56974: EMPTY
56975: PPUSH
56976: CALL_OW 1
56980: ST_TO_ADDR
56981: GO 56956
56983: POP
56984: POP
// tmp := [ ] ;
56985: LD_ADDR_VAR 0 5
56989: PUSH
56990: EMPTY
56991: ST_TO_ADDR
// for i = 1 to mc_sides do
56992: LD_ADDR_VAR 0 2
56996: PUSH
56997: DOUBLE
56998: LD_INT 1
57000: DEC
57001: ST_TO_ADDR
57002: LD_EXP 85
57006: PUSH
57007: FOR_TO
57008: IFFALSE 57066
// if not mc_sides [ i ] in tmp then
57010: LD_EXP 85
57014: PUSH
57015: LD_VAR 0 2
57019: ARRAY
57020: PUSH
57021: LD_VAR 0 5
57025: IN
57026: NOT
57027: IFFALSE 57064
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
57029: LD_ADDR_VAR 0 5
57033: PUSH
57034: LD_VAR 0 5
57038: PPUSH
57039: LD_VAR 0 5
57043: PUSH
57044: LD_INT 1
57046: PLUS
57047: PPUSH
57048: LD_EXP 85
57052: PUSH
57053: LD_VAR 0 2
57057: ARRAY
57058: PPUSH
57059: CALL_OW 2
57063: ST_TO_ADDR
57064: GO 57007
57066: POP
57067: POP
// if not tmp then
57068: LD_VAR 0 5
57072: NOT
57073: IFFALSE 57077
// exit ;
57075: GO 57182
// for j in tmp do
57077: LD_ADDR_VAR 0 3
57081: PUSH
57082: LD_VAR 0 5
57086: PUSH
57087: FOR_IN
57088: IFFALSE 57180
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
57090: LD_ADDR_VAR 0 6
57094: PUSH
57095: LD_INT 22
57097: PUSH
57098: LD_VAR 0 3
57102: PUSH
57103: EMPTY
57104: LIST
57105: LIST
57106: PPUSH
57107: CALL_OW 69
57111: ST_TO_ADDR
// if not un then
57112: LD_VAR 0 6
57116: NOT
57117: IFFALSE 57121
// continue ;
57119: GO 57087
// nation := GetNation ( un [ 1 ] ) ;
57121: LD_ADDR_VAR 0 4
57125: PUSH
57126: LD_VAR 0 6
57130: PUSH
57131: LD_INT 1
57133: ARRAY
57134: PPUSH
57135: CALL_OW 248
57139: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
57140: LD_ADDR_EXP 86
57144: PUSH
57145: LD_EXP 86
57149: PPUSH
57150: LD_VAR 0 3
57154: PPUSH
57155: LD_VAR 0 3
57159: PPUSH
57160: LD_VAR 0 4
57164: PPUSH
57165: LD_INT 1
57167: PPUSH
57168: CALL 14803 0 3
57172: PPUSH
57173: CALL_OW 1
57177: ST_TO_ADDR
// end ;
57178: GO 57087
57180: POP
57181: POP
// end ;
57182: LD_VAR 0 1
57186: RET
// export function MC_InitSides ( ) ; var i ; begin
57187: LD_INT 0
57189: PPUSH
57190: PPUSH
// if not mc_bases then
57191: LD_EXP 59
57195: NOT
57196: IFFALSE 57200
// exit ;
57198: GO 57274
// for i = 1 to mc_bases do
57200: LD_ADDR_VAR 0 2
57204: PUSH
57205: DOUBLE
57206: LD_INT 1
57208: DEC
57209: ST_TO_ADDR
57210: LD_EXP 59
57214: PUSH
57215: FOR_TO
57216: IFFALSE 57272
// if mc_bases [ i ] then
57218: LD_EXP 59
57222: PUSH
57223: LD_VAR 0 2
57227: ARRAY
57228: IFFALSE 57270
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
57230: LD_ADDR_EXP 85
57234: PUSH
57235: LD_EXP 85
57239: PPUSH
57240: LD_VAR 0 2
57244: PPUSH
57245: LD_EXP 59
57249: PUSH
57250: LD_VAR 0 2
57254: ARRAY
57255: PUSH
57256: LD_INT 1
57258: ARRAY
57259: PPUSH
57260: CALL_OW 255
57264: PPUSH
57265: CALL_OW 1
57269: ST_TO_ADDR
57270: GO 57215
57272: POP
57273: POP
// end ;
57274: LD_VAR 0 1
57278: RET
// every 0 0$03 trigger skirmish do
57279: LD_EXP 57
57283: IFFALSE 57437
57285: GO 57287
57287: DISABLE
// begin enable ;
57288: ENABLE
// MC_CheckBuildings ( ) ;
57289: CALL 61935 0 0
// MC_CheckPeopleLife ( ) ;
57293: CALL 62096 0 0
// RaiseSailEvent ( 100 ) ;
57297: LD_INT 100
57299: PPUSH
57300: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
57304: LD_INT 103
57306: PPUSH
57307: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
57311: LD_INT 104
57313: PPUSH
57314: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
57318: LD_INT 105
57320: PPUSH
57321: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
57325: LD_INT 106
57327: PPUSH
57328: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
57332: LD_INT 107
57334: PPUSH
57335: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
57339: LD_INT 108
57341: PPUSH
57342: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
57346: LD_INT 109
57348: PPUSH
57349: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
57353: LD_INT 110
57355: PPUSH
57356: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
57360: LD_INT 111
57362: PPUSH
57363: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
57367: LD_INT 112
57369: PPUSH
57370: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
57374: LD_INT 113
57376: PPUSH
57377: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
57381: LD_INT 120
57383: PPUSH
57384: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
57388: LD_INT 121
57390: PPUSH
57391: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
57395: LD_INT 122
57397: PPUSH
57398: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
57402: LD_INT 123
57404: PPUSH
57405: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
57409: LD_INT 124
57411: PPUSH
57412: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
57416: LD_INT 125
57418: PPUSH
57419: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
57423: LD_INT 126
57425: PPUSH
57426: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
57430: LD_INT 200
57432: PPUSH
57433: CALL_OW 427
// end ;
57437: END
// on SailEvent ( event ) do begin if event < 100 then
57438: LD_VAR 0 1
57442: PUSH
57443: LD_INT 100
57445: LESS
57446: IFFALSE 57457
// CustomEvent ( event ) ;
57448: LD_VAR 0 1
57452: PPUSH
57453: CALL 13461 0 1
// if event = 100 then
57457: LD_VAR 0 1
57461: PUSH
57462: LD_INT 100
57464: EQUAL
57465: IFFALSE 57471
// MC_ClassManager ( ) ;
57467: CALL 57863 0 0
// if event = 101 then
57471: LD_VAR 0 1
57475: PUSH
57476: LD_INT 101
57478: EQUAL
57479: IFFALSE 57485
// MC_RepairBuildings ( ) ;
57481: CALL 62681 0 0
// if event = 102 then
57485: LD_VAR 0 1
57489: PUSH
57490: LD_INT 102
57492: EQUAL
57493: IFFALSE 57499
// MC_Heal ( ) ;
57495: CALL 63588 0 0
// if event = 103 then
57499: LD_VAR 0 1
57503: PUSH
57504: LD_INT 103
57506: EQUAL
57507: IFFALSE 57513
// MC_Build ( ) ;
57509: CALL 64010 0 0
// if event = 104 then
57513: LD_VAR 0 1
57517: PUSH
57518: LD_INT 104
57520: EQUAL
57521: IFFALSE 57527
// MC_TurretWeapon ( ) ;
57523: CALL 65651 0 0
// if event = 105 then
57527: LD_VAR 0 1
57531: PUSH
57532: LD_INT 105
57534: EQUAL
57535: IFFALSE 57541
// MC_BuildUpgrade ( ) ;
57537: CALL 65202 0 0
// if event = 106 then
57541: LD_VAR 0 1
57545: PUSH
57546: LD_INT 106
57548: EQUAL
57549: IFFALSE 57555
// MC_PlantMines ( ) ;
57551: CALL 66081 0 0
// if event = 107 then
57555: LD_VAR 0 1
57559: PUSH
57560: LD_INT 107
57562: EQUAL
57563: IFFALSE 57569
// MC_CollectCrates ( ) ;
57565: CALL 66872 0 0
// if event = 108 then
57569: LD_VAR 0 1
57573: PUSH
57574: LD_INT 108
57576: EQUAL
57577: IFFALSE 57583
// MC_LinkRemoteControl ( ) ;
57579: CALL 68722 0 0
// if event = 109 then
57583: LD_VAR 0 1
57587: PUSH
57588: LD_INT 109
57590: EQUAL
57591: IFFALSE 57597
// MC_ProduceVehicle ( ) ;
57593: CALL 68903 0 0
// if event = 110 then
57597: LD_VAR 0 1
57601: PUSH
57602: LD_INT 110
57604: EQUAL
57605: IFFALSE 57611
// MC_SendAttack ( ) ;
57607: CALL 69369 0 0
// if event = 111 then
57611: LD_VAR 0 1
57615: PUSH
57616: LD_INT 111
57618: EQUAL
57619: IFFALSE 57625
// MC_Defend ( ) ;
57621: CALL 69477 0 0
// if event = 112 then
57625: LD_VAR 0 1
57629: PUSH
57630: LD_INT 112
57632: EQUAL
57633: IFFALSE 57639
// MC_Research ( ) ;
57635: CALL 70210 0 0
// if event = 113 then
57639: LD_VAR 0 1
57643: PUSH
57644: LD_INT 113
57646: EQUAL
57647: IFFALSE 57653
// MC_MinesTrigger ( ) ;
57649: CALL 71324 0 0
// if event = 120 then
57653: LD_VAR 0 1
57657: PUSH
57658: LD_INT 120
57660: EQUAL
57661: IFFALSE 57667
// MC_RepairVehicle ( ) ;
57663: CALL 71423 0 0
// if event = 121 then
57667: LD_VAR 0 1
57671: PUSH
57672: LD_INT 121
57674: EQUAL
57675: IFFALSE 57681
// MC_TameApe ( ) ;
57677: CALL 72164 0 0
// if event = 122 then
57681: LD_VAR 0 1
57685: PUSH
57686: LD_INT 122
57688: EQUAL
57689: IFFALSE 57695
// MC_ChangeApeClass ( ) ;
57691: CALL 72993 0 0
// if event = 123 then
57695: LD_VAR 0 1
57699: PUSH
57700: LD_INT 123
57702: EQUAL
57703: IFFALSE 57709
// MC_Bazooka ( ) ;
57705: CALL 73643 0 0
// if event = 124 then
57709: LD_VAR 0 1
57713: PUSH
57714: LD_INT 124
57716: EQUAL
57717: IFFALSE 57723
// MC_TeleportExit ( ) ;
57719: CALL 73841 0 0
// if event = 125 then
57723: LD_VAR 0 1
57727: PUSH
57728: LD_INT 125
57730: EQUAL
57731: IFFALSE 57737
// MC_Deposits ( ) ;
57733: CALL 74488 0 0
// if event = 126 then
57737: LD_VAR 0 1
57741: PUSH
57742: LD_INT 126
57744: EQUAL
57745: IFFALSE 57751
// MC_RemoteDriver ( ) ;
57747: CALL 75113 0 0
// if event = 200 then
57751: LD_VAR 0 1
57755: PUSH
57756: LD_INT 200
57758: EQUAL
57759: IFFALSE 57765
// MC_Idle ( ) ;
57761: CALL 77062 0 0
// end ;
57765: PPOPN 1
57767: END
// export function MC_Reset ( base , tag ) ; var i ; begin
57768: LD_INT 0
57770: PPUSH
57771: PPUSH
// if not mc_bases [ base ] or not tag then
57772: LD_EXP 59
57776: PUSH
57777: LD_VAR 0 1
57781: ARRAY
57782: NOT
57783: PUSH
57784: LD_VAR 0 2
57788: NOT
57789: OR
57790: IFFALSE 57794
// exit ;
57792: GO 57858
// for i in mc_bases [ base ] union mc_ape [ base ] do
57794: LD_ADDR_VAR 0 4
57798: PUSH
57799: LD_EXP 59
57803: PUSH
57804: LD_VAR 0 1
57808: ARRAY
57809: PUSH
57810: LD_EXP 88
57814: PUSH
57815: LD_VAR 0 1
57819: ARRAY
57820: UNION
57821: PUSH
57822: FOR_IN
57823: IFFALSE 57856
// if GetTag ( i ) = tag then
57825: LD_VAR 0 4
57829: PPUSH
57830: CALL_OW 110
57834: PUSH
57835: LD_VAR 0 2
57839: EQUAL
57840: IFFALSE 57854
// SetTag ( i , 0 ) ;
57842: LD_VAR 0 4
57846: PPUSH
57847: LD_INT 0
57849: PPUSH
57850: CALL_OW 109
57854: GO 57822
57856: POP
57857: POP
// end ;
57858: LD_VAR 0 3
57862: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
57863: LD_INT 0
57865: PPUSH
57866: PPUSH
57867: PPUSH
57868: PPUSH
57869: PPUSH
57870: PPUSH
57871: PPUSH
57872: PPUSH
// if not mc_bases then
57873: LD_EXP 59
57877: NOT
57878: IFFALSE 57882
// exit ;
57880: GO 58340
// for i = 1 to mc_bases do
57882: LD_ADDR_VAR 0 2
57886: PUSH
57887: DOUBLE
57888: LD_INT 1
57890: DEC
57891: ST_TO_ADDR
57892: LD_EXP 59
57896: PUSH
57897: FOR_TO
57898: IFFALSE 58338
// begin tmp := MC_ClassCheckReq ( i ) ;
57900: LD_ADDR_VAR 0 4
57904: PUSH
57905: LD_VAR 0 2
57909: PPUSH
57910: CALL 58345 0 1
57914: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
57915: LD_ADDR_EXP 100
57919: PUSH
57920: LD_EXP 100
57924: PPUSH
57925: LD_VAR 0 2
57929: PPUSH
57930: LD_VAR 0 4
57934: PPUSH
57935: CALL_OW 1
57939: ST_TO_ADDR
// if not tmp then
57940: LD_VAR 0 4
57944: NOT
57945: IFFALSE 57949
// continue ;
57947: GO 57897
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
57949: LD_ADDR_VAR 0 6
57953: PUSH
57954: LD_EXP 59
57958: PUSH
57959: LD_VAR 0 2
57963: ARRAY
57964: PPUSH
57965: LD_INT 2
57967: PUSH
57968: LD_INT 30
57970: PUSH
57971: LD_INT 4
57973: PUSH
57974: EMPTY
57975: LIST
57976: LIST
57977: PUSH
57978: LD_INT 30
57980: PUSH
57981: LD_INT 5
57983: PUSH
57984: EMPTY
57985: LIST
57986: LIST
57987: PUSH
57988: EMPTY
57989: LIST
57990: LIST
57991: LIST
57992: PPUSH
57993: CALL_OW 72
57997: PUSH
57998: LD_EXP 59
58002: PUSH
58003: LD_VAR 0 2
58007: ARRAY
58008: PPUSH
58009: LD_INT 2
58011: PUSH
58012: LD_INT 30
58014: PUSH
58015: LD_INT 0
58017: PUSH
58018: EMPTY
58019: LIST
58020: LIST
58021: PUSH
58022: LD_INT 30
58024: PUSH
58025: LD_INT 1
58027: PUSH
58028: EMPTY
58029: LIST
58030: LIST
58031: PUSH
58032: EMPTY
58033: LIST
58034: LIST
58035: LIST
58036: PPUSH
58037: CALL_OW 72
58041: PUSH
58042: LD_EXP 59
58046: PUSH
58047: LD_VAR 0 2
58051: ARRAY
58052: PPUSH
58053: LD_INT 30
58055: PUSH
58056: LD_INT 3
58058: PUSH
58059: EMPTY
58060: LIST
58061: LIST
58062: PPUSH
58063: CALL_OW 72
58067: PUSH
58068: LD_EXP 59
58072: PUSH
58073: LD_VAR 0 2
58077: ARRAY
58078: PPUSH
58079: LD_INT 2
58081: PUSH
58082: LD_INT 30
58084: PUSH
58085: LD_INT 6
58087: PUSH
58088: EMPTY
58089: LIST
58090: LIST
58091: PUSH
58092: LD_INT 30
58094: PUSH
58095: LD_INT 7
58097: PUSH
58098: EMPTY
58099: LIST
58100: LIST
58101: PUSH
58102: LD_INT 30
58104: PUSH
58105: LD_INT 8
58107: PUSH
58108: EMPTY
58109: LIST
58110: LIST
58111: PUSH
58112: EMPTY
58113: LIST
58114: LIST
58115: LIST
58116: LIST
58117: PPUSH
58118: CALL_OW 72
58122: PUSH
58123: EMPTY
58124: LIST
58125: LIST
58126: LIST
58127: LIST
58128: ST_TO_ADDR
// for j = 1 to 4 do
58129: LD_ADDR_VAR 0 3
58133: PUSH
58134: DOUBLE
58135: LD_INT 1
58137: DEC
58138: ST_TO_ADDR
58139: LD_INT 4
58141: PUSH
58142: FOR_TO
58143: IFFALSE 58334
// begin if not tmp [ j ] then
58145: LD_VAR 0 4
58149: PUSH
58150: LD_VAR 0 3
58154: ARRAY
58155: NOT
58156: IFFALSE 58160
// continue ;
58158: GO 58142
// for p in tmp [ j ] do
58160: LD_ADDR_VAR 0 5
58164: PUSH
58165: LD_VAR 0 4
58169: PUSH
58170: LD_VAR 0 3
58174: ARRAY
58175: PUSH
58176: FOR_IN
58177: IFFALSE 58330
// begin if not b [ j ] then
58179: LD_VAR 0 6
58183: PUSH
58184: LD_VAR 0 3
58188: ARRAY
58189: NOT
58190: IFFALSE 58194
// break ;
58192: GO 58330
// e := 0 ;
58194: LD_ADDR_VAR 0 7
58198: PUSH
58199: LD_INT 0
58201: ST_TO_ADDR
// for k in b [ j ] do
58202: LD_ADDR_VAR 0 8
58206: PUSH
58207: LD_VAR 0 6
58211: PUSH
58212: LD_VAR 0 3
58216: ARRAY
58217: PUSH
58218: FOR_IN
58219: IFFALSE 58246
// if IsNotFull ( k ) then
58221: LD_VAR 0 8
58225: PPUSH
58226: CALL 16956 0 1
58230: IFFALSE 58244
// begin e := k ;
58232: LD_ADDR_VAR 0 7
58236: PUSH
58237: LD_VAR 0 8
58241: ST_TO_ADDR
// break ;
58242: GO 58246
// end ;
58244: GO 58218
58246: POP
58247: POP
// if e and not UnitGoingToBuilding ( p , e ) then
58248: LD_VAR 0 7
58252: PUSH
58253: LD_VAR 0 5
58257: PPUSH
58258: LD_VAR 0 7
58262: PPUSH
58263: CALL 50120 0 2
58267: NOT
58268: AND
58269: IFFALSE 58328
// begin if IsInUnit ( p ) then
58271: LD_VAR 0 5
58275: PPUSH
58276: CALL_OW 310
58280: IFFALSE 58291
// ComExitBuilding ( p ) ;
58282: LD_VAR 0 5
58286: PPUSH
58287: CALL_OW 122
// ComEnterUnit ( p , e ) ;
58291: LD_VAR 0 5
58295: PPUSH
58296: LD_VAR 0 7
58300: PPUSH
58301: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
58305: LD_VAR 0 5
58309: PPUSH
58310: LD_VAR 0 3
58314: PPUSH
58315: CALL_OW 183
// AddComExitBuilding ( p ) ;
58319: LD_VAR 0 5
58323: PPUSH
58324: CALL_OW 182
// end ; end ;
58328: GO 58176
58330: POP
58331: POP
// end ;
58332: GO 58142
58334: POP
58335: POP
// end ;
58336: GO 57897
58338: POP
58339: POP
// end ;
58340: LD_VAR 0 1
58344: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
58345: LD_INT 0
58347: PPUSH
58348: PPUSH
58349: PPUSH
58350: PPUSH
58351: PPUSH
58352: PPUSH
58353: PPUSH
58354: PPUSH
58355: PPUSH
58356: PPUSH
58357: PPUSH
58358: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
58359: LD_VAR 0 1
58363: NOT
58364: PUSH
58365: LD_EXP 59
58369: PUSH
58370: LD_VAR 0 1
58374: ARRAY
58375: NOT
58376: OR
58377: PUSH
58378: LD_EXP 59
58382: PUSH
58383: LD_VAR 0 1
58387: ARRAY
58388: PPUSH
58389: LD_INT 2
58391: PUSH
58392: LD_INT 30
58394: PUSH
58395: LD_INT 0
58397: PUSH
58398: EMPTY
58399: LIST
58400: LIST
58401: PUSH
58402: LD_INT 30
58404: PUSH
58405: LD_INT 1
58407: PUSH
58408: EMPTY
58409: LIST
58410: LIST
58411: PUSH
58412: EMPTY
58413: LIST
58414: LIST
58415: LIST
58416: PPUSH
58417: CALL_OW 72
58421: NOT
58422: OR
58423: IFFALSE 58427
// exit ;
58425: GO 61930
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58427: LD_ADDR_VAR 0 4
58431: PUSH
58432: LD_EXP 59
58436: PUSH
58437: LD_VAR 0 1
58441: ARRAY
58442: PPUSH
58443: LD_INT 2
58445: PUSH
58446: LD_INT 25
58448: PUSH
58449: LD_INT 1
58451: PUSH
58452: EMPTY
58453: LIST
58454: LIST
58455: PUSH
58456: LD_INT 25
58458: PUSH
58459: LD_INT 2
58461: PUSH
58462: EMPTY
58463: LIST
58464: LIST
58465: PUSH
58466: LD_INT 25
58468: PUSH
58469: LD_INT 3
58471: PUSH
58472: EMPTY
58473: LIST
58474: LIST
58475: PUSH
58476: LD_INT 25
58478: PUSH
58479: LD_INT 4
58481: PUSH
58482: EMPTY
58483: LIST
58484: LIST
58485: PUSH
58486: LD_INT 25
58488: PUSH
58489: LD_INT 5
58491: PUSH
58492: EMPTY
58493: LIST
58494: LIST
58495: PUSH
58496: LD_INT 25
58498: PUSH
58499: LD_INT 8
58501: PUSH
58502: EMPTY
58503: LIST
58504: LIST
58505: PUSH
58506: LD_INT 25
58508: PUSH
58509: LD_INT 9
58511: PUSH
58512: EMPTY
58513: LIST
58514: LIST
58515: PUSH
58516: EMPTY
58517: LIST
58518: LIST
58519: LIST
58520: LIST
58521: LIST
58522: LIST
58523: LIST
58524: LIST
58525: PPUSH
58526: CALL_OW 72
58530: ST_TO_ADDR
// if not tmp then
58531: LD_VAR 0 4
58535: NOT
58536: IFFALSE 58540
// exit ;
58538: GO 61930
// for i in tmp do
58540: LD_ADDR_VAR 0 3
58544: PUSH
58545: LD_VAR 0 4
58549: PUSH
58550: FOR_IN
58551: IFFALSE 58582
// if GetTag ( i ) then
58553: LD_VAR 0 3
58557: PPUSH
58558: CALL_OW 110
58562: IFFALSE 58580
// tmp := tmp diff i ;
58564: LD_ADDR_VAR 0 4
58568: PUSH
58569: LD_VAR 0 4
58573: PUSH
58574: LD_VAR 0 3
58578: DIFF
58579: ST_TO_ADDR
58580: GO 58550
58582: POP
58583: POP
// if not tmp then
58584: LD_VAR 0 4
58588: NOT
58589: IFFALSE 58593
// exit ;
58591: GO 61930
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58593: LD_ADDR_VAR 0 5
58597: PUSH
58598: LD_EXP 59
58602: PUSH
58603: LD_VAR 0 1
58607: ARRAY
58608: PPUSH
58609: LD_INT 2
58611: PUSH
58612: LD_INT 25
58614: PUSH
58615: LD_INT 1
58617: PUSH
58618: EMPTY
58619: LIST
58620: LIST
58621: PUSH
58622: LD_INT 25
58624: PUSH
58625: LD_INT 5
58627: PUSH
58628: EMPTY
58629: LIST
58630: LIST
58631: PUSH
58632: LD_INT 25
58634: PUSH
58635: LD_INT 8
58637: PUSH
58638: EMPTY
58639: LIST
58640: LIST
58641: PUSH
58642: LD_INT 25
58644: PUSH
58645: LD_INT 9
58647: PUSH
58648: EMPTY
58649: LIST
58650: LIST
58651: PUSH
58652: EMPTY
58653: LIST
58654: LIST
58655: LIST
58656: LIST
58657: LIST
58658: PPUSH
58659: CALL_OW 72
58663: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
58664: LD_ADDR_VAR 0 6
58668: PUSH
58669: LD_EXP 59
58673: PUSH
58674: LD_VAR 0 1
58678: ARRAY
58679: PPUSH
58680: LD_INT 25
58682: PUSH
58683: LD_INT 2
58685: PUSH
58686: EMPTY
58687: LIST
58688: LIST
58689: PPUSH
58690: CALL_OW 72
58694: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
58695: LD_ADDR_VAR 0 7
58699: PUSH
58700: LD_EXP 59
58704: PUSH
58705: LD_VAR 0 1
58709: ARRAY
58710: PPUSH
58711: LD_INT 25
58713: PUSH
58714: LD_INT 3
58716: PUSH
58717: EMPTY
58718: LIST
58719: LIST
58720: PPUSH
58721: CALL_OW 72
58725: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
58726: LD_ADDR_VAR 0 8
58730: PUSH
58731: LD_EXP 59
58735: PUSH
58736: LD_VAR 0 1
58740: ARRAY
58741: PPUSH
58742: LD_INT 25
58744: PUSH
58745: LD_INT 4
58747: PUSH
58748: EMPTY
58749: LIST
58750: LIST
58751: PUSH
58752: LD_INT 24
58754: PUSH
58755: LD_INT 251
58757: PUSH
58758: EMPTY
58759: LIST
58760: LIST
58761: PUSH
58762: EMPTY
58763: LIST
58764: LIST
58765: PPUSH
58766: CALL_OW 72
58770: ST_TO_ADDR
// if mc_is_defending [ base ] then
58771: LD_EXP 102
58775: PUSH
58776: LD_VAR 0 1
58780: ARRAY
58781: IFFALSE 59242
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
58783: LD_ADDR_EXP 101
58787: PUSH
58788: LD_EXP 101
58792: PPUSH
58793: LD_VAR 0 1
58797: PPUSH
58798: LD_INT 4
58800: PPUSH
58801: CALL_OW 1
58805: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
58806: LD_ADDR_VAR 0 12
58810: PUSH
58811: LD_EXP 59
58815: PUSH
58816: LD_VAR 0 1
58820: ARRAY
58821: PPUSH
58822: LD_INT 2
58824: PUSH
58825: LD_INT 30
58827: PUSH
58828: LD_INT 4
58830: PUSH
58831: EMPTY
58832: LIST
58833: LIST
58834: PUSH
58835: LD_INT 30
58837: PUSH
58838: LD_INT 5
58840: PUSH
58841: EMPTY
58842: LIST
58843: LIST
58844: PUSH
58845: EMPTY
58846: LIST
58847: LIST
58848: LIST
58849: PPUSH
58850: CALL_OW 72
58854: ST_TO_ADDR
// if not b then
58855: LD_VAR 0 12
58859: NOT
58860: IFFALSE 58864
// exit ;
58862: GO 61930
// p := [ ] ;
58864: LD_ADDR_VAR 0 11
58868: PUSH
58869: EMPTY
58870: ST_TO_ADDR
// if sci >= 2 then
58871: LD_VAR 0 8
58875: PUSH
58876: LD_INT 2
58878: GREATEREQUAL
58879: IFFALSE 58910
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
58881: LD_ADDR_VAR 0 8
58885: PUSH
58886: LD_VAR 0 8
58890: PUSH
58891: LD_INT 1
58893: ARRAY
58894: PUSH
58895: LD_VAR 0 8
58899: PUSH
58900: LD_INT 2
58902: ARRAY
58903: PUSH
58904: EMPTY
58905: LIST
58906: LIST
58907: ST_TO_ADDR
58908: GO 58971
// if sci = 1 then
58910: LD_VAR 0 8
58914: PUSH
58915: LD_INT 1
58917: EQUAL
58918: IFFALSE 58939
// sci := [ sci [ 1 ] ] else
58920: LD_ADDR_VAR 0 8
58924: PUSH
58925: LD_VAR 0 8
58929: PUSH
58930: LD_INT 1
58932: ARRAY
58933: PUSH
58934: EMPTY
58935: LIST
58936: ST_TO_ADDR
58937: GO 58971
// if sci = 0 then
58939: LD_VAR 0 8
58943: PUSH
58944: LD_INT 0
58946: EQUAL
58947: IFFALSE 58971
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
58949: LD_ADDR_VAR 0 11
58953: PUSH
58954: LD_VAR 0 4
58958: PPUSH
58959: LD_INT 4
58961: PPUSH
58962: CALL 49983 0 2
58966: PUSH
58967: LD_INT 1
58969: ARRAY
58970: ST_TO_ADDR
// if eng > 4 then
58971: LD_VAR 0 6
58975: PUSH
58976: LD_INT 4
58978: GREATER
58979: IFFALSE 59025
// for i = eng downto 4 do
58981: LD_ADDR_VAR 0 3
58985: PUSH
58986: DOUBLE
58987: LD_VAR 0 6
58991: INC
58992: ST_TO_ADDR
58993: LD_INT 4
58995: PUSH
58996: FOR_DOWNTO
58997: IFFALSE 59023
// eng := eng diff eng [ i ] ;
58999: LD_ADDR_VAR 0 6
59003: PUSH
59004: LD_VAR 0 6
59008: PUSH
59009: LD_VAR 0 6
59013: PUSH
59014: LD_VAR 0 3
59018: ARRAY
59019: DIFF
59020: ST_TO_ADDR
59021: GO 58996
59023: POP
59024: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
59025: LD_ADDR_VAR 0 4
59029: PUSH
59030: LD_VAR 0 4
59034: PUSH
59035: LD_VAR 0 5
59039: PUSH
59040: LD_VAR 0 6
59044: UNION
59045: PUSH
59046: LD_VAR 0 7
59050: UNION
59051: PUSH
59052: LD_VAR 0 8
59056: UNION
59057: DIFF
59058: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
59059: LD_ADDR_VAR 0 13
59063: PUSH
59064: LD_EXP 59
59068: PUSH
59069: LD_VAR 0 1
59073: ARRAY
59074: PPUSH
59075: LD_INT 2
59077: PUSH
59078: LD_INT 30
59080: PUSH
59081: LD_INT 32
59083: PUSH
59084: EMPTY
59085: LIST
59086: LIST
59087: PUSH
59088: LD_INT 30
59090: PUSH
59091: LD_INT 31
59093: PUSH
59094: EMPTY
59095: LIST
59096: LIST
59097: PUSH
59098: EMPTY
59099: LIST
59100: LIST
59101: LIST
59102: PPUSH
59103: CALL_OW 72
59107: PUSH
59108: LD_EXP 59
59112: PUSH
59113: LD_VAR 0 1
59117: ARRAY
59118: PPUSH
59119: LD_INT 2
59121: PUSH
59122: LD_INT 30
59124: PUSH
59125: LD_INT 4
59127: PUSH
59128: EMPTY
59129: LIST
59130: LIST
59131: PUSH
59132: LD_INT 30
59134: PUSH
59135: LD_INT 5
59137: PUSH
59138: EMPTY
59139: LIST
59140: LIST
59141: PUSH
59142: EMPTY
59143: LIST
59144: LIST
59145: LIST
59146: PPUSH
59147: CALL_OW 72
59151: PUSH
59152: LD_INT 6
59154: MUL
59155: PLUS
59156: ST_TO_ADDR
// if bcount < tmp then
59157: LD_VAR 0 13
59161: PUSH
59162: LD_VAR 0 4
59166: LESS
59167: IFFALSE 59213
// for i = tmp downto bcount do
59169: LD_ADDR_VAR 0 3
59173: PUSH
59174: DOUBLE
59175: LD_VAR 0 4
59179: INC
59180: ST_TO_ADDR
59181: LD_VAR 0 13
59185: PUSH
59186: FOR_DOWNTO
59187: IFFALSE 59211
// tmp := Delete ( tmp , tmp ) ;
59189: LD_ADDR_VAR 0 4
59193: PUSH
59194: LD_VAR 0 4
59198: PPUSH
59199: LD_VAR 0 4
59203: PPUSH
59204: CALL_OW 3
59208: ST_TO_ADDR
59209: GO 59186
59211: POP
59212: POP
// result := [ tmp , 0 , 0 , p ] ;
59213: LD_ADDR_VAR 0 2
59217: PUSH
59218: LD_VAR 0 4
59222: PUSH
59223: LD_INT 0
59225: PUSH
59226: LD_INT 0
59228: PUSH
59229: LD_VAR 0 11
59233: PUSH
59234: EMPTY
59235: LIST
59236: LIST
59237: LIST
59238: LIST
59239: ST_TO_ADDR
// exit ;
59240: GO 61930
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59242: LD_EXP 59
59246: PUSH
59247: LD_VAR 0 1
59251: ARRAY
59252: PPUSH
59253: LD_INT 2
59255: PUSH
59256: LD_INT 30
59258: PUSH
59259: LD_INT 6
59261: PUSH
59262: EMPTY
59263: LIST
59264: LIST
59265: PUSH
59266: LD_INT 30
59268: PUSH
59269: LD_INT 7
59271: PUSH
59272: EMPTY
59273: LIST
59274: LIST
59275: PUSH
59276: LD_INT 30
59278: PUSH
59279: LD_INT 8
59281: PUSH
59282: EMPTY
59283: LIST
59284: LIST
59285: PUSH
59286: EMPTY
59287: LIST
59288: LIST
59289: LIST
59290: LIST
59291: PPUSH
59292: CALL_OW 72
59296: NOT
59297: PUSH
59298: LD_EXP 59
59302: PUSH
59303: LD_VAR 0 1
59307: ARRAY
59308: PPUSH
59309: LD_INT 30
59311: PUSH
59312: LD_INT 3
59314: PUSH
59315: EMPTY
59316: LIST
59317: LIST
59318: PPUSH
59319: CALL_OW 72
59323: NOT
59324: AND
59325: IFFALSE 59397
// begin if eng = tmp then
59327: LD_VAR 0 6
59331: PUSH
59332: LD_VAR 0 4
59336: EQUAL
59337: IFFALSE 59341
// exit ;
59339: GO 61930
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
59341: LD_ADDR_EXP 101
59345: PUSH
59346: LD_EXP 101
59350: PPUSH
59351: LD_VAR 0 1
59355: PPUSH
59356: LD_INT 1
59358: PPUSH
59359: CALL_OW 1
59363: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
59364: LD_ADDR_VAR 0 2
59368: PUSH
59369: LD_INT 0
59371: PUSH
59372: LD_VAR 0 4
59376: PUSH
59377: LD_VAR 0 6
59381: DIFF
59382: PUSH
59383: LD_INT 0
59385: PUSH
59386: LD_INT 0
59388: PUSH
59389: EMPTY
59390: LIST
59391: LIST
59392: LIST
59393: LIST
59394: ST_TO_ADDR
// exit ;
59395: GO 61930
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59397: LD_EXP 86
59401: PUSH
59402: LD_EXP 85
59406: PUSH
59407: LD_VAR 0 1
59411: ARRAY
59412: ARRAY
59413: PUSH
59414: LD_EXP 59
59418: PUSH
59419: LD_VAR 0 1
59423: ARRAY
59424: PPUSH
59425: LD_INT 2
59427: PUSH
59428: LD_INT 30
59430: PUSH
59431: LD_INT 6
59433: PUSH
59434: EMPTY
59435: LIST
59436: LIST
59437: PUSH
59438: LD_INT 30
59440: PUSH
59441: LD_INT 7
59443: PUSH
59444: EMPTY
59445: LIST
59446: LIST
59447: PUSH
59448: LD_INT 30
59450: PUSH
59451: LD_INT 8
59453: PUSH
59454: EMPTY
59455: LIST
59456: LIST
59457: PUSH
59458: EMPTY
59459: LIST
59460: LIST
59461: LIST
59462: LIST
59463: PPUSH
59464: CALL_OW 72
59468: AND
59469: PUSH
59470: LD_EXP 59
59474: PUSH
59475: LD_VAR 0 1
59479: ARRAY
59480: PPUSH
59481: LD_INT 30
59483: PUSH
59484: LD_INT 3
59486: PUSH
59487: EMPTY
59488: LIST
59489: LIST
59490: PPUSH
59491: CALL_OW 72
59495: NOT
59496: AND
59497: IFFALSE 59711
// begin if sci >= 6 then
59499: LD_VAR 0 8
59503: PUSH
59504: LD_INT 6
59506: GREATEREQUAL
59507: IFFALSE 59511
// exit ;
59509: GO 61930
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
59511: LD_ADDR_EXP 101
59515: PUSH
59516: LD_EXP 101
59520: PPUSH
59521: LD_VAR 0 1
59525: PPUSH
59526: LD_INT 2
59528: PPUSH
59529: CALL_OW 1
59533: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
59534: LD_ADDR_VAR 0 9
59538: PUSH
59539: LD_VAR 0 4
59543: PUSH
59544: LD_VAR 0 8
59548: DIFF
59549: PPUSH
59550: LD_INT 4
59552: PPUSH
59553: CALL 49983 0 2
59557: ST_TO_ADDR
// p := [ ] ;
59558: LD_ADDR_VAR 0 11
59562: PUSH
59563: EMPTY
59564: ST_TO_ADDR
// if sci < 6 and sort > 6 then
59565: LD_VAR 0 8
59569: PUSH
59570: LD_INT 6
59572: LESS
59573: PUSH
59574: LD_VAR 0 9
59578: PUSH
59579: LD_INT 6
59581: GREATER
59582: AND
59583: IFFALSE 59664
// begin for i = 1 to 6 - sci do
59585: LD_ADDR_VAR 0 3
59589: PUSH
59590: DOUBLE
59591: LD_INT 1
59593: DEC
59594: ST_TO_ADDR
59595: LD_INT 6
59597: PUSH
59598: LD_VAR 0 8
59602: MINUS
59603: PUSH
59604: FOR_TO
59605: IFFALSE 59660
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
59607: LD_ADDR_VAR 0 11
59611: PUSH
59612: LD_VAR 0 11
59616: PPUSH
59617: LD_VAR 0 11
59621: PUSH
59622: LD_INT 1
59624: PLUS
59625: PPUSH
59626: LD_VAR 0 9
59630: PUSH
59631: LD_INT 1
59633: ARRAY
59634: PPUSH
59635: CALL_OW 2
59639: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
59640: LD_ADDR_VAR 0 9
59644: PUSH
59645: LD_VAR 0 9
59649: PPUSH
59650: LD_INT 1
59652: PPUSH
59653: CALL_OW 3
59657: ST_TO_ADDR
// end ;
59658: GO 59604
59660: POP
59661: POP
// end else
59662: GO 59684
// if sort then
59664: LD_VAR 0 9
59668: IFFALSE 59684
// p := sort [ 1 ] ;
59670: LD_ADDR_VAR 0 11
59674: PUSH
59675: LD_VAR 0 9
59679: PUSH
59680: LD_INT 1
59682: ARRAY
59683: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
59684: LD_ADDR_VAR 0 2
59688: PUSH
59689: LD_INT 0
59691: PUSH
59692: LD_INT 0
59694: PUSH
59695: LD_INT 0
59697: PUSH
59698: LD_VAR 0 11
59702: PUSH
59703: EMPTY
59704: LIST
59705: LIST
59706: LIST
59707: LIST
59708: ST_TO_ADDR
// exit ;
59709: GO 61930
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59711: LD_EXP 86
59715: PUSH
59716: LD_EXP 85
59720: PUSH
59721: LD_VAR 0 1
59725: ARRAY
59726: ARRAY
59727: PUSH
59728: LD_EXP 59
59732: PUSH
59733: LD_VAR 0 1
59737: ARRAY
59738: PPUSH
59739: LD_INT 2
59741: PUSH
59742: LD_INT 30
59744: PUSH
59745: LD_INT 6
59747: PUSH
59748: EMPTY
59749: LIST
59750: LIST
59751: PUSH
59752: LD_INT 30
59754: PUSH
59755: LD_INT 7
59757: PUSH
59758: EMPTY
59759: LIST
59760: LIST
59761: PUSH
59762: LD_INT 30
59764: PUSH
59765: LD_INT 8
59767: PUSH
59768: EMPTY
59769: LIST
59770: LIST
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: LIST
59776: LIST
59777: PPUSH
59778: CALL_OW 72
59782: AND
59783: PUSH
59784: LD_EXP 59
59788: PUSH
59789: LD_VAR 0 1
59793: ARRAY
59794: PPUSH
59795: LD_INT 30
59797: PUSH
59798: LD_INT 3
59800: PUSH
59801: EMPTY
59802: LIST
59803: LIST
59804: PPUSH
59805: CALL_OW 72
59809: AND
59810: IFFALSE 60544
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
59812: LD_ADDR_EXP 101
59816: PUSH
59817: LD_EXP 101
59821: PPUSH
59822: LD_VAR 0 1
59826: PPUSH
59827: LD_INT 3
59829: PPUSH
59830: CALL_OW 1
59834: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59835: LD_ADDR_VAR 0 2
59839: PUSH
59840: LD_INT 0
59842: PUSH
59843: LD_INT 0
59845: PUSH
59846: LD_INT 0
59848: PUSH
59849: LD_INT 0
59851: PUSH
59852: EMPTY
59853: LIST
59854: LIST
59855: LIST
59856: LIST
59857: ST_TO_ADDR
// if not eng then
59858: LD_VAR 0 6
59862: NOT
59863: IFFALSE 59926
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
59865: LD_ADDR_VAR 0 11
59869: PUSH
59870: LD_VAR 0 4
59874: PPUSH
59875: LD_INT 2
59877: PPUSH
59878: CALL 49983 0 2
59882: PUSH
59883: LD_INT 1
59885: ARRAY
59886: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
59887: LD_ADDR_VAR 0 2
59891: PUSH
59892: LD_VAR 0 2
59896: PPUSH
59897: LD_INT 2
59899: PPUSH
59900: LD_VAR 0 11
59904: PPUSH
59905: CALL_OW 1
59909: ST_TO_ADDR
// tmp := tmp diff p ;
59910: LD_ADDR_VAR 0 4
59914: PUSH
59915: LD_VAR 0 4
59919: PUSH
59920: LD_VAR 0 11
59924: DIFF
59925: ST_TO_ADDR
// end ; if tmp and sci < 6 then
59926: LD_VAR 0 4
59930: PUSH
59931: LD_VAR 0 8
59935: PUSH
59936: LD_INT 6
59938: LESS
59939: AND
59940: IFFALSE 60128
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
59942: LD_ADDR_VAR 0 9
59946: PUSH
59947: LD_VAR 0 4
59951: PUSH
59952: LD_VAR 0 8
59956: PUSH
59957: LD_VAR 0 7
59961: UNION
59962: DIFF
59963: PPUSH
59964: LD_INT 4
59966: PPUSH
59967: CALL 49983 0 2
59971: ST_TO_ADDR
// p := [ ] ;
59972: LD_ADDR_VAR 0 11
59976: PUSH
59977: EMPTY
59978: ST_TO_ADDR
// if sort then
59979: LD_VAR 0 9
59983: IFFALSE 60099
// for i = 1 to 6 - sci do
59985: LD_ADDR_VAR 0 3
59989: PUSH
59990: DOUBLE
59991: LD_INT 1
59993: DEC
59994: ST_TO_ADDR
59995: LD_INT 6
59997: PUSH
59998: LD_VAR 0 8
60002: MINUS
60003: PUSH
60004: FOR_TO
60005: IFFALSE 60097
// begin if i = sort then
60007: LD_VAR 0 3
60011: PUSH
60012: LD_VAR 0 9
60016: EQUAL
60017: IFFALSE 60021
// break ;
60019: GO 60097
// if GetClass ( i ) = 4 then
60021: LD_VAR 0 3
60025: PPUSH
60026: CALL_OW 257
60030: PUSH
60031: LD_INT 4
60033: EQUAL
60034: IFFALSE 60038
// continue ;
60036: GO 60004
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60038: LD_ADDR_VAR 0 11
60042: PUSH
60043: LD_VAR 0 11
60047: PPUSH
60048: LD_VAR 0 11
60052: PUSH
60053: LD_INT 1
60055: PLUS
60056: PPUSH
60057: LD_VAR 0 9
60061: PUSH
60062: LD_VAR 0 3
60066: ARRAY
60067: PPUSH
60068: CALL_OW 2
60072: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60073: LD_ADDR_VAR 0 4
60077: PUSH
60078: LD_VAR 0 4
60082: PUSH
60083: LD_VAR 0 9
60087: PUSH
60088: LD_VAR 0 3
60092: ARRAY
60093: DIFF
60094: ST_TO_ADDR
// end ;
60095: GO 60004
60097: POP
60098: POP
// if p then
60099: LD_VAR 0 11
60103: IFFALSE 60128
// result := Replace ( result , 4 , p ) ;
60105: LD_ADDR_VAR 0 2
60109: PUSH
60110: LD_VAR 0 2
60114: PPUSH
60115: LD_INT 4
60117: PPUSH
60118: LD_VAR 0 11
60122: PPUSH
60123: CALL_OW 1
60127: ST_TO_ADDR
// end ; if tmp and mech < 6 then
60128: LD_VAR 0 4
60132: PUSH
60133: LD_VAR 0 7
60137: PUSH
60138: LD_INT 6
60140: LESS
60141: AND
60142: IFFALSE 60330
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
60144: LD_ADDR_VAR 0 9
60148: PUSH
60149: LD_VAR 0 4
60153: PUSH
60154: LD_VAR 0 8
60158: PUSH
60159: LD_VAR 0 7
60163: UNION
60164: DIFF
60165: PPUSH
60166: LD_INT 3
60168: PPUSH
60169: CALL 49983 0 2
60173: ST_TO_ADDR
// p := [ ] ;
60174: LD_ADDR_VAR 0 11
60178: PUSH
60179: EMPTY
60180: ST_TO_ADDR
// if sort then
60181: LD_VAR 0 9
60185: IFFALSE 60301
// for i = 1 to 6 - mech do
60187: LD_ADDR_VAR 0 3
60191: PUSH
60192: DOUBLE
60193: LD_INT 1
60195: DEC
60196: ST_TO_ADDR
60197: LD_INT 6
60199: PUSH
60200: LD_VAR 0 7
60204: MINUS
60205: PUSH
60206: FOR_TO
60207: IFFALSE 60299
// begin if i = sort then
60209: LD_VAR 0 3
60213: PUSH
60214: LD_VAR 0 9
60218: EQUAL
60219: IFFALSE 60223
// break ;
60221: GO 60299
// if GetClass ( i ) = 3 then
60223: LD_VAR 0 3
60227: PPUSH
60228: CALL_OW 257
60232: PUSH
60233: LD_INT 3
60235: EQUAL
60236: IFFALSE 60240
// continue ;
60238: GO 60206
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60240: LD_ADDR_VAR 0 11
60244: PUSH
60245: LD_VAR 0 11
60249: PPUSH
60250: LD_VAR 0 11
60254: PUSH
60255: LD_INT 1
60257: PLUS
60258: PPUSH
60259: LD_VAR 0 9
60263: PUSH
60264: LD_VAR 0 3
60268: ARRAY
60269: PPUSH
60270: CALL_OW 2
60274: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60275: LD_ADDR_VAR 0 4
60279: PUSH
60280: LD_VAR 0 4
60284: PUSH
60285: LD_VAR 0 9
60289: PUSH
60290: LD_VAR 0 3
60294: ARRAY
60295: DIFF
60296: ST_TO_ADDR
// end ;
60297: GO 60206
60299: POP
60300: POP
// if p then
60301: LD_VAR 0 11
60305: IFFALSE 60330
// result := Replace ( result , 3 , p ) ;
60307: LD_ADDR_VAR 0 2
60311: PUSH
60312: LD_VAR 0 2
60316: PPUSH
60317: LD_INT 3
60319: PPUSH
60320: LD_VAR 0 11
60324: PPUSH
60325: CALL_OW 1
60329: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
60330: LD_VAR 0 4
60334: PUSH
60335: LD_INT 6
60337: GREATER
60338: PUSH
60339: LD_VAR 0 6
60343: PUSH
60344: LD_INT 6
60346: LESS
60347: AND
60348: IFFALSE 60542
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
60350: LD_ADDR_VAR 0 9
60354: PUSH
60355: LD_VAR 0 4
60359: PUSH
60360: LD_VAR 0 8
60364: PUSH
60365: LD_VAR 0 7
60369: UNION
60370: PUSH
60371: LD_VAR 0 6
60375: UNION
60376: DIFF
60377: PPUSH
60378: LD_INT 2
60380: PPUSH
60381: CALL 49983 0 2
60385: ST_TO_ADDR
// p := [ ] ;
60386: LD_ADDR_VAR 0 11
60390: PUSH
60391: EMPTY
60392: ST_TO_ADDR
// if sort then
60393: LD_VAR 0 9
60397: IFFALSE 60513
// for i = 1 to 6 - eng do
60399: LD_ADDR_VAR 0 3
60403: PUSH
60404: DOUBLE
60405: LD_INT 1
60407: DEC
60408: ST_TO_ADDR
60409: LD_INT 6
60411: PUSH
60412: LD_VAR 0 6
60416: MINUS
60417: PUSH
60418: FOR_TO
60419: IFFALSE 60511
// begin if i = sort then
60421: LD_VAR 0 3
60425: PUSH
60426: LD_VAR 0 9
60430: EQUAL
60431: IFFALSE 60435
// break ;
60433: GO 60511
// if GetClass ( i ) = 2 then
60435: LD_VAR 0 3
60439: PPUSH
60440: CALL_OW 257
60444: PUSH
60445: LD_INT 2
60447: EQUAL
60448: IFFALSE 60452
// continue ;
60450: GO 60418
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60452: LD_ADDR_VAR 0 11
60456: PUSH
60457: LD_VAR 0 11
60461: PPUSH
60462: LD_VAR 0 11
60466: PUSH
60467: LD_INT 1
60469: PLUS
60470: PPUSH
60471: LD_VAR 0 9
60475: PUSH
60476: LD_VAR 0 3
60480: ARRAY
60481: PPUSH
60482: CALL_OW 2
60486: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60487: LD_ADDR_VAR 0 4
60491: PUSH
60492: LD_VAR 0 4
60496: PUSH
60497: LD_VAR 0 9
60501: PUSH
60502: LD_VAR 0 3
60506: ARRAY
60507: DIFF
60508: ST_TO_ADDR
// end ;
60509: GO 60418
60511: POP
60512: POP
// if p then
60513: LD_VAR 0 11
60517: IFFALSE 60542
// result := Replace ( result , 2 , p ) ;
60519: LD_ADDR_VAR 0 2
60523: PUSH
60524: LD_VAR 0 2
60528: PPUSH
60529: LD_INT 2
60531: PPUSH
60532: LD_VAR 0 11
60536: PPUSH
60537: CALL_OW 1
60541: ST_TO_ADDR
// end ; exit ;
60542: GO 61930
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
60544: LD_EXP 86
60548: PUSH
60549: LD_EXP 85
60553: PUSH
60554: LD_VAR 0 1
60558: ARRAY
60559: ARRAY
60560: NOT
60561: PUSH
60562: LD_EXP 59
60566: PUSH
60567: LD_VAR 0 1
60571: ARRAY
60572: PPUSH
60573: LD_INT 30
60575: PUSH
60576: LD_INT 3
60578: PUSH
60579: EMPTY
60580: LIST
60581: LIST
60582: PPUSH
60583: CALL_OW 72
60587: AND
60588: PUSH
60589: LD_EXP 64
60593: PUSH
60594: LD_VAR 0 1
60598: ARRAY
60599: AND
60600: IFFALSE 61208
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
60602: LD_ADDR_EXP 101
60606: PUSH
60607: LD_EXP 101
60611: PPUSH
60612: LD_VAR 0 1
60616: PPUSH
60617: LD_INT 5
60619: PPUSH
60620: CALL_OW 1
60624: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60625: LD_ADDR_VAR 0 2
60629: PUSH
60630: LD_INT 0
60632: PUSH
60633: LD_INT 0
60635: PUSH
60636: LD_INT 0
60638: PUSH
60639: LD_INT 0
60641: PUSH
60642: EMPTY
60643: LIST
60644: LIST
60645: LIST
60646: LIST
60647: ST_TO_ADDR
// if sci > 1 then
60648: LD_VAR 0 8
60652: PUSH
60653: LD_INT 1
60655: GREATER
60656: IFFALSE 60684
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
60658: LD_ADDR_VAR 0 4
60662: PUSH
60663: LD_VAR 0 4
60667: PUSH
60668: LD_VAR 0 8
60672: PUSH
60673: LD_VAR 0 8
60677: PUSH
60678: LD_INT 1
60680: ARRAY
60681: DIFF
60682: DIFF
60683: ST_TO_ADDR
// if tmp and not sci then
60684: LD_VAR 0 4
60688: PUSH
60689: LD_VAR 0 8
60693: NOT
60694: AND
60695: IFFALSE 60764
// begin sort := SortBySkill ( tmp , 4 ) ;
60697: LD_ADDR_VAR 0 9
60701: PUSH
60702: LD_VAR 0 4
60706: PPUSH
60707: LD_INT 4
60709: PPUSH
60710: CALL 49983 0 2
60714: ST_TO_ADDR
// if sort then
60715: LD_VAR 0 9
60719: IFFALSE 60735
// p := sort [ 1 ] ;
60721: LD_ADDR_VAR 0 11
60725: PUSH
60726: LD_VAR 0 9
60730: PUSH
60731: LD_INT 1
60733: ARRAY
60734: ST_TO_ADDR
// if p then
60735: LD_VAR 0 11
60739: IFFALSE 60764
// result := Replace ( result , 4 , p ) ;
60741: LD_ADDR_VAR 0 2
60745: PUSH
60746: LD_VAR 0 2
60750: PPUSH
60751: LD_INT 4
60753: PPUSH
60754: LD_VAR 0 11
60758: PPUSH
60759: CALL_OW 1
60763: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
60764: LD_ADDR_VAR 0 4
60768: PUSH
60769: LD_VAR 0 4
60773: PUSH
60774: LD_VAR 0 7
60778: DIFF
60779: ST_TO_ADDR
// if tmp and mech < 6 then
60780: LD_VAR 0 4
60784: PUSH
60785: LD_VAR 0 7
60789: PUSH
60790: LD_INT 6
60792: LESS
60793: AND
60794: IFFALSE 60982
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
60796: LD_ADDR_VAR 0 9
60800: PUSH
60801: LD_VAR 0 4
60805: PUSH
60806: LD_VAR 0 8
60810: PUSH
60811: LD_VAR 0 7
60815: UNION
60816: DIFF
60817: PPUSH
60818: LD_INT 3
60820: PPUSH
60821: CALL 49983 0 2
60825: ST_TO_ADDR
// p := [ ] ;
60826: LD_ADDR_VAR 0 11
60830: PUSH
60831: EMPTY
60832: ST_TO_ADDR
// if sort then
60833: LD_VAR 0 9
60837: IFFALSE 60953
// for i = 1 to 6 - mech do
60839: LD_ADDR_VAR 0 3
60843: PUSH
60844: DOUBLE
60845: LD_INT 1
60847: DEC
60848: ST_TO_ADDR
60849: LD_INT 6
60851: PUSH
60852: LD_VAR 0 7
60856: MINUS
60857: PUSH
60858: FOR_TO
60859: IFFALSE 60951
// begin if i = sort then
60861: LD_VAR 0 3
60865: PUSH
60866: LD_VAR 0 9
60870: EQUAL
60871: IFFALSE 60875
// break ;
60873: GO 60951
// if GetClass ( i ) = 3 then
60875: LD_VAR 0 3
60879: PPUSH
60880: CALL_OW 257
60884: PUSH
60885: LD_INT 3
60887: EQUAL
60888: IFFALSE 60892
// continue ;
60890: GO 60858
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60892: LD_ADDR_VAR 0 11
60896: PUSH
60897: LD_VAR 0 11
60901: PPUSH
60902: LD_VAR 0 11
60906: PUSH
60907: LD_INT 1
60909: PLUS
60910: PPUSH
60911: LD_VAR 0 9
60915: PUSH
60916: LD_VAR 0 3
60920: ARRAY
60921: PPUSH
60922: CALL_OW 2
60926: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60927: LD_ADDR_VAR 0 4
60931: PUSH
60932: LD_VAR 0 4
60936: PUSH
60937: LD_VAR 0 9
60941: PUSH
60942: LD_VAR 0 3
60946: ARRAY
60947: DIFF
60948: ST_TO_ADDR
// end ;
60949: GO 60858
60951: POP
60952: POP
// if p then
60953: LD_VAR 0 11
60957: IFFALSE 60982
// result := Replace ( result , 3 , p ) ;
60959: LD_ADDR_VAR 0 2
60963: PUSH
60964: LD_VAR 0 2
60968: PPUSH
60969: LD_INT 3
60971: PPUSH
60972: LD_VAR 0 11
60976: PPUSH
60977: CALL_OW 1
60981: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60982: LD_ADDR_VAR 0 4
60986: PUSH
60987: LD_VAR 0 4
60991: PUSH
60992: LD_VAR 0 6
60996: DIFF
60997: ST_TO_ADDR
// if tmp and eng < 6 then
60998: LD_VAR 0 4
61002: PUSH
61003: LD_VAR 0 6
61007: PUSH
61008: LD_INT 6
61010: LESS
61011: AND
61012: IFFALSE 61206
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61014: LD_ADDR_VAR 0 9
61018: PUSH
61019: LD_VAR 0 4
61023: PUSH
61024: LD_VAR 0 8
61028: PUSH
61029: LD_VAR 0 7
61033: UNION
61034: PUSH
61035: LD_VAR 0 6
61039: UNION
61040: DIFF
61041: PPUSH
61042: LD_INT 2
61044: PPUSH
61045: CALL 49983 0 2
61049: ST_TO_ADDR
// p := [ ] ;
61050: LD_ADDR_VAR 0 11
61054: PUSH
61055: EMPTY
61056: ST_TO_ADDR
// if sort then
61057: LD_VAR 0 9
61061: IFFALSE 61177
// for i = 1 to 6 - eng do
61063: LD_ADDR_VAR 0 3
61067: PUSH
61068: DOUBLE
61069: LD_INT 1
61071: DEC
61072: ST_TO_ADDR
61073: LD_INT 6
61075: PUSH
61076: LD_VAR 0 6
61080: MINUS
61081: PUSH
61082: FOR_TO
61083: IFFALSE 61175
// begin if i = sort then
61085: LD_VAR 0 3
61089: PUSH
61090: LD_VAR 0 9
61094: EQUAL
61095: IFFALSE 61099
// break ;
61097: GO 61175
// if GetClass ( i ) = 2 then
61099: LD_VAR 0 3
61103: PPUSH
61104: CALL_OW 257
61108: PUSH
61109: LD_INT 2
61111: EQUAL
61112: IFFALSE 61116
// continue ;
61114: GO 61082
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61116: LD_ADDR_VAR 0 11
61120: PUSH
61121: LD_VAR 0 11
61125: PPUSH
61126: LD_VAR 0 11
61130: PUSH
61131: LD_INT 1
61133: PLUS
61134: PPUSH
61135: LD_VAR 0 9
61139: PUSH
61140: LD_VAR 0 3
61144: ARRAY
61145: PPUSH
61146: CALL_OW 2
61150: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61151: LD_ADDR_VAR 0 4
61155: PUSH
61156: LD_VAR 0 4
61160: PUSH
61161: LD_VAR 0 9
61165: PUSH
61166: LD_VAR 0 3
61170: ARRAY
61171: DIFF
61172: ST_TO_ADDR
// end ;
61173: GO 61082
61175: POP
61176: POP
// if p then
61177: LD_VAR 0 11
61181: IFFALSE 61206
// result := Replace ( result , 2 , p ) ;
61183: LD_ADDR_VAR 0 2
61187: PUSH
61188: LD_VAR 0 2
61192: PPUSH
61193: LD_INT 2
61195: PPUSH
61196: LD_VAR 0 11
61200: PPUSH
61201: CALL_OW 1
61205: ST_TO_ADDR
// end ; exit ;
61206: GO 61930
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
61208: LD_EXP 86
61212: PUSH
61213: LD_EXP 85
61217: PUSH
61218: LD_VAR 0 1
61222: ARRAY
61223: ARRAY
61224: NOT
61225: PUSH
61226: LD_EXP 59
61230: PUSH
61231: LD_VAR 0 1
61235: ARRAY
61236: PPUSH
61237: LD_INT 30
61239: PUSH
61240: LD_INT 3
61242: PUSH
61243: EMPTY
61244: LIST
61245: LIST
61246: PPUSH
61247: CALL_OW 72
61251: AND
61252: PUSH
61253: LD_EXP 64
61257: PUSH
61258: LD_VAR 0 1
61262: ARRAY
61263: NOT
61264: AND
61265: IFFALSE 61930
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
61267: LD_ADDR_EXP 101
61271: PUSH
61272: LD_EXP 101
61276: PPUSH
61277: LD_VAR 0 1
61281: PPUSH
61282: LD_INT 6
61284: PPUSH
61285: CALL_OW 1
61289: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61290: LD_ADDR_VAR 0 2
61294: PUSH
61295: LD_INT 0
61297: PUSH
61298: LD_INT 0
61300: PUSH
61301: LD_INT 0
61303: PUSH
61304: LD_INT 0
61306: PUSH
61307: EMPTY
61308: LIST
61309: LIST
61310: LIST
61311: LIST
61312: ST_TO_ADDR
// if sci >= 1 then
61313: LD_VAR 0 8
61317: PUSH
61318: LD_INT 1
61320: GREATEREQUAL
61321: IFFALSE 61343
// tmp := tmp diff sci [ 1 ] ;
61323: LD_ADDR_VAR 0 4
61327: PUSH
61328: LD_VAR 0 4
61332: PUSH
61333: LD_VAR 0 8
61337: PUSH
61338: LD_INT 1
61340: ARRAY
61341: DIFF
61342: ST_TO_ADDR
// if tmp and not sci then
61343: LD_VAR 0 4
61347: PUSH
61348: LD_VAR 0 8
61352: NOT
61353: AND
61354: IFFALSE 61423
// begin sort := SortBySkill ( tmp , 4 ) ;
61356: LD_ADDR_VAR 0 9
61360: PUSH
61361: LD_VAR 0 4
61365: PPUSH
61366: LD_INT 4
61368: PPUSH
61369: CALL 49983 0 2
61373: ST_TO_ADDR
// if sort then
61374: LD_VAR 0 9
61378: IFFALSE 61394
// p := sort [ 1 ] ;
61380: LD_ADDR_VAR 0 11
61384: PUSH
61385: LD_VAR 0 9
61389: PUSH
61390: LD_INT 1
61392: ARRAY
61393: ST_TO_ADDR
// if p then
61394: LD_VAR 0 11
61398: IFFALSE 61423
// result := Replace ( result , 4 , p ) ;
61400: LD_ADDR_VAR 0 2
61404: PUSH
61405: LD_VAR 0 2
61409: PPUSH
61410: LD_INT 4
61412: PPUSH
61413: LD_VAR 0 11
61417: PPUSH
61418: CALL_OW 1
61422: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61423: LD_ADDR_VAR 0 4
61427: PUSH
61428: LD_VAR 0 4
61432: PUSH
61433: LD_VAR 0 7
61437: DIFF
61438: ST_TO_ADDR
// if tmp and mech < 6 then
61439: LD_VAR 0 4
61443: PUSH
61444: LD_VAR 0 7
61448: PUSH
61449: LD_INT 6
61451: LESS
61452: AND
61453: IFFALSE 61635
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
61455: LD_ADDR_VAR 0 9
61459: PUSH
61460: LD_VAR 0 4
61464: PUSH
61465: LD_VAR 0 7
61469: DIFF
61470: PPUSH
61471: LD_INT 3
61473: PPUSH
61474: CALL 49983 0 2
61478: ST_TO_ADDR
// p := [ ] ;
61479: LD_ADDR_VAR 0 11
61483: PUSH
61484: EMPTY
61485: ST_TO_ADDR
// if sort then
61486: LD_VAR 0 9
61490: IFFALSE 61606
// for i = 1 to 6 - mech do
61492: LD_ADDR_VAR 0 3
61496: PUSH
61497: DOUBLE
61498: LD_INT 1
61500: DEC
61501: ST_TO_ADDR
61502: LD_INT 6
61504: PUSH
61505: LD_VAR 0 7
61509: MINUS
61510: PUSH
61511: FOR_TO
61512: IFFALSE 61604
// begin if i = sort then
61514: LD_VAR 0 3
61518: PUSH
61519: LD_VAR 0 9
61523: EQUAL
61524: IFFALSE 61528
// break ;
61526: GO 61604
// if GetClass ( i ) = 3 then
61528: LD_VAR 0 3
61532: PPUSH
61533: CALL_OW 257
61537: PUSH
61538: LD_INT 3
61540: EQUAL
61541: IFFALSE 61545
// continue ;
61543: GO 61511
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61545: LD_ADDR_VAR 0 11
61549: PUSH
61550: LD_VAR 0 11
61554: PPUSH
61555: LD_VAR 0 11
61559: PUSH
61560: LD_INT 1
61562: PLUS
61563: PPUSH
61564: LD_VAR 0 9
61568: PUSH
61569: LD_VAR 0 3
61573: ARRAY
61574: PPUSH
61575: CALL_OW 2
61579: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61580: LD_ADDR_VAR 0 4
61584: PUSH
61585: LD_VAR 0 4
61589: PUSH
61590: LD_VAR 0 9
61594: PUSH
61595: LD_VAR 0 3
61599: ARRAY
61600: DIFF
61601: ST_TO_ADDR
// end ;
61602: GO 61511
61604: POP
61605: POP
// if p then
61606: LD_VAR 0 11
61610: IFFALSE 61635
// result := Replace ( result , 3 , p ) ;
61612: LD_ADDR_VAR 0 2
61616: PUSH
61617: LD_VAR 0 2
61621: PPUSH
61622: LD_INT 3
61624: PPUSH
61625: LD_VAR 0 11
61629: PPUSH
61630: CALL_OW 1
61634: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61635: LD_ADDR_VAR 0 4
61639: PUSH
61640: LD_VAR 0 4
61644: PUSH
61645: LD_VAR 0 6
61649: DIFF
61650: ST_TO_ADDR
// if tmp and eng < 4 then
61651: LD_VAR 0 4
61655: PUSH
61656: LD_VAR 0 6
61660: PUSH
61661: LD_INT 4
61663: LESS
61664: AND
61665: IFFALSE 61855
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
61667: LD_ADDR_VAR 0 9
61671: PUSH
61672: LD_VAR 0 4
61676: PUSH
61677: LD_VAR 0 7
61681: PUSH
61682: LD_VAR 0 6
61686: UNION
61687: DIFF
61688: PPUSH
61689: LD_INT 2
61691: PPUSH
61692: CALL 49983 0 2
61696: ST_TO_ADDR
// p := [ ] ;
61697: LD_ADDR_VAR 0 11
61701: PUSH
61702: EMPTY
61703: ST_TO_ADDR
// if sort then
61704: LD_VAR 0 9
61708: IFFALSE 61824
// for i = 1 to 4 - eng do
61710: LD_ADDR_VAR 0 3
61714: PUSH
61715: DOUBLE
61716: LD_INT 1
61718: DEC
61719: ST_TO_ADDR
61720: LD_INT 4
61722: PUSH
61723: LD_VAR 0 6
61727: MINUS
61728: PUSH
61729: FOR_TO
61730: IFFALSE 61822
// begin if i = sort then
61732: LD_VAR 0 3
61736: PUSH
61737: LD_VAR 0 9
61741: EQUAL
61742: IFFALSE 61746
// break ;
61744: GO 61822
// if GetClass ( i ) = 2 then
61746: LD_VAR 0 3
61750: PPUSH
61751: CALL_OW 257
61755: PUSH
61756: LD_INT 2
61758: EQUAL
61759: IFFALSE 61763
// continue ;
61761: GO 61729
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61763: LD_ADDR_VAR 0 11
61767: PUSH
61768: LD_VAR 0 11
61772: PPUSH
61773: LD_VAR 0 11
61777: PUSH
61778: LD_INT 1
61780: PLUS
61781: PPUSH
61782: LD_VAR 0 9
61786: PUSH
61787: LD_VAR 0 3
61791: ARRAY
61792: PPUSH
61793: CALL_OW 2
61797: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61798: LD_ADDR_VAR 0 4
61802: PUSH
61803: LD_VAR 0 4
61807: PUSH
61808: LD_VAR 0 9
61812: PUSH
61813: LD_VAR 0 3
61817: ARRAY
61818: DIFF
61819: ST_TO_ADDR
// end ;
61820: GO 61729
61822: POP
61823: POP
// if p then
61824: LD_VAR 0 11
61828: IFFALSE 61853
// result := Replace ( result , 2 , p ) ;
61830: LD_ADDR_VAR 0 2
61834: PUSH
61835: LD_VAR 0 2
61839: PPUSH
61840: LD_INT 2
61842: PPUSH
61843: LD_VAR 0 11
61847: PPUSH
61848: CALL_OW 1
61852: ST_TO_ADDR
// end else
61853: GO 61899
// for i = eng downto 5 do
61855: LD_ADDR_VAR 0 3
61859: PUSH
61860: DOUBLE
61861: LD_VAR 0 6
61865: INC
61866: ST_TO_ADDR
61867: LD_INT 5
61869: PUSH
61870: FOR_DOWNTO
61871: IFFALSE 61897
// tmp := tmp union eng [ i ] ;
61873: LD_ADDR_VAR 0 4
61877: PUSH
61878: LD_VAR 0 4
61882: PUSH
61883: LD_VAR 0 6
61887: PUSH
61888: LD_VAR 0 3
61892: ARRAY
61893: UNION
61894: ST_TO_ADDR
61895: GO 61870
61897: POP
61898: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
61899: LD_ADDR_VAR 0 2
61903: PUSH
61904: LD_VAR 0 2
61908: PPUSH
61909: LD_INT 1
61911: PPUSH
61912: LD_VAR 0 4
61916: PUSH
61917: LD_VAR 0 5
61921: DIFF
61922: PPUSH
61923: CALL_OW 1
61927: ST_TO_ADDR
// exit ;
61928: GO 61930
// end ; end ;
61930: LD_VAR 0 2
61934: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
61935: LD_INT 0
61937: PPUSH
61938: PPUSH
61939: PPUSH
// if not mc_bases then
61940: LD_EXP 59
61944: NOT
61945: IFFALSE 61949
// exit ;
61947: GO 62091
// for i = 1 to mc_bases do
61949: LD_ADDR_VAR 0 2
61953: PUSH
61954: DOUBLE
61955: LD_INT 1
61957: DEC
61958: ST_TO_ADDR
61959: LD_EXP 59
61963: PUSH
61964: FOR_TO
61965: IFFALSE 62082
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
61967: LD_ADDR_VAR 0 3
61971: PUSH
61972: LD_EXP 59
61976: PUSH
61977: LD_VAR 0 2
61981: ARRAY
61982: PPUSH
61983: LD_INT 21
61985: PUSH
61986: LD_INT 3
61988: PUSH
61989: EMPTY
61990: LIST
61991: LIST
61992: PUSH
61993: LD_INT 3
61995: PUSH
61996: LD_INT 2
61998: PUSH
61999: LD_INT 30
62001: PUSH
62002: LD_INT 29
62004: PUSH
62005: EMPTY
62006: LIST
62007: LIST
62008: PUSH
62009: LD_INT 30
62011: PUSH
62012: LD_INT 30
62014: PUSH
62015: EMPTY
62016: LIST
62017: LIST
62018: PUSH
62019: EMPTY
62020: LIST
62021: LIST
62022: LIST
62023: PUSH
62024: EMPTY
62025: LIST
62026: LIST
62027: PUSH
62028: LD_INT 3
62030: PUSH
62031: LD_INT 24
62033: PUSH
62034: LD_INT 1000
62036: PUSH
62037: EMPTY
62038: LIST
62039: LIST
62040: PUSH
62041: EMPTY
62042: LIST
62043: LIST
62044: PUSH
62045: EMPTY
62046: LIST
62047: LIST
62048: LIST
62049: PPUSH
62050: CALL_OW 72
62054: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
62055: LD_ADDR_EXP 60
62059: PUSH
62060: LD_EXP 60
62064: PPUSH
62065: LD_VAR 0 2
62069: PPUSH
62070: LD_VAR 0 3
62074: PPUSH
62075: CALL_OW 1
62079: ST_TO_ADDR
// end ;
62080: GO 61964
62082: POP
62083: POP
// RaiseSailEvent ( 101 ) ;
62084: LD_INT 101
62086: PPUSH
62087: CALL_OW 427
// end ;
62091: LD_VAR 0 1
62095: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
62096: LD_INT 0
62098: PPUSH
62099: PPUSH
62100: PPUSH
62101: PPUSH
62102: PPUSH
62103: PPUSH
62104: PPUSH
// if not mc_bases then
62105: LD_EXP 59
62109: NOT
62110: IFFALSE 62114
// exit ;
62112: GO 62676
// for i = 1 to mc_bases do
62114: LD_ADDR_VAR 0 2
62118: PUSH
62119: DOUBLE
62120: LD_INT 1
62122: DEC
62123: ST_TO_ADDR
62124: LD_EXP 59
62128: PUSH
62129: FOR_TO
62130: IFFALSE 62667
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
62132: LD_ADDR_VAR 0 5
62136: PUSH
62137: LD_EXP 59
62141: PUSH
62142: LD_VAR 0 2
62146: ARRAY
62147: PUSH
62148: LD_EXP 88
62152: PUSH
62153: LD_VAR 0 2
62157: ARRAY
62158: UNION
62159: PPUSH
62160: LD_INT 21
62162: PUSH
62163: LD_INT 1
62165: PUSH
62166: EMPTY
62167: LIST
62168: LIST
62169: PUSH
62170: LD_INT 1
62172: PUSH
62173: LD_INT 3
62175: PUSH
62176: LD_INT 54
62178: PUSH
62179: EMPTY
62180: LIST
62181: PUSH
62182: EMPTY
62183: LIST
62184: LIST
62185: PUSH
62186: LD_INT 3
62188: PUSH
62189: LD_INT 24
62191: PUSH
62192: LD_INT 1000
62194: PUSH
62195: EMPTY
62196: LIST
62197: LIST
62198: PUSH
62199: EMPTY
62200: LIST
62201: LIST
62202: PUSH
62203: EMPTY
62204: LIST
62205: LIST
62206: LIST
62207: PUSH
62208: EMPTY
62209: LIST
62210: LIST
62211: PPUSH
62212: CALL_OW 72
62216: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
62217: LD_ADDR_VAR 0 6
62221: PUSH
62222: LD_EXP 59
62226: PUSH
62227: LD_VAR 0 2
62231: ARRAY
62232: PPUSH
62233: LD_INT 21
62235: PUSH
62236: LD_INT 1
62238: PUSH
62239: EMPTY
62240: LIST
62241: LIST
62242: PUSH
62243: LD_INT 1
62245: PUSH
62246: LD_INT 3
62248: PUSH
62249: LD_INT 54
62251: PUSH
62252: EMPTY
62253: LIST
62254: PUSH
62255: EMPTY
62256: LIST
62257: LIST
62258: PUSH
62259: LD_INT 3
62261: PUSH
62262: LD_INT 24
62264: PUSH
62265: LD_INT 250
62267: PUSH
62268: EMPTY
62269: LIST
62270: LIST
62271: PUSH
62272: EMPTY
62273: LIST
62274: LIST
62275: PUSH
62276: EMPTY
62277: LIST
62278: LIST
62279: LIST
62280: PUSH
62281: EMPTY
62282: LIST
62283: LIST
62284: PPUSH
62285: CALL_OW 72
62289: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
62290: LD_ADDR_VAR 0 7
62294: PUSH
62295: LD_VAR 0 5
62299: PUSH
62300: LD_VAR 0 6
62304: DIFF
62305: ST_TO_ADDR
// if not need_heal_1 then
62306: LD_VAR 0 6
62310: NOT
62311: IFFALSE 62344
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
62313: LD_ADDR_EXP 62
62317: PUSH
62318: LD_EXP 62
62322: PPUSH
62323: LD_VAR 0 2
62327: PUSH
62328: LD_INT 1
62330: PUSH
62331: EMPTY
62332: LIST
62333: LIST
62334: PPUSH
62335: EMPTY
62336: PPUSH
62337: CALL 19726 0 3
62341: ST_TO_ADDR
62342: GO 62414
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
62344: LD_ADDR_EXP 62
62348: PUSH
62349: LD_EXP 62
62353: PPUSH
62354: LD_VAR 0 2
62358: PUSH
62359: LD_INT 1
62361: PUSH
62362: EMPTY
62363: LIST
62364: LIST
62365: PPUSH
62366: LD_EXP 62
62370: PUSH
62371: LD_VAR 0 2
62375: ARRAY
62376: PUSH
62377: LD_INT 1
62379: ARRAY
62380: PPUSH
62381: LD_INT 3
62383: PUSH
62384: LD_INT 24
62386: PUSH
62387: LD_INT 1000
62389: PUSH
62390: EMPTY
62391: LIST
62392: LIST
62393: PUSH
62394: EMPTY
62395: LIST
62396: LIST
62397: PPUSH
62398: CALL_OW 72
62402: PUSH
62403: LD_VAR 0 6
62407: UNION
62408: PPUSH
62409: CALL 19726 0 3
62413: ST_TO_ADDR
// if not need_heal_2 then
62414: LD_VAR 0 7
62418: NOT
62419: IFFALSE 62452
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
62421: LD_ADDR_EXP 62
62425: PUSH
62426: LD_EXP 62
62430: PPUSH
62431: LD_VAR 0 2
62435: PUSH
62436: LD_INT 2
62438: PUSH
62439: EMPTY
62440: LIST
62441: LIST
62442: PPUSH
62443: EMPTY
62444: PPUSH
62445: CALL 19726 0 3
62449: ST_TO_ADDR
62450: GO 62484
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
62452: LD_ADDR_EXP 62
62456: PUSH
62457: LD_EXP 62
62461: PPUSH
62462: LD_VAR 0 2
62466: PUSH
62467: LD_INT 2
62469: PUSH
62470: EMPTY
62471: LIST
62472: LIST
62473: PPUSH
62474: LD_VAR 0 7
62478: PPUSH
62479: CALL 19726 0 3
62483: ST_TO_ADDR
// if need_heal_2 then
62484: LD_VAR 0 7
62488: IFFALSE 62649
// for j in need_heal_2 do
62490: LD_ADDR_VAR 0 3
62494: PUSH
62495: LD_VAR 0 7
62499: PUSH
62500: FOR_IN
62501: IFFALSE 62647
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62503: LD_ADDR_VAR 0 5
62507: PUSH
62508: LD_EXP 59
62512: PUSH
62513: LD_VAR 0 2
62517: ARRAY
62518: PPUSH
62519: LD_INT 2
62521: PUSH
62522: LD_INT 30
62524: PUSH
62525: LD_INT 6
62527: PUSH
62528: EMPTY
62529: LIST
62530: LIST
62531: PUSH
62532: LD_INT 30
62534: PUSH
62535: LD_INT 7
62537: PUSH
62538: EMPTY
62539: LIST
62540: LIST
62541: PUSH
62542: LD_INT 30
62544: PUSH
62545: LD_INT 8
62547: PUSH
62548: EMPTY
62549: LIST
62550: LIST
62551: PUSH
62552: LD_INT 30
62554: PUSH
62555: LD_INT 0
62557: PUSH
62558: EMPTY
62559: LIST
62560: LIST
62561: PUSH
62562: LD_INT 30
62564: PUSH
62565: LD_INT 1
62567: PUSH
62568: EMPTY
62569: LIST
62570: LIST
62571: PUSH
62572: EMPTY
62573: LIST
62574: LIST
62575: LIST
62576: LIST
62577: LIST
62578: LIST
62579: PPUSH
62580: CALL_OW 72
62584: ST_TO_ADDR
// if tmp then
62585: LD_VAR 0 5
62589: IFFALSE 62645
// begin k := NearestUnitToUnit ( tmp , j ) ;
62591: LD_ADDR_VAR 0 4
62595: PUSH
62596: LD_VAR 0 5
62600: PPUSH
62601: LD_VAR 0 3
62605: PPUSH
62606: CALL_OW 74
62610: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
62611: LD_VAR 0 3
62615: PPUSH
62616: LD_VAR 0 4
62620: PPUSH
62621: CALL_OW 296
62625: PUSH
62626: LD_INT 5
62628: GREATER
62629: IFFALSE 62645
// ComMoveToNearbyEntrance ( j , k ) ;
62631: LD_VAR 0 3
62635: PPUSH
62636: LD_VAR 0 4
62640: PPUSH
62641: CALL 52344 0 2
// end ; end ;
62645: GO 62500
62647: POP
62648: POP
// if not need_heal_1 and not need_heal_2 then
62649: LD_VAR 0 6
62653: NOT
62654: PUSH
62655: LD_VAR 0 7
62659: NOT
62660: AND
62661: IFFALSE 62665
// continue ;
62663: GO 62129
// end ;
62665: GO 62129
62667: POP
62668: POP
// RaiseSailEvent ( 102 ) ;
62669: LD_INT 102
62671: PPUSH
62672: CALL_OW 427
// end ;
62676: LD_VAR 0 1
62680: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
62681: LD_INT 0
62683: PPUSH
62684: PPUSH
62685: PPUSH
62686: PPUSH
62687: PPUSH
62688: PPUSH
62689: PPUSH
62690: PPUSH
// if not mc_bases then
62691: LD_EXP 59
62695: NOT
62696: IFFALSE 62700
// exit ;
62698: GO 63583
// for i = 1 to mc_bases do
62700: LD_ADDR_VAR 0 2
62704: PUSH
62705: DOUBLE
62706: LD_INT 1
62708: DEC
62709: ST_TO_ADDR
62710: LD_EXP 59
62714: PUSH
62715: FOR_TO
62716: IFFALSE 63581
// begin if not mc_building_need_repair [ i ] then
62718: LD_EXP 60
62722: PUSH
62723: LD_VAR 0 2
62727: ARRAY
62728: NOT
62729: IFFALSE 62916
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
62731: LD_ADDR_VAR 0 6
62735: PUSH
62736: LD_EXP 78
62740: PUSH
62741: LD_VAR 0 2
62745: ARRAY
62746: PPUSH
62747: LD_INT 3
62749: PUSH
62750: LD_INT 24
62752: PUSH
62753: LD_INT 1000
62755: PUSH
62756: EMPTY
62757: LIST
62758: LIST
62759: PUSH
62760: EMPTY
62761: LIST
62762: LIST
62763: PUSH
62764: LD_INT 2
62766: PUSH
62767: LD_INT 34
62769: PUSH
62770: LD_INT 13
62772: PUSH
62773: EMPTY
62774: LIST
62775: LIST
62776: PUSH
62777: LD_INT 34
62779: PUSH
62780: LD_INT 52
62782: PUSH
62783: EMPTY
62784: LIST
62785: LIST
62786: PUSH
62787: LD_INT 34
62789: PUSH
62790: LD_EXP 109
62794: PUSH
62795: EMPTY
62796: LIST
62797: LIST
62798: PUSH
62799: EMPTY
62800: LIST
62801: LIST
62802: LIST
62803: LIST
62804: PUSH
62805: EMPTY
62806: LIST
62807: LIST
62808: PPUSH
62809: CALL_OW 72
62813: ST_TO_ADDR
// if cranes then
62814: LD_VAR 0 6
62818: IFFALSE 62880
// for j in cranes do
62820: LD_ADDR_VAR 0 3
62824: PUSH
62825: LD_VAR 0 6
62829: PUSH
62830: FOR_IN
62831: IFFALSE 62878
// if not IsInArea ( j , mc_parking [ i ] ) then
62833: LD_VAR 0 3
62837: PPUSH
62838: LD_EXP 83
62842: PUSH
62843: LD_VAR 0 2
62847: ARRAY
62848: PPUSH
62849: CALL_OW 308
62853: NOT
62854: IFFALSE 62876
// ComMoveToArea ( j , mc_parking [ i ] ) ;
62856: LD_VAR 0 3
62860: PPUSH
62861: LD_EXP 83
62865: PUSH
62866: LD_VAR 0 2
62870: ARRAY
62871: PPUSH
62872: CALL_OW 113
62876: GO 62830
62878: POP
62879: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
62880: LD_ADDR_EXP 61
62884: PUSH
62885: LD_EXP 61
62889: PPUSH
62890: LD_VAR 0 2
62894: PPUSH
62895: EMPTY
62896: PPUSH
62897: CALL_OW 1
62901: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
62902: LD_VAR 0 2
62906: PPUSH
62907: LD_INT 101
62909: PPUSH
62910: CALL 57768 0 2
// continue ;
62914: GO 62715
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
62916: LD_ADDR_EXP 65
62920: PUSH
62921: LD_EXP 65
62925: PPUSH
62926: LD_VAR 0 2
62930: PPUSH
62931: EMPTY
62932: PPUSH
62933: CALL_OW 1
62937: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62938: LD_VAR 0 2
62942: PPUSH
62943: LD_INT 103
62945: PPUSH
62946: CALL 57768 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
62950: LD_ADDR_VAR 0 5
62954: PUSH
62955: LD_EXP 59
62959: PUSH
62960: LD_VAR 0 2
62964: ARRAY
62965: PUSH
62966: LD_EXP 88
62970: PUSH
62971: LD_VAR 0 2
62975: ARRAY
62976: UNION
62977: PPUSH
62978: LD_INT 2
62980: PUSH
62981: LD_INT 25
62983: PUSH
62984: LD_INT 2
62986: PUSH
62987: EMPTY
62988: LIST
62989: LIST
62990: PUSH
62991: LD_INT 25
62993: PUSH
62994: LD_INT 16
62996: PUSH
62997: EMPTY
62998: LIST
62999: LIST
63000: PUSH
63001: EMPTY
63002: LIST
63003: LIST
63004: LIST
63005: PUSH
63006: EMPTY
63007: LIST
63008: PPUSH
63009: CALL_OW 72
63013: ST_TO_ADDR
// if mc_need_heal [ i ] then
63014: LD_EXP 62
63018: PUSH
63019: LD_VAR 0 2
63023: ARRAY
63024: IFFALSE 63068
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
63026: LD_ADDR_VAR 0 5
63030: PUSH
63031: LD_VAR 0 5
63035: PUSH
63036: LD_EXP 62
63040: PUSH
63041: LD_VAR 0 2
63045: ARRAY
63046: PUSH
63047: LD_INT 1
63049: ARRAY
63050: PUSH
63051: LD_EXP 62
63055: PUSH
63056: LD_VAR 0 2
63060: ARRAY
63061: PUSH
63062: LD_INT 2
63064: ARRAY
63065: UNION
63066: DIFF
63067: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
63068: LD_ADDR_VAR 0 6
63072: PUSH
63073: LD_EXP 78
63077: PUSH
63078: LD_VAR 0 2
63082: ARRAY
63083: PPUSH
63084: LD_INT 2
63086: PUSH
63087: LD_INT 34
63089: PUSH
63090: LD_INT 13
63092: PUSH
63093: EMPTY
63094: LIST
63095: LIST
63096: PUSH
63097: LD_INT 34
63099: PUSH
63100: LD_INT 52
63102: PUSH
63103: EMPTY
63104: LIST
63105: LIST
63106: PUSH
63107: LD_INT 34
63109: PUSH
63110: LD_EXP 109
63114: PUSH
63115: EMPTY
63116: LIST
63117: LIST
63118: PUSH
63119: EMPTY
63120: LIST
63121: LIST
63122: LIST
63123: LIST
63124: PPUSH
63125: CALL_OW 72
63129: ST_TO_ADDR
// if cranes then
63130: LD_VAR 0 6
63134: IFFALSE 63270
// begin for j in cranes do
63136: LD_ADDR_VAR 0 3
63140: PUSH
63141: LD_VAR 0 6
63145: PUSH
63146: FOR_IN
63147: IFFALSE 63268
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
63149: LD_VAR 0 3
63153: PPUSH
63154: CALL_OW 256
63158: PUSH
63159: LD_INT 1000
63161: EQUAL
63162: PUSH
63163: LD_VAR 0 3
63167: PPUSH
63168: CALL_OW 314
63172: NOT
63173: AND
63174: IFFALSE 63208
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
63176: LD_VAR 0 3
63180: PPUSH
63181: LD_EXP 60
63185: PUSH
63186: LD_VAR 0 2
63190: ARRAY
63191: PPUSH
63192: LD_VAR 0 3
63196: PPUSH
63197: CALL_OW 74
63201: PPUSH
63202: CALL_OW 130
63206: GO 63266
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
63208: LD_VAR 0 3
63212: PPUSH
63213: CALL_OW 256
63217: PUSH
63218: LD_INT 500
63220: LESS
63221: PUSH
63222: LD_VAR 0 3
63226: PPUSH
63227: LD_EXP 83
63231: PUSH
63232: LD_VAR 0 2
63236: ARRAY
63237: PPUSH
63238: CALL_OW 308
63242: NOT
63243: AND
63244: IFFALSE 63266
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63246: LD_VAR 0 3
63250: PPUSH
63251: LD_EXP 83
63255: PUSH
63256: LD_VAR 0 2
63260: ARRAY
63261: PPUSH
63262: CALL_OW 113
// end ;
63266: GO 63146
63268: POP
63269: POP
// end ; if tmp > 3 then
63270: LD_VAR 0 5
63274: PUSH
63275: LD_INT 3
63277: GREATER
63278: IFFALSE 63298
// tmp := ShrinkArray ( tmp , 4 ) ;
63280: LD_ADDR_VAR 0 5
63284: PUSH
63285: LD_VAR 0 5
63289: PPUSH
63290: LD_INT 4
63292: PPUSH
63293: CALL 51792 0 2
63297: ST_TO_ADDR
// if not tmp then
63298: LD_VAR 0 5
63302: NOT
63303: IFFALSE 63307
// continue ;
63305: GO 62715
// for j in tmp do
63307: LD_ADDR_VAR 0 3
63311: PUSH
63312: LD_VAR 0 5
63316: PUSH
63317: FOR_IN
63318: IFFALSE 63577
// begin if IsInUnit ( j ) then
63320: LD_VAR 0 3
63324: PPUSH
63325: CALL_OW 310
63329: IFFALSE 63340
// ComExitBuilding ( j ) ;
63331: LD_VAR 0 3
63335: PPUSH
63336: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
63340: LD_VAR 0 3
63344: PUSH
63345: LD_EXP 61
63349: PUSH
63350: LD_VAR 0 2
63354: ARRAY
63355: IN
63356: NOT
63357: IFFALSE 63415
// begin SetTag ( j , 101 ) ;
63359: LD_VAR 0 3
63363: PPUSH
63364: LD_INT 101
63366: PPUSH
63367: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
63371: LD_ADDR_EXP 61
63375: PUSH
63376: LD_EXP 61
63380: PPUSH
63381: LD_VAR 0 2
63385: PUSH
63386: LD_EXP 61
63390: PUSH
63391: LD_VAR 0 2
63395: ARRAY
63396: PUSH
63397: LD_INT 1
63399: PLUS
63400: PUSH
63401: EMPTY
63402: LIST
63403: LIST
63404: PPUSH
63405: LD_VAR 0 3
63409: PPUSH
63410: CALL 19726 0 3
63414: ST_TO_ADDR
// end ; wait ( 1 ) ;
63415: LD_INT 1
63417: PPUSH
63418: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
63422: LD_ADDR_VAR 0 7
63426: PUSH
63427: LD_EXP 60
63431: PUSH
63432: LD_VAR 0 2
63436: ARRAY
63437: ST_TO_ADDR
// if mc_scan [ i ] then
63438: LD_EXP 82
63442: PUSH
63443: LD_VAR 0 2
63447: ARRAY
63448: IFFALSE 63510
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
63450: LD_ADDR_VAR 0 7
63454: PUSH
63455: LD_EXP 60
63459: PUSH
63460: LD_VAR 0 2
63464: ARRAY
63465: PPUSH
63466: LD_INT 3
63468: PUSH
63469: LD_INT 30
63471: PUSH
63472: LD_INT 32
63474: PUSH
63475: EMPTY
63476: LIST
63477: LIST
63478: PUSH
63479: LD_INT 30
63481: PUSH
63482: LD_INT 33
63484: PUSH
63485: EMPTY
63486: LIST
63487: LIST
63488: PUSH
63489: LD_INT 30
63491: PUSH
63492: LD_INT 31
63494: PUSH
63495: EMPTY
63496: LIST
63497: LIST
63498: PUSH
63499: EMPTY
63500: LIST
63501: LIST
63502: LIST
63503: LIST
63504: PPUSH
63505: CALL_OW 72
63509: ST_TO_ADDR
// if not to_repair_tmp then
63510: LD_VAR 0 7
63514: NOT
63515: IFFALSE 63519
// continue ;
63517: GO 63317
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
63519: LD_ADDR_VAR 0 8
63523: PUSH
63524: LD_VAR 0 7
63528: PPUSH
63529: LD_VAR 0 3
63533: PPUSH
63534: CALL_OW 74
63538: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
63539: LD_VAR 0 8
63543: PPUSH
63544: LD_INT 16
63546: PPUSH
63547: CALL 22325 0 2
63551: PUSH
63552: LD_INT 4
63554: ARRAY
63555: PUSH
63556: LD_INT 10
63558: LESS
63559: IFFALSE 63575
// ComRepairBuilding ( j , to_repair ) ;
63561: LD_VAR 0 3
63565: PPUSH
63566: LD_VAR 0 8
63570: PPUSH
63571: CALL_OW 130
// end ;
63575: GO 63317
63577: POP
63578: POP
// end ;
63579: GO 62715
63581: POP
63582: POP
// end ;
63583: LD_VAR 0 1
63587: RET
// export function MC_Heal ; var i , j , tmp ; begin
63588: LD_INT 0
63590: PPUSH
63591: PPUSH
63592: PPUSH
63593: PPUSH
// if not mc_bases then
63594: LD_EXP 59
63598: NOT
63599: IFFALSE 63603
// exit ;
63601: GO 64005
// for i = 1 to mc_bases do
63603: LD_ADDR_VAR 0 2
63607: PUSH
63608: DOUBLE
63609: LD_INT 1
63611: DEC
63612: ST_TO_ADDR
63613: LD_EXP 59
63617: PUSH
63618: FOR_TO
63619: IFFALSE 64003
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
63621: LD_EXP 62
63625: PUSH
63626: LD_VAR 0 2
63630: ARRAY
63631: PUSH
63632: LD_INT 1
63634: ARRAY
63635: NOT
63636: PUSH
63637: LD_EXP 62
63641: PUSH
63642: LD_VAR 0 2
63646: ARRAY
63647: PUSH
63648: LD_INT 2
63650: ARRAY
63651: NOT
63652: AND
63653: IFFALSE 63691
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
63655: LD_ADDR_EXP 63
63659: PUSH
63660: LD_EXP 63
63664: PPUSH
63665: LD_VAR 0 2
63669: PPUSH
63670: EMPTY
63671: PPUSH
63672: CALL_OW 1
63676: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
63677: LD_VAR 0 2
63681: PPUSH
63682: LD_INT 102
63684: PPUSH
63685: CALL 57768 0 2
// continue ;
63689: GO 63618
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
63691: LD_ADDR_VAR 0 4
63695: PUSH
63696: LD_EXP 59
63700: PUSH
63701: LD_VAR 0 2
63705: ARRAY
63706: PPUSH
63707: LD_INT 25
63709: PUSH
63710: LD_INT 4
63712: PUSH
63713: EMPTY
63714: LIST
63715: LIST
63716: PPUSH
63717: CALL_OW 72
63721: ST_TO_ADDR
// if not tmp then
63722: LD_VAR 0 4
63726: NOT
63727: IFFALSE 63731
// continue ;
63729: GO 63618
// if mc_taming [ i ] then
63731: LD_EXP 90
63735: PUSH
63736: LD_VAR 0 2
63740: ARRAY
63741: IFFALSE 63765
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63743: LD_ADDR_EXP 90
63747: PUSH
63748: LD_EXP 90
63752: PPUSH
63753: LD_VAR 0 2
63757: PPUSH
63758: EMPTY
63759: PPUSH
63760: CALL_OW 1
63764: ST_TO_ADDR
// for j in tmp do
63765: LD_ADDR_VAR 0 3
63769: PUSH
63770: LD_VAR 0 4
63774: PUSH
63775: FOR_IN
63776: IFFALSE 63999
// begin if IsInUnit ( j ) then
63778: LD_VAR 0 3
63782: PPUSH
63783: CALL_OW 310
63787: IFFALSE 63798
// ComExitBuilding ( j ) ;
63789: LD_VAR 0 3
63793: PPUSH
63794: CALL_OW 122
// if not j in mc_healers [ i ] then
63798: LD_VAR 0 3
63802: PUSH
63803: LD_EXP 63
63807: PUSH
63808: LD_VAR 0 2
63812: ARRAY
63813: IN
63814: NOT
63815: IFFALSE 63861
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
63817: LD_ADDR_EXP 63
63821: PUSH
63822: LD_EXP 63
63826: PPUSH
63827: LD_VAR 0 2
63831: PUSH
63832: LD_EXP 63
63836: PUSH
63837: LD_VAR 0 2
63841: ARRAY
63842: PUSH
63843: LD_INT 1
63845: PLUS
63846: PUSH
63847: EMPTY
63848: LIST
63849: LIST
63850: PPUSH
63851: LD_VAR 0 3
63855: PPUSH
63856: CALL 19726 0 3
63860: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
63861: LD_VAR 0 3
63865: PPUSH
63866: CALL_OW 110
63870: PUSH
63871: LD_INT 102
63873: NONEQUAL
63874: IFFALSE 63888
// SetTag ( j , 102 ) ;
63876: LD_VAR 0 3
63880: PPUSH
63881: LD_INT 102
63883: PPUSH
63884: CALL_OW 109
// Wait ( 3 ) ;
63888: LD_INT 3
63890: PPUSH
63891: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
63895: LD_EXP 62
63899: PUSH
63900: LD_VAR 0 2
63904: ARRAY
63905: PUSH
63906: LD_INT 1
63908: ARRAY
63909: IFFALSE 63941
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
63911: LD_VAR 0 3
63915: PPUSH
63916: LD_EXP 62
63920: PUSH
63921: LD_VAR 0 2
63925: ARRAY
63926: PUSH
63927: LD_INT 1
63929: ARRAY
63930: PUSH
63931: LD_INT 1
63933: ARRAY
63934: PPUSH
63935: CALL_OW 128
63939: GO 63997
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
63941: LD_VAR 0 3
63945: PPUSH
63946: CALL_OW 314
63950: NOT
63951: PUSH
63952: LD_EXP 62
63956: PUSH
63957: LD_VAR 0 2
63961: ARRAY
63962: PUSH
63963: LD_INT 2
63965: ARRAY
63966: AND
63967: IFFALSE 63997
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
63969: LD_VAR 0 3
63973: PPUSH
63974: LD_EXP 62
63978: PUSH
63979: LD_VAR 0 2
63983: ARRAY
63984: PUSH
63985: LD_INT 2
63987: ARRAY
63988: PUSH
63989: LD_INT 1
63991: ARRAY
63992: PPUSH
63993: CALL_OW 128
// end ;
63997: GO 63775
63999: POP
64000: POP
// end ;
64001: GO 63618
64003: POP
64004: POP
// end ;
64005: LD_VAR 0 1
64009: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
64010: LD_INT 0
64012: PPUSH
64013: PPUSH
64014: PPUSH
64015: PPUSH
64016: PPUSH
// if not mc_bases then
64017: LD_EXP 59
64021: NOT
64022: IFFALSE 64026
// exit ;
64024: GO 65197
// for i = 1 to mc_bases do
64026: LD_ADDR_VAR 0 2
64030: PUSH
64031: DOUBLE
64032: LD_INT 1
64034: DEC
64035: ST_TO_ADDR
64036: LD_EXP 59
64040: PUSH
64041: FOR_TO
64042: IFFALSE 65195
// begin if mc_scan [ i ] then
64044: LD_EXP 82
64048: PUSH
64049: LD_VAR 0 2
64053: ARRAY
64054: IFFALSE 64058
// continue ;
64056: GO 64041
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
64058: LD_EXP 64
64062: PUSH
64063: LD_VAR 0 2
64067: ARRAY
64068: NOT
64069: PUSH
64070: LD_EXP 66
64074: PUSH
64075: LD_VAR 0 2
64079: ARRAY
64080: NOT
64081: AND
64082: PUSH
64083: LD_EXP 65
64087: PUSH
64088: LD_VAR 0 2
64092: ARRAY
64093: AND
64094: IFFALSE 64132
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
64096: LD_ADDR_EXP 65
64100: PUSH
64101: LD_EXP 65
64105: PPUSH
64106: LD_VAR 0 2
64110: PPUSH
64111: EMPTY
64112: PPUSH
64113: CALL_OW 1
64117: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64118: LD_VAR 0 2
64122: PPUSH
64123: LD_INT 103
64125: PPUSH
64126: CALL 57768 0 2
// continue ;
64130: GO 64041
// end ; if mc_construct_list [ i ] then
64132: LD_EXP 66
64136: PUSH
64137: LD_VAR 0 2
64141: ARRAY
64142: IFFALSE 64362
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64144: LD_ADDR_VAR 0 4
64148: PUSH
64149: LD_EXP 59
64153: PUSH
64154: LD_VAR 0 2
64158: ARRAY
64159: PPUSH
64160: LD_INT 25
64162: PUSH
64163: LD_INT 2
64165: PUSH
64166: EMPTY
64167: LIST
64168: LIST
64169: PPUSH
64170: CALL_OW 72
64174: PUSH
64175: LD_EXP 61
64179: PUSH
64180: LD_VAR 0 2
64184: ARRAY
64185: DIFF
64186: ST_TO_ADDR
// if not tmp then
64187: LD_VAR 0 4
64191: NOT
64192: IFFALSE 64196
// continue ;
64194: GO 64041
// for j in tmp do
64196: LD_ADDR_VAR 0 3
64200: PUSH
64201: LD_VAR 0 4
64205: PUSH
64206: FOR_IN
64207: IFFALSE 64358
// begin if not mc_builders [ i ] then
64209: LD_EXP 65
64213: PUSH
64214: LD_VAR 0 2
64218: ARRAY
64219: NOT
64220: IFFALSE 64278
// begin SetTag ( j , 103 ) ;
64222: LD_VAR 0 3
64226: PPUSH
64227: LD_INT 103
64229: PPUSH
64230: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64234: LD_ADDR_EXP 65
64238: PUSH
64239: LD_EXP 65
64243: PPUSH
64244: LD_VAR 0 2
64248: PUSH
64249: LD_EXP 65
64253: PUSH
64254: LD_VAR 0 2
64258: ARRAY
64259: PUSH
64260: LD_INT 1
64262: PLUS
64263: PUSH
64264: EMPTY
64265: LIST
64266: LIST
64267: PPUSH
64268: LD_VAR 0 3
64272: PPUSH
64273: CALL 19726 0 3
64277: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64278: LD_VAR 0 3
64282: PPUSH
64283: CALL_OW 310
64287: IFFALSE 64298
// ComExitBuilding ( j ) ;
64289: LD_VAR 0 3
64293: PPUSH
64294: CALL_OW 122
// wait ( 3 ) ;
64298: LD_INT 3
64300: PPUSH
64301: CALL_OW 67
// if not mc_construct_list [ i ] then
64305: LD_EXP 66
64309: PUSH
64310: LD_VAR 0 2
64314: ARRAY
64315: NOT
64316: IFFALSE 64320
// break ;
64318: GO 64358
// if not HasTask ( j ) then
64320: LD_VAR 0 3
64324: PPUSH
64325: CALL_OW 314
64329: NOT
64330: IFFALSE 64356
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
64332: LD_VAR 0 3
64336: PPUSH
64337: LD_EXP 66
64341: PUSH
64342: LD_VAR 0 2
64346: ARRAY
64347: PUSH
64348: LD_INT 1
64350: ARRAY
64351: PPUSH
64352: CALL 22589 0 2
// end ;
64356: GO 64206
64358: POP
64359: POP
// end else
64360: GO 65193
// if mc_build_list [ i ] then
64362: LD_EXP 64
64366: PUSH
64367: LD_VAR 0 2
64371: ARRAY
64372: IFFALSE 65193
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64374: LD_ADDR_VAR 0 5
64378: PUSH
64379: LD_EXP 59
64383: PUSH
64384: LD_VAR 0 2
64388: ARRAY
64389: PPUSH
64390: LD_INT 2
64392: PUSH
64393: LD_INT 30
64395: PUSH
64396: LD_INT 0
64398: PUSH
64399: EMPTY
64400: LIST
64401: LIST
64402: PUSH
64403: LD_INT 30
64405: PUSH
64406: LD_INT 1
64408: PUSH
64409: EMPTY
64410: LIST
64411: LIST
64412: PUSH
64413: EMPTY
64414: LIST
64415: LIST
64416: LIST
64417: PPUSH
64418: CALL_OW 72
64422: ST_TO_ADDR
// if depot then
64423: LD_VAR 0 5
64427: IFFALSE 64445
// depot := depot [ 1 ] else
64429: LD_ADDR_VAR 0 5
64433: PUSH
64434: LD_VAR 0 5
64438: PUSH
64439: LD_INT 1
64441: ARRAY
64442: ST_TO_ADDR
64443: GO 64453
// depot := 0 ;
64445: LD_ADDR_VAR 0 5
64449: PUSH
64450: LD_INT 0
64452: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
64453: LD_EXP 64
64457: PUSH
64458: LD_VAR 0 2
64462: ARRAY
64463: PUSH
64464: LD_INT 1
64466: ARRAY
64467: PUSH
64468: LD_INT 1
64470: ARRAY
64471: PPUSH
64472: CALL 22413 0 1
64476: PUSH
64477: LD_EXP 59
64481: PUSH
64482: LD_VAR 0 2
64486: ARRAY
64487: PPUSH
64488: LD_INT 2
64490: PUSH
64491: LD_INT 30
64493: PUSH
64494: LD_INT 2
64496: PUSH
64497: EMPTY
64498: LIST
64499: LIST
64500: PUSH
64501: LD_INT 30
64503: PUSH
64504: LD_INT 3
64506: PUSH
64507: EMPTY
64508: LIST
64509: LIST
64510: PUSH
64511: EMPTY
64512: LIST
64513: LIST
64514: LIST
64515: PPUSH
64516: CALL_OW 72
64520: NOT
64521: AND
64522: IFFALSE 64627
// begin for j = 1 to mc_build_list [ i ] do
64524: LD_ADDR_VAR 0 3
64528: PUSH
64529: DOUBLE
64530: LD_INT 1
64532: DEC
64533: ST_TO_ADDR
64534: LD_EXP 64
64538: PUSH
64539: LD_VAR 0 2
64543: ARRAY
64544: PUSH
64545: FOR_TO
64546: IFFALSE 64625
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
64548: LD_EXP 64
64552: PUSH
64553: LD_VAR 0 2
64557: ARRAY
64558: PUSH
64559: LD_VAR 0 3
64563: ARRAY
64564: PUSH
64565: LD_INT 1
64567: ARRAY
64568: PUSH
64569: LD_INT 2
64571: EQUAL
64572: IFFALSE 64623
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
64574: LD_ADDR_EXP 64
64578: PUSH
64579: LD_EXP 64
64583: PPUSH
64584: LD_VAR 0 2
64588: PPUSH
64589: LD_EXP 64
64593: PUSH
64594: LD_VAR 0 2
64598: ARRAY
64599: PPUSH
64600: LD_VAR 0 3
64604: PPUSH
64605: LD_INT 1
64607: PPUSH
64608: LD_INT 0
64610: PPUSH
64611: CALL 19144 0 4
64615: PPUSH
64616: CALL_OW 1
64620: ST_TO_ADDR
// break ;
64621: GO 64625
// end ;
64623: GO 64545
64625: POP
64626: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
64627: LD_EXP 64
64631: PUSH
64632: LD_VAR 0 2
64636: ARRAY
64637: PUSH
64638: LD_INT 1
64640: ARRAY
64641: PUSH
64642: LD_INT 1
64644: ARRAY
64645: PUSH
64646: LD_INT 0
64648: EQUAL
64649: PUSH
64650: LD_VAR 0 5
64654: PUSH
64655: LD_VAR 0 5
64659: PPUSH
64660: LD_EXP 64
64664: PUSH
64665: LD_VAR 0 2
64669: ARRAY
64670: PUSH
64671: LD_INT 1
64673: ARRAY
64674: PUSH
64675: LD_INT 1
64677: ARRAY
64678: PPUSH
64679: LD_EXP 64
64683: PUSH
64684: LD_VAR 0 2
64688: ARRAY
64689: PUSH
64690: LD_INT 1
64692: ARRAY
64693: PUSH
64694: LD_INT 2
64696: ARRAY
64697: PPUSH
64698: LD_EXP 64
64702: PUSH
64703: LD_VAR 0 2
64707: ARRAY
64708: PUSH
64709: LD_INT 1
64711: ARRAY
64712: PUSH
64713: LD_INT 3
64715: ARRAY
64716: PPUSH
64717: LD_EXP 64
64721: PUSH
64722: LD_VAR 0 2
64726: ARRAY
64727: PUSH
64728: LD_INT 1
64730: ARRAY
64731: PUSH
64732: LD_INT 4
64734: ARRAY
64735: PPUSH
64736: CALL 27829 0 5
64740: AND
64741: OR
64742: IFFALSE 65023
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64744: LD_ADDR_VAR 0 4
64748: PUSH
64749: LD_EXP 59
64753: PUSH
64754: LD_VAR 0 2
64758: ARRAY
64759: PPUSH
64760: LD_INT 25
64762: PUSH
64763: LD_INT 2
64765: PUSH
64766: EMPTY
64767: LIST
64768: LIST
64769: PPUSH
64770: CALL_OW 72
64774: PUSH
64775: LD_EXP 61
64779: PUSH
64780: LD_VAR 0 2
64784: ARRAY
64785: DIFF
64786: ST_TO_ADDR
// if not tmp then
64787: LD_VAR 0 4
64791: NOT
64792: IFFALSE 64796
// continue ;
64794: GO 64041
// for j in tmp do
64796: LD_ADDR_VAR 0 3
64800: PUSH
64801: LD_VAR 0 4
64805: PUSH
64806: FOR_IN
64807: IFFALSE 65019
// begin if not mc_builders [ i ] then
64809: LD_EXP 65
64813: PUSH
64814: LD_VAR 0 2
64818: ARRAY
64819: NOT
64820: IFFALSE 64878
// begin SetTag ( j , 103 ) ;
64822: LD_VAR 0 3
64826: PPUSH
64827: LD_INT 103
64829: PPUSH
64830: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64834: LD_ADDR_EXP 65
64838: PUSH
64839: LD_EXP 65
64843: PPUSH
64844: LD_VAR 0 2
64848: PUSH
64849: LD_EXP 65
64853: PUSH
64854: LD_VAR 0 2
64858: ARRAY
64859: PUSH
64860: LD_INT 1
64862: PLUS
64863: PUSH
64864: EMPTY
64865: LIST
64866: LIST
64867: PPUSH
64868: LD_VAR 0 3
64872: PPUSH
64873: CALL 19726 0 3
64877: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64878: LD_VAR 0 3
64882: PPUSH
64883: CALL_OW 310
64887: IFFALSE 64898
// ComExitBuilding ( j ) ;
64889: LD_VAR 0 3
64893: PPUSH
64894: CALL_OW 122
// wait ( 3 ) ;
64898: LD_INT 3
64900: PPUSH
64901: CALL_OW 67
// if not mc_build_list [ i ] then
64905: LD_EXP 64
64909: PUSH
64910: LD_VAR 0 2
64914: ARRAY
64915: NOT
64916: IFFALSE 64920
// break ;
64918: GO 65019
// if not HasTask ( j ) then
64920: LD_VAR 0 3
64924: PPUSH
64925: CALL_OW 314
64929: NOT
64930: IFFALSE 65017
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
64932: LD_VAR 0 3
64936: PPUSH
64937: LD_EXP 64
64941: PUSH
64942: LD_VAR 0 2
64946: ARRAY
64947: PUSH
64948: LD_INT 1
64950: ARRAY
64951: PUSH
64952: LD_INT 1
64954: ARRAY
64955: PPUSH
64956: LD_EXP 64
64960: PUSH
64961: LD_VAR 0 2
64965: ARRAY
64966: PUSH
64967: LD_INT 1
64969: ARRAY
64970: PUSH
64971: LD_INT 2
64973: ARRAY
64974: PPUSH
64975: LD_EXP 64
64979: PUSH
64980: LD_VAR 0 2
64984: ARRAY
64985: PUSH
64986: LD_INT 1
64988: ARRAY
64989: PUSH
64990: LD_INT 3
64992: ARRAY
64993: PPUSH
64994: LD_EXP 64
64998: PUSH
64999: LD_VAR 0 2
65003: ARRAY
65004: PUSH
65005: LD_INT 1
65007: ARRAY
65008: PUSH
65009: LD_INT 4
65011: ARRAY
65012: PPUSH
65013: CALL_OW 145
// end ;
65017: GO 64806
65019: POP
65020: POP
// end else
65021: GO 65193
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
65023: LD_EXP 59
65027: PUSH
65028: LD_VAR 0 2
65032: ARRAY
65033: PPUSH
65034: LD_EXP 64
65038: PUSH
65039: LD_VAR 0 2
65043: ARRAY
65044: PUSH
65045: LD_INT 1
65047: ARRAY
65048: PUSH
65049: LD_INT 1
65051: ARRAY
65052: PPUSH
65053: LD_EXP 64
65057: PUSH
65058: LD_VAR 0 2
65062: ARRAY
65063: PUSH
65064: LD_INT 1
65066: ARRAY
65067: PUSH
65068: LD_INT 2
65070: ARRAY
65071: PPUSH
65072: LD_EXP 64
65076: PUSH
65077: LD_VAR 0 2
65081: ARRAY
65082: PUSH
65083: LD_INT 1
65085: ARRAY
65086: PUSH
65087: LD_INT 3
65089: ARRAY
65090: PPUSH
65091: LD_EXP 64
65095: PUSH
65096: LD_VAR 0 2
65100: ARRAY
65101: PUSH
65102: LD_INT 1
65104: ARRAY
65105: PUSH
65106: LD_INT 4
65108: ARRAY
65109: PPUSH
65110: LD_EXP 59
65114: PUSH
65115: LD_VAR 0 2
65119: ARRAY
65120: PPUSH
65121: LD_INT 21
65123: PUSH
65124: LD_INT 3
65126: PUSH
65127: EMPTY
65128: LIST
65129: LIST
65130: PPUSH
65131: CALL_OW 72
65135: PPUSH
65136: EMPTY
65137: PPUSH
65138: CALL 26579 0 7
65142: NOT
65143: IFFALSE 65193
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
65145: LD_ADDR_EXP 64
65149: PUSH
65150: LD_EXP 64
65154: PPUSH
65155: LD_VAR 0 2
65159: PPUSH
65160: LD_EXP 64
65164: PUSH
65165: LD_VAR 0 2
65169: ARRAY
65170: PPUSH
65171: LD_INT 1
65173: PPUSH
65174: LD_INT 1
65176: NEG
65177: PPUSH
65178: LD_INT 0
65180: PPUSH
65181: CALL 19144 0 4
65185: PPUSH
65186: CALL_OW 1
65190: ST_TO_ADDR
// continue ;
65191: GO 64041
// end ; end ; end ;
65193: GO 64041
65195: POP
65196: POP
// end ;
65197: LD_VAR 0 1
65201: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
65202: LD_INT 0
65204: PPUSH
65205: PPUSH
65206: PPUSH
65207: PPUSH
65208: PPUSH
65209: PPUSH
// if not mc_bases then
65210: LD_EXP 59
65214: NOT
65215: IFFALSE 65219
// exit ;
65217: GO 65646
// for i = 1 to mc_bases do
65219: LD_ADDR_VAR 0 2
65223: PUSH
65224: DOUBLE
65225: LD_INT 1
65227: DEC
65228: ST_TO_ADDR
65229: LD_EXP 59
65233: PUSH
65234: FOR_TO
65235: IFFALSE 65644
// begin tmp := mc_build_upgrade [ i ] ;
65237: LD_ADDR_VAR 0 4
65241: PUSH
65242: LD_EXP 91
65246: PUSH
65247: LD_VAR 0 2
65251: ARRAY
65252: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
65253: LD_ADDR_VAR 0 6
65257: PUSH
65258: LD_EXP 92
65262: PUSH
65263: LD_VAR 0 2
65267: ARRAY
65268: PPUSH
65269: LD_INT 2
65271: PUSH
65272: LD_INT 30
65274: PUSH
65275: LD_INT 6
65277: PUSH
65278: EMPTY
65279: LIST
65280: LIST
65281: PUSH
65282: LD_INT 30
65284: PUSH
65285: LD_INT 7
65287: PUSH
65288: EMPTY
65289: LIST
65290: LIST
65291: PUSH
65292: EMPTY
65293: LIST
65294: LIST
65295: LIST
65296: PPUSH
65297: CALL_OW 72
65301: ST_TO_ADDR
// if not tmp and not lab then
65302: LD_VAR 0 4
65306: NOT
65307: PUSH
65308: LD_VAR 0 6
65312: NOT
65313: AND
65314: IFFALSE 65318
// continue ;
65316: GO 65234
// if tmp then
65318: LD_VAR 0 4
65322: IFFALSE 65442
// for j in tmp do
65324: LD_ADDR_VAR 0 3
65328: PUSH
65329: LD_VAR 0 4
65333: PUSH
65334: FOR_IN
65335: IFFALSE 65440
// begin if UpgradeCost ( j ) then
65337: LD_VAR 0 3
65341: PPUSH
65342: CALL 26239 0 1
65346: IFFALSE 65438
// begin ComUpgrade ( j ) ;
65348: LD_VAR 0 3
65352: PPUSH
65353: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
65357: LD_ADDR_EXP 91
65361: PUSH
65362: LD_EXP 91
65366: PPUSH
65367: LD_VAR 0 2
65371: PPUSH
65372: LD_EXP 91
65376: PUSH
65377: LD_VAR 0 2
65381: ARRAY
65382: PUSH
65383: LD_VAR 0 3
65387: DIFF
65388: PPUSH
65389: CALL_OW 1
65393: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65394: LD_ADDR_EXP 66
65398: PUSH
65399: LD_EXP 66
65403: PPUSH
65404: LD_VAR 0 2
65408: PUSH
65409: LD_EXP 66
65413: PUSH
65414: LD_VAR 0 2
65418: ARRAY
65419: PUSH
65420: LD_INT 1
65422: PLUS
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: PPUSH
65428: LD_VAR 0 3
65432: PPUSH
65433: CALL 19726 0 3
65437: ST_TO_ADDR
// end ; end ;
65438: GO 65334
65440: POP
65441: POP
// if not lab or not mc_lab_upgrade [ i ] then
65442: LD_VAR 0 6
65446: NOT
65447: PUSH
65448: LD_EXP 93
65452: PUSH
65453: LD_VAR 0 2
65457: ARRAY
65458: NOT
65459: OR
65460: IFFALSE 65464
// continue ;
65462: GO 65234
// for j in lab do
65464: LD_ADDR_VAR 0 3
65468: PUSH
65469: LD_VAR 0 6
65473: PUSH
65474: FOR_IN
65475: IFFALSE 65640
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
65477: LD_VAR 0 3
65481: PPUSH
65482: CALL_OW 266
65486: PUSH
65487: LD_INT 6
65489: PUSH
65490: LD_INT 7
65492: PUSH
65493: EMPTY
65494: LIST
65495: LIST
65496: IN
65497: PUSH
65498: LD_VAR 0 3
65502: PPUSH
65503: CALL_OW 461
65507: PUSH
65508: LD_INT 1
65510: NONEQUAL
65511: AND
65512: IFFALSE 65638
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
65514: LD_VAR 0 3
65518: PPUSH
65519: LD_EXP 93
65523: PUSH
65524: LD_VAR 0 2
65528: ARRAY
65529: PUSH
65530: LD_INT 1
65532: ARRAY
65533: PPUSH
65534: CALL 26444 0 2
65538: IFFALSE 65638
// begin ComCancel ( j ) ;
65540: LD_VAR 0 3
65544: PPUSH
65545: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
65549: LD_VAR 0 3
65553: PPUSH
65554: LD_EXP 93
65558: PUSH
65559: LD_VAR 0 2
65563: ARRAY
65564: PUSH
65565: LD_INT 1
65567: ARRAY
65568: PPUSH
65569: CALL_OW 207
// if not j in mc_construct_list [ i ] then
65573: LD_VAR 0 3
65577: PUSH
65578: LD_EXP 66
65582: PUSH
65583: LD_VAR 0 2
65587: ARRAY
65588: IN
65589: NOT
65590: IFFALSE 65636
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65592: LD_ADDR_EXP 66
65596: PUSH
65597: LD_EXP 66
65601: PPUSH
65602: LD_VAR 0 2
65606: PUSH
65607: LD_EXP 66
65611: PUSH
65612: LD_VAR 0 2
65616: ARRAY
65617: PUSH
65618: LD_INT 1
65620: PLUS
65621: PUSH
65622: EMPTY
65623: LIST
65624: LIST
65625: PPUSH
65626: LD_VAR 0 3
65630: PPUSH
65631: CALL 19726 0 3
65635: ST_TO_ADDR
// break ;
65636: GO 65640
// end ; end ; end ;
65638: GO 65474
65640: POP
65641: POP
// end ;
65642: GO 65234
65644: POP
65645: POP
// end ;
65646: LD_VAR 0 1
65650: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
65651: LD_INT 0
65653: PPUSH
65654: PPUSH
65655: PPUSH
65656: PPUSH
65657: PPUSH
65658: PPUSH
65659: PPUSH
65660: PPUSH
65661: PPUSH
// if not mc_bases then
65662: LD_EXP 59
65666: NOT
65667: IFFALSE 65671
// exit ;
65669: GO 66076
// for i = 1 to mc_bases do
65671: LD_ADDR_VAR 0 2
65675: PUSH
65676: DOUBLE
65677: LD_INT 1
65679: DEC
65680: ST_TO_ADDR
65681: LD_EXP 59
65685: PUSH
65686: FOR_TO
65687: IFFALSE 66074
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
65689: LD_EXP 67
65693: PUSH
65694: LD_VAR 0 2
65698: ARRAY
65699: NOT
65700: PUSH
65701: LD_EXP 59
65705: PUSH
65706: LD_VAR 0 2
65710: ARRAY
65711: PPUSH
65712: LD_INT 30
65714: PUSH
65715: LD_INT 3
65717: PUSH
65718: EMPTY
65719: LIST
65720: LIST
65721: PPUSH
65722: CALL_OW 72
65726: NOT
65727: OR
65728: IFFALSE 65732
// continue ;
65730: GO 65686
// busy := false ;
65732: LD_ADDR_VAR 0 8
65736: PUSH
65737: LD_INT 0
65739: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65740: LD_ADDR_VAR 0 4
65744: PUSH
65745: LD_EXP 59
65749: PUSH
65750: LD_VAR 0 2
65754: ARRAY
65755: PPUSH
65756: LD_INT 30
65758: PUSH
65759: LD_INT 3
65761: PUSH
65762: EMPTY
65763: LIST
65764: LIST
65765: PPUSH
65766: CALL_OW 72
65770: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
65771: LD_ADDR_VAR 0 6
65775: PUSH
65776: LD_EXP 67
65780: PUSH
65781: LD_VAR 0 2
65785: ARRAY
65786: PPUSH
65787: LD_INT 2
65789: PUSH
65790: LD_INT 30
65792: PUSH
65793: LD_INT 32
65795: PUSH
65796: EMPTY
65797: LIST
65798: LIST
65799: PUSH
65800: LD_INT 30
65802: PUSH
65803: LD_INT 33
65805: PUSH
65806: EMPTY
65807: LIST
65808: LIST
65809: PUSH
65810: EMPTY
65811: LIST
65812: LIST
65813: LIST
65814: PPUSH
65815: CALL_OW 72
65819: ST_TO_ADDR
// if not t then
65820: LD_VAR 0 6
65824: NOT
65825: IFFALSE 65829
// continue ;
65827: GO 65686
// for j in tmp do
65829: LD_ADDR_VAR 0 3
65833: PUSH
65834: LD_VAR 0 4
65838: PUSH
65839: FOR_IN
65840: IFFALSE 65870
// if not BuildingStatus ( j ) = bs_idle then
65842: LD_VAR 0 3
65846: PPUSH
65847: CALL_OW 461
65851: PUSH
65852: LD_INT 2
65854: EQUAL
65855: NOT
65856: IFFALSE 65868
// begin busy := true ;
65858: LD_ADDR_VAR 0 8
65862: PUSH
65863: LD_INT 1
65865: ST_TO_ADDR
// break ;
65866: GO 65870
// end ;
65868: GO 65839
65870: POP
65871: POP
// if busy then
65872: LD_VAR 0 8
65876: IFFALSE 65880
// continue ;
65878: GO 65686
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
65880: LD_ADDR_VAR 0 7
65884: PUSH
65885: LD_VAR 0 6
65889: PPUSH
65890: LD_INT 35
65892: PUSH
65893: LD_INT 0
65895: PUSH
65896: EMPTY
65897: LIST
65898: LIST
65899: PPUSH
65900: CALL_OW 72
65904: ST_TO_ADDR
// if tw then
65905: LD_VAR 0 7
65909: IFFALSE 65986
// begin tw := tw [ 1 ] ;
65911: LD_ADDR_VAR 0 7
65915: PUSH
65916: LD_VAR 0 7
65920: PUSH
65921: LD_INT 1
65923: ARRAY
65924: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
65925: LD_ADDR_VAR 0 9
65929: PUSH
65930: LD_VAR 0 7
65934: PPUSH
65935: LD_EXP 84
65939: PUSH
65940: LD_VAR 0 2
65944: ARRAY
65945: PPUSH
65946: CALL 24736 0 2
65950: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
65951: LD_EXP 98
65955: PUSH
65956: LD_VAR 0 2
65960: ARRAY
65961: IFFALSE 65984
// if not weapon in mc_allowed_tower_weapons [ i ] then
65963: LD_VAR 0 9
65967: PUSH
65968: LD_EXP 98
65972: PUSH
65973: LD_VAR 0 2
65977: ARRAY
65978: IN
65979: NOT
65980: IFFALSE 65984
// continue ;
65982: GO 65686
// end else
65984: GO 66049
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
65986: LD_ADDR_VAR 0 5
65990: PUSH
65991: LD_EXP 67
65995: PUSH
65996: LD_VAR 0 2
66000: ARRAY
66001: PPUSH
66002: LD_VAR 0 4
66006: PPUSH
66007: CALL 51025 0 2
66011: ST_TO_ADDR
// if not tmp2 then
66012: LD_VAR 0 5
66016: NOT
66017: IFFALSE 66021
// continue ;
66019: GO 65686
// tw := tmp2 [ 1 ] ;
66021: LD_ADDR_VAR 0 7
66025: PUSH
66026: LD_VAR 0 5
66030: PUSH
66031: LD_INT 1
66033: ARRAY
66034: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
66035: LD_ADDR_VAR 0 9
66039: PUSH
66040: LD_VAR 0 5
66044: PUSH
66045: LD_INT 2
66047: ARRAY
66048: ST_TO_ADDR
// end ; if not weapon then
66049: LD_VAR 0 9
66053: NOT
66054: IFFALSE 66058
// continue ;
66056: GO 65686
// ComPlaceWeapon ( tw , weapon ) ;
66058: LD_VAR 0 7
66062: PPUSH
66063: LD_VAR 0 9
66067: PPUSH
66068: CALL_OW 148
// end ;
66072: GO 65686
66074: POP
66075: POP
// end ;
66076: LD_VAR 0 1
66080: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
66081: LD_INT 0
66083: PPUSH
66084: PPUSH
66085: PPUSH
66086: PPUSH
66087: PPUSH
66088: PPUSH
66089: PPUSH
// if not mc_bases then
66090: LD_EXP 59
66094: NOT
66095: IFFALSE 66099
// exit ;
66097: GO 66867
// for i = 1 to mc_bases do
66099: LD_ADDR_VAR 0 2
66103: PUSH
66104: DOUBLE
66105: LD_INT 1
66107: DEC
66108: ST_TO_ADDR
66109: LD_EXP 59
66113: PUSH
66114: FOR_TO
66115: IFFALSE 66865
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
66117: LD_EXP 72
66121: PUSH
66122: LD_VAR 0 2
66126: ARRAY
66127: NOT
66128: PUSH
66129: LD_EXP 72
66133: PUSH
66134: LD_VAR 0 2
66138: ARRAY
66139: PUSH
66140: LD_EXP 73
66144: PUSH
66145: LD_VAR 0 2
66149: ARRAY
66150: EQUAL
66151: OR
66152: PUSH
66153: LD_EXP 82
66157: PUSH
66158: LD_VAR 0 2
66162: ARRAY
66163: OR
66164: IFFALSE 66168
// continue ;
66166: GO 66114
// if mc_miners [ i ] then
66168: LD_EXP 73
66172: PUSH
66173: LD_VAR 0 2
66177: ARRAY
66178: IFFALSE 66552
// begin for j = mc_miners [ i ] downto 1 do
66180: LD_ADDR_VAR 0 3
66184: PUSH
66185: DOUBLE
66186: LD_EXP 73
66190: PUSH
66191: LD_VAR 0 2
66195: ARRAY
66196: INC
66197: ST_TO_ADDR
66198: LD_INT 1
66200: PUSH
66201: FOR_DOWNTO
66202: IFFALSE 66550
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
66204: LD_EXP 73
66208: PUSH
66209: LD_VAR 0 2
66213: ARRAY
66214: PUSH
66215: LD_VAR 0 3
66219: ARRAY
66220: PPUSH
66221: CALL_OW 301
66225: PUSH
66226: LD_EXP 73
66230: PUSH
66231: LD_VAR 0 2
66235: ARRAY
66236: PUSH
66237: LD_VAR 0 3
66241: ARRAY
66242: PPUSH
66243: CALL_OW 257
66247: PUSH
66248: LD_INT 1
66250: NONEQUAL
66251: OR
66252: IFFALSE 66315
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
66254: LD_ADDR_VAR 0 5
66258: PUSH
66259: LD_EXP 73
66263: PUSH
66264: LD_VAR 0 2
66268: ARRAY
66269: PUSH
66270: LD_EXP 73
66274: PUSH
66275: LD_VAR 0 2
66279: ARRAY
66280: PUSH
66281: LD_VAR 0 3
66285: ARRAY
66286: DIFF
66287: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
66288: LD_ADDR_EXP 73
66292: PUSH
66293: LD_EXP 73
66297: PPUSH
66298: LD_VAR 0 2
66302: PPUSH
66303: LD_VAR 0 5
66307: PPUSH
66308: CALL_OW 1
66312: ST_TO_ADDR
// continue ;
66313: GO 66201
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
66315: LD_EXP 73
66319: PUSH
66320: LD_VAR 0 2
66324: ARRAY
66325: PUSH
66326: LD_VAR 0 3
66330: ARRAY
66331: PPUSH
66332: CALL_OW 257
66336: PUSH
66337: LD_INT 1
66339: EQUAL
66340: PUSH
66341: LD_EXP 73
66345: PUSH
66346: LD_VAR 0 2
66350: ARRAY
66351: PUSH
66352: LD_VAR 0 3
66356: ARRAY
66357: PPUSH
66358: CALL_OW 459
66362: NOT
66363: AND
66364: PUSH
66365: LD_EXP 73
66369: PUSH
66370: LD_VAR 0 2
66374: ARRAY
66375: PUSH
66376: LD_VAR 0 3
66380: ARRAY
66381: PPUSH
66382: CALL_OW 314
66386: NOT
66387: AND
66388: IFFALSE 66548
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
66390: LD_EXP 73
66394: PUSH
66395: LD_VAR 0 2
66399: ARRAY
66400: PUSH
66401: LD_VAR 0 3
66405: ARRAY
66406: PPUSH
66407: CALL_OW 310
66411: IFFALSE 66434
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
66413: LD_EXP 73
66417: PUSH
66418: LD_VAR 0 2
66422: ARRAY
66423: PUSH
66424: LD_VAR 0 3
66428: ARRAY
66429: PPUSH
66430: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
66434: LD_EXP 73
66438: PUSH
66439: LD_VAR 0 2
66443: ARRAY
66444: PUSH
66445: LD_VAR 0 3
66449: ARRAY
66450: PPUSH
66451: CALL_OW 314
66455: NOT
66456: IFFALSE 66548
// begin r := rand ( 1 , mc_mines [ i ] ) ;
66458: LD_ADDR_VAR 0 7
66462: PUSH
66463: LD_INT 1
66465: PPUSH
66466: LD_EXP 72
66470: PUSH
66471: LD_VAR 0 2
66475: ARRAY
66476: PPUSH
66477: CALL_OW 12
66481: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
66482: LD_EXP 73
66486: PUSH
66487: LD_VAR 0 2
66491: ARRAY
66492: PUSH
66493: LD_VAR 0 3
66497: ARRAY
66498: PPUSH
66499: LD_EXP 72
66503: PUSH
66504: LD_VAR 0 2
66508: ARRAY
66509: PUSH
66510: LD_VAR 0 7
66514: ARRAY
66515: PUSH
66516: LD_INT 1
66518: ARRAY
66519: PPUSH
66520: LD_EXP 72
66524: PUSH
66525: LD_VAR 0 2
66529: ARRAY
66530: PUSH
66531: LD_VAR 0 7
66535: ARRAY
66536: PUSH
66537: LD_INT 2
66539: ARRAY
66540: PPUSH
66541: LD_INT 0
66543: PPUSH
66544: CALL_OW 193
// end ; end ; end ;
66548: GO 66201
66550: POP
66551: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
66552: LD_ADDR_VAR 0 5
66556: PUSH
66557: LD_EXP 59
66561: PUSH
66562: LD_VAR 0 2
66566: ARRAY
66567: PPUSH
66568: LD_INT 2
66570: PUSH
66571: LD_INT 30
66573: PUSH
66574: LD_INT 4
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: PUSH
66581: LD_INT 30
66583: PUSH
66584: LD_INT 5
66586: PUSH
66587: EMPTY
66588: LIST
66589: LIST
66590: PUSH
66591: LD_INT 30
66593: PUSH
66594: LD_INT 32
66596: PUSH
66597: EMPTY
66598: LIST
66599: LIST
66600: PUSH
66601: EMPTY
66602: LIST
66603: LIST
66604: LIST
66605: LIST
66606: PPUSH
66607: CALL_OW 72
66611: ST_TO_ADDR
// if not tmp then
66612: LD_VAR 0 5
66616: NOT
66617: IFFALSE 66621
// continue ;
66619: GO 66114
// list := [ ] ;
66621: LD_ADDR_VAR 0 6
66625: PUSH
66626: EMPTY
66627: ST_TO_ADDR
// for j in tmp do
66628: LD_ADDR_VAR 0 3
66632: PUSH
66633: LD_VAR 0 5
66637: PUSH
66638: FOR_IN
66639: IFFALSE 66708
// begin for k in UnitsInside ( j ) do
66641: LD_ADDR_VAR 0 4
66645: PUSH
66646: LD_VAR 0 3
66650: PPUSH
66651: CALL_OW 313
66655: PUSH
66656: FOR_IN
66657: IFFALSE 66704
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
66659: LD_VAR 0 4
66663: PPUSH
66664: CALL_OW 257
66668: PUSH
66669: LD_INT 1
66671: EQUAL
66672: PUSH
66673: LD_VAR 0 4
66677: PPUSH
66678: CALL_OW 459
66682: NOT
66683: AND
66684: IFFALSE 66702
// list := list ^ k ;
66686: LD_ADDR_VAR 0 6
66690: PUSH
66691: LD_VAR 0 6
66695: PUSH
66696: LD_VAR 0 4
66700: ADD
66701: ST_TO_ADDR
66702: GO 66656
66704: POP
66705: POP
// end ;
66706: GO 66638
66708: POP
66709: POP
// list := list diff mc_miners [ i ] ;
66710: LD_ADDR_VAR 0 6
66714: PUSH
66715: LD_VAR 0 6
66719: PUSH
66720: LD_EXP 73
66724: PUSH
66725: LD_VAR 0 2
66729: ARRAY
66730: DIFF
66731: ST_TO_ADDR
// if not list then
66732: LD_VAR 0 6
66736: NOT
66737: IFFALSE 66741
// continue ;
66739: GO 66114
// k := mc_mines [ i ] - mc_miners [ i ] ;
66741: LD_ADDR_VAR 0 4
66745: PUSH
66746: LD_EXP 72
66750: PUSH
66751: LD_VAR 0 2
66755: ARRAY
66756: PUSH
66757: LD_EXP 73
66761: PUSH
66762: LD_VAR 0 2
66766: ARRAY
66767: MINUS
66768: ST_TO_ADDR
// if k > list then
66769: LD_VAR 0 4
66773: PUSH
66774: LD_VAR 0 6
66778: GREATER
66779: IFFALSE 66791
// k := list ;
66781: LD_ADDR_VAR 0 4
66785: PUSH
66786: LD_VAR 0 6
66790: ST_TO_ADDR
// for j = 1 to k do
66791: LD_ADDR_VAR 0 3
66795: PUSH
66796: DOUBLE
66797: LD_INT 1
66799: DEC
66800: ST_TO_ADDR
66801: LD_VAR 0 4
66805: PUSH
66806: FOR_TO
66807: IFFALSE 66861
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
66809: LD_ADDR_EXP 73
66813: PUSH
66814: LD_EXP 73
66818: PPUSH
66819: LD_VAR 0 2
66823: PUSH
66824: LD_EXP 73
66828: PUSH
66829: LD_VAR 0 2
66833: ARRAY
66834: PUSH
66835: LD_INT 1
66837: PLUS
66838: PUSH
66839: EMPTY
66840: LIST
66841: LIST
66842: PPUSH
66843: LD_VAR 0 6
66847: PUSH
66848: LD_VAR 0 3
66852: ARRAY
66853: PPUSH
66854: CALL 19726 0 3
66858: ST_TO_ADDR
66859: GO 66806
66861: POP
66862: POP
// end ;
66863: GO 66114
66865: POP
66866: POP
// end ;
66867: LD_VAR 0 1
66871: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
66872: LD_INT 0
66874: PPUSH
66875: PPUSH
66876: PPUSH
66877: PPUSH
66878: PPUSH
66879: PPUSH
66880: PPUSH
66881: PPUSH
66882: PPUSH
66883: PPUSH
66884: PPUSH
// if not mc_bases then
66885: LD_EXP 59
66889: NOT
66890: IFFALSE 66894
// exit ;
66892: GO 68717
// for i = 1 to mc_bases do
66894: LD_ADDR_VAR 0 2
66898: PUSH
66899: DOUBLE
66900: LD_INT 1
66902: DEC
66903: ST_TO_ADDR
66904: LD_EXP 59
66908: PUSH
66909: FOR_TO
66910: IFFALSE 68715
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
66912: LD_EXP 59
66916: PUSH
66917: LD_VAR 0 2
66921: ARRAY
66922: NOT
66923: PUSH
66924: LD_EXP 66
66928: PUSH
66929: LD_VAR 0 2
66933: ARRAY
66934: OR
66935: IFFALSE 66939
// continue ;
66937: GO 66909
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
66939: LD_EXP 75
66943: PUSH
66944: LD_VAR 0 2
66948: ARRAY
66949: NOT
66950: PUSH
66951: LD_EXP 76
66955: PUSH
66956: LD_VAR 0 2
66960: ARRAY
66961: AND
66962: IFFALSE 67000
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
66964: LD_ADDR_EXP 76
66968: PUSH
66969: LD_EXP 76
66973: PPUSH
66974: LD_VAR 0 2
66978: PPUSH
66979: EMPTY
66980: PPUSH
66981: CALL_OW 1
66985: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
66986: LD_VAR 0 2
66990: PPUSH
66991: LD_INT 107
66993: PPUSH
66994: CALL 57768 0 2
// continue ;
66998: GO 66909
// end ; target := [ ] ;
67000: LD_ADDR_VAR 0 7
67004: PUSH
67005: EMPTY
67006: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
67007: LD_ADDR_VAR 0 6
67011: PUSH
67012: LD_EXP 59
67016: PUSH
67017: LD_VAR 0 2
67021: ARRAY
67022: PUSH
67023: LD_INT 1
67025: ARRAY
67026: PPUSH
67027: CALL_OW 255
67031: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67032: LD_ADDR_VAR 0 9
67036: PUSH
67037: LD_EXP 59
67041: PUSH
67042: LD_VAR 0 2
67046: ARRAY
67047: PPUSH
67048: LD_INT 2
67050: PUSH
67051: LD_INT 30
67053: PUSH
67054: LD_INT 0
67056: PUSH
67057: EMPTY
67058: LIST
67059: LIST
67060: PUSH
67061: LD_INT 30
67063: PUSH
67064: LD_INT 1
67066: PUSH
67067: EMPTY
67068: LIST
67069: LIST
67070: PUSH
67071: EMPTY
67072: LIST
67073: LIST
67074: LIST
67075: PPUSH
67076: CALL_OW 72
67080: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
67081: LD_ADDR_VAR 0 3
67085: PUSH
67086: DOUBLE
67087: LD_EXP 75
67091: PUSH
67092: LD_VAR 0 2
67096: ARRAY
67097: INC
67098: ST_TO_ADDR
67099: LD_INT 1
67101: PUSH
67102: FOR_DOWNTO
67103: IFFALSE 67348
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
67105: LD_EXP 75
67109: PUSH
67110: LD_VAR 0 2
67114: ARRAY
67115: PUSH
67116: LD_VAR 0 3
67120: ARRAY
67121: PUSH
67122: LD_INT 2
67124: ARRAY
67125: PPUSH
67126: LD_EXP 75
67130: PUSH
67131: LD_VAR 0 2
67135: ARRAY
67136: PUSH
67137: LD_VAR 0 3
67141: ARRAY
67142: PUSH
67143: LD_INT 3
67145: ARRAY
67146: PPUSH
67147: CALL_OW 488
67151: PUSH
67152: LD_EXP 75
67156: PUSH
67157: LD_VAR 0 2
67161: ARRAY
67162: PUSH
67163: LD_VAR 0 3
67167: ARRAY
67168: PUSH
67169: LD_INT 2
67171: ARRAY
67172: PPUSH
67173: LD_EXP 75
67177: PUSH
67178: LD_VAR 0 2
67182: ARRAY
67183: PUSH
67184: LD_VAR 0 3
67188: ARRAY
67189: PUSH
67190: LD_INT 3
67192: ARRAY
67193: PPUSH
67194: CALL_OW 284
67198: PUSH
67199: LD_INT 0
67201: EQUAL
67202: AND
67203: IFFALSE 67258
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
67205: LD_ADDR_VAR 0 5
67209: PUSH
67210: LD_EXP 75
67214: PUSH
67215: LD_VAR 0 2
67219: ARRAY
67220: PPUSH
67221: LD_VAR 0 3
67225: PPUSH
67226: CALL_OW 3
67230: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
67231: LD_ADDR_EXP 75
67235: PUSH
67236: LD_EXP 75
67240: PPUSH
67241: LD_VAR 0 2
67245: PPUSH
67246: LD_VAR 0 5
67250: PPUSH
67251: CALL_OW 1
67255: ST_TO_ADDR
// continue ;
67256: GO 67102
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
67258: LD_VAR 0 6
67262: PPUSH
67263: LD_EXP 75
67267: PUSH
67268: LD_VAR 0 2
67272: ARRAY
67273: PUSH
67274: LD_VAR 0 3
67278: ARRAY
67279: PUSH
67280: LD_INT 2
67282: ARRAY
67283: PPUSH
67284: LD_EXP 75
67288: PUSH
67289: LD_VAR 0 2
67293: ARRAY
67294: PUSH
67295: LD_VAR 0 3
67299: ARRAY
67300: PUSH
67301: LD_INT 3
67303: ARRAY
67304: PPUSH
67305: LD_INT 30
67307: PPUSH
67308: CALL 20622 0 4
67312: PUSH
67313: LD_INT 4
67315: ARRAY
67316: PUSH
67317: LD_INT 0
67319: EQUAL
67320: IFFALSE 67346
// begin target := mc_crates [ i ] [ j ] ;
67322: LD_ADDR_VAR 0 7
67326: PUSH
67327: LD_EXP 75
67331: PUSH
67332: LD_VAR 0 2
67336: ARRAY
67337: PUSH
67338: LD_VAR 0 3
67342: ARRAY
67343: ST_TO_ADDR
// break ;
67344: GO 67348
// end ; end ;
67346: GO 67102
67348: POP
67349: POP
// if not target then
67350: LD_VAR 0 7
67354: NOT
67355: IFFALSE 67359
// continue ;
67357: GO 66909
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
67359: LD_ADDR_VAR 0 8
67363: PUSH
67364: LD_EXP 78
67368: PUSH
67369: LD_VAR 0 2
67373: ARRAY
67374: PPUSH
67375: LD_INT 2
67377: PUSH
67378: LD_INT 3
67380: PUSH
67381: LD_INT 58
67383: PUSH
67384: EMPTY
67385: LIST
67386: PUSH
67387: EMPTY
67388: LIST
67389: LIST
67390: PUSH
67391: LD_INT 61
67393: PUSH
67394: EMPTY
67395: LIST
67396: PUSH
67397: LD_INT 33
67399: PUSH
67400: LD_INT 5
67402: PUSH
67403: EMPTY
67404: LIST
67405: LIST
67406: PUSH
67407: LD_INT 33
67409: PUSH
67410: LD_INT 3
67412: PUSH
67413: EMPTY
67414: LIST
67415: LIST
67416: PUSH
67417: EMPTY
67418: LIST
67419: LIST
67420: LIST
67421: LIST
67422: LIST
67423: PUSH
67424: LD_INT 2
67426: PUSH
67427: LD_INT 34
67429: PUSH
67430: LD_INT 32
67432: PUSH
67433: EMPTY
67434: LIST
67435: LIST
67436: PUSH
67437: LD_INT 34
67439: PUSH
67440: LD_INT 51
67442: PUSH
67443: EMPTY
67444: LIST
67445: LIST
67446: PUSH
67447: LD_INT 34
67449: PUSH
67450: LD_INT 12
67452: PUSH
67453: EMPTY
67454: LIST
67455: LIST
67456: PUSH
67457: EMPTY
67458: LIST
67459: LIST
67460: LIST
67461: LIST
67462: PUSH
67463: EMPTY
67464: LIST
67465: LIST
67466: PPUSH
67467: CALL_OW 72
67471: ST_TO_ADDR
// if not cargo then
67472: LD_VAR 0 8
67476: NOT
67477: IFFALSE 68183
// begin if mc_crates_collector [ i ] < 5 then
67479: LD_EXP 76
67483: PUSH
67484: LD_VAR 0 2
67488: ARRAY
67489: PUSH
67490: LD_INT 5
67492: LESS
67493: IFFALSE 67859
// begin if mc_ape [ i ] then
67495: LD_EXP 88
67499: PUSH
67500: LD_VAR 0 2
67504: ARRAY
67505: IFFALSE 67552
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
67507: LD_ADDR_VAR 0 5
67511: PUSH
67512: LD_EXP 88
67516: PUSH
67517: LD_VAR 0 2
67521: ARRAY
67522: PPUSH
67523: LD_INT 25
67525: PUSH
67526: LD_INT 16
67528: PUSH
67529: EMPTY
67530: LIST
67531: LIST
67532: PUSH
67533: LD_INT 24
67535: PUSH
67536: LD_INT 750
67538: PUSH
67539: EMPTY
67540: LIST
67541: LIST
67542: PUSH
67543: EMPTY
67544: LIST
67545: LIST
67546: PPUSH
67547: CALL_OW 72
67551: ST_TO_ADDR
// if not tmp then
67552: LD_VAR 0 5
67556: NOT
67557: IFFALSE 67604
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
67559: LD_ADDR_VAR 0 5
67563: PUSH
67564: LD_EXP 59
67568: PUSH
67569: LD_VAR 0 2
67573: ARRAY
67574: PPUSH
67575: LD_INT 25
67577: PUSH
67578: LD_INT 2
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: PUSH
67585: LD_INT 24
67587: PUSH
67588: LD_INT 750
67590: PUSH
67591: EMPTY
67592: LIST
67593: LIST
67594: PUSH
67595: EMPTY
67596: LIST
67597: LIST
67598: PPUSH
67599: CALL_OW 72
67603: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
67604: LD_EXP 88
67608: PUSH
67609: LD_VAR 0 2
67613: ARRAY
67614: PUSH
67615: LD_EXP 59
67619: PUSH
67620: LD_VAR 0 2
67624: ARRAY
67625: PPUSH
67626: LD_INT 25
67628: PUSH
67629: LD_INT 2
67631: PUSH
67632: EMPTY
67633: LIST
67634: LIST
67635: PUSH
67636: LD_INT 24
67638: PUSH
67639: LD_INT 750
67641: PUSH
67642: EMPTY
67643: LIST
67644: LIST
67645: PUSH
67646: EMPTY
67647: LIST
67648: LIST
67649: PPUSH
67650: CALL_OW 72
67654: AND
67655: PUSH
67656: LD_VAR 0 5
67660: PUSH
67661: LD_INT 5
67663: LESS
67664: AND
67665: IFFALSE 67747
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
67667: LD_ADDR_VAR 0 3
67671: PUSH
67672: LD_EXP 59
67676: PUSH
67677: LD_VAR 0 2
67681: ARRAY
67682: PPUSH
67683: LD_INT 25
67685: PUSH
67686: LD_INT 2
67688: PUSH
67689: EMPTY
67690: LIST
67691: LIST
67692: PUSH
67693: LD_INT 24
67695: PUSH
67696: LD_INT 750
67698: PUSH
67699: EMPTY
67700: LIST
67701: LIST
67702: PUSH
67703: EMPTY
67704: LIST
67705: LIST
67706: PPUSH
67707: CALL_OW 72
67711: PUSH
67712: FOR_IN
67713: IFFALSE 67745
// begin tmp := tmp union j ;
67715: LD_ADDR_VAR 0 5
67719: PUSH
67720: LD_VAR 0 5
67724: PUSH
67725: LD_VAR 0 3
67729: UNION
67730: ST_TO_ADDR
// if tmp >= 5 then
67731: LD_VAR 0 5
67735: PUSH
67736: LD_INT 5
67738: GREATEREQUAL
67739: IFFALSE 67743
// break ;
67741: GO 67745
// end ;
67743: GO 67712
67745: POP
67746: POP
// end ; if not tmp then
67747: LD_VAR 0 5
67751: NOT
67752: IFFALSE 67756
// continue ;
67754: GO 66909
// for j in tmp do
67756: LD_ADDR_VAR 0 3
67760: PUSH
67761: LD_VAR 0 5
67765: PUSH
67766: FOR_IN
67767: IFFALSE 67857
// if not GetTag ( j ) then
67769: LD_VAR 0 3
67773: PPUSH
67774: CALL_OW 110
67778: NOT
67779: IFFALSE 67855
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
67781: LD_ADDR_EXP 76
67785: PUSH
67786: LD_EXP 76
67790: PPUSH
67791: LD_VAR 0 2
67795: PUSH
67796: LD_EXP 76
67800: PUSH
67801: LD_VAR 0 2
67805: ARRAY
67806: PUSH
67807: LD_INT 1
67809: PLUS
67810: PUSH
67811: EMPTY
67812: LIST
67813: LIST
67814: PPUSH
67815: LD_VAR 0 3
67819: PPUSH
67820: CALL 19726 0 3
67824: ST_TO_ADDR
// SetTag ( j , 107 ) ;
67825: LD_VAR 0 3
67829: PPUSH
67830: LD_INT 107
67832: PPUSH
67833: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
67837: LD_EXP 76
67841: PUSH
67842: LD_VAR 0 2
67846: ARRAY
67847: PUSH
67848: LD_INT 5
67850: GREATEREQUAL
67851: IFFALSE 67855
// break ;
67853: GO 67857
// end ;
67855: GO 67766
67857: POP
67858: POP
// end ; if mc_crates_collector [ i ] and target then
67859: LD_EXP 76
67863: PUSH
67864: LD_VAR 0 2
67868: ARRAY
67869: PUSH
67870: LD_VAR 0 7
67874: AND
67875: IFFALSE 68181
// begin if mc_crates_collector [ i ] < target [ 1 ] then
67877: LD_EXP 76
67881: PUSH
67882: LD_VAR 0 2
67886: ARRAY
67887: PUSH
67888: LD_VAR 0 7
67892: PUSH
67893: LD_INT 1
67895: ARRAY
67896: LESS
67897: IFFALSE 67917
// tmp := mc_crates_collector [ i ] else
67899: LD_ADDR_VAR 0 5
67903: PUSH
67904: LD_EXP 76
67908: PUSH
67909: LD_VAR 0 2
67913: ARRAY
67914: ST_TO_ADDR
67915: GO 67931
// tmp := target [ 1 ] ;
67917: LD_ADDR_VAR 0 5
67921: PUSH
67922: LD_VAR 0 7
67926: PUSH
67927: LD_INT 1
67929: ARRAY
67930: ST_TO_ADDR
// k := 0 ;
67931: LD_ADDR_VAR 0 4
67935: PUSH
67936: LD_INT 0
67938: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
67939: LD_ADDR_VAR 0 3
67943: PUSH
67944: LD_EXP 76
67948: PUSH
67949: LD_VAR 0 2
67953: ARRAY
67954: PUSH
67955: FOR_IN
67956: IFFALSE 68179
// begin k := k + 1 ;
67958: LD_ADDR_VAR 0 4
67962: PUSH
67963: LD_VAR 0 4
67967: PUSH
67968: LD_INT 1
67970: PLUS
67971: ST_TO_ADDR
// if k > tmp then
67972: LD_VAR 0 4
67976: PUSH
67977: LD_VAR 0 5
67981: GREATER
67982: IFFALSE 67986
// break ;
67984: GO 68179
// if not GetClass ( j ) in [ 2 , 16 ] then
67986: LD_VAR 0 3
67990: PPUSH
67991: CALL_OW 257
67995: PUSH
67996: LD_INT 2
67998: PUSH
67999: LD_INT 16
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: IN
68006: NOT
68007: IFFALSE 68060
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
68009: LD_ADDR_EXP 76
68013: PUSH
68014: LD_EXP 76
68018: PPUSH
68019: LD_VAR 0 2
68023: PPUSH
68024: LD_EXP 76
68028: PUSH
68029: LD_VAR 0 2
68033: ARRAY
68034: PUSH
68035: LD_VAR 0 3
68039: DIFF
68040: PPUSH
68041: CALL_OW 1
68045: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68046: LD_VAR 0 3
68050: PPUSH
68051: LD_INT 0
68053: PPUSH
68054: CALL_OW 109
// continue ;
68058: GO 67955
// end ; if IsInUnit ( j ) then
68060: LD_VAR 0 3
68064: PPUSH
68065: CALL_OW 310
68069: IFFALSE 68080
// ComExitBuilding ( j ) ;
68071: LD_VAR 0 3
68075: PPUSH
68076: CALL_OW 122
// wait ( 3 ) ;
68080: LD_INT 3
68082: PPUSH
68083: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
68087: LD_VAR 0 3
68091: PPUSH
68092: CALL_OW 314
68096: PUSH
68097: LD_VAR 0 6
68101: PPUSH
68102: LD_VAR 0 7
68106: PUSH
68107: LD_INT 2
68109: ARRAY
68110: PPUSH
68111: LD_VAR 0 7
68115: PUSH
68116: LD_INT 3
68118: ARRAY
68119: PPUSH
68120: LD_INT 30
68122: PPUSH
68123: CALL 20622 0 4
68127: PUSH
68128: LD_INT 4
68130: ARRAY
68131: AND
68132: IFFALSE 68150
// ComStandNearbyBuilding ( j , depot ) else
68134: LD_VAR 0 3
68138: PPUSH
68139: LD_VAR 0 9
68143: PPUSH
68144: CALL 16304 0 2
68148: GO 68177
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68150: LD_VAR 0 3
68154: PPUSH
68155: LD_VAR 0 7
68159: PUSH
68160: LD_INT 2
68162: ARRAY
68163: PPUSH
68164: LD_VAR 0 7
68168: PUSH
68169: LD_INT 3
68171: ARRAY
68172: PPUSH
68173: CALL_OW 117
// end ;
68177: GO 67955
68179: POP
68180: POP
// end ; end else
68181: GO 68713
// begin for j in cargo do
68183: LD_ADDR_VAR 0 3
68187: PUSH
68188: LD_VAR 0 8
68192: PUSH
68193: FOR_IN
68194: IFFALSE 68711
// begin if GetTag ( j ) <> 0 then
68196: LD_VAR 0 3
68200: PPUSH
68201: CALL_OW 110
68205: PUSH
68206: LD_INT 0
68208: NONEQUAL
68209: IFFALSE 68213
// continue ;
68211: GO 68193
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
68213: LD_VAR 0 3
68217: PPUSH
68218: CALL_OW 256
68222: PUSH
68223: LD_INT 1000
68225: LESS
68226: PUSH
68227: LD_VAR 0 3
68231: PPUSH
68232: LD_EXP 83
68236: PUSH
68237: LD_VAR 0 2
68241: ARRAY
68242: PPUSH
68243: CALL_OW 308
68247: NOT
68248: AND
68249: IFFALSE 68271
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68251: LD_VAR 0 3
68255: PPUSH
68256: LD_EXP 83
68260: PUSH
68261: LD_VAR 0 2
68265: ARRAY
68266: PPUSH
68267: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
68271: LD_VAR 0 3
68275: PPUSH
68276: CALL_OW 256
68280: PUSH
68281: LD_INT 1000
68283: LESS
68284: PUSH
68285: LD_VAR 0 3
68289: PPUSH
68290: LD_EXP 83
68294: PUSH
68295: LD_VAR 0 2
68299: ARRAY
68300: PPUSH
68301: CALL_OW 308
68305: AND
68306: IFFALSE 68310
// continue ;
68308: GO 68193
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
68310: LD_VAR 0 3
68314: PPUSH
68315: CALL_OW 262
68319: PUSH
68320: LD_INT 2
68322: EQUAL
68323: PUSH
68324: LD_VAR 0 3
68328: PPUSH
68329: CALL_OW 261
68333: PUSH
68334: LD_INT 15
68336: LESS
68337: AND
68338: IFFALSE 68342
// continue ;
68340: GO 68193
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
68342: LD_VAR 0 3
68346: PPUSH
68347: CALL_OW 262
68351: PUSH
68352: LD_INT 1
68354: EQUAL
68355: PUSH
68356: LD_VAR 0 3
68360: PPUSH
68361: CALL_OW 261
68365: PUSH
68366: LD_INT 10
68368: LESS
68369: AND
68370: IFFALSE 68650
// begin if not depot then
68372: LD_VAR 0 9
68376: NOT
68377: IFFALSE 68381
// continue ;
68379: GO 68193
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
68381: LD_VAR 0 3
68385: PPUSH
68386: LD_VAR 0 9
68390: PPUSH
68391: LD_VAR 0 3
68395: PPUSH
68396: CALL_OW 74
68400: PPUSH
68401: CALL_OW 296
68405: PUSH
68406: LD_INT 6
68408: LESS
68409: IFFALSE 68425
// SetFuel ( j , 100 ) else
68411: LD_VAR 0 3
68415: PPUSH
68416: LD_INT 100
68418: PPUSH
68419: CALL_OW 240
68423: GO 68650
// if GetFuel ( j ) = 0 then
68425: LD_VAR 0 3
68429: PPUSH
68430: CALL_OW 261
68434: PUSH
68435: LD_INT 0
68437: EQUAL
68438: IFFALSE 68650
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
68440: LD_ADDR_EXP 78
68444: PUSH
68445: LD_EXP 78
68449: PPUSH
68450: LD_VAR 0 2
68454: PPUSH
68455: LD_EXP 78
68459: PUSH
68460: LD_VAR 0 2
68464: ARRAY
68465: PUSH
68466: LD_VAR 0 3
68470: DIFF
68471: PPUSH
68472: CALL_OW 1
68476: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
68477: LD_VAR 0 3
68481: PPUSH
68482: CALL_OW 263
68486: PUSH
68487: LD_INT 1
68489: EQUAL
68490: IFFALSE 68506
// ComExitVehicle ( IsInUnit ( j ) ) ;
68492: LD_VAR 0 3
68496: PPUSH
68497: CALL_OW 310
68501: PPUSH
68502: CALL_OW 121
// if GetControl ( j ) = control_remote then
68506: LD_VAR 0 3
68510: PPUSH
68511: CALL_OW 263
68515: PUSH
68516: LD_INT 2
68518: EQUAL
68519: IFFALSE 68530
// ComUnlink ( j ) ;
68521: LD_VAR 0 3
68525: PPUSH
68526: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
68530: LD_ADDR_VAR 0 10
68534: PUSH
68535: LD_VAR 0 2
68539: PPUSH
68540: LD_INT 3
68542: PPUSH
68543: CALL 78142 0 2
68547: ST_TO_ADDR
// if fac then
68548: LD_VAR 0 10
68552: IFFALSE 68648
// begin for k in fac do
68554: LD_ADDR_VAR 0 4
68558: PUSH
68559: LD_VAR 0 10
68563: PUSH
68564: FOR_IN
68565: IFFALSE 68646
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
68567: LD_ADDR_VAR 0 11
68571: PUSH
68572: LD_VAR 0 10
68576: PPUSH
68577: LD_VAR 0 3
68581: PPUSH
68582: CALL_OW 265
68586: PPUSH
68587: LD_VAR 0 3
68591: PPUSH
68592: CALL_OW 262
68596: PPUSH
68597: LD_VAR 0 3
68601: PPUSH
68602: CALL_OW 263
68606: PPUSH
68607: LD_VAR 0 3
68611: PPUSH
68612: CALL_OW 264
68616: PPUSH
68617: CALL 17222 0 5
68621: ST_TO_ADDR
// if components then
68622: LD_VAR 0 11
68626: IFFALSE 68644
// begin MC_InsertProduceList ( i , components ) ;
68628: LD_VAR 0 2
68632: PPUSH
68633: LD_VAR 0 11
68637: PPUSH
68638: CALL 77687 0 2
// break ;
68642: GO 68646
// end ; end ;
68644: GO 68564
68646: POP
68647: POP
// end ; continue ;
68648: GO 68193
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
68650: LD_VAR 0 3
68654: PPUSH
68655: LD_INT 1
68657: PPUSH
68658: CALL_OW 289
68662: PUSH
68663: LD_INT 100
68665: LESS
68666: PUSH
68667: LD_VAR 0 3
68671: PPUSH
68672: CALL_OW 314
68676: NOT
68677: AND
68678: IFFALSE 68707
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68680: LD_VAR 0 3
68684: PPUSH
68685: LD_VAR 0 7
68689: PUSH
68690: LD_INT 2
68692: ARRAY
68693: PPUSH
68694: LD_VAR 0 7
68698: PUSH
68699: LD_INT 3
68701: ARRAY
68702: PPUSH
68703: CALL_OW 117
// break ;
68707: GO 68711
// end ;
68709: GO 68193
68711: POP
68712: POP
// end ; end ;
68713: GO 66909
68715: POP
68716: POP
// end ;
68717: LD_VAR 0 1
68721: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
68722: LD_INT 0
68724: PPUSH
68725: PPUSH
68726: PPUSH
68727: PPUSH
// if not mc_bases then
68728: LD_EXP 59
68732: NOT
68733: IFFALSE 68737
// exit ;
68735: GO 68898
// for i = 1 to mc_bases do
68737: LD_ADDR_VAR 0 2
68741: PUSH
68742: DOUBLE
68743: LD_INT 1
68745: DEC
68746: ST_TO_ADDR
68747: LD_EXP 59
68751: PUSH
68752: FOR_TO
68753: IFFALSE 68896
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
68755: LD_ADDR_VAR 0 4
68759: PUSH
68760: LD_EXP 78
68764: PUSH
68765: LD_VAR 0 2
68769: ARRAY
68770: PUSH
68771: LD_EXP 81
68775: PUSH
68776: LD_VAR 0 2
68780: ARRAY
68781: UNION
68782: PPUSH
68783: LD_INT 33
68785: PUSH
68786: LD_INT 2
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PPUSH
68793: CALL_OW 72
68797: ST_TO_ADDR
// if tmp then
68798: LD_VAR 0 4
68802: IFFALSE 68894
// for j in tmp do
68804: LD_ADDR_VAR 0 3
68808: PUSH
68809: LD_VAR 0 4
68813: PUSH
68814: FOR_IN
68815: IFFALSE 68892
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
68817: LD_VAR 0 3
68821: PPUSH
68822: CALL_OW 312
68826: NOT
68827: PUSH
68828: LD_VAR 0 3
68832: PPUSH
68833: CALL_OW 256
68837: PUSH
68838: LD_INT 250
68840: GREATEREQUAL
68841: AND
68842: IFFALSE 68855
// Connect ( j ) else
68844: LD_VAR 0 3
68848: PPUSH
68849: CALL 22697 0 1
68853: GO 68890
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
68855: LD_VAR 0 3
68859: PPUSH
68860: CALL_OW 256
68864: PUSH
68865: LD_INT 250
68867: LESS
68868: PUSH
68869: LD_VAR 0 3
68873: PPUSH
68874: CALL_OW 312
68878: AND
68879: IFFALSE 68890
// ComUnlink ( j ) ;
68881: LD_VAR 0 3
68885: PPUSH
68886: CALL_OW 136
68890: GO 68814
68892: POP
68893: POP
// end ;
68894: GO 68752
68896: POP
68897: POP
// end ;
68898: LD_VAR 0 1
68902: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
68903: LD_INT 0
68905: PPUSH
68906: PPUSH
68907: PPUSH
68908: PPUSH
68909: PPUSH
// if not mc_bases then
68910: LD_EXP 59
68914: NOT
68915: IFFALSE 68919
// exit ;
68917: GO 69364
// for i = 1 to mc_bases do
68919: LD_ADDR_VAR 0 2
68923: PUSH
68924: DOUBLE
68925: LD_INT 1
68927: DEC
68928: ST_TO_ADDR
68929: LD_EXP 59
68933: PUSH
68934: FOR_TO
68935: IFFALSE 69362
// begin if not mc_produce [ i ] then
68937: LD_EXP 80
68941: PUSH
68942: LD_VAR 0 2
68946: ARRAY
68947: NOT
68948: IFFALSE 68952
// continue ;
68950: GO 68934
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68952: LD_ADDR_VAR 0 5
68956: PUSH
68957: LD_EXP 59
68961: PUSH
68962: LD_VAR 0 2
68966: ARRAY
68967: PPUSH
68968: LD_INT 30
68970: PUSH
68971: LD_INT 3
68973: PUSH
68974: EMPTY
68975: LIST
68976: LIST
68977: PPUSH
68978: CALL_OW 72
68982: ST_TO_ADDR
// if not fac then
68983: LD_VAR 0 5
68987: NOT
68988: IFFALSE 68992
// continue ;
68990: GO 68934
// for j in fac do
68992: LD_ADDR_VAR 0 3
68996: PUSH
68997: LD_VAR 0 5
69001: PUSH
69002: FOR_IN
69003: IFFALSE 69358
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
69005: LD_VAR 0 3
69009: PPUSH
69010: CALL_OW 461
69014: PUSH
69015: LD_INT 2
69017: NONEQUAL
69018: PUSH
69019: LD_VAR 0 3
69023: PPUSH
69024: LD_INT 15
69026: PPUSH
69027: CALL 22325 0 2
69031: PUSH
69032: LD_INT 4
69034: ARRAY
69035: OR
69036: IFFALSE 69040
// continue ;
69038: GO 69002
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
69040: LD_VAR 0 3
69044: PPUSH
69045: LD_EXP 80
69049: PUSH
69050: LD_VAR 0 2
69054: ARRAY
69055: PUSH
69056: LD_INT 1
69058: ARRAY
69059: PUSH
69060: LD_INT 1
69062: ARRAY
69063: PPUSH
69064: LD_EXP 80
69068: PUSH
69069: LD_VAR 0 2
69073: ARRAY
69074: PUSH
69075: LD_INT 1
69077: ARRAY
69078: PUSH
69079: LD_INT 2
69081: ARRAY
69082: PPUSH
69083: LD_EXP 80
69087: PUSH
69088: LD_VAR 0 2
69092: ARRAY
69093: PUSH
69094: LD_INT 1
69096: ARRAY
69097: PUSH
69098: LD_INT 3
69100: ARRAY
69101: PPUSH
69102: LD_EXP 80
69106: PUSH
69107: LD_VAR 0 2
69111: ARRAY
69112: PUSH
69113: LD_INT 1
69115: ARRAY
69116: PUSH
69117: LD_INT 4
69119: ARRAY
69120: PPUSH
69121: CALL_OW 448
69125: PUSH
69126: LD_VAR 0 3
69130: PPUSH
69131: LD_EXP 80
69135: PUSH
69136: LD_VAR 0 2
69140: ARRAY
69141: PUSH
69142: LD_INT 1
69144: ARRAY
69145: PUSH
69146: LD_INT 1
69148: ARRAY
69149: PUSH
69150: LD_EXP 80
69154: PUSH
69155: LD_VAR 0 2
69159: ARRAY
69160: PUSH
69161: LD_INT 1
69163: ARRAY
69164: PUSH
69165: LD_INT 2
69167: ARRAY
69168: PUSH
69169: LD_EXP 80
69173: PUSH
69174: LD_VAR 0 2
69178: ARRAY
69179: PUSH
69180: LD_INT 1
69182: ARRAY
69183: PUSH
69184: LD_INT 3
69186: ARRAY
69187: PUSH
69188: LD_EXP 80
69192: PUSH
69193: LD_VAR 0 2
69197: ARRAY
69198: PUSH
69199: LD_INT 1
69201: ARRAY
69202: PUSH
69203: LD_INT 4
69205: ARRAY
69206: PUSH
69207: EMPTY
69208: LIST
69209: LIST
69210: LIST
69211: LIST
69212: PPUSH
69213: CALL 26092 0 2
69217: AND
69218: IFFALSE 69356
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
69220: LD_VAR 0 3
69224: PPUSH
69225: LD_EXP 80
69229: PUSH
69230: LD_VAR 0 2
69234: ARRAY
69235: PUSH
69236: LD_INT 1
69238: ARRAY
69239: PUSH
69240: LD_INT 1
69242: ARRAY
69243: PPUSH
69244: LD_EXP 80
69248: PUSH
69249: LD_VAR 0 2
69253: ARRAY
69254: PUSH
69255: LD_INT 1
69257: ARRAY
69258: PUSH
69259: LD_INT 2
69261: ARRAY
69262: PPUSH
69263: LD_EXP 80
69267: PUSH
69268: LD_VAR 0 2
69272: ARRAY
69273: PUSH
69274: LD_INT 1
69276: ARRAY
69277: PUSH
69278: LD_INT 3
69280: ARRAY
69281: PPUSH
69282: LD_EXP 80
69286: PUSH
69287: LD_VAR 0 2
69291: ARRAY
69292: PUSH
69293: LD_INT 1
69295: ARRAY
69296: PUSH
69297: LD_INT 4
69299: ARRAY
69300: PPUSH
69301: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
69305: LD_ADDR_VAR 0 4
69309: PUSH
69310: LD_EXP 80
69314: PUSH
69315: LD_VAR 0 2
69319: ARRAY
69320: PPUSH
69321: LD_INT 1
69323: PPUSH
69324: CALL_OW 3
69328: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
69329: LD_ADDR_EXP 80
69333: PUSH
69334: LD_EXP 80
69338: PPUSH
69339: LD_VAR 0 2
69343: PPUSH
69344: LD_VAR 0 4
69348: PPUSH
69349: CALL_OW 1
69353: ST_TO_ADDR
// break ;
69354: GO 69358
// end ; end ;
69356: GO 69002
69358: POP
69359: POP
// end ;
69360: GO 68934
69362: POP
69363: POP
// end ;
69364: LD_VAR 0 1
69368: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
69369: LD_INT 0
69371: PPUSH
69372: PPUSH
69373: PPUSH
// if not mc_bases then
69374: LD_EXP 59
69378: NOT
69379: IFFALSE 69383
// exit ;
69381: GO 69472
// for i = 1 to mc_bases do
69383: LD_ADDR_VAR 0 2
69387: PUSH
69388: DOUBLE
69389: LD_INT 1
69391: DEC
69392: ST_TO_ADDR
69393: LD_EXP 59
69397: PUSH
69398: FOR_TO
69399: IFFALSE 69470
// begin if mc_attack [ i ] then
69401: LD_EXP 79
69405: PUSH
69406: LD_VAR 0 2
69410: ARRAY
69411: IFFALSE 69468
// begin tmp := mc_attack [ i ] [ 1 ] ;
69413: LD_ADDR_VAR 0 3
69417: PUSH
69418: LD_EXP 79
69422: PUSH
69423: LD_VAR 0 2
69427: ARRAY
69428: PUSH
69429: LD_INT 1
69431: ARRAY
69432: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
69433: LD_ADDR_EXP 79
69437: PUSH
69438: LD_EXP 79
69442: PPUSH
69443: LD_VAR 0 2
69447: PPUSH
69448: EMPTY
69449: PPUSH
69450: CALL_OW 1
69454: ST_TO_ADDR
// Attack ( tmp ) ;
69455: LD_VAR 0 3
69459: PPUSH
69460: CALL 101448 0 1
// exit ;
69464: POP
69465: POP
69466: GO 69472
// end ; end ;
69468: GO 69398
69470: POP
69471: POP
// end ;
69472: LD_VAR 0 1
69476: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
69477: LD_INT 0
69479: PPUSH
69480: PPUSH
69481: PPUSH
69482: PPUSH
69483: PPUSH
69484: PPUSH
69485: PPUSH
// if not mc_bases then
69486: LD_EXP 59
69490: NOT
69491: IFFALSE 69495
// exit ;
69493: GO 70205
// for i = 1 to mc_bases do
69495: LD_ADDR_VAR 0 2
69499: PUSH
69500: DOUBLE
69501: LD_INT 1
69503: DEC
69504: ST_TO_ADDR
69505: LD_EXP 59
69509: PUSH
69510: FOR_TO
69511: IFFALSE 70203
// begin if not mc_bases [ i ] then
69513: LD_EXP 59
69517: PUSH
69518: LD_VAR 0 2
69522: ARRAY
69523: NOT
69524: IFFALSE 69528
// continue ;
69526: GO 69510
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
69528: LD_ADDR_VAR 0 7
69532: PUSH
69533: LD_EXP 59
69537: PUSH
69538: LD_VAR 0 2
69542: ARRAY
69543: PUSH
69544: LD_INT 1
69546: ARRAY
69547: PPUSH
69548: CALL 16526 0 1
69552: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
69553: LD_ADDR_EXP 82
69557: PUSH
69558: LD_EXP 82
69562: PPUSH
69563: LD_VAR 0 2
69567: PPUSH
69568: LD_EXP 59
69572: PUSH
69573: LD_VAR 0 2
69577: ARRAY
69578: PUSH
69579: LD_INT 1
69581: ARRAY
69582: PPUSH
69583: CALL_OW 255
69587: PPUSH
69588: LD_EXP 84
69592: PUSH
69593: LD_VAR 0 2
69597: ARRAY
69598: PPUSH
69599: CALL 16491 0 2
69603: PPUSH
69604: CALL_OW 1
69608: ST_TO_ADDR
// if not mc_scan [ i ] then
69609: LD_EXP 82
69613: PUSH
69614: LD_VAR 0 2
69618: ARRAY
69619: NOT
69620: IFFALSE 69798
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
69622: LD_ADDR_EXP 102
69626: PUSH
69627: LD_EXP 102
69631: PPUSH
69632: LD_VAR 0 2
69636: PPUSH
69637: LD_INT 0
69639: PPUSH
69640: CALL_OW 1
69644: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69645: LD_ADDR_VAR 0 4
69649: PUSH
69650: LD_EXP 59
69654: PUSH
69655: LD_VAR 0 2
69659: ARRAY
69660: PPUSH
69661: LD_INT 2
69663: PUSH
69664: LD_INT 25
69666: PUSH
69667: LD_INT 5
69669: PUSH
69670: EMPTY
69671: LIST
69672: LIST
69673: PUSH
69674: LD_INT 25
69676: PUSH
69677: LD_INT 8
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: PUSH
69684: LD_INT 25
69686: PUSH
69687: LD_INT 9
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: LIST
69698: LIST
69699: PPUSH
69700: CALL_OW 72
69704: ST_TO_ADDR
// if not tmp then
69705: LD_VAR 0 4
69709: NOT
69710: IFFALSE 69714
// continue ;
69712: GO 69510
// for j in tmp do
69714: LD_ADDR_VAR 0 3
69718: PUSH
69719: LD_VAR 0 4
69723: PUSH
69724: FOR_IN
69725: IFFALSE 69796
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
69727: LD_VAR 0 3
69731: PPUSH
69732: CALL_OW 310
69736: PPUSH
69737: CALL_OW 266
69741: PUSH
69742: LD_INT 5
69744: EQUAL
69745: PUSH
69746: LD_VAR 0 3
69750: PPUSH
69751: CALL_OW 257
69755: PUSH
69756: LD_INT 1
69758: EQUAL
69759: AND
69760: PUSH
69761: LD_VAR 0 3
69765: PPUSH
69766: CALL_OW 459
69770: NOT
69771: AND
69772: PUSH
69773: LD_VAR 0 7
69777: AND
69778: IFFALSE 69794
// ComChangeProfession ( j , class ) ;
69780: LD_VAR 0 3
69784: PPUSH
69785: LD_VAR 0 7
69789: PPUSH
69790: CALL_OW 123
69794: GO 69724
69796: POP
69797: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] then
69798: LD_EXP 82
69802: PUSH
69803: LD_VAR 0 2
69807: ARRAY
69808: PUSH
69809: LD_EXP 102
69813: PUSH
69814: LD_VAR 0 2
69818: ARRAY
69819: NOT
69820: AND
69821: PUSH
69822: LD_EXP 81
69826: PUSH
69827: LD_VAR 0 2
69831: ARRAY
69832: NOT
69833: AND
69834: IFFALSE 70085
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
69836: LD_ADDR_EXP 102
69840: PUSH
69841: LD_EXP 102
69845: PPUSH
69846: LD_VAR 0 2
69850: PPUSH
69851: LD_INT 1
69853: PPUSH
69854: CALL_OW 1
69858: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69859: LD_ADDR_VAR 0 4
69863: PUSH
69864: LD_EXP 59
69868: PUSH
69869: LD_VAR 0 2
69873: ARRAY
69874: PPUSH
69875: LD_INT 2
69877: PUSH
69878: LD_INT 25
69880: PUSH
69881: LD_INT 1
69883: PUSH
69884: EMPTY
69885: LIST
69886: LIST
69887: PUSH
69888: LD_INT 25
69890: PUSH
69891: LD_INT 5
69893: PUSH
69894: EMPTY
69895: LIST
69896: LIST
69897: PUSH
69898: LD_INT 25
69900: PUSH
69901: LD_INT 8
69903: PUSH
69904: EMPTY
69905: LIST
69906: LIST
69907: PUSH
69908: LD_INT 25
69910: PUSH
69911: LD_INT 9
69913: PUSH
69914: EMPTY
69915: LIST
69916: LIST
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: LIST
69922: LIST
69923: LIST
69924: PPUSH
69925: CALL_OW 72
69929: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
69930: LD_ADDR_VAR 0 4
69934: PUSH
69935: LD_VAR 0 4
69939: PUSH
69940: LD_VAR 0 4
69944: PPUSH
69945: LD_INT 18
69947: PPUSH
69948: CALL 48995 0 2
69952: DIFF
69953: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
69954: LD_VAR 0 4
69958: NOT
69959: PUSH
69960: LD_EXP 59
69964: PUSH
69965: LD_VAR 0 2
69969: ARRAY
69970: PPUSH
69971: LD_INT 2
69973: PUSH
69974: LD_INT 30
69976: PUSH
69977: LD_INT 4
69979: PUSH
69980: EMPTY
69981: LIST
69982: LIST
69983: PUSH
69984: LD_INT 30
69986: PUSH
69987: LD_INT 5
69989: PUSH
69990: EMPTY
69991: LIST
69992: LIST
69993: PUSH
69994: EMPTY
69995: LIST
69996: LIST
69997: LIST
69998: PPUSH
69999: CALL_OW 72
70003: NOT
70004: AND
70005: IFFALSE 70067
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
70007: LD_ADDR_VAR 0 4
70011: PUSH
70012: LD_EXP 59
70016: PUSH
70017: LD_VAR 0 2
70021: ARRAY
70022: PPUSH
70023: LD_INT 2
70025: PUSH
70026: LD_INT 25
70028: PUSH
70029: LD_INT 2
70031: PUSH
70032: EMPTY
70033: LIST
70034: LIST
70035: PUSH
70036: LD_INT 25
70038: PUSH
70039: LD_INT 3
70041: PUSH
70042: EMPTY
70043: LIST
70044: LIST
70045: PUSH
70046: LD_INT 25
70048: PUSH
70049: LD_INT 4
70051: PUSH
70052: EMPTY
70053: LIST
70054: LIST
70055: PUSH
70056: EMPTY
70057: LIST
70058: LIST
70059: LIST
70060: LIST
70061: PPUSH
70062: CALL_OW 72
70066: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
70067: LD_VAR 0 2
70071: PPUSH
70072: LD_VAR 0 4
70076: PPUSH
70077: CALL 106157 0 2
// exit ;
70081: POP
70082: POP
70083: GO 70205
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
70085: LD_EXP 82
70089: PUSH
70090: LD_VAR 0 2
70094: ARRAY
70095: PUSH
70096: LD_EXP 102
70100: PUSH
70101: LD_VAR 0 2
70105: ARRAY
70106: NOT
70107: AND
70108: PUSH
70109: LD_EXP 81
70113: PUSH
70114: LD_VAR 0 2
70118: ARRAY
70119: AND
70120: IFFALSE 70201
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
70122: LD_ADDR_EXP 102
70126: PUSH
70127: LD_EXP 102
70131: PPUSH
70132: LD_VAR 0 2
70136: PPUSH
70137: LD_INT 1
70139: PPUSH
70140: CALL_OW 1
70144: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
70145: LD_ADDR_VAR 0 4
70149: PUSH
70150: LD_EXP 81
70154: PUSH
70155: LD_VAR 0 2
70159: ARRAY
70160: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
70161: LD_ADDR_EXP 81
70165: PUSH
70166: LD_EXP 81
70170: PPUSH
70171: LD_VAR 0 2
70175: PPUSH
70176: EMPTY
70177: PPUSH
70178: CALL_OW 1
70182: ST_TO_ADDR
// Defend ( i , tmp ) ;
70183: LD_VAR 0 2
70187: PPUSH
70188: LD_VAR 0 4
70192: PPUSH
70193: CALL 106727 0 2
// exit ;
70197: POP
70198: POP
70199: GO 70205
// end ; end ;
70201: GO 69510
70203: POP
70204: POP
// end ;
70205: LD_VAR 0 1
70209: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
70210: LD_INT 0
70212: PPUSH
70213: PPUSH
70214: PPUSH
70215: PPUSH
70216: PPUSH
70217: PPUSH
70218: PPUSH
70219: PPUSH
70220: PPUSH
70221: PPUSH
70222: PPUSH
// if not mc_bases then
70223: LD_EXP 59
70227: NOT
70228: IFFALSE 70232
// exit ;
70230: GO 71319
// for i = 1 to mc_bases do
70232: LD_ADDR_VAR 0 2
70236: PUSH
70237: DOUBLE
70238: LD_INT 1
70240: DEC
70241: ST_TO_ADDR
70242: LD_EXP 59
70246: PUSH
70247: FOR_TO
70248: IFFALSE 71317
// begin tmp := mc_lab [ i ] ;
70250: LD_ADDR_VAR 0 6
70254: PUSH
70255: LD_EXP 92
70259: PUSH
70260: LD_VAR 0 2
70264: ARRAY
70265: ST_TO_ADDR
// if not tmp then
70266: LD_VAR 0 6
70270: NOT
70271: IFFALSE 70275
// continue ;
70273: GO 70247
// idle_lab := 0 ;
70275: LD_ADDR_VAR 0 11
70279: PUSH
70280: LD_INT 0
70282: ST_TO_ADDR
// for j in tmp do
70283: LD_ADDR_VAR 0 3
70287: PUSH
70288: LD_VAR 0 6
70292: PUSH
70293: FOR_IN
70294: IFFALSE 71313
// begin researching := false ;
70296: LD_ADDR_VAR 0 10
70300: PUSH
70301: LD_INT 0
70303: ST_TO_ADDR
// side := GetSide ( j ) ;
70304: LD_ADDR_VAR 0 4
70308: PUSH
70309: LD_VAR 0 3
70313: PPUSH
70314: CALL_OW 255
70318: ST_TO_ADDR
// if not mc_tech [ side ] then
70319: LD_EXP 86
70323: PUSH
70324: LD_VAR 0 4
70328: ARRAY
70329: NOT
70330: IFFALSE 70334
// continue ;
70332: GO 70293
// if BuildingStatus ( j ) = bs_idle then
70334: LD_VAR 0 3
70338: PPUSH
70339: CALL_OW 461
70343: PUSH
70344: LD_INT 2
70346: EQUAL
70347: IFFALSE 70535
// begin if idle_lab and UnitsInside ( j ) < 6 then
70349: LD_VAR 0 11
70353: PUSH
70354: LD_VAR 0 3
70358: PPUSH
70359: CALL_OW 313
70363: PUSH
70364: LD_INT 6
70366: LESS
70367: AND
70368: IFFALSE 70439
// begin tmp2 := UnitsInside ( idle_lab ) ;
70370: LD_ADDR_VAR 0 9
70374: PUSH
70375: LD_VAR 0 11
70379: PPUSH
70380: CALL_OW 313
70384: ST_TO_ADDR
// if tmp2 then
70385: LD_VAR 0 9
70389: IFFALSE 70431
// for x in tmp2 do
70391: LD_ADDR_VAR 0 7
70395: PUSH
70396: LD_VAR 0 9
70400: PUSH
70401: FOR_IN
70402: IFFALSE 70429
// begin ComExitBuilding ( x ) ;
70404: LD_VAR 0 7
70408: PPUSH
70409: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70413: LD_VAR 0 7
70417: PPUSH
70418: LD_VAR 0 3
70422: PPUSH
70423: CALL_OW 180
// end ;
70427: GO 70401
70429: POP
70430: POP
// idle_lab := 0 ;
70431: LD_ADDR_VAR 0 11
70435: PUSH
70436: LD_INT 0
70438: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
70439: LD_ADDR_VAR 0 5
70443: PUSH
70444: LD_EXP 86
70448: PUSH
70449: LD_VAR 0 4
70453: ARRAY
70454: PUSH
70455: FOR_IN
70456: IFFALSE 70516
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
70458: LD_VAR 0 3
70462: PPUSH
70463: LD_VAR 0 5
70467: PPUSH
70468: CALL_OW 430
70472: PUSH
70473: LD_VAR 0 4
70477: PPUSH
70478: LD_VAR 0 5
70482: PPUSH
70483: CALL 15596 0 2
70487: AND
70488: IFFALSE 70514
// begin researching := true ;
70490: LD_ADDR_VAR 0 10
70494: PUSH
70495: LD_INT 1
70497: ST_TO_ADDR
// ComResearch ( j , t ) ;
70498: LD_VAR 0 3
70502: PPUSH
70503: LD_VAR 0 5
70507: PPUSH
70508: CALL_OW 124
// break ;
70512: GO 70516
// end ;
70514: GO 70455
70516: POP
70517: POP
// if not researching then
70518: LD_VAR 0 10
70522: NOT
70523: IFFALSE 70535
// idle_lab := j ;
70525: LD_ADDR_VAR 0 11
70529: PUSH
70530: LD_VAR 0 3
70534: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
70535: LD_VAR 0 3
70539: PPUSH
70540: CALL_OW 461
70544: PUSH
70545: LD_INT 10
70547: EQUAL
70548: IFFALSE 71136
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
70550: LD_EXP 88
70554: PUSH
70555: LD_VAR 0 2
70559: ARRAY
70560: NOT
70561: PUSH
70562: LD_EXP 89
70566: PUSH
70567: LD_VAR 0 2
70571: ARRAY
70572: NOT
70573: AND
70574: PUSH
70575: LD_EXP 86
70579: PUSH
70580: LD_VAR 0 4
70584: ARRAY
70585: PUSH
70586: LD_INT 1
70588: GREATER
70589: AND
70590: IFFALSE 70721
// begin ComCancel ( j ) ;
70592: LD_VAR 0 3
70596: PPUSH
70597: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
70601: LD_ADDR_EXP 86
70605: PUSH
70606: LD_EXP 86
70610: PPUSH
70611: LD_VAR 0 4
70615: PPUSH
70616: LD_EXP 86
70620: PUSH
70621: LD_VAR 0 4
70625: ARRAY
70626: PPUSH
70627: LD_EXP 86
70631: PUSH
70632: LD_VAR 0 4
70636: ARRAY
70637: PUSH
70638: LD_INT 1
70640: MINUS
70641: PPUSH
70642: LD_EXP 86
70646: PUSH
70647: LD_VAR 0 4
70651: ARRAY
70652: PPUSH
70653: LD_INT 0
70655: PPUSH
70656: CALL 19144 0 4
70660: PPUSH
70661: CALL_OW 1
70665: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
70666: LD_ADDR_EXP 86
70670: PUSH
70671: LD_EXP 86
70675: PPUSH
70676: LD_VAR 0 4
70680: PPUSH
70681: LD_EXP 86
70685: PUSH
70686: LD_VAR 0 4
70690: ARRAY
70691: PPUSH
70692: LD_EXP 86
70696: PUSH
70697: LD_VAR 0 4
70701: ARRAY
70702: PPUSH
70703: LD_INT 1
70705: PPUSH
70706: LD_INT 0
70708: PPUSH
70709: CALL 19144 0 4
70713: PPUSH
70714: CALL_OW 1
70718: ST_TO_ADDR
// continue ;
70719: GO 70293
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
70721: LD_EXP 88
70725: PUSH
70726: LD_VAR 0 2
70730: ARRAY
70731: PUSH
70732: LD_EXP 89
70736: PUSH
70737: LD_VAR 0 2
70741: ARRAY
70742: NOT
70743: AND
70744: IFFALSE 70871
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
70746: LD_ADDR_EXP 89
70750: PUSH
70751: LD_EXP 89
70755: PPUSH
70756: LD_VAR 0 2
70760: PUSH
70761: LD_EXP 89
70765: PUSH
70766: LD_VAR 0 2
70770: ARRAY
70771: PUSH
70772: LD_INT 1
70774: PLUS
70775: PUSH
70776: EMPTY
70777: LIST
70778: LIST
70779: PPUSH
70780: LD_EXP 88
70784: PUSH
70785: LD_VAR 0 2
70789: ARRAY
70790: PUSH
70791: LD_INT 1
70793: ARRAY
70794: PPUSH
70795: CALL 19726 0 3
70799: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
70800: LD_EXP 88
70804: PUSH
70805: LD_VAR 0 2
70809: ARRAY
70810: PUSH
70811: LD_INT 1
70813: ARRAY
70814: PPUSH
70815: LD_INT 112
70817: PPUSH
70818: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
70822: LD_ADDR_VAR 0 9
70826: PUSH
70827: LD_EXP 88
70831: PUSH
70832: LD_VAR 0 2
70836: ARRAY
70837: PPUSH
70838: LD_INT 1
70840: PPUSH
70841: CALL_OW 3
70845: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
70846: LD_ADDR_EXP 88
70850: PUSH
70851: LD_EXP 88
70855: PPUSH
70856: LD_VAR 0 2
70860: PPUSH
70861: LD_VAR 0 9
70865: PPUSH
70866: CALL_OW 1
70870: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
70871: LD_EXP 88
70875: PUSH
70876: LD_VAR 0 2
70880: ARRAY
70881: PUSH
70882: LD_EXP 89
70886: PUSH
70887: LD_VAR 0 2
70891: ARRAY
70892: AND
70893: PUSH
70894: LD_EXP 89
70898: PUSH
70899: LD_VAR 0 2
70903: ARRAY
70904: PUSH
70905: LD_INT 1
70907: ARRAY
70908: PPUSH
70909: CALL_OW 310
70913: NOT
70914: AND
70915: PUSH
70916: LD_VAR 0 3
70920: PPUSH
70921: CALL_OW 313
70925: PUSH
70926: LD_INT 6
70928: EQUAL
70929: AND
70930: IFFALSE 70986
// begin tmp2 := UnitsInside ( j ) ;
70932: LD_ADDR_VAR 0 9
70936: PUSH
70937: LD_VAR 0 3
70941: PPUSH
70942: CALL_OW 313
70946: ST_TO_ADDR
// if tmp2 = 6 then
70947: LD_VAR 0 9
70951: PUSH
70952: LD_INT 6
70954: EQUAL
70955: IFFALSE 70986
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
70957: LD_VAR 0 9
70961: PUSH
70962: LD_INT 1
70964: ARRAY
70965: PPUSH
70966: LD_INT 112
70968: PPUSH
70969: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
70973: LD_VAR 0 9
70977: PUSH
70978: LD_INT 1
70980: ARRAY
70981: PPUSH
70982: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
70986: LD_EXP 89
70990: PUSH
70991: LD_VAR 0 2
70995: ARRAY
70996: PUSH
70997: LD_EXP 89
71001: PUSH
71002: LD_VAR 0 2
71006: ARRAY
71007: PUSH
71008: LD_INT 1
71010: ARRAY
71011: PPUSH
71012: CALL_OW 314
71016: NOT
71017: AND
71018: PUSH
71019: LD_EXP 89
71023: PUSH
71024: LD_VAR 0 2
71028: ARRAY
71029: PUSH
71030: LD_INT 1
71032: ARRAY
71033: PPUSH
71034: CALL_OW 310
71038: NOT
71039: AND
71040: IFFALSE 71066
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
71042: LD_EXP 89
71046: PUSH
71047: LD_VAR 0 2
71051: ARRAY
71052: PUSH
71053: LD_INT 1
71055: ARRAY
71056: PPUSH
71057: LD_VAR 0 3
71061: PPUSH
71062: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
71066: LD_EXP 89
71070: PUSH
71071: LD_VAR 0 2
71075: ARRAY
71076: PUSH
71077: LD_INT 1
71079: ARRAY
71080: PPUSH
71081: CALL_OW 310
71085: PUSH
71086: LD_EXP 89
71090: PUSH
71091: LD_VAR 0 2
71095: ARRAY
71096: PUSH
71097: LD_INT 1
71099: ARRAY
71100: PPUSH
71101: CALL_OW 310
71105: PPUSH
71106: CALL_OW 461
71110: PUSH
71111: LD_INT 3
71113: NONEQUAL
71114: AND
71115: IFFALSE 71136
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
71117: LD_EXP 89
71121: PUSH
71122: LD_VAR 0 2
71126: ARRAY
71127: PUSH
71128: LD_INT 1
71130: ARRAY
71131: PPUSH
71132: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
71136: LD_VAR 0 3
71140: PPUSH
71141: CALL_OW 461
71145: PUSH
71146: LD_INT 6
71148: EQUAL
71149: PUSH
71150: LD_VAR 0 6
71154: PUSH
71155: LD_INT 1
71157: GREATER
71158: AND
71159: IFFALSE 71311
// begin sci := [ ] ;
71161: LD_ADDR_VAR 0 8
71165: PUSH
71166: EMPTY
71167: ST_TO_ADDR
// for x in ( tmp diff j ) do
71168: LD_ADDR_VAR 0 7
71172: PUSH
71173: LD_VAR 0 6
71177: PUSH
71178: LD_VAR 0 3
71182: DIFF
71183: PUSH
71184: FOR_IN
71185: IFFALSE 71237
// begin if sci = 6 then
71187: LD_VAR 0 8
71191: PUSH
71192: LD_INT 6
71194: EQUAL
71195: IFFALSE 71199
// break ;
71197: GO 71237
// if BuildingStatus ( x ) = bs_idle then
71199: LD_VAR 0 7
71203: PPUSH
71204: CALL_OW 461
71208: PUSH
71209: LD_INT 2
71211: EQUAL
71212: IFFALSE 71235
// sci := sci ^ UnitsInside ( x ) ;
71214: LD_ADDR_VAR 0 8
71218: PUSH
71219: LD_VAR 0 8
71223: PUSH
71224: LD_VAR 0 7
71228: PPUSH
71229: CALL_OW 313
71233: ADD
71234: ST_TO_ADDR
// end ;
71235: GO 71184
71237: POP
71238: POP
// if not sci then
71239: LD_VAR 0 8
71243: NOT
71244: IFFALSE 71248
// continue ;
71246: GO 70293
// for x in sci do
71248: LD_ADDR_VAR 0 7
71252: PUSH
71253: LD_VAR 0 8
71257: PUSH
71258: FOR_IN
71259: IFFALSE 71309
// if IsInUnit ( x ) and not HasTask ( x ) then
71261: LD_VAR 0 7
71265: PPUSH
71266: CALL_OW 310
71270: PUSH
71271: LD_VAR 0 7
71275: PPUSH
71276: CALL_OW 314
71280: NOT
71281: AND
71282: IFFALSE 71307
// begin ComExitBuilding ( x ) ;
71284: LD_VAR 0 7
71288: PPUSH
71289: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71293: LD_VAR 0 7
71297: PPUSH
71298: LD_VAR 0 3
71302: PPUSH
71303: CALL_OW 180
// end ;
71307: GO 71258
71309: POP
71310: POP
// end ; end ;
71311: GO 70293
71313: POP
71314: POP
// end ;
71315: GO 70247
71317: POP
71318: POP
// end ;
71319: LD_VAR 0 1
71323: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
71324: LD_INT 0
71326: PPUSH
71327: PPUSH
// if not mc_bases then
71328: LD_EXP 59
71332: NOT
71333: IFFALSE 71337
// exit ;
71335: GO 71418
// for i = 1 to mc_bases do
71337: LD_ADDR_VAR 0 2
71341: PUSH
71342: DOUBLE
71343: LD_INT 1
71345: DEC
71346: ST_TO_ADDR
71347: LD_EXP 59
71351: PUSH
71352: FOR_TO
71353: IFFALSE 71416
// if mc_mines [ i ] and mc_miners [ i ] then
71355: LD_EXP 72
71359: PUSH
71360: LD_VAR 0 2
71364: ARRAY
71365: PUSH
71366: LD_EXP 73
71370: PUSH
71371: LD_VAR 0 2
71375: ARRAY
71376: AND
71377: IFFALSE 71414
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
71379: LD_EXP 73
71383: PUSH
71384: LD_VAR 0 2
71388: ARRAY
71389: PUSH
71390: LD_INT 1
71392: ARRAY
71393: PPUSH
71394: CALL_OW 255
71398: PPUSH
71399: LD_EXP 72
71403: PUSH
71404: LD_VAR 0 2
71408: ARRAY
71409: PPUSH
71410: CALL 16679 0 2
71414: GO 71352
71416: POP
71417: POP
// end ;
71418: LD_VAR 0 1
71422: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
71423: LD_INT 0
71425: PPUSH
71426: PPUSH
71427: PPUSH
71428: PPUSH
71429: PPUSH
71430: PPUSH
71431: PPUSH
71432: PPUSH
// if not mc_bases or not mc_parking then
71433: LD_EXP 59
71437: NOT
71438: PUSH
71439: LD_EXP 83
71443: NOT
71444: OR
71445: IFFALSE 71449
// exit ;
71447: GO 72159
// for i = 1 to mc_bases do
71449: LD_ADDR_VAR 0 2
71453: PUSH
71454: DOUBLE
71455: LD_INT 1
71457: DEC
71458: ST_TO_ADDR
71459: LD_EXP 59
71463: PUSH
71464: FOR_TO
71465: IFFALSE 72157
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
71467: LD_EXP 59
71471: PUSH
71472: LD_VAR 0 2
71476: ARRAY
71477: NOT
71478: PUSH
71479: LD_EXP 83
71483: PUSH
71484: LD_VAR 0 2
71488: ARRAY
71489: NOT
71490: OR
71491: IFFALSE 71495
// continue ;
71493: GO 71464
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
71495: LD_ADDR_VAR 0 5
71499: PUSH
71500: LD_EXP 59
71504: PUSH
71505: LD_VAR 0 2
71509: ARRAY
71510: PUSH
71511: LD_INT 1
71513: ARRAY
71514: PPUSH
71515: CALL_OW 255
71519: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71520: LD_ADDR_VAR 0 6
71524: PUSH
71525: LD_EXP 59
71529: PUSH
71530: LD_VAR 0 2
71534: ARRAY
71535: PPUSH
71536: LD_INT 30
71538: PUSH
71539: LD_INT 3
71541: PUSH
71542: EMPTY
71543: LIST
71544: LIST
71545: PPUSH
71546: CALL_OW 72
71550: ST_TO_ADDR
// if not fac then
71551: LD_VAR 0 6
71555: NOT
71556: IFFALSE 71607
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71558: LD_ADDR_VAR 0 6
71562: PUSH
71563: LD_EXP 59
71567: PUSH
71568: LD_VAR 0 2
71572: ARRAY
71573: PPUSH
71574: LD_INT 2
71576: PUSH
71577: LD_INT 30
71579: PUSH
71580: LD_INT 0
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PUSH
71587: LD_INT 30
71589: PUSH
71590: LD_INT 1
71592: PUSH
71593: EMPTY
71594: LIST
71595: LIST
71596: PUSH
71597: EMPTY
71598: LIST
71599: LIST
71600: LIST
71601: PPUSH
71602: CALL_OW 72
71606: ST_TO_ADDR
// if not fac then
71607: LD_VAR 0 6
71611: NOT
71612: IFFALSE 71616
// continue ;
71614: GO 71464
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
71616: LD_ADDR_VAR 0 7
71620: PUSH
71621: LD_EXP 83
71625: PUSH
71626: LD_VAR 0 2
71630: ARRAY
71631: PPUSH
71632: LD_INT 22
71634: PUSH
71635: LD_VAR 0 5
71639: PUSH
71640: EMPTY
71641: LIST
71642: LIST
71643: PUSH
71644: LD_INT 21
71646: PUSH
71647: LD_INT 2
71649: PUSH
71650: EMPTY
71651: LIST
71652: LIST
71653: PUSH
71654: LD_INT 3
71656: PUSH
71657: LD_INT 24
71659: PUSH
71660: LD_INT 1000
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: PUSH
71667: EMPTY
71668: LIST
71669: LIST
71670: PUSH
71671: EMPTY
71672: LIST
71673: LIST
71674: LIST
71675: PPUSH
71676: CALL_OW 70
71680: ST_TO_ADDR
// for j in fac do
71681: LD_ADDR_VAR 0 3
71685: PUSH
71686: LD_VAR 0 6
71690: PUSH
71691: FOR_IN
71692: IFFALSE 71773
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
71694: LD_ADDR_VAR 0 7
71698: PUSH
71699: LD_VAR 0 7
71703: PUSH
71704: LD_INT 22
71706: PUSH
71707: LD_VAR 0 5
71711: PUSH
71712: EMPTY
71713: LIST
71714: LIST
71715: PUSH
71716: LD_INT 91
71718: PUSH
71719: LD_VAR 0 3
71723: PUSH
71724: LD_INT 15
71726: PUSH
71727: EMPTY
71728: LIST
71729: LIST
71730: LIST
71731: PUSH
71732: LD_INT 21
71734: PUSH
71735: LD_INT 2
71737: PUSH
71738: EMPTY
71739: LIST
71740: LIST
71741: PUSH
71742: LD_INT 3
71744: PUSH
71745: LD_INT 24
71747: PUSH
71748: LD_INT 1000
71750: PUSH
71751: EMPTY
71752: LIST
71753: LIST
71754: PUSH
71755: EMPTY
71756: LIST
71757: LIST
71758: PUSH
71759: EMPTY
71760: LIST
71761: LIST
71762: LIST
71763: LIST
71764: PPUSH
71765: CALL_OW 69
71769: UNION
71770: ST_TO_ADDR
71771: GO 71691
71773: POP
71774: POP
// if not vehs then
71775: LD_VAR 0 7
71779: NOT
71780: IFFALSE 71806
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
71782: LD_ADDR_EXP 71
71786: PUSH
71787: LD_EXP 71
71791: PPUSH
71792: LD_VAR 0 2
71796: PPUSH
71797: EMPTY
71798: PPUSH
71799: CALL_OW 1
71803: ST_TO_ADDR
// continue ;
71804: GO 71464
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71806: LD_ADDR_VAR 0 8
71810: PUSH
71811: LD_EXP 59
71815: PUSH
71816: LD_VAR 0 2
71820: ARRAY
71821: PPUSH
71822: LD_INT 30
71824: PUSH
71825: LD_INT 3
71827: PUSH
71828: EMPTY
71829: LIST
71830: LIST
71831: PPUSH
71832: CALL_OW 72
71836: ST_TO_ADDR
// if tmp then
71837: LD_VAR 0 8
71841: IFFALSE 71944
// begin for j in tmp do
71843: LD_ADDR_VAR 0 3
71847: PUSH
71848: LD_VAR 0 8
71852: PUSH
71853: FOR_IN
71854: IFFALSE 71942
// for k in UnitsInside ( j ) do
71856: LD_ADDR_VAR 0 4
71860: PUSH
71861: LD_VAR 0 3
71865: PPUSH
71866: CALL_OW 313
71870: PUSH
71871: FOR_IN
71872: IFFALSE 71938
// if k then
71874: LD_VAR 0 4
71878: IFFALSE 71936
// if not k in mc_repair_vehicle [ i ] then
71880: LD_VAR 0 4
71884: PUSH
71885: LD_EXP 71
71889: PUSH
71890: LD_VAR 0 2
71894: ARRAY
71895: IN
71896: NOT
71897: IFFALSE 71936
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
71899: LD_ADDR_EXP 71
71903: PUSH
71904: LD_EXP 71
71908: PPUSH
71909: LD_VAR 0 2
71913: PPUSH
71914: LD_EXP 71
71918: PUSH
71919: LD_VAR 0 2
71923: ARRAY
71924: PUSH
71925: LD_VAR 0 4
71929: UNION
71930: PPUSH
71931: CALL_OW 1
71935: ST_TO_ADDR
71936: GO 71871
71938: POP
71939: POP
71940: GO 71853
71942: POP
71943: POP
// end ; if not mc_repair_vehicle [ i ] then
71944: LD_EXP 71
71948: PUSH
71949: LD_VAR 0 2
71953: ARRAY
71954: NOT
71955: IFFALSE 71959
// continue ;
71957: GO 71464
// for j in mc_repair_vehicle [ i ] do
71959: LD_ADDR_VAR 0 3
71963: PUSH
71964: LD_EXP 71
71968: PUSH
71969: LD_VAR 0 2
71973: ARRAY
71974: PUSH
71975: FOR_IN
71976: IFFALSE 72153
// begin if GetClass ( j ) <> 3 then
71978: LD_VAR 0 3
71982: PPUSH
71983: CALL_OW 257
71987: PUSH
71988: LD_INT 3
71990: NONEQUAL
71991: IFFALSE 72032
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
71993: LD_ADDR_EXP 71
71997: PUSH
71998: LD_EXP 71
72002: PPUSH
72003: LD_VAR 0 2
72007: PPUSH
72008: LD_EXP 71
72012: PUSH
72013: LD_VAR 0 2
72017: ARRAY
72018: PUSH
72019: LD_VAR 0 3
72023: DIFF
72024: PPUSH
72025: CALL_OW 1
72029: ST_TO_ADDR
// continue ;
72030: GO 71975
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72032: LD_VAR 0 3
72036: PPUSH
72037: CALL_OW 311
72041: NOT
72042: PUSH
72043: LD_VAR 0 3
72047: PUSH
72048: LD_EXP 62
72052: PUSH
72053: LD_VAR 0 2
72057: ARRAY
72058: PUSH
72059: LD_INT 1
72061: ARRAY
72062: IN
72063: NOT
72064: AND
72065: PUSH
72066: LD_VAR 0 3
72070: PUSH
72071: LD_EXP 62
72075: PUSH
72076: LD_VAR 0 2
72080: ARRAY
72081: PUSH
72082: LD_INT 2
72084: ARRAY
72085: IN
72086: NOT
72087: AND
72088: IFFALSE 72151
// begin if IsInUnit ( j ) then
72090: LD_VAR 0 3
72094: PPUSH
72095: CALL_OW 310
72099: IFFALSE 72112
// ComExitBuilding ( j ) else
72101: LD_VAR 0 3
72105: PPUSH
72106: CALL_OW 122
72110: GO 72151
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
72112: LD_VAR 0 3
72116: PPUSH
72117: LD_VAR 0 7
72121: PUSH
72122: LD_INT 1
72124: ARRAY
72125: PPUSH
72126: CALL 53333 0 2
72130: NOT
72131: IFFALSE 72151
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
72133: LD_VAR 0 3
72137: PPUSH
72138: LD_VAR 0 7
72142: PUSH
72143: LD_INT 1
72145: ARRAY
72146: PPUSH
72147: CALL_OW 129
// end ; end ;
72151: GO 71975
72153: POP
72154: POP
// end ;
72155: GO 71464
72157: POP
72158: POP
// end ;
72159: LD_VAR 0 1
72163: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
72164: LD_INT 0
72166: PPUSH
72167: PPUSH
72168: PPUSH
72169: PPUSH
72170: PPUSH
72171: PPUSH
72172: PPUSH
72173: PPUSH
72174: PPUSH
72175: PPUSH
72176: PPUSH
// if not mc_bases then
72177: LD_EXP 59
72181: NOT
72182: IFFALSE 72186
// exit ;
72184: GO 72988
// for i = 1 to mc_bases do
72186: LD_ADDR_VAR 0 2
72190: PUSH
72191: DOUBLE
72192: LD_INT 1
72194: DEC
72195: ST_TO_ADDR
72196: LD_EXP 59
72200: PUSH
72201: FOR_TO
72202: IFFALSE 72986
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
72204: LD_EXP 87
72208: PUSH
72209: LD_VAR 0 2
72213: ARRAY
72214: NOT
72215: PUSH
72216: LD_EXP 62
72220: PUSH
72221: LD_VAR 0 2
72225: ARRAY
72226: PUSH
72227: LD_INT 1
72229: ARRAY
72230: OR
72231: PUSH
72232: LD_EXP 62
72236: PUSH
72237: LD_VAR 0 2
72241: ARRAY
72242: PUSH
72243: LD_INT 2
72245: ARRAY
72246: OR
72247: PUSH
72248: LD_EXP 85
72252: PUSH
72253: LD_VAR 0 2
72257: ARRAY
72258: PPUSH
72259: LD_INT 1
72261: PPUSH
72262: CALL_OW 325
72266: NOT
72267: OR
72268: PUSH
72269: LD_EXP 82
72273: PUSH
72274: LD_VAR 0 2
72278: ARRAY
72279: OR
72280: IFFALSE 72284
// continue ;
72282: GO 72201
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
72284: LD_ADDR_VAR 0 8
72288: PUSH
72289: LD_EXP 59
72293: PUSH
72294: LD_VAR 0 2
72298: ARRAY
72299: PPUSH
72300: LD_INT 25
72302: PUSH
72303: LD_INT 4
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: PUSH
72310: LD_INT 50
72312: PUSH
72313: EMPTY
72314: LIST
72315: PUSH
72316: LD_INT 3
72318: PUSH
72319: LD_INT 60
72321: PUSH
72322: EMPTY
72323: LIST
72324: PUSH
72325: EMPTY
72326: LIST
72327: LIST
72328: PUSH
72329: EMPTY
72330: LIST
72331: LIST
72332: LIST
72333: PPUSH
72334: CALL_OW 72
72338: PUSH
72339: LD_EXP 63
72343: PUSH
72344: LD_VAR 0 2
72348: ARRAY
72349: DIFF
72350: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72351: LD_ADDR_VAR 0 9
72355: PUSH
72356: LD_EXP 59
72360: PUSH
72361: LD_VAR 0 2
72365: ARRAY
72366: PPUSH
72367: LD_INT 2
72369: PUSH
72370: LD_INT 30
72372: PUSH
72373: LD_INT 0
72375: PUSH
72376: EMPTY
72377: LIST
72378: LIST
72379: PUSH
72380: LD_INT 30
72382: PUSH
72383: LD_INT 1
72385: PUSH
72386: EMPTY
72387: LIST
72388: LIST
72389: PUSH
72390: EMPTY
72391: LIST
72392: LIST
72393: LIST
72394: PPUSH
72395: CALL_OW 72
72399: ST_TO_ADDR
// if not tmp or not dep then
72400: LD_VAR 0 8
72404: NOT
72405: PUSH
72406: LD_VAR 0 9
72410: NOT
72411: OR
72412: IFFALSE 72416
// continue ;
72414: GO 72201
// side := GetSide ( tmp [ 1 ] ) ;
72416: LD_ADDR_VAR 0 11
72420: PUSH
72421: LD_VAR 0 8
72425: PUSH
72426: LD_INT 1
72428: ARRAY
72429: PPUSH
72430: CALL_OW 255
72434: ST_TO_ADDR
// dep := dep [ 1 ] ;
72435: LD_ADDR_VAR 0 9
72439: PUSH
72440: LD_VAR 0 9
72444: PUSH
72445: LD_INT 1
72447: ARRAY
72448: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
72449: LD_ADDR_VAR 0 7
72453: PUSH
72454: LD_EXP 87
72458: PUSH
72459: LD_VAR 0 2
72463: ARRAY
72464: PPUSH
72465: LD_INT 22
72467: PUSH
72468: LD_INT 0
72470: PUSH
72471: EMPTY
72472: LIST
72473: LIST
72474: PUSH
72475: LD_INT 25
72477: PUSH
72478: LD_INT 12
72480: PUSH
72481: EMPTY
72482: LIST
72483: LIST
72484: PUSH
72485: EMPTY
72486: LIST
72487: LIST
72488: PPUSH
72489: CALL_OW 70
72493: PUSH
72494: LD_INT 22
72496: PUSH
72497: LD_INT 0
72499: PUSH
72500: EMPTY
72501: LIST
72502: LIST
72503: PUSH
72504: LD_INT 25
72506: PUSH
72507: LD_INT 12
72509: PUSH
72510: EMPTY
72511: LIST
72512: LIST
72513: PUSH
72514: LD_INT 91
72516: PUSH
72517: LD_VAR 0 9
72521: PUSH
72522: LD_INT 20
72524: PUSH
72525: EMPTY
72526: LIST
72527: LIST
72528: LIST
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: LIST
72534: PPUSH
72535: CALL_OW 69
72539: UNION
72540: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
72541: LD_ADDR_VAR 0 10
72545: PUSH
72546: LD_EXP 87
72550: PUSH
72551: LD_VAR 0 2
72555: ARRAY
72556: PPUSH
72557: LD_INT 81
72559: PUSH
72560: LD_VAR 0 11
72564: PUSH
72565: EMPTY
72566: LIST
72567: LIST
72568: PPUSH
72569: CALL_OW 70
72573: ST_TO_ADDR
// if not apes or danger_at_area then
72574: LD_VAR 0 7
72578: NOT
72579: PUSH
72580: LD_VAR 0 10
72584: OR
72585: IFFALSE 72635
// begin if mc_taming [ i ] then
72587: LD_EXP 90
72591: PUSH
72592: LD_VAR 0 2
72596: ARRAY
72597: IFFALSE 72633
// begin MC_Reset ( i , 121 ) ;
72599: LD_VAR 0 2
72603: PPUSH
72604: LD_INT 121
72606: PPUSH
72607: CALL 57768 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
72611: LD_ADDR_EXP 90
72615: PUSH
72616: LD_EXP 90
72620: PPUSH
72621: LD_VAR 0 2
72625: PPUSH
72626: EMPTY
72627: PPUSH
72628: CALL_OW 1
72632: ST_TO_ADDR
// end ; continue ;
72633: GO 72201
// end ; for j in tmp do
72635: LD_ADDR_VAR 0 3
72639: PUSH
72640: LD_VAR 0 8
72644: PUSH
72645: FOR_IN
72646: IFFALSE 72982
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
72648: LD_VAR 0 3
72652: PUSH
72653: LD_EXP 90
72657: PUSH
72658: LD_VAR 0 2
72662: ARRAY
72663: IN
72664: NOT
72665: PUSH
72666: LD_EXP 90
72670: PUSH
72671: LD_VAR 0 2
72675: ARRAY
72676: PUSH
72677: LD_INT 3
72679: LESS
72680: AND
72681: IFFALSE 72739
// begin SetTag ( j , 121 ) ;
72683: LD_VAR 0 3
72687: PPUSH
72688: LD_INT 121
72690: PPUSH
72691: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
72695: LD_ADDR_EXP 90
72699: PUSH
72700: LD_EXP 90
72704: PPUSH
72705: LD_VAR 0 2
72709: PUSH
72710: LD_EXP 90
72714: PUSH
72715: LD_VAR 0 2
72719: ARRAY
72720: PUSH
72721: LD_INT 1
72723: PLUS
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: PPUSH
72729: LD_VAR 0 3
72733: PPUSH
72734: CALL 19726 0 3
72738: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
72739: LD_VAR 0 3
72743: PUSH
72744: LD_EXP 90
72748: PUSH
72749: LD_VAR 0 2
72753: ARRAY
72754: IN
72755: IFFALSE 72980
// begin if GetClass ( j ) <> 4 then
72757: LD_VAR 0 3
72761: PPUSH
72762: CALL_OW 257
72766: PUSH
72767: LD_INT 4
72769: NONEQUAL
72770: IFFALSE 72823
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
72772: LD_ADDR_EXP 90
72776: PUSH
72777: LD_EXP 90
72781: PPUSH
72782: LD_VAR 0 2
72786: PPUSH
72787: LD_EXP 90
72791: PUSH
72792: LD_VAR 0 2
72796: ARRAY
72797: PUSH
72798: LD_VAR 0 3
72802: DIFF
72803: PPUSH
72804: CALL_OW 1
72808: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72809: LD_VAR 0 3
72813: PPUSH
72814: LD_INT 0
72816: PPUSH
72817: CALL_OW 109
// continue ;
72821: GO 72645
// end ; if IsInUnit ( j ) then
72823: LD_VAR 0 3
72827: PPUSH
72828: CALL_OW 310
72832: IFFALSE 72843
// ComExitBuilding ( j ) ;
72834: LD_VAR 0 3
72838: PPUSH
72839: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
72843: LD_ADDR_VAR 0 6
72847: PUSH
72848: LD_VAR 0 7
72852: PPUSH
72853: LD_VAR 0 3
72857: PPUSH
72858: CALL_OW 74
72862: ST_TO_ADDR
// if not ape then
72863: LD_VAR 0 6
72867: NOT
72868: IFFALSE 72872
// break ;
72870: GO 72982
// x := GetX ( ape ) ;
72872: LD_ADDR_VAR 0 4
72876: PUSH
72877: LD_VAR 0 6
72881: PPUSH
72882: CALL_OW 250
72886: ST_TO_ADDR
// y := GetY ( ape ) ;
72887: LD_ADDR_VAR 0 5
72891: PUSH
72892: LD_VAR 0 6
72896: PPUSH
72897: CALL_OW 251
72901: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
72902: LD_VAR 0 4
72906: PPUSH
72907: LD_VAR 0 5
72911: PPUSH
72912: CALL_OW 488
72916: NOT
72917: PUSH
72918: LD_VAR 0 11
72922: PPUSH
72923: LD_VAR 0 4
72927: PPUSH
72928: LD_VAR 0 5
72932: PPUSH
72933: LD_INT 20
72935: PPUSH
72936: CALL 20622 0 4
72940: PUSH
72941: LD_INT 4
72943: ARRAY
72944: OR
72945: IFFALSE 72949
// break ;
72947: GO 72982
// if not HasTask ( j ) then
72949: LD_VAR 0 3
72953: PPUSH
72954: CALL_OW 314
72958: NOT
72959: IFFALSE 72980
// ComTameXY ( j , x , y ) ;
72961: LD_VAR 0 3
72965: PPUSH
72966: LD_VAR 0 4
72970: PPUSH
72971: LD_VAR 0 5
72975: PPUSH
72976: CALL_OW 131
// end ; end ;
72980: GO 72645
72982: POP
72983: POP
// end ;
72984: GO 72201
72986: POP
72987: POP
// end ;
72988: LD_VAR 0 1
72992: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
72993: LD_INT 0
72995: PPUSH
72996: PPUSH
72997: PPUSH
72998: PPUSH
72999: PPUSH
73000: PPUSH
73001: PPUSH
73002: PPUSH
// if not mc_bases then
73003: LD_EXP 59
73007: NOT
73008: IFFALSE 73012
// exit ;
73010: GO 73638
// for i = 1 to mc_bases do
73012: LD_ADDR_VAR 0 2
73016: PUSH
73017: DOUBLE
73018: LD_INT 1
73020: DEC
73021: ST_TO_ADDR
73022: LD_EXP 59
73026: PUSH
73027: FOR_TO
73028: IFFALSE 73636
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
73030: LD_EXP 88
73034: PUSH
73035: LD_VAR 0 2
73039: ARRAY
73040: NOT
73041: PUSH
73042: LD_EXP 88
73046: PUSH
73047: LD_VAR 0 2
73051: ARRAY
73052: PPUSH
73053: LD_INT 25
73055: PUSH
73056: LD_INT 12
73058: PUSH
73059: EMPTY
73060: LIST
73061: LIST
73062: PPUSH
73063: CALL_OW 72
73067: NOT
73068: OR
73069: IFFALSE 73073
// continue ;
73071: GO 73027
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
73073: LD_ADDR_VAR 0 5
73077: PUSH
73078: LD_EXP 88
73082: PUSH
73083: LD_VAR 0 2
73087: ARRAY
73088: PUSH
73089: LD_INT 1
73091: ARRAY
73092: PPUSH
73093: CALL_OW 255
73097: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
73098: LD_VAR 0 5
73102: PPUSH
73103: LD_INT 2
73105: PPUSH
73106: CALL_OW 325
73110: IFFALSE 73363
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73112: LD_ADDR_VAR 0 4
73116: PUSH
73117: LD_EXP 88
73121: PUSH
73122: LD_VAR 0 2
73126: ARRAY
73127: PPUSH
73128: LD_INT 25
73130: PUSH
73131: LD_INT 16
73133: PUSH
73134: EMPTY
73135: LIST
73136: LIST
73137: PPUSH
73138: CALL_OW 72
73142: ST_TO_ADDR
// if tmp < 6 then
73143: LD_VAR 0 4
73147: PUSH
73148: LD_INT 6
73150: LESS
73151: IFFALSE 73363
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73153: LD_ADDR_VAR 0 6
73157: PUSH
73158: LD_EXP 59
73162: PUSH
73163: LD_VAR 0 2
73167: ARRAY
73168: PPUSH
73169: LD_INT 2
73171: PUSH
73172: LD_INT 30
73174: PUSH
73175: LD_INT 0
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: PUSH
73182: LD_INT 30
73184: PUSH
73185: LD_INT 1
73187: PUSH
73188: EMPTY
73189: LIST
73190: LIST
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: LIST
73196: PPUSH
73197: CALL_OW 72
73201: ST_TO_ADDR
// if depot then
73202: LD_VAR 0 6
73206: IFFALSE 73363
// begin selected := 0 ;
73208: LD_ADDR_VAR 0 7
73212: PUSH
73213: LD_INT 0
73215: ST_TO_ADDR
// for j in depot do
73216: LD_ADDR_VAR 0 3
73220: PUSH
73221: LD_VAR 0 6
73225: PUSH
73226: FOR_IN
73227: IFFALSE 73258
// begin if UnitsInside ( j ) < 6 then
73229: LD_VAR 0 3
73233: PPUSH
73234: CALL_OW 313
73238: PUSH
73239: LD_INT 6
73241: LESS
73242: IFFALSE 73256
// begin selected := j ;
73244: LD_ADDR_VAR 0 7
73248: PUSH
73249: LD_VAR 0 3
73253: ST_TO_ADDR
// break ;
73254: GO 73258
// end ; end ;
73256: GO 73226
73258: POP
73259: POP
// if selected then
73260: LD_VAR 0 7
73264: IFFALSE 73363
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73266: LD_ADDR_VAR 0 3
73270: PUSH
73271: LD_EXP 88
73275: PUSH
73276: LD_VAR 0 2
73280: ARRAY
73281: PPUSH
73282: LD_INT 25
73284: PUSH
73285: LD_INT 12
73287: PUSH
73288: EMPTY
73289: LIST
73290: LIST
73291: PPUSH
73292: CALL_OW 72
73296: PUSH
73297: FOR_IN
73298: IFFALSE 73361
// if not HasTask ( j ) then
73300: LD_VAR 0 3
73304: PPUSH
73305: CALL_OW 314
73309: NOT
73310: IFFALSE 73359
// begin if not IsInUnit ( j ) then
73312: LD_VAR 0 3
73316: PPUSH
73317: CALL_OW 310
73321: NOT
73322: IFFALSE 73338
// ComEnterUnit ( j , selected ) ;
73324: LD_VAR 0 3
73328: PPUSH
73329: LD_VAR 0 7
73333: PPUSH
73334: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
73338: LD_VAR 0 3
73342: PPUSH
73343: LD_INT 16
73345: PPUSH
73346: CALL_OW 183
// AddComExitBuilding ( j ) ;
73350: LD_VAR 0 3
73354: PPUSH
73355: CALL_OW 182
// end ;
73359: GO 73297
73361: POP
73362: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
73363: LD_VAR 0 5
73367: PPUSH
73368: LD_INT 11
73370: PPUSH
73371: CALL_OW 325
73375: IFFALSE 73634
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73377: LD_ADDR_VAR 0 4
73381: PUSH
73382: LD_EXP 88
73386: PUSH
73387: LD_VAR 0 2
73391: ARRAY
73392: PPUSH
73393: LD_INT 25
73395: PUSH
73396: LD_INT 16
73398: PUSH
73399: EMPTY
73400: LIST
73401: LIST
73402: PPUSH
73403: CALL_OW 72
73407: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
73408: LD_VAR 0 4
73412: PUSH
73413: LD_INT 6
73415: GREATEREQUAL
73416: PUSH
73417: LD_VAR 0 5
73421: PPUSH
73422: LD_INT 2
73424: PPUSH
73425: CALL_OW 325
73429: NOT
73430: OR
73431: IFFALSE 73634
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
73433: LD_ADDR_VAR 0 8
73437: PUSH
73438: LD_EXP 59
73442: PUSH
73443: LD_VAR 0 2
73447: ARRAY
73448: PPUSH
73449: LD_INT 2
73451: PUSH
73452: LD_INT 30
73454: PUSH
73455: LD_INT 4
73457: PUSH
73458: EMPTY
73459: LIST
73460: LIST
73461: PUSH
73462: LD_INT 30
73464: PUSH
73465: LD_INT 5
73467: PUSH
73468: EMPTY
73469: LIST
73470: LIST
73471: PUSH
73472: EMPTY
73473: LIST
73474: LIST
73475: LIST
73476: PPUSH
73477: CALL_OW 72
73481: ST_TO_ADDR
// if barracks then
73482: LD_VAR 0 8
73486: IFFALSE 73634
// begin selected := 0 ;
73488: LD_ADDR_VAR 0 7
73492: PUSH
73493: LD_INT 0
73495: ST_TO_ADDR
// for j in barracks do
73496: LD_ADDR_VAR 0 3
73500: PUSH
73501: LD_VAR 0 8
73505: PUSH
73506: FOR_IN
73507: IFFALSE 73538
// begin if UnitsInside ( j ) < 6 then
73509: LD_VAR 0 3
73513: PPUSH
73514: CALL_OW 313
73518: PUSH
73519: LD_INT 6
73521: LESS
73522: IFFALSE 73536
// begin selected := j ;
73524: LD_ADDR_VAR 0 7
73528: PUSH
73529: LD_VAR 0 3
73533: ST_TO_ADDR
// break ;
73534: GO 73538
// end ; end ;
73536: GO 73506
73538: POP
73539: POP
// if selected then
73540: LD_VAR 0 7
73544: IFFALSE 73634
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73546: LD_ADDR_VAR 0 3
73550: PUSH
73551: LD_EXP 88
73555: PUSH
73556: LD_VAR 0 2
73560: ARRAY
73561: PPUSH
73562: LD_INT 25
73564: PUSH
73565: LD_INT 12
73567: PUSH
73568: EMPTY
73569: LIST
73570: LIST
73571: PPUSH
73572: CALL_OW 72
73576: PUSH
73577: FOR_IN
73578: IFFALSE 73632
// if not IsInUnit ( j ) and not HasTask ( j ) then
73580: LD_VAR 0 3
73584: PPUSH
73585: CALL_OW 310
73589: NOT
73590: PUSH
73591: LD_VAR 0 3
73595: PPUSH
73596: CALL_OW 314
73600: NOT
73601: AND
73602: IFFALSE 73630
// begin ComEnterUnit ( j , selected ) ;
73604: LD_VAR 0 3
73608: PPUSH
73609: LD_VAR 0 7
73613: PPUSH
73614: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
73618: LD_VAR 0 3
73622: PPUSH
73623: LD_INT 15
73625: PPUSH
73626: CALL_OW 183
// end ;
73630: GO 73577
73632: POP
73633: POP
// end ; end ; end ; end ; end ;
73634: GO 73027
73636: POP
73637: POP
// end ;
73638: LD_VAR 0 1
73642: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
73643: LD_INT 0
73645: PPUSH
73646: PPUSH
73647: PPUSH
73648: PPUSH
// if not mc_bases then
73649: LD_EXP 59
73653: NOT
73654: IFFALSE 73658
// exit ;
73656: GO 73836
// for i = 1 to mc_bases do
73658: LD_ADDR_VAR 0 2
73662: PUSH
73663: DOUBLE
73664: LD_INT 1
73666: DEC
73667: ST_TO_ADDR
73668: LD_EXP 59
73672: PUSH
73673: FOR_TO
73674: IFFALSE 73834
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
73676: LD_ADDR_VAR 0 4
73680: PUSH
73681: LD_EXP 59
73685: PUSH
73686: LD_VAR 0 2
73690: ARRAY
73691: PPUSH
73692: LD_INT 25
73694: PUSH
73695: LD_INT 9
73697: PUSH
73698: EMPTY
73699: LIST
73700: LIST
73701: PPUSH
73702: CALL_OW 72
73706: ST_TO_ADDR
// if not tmp then
73707: LD_VAR 0 4
73711: NOT
73712: IFFALSE 73716
// continue ;
73714: GO 73673
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
73716: LD_EXP 85
73720: PUSH
73721: LD_VAR 0 2
73725: ARRAY
73726: PPUSH
73727: LD_INT 29
73729: PPUSH
73730: CALL_OW 325
73734: NOT
73735: PUSH
73736: LD_EXP 85
73740: PUSH
73741: LD_VAR 0 2
73745: ARRAY
73746: PPUSH
73747: LD_INT 28
73749: PPUSH
73750: CALL_OW 325
73754: NOT
73755: AND
73756: IFFALSE 73760
// continue ;
73758: GO 73673
// for j in tmp do
73760: LD_ADDR_VAR 0 3
73764: PUSH
73765: LD_VAR 0 4
73769: PUSH
73770: FOR_IN
73771: IFFALSE 73830
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73773: LD_VAR 0 3
73777: PUSH
73778: LD_EXP 62
73782: PUSH
73783: LD_VAR 0 2
73787: ARRAY
73788: PUSH
73789: LD_INT 1
73791: ARRAY
73792: IN
73793: NOT
73794: PUSH
73795: LD_VAR 0 3
73799: PUSH
73800: LD_EXP 62
73804: PUSH
73805: LD_VAR 0 2
73809: ARRAY
73810: PUSH
73811: LD_INT 2
73813: ARRAY
73814: IN
73815: NOT
73816: AND
73817: IFFALSE 73828
// ComSpaceTimeShoot ( j ) ;
73819: LD_VAR 0 3
73823: PPUSH
73824: CALL 15687 0 1
73828: GO 73770
73830: POP
73831: POP
// end ;
73832: GO 73673
73834: POP
73835: POP
// end ;
73836: LD_VAR 0 1
73840: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
73841: LD_INT 0
73843: PPUSH
73844: PPUSH
73845: PPUSH
73846: PPUSH
73847: PPUSH
73848: PPUSH
73849: PPUSH
73850: PPUSH
73851: PPUSH
// if not mc_bases then
73852: LD_EXP 59
73856: NOT
73857: IFFALSE 73861
// exit ;
73859: GO 74483
// for i = 1 to mc_bases do
73861: LD_ADDR_VAR 0 2
73865: PUSH
73866: DOUBLE
73867: LD_INT 1
73869: DEC
73870: ST_TO_ADDR
73871: LD_EXP 59
73875: PUSH
73876: FOR_TO
73877: IFFALSE 74481
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
73879: LD_EXP 94
73883: PUSH
73884: LD_VAR 0 2
73888: ARRAY
73889: NOT
73890: PUSH
73891: LD_INT 38
73893: PPUSH
73894: LD_EXP 85
73898: PUSH
73899: LD_VAR 0 2
73903: ARRAY
73904: PPUSH
73905: CALL_OW 321
73909: PUSH
73910: LD_INT 2
73912: NONEQUAL
73913: OR
73914: IFFALSE 73918
// continue ;
73916: GO 73876
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
73918: LD_ADDR_VAR 0 8
73922: PUSH
73923: LD_EXP 59
73927: PUSH
73928: LD_VAR 0 2
73932: ARRAY
73933: PPUSH
73934: LD_INT 30
73936: PUSH
73937: LD_INT 34
73939: PUSH
73940: EMPTY
73941: LIST
73942: LIST
73943: PPUSH
73944: CALL_OW 72
73948: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
73949: LD_ADDR_VAR 0 9
73953: PUSH
73954: LD_EXP 59
73958: PUSH
73959: LD_VAR 0 2
73963: ARRAY
73964: PPUSH
73965: LD_INT 25
73967: PUSH
73968: LD_INT 4
73970: PUSH
73971: EMPTY
73972: LIST
73973: LIST
73974: PPUSH
73975: CALL_OW 72
73979: PPUSH
73980: LD_INT 0
73982: PPUSH
73983: CALL 48995 0 2
73987: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
73988: LD_VAR 0 9
73992: NOT
73993: PUSH
73994: LD_VAR 0 8
73998: NOT
73999: OR
74000: PUSH
74001: LD_EXP 59
74005: PUSH
74006: LD_VAR 0 2
74010: ARRAY
74011: PPUSH
74012: LD_INT 124
74014: PPUSH
74015: CALL 48995 0 2
74019: OR
74020: IFFALSE 74024
// continue ;
74022: GO 73876
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
74024: LD_EXP 95
74028: PUSH
74029: LD_VAR 0 2
74033: ARRAY
74034: PUSH
74035: LD_EXP 94
74039: PUSH
74040: LD_VAR 0 2
74044: ARRAY
74045: LESS
74046: PUSH
74047: LD_EXP 95
74051: PUSH
74052: LD_VAR 0 2
74056: ARRAY
74057: PUSH
74058: LD_VAR 0 8
74062: LESS
74063: AND
74064: IFFALSE 74479
// begin tmp := sci [ 1 ] ;
74066: LD_ADDR_VAR 0 7
74070: PUSH
74071: LD_VAR 0 9
74075: PUSH
74076: LD_INT 1
74078: ARRAY
74079: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
74080: LD_VAR 0 7
74084: PPUSH
74085: LD_INT 124
74087: PPUSH
74088: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
74092: LD_ADDR_VAR 0 3
74096: PUSH
74097: DOUBLE
74098: LD_EXP 94
74102: PUSH
74103: LD_VAR 0 2
74107: ARRAY
74108: INC
74109: ST_TO_ADDR
74110: LD_EXP 94
74114: PUSH
74115: LD_VAR 0 2
74119: ARRAY
74120: PUSH
74121: FOR_DOWNTO
74122: IFFALSE 74465
// begin if IsInUnit ( tmp ) then
74124: LD_VAR 0 7
74128: PPUSH
74129: CALL_OW 310
74133: IFFALSE 74144
// ComExitBuilding ( tmp ) ;
74135: LD_VAR 0 7
74139: PPUSH
74140: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
74144: LD_INT 35
74146: PPUSH
74147: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
74151: LD_VAR 0 7
74155: PPUSH
74156: CALL_OW 310
74160: NOT
74161: PUSH
74162: LD_VAR 0 7
74166: PPUSH
74167: CALL_OW 314
74171: NOT
74172: AND
74173: IFFALSE 74144
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
74175: LD_ADDR_VAR 0 6
74179: PUSH
74180: LD_VAR 0 7
74184: PPUSH
74185: CALL_OW 250
74189: PUSH
74190: LD_VAR 0 7
74194: PPUSH
74195: CALL_OW 251
74199: PUSH
74200: EMPTY
74201: LIST
74202: LIST
74203: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74204: LD_INT 35
74206: PPUSH
74207: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
74211: LD_ADDR_VAR 0 4
74215: PUSH
74216: LD_EXP 94
74220: PUSH
74221: LD_VAR 0 2
74225: ARRAY
74226: PUSH
74227: LD_VAR 0 3
74231: ARRAY
74232: PUSH
74233: LD_INT 1
74235: ARRAY
74236: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
74237: LD_ADDR_VAR 0 5
74241: PUSH
74242: LD_EXP 94
74246: PUSH
74247: LD_VAR 0 2
74251: ARRAY
74252: PUSH
74253: LD_VAR 0 3
74257: ARRAY
74258: PUSH
74259: LD_INT 2
74261: ARRAY
74262: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
74263: LD_VAR 0 7
74267: PPUSH
74268: LD_INT 10
74270: PPUSH
74271: CALL 22325 0 2
74275: PUSH
74276: LD_INT 4
74278: ARRAY
74279: IFFALSE 74317
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
74281: LD_VAR 0 7
74285: PPUSH
74286: LD_VAR 0 6
74290: PUSH
74291: LD_INT 1
74293: ARRAY
74294: PPUSH
74295: LD_VAR 0 6
74299: PUSH
74300: LD_INT 2
74302: ARRAY
74303: PPUSH
74304: CALL_OW 111
// wait ( 0 0$10 ) ;
74308: LD_INT 350
74310: PPUSH
74311: CALL_OW 67
// end else
74315: GO 74343
// begin ComMoveXY ( tmp , x , y ) ;
74317: LD_VAR 0 7
74321: PPUSH
74322: LD_VAR 0 4
74326: PPUSH
74327: LD_VAR 0 5
74331: PPUSH
74332: CALL_OW 111
// wait ( 0 0$3 ) ;
74336: LD_INT 105
74338: PPUSH
74339: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
74343: LD_VAR 0 7
74347: PPUSH
74348: LD_VAR 0 4
74352: PPUSH
74353: LD_VAR 0 5
74357: PPUSH
74358: CALL_OW 307
74362: IFFALSE 74204
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
74364: LD_VAR 0 7
74368: PPUSH
74369: LD_VAR 0 4
74373: PPUSH
74374: LD_VAR 0 5
74378: PPUSH
74379: LD_VAR 0 8
74383: PUSH
74384: LD_VAR 0 3
74388: ARRAY
74389: PPUSH
74390: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
74394: LD_INT 35
74396: PPUSH
74397: CALL_OW 67
// until not HasTask ( tmp ) ;
74401: LD_VAR 0 7
74405: PPUSH
74406: CALL_OW 314
74410: NOT
74411: IFFALSE 74394
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
74413: LD_ADDR_EXP 95
74417: PUSH
74418: LD_EXP 95
74422: PPUSH
74423: LD_VAR 0 2
74427: PUSH
74428: LD_EXP 95
74432: PUSH
74433: LD_VAR 0 2
74437: ARRAY
74438: PUSH
74439: LD_INT 1
74441: PLUS
74442: PUSH
74443: EMPTY
74444: LIST
74445: LIST
74446: PPUSH
74447: LD_VAR 0 8
74451: PUSH
74452: LD_VAR 0 3
74456: ARRAY
74457: PPUSH
74458: CALL 19726 0 3
74462: ST_TO_ADDR
// end ;
74463: GO 74121
74465: POP
74466: POP
// MC_Reset ( i , 124 ) ;
74467: LD_VAR 0 2
74471: PPUSH
74472: LD_INT 124
74474: PPUSH
74475: CALL 57768 0 2
// end ; end ;
74479: GO 73876
74481: POP
74482: POP
// end ;
74483: LD_VAR 0 1
74487: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
74488: LD_INT 0
74490: PPUSH
74491: PPUSH
74492: PPUSH
// if not mc_bases then
74493: LD_EXP 59
74497: NOT
74498: IFFALSE 74502
// exit ;
74500: GO 75108
// for i = 1 to mc_bases do
74502: LD_ADDR_VAR 0 2
74506: PUSH
74507: DOUBLE
74508: LD_INT 1
74510: DEC
74511: ST_TO_ADDR
74512: LD_EXP 59
74516: PUSH
74517: FOR_TO
74518: IFFALSE 75106
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
74520: LD_ADDR_VAR 0 3
74524: PUSH
74525: LD_EXP 59
74529: PUSH
74530: LD_VAR 0 2
74534: ARRAY
74535: PPUSH
74536: LD_INT 25
74538: PUSH
74539: LD_INT 4
74541: PUSH
74542: EMPTY
74543: LIST
74544: LIST
74545: PPUSH
74546: CALL_OW 72
74550: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
74551: LD_VAR 0 3
74555: NOT
74556: PUSH
74557: LD_EXP 96
74561: PUSH
74562: LD_VAR 0 2
74566: ARRAY
74567: NOT
74568: OR
74569: PUSH
74570: LD_EXP 59
74574: PUSH
74575: LD_VAR 0 2
74579: ARRAY
74580: PPUSH
74581: LD_INT 2
74583: PUSH
74584: LD_INT 30
74586: PUSH
74587: LD_INT 0
74589: PUSH
74590: EMPTY
74591: LIST
74592: LIST
74593: PUSH
74594: LD_INT 30
74596: PUSH
74597: LD_INT 1
74599: PUSH
74600: EMPTY
74601: LIST
74602: LIST
74603: PUSH
74604: EMPTY
74605: LIST
74606: LIST
74607: LIST
74608: PPUSH
74609: CALL_OW 72
74613: NOT
74614: OR
74615: IFFALSE 74665
// begin if mc_deposits_finder [ i ] then
74617: LD_EXP 97
74621: PUSH
74622: LD_VAR 0 2
74626: ARRAY
74627: IFFALSE 74663
// begin MC_Reset ( i , 125 ) ;
74629: LD_VAR 0 2
74633: PPUSH
74634: LD_INT 125
74636: PPUSH
74637: CALL 57768 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74641: LD_ADDR_EXP 97
74645: PUSH
74646: LD_EXP 97
74650: PPUSH
74651: LD_VAR 0 2
74655: PPUSH
74656: EMPTY
74657: PPUSH
74658: CALL_OW 1
74662: ST_TO_ADDR
// end ; continue ;
74663: GO 74517
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
74665: LD_EXP 96
74669: PUSH
74670: LD_VAR 0 2
74674: ARRAY
74675: PUSH
74676: LD_INT 1
74678: ARRAY
74679: PUSH
74680: LD_INT 3
74682: ARRAY
74683: PUSH
74684: LD_INT 1
74686: EQUAL
74687: PUSH
74688: LD_INT 20
74690: PPUSH
74691: LD_EXP 85
74695: PUSH
74696: LD_VAR 0 2
74700: ARRAY
74701: PPUSH
74702: CALL_OW 321
74706: PUSH
74707: LD_INT 2
74709: NONEQUAL
74710: AND
74711: IFFALSE 74761
// begin if mc_deposits_finder [ i ] then
74713: LD_EXP 97
74717: PUSH
74718: LD_VAR 0 2
74722: ARRAY
74723: IFFALSE 74759
// begin MC_Reset ( i , 125 ) ;
74725: LD_VAR 0 2
74729: PPUSH
74730: LD_INT 125
74732: PPUSH
74733: CALL 57768 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74737: LD_ADDR_EXP 97
74741: PUSH
74742: LD_EXP 97
74746: PPUSH
74747: LD_VAR 0 2
74751: PPUSH
74752: EMPTY
74753: PPUSH
74754: CALL_OW 1
74758: ST_TO_ADDR
// end ; continue ;
74759: GO 74517
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
74761: LD_EXP 96
74765: PUSH
74766: LD_VAR 0 2
74770: ARRAY
74771: PUSH
74772: LD_INT 1
74774: ARRAY
74775: PUSH
74776: LD_INT 1
74778: ARRAY
74779: PPUSH
74780: LD_EXP 96
74784: PUSH
74785: LD_VAR 0 2
74789: ARRAY
74790: PUSH
74791: LD_INT 1
74793: ARRAY
74794: PUSH
74795: LD_INT 2
74797: ARRAY
74798: PPUSH
74799: LD_EXP 85
74803: PUSH
74804: LD_VAR 0 2
74808: ARRAY
74809: PPUSH
74810: CALL_OW 440
74814: IFFALSE 74857
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
74816: LD_ADDR_EXP 96
74820: PUSH
74821: LD_EXP 96
74825: PPUSH
74826: LD_VAR 0 2
74830: PPUSH
74831: LD_EXP 96
74835: PUSH
74836: LD_VAR 0 2
74840: ARRAY
74841: PPUSH
74842: LD_INT 1
74844: PPUSH
74845: CALL_OW 3
74849: PPUSH
74850: CALL_OW 1
74854: ST_TO_ADDR
74855: GO 75104
// begin if not mc_deposits_finder [ i ] then
74857: LD_EXP 97
74861: PUSH
74862: LD_VAR 0 2
74866: ARRAY
74867: NOT
74868: IFFALSE 74920
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
74870: LD_ADDR_EXP 97
74874: PUSH
74875: LD_EXP 97
74879: PPUSH
74880: LD_VAR 0 2
74884: PPUSH
74885: LD_VAR 0 3
74889: PUSH
74890: LD_INT 1
74892: ARRAY
74893: PUSH
74894: EMPTY
74895: LIST
74896: PPUSH
74897: CALL_OW 1
74901: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
74902: LD_VAR 0 3
74906: PUSH
74907: LD_INT 1
74909: ARRAY
74910: PPUSH
74911: LD_INT 125
74913: PPUSH
74914: CALL_OW 109
// end else
74918: GO 75104
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
74920: LD_EXP 97
74924: PUSH
74925: LD_VAR 0 2
74929: ARRAY
74930: PUSH
74931: LD_INT 1
74933: ARRAY
74934: PPUSH
74935: CALL_OW 310
74939: IFFALSE 74962
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
74941: LD_EXP 97
74945: PUSH
74946: LD_VAR 0 2
74950: ARRAY
74951: PUSH
74952: LD_INT 1
74954: ARRAY
74955: PPUSH
74956: CALL_OW 122
74960: GO 75104
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
74962: LD_EXP 97
74966: PUSH
74967: LD_VAR 0 2
74971: ARRAY
74972: PUSH
74973: LD_INT 1
74975: ARRAY
74976: PPUSH
74977: CALL_OW 314
74981: NOT
74982: PUSH
74983: LD_EXP 97
74987: PUSH
74988: LD_VAR 0 2
74992: ARRAY
74993: PUSH
74994: LD_INT 1
74996: ARRAY
74997: PPUSH
74998: LD_EXP 96
75002: PUSH
75003: LD_VAR 0 2
75007: ARRAY
75008: PUSH
75009: LD_INT 1
75011: ARRAY
75012: PUSH
75013: LD_INT 1
75015: ARRAY
75016: PPUSH
75017: LD_EXP 96
75021: PUSH
75022: LD_VAR 0 2
75026: ARRAY
75027: PUSH
75028: LD_INT 1
75030: ARRAY
75031: PUSH
75032: LD_INT 2
75034: ARRAY
75035: PPUSH
75036: CALL_OW 297
75040: PUSH
75041: LD_INT 6
75043: GREATER
75044: AND
75045: IFFALSE 75104
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
75047: LD_EXP 97
75051: PUSH
75052: LD_VAR 0 2
75056: ARRAY
75057: PUSH
75058: LD_INT 1
75060: ARRAY
75061: PPUSH
75062: LD_EXP 96
75066: PUSH
75067: LD_VAR 0 2
75071: ARRAY
75072: PUSH
75073: LD_INT 1
75075: ARRAY
75076: PUSH
75077: LD_INT 1
75079: ARRAY
75080: PPUSH
75081: LD_EXP 96
75085: PUSH
75086: LD_VAR 0 2
75090: ARRAY
75091: PUSH
75092: LD_INT 1
75094: ARRAY
75095: PUSH
75096: LD_INT 2
75098: ARRAY
75099: PPUSH
75100: CALL_OW 111
// end ; end ; end ;
75104: GO 74517
75106: POP
75107: POP
// end ;
75108: LD_VAR 0 1
75112: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
75113: LD_INT 0
75115: PPUSH
75116: PPUSH
75117: PPUSH
75118: PPUSH
75119: PPUSH
75120: PPUSH
75121: PPUSH
75122: PPUSH
75123: PPUSH
75124: PPUSH
75125: PPUSH
// if not mc_bases then
75126: LD_EXP 59
75130: NOT
75131: IFFALSE 75135
// exit ;
75133: GO 76075
// for i = 1 to mc_bases do
75135: LD_ADDR_VAR 0 2
75139: PUSH
75140: DOUBLE
75141: LD_INT 1
75143: DEC
75144: ST_TO_ADDR
75145: LD_EXP 59
75149: PUSH
75150: FOR_TO
75151: IFFALSE 76073
// begin if not mc_bases [ i ] or mc_scan [ i ] then
75153: LD_EXP 59
75157: PUSH
75158: LD_VAR 0 2
75162: ARRAY
75163: NOT
75164: PUSH
75165: LD_EXP 82
75169: PUSH
75170: LD_VAR 0 2
75174: ARRAY
75175: OR
75176: IFFALSE 75180
// continue ;
75178: GO 75150
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
75180: LD_ADDR_VAR 0 7
75184: PUSH
75185: LD_EXP 59
75189: PUSH
75190: LD_VAR 0 2
75194: ARRAY
75195: PUSH
75196: LD_INT 1
75198: ARRAY
75199: PPUSH
75200: CALL_OW 248
75204: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
75205: LD_VAR 0 7
75209: PUSH
75210: LD_INT 3
75212: EQUAL
75213: PUSH
75214: LD_EXP 78
75218: PUSH
75219: LD_VAR 0 2
75223: ARRAY
75224: PUSH
75225: LD_EXP 81
75229: PUSH
75230: LD_VAR 0 2
75234: ARRAY
75235: UNION
75236: PPUSH
75237: LD_INT 33
75239: PUSH
75240: LD_INT 2
75242: PUSH
75243: EMPTY
75244: LIST
75245: LIST
75246: PPUSH
75247: CALL_OW 72
75251: NOT
75252: OR
75253: IFFALSE 75257
// continue ;
75255: GO 75150
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
75257: LD_ADDR_VAR 0 9
75261: PUSH
75262: LD_EXP 59
75266: PUSH
75267: LD_VAR 0 2
75271: ARRAY
75272: PPUSH
75273: LD_INT 30
75275: PUSH
75276: LD_INT 36
75278: PUSH
75279: EMPTY
75280: LIST
75281: LIST
75282: PPUSH
75283: CALL_OW 72
75287: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
75288: LD_ADDR_VAR 0 10
75292: PUSH
75293: LD_EXP 78
75297: PUSH
75298: LD_VAR 0 2
75302: ARRAY
75303: PPUSH
75304: LD_INT 34
75306: PUSH
75307: LD_INT 31
75309: PUSH
75310: EMPTY
75311: LIST
75312: LIST
75313: PPUSH
75314: CALL_OW 72
75318: ST_TO_ADDR
// if not cts and not mcts then
75319: LD_VAR 0 9
75323: NOT
75324: PUSH
75325: LD_VAR 0 10
75329: NOT
75330: AND
75331: IFFALSE 75335
// continue ;
75333: GO 75150
// x := cts ;
75335: LD_ADDR_VAR 0 11
75339: PUSH
75340: LD_VAR 0 9
75344: ST_TO_ADDR
// if not x then
75345: LD_VAR 0 11
75349: NOT
75350: IFFALSE 75362
// x := mcts ;
75352: LD_ADDR_VAR 0 11
75356: PUSH
75357: LD_VAR 0 10
75361: ST_TO_ADDR
// if not x then
75362: LD_VAR 0 11
75366: NOT
75367: IFFALSE 75371
// continue ;
75369: GO 75150
// if mc_remote_driver [ i ] then
75371: LD_EXP 99
75375: PUSH
75376: LD_VAR 0 2
75380: ARRAY
75381: IFFALSE 75768
// for j in mc_remote_driver [ i ] do
75383: LD_ADDR_VAR 0 3
75387: PUSH
75388: LD_EXP 99
75392: PUSH
75393: LD_VAR 0 2
75397: ARRAY
75398: PUSH
75399: FOR_IN
75400: IFFALSE 75766
// begin if GetClass ( j ) <> 3 then
75402: LD_VAR 0 3
75406: PPUSH
75407: CALL_OW 257
75411: PUSH
75412: LD_INT 3
75414: NONEQUAL
75415: IFFALSE 75468
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
75417: LD_ADDR_EXP 99
75421: PUSH
75422: LD_EXP 99
75426: PPUSH
75427: LD_VAR 0 2
75431: PPUSH
75432: LD_EXP 99
75436: PUSH
75437: LD_VAR 0 2
75441: ARRAY
75442: PUSH
75443: LD_VAR 0 3
75447: DIFF
75448: PPUSH
75449: CALL_OW 1
75453: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75454: LD_VAR 0 3
75458: PPUSH
75459: LD_INT 0
75461: PPUSH
75462: CALL_OW 109
// continue ;
75466: GO 75399
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
75468: LD_EXP 78
75472: PUSH
75473: LD_VAR 0 2
75477: ARRAY
75478: PPUSH
75479: LD_INT 34
75481: PUSH
75482: LD_INT 31
75484: PUSH
75485: EMPTY
75486: LIST
75487: LIST
75488: PUSH
75489: LD_INT 58
75491: PUSH
75492: EMPTY
75493: LIST
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PPUSH
75499: CALL_OW 72
75503: PUSH
75504: LD_VAR 0 3
75508: PPUSH
75509: CALL 49083 0 1
75513: NOT
75514: AND
75515: IFFALSE 75586
// begin if IsInUnit ( j ) then
75517: LD_VAR 0 3
75521: PPUSH
75522: CALL_OW 310
75526: IFFALSE 75537
// ComExitBuilding ( j ) ;
75528: LD_VAR 0 3
75532: PPUSH
75533: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
75537: LD_VAR 0 3
75541: PPUSH
75542: LD_EXP 78
75546: PUSH
75547: LD_VAR 0 2
75551: ARRAY
75552: PPUSH
75553: LD_INT 34
75555: PUSH
75556: LD_INT 31
75558: PUSH
75559: EMPTY
75560: LIST
75561: LIST
75562: PUSH
75563: LD_INT 58
75565: PUSH
75566: EMPTY
75567: LIST
75568: PUSH
75569: EMPTY
75570: LIST
75571: LIST
75572: PPUSH
75573: CALL_OW 72
75577: PUSH
75578: LD_INT 1
75580: ARRAY
75581: PPUSH
75582: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
75586: LD_VAR 0 3
75590: PPUSH
75591: CALL_OW 310
75595: NOT
75596: PUSH
75597: LD_VAR 0 3
75601: PPUSH
75602: CALL_OW 310
75606: PPUSH
75607: CALL_OW 266
75611: PUSH
75612: LD_INT 36
75614: NONEQUAL
75615: PUSH
75616: LD_VAR 0 3
75620: PPUSH
75621: CALL 49083 0 1
75625: NOT
75626: AND
75627: OR
75628: IFFALSE 75764
// begin if IsInUnit ( j ) then
75630: LD_VAR 0 3
75634: PPUSH
75635: CALL_OW 310
75639: IFFALSE 75650
// ComExitBuilding ( j ) ;
75641: LD_VAR 0 3
75645: PPUSH
75646: CALL_OW 122
// ct := 0 ;
75650: LD_ADDR_VAR 0 8
75654: PUSH
75655: LD_INT 0
75657: ST_TO_ADDR
// for k in x do
75658: LD_ADDR_VAR 0 4
75662: PUSH
75663: LD_VAR 0 11
75667: PUSH
75668: FOR_IN
75669: IFFALSE 75742
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
75671: LD_VAR 0 4
75675: PPUSH
75676: CALL_OW 264
75680: PUSH
75681: LD_INT 31
75683: EQUAL
75684: PUSH
75685: LD_VAR 0 4
75689: PPUSH
75690: CALL_OW 311
75694: NOT
75695: AND
75696: PUSH
75697: LD_VAR 0 4
75701: PPUSH
75702: CALL_OW 266
75706: PUSH
75707: LD_INT 36
75709: EQUAL
75710: PUSH
75711: LD_VAR 0 4
75715: PPUSH
75716: CALL_OW 313
75720: PUSH
75721: LD_INT 3
75723: LESS
75724: AND
75725: OR
75726: IFFALSE 75740
// begin ct := k ;
75728: LD_ADDR_VAR 0 8
75732: PUSH
75733: LD_VAR 0 4
75737: ST_TO_ADDR
// break ;
75738: GO 75742
// end ;
75740: GO 75668
75742: POP
75743: POP
// if ct then
75744: LD_VAR 0 8
75748: IFFALSE 75764
// ComEnterUnit ( j , ct ) ;
75750: LD_VAR 0 3
75754: PPUSH
75755: LD_VAR 0 8
75759: PPUSH
75760: CALL_OW 120
// end ; end ;
75764: GO 75399
75766: POP
75767: POP
// places := 0 ;
75768: LD_ADDR_VAR 0 5
75772: PUSH
75773: LD_INT 0
75775: ST_TO_ADDR
// for j = 1 to x do
75776: LD_ADDR_VAR 0 3
75780: PUSH
75781: DOUBLE
75782: LD_INT 1
75784: DEC
75785: ST_TO_ADDR
75786: LD_VAR 0 11
75790: PUSH
75791: FOR_TO
75792: IFFALSE 75868
// if GetWeapon ( x [ j ] ) = ar_control_tower then
75794: LD_VAR 0 11
75798: PUSH
75799: LD_VAR 0 3
75803: ARRAY
75804: PPUSH
75805: CALL_OW 264
75809: PUSH
75810: LD_INT 31
75812: EQUAL
75813: IFFALSE 75831
// places := places + 1 else
75815: LD_ADDR_VAR 0 5
75819: PUSH
75820: LD_VAR 0 5
75824: PUSH
75825: LD_INT 1
75827: PLUS
75828: ST_TO_ADDR
75829: GO 75866
// if GetBType ( x [ j ] ) = b_control_tower then
75831: LD_VAR 0 11
75835: PUSH
75836: LD_VAR 0 3
75840: ARRAY
75841: PPUSH
75842: CALL_OW 266
75846: PUSH
75847: LD_INT 36
75849: EQUAL
75850: IFFALSE 75866
// places := places + 3 ;
75852: LD_ADDR_VAR 0 5
75856: PUSH
75857: LD_VAR 0 5
75861: PUSH
75862: LD_INT 3
75864: PLUS
75865: ST_TO_ADDR
75866: GO 75791
75868: POP
75869: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
75870: LD_VAR 0 5
75874: PUSH
75875: LD_INT 0
75877: EQUAL
75878: PUSH
75879: LD_VAR 0 5
75883: PUSH
75884: LD_EXP 99
75888: PUSH
75889: LD_VAR 0 2
75893: ARRAY
75894: LESSEQUAL
75895: OR
75896: IFFALSE 75900
// continue ;
75898: GO 75150
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
75900: LD_ADDR_VAR 0 6
75904: PUSH
75905: LD_EXP 59
75909: PUSH
75910: LD_VAR 0 2
75914: ARRAY
75915: PPUSH
75916: LD_INT 25
75918: PUSH
75919: LD_INT 3
75921: PUSH
75922: EMPTY
75923: LIST
75924: LIST
75925: PPUSH
75926: CALL_OW 72
75930: PUSH
75931: LD_EXP 99
75935: PUSH
75936: LD_VAR 0 2
75940: ARRAY
75941: DIFF
75942: PPUSH
75943: LD_INT 3
75945: PPUSH
75946: CALL 49983 0 2
75950: ST_TO_ADDR
// for j in tmp do
75951: LD_ADDR_VAR 0 3
75955: PUSH
75956: LD_VAR 0 6
75960: PUSH
75961: FOR_IN
75962: IFFALSE 75997
// if GetTag ( j ) > 0 then
75964: LD_VAR 0 3
75968: PPUSH
75969: CALL_OW 110
75973: PUSH
75974: LD_INT 0
75976: GREATER
75977: IFFALSE 75995
// tmp := tmp diff j ;
75979: LD_ADDR_VAR 0 6
75983: PUSH
75984: LD_VAR 0 6
75988: PUSH
75989: LD_VAR 0 3
75993: DIFF
75994: ST_TO_ADDR
75995: GO 75961
75997: POP
75998: POP
// if not tmp then
75999: LD_VAR 0 6
76003: NOT
76004: IFFALSE 76008
// continue ;
76006: GO 75150
// if places then
76008: LD_VAR 0 5
76012: IFFALSE 76071
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
76014: LD_ADDR_EXP 99
76018: PUSH
76019: LD_EXP 99
76023: PPUSH
76024: LD_VAR 0 2
76028: PPUSH
76029: LD_EXP 99
76033: PUSH
76034: LD_VAR 0 2
76038: ARRAY
76039: PUSH
76040: LD_VAR 0 6
76044: PUSH
76045: LD_INT 1
76047: ARRAY
76048: UNION
76049: PPUSH
76050: CALL_OW 1
76054: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
76055: LD_VAR 0 6
76059: PUSH
76060: LD_INT 1
76062: ARRAY
76063: PPUSH
76064: LD_INT 126
76066: PPUSH
76067: CALL_OW 109
// end ; end ;
76071: GO 75150
76073: POP
76074: POP
// end ;
76075: LD_VAR 0 1
76079: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
76080: LD_INT 0
76082: PPUSH
76083: PPUSH
76084: PPUSH
76085: PPUSH
76086: PPUSH
76087: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
76088: LD_VAR 0 1
76092: NOT
76093: PUSH
76094: LD_VAR 0 2
76098: NOT
76099: OR
76100: PUSH
76101: LD_VAR 0 3
76105: NOT
76106: OR
76107: PUSH
76108: LD_VAR 0 4
76112: PUSH
76113: LD_INT 1
76115: PUSH
76116: LD_INT 2
76118: PUSH
76119: LD_INT 3
76121: PUSH
76122: LD_INT 4
76124: PUSH
76125: LD_INT 5
76127: PUSH
76128: LD_INT 8
76130: PUSH
76131: LD_INT 9
76133: PUSH
76134: LD_INT 15
76136: PUSH
76137: LD_INT 16
76139: PUSH
76140: EMPTY
76141: LIST
76142: LIST
76143: LIST
76144: LIST
76145: LIST
76146: LIST
76147: LIST
76148: LIST
76149: LIST
76150: IN
76151: NOT
76152: OR
76153: IFFALSE 76157
// exit ;
76155: GO 77057
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
76157: LD_ADDR_VAR 0 2
76161: PUSH
76162: LD_VAR 0 2
76166: PPUSH
76167: LD_INT 21
76169: PUSH
76170: LD_INT 3
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: PUSH
76177: LD_INT 24
76179: PUSH
76180: LD_INT 250
76182: PUSH
76183: EMPTY
76184: LIST
76185: LIST
76186: PUSH
76187: EMPTY
76188: LIST
76189: LIST
76190: PPUSH
76191: CALL_OW 72
76195: ST_TO_ADDR
// case class of 1 , 15 :
76196: LD_VAR 0 4
76200: PUSH
76201: LD_INT 1
76203: DOUBLE
76204: EQUAL
76205: IFTRUE 76215
76207: LD_INT 15
76209: DOUBLE
76210: EQUAL
76211: IFTRUE 76215
76213: GO 76300
76215: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
76216: LD_ADDR_VAR 0 8
76220: PUSH
76221: LD_VAR 0 2
76225: PPUSH
76226: LD_INT 2
76228: PUSH
76229: LD_INT 30
76231: PUSH
76232: LD_INT 32
76234: PUSH
76235: EMPTY
76236: LIST
76237: LIST
76238: PUSH
76239: LD_INT 30
76241: PUSH
76242: LD_INT 31
76244: PUSH
76245: EMPTY
76246: LIST
76247: LIST
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: LIST
76253: PPUSH
76254: CALL_OW 72
76258: PUSH
76259: LD_VAR 0 2
76263: PPUSH
76264: LD_INT 2
76266: PUSH
76267: LD_INT 30
76269: PUSH
76270: LD_INT 4
76272: PUSH
76273: EMPTY
76274: LIST
76275: LIST
76276: PUSH
76277: LD_INT 30
76279: PUSH
76280: LD_INT 5
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: PUSH
76287: EMPTY
76288: LIST
76289: LIST
76290: LIST
76291: PPUSH
76292: CALL_OW 72
76296: ADD
76297: ST_TO_ADDR
76298: GO 76546
76300: LD_INT 2
76302: DOUBLE
76303: EQUAL
76304: IFTRUE 76314
76306: LD_INT 16
76308: DOUBLE
76309: EQUAL
76310: IFTRUE 76314
76312: GO 76360
76314: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
76315: LD_ADDR_VAR 0 8
76319: PUSH
76320: LD_VAR 0 2
76324: PPUSH
76325: LD_INT 2
76327: PUSH
76328: LD_INT 30
76330: PUSH
76331: LD_INT 0
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PUSH
76338: LD_INT 30
76340: PUSH
76341: LD_INT 1
76343: PUSH
76344: EMPTY
76345: LIST
76346: LIST
76347: PUSH
76348: EMPTY
76349: LIST
76350: LIST
76351: LIST
76352: PPUSH
76353: CALL_OW 72
76357: ST_TO_ADDR
76358: GO 76546
76360: LD_INT 3
76362: DOUBLE
76363: EQUAL
76364: IFTRUE 76368
76366: GO 76414
76368: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
76369: LD_ADDR_VAR 0 8
76373: PUSH
76374: LD_VAR 0 2
76378: PPUSH
76379: LD_INT 2
76381: PUSH
76382: LD_INT 30
76384: PUSH
76385: LD_INT 2
76387: PUSH
76388: EMPTY
76389: LIST
76390: LIST
76391: PUSH
76392: LD_INT 30
76394: PUSH
76395: LD_INT 3
76397: PUSH
76398: EMPTY
76399: LIST
76400: LIST
76401: PUSH
76402: EMPTY
76403: LIST
76404: LIST
76405: LIST
76406: PPUSH
76407: CALL_OW 72
76411: ST_TO_ADDR
76412: GO 76546
76414: LD_INT 4
76416: DOUBLE
76417: EQUAL
76418: IFTRUE 76422
76420: GO 76479
76422: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
76423: LD_ADDR_VAR 0 8
76427: PUSH
76428: LD_VAR 0 2
76432: PPUSH
76433: LD_INT 2
76435: PUSH
76436: LD_INT 30
76438: PUSH
76439: LD_INT 6
76441: PUSH
76442: EMPTY
76443: LIST
76444: LIST
76445: PUSH
76446: LD_INT 30
76448: PUSH
76449: LD_INT 7
76451: PUSH
76452: EMPTY
76453: LIST
76454: LIST
76455: PUSH
76456: LD_INT 30
76458: PUSH
76459: LD_INT 8
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: LIST
76470: LIST
76471: PPUSH
76472: CALL_OW 72
76476: ST_TO_ADDR
76477: GO 76546
76479: LD_INT 5
76481: DOUBLE
76482: EQUAL
76483: IFTRUE 76499
76485: LD_INT 8
76487: DOUBLE
76488: EQUAL
76489: IFTRUE 76499
76491: LD_INT 9
76493: DOUBLE
76494: EQUAL
76495: IFTRUE 76499
76497: GO 76545
76499: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
76500: LD_ADDR_VAR 0 8
76504: PUSH
76505: LD_VAR 0 2
76509: PPUSH
76510: LD_INT 2
76512: PUSH
76513: LD_INT 30
76515: PUSH
76516: LD_INT 4
76518: PUSH
76519: EMPTY
76520: LIST
76521: LIST
76522: PUSH
76523: LD_INT 30
76525: PUSH
76526: LD_INT 5
76528: PUSH
76529: EMPTY
76530: LIST
76531: LIST
76532: PUSH
76533: EMPTY
76534: LIST
76535: LIST
76536: LIST
76537: PPUSH
76538: CALL_OW 72
76542: ST_TO_ADDR
76543: GO 76546
76545: POP
// if not tmp then
76546: LD_VAR 0 8
76550: NOT
76551: IFFALSE 76555
// exit ;
76553: GO 77057
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
76555: LD_VAR 0 4
76559: PUSH
76560: LD_INT 1
76562: PUSH
76563: LD_INT 15
76565: PUSH
76566: EMPTY
76567: LIST
76568: LIST
76569: IN
76570: PUSH
76571: LD_EXP 68
76575: PUSH
76576: LD_VAR 0 1
76580: ARRAY
76581: AND
76582: IFFALSE 76738
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
76584: LD_ADDR_VAR 0 9
76588: PUSH
76589: LD_EXP 68
76593: PUSH
76594: LD_VAR 0 1
76598: ARRAY
76599: PUSH
76600: LD_INT 1
76602: ARRAY
76603: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
76604: LD_VAR 0 9
76608: PUSH
76609: LD_EXP 69
76613: PUSH
76614: LD_VAR 0 1
76618: ARRAY
76619: IN
76620: NOT
76621: IFFALSE 76736
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
76623: LD_ADDR_EXP 69
76627: PUSH
76628: LD_EXP 69
76632: PPUSH
76633: LD_VAR 0 1
76637: PUSH
76638: LD_EXP 69
76642: PUSH
76643: LD_VAR 0 1
76647: ARRAY
76648: PUSH
76649: LD_INT 1
76651: PLUS
76652: PUSH
76653: EMPTY
76654: LIST
76655: LIST
76656: PPUSH
76657: LD_VAR 0 9
76661: PPUSH
76662: CALL 19726 0 3
76666: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
76667: LD_ADDR_EXP 68
76671: PUSH
76672: LD_EXP 68
76676: PPUSH
76677: LD_VAR 0 1
76681: PPUSH
76682: LD_EXP 68
76686: PUSH
76687: LD_VAR 0 1
76691: ARRAY
76692: PUSH
76693: LD_VAR 0 9
76697: DIFF
76698: PPUSH
76699: CALL_OW 1
76703: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
76704: LD_VAR 0 3
76708: PPUSH
76709: LD_EXP 69
76713: PUSH
76714: LD_VAR 0 1
76718: ARRAY
76719: PUSH
76720: LD_EXP 69
76724: PUSH
76725: LD_VAR 0 1
76729: ARRAY
76730: ARRAY
76731: PPUSH
76732: CALL_OW 120
// end ; exit ;
76736: GO 77057
// end ; if tmp > 1 then
76738: LD_VAR 0 8
76742: PUSH
76743: LD_INT 1
76745: GREATER
76746: IFFALSE 76850
// for i = 2 to tmp do
76748: LD_ADDR_VAR 0 6
76752: PUSH
76753: DOUBLE
76754: LD_INT 2
76756: DEC
76757: ST_TO_ADDR
76758: LD_VAR 0 8
76762: PUSH
76763: FOR_TO
76764: IFFALSE 76848
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
76766: LD_VAR 0 8
76770: PUSH
76771: LD_VAR 0 6
76775: ARRAY
76776: PPUSH
76777: CALL_OW 461
76781: PUSH
76782: LD_INT 6
76784: EQUAL
76785: IFFALSE 76846
// begin x := tmp [ i ] ;
76787: LD_ADDR_VAR 0 9
76791: PUSH
76792: LD_VAR 0 8
76796: PUSH
76797: LD_VAR 0 6
76801: ARRAY
76802: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
76803: LD_ADDR_VAR 0 8
76807: PUSH
76808: LD_VAR 0 8
76812: PPUSH
76813: LD_VAR 0 6
76817: PPUSH
76818: CALL_OW 3
76822: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
76823: LD_ADDR_VAR 0 8
76827: PUSH
76828: LD_VAR 0 8
76832: PPUSH
76833: LD_INT 1
76835: PPUSH
76836: LD_VAR 0 9
76840: PPUSH
76841: CALL_OW 2
76845: ST_TO_ADDR
// end ;
76846: GO 76763
76848: POP
76849: POP
// for i in tmp do
76850: LD_ADDR_VAR 0 6
76854: PUSH
76855: LD_VAR 0 8
76859: PUSH
76860: FOR_IN
76861: IFFALSE 76930
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
76863: LD_VAR 0 6
76867: PPUSH
76868: CALL_OW 313
76872: PUSH
76873: LD_INT 6
76875: LESS
76876: PUSH
76877: LD_VAR 0 6
76881: PPUSH
76882: CALL_OW 266
76886: PUSH
76887: LD_INT 31
76889: PUSH
76890: LD_INT 32
76892: PUSH
76893: EMPTY
76894: LIST
76895: LIST
76896: IN
76897: NOT
76898: AND
76899: PUSH
76900: LD_VAR 0 6
76904: PPUSH
76905: CALL_OW 313
76909: PUSH
76910: LD_INT 0
76912: EQUAL
76913: OR
76914: IFFALSE 76928
// begin j := i ;
76916: LD_ADDR_VAR 0 7
76920: PUSH
76921: LD_VAR 0 6
76925: ST_TO_ADDR
// break ;
76926: GO 76930
// end ; end ;
76928: GO 76860
76930: POP
76931: POP
// if j then
76932: LD_VAR 0 7
76936: IFFALSE 76954
// ComEnterUnit ( unit , j ) else
76938: LD_VAR 0 3
76942: PPUSH
76943: LD_VAR 0 7
76947: PPUSH
76948: CALL_OW 120
76952: GO 77057
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76954: LD_ADDR_VAR 0 10
76958: PUSH
76959: LD_VAR 0 2
76963: PPUSH
76964: LD_INT 2
76966: PUSH
76967: LD_INT 30
76969: PUSH
76970: LD_INT 0
76972: PUSH
76973: EMPTY
76974: LIST
76975: LIST
76976: PUSH
76977: LD_INT 30
76979: PUSH
76980: LD_INT 1
76982: PUSH
76983: EMPTY
76984: LIST
76985: LIST
76986: PUSH
76987: EMPTY
76988: LIST
76989: LIST
76990: LIST
76991: PPUSH
76992: CALL_OW 72
76996: ST_TO_ADDR
// if depot then
76997: LD_VAR 0 10
77001: IFFALSE 77057
// begin depot := NearestUnitToUnit ( depot , unit ) ;
77003: LD_ADDR_VAR 0 10
77007: PUSH
77008: LD_VAR 0 10
77012: PPUSH
77013: LD_VAR 0 3
77017: PPUSH
77018: CALL_OW 74
77022: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
77023: LD_VAR 0 3
77027: PPUSH
77028: LD_VAR 0 10
77032: PPUSH
77033: CALL_OW 296
77037: PUSH
77038: LD_INT 10
77040: GREATER
77041: IFFALSE 77057
// ComStandNearbyBuilding ( unit , depot ) ;
77043: LD_VAR 0 3
77047: PPUSH
77048: LD_VAR 0 10
77052: PPUSH
77053: CALL 16304 0 2
// end ; end ; end ;
77057: LD_VAR 0 5
77061: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
77062: LD_INT 0
77064: PPUSH
77065: PPUSH
77066: PPUSH
77067: PPUSH
// if not mc_bases then
77068: LD_EXP 59
77072: NOT
77073: IFFALSE 77077
// exit ;
77075: GO 77316
// for i = 1 to mc_bases do
77077: LD_ADDR_VAR 0 2
77081: PUSH
77082: DOUBLE
77083: LD_INT 1
77085: DEC
77086: ST_TO_ADDR
77087: LD_EXP 59
77091: PUSH
77092: FOR_TO
77093: IFFALSE 77314
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
77095: LD_ADDR_VAR 0 4
77099: PUSH
77100: LD_EXP 59
77104: PUSH
77105: LD_VAR 0 2
77109: ARRAY
77110: PPUSH
77111: LD_INT 21
77113: PUSH
77114: LD_INT 1
77116: PUSH
77117: EMPTY
77118: LIST
77119: LIST
77120: PPUSH
77121: CALL_OW 72
77125: PUSH
77126: LD_EXP 88
77130: PUSH
77131: LD_VAR 0 2
77135: ARRAY
77136: UNION
77137: ST_TO_ADDR
// if not tmp then
77138: LD_VAR 0 4
77142: NOT
77143: IFFALSE 77147
// continue ;
77145: GO 77092
// for j in tmp do
77147: LD_ADDR_VAR 0 3
77151: PUSH
77152: LD_VAR 0 4
77156: PUSH
77157: FOR_IN
77158: IFFALSE 77310
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
77160: LD_VAR 0 3
77164: PPUSH
77165: CALL_OW 110
77169: NOT
77170: PUSH
77171: LD_VAR 0 3
77175: PPUSH
77176: CALL_OW 314
77180: NOT
77181: AND
77182: PUSH
77183: LD_VAR 0 3
77187: PPUSH
77188: CALL_OW 311
77192: NOT
77193: AND
77194: PUSH
77195: LD_VAR 0 3
77199: PPUSH
77200: CALL_OW 310
77204: NOT
77205: AND
77206: PUSH
77207: LD_VAR 0 3
77211: PUSH
77212: LD_EXP 62
77216: PUSH
77217: LD_VAR 0 2
77221: ARRAY
77222: PUSH
77223: LD_INT 1
77225: ARRAY
77226: IN
77227: NOT
77228: AND
77229: PUSH
77230: LD_VAR 0 3
77234: PUSH
77235: LD_EXP 62
77239: PUSH
77240: LD_VAR 0 2
77244: ARRAY
77245: PUSH
77246: LD_INT 2
77248: ARRAY
77249: IN
77250: NOT
77251: AND
77252: PUSH
77253: LD_VAR 0 3
77257: PUSH
77258: LD_EXP 71
77262: PUSH
77263: LD_VAR 0 2
77267: ARRAY
77268: IN
77269: NOT
77270: AND
77271: IFFALSE 77308
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
77273: LD_VAR 0 2
77277: PPUSH
77278: LD_EXP 59
77282: PUSH
77283: LD_VAR 0 2
77287: ARRAY
77288: PPUSH
77289: LD_VAR 0 3
77293: PPUSH
77294: LD_VAR 0 3
77298: PPUSH
77299: CALL_OW 257
77303: PPUSH
77304: CALL 76080 0 4
// end ;
77308: GO 77157
77310: POP
77311: POP
// end ;
77312: GO 77092
77314: POP
77315: POP
// end ;
77316: LD_VAR 0 1
77320: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
77321: LD_INT 0
77323: PPUSH
77324: PPUSH
77325: PPUSH
77326: PPUSH
77327: PPUSH
77328: PPUSH
// if not mc_bases [ base ] then
77329: LD_EXP 59
77333: PUSH
77334: LD_VAR 0 1
77338: ARRAY
77339: NOT
77340: IFFALSE 77344
// exit ;
77342: GO 77526
// tmp := [ ] ;
77344: LD_ADDR_VAR 0 6
77348: PUSH
77349: EMPTY
77350: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
77351: LD_ADDR_VAR 0 7
77355: PUSH
77356: LD_VAR 0 3
77360: PPUSH
77361: LD_INT 0
77363: PPUSH
77364: CALL_OW 517
77368: ST_TO_ADDR
// if not list then
77369: LD_VAR 0 7
77373: NOT
77374: IFFALSE 77378
// exit ;
77376: GO 77526
// for i = 1 to amount do
77378: LD_ADDR_VAR 0 5
77382: PUSH
77383: DOUBLE
77384: LD_INT 1
77386: DEC
77387: ST_TO_ADDR
77388: LD_VAR 0 2
77392: PUSH
77393: FOR_TO
77394: IFFALSE 77474
// begin x := rand ( 1 , list [ 1 ] ) ;
77396: LD_ADDR_VAR 0 8
77400: PUSH
77401: LD_INT 1
77403: PPUSH
77404: LD_VAR 0 7
77408: PUSH
77409: LD_INT 1
77411: ARRAY
77412: PPUSH
77413: CALL_OW 12
77417: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
77418: LD_ADDR_VAR 0 6
77422: PUSH
77423: LD_VAR 0 6
77427: PPUSH
77428: LD_VAR 0 5
77432: PPUSH
77433: LD_VAR 0 7
77437: PUSH
77438: LD_INT 1
77440: ARRAY
77441: PUSH
77442: LD_VAR 0 8
77446: ARRAY
77447: PUSH
77448: LD_VAR 0 7
77452: PUSH
77453: LD_INT 2
77455: ARRAY
77456: PUSH
77457: LD_VAR 0 8
77461: ARRAY
77462: PUSH
77463: EMPTY
77464: LIST
77465: LIST
77466: PPUSH
77467: CALL_OW 1
77471: ST_TO_ADDR
// end ;
77472: GO 77393
77474: POP
77475: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
77476: LD_ADDR_EXP 72
77480: PUSH
77481: LD_EXP 72
77485: PPUSH
77486: LD_VAR 0 1
77490: PPUSH
77491: LD_VAR 0 6
77495: PPUSH
77496: CALL_OW 1
77500: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
77501: LD_ADDR_EXP 74
77505: PUSH
77506: LD_EXP 74
77510: PPUSH
77511: LD_VAR 0 1
77515: PPUSH
77516: LD_VAR 0 3
77520: PPUSH
77521: CALL_OW 1
77525: ST_TO_ADDR
// end ;
77526: LD_VAR 0 4
77530: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
77531: LD_INT 0
77533: PPUSH
// if not mc_bases [ base ] then
77534: LD_EXP 59
77538: PUSH
77539: LD_VAR 0 1
77543: ARRAY
77544: NOT
77545: IFFALSE 77549
// exit ;
77547: GO 77574
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
77549: LD_ADDR_EXP 64
77553: PUSH
77554: LD_EXP 64
77558: PPUSH
77559: LD_VAR 0 1
77563: PPUSH
77564: LD_VAR 0 2
77568: PPUSH
77569: CALL_OW 1
77573: ST_TO_ADDR
// end ;
77574: LD_VAR 0 3
77578: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
77579: LD_INT 0
77581: PPUSH
// if not mc_bases [ base ] then
77582: LD_EXP 59
77586: PUSH
77587: LD_VAR 0 1
77591: ARRAY
77592: NOT
77593: IFFALSE 77597
// exit ;
77595: GO 77634
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
77597: LD_ADDR_EXP 64
77601: PUSH
77602: LD_EXP 64
77606: PPUSH
77607: LD_VAR 0 1
77611: PPUSH
77612: LD_EXP 64
77616: PUSH
77617: LD_VAR 0 1
77621: ARRAY
77622: PUSH
77623: LD_VAR 0 2
77627: UNION
77628: PPUSH
77629: CALL_OW 1
77633: ST_TO_ADDR
// end ;
77634: LD_VAR 0 3
77638: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
77639: LD_INT 0
77641: PPUSH
// if not mc_bases [ base ] then
77642: LD_EXP 59
77646: PUSH
77647: LD_VAR 0 1
77651: ARRAY
77652: NOT
77653: IFFALSE 77657
// exit ;
77655: GO 77682
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
77657: LD_ADDR_EXP 80
77661: PUSH
77662: LD_EXP 80
77666: PPUSH
77667: LD_VAR 0 1
77671: PPUSH
77672: LD_VAR 0 2
77676: PPUSH
77677: CALL_OW 1
77681: ST_TO_ADDR
// end ;
77682: LD_VAR 0 3
77686: RET
// export function MC_InsertProduceList ( base , components ) ; begin
77687: LD_INT 0
77689: PPUSH
// if not mc_bases [ base ] then
77690: LD_EXP 59
77694: PUSH
77695: LD_VAR 0 1
77699: ARRAY
77700: NOT
77701: IFFALSE 77705
// exit ;
77703: GO 77742
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
77705: LD_ADDR_EXP 80
77709: PUSH
77710: LD_EXP 80
77714: PPUSH
77715: LD_VAR 0 1
77719: PPUSH
77720: LD_EXP 80
77724: PUSH
77725: LD_VAR 0 1
77729: ARRAY
77730: PUSH
77731: LD_VAR 0 2
77735: ADD
77736: PPUSH
77737: CALL_OW 1
77741: ST_TO_ADDR
// end ;
77742: LD_VAR 0 3
77746: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
77747: LD_INT 0
77749: PPUSH
// if not mc_bases [ base ] then
77750: LD_EXP 59
77754: PUSH
77755: LD_VAR 0 1
77759: ARRAY
77760: NOT
77761: IFFALSE 77765
// exit ;
77763: GO 77819
// mc_defender := Replace ( mc_defender , base , deflist ) ;
77765: LD_ADDR_EXP 81
77769: PUSH
77770: LD_EXP 81
77774: PPUSH
77775: LD_VAR 0 1
77779: PPUSH
77780: LD_VAR 0 2
77784: PPUSH
77785: CALL_OW 1
77789: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
77790: LD_ADDR_EXP 70
77794: PUSH
77795: LD_EXP 70
77799: PPUSH
77800: LD_VAR 0 1
77804: PPUSH
77805: LD_VAR 0 2
77809: PUSH
77810: LD_INT 0
77812: PLUS
77813: PPUSH
77814: CALL_OW 1
77818: ST_TO_ADDR
// end ;
77819: LD_VAR 0 3
77823: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
77824: LD_INT 0
77826: PPUSH
// if not mc_bases [ base ] then
77827: LD_EXP 59
77831: PUSH
77832: LD_VAR 0 1
77836: ARRAY
77837: NOT
77838: IFFALSE 77842
// exit ;
77840: GO 77867
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
77842: LD_ADDR_EXP 70
77846: PUSH
77847: LD_EXP 70
77851: PPUSH
77852: LD_VAR 0 1
77856: PPUSH
77857: LD_VAR 0 2
77861: PPUSH
77862: CALL_OW 1
77866: ST_TO_ADDR
// end ;
77867: LD_VAR 0 3
77871: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
77872: LD_INT 0
77874: PPUSH
77875: PPUSH
77876: PPUSH
77877: PPUSH
// if not mc_bases [ base ] then
77878: LD_EXP 59
77882: PUSH
77883: LD_VAR 0 1
77887: ARRAY
77888: NOT
77889: IFFALSE 77893
// exit ;
77891: GO 77958
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
77893: LD_ADDR_EXP 79
77897: PUSH
77898: LD_EXP 79
77902: PPUSH
77903: LD_VAR 0 1
77907: PUSH
77908: LD_EXP 79
77912: PUSH
77913: LD_VAR 0 1
77917: ARRAY
77918: PUSH
77919: LD_INT 1
77921: PLUS
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PPUSH
77927: LD_VAR 0 1
77931: PUSH
77932: LD_VAR 0 2
77936: PUSH
77937: LD_VAR 0 3
77941: PUSH
77942: LD_VAR 0 4
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: LIST
77951: LIST
77952: PPUSH
77953: CALL 19726 0 3
77957: ST_TO_ADDR
// end ;
77958: LD_VAR 0 5
77962: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
77963: LD_INT 0
77965: PPUSH
// if not mc_bases [ base ] then
77966: LD_EXP 59
77970: PUSH
77971: LD_VAR 0 1
77975: ARRAY
77976: NOT
77977: IFFALSE 77981
// exit ;
77979: GO 78006
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
77981: LD_ADDR_EXP 96
77985: PUSH
77986: LD_EXP 96
77990: PPUSH
77991: LD_VAR 0 1
77995: PPUSH
77996: LD_VAR 0 2
78000: PPUSH
78001: CALL_OW 1
78005: ST_TO_ADDR
// end ;
78006: LD_VAR 0 3
78010: RET
// export function MC_GetMinesField ( base ) ; begin
78011: LD_INT 0
78013: PPUSH
// result := mc_mines [ base ] ;
78014: LD_ADDR_VAR 0 2
78018: PUSH
78019: LD_EXP 72
78023: PUSH
78024: LD_VAR 0 1
78028: ARRAY
78029: ST_TO_ADDR
// end ;
78030: LD_VAR 0 2
78034: RET
// export function MC_GetProduceList ( base ) ; begin
78035: LD_INT 0
78037: PPUSH
// result := mc_produce [ base ] ;
78038: LD_ADDR_VAR 0 2
78042: PUSH
78043: LD_EXP 80
78047: PUSH
78048: LD_VAR 0 1
78052: ARRAY
78053: ST_TO_ADDR
// end ;
78054: LD_VAR 0 2
78058: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
78059: LD_INT 0
78061: PPUSH
78062: PPUSH
// if not mc_bases then
78063: LD_EXP 59
78067: NOT
78068: IFFALSE 78072
// exit ;
78070: GO 78137
// if mc_bases [ base ] then
78072: LD_EXP 59
78076: PUSH
78077: LD_VAR 0 1
78081: ARRAY
78082: IFFALSE 78137
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78084: LD_ADDR_VAR 0 3
78088: PUSH
78089: LD_EXP 59
78093: PUSH
78094: LD_VAR 0 1
78098: ARRAY
78099: PPUSH
78100: LD_INT 30
78102: PUSH
78103: LD_VAR 0 2
78107: PUSH
78108: EMPTY
78109: LIST
78110: LIST
78111: PPUSH
78112: CALL_OW 72
78116: ST_TO_ADDR
// if result then
78117: LD_VAR 0 3
78121: IFFALSE 78137
// result := result [ 1 ] ;
78123: LD_ADDR_VAR 0 3
78127: PUSH
78128: LD_VAR 0 3
78132: PUSH
78133: LD_INT 1
78135: ARRAY
78136: ST_TO_ADDR
// end ; end ;
78137: LD_VAR 0 3
78141: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
78142: LD_INT 0
78144: PPUSH
78145: PPUSH
// if not mc_bases then
78146: LD_EXP 59
78150: NOT
78151: IFFALSE 78155
// exit ;
78153: GO 78200
// if mc_bases [ base ] then
78155: LD_EXP 59
78159: PUSH
78160: LD_VAR 0 1
78164: ARRAY
78165: IFFALSE 78200
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78167: LD_ADDR_VAR 0 3
78171: PUSH
78172: LD_EXP 59
78176: PUSH
78177: LD_VAR 0 1
78181: ARRAY
78182: PPUSH
78183: LD_INT 30
78185: PUSH
78186: LD_VAR 0 2
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: PPUSH
78195: CALL_OW 72
78199: ST_TO_ADDR
// end ;
78200: LD_VAR 0 3
78204: RET
// export function MC_SetTame ( base , area ) ; begin
78205: LD_INT 0
78207: PPUSH
// if not mc_bases or not base then
78208: LD_EXP 59
78212: NOT
78213: PUSH
78214: LD_VAR 0 1
78218: NOT
78219: OR
78220: IFFALSE 78224
// exit ;
78222: GO 78249
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
78224: LD_ADDR_EXP 87
78228: PUSH
78229: LD_EXP 87
78233: PPUSH
78234: LD_VAR 0 1
78238: PPUSH
78239: LD_VAR 0 2
78243: PPUSH
78244: CALL_OW 1
78248: ST_TO_ADDR
// end ;
78249: LD_VAR 0 3
78253: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
78254: LD_INT 0
78256: PPUSH
78257: PPUSH
// if not mc_bases or not base then
78258: LD_EXP 59
78262: NOT
78263: PUSH
78264: LD_VAR 0 1
78268: NOT
78269: OR
78270: IFFALSE 78274
// exit ;
78272: GO 78376
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78274: LD_ADDR_VAR 0 4
78278: PUSH
78279: LD_EXP 59
78283: PUSH
78284: LD_VAR 0 1
78288: ARRAY
78289: PPUSH
78290: LD_INT 30
78292: PUSH
78293: LD_VAR 0 2
78297: PUSH
78298: EMPTY
78299: LIST
78300: LIST
78301: PPUSH
78302: CALL_OW 72
78306: ST_TO_ADDR
// if not tmp then
78307: LD_VAR 0 4
78311: NOT
78312: IFFALSE 78316
// exit ;
78314: GO 78376
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
78316: LD_ADDR_EXP 91
78320: PUSH
78321: LD_EXP 91
78325: PPUSH
78326: LD_VAR 0 1
78330: PPUSH
78331: LD_EXP 91
78335: PUSH
78336: LD_VAR 0 1
78340: ARRAY
78341: PPUSH
78342: LD_EXP 91
78346: PUSH
78347: LD_VAR 0 1
78351: ARRAY
78352: PUSH
78353: LD_INT 1
78355: PLUS
78356: PPUSH
78357: LD_VAR 0 4
78361: PUSH
78362: LD_INT 1
78364: ARRAY
78365: PPUSH
78366: CALL_OW 2
78370: PPUSH
78371: CALL_OW 1
78375: ST_TO_ADDR
// end ;
78376: LD_VAR 0 3
78380: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
78381: LD_INT 0
78383: PPUSH
78384: PPUSH
// if not mc_bases or not base or not kinds then
78385: LD_EXP 59
78389: NOT
78390: PUSH
78391: LD_VAR 0 1
78395: NOT
78396: OR
78397: PUSH
78398: LD_VAR 0 2
78402: NOT
78403: OR
78404: IFFALSE 78408
// exit ;
78406: GO 78469
// for i in kinds do
78408: LD_ADDR_VAR 0 4
78412: PUSH
78413: LD_VAR 0 2
78417: PUSH
78418: FOR_IN
78419: IFFALSE 78467
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
78421: LD_ADDR_EXP 93
78425: PUSH
78426: LD_EXP 93
78430: PPUSH
78431: LD_VAR 0 1
78435: PUSH
78436: LD_EXP 93
78440: PUSH
78441: LD_VAR 0 1
78445: ARRAY
78446: PUSH
78447: LD_INT 1
78449: PLUS
78450: PUSH
78451: EMPTY
78452: LIST
78453: LIST
78454: PPUSH
78455: LD_VAR 0 4
78459: PPUSH
78460: CALL 19726 0 3
78464: ST_TO_ADDR
78465: GO 78418
78467: POP
78468: POP
// end ;
78469: LD_VAR 0 3
78473: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
78474: LD_INT 0
78476: PPUSH
// if not mc_bases or not base or not areas then
78477: LD_EXP 59
78481: NOT
78482: PUSH
78483: LD_VAR 0 1
78487: NOT
78488: OR
78489: PUSH
78490: LD_VAR 0 2
78494: NOT
78495: OR
78496: IFFALSE 78500
// exit ;
78498: GO 78525
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
78500: LD_ADDR_EXP 77
78504: PUSH
78505: LD_EXP 77
78509: PPUSH
78510: LD_VAR 0 1
78514: PPUSH
78515: LD_VAR 0 2
78519: PPUSH
78520: CALL_OW 1
78524: ST_TO_ADDR
// end ;
78525: LD_VAR 0 3
78529: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
78530: LD_INT 0
78532: PPUSH
// if not mc_bases or not base or not teleports_exit then
78533: LD_EXP 59
78537: NOT
78538: PUSH
78539: LD_VAR 0 1
78543: NOT
78544: OR
78545: PUSH
78546: LD_VAR 0 2
78550: NOT
78551: OR
78552: IFFALSE 78556
// exit ;
78554: GO 78581
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
78556: LD_ADDR_EXP 94
78560: PUSH
78561: LD_EXP 94
78565: PPUSH
78566: LD_VAR 0 1
78570: PPUSH
78571: LD_VAR 0 2
78575: PPUSH
78576: CALL_OW 1
78580: ST_TO_ADDR
// end ;
78581: LD_VAR 0 3
78585: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
78586: LD_INT 0
78588: PPUSH
78589: PPUSH
78590: PPUSH
// if not mc_bases or not base or not ext_list then
78591: LD_EXP 59
78595: NOT
78596: PUSH
78597: LD_VAR 0 1
78601: NOT
78602: OR
78603: PUSH
78604: LD_VAR 0 5
78608: NOT
78609: OR
78610: IFFALSE 78614
// exit ;
78612: GO 78787
// tmp := GetFacExtXYD ( x , y , d ) ;
78614: LD_ADDR_VAR 0 8
78618: PUSH
78619: LD_VAR 0 2
78623: PPUSH
78624: LD_VAR 0 3
78628: PPUSH
78629: LD_VAR 0 4
78633: PPUSH
78634: CALL 49113 0 3
78638: ST_TO_ADDR
// if not tmp then
78639: LD_VAR 0 8
78643: NOT
78644: IFFALSE 78648
// exit ;
78646: GO 78787
// for i in tmp do
78648: LD_ADDR_VAR 0 7
78652: PUSH
78653: LD_VAR 0 8
78657: PUSH
78658: FOR_IN
78659: IFFALSE 78785
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
78661: LD_ADDR_EXP 64
78665: PUSH
78666: LD_EXP 64
78670: PPUSH
78671: LD_VAR 0 1
78675: PPUSH
78676: LD_EXP 64
78680: PUSH
78681: LD_VAR 0 1
78685: ARRAY
78686: PPUSH
78687: LD_EXP 64
78691: PUSH
78692: LD_VAR 0 1
78696: ARRAY
78697: PUSH
78698: LD_INT 1
78700: PLUS
78701: PPUSH
78702: LD_VAR 0 5
78706: PUSH
78707: LD_INT 1
78709: ARRAY
78710: PUSH
78711: LD_VAR 0 7
78715: PUSH
78716: LD_INT 1
78718: ARRAY
78719: PUSH
78720: LD_VAR 0 7
78724: PUSH
78725: LD_INT 2
78727: ARRAY
78728: PUSH
78729: LD_VAR 0 7
78733: PUSH
78734: LD_INT 3
78736: ARRAY
78737: PUSH
78738: EMPTY
78739: LIST
78740: LIST
78741: LIST
78742: LIST
78743: PPUSH
78744: CALL_OW 2
78748: PPUSH
78749: CALL_OW 1
78753: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
78754: LD_ADDR_VAR 0 5
78758: PUSH
78759: LD_VAR 0 5
78763: PPUSH
78764: LD_INT 1
78766: PPUSH
78767: CALL_OW 3
78771: ST_TO_ADDR
// if not ext_list then
78772: LD_VAR 0 5
78776: NOT
78777: IFFALSE 78783
// exit ;
78779: POP
78780: POP
78781: GO 78787
// end ;
78783: GO 78658
78785: POP
78786: POP
// end ;
78787: LD_VAR 0 6
78791: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
78792: LD_INT 0
78794: PPUSH
// if not mc_bases or not base or not weapon_list then
78795: LD_EXP 59
78799: NOT
78800: PUSH
78801: LD_VAR 0 1
78805: NOT
78806: OR
78807: PUSH
78808: LD_VAR 0 2
78812: NOT
78813: OR
78814: IFFALSE 78818
// exit ;
78816: GO 78843
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
78818: LD_ADDR_EXP 98
78822: PUSH
78823: LD_EXP 98
78827: PPUSH
78828: LD_VAR 0 1
78832: PPUSH
78833: LD_VAR 0 2
78837: PPUSH
78838: CALL_OW 1
78842: ST_TO_ADDR
// end ;
78843: LD_VAR 0 3
78847: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
78848: LD_INT 0
78850: PPUSH
// if not mc_bases or not base or not tech_list then
78851: LD_EXP 59
78855: NOT
78856: PUSH
78857: LD_VAR 0 1
78861: NOT
78862: OR
78863: PUSH
78864: LD_VAR 0 2
78868: NOT
78869: OR
78870: IFFALSE 78874
// exit ;
78872: GO 78899
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
78874: LD_ADDR_EXP 86
78878: PUSH
78879: LD_EXP 86
78883: PPUSH
78884: LD_VAR 0 1
78888: PPUSH
78889: LD_VAR 0 2
78893: PPUSH
78894: CALL_OW 1
78898: ST_TO_ADDR
// end ;
78899: LD_VAR 0 3
78903: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
78904: LD_INT 0
78906: PPUSH
// if not mc_bases or not parking_area or not base then
78907: LD_EXP 59
78911: NOT
78912: PUSH
78913: LD_VAR 0 2
78917: NOT
78918: OR
78919: PUSH
78920: LD_VAR 0 1
78924: NOT
78925: OR
78926: IFFALSE 78930
// exit ;
78928: GO 78955
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
78930: LD_ADDR_EXP 83
78934: PUSH
78935: LD_EXP 83
78939: PPUSH
78940: LD_VAR 0 1
78944: PPUSH
78945: LD_VAR 0 2
78949: PPUSH
78950: CALL_OW 1
78954: ST_TO_ADDR
// end ;
78955: LD_VAR 0 3
78959: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
78960: LD_INT 0
78962: PPUSH
// if not mc_bases or not base or not scan_area then
78963: LD_EXP 59
78967: NOT
78968: PUSH
78969: LD_VAR 0 1
78973: NOT
78974: OR
78975: PUSH
78976: LD_VAR 0 2
78980: NOT
78981: OR
78982: IFFALSE 78986
// exit ;
78984: GO 79011
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
78986: LD_ADDR_EXP 84
78990: PUSH
78991: LD_EXP 84
78995: PPUSH
78996: LD_VAR 0 1
79000: PPUSH
79001: LD_VAR 0 2
79005: PPUSH
79006: CALL_OW 1
79010: ST_TO_ADDR
// end ;
79011: LD_VAR 0 3
79015: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
79016: LD_INT 0
79018: PPUSH
79019: PPUSH
// if not mc_bases or not base then
79020: LD_EXP 59
79024: NOT
79025: PUSH
79026: LD_VAR 0 1
79030: NOT
79031: OR
79032: IFFALSE 79036
// exit ;
79034: GO 79100
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
79036: LD_ADDR_VAR 0 3
79040: PUSH
79041: LD_INT 1
79043: PUSH
79044: LD_INT 2
79046: PUSH
79047: LD_INT 3
79049: PUSH
79050: LD_INT 4
79052: PUSH
79053: LD_INT 11
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: LIST
79060: LIST
79061: LIST
79062: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
79063: LD_ADDR_EXP 86
79067: PUSH
79068: LD_EXP 86
79072: PPUSH
79073: LD_VAR 0 1
79077: PPUSH
79078: LD_EXP 86
79082: PUSH
79083: LD_VAR 0 1
79087: ARRAY
79088: PUSH
79089: LD_VAR 0 3
79093: DIFF
79094: PPUSH
79095: CALL_OW 1
79099: ST_TO_ADDR
// end ;
79100: LD_VAR 0 2
79104: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
79105: LD_INT 0
79107: PPUSH
// result := mc_vehicles [ base ] ;
79108: LD_ADDR_VAR 0 3
79112: PUSH
79113: LD_EXP 78
79117: PUSH
79118: LD_VAR 0 1
79122: ARRAY
79123: ST_TO_ADDR
// if onlyCombat then
79124: LD_VAR 0 2
79128: IFFALSE 79306
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
79130: LD_ADDR_VAR 0 3
79134: PUSH
79135: LD_VAR 0 3
79139: PUSH
79140: LD_VAR 0 3
79144: PPUSH
79145: LD_INT 2
79147: PUSH
79148: LD_INT 34
79150: PUSH
79151: LD_INT 12
79153: PUSH
79154: EMPTY
79155: LIST
79156: LIST
79157: PUSH
79158: LD_INT 34
79160: PUSH
79161: LD_INT 51
79163: PUSH
79164: EMPTY
79165: LIST
79166: LIST
79167: PUSH
79168: LD_INT 34
79170: PUSH
79171: LD_EXP 104
79175: PUSH
79176: EMPTY
79177: LIST
79178: LIST
79179: PUSH
79180: LD_INT 34
79182: PUSH
79183: LD_INT 32
79185: PUSH
79186: EMPTY
79187: LIST
79188: LIST
79189: PUSH
79190: LD_INT 34
79192: PUSH
79193: LD_INT 13
79195: PUSH
79196: EMPTY
79197: LIST
79198: LIST
79199: PUSH
79200: LD_INT 34
79202: PUSH
79203: LD_INT 52
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: LD_INT 34
79212: PUSH
79213: LD_EXP 109
79217: PUSH
79218: EMPTY
79219: LIST
79220: LIST
79221: PUSH
79222: LD_INT 34
79224: PUSH
79225: LD_INT 14
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: PUSH
79232: LD_INT 34
79234: PUSH
79235: LD_INT 53
79237: PUSH
79238: EMPTY
79239: LIST
79240: LIST
79241: PUSH
79242: LD_INT 34
79244: PUSH
79245: LD_EXP 103
79249: PUSH
79250: EMPTY
79251: LIST
79252: LIST
79253: PUSH
79254: LD_INT 34
79256: PUSH
79257: LD_INT 31
79259: PUSH
79260: EMPTY
79261: LIST
79262: LIST
79263: PUSH
79264: LD_INT 34
79266: PUSH
79267: LD_INT 48
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: PUSH
79274: LD_INT 34
79276: PUSH
79277: LD_INT 8
79279: PUSH
79280: EMPTY
79281: LIST
79282: LIST
79283: PUSH
79284: EMPTY
79285: LIST
79286: LIST
79287: LIST
79288: LIST
79289: LIST
79290: LIST
79291: LIST
79292: LIST
79293: LIST
79294: LIST
79295: LIST
79296: LIST
79297: LIST
79298: LIST
79299: PPUSH
79300: CALL_OW 72
79304: DIFF
79305: ST_TO_ADDR
// end ; end_of_file
79306: LD_VAR 0 3
79310: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
79311: LD_INT 0
79313: PPUSH
79314: PPUSH
79315: PPUSH
// if not mc_bases or not skirmish then
79316: LD_EXP 59
79320: NOT
79321: PUSH
79322: LD_EXP 57
79326: NOT
79327: OR
79328: IFFALSE 79332
// exit ;
79330: GO 79497
// for i = 1 to mc_bases do
79332: LD_ADDR_VAR 0 4
79336: PUSH
79337: DOUBLE
79338: LD_INT 1
79340: DEC
79341: ST_TO_ADDR
79342: LD_EXP 59
79346: PUSH
79347: FOR_TO
79348: IFFALSE 79495
// begin if sci in mc_bases [ i ] then
79350: LD_VAR 0 2
79354: PUSH
79355: LD_EXP 59
79359: PUSH
79360: LD_VAR 0 4
79364: ARRAY
79365: IN
79366: IFFALSE 79493
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
79368: LD_ADDR_EXP 88
79372: PUSH
79373: LD_EXP 88
79377: PPUSH
79378: LD_VAR 0 4
79382: PUSH
79383: LD_EXP 88
79387: PUSH
79388: LD_VAR 0 4
79392: ARRAY
79393: PUSH
79394: LD_INT 1
79396: PLUS
79397: PUSH
79398: EMPTY
79399: LIST
79400: LIST
79401: PPUSH
79402: LD_VAR 0 1
79406: PPUSH
79407: CALL 19726 0 3
79411: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
79412: LD_ADDR_VAR 0 5
79416: PUSH
79417: LD_EXP 59
79421: PUSH
79422: LD_VAR 0 4
79426: ARRAY
79427: PPUSH
79428: LD_INT 2
79430: PUSH
79431: LD_INT 30
79433: PUSH
79434: LD_INT 0
79436: PUSH
79437: EMPTY
79438: LIST
79439: LIST
79440: PUSH
79441: LD_INT 30
79443: PUSH
79444: LD_INT 1
79446: PUSH
79447: EMPTY
79448: LIST
79449: LIST
79450: PUSH
79451: EMPTY
79452: LIST
79453: LIST
79454: LIST
79455: PPUSH
79456: CALL_OW 72
79460: PPUSH
79461: LD_VAR 0 1
79465: PPUSH
79466: CALL_OW 74
79470: ST_TO_ADDR
// if tmp then
79471: LD_VAR 0 5
79475: IFFALSE 79491
// ComStandNearbyBuilding ( ape , tmp ) ;
79477: LD_VAR 0 1
79481: PPUSH
79482: LD_VAR 0 5
79486: PPUSH
79487: CALL 16304 0 2
// break ;
79491: GO 79495
// end ; end ;
79493: GO 79347
79495: POP
79496: POP
// end ;
79497: LD_VAR 0 3
79501: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
79502: LD_INT 0
79504: PPUSH
79505: PPUSH
79506: PPUSH
// if not mc_bases or not skirmish then
79507: LD_EXP 59
79511: NOT
79512: PUSH
79513: LD_EXP 57
79517: NOT
79518: OR
79519: IFFALSE 79523
// exit ;
79521: GO 79612
// for i = 1 to mc_bases do
79523: LD_ADDR_VAR 0 4
79527: PUSH
79528: DOUBLE
79529: LD_INT 1
79531: DEC
79532: ST_TO_ADDR
79533: LD_EXP 59
79537: PUSH
79538: FOR_TO
79539: IFFALSE 79610
// begin if building in mc_busy_turret_list [ i ] then
79541: LD_VAR 0 1
79545: PUSH
79546: LD_EXP 69
79550: PUSH
79551: LD_VAR 0 4
79555: ARRAY
79556: IN
79557: IFFALSE 79608
// begin tmp := mc_busy_turret_list [ i ] diff building ;
79559: LD_ADDR_VAR 0 5
79563: PUSH
79564: LD_EXP 69
79568: PUSH
79569: LD_VAR 0 4
79573: ARRAY
79574: PUSH
79575: LD_VAR 0 1
79579: DIFF
79580: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
79581: LD_ADDR_EXP 69
79585: PUSH
79586: LD_EXP 69
79590: PPUSH
79591: LD_VAR 0 4
79595: PPUSH
79596: LD_VAR 0 5
79600: PPUSH
79601: CALL_OW 1
79605: ST_TO_ADDR
// break ;
79606: GO 79610
// end ; end ;
79608: GO 79538
79610: POP
79611: POP
// end ;
79612: LD_VAR 0 3
79616: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
79617: LD_INT 0
79619: PPUSH
79620: PPUSH
79621: PPUSH
// if not mc_bases or not skirmish then
79622: LD_EXP 59
79626: NOT
79627: PUSH
79628: LD_EXP 57
79632: NOT
79633: OR
79634: IFFALSE 79638
// exit ;
79636: GO 79837
// for i = 1 to mc_bases do
79638: LD_ADDR_VAR 0 5
79642: PUSH
79643: DOUBLE
79644: LD_INT 1
79646: DEC
79647: ST_TO_ADDR
79648: LD_EXP 59
79652: PUSH
79653: FOR_TO
79654: IFFALSE 79835
// if building in mc_bases [ i ] then
79656: LD_VAR 0 1
79660: PUSH
79661: LD_EXP 59
79665: PUSH
79666: LD_VAR 0 5
79670: ARRAY
79671: IN
79672: IFFALSE 79833
// begin tmp := mc_bases [ i ] diff building ;
79674: LD_ADDR_VAR 0 6
79678: PUSH
79679: LD_EXP 59
79683: PUSH
79684: LD_VAR 0 5
79688: ARRAY
79689: PUSH
79690: LD_VAR 0 1
79694: DIFF
79695: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
79696: LD_ADDR_EXP 59
79700: PUSH
79701: LD_EXP 59
79705: PPUSH
79706: LD_VAR 0 5
79710: PPUSH
79711: LD_VAR 0 6
79715: PPUSH
79716: CALL_OW 1
79720: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
79721: LD_VAR 0 1
79725: PUSH
79726: LD_EXP 67
79730: PUSH
79731: LD_VAR 0 5
79735: ARRAY
79736: IN
79737: IFFALSE 79776
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
79739: LD_ADDR_EXP 67
79743: PUSH
79744: LD_EXP 67
79748: PPUSH
79749: LD_VAR 0 5
79753: PPUSH
79754: LD_EXP 67
79758: PUSH
79759: LD_VAR 0 5
79763: ARRAY
79764: PUSH
79765: LD_VAR 0 1
79769: DIFF
79770: PPUSH
79771: CALL_OW 1
79775: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
79776: LD_VAR 0 1
79780: PUSH
79781: LD_EXP 68
79785: PUSH
79786: LD_VAR 0 5
79790: ARRAY
79791: IN
79792: IFFALSE 79831
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
79794: LD_ADDR_EXP 68
79798: PUSH
79799: LD_EXP 68
79803: PPUSH
79804: LD_VAR 0 5
79808: PPUSH
79809: LD_EXP 68
79813: PUSH
79814: LD_VAR 0 5
79818: ARRAY
79819: PUSH
79820: LD_VAR 0 1
79824: DIFF
79825: PPUSH
79826: CALL_OW 1
79830: ST_TO_ADDR
// break ;
79831: GO 79835
// end ;
79833: GO 79653
79835: POP
79836: POP
// end ;
79837: LD_VAR 0 4
79841: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
79842: LD_INT 0
79844: PPUSH
79845: PPUSH
79846: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
79847: LD_EXP 59
79851: NOT
79852: PUSH
79853: LD_EXP 57
79857: NOT
79858: OR
79859: PUSH
79860: LD_VAR 0 3
79864: PUSH
79865: LD_EXP 85
79869: IN
79870: NOT
79871: OR
79872: IFFALSE 79876
// exit ;
79874: GO 79999
// for i = 1 to mc_vehicles do
79876: LD_ADDR_VAR 0 6
79880: PUSH
79881: DOUBLE
79882: LD_INT 1
79884: DEC
79885: ST_TO_ADDR
79886: LD_EXP 78
79890: PUSH
79891: FOR_TO
79892: IFFALSE 79997
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
79894: LD_VAR 0 2
79898: PUSH
79899: LD_EXP 78
79903: PUSH
79904: LD_VAR 0 6
79908: ARRAY
79909: IN
79910: PUSH
79911: LD_VAR 0 1
79915: PUSH
79916: LD_EXP 78
79920: PUSH
79921: LD_VAR 0 6
79925: ARRAY
79926: IN
79927: OR
79928: IFFALSE 79995
// begin tmp := mc_vehicles [ i ] diff old ;
79930: LD_ADDR_VAR 0 7
79934: PUSH
79935: LD_EXP 78
79939: PUSH
79940: LD_VAR 0 6
79944: ARRAY
79945: PUSH
79946: LD_VAR 0 2
79950: DIFF
79951: ST_TO_ADDR
// tmp := tmp diff new ;
79952: LD_ADDR_VAR 0 7
79956: PUSH
79957: LD_VAR 0 7
79961: PUSH
79962: LD_VAR 0 1
79966: DIFF
79967: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
79968: LD_ADDR_EXP 78
79972: PUSH
79973: LD_EXP 78
79977: PPUSH
79978: LD_VAR 0 6
79982: PPUSH
79983: LD_VAR 0 7
79987: PPUSH
79988: CALL_OW 1
79992: ST_TO_ADDR
// break ;
79993: GO 79997
// end ;
79995: GO 79891
79997: POP
79998: POP
// end ;
79999: LD_VAR 0 5
80003: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
80004: LD_INT 0
80006: PPUSH
80007: PPUSH
80008: PPUSH
80009: PPUSH
// if not mc_bases or not skirmish then
80010: LD_EXP 59
80014: NOT
80015: PUSH
80016: LD_EXP 57
80020: NOT
80021: OR
80022: IFFALSE 80026
// exit ;
80024: GO 80418
// side := GetSide ( vehicle ) ;
80026: LD_ADDR_VAR 0 5
80030: PUSH
80031: LD_VAR 0 1
80035: PPUSH
80036: CALL_OW 255
80040: ST_TO_ADDR
// for i = 1 to mc_bases do
80041: LD_ADDR_VAR 0 4
80045: PUSH
80046: DOUBLE
80047: LD_INT 1
80049: DEC
80050: ST_TO_ADDR
80051: LD_EXP 59
80055: PUSH
80056: FOR_TO
80057: IFFALSE 80416
// begin if factory in mc_bases [ i ] then
80059: LD_VAR 0 2
80063: PUSH
80064: LD_EXP 59
80068: PUSH
80069: LD_VAR 0 4
80073: ARRAY
80074: IN
80075: IFFALSE 80414
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
80077: LD_EXP 81
80081: PUSH
80082: LD_VAR 0 4
80086: ARRAY
80087: PUSH
80088: LD_EXP 70
80092: PUSH
80093: LD_VAR 0 4
80097: ARRAY
80098: LESS
80099: PUSH
80100: LD_VAR 0 1
80104: PPUSH
80105: CALL_OW 264
80109: PUSH
80110: LD_INT 31
80112: PUSH
80113: LD_INT 32
80115: PUSH
80116: LD_INT 51
80118: PUSH
80119: LD_EXP 104
80123: PUSH
80124: LD_INT 12
80126: PUSH
80127: LD_INT 30
80129: PUSH
80130: LD_EXP 103
80134: PUSH
80135: LD_INT 11
80137: PUSH
80138: LD_INT 53
80140: PUSH
80141: LD_INT 14
80143: PUSH
80144: LD_EXP 107
80148: PUSH
80149: LD_INT 29
80151: PUSH
80152: LD_EXP 105
80156: PUSH
80157: LD_INT 13
80159: PUSH
80160: LD_INT 52
80162: PUSH
80163: LD_EXP 109
80167: PUSH
80168: LD_INT 48
80170: PUSH
80171: LD_INT 8
80173: PUSH
80174: EMPTY
80175: LIST
80176: LIST
80177: LIST
80178: LIST
80179: LIST
80180: LIST
80181: LIST
80182: LIST
80183: LIST
80184: LIST
80185: LIST
80186: LIST
80187: LIST
80188: LIST
80189: LIST
80190: LIST
80191: LIST
80192: LIST
80193: IN
80194: NOT
80195: AND
80196: IFFALSE 80244
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
80198: LD_ADDR_EXP 81
80202: PUSH
80203: LD_EXP 81
80207: PPUSH
80208: LD_VAR 0 4
80212: PUSH
80213: LD_EXP 81
80217: PUSH
80218: LD_VAR 0 4
80222: ARRAY
80223: PUSH
80224: LD_INT 1
80226: PLUS
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PPUSH
80232: LD_VAR 0 1
80236: PPUSH
80237: CALL 19726 0 3
80241: ST_TO_ADDR
80242: GO 80288
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
80244: LD_ADDR_EXP 78
80248: PUSH
80249: LD_EXP 78
80253: PPUSH
80254: LD_VAR 0 4
80258: PUSH
80259: LD_EXP 78
80263: PUSH
80264: LD_VAR 0 4
80268: ARRAY
80269: PUSH
80270: LD_INT 1
80272: PLUS
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PPUSH
80278: LD_VAR 0 1
80282: PPUSH
80283: CALL 19726 0 3
80287: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
80288: LD_VAR 0 1
80292: PPUSH
80293: CALL_OW 263
80297: PUSH
80298: LD_INT 2
80300: EQUAL
80301: IFFALSE 80330
// begin repeat wait ( 0 0$3 ) ;
80303: LD_INT 105
80305: PPUSH
80306: CALL_OW 67
// Connect ( vehicle ) ;
80310: LD_VAR 0 1
80314: PPUSH
80315: CALL 22697 0 1
// until IsControledBy ( vehicle ) ;
80319: LD_VAR 0 1
80323: PPUSH
80324: CALL_OW 312
80328: IFFALSE 80303
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
80330: LD_VAR 0 1
80334: PPUSH
80335: LD_EXP 83
80339: PUSH
80340: LD_VAR 0 4
80344: ARRAY
80345: PPUSH
80346: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
80350: LD_VAR 0 1
80354: PPUSH
80355: CALL_OW 263
80359: PUSH
80360: LD_INT 1
80362: NONEQUAL
80363: IFFALSE 80367
// break ;
80365: GO 80416
// repeat wait ( 0 0$1 ) ;
80367: LD_INT 35
80369: PPUSH
80370: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
80374: LD_VAR 0 1
80378: PPUSH
80379: LD_EXP 83
80383: PUSH
80384: LD_VAR 0 4
80388: ARRAY
80389: PPUSH
80390: CALL_OW 308
80394: IFFALSE 80367
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
80396: LD_VAR 0 1
80400: PPUSH
80401: CALL_OW 311
80405: PPUSH
80406: CALL_OW 121
// exit ;
80410: POP
80411: POP
80412: GO 80418
// end ; end ;
80414: GO 80056
80416: POP
80417: POP
// end ;
80418: LD_VAR 0 3
80422: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
80423: LD_INT 0
80425: PPUSH
80426: PPUSH
80427: PPUSH
80428: PPUSH
// if not mc_bases or not skirmish then
80429: LD_EXP 59
80433: NOT
80434: PUSH
80435: LD_EXP 57
80439: NOT
80440: OR
80441: IFFALSE 80445
// exit ;
80443: GO 80798
// repeat wait ( 0 0$1 ) ;
80445: LD_INT 35
80447: PPUSH
80448: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
80452: LD_VAR 0 2
80456: PPUSH
80457: LD_VAR 0 3
80461: PPUSH
80462: CALL_OW 284
80466: IFFALSE 80445
// if GetResourceTypeXY ( x , y ) = mat_artefact then
80468: LD_VAR 0 2
80472: PPUSH
80473: LD_VAR 0 3
80477: PPUSH
80478: CALL_OW 283
80482: PUSH
80483: LD_INT 4
80485: EQUAL
80486: IFFALSE 80490
// exit ;
80488: GO 80798
// for i = 1 to mc_bases do
80490: LD_ADDR_VAR 0 7
80494: PUSH
80495: DOUBLE
80496: LD_INT 1
80498: DEC
80499: ST_TO_ADDR
80500: LD_EXP 59
80504: PUSH
80505: FOR_TO
80506: IFFALSE 80796
// begin if mc_crates_area [ i ] then
80508: LD_EXP 77
80512: PUSH
80513: LD_VAR 0 7
80517: ARRAY
80518: IFFALSE 80629
// for j in mc_crates_area [ i ] do
80520: LD_ADDR_VAR 0 8
80524: PUSH
80525: LD_EXP 77
80529: PUSH
80530: LD_VAR 0 7
80534: ARRAY
80535: PUSH
80536: FOR_IN
80537: IFFALSE 80627
// if InArea ( x , y , j ) then
80539: LD_VAR 0 2
80543: PPUSH
80544: LD_VAR 0 3
80548: PPUSH
80549: LD_VAR 0 8
80553: PPUSH
80554: CALL_OW 309
80558: IFFALSE 80625
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80560: LD_ADDR_EXP 75
80564: PUSH
80565: LD_EXP 75
80569: PPUSH
80570: LD_VAR 0 7
80574: PUSH
80575: LD_EXP 75
80579: PUSH
80580: LD_VAR 0 7
80584: ARRAY
80585: PUSH
80586: LD_INT 1
80588: PLUS
80589: PUSH
80590: EMPTY
80591: LIST
80592: LIST
80593: PPUSH
80594: LD_VAR 0 4
80598: PUSH
80599: LD_VAR 0 2
80603: PUSH
80604: LD_VAR 0 3
80608: PUSH
80609: EMPTY
80610: LIST
80611: LIST
80612: LIST
80613: PPUSH
80614: CALL 19726 0 3
80618: ST_TO_ADDR
// exit ;
80619: POP
80620: POP
80621: POP
80622: POP
80623: GO 80798
// end ;
80625: GO 80536
80627: POP
80628: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80629: LD_ADDR_VAR 0 9
80633: PUSH
80634: LD_EXP 59
80638: PUSH
80639: LD_VAR 0 7
80643: ARRAY
80644: PPUSH
80645: LD_INT 2
80647: PUSH
80648: LD_INT 30
80650: PUSH
80651: LD_INT 0
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 30
80660: PUSH
80661: LD_INT 1
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: EMPTY
80669: LIST
80670: LIST
80671: LIST
80672: PPUSH
80673: CALL_OW 72
80677: ST_TO_ADDR
// if not depot then
80678: LD_VAR 0 9
80682: NOT
80683: IFFALSE 80687
// continue ;
80685: GO 80505
// for j in depot do
80687: LD_ADDR_VAR 0 8
80691: PUSH
80692: LD_VAR 0 9
80696: PUSH
80697: FOR_IN
80698: IFFALSE 80792
// if GetDistUnitXY ( j , x , y ) < 30 then
80700: LD_VAR 0 8
80704: PPUSH
80705: LD_VAR 0 2
80709: PPUSH
80710: LD_VAR 0 3
80714: PPUSH
80715: CALL_OW 297
80719: PUSH
80720: LD_INT 30
80722: LESS
80723: IFFALSE 80790
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80725: LD_ADDR_EXP 75
80729: PUSH
80730: LD_EXP 75
80734: PPUSH
80735: LD_VAR 0 7
80739: PUSH
80740: LD_EXP 75
80744: PUSH
80745: LD_VAR 0 7
80749: ARRAY
80750: PUSH
80751: LD_INT 1
80753: PLUS
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: PPUSH
80759: LD_VAR 0 4
80763: PUSH
80764: LD_VAR 0 2
80768: PUSH
80769: LD_VAR 0 3
80773: PUSH
80774: EMPTY
80775: LIST
80776: LIST
80777: LIST
80778: PPUSH
80779: CALL 19726 0 3
80783: ST_TO_ADDR
// exit ;
80784: POP
80785: POP
80786: POP
80787: POP
80788: GO 80798
// end ;
80790: GO 80697
80792: POP
80793: POP
// end ;
80794: GO 80505
80796: POP
80797: POP
// end ;
80798: LD_VAR 0 6
80802: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
80803: LD_INT 0
80805: PPUSH
80806: PPUSH
80807: PPUSH
80808: PPUSH
// if not mc_bases or not skirmish then
80809: LD_EXP 59
80813: NOT
80814: PUSH
80815: LD_EXP 57
80819: NOT
80820: OR
80821: IFFALSE 80825
// exit ;
80823: GO 81102
// side := GetSide ( lab ) ;
80825: LD_ADDR_VAR 0 4
80829: PUSH
80830: LD_VAR 0 2
80834: PPUSH
80835: CALL_OW 255
80839: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
80840: LD_VAR 0 4
80844: PUSH
80845: LD_EXP 85
80849: IN
80850: NOT
80851: PUSH
80852: LD_EXP 86
80856: NOT
80857: OR
80858: PUSH
80859: LD_EXP 59
80863: NOT
80864: OR
80865: IFFALSE 80869
// exit ;
80867: GO 81102
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
80869: LD_ADDR_EXP 86
80873: PUSH
80874: LD_EXP 86
80878: PPUSH
80879: LD_VAR 0 4
80883: PPUSH
80884: LD_EXP 86
80888: PUSH
80889: LD_VAR 0 4
80893: ARRAY
80894: PUSH
80895: LD_VAR 0 1
80899: DIFF
80900: PPUSH
80901: CALL_OW 1
80905: ST_TO_ADDR
// for i = 1 to mc_bases do
80906: LD_ADDR_VAR 0 5
80910: PUSH
80911: DOUBLE
80912: LD_INT 1
80914: DEC
80915: ST_TO_ADDR
80916: LD_EXP 59
80920: PUSH
80921: FOR_TO
80922: IFFALSE 81100
// begin if lab in mc_bases [ i ] then
80924: LD_VAR 0 2
80928: PUSH
80929: LD_EXP 59
80933: PUSH
80934: LD_VAR 0 5
80938: ARRAY
80939: IN
80940: IFFALSE 81098
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
80942: LD_VAR 0 1
80946: PUSH
80947: LD_INT 11
80949: PUSH
80950: LD_INT 4
80952: PUSH
80953: LD_INT 3
80955: PUSH
80956: LD_INT 2
80958: PUSH
80959: EMPTY
80960: LIST
80961: LIST
80962: LIST
80963: LIST
80964: IN
80965: PUSH
80966: LD_EXP 89
80970: PUSH
80971: LD_VAR 0 5
80975: ARRAY
80976: AND
80977: IFFALSE 81098
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
80979: LD_ADDR_VAR 0 6
80983: PUSH
80984: LD_EXP 89
80988: PUSH
80989: LD_VAR 0 5
80993: ARRAY
80994: PUSH
80995: LD_INT 1
80997: ARRAY
80998: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80999: LD_ADDR_EXP 89
81003: PUSH
81004: LD_EXP 89
81008: PPUSH
81009: LD_VAR 0 5
81013: PPUSH
81014: EMPTY
81015: PPUSH
81016: CALL_OW 1
81020: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
81021: LD_VAR 0 6
81025: PPUSH
81026: LD_INT 0
81028: PPUSH
81029: CALL_OW 109
// ComExitBuilding ( tmp ) ;
81033: LD_VAR 0 6
81037: PPUSH
81038: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
81042: LD_ADDR_EXP 88
81046: PUSH
81047: LD_EXP 88
81051: PPUSH
81052: LD_VAR 0 5
81056: PPUSH
81057: LD_EXP 88
81061: PUSH
81062: LD_VAR 0 5
81066: ARRAY
81067: PPUSH
81068: LD_INT 1
81070: PPUSH
81071: LD_VAR 0 6
81075: PPUSH
81076: CALL_OW 2
81080: PPUSH
81081: CALL_OW 1
81085: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
81086: LD_VAR 0 5
81090: PPUSH
81091: LD_INT 112
81093: PPUSH
81094: CALL 57768 0 2
// end ; end ; end ;
81098: GO 80921
81100: POP
81101: POP
// end ;
81102: LD_VAR 0 3
81106: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
81107: LD_INT 0
81109: PPUSH
81110: PPUSH
81111: PPUSH
81112: PPUSH
81113: PPUSH
81114: PPUSH
81115: PPUSH
81116: PPUSH
// if not mc_bases or not skirmish then
81117: LD_EXP 59
81121: NOT
81122: PUSH
81123: LD_EXP 57
81127: NOT
81128: OR
81129: IFFALSE 81133
// exit ;
81131: GO 82504
// for i = 1 to mc_bases do
81133: LD_ADDR_VAR 0 3
81137: PUSH
81138: DOUBLE
81139: LD_INT 1
81141: DEC
81142: ST_TO_ADDR
81143: LD_EXP 59
81147: PUSH
81148: FOR_TO
81149: IFFALSE 82502
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
81151: LD_VAR 0 1
81155: PUSH
81156: LD_EXP 59
81160: PUSH
81161: LD_VAR 0 3
81165: ARRAY
81166: IN
81167: PUSH
81168: LD_VAR 0 1
81172: PUSH
81173: LD_EXP 66
81177: PUSH
81178: LD_VAR 0 3
81182: ARRAY
81183: IN
81184: OR
81185: PUSH
81186: LD_VAR 0 1
81190: PUSH
81191: LD_EXP 81
81195: PUSH
81196: LD_VAR 0 3
81200: ARRAY
81201: IN
81202: OR
81203: PUSH
81204: LD_VAR 0 1
81208: PUSH
81209: LD_EXP 78
81213: PUSH
81214: LD_VAR 0 3
81218: ARRAY
81219: IN
81220: OR
81221: PUSH
81222: LD_VAR 0 1
81226: PUSH
81227: LD_EXP 88
81231: PUSH
81232: LD_VAR 0 3
81236: ARRAY
81237: IN
81238: OR
81239: PUSH
81240: LD_VAR 0 1
81244: PUSH
81245: LD_EXP 89
81249: PUSH
81250: LD_VAR 0 3
81254: ARRAY
81255: IN
81256: OR
81257: IFFALSE 82500
// begin if un in mc_ape [ i ] then
81259: LD_VAR 0 1
81263: PUSH
81264: LD_EXP 88
81268: PUSH
81269: LD_VAR 0 3
81273: ARRAY
81274: IN
81275: IFFALSE 81314
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
81277: LD_ADDR_EXP 88
81281: PUSH
81282: LD_EXP 88
81286: PPUSH
81287: LD_VAR 0 3
81291: PPUSH
81292: LD_EXP 88
81296: PUSH
81297: LD_VAR 0 3
81301: ARRAY
81302: PUSH
81303: LD_VAR 0 1
81307: DIFF
81308: PPUSH
81309: CALL_OW 1
81313: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
81314: LD_VAR 0 1
81318: PUSH
81319: LD_EXP 89
81323: PUSH
81324: LD_VAR 0 3
81328: ARRAY
81329: IN
81330: IFFALSE 81354
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81332: LD_ADDR_EXP 89
81336: PUSH
81337: LD_EXP 89
81341: PPUSH
81342: LD_VAR 0 3
81346: PPUSH
81347: EMPTY
81348: PPUSH
81349: CALL_OW 1
81353: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
81354: LD_VAR 0 1
81358: PPUSH
81359: CALL_OW 247
81363: PUSH
81364: LD_INT 2
81366: EQUAL
81367: PUSH
81368: LD_VAR 0 1
81372: PPUSH
81373: CALL_OW 110
81377: PUSH
81378: LD_INT 20
81380: EQUAL
81381: PUSH
81382: LD_VAR 0 1
81386: PUSH
81387: LD_EXP 81
81391: PUSH
81392: LD_VAR 0 3
81396: ARRAY
81397: IN
81398: OR
81399: PUSH
81400: LD_VAR 0 1
81404: PPUSH
81405: CALL_OW 264
81409: PUSH
81410: LD_INT 12
81412: PUSH
81413: LD_INT 51
81415: PUSH
81416: LD_EXP 104
81420: PUSH
81421: LD_INT 32
81423: PUSH
81424: LD_INT 13
81426: PUSH
81427: LD_INT 52
81429: PUSH
81430: LD_INT 31
81432: PUSH
81433: EMPTY
81434: LIST
81435: LIST
81436: LIST
81437: LIST
81438: LIST
81439: LIST
81440: LIST
81441: IN
81442: OR
81443: AND
81444: IFFALSE 81752
// begin if un in mc_defender [ i ] then
81446: LD_VAR 0 1
81450: PUSH
81451: LD_EXP 81
81455: PUSH
81456: LD_VAR 0 3
81460: ARRAY
81461: IN
81462: IFFALSE 81501
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81464: LD_ADDR_EXP 81
81468: PUSH
81469: LD_EXP 81
81473: PPUSH
81474: LD_VAR 0 3
81478: PPUSH
81479: LD_EXP 81
81483: PUSH
81484: LD_VAR 0 3
81488: ARRAY
81489: PUSH
81490: LD_VAR 0 1
81494: DIFF
81495: PPUSH
81496: CALL_OW 1
81500: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
81501: LD_ADDR_VAR 0 8
81505: PUSH
81506: LD_VAR 0 3
81510: PPUSH
81511: LD_INT 3
81513: PPUSH
81514: CALL 78142 0 2
81518: ST_TO_ADDR
// if fac then
81519: LD_VAR 0 8
81523: IFFALSE 81752
// begin for j in fac do
81525: LD_ADDR_VAR 0 4
81529: PUSH
81530: LD_VAR 0 8
81534: PUSH
81535: FOR_IN
81536: IFFALSE 81750
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
81538: LD_ADDR_VAR 0 9
81542: PUSH
81543: LD_VAR 0 8
81547: PPUSH
81548: LD_VAR 0 1
81552: PPUSH
81553: CALL_OW 265
81557: PPUSH
81558: LD_VAR 0 1
81562: PPUSH
81563: CALL_OW 262
81567: PPUSH
81568: LD_VAR 0 1
81572: PPUSH
81573: CALL_OW 263
81577: PPUSH
81578: LD_VAR 0 1
81582: PPUSH
81583: CALL_OW 264
81587: PPUSH
81588: CALL 17222 0 5
81592: ST_TO_ADDR
// if components then
81593: LD_VAR 0 9
81597: IFFALSE 81748
// begin if GetWeapon ( un ) = ar_control_tower then
81599: LD_VAR 0 1
81603: PPUSH
81604: CALL_OW 264
81608: PUSH
81609: LD_INT 31
81611: EQUAL
81612: IFFALSE 81729
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
81614: LD_VAR 0 1
81618: PPUSH
81619: CALL_OW 311
81623: PPUSH
81624: LD_INT 0
81626: PPUSH
81627: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
81631: LD_ADDR_EXP 99
81635: PUSH
81636: LD_EXP 99
81640: PPUSH
81641: LD_VAR 0 3
81645: PPUSH
81646: LD_EXP 99
81650: PUSH
81651: LD_VAR 0 3
81655: ARRAY
81656: PUSH
81657: LD_VAR 0 1
81661: PPUSH
81662: CALL_OW 311
81666: DIFF
81667: PPUSH
81668: CALL_OW 1
81672: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
81673: LD_ADDR_VAR 0 7
81677: PUSH
81678: LD_EXP 80
81682: PUSH
81683: LD_VAR 0 3
81687: ARRAY
81688: PPUSH
81689: LD_INT 1
81691: PPUSH
81692: LD_VAR 0 9
81696: PPUSH
81697: CALL_OW 2
81701: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
81702: LD_ADDR_EXP 80
81706: PUSH
81707: LD_EXP 80
81711: PPUSH
81712: LD_VAR 0 3
81716: PPUSH
81717: LD_VAR 0 7
81721: PPUSH
81722: CALL_OW 1
81726: ST_TO_ADDR
// end else
81727: GO 81746
// MC_InsertProduceList ( i , [ components ] ) ;
81729: LD_VAR 0 3
81733: PPUSH
81734: LD_VAR 0 9
81738: PUSH
81739: EMPTY
81740: LIST
81741: PPUSH
81742: CALL 77687 0 2
// break ;
81746: GO 81750
// end ; end ;
81748: GO 81535
81750: POP
81751: POP
// end ; end ; if GetType ( un ) = unit_building then
81752: LD_VAR 0 1
81756: PPUSH
81757: CALL_OW 247
81761: PUSH
81762: LD_INT 3
81764: EQUAL
81765: IFFALSE 82168
// begin btype := GetBType ( un ) ;
81767: LD_ADDR_VAR 0 5
81771: PUSH
81772: LD_VAR 0 1
81776: PPUSH
81777: CALL_OW 266
81781: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
81782: LD_VAR 0 5
81786: PUSH
81787: LD_INT 29
81789: PUSH
81790: LD_INT 30
81792: PUSH
81793: EMPTY
81794: LIST
81795: LIST
81796: IN
81797: IFFALSE 81870
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
81799: LD_VAR 0 1
81803: PPUSH
81804: CALL_OW 250
81808: PPUSH
81809: LD_VAR 0 1
81813: PPUSH
81814: CALL_OW 251
81818: PPUSH
81819: LD_VAR 0 1
81823: PPUSH
81824: CALL_OW 255
81828: PPUSH
81829: CALL_OW 440
81833: NOT
81834: IFFALSE 81870
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
81836: LD_VAR 0 1
81840: PPUSH
81841: CALL_OW 250
81845: PPUSH
81846: LD_VAR 0 1
81850: PPUSH
81851: CALL_OW 251
81855: PPUSH
81856: LD_VAR 0 1
81860: PPUSH
81861: CALL_OW 255
81865: PPUSH
81866: CALL_OW 441
// end ; if btype = b_warehouse then
81870: LD_VAR 0 5
81874: PUSH
81875: LD_INT 1
81877: EQUAL
81878: IFFALSE 81896
// begin btype := b_depot ;
81880: LD_ADDR_VAR 0 5
81884: PUSH
81885: LD_INT 0
81887: ST_TO_ADDR
// pos := 1 ;
81888: LD_ADDR_VAR 0 6
81892: PUSH
81893: LD_INT 1
81895: ST_TO_ADDR
// end ; if btype = b_factory then
81896: LD_VAR 0 5
81900: PUSH
81901: LD_INT 3
81903: EQUAL
81904: IFFALSE 81922
// begin btype := b_workshop ;
81906: LD_ADDR_VAR 0 5
81910: PUSH
81911: LD_INT 2
81913: ST_TO_ADDR
// pos := 1 ;
81914: LD_ADDR_VAR 0 6
81918: PUSH
81919: LD_INT 1
81921: ST_TO_ADDR
// end ; if btype = b_barracks then
81922: LD_VAR 0 5
81926: PUSH
81927: LD_INT 5
81929: EQUAL
81930: IFFALSE 81940
// btype := b_armoury ;
81932: LD_ADDR_VAR 0 5
81936: PUSH
81937: LD_INT 4
81939: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
81940: LD_VAR 0 5
81944: PUSH
81945: LD_INT 7
81947: PUSH
81948: LD_INT 8
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: IN
81955: IFFALSE 81965
// btype := b_lab ;
81957: LD_ADDR_VAR 0 5
81961: PUSH
81962: LD_INT 6
81964: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
81965: LD_ADDR_EXP 64
81969: PUSH
81970: LD_EXP 64
81974: PPUSH
81975: LD_VAR 0 3
81979: PUSH
81980: LD_EXP 64
81984: PUSH
81985: LD_VAR 0 3
81989: ARRAY
81990: PUSH
81991: LD_INT 1
81993: PLUS
81994: PUSH
81995: EMPTY
81996: LIST
81997: LIST
81998: PPUSH
81999: LD_VAR 0 5
82003: PUSH
82004: LD_VAR 0 1
82008: PPUSH
82009: CALL_OW 250
82013: PUSH
82014: LD_VAR 0 1
82018: PPUSH
82019: CALL_OW 251
82023: PUSH
82024: LD_VAR 0 1
82028: PPUSH
82029: CALL_OW 254
82033: PUSH
82034: EMPTY
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: PPUSH
82040: CALL 19726 0 3
82044: ST_TO_ADDR
// if pos = 1 then
82045: LD_VAR 0 6
82049: PUSH
82050: LD_INT 1
82052: EQUAL
82053: IFFALSE 82168
// begin tmp := mc_build_list [ i ] ;
82055: LD_ADDR_VAR 0 7
82059: PUSH
82060: LD_EXP 64
82064: PUSH
82065: LD_VAR 0 3
82069: ARRAY
82070: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82071: LD_VAR 0 7
82075: PPUSH
82076: LD_INT 2
82078: PUSH
82079: LD_INT 30
82081: PUSH
82082: LD_INT 0
82084: PUSH
82085: EMPTY
82086: LIST
82087: LIST
82088: PUSH
82089: LD_INT 30
82091: PUSH
82092: LD_INT 1
82094: PUSH
82095: EMPTY
82096: LIST
82097: LIST
82098: PUSH
82099: EMPTY
82100: LIST
82101: LIST
82102: LIST
82103: PPUSH
82104: CALL_OW 72
82108: IFFALSE 82118
// pos := 2 ;
82110: LD_ADDR_VAR 0 6
82114: PUSH
82115: LD_INT 2
82117: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
82118: LD_ADDR_VAR 0 7
82122: PUSH
82123: LD_VAR 0 7
82127: PPUSH
82128: LD_VAR 0 6
82132: PPUSH
82133: LD_VAR 0 7
82137: PPUSH
82138: CALL 20052 0 3
82142: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
82143: LD_ADDR_EXP 64
82147: PUSH
82148: LD_EXP 64
82152: PPUSH
82153: LD_VAR 0 3
82157: PPUSH
82158: LD_VAR 0 7
82162: PPUSH
82163: CALL_OW 1
82167: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
82168: LD_VAR 0 1
82172: PUSH
82173: LD_EXP 59
82177: PUSH
82178: LD_VAR 0 3
82182: ARRAY
82183: IN
82184: IFFALSE 82223
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
82186: LD_ADDR_EXP 59
82190: PUSH
82191: LD_EXP 59
82195: PPUSH
82196: LD_VAR 0 3
82200: PPUSH
82201: LD_EXP 59
82205: PUSH
82206: LD_VAR 0 3
82210: ARRAY
82211: PUSH
82212: LD_VAR 0 1
82216: DIFF
82217: PPUSH
82218: CALL_OW 1
82222: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
82223: LD_VAR 0 1
82227: PUSH
82228: LD_EXP 66
82232: PUSH
82233: LD_VAR 0 3
82237: ARRAY
82238: IN
82239: IFFALSE 82278
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
82241: LD_ADDR_EXP 66
82245: PUSH
82246: LD_EXP 66
82250: PPUSH
82251: LD_VAR 0 3
82255: PPUSH
82256: LD_EXP 66
82260: PUSH
82261: LD_VAR 0 3
82265: ARRAY
82266: PUSH
82267: LD_VAR 0 1
82271: DIFF
82272: PPUSH
82273: CALL_OW 1
82277: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
82278: LD_VAR 0 1
82282: PUSH
82283: LD_EXP 78
82287: PUSH
82288: LD_VAR 0 3
82292: ARRAY
82293: IN
82294: IFFALSE 82333
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
82296: LD_ADDR_EXP 78
82300: PUSH
82301: LD_EXP 78
82305: PPUSH
82306: LD_VAR 0 3
82310: PPUSH
82311: LD_EXP 78
82315: PUSH
82316: LD_VAR 0 3
82320: ARRAY
82321: PUSH
82322: LD_VAR 0 1
82326: DIFF
82327: PPUSH
82328: CALL_OW 1
82332: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
82333: LD_VAR 0 1
82337: PUSH
82338: LD_EXP 81
82342: PUSH
82343: LD_VAR 0 3
82347: ARRAY
82348: IN
82349: IFFALSE 82388
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82351: LD_ADDR_EXP 81
82355: PUSH
82356: LD_EXP 81
82360: PPUSH
82361: LD_VAR 0 3
82365: PPUSH
82366: LD_EXP 81
82370: PUSH
82371: LD_VAR 0 3
82375: ARRAY
82376: PUSH
82377: LD_VAR 0 1
82381: DIFF
82382: PPUSH
82383: CALL_OW 1
82387: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
82388: LD_VAR 0 1
82392: PUSH
82393: LD_EXP 68
82397: PUSH
82398: LD_VAR 0 3
82402: ARRAY
82403: IN
82404: IFFALSE 82443
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
82406: LD_ADDR_EXP 68
82410: PUSH
82411: LD_EXP 68
82415: PPUSH
82416: LD_VAR 0 3
82420: PPUSH
82421: LD_EXP 68
82425: PUSH
82426: LD_VAR 0 3
82430: ARRAY
82431: PUSH
82432: LD_VAR 0 1
82436: DIFF
82437: PPUSH
82438: CALL_OW 1
82442: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
82443: LD_VAR 0 1
82447: PUSH
82448: LD_EXP 67
82452: PUSH
82453: LD_VAR 0 3
82457: ARRAY
82458: IN
82459: IFFALSE 82498
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
82461: LD_ADDR_EXP 67
82465: PUSH
82466: LD_EXP 67
82470: PPUSH
82471: LD_VAR 0 3
82475: PPUSH
82476: LD_EXP 67
82480: PUSH
82481: LD_VAR 0 3
82485: ARRAY
82486: PUSH
82487: LD_VAR 0 1
82491: DIFF
82492: PPUSH
82493: CALL_OW 1
82497: ST_TO_ADDR
// end ; break ;
82498: GO 82502
// end ;
82500: GO 81148
82502: POP
82503: POP
// end ;
82504: LD_VAR 0 2
82508: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
82509: LD_INT 0
82511: PPUSH
82512: PPUSH
82513: PPUSH
// if not mc_bases or not skirmish then
82514: LD_EXP 59
82518: NOT
82519: PUSH
82520: LD_EXP 57
82524: NOT
82525: OR
82526: IFFALSE 82530
// exit ;
82528: GO 82745
// for i = 1 to mc_bases do
82530: LD_ADDR_VAR 0 3
82534: PUSH
82535: DOUBLE
82536: LD_INT 1
82538: DEC
82539: ST_TO_ADDR
82540: LD_EXP 59
82544: PUSH
82545: FOR_TO
82546: IFFALSE 82743
// begin if building in mc_construct_list [ i ] then
82548: LD_VAR 0 1
82552: PUSH
82553: LD_EXP 66
82557: PUSH
82558: LD_VAR 0 3
82562: ARRAY
82563: IN
82564: IFFALSE 82741
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82566: LD_ADDR_EXP 66
82570: PUSH
82571: LD_EXP 66
82575: PPUSH
82576: LD_VAR 0 3
82580: PPUSH
82581: LD_EXP 66
82585: PUSH
82586: LD_VAR 0 3
82590: ARRAY
82591: PUSH
82592: LD_VAR 0 1
82596: DIFF
82597: PPUSH
82598: CALL_OW 1
82602: ST_TO_ADDR
// if building in mc_lab [ i ] then
82603: LD_VAR 0 1
82607: PUSH
82608: LD_EXP 92
82612: PUSH
82613: LD_VAR 0 3
82617: ARRAY
82618: IN
82619: IFFALSE 82674
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
82621: LD_ADDR_EXP 93
82625: PUSH
82626: LD_EXP 93
82630: PPUSH
82631: LD_VAR 0 3
82635: PPUSH
82636: LD_EXP 93
82640: PUSH
82641: LD_VAR 0 3
82645: ARRAY
82646: PPUSH
82647: LD_INT 1
82649: PPUSH
82650: LD_EXP 93
82654: PUSH
82655: LD_VAR 0 3
82659: ARRAY
82660: PPUSH
82661: LD_INT 0
82663: PPUSH
82664: CALL 19144 0 4
82668: PPUSH
82669: CALL_OW 1
82673: ST_TO_ADDR
// if not building in mc_bases [ i ] then
82674: LD_VAR 0 1
82678: PUSH
82679: LD_EXP 59
82683: PUSH
82684: LD_VAR 0 3
82688: ARRAY
82689: IN
82690: NOT
82691: IFFALSE 82737
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82693: LD_ADDR_EXP 59
82697: PUSH
82698: LD_EXP 59
82702: PPUSH
82703: LD_VAR 0 3
82707: PUSH
82708: LD_EXP 59
82712: PUSH
82713: LD_VAR 0 3
82717: ARRAY
82718: PUSH
82719: LD_INT 1
82721: PLUS
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: PPUSH
82727: LD_VAR 0 1
82731: PPUSH
82732: CALL 19726 0 3
82736: ST_TO_ADDR
// exit ;
82737: POP
82738: POP
82739: GO 82745
// end ; end ;
82741: GO 82545
82743: POP
82744: POP
// end ;
82745: LD_VAR 0 2
82749: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
82750: LD_INT 0
82752: PPUSH
82753: PPUSH
82754: PPUSH
82755: PPUSH
82756: PPUSH
82757: PPUSH
82758: PPUSH
// if not mc_bases or not skirmish then
82759: LD_EXP 59
82763: NOT
82764: PUSH
82765: LD_EXP 57
82769: NOT
82770: OR
82771: IFFALSE 82775
// exit ;
82773: GO 83436
// for i = 1 to mc_bases do
82775: LD_ADDR_VAR 0 3
82779: PUSH
82780: DOUBLE
82781: LD_INT 1
82783: DEC
82784: ST_TO_ADDR
82785: LD_EXP 59
82789: PUSH
82790: FOR_TO
82791: IFFALSE 83434
// begin if building in mc_construct_list [ i ] then
82793: LD_VAR 0 1
82797: PUSH
82798: LD_EXP 66
82802: PUSH
82803: LD_VAR 0 3
82807: ARRAY
82808: IN
82809: IFFALSE 83432
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82811: LD_ADDR_EXP 66
82815: PUSH
82816: LD_EXP 66
82820: PPUSH
82821: LD_VAR 0 3
82825: PPUSH
82826: LD_EXP 66
82830: PUSH
82831: LD_VAR 0 3
82835: ARRAY
82836: PUSH
82837: LD_VAR 0 1
82841: DIFF
82842: PPUSH
82843: CALL_OW 1
82847: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82848: LD_ADDR_EXP 59
82852: PUSH
82853: LD_EXP 59
82857: PPUSH
82858: LD_VAR 0 3
82862: PUSH
82863: LD_EXP 59
82867: PUSH
82868: LD_VAR 0 3
82872: ARRAY
82873: PUSH
82874: LD_INT 1
82876: PLUS
82877: PUSH
82878: EMPTY
82879: LIST
82880: LIST
82881: PPUSH
82882: LD_VAR 0 1
82886: PPUSH
82887: CALL 19726 0 3
82891: ST_TO_ADDR
// btype := GetBType ( building ) ;
82892: LD_ADDR_VAR 0 5
82896: PUSH
82897: LD_VAR 0 1
82901: PPUSH
82902: CALL_OW 266
82906: ST_TO_ADDR
// side := GetSide ( building ) ;
82907: LD_ADDR_VAR 0 8
82911: PUSH
82912: LD_VAR 0 1
82916: PPUSH
82917: CALL_OW 255
82921: ST_TO_ADDR
// if btype = b_lab then
82922: LD_VAR 0 5
82926: PUSH
82927: LD_INT 6
82929: EQUAL
82930: IFFALSE 82980
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
82932: LD_ADDR_EXP 92
82936: PUSH
82937: LD_EXP 92
82941: PPUSH
82942: LD_VAR 0 3
82946: PUSH
82947: LD_EXP 92
82951: PUSH
82952: LD_VAR 0 3
82956: ARRAY
82957: PUSH
82958: LD_INT 1
82960: PLUS
82961: PUSH
82962: EMPTY
82963: LIST
82964: LIST
82965: PPUSH
82966: LD_VAR 0 1
82970: PPUSH
82971: CALL 19726 0 3
82975: ST_TO_ADDR
// exit ;
82976: POP
82977: POP
82978: GO 83436
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
82980: LD_VAR 0 5
82984: PUSH
82985: LD_INT 0
82987: PUSH
82988: LD_INT 2
82990: PUSH
82991: LD_INT 4
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: LIST
82998: IN
82999: IFFALSE 83123
// begin if btype = b_armoury then
83001: LD_VAR 0 5
83005: PUSH
83006: LD_INT 4
83008: EQUAL
83009: IFFALSE 83019
// btype := b_barracks ;
83011: LD_ADDR_VAR 0 5
83015: PUSH
83016: LD_INT 5
83018: ST_TO_ADDR
// if btype = b_depot then
83019: LD_VAR 0 5
83023: PUSH
83024: LD_INT 0
83026: EQUAL
83027: IFFALSE 83037
// btype := b_warehouse ;
83029: LD_ADDR_VAR 0 5
83033: PUSH
83034: LD_INT 1
83036: ST_TO_ADDR
// if btype = b_workshop then
83037: LD_VAR 0 5
83041: PUSH
83042: LD_INT 2
83044: EQUAL
83045: IFFALSE 83055
// btype := b_factory ;
83047: LD_ADDR_VAR 0 5
83051: PUSH
83052: LD_INT 3
83054: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
83055: LD_VAR 0 5
83059: PPUSH
83060: LD_VAR 0 8
83064: PPUSH
83065: CALL_OW 323
83069: PUSH
83070: LD_INT 1
83072: EQUAL
83073: IFFALSE 83119
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
83075: LD_ADDR_EXP 91
83079: PUSH
83080: LD_EXP 91
83084: PPUSH
83085: LD_VAR 0 3
83089: PUSH
83090: LD_EXP 91
83094: PUSH
83095: LD_VAR 0 3
83099: ARRAY
83100: PUSH
83101: LD_INT 1
83103: PLUS
83104: PUSH
83105: EMPTY
83106: LIST
83107: LIST
83108: PPUSH
83109: LD_VAR 0 1
83113: PPUSH
83114: CALL 19726 0 3
83118: ST_TO_ADDR
// exit ;
83119: POP
83120: POP
83121: GO 83436
// end ; if btype in [ b_bunker , b_turret ] then
83123: LD_VAR 0 5
83127: PUSH
83128: LD_INT 32
83130: PUSH
83131: LD_INT 33
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: IN
83138: IFFALSE 83428
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
83140: LD_ADDR_EXP 67
83144: PUSH
83145: LD_EXP 67
83149: PPUSH
83150: LD_VAR 0 3
83154: PUSH
83155: LD_EXP 67
83159: PUSH
83160: LD_VAR 0 3
83164: ARRAY
83165: PUSH
83166: LD_INT 1
83168: PLUS
83169: PUSH
83170: EMPTY
83171: LIST
83172: LIST
83173: PPUSH
83174: LD_VAR 0 1
83178: PPUSH
83179: CALL 19726 0 3
83183: ST_TO_ADDR
// if btype = b_bunker then
83184: LD_VAR 0 5
83188: PUSH
83189: LD_INT 32
83191: EQUAL
83192: IFFALSE 83428
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83194: LD_ADDR_EXP 68
83198: PUSH
83199: LD_EXP 68
83203: PPUSH
83204: LD_VAR 0 3
83208: PUSH
83209: LD_EXP 68
83213: PUSH
83214: LD_VAR 0 3
83218: ARRAY
83219: PUSH
83220: LD_INT 1
83222: PLUS
83223: PUSH
83224: EMPTY
83225: LIST
83226: LIST
83227: PPUSH
83228: LD_VAR 0 1
83232: PPUSH
83233: CALL 19726 0 3
83237: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
83238: LD_ADDR_VAR 0 6
83242: PUSH
83243: LD_EXP 59
83247: PUSH
83248: LD_VAR 0 3
83252: ARRAY
83253: PPUSH
83254: LD_INT 25
83256: PUSH
83257: LD_INT 1
83259: PUSH
83260: EMPTY
83261: LIST
83262: LIST
83263: PUSH
83264: LD_INT 3
83266: PUSH
83267: LD_INT 54
83269: PUSH
83270: EMPTY
83271: LIST
83272: PUSH
83273: EMPTY
83274: LIST
83275: LIST
83276: PUSH
83277: EMPTY
83278: LIST
83279: LIST
83280: PPUSH
83281: CALL_OW 72
83285: ST_TO_ADDR
// if tmp then
83286: LD_VAR 0 6
83290: IFFALSE 83296
// exit ;
83292: POP
83293: POP
83294: GO 83436
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
83296: LD_ADDR_VAR 0 6
83300: PUSH
83301: LD_EXP 59
83305: PUSH
83306: LD_VAR 0 3
83310: ARRAY
83311: PPUSH
83312: LD_INT 2
83314: PUSH
83315: LD_INT 30
83317: PUSH
83318: LD_INT 4
83320: PUSH
83321: EMPTY
83322: LIST
83323: LIST
83324: PUSH
83325: LD_INT 30
83327: PUSH
83328: LD_INT 5
83330: PUSH
83331: EMPTY
83332: LIST
83333: LIST
83334: PUSH
83335: EMPTY
83336: LIST
83337: LIST
83338: LIST
83339: PPUSH
83340: CALL_OW 72
83344: ST_TO_ADDR
// if not tmp then
83345: LD_VAR 0 6
83349: NOT
83350: IFFALSE 83356
// exit ;
83352: POP
83353: POP
83354: GO 83436
// for j in tmp do
83356: LD_ADDR_VAR 0 4
83360: PUSH
83361: LD_VAR 0 6
83365: PUSH
83366: FOR_IN
83367: IFFALSE 83426
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
83369: LD_ADDR_VAR 0 7
83373: PUSH
83374: LD_VAR 0 4
83378: PPUSH
83379: CALL_OW 313
83383: PPUSH
83384: LD_INT 25
83386: PUSH
83387: LD_INT 1
83389: PUSH
83390: EMPTY
83391: LIST
83392: LIST
83393: PPUSH
83394: CALL_OW 72
83398: ST_TO_ADDR
// if units then
83399: LD_VAR 0 7
83403: IFFALSE 83424
// begin ComExitBuilding ( units [ 1 ] ) ;
83405: LD_VAR 0 7
83409: PUSH
83410: LD_INT 1
83412: ARRAY
83413: PPUSH
83414: CALL_OW 122
// exit ;
83418: POP
83419: POP
83420: POP
83421: POP
83422: GO 83436
// end ; end ;
83424: GO 83366
83426: POP
83427: POP
// end ; end ; exit ;
83428: POP
83429: POP
83430: GO 83436
// end ; end ;
83432: GO 82790
83434: POP
83435: POP
// end ;
83436: LD_VAR 0 2
83440: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
83441: LD_INT 0
83443: PPUSH
83444: PPUSH
83445: PPUSH
83446: PPUSH
83447: PPUSH
83448: PPUSH
83449: PPUSH
// if not mc_bases or not skirmish then
83450: LD_EXP 59
83454: NOT
83455: PUSH
83456: LD_EXP 57
83460: NOT
83461: OR
83462: IFFALSE 83466
// exit ;
83464: GO 83731
// btype := GetBType ( building ) ;
83466: LD_ADDR_VAR 0 6
83470: PUSH
83471: LD_VAR 0 1
83475: PPUSH
83476: CALL_OW 266
83480: ST_TO_ADDR
// x := GetX ( building ) ;
83481: LD_ADDR_VAR 0 7
83485: PUSH
83486: LD_VAR 0 1
83490: PPUSH
83491: CALL_OW 250
83495: ST_TO_ADDR
// y := GetY ( building ) ;
83496: LD_ADDR_VAR 0 8
83500: PUSH
83501: LD_VAR 0 1
83505: PPUSH
83506: CALL_OW 251
83510: ST_TO_ADDR
// d := GetDir ( building ) ;
83511: LD_ADDR_VAR 0 9
83515: PUSH
83516: LD_VAR 0 1
83520: PPUSH
83521: CALL_OW 254
83525: ST_TO_ADDR
// for i = 1 to mc_bases do
83526: LD_ADDR_VAR 0 4
83530: PUSH
83531: DOUBLE
83532: LD_INT 1
83534: DEC
83535: ST_TO_ADDR
83536: LD_EXP 59
83540: PUSH
83541: FOR_TO
83542: IFFALSE 83729
// begin if not mc_build_list [ i ] then
83544: LD_EXP 64
83548: PUSH
83549: LD_VAR 0 4
83553: ARRAY
83554: NOT
83555: IFFALSE 83559
// continue ;
83557: GO 83541
// for j := 1 to mc_build_list [ i ] do
83559: LD_ADDR_VAR 0 5
83563: PUSH
83564: DOUBLE
83565: LD_INT 1
83567: DEC
83568: ST_TO_ADDR
83569: LD_EXP 64
83573: PUSH
83574: LD_VAR 0 4
83578: ARRAY
83579: PUSH
83580: FOR_TO
83581: IFFALSE 83725
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
83583: LD_VAR 0 6
83587: PUSH
83588: LD_VAR 0 7
83592: PUSH
83593: LD_VAR 0 8
83597: PUSH
83598: LD_VAR 0 9
83602: PUSH
83603: EMPTY
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: PPUSH
83609: LD_EXP 64
83613: PUSH
83614: LD_VAR 0 4
83618: ARRAY
83619: PUSH
83620: LD_VAR 0 5
83624: ARRAY
83625: PPUSH
83626: CALL 25908 0 2
83630: IFFALSE 83723
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
83632: LD_ADDR_EXP 64
83636: PUSH
83637: LD_EXP 64
83641: PPUSH
83642: LD_VAR 0 4
83646: PPUSH
83647: LD_EXP 64
83651: PUSH
83652: LD_VAR 0 4
83656: ARRAY
83657: PPUSH
83658: LD_VAR 0 5
83662: PPUSH
83663: CALL_OW 3
83667: PPUSH
83668: CALL_OW 1
83672: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
83673: LD_ADDR_EXP 66
83677: PUSH
83678: LD_EXP 66
83682: PPUSH
83683: LD_VAR 0 4
83687: PUSH
83688: LD_EXP 66
83692: PUSH
83693: LD_VAR 0 4
83697: ARRAY
83698: PUSH
83699: LD_INT 1
83701: PLUS
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: PPUSH
83707: LD_VAR 0 1
83711: PPUSH
83712: CALL 19726 0 3
83716: ST_TO_ADDR
// exit ;
83717: POP
83718: POP
83719: POP
83720: POP
83721: GO 83731
// end ;
83723: GO 83580
83725: POP
83726: POP
// end ;
83727: GO 83541
83729: POP
83730: POP
// end ;
83731: LD_VAR 0 3
83735: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
83736: LD_INT 0
83738: PPUSH
83739: PPUSH
83740: PPUSH
// if not mc_bases or not skirmish then
83741: LD_EXP 59
83745: NOT
83746: PUSH
83747: LD_EXP 57
83751: NOT
83752: OR
83753: IFFALSE 83757
// exit ;
83755: GO 83947
// for i = 1 to mc_bases do
83757: LD_ADDR_VAR 0 4
83761: PUSH
83762: DOUBLE
83763: LD_INT 1
83765: DEC
83766: ST_TO_ADDR
83767: LD_EXP 59
83771: PUSH
83772: FOR_TO
83773: IFFALSE 83860
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
83775: LD_VAR 0 1
83779: PUSH
83780: LD_EXP 67
83784: PUSH
83785: LD_VAR 0 4
83789: ARRAY
83790: IN
83791: PUSH
83792: LD_VAR 0 1
83796: PUSH
83797: LD_EXP 68
83801: PUSH
83802: LD_VAR 0 4
83806: ARRAY
83807: IN
83808: NOT
83809: AND
83810: IFFALSE 83858
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83812: LD_ADDR_EXP 68
83816: PUSH
83817: LD_EXP 68
83821: PPUSH
83822: LD_VAR 0 4
83826: PUSH
83827: LD_EXP 68
83831: PUSH
83832: LD_VAR 0 4
83836: ARRAY
83837: PUSH
83838: LD_INT 1
83840: PLUS
83841: PUSH
83842: EMPTY
83843: LIST
83844: LIST
83845: PPUSH
83846: LD_VAR 0 1
83850: PPUSH
83851: CALL 19726 0 3
83855: ST_TO_ADDR
// break ;
83856: GO 83860
// end ; end ;
83858: GO 83772
83860: POP
83861: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
83862: LD_VAR 0 1
83866: PPUSH
83867: CALL_OW 257
83871: PUSH
83872: LD_EXP 85
83876: IN
83877: PUSH
83878: LD_VAR 0 1
83882: PPUSH
83883: CALL_OW 266
83887: PUSH
83888: LD_INT 5
83890: EQUAL
83891: AND
83892: PUSH
83893: LD_VAR 0 2
83897: PPUSH
83898: CALL_OW 110
83902: PUSH
83903: LD_INT 18
83905: NONEQUAL
83906: AND
83907: IFFALSE 83947
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
83909: LD_VAR 0 2
83913: PPUSH
83914: CALL_OW 257
83918: PUSH
83919: LD_INT 5
83921: PUSH
83922: LD_INT 8
83924: PUSH
83925: LD_INT 9
83927: PUSH
83928: EMPTY
83929: LIST
83930: LIST
83931: LIST
83932: IN
83933: IFFALSE 83947
// SetClass ( unit , 1 ) ;
83935: LD_VAR 0 2
83939: PPUSH
83940: LD_INT 1
83942: PPUSH
83943: CALL_OW 336
// end ;
83947: LD_VAR 0 3
83951: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
83952: LD_INT 0
83954: PPUSH
83955: PPUSH
// if not mc_bases or not skirmish then
83956: LD_EXP 59
83960: NOT
83961: PUSH
83962: LD_EXP 57
83966: NOT
83967: OR
83968: IFFALSE 83972
// exit ;
83970: GO 84088
// if GetLives ( abandoned_vehicle ) > 250 then
83972: LD_VAR 0 2
83976: PPUSH
83977: CALL_OW 256
83981: PUSH
83982: LD_INT 250
83984: GREATER
83985: IFFALSE 83989
// exit ;
83987: GO 84088
// for i = 1 to mc_bases do
83989: LD_ADDR_VAR 0 6
83993: PUSH
83994: DOUBLE
83995: LD_INT 1
83997: DEC
83998: ST_TO_ADDR
83999: LD_EXP 59
84003: PUSH
84004: FOR_TO
84005: IFFALSE 84086
// begin if driver in mc_bases [ i ] then
84007: LD_VAR 0 1
84011: PUSH
84012: LD_EXP 59
84016: PUSH
84017: LD_VAR 0 6
84021: ARRAY
84022: IN
84023: IFFALSE 84084
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
84025: LD_VAR 0 1
84029: PPUSH
84030: LD_EXP 59
84034: PUSH
84035: LD_VAR 0 6
84039: ARRAY
84040: PPUSH
84041: LD_INT 2
84043: PUSH
84044: LD_INT 30
84046: PUSH
84047: LD_INT 0
84049: PUSH
84050: EMPTY
84051: LIST
84052: LIST
84053: PUSH
84054: LD_INT 30
84056: PUSH
84057: LD_INT 1
84059: PUSH
84060: EMPTY
84061: LIST
84062: LIST
84063: PUSH
84064: EMPTY
84065: LIST
84066: LIST
84067: LIST
84068: PPUSH
84069: CALL_OW 72
84073: PUSH
84074: LD_INT 1
84076: ARRAY
84077: PPUSH
84078: CALL 52344 0 2
// break ;
84082: GO 84086
// end ; end ;
84084: GO 84004
84086: POP
84087: POP
// end ; end_of_file
84088: LD_VAR 0 5
84092: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
84093: LD_INT 0
84095: PPUSH
// ar_miner := 81 ;
84096: LD_ADDR_EXP 110
84100: PUSH
84101: LD_INT 81
84103: ST_TO_ADDR
// ar_crane := 88 ;
84104: LD_ADDR_EXP 109
84108: PUSH
84109: LD_INT 88
84111: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
84112: LD_ADDR_EXP 104
84116: PUSH
84117: LD_INT 89
84119: ST_TO_ADDR
// us_hack := 99 ;
84120: LD_ADDR_EXP 105
84124: PUSH
84125: LD_INT 99
84127: ST_TO_ADDR
// us_artillery := 97 ;
84128: LD_ADDR_EXP 106
84132: PUSH
84133: LD_INT 97
84135: ST_TO_ADDR
// ar_bio_bomb := 91 ;
84136: LD_ADDR_EXP 107
84140: PUSH
84141: LD_INT 91
84143: ST_TO_ADDR
// ar_mortar := 92 ;
84144: LD_ADDR_EXP 108
84148: PUSH
84149: LD_INT 92
84151: ST_TO_ADDR
// ru_radar := 98 ;
84152: LD_ADDR_EXP 103
84156: PUSH
84157: LD_INT 98
84159: ST_TO_ADDR
// tech_Artillery := 80 ;
84160: LD_ADDR_EXP 111
84164: PUSH
84165: LD_INT 80
84167: ST_TO_ADDR
// tech_RadMat := 81 ;
84168: LD_ADDR_EXP 112
84172: PUSH
84173: LD_INT 81
84175: ST_TO_ADDR
// tech_BasicTools := 82 ;
84176: LD_ADDR_EXP 113
84180: PUSH
84181: LD_INT 82
84183: ST_TO_ADDR
// tech_Cargo := 83 ;
84184: LD_ADDR_EXP 114
84188: PUSH
84189: LD_INT 83
84191: ST_TO_ADDR
// tech_Track := 84 ;
84192: LD_ADDR_EXP 115
84196: PUSH
84197: LD_INT 84
84199: ST_TO_ADDR
// tech_Crane := 85 ;
84200: LD_ADDR_EXP 116
84204: PUSH
84205: LD_INT 85
84207: ST_TO_ADDR
// tech_Bulldozer := 86 ;
84208: LD_ADDR_EXP 117
84212: PUSH
84213: LD_INT 86
84215: ST_TO_ADDR
// tech_Hovercraft := 87 ;
84216: LD_ADDR_EXP 118
84220: PUSH
84221: LD_INT 87
84223: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
84224: LD_ADDR_EXP 119
84228: PUSH
84229: LD_INT 88
84231: ST_TO_ADDR
// class_mastodont := 31 ;
84232: LD_ADDR_EXP 120
84236: PUSH
84237: LD_INT 31
84239: ST_TO_ADDR
// class_horse := 21 ;
84240: LD_ADDR_EXP 121
84244: PUSH
84245: LD_INT 21
84247: ST_TO_ADDR
// end ;
84248: LD_VAR 0 1
84252: RET
// every 1 do
84253: GO 84255
84255: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
84256: CALL 84093 0 0
84260: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
84261: LD_INT 0
84263: PPUSH
// if p2 = 100 then
84264: LD_VAR 0 2
84268: PUSH
84269: LD_INT 100
84271: EQUAL
84272: IFFALSE 85221
// begin if not StreamModeActive then
84274: LD_EXP 122
84278: NOT
84279: IFFALSE 84289
// StreamModeActive := true ;
84281: LD_ADDR_EXP 122
84285: PUSH
84286: LD_INT 1
84288: ST_TO_ADDR
// if p3 = 0 then
84289: LD_VAR 0 3
84293: PUSH
84294: LD_INT 0
84296: EQUAL
84297: IFFALSE 84303
// InitStreamMode ;
84299: CALL 85381 0 0
// if p3 = 1 then
84303: LD_VAR 0 3
84307: PUSH
84308: LD_INT 1
84310: EQUAL
84311: IFFALSE 84321
// sRocket := true ;
84313: LD_ADDR_EXP 127
84317: PUSH
84318: LD_INT 1
84320: ST_TO_ADDR
// if p3 = 2 then
84321: LD_VAR 0 3
84325: PUSH
84326: LD_INT 2
84328: EQUAL
84329: IFFALSE 84339
// sSpeed := true ;
84331: LD_ADDR_EXP 126
84335: PUSH
84336: LD_INT 1
84338: ST_TO_ADDR
// if p3 = 3 then
84339: LD_VAR 0 3
84343: PUSH
84344: LD_INT 3
84346: EQUAL
84347: IFFALSE 84357
// sEngine := true ;
84349: LD_ADDR_EXP 128
84353: PUSH
84354: LD_INT 1
84356: ST_TO_ADDR
// if p3 = 4 then
84357: LD_VAR 0 3
84361: PUSH
84362: LD_INT 4
84364: EQUAL
84365: IFFALSE 84375
// sSpec := true ;
84367: LD_ADDR_EXP 125
84371: PUSH
84372: LD_INT 1
84374: ST_TO_ADDR
// if p3 = 5 then
84375: LD_VAR 0 3
84379: PUSH
84380: LD_INT 5
84382: EQUAL
84383: IFFALSE 84393
// sLevel := true ;
84385: LD_ADDR_EXP 129
84389: PUSH
84390: LD_INT 1
84392: ST_TO_ADDR
// if p3 = 6 then
84393: LD_VAR 0 3
84397: PUSH
84398: LD_INT 6
84400: EQUAL
84401: IFFALSE 84411
// sArmoury := true ;
84403: LD_ADDR_EXP 130
84407: PUSH
84408: LD_INT 1
84410: ST_TO_ADDR
// if p3 = 7 then
84411: LD_VAR 0 3
84415: PUSH
84416: LD_INT 7
84418: EQUAL
84419: IFFALSE 84429
// sRadar := true ;
84421: LD_ADDR_EXP 131
84425: PUSH
84426: LD_INT 1
84428: ST_TO_ADDR
// if p3 = 8 then
84429: LD_VAR 0 3
84433: PUSH
84434: LD_INT 8
84436: EQUAL
84437: IFFALSE 84447
// sBunker := true ;
84439: LD_ADDR_EXP 132
84443: PUSH
84444: LD_INT 1
84446: ST_TO_ADDR
// if p3 = 9 then
84447: LD_VAR 0 3
84451: PUSH
84452: LD_INT 9
84454: EQUAL
84455: IFFALSE 84465
// sHack := true ;
84457: LD_ADDR_EXP 133
84461: PUSH
84462: LD_INT 1
84464: ST_TO_ADDR
// if p3 = 10 then
84465: LD_VAR 0 3
84469: PUSH
84470: LD_INT 10
84472: EQUAL
84473: IFFALSE 84483
// sFire := true ;
84475: LD_ADDR_EXP 134
84479: PUSH
84480: LD_INT 1
84482: ST_TO_ADDR
// if p3 = 11 then
84483: LD_VAR 0 3
84487: PUSH
84488: LD_INT 11
84490: EQUAL
84491: IFFALSE 84501
// sRefresh := true ;
84493: LD_ADDR_EXP 135
84497: PUSH
84498: LD_INT 1
84500: ST_TO_ADDR
// if p3 = 12 then
84501: LD_VAR 0 3
84505: PUSH
84506: LD_INT 12
84508: EQUAL
84509: IFFALSE 84519
// sExp := true ;
84511: LD_ADDR_EXP 136
84515: PUSH
84516: LD_INT 1
84518: ST_TO_ADDR
// if p3 = 13 then
84519: LD_VAR 0 3
84523: PUSH
84524: LD_INT 13
84526: EQUAL
84527: IFFALSE 84537
// sDepot := true ;
84529: LD_ADDR_EXP 137
84533: PUSH
84534: LD_INT 1
84536: ST_TO_ADDR
// if p3 = 14 then
84537: LD_VAR 0 3
84541: PUSH
84542: LD_INT 14
84544: EQUAL
84545: IFFALSE 84555
// sFlag := true ;
84547: LD_ADDR_EXP 138
84551: PUSH
84552: LD_INT 1
84554: ST_TO_ADDR
// if p3 = 15 then
84555: LD_VAR 0 3
84559: PUSH
84560: LD_INT 15
84562: EQUAL
84563: IFFALSE 84573
// sKamikadze := true ;
84565: LD_ADDR_EXP 146
84569: PUSH
84570: LD_INT 1
84572: ST_TO_ADDR
// if p3 = 16 then
84573: LD_VAR 0 3
84577: PUSH
84578: LD_INT 16
84580: EQUAL
84581: IFFALSE 84591
// sTroll := true ;
84583: LD_ADDR_EXP 147
84587: PUSH
84588: LD_INT 1
84590: ST_TO_ADDR
// if p3 = 17 then
84591: LD_VAR 0 3
84595: PUSH
84596: LD_INT 17
84598: EQUAL
84599: IFFALSE 84609
// sSlow := true ;
84601: LD_ADDR_EXP 148
84605: PUSH
84606: LD_INT 1
84608: ST_TO_ADDR
// if p3 = 18 then
84609: LD_VAR 0 3
84613: PUSH
84614: LD_INT 18
84616: EQUAL
84617: IFFALSE 84627
// sLack := true ;
84619: LD_ADDR_EXP 149
84623: PUSH
84624: LD_INT 1
84626: ST_TO_ADDR
// if p3 = 19 then
84627: LD_VAR 0 3
84631: PUSH
84632: LD_INT 19
84634: EQUAL
84635: IFFALSE 84645
// sTank := true ;
84637: LD_ADDR_EXP 151
84641: PUSH
84642: LD_INT 1
84644: ST_TO_ADDR
// if p3 = 20 then
84645: LD_VAR 0 3
84649: PUSH
84650: LD_INT 20
84652: EQUAL
84653: IFFALSE 84663
// sRemote := true ;
84655: LD_ADDR_EXP 152
84659: PUSH
84660: LD_INT 1
84662: ST_TO_ADDR
// if p3 = 21 then
84663: LD_VAR 0 3
84667: PUSH
84668: LD_INT 21
84670: EQUAL
84671: IFFALSE 84681
// sPowell := true ;
84673: LD_ADDR_EXP 153
84677: PUSH
84678: LD_INT 1
84680: ST_TO_ADDR
// if p3 = 22 then
84681: LD_VAR 0 3
84685: PUSH
84686: LD_INT 22
84688: EQUAL
84689: IFFALSE 84699
// sTeleport := true ;
84691: LD_ADDR_EXP 156
84695: PUSH
84696: LD_INT 1
84698: ST_TO_ADDR
// if p3 = 23 then
84699: LD_VAR 0 3
84703: PUSH
84704: LD_INT 23
84706: EQUAL
84707: IFFALSE 84717
// sOilTower := true ;
84709: LD_ADDR_EXP 158
84713: PUSH
84714: LD_INT 1
84716: ST_TO_ADDR
// if p3 = 24 then
84717: LD_VAR 0 3
84721: PUSH
84722: LD_INT 24
84724: EQUAL
84725: IFFALSE 84735
// sShovel := true ;
84727: LD_ADDR_EXP 159
84731: PUSH
84732: LD_INT 1
84734: ST_TO_ADDR
// if p3 = 25 then
84735: LD_VAR 0 3
84739: PUSH
84740: LD_INT 25
84742: EQUAL
84743: IFFALSE 84753
// sSheik := true ;
84745: LD_ADDR_EXP 160
84749: PUSH
84750: LD_INT 1
84752: ST_TO_ADDR
// if p3 = 26 then
84753: LD_VAR 0 3
84757: PUSH
84758: LD_INT 26
84760: EQUAL
84761: IFFALSE 84771
// sEarthquake := true ;
84763: LD_ADDR_EXP 162
84767: PUSH
84768: LD_INT 1
84770: ST_TO_ADDR
// if p3 = 27 then
84771: LD_VAR 0 3
84775: PUSH
84776: LD_INT 27
84778: EQUAL
84779: IFFALSE 84789
// sAI := true ;
84781: LD_ADDR_EXP 163
84785: PUSH
84786: LD_INT 1
84788: ST_TO_ADDR
// if p3 = 28 then
84789: LD_VAR 0 3
84793: PUSH
84794: LD_INT 28
84796: EQUAL
84797: IFFALSE 84807
// sCargo := true ;
84799: LD_ADDR_EXP 166
84803: PUSH
84804: LD_INT 1
84806: ST_TO_ADDR
// if p3 = 29 then
84807: LD_VAR 0 3
84811: PUSH
84812: LD_INT 29
84814: EQUAL
84815: IFFALSE 84825
// sDLaser := true ;
84817: LD_ADDR_EXP 167
84821: PUSH
84822: LD_INT 1
84824: ST_TO_ADDR
// if p3 = 30 then
84825: LD_VAR 0 3
84829: PUSH
84830: LD_INT 30
84832: EQUAL
84833: IFFALSE 84843
// sExchange := true ;
84835: LD_ADDR_EXP 168
84839: PUSH
84840: LD_INT 1
84842: ST_TO_ADDR
// if p3 = 31 then
84843: LD_VAR 0 3
84847: PUSH
84848: LD_INT 31
84850: EQUAL
84851: IFFALSE 84861
// sFac := true ;
84853: LD_ADDR_EXP 169
84857: PUSH
84858: LD_INT 1
84860: ST_TO_ADDR
// if p3 = 32 then
84861: LD_VAR 0 3
84865: PUSH
84866: LD_INT 32
84868: EQUAL
84869: IFFALSE 84879
// sPower := true ;
84871: LD_ADDR_EXP 170
84875: PUSH
84876: LD_INT 1
84878: ST_TO_ADDR
// if p3 = 33 then
84879: LD_VAR 0 3
84883: PUSH
84884: LD_INT 33
84886: EQUAL
84887: IFFALSE 84897
// sRandom := true ;
84889: LD_ADDR_EXP 171
84893: PUSH
84894: LD_INT 1
84896: ST_TO_ADDR
// if p3 = 34 then
84897: LD_VAR 0 3
84901: PUSH
84902: LD_INT 34
84904: EQUAL
84905: IFFALSE 84915
// sShield := true ;
84907: LD_ADDR_EXP 172
84911: PUSH
84912: LD_INT 1
84914: ST_TO_ADDR
// if p3 = 35 then
84915: LD_VAR 0 3
84919: PUSH
84920: LD_INT 35
84922: EQUAL
84923: IFFALSE 84933
// sTime := true ;
84925: LD_ADDR_EXP 173
84929: PUSH
84930: LD_INT 1
84932: ST_TO_ADDR
// if p3 = 36 then
84933: LD_VAR 0 3
84937: PUSH
84938: LD_INT 36
84940: EQUAL
84941: IFFALSE 84951
// sTools := true ;
84943: LD_ADDR_EXP 174
84947: PUSH
84948: LD_INT 1
84950: ST_TO_ADDR
// if p3 = 101 then
84951: LD_VAR 0 3
84955: PUSH
84956: LD_INT 101
84958: EQUAL
84959: IFFALSE 84969
// sSold := true ;
84961: LD_ADDR_EXP 139
84965: PUSH
84966: LD_INT 1
84968: ST_TO_ADDR
// if p3 = 102 then
84969: LD_VAR 0 3
84973: PUSH
84974: LD_INT 102
84976: EQUAL
84977: IFFALSE 84987
// sDiff := true ;
84979: LD_ADDR_EXP 140
84983: PUSH
84984: LD_INT 1
84986: ST_TO_ADDR
// if p3 = 103 then
84987: LD_VAR 0 3
84991: PUSH
84992: LD_INT 103
84994: EQUAL
84995: IFFALSE 85005
// sFog := true ;
84997: LD_ADDR_EXP 143
85001: PUSH
85002: LD_INT 1
85004: ST_TO_ADDR
// if p3 = 104 then
85005: LD_VAR 0 3
85009: PUSH
85010: LD_INT 104
85012: EQUAL
85013: IFFALSE 85023
// sReset := true ;
85015: LD_ADDR_EXP 144
85019: PUSH
85020: LD_INT 1
85022: ST_TO_ADDR
// if p3 = 105 then
85023: LD_VAR 0 3
85027: PUSH
85028: LD_INT 105
85030: EQUAL
85031: IFFALSE 85041
// sSun := true ;
85033: LD_ADDR_EXP 145
85037: PUSH
85038: LD_INT 1
85040: ST_TO_ADDR
// if p3 = 106 then
85041: LD_VAR 0 3
85045: PUSH
85046: LD_INT 106
85048: EQUAL
85049: IFFALSE 85059
// sTiger := true ;
85051: LD_ADDR_EXP 141
85055: PUSH
85056: LD_INT 1
85058: ST_TO_ADDR
// if p3 = 107 then
85059: LD_VAR 0 3
85063: PUSH
85064: LD_INT 107
85066: EQUAL
85067: IFFALSE 85077
// sBomb := true ;
85069: LD_ADDR_EXP 142
85073: PUSH
85074: LD_INT 1
85076: ST_TO_ADDR
// if p3 = 108 then
85077: LD_VAR 0 3
85081: PUSH
85082: LD_INT 108
85084: EQUAL
85085: IFFALSE 85095
// sWound := true ;
85087: LD_ADDR_EXP 150
85091: PUSH
85092: LD_INT 1
85094: ST_TO_ADDR
// if p3 = 109 then
85095: LD_VAR 0 3
85099: PUSH
85100: LD_INT 109
85102: EQUAL
85103: IFFALSE 85113
// sBetray := true ;
85105: LD_ADDR_EXP 154
85109: PUSH
85110: LD_INT 1
85112: ST_TO_ADDR
// if p3 = 110 then
85113: LD_VAR 0 3
85117: PUSH
85118: LD_INT 110
85120: EQUAL
85121: IFFALSE 85131
// sContamin := true ;
85123: LD_ADDR_EXP 155
85127: PUSH
85128: LD_INT 1
85130: ST_TO_ADDR
// if p3 = 111 then
85131: LD_VAR 0 3
85135: PUSH
85136: LD_INT 111
85138: EQUAL
85139: IFFALSE 85149
// sOil := true ;
85141: LD_ADDR_EXP 157
85145: PUSH
85146: LD_INT 1
85148: ST_TO_ADDR
// if p3 = 112 then
85149: LD_VAR 0 3
85153: PUSH
85154: LD_INT 112
85156: EQUAL
85157: IFFALSE 85167
// sStu := true ;
85159: LD_ADDR_EXP 161
85163: PUSH
85164: LD_INT 1
85166: ST_TO_ADDR
// if p3 = 113 then
85167: LD_VAR 0 3
85171: PUSH
85172: LD_INT 113
85174: EQUAL
85175: IFFALSE 85185
// sBazooka := true ;
85177: LD_ADDR_EXP 164
85181: PUSH
85182: LD_INT 1
85184: ST_TO_ADDR
// if p3 = 114 then
85185: LD_VAR 0 3
85189: PUSH
85190: LD_INT 114
85192: EQUAL
85193: IFFALSE 85203
// sMortar := true ;
85195: LD_ADDR_EXP 165
85199: PUSH
85200: LD_INT 1
85202: ST_TO_ADDR
// if p3 = 115 then
85203: LD_VAR 0 3
85207: PUSH
85208: LD_INT 115
85210: EQUAL
85211: IFFALSE 85221
// sRanger := true ;
85213: LD_ADDR_EXP 175
85217: PUSH
85218: LD_INT 1
85220: ST_TO_ADDR
// end ; if p2 = 101 then
85221: LD_VAR 0 2
85225: PUSH
85226: LD_INT 101
85228: EQUAL
85229: IFFALSE 85357
// begin case p3 of 1 :
85231: LD_VAR 0 3
85235: PUSH
85236: LD_INT 1
85238: DOUBLE
85239: EQUAL
85240: IFTRUE 85244
85242: GO 85251
85244: POP
// hHackUnlimitedResources ; 2 :
85245: CALL 96394 0 0
85249: GO 85357
85251: LD_INT 2
85253: DOUBLE
85254: EQUAL
85255: IFTRUE 85259
85257: GO 85266
85259: POP
// hHackSetLevel10 ; 3 :
85260: CALL 96527 0 0
85264: GO 85357
85266: LD_INT 3
85268: DOUBLE
85269: EQUAL
85270: IFTRUE 85274
85272: GO 85281
85274: POP
// hHackSetLevel10YourUnits ; 4 :
85275: CALL 96612 0 0
85279: GO 85357
85281: LD_INT 4
85283: DOUBLE
85284: EQUAL
85285: IFTRUE 85289
85287: GO 85296
85289: POP
// hHackInvincible ; 5 :
85290: CALL 97060 0 0
85294: GO 85357
85296: LD_INT 5
85298: DOUBLE
85299: EQUAL
85300: IFTRUE 85304
85302: GO 85311
85304: POP
// hHackInvisible ; 6 :
85305: CALL 97171 0 0
85309: GO 85357
85311: LD_INT 6
85313: DOUBLE
85314: EQUAL
85315: IFTRUE 85319
85317: GO 85326
85319: POP
// hHackChangeYourSide ; 7 :
85320: CALL 97228 0 0
85324: GO 85357
85326: LD_INT 7
85328: DOUBLE
85329: EQUAL
85330: IFTRUE 85334
85332: GO 85341
85334: POP
// hHackChangeUnitSide ; 8 :
85335: CALL 97270 0 0
85339: GO 85357
85341: LD_INT 8
85343: DOUBLE
85344: EQUAL
85345: IFTRUE 85349
85347: GO 85356
85349: POP
// hHackFog ; end ;
85350: CALL 97371 0 0
85354: GO 85357
85356: POP
// end ; end ;
85357: LD_VAR 0 7
85361: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
85362: GO 85364
85364: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
85365: LD_STRING initStreamRollete();
85367: PPUSH
85368: CALL_OW 559
// InitStreamMode ;
85372: CALL 85381 0 0
// DefineStreamItems ( ) ;
85376: CALL 85821 0 0
// end ;
85380: END
// function InitStreamMode ; begin
85381: LD_INT 0
85383: PPUSH
// streamModeActive := false ;
85384: LD_ADDR_EXP 122
85388: PUSH
85389: LD_INT 0
85391: ST_TO_ADDR
// normalCounter := 36 ;
85392: LD_ADDR_EXP 123
85396: PUSH
85397: LD_INT 36
85399: ST_TO_ADDR
// hardcoreCounter := 16 ;
85400: LD_ADDR_EXP 124
85404: PUSH
85405: LD_INT 16
85407: ST_TO_ADDR
// sRocket := false ;
85408: LD_ADDR_EXP 127
85412: PUSH
85413: LD_INT 0
85415: ST_TO_ADDR
// sSpeed := false ;
85416: LD_ADDR_EXP 126
85420: PUSH
85421: LD_INT 0
85423: ST_TO_ADDR
// sEngine := false ;
85424: LD_ADDR_EXP 128
85428: PUSH
85429: LD_INT 0
85431: ST_TO_ADDR
// sSpec := false ;
85432: LD_ADDR_EXP 125
85436: PUSH
85437: LD_INT 0
85439: ST_TO_ADDR
// sLevel := false ;
85440: LD_ADDR_EXP 129
85444: PUSH
85445: LD_INT 0
85447: ST_TO_ADDR
// sArmoury := false ;
85448: LD_ADDR_EXP 130
85452: PUSH
85453: LD_INT 0
85455: ST_TO_ADDR
// sRadar := false ;
85456: LD_ADDR_EXP 131
85460: PUSH
85461: LD_INT 0
85463: ST_TO_ADDR
// sBunker := false ;
85464: LD_ADDR_EXP 132
85468: PUSH
85469: LD_INT 0
85471: ST_TO_ADDR
// sHack := false ;
85472: LD_ADDR_EXP 133
85476: PUSH
85477: LD_INT 0
85479: ST_TO_ADDR
// sFire := false ;
85480: LD_ADDR_EXP 134
85484: PUSH
85485: LD_INT 0
85487: ST_TO_ADDR
// sRefresh := false ;
85488: LD_ADDR_EXP 135
85492: PUSH
85493: LD_INT 0
85495: ST_TO_ADDR
// sExp := false ;
85496: LD_ADDR_EXP 136
85500: PUSH
85501: LD_INT 0
85503: ST_TO_ADDR
// sDepot := false ;
85504: LD_ADDR_EXP 137
85508: PUSH
85509: LD_INT 0
85511: ST_TO_ADDR
// sFlag := false ;
85512: LD_ADDR_EXP 138
85516: PUSH
85517: LD_INT 0
85519: ST_TO_ADDR
// sKamikadze := false ;
85520: LD_ADDR_EXP 146
85524: PUSH
85525: LD_INT 0
85527: ST_TO_ADDR
// sTroll := false ;
85528: LD_ADDR_EXP 147
85532: PUSH
85533: LD_INT 0
85535: ST_TO_ADDR
// sSlow := false ;
85536: LD_ADDR_EXP 148
85540: PUSH
85541: LD_INT 0
85543: ST_TO_ADDR
// sLack := false ;
85544: LD_ADDR_EXP 149
85548: PUSH
85549: LD_INT 0
85551: ST_TO_ADDR
// sTank := false ;
85552: LD_ADDR_EXP 151
85556: PUSH
85557: LD_INT 0
85559: ST_TO_ADDR
// sRemote := false ;
85560: LD_ADDR_EXP 152
85564: PUSH
85565: LD_INT 0
85567: ST_TO_ADDR
// sPowell := false ;
85568: LD_ADDR_EXP 153
85572: PUSH
85573: LD_INT 0
85575: ST_TO_ADDR
// sTeleport := false ;
85576: LD_ADDR_EXP 156
85580: PUSH
85581: LD_INT 0
85583: ST_TO_ADDR
// sOilTower := false ;
85584: LD_ADDR_EXP 158
85588: PUSH
85589: LD_INT 0
85591: ST_TO_ADDR
// sShovel := false ;
85592: LD_ADDR_EXP 159
85596: PUSH
85597: LD_INT 0
85599: ST_TO_ADDR
// sSheik := false ;
85600: LD_ADDR_EXP 160
85604: PUSH
85605: LD_INT 0
85607: ST_TO_ADDR
// sEarthquake := false ;
85608: LD_ADDR_EXP 162
85612: PUSH
85613: LD_INT 0
85615: ST_TO_ADDR
// sAI := false ;
85616: LD_ADDR_EXP 163
85620: PUSH
85621: LD_INT 0
85623: ST_TO_ADDR
// sCargo := false ;
85624: LD_ADDR_EXP 166
85628: PUSH
85629: LD_INT 0
85631: ST_TO_ADDR
// sDLaser := false ;
85632: LD_ADDR_EXP 167
85636: PUSH
85637: LD_INT 0
85639: ST_TO_ADDR
// sExchange := false ;
85640: LD_ADDR_EXP 168
85644: PUSH
85645: LD_INT 0
85647: ST_TO_ADDR
// sFac := false ;
85648: LD_ADDR_EXP 169
85652: PUSH
85653: LD_INT 0
85655: ST_TO_ADDR
// sPower := false ;
85656: LD_ADDR_EXP 170
85660: PUSH
85661: LD_INT 0
85663: ST_TO_ADDR
// sRandom := false ;
85664: LD_ADDR_EXP 171
85668: PUSH
85669: LD_INT 0
85671: ST_TO_ADDR
// sShield := false ;
85672: LD_ADDR_EXP 172
85676: PUSH
85677: LD_INT 0
85679: ST_TO_ADDR
// sTime := false ;
85680: LD_ADDR_EXP 173
85684: PUSH
85685: LD_INT 0
85687: ST_TO_ADDR
// sTools := false ;
85688: LD_ADDR_EXP 174
85692: PUSH
85693: LD_INT 0
85695: ST_TO_ADDR
// sSold := false ;
85696: LD_ADDR_EXP 139
85700: PUSH
85701: LD_INT 0
85703: ST_TO_ADDR
// sDiff := false ;
85704: LD_ADDR_EXP 140
85708: PUSH
85709: LD_INT 0
85711: ST_TO_ADDR
// sFog := false ;
85712: LD_ADDR_EXP 143
85716: PUSH
85717: LD_INT 0
85719: ST_TO_ADDR
// sReset := false ;
85720: LD_ADDR_EXP 144
85724: PUSH
85725: LD_INT 0
85727: ST_TO_ADDR
// sSun := false ;
85728: LD_ADDR_EXP 145
85732: PUSH
85733: LD_INT 0
85735: ST_TO_ADDR
// sTiger := false ;
85736: LD_ADDR_EXP 141
85740: PUSH
85741: LD_INT 0
85743: ST_TO_ADDR
// sBomb := false ;
85744: LD_ADDR_EXP 142
85748: PUSH
85749: LD_INT 0
85751: ST_TO_ADDR
// sWound := false ;
85752: LD_ADDR_EXP 150
85756: PUSH
85757: LD_INT 0
85759: ST_TO_ADDR
// sBetray := false ;
85760: LD_ADDR_EXP 154
85764: PUSH
85765: LD_INT 0
85767: ST_TO_ADDR
// sContamin := false ;
85768: LD_ADDR_EXP 155
85772: PUSH
85773: LD_INT 0
85775: ST_TO_ADDR
// sOil := false ;
85776: LD_ADDR_EXP 157
85780: PUSH
85781: LD_INT 0
85783: ST_TO_ADDR
// sStu := false ;
85784: LD_ADDR_EXP 161
85788: PUSH
85789: LD_INT 0
85791: ST_TO_ADDR
// sBazooka := false ;
85792: LD_ADDR_EXP 164
85796: PUSH
85797: LD_INT 0
85799: ST_TO_ADDR
// sMortar := false ;
85800: LD_ADDR_EXP 165
85804: PUSH
85805: LD_INT 0
85807: ST_TO_ADDR
// sRanger := false ;
85808: LD_ADDR_EXP 175
85812: PUSH
85813: LD_INT 0
85815: ST_TO_ADDR
// end ;
85816: LD_VAR 0 1
85820: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
85821: LD_INT 0
85823: PPUSH
85824: PPUSH
85825: PPUSH
85826: PPUSH
85827: PPUSH
// result := [ ] ;
85828: LD_ADDR_VAR 0 1
85832: PUSH
85833: EMPTY
85834: ST_TO_ADDR
// if campaign_id = 1 then
85835: LD_OWVAR 69
85839: PUSH
85840: LD_INT 1
85842: EQUAL
85843: IFFALSE 88781
// begin case mission_number of 1 :
85845: LD_OWVAR 70
85849: PUSH
85850: LD_INT 1
85852: DOUBLE
85853: EQUAL
85854: IFTRUE 85858
85856: GO 85922
85858: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
85859: LD_ADDR_VAR 0 1
85863: PUSH
85864: LD_INT 2
85866: PUSH
85867: LD_INT 4
85869: PUSH
85870: LD_INT 11
85872: PUSH
85873: LD_INT 12
85875: PUSH
85876: LD_INT 15
85878: PUSH
85879: LD_INT 16
85881: PUSH
85882: LD_INT 22
85884: PUSH
85885: LD_INT 23
85887: PUSH
85888: LD_INT 26
85890: PUSH
85891: EMPTY
85892: LIST
85893: LIST
85894: LIST
85895: LIST
85896: LIST
85897: LIST
85898: LIST
85899: LIST
85900: LIST
85901: PUSH
85902: LD_INT 101
85904: PUSH
85905: LD_INT 102
85907: PUSH
85908: LD_INT 106
85910: PUSH
85911: EMPTY
85912: LIST
85913: LIST
85914: LIST
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: ST_TO_ADDR
85920: GO 88779
85922: LD_INT 2
85924: DOUBLE
85925: EQUAL
85926: IFTRUE 85930
85928: GO 86002
85930: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
85931: LD_ADDR_VAR 0 1
85935: PUSH
85936: LD_INT 2
85938: PUSH
85939: LD_INT 4
85941: PUSH
85942: LD_INT 11
85944: PUSH
85945: LD_INT 12
85947: PUSH
85948: LD_INT 15
85950: PUSH
85951: LD_INT 16
85953: PUSH
85954: LD_INT 22
85956: PUSH
85957: LD_INT 23
85959: PUSH
85960: LD_INT 26
85962: PUSH
85963: EMPTY
85964: LIST
85965: LIST
85966: LIST
85967: LIST
85968: LIST
85969: LIST
85970: LIST
85971: LIST
85972: LIST
85973: PUSH
85974: LD_INT 101
85976: PUSH
85977: LD_INT 102
85979: PUSH
85980: LD_INT 105
85982: PUSH
85983: LD_INT 106
85985: PUSH
85986: LD_INT 108
85988: PUSH
85989: EMPTY
85990: LIST
85991: LIST
85992: LIST
85993: LIST
85994: LIST
85995: PUSH
85996: EMPTY
85997: LIST
85998: LIST
85999: ST_TO_ADDR
86000: GO 88779
86002: LD_INT 3
86004: DOUBLE
86005: EQUAL
86006: IFTRUE 86010
86008: GO 86086
86010: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
86011: LD_ADDR_VAR 0 1
86015: PUSH
86016: LD_INT 2
86018: PUSH
86019: LD_INT 4
86021: PUSH
86022: LD_INT 5
86024: PUSH
86025: LD_INT 11
86027: PUSH
86028: LD_INT 12
86030: PUSH
86031: LD_INT 15
86033: PUSH
86034: LD_INT 16
86036: PUSH
86037: LD_INT 22
86039: PUSH
86040: LD_INT 26
86042: PUSH
86043: LD_INT 36
86045: PUSH
86046: EMPTY
86047: LIST
86048: LIST
86049: LIST
86050: LIST
86051: LIST
86052: LIST
86053: LIST
86054: LIST
86055: LIST
86056: LIST
86057: PUSH
86058: LD_INT 101
86060: PUSH
86061: LD_INT 102
86063: PUSH
86064: LD_INT 105
86066: PUSH
86067: LD_INT 106
86069: PUSH
86070: LD_INT 108
86072: PUSH
86073: EMPTY
86074: LIST
86075: LIST
86076: LIST
86077: LIST
86078: LIST
86079: PUSH
86080: EMPTY
86081: LIST
86082: LIST
86083: ST_TO_ADDR
86084: GO 88779
86086: LD_INT 4
86088: DOUBLE
86089: EQUAL
86090: IFTRUE 86094
86092: GO 86178
86094: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
86095: LD_ADDR_VAR 0 1
86099: PUSH
86100: LD_INT 2
86102: PUSH
86103: LD_INT 4
86105: PUSH
86106: LD_INT 5
86108: PUSH
86109: LD_INT 8
86111: PUSH
86112: LD_INT 11
86114: PUSH
86115: LD_INT 12
86117: PUSH
86118: LD_INT 15
86120: PUSH
86121: LD_INT 16
86123: PUSH
86124: LD_INT 22
86126: PUSH
86127: LD_INT 23
86129: PUSH
86130: LD_INT 26
86132: PUSH
86133: LD_INT 36
86135: PUSH
86136: EMPTY
86137: LIST
86138: LIST
86139: LIST
86140: LIST
86141: LIST
86142: LIST
86143: LIST
86144: LIST
86145: LIST
86146: LIST
86147: LIST
86148: LIST
86149: PUSH
86150: LD_INT 101
86152: PUSH
86153: LD_INT 102
86155: PUSH
86156: LD_INT 105
86158: PUSH
86159: LD_INT 106
86161: PUSH
86162: LD_INT 108
86164: PUSH
86165: EMPTY
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: PUSH
86172: EMPTY
86173: LIST
86174: LIST
86175: ST_TO_ADDR
86176: GO 88779
86178: LD_INT 5
86180: DOUBLE
86181: EQUAL
86182: IFTRUE 86186
86184: GO 86286
86186: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
86187: LD_ADDR_VAR 0 1
86191: PUSH
86192: LD_INT 2
86194: PUSH
86195: LD_INT 4
86197: PUSH
86198: LD_INT 5
86200: PUSH
86201: LD_INT 6
86203: PUSH
86204: LD_INT 8
86206: PUSH
86207: LD_INT 11
86209: PUSH
86210: LD_INT 12
86212: PUSH
86213: LD_INT 15
86215: PUSH
86216: LD_INT 16
86218: PUSH
86219: LD_INT 22
86221: PUSH
86222: LD_INT 23
86224: PUSH
86225: LD_INT 25
86227: PUSH
86228: LD_INT 26
86230: PUSH
86231: LD_INT 36
86233: PUSH
86234: EMPTY
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: LIST
86241: LIST
86242: LIST
86243: LIST
86244: LIST
86245: LIST
86246: LIST
86247: LIST
86248: LIST
86249: PUSH
86250: LD_INT 101
86252: PUSH
86253: LD_INT 102
86255: PUSH
86256: LD_INT 105
86258: PUSH
86259: LD_INT 106
86261: PUSH
86262: LD_INT 108
86264: PUSH
86265: LD_INT 109
86267: PUSH
86268: LD_INT 112
86270: PUSH
86271: EMPTY
86272: LIST
86273: LIST
86274: LIST
86275: LIST
86276: LIST
86277: LIST
86278: LIST
86279: PUSH
86280: EMPTY
86281: LIST
86282: LIST
86283: ST_TO_ADDR
86284: GO 88779
86286: LD_INT 6
86288: DOUBLE
86289: EQUAL
86290: IFTRUE 86294
86292: GO 86414
86294: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
86295: LD_ADDR_VAR 0 1
86299: PUSH
86300: LD_INT 2
86302: PUSH
86303: LD_INT 4
86305: PUSH
86306: LD_INT 5
86308: PUSH
86309: LD_INT 6
86311: PUSH
86312: LD_INT 8
86314: PUSH
86315: LD_INT 11
86317: PUSH
86318: LD_INT 12
86320: PUSH
86321: LD_INT 15
86323: PUSH
86324: LD_INT 16
86326: PUSH
86327: LD_INT 20
86329: PUSH
86330: LD_INT 21
86332: PUSH
86333: LD_INT 22
86335: PUSH
86336: LD_INT 23
86338: PUSH
86339: LD_INT 25
86341: PUSH
86342: LD_INT 26
86344: PUSH
86345: LD_INT 30
86347: PUSH
86348: LD_INT 31
86350: PUSH
86351: LD_INT 32
86353: PUSH
86354: LD_INT 36
86356: PUSH
86357: EMPTY
86358: LIST
86359: LIST
86360: LIST
86361: LIST
86362: LIST
86363: LIST
86364: LIST
86365: LIST
86366: LIST
86367: LIST
86368: LIST
86369: LIST
86370: LIST
86371: LIST
86372: LIST
86373: LIST
86374: LIST
86375: LIST
86376: LIST
86377: PUSH
86378: LD_INT 101
86380: PUSH
86381: LD_INT 102
86383: PUSH
86384: LD_INT 105
86386: PUSH
86387: LD_INT 106
86389: PUSH
86390: LD_INT 108
86392: PUSH
86393: LD_INT 109
86395: PUSH
86396: LD_INT 112
86398: PUSH
86399: EMPTY
86400: LIST
86401: LIST
86402: LIST
86403: LIST
86404: LIST
86405: LIST
86406: LIST
86407: PUSH
86408: EMPTY
86409: LIST
86410: LIST
86411: ST_TO_ADDR
86412: GO 88779
86414: LD_INT 7
86416: DOUBLE
86417: EQUAL
86418: IFTRUE 86422
86420: GO 86522
86422: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
86423: LD_ADDR_VAR 0 1
86427: PUSH
86428: LD_INT 2
86430: PUSH
86431: LD_INT 4
86433: PUSH
86434: LD_INT 5
86436: PUSH
86437: LD_INT 7
86439: PUSH
86440: LD_INT 11
86442: PUSH
86443: LD_INT 12
86445: PUSH
86446: LD_INT 15
86448: PUSH
86449: LD_INT 16
86451: PUSH
86452: LD_INT 20
86454: PUSH
86455: LD_INT 21
86457: PUSH
86458: LD_INT 22
86460: PUSH
86461: LD_INT 23
86463: PUSH
86464: LD_INT 25
86466: PUSH
86467: LD_INT 26
86469: PUSH
86470: EMPTY
86471: LIST
86472: LIST
86473: LIST
86474: LIST
86475: LIST
86476: LIST
86477: LIST
86478: LIST
86479: LIST
86480: LIST
86481: LIST
86482: LIST
86483: LIST
86484: LIST
86485: PUSH
86486: LD_INT 101
86488: PUSH
86489: LD_INT 102
86491: PUSH
86492: LD_INT 103
86494: PUSH
86495: LD_INT 105
86497: PUSH
86498: LD_INT 106
86500: PUSH
86501: LD_INT 108
86503: PUSH
86504: LD_INT 112
86506: PUSH
86507: EMPTY
86508: LIST
86509: LIST
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: ST_TO_ADDR
86520: GO 88779
86522: LD_INT 8
86524: DOUBLE
86525: EQUAL
86526: IFTRUE 86530
86528: GO 86658
86530: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
86531: LD_ADDR_VAR 0 1
86535: PUSH
86536: LD_INT 2
86538: PUSH
86539: LD_INT 4
86541: PUSH
86542: LD_INT 5
86544: PUSH
86545: LD_INT 6
86547: PUSH
86548: LD_INT 7
86550: PUSH
86551: LD_INT 8
86553: PUSH
86554: LD_INT 11
86556: PUSH
86557: LD_INT 12
86559: PUSH
86560: LD_INT 15
86562: PUSH
86563: LD_INT 16
86565: PUSH
86566: LD_INT 20
86568: PUSH
86569: LD_INT 21
86571: PUSH
86572: LD_INT 22
86574: PUSH
86575: LD_INT 23
86577: PUSH
86578: LD_INT 25
86580: PUSH
86581: LD_INT 26
86583: PUSH
86584: LD_INT 30
86586: PUSH
86587: LD_INT 31
86589: PUSH
86590: LD_INT 32
86592: PUSH
86593: LD_INT 36
86595: PUSH
86596: EMPTY
86597: LIST
86598: LIST
86599: LIST
86600: LIST
86601: LIST
86602: LIST
86603: LIST
86604: LIST
86605: LIST
86606: LIST
86607: LIST
86608: LIST
86609: LIST
86610: LIST
86611: LIST
86612: LIST
86613: LIST
86614: LIST
86615: LIST
86616: LIST
86617: PUSH
86618: LD_INT 101
86620: PUSH
86621: LD_INT 102
86623: PUSH
86624: LD_INT 103
86626: PUSH
86627: LD_INT 105
86629: PUSH
86630: LD_INT 106
86632: PUSH
86633: LD_INT 108
86635: PUSH
86636: LD_INT 109
86638: PUSH
86639: LD_INT 112
86641: PUSH
86642: EMPTY
86643: LIST
86644: LIST
86645: LIST
86646: LIST
86647: LIST
86648: LIST
86649: LIST
86650: LIST
86651: PUSH
86652: EMPTY
86653: LIST
86654: LIST
86655: ST_TO_ADDR
86656: GO 88779
86658: LD_INT 9
86660: DOUBLE
86661: EQUAL
86662: IFTRUE 86666
86664: GO 86802
86666: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
86667: LD_ADDR_VAR 0 1
86671: PUSH
86672: LD_INT 2
86674: PUSH
86675: LD_INT 4
86677: PUSH
86678: LD_INT 5
86680: PUSH
86681: LD_INT 6
86683: PUSH
86684: LD_INT 7
86686: PUSH
86687: LD_INT 8
86689: PUSH
86690: LD_INT 11
86692: PUSH
86693: LD_INT 12
86695: PUSH
86696: LD_INT 15
86698: PUSH
86699: LD_INT 16
86701: PUSH
86702: LD_INT 20
86704: PUSH
86705: LD_INT 21
86707: PUSH
86708: LD_INT 22
86710: PUSH
86711: LD_INT 23
86713: PUSH
86714: LD_INT 25
86716: PUSH
86717: LD_INT 26
86719: PUSH
86720: LD_INT 28
86722: PUSH
86723: LD_INT 30
86725: PUSH
86726: LD_INT 31
86728: PUSH
86729: LD_INT 32
86731: PUSH
86732: LD_INT 36
86734: PUSH
86735: EMPTY
86736: LIST
86737: LIST
86738: LIST
86739: LIST
86740: LIST
86741: LIST
86742: LIST
86743: LIST
86744: LIST
86745: LIST
86746: LIST
86747: LIST
86748: LIST
86749: LIST
86750: LIST
86751: LIST
86752: LIST
86753: LIST
86754: LIST
86755: LIST
86756: LIST
86757: PUSH
86758: LD_INT 101
86760: PUSH
86761: LD_INT 102
86763: PUSH
86764: LD_INT 103
86766: PUSH
86767: LD_INT 105
86769: PUSH
86770: LD_INT 106
86772: PUSH
86773: LD_INT 108
86775: PUSH
86776: LD_INT 109
86778: PUSH
86779: LD_INT 112
86781: PUSH
86782: LD_INT 114
86784: PUSH
86785: EMPTY
86786: LIST
86787: LIST
86788: LIST
86789: LIST
86790: LIST
86791: LIST
86792: LIST
86793: LIST
86794: LIST
86795: PUSH
86796: EMPTY
86797: LIST
86798: LIST
86799: ST_TO_ADDR
86800: GO 88779
86802: LD_INT 10
86804: DOUBLE
86805: EQUAL
86806: IFTRUE 86810
86808: GO 86994
86810: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
86811: LD_ADDR_VAR 0 1
86815: PUSH
86816: LD_INT 2
86818: PUSH
86819: LD_INT 4
86821: PUSH
86822: LD_INT 5
86824: PUSH
86825: LD_INT 6
86827: PUSH
86828: LD_INT 7
86830: PUSH
86831: LD_INT 8
86833: PUSH
86834: LD_INT 9
86836: PUSH
86837: LD_INT 10
86839: PUSH
86840: LD_INT 11
86842: PUSH
86843: LD_INT 12
86845: PUSH
86846: LD_INT 13
86848: PUSH
86849: LD_INT 14
86851: PUSH
86852: LD_INT 15
86854: PUSH
86855: LD_INT 16
86857: PUSH
86858: LD_INT 17
86860: PUSH
86861: LD_INT 18
86863: PUSH
86864: LD_INT 19
86866: PUSH
86867: LD_INT 20
86869: PUSH
86870: LD_INT 21
86872: PUSH
86873: LD_INT 22
86875: PUSH
86876: LD_INT 23
86878: PUSH
86879: LD_INT 24
86881: PUSH
86882: LD_INT 25
86884: PUSH
86885: LD_INT 26
86887: PUSH
86888: LD_INT 28
86890: PUSH
86891: LD_INT 30
86893: PUSH
86894: LD_INT 31
86896: PUSH
86897: LD_INT 32
86899: PUSH
86900: LD_INT 36
86902: PUSH
86903: EMPTY
86904: LIST
86905: LIST
86906: LIST
86907: LIST
86908: LIST
86909: LIST
86910: LIST
86911: LIST
86912: LIST
86913: LIST
86914: LIST
86915: LIST
86916: LIST
86917: LIST
86918: LIST
86919: LIST
86920: LIST
86921: LIST
86922: LIST
86923: LIST
86924: LIST
86925: LIST
86926: LIST
86927: LIST
86928: LIST
86929: LIST
86930: LIST
86931: LIST
86932: LIST
86933: PUSH
86934: LD_INT 101
86936: PUSH
86937: LD_INT 102
86939: PUSH
86940: LD_INT 103
86942: PUSH
86943: LD_INT 104
86945: PUSH
86946: LD_INT 105
86948: PUSH
86949: LD_INT 106
86951: PUSH
86952: LD_INT 107
86954: PUSH
86955: LD_INT 108
86957: PUSH
86958: LD_INT 109
86960: PUSH
86961: LD_INT 110
86963: PUSH
86964: LD_INT 111
86966: PUSH
86967: LD_INT 112
86969: PUSH
86970: LD_INT 114
86972: PUSH
86973: EMPTY
86974: LIST
86975: LIST
86976: LIST
86977: LIST
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: LIST
86983: LIST
86984: LIST
86985: LIST
86986: LIST
86987: PUSH
86988: EMPTY
86989: LIST
86990: LIST
86991: ST_TO_ADDR
86992: GO 88779
86994: LD_INT 11
86996: DOUBLE
86997: EQUAL
86998: IFTRUE 87002
87000: GO 87194
87002: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
87003: LD_ADDR_VAR 0 1
87007: PUSH
87008: LD_INT 2
87010: PUSH
87011: LD_INT 3
87013: PUSH
87014: LD_INT 4
87016: PUSH
87017: LD_INT 5
87019: PUSH
87020: LD_INT 6
87022: PUSH
87023: LD_INT 7
87025: PUSH
87026: LD_INT 8
87028: PUSH
87029: LD_INT 9
87031: PUSH
87032: LD_INT 10
87034: PUSH
87035: LD_INT 11
87037: PUSH
87038: LD_INT 12
87040: PUSH
87041: LD_INT 13
87043: PUSH
87044: LD_INT 14
87046: PUSH
87047: LD_INT 15
87049: PUSH
87050: LD_INT 16
87052: PUSH
87053: LD_INT 17
87055: PUSH
87056: LD_INT 18
87058: PUSH
87059: LD_INT 19
87061: PUSH
87062: LD_INT 20
87064: PUSH
87065: LD_INT 21
87067: PUSH
87068: LD_INT 22
87070: PUSH
87071: LD_INT 23
87073: PUSH
87074: LD_INT 24
87076: PUSH
87077: LD_INT 25
87079: PUSH
87080: LD_INT 26
87082: PUSH
87083: LD_INT 28
87085: PUSH
87086: LD_INT 30
87088: PUSH
87089: LD_INT 31
87091: PUSH
87092: LD_INT 32
87094: PUSH
87095: LD_INT 34
87097: PUSH
87098: LD_INT 36
87100: PUSH
87101: EMPTY
87102: LIST
87103: LIST
87104: LIST
87105: LIST
87106: LIST
87107: LIST
87108: LIST
87109: LIST
87110: LIST
87111: LIST
87112: LIST
87113: LIST
87114: LIST
87115: LIST
87116: LIST
87117: LIST
87118: LIST
87119: LIST
87120: LIST
87121: LIST
87122: LIST
87123: LIST
87124: LIST
87125: LIST
87126: LIST
87127: LIST
87128: LIST
87129: LIST
87130: LIST
87131: LIST
87132: LIST
87133: PUSH
87134: LD_INT 101
87136: PUSH
87137: LD_INT 102
87139: PUSH
87140: LD_INT 103
87142: PUSH
87143: LD_INT 104
87145: PUSH
87146: LD_INT 105
87148: PUSH
87149: LD_INT 106
87151: PUSH
87152: LD_INT 107
87154: PUSH
87155: LD_INT 108
87157: PUSH
87158: LD_INT 109
87160: PUSH
87161: LD_INT 110
87163: PUSH
87164: LD_INT 111
87166: PUSH
87167: LD_INT 112
87169: PUSH
87170: LD_INT 114
87172: PUSH
87173: EMPTY
87174: LIST
87175: LIST
87176: LIST
87177: LIST
87178: LIST
87179: LIST
87180: LIST
87181: LIST
87182: LIST
87183: LIST
87184: LIST
87185: LIST
87186: LIST
87187: PUSH
87188: EMPTY
87189: LIST
87190: LIST
87191: ST_TO_ADDR
87192: GO 88779
87194: LD_INT 12
87196: DOUBLE
87197: EQUAL
87198: IFTRUE 87202
87200: GO 87410
87202: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
87203: LD_ADDR_VAR 0 1
87207: PUSH
87208: LD_INT 1
87210: PUSH
87211: LD_INT 2
87213: PUSH
87214: LD_INT 3
87216: PUSH
87217: LD_INT 4
87219: PUSH
87220: LD_INT 5
87222: PUSH
87223: LD_INT 6
87225: PUSH
87226: LD_INT 7
87228: PUSH
87229: LD_INT 8
87231: PUSH
87232: LD_INT 9
87234: PUSH
87235: LD_INT 10
87237: PUSH
87238: LD_INT 11
87240: PUSH
87241: LD_INT 12
87243: PUSH
87244: LD_INT 13
87246: PUSH
87247: LD_INT 14
87249: PUSH
87250: LD_INT 15
87252: PUSH
87253: LD_INT 16
87255: PUSH
87256: LD_INT 17
87258: PUSH
87259: LD_INT 18
87261: PUSH
87262: LD_INT 19
87264: PUSH
87265: LD_INT 20
87267: PUSH
87268: LD_INT 21
87270: PUSH
87271: LD_INT 22
87273: PUSH
87274: LD_INT 23
87276: PUSH
87277: LD_INT 24
87279: PUSH
87280: LD_INT 25
87282: PUSH
87283: LD_INT 26
87285: PUSH
87286: LD_INT 27
87288: PUSH
87289: LD_INT 28
87291: PUSH
87292: LD_INT 30
87294: PUSH
87295: LD_INT 31
87297: PUSH
87298: LD_INT 32
87300: PUSH
87301: LD_INT 33
87303: PUSH
87304: LD_INT 34
87306: PUSH
87307: LD_INT 36
87309: PUSH
87310: EMPTY
87311: LIST
87312: LIST
87313: LIST
87314: LIST
87315: LIST
87316: LIST
87317: LIST
87318: LIST
87319: LIST
87320: LIST
87321: LIST
87322: LIST
87323: LIST
87324: LIST
87325: LIST
87326: LIST
87327: LIST
87328: LIST
87329: LIST
87330: LIST
87331: LIST
87332: LIST
87333: LIST
87334: LIST
87335: LIST
87336: LIST
87337: LIST
87338: LIST
87339: LIST
87340: LIST
87341: LIST
87342: LIST
87343: LIST
87344: LIST
87345: PUSH
87346: LD_INT 101
87348: PUSH
87349: LD_INT 102
87351: PUSH
87352: LD_INT 103
87354: PUSH
87355: LD_INT 104
87357: PUSH
87358: LD_INT 105
87360: PUSH
87361: LD_INT 106
87363: PUSH
87364: LD_INT 107
87366: PUSH
87367: LD_INT 108
87369: PUSH
87370: LD_INT 109
87372: PUSH
87373: LD_INT 110
87375: PUSH
87376: LD_INT 111
87378: PUSH
87379: LD_INT 112
87381: PUSH
87382: LD_INT 113
87384: PUSH
87385: LD_INT 114
87387: PUSH
87388: EMPTY
87389: LIST
87390: LIST
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: LIST
87396: LIST
87397: LIST
87398: LIST
87399: LIST
87400: LIST
87401: LIST
87402: LIST
87403: PUSH
87404: EMPTY
87405: LIST
87406: LIST
87407: ST_TO_ADDR
87408: GO 88779
87410: LD_INT 13
87412: DOUBLE
87413: EQUAL
87414: IFTRUE 87418
87416: GO 87614
87418: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
87419: LD_ADDR_VAR 0 1
87423: PUSH
87424: LD_INT 1
87426: PUSH
87427: LD_INT 2
87429: PUSH
87430: LD_INT 3
87432: PUSH
87433: LD_INT 4
87435: PUSH
87436: LD_INT 5
87438: PUSH
87439: LD_INT 8
87441: PUSH
87442: LD_INT 9
87444: PUSH
87445: LD_INT 10
87447: PUSH
87448: LD_INT 11
87450: PUSH
87451: LD_INT 12
87453: PUSH
87454: LD_INT 14
87456: PUSH
87457: LD_INT 15
87459: PUSH
87460: LD_INT 16
87462: PUSH
87463: LD_INT 17
87465: PUSH
87466: LD_INT 18
87468: PUSH
87469: LD_INT 19
87471: PUSH
87472: LD_INT 20
87474: PUSH
87475: LD_INT 21
87477: PUSH
87478: LD_INT 22
87480: PUSH
87481: LD_INT 23
87483: PUSH
87484: LD_INT 24
87486: PUSH
87487: LD_INT 25
87489: PUSH
87490: LD_INT 26
87492: PUSH
87493: LD_INT 27
87495: PUSH
87496: LD_INT 28
87498: PUSH
87499: LD_INT 30
87501: PUSH
87502: LD_INT 31
87504: PUSH
87505: LD_INT 32
87507: PUSH
87508: LD_INT 33
87510: PUSH
87511: LD_INT 34
87513: PUSH
87514: LD_INT 36
87516: PUSH
87517: EMPTY
87518: LIST
87519: LIST
87520: LIST
87521: LIST
87522: LIST
87523: LIST
87524: LIST
87525: LIST
87526: LIST
87527: LIST
87528: LIST
87529: LIST
87530: LIST
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: LIST
87539: LIST
87540: LIST
87541: LIST
87542: LIST
87543: LIST
87544: LIST
87545: LIST
87546: LIST
87547: LIST
87548: LIST
87549: PUSH
87550: LD_INT 101
87552: PUSH
87553: LD_INT 102
87555: PUSH
87556: LD_INT 103
87558: PUSH
87559: LD_INT 104
87561: PUSH
87562: LD_INT 105
87564: PUSH
87565: LD_INT 106
87567: PUSH
87568: LD_INT 107
87570: PUSH
87571: LD_INT 108
87573: PUSH
87574: LD_INT 109
87576: PUSH
87577: LD_INT 110
87579: PUSH
87580: LD_INT 111
87582: PUSH
87583: LD_INT 112
87585: PUSH
87586: LD_INT 113
87588: PUSH
87589: LD_INT 114
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: LIST
87596: LIST
87597: LIST
87598: LIST
87599: LIST
87600: LIST
87601: LIST
87602: LIST
87603: LIST
87604: LIST
87605: LIST
87606: LIST
87607: PUSH
87608: EMPTY
87609: LIST
87610: LIST
87611: ST_TO_ADDR
87612: GO 88779
87614: LD_INT 14
87616: DOUBLE
87617: EQUAL
87618: IFTRUE 87622
87620: GO 87834
87622: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
87623: LD_ADDR_VAR 0 1
87627: PUSH
87628: LD_INT 1
87630: PUSH
87631: LD_INT 2
87633: PUSH
87634: LD_INT 3
87636: PUSH
87637: LD_INT 4
87639: PUSH
87640: LD_INT 5
87642: PUSH
87643: LD_INT 6
87645: PUSH
87646: LD_INT 7
87648: PUSH
87649: LD_INT 8
87651: PUSH
87652: LD_INT 9
87654: PUSH
87655: LD_INT 10
87657: PUSH
87658: LD_INT 11
87660: PUSH
87661: LD_INT 12
87663: PUSH
87664: LD_INT 13
87666: PUSH
87667: LD_INT 14
87669: PUSH
87670: LD_INT 15
87672: PUSH
87673: LD_INT 16
87675: PUSH
87676: LD_INT 17
87678: PUSH
87679: LD_INT 18
87681: PUSH
87682: LD_INT 19
87684: PUSH
87685: LD_INT 20
87687: PUSH
87688: LD_INT 21
87690: PUSH
87691: LD_INT 22
87693: PUSH
87694: LD_INT 23
87696: PUSH
87697: LD_INT 24
87699: PUSH
87700: LD_INT 25
87702: PUSH
87703: LD_INT 26
87705: PUSH
87706: LD_INT 27
87708: PUSH
87709: LD_INT 28
87711: PUSH
87712: LD_INT 29
87714: PUSH
87715: LD_INT 30
87717: PUSH
87718: LD_INT 31
87720: PUSH
87721: LD_INT 32
87723: PUSH
87724: LD_INT 33
87726: PUSH
87727: LD_INT 34
87729: PUSH
87730: LD_INT 36
87732: PUSH
87733: EMPTY
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: LIST
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: LIST
87764: LIST
87765: LIST
87766: LIST
87767: LIST
87768: LIST
87769: PUSH
87770: LD_INT 101
87772: PUSH
87773: LD_INT 102
87775: PUSH
87776: LD_INT 103
87778: PUSH
87779: LD_INT 104
87781: PUSH
87782: LD_INT 105
87784: PUSH
87785: LD_INT 106
87787: PUSH
87788: LD_INT 107
87790: PUSH
87791: LD_INT 108
87793: PUSH
87794: LD_INT 109
87796: PUSH
87797: LD_INT 110
87799: PUSH
87800: LD_INT 111
87802: PUSH
87803: LD_INT 112
87805: PUSH
87806: LD_INT 113
87808: PUSH
87809: LD_INT 114
87811: PUSH
87812: EMPTY
87813: LIST
87814: LIST
87815: LIST
87816: LIST
87817: LIST
87818: LIST
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: PUSH
87828: EMPTY
87829: LIST
87830: LIST
87831: ST_TO_ADDR
87832: GO 88779
87834: LD_INT 15
87836: DOUBLE
87837: EQUAL
87838: IFTRUE 87842
87840: GO 88054
87842: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
87843: LD_ADDR_VAR 0 1
87847: PUSH
87848: LD_INT 1
87850: PUSH
87851: LD_INT 2
87853: PUSH
87854: LD_INT 3
87856: PUSH
87857: LD_INT 4
87859: PUSH
87860: LD_INT 5
87862: PUSH
87863: LD_INT 6
87865: PUSH
87866: LD_INT 7
87868: PUSH
87869: LD_INT 8
87871: PUSH
87872: LD_INT 9
87874: PUSH
87875: LD_INT 10
87877: PUSH
87878: LD_INT 11
87880: PUSH
87881: LD_INT 12
87883: PUSH
87884: LD_INT 13
87886: PUSH
87887: LD_INT 14
87889: PUSH
87890: LD_INT 15
87892: PUSH
87893: LD_INT 16
87895: PUSH
87896: LD_INT 17
87898: PUSH
87899: LD_INT 18
87901: PUSH
87902: LD_INT 19
87904: PUSH
87905: LD_INT 20
87907: PUSH
87908: LD_INT 21
87910: PUSH
87911: LD_INT 22
87913: PUSH
87914: LD_INT 23
87916: PUSH
87917: LD_INT 24
87919: PUSH
87920: LD_INT 25
87922: PUSH
87923: LD_INT 26
87925: PUSH
87926: LD_INT 27
87928: PUSH
87929: LD_INT 28
87931: PUSH
87932: LD_INT 29
87934: PUSH
87935: LD_INT 30
87937: PUSH
87938: LD_INT 31
87940: PUSH
87941: LD_INT 32
87943: PUSH
87944: LD_INT 33
87946: PUSH
87947: LD_INT 34
87949: PUSH
87950: LD_INT 36
87952: PUSH
87953: EMPTY
87954: LIST
87955: LIST
87956: LIST
87957: LIST
87958: LIST
87959: LIST
87960: LIST
87961: LIST
87962: LIST
87963: LIST
87964: LIST
87965: LIST
87966: LIST
87967: LIST
87968: LIST
87969: LIST
87970: LIST
87971: LIST
87972: LIST
87973: LIST
87974: LIST
87975: LIST
87976: LIST
87977: LIST
87978: LIST
87979: LIST
87980: LIST
87981: LIST
87982: LIST
87983: LIST
87984: LIST
87985: LIST
87986: LIST
87987: LIST
87988: LIST
87989: PUSH
87990: LD_INT 101
87992: PUSH
87993: LD_INT 102
87995: PUSH
87996: LD_INT 103
87998: PUSH
87999: LD_INT 104
88001: PUSH
88002: LD_INT 105
88004: PUSH
88005: LD_INT 106
88007: PUSH
88008: LD_INT 107
88010: PUSH
88011: LD_INT 108
88013: PUSH
88014: LD_INT 109
88016: PUSH
88017: LD_INT 110
88019: PUSH
88020: LD_INT 111
88022: PUSH
88023: LD_INT 112
88025: PUSH
88026: LD_INT 113
88028: PUSH
88029: LD_INT 114
88031: PUSH
88032: EMPTY
88033: LIST
88034: LIST
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: LIST
88046: LIST
88047: PUSH
88048: EMPTY
88049: LIST
88050: LIST
88051: ST_TO_ADDR
88052: GO 88779
88054: LD_INT 16
88056: DOUBLE
88057: EQUAL
88058: IFTRUE 88062
88060: GO 88186
88062: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
88063: LD_ADDR_VAR 0 1
88067: PUSH
88068: LD_INT 2
88070: PUSH
88071: LD_INT 4
88073: PUSH
88074: LD_INT 5
88076: PUSH
88077: LD_INT 7
88079: PUSH
88080: LD_INT 11
88082: PUSH
88083: LD_INT 12
88085: PUSH
88086: LD_INT 15
88088: PUSH
88089: LD_INT 16
88091: PUSH
88092: LD_INT 20
88094: PUSH
88095: LD_INT 21
88097: PUSH
88098: LD_INT 22
88100: PUSH
88101: LD_INT 23
88103: PUSH
88104: LD_INT 25
88106: PUSH
88107: LD_INT 26
88109: PUSH
88110: LD_INT 30
88112: PUSH
88113: LD_INT 31
88115: PUSH
88116: LD_INT 32
88118: PUSH
88119: LD_INT 33
88121: PUSH
88122: LD_INT 34
88124: PUSH
88125: EMPTY
88126: LIST
88127: LIST
88128: LIST
88129: LIST
88130: LIST
88131: LIST
88132: LIST
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: PUSH
88146: LD_INT 101
88148: PUSH
88149: LD_INT 102
88151: PUSH
88152: LD_INT 103
88154: PUSH
88155: LD_INT 106
88157: PUSH
88158: LD_INT 108
88160: PUSH
88161: LD_INT 112
88163: PUSH
88164: LD_INT 113
88166: PUSH
88167: LD_INT 114
88169: PUSH
88170: EMPTY
88171: LIST
88172: LIST
88173: LIST
88174: LIST
88175: LIST
88176: LIST
88177: LIST
88178: LIST
88179: PUSH
88180: EMPTY
88181: LIST
88182: LIST
88183: ST_TO_ADDR
88184: GO 88779
88186: LD_INT 17
88188: DOUBLE
88189: EQUAL
88190: IFTRUE 88194
88192: GO 88406
88194: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
88195: LD_ADDR_VAR 0 1
88199: PUSH
88200: LD_INT 1
88202: PUSH
88203: LD_INT 2
88205: PUSH
88206: LD_INT 3
88208: PUSH
88209: LD_INT 4
88211: PUSH
88212: LD_INT 5
88214: PUSH
88215: LD_INT 6
88217: PUSH
88218: LD_INT 7
88220: PUSH
88221: LD_INT 8
88223: PUSH
88224: LD_INT 9
88226: PUSH
88227: LD_INT 10
88229: PUSH
88230: LD_INT 11
88232: PUSH
88233: LD_INT 12
88235: PUSH
88236: LD_INT 13
88238: PUSH
88239: LD_INT 14
88241: PUSH
88242: LD_INT 15
88244: PUSH
88245: LD_INT 16
88247: PUSH
88248: LD_INT 17
88250: PUSH
88251: LD_INT 18
88253: PUSH
88254: LD_INT 19
88256: PUSH
88257: LD_INT 20
88259: PUSH
88260: LD_INT 21
88262: PUSH
88263: LD_INT 22
88265: PUSH
88266: LD_INT 23
88268: PUSH
88269: LD_INT 24
88271: PUSH
88272: LD_INT 25
88274: PUSH
88275: LD_INT 26
88277: PUSH
88278: LD_INT 27
88280: PUSH
88281: LD_INT 28
88283: PUSH
88284: LD_INT 29
88286: PUSH
88287: LD_INT 30
88289: PUSH
88290: LD_INT 31
88292: PUSH
88293: LD_INT 32
88295: PUSH
88296: LD_INT 33
88298: PUSH
88299: LD_INT 34
88301: PUSH
88302: LD_INT 36
88304: PUSH
88305: EMPTY
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: LIST
88312: LIST
88313: LIST
88314: LIST
88315: LIST
88316: LIST
88317: LIST
88318: LIST
88319: LIST
88320: LIST
88321: LIST
88322: LIST
88323: LIST
88324: LIST
88325: LIST
88326: LIST
88327: LIST
88328: LIST
88329: LIST
88330: LIST
88331: LIST
88332: LIST
88333: LIST
88334: LIST
88335: LIST
88336: LIST
88337: LIST
88338: LIST
88339: LIST
88340: LIST
88341: PUSH
88342: LD_INT 101
88344: PUSH
88345: LD_INT 102
88347: PUSH
88348: LD_INT 103
88350: PUSH
88351: LD_INT 104
88353: PUSH
88354: LD_INT 105
88356: PUSH
88357: LD_INT 106
88359: PUSH
88360: LD_INT 107
88362: PUSH
88363: LD_INT 108
88365: PUSH
88366: LD_INT 109
88368: PUSH
88369: LD_INT 110
88371: PUSH
88372: LD_INT 111
88374: PUSH
88375: LD_INT 112
88377: PUSH
88378: LD_INT 113
88380: PUSH
88381: LD_INT 114
88383: PUSH
88384: EMPTY
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: LIST
88394: LIST
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: PUSH
88400: EMPTY
88401: LIST
88402: LIST
88403: ST_TO_ADDR
88404: GO 88779
88406: LD_INT 18
88408: DOUBLE
88409: EQUAL
88410: IFTRUE 88414
88412: GO 88550
88414: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
88415: LD_ADDR_VAR 0 1
88419: PUSH
88420: LD_INT 2
88422: PUSH
88423: LD_INT 4
88425: PUSH
88426: LD_INT 5
88428: PUSH
88429: LD_INT 7
88431: PUSH
88432: LD_INT 11
88434: PUSH
88435: LD_INT 12
88437: PUSH
88438: LD_INT 15
88440: PUSH
88441: LD_INT 16
88443: PUSH
88444: LD_INT 20
88446: PUSH
88447: LD_INT 21
88449: PUSH
88450: LD_INT 22
88452: PUSH
88453: LD_INT 23
88455: PUSH
88456: LD_INT 25
88458: PUSH
88459: LD_INT 26
88461: PUSH
88462: LD_INT 30
88464: PUSH
88465: LD_INT 31
88467: PUSH
88468: LD_INT 32
88470: PUSH
88471: LD_INT 33
88473: PUSH
88474: LD_INT 34
88476: PUSH
88477: LD_INT 35
88479: PUSH
88480: LD_INT 36
88482: PUSH
88483: EMPTY
88484: LIST
88485: LIST
88486: LIST
88487: LIST
88488: LIST
88489: LIST
88490: LIST
88491: LIST
88492: LIST
88493: LIST
88494: LIST
88495: LIST
88496: LIST
88497: LIST
88498: LIST
88499: LIST
88500: LIST
88501: LIST
88502: LIST
88503: LIST
88504: LIST
88505: PUSH
88506: LD_INT 101
88508: PUSH
88509: LD_INT 102
88511: PUSH
88512: LD_INT 103
88514: PUSH
88515: LD_INT 106
88517: PUSH
88518: LD_INT 108
88520: PUSH
88521: LD_INT 112
88523: PUSH
88524: LD_INT 113
88526: PUSH
88527: LD_INT 114
88529: PUSH
88530: LD_INT 115
88532: PUSH
88533: EMPTY
88534: LIST
88535: LIST
88536: LIST
88537: LIST
88538: LIST
88539: LIST
88540: LIST
88541: LIST
88542: LIST
88543: PUSH
88544: EMPTY
88545: LIST
88546: LIST
88547: ST_TO_ADDR
88548: GO 88779
88550: LD_INT 19
88552: DOUBLE
88553: EQUAL
88554: IFTRUE 88558
88556: GO 88778
88558: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
88559: LD_ADDR_VAR 0 1
88563: PUSH
88564: LD_INT 1
88566: PUSH
88567: LD_INT 2
88569: PUSH
88570: LD_INT 3
88572: PUSH
88573: LD_INT 4
88575: PUSH
88576: LD_INT 5
88578: PUSH
88579: LD_INT 6
88581: PUSH
88582: LD_INT 7
88584: PUSH
88585: LD_INT 8
88587: PUSH
88588: LD_INT 9
88590: PUSH
88591: LD_INT 10
88593: PUSH
88594: LD_INT 11
88596: PUSH
88597: LD_INT 12
88599: PUSH
88600: LD_INT 13
88602: PUSH
88603: LD_INT 14
88605: PUSH
88606: LD_INT 15
88608: PUSH
88609: LD_INT 16
88611: PUSH
88612: LD_INT 17
88614: PUSH
88615: LD_INT 18
88617: PUSH
88618: LD_INT 19
88620: PUSH
88621: LD_INT 20
88623: PUSH
88624: LD_INT 21
88626: PUSH
88627: LD_INT 22
88629: PUSH
88630: LD_INT 23
88632: PUSH
88633: LD_INT 24
88635: PUSH
88636: LD_INT 25
88638: PUSH
88639: LD_INT 26
88641: PUSH
88642: LD_INT 27
88644: PUSH
88645: LD_INT 28
88647: PUSH
88648: LD_INT 29
88650: PUSH
88651: LD_INT 30
88653: PUSH
88654: LD_INT 31
88656: PUSH
88657: LD_INT 32
88659: PUSH
88660: LD_INT 33
88662: PUSH
88663: LD_INT 34
88665: PUSH
88666: LD_INT 35
88668: PUSH
88669: LD_INT 36
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: LIST
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: LIST
88681: LIST
88682: LIST
88683: LIST
88684: LIST
88685: LIST
88686: LIST
88687: LIST
88688: LIST
88689: LIST
88690: LIST
88691: LIST
88692: LIST
88693: LIST
88694: LIST
88695: LIST
88696: LIST
88697: LIST
88698: LIST
88699: LIST
88700: LIST
88701: LIST
88702: LIST
88703: LIST
88704: LIST
88705: LIST
88706: LIST
88707: LIST
88708: LIST
88709: PUSH
88710: LD_INT 101
88712: PUSH
88713: LD_INT 102
88715: PUSH
88716: LD_INT 103
88718: PUSH
88719: LD_INT 104
88721: PUSH
88722: LD_INT 105
88724: PUSH
88725: LD_INT 106
88727: PUSH
88728: LD_INT 107
88730: PUSH
88731: LD_INT 108
88733: PUSH
88734: LD_INT 109
88736: PUSH
88737: LD_INT 110
88739: PUSH
88740: LD_INT 111
88742: PUSH
88743: LD_INT 112
88745: PUSH
88746: LD_INT 113
88748: PUSH
88749: LD_INT 114
88751: PUSH
88752: LD_INT 115
88754: PUSH
88755: EMPTY
88756: LIST
88757: LIST
88758: LIST
88759: LIST
88760: LIST
88761: LIST
88762: LIST
88763: LIST
88764: LIST
88765: LIST
88766: LIST
88767: LIST
88768: LIST
88769: LIST
88770: LIST
88771: PUSH
88772: EMPTY
88773: LIST
88774: LIST
88775: ST_TO_ADDR
88776: GO 88779
88778: POP
// end else
88779: GO 88998
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
88781: LD_ADDR_VAR 0 1
88785: PUSH
88786: LD_INT 1
88788: PUSH
88789: LD_INT 2
88791: PUSH
88792: LD_INT 3
88794: PUSH
88795: LD_INT 4
88797: PUSH
88798: LD_INT 5
88800: PUSH
88801: LD_INT 6
88803: PUSH
88804: LD_INT 7
88806: PUSH
88807: LD_INT 8
88809: PUSH
88810: LD_INT 9
88812: PUSH
88813: LD_INT 10
88815: PUSH
88816: LD_INT 11
88818: PUSH
88819: LD_INT 12
88821: PUSH
88822: LD_INT 13
88824: PUSH
88825: LD_INT 14
88827: PUSH
88828: LD_INT 15
88830: PUSH
88831: LD_INT 16
88833: PUSH
88834: LD_INT 17
88836: PUSH
88837: LD_INT 18
88839: PUSH
88840: LD_INT 19
88842: PUSH
88843: LD_INT 20
88845: PUSH
88846: LD_INT 21
88848: PUSH
88849: LD_INT 22
88851: PUSH
88852: LD_INT 23
88854: PUSH
88855: LD_INT 24
88857: PUSH
88858: LD_INT 25
88860: PUSH
88861: LD_INT 26
88863: PUSH
88864: LD_INT 27
88866: PUSH
88867: LD_INT 28
88869: PUSH
88870: LD_INT 29
88872: PUSH
88873: LD_INT 30
88875: PUSH
88876: LD_INT 31
88878: PUSH
88879: LD_INT 32
88881: PUSH
88882: LD_INT 33
88884: PUSH
88885: LD_INT 34
88887: PUSH
88888: LD_INT 35
88890: PUSH
88891: LD_INT 36
88893: PUSH
88894: EMPTY
88895: LIST
88896: LIST
88897: LIST
88898: LIST
88899: LIST
88900: LIST
88901: LIST
88902: LIST
88903: LIST
88904: LIST
88905: LIST
88906: LIST
88907: LIST
88908: LIST
88909: LIST
88910: LIST
88911: LIST
88912: LIST
88913: LIST
88914: LIST
88915: LIST
88916: LIST
88917: LIST
88918: LIST
88919: LIST
88920: LIST
88921: LIST
88922: LIST
88923: LIST
88924: LIST
88925: LIST
88926: LIST
88927: LIST
88928: LIST
88929: LIST
88930: LIST
88931: PUSH
88932: LD_INT 101
88934: PUSH
88935: LD_INT 102
88937: PUSH
88938: LD_INT 103
88940: PUSH
88941: LD_INT 104
88943: PUSH
88944: LD_INT 105
88946: PUSH
88947: LD_INT 106
88949: PUSH
88950: LD_INT 107
88952: PUSH
88953: LD_INT 108
88955: PUSH
88956: LD_INT 109
88958: PUSH
88959: LD_INT 110
88961: PUSH
88962: LD_INT 111
88964: PUSH
88965: LD_INT 112
88967: PUSH
88968: LD_INT 113
88970: PUSH
88971: LD_INT 114
88973: PUSH
88974: LD_INT 115
88976: PUSH
88977: EMPTY
88978: LIST
88979: LIST
88980: LIST
88981: LIST
88982: LIST
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: PUSH
88994: EMPTY
88995: LIST
88996: LIST
88997: ST_TO_ADDR
// if result then
88998: LD_VAR 0 1
89002: IFFALSE 89291
// begin normal :=  ;
89004: LD_ADDR_VAR 0 3
89008: PUSH
89009: LD_STRING 
89011: ST_TO_ADDR
// hardcore :=  ;
89012: LD_ADDR_VAR 0 4
89016: PUSH
89017: LD_STRING 
89019: ST_TO_ADDR
// for i = 1 to normalCounter do
89020: LD_ADDR_VAR 0 5
89024: PUSH
89025: DOUBLE
89026: LD_INT 1
89028: DEC
89029: ST_TO_ADDR
89030: LD_EXP 123
89034: PUSH
89035: FOR_TO
89036: IFFALSE 89137
// begin tmp := 0 ;
89038: LD_ADDR_VAR 0 2
89042: PUSH
89043: LD_STRING 0
89045: ST_TO_ADDR
// if result [ 1 ] then
89046: LD_VAR 0 1
89050: PUSH
89051: LD_INT 1
89053: ARRAY
89054: IFFALSE 89119
// if result [ 1 ] [ 1 ] = i then
89056: LD_VAR 0 1
89060: PUSH
89061: LD_INT 1
89063: ARRAY
89064: PUSH
89065: LD_INT 1
89067: ARRAY
89068: PUSH
89069: LD_VAR 0 5
89073: EQUAL
89074: IFFALSE 89119
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
89076: LD_ADDR_VAR 0 1
89080: PUSH
89081: LD_VAR 0 1
89085: PPUSH
89086: LD_INT 1
89088: PPUSH
89089: LD_VAR 0 1
89093: PUSH
89094: LD_INT 1
89096: ARRAY
89097: PPUSH
89098: LD_INT 1
89100: PPUSH
89101: CALL_OW 3
89105: PPUSH
89106: CALL_OW 1
89110: ST_TO_ADDR
// tmp := 1 ;
89111: LD_ADDR_VAR 0 2
89115: PUSH
89116: LD_STRING 1
89118: ST_TO_ADDR
// end ; normal := normal & tmp ;
89119: LD_ADDR_VAR 0 3
89123: PUSH
89124: LD_VAR 0 3
89128: PUSH
89129: LD_VAR 0 2
89133: STR
89134: ST_TO_ADDR
// end ;
89135: GO 89035
89137: POP
89138: POP
// for i = 1 to hardcoreCounter do
89139: LD_ADDR_VAR 0 5
89143: PUSH
89144: DOUBLE
89145: LD_INT 1
89147: DEC
89148: ST_TO_ADDR
89149: LD_EXP 124
89153: PUSH
89154: FOR_TO
89155: IFFALSE 89260
// begin tmp := 0 ;
89157: LD_ADDR_VAR 0 2
89161: PUSH
89162: LD_STRING 0
89164: ST_TO_ADDR
// if result [ 2 ] then
89165: LD_VAR 0 1
89169: PUSH
89170: LD_INT 2
89172: ARRAY
89173: IFFALSE 89242
// if result [ 2 ] [ 1 ] = 100 + i then
89175: LD_VAR 0 1
89179: PUSH
89180: LD_INT 2
89182: ARRAY
89183: PUSH
89184: LD_INT 1
89186: ARRAY
89187: PUSH
89188: LD_INT 100
89190: PUSH
89191: LD_VAR 0 5
89195: PLUS
89196: EQUAL
89197: IFFALSE 89242
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
89199: LD_ADDR_VAR 0 1
89203: PUSH
89204: LD_VAR 0 1
89208: PPUSH
89209: LD_INT 2
89211: PPUSH
89212: LD_VAR 0 1
89216: PUSH
89217: LD_INT 2
89219: ARRAY
89220: PPUSH
89221: LD_INT 1
89223: PPUSH
89224: CALL_OW 3
89228: PPUSH
89229: CALL_OW 1
89233: ST_TO_ADDR
// tmp := 1 ;
89234: LD_ADDR_VAR 0 2
89238: PUSH
89239: LD_STRING 1
89241: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
89242: LD_ADDR_VAR 0 4
89246: PUSH
89247: LD_VAR 0 4
89251: PUSH
89252: LD_VAR 0 2
89256: STR
89257: ST_TO_ADDR
// end ;
89258: GO 89154
89260: POP
89261: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
89262: LD_STRING getStreamItemsFromMission("
89264: PUSH
89265: LD_VAR 0 3
89269: STR
89270: PUSH
89271: LD_STRING ","
89273: STR
89274: PUSH
89275: LD_VAR 0 4
89279: STR
89280: PUSH
89281: LD_STRING ")
89283: STR
89284: PPUSH
89285: CALL_OW 559
// end else
89289: GO 89298
// ToLua ( getStreamItemsFromMission("","") ) ;
89291: LD_STRING getStreamItemsFromMission("","")
89293: PPUSH
89294: CALL_OW 559
// end ;
89298: LD_VAR 0 1
89302: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
89303: LD_EXP 122
89307: PUSH
89308: LD_EXP 127
89312: AND
89313: IFFALSE 89437
89315: GO 89317
89317: DISABLE
89318: LD_INT 0
89320: PPUSH
89321: PPUSH
// begin enable ;
89322: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
89323: LD_ADDR_VAR 0 2
89327: PUSH
89328: LD_INT 22
89330: PUSH
89331: LD_OWVAR 2
89335: PUSH
89336: EMPTY
89337: LIST
89338: LIST
89339: PUSH
89340: LD_INT 2
89342: PUSH
89343: LD_INT 34
89345: PUSH
89346: LD_INT 7
89348: PUSH
89349: EMPTY
89350: LIST
89351: LIST
89352: PUSH
89353: LD_INT 34
89355: PUSH
89356: LD_INT 45
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: LD_INT 34
89365: PUSH
89366: LD_INT 28
89368: PUSH
89369: EMPTY
89370: LIST
89371: LIST
89372: PUSH
89373: LD_INT 34
89375: PUSH
89376: LD_INT 47
89378: PUSH
89379: EMPTY
89380: LIST
89381: LIST
89382: PUSH
89383: EMPTY
89384: LIST
89385: LIST
89386: LIST
89387: LIST
89388: LIST
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PPUSH
89394: CALL_OW 69
89398: ST_TO_ADDR
// if not tmp then
89399: LD_VAR 0 2
89403: NOT
89404: IFFALSE 89408
// exit ;
89406: GO 89437
// for i in tmp do
89408: LD_ADDR_VAR 0 1
89412: PUSH
89413: LD_VAR 0 2
89417: PUSH
89418: FOR_IN
89419: IFFALSE 89435
// begin SetLives ( i , 0 ) ;
89421: LD_VAR 0 1
89425: PPUSH
89426: LD_INT 0
89428: PPUSH
89429: CALL_OW 234
// end ;
89433: GO 89418
89435: POP
89436: POP
// end ;
89437: PPOPN 2
89439: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
89440: LD_EXP 122
89444: PUSH
89445: LD_EXP 128
89449: AND
89450: IFFALSE 89534
89452: GO 89454
89454: DISABLE
89455: LD_INT 0
89457: PPUSH
89458: PPUSH
// begin enable ;
89459: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
89460: LD_ADDR_VAR 0 2
89464: PUSH
89465: LD_INT 22
89467: PUSH
89468: LD_OWVAR 2
89472: PUSH
89473: EMPTY
89474: LIST
89475: LIST
89476: PUSH
89477: LD_INT 32
89479: PUSH
89480: LD_INT 3
89482: PUSH
89483: EMPTY
89484: LIST
89485: LIST
89486: PUSH
89487: EMPTY
89488: LIST
89489: LIST
89490: PPUSH
89491: CALL_OW 69
89495: ST_TO_ADDR
// if not tmp then
89496: LD_VAR 0 2
89500: NOT
89501: IFFALSE 89505
// exit ;
89503: GO 89534
// for i in tmp do
89505: LD_ADDR_VAR 0 1
89509: PUSH
89510: LD_VAR 0 2
89514: PUSH
89515: FOR_IN
89516: IFFALSE 89532
// begin SetLives ( i , 0 ) ;
89518: LD_VAR 0 1
89522: PPUSH
89523: LD_INT 0
89525: PPUSH
89526: CALL_OW 234
// end ;
89530: GO 89515
89532: POP
89533: POP
// end ;
89534: PPOPN 2
89536: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
89537: LD_EXP 122
89541: PUSH
89542: LD_EXP 125
89546: AND
89547: IFFALSE 89640
89549: GO 89551
89551: DISABLE
89552: LD_INT 0
89554: PPUSH
// begin enable ;
89555: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
89556: LD_ADDR_VAR 0 1
89560: PUSH
89561: LD_INT 22
89563: PUSH
89564: LD_OWVAR 2
89568: PUSH
89569: EMPTY
89570: LIST
89571: LIST
89572: PUSH
89573: LD_INT 2
89575: PUSH
89576: LD_INT 25
89578: PUSH
89579: LD_INT 5
89581: PUSH
89582: EMPTY
89583: LIST
89584: LIST
89585: PUSH
89586: LD_INT 25
89588: PUSH
89589: LD_INT 9
89591: PUSH
89592: EMPTY
89593: LIST
89594: LIST
89595: PUSH
89596: LD_INT 25
89598: PUSH
89599: LD_INT 8
89601: PUSH
89602: EMPTY
89603: LIST
89604: LIST
89605: PUSH
89606: EMPTY
89607: LIST
89608: LIST
89609: LIST
89610: LIST
89611: PUSH
89612: EMPTY
89613: LIST
89614: LIST
89615: PPUSH
89616: CALL_OW 69
89620: PUSH
89621: FOR_IN
89622: IFFALSE 89638
// begin SetClass ( i , 1 ) ;
89624: LD_VAR 0 1
89628: PPUSH
89629: LD_INT 1
89631: PPUSH
89632: CALL_OW 336
// end ;
89636: GO 89621
89638: POP
89639: POP
// end ;
89640: PPOPN 1
89642: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
89643: LD_EXP 122
89647: PUSH
89648: LD_EXP 126
89652: AND
89653: PUSH
89654: LD_OWVAR 65
89658: PUSH
89659: LD_INT 7
89661: LESS
89662: AND
89663: IFFALSE 89677
89665: GO 89667
89667: DISABLE
// begin enable ;
89668: ENABLE
// game_speed := 7 ;
89669: LD_ADDR_OWVAR 65
89673: PUSH
89674: LD_INT 7
89676: ST_TO_ADDR
// end ;
89677: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
89678: LD_EXP 122
89682: PUSH
89683: LD_EXP 129
89687: AND
89688: IFFALSE 89890
89690: GO 89692
89692: DISABLE
89693: LD_INT 0
89695: PPUSH
89696: PPUSH
89697: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
89698: LD_ADDR_VAR 0 3
89702: PUSH
89703: LD_INT 81
89705: PUSH
89706: LD_OWVAR 2
89710: PUSH
89711: EMPTY
89712: LIST
89713: LIST
89714: PUSH
89715: LD_INT 21
89717: PUSH
89718: LD_INT 1
89720: PUSH
89721: EMPTY
89722: LIST
89723: LIST
89724: PUSH
89725: EMPTY
89726: LIST
89727: LIST
89728: PPUSH
89729: CALL_OW 69
89733: ST_TO_ADDR
// if not tmp then
89734: LD_VAR 0 3
89738: NOT
89739: IFFALSE 89743
// exit ;
89741: GO 89890
// if tmp > 5 then
89743: LD_VAR 0 3
89747: PUSH
89748: LD_INT 5
89750: GREATER
89751: IFFALSE 89763
// k := 5 else
89753: LD_ADDR_VAR 0 2
89757: PUSH
89758: LD_INT 5
89760: ST_TO_ADDR
89761: GO 89773
// k := tmp ;
89763: LD_ADDR_VAR 0 2
89767: PUSH
89768: LD_VAR 0 3
89772: ST_TO_ADDR
// for i := 1 to k do
89773: LD_ADDR_VAR 0 1
89777: PUSH
89778: DOUBLE
89779: LD_INT 1
89781: DEC
89782: ST_TO_ADDR
89783: LD_VAR 0 2
89787: PUSH
89788: FOR_TO
89789: IFFALSE 89888
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
89791: LD_VAR 0 3
89795: PUSH
89796: LD_VAR 0 1
89800: ARRAY
89801: PPUSH
89802: LD_VAR 0 1
89806: PUSH
89807: LD_INT 4
89809: MOD
89810: PUSH
89811: LD_INT 1
89813: PLUS
89814: PPUSH
89815: CALL_OW 259
89819: PUSH
89820: LD_INT 10
89822: LESS
89823: IFFALSE 89886
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
89825: LD_VAR 0 3
89829: PUSH
89830: LD_VAR 0 1
89834: ARRAY
89835: PPUSH
89836: LD_VAR 0 1
89840: PUSH
89841: LD_INT 4
89843: MOD
89844: PUSH
89845: LD_INT 1
89847: PLUS
89848: PPUSH
89849: LD_VAR 0 3
89853: PUSH
89854: LD_VAR 0 1
89858: ARRAY
89859: PPUSH
89860: LD_VAR 0 1
89864: PUSH
89865: LD_INT 4
89867: MOD
89868: PUSH
89869: LD_INT 1
89871: PLUS
89872: PPUSH
89873: CALL_OW 259
89877: PUSH
89878: LD_INT 1
89880: PLUS
89881: PPUSH
89882: CALL_OW 237
89886: GO 89788
89888: POP
89889: POP
// end ;
89890: PPOPN 3
89892: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
89893: LD_EXP 122
89897: PUSH
89898: LD_EXP 130
89902: AND
89903: IFFALSE 89923
89905: GO 89907
89907: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
89908: LD_INT 4
89910: PPUSH
89911: LD_OWVAR 2
89915: PPUSH
89916: LD_INT 0
89918: PPUSH
89919: CALL_OW 324
89923: END
// every 0 0$1 trigger StreamModeActive and sShovel do
89924: LD_EXP 122
89928: PUSH
89929: LD_EXP 159
89933: AND
89934: IFFALSE 89954
89936: GO 89938
89938: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
89939: LD_INT 19
89941: PPUSH
89942: LD_OWVAR 2
89946: PPUSH
89947: LD_INT 0
89949: PPUSH
89950: CALL_OW 324
89954: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
89955: LD_EXP 122
89959: PUSH
89960: LD_EXP 131
89964: AND
89965: IFFALSE 90067
89967: GO 89969
89969: DISABLE
89970: LD_INT 0
89972: PPUSH
89973: PPUSH
// begin enable ;
89974: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
89975: LD_ADDR_VAR 0 2
89979: PUSH
89980: LD_INT 22
89982: PUSH
89983: LD_OWVAR 2
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: PUSH
89992: LD_INT 2
89994: PUSH
89995: LD_INT 34
89997: PUSH
89998: LD_INT 11
90000: PUSH
90001: EMPTY
90002: LIST
90003: LIST
90004: PUSH
90005: LD_INT 34
90007: PUSH
90008: LD_INT 30
90010: PUSH
90011: EMPTY
90012: LIST
90013: LIST
90014: PUSH
90015: EMPTY
90016: LIST
90017: LIST
90018: LIST
90019: PUSH
90020: EMPTY
90021: LIST
90022: LIST
90023: PPUSH
90024: CALL_OW 69
90028: ST_TO_ADDR
// if not tmp then
90029: LD_VAR 0 2
90033: NOT
90034: IFFALSE 90038
// exit ;
90036: GO 90067
// for i in tmp do
90038: LD_ADDR_VAR 0 1
90042: PUSH
90043: LD_VAR 0 2
90047: PUSH
90048: FOR_IN
90049: IFFALSE 90065
// begin SetLives ( i , 0 ) ;
90051: LD_VAR 0 1
90055: PPUSH
90056: LD_INT 0
90058: PPUSH
90059: CALL_OW 234
// end ;
90063: GO 90048
90065: POP
90066: POP
// end ;
90067: PPOPN 2
90069: END
// every 0 0$1 trigger StreamModeActive and sBunker do
90070: LD_EXP 122
90074: PUSH
90075: LD_EXP 132
90079: AND
90080: IFFALSE 90100
90082: GO 90084
90084: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
90085: LD_INT 32
90087: PPUSH
90088: LD_OWVAR 2
90092: PPUSH
90093: LD_INT 0
90095: PPUSH
90096: CALL_OW 324
90100: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
90101: LD_EXP 122
90105: PUSH
90106: LD_EXP 133
90110: AND
90111: IFFALSE 90292
90113: GO 90115
90115: DISABLE
90116: LD_INT 0
90118: PPUSH
90119: PPUSH
90120: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
90121: LD_ADDR_VAR 0 2
90125: PUSH
90126: LD_INT 22
90128: PUSH
90129: LD_OWVAR 2
90133: PUSH
90134: EMPTY
90135: LIST
90136: LIST
90137: PUSH
90138: LD_INT 33
90140: PUSH
90141: LD_INT 3
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: PUSH
90148: EMPTY
90149: LIST
90150: LIST
90151: PPUSH
90152: CALL_OW 69
90156: ST_TO_ADDR
// if not tmp then
90157: LD_VAR 0 2
90161: NOT
90162: IFFALSE 90166
// exit ;
90164: GO 90292
// side := 0 ;
90166: LD_ADDR_VAR 0 3
90170: PUSH
90171: LD_INT 0
90173: ST_TO_ADDR
// for i := 1 to 8 do
90174: LD_ADDR_VAR 0 1
90178: PUSH
90179: DOUBLE
90180: LD_INT 1
90182: DEC
90183: ST_TO_ADDR
90184: LD_INT 8
90186: PUSH
90187: FOR_TO
90188: IFFALSE 90236
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
90190: LD_OWVAR 2
90194: PUSH
90195: LD_VAR 0 1
90199: NONEQUAL
90200: PUSH
90201: LD_OWVAR 2
90205: PPUSH
90206: LD_VAR 0 1
90210: PPUSH
90211: CALL_OW 81
90215: PUSH
90216: LD_INT 2
90218: EQUAL
90219: AND
90220: IFFALSE 90234
// begin side := i ;
90222: LD_ADDR_VAR 0 3
90226: PUSH
90227: LD_VAR 0 1
90231: ST_TO_ADDR
// break ;
90232: GO 90236
// end ;
90234: GO 90187
90236: POP
90237: POP
// if not side then
90238: LD_VAR 0 3
90242: NOT
90243: IFFALSE 90247
// exit ;
90245: GO 90292
// for i := 1 to tmp do
90247: LD_ADDR_VAR 0 1
90251: PUSH
90252: DOUBLE
90253: LD_INT 1
90255: DEC
90256: ST_TO_ADDR
90257: LD_VAR 0 2
90261: PUSH
90262: FOR_TO
90263: IFFALSE 90290
// if Prob ( 60 ) then
90265: LD_INT 60
90267: PPUSH
90268: CALL_OW 13
90272: IFFALSE 90288
// SetSide ( i , side ) ;
90274: LD_VAR 0 1
90278: PPUSH
90279: LD_VAR 0 3
90283: PPUSH
90284: CALL_OW 235
90288: GO 90262
90290: POP
90291: POP
// end ;
90292: PPOPN 3
90294: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
90295: LD_EXP 122
90299: PUSH
90300: LD_EXP 135
90304: AND
90305: IFFALSE 90424
90307: GO 90309
90309: DISABLE
90310: LD_INT 0
90312: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
90313: LD_ADDR_VAR 0 1
90317: PUSH
90318: LD_INT 22
90320: PUSH
90321: LD_OWVAR 2
90325: PUSH
90326: EMPTY
90327: LIST
90328: LIST
90329: PUSH
90330: LD_INT 21
90332: PUSH
90333: LD_INT 1
90335: PUSH
90336: EMPTY
90337: LIST
90338: LIST
90339: PUSH
90340: LD_INT 3
90342: PUSH
90343: LD_INT 23
90345: PUSH
90346: LD_INT 0
90348: PUSH
90349: EMPTY
90350: LIST
90351: LIST
90352: PUSH
90353: EMPTY
90354: LIST
90355: LIST
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: LIST
90361: PPUSH
90362: CALL_OW 69
90366: PUSH
90367: FOR_IN
90368: IFFALSE 90422
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
90370: LD_VAR 0 1
90374: PPUSH
90375: CALL_OW 257
90379: PUSH
90380: LD_INT 1
90382: PUSH
90383: LD_INT 2
90385: PUSH
90386: LD_INT 3
90388: PUSH
90389: LD_INT 4
90391: PUSH
90392: EMPTY
90393: LIST
90394: LIST
90395: LIST
90396: LIST
90397: IN
90398: IFFALSE 90420
// SetClass ( un , rand ( 1 , 4 ) ) ;
90400: LD_VAR 0 1
90404: PPUSH
90405: LD_INT 1
90407: PPUSH
90408: LD_INT 4
90410: PPUSH
90411: CALL_OW 12
90415: PPUSH
90416: CALL_OW 336
90420: GO 90367
90422: POP
90423: POP
// end ;
90424: PPOPN 1
90426: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
90427: LD_EXP 122
90431: PUSH
90432: LD_EXP 134
90436: AND
90437: IFFALSE 90516
90439: GO 90441
90441: DISABLE
90442: LD_INT 0
90444: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
90445: LD_ADDR_VAR 0 1
90449: PUSH
90450: LD_INT 22
90452: PUSH
90453: LD_OWVAR 2
90457: PUSH
90458: EMPTY
90459: LIST
90460: LIST
90461: PUSH
90462: LD_INT 21
90464: PUSH
90465: LD_INT 3
90467: PUSH
90468: EMPTY
90469: LIST
90470: LIST
90471: PUSH
90472: EMPTY
90473: LIST
90474: LIST
90475: PPUSH
90476: CALL_OW 69
90480: ST_TO_ADDR
// if not tmp then
90481: LD_VAR 0 1
90485: NOT
90486: IFFALSE 90490
// exit ;
90488: GO 90516
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
90490: LD_VAR 0 1
90494: PUSH
90495: LD_INT 1
90497: PPUSH
90498: LD_VAR 0 1
90502: PPUSH
90503: CALL_OW 12
90507: ARRAY
90508: PPUSH
90509: LD_INT 100
90511: PPUSH
90512: CALL_OW 234
// end ;
90516: PPOPN 1
90518: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
90519: LD_EXP 122
90523: PUSH
90524: LD_EXP 136
90528: AND
90529: IFFALSE 90627
90531: GO 90533
90533: DISABLE
90534: LD_INT 0
90536: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
90537: LD_ADDR_VAR 0 1
90541: PUSH
90542: LD_INT 22
90544: PUSH
90545: LD_OWVAR 2
90549: PUSH
90550: EMPTY
90551: LIST
90552: LIST
90553: PUSH
90554: LD_INT 21
90556: PUSH
90557: LD_INT 1
90559: PUSH
90560: EMPTY
90561: LIST
90562: LIST
90563: PUSH
90564: EMPTY
90565: LIST
90566: LIST
90567: PPUSH
90568: CALL_OW 69
90572: ST_TO_ADDR
// if not tmp then
90573: LD_VAR 0 1
90577: NOT
90578: IFFALSE 90582
// exit ;
90580: GO 90627
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
90582: LD_VAR 0 1
90586: PUSH
90587: LD_INT 1
90589: PPUSH
90590: LD_VAR 0 1
90594: PPUSH
90595: CALL_OW 12
90599: ARRAY
90600: PPUSH
90601: LD_INT 1
90603: PPUSH
90604: LD_INT 4
90606: PPUSH
90607: CALL_OW 12
90611: PPUSH
90612: LD_INT 3000
90614: PPUSH
90615: LD_INT 9000
90617: PPUSH
90618: CALL_OW 12
90622: PPUSH
90623: CALL_OW 492
// end ;
90627: PPOPN 1
90629: END
// every 0 0$1 trigger StreamModeActive and sDepot do
90630: LD_EXP 122
90634: PUSH
90635: LD_EXP 137
90639: AND
90640: IFFALSE 90660
90642: GO 90644
90644: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
90645: LD_INT 1
90647: PPUSH
90648: LD_OWVAR 2
90652: PPUSH
90653: LD_INT 0
90655: PPUSH
90656: CALL_OW 324
90660: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
90661: LD_EXP 122
90665: PUSH
90666: LD_EXP 138
90670: AND
90671: IFFALSE 90754
90673: GO 90675
90675: DISABLE
90676: LD_INT 0
90678: PPUSH
90679: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
90680: LD_ADDR_VAR 0 2
90684: PUSH
90685: LD_INT 22
90687: PUSH
90688: LD_OWVAR 2
90692: PUSH
90693: EMPTY
90694: LIST
90695: LIST
90696: PUSH
90697: LD_INT 21
90699: PUSH
90700: LD_INT 3
90702: PUSH
90703: EMPTY
90704: LIST
90705: LIST
90706: PUSH
90707: EMPTY
90708: LIST
90709: LIST
90710: PPUSH
90711: CALL_OW 69
90715: ST_TO_ADDR
// if not tmp then
90716: LD_VAR 0 2
90720: NOT
90721: IFFALSE 90725
// exit ;
90723: GO 90754
// for i in tmp do
90725: LD_ADDR_VAR 0 1
90729: PUSH
90730: LD_VAR 0 2
90734: PUSH
90735: FOR_IN
90736: IFFALSE 90752
// SetBLevel ( i , 10 ) ;
90738: LD_VAR 0 1
90742: PPUSH
90743: LD_INT 10
90745: PPUSH
90746: CALL_OW 241
90750: GO 90735
90752: POP
90753: POP
// end ;
90754: PPOPN 2
90756: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
90757: LD_EXP 122
90761: PUSH
90762: LD_EXP 139
90766: AND
90767: IFFALSE 90878
90769: GO 90771
90771: DISABLE
90772: LD_INT 0
90774: PPUSH
90775: PPUSH
90776: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90777: LD_ADDR_VAR 0 3
90781: PUSH
90782: LD_INT 22
90784: PUSH
90785: LD_OWVAR 2
90789: PUSH
90790: EMPTY
90791: LIST
90792: LIST
90793: PUSH
90794: LD_INT 25
90796: PUSH
90797: LD_INT 1
90799: PUSH
90800: EMPTY
90801: LIST
90802: LIST
90803: PUSH
90804: EMPTY
90805: LIST
90806: LIST
90807: PPUSH
90808: CALL_OW 69
90812: ST_TO_ADDR
// if not tmp then
90813: LD_VAR 0 3
90817: NOT
90818: IFFALSE 90822
// exit ;
90820: GO 90878
// un := tmp [ rand ( 1 , tmp ) ] ;
90822: LD_ADDR_VAR 0 2
90826: PUSH
90827: LD_VAR 0 3
90831: PUSH
90832: LD_INT 1
90834: PPUSH
90835: LD_VAR 0 3
90839: PPUSH
90840: CALL_OW 12
90844: ARRAY
90845: ST_TO_ADDR
// if Crawls ( un ) then
90846: LD_VAR 0 2
90850: PPUSH
90851: CALL_OW 318
90855: IFFALSE 90866
// ComWalk ( un ) ;
90857: LD_VAR 0 2
90861: PPUSH
90862: CALL_OW 138
// SetClass ( un , class_sniper ) ;
90866: LD_VAR 0 2
90870: PPUSH
90871: LD_INT 5
90873: PPUSH
90874: CALL_OW 336
// end ;
90878: PPOPN 3
90880: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
90881: LD_EXP 122
90885: PUSH
90886: LD_EXP 140
90890: AND
90891: PUSH
90892: LD_OWVAR 67
90896: PUSH
90897: LD_INT 3
90899: LESS
90900: AND
90901: IFFALSE 90920
90903: GO 90905
90905: DISABLE
// Difficulty := Difficulty + 1 ;
90906: LD_ADDR_OWVAR 67
90910: PUSH
90911: LD_OWVAR 67
90915: PUSH
90916: LD_INT 1
90918: PLUS
90919: ST_TO_ADDR
90920: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
90921: LD_EXP 122
90925: PUSH
90926: LD_EXP 141
90930: AND
90931: IFFALSE 91034
90933: GO 90935
90935: DISABLE
90936: LD_INT 0
90938: PPUSH
// begin for i := 1 to 5 do
90939: LD_ADDR_VAR 0 1
90943: PUSH
90944: DOUBLE
90945: LD_INT 1
90947: DEC
90948: ST_TO_ADDR
90949: LD_INT 5
90951: PUSH
90952: FOR_TO
90953: IFFALSE 91032
// begin uc_nation := nation_nature ;
90955: LD_ADDR_OWVAR 21
90959: PUSH
90960: LD_INT 0
90962: ST_TO_ADDR
// uc_side := 0 ;
90963: LD_ADDR_OWVAR 20
90967: PUSH
90968: LD_INT 0
90970: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
90971: LD_ADDR_OWVAR 29
90975: PUSH
90976: LD_INT 12
90978: PUSH
90979: LD_INT 12
90981: PUSH
90982: EMPTY
90983: LIST
90984: LIST
90985: ST_TO_ADDR
// hc_agressivity := 20 ;
90986: LD_ADDR_OWVAR 35
90990: PUSH
90991: LD_INT 20
90993: ST_TO_ADDR
// hc_class := class_tiger ;
90994: LD_ADDR_OWVAR 28
90998: PUSH
90999: LD_INT 14
91001: ST_TO_ADDR
// hc_gallery :=  ;
91002: LD_ADDR_OWVAR 33
91006: PUSH
91007: LD_STRING 
91009: ST_TO_ADDR
// hc_name :=  ;
91010: LD_ADDR_OWVAR 26
91014: PUSH
91015: LD_STRING 
91017: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
91018: CALL_OW 44
91022: PPUSH
91023: LD_INT 0
91025: PPUSH
91026: CALL_OW 51
// end ;
91030: GO 90952
91032: POP
91033: POP
// end ;
91034: PPOPN 1
91036: END
// every 0 0$1 trigger StreamModeActive and sBomb do
91037: LD_EXP 122
91041: PUSH
91042: LD_EXP 142
91046: AND
91047: IFFALSE 91056
91049: GO 91051
91051: DISABLE
// StreamSibBomb ;
91052: CALL 91057 0 0
91056: END
// export function StreamSibBomb ; var i , x , y ; begin
91057: LD_INT 0
91059: PPUSH
91060: PPUSH
91061: PPUSH
91062: PPUSH
// result := false ;
91063: LD_ADDR_VAR 0 1
91067: PUSH
91068: LD_INT 0
91070: ST_TO_ADDR
// for i := 1 to 16 do
91071: LD_ADDR_VAR 0 2
91075: PUSH
91076: DOUBLE
91077: LD_INT 1
91079: DEC
91080: ST_TO_ADDR
91081: LD_INT 16
91083: PUSH
91084: FOR_TO
91085: IFFALSE 91284
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
91087: LD_ADDR_VAR 0 3
91091: PUSH
91092: LD_INT 10
91094: PUSH
91095: LD_INT 20
91097: PUSH
91098: LD_INT 30
91100: PUSH
91101: LD_INT 40
91103: PUSH
91104: LD_INT 50
91106: PUSH
91107: LD_INT 60
91109: PUSH
91110: LD_INT 70
91112: PUSH
91113: LD_INT 80
91115: PUSH
91116: LD_INT 90
91118: PUSH
91119: LD_INT 100
91121: PUSH
91122: LD_INT 110
91124: PUSH
91125: LD_INT 120
91127: PUSH
91128: LD_INT 130
91130: PUSH
91131: LD_INT 140
91133: PUSH
91134: LD_INT 150
91136: PUSH
91137: EMPTY
91138: LIST
91139: LIST
91140: LIST
91141: LIST
91142: LIST
91143: LIST
91144: LIST
91145: LIST
91146: LIST
91147: LIST
91148: LIST
91149: LIST
91150: LIST
91151: LIST
91152: LIST
91153: PUSH
91154: LD_INT 1
91156: PPUSH
91157: LD_INT 15
91159: PPUSH
91160: CALL_OW 12
91164: ARRAY
91165: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
91166: LD_ADDR_VAR 0 4
91170: PUSH
91171: LD_INT 10
91173: PUSH
91174: LD_INT 20
91176: PUSH
91177: LD_INT 30
91179: PUSH
91180: LD_INT 40
91182: PUSH
91183: LD_INT 50
91185: PUSH
91186: LD_INT 60
91188: PUSH
91189: LD_INT 70
91191: PUSH
91192: LD_INT 80
91194: PUSH
91195: LD_INT 90
91197: PUSH
91198: LD_INT 100
91200: PUSH
91201: LD_INT 110
91203: PUSH
91204: LD_INT 120
91206: PUSH
91207: LD_INT 130
91209: PUSH
91210: LD_INT 140
91212: PUSH
91213: LD_INT 150
91215: PUSH
91216: EMPTY
91217: LIST
91218: LIST
91219: LIST
91220: LIST
91221: LIST
91222: LIST
91223: LIST
91224: LIST
91225: LIST
91226: LIST
91227: LIST
91228: LIST
91229: LIST
91230: LIST
91231: LIST
91232: PUSH
91233: LD_INT 1
91235: PPUSH
91236: LD_INT 15
91238: PPUSH
91239: CALL_OW 12
91243: ARRAY
91244: ST_TO_ADDR
// if ValidHex ( x , y ) then
91245: LD_VAR 0 3
91249: PPUSH
91250: LD_VAR 0 4
91254: PPUSH
91255: CALL_OW 488
91259: IFFALSE 91282
// begin result := [ x , y ] ;
91261: LD_ADDR_VAR 0 1
91265: PUSH
91266: LD_VAR 0 3
91270: PUSH
91271: LD_VAR 0 4
91275: PUSH
91276: EMPTY
91277: LIST
91278: LIST
91279: ST_TO_ADDR
// break ;
91280: GO 91284
// end ; end ;
91282: GO 91084
91284: POP
91285: POP
// if result then
91286: LD_VAR 0 1
91290: IFFALSE 91350
// begin ToLua ( playSibBomb() ) ;
91292: LD_STRING playSibBomb()
91294: PPUSH
91295: CALL_OW 559
// wait ( 0 0$14 ) ;
91299: LD_INT 490
91301: PPUSH
91302: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
91306: LD_VAR 0 1
91310: PUSH
91311: LD_INT 1
91313: ARRAY
91314: PPUSH
91315: LD_VAR 0 1
91319: PUSH
91320: LD_INT 2
91322: ARRAY
91323: PPUSH
91324: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
91328: LD_VAR 0 1
91332: PUSH
91333: LD_INT 1
91335: ARRAY
91336: PPUSH
91337: LD_VAR 0 1
91341: PUSH
91342: LD_INT 2
91344: ARRAY
91345: PPUSH
91346: CALL_OW 429
// end ; end ;
91350: LD_VAR 0 1
91354: RET
// every 0 0$1 trigger StreamModeActive and sReset do
91355: LD_EXP 122
91359: PUSH
91360: LD_EXP 144
91364: AND
91365: IFFALSE 91377
91367: GO 91369
91369: DISABLE
// YouLost (  ) ;
91370: LD_STRING 
91372: PPUSH
91373: CALL_OW 104
91377: END
// every 0 0$1 trigger StreamModeActive and sFog do
91378: LD_EXP 122
91382: PUSH
91383: LD_EXP 143
91387: AND
91388: IFFALSE 91402
91390: GO 91392
91392: DISABLE
// FogOff ( your_side ) ;
91393: LD_OWVAR 2
91397: PPUSH
91398: CALL_OW 344
91402: END
// every 0 0$1 trigger StreamModeActive and sSun do
91403: LD_EXP 122
91407: PUSH
91408: LD_EXP 145
91412: AND
91413: IFFALSE 91441
91415: GO 91417
91417: DISABLE
// begin solar_recharge_percent := 0 ;
91418: LD_ADDR_OWVAR 79
91422: PUSH
91423: LD_INT 0
91425: ST_TO_ADDR
// wait ( 5 5$00 ) ;
91426: LD_INT 10500
91428: PPUSH
91429: CALL_OW 67
// solar_recharge_percent := 100 ;
91433: LD_ADDR_OWVAR 79
91437: PUSH
91438: LD_INT 100
91440: ST_TO_ADDR
// end ;
91441: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
91442: LD_EXP 122
91446: PUSH
91447: LD_EXP 146
91451: AND
91452: IFFALSE 91691
91454: GO 91456
91456: DISABLE
91457: LD_INT 0
91459: PPUSH
91460: PPUSH
91461: PPUSH
// begin tmp := [ ] ;
91462: LD_ADDR_VAR 0 3
91466: PUSH
91467: EMPTY
91468: ST_TO_ADDR
// for i := 1 to 6 do
91469: LD_ADDR_VAR 0 1
91473: PUSH
91474: DOUBLE
91475: LD_INT 1
91477: DEC
91478: ST_TO_ADDR
91479: LD_INT 6
91481: PUSH
91482: FOR_TO
91483: IFFALSE 91588
// begin uc_nation := nation_nature ;
91485: LD_ADDR_OWVAR 21
91489: PUSH
91490: LD_INT 0
91492: ST_TO_ADDR
// uc_side := 0 ;
91493: LD_ADDR_OWVAR 20
91497: PUSH
91498: LD_INT 0
91500: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
91501: LD_ADDR_OWVAR 29
91505: PUSH
91506: LD_INT 12
91508: PUSH
91509: LD_INT 12
91511: PUSH
91512: EMPTY
91513: LIST
91514: LIST
91515: ST_TO_ADDR
// hc_agressivity := 20 ;
91516: LD_ADDR_OWVAR 35
91520: PUSH
91521: LD_INT 20
91523: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
91524: LD_ADDR_OWVAR 28
91528: PUSH
91529: LD_INT 17
91531: ST_TO_ADDR
// hc_gallery :=  ;
91532: LD_ADDR_OWVAR 33
91536: PUSH
91537: LD_STRING 
91539: ST_TO_ADDR
// hc_name :=  ;
91540: LD_ADDR_OWVAR 26
91544: PUSH
91545: LD_STRING 
91547: ST_TO_ADDR
// un := CreateHuman ;
91548: LD_ADDR_VAR 0 2
91552: PUSH
91553: CALL_OW 44
91557: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
91558: LD_VAR 0 2
91562: PPUSH
91563: LD_INT 1
91565: PPUSH
91566: CALL_OW 51
// tmp := tmp ^ un ;
91570: LD_ADDR_VAR 0 3
91574: PUSH
91575: LD_VAR 0 3
91579: PUSH
91580: LD_VAR 0 2
91584: ADD
91585: ST_TO_ADDR
// end ;
91586: GO 91482
91588: POP
91589: POP
// repeat wait ( 0 0$1 ) ;
91590: LD_INT 35
91592: PPUSH
91593: CALL_OW 67
// for un in tmp do
91597: LD_ADDR_VAR 0 2
91601: PUSH
91602: LD_VAR 0 3
91606: PUSH
91607: FOR_IN
91608: IFFALSE 91682
// begin if IsDead ( un ) then
91610: LD_VAR 0 2
91614: PPUSH
91615: CALL_OW 301
91619: IFFALSE 91639
// begin tmp := tmp diff un ;
91621: LD_ADDR_VAR 0 3
91625: PUSH
91626: LD_VAR 0 3
91630: PUSH
91631: LD_VAR 0 2
91635: DIFF
91636: ST_TO_ADDR
// continue ;
91637: GO 91607
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
91639: LD_VAR 0 2
91643: PPUSH
91644: LD_INT 3
91646: PUSH
91647: LD_INT 22
91649: PUSH
91650: LD_INT 0
91652: PUSH
91653: EMPTY
91654: LIST
91655: LIST
91656: PUSH
91657: EMPTY
91658: LIST
91659: LIST
91660: PPUSH
91661: CALL_OW 69
91665: PPUSH
91666: LD_VAR 0 2
91670: PPUSH
91671: CALL_OW 74
91675: PPUSH
91676: CALL_OW 115
// end ;
91680: GO 91607
91682: POP
91683: POP
// until not tmp ;
91684: LD_VAR 0 3
91688: NOT
91689: IFFALSE 91590
// end ;
91691: PPOPN 3
91693: END
// every 0 0$1 trigger StreamModeActive and sTroll do
91694: LD_EXP 122
91698: PUSH
91699: LD_EXP 147
91703: AND
91704: IFFALSE 91758
91706: GO 91708
91708: DISABLE
// begin ToLua ( displayTroll(); ) ;
91709: LD_STRING displayTroll();
91711: PPUSH
91712: CALL_OW 559
// wait ( 3 3$00 ) ;
91716: LD_INT 6300
91718: PPUSH
91719: CALL_OW 67
// ToLua ( hideTroll(); ) ;
91723: LD_STRING hideTroll();
91725: PPUSH
91726: CALL_OW 559
// wait ( 1 1$00 ) ;
91730: LD_INT 2100
91732: PPUSH
91733: CALL_OW 67
// ToLua ( displayTroll(); ) ;
91737: LD_STRING displayTroll();
91739: PPUSH
91740: CALL_OW 559
// wait ( 1 1$00 ) ;
91744: LD_INT 2100
91746: PPUSH
91747: CALL_OW 67
// ToLua ( hideTroll(); ) ;
91751: LD_STRING hideTroll();
91753: PPUSH
91754: CALL_OW 559
// end ;
91758: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
91759: LD_EXP 122
91763: PUSH
91764: LD_EXP 148
91768: AND
91769: IFFALSE 91832
91771: GO 91773
91773: DISABLE
91774: LD_INT 0
91776: PPUSH
// begin p := 0 ;
91777: LD_ADDR_VAR 0 1
91781: PUSH
91782: LD_INT 0
91784: ST_TO_ADDR
// repeat game_speed := 1 ;
91785: LD_ADDR_OWVAR 65
91789: PUSH
91790: LD_INT 1
91792: ST_TO_ADDR
// wait ( 0 0$1 ) ;
91793: LD_INT 35
91795: PPUSH
91796: CALL_OW 67
// p := p + 1 ;
91800: LD_ADDR_VAR 0 1
91804: PUSH
91805: LD_VAR 0 1
91809: PUSH
91810: LD_INT 1
91812: PLUS
91813: ST_TO_ADDR
// until p >= 60 ;
91814: LD_VAR 0 1
91818: PUSH
91819: LD_INT 60
91821: GREATEREQUAL
91822: IFFALSE 91785
// game_speed := 4 ;
91824: LD_ADDR_OWVAR 65
91828: PUSH
91829: LD_INT 4
91831: ST_TO_ADDR
// end ;
91832: PPOPN 1
91834: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
91835: LD_EXP 122
91839: PUSH
91840: LD_EXP 149
91844: AND
91845: IFFALSE 91991
91847: GO 91849
91849: DISABLE
91850: LD_INT 0
91852: PPUSH
91853: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
91854: LD_ADDR_VAR 0 1
91858: PUSH
91859: LD_INT 22
91861: PUSH
91862: LD_OWVAR 2
91866: PUSH
91867: EMPTY
91868: LIST
91869: LIST
91870: PUSH
91871: LD_INT 2
91873: PUSH
91874: LD_INT 30
91876: PUSH
91877: LD_INT 0
91879: PUSH
91880: EMPTY
91881: LIST
91882: LIST
91883: PUSH
91884: LD_INT 30
91886: PUSH
91887: LD_INT 1
91889: PUSH
91890: EMPTY
91891: LIST
91892: LIST
91893: PUSH
91894: EMPTY
91895: LIST
91896: LIST
91897: LIST
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: PPUSH
91903: CALL_OW 69
91907: ST_TO_ADDR
// if not depot then
91908: LD_VAR 0 1
91912: NOT
91913: IFFALSE 91917
// exit ;
91915: GO 91991
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
91917: LD_ADDR_VAR 0 2
91921: PUSH
91922: LD_VAR 0 1
91926: PUSH
91927: LD_INT 1
91929: PPUSH
91930: LD_VAR 0 1
91934: PPUSH
91935: CALL_OW 12
91939: ARRAY
91940: PPUSH
91941: CALL_OW 274
91945: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
91946: LD_VAR 0 2
91950: PPUSH
91951: LD_INT 1
91953: PPUSH
91954: LD_INT 0
91956: PPUSH
91957: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
91961: LD_VAR 0 2
91965: PPUSH
91966: LD_INT 2
91968: PPUSH
91969: LD_INT 0
91971: PPUSH
91972: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
91976: LD_VAR 0 2
91980: PPUSH
91981: LD_INT 3
91983: PPUSH
91984: LD_INT 0
91986: PPUSH
91987: CALL_OW 277
// end ;
91991: PPOPN 2
91993: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
91994: LD_EXP 122
91998: PUSH
91999: LD_EXP 150
92003: AND
92004: IFFALSE 92101
92006: GO 92008
92008: DISABLE
92009: LD_INT 0
92011: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92012: LD_ADDR_VAR 0 1
92016: PUSH
92017: LD_INT 22
92019: PUSH
92020: LD_OWVAR 2
92024: PUSH
92025: EMPTY
92026: LIST
92027: LIST
92028: PUSH
92029: LD_INT 21
92031: PUSH
92032: LD_INT 1
92034: PUSH
92035: EMPTY
92036: LIST
92037: LIST
92038: PUSH
92039: LD_INT 3
92041: PUSH
92042: LD_INT 23
92044: PUSH
92045: LD_INT 0
92047: PUSH
92048: EMPTY
92049: LIST
92050: LIST
92051: PUSH
92052: EMPTY
92053: LIST
92054: LIST
92055: PUSH
92056: EMPTY
92057: LIST
92058: LIST
92059: LIST
92060: PPUSH
92061: CALL_OW 69
92065: ST_TO_ADDR
// if not tmp then
92066: LD_VAR 0 1
92070: NOT
92071: IFFALSE 92075
// exit ;
92073: GO 92101
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
92075: LD_VAR 0 1
92079: PUSH
92080: LD_INT 1
92082: PPUSH
92083: LD_VAR 0 1
92087: PPUSH
92088: CALL_OW 12
92092: ARRAY
92093: PPUSH
92094: LD_INT 200
92096: PPUSH
92097: CALL_OW 234
// end ;
92101: PPOPN 1
92103: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
92104: LD_EXP 122
92108: PUSH
92109: LD_EXP 151
92113: AND
92114: IFFALSE 92193
92116: GO 92118
92118: DISABLE
92119: LD_INT 0
92121: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
92122: LD_ADDR_VAR 0 1
92126: PUSH
92127: LD_INT 22
92129: PUSH
92130: LD_OWVAR 2
92134: PUSH
92135: EMPTY
92136: LIST
92137: LIST
92138: PUSH
92139: LD_INT 21
92141: PUSH
92142: LD_INT 2
92144: PUSH
92145: EMPTY
92146: LIST
92147: LIST
92148: PUSH
92149: EMPTY
92150: LIST
92151: LIST
92152: PPUSH
92153: CALL_OW 69
92157: ST_TO_ADDR
// if not tmp then
92158: LD_VAR 0 1
92162: NOT
92163: IFFALSE 92167
// exit ;
92165: GO 92193
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
92167: LD_VAR 0 1
92171: PUSH
92172: LD_INT 1
92174: PPUSH
92175: LD_VAR 0 1
92179: PPUSH
92180: CALL_OW 12
92184: ARRAY
92185: PPUSH
92186: LD_INT 60
92188: PPUSH
92189: CALL_OW 234
// end ;
92193: PPOPN 1
92195: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
92196: LD_EXP 122
92200: PUSH
92201: LD_EXP 152
92205: AND
92206: IFFALSE 92305
92208: GO 92210
92210: DISABLE
92211: LD_INT 0
92213: PPUSH
92214: PPUSH
// begin enable ;
92215: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
92216: LD_ADDR_VAR 0 1
92220: PUSH
92221: LD_INT 22
92223: PUSH
92224: LD_OWVAR 2
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: PUSH
92233: LD_INT 61
92235: PUSH
92236: EMPTY
92237: LIST
92238: PUSH
92239: LD_INT 33
92241: PUSH
92242: LD_INT 2
92244: PUSH
92245: EMPTY
92246: LIST
92247: LIST
92248: PUSH
92249: EMPTY
92250: LIST
92251: LIST
92252: LIST
92253: PPUSH
92254: CALL_OW 69
92258: ST_TO_ADDR
// if not tmp then
92259: LD_VAR 0 1
92263: NOT
92264: IFFALSE 92268
// exit ;
92266: GO 92305
// for i in tmp do
92268: LD_ADDR_VAR 0 2
92272: PUSH
92273: LD_VAR 0 1
92277: PUSH
92278: FOR_IN
92279: IFFALSE 92303
// if IsControledBy ( i ) then
92281: LD_VAR 0 2
92285: PPUSH
92286: CALL_OW 312
92290: IFFALSE 92301
// ComUnlink ( i ) ;
92292: LD_VAR 0 2
92296: PPUSH
92297: CALL_OW 136
92301: GO 92278
92303: POP
92304: POP
// end ;
92305: PPOPN 2
92307: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
92308: LD_EXP 122
92312: PUSH
92313: LD_EXP 153
92317: AND
92318: IFFALSE 92458
92320: GO 92322
92322: DISABLE
92323: LD_INT 0
92325: PPUSH
92326: PPUSH
// begin ToLua ( displayPowell(); ) ;
92327: LD_STRING displayPowell();
92329: PPUSH
92330: CALL_OW 559
// uc_side := 0 ;
92334: LD_ADDR_OWVAR 20
92338: PUSH
92339: LD_INT 0
92341: ST_TO_ADDR
// uc_nation := 2 ;
92342: LD_ADDR_OWVAR 21
92346: PUSH
92347: LD_INT 2
92349: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
92350: LD_ADDR_OWVAR 37
92354: PUSH
92355: LD_INT 14
92357: ST_TO_ADDR
// vc_engine := engine_siberite ;
92358: LD_ADDR_OWVAR 39
92362: PUSH
92363: LD_INT 3
92365: ST_TO_ADDR
// vc_control := control_apeman ;
92366: LD_ADDR_OWVAR 38
92370: PUSH
92371: LD_INT 5
92373: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
92374: LD_ADDR_OWVAR 40
92378: PUSH
92379: LD_INT 29
92381: ST_TO_ADDR
// un := CreateVehicle ;
92382: LD_ADDR_VAR 0 2
92386: PUSH
92387: CALL_OW 45
92391: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92392: LD_VAR 0 2
92396: PPUSH
92397: LD_INT 1
92399: PPUSH
92400: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
92404: LD_INT 35
92406: PPUSH
92407: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
92411: LD_VAR 0 2
92415: PPUSH
92416: LD_INT 22
92418: PUSH
92419: LD_OWVAR 2
92423: PUSH
92424: EMPTY
92425: LIST
92426: LIST
92427: PPUSH
92428: CALL_OW 69
92432: PPUSH
92433: LD_VAR 0 2
92437: PPUSH
92438: CALL_OW 74
92442: PPUSH
92443: CALL_OW 115
// until IsDead ( un ) ;
92447: LD_VAR 0 2
92451: PPUSH
92452: CALL_OW 301
92456: IFFALSE 92404
// end ;
92458: PPOPN 2
92460: END
// every 0 0$1 trigger StreamModeActive and sStu do
92461: LD_EXP 122
92465: PUSH
92466: LD_EXP 161
92470: AND
92471: IFFALSE 92487
92473: GO 92475
92475: DISABLE
// begin ToLua ( displayStucuk(); ) ;
92476: LD_STRING displayStucuk();
92478: PPUSH
92479: CALL_OW 559
// ResetFog ;
92483: CALL_OW 335
// end ;
92487: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
92488: LD_EXP 122
92492: PUSH
92493: LD_EXP 154
92497: AND
92498: IFFALSE 92639
92500: GO 92502
92502: DISABLE
92503: LD_INT 0
92505: PPUSH
92506: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92507: LD_ADDR_VAR 0 2
92511: PUSH
92512: LD_INT 22
92514: PUSH
92515: LD_OWVAR 2
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: PUSH
92524: LD_INT 21
92526: PUSH
92527: LD_INT 1
92529: PUSH
92530: EMPTY
92531: LIST
92532: LIST
92533: PUSH
92534: EMPTY
92535: LIST
92536: LIST
92537: PPUSH
92538: CALL_OW 69
92542: ST_TO_ADDR
// if not tmp then
92543: LD_VAR 0 2
92547: NOT
92548: IFFALSE 92552
// exit ;
92550: GO 92639
// un := tmp [ rand ( 1 , tmp ) ] ;
92552: LD_ADDR_VAR 0 1
92556: PUSH
92557: LD_VAR 0 2
92561: PUSH
92562: LD_INT 1
92564: PPUSH
92565: LD_VAR 0 2
92569: PPUSH
92570: CALL_OW 12
92574: ARRAY
92575: ST_TO_ADDR
// SetSide ( un , 0 ) ;
92576: LD_VAR 0 1
92580: PPUSH
92581: LD_INT 0
92583: PPUSH
92584: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
92588: LD_VAR 0 1
92592: PPUSH
92593: LD_OWVAR 3
92597: PUSH
92598: LD_VAR 0 1
92602: DIFF
92603: PPUSH
92604: LD_VAR 0 1
92608: PPUSH
92609: CALL_OW 74
92613: PPUSH
92614: CALL_OW 115
// wait ( 0 0$20 ) ;
92618: LD_INT 700
92620: PPUSH
92621: CALL_OW 67
// SetSide ( un , your_side ) ;
92625: LD_VAR 0 1
92629: PPUSH
92630: LD_OWVAR 2
92634: PPUSH
92635: CALL_OW 235
// end ;
92639: PPOPN 2
92641: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
92642: LD_EXP 122
92646: PUSH
92647: LD_EXP 155
92651: AND
92652: IFFALSE 92758
92654: GO 92656
92656: DISABLE
92657: LD_INT 0
92659: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92660: LD_ADDR_VAR 0 1
92664: PUSH
92665: LD_INT 22
92667: PUSH
92668: LD_OWVAR 2
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: LD_INT 2
92679: PUSH
92680: LD_INT 30
92682: PUSH
92683: LD_INT 0
92685: PUSH
92686: EMPTY
92687: LIST
92688: LIST
92689: PUSH
92690: LD_INT 30
92692: PUSH
92693: LD_INT 1
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: PUSH
92700: EMPTY
92701: LIST
92702: LIST
92703: LIST
92704: PUSH
92705: EMPTY
92706: LIST
92707: LIST
92708: PPUSH
92709: CALL_OW 69
92713: ST_TO_ADDR
// if not depot then
92714: LD_VAR 0 1
92718: NOT
92719: IFFALSE 92723
// exit ;
92721: GO 92758
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
92723: LD_VAR 0 1
92727: PUSH
92728: LD_INT 1
92730: ARRAY
92731: PPUSH
92732: CALL_OW 250
92736: PPUSH
92737: LD_VAR 0 1
92741: PUSH
92742: LD_INT 1
92744: ARRAY
92745: PPUSH
92746: CALL_OW 251
92750: PPUSH
92751: LD_INT 70
92753: PPUSH
92754: CALL_OW 495
// end ;
92758: PPOPN 1
92760: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
92761: LD_EXP 122
92765: PUSH
92766: LD_EXP 156
92770: AND
92771: IFFALSE 92982
92773: GO 92775
92775: DISABLE
92776: LD_INT 0
92778: PPUSH
92779: PPUSH
92780: PPUSH
92781: PPUSH
92782: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92783: LD_ADDR_VAR 0 5
92787: PUSH
92788: LD_INT 22
92790: PUSH
92791: LD_OWVAR 2
92795: PUSH
92796: EMPTY
92797: LIST
92798: LIST
92799: PUSH
92800: LD_INT 21
92802: PUSH
92803: LD_INT 1
92805: PUSH
92806: EMPTY
92807: LIST
92808: LIST
92809: PUSH
92810: EMPTY
92811: LIST
92812: LIST
92813: PPUSH
92814: CALL_OW 69
92818: ST_TO_ADDR
// if not tmp then
92819: LD_VAR 0 5
92823: NOT
92824: IFFALSE 92828
// exit ;
92826: GO 92982
// for i in tmp do
92828: LD_ADDR_VAR 0 1
92832: PUSH
92833: LD_VAR 0 5
92837: PUSH
92838: FOR_IN
92839: IFFALSE 92980
// begin d := rand ( 0 , 5 ) ;
92841: LD_ADDR_VAR 0 4
92845: PUSH
92846: LD_INT 0
92848: PPUSH
92849: LD_INT 5
92851: PPUSH
92852: CALL_OW 12
92856: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
92857: LD_ADDR_VAR 0 2
92861: PUSH
92862: LD_VAR 0 1
92866: PPUSH
92867: CALL_OW 250
92871: PPUSH
92872: LD_VAR 0 4
92876: PPUSH
92877: LD_INT 3
92879: PPUSH
92880: LD_INT 12
92882: PPUSH
92883: CALL_OW 12
92887: PPUSH
92888: CALL_OW 272
92892: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
92893: LD_ADDR_VAR 0 3
92897: PUSH
92898: LD_VAR 0 1
92902: PPUSH
92903: CALL_OW 251
92907: PPUSH
92908: LD_VAR 0 4
92912: PPUSH
92913: LD_INT 3
92915: PPUSH
92916: LD_INT 12
92918: PPUSH
92919: CALL_OW 12
92923: PPUSH
92924: CALL_OW 273
92928: ST_TO_ADDR
// if ValidHex ( x , y ) then
92929: LD_VAR 0 2
92933: PPUSH
92934: LD_VAR 0 3
92938: PPUSH
92939: CALL_OW 488
92943: IFFALSE 92978
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
92945: LD_VAR 0 1
92949: PPUSH
92950: LD_VAR 0 2
92954: PPUSH
92955: LD_VAR 0 3
92959: PPUSH
92960: LD_INT 3
92962: PPUSH
92963: LD_INT 6
92965: PPUSH
92966: CALL_OW 12
92970: PPUSH
92971: LD_INT 1
92973: PPUSH
92974: CALL_OW 483
// end ;
92978: GO 92838
92980: POP
92981: POP
// end ;
92982: PPOPN 5
92984: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
92985: LD_EXP 122
92989: PUSH
92990: LD_EXP 157
92994: AND
92995: IFFALSE 93089
92997: GO 92999
92999: DISABLE
93000: LD_INT 0
93002: PPUSH
93003: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
93004: LD_ADDR_VAR 0 2
93008: PUSH
93009: LD_INT 22
93011: PUSH
93012: LD_OWVAR 2
93016: PUSH
93017: EMPTY
93018: LIST
93019: LIST
93020: PUSH
93021: LD_INT 32
93023: PUSH
93024: LD_INT 1
93026: PUSH
93027: EMPTY
93028: LIST
93029: LIST
93030: PUSH
93031: LD_INT 21
93033: PUSH
93034: LD_INT 2
93036: PUSH
93037: EMPTY
93038: LIST
93039: LIST
93040: PUSH
93041: EMPTY
93042: LIST
93043: LIST
93044: LIST
93045: PPUSH
93046: CALL_OW 69
93050: ST_TO_ADDR
// if not tmp then
93051: LD_VAR 0 2
93055: NOT
93056: IFFALSE 93060
// exit ;
93058: GO 93089
// for i in tmp do
93060: LD_ADDR_VAR 0 1
93064: PUSH
93065: LD_VAR 0 2
93069: PUSH
93070: FOR_IN
93071: IFFALSE 93087
// SetFuel ( i , 0 ) ;
93073: LD_VAR 0 1
93077: PPUSH
93078: LD_INT 0
93080: PPUSH
93081: CALL_OW 240
93085: GO 93070
93087: POP
93088: POP
// end ;
93089: PPOPN 2
93091: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
93092: LD_EXP 122
93096: PUSH
93097: LD_EXP 158
93101: AND
93102: IFFALSE 93168
93104: GO 93106
93106: DISABLE
93107: LD_INT 0
93109: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
93110: LD_ADDR_VAR 0 1
93114: PUSH
93115: LD_INT 22
93117: PUSH
93118: LD_OWVAR 2
93122: PUSH
93123: EMPTY
93124: LIST
93125: LIST
93126: PUSH
93127: LD_INT 30
93129: PUSH
93130: LD_INT 29
93132: PUSH
93133: EMPTY
93134: LIST
93135: LIST
93136: PUSH
93137: EMPTY
93138: LIST
93139: LIST
93140: PPUSH
93141: CALL_OW 69
93145: ST_TO_ADDR
// if not tmp then
93146: LD_VAR 0 1
93150: NOT
93151: IFFALSE 93155
// exit ;
93153: GO 93168
// DestroyUnit ( tmp [ 1 ] ) ;
93155: LD_VAR 0 1
93159: PUSH
93160: LD_INT 1
93162: ARRAY
93163: PPUSH
93164: CALL_OW 65
// end ;
93168: PPOPN 1
93170: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
93171: LD_EXP 122
93175: PUSH
93176: LD_EXP 160
93180: AND
93181: IFFALSE 93310
93183: GO 93185
93185: DISABLE
93186: LD_INT 0
93188: PPUSH
// begin uc_side := 0 ;
93189: LD_ADDR_OWVAR 20
93193: PUSH
93194: LD_INT 0
93196: ST_TO_ADDR
// uc_nation := nation_arabian ;
93197: LD_ADDR_OWVAR 21
93201: PUSH
93202: LD_INT 2
93204: ST_TO_ADDR
// hc_gallery :=  ;
93205: LD_ADDR_OWVAR 33
93209: PUSH
93210: LD_STRING 
93212: ST_TO_ADDR
// hc_name :=  ;
93213: LD_ADDR_OWVAR 26
93217: PUSH
93218: LD_STRING 
93220: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
93221: LD_INT 1
93223: PPUSH
93224: LD_INT 11
93226: PPUSH
93227: LD_INT 10
93229: PPUSH
93230: CALL_OW 380
// un := CreateHuman ;
93234: LD_ADDR_VAR 0 1
93238: PUSH
93239: CALL_OW 44
93243: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93244: LD_VAR 0 1
93248: PPUSH
93249: LD_INT 1
93251: PPUSH
93252: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
93256: LD_INT 35
93258: PPUSH
93259: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
93263: LD_VAR 0 1
93267: PPUSH
93268: LD_INT 22
93270: PUSH
93271: LD_OWVAR 2
93275: PUSH
93276: EMPTY
93277: LIST
93278: LIST
93279: PPUSH
93280: CALL_OW 69
93284: PPUSH
93285: LD_VAR 0 1
93289: PPUSH
93290: CALL_OW 74
93294: PPUSH
93295: CALL_OW 115
// until IsDead ( un ) ;
93299: LD_VAR 0 1
93303: PPUSH
93304: CALL_OW 301
93308: IFFALSE 93256
// end ;
93310: PPOPN 1
93312: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
93313: LD_EXP 122
93317: PUSH
93318: LD_EXP 162
93322: AND
93323: IFFALSE 93335
93325: GO 93327
93327: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
93328: LD_STRING earthquake(getX(game), 0, 32)
93330: PPUSH
93331: CALL_OW 559
93335: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
93336: LD_EXP 122
93340: PUSH
93341: LD_EXP 163
93345: AND
93346: IFFALSE 93437
93348: GO 93350
93350: DISABLE
93351: LD_INT 0
93353: PPUSH
// begin enable ;
93354: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
93355: LD_ADDR_VAR 0 1
93359: PUSH
93360: LD_INT 22
93362: PUSH
93363: LD_OWVAR 2
93367: PUSH
93368: EMPTY
93369: LIST
93370: LIST
93371: PUSH
93372: LD_INT 21
93374: PUSH
93375: LD_INT 2
93377: PUSH
93378: EMPTY
93379: LIST
93380: LIST
93381: PUSH
93382: LD_INT 33
93384: PUSH
93385: LD_INT 3
93387: PUSH
93388: EMPTY
93389: LIST
93390: LIST
93391: PUSH
93392: EMPTY
93393: LIST
93394: LIST
93395: LIST
93396: PPUSH
93397: CALL_OW 69
93401: ST_TO_ADDR
// if not tmp then
93402: LD_VAR 0 1
93406: NOT
93407: IFFALSE 93411
// exit ;
93409: GO 93437
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
93411: LD_VAR 0 1
93415: PUSH
93416: LD_INT 1
93418: PPUSH
93419: LD_VAR 0 1
93423: PPUSH
93424: CALL_OW 12
93428: ARRAY
93429: PPUSH
93430: LD_INT 1
93432: PPUSH
93433: CALL_OW 234
// end ;
93437: PPOPN 1
93439: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
93440: LD_EXP 122
93444: PUSH
93445: LD_EXP 164
93449: AND
93450: IFFALSE 93591
93452: GO 93454
93454: DISABLE
93455: LD_INT 0
93457: PPUSH
93458: PPUSH
93459: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93460: LD_ADDR_VAR 0 3
93464: PUSH
93465: LD_INT 22
93467: PUSH
93468: LD_OWVAR 2
93472: PUSH
93473: EMPTY
93474: LIST
93475: LIST
93476: PUSH
93477: LD_INT 25
93479: PUSH
93480: LD_INT 1
93482: PUSH
93483: EMPTY
93484: LIST
93485: LIST
93486: PUSH
93487: EMPTY
93488: LIST
93489: LIST
93490: PPUSH
93491: CALL_OW 69
93495: ST_TO_ADDR
// if not tmp then
93496: LD_VAR 0 3
93500: NOT
93501: IFFALSE 93505
// exit ;
93503: GO 93591
// un := tmp [ rand ( 1 , tmp ) ] ;
93505: LD_ADDR_VAR 0 2
93509: PUSH
93510: LD_VAR 0 3
93514: PUSH
93515: LD_INT 1
93517: PPUSH
93518: LD_VAR 0 3
93522: PPUSH
93523: CALL_OW 12
93527: ARRAY
93528: ST_TO_ADDR
// if Crawls ( un ) then
93529: LD_VAR 0 2
93533: PPUSH
93534: CALL_OW 318
93538: IFFALSE 93549
// ComWalk ( un ) ;
93540: LD_VAR 0 2
93544: PPUSH
93545: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
93549: LD_VAR 0 2
93553: PPUSH
93554: LD_INT 9
93556: PPUSH
93557: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
93561: LD_INT 28
93563: PPUSH
93564: LD_OWVAR 2
93568: PPUSH
93569: LD_INT 2
93571: PPUSH
93572: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
93576: LD_INT 29
93578: PPUSH
93579: LD_OWVAR 2
93583: PPUSH
93584: LD_INT 2
93586: PPUSH
93587: CALL_OW 322
// end ;
93591: PPOPN 3
93593: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
93594: LD_EXP 122
93598: PUSH
93599: LD_EXP 165
93603: AND
93604: IFFALSE 93715
93606: GO 93608
93608: DISABLE
93609: LD_INT 0
93611: PPUSH
93612: PPUSH
93613: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93614: LD_ADDR_VAR 0 3
93618: PUSH
93619: LD_INT 22
93621: PUSH
93622: LD_OWVAR 2
93626: PUSH
93627: EMPTY
93628: LIST
93629: LIST
93630: PUSH
93631: LD_INT 25
93633: PUSH
93634: LD_INT 1
93636: PUSH
93637: EMPTY
93638: LIST
93639: LIST
93640: PUSH
93641: EMPTY
93642: LIST
93643: LIST
93644: PPUSH
93645: CALL_OW 69
93649: ST_TO_ADDR
// if not tmp then
93650: LD_VAR 0 3
93654: NOT
93655: IFFALSE 93659
// exit ;
93657: GO 93715
// un := tmp [ rand ( 1 , tmp ) ] ;
93659: LD_ADDR_VAR 0 2
93663: PUSH
93664: LD_VAR 0 3
93668: PUSH
93669: LD_INT 1
93671: PPUSH
93672: LD_VAR 0 3
93676: PPUSH
93677: CALL_OW 12
93681: ARRAY
93682: ST_TO_ADDR
// if Crawls ( un ) then
93683: LD_VAR 0 2
93687: PPUSH
93688: CALL_OW 318
93692: IFFALSE 93703
// ComWalk ( un ) ;
93694: LD_VAR 0 2
93698: PPUSH
93699: CALL_OW 138
// SetClass ( un , class_mortar ) ;
93703: LD_VAR 0 2
93707: PPUSH
93708: LD_INT 8
93710: PPUSH
93711: CALL_OW 336
// end ;
93715: PPOPN 3
93717: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
93718: LD_EXP 122
93722: PUSH
93723: LD_EXP 166
93727: AND
93728: IFFALSE 93872
93730: GO 93732
93732: DISABLE
93733: LD_INT 0
93735: PPUSH
93736: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
93737: LD_ADDR_VAR 0 2
93741: PUSH
93742: LD_INT 22
93744: PUSH
93745: LD_OWVAR 2
93749: PUSH
93750: EMPTY
93751: LIST
93752: LIST
93753: PUSH
93754: LD_INT 21
93756: PUSH
93757: LD_INT 2
93759: PUSH
93760: EMPTY
93761: LIST
93762: LIST
93763: PUSH
93764: LD_INT 2
93766: PUSH
93767: LD_INT 34
93769: PUSH
93770: LD_INT 12
93772: PUSH
93773: EMPTY
93774: LIST
93775: LIST
93776: PUSH
93777: LD_INT 34
93779: PUSH
93780: LD_INT 51
93782: PUSH
93783: EMPTY
93784: LIST
93785: LIST
93786: PUSH
93787: LD_INT 34
93789: PUSH
93790: LD_INT 32
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: PUSH
93797: EMPTY
93798: LIST
93799: LIST
93800: LIST
93801: LIST
93802: PUSH
93803: EMPTY
93804: LIST
93805: LIST
93806: LIST
93807: PPUSH
93808: CALL_OW 69
93812: ST_TO_ADDR
// if not tmp then
93813: LD_VAR 0 2
93817: NOT
93818: IFFALSE 93822
// exit ;
93820: GO 93872
// for i in tmp do
93822: LD_ADDR_VAR 0 1
93826: PUSH
93827: LD_VAR 0 2
93831: PUSH
93832: FOR_IN
93833: IFFALSE 93870
// if GetCargo ( i , mat_artifact ) = 0 then
93835: LD_VAR 0 1
93839: PPUSH
93840: LD_INT 4
93842: PPUSH
93843: CALL_OW 289
93847: PUSH
93848: LD_INT 0
93850: EQUAL
93851: IFFALSE 93868
// SetCargo ( i , mat_siberit , 100 ) ;
93853: LD_VAR 0 1
93857: PPUSH
93858: LD_INT 3
93860: PPUSH
93861: LD_INT 100
93863: PPUSH
93864: CALL_OW 290
93868: GO 93832
93870: POP
93871: POP
// end ;
93872: PPOPN 2
93874: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
93875: LD_EXP 122
93879: PUSH
93880: LD_EXP 167
93884: AND
93885: IFFALSE 94068
93887: GO 93889
93889: DISABLE
93890: LD_INT 0
93892: PPUSH
93893: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
93894: LD_ADDR_VAR 0 2
93898: PUSH
93899: LD_INT 22
93901: PUSH
93902: LD_OWVAR 2
93906: PUSH
93907: EMPTY
93908: LIST
93909: LIST
93910: PPUSH
93911: CALL_OW 69
93915: ST_TO_ADDR
// if not tmp then
93916: LD_VAR 0 2
93920: NOT
93921: IFFALSE 93925
// exit ;
93923: GO 94068
// for i := 1 to 2 do
93925: LD_ADDR_VAR 0 1
93929: PUSH
93930: DOUBLE
93931: LD_INT 1
93933: DEC
93934: ST_TO_ADDR
93935: LD_INT 2
93937: PUSH
93938: FOR_TO
93939: IFFALSE 94066
// begin uc_side := your_side ;
93941: LD_ADDR_OWVAR 20
93945: PUSH
93946: LD_OWVAR 2
93950: ST_TO_ADDR
// uc_nation := nation_american ;
93951: LD_ADDR_OWVAR 21
93955: PUSH
93956: LD_INT 1
93958: ST_TO_ADDR
// vc_chassis := us_morphling ;
93959: LD_ADDR_OWVAR 37
93963: PUSH
93964: LD_INT 5
93966: ST_TO_ADDR
// vc_engine := engine_siberite ;
93967: LD_ADDR_OWVAR 39
93971: PUSH
93972: LD_INT 3
93974: ST_TO_ADDR
// vc_control := control_computer ;
93975: LD_ADDR_OWVAR 38
93979: PUSH
93980: LD_INT 3
93982: ST_TO_ADDR
// vc_weapon := us_double_laser ;
93983: LD_ADDR_OWVAR 40
93987: PUSH
93988: LD_INT 10
93990: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
93991: LD_VAR 0 2
93995: PUSH
93996: LD_INT 1
93998: ARRAY
93999: PPUSH
94000: CALL_OW 310
94004: NOT
94005: IFFALSE 94052
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
94007: CALL_OW 45
94011: PPUSH
94012: LD_VAR 0 2
94016: PUSH
94017: LD_INT 1
94019: ARRAY
94020: PPUSH
94021: CALL_OW 250
94025: PPUSH
94026: LD_VAR 0 2
94030: PUSH
94031: LD_INT 1
94033: ARRAY
94034: PPUSH
94035: CALL_OW 251
94039: PPUSH
94040: LD_INT 12
94042: PPUSH
94043: LD_INT 1
94045: PPUSH
94046: CALL_OW 50
94050: GO 94064
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
94052: CALL_OW 45
94056: PPUSH
94057: LD_INT 1
94059: PPUSH
94060: CALL_OW 51
// end ;
94064: GO 93938
94066: POP
94067: POP
// end ;
94068: PPOPN 2
94070: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
94071: LD_EXP 122
94075: PUSH
94076: LD_EXP 168
94080: AND
94081: IFFALSE 94303
94083: GO 94085
94085: DISABLE
94086: LD_INT 0
94088: PPUSH
94089: PPUSH
94090: PPUSH
94091: PPUSH
94092: PPUSH
94093: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94094: LD_ADDR_VAR 0 6
94098: PUSH
94099: LD_INT 22
94101: PUSH
94102: LD_OWVAR 2
94106: PUSH
94107: EMPTY
94108: LIST
94109: LIST
94110: PUSH
94111: LD_INT 21
94113: PUSH
94114: LD_INT 1
94116: PUSH
94117: EMPTY
94118: LIST
94119: LIST
94120: PUSH
94121: LD_INT 3
94123: PUSH
94124: LD_INT 23
94126: PUSH
94127: LD_INT 0
94129: PUSH
94130: EMPTY
94131: LIST
94132: LIST
94133: PUSH
94134: EMPTY
94135: LIST
94136: LIST
94137: PUSH
94138: EMPTY
94139: LIST
94140: LIST
94141: LIST
94142: PPUSH
94143: CALL_OW 69
94147: ST_TO_ADDR
// if not tmp then
94148: LD_VAR 0 6
94152: NOT
94153: IFFALSE 94157
// exit ;
94155: GO 94303
// s1 := rand ( 1 , 4 ) ;
94157: LD_ADDR_VAR 0 2
94161: PUSH
94162: LD_INT 1
94164: PPUSH
94165: LD_INT 4
94167: PPUSH
94168: CALL_OW 12
94172: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
94173: LD_ADDR_VAR 0 4
94177: PUSH
94178: LD_VAR 0 6
94182: PUSH
94183: LD_INT 1
94185: ARRAY
94186: PPUSH
94187: LD_VAR 0 2
94191: PPUSH
94192: CALL_OW 259
94196: ST_TO_ADDR
// if s1 = 1 then
94197: LD_VAR 0 2
94201: PUSH
94202: LD_INT 1
94204: EQUAL
94205: IFFALSE 94225
// s2 := rand ( 2 , 4 ) else
94207: LD_ADDR_VAR 0 3
94211: PUSH
94212: LD_INT 2
94214: PPUSH
94215: LD_INT 4
94217: PPUSH
94218: CALL_OW 12
94222: ST_TO_ADDR
94223: GO 94233
// s2 := 1 ;
94225: LD_ADDR_VAR 0 3
94229: PUSH
94230: LD_INT 1
94232: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
94233: LD_ADDR_VAR 0 5
94237: PUSH
94238: LD_VAR 0 6
94242: PUSH
94243: LD_INT 1
94245: ARRAY
94246: PPUSH
94247: LD_VAR 0 3
94251: PPUSH
94252: CALL_OW 259
94256: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
94257: LD_VAR 0 6
94261: PUSH
94262: LD_INT 1
94264: ARRAY
94265: PPUSH
94266: LD_VAR 0 2
94270: PPUSH
94271: LD_VAR 0 5
94275: PPUSH
94276: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
94280: LD_VAR 0 6
94284: PUSH
94285: LD_INT 1
94287: ARRAY
94288: PPUSH
94289: LD_VAR 0 3
94293: PPUSH
94294: LD_VAR 0 4
94298: PPUSH
94299: CALL_OW 237
// end ;
94303: PPOPN 6
94305: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
94306: LD_EXP 122
94310: PUSH
94311: LD_EXP 169
94315: AND
94316: IFFALSE 94395
94318: GO 94320
94320: DISABLE
94321: LD_INT 0
94323: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
94324: LD_ADDR_VAR 0 1
94328: PUSH
94329: LD_INT 22
94331: PUSH
94332: LD_OWVAR 2
94336: PUSH
94337: EMPTY
94338: LIST
94339: LIST
94340: PUSH
94341: LD_INT 30
94343: PUSH
94344: LD_INT 3
94346: PUSH
94347: EMPTY
94348: LIST
94349: LIST
94350: PUSH
94351: EMPTY
94352: LIST
94353: LIST
94354: PPUSH
94355: CALL_OW 69
94359: ST_TO_ADDR
// if not tmp then
94360: LD_VAR 0 1
94364: NOT
94365: IFFALSE 94369
// exit ;
94367: GO 94395
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
94369: LD_VAR 0 1
94373: PUSH
94374: LD_INT 1
94376: PPUSH
94377: LD_VAR 0 1
94381: PPUSH
94382: CALL_OW 12
94386: ARRAY
94387: PPUSH
94388: LD_INT 1
94390: PPUSH
94391: CALL_OW 234
// end ;
94395: PPOPN 1
94397: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
94398: LD_EXP 122
94402: PUSH
94403: LD_EXP 170
94407: AND
94408: IFFALSE 94520
94410: GO 94412
94412: DISABLE
94413: LD_INT 0
94415: PPUSH
94416: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
94417: LD_ADDR_VAR 0 2
94421: PUSH
94422: LD_INT 22
94424: PUSH
94425: LD_OWVAR 2
94429: PUSH
94430: EMPTY
94431: LIST
94432: LIST
94433: PUSH
94434: LD_INT 2
94436: PUSH
94437: LD_INT 30
94439: PUSH
94440: LD_INT 27
94442: PUSH
94443: EMPTY
94444: LIST
94445: LIST
94446: PUSH
94447: LD_INT 30
94449: PUSH
94450: LD_INT 26
94452: PUSH
94453: EMPTY
94454: LIST
94455: LIST
94456: PUSH
94457: LD_INT 30
94459: PUSH
94460: LD_INT 28
94462: PUSH
94463: EMPTY
94464: LIST
94465: LIST
94466: PUSH
94467: EMPTY
94468: LIST
94469: LIST
94470: LIST
94471: LIST
94472: PUSH
94473: EMPTY
94474: LIST
94475: LIST
94476: PPUSH
94477: CALL_OW 69
94481: ST_TO_ADDR
// if not tmp then
94482: LD_VAR 0 2
94486: NOT
94487: IFFALSE 94491
// exit ;
94489: GO 94520
// for i in tmp do
94491: LD_ADDR_VAR 0 1
94495: PUSH
94496: LD_VAR 0 2
94500: PUSH
94501: FOR_IN
94502: IFFALSE 94518
// SetLives ( i , 1 ) ;
94504: LD_VAR 0 1
94508: PPUSH
94509: LD_INT 1
94511: PPUSH
94512: CALL_OW 234
94516: GO 94501
94518: POP
94519: POP
// end ;
94520: PPOPN 2
94522: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
94523: LD_EXP 122
94527: PUSH
94528: LD_EXP 171
94532: AND
94533: IFFALSE 94807
94535: GO 94537
94537: DISABLE
94538: LD_INT 0
94540: PPUSH
94541: PPUSH
94542: PPUSH
// begin i := rand ( 1 , 7 ) ;
94543: LD_ADDR_VAR 0 1
94547: PUSH
94548: LD_INT 1
94550: PPUSH
94551: LD_INT 7
94553: PPUSH
94554: CALL_OW 12
94558: ST_TO_ADDR
// case i of 1 :
94559: LD_VAR 0 1
94563: PUSH
94564: LD_INT 1
94566: DOUBLE
94567: EQUAL
94568: IFTRUE 94572
94570: GO 94582
94572: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
94573: LD_STRING earthquake(getX(game), 0, 32)
94575: PPUSH
94576: CALL_OW 559
94580: GO 94807
94582: LD_INT 2
94584: DOUBLE
94585: EQUAL
94586: IFTRUE 94590
94588: GO 94604
94590: POP
// begin ToLua ( displayStucuk(); ) ;
94591: LD_STRING displayStucuk();
94593: PPUSH
94594: CALL_OW 559
// ResetFog ;
94598: CALL_OW 335
// end ; 3 :
94602: GO 94807
94604: LD_INT 3
94606: DOUBLE
94607: EQUAL
94608: IFTRUE 94612
94610: GO 94716
94612: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94613: LD_ADDR_VAR 0 2
94617: PUSH
94618: LD_INT 22
94620: PUSH
94621: LD_OWVAR 2
94625: PUSH
94626: EMPTY
94627: LIST
94628: LIST
94629: PUSH
94630: LD_INT 25
94632: PUSH
94633: LD_INT 1
94635: PUSH
94636: EMPTY
94637: LIST
94638: LIST
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: PPUSH
94644: CALL_OW 69
94648: ST_TO_ADDR
// if not tmp then
94649: LD_VAR 0 2
94653: NOT
94654: IFFALSE 94658
// exit ;
94656: GO 94807
// un := tmp [ rand ( 1 , tmp ) ] ;
94658: LD_ADDR_VAR 0 3
94662: PUSH
94663: LD_VAR 0 2
94667: PUSH
94668: LD_INT 1
94670: PPUSH
94671: LD_VAR 0 2
94675: PPUSH
94676: CALL_OW 12
94680: ARRAY
94681: ST_TO_ADDR
// if Crawls ( un ) then
94682: LD_VAR 0 3
94686: PPUSH
94687: CALL_OW 318
94691: IFFALSE 94702
// ComWalk ( un ) ;
94693: LD_VAR 0 3
94697: PPUSH
94698: CALL_OW 138
// SetClass ( un , class_mortar ) ;
94702: LD_VAR 0 3
94706: PPUSH
94707: LD_INT 8
94709: PPUSH
94710: CALL_OW 336
// end ; 4 :
94714: GO 94807
94716: LD_INT 4
94718: DOUBLE
94719: EQUAL
94720: IFTRUE 94724
94722: GO 94785
94724: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
94725: LD_ADDR_VAR 0 2
94729: PUSH
94730: LD_INT 22
94732: PUSH
94733: LD_OWVAR 2
94737: PUSH
94738: EMPTY
94739: LIST
94740: LIST
94741: PUSH
94742: LD_INT 30
94744: PUSH
94745: LD_INT 29
94747: PUSH
94748: EMPTY
94749: LIST
94750: LIST
94751: PUSH
94752: EMPTY
94753: LIST
94754: LIST
94755: PPUSH
94756: CALL_OW 69
94760: ST_TO_ADDR
// if not tmp then
94761: LD_VAR 0 2
94765: NOT
94766: IFFALSE 94770
// exit ;
94768: GO 94807
// DestroyUnit ( tmp [ 1 ] ) ;
94770: LD_VAR 0 2
94774: PUSH
94775: LD_INT 1
94777: ARRAY
94778: PPUSH
94779: CALL_OW 65
// end ; 5 .. 7 :
94783: GO 94807
94785: LD_INT 5
94787: DOUBLE
94788: GREATEREQUAL
94789: IFFALSE 94797
94791: LD_INT 7
94793: DOUBLE
94794: LESSEQUAL
94795: IFTRUE 94799
94797: GO 94806
94799: POP
// StreamSibBomb ; end ;
94800: CALL 91057 0 0
94804: GO 94807
94806: POP
// end ;
94807: PPOPN 3
94809: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
94810: LD_EXP 122
94814: PUSH
94815: LD_EXP 172
94819: AND
94820: IFFALSE 94976
94822: GO 94824
94824: DISABLE
94825: LD_INT 0
94827: PPUSH
94828: PPUSH
94829: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
94830: LD_ADDR_VAR 0 2
94834: PUSH
94835: LD_INT 81
94837: PUSH
94838: LD_OWVAR 2
94842: PUSH
94843: EMPTY
94844: LIST
94845: LIST
94846: PUSH
94847: LD_INT 2
94849: PUSH
94850: LD_INT 21
94852: PUSH
94853: LD_INT 1
94855: PUSH
94856: EMPTY
94857: LIST
94858: LIST
94859: PUSH
94860: LD_INT 21
94862: PUSH
94863: LD_INT 2
94865: PUSH
94866: EMPTY
94867: LIST
94868: LIST
94869: PUSH
94870: EMPTY
94871: LIST
94872: LIST
94873: LIST
94874: PUSH
94875: EMPTY
94876: LIST
94877: LIST
94878: PPUSH
94879: CALL_OW 69
94883: ST_TO_ADDR
// if not tmp then
94884: LD_VAR 0 2
94888: NOT
94889: IFFALSE 94893
// exit ;
94891: GO 94976
// p := 0 ;
94893: LD_ADDR_VAR 0 3
94897: PUSH
94898: LD_INT 0
94900: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
94901: LD_INT 35
94903: PPUSH
94904: CALL_OW 67
// p := p + 1 ;
94908: LD_ADDR_VAR 0 3
94912: PUSH
94913: LD_VAR 0 3
94917: PUSH
94918: LD_INT 1
94920: PLUS
94921: ST_TO_ADDR
// for i in tmp do
94922: LD_ADDR_VAR 0 1
94926: PUSH
94927: LD_VAR 0 2
94931: PUSH
94932: FOR_IN
94933: IFFALSE 94964
// if GetLives ( i ) < 1000 then
94935: LD_VAR 0 1
94939: PPUSH
94940: CALL_OW 256
94944: PUSH
94945: LD_INT 1000
94947: LESS
94948: IFFALSE 94962
// SetLives ( i , 1000 ) ;
94950: LD_VAR 0 1
94954: PPUSH
94955: LD_INT 1000
94957: PPUSH
94958: CALL_OW 234
94962: GO 94932
94964: POP
94965: POP
// until p > 20 ;
94966: LD_VAR 0 3
94970: PUSH
94971: LD_INT 20
94973: GREATER
94974: IFFALSE 94901
// end ;
94976: PPOPN 3
94978: END
// every 0 0$1 trigger StreamModeActive and sTime do
94979: LD_EXP 122
94983: PUSH
94984: LD_EXP 173
94988: AND
94989: IFFALSE 95024
94991: GO 94993
94993: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
94994: LD_INT 28
94996: PPUSH
94997: LD_OWVAR 2
95001: PPUSH
95002: LD_INT 2
95004: PPUSH
95005: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
95009: LD_INT 30
95011: PPUSH
95012: LD_OWVAR 2
95016: PPUSH
95017: LD_INT 2
95019: PPUSH
95020: CALL_OW 322
// end ;
95024: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
95025: LD_EXP 122
95029: PUSH
95030: LD_EXP 174
95034: AND
95035: IFFALSE 95156
95037: GO 95039
95039: DISABLE
95040: LD_INT 0
95042: PPUSH
95043: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95044: LD_ADDR_VAR 0 2
95048: PUSH
95049: LD_INT 22
95051: PUSH
95052: LD_OWVAR 2
95056: PUSH
95057: EMPTY
95058: LIST
95059: LIST
95060: PUSH
95061: LD_INT 21
95063: PUSH
95064: LD_INT 1
95066: PUSH
95067: EMPTY
95068: LIST
95069: LIST
95070: PUSH
95071: LD_INT 3
95073: PUSH
95074: LD_INT 23
95076: PUSH
95077: LD_INT 0
95079: PUSH
95080: EMPTY
95081: LIST
95082: LIST
95083: PUSH
95084: EMPTY
95085: LIST
95086: LIST
95087: PUSH
95088: EMPTY
95089: LIST
95090: LIST
95091: LIST
95092: PPUSH
95093: CALL_OW 69
95097: ST_TO_ADDR
// if not tmp then
95098: LD_VAR 0 2
95102: NOT
95103: IFFALSE 95107
// exit ;
95105: GO 95156
// for i in tmp do
95107: LD_ADDR_VAR 0 1
95111: PUSH
95112: LD_VAR 0 2
95116: PUSH
95117: FOR_IN
95118: IFFALSE 95154
// begin if Crawls ( i ) then
95120: LD_VAR 0 1
95124: PPUSH
95125: CALL_OW 318
95129: IFFALSE 95140
// ComWalk ( i ) ;
95131: LD_VAR 0 1
95135: PPUSH
95136: CALL_OW 138
// SetClass ( i , 2 ) ;
95140: LD_VAR 0 1
95144: PPUSH
95145: LD_INT 2
95147: PPUSH
95148: CALL_OW 336
// end ;
95152: GO 95117
95154: POP
95155: POP
// end ;
95156: PPOPN 2
95158: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
95159: LD_EXP 122
95163: PUSH
95164: LD_EXP 175
95168: AND
95169: IFFALSE 95450
95171: GO 95173
95173: DISABLE
95174: LD_INT 0
95176: PPUSH
95177: PPUSH
95178: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
95179: LD_OWVAR 2
95183: PPUSH
95184: LD_INT 9
95186: PPUSH
95187: LD_INT 1
95189: PPUSH
95190: LD_INT 1
95192: PPUSH
95193: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
95197: LD_INT 9
95199: PPUSH
95200: LD_OWVAR 2
95204: PPUSH
95205: CALL_OW 343
// uc_side := 9 ;
95209: LD_ADDR_OWVAR 20
95213: PUSH
95214: LD_INT 9
95216: ST_TO_ADDR
// uc_nation := 2 ;
95217: LD_ADDR_OWVAR 21
95221: PUSH
95222: LD_INT 2
95224: ST_TO_ADDR
// hc_name := Dark Warrior ;
95225: LD_ADDR_OWVAR 26
95229: PUSH
95230: LD_STRING Dark Warrior
95232: ST_TO_ADDR
// hc_gallery :=  ;
95233: LD_ADDR_OWVAR 33
95237: PUSH
95238: LD_STRING 
95240: ST_TO_ADDR
// hc_noskilllimit := true ;
95241: LD_ADDR_OWVAR 76
95245: PUSH
95246: LD_INT 1
95248: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
95249: LD_ADDR_OWVAR 31
95253: PUSH
95254: LD_INT 30
95256: PUSH
95257: LD_INT 30
95259: PUSH
95260: LD_INT 30
95262: PUSH
95263: LD_INT 30
95265: PUSH
95266: EMPTY
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: ST_TO_ADDR
// un := CreateHuman ;
95272: LD_ADDR_VAR 0 3
95276: PUSH
95277: CALL_OW 44
95281: ST_TO_ADDR
// hc_noskilllimit := false ;
95282: LD_ADDR_OWVAR 76
95286: PUSH
95287: LD_INT 0
95289: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95290: LD_VAR 0 3
95294: PPUSH
95295: LD_INT 1
95297: PPUSH
95298: CALL_OW 51
// p := 0 ;
95302: LD_ADDR_VAR 0 2
95306: PUSH
95307: LD_INT 0
95309: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
95310: LD_INT 35
95312: PPUSH
95313: CALL_OW 67
// p := p + 1 ;
95317: LD_ADDR_VAR 0 2
95321: PUSH
95322: LD_VAR 0 2
95326: PUSH
95327: LD_INT 1
95329: PLUS
95330: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
95331: LD_VAR 0 3
95335: PPUSH
95336: CALL_OW 256
95340: PUSH
95341: LD_INT 1000
95343: LESS
95344: IFFALSE 95358
// SetLives ( un , 1000 ) ;
95346: LD_VAR 0 3
95350: PPUSH
95351: LD_INT 1000
95353: PPUSH
95354: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
95358: LD_VAR 0 3
95362: PPUSH
95363: LD_INT 81
95365: PUSH
95366: LD_OWVAR 2
95370: PUSH
95371: EMPTY
95372: LIST
95373: LIST
95374: PUSH
95375: LD_INT 91
95377: PUSH
95378: LD_VAR 0 3
95382: PUSH
95383: LD_INT 30
95385: PUSH
95386: EMPTY
95387: LIST
95388: LIST
95389: LIST
95390: PUSH
95391: EMPTY
95392: LIST
95393: LIST
95394: PPUSH
95395: CALL_OW 69
95399: PPUSH
95400: LD_VAR 0 3
95404: PPUSH
95405: CALL_OW 74
95409: PPUSH
95410: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
95414: LD_VAR 0 2
95418: PUSH
95419: LD_INT 60
95421: GREATER
95422: PUSH
95423: LD_VAR 0 3
95427: PPUSH
95428: CALL_OW 301
95432: OR
95433: IFFALSE 95310
// if un then
95435: LD_VAR 0 3
95439: IFFALSE 95450
// RemoveUnit ( un ) ;
95441: LD_VAR 0 3
95445: PPUSH
95446: CALL_OW 64
// end ;
95450: PPOPN 3
95452: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
95453: LD_INT 0
95455: PPUSH
// case cmd of 301 :
95456: LD_VAR 0 1
95460: PUSH
95461: LD_INT 301
95463: DOUBLE
95464: EQUAL
95465: IFTRUE 95469
95467: GO 95501
95469: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
95470: LD_VAR 0 6
95474: PPUSH
95475: LD_VAR 0 7
95479: PPUSH
95480: LD_VAR 0 8
95484: PPUSH
95485: LD_VAR 0 4
95489: PPUSH
95490: LD_VAR 0 5
95494: PPUSH
95495: CALL 96702 0 5
95499: GO 95622
95501: LD_INT 302
95503: DOUBLE
95504: EQUAL
95505: IFTRUE 95509
95507: GO 95546
95509: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
95510: LD_VAR 0 6
95514: PPUSH
95515: LD_VAR 0 7
95519: PPUSH
95520: LD_VAR 0 8
95524: PPUSH
95525: LD_VAR 0 9
95529: PPUSH
95530: LD_VAR 0 4
95534: PPUSH
95535: LD_VAR 0 5
95539: PPUSH
95540: CALL 96793 0 6
95544: GO 95622
95546: LD_INT 303
95548: DOUBLE
95549: EQUAL
95550: IFTRUE 95554
95552: GO 95591
95554: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
95555: LD_VAR 0 6
95559: PPUSH
95560: LD_VAR 0 7
95564: PPUSH
95565: LD_VAR 0 8
95569: PPUSH
95570: LD_VAR 0 9
95574: PPUSH
95575: LD_VAR 0 4
95579: PPUSH
95580: LD_VAR 0 5
95584: PPUSH
95585: CALL 95627 0 6
95589: GO 95622
95591: LD_INT 304
95593: DOUBLE
95594: EQUAL
95595: IFTRUE 95599
95597: GO 95621
95599: POP
// hHackTeleport ( unit , x , y ) ; end ;
95600: LD_VAR 0 2
95604: PPUSH
95605: LD_VAR 0 4
95609: PPUSH
95610: LD_VAR 0 5
95614: PPUSH
95615: CALL 97386 0 3
95619: GO 95622
95621: POP
// end ;
95622: LD_VAR 0 12
95626: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
95627: LD_INT 0
95629: PPUSH
95630: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
95631: LD_VAR 0 1
95635: PUSH
95636: LD_INT 1
95638: LESS
95639: PUSH
95640: LD_VAR 0 1
95644: PUSH
95645: LD_INT 3
95647: GREATER
95648: OR
95649: PUSH
95650: LD_VAR 0 5
95654: PPUSH
95655: LD_VAR 0 6
95659: PPUSH
95660: CALL_OW 428
95664: OR
95665: IFFALSE 95669
// exit ;
95667: GO 96389
// uc_side := your_side ;
95669: LD_ADDR_OWVAR 20
95673: PUSH
95674: LD_OWVAR 2
95678: ST_TO_ADDR
// uc_nation := nation ;
95679: LD_ADDR_OWVAR 21
95683: PUSH
95684: LD_VAR 0 1
95688: ST_TO_ADDR
// bc_level = 1 ;
95689: LD_ADDR_OWVAR 43
95693: PUSH
95694: LD_INT 1
95696: ST_TO_ADDR
// case btype of 1 :
95697: LD_VAR 0 2
95701: PUSH
95702: LD_INT 1
95704: DOUBLE
95705: EQUAL
95706: IFTRUE 95710
95708: GO 95721
95710: POP
// bc_type := b_depot ; 2 :
95711: LD_ADDR_OWVAR 42
95715: PUSH
95716: LD_INT 0
95718: ST_TO_ADDR
95719: GO 96333
95721: LD_INT 2
95723: DOUBLE
95724: EQUAL
95725: IFTRUE 95729
95727: GO 95740
95729: POP
// bc_type := b_warehouse ; 3 :
95730: LD_ADDR_OWVAR 42
95734: PUSH
95735: LD_INT 1
95737: ST_TO_ADDR
95738: GO 96333
95740: LD_INT 3
95742: DOUBLE
95743: EQUAL
95744: IFTRUE 95748
95746: GO 95759
95748: POP
// bc_type := b_lab ; 4 .. 9 :
95749: LD_ADDR_OWVAR 42
95753: PUSH
95754: LD_INT 6
95756: ST_TO_ADDR
95757: GO 96333
95759: LD_INT 4
95761: DOUBLE
95762: GREATEREQUAL
95763: IFFALSE 95771
95765: LD_INT 9
95767: DOUBLE
95768: LESSEQUAL
95769: IFTRUE 95773
95771: GO 95825
95773: POP
// begin bc_type := b_lab_half ;
95774: LD_ADDR_OWVAR 42
95778: PUSH
95779: LD_INT 7
95781: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
95782: LD_ADDR_OWVAR 44
95786: PUSH
95787: LD_INT 10
95789: PUSH
95790: LD_INT 11
95792: PUSH
95793: LD_INT 12
95795: PUSH
95796: LD_INT 15
95798: PUSH
95799: LD_INT 14
95801: PUSH
95802: LD_INT 13
95804: PUSH
95805: EMPTY
95806: LIST
95807: LIST
95808: LIST
95809: LIST
95810: LIST
95811: LIST
95812: PUSH
95813: LD_VAR 0 2
95817: PUSH
95818: LD_INT 3
95820: MINUS
95821: ARRAY
95822: ST_TO_ADDR
// end ; 10 .. 13 :
95823: GO 96333
95825: LD_INT 10
95827: DOUBLE
95828: GREATEREQUAL
95829: IFFALSE 95837
95831: LD_INT 13
95833: DOUBLE
95834: LESSEQUAL
95835: IFTRUE 95839
95837: GO 95916
95839: POP
// begin bc_type := b_lab_full ;
95840: LD_ADDR_OWVAR 42
95844: PUSH
95845: LD_INT 8
95847: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
95848: LD_ADDR_OWVAR 44
95852: PUSH
95853: LD_INT 10
95855: PUSH
95856: LD_INT 12
95858: PUSH
95859: LD_INT 14
95861: PUSH
95862: LD_INT 13
95864: PUSH
95865: EMPTY
95866: LIST
95867: LIST
95868: LIST
95869: LIST
95870: PUSH
95871: LD_VAR 0 2
95875: PUSH
95876: LD_INT 9
95878: MINUS
95879: ARRAY
95880: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
95881: LD_ADDR_OWVAR 45
95885: PUSH
95886: LD_INT 11
95888: PUSH
95889: LD_INT 15
95891: PUSH
95892: LD_INT 12
95894: PUSH
95895: LD_INT 15
95897: PUSH
95898: EMPTY
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: PUSH
95904: LD_VAR 0 2
95908: PUSH
95909: LD_INT 9
95911: MINUS
95912: ARRAY
95913: ST_TO_ADDR
// end ; 14 :
95914: GO 96333
95916: LD_INT 14
95918: DOUBLE
95919: EQUAL
95920: IFTRUE 95924
95922: GO 95935
95924: POP
// bc_type := b_workshop ; 15 :
95925: LD_ADDR_OWVAR 42
95929: PUSH
95930: LD_INT 2
95932: ST_TO_ADDR
95933: GO 96333
95935: LD_INT 15
95937: DOUBLE
95938: EQUAL
95939: IFTRUE 95943
95941: GO 95954
95943: POP
// bc_type := b_factory ; 16 :
95944: LD_ADDR_OWVAR 42
95948: PUSH
95949: LD_INT 3
95951: ST_TO_ADDR
95952: GO 96333
95954: LD_INT 16
95956: DOUBLE
95957: EQUAL
95958: IFTRUE 95962
95960: GO 95973
95962: POP
// bc_type := b_ext_gun ; 17 :
95963: LD_ADDR_OWVAR 42
95967: PUSH
95968: LD_INT 17
95970: ST_TO_ADDR
95971: GO 96333
95973: LD_INT 17
95975: DOUBLE
95976: EQUAL
95977: IFTRUE 95981
95979: GO 96009
95981: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
95982: LD_ADDR_OWVAR 42
95986: PUSH
95987: LD_INT 19
95989: PUSH
95990: LD_INT 23
95992: PUSH
95993: LD_INT 19
95995: PUSH
95996: EMPTY
95997: LIST
95998: LIST
95999: LIST
96000: PUSH
96001: LD_VAR 0 1
96005: ARRAY
96006: ST_TO_ADDR
96007: GO 96333
96009: LD_INT 18
96011: DOUBLE
96012: EQUAL
96013: IFTRUE 96017
96015: GO 96028
96017: POP
// bc_type := b_ext_radar ; 19 :
96018: LD_ADDR_OWVAR 42
96022: PUSH
96023: LD_INT 20
96025: ST_TO_ADDR
96026: GO 96333
96028: LD_INT 19
96030: DOUBLE
96031: EQUAL
96032: IFTRUE 96036
96034: GO 96047
96036: POP
// bc_type := b_ext_radio ; 20 :
96037: LD_ADDR_OWVAR 42
96041: PUSH
96042: LD_INT 22
96044: ST_TO_ADDR
96045: GO 96333
96047: LD_INT 20
96049: DOUBLE
96050: EQUAL
96051: IFTRUE 96055
96053: GO 96066
96055: POP
// bc_type := b_ext_siberium ; 21 :
96056: LD_ADDR_OWVAR 42
96060: PUSH
96061: LD_INT 21
96063: ST_TO_ADDR
96064: GO 96333
96066: LD_INT 21
96068: DOUBLE
96069: EQUAL
96070: IFTRUE 96074
96072: GO 96085
96074: POP
// bc_type := b_ext_computer ; 22 :
96075: LD_ADDR_OWVAR 42
96079: PUSH
96080: LD_INT 24
96082: ST_TO_ADDR
96083: GO 96333
96085: LD_INT 22
96087: DOUBLE
96088: EQUAL
96089: IFTRUE 96093
96091: GO 96104
96093: POP
// bc_type := b_ext_track ; 23 :
96094: LD_ADDR_OWVAR 42
96098: PUSH
96099: LD_INT 16
96101: ST_TO_ADDR
96102: GO 96333
96104: LD_INT 23
96106: DOUBLE
96107: EQUAL
96108: IFTRUE 96112
96110: GO 96123
96112: POP
// bc_type := b_ext_laser ; 24 :
96113: LD_ADDR_OWVAR 42
96117: PUSH
96118: LD_INT 25
96120: ST_TO_ADDR
96121: GO 96333
96123: LD_INT 24
96125: DOUBLE
96126: EQUAL
96127: IFTRUE 96131
96129: GO 96142
96131: POP
// bc_type := b_control_tower ; 25 :
96132: LD_ADDR_OWVAR 42
96136: PUSH
96137: LD_INT 36
96139: ST_TO_ADDR
96140: GO 96333
96142: LD_INT 25
96144: DOUBLE
96145: EQUAL
96146: IFTRUE 96150
96148: GO 96161
96150: POP
// bc_type := b_breastwork ; 26 :
96151: LD_ADDR_OWVAR 42
96155: PUSH
96156: LD_INT 31
96158: ST_TO_ADDR
96159: GO 96333
96161: LD_INT 26
96163: DOUBLE
96164: EQUAL
96165: IFTRUE 96169
96167: GO 96180
96169: POP
// bc_type := b_bunker ; 27 :
96170: LD_ADDR_OWVAR 42
96174: PUSH
96175: LD_INT 32
96177: ST_TO_ADDR
96178: GO 96333
96180: LD_INT 27
96182: DOUBLE
96183: EQUAL
96184: IFTRUE 96188
96186: GO 96199
96188: POP
// bc_type := b_turret ; 28 :
96189: LD_ADDR_OWVAR 42
96193: PUSH
96194: LD_INT 33
96196: ST_TO_ADDR
96197: GO 96333
96199: LD_INT 28
96201: DOUBLE
96202: EQUAL
96203: IFTRUE 96207
96205: GO 96218
96207: POP
// bc_type := b_armoury ; 29 :
96208: LD_ADDR_OWVAR 42
96212: PUSH
96213: LD_INT 4
96215: ST_TO_ADDR
96216: GO 96333
96218: LD_INT 29
96220: DOUBLE
96221: EQUAL
96222: IFTRUE 96226
96224: GO 96237
96226: POP
// bc_type := b_barracks ; 30 :
96227: LD_ADDR_OWVAR 42
96231: PUSH
96232: LD_INT 5
96234: ST_TO_ADDR
96235: GO 96333
96237: LD_INT 30
96239: DOUBLE
96240: EQUAL
96241: IFTRUE 96245
96243: GO 96256
96245: POP
// bc_type := b_solar_power ; 31 :
96246: LD_ADDR_OWVAR 42
96250: PUSH
96251: LD_INT 27
96253: ST_TO_ADDR
96254: GO 96333
96256: LD_INT 31
96258: DOUBLE
96259: EQUAL
96260: IFTRUE 96264
96262: GO 96275
96264: POP
// bc_type := b_oil_power ; 32 :
96265: LD_ADDR_OWVAR 42
96269: PUSH
96270: LD_INT 26
96272: ST_TO_ADDR
96273: GO 96333
96275: LD_INT 32
96277: DOUBLE
96278: EQUAL
96279: IFTRUE 96283
96281: GO 96294
96283: POP
// bc_type := b_siberite_power ; 33 :
96284: LD_ADDR_OWVAR 42
96288: PUSH
96289: LD_INT 28
96291: ST_TO_ADDR
96292: GO 96333
96294: LD_INT 33
96296: DOUBLE
96297: EQUAL
96298: IFTRUE 96302
96300: GO 96313
96302: POP
// bc_type := b_oil_mine ; 34 :
96303: LD_ADDR_OWVAR 42
96307: PUSH
96308: LD_INT 29
96310: ST_TO_ADDR
96311: GO 96333
96313: LD_INT 34
96315: DOUBLE
96316: EQUAL
96317: IFTRUE 96321
96319: GO 96332
96321: POP
// bc_type := b_siberite_mine ; end ;
96322: LD_ADDR_OWVAR 42
96326: PUSH
96327: LD_INT 30
96329: ST_TO_ADDR
96330: GO 96333
96332: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
96333: LD_ADDR_VAR 0 8
96337: PUSH
96338: LD_VAR 0 5
96342: PPUSH
96343: LD_VAR 0 6
96347: PPUSH
96348: LD_VAR 0 3
96352: PPUSH
96353: CALL_OW 47
96357: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
96358: LD_OWVAR 42
96362: PUSH
96363: LD_INT 32
96365: PUSH
96366: LD_INT 33
96368: PUSH
96369: EMPTY
96370: LIST
96371: LIST
96372: IN
96373: IFFALSE 96389
// PlaceWeaponTurret ( b , weapon ) ;
96375: LD_VAR 0 8
96379: PPUSH
96380: LD_VAR 0 4
96384: PPUSH
96385: CALL_OW 431
// end ;
96389: LD_VAR 0 7
96393: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
96394: LD_INT 0
96396: PPUSH
96397: PPUSH
96398: PPUSH
96399: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96400: LD_ADDR_VAR 0 4
96404: PUSH
96405: LD_INT 22
96407: PUSH
96408: LD_OWVAR 2
96412: PUSH
96413: EMPTY
96414: LIST
96415: LIST
96416: PUSH
96417: LD_INT 2
96419: PUSH
96420: LD_INT 30
96422: PUSH
96423: LD_INT 0
96425: PUSH
96426: EMPTY
96427: LIST
96428: LIST
96429: PUSH
96430: LD_INT 30
96432: PUSH
96433: LD_INT 1
96435: PUSH
96436: EMPTY
96437: LIST
96438: LIST
96439: PUSH
96440: EMPTY
96441: LIST
96442: LIST
96443: LIST
96444: PUSH
96445: EMPTY
96446: LIST
96447: LIST
96448: PPUSH
96449: CALL_OW 69
96453: ST_TO_ADDR
// if not tmp then
96454: LD_VAR 0 4
96458: NOT
96459: IFFALSE 96463
// exit ;
96461: GO 96522
// for i in tmp do
96463: LD_ADDR_VAR 0 2
96467: PUSH
96468: LD_VAR 0 4
96472: PUSH
96473: FOR_IN
96474: IFFALSE 96520
// for j = 1 to 3 do
96476: LD_ADDR_VAR 0 3
96480: PUSH
96481: DOUBLE
96482: LD_INT 1
96484: DEC
96485: ST_TO_ADDR
96486: LD_INT 3
96488: PUSH
96489: FOR_TO
96490: IFFALSE 96516
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
96492: LD_VAR 0 2
96496: PPUSH
96497: CALL_OW 274
96501: PPUSH
96502: LD_VAR 0 3
96506: PPUSH
96507: LD_INT 99999
96509: PPUSH
96510: CALL_OW 277
96514: GO 96489
96516: POP
96517: POP
96518: GO 96473
96520: POP
96521: POP
// end ;
96522: LD_VAR 0 1
96526: RET
// export function hHackSetLevel10 ; var i , j ; begin
96527: LD_INT 0
96529: PPUSH
96530: PPUSH
96531: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
96532: LD_ADDR_VAR 0 2
96536: PUSH
96537: LD_INT 21
96539: PUSH
96540: LD_INT 1
96542: PUSH
96543: EMPTY
96544: LIST
96545: LIST
96546: PPUSH
96547: CALL_OW 69
96551: PUSH
96552: FOR_IN
96553: IFFALSE 96605
// if IsSelected ( i ) then
96555: LD_VAR 0 2
96559: PPUSH
96560: CALL_OW 306
96564: IFFALSE 96603
// begin for j := 1 to 4 do
96566: LD_ADDR_VAR 0 3
96570: PUSH
96571: DOUBLE
96572: LD_INT 1
96574: DEC
96575: ST_TO_ADDR
96576: LD_INT 4
96578: PUSH
96579: FOR_TO
96580: IFFALSE 96601
// SetSkill ( i , j , 10 ) ;
96582: LD_VAR 0 2
96586: PPUSH
96587: LD_VAR 0 3
96591: PPUSH
96592: LD_INT 10
96594: PPUSH
96595: CALL_OW 237
96599: GO 96579
96601: POP
96602: POP
// end ;
96603: GO 96552
96605: POP
96606: POP
// end ;
96607: LD_VAR 0 1
96611: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
96612: LD_INT 0
96614: PPUSH
96615: PPUSH
96616: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
96617: LD_ADDR_VAR 0 2
96621: PUSH
96622: LD_INT 22
96624: PUSH
96625: LD_OWVAR 2
96629: PUSH
96630: EMPTY
96631: LIST
96632: LIST
96633: PUSH
96634: LD_INT 21
96636: PUSH
96637: LD_INT 1
96639: PUSH
96640: EMPTY
96641: LIST
96642: LIST
96643: PUSH
96644: EMPTY
96645: LIST
96646: LIST
96647: PPUSH
96648: CALL_OW 69
96652: PUSH
96653: FOR_IN
96654: IFFALSE 96695
// begin for j := 1 to 4 do
96656: LD_ADDR_VAR 0 3
96660: PUSH
96661: DOUBLE
96662: LD_INT 1
96664: DEC
96665: ST_TO_ADDR
96666: LD_INT 4
96668: PUSH
96669: FOR_TO
96670: IFFALSE 96691
// SetSkill ( i , j , 10 ) ;
96672: LD_VAR 0 2
96676: PPUSH
96677: LD_VAR 0 3
96681: PPUSH
96682: LD_INT 10
96684: PPUSH
96685: CALL_OW 237
96689: GO 96669
96691: POP
96692: POP
// end ;
96693: GO 96653
96695: POP
96696: POP
// end ;
96697: LD_VAR 0 1
96701: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
96702: LD_INT 0
96704: PPUSH
// uc_side := your_side ;
96705: LD_ADDR_OWVAR 20
96709: PUSH
96710: LD_OWVAR 2
96714: ST_TO_ADDR
// uc_nation := nation ;
96715: LD_ADDR_OWVAR 21
96719: PUSH
96720: LD_VAR 0 1
96724: ST_TO_ADDR
// InitHc ;
96725: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
96729: LD_INT 0
96731: PPUSH
96732: LD_VAR 0 2
96736: PPUSH
96737: LD_VAR 0 3
96741: PPUSH
96742: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
96746: LD_VAR 0 4
96750: PPUSH
96751: LD_VAR 0 5
96755: PPUSH
96756: CALL_OW 428
96760: PUSH
96761: LD_INT 0
96763: EQUAL
96764: IFFALSE 96788
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
96766: CALL_OW 44
96770: PPUSH
96771: LD_VAR 0 4
96775: PPUSH
96776: LD_VAR 0 5
96780: PPUSH
96781: LD_INT 1
96783: PPUSH
96784: CALL_OW 48
// end ;
96788: LD_VAR 0 6
96792: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
96793: LD_INT 0
96795: PPUSH
96796: PPUSH
// uc_side := your_side ;
96797: LD_ADDR_OWVAR 20
96801: PUSH
96802: LD_OWVAR 2
96806: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
96807: LD_VAR 0 1
96811: PUSH
96812: LD_INT 1
96814: PUSH
96815: LD_INT 2
96817: PUSH
96818: LD_INT 3
96820: PUSH
96821: LD_INT 4
96823: PUSH
96824: LD_INT 5
96826: PUSH
96827: EMPTY
96828: LIST
96829: LIST
96830: LIST
96831: LIST
96832: LIST
96833: IN
96834: IFFALSE 96846
// uc_nation := nation_american else
96836: LD_ADDR_OWVAR 21
96840: PUSH
96841: LD_INT 1
96843: ST_TO_ADDR
96844: GO 96889
// if chassis in [ 11 , 12 , 13 , 14 ] then
96846: LD_VAR 0 1
96850: PUSH
96851: LD_INT 11
96853: PUSH
96854: LD_INT 12
96856: PUSH
96857: LD_INT 13
96859: PUSH
96860: LD_INT 14
96862: PUSH
96863: EMPTY
96864: LIST
96865: LIST
96866: LIST
96867: LIST
96868: IN
96869: IFFALSE 96881
// uc_nation := nation_arabian else
96871: LD_ADDR_OWVAR 21
96875: PUSH
96876: LD_INT 2
96878: ST_TO_ADDR
96879: GO 96889
// uc_nation := nation_russian ;
96881: LD_ADDR_OWVAR 21
96885: PUSH
96886: LD_INT 3
96888: ST_TO_ADDR
// vc_chassis := chassis ;
96889: LD_ADDR_OWVAR 37
96893: PUSH
96894: LD_VAR 0 1
96898: ST_TO_ADDR
// vc_engine := engine ;
96899: LD_ADDR_OWVAR 39
96903: PUSH
96904: LD_VAR 0 2
96908: ST_TO_ADDR
// vc_control := control ;
96909: LD_ADDR_OWVAR 38
96913: PUSH
96914: LD_VAR 0 3
96918: ST_TO_ADDR
// vc_weapon := weapon ;
96919: LD_ADDR_OWVAR 40
96923: PUSH
96924: LD_VAR 0 4
96928: ST_TO_ADDR
// un := CreateVehicle ;
96929: LD_ADDR_VAR 0 8
96933: PUSH
96934: CALL_OW 45
96938: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
96939: LD_VAR 0 8
96943: PPUSH
96944: LD_INT 0
96946: PPUSH
96947: LD_INT 5
96949: PPUSH
96950: CALL_OW 12
96954: PPUSH
96955: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
96959: LD_VAR 0 8
96963: PPUSH
96964: LD_VAR 0 5
96968: PPUSH
96969: LD_VAR 0 6
96973: PPUSH
96974: LD_INT 1
96976: PPUSH
96977: CALL_OW 48
// end ;
96981: LD_VAR 0 7
96985: RET
// export hInvincible ; every 1 do
96986: GO 96988
96988: DISABLE
// hInvincible := [ ] ;
96989: LD_ADDR_EXP 176
96993: PUSH
96994: EMPTY
96995: ST_TO_ADDR
96996: END
// every 10 do var i ;
96997: GO 96999
96999: DISABLE
97000: LD_INT 0
97002: PPUSH
// begin enable ;
97003: ENABLE
// if not hInvincible then
97004: LD_EXP 176
97008: NOT
97009: IFFALSE 97013
// exit ;
97011: GO 97057
// for i in hInvincible do
97013: LD_ADDR_VAR 0 1
97017: PUSH
97018: LD_EXP 176
97022: PUSH
97023: FOR_IN
97024: IFFALSE 97055
// if GetLives ( i ) < 1000 then
97026: LD_VAR 0 1
97030: PPUSH
97031: CALL_OW 256
97035: PUSH
97036: LD_INT 1000
97038: LESS
97039: IFFALSE 97053
// SetLives ( i , 1000 ) ;
97041: LD_VAR 0 1
97045: PPUSH
97046: LD_INT 1000
97048: PPUSH
97049: CALL_OW 234
97053: GO 97023
97055: POP
97056: POP
// end ;
97057: PPOPN 1
97059: END
// export function hHackInvincible ; var i ; begin
97060: LD_INT 0
97062: PPUSH
97063: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
97064: LD_ADDR_VAR 0 2
97068: PUSH
97069: LD_INT 2
97071: PUSH
97072: LD_INT 21
97074: PUSH
97075: LD_INT 1
97077: PUSH
97078: EMPTY
97079: LIST
97080: LIST
97081: PUSH
97082: LD_INT 21
97084: PUSH
97085: LD_INT 2
97087: PUSH
97088: EMPTY
97089: LIST
97090: LIST
97091: PUSH
97092: EMPTY
97093: LIST
97094: LIST
97095: LIST
97096: PPUSH
97097: CALL_OW 69
97101: PUSH
97102: FOR_IN
97103: IFFALSE 97164
// if IsSelected ( i ) then
97105: LD_VAR 0 2
97109: PPUSH
97110: CALL_OW 306
97114: IFFALSE 97162
// begin if i in hInvincible then
97116: LD_VAR 0 2
97120: PUSH
97121: LD_EXP 176
97125: IN
97126: IFFALSE 97146
// hInvincible := hInvincible diff i else
97128: LD_ADDR_EXP 176
97132: PUSH
97133: LD_EXP 176
97137: PUSH
97138: LD_VAR 0 2
97142: DIFF
97143: ST_TO_ADDR
97144: GO 97162
// hInvincible := hInvincible union i ;
97146: LD_ADDR_EXP 176
97150: PUSH
97151: LD_EXP 176
97155: PUSH
97156: LD_VAR 0 2
97160: UNION
97161: ST_TO_ADDR
// end ;
97162: GO 97102
97164: POP
97165: POP
// end ;
97166: LD_VAR 0 1
97170: RET
// export function hHackInvisible ; var i , j ; begin
97171: LD_INT 0
97173: PPUSH
97174: PPUSH
97175: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
97176: LD_ADDR_VAR 0 2
97180: PUSH
97181: LD_INT 21
97183: PUSH
97184: LD_INT 1
97186: PUSH
97187: EMPTY
97188: LIST
97189: LIST
97190: PPUSH
97191: CALL_OW 69
97195: PUSH
97196: FOR_IN
97197: IFFALSE 97221
// if IsSelected ( i ) then
97199: LD_VAR 0 2
97203: PPUSH
97204: CALL_OW 306
97208: IFFALSE 97219
// ComForceInvisible ( i ) ;
97210: LD_VAR 0 2
97214: PPUSH
97215: CALL_OW 496
97219: GO 97196
97221: POP
97222: POP
// end ;
97223: LD_VAR 0 1
97227: RET
// export function hHackChangeYourSide ; begin
97228: LD_INT 0
97230: PPUSH
// if your_side = 8 then
97231: LD_OWVAR 2
97235: PUSH
97236: LD_INT 8
97238: EQUAL
97239: IFFALSE 97251
// your_side := 0 else
97241: LD_ADDR_OWVAR 2
97245: PUSH
97246: LD_INT 0
97248: ST_TO_ADDR
97249: GO 97265
// your_side := your_side + 1 ;
97251: LD_ADDR_OWVAR 2
97255: PUSH
97256: LD_OWVAR 2
97260: PUSH
97261: LD_INT 1
97263: PLUS
97264: ST_TO_ADDR
// end ;
97265: LD_VAR 0 1
97269: RET
// export function hHackChangeUnitSide ; var i , j ; begin
97270: LD_INT 0
97272: PPUSH
97273: PPUSH
97274: PPUSH
// for i in all_units do
97275: LD_ADDR_VAR 0 2
97279: PUSH
97280: LD_OWVAR 3
97284: PUSH
97285: FOR_IN
97286: IFFALSE 97364
// if IsSelected ( i ) then
97288: LD_VAR 0 2
97292: PPUSH
97293: CALL_OW 306
97297: IFFALSE 97362
// begin j := GetSide ( i ) ;
97299: LD_ADDR_VAR 0 3
97303: PUSH
97304: LD_VAR 0 2
97308: PPUSH
97309: CALL_OW 255
97313: ST_TO_ADDR
// if j = 8 then
97314: LD_VAR 0 3
97318: PUSH
97319: LD_INT 8
97321: EQUAL
97322: IFFALSE 97334
// j := 0 else
97324: LD_ADDR_VAR 0 3
97328: PUSH
97329: LD_INT 0
97331: ST_TO_ADDR
97332: GO 97348
// j := j + 1 ;
97334: LD_ADDR_VAR 0 3
97338: PUSH
97339: LD_VAR 0 3
97343: PUSH
97344: LD_INT 1
97346: PLUS
97347: ST_TO_ADDR
// SetSide ( i , j ) ;
97348: LD_VAR 0 2
97352: PPUSH
97353: LD_VAR 0 3
97357: PPUSH
97358: CALL_OW 235
// end ;
97362: GO 97285
97364: POP
97365: POP
// end ;
97366: LD_VAR 0 1
97370: RET
// export function hHackFog ; begin
97371: LD_INT 0
97373: PPUSH
// FogOff ( true ) ;
97374: LD_INT 1
97376: PPUSH
97377: CALL_OW 344
// end ;
97381: LD_VAR 0 1
97385: RET
// export function hHackTeleport ( unit , x , y ) ; begin
97386: LD_INT 0
97388: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
97389: LD_VAR 0 1
97393: PPUSH
97394: LD_VAR 0 2
97398: PPUSH
97399: LD_VAR 0 3
97403: PPUSH
97404: LD_INT 1
97406: PPUSH
97407: LD_INT 1
97409: PPUSH
97410: CALL_OW 483
// CenterOnXY ( x , y ) ;
97414: LD_VAR 0 2
97418: PPUSH
97419: LD_VAR 0 3
97423: PPUSH
97424: CALL_OW 84
// end ; end_of_file
97428: LD_VAR 0 4
97432: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
97433: LD_INT 0
97435: PPUSH
97436: PPUSH
97437: PPUSH
97438: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
97439: LD_VAR 0 1
97443: PPUSH
97444: CALL_OW 264
97448: PUSH
97449: LD_EXP 107
97453: EQUAL
97454: IFFALSE 97526
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
97456: LD_INT 68
97458: PPUSH
97459: LD_VAR 0 1
97463: PPUSH
97464: CALL_OW 255
97468: PPUSH
97469: CALL_OW 321
97473: PUSH
97474: LD_INT 2
97476: EQUAL
97477: IFFALSE 97489
// eff := 70 else
97479: LD_ADDR_VAR 0 4
97483: PUSH
97484: LD_INT 70
97486: ST_TO_ADDR
97487: GO 97497
// eff := 30 ;
97489: LD_ADDR_VAR 0 4
97493: PUSH
97494: LD_INT 30
97496: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
97497: LD_VAR 0 1
97501: PPUSH
97502: CALL_OW 250
97506: PPUSH
97507: LD_VAR 0 1
97511: PPUSH
97512: CALL_OW 251
97516: PPUSH
97517: LD_VAR 0 4
97521: PPUSH
97522: CALL_OW 495
// end ; end ;
97526: LD_VAR 0 2
97530: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
97531: LD_INT 0
97533: PPUSH
// end ;
97534: LD_VAR 0 4
97538: RET
// export function SOS_Command ( cmd ) ; begin
97539: LD_INT 0
97541: PPUSH
// end ;
97542: LD_VAR 0 2
97546: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
97547: LD_INT 0
97549: PPUSH
// if cmd = 121 then
97550: LD_VAR 0 1
97554: PUSH
97555: LD_INT 121
97557: EQUAL
97558: IFFALSE 97560
// end ;
97560: LD_VAR 0 6
97564: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
97565: LD_INT 0
97567: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
97568: LD_VAR 0 1
97572: PUSH
97573: LD_INT 250
97575: EQUAL
97576: PUSH
97577: LD_VAR 0 2
97581: PPUSH
97582: CALL_OW 264
97586: PUSH
97587: LD_EXP 110
97591: EQUAL
97592: AND
97593: IFFALSE 97614
// MinerPlaceMine ( unit , x , y ) ;
97595: LD_VAR 0 2
97599: PPUSH
97600: LD_VAR 0 4
97604: PPUSH
97605: LD_VAR 0 5
97609: PPUSH
97610: CALL 99963 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
97614: LD_VAR 0 1
97618: PUSH
97619: LD_INT 251
97621: EQUAL
97622: PUSH
97623: LD_VAR 0 2
97627: PPUSH
97628: CALL_OW 264
97632: PUSH
97633: LD_EXP 110
97637: EQUAL
97638: AND
97639: IFFALSE 97660
// MinerDetonateMine ( unit , x , y ) ;
97641: LD_VAR 0 2
97645: PPUSH
97646: LD_VAR 0 4
97650: PPUSH
97651: LD_VAR 0 5
97655: PPUSH
97656: CALL 100240 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
97660: LD_VAR 0 1
97664: PUSH
97665: LD_INT 252
97667: EQUAL
97668: PUSH
97669: LD_VAR 0 2
97673: PPUSH
97674: CALL_OW 264
97678: PUSH
97679: LD_EXP 110
97683: EQUAL
97684: AND
97685: IFFALSE 97706
// MinerCreateMinefield ( unit , x , y ) ;
97687: LD_VAR 0 2
97691: PPUSH
97692: LD_VAR 0 4
97696: PPUSH
97697: LD_VAR 0 5
97701: PPUSH
97702: CALL 100657 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
97706: LD_VAR 0 1
97710: PUSH
97711: LD_INT 253
97713: EQUAL
97714: PUSH
97715: LD_VAR 0 2
97719: PPUSH
97720: CALL_OW 257
97724: PUSH
97725: LD_INT 5
97727: EQUAL
97728: AND
97729: IFFALSE 97750
// ComBinocular ( unit , x , y ) ;
97731: LD_VAR 0 2
97735: PPUSH
97736: LD_VAR 0 4
97740: PPUSH
97741: LD_VAR 0 5
97745: PPUSH
97746: CALL 101028 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
97750: LD_VAR 0 1
97754: PUSH
97755: LD_INT 254
97757: EQUAL
97758: PUSH
97759: LD_VAR 0 2
97763: PPUSH
97764: CALL_OW 264
97768: PUSH
97769: LD_EXP 105
97773: EQUAL
97774: AND
97775: PUSH
97776: LD_VAR 0 3
97780: PPUSH
97781: CALL_OW 263
97785: PUSH
97786: LD_INT 3
97788: EQUAL
97789: AND
97790: IFFALSE 97806
// HackDestroyVehicle ( unit , selectedUnit ) ;
97792: LD_VAR 0 2
97796: PPUSH
97797: LD_VAR 0 3
97801: PPUSH
97802: CALL 99323 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
97806: LD_VAR 0 1
97810: PUSH
97811: LD_INT 255
97813: EQUAL
97814: PUSH
97815: LD_VAR 0 2
97819: PPUSH
97820: CALL_OW 264
97824: PUSH
97825: LD_INT 14
97827: PUSH
97828: LD_INT 53
97830: PUSH
97831: EMPTY
97832: LIST
97833: LIST
97834: IN
97835: AND
97836: PUSH
97837: LD_VAR 0 4
97841: PPUSH
97842: LD_VAR 0 5
97846: PPUSH
97847: CALL_OW 488
97851: AND
97852: IFFALSE 97876
// CutTreeXYR ( unit , x , y , 12 ) ;
97854: LD_VAR 0 2
97858: PPUSH
97859: LD_VAR 0 4
97863: PPUSH
97864: LD_VAR 0 5
97868: PPUSH
97869: LD_INT 12
97871: PPUSH
97872: CALL 97889 0 4
// end ;
97876: LD_VAR 0 6
97880: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
97881: LD_INT 0
97883: PPUSH
// end ;
97884: LD_VAR 0 4
97888: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
97889: LD_INT 0
97891: PPUSH
97892: PPUSH
97893: PPUSH
97894: PPUSH
97895: PPUSH
97896: PPUSH
97897: PPUSH
97898: PPUSH
97899: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
97900: LD_VAR 0 1
97904: NOT
97905: PUSH
97906: LD_VAR 0 2
97910: PPUSH
97911: LD_VAR 0 3
97915: PPUSH
97916: CALL_OW 488
97920: NOT
97921: OR
97922: PUSH
97923: LD_VAR 0 4
97927: NOT
97928: OR
97929: IFFALSE 97933
// exit ;
97931: GO 98273
// list := [ ] ;
97933: LD_ADDR_VAR 0 13
97937: PUSH
97938: EMPTY
97939: ST_TO_ADDR
// if x - r < 0 then
97940: LD_VAR 0 2
97944: PUSH
97945: LD_VAR 0 4
97949: MINUS
97950: PUSH
97951: LD_INT 0
97953: LESS
97954: IFFALSE 97966
// min_x := 0 else
97956: LD_ADDR_VAR 0 7
97960: PUSH
97961: LD_INT 0
97963: ST_TO_ADDR
97964: GO 97982
// min_x := x - r ;
97966: LD_ADDR_VAR 0 7
97970: PUSH
97971: LD_VAR 0 2
97975: PUSH
97976: LD_VAR 0 4
97980: MINUS
97981: ST_TO_ADDR
// if y - r < 0 then
97982: LD_VAR 0 3
97986: PUSH
97987: LD_VAR 0 4
97991: MINUS
97992: PUSH
97993: LD_INT 0
97995: LESS
97996: IFFALSE 98008
// min_y := 0 else
97998: LD_ADDR_VAR 0 8
98002: PUSH
98003: LD_INT 0
98005: ST_TO_ADDR
98006: GO 98024
// min_y := y - r ;
98008: LD_ADDR_VAR 0 8
98012: PUSH
98013: LD_VAR 0 3
98017: PUSH
98018: LD_VAR 0 4
98022: MINUS
98023: ST_TO_ADDR
// max_x := x + r ;
98024: LD_ADDR_VAR 0 9
98028: PUSH
98029: LD_VAR 0 2
98033: PUSH
98034: LD_VAR 0 4
98038: PLUS
98039: ST_TO_ADDR
// max_y := y + r ;
98040: LD_ADDR_VAR 0 10
98044: PUSH
98045: LD_VAR 0 3
98049: PUSH
98050: LD_VAR 0 4
98054: PLUS
98055: ST_TO_ADDR
// for _x = min_x to max_x do
98056: LD_ADDR_VAR 0 11
98060: PUSH
98061: DOUBLE
98062: LD_VAR 0 7
98066: DEC
98067: ST_TO_ADDR
98068: LD_VAR 0 9
98072: PUSH
98073: FOR_TO
98074: IFFALSE 98191
// for _y = min_y to max_y do
98076: LD_ADDR_VAR 0 12
98080: PUSH
98081: DOUBLE
98082: LD_VAR 0 8
98086: DEC
98087: ST_TO_ADDR
98088: LD_VAR 0 10
98092: PUSH
98093: FOR_TO
98094: IFFALSE 98187
// begin if not ValidHex ( _x , _y ) then
98096: LD_VAR 0 11
98100: PPUSH
98101: LD_VAR 0 12
98105: PPUSH
98106: CALL_OW 488
98110: NOT
98111: IFFALSE 98115
// continue ;
98113: GO 98093
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
98115: LD_VAR 0 11
98119: PPUSH
98120: LD_VAR 0 12
98124: PPUSH
98125: CALL_OW 351
98129: PUSH
98130: LD_VAR 0 11
98134: PPUSH
98135: LD_VAR 0 12
98139: PPUSH
98140: CALL_OW 554
98144: AND
98145: IFFALSE 98185
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
98147: LD_ADDR_VAR 0 13
98151: PUSH
98152: LD_VAR 0 13
98156: PPUSH
98157: LD_VAR 0 13
98161: PUSH
98162: LD_INT 1
98164: PLUS
98165: PPUSH
98166: LD_VAR 0 11
98170: PUSH
98171: LD_VAR 0 12
98175: PUSH
98176: EMPTY
98177: LIST
98178: LIST
98179: PPUSH
98180: CALL_OW 2
98184: ST_TO_ADDR
// end ;
98185: GO 98093
98187: POP
98188: POP
98189: GO 98073
98191: POP
98192: POP
// if not list then
98193: LD_VAR 0 13
98197: NOT
98198: IFFALSE 98202
// exit ;
98200: GO 98273
// for i in list do
98202: LD_ADDR_VAR 0 6
98206: PUSH
98207: LD_VAR 0 13
98211: PUSH
98212: FOR_IN
98213: IFFALSE 98271
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
98215: LD_VAR 0 1
98219: PPUSH
98220: LD_STRING M
98222: PUSH
98223: LD_VAR 0 6
98227: PUSH
98228: LD_INT 1
98230: ARRAY
98231: PUSH
98232: LD_VAR 0 6
98236: PUSH
98237: LD_INT 2
98239: ARRAY
98240: PUSH
98241: LD_INT 0
98243: PUSH
98244: LD_INT 0
98246: PUSH
98247: LD_INT 0
98249: PUSH
98250: LD_INT 0
98252: PUSH
98253: EMPTY
98254: LIST
98255: LIST
98256: LIST
98257: LIST
98258: LIST
98259: LIST
98260: LIST
98261: PUSH
98262: EMPTY
98263: LIST
98264: PPUSH
98265: CALL_OW 447
98269: GO 98212
98271: POP
98272: POP
// end ;
98273: LD_VAR 0 5
98277: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
98278: LD_EXP 179
98282: NOT
98283: IFFALSE 98333
98285: GO 98287
98287: DISABLE
// begin initHack := true ;
98288: LD_ADDR_EXP 179
98292: PUSH
98293: LD_INT 1
98295: ST_TO_ADDR
// hackTanks := [ ] ;
98296: LD_ADDR_EXP 180
98300: PUSH
98301: EMPTY
98302: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
98303: LD_ADDR_EXP 181
98307: PUSH
98308: EMPTY
98309: ST_TO_ADDR
// hackLimit := 3 ;
98310: LD_ADDR_EXP 182
98314: PUSH
98315: LD_INT 3
98317: ST_TO_ADDR
// hackDist := 12 ;
98318: LD_ADDR_EXP 183
98322: PUSH
98323: LD_INT 12
98325: ST_TO_ADDR
// hackCounter := [ ] ;
98326: LD_ADDR_EXP 184
98330: PUSH
98331: EMPTY
98332: ST_TO_ADDR
// end ;
98333: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
98334: LD_EXP 179
98338: PUSH
98339: LD_INT 34
98341: PUSH
98342: LD_EXP 105
98346: PUSH
98347: EMPTY
98348: LIST
98349: LIST
98350: PPUSH
98351: CALL_OW 69
98355: AND
98356: IFFALSE 98611
98358: GO 98360
98360: DISABLE
98361: LD_INT 0
98363: PPUSH
98364: PPUSH
// begin enable ;
98365: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
98366: LD_ADDR_VAR 0 1
98370: PUSH
98371: LD_INT 34
98373: PUSH
98374: LD_EXP 105
98378: PUSH
98379: EMPTY
98380: LIST
98381: LIST
98382: PPUSH
98383: CALL_OW 69
98387: PUSH
98388: FOR_IN
98389: IFFALSE 98609
// begin if not i in hackTanks then
98391: LD_VAR 0 1
98395: PUSH
98396: LD_EXP 180
98400: IN
98401: NOT
98402: IFFALSE 98485
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
98404: LD_ADDR_EXP 180
98408: PUSH
98409: LD_EXP 180
98413: PPUSH
98414: LD_EXP 180
98418: PUSH
98419: LD_INT 1
98421: PLUS
98422: PPUSH
98423: LD_VAR 0 1
98427: PPUSH
98428: CALL_OW 1
98432: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
98433: LD_ADDR_EXP 181
98437: PUSH
98438: LD_EXP 181
98442: PPUSH
98443: LD_EXP 181
98447: PUSH
98448: LD_INT 1
98450: PLUS
98451: PPUSH
98452: EMPTY
98453: PPUSH
98454: CALL_OW 1
98458: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
98459: LD_ADDR_EXP 184
98463: PUSH
98464: LD_EXP 184
98468: PPUSH
98469: LD_EXP 184
98473: PUSH
98474: LD_INT 1
98476: PLUS
98477: PPUSH
98478: EMPTY
98479: PPUSH
98480: CALL_OW 1
98484: ST_TO_ADDR
// end ; if not IsOk ( i ) then
98485: LD_VAR 0 1
98489: PPUSH
98490: CALL_OW 302
98494: NOT
98495: IFFALSE 98508
// begin HackUnlinkAll ( i ) ;
98497: LD_VAR 0 1
98501: PPUSH
98502: CALL 98614 0 1
// continue ;
98506: GO 98388
// end ; HackCheckCapturedStatus ( i ) ;
98508: LD_VAR 0 1
98512: PPUSH
98513: CALL 99057 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
98517: LD_ADDR_VAR 0 2
98521: PUSH
98522: LD_INT 81
98524: PUSH
98525: LD_VAR 0 1
98529: PPUSH
98530: CALL_OW 255
98534: PUSH
98535: EMPTY
98536: LIST
98537: LIST
98538: PUSH
98539: LD_INT 33
98541: PUSH
98542: LD_INT 3
98544: PUSH
98545: EMPTY
98546: LIST
98547: LIST
98548: PUSH
98549: LD_INT 91
98551: PUSH
98552: LD_VAR 0 1
98556: PUSH
98557: LD_EXP 183
98561: PUSH
98562: EMPTY
98563: LIST
98564: LIST
98565: LIST
98566: PUSH
98567: LD_INT 50
98569: PUSH
98570: EMPTY
98571: LIST
98572: PUSH
98573: EMPTY
98574: LIST
98575: LIST
98576: LIST
98577: LIST
98578: PPUSH
98579: CALL_OW 69
98583: ST_TO_ADDR
// if not tmp then
98584: LD_VAR 0 2
98588: NOT
98589: IFFALSE 98593
// continue ;
98591: GO 98388
// HackLink ( i , tmp ) ;
98593: LD_VAR 0 1
98597: PPUSH
98598: LD_VAR 0 2
98602: PPUSH
98603: CALL 98750 0 2
// end ;
98607: GO 98388
98609: POP
98610: POP
// end ;
98611: PPOPN 2
98613: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
98614: LD_INT 0
98616: PPUSH
98617: PPUSH
98618: PPUSH
// if not hack in hackTanks then
98619: LD_VAR 0 1
98623: PUSH
98624: LD_EXP 180
98628: IN
98629: NOT
98630: IFFALSE 98634
// exit ;
98632: GO 98745
// index := GetElementIndex ( hackTanks , hack ) ;
98634: LD_ADDR_VAR 0 4
98638: PUSH
98639: LD_EXP 180
98643: PPUSH
98644: LD_VAR 0 1
98648: PPUSH
98649: CALL 19511 0 2
98653: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
98654: LD_EXP 181
98658: PUSH
98659: LD_VAR 0 4
98663: ARRAY
98664: IFFALSE 98745
// begin for i in hackTanksCaptured [ index ] do
98666: LD_ADDR_VAR 0 3
98670: PUSH
98671: LD_EXP 181
98675: PUSH
98676: LD_VAR 0 4
98680: ARRAY
98681: PUSH
98682: FOR_IN
98683: IFFALSE 98709
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
98685: LD_VAR 0 3
98689: PUSH
98690: LD_INT 1
98692: ARRAY
98693: PPUSH
98694: LD_VAR 0 3
98698: PUSH
98699: LD_INT 2
98701: ARRAY
98702: PPUSH
98703: CALL_OW 235
98707: GO 98682
98709: POP
98710: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
98711: LD_ADDR_EXP 181
98715: PUSH
98716: LD_EXP 181
98720: PPUSH
98721: LD_VAR 0 4
98725: PPUSH
98726: EMPTY
98727: PPUSH
98728: CALL_OW 1
98732: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
98733: LD_VAR 0 1
98737: PPUSH
98738: LD_INT 0
98740: PPUSH
98741: CALL_OW 505
// end ; end ;
98745: LD_VAR 0 2
98749: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
98750: LD_INT 0
98752: PPUSH
98753: PPUSH
98754: PPUSH
// if not hack in hackTanks or not vehicles then
98755: LD_VAR 0 1
98759: PUSH
98760: LD_EXP 180
98764: IN
98765: NOT
98766: PUSH
98767: LD_VAR 0 2
98771: NOT
98772: OR
98773: IFFALSE 98777
// exit ;
98775: GO 99052
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
98777: LD_ADDR_VAR 0 2
98781: PUSH
98782: LD_VAR 0 1
98786: PPUSH
98787: LD_VAR 0 2
98791: PPUSH
98792: LD_INT 1
98794: PPUSH
98795: LD_INT 1
98797: PPUSH
98798: CALL 20161 0 4
98802: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
98803: LD_ADDR_VAR 0 5
98807: PUSH
98808: LD_EXP 180
98812: PPUSH
98813: LD_VAR 0 1
98817: PPUSH
98818: CALL 19511 0 2
98822: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
98823: LD_EXP 181
98827: PUSH
98828: LD_VAR 0 5
98832: ARRAY
98833: PUSH
98834: LD_EXP 182
98838: LESS
98839: IFFALSE 99028
// begin for i := 1 to vehicles do
98841: LD_ADDR_VAR 0 4
98845: PUSH
98846: DOUBLE
98847: LD_INT 1
98849: DEC
98850: ST_TO_ADDR
98851: LD_VAR 0 2
98855: PUSH
98856: FOR_TO
98857: IFFALSE 99026
// begin if hackTanksCaptured [ index ] = hackLimit then
98859: LD_EXP 181
98863: PUSH
98864: LD_VAR 0 5
98868: ARRAY
98869: PUSH
98870: LD_EXP 182
98874: EQUAL
98875: IFFALSE 98879
// break ;
98877: GO 99026
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
98879: LD_ADDR_EXP 184
98883: PUSH
98884: LD_EXP 184
98888: PPUSH
98889: LD_VAR 0 5
98893: PPUSH
98894: LD_EXP 184
98898: PUSH
98899: LD_VAR 0 5
98903: ARRAY
98904: PUSH
98905: LD_INT 1
98907: PLUS
98908: PPUSH
98909: CALL_OW 1
98913: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
98914: LD_ADDR_EXP 181
98918: PUSH
98919: LD_EXP 181
98923: PPUSH
98924: LD_VAR 0 5
98928: PUSH
98929: LD_EXP 181
98933: PUSH
98934: LD_VAR 0 5
98938: ARRAY
98939: PUSH
98940: LD_INT 1
98942: PLUS
98943: PUSH
98944: EMPTY
98945: LIST
98946: LIST
98947: PPUSH
98948: LD_VAR 0 2
98952: PUSH
98953: LD_VAR 0 4
98957: ARRAY
98958: PUSH
98959: LD_VAR 0 2
98963: PUSH
98964: LD_VAR 0 4
98968: ARRAY
98969: PPUSH
98970: CALL_OW 255
98974: PUSH
98975: EMPTY
98976: LIST
98977: LIST
98978: PPUSH
98979: CALL 19726 0 3
98983: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
98984: LD_VAR 0 2
98988: PUSH
98989: LD_VAR 0 4
98993: ARRAY
98994: PPUSH
98995: LD_VAR 0 1
98999: PPUSH
99000: CALL_OW 255
99004: PPUSH
99005: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
99009: LD_VAR 0 2
99013: PUSH
99014: LD_VAR 0 4
99018: ARRAY
99019: PPUSH
99020: CALL_OW 141
// end ;
99024: GO 98856
99026: POP
99027: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
99028: LD_VAR 0 1
99032: PPUSH
99033: LD_EXP 181
99037: PUSH
99038: LD_VAR 0 5
99042: ARRAY
99043: PUSH
99044: LD_INT 0
99046: PLUS
99047: PPUSH
99048: CALL_OW 505
// end ;
99052: LD_VAR 0 3
99056: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
99057: LD_INT 0
99059: PPUSH
99060: PPUSH
99061: PPUSH
99062: PPUSH
// if not hack in hackTanks then
99063: LD_VAR 0 1
99067: PUSH
99068: LD_EXP 180
99072: IN
99073: NOT
99074: IFFALSE 99078
// exit ;
99076: GO 99318
// index := GetElementIndex ( hackTanks , hack ) ;
99078: LD_ADDR_VAR 0 4
99082: PUSH
99083: LD_EXP 180
99087: PPUSH
99088: LD_VAR 0 1
99092: PPUSH
99093: CALL 19511 0 2
99097: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
99098: LD_ADDR_VAR 0 3
99102: PUSH
99103: DOUBLE
99104: LD_EXP 181
99108: PUSH
99109: LD_VAR 0 4
99113: ARRAY
99114: INC
99115: ST_TO_ADDR
99116: LD_INT 1
99118: PUSH
99119: FOR_DOWNTO
99120: IFFALSE 99292
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
99122: LD_ADDR_VAR 0 5
99126: PUSH
99127: LD_EXP 181
99131: PUSH
99132: LD_VAR 0 4
99136: ARRAY
99137: PUSH
99138: LD_VAR 0 3
99142: ARRAY
99143: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
99144: LD_VAR 0 5
99148: PUSH
99149: LD_INT 1
99151: ARRAY
99152: PPUSH
99153: CALL_OW 302
99157: NOT
99158: PUSH
99159: LD_VAR 0 5
99163: PUSH
99164: LD_INT 1
99166: ARRAY
99167: PPUSH
99168: CALL_OW 255
99172: PUSH
99173: LD_VAR 0 1
99177: PPUSH
99178: CALL_OW 255
99182: NONEQUAL
99183: OR
99184: IFFALSE 99290
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
99186: LD_VAR 0 5
99190: PUSH
99191: LD_INT 1
99193: ARRAY
99194: PPUSH
99195: CALL_OW 305
99199: PUSH
99200: LD_VAR 0 5
99204: PUSH
99205: LD_INT 1
99207: ARRAY
99208: PPUSH
99209: CALL_OW 255
99213: PUSH
99214: LD_VAR 0 1
99218: PPUSH
99219: CALL_OW 255
99223: EQUAL
99224: AND
99225: IFFALSE 99249
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
99227: LD_VAR 0 5
99231: PUSH
99232: LD_INT 1
99234: ARRAY
99235: PPUSH
99236: LD_VAR 0 5
99240: PUSH
99241: LD_INT 2
99243: ARRAY
99244: PPUSH
99245: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
99249: LD_ADDR_EXP 181
99253: PUSH
99254: LD_EXP 181
99258: PPUSH
99259: LD_VAR 0 4
99263: PPUSH
99264: LD_EXP 181
99268: PUSH
99269: LD_VAR 0 4
99273: ARRAY
99274: PPUSH
99275: LD_VAR 0 3
99279: PPUSH
99280: CALL_OW 3
99284: PPUSH
99285: CALL_OW 1
99289: ST_TO_ADDR
// end ; end ;
99290: GO 99119
99292: POP
99293: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
99294: LD_VAR 0 1
99298: PPUSH
99299: LD_EXP 181
99303: PUSH
99304: LD_VAR 0 4
99308: ARRAY
99309: PUSH
99310: LD_INT 0
99312: PLUS
99313: PPUSH
99314: CALL_OW 505
// end ;
99318: LD_VAR 0 2
99322: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
99323: LD_INT 0
99325: PPUSH
99326: PPUSH
99327: PPUSH
99328: PPUSH
// if not hack in hackTanks then
99329: LD_VAR 0 1
99333: PUSH
99334: LD_EXP 180
99338: IN
99339: NOT
99340: IFFALSE 99344
// exit ;
99342: GO 99429
// index := GetElementIndex ( hackTanks , hack ) ;
99344: LD_ADDR_VAR 0 5
99348: PUSH
99349: LD_EXP 180
99353: PPUSH
99354: LD_VAR 0 1
99358: PPUSH
99359: CALL 19511 0 2
99363: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
99364: LD_ADDR_VAR 0 4
99368: PUSH
99369: DOUBLE
99370: LD_INT 1
99372: DEC
99373: ST_TO_ADDR
99374: LD_EXP 181
99378: PUSH
99379: LD_VAR 0 5
99383: ARRAY
99384: PUSH
99385: FOR_TO
99386: IFFALSE 99427
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
99388: LD_EXP 181
99392: PUSH
99393: LD_VAR 0 5
99397: ARRAY
99398: PUSH
99399: LD_VAR 0 4
99403: ARRAY
99404: PUSH
99405: LD_INT 1
99407: ARRAY
99408: PUSH
99409: LD_VAR 0 2
99413: EQUAL
99414: IFFALSE 99425
// KillUnit ( vehicle ) ;
99416: LD_VAR 0 2
99420: PPUSH
99421: CALL_OW 66
99425: GO 99385
99427: POP
99428: POP
// end ;
99429: LD_VAR 0 3
99433: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
99434: LD_EXP 185
99438: NOT
99439: IFFALSE 99474
99441: GO 99443
99443: DISABLE
// begin initMiner := true ;
99444: LD_ADDR_EXP 185
99448: PUSH
99449: LD_INT 1
99451: ST_TO_ADDR
// minersList := [ ] ;
99452: LD_ADDR_EXP 186
99456: PUSH
99457: EMPTY
99458: ST_TO_ADDR
// minerMinesList := [ ] ;
99459: LD_ADDR_EXP 187
99463: PUSH
99464: EMPTY
99465: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
99466: LD_ADDR_EXP 188
99470: PUSH
99471: LD_INT 5
99473: ST_TO_ADDR
// end ;
99474: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
99475: LD_EXP 185
99479: PUSH
99480: LD_INT 34
99482: PUSH
99483: LD_EXP 110
99487: PUSH
99488: EMPTY
99489: LIST
99490: LIST
99491: PPUSH
99492: CALL_OW 69
99496: AND
99497: IFFALSE 99960
99499: GO 99501
99501: DISABLE
99502: LD_INT 0
99504: PPUSH
99505: PPUSH
99506: PPUSH
99507: PPUSH
// begin enable ;
99508: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
99509: LD_ADDR_VAR 0 1
99513: PUSH
99514: LD_INT 34
99516: PUSH
99517: LD_EXP 110
99521: PUSH
99522: EMPTY
99523: LIST
99524: LIST
99525: PPUSH
99526: CALL_OW 69
99530: PUSH
99531: FOR_IN
99532: IFFALSE 99604
// begin if not i in minersList then
99534: LD_VAR 0 1
99538: PUSH
99539: LD_EXP 186
99543: IN
99544: NOT
99545: IFFALSE 99602
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
99547: LD_ADDR_EXP 186
99551: PUSH
99552: LD_EXP 186
99556: PPUSH
99557: LD_EXP 186
99561: PUSH
99562: LD_INT 1
99564: PLUS
99565: PPUSH
99566: LD_VAR 0 1
99570: PPUSH
99571: CALL_OW 1
99575: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
99576: LD_ADDR_EXP 187
99580: PUSH
99581: LD_EXP 187
99585: PPUSH
99586: LD_EXP 187
99590: PUSH
99591: LD_INT 1
99593: PLUS
99594: PPUSH
99595: EMPTY
99596: PPUSH
99597: CALL_OW 1
99601: ST_TO_ADDR
// end end ;
99602: GO 99531
99604: POP
99605: POP
// for i := minerMinesList downto 1 do
99606: LD_ADDR_VAR 0 1
99610: PUSH
99611: DOUBLE
99612: LD_EXP 187
99616: INC
99617: ST_TO_ADDR
99618: LD_INT 1
99620: PUSH
99621: FOR_DOWNTO
99622: IFFALSE 99958
// begin if IsLive ( minersList [ i ] ) then
99624: LD_EXP 186
99628: PUSH
99629: LD_VAR 0 1
99633: ARRAY
99634: PPUSH
99635: CALL_OW 300
99639: IFFALSE 99667
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
99641: LD_EXP 186
99645: PUSH
99646: LD_VAR 0 1
99650: ARRAY
99651: PPUSH
99652: LD_EXP 187
99656: PUSH
99657: LD_VAR 0 1
99661: ARRAY
99662: PPUSH
99663: CALL_OW 505
// if not minerMinesList [ i ] then
99667: LD_EXP 187
99671: PUSH
99672: LD_VAR 0 1
99676: ARRAY
99677: NOT
99678: IFFALSE 99682
// continue ;
99680: GO 99621
// for j := minerMinesList [ i ] downto 1 do
99682: LD_ADDR_VAR 0 2
99686: PUSH
99687: DOUBLE
99688: LD_EXP 187
99692: PUSH
99693: LD_VAR 0 1
99697: ARRAY
99698: INC
99699: ST_TO_ADDR
99700: LD_INT 1
99702: PUSH
99703: FOR_DOWNTO
99704: IFFALSE 99954
// begin side := GetSide ( minersList [ i ] ) ;
99706: LD_ADDR_VAR 0 3
99710: PUSH
99711: LD_EXP 186
99715: PUSH
99716: LD_VAR 0 1
99720: ARRAY
99721: PPUSH
99722: CALL_OW 255
99726: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
99727: LD_ADDR_VAR 0 4
99731: PUSH
99732: LD_EXP 187
99736: PUSH
99737: LD_VAR 0 1
99741: ARRAY
99742: PUSH
99743: LD_VAR 0 2
99747: ARRAY
99748: PUSH
99749: LD_INT 1
99751: ARRAY
99752: PPUSH
99753: LD_EXP 187
99757: PUSH
99758: LD_VAR 0 1
99762: ARRAY
99763: PUSH
99764: LD_VAR 0 2
99768: ARRAY
99769: PUSH
99770: LD_INT 2
99772: ARRAY
99773: PPUSH
99774: CALL_OW 428
99778: ST_TO_ADDR
// if not tmp then
99779: LD_VAR 0 4
99783: NOT
99784: IFFALSE 99788
// continue ;
99786: GO 99703
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
99788: LD_VAR 0 4
99792: PUSH
99793: LD_INT 81
99795: PUSH
99796: LD_VAR 0 3
99800: PUSH
99801: EMPTY
99802: LIST
99803: LIST
99804: PPUSH
99805: CALL_OW 69
99809: IN
99810: PUSH
99811: LD_EXP 187
99815: PUSH
99816: LD_VAR 0 1
99820: ARRAY
99821: PUSH
99822: LD_VAR 0 2
99826: ARRAY
99827: PUSH
99828: LD_INT 1
99830: ARRAY
99831: PPUSH
99832: LD_EXP 187
99836: PUSH
99837: LD_VAR 0 1
99841: ARRAY
99842: PUSH
99843: LD_VAR 0 2
99847: ARRAY
99848: PUSH
99849: LD_INT 2
99851: ARRAY
99852: PPUSH
99853: CALL_OW 458
99857: AND
99858: IFFALSE 99952
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
99860: LD_EXP 187
99864: PUSH
99865: LD_VAR 0 1
99869: ARRAY
99870: PUSH
99871: LD_VAR 0 2
99875: ARRAY
99876: PUSH
99877: LD_INT 1
99879: ARRAY
99880: PPUSH
99881: LD_EXP 187
99885: PUSH
99886: LD_VAR 0 1
99890: ARRAY
99891: PUSH
99892: LD_VAR 0 2
99896: ARRAY
99897: PUSH
99898: LD_INT 2
99900: ARRAY
99901: PPUSH
99902: LD_VAR 0 3
99906: PPUSH
99907: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
99911: LD_ADDR_EXP 187
99915: PUSH
99916: LD_EXP 187
99920: PPUSH
99921: LD_VAR 0 1
99925: PPUSH
99926: LD_EXP 187
99930: PUSH
99931: LD_VAR 0 1
99935: ARRAY
99936: PPUSH
99937: LD_VAR 0 2
99941: PPUSH
99942: CALL_OW 3
99946: PPUSH
99947: CALL_OW 1
99951: ST_TO_ADDR
// end ; end ;
99952: GO 99703
99954: POP
99955: POP
// end ;
99956: GO 99621
99958: POP
99959: POP
// end ;
99960: PPOPN 4
99962: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
99963: LD_INT 0
99965: PPUSH
99966: PPUSH
// result := false ;
99967: LD_ADDR_VAR 0 4
99971: PUSH
99972: LD_INT 0
99974: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
99975: LD_VAR 0 1
99979: PPUSH
99980: CALL_OW 264
99984: PUSH
99985: LD_EXP 110
99989: EQUAL
99990: NOT
99991: IFFALSE 99995
// exit ;
99993: GO 100235
// index := GetElementIndex ( minersList , unit ) ;
99995: LD_ADDR_VAR 0 5
99999: PUSH
100000: LD_EXP 186
100004: PPUSH
100005: LD_VAR 0 1
100009: PPUSH
100010: CALL 19511 0 2
100014: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
100015: LD_EXP 187
100019: PUSH
100020: LD_VAR 0 5
100024: ARRAY
100025: PUSH
100026: LD_EXP 188
100030: GREATEREQUAL
100031: IFFALSE 100035
// exit ;
100033: GO 100235
// ComMoveXY ( unit , x , y ) ;
100035: LD_VAR 0 1
100039: PPUSH
100040: LD_VAR 0 2
100044: PPUSH
100045: LD_VAR 0 3
100049: PPUSH
100050: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
100054: LD_INT 35
100056: PPUSH
100057: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
100061: LD_VAR 0 1
100065: PPUSH
100066: LD_VAR 0 2
100070: PPUSH
100071: LD_VAR 0 3
100075: PPUSH
100076: CALL 50283 0 3
100080: NOT
100081: PUSH
100082: LD_VAR 0 1
100086: PPUSH
100087: CALL_OW 314
100091: AND
100092: IFFALSE 100096
// exit ;
100094: GO 100235
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
100096: LD_VAR 0 2
100100: PPUSH
100101: LD_VAR 0 3
100105: PPUSH
100106: CALL_OW 428
100110: PUSH
100111: LD_VAR 0 1
100115: EQUAL
100116: PUSH
100117: LD_VAR 0 1
100121: PPUSH
100122: CALL_OW 314
100126: NOT
100127: AND
100128: IFFALSE 100054
// PlaySoundXY ( x , y , PlantMine ) ;
100130: LD_VAR 0 2
100134: PPUSH
100135: LD_VAR 0 3
100139: PPUSH
100140: LD_STRING PlantMine
100142: PPUSH
100143: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
100147: LD_VAR 0 2
100151: PPUSH
100152: LD_VAR 0 3
100156: PPUSH
100157: LD_VAR 0 1
100161: PPUSH
100162: CALL_OW 255
100166: PPUSH
100167: LD_INT 0
100169: PPUSH
100170: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
100174: LD_ADDR_EXP 187
100178: PUSH
100179: LD_EXP 187
100183: PPUSH
100184: LD_VAR 0 5
100188: PUSH
100189: LD_EXP 187
100193: PUSH
100194: LD_VAR 0 5
100198: ARRAY
100199: PUSH
100200: LD_INT 1
100202: PLUS
100203: PUSH
100204: EMPTY
100205: LIST
100206: LIST
100207: PPUSH
100208: LD_VAR 0 2
100212: PUSH
100213: LD_VAR 0 3
100217: PUSH
100218: EMPTY
100219: LIST
100220: LIST
100221: PPUSH
100222: CALL 19726 0 3
100226: ST_TO_ADDR
// result := true ;
100227: LD_ADDR_VAR 0 4
100231: PUSH
100232: LD_INT 1
100234: ST_TO_ADDR
// end ;
100235: LD_VAR 0 4
100239: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
100240: LD_INT 0
100242: PPUSH
100243: PPUSH
100244: PPUSH
// if not unit in minersList then
100245: LD_VAR 0 1
100249: PUSH
100250: LD_EXP 186
100254: IN
100255: NOT
100256: IFFALSE 100260
// exit ;
100258: GO 100652
// index := GetElementIndex ( minersList , unit ) ;
100260: LD_ADDR_VAR 0 6
100264: PUSH
100265: LD_EXP 186
100269: PPUSH
100270: LD_VAR 0 1
100274: PPUSH
100275: CALL 19511 0 2
100279: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
100280: LD_ADDR_VAR 0 5
100284: PUSH
100285: DOUBLE
100286: LD_EXP 187
100290: PUSH
100291: LD_VAR 0 6
100295: ARRAY
100296: INC
100297: ST_TO_ADDR
100298: LD_INT 1
100300: PUSH
100301: FOR_DOWNTO
100302: IFFALSE 100463
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
100304: LD_EXP 187
100308: PUSH
100309: LD_VAR 0 6
100313: ARRAY
100314: PUSH
100315: LD_VAR 0 5
100319: ARRAY
100320: PUSH
100321: LD_INT 1
100323: ARRAY
100324: PUSH
100325: LD_VAR 0 2
100329: EQUAL
100330: PUSH
100331: LD_EXP 187
100335: PUSH
100336: LD_VAR 0 6
100340: ARRAY
100341: PUSH
100342: LD_VAR 0 5
100346: ARRAY
100347: PUSH
100348: LD_INT 2
100350: ARRAY
100351: PUSH
100352: LD_VAR 0 3
100356: EQUAL
100357: AND
100358: IFFALSE 100461
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
100360: LD_EXP 187
100364: PUSH
100365: LD_VAR 0 6
100369: ARRAY
100370: PUSH
100371: LD_VAR 0 5
100375: ARRAY
100376: PUSH
100377: LD_INT 1
100379: ARRAY
100380: PPUSH
100381: LD_EXP 187
100385: PUSH
100386: LD_VAR 0 6
100390: ARRAY
100391: PUSH
100392: LD_VAR 0 5
100396: ARRAY
100397: PUSH
100398: LD_INT 2
100400: ARRAY
100401: PPUSH
100402: LD_VAR 0 1
100406: PPUSH
100407: CALL_OW 255
100411: PPUSH
100412: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
100416: LD_ADDR_EXP 187
100420: PUSH
100421: LD_EXP 187
100425: PPUSH
100426: LD_VAR 0 6
100430: PPUSH
100431: LD_EXP 187
100435: PUSH
100436: LD_VAR 0 6
100440: ARRAY
100441: PPUSH
100442: LD_VAR 0 5
100446: PPUSH
100447: CALL_OW 3
100451: PPUSH
100452: CALL_OW 1
100456: ST_TO_ADDR
// exit ;
100457: POP
100458: POP
100459: GO 100652
// end ; end ;
100461: GO 100301
100463: POP
100464: POP
// for i := minerMinesList [ index ] downto 1 do
100465: LD_ADDR_VAR 0 5
100469: PUSH
100470: DOUBLE
100471: LD_EXP 187
100475: PUSH
100476: LD_VAR 0 6
100480: ARRAY
100481: INC
100482: ST_TO_ADDR
100483: LD_INT 1
100485: PUSH
100486: FOR_DOWNTO
100487: IFFALSE 100650
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
100489: LD_EXP 187
100493: PUSH
100494: LD_VAR 0 6
100498: ARRAY
100499: PUSH
100500: LD_VAR 0 5
100504: ARRAY
100505: PUSH
100506: LD_INT 1
100508: ARRAY
100509: PPUSH
100510: LD_EXP 187
100514: PUSH
100515: LD_VAR 0 6
100519: ARRAY
100520: PUSH
100521: LD_VAR 0 5
100525: ARRAY
100526: PUSH
100527: LD_INT 2
100529: ARRAY
100530: PPUSH
100531: LD_VAR 0 2
100535: PPUSH
100536: LD_VAR 0 3
100540: PPUSH
100541: CALL_OW 298
100545: PUSH
100546: LD_INT 6
100548: LESS
100549: IFFALSE 100648
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
100551: LD_EXP 187
100555: PUSH
100556: LD_VAR 0 6
100560: ARRAY
100561: PUSH
100562: LD_VAR 0 5
100566: ARRAY
100567: PUSH
100568: LD_INT 1
100570: ARRAY
100571: PPUSH
100572: LD_EXP 187
100576: PUSH
100577: LD_VAR 0 6
100581: ARRAY
100582: PUSH
100583: LD_VAR 0 5
100587: ARRAY
100588: PUSH
100589: LD_INT 2
100591: ARRAY
100592: PPUSH
100593: LD_VAR 0 1
100597: PPUSH
100598: CALL_OW 255
100602: PPUSH
100603: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
100607: LD_ADDR_EXP 187
100611: PUSH
100612: LD_EXP 187
100616: PPUSH
100617: LD_VAR 0 6
100621: PPUSH
100622: LD_EXP 187
100626: PUSH
100627: LD_VAR 0 6
100631: ARRAY
100632: PPUSH
100633: LD_VAR 0 5
100637: PPUSH
100638: CALL_OW 3
100642: PPUSH
100643: CALL_OW 1
100647: ST_TO_ADDR
// end ; end ;
100648: GO 100486
100650: POP
100651: POP
// end ;
100652: LD_VAR 0 4
100656: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
100657: LD_INT 0
100659: PPUSH
100660: PPUSH
100661: PPUSH
100662: PPUSH
100663: PPUSH
100664: PPUSH
100665: PPUSH
100666: PPUSH
100667: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
100668: LD_VAR 0 1
100672: PPUSH
100673: CALL_OW 264
100677: PUSH
100678: LD_EXP 110
100682: EQUAL
100683: NOT
100684: PUSH
100685: LD_VAR 0 1
100689: PUSH
100690: LD_EXP 186
100694: IN
100695: NOT
100696: OR
100697: IFFALSE 100701
// exit ;
100699: GO 101023
// index := GetElementIndex ( minersList , unit ) ;
100701: LD_ADDR_VAR 0 6
100705: PUSH
100706: LD_EXP 186
100710: PPUSH
100711: LD_VAR 0 1
100715: PPUSH
100716: CALL 19511 0 2
100720: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
100721: LD_ADDR_VAR 0 8
100725: PUSH
100726: LD_EXP 188
100730: PUSH
100731: LD_EXP 187
100735: PUSH
100736: LD_VAR 0 6
100740: ARRAY
100741: MINUS
100742: ST_TO_ADDR
// if not minesFreeAmount then
100743: LD_VAR 0 8
100747: NOT
100748: IFFALSE 100752
// exit ;
100750: GO 101023
// tmp := [ ] ;
100752: LD_ADDR_VAR 0 7
100756: PUSH
100757: EMPTY
100758: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
100759: LD_ADDR_VAR 0 5
100763: PUSH
100764: DOUBLE
100765: LD_INT 1
100767: DEC
100768: ST_TO_ADDR
100769: LD_VAR 0 8
100773: PUSH
100774: FOR_TO
100775: IFFALSE 100970
// begin _d := rand ( 0 , 5 ) ;
100777: LD_ADDR_VAR 0 11
100781: PUSH
100782: LD_INT 0
100784: PPUSH
100785: LD_INT 5
100787: PPUSH
100788: CALL_OW 12
100792: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
100793: LD_ADDR_VAR 0 12
100797: PUSH
100798: LD_INT 2
100800: PPUSH
100801: LD_INT 6
100803: PPUSH
100804: CALL_OW 12
100808: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
100809: LD_ADDR_VAR 0 9
100813: PUSH
100814: LD_VAR 0 2
100818: PPUSH
100819: LD_VAR 0 11
100823: PPUSH
100824: LD_VAR 0 12
100828: PPUSH
100829: CALL_OW 272
100833: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
100834: LD_ADDR_VAR 0 10
100838: PUSH
100839: LD_VAR 0 3
100843: PPUSH
100844: LD_VAR 0 11
100848: PPUSH
100849: LD_VAR 0 12
100853: PPUSH
100854: CALL_OW 273
100858: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
100859: LD_VAR 0 9
100863: PPUSH
100864: LD_VAR 0 10
100868: PPUSH
100869: CALL_OW 488
100873: PUSH
100874: LD_VAR 0 9
100878: PUSH
100879: LD_VAR 0 10
100883: PUSH
100884: EMPTY
100885: LIST
100886: LIST
100887: PUSH
100888: LD_VAR 0 7
100892: IN
100893: NOT
100894: AND
100895: PUSH
100896: LD_VAR 0 9
100900: PPUSH
100901: LD_VAR 0 10
100905: PPUSH
100906: CALL_OW 458
100910: NOT
100911: AND
100912: IFFALSE 100954
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
100914: LD_ADDR_VAR 0 7
100918: PUSH
100919: LD_VAR 0 7
100923: PPUSH
100924: LD_VAR 0 7
100928: PUSH
100929: LD_INT 1
100931: PLUS
100932: PPUSH
100933: LD_VAR 0 9
100937: PUSH
100938: LD_VAR 0 10
100942: PUSH
100943: EMPTY
100944: LIST
100945: LIST
100946: PPUSH
100947: CALL_OW 1
100951: ST_TO_ADDR
100952: GO 100968
// i := i - 1 ;
100954: LD_ADDR_VAR 0 5
100958: PUSH
100959: LD_VAR 0 5
100963: PUSH
100964: LD_INT 1
100966: MINUS
100967: ST_TO_ADDR
// end ;
100968: GO 100774
100970: POP
100971: POP
// for i in tmp do
100972: LD_ADDR_VAR 0 5
100976: PUSH
100977: LD_VAR 0 7
100981: PUSH
100982: FOR_IN
100983: IFFALSE 101021
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
100985: LD_VAR 0 1
100989: PPUSH
100990: LD_VAR 0 5
100994: PUSH
100995: LD_INT 1
100997: ARRAY
100998: PPUSH
100999: LD_VAR 0 5
101003: PUSH
101004: LD_INT 2
101006: ARRAY
101007: PPUSH
101008: CALL 99963 0 3
101012: NOT
101013: IFFALSE 101019
// exit ;
101015: POP
101016: POP
101017: GO 101023
101019: GO 100982
101021: POP
101022: POP
// end ;
101023: LD_VAR 0 4
101027: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
101028: LD_INT 0
101030: PPUSH
101031: PPUSH
101032: PPUSH
101033: PPUSH
101034: PPUSH
101035: PPUSH
101036: PPUSH
// if not GetClass ( unit ) = class_sniper then
101037: LD_VAR 0 1
101041: PPUSH
101042: CALL_OW 257
101046: PUSH
101047: LD_INT 5
101049: EQUAL
101050: NOT
101051: IFFALSE 101055
// exit ;
101053: GO 101443
// dist := 8 ;
101055: LD_ADDR_VAR 0 5
101059: PUSH
101060: LD_INT 8
101062: ST_TO_ADDR
// viewRange := 12 ;
101063: LD_ADDR_VAR 0 7
101067: PUSH
101068: LD_INT 12
101070: ST_TO_ADDR
// side := GetSide ( unit ) ;
101071: LD_ADDR_VAR 0 6
101075: PUSH
101076: LD_VAR 0 1
101080: PPUSH
101081: CALL_OW 255
101085: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
101086: LD_INT 61
101088: PPUSH
101089: LD_VAR 0 6
101093: PPUSH
101094: CALL_OW 321
101098: PUSH
101099: LD_INT 2
101101: EQUAL
101102: IFFALSE 101112
// viewRange := 16 ;
101104: LD_ADDR_VAR 0 7
101108: PUSH
101109: LD_INT 16
101111: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
101112: LD_VAR 0 1
101116: PPUSH
101117: LD_VAR 0 2
101121: PPUSH
101122: LD_VAR 0 3
101126: PPUSH
101127: CALL_OW 297
101131: PUSH
101132: LD_VAR 0 5
101136: GREATER
101137: IFFALSE 101216
// begin ComMoveXY ( unit , x , y ) ;
101139: LD_VAR 0 1
101143: PPUSH
101144: LD_VAR 0 2
101148: PPUSH
101149: LD_VAR 0 3
101153: PPUSH
101154: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
101158: LD_INT 35
101160: PPUSH
101161: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
101165: LD_VAR 0 1
101169: PPUSH
101170: LD_VAR 0 2
101174: PPUSH
101175: LD_VAR 0 3
101179: PPUSH
101180: CALL 50283 0 3
101184: NOT
101185: IFFALSE 101189
// exit ;
101187: GO 101443
// until GetDistUnitXY ( unit , x , y ) < dist ;
101189: LD_VAR 0 1
101193: PPUSH
101194: LD_VAR 0 2
101198: PPUSH
101199: LD_VAR 0 3
101203: PPUSH
101204: CALL_OW 297
101208: PUSH
101209: LD_VAR 0 5
101213: LESS
101214: IFFALSE 101158
// end ; ComTurnXY ( unit , x , y ) ;
101216: LD_VAR 0 1
101220: PPUSH
101221: LD_VAR 0 2
101225: PPUSH
101226: LD_VAR 0 3
101230: PPUSH
101231: CALL_OW 118
// wait ( 5 ) ;
101235: LD_INT 5
101237: PPUSH
101238: CALL_OW 67
// _d := GetDir ( unit ) ;
101242: LD_ADDR_VAR 0 10
101246: PUSH
101247: LD_VAR 0 1
101251: PPUSH
101252: CALL_OW 254
101256: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
101257: LD_ADDR_VAR 0 8
101261: PUSH
101262: LD_VAR 0 1
101266: PPUSH
101267: CALL_OW 250
101271: PPUSH
101272: LD_VAR 0 10
101276: PPUSH
101277: LD_VAR 0 5
101281: PPUSH
101282: CALL_OW 272
101286: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
101287: LD_ADDR_VAR 0 9
101291: PUSH
101292: LD_VAR 0 1
101296: PPUSH
101297: CALL_OW 251
101301: PPUSH
101302: LD_VAR 0 10
101306: PPUSH
101307: LD_VAR 0 5
101311: PPUSH
101312: CALL_OW 273
101316: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
101317: LD_VAR 0 8
101321: PPUSH
101322: LD_VAR 0 9
101326: PPUSH
101327: CALL_OW 488
101331: NOT
101332: IFFALSE 101336
// exit ;
101334: GO 101443
// ComAnimCustom ( unit , 1 ) ;
101336: LD_VAR 0 1
101340: PPUSH
101341: LD_INT 1
101343: PPUSH
101344: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
101348: LD_VAR 0 8
101352: PPUSH
101353: LD_VAR 0 9
101357: PPUSH
101358: LD_VAR 0 6
101362: PPUSH
101363: LD_VAR 0 7
101367: PPUSH
101368: CALL_OW 330
// repeat wait ( 1 ) ;
101372: LD_INT 1
101374: PPUSH
101375: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
101379: LD_VAR 0 1
101383: PPUSH
101384: CALL_OW 316
101388: PUSH
101389: LD_VAR 0 1
101393: PPUSH
101394: CALL_OW 314
101398: OR
101399: PUSH
101400: LD_VAR 0 1
101404: PPUSH
101405: CALL_OW 302
101409: NOT
101410: OR
101411: PUSH
101412: LD_VAR 0 1
101416: PPUSH
101417: CALL_OW 301
101421: OR
101422: IFFALSE 101372
// RemoveSeeing ( _x , _y , side ) ;
101424: LD_VAR 0 8
101428: PPUSH
101429: LD_VAR 0 9
101433: PPUSH
101434: LD_VAR 0 6
101438: PPUSH
101439: CALL_OW 331
// end ; end_of_file
101443: LD_VAR 0 4
101447: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
101448: LD_INT 0
101450: PPUSH
101451: PPUSH
101452: PPUSH
101453: PPUSH
101454: PPUSH
101455: PPUSH
101456: PPUSH
101457: PPUSH
101458: PPUSH
101459: PPUSH
101460: PPUSH
101461: PPUSH
101462: PPUSH
101463: PPUSH
101464: PPUSH
101465: PPUSH
101466: PPUSH
101467: PPUSH
101468: PPUSH
101469: PPUSH
101470: PPUSH
101471: PPUSH
101472: PPUSH
101473: PPUSH
101474: PPUSH
101475: PPUSH
101476: PPUSH
101477: PPUSH
101478: PPUSH
101479: PPUSH
101480: PPUSH
101481: PPUSH
101482: PPUSH
101483: PPUSH
// if not list then
101484: LD_VAR 0 1
101488: NOT
101489: IFFALSE 101493
// exit ;
101491: GO 106152
// base := list [ 1 ] ;
101493: LD_ADDR_VAR 0 3
101497: PUSH
101498: LD_VAR 0 1
101502: PUSH
101503: LD_INT 1
101505: ARRAY
101506: ST_TO_ADDR
// group := list [ 2 ] ;
101507: LD_ADDR_VAR 0 4
101511: PUSH
101512: LD_VAR 0 1
101516: PUSH
101517: LD_INT 2
101519: ARRAY
101520: ST_TO_ADDR
// path := list [ 3 ] ;
101521: LD_ADDR_VAR 0 5
101525: PUSH
101526: LD_VAR 0 1
101530: PUSH
101531: LD_INT 3
101533: ARRAY
101534: ST_TO_ADDR
// flags := list [ 4 ] ;
101535: LD_ADDR_VAR 0 6
101539: PUSH
101540: LD_VAR 0 1
101544: PUSH
101545: LD_INT 4
101547: ARRAY
101548: ST_TO_ADDR
// mined := [ ] ;
101549: LD_ADDR_VAR 0 27
101553: PUSH
101554: EMPTY
101555: ST_TO_ADDR
// bombed := [ ] ;
101556: LD_ADDR_VAR 0 28
101560: PUSH
101561: EMPTY
101562: ST_TO_ADDR
// healers := [ ] ;
101563: LD_ADDR_VAR 0 31
101567: PUSH
101568: EMPTY
101569: ST_TO_ADDR
// to_heal := [ ] ;
101570: LD_ADDR_VAR 0 30
101574: PUSH
101575: EMPTY
101576: ST_TO_ADDR
// repairs := [ ] ;
101577: LD_ADDR_VAR 0 33
101581: PUSH
101582: EMPTY
101583: ST_TO_ADDR
// to_repair := [ ] ;
101584: LD_ADDR_VAR 0 32
101588: PUSH
101589: EMPTY
101590: ST_TO_ADDR
// if not group or not path then
101591: LD_VAR 0 4
101595: NOT
101596: PUSH
101597: LD_VAR 0 5
101601: NOT
101602: OR
101603: IFFALSE 101607
// exit ;
101605: GO 106152
// side := GetSide ( group [ 1 ] ) ;
101607: LD_ADDR_VAR 0 35
101611: PUSH
101612: LD_VAR 0 4
101616: PUSH
101617: LD_INT 1
101619: ARRAY
101620: PPUSH
101621: CALL_OW 255
101625: ST_TO_ADDR
// if flags then
101626: LD_VAR 0 6
101630: IFFALSE 101774
// begin f_ignore_area := flags [ 1 ] ;
101632: LD_ADDR_VAR 0 17
101636: PUSH
101637: LD_VAR 0 6
101641: PUSH
101642: LD_INT 1
101644: ARRAY
101645: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
101646: LD_ADDR_VAR 0 18
101650: PUSH
101651: LD_VAR 0 6
101655: PUSH
101656: LD_INT 2
101658: ARRAY
101659: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
101660: LD_ADDR_VAR 0 19
101664: PUSH
101665: LD_VAR 0 6
101669: PUSH
101670: LD_INT 3
101672: ARRAY
101673: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
101674: LD_ADDR_VAR 0 20
101678: PUSH
101679: LD_VAR 0 6
101683: PUSH
101684: LD_INT 4
101686: ARRAY
101687: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
101688: LD_ADDR_VAR 0 21
101692: PUSH
101693: LD_VAR 0 6
101697: PUSH
101698: LD_INT 5
101700: ARRAY
101701: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
101702: LD_ADDR_VAR 0 22
101706: PUSH
101707: LD_VAR 0 6
101711: PUSH
101712: LD_INT 6
101714: ARRAY
101715: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
101716: LD_ADDR_VAR 0 23
101720: PUSH
101721: LD_VAR 0 6
101725: PUSH
101726: LD_INT 7
101728: ARRAY
101729: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
101730: LD_ADDR_VAR 0 24
101734: PUSH
101735: LD_VAR 0 6
101739: PUSH
101740: LD_INT 8
101742: ARRAY
101743: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
101744: LD_ADDR_VAR 0 25
101748: PUSH
101749: LD_VAR 0 6
101753: PUSH
101754: LD_INT 9
101756: ARRAY
101757: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
101758: LD_ADDR_VAR 0 26
101762: PUSH
101763: LD_VAR 0 6
101767: PUSH
101768: LD_INT 10
101770: ARRAY
101771: ST_TO_ADDR
// end else
101772: GO 101854
// begin f_ignore_area := false ;
101774: LD_ADDR_VAR 0 17
101778: PUSH
101779: LD_INT 0
101781: ST_TO_ADDR
// f_capture := false ;
101782: LD_ADDR_VAR 0 18
101786: PUSH
101787: LD_INT 0
101789: ST_TO_ADDR
// f_ignore_civ := false ;
101790: LD_ADDR_VAR 0 19
101794: PUSH
101795: LD_INT 0
101797: ST_TO_ADDR
// f_murder := false ;
101798: LD_ADDR_VAR 0 20
101802: PUSH
101803: LD_INT 0
101805: ST_TO_ADDR
// f_mines := false ;
101806: LD_ADDR_VAR 0 21
101810: PUSH
101811: LD_INT 0
101813: ST_TO_ADDR
// f_repair := false ;
101814: LD_ADDR_VAR 0 22
101818: PUSH
101819: LD_INT 0
101821: ST_TO_ADDR
// f_heal := false ;
101822: LD_ADDR_VAR 0 23
101826: PUSH
101827: LD_INT 0
101829: ST_TO_ADDR
// f_spacetime := false ;
101830: LD_ADDR_VAR 0 24
101834: PUSH
101835: LD_INT 0
101837: ST_TO_ADDR
// f_attack_depot := false ;
101838: LD_ADDR_VAR 0 25
101842: PUSH
101843: LD_INT 0
101845: ST_TO_ADDR
// f_crawl := false ;
101846: LD_ADDR_VAR 0 26
101850: PUSH
101851: LD_INT 0
101853: ST_TO_ADDR
// end ; if f_heal then
101854: LD_VAR 0 23
101858: IFFALSE 101885
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
101860: LD_ADDR_VAR 0 31
101864: PUSH
101865: LD_VAR 0 4
101869: PPUSH
101870: LD_INT 25
101872: PUSH
101873: LD_INT 4
101875: PUSH
101876: EMPTY
101877: LIST
101878: LIST
101879: PPUSH
101880: CALL_OW 72
101884: ST_TO_ADDR
// if f_repair then
101885: LD_VAR 0 22
101889: IFFALSE 101916
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
101891: LD_ADDR_VAR 0 33
101895: PUSH
101896: LD_VAR 0 4
101900: PPUSH
101901: LD_INT 25
101903: PUSH
101904: LD_INT 3
101906: PUSH
101907: EMPTY
101908: LIST
101909: LIST
101910: PPUSH
101911: CALL_OW 72
101915: ST_TO_ADDR
// units_path := [ ] ;
101916: LD_ADDR_VAR 0 16
101920: PUSH
101921: EMPTY
101922: ST_TO_ADDR
// for i = 1 to group do
101923: LD_ADDR_VAR 0 7
101927: PUSH
101928: DOUBLE
101929: LD_INT 1
101931: DEC
101932: ST_TO_ADDR
101933: LD_VAR 0 4
101937: PUSH
101938: FOR_TO
101939: IFFALSE 101968
// units_path := Replace ( units_path , i , path ) ;
101941: LD_ADDR_VAR 0 16
101945: PUSH
101946: LD_VAR 0 16
101950: PPUSH
101951: LD_VAR 0 7
101955: PPUSH
101956: LD_VAR 0 5
101960: PPUSH
101961: CALL_OW 1
101965: ST_TO_ADDR
101966: GO 101938
101968: POP
101969: POP
// repeat for i = group downto 1 do
101970: LD_ADDR_VAR 0 7
101974: PUSH
101975: DOUBLE
101976: LD_VAR 0 4
101980: INC
101981: ST_TO_ADDR
101982: LD_INT 1
101984: PUSH
101985: FOR_DOWNTO
101986: IFFALSE 106108
// begin wait ( 5 ) ;
101988: LD_INT 5
101990: PPUSH
101991: CALL_OW 67
// tmp := [ ] ;
101995: LD_ADDR_VAR 0 14
101999: PUSH
102000: EMPTY
102001: ST_TO_ADDR
// attacking := false ;
102002: LD_ADDR_VAR 0 29
102006: PUSH
102007: LD_INT 0
102009: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
102010: LD_VAR 0 4
102014: PUSH
102015: LD_VAR 0 7
102019: ARRAY
102020: PPUSH
102021: CALL_OW 301
102025: PUSH
102026: LD_VAR 0 4
102030: PUSH
102031: LD_VAR 0 7
102035: ARRAY
102036: NOT
102037: OR
102038: IFFALSE 102147
// begin if GetType ( group [ i ] ) = unit_human then
102040: LD_VAR 0 4
102044: PUSH
102045: LD_VAR 0 7
102049: ARRAY
102050: PPUSH
102051: CALL_OW 247
102055: PUSH
102056: LD_INT 1
102058: EQUAL
102059: IFFALSE 102105
// begin to_heal := to_heal diff group [ i ] ;
102061: LD_ADDR_VAR 0 30
102065: PUSH
102066: LD_VAR 0 30
102070: PUSH
102071: LD_VAR 0 4
102075: PUSH
102076: LD_VAR 0 7
102080: ARRAY
102081: DIFF
102082: ST_TO_ADDR
// healers := healers diff group [ i ] ;
102083: LD_ADDR_VAR 0 31
102087: PUSH
102088: LD_VAR 0 31
102092: PUSH
102093: LD_VAR 0 4
102097: PUSH
102098: LD_VAR 0 7
102102: ARRAY
102103: DIFF
102104: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
102105: LD_ADDR_VAR 0 4
102109: PUSH
102110: LD_VAR 0 4
102114: PPUSH
102115: LD_VAR 0 7
102119: PPUSH
102120: CALL_OW 3
102124: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
102125: LD_ADDR_VAR 0 16
102129: PUSH
102130: LD_VAR 0 16
102134: PPUSH
102135: LD_VAR 0 7
102139: PPUSH
102140: CALL_OW 3
102144: ST_TO_ADDR
// continue ;
102145: GO 101985
// end ; if f_repair then
102147: LD_VAR 0 22
102151: IFFALSE 102640
// begin if GetType ( group [ i ] ) = unit_vehicle then
102153: LD_VAR 0 4
102157: PUSH
102158: LD_VAR 0 7
102162: ARRAY
102163: PPUSH
102164: CALL_OW 247
102168: PUSH
102169: LD_INT 2
102171: EQUAL
102172: IFFALSE 102362
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
102174: LD_VAR 0 4
102178: PUSH
102179: LD_VAR 0 7
102183: ARRAY
102184: PPUSH
102185: CALL_OW 256
102189: PUSH
102190: LD_INT 700
102192: LESS
102193: PUSH
102194: LD_VAR 0 4
102198: PUSH
102199: LD_VAR 0 7
102203: ARRAY
102204: PUSH
102205: LD_VAR 0 32
102209: IN
102210: NOT
102211: AND
102212: IFFALSE 102236
// to_repair := to_repair union group [ i ] ;
102214: LD_ADDR_VAR 0 32
102218: PUSH
102219: LD_VAR 0 32
102223: PUSH
102224: LD_VAR 0 4
102228: PUSH
102229: LD_VAR 0 7
102233: ARRAY
102234: UNION
102235: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
102236: LD_VAR 0 4
102240: PUSH
102241: LD_VAR 0 7
102245: ARRAY
102246: PPUSH
102247: CALL_OW 256
102251: PUSH
102252: LD_INT 1000
102254: EQUAL
102255: PUSH
102256: LD_VAR 0 4
102260: PUSH
102261: LD_VAR 0 7
102265: ARRAY
102266: PUSH
102267: LD_VAR 0 32
102271: IN
102272: AND
102273: IFFALSE 102297
// to_repair := to_repair diff group [ i ] ;
102275: LD_ADDR_VAR 0 32
102279: PUSH
102280: LD_VAR 0 32
102284: PUSH
102285: LD_VAR 0 4
102289: PUSH
102290: LD_VAR 0 7
102294: ARRAY
102295: DIFF
102296: ST_TO_ADDR
// if group [ i ] in to_repair then
102297: LD_VAR 0 4
102301: PUSH
102302: LD_VAR 0 7
102306: ARRAY
102307: PUSH
102308: LD_VAR 0 32
102312: IN
102313: IFFALSE 102360
// begin if not IsInArea ( group [ i ] , f_repair ) then
102315: LD_VAR 0 4
102319: PUSH
102320: LD_VAR 0 7
102324: ARRAY
102325: PPUSH
102326: LD_VAR 0 22
102330: PPUSH
102331: CALL_OW 308
102335: NOT
102336: IFFALSE 102358
// ComMoveToArea ( group [ i ] , f_repair ) ;
102338: LD_VAR 0 4
102342: PUSH
102343: LD_VAR 0 7
102347: ARRAY
102348: PPUSH
102349: LD_VAR 0 22
102353: PPUSH
102354: CALL_OW 113
// continue ;
102358: GO 101985
// end ; end else
102360: GO 102640
// if group [ i ] in repairs then
102362: LD_VAR 0 4
102366: PUSH
102367: LD_VAR 0 7
102371: ARRAY
102372: PUSH
102373: LD_VAR 0 33
102377: IN
102378: IFFALSE 102640
// begin if IsInUnit ( group [ i ] ) then
102380: LD_VAR 0 4
102384: PUSH
102385: LD_VAR 0 7
102389: ARRAY
102390: PPUSH
102391: CALL_OW 310
102395: IFFALSE 102463
// begin z := IsInUnit ( group [ i ] ) ;
102397: LD_ADDR_VAR 0 13
102401: PUSH
102402: LD_VAR 0 4
102406: PUSH
102407: LD_VAR 0 7
102411: ARRAY
102412: PPUSH
102413: CALL_OW 310
102417: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
102418: LD_VAR 0 13
102422: PUSH
102423: LD_VAR 0 32
102427: IN
102428: PUSH
102429: LD_VAR 0 13
102433: PPUSH
102434: LD_VAR 0 22
102438: PPUSH
102439: CALL_OW 308
102443: AND
102444: IFFALSE 102461
// ComExitVehicle ( group [ i ] ) ;
102446: LD_VAR 0 4
102450: PUSH
102451: LD_VAR 0 7
102455: ARRAY
102456: PPUSH
102457: CALL_OW 121
// end else
102461: GO 102640
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
102463: LD_ADDR_VAR 0 13
102467: PUSH
102468: LD_VAR 0 4
102472: PPUSH
102473: LD_INT 95
102475: PUSH
102476: LD_VAR 0 22
102480: PUSH
102481: EMPTY
102482: LIST
102483: LIST
102484: PUSH
102485: LD_INT 58
102487: PUSH
102488: EMPTY
102489: LIST
102490: PUSH
102491: EMPTY
102492: LIST
102493: LIST
102494: PPUSH
102495: CALL_OW 72
102499: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
102500: LD_VAR 0 4
102504: PUSH
102505: LD_VAR 0 7
102509: ARRAY
102510: PPUSH
102511: CALL_OW 314
102515: NOT
102516: IFFALSE 102638
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
102518: LD_ADDR_VAR 0 10
102522: PUSH
102523: LD_VAR 0 13
102527: PPUSH
102528: LD_VAR 0 4
102532: PUSH
102533: LD_VAR 0 7
102537: ARRAY
102538: PPUSH
102539: CALL_OW 74
102543: ST_TO_ADDR
// if not x then
102544: LD_VAR 0 10
102548: NOT
102549: IFFALSE 102553
// continue ;
102551: GO 101985
// if GetLives ( x ) < 1000 then
102553: LD_VAR 0 10
102557: PPUSH
102558: CALL_OW 256
102562: PUSH
102563: LD_INT 1000
102565: LESS
102566: IFFALSE 102590
// ComRepairVehicle ( group [ i ] , x ) else
102568: LD_VAR 0 4
102572: PUSH
102573: LD_VAR 0 7
102577: ARRAY
102578: PPUSH
102579: LD_VAR 0 10
102583: PPUSH
102584: CALL_OW 129
102588: GO 102638
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
102590: LD_VAR 0 23
102594: PUSH
102595: LD_VAR 0 4
102599: PUSH
102600: LD_VAR 0 7
102604: ARRAY
102605: PPUSH
102606: CALL_OW 256
102610: PUSH
102611: LD_INT 1000
102613: LESS
102614: AND
102615: NOT
102616: IFFALSE 102638
// ComEnterUnit ( group [ i ] , x ) ;
102618: LD_VAR 0 4
102622: PUSH
102623: LD_VAR 0 7
102627: ARRAY
102628: PPUSH
102629: LD_VAR 0 10
102633: PPUSH
102634: CALL_OW 120
// end ; continue ;
102638: GO 101985
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
102640: LD_VAR 0 23
102644: PUSH
102645: LD_VAR 0 4
102649: PUSH
102650: LD_VAR 0 7
102654: ARRAY
102655: PPUSH
102656: CALL_OW 247
102660: PUSH
102661: LD_INT 1
102663: EQUAL
102664: AND
102665: IFFALSE 103143
// begin if group [ i ] in healers then
102667: LD_VAR 0 4
102671: PUSH
102672: LD_VAR 0 7
102676: ARRAY
102677: PUSH
102678: LD_VAR 0 31
102682: IN
102683: IFFALSE 102956
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
102685: LD_VAR 0 4
102689: PUSH
102690: LD_VAR 0 7
102694: ARRAY
102695: PPUSH
102696: LD_VAR 0 23
102700: PPUSH
102701: CALL_OW 308
102705: NOT
102706: PUSH
102707: LD_VAR 0 4
102711: PUSH
102712: LD_VAR 0 7
102716: ARRAY
102717: PPUSH
102718: CALL_OW 314
102722: NOT
102723: AND
102724: IFFALSE 102748
// ComMoveToArea ( group [ i ] , f_heal ) else
102726: LD_VAR 0 4
102730: PUSH
102731: LD_VAR 0 7
102735: ARRAY
102736: PPUSH
102737: LD_VAR 0 23
102741: PPUSH
102742: CALL_OW 113
102746: GO 102954
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
102748: LD_VAR 0 4
102752: PUSH
102753: LD_VAR 0 7
102757: ARRAY
102758: PPUSH
102759: CALL 48806 0 1
102763: PPUSH
102764: CALL_OW 256
102768: PUSH
102769: LD_INT 1000
102771: EQUAL
102772: IFFALSE 102791
// ComStop ( group [ i ] ) else
102774: LD_VAR 0 4
102778: PUSH
102779: LD_VAR 0 7
102783: ARRAY
102784: PPUSH
102785: CALL_OW 141
102789: GO 102954
// if not HasTask ( group [ i ] ) and to_heal then
102791: LD_VAR 0 4
102795: PUSH
102796: LD_VAR 0 7
102800: ARRAY
102801: PPUSH
102802: CALL_OW 314
102806: NOT
102807: PUSH
102808: LD_VAR 0 30
102812: AND
102813: IFFALSE 102954
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
102815: LD_ADDR_VAR 0 13
102819: PUSH
102820: LD_VAR 0 30
102824: PPUSH
102825: LD_INT 3
102827: PUSH
102828: LD_INT 54
102830: PUSH
102831: EMPTY
102832: LIST
102833: PUSH
102834: EMPTY
102835: LIST
102836: LIST
102837: PPUSH
102838: CALL_OW 72
102842: PPUSH
102843: LD_VAR 0 4
102847: PUSH
102848: LD_VAR 0 7
102852: ARRAY
102853: PPUSH
102854: CALL_OW 74
102858: ST_TO_ADDR
// if z then
102859: LD_VAR 0 13
102863: IFFALSE 102954
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
102865: LD_INT 91
102867: PUSH
102868: LD_VAR 0 13
102872: PUSH
102873: LD_INT 10
102875: PUSH
102876: EMPTY
102877: LIST
102878: LIST
102879: LIST
102880: PUSH
102881: LD_INT 81
102883: PUSH
102884: LD_VAR 0 13
102888: PPUSH
102889: CALL_OW 255
102893: PUSH
102894: EMPTY
102895: LIST
102896: LIST
102897: PUSH
102898: EMPTY
102899: LIST
102900: LIST
102901: PPUSH
102902: CALL_OW 69
102906: PUSH
102907: LD_INT 0
102909: EQUAL
102910: IFFALSE 102934
// ComHeal ( group [ i ] , z ) else
102912: LD_VAR 0 4
102916: PUSH
102917: LD_VAR 0 7
102921: ARRAY
102922: PPUSH
102923: LD_VAR 0 13
102927: PPUSH
102928: CALL_OW 128
102932: GO 102954
// ComMoveToArea ( group [ i ] , f_heal ) ;
102934: LD_VAR 0 4
102938: PUSH
102939: LD_VAR 0 7
102943: ARRAY
102944: PPUSH
102945: LD_VAR 0 23
102949: PPUSH
102950: CALL_OW 113
// end ; continue ;
102954: GO 101985
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
102956: LD_VAR 0 4
102960: PUSH
102961: LD_VAR 0 7
102965: ARRAY
102966: PPUSH
102967: CALL_OW 256
102971: PUSH
102972: LD_INT 700
102974: LESS
102975: PUSH
102976: LD_VAR 0 4
102980: PUSH
102981: LD_VAR 0 7
102985: ARRAY
102986: PUSH
102987: LD_VAR 0 30
102991: IN
102992: NOT
102993: AND
102994: IFFALSE 103018
// to_heal := to_heal union group [ i ] ;
102996: LD_ADDR_VAR 0 30
103000: PUSH
103001: LD_VAR 0 30
103005: PUSH
103006: LD_VAR 0 4
103010: PUSH
103011: LD_VAR 0 7
103015: ARRAY
103016: UNION
103017: ST_TO_ADDR
// if group [ i ] in to_heal then
103018: LD_VAR 0 4
103022: PUSH
103023: LD_VAR 0 7
103027: ARRAY
103028: PUSH
103029: LD_VAR 0 30
103033: IN
103034: IFFALSE 103143
// begin if GetLives ( group [ i ] ) = 1000 then
103036: LD_VAR 0 4
103040: PUSH
103041: LD_VAR 0 7
103045: ARRAY
103046: PPUSH
103047: CALL_OW 256
103051: PUSH
103052: LD_INT 1000
103054: EQUAL
103055: IFFALSE 103081
// to_heal := to_heal diff group [ i ] else
103057: LD_ADDR_VAR 0 30
103061: PUSH
103062: LD_VAR 0 30
103066: PUSH
103067: LD_VAR 0 4
103071: PUSH
103072: LD_VAR 0 7
103076: ARRAY
103077: DIFF
103078: ST_TO_ADDR
103079: GO 103143
// begin if not IsInArea ( group [ i ] , to_heal ) then
103081: LD_VAR 0 4
103085: PUSH
103086: LD_VAR 0 7
103090: ARRAY
103091: PPUSH
103092: LD_VAR 0 30
103096: PPUSH
103097: CALL_OW 308
103101: NOT
103102: IFFALSE 103126
// ComMoveToArea ( group [ i ] , f_heal ) else
103104: LD_VAR 0 4
103108: PUSH
103109: LD_VAR 0 7
103113: ARRAY
103114: PPUSH
103115: LD_VAR 0 23
103119: PPUSH
103120: CALL_OW 113
103124: GO 103141
// ComHold ( group [ i ] ) ;
103126: LD_VAR 0 4
103130: PUSH
103131: LD_VAR 0 7
103135: ARRAY
103136: PPUSH
103137: CALL_OW 140
// continue ;
103141: GO 101985
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
103143: LD_VAR 0 4
103147: PUSH
103148: LD_VAR 0 7
103152: ARRAY
103153: PPUSH
103154: LD_INT 10
103156: PPUSH
103157: CALL 47226 0 2
103161: NOT
103162: PUSH
103163: LD_VAR 0 16
103167: PUSH
103168: LD_VAR 0 7
103172: ARRAY
103173: PUSH
103174: EMPTY
103175: EQUAL
103176: NOT
103177: AND
103178: IFFALSE 103444
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
103180: LD_VAR 0 4
103184: PUSH
103185: LD_VAR 0 7
103189: ARRAY
103190: PPUSH
103191: CALL_OW 262
103195: PUSH
103196: LD_INT 1
103198: PUSH
103199: LD_INT 2
103201: PUSH
103202: EMPTY
103203: LIST
103204: LIST
103205: IN
103206: IFFALSE 103247
// if GetFuel ( group [ i ] ) < 10 then
103208: LD_VAR 0 4
103212: PUSH
103213: LD_VAR 0 7
103217: ARRAY
103218: PPUSH
103219: CALL_OW 261
103223: PUSH
103224: LD_INT 10
103226: LESS
103227: IFFALSE 103247
// SetFuel ( group [ i ] , 12 ) ;
103229: LD_VAR 0 4
103233: PUSH
103234: LD_VAR 0 7
103238: ARRAY
103239: PPUSH
103240: LD_INT 12
103242: PPUSH
103243: CALL_OW 240
// if units_path [ i ] then
103247: LD_VAR 0 16
103251: PUSH
103252: LD_VAR 0 7
103256: ARRAY
103257: IFFALSE 103442
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
103259: LD_VAR 0 4
103263: PUSH
103264: LD_VAR 0 7
103268: ARRAY
103269: PPUSH
103270: LD_VAR 0 16
103274: PUSH
103275: LD_VAR 0 7
103279: ARRAY
103280: PUSH
103281: LD_INT 1
103283: ARRAY
103284: PUSH
103285: LD_INT 1
103287: ARRAY
103288: PPUSH
103289: LD_VAR 0 16
103293: PUSH
103294: LD_VAR 0 7
103298: ARRAY
103299: PUSH
103300: LD_INT 1
103302: ARRAY
103303: PUSH
103304: LD_INT 2
103306: ARRAY
103307: PPUSH
103308: CALL_OW 297
103312: PUSH
103313: LD_INT 6
103315: GREATER
103316: IFFALSE 103391
// begin if not HasTask ( group [ i ] ) then
103318: LD_VAR 0 4
103322: PUSH
103323: LD_VAR 0 7
103327: ARRAY
103328: PPUSH
103329: CALL_OW 314
103333: NOT
103334: IFFALSE 103389
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
103336: LD_VAR 0 4
103340: PUSH
103341: LD_VAR 0 7
103345: ARRAY
103346: PPUSH
103347: LD_VAR 0 16
103351: PUSH
103352: LD_VAR 0 7
103356: ARRAY
103357: PUSH
103358: LD_INT 1
103360: ARRAY
103361: PUSH
103362: LD_INT 1
103364: ARRAY
103365: PPUSH
103366: LD_VAR 0 16
103370: PUSH
103371: LD_VAR 0 7
103375: ARRAY
103376: PUSH
103377: LD_INT 1
103379: ARRAY
103380: PUSH
103381: LD_INT 2
103383: ARRAY
103384: PPUSH
103385: CALL_OW 114
// end else
103389: GO 103442
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
103391: LD_ADDR_VAR 0 15
103395: PUSH
103396: LD_VAR 0 16
103400: PUSH
103401: LD_VAR 0 7
103405: ARRAY
103406: PPUSH
103407: LD_INT 1
103409: PPUSH
103410: CALL_OW 3
103414: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
103415: LD_ADDR_VAR 0 16
103419: PUSH
103420: LD_VAR 0 16
103424: PPUSH
103425: LD_VAR 0 7
103429: PPUSH
103430: LD_VAR 0 15
103434: PPUSH
103435: CALL_OW 1
103439: ST_TO_ADDR
// continue ;
103440: GO 101985
// end ; end ; end else
103442: GO 106106
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
103444: LD_ADDR_VAR 0 14
103448: PUSH
103449: LD_INT 81
103451: PUSH
103452: LD_VAR 0 4
103456: PUSH
103457: LD_VAR 0 7
103461: ARRAY
103462: PPUSH
103463: CALL_OW 255
103467: PUSH
103468: EMPTY
103469: LIST
103470: LIST
103471: PPUSH
103472: CALL_OW 69
103476: ST_TO_ADDR
// if not tmp then
103477: LD_VAR 0 14
103481: NOT
103482: IFFALSE 103486
// continue ;
103484: GO 101985
// if f_ignore_area then
103486: LD_VAR 0 17
103490: IFFALSE 103578
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
103492: LD_ADDR_VAR 0 15
103496: PUSH
103497: LD_VAR 0 14
103501: PPUSH
103502: LD_INT 3
103504: PUSH
103505: LD_INT 92
103507: PUSH
103508: LD_VAR 0 17
103512: PUSH
103513: LD_INT 1
103515: ARRAY
103516: PUSH
103517: LD_VAR 0 17
103521: PUSH
103522: LD_INT 2
103524: ARRAY
103525: PUSH
103526: LD_VAR 0 17
103530: PUSH
103531: LD_INT 3
103533: ARRAY
103534: PUSH
103535: EMPTY
103536: LIST
103537: LIST
103538: LIST
103539: LIST
103540: PUSH
103541: EMPTY
103542: LIST
103543: LIST
103544: PPUSH
103545: CALL_OW 72
103549: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
103550: LD_VAR 0 14
103554: PUSH
103555: LD_VAR 0 15
103559: DIFF
103560: IFFALSE 103578
// tmp := tmp diff tmp2 ;
103562: LD_ADDR_VAR 0 14
103566: PUSH
103567: LD_VAR 0 14
103571: PUSH
103572: LD_VAR 0 15
103576: DIFF
103577: ST_TO_ADDR
// end ; if not f_murder then
103578: LD_VAR 0 20
103582: NOT
103583: IFFALSE 103641
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
103585: LD_ADDR_VAR 0 15
103589: PUSH
103590: LD_VAR 0 14
103594: PPUSH
103595: LD_INT 3
103597: PUSH
103598: LD_INT 50
103600: PUSH
103601: EMPTY
103602: LIST
103603: PUSH
103604: EMPTY
103605: LIST
103606: LIST
103607: PPUSH
103608: CALL_OW 72
103612: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
103613: LD_VAR 0 14
103617: PUSH
103618: LD_VAR 0 15
103622: DIFF
103623: IFFALSE 103641
// tmp := tmp diff tmp2 ;
103625: LD_ADDR_VAR 0 14
103629: PUSH
103630: LD_VAR 0 14
103634: PUSH
103635: LD_VAR 0 15
103639: DIFF
103640: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
103641: LD_ADDR_VAR 0 14
103645: PUSH
103646: LD_VAR 0 4
103650: PUSH
103651: LD_VAR 0 7
103655: ARRAY
103656: PPUSH
103657: LD_VAR 0 14
103661: PPUSH
103662: LD_INT 1
103664: PPUSH
103665: LD_INT 1
103667: PPUSH
103668: CALL 20161 0 4
103672: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
103673: LD_VAR 0 4
103677: PUSH
103678: LD_VAR 0 7
103682: ARRAY
103683: PPUSH
103684: CALL_OW 257
103688: PUSH
103689: LD_INT 1
103691: EQUAL
103692: IFFALSE 104140
// begin if WantPlant ( group [ i ] ) then
103694: LD_VAR 0 4
103698: PUSH
103699: LD_VAR 0 7
103703: ARRAY
103704: PPUSH
103705: CALL 19662 0 1
103709: IFFALSE 103713
// continue ;
103711: GO 101985
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
103713: LD_VAR 0 18
103717: PUSH
103718: LD_VAR 0 4
103722: PUSH
103723: LD_VAR 0 7
103727: ARRAY
103728: PPUSH
103729: CALL_OW 310
103733: NOT
103734: AND
103735: PUSH
103736: LD_VAR 0 14
103740: PUSH
103741: LD_INT 1
103743: ARRAY
103744: PUSH
103745: LD_VAR 0 14
103749: PPUSH
103750: LD_INT 21
103752: PUSH
103753: LD_INT 2
103755: PUSH
103756: EMPTY
103757: LIST
103758: LIST
103759: PUSH
103760: LD_INT 58
103762: PUSH
103763: EMPTY
103764: LIST
103765: PUSH
103766: EMPTY
103767: LIST
103768: LIST
103769: PPUSH
103770: CALL_OW 72
103774: IN
103775: AND
103776: IFFALSE 103812
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
103778: LD_VAR 0 4
103782: PUSH
103783: LD_VAR 0 7
103787: ARRAY
103788: PPUSH
103789: LD_VAR 0 14
103793: PUSH
103794: LD_INT 1
103796: ARRAY
103797: PPUSH
103798: CALL_OW 120
// attacking := true ;
103802: LD_ADDR_VAR 0 29
103806: PUSH
103807: LD_INT 1
103809: ST_TO_ADDR
// continue ;
103810: GO 101985
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
103812: LD_VAR 0 26
103816: PUSH
103817: LD_VAR 0 4
103821: PUSH
103822: LD_VAR 0 7
103826: ARRAY
103827: PPUSH
103828: CALL_OW 257
103832: PUSH
103833: LD_INT 1
103835: EQUAL
103836: AND
103837: PUSH
103838: LD_VAR 0 4
103842: PUSH
103843: LD_VAR 0 7
103847: ARRAY
103848: PPUSH
103849: CALL_OW 256
103853: PUSH
103854: LD_INT 800
103856: LESS
103857: AND
103858: PUSH
103859: LD_VAR 0 4
103863: PUSH
103864: LD_VAR 0 7
103868: ARRAY
103869: PPUSH
103870: CALL_OW 318
103874: NOT
103875: AND
103876: IFFALSE 103893
// ComCrawl ( group [ i ] ) ;
103878: LD_VAR 0 4
103882: PUSH
103883: LD_VAR 0 7
103887: ARRAY
103888: PPUSH
103889: CALL_OW 137
// if f_mines then
103893: LD_VAR 0 21
103897: IFFALSE 104140
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
103899: LD_VAR 0 14
103903: PUSH
103904: LD_INT 1
103906: ARRAY
103907: PPUSH
103908: CALL_OW 247
103912: PUSH
103913: LD_INT 3
103915: EQUAL
103916: PUSH
103917: LD_VAR 0 14
103921: PUSH
103922: LD_INT 1
103924: ARRAY
103925: PUSH
103926: LD_VAR 0 27
103930: IN
103931: NOT
103932: AND
103933: IFFALSE 104140
// begin x := GetX ( tmp [ 1 ] ) ;
103935: LD_ADDR_VAR 0 10
103939: PUSH
103940: LD_VAR 0 14
103944: PUSH
103945: LD_INT 1
103947: ARRAY
103948: PPUSH
103949: CALL_OW 250
103953: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
103954: LD_ADDR_VAR 0 11
103958: PUSH
103959: LD_VAR 0 14
103963: PUSH
103964: LD_INT 1
103966: ARRAY
103967: PPUSH
103968: CALL_OW 251
103972: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
103973: LD_ADDR_VAR 0 12
103977: PUSH
103978: LD_VAR 0 4
103982: PUSH
103983: LD_VAR 0 7
103987: ARRAY
103988: PPUSH
103989: CALL 47311 0 1
103993: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
103994: LD_VAR 0 4
103998: PUSH
103999: LD_VAR 0 7
104003: ARRAY
104004: PPUSH
104005: LD_VAR 0 10
104009: PPUSH
104010: LD_VAR 0 11
104014: PPUSH
104015: LD_VAR 0 14
104019: PUSH
104020: LD_INT 1
104022: ARRAY
104023: PPUSH
104024: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
104028: LD_VAR 0 4
104032: PUSH
104033: LD_VAR 0 7
104037: ARRAY
104038: PPUSH
104039: LD_VAR 0 10
104043: PPUSH
104044: LD_VAR 0 12
104048: PPUSH
104049: LD_INT 7
104051: PPUSH
104052: CALL_OW 272
104056: PPUSH
104057: LD_VAR 0 11
104061: PPUSH
104062: LD_VAR 0 12
104066: PPUSH
104067: LD_INT 7
104069: PPUSH
104070: CALL_OW 273
104074: PPUSH
104075: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
104079: LD_VAR 0 4
104083: PUSH
104084: LD_VAR 0 7
104088: ARRAY
104089: PPUSH
104090: LD_INT 71
104092: PPUSH
104093: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
104097: LD_ADDR_VAR 0 27
104101: PUSH
104102: LD_VAR 0 27
104106: PPUSH
104107: LD_VAR 0 27
104111: PUSH
104112: LD_INT 1
104114: PLUS
104115: PPUSH
104116: LD_VAR 0 14
104120: PUSH
104121: LD_INT 1
104123: ARRAY
104124: PPUSH
104125: CALL_OW 1
104129: ST_TO_ADDR
// attacking := true ;
104130: LD_ADDR_VAR 0 29
104134: PUSH
104135: LD_INT 1
104137: ST_TO_ADDR
// continue ;
104138: GO 101985
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
104140: LD_VAR 0 4
104144: PUSH
104145: LD_VAR 0 7
104149: ARRAY
104150: PPUSH
104151: CALL_OW 257
104155: PUSH
104156: LD_INT 17
104158: EQUAL
104159: PUSH
104160: LD_VAR 0 4
104164: PUSH
104165: LD_VAR 0 7
104169: ARRAY
104170: PPUSH
104171: CALL_OW 110
104175: PUSH
104176: LD_INT 71
104178: EQUAL
104179: NOT
104180: AND
104181: IFFALSE 104327
// begin attacking := false ;
104183: LD_ADDR_VAR 0 29
104187: PUSH
104188: LD_INT 0
104190: ST_TO_ADDR
// k := 5 ;
104191: LD_ADDR_VAR 0 9
104195: PUSH
104196: LD_INT 5
104198: ST_TO_ADDR
// if tmp < k then
104199: LD_VAR 0 14
104203: PUSH
104204: LD_VAR 0 9
104208: LESS
104209: IFFALSE 104221
// k := tmp ;
104211: LD_ADDR_VAR 0 9
104215: PUSH
104216: LD_VAR 0 14
104220: ST_TO_ADDR
// for j = 1 to k do
104221: LD_ADDR_VAR 0 8
104225: PUSH
104226: DOUBLE
104227: LD_INT 1
104229: DEC
104230: ST_TO_ADDR
104231: LD_VAR 0 9
104235: PUSH
104236: FOR_TO
104237: IFFALSE 104325
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
104239: LD_VAR 0 14
104243: PUSH
104244: LD_VAR 0 8
104248: ARRAY
104249: PUSH
104250: LD_VAR 0 14
104254: PPUSH
104255: LD_INT 58
104257: PUSH
104258: EMPTY
104259: LIST
104260: PPUSH
104261: CALL_OW 72
104265: IN
104266: NOT
104267: IFFALSE 104323
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104269: LD_VAR 0 4
104273: PUSH
104274: LD_VAR 0 7
104278: ARRAY
104279: PPUSH
104280: LD_VAR 0 14
104284: PUSH
104285: LD_VAR 0 8
104289: ARRAY
104290: PPUSH
104291: CALL_OW 115
// attacking := true ;
104295: LD_ADDR_VAR 0 29
104299: PUSH
104300: LD_INT 1
104302: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
104303: LD_VAR 0 4
104307: PUSH
104308: LD_VAR 0 7
104312: ARRAY
104313: PPUSH
104314: LD_INT 71
104316: PPUSH
104317: CALL_OW 109
// continue ;
104321: GO 104236
// end ; end ;
104323: GO 104236
104325: POP
104326: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
104327: LD_VAR 0 4
104331: PUSH
104332: LD_VAR 0 7
104336: ARRAY
104337: PPUSH
104338: CALL_OW 257
104342: PUSH
104343: LD_INT 8
104345: EQUAL
104346: PUSH
104347: LD_VAR 0 4
104351: PUSH
104352: LD_VAR 0 7
104356: ARRAY
104357: PPUSH
104358: CALL_OW 264
104362: PUSH
104363: LD_INT 28
104365: PUSH
104366: LD_INT 45
104368: PUSH
104369: LD_INT 7
104371: PUSH
104372: LD_INT 47
104374: PUSH
104375: EMPTY
104376: LIST
104377: LIST
104378: LIST
104379: LIST
104380: IN
104381: OR
104382: IFFALSE 104638
// begin attacking := false ;
104384: LD_ADDR_VAR 0 29
104388: PUSH
104389: LD_INT 0
104391: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
104392: LD_VAR 0 14
104396: PUSH
104397: LD_INT 1
104399: ARRAY
104400: PPUSH
104401: CALL_OW 266
104405: PUSH
104406: LD_INT 32
104408: PUSH
104409: LD_INT 31
104411: PUSH
104412: LD_INT 33
104414: PUSH
104415: LD_INT 4
104417: PUSH
104418: LD_INT 5
104420: PUSH
104421: EMPTY
104422: LIST
104423: LIST
104424: LIST
104425: LIST
104426: LIST
104427: IN
104428: IFFALSE 104614
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
104430: LD_ADDR_VAR 0 9
104434: PUSH
104435: LD_VAR 0 14
104439: PUSH
104440: LD_INT 1
104442: ARRAY
104443: PPUSH
104444: CALL_OW 266
104448: PPUSH
104449: LD_VAR 0 14
104453: PUSH
104454: LD_INT 1
104456: ARRAY
104457: PPUSH
104458: CALL_OW 250
104462: PPUSH
104463: LD_VAR 0 14
104467: PUSH
104468: LD_INT 1
104470: ARRAY
104471: PPUSH
104472: CALL_OW 251
104476: PPUSH
104477: LD_VAR 0 14
104481: PUSH
104482: LD_INT 1
104484: ARRAY
104485: PPUSH
104486: CALL_OW 254
104490: PPUSH
104491: LD_VAR 0 14
104495: PUSH
104496: LD_INT 1
104498: ARRAY
104499: PPUSH
104500: CALL_OW 248
104504: PPUSH
104505: LD_INT 0
104507: PPUSH
104508: CALL 28681 0 6
104512: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
104513: LD_ADDR_VAR 0 8
104517: PUSH
104518: LD_VAR 0 4
104522: PUSH
104523: LD_VAR 0 7
104527: ARRAY
104528: PPUSH
104529: LD_VAR 0 9
104533: PPUSH
104534: CALL 47351 0 2
104538: ST_TO_ADDR
// if j then
104539: LD_VAR 0 8
104543: IFFALSE 104612
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
104545: LD_VAR 0 8
104549: PUSH
104550: LD_INT 1
104552: ARRAY
104553: PPUSH
104554: LD_VAR 0 8
104558: PUSH
104559: LD_INT 2
104561: ARRAY
104562: PPUSH
104563: CALL_OW 488
104567: IFFALSE 104612
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
104569: LD_VAR 0 4
104573: PUSH
104574: LD_VAR 0 7
104578: ARRAY
104579: PPUSH
104580: LD_VAR 0 8
104584: PUSH
104585: LD_INT 1
104587: ARRAY
104588: PPUSH
104589: LD_VAR 0 8
104593: PUSH
104594: LD_INT 2
104596: ARRAY
104597: PPUSH
104598: CALL_OW 116
// attacking := true ;
104602: LD_ADDR_VAR 0 29
104606: PUSH
104607: LD_INT 1
104609: ST_TO_ADDR
// continue ;
104610: GO 101985
// end ; end else
104612: GO 104638
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104614: LD_VAR 0 4
104618: PUSH
104619: LD_VAR 0 7
104623: ARRAY
104624: PPUSH
104625: LD_VAR 0 14
104629: PUSH
104630: LD_INT 1
104632: ARRAY
104633: PPUSH
104634: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
104638: LD_VAR 0 4
104642: PUSH
104643: LD_VAR 0 7
104647: ARRAY
104648: PPUSH
104649: CALL_OW 265
104653: PUSH
104654: LD_INT 11
104656: EQUAL
104657: IFFALSE 104935
// begin k := 10 ;
104659: LD_ADDR_VAR 0 9
104663: PUSH
104664: LD_INT 10
104666: ST_TO_ADDR
// x := 0 ;
104667: LD_ADDR_VAR 0 10
104671: PUSH
104672: LD_INT 0
104674: ST_TO_ADDR
// if tmp < k then
104675: LD_VAR 0 14
104679: PUSH
104680: LD_VAR 0 9
104684: LESS
104685: IFFALSE 104697
// k := tmp ;
104687: LD_ADDR_VAR 0 9
104691: PUSH
104692: LD_VAR 0 14
104696: ST_TO_ADDR
// for j = k downto 1 do
104697: LD_ADDR_VAR 0 8
104701: PUSH
104702: DOUBLE
104703: LD_VAR 0 9
104707: INC
104708: ST_TO_ADDR
104709: LD_INT 1
104711: PUSH
104712: FOR_DOWNTO
104713: IFFALSE 104788
// begin if GetType ( tmp [ j ] ) = unit_human then
104715: LD_VAR 0 14
104719: PUSH
104720: LD_VAR 0 8
104724: ARRAY
104725: PPUSH
104726: CALL_OW 247
104730: PUSH
104731: LD_INT 1
104733: EQUAL
104734: IFFALSE 104786
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
104736: LD_VAR 0 4
104740: PUSH
104741: LD_VAR 0 7
104745: ARRAY
104746: PPUSH
104747: LD_VAR 0 14
104751: PUSH
104752: LD_VAR 0 8
104756: ARRAY
104757: PPUSH
104758: CALL 47622 0 2
// x := tmp [ j ] ;
104762: LD_ADDR_VAR 0 10
104766: PUSH
104767: LD_VAR 0 14
104771: PUSH
104772: LD_VAR 0 8
104776: ARRAY
104777: ST_TO_ADDR
// attacking := true ;
104778: LD_ADDR_VAR 0 29
104782: PUSH
104783: LD_INT 1
104785: ST_TO_ADDR
// end ; end ;
104786: GO 104712
104788: POP
104789: POP
// if not x then
104790: LD_VAR 0 10
104794: NOT
104795: IFFALSE 104935
// begin attacking := true ;
104797: LD_ADDR_VAR 0 29
104801: PUSH
104802: LD_INT 1
104804: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
104805: LD_VAR 0 4
104809: PUSH
104810: LD_VAR 0 7
104814: ARRAY
104815: PPUSH
104816: CALL_OW 250
104820: PPUSH
104821: LD_VAR 0 4
104825: PUSH
104826: LD_VAR 0 7
104830: ARRAY
104831: PPUSH
104832: CALL_OW 251
104836: PPUSH
104837: CALL_OW 546
104841: PUSH
104842: LD_INT 2
104844: ARRAY
104845: PUSH
104846: LD_VAR 0 14
104850: PUSH
104851: LD_INT 1
104853: ARRAY
104854: PPUSH
104855: CALL_OW 250
104859: PPUSH
104860: LD_VAR 0 14
104864: PUSH
104865: LD_INT 1
104867: ARRAY
104868: PPUSH
104869: CALL_OW 251
104873: PPUSH
104874: CALL_OW 546
104878: PUSH
104879: LD_INT 2
104881: ARRAY
104882: EQUAL
104883: IFFALSE 104911
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
104885: LD_VAR 0 4
104889: PUSH
104890: LD_VAR 0 7
104894: ARRAY
104895: PPUSH
104896: LD_VAR 0 14
104900: PUSH
104901: LD_INT 1
104903: ARRAY
104904: PPUSH
104905: CALL 47622 0 2
104909: GO 104935
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104911: LD_VAR 0 4
104915: PUSH
104916: LD_VAR 0 7
104920: ARRAY
104921: PPUSH
104922: LD_VAR 0 14
104926: PUSH
104927: LD_INT 1
104929: ARRAY
104930: PPUSH
104931: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
104935: LD_VAR 0 4
104939: PUSH
104940: LD_VAR 0 7
104944: ARRAY
104945: PPUSH
104946: CALL_OW 264
104950: PUSH
104951: LD_INT 29
104953: EQUAL
104954: IFFALSE 105320
// begin if WantsToAttack ( group [ i ] ) in bombed then
104956: LD_VAR 0 4
104960: PUSH
104961: LD_VAR 0 7
104965: ARRAY
104966: PPUSH
104967: CALL_OW 319
104971: PUSH
104972: LD_VAR 0 28
104976: IN
104977: IFFALSE 104981
// continue ;
104979: GO 101985
// k := 8 ;
104981: LD_ADDR_VAR 0 9
104985: PUSH
104986: LD_INT 8
104988: ST_TO_ADDR
// x := 0 ;
104989: LD_ADDR_VAR 0 10
104993: PUSH
104994: LD_INT 0
104996: ST_TO_ADDR
// if tmp < k then
104997: LD_VAR 0 14
105001: PUSH
105002: LD_VAR 0 9
105006: LESS
105007: IFFALSE 105019
// k := tmp ;
105009: LD_ADDR_VAR 0 9
105013: PUSH
105014: LD_VAR 0 14
105018: ST_TO_ADDR
// for j = 1 to k do
105019: LD_ADDR_VAR 0 8
105023: PUSH
105024: DOUBLE
105025: LD_INT 1
105027: DEC
105028: ST_TO_ADDR
105029: LD_VAR 0 9
105033: PUSH
105034: FOR_TO
105035: IFFALSE 105167
// begin if GetType ( tmp [ j ] ) = unit_building then
105037: LD_VAR 0 14
105041: PUSH
105042: LD_VAR 0 8
105046: ARRAY
105047: PPUSH
105048: CALL_OW 247
105052: PUSH
105053: LD_INT 3
105055: EQUAL
105056: IFFALSE 105165
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
105058: LD_VAR 0 14
105062: PUSH
105063: LD_VAR 0 8
105067: ARRAY
105068: PUSH
105069: LD_VAR 0 28
105073: IN
105074: NOT
105075: PUSH
105076: LD_VAR 0 14
105080: PUSH
105081: LD_VAR 0 8
105085: ARRAY
105086: PPUSH
105087: CALL_OW 313
105091: AND
105092: IFFALSE 105165
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105094: LD_VAR 0 4
105098: PUSH
105099: LD_VAR 0 7
105103: ARRAY
105104: PPUSH
105105: LD_VAR 0 14
105109: PUSH
105110: LD_VAR 0 8
105114: ARRAY
105115: PPUSH
105116: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
105120: LD_ADDR_VAR 0 28
105124: PUSH
105125: LD_VAR 0 28
105129: PPUSH
105130: LD_VAR 0 28
105134: PUSH
105135: LD_INT 1
105137: PLUS
105138: PPUSH
105139: LD_VAR 0 14
105143: PUSH
105144: LD_VAR 0 8
105148: ARRAY
105149: PPUSH
105150: CALL_OW 1
105154: ST_TO_ADDR
// attacking := true ;
105155: LD_ADDR_VAR 0 29
105159: PUSH
105160: LD_INT 1
105162: ST_TO_ADDR
// break ;
105163: GO 105167
// end ; end ;
105165: GO 105034
105167: POP
105168: POP
// if not attacking and f_attack_depot then
105169: LD_VAR 0 29
105173: NOT
105174: PUSH
105175: LD_VAR 0 25
105179: AND
105180: IFFALSE 105275
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
105182: LD_ADDR_VAR 0 13
105186: PUSH
105187: LD_VAR 0 14
105191: PPUSH
105192: LD_INT 2
105194: PUSH
105195: LD_INT 30
105197: PUSH
105198: LD_INT 0
105200: PUSH
105201: EMPTY
105202: LIST
105203: LIST
105204: PUSH
105205: LD_INT 30
105207: PUSH
105208: LD_INT 1
105210: PUSH
105211: EMPTY
105212: LIST
105213: LIST
105214: PUSH
105215: EMPTY
105216: LIST
105217: LIST
105218: LIST
105219: PPUSH
105220: CALL_OW 72
105224: ST_TO_ADDR
// if z then
105225: LD_VAR 0 13
105229: IFFALSE 105275
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
105231: LD_VAR 0 4
105235: PUSH
105236: LD_VAR 0 7
105240: ARRAY
105241: PPUSH
105242: LD_VAR 0 13
105246: PPUSH
105247: LD_VAR 0 4
105251: PUSH
105252: LD_VAR 0 7
105256: ARRAY
105257: PPUSH
105258: CALL_OW 74
105262: PPUSH
105263: CALL_OW 115
// attacking := true ;
105267: LD_ADDR_VAR 0 29
105271: PUSH
105272: LD_INT 1
105274: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
105275: LD_VAR 0 4
105279: PUSH
105280: LD_VAR 0 7
105284: ARRAY
105285: PPUSH
105286: CALL_OW 256
105290: PUSH
105291: LD_INT 500
105293: LESS
105294: IFFALSE 105320
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105296: LD_VAR 0 4
105300: PUSH
105301: LD_VAR 0 7
105305: ARRAY
105306: PPUSH
105307: LD_VAR 0 14
105311: PUSH
105312: LD_INT 1
105314: ARRAY
105315: PPUSH
105316: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
105320: LD_VAR 0 4
105324: PUSH
105325: LD_VAR 0 7
105329: ARRAY
105330: PPUSH
105331: CALL_OW 264
105335: PUSH
105336: LD_INT 49
105338: EQUAL
105339: IFFALSE 105460
// begin if not HasTask ( group [ i ] ) then
105341: LD_VAR 0 4
105345: PUSH
105346: LD_VAR 0 7
105350: ARRAY
105351: PPUSH
105352: CALL_OW 314
105356: NOT
105357: IFFALSE 105460
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
105359: LD_ADDR_VAR 0 9
105363: PUSH
105364: LD_INT 81
105366: PUSH
105367: LD_VAR 0 4
105371: PUSH
105372: LD_VAR 0 7
105376: ARRAY
105377: PPUSH
105378: CALL_OW 255
105382: PUSH
105383: EMPTY
105384: LIST
105385: LIST
105386: PPUSH
105387: CALL_OW 69
105391: PPUSH
105392: LD_VAR 0 4
105396: PUSH
105397: LD_VAR 0 7
105401: ARRAY
105402: PPUSH
105403: CALL_OW 74
105407: ST_TO_ADDR
// if k then
105408: LD_VAR 0 9
105412: IFFALSE 105460
// if GetDistUnits ( group [ i ] , k ) > 10 then
105414: LD_VAR 0 4
105418: PUSH
105419: LD_VAR 0 7
105423: ARRAY
105424: PPUSH
105425: LD_VAR 0 9
105429: PPUSH
105430: CALL_OW 296
105434: PUSH
105435: LD_INT 10
105437: GREATER
105438: IFFALSE 105460
// ComMoveUnit ( group [ i ] , k ) ;
105440: LD_VAR 0 4
105444: PUSH
105445: LD_VAR 0 7
105449: ARRAY
105450: PPUSH
105451: LD_VAR 0 9
105455: PPUSH
105456: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
105460: LD_VAR 0 4
105464: PUSH
105465: LD_VAR 0 7
105469: ARRAY
105470: PPUSH
105471: CALL_OW 256
105475: PUSH
105476: LD_INT 250
105478: LESS
105479: PUSH
105480: LD_VAR 0 4
105484: PUSH
105485: LD_VAR 0 7
105489: ARRAY
105490: PUSH
105491: LD_INT 21
105493: PUSH
105494: LD_INT 2
105496: PUSH
105497: EMPTY
105498: LIST
105499: LIST
105500: PUSH
105501: LD_INT 23
105503: PUSH
105504: LD_INT 2
105506: PUSH
105507: EMPTY
105508: LIST
105509: LIST
105510: PUSH
105511: EMPTY
105512: LIST
105513: LIST
105514: PPUSH
105515: CALL_OW 69
105519: IN
105520: AND
105521: IFFALSE 105646
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
105523: LD_ADDR_VAR 0 9
105527: PUSH
105528: LD_OWVAR 3
105532: PUSH
105533: LD_VAR 0 4
105537: PUSH
105538: LD_VAR 0 7
105542: ARRAY
105543: DIFF
105544: PPUSH
105545: LD_VAR 0 4
105549: PUSH
105550: LD_VAR 0 7
105554: ARRAY
105555: PPUSH
105556: CALL_OW 74
105560: ST_TO_ADDR
// if not k then
105561: LD_VAR 0 9
105565: NOT
105566: IFFALSE 105570
// continue ;
105568: GO 101985
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
105570: LD_VAR 0 9
105574: PUSH
105575: LD_INT 81
105577: PUSH
105578: LD_VAR 0 4
105582: PUSH
105583: LD_VAR 0 7
105587: ARRAY
105588: PPUSH
105589: CALL_OW 255
105593: PUSH
105594: EMPTY
105595: LIST
105596: LIST
105597: PPUSH
105598: CALL_OW 69
105602: IN
105603: PUSH
105604: LD_VAR 0 9
105608: PPUSH
105609: LD_VAR 0 4
105613: PUSH
105614: LD_VAR 0 7
105618: ARRAY
105619: PPUSH
105620: CALL_OW 296
105624: PUSH
105625: LD_INT 5
105627: LESS
105628: AND
105629: IFFALSE 105646
// ComAutodestruct ( group [ i ] ) ;
105631: LD_VAR 0 4
105635: PUSH
105636: LD_VAR 0 7
105640: ARRAY
105641: PPUSH
105642: CALL 47520 0 1
// end ; if f_attack_depot then
105646: LD_VAR 0 25
105650: IFFALSE 105762
// begin k := 6 ;
105652: LD_ADDR_VAR 0 9
105656: PUSH
105657: LD_INT 6
105659: ST_TO_ADDR
// if tmp < k then
105660: LD_VAR 0 14
105664: PUSH
105665: LD_VAR 0 9
105669: LESS
105670: IFFALSE 105682
// k := tmp ;
105672: LD_ADDR_VAR 0 9
105676: PUSH
105677: LD_VAR 0 14
105681: ST_TO_ADDR
// for j = 1 to k do
105682: LD_ADDR_VAR 0 8
105686: PUSH
105687: DOUBLE
105688: LD_INT 1
105690: DEC
105691: ST_TO_ADDR
105692: LD_VAR 0 9
105696: PUSH
105697: FOR_TO
105698: IFFALSE 105760
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
105700: LD_VAR 0 8
105704: PPUSH
105705: CALL_OW 266
105709: PUSH
105710: LD_INT 0
105712: PUSH
105713: LD_INT 1
105715: PUSH
105716: EMPTY
105717: LIST
105718: LIST
105719: IN
105720: IFFALSE 105758
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105722: LD_VAR 0 4
105726: PUSH
105727: LD_VAR 0 7
105731: ARRAY
105732: PPUSH
105733: LD_VAR 0 14
105737: PUSH
105738: LD_VAR 0 8
105742: ARRAY
105743: PPUSH
105744: CALL_OW 115
// attacking := true ;
105748: LD_ADDR_VAR 0 29
105752: PUSH
105753: LD_INT 1
105755: ST_TO_ADDR
// break ;
105756: GO 105760
// end ;
105758: GO 105697
105760: POP
105761: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
105762: LD_VAR 0 4
105766: PUSH
105767: LD_VAR 0 7
105771: ARRAY
105772: PPUSH
105773: CALL_OW 302
105777: PUSH
105778: LD_VAR 0 29
105782: NOT
105783: AND
105784: IFFALSE 106106
// begin if GetTag ( group [ i ] ) = 71 then
105786: LD_VAR 0 4
105790: PUSH
105791: LD_VAR 0 7
105795: ARRAY
105796: PPUSH
105797: CALL_OW 110
105801: PUSH
105802: LD_INT 71
105804: EQUAL
105805: IFFALSE 105846
// begin if HasTask ( group [ i ] ) then
105807: LD_VAR 0 4
105811: PUSH
105812: LD_VAR 0 7
105816: ARRAY
105817: PPUSH
105818: CALL_OW 314
105822: IFFALSE 105828
// continue else
105824: GO 101985
105826: GO 105846
// SetTag ( group [ i ] , 0 ) ;
105828: LD_VAR 0 4
105832: PUSH
105833: LD_VAR 0 7
105837: ARRAY
105838: PPUSH
105839: LD_INT 0
105841: PPUSH
105842: CALL_OW 109
// end ; k := 8 ;
105846: LD_ADDR_VAR 0 9
105850: PUSH
105851: LD_INT 8
105853: ST_TO_ADDR
// x := 0 ;
105854: LD_ADDR_VAR 0 10
105858: PUSH
105859: LD_INT 0
105861: ST_TO_ADDR
// if tmp < k then
105862: LD_VAR 0 14
105866: PUSH
105867: LD_VAR 0 9
105871: LESS
105872: IFFALSE 105884
// k := tmp ;
105874: LD_ADDR_VAR 0 9
105878: PUSH
105879: LD_VAR 0 14
105883: ST_TO_ADDR
// for j = 1 to k do
105884: LD_ADDR_VAR 0 8
105888: PUSH
105889: DOUBLE
105890: LD_INT 1
105892: DEC
105893: ST_TO_ADDR
105894: LD_VAR 0 9
105898: PUSH
105899: FOR_TO
105900: IFFALSE 105998
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
105902: LD_VAR 0 14
105906: PUSH
105907: LD_VAR 0 8
105911: ARRAY
105912: PPUSH
105913: CALL_OW 247
105917: PUSH
105918: LD_INT 1
105920: EQUAL
105921: PUSH
105922: LD_VAR 0 14
105926: PUSH
105927: LD_VAR 0 8
105931: ARRAY
105932: PPUSH
105933: CALL_OW 256
105937: PUSH
105938: LD_INT 250
105940: LESS
105941: PUSH
105942: LD_VAR 0 20
105946: AND
105947: PUSH
105948: LD_VAR 0 20
105952: NOT
105953: PUSH
105954: LD_VAR 0 14
105958: PUSH
105959: LD_VAR 0 8
105963: ARRAY
105964: PPUSH
105965: CALL_OW 256
105969: PUSH
105970: LD_INT 250
105972: GREATEREQUAL
105973: AND
105974: OR
105975: AND
105976: IFFALSE 105996
// begin x := tmp [ j ] ;
105978: LD_ADDR_VAR 0 10
105982: PUSH
105983: LD_VAR 0 14
105987: PUSH
105988: LD_VAR 0 8
105992: ARRAY
105993: ST_TO_ADDR
// break ;
105994: GO 105998
// end ;
105996: GO 105899
105998: POP
105999: POP
// if x then
106000: LD_VAR 0 10
106004: IFFALSE 106028
// ComAttackUnit ( group [ i ] , x ) else
106006: LD_VAR 0 4
106010: PUSH
106011: LD_VAR 0 7
106015: ARRAY
106016: PPUSH
106017: LD_VAR 0 10
106021: PPUSH
106022: CALL_OW 115
106026: GO 106052
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106028: LD_VAR 0 4
106032: PUSH
106033: LD_VAR 0 7
106037: ARRAY
106038: PPUSH
106039: LD_VAR 0 14
106043: PUSH
106044: LD_INT 1
106046: ARRAY
106047: PPUSH
106048: CALL_OW 115
// if not HasTask ( group [ i ] ) then
106052: LD_VAR 0 4
106056: PUSH
106057: LD_VAR 0 7
106061: ARRAY
106062: PPUSH
106063: CALL_OW 314
106067: NOT
106068: IFFALSE 106106
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
106070: LD_VAR 0 4
106074: PUSH
106075: LD_VAR 0 7
106079: ARRAY
106080: PPUSH
106081: LD_VAR 0 14
106085: PPUSH
106086: LD_VAR 0 4
106090: PUSH
106091: LD_VAR 0 7
106095: ARRAY
106096: PPUSH
106097: CALL_OW 74
106101: PPUSH
106102: CALL_OW 115
// end ; end ; end ;
106106: GO 101985
106108: POP
106109: POP
// wait ( 0 0$2 ) ;
106110: LD_INT 70
106112: PPUSH
106113: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
106117: LD_VAR 0 4
106121: NOT
106122: PUSH
106123: LD_VAR 0 4
106127: PUSH
106128: EMPTY
106129: EQUAL
106130: OR
106131: PUSH
106132: LD_INT 81
106134: PUSH
106135: LD_VAR 0 35
106139: PUSH
106140: EMPTY
106141: LIST
106142: LIST
106143: PPUSH
106144: CALL_OW 69
106148: NOT
106149: OR
106150: IFFALSE 101970
// end ;
106152: LD_VAR 0 2
106156: RET
// export function BasicDefend ( base , solds ) ; var enemy , side , i , hex ; begin
106157: LD_INT 0
106159: PPUSH
106160: PPUSH
106161: PPUSH
106162: PPUSH
106163: PPUSH
// if not base or not mc_bases [ base ] or not solds then
106164: LD_VAR 0 1
106168: NOT
106169: PUSH
106170: LD_EXP 59
106174: PUSH
106175: LD_VAR 0 1
106179: ARRAY
106180: NOT
106181: OR
106182: PUSH
106183: LD_VAR 0 2
106187: NOT
106188: OR
106189: IFFALSE 106193
// exit ;
106191: GO 106722
// side := mc_sides [ base ] ;
106193: LD_ADDR_VAR 0 5
106197: PUSH
106198: LD_EXP 85
106202: PUSH
106203: LD_VAR 0 1
106207: ARRAY
106208: ST_TO_ADDR
// if not side then
106209: LD_VAR 0 5
106213: NOT
106214: IFFALSE 106218
// exit ;
106216: GO 106722
// for i in solds do
106218: LD_ADDR_VAR 0 6
106222: PUSH
106223: LD_VAR 0 2
106227: PUSH
106228: FOR_IN
106229: IFFALSE 106290
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
106231: LD_VAR 0 6
106235: PPUSH
106236: CALL_OW 310
106240: PPUSH
106241: CALL_OW 266
106245: PUSH
106246: LD_INT 32
106248: PUSH
106249: LD_INT 31
106251: PUSH
106252: EMPTY
106253: LIST
106254: LIST
106255: IN
106256: IFFALSE 106276
// solds := solds diff i else
106258: LD_ADDR_VAR 0 2
106262: PUSH
106263: LD_VAR 0 2
106267: PUSH
106268: LD_VAR 0 6
106272: DIFF
106273: ST_TO_ADDR
106274: GO 106288
// SetTag ( i , 18 ) ;
106276: LD_VAR 0 6
106280: PPUSH
106281: LD_INT 18
106283: PPUSH
106284: CALL_OW 109
106288: GO 106228
106290: POP
106291: POP
// if not solds then
106292: LD_VAR 0 2
106296: NOT
106297: IFFALSE 106301
// exit ;
106299: GO 106722
// repeat wait ( 0 0$2 ) ;
106301: LD_INT 70
106303: PPUSH
106304: CALL_OW 67
// enemy := mc_scan [ base ] ;
106308: LD_ADDR_VAR 0 4
106312: PUSH
106313: LD_EXP 82
106317: PUSH
106318: LD_VAR 0 1
106322: ARRAY
106323: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
106324: LD_EXP 59
106328: PUSH
106329: LD_VAR 0 1
106333: ARRAY
106334: NOT
106335: PUSH
106336: LD_EXP 59
106340: PUSH
106341: LD_VAR 0 1
106345: ARRAY
106346: PUSH
106347: EMPTY
106348: EQUAL
106349: OR
106350: IFFALSE 106387
// begin for i in solds do
106352: LD_ADDR_VAR 0 6
106356: PUSH
106357: LD_VAR 0 2
106361: PUSH
106362: FOR_IN
106363: IFFALSE 106376
// ComStop ( i ) ;
106365: LD_VAR 0 6
106369: PPUSH
106370: CALL_OW 141
106374: GO 106362
106376: POP
106377: POP
// solds := [ ] ;
106378: LD_ADDR_VAR 0 2
106382: PUSH
106383: EMPTY
106384: ST_TO_ADDR
// exit ;
106385: GO 106722
// end ; for i in solds do
106387: LD_ADDR_VAR 0 6
106391: PUSH
106392: LD_VAR 0 2
106396: PUSH
106397: FOR_IN
106398: IFFALSE 106694
// begin if IsInUnit ( i ) then
106400: LD_VAR 0 6
106404: PPUSH
106405: CALL_OW 310
106409: IFFALSE 106420
// ComExitBuilding ( i ) ;
106411: LD_VAR 0 6
106415: PPUSH
106416: CALL_OW 122
// if GetLives ( i ) > 333 then
106420: LD_VAR 0 6
106424: PPUSH
106425: CALL_OW 256
106429: PUSH
106430: LD_INT 333
106432: GREATER
106433: IFFALSE 106461
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
106435: LD_VAR 0 6
106439: PPUSH
106440: LD_VAR 0 4
106444: PPUSH
106445: LD_VAR 0 6
106449: PPUSH
106450: CALL_OW 74
106454: PPUSH
106455: CALL_OW 115
106459: GO 106692
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
106461: LD_VAR 0 6
106465: PPUSH
106466: LD_EXP 59
106470: PUSH
106471: LD_VAR 0 1
106475: ARRAY
106476: PPUSH
106477: LD_INT 2
106479: PUSH
106480: LD_INT 30
106482: PUSH
106483: LD_INT 0
106485: PUSH
106486: EMPTY
106487: LIST
106488: LIST
106489: PUSH
106490: LD_INT 30
106492: PUSH
106493: LD_INT 1
106495: PUSH
106496: EMPTY
106497: LIST
106498: LIST
106499: PUSH
106500: LD_INT 30
106502: PUSH
106503: LD_INT 6
106505: PUSH
106506: EMPTY
106507: LIST
106508: LIST
106509: PUSH
106510: EMPTY
106511: LIST
106512: LIST
106513: LIST
106514: LIST
106515: PPUSH
106516: CALL_OW 72
106520: PPUSH
106521: LD_VAR 0 6
106525: PPUSH
106526: CALL_OW 74
106530: PPUSH
106531: CALL_OW 296
106535: PUSH
106536: LD_INT 10
106538: GREATER
106539: IFFALSE 106692
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
106541: LD_ADDR_VAR 0 7
106545: PUSH
106546: LD_EXP 59
106550: PUSH
106551: LD_VAR 0 1
106555: ARRAY
106556: PPUSH
106557: LD_INT 2
106559: PUSH
106560: LD_INT 30
106562: PUSH
106563: LD_INT 0
106565: PUSH
106566: EMPTY
106567: LIST
106568: LIST
106569: PUSH
106570: LD_INT 30
106572: PUSH
106573: LD_INT 1
106575: PUSH
106576: EMPTY
106577: LIST
106578: LIST
106579: PUSH
106580: LD_INT 30
106582: PUSH
106583: LD_INT 6
106585: PUSH
106586: EMPTY
106587: LIST
106588: LIST
106589: PUSH
106590: EMPTY
106591: LIST
106592: LIST
106593: LIST
106594: LIST
106595: PPUSH
106596: CALL_OW 72
106600: PPUSH
106601: LD_VAR 0 6
106605: PPUSH
106606: CALL_OW 74
106610: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
106611: LD_VAR 0 6
106615: PPUSH
106616: LD_VAR 0 7
106620: PPUSH
106621: CALL_OW 250
106625: PPUSH
106626: LD_INT 3
106628: PPUSH
106629: LD_INT 5
106631: PPUSH
106632: CALL_OW 272
106636: PPUSH
106637: LD_VAR 0 7
106641: PPUSH
106642: CALL_OW 251
106646: PPUSH
106647: LD_INT 3
106649: PPUSH
106650: LD_INT 5
106652: PPUSH
106653: CALL_OW 273
106657: PPUSH
106658: CALL_OW 111
// SetTag ( i , 0 ) ;
106662: LD_VAR 0 6
106666: PPUSH
106667: LD_INT 0
106669: PPUSH
106670: CALL_OW 109
// solds := solds diff i ;
106674: LD_ADDR_VAR 0 2
106678: PUSH
106679: LD_VAR 0 2
106683: PUSH
106684: LD_VAR 0 6
106688: DIFF
106689: ST_TO_ADDR
// continue ;
106690: GO 106397
// end ; end ;
106692: GO 106397
106694: POP
106695: POP
// until not solds or not enemy ;
106696: LD_VAR 0 2
106700: NOT
106701: PUSH
106702: LD_VAR 0 4
106706: NOT
106707: OR
106708: IFFALSE 106301
// MC_Reset ( base , 18 ) ;
106710: LD_VAR 0 1
106714: PPUSH
106715: LD_INT 18
106717: PPUSH
106718: CALL 57768 0 2
// end ;
106722: LD_VAR 0 3
106726: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
106727: LD_INT 0
106729: PPUSH
106730: PPUSH
106731: PPUSH
106732: PPUSH
106733: PPUSH
106734: PPUSH
106735: PPUSH
106736: PPUSH
106737: PPUSH
106738: PPUSH
106739: PPUSH
106740: PPUSH
106741: PPUSH
106742: PPUSH
106743: PPUSH
106744: PPUSH
106745: PPUSH
106746: PPUSH
106747: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
106748: LD_ADDR_VAR 0 12
106752: PUSH
106753: LD_EXP 59
106757: PUSH
106758: LD_VAR 0 1
106762: ARRAY
106763: PPUSH
106764: LD_INT 25
106766: PUSH
106767: LD_INT 3
106769: PUSH
106770: EMPTY
106771: LIST
106772: LIST
106773: PPUSH
106774: CALL_OW 72
106778: ST_TO_ADDR
// if mc_remote_driver [ base ] then
106779: LD_EXP 99
106783: PUSH
106784: LD_VAR 0 1
106788: ARRAY
106789: IFFALSE 106813
// mechs := mechs diff mc_remote_driver [ base ] ;
106791: LD_ADDR_VAR 0 12
106795: PUSH
106796: LD_VAR 0 12
106800: PUSH
106801: LD_EXP 99
106805: PUSH
106806: LD_VAR 0 1
106810: ARRAY
106811: DIFF
106812: ST_TO_ADDR
// for i in mechs do
106813: LD_ADDR_VAR 0 4
106817: PUSH
106818: LD_VAR 0 12
106822: PUSH
106823: FOR_IN
106824: IFFALSE 106859
// if GetTag ( i ) > 0 then
106826: LD_VAR 0 4
106830: PPUSH
106831: CALL_OW 110
106835: PUSH
106836: LD_INT 0
106838: GREATER
106839: IFFALSE 106857
// mechs := mechs diff i ;
106841: LD_ADDR_VAR 0 12
106845: PUSH
106846: LD_VAR 0 12
106850: PUSH
106851: LD_VAR 0 4
106855: DIFF
106856: ST_TO_ADDR
106857: GO 106823
106859: POP
106860: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
106861: LD_ADDR_VAR 0 8
106865: PUSH
106866: LD_EXP 59
106870: PUSH
106871: LD_VAR 0 1
106875: ARRAY
106876: PPUSH
106877: LD_INT 2
106879: PUSH
106880: LD_INT 25
106882: PUSH
106883: LD_INT 1
106885: PUSH
106886: EMPTY
106887: LIST
106888: LIST
106889: PUSH
106890: LD_INT 25
106892: PUSH
106893: LD_INT 5
106895: PUSH
106896: EMPTY
106897: LIST
106898: LIST
106899: PUSH
106900: LD_INT 25
106902: PUSH
106903: LD_INT 8
106905: PUSH
106906: EMPTY
106907: LIST
106908: LIST
106909: PUSH
106910: LD_INT 25
106912: PUSH
106913: LD_INT 9
106915: PUSH
106916: EMPTY
106917: LIST
106918: LIST
106919: PUSH
106920: EMPTY
106921: LIST
106922: LIST
106923: LIST
106924: LIST
106925: LIST
106926: PPUSH
106927: CALL_OW 72
106931: ST_TO_ADDR
// if not defenders and not solds then
106932: LD_VAR 0 2
106936: NOT
106937: PUSH
106938: LD_VAR 0 8
106942: NOT
106943: AND
106944: IFFALSE 106948
// exit ;
106946: GO 108718
// depot_under_attack := false ;
106948: LD_ADDR_VAR 0 16
106952: PUSH
106953: LD_INT 0
106955: ST_TO_ADDR
// sold_defenders := [ ] ;
106956: LD_ADDR_VAR 0 17
106960: PUSH
106961: EMPTY
106962: ST_TO_ADDR
// if mechs then
106963: LD_VAR 0 12
106967: IFFALSE 107120
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
106969: LD_ADDR_VAR 0 4
106973: PUSH
106974: LD_VAR 0 2
106978: PPUSH
106979: LD_INT 21
106981: PUSH
106982: LD_INT 2
106984: PUSH
106985: EMPTY
106986: LIST
106987: LIST
106988: PPUSH
106989: CALL_OW 72
106993: PUSH
106994: FOR_IN
106995: IFFALSE 107118
// begin if GetTag ( i ) <> 20 then
106997: LD_VAR 0 4
107001: PPUSH
107002: CALL_OW 110
107006: PUSH
107007: LD_INT 20
107009: NONEQUAL
107010: IFFALSE 107024
// SetTag ( i , 20 ) ;
107012: LD_VAR 0 4
107016: PPUSH
107017: LD_INT 20
107019: PPUSH
107020: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
107024: LD_VAR 0 4
107028: PPUSH
107029: CALL_OW 263
107033: PUSH
107034: LD_INT 1
107036: EQUAL
107037: PUSH
107038: LD_VAR 0 4
107042: PPUSH
107043: CALL_OW 311
107047: NOT
107048: AND
107049: IFFALSE 107116
// begin un := mechs [ 1 ] ;
107051: LD_ADDR_VAR 0 10
107055: PUSH
107056: LD_VAR 0 12
107060: PUSH
107061: LD_INT 1
107063: ARRAY
107064: ST_TO_ADDR
// ComExit ( un ) ;
107065: LD_VAR 0 10
107069: PPUSH
107070: CALL 51865 0 1
// AddComEnterUnit ( un , i ) ;
107074: LD_VAR 0 10
107078: PPUSH
107079: LD_VAR 0 4
107083: PPUSH
107084: CALL_OW 180
// SetTag ( un , 19 ) ;
107088: LD_VAR 0 10
107092: PPUSH
107093: LD_INT 19
107095: PPUSH
107096: CALL_OW 109
// mechs := mechs diff un ;
107100: LD_ADDR_VAR 0 12
107104: PUSH
107105: LD_VAR 0 12
107109: PUSH
107110: LD_VAR 0 10
107114: DIFF
107115: ST_TO_ADDR
// end ; end ;
107116: GO 106994
107118: POP
107119: POP
// if solds then
107120: LD_VAR 0 8
107124: IFFALSE 107183
// for i in solds do
107126: LD_ADDR_VAR 0 4
107130: PUSH
107131: LD_VAR 0 8
107135: PUSH
107136: FOR_IN
107137: IFFALSE 107181
// if not GetTag ( i ) then
107139: LD_VAR 0 4
107143: PPUSH
107144: CALL_OW 110
107148: NOT
107149: IFFALSE 107179
// begin defenders := defenders union i ;
107151: LD_ADDR_VAR 0 2
107155: PUSH
107156: LD_VAR 0 2
107160: PUSH
107161: LD_VAR 0 4
107165: UNION
107166: ST_TO_ADDR
// SetTag ( i , 18 ) ;
107167: LD_VAR 0 4
107171: PPUSH
107172: LD_INT 18
107174: PPUSH
107175: CALL_OW 109
// end ;
107179: GO 107136
107181: POP
107182: POP
// repeat wait ( 0 0$2 ) ;
107183: LD_INT 70
107185: PPUSH
107186: CALL_OW 67
// enemy := mc_scan [ base ] ;
107190: LD_ADDR_VAR 0 21
107194: PUSH
107195: LD_EXP 82
107199: PUSH
107200: LD_VAR 0 1
107204: ARRAY
107205: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107206: LD_EXP 59
107210: PUSH
107211: LD_VAR 0 1
107215: ARRAY
107216: NOT
107217: PUSH
107218: LD_EXP 59
107222: PUSH
107223: LD_VAR 0 1
107227: ARRAY
107228: PUSH
107229: EMPTY
107230: EQUAL
107231: OR
107232: IFFALSE 107269
// begin for i in defenders do
107234: LD_ADDR_VAR 0 4
107238: PUSH
107239: LD_VAR 0 2
107243: PUSH
107244: FOR_IN
107245: IFFALSE 107258
// ComStop ( i ) ;
107247: LD_VAR 0 4
107251: PPUSH
107252: CALL_OW 141
107256: GO 107244
107258: POP
107259: POP
// defenders := [ ] ;
107260: LD_ADDR_VAR 0 2
107264: PUSH
107265: EMPTY
107266: ST_TO_ADDR
// exit ;
107267: GO 108718
// end ; for i in defenders do
107269: LD_ADDR_VAR 0 4
107273: PUSH
107274: LD_VAR 0 2
107278: PUSH
107279: FOR_IN
107280: IFFALSE 108178
// begin e := NearestUnitToUnit ( enemy , i ) ;
107282: LD_ADDR_VAR 0 13
107286: PUSH
107287: LD_VAR 0 21
107291: PPUSH
107292: LD_VAR 0 4
107296: PPUSH
107297: CALL_OW 74
107301: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107302: LD_ADDR_VAR 0 7
107306: PUSH
107307: LD_EXP 59
107311: PUSH
107312: LD_VAR 0 1
107316: ARRAY
107317: PPUSH
107318: LD_INT 2
107320: PUSH
107321: LD_INT 30
107323: PUSH
107324: LD_INT 0
107326: PUSH
107327: EMPTY
107328: LIST
107329: LIST
107330: PUSH
107331: LD_INT 30
107333: PUSH
107334: LD_INT 1
107336: PUSH
107337: EMPTY
107338: LIST
107339: LIST
107340: PUSH
107341: EMPTY
107342: LIST
107343: LIST
107344: LIST
107345: PPUSH
107346: CALL_OW 72
107350: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
107351: LD_ADDR_VAR 0 16
107355: PUSH
107356: LD_VAR 0 7
107360: NOT
107361: PUSH
107362: LD_VAR 0 7
107366: PPUSH
107367: LD_INT 3
107369: PUSH
107370: LD_INT 24
107372: PUSH
107373: LD_INT 600
107375: PUSH
107376: EMPTY
107377: LIST
107378: LIST
107379: PUSH
107380: EMPTY
107381: LIST
107382: LIST
107383: PPUSH
107384: CALL_OW 72
107388: OR
107389: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
107390: LD_VAR 0 4
107394: PPUSH
107395: CALL_OW 247
107399: PUSH
107400: LD_INT 2
107402: DOUBLE
107403: EQUAL
107404: IFTRUE 107408
107406: GO 107804
107408: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
107409: LD_VAR 0 4
107413: PPUSH
107414: CALL_OW 256
107418: PUSH
107419: LD_INT 1000
107421: EQUAL
107422: PUSH
107423: LD_VAR 0 4
107427: PPUSH
107428: LD_VAR 0 13
107432: PPUSH
107433: CALL_OW 296
107437: PUSH
107438: LD_INT 40
107440: LESS
107441: PUSH
107442: LD_VAR 0 13
107446: PPUSH
107447: LD_EXP 84
107451: PUSH
107452: LD_VAR 0 1
107456: ARRAY
107457: PPUSH
107458: CALL_OW 308
107462: OR
107463: AND
107464: IFFALSE 107586
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
107466: LD_VAR 0 4
107470: PPUSH
107471: CALL_OW 262
107475: PUSH
107476: LD_INT 1
107478: EQUAL
107479: PUSH
107480: LD_VAR 0 4
107484: PPUSH
107485: CALL_OW 261
107489: PUSH
107490: LD_INT 30
107492: LESS
107493: AND
107494: PUSH
107495: LD_VAR 0 7
107499: AND
107500: IFFALSE 107570
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
107502: LD_VAR 0 4
107506: PPUSH
107507: LD_VAR 0 7
107511: PPUSH
107512: LD_VAR 0 4
107516: PPUSH
107517: CALL_OW 74
107521: PPUSH
107522: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
107526: LD_VAR 0 4
107530: PPUSH
107531: LD_VAR 0 7
107535: PPUSH
107536: LD_VAR 0 4
107540: PPUSH
107541: CALL_OW 74
107545: PPUSH
107546: CALL_OW 296
107550: PUSH
107551: LD_INT 6
107553: LESS
107554: IFFALSE 107568
// SetFuel ( i , 100 ) ;
107556: LD_VAR 0 4
107560: PPUSH
107561: LD_INT 100
107563: PPUSH
107564: CALL_OW 240
// end else
107568: GO 107584
// ComAttackUnit ( i , e ) ;
107570: LD_VAR 0 4
107574: PPUSH
107575: LD_VAR 0 13
107579: PPUSH
107580: CALL_OW 115
// end else
107584: GO 107687
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
107586: LD_VAR 0 13
107590: PPUSH
107591: LD_EXP 84
107595: PUSH
107596: LD_VAR 0 1
107600: ARRAY
107601: PPUSH
107602: CALL_OW 308
107606: NOT
107607: PUSH
107608: LD_VAR 0 4
107612: PPUSH
107613: LD_VAR 0 13
107617: PPUSH
107618: CALL_OW 296
107622: PUSH
107623: LD_INT 40
107625: GREATEREQUAL
107626: AND
107627: PUSH
107628: LD_VAR 0 4
107632: PPUSH
107633: CALL_OW 256
107637: PUSH
107638: LD_INT 650
107640: LESSEQUAL
107641: OR
107642: PUSH
107643: LD_VAR 0 4
107647: PPUSH
107648: LD_EXP 83
107652: PUSH
107653: LD_VAR 0 1
107657: ARRAY
107658: PPUSH
107659: CALL_OW 308
107663: NOT
107664: AND
107665: IFFALSE 107687
// ComMoveToArea ( i , mc_parking [ base ] ) ;
107667: LD_VAR 0 4
107671: PPUSH
107672: LD_EXP 83
107676: PUSH
107677: LD_VAR 0 1
107681: ARRAY
107682: PPUSH
107683: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
107687: LD_VAR 0 4
107691: PPUSH
107692: CALL_OW 256
107696: PUSH
107697: LD_INT 1000
107699: LESS
107700: PUSH
107701: LD_VAR 0 4
107705: PPUSH
107706: CALL_OW 263
107710: PUSH
107711: LD_INT 1
107713: EQUAL
107714: AND
107715: PUSH
107716: LD_VAR 0 4
107720: PPUSH
107721: CALL_OW 311
107725: AND
107726: PUSH
107727: LD_VAR 0 4
107731: PPUSH
107732: LD_EXP 83
107736: PUSH
107737: LD_VAR 0 1
107741: ARRAY
107742: PPUSH
107743: CALL_OW 308
107747: AND
107748: IFFALSE 107802
// begin mech := IsDrivenBy ( i ) ;
107750: LD_ADDR_VAR 0 9
107754: PUSH
107755: LD_VAR 0 4
107759: PPUSH
107760: CALL_OW 311
107764: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
107765: LD_VAR 0 9
107769: PPUSH
107770: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
107774: LD_VAR 0 9
107778: PPUSH
107779: LD_VAR 0 4
107783: PPUSH
107784: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
107788: LD_VAR 0 9
107792: PPUSH
107793: LD_VAR 0 4
107797: PPUSH
107798: CALL_OW 180
// end ; end ; unit_human :
107802: GO 108149
107804: LD_INT 1
107806: DOUBLE
107807: EQUAL
107808: IFTRUE 107812
107810: GO 108148
107812: POP
// begin b := IsInUnit ( i ) ;
107813: LD_ADDR_VAR 0 18
107817: PUSH
107818: LD_VAR 0 4
107822: PPUSH
107823: CALL_OW 310
107827: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
107828: LD_ADDR_VAR 0 19
107832: PUSH
107833: LD_VAR 0 18
107837: NOT
107838: PUSH
107839: LD_VAR 0 18
107843: PPUSH
107844: CALL_OW 266
107848: PUSH
107849: LD_INT 32
107851: PUSH
107852: LD_INT 31
107854: PUSH
107855: EMPTY
107856: LIST
107857: LIST
107858: IN
107859: OR
107860: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
107861: LD_VAR 0 18
107865: PPUSH
107866: CALL_OW 266
107870: PUSH
107871: LD_INT 5
107873: EQUAL
107874: PUSH
107875: LD_VAR 0 4
107879: PPUSH
107880: CALL_OW 257
107884: PUSH
107885: LD_INT 1
107887: PUSH
107888: LD_INT 2
107890: PUSH
107891: LD_INT 3
107893: PUSH
107894: LD_INT 4
107896: PUSH
107897: EMPTY
107898: LIST
107899: LIST
107900: LIST
107901: LIST
107902: IN
107903: AND
107904: IFFALSE 107941
// begin class := AllowSpecClass ( i ) ;
107906: LD_ADDR_VAR 0 20
107910: PUSH
107911: LD_VAR 0 4
107915: PPUSH
107916: CALL 16526 0 1
107920: ST_TO_ADDR
// if class then
107921: LD_VAR 0 20
107925: IFFALSE 107941
// ComChangeProfession ( i , class ) ;
107927: LD_VAR 0 4
107931: PPUSH
107932: LD_VAR 0 20
107936: PPUSH
107937: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
107941: LD_VAR 0 16
107945: PUSH
107946: LD_VAR 0 2
107950: PPUSH
107951: LD_INT 21
107953: PUSH
107954: LD_INT 2
107956: PUSH
107957: EMPTY
107958: LIST
107959: LIST
107960: PPUSH
107961: CALL_OW 72
107965: PUSH
107966: LD_INT 1
107968: LESSEQUAL
107969: OR
107970: PUSH
107971: LD_VAR 0 19
107975: AND
107976: PUSH
107977: LD_VAR 0 4
107981: PUSH
107982: LD_VAR 0 17
107986: IN
107987: NOT
107988: AND
107989: IFFALSE 108082
// begin if b then
107991: LD_VAR 0 18
107995: IFFALSE 108044
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
107997: LD_VAR 0 18
108001: PPUSH
108002: LD_VAR 0 21
108006: PPUSH
108007: LD_VAR 0 18
108011: PPUSH
108012: CALL_OW 74
108016: PPUSH
108017: CALL_OW 296
108021: PUSH
108022: LD_INT 10
108024: LESS
108025: PUSH
108026: LD_VAR 0 18
108030: PPUSH
108031: CALL_OW 461
108035: PUSH
108036: LD_INT 7
108038: NONEQUAL
108039: AND
108040: IFFALSE 108044
// continue ;
108042: GO 107279
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
108044: LD_ADDR_VAR 0 17
108048: PUSH
108049: LD_VAR 0 17
108053: PPUSH
108054: LD_VAR 0 17
108058: PUSH
108059: LD_INT 1
108061: PLUS
108062: PPUSH
108063: LD_VAR 0 4
108067: PPUSH
108068: CALL_OW 1
108072: ST_TO_ADDR
// ComExitBuilding ( i ) ;
108073: LD_VAR 0 4
108077: PPUSH
108078: CALL_OW 122
// end ; if sold_defenders then
108082: LD_VAR 0 17
108086: IFFALSE 108146
// if i in sold_defenders then
108088: LD_VAR 0 4
108092: PUSH
108093: LD_VAR 0 17
108097: IN
108098: IFFALSE 108146
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
108100: LD_VAR 0 4
108104: PPUSH
108105: CALL_OW 314
108109: NOT
108110: PUSH
108111: LD_VAR 0 4
108115: PPUSH
108116: LD_VAR 0 13
108120: PPUSH
108121: CALL_OW 296
108125: PUSH
108126: LD_INT 30
108128: LESS
108129: AND
108130: IFFALSE 108146
// ComAttackUnit ( i , e ) ;
108132: LD_VAR 0 4
108136: PPUSH
108137: LD_VAR 0 13
108141: PPUSH
108142: CALL_OW 115
// end ; end ; end ;
108146: GO 108149
108148: POP
// if IsDead ( i ) then
108149: LD_VAR 0 4
108153: PPUSH
108154: CALL_OW 301
108158: IFFALSE 108176
// defenders := defenders diff i ;
108160: LD_ADDR_VAR 0 2
108164: PUSH
108165: LD_VAR 0 2
108169: PUSH
108170: LD_VAR 0 4
108174: DIFF
108175: ST_TO_ADDR
// end ;
108176: GO 107279
108178: POP
108179: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
108180: LD_VAR 0 21
108184: NOT
108185: PUSH
108186: LD_VAR 0 2
108190: NOT
108191: OR
108192: PUSH
108193: LD_EXP 59
108197: PUSH
108198: LD_VAR 0 1
108202: ARRAY
108203: NOT
108204: OR
108205: IFFALSE 107183
// MC_Reset ( base , 18 ) ;
108207: LD_VAR 0 1
108211: PPUSH
108212: LD_INT 18
108214: PPUSH
108215: CALL 57768 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
108219: LD_ADDR_VAR 0 2
108223: PUSH
108224: LD_VAR 0 2
108228: PUSH
108229: LD_VAR 0 2
108233: PPUSH
108234: LD_INT 2
108236: PUSH
108237: LD_INT 25
108239: PUSH
108240: LD_INT 1
108242: PUSH
108243: EMPTY
108244: LIST
108245: LIST
108246: PUSH
108247: LD_INT 25
108249: PUSH
108250: LD_INT 5
108252: PUSH
108253: EMPTY
108254: LIST
108255: LIST
108256: PUSH
108257: LD_INT 25
108259: PUSH
108260: LD_INT 8
108262: PUSH
108263: EMPTY
108264: LIST
108265: LIST
108266: PUSH
108267: LD_INT 25
108269: PUSH
108270: LD_INT 9
108272: PUSH
108273: EMPTY
108274: LIST
108275: LIST
108276: PUSH
108277: EMPTY
108278: LIST
108279: LIST
108280: LIST
108281: LIST
108282: LIST
108283: PPUSH
108284: CALL_OW 72
108288: DIFF
108289: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
108290: LD_VAR 0 21
108294: NOT
108295: PUSH
108296: LD_VAR 0 2
108300: PPUSH
108301: LD_INT 21
108303: PUSH
108304: LD_INT 2
108306: PUSH
108307: EMPTY
108308: LIST
108309: LIST
108310: PPUSH
108311: CALL_OW 72
108315: AND
108316: IFFALSE 108654
// begin tmp := FilterByTag ( defenders , 19 ) ;
108318: LD_ADDR_VAR 0 11
108322: PUSH
108323: LD_VAR 0 2
108327: PPUSH
108328: LD_INT 19
108330: PPUSH
108331: CALL 48995 0 2
108335: ST_TO_ADDR
// if tmp then
108336: LD_VAR 0 11
108340: IFFALSE 108410
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
108342: LD_ADDR_VAR 0 11
108346: PUSH
108347: LD_VAR 0 11
108351: PPUSH
108352: LD_INT 25
108354: PUSH
108355: LD_INT 3
108357: PUSH
108358: EMPTY
108359: LIST
108360: LIST
108361: PPUSH
108362: CALL_OW 72
108366: ST_TO_ADDR
// if tmp then
108367: LD_VAR 0 11
108371: IFFALSE 108410
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
108373: LD_ADDR_EXP 71
108377: PUSH
108378: LD_EXP 71
108382: PPUSH
108383: LD_VAR 0 1
108387: PPUSH
108388: LD_EXP 71
108392: PUSH
108393: LD_VAR 0 1
108397: ARRAY
108398: PUSH
108399: LD_VAR 0 11
108403: UNION
108404: PPUSH
108405: CALL_OW 1
108409: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
108410: LD_VAR 0 1
108414: PPUSH
108415: LD_INT 19
108417: PPUSH
108418: CALL 57768 0 2
// repeat wait ( 0 0$1 ) ;
108422: LD_INT 35
108424: PPUSH
108425: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
108429: LD_EXP 59
108433: PUSH
108434: LD_VAR 0 1
108438: ARRAY
108439: NOT
108440: PUSH
108441: LD_EXP 59
108445: PUSH
108446: LD_VAR 0 1
108450: ARRAY
108451: PUSH
108452: EMPTY
108453: EQUAL
108454: OR
108455: IFFALSE 108492
// begin for i in defenders do
108457: LD_ADDR_VAR 0 4
108461: PUSH
108462: LD_VAR 0 2
108466: PUSH
108467: FOR_IN
108468: IFFALSE 108481
// ComStop ( i ) ;
108470: LD_VAR 0 4
108474: PPUSH
108475: CALL_OW 141
108479: GO 108467
108481: POP
108482: POP
// defenders := [ ] ;
108483: LD_ADDR_VAR 0 2
108487: PUSH
108488: EMPTY
108489: ST_TO_ADDR
// exit ;
108490: GO 108718
// end ; for i in defenders do
108492: LD_ADDR_VAR 0 4
108496: PUSH
108497: LD_VAR 0 2
108501: PUSH
108502: FOR_IN
108503: IFFALSE 108592
// begin if not IsInArea ( i , mc_parking [ base ] ) then
108505: LD_VAR 0 4
108509: PPUSH
108510: LD_EXP 83
108514: PUSH
108515: LD_VAR 0 1
108519: ARRAY
108520: PPUSH
108521: CALL_OW 308
108525: NOT
108526: IFFALSE 108550
// ComMoveToArea ( i , mc_parking [ base ] ) else
108528: LD_VAR 0 4
108532: PPUSH
108533: LD_EXP 83
108537: PUSH
108538: LD_VAR 0 1
108542: ARRAY
108543: PPUSH
108544: CALL_OW 113
108548: GO 108590
// if GetControl ( i ) = control_manual then
108550: LD_VAR 0 4
108554: PPUSH
108555: CALL_OW 263
108559: PUSH
108560: LD_INT 1
108562: EQUAL
108563: IFFALSE 108590
// if IsDrivenBy ( i ) then
108565: LD_VAR 0 4
108569: PPUSH
108570: CALL_OW 311
108574: IFFALSE 108590
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
108576: LD_VAR 0 4
108580: PPUSH
108581: CALL_OW 311
108585: PPUSH
108586: CALL_OW 121
// end ;
108590: GO 108502
108592: POP
108593: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
108594: LD_VAR 0 2
108598: PPUSH
108599: LD_INT 95
108601: PUSH
108602: LD_EXP 83
108606: PUSH
108607: LD_VAR 0 1
108611: ARRAY
108612: PUSH
108613: EMPTY
108614: LIST
108615: LIST
108616: PPUSH
108617: CALL_OW 72
108621: PUSH
108622: LD_VAR 0 2
108626: EQUAL
108627: PUSH
108628: LD_EXP 82
108632: PUSH
108633: LD_VAR 0 1
108637: ARRAY
108638: OR
108639: PUSH
108640: LD_EXP 59
108644: PUSH
108645: LD_VAR 0 1
108649: ARRAY
108650: NOT
108651: OR
108652: IFFALSE 108422
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
108654: LD_ADDR_EXP 81
108658: PUSH
108659: LD_EXP 81
108663: PPUSH
108664: LD_VAR 0 1
108668: PPUSH
108669: LD_VAR 0 2
108673: PPUSH
108674: LD_INT 21
108676: PUSH
108677: LD_INT 2
108679: PUSH
108680: EMPTY
108681: LIST
108682: LIST
108683: PPUSH
108684: CALL_OW 72
108688: PPUSH
108689: CALL_OW 1
108693: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
108694: LD_VAR 0 1
108698: PPUSH
108699: LD_INT 19
108701: PPUSH
108702: CALL 57768 0 2
// MC_Reset ( base , 20 ) ;
108706: LD_VAR 0 1
108710: PPUSH
108711: LD_INT 20
108713: PPUSH
108714: CALL 57768 0 2
// end ; end_of_file
108718: LD_VAR 0 3
108722: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
108723: LD_VAR 0 1
108727: PUSH
108728: LD_INT 200
108730: DOUBLE
108731: GREATEREQUAL
108732: IFFALSE 108740
108734: LD_INT 299
108736: DOUBLE
108737: LESSEQUAL
108738: IFTRUE 108742
108740: GO 108774
108742: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
108743: LD_VAR 0 1
108747: PPUSH
108748: LD_VAR 0 2
108752: PPUSH
108753: LD_VAR 0 3
108757: PPUSH
108758: LD_VAR 0 4
108762: PPUSH
108763: LD_VAR 0 5
108767: PPUSH
108768: CALL 97565 0 5
108772: GO 108851
108774: LD_INT 300
108776: DOUBLE
108777: GREATEREQUAL
108778: IFFALSE 108786
108780: LD_INT 399
108782: DOUBLE
108783: LESSEQUAL
108784: IFTRUE 108788
108786: GO 108850
108788: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
108789: LD_VAR 0 1
108793: PPUSH
108794: LD_VAR 0 2
108798: PPUSH
108799: LD_VAR 0 3
108803: PPUSH
108804: LD_VAR 0 4
108808: PPUSH
108809: LD_VAR 0 5
108813: PPUSH
108814: LD_VAR 0 6
108818: PPUSH
108819: LD_VAR 0 7
108823: PPUSH
108824: LD_VAR 0 8
108828: PPUSH
108829: LD_VAR 0 9
108833: PPUSH
108834: LD_VAR 0 10
108838: PPUSH
108839: LD_VAR 0 11
108843: PPUSH
108844: CALL 95453 0 11
108848: GO 108851
108850: POP
// end ;
108851: PPOPN 11
108853: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
108854: LD_VAR 0 1
108858: PPUSH
108859: LD_VAR 0 2
108863: PPUSH
108864: LD_VAR 0 3
108868: PPUSH
108869: LD_VAR 0 4
108873: PPUSH
108874: LD_VAR 0 5
108878: PPUSH
108879: CALL 97547 0 5
// end ; end_of_file
108883: PPOPN 5
108885: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
108886: LD_VAR 0 1
108890: PPUSH
108891: LD_VAR 0 2
108895: PPUSH
108896: LD_VAR 0 3
108900: PPUSH
108901: LD_VAR 0 4
108905: PPUSH
108906: LD_VAR 0 5
108910: PPUSH
108911: LD_VAR 0 6
108915: PPUSH
108916: CALL 84261 0 6
// end ;
108920: PPOPN 6
108922: END
