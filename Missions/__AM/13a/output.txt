// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 619 0 0
// InitMacro ;
  19: CALL 57449 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 49190 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 49190 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 49190 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 49190 0 9
// PrepareArabian ;
 147: CALL 3690 0 0
// PrepareRussian ;
 151: CALL 2825 0 0
// PrepareAlliance ;
 155: CALL 821 0 0
// MC_Start ( ) ;
 159: CALL 59561 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6853 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 83
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 84
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 80778 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 54
 252: PPUSH
 253: CALL 81204 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 81662 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 81931 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 81144 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 81838 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 51
 340: PPUSH
 341: CALL 81204 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 81662 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 81931 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 80988 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 22
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 3
 596: PUSH
 597: LD_INT 52
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL 81144 0 2
// end ;
 614: LD_VAR 0 1
 618: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 619: LD_INT 0
 621: PPUSH
// debug := 0 ;
 622: LD_ADDR_EXP 1
 626: PUSH
 627: LD_INT 0
 629: ST_TO_ADDR
// game := true ;
 630: LD_ADDR_EXP 2
 634: PUSH
 635: LD_INT 1
 637: ST_TO_ADDR
// gossudarov_arrive := false ;
 638: LD_ADDR_EXP 4
 642: PUSH
 643: LD_INT 0
 645: ST_TO_ADDR
// ru_lab_builded := false ;
 646: LD_ADDR_EXP 5
 650: PUSH
 651: LD_INT 0
 653: ST_TO_ADDR
// player_spotted := false ;
 654: LD_ADDR_EXP 6
 658: PUSH
 659: LD_INT 0
 661: ST_TO_ADDR
// first_attack := false ;
 662: LD_ADDR_EXP 7
 666: PUSH
 667: LD_INT 0
 669: ST_TO_ADDR
// ru_attackers := [ ] ;
 670: LD_ADDR_EXP 52
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// ar_base_spotted := false ;
 677: LD_ADDR_EXP 8
 681: PUSH
 682: LD_INT 0
 684: ST_TO_ADDR
// ar_active_attack := false ;
 685: LD_ADDR_EXP 9
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// ar_attackers := [ ] ;
 693: LD_ADDR_EXP 10
 697: PUSH
 698: EMPTY
 699: ST_TO_ADDR
// first_powell_attack := false ;
 700: LD_ADDR_EXP 11
 704: PUSH
 705: LD_INT 0
 707: ST_TO_ADDR
// abdul_escaped := true ;
 708: LD_ADDR_EXP 12
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// loss_counter := 0 ;
 716: LD_ADDR_EXP 13
 720: PUSH
 721: LD_INT 0
 723: ST_TO_ADDR
// hack_counter := 0 ;
 724: LD_ADDR_EXP 14
 728: PUSH
 729: LD_INT 0
 731: ST_TO_ADDR
// end ;
 732: LD_VAR 0 1
 736: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 737: LD_EXP 48
 741: PPUSH
 742: CALL_OW 255
 746: PUSH
 747: LD_INT 7
 749: EQUAL
 750: PUSH
 751: LD_EXP 47
 755: PPUSH
 756: CALL_OW 255
 760: PUSH
 761: LD_INT 7
 763: EQUAL
 764: AND
 765: PUSH
 766: LD_EXP 48
 770: PPUSH
 771: CALL_OW 302
 775: AND
 776: PUSH
 777: LD_EXP 47
 781: PPUSH
 782: CALL_OW 302
 786: AND
 787: IFFALSE 799
 789: GO 791
 791: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 792: LD_STRING ACH_COMRADE
 794: PPUSH
 795: CALL_OW 543
 799: END
// every 0 0$1 trigger hack_counter >= 10 do
 800: LD_EXP 14
 804: PUSH
 805: LD_INT 10
 807: GREATEREQUAL
 808: IFFALSE 820
 810: GO 812
 812: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 813: LD_STRING ACH_HACK
 815: PPUSH
 816: CALL_OW 543
 820: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 821: LD_INT 0
 823: PPUSH
 824: PPUSH
 825: PPUSH
 826: PPUSH
// uc_side := 7 ;
 827: LD_ADDR_OWVAR 20
 831: PUSH
 832: LD_INT 7
 834: ST_TO_ADDR
// uc_nation := 1 ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_INT 1
 842: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 843: LD_ADDR_EXP 15
 847: PUSH
 848: LD_STRING JMM
 850: PPUSH
 851: LD_EXP 1
 855: NOT
 856: PPUSH
 857: LD_STRING 12a_
 859: PPUSH
 860: CALL 14284 0 3
 864: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 865: LD_EXP 15
 869: PPUSH
 870: LD_INT 71
 872: PPUSH
 873: LD_INT 23
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 883: LD_EXP 15
 887: PPUSH
 888: LD_INT 2
 890: PPUSH
 891: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 895: LD_ADDR_EXP 16
 899: PUSH
 900: LD_STRING Roth
 902: PPUSH
 903: LD_EXP 1
 907: NOT
 908: PPUSH
 909: LD_STRING 12a_
 911: PPUSH
 912: CALL 14284 0 3
 916: ST_TO_ADDR
// if Roth then
 917: LD_EXP 16
 921: IFFALSE 941
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 923: LD_EXP 16
 927: PPUSH
 928: LD_INT 71
 930: PPUSH
 931: LD_INT 21
 933: PPUSH
 934: LD_INT 0
 936: PPUSH
 937: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING Lisa
 948: PPUSH
 949: LD_EXP 1
 953: NOT
 954: PPUSH
 955: LD_STRING 12a_
 957: PPUSH
 958: CALL 14284 0 3
 962: ST_TO_ADDR
// if Lisa then
 963: LD_EXP 17
 967: IFFALSE 984
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 969: LD_EXP 17
 973: PPUSH
 974: LD_INT 13
 976: PPUSH
 977: LD_INT 0
 979: PPUSH
 980: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 984: LD_ADDR_EXP 18
 988: PUSH
 989: LD_STRING Donaldson
 991: PPUSH
 992: LD_EXP 1
 996: NOT
 997: PPUSH
 998: LD_STRING 12a_
1000: PPUSH
1001: CALL 14284 0 3
1005: ST_TO_ADDR
// if Donaldson then
1006: LD_EXP 18
1010: IFFALSE 1027
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1012: LD_EXP 18
1016: PPUSH
1017: LD_INT 13
1019: PPUSH
1020: LD_INT 0
1022: PPUSH
1023: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1027: LD_ADDR_EXP 19
1031: PUSH
1032: LD_STRING Bobby
1034: PPUSH
1035: LD_EXP 1
1039: NOT
1040: PPUSH
1041: LD_STRING 12a_
1043: PPUSH
1044: CALL 14284 0 3
1048: ST_TO_ADDR
// if Bobby then
1049: LD_EXP 19
1053: IFFALSE 1070
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1055: LD_EXP 19
1059: PPUSH
1060: LD_INT 13
1062: PPUSH
1063: LD_INT 0
1065: PPUSH
1066: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1070: LD_ADDR_EXP 20
1074: PUSH
1075: LD_STRING Cyrus
1077: PPUSH
1078: LD_EXP 1
1082: NOT
1083: PPUSH
1084: LD_STRING 12a_
1086: PPUSH
1087: CALL 14284 0 3
1091: ST_TO_ADDR
// if Cyrus then
1092: LD_EXP 20
1096: IFFALSE 1113
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1098: LD_EXP 20
1102: PPUSH
1103: LD_INT 13
1105: PPUSH
1106: LD_INT 0
1108: PPUSH
1109: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1113: LD_ADDR_EXP 21
1117: PUSH
1118: LD_STRING Denis
1120: PPUSH
1121: LD_EXP 1
1125: NOT
1126: PPUSH
1127: LD_STRING 12a_
1129: PPUSH
1130: CALL 14284 0 3
1134: ST_TO_ADDR
// if Denis then
1135: LD_EXP 21
1139: IFFALSE 1156
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1141: LD_EXP 21
1145: PPUSH
1146: LD_INT 13
1148: PPUSH
1149: LD_INT 0
1151: PPUSH
1152: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1156: LD_ADDR_EXP 22
1160: PUSH
1161: LD_STRING Brown
1163: PPUSH
1164: LD_EXP 1
1168: NOT
1169: PPUSH
1170: LD_STRING 12a_
1172: PPUSH
1173: CALL 14284 0 3
1177: ST_TO_ADDR
// if Brown then
1178: LD_EXP 22
1182: IFFALSE 1199
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1184: LD_EXP 22
1188: PPUSH
1189: LD_INT 13
1191: PPUSH
1192: LD_INT 0
1194: PPUSH
1195: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1199: LD_ADDR_EXP 23
1203: PUSH
1204: LD_STRING Gladstone
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_STRING 12a_
1215: PPUSH
1216: CALL 14284 0 3
1220: ST_TO_ADDR
// if Gladstone then
1221: LD_EXP 23
1225: IFFALSE 1242
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1227: LD_EXP 23
1231: PPUSH
1232: LD_INT 13
1234: PPUSH
1235: LD_INT 0
1237: PPUSH
1238: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1242: LD_ADDR_EXP 24
1246: PUSH
1247: LD_STRING Houten
1249: PPUSH
1250: LD_EXP 1
1254: NOT
1255: PPUSH
1256: LD_STRING 12a_
1258: PPUSH
1259: CALL 14284 0 3
1263: ST_TO_ADDR
// if Houten then
1264: LD_EXP 24
1268: IFFALSE 1285
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1270: LD_EXP 24
1274: PPUSH
1275: LD_INT 13
1277: PPUSH
1278: LD_INT 0
1280: PPUSH
1281: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1285: LD_ADDR_EXP 25
1289: PUSH
1290: LD_STRING Cornell
1292: PPUSH
1293: LD_EXP 1
1297: NOT
1298: PPUSH
1299: LD_STRING 12a_
1301: PPUSH
1302: CALL 14284 0 3
1306: ST_TO_ADDR
// if Cornel then
1307: LD_EXP 25
1311: IFFALSE 1328
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1313: LD_EXP 25
1317: PPUSH
1318: LD_INT 13
1320: PPUSH
1321: LD_INT 0
1323: PPUSH
1324: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1328: LD_ADDR_EXP 26
1332: PUSH
1333: LD_STRING Gary
1335: PPUSH
1336: LD_EXP 1
1340: NOT
1341: PPUSH
1342: LD_STRING 12a_
1344: PPUSH
1345: CALL 14284 0 3
1349: ST_TO_ADDR
// if Gary then
1350: LD_EXP 26
1354: IFFALSE 1371
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1356: LD_EXP 26
1360: PPUSH
1361: LD_INT 13
1363: PPUSH
1364: LD_INT 0
1366: PPUSH
1367: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1371: LD_ADDR_EXP 27
1375: PUSH
1376: LD_STRING Frank
1378: PPUSH
1379: LD_EXP 1
1383: NOT
1384: PPUSH
1385: LD_STRING 12a_
1387: PPUSH
1388: CALL 14284 0 3
1392: ST_TO_ADDR
// if Frank then
1393: LD_EXP 27
1397: IFFALSE 1414
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1399: LD_EXP 27
1403: PPUSH
1404: LD_INT 13
1406: PPUSH
1407: LD_INT 0
1409: PPUSH
1410: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1414: LD_ADDR_EXP 28
1418: PUSH
1419: LD_STRING Kikuchi
1421: PPUSH
1422: LD_EXP 1
1426: NOT
1427: PPUSH
1428: LD_STRING 12a_
1430: PPUSH
1431: CALL 14284 0 3
1435: ST_TO_ADDR
// if Kikuchi then
1436: LD_EXP 28
1440: IFFALSE 1457
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1442: LD_EXP 28
1446: PPUSH
1447: LD_INT 13
1449: PPUSH
1450: LD_INT 0
1452: PPUSH
1453: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1457: LD_ADDR_EXP 29
1461: PUSH
1462: LD_STRING Simms
1464: PPUSH
1465: LD_EXP 1
1469: NOT
1470: PPUSH
1471: LD_STRING 12a_
1473: PPUSH
1474: CALL 14284 0 3
1478: ST_TO_ADDR
// if Simms then
1479: LD_EXP 29
1483: IFFALSE 1500
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1485: LD_EXP 29
1489: PPUSH
1490: LD_INT 13
1492: PPUSH
1493: LD_INT 0
1495: PPUSH
1496: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1500: LD_ADDR_EXP 30
1504: PUSH
1505: LD_STRING Joan
1507: PPUSH
1508: LD_EXP 1
1512: NOT
1513: PPUSH
1514: LD_STRING 12a_
1516: PPUSH
1517: CALL 14284 0 3
1521: ST_TO_ADDR
// if Joan then
1522: LD_EXP 30
1526: IFFALSE 1543
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1528: LD_EXP 30
1532: PPUSH
1533: LD_INT 13
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1543: LD_ADDR_EXP 31
1547: PUSH
1548: LD_STRING DeltaDoctor
1550: PPUSH
1551: LD_EXP 1
1555: NOT
1556: PPUSH
1557: LD_STRING 12a_
1559: PPUSH
1560: CALL 14284 0 3
1564: ST_TO_ADDR
// if DeltaDoctor then
1565: LD_EXP 31
1569: IFFALSE 1586
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1571: LD_EXP 31
1575: PPUSH
1576: LD_INT 13
1578: PPUSH
1579: LD_INT 0
1581: PPUSH
1582: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1586: LD_ADDR_VAR 0 4
1590: PUSH
1591: LD_STRING 12a_others
1593: PPUSH
1594: CALL_OW 31
1598: ST_TO_ADDR
// if tmp then
1599: LD_VAR 0 4
1603: IFFALSE 1637
// for i in tmp do
1605: LD_ADDR_VAR 0 3
1609: PUSH
1610: LD_VAR 0 4
1614: PUSH
1615: FOR_IN
1616: IFFALSE 1635
// PlaceUnitArea ( i , alliance_start , false ) ;
1618: LD_VAR 0 3
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
1633: GO 1615
1635: POP
1636: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 3
1642: PPUSH
1643: LD_INT 3
1645: PPUSH
1646: LD_INT 12
1648: PPUSH
1649: LD_INT 100
1651: PPUSH
1652: CALL 21399 0 5
// veh := CreateVehicle ;
1656: LD_ADDR_VAR 0 2
1660: PUSH
1661: CALL_OW 45
1665: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1666: LD_VAR 0 2
1670: PPUSH
1671: LD_INT 2
1673: PPUSH
1674: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1678: LD_VAR 0 2
1682: PPUSH
1683: LD_INT 60
1685: PPUSH
1686: LD_INT 6
1688: PPUSH
1689: LD_INT 0
1691: PPUSH
1692: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1696: LD_VAR 0 2
1700: PPUSH
1701: LD_INT 4
1703: PPUSH
1704: LD_INT 30
1706: PPUSH
1707: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1711: LD_STRING 11_artifact_captured
1713: PPUSH
1714: LD_INT 0
1716: PPUSH
1717: CALL_OW 30
1721: IFFALSE 1797
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1723: LD_INT 3
1725: PPUSH
1726: LD_INT 3
1728: PPUSH
1729: LD_INT 3
1731: PPUSH
1732: LD_INT 12
1734: PPUSH
1735: LD_INT 100
1737: PPUSH
1738: CALL 21399 0 5
// veh := CreateVehicle ;
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: CALL_OW 45
1751: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1752: LD_VAR 0 2
1756: PPUSH
1757: LD_INT 3
1759: PPUSH
1760: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1764: LD_VAR 0 2
1768: PPUSH
1769: LD_INT 75
1771: PPUSH
1772: LD_INT 6
1774: PPUSH
1775: LD_INT 0
1777: PPUSH
1778: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1782: LD_VAR 0 2
1786: PPUSH
1787: LD_INT 4
1789: PPUSH
1790: LD_INT 50
1792: PPUSH
1793: CALL_OW 290
// end ; end ;
1797: LD_VAR 0 1
1801: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1802: LD_INT 0
1804: PPUSH
1805: PPUSH
1806: PPUSH
1807: PPUSH
// uc_side := 6 ;
1808: LD_ADDR_OWVAR 20
1812: PUSH
1813: LD_INT 6
1815: ST_TO_ADDR
// uc_nation := 3 ;
1816: LD_ADDR_OWVAR 21
1820: PUSH
1821: LD_INT 3
1823: ST_TO_ADDR
// InitHc ;
1824: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1828: LD_ADDR_EXP 32
1832: PUSH
1833: LD_STRING Gossudarov
1835: PPUSH
1836: CALL_OW 25
1840: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1841: LD_ADDR_EXP 33
1845: PUSH
1846: LD_STRING Kirilenkova
1848: PPUSH
1849: CALL_OW 25
1853: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1854: LD_ADDR_EXP 34
1858: PUSH
1859: LD_STRING Titov
1861: PPUSH
1862: CALL_OW 25
1866: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1867: LD_ADDR_EXP 39
1871: PUSH
1872: LD_STRING Oblukov
1874: PPUSH
1875: CALL_OW 25
1879: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1880: LD_ADDR_EXP 36
1884: PUSH
1885: LD_STRING Dolgov
1887: PPUSH
1888: CALL_OW 25
1892: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1893: LD_ADDR_EXP 37
1897: PUSH
1898: LD_STRING Petrosyan
1900: PPUSH
1901: CALL_OW 25
1905: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1906: LD_ADDR_EXP 38
1910: PUSH
1911: LD_STRING Scholtze
1913: PPUSH
1914: CALL_OW 25
1918: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1919: LD_ADDR_EXP 40
1923: PUSH
1924: LD_STRING Kapitsova
1926: PPUSH
1927: CALL_OW 25
1931: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1932: LD_ADDR_VAR 0 2
1936: PUSH
1937: LD_EXP 32
1941: PUSH
1942: LD_EXP 33
1946: PUSH
1947: LD_EXP 34
1951: PUSH
1952: LD_EXP 39
1956: PUSH
1957: LD_EXP 36
1961: PUSH
1962: LD_EXP 37
1966: PUSH
1967: LD_EXP 38
1971: PUSH
1972: LD_EXP 40
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: LIST
1986: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1987: LD_INT 1
1989: PPUSH
1990: LD_INT 4
1992: PPUSH
1993: LD_INT 8
1995: PPUSH
1996: CALL_OW 380
// un := CreateHuman ;
2000: LD_ADDR_VAR 0 4
2004: PUSH
2005: CALL_OW 44
2009: ST_TO_ADDR
// tmp := tmp ^ un ;
2010: LD_ADDR_VAR 0 2
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_VAR 0 4
2024: ADD
2025: ST_TO_ADDR
// for i in tmp do
2026: LD_ADDR_VAR 0 3
2030: PUSH
2031: LD_VAR 0 2
2035: PUSH
2036: FOR_IN
2037: IFFALSE 2056
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2039: LD_VAR 0 3
2043: PPUSH
2044: LD_INT 14
2046: PPUSH
2047: LD_INT 0
2049: PPUSH
2050: CALL_OW 49
2054: GO 2036
2056: POP
2057: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_EXP 3
2067: PPUSH
2068: CALL_OW 250
2072: PPUSH
2073: LD_EXP 3
2077: PPUSH
2078: CALL_OW 251
2082: PPUSH
2083: CALL_OW 111
// end ;
2087: LD_VAR 0 1
2091: RET
// export function PrepareBelkov ; begin
2092: LD_INT 0
2094: PPUSH
// uc_side := 4 ;
2095: LD_ADDR_OWVAR 20
2099: PUSH
2100: LD_INT 4
2102: ST_TO_ADDR
// uc_nation := 3 ;
2103: LD_ADDR_OWVAR 21
2107: PUSH
2108: LD_INT 3
2110: ST_TO_ADDR
// InitHc ;
2111: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2115: LD_ADDR_EXP 47
2119: PUSH
2120: LD_STRING Belkov
2122: PPUSH
2123: CALL_OW 25
2127: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2128: LD_EXP 47
2132: PPUSH
2133: LD_INT 14
2135: PPUSH
2136: LD_INT 0
2138: PPUSH
2139: CALL_OW 49
// end ;
2143: LD_VAR 0 1
2147: RET
// export function PrepareGnyevko ; begin
2148: LD_INT 0
2150: PPUSH
// uc_side := 4 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 4
2158: ST_TO_ADDR
// uc_nation := 3 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 3
2166: ST_TO_ADDR
// InitHc ;
2167: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2171: LD_ADDR_EXP 48
2175: PUSH
2176: LD_STRING Gnyevko
2178: PPUSH
2179: CALL_OW 25
2183: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2184: LD_EXP 48
2188: PPUSH
2189: LD_INT 14
2191: PPUSH
2192: LD_INT 0
2194: PPUSH
2195: CALL_OW 49
// end ;
2199: LD_VAR 0 1
2203: RET
// export function PrepareBurlak ; var i , tmp ; begin
2204: LD_INT 0
2206: PPUSH
2207: PPUSH
2208: PPUSH
// uc_side := 4 ;
2209: LD_ADDR_OWVAR 20
2213: PUSH
2214: LD_INT 4
2216: ST_TO_ADDR
// uc_nation := 3 ;
2217: LD_ADDR_OWVAR 21
2221: PUSH
2222: LD_INT 3
2224: ST_TO_ADDR
// InitHc ;
2225: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2229: LD_ADDR_EXP 46
2233: PUSH
2234: LD_STRING Burlak
2236: PPUSH
2237: CALL_OW 25
2241: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2242: LD_INT 24
2244: PUSH
2245: LD_INT 23
2247: PUSH
2248: LD_INT 22
2250: PUSH
2251: EMPTY
2252: LIST
2253: LIST
2254: LIST
2255: PUSH
2256: LD_OWVAR 67
2260: ARRAY
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: LD_INT 1
2267: PPUSH
2268: LD_INT 45
2270: PUSH
2271: LD_INT 44
2273: PUSH
2274: LD_INT 43
2276: PUSH
2277: EMPTY
2278: LIST
2279: LIST
2280: LIST
2281: PUSH
2282: LD_OWVAR 67
2286: ARRAY
2287: PPUSH
2288: LD_INT 0
2290: PPUSH
2291: CALL 21399 0 5
// Masha := CreateVehicle ;
2295: LD_ADDR_EXP 49
2299: PUSH
2300: CALL_OW 45
2304: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2305: LD_EXP 49
2309: PUSH
2310: LD_EXP 46
2314: PUSH
2315: EMPTY
2316: LIST
2317: LIST
2318: PPUSH
2319: LD_INT 499
2321: PPUSH
2322: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2326: LD_EXP 49
2330: PPUSH
2331: LD_INT 3
2333: PPUSH
2334: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2338: LD_EXP 49
2342: PPUSH
2343: LD_INT 1
2345: PPUSH
2346: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2350: LD_INT 1
2352: PPUSH
2353: LD_INT 18
2355: PPUSH
2356: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2360: LD_INT 35
2362: PPUSH
2363: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 18
2374: PPUSH
2375: EMPTY
2376: PPUSH
2377: CALL_OW 70
2381: ST_TO_ADDR
// if tmp then
2382: LD_VAR 0 3
2386: IFFALSE 2420
// for i in tmp do
2388: LD_ADDR_VAR 0 2
2392: PUSH
2393: LD_VAR 0 3
2397: PUSH
2398: FOR_IN
2399: IFFALSE 2418
// ComMoveXY ( i , 114 , 9 ) ;
2401: LD_VAR 0 2
2405: PPUSH
2406: LD_INT 114
2408: PPUSH
2409: LD_INT 9
2411: PPUSH
2412: CALL_OW 111
2416: GO 2398
2418: POP
2419: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2420: LD_INT 18
2422: PPUSH
2423: EMPTY
2424: PPUSH
2425: CALL_OW 70
2429: NOT
2430: PUSH
2431: LD_INT 123
2433: PPUSH
2434: LD_INT 3
2436: PPUSH
2437: CALL_OW 428
2441: PUSH
2442: LD_INT 0
2444: EQUAL
2445: AND
2446: IFFALSE 2360
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2448: LD_EXP 49
2452: PPUSH
2453: LD_INT 123
2455: PPUSH
2456: LD_INT 3
2458: PPUSH
2459: LD_INT 0
2461: PPUSH
2462: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2466: LD_EXP 46
2470: PPUSH
2471: LD_INT 125
2473: PPUSH
2474: LD_INT 1
2476: PPUSH
2477: LD_INT 0
2479: PPUSH
2480: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2484: LD_EXP 46
2488: PPUSH
2489: LD_EXP 49
2493: PPUSH
2494: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2498: LD_INT 10
2500: PPUSH
2501: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2505: LD_EXP 49
2509: PPUSH
2510: LD_INT 110
2512: PPUSH
2513: LD_INT 10
2515: PPUSH
2516: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2520: LD_ADDR_EXP 42
2524: PUSH
2525: LD_STRING Petrovova
2527: PPUSH
2528: CALL_OW 25
2532: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2533: LD_ADDR_EXP 44
2537: PUSH
2538: LD_STRING Kuzmov
2540: PPUSH
2541: CALL_OW 25
2545: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2546: LD_ADDR_EXP 43
2550: PUSH
2551: LD_STRING Kovalyuk
2553: PPUSH
2554: CALL_OW 25
2558: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2559: LD_ADDR_EXP 41
2563: PUSH
2564: LD_STRING Lipshchin
2566: PPUSH
2567: CALL_OW 25
2571: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2572: LD_ADDR_EXP 45
2576: PUSH
2577: LD_STRING Karamazov
2579: PPUSH
2580: CALL_OW 25
2584: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2585: LD_ADDR_VAR 0 3
2589: PUSH
2590: LD_EXP 42
2594: PUSH
2595: LD_EXP 44
2599: PUSH
2600: LD_EXP 43
2604: PUSH
2605: LD_EXP 41
2609: PUSH
2610: LD_EXP 45
2614: PUSH
2615: EMPTY
2616: LIST
2617: LIST
2618: LIST
2619: LIST
2620: LIST
2621: ST_TO_ADDR
// for i in tmp do
2622: LD_ADDR_VAR 0 2
2626: PUSH
2627: LD_VAR 0 3
2631: PUSH
2632: FOR_IN
2633: IFFALSE 2672
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2635: LD_VAR 0 2
2639: PPUSH
2640: LD_INT 399
2642: PPUSH
2643: LD_INT 799
2645: PPUSH
2646: CALL_OW 12
2650: PPUSH
2651: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2655: LD_VAR 0 2
2659: PPUSH
2660: LD_INT 19
2662: PPUSH
2663: LD_INT 0
2665: PPUSH
2666: CALL_OW 49
// end ;
2670: GO 2632
2672: POP
2673: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2674: LD_VAR 0 3
2678: PPUSH
2679: LD_INT 116
2681: PPUSH
2682: LD_INT 8
2684: PPUSH
2685: CALL_OW 111
// AddComHold ( tmp ) ;
2689: LD_VAR 0 3
2693: PPUSH
2694: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2698: LD_ADDR_VAR 0 2
2702: PUSH
2703: LD_VAR 0 3
2707: PPUSH
2708: LD_INT 25
2710: PUSH
2711: LD_INT 1
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PPUSH
2718: CALL_OW 72
2722: PUSH
2723: FOR_IN
2724: IFFALSE 2764
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2726: LD_VAR 0 2
2730: PPUSH
2731: LD_INT 20
2733: PPUSH
2734: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2738: LD_VAR 0 2
2742: PPUSH
2743: LD_INT 147
2745: PPUSH
2746: LD_INT 45
2748: PPUSH
2749: CALL_OW 178
// AddComCrawl ( i ) ;
2753: LD_VAR 0 2
2757: PPUSH
2758: CALL_OW 197
// end ;
2762: GO 2723
2764: POP
2765: POP
// repeat wait ( 0 0$1 ) ;
2766: LD_INT 35
2768: PPUSH
2769: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2773: LD_EXP 49
2777: PPUSH
2778: LD_INT 110
2780: PPUSH
2781: LD_INT 10
2783: PPUSH
2784: CALL_OW 307
2788: PUSH
2789: LD_EXP 49
2793: PPUSH
2794: CALL_OW 305
2798: NOT
2799: OR
2800: IFFALSE 2766
// ComStop ( Burlak ) ;
2802: LD_EXP 46
2806: PPUSH
2807: CALL_OW 141
// AddComHold ( Burlak ) ;
2811: LD_EXP 46
2815: PPUSH
2816: CALL_OW 200
// end ; end_of_file
2820: LD_VAR 0 1
2824: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2825: LD_INT 0
2827: PPUSH
2828: PPUSH
2829: PPUSH
2830: PPUSH
// uc_side := 3 ;
2831: LD_ADDR_OWVAR 20
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// uc_nation := 3 ;
2839: LD_ADDR_OWVAR 21
2843: PUSH
2844: LD_INT 3
2846: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2847: LD_ADDR_EXP 50
2851: PUSH
2852: LD_INT 47
2854: PPUSH
2855: LD_INT 4
2857: PPUSH
2858: LD_STRING 
2860: PPUSH
2861: LD_INT 7
2863: PUSH
2864: LD_INT 8
2866: PUSH
2867: LD_INT 9
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: LIST
2874: PUSH
2875: LD_OWVAR 67
2879: ARRAY
2880: PPUSH
2881: LD_INT 10000
2883: PUSH
2884: LD_INT 3000
2886: PUSH
2887: LD_INT 300
2889: PUSH
2890: EMPTY
2891: LIST
2892: LIST
2893: LIST
2894: PPUSH
2895: LD_INT 9
2897: PUSH
2898: LD_INT 5
2900: PUSH
2901: LD_INT 6
2903: PUSH
2904: LD_INT 6
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: PPUSH
2913: CALL 24808 0 6
2917: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2918: LD_ADDR_EXP 59
2922: PUSH
2923: LD_EXP 59
2927: PPUSH
2928: LD_INT 2
2930: PPUSH
2931: LD_EXP 50
2935: PPUSH
2936: CALL_OW 1
2940: ST_TO_ADDR
// tmp := [ ] ;
2941: LD_ADDR_VAR 0 4
2945: PUSH
2946: EMPTY
2947: ST_TO_ADDR
// for i = 1 to 4 do
2948: LD_ADDR_VAR 0 2
2952: PUSH
2953: DOUBLE
2954: LD_INT 1
2956: DEC
2957: ST_TO_ADDR
2958: LD_INT 4
2960: PUSH
2961: FOR_TO
2962: IFFALSE 3055
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2964: LD_INT 22
2966: PPUSH
2967: LD_INT 3
2969: PPUSH
2970: LD_INT 3
2972: PPUSH
2973: LD_INT 43
2975: PUSH
2976: LD_INT 45
2978: PUSH
2979: LD_INT 45
2981: PUSH
2982: LD_INT 44
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: PUSH
2991: LD_VAR 0 2
2995: PUSH
2996: LD_INT 4
2998: MOD
2999: PUSH
3000: LD_INT 1
3002: PLUS
3003: ARRAY
3004: PPUSH
3005: LD_INT 100
3007: PPUSH
3008: CALL 21399 0 5
// veh := CreateVehicle ;
3012: LD_ADDR_VAR 0 3
3016: PUSH
3017: CALL_OW 45
3021: ST_TO_ADDR
// tmp := tmp ^ veh ;
3022: LD_ADDR_VAR 0 4
3026: PUSH
3027: LD_VAR 0 4
3031: PUSH
3032: LD_VAR 0 3
3036: ADD
3037: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3038: LD_VAR 0 3
3042: PPUSH
3043: LD_INT 2
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 49
// end ;
3053: GO 2961
3055: POP
3056: POP
// russian_guard := tmp ;
3057: LD_ADDR_EXP 51
3061: PUSH
3062: LD_VAR 0 4
3066: ST_TO_ADDR
// end ;
3067: LD_VAR 0 1
3071: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
3072: LD_INT 47
3074: PPUSH
3075: CALL_OW 302
3079: PUSH
3080: LD_EXP 6
3084: AND
3085: IFFALSE 3687
3087: GO 3089
3089: DISABLE
3090: LD_INT 0
3092: PPUSH
3093: PPUSH
3094: PPUSH
3095: PPUSH
3096: PPUSH
3097: PPUSH
// begin enable ;
3098: ENABLE
// base := 2 ;
3099: LD_ADDR_VAR 0 2
3103: PUSH
3104: LD_INT 2
3106: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3107: LD_ADDR_VAR 0 4
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: LD_INT 0
3117: PUSH
3118: LD_INT 0
3120: PUSH
3121: LD_INT 0
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 0
3129: PUSH
3130: LD_INT 0
3132: PUSH
3133: LD_INT 0
3135: PUSH
3136: LD_INT 1
3138: PUSH
3139: LD_INT 0
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3154: LD_ADDR_VAR 0 3
3158: PUSH
3159: LD_INT 22
3161: PUSH
3162: LD_INT 1
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: LD_INT 45
3170: PUSH
3171: EMPTY
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: PUSH
3177: LD_INT 21
3179: PUSH
3180: LD_INT 1
3182: PUSH
3183: LD_INT 3
3185: PUSH
3186: LD_INT 45
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 22
3197: PUSH
3198: LD_INT 1
3200: PUSH
3201: LD_INT 3
3203: PUSH
3204: LD_INT 45
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 23
3215: PUSH
3216: LD_INT 1
3218: PUSH
3219: LD_INT 3
3221: PUSH
3222: LD_INT 46
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: LIST
3229: LIST
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: LIST
3235: LIST
3236: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3237: LD_ADDR_VAR 0 1
3241: PUSH
3242: DOUBLE
3243: LD_INT 1
3245: DEC
3246: ST_TO_ADDR
3247: LD_OWVAR 67
3251: PUSH
3252: LD_OWVAR 1
3256: PUSH
3257: LD_INT 21000
3259: DIV
3260: PLUS
3261: PUSH
3262: FOR_TO
3263: IFFALSE 3351
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3265: LD_ADDR_VAR 0 3
3269: PUSH
3270: LD_VAR 0 3
3274: PPUSH
3275: LD_VAR 0 3
3279: PUSH
3280: LD_INT 1
3282: PLUS
3283: PPUSH
3284: LD_INT 23
3286: PUSH
3287: LD_INT 24
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: LD_INT 1
3296: PPUSH
3297: LD_INT 2
3299: PPUSH
3300: CALL_OW 12
3304: ARRAY
3305: PUSH
3306: LD_INT 1
3308: PUSH
3309: LD_INT 3
3311: PUSH
3312: LD_INT 46
3314: PUSH
3315: LD_INT 47
3317: PUSH
3318: LD_INT 45
3320: PUSH
3321: EMPTY
3322: LIST
3323: LIST
3324: LIST
3325: PUSH
3326: LD_INT 1
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: CALL_OW 12
3336: ARRAY
3337: PUSH
3338: EMPTY
3339: LIST
3340: LIST
3341: LIST
3342: LIST
3343: PPUSH
3344: CALL_OW 2
3348: ST_TO_ADDR
3349: GO 3262
3351: POP
3352: POP
// MC_InsertProduceList ( base , tmp ) ;
3353: LD_VAR 0 2
3357: PPUSH
3358: LD_VAR 0 3
3362: PPUSH
3363: CALL 81144 0 2
// repeat wait ( 0 0$1 ) ;
3367: LD_INT 35
3369: PPUSH
3370: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3374: LD_EXP 78
3378: PUSH
3379: LD_VAR 0 2
3383: ARRAY
3384: PUSH
3385: LD_INT 6
3387: GREATER
3388: IFFALSE 3367
// wait ( 0 0$20 ) ;
3390: LD_INT 700
3392: PPUSH
3393: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3397: LD_ADDR_VAR 0 5
3401: PUSH
3402: LD_INT 71
3404: PUSH
3405: LD_INT 19
3407: PUSH
3408: EMPTY
3409: LIST
3410: LIST
3411: PUSH
3412: LD_INT 91
3414: PUSH
3415: LD_INT 67
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: PUSH
3422: LD_INT 52
3424: PUSH
3425: LD_INT 44
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PUSH
3432: LD_INT 68
3434: PUSH
3435: LD_INT 48
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3448: LD_ADDR_VAR 0 6
3452: PUSH
3453: LD_EXP 78
3457: PUSH
3458: LD_VAR 0 2
3462: ARRAY
3463: PUSH
3464: LD_EXP 78
3468: PUSH
3469: LD_VAR 0 2
3473: ARRAY
3474: PPUSH
3475: LD_INT 2
3477: PUSH
3478: LD_INT 34
3480: PUSH
3481: LD_INT 51
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: PUSH
3488: LD_INT 34
3490: PUSH
3491: LD_INT 52
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: LIST
3502: PPUSH
3503: CALL_OW 72
3507: DIFF
3508: ST_TO_ADDR
// if not attackers then
3509: LD_VAR 0 6
3513: NOT
3514: IFFALSE 3518
// exit ;
3516: GO 3687
// ru_attackers := attackers ;
3518: LD_ADDR_EXP 52
3522: PUSH
3523: LD_VAR 0 6
3527: ST_TO_ADDR
// for i = 1 to attackers do
3528: LD_ADDR_VAR 0 1
3532: PUSH
3533: DOUBLE
3534: LD_INT 1
3536: DEC
3537: ST_TO_ADDR
3538: LD_VAR 0 6
3542: PUSH
3543: FOR_TO
3544: IFFALSE 3621
// begin case i mod 3 of 0 :
3546: LD_VAR 0 1
3550: PUSH
3551: LD_INT 3
3553: MOD
3554: PUSH
3555: LD_INT 0
3557: DOUBLE
3558: EQUAL
3559: IFTRUE 3563
3561: GO 3566
3563: POP
// ; 1 :
3564: GO 3619
3566: LD_INT 1
3568: DOUBLE
3569: EQUAL
3570: IFTRUE 3574
3572: GO 3592
3574: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3575: LD_VAR 0 1
3579: PPUSH
3580: LD_INT 32
3582: PPUSH
3583: LD_INT 49
3585: PPUSH
3586: CALL_OW 114
3590: GO 3619
3592: LD_INT 2
3594: DOUBLE
3595: EQUAL
3596: IFTRUE 3600
3598: GO 3618
3600: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3601: LD_VAR 0 1
3605: PPUSH
3606: LD_INT 117
3608: PPUSH
3609: LD_INT 107
3611: PPUSH
3612: CALL_OW 114
3616: GO 3619
3618: POP
// end ;
3619: GO 3543
3621: POP
3622: POP
// repeat wait ( 0 0$1 ) ;
3623: LD_INT 35
3625: PPUSH
3626: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3630: LD_VAR 0 6
3634: PPUSH
3635: LD_INT 60
3637: PUSH
3638: EMPTY
3639: LIST
3640: PPUSH
3641: CALL_OW 72
3645: NOT
3646: IFFALSE 3623
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3648: LD_VAR 0 2
3652: PPUSH
3653: LD_VAR 0 6
3657: PPUSH
3658: LD_VAR 0 5
3662: PPUSH
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL 81329 0 4
// if not first_attack then
3672: LD_EXP 7
3676: NOT
3677: IFFALSE 3687
// first_attack := true ;
3679: LD_ADDR_EXP 7
3683: PUSH
3684: LD_INT 1
3686: ST_TO_ADDR
// end ; end_of_file
3687: PPOPN 6
3689: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3690: LD_INT 0
3692: PPUSH
3693: PPUSH
3694: PPUSH
3695: PPUSH
3696: PPUSH
3697: PPUSH
3698: PPUSH
// uc_side := 2 ;
3699: LD_ADDR_OWVAR 20
3703: PUSH
3704: LD_INT 2
3706: ST_TO_ADDR
// uc_nation := 2 ;
3707: LD_ADDR_OWVAR 21
3711: PUSH
3712: LD_INT 2
3714: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3715: LD_ADDR_EXP 55
3719: PUSH
3720: LD_STRING Abdul
3722: PPUSH
3723: CALL_OW 25
3727: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3728: LD_EXP 55
3732: PPUSH
3733: LD_INT 11
3735: PPUSH
3736: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3740: LD_EXP 55
3744: PPUSH
3745: LD_INT 1
3747: PPUSH
3748: CALL_OW 52
// vc_chassis := 31 ;
3752: LD_ADDR_OWVAR 37
3756: PUSH
3757: LD_INT 31
3759: ST_TO_ADDR
// vc_control := control_rider ;
3760: LD_ADDR_OWVAR 38
3764: PUSH
3765: LD_INT 4
3767: ST_TO_ADDR
// mastodont := CreateVehicle ;
3768: LD_ADDR_EXP 56
3772: PUSH
3773: CALL_OW 45
3777: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3778: LD_EXP 56
3782: PPUSH
3783: LD_INT 153
3785: PPUSH
3786: LD_INT 71
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// InitVc ;
3796: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3800: LD_ADDR_EXP 53
3804: PUSH
3805: LD_INT 1
3807: PPUSH
3808: LD_INT 3
3810: PPUSH
3811: LD_STRING 
3813: PPUSH
3814: LD_INT 7
3816: PUSH
3817: LD_INT 8
3819: PUSH
3820: LD_INT 9
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: PUSH
3828: LD_OWVAR 67
3832: ARRAY
3833: PPUSH
3834: LD_INT 5000
3836: PUSH
3837: LD_INT 1000
3839: PUSH
3840: LD_INT 300
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: PPUSH
3848: LD_INT 22
3850: PUSH
3851: LD_INT 5
3853: PUSH
3854: LD_INT 6
3856: PUSH
3857: LD_INT 9
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: LIST
3864: LIST
3865: PPUSH
3866: CALL 24808 0 6
3870: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3871: LD_ADDR_EXP 59
3875: PUSH
3876: LD_EXP 59
3880: PPUSH
3881: LD_INT 1
3883: PPUSH
3884: LD_EXP 53
3888: PPUSH
3889: CALL_OW 1
3893: ST_TO_ADDR
// tmp := [ ] ;
3894: LD_ADDR_VAR 0 4
3898: PUSH
3899: EMPTY
3900: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3901: LD_ADDR_OWVAR 37
3905: PUSH
3906: LD_INT 14
3908: ST_TO_ADDR
// vc_engine := engine_siberite ;
3909: LD_ADDR_OWVAR 39
3913: PUSH
3914: LD_INT 3
3916: ST_TO_ADDR
// vc_control := control_manual ;
3917: LD_ADDR_OWVAR 38
3921: PUSH
3922: LD_INT 1
3924: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3925: LD_ADDR_OWVAR 40
3929: PUSH
3930: LD_INT 31
3932: ST_TO_ADDR
// for i = 1 to 3 do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: DOUBLE
3939: LD_INT 1
3941: DEC
3942: ST_TO_ADDR
3943: LD_INT 3
3945: PUSH
3946: FOR_TO
3947: IFFALSE 4191
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3949: LD_ADDR_VAR 0 5
3953: PUSH
3954: LD_INT 153
3956: PUSH
3957: LD_INT 71
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PUSH
3964: LD_INT 155
3966: PUSH
3967: LD_INT 81
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PUSH
3978: LD_VAR 0 2
3982: PUSH
3983: LD_INT 2
3985: MOD
3986: PUSH
3987: LD_INT 1
3989: PLUS
3990: ARRAY
3991: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3992: LD_INT 0
3994: PPUSH
3995: LD_INT 3
3997: PPUSH
3998: LD_INT 7
4000: PUSH
4001: LD_INT 8
4003: PUSH
4004: LD_INT 9
4006: PUSH
4007: EMPTY
4008: LIST
4009: LIST
4010: LIST
4011: PUSH
4012: LD_OWVAR 67
4016: ARRAY
4017: PPUSH
4018: CALL_OW 380
// un := CreateVehicle ;
4022: LD_ADDR_VAR 0 6
4026: PUSH
4027: CALL_OW 45
4031: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4032: LD_VAR 0 6
4036: PPUSH
4037: LD_INT 0
4039: PPUSH
4040: LD_INT 5
4042: PPUSH
4043: CALL_OW 12
4047: PPUSH
4048: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4052: LD_VAR 0 6
4056: PPUSH
4057: LD_VAR 0 5
4061: PUSH
4062: LD_INT 1
4064: ARRAY
4065: PPUSH
4066: LD_VAR 0 5
4070: PUSH
4071: LD_INT 2
4073: ARRAY
4074: PPUSH
4075: LD_INT 6
4077: PPUSH
4078: LD_INT 0
4080: PPUSH
4081: CALL_OW 50
// un2 := CreateHuman ;
4085: LD_ADDR_VAR 0 7
4089: PUSH
4090: CALL_OW 44
4094: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4095: LD_VAR 0 7
4099: PPUSH
4100: LD_VAR 0 6
4104: PPUSH
4105: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4109: LD_ADDR_EXP 59
4113: PUSH
4114: LD_EXP 59
4118: PPUSH
4119: LD_INT 1
4121: PUSH
4122: LD_EXP 59
4126: PUSH
4127: LD_INT 1
4129: ARRAY
4130: PUSH
4131: LD_INT 1
4133: PLUS
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: PPUSH
4139: LD_VAR 0 6
4143: PPUSH
4144: CALL 21521 0 3
4148: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4149: LD_ADDR_EXP 59
4153: PUSH
4154: LD_EXP 59
4158: PPUSH
4159: LD_INT 1
4161: PUSH
4162: LD_EXP 59
4166: PUSH
4167: LD_INT 1
4169: ARRAY
4170: PUSH
4171: LD_INT 1
4173: PLUS
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: PPUSH
4179: LD_VAR 0 7
4183: PPUSH
4184: CALL 21521 0 3
4188: ST_TO_ADDR
// end ;
4189: GO 3946
4191: POP
4192: POP
// for i = 1 to 5 do
4193: LD_ADDR_VAR 0 2
4197: PUSH
4198: DOUBLE
4199: LD_INT 1
4201: DEC
4202: ST_TO_ADDR
4203: LD_INT 5
4205: PUSH
4206: FOR_TO
4207: IFFALSE 4300
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4209: LD_INT 14
4211: PPUSH
4212: LD_INT 3
4214: PPUSH
4215: LD_INT 1
4217: PPUSH
4218: LD_INT 25
4220: PUSH
4221: LD_INT 28
4223: PUSH
4224: LD_INT 28
4226: PUSH
4227: LD_INT 26
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: LIST
4235: PUSH
4236: LD_VAR 0 2
4240: PUSH
4241: LD_INT 4
4243: MOD
4244: PUSH
4245: LD_INT 1
4247: PLUS
4248: ARRAY
4249: PPUSH
4250: LD_INT 100
4252: PPUSH
4253: CALL 21399 0 5
// veh := CreateVehicle ;
4257: LD_ADDR_VAR 0 3
4261: PUSH
4262: CALL_OW 45
4266: ST_TO_ADDR
// tmp := tmp ^ veh ;
4267: LD_ADDR_VAR 0 4
4271: PUSH
4272: LD_VAR 0 4
4276: PUSH
4277: LD_VAR 0 3
4281: ADD
4282: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4283: LD_VAR 0 3
4287: PPUSH
4288: LD_INT 1
4290: PPUSH
4291: LD_INT 0
4293: PPUSH
4294: CALL_OW 49
// end ;
4298: GO 4206
4300: POP
4301: POP
// arabian_guard := tmp ;
4302: LD_ADDR_EXP 54
4306: PUSH
4307: LD_VAR 0 4
4311: ST_TO_ADDR
// end ;
4312: LD_VAR 0 1
4316: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4317: LD_INT 22
4319: PUSH
4320: LD_INT 7
4322: PUSH
4323: EMPTY
4324: LIST
4325: LIST
4326: PUSH
4327: LD_INT 91
4329: PUSH
4330: LD_INT 1
4332: PUSH
4333: LD_INT 12
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: PPUSH
4345: CALL_OW 69
4349: PUSH
4350: LD_EXP 56
4354: PPUSH
4355: CALL_OW 256
4359: PUSH
4360: LD_INT 990
4362: LESS
4363: OR
4364: PUSH
4365: LD_EXP 55
4369: PPUSH
4370: CALL_OW 256
4374: PUSH
4375: LD_INT 990
4377: LESS
4378: OR
4379: IFFALSE 4522
4381: GO 4383
4383: DISABLE
// begin if IsInUnit ( Abdul ) then
4384: LD_EXP 55
4388: PPUSH
4389: CALL_OW 310
4393: IFFALSE 4404
// ComExitBuilding ( Abdul ) ;
4395: LD_EXP 55
4399: PPUSH
4400: CALL_OW 122
// if Mastodont then
4404: LD_EXP 56
4408: IFFALSE 4425
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4410: LD_EXP 56
4414: PPUSH
4415: LD_INT 205
4417: PPUSH
4418: LD_INT 132
4420: PPUSH
4421: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4425: LD_EXP 55
4429: PPUSH
4430: LD_INT 205
4432: PPUSH
4433: LD_INT 132
4435: PPUSH
4436: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4440: LD_INT 35
4442: PPUSH
4443: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4447: LD_EXP 55
4451: PPUSH
4452: LD_INT 21
4454: PPUSH
4455: CALL_OW 308
4459: IFFALSE 4440
// RemoveUnit ( Abdul ) ;
4461: LD_EXP 55
4465: PPUSH
4466: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4470: LD_INT 35
4472: PPUSH
4473: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4477: LD_EXP 56
4481: PPUSH
4482: LD_INT 21
4484: PPUSH
4485: CALL_OW 308
4489: PUSH
4490: LD_EXP 56
4494: PPUSH
4495: CALL_OW 301
4499: OR
4500: IFFALSE 4470
// if IsOk ( Mastodont ) then
4502: LD_EXP 56
4506: PPUSH
4507: CALL_OW 302
4511: IFFALSE 4522
// RemoveUnit ( Mastodont ) ;
4513: LD_EXP 56
4517: PPUSH
4518: CALL_OW 64
// end ;
4522: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4523: LD_EXP 55
4527: PPUSH
4528: CALL_OW 301
4532: PUSH
4533: LD_INT 22
4535: PUSH
4536: LD_INT 2
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: PUSH
4543: LD_INT 2
4545: PUSH
4546: LD_INT 25
4548: PUSH
4549: LD_INT 1
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 25
4558: PUSH
4559: LD_INT 2
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 25
4568: PUSH
4569: LD_INT 3
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: LD_INT 25
4578: PUSH
4579: LD_INT 4
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PUSH
4586: LD_INT 25
4588: PUSH
4589: LD_INT 8
4591: PUSH
4592: EMPTY
4593: LIST
4594: LIST
4595: PUSH
4596: EMPTY
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: PPUSH
4608: CALL_OW 69
4612: PUSH
4613: LD_INT 16
4615: PUSH
4616: LD_INT 19
4618: PUSH
4619: LD_INT 22
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: LIST
4626: PUSH
4627: LD_OWVAR 67
4631: ARRAY
4632: LESS
4633: OR
4634: IFFALSE 5307
4636: GO 4638
4638: DISABLE
4639: LD_INT 0
4641: PPUSH
4642: PPUSH
4643: PPUSH
4644: PPUSH
4645: PPUSH
4646: PPUSH
// begin MC_Kill ( 1 ) ;
4647: LD_INT 1
4649: PPUSH
4650: CALL 57684 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4654: LD_ADDR_VAR 0 2
4658: PUSH
4659: LD_INT 22
4661: PUSH
4662: LD_INT 2
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: LD_INT 25
4674: PUSH
4675: LD_INT 1
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: LD_INT 25
4684: PUSH
4685: LD_INT 2
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: PUSH
4692: LD_INT 25
4694: PUSH
4695: LD_INT 3
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PUSH
4702: LD_INT 25
4704: PUSH
4705: LD_INT 4
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: LD_INT 25
4714: PUSH
4715: LD_INT 8
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PPUSH
4734: CALL_OW 69
4738: ST_TO_ADDR
// for i in tmp do
4739: LD_ADDR_VAR 0 5
4743: PUSH
4744: LD_VAR 0 2
4748: PUSH
4749: FOR_IN
4750: IFFALSE 4766
// SetTag ( i , 10 ) ;
4752: LD_VAR 0 5
4756: PPUSH
4757: LD_INT 10
4759: PPUSH
4760: CALL_OW 109
4764: GO 4749
4766: POP
4767: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4768: LD_ADDR_VAR 0 3
4772: PUSH
4773: LD_INT 22
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: LD_INT 21
4785: PUSH
4786: LD_INT 1
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: PPUSH
4797: CALL_OW 69
4801: PUSH
4802: LD_VAR 0 2
4806: DIFF
4807: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4808: LD_ADDR_VAR 0 1
4812: PUSH
4813: LD_INT 22
4815: PUSH
4816: LD_INT 2
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: LD_INT 21
4825: PUSH
4826: LD_INT 2
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: PUSH
4833: LD_INT 24
4835: PUSH
4836: LD_INT 300
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: LIST
4847: PPUSH
4848: CALL_OW 69
4852: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4853: LD_ADDR_VAR 0 4
4857: PUSH
4858: LD_VAR 0 1
4862: PPUSH
4863: LD_INT 33
4865: PUSH
4866: LD_INT 1
4868: PUSH
4869: EMPTY
4870: LIST
4871: LIST
4872: PUSH
4873: LD_INT 58
4875: PUSH
4876: EMPTY
4877: LIST
4878: PUSH
4879: EMPTY
4880: LIST
4881: LIST
4882: PPUSH
4883: CALL_OW 72
4887: ST_TO_ADDR
// for i in tmp do
4888: LD_ADDR_VAR 0 5
4892: PUSH
4893: LD_VAR 0 2
4897: PUSH
4898: FOR_IN
4899: IFFALSE 5083
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4901: LD_VAR 0 5
4905: PUSH
4906: LD_INT 55
4908: PUSH
4909: EMPTY
4910: LIST
4911: PPUSH
4912: CALL_OW 69
4916: IN
4917: IFFALSE 4936
// begin AddComMoveXY ( i , 209 , 132 ) ;
4919: LD_VAR 0 5
4923: PPUSH
4924: LD_INT 209
4926: PPUSH
4927: LD_INT 132
4929: PPUSH
4930: CALL_OW 171
// continue ;
4934: GO 4898
// end ; if IsInUnit ( i ) then
4936: LD_VAR 0 5
4940: PPUSH
4941: CALL_OW 310
4945: IFFALSE 4963
// begin ComExitBuilding ( i ) ;
4947: LD_VAR 0 5
4951: PPUSH
4952: CALL_OW 122
// wait ( 3 ) ;
4956: LD_INT 3
4958: PPUSH
4959: CALL_OW 67
// end ; if tmp_empty then
4963: LD_VAR 0 4
4967: IFFALSE 5066
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4969: LD_VAR 0 5
4973: PPUSH
4974: LD_VAR 0 4
4978: PPUSH
4979: LD_VAR 0 5
4983: PPUSH
4984: CALL_OW 74
4988: PPUSH
4989: CALL_OW 296
4993: PUSH
4994: LD_INT 25
4996: LESS
4997: IFFALSE 5066
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4999: LD_ADDR_VAR 0 6
5003: PUSH
5004: LD_VAR 0 4
5008: PPUSH
5009: LD_VAR 0 5
5013: PPUSH
5014: CALL_OW 74
5018: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5019: LD_VAR 0 5
5023: PPUSH
5024: LD_VAR 0 6
5028: PPUSH
5029: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5033: LD_VAR 0 5
5037: PPUSH
5038: LD_INT 209
5040: PPUSH
5041: LD_INT 132
5043: PPUSH
5044: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5048: LD_ADDR_VAR 0 4
5052: PUSH
5053: LD_VAR 0 4
5057: PUSH
5058: LD_VAR 0 6
5062: DIFF
5063: ST_TO_ADDR
// continue ;
5064: GO 4898
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5066: LD_VAR 0 5
5070: PPUSH
5071: LD_INT 201
5073: PPUSH
5074: LD_INT 132
5076: PPUSH
5077: CALL_OW 171
// end ;
5081: GO 4898
5083: POP
5084: POP
// for i in tmp_ape do
5085: LD_ADDR_VAR 0 5
5089: PUSH
5090: LD_VAR 0 3
5094: PUSH
5095: FOR_IN
5096: IFFALSE 5135
// begin if IsInUnit ( i ) then
5098: LD_VAR 0 5
5102: PPUSH
5103: CALL_OW 310
5107: IFFALSE 5118
// ComExitBuilding ( i ) ;
5109: LD_VAR 0 5
5113: PPUSH
5114: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5118: LD_VAR 0 5
5122: PPUSH
5123: LD_INT 201
5125: PPUSH
5126: LD_INT 132
5128: PPUSH
5129: CALL_OW 171
// end ;
5133: GO 5095
5135: POP
5136: POP
// repeat wait ( 0 0$1 ) ;
5137: LD_INT 35
5139: PPUSH
5140: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5144: LD_ADDR_VAR 0 5
5148: PUSH
5149: LD_VAR 0 2
5153: PUSH
5154: LD_VAR 0 3
5158: UNION
5159: PUSH
5160: LD_VAR 0 1
5164: UNION
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5198
// if not HasTask ( i ) then
5169: LD_VAR 0 5
5173: PPUSH
5174: CALL_OW 314
5178: NOT
5179: IFFALSE 5196
// ComMoveXY ( i , 201 , 132 ) ;
5181: LD_VAR 0 5
5185: PPUSH
5186: LD_INT 201
5188: PPUSH
5189: LD_INT 132
5191: PPUSH
5192: CALL_OW 111
5196: GO 5166
5198: POP
5199: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5200: LD_INT 21
5202: PPUSH
5203: LD_INT 22
5205: PUSH
5206: LD_INT 2
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL_OW 70
5217: IFFALSE 5258
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5219: LD_ADDR_VAR 0 5
5223: PUSH
5224: LD_INT 21
5226: PPUSH
5227: LD_INT 22
5229: PUSH
5230: LD_INT 2
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: PPUSH
5237: CALL_OW 70
5241: PUSH
5242: FOR_IN
5243: IFFALSE 5256
// RemoveUnit ( i ) ;
5245: LD_VAR 0 5
5249: PPUSH
5250: CALL_OW 64
5254: GO 5242
5256: POP
5257: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5258: LD_INT 22
5260: PUSH
5261: LD_INT 2
5263: PUSH
5264: EMPTY
5265: LIST
5266: LIST
5267: PUSH
5268: LD_INT 2
5270: PUSH
5271: LD_INT 21
5273: PUSH
5274: LD_INT 1
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PUSH
5281: LD_INT 21
5283: PUSH
5284: LD_INT 2
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: LIST
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 69
5304: NOT
5305: IFFALSE 5137
// end ;
5307: PPOPN 6
5309: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5310: LD_EXP 9
5314: PUSH
5315: LD_INT 92
5317: PPUSH
5318: LD_INT 40
5320: PPUSH
5321: CALL_OW 428
5325: PPUSH
5326: CALL_OW 266
5330: PUSH
5331: LD_INT 30
5333: EQUAL
5334: AND
5335: IFFALSE 5531
5337: GO 5339
5339: DISABLE
5340: LD_INT 0
5342: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5343: LD_ADDR_VAR 0 1
5347: PUSH
5348: LD_EXP 59
5352: PUSH
5353: LD_INT 1
5355: ARRAY
5356: PPUSH
5357: LD_INT 25
5359: PUSH
5360: LD_INT 4
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PPUSH
5367: CALL_OW 72
5371: ST_TO_ADDR
// if not sci then
5372: LD_VAR 0 1
5376: NOT
5377: IFFALSE 5381
// exit ;
5379: GO 5531
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5381: LD_ADDR_EXP 59
5385: PUSH
5386: LD_EXP 59
5390: PPUSH
5391: LD_INT 1
5393: PPUSH
5394: LD_EXP 59
5398: PUSH
5399: LD_INT 1
5401: ARRAY
5402: PUSH
5403: LD_VAR 0 1
5407: PUSH
5408: LD_INT 1
5410: ARRAY
5411: DIFF
5412: PPUSH
5413: CALL_OW 1
5417: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5418: LD_VAR 0 1
5422: PUSH
5423: LD_INT 1
5425: ARRAY
5426: PPUSH
5427: CALL_OW 310
5431: IFFALSE 5446
// ComExitBuilding ( sci [ 1 ] ) ;
5433: LD_VAR 0 1
5437: PUSH
5438: LD_INT 1
5440: ARRAY
5441: PPUSH
5442: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5446: LD_INT 2
5448: PPUSH
5449: LD_INT 105
5451: PPUSH
5452: LD_INT 14
5454: PPUSH
5455: LD_INT 20
5457: PPUSH
5458: CALL 22417 0 4
5462: PUSH
5463: LD_INT 4
5465: ARRAY
5466: PUSH
5467: LD_INT 10
5469: LESS
5470: IFFALSE 5493
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5472: LD_VAR 0 1
5476: PUSH
5477: LD_INT 1
5479: ARRAY
5480: PPUSH
5481: LD_INT 105
5483: PPUSH
5484: LD_INT 14
5486: PPUSH
5487: CALL_OW 171
5491: GO 5512
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5493: LD_VAR 0 1
5497: PUSH
5498: LD_INT 1
5500: ARRAY
5501: PPUSH
5502: LD_INT 118
5504: PPUSH
5505: LD_INT 77
5507: PPUSH
5508: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5512: LD_VAR 0 1
5516: PUSH
5517: LD_INT 1
5519: ARRAY
5520: PPUSH
5521: LD_INT 92
5523: PPUSH
5524: LD_INT 40
5526: PPUSH
5527: CALL_OW 218
// end ;
5531: PPOPN 1
5533: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5534: LD_INT 1
5536: PPUSH
5537: CALL_OW 302
5541: PUSH
5542: LD_EXP 9
5546: AND
5547: IFFALSE 6006
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
5557: PPUSH
5558: PPUSH
5559: PPUSH
// begin enable ;
5560: ENABLE
// base := 1 ;
5561: LD_ADDR_VAR 0 2
5565: PUSH
5566: LD_INT 1
5568: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5569: LD_ADDR_VAR 0 4
5573: PUSH
5574: LD_INT 0
5576: PUSH
5577: LD_INT 0
5579: PUSH
5580: LD_INT 0
5582: PUSH
5583: LD_INT 0
5585: PUSH
5586: LD_INT 0
5588: PUSH
5589: LD_INT 0
5591: PUSH
5592: LD_INT 0
5594: PUSH
5595: LD_INT 0
5597: PUSH
5598: LD_INT 1
5600: PUSH
5601: LD_INT 0
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: LIST
5614: LIST
5615: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5616: LD_ADDR_VAR 0 3
5620: PUSH
5621: LD_INT 14
5623: PUSH
5624: LD_INT 1
5626: PUSH
5627: LD_INT 2
5629: PUSH
5630: LD_INT 26
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: PUSH
5639: LD_INT 14
5641: PUSH
5642: LD_INT 1
5644: PUSH
5645: LD_INT 2
5647: PUSH
5648: LD_INT 28
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: LD_INT 13
5659: PUSH
5660: LD_INT 1
5662: PUSH
5663: LD_INT 2
5665: PUSH
5666: LD_INT 29
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: LIST
5679: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5680: LD_ADDR_VAR 0 1
5684: PUSH
5685: DOUBLE
5686: LD_INT 1
5688: DEC
5689: ST_TO_ADDR
5690: LD_OWVAR 67
5694: PUSH
5695: LD_OWVAR 1
5699: PUSH
5700: LD_INT 21000
5702: DIV
5703: PLUS
5704: PUSH
5705: FOR_TO
5706: IFFALSE 5798
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5708: LD_ADDR_VAR 0 3
5712: PUSH
5713: LD_VAR 0 3
5717: PPUSH
5718: LD_VAR 0 3
5722: PUSH
5723: LD_INT 1
5725: PLUS
5726: PPUSH
5727: LD_INT 13
5729: PUSH
5730: LD_INT 14
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: PUSH
5737: LD_INT 1
5739: PPUSH
5740: LD_INT 2
5742: PPUSH
5743: CALL_OW 12
5747: ARRAY
5748: PUSH
5749: LD_INT 1
5751: PUSH
5752: LD_INT 2
5754: PUSH
5755: LD_INT 28
5757: PUSH
5758: LD_INT 29
5760: PUSH
5761: LD_INT 25
5763: PUSH
5764: LD_INT 26
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_INT 1
5775: PPUSH
5776: LD_INT 4
5778: PPUSH
5779: CALL_OW 12
5783: ARRAY
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PPUSH
5791: CALL_OW 2
5795: ST_TO_ADDR
5796: GO 5705
5798: POP
5799: POP
// MC_InsertProduceList ( base , tmp ) ;
5800: LD_VAR 0 2
5804: PPUSH
5805: LD_VAR 0 3
5809: PPUSH
5810: CALL 81144 0 2
// repeat wait ( 0 0$1 ) ;
5814: LD_INT 35
5816: PPUSH
5817: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5821: LD_EXP 78
5825: PUSH
5826: LD_VAR 0 2
5830: ARRAY
5831: PUSH
5832: LD_INT 6
5834: GREATER
5835: IFFALSE 5814
// wait ( 0 0$20 ) ;
5837: LD_INT 700
5839: PPUSH
5840: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5844: LD_ADDR_VAR 0 5
5848: PUSH
5849: LD_INT 124
5851: PUSH
5852: LD_INT 85
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: LD_INT 90
5861: PUSH
5862: LD_INT 61
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: PUSH
5869: LD_INT 69
5871: PUSH
5872: LD_INT 48
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: PUSH
5879: LD_INT 68
5881: PUSH
5882: LD_INT 48
5884: PUSH
5885: EMPTY
5886: LIST
5887: LIST
5888: PUSH
5889: EMPTY
5890: LIST
5891: LIST
5892: LIST
5893: LIST
5894: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5895: LD_ADDR_VAR 0 6
5899: PUSH
5900: LD_EXP 78
5904: PUSH
5905: LD_VAR 0 2
5909: ARRAY
5910: PUSH
5911: LD_EXP 78
5915: PUSH
5916: LD_VAR 0 2
5920: ARRAY
5921: PPUSH
5922: LD_INT 34
5924: PUSH
5925: LD_INT 32
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL_OW 72
5936: DIFF
5937: ST_TO_ADDR
// if not attackers then
5938: LD_VAR 0 6
5942: NOT
5943: IFFALSE 5947
// exit ;
5945: GO 6006
// ar_attackers := attackers ;
5947: LD_ADDR_EXP 10
5951: PUSH
5952: LD_VAR 0 6
5956: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5957: LD_INT 35
5959: PPUSH
5960: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5964: LD_VAR 0 6
5968: PPUSH
5969: LD_INT 60
5971: PUSH
5972: EMPTY
5973: LIST
5974: PPUSH
5975: CALL_OW 72
5979: NOT
5980: IFFALSE 5957
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5982: LD_VAR 0 2
5986: PPUSH
5987: LD_VAR 0 6
5991: PPUSH
5992: LD_VAR 0 5
5996: PPUSH
5997: LD_VAR 0 4
6001: PPUSH
6002: CALL 81329 0 4
// end ;
6006: PPOPN 6
6008: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6009: LD_INT 1
6011: PPUSH
6012: CALL_OW 302
6016: PUSH
6017: LD_EXP 9
6021: AND
6022: PUSH
6023: LD_EXP 49
6027: PPUSH
6028: LD_INT 22
6030: PPUSH
6031: CALL_OW 308
6035: AND
6036: PUSH
6037: LD_INT 1
6039: PPUSH
6040: CALL 81492 0 1
6044: PUSH
6045: LD_INT 0
6047: EQUAL
6048: AND
6049: PUSH
6050: LD_EXP 10
6054: NOT
6055: AND
6056: IFFALSE 6520
6058: GO 6060
6060: DISABLE
6061: LD_INT 0
6063: PPUSH
6064: PPUSH
6065: PPUSH
6066: PPUSH
6067: PPUSH
6068: PPUSH
6069: PPUSH
// begin base := 1 ;
6070: LD_ADDR_VAR 0 2
6074: PUSH
6075: LD_INT 1
6077: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6078: LD_ADDR_VAR 0 4
6082: PUSH
6083: LD_INT 0
6085: PUSH
6086: LD_INT 0
6088: PUSH
6089: LD_INT 0
6091: PUSH
6092: LD_INT 0
6094: PUSH
6095: LD_INT 0
6097: PUSH
6098: LD_INT 0
6100: PUSH
6101: LD_INT 0
6103: PUSH
6104: LD_INT 0
6106: PUSH
6107: LD_INT 1
6109: PUSH
6110: LD_INT 0
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6125: LD_ADDR_VAR 0 3
6129: PUSH
6130: LD_INT 13
6132: PUSH
6133: LD_INT 1
6135: PUSH
6136: LD_INT 2
6138: PUSH
6139: LD_INT 28
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 13
6150: PUSH
6151: LD_INT 1
6153: PUSH
6154: LD_INT 2
6156: PUSH
6157: LD_INT 27
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: PUSH
6166: LD_INT 13
6168: PUSH
6169: LD_INT 1
6171: PUSH
6172: LD_INT 2
6174: PUSH
6175: LD_INT 25
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 11
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 2
6192: PUSH
6193: LD_INT 24
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: PUSH
6202: LD_INT 11
6204: PUSH
6205: LD_INT 2
6207: PUSH
6208: LD_INT 2
6210: PUSH
6211: LD_INT 24
6213: PUSH
6214: EMPTY
6215: LIST
6216: LIST
6217: LIST
6218: LIST
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6227: LD_VAR 0 2
6231: PPUSH
6232: LD_VAR 0 3
6236: PPUSH
6237: CALL 81144 0 2
// repeat wait ( 0 0$1 ) ;
6241: LD_INT 35
6243: PPUSH
6244: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6248: LD_EXP 78
6252: PUSH
6253: LD_VAR 0 2
6257: ARRAY
6258: PUSH
6259: LD_INT 6
6261: GREATEREQUAL
6262: IFFALSE 6241
// wait ( 0 0$20 ) ;
6264: LD_INT 700
6266: PPUSH
6267: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6271: LD_ADDR_VAR 0 5
6275: PUSH
6276: LD_INT 119
6278: PUSH
6279: LD_INT 9
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: PUSH
6286: EMPTY
6287: LIST
6288: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6289: LD_ADDR_VAR 0 6
6293: PUSH
6294: LD_EXP 78
6298: PUSH
6299: LD_VAR 0 2
6303: ARRAY
6304: PUSH
6305: LD_EXP 78
6309: PUSH
6310: LD_VAR 0 2
6314: ARRAY
6315: PPUSH
6316: LD_INT 34
6318: PUSH
6319: LD_INT 32
6321: PUSH
6322: EMPTY
6323: LIST
6324: LIST
6325: PPUSH
6326: CALL_OW 72
6330: DIFF
6331: ST_TO_ADDR
// if not attackers then
6332: LD_VAR 0 6
6336: NOT
6337: IFFALSE 6341
// exit ;
6339: GO 6520
// uc_side := 2 ;
6341: LD_ADDR_OWVAR 20
6345: PUSH
6346: LD_INT 2
6348: ST_TO_ADDR
// uc_nation := 2 ;
6349: LD_ADDR_OWVAR 21
6353: PUSH
6354: LD_INT 2
6356: ST_TO_ADDR
// InitHc ;
6357: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6361: LD_ADDR_VAR 0 1
6365: PUSH
6366: DOUBLE
6367: LD_INT 1
6369: DEC
6370: ST_TO_ADDR
6371: LD_INT 4
6373: PUSH
6374: LD_INT 5
6376: PUSH
6377: LD_INT 6
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: LD_OWVAR 67
6389: ARRAY
6390: PUSH
6391: FOR_TO
6392: IFFALSE 6469
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6394: LD_INT 0
6396: PPUSH
6397: LD_INT 15
6399: PUSH
6400: LD_INT 17
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: CALL_OW 12
6417: ARRAY
6418: PPUSH
6419: LD_INT 8
6421: PPUSH
6422: CALL_OW 380
// un := CreateHuman ;
6426: LD_ADDR_VAR 0 7
6430: PUSH
6431: CALL_OW 44
6435: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6436: LD_VAR 0 7
6440: PPUSH
6441: LD_INT 23
6443: PPUSH
6444: LD_INT 0
6446: PPUSH
6447: CALL_OW 49
// attackers := attackers union un ;
6451: LD_ADDR_VAR 0 6
6455: PUSH
6456: LD_VAR 0 6
6460: PUSH
6461: LD_VAR 0 7
6465: UNION
6466: ST_TO_ADDR
// end ;
6467: GO 6391
6469: POP
6470: POP
// repeat wait ( 0 0$1 ) ;
6471: LD_INT 35
6473: PPUSH
6474: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6478: LD_VAR 0 6
6482: PPUSH
6483: LD_INT 60
6485: PUSH
6486: EMPTY
6487: LIST
6488: PPUSH
6489: CALL_OW 72
6493: NOT
6494: IFFALSE 6471
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6496: LD_VAR 0 2
6500: PPUSH
6501: LD_VAR 0 6
6505: PPUSH
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 4
6515: PPUSH
6516: CALL 81329 0 4
// end ; end_of_file
6520: PPOPN 7
6522: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6523: LD_INT 0
6525: PPUSH
6526: PPUSH
6527: PPUSH
6528: PPUSH
// uc_side := 1 ;
6529: LD_ADDR_OWVAR 20
6533: PUSH
6534: LD_INT 1
6536: ST_TO_ADDR
// uc_nation := 1 ;
6537: LD_ADDR_OWVAR 21
6541: PUSH
6542: LD_INT 1
6544: ST_TO_ADDR
// InitHc ;
6545: CALL_OW 19
// InitVc ;
6549: CALL_OW 20
// tmp := [ ] ;
6553: LD_ADDR_VAR 0 3
6557: PUSH
6558: EMPTY
6559: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6560: LD_ADDR_VAR 0 2
6564: PUSH
6565: DOUBLE
6566: LD_INT 1
6568: DEC
6569: ST_TO_ADDR
6570: LD_INT 5
6572: PUSH
6573: LD_INT 6
6575: PUSH
6576: LD_INT 6
6578: PUSH
6579: EMPTY
6580: LIST
6581: LIST
6582: LIST
6583: PUSH
6584: LD_OWVAR 67
6588: ARRAY
6589: PUSH
6590: FOR_TO
6591: IFFALSE 6728
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6593: LD_INT 2
6595: PUSH
6596: LD_INT 4
6598: PUSH
6599: LD_INT 5
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: LIST
6606: PUSH
6607: LD_INT 1
6609: PPUSH
6610: LD_INT 3
6612: PPUSH
6613: CALL_OW 12
6617: ARRAY
6618: PPUSH
6619: LD_INT 1
6621: PUSH
6622: LD_INT 3
6624: PUSH
6625: EMPTY
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 1
6631: PPUSH
6632: LD_INT 2
6634: PPUSH
6635: CALL_OW 12
6639: ARRAY
6640: PPUSH
6641: LD_INT 3
6643: PPUSH
6644: LD_INT 9
6646: PUSH
6647: LD_INT 7
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 1
6656: PPUSH
6657: LD_INT 2
6659: PPUSH
6660: CALL_OW 12
6664: ARRAY
6665: PPUSH
6666: LD_INT 78
6668: PPUSH
6669: CALL 21399 0 5
// veh := CreateVehicle ;
6673: LD_ADDR_VAR 0 4
6677: PUSH
6678: CALL_OW 45
6682: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6683: LD_VAR 0 4
6687: PPUSH
6688: LD_INT 2
6690: PPUSH
6691: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6695: LD_VAR 0 4
6699: PPUSH
6700: LD_INT 17
6702: PPUSH
6703: LD_INT 0
6705: PPUSH
6706: CALL_OW 49
// tmp := tmp ^ veh ;
6710: LD_ADDR_VAR 0 3
6714: PUSH
6715: LD_VAR 0 3
6719: PUSH
6720: LD_VAR 0 4
6724: ADD
6725: ST_TO_ADDR
// end ;
6726: GO 6590
6728: POP
6729: POP
// if not tmp then
6730: LD_VAR 0 3
6734: NOT
6735: IFFALSE 6739
// exit ;
6737: GO 6848
// if not first_powell_attack then
6739: LD_EXP 11
6743: NOT
6744: IFFALSE 6754
// first_powell_attack := true ;
6746: LD_ADDR_EXP 11
6750: PUSH
6751: LD_INT 1
6753: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6754: LD_INT 70
6756: PPUSH
6757: CALL_OW 67
// for i in tmp do
6761: LD_ADDR_VAR 0 2
6765: PUSH
6766: LD_VAR 0 3
6770: PUSH
6771: FOR_IN
6772: IFFALSE 6839
// if IsOk ( i ) then
6774: LD_VAR 0 2
6778: PPUSH
6779: CALL_OW 302
6783: IFFALSE 6821
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6785: LD_VAR 0 2
6789: PPUSH
6790: LD_INT 81
6792: PUSH
6793: LD_INT 1
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: PPUSH
6800: CALL_OW 69
6804: PPUSH
6805: LD_VAR 0 2
6809: PPUSH
6810: CALL_OW 74
6814: PPUSH
6815: CALL_OW 115
6819: GO 6837
// tmp := tmp diff i ;
6821: LD_ADDR_VAR 0 3
6825: PUSH
6826: LD_VAR 0 3
6830: PUSH
6831: LD_VAR 0 2
6835: DIFF
6836: ST_TO_ADDR
6837: GO 6771
6839: POP
6840: POP
// until not tmp ;
6841: LD_VAR 0 3
6845: NOT
6846: IFFALSE 6754
// end ; end_of_file
6848: LD_VAR 0 1
6852: RET
// export function Action ; var tmp , i , un ; begin
6853: LD_INT 0
6855: PPUSH
6856: PPUSH
6857: PPUSH
6858: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6859: LD_INT 68
6861: PPUSH
6862: LD_INT 39
6864: PPUSH
6865: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6869: LD_ADDR_VAR 0 2
6873: PUSH
6874: LD_INT 22
6876: PUSH
6877: LD_INT 7
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: PPUSH
6884: CALL_OW 69
6888: ST_TO_ADDR
// InGameOn ;
6889: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6893: LD_VAR 0 2
6897: PPUSH
6898: LD_INT 71
6900: PPUSH
6901: LD_INT 49
6903: PPUSH
6904: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6908: LD_INT 35
6910: PPUSH
6911: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6915: LD_INT 7
6917: PPUSH
6918: LD_INT 71
6920: PPUSH
6921: LD_INT 51
6923: PPUSH
6924: CALL_OW 293
6928: IFFALSE 6908
// DialogueOn ;
6930: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6934: LD_EXP 15
6938: PPUSH
6939: LD_STRING D1-JMM-1
6941: PPUSH
6942: CALL_OW 88
// if Joan then
6946: LD_EXP 30
6950: IFFALSE 6964
// Say ( Joan , D1-Joan-1 ) ;
6952: LD_EXP 30
6956: PPUSH
6957: LD_STRING D1-Joan-1
6959: PPUSH
6960: CALL_OW 88
// if Lisa then
6964: LD_EXP 17
6968: IFFALSE 6982
// Say ( Lisa , D1-Lisa-1 ) ;
6970: LD_EXP 17
6974: PPUSH
6975: LD_STRING D1-Lisa-1
6977: PPUSH
6978: CALL_OW 88
// if Joan or Lisa then
6982: LD_EXP 30
6986: PUSH
6987: LD_EXP 17
6991: OR
6992: IFFALSE 7006
// Say ( JMM , D1-JMM-2 ) ;
6994: LD_EXP 15
6998: PPUSH
6999: LD_STRING D1-JMM-2
7001: PPUSH
7002: CALL_OW 88
// DialogueOff ;
7006: CALL_OW 7
// InGameOff ;
7010: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7014: LD_INT 71
7016: PPUSH
7017: LD_INT 50
7019: PPUSH
7020: LD_INT 7
7022: PPUSH
7023: LD_INT 30
7025: NEG
7026: PPUSH
7027: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7031: LD_INT 71
7033: PPUSH
7034: LD_INT 50
7036: PPUSH
7037: LD_INT 7
7039: PPUSH
7040: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7044: LD_STRING M1
7046: PPUSH
7047: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7051: LD_INT 35
7053: PPUSH
7054: CALL_OW 67
// until freedom ;
7058: LD_EXP 3
7062: IFFALSE 7051
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7064: LD_INT 350
7066: PPUSH
7067: LD_INT 700
7069: PPUSH
7070: CALL_OW 12
7074: PPUSH
7075: CALL_OW 67
// PrepareGossudarov ;
7079: CALL 1802 0 0
// repeat wait ( 0 0$1 ) ;
7083: LD_INT 35
7085: PPUSH
7086: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7090: LD_INT 22
7092: PUSH
7093: LD_INT 6
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 24
7105: PUSH
7106: LD_INT 1000
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: PPUSH
7121: CALL_OW 69
7125: PUSH
7126: LD_INT 7
7128: PPUSH
7129: LD_EXP 32
7133: PPUSH
7134: CALL_OW 292
7138: OR
7139: IFFALSE 7083
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7141: LD_ADDR_VAR 0 2
7145: PUSH
7146: LD_INT 22
7148: PUSH
7149: LD_INT 6
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PPUSH
7156: CALL_OW 69
7160: ST_TO_ADDR
// for i in tmp do
7161: LD_ADDR_VAR 0 3
7165: PUSH
7166: LD_VAR 0 2
7170: PUSH
7171: FOR_IN
7172: IFFALSE 7188
// SetSide ( i , 7 ) ;
7174: LD_VAR 0 3
7178: PPUSH
7179: LD_INT 7
7181: PPUSH
7182: CALL_OW 235
7186: GO 7171
7188: POP
7189: POP
// DialogueOn ;
7190: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7194: LD_EXP 15
7198: PUSH
7199: LD_EXP 16
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: PPUSH
7208: LD_EXP 32
7212: PPUSH
7213: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7217: LD_EXP 32
7221: PPUSH
7222: CALL_OW 87
// if not Roth then
7226: LD_EXP 16
7230: NOT
7231: IFFALSE 7323
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7233: LD_VAR 0 2
7237: PPUSH
7238: LD_INT 3
7240: PUSH
7241: LD_INT 24
7243: PUSH
7244: LD_INT 1000
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PPUSH
7255: CALL_OW 72
7259: IFFALSE 7273
// Say ( JMM , D2-JMM-1 ) ;
7261: LD_EXP 15
7265: PPUSH
7266: LD_STRING D2-JMM-1
7268: PPUSH
7269: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7273: LD_EXP 15
7277: PPUSH
7278: LD_STRING D2-JMM-1b
7280: PPUSH
7281: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7285: LD_EXP 32
7289: PPUSH
7290: LD_STRING D2-Gos-1
7292: PPUSH
7293: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7297: LD_EXP 15
7301: PPUSH
7302: LD_STRING D2-JMM-2
7304: PPUSH
7305: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7309: LD_EXP 32
7313: PPUSH
7314: LD_STRING D2-Gos-2
7316: PPUSH
7317: CALL_OW 88
// end else
7321: GO 7475
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7323: LD_VAR 0 2
7327: PPUSH
7328: LD_INT 3
7330: PUSH
7331: LD_INT 24
7333: PUSH
7334: LD_INT 1000
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL_OW 72
7349: IFFALSE 7375
// begin Say ( Roth , D2-Roth-2 ) ;
7351: LD_EXP 16
7355: PPUSH
7356: LD_STRING D2-Roth-2
7358: PPUSH
7359: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7363: LD_EXP 15
7367: PPUSH
7368: LD_STRING D2-JMM-1a
7370: PPUSH
7371: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7375: LD_EXP 16
7379: PPUSH
7380: LD_STRING D2-Roth-2a
7382: PPUSH
7383: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7387: LD_EXP 16
7391: PPUSH
7392: LD_STRING D2-Roth-2b
7394: PPUSH
7395: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7399: LD_EXP 15
7403: PPUSH
7404: LD_STRING D2-JMM-3
7406: PPUSH
7407: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7411: LD_VAR 0 2
7415: PPUSH
7416: LD_INT 3
7418: PUSH
7419: LD_INT 24
7421: PUSH
7422: LD_INT 1000
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: PPUSH
7433: CALL_OW 72
7437: IFFALSE 7475
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7439: LD_EXP 32
7443: PPUSH
7444: LD_STRING D2-Gos-3
7446: PPUSH
7447: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7451: LD_EXP 15
7455: PPUSH
7456: LD_STRING D2-JMM-4
7458: PPUSH
7459: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7463: LD_EXP 32
7467: PPUSH
7468: LD_STRING D2-Gos-4
7470: PPUSH
7471: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7475: LD_EXP 15
7479: PPUSH
7480: LD_STRING D2-JMM-5
7482: PPUSH
7483: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7487: LD_EXP 32
7491: PPUSH
7492: LD_STRING D2-Gos-5
7494: PPUSH
7495: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7499: LD_EXP 15
7503: PPUSH
7504: LD_STRING D2-JMM-6
7506: PPUSH
7507: CALL_OW 88
// DialogueOff ;
7511: CALL_OW 7
// wait ( 0 0$2 ) ;
7515: LD_INT 70
7517: PPUSH
7518: CALL_OW 67
// if Kirilenkova then
7522: LD_EXP 33
7526: IFFALSE 7540
// Say ( Kirilenkova , D3-Kir-1 ) ;
7528: LD_EXP 33
7532: PPUSH
7533: LD_STRING D3-Kir-1
7535: PPUSH
7536: CALL_OW 88
// gossudarov_arrive := true ;
7540: LD_ADDR_EXP 4
7544: PUSH
7545: LD_INT 1
7547: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7548: LD_INT 35
7550: PPUSH
7551: CALL_OW 67
// until ru_lab_builded ;
7555: LD_EXP 5
7559: IFFALSE 7548
// if Kirilenkova then
7561: LD_EXP 33
7565: IFFALSE 7581
// Say ( Kirilenkova , D3a-Kir-1 ) else
7567: LD_EXP 33
7571: PPUSH
7572: LD_STRING D3a-Kir-1
7574: PPUSH
7575: CALL_OW 88
7579: GO 7603
// begin un := SciRu ;
7581: LD_ADDR_VAR 0 4
7585: PUSH
7586: CALL 12711 0 0
7590: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7591: LD_VAR 0 4
7595: PPUSH
7596: LD_STRING D3a-Sci1-1
7598: PPUSH
7599: CALL_OW 88
// end ; if Kirilenkova or un then
7603: LD_EXP 33
7607: PUSH
7608: LD_VAR 0 4
7612: OR
7613: IFFALSE 7627
// Say ( JMM , D3a-JMM-1 ) ;
7615: LD_EXP 15
7619: PPUSH
7620: LD_STRING D3a-JMM-1
7622: PPUSH
7623: CALL_OW 88
// end ;
7627: LD_VAR 0 1
7631: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7632: LD_EXP 4
7636: PUSH
7637: LD_INT 22
7639: PUSH
7640: LD_INT 7
7642: PUSH
7643: EMPTY
7644: LIST
7645: LIST
7646: PUSH
7647: LD_INT 2
7649: PUSH
7650: LD_INT 25
7652: PUSH
7653: LD_INT 1
7655: PUSH
7656: EMPTY
7657: LIST
7658: LIST
7659: PUSH
7660: LD_INT 25
7662: PUSH
7663: LD_INT 2
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: PUSH
7670: LD_INT 25
7672: PUSH
7673: LD_INT 3
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: PUSH
7680: LD_INT 25
7682: PUSH
7683: LD_INT 4
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: PUSH
7690: LD_INT 25
7692: PUSH
7693: LD_INT 5
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PUSH
7700: LD_INT 25
7702: PUSH
7703: LD_INT 8
7705: PUSH
7706: EMPTY
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 25
7712: PUSH
7713: LD_INT 9
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: LIST
7724: LIST
7725: LIST
7726: LIST
7727: LIST
7728: LIST
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PPUSH
7734: CALL_OW 69
7738: PUSH
7739: LD_INT 7
7741: LESS
7742: AND
7743: IFFALSE 7755
7745: GO 7747
7747: DISABLE
// YouLost ( TooMany ) ;
7748: LD_STRING TooMany
7750: PPUSH
7751: CALL_OW 104
7755: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7756: LD_EXP 32
7760: PPUSH
7761: CALL_OW 255
7765: PUSH
7766: LD_INT 7
7768: EQUAL
7769: IFFALSE 7969
7771: GO 7773
7773: DISABLE
7774: LD_INT 0
7776: PPUSH
7777: PPUSH
7778: PPUSH
// begin uc_side := 3 ;
7779: LD_ADDR_OWVAR 20
7783: PUSH
7784: LD_INT 3
7786: ST_TO_ADDR
// uc_nation := 3 ;
7787: LD_ADDR_OWVAR 21
7791: PUSH
7792: LD_INT 3
7794: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7795: LD_INT 21
7797: PPUSH
7798: LD_INT 3
7800: PPUSH
7801: LD_INT 3
7803: PPUSH
7804: LD_INT 42
7806: PPUSH
7807: LD_INT 100
7809: PPUSH
7810: CALL 21399 0 5
// un := CreateVehicle ;
7814: LD_ADDR_VAR 0 3
7818: PUSH
7819: CALL_OW 45
7823: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7824: LD_VAR 0 3
7828: PPUSH
7829: LD_INT 15
7831: PPUSH
7832: LD_INT 0
7834: PPUSH
7835: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7839: LD_VAR 0 3
7843: PPUSH
7844: LD_INT 67
7846: PPUSH
7847: LD_INT 45
7849: PPUSH
7850: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7854: LD_VAR 0 3
7858: PPUSH
7859: LD_INT 70
7861: PPUSH
7862: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7866: LD_VAR 0 3
7870: PPUSH
7871: LD_INT 69
7873: PPUSH
7874: LD_INT 18
7876: PPUSH
7877: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7881: LD_VAR 0 3
7885: PPUSH
7886: LD_INT 60
7888: PPUSH
7889: LD_INT 2
7891: PPUSH
7892: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7896: LD_INT 35
7898: PPUSH
7899: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7903: LD_VAR 0 3
7907: PPUSH
7908: CALL_OW 302
7912: NOT
7913: PUSH
7914: LD_VAR 0 3
7918: PPUSH
7919: LD_INT 17
7921: PPUSH
7922: CALL_OW 308
7926: OR
7927: IFFALSE 7896
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7929: LD_VAR 0 3
7933: PPUSH
7934: LD_INT 17
7936: PPUSH
7937: CALL_OW 308
7941: PUSH
7942: LD_VAR 0 3
7946: PPUSH
7947: LD_INT 60
7949: PPUSH
7950: LD_INT 2
7952: PPUSH
7953: CALL_OW 307
7957: OR
7958: IFFALSE 7969
// RemoveUnit ( un ) ;
7960: LD_VAR 0 3
7964: PPUSH
7965: CALL_OW 64
// end ;
7969: PPOPN 3
7971: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
7972: LD_EXP 4
7976: IFFALSE 8218
7978: GO 7980
7980: DISABLE
7981: LD_INT 0
7983: PPUSH
7984: PPUSH
7985: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7986: LD_INT 70
7988: PPUSH
7989: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7993: LD_ADDR_VAR 0 3
7997: PUSH
7998: LD_INT 22
8000: PUSH
8001: LD_INT 7
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PUSH
8008: LD_INT 101
8010: PUSH
8011: LD_INT 3
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: PUSH
8018: EMPTY
8019: LIST
8020: LIST
8021: PPUSH
8022: CALL_OW 69
8026: ST_TO_ADDR
// until tmp ;
8027: LD_VAR 0 3
8031: IFFALSE 7986
// un := NearestUnitToUnit ( tmp , JMM ) ;
8033: LD_ADDR_VAR 0 2
8037: PUSH
8038: LD_VAR 0 3
8042: PPUSH
8043: LD_EXP 15
8047: PPUSH
8048: CALL_OW 74
8052: ST_TO_ADDR
// player_spotted := true ;
8053: LD_ADDR_EXP 6
8057: PUSH
8058: LD_INT 1
8060: ST_TO_ADDR
// tmp := SciRu ;
8061: LD_ADDR_VAR 0 3
8065: PUSH
8066: CALL 12711 0 0
8070: ST_TO_ADDR
// if not tmp then
8071: LD_VAR 0 3
8075: NOT
8076: IFFALSE 8088
// tmp := SolRu ;
8078: LD_ADDR_VAR 0 3
8082: PUSH
8083: CALL 12858 0 0
8087: ST_TO_ADDR
// DialogueOn ;
8088: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8092: LD_VAR 0 2
8096: PPUSH
8097: CALL_OW 250
8101: PPUSH
8102: LD_VAR 0 2
8106: PPUSH
8107: CALL_OW 251
8111: PPUSH
8112: LD_INT 7
8114: PPUSH
8115: LD_INT 8
8117: NEG
8118: PPUSH
8119: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8123: LD_VAR 0 2
8127: PPUSH
8128: CALL_OW 87
// if tmp then
8132: LD_VAR 0 3
8136: IFFALSE 8150
// Say ( tmp , D4-RSci1-1 ) ;
8138: LD_VAR 0 3
8142: PPUSH
8143: LD_STRING D4-RSci1-1
8145: PPUSH
8146: CALL_OW 88
// if Gossudarov then
8150: LD_EXP 32
8154: IFFALSE 8180
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8156: LD_EXP 32
8160: PPUSH
8161: LD_STRING D4-Gos-1
8163: PPUSH
8164: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8168: LD_EXP 15
8172: PPUSH
8173: LD_STRING D4-JMM-1
8175: PPUSH
8176: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8180: LD_VAR 0 2
8184: PPUSH
8185: CALL_OW 250
8189: PPUSH
8190: LD_VAR 0 2
8194: PPUSH
8195: CALL_OW 251
8199: PPUSH
8200: LD_INT 7
8202: PPUSH
8203: CALL_OW 331
// DialogueOff ;
8207: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8211: LD_STRING M5
8213: PPUSH
8214: CALL_OW 337
// end ;
8218: PPOPN 3
8220: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8221: LD_EXP 6
8225: IFFALSE 8814
8227: GO 8229
8229: DISABLE
8230: LD_INT 0
8232: PPUSH
8233: PPUSH
8234: PPUSH
// begin PrepareBelkov ;
8235: CALL 2092 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8239: LD_EXP 47
8243: PPUSH
8244: LD_INT 118
8246: PPUSH
8247: LD_INT 106
8249: PPUSH
8250: CALL_OW 111
// AddComHold ( Belkov ) ;
8254: LD_EXP 47
8258: PPUSH
8259: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8263: LD_INT 35
8265: PPUSH
8266: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8270: LD_EXP 47
8274: PPUSH
8275: LD_INT 118
8277: PPUSH
8278: LD_INT 106
8280: PPUSH
8281: CALL_OW 307
8285: IFFALSE 8263
// ChangeSideFog ( 4 , 7 ) ;
8287: LD_INT 4
8289: PPUSH
8290: LD_INT 7
8292: PPUSH
8293: CALL_OW 343
// if IsOk ( Belkov ) then
8297: LD_EXP 47
8301: PPUSH
8302: CALL_OW 302
8306: IFFALSE 8390
// begin InGameOn ;
8308: CALL_OW 8
// DialogueOn ;
8312: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8316: LD_EXP 47
8320: PPUSH
8321: LD_STRING D5-Bel-1
8323: PPUSH
8324: CALL_OW 94
// if Gossudarov then
8328: LD_EXP 32
8332: IFFALSE 8382
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8334: LD_EXP 32
8338: PPUSH
8339: LD_STRING D5-Gos-1
8341: PPUSH
8342: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8346: LD_EXP 15
8350: PPUSH
8351: LD_STRING D5-JMM-1
8353: PPUSH
8354: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8358: LD_EXP 32
8362: PPUSH
8363: LD_STRING D5-Gos-2
8365: PPUSH
8366: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8370: LD_EXP 15
8374: PPUSH
8375: LD_STRING D5-JMM-2
8377: PPUSH
8378: CALL_OW 88
// end ; DialogueOff ;
8382: CALL_OW 7
// InGameOff ;
8386: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8390: LD_STRING QSaveBelkov
8392: PPUSH
8393: CALL_OW 97
8397: PUSH
8398: LD_INT 1
8400: DOUBLE
8401: EQUAL
8402: IFTRUE 8406
8404: GO 8456
8406: POP
// begin DialogueOn ;
8407: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8411: LD_EXP 15
8415: PPUSH
8416: LD_STRING D5a-JMM-1
8418: PPUSH
8419: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8423: LD_EXP 47
8427: PPUSH
8428: LD_STRING D5a-Bel-1
8430: PPUSH
8431: CALL_OW 94
// DialogueOff ;
8435: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8439: LD_EXP 47
8443: PPUSH
8444: LD_INT 83
8446: PPUSH
8447: LD_INT 49
8449: PPUSH
8450: CALL_OW 111
// end ; 2 :
8454: GO 8489
8456: LD_INT 2
8458: DOUBLE
8459: EQUAL
8460: IFTRUE 8464
8462: GO 8488
8464: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8465: LD_EXP 15
8469: PPUSH
8470: LD_STRING D5a-JMM-2
8472: PPUSH
8473: CALL_OW 88
// ComHold ( Belkov ) ;
8477: LD_EXP 47
8481: PPUSH
8482: CALL_OW 140
// end ; end ;
8486: GO 8489
8488: POP
// time := 0 0$00 ;
8489: LD_ADDR_VAR 0 1
8493: PUSH
8494: LD_INT 0
8496: ST_TO_ADDR
// vehSpawned := false ;
8497: LD_ADDR_VAR 0 3
8501: PUSH
8502: LD_INT 0
8504: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8505: LD_INT 35
8507: PPUSH
8508: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8512: LD_VAR 0 1
8516: PUSH
8517: LD_INT 350
8519: PUSH
8520: LD_INT 175
8522: PUSH
8523: LD_INT 70
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: LIST
8530: PUSH
8531: LD_OWVAR 67
8535: ARRAY
8536: GREATEREQUAL
8537: PUSH
8538: LD_VAR 0 3
8542: NOT
8543: AND
8544: IFFALSE 8634
// begin vehSpawned := true ;
8546: LD_ADDR_VAR 0 3
8550: PUSH
8551: LD_INT 1
8553: ST_TO_ADDR
// uc_side := 3 ;
8554: LD_ADDR_OWVAR 20
8558: PUSH
8559: LD_INT 3
8561: ST_TO_ADDR
// uc_nation := 3 ;
8562: LD_ADDR_OWVAR 21
8566: PUSH
8567: LD_INT 3
8569: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8570: LD_INT 22
8572: PPUSH
8573: LD_INT 3
8575: PPUSH
8576: LD_INT 3
8578: PPUSH
8579: LD_INT 43
8581: PPUSH
8582: LD_INT 100
8584: PPUSH
8585: CALL 21399 0 5
// veh := CreateVehicle ;
8589: LD_ADDR_VAR 0 2
8593: PUSH
8594: CALL_OW 45
8598: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8599: LD_VAR 0 2
8603: PPUSH
8604: LD_INT 130
8606: PPUSH
8607: LD_INT 131
8609: PPUSH
8610: LD_INT 0
8612: PPUSH
8613: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8617: LD_VAR 0 2
8621: PPUSH
8622: LD_INT 100
8624: PPUSH
8625: LD_INT 82
8627: PPUSH
8628: CALL_OW 114
// end else
8632: GO 8648
// time := time + 0 0$1 ;
8634: LD_ADDR_VAR 0 1
8638: PUSH
8639: LD_VAR 0 1
8643: PUSH
8644: LD_INT 35
8646: PLUS
8647: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8648: LD_EXP 47
8652: PPUSH
8653: CALL_OW 301
8657: PUSH
8658: LD_EXP 47
8662: PPUSH
8663: CALL_OW 255
8667: PUSH
8668: LD_INT 4
8670: EQUAL
8671: AND
8672: PUSH
8673: LD_INT 22
8675: PUSH
8676: LD_INT 7
8678: PUSH
8679: EMPTY
8680: LIST
8681: LIST
8682: PPUSH
8683: CALL_OW 69
8687: PPUSH
8688: LD_EXP 47
8692: PPUSH
8693: CALL_OW 74
8697: PPUSH
8698: LD_EXP 47
8702: PPUSH
8703: CALL_OW 296
8707: PUSH
8708: LD_INT 10
8710: LESS
8711: OR
8712: IFFALSE 8505
// if IsDead ( Belkov ) then
8714: LD_EXP 47
8718: PPUSH
8719: CALL_OW 301
8723: IFFALSE 8748
// begin CenterNowOnUnits ( Belkov ) ;
8725: LD_EXP 47
8729: PPUSH
8730: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8734: LD_EXP 15
8738: PPUSH
8739: LD_STRING D5a-JMM-2a
8741: PPUSH
8742: CALL_OW 88
// exit ;
8746: GO 8814
// end ; if See ( 7 , Belkov ) then
8748: LD_INT 7
8750: PPUSH
8751: LD_EXP 47
8755: PPUSH
8756: CALL_OW 292
8760: IFFALSE 8774
// SetSide ( Belkov , 7 ) ;
8762: LD_EXP 47
8766: PPUSH
8767: LD_INT 7
8769: PPUSH
8770: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8774: LD_INT 35
8776: PPUSH
8777: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8781: LD_EXP 47
8785: PPUSH
8786: LD_INT 66
8788: PPUSH
8789: LD_INT 45
8791: PPUSH
8792: CALL_OW 297
8796: PUSH
8797: LD_INT 30
8799: LESS
8800: IFFALSE 8774
// Say ( Belkov , D6-Bel-1 ) ;
8802: LD_EXP 47
8806: PPUSH
8807: LD_STRING D6-Bel-1
8809: PPUSH
8810: CALL_OW 88
// end ;
8814: PPOPN 3
8816: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8817: LD_EXP 47
8821: PPUSH
8822: CALL_OW 302
8826: PUSH
8827: LD_EXP 47
8831: PPUSH
8832: CALL_OW 504
8836: PUSH
8837: LD_INT 2
8839: PUSH
8840: LD_INT 34
8842: PUSH
8843: LD_INT 47
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: PUSH
8850: LD_INT 34
8852: PUSH
8853: LD_INT 45
8855: PUSH
8856: EMPTY
8857: LIST
8858: LIST
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: LIST
8864: PPUSH
8865: CALL_OW 69
8869: IN
8870: AND
8871: IFFALSE 8888
8873: GO 8875
8875: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8876: LD_EXP 47
8880: PPUSH
8881: LD_STRING D7-Bel-1
8883: PPUSH
8884: CALL_OW 88
8888: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8889: LD_INT 22
8891: PUSH
8892: LD_INT 7
8894: PUSH
8895: EMPTY
8896: LIST
8897: LIST
8898: PUSH
8899: LD_INT 101
8901: PUSH
8902: LD_INT 2
8904: PUSH
8905: EMPTY
8906: LIST
8907: LIST
8908: PUSH
8909: EMPTY
8910: LIST
8911: LIST
8912: PPUSH
8913: CALL_OW 69
8917: PUSH
8918: LD_EXP 8
8922: NOT
8923: AND
8924: PUSH
8925: LD_EXP 46
8929: PPUSH
8930: CALL_OW 305
8934: NOT
8935: AND
8936: IFFALSE 9406
8938: GO 8940
8940: DISABLE
8941: LD_INT 0
8943: PPUSH
// begin ar_base_spotted := true ;
8944: LD_ADDR_EXP 8
8948: PUSH
8949: LD_INT 1
8951: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8952: LD_ADDR_VAR 0 1
8956: PUSH
8957: LD_INT 22
8959: PUSH
8960: LD_INT 2
8962: PUSH
8963: EMPTY
8964: LIST
8965: LIST
8966: PUSH
8967: LD_INT 21
8969: PUSH
8970: LD_INT 3
8972: PUSH
8973: EMPTY
8974: LIST
8975: LIST
8976: PUSH
8977: EMPTY
8978: LIST
8979: LIST
8980: PPUSH
8981: CALL_OW 69
8985: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8986: LD_ADDR_VAR 0 1
8990: PUSH
8991: LD_VAR 0 1
8995: PPUSH
8996: LD_EXP 15
9000: PPUSH
9001: CALL_OW 74
9005: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9006: LD_INT 7
9008: PPUSH
9009: LD_INT 3
9011: PPUSH
9012: CALL_OW 332
// DialogueOn ;
9016: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9020: LD_VAR 0 1
9024: PPUSH
9025: CALL_OW 250
9029: PPUSH
9030: LD_VAR 0 1
9034: PPUSH
9035: CALL_OW 251
9039: PPUSH
9040: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9044: LD_ADDR_VAR 0 1
9048: PUSH
9049: LD_INT 22
9051: PUSH
9052: LD_INT 7
9054: PUSH
9055: EMPTY
9056: LIST
9057: LIST
9058: PUSH
9059: LD_INT 23
9061: PUSH
9062: LD_INT 1
9064: PUSH
9065: EMPTY
9066: LIST
9067: LIST
9068: PUSH
9069: LD_INT 26
9071: PUSH
9072: LD_INT 1
9074: PUSH
9075: EMPTY
9076: LIST
9077: LIST
9078: PUSH
9079: EMPTY
9080: LIST
9081: LIST
9082: LIST
9083: PPUSH
9084: CALL_OW 69
9088: PUSH
9089: LD_EXP 15
9093: PUSH
9094: LD_EXP 19
9098: PUSH
9099: LD_EXP 20
9103: PUSH
9104: LD_EXP 27
9108: PUSH
9109: LD_EXP 16
9113: PUSH
9114: LD_EXP 25
9118: PUSH
9119: LD_EXP 21
9123: PUSH
9124: LD_EXP 23
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: LIST
9133: LIST
9134: LIST
9135: LIST
9136: LIST
9137: LIST
9138: DIFF
9139: ST_TO_ADDR
// if not tmp then
9140: LD_VAR 0 1
9144: NOT
9145: IFFALSE 9219
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9147: LD_ADDR_VAR 0 1
9151: PUSH
9152: LD_INT 22
9154: PUSH
9155: LD_INT 7
9157: PUSH
9158: EMPTY
9159: LIST
9160: LIST
9161: PUSH
9162: LD_INT 23
9164: PUSH
9165: LD_INT 1
9167: PUSH
9168: EMPTY
9169: LIST
9170: LIST
9171: PUSH
9172: LD_INT 26
9174: PUSH
9175: LD_INT 2
9177: PUSH
9178: EMPTY
9179: LIST
9180: LIST
9181: PUSH
9182: EMPTY
9183: LIST
9184: LIST
9185: LIST
9186: PPUSH
9187: CALL_OW 69
9191: PUSH
9192: LD_EXP 30
9196: PUSH
9197: LD_EXP 17
9201: PUSH
9202: LD_EXP 28
9206: PUSH
9207: LD_EXP 29
9211: PUSH
9212: EMPTY
9213: LIST
9214: LIST
9215: LIST
9216: LIST
9217: DIFF
9218: ST_TO_ADDR
// if tmp then
9219: LD_VAR 0 1
9223: IFFALSE 9294
// case GetSex ( tmp [ 1 ] ) of sex_male :
9225: LD_VAR 0 1
9229: PUSH
9230: LD_INT 1
9232: ARRAY
9233: PPUSH
9234: CALL_OW 258
9238: PUSH
9239: LD_INT 1
9241: DOUBLE
9242: EQUAL
9243: IFTRUE 9247
9245: GO 9266
9247: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9248: LD_VAR 0 1
9252: PUSH
9253: LD_INT 1
9255: ARRAY
9256: PPUSH
9257: LD_STRING D9-Sol1-1
9259: PPUSH
9260: CALL_OW 88
9264: GO 9294
9266: LD_INT 2
9268: DOUBLE
9269: EQUAL
9270: IFTRUE 9274
9272: GO 9293
9274: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9275: LD_VAR 0 1
9279: PUSH
9280: LD_INT 1
9282: ARRAY
9283: PPUSH
9284: LD_STRING D9-FSol1-1
9286: PPUSH
9287: CALL_OW 88
9291: GO 9294
9293: POP
// if Frank then
9294: LD_EXP 27
9298: IFFALSE 9402
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9300: LD_EXP 56
9304: PPUSH
9305: CALL_OW 250
9309: PPUSH
9310: LD_EXP 56
9314: PPUSH
9315: CALL_OW 251
9319: PPUSH
9320: LD_INT 7
9322: PPUSH
9323: LD_INT 8
9325: PPUSH
9326: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9330: LD_EXP 56
9334: PPUSH
9335: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9339: LD_EXP 27
9343: PPUSH
9344: LD_STRING D9-Frank-1
9346: PPUSH
9347: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9351: LD_EXP 15
9355: PPUSH
9356: LD_STRING D9-JMM-1
9358: PPUSH
9359: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9363: LD_EXP 27
9367: PPUSH
9368: LD_STRING D9-Frank-2
9370: PPUSH
9371: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9375: LD_EXP 56
9379: PPUSH
9380: CALL_OW 250
9384: PPUSH
9385: LD_EXP 56
9389: PPUSH
9390: CALL_OW 251
9394: PPUSH
9395: LD_INT 7
9397: PPUSH
9398: CALL_OW 331
// end ; DialogueOff ;
9402: CALL_OW 7
// end ;
9406: PPOPN 1
9408: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9409: LD_EXP 7
9413: PUSH
9414: LD_OWVAR 1
9418: PUSH
9419: LD_INT 42000
9421: GREATEREQUAL
9422: OR
9423: IFFALSE 10450
9425: GO 9427
9427: DISABLE
9428: LD_INT 0
9430: PPUSH
9431: PPUSH
// begin selected_option := 1 ;
9432: LD_ADDR_VAR 0 2
9436: PUSH
9437: LD_INT 1
9439: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9440: LD_INT 10500
9442: PPUSH
9443: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9447: LD_INT 35
9449: PPUSH
9450: CALL_OW 67
// until not ru_attackers ;
9454: LD_EXP 52
9458: NOT
9459: IFFALSE 9447
// PrepareBurlak ;
9461: CALL 2204 0 0
// repeat wait ( 0 0$2 ) ;
9465: LD_INT 70
9467: PPUSH
9468: CALL_OW 67
// until not HasTask ( Burlak ) ;
9472: LD_EXP 46
9476: PPUSH
9477: CALL_OW 314
9481: NOT
9482: IFFALSE 9465
// InGameOn ;
9484: CALL_OW 8
// DialogueOn ;
9488: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9492: LD_EXP 49
9496: PPUSH
9497: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9501: LD_EXP 46
9505: PPUSH
9506: LD_STRING D10-Bur-1
9508: PPUSH
9509: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9513: LD_EXP 47
9517: PUSH
9518: LD_EXP 47
9522: PPUSH
9523: CALL_OW 255
9527: PUSH
9528: LD_INT 7
9530: EQUAL
9531: AND
9532: IFFALSE 9546
// Say ( Belkov , D10-Bel-1 ) ;
9534: LD_EXP 47
9538: PPUSH
9539: LD_STRING D10-Bel-1
9541: PPUSH
9542: CALL_OW 88
// if Gossudarov then
9546: LD_EXP 32
9550: IFFALSE 9564
// Say ( Gossudarov , D10-Gos-1 ) ;
9552: LD_EXP 32
9556: PPUSH
9557: LD_STRING D10-Gos-1
9559: PPUSH
9560: CALL_OW 88
// if Kirilenkova then
9564: LD_EXP 33
9568: IFFALSE 9582
// Say ( Kirilenkova , D10-Kir-1 ) ;
9570: LD_EXP 33
9574: PPUSH
9575: LD_STRING D10-Kir-1
9577: PPUSH
9578: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9582: CALL 12858 0 0
9586: PPUSH
9587: LD_STRING D10-RSol1-1
9589: PPUSH
9590: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9594: LD_EXP 46
9598: PPUSH
9599: LD_STRING D10-Bur-2
9601: PPUSH
9602: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9606: LD_EXP 15
9610: PPUSH
9611: LD_STRING D10-JMM-2
9613: PPUSH
9614: CALL_OW 88
// if Kirilenkova then
9618: LD_EXP 33
9622: IFFALSE 9638
// Say ( Kirilenkova , D10-Kir-2 ) else
9624: LD_EXP 33
9628: PPUSH
9629: LD_STRING D10-Kir-2
9631: PPUSH
9632: CALL_OW 88
9636: GO 9650
// Say ( SolRu , D10-RSol1-2 ) ;
9638: CALL 12858 0 0
9642: PPUSH
9643: LD_STRING D10-RSol1-2
9645: PPUSH
9646: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9650: LD_EXP 15
9654: PPUSH
9655: LD_STRING D10-JMM-3
9657: PPUSH
9658: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9662: LD_EXP 46
9666: PPUSH
9667: LD_STRING D10-Bur-3
9669: PPUSH
9670: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9674: LD_EXP 15
9678: PPUSH
9679: LD_STRING D10-JMM-4
9681: PPUSH
9682: CALL_OW 88
// DialogueOff ;
9686: CALL_OW 7
// InGameOff ;
9690: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9694: LD_STRING M2
9696: PPUSH
9697: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9701: LD_INT 35
9703: PPUSH
9704: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9708: LD_INT 22
9710: PUSH
9711: LD_INT 7
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: PUSH
9718: LD_INT 91
9720: PUSH
9721: LD_EXP 46
9725: PUSH
9726: LD_INT 8
9728: PUSH
9729: EMPTY
9730: LIST
9731: LIST
9732: LIST
9733: PUSH
9734: EMPTY
9735: LIST
9736: LIST
9737: PPUSH
9738: CALL_OW 69
9742: IFFALSE 9701
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9744: LD_ADDR_VAR 0 1
9748: PUSH
9749: LD_INT 22
9751: PUSH
9752: LD_INT 4
9754: PUSH
9755: EMPTY
9756: LIST
9757: LIST
9758: PPUSH
9759: CALL_OW 69
9763: PUSH
9764: FOR_IN
9765: IFFALSE 9781
// SetSide ( i , 7 ) ;
9767: LD_VAR 0 1
9771: PPUSH
9772: LD_INT 7
9774: PPUSH
9775: CALL_OW 235
9779: GO 9764
9781: POP
9782: POP
// ChangeMissionObjectives ( M3 ) ;
9783: LD_STRING M3
9785: PPUSH
9786: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9790: LD_INT 35
9792: PPUSH
9793: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9797: LD_EXP 15
9801: PPUSH
9802: LD_EXP 46
9806: PPUSH
9807: CALL_OW 296
9811: PUSH
9812: LD_INT 8
9814: LESS
9815: IFFALSE 9790
// ComTurnUnit ( JMM , Burlak ) ;
9817: LD_EXP 15
9821: PPUSH
9822: LD_EXP 46
9826: PPUSH
9827: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9831: LD_EXP 46
9835: PPUSH
9836: LD_EXP 15
9840: PPUSH
9841: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9845: LD_INT 10
9847: PPUSH
9848: CALL_OW 67
// DialogueOn ;
9852: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9856: LD_EXP 15
9860: PPUSH
9861: LD_STRING D11-JMM-1
9863: PPUSH
9864: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9868: LD_EXP 46
9872: PPUSH
9873: LD_STRING D11-Bur-1
9875: PPUSH
9876: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9880: LD_EXP 15
9884: PPUSH
9885: LD_STRING D11-JMM-2
9887: PPUSH
9888: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9892: LD_EXP 46
9896: PPUSH
9897: LD_STRING D11-Bur-2
9899: PPUSH
9900: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9904: LD_EXP 15
9908: PPUSH
9909: LD_STRING D11-JMM-3
9911: PPUSH
9912: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9916: LD_EXP 46
9920: PPUSH
9921: LD_STRING D11-Bur-3
9923: PPUSH
9924: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9928: LD_EXP 15
9932: PPUSH
9933: LD_STRING D11-JMM-4
9935: PPUSH
9936: CALL_OW 88
// if ar_base_spotted then
9940: LD_EXP 8
9944: IFFALSE 9960
// Say ( Burlak , D12-Bur-1 ) else
9946: LD_EXP 46
9950: PPUSH
9951: LD_STRING D12-Bur-1
9953: PPUSH
9954: CALL_OW 88
9958: GO 9999
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9960: LD_INT 7
9962: PPUSH
9963: LD_INT 3
9965: PPUSH
9966: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9970: LD_INT 127
9972: PPUSH
9973: LD_INT 45
9975: PPUSH
9976: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9980: LD_EXP 46
9984: PPUSH
9985: LD_STRING D12-Bur-1a
9987: PPUSH
9988: CALL_OW 88
// dwait ( 0 0$2 ) ;
9992: LD_INT 70
9994: PPUSH
9995: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9999: LD_EXP 46
10003: PPUSH
10004: LD_STRING D12-Bur-1b
10006: PPUSH
10007: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10011: LD_EXP 15
10015: PPUSH
10016: LD_STRING D12-JMM-1
10018: PPUSH
10019: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10023: LD_EXP 46
10027: PPUSH
10028: LD_STRING D12-Bur-2
10030: PPUSH
10031: CALL_OW 88
// if Roth then
10035: LD_EXP 16
10039: IFFALSE 10055
// Say ( Roth , D12-Roth-2 ) else
10041: LD_EXP 16
10045: PPUSH
10046: LD_STRING D12-Roth-2
10048: PPUSH
10049: CALL_OW 88
10053: GO 10067
// Say ( SciRu , D12-RSci1-2 ) ;
10055: CALL 12711 0 0
10059: PPUSH
10060: LD_STRING D12-RSci1-2
10062: PPUSH
10063: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10067: LD_EXP 15
10071: PPUSH
10072: LD_STRING D12-JMM-2
10074: PPUSH
10075: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10079: LD_EXP 46
10083: PPUSH
10084: LD_STRING D12-Bur-3
10086: PPUSH
10087: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10091: LD_EXP 15
10095: PPUSH
10096: LD_STRING D12-JMM-3
10098: PPUSH
10099: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10103: LD_EXP 46
10107: PPUSH
10108: LD_STRING D12-Bur-4
10110: PPUSH
10111: CALL_OW 88
// case Query ( QBase ) of 1 :
10115: LD_STRING QBase
10117: PPUSH
10118: CALL_OW 97
10122: PUSH
10123: LD_INT 1
10125: DOUBLE
10126: EQUAL
10127: IFTRUE 10131
10129: GO 10249
10131: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10132: LD_EXP 15
10136: PPUSH
10137: LD_STRING D13a-JMM-1
10139: PPUSH
10140: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10144: LD_EXP 46
10148: PPUSH
10149: LD_STRING D13a-Bur-1
10151: PPUSH
10152: CALL_OW 88
// if Roth then
10156: LD_EXP 16
10160: IFFALSE 10176
// Say ( Roth , D13a-Roth-1 ) else
10162: LD_EXP 16
10166: PPUSH
10167: LD_STRING D13a-Roth-1
10169: PPUSH
10170: CALL_OW 88
10174: GO 10188
// Say ( SciRu , D13a-RSci1-1 ) ;
10176: CALL 12711 0 0
10180: PPUSH
10181: LD_STRING D13a-RSci1-1
10183: PPUSH
10184: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10188: LD_EXP 15
10192: PPUSH
10193: LD_STRING D13a-JMM-2
10195: PPUSH
10196: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10200: LD_STRING QBaseAgain
10202: PPUSH
10203: CALL_OW 97
10207: PUSH
10208: LD_INT 1
10210: DOUBLE
10211: EQUAL
10212: IFTRUE 10216
10214: GO 10227
10216: POP
// selected_option := 2 ; 2 :
10217: LD_ADDR_VAR 0 2
10221: PUSH
10222: LD_INT 2
10224: ST_TO_ADDR
10225: GO 10247
10227: LD_INT 2
10229: DOUBLE
10230: EQUAL
10231: IFTRUE 10235
10233: GO 10246
10235: POP
// selected_option := 3 ; end ;
10236: LD_ADDR_VAR 0 2
10240: PUSH
10241: LD_INT 3
10243: ST_TO_ADDR
10244: GO 10247
10246: POP
// end ; 2 :
10247: GO 10288
10249: LD_INT 2
10251: DOUBLE
10252: EQUAL
10253: IFTRUE 10257
10255: GO 10268
10257: POP
// selected_option := 2 ; 3 :
10258: LD_ADDR_VAR 0 2
10262: PUSH
10263: LD_INT 2
10265: ST_TO_ADDR
10266: GO 10288
10268: LD_INT 3
10270: DOUBLE
10271: EQUAL
10272: IFTRUE 10276
10274: GO 10287
10276: POP
// selected_option := 3 ; end ;
10277: LD_ADDR_VAR 0 2
10281: PUSH
10282: LD_INT 3
10284: ST_TO_ADDR
10285: GO 10288
10287: POP
// if selected_option = 2 then
10288: LD_VAR 0 2
10292: PUSH
10293: LD_INT 2
10295: EQUAL
10296: IFFALSE 10390
// begin Say ( JMM , D13b-JMM-1 ) ;
10298: LD_EXP 15
10302: PPUSH
10303: LD_STRING D13b-JMM-1
10305: PPUSH
10306: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10310: LD_EXP 46
10314: PPUSH
10315: LD_STRING D13b-Bur-1
10317: PPUSH
10318: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10322: LD_EXP 15
10326: PPUSH
10327: LD_STRING D13b-JMM-2
10329: PPUSH
10330: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10334: LD_EXP 55
10338: PPUSH
10339: LD_STRING D13b-Abd-2
10341: PPUSH
10342: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10346: LD_EXP 15
10350: PPUSH
10351: LD_STRING D13b-JMM-3
10353: PPUSH
10354: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10358: LD_EXP 55
10362: PPUSH
10363: LD_STRING D13b-Abd-3
10365: PPUSH
10366: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10370: LD_EXP 15
10374: PPUSH
10375: LD_STRING D13b-JMM-4
10377: PPUSH
10378: CALL_OW 88
// ar_active_attack := true ;
10382: LD_ADDR_EXP 9
10386: PUSH
10387: LD_INT 1
10389: ST_TO_ADDR
// end ; if selected_option = 3 then
10390: LD_VAR 0 2
10394: PUSH
10395: LD_INT 3
10397: EQUAL
10398: IFFALSE 10424
// begin Say ( JMM , D13c-JMM-1 ) ;
10400: LD_EXP 15
10404: PPUSH
10405: LD_STRING D13c-JMM-1
10407: PPUSH
10408: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10412: LD_EXP 46
10416: PPUSH
10417: LD_STRING D13c-Bur-1
10419: PPUSH
10420: CALL_OW 88
// end ; DialogueOff ;
10424: CALL_OW 7
// if not ar_active_attack then
10428: LD_EXP 9
10432: NOT
10433: IFFALSE 10450
// begin wait ( 6 6$00 ) ;
10435: LD_INT 12600
10437: PPUSH
10438: CALL_OW 67
// ar_active_attack := true ;
10442: LD_ADDR_EXP 9
10446: PUSH
10447: LD_INT 1
10449: ST_TO_ADDR
// end ; end ;
10450: PPOPN 2
10452: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10453: LD_EXP 46
10457: PPUSH
10458: CALL_OW 305
10462: PUSH
10463: LD_EXP 46
10467: PPUSH
10468: CALL_OW 255
10472: PUSH
10473: LD_INT 7
10475: EQUAL
10476: AND
10477: IFFALSE 10673
10479: GO 10481
10481: DISABLE
10482: LD_INT 0
10484: PPUSH
// begin wait ( 4 4$40 ) ;
10485: LD_INT 9800
10487: PPUSH
10488: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10492: LD_INT 35
10494: PPUSH
10495: CALL_OW 67
// until not ru_attackers ;
10499: LD_EXP 52
10503: NOT
10504: IFFALSE 10492
// PrepareGnyevko ;
10506: CALL 2148 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10510: LD_EXP 48
10514: PPUSH
10515: LD_INT 124
10517: PPUSH
10518: LD_INT 118
10520: PPUSH
10521: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10525: LD_EXP 48
10529: PPUSH
10530: CALL_OW 200
// time := 0 0$00 ;
10534: LD_ADDR_VAR 0 1
10538: PUSH
10539: LD_INT 0
10541: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10542: LD_INT 35
10544: PPUSH
10545: CALL_OW 67
// time := time + 0 0$1 ;
10549: LD_ADDR_VAR 0 1
10553: PUSH
10554: LD_VAR 0 1
10558: PUSH
10559: LD_INT 35
10561: PLUS
10562: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10563: LD_EXP 48
10567: PPUSH
10568: LD_INT 124
10570: PPUSH
10571: LD_INT 118
10573: PPUSH
10574: CALL_OW 307
10578: PUSH
10579: LD_VAR 0 1
10583: PUSH
10584: LD_INT 1050
10586: GREATEREQUAL
10587: OR
10588: IFFALSE 10542
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10590: LD_EXP 48
10594: PPUSH
10595: LD_STRING DBelkov-Gny-1
10597: PPUSH
10598: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10602: LD_EXP 46
10606: PPUSH
10607: LD_STRING DBelkov-Bur-1a
10609: PPUSH
10610: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10614: LD_INT 35
10616: PPUSH
10617: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10621: LD_EXP 48
10625: PPUSH
10626: LD_INT 22
10628: PUSH
10629: LD_INT 7
10631: PUSH
10632: EMPTY
10633: LIST
10634: LIST
10635: PPUSH
10636: CALL_OW 69
10640: PPUSH
10641: LD_EXP 48
10645: PPUSH
10646: CALL_OW 74
10650: PPUSH
10651: CALL_OW 296
10655: PUSH
10656: LD_INT 8
10658: LESS
10659: IFFALSE 10614
// SetSide ( Gnyevko , 7 ) ;
10661: LD_EXP 48
10665: PPUSH
10666: LD_INT 7
10668: PPUSH
10669: CALL_OW 235
// end ;
10673: PPOPN 1
10675: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10676: LD_EXP 46
10680: PPUSH
10681: CALL_OW 255
10685: PUSH
10686: LD_INT 7
10688: EQUAL
10689: IFFALSE 10699
10691: GO 10693
10693: DISABLE
// begin enable ;
10694: ENABLE
// PrepareAmericanAttack ;
10695: CALL 6523 0 0
// end ;
10699: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10700: LD_INT 22
10702: PUSH
10703: LD_INT 1
10705: PUSH
10706: EMPTY
10707: LIST
10708: LIST
10709: PPUSH
10710: CALL_OW 69
10714: IFFALSE 10898
10716: GO 10718
10718: DISABLE
10719: LD_INT 0
10721: PPUSH
10722: PPUSH
// begin while true do
10723: LD_INT 1
10725: IFFALSE 10782
// begin wait ( 0 0$1 ) ;
10727: LD_INT 35
10729: PPUSH
10730: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10734: LD_ADDR_VAR 0 2
10738: PUSH
10739: LD_INT 22
10741: PUSH
10742: LD_INT 1
10744: PUSH
10745: EMPTY
10746: LIST
10747: LIST
10748: PPUSH
10749: CALL_OW 69
10753: PPUSH
10754: LD_EXP 15
10758: PPUSH
10759: CALL_OW 74
10763: ST_TO_ADDR
// if See ( 7 , tmp ) then
10764: LD_INT 7
10766: PPUSH
10767: LD_VAR 0 2
10771: PPUSH
10772: CALL_OW 292
10776: IFFALSE 10780
// break ;
10778: GO 10782
// end ;
10780: GO 10723
// DialogueOn ;
10782: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10786: LD_VAR 0 2
10790: PPUSH
10791: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10795: LD_VAR 0 2
10799: PPUSH
10800: CALL_OW 250
10804: PPUSH
10805: LD_VAR 0 2
10809: PPUSH
10810: CALL_OW 251
10814: PPUSH
10815: LD_INT 7
10817: PPUSH
10818: LD_INT 8
10820: PPUSH
10821: CALL_OW 330
// if Denis then
10825: LD_EXP 21
10829: IFFALSE 10843
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10831: LD_EXP 21
10835: PPUSH
10836: LD_STRING DAmerAttack-Pet-1
10838: PPUSH
10839: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10843: LD_EXP 15
10847: PPUSH
10848: LD_STRING DAmerAttack-JMM-1
10850: PPUSH
10851: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10855: LD_EXP 46
10859: PPUSH
10860: LD_STRING DStop-Bur-1
10862: PPUSH
10863: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10867: LD_VAR 0 2
10871: PPUSH
10872: CALL_OW 250
10876: PPUSH
10877: LD_VAR 0 2
10881: PPUSH
10882: CALL_OW 251
10886: PPUSH
10887: LD_INT 7
10889: PPUSH
10890: CALL_OW 331
// DialogueOff ;
10894: CALL_OW 7
// end ;
10898: PPOPN 2
10900: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10901: LD_INT 22
10903: PUSH
10904: LD_INT 3
10906: PUSH
10907: EMPTY
10908: LIST
10909: LIST
10910: PUSH
10911: LD_INT 21
10913: PUSH
10914: LD_INT 1
10916: PUSH
10917: EMPTY
10918: LIST
10919: LIST
10920: PUSH
10921: EMPTY
10922: LIST
10923: LIST
10924: PPUSH
10925: CALL_OW 69
10929: PUSH
10930: LD_INT 0
10932: EQUAL
10933: IFFALSE 10975
10935: GO 10937
10937: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10938: LD_STRING M5a
10940: PPUSH
10941: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10945: LD_EXP 15
10949: PPUSH
10950: LD_STRING D8-JMM-1
10952: PPUSH
10953: CALL_OW 88
// if Gossudarov then
10957: LD_EXP 32
10961: IFFALSE 10975
// Say ( Gossudarov , D8-Gos-1 ) ;
10963: LD_EXP 32
10967: PPUSH
10968: LD_STRING D8-Gos-1
10970: PPUSH
10971: CALL_OW 88
// end ;
10975: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10976: LD_INT 22
10978: PUSH
10979: LD_INT 2
10981: PUSH
10982: EMPTY
10983: LIST
10984: LIST
10985: PUSH
10986: LD_INT 21
10988: PUSH
10989: LD_INT 1
10991: PUSH
10992: EMPTY
10993: LIST
10994: LIST
10995: PUSH
10996: EMPTY
10997: LIST
10998: LIST
10999: PPUSH
11000: CALL_OW 69
11004: PUSH
11005: LD_INT 0
11007: EQUAL
11008: IFFALSE 11058
11010: GO 11012
11012: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11013: LD_STRING M4c
11015: PPUSH
11016: CALL_OW 337
// if Roth then
11020: LD_EXP 16
11024: IFFALSE 11040
// Say ( Roth , DStop-Roth-1 ) else
11026: LD_EXP 16
11030: PPUSH
11031: LD_STRING DStop-Roth-1
11033: PPUSH
11034: CALL_OW 88
11038: GO 11058
// if Gossudarov then
11040: LD_EXP 32
11044: IFFALSE 11058
// Say ( Gossudarov , D8-Gos-1a ) ;
11046: LD_EXP 32
11050: PPUSH
11051: LD_STRING D8-Gos-1a
11053: PPUSH
11054: CALL_OW 88
// end ;
11058: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11059: LD_INT 7
11061: PPUSH
11062: LD_INT 1
11064: PPUSH
11065: LD_INT 1
11067: PPUSH
11068: CALL 14347 0 3
11072: PUSH
11073: LD_INT 0
11075: EQUAL
11076: PUSH
11077: LD_INT 7
11079: PPUSH
11080: LD_INT 3
11082: PPUSH
11083: LD_INT 1
11085: PPUSH
11086: CALL 14347 0 3
11090: PUSH
11091: LD_INT 0
11093: EQUAL
11094: AND
11095: IFFALSE 11107
11097: GO 11099
11099: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11100: LD_STRING M1a
11102: PPUSH
11103: CALL_OW 337
// end ;
11107: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11108: LD_INT 22
11110: PUSH
11111: LD_INT 2
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: PUSH
11118: LD_INT 21
11120: PUSH
11121: LD_INT 1
11123: PUSH
11124: EMPTY
11125: LIST
11126: LIST
11127: PUSH
11128: EMPTY
11129: LIST
11130: LIST
11131: PPUSH
11132: CALL_OW 69
11136: PUSH
11137: LD_INT 0
11139: EQUAL
11140: PUSH
11141: LD_INT 22
11143: PUSH
11144: LD_INT 3
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: PUSH
11151: LD_INT 21
11153: PUSH
11154: LD_INT 1
11156: PUSH
11157: EMPTY
11158: LIST
11159: LIST
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: PPUSH
11165: CALL_OW 69
11169: PUSH
11170: LD_INT 0
11172: EQUAL
11173: AND
11174: PUSH
11175: LD_INT 22
11177: PUSH
11178: LD_INT 1
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PPUSH
11185: CALL_OW 69
11189: PUSH
11190: LD_INT 0
11192: EQUAL
11193: AND
11194: PUSH
11195: LD_INT 7
11197: PPUSH
11198: LD_INT 1
11200: PPUSH
11201: LD_INT 1
11203: PPUSH
11204: CALL 14347 0 3
11208: PUSH
11209: LD_INT 0
11211: EQUAL
11212: AND
11213: PUSH
11214: LD_INT 7
11216: PPUSH
11217: LD_INT 3
11219: PPUSH
11220: LD_INT 1
11222: PPUSH
11223: CALL 14347 0 3
11227: PUSH
11228: LD_INT 0
11230: EQUAL
11231: AND
11232: IFFALSE 12708
11234: GO 11236
11236: DISABLE
11237: LD_INT 0
11239: PPUSH
11240: PPUSH
11241: PPUSH
11242: PPUSH
11243: PPUSH
11244: PPUSH
// begin m1 := false ;
11245: LD_ADDR_VAR 0 4
11249: PUSH
11250: LD_INT 0
11252: ST_TO_ADDR
// m2 := false ;
11253: LD_ADDR_VAR 0 5
11257: PUSH
11258: LD_INT 0
11260: ST_TO_ADDR
// m3 := false ;
11261: LD_ADDR_VAR 0 6
11265: PUSH
11266: LD_INT 0
11268: ST_TO_ADDR
// if tick < 40 40$00 then
11269: LD_OWVAR 1
11273: PUSH
11274: LD_INT 84000
11276: LESS
11277: IFFALSE 11286
// SetAchievement ( ACH_ASPEED_17 ) ;
11279: LD_STRING ACH_ASPEED_17
11281: PPUSH
11282: CALL_OW 543
// wait ( 0 0$1 ) ;
11286: LD_INT 35
11288: PPUSH
11289: CALL_OW 67
// if not IsDead ( Masha ) then
11293: LD_EXP 49
11297: PPUSH
11298: CALL_OW 301
11302: NOT
11303: IFFALSE 11325
// begin m1 := true ;
11305: LD_ADDR_VAR 0 4
11309: PUSH
11310: LD_INT 1
11312: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11313: LD_STRING Masha
11315: PPUSH
11316: LD_INT 1
11318: PPUSH
11319: CALL_OW 101
// end else
11323: GO 11336
// AddMedal ( Masha , - 1 ) ;
11325: LD_STRING Masha
11327: PPUSH
11328: LD_INT 1
11330: NEG
11331: PPUSH
11332: CALL_OW 101
// if abdul_escaped then
11336: LD_EXP 12
11340: IFFALSE 11355
// AddMedal ( Abdul , - 1 ) else
11342: LD_STRING Abdul
11344: PPUSH
11345: LD_INT 1
11347: NEG
11348: PPUSH
11349: CALL_OW 101
11353: GO 11373
// begin m2 := true ;
11355: LD_ADDR_VAR 0 5
11359: PUSH
11360: LD_INT 1
11362: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11363: LD_STRING Abdul
11365: PPUSH
11366: LD_INT 1
11368: PPUSH
11369: CALL_OW 101
// end ; if loss_counter = 0 then
11373: LD_EXP 13
11377: PUSH
11378: LD_INT 0
11380: EQUAL
11381: IFFALSE 11403
// begin m3 := true ;
11383: LD_ADDR_VAR 0 6
11387: PUSH
11388: LD_INT 1
11390: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11391: LD_STRING People
11393: PPUSH
11394: LD_INT 2
11396: PPUSH
11397: CALL_OW 101
// end else
11401: GO 11461
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11403: LD_EXP 13
11407: PUSH
11408: LD_INT 3
11410: PUSH
11411: LD_INT 2
11413: PUSH
11414: LD_INT 2
11416: PUSH
11417: EMPTY
11418: LIST
11419: LIST
11420: LIST
11421: PUSH
11422: LD_OWVAR 67
11426: ARRAY
11427: LESSEQUAL
11428: IFFALSE 11450
// begin AddMedal ( People , 1 ) ;
11430: LD_STRING People
11432: PPUSH
11433: LD_INT 1
11435: PPUSH
11436: CALL_OW 101
// m3 := true ;
11440: LD_ADDR_VAR 0 6
11444: PUSH
11445: LD_INT 1
11447: ST_TO_ADDR
// end else
11448: GO 11461
// AddMedal ( People , - 1 ) ;
11450: LD_STRING People
11452: PPUSH
11453: LD_INT 1
11455: NEG
11456: PPUSH
11457: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11461: LD_OWVAR 67
11465: PUSH
11466: LD_INT 3
11468: EQUAL
11469: PUSH
11470: LD_VAR 0 4
11474: AND
11475: PUSH
11476: LD_VAR 0 5
11480: AND
11481: PUSH
11482: LD_VAR 0 6
11486: AND
11487: IFFALSE 11499
// SetAchievementEX ( ACH_AMER , 17 ) ;
11489: LD_STRING ACH_AMER
11491: PPUSH
11492: LD_INT 17
11494: PPUSH
11495: CALL_OW 564
// GiveMedals ( MAIN ) ;
11499: LD_STRING MAIN
11501: PPUSH
11502: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11506: LD_ADDR_VAR 0 2
11510: PUSH
11511: LD_INT 22
11513: PUSH
11514: LD_INT 7
11516: PUSH
11517: EMPTY
11518: LIST
11519: LIST
11520: PUSH
11521: LD_INT 2
11523: PUSH
11524: LD_INT 25
11526: PUSH
11527: LD_INT 1
11529: PUSH
11530: EMPTY
11531: LIST
11532: LIST
11533: PUSH
11534: LD_INT 25
11536: PUSH
11537: LD_INT 2
11539: PUSH
11540: EMPTY
11541: LIST
11542: LIST
11543: PUSH
11544: LD_INT 25
11546: PUSH
11547: LD_INT 3
11549: PUSH
11550: EMPTY
11551: LIST
11552: LIST
11553: PUSH
11554: LD_INT 25
11556: PUSH
11557: LD_INT 4
11559: PUSH
11560: EMPTY
11561: LIST
11562: LIST
11563: PUSH
11564: LD_INT 25
11566: PUSH
11567: LD_INT 5
11569: PUSH
11570: EMPTY
11571: LIST
11572: LIST
11573: PUSH
11574: LD_INT 25
11576: PUSH
11577: LD_INT 8
11579: PUSH
11580: EMPTY
11581: LIST
11582: LIST
11583: PUSH
11584: LD_INT 25
11586: PUSH
11587: LD_INT 9
11589: PUSH
11590: EMPTY
11591: LIST
11592: LIST
11593: PUSH
11594: EMPTY
11595: LIST
11596: LIST
11597: LIST
11598: LIST
11599: LIST
11600: LIST
11601: LIST
11602: LIST
11603: PUSH
11604: EMPTY
11605: LIST
11606: LIST
11607: PPUSH
11608: CALL_OW 69
11612: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11613: LD_VAR 0 2
11617: PPUSH
11618: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11622: LD_ADDR_VAR 0 3
11626: PUSH
11627: LD_EXP 15
11631: PUSH
11632: LD_EXP 16
11636: PUSH
11637: LD_EXP 17
11641: PUSH
11642: LD_EXP 18
11646: PUSH
11647: LD_EXP 19
11651: PUSH
11652: LD_EXP 20
11656: PUSH
11657: LD_EXP 21
11661: PUSH
11662: LD_EXP 22
11666: PUSH
11667: LD_EXP 23
11671: PUSH
11672: LD_EXP 24
11676: PUSH
11677: LD_EXP 25
11681: PUSH
11682: LD_EXP 26
11686: PUSH
11687: LD_EXP 27
11691: PUSH
11692: LD_EXP 28
11696: PUSH
11697: LD_EXP 29
11701: PUSH
11702: LD_EXP 30
11706: PUSH
11707: LD_EXP 31
11711: PUSH
11712: LD_EXP 32
11716: PUSH
11717: LD_EXP 33
11721: PUSH
11722: LD_EXP 34
11726: PUSH
11727: LD_EXP 36
11731: PUSH
11732: LD_EXP 37
11736: PUSH
11737: LD_EXP 38
11741: PUSH
11742: LD_EXP 39
11746: PUSH
11747: LD_EXP 40
11751: PUSH
11752: LD_EXP 41
11756: PUSH
11757: LD_EXP 42
11761: PUSH
11762: LD_EXP 43
11766: PUSH
11767: LD_EXP 44
11771: PUSH
11772: LD_EXP 45
11776: PUSH
11777: LD_EXP 46
11781: PUSH
11782: LD_EXP 47
11786: PUSH
11787: LD_EXP 48
11791: PUSH
11792: EMPTY
11793: LIST
11794: LIST
11795: LIST
11796: LIST
11797: LIST
11798: LIST
11799: LIST
11800: LIST
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: LIST
11809: LIST
11810: LIST
11811: LIST
11812: LIST
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: ST_TO_ADDR
// if tmp diff tmp2 then
11827: LD_VAR 0 2
11831: PUSH
11832: LD_VAR 0 3
11836: DIFF
11837: IFFALSE 11857
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11839: LD_VAR 0 2
11843: PUSH
11844: LD_VAR 0 3
11848: DIFF
11849: PPUSH
11850: LD_STRING 13a_others
11852: PPUSH
11853: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11857: LD_EXP 15
11861: PPUSH
11862: LD_STRING 13a_JMM
11864: PPUSH
11865: CALL_OW 38
// if Titov then
11869: LD_EXP 34
11873: IFFALSE 11887
// SaveCharacters ( Titov , 13a_Titov ) ;
11875: LD_EXP 34
11879: PPUSH
11880: LD_STRING 13a_Titov
11882: PPUSH
11883: CALL_OW 38
// if Dolgov then
11887: LD_EXP 36
11891: IFFALSE 11905
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11893: LD_EXP 36
11897: PPUSH
11898: LD_STRING 13a_Dolgov
11900: PPUSH
11901: CALL_OW 38
// if Petrosyan then
11905: LD_EXP 37
11909: IFFALSE 11923
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11911: LD_EXP 37
11915: PPUSH
11916: LD_STRING 13a_Petrosyan
11918: PPUSH
11919: CALL_OW 38
// if Scholtze then
11923: LD_EXP 38
11927: IFFALSE 11941
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11929: LD_EXP 38
11933: PPUSH
11934: LD_STRING 13a_Scholtze
11936: PPUSH
11937: CALL_OW 38
// if Oblukov then
11941: LD_EXP 39
11945: IFFALSE 11959
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11947: LD_EXP 39
11951: PPUSH
11952: LD_STRING 13a_Oblukov
11954: PPUSH
11955: CALL_OW 38
// if Kapitsova then
11959: LD_EXP 40
11963: IFFALSE 11977
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11965: LD_EXP 40
11969: PPUSH
11970: LD_STRING 13a_Kapitsova
11972: PPUSH
11973: CALL_OW 38
// if Lipshchin then
11977: LD_EXP 41
11981: IFFALSE 11995
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11983: LD_EXP 41
11987: PPUSH
11988: LD_STRING 13a_Lipshchin
11990: PPUSH
11991: CALL_OW 38
// if Petrovova then
11995: LD_EXP 42
11999: IFFALSE 12013
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12001: LD_EXP 42
12005: PPUSH
12006: LD_STRING 13a_Petrovova
12008: PPUSH
12009: CALL_OW 38
// if Kovalyuk then
12013: LD_EXP 43
12017: IFFALSE 12031
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12019: LD_EXP 43
12023: PPUSH
12024: LD_STRING 13a_Kovalyuk
12026: PPUSH
12027: CALL_OW 38
// if Kuzmov then
12031: LD_EXP 44
12035: IFFALSE 12049
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12037: LD_EXP 44
12041: PPUSH
12042: LD_STRING 13a_Kuzmov
12044: PPUSH
12045: CALL_OW 38
// if Karamazov then
12049: LD_EXP 45
12053: IFFALSE 12067
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12055: LD_EXP 45
12059: PPUSH
12060: LD_STRING 13a_Karamazov
12062: PPUSH
12063: CALL_OW 38
// if Burlak then
12067: LD_EXP 46
12071: IFFALSE 12085
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12073: LD_EXP 46
12077: PPUSH
12078: LD_STRING 13a_Burlak
12080: PPUSH
12081: CALL_OW 38
// if Belkov then
12085: LD_EXP 47
12089: IFFALSE 12103
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12091: LD_EXP 47
12095: PPUSH
12096: LD_STRING 13a_Belkov
12098: PPUSH
12099: CALL_OW 38
// if Gnyevko then
12103: LD_EXP 48
12107: IFFALSE 12121
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12109: LD_EXP 48
12113: PPUSH
12114: LD_STRING 13a_Gnyevko
12116: PPUSH
12117: CALL_OW 38
// if Lisa then
12121: LD_EXP 17
12125: IFFALSE 12139
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12127: LD_EXP 17
12131: PPUSH
12132: LD_STRING 13a_Lisa
12134: PPUSH
12135: CALL_OW 38
// if Donaldson then
12139: LD_EXP 18
12143: IFFALSE 12157
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12145: LD_EXP 18
12149: PPUSH
12150: LD_STRING 13a_Donaldson
12152: PPUSH
12153: CALL_OW 38
// if Bobby then
12157: LD_EXP 19
12161: IFFALSE 12175
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12163: LD_EXP 19
12167: PPUSH
12168: LD_STRING 13a_Bobby
12170: PPUSH
12171: CALL_OW 38
// if Cyrus then
12175: LD_EXP 20
12179: IFFALSE 12193
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12181: LD_EXP 20
12185: PPUSH
12186: LD_STRING 13a_Cyrus
12188: PPUSH
12189: CALL_OW 38
// if Denis then
12193: LD_EXP 21
12197: IFFALSE 12211
// SaveCharacters ( Denis , 13a_Denis ) ;
12199: LD_EXP 21
12203: PPUSH
12204: LD_STRING 13a_Denis
12206: PPUSH
12207: CALL_OW 38
// if Brown then
12211: LD_EXP 22
12215: IFFALSE 12229
// SaveCharacters ( Brown , 13a_Brown ) ;
12217: LD_EXP 22
12221: PPUSH
12222: LD_STRING 13a_Brown
12224: PPUSH
12225: CALL_OW 38
// if Gladstone then
12229: LD_EXP 23
12233: IFFALSE 12247
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12235: LD_EXP 23
12239: PPUSH
12240: LD_STRING 13a_Gladstone
12242: PPUSH
12243: CALL_OW 38
// if Houten then
12247: LD_EXP 24
12251: IFFALSE 12265
// SaveCharacters ( Houten , 13a_Houten ) ;
12253: LD_EXP 24
12257: PPUSH
12258: LD_STRING 13a_Houten
12260: PPUSH
12261: CALL_OW 38
// if Cornel then
12265: LD_EXP 25
12269: IFFALSE 12283
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12271: LD_EXP 25
12275: PPUSH
12276: LD_STRING 13a_Cornel
12278: PPUSH
12279: CALL_OW 38
// if Gary then
12283: LD_EXP 26
12287: IFFALSE 12301
// SaveCharacters ( Gary , 13a_Gary ) ;
12289: LD_EXP 26
12293: PPUSH
12294: LD_STRING 13a_Gary
12296: PPUSH
12297: CALL_OW 38
// if Frank then
12301: LD_EXP 27
12305: IFFALSE 12319
// SaveCharacters ( Frank , 13a_Frank ) ;
12307: LD_EXP 27
12311: PPUSH
12312: LD_STRING 13a_Frank
12314: PPUSH
12315: CALL_OW 38
// if Kikuchi then
12319: LD_EXP 28
12323: IFFALSE 12337
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12325: LD_EXP 28
12329: PPUSH
12330: LD_STRING 13a_Kikuchi
12332: PPUSH
12333: CALL_OW 38
// if Simms then
12337: LD_EXP 29
12341: IFFALSE 12355
// SaveCharacters ( Simms , 13a_Simms ) ;
12343: LD_EXP 29
12347: PPUSH
12348: LD_STRING 13a_Simms
12350: PPUSH
12351: CALL_OW 38
// if Joan then
12355: LD_EXP 30
12359: IFFALSE 12373
// SaveCharacters ( Joan , 13a_Joan ) ;
12361: LD_EXP 30
12365: PPUSH
12366: LD_STRING 13a_Joan
12368: PPUSH
12369: CALL_OW 38
// if DeltaDoctor then
12373: LD_EXP 31
12377: IFFALSE 12391
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12379: LD_EXP 31
12383: PPUSH
12384: LD_STRING 13a_DeltaDoctor
12386: PPUSH
12387: CALL_OW 38
// if Gossudarov then
12391: LD_EXP 32
12395: IFFALSE 12409
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12397: LD_EXP 32
12401: PPUSH
12402: LD_STRING 13a_Gossudarov
12404: PPUSH
12405: CALL_OW 38
// if Kirilenkova then
12409: LD_EXP 33
12413: IFFALSE 12427
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12415: LD_EXP 33
12419: PPUSH
12420: LD_STRING 13a_Kirilenkova
12422: PPUSH
12423: CALL_OW 38
// if Roth then
12427: LD_EXP 16
12431: IFFALSE 12445
// SaveCharacters ( Roth , 13a_Roth ) ;
12433: LD_EXP 16
12437: PPUSH
12438: LD_STRING 13a_Roth
12440: PPUSH
12441: CALL_OW 38
// if Masha then
12445: LD_EXP 49
12449: IFFALSE 12504
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12451: LD_EXP 49
12455: PPUSH
12456: CALL_OW 265
12460: PUSH
12461: LD_EXP 49
12465: PPUSH
12466: CALL_OW 262
12470: PUSH
12471: LD_EXP 49
12475: PPUSH
12476: CALL_OW 263
12480: PUSH
12481: LD_EXP 49
12485: PPUSH
12486: CALL_OW 264
12490: PUSH
12491: EMPTY
12492: LIST
12493: LIST
12494: LIST
12495: LIST
12496: PPUSH
12497: LD_STRING 13a_Masha
12499: PPUSH
12500: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12504: LD_ADDR_VAR 0 2
12508: PUSH
12509: LD_INT 21
12511: PUSH
12512: LD_INT 3
12514: PUSH
12515: EMPTY
12516: LIST
12517: LIST
12518: PPUSH
12519: CALL_OW 69
12523: ST_TO_ADDR
// tmp2 := [ ] ;
12524: LD_ADDR_VAR 0 3
12528: PUSH
12529: EMPTY
12530: ST_TO_ADDR
// if tmp then
12531: LD_VAR 0 2
12535: IFFALSE 12686
// for i in tmp do
12537: LD_ADDR_VAR 0 1
12541: PUSH
12542: LD_VAR 0 2
12546: PUSH
12547: FOR_IN
12548: IFFALSE 12684
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12550: LD_ADDR_VAR 0 3
12554: PUSH
12555: LD_VAR 0 3
12559: PUSH
12560: LD_VAR 0 1
12564: PPUSH
12565: CALL_OW 255
12569: PUSH
12570: LD_VAR 0 1
12574: PPUSH
12575: CALL_OW 248
12579: PUSH
12580: LD_VAR 0 1
12584: PPUSH
12585: CALL_OW 266
12589: PUSH
12590: LD_VAR 0 1
12594: PPUSH
12595: CALL_OW 250
12599: PUSH
12600: LD_VAR 0 1
12604: PPUSH
12605: CALL_OW 251
12609: PUSH
12610: LD_VAR 0 1
12614: PPUSH
12615: CALL_OW 254
12619: PUSH
12620: LD_VAR 0 1
12624: PPUSH
12625: CALL_OW 267
12629: PUSH
12630: LD_VAR 0 1
12634: PPUSH
12635: LD_INT 1
12637: PPUSH
12638: CALL_OW 268
12642: PUSH
12643: LD_VAR 0 1
12647: PPUSH
12648: LD_INT 2
12650: PPUSH
12651: CALL_OW 268
12655: PUSH
12656: LD_VAR 0 1
12660: PPUSH
12661: CALL_OW 269
12665: PUSH
12666: EMPTY
12667: LIST
12668: LIST
12669: LIST
12670: LIST
12671: LIST
12672: LIST
12673: LIST
12674: LIST
12675: LIST
12676: LIST
12677: PUSH
12678: EMPTY
12679: LIST
12680: ADD
12681: ST_TO_ADDR
12682: GO 12547
12684: POP
12685: POP
// if tmp2 then
12686: LD_VAR 0 3
12690: IFFALSE 12704
// SaveVariable ( tmp2 , 13a_buildings ) ;
12692: LD_VAR 0 3
12696: PPUSH
12697: LD_STRING 13a_buildings
12699: PPUSH
12700: CALL_OW 39
// YouWin ;
12704: CALL_OW 103
// end ;
12708: PPOPN 6
12710: END
// export function SciRu ; var tmp , t ; begin
12711: LD_INT 0
12713: PPUSH
12714: PPUSH
12715: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12716: LD_ADDR_VAR 0 3
12720: PUSH
12721: LD_EXP 32
12725: PUSH
12726: LD_EXP 46
12730: PUSH
12731: LD_EXP 34
12735: PUSH
12736: LD_EXP 47
12740: PUSH
12741: LD_EXP 48
12745: PUSH
12746: LD_EXP 37
12750: PUSH
12751: LD_EXP 38
12755: PUSH
12756: LD_EXP 36
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: LIST
12765: LIST
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12771: LD_ADDR_VAR 0 2
12775: PUSH
12776: LD_INT 22
12778: PUSH
12779: LD_INT 7
12781: PUSH
12782: EMPTY
12783: LIST
12784: LIST
12785: PUSH
12786: LD_INT 23
12788: PUSH
12789: LD_INT 3
12791: PUSH
12792: EMPTY
12793: LIST
12794: LIST
12795: PUSH
12796: LD_INT 25
12798: PUSH
12799: LD_INT 4
12801: PUSH
12802: EMPTY
12803: LIST
12804: LIST
12805: PUSH
12806: LD_INT 26
12808: PUSH
12809: LD_INT 1
12811: PUSH
12812: EMPTY
12813: LIST
12814: LIST
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: PPUSH
12822: CALL_OW 69
12826: PUSH
12827: LD_VAR 0 3
12831: DIFF
12832: ST_TO_ADDR
// if tmp then
12833: LD_VAR 0 2
12837: IFFALSE 12853
// result := tmp [ 1 ] ;
12839: LD_ADDR_VAR 0 1
12843: PUSH
12844: LD_VAR 0 2
12848: PUSH
12849: LD_INT 1
12851: ARRAY
12852: ST_TO_ADDR
// end ;
12853: LD_VAR 0 1
12857: RET
// export function SolRu ; var tmp , t ; begin
12858: LD_INT 0
12860: PPUSH
12861: PPUSH
12862: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12863: LD_ADDR_VAR 0 3
12867: PUSH
12868: LD_EXP 32
12872: PUSH
12873: LD_EXP 46
12877: PUSH
12878: LD_EXP 34
12882: PUSH
12883: LD_EXP 47
12887: PUSH
12888: LD_EXP 48
12892: PUSH
12893: LD_EXP 37
12897: PUSH
12898: LD_EXP 38
12902: PUSH
12903: LD_EXP 36
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: LIST
12912: LIST
12913: LIST
12914: LIST
12915: LIST
12916: LIST
12917: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12918: LD_ADDR_VAR 0 2
12922: PUSH
12923: LD_INT 22
12925: PUSH
12926: LD_INT 7
12928: PUSH
12929: EMPTY
12930: LIST
12931: LIST
12932: PUSH
12933: LD_INT 23
12935: PUSH
12936: LD_INT 3
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: PUSH
12943: LD_INT 25
12945: PUSH
12946: LD_INT 1
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PUSH
12953: LD_INT 26
12955: PUSH
12956: LD_INT 1
12958: PUSH
12959: EMPTY
12960: LIST
12961: LIST
12962: PUSH
12963: EMPTY
12964: LIST
12965: LIST
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 69
12973: PUSH
12974: LD_VAR 0 3
12978: DIFF
12979: ST_TO_ADDR
// if tmp then
12980: LD_VAR 0 2
12984: IFFALSE 13000
// result := tmp [ 1 ] ;
12986: LD_ADDR_VAR 0 1
12990: PUSH
12991: LD_VAR 0 2
12995: PUSH
12996: LD_INT 1
12998: ARRAY
12999: ST_TO_ADDR
// end ; end_of_file
13000: LD_VAR 0 1
13004: RET
// export function CustomEvent ( event ) ; begin
13005: LD_INT 0
13007: PPUSH
// end ;
13008: LD_VAR 0 2
13012: RET
// on UnitDestroyed ( un ) do var i , side ;
13013: LD_INT 0
13015: PPUSH
13016: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13017: LD_VAR 0 1
13021: PUSH
13022: LD_INT 22
13024: PUSH
13025: LD_INT 7
13027: PUSH
13028: EMPTY
13029: LIST
13030: LIST
13031: PUSH
13032: LD_INT 2
13034: PUSH
13035: LD_INT 25
13037: PUSH
13038: LD_INT 1
13040: PUSH
13041: EMPTY
13042: LIST
13043: LIST
13044: PUSH
13045: LD_INT 25
13047: PUSH
13048: LD_INT 2
13050: PUSH
13051: EMPTY
13052: LIST
13053: LIST
13054: PUSH
13055: LD_INT 25
13057: PUSH
13058: LD_INT 3
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: PUSH
13065: LD_INT 25
13067: PUSH
13068: LD_INT 4
13070: PUSH
13071: EMPTY
13072: LIST
13073: LIST
13074: PUSH
13075: LD_INT 25
13077: PUSH
13078: LD_INT 5
13080: PUSH
13081: EMPTY
13082: LIST
13083: LIST
13084: PUSH
13085: LD_INT 25
13087: PUSH
13088: LD_INT 8
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: PUSH
13095: LD_INT 25
13097: PUSH
13098: LD_INT 9
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: PUSH
13105: EMPTY
13106: LIST
13107: LIST
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: LIST
13114: PUSH
13115: EMPTY
13116: LIST
13117: LIST
13118: PPUSH
13119: CALL_OW 69
13123: IN
13124: IFFALSE 13140
// loss_counter := loss_counter + 1 ;
13126: LD_ADDR_EXP 13
13130: PUSH
13131: LD_EXP 13
13135: PUSH
13136: LD_INT 1
13138: PLUS
13139: ST_TO_ADDR
// if un = Abdul then
13140: LD_VAR 0 1
13144: PUSH
13145: LD_EXP 55
13149: EQUAL
13150: IFFALSE 13160
// abdul_escaped := false ;
13152: LD_ADDR_EXP 12
13156: PUSH
13157: LD_INT 0
13159: ST_TO_ADDR
// if un in ru_attackers then
13160: LD_VAR 0 1
13164: PUSH
13165: LD_EXP 52
13169: IN
13170: IFFALSE 13188
// ru_attackers := ru_attackers diff un ;
13172: LD_ADDR_EXP 52
13176: PUSH
13177: LD_EXP 52
13181: PUSH
13182: LD_VAR 0 1
13186: DIFF
13187: ST_TO_ADDR
// if un in ar_attackers then
13188: LD_VAR 0 1
13192: PUSH
13193: LD_EXP 10
13197: IN
13198: IFFALSE 13216
// ar_attackers := ar_attackers diff un ;
13200: LD_ADDR_EXP 10
13204: PUSH
13205: LD_EXP 10
13209: PUSH
13210: LD_VAR 0 1
13214: DIFF
13215: ST_TO_ADDR
// if un = JMM then
13216: LD_VAR 0 1
13220: PUSH
13221: LD_EXP 15
13225: EQUAL
13226: IFFALSE 13237
// begin YouLost ( JMM ) ;
13228: LD_STRING JMM
13230: PPUSH
13231: CALL_OW 104
// exit ;
13235: GO 13326
// end ; if un = Burlak then
13237: LD_VAR 0 1
13241: PUSH
13242: LD_EXP 46
13246: EQUAL
13247: IFFALSE 13258
// begin YouLost ( Burlak ) ;
13249: LD_STRING Burlak
13251: PPUSH
13252: CALL_OW 104
// exit ;
13256: GO 13326
// end ; if un = freedom then
13258: LD_VAR 0 1
13262: PUSH
13263: LD_EXP 3
13267: EQUAL
13268: IFFALSE 13279
// begin YouLost ( Destroyed ) ;
13270: LD_STRING Destroyed
13272: PPUSH
13273: CALL_OW 104
// exit ;
13277: GO 13326
// end ; if un = Masha then
13279: LD_VAR 0 1
13283: PUSH
13284: LD_EXP 49
13288: EQUAL
13289: IFFALSE 13298
// ChangeMissionObjectives ( M4b ) ;
13291: LD_STRING M4b
13293: PPUSH
13294: CALL_OW 337
// if un = Mastodont then
13298: LD_VAR 0 1
13302: PUSH
13303: LD_EXP 56
13307: EQUAL
13308: IFFALSE 13317
// ChangeMissionObjectives ( M4a ) ;
13310: LD_STRING M4a
13312: PPUSH
13313: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13317: LD_VAR 0 1
13321: PPUSH
13322: CALL 84536 0 1
// end ;
13326: PPOPN 3
13328: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13329: LD_VAR 0 1
13333: PPUSH
13334: LD_VAR 0 2
13338: PPUSH
13339: CALL 86870 0 2
// end ;
13343: PPOPN 2
13345: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13346: LD_VAR 0 1
13350: PPUSH
13351: CALL 85938 0 1
// end ;
13355: PPOPN 1
13357: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13358: LD_VAR 0 1
13362: PUSH
13363: LD_INT 22
13365: PUSH
13366: LD_INT 7
13368: PUSH
13369: EMPTY
13370: LIST
13371: LIST
13372: PUSH
13373: LD_INT 30
13375: PUSH
13376: LD_INT 0
13378: PUSH
13379: EMPTY
13380: LIST
13381: LIST
13382: PUSH
13383: EMPTY
13384: LIST
13385: LIST
13386: PPUSH
13387: CALL_OW 69
13391: IN
13392: IFFALSE 13431
// begin SetBName ( building , freedom ) ;
13394: LD_VAR 0 1
13398: PPUSH
13399: LD_STRING freedom
13401: PPUSH
13402: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13406: LD_INT 0
13408: PPUSH
13409: LD_INT 7
13411: PPUSH
13412: LD_INT 0
13414: PPUSH
13415: CALL_OW 324
// freedom := building ;
13419: LD_ADDR_EXP 3
13423: PUSH
13424: LD_VAR 0 1
13428: ST_TO_ADDR
// exit ;
13429: GO 13497
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13431: LD_VAR 0 1
13435: PUSH
13436: LD_INT 22
13438: PUSH
13439: LD_INT 7
13441: PUSH
13442: EMPTY
13443: LIST
13444: LIST
13445: PUSH
13446: LD_INT 23
13448: PUSH
13449: LD_INT 3
13451: PUSH
13452: EMPTY
13453: LIST
13454: LIST
13455: PUSH
13456: LD_INT 30
13458: PUSH
13459: LD_INT 6
13461: PUSH
13462: EMPTY
13463: LIST
13464: LIST
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: LIST
13470: PPUSH
13471: CALL_OW 69
13475: IN
13476: IFFALSE 13488
// begin ru_lab_builded := true ;
13478: LD_ADDR_EXP 5
13482: PUSH
13483: LD_INT 1
13485: ST_TO_ADDR
// exit ;
13486: GO 13497
// end ; MCE_BuildingComplete ( building ) ;
13488: LD_VAR 0 1
13492: PPUSH
13493: CALL 86179 0 1
// end ;
13497: PPOPN 1
13499: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13500: LD_VAR 0 1
13504: PPUSH
13505: LD_VAR 0 2
13509: PPUSH
13510: CALL 84232 0 2
// end ;
13514: PPOPN 2
13516: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13517: LD_VAR 0 1
13521: PPUSH
13522: LD_VAR 0 2
13526: PPUSH
13527: LD_VAR 0 3
13531: PPUSH
13532: LD_VAR 0 4
13536: PPUSH
13537: LD_VAR 0 5
13541: PPUSH
13542: CALL 83852 0 5
// end ;
13546: PPOPN 5
13548: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13549: LD_VAR 0 1
13553: PPUSH
13554: LD_VAR 0 2
13558: PPUSH
13559: CALL 83448 0 2
// end ;
13563: PPOPN 2
13565: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
13566: LD_VAR 0 1
13570: PPUSH
13571: CALL_OW 263
13575: PUSH
13576: LD_INT 3
13578: EQUAL
13579: PUSH
13580: LD_VAR 0 2
13584: PPUSH
13585: CALL_OW 263
13589: PUSH
13590: LD_INT 3
13592: EQUAL
13593: OR
13594: IFFALSE 13610
// hack_counter := hack_counter + 1 ;
13596: LD_ADDR_EXP 14
13600: PUSH
13601: LD_EXP 14
13605: PUSH
13606: LD_INT 1
13608: PLUS
13609: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13610: LD_VAR 0 1
13614: PPUSH
13615: LD_VAR 0 2
13619: PPUSH
13620: LD_VAR 0 3
13624: PPUSH
13625: LD_VAR 0 4
13629: PPUSH
13630: CALL 83286 0 4
// end ;
13634: PPOPN 4
13636: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13637: LD_VAR 0 1
13641: PPUSH
13642: LD_VAR 0 2
13646: PPUSH
13647: LD_VAR 0 3
13651: PPUSH
13652: CALL 83061 0 3
// end ;
13656: PPOPN 3
13658: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13659: LD_VAR 0 1
13663: PPUSH
13664: LD_VAR 0 2
13668: PPUSH
13669: CALL 82946 0 2
// end ;
13673: PPOPN 2
13675: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13676: LD_VAR 0 1
13680: PPUSH
13681: LD_VAR 0 2
13685: PPUSH
13686: CALL 87131 0 2
// end ;
13690: PPOPN 2
13692: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13693: LD_VAR 0 1
13697: PPUSH
13698: LD_VAR 0 2
13702: PPUSH
13703: LD_VAR 0 3
13707: PPUSH
13708: LD_VAR 0 4
13712: PPUSH
13713: CALL 87347 0 4
// end ;
13717: PPOPN 4
13719: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13720: LD_VAR 0 1
13724: PPUSH
13725: LD_VAR 0 2
13729: PPUSH
13730: CALL 82755 0 2
// end ;
13734: PPOPN 2
13736: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13737: LD_VAR 0 1
13741: PPUSH
13742: CALL 87630 0 1
// end ; end_of_file
13746: PPOPN 1
13748: END
// every 0 0$30 do var cr , time ;
13749: GO 13751
13751: DISABLE
13752: LD_INT 0
13754: PPUSH
13755: PPUSH
// begin time := 0 0$30 ;
13756: LD_ADDR_VAR 0 2
13760: PUSH
13761: LD_INT 1050
13763: ST_TO_ADDR
// while game do
13764: LD_EXP 2
13768: IFFALSE 13867
// begin wait ( time ) ;
13770: LD_VAR 0 2
13774: PPUSH
13775: CALL_OW 67
// if tick > 2 2$00 then
13779: LD_OWVAR 1
13783: PUSH
13784: LD_INT 4200
13786: GREATER
13787: IFFALSE 13820
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13789: LD_ADDR_VAR 0 2
13793: PUSH
13794: LD_VAR 0 2
13798: PUSH
13799: LD_INT 280
13801: PUSH
13802: LD_INT 420
13804: PUSH
13805: LD_INT 630
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: LIST
13812: PUSH
13813: LD_OWVAR 67
13817: ARRAY
13818: PLUS
13819: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13820: LD_INT 1
13822: PPUSH
13823: LD_INT 5
13825: PPUSH
13826: CALL_OW 12
13830: PPUSH
13831: LD_INT 70
13833: PPUSH
13834: LD_INT 49
13836: PPUSH
13837: LD_INT 25
13839: PPUSH
13840: LD_INT 1
13842: PPUSH
13843: CALL_OW 56
// if time > 5 5$00 then
13847: LD_VAR 0 2
13851: PUSH
13852: LD_INT 10500
13854: GREATER
13855: IFFALSE 13865
// time := 0 0$30 ;
13857: LD_ADDR_VAR 0 2
13861: PUSH
13862: LD_INT 1050
13864: ST_TO_ADDR
// end ;
13865: GO 13764
// end ;
13867: PPOPN 2
13869: END
// every 0 0$30 do var cr , time ;
13870: GO 13872
13872: DISABLE
13873: LD_INT 0
13875: PPUSH
13876: PPUSH
// begin time := 0 0$20 ;
13877: LD_ADDR_VAR 0 2
13881: PUSH
13882: LD_INT 700
13884: ST_TO_ADDR
// while game do
13885: LD_EXP 2
13889: IFFALSE 13978
// begin wait ( time ) ;
13891: LD_VAR 0 2
13895: PPUSH
13896: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13900: LD_ADDR_VAR 0 2
13904: PUSH
13905: LD_VAR 0 2
13909: PUSH
13910: LD_INT 490
13912: PUSH
13913: LD_INT 525
13915: PUSH
13916: LD_INT 560
13918: PUSH
13919: EMPTY
13920: LIST
13921: LIST
13922: LIST
13923: PUSH
13924: LD_OWVAR 67
13928: ARRAY
13929: PLUS
13930: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13931: LD_INT 3
13933: PPUSH
13934: LD_INT 5
13936: PPUSH
13937: CALL_OW 12
13941: PPUSH
13942: LD_INT 26
13944: PPUSH
13945: LD_INT 9
13947: PPUSH
13948: LD_INT 30
13950: PPUSH
13951: LD_INT 1
13953: PPUSH
13954: CALL_OW 56
// if time > 3 3$00 then
13958: LD_VAR 0 2
13962: PUSH
13963: LD_INT 6300
13965: GREATER
13966: IFFALSE 13976
// time := 0 0$20 ;
13968: LD_ADDR_VAR 0 2
13972: PUSH
13973: LD_INT 700
13975: ST_TO_ADDR
// end ;
13976: GO 13885
// end ;
13978: PPOPN 2
13980: END
// every 0 0$30 do var cr , time ;
13981: GO 13983
13983: DISABLE
13984: LD_INT 0
13986: PPUSH
13987: PPUSH
// begin time := 0 0$20 ;
13988: LD_ADDR_VAR 0 2
13992: PUSH
13993: LD_INT 700
13995: ST_TO_ADDR
// while game do
13996: LD_EXP 2
14000: IFFALSE 14125
// begin wait ( time ) ;
14002: LD_VAR 0 2
14006: PPUSH
14007: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14011: LD_ADDR_VAR 0 2
14015: PUSH
14016: LD_VAR 0 2
14020: PUSH
14021: LD_INT 175
14023: PUSH
14024: LD_INT 210
14026: PUSH
14027: LD_INT 280
14029: PUSH
14030: EMPTY
14031: LIST
14032: LIST
14033: LIST
14034: PUSH
14035: LD_OWVAR 67
14039: ARRAY
14040: PLUS
14041: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14042: LD_INT 1
14044: PPUSH
14045: LD_INT 5
14047: PPUSH
14048: CALL_OW 12
14052: PPUSH
14053: LD_INT 179
14055: PPUSH
14056: LD_INT 101
14058: PPUSH
14059: LD_INT 20
14061: PPUSH
14062: LD_INT 1
14064: PPUSH
14065: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14069: LD_INT 350
14071: PPUSH
14072: LD_INT 525
14074: PPUSH
14075: CALL_OW 12
14079: PPUSH
14080: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14084: LD_INT 1
14086: PPUSH
14087: LD_INT 5
14089: PPUSH
14090: CALL_OW 12
14094: PPUSH
14095: LD_INT 9
14097: PPUSH
14098: LD_INT 1
14100: PPUSH
14101: CALL_OW 55
// if time > 4 4$00 then
14105: LD_VAR 0 2
14109: PUSH
14110: LD_INT 8400
14112: GREATER
14113: IFFALSE 14123
// time := 0 0$30 ;
14115: LD_ADDR_VAR 0 2
14119: PUSH
14120: LD_INT 1050
14122: ST_TO_ADDR
// end ;
14123: GO 13996
// end ;
14125: PPOPN 2
14127: END
// every 0 0$30 do var cr , time ;
14128: GO 14130
14130: DISABLE
14131: LD_INT 0
14133: PPUSH
14134: PPUSH
// begin time := 0 0$10 ;
14135: LD_ADDR_VAR 0 2
14139: PUSH
14140: LD_INT 350
14142: ST_TO_ADDR
// while game do
14143: LD_EXP 2
14147: IFFALSE 14281
// begin wait ( time ) ;
14149: LD_VAR 0 2
14153: PPUSH
14154: CALL_OW 67
// time := time + 0 0$10 ;
14158: LD_ADDR_VAR 0 2
14162: PUSH
14163: LD_VAR 0 2
14167: PUSH
14168: LD_INT 350
14170: PLUS
14171: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14172: LD_INT 1
14174: PPUSH
14175: LD_INT 5
14177: PPUSH
14178: CALL_OW 12
14182: PPUSH
14183: LD_INT 11
14185: PPUSH
14186: LD_INT 1
14188: PPUSH
14189: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14193: LD_ADDR_VAR 0 1
14197: PUSH
14198: LD_INT 1
14200: PPUSH
14201: LD_INT 3
14203: PPUSH
14204: CALL_OW 12
14208: ST_TO_ADDR
// if cr = 1 then
14209: LD_VAR 0 1
14213: PUSH
14214: LD_INT 1
14216: EQUAL
14217: IFFALSE 14261
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14219: LD_INT 700
14221: PPUSH
14222: LD_INT 1575
14224: PPUSH
14225: CALL_OW 12
14229: PPUSH
14230: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14234: LD_INT 1
14236: PPUSH
14237: LD_INT 5
14239: PPUSH
14240: CALL_OW 12
14244: PPUSH
14245: LD_INT 34
14247: PPUSH
14248: LD_INT 50
14250: PPUSH
14251: LD_INT 7
14253: PPUSH
14254: LD_INT 1
14256: PPUSH
14257: CALL_OW 56
// end ; if time > 8 8$00 then
14261: LD_VAR 0 2
14265: PUSH
14266: LD_INT 16800
14268: GREATER
14269: IFFALSE 14279
// time := 0 0$40 ;
14271: LD_ADDR_VAR 0 2
14275: PUSH
14276: LD_INT 1400
14278: ST_TO_ADDR
// end ;
14279: GO 14143
// end ; end_of_file
14281: PPOPN 2
14283: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14284: LD_INT 0
14286: PPUSH
14287: PPUSH
// if exist_mode then
14288: LD_VAR 0 2
14292: IFFALSE 14317
// unit := CreateCharacter ( prefix & ident ) else
14294: LD_ADDR_VAR 0 5
14298: PUSH
14299: LD_VAR 0 3
14303: PUSH
14304: LD_VAR 0 1
14308: STR
14309: PPUSH
14310: CALL_OW 34
14314: ST_TO_ADDR
14315: GO 14332
// unit := NewCharacter ( ident ) ;
14317: LD_ADDR_VAR 0 5
14321: PUSH
14322: LD_VAR 0 1
14326: PPUSH
14327: CALL_OW 25
14331: ST_TO_ADDR
// result := unit ;
14332: LD_ADDR_VAR 0 4
14336: PUSH
14337: LD_VAR 0 5
14341: ST_TO_ADDR
// end ;
14342: LD_VAR 0 4
14346: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14347: LD_INT 0
14349: PPUSH
14350: PPUSH
// if not side or not nation then
14351: LD_VAR 0 1
14355: NOT
14356: PUSH
14357: LD_VAR 0 2
14361: NOT
14362: OR
14363: IFFALSE 14367
// exit ;
14365: GO 15011
// case nation of nation_american :
14367: LD_VAR 0 2
14371: PUSH
14372: LD_INT 1
14374: DOUBLE
14375: EQUAL
14376: IFTRUE 14380
14378: GO 14554
14380: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
14381: LD_ADDR_VAR 0 4
14385: PUSH
14386: LD_INT 35
14388: PUSH
14389: LD_INT 45
14391: PUSH
14392: LD_INT 46
14394: PUSH
14395: LD_INT 47
14397: PUSH
14398: LD_INT 1
14400: PUSH
14401: LD_INT 2
14403: PUSH
14404: LD_INT 6
14406: PUSH
14407: LD_INT 15
14409: PUSH
14410: LD_INT 16
14412: PUSH
14413: LD_INT 7
14415: PUSH
14416: LD_INT 12
14418: PUSH
14419: LD_INT 13
14421: PUSH
14422: LD_INT 10
14424: PUSH
14425: LD_INT 14
14427: PUSH
14428: LD_INT 20
14430: PUSH
14431: LD_INT 21
14433: PUSH
14434: LD_INT 22
14436: PUSH
14437: LD_INT 25
14439: PUSH
14440: LD_INT 32
14442: PUSH
14443: LD_INT 27
14445: PUSH
14446: LD_INT 36
14448: PUSH
14449: LD_INT 69
14451: PUSH
14452: LD_INT 39
14454: PUSH
14455: LD_INT 34
14457: PUSH
14458: LD_INT 40
14460: PUSH
14461: LD_INT 48
14463: PUSH
14464: LD_INT 49
14466: PUSH
14467: LD_INT 50
14469: PUSH
14470: LD_INT 51
14472: PUSH
14473: LD_INT 52
14475: PUSH
14476: LD_INT 53
14478: PUSH
14479: LD_INT 54
14481: PUSH
14482: LD_INT 55
14484: PUSH
14485: LD_INT 56
14487: PUSH
14488: LD_INT 57
14490: PUSH
14491: LD_INT 58
14493: PUSH
14494: LD_INT 59
14496: PUSH
14497: LD_INT 60
14499: PUSH
14500: LD_INT 61
14502: PUSH
14503: LD_INT 62
14505: PUSH
14506: LD_INT 80
14508: PUSH
14509: EMPTY
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: LIST
14521: LIST
14522: LIST
14523: LIST
14524: LIST
14525: LIST
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: ST_TO_ADDR
14552: GO 14935
14554: LD_INT 2
14556: DOUBLE
14557: EQUAL
14558: IFTRUE 14562
14560: GO 14744
14562: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
14563: LD_ADDR_VAR 0 4
14567: PUSH
14568: LD_INT 35
14570: PUSH
14571: LD_INT 45
14573: PUSH
14574: LD_INT 46
14576: PUSH
14577: LD_INT 47
14579: PUSH
14580: LD_INT 70
14582: PUSH
14583: LD_INT 1
14585: PUSH
14586: LD_INT 11
14588: PUSH
14589: LD_INT 3
14591: PUSH
14592: LD_INT 4
14594: PUSH
14595: LD_INT 5
14597: PUSH
14598: LD_INT 6
14600: PUSH
14601: LD_INT 15
14603: PUSH
14604: LD_INT 18
14606: PUSH
14607: LD_INT 7
14609: PUSH
14610: LD_INT 17
14612: PUSH
14613: LD_INT 8
14615: PUSH
14616: LD_INT 20
14618: PUSH
14619: LD_INT 21
14621: PUSH
14622: LD_INT 22
14624: PUSH
14625: LD_INT 72
14627: PUSH
14628: LD_INT 26
14630: PUSH
14631: LD_INT 69
14633: PUSH
14634: LD_INT 39
14636: PUSH
14637: LD_INT 40
14639: PUSH
14640: LD_INT 41
14642: PUSH
14643: LD_INT 42
14645: PUSH
14646: LD_INT 43
14648: PUSH
14649: LD_INT 48
14651: PUSH
14652: LD_INT 49
14654: PUSH
14655: LD_INT 50
14657: PUSH
14658: LD_INT 51
14660: PUSH
14661: LD_INT 52
14663: PUSH
14664: LD_INT 53
14666: PUSH
14667: LD_INT 54
14669: PUSH
14670: LD_INT 55
14672: PUSH
14673: LD_INT 56
14675: PUSH
14676: LD_INT 60
14678: PUSH
14679: LD_INT 61
14681: PUSH
14682: LD_INT 62
14684: PUSH
14685: LD_INT 66
14687: PUSH
14688: LD_INT 67
14690: PUSH
14691: LD_INT 68
14693: PUSH
14694: LD_INT 81
14696: PUSH
14697: EMPTY
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: LIST
14706: LIST
14707: LIST
14708: LIST
14709: LIST
14710: LIST
14711: LIST
14712: LIST
14713: LIST
14714: LIST
14715: LIST
14716: LIST
14717: LIST
14718: LIST
14719: LIST
14720: LIST
14721: LIST
14722: LIST
14723: LIST
14724: LIST
14725: LIST
14726: LIST
14727: LIST
14728: LIST
14729: LIST
14730: LIST
14731: LIST
14732: LIST
14733: LIST
14734: LIST
14735: LIST
14736: LIST
14737: LIST
14738: LIST
14739: LIST
14740: LIST
14741: ST_TO_ADDR
14742: GO 14935
14744: LD_INT 3
14746: DOUBLE
14747: EQUAL
14748: IFTRUE 14752
14750: GO 14934
14752: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14753: LD_ADDR_VAR 0 4
14757: PUSH
14758: LD_INT 46
14760: PUSH
14761: LD_INT 47
14763: PUSH
14764: LD_INT 1
14766: PUSH
14767: LD_INT 2
14769: PUSH
14770: LD_INT 11
14772: PUSH
14773: LD_INT 9
14775: PUSH
14776: LD_INT 20
14778: PUSH
14779: LD_INT 19
14781: PUSH
14782: LD_INT 21
14784: PUSH
14785: LD_INT 24
14787: PUSH
14788: LD_INT 22
14790: PUSH
14791: LD_INT 25
14793: PUSH
14794: LD_INT 28
14796: PUSH
14797: LD_INT 29
14799: PUSH
14800: LD_INT 30
14802: PUSH
14803: LD_INT 31
14805: PUSH
14806: LD_INT 37
14808: PUSH
14809: LD_INT 38
14811: PUSH
14812: LD_INT 32
14814: PUSH
14815: LD_INT 27
14817: PUSH
14818: LD_INT 33
14820: PUSH
14821: LD_INT 69
14823: PUSH
14824: LD_INT 39
14826: PUSH
14827: LD_INT 34
14829: PUSH
14830: LD_INT 40
14832: PUSH
14833: LD_INT 71
14835: PUSH
14836: LD_INT 23
14838: PUSH
14839: LD_INT 44
14841: PUSH
14842: LD_INT 48
14844: PUSH
14845: LD_INT 49
14847: PUSH
14848: LD_INT 50
14850: PUSH
14851: LD_INT 51
14853: PUSH
14854: LD_INT 52
14856: PUSH
14857: LD_INT 53
14859: PUSH
14860: LD_INT 54
14862: PUSH
14863: LD_INT 55
14865: PUSH
14866: LD_INT 56
14868: PUSH
14869: LD_INT 57
14871: PUSH
14872: LD_INT 58
14874: PUSH
14875: LD_INT 59
14877: PUSH
14878: LD_INT 63
14880: PUSH
14881: LD_INT 64
14883: PUSH
14884: LD_INT 65
14886: PUSH
14887: EMPTY
14888: LIST
14889: LIST
14890: LIST
14891: LIST
14892: LIST
14893: LIST
14894: LIST
14895: LIST
14896: LIST
14897: LIST
14898: LIST
14899: LIST
14900: LIST
14901: LIST
14902: LIST
14903: LIST
14904: LIST
14905: LIST
14906: LIST
14907: LIST
14908: LIST
14909: LIST
14910: LIST
14911: LIST
14912: LIST
14913: LIST
14914: LIST
14915: LIST
14916: LIST
14917: LIST
14918: LIST
14919: LIST
14920: LIST
14921: LIST
14922: LIST
14923: LIST
14924: LIST
14925: LIST
14926: LIST
14927: LIST
14928: LIST
14929: LIST
14930: LIST
14931: ST_TO_ADDR
14932: GO 14935
14934: POP
// if state > - 1 and state < 3 then
14935: LD_VAR 0 3
14939: PUSH
14940: LD_INT 1
14942: NEG
14943: GREATER
14944: PUSH
14945: LD_VAR 0 3
14949: PUSH
14950: LD_INT 3
14952: LESS
14953: AND
14954: IFFALSE 15011
// for i in result do
14956: LD_ADDR_VAR 0 5
14960: PUSH
14961: LD_VAR 0 4
14965: PUSH
14966: FOR_IN
14967: IFFALSE 15009
// if GetTech ( i , side ) <> state then
14969: LD_VAR 0 5
14973: PPUSH
14974: LD_VAR 0 1
14978: PPUSH
14979: CALL_OW 321
14983: PUSH
14984: LD_VAR 0 3
14988: NONEQUAL
14989: IFFALSE 15007
// result := result diff i ;
14991: LD_ADDR_VAR 0 4
14995: PUSH
14996: LD_VAR 0 4
15000: PUSH
15001: LD_VAR 0 5
15005: DIFF
15006: ST_TO_ADDR
15007: GO 14966
15009: POP
15010: POP
// end ;
15011: LD_VAR 0 4
15015: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15016: LD_INT 0
15018: PPUSH
15019: PPUSH
15020: PPUSH
// result := true ;
15021: LD_ADDR_VAR 0 3
15025: PUSH
15026: LD_INT 1
15028: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15029: LD_ADDR_VAR 0 5
15033: PUSH
15034: LD_VAR 0 2
15038: PPUSH
15039: CALL_OW 480
15043: ST_TO_ADDR
// if not tmp then
15044: LD_VAR 0 5
15048: NOT
15049: IFFALSE 15053
// exit ;
15051: GO 15102
// for i in tmp do
15053: LD_ADDR_VAR 0 4
15057: PUSH
15058: LD_VAR 0 5
15062: PUSH
15063: FOR_IN
15064: IFFALSE 15100
// if GetTech ( i , side ) <> state_researched then
15066: LD_VAR 0 4
15070: PPUSH
15071: LD_VAR 0 1
15075: PPUSH
15076: CALL_OW 321
15080: PUSH
15081: LD_INT 2
15083: NONEQUAL
15084: IFFALSE 15098
// begin result := false ;
15086: LD_ADDR_VAR 0 3
15090: PUSH
15091: LD_INT 0
15093: ST_TO_ADDR
// exit ;
15094: POP
15095: POP
15096: GO 15102
// end ;
15098: GO 15063
15100: POP
15101: POP
// end ;
15102: LD_VAR 0 3
15106: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15107: LD_INT 0
15109: PPUSH
15110: PPUSH
15111: PPUSH
15112: PPUSH
15113: PPUSH
15114: PPUSH
15115: PPUSH
15116: PPUSH
15117: PPUSH
15118: PPUSH
15119: PPUSH
15120: PPUSH
15121: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15122: LD_VAR 0 1
15126: NOT
15127: PUSH
15128: LD_VAR 0 1
15132: PPUSH
15133: CALL_OW 257
15137: PUSH
15138: LD_INT 9
15140: NONEQUAL
15141: OR
15142: IFFALSE 15146
// exit ;
15144: GO 15719
// side := GetSide ( unit ) ;
15146: LD_ADDR_VAR 0 9
15150: PUSH
15151: LD_VAR 0 1
15155: PPUSH
15156: CALL_OW 255
15160: ST_TO_ADDR
// tech_space := tech_spacanom ;
15161: LD_ADDR_VAR 0 12
15165: PUSH
15166: LD_INT 29
15168: ST_TO_ADDR
// tech_time := tech_taurad ;
15169: LD_ADDR_VAR 0 13
15173: PUSH
15174: LD_INT 28
15176: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15177: LD_ADDR_VAR 0 11
15181: PUSH
15182: LD_VAR 0 1
15186: PPUSH
15187: CALL_OW 310
15191: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15192: LD_VAR 0 11
15196: PPUSH
15197: CALL_OW 247
15201: PUSH
15202: LD_INT 2
15204: EQUAL
15205: IFFALSE 15209
// exit ;
15207: GO 15719
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15209: LD_ADDR_VAR 0 8
15213: PUSH
15214: LD_INT 81
15216: PUSH
15217: LD_VAR 0 9
15221: PUSH
15222: EMPTY
15223: LIST
15224: LIST
15225: PUSH
15226: LD_INT 3
15228: PUSH
15229: LD_INT 21
15231: PUSH
15232: LD_INT 3
15234: PUSH
15235: EMPTY
15236: LIST
15237: LIST
15238: PUSH
15239: EMPTY
15240: LIST
15241: LIST
15242: PUSH
15243: EMPTY
15244: LIST
15245: LIST
15246: PPUSH
15247: CALL_OW 69
15251: ST_TO_ADDR
// if not tmp then
15252: LD_VAR 0 8
15256: NOT
15257: IFFALSE 15261
// exit ;
15259: GO 15719
// if in_unit then
15261: LD_VAR 0 11
15265: IFFALSE 15289
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15267: LD_ADDR_VAR 0 10
15271: PUSH
15272: LD_VAR 0 8
15276: PPUSH
15277: LD_VAR 0 11
15281: PPUSH
15282: CALL_OW 74
15286: ST_TO_ADDR
15287: GO 15309
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15289: LD_ADDR_VAR 0 10
15293: PUSH
15294: LD_VAR 0 8
15298: PPUSH
15299: LD_VAR 0 1
15303: PPUSH
15304: CALL_OW 74
15308: ST_TO_ADDR
// if not enemy then
15309: LD_VAR 0 10
15313: NOT
15314: IFFALSE 15318
// exit ;
15316: GO 15719
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15318: LD_VAR 0 11
15322: PUSH
15323: LD_VAR 0 11
15327: PPUSH
15328: LD_VAR 0 10
15332: PPUSH
15333: CALL_OW 296
15337: PUSH
15338: LD_INT 13
15340: GREATER
15341: AND
15342: PUSH
15343: LD_VAR 0 1
15347: PPUSH
15348: LD_VAR 0 10
15352: PPUSH
15353: CALL_OW 296
15357: PUSH
15358: LD_INT 12
15360: GREATER
15361: OR
15362: IFFALSE 15366
// exit ;
15364: GO 15719
// missile := [ 1 ] ;
15366: LD_ADDR_VAR 0 14
15370: PUSH
15371: LD_INT 1
15373: PUSH
15374: EMPTY
15375: LIST
15376: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15377: LD_VAR 0 9
15381: PPUSH
15382: LD_VAR 0 12
15386: PPUSH
15387: CALL_OW 325
15391: IFFALSE 15420
// missile := Insert ( missile , missile + 1 , 2 ) ;
15393: LD_ADDR_VAR 0 14
15397: PUSH
15398: LD_VAR 0 14
15402: PPUSH
15403: LD_VAR 0 14
15407: PUSH
15408: LD_INT 1
15410: PLUS
15411: PPUSH
15412: LD_INT 2
15414: PPUSH
15415: CALL_OW 2
15419: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15420: LD_VAR 0 9
15424: PPUSH
15425: LD_VAR 0 13
15429: PPUSH
15430: CALL_OW 325
15434: PUSH
15435: LD_VAR 0 10
15439: PPUSH
15440: CALL_OW 255
15444: PPUSH
15445: LD_VAR 0 13
15449: PPUSH
15450: CALL_OW 325
15454: NOT
15455: AND
15456: IFFALSE 15485
// missile := Insert ( missile , missile + 1 , 3 ) ;
15458: LD_ADDR_VAR 0 14
15462: PUSH
15463: LD_VAR 0 14
15467: PPUSH
15468: LD_VAR 0 14
15472: PUSH
15473: LD_INT 1
15475: PLUS
15476: PPUSH
15477: LD_INT 3
15479: PPUSH
15480: CALL_OW 2
15484: ST_TO_ADDR
// if missile < 2 then
15485: LD_VAR 0 14
15489: PUSH
15490: LD_INT 2
15492: LESS
15493: IFFALSE 15497
// exit ;
15495: GO 15719
// x := GetX ( enemy ) ;
15497: LD_ADDR_VAR 0 4
15501: PUSH
15502: LD_VAR 0 10
15506: PPUSH
15507: CALL_OW 250
15511: ST_TO_ADDR
// y := GetY ( enemy ) ;
15512: LD_ADDR_VAR 0 5
15516: PUSH
15517: LD_VAR 0 10
15521: PPUSH
15522: CALL_OW 251
15526: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15527: LD_ADDR_VAR 0 6
15531: PUSH
15532: LD_VAR 0 4
15536: PUSH
15537: LD_INT 1
15539: NEG
15540: PPUSH
15541: LD_INT 1
15543: PPUSH
15544: CALL_OW 12
15548: PLUS
15549: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15550: LD_ADDR_VAR 0 7
15554: PUSH
15555: LD_VAR 0 5
15559: PUSH
15560: LD_INT 1
15562: NEG
15563: PPUSH
15564: LD_INT 1
15566: PPUSH
15567: CALL_OW 12
15571: PLUS
15572: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15573: LD_VAR 0 6
15577: PPUSH
15578: LD_VAR 0 7
15582: PPUSH
15583: CALL_OW 488
15587: NOT
15588: IFFALSE 15610
// begin _x := x ;
15590: LD_ADDR_VAR 0 6
15594: PUSH
15595: LD_VAR 0 4
15599: ST_TO_ADDR
// _y := y ;
15600: LD_ADDR_VAR 0 7
15604: PUSH
15605: LD_VAR 0 5
15609: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15610: LD_ADDR_VAR 0 3
15614: PUSH
15615: LD_INT 1
15617: PPUSH
15618: LD_VAR 0 14
15622: PPUSH
15623: CALL_OW 12
15627: ST_TO_ADDR
// case i of 1 :
15628: LD_VAR 0 3
15632: PUSH
15633: LD_INT 1
15635: DOUBLE
15636: EQUAL
15637: IFTRUE 15641
15639: GO 15658
15641: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15642: LD_VAR 0 1
15646: PPUSH
15647: LD_VAR 0 10
15651: PPUSH
15652: CALL_OW 115
15656: GO 15719
15658: LD_INT 2
15660: DOUBLE
15661: EQUAL
15662: IFTRUE 15666
15664: GO 15688
15666: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15667: LD_VAR 0 1
15671: PPUSH
15672: LD_VAR 0 6
15676: PPUSH
15677: LD_VAR 0 7
15681: PPUSH
15682: CALL_OW 153
15686: GO 15719
15688: LD_INT 3
15690: DOUBLE
15691: EQUAL
15692: IFTRUE 15696
15694: GO 15718
15696: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15697: LD_VAR 0 1
15701: PPUSH
15702: LD_VAR 0 6
15706: PPUSH
15707: LD_VAR 0 7
15711: PPUSH
15712: CALL_OW 154
15716: GO 15719
15718: POP
// end ;
15719: LD_VAR 0 2
15723: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15724: LD_INT 0
15726: PPUSH
15727: PPUSH
15728: PPUSH
15729: PPUSH
15730: PPUSH
15731: PPUSH
// if not unit or not building then
15732: LD_VAR 0 1
15736: NOT
15737: PUSH
15738: LD_VAR 0 2
15742: NOT
15743: OR
15744: IFFALSE 15748
// exit ;
15746: GO 15906
// x := GetX ( building ) ;
15748: LD_ADDR_VAR 0 5
15752: PUSH
15753: LD_VAR 0 2
15757: PPUSH
15758: CALL_OW 250
15762: ST_TO_ADDR
// y := GetY ( building ) ;
15763: LD_ADDR_VAR 0 6
15767: PUSH
15768: LD_VAR 0 2
15772: PPUSH
15773: CALL_OW 251
15777: ST_TO_ADDR
// for i = 0 to 5 do
15778: LD_ADDR_VAR 0 4
15782: PUSH
15783: DOUBLE
15784: LD_INT 0
15786: DEC
15787: ST_TO_ADDR
15788: LD_INT 5
15790: PUSH
15791: FOR_TO
15792: IFFALSE 15904
// begin _x := ShiftX ( x , i , 3 ) ;
15794: LD_ADDR_VAR 0 7
15798: PUSH
15799: LD_VAR 0 5
15803: PPUSH
15804: LD_VAR 0 4
15808: PPUSH
15809: LD_INT 3
15811: PPUSH
15812: CALL_OW 272
15816: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15817: LD_ADDR_VAR 0 8
15821: PUSH
15822: LD_VAR 0 6
15826: PPUSH
15827: LD_VAR 0 4
15831: PPUSH
15832: LD_INT 3
15834: PPUSH
15835: CALL_OW 273
15839: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15840: LD_VAR 0 7
15844: PPUSH
15845: LD_VAR 0 8
15849: PPUSH
15850: CALL_OW 488
15854: NOT
15855: IFFALSE 15859
// continue ;
15857: GO 15791
// if HexInfo ( _x , _y ) = 0 then
15859: LD_VAR 0 7
15863: PPUSH
15864: LD_VAR 0 8
15868: PPUSH
15869: CALL_OW 428
15873: PUSH
15874: LD_INT 0
15876: EQUAL
15877: IFFALSE 15902
// begin ComMoveXY ( unit , _x , _y ) ;
15879: LD_VAR 0 1
15883: PPUSH
15884: LD_VAR 0 7
15888: PPUSH
15889: LD_VAR 0 8
15893: PPUSH
15894: CALL_OW 111
// exit ;
15898: POP
15899: POP
15900: GO 15906
// end ; end ;
15902: GO 15791
15904: POP
15905: POP
// end ;
15906: LD_VAR 0 3
15910: RET
// export function ScanBase ( side , base_area ) ; begin
15911: LD_INT 0
15913: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15914: LD_ADDR_VAR 0 3
15918: PUSH
15919: LD_VAR 0 2
15923: PPUSH
15924: LD_INT 81
15926: PUSH
15927: LD_VAR 0 1
15931: PUSH
15932: EMPTY
15933: LIST
15934: LIST
15935: PPUSH
15936: CALL_OW 70
15940: ST_TO_ADDR
// end ;
15941: LD_VAR 0 3
15945: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15946: LD_INT 0
15948: PPUSH
15949: PPUSH
15950: PPUSH
15951: PPUSH
15952: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15953: LD_VAR 0 1
15957: NOT
15958: PUSH
15959: LD_EXP 59
15963: PUSH
15964: LD_VAR 0 1
15968: ARRAY
15969: NOT
15970: OR
15971: PUSH
15972: LD_VAR 0 2
15976: NOT
15977: OR
15978: PUSH
15979: LD_VAR 0 3
15983: NOT
15984: OR
15985: IFFALSE 15989
// exit ;
15987: GO 16502
// side := mc_sides [ base ] ;
15989: LD_ADDR_VAR 0 6
15993: PUSH
15994: LD_EXP 85
15998: PUSH
15999: LD_VAR 0 1
16003: ARRAY
16004: ST_TO_ADDR
// if not side then
16005: LD_VAR 0 6
16009: NOT
16010: IFFALSE 16014
// exit ;
16012: GO 16502
// for i in solds do
16014: LD_ADDR_VAR 0 7
16018: PUSH
16019: LD_VAR 0 2
16023: PUSH
16024: FOR_IN
16025: IFFALSE 16086
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
16027: LD_VAR 0 7
16031: PPUSH
16032: CALL_OW 310
16036: PPUSH
16037: CALL_OW 266
16041: PUSH
16042: LD_INT 32
16044: PUSH
16045: LD_INT 31
16047: PUSH
16048: EMPTY
16049: LIST
16050: LIST
16051: IN
16052: IFFALSE 16072
// solds := solds diff i else
16054: LD_ADDR_VAR 0 2
16058: PUSH
16059: LD_VAR 0 2
16063: PUSH
16064: LD_VAR 0 7
16068: DIFF
16069: ST_TO_ADDR
16070: GO 16084
// SetTag ( i , 18 ) ;
16072: LD_VAR 0 7
16076: PPUSH
16077: LD_INT 18
16079: PPUSH
16080: CALL_OW 109
16084: GO 16024
16086: POP
16087: POP
// if not solds then
16088: LD_VAR 0 2
16092: NOT
16093: IFFALSE 16097
// exit ;
16095: GO 16502
// repeat wait ( 0 0$1 ) ;
16097: LD_INT 35
16099: PPUSH
16100: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
16104: LD_ADDR_VAR 0 5
16108: PUSH
16109: LD_VAR 0 6
16113: PPUSH
16114: LD_VAR 0 3
16118: PPUSH
16119: CALL 15911 0 2
16123: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16124: LD_EXP 59
16128: PUSH
16129: LD_VAR 0 1
16133: ARRAY
16134: NOT
16135: PUSH
16136: LD_EXP 59
16140: PUSH
16141: LD_VAR 0 1
16145: ARRAY
16146: PUSH
16147: EMPTY
16148: EQUAL
16149: OR
16150: IFFALSE 16187
// begin for i in solds do
16152: LD_ADDR_VAR 0 7
16156: PUSH
16157: LD_VAR 0 2
16161: PUSH
16162: FOR_IN
16163: IFFALSE 16176
// ComStop ( i ) ;
16165: LD_VAR 0 7
16169: PPUSH
16170: CALL_OW 141
16174: GO 16162
16176: POP
16177: POP
// solds := [ ] ;
16178: LD_ADDR_VAR 0 2
16182: PUSH
16183: EMPTY
16184: ST_TO_ADDR
// exit ;
16185: GO 16502
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
16187: LD_VAR 0 5
16191: NOT
16192: PUSH
16193: LD_VAR 0 5
16197: PUSH
16198: LD_INT 3
16200: GREATER
16201: OR
16202: PUSH
16203: LD_EXP 81
16207: PUSH
16208: LD_VAR 0 1
16212: ARRAY
16213: OR
16214: IFFALSE 16255
// begin for i in solds do
16216: LD_ADDR_VAR 0 7
16220: PUSH
16221: LD_VAR 0 2
16225: PUSH
16226: FOR_IN
16227: IFFALSE 16251
// if HasTask ( i ) then
16229: LD_VAR 0 7
16233: PPUSH
16234: CALL_OW 314
16238: IFFALSE 16249
// ComStop ( i ) ;
16240: LD_VAR 0 7
16244: PPUSH
16245: CALL_OW 141
16249: GO 16226
16251: POP
16252: POP
// break ;
16253: GO 16490
// end ; for i in solds do
16255: LD_ADDR_VAR 0 7
16259: PUSH
16260: LD_VAR 0 2
16264: PUSH
16265: FOR_IN
16266: IFFALSE 16482
// begin if IsInUnit ( i ) then
16268: LD_VAR 0 7
16272: PPUSH
16273: CALL_OW 310
16277: IFFALSE 16288
// ComExitBuilding ( i ) ;
16279: LD_VAR 0 7
16283: PPUSH
16284: CALL_OW 122
// if GetLives ( i ) > 333 then
16288: LD_VAR 0 7
16292: PPUSH
16293: CALL_OW 256
16297: PUSH
16298: LD_INT 333
16300: GREATER
16301: IFFALSE 16329
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
16303: LD_VAR 0 7
16307: PPUSH
16308: LD_VAR 0 5
16312: PPUSH
16313: LD_VAR 0 7
16317: PPUSH
16318: CALL_OW 74
16322: PPUSH
16323: CALL_OW 115
16327: GO 16480
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
16329: LD_ADDR_VAR 0 8
16333: PUSH
16334: LD_EXP 59
16338: PUSH
16339: LD_VAR 0 1
16343: ARRAY
16344: PPUSH
16345: LD_INT 2
16347: PUSH
16348: LD_INT 30
16350: PUSH
16351: LD_INT 0
16353: PUSH
16354: EMPTY
16355: LIST
16356: LIST
16357: PUSH
16358: LD_INT 30
16360: PUSH
16361: LD_INT 1
16363: PUSH
16364: EMPTY
16365: LIST
16366: LIST
16367: PUSH
16368: LD_INT 30
16370: PUSH
16371: LD_INT 6
16373: PUSH
16374: EMPTY
16375: LIST
16376: LIST
16377: PUSH
16378: EMPTY
16379: LIST
16380: LIST
16381: LIST
16382: LIST
16383: PPUSH
16384: CALL_OW 72
16388: PPUSH
16389: LD_VAR 0 7
16393: PPUSH
16394: CALL_OW 74
16398: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
16399: LD_VAR 0 7
16403: PPUSH
16404: LD_VAR 0 8
16408: PPUSH
16409: CALL_OW 250
16413: PPUSH
16414: LD_INT 3
16416: PPUSH
16417: LD_INT 5
16419: PPUSH
16420: CALL_OW 272
16424: PPUSH
16425: LD_VAR 0 8
16429: PPUSH
16430: CALL_OW 251
16434: PPUSH
16435: LD_INT 3
16437: PPUSH
16438: LD_INT 5
16440: PPUSH
16441: CALL_OW 273
16445: PPUSH
16446: CALL_OW 111
// SetTag ( i , 0 ) ;
16450: LD_VAR 0 7
16454: PPUSH
16455: LD_INT 0
16457: PPUSH
16458: CALL_OW 109
// solds := solds diff i ;
16462: LD_ADDR_VAR 0 2
16466: PUSH
16467: LD_VAR 0 2
16471: PUSH
16472: LD_VAR 0 7
16476: DIFF
16477: ST_TO_ADDR
// continue ;
16478: GO 16265
// end ; end ;
16480: GO 16265
16482: POP
16483: POP
// until solds ;
16484: LD_VAR 0 2
16488: IFFALSE 16097
// MC_Reset ( base , 18 ) ;
16490: LD_VAR 0 1
16494: PPUSH
16495: LD_INT 18
16497: PPUSH
16498: CALL 61527 0 2
// end ;
16502: LD_VAR 0 4
16506: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16507: LD_INT 0
16509: PPUSH
16510: PPUSH
16511: PPUSH
16512: PPUSH
16513: PPUSH
16514: PPUSH
16515: PPUSH
16516: PPUSH
16517: PPUSH
16518: PPUSH
16519: PPUSH
16520: PPUSH
16521: PPUSH
16522: PPUSH
16523: PPUSH
16524: PPUSH
16525: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16526: LD_ADDR_VAR 0 13
16530: PUSH
16531: LD_EXP 59
16535: PUSH
16536: LD_VAR 0 1
16540: ARRAY
16541: PPUSH
16542: LD_INT 25
16544: PUSH
16545: LD_INT 3
16547: PUSH
16548: EMPTY
16549: LIST
16550: LIST
16551: PPUSH
16552: CALL_OW 72
16556: ST_TO_ADDR
// if mc_remote_driver [ base ] then
16557: LD_EXP 99
16561: PUSH
16562: LD_VAR 0 1
16566: ARRAY
16567: IFFALSE 16591
// mechs := mechs diff mc_remote_driver [ base ] ;
16569: LD_ADDR_VAR 0 13
16573: PUSH
16574: LD_VAR 0 13
16578: PUSH
16579: LD_EXP 99
16583: PUSH
16584: LD_VAR 0 1
16588: ARRAY
16589: DIFF
16590: ST_TO_ADDR
// for i in mechs do
16591: LD_ADDR_VAR 0 5
16595: PUSH
16596: LD_VAR 0 13
16600: PUSH
16601: FOR_IN
16602: IFFALSE 16637
// if GetTag ( i ) > 0 then
16604: LD_VAR 0 5
16608: PPUSH
16609: CALL_OW 110
16613: PUSH
16614: LD_INT 0
16616: GREATER
16617: IFFALSE 16635
// mechs := mechs diff i ;
16619: LD_ADDR_VAR 0 13
16623: PUSH
16624: LD_VAR 0 13
16628: PUSH
16629: LD_VAR 0 5
16633: DIFF
16634: ST_TO_ADDR
16635: GO 16601
16637: POP
16638: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16639: LD_ADDR_VAR 0 9
16643: PUSH
16644: LD_EXP 59
16648: PUSH
16649: LD_VAR 0 1
16653: ARRAY
16654: PPUSH
16655: LD_INT 2
16657: PUSH
16658: LD_INT 25
16660: PUSH
16661: LD_INT 1
16663: PUSH
16664: EMPTY
16665: LIST
16666: LIST
16667: PUSH
16668: LD_INT 25
16670: PUSH
16671: LD_INT 5
16673: PUSH
16674: EMPTY
16675: LIST
16676: LIST
16677: PUSH
16678: LD_INT 25
16680: PUSH
16681: LD_INT 8
16683: PUSH
16684: EMPTY
16685: LIST
16686: LIST
16687: PUSH
16688: LD_INT 25
16690: PUSH
16691: LD_INT 9
16693: PUSH
16694: EMPTY
16695: LIST
16696: LIST
16697: PUSH
16698: EMPTY
16699: LIST
16700: LIST
16701: LIST
16702: LIST
16703: LIST
16704: PPUSH
16705: CALL_OW 72
16709: ST_TO_ADDR
// if not defenders and not solds then
16710: LD_VAR 0 2
16714: NOT
16715: PUSH
16716: LD_VAR 0 9
16720: NOT
16721: AND
16722: IFFALSE 16726
// exit ;
16724: GO 18352
// depot_under_attack := false ;
16726: LD_ADDR_VAR 0 17
16730: PUSH
16731: LD_INT 0
16733: ST_TO_ADDR
// sold_defenders := [ ] ;
16734: LD_ADDR_VAR 0 18
16738: PUSH
16739: EMPTY
16740: ST_TO_ADDR
// if mechs then
16741: LD_VAR 0 13
16745: IFFALSE 16874
// for i in defenders do
16747: LD_ADDR_VAR 0 5
16751: PUSH
16752: LD_VAR 0 2
16756: PUSH
16757: FOR_IN
16758: IFFALSE 16872
// begin SetTag ( i , 20 ) ;
16760: LD_VAR 0 5
16764: PPUSH
16765: LD_INT 20
16767: PPUSH
16768: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16772: LD_VAR 0 5
16776: PPUSH
16777: CALL_OW 263
16781: PUSH
16782: LD_INT 1
16784: EQUAL
16785: PUSH
16786: LD_VAR 0 5
16790: PPUSH
16791: CALL_OW 311
16795: NOT
16796: AND
16797: PUSH
16798: LD_VAR 0 13
16802: AND
16803: IFFALSE 16870
// begin un := mechs [ 1 ] ;
16805: LD_ADDR_VAR 0 11
16809: PUSH
16810: LD_VAR 0 13
16814: PUSH
16815: LD_INT 1
16817: ARRAY
16818: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16819: LD_VAR 0 11
16823: PPUSH
16824: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16828: LD_VAR 0 11
16832: PPUSH
16833: LD_VAR 0 5
16837: PPUSH
16838: CALL_OW 180
// SetTag ( un , 19 ) ;
16842: LD_VAR 0 11
16846: PPUSH
16847: LD_INT 19
16849: PPUSH
16850: CALL_OW 109
// mechs := mechs diff un ;
16854: LD_ADDR_VAR 0 13
16858: PUSH
16859: LD_VAR 0 13
16863: PUSH
16864: LD_VAR 0 11
16868: DIFF
16869: ST_TO_ADDR
// end ; end ;
16870: GO 16757
16872: POP
16873: POP
// if solds then
16874: LD_VAR 0 9
16878: IFFALSE 16937
// for i in solds do
16880: LD_ADDR_VAR 0 5
16884: PUSH
16885: LD_VAR 0 9
16889: PUSH
16890: FOR_IN
16891: IFFALSE 16935
// if not GetTag ( i ) then
16893: LD_VAR 0 5
16897: PPUSH
16898: CALL_OW 110
16902: NOT
16903: IFFALSE 16933
// begin defenders := defenders union i ;
16905: LD_ADDR_VAR 0 2
16909: PUSH
16910: LD_VAR 0 2
16914: PUSH
16915: LD_VAR 0 5
16919: UNION
16920: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16921: LD_VAR 0 5
16925: PPUSH
16926: LD_INT 18
16928: PPUSH
16929: CALL_OW 109
// end ;
16933: GO 16890
16935: POP
16936: POP
// repeat wait ( 0 0$1 ) ;
16937: LD_INT 35
16939: PPUSH
16940: CALL_OW 67
// enemy := mc_scan [ base ] ;
16944: LD_ADDR_VAR 0 3
16948: PUSH
16949: LD_EXP 82
16953: PUSH
16954: LD_VAR 0 1
16958: ARRAY
16959: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16960: LD_EXP 59
16964: PUSH
16965: LD_VAR 0 1
16969: ARRAY
16970: NOT
16971: PUSH
16972: LD_EXP 59
16976: PUSH
16977: LD_VAR 0 1
16981: ARRAY
16982: PUSH
16983: EMPTY
16984: EQUAL
16985: OR
16986: IFFALSE 17023
// begin for i in defenders do
16988: LD_ADDR_VAR 0 5
16992: PUSH
16993: LD_VAR 0 2
16997: PUSH
16998: FOR_IN
16999: IFFALSE 17012
// ComStop ( i ) ;
17001: LD_VAR 0 5
17005: PPUSH
17006: CALL_OW 141
17010: GO 16998
17012: POP
17013: POP
// defenders := [ ] ;
17014: LD_ADDR_VAR 0 2
17018: PUSH
17019: EMPTY
17020: ST_TO_ADDR
// exit ;
17021: GO 18352
// end ; for i in defenders do
17023: LD_ADDR_VAR 0 5
17027: PUSH
17028: LD_VAR 0 2
17032: PUSH
17033: FOR_IN
17034: IFFALSE 17852
// begin e := NearestUnitToUnit ( enemy , i ) ;
17036: LD_ADDR_VAR 0 14
17040: PUSH
17041: LD_VAR 0 3
17045: PPUSH
17046: LD_VAR 0 5
17050: PPUSH
17051: CALL_OW 74
17055: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
17056: LD_ADDR_VAR 0 8
17060: PUSH
17061: LD_EXP 59
17065: PUSH
17066: LD_VAR 0 1
17070: ARRAY
17071: PPUSH
17072: LD_INT 2
17074: PUSH
17075: LD_INT 30
17077: PUSH
17078: LD_INT 0
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: PUSH
17085: LD_INT 30
17087: PUSH
17088: LD_INT 1
17090: PUSH
17091: EMPTY
17092: LIST
17093: LIST
17094: PUSH
17095: EMPTY
17096: LIST
17097: LIST
17098: LIST
17099: PPUSH
17100: CALL_OW 72
17104: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
17105: LD_ADDR_VAR 0 17
17109: PUSH
17110: LD_VAR 0 8
17114: NOT
17115: PUSH
17116: LD_VAR 0 8
17120: PPUSH
17121: LD_INT 3
17123: PUSH
17124: LD_INT 24
17126: PUSH
17127: LD_INT 600
17129: PUSH
17130: EMPTY
17131: LIST
17132: LIST
17133: PUSH
17134: EMPTY
17135: LIST
17136: LIST
17137: PPUSH
17138: CALL_OW 72
17142: OR
17143: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
17144: LD_VAR 0 5
17148: PPUSH
17149: CALL_OW 247
17153: PUSH
17154: LD_INT 2
17156: DOUBLE
17157: EQUAL
17158: IFTRUE 17162
17160: GO 17558
17162: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
17163: LD_VAR 0 5
17167: PPUSH
17168: CALL_OW 256
17172: PUSH
17173: LD_INT 650
17175: GREATER
17176: PUSH
17177: LD_VAR 0 5
17181: PPUSH
17182: LD_VAR 0 14
17186: PPUSH
17187: CALL_OW 296
17191: PUSH
17192: LD_INT 40
17194: LESS
17195: PUSH
17196: LD_VAR 0 14
17200: PPUSH
17201: LD_EXP 84
17205: PUSH
17206: LD_VAR 0 1
17210: ARRAY
17211: PPUSH
17212: CALL_OW 308
17216: OR
17217: AND
17218: IFFALSE 17340
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
17220: LD_VAR 0 5
17224: PPUSH
17225: CALL_OW 262
17229: PUSH
17230: LD_INT 1
17232: EQUAL
17233: PUSH
17234: LD_VAR 0 5
17238: PPUSH
17239: CALL_OW 261
17243: PUSH
17244: LD_INT 30
17246: LESS
17247: AND
17248: PUSH
17249: LD_VAR 0 8
17253: AND
17254: IFFALSE 17324
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
17256: LD_VAR 0 5
17260: PPUSH
17261: LD_VAR 0 8
17265: PPUSH
17266: LD_VAR 0 5
17270: PPUSH
17271: CALL_OW 74
17275: PPUSH
17276: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
17280: LD_VAR 0 5
17284: PPUSH
17285: LD_VAR 0 8
17289: PPUSH
17290: LD_VAR 0 5
17294: PPUSH
17295: CALL_OW 74
17299: PPUSH
17300: CALL_OW 296
17304: PUSH
17305: LD_INT 6
17307: LESS
17308: IFFALSE 17322
// SetFuel ( i , 100 ) ;
17310: LD_VAR 0 5
17314: PPUSH
17315: LD_INT 100
17317: PPUSH
17318: CALL_OW 240
// end else
17322: GO 17338
// ComAttackUnit ( i , e ) ;
17324: LD_VAR 0 5
17328: PPUSH
17329: LD_VAR 0 14
17333: PPUSH
17334: CALL_OW 115
// end else
17338: GO 17441
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
17340: LD_VAR 0 14
17344: PPUSH
17345: LD_EXP 84
17349: PUSH
17350: LD_VAR 0 1
17354: ARRAY
17355: PPUSH
17356: CALL_OW 308
17360: NOT
17361: PUSH
17362: LD_VAR 0 5
17366: PPUSH
17367: LD_VAR 0 14
17371: PPUSH
17372: CALL_OW 296
17376: PUSH
17377: LD_INT 40
17379: GREATEREQUAL
17380: AND
17381: PUSH
17382: LD_VAR 0 5
17386: PPUSH
17387: CALL_OW 256
17391: PUSH
17392: LD_INT 650
17394: LESSEQUAL
17395: OR
17396: PUSH
17397: LD_VAR 0 5
17401: PPUSH
17402: LD_EXP 83
17406: PUSH
17407: LD_VAR 0 1
17411: ARRAY
17412: PPUSH
17413: CALL_OW 308
17417: NOT
17418: AND
17419: IFFALSE 17441
// ComMoveToArea ( i , mc_parking [ base ] ) ;
17421: LD_VAR 0 5
17425: PPUSH
17426: LD_EXP 83
17430: PUSH
17431: LD_VAR 0 1
17435: ARRAY
17436: PPUSH
17437: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
17441: LD_VAR 0 5
17445: PPUSH
17446: CALL_OW 256
17450: PUSH
17451: LD_INT 998
17453: LESS
17454: PUSH
17455: LD_VAR 0 5
17459: PPUSH
17460: CALL_OW 263
17464: PUSH
17465: LD_INT 1
17467: EQUAL
17468: AND
17469: PUSH
17470: LD_VAR 0 5
17474: PPUSH
17475: CALL_OW 311
17479: AND
17480: PUSH
17481: LD_VAR 0 5
17485: PPUSH
17486: LD_EXP 83
17490: PUSH
17491: LD_VAR 0 1
17495: ARRAY
17496: PPUSH
17497: CALL_OW 308
17501: AND
17502: IFFALSE 17556
// begin mech := IsDrivenBy ( i ) ;
17504: LD_ADDR_VAR 0 10
17508: PUSH
17509: LD_VAR 0 5
17513: PPUSH
17514: CALL_OW 311
17518: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
17519: LD_VAR 0 10
17523: PPUSH
17524: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
17528: LD_VAR 0 10
17532: PPUSH
17533: LD_VAR 0 5
17537: PPUSH
17538: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
17542: LD_VAR 0 10
17546: PPUSH
17547: LD_VAR 0 5
17551: PPUSH
17552: CALL_OW 180
// end ; end ; unit_human :
17556: GO 17823
17558: LD_INT 1
17560: DOUBLE
17561: EQUAL
17562: IFTRUE 17566
17564: GO 17822
17566: POP
// begin b := IsInUnit ( i ) ;
17567: LD_ADDR_VAR 0 19
17571: PUSH
17572: LD_VAR 0 5
17576: PPUSH
17577: CALL_OW 310
17581: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
17582: LD_ADDR_VAR 0 20
17586: PUSH
17587: LD_VAR 0 19
17591: NOT
17592: PUSH
17593: LD_VAR 0 19
17597: PPUSH
17598: CALL_OW 266
17602: PUSH
17603: LD_INT 32
17605: PUSH
17606: LD_INT 31
17608: PUSH
17609: EMPTY
17610: LIST
17611: LIST
17612: IN
17613: OR
17614: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
17615: LD_VAR 0 17
17619: PUSH
17620: LD_VAR 0 2
17624: PPUSH
17625: LD_INT 21
17627: PUSH
17628: LD_INT 2
17630: PUSH
17631: EMPTY
17632: LIST
17633: LIST
17634: PPUSH
17635: CALL_OW 72
17639: PUSH
17640: LD_INT 1
17642: LESSEQUAL
17643: OR
17644: PUSH
17645: LD_VAR 0 20
17649: AND
17650: PUSH
17651: LD_VAR 0 5
17655: PUSH
17656: LD_VAR 0 18
17660: IN
17661: NOT
17662: AND
17663: IFFALSE 17756
// begin if b then
17665: LD_VAR 0 19
17669: IFFALSE 17718
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
17671: LD_VAR 0 19
17675: PPUSH
17676: LD_VAR 0 3
17680: PPUSH
17681: LD_VAR 0 19
17685: PPUSH
17686: CALL_OW 74
17690: PPUSH
17691: CALL_OW 296
17695: PUSH
17696: LD_INT 10
17698: LESS
17699: PUSH
17700: LD_VAR 0 19
17704: PPUSH
17705: CALL_OW 461
17709: PUSH
17710: LD_INT 7
17712: NONEQUAL
17713: AND
17714: IFFALSE 17718
// continue ;
17716: GO 17033
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17718: LD_ADDR_VAR 0 18
17722: PUSH
17723: LD_VAR 0 18
17727: PPUSH
17728: LD_VAR 0 18
17732: PUSH
17733: LD_INT 1
17735: PLUS
17736: PPUSH
17737: LD_VAR 0 5
17741: PPUSH
17742: CALL_OW 1
17746: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17747: LD_VAR 0 5
17751: PPUSH
17752: CALL_OW 122
// end ; if sold_defenders then
17756: LD_VAR 0 18
17760: IFFALSE 17820
// if i in sold_defenders then
17762: LD_VAR 0 5
17766: PUSH
17767: LD_VAR 0 18
17771: IN
17772: IFFALSE 17820
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17774: LD_VAR 0 5
17778: PPUSH
17779: CALL_OW 314
17783: NOT
17784: PUSH
17785: LD_VAR 0 5
17789: PPUSH
17790: LD_VAR 0 14
17794: PPUSH
17795: CALL_OW 296
17799: PUSH
17800: LD_INT 30
17802: LESS
17803: AND
17804: IFFALSE 17820
// ComAttackUnit ( i , e ) ;
17806: LD_VAR 0 5
17810: PPUSH
17811: LD_VAR 0 14
17815: PPUSH
17816: CALL_OW 115
// end ; end ; end ;
17820: GO 17823
17822: POP
// if IsDead ( i ) then
17823: LD_VAR 0 5
17827: PPUSH
17828: CALL_OW 301
17832: IFFALSE 17850
// defenders := defenders diff i ;
17834: LD_ADDR_VAR 0 2
17838: PUSH
17839: LD_VAR 0 2
17843: PUSH
17844: LD_VAR 0 5
17848: DIFF
17849: ST_TO_ADDR
// end ;
17850: GO 17033
17852: POP
17853: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
17854: LD_VAR 0 3
17858: NOT
17859: PUSH
17860: LD_VAR 0 2
17864: NOT
17865: OR
17866: PUSH
17867: LD_EXP 59
17871: PUSH
17872: LD_VAR 0 1
17876: ARRAY
17877: NOT
17878: OR
17879: IFFALSE 16937
// MC_Reset ( base , 18 ) ;
17881: LD_VAR 0 1
17885: PPUSH
17886: LD_INT 18
17888: PPUSH
17889: CALL 61527 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17893: LD_ADDR_VAR 0 2
17897: PUSH
17898: LD_VAR 0 2
17902: PUSH
17903: LD_VAR 0 2
17907: PPUSH
17908: LD_INT 2
17910: PUSH
17911: LD_INT 25
17913: PUSH
17914: LD_INT 1
17916: PUSH
17917: EMPTY
17918: LIST
17919: LIST
17920: PUSH
17921: LD_INT 25
17923: PUSH
17924: LD_INT 5
17926: PUSH
17927: EMPTY
17928: LIST
17929: LIST
17930: PUSH
17931: LD_INT 25
17933: PUSH
17934: LD_INT 8
17936: PUSH
17937: EMPTY
17938: LIST
17939: LIST
17940: PUSH
17941: LD_INT 25
17943: PUSH
17944: LD_INT 9
17946: PUSH
17947: EMPTY
17948: LIST
17949: LIST
17950: PUSH
17951: EMPTY
17952: LIST
17953: LIST
17954: LIST
17955: LIST
17956: LIST
17957: PPUSH
17958: CALL_OW 72
17962: DIFF
17963: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17964: LD_VAR 0 3
17968: NOT
17969: PUSH
17970: LD_VAR 0 2
17974: PPUSH
17975: LD_INT 21
17977: PUSH
17978: LD_INT 2
17980: PUSH
17981: EMPTY
17982: LIST
17983: LIST
17984: PPUSH
17985: CALL_OW 72
17989: AND
17990: IFFALSE 18328
// begin tmp := FilterByTag ( defenders , 19 ) ;
17992: LD_ADDR_VAR 0 12
17996: PUSH
17997: LD_VAR 0 2
18001: PPUSH
18002: LD_INT 19
18004: PPUSH
18005: CALL 54784 0 2
18009: ST_TO_ADDR
// if tmp then
18010: LD_VAR 0 12
18014: IFFALSE 18084
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
18016: LD_ADDR_VAR 0 12
18020: PUSH
18021: LD_VAR 0 12
18025: PPUSH
18026: LD_INT 25
18028: PUSH
18029: LD_INT 3
18031: PUSH
18032: EMPTY
18033: LIST
18034: LIST
18035: PPUSH
18036: CALL_OW 72
18040: ST_TO_ADDR
// if tmp then
18041: LD_VAR 0 12
18045: IFFALSE 18084
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
18047: LD_ADDR_EXP 71
18051: PUSH
18052: LD_EXP 71
18056: PPUSH
18057: LD_VAR 0 1
18061: PPUSH
18062: LD_EXP 71
18066: PUSH
18067: LD_VAR 0 1
18071: ARRAY
18072: PUSH
18073: LD_VAR 0 12
18077: UNION
18078: PPUSH
18079: CALL_OW 1
18083: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
18084: LD_VAR 0 1
18088: PPUSH
18089: LD_INT 19
18091: PPUSH
18092: CALL 61527 0 2
// repeat wait ( 0 0$1 ) ;
18096: LD_INT 35
18098: PPUSH
18099: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
18103: LD_EXP 59
18107: PUSH
18108: LD_VAR 0 1
18112: ARRAY
18113: NOT
18114: PUSH
18115: LD_EXP 59
18119: PUSH
18120: LD_VAR 0 1
18124: ARRAY
18125: PUSH
18126: EMPTY
18127: EQUAL
18128: OR
18129: IFFALSE 18166
// begin for i in defenders do
18131: LD_ADDR_VAR 0 5
18135: PUSH
18136: LD_VAR 0 2
18140: PUSH
18141: FOR_IN
18142: IFFALSE 18155
// ComStop ( i ) ;
18144: LD_VAR 0 5
18148: PPUSH
18149: CALL_OW 141
18153: GO 18141
18155: POP
18156: POP
// defenders := [ ] ;
18157: LD_ADDR_VAR 0 2
18161: PUSH
18162: EMPTY
18163: ST_TO_ADDR
// exit ;
18164: GO 18352
// end ; for i in defenders do
18166: LD_ADDR_VAR 0 5
18170: PUSH
18171: LD_VAR 0 2
18175: PUSH
18176: FOR_IN
18177: IFFALSE 18266
// begin if not IsInArea ( i , mc_parking [ base ] ) then
18179: LD_VAR 0 5
18183: PPUSH
18184: LD_EXP 83
18188: PUSH
18189: LD_VAR 0 1
18193: ARRAY
18194: PPUSH
18195: CALL_OW 308
18199: NOT
18200: IFFALSE 18224
// ComMoveToArea ( i , mc_parking [ base ] ) else
18202: LD_VAR 0 5
18206: PPUSH
18207: LD_EXP 83
18211: PUSH
18212: LD_VAR 0 1
18216: ARRAY
18217: PPUSH
18218: CALL_OW 113
18222: GO 18264
// if GetControl ( i ) = control_manual then
18224: LD_VAR 0 5
18228: PPUSH
18229: CALL_OW 263
18233: PUSH
18234: LD_INT 1
18236: EQUAL
18237: IFFALSE 18264
// if IsDrivenBy ( i ) then
18239: LD_VAR 0 5
18243: PPUSH
18244: CALL_OW 311
18248: IFFALSE 18264
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
18250: LD_VAR 0 5
18254: PPUSH
18255: CALL_OW 311
18259: PPUSH
18260: CALL_OW 121
// end ;
18264: GO 18176
18266: POP
18267: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
18268: LD_VAR 0 2
18272: PPUSH
18273: LD_INT 95
18275: PUSH
18276: LD_EXP 83
18280: PUSH
18281: LD_VAR 0 1
18285: ARRAY
18286: PUSH
18287: EMPTY
18288: LIST
18289: LIST
18290: PPUSH
18291: CALL_OW 72
18295: PUSH
18296: LD_VAR 0 2
18300: EQUAL
18301: PUSH
18302: LD_EXP 82
18306: PUSH
18307: LD_VAR 0 1
18311: ARRAY
18312: OR
18313: PUSH
18314: LD_EXP 59
18318: PUSH
18319: LD_VAR 0 1
18323: ARRAY
18324: NOT
18325: OR
18326: IFFALSE 18096
// end ; MC_Reset ( base , 19 ) ;
18328: LD_VAR 0 1
18332: PPUSH
18333: LD_INT 19
18335: PPUSH
18336: CALL 61527 0 2
// MC_Reset ( base , 20 ) ;
18340: LD_VAR 0 1
18344: PPUSH
18345: LD_INT 20
18347: PPUSH
18348: CALL 61527 0 2
// end ;
18352: LD_VAR 0 4
18356: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
18357: LD_INT 0
18359: PPUSH
18360: PPUSH
18361: PPUSH
18362: PPUSH
// result := false ;
18363: LD_ADDR_VAR 0 2
18367: PUSH
18368: LD_INT 0
18370: ST_TO_ADDR
// side := GetSide ( unit ) ;
18371: LD_ADDR_VAR 0 3
18375: PUSH
18376: LD_VAR 0 1
18380: PPUSH
18381: CALL_OW 255
18385: ST_TO_ADDR
// nat := GetNation ( unit ) ;
18386: LD_ADDR_VAR 0 4
18390: PUSH
18391: LD_VAR 0 1
18395: PPUSH
18396: CALL_OW 248
18400: ST_TO_ADDR
// case nat of 1 :
18401: LD_VAR 0 4
18405: PUSH
18406: LD_INT 1
18408: DOUBLE
18409: EQUAL
18410: IFTRUE 18414
18412: GO 18425
18414: POP
// tech := tech_lassight ; 2 :
18415: LD_ADDR_VAR 0 5
18419: PUSH
18420: LD_INT 12
18422: ST_TO_ADDR
18423: GO 18464
18425: LD_INT 2
18427: DOUBLE
18428: EQUAL
18429: IFTRUE 18433
18431: GO 18444
18433: POP
// tech := tech_mortar ; 3 :
18434: LD_ADDR_VAR 0 5
18438: PUSH
18439: LD_INT 41
18441: ST_TO_ADDR
18442: GO 18464
18444: LD_INT 3
18446: DOUBLE
18447: EQUAL
18448: IFTRUE 18452
18450: GO 18463
18452: POP
// tech := tech_bazooka ; end ;
18453: LD_ADDR_VAR 0 5
18457: PUSH
18458: LD_INT 44
18460: ST_TO_ADDR
18461: GO 18464
18463: POP
// if Researched ( side , tech ) then
18464: LD_VAR 0 3
18468: PPUSH
18469: LD_VAR 0 5
18473: PPUSH
18474: CALL_OW 325
18478: IFFALSE 18505
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18480: LD_ADDR_VAR 0 2
18484: PUSH
18485: LD_INT 5
18487: PUSH
18488: LD_INT 8
18490: PUSH
18491: LD_INT 9
18493: PUSH
18494: EMPTY
18495: LIST
18496: LIST
18497: LIST
18498: PUSH
18499: LD_VAR 0 4
18503: ARRAY
18504: ST_TO_ADDR
// end ;
18505: LD_VAR 0 2
18509: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18510: LD_INT 0
18512: PPUSH
18513: PPUSH
18514: PPUSH
// if not mines then
18515: LD_VAR 0 2
18519: NOT
18520: IFFALSE 18524
// exit ;
18522: GO 18668
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18524: LD_ADDR_VAR 0 5
18528: PUSH
18529: LD_INT 81
18531: PUSH
18532: LD_VAR 0 1
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: PUSH
18541: LD_INT 3
18543: PUSH
18544: LD_INT 21
18546: PUSH
18547: LD_INT 3
18549: PUSH
18550: EMPTY
18551: LIST
18552: LIST
18553: PUSH
18554: EMPTY
18555: LIST
18556: LIST
18557: PUSH
18558: EMPTY
18559: LIST
18560: LIST
18561: PPUSH
18562: CALL_OW 69
18566: ST_TO_ADDR
// for i in mines do
18567: LD_ADDR_VAR 0 4
18571: PUSH
18572: LD_VAR 0 2
18576: PUSH
18577: FOR_IN
18578: IFFALSE 18666
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18580: LD_VAR 0 4
18584: PUSH
18585: LD_INT 1
18587: ARRAY
18588: PPUSH
18589: LD_VAR 0 4
18593: PUSH
18594: LD_INT 2
18596: ARRAY
18597: PPUSH
18598: CALL_OW 458
18602: NOT
18603: IFFALSE 18607
// continue ;
18605: GO 18577
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18607: LD_VAR 0 4
18611: PUSH
18612: LD_INT 1
18614: ARRAY
18615: PPUSH
18616: LD_VAR 0 4
18620: PUSH
18621: LD_INT 2
18623: ARRAY
18624: PPUSH
18625: CALL_OW 428
18629: PUSH
18630: LD_VAR 0 5
18634: IN
18635: IFFALSE 18664
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18637: LD_VAR 0 4
18641: PUSH
18642: LD_INT 1
18644: ARRAY
18645: PPUSH
18646: LD_VAR 0 4
18650: PUSH
18651: LD_INT 2
18653: ARRAY
18654: PPUSH
18655: LD_VAR 0 1
18659: PPUSH
18660: CALL_OW 456
// end ;
18664: GO 18577
18666: POP
18667: POP
// end ;
18668: LD_VAR 0 3
18672: RET
// export function Count ( array ) ; var i ; begin
18673: LD_INT 0
18675: PPUSH
18676: PPUSH
// result := 0 ;
18677: LD_ADDR_VAR 0 2
18681: PUSH
18682: LD_INT 0
18684: ST_TO_ADDR
// for i in array do
18685: LD_ADDR_VAR 0 3
18689: PUSH
18690: LD_VAR 0 1
18694: PUSH
18695: FOR_IN
18696: IFFALSE 18720
// if i then
18698: LD_VAR 0 3
18702: IFFALSE 18718
// result := result + 1 ;
18704: LD_ADDR_VAR 0 2
18708: PUSH
18709: LD_VAR 0 2
18713: PUSH
18714: LD_INT 1
18716: PLUS
18717: ST_TO_ADDR
18718: GO 18695
18720: POP
18721: POP
// end ;
18722: LD_VAR 0 2
18726: RET
// export function IsEmpty ( building ) ; begin
18727: LD_INT 0
18729: PPUSH
// if not building then
18730: LD_VAR 0 1
18734: NOT
18735: IFFALSE 18739
// exit ;
18737: GO 18782
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18739: LD_ADDR_VAR 0 2
18743: PUSH
18744: LD_VAR 0 1
18748: PUSH
18749: LD_INT 22
18751: PUSH
18752: LD_VAR 0 1
18756: PPUSH
18757: CALL_OW 255
18761: PUSH
18762: EMPTY
18763: LIST
18764: LIST
18765: PUSH
18766: LD_INT 58
18768: PUSH
18769: EMPTY
18770: LIST
18771: PUSH
18772: EMPTY
18773: LIST
18774: LIST
18775: PPUSH
18776: CALL_OW 69
18780: IN
18781: ST_TO_ADDR
// end ;
18782: LD_VAR 0 2
18786: RET
// export function IsNotFull ( building ) ; begin
18787: LD_INT 0
18789: PPUSH
// if not building then
18790: LD_VAR 0 1
18794: NOT
18795: IFFALSE 18799
// exit ;
18797: GO 18818
// result := UnitsInside ( building ) < 6 ;
18799: LD_ADDR_VAR 0 2
18803: PUSH
18804: LD_VAR 0 1
18808: PPUSH
18809: CALL_OW 313
18813: PUSH
18814: LD_INT 6
18816: LESS
18817: ST_TO_ADDR
// end ;
18818: LD_VAR 0 2
18822: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18823: LD_INT 0
18825: PPUSH
18826: PPUSH
18827: PPUSH
18828: PPUSH
// tmp := [ ] ;
18829: LD_ADDR_VAR 0 3
18833: PUSH
18834: EMPTY
18835: ST_TO_ADDR
// list := [ ] ;
18836: LD_ADDR_VAR 0 5
18840: PUSH
18841: EMPTY
18842: ST_TO_ADDR
// for i = 16 to 25 do
18843: LD_ADDR_VAR 0 4
18847: PUSH
18848: DOUBLE
18849: LD_INT 16
18851: DEC
18852: ST_TO_ADDR
18853: LD_INT 25
18855: PUSH
18856: FOR_TO
18857: IFFALSE 18930
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18859: LD_ADDR_VAR 0 3
18863: PUSH
18864: LD_VAR 0 3
18868: PUSH
18869: LD_INT 22
18871: PUSH
18872: LD_VAR 0 1
18876: PPUSH
18877: CALL_OW 255
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: PUSH
18886: LD_INT 91
18888: PUSH
18889: LD_VAR 0 1
18893: PUSH
18894: LD_INT 6
18896: PUSH
18897: EMPTY
18898: LIST
18899: LIST
18900: LIST
18901: PUSH
18902: LD_INT 30
18904: PUSH
18905: LD_VAR 0 4
18909: PUSH
18910: EMPTY
18911: LIST
18912: LIST
18913: PUSH
18914: EMPTY
18915: LIST
18916: LIST
18917: LIST
18918: PUSH
18919: EMPTY
18920: LIST
18921: PPUSH
18922: CALL_OW 69
18926: ADD
18927: ST_TO_ADDR
18928: GO 18856
18930: POP
18931: POP
// for i = 1 to tmp do
18932: LD_ADDR_VAR 0 4
18936: PUSH
18937: DOUBLE
18938: LD_INT 1
18940: DEC
18941: ST_TO_ADDR
18942: LD_VAR 0 3
18946: PUSH
18947: FOR_TO
18948: IFFALSE 19036
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18950: LD_ADDR_VAR 0 5
18954: PUSH
18955: LD_VAR 0 5
18959: PUSH
18960: LD_VAR 0 3
18964: PUSH
18965: LD_VAR 0 4
18969: ARRAY
18970: PPUSH
18971: CALL_OW 266
18975: PUSH
18976: LD_VAR 0 3
18980: PUSH
18981: LD_VAR 0 4
18985: ARRAY
18986: PPUSH
18987: CALL_OW 250
18991: PUSH
18992: LD_VAR 0 3
18996: PUSH
18997: LD_VAR 0 4
19001: ARRAY
19002: PPUSH
19003: CALL_OW 251
19007: PUSH
19008: LD_VAR 0 3
19012: PUSH
19013: LD_VAR 0 4
19017: ARRAY
19018: PPUSH
19019: CALL_OW 254
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: LIST
19028: LIST
19029: PUSH
19030: EMPTY
19031: LIST
19032: ADD
19033: ST_TO_ADDR
19034: GO 18947
19036: POP
19037: POP
// result := list ;
19038: LD_ADDR_VAR 0 2
19042: PUSH
19043: LD_VAR 0 5
19047: ST_TO_ADDR
// end ;
19048: LD_VAR 0 2
19052: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
19053: LD_INT 0
19055: PPUSH
19056: PPUSH
19057: PPUSH
19058: PPUSH
19059: PPUSH
19060: PPUSH
19061: PPUSH
// if not factory then
19062: LD_VAR 0 1
19066: NOT
19067: IFFALSE 19071
// exit ;
19069: GO 19664
// if control = control_apeman then
19071: LD_VAR 0 4
19075: PUSH
19076: LD_INT 5
19078: EQUAL
19079: IFFALSE 19188
// begin tmp := UnitsInside ( factory ) ;
19081: LD_ADDR_VAR 0 8
19085: PUSH
19086: LD_VAR 0 1
19090: PPUSH
19091: CALL_OW 313
19095: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
19096: LD_VAR 0 8
19100: PPUSH
19101: LD_INT 25
19103: PUSH
19104: LD_INT 12
19106: PUSH
19107: EMPTY
19108: LIST
19109: LIST
19110: PPUSH
19111: CALL_OW 72
19115: NOT
19116: IFFALSE 19126
// control := control_manual ;
19118: LD_ADDR_VAR 0 4
19122: PUSH
19123: LD_INT 1
19125: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
19126: LD_ADDR_VAR 0 8
19130: PUSH
19131: LD_VAR 0 1
19135: PPUSH
19136: CALL 18823 0 1
19140: ST_TO_ADDR
// if tmp then
19141: LD_VAR 0 8
19145: IFFALSE 19188
// begin for i in tmp do
19147: LD_ADDR_VAR 0 7
19151: PUSH
19152: LD_VAR 0 8
19156: PUSH
19157: FOR_IN
19158: IFFALSE 19186
// if i [ 1 ] = b_ext_radio then
19160: LD_VAR 0 7
19164: PUSH
19165: LD_INT 1
19167: ARRAY
19168: PUSH
19169: LD_INT 22
19171: EQUAL
19172: IFFALSE 19184
// begin control := control_remote ;
19174: LD_ADDR_VAR 0 4
19178: PUSH
19179: LD_INT 2
19181: ST_TO_ADDR
// break ;
19182: GO 19186
// end ;
19184: GO 19157
19186: POP
19187: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19188: LD_VAR 0 1
19192: PPUSH
19193: LD_VAR 0 2
19197: PPUSH
19198: LD_VAR 0 3
19202: PPUSH
19203: LD_VAR 0 4
19207: PPUSH
19208: LD_VAR 0 5
19212: PPUSH
19213: CALL_OW 448
19217: IFFALSE 19252
// begin result := [ chassis , engine , control , weapon ] ;
19219: LD_ADDR_VAR 0 6
19223: PUSH
19224: LD_VAR 0 2
19228: PUSH
19229: LD_VAR 0 3
19233: PUSH
19234: LD_VAR 0 4
19238: PUSH
19239: LD_VAR 0 5
19243: PUSH
19244: EMPTY
19245: LIST
19246: LIST
19247: LIST
19248: LIST
19249: ST_TO_ADDR
// exit ;
19250: GO 19664
// end ; _chassis := AvailableChassisList ( factory ) ;
19252: LD_ADDR_VAR 0 9
19256: PUSH
19257: LD_VAR 0 1
19261: PPUSH
19262: CALL_OW 475
19266: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
19267: LD_ADDR_VAR 0 11
19271: PUSH
19272: LD_VAR 0 1
19276: PPUSH
19277: CALL_OW 476
19281: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
19282: LD_ADDR_VAR 0 12
19286: PUSH
19287: LD_VAR 0 1
19291: PPUSH
19292: CALL_OW 477
19296: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
19297: LD_ADDR_VAR 0 10
19301: PUSH
19302: LD_VAR 0 1
19306: PPUSH
19307: CALL_OW 478
19311: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
19312: LD_VAR 0 9
19316: NOT
19317: PUSH
19318: LD_VAR 0 11
19322: NOT
19323: OR
19324: PUSH
19325: LD_VAR 0 12
19329: NOT
19330: OR
19331: PUSH
19332: LD_VAR 0 10
19336: NOT
19337: OR
19338: IFFALSE 19373
// begin result := [ chassis , engine , control , weapon ] ;
19340: LD_ADDR_VAR 0 6
19344: PUSH
19345: LD_VAR 0 2
19349: PUSH
19350: LD_VAR 0 3
19354: PUSH
19355: LD_VAR 0 4
19359: PUSH
19360: LD_VAR 0 5
19364: PUSH
19365: EMPTY
19366: LIST
19367: LIST
19368: LIST
19369: LIST
19370: ST_TO_ADDR
// exit ;
19371: GO 19664
// end ; if not chassis in _chassis then
19373: LD_VAR 0 2
19377: PUSH
19378: LD_VAR 0 9
19382: IN
19383: NOT
19384: IFFALSE 19410
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
19386: LD_ADDR_VAR 0 2
19390: PUSH
19391: LD_VAR 0 9
19395: PUSH
19396: LD_INT 1
19398: PPUSH
19399: LD_VAR 0 9
19403: PPUSH
19404: CALL_OW 12
19408: ARRAY
19409: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
19410: LD_VAR 0 2
19414: PPUSH
19415: LD_VAR 0 3
19419: PPUSH
19420: CALL 19669 0 2
19424: NOT
19425: IFFALSE 19484
// repeat engine := _engine [ 1 ] ;
19427: LD_ADDR_VAR 0 3
19431: PUSH
19432: LD_VAR 0 11
19436: PUSH
19437: LD_INT 1
19439: ARRAY
19440: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
19441: LD_ADDR_VAR 0 11
19445: PUSH
19446: LD_VAR 0 11
19450: PPUSH
19451: LD_INT 1
19453: PPUSH
19454: CALL_OW 3
19458: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
19459: LD_VAR 0 2
19463: PPUSH
19464: LD_VAR 0 3
19468: PPUSH
19469: CALL 19669 0 2
19473: PUSH
19474: LD_VAR 0 11
19478: PUSH
19479: EMPTY
19480: EQUAL
19481: OR
19482: IFFALSE 19427
// if not control in _control then
19484: LD_VAR 0 4
19488: PUSH
19489: LD_VAR 0 12
19493: IN
19494: NOT
19495: IFFALSE 19521
// control := _control [ rand ( 1 , _control ) ] ;
19497: LD_ADDR_VAR 0 4
19501: PUSH
19502: LD_VAR 0 12
19506: PUSH
19507: LD_INT 1
19509: PPUSH
19510: LD_VAR 0 12
19514: PPUSH
19515: CALL_OW 12
19519: ARRAY
19520: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19521: LD_VAR 0 2
19525: PPUSH
19526: LD_VAR 0 5
19530: PPUSH
19531: CALL 19889 0 2
19535: NOT
19536: IFFALSE 19595
// repeat weapon := _weapon [ 1 ] ;
19538: LD_ADDR_VAR 0 5
19542: PUSH
19543: LD_VAR 0 10
19547: PUSH
19548: LD_INT 1
19550: ARRAY
19551: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19552: LD_ADDR_VAR 0 10
19556: PUSH
19557: LD_VAR 0 10
19561: PPUSH
19562: LD_INT 1
19564: PPUSH
19565: CALL_OW 3
19569: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19570: LD_VAR 0 2
19574: PPUSH
19575: LD_VAR 0 5
19579: PPUSH
19580: CALL 19889 0 2
19584: PUSH
19585: LD_VAR 0 10
19589: PUSH
19590: EMPTY
19591: EQUAL
19592: OR
19593: IFFALSE 19538
// result := [ ] ;
19595: LD_ADDR_VAR 0 6
19599: PUSH
19600: EMPTY
19601: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19602: LD_VAR 0 1
19606: PPUSH
19607: LD_VAR 0 2
19611: PPUSH
19612: LD_VAR 0 3
19616: PPUSH
19617: LD_VAR 0 4
19621: PPUSH
19622: LD_VAR 0 5
19626: PPUSH
19627: CALL_OW 448
19631: IFFALSE 19664
// result := [ chassis , engine , control , weapon ] ;
19633: LD_ADDR_VAR 0 6
19637: PUSH
19638: LD_VAR 0 2
19642: PUSH
19643: LD_VAR 0 3
19647: PUSH
19648: LD_VAR 0 4
19652: PUSH
19653: LD_VAR 0 5
19657: PUSH
19658: EMPTY
19659: LIST
19660: LIST
19661: LIST
19662: LIST
19663: ST_TO_ADDR
// end ;
19664: LD_VAR 0 6
19668: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19669: LD_INT 0
19671: PPUSH
// if not chassis or not engine then
19672: LD_VAR 0 1
19676: NOT
19677: PUSH
19678: LD_VAR 0 2
19682: NOT
19683: OR
19684: IFFALSE 19688
// exit ;
19686: GO 19884
// case engine of engine_solar :
19688: LD_VAR 0 2
19692: PUSH
19693: LD_INT 2
19695: DOUBLE
19696: EQUAL
19697: IFTRUE 19701
19699: GO 19739
19701: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19702: LD_ADDR_VAR 0 3
19706: PUSH
19707: LD_INT 11
19709: PUSH
19710: LD_INT 12
19712: PUSH
19713: LD_INT 13
19715: PUSH
19716: LD_INT 14
19718: PUSH
19719: LD_INT 1
19721: PUSH
19722: LD_INT 2
19724: PUSH
19725: LD_INT 3
19727: PUSH
19728: EMPTY
19729: LIST
19730: LIST
19731: LIST
19732: LIST
19733: LIST
19734: LIST
19735: LIST
19736: ST_TO_ADDR
19737: GO 19868
19739: LD_INT 1
19741: DOUBLE
19742: EQUAL
19743: IFTRUE 19747
19745: GO 19809
19747: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19748: LD_ADDR_VAR 0 3
19752: PUSH
19753: LD_INT 11
19755: PUSH
19756: LD_INT 12
19758: PUSH
19759: LD_INT 13
19761: PUSH
19762: LD_INT 14
19764: PUSH
19765: LD_INT 1
19767: PUSH
19768: LD_INT 2
19770: PUSH
19771: LD_INT 3
19773: PUSH
19774: LD_INT 4
19776: PUSH
19777: LD_INT 5
19779: PUSH
19780: LD_INT 21
19782: PUSH
19783: LD_INT 23
19785: PUSH
19786: LD_INT 22
19788: PUSH
19789: LD_INT 24
19791: PUSH
19792: EMPTY
19793: LIST
19794: LIST
19795: LIST
19796: LIST
19797: LIST
19798: LIST
19799: LIST
19800: LIST
19801: LIST
19802: LIST
19803: LIST
19804: LIST
19805: LIST
19806: ST_TO_ADDR
19807: GO 19868
19809: LD_INT 3
19811: DOUBLE
19812: EQUAL
19813: IFTRUE 19817
19815: GO 19867
19817: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19818: LD_ADDR_VAR 0 3
19822: PUSH
19823: LD_INT 13
19825: PUSH
19826: LD_INT 14
19828: PUSH
19829: LD_INT 2
19831: PUSH
19832: LD_INT 3
19834: PUSH
19835: LD_INT 4
19837: PUSH
19838: LD_INT 5
19840: PUSH
19841: LD_INT 21
19843: PUSH
19844: LD_INT 22
19846: PUSH
19847: LD_INT 23
19849: PUSH
19850: LD_INT 24
19852: PUSH
19853: EMPTY
19854: LIST
19855: LIST
19856: LIST
19857: LIST
19858: LIST
19859: LIST
19860: LIST
19861: LIST
19862: LIST
19863: LIST
19864: ST_TO_ADDR
19865: GO 19868
19867: POP
// result := ( chassis in result ) ;
19868: LD_ADDR_VAR 0 3
19872: PUSH
19873: LD_VAR 0 1
19877: PUSH
19878: LD_VAR 0 3
19882: IN
19883: ST_TO_ADDR
// end ;
19884: LD_VAR 0 3
19888: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19889: LD_INT 0
19891: PPUSH
// if not chassis or not weapon then
19892: LD_VAR 0 1
19896: NOT
19897: PUSH
19898: LD_VAR 0 2
19902: NOT
19903: OR
19904: IFFALSE 19908
// exit ;
19906: GO 20934
// case weapon of us_machine_gun :
19908: LD_VAR 0 2
19912: PUSH
19913: LD_INT 2
19915: DOUBLE
19916: EQUAL
19917: IFTRUE 19921
19919: GO 19951
19921: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19922: LD_ADDR_VAR 0 3
19926: PUSH
19927: LD_INT 1
19929: PUSH
19930: LD_INT 2
19932: PUSH
19933: LD_INT 3
19935: PUSH
19936: LD_INT 4
19938: PUSH
19939: LD_INT 5
19941: PUSH
19942: EMPTY
19943: LIST
19944: LIST
19945: LIST
19946: LIST
19947: LIST
19948: ST_TO_ADDR
19949: GO 20918
19951: LD_INT 3
19953: DOUBLE
19954: EQUAL
19955: IFTRUE 19959
19957: GO 19989
19959: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19960: LD_ADDR_VAR 0 3
19964: PUSH
19965: LD_INT 1
19967: PUSH
19968: LD_INT 2
19970: PUSH
19971: LD_INT 3
19973: PUSH
19974: LD_INT 4
19976: PUSH
19977: LD_INT 5
19979: PUSH
19980: EMPTY
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: ST_TO_ADDR
19987: GO 20918
19989: LD_INT 11
19991: DOUBLE
19992: EQUAL
19993: IFTRUE 19997
19995: GO 20027
19997: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19998: LD_ADDR_VAR 0 3
20002: PUSH
20003: LD_INT 1
20005: PUSH
20006: LD_INT 2
20008: PUSH
20009: LD_INT 3
20011: PUSH
20012: LD_INT 4
20014: PUSH
20015: LD_INT 5
20017: PUSH
20018: EMPTY
20019: LIST
20020: LIST
20021: LIST
20022: LIST
20023: LIST
20024: ST_TO_ADDR
20025: GO 20918
20027: LD_INT 4
20029: DOUBLE
20030: EQUAL
20031: IFTRUE 20035
20033: GO 20061
20035: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
20036: LD_ADDR_VAR 0 3
20040: PUSH
20041: LD_INT 2
20043: PUSH
20044: LD_INT 3
20046: PUSH
20047: LD_INT 4
20049: PUSH
20050: LD_INT 5
20052: PUSH
20053: EMPTY
20054: LIST
20055: LIST
20056: LIST
20057: LIST
20058: ST_TO_ADDR
20059: GO 20918
20061: LD_INT 5
20063: DOUBLE
20064: EQUAL
20065: IFTRUE 20069
20067: GO 20095
20069: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
20070: LD_ADDR_VAR 0 3
20074: PUSH
20075: LD_INT 2
20077: PUSH
20078: LD_INT 3
20080: PUSH
20081: LD_INT 4
20083: PUSH
20084: LD_INT 5
20086: PUSH
20087: EMPTY
20088: LIST
20089: LIST
20090: LIST
20091: LIST
20092: ST_TO_ADDR
20093: GO 20918
20095: LD_INT 9
20097: DOUBLE
20098: EQUAL
20099: IFTRUE 20103
20101: GO 20129
20103: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
20104: LD_ADDR_VAR 0 3
20108: PUSH
20109: LD_INT 2
20111: PUSH
20112: LD_INT 3
20114: PUSH
20115: LD_INT 4
20117: PUSH
20118: LD_INT 5
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: LIST
20125: LIST
20126: ST_TO_ADDR
20127: GO 20918
20129: LD_INT 7
20131: DOUBLE
20132: EQUAL
20133: IFTRUE 20137
20135: GO 20163
20137: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
20138: LD_ADDR_VAR 0 3
20142: PUSH
20143: LD_INT 2
20145: PUSH
20146: LD_INT 3
20148: PUSH
20149: LD_INT 4
20151: PUSH
20152: LD_INT 5
20154: PUSH
20155: EMPTY
20156: LIST
20157: LIST
20158: LIST
20159: LIST
20160: ST_TO_ADDR
20161: GO 20918
20163: LD_INT 12
20165: DOUBLE
20166: EQUAL
20167: IFTRUE 20171
20169: GO 20197
20171: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
20172: LD_ADDR_VAR 0 3
20176: PUSH
20177: LD_INT 2
20179: PUSH
20180: LD_INT 3
20182: PUSH
20183: LD_INT 4
20185: PUSH
20186: LD_INT 5
20188: PUSH
20189: EMPTY
20190: LIST
20191: LIST
20192: LIST
20193: LIST
20194: ST_TO_ADDR
20195: GO 20918
20197: LD_INT 13
20199: DOUBLE
20200: EQUAL
20201: IFTRUE 20205
20203: GO 20231
20205: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
20206: LD_ADDR_VAR 0 3
20210: PUSH
20211: LD_INT 2
20213: PUSH
20214: LD_INT 3
20216: PUSH
20217: LD_INT 4
20219: PUSH
20220: LD_INT 5
20222: PUSH
20223: EMPTY
20224: LIST
20225: LIST
20226: LIST
20227: LIST
20228: ST_TO_ADDR
20229: GO 20918
20231: LD_INT 14
20233: DOUBLE
20234: EQUAL
20235: IFTRUE 20239
20237: GO 20257
20239: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
20240: LD_ADDR_VAR 0 3
20244: PUSH
20245: LD_INT 4
20247: PUSH
20248: LD_INT 5
20250: PUSH
20251: EMPTY
20252: LIST
20253: LIST
20254: ST_TO_ADDR
20255: GO 20918
20257: LD_INT 6
20259: DOUBLE
20260: EQUAL
20261: IFTRUE 20265
20263: GO 20283
20265: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
20266: LD_ADDR_VAR 0 3
20270: PUSH
20271: LD_INT 4
20273: PUSH
20274: LD_INT 5
20276: PUSH
20277: EMPTY
20278: LIST
20279: LIST
20280: ST_TO_ADDR
20281: GO 20918
20283: LD_INT 10
20285: DOUBLE
20286: EQUAL
20287: IFTRUE 20291
20289: GO 20309
20291: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
20292: LD_ADDR_VAR 0 3
20296: PUSH
20297: LD_INT 4
20299: PUSH
20300: LD_INT 5
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: ST_TO_ADDR
20307: GO 20918
20309: LD_INT 22
20311: DOUBLE
20312: EQUAL
20313: IFTRUE 20317
20315: GO 20343
20317: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
20318: LD_ADDR_VAR 0 3
20322: PUSH
20323: LD_INT 11
20325: PUSH
20326: LD_INT 12
20328: PUSH
20329: LD_INT 13
20331: PUSH
20332: LD_INT 14
20334: PUSH
20335: EMPTY
20336: LIST
20337: LIST
20338: LIST
20339: LIST
20340: ST_TO_ADDR
20341: GO 20918
20343: LD_INT 23
20345: DOUBLE
20346: EQUAL
20347: IFTRUE 20351
20349: GO 20377
20351: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
20352: LD_ADDR_VAR 0 3
20356: PUSH
20357: LD_INT 11
20359: PUSH
20360: LD_INT 12
20362: PUSH
20363: LD_INT 13
20365: PUSH
20366: LD_INT 14
20368: PUSH
20369: EMPTY
20370: LIST
20371: LIST
20372: LIST
20373: LIST
20374: ST_TO_ADDR
20375: GO 20918
20377: LD_INT 24
20379: DOUBLE
20380: EQUAL
20381: IFTRUE 20385
20383: GO 20411
20385: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
20386: LD_ADDR_VAR 0 3
20390: PUSH
20391: LD_INT 11
20393: PUSH
20394: LD_INT 12
20396: PUSH
20397: LD_INT 13
20399: PUSH
20400: LD_INT 14
20402: PUSH
20403: EMPTY
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: ST_TO_ADDR
20409: GO 20918
20411: LD_INT 30
20413: DOUBLE
20414: EQUAL
20415: IFTRUE 20419
20417: GO 20445
20419: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
20420: LD_ADDR_VAR 0 3
20424: PUSH
20425: LD_INT 11
20427: PUSH
20428: LD_INT 12
20430: PUSH
20431: LD_INT 13
20433: PUSH
20434: LD_INT 14
20436: PUSH
20437: EMPTY
20438: LIST
20439: LIST
20440: LIST
20441: LIST
20442: ST_TO_ADDR
20443: GO 20918
20445: LD_INT 25
20447: DOUBLE
20448: EQUAL
20449: IFTRUE 20453
20451: GO 20471
20453: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
20454: LD_ADDR_VAR 0 3
20458: PUSH
20459: LD_INT 13
20461: PUSH
20462: LD_INT 14
20464: PUSH
20465: EMPTY
20466: LIST
20467: LIST
20468: ST_TO_ADDR
20469: GO 20918
20471: LD_INT 27
20473: DOUBLE
20474: EQUAL
20475: IFTRUE 20479
20477: GO 20497
20479: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20480: LD_ADDR_VAR 0 3
20484: PUSH
20485: LD_INT 13
20487: PUSH
20488: LD_INT 14
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: ST_TO_ADDR
20495: GO 20918
20497: LD_INT 28
20499: DOUBLE
20500: EQUAL
20501: IFTRUE 20505
20503: GO 20523
20505: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20506: LD_ADDR_VAR 0 3
20510: PUSH
20511: LD_INT 13
20513: PUSH
20514: LD_INT 14
20516: PUSH
20517: EMPTY
20518: LIST
20519: LIST
20520: ST_TO_ADDR
20521: GO 20918
20523: LD_INT 29
20525: DOUBLE
20526: EQUAL
20527: IFTRUE 20531
20529: GO 20549
20531: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20532: LD_ADDR_VAR 0 3
20536: PUSH
20537: LD_INT 13
20539: PUSH
20540: LD_INT 14
20542: PUSH
20543: EMPTY
20544: LIST
20545: LIST
20546: ST_TO_ADDR
20547: GO 20918
20549: LD_INT 31
20551: DOUBLE
20552: EQUAL
20553: IFTRUE 20557
20555: GO 20575
20557: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20558: LD_ADDR_VAR 0 3
20562: PUSH
20563: LD_INT 13
20565: PUSH
20566: LD_INT 14
20568: PUSH
20569: EMPTY
20570: LIST
20571: LIST
20572: ST_TO_ADDR
20573: GO 20918
20575: LD_INT 26
20577: DOUBLE
20578: EQUAL
20579: IFTRUE 20583
20581: GO 20601
20583: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20584: LD_ADDR_VAR 0 3
20588: PUSH
20589: LD_INT 13
20591: PUSH
20592: LD_INT 14
20594: PUSH
20595: EMPTY
20596: LIST
20597: LIST
20598: ST_TO_ADDR
20599: GO 20918
20601: LD_INT 42
20603: DOUBLE
20604: EQUAL
20605: IFTRUE 20609
20607: GO 20635
20609: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20610: LD_ADDR_VAR 0 3
20614: PUSH
20615: LD_INT 21
20617: PUSH
20618: LD_INT 22
20620: PUSH
20621: LD_INT 23
20623: PUSH
20624: LD_INT 24
20626: PUSH
20627: EMPTY
20628: LIST
20629: LIST
20630: LIST
20631: LIST
20632: ST_TO_ADDR
20633: GO 20918
20635: LD_INT 43
20637: DOUBLE
20638: EQUAL
20639: IFTRUE 20643
20641: GO 20669
20643: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20644: LD_ADDR_VAR 0 3
20648: PUSH
20649: LD_INT 21
20651: PUSH
20652: LD_INT 22
20654: PUSH
20655: LD_INT 23
20657: PUSH
20658: LD_INT 24
20660: PUSH
20661: EMPTY
20662: LIST
20663: LIST
20664: LIST
20665: LIST
20666: ST_TO_ADDR
20667: GO 20918
20669: LD_INT 44
20671: DOUBLE
20672: EQUAL
20673: IFTRUE 20677
20675: GO 20703
20677: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20678: LD_ADDR_VAR 0 3
20682: PUSH
20683: LD_INT 21
20685: PUSH
20686: LD_INT 22
20688: PUSH
20689: LD_INT 23
20691: PUSH
20692: LD_INT 24
20694: PUSH
20695: EMPTY
20696: LIST
20697: LIST
20698: LIST
20699: LIST
20700: ST_TO_ADDR
20701: GO 20918
20703: LD_INT 45
20705: DOUBLE
20706: EQUAL
20707: IFTRUE 20711
20709: GO 20737
20711: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20712: LD_ADDR_VAR 0 3
20716: PUSH
20717: LD_INT 21
20719: PUSH
20720: LD_INT 22
20722: PUSH
20723: LD_INT 23
20725: PUSH
20726: LD_INT 24
20728: PUSH
20729: EMPTY
20730: LIST
20731: LIST
20732: LIST
20733: LIST
20734: ST_TO_ADDR
20735: GO 20918
20737: LD_INT 49
20739: DOUBLE
20740: EQUAL
20741: IFTRUE 20745
20743: GO 20771
20745: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20746: LD_ADDR_VAR 0 3
20750: PUSH
20751: LD_INT 21
20753: PUSH
20754: LD_INT 22
20756: PUSH
20757: LD_INT 23
20759: PUSH
20760: LD_INT 24
20762: PUSH
20763: EMPTY
20764: LIST
20765: LIST
20766: LIST
20767: LIST
20768: ST_TO_ADDR
20769: GO 20918
20771: LD_INT 51
20773: DOUBLE
20774: EQUAL
20775: IFTRUE 20779
20777: GO 20805
20779: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20780: LD_ADDR_VAR 0 3
20784: PUSH
20785: LD_INT 21
20787: PUSH
20788: LD_INT 22
20790: PUSH
20791: LD_INT 23
20793: PUSH
20794: LD_INT 24
20796: PUSH
20797: EMPTY
20798: LIST
20799: LIST
20800: LIST
20801: LIST
20802: ST_TO_ADDR
20803: GO 20918
20805: LD_INT 52
20807: DOUBLE
20808: EQUAL
20809: IFTRUE 20813
20811: GO 20839
20813: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20814: LD_ADDR_VAR 0 3
20818: PUSH
20819: LD_INT 21
20821: PUSH
20822: LD_INT 22
20824: PUSH
20825: LD_INT 23
20827: PUSH
20828: LD_INT 24
20830: PUSH
20831: EMPTY
20832: LIST
20833: LIST
20834: LIST
20835: LIST
20836: ST_TO_ADDR
20837: GO 20918
20839: LD_INT 53
20841: DOUBLE
20842: EQUAL
20843: IFTRUE 20847
20845: GO 20865
20847: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20848: LD_ADDR_VAR 0 3
20852: PUSH
20853: LD_INT 23
20855: PUSH
20856: LD_INT 24
20858: PUSH
20859: EMPTY
20860: LIST
20861: LIST
20862: ST_TO_ADDR
20863: GO 20918
20865: LD_INT 46
20867: DOUBLE
20868: EQUAL
20869: IFTRUE 20873
20871: GO 20891
20873: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20874: LD_ADDR_VAR 0 3
20878: PUSH
20879: LD_INT 23
20881: PUSH
20882: LD_INT 24
20884: PUSH
20885: EMPTY
20886: LIST
20887: LIST
20888: ST_TO_ADDR
20889: GO 20918
20891: LD_INT 47
20893: DOUBLE
20894: EQUAL
20895: IFTRUE 20899
20897: GO 20917
20899: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20900: LD_ADDR_VAR 0 3
20904: PUSH
20905: LD_INT 23
20907: PUSH
20908: LD_INT 24
20910: PUSH
20911: EMPTY
20912: LIST
20913: LIST
20914: ST_TO_ADDR
20915: GO 20918
20917: POP
// result := ( chassis in result ) ;
20918: LD_ADDR_VAR 0 3
20922: PUSH
20923: LD_VAR 0 1
20927: PUSH
20928: LD_VAR 0 3
20932: IN
20933: ST_TO_ADDR
// end ;
20934: LD_VAR 0 3
20938: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20939: LD_INT 0
20941: PPUSH
20942: PPUSH
20943: PPUSH
20944: PPUSH
20945: PPUSH
20946: PPUSH
20947: PPUSH
// result := array ;
20948: LD_ADDR_VAR 0 5
20952: PUSH
20953: LD_VAR 0 1
20957: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20958: LD_VAR 0 1
20962: NOT
20963: PUSH
20964: LD_VAR 0 2
20968: NOT
20969: OR
20970: PUSH
20971: LD_VAR 0 3
20975: NOT
20976: OR
20977: PUSH
20978: LD_VAR 0 2
20982: PUSH
20983: LD_VAR 0 1
20987: GREATER
20988: OR
20989: PUSH
20990: LD_VAR 0 3
20994: PUSH
20995: LD_VAR 0 1
20999: GREATER
21000: OR
21001: IFFALSE 21005
// exit ;
21003: GO 21301
// if direction then
21005: LD_VAR 0 4
21009: IFFALSE 21073
// begin d := 1 ;
21011: LD_ADDR_VAR 0 9
21015: PUSH
21016: LD_INT 1
21018: ST_TO_ADDR
// if i_from > i_to then
21019: LD_VAR 0 2
21023: PUSH
21024: LD_VAR 0 3
21028: GREATER
21029: IFFALSE 21055
// length := ( array - i_from ) + i_to else
21031: LD_ADDR_VAR 0 11
21035: PUSH
21036: LD_VAR 0 1
21040: PUSH
21041: LD_VAR 0 2
21045: MINUS
21046: PUSH
21047: LD_VAR 0 3
21051: PLUS
21052: ST_TO_ADDR
21053: GO 21071
// length := i_to - i_from ;
21055: LD_ADDR_VAR 0 11
21059: PUSH
21060: LD_VAR 0 3
21064: PUSH
21065: LD_VAR 0 2
21069: MINUS
21070: ST_TO_ADDR
// end else
21071: GO 21134
// begin d := - 1 ;
21073: LD_ADDR_VAR 0 9
21077: PUSH
21078: LD_INT 1
21080: NEG
21081: ST_TO_ADDR
// if i_from > i_to then
21082: LD_VAR 0 2
21086: PUSH
21087: LD_VAR 0 3
21091: GREATER
21092: IFFALSE 21112
// length := i_from - i_to else
21094: LD_ADDR_VAR 0 11
21098: PUSH
21099: LD_VAR 0 2
21103: PUSH
21104: LD_VAR 0 3
21108: MINUS
21109: ST_TO_ADDR
21110: GO 21134
// length := ( array - i_to ) + i_from ;
21112: LD_ADDR_VAR 0 11
21116: PUSH
21117: LD_VAR 0 1
21121: PUSH
21122: LD_VAR 0 3
21126: MINUS
21127: PUSH
21128: LD_VAR 0 2
21132: PLUS
21133: ST_TO_ADDR
// end ; if not length then
21134: LD_VAR 0 11
21138: NOT
21139: IFFALSE 21143
// exit ;
21141: GO 21301
// tmp := array ;
21143: LD_ADDR_VAR 0 10
21147: PUSH
21148: LD_VAR 0 1
21152: ST_TO_ADDR
// for i = 1 to length do
21153: LD_ADDR_VAR 0 6
21157: PUSH
21158: DOUBLE
21159: LD_INT 1
21161: DEC
21162: ST_TO_ADDR
21163: LD_VAR 0 11
21167: PUSH
21168: FOR_TO
21169: IFFALSE 21289
// begin for j = 1 to array do
21171: LD_ADDR_VAR 0 7
21175: PUSH
21176: DOUBLE
21177: LD_INT 1
21179: DEC
21180: ST_TO_ADDR
21181: LD_VAR 0 1
21185: PUSH
21186: FOR_TO
21187: IFFALSE 21275
// begin k := j + d ;
21189: LD_ADDR_VAR 0 8
21193: PUSH
21194: LD_VAR 0 7
21198: PUSH
21199: LD_VAR 0 9
21203: PLUS
21204: ST_TO_ADDR
// if k > array then
21205: LD_VAR 0 8
21209: PUSH
21210: LD_VAR 0 1
21214: GREATER
21215: IFFALSE 21225
// k := 1 ;
21217: LD_ADDR_VAR 0 8
21221: PUSH
21222: LD_INT 1
21224: ST_TO_ADDR
// if not k then
21225: LD_VAR 0 8
21229: NOT
21230: IFFALSE 21242
// k := array ;
21232: LD_ADDR_VAR 0 8
21236: PUSH
21237: LD_VAR 0 1
21241: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
21242: LD_ADDR_VAR 0 10
21246: PUSH
21247: LD_VAR 0 10
21251: PPUSH
21252: LD_VAR 0 8
21256: PPUSH
21257: LD_VAR 0 1
21261: PUSH
21262: LD_VAR 0 7
21266: ARRAY
21267: PPUSH
21268: CALL_OW 1
21272: ST_TO_ADDR
// end ;
21273: GO 21186
21275: POP
21276: POP
// array := tmp ;
21277: LD_ADDR_VAR 0 1
21281: PUSH
21282: LD_VAR 0 10
21286: ST_TO_ADDR
// end ;
21287: GO 21168
21289: POP
21290: POP
// result := array ;
21291: LD_ADDR_VAR 0 5
21295: PUSH
21296: LD_VAR 0 1
21300: ST_TO_ADDR
// end ;
21301: LD_VAR 0 5
21305: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
21306: LD_INT 0
21308: PPUSH
21309: PPUSH
// result := 0 ;
21310: LD_ADDR_VAR 0 3
21314: PUSH
21315: LD_INT 0
21317: ST_TO_ADDR
// if not array or not value in array then
21318: LD_VAR 0 1
21322: NOT
21323: PUSH
21324: LD_VAR 0 2
21328: PUSH
21329: LD_VAR 0 1
21333: IN
21334: NOT
21335: OR
21336: IFFALSE 21340
// exit ;
21338: GO 21394
// for i = 1 to array do
21340: LD_ADDR_VAR 0 4
21344: PUSH
21345: DOUBLE
21346: LD_INT 1
21348: DEC
21349: ST_TO_ADDR
21350: LD_VAR 0 1
21354: PUSH
21355: FOR_TO
21356: IFFALSE 21392
// if value = array [ i ] then
21358: LD_VAR 0 2
21362: PUSH
21363: LD_VAR 0 1
21367: PUSH
21368: LD_VAR 0 4
21372: ARRAY
21373: EQUAL
21374: IFFALSE 21390
// begin result := i ;
21376: LD_ADDR_VAR 0 3
21380: PUSH
21381: LD_VAR 0 4
21385: ST_TO_ADDR
// exit ;
21386: POP
21387: POP
21388: GO 21394
// end ;
21390: GO 21355
21392: POP
21393: POP
// end ;
21394: LD_VAR 0 3
21398: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
21399: LD_INT 0
21401: PPUSH
// vc_chassis := chassis ;
21402: LD_ADDR_OWVAR 37
21406: PUSH
21407: LD_VAR 0 1
21411: ST_TO_ADDR
// vc_engine := engine ;
21412: LD_ADDR_OWVAR 39
21416: PUSH
21417: LD_VAR 0 2
21421: ST_TO_ADDR
// vc_control := control ;
21422: LD_ADDR_OWVAR 38
21426: PUSH
21427: LD_VAR 0 3
21431: ST_TO_ADDR
// vc_weapon := weapon ;
21432: LD_ADDR_OWVAR 40
21436: PUSH
21437: LD_VAR 0 4
21441: ST_TO_ADDR
// vc_fuel_battery := fuel ;
21442: LD_ADDR_OWVAR 41
21446: PUSH
21447: LD_VAR 0 5
21451: ST_TO_ADDR
// end ;
21452: LD_VAR 0 6
21456: RET
// export function WantPlant ( unit ) ; var task ; begin
21457: LD_INT 0
21459: PPUSH
21460: PPUSH
// result := false ;
21461: LD_ADDR_VAR 0 2
21465: PUSH
21466: LD_INT 0
21468: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21469: LD_ADDR_VAR 0 3
21473: PUSH
21474: LD_VAR 0 1
21478: PPUSH
21479: CALL_OW 437
21483: ST_TO_ADDR
// if task then
21484: LD_VAR 0 3
21488: IFFALSE 21516
// if task [ 1 ] [ 1 ] = p then
21490: LD_VAR 0 3
21494: PUSH
21495: LD_INT 1
21497: ARRAY
21498: PUSH
21499: LD_INT 1
21501: ARRAY
21502: PUSH
21503: LD_STRING p
21505: EQUAL
21506: IFFALSE 21516
// result := true ;
21508: LD_ADDR_VAR 0 2
21512: PUSH
21513: LD_INT 1
21515: ST_TO_ADDR
// end ;
21516: LD_VAR 0 2
21520: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21521: LD_INT 0
21523: PPUSH
21524: PPUSH
21525: PPUSH
21526: PPUSH
// if pos < 1 then
21527: LD_VAR 0 2
21531: PUSH
21532: LD_INT 1
21534: LESS
21535: IFFALSE 21539
// exit ;
21537: GO 21842
// if pos = 1 then
21539: LD_VAR 0 2
21543: PUSH
21544: LD_INT 1
21546: EQUAL
21547: IFFALSE 21580
// result := Replace ( arr , pos [ 1 ] , value ) else
21549: LD_ADDR_VAR 0 4
21553: PUSH
21554: LD_VAR 0 1
21558: PPUSH
21559: LD_VAR 0 2
21563: PUSH
21564: LD_INT 1
21566: ARRAY
21567: PPUSH
21568: LD_VAR 0 3
21572: PPUSH
21573: CALL_OW 1
21577: ST_TO_ADDR
21578: GO 21842
// begin tmp := arr ;
21580: LD_ADDR_VAR 0 6
21584: PUSH
21585: LD_VAR 0 1
21589: ST_TO_ADDR
// s_arr := [ tmp ] ;
21590: LD_ADDR_VAR 0 7
21594: PUSH
21595: LD_VAR 0 6
21599: PUSH
21600: EMPTY
21601: LIST
21602: ST_TO_ADDR
// for i = 1 to pos - 1 do
21603: LD_ADDR_VAR 0 5
21607: PUSH
21608: DOUBLE
21609: LD_INT 1
21611: DEC
21612: ST_TO_ADDR
21613: LD_VAR 0 2
21617: PUSH
21618: LD_INT 1
21620: MINUS
21621: PUSH
21622: FOR_TO
21623: IFFALSE 21668
// begin tmp := tmp [ pos [ i ] ] ;
21625: LD_ADDR_VAR 0 6
21629: PUSH
21630: LD_VAR 0 6
21634: PUSH
21635: LD_VAR 0 2
21639: PUSH
21640: LD_VAR 0 5
21644: ARRAY
21645: ARRAY
21646: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21647: LD_ADDR_VAR 0 7
21651: PUSH
21652: LD_VAR 0 7
21656: PUSH
21657: LD_VAR 0 6
21661: PUSH
21662: EMPTY
21663: LIST
21664: ADD
21665: ST_TO_ADDR
// end ;
21666: GO 21622
21668: POP
21669: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21670: LD_ADDR_VAR 0 6
21674: PUSH
21675: LD_VAR 0 6
21679: PPUSH
21680: LD_VAR 0 2
21684: PUSH
21685: LD_VAR 0 2
21689: ARRAY
21690: PPUSH
21691: LD_VAR 0 3
21695: PPUSH
21696: CALL_OW 1
21700: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21701: LD_ADDR_VAR 0 7
21705: PUSH
21706: LD_VAR 0 7
21710: PPUSH
21711: LD_VAR 0 7
21715: PPUSH
21716: LD_VAR 0 6
21720: PPUSH
21721: CALL_OW 1
21725: ST_TO_ADDR
// for i = s_arr downto 2 do
21726: LD_ADDR_VAR 0 5
21730: PUSH
21731: DOUBLE
21732: LD_VAR 0 7
21736: INC
21737: ST_TO_ADDR
21738: LD_INT 2
21740: PUSH
21741: FOR_DOWNTO
21742: IFFALSE 21826
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21744: LD_ADDR_VAR 0 6
21748: PUSH
21749: LD_VAR 0 7
21753: PUSH
21754: LD_VAR 0 5
21758: PUSH
21759: LD_INT 1
21761: MINUS
21762: ARRAY
21763: PPUSH
21764: LD_VAR 0 2
21768: PUSH
21769: LD_VAR 0 5
21773: PUSH
21774: LD_INT 1
21776: MINUS
21777: ARRAY
21778: PPUSH
21779: LD_VAR 0 7
21783: PUSH
21784: LD_VAR 0 5
21788: ARRAY
21789: PPUSH
21790: CALL_OW 1
21794: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21795: LD_ADDR_VAR 0 7
21799: PUSH
21800: LD_VAR 0 7
21804: PPUSH
21805: LD_VAR 0 5
21809: PUSH
21810: LD_INT 1
21812: MINUS
21813: PPUSH
21814: LD_VAR 0 6
21818: PPUSH
21819: CALL_OW 1
21823: ST_TO_ADDR
// end ;
21824: GO 21741
21826: POP
21827: POP
// result := s_arr [ 1 ] ;
21828: LD_ADDR_VAR 0 4
21832: PUSH
21833: LD_VAR 0 7
21837: PUSH
21838: LD_INT 1
21840: ARRAY
21841: ST_TO_ADDR
// end ; end ;
21842: LD_VAR 0 4
21846: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21847: LD_INT 0
21849: PPUSH
21850: PPUSH
// if not list then
21851: LD_VAR 0 1
21855: NOT
21856: IFFALSE 21860
// exit ;
21858: GO 21951
// i := list [ pos1 ] ;
21860: LD_ADDR_VAR 0 5
21864: PUSH
21865: LD_VAR 0 1
21869: PUSH
21870: LD_VAR 0 2
21874: ARRAY
21875: ST_TO_ADDR
// if not i then
21876: LD_VAR 0 5
21880: NOT
21881: IFFALSE 21885
// exit ;
21883: GO 21951
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21885: LD_ADDR_VAR 0 1
21889: PUSH
21890: LD_VAR 0 1
21894: PPUSH
21895: LD_VAR 0 2
21899: PPUSH
21900: LD_VAR 0 1
21904: PUSH
21905: LD_VAR 0 3
21909: ARRAY
21910: PPUSH
21911: CALL_OW 1
21915: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21916: LD_ADDR_VAR 0 1
21920: PUSH
21921: LD_VAR 0 1
21925: PPUSH
21926: LD_VAR 0 3
21930: PPUSH
21931: LD_VAR 0 5
21935: PPUSH
21936: CALL_OW 1
21940: ST_TO_ADDR
// result := list ;
21941: LD_ADDR_VAR 0 4
21945: PUSH
21946: LD_VAR 0 1
21950: ST_TO_ADDR
// end ;
21951: LD_VAR 0 4
21955: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21956: LD_INT 0
21958: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21959: LD_ADDR_VAR 0 5
21963: PUSH
21964: LD_VAR 0 1
21968: PPUSH
21969: CALL_OW 250
21973: PPUSH
21974: LD_VAR 0 1
21978: PPUSH
21979: CALL_OW 251
21983: PPUSH
21984: LD_VAR 0 2
21988: PPUSH
21989: LD_VAR 0 3
21993: PPUSH
21994: LD_VAR 0 4
21998: PPUSH
21999: CALL 22009 0 5
22003: ST_TO_ADDR
// end ;
22004: LD_VAR 0 5
22008: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
22009: LD_INT 0
22011: PPUSH
22012: PPUSH
22013: PPUSH
22014: PPUSH
// if not list then
22015: LD_VAR 0 3
22019: NOT
22020: IFFALSE 22024
// exit ;
22022: GO 22412
// result := [ ] ;
22024: LD_ADDR_VAR 0 6
22028: PUSH
22029: EMPTY
22030: ST_TO_ADDR
// for i in list do
22031: LD_ADDR_VAR 0 7
22035: PUSH
22036: LD_VAR 0 3
22040: PUSH
22041: FOR_IN
22042: IFFALSE 22244
// begin tmp := GetDistUnitXY ( i , x , y ) ;
22044: LD_ADDR_VAR 0 9
22048: PUSH
22049: LD_VAR 0 7
22053: PPUSH
22054: LD_VAR 0 1
22058: PPUSH
22059: LD_VAR 0 2
22063: PPUSH
22064: CALL_OW 297
22068: ST_TO_ADDR
// if not result then
22069: LD_VAR 0 6
22073: NOT
22074: IFFALSE 22100
// result := [ [ i , tmp ] ] else
22076: LD_ADDR_VAR 0 6
22080: PUSH
22081: LD_VAR 0 7
22085: PUSH
22086: LD_VAR 0 9
22090: PUSH
22091: EMPTY
22092: LIST
22093: LIST
22094: PUSH
22095: EMPTY
22096: LIST
22097: ST_TO_ADDR
22098: GO 22242
// begin if result [ result ] [ 2 ] < tmp then
22100: LD_VAR 0 6
22104: PUSH
22105: LD_VAR 0 6
22109: ARRAY
22110: PUSH
22111: LD_INT 2
22113: ARRAY
22114: PUSH
22115: LD_VAR 0 9
22119: LESS
22120: IFFALSE 22162
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
22122: LD_ADDR_VAR 0 6
22126: PUSH
22127: LD_VAR 0 6
22131: PPUSH
22132: LD_VAR 0 6
22136: PUSH
22137: LD_INT 1
22139: PLUS
22140: PPUSH
22141: LD_VAR 0 7
22145: PUSH
22146: LD_VAR 0 9
22150: PUSH
22151: EMPTY
22152: LIST
22153: LIST
22154: PPUSH
22155: CALL_OW 2
22159: ST_TO_ADDR
22160: GO 22242
// for j = 1 to result do
22162: LD_ADDR_VAR 0 8
22166: PUSH
22167: DOUBLE
22168: LD_INT 1
22170: DEC
22171: ST_TO_ADDR
22172: LD_VAR 0 6
22176: PUSH
22177: FOR_TO
22178: IFFALSE 22240
// begin if tmp < result [ j ] [ 2 ] then
22180: LD_VAR 0 9
22184: PUSH
22185: LD_VAR 0 6
22189: PUSH
22190: LD_VAR 0 8
22194: ARRAY
22195: PUSH
22196: LD_INT 2
22198: ARRAY
22199: LESS
22200: IFFALSE 22238
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22202: LD_ADDR_VAR 0 6
22206: PUSH
22207: LD_VAR 0 6
22211: PPUSH
22212: LD_VAR 0 8
22216: PPUSH
22217: LD_VAR 0 7
22221: PUSH
22222: LD_VAR 0 9
22226: PUSH
22227: EMPTY
22228: LIST
22229: LIST
22230: PPUSH
22231: CALL_OW 2
22235: ST_TO_ADDR
// break ;
22236: GO 22240
// end ; end ;
22238: GO 22177
22240: POP
22241: POP
// end ; end ;
22242: GO 22041
22244: POP
22245: POP
// if result and not asc then
22246: LD_VAR 0 6
22250: PUSH
22251: LD_VAR 0 4
22255: NOT
22256: AND
22257: IFFALSE 22332
// begin tmp := result ;
22259: LD_ADDR_VAR 0 9
22263: PUSH
22264: LD_VAR 0 6
22268: ST_TO_ADDR
// for i = tmp downto 1 do
22269: LD_ADDR_VAR 0 7
22273: PUSH
22274: DOUBLE
22275: LD_VAR 0 9
22279: INC
22280: ST_TO_ADDR
22281: LD_INT 1
22283: PUSH
22284: FOR_DOWNTO
22285: IFFALSE 22330
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
22287: LD_ADDR_VAR 0 6
22291: PUSH
22292: LD_VAR 0 6
22296: PPUSH
22297: LD_VAR 0 9
22301: PUSH
22302: LD_VAR 0 7
22306: MINUS
22307: PUSH
22308: LD_INT 1
22310: PLUS
22311: PPUSH
22312: LD_VAR 0 9
22316: PUSH
22317: LD_VAR 0 7
22321: ARRAY
22322: PPUSH
22323: CALL_OW 1
22327: ST_TO_ADDR
22328: GO 22284
22330: POP
22331: POP
// end ; tmp := [ ] ;
22332: LD_ADDR_VAR 0 9
22336: PUSH
22337: EMPTY
22338: ST_TO_ADDR
// if mode then
22339: LD_VAR 0 5
22343: IFFALSE 22412
// begin for i = 1 to result do
22345: LD_ADDR_VAR 0 7
22349: PUSH
22350: DOUBLE
22351: LD_INT 1
22353: DEC
22354: ST_TO_ADDR
22355: LD_VAR 0 6
22359: PUSH
22360: FOR_TO
22361: IFFALSE 22400
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
22363: LD_ADDR_VAR 0 9
22367: PUSH
22368: LD_VAR 0 9
22372: PPUSH
22373: LD_VAR 0 7
22377: PPUSH
22378: LD_VAR 0 6
22382: PUSH
22383: LD_VAR 0 7
22387: ARRAY
22388: PUSH
22389: LD_INT 1
22391: ARRAY
22392: PPUSH
22393: CALL_OW 1
22397: ST_TO_ADDR
22398: GO 22360
22400: POP
22401: POP
// result := tmp ;
22402: LD_ADDR_VAR 0 6
22406: PUSH
22407: LD_VAR 0 9
22411: ST_TO_ADDR
// end ; end ;
22412: LD_VAR 0 6
22416: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22417: LD_INT 0
22419: PPUSH
22420: PPUSH
22421: PPUSH
22422: PPUSH
22423: PPUSH
22424: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22425: LD_ADDR_VAR 0 5
22429: PUSH
22430: LD_INT 0
22432: PUSH
22433: LD_INT 0
22435: PUSH
22436: LD_INT 0
22438: PUSH
22439: EMPTY
22440: PUSH
22441: EMPTY
22442: LIST
22443: LIST
22444: LIST
22445: LIST
22446: ST_TO_ADDR
// if not x or not y then
22447: LD_VAR 0 2
22451: NOT
22452: PUSH
22453: LD_VAR 0 3
22457: NOT
22458: OR
22459: IFFALSE 22463
// exit ;
22461: GO 24109
// if not range then
22463: LD_VAR 0 4
22467: NOT
22468: IFFALSE 22478
// range := 10 ;
22470: LD_ADDR_VAR 0 4
22474: PUSH
22475: LD_INT 10
22477: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22478: LD_ADDR_VAR 0 8
22482: PUSH
22483: LD_INT 81
22485: PUSH
22486: LD_VAR 0 1
22490: PUSH
22491: EMPTY
22492: LIST
22493: LIST
22494: PUSH
22495: LD_INT 92
22497: PUSH
22498: LD_VAR 0 2
22502: PUSH
22503: LD_VAR 0 3
22507: PUSH
22508: LD_VAR 0 4
22512: PUSH
22513: EMPTY
22514: LIST
22515: LIST
22516: LIST
22517: LIST
22518: PUSH
22519: LD_INT 3
22521: PUSH
22522: LD_INT 21
22524: PUSH
22525: LD_INT 3
22527: PUSH
22528: EMPTY
22529: LIST
22530: LIST
22531: PUSH
22532: EMPTY
22533: LIST
22534: LIST
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: LIST
22540: PPUSH
22541: CALL_OW 69
22545: ST_TO_ADDR
// if not tmp then
22546: LD_VAR 0 8
22550: NOT
22551: IFFALSE 22555
// exit ;
22553: GO 24109
// for i in tmp do
22555: LD_ADDR_VAR 0 6
22559: PUSH
22560: LD_VAR 0 8
22564: PUSH
22565: FOR_IN
22566: IFFALSE 24084
// begin points := [ 0 , 0 , 0 ] ;
22568: LD_ADDR_VAR 0 9
22572: PUSH
22573: LD_INT 0
22575: PUSH
22576: LD_INT 0
22578: PUSH
22579: LD_INT 0
22581: PUSH
22582: EMPTY
22583: LIST
22584: LIST
22585: LIST
22586: ST_TO_ADDR
// bpoints := 1 ;
22587: LD_ADDR_VAR 0 10
22591: PUSH
22592: LD_INT 1
22594: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22595: LD_VAR 0 6
22599: PPUSH
22600: CALL_OW 247
22604: PUSH
22605: LD_INT 1
22607: DOUBLE
22608: EQUAL
22609: IFTRUE 22613
22611: GO 23191
22613: POP
// begin if GetClass ( i ) = 1 then
22614: LD_VAR 0 6
22618: PPUSH
22619: CALL_OW 257
22623: PUSH
22624: LD_INT 1
22626: EQUAL
22627: IFFALSE 22648
// points := [ 10 , 5 , 3 ] ;
22629: LD_ADDR_VAR 0 9
22633: PUSH
22634: LD_INT 10
22636: PUSH
22637: LD_INT 5
22639: PUSH
22640: LD_INT 3
22642: PUSH
22643: EMPTY
22644: LIST
22645: LIST
22646: LIST
22647: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22648: LD_VAR 0 6
22652: PPUSH
22653: CALL_OW 257
22657: PUSH
22658: LD_INT 2
22660: PUSH
22661: LD_INT 3
22663: PUSH
22664: LD_INT 4
22666: PUSH
22667: EMPTY
22668: LIST
22669: LIST
22670: LIST
22671: IN
22672: IFFALSE 22693
// points := [ 3 , 2 , 1 ] ;
22674: LD_ADDR_VAR 0 9
22678: PUSH
22679: LD_INT 3
22681: PUSH
22682: LD_INT 2
22684: PUSH
22685: LD_INT 1
22687: PUSH
22688: EMPTY
22689: LIST
22690: LIST
22691: LIST
22692: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22693: LD_VAR 0 6
22697: PPUSH
22698: CALL_OW 257
22702: PUSH
22703: LD_INT 5
22705: EQUAL
22706: IFFALSE 22727
// points := [ 130 , 5 , 2 ] ;
22708: LD_ADDR_VAR 0 9
22712: PUSH
22713: LD_INT 130
22715: PUSH
22716: LD_INT 5
22718: PUSH
22719: LD_INT 2
22721: PUSH
22722: EMPTY
22723: LIST
22724: LIST
22725: LIST
22726: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22727: LD_VAR 0 6
22731: PPUSH
22732: CALL_OW 257
22736: PUSH
22737: LD_INT 8
22739: EQUAL
22740: IFFALSE 22761
// points := [ 35 , 35 , 30 ] ;
22742: LD_ADDR_VAR 0 9
22746: PUSH
22747: LD_INT 35
22749: PUSH
22750: LD_INT 35
22752: PUSH
22753: LD_INT 30
22755: PUSH
22756: EMPTY
22757: LIST
22758: LIST
22759: LIST
22760: ST_TO_ADDR
// if GetClass ( i ) = 9 then
22761: LD_VAR 0 6
22765: PPUSH
22766: CALL_OW 257
22770: PUSH
22771: LD_INT 9
22773: EQUAL
22774: IFFALSE 22795
// points := [ 20 , 55 , 40 ] ;
22776: LD_ADDR_VAR 0 9
22780: PUSH
22781: LD_INT 20
22783: PUSH
22784: LD_INT 55
22786: PUSH
22787: LD_INT 40
22789: PUSH
22790: EMPTY
22791: LIST
22792: LIST
22793: LIST
22794: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
22795: LD_VAR 0 6
22799: PPUSH
22800: CALL_OW 257
22804: PUSH
22805: LD_INT 12
22807: PUSH
22808: LD_INT 16
22810: PUSH
22811: EMPTY
22812: LIST
22813: LIST
22814: IN
22815: IFFALSE 22836
// points := [ 5 , 3 , 2 ] ;
22817: LD_ADDR_VAR 0 9
22821: PUSH
22822: LD_INT 5
22824: PUSH
22825: LD_INT 3
22827: PUSH
22828: LD_INT 2
22830: PUSH
22831: EMPTY
22832: LIST
22833: LIST
22834: LIST
22835: ST_TO_ADDR
// if GetClass ( i ) = 17 then
22836: LD_VAR 0 6
22840: PPUSH
22841: CALL_OW 257
22845: PUSH
22846: LD_INT 17
22848: EQUAL
22849: IFFALSE 22870
// points := [ 100 , 50 , 75 ] ;
22851: LD_ADDR_VAR 0 9
22855: PUSH
22856: LD_INT 100
22858: PUSH
22859: LD_INT 50
22861: PUSH
22862: LD_INT 75
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: LIST
22869: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22870: LD_VAR 0 6
22874: PPUSH
22875: CALL_OW 257
22879: PUSH
22880: LD_INT 15
22882: EQUAL
22883: IFFALSE 22904
// points := [ 10 , 5 , 3 ] ;
22885: LD_ADDR_VAR 0 9
22889: PUSH
22890: LD_INT 10
22892: PUSH
22893: LD_INT 5
22895: PUSH
22896: LD_INT 3
22898: PUSH
22899: EMPTY
22900: LIST
22901: LIST
22902: LIST
22903: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22904: LD_VAR 0 6
22908: PPUSH
22909: CALL_OW 257
22913: PUSH
22914: LD_INT 14
22916: EQUAL
22917: IFFALSE 22938
// points := [ 10 , 0 , 0 ] ;
22919: LD_ADDR_VAR 0 9
22923: PUSH
22924: LD_INT 10
22926: PUSH
22927: LD_INT 0
22929: PUSH
22930: LD_INT 0
22932: PUSH
22933: EMPTY
22934: LIST
22935: LIST
22936: LIST
22937: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22938: LD_VAR 0 6
22942: PPUSH
22943: CALL_OW 257
22947: PUSH
22948: LD_INT 11
22950: EQUAL
22951: IFFALSE 22972
// points := [ 30 , 10 , 5 ] ;
22953: LD_ADDR_VAR 0 9
22957: PUSH
22958: LD_INT 30
22960: PUSH
22961: LD_INT 10
22963: PUSH
22964: LD_INT 5
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: LIST
22971: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22972: LD_VAR 0 1
22976: PPUSH
22977: LD_INT 5
22979: PPUSH
22980: CALL_OW 321
22984: PUSH
22985: LD_INT 2
22987: EQUAL
22988: IFFALSE 23005
// bpoints := bpoints * 1.8 ;
22990: LD_ADDR_VAR 0 10
22994: PUSH
22995: LD_VAR 0 10
22999: PUSH
23000: LD_REAL  1.80000000000000E+0000
23003: MUL
23004: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
23005: LD_VAR 0 6
23009: PPUSH
23010: CALL_OW 257
23014: PUSH
23015: LD_INT 1
23017: PUSH
23018: LD_INT 2
23020: PUSH
23021: LD_INT 3
23023: PUSH
23024: LD_INT 4
23026: PUSH
23027: EMPTY
23028: LIST
23029: LIST
23030: LIST
23031: LIST
23032: IN
23033: PUSH
23034: LD_VAR 0 1
23038: PPUSH
23039: LD_INT 51
23041: PPUSH
23042: CALL_OW 321
23046: PUSH
23047: LD_INT 2
23049: EQUAL
23050: AND
23051: IFFALSE 23068
// bpoints := bpoints * 1.2 ;
23053: LD_ADDR_VAR 0 10
23057: PUSH
23058: LD_VAR 0 10
23062: PUSH
23063: LD_REAL  1.20000000000000E+0000
23066: MUL
23067: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
23068: LD_VAR 0 6
23072: PPUSH
23073: CALL_OW 257
23077: PUSH
23078: LD_INT 5
23080: PUSH
23081: LD_INT 7
23083: PUSH
23084: LD_INT 9
23086: PUSH
23087: EMPTY
23088: LIST
23089: LIST
23090: LIST
23091: IN
23092: PUSH
23093: LD_VAR 0 1
23097: PPUSH
23098: LD_INT 52
23100: PPUSH
23101: CALL_OW 321
23105: PUSH
23106: LD_INT 2
23108: EQUAL
23109: AND
23110: IFFALSE 23127
// bpoints := bpoints * 1.5 ;
23112: LD_ADDR_VAR 0 10
23116: PUSH
23117: LD_VAR 0 10
23121: PUSH
23122: LD_REAL  1.50000000000000E+0000
23125: MUL
23126: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
23127: LD_VAR 0 1
23131: PPUSH
23132: LD_INT 66
23134: PPUSH
23135: CALL_OW 321
23139: PUSH
23140: LD_INT 2
23142: EQUAL
23143: IFFALSE 23160
// bpoints := bpoints * 1.1 ;
23145: LD_ADDR_VAR 0 10
23149: PUSH
23150: LD_VAR 0 10
23154: PUSH
23155: LD_REAL  1.10000000000000E+0000
23158: MUL
23159: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
23160: LD_ADDR_VAR 0 10
23164: PUSH
23165: LD_VAR 0 10
23169: PUSH
23170: LD_VAR 0 6
23174: PPUSH
23175: LD_INT 1
23177: PPUSH
23178: CALL_OW 259
23182: PUSH
23183: LD_REAL  1.15000000000000E+0000
23186: MUL
23187: MUL
23188: ST_TO_ADDR
// end ; unit_vehicle :
23189: GO 24013
23191: LD_INT 2
23193: DOUBLE
23194: EQUAL
23195: IFTRUE 23199
23197: GO 24001
23199: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
23200: LD_VAR 0 6
23204: PPUSH
23205: CALL_OW 264
23209: PUSH
23210: LD_INT 2
23212: PUSH
23213: LD_INT 42
23215: PUSH
23216: LD_INT 24
23218: PUSH
23219: EMPTY
23220: LIST
23221: LIST
23222: LIST
23223: IN
23224: IFFALSE 23245
// points := [ 25 , 5 , 3 ] ;
23226: LD_ADDR_VAR 0 9
23230: PUSH
23231: LD_INT 25
23233: PUSH
23234: LD_INT 5
23236: PUSH
23237: LD_INT 3
23239: PUSH
23240: EMPTY
23241: LIST
23242: LIST
23243: LIST
23244: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
23245: LD_VAR 0 6
23249: PPUSH
23250: CALL_OW 264
23254: PUSH
23255: LD_INT 4
23257: PUSH
23258: LD_INT 43
23260: PUSH
23261: LD_INT 25
23263: PUSH
23264: EMPTY
23265: LIST
23266: LIST
23267: LIST
23268: IN
23269: IFFALSE 23290
// points := [ 40 , 15 , 5 ] ;
23271: LD_ADDR_VAR 0 9
23275: PUSH
23276: LD_INT 40
23278: PUSH
23279: LD_INT 15
23281: PUSH
23282: LD_INT 5
23284: PUSH
23285: EMPTY
23286: LIST
23287: LIST
23288: LIST
23289: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
23290: LD_VAR 0 6
23294: PPUSH
23295: CALL_OW 264
23299: PUSH
23300: LD_INT 3
23302: PUSH
23303: LD_INT 23
23305: PUSH
23306: EMPTY
23307: LIST
23308: LIST
23309: IN
23310: IFFALSE 23331
// points := [ 7 , 25 , 8 ] ;
23312: LD_ADDR_VAR 0 9
23316: PUSH
23317: LD_INT 7
23319: PUSH
23320: LD_INT 25
23322: PUSH
23323: LD_INT 8
23325: PUSH
23326: EMPTY
23327: LIST
23328: LIST
23329: LIST
23330: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
23331: LD_VAR 0 6
23335: PPUSH
23336: CALL_OW 264
23340: PUSH
23341: LD_INT 5
23343: PUSH
23344: LD_INT 27
23346: PUSH
23347: LD_INT 44
23349: PUSH
23350: EMPTY
23351: LIST
23352: LIST
23353: LIST
23354: IN
23355: IFFALSE 23376
// points := [ 14 , 50 , 16 ] ;
23357: LD_ADDR_VAR 0 9
23361: PUSH
23362: LD_INT 14
23364: PUSH
23365: LD_INT 50
23367: PUSH
23368: LD_INT 16
23370: PUSH
23371: EMPTY
23372: LIST
23373: LIST
23374: LIST
23375: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23376: LD_VAR 0 6
23380: PPUSH
23381: CALL_OW 264
23385: PUSH
23386: LD_INT 6
23388: PUSH
23389: LD_INT 46
23391: PUSH
23392: EMPTY
23393: LIST
23394: LIST
23395: IN
23396: IFFALSE 23417
// points := [ 32 , 120 , 70 ] ;
23398: LD_ADDR_VAR 0 9
23402: PUSH
23403: LD_INT 32
23405: PUSH
23406: LD_INT 120
23408: PUSH
23409: LD_INT 70
23411: PUSH
23412: EMPTY
23413: LIST
23414: LIST
23415: LIST
23416: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
23417: LD_VAR 0 6
23421: PPUSH
23422: CALL_OW 264
23426: PUSH
23427: LD_INT 7
23429: PUSH
23430: LD_INT 28
23432: PUSH
23433: LD_INT 45
23435: PUSH
23436: EMPTY
23437: LIST
23438: LIST
23439: LIST
23440: IN
23441: IFFALSE 23462
// points := [ 35 , 20 , 45 ] ;
23443: LD_ADDR_VAR 0 9
23447: PUSH
23448: LD_INT 35
23450: PUSH
23451: LD_INT 20
23453: PUSH
23454: LD_INT 45
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: LIST
23461: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23462: LD_VAR 0 6
23466: PPUSH
23467: CALL_OW 264
23471: PUSH
23472: LD_INT 47
23474: PUSH
23475: EMPTY
23476: LIST
23477: IN
23478: IFFALSE 23499
// points := [ 67 , 45 , 75 ] ;
23480: LD_ADDR_VAR 0 9
23484: PUSH
23485: LD_INT 67
23487: PUSH
23488: LD_INT 45
23490: PUSH
23491: LD_INT 75
23493: PUSH
23494: EMPTY
23495: LIST
23496: LIST
23497: LIST
23498: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23499: LD_VAR 0 6
23503: PPUSH
23504: CALL_OW 264
23508: PUSH
23509: LD_INT 26
23511: PUSH
23512: EMPTY
23513: LIST
23514: IN
23515: IFFALSE 23536
// points := [ 120 , 30 , 80 ] ;
23517: LD_ADDR_VAR 0 9
23521: PUSH
23522: LD_INT 120
23524: PUSH
23525: LD_INT 30
23527: PUSH
23528: LD_INT 80
23530: PUSH
23531: EMPTY
23532: LIST
23533: LIST
23534: LIST
23535: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23536: LD_VAR 0 6
23540: PPUSH
23541: CALL_OW 264
23545: PUSH
23546: LD_INT 22
23548: PUSH
23549: EMPTY
23550: LIST
23551: IN
23552: IFFALSE 23573
// points := [ 40 , 1 , 1 ] ;
23554: LD_ADDR_VAR 0 9
23558: PUSH
23559: LD_INT 40
23561: PUSH
23562: LD_INT 1
23564: PUSH
23565: LD_INT 1
23567: PUSH
23568: EMPTY
23569: LIST
23570: LIST
23571: LIST
23572: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23573: LD_VAR 0 6
23577: PPUSH
23578: CALL_OW 264
23582: PUSH
23583: LD_INT 29
23585: PUSH
23586: EMPTY
23587: LIST
23588: IN
23589: IFFALSE 23610
// points := [ 70 , 200 , 400 ] ;
23591: LD_ADDR_VAR 0 9
23595: PUSH
23596: LD_INT 70
23598: PUSH
23599: LD_INT 200
23601: PUSH
23602: LD_INT 400
23604: PUSH
23605: EMPTY
23606: LIST
23607: LIST
23608: LIST
23609: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23610: LD_VAR 0 6
23614: PPUSH
23615: CALL_OW 264
23619: PUSH
23620: LD_INT 14
23622: PUSH
23623: LD_INT 53
23625: PUSH
23626: EMPTY
23627: LIST
23628: LIST
23629: IN
23630: IFFALSE 23651
// points := [ 40 , 10 , 20 ] ;
23632: LD_ADDR_VAR 0 9
23636: PUSH
23637: LD_INT 40
23639: PUSH
23640: LD_INT 10
23642: PUSH
23643: LD_INT 20
23645: PUSH
23646: EMPTY
23647: LIST
23648: LIST
23649: LIST
23650: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23651: LD_VAR 0 6
23655: PPUSH
23656: CALL_OW 264
23660: PUSH
23661: LD_INT 9
23663: PUSH
23664: EMPTY
23665: LIST
23666: IN
23667: IFFALSE 23688
// points := [ 5 , 70 , 20 ] ;
23669: LD_ADDR_VAR 0 9
23673: PUSH
23674: LD_INT 5
23676: PUSH
23677: LD_INT 70
23679: PUSH
23680: LD_INT 20
23682: PUSH
23683: EMPTY
23684: LIST
23685: LIST
23686: LIST
23687: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23688: LD_VAR 0 6
23692: PPUSH
23693: CALL_OW 264
23697: PUSH
23698: LD_INT 10
23700: PUSH
23701: EMPTY
23702: LIST
23703: IN
23704: IFFALSE 23725
// points := [ 35 , 110 , 70 ] ;
23706: LD_ADDR_VAR 0 9
23710: PUSH
23711: LD_INT 35
23713: PUSH
23714: LD_INT 110
23716: PUSH
23717: LD_INT 70
23719: PUSH
23720: EMPTY
23721: LIST
23722: LIST
23723: LIST
23724: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23725: LD_VAR 0 6
23729: PPUSH
23730: CALL_OW 265
23734: PUSH
23735: LD_INT 25
23737: EQUAL
23738: IFFALSE 23759
// points := [ 80 , 65 , 100 ] ;
23740: LD_ADDR_VAR 0 9
23744: PUSH
23745: LD_INT 80
23747: PUSH
23748: LD_INT 65
23750: PUSH
23751: LD_INT 100
23753: PUSH
23754: EMPTY
23755: LIST
23756: LIST
23757: LIST
23758: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
23759: LD_VAR 0 6
23763: PPUSH
23764: CALL_OW 263
23768: PUSH
23769: LD_INT 1
23771: EQUAL
23772: IFFALSE 23807
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
23774: LD_ADDR_VAR 0 10
23778: PUSH
23779: LD_VAR 0 10
23783: PUSH
23784: LD_VAR 0 6
23788: PPUSH
23789: CALL_OW 311
23793: PPUSH
23794: LD_INT 3
23796: PPUSH
23797: CALL_OW 259
23801: PUSH
23802: LD_INT 4
23804: MUL
23805: MUL
23806: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
23807: LD_VAR 0 6
23811: PPUSH
23812: CALL_OW 263
23816: PUSH
23817: LD_INT 2
23819: EQUAL
23820: IFFALSE 23871
// begin j := IsControledBy ( i ) ;
23822: LD_ADDR_VAR 0 7
23826: PUSH
23827: LD_VAR 0 6
23831: PPUSH
23832: CALL_OW 312
23836: ST_TO_ADDR
// if j then
23837: LD_VAR 0 7
23841: IFFALSE 23871
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
23843: LD_ADDR_VAR 0 10
23847: PUSH
23848: LD_VAR 0 10
23852: PUSH
23853: LD_VAR 0 7
23857: PPUSH
23858: LD_INT 3
23860: PPUSH
23861: CALL_OW 259
23865: PUSH
23866: LD_INT 3
23868: MUL
23869: MUL
23870: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23871: LD_VAR 0 6
23875: PPUSH
23876: CALL_OW 264
23880: PUSH
23881: LD_INT 5
23883: PUSH
23884: LD_INT 6
23886: PUSH
23887: LD_INT 46
23889: PUSH
23890: LD_INT 44
23892: PUSH
23893: LD_INT 47
23895: PUSH
23896: LD_INT 45
23898: PUSH
23899: LD_INT 28
23901: PUSH
23902: LD_INT 7
23904: PUSH
23905: LD_INT 27
23907: PUSH
23908: LD_INT 29
23910: PUSH
23911: EMPTY
23912: LIST
23913: LIST
23914: LIST
23915: LIST
23916: LIST
23917: LIST
23918: LIST
23919: LIST
23920: LIST
23921: LIST
23922: IN
23923: PUSH
23924: LD_VAR 0 1
23928: PPUSH
23929: LD_INT 52
23931: PPUSH
23932: CALL_OW 321
23936: PUSH
23937: LD_INT 2
23939: EQUAL
23940: AND
23941: IFFALSE 23958
// bpoints := bpoints * 1.2 ;
23943: LD_ADDR_VAR 0 10
23947: PUSH
23948: LD_VAR 0 10
23952: PUSH
23953: LD_REAL  1.20000000000000E+0000
23956: MUL
23957: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23958: LD_VAR 0 6
23962: PPUSH
23963: CALL_OW 264
23967: PUSH
23968: LD_INT 6
23970: PUSH
23971: LD_INT 46
23973: PUSH
23974: LD_INT 47
23976: PUSH
23977: EMPTY
23978: LIST
23979: LIST
23980: LIST
23981: IN
23982: IFFALSE 23999
// bpoints := bpoints * 1.2 ;
23984: LD_ADDR_VAR 0 10
23988: PUSH
23989: LD_VAR 0 10
23993: PUSH
23994: LD_REAL  1.20000000000000E+0000
23997: MUL
23998: ST_TO_ADDR
// end ; unit_building :
23999: GO 24013
24001: LD_INT 3
24003: DOUBLE
24004: EQUAL
24005: IFTRUE 24009
24007: GO 24012
24009: POP
// ; end ;
24010: GO 24013
24012: POP
// for j = 1 to 3 do
24013: LD_ADDR_VAR 0 7
24017: PUSH
24018: DOUBLE
24019: LD_INT 1
24021: DEC
24022: ST_TO_ADDR
24023: LD_INT 3
24025: PUSH
24026: FOR_TO
24027: IFFALSE 24080
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
24029: LD_ADDR_VAR 0 5
24033: PUSH
24034: LD_VAR 0 5
24038: PPUSH
24039: LD_VAR 0 7
24043: PPUSH
24044: LD_VAR 0 5
24048: PUSH
24049: LD_VAR 0 7
24053: ARRAY
24054: PUSH
24055: LD_VAR 0 9
24059: PUSH
24060: LD_VAR 0 7
24064: ARRAY
24065: PUSH
24066: LD_VAR 0 10
24070: MUL
24071: PLUS
24072: PPUSH
24073: CALL_OW 1
24077: ST_TO_ADDR
24078: GO 24026
24080: POP
24081: POP
// end ;
24082: GO 22565
24084: POP
24085: POP
// result := Replace ( result , 4 , tmp ) ;
24086: LD_ADDR_VAR 0 5
24090: PUSH
24091: LD_VAR 0 5
24095: PPUSH
24096: LD_INT 4
24098: PPUSH
24099: LD_VAR 0 8
24103: PPUSH
24104: CALL_OW 1
24108: ST_TO_ADDR
// end ;
24109: LD_VAR 0 5
24113: RET
// export function DangerAtRange ( unit , range ) ; begin
24114: LD_INT 0
24116: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
24117: LD_ADDR_VAR 0 3
24121: PUSH
24122: LD_VAR 0 1
24126: PPUSH
24127: CALL_OW 255
24131: PPUSH
24132: LD_VAR 0 1
24136: PPUSH
24137: CALL_OW 250
24141: PPUSH
24142: LD_VAR 0 1
24146: PPUSH
24147: CALL_OW 251
24151: PPUSH
24152: LD_VAR 0 2
24156: PPUSH
24157: CALL 22417 0 4
24161: ST_TO_ADDR
// end ;
24162: LD_VAR 0 3
24166: RET
// export function DangerInArea ( side , area ) ; begin
24167: LD_INT 0
24169: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
24170: LD_ADDR_VAR 0 3
24174: PUSH
24175: LD_VAR 0 2
24179: PPUSH
24180: LD_INT 81
24182: PUSH
24183: LD_VAR 0 1
24187: PUSH
24188: EMPTY
24189: LIST
24190: LIST
24191: PPUSH
24192: CALL_OW 70
24196: ST_TO_ADDR
// end ;
24197: LD_VAR 0 3
24201: RET
// export function IsExtension ( b ) ; begin
24202: LD_INT 0
24204: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
24205: LD_ADDR_VAR 0 2
24209: PUSH
24210: LD_VAR 0 1
24214: PUSH
24215: LD_INT 23
24217: PUSH
24218: LD_INT 20
24220: PUSH
24221: LD_INT 22
24223: PUSH
24224: LD_INT 17
24226: PUSH
24227: LD_INT 24
24229: PUSH
24230: LD_INT 21
24232: PUSH
24233: LD_INT 19
24235: PUSH
24236: LD_INT 16
24238: PUSH
24239: LD_INT 25
24241: PUSH
24242: LD_INT 18
24244: PUSH
24245: EMPTY
24246: LIST
24247: LIST
24248: LIST
24249: LIST
24250: LIST
24251: LIST
24252: LIST
24253: LIST
24254: LIST
24255: LIST
24256: IN
24257: ST_TO_ADDR
// end ;
24258: LD_VAR 0 2
24262: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
24263: LD_INT 0
24265: PPUSH
24266: PPUSH
24267: PPUSH
// result := [ ] ;
24268: LD_ADDR_VAR 0 3
24272: PUSH
24273: EMPTY
24274: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
24275: LD_ADDR_VAR 0 4
24279: PUSH
24280: LD_VAR 0 2
24284: PPUSH
24285: LD_INT 21
24287: PUSH
24288: LD_INT 3
24290: PUSH
24291: EMPTY
24292: LIST
24293: LIST
24294: PPUSH
24295: CALL_OW 70
24299: ST_TO_ADDR
// if not tmp then
24300: LD_VAR 0 4
24304: NOT
24305: IFFALSE 24309
// exit ;
24307: GO 24367
// for i in tmp do
24309: LD_ADDR_VAR 0 5
24313: PUSH
24314: LD_VAR 0 4
24318: PUSH
24319: FOR_IN
24320: IFFALSE 24355
// if GetBase ( i ) <> base then
24322: LD_VAR 0 5
24326: PPUSH
24327: CALL_OW 274
24331: PUSH
24332: LD_VAR 0 1
24336: NONEQUAL
24337: IFFALSE 24353
// ComLinkToBase ( base , i ) ;
24339: LD_VAR 0 1
24343: PPUSH
24344: LD_VAR 0 5
24348: PPUSH
24349: CALL_OW 169
24353: GO 24319
24355: POP
24356: POP
// result := tmp ;
24357: LD_ADDR_VAR 0 3
24361: PUSH
24362: LD_VAR 0 4
24366: ST_TO_ADDR
// end ;
24367: LD_VAR 0 3
24371: RET
// export function ComComplete ( unit , b ) ; var i ; begin
24372: LD_INT 0
24374: PPUSH
24375: PPUSH
// if BuildingStatus ( b ) = bs_build then
24376: LD_VAR 0 2
24380: PPUSH
24381: CALL_OW 461
24385: PUSH
24386: LD_INT 1
24388: EQUAL
24389: IFFALSE 24449
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24391: LD_VAR 0 1
24395: PPUSH
24396: LD_STRING h
24398: PUSH
24399: LD_VAR 0 2
24403: PPUSH
24404: CALL_OW 250
24408: PUSH
24409: LD_VAR 0 2
24413: PPUSH
24414: CALL_OW 251
24418: PUSH
24419: LD_VAR 0 2
24423: PUSH
24424: LD_INT 0
24426: PUSH
24427: LD_INT 0
24429: PUSH
24430: LD_INT 0
24432: PUSH
24433: EMPTY
24434: LIST
24435: LIST
24436: LIST
24437: LIST
24438: LIST
24439: LIST
24440: LIST
24441: PUSH
24442: EMPTY
24443: LIST
24444: PPUSH
24445: CALL_OW 446
// end ;
24449: LD_VAR 0 3
24453: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24454: LD_INT 0
24456: PPUSH
24457: PPUSH
24458: PPUSH
24459: PPUSH
24460: PPUSH
24461: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
24462: LD_VAR 0 1
24466: NOT
24467: PUSH
24468: LD_VAR 0 1
24472: PPUSH
24473: CALL_OW 263
24477: PUSH
24478: LD_INT 2
24480: EQUAL
24481: NOT
24482: OR
24483: IFFALSE 24487
// exit ;
24485: GO 24803
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24487: LD_ADDR_VAR 0 6
24491: PUSH
24492: LD_INT 22
24494: PUSH
24495: LD_VAR 0 1
24499: PPUSH
24500: CALL_OW 255
24504: PUSH
24505: EMPTY
24506: LIST
24507: LIST
24508: PUSH
24509: LD_INT 2
24511: PUSH
24512: LD_INT 30
24514: PUSH
24515: LD_INT 36
24517: PUSH
24518: EMPTY
24519: LIST
24520: LIST
24521: PUSH
24522: LD_INT 34
24524: PUSH
24525: LD_INT 31
24527: PUSH
24528: EMPTY
24529: LIST
24530: LIST
24531: PUSH
24532: EMPTY
24533: LIST
24534: LIST
24535: LIST
24536: PUSH
24537: EMPTY
24538: LIST
24539: LIST
24540: PPUSH
24541: CALL_OW 69
24545: ST_TO_ADDR
// if not tmp then
24546: LD_VAR 0 6
24550: NOT
24551: IFFALSE 24555
// exit ;
24553: GO 24803
// result := [ ] ;
24555: LD_ADDR_VAR 0 2
24559: PUSH
24560: EMPTY
24561: ST_TO_ADDR
// for i in tmp do
24562: LD_ADDR_VAR 0 3
24566: PUSH
24567: LD_VAR 0 6
24571: PUSH
24572: FOR_IN
24573: IFFALSE 24644
// begin t := UnitsInside ( i ) ;
24575: LD_ADDR_VAR 0 4
24579: PUSH
24580: LD_VAR 0 3
24584: PPUSH
24585: CALL_OW 313
24589: ST_TO_ADDR
// if t then
24590: LD_VAR 0 4
24594: IFFALSE 24642
// for j in t do
24596: LD_ADDR_VAR 0 7
24600: PUSH
24601: LD_VAR 0 4
24605: PUSH
24606: FOR_IN
24607: IFFALSE 24640
// result := Insert ( result , result + 1 , j ) ;
24609: LD_ADDR_VAR 0 2
24613: PUSH
24614: LD_VAR 0 2
24618: PPUSH
24619: LD_VAR 0 2
24623: PUSH
24624: LD_INT 1
24626: PLUS
24627: PPUSH
24628: LD_VAR 0 7
24632: PPUSH
24633: CALL_OW 2
24637: ST_TO_ADDR
24638: GO 24606
24640: POP
24641: POP
// end ;
24642: GO 24572
24644: POP
24645: POP
// if not result then
24646: LD_VAR 0 2
24650: NOT
24651: IFFALSE 24655
// exit ;
24653: GO 24803
// mech := result [ 1 ] ;
24655: LD_ADDR_VAR 0 5
24659: PUSH
24660: LD_VAR 0 2
24664: PUSH
24665: LD_INT 1
24667: ARRAY
24668: ST_TO_ADDR
// if result > 1 then
24669: LD_VAR 0 2
24673: PUSH
24674: LD_INT 1
24676: GREATER
24677: IFFALSE 24789
// for i = 2 to result do
24679: LD_ADDR_VAR 0 3
24683: PUSH
24684: DOUBLE
24685: LD_INT 2
24687: DEC
24688: ST_TO_ADDR
24689: LD_VAR 0 2
24693: PUSH
24694: FOR_TO
24695: IFFALSE 24787
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24697: LD_ADDR_VAR 0 4
24701: PUSH
24702: LD_VAR 0 2
24706: PUSH
24707: LD_VAR 0 3
24711: ARRAY
24712: PPUSH
24713: LD_INT 3
24715: PPUSH
24716: CALL_OW 259
24720: PUSH
24721: LD_VAR 0 2
24725: PUSH
24726: LD_VAR 0 3
24730: ARRAY
24731: PPUSH
24732: CALL_OW 432
24736: MINUS
24737: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
24738: LD_VAR 0 4
24742: PUSH
24743: LD_VAR 0 5
24747: PPUSH
24748: LD_INT 3
24750: PPUSH
24751: CALL_OW 259
24755: PUSH
24756: LD_VAR 0 5
24760: PPUSH
24761: CALL_OW 432
24765: MINUS
24766: GREATEREQUAL
24767: IFFALSE 24785
// mech := result [ i ] ;
24769: LD_ADDR_VAR 0 5
24773: PUSH
24774: LD_VAR 0 2
24778: PUSH
24779: LD_VAR 0 3
24783: ARRAY
24784: ST_TO_ADDR
// end ;
24785: GO 24694
24787: POP
24788: POP
// ComLinkTo ( vehicle , mech ) ;
24789: LD_VAR 0 1
24793: PPUSH
24794: LD_VAR 0 5
24798: PPUSH
24799: CALL_OW 135
// end ;
24803: LD_VAR 0 2
24807: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
24808: LD_INT 0
24810: PPUSH
24811: PPUSH
24812: PPUSH
24813: PPUSH
24814: PPUSH
24815: PPUSH
24816: PPUSH
24817: PPUSH
24818: PPUSH
24819: PPUSH
24820: PPUSH
24821: PPUSH
24822: PPUSH
// result := [ ] ;
24823: LD_ADDR_VAR 0 7
24827: PUSH
24828: EMPTY
24829: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
24830: LD_VAR 0 1
24834: PPUSH
24835: CALL_OW 266
24839: PUSH
24840: LD_INT 0
24842: PUSH
24843: LD_INT 1
24845: PUSH
24846: EMPTY
24847: LIST
24848: LIST
24849: IN
24850: NOT
24851: IFFALSE 24855
// exit ;
24853: GO 26486
// if name then
24855: LD_VAR 0 3
24859: IFFALSE 24875
// SetBName ( base_dep , name ) ;
24861: LD_VAR 0 1
24865: PPUSH
24866: LD_VAR 0 3
24870: PPUSH
24871: CALL_OW 500
// base := GetBase ( base_dep ) ;
24875: LD_ADDR_VAR 0 15
24879: PUSH
24880: LD_VAR 0 1
24884: PPUSH
24885: CALL_OW 274
24889: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24890: LD_ADDR_VAR 0 16
24894: PUSH
24895: LD_VAR 0 1
24899: PPUSH
24900: CALL_OW 255
24904: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24905: LD_ADDR_VAR 0 17
24909: PUSH
24910: LD_VAR 0 1
24914: PPUSH
24915: CALL_OW 248
24919: ST_TO_ADDR
// if sources then
24920: LD_VAR 0 5
24924: IFFALSE 24971
// for i = 1 to 3 do
24926: LD_ADDR_VAR 0 8
24930: PUSH
24931: DOUBLE
24932: LD_INT 1
24934: DEC
24935: ST_TO_ADDR
24936: LD_INT 3
24938: PUSH
24939: FOR_TO
24940: IFFALSE 24969
// AddResourceType ( base , i , sources [ i ] ) ;
24942: LD_VAR 0 15
24946: PPUSH
24947: LD_VAR 0 8
24951: PPUSH
24952: LD_VAR 0 5
24956: PUSH
24957: LD_VAR 0 8
24961: ARRAY
24962: PPUSH
24963: CALL_OW 276
24967: GO 24939
24969: POP
24970: POP
// buildings := GetBaseBuildings ( base , area ) ;
24971: LD_ADDR_VAR 0 18
24975: PUSH
24976: LD_VAR 0 15
24980: PPUSH
24981: LD_VAR 0 2
24985: PPUSH
24986: CALL 24263 0 2
24990: ST_TO_ADDR
// InitHc ;
24991: CALL_OW 19
// InitUc ;
24995: CALL_OW 18
// uc_side := side ;
24999: LD_ADDR_OWVAR 20
25003: PUSH
25004: LD_VAR 0 16
25008: ST_TO_ADDR
// uc_nation := nation ;
25009: LD_ADDR_OWVAR 21
25013: PUSH
25014: LD_VAR 0 17
25018: ST_TO_ADDR
// if buildings then
25019: LD_VAR 0 18
25023: IFFALSE 26345
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
25025: LD_ADDR_VAR 0 19
25029: PUSH
25030: LD_VAR 0 18
25034: PPUSH
25035: LD_INT 2
25037: PUSH
25038: LD_INT 30
25040: PUSH
25041: LD_INT 29
25043: PUSH
25044: EMPTY
25045: LIST
25046: LIST
25047: PUSH
25048: LD_INT 30
25050: PUSH
25051: LD_INT 30
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: PUSH
25058: EMPTY
25059: LIST
25060: LIST
25061: LIST
25062: PPUSH
25063: CALL_OW 72
25067: ST_TO_ADDR
// if tmp then
25068: LD_VAR 0 19
25072: IFFALSE 25120
// for i in tmp do
25074: LD_ADDR_VAR 0 8
25078: PUSH
25079: LD_VAR 0 19
25083: PUSH
25084: FOR_IN
25085: IFFALSE 25118
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
25087: LD_VAR 0 8
25091: PPUSH
25092: CALL_OW 250
25096: PPUSH
25097: LD_VAR 0 8
25101: PPUSH
25102: CALL_OW 251
25106: PPUSH
25107: LD_VAR 0 16
25111: PPUSH
25112: CALL_OW 441
25116: GO 25084
25118: POP
25119: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
25120: LD_VAR 0 18
25124: PPUSH
25125: LD_INT 2
25127: PUSH
25128: LD_INT 30
25130: PUSH
25131: LD_INT 32
25133: PUSH
25134: EMPTY
25135: LIST
25136: LIST
25137: PUSH
25138: LD_INT 30
25140: PUSH
25141: LD_INT 33
25143: PUSH
25144: EMPTY
25145: LIST
25146: LIST
25147: PUSH
25148: EMPTY
25149: LIST
25150: LIST
25151: LIST
25152: PPUSH
25153: CALL_OW 72
25157: IFFALSE 25245
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
25159: LD_ADDR_VAR 0 8
25163: PUSH
25164: LD_VAR 0 18
25168: PPUSH
25169: LD_INT 2
25171: PUSH
25172: LD_INT 30
25174: PUSH
25175: LD_INT 32
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: PUSH
25182: LD_INT 30
25184: PUSH
25185: LD_INT 33
25187: PUSH
25188: EMPTY
25189: LIST
25190: LIST
25191: PUSH
25192: EMPTY
25193: LIST
25194: LIST
25195: LIST
25196: PPUSH
25197: CALL_OW 72
25201: PUSH
25202: FOR_IN
25203: IFFALSE 25243
// begin if not GetBWeapon ( i ) then
25205: LD_VAR 0 8
25209: PPUSH
25210: CALL_OW 269
25214: NOT
25215: IFFALSE 25241
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
25217: LD_VAR 0 8
25221: PPUSH
25222: LD_VAR 0 8
25226: PPUSH
25227: LD_VAR 0 2
25231: PPUSH
25232: CALL 26491 0 2
25236: PPUSH
25237: CALL_OW 431
// end ;
25241: GO 25202
25243: POP
25244: POP
// end ; for i = 1 to personel do
25245: LD_ADDR_VAR 0 8
25249: PUSH
25250: DOUBLE
25251: LD_INT 1
25253: DEC
25254: ST_TO_ADDR
25255: LD_VAR 0 6
25259: PUSH
25260: FOR_TO
25261: IFFALSE 26325
// begin if i > 4 then
25263: LD_VAR 0 8
25267: PUSH
25268: LD_INT 4
25270: GREATER
25271: IFFALSE 25275
// break ;
25273: GO 26325
// case i of 1 :
25275: LD_VAR 0 8
25279: PUSH
25280: LD_INT 1
25282: DOUBLE
25283: EQUAL
25284: IFTRUE 25288
25286: GO 25368
25288: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
25289: LD_ADDR_VAR 0 12
25293: PUSH
25294: LD_VAR 0 18
25298: PPUSH
25299: LD_INT 22
25301: PUSH
25302: LD_VAR 0 16
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: PUSH
25311: LD_INT 58
25313: PUSH
25314: EMPTY
25315: LIST
25316: PUSH
25317: LD_INT 2
25319: PUSH
25320: LD_INT 30
25322: PUSH
25323: LD_INT 32
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: PUSH
25330: LD_INT 30
25332: PUSH
25333: LD_INT 4
25335: PUSH
25336: EMPTY
25337: LIST
25338: LIST
25339: PUSH
25340: LD_INT 30
25342: PUSH
25343: LD_INT 5
25345: PUSH
25346: EMPTY
25347: LIST
25348: LIST
25349: PUSH
25350: EMPTY
25351: LIST
25352: LIST
25353: LIST
25354: LIST
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: LIST
25360: PPUSH
25361: CALL_OW 72
25365: ST_TO_ADDR
25366: GO 25590
25368: LD_INT 2
25370: DOUBLE
25371: EQUAL
25372: IFTRUE 25376
25374: GO 25438
25376: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25377: LD_ADDR_VAR 0 12
25381: PUSH
25382: LD_VAR 0 18
25386: PPUSH
25387: LD_INT 22
25389: PUSH
25390: LD_VAR 0 16
25394: PUSH
25395: EMPTY
25396: LIST
25397: LIST
25398: PUSH
25399: LD_INT 2
25401: PUSH
25402: LD_INT 30
25404: PUSH
25405: LD_INT 0
25407: PUSH
25408: EMPTY
25409: LIST
25410: LIST
25411: PUSH
25412: LD_INT 30
25414: PUSH
25415: LD_INT 1
25417: PUSH
25418: EMPTY
25419: LIST
25420: LIST
25421: PUSH
25422: EMPTY
25423: LIST
25424: LIST
25425: LIST
25426: PUSH
25427: EMPTY
25428: LIST
25429: LIST
25430: PPUSH
25431: CALL_OW 72
25435: ST_TO_ADDR
25436: GO 25590
25438: LD_INT 3
25440: DOUBLE
25441: EQUAL
25442: IFTRUE 25446
25444: GO 25508
25446: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25447: LD_ADDR_VAR 0 12
25451: PUSH
25452: LD_VAR 0 18
25456: PPUSH
25457: LD_INT 22
25459: PUSH
25460: LD_VAR 0 16
25464: PUSH
25465: EMPTY
25466: LIST
25467: LIST
25468: PUSH
25469: LD_INT 2
25471: PUSH
25472: LD_INT 30
25474: PUSH
25475: LD_INT 2
25477: PUSH
25478: EMPTY
25479: LIST
25480: LIST
25481: PUSH
25482: LD_INT 30
25484: PUSH
25485: LD_INT 3
25487: PUSH
25488: EMPTY
25489: LIST
25490: LIST
25491: PUSH
25492: EMPTY
25493: LIST
25494: LIST
25495: LIST
25496: PUSH
25497: EMPTY
25498: LIST
25499: LIST
25500: PPUSH
25501: CALL_OW 72
25505: ST_TO_ADDR
25506: GO 25590
25508: LD_INT 4
25510: DOUBLE
25511: EQUAL
25512: IFTRUE 25516
25514: GO 25589
25516: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25517: LD_ADDR_VAR 0 12
25521: PUSH
25522: LD_VAR 0 18
25526: PPUSH
25527: LD_INT 22
25529: PUSH
25530: LD_VAR 0 16
25534: PUSH
25535: EMPTY
25536: LIST
25537: LIST
25538: PUSH
25539: LD_INT 2
25541: PUSH
25542: LD_INT 30
25544: PUSH
25545: LD_INT 6
25547: PUSH
25548: EMPTY
25549: LIST
25550: LIST
25551: PUSH
25552: LD_INT 30
25554: PUSH
25555: LD_INT 7
25557: PUSH
25558: EMPTY
25559: LIST
25560: LIST
25561: PUSH
25562: LD_INT 30
25564: PUSH
25565: LD_INT 8
25567: PUSH
25568: EMPTY
25569: LIST
25570: LIST
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: LIST
25576: LIST
25577: PUSH
25578: EMPTY
25579: LIST
25580: LIST
25581: PPUSH
25582: CALL_OW 72
25586: ST_TO_ADDR
25587: GO 25590
25589: POP
// if i = 1 then
25590: LD_VAR 0 8
25594: PUSH
25595: LD_INT 1
25597: EQUAL
25598: IFFALSE 25709
// begin tmp := [ ] ;
25600: LD_ADDR_VAR 0 19
25604: PUSH
25605: EMPTY
25606: ST_TO_ADDR
// for j in f do
25607: LD_ADDR_VAR 0 9
25611: PUSH
25612: LD_VAR 0 12
25616: PUSH
25617: FOR_IN
25618: IFFALSE 25691
// if GetBType ( j ) = b_bunker then
25620: LD_VAR 0 9
25624: PPUSH
25625: CALL_OW 266
25629: PUSH
25630: LD_INT 32
25632: EQUAL
25633: IFFALSE 25660
// tmp := Insert ( tmp , 1 , j ) else
25635: LD_ADDR_VAR 0 19
25639: PUSH
25640: LD_VAR 0 19
25644: PPUSH
25645: LD_INT 1
25647: PPUSH
25648: LD_VAR 0 9
25652: PPUSH
25653: CALL_OW 2
25657: ST_TO_ADDR
25658: GO 25689
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25660: LD_ADDR_VAR 0 19
25664: PUSH
25665: LD_VAR 0 19
25669: PPUSH
25670: LD_VAR 0 19
25674: PUSH
25675: LD_INT 1
25677: PLUS
25678: PPUSH
25679: LD_VAR 0 9
25683: PPUSH
25684: CALL_OW 2
25688: ST_TO_ADDR
25689: GO 25617
25691: POP
25692: POP
// if tmp then
25693: LD_VAR 0 19
25697: IFFALSE 25709
// f := tmp ;
25699: LD_ADDR_VAR 0 12
25703: PUSH
25704: LD_VAR 0 19
25708: ST_TO_ADDR
// end ; x := personel [ i ] ;
25709: LD_ADDR_VAR 0 13
25713: PUSH
25714: LD_VAR 0 6
25718: PUSH
25719: LD_VAR 0 8
25723: ARRAY
25724: ST_TO_ADDR
// if x = - 1 then
25725: LD_VAR 0 13
25729: PUSH
25730: LD_INT 1
25732: NEG
25733: EQUAL
25734: IFFALSE 25943
// begin for j in f do
25736: LD_ADDR_VAR 0 9
25740: PUSH
25741: LD_VAR 0 12
25745: PUSH
25746: FOR_IN
25747: IFFALSE 25939
// repeat InitHc ;
25749: CALL_OW 19
// if GetBType ( j ) = b_barracks then
25753: LD_VAR 0 9
25757: PPUSH
25758: CALL_OW 266
25762: PUSH
25763: LD_INT 5
25765: EQUAL
25766: IFFALSE 25836
// begin if UnitsInside ( j ) < 3 then
25768: LD_VAR 0 9
25772: PPUSH
25773: CALL_OW 313
25777: PUSH
25778: LD_INT 3
25780: LESS
25781: IFFALSE 25817
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25783: LD_INT 0
25785: PPUSH
25786: LD_INT 5
25788: PUSH
25789: LD_INT 8
25791: PUSH
25792: LD_INT 9
25794: PUSH
25795: EMPTY
25796: LIST
25797: LIST
25798: LIST
25799: PUSH
25800: LD_VAR 0 17
25804: ARRAY
25805: PPUSH
25806: LD_VAR 0 4
25810: PPUSH
25811: CALL_OW 380
25815: GO 25834
// PrepareHuman ( false , i , skill ) ;
25817: LD_INT 0
25819: PPUSH
25820: LD_VAR 0 8
25824: PPUSH
25825: LD_VAR 0 4
25829: PPUSH
25830: CALL_OW 380
// end else
25834: GO 25853
// PrepareHuman ( false , i , skill ) ;
25836: LD_INT 0
25838: PPUSH
25839: LD_VAR 0 8
25843: PPUSH
25844: LD_VAR 0 4
25848: PPUSH
25849: CALL_OW 380
// un := CreateHuman ;
25853: LD_ADDR_VAR 0 14
25857: PUSH
25858: CALL_OW 44
25862: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25863: LD_ADDR_VAR 0 7
25867: PUSH
25868: LD_VAR 0 7
25872: PPUSH
25873: LD_INT 1
25875: PPUSH
25876: LD_VAR 0 14
25880: PPUSH
25881: CALL_OW 2
25885: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25886: LD_VAR 0 14
25890: PPUSH
25891: LD_VAR 0 9
25895: PPUSH
25896: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25900: LD_VAR 0 9
25904: PPUSH
25905: CALL_OW 313
25909: PUSH
25910: LD_INT 6
25912: EQUAL
25913: PUSH
25914: LD_VAR 0 9
25918: PPUSH
25919: CALL_OW 266
25923: PUSH
25924: LD_INT 32
25926: PUSH
25927: LD_INT 31
25929: PUSH
25930: EMPTY
25931: LIST
25932: LIST
25933: IN
25934: OR
25935: IFFALSE 25749
25937: GO 25746
25939: POP
25940: POP
// end else
25941: GO 26323
// for j = 1 to x do
25943: LD_ADDR_VAR 0 9
25947: PUSH
25948: DOUBLE
25949: LD_INT 1
25951: DEC
25952: ST_TO_ADDR
25953: LD_VAR 0 13
25957: PUSH
25958: FOR_TO
25959: IFFALSE 26321
// begin InitHc ;
25961: CALL_OW 19
// if not f then
25965: LD_VAR 0 12
25969: NOT
25970: IFFALSE 26059
// begin PrepareHuman ( false , i , skill ) ;
25972: LD_INT 0
25974: PPUSH
25975: LD_VAR 0 8
25979: PPUSH
25980: LD_VAR 0 4
25984: PPUSH
25985: CALL_OW 380
// un := CreateHuman ;
25989: LD_ADDR_VAR 0 14
25993: PUSH
25994: CALL_OW 44
25998: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25999: LD_ADDR_VAR 0 7
26003: PUSH
26004: LD_VAR 0 7
26008: PPUSH
26009: LD_INT 1
26011: PPUSH
26012: LD_VAR 0 14
26016: PPUSH
26017: CALL_OW 2
26021: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26022: LD_VAR 0 14
26026: PPUSH
26027: LD_VAR 0 1
26031: PPUSH
26032: CALL_OW 250
26036: PPUSH
26037: LD_VAR 0 1
26041: PPUSH
26042: CALL_OW 251
26046: PPUSH
26047: LD_INT 10
26049: PPUSH
26050: LD_INT 0
26052: PPUSH
26053: CALL_OW 50
// continue ;
26057: GO 25958
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
26059: LD_VAR 0 12
26063: PUSH
26064: LD_INT 1
26066: ARRAY
26067: PPUSH
26068: CALL_OW 313
26072: PUSH
26073: LD_VAR 0 12
26077: PUSH
26078: LD_INT 1
26080: ARRAY
26081: PPUSH
26082: CALL_OW 266
26086: PUSH
26087: LD_INT 32
26089: PUSH
26090: LD_INT 31
26092: PUSH
26093: EMPTY
26094: LIST
26095: LIST
26096: IN
26097: AND
26098: PUSH
26099: LD_VAR 0 12
26103: PUSH
26104: LD_INT 1
26106: ARRAY
26107: PPUSH
26108: CALL_OW 313
26112: PUSH
26113: LD_INT 6
26115: EQUAL
26116: OR
26117: IFFALSE 26137
// f := Delete ( f , 1 ) ;
26119: LD_ADDR_VAR 0 12
26123: PUSH
26124: LD_VAR 0 12
26128: PPUSH
26129: LD_INT 1
26131: PPUSH
26132: CALL_OW 3
26136: ST_TO_ADDR
// if not f then
26137: LD_VAR 0 12
26141: NOT
26142: IFFALSE 26160
// begin x := x + 2 ;
26144: LD_ADDR_VAR 0 13
26148: PUSH
26149: LD_VAR 0 13
26153: PUSH
26154: LD_INT 2
26156: PLUS
26157: ST_TO_ADDR
// continue ;
26158: GO 25958
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
26160: LD_VAR 0 12
26164: PUSH
26165: LD_INT 1
26167: ARRAY
26168: PPUSH
26169: CALL_OW 266
26173: PUSH
26174: LD_INT 5
26176: EQUAL
26177: IFFALSE 26251
// begin if UnitsInside ( f [ 1 ] ) < 3 then
26179: LD_VAR 0 12
26183: PUSH
26184: LD_INT 1
26186: ARRAY
26187: PPUSH
26188: CALL_OW 313
26192: PUSH
26193: LD_INT 3
26195: LESS
26196: IFFALSE 26232
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26198: LD_INT 0
26200: PPUSH
26201: LD_INT 5
26203: PUSH
26204: LD_INT 8
26206: PUSH
26207: LD_INT 9
26209: PUSH
26210: EMPTY
26211: LIST
26212: LIST
26213: LIST
26214: PUSH
26215: LD_VAR 0 17
26219: ARRAY
26220: PPUSH
26221: LD_VAR 0 4
26225: PPUSH
26226: CALL_OW 380
26230: GO 26249
// PrepareHuman ( false , i , skill ) ;
26232: LD_INT 0
26234: PPUSH
26235: LD_VAR 0 8
26239: PPUSH
26240: LD_VAR 0 4
26244: PPUSH
26245: CALL_OW 380
// end else
26249: GO 26268
// PrepareHuman ( false , i , skill ) ;
26251: LD_INT 0
26253: PPUSH
26254: LD_VAR 0 8
26258: PPUSH
26259: LD_VAR 0 4
26263: PPUSH
26264: CALL_OW 380
// un := CreateHuman ;
26268: LD_ADDR_VAR 0 14
26272: PUSH
26273: CALL_OW 44
26277: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26278: LD_ADDR_VAR 0 7
26282: PUSH
26283: LD_VAR 0 7
26287: PPUSH
26288: LD_INT 1
26290: PPUSH
26291: LD_VAR 0 14
26295: PPUSH
26296: CALL_OW 2
26300: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
26301: LD_VAR 0 14
26305: PPUSH
26306: LD_VAR 0 12
26310: PUSH
26311: LD_INT 1
26313: ARRAY
26314: PPUSH
26315: CALL_OW 52
// end ;
26319: GO 25958
26321: POP
26322: POP
// end ;
26323: GO 25260
26325: POP
26326: POP
// result := result ^ buildings ;
26327: LD_ADDR_VAR 0 7
26331: PUSH
26332: LD_VAR 0 7
26336: PUSH
26337: LD_VAR 0 18
26341: ADD
26342: ST_TO_ADDR
// end else
26343: GO 26486
// begin for i = 1 to personel do
26345: LD_ADDR_VAR 0 8
26349: PUSH
26350: DOUBLE
26351: LD_INT 1
26353: DEC
26354: ST_TO_ADDR
26355: LD_VAR 0 6
26359: PUSH
26360: FOR_TO
26361: IFFALSE 26484
// begin if i > 4 then
26363: LD_VAR 0 8
26367: PUSH
26368: LD_INT 4
26370: GREATER
26371: IFFALSE 26375
// break ;
26373: GO 26484
// x := personel [ i ] ;
26375: LD_ADDR_VAR 0 13
26379: PUSH
26380: LD_VAR 0 6
26384: PUSH
26385: LD_VAR 0 8
26389: ARRAY
26390: ST_TO_ADDR
// if x = - 1 then
26391: LD_VAR 0 13
26395: PUSH
26396: LD_INT 1
26398: NEG
26399: EQUAL
26400: IFFALSE 26404
// continue ;
26402: GO 26360
// PrepareHuman ( false , i , skill ) ;
26404: LD_INT 0
26406: PPUSH
26407: LD_VAR 0 8
26411: PPUSH
26412: LD_VAR 0 4
26416: PPUSH
26417: CALL_OW 380
// un := CreateHuman ;
26421: LD_ADDR_VAR 0 14
26425: PUSH
26426: CALL_OW 44
26430: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26431: LD_VAR 0 14
26435: PPUSH
26436: LD_VAR 0 1
26440: PPUSH
26441: CALL_OW 250
26445: PPUSH
26446: LD_VAR 0 1
26450: PPUSH
26451: CALL_OW 251
26455: PPUSH
26456: LD_INT 10
26458: PPUSH
26459: LD_INT 0
26461: PPUSH
26462: CALL_OW 50
// result := result ^ un ;
26466: LD_ADDR_VAR 0 7
26470: PUSH
26471: LD_VAR 0 7
26475: PUSH
26476: LD_VAR 0 14
26480: ADD
26481: ST_TO_ADDR
// end ;
26482: GO 26360
26484: POP
26485: POP
// end ; end ;
26486: LD_VAR 0 7
26490: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26491: LD_INT 0
26493: PPUSH
26494: PPUSH
26495: PPUSH
26496: PPUSH
26497: PPUSH
26498: PPUSH
26499: PPUSH
26500: PPUSH
26501: PPUSH
26502: PPUSH
26503: PPUSH
26504: PPUSH
26505: PPUSH
26506: PPUSH
26507: PPUSH
26508: PPUSH
// result := false ;
26509: LD_ADDR_VAR 0 3
26513: PUSH
26514: LD_INT 0
26516: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26517: LD_VAR 0 1
26521: NOT
26522: PUSH
26523: LD_VAR 0 1
26527: PPUSH
26528: CALL_OW 266
26532: PUSH
26533: LD_INT 32
26535: PUSH
26536: LD_INT 33
26538: PUSH
26539: EMPTY
26540: LIST
26541: LIST
26542: IN
26543: NOT
26544: OR
26545: IFFALSE 26549
// exit ;
26547: GO 27685
// nat := GetNation ( tower ) ;
26549: LD_ADDR_VAR 0 12
26553: PUSH
26554: LD_VAR 0 1
26558: PPUSH
26559: CALL_OW 248
26563: ST_TO_ADDR
// side := GetSide ( tower ) ;
26564: LD_ADDR_VAR 0 16
26568: PUSH
26569: LD_VAR 0 1
26573: PPUSH
26574: CALL_OW 255
26578: ST_TO_ADDR
// x := GetX ( tower ) ;
26579: LD_ADDR_VAR 0 10
26583: PUSH
26584: LD_VAR 0 1
26588: PPUSH
26589: CALL_OW 250
26593: ST_TO_ADDR
// y := GetY ( tower ) ;
26594: LD_ADDR_VAR 0 11
26598: PUSH
26599: LD_VAR 0 1
26603: PPUSH
26604: CALL_OW 251
26608: ST_TO_ADDR
// if not x or not y then
26609: LD_VAR 0 10
26613: NOT
26614: PUSH
26615: LD_VAR 0 11
26619: NOT
26620: OR
26621: IFFALSE 26625
// exit ;
26623: GO 27685
// weapon := 0 ;
26625: LD_ADDR_VAR 0 18
26629: PUSH
26630: LD_INT 0
26632: ST_TO_ADDR
// fac_list := [ ] ;
26633: LD_ADDR_VAR 0 17
26637: PUSH
26638: EMPTY
26639: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
26640: LD_ADDR_VAR 0 6
26644: PUSH
26645: LD_VAR 0 1
26649: PPUSH
26650: CALL_OW 274
26654: PPUSH
26655: LD_VAR 0 2
26659: PPUSH
26660: CALL 24263 0 2
26664: PPUSH
26665: LD_INT 30
26667: PUSH
26668: LD_INT 3
26670: PUSH
26671: EMPTY
26672: LIST
26673: LIST
26674: PPUSH
26675: CALL_OW 72
26679: ST_TO_ADDR
// if not factories then
26680: LD_VAR 0 6
26684: NOT
26685: IFFALSE 26689
// exit ;
26687: GO 27685
// for i in factories do
26689: LD_ADDR_VAR 0 8
26693: PUSH
26694: LD_VAR 0 6
26698: PUSH
26699: FOR_IN
26700: IFFALSE 26725
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26702: LD_ADDR_VAR 0 17
26706: PUSH
26707: LD_VAR 0 17
26711: PUSH
26712: LD_VAR 0 8
26716: PPUSH
26717: CALL_OW 478
26721: UNION
26722: ST_TO_ADDR
26723: GO 26699
26725: POP
26726: POP
// if not fac_list then
26727: LD_VAR 0 17
26731: NOT
26732: IFFALSE 26736
// exit ;
26734: GO 27685
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
26736: LD_ADDR_VAR 0 5
26740: PUSH
26741: LD_INT 4
26743: PUSH
26744: LD_INT 5
26746: PUSH
26747: LD_INT 9
26749: PUSH
26750: LD_INT 10
26752: PUSH
26753: LD_INT 6
26755: PUSH
26756: LD_INT 7
26758: PUSH
26759: LD_INT 11
26761: PUSH
26762: EMPTY
26763: LIST
26764: LIST
26765: LIST
26766: LIST
26767: LIST
26768: LIST
26769: LIST
26770: PUSH
26771: LD_INT 27
26773: PUSH
26774: LD_INT 28
26776: PUSH
26777: LD_INT 26
26779: PUSH
26780: LD_INT 30
26782: PUSH
26783: EMPTY
26784: LIST
26785: LIST
26786: LIST
26787: LIST
26788: PUSH
26789: LD_INT 43
26791: PUSH
26792: LD_INT 44
26794: PUSH
26795: LD_INT 46
26797: PUSH
26798: LD_INT 45
26800: PUSH
26801: LD_INT 47
26803: PUSH
26804: LD_INT 49
26806: PUSH
26807: EMPTY
26808: LIST
26809: LIST
26810: LIST
26811: LIST
26812: LIST
26813: LIST
26814: PUSH
26815: EMPTY
26816: LIST
26817: LIST
26818: LIST
26819: PUSH
26820: LD_VAR 0 12
26824: ARRAY
26825: ST_TO_ADDR
// for i in list do
26826: LD_ADDR_VAR 0 8
26830: PUSH
26831: LD_VAR 0 5
26835: PUSH
26836: FOR_IN
26837: IFFALSE 26870
// if not i in fac_list then
26839: LD_VAR 0 8
26843: PUSH
26844: LD_VAR 0 17
26848: IN
26849: NOT
26850: IFFALSE 26868
// list := list diff i ;
26852: LD_ADDR_VAR 0 5
26856: PUSH
26857: LD_VAR 0 5
26861: PUSH
26862: LD_VAR 0 8
26866: DIFF
26867: ST_TO_ADDR
26868: GO 26836
26870: POP
26871: POP
// if not list then
26872: LD_VAR 0 5
26876: NOT
26877: IFFALSE 26881
// exit ;
26879: GO 27685
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26881: LD_VAR 0 12
26885: PUSH
26886: LD_INT 3
26888: EQUAL
26889: PUSH
26890: LD_INT 49
26892: PUSH
26893: LD_VAR 0 5
26897: IN
26898: AND
26899: PUSH
26900: LD_INT 31
26902: PPUSH
26903: LD_VAR 0 16
26907: PPUSH
26908: CALL_OW 321
26912: PUSH
26913: LD_INT 2
26915: EQUAL
26916: AND
26917: IFFALSE 26977
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26919: LD_INT 22
26921: PUSH
26922: LD_VAR 0 16
26926: PUSH
26927: EMPTY
26928: LIST
26929: LIST
26930: PUSH
26931: LD_INT 35
26933: PUSH
26934: LD_INT 49
26936: PUSH
26937: EMPTY
26938: LIST
26939: LIST
26940: PUSH
26941: LD_INT 91
26943: PUSH
26944: LD_VAR 0 1
26948: PUSH
26949: LD_INT 10
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: LIST
26956: PUSH
26957: EMPTY
26958: LIST
26959: LIST
26960: LIST
26961: PPUSH
26962: CALL_OW 69
26966: NOT
26967: IFFALSE 26977
// weapon := ru_time_lapser ;
26969: LD_ADDR_VAR 0 18
26973: PUSH
26974: LD_INT 49
26976: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26977: LD_VAR 0 12
26981: PUSH
26982: LD_INT 1
26984: PUSH
26985: LD_INT 2
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: IN
26992: PUSH
26993: LD_INT 11
26995: PUSH
26996: LD_VAR 0 5
27000: IN
27001: PUSH
27002: LD_INT 30
27004: PUSH
27005: LD_VAR 0 5
27009: IN
27010: OR
27011: AND
27012: PUSH
27013: LD_INT 6
27015: PPUSH
27016: LD_VAR 0 16
27020: PPUSH
27021: CALL_OW 321
27025: PUSH
27026: LD_INT 2
27028: EQUAL
27029: AND
27030: IFFALSE 27195
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
27032: LD_INT 22
27034: PUSH
27035: LD_VAR 0 16
27039: PUSH
27040: EMPTY
27041: LIST
27042: LIST
27043: PUSH
27044: LD_INT 2
27046: PUSH
27047: LD_INT 35
27049: PUSH
27050: LD_INT 11
27052: PUSH
27053: EMPTY
27054: LIST
27055: LIST
27056: PUSH
27057: LD_INT 35
27059: PUSH
27060: LD_INT 30
27062: PUSH
27063: EMPTY
27064: LIST
27065: LIST
27066: PUSH
27067: EMPTY
27068: LIST
27069: LIST
27070: LIST
27071: PUSH
27072: LD_INT 91
27074: PUSH
27075: LD_VAR 0 1
27079: PUSH
27080: LD_INT 18
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: LIST
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: LIST
27092: PPUSH
27093: CALL_OW 69
27097: NOT
27098: PUSH
27099: LD_INT 22
27101: PUSH
27102: LD_VAR 0 16
27106: PUSH
27107: EMPTY
27108: LIST
27109: LIST
27110: PUSH
27111: LD_INT 2
27113: PUSH
27114: LD_INT 30
27116: PUSH
27117: LD_INT 32
27119: PUSH
27120: EMPTY
27121: LIST
27122: LIST
27123: PUSH
27124: LD_INT 30
27126: PUSH
27127: LD_INT 33
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: PUSH
27134: EMPTY
27135: LIST
27136: LIST
27137: LIST
27138: PUSH
27139: LD_INT 91
27141: PUSH
27142: LD_VAR 0 1
27146: PUSH
27147: LD_INT 12
27149: PUSH
27150: EMPTY
27151: LIST
27152: LIST
27153: LIST
27154: PUSH
27155: EMPTY
27156: LIST
27157: LIST
27158: LIST
27159: PUSH
27160: EMPTY
27161: LIST
27162: PPUSH
27163: CALL_OW 69
27167: PUSH
27168: LD_INT 2
27170: GREATER
27171: AND
27172: IFFALSE 27195
// weapon := [ us_radar , ar_radar ] [ nat ] ;
27174: LD_ADDR_VAR 0 18
27178: PUSH
27179: LD_INT 11
27181: PUSH
27182: LD_INT 30
27184: PUSH
27185: EMPTY
27186: LIST
27187: LIST
27188: PUSH
27189: LD_VAR 0 12
27193: ARRAY
27194: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
27195: LD_VAR 0 18
27199: NOT
27200: PUSH
27201: LD_INT 40
27203: PPUSH
27204: LD_VAR 0 16
27208: PPUSH
27209: CALL_OW 321
27213: PUSH
27214: LD_INT 2
27216: EQUAL
27217: AND
27218: PUSH
27219: LD_INT 7
27221: PUSH
27222: LD_VAR 0 5
27226: IN
27227: PUSH
27228: LD_INT 28
27230: PUSH
27231: LD_VAR 0 5
27235: IN
27236: OR
27237: PUSH
27238: LD_INT 45
27240: PUSH
27241: LD_VAR 0 5
27245: IN
27246: OR
27247: AND
27248: IFFALSE 27502
// begin hex := GetHexInfo ( x , y ) ;
27250: LD_ADDR_VAR 0 4
27254: PUSH
27255: LD_VAR 0 10
27259: PPUSH
27260: LD_VAR 0 11
27264: PPUSH
27265: CALL_OW 546
27269: ST_TO_ADDR
// if hex [ 1 ] then
27270: LD_VAR 0 4
27274: PUSH
27275: LD_INT 1
27277: ARRAY
27278: IFFALSE 27282
// exit ;
27280: GO 27685
// height := hex [ 2 ] ;
27282: LD_ADDR_VAR 0 15
27286: PUSH
27287: LD_VAR 0 4
27291: PUSH
27292: LD_INT 2
27294: ARRAY
27295: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
27296: LD_ADDR_VAR 0 14
27300: PUSH
27301: LD_INT 0
27303: PUSH
27304: LD_INT 2
27306: PUSH
27307: LD_INT 3
27309: PUSH
27310: LD_INT 5
27312: PUSH
27313: EMPTY
27314: LIST
27315: LIST
27316: LIST
27317: LIST
27318: ST_TO_ADDR
// for i in tmp do
27319: LD_ADDR_VAR 0 8
27323: PUSH
27324: LD_VAR 0 14
27328: PUSH
27329: FOR_IN
27330: IFFALSE 27500
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
27332: LD_ADDR_VAR 0 9
27336: PUSH
27337: LD_VAR 0 10
27341: PPUSH
27342: LD_VAR 0 8
27346: PPUSH
27347: LD_INT 5
27349: PPUSH
27350: CALL_OW 272
27354: PUSH
27355: LD_VAR 0 11
27359: PPUSH
27360: LD_VAR 0 8
27364: PPUSH
27365: LD_INT 5
27367: PPUSH
27368: CALL_OW 273
27372: PUSH
27373: EMPTY
27374: LIST
27375: LIST
27376: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27377: LD_VAR 0 9
27381: PUSH
27382: LD_INT 1
27384: ARRAY
27385: PPUSH
27386: LD_VAR 0 9
27390: PUSH
27391: LD_INT 2
27393: ARRAY
27394: PPUSH
27395: CALL_OW 488
27399: IFFALSE 27498
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27401: LD_ADDR_VAR 0 4
27405: PUSH
27406: LD_VAR 0 9
27410: PUSH
27411: LD_INT 1
27413: ARRAY
27414: PPUSH
27415: LD_VAR 0 9
27419: PUSH
27420: LD_INT 2
27422: ARRAY
27423: PPUSH
27424: CALL_OW 546
27428: ST_TO_ADDR
// if hex [ 1 ] then
27429: LD_VAR 0 4
27433: PUSH
27434: LD_INT 1
27436: ARRAY
27437: IFFALSE 27441
// continue ;
27439: GO 27329
// h := hex [ 2 ] ;
27441: LD_ADDR_VAR 0 13
27445: PUSH
27446: LD_VAR 0 4
27450: PUSH
27451: LD_INT 2
27453: ARRAY
27454: ST_TO_ADDR
// if h + 7 < height then
27455: LD_VAR 0 13
27459: PUSH
27460: LD_INT 7
27462: PLUS
27463: PUSH
27464: LD_VAR 0 15
27468: LESS
27469: IFFALSE 27498
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27471: LD_ADDR_VAR 0 18
27475: PUSH
27476: LD_INT 7
27478: PUSH
27479: LD_INT 28
27481: PUSH
27482: LD_INT 45
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: LIST
27489: PUSH
27490: LD_VAR 0 12
27494: ARRAY
27495: ST_TO_ADDR
// break ;
27496: GO 27500
// end ; end ; end ;
27498: GO 27329
27500: POP
27501: POP
// end ; if not weapon then
27502: LD_VAR 0 18
27506: NOT
27507: IFFALSE 27567
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27509: LD_ADDR_VAR 0 5
27513: PUSH
27514: LD_VAR 0 5
27518: PUSH
27519: LD_INT 11
27521: PUSH
27522: LD_INT 30
27524: PUSH
27525: LD_INT 49
27527: PUSH
27528: EMPTY
27529: LIST
27530: LIST
27531: LIST
27532: DIFF
27533: ST_TO_ADDR
// if not list then
27534: LD_VAR 0 5
27538: NOT
27539: IFFALSE 27543
// exit ;
27541: GO 27685
// weapon := list [ rand ( 1 , list ) ] ;
27543: LD_ADDR_VAR 0 18
27547: PUSH
27548: LD_VAR 0 5
27552: PUSH
27553: LD_INT 1
27555: PPUSH
27556: LD_VAR 0 5
27560: PPUSH
27561: CALL_OW 12
27565: ARRAY
27566: ST_TO_ADDR
// end ; if weapon then
27567: LD_VAR 0 18
27571: IFFALSE 27685
// begin tmp := CostOfWeapon ( weapon ) ;
27573: LD_ADDR_VAR 0 14
27577: PUSH
27578: LD_VAR 0 18
27582: PPUSH
27583: CALL_OW 451
27587: ST_TO_ADDR
// j := GetBase ( tower ) ;
27588: LD_ADDR_VAR 0 9
27592: PUSH
27593: LD_VAR 0 1
27597: PPUSH
27598: CALL_OW 274
27602: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27603: LD_VAR 0 9
27607: PPUSH
27608: LD_INT 1
27610: PPUSH
27611: CALL_OW 275
27615: PUSH
27616: LD_VAR 0 14
27620: PUSH
27621: LD_INT 1
27623: ARRAY
27624: GREATEREQUAL
27625: PUSH
27626: LD_VAR 0 9
27630: PPUSH
27631: LD_INT 2
27633: PPUSH
27634: CALL_OW 275
27638: PUSH
27639: LD_VAR 0 14
27643: PUSH
27644: LD_INT 2
27646: ARRAY
27647: GREATEREQUAL
27648: AND
27649: PUSH
27650: LD_VAR 0 9
27654: PPUSH
27655: LD_INT 3
27657: PPUSH
27658: CALL_OW 275
27662: PUSH
27663: LD_VAR 0 14
27667: PUSH
27668: LD_INT 3
27670: ARRAY
27671: GREATEREQUAL
27672: AND
27673: IFFALSE 27685
// result := weapon ;
27675: LD_ADDR_VAR 0 3
27679: PUSH
27680: LD_VAR 0 18
27684: ST_TO_ADDR
// end ; end ;
27685: LD_VAR 0 3
27689: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27690: LD_INT 0
27692: PPUSH
27693: PPUSH
// result := true ;
27694: LD_ADDR_VAR 0 3
27698: PUSH
27699: LD_INT 1
27701: ST_TO_ADDR
// if array1 = array2 then
27702: LD_VAR 0 1
27706: PUSH
27707: LD_VAR 0 2
27711: EQUAL
27712: IFFALSE 27772
// begin for i = 1 to array1 do
27714: LD_ADDR_VAR 0 4
27718: PUSH
27719: DOUBLE
27720: LD_INT 1
27722: DEC
27723: ST_TO_ADDR
27724: LD_VAR 0 1
27728: PUSH
27729: FOR_TO
27730: IFFALSE 27768
// if array1 [ i ] <> array2 [ i ] then
27732: LD_VAR 0 1
27736: PUSH
27737: LD_VAR 0 4
27741: ARRAY
27742: PUSH
27743: LD_VAR 0 2
27747: PUSH
27748: LD_VAR 0 4
27752: ARRAY
27753: NONEQUAL
27754: IFFALSE 27766
// begin result := false ;
27756: LD_ADDR_VAR 0 3
27760: PUSH
27761: LD_INT 0
27763: ST_TO_ADDR
// break ;
27764: GO 27768
// end ;
27766: GO 27729
27768: POP
27769: POP
// end else
27770: GO 27780
// result := false ;
27772: LD_ADDR_VAR 0 3
27776: PUSH
27777: LD_INT 0
27779: ST_TO_ADDR
// end ;
27780: LD_VAR 0 3
27784: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
27785: LD_INT 0
27787: PPUSH
27788: PPUSH
27789: PPUSH
// pom := GetBase ( fac ) ;
27790: LD_ADDR_VAR 0 5
27794: PUSH
27795: LD_VAR 0 1
27799: PPUSH
27800: CALL_OW 274
27804: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
27805: LD_ADDR_VAR 0 4
27809: PUSH
27810: LD_VAR 0 2
27814: PUSH
27815: LD_INT 1
27817: ARRAY
27818: PPUSH
27819: LD_VAR 0 2
27823: PUSH
27824: LD_INT 2
27826: ARRAY
27827: PPUSH
27828: LD_VAR 0 2
27832: PUSH
27833: LD_INT 3
27835: ARRAY
27836: PPUSH
27837: LD_VAR 0 2
27841: PUSH
27842: LD_INT 4
27844: ARRAY
27845: PPUSH
27846: CALL_OW 449
27850: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27851: LD_ADDR_VAR 0 3
27855: PUSH
27856: LD_VAR 0 5
27860: PPUSH
27861: LD_INT 1
27863: PPUSH
27864: CALL_OW 275
27868: PUSH
27869: LD_VAR 0 4
27873: PUSH
27874: LD_INT 1
27876: ARRAY
27877: GREATEREQUAL
27878: PUSH
27879: LD_VAR 0 5
27883: PPUSH
27884: LD_INT 2
27886: PPUSH
27887: CALL_OW 275
27891: PUSH
27892: LD_VAR 0 4
27896: PUSH
27897: LD_INT 2
27899: ARRAY
27900: GREATEREQUAL
27901: AND
27902: PUSH
27903: LD_VAR 0 5
27907: PPUSH
27908: LD_INT 3
27910: PPUSH
27911: CALL_OW 275
27915: PUSH
27916: LD_VAR 0 4
27920: PUSH
27921: LD_INT 3
27923: ARRAY
27924: GREATEREQUAL
27925: AND
27926: ST_TO_ADDR
// end ;
27927: LD_VAR 0 3
27931: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27932: LD_INT 0
27934: PPUSH
27935: PPUSH
27936: PPUSH
27937: PPUSH
// pom := GetBase ( building ) ;
27938: LD_ADDR_VAR 0 3
27942: PUSH
27943: LD_VAR 0 1
27947: PPUSH
27948: CALL_OW 274
27952: ST_TO_ADDR
// if not pom then
27953: LD_VAR 0 3
27957: NOT
27958: IFFALSE 27962
// exit ;
27960: GO 28132
// btype := GetBType ( building ) ;
27962: LD_ADDR_VAR 0 5
27966: PUSH
27967: LD_VAR 0 1
27971: PPUSH
27972: CALL_OW 266
27976: ST_TO_ADDR
// if btype = b_armoury then
27977: LD_VAR 0 5
27981: PUSH
27982: LD_INT 4
27984: EQUAL
27985: IFFALSE 27995
// btype := b_barracks ;
27987: LD_ADDR_VAR 0 5
27991: PUSH
27992: LD_INT 5
27994: ST_TO_ADDR
// if btype = b_depot then
27995: LD_VAR 0 5
27999: PUSH
28000: LD_INT 0
28002: EQUAL
28003: IFFALSE 28013
// btype := b_warehouse ;
28005: LD_ADDR_VAR 0 5
28009: PUSH
28010: LD_INT 1
28012: ST_TO_ADDR
// if btype = b_workshop then
28013: LD_VAR 0 5
28017: PUSH
28018: LD_INT 2
28020: EQUAL
28021: IFFALSE 28031
// btype := b_factory ;
28023: LD_ADDR_VAR 0 5
28027: PUSH
28028: LD_INT 3
28030: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28031: LD_ADDR_VAR 0 4
28035: PUSH
28036: LD_VAR 0 5
28040: PPUSH
28041: LD_VAR 0 1
28045: PPUSH
28046: CALL_OW 248
28050: PPUSH
28051: CALL_OW 450
28055: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28056: LD_ADDR_VAR 0 2
28060: PUSH
28061: LD_VAR 0 3
28065: PPUSH
28066: LD_INT 1
28068: PPUSH
28069: CALL_OW 275
28073: PUSH
28074: LD_VAR 0 4
28078: PUSH
28079: LD_INT 1
28081: ARRAY
28082: GREATEREQUAL
28083: PUSH
28084: LD_VAR 0 3
28088: PPUSH
28089: LD_INT 2
28091: PPUSH
28092: CALL_OW 275
28096: PUSH
28097: LD_VAR 0 4
28101: PUSH
28102: LD_INT 2
28104: ARRAY
28105: GREATEREQUAL
28106: AND
28107: PUSH
28108: LD_VAR 0 3
28112: PPUSH
28113: LD_INT 3
28115: PPUSH
28116: CALL_OW 275
28120: PUSH
28121: LD_VAR 0 4
28125: PUSH
28126: LD_INT 3
28128: ARRAY
28129: GREATEREQUAL
28130: AND
28131: ST_TO_ADDR
// end ;
28132: LD_VAR 0 2
28136: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
28137: LD_INT 0
28139: PPUSH
28140: PPUSH
28141: PPUSH
// pom := GetBase ( building ) ;
28142: LD_ADDR_VAR 0 4
28146: PUSH
28147: LD_VAR 0 1
28151: PPUSH
28152: CALL_OW 274
28156: ST_TO_ADDR
// if not pom then
28157: LD_VAR 0 4
28161: NOT
28162: IFFALSE 28166
// exit ;
28164: GO 28267
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28166: LD_ADDR_VAR 0 5
28170: PUSH
28171: LD_VAR 0 2
28175: PPUSH
28176: LD_VAR 0 1
28180: PPUSH
28181: CALL_OW 248
28185: PPUSH
28186: CALL_OW 450
28190: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28191: LD_ADDR_VAR 0 3
28195: PUSH
28196: LD_VAR 0 4
28200: PPUSH
28201: LD_INT 1
28203: PPUSH
28204: CALL_OW 275
28208: PUSH
28209: LD_VAR 0 5
28213: PUSH
28214: LD_INT 1
28216: ARRAY
28217: GREATEREQUAL
28218: PUSH
28219: LD_VAR 0 4
28223: PPUSH
28224: LD_INT 2
28226: PPUSH
28227: CALL_OW 275
28231: PUSH
28232: LD_VAR 0 5
28236: PUSH
28237: LD_INT 2
28239: ARRAY
28240: GREATEREQUAL
28241: AND
28242: PUSH
28243: LD_VAR 0 4
28247: PPUSH
28248: LD_INT 3
28250: PPUSH
28251: CALL_OW 275
28255: PUSH
28256: LD_VAR 0 5
28260: PUSH
28261: LD_INT 3
28263: ARRAY
28264: GREATEREQUAL
28265: AND
28266: ST_TO_ADDR
// end ;
28267: LD_VAR 0 3
28271: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
28272: LD_INT 0
28274: PPUSH
28275: PPUSH
28276: PPUSH
28277: PPUSH
28278: PPUSH
28279: PPUSH
28280: PPUSH
28281: PPUSH
28282: PPUSH
28283: PPUSH
// result := false ;
28284: LD_ADDR_VAR 0 6
28288: PUSH
28289: LD_INT 0
28291: ST_TO_ADDR
// if not base or not btype or not x or not y then
28292: LD_VAR 0 1
28296: NOT
28297: PUSH
28298: LD_VAR 0 2
28302: NOT
28303: OR
28304: PUSH
28305: LD_VAR 0 3
28309: NOT
28310: OR
28311: PUSH
28312: LD_VAR 0 4
28316: NOT
28317: OR
28318: IFFALSE 28322
// exit ;
28320: GO 28931
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
28322: LD_ADDR_VAR 0 12
28326: PUSH
28327: LD_VAR 0 2
28331: PPUSH
28332: LD_VAR 0 3
28336: PPUSH
28337: LD_VAR 0 4
28341: PPUSH
28342: LD_VAR 0 5
28346: PPUSH
28347: LD_VAR 0 1
28351: PUSH
28352: LD_INT 1
28354: ARRAY
28355: PPUSH
28356: CALL_OW 248
28360: PPUSH
28361: LD_INT 0
28363: PPUSH
28364: CALL 29768 0 6
28368: ST_TO_ADDR
// if not hexes then
28369: LD_VAR 0 12
28373: NOT
28374: IFFALSE 28378
// exit ;
28376: GO 28931
// for i = 1 to hexes do
28378: LD_ADDR_VAR 0 7
28382: PUSH
28383: DOUBLE
28384: LD_INT 1
28386: DEC
28387: ST_TO_ADDR
28388: LD_VAR 0 12
28392: PUSH
28393: FOR_TO
28394: IFFALSE 28929
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28396: LD_ADDR_VAR 0 11
28400: PUSH
28401: LD_VAR 0 12
28405: PUSH
28406: LD_VAR 0 7
28410: ARRAY
28411: PUSH
28412: LD_INT 1
28414: ARRAY
28415: PPUSH
28416: LD_VAR 0 12
28420: PUSH
28421: LD_VAR 0 7
28425: ARRAY
28426: PUSH
28427: LD_INT 2
28429: ARRAY
28430: PPUSH
28431: CALL_OW 428
28435: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28436: LD_VAR 0 12
28440: PUSH
28441: LD_VAR 0 7
28445: ARRAY
28446: PUSH
28447: LD_INT 1
28449: ARRAY
28450: PPUSH
28451: LD_VAR 0 12
28455: PUSH
28456: LD_VAR 0 7
28460: ARRAY
28461: PUSH
28462: LD_INT 2
28464: ARRAY
28465: PPUSH
28466: CALL_OW 351
28470: PUSH
28471: LD_VAR 0 12
28475: PUSH
28476: LD_VAR 0 7
28480: ARRAY
28481: PUSH
28482: LD_INT 1
28484: ARRAY
28485: PPUSH
28486: LD_VAR 0 12
28490: PUSH
28491: LD_VAR 0 7
28495: ARRAY
28496: PUSH
28497: LD_INT 2
28499: ARRAY
28500: PPUSH
28501: CALL_OW 488
28505: NOT
28506: OR
28507: PUSH
28508: LD_VAR 0 11
28512: PPUSH
28513: CALL_OW 247
28517: PUSH
28518: LD_INT 3
28520: EQUAL
28521: OR
28522: IFFALSE 28528
// exit ;
28524: POP
28525: POP
28526: GO 28931
// if not tmp or not tmp in base then
28528: LD_VAR 0 11
28532: NOT
28533: PUSH
28534: LD_VAR 0 11
28538: PUSH
28539: LD_VAR 0 1
28543: IN
28544: NOT
28545: OR
28546: IFFALSE 28550
// continue ;
28548: GO 28393
// result := true ;
28550: LD_ADDR_VAR 0 6
28554: PUSH
28555: LD_INT 1
28557: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28558: LD_ADDR_VAR 0 15
28562: PUSH
28563: LD_VAR 0 1
28567: PPUSH
28568: LD_INT 22
28570: PUSH
28571: LD_VAR 0 11
28575: PPUSH
28576: CALL_OW 255
28580: PUSH
28581: EMPTY
28582: LIST
28583: LIST
28584: PUSH
28585: LD_INT 2
28587: PUSH
28588: LD_INT 30
28590: PUSH
28591: LD_INT 0
28593: PUSH
28594: EMPTY
28595: LIST
28596: LIST
28597: PUSH
28598: LD_INT 30
28600: PUSH
28601: LD_INT 1
28603: PUSH
28604: EMPTY
28605: LIST
28606: LIST
28607: PUSH
28608: EMPTY
28609: LIST
28610: LIST
28611: LIST
28612: PUSH
28613: EMPTY
28614: LIST
28615: LIST
28616: PPUSH
28617: CALL_OW 72
28621: ST_TO_ADDR
// if dep then
28622: LD_VAR 0 15
28626: IFFALSE 28762
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
28628: LD_ADDR_VAR 0 14
28632: PUSH
28633: LD_VAR 0 15
28637: PUSH
28638: LD_INT 1
28640: ARRAY
28641: PPUSH
28642: CALL_OW 250
28646: PPUSH
28647: LD_VAR 0 15
28651: PUSH
28652: LD_INT 1
28654: ARRAY
28655: PPUSH
28656: CALL_OW 254
28660: PPUSH
28661: LD_INT 5
28663: PPUSH
28664: CALL_OW 272
28668: PUSH
28669: LD_VAR 0 15
28673: PUSH
28674: LD_INT 1
28676: ARRAY
28677: PPUSH
28678: CALL_OW 251
28682: PPUSH
28683: LD_VAR 0 15
28687: PUSH
28688: LD_INT 1
28690: ARRAY
28691: PPUSH
28692: CALL_OW 254
28696: PPUSH
28697: LD_INT 5
28699: PPUSH
28700: CALL_OW 273
28704: PUSH
28705: EMPTY
28706: LIST
28707: LIST
28708: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
28709: LD_VAR 0 14
28713: PUSH
28714: LD_INT 1
28716: ARRAY
28717: PPUSH
28718: LD_VAR 0 14
28722: PUSH
28723: LD_INT 2
28725: ARRAY
28726: PPUSH
28727: CALL_OW 488
28731: IFFALSE 28762
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
28733: LD_VAR 0 11
28737: PPUSH
28738: LD_VAR 0 14
28742: PUSH
28743: LD_INT 1
28745: ARRAY
28746: PPUSH
28747: LD_VAR 0 14
28751: PUSH
28752: LD_INT 2
28754: ARRAY
28755: PPUSH
28756: CALL_OW 111
// continue ;
28760: GO 28393
// end ; end ; r := GetDir ( tmp ) ;
28762: LD_ADDR_VAR 0 13
28766: PUSH
28767: LD_VAR 0 11
28771: PPUSH
28772: CALL_OW 254
28776: ST_TO_ADDR
// if r = 5 then
28777: LD_VAR 0 13
28781: PUSH
28782: LD_INT 5
28784: EQUAL
28785: IFFALSE 28795
// r := 0 ;
28787: LD_ADDR_VAR 0 13
28791: PUSH
28792: LD_INT 0
28794: ST_TO_ADDR
// for j = r to 5 do
28795: LD_ADDR_VAR 0 8
28799: PUSH
28800: DOUBLE
28801: LD_VAR 0 13
28805: DEC
28806: ST_TO_ADDR
28807: LD_INT 5
28809: PUSH
28810: FOR_TO
28811: IFFALSE 28925
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28813: LD_ADDR_VAR 0 9
28817: PUSH
28818: LD_VAR 0 11
28822: PPUSH
28823: CALL_OW 250
28827: PPUSH
28828: LD_VAR 0 8
28832: PPUSH
28833: LD_INT 2
28835: PPUSH
28836: CALL_OW 272
28840: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28841: LD_ADDR_VAR 0 10
28845: PUSH
28846: LD_VAR 0 11
28850: PPUSH
28851: CALL_OW 251
28855: PPUSH
28856: LD_VAR 0 8
28860: PPUSH
28861: LD_INT 2
28863: PPUSH
28864: CALL_OW 273
28868: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28869: LD_VAR 0 9
28873: PPUSH
28874: LD_VAR 0 10
28878: PPUSH
28879: CALL_OW 488
28883: PUSH
28884: LD_VAR 0 9
28888: PPUSH
28889: LD_VAR 0 10
28893: PPUSH
28894: CALL_OW 428
28898: NOT
28899: AND
28900: IFFALSE 28923
// begin ComMoveXY ( tmp , _x , _y ) ;
28902: LD_VAR 0 11
28906: PPUSH
28907: LD_VAR 0 9
28911: PPUSH
28912: LD_VAR 0 10
28916: PPUSH
28917: CALL_OW 111
// break ;
28921: GO 28925
// end ; end ;
28923: GO 28810
28925: POP
28926: POP
// end ;
28927: GO 28393
28929: POP
28930: POP
// end ;
28931: LD_VAR 0 6
28935: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28936: LD_INT 0
28938: PPUSH
28939: PPUSH
28940: PPUSH
28941: PPUSH
28942: PPUSH
28943: PPUSH
28944: PPUSH
28945: PPUSH
28946: PPUSH
28947: PPUSH
// result := false ;
28948: LD_ADDR_VAR 0 6
28952: PUSH
28953: LD_INT 0
28955: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28956: LD_VAR 0 1
28960: NOT
28961: PUSH
28962: LD_VAR 0 1
28966: PPUSH
28967: CALL_OW 266
28971: PUSH
28972: LD_INT 0
28974: PUSH
28975: LD_INT 1
28977: PUSH
28978: EMPTY
28979: LIST
28980: LIST
28981: IN
28982: NOT
28983: OR
28984: PUSH
28985: LD_VAR 0 2
28989: NOT
28990: OR
28991: PUSH
28992: LD_VAR 0 5
28996: PUSH
28997: LD_INT 0
28999: PUSH
29000: LD_INT 1
29002: PUSH
29003: LD_INT 2
29005: PUSH
29006: LD_INT 3
29008: PUSH
29009: LD_INT 4
29011: PUSH
29012: LD_INT 5
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: IN
29023: NOT
29024: OR
29025: PUSH
29026: LD_VAR 0 3
29030: PPUSH
29031: LD_VAR 0 4
29035: PPUSH
29036: CALL_OW 488
29040: NOT
29041: OR
29042: IFFALSE 29046
// exit ;
29044: GO 29763
// pom := GetBase ( depot ) ;
29046: LD_ADDR_VAR 0 10
29050: PUSH
29051: LD_VAR 0 1
29055: PPUSH
29056: CALL_OW 274
29060: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
29061: LD_ADDR_VAR 0 11
29065: PUSH
29066: LD_VAR 0 2
29070: PPUSH
29071: LD_VAR 0 1
29075: PPUSH
29076: CALL_OW 248
29080: PPUSH
29081: CALL_OW 450
29085: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
29086: LD_VAR 0 10
29090: PPUSH
29091: LD_INT 1
29093: PPUSH
29094: CALL_OW 275
29098: PUSH
29099: LD_VAR 0 11
29103: PUSH
29104: LD_INT 1
29106: ARRAY
29107: GREATEREQUAL
29108: PUSH
29109: LD_VAR 0 10
29113: PPUSH
29114: LD_INT 2
29116: PPUSH
29117: CALL_OW 275
29121: PUSH
29122: LD_VAR 0 11
29126: PUSH
29127: LD_INT 2
29129: ARRAY
29130: GREATEREQUAL
29131: AND
29132: PUSH
29133: LD_VAR 0 10
29137: PPUSH
29138: LD_INT 3
29140: PPUSH
29141: CALL_OW 275
29145: PUSH
29146: LD_VAR 0 11
29150: PUSH
29151: LD_INT 3
29153: ARRAY
29154: GREATEREQUAL
29155: AND
29156: NOT
29157: IFFALSE 29161
// exit ;
29159: GO 29763
// if GetBType ( depot ) = b_depot then
29161: LD_VAR 0 1
29165: PPUSH
29166: CALL_OW 266
29170: PUSH
29171: LD_INT 0
29173: EQUAL
29174: IFFALSE 29186
// dist := 28 else
29176: LD_ADDR_VAR 0 14
29180: PUSH
29181: LD_INT 28
29183: ST_TO_ADDR
29184: GO 29194
// dist := 36 ;
29186: LD_ADDR_VAR 0 14
29190: PUSH
29191: LD_INT 36
29193: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
29194: LD_VAR 0 1
29198: PPUSH
29199: LD_VAR 0 3
29203: PPUSH
29204: LD_VAR 0 4
29208: PPUSH
29209: CALL_OW 297
29213: PUSH
29214: LD_VAR 0 14
29218: GREATER
29219: IFFALSE 29223
// exit ;
29221: GO 29763
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
29223: LD_ADDR_VAR 0 12
29227: PUSH
29228: LD_VAR 0 2
29232: PPUSH
29233: LD_VAR 0 3
29237: PPUSH
29238: LD_VAR 0 4
29242: PPUSH
29243: LD_VAR 0 5
29247: PPUSH
29248: LD_VAR 0 1
29252: PPUSH
29253: CALL_OW 248
29257: PPUSH
29258: LD_INT 0
29260: PPUSH
29261: CALL 29768 0 6
29265: ST_TO_ADDR
// if not hexes then
29266: LD_VAR 0 12
29270: NOT
29271: IFFALSE 29275
// exit ;
29273: GO 29763
// hex := GetHexInfo ( x , y ) ;
29275: LD_ADDR_VAR 0 15
29279: PUSH
29280: LD_VAR 0 3
29284: PPUSH
29285: LD_VAR 0 4
29289: PPUSH
29290: CALL_OW 546
29294: ST_TO_ADDR
// if hex [ 1 ] then
29295: LD_VAR 0 15
29299: PUSH
29300: LD_INT 1
29302: ARRAY
29303: IFFALSE 29307
// exit ;
29305: GO 29763
// height := hex [ 2 ] ;
29307: LD_ADDR_VAR 0 13
29311: PUSH
29312: LD_VAR 0 15
29316: PUSH
29317: LD_INT 2
29319: ARRAY
29320: ST_TO_ADDR
// for i = 1 to hexes do
29321: LD_ADDR_VAR 0 7
29325: PUSH
29326: DOUBLE
29327: LD_INT 1
29329: DEC
29330: ST_TO_ADDR
29331: LD_VAR 0 12
29335: PUSH
29336: FOR_TO
29337: IFFALSE 29667
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
29339: LD_VAR 0 12
29343: PUSH
29344: LD_VAR 0 7
29348: ARRAY
29349: PUSH
29350: LD_INT 1
29352: ARRAY
29353: PPUSH
29354: LD_VAR 0 12
29358: PUSH
29359: LD_VAR 0 7
29363: ARRAY
29364: PUSH
29365: LD_INT 2
29367: ARRAY
29368: PPUSH
29369: CALL_OW 488
29373: NOT
29374: PUSH
29375: LD_VAR 0 12
29379: PUSH
29380: LD_VAR 0 7
29384: ARRAY
29385: PUSH
29386: LD_INT 1
29388: ARRAY
29389: PPUSH
29390: LD_VAR 0 12
29394: PUSH
29395: LD_VAR 0 7
29399: ARRAY
29400: PUSH
29401: LD_INT 2
29403: ARRAY
29404: PPUSH
29405: CALL_OW 428
29409: PUSH
29410: LD_INT 0
29412: GREATER
29413: OR
29414: PUSH
29415: LD_VAR 0 12
29419: PUSH
29420: LD_VAR 0 7
29424: ARRAY
29425: PUSH
29426: LD_INT 1
29428: ARRAY
29429: PPUSH
29430: LD_VAR 0 12
29434: PUSH
29435: LD_VAR 0 7
29439: ARRAY
29440: PUSH
29441: LD_INT 2
29443: ARRAY
29444: PPUSH
29445: CALL_OW 351
29449: OR
29450: IFFALSE 29456
// exit ;
29452: POP
29453: POP
29454: GO 29763
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29456: LD_ADDR_VAR 0 8
29460: PUSH
29461: LD_VAR 0 12
29465: PUSH
29466: LD_VAR 0 7
29470: ARRAY
29471: PUSH
29472: LD_INT 1
29474: ARRAY
29475: PPUSH
29476: LD_VAR 0 12
29480: PUSH
29481: LD_VAR 0 7
29485: ARRAY
29486: PUSH
29487: LD_INT 2
29489: ARRAY
29490: PPUSH
29491: CALL_OW 546
29495: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
29496: LD_VAR 0 8
29500: PUSH
29501: LD_INT 1
29503: ARRAY
29504: PUSH
29505: LD_VAR 0 8
29509: PUSH
29510: LD_INT 2
29512: ARRAY
29513: PUSH
29514: LD_VAR 0 13
29518: PUSH
29519: LD_INT 2
29521: PLUS
29522: GREATER
29523: OR
29524: PUSH
29525: LD_VAR 0 8
29529: PUSH
29530: LD_INT 2
29532: ARRAY
29533: PUSH
29534: LD_VAR 0 13
29538: PUSH
29539: LD_INT 2
29541: MINUS
29542: LESS
29543: OR
29544: PUSH
29545: LD_VAR 0 8
29549: PUSH
29550: LD_INT 3
29552: ARRAY
29553: PUSH
29554: LD_INT 0
29556: PUSH
29557: LD_INT 8
29559: PUSH
29560: LD_INT 9
29562: PUSH
29563: LD_INT 10
29565: PUSH
29566: LD_INT 11
29568: PUSH
29569: LD_INT 12
29571: PUSH
29572: LD_INT 13
29574: PUSH
29575: LD_INT 16
29577: PUSH
29578: LD_INT 17
29580: PUSH
29581: LD_INT 18
29583: PUSH
29584: LD_INT 19
29586: PUSH
29587: LD_INT 20
29589: PUSH
29590: LD_INT 21
29592: PUSH
29593: EMPTY
29594: LIST
29595: LIST
29596: LIST
29597: LIST
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: IN
29608: NOT
29609: OR
29610: PUSH
29611: LD_VAR 0 8
29615: PUSH
29616: LD_INT 5
29618: ARRAY
29619: NOT
29620: OR
29621: PUSH
29622: LD_VAR 0 8
29626: PUSH
29627: LD_INT 6
29629: ARRAY
29630: PUSH
29631: LD_INT 1
29633: PUSH
29634: LD_INT 2
29636: PUSH
29637: LD_INT 7
29639: PUSH
29640: LD_INT 9
29642: PUSH
29643: LD_INT 10
29645: PUSH
29646: LD_INT 11
29648: PUSH
29649: EMPTY
29650: LIST
29651: LIST
29652: LIST
29653: LIST
29654: LIST
29655: LIST
29656: IN
29657: NOT
29658: OR
29659: IFFALSE 29665
// exit ;
29661: POP
29662: POP
29663: GO 29763
// end ;
29665: GO 29336
29667: POP
29668: POP
// side := GetSide ( depot ) ;
29669: LD_ADDR_VAR 0 9
29673: PUSH
29674: LD_VAR 0 1
29678: PPUSH
29679: CALL_OW 255
29683: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29684: LD_VAR 0 9
29688: PPUSH
29689: LD_VAR 0 3
29693: PPUSH
29694: LD_VAR 0 4
29698: PPUSH
29699: LD_INT 20
29701: PPUSH
29702: CALL 22417 0 4
29706: PUSH
29707: LD_INT 4
29709: ARRAY
29710: IFFALSE 29714
// exit ;
29712: GO 29763
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29714: LD_VAR 0 2
29718: PUSH
29719: LD_INT 29
29721: PUSH
29722: LD_INT 30
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: IN
29729: PUSH
29730: LD_VAR 0 3
29734: PPUSH
29735: LD_VAR 0 4
29739: PPUSH
29740: LD_VAR 0 9
29744: PPUSH
29745: CALL_OW 440
29749: NOT
29750: AND
29751: IFFALSE 29755
// exit ;
29753: GO 29763
// result := true ;
29755: LD_ADDR_VAR 0 6
29759: PUSH
29760: LD_INT 1
29762: ST_TO_ADDR
// end ;
29763: LD_VAR 0 6
29767: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
29768: LD_INT 0
29770: PPUSH
29771: PPUSH
29772: PPUSH
29773: PPUSH
29774: PPUSH
29775: PPUSH
29776: PPUSH
29777: PPUSH
29778: PPUSH
29779: PPUSH
29780: PPUSH
29781: PPUSH
29782: PPUSH
29783: PPUSH
29784: PPUSH
29785: PPUSH
29786: PPUSH
29787: PPUSH
29788: PPUSH
29789: PPUSH
29790: PPUSH
29791: PPUSH
29792: PPUSH
29793: PPUSH
29794: PPUSH
29795: PPUSH
29796: PPUSH
29797: PPUSH
29798: PPUSH
29799: PPUSH
29800: PPUSH
29801: PPUSH
29802: PPUSH
29803: PPUSH
29804: PPUSH
29805: PPUSH
29806: PPUSH
29807: PPUSH
29808: PPUSH
29809: PPUSH
29810: PPUSH
29811: PPUSH
29812: PPUSH
29813: PPUSH
29814: PPUSH
29815: PPUSH
29816: PPUSH
29817: PPUSH
29818: PPUSH
29819: PPUSH
29820: PPUSH
29821: PPUSH
29822: PPUSH
29823: PPUSH
29824: PPUSH
29825: PPUSH
29826: PPUSH
29827: PPUSH
// result = [ ] ;
29828: LD_ADDR_VAR 0 7
29832: PUSH
29833: EMPTY
29834: ST_TO_ADDR
// temp_list = [ ] ;
29835: LD_ADDR_VAR 0 9
29839: PUSH
29840: EMPTY
29841: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29842: LD_VAR 0 4
29846: PUSH
29847: LD_INT 0
29849: PUSH
29850: LD_INT 1
29852: PUSH
29853: LD_INT 2
29855: PUSH
29856: LD_INT 3
29858: PUSH
29859: LD_INT 4
29861: PUSH
29862: LD_INT 5
29864: PUSH
29865: EMPTY
29866: LIST
29867: LIST
29868: LIST
29869: LIST
29870: LIST
29871: LIST
29872: IN
29873: NOT
29874: PUSH
29875: LD_VAR 0 1
29879: PUSH
29880: LD_INT 0
29882: PUSH
29883: LD_INT 1
29885: PUSH
29886: EMPTY
29887: LIST
29888: LIST
29889: IN
29890: PUSH
29891: LD_VAR 0 5
29895: PUSH
29896: LD_INT 1
29898: PUSH
29899: LD_INT 2
29901: PUSH
29902: LD_INT 3
29904: PUSH
29905: EMPTY
29906: LIST
29907: LIST
29908: LIST
29909: IN
29910: NOT
29911: AND
29912: OR
29913: IFFALSE 29917
// exit ;
29915: GO 48308
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29917: LD_VAR 0 1
29921: PUSH
29922: LD_INT 6
29924: PUSH
29925: LD_INT 7
29927: PUSH
29928: LD_INT 8
29930: PUSH
29931: LD_INT 13
29933: PUSH
29934: LD_INT 12
29936: PUSH
29937: LD_INT 15
29939: PUSH
29940: LD_INT 11
29942: PUSH
29943: LD_INT 14
29945: PUSH
29946: LD_INT 10
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: LIST
29953: LIST
29954: LIST
29955: LIST
29956: LIST
29957: LIST
29958: LIST
29959: IN
29960: IFFALSE 29970
// btype = b_lab ;
29962: LD_ADDR_VAR 0 1
29966: PUSH
29967: LD_INT 6
29969: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29970: LD_VAR 0 6
29974: PUSH
29975: LD_INT 0
29977: PUSH
29978: LD_INT 1
29980: PUSH
29981: LD_INT 2
29983: PUSH
29984: EMPTY
29985: LIST
29986: LIST
29987: LIST
29988: IN
29989: NOT
29990: PUSH
29991: LD_VAR 0 1
29995: PUSH
29996: LD_INT 0
29998: PUSH
29999: LD_INT 1
30001: PUSH
30002: LD_INT 2
30004: PUSH
30005: LD_INT 3
30007: PUSH
30008: LD_INT 6
30010: PUSH
30011: LD_INT 36
30013: PUSH
30014: LD_INT 4
30016: PUSH
30017: LD_INT 5
30019: PUSH
30020: LD_INT 31
30022: PUSH
30023: LD_INT 32
30025: PUSH
30026: LD_INT 33
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: LIST
30033: LIST
30034: LIST
30035: LIST
30036: LIST
30037: LIST
30038: LIST
30039: LIST
30040: LIST
30041: IN
30042: NOT
30043: PUSH
30044: LD_VAR 0 6
30048: PUSH
30049: LD_INT 1
30051: EQUAL
30052: AND
30053: OR
30054: PUSH
30055: LD_VAR 0 1
30059: PUSH
30060: LD_INT 2
30062: PUSH
30063: LD_INT 3
30065: PUSH
30066: EMPTY
30067: LIST
30068: LIST
30069: IN
30070: NOT
30071: PUSH
30072: LD_VAR 0 6
30076: PUSH
30077: LD_INT 2
30079: EQUAL
30080: AND
30081: OR
30082: IFFALSE 30092
// mode = 0 ;
30084: LD_ADDR_VAR 0 6
30088: PUSH
30089: LD_INT 0
30091: ST_TO_ADDR
// case mode of 0 :
30092: LD_VAR 0 6
30096: PUSH
30097: LD_INT 0
30099: DOUBLE
30100: EQUAL
30101: IFTRUE 30105
30103: GO 41558
30105: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
30106: LD_ADDR_VAR 0 11
30110: PUSH
30111: LD_INT 0
30113: PUSH
30114: LD_INT 0
30116: PUSH
30117: EMPTY
30118: LIST
30119: LIST
30120: PUSH
30121: LD_INT 0
30123: PUSH
30124: LD_INT 1
30126: NEG
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PUSH
30132: LD_INT 1
30134: PUSH
30135: LD_INT 0
30137: PUSH
30138: EMPTY
30139: LIST
30140: LIST
30141: PUSH
30142: LD_INT 1
30144: PUSH
30145: LD_INT 1
30147: PUSH
30148: EMPTY
30149: LIST
30150: LIST
30151: PUSH
30152: LD_INT 0
30154: PUSH
30155: LD_INT 1
30157: PUSH
30158: EMPTY
30159: LIST
30160: LIST
30161: PUSH
30162: LD_INT 1
30164: NEG
30165: PUSH
30166: LD_INT 0
30168: PUSH
30169: EMPTY
30170: LIST
30171: LIST
30172: PUSH
30173: LD_INT 1
30175: NEG
30176: PUSH
30177: LD_INT 1
30179: NEG
30180: PUSH
30181: EMPTY
30182: LIST
30183: LIST
30184: PUSH
30185: LD_INT 1
30187: NEG
30188: PUSH
30189: LD_INT 2
30191: NEG
30192: PUSH
30193: EMPTY
30194: LIST
30195: LIST
30196: PUSH
30197: LD_INT 0
30199: PUSH
30200: LD_INT 2
30202: NEG
30203: PUSH
30204: EMPTY
30205: LIST
30206: LIST
30207: PUSH
30208: LD_INT 1
30210: PUSH
30211: LD_INT 1
30213: NEG
30214: PUSH
30215: EMPTY
30216: LIST
30217: LIST
30218: PUSH
30219: LD_INT 1
30221: PUSH
30222: LD_INT 2
30224: PUSH
30225: EMPTY
30226: LIST
30227: LIST
30228: PUSH
30229: LD_INT 0
30231: PUSH
30232: LD_INT 2
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PUSH
30239: LD_INT 1
30241: NEG
30242: PUSH
30243: LD_INT 1
30245: PUSH
30246: EMPTY
30247: LIST
30248: LIST
30249: PUSH
30250: LD_INT 1
30252: PUSH
30253: LD_INT 3
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PUSH
30260: LD_INT 0
30262: PUSH
30263: LD_INT 3
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 1
30272: NEG
30273: PUSH
30274: LD_INT 2
30276: PUSH
30277: EMPTY
30278: LIST
30279: LIST
30280: PUSH
30281: EMPTY
30282: LIST
30283: LIST
30284: LIST
30285: LIST
30286: LIST
30287: LIST
30288: LIST
30289: LIST
30290: LIST
30291: LIST
30292: LIST
30293: LIST
30294: LIST
30295: LIST
30296: LIST
30297: LIST
30298: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30299: LD_ADDR_VAR 0 12
30303: PUSH
30304: LD_INT 0
30306: PUSH
30307: LD_INT 0
30309: PUSH
30310: EMPTY
30311: LIST
30312: LIST
30313: PUSH
30314: LD_INT 0
30316: PUSH
30317: LD_INT 1
30319: NEG
30320: PUSH
30321: EMPTY
30322: LIST
30323: LIST
30324: PUSH
30325: LD_INT 1
30327: PUSH
30328: LD_INT 0
30330: PUSH
30331: EMPTY
30332: LIST
30333: LIST
30334: PUSH
30335: LD_INT 1
30337: PUSH
30338: LD_INT 1
30340: PUSH
30341: EMPTY
30342: LIST
30343: LIST
30344: PUSH
30345: LD_INT 0
30347: PUSH
30348: LD_INT 1
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: PUSH
30355: LD_INT 1
30357: NEG
30358: PUSH
30359: LD_INT 0
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: LD_INT 1
30368: NEG
30369: PUSH
30370: LD_INT 1
30372: NEG
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: PUSH
30378: LD_INT 1
30380: PUSH
30381: LD_INT 1
30383: NEG
30384: PUSH
30385: EMPTY
30386: LIST
30387: LIST
30388: PUSH
30389: LD_INT 2
30391: PUSH
30392: LD_INT 0
30394: PUSH
30395: EMPTY
30396: LIST
30397: LIST
30398: PUSH
30399: LD_INT 2
30401: PUSH
30402: LD_INT 1
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: LD_INT 1
30411: NEG
30412: PUSH
30413: LD_INT 1
30415: PUSH
30416: EMPTY
30417: LIST
30418: LIST
30419: PUSH
30420: LD_INT 2
30422: NEG
30423: PUSH
30424: LD_INT 0
30426: PUSH
30427: EMPTY
30428: LIST
30429: LIST
30430: PUSH
30431: LD_INT 2
30433: NEG
30434: PUSH
30435: LD_INT 1
30437: NEG
30438: PUSH
30439: EMPTY
30440: LIST
30441: LIST
30442: PUSH
30443: LD_INT 2
30445: NEG
30446: PUSH
30447: LD_INT 1
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: PUSH
30454: LD_INT 3
30456: NEG
30457: PUSH
30458: LD_INT 0
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 3
30467: NEG
30468: PUSH
30469: LD_INT 1
30471: NEG
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: LIST
30481: LIST
30482: LIST
30483: LIST
30484: LIST
30485: LIST
30486: LIST
30487: LIST
30488: LIST
30489: LIST
30490: LIST
30491: LIST
30492: LIST
30493: LIST
30494: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30495: LD_ADDR_VAR 0 13
30499: PUSH
30500: LD_INT 0
30502: PUSH
30503: LD_INT 0
30505: PUSH
30506: EMPTY
30507: LIST
30508: LIST
30509: PUSH
30510: LD_INT 0
30512: PUSH
30513: LD_INT 1
30515: NEG
30516: PUSH
30517: EMPTY
30518: LIST
30519: LIST
30520: PUSH
30521: LD_INT 1
30523: PUSH
30524: LD_INT 0
30526: PUSH
30527: EMPTY
30528: LIST
30529: LIST
30530: PUSH
30531: LD_INT 1
30533: PUSH
30534: LD_INT 1
30536: PUSH
30537: EMPTY
30538: LIST
30539: LIST
30540: PUSH
30541: LD_INT 0
30543: PUSH
30544: LD_INT 1
30546: PUSH
30547: EMPTY
30548: LIST
30549: LIST
30550: PUSH
30551: LD_INT 1
30553: NEG
30554: PUSH
30555: LD_INT 0
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PUSH
30562: LD_INT 1
30564: NEG
30565: PUSH
30566: LD_INT 1
30568: NEG
30569: PUSH
30570: EMPTY
30571: LIST
30572: LIST
30573: PUSH
30574: LD_INT 1
30576: NEG
30577: PUSH
30578: LD_INT 2
30580: NEG
30581: PUSH
30582: EMPTY
30583: LIST
30584: LIST
30585: PUSH
30586: LD_INT 2
30588: PUSH
30589: LD_INT 1
30591: PUSH
30592: EMPTY
30593: LIST
30594: LIST
30595: PUSH
30596: LD_INT 2
30598: PUSH
30599: LD_INT 2
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 1
30608: PUSH
30609: LD_INT 2
30611: PUSH
30612: EMPTY
30613: LIST
30614: LIST
30615: PUSH
30616: LD_INT 2
30618: NEG
30619: PUSH
30620: LD_INT 1
30622: NEG
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: LD_INT 2
30630: NEG
30631: PUSH
30632: LD_INT 2
30634: NEG
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: PUSH
30640: LD_INT 2
30642: NEG
30643: PUSH
30644: LD_INT 3
30646: NEG
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 3
30654: NEG
30655: PUSH
30656: LD_INT 2
30658: NEG
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: LD_INT 3
30666: NEG
30667: PUSH
30668: LD_INT 3
30670: NEG
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: LIST
30680: LIST
30681: LIST
30682: LIST
30683: LIST
30684: LIST
30685: LIST
30686: LIST
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: LIST
30693: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30694: LD_ADDR_VAR 0 14
30698: PUSH
30699: LD_INT 0
30701: PUSH
30702: LD_INT 0
30704: PUSH
30705: EMPTY
30706: LIST
30707: LIST
30708: PUSH
30709: LD_INT 0
30711: PUSH
30712: LD_INT 1
30714: NEG
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: PUSH
30720: LD_INT 1
30722: PUSH
30723: LD_INT 0
30725: PUSH
30726: EMPTY
30727: LIST
30728: LIST
30729: PUSH
30730: LD_INT 1
30732: PUSH
30733: LD_INT 1
30735: PUSH
30736: EMPTY
30737: LIST
30738: LIST
30739: PUSH
30740: LD_INT 0
30742: PUSH
30743: LD_INT 1
30745: PUSH
30746: EMPTY
30747: LIST
30748: LIST
30749: PUSH
30750: LD_INT 1
30752: NEG
30753: PUSH
30754: LD_INT 0
30756: PUSH
30757: EMPTY
30758: LIST
30759: LIST
30760: PUSH
30761: LD_INT 1
30763: NEG
30764: PUSH
30765: LD_INT 1
30767: NEG
30768: PUSH
30769: EMPTY
30770: LIST
30771: LIST
30772: PUSH
30773: LD_INT 1
30775: NEG
30776: PUSH
30777: LD_INT 2
30779: NEG
30780: PUSH
30781: EMPTY
30782: LIST
30783: LIST
30784: PUSH
30785: LD_INT 0
30787: PUSH
30788: LD_INT 2
30790: NEG
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 1
30798: PUSH
30799: LD_INT 1
30801: NEG
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: PUSH
30807: LD_INT 1
30809: PUSH
30810: LD_INT 2
30812: PUSH
30813: EMPTY
30814: LIST
30815: LIST
30816: PUSH
30817: LD_INT 0
30819: PUSH
30820: LD_INT 2
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: LD_INT 1
30829: NEG
30830: PUSH
30831: LD_INT 1
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: LD_INT 1
30840: NEG
30841: PUSH
30842: LD_INT 3
30844: NEG
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 0
30852: PUSH
30853: LD_INT 3
30855: NEG
30856: PUSH
30857: EMPTY
30858: LIST
30859: LIST
30860: PUSH
30861: LD_INT 1
30863: PUSH
30864: LD_INT 2
30866: NEG
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: PUSH
30872: EMPTY
30873: LIST
30874: LIST
30875: LIST
30876: LIST
30877: LIST
30878: LIST
30879: LIST
30880: LIST
30881: LIST
30882: LIST
30883: LIST
30884: LIST
30885: LIST
30886: LIST
30887: LIST
30888: LIST
30889: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30890: LD_ADDR_VAR 0 15
30894: PUSH
30895: LD_INT 0
30897: PUSH
30898: LD_INT 0
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PUSH
30905: LD_INT 0
30907: PUSH
30908: LD_INT 1
30910: NEG
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: LD_INT 1
30918: PUSH
30919: LD_INT 0
30921: PUSH
30922: EMPTY
30923: LIST
30924: LIST
30925: PUSH
30926: LD_INT 1
30928: PUSH
30929: LD_INT 1
30931: PUSH
30932: EMPTY
30933: LIST
30934: LIST
30935: PUSH
30936: LD_INT 0
30938: PUSH
30939: LD_INT 1
30941: PUSH
30942: EMPTY
30943: LIST
30944: LIST
30945: PUSH
30946: LD_INT 1
30948: NEG
30949: PUSH
30950: LD_INT 0
30952: PUSH
30953: EMPTY
30954: LIST
30955: LIST
30956: PUSH
30957: LD_INT 1
30959: NEG
30960: PUSH
30961: LD_INT 1
30963: NEG
30964: PUSH
30965: EMPTY
30966: LIST
30967: LIST
30968: PUSH
30969: LD_INT 1
30971: PUSH
30972: LD_INT 1
30974: NEG
30975: PUSH
30976: EMPTY
30977: LIST
30978: LIST
30979: PUSH
30980: LD_INT 2
30982: PUSH
30983: LD_INT 0
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PUSH
30990: LD_INT 2
30992: PUSH
30993: LD_INT 1
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PUSH
31000: LD_INT 1
31002: NEG
31003: PUSH
31004: LD_INT 1
31006: PUSH
31007: EMPTY
31008: LIST
31009: LIST
31010: PUSH
31011: LD_INT 2
31013: NEG
31014: PUSH
31015: LD_INT 0
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: PUSH
31022: LD_INT 2
31024: NEG
31025: PUSH
31026: LD_INT 1
31028: NEG
31029: PUSH
31030: EMPTY
31031: LIST
31032: LIST
31033: PUSH
31034: LD_INT 2
31036: PUSH
31037: LD_INT 1
31039: NEG
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: PUSH
31045: LD_INT 3
31047: PUSH
31048: LD_INT 0
31050: PUSH
31051: EMPTY
31052: LIST
31053: LIST
31054: PUSH
31055: LD_INT 3
31057: PUSH
31058: LD_INT 1
31060: PUSH
31061: EMPTY
31062: LIST
31063: LIST
31064: PUSH
31065: EMPTY
31066: LIST
31067: LIST
31068: LIST
31069: LIST
31070: LIST
31071: LIST
31072: LIST
31073: LIST
31074: LIST
31075: LIST
31076: LIST
31077: LIST
31078: LIST
31079: LIST
31080: LIST
31081: LIST
31082: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
31083: LD_ADDR_VAR 0 16
31087: PUSH
31088: LD_INT 0
31090: PUSH
31091: LD_INT 0
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 0
31100: PUSH
31101: LD_INT 1
31103: NEG
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 1
31111: PUSH
31112: LD_INT 0
31114: PUSH
31115: EMPTY
31116: LIST
31117: LIST
31118: PUSH
31119: LD_INT 1
31121: PUSH
31122: LD_INT 1
31124: PUSH
31125: EMPTY
31126: LIST
31127: LIST
31128: PUSH
31129: LD_INT 0
31131: PUSH
31132: LD_INT 1
31134: PUSH
31135: EMPTY
31136: LIST
31137: LIST
31138: PUSH
31139: LD_INT 1
31141: NEG
31142: PUSH
31143: LD_INT 0
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: LD_INT 1
31152: NEG
31153: PUSH
31154: LD_INT 1
31156: NEG
31157: PUSH
31158: EMPTY
31159: LIST
31160: LIST
31161: PUSH
31162: LD_INT 1
31164: NEG
31165: PUSH
31166: LD_INT 2
31168: NEG
31169: PUSH
31170: EMPTY
31171: LIST
31172: LIST
31173: PUSH
31174: LD_INT 2
31176: PUSH
31177: LD_INT 1
31179: PUSH
31180: EMPTY
31181: LIST
31182: LIST
31183: PUSH
31184: LD_INT 2
31186: PUSH
31187: LD_INT 2
31189: PUSH
31190: EMPTY
31191: LIST
31192: LIST
31193: PUSH
31194: LD_INT 1
31196: PUSH
31197: LD_INT 2
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: LD_INT 2
31206: NEG
31207: PUSH
31208: LD_INT 1
31210: NEG
31211: PUSH
31212: EMPTY
31213: LIST
31214: LIST
31215: PUSH
31216: LD_INT 2
31218: NEG
31219: PUSH
31220: LD_INT 2
31222: NEG
31223: PUSH
31224: EMPTY
31225: LIST
31226: LIST
31227: PUSH
31228: LD_INT 3
31230: PUSH
31231: LD_INT 2
31233: PUSH
31234: EMPTY
31235: LIST
31236: LIST
31237: PUSH
31238: LD_INT 3
31240: PUSH
31241: LD_INT 3
31243: PUSH
31244: EMPTY
31245: LIST
31246: LIST
31247: PUSH
31248: LD_INT 2
31250: PUSH
31251: LD_INT 3
31253: PUSH
31254: EMPTY
31255: LIST
31256: LIST
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: LIST
31262: LIST
31263: LIST
31264: LIST
31265: LIST
31266: LIST
31267: LIST
31268: LIST
31269: LIST
31270: LIST
31271: LIST
31272: LIST
31273: LIST
31274: LIST
31275: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31276: LD_ADDR_VAR 0 17
31280: PUSH
31281: LD_INT 0
31283: PUSH
31284: LD_INT 0
31286: PUSH
31287: EMPTY
31288: LIST
31289: LIST
31290: PUSH
31291: LD_INT 0
31293: PUSH
31294: LD_INT 1
31296: NEG
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 1
31304: PUSH
31305: LD_INT 0
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 1
31314: PUSH
31315: LD_INT 1
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: PUSH
31322: LD_INT 0
31324: PUSH
31325: LD_INT 1
31327: PUSH
31328: EMPTY
31329: LIST
31330: LIST
31331: PUSH
31332: LD_INT 1
31334: NEG
31335: PUSH
31336: LD_INT 0
31338: PUSH
31339: EMPTY
31340: LIST
31341: LIST
31342: PUSH
31343: LD_INT 1
31345: NEG
31346: PUSH
31347: LD_INT 1
31349: NEG
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 1
31357: NEG
31358: PUSH
31359: LD_INT 2
31361: NEG
31362: PUSH
31363: EMPTY
31364: LIST
31365: LIST
31366: PUSH
31367: LD_INT 0
31369: PUSH
31370: LD_INT 2
31372: NEG
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PUSH
31378: LD_INT 1
31380: PUSH
31381: LD_INT 1
31383: NEG
31384: PUSH
31385: EMPTY
31386: LIST
31387: LIST
31388: PUSH
31389: LD_INT 2
31391: PUSH
31392: LD_INT 0
31394: PUSH
31395: EMPTY
31396: LIST
31397: LIST
31398: PUSH
31399: LD_INT 2
31401: PUSH
31402: LD_INT 1
31404: PUSH
31405: EMPTY
31406: LIST
31407: LIST
31408: PUSH
31409: LD_INT 2
31411: PUSH
31412: LD_INT 2
31414: PUSH
31415: EMPTY
31416: LIST
31417: LIST
31418: PUSH
31419: LD_INT 1
31421: PUSH
31422: LD_INT 2
31424: PUSH
31425: EMPTY
31426: LIST
31427: LIST
31428: PUSH
31429: LD_INT 0
31431: PUSH
31432: LD_INT 2
31434: PUSH
31435: EMPTY
31436: LIST
31437: LIST
31438: PUSH
31439: LD_INT 1
31441: NEG
31442: PUSH
31443: LD_INT 1
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: PUSH
31450: LD_INT 2
31452: NEG
31453: PUSH
31454: LD_INT 0
31456: PUSH
31457: EMPTY
31458: LIST
31459: LIST
31460: PUSH
31461: LD_INT 2
31463: NEG
31464: PUSH
31465: LD_INT 1
31467: NEG
31468: PUSH
31469: EMPTY
31470: LIST
31471: LIST
31472: PUSH
31473: LD_INT 2
31475: NEG
31476: PUSH
31477: LD_INT 2
31479: NEG
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PUSH
31485: EMPTY
31486: LIST
31487: LIST
31488: LIST
31489: LIST
31490: LIST
31491: LIST
31492: LIST
31493: LIST
31494: LIST
31495: LIST
31496: LIST
31497: LIST
31498: LIST
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31506: LD_ADDR_VAR 0 18
31510: PUSH
31511: LD_INT 0
31513: PUSH
31514: LD_INT 0
31516: PUSH
31517: EMPTY
31518: LIST
31519: LIST
31520: PUSH
31521: LD_INT 0
31523: PUSH
31524: LD_INT 1
31526: NEG
31527: PUSH
31528: EMPTY
31529: LIST
31530: LIST
31531: PUSH
31532: LD_INT 1
31534: PUSH
31535: LD_INT 0
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: PUSH
31542: LD_INT 1
31544: PUSH
31545: LD_INT 1
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: PUSH
31552: LD_INT 0
31554: PUSH
31555: LD_INT 1
31557: PUSH
31558: EMPTY
31559: LIST
31560: LIST
31561: PUSH
31562: LD_INT 1
31564: NEG
31565: PUSH
31566: LD_INT 0
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PUSH
31573: LD_INT 1
31575: NEG
31576: PUSH
31577: LD_INT 1
31579: NEG
31580: PUSH
31581: EMPTY
31582: LIST
31583: LIST
31584: PUSH
31585: LD_INT 1
31587: NEG
31588: PUSH
31589: LD_INT 2
31591: NEG
31592: PUSH
31593: EMPTY
31594: LIST
31595: LIST
31596: PUSH
31597: LD_INT 0
31599: PUSH
31600: LD_INT 2
31602: NEG
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 1
31610: PUSH
31611: LD_INT 1
31613: NEG
31614: PUSH
31615: EMPTY
31616: LIST
31617: LIST
31618: PUSH
31619: LD_INT 2
31621: PUSH
31622: LD_INT 0
31624: PUSH
31625: EMPTY
31626: LIST
31627: LIST
31628: PUSH
31629: LD_INT 2
31631: PUSH
31632: LD_INT 1
31634: PUSH
31635: EMPTY
31636: LIST
31637: LIST
31638: PUSH
31639: LD_INT 2
31641: PUSH
31642: LD_INT 2
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 1
31651: PUSH
31652: LD_INT 2
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: LD_INT 0
31661: PUSH
31662: LD_INT 2
31664: PUSH
31665: EMPTY
31666: LIST
31667: LIST
31668: PUSH
31669: LD_INT 1
31671: NEG
31672: PUSH
31673: LD_INT 1
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 2
31682: NEG
31683: PUSH
31684: LD_INT 0
31686: PUSH
31687: EMPTY
31688: LIST
31689: LIST
31690: PUSH
31691: LD_INT 2
31693: NEG
31694: PUSH
31695: LD_INT 1
31697: NEG
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: PUSH
31703: LD_INT 2
31705: NEG
31706: PUSH
31707: LD_INT 2
31709: NEG
31710: PUSH
31711: EMPTY
31712: LIST
31713: LIST
31714: PUSH
31715: EMPTY
31716: LIST
31717: LIST
31718: LIST
31719: LIST
31720: LIST
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: LIST
31733: LIST
31734: LIST
31735: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31736: LD_ADDR_VAR 0 19
31740: PUSH
31741: LD_INT 0
31743: PUSH
31744: LD_INT 0
31746: PUSH
31747: EMPTY
31748: LIST
31749: LIST
31750: PUSH
31751: LD_INT 0
31753: PUSH
31754: LD_INT 1
31756: NEG
31757: PUSH
31758: EMPTY
31759: LIST
31760: LIST
31761: PUSH
31762: LD_INT 1
31764: PUSH
31765: LD_INT 0
31767: PUSH
31768: EMPTY
31769: LIST
31770: LIST
31771: PUSH
31772: LD_INT 1
31774: PUSH
31775: LD_INT 1
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: PUSH
31782: LD_INT 0
31784: PUSH
31785: LD_INT 1
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: LD_INT 1
31794: NEG
31795: PUSH
31796: LD_INT 0
31798: PUSH
31799: EMPTY
31800: LIST
31801: LIST
31802: PUSH
31803: LD_INT 1
31805: NEG
31806: PUSH
31807: LD_INT 1
31809: NEG
31810: PUSH
31811: EMPTY
31812: LIST
31813: LIST
31814: PUSH
31815: LD_INT 1
31817: NEG
31818: PUSH
31819: LD_INT 2
31821: NEG
31822: PUSH
31823: EMPTY
31824: LIST
31825: LIST
31826: PUSH
31827: LD_INT 0
31829: PUSH
31830: LD_INT 2
31832: NEG
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: PUSH
31838: LD_INT 1
31840: PUSH
31841: LD_INT 1
31843: NEG
31844: PUSH
31845: EMPTY
31846: LIST
31847: LIST
31848: PUSH
31849: LD_INT 2
31851: PUSH
31852: LD_INT 0
31854: PUSH
31855: EMPTY
31856: LIST
31857: LIST
31858: PUSH
31859: LD_INT 2
31861: PUSH
31862: LD_INT 1
31864: PUSH
31865: EMPTY
31866: LIST
31867: LIST
31868: PUSH
31869: LD_INT 2
31871: PUSH
31872: LD_INT 2
31874: PUSH
31875: EMPTY
31876: LIST
31877: LIST
31878: PUSH
31879: LD_INT 1
31881: PUSH
31882: LD_INT 2
31884: PUSH
31885: EMPTY
31886: LIST
31887: LIST
31888: PUSH
31889: LD_INT 0
31891: PUSH
31892: LD_INT 2
31894: PUSH
31895: EMPTY
31896: LIST
31897: LIST
31898: PUSH
31899: LD_INT 1
31901: NEG
31902: PUSH
31903: LD_INT 1
31905: PUSH
31906: EMPTY
31907: LIST
31908: LIST
31909: PUSH
31910: LD_INT 2
31912: NEG
31913: PUSH
31914: LD_INT 0
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 2
31923: NEG
31924: PUSH
31925: LD_INT 1
31927: NEG
31928: PUSH
31929: EMPTY
31930: LIST
31931: LIST
31932: PUSH
31933: LD_INT 2
31935: NEG
31936: PUSH
31937: LD_INT 2
31939: NEG
31940: PUSH
31941: EMPTY
31942: LIST
31943: LIST
31944: PUSH
31945: EMPTY
31946: LIST
31947: LIST
31948: LIST
31949: LIST
31950: LIST
31951: LIST
31952: LIST
31953: LIST
31954: LIST
31955: LIST
31956: LIST
31957: LIST
31958: LIST
31959: LIST
31960: LIST
31961: LIST
31962: LIST
31963: LIST
31964: LIST
31965: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31966: LD_ADDR_VAR 0 20
31970: PUSH
31971: LD_INT 0
31973: PUSH
31974: LD_INT 0
31976: PUSH
31977: EMPTY
31978: LIST
31979: LIST
31980: PUSH
31981: LD_INT 0
31983: PUSH
31984: LD_INT 1
31986: NEG
31987: PUSH
31988: EMPTY
31989: LIST
31990: LIST
31991: PUSH
31992: LD_INT 1
31994: PUSH
31995: LD_INT 0
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: PUSH
32002: LD_INT 1
32004: PUSH
32005: LD_INT 1
32007: PUSH
32008: EMPTY
32009: LIST
32010: LIST
32011: PUSH
32012: LD_INT 0
32014: PUSH
32015: LD_INT 1
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PUSH
32022: LD_INT 1
32024: NEG
32025: PUSH
32026: LD_INT 0
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: PUSH
32033: LD_INT 1
32035: NEG
32036: PUSH
32037: LD_INT 1
32039: NEG
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: PUSH
32045: LD_INT 1
32047: NEG
32048: PUSH
32049: LD_INT 2
32051: NEG
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: PUSH
32057: LD_INT 0
32059: PUSH
32060: LD_INT 2
32062: NEG
32063: PUSH
32064: EMPTY
32065: LIST
32066: LIST
32067: PUSH
32068: LD_INT 1
32070: PUSH
32071: LD_INT 1
32073: NEG
32074: PUSH
32075: EMPTY
32076: LIST
32077: LIST
32078: PUSH
32079: LD_INT 2
32081: PUSH
32082: LD_INT 0
32084: PUSH
32085: EMPTY
32086: LIST
32087: LIST
32088: PUSH
32089: LD_INT 2
32091: PUSH
32092: LD_INT 1
32094: PUSH
32095: EMPTY
32096: LIST
32097: LIST
32098: PUSH
32099: LD_INT 2
32101: PUSH
32102: LD_INT 2
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: PUSH
32109: LD_INT 1
32111: PUSH
32112: LD_INT 2
32114: PUSH
32115: EMPTY
32116: LIST
32117: LIST
32118: PUSH
32119: LD_INT 0
32121: PUSH
32122: LD_INT 2
32124: PUSH
32125: EMPTY
32126: LIST
32127: LIST
32128: PUSH
32129: LD_INT 1
32131: NEG
32132: PUSH
32133: LD_INT 1
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 2
32142: NEG
32143: PUSH
32144: LD_INT 0
32146: PUSH
32147: EMPTY
32148: LIST
32149: LIST
32150: PUSH
32151: LD_INT 2
32153: NEG
32154: PUSH
32155: LD_INT 1
32157: NEG
32158: PUSH
32159: EMPTY
32160: LIST
32161: LIST
32162: PUSH
32163: LD_INT 2
32165: NEG
32166: PUSH
32167: LD_INT 2
32169: NEG
32170: PUSH
32171: EMPTY
32172: LIST
32173: LIST
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: LIST
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: LIST
32195: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32196: LD_ADDR_VAR 0 21
32200: PUSH
32201: LD_INT 0
32203: PUSH
32204: LD_INT 0
32206: PUSH
32207: EMPTY
32208: LIST
32209: LIST
32210: PUSH
32211: LD_INT 0
32213: PUSH
32214: LD_INT 1
32216: NEG
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 1
32224: PUSH
32225: LD_INT 0
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 1
32234: PUSH
32235: LD_INT 1
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 0
32244: PUSH
32245: LD_INT 1
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 1
32254: NEG
32255: PUSH
32256: LD_INT 0
32258: PUSH
32259: EMPTY
32260: LIST
32261: LIST
32262: PUSH
32263: LD_INT 1
32265: NEG
32266: PUSH
32267: LD_INT 1
32269: NEG
32270: PUSH
32271: EMPTY
32272: LIST
32273: LIST
32274: PUSH
32275: LD_INT 1
32277: NEG
32278: PUSH
32279: LD_INT 2
32281: NEG
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 0
32289: PUSH
32290: LD_INT 2
32292: NEG
32293: PUSH
32294: EMPTY
32295: LIST
32296: LIST
32297: PUSH
32298: LD_INT 1
32300: PUSH
32301: LD_INT 1
32303: NEG
32304: PUSH
32305: EMPTY
32306: LIST
32307: LIST
32308: PUSH
32309: LD_INT 2
32311: PUSH
32312: LD_INT 0
32314: PUSH
32315: EMPTY
32316: LIST
32317: LIST
32318: PUSH
32319: LD_INT 2
32321: PUSH
32322: LD_INT 1
32324: PUSH
32325: EMPTY
32326: LIST
32327: LIST
32328: PUSH
32329: LD_INT 2
32331: PUSH
32332: LD_INT 2
32334: PUSH
32335: EMPTY
32336: LIST
32337: LIST
32338: PUSH
32339: LD_INT 1
32341: PUSH
32342: LD_INT 2
32344: PUSH
32345: EMPTY
32346: LIST
32347: LIST
32348: PUSH
32349: LD_INT 0
32351: PUSH
32352: LD_INT 2
32354: PUSH
32355: EMPTY
32356: LIST
32357: LIST
32358: PUSH
32359: LD_INT 1
32361: NEG
32362: PUSH
32363: LD_INT 1
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PUSH
32370: LD_INT 2
32372: NEG
32373: PUSH
32374: LD_INT 0
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: PUSH
32381: LD_INT 2
32383: NEG
32384: PUSH
32385: LD_INT 1
32387: NEG
32388: PUSH
32389: EMPTY
32390: LIST
32391: LIST
32392: PUSH
32393: LD_INT 2
32395: NEG
32396: PUSH
32397: LD_INT 2
32399: NEG
32400: PUSH
32401: EMPTY
32402: LIST
32403: LIST
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: LIST
32409: LIST
32410: LIST
32411: LIST
32412: LIST
32413: LIST
32414: LIST
32415: LIST
32416: LIST
32417: LIST
32418: LIST
32419: LIST
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32426: LD_ADDR_VAR 0 22
32430: PUSH
32431: LD_INT 0
32433: PUSH
32434: LD_INT 0
32436: PUSH
32437: EMPTY
32438: LIST
32439: LIST
32440: PUSH
32441: LD_INT 0
32443: PUSH
32444: LD_INT 1
32446: NEG
32447: PUSH
32448: EMPTY
32449: LIST
32450: LIST
32451: PUSH
32452: LD_INT 1
32454: PUSH
32455: LD_INT 0
32457: PUSH
32458: EMPTY
32459: LIST
32460: LIST
32461: PUSH
32462: LD_INT 1
32464: PUSH
32465: LD_INT 1
32467: PUSH
32468: EMPTY
32469: LIST
32470: LIST
32471: PUSH
32472: LD_INT 0
32474: PUSH
32475: LD_INT 1
32477: PUSH
32478: EMPTY
32479: LIST
32480: LIST
32481: PUSH
32482: LD_INT 1
32484: NEG
32485: PUSH
32486: LD_INT 0
32488: PUSH
32489: EMPTY
32490: LIST
32491: LIST
32492: PUSH
32493: LD_INT 1
32495: NEG
32496: PUSH
32497: LD_INT 1
32499: NEG
32500: PUSH
32501: EMPTY
32502: LIST
32503: LIST
32504: PUSH
32505: LD_INT 1
32507: NEG
32508: PUSH
32509: LD_INT 2
32511: NEG
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: PUSH
32517: LD_INT 0
32519: PUSH
32520: LD_INT 2
32522: NEG
32523: PUSH
32524: EMPTY
32525: LIST
32526: LIST
32527: PUSH
32528: LD_INT 1
32530: PUSH
32531: LD_INT 1
32533: NEG
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: PUSH
32539: LD_INT 2
32541: PUSH
32542: LD_INT 0
32544: PUSH
32545: EMPTY
32546: LIST
32547: LIST
32548: PUSH
32549: LD_INT 2
32551: PUSH
32552: LD_INT 1
32554: PUSH
32555: EMPTY
32556: LIST
32557: LIST
32558: PUSH
32559: LD_INT 2
32561: PUSH
32562: LD_INT 2
32564: PUSH
32565: EMPTY
32566: LIST
32567: LIST
32568: PUSH
32569: LD_INT 1
32571: PUSH
32572: LD_INT 2
32574: PUSH
32575: EMPTY
32576: LIST
32577: LIST
32578: PUSH
32579: LD_INT 0
32581: PUSH
32582: LD_INT 2
32584: PUSH
32585: EMPTY
32586: LIST
32587: LIST
32588: PUSH
32589: LD_INT 1
32591: NEG
32592: PUSH
32593: LD_INT 1
32595: PUSH
32596: EMPTY
32597: LIST
32598: LIST
32599: PUSH
32600: LD_INT 2
32602: NEG
32603: PUSH
32604: LD_INT 0
32606: PUSH
32607: EMPTY
32608: LIST
32609: LIST
32610: PUSH
32611: LD_INT 2
32613: NEG
32614: PUSH
32615: LD_INT 1
32617: NEG
32618: PUSH
32619: EMPTY
32620: LIST
32621: LIST
32622: PUSH
32623: LD_INT 2
32625: NEG
32626: PUSH
32627: LD_INT 2
32629: NEG
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: PUSH
32635: EMPTY
32636: LIST
32637: LIST
32638: LIST
32639: LIST
32640: LIST
32641: LIST
32642: LIST
32643: LIST
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
32656: LD_ADDR_VAR 0 23
32660: PUSH
32661: LD_INT 0
32663: PUSH
32664: LD_INT 0
32666: PUSH
32667: EMPTY
32668: LIST
32669: LIST
32670: PUSH
32671: LD_INT 0
32673: PUSH
32674: LD_INT 1
32676: NEG
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PUSH
32682: LD_INT 1
32684: PUSH
32685: LD_INT 0
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 1
32694: PUSH
32695: LD_INT 1
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 0
32704: PUSH
32705: LD_INT 1
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: LD_INT 1
32714: NEG
32715: PUSH
32716: LD_INT 0
32718: PUSH
32719: EMPTY
32720: LIST
32721: LIST
32722: PUSH
32723: LD_INT 1
32725: NEG
32726: PUSH
32727: LD_INT 1
32729: NEG
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 1
32737: NEG
32738: PUSH
32739: LD_INT 2
32741: NEG
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 0
32749: PUSH
32750: LD_INT 2
32752: NEG
32753: PUSH
32754: EMPTY
32755: LIST
32756: LIST
32757: PUSH
32758: LD_INT 1
32760: PUSH
32761: LD_INT 1
32763: NEG
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: PUSH
32769: LD_INT 2
32771: PUSH
32772: LD_INT 0
32774: PUSH
32775: EMPTY
32776: LIST
32777: LIST
32778: PUSH
32779: LD_INT 2
32781: PUSH
32782: LD_INT 1
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: PUSH
32789: LD_INT 2
32791: PUSH
32792: LD_INT 2
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 1
32801: PUSH
32802: LD_INT 2
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 0
32811: PUSH
32812: LD_INT 2
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 1
32821: NEG
32822: PUSH
32823: LD_INT 1
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 2
32832: NEG
32833: PUSH
32834: LD_INT 0
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PUSH
32841: LD_INT 2
32843: NEG
32844: PUSH
32845: LD_INT 1
32847: NEG
32848: PUSH
32849: EMPTY
32850: LIST
32851: LIST
32852: PUSH
32853: LD_INT 2
32855: NEG
32856: PUSH
32857: LD_INT 2
32859: NEG
32860: PUSH
32861: EMPTY
32862: LIST
32863: LIST
32864: PUSH
32865: LD_INT 2
32867: NEG
32868: PUSH
32869: LD_INT 3
32871: NEG
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PUSH
32877: LD_INT 1
32879: NEG
32880: PUSH
32881: LD_INT 3
32883: NEG
32884: PUSH
32885: EMPTY
32886: LIST
32887: LIST
32888: PUSH
32889: LD_INT 1
32891: PUSH
32892: LD_INT 2
32894: NEG
32895: PUSH
32896: EMPTY
32897: LIST
32898: LIST
32899: PUSH
32900: LD_INT 2
32902: PUSH
32903: LD_INT 1
32905: NEG
32906: PUSH
32907: EMPTY
32908: LIST
32909: LIST
32910: PUSH
32911: EMPTY
32912: LIST
32913: LIST
32914: LIST
32915: LIST
32916: LIST
32917: LIST
32918: LIST
32919: LIST
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32936: LD_ADDR_VAR 0 24
32940: PUSH
32941: LD_INT 0
32943: PUSH
32944: LD_INT 0
32946: PUSH
32947: EMPTY
32948: LIST
32949: LIST
32950: PUSH
32951: LD_INT 0
32953: PUSH
32954: LD_INT 1
32956: NEG
32957: PUSH
32958: EMPTY
32959: LIST
32960: LIST
32961: PUSH
32962: LD_INT 1
32964: PUSH
32965: LD_INT 0
32967: PUSH
32968: EMPTY
32969: LIST
32970: LIST
32971: PUSH
32972: LD_INT 1
32974: PUSH
32975: LD_INT 1
32977: PUSH
32978: EMPTY
32979: LIST
32980: LIST
32981: PUSH
32982: LD_INT 0
32984: PUSH
32985: LD_INT 1
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: PUSH
32992: LD_INT 1
32994: NEG
32995: PUSH
32996: LD_INT 0
32998: PUSH
32999: EMPTY
33000: LIST
33001: LIST
33002: PUSH
33003: LD_INT 1
33005: NEG
33006: PUSH
33007: LD_INT 1
33009: NEG
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 1
33017: NEG
33018: PUSH
33019: LD_INT 2
33021: NEG
33022: PUSH
33023: EMPTY
33024: LIST
33025: LIST
33026: PUSH
33027: LD_INT 0
33029: PUSH
33030: LD_INT 2
33032: NEG
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: LD_INT 1
33040: PUSH
33041: LD_INT 1
33043: NEG
33044: PUSH
33045: EMPTY
33046: LIST
33047: LIST
33048: PUSH
33049: LD_INT 2
33051: PUSH
33052: LD_INT 0
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 2
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 2
33071: PUSH
33072: LD_INT 2
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 1
33081: PUSH
33082: LD_INT 2
33084: PUSH
33085: EMPTY
33086: LIST
33087: LIST
33088: PUSH
33089: LD_INT 0
33091: PUSH
33092: LD_INT 2
33094: PUSH
33095: EMPTY
33096: LIST
33097: LIST
33098: PUSH
33099: LD_INT 1
33101: NEG
33102: PUSH
33103: LD_INT 1
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: LD_INT 2
33112: NEG
33113: PUSH
33114: LD_INT 0
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 2
33123: NEG
33124: PUSH
33125: LD_INT 1
33127: NEG
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: PUSH
33133: LD_INT 2
33135: NEG
33136: PUSH
33137: LD_INT 2
33139: NEG
33140: PUSH
33141: EMPTY
33142: LIST
33143: LIST
33144: PUSH
33145: LD_INT 1
33147: PUSH
33148: LD_INT 2
33150: NEG
33151: PUSH
33152: EMPTY
33153: LIST
33154: LIST
33155: PUSH
33156: LD_INT 2
33158: PUSH
33159: LD_INT 1
33161: NEG
33162: PUSH
33163: EMPTY
33164: LIST
33165: LIST
33166: PUSH
33167: LD_INT 3
33169: PUSH
33170: LD_INT 1
33172: PUSH
33173: EMPTY
33174: LIST
33175: LIST
33176: PUSH
33177: LD_INT 3
33179: PUSH
33180: LD_INT 2
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: LIST
33191: LIST
33192: LIST
33193: LIST
33194: LIST
33195: LIST
33196: LIST
33197: LIST
33198: LIST
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
33212: LD_ADDR_VAR 0 25
33216: PUSH
33217: LD_INT 0
33219: PUSH
33220: LD_INT 0
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 0
33229: PUSH
33230: LD_INT 1
33232: NEG
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: PUSH
33238: LD_INT 1
33240: PUSH
33241: LD_INT 0
33243: PUSH
33244: EMPTY
33245: LIST
33246: LIST
33247: PUSH
33248: LD_INT 1
33250: PUSH
33251: LD_INT 1
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 0
33260: PUSH
33261: LD_INT 1
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: LD_INT 1
33270: NEG
33271: PUSH
33272: LD_INT 0
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 1
33281: NEG
33282: PUSH
33283: LD_INT 1
33285: NEG
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: PUSH
33291: LD_INT 1
33293: NEG
33294: PUSH
33295: LD_INT 2
33297: NEG
33298: PUSH
33299: EMPTY
33300: LIST
33301: LIST
33302: PUSH
33303: LD_INT 0
33305: PUSH
33306: LD_INT 2
33308: NEG
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 1
33316: PUSH
33317: LD_INT 1
33319: NEG
33320: PUSH
33321: EMPTY
33322: LIST
33323: LIST
33324: PUSH
33325: LD_INT 2
33327: PUSH
33328: LD_INT 0
33330: PUSH
33331: EMPTY
33332: LIST
33333: LIST
33334: PUSH
33335: LD_INT 2
33337: PUSH
33338: LD_INT 1
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 2
33347: PUSH
33348: LD_INT 2
33350: PUSH
33351: EMPTY
33352: LIST
33353: LIST
33354: PUSH
33355: LD_INT 1
33357: PUSH
33358: LD_INT 2
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 0
33367: PUSH
33368: LD_INT 2
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PUSH
33375: LD_INT 1
33377: NEG
33378: PUSH
33379: LD_INT 1
33381: PUSH
33382: EMPTY
33383: LIST
33384: LIST
33385: PUSH
33386: LD_INT 2
33388: NEG
33389: PUSH
33390: LD_INT 0
33392: PUSH
33393: EMPTY
33394: LIST
33395: LIST
33396: PUSH
33397: LD_INT 2
33399: NEG
33400: PUSH
33401: LD_INT 1
33403: NEG
33404: PUSH
33405: EMPTY
33406: LIST
33407: LIST
33408: PUSH
33409: LD_INT 2
33411: NEG
33412: PUSH
33413: LD_INT 2
33415: NEG
33416: PUSH
33417: EMPTY
33418: LIST
33419: LIST
33420: PUSH
33421: LD_INT 3
33423: PUSH
33424: LD_INT 1
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: PUSH
33431: LD_INT 3
33433: PUSH
33434: LD_INT 2
33436: PUSH
33437: EMPTY
33438: LIST
33439: LIST
33440: PUSH
33441: LD_INT 2
33443: PUSH
33444: LD_INT 3
33446: PUSH
33447: EMPTY
33448: LIST
33449: LIST
33450: PUSH
33451: LD_INT 1
33453: PUSH
33454: LD_INT 3
33456: PUSH
33457: EMPTY
33458: LIST
33459: LIST
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: LIST
33465: LIST
33466: LIST
33467: LIST
33468: LIST
33469: LIST
33470: LIST
33471: LIST
33472: LIST
33473: LIST
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
33486: LD_ADDR_VAR 0 26
33490: PUSH
33491: LD_INT 0
33493: PUSH
33494: LD_INT 0
33496: PUSH
33497: EMPTY
33498: LIST
33499: LIST
33500: PUSH
33501: LD_INT 0
33503: PUSH
33504: LD_INT 1
33506: NEG
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 1
33514: PUSH
33515: LD_INT 0
33517: PUSH
33518: EMPTY
33519: LIST
33520: LIST
33521: PUSH
33522: LD_INT 1
33524: PUSH
33525: LD_INT 1
33527: PUSH
33528: EMPTY
33529: LIST
33530: LIST
33531: PUSH
33532: LD_INT 0
33534: PUSH
33535: LD_INT 1
33537: PUSH
33538: EMPTY
33539: LIST
33540: LIST
33541: PUSH
33542: LD_INT 1
33544: NEG
33545: PUSH
33546: LD_INT 0
33548: PUSH
33549: EMPTY
33550: LIST
33551: LIST
33552: PUSH
33553: LD_INT 1
33555: NEG
33556: PUSH
33557: LD_INT 1
33559: NEG
33560: PUSH
33561: EMPTY
33562: LIST
33563: LIST
33564: PUSH
33565: LD_INT 1
33567: NEG
33568: PUSH
33569: LD_INT 2
33571: NEG
33572: PUSH
33573: EMPTY
33574: LIST
33575: LIST
33576: PUSH
33577: LD_INT 0
33579: PUSH
33580: LD_INT 2
33582: NEG
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: LD_INT 1
33590: PUSH
33591: LD_INT 1
33593: NEG
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: LD_INT 2
33601: PUSH
33602: LD_INT 0
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 2
33611: PUSH
33612: LD_INT 1
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 2
33621: PUSH
33622: LD_INT 2
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 1
33631: PUSH
33632: LD_INT 2
33634: PUSH
33635: EMPTY
33636: LIST
33637: LIST
33638: PUSH
33639: LD_INT 0
33641: PUSH
33642: LD_INT 2
33644: PUSH
33645: EMPTY
33646: LIST
33647: LIST
33648: PUSH
33649: LD_INT 1
33651: NEG
33652: PUSH
33653: LD_INT 1
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 2
33662: NEG
33663: PUSH
33664: LD_INT 0
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 2
33673: NEG
33674: PUSH
33675: LD_INT 1
33677: NEG
33678: PUSH
33679: EMPTY
33680: LIST
33681: LIST
33682: PUSH
33683: LD_INT 2
33685: NEG
33686: PUSH
33687: LD_INT 2
33689: NEG
33690: PUSH
33691: EMPTY
33692: LIST
33693: LIST
33694: PUSH
33695: LD_INT 2
33697: PUSH
33698: LD_INT 3
33700: PUSH
33701: EMPTY
33702: LIST
33703: LIST
33704: PUSH
33705: LD_INT 1
33707: PUSH
33708: LD_INT 3
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PUSH
33715: LD_INT 1
33717: NEG
33718: PUSH
33719: LD_INT 2
33721: PUSH
33722: EMPTY
33723: LIST
33724: LIST
33725: PUSH
33726: LD_INT 2
33728: NEG
33729: PUSH
33730: LD_INT 1
33732: PUSH
33733: EMPTY
33734: LIST
33735: LIST
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: LIST
33741: LIST
33742: LIST
33743: LIST
33744: LIST
33745: LIST
33746: LIST
33747: LIST
33748: LIST
33749: LIST
33750: LIST
33751: LIST
33752: LIST
33753: LIST
33754: LIST
33755: LIST
33756: LIST
33757: LIST
33758: LIST
33759: LIST
33760: LIST
33761: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33762: LD_ADDR_VAR 0 27
33766: PUSH
33767: LD_INT 0
33769: PUSH
33770: LD_INT 0
33772: PUSH
33773: EMPTY
33774: LIST
33775: LIST
33776: PUSH
33777: LD_INT 0
33779: PUSH
33780: LD_INT 1
33782: NEG
33783: PUSH
33784: EMPTY
33785: LIST
33786: LIST
33787: PUSH
33788: LD_INT 1
33790: PUSH
33791: LD_INT 0
33793: PUSH
33794: EMPTY
33795: LIST
33796: LIST
33797: PUSH
33798: LD_INT 1
33800: PUSH
33801: LD_INT 1
33803: PUSH
33804: EMPTY
33805: LIST
33806: LIST
33807: PUSH
33808: LD_INT 0
33810: PUSH
33811: LD_INT 1
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: LD_INT 1
33820: NEG
33821: PUSH
33822: LD_INT 0
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: LD_INT 1
33831: NEG
33832: PUSH
33833: LD_INT 1
33835: NEG
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: LD_INT 1
33843: NEG
33844: PUSH
33845: LD_INT 2
33847: NEG
33848: PUSH
33849: EMPTY
33850: LIST
33851: LIST
33852: PUSH
33853: LD_INT 0
33855: PUSH
33856: LD_INT 2
33858: NEG
33859: PUSH
33860: EMPTY
33861: LIST
33862: LIST
33863: PUSH
33864: LD_INT 1
33866: PUSH
33867: LD_INT 1
33869: NEG
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 2
33877: PUSH
33878: LD_INT 0
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 2
33887: PUSH
33888: LD_INT 1
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 2
33897: PUSH
33898: LD_INT 2
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 1
33907: PUSH
33908: LD_INT 2
33910: PUSH
33911: EMPTY
33912: LIST
33913: LIST
33914: PUSH
33915: LD_INT 0
33917: PUSH
33918: LD_INT 2
33920: PUSH
33921: EMPTY
33922: LIST
33923: LIST
33924: PUSH
33925: LD_INT 1
33927: NEG
33928: PUSH
33929: LD_INT 1
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 2
33938: NEG
33939: PUSH
33940: LD_INT 0
33942: PUSH
33943: EMPTY
33944: LIST
33945: LIST
33946: PUSH
33947: LD_INT 2
33949: NEG
33950: PUSH
33951: LD_INT 1
33953: NEG
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 2
33961: NEG
33962: PUSH
33963: LD_INT 2
33965: NEG
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PUSH
33971: LD_INT 1
33973: NEG
33974: PUSH
33975: LD_INT 2
33977: PUSH
33978: EMPTY
33979: LIST
33980: LIST
33981: PUSH
33982: LD_INT 2
33984: NEG
33985: PUSH
33986: LD_INT 1
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 3
33995: NEG
33996: PUSH
33997: LD_INT 1
33999: NEG
34000: PUSH
34001: EMPTY
34002: LIST
34003: LIST
34004: PUSH
34005: LD_INT 3
34007: NEG
34008: PUSH
34009: LD_INT 2
34011: NEG
34012: PUSH
34013: EMPTY
34014: LIST
34015: LIST
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: LIST
34021: LIST
34022: LIST
34023: LIST
34024: LIST
34025: LIST
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34042: LD_ADDR_VAR 0 28
34046: PUSH
34047: LD_INT 0
34049: PUSH
34050: LD_INT 0
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: PUSH
34057: LD_INT 0
34059: PUSH
34060: LD_INT 1
34062: NEG
34063: PUSH
34064: EMPTY
34065: LIST
34066: LIST
34067: PUSH
34068: LD_INT 1
34070: PUSH
34071: LD_INT 0
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PUSH
34078: LD_INT 1
34080: PUSH
34081: LD_INT 1
34083: PUSH
34084: EMPTY
34085: LIST
34086: LIST
34087: PUSH
34088: LD_INT 0
34090: PUSH
34091: LD_INT 1
34093: PUSH
34094: EMPTY
34095: LIST
34096: LIST
34097: PUSH
34098: LD_INT 1
34100: NEG
34101: PUSH
34102: LD_INT 0
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: PUSH
34109: LD_INT 1
34111: NEG
34112: PUSH
34113: LD_INT 1
34115: NEG
34116: PUSH
34117: EMPTY
34118: LIST
34119: LIST
34120: PUSH
34121: LD_INT 1
34123: NEG
34124: PUSH
34125: LD_INT 2
34127: NEG
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 0
34135: PUSH
34136: LD_INT 2
34138: NEG
34139: PUSH
34140: EMPTY
34141: LIST
34142: LIST
34143: PUSH
34144: LD_INT 1
34146: PUSH
34147: LD_INT 1
34149: NEG
34150: PUSH
34151: EMPTY
34152: LIST
34153: LIST
34154: PUSH
34155: LD_INT 2
34157: PUSH
34158: LD_INT 0
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PUSH
34165: LD_INT 2
34167: PUSH
34168: LD_INT 1
34170: PUSH
34171: EMPTY
34172: LIST
34173: LIST
34174: PUSH
34175: LD_INT 2
34177: PUSH
34178: LD_INT 2
34180: PUSH
34181: EMPTY
34182: LIST
34183: LIST
34184: PUSH
34185: LD_INT 1
34187: PUSH
34188: LD_INT 2
34190: PUSH
34191: EMPTY
34192: LIST
34193: LIST
34194: PUSH
34195: LD_INT 0
34197: PUSH
34198: LD_INT 2
34200: PUSH
34201: EMPTY
34202: LIST
34203: LIST
34204: PUSH
34205: LD_INT 1
34207: NEG
34208: PUSH
34209: LD_INT 1
34211: PUSH
34212: EMPTY
34213: LIST
34214: LIST
34215: PUSH
34216: LD_INT 2
34218: NEG
34219: PUSH
34220: LD_INT 0
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 2
34229: NEG
34230: PUSH
34231: LD_INT 1
34233: NEG
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: LD_INT 2
34241: NEG
34242: PUSH
34243: LD_INT 2
34245: NEG
34246: PUSH
34247: EMPTY
34248: LIST
34249: LIST
34250: PUSH
34251: LD_INT 2
34253: NEG
34254: PUSH
34255: LD_INT 3
34257: NEG
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: PUSH
34263: LD_INT 1
34265: NEG
34266: PUSH
34267: LD_INT 3
34269: NEG
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 3
34277: NEG
34278: PUSH
34279: LD_INT 1
34281: NEG
34282: PUSH
34283: EMPTY
34284: LIST
34285: LIST
34286: PUSH
34287: LD_INT 3
34289: NEG
34290: PUSH
34291: LD_INT 2
34293: NEG
34294: PUSH
34295: EMPTY
34296: LIST
34297: LIST
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: LIST
34303: LIST
34304: LIST
34305: LIST
34306: LIST
34307: LIST
34308: LIST
34309: LIST
34310: LIST
34311: LIST
34312: LIST
34313: LIST
34314: LIST
34315: LIST
34316: LIST
34317: LIST
34318: LIST
34319: LIST
34320: LIST
34321: LIST
34322: LIST
34323: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34324: LD_ADDR_VAR 0 29
34328: PUSH
34329: LD_INT 0
34331: PUSH
34332: LD_INT 0
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: LD_INT 0
34341: PUSH
34342: LD_INT 1
34344: NEG
34345: PUSH
34346: EMPTY
34347: LIST
34348: LIST
34349: PUSH
34350: LD_INT 1
34352: PUSH
34353: LD_INT 0
34355: PUSH
34356: EMPTY
34357: LIST
34358: LIST
34359: PUSH
34360: LD_INT 1
34362: PUSH
34363: LD_INT 1
34365: PUSH
34366: EMPTY
34367: LIST
34368: LIST
34369: PUSH
34370: LD_INT 0
34372: PUSH
34373: LD_INT 1
34375: PUSH
34376: EMPTY
34377: LIST
34378: LIST
34379: PUSH
34380: LD_INT 1
34382: NEG
34383: PUSH
34384: LD_INT 0
34386: PUSH
34387: EMPTY
34388: LIST
34389: LIST
34390: PUSH
34391: LD_INT 1
34393: NEG
34394: PUSH
34395: LD_INT 1
34397: NEG
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: PUSH
34403: LD_INT 1
34405: NEG
34406: PUSH
34407: LD_INT 2
34409: NEG
34410: PUSH
34411: EMPTY
34412: LIST
34413: LIST
34414: PUSH
34415: LD_INT 0
34417: PUSH
34418: LD_INT 2
34420: NEG
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: PUSH
34426: LD_INT 1
34428: PUSH
34429: LD_INT 1
34431: NEG
34432: PUSH
34433: EMPTY
34434: LIST
34435: LIST
34436: PUSH
34437: LD_INT 2
34439: PUSH
34440: LD_INT 0
34442: PUSH
34443: EMPTY
34444: LIST
34445: LIST
34446: PUSH
34447: LD_INT 2
34449: PUSH
34450: LD_INT 1
34452: PUSH
34453: EMPTY
34454: LIST
34455: LIST
34456: PUSH
34457: LD_INT 1
34459: PUSH
34460: LD_INT 2
34462: PUSH
34463: EMPTY
34464: LIST
34465: LIST
34466: PUSH
34467: LD_INT 0
34469: PUSH
34470: LD_INT 2
34472: PUSH
34473: EMPTY
34474: LIST
34475: LIST
34476: PUSH
34477: LD_INT 1
34479: NEG
34480: PUSH
34481: LD_INT 1
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: LD_INT 2
34490: NEG
34491: PUSH
34492: LD_INT 1
34494: NEG
34495: PUSH
34496: EMPTY
34497: LIST
34498: LIST
34499: PUSH
34500: LD_INT 2
34502: NEG
34503: PUSH
34504: LD_INT 2
34506: NEG
34507: PUSH
34508: EMPTY
34509: LIST
34510: LIST
34511: PUSH
34512: LD_INT 2
34514: NEG
34515: PUSH
34516: LD_INT 3
34518: NEG
34519: PUSH
34520: EMPTY
34521: LIST
34522: LIST
34523: PUSH
34524: LD_INT 2
34526: PUSH
34527: LD_INT 1
34529: NEG
34530: PUSH
34531: EMPTY
34532: LIST
34533: LIST
34534: PUSH
34535: LD_INT 3
34537: PUSH
34538: LD_INT 1
34540: PUSH
34541: EMPTY
34542: LIST
34543: LIST
34544: PUSH
34545: LD_INT 1
34547: PUSH
34548: LD_INT 3
34550: PUSH
34551: EMPTY
34552: LIST
34553: LIST
34554: PUSH
34555: LD_INT 1
34557: NEG
34558: PUSH
34559: LD_INT 2
34561: PUSH
34562: EMPTY
34563: LIST
34564: LIST
34565: PUSH
34566: LD_INT 3
34568: NEG
34569: PUSH
34570: LD_INT 2
34572: NEG
34573: PUSH
34574: EMPTY
34575: LIST
34576: LIST
34577: PUSH
34578: EMPTY
34579: LIST
34580: LIST
34581: LIST
34582: LIST
34583: LIST
34584: LIST
34585: LIST
34586: LIST
34587: LIST
34588: LIST
34589: LIST
34590: LIST
34591: LIST
34592: LIST
34593: LIST
34594: LIST
34595: LIST
34596: LIST
34597: LIST
34598: LIST
34599: LIST
34600: LIST
34601: LIST
34602: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34603: LD_ADDR_VAR 0 30
34607: PUSH
34608: LD_INT 0
34610: PUSH
34611: LD_INT 0
34613: PUSH
34614: EMPTY
34615: LIST
34616: LIST
34617: PUSH
34618: LD_INT 0
34620: PUSH
34621: LD_INT 1
34623: NEG
34624: PUSH
34625: EMPTY
34626: LIST
34627: LIST
34628: PUSH
34629: LD_INT 1
34631: PUSH
34632: LD_INT 0
34634: PUSH
34635: EMPTY
34636: LIST
34637: LIST
34638: PUSH
34639: LD_INT 1
34641: PUSH
34642: LD_INT 1
34644: PUSH
34645: EMPTY
34646: LIST
34647: LIST
34648: PUSH
34649: LD_INT 0
34651: PUSH
34652: LD_INT 1
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: PUSH
34659: LD_INT 1
34661: NEG
34662: PUSH
34663: LD_INT 0
34665: PUSH
34666: EMPTY
34667: LIST
34668: LIST
34669: PUSH
34670: LD_INT 1
34672: NEG
34673: PUSH
34674: LD_INT 1
34676: NEG
34677: PUSH
34678: EMPTY
34679: LIST
34680: LIST
34681: PUSH
34682: LD_INT 1
34684: NEG
34685: PUSH
34686: LD_INT 2
34688: NEG
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 0
34696: PUSH
34697: LD_INT 2
34699: NEG
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 1
34707: PUSH
34708: LD_INT 1
34710: NEG
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: LD_INT 2
34718: PUSH
34719: LD_INT 0
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PUSH
34726: LD_INT 2
34728: PUSH
34729: LD_INT 1
34731: PUSH
34732: EMPTY
34733: LIST
34734: LIST
34735: PUSH
34736: LD_INT 2
34738: PUSH
34739: LD_INT 2
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: LD_INT 1
34748: PUSH
34749: LD_INT 2
34751: PUSH
34752: EMPTY
34753: LIST
34754: LIST
34755: PUSH
34756: LD_INT 1
34758: NEG
34759: PUSH
34760: LD_INT 1
34762: PUSH
34763: EMPTY
34764: LIST
34765: LIST
34766: PUSH
34767: LD_INT 2
34769: NEG
34770: PUSH
34771: LD_INT 0
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: PUSH
34778: LD_INT 2
34780: NEG
34781: PUSH
34782: LD_INT 1
34784: NEG
34785: PUSH
34786: EMPTY
34787: LIST
34788: LIST
34789: PUSH
34790: LD_INT 1
34792: NEG
34793: PUSH
34794: LD_INT 3
34796: NEG
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: PUSH
34802: LD_INT 1
34804: PUSH
34805: LD_INT 2
34807: NEG
34808: PUSH
34809: EMPTY
34810: LIST
34811: LIST
34812: PUSH
34813: LD_INT 3
34815: PUSH
34816: LD_INT 2
34818: PUSH
34819: EMPTY
34820: LIST
34821: LIST
34822: PUSH
34823: LD_INT 2
34825: PUSH
34826: LD_INT 3
34828: PUSH
34829: EMPTY
34830: LIST
34831: LIST
34832: PUSH
34833: LD_INT 2
34835: NEG
34836: PUSH
34837: LD_INT 1
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PUSH
34844: LD_INT 3
34846: NEG
34847: PUSH
34848: LD_INT 1
34850: NEG
34851: PUSH
34852: EMPTY
34853: LIST
34854: LIST
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: LIST
34860: LIST
34861: LIST
34862: LIST
34863: LIST
34864: LIST
34865: LIST
34866: LIST
34867: LIST
34868: LIST
34869: LIST
34870: LIST
34871: LIST
34872: LIST
34873: LIST
34874: LIST
34875: LIST
34876: LIST
34877: LIST
34878: LIST
34879: LIST
34880: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34881: LD_ADDR_VAR 0 31
34885: PUSH
34886: LD_INT 0
34888: PUSH
34889: LD_INT 0
34891: PUSH
34892: EMPTY
34893: LIST
34894: LIST
34895: PUSH
34896: LD_INT 0
34898: PUSH
34899: LD_INT 1
34901: NEG
34902: PUSH
34903: EMPTY
34904: LIST
34905: LIST
34906: PUSH
34907: LD_INT 1
34909: PUSH
34910: LD_INT 0
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: PUSH
34917: LD_INT 1
34919: PUSH
34920: LD_INT 1
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 0
34929: PUSH
34930: LD_INT 1
34932: PUSH
34933: EMPTY
34934: LIST
34935: LIST
34936: PUSH
34937: LD_INT 1
34939: NEG
34940: PUSH
34941: LD_INT 0
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: LD_INT 1
34950: NEG
34951: PUSH
34952: LD_INT 1
34954: NEG
34955: PUSH
34956: EMPTY
34957: LIST
34958: LIST
34959: PUSH
34960: LD_INT 1
34962: NEG
34963: PUSH
34964: LD_INT 2
34966: NEG
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: PUSH
34972: LD_INT 1
34974: PUSH
34975: LD_INT 1
34977: NEG
34978: PUSH
34979: EMPTY
34980: LIST
34981: LIST
34982: PUSH
34983: LD_INT 2
34985: PUSH
34986: LD_INT 0
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 2
34995: PUSH
34996: LD_INT 1
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: LD_INT 2
35005: PUSH
35006: LD_INT 2
35008: PUSH
35009: EMPTY
35010: LIST
35011: LIST
35012: PUSH
35013: LD_INT 1
35015: PUSH
35016: LD_INT 2
35018: PUSH
35019: EMPTY
35020: LIST
35021: LIST
35022: PUSH
35023: LD_INT 0
35025: PUSH
35026: LD_INT 2
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 1
35035: NEG
35036: PUSH
35037: LD_INT 1
35039: PUSH
35040: EMPTY
35041: LIST
35042: LIST
35043: PUSH
35044: LD_INT 2
35046: NEG
35047: PUSH
35048: LD_INT 1
35050: NEG
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: PUSH
35056: LD_INT 2
35058: NEG
35059: PUSH
35060: LD_INT 2
35062: NEG
35063: PUSH
35064: EMPTY
35065: LIST
35066: LIST
35067: PUSH
35068: LD_INT 2
35070: NEG
35071: PUSH
35072: LD_INT 3
35074: NEG
35075: PUSH
35076: EMPTY
35077: LIST
35078: LIST
35079: PUSH
35080: LD_INT 2
35082: PUSH
35083: LD_INT 1
35085: NEG
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: PUSH
35091: LD_INT 3
35093: PUSH
35094: LD_INT 1
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: PUSH
35101: LD_INT 1
35103: PUSH
35104: LD_INT 3
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 1
35113: NEG
35114: PUSH
35115: LD_INT 2
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: LD_INT 3
35124: NEG
35125: PUSH
35126: LD_INT 2
35128: NEG
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: LIST
35138: LIST
35139: LIST
35140: LIST
35141: LIST
35142: LIST
35143: LIST
35144: LIST
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: LIST
35150: LIST
35151: LIST
35152: LIST
35153: LIST
35154: LIST
35155: LIST
35156: LIST
35157: LIST
35158: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35159: LD_ADDR_VAR 0 32
35163: PUSH
35164: LD_INT 0
35166: PUSH
35167: LD_INT 0
35169: PUSH
35170: EMPTY
35171: LIST
35172: LIST
35173: PUSH
35174: LD_INT 0
35176: PUSH
35177: LD_INT 1
35179: NEG
35180: PUSH
35181: EMPTY
35182: LIST
35183: LIST
35184: PUSH
35185: LD_INT 1
35187: PUSH
35188: LD_INT 0
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: PUSH
35195: LD_INT 1
35197: PUSH
35198: LD_INT 1
35200: PUSH
35201: EMPTY
35202: LIST
35203: LIST
35204: PUSH
35205: LD_INT 0
35207: PUSH
35208: LD_INT 1
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PUSH
35215: LD_INT 1
35217: NEG
35218: PUSH
35219: LD_INT 0
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: PUSH
35226: LD_INT 1
35228: NEG
35229: PUSH
35230: LD_INT 1
35232: NEG
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: LD_INT 2
35244: NEG
35245: PUSH
35246: EMPTY
35247: LIST
35248: LIST
35249: PUSH
35250: LD_INT 0
35252: PUSH
35253: LD_INT 2
35255: NEG
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: PUSH
35261: LD_INT 1
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: LD_INT 2
35274: PUSH
35275: LD_INT 1
35277: PUSH
35278: EMPTY
35279: LIST
35280: LIST
35281: PUSH
35282: LD_INT 2
35284: PUSH
35285: LD_INT 2
35287: PUSH
35288: EMPTY
35289: LIST
35290: LIST
35291: PUSH
35292: LD_INT 1
35294: PUSH
35295: LD_INT 2
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: LD_INT 0
35304: PUSH
35305: LD_INT 2
35307: PUSH
35308: EMPTY
35309: LIST
35310: LIST
35311: PUSH
35312: LD_INT 1
35314: NEG
35315: PUSH
35316: LD_INT 1
35318: PUSH
35319: EMPTY
35320: LIST
35321: LIST
35322: PUSH
35323: LD_INT 2
35325: NEG
35326: PUSH
35327: LD_INT 0
35329: PUSH
35330: EMPTY
35331: LIST
35332: LIST
35333: PUSH
35334: LD_INT 2
35336: NEG
35337: PUSH
35338: LD_INT 1
35340: NEG
35341: PUSH
35342: EMPTY
35343: LIST
35344: LIST
35345: PUSH
35346: LD_INT 1
35348: NEG
35349: PUSH
35350: LD_INT 3
35352: NEG
35353: PUSH
35354: EMPTY
35355: LIST
35356: LIST
35357: PUSH
35358: LD_INT 1
35360: PUSH
35361: LD_INT 2
35363: NEG
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 3
35371: PUSH
35372: LD_INT 2
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 2
35381: PUSH
35382: LD_INT 3
35384: PUSH
35385: EMPTY
35386: LIST
35387: LIST
35388: PUSH
35389: LD_INT 2
35391: NEG
35392: PUSH
35393: LD_INT 1
35395: PUSH
35396: EMPTY
35397: LIST
35398: LIST
35399: PUSH
35400: LD_INT 3
35402: NEG
35403: PUSH
35404: LD_INT 1
35406: NEG
35407: PUSH
35408: EMPTY
35409: LIST
35410: LIST
35411: PUSH
35412: EMPTY
35413: LIST
35414: LIST
35415: LIST
35416: LIST
35417: LIST
35418: LIST
35419: LIST
35420: LIST
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: LIST
35436: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35437: LD_ADDR_VAR 0 33
35441: PUSH
35442: LD_INT 0
35444: PUSH
35445: LD_INT 0
35447: PUSH
35448: EMPTY
35449: LIST
35450: LIST
35451: PUSH
35452: LD_INT 0
35454: PUSH
35455: LD_INT 1
35457: NEG
35458: PUSH
35459: EMPTY
35460: LIST
35461: LIST
35462: PUSH
35463: LD_INT 1
35465: PUSH
35466: LD_INT 0
35468: PUSH
35469: EMPTY
35470: LIST
35471: LIST
35472: PUSH
35473: LD_INT 1
35475: PUSH
35476: LD_INT 1
35478: PUSH
35479: EMPTY
35480: LIST
35481: LIST
35482: PUSH
35483: LD_INT 0
35485: PUSH
35486: LD_INT 1
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PUSH
35493: LD_INT 1
35495: NEG
35496: PUSH
35497: LD_INT 0
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 1
35506: NEG
35507: PUSH
35508: LD_INT 1
35510: NEG
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: PUSH
35516: LD_INT 1
35518: NEG
35519: PUSH
35520: LD_INT 2
35522: NEG
35523: PUSH
35524: EMPTY
35525: LIST
35526: LIST
35527: PUSH
35528: LD_INT 1
35530: PUSH
35531: LD_INT 1
35533: NEG
35534: PUSH
35535: EMPTY
35536: LIST
35537: LIST
35538: PUSH
35539: LD_INT 2
35541: PUSH
35542: LD_INT 0
35544: PUSH
35545: EMPTY
35546: LIST
35547: LIST
35548: PUSH
35549: LD_INT 2
35551: PUSH
35552: LD_INT 1
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 1
35561: PUSH
35562: LD_INT 2
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PUSH
35569: LD_INT 0
35571: PUSH
35572: LD_INT 2
35574: PUSH
35575: EMPTY
35576: LIST
35577: LIST
35578: PUSH
35579: LD_INT 1
35581: NEG
35582: PUSH
35583: LD_INT 1
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: LD_INT 2
35592: NEG
35593: PUSH
35594: LD_INT 0
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 2
35603: NEG
35604: PUSH
35605: LD_INT 1
35607: NEG
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: LD_INT 2
35615: NEG
35616: PUSH
35617: LD_INT 2
35619: NEG
35620: PUSH
35621: EMPTY
35622: LIST
35623: LIST
35624: PUSH
35625: LD_INT 2
35627: NEG
35628: PUSH
35629: LD_INT 3
35631: NEG
35632: PUSH
35633: EMPTY
35634: LIST
35635: LIST
35636: PUSH
35637: LD_INT 2
35639: PUSH
35640: LD_INT 1
35642: NEG
35643: PUSH
35644: EMPTY
35645: LIST
35646: LIST
35647: PUSH
35648: LD_INT 3
35650: PUSH
35651: LD_INT 1
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PUSH
35658: LD_INT 1
35660: PUSH
35661: LD_INT 3
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: LD_INT 1
35670: NEG
35671: PUSH
35672: LD_INT 2
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 3
35681: NEG
35682: PUSH
35683: LD_INT 2
35685: NEG
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: LIST
35695: LIST
35696: LIST
35697: LIST
35698: LIST
35699: LIST
35700: LIST
35701: LIST
35702: LIST
35703: LIST
35704: LIST
35705: LIST
35706: LIST
35707: LIST
35708: LIST
35709: LIST
35710: LIST
35711: LIST
35712: LIST
35713: LIST
35714: LIST
35715: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35716: LD_ADDR_VAR 0 34
35720: PUSH
35721: LD_INT 0
35723: PUSH
35724: LD_INT 0
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 0
35733: PUSH
35734: LD_INT 1
35736: NEG
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 1
35744: PUSH
35745: LD_INT 0
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: LD_INT 1
35754: PUSH
35755: LD_INT 1
35757: PUSH
35758: EMPTY
35759: LIST
35760: LIST
35761: PUSH
35762: LD_INT 0
35764: PUSH
35765: LD_INT 1
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 1
35774: NEG
35775: PUSH
35776: LD_INT 0
35778: PUSH
35779: EMPTY
35780: LIST
35781: LIST
35782: PUSH
35783: LD_INT 1
35785: NEG
35786: PUSH
35787: LD_INT 1
35789: NEG
35790: PUSH
35791: EMPTY
35792: LIST
35793: LIST
35794: PUSH
35795: LD_INT 1
35797: NEG
35798: PUSH
35799: LD_INT 2
35801: NEG
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PUSH
35807: LD_INT 0
35809: PUSH
35810: LD_INT 2
35812: NEG
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: LD_INT 1
35820: PUSH
35821: LD_INT 1
35823: NEG
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 2
35831: PUSH
35832: LD_INT 1
35834: PUSH
35835: EMPTY
35836: LIST
35837: LIST
35838: PUSH
35839: LD_INT 2
35841: PUSH
35842: LD_INT 2
35844: PUSH
35845: EMPTY
35846: LIST
35847: LIST
35848: PUSH
35849: LD_INT 1
35851: PUSH
35852: LD_INT 2
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 1
35861: NEG
35862: PUSH
35863: LD_INT 1
35865: PUSH
35866: EMPTY
35867: LIST
35868: LIST
35869: PUSH
35870: LD_INT 2
35872: NEG
35873: PUSH
35874: LD_INT 0
35876: PUSH
35877: EMPTY
35878: LIST
35879: LIST
35880: PUSH
35881: LD_INT 2
35883: NEG
35884: PUSH
35885: LD_INT 1
35887: NEG
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 2
35895: NEG
35896: PUSH
35897: LD_INT 2
35899: NEG
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: PUSH
35905: LD_INT 1
35907: NEG
35908: PUSH
35909: LD_INT 3
35911: NEG
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 1
35919: PUSH
35920: LD_INT 2
35922: NEG
35923: PUSH
35924: EMPTY
35925: LIST
35926: LIST
35927: PUSH
35928: LD_INT 3
35930: PUSH
35931: LD_INT 2
35933: PUSH
35934: EMPTY
35935: LIST
35936: LIST
35937: PUSH
35938: LD_INT 2
35940: PUSH
35941: LD_INT 3
35943: PUSH
35944: EMPTY
35945: LIST
35946: LIST
35947: PUSH
35948: LD_INT 2
35950: NEG
35951: PUSH
35952: LD_INT 1
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PUSH
35959: LD_INT 3
35961: NEG
35962: PUSH
35963: LD_INT 1
35965: NEG
35966: PUSH
35967: EMPTY
35968: LIST
35969: LIST
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: LIST
35975: LIST
35976: LIST
35977: LIST
35978: LIST
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: LIST
35993: LIST
35994: LIST
35995: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35996: LD_ADDR_VAR 0 35
36000: PUSH
36001: LD_INT 0
36003: PUSH
36004: LD_INT 0
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 0
36013: PUSH
36014: LD_INT 1
36016: NEG
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 1
36024: PUSH
36025: LD_INT 0
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 1
36034: PUSH
36035: LD_INT 1
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 0
36044: PUSH
36045: LD_INT 1
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 1
36054: NEG
36055: PUSH
36056: LD_INT 0
36058: PUSH
36059: EMPTY
36060: LIST
36061: LIST
36062: PUSH
36063: LD_INT 1
36065: NEG
36066: PUSH
36067: LD_INT 1
36069: NEG
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: LD_INT 2
36077: PUSH
36078: LD_INT 1
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 2
36087: NEG
36088: PUSH
36089: LD_INT 1
36091: NEG
36092: PUSH
36093: EMPTY
36094: LIST
36095: LIST
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: LIST
36101: LIST
36102: LIST
36103: LIST
36104: LIST
36105: LIST
36106: LIST
36107: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36108: LD_ADDR_VAR 0 36
36112: PUSH
36113: LD_INT 0
36115: PUSH
36116: LD_INT 0
36118: PUSH
36119: EMPTY
36120: LIST
36121: LIST
36122: PUSH
36123: LD_INT 0
36125: PUSH
36126: LD_INT 1
36128: NEG
36129: PUSH
36130: EMPTY
36131: LIST
36132: LIST
36133: PUSH
36134: LD_INT 1
36136: PUSH
36137: LD_INT 0
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PUSH
36144: LD_INT 1
36146: PUSH
36147: LD_INT 1
36149: PUSH
36150: EMPTY
36151: LIST
36152: LIST
36153: PUSH
36154: LD_INT 0
36156: PUSH
36157: LD_INT 1
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: PUSH
36164: LD_INT 1
36166: NEG
36167: PUSH
36168: LD_INT 0
36170: PUSH
36171: EMPTY
36172: LIST
36173: LIST
36174: PUSH
36175: LD_INT 1
36177: NEG
36178: PUSH
36179: LD_INT 1
36181: NEG
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 1
36189: NEG
36190: PUSH
36191: LD_INT 2
36193: NEG
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: LD_INT 1
36201: PUSH
36202: LD_INT 2
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: LIST
36213: LIST
36214: LIST
36215: LIST
36216: LIST
36217: LIST
36218: LIST
36219: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36220: LD_ADDR_VAR 0 37
36224: PUSH
36225: LD_INT 0
36227: PUSH
36228: LD_INT 0
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 0
36237: PUSH
36238: LD_INT 1
36240: NEG
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 1
36248: PUSH
36249: LD_INT 0
36251: PUSH
36252: EMPTY
36253: LIST
36254: LIST
36255: PUSH
36256: LD_INT 1
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: PUSH
36266: LD_INT 0
36268: PUSH
36269: LD_INT 1
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 1
36278: NEG
36279: PUSH
36280: LD_INT 0
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 1
36289: NEG
36290: PUSH
36291: LD_INT 1
36293: NEG
36294: PUSH
36295: EMPTY
36296: LIST
36297: LIST
36298: PUSH
36299: LD_INT 1
36301: PUSH
36302: LD_INT 1
36304: NEG
36305: PUSH
36306: EMPTY
36307: LIST
36308: LIST
36309: PUSH
36310: LD_INT 1
36312: NEG
36313: PUSH
36314: LD_INT 1
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: LIST
36325: LIST
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36332: LD_ADDR_VAR 0 38
36336: PUSH
36337: LD_INT 0
36339: PUSH
36340: LD_INT 0
36342: PUSH
36343: EMPTY
36344: LIST
36345: LIST
36346: PUSH
36347: LD_INT 0
36349: PUSH
36350: LD_INT 1
36352: NEG
36353: PUSH
36354: EMPTY
36355: LIST
36356: LIST
36357: PUSH
36358: LD_INT 1
36360: PUSH
36361: LD_INT 0
36363: PUSH
36364: EMPTY
36365: LIST
36366: LIST
36367: PUSH
36368: LD_INT 1
36370: PUSH
36371: LD_INT 1
36373: PUSH
36374: EMPTY
36375: LIST
36376: LIST
36377: PUSH
36378: LD_INT 0
36380: PUSH
36381: LD_INT 1
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 1
36390: NEG
36391: PUSH
36392: LD_INT 0
36394: PUSH
36395: EMPTY
36396: LIST
36397: LIST
36398: PUSH
36399: LD_INT 1
36401: NEG
36402: PUSH
36403: LD_INT 1
36405: NEG
36406: PUSH
36407: EMPTY
36408: LIST
36409: LIST
36410: PUSH
36411: LD_INT 2
36413: PUSH
36414: LD_INT 1
36416: PUSH
36417: EMPTY
36418: LIST
36419: LIST
36420: PUSH
36421: LD_INT 2
36423: NEG
36424: PUSH
36425: LD_INT 1
36427: NEG
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: LIST
36437: LIST
36438: LIST
36439: LIST
36440: LIST
36441: LIST
36442: LIST
36443: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36444: LD_ADDR_VAR 0 39
36448: PUSH
36449: LD_INT 0
36451: PUSH
36452: LD_INT 0
36454: PUSH
36455: EMPTY
36456: LIST
36457: LIST
36458: PUSH
36459: LD_INT 0
36461: PUSH
36462: LD_INT 1
36464: NEG
36465: PUSH
36466: EMPTY
36467: LIST
36468: LIST
36469: PUSH
36470: LD_INT 1
36472: PUSH
36473: LD_INT 0
36475: PUSH
36476: EMPTY
36477: LIST
36478: LIST
36479: PUSH
36480: LD_INT 1
36482: PUSH
36483: LD_INT 1
36485: PUSH
36486: EMPTY
36487: LIST
36488: LIST
36489: PUSH
36490: LD_INT 0
36492: PUSH
36493: LD_INT 1
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: LD_INT 1
36502: NEG
36503: PUSH
36504: LD_INT 0
36506: PUSH
36507: EMPTY
36508: LIST
36509: LIST
36510: PUSH
36511: LD_INT 1
36513: NEG
36514: PUSH
36515: LD_INT 1
36517: NEG
36518: PUSH
36519: EMPTY
36520: LIST
36521: LIST
36522: PUSH
36523: LD_INT 1
36525: NEG
36526: PUSH
36527: LD_INT 2
36529: NEG
36530: PUSH
36531: EMPTY
36532: LIST
36533: LIST
36534: PUSH
36535: LD_INT 1
36537: PUSH
36538: LD_INT 2
36540: PUSH
36541: EMPTY
36542: LIST
36543: LIST
36544: PUSH
36545: EMPTY
36546: LIST
36547: LIST
36548: LIST
36549: LIST
36550: LIST
36551: LIST
36552: LIST
36553: LIST
36554: LIST
36555: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36556: LD_ADDR_VAR 0 40
36560: PUSH
36561: LD_INT 0
36563: PUSH
36564: LD_INT 0
36566: PUSH
36567: EMPTY
36568: LIST
36569: LIST
36570: PUSH
36571: LD_INT 0
36573: PUSH
36574: LD_INT 1
36576: NEG
36577: PUSH
36578: EMPTY
36579: LIST
36580: LIST
36581: PUSH
36582: LD_INT 1
36584: PUSH
36585: LD_INT 0
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 1
36594: PUSH
36595: LD_INT 1
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: LD_INT 0
36604: PUSH
36605: LD_INT 1
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 1
36614: NEG
36615: PUSH
36616: LD_INT 0
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: LD_INT 1
36625: NEG
36626: PUSH
36627: LD_INT 1
36629: NEG
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 1
36637: PUSH
36638: LD_INT 1
36640: NEG
36641: PUSH
36642: EMPTY
36643: LIST
36644: LIST
36645: PUSH
36646: LD_INT 1
36648: NEG
36649: PUSH
36650: LD_INT 1
36652: PUSH
36653: EMPTY
36654: LIST
36655: LIST
36656: PUSH
36657: EMPTY
36658: LIST
36659: LIST
36660: LIST
36661: LIST
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36668: LD_ADDR_VAR 0 41
36672: PUSH
36673: LD_INT 0
36675: PUSH
36676: LD_INT 0
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PUSH
36683: LD_INT 0
36685: PUSH
36686: LD_INT 1
36688: NEG
36689: PUSH
36690: EMPTY
36691: LIST
36692: LIST
36693: PUSH
36694: LD_INT 1
36696: PUSH
36697: LD_INT 0
36699: PUSH
36700: EMPTY
36701: LIST
36702: LIST
36703: PUSH
36704: LD_INT 1
36706: PUSH
36707: LD_INT 1
36709: PUSH
36710: EMPTY
36711: LIST
36712: LIST
36713: PUSH
36714: LD_INT 0
36716: PUSH
36717: LD_INT 1
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: LD_INT 1
36726: NEG
36727: PUSH
36728: LD_INT 0
36730: PUSH
36731: EMPTY
36732: LIST
36733: LIST
36734: PUSH
36735: LD_INT 1
36737: NEG
36738: PUSH
36739: LD_INT 1
36741: NEG
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: LD_INT 1
36749: NEG
36750: PUSH
36751: LD_INT 2
36753: NEG
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PUSH
36759: LD_INT 1
36761: PUSH
36762: LD_INT 1
36764: NEG
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: PUSH
36770: LD_INT 2
36772: PUSH
36773: LD_INT 0
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: LD_INT 2
36782: PUSH
36783: LD_INT 1
36785: PUSH
36786: EMPTY
36787: LIST
36788: LIST
36789: PUSH
36790: LD_INT 2
36792: PUSH
36793: LD_INT 2
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: PUSH
36800: LD_INT 1
36802: PUSH
36803: LD_INT 2
36805: PUSH
36806: EMPTY
36807: LIST
36808: LIST
36809: PUSH
36810: LD_INT 1
36812: NEG
36813: PUSH
36814: LD_INT 1
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: PUSH
36821: LD_INT 2
36823: NEG
36824: PUSH
36825: LD_INT 0
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: PUSH
36832: LD_INT 2
36834: NEG
36835: PUSH
36836: LD_INT 1
36838: NEG
36839: PUSH
36840: EMPTY
36841: LIST
36842: LIST
36843: PUSH
36844: LD_INT 2
36846: NEG
36847: PUSH
36848: LD_INT 2
36850: NEG
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: PUSH
36856: LD_INT 2
36858: NEG
36859: PUSH
36860: LD_INT 3
36862: NEG
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 2
36870: PUSH
36871: LD_INT 1
36873: NEG
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: PUSH
36879: LD_INT 3
36881: PUSH
36882: LD_INT 0
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 3
36891: PUSH
36892: LD_INT 1
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 3
36901: PUSH
36902: LD_INT 2
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 3
36911: PUSH
36912: LD_INT 3
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: LD_INT 2
36921: PUSH
36922: LD_INT 3
36924: PUSH
36925: EMPTY
36926: LIST
36927: LIST
36928: PUSH
36929: LD_INT 2
36931: NEG
36932: PUSH
36933: LD_INT 1
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: PUSH
36940: LD_INT 3
36942: NEG
36943: PUSH
36944: LD_INT 0
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: LD_INT 3
36953: NEG
36954: PUSH
36955: LD_INT 1
36957: NEG
36958: PUSH
36959: EMPTY
36960: LIST
36961: LIST
36962: PUSH
36963: LD_INT 3
36965: NEG
36966: PUSH
36967: LD_INT 2
36969: NEG
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: PUSH
36975: LD_INT 3
36977: NEG
36978: PUSH
36979: LD_INT 3
36981: NEG
36982: PUSH
36983: EMPTY
36984: LIST
36985: LIST
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: LIST
36991: LIST
36992: LIST
36993: LIST
36994: LIST
36995: LIST
36996: LIST
36997: LIST
36998: LIST
36999: LIST
37000: LIST
37001: LIST
37002: LIST
37003: LIST
37004: LIST
37005: LIST
37006: LIST
37007: LIST
37008: LIST
37009: LIST
37010: LIST
37011: LIST
37012: LIST
37013: LIST
37014: LIST
37015: LIST
37016: LIST
37017: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37018: LD_ADDR_VAR 0 42
37022: PUSH
37023: LD_INT 0
37025: PUSH
37026: LD_INT 0
37028: PUSH
37029: EMPTY
37030: LIST
37031: LIST
37032: PUSH
37033: LD_INT 0
37035: PUSH
37036: LD_INT 1
37038: NEG
37039: PUSH
37040: EMPTY
37041: LIST
37042: LIST
37043: PUSH
37044: LD_INT 1
37046: PUSH
37047: LD_INT 0
37049: PUSH
37050: EMPTY
37051: LIST
37052: LIST
37053: PUSH
37054: LD_INT 1
37056: PUSH
37057: LD_INT 1
37059: PUSH
37060: EMPTY
37061: LIST
37062: LIST
37063: PUSH
37064: LD_INT 0
37066: PUSH
37067: LD_INT 1
37069: PUSH
37070: EMPTY
37071: LIST
37072: LIST
37073: PUSH
37074: LD_INT 1
37076: NEG
37077: PUSH
37078: LD_INT 0
37080: PUSH
37081: EMPTY
37082: LIST
37083: LIST
37084: PUSH
37085: LD_INT 1
37087: NEG
37088: PUSH
37089: LD_INT 1
37091: NEG
37092: PUSH
37093: EMPTY
37094: LIST
37095: LIST
37096: PUSH
37097: LD_INT 1
37099: NEG
37100: PUSH
37101: LD_INT 2
37103: NEG
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: LD_INT 0
37111: PUSH
37112: LD_INT 2
37114: NEG
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: LD_INT 1
37122: PUSH
37123: LD_INT 1
37125: NEG
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 2
37133: PUSH
37134: LD_INT 1
37136: PUSH
37137: EMPTY
37138: LIST
37139: LIST
37140: PUSH
37141: LD_INT 2
37143: PUSH
37144: LD_INT 2
37146: PUSH
37147: EMPTY
37148: LIST
37149: LIST
37150: PUSH
37151: LD_INT 1
37153: PUSH
37154: LD_INT 2
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 0
37163: PUSH
37164: LD_INT 2
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 1
37173: NEG
37174: PUSH
37175: LD_INT 1
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 2
37184: NEG
37185: PUSH
37186: LD_INT 1
37188: NEG
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: LD_INT 2
37196: NEG
37197: PUSH
37198: LD_INT 2
37200: NEG
37201: PUSH
37202: EMPTY
37203: LIST
37204: LIST
37205: PUSH
37206: LD_INT 2
37208: NEG
37209: PUSH
37210: LD_INT 3
37212: NEG
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: PUSH
37218: LD_INT 1
37220: NEG
37221: PUSH
37222: LD_INT 3
37224: NEG
37225: PUSH
37226: EMPTY
37227: LIST
37228: LIST
37229: PUSH
37230: LD_INT 0
37232: PUSH
37233: LD_INT 3
37235: NEG
37236: PUSH
37237: EMPTY
37238: LIST
37239: LIST
37240: PUSH
37241: LD_INT 1
37243: PUSH
37244: LD_INT 2
37246: NEG
37247: PUSH
37248: EMPTY
37249: LIST
37250: LIST
37251: PUSH
37252: LD_INT 3
37254: PUSH
37255: LD_INT 2
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 3
37264: PUSH
37265: LD_INT 3
37267: PUSH
37268: EMPTY
37269: LIST
37270: LIST
37271: PUSH
37272: LD_INT 2
37274: PUSH
37275: LD_INT 3
37277: PUSH
37278: EMPTY
37279: LIST
37280: LIST
37281: PUSH
37282: LD_INT 1
37284: PUSH
37285: LD_INT 3
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 0
37294: PUSH
37295: LD_INT 3
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: LD_INT 1
37304: NEG
37305: PUSH
37306: LD_INT 2
37308: PUSH
37309: EMPTY
37310: LIST
37311: LIST
37312: PUSH
37313: LD_INT 3
37315: NEG
37316: PUSH
37317: LD_INT 2
37319: NEG
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: PUSH
37325: LD_INT 3
37327: NEG
37328: PUSH
37329: LD_INT 3
37331: NEG
37332: PUSH
37333: EMPTY
37334: LIST
37335: LIST
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: LIST
37341: LIST
37342: LIST
37343: LIST
37344: LIST
37345: LIST
37346: LIST
37347: LIST
37348: LIST
37349: LIST
37350: LIST
37351: LIST
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: LIST
37365: LIST
37366: LIST
37367: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37368: LD_ADDR_VAR 0 43
37372: PUSH
37373: LD_INT 0
37375: PUSH
37376: LD_INT 0
37378: PUSH
37379: EMPTY
37380: LIST
37381: LIST
37382: PUSH
37383: LD_INT 0
37385: PUSH
37386: LD_INT 1
37388: NEG
37389: PUSH
37390: EMPTY
37391: LIST
37392: LIST
37393: PUSH
37394: LD_INT 1
37396: PUSH
37397: LD_INT 0
37399: PUSH
37400: EMPTY
37401: LIST
37402: LIST
37403: PUSH
37404: LD_INT 1
37406: PUSH
37407: LD_INT 1
37409: PUSH
37410: EMPTY
37411: LIST
37412: LIST
37413: PUSH
37414: LD_INT 0
37416: PUSH
37417: LD_INT 1
37419: PUSH
37420: EMPTY
37421: LIST
37422: LIST
37423: PUSH
37424: LD_INT 1
37426: NEG
37427: PUSH
37428: LD_INT 0
37430: PUSH
37431: EMPTY
37432: LIST
37433: LIST
37434: PUSH
37435: LD_INT 1
37437: NEG
37438: PUSH
37439: LD_INT 1
37441: NEG
37442: PUSH
37443: EMPTY
37444: LIST
37445: LIST
37446: PUSH
37447: LD_INT 1
37449: NEG
37450: PUSH
37451: LD_INT 2
37453: NEG
37454: PUSH
37455: EMPTY
37456: LIST
37457: LIST
37458: PUSH
37459: LD_INT 0
37461: PUSH
37462: LD_INT 2
37464: NEG
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 1
37472: PUSH
37473: LD_INT 1
37475: NEG
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PUSH
37481: LD_INT 2
37483: PUSH
37484: LD_INT 0
37486: PUSH
37487: EMPTY
37488: LIST
37489: LIST
37490: PUSH
37491: LD_INT 2
37493: PUSH
37494: LD_INT 1
37496: PUSH
37497: EMPTY
37498: LIST
37499: LIST
37500: PUSH
37501: LD_INT 1
37503: PUSH
37504: LD_INT 2
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: LD_INT 0
37513: PUSH
37514: LD_INT 2
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PUSH
37521: LD_INT 1
37523: NEG
37524: PUSH
37525: LD_INT 1
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PUSH
37532: LD_INT 2
37534: NEG
37535: PUSH
37536: LD_INT 0
37538: PUSH
37539: EMPTY
37540: LIST
37541: LIST
37542: PUSH
37543: LD_INT 2
37545: NEG
37546: PUSH
37547: LD_INT 1
37549: NEG
37550: PUSH
37551: EMPTY
37552: LIST
37553: LIST
37554: PUSH
37555: LD_INT 1
37557: NEG
37558: PUSH
37559: LD_INT 3
37561: NEG
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: LD_INT 0
37569: PUSH
37570: LD_INT 3
37572: NEG
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: LD_INT 1
37580: PUSH
37581: LD_INT 2
37583: NEG
37584: PUSH
37585: EMPTY
37586: LIST
37587: LIST
37588: PUSH
37589: LD_INT 2
37591: PUSH
37592: LD_INT 1
37594: NEG
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PUSH
37600: LD_INT 3
37602: PUSH
37603: LD_INT 0
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 3
37612: PUSH
37613: LD_INT 1
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 1
37622: PUSH
37623: LD_INT 3
37625: PUSH
37626: EMPTY
37627: LIST
37628: LIST
37629: PUSH
37630: LD_INT 0
37632: PUSH
37633: LD_INT 3
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 1
37642: NEG
37643: PUSH
37644: LD_INT 2
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 2
37653: NEG
37654: PUSH
37655: LD_INT 1
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 3
37664: NEG
37665: PUSH
37666: LD_INT 0
37668: PUSH
37669: EMPTY
37670: LIST
37671: LIST
37672: PUSH
37673: LD_INT 3
37675: NEG
37676: PUSH
37677: LD_INT 1
37679: NEG
37680: PUSH
37681: EMPTY
37682: LIST
37683: LIST
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: LIST
37689: LIST
37690: LIST
37691: LIST
37692: LIST
37693: LIST
37694: LIST
37695: LIST
37696: LIST
37697: LIST
37698: LIST
37699: LIST
37700: LIST
37701: LIST
37702: LIST
37703: LIST
37704: LIST
37705: LIST
37706: LIST
37707: LIST
37708: LIST
37709: LIST
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37716: LD_ADDR_VAR 0 44
37720: PUSH
37721: LD_INT 0
37723: PUSH
37724: LD_INT 0
37726: PUSH
37727: EMPTY
37728: LIST
37729: LIST
37730: PUSH
37731: LD_INT 0
37733: PUSH
37734: LD_INT 1
37736: NEG
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: PUSH
37742: LD_INT 1
37744: PUSH
37745: LD_INT 0
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: LD_INT 1
37754: PUSH
37755: LD_INT 1
37757: PUSH
37758: EMPTY
37759: LIST
37760: LIST
37761: PUSH
37762: LD_INT 0
37764: PUSH
37765: LD_INT 1
37767: PUSH
37768: EMPTY
37769: LIST
37770: LIST
37771: PUSH
37772: LD_INT 1
37774: NEG
37775: PUSH
37776: LD_INT 0
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: PUSH
37783: LD_INT 1
37785: NEG
37786: PUSH
37787: LD_INT 1
37789: NEG
37790: PUSH
37791: EMPTY
37792: LIST
37793: LIST
37794: PUSH
37795: LD_INT 1
37797: NEG
37798: PUSH
37799: LD_INT 2
37801: NEG
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: LD_INT 1
37809: PUSH
37810: LD_INT 1
37812: NEG
37813: PUSH
37814: EMPTY
37815: LIST
37816: LIST
37817: PUSH
37818: LD_INT 2
37820: PUSH
37821: LD_INT 0
37823: PUSH
37824: EMPTY
37825: LIST
37826: LIST
37827: PUSH
37828: LD_INT 2
37830: PUSH
37831: LD_INT 1
37833: PUSH
37834: EMPTY
37835: LIST
37836: LIST
37837: PUSH
37838: LD_INT 2
37840: PUSH
37841: LD_INT 2
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 1
37850: PUSH
37851: LD_INT 2
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PUSH
37858: LD_INT 1
37860: NEG
37861: PUSH
37862: LD_INT 1
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 2
37871: NEG
37872: PUSH
37873: LD_INT 0
37875: PUSH
37876: EMPTY
37877: LIST
37878: LIST
37879: PUSH
37880: LD_INT 2
37882: NEG
37883: PUSH
37884: LD_INT 1
37886: NEG
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: PUSH
37892: LD_INT 2
37894: NEG
37895: PUSH
37896: LD_INT 2
37898: NEG
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: LD_INT 2
37906: NEG
37907: PUSH
37908: LD_INT 3
37910: NEG
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: PUSH
37916: LD_INT 2
37918: PUSH
37919: LD_INT 1
37921: NEG
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: PUSH
37927: LD_INT 3
37929: PUSH
37930: LD_INT 0
37932: PUSH
37933: EMPTY
37934: LIST
37935: LIST
37936: PUSH
37937: LD_INT 3
37939: PUSH
37940: LD_INT 1
37942: PUSH
37943: EMPTY
37944: LIST
37945: LIST
37946: PUSH
37947: LD_INT 3
37949: PUSH
37950: LD_INT 2
37952: PUSH
37953: EMPTY
37954: LIST
37955: LIST
37956: PUSH
37957: LD_INT 3
37959: PUSH
37960: LD_INT 3
37962: PUSH
37963: EMPTY
37964: LIST
37965: LIST
37966: PUSH
37967: LD_INT 2
37969: PUSH
37970: LD_INT 3
37972: PUSH
37973: EMPTY
37974: LIST
37975: LIST
37976: PUSH
37977: LD_INT 2
37979: NEG
37980: PUSH
37981: LD_INT 1
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: PUSH
37988: LD_INT 3
37990: NEG
37991: PUSH
37992: LD_INT 0
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 3
38001: NEG
38002: PUSH
38003: LD_INT 1
38005: NEG
38006: PUSH
38007: EMPTY
38008: LIST
38009: LIST
38010: PUSH
38011: LD_INT 3
38013: NEG
38014: PUSH
38015: LD_INT 2
38017: NEG
38018: PUSH
38019: EMPTY
38020: LIST
38021: LIST
38022: PUSH
38023: LD_INT 3
38025: NEG
38026: PUSH
38027: LD_INT 3
38029: NEG
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38066: LD_ADDR_VAR 0 45
38070: PUSH
38071: LD_INT 0
38073: PUSH
38074: LD_INT 0
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 0
38083: PUSH
38084: LD_INT 1
38086: NEG
38087: PUSH
38088: EMPTY
38089: LIST
38090: LIST
38091: PUSH
38092: LD_INT 1
38094: PUSH
38095: LD_INT 0
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: LD_INT 1
38104: PUSH
38105: LD_INT 1
38107: PUSH
38108: EMPTY
38109: LIST
38110: LIST
38111: PUSH
38112: LD_INT 0
38114: PUSH
38115: LD_INT 1
38117: PUSH
38118: EMPTY
38119: LIST
38120: LIST
38121: PUSH
38122: LD_INT 1
38124: NEG
38125: PUSH
38126: LD_INT 0
38128: PUSH
38129: EMPTY
38130: LIST
38131: LIST
38132: PUSH
38133: LD_INT 1
38135: NEG
38136: PUSH
38137: LD_INT 1
38139: NEG
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: PUSH
38145: LD_INT 1
38147: NEG
38148: PUSH
38149: LD_INT 2
38151: NEG
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: LD_INT 0
38159: PUSH
38160: LD_INT 2
38162: NEG
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 1
38170: PUSH
38171: LD_INT 1
38173: NEG
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 2
38181: PUSH
38182: LD_INT 1
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PUSH
38189: LD_INT 2
38191: PUSH
38192: LD_INT 2
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 1
38201: PUSH
38202: LD_INT 2
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: PUSH
38209: LD_INT 0
38211: PUSH
38212: LD_INT 2
38214: PUSH
38215: EMPTY
38216: LIST
38217: LIST
38218: PUSH
38219: LD_INT 1
38221: NEG
38222: PUSH
38223: LD_INT 1
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 2
38232: NEG
38233: PUSH
38234: LD_INT 1
38236: NEG
38237: PUSH
38238: EMPTY
38239: LIST
38240: LIST
38241: PUSH
38242: LD_INT 2
38244: NEG
38245: PUSH
38246: LD_INT 2
38248: NEG
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 2
38256: NEG
38257: PUSH
38258: LD_INT 3
38260: NEG
38261: PUSH
38262: EMPTY
38263: LIST
38264: LIST
38265: PUSH
38266: LD_INT 1
38268: NEG
38269: PUSH
38270: LD_INT 3
38272: NEG
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 0
38280: PUSH
38281: LD_INT 3
38283: NEG
38284: PUSH
38285: EMPTY
38286: LIST
38287: LIST
38288: PUSH
38289: LD_INT 1
38291: PUSH
38292: LD_INT 2
38294: NEG
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 3
38302: PUSH
38303: LD_INT 2
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 3
38312: PUSH
38313: LD_INT 3
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: PUSH
38320: LD_INT 2
38322: PUSH
38323: LD_INT 3
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: LD_INT 1
38332: PUSH
38333: LD_INT 3
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 0
38342: PUSH
38343: LD_INT 3
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: LD_INT 1
38352: NEG
38353: PUSH
38354: LD_INT 2
38356: PUSH
38357: EMPTY
38358: LIST
38359: LIST
38360: PUSH
38361: LD_INT 3
38363: NEG
38364: PUSH
38365: LD_INT 2
38367: NEG
38368: PUSH
38369: EMPTY
38370: LIST
38371: LIST
38372: PUSH
38373: LD_INT 3
38375: NEG
38376: PUSH
38377: LD_INT 3
38379: NEG
38380: PUSH
38381: EMPTY
38382: LIST
38383: LIST
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: LIST
38389: LIST
38390: LIST
38391: LIST
38392: LIST
38393: LIST
38394: LIST
38395: LIST
38396: LIST
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: LIST
38408: LIST
38409: LIST
38410: LIST
38411: LIST
38412: LIST
38413: LIST
38414: LIST
38415: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38416: LD_ADDR_VAR 0 46
38420: PUSH
38421: LD_INT 0
38423: PUSH
38424: LD_INT 0
38426: PUSH
38427: EMPTY
38428: LIST
38429: LIST
38430: PUSH
38431: LD_INT 0
38433: PUSH
38434: LD_INT 1
38436: NEG
38437: PUSH
38438: EMPTY
38439: LIST
38440: LIST
38441: PUSH
38442: LD_INT 1
38444: PUSH
38445: LD_INT 0
38447: PUSH
38448: EMPTY
38449: LIST
38450: LIST
38451: PUSH
38452: LD_INT 1
38454: PUSH
38455: LD_INT 1
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: PUSH
38462: LD_INT 0
38464: PUSH
38465: LD_INT 1
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 1
38474: NEG
38475: PUSH
38476: LD_INT 0
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: PUSH
38483: LD_INT 1
38485: NEG
38486: PUSH
38487: LD_INT 1
38489: NEG
38490: PUSH
38491: EMPTY
38492: LIST
38493: LIST
38494: PUSH
38495: LD_INT 1
38497: NEG
38498: PUSH
38499: LD_INT 2
38501: NEG
38502: PUSH
38503: EMPTY
38504: LIST
38505: LIST
38506: PUSH
38507: LD_INT 0
38509: PUSH
38510: LD_INT 2
38512: NEG
38513: PUSH
38514: EMPTY
38515: LIST
38516: LIST
38517: PUSH
38518: LD_INT 1
38520: PUSH
38521: LD_INT 1
38523: NEG
38524: PUSH
38525: EMPTY
38526: LIST
38527: LIST
38528: PUSH
38529: LD_INT 2
38531: PUSH
38532: LD_INT 0
38534: PUSH
38535: EMPTY
38536: LIST
38537: LIST
38538: PUSH
38539: LD_INT 2
38541: PUSH
38542: LD_INT 1
38544: PUSH
38545: EMPTY
38546: LIST
38547: LIST
38548: PUSH
38549: LD_INT 1
38551: PUSH
38552: LD_INT 2
38554: PUSH
38555: EMPTY
38556: LIST
38557: LIST
38558: PUSH
38559: LD_INT 0
38561: PUSH
38562: LD_INT 2
38564: PUSH
38565: EMPTY
38566: LIST
38567: LIST
38568: PUSH
38569: LD_INT 1
38571: NEG
38572: PUSH
38573: LD_INT 1
38575: PUSH
38576: EMPTY
38577: LIST
38578: LIST
38579: PUSH
38580: LD_INT 2
38582: NEG
38583: PUSH
38584: LD_INT 0
38586: PUSH
38587: EMPTY
38588: LIST
38589: LIST
38590: PUSH
38591: LD_INT 2
38593: NEG
38594: PUSH
38595: LD_INT 1
38597: NEG
38598: PUSH
38599: EMPTY
38600: LIST
38601: LIST
38602: PUSH
38603: LD_INT 1
38605: NEG
38606: PUSH
38607: LD_INT 3
38609: NEG
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: LD_INT 0
38617: PUSH
38618: LD_INT 3
38620: NEG
38621: PUSH
38622: EMPTY
38623: LIST
38624: LIST
38625: PUSH
38626: LD_INT 1
38628: PUSH
38629: LD_INT 2
38631: NEG
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 2
38639: PUSH
38640: LD_INT 1
38642: NEG
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 3
38650: PUSH
38651: LD_INT 0
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 3
38660: PUSH
38661: LD_INT 1
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 1
38670: PUSH
38671: LD_INT 3
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 0
38680: PUSH
38681: LD_INT 3
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 1
38690: NEG
38691: PUSH
38692: LD_INT 2
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 2
38701: NEG
38702: PUSH
38703: LD_INT 1
38705: PUSH
38706: EMPTY
38707: LIST
38708: LIST
38709: PUSH
38710: LD_INT 3
38712: NEG
38713: PUSH
38714: LD_INT 0
38716: PUSH
38717: EMPTY
38718: LIST
38719: LIST
38720: PUSH
38721: LD_INT 3
38723: NEG
38724: PUSH
38725: LD_INT 1
38727: NEG
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: LIST
38744: LIST
38745: LIST
38746: LIST
38747: LIST
38748: LIST
38749: LIST
38750: LIST
38751: LIST
38752: LIST
38753: LIST
38754: LIST
38755: LIST
38756: LIST
38757: LIST
38758: LIST
38759: LIST
38760: LIST
38761: LIST
38762: LIST
38763: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38764: LD_ADDR_VAR 0 47
38768: PUSH
38769: LD_INT 0
38771: PUSH
38772: LD_INT 0
38774: PUSH
38775: EMPTY
38776: LIST
38777: LIST
38778: PUSH
38779: LD_INT 0
38781: PUSH
38782: LD_INT 1
38784: NEG
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: PUSH
38790: LD_INT 1
38792: PUSH
38793: LD_INT 0
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: LD_INT 1
38802: PUSH
38803: LD_INT 1
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: PUSH
38810: LD_INT 0
38812: PUSH
38813: LD_INT 1
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PUSH
38820: LD_INT 1
38822: NEG
38823: PUSH
38824: LD_INT 0
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 1
38833: NEG
38834: PUSH
38835: LD_INT 1
38837: NEG
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: PUSH
38843: LD_INT 1
38845: NEG
38846: PUSH
38847: LD_INT 2
38849: NEG
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: LD_INT 0
38857: PUSH
38858: LD_INT 2
38860: NEG
38861: PUSH
38862: EMPTY
38863: LIST
38864: LIST
38865: PUSH
38866: LD_INT 1
38868: PUSH
38869: LD_INT 1
38871: NEG
38872: PUSH
38873: EMPTY
38874: LIST
38875: LIST
38876: PUSH
38877: LD_INT 2
38879: NEG
38880: PUSH
38881: LD_INT 1
38883: NEG
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: LD_INT 2
38891: NEG
38892: PUSH
38893: LD_INT 2
38895: NEG
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: LIST
38905: LIST
38906: LIST
38907: LIST
38908: LIST
38909: LIST
38910: LIST
38911: LIST
38912: LIST
38913: LIST
38914: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38915: LD_ADDR_VAR 0 48
38919: PUSH
38920: LD_INT 0
38922: PUSH
38923: LD_INT 0
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PUSH
38930: LD_INT 0
38932: PUSH
38933: LD_INT 1
38935: NEG
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PUSH
38941: LD_INT 1
38943: PUSH
38944: LD_INT 0
38946: PUSH
38947: EMPTY
38948: LIST
38949: LIST
38950: PUSH
38951: LD_INT 1
38953: PUSH
38954: LD_INT 1
38956: PUSH
38957: EMPTY
38958: LIST
38959: LIST
38960: PUSH
38961: LD_INT 0
38963: PUSH
38964: LD_INT 1
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 1
38973: NEG
38974: PUSH
38975: LD_INT 0
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 1
38984: NEG
38985: PUSH
38986: LD_INT 1
38988: NEG
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: PUSH
38994: LD_INT 1
38996: NEG
38997: PUSH
38998: LD_INT 2
39000: NEG
39001: PUSH
39002: EMPTY
39003: LIST
39004: LIST
39005: PUSH
39006: LD_INT 0
39008: PUSH
39009: LD_INT 2
39011: NEG
39012: PUSH
39013: EMPTY
39014: LIST
39015: LIST
39016: PUSH
39017: LD_INT 1
39019: PUSH
39020: LD_INT 1
39022: NEG
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: PUSH
39028: LD_INT 2
39030: PUSH
39031: LD_INT 0
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 2
39040: PUSH
39041: LD_INT 1
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: LIST
39052: LIST
39053: LIST
39054: LIST
39055: LIST
39056: LIST
39057: LIST
39058: LIST
39059: LIST
39060: LIST
39061: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39062: LD_ADDR_VAR 0 49
39066: PUSH
39067: LD_INT 0
39069: PUSH
39070: LD_INT 0
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PUSH
39077: LD_INT 0
39079: PUSH
39080: LD_INT 1
39082: NEG
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: LD_INT 1
39090: PUSH
39091: LD_INT 0
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 1
39100: PUSH
39101: LD_INT 1
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: PUSH
39108: LD_INT 0
39110: PUSH
39111: LD_INT 1
39113: PUSH
39114: EMPTY
39115: LIST
39116: LIST
39117: PUSH
39118: LD_INT 1
39120: NEG
39121: PUSH
39122: LD_INT 0
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 1
39131: NEG
39132: PUSH
39133: LD_INT 1
39135: NEG
39136: PUSH
39137: EMPTY
39138: LIST
39139: LIST
39140: PUSH
39141: LD_INT 1
39143: PUSH
39144: LD_INT 1
39146: NEG
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: PUSH
39152: LD_INT 2
39154: PUSH
39155: LD_INT 0
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 2
39164: PUSH
39165: LD_INT 1
39167: PUSH
39168: EMPTY
39169: LIST
39170: LIST
39171: PUSH
39172: LD_INT 2
39174: PUSH
39175: LD_INT 2
39177: PUSH
39178: EMPTY
39179: LIST
39180: LIST
39181: PUSH
39182: LD_INT 1
39184: PUSH
39185: LD_INT 2
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: LIST
39196: LIST
39197: LIST
39198: LIST
39199: LIST
39200: LIST
39201: LIST
39202: LIST
39203: LIST
39204: LIST
39205: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39206: LD_ADDR_VAR 0 50
39210: PUSH
39211: LD_INT 0
39213: PUSH
39214: LD_INT 0
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 0
39223: PUSH
39224: LD_INT 1
39226: NEG
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: PUSH
39232: LD_INT 1
39234: PUSH
39235: LD_INT 0
39237: PUSH
39238: EMPTY
39239: LIST
39240: LIST
39241: PUSH
39242: LD_INT 1
39244: PUSH
39245: LD_INT 1
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 0
39254: PUSH
39255: LD_INT 1
39257: PUSH
39258: EMPTY
39259: LIST
39260: LIST
39261: PUSH
39262: LD_INT 1
39264: NEG
39265: PUSH
39266: LD_INT 0
39268: PUSH
39269: EMPTY
39270: LIST
39271: LIST
39272: PUSH
39273: LD_INT 1
39275: NEG
39276: PUSH
39277: LD_INT 1
39279: NEG
39280: PUSH
39281: EMPTY
39282: LIST
39283: LIST
39284: PUSH
39285: LD_INT 2
39287: PUSH
39288: LD_INT 1
39290: PUSH
39291: EMPTY
39292: LIST
39293: LIST
39294: PUSH
39295: LD_INT 2
39297: PUSH
39298: LD_INT 2
39300: PUSH
39301: EMPTY
39302: LIST
39303: LIST
39304: PUSH
39305: LD_INT 1
39307: PUSH
39308: LD_INT 2
39310: PUSH
39311: EMPTY
39312: LIST
39313: LIST
39314: PUSH
39315: LD_INT 0
39317: PUSH
39318: LD_INT 2
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 1
39327: NEG
39328: PUSH
39329: LD_INT 1
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: EMPTY
39337: LIST
39338: LIST
39339: LIST
39340: LIST
39341: LIST
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39350: LD_ADDR_VAR 0 51
39354: PUSH
39355: LD_INT 0
39357: PUSH
39358: LD_INT 0
39360: PUSH
39361: EMPTY
39362: LIST
39363: LIST
39364: PUSH
39365: LD_INT 0
39367: PUSH
39368: LD_INT 1
39370: NEG
39371: PUSH
39372: EMPTY
39373: LIST
39374: LIST
39375: PUSH
39376: LD_INT 1
39378: PUSH
39379: LD_INT 0
39381: PUSH
39382: EMPTY
39383: LIST
39384: LIST
39385: PUSH
39386: LD_INT 1
39388: PUSH
39389: LD_INT 1
39391: PUSH
39392: EMPTY
39393: LIST
39394: LIST
39395: PUSH
39396: LD_INT 0
39398: PUSH
39399: LD_INT 1
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: PUSH
39406: LD_INT 1
39408: NEG
39409: PUSH
39410: LD_INT 0
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 1
39419: NEG
39420: PUSH
39421: LD_INT 1
39423: NEG
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: LD_INT 1
39431: PUSH
39432: LD_INT 2
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PUSH
39439: LD_INT 0
39441: PUSH
39442: LD_INT 2
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 1
39451: NEG
39452: PUSH
39453: LD_INT 1
39455: PUSH
39456: EMPTY
39457: LIST
39458: LIST
39459: PUSH
39460: LD_INT 2
39462: NEG
39463: PUSH
39464: LD_INT 0
39466: PUSH
39467: EMPTY
39468: LIST
39469: LIST
39470: PUSH
39471: LD_INT 2
39473: NEG
39474: PUSH
39475: LD_INT 1
39477: NEG
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: PUSH
39483: EMPTY
39484: LIST
39485: LIST
39486: LIST
39487: LIST
39488: LIST
39489: LIST
39490: LIST
39491: LIST
39492: LIST
39493: LIST
39494: LIST
39495: LIST
39496: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39497: LD_ADDR_VAR 0 52
39501: PUSH
39502: LD_INT 0
39504: PUSH
39505: LD_INT 0
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: LD_INT 0
39514: PUSH
39515: LD_INT 1
39517: NEG
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 1
39525: PUSH
39526: LD_INT 0
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 1
39535: PUSH
39536: LD_INT 1
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 0
39545: PUSH
39546: LD_INT 1
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: LD_INT 1
39555: NEG
39556: PUSH
39557: LD_INT 0
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 1
39566: NEG
39567: PUSH
39568: LD_INT 1
39570: NEG
39571: PUSH
39572: EMPTY
39573: LIST
39574: LIST
39575: PUSH
39576: LD_INT 1
39578: NEG
39579: PUSH
39580: LD_INT 2
39582: NEG
39583: PUSH
39584: EMPTY
39585: LIST
39586: LIST
39587: PUSH
39588: LD_INT 1
39590: NEG
39591: PUSH
39592: LD_INT 1
39594: PUSH
39595: EMPTY
39596: LIST
39597: LIST
39598: PUSH
39599: LD_INT 2
39601: NEG
39602: PUSH
39603: LD_INT 0
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: PUSH
39610: LD_INT 2
39612: NEG
39613: PUSH
39614: LD_INT 1
39616: NEG
39617: PUSH
39618: EMPTY
39619: LIST
39620: LIST
39621: PUSH
39622: LD_INT 2
39624: NEG
39625: PUSH
39626: LD_INT 2
39628: NEG
39629: PUSH
39630: EMPTY
39631: LIST
39632: LIST
39633: PUSH
39634: EMPTY
39635: LIST
39636: LIST
39637: LIST
39638: LIST
39639: LIST
39640: LIST
39641: LIST
39642: LIST
39643: LIST
39644: LIST
39645: LIST
39646: LIST
39647: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39648: LD_ADDR_VAR 0 53
39652: PUSH
39653: LD_INT 0
39655: PUSH
39656: LD_INT 0
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 0
39665: PUSH
39666: LD_INT 1
39668: NEG
39669: PUSH
39670: EMPTY
39671: LIST
39672: LIST
39673: PUSH
39674: LD_INT 1
39676: PUSH
39677: LD_INT 0
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 1
39686: PUSH
39687: LD_INT 1
39689: PUSH
39690: EMPTY
39691: LIST
39692: LIST
39693: PUSH
39694: LD_INT 0
39696: PUSH
39697: LD_INT 1
39699: PUSH
39700: EMPTY
39701: LIST
39702: LIST
39703: PUSH
39704: LD_INT 1
39706: NEG
39707: PUSH
39708: LD_INT 0
39710: PUSH
39711: EMPTY
39712: LIST
39713: LIST
39714: PUSH
39715: LD_INT 1
39717: NEG
39718: PUSH
39719: LD_INT 1
39721: NEG
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PUSH
39727: LD_INT 1
39729: NEG
39730: PUSH
39731: LD_INT 2
39733: NEG
39734: PUSH
39735: EMPTY
39736: LIST
39737: LIST
39738: PUSH
39739: LD_INT 0
39741: PUSH
39742: LD_INT 2
39744: NEG
39745: PUSH
39746: EMPTY
39747: LIST
39748: LIST
39749: PUSH
39750: LD_INT 1
39752: PUSH
39753: LD_INT 1
39755: NEG
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: PUSH
39761: LD_INT 2
39763: PUSH
39764: LD_INT 0
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: PUSH
39771: LD_INT 2
39773: PUSH
39774: LD_INT 1
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: PUSH
39781: LD_INT 2
39783: PUSH
39784: LD_INT 2
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 1
39793: PUSH
39794: LD_INT 2
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 0
39803: PUSH
39804: LD_INT 2
39806: PUSH
39807: EMPTY
39808: LIST
39809: LIST
39810: PUSH
39811: LD_INT 1
39813: NEG
39814: PUSH
39815: LD_INT 1
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: LD_INT 2
39824: NEG
39825: PUSH
39826: LD_INT 0
39828: PUSH
39829: EMPTY
39830: LIST
39831: LIST
39832: PUSH
39833: LD_INT 2
39835: NEG
39836: PUSH
39837: LD_INT 1
39839: NEG
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 2
39847: NEG
39848: PUSH
39849: LD_INT 2
39851: NEG
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: EMPTY
39858: LIST
39859: LIST
39860: LIST
39861: LIST
39862: LIST
39863: LIST
39864: LIST
39865: LIST
39866: LIST
39867: LIST
39868: LIST
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39878: LD_ADDR_VAR 0 54
39882: PUSH
39883: LD_INT 0
39885: PUSH
39886: LD_INT 0
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: LD_INT 0
39895: PUSH
39896: LD_INT 1
39898: NEG
39899: PUSH
39900: EMPTY
39901: LIST
39902: LIST
39903: PUSH
39904: LD_INT 1
39906: PUSH
39907: LD_INT 0
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 1
39916: PUSH
39917: LD_INT 1
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: PUSH
39924: LD_INT 0
39926: PUSH
39927: LD_INT 1
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: PUSH
39934: LD_INT 1
39936: NEG
39937: PUSH
39938: LD_INT 0
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: PUSH
39945: LD_INT 1
39947: NEG
39948: PUSH
39949: LD_INT 1
39951: NEG
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: LD_INT 1
39959: NEG
39960: PUSH
39961: LD_INT 2
39963: NEG
39964: PUSH
39965: EMPTY
39966: LIST
39967: LIST
39968: PUSH
39969: LD_INT 0
39971: PUSH
39972: LD_INT 2
39974: NEG
39975: PUSH
39976: EMPTY
39977: LIST
39978: LIST
39979: PUSH
39980: LD_INT 1
39982: PUSH
39983: LD_INT 1
39985: NEG
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 2
39993: PUSH
39994: LD_INT 0
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: LD_INT 2
40003: PUSH
40004: LD_INT 1
40006: PUSH
40007: EMPTY
40008: LIST
40009: LIST
40010: PUSH
40011: LD_INT 2
40013: PUSH
40014: LD_INT 2
40016: PUSH
40017: EMPTY
40018: LIST
40019: LIST
40020: PUSH
40021: LD_INT 1
40023: PUSH
40024: LD_INT 2
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 0
40033: PUSH
40034: LD_INT 2
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: LD_INT 1
40043: NEG
40044: PUSH
40045: LD_INT 1
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 2
40054: NEG
40055: PUSH
40056: LD_INT 0
40058: PUSH
40059: EMPTY
40060: LIST
40061: LIST
40062: PUSH
40063: LD_INT 2
40065: NEG
40066: PUSH
40067: LD_INT 1
40069: NEG
40070: PUSH
40071: EMPTY
40072: LIST
40073: LIST
40074: PUSH
40075: LD_INT 2
40077: NEG
40078: PUSH
40079: LD_INT 2
40081: NEG
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: LIST
40091: LIST
40092: LIST
40093: LIST
40094: LIST
40095: LIST
40096: LIST
40097: LIST
40098: LIST
40099: LIST
40100: LIST
40101: LIST
40102: LIST
40103: LIST
40104: LIST
40105: LIST
40106: LIST
40107: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40108: LD_ADDR_VAR 0 55
40112: PUSH
40113: LD_INT 0
40115: PUSH
40116: LD_INT 0
40118: PUSH
40119: EMPTY
40120: LIST
40121: LIST
40122: PUSH
40123: LD_INT 0
40125: PUSH
40126: LD_INT 1
40128: NEG
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: PUSH
40134: LD_INT 1
40136: PUSH
40137: LD_INT 0
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 1
40146: PUSH
40147: LD_INT 1
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PUSH
40154: LD_INT 0
40156: PUSH
40157: LD_INT 1
40159: PUSH
40160: EMPTY
40161: LIST
40162: LIST
40163: PUSH
40164: LD_INT 1
40166: NEG
40167: PUSH
40168: LD_INT 0
40170: PUSH
40171: EMPTY
40172: LIST
40173: LIST
40174: PUSH
40175: LD_INT 1
40177: NEG
40178: PUSH
40179: LD_INT 1
40181: NEG
40182: PUSH
40183: EMPTY
40184: LIST
40185: LIST
40186: PUSH
40187: LD_INT 1
40189: NEG
40190: PUSH
40191: LD_INT 2
40193: NEG
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: PUSH
40199: LD_INT 0
40201: PUSH
40202: LD_INT 2
40204: NEG
40205: PUSH
40206: EMPTY
40207: LIST
40208: LIST
40209: PUSH
40210: LD_INT 1
40212: PUSH
40213: LD_INT 1
40215: NEG
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PUSH
40221: LD_INT 2
40223: PUSH
40224: LD_INT 0
40226: PUSH
40227: EMPTY
40228: LIST
40229: LIST
40230: PUSH
40231: LD_INT 2
40233: PUSH
40234: LD_INT 1
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 2
40243: PUSH
40244: LD_INT 2
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: LD_INT 1
40253: PUSH
40254: LD_INT 2
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 0
40263: PUSH
40264: LD_INT 2
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: PUSH
40271: LD_INT 1
40273: NEG
40274: PUSH
40275: LD_INT 1
40277: PUSH
40278: EMPTY
40279: LIST
40280: LIST
40281: PUSH
40282: LD_INT 2
40284: NEG
40285: PUSH
40286: LD_INT 0
40288: PUSH
40289: EMPTY
40290: LIST
40291: LIST
40292: PUSH
40293: LD_INT 2
40295: NEG
40296: PUSH
40297: LD_INT 1
40299: NEG
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: LD_INT 2
40307: NEG
40308: PUSH
40309: LD_INT 2
40311: NEG
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: LIST
40321: LIST
40322: LIST
40323: LIST
40324: LIST
40325: LIST
40326: LIST
40327: LIST
40328: LIST
40329: LIST
40330: LIST
40331: LIST
40332: LIST
40333: LIST
40334: LIST
40335: LIST
40336: LIST
40337: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40338: LD_ADDR_VAR 0 56
40342: PUSH
40343: LD_INT 0
40345: PUSH
40346: LD_INT 0
40348: PUSH
40349: EMPTY
40350: LIST
40351: LIST
40352: PUSH
40353: LD_INT 0
40355: PUSH
40356: LD_INT 1
40358: NEG
40359: PUSH
40360: EMPTY
40361: LIST
40362: LIST
40363: PUSH
40364: LD_INT 1
40366: PUSH
40367: LD_INT 0
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 1
40376: PUSH
40377: LD_INT 1
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PUSH
40384: LD_INT 0
40386: PUSH
40387: LD_INT 1
40389: PUSH
40390: EMPTY
40391: LIST
40392: LIST
40393: PUSH
40394: LD_INT 1
40396: NEG
40397: PUSH
40398: LD_INT 0
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 1
40407: NEG
40408: PUSH
40409: LD_INT 1
40411: NEG
40412: PUSH
40413: EMPTY
40414: LIST
40415: LIST
40416: PUSH
40417: LD_INT 1
40419: NEG
40420: PUSH
40421: LD_INT 2
40423: NEG
40424: PUSH
40425: EMPTY
40426: LIST
40427: LIST
40428: PUSH
40429: LD_INT 0
40431: PUSH
40432: LD_INT 2
40434: NEG
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 1
40442: PUSH
40443: LD_INT 1
40445: NEG
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 2
40453: PUSH
40454: LD_INT 0
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 2
40463: PUSH
40464: LD_INT 1
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 2
40473: PUSH
40474: LD_INT 2
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PUSH
40481: LD_INT 1
40483: PUSH
40484: LD_INT 2
40486: PUSH
40487: EMPTY
40488: LIST
40489: LIST
40490: PUSH
40491: LD_INT 0
40493: PUSH
40494: LD_INT 2
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 1
40503: NEG
40504: PUSH
40505: LD_INT 1
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 2
40514: NEG
40515: PUSH
40516: LD_INT 0
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PUSH
40523: LD_INT 2
40525: NEG
40526: PUSH
40527: LD_INT 1
40529: NEG
40530: PUSH
40531: EMPTY
40532: LIST
40533: LIST
40534: PUSH
40535: LD_INT 2
40537: NEG
40538: PUSH
40539: LD_INT 2
40541: NEG
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: PUSH
40547: EMPTY
40548: LIST
40549: LIST
40550: LIST
40551: LIST
40552: LIST
40553: LIST
40554: LIST
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: LIST
40560: LIST
40561: LIST
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40568: LD_ADDR_VAR 0 57
40572: PUSH
40573: LD_INT 0
40575: PUSH
40576: LD_INT 0
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: PUSH
40583: LD_INT 0
40585: PUSH
40586: LD_INT 1
40588: NEG
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: PUSH
40594: LD_INT 1
40596: PUSH
40597: LD_INT 0
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PUSH
40604: LD_INT 1
40606: PUSH
40607: LD_INT 1
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 0
40616: PUSH
40617: LD_INT 1
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 1
40626: NEG
40627: PUSH
40628: LD_INT 0
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 1
40637: NEG
40638: PUSH
40639: LD_INT 1
40641: NEG
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: PUSH
40647: LD_INT 1
40649: NEG
40650: PUSH
40651: LD_INT 2
40653: NEG
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 0
40661: PUSH
40662: LD_INT 2
40664: NEG
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: PUSH
40670: LD_INT 1
40672: PUSH
40673: LD_INT 1
40675: NEG
40676: PUSH
40677: EMPTY
40678: LIST
40679: LIST
40680: PUSH
40681: LD_INT 2
40683: PUSH
40684: LD_INT 0
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: LD_INT 2
40693: PUSH
40694: LD_INT 1
40696: PUSH
40697: EMPTY
40698: LIST
40699: LIST
40700: PUSH
40701: LD_INT 2
40703: PUSH
40704: LD_INT 2
40706: PUSH
40707: EMPTY
40708: LIST
40709: LIST
40710: PUSH
40711: LD_INT 1
40713: PUSH
40714: LD_INT 2
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: PUSH
40721: LD_INT 0
40723: PUSH
40724: LD_INT 2
40726: PUSH
40727: EMPTY
40728: LIST
40729: LIST
40730: PUSH
40731: LD_INT 1
40733: NEG
40734: PUSH
40735: LD_INT 1
40737: PUSH
40738: EMPTY
40739: LIST
40740: LIST
40741: PUSH
40742: LD_INT 2
40744: NEG
40745: PUSH
40746: LD_INT 0
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: PUSH
40753: LD_INT 2
40755: NEG
40756: PUSH
40757: LD_INT 1
40759: NEG
40760: PUSH
40761: EMPTY
40762: LIST
40763: LIST
40764: PUSH
40765: LD_INT 2
40767: NEG
40768: PUSH
40769: LD_INT 2
40771: NEG
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: PUSH
40777: EMPTY
40778: LIST
40779: LIST
40780: LIST
40781: LIST
40782: LIST
40783: LIST
40784: LIST
40785: LIST
40786: LIST
40787: LIST
40788: LIST
40789: LIST
40790: LIST
40791: LIST
40792: LIST
40793: LIST
40794: LIST
40795: LIST
40796: LIST
40797: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40798: LD_ADDR_VAR 0 58
40802: PUSH
40803: LD_INT 0
40805: PUSH
40806: LD_INT 0
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: LD_INT 0
40815: PUSH
40816: LD_INT 1
40818: NEG
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: PUSH
40824: LD_INT 1
40826: PUSH
40827: LD_INT 0
40829: PUSH
40830: EMPTY
40831: LIST
40832: LIST
40833: PUSH
40834: LD_INT 1
40836: PUSH
40837: LD_INT 1
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: LD_INT 0
40846: PUSH
40847: LD_INT 1
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PUSH
40854: LD_INT 1
40856: NEG
40857: PUSH
40858: LD_INT 0
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: PUSH
40865: LD_INT 1
40867: NEG
40868: PUSH
40869: LD_INT 1
40871: NEG
40872: PUSH
40873: EMPTY
40874: LIST
40875: LIST
40876: PUSH
40877: LD_INT 1
40879: NEG
40880: PUSH
40881: LD_INT 2
40883: NEG
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 0
40891: PUSH
40892: LD_INT 2
40894: NEG
40895: PUSH
40896: EMPTY
40897: LIST
40898: LIST
40899: PUSH
40900: LD_INT 1
40902: PUSH
40903: LD_INT 1
40905: NEG
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: PUSH
40911: LD_INT 2
40913: PUSH
40914: LD_INT 0
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: LD_INT 2
40923: PUSH
40924: LD_INT 1
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: LD_INT 2
40933: PUSH
40934: LD_INT 2
40936: PUSH
40937: EMPTY
40938: LIST
40939: LIST
40940: PUSH
40941: LD_INT 1
40943: PUSH
40944: LD_INT 2
40946: PUSH
40947: EMPTY
40948: LIST
40949: LIST
40950: PUSH
40951: LD_INT 0
40953: PUSH
40954: LD_INT 2
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 1
40963: NEG
40964: PUSH
40965: LD_INT 1
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 2
40974: NEG
40975: PUSH
40976: LD_INT 0
40978: PUSH
40979: EMPTY
40980: LIST
40981: LIST
40982: PUSH
40983: LD_INT 2
40985: NEG
40986: PUSH
40987: LD_INT 1
40989: NEG
40990: PUSH
40991: EMPTY
40992: LIST
40993: LIST
40994: PUSH
40995: LD_INT 2
40997: NEG
40998: PUSH
40999: LD_INT 2
41001: NEG
41002: PUSH
41003: EMPTY
41004: LIST
41005: LIST
41006: PUSH
41007: EMPTY
41008: LIST
41009: LIST
41010: LIST
41011: LIST
41012: LIST
41013: LIST
41014: LIST
41015: LIST
41016: LIST
41017: LIST
41018: LIST
41019: LIST
41020: LIST
41021: LIST
41022: LIST
41023: LIST
41024: LIST
41025: LIST
41026: LIST
41027: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41028: LD_ADDR_VAR 0 59
41032: PUSH
41033: LD_INT 0
41035: PUSH
41036: LD_INT 0
41038: PUSH
41039: EMPTY
41040: LIST
41041: LIST
41042: PUSH
41043: LD_INT 0
41045: PUSH
41046: LD_INT 1
41048: NEG
41049: PUSH
41050: EMPTY
41051: LIST
41052: LIST
41053: PUSH
41054: LD_INT 1
41056: PUSH
41057: LD_INT 0
41059: PUSH
41060: EMPTY
41061: LIST
41062: LIST
41063: PUSH
41064: LD_INT 1
41066: PUSH
41067: LD_INT 1
41069: PUSH
41070: EMPTY
41071: LIST
41072: LIST
41073: PUSH
41074: LD_INT 0
41076: PUSH
41077: LD_INT 1
41079: PUSH
41080: EMPTY
41081: LIST
41082: LIST
41083: PUSH
41084: LD_INT 1
41086: NEG
41087: PUSH
41088: LD_INT 0
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: PUSH
41095: LD_INT 1
41097: NEG
41098: PUSH
41099: LD_INT 1
41101: NEG
41102: PUSH
41103: EMPTY
41104: LIST
41105: LIST
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: LIST
41111: LIST
41112: LIST
41113: LIST
41114: LIST
41115: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41116: LD_ADDR_VAR 0 60
41120: PUSH
41121: LD_INT 0
41123: PUSH
41124: LD_INT 0
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 0
41133: PUSH
41134: LD_INT 1
41136: NEG
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 1
41144: PUSH
41145: LD_INT 0
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 1
41154: PUSH
41155: LD_INT 1
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 0
41164: PUSH
41165: LD_INT 1
41167: PUSH
41168: EMPTY
41169: LIST
41170: LIST
41171: PUSH
41172: LD_INT 1
41174: NEG
41175: PUSH
41176: LD_INT 0
41178: PUSH
41179: EMPTY
41180: LIST
41181: LIST
41182: PUSH
41183: LD_INT 1
41185: NEG
41186: PUSH
41187: LD_INT 1
41189: NEG
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: PUSH
41195: EMPTY
41196: LIST
41197: LIST
41198: LIST
41199: LIST
41200: LIST
41201: LIST
41202: LIST
41203: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41204: LD_ADDR_VAR 0 61
41208: PUSH
41209: LD_INT 0
41211: PUSH
41212: LD_INT 0
41214: PUSH
41215: EMPTY
41216: LIST
41217: LIST
41218: PUSH
41219: LD_INT 0
41221: PUSH
41222: LD_INT 1
41224: NEG
41225: PUSH
41226: EMPTY
41227: LIST
41228: LIST
41229: PUSH
41230: LD_INT 1
41232: PUSH
41233: LD_INT 0
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: LD_INT 1
41242: PUSH
41243: LD_INT 1
41245: PUSH
41246: EMPTY
41247: LIST
41248: LIST
41249: PUSH
41250: LD_INT 0
41252: PUSH
41253: LD_INT 1
41255: PUSH
41256: EMPTY
41257: LIST
41258: LIST
41259: PUSH
41260: LD_INT 1
41262: NEG
41263: PUSH
41264: LD_INT 0
41266: PUSH
41267: EMPTY
41268: LIST
41269: LIST
41270: PUSH
41271: LD_INT 1
41273: NEG
41274: PUSH
41275: LD_INT 1
41277: NEG
41278: PUSH
41279: EMPTY
41280: LIST
41281: LIST
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: LIST
41287: LIST
41288: LIST
41289: LIST
41290: LIST
41291: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41292: LD_ADDR_VAR 0 62
41296: PUSH
41297: LD_INT 0
41299: PUSH
41300: LD_INT 0
41302: PUSH
41303: EMPTY
41304: LIST
41305: LIST
41306: PUSH
41307: LD_INT 0
41309: PUSH
41310: LD_INT 1
41312: NEG
41313: PUSH
41314: EMPTY
41315: LIST
41316: LIST
41317: PUSH
41318: LD_INT 1
41320: PUSH
41321: LD_INT 0
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: PUSH
41328: LD_INT 1
41330: PUSH
41331: LD_INT 1
41333: PUSH
41334: EMPTY
41335: LIST
41336: LIST
41337: PUSH
41338: LD_INT 0
41340: PUSH
41341: LD_INT 1
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: LD_INT 1
41350: NEG
41351: PUSH
41352: LD_INT 0
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 1
41361: NEG
41362: PUSH
41363: LD_INT 1
41365: NEG
41366: PUSH
41367: EMPTY
41368: LIST
41369: LIST
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: LIST
41375: LIST
41376: LIST
41377: LIST
41378: LIST
41379: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41380: LD_ADDR_VAR 0 63
41384: PUSH
41385: LD_INT 0
41387: PUSH
41388: LD_INT 0
41390: PUSH
41391: EMPTY
41392: LIST
41393: LIST
41394: PUSH
41395: LD_INT 0
41397: PUSH
41398: LD_INT 1
41400: NEG
41401: PUSH
41402: EMPTY
41403: LIST
41404: LIST
41405: PUSH
41406: LD_INT 1
41408: PUSH
41409: LD_INT 0
41411: PUSH
41412: EMPTY
41413: LIST
41414: LIST
41415: PUSH
41416: LD_INT 1
41418: PUSH
41419: LD_INT 1
41421: PUSH
41422: EMPTY
41423: LIST
41424: LIST
41425: PUSH
41426: LD_INT 0
41428: PUSH
41429: LD_INT 1
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: PUSH
41436: LD_INT 1
41438: NEG
41439: PUSH
41440: LD_INT 0
41442: PUSH
41443: EMPTY
41444: LIST
41445: LIST
41446: PUSH
41447: LD_INT 1
41449: NEG
41450: PUSH
41451: LD_INT 1
41453: NEG
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: PUSH
41459: EMPTY
41460: LIST
41461: LIST
41462: LIST
41463: LIST
41464: LIST
41465: LIST
41466: LIST
41467: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41468: LD_ADDR_VAR 0 64
41472: PUSH
41473: LD_INT 0
41475: PUSH
41476: LD_INT 0
41478: PUSH
41479: EMPTY
41480: LIST
41481: LIST
41482: PUSH
41483: LD_INT 0
41485: PUSH
41486: LD_INT 1
41488: NEG
41489: PUSH
41490: EMPTY
41491: LIST
41492: LIST
41493: PUSH
41494: LD_INT 1
41496: PUSH
41497: LD_INT 0
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 1
41506: PUSH
41507: LD_INT 1
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: PUSH
41514: LD_INT 0
41516: PUSH
41517: LD_INT 1
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: PUSH
41524: LD_INT 1
41526: NEG
41527: PUSH
41528: LD_INT 0
41530: PUSH
41531: EMPTY
41532: LIST
41533: LIST
41534: PUSH
41535: LD_INT 1
41537: NEG
41538: PUSH
41539: LD_INT 1
41541: NEG
41542: PUSH
41543: EMPTY
41544: LIST
41545: LIST
41546: PUSH
41547: EMPTY
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: LIST
41554: LIST
41555: ST_TO_ADDR
// end ; 1 :
41556: GO 47453
41558: LD_INT 1
41560: DOUBLE
41561: EQUAL
41562: IFTRUE 41566
41564: GO 44189
41566: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41567: LD_ADDR_VAR 0 11
41571: PUSH
41572: LD_INT 1
41574: NEG
41575: PUSH
41576: LD_INT 3
41578: NEG
41579: PUSH
41580: EMPTY
41581: LIST
41582: LIST
41583: PUSH
41584: LD_INT 0
41586: PUSH
41587: LD_INT 3
41589: NEG
41590: PUSH
41591: EMPTY
41592: LIST
41593: LIST
41594: PUSH
41595: LD_INT 1
41597: PUSH
41598: LD_INT 2
41600: NEG
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: LIST
41610: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41611: LD_ADDR_VAR 0 12
41615: PUSH
41616: LD_INT 2
41618: PUSH
41619: LD_INT 1
41621: NEG
41622: PUSH
41623: EMPTY
41624: LIST
41625: LIST
41626: PUSH
41627: LD_INT 3
41629: PUSH
41630: LD_INT 0
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: PUSH
41637: LD_INT 3
41639: PUSH
41640: LD_INT 1
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: LIST
41651: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41652: LD_ADDR_VAR 0 13
41656: PUSH
41657: LD_INT 3
41659: PUSH
41660: LD_INT 2
41662: PUSH
41663: EMPTY
41664: LIST
41665: LIST
41666: PUSH
41667: LD_INT 3
41669: PUSH
41670: LD_INT 3
41672: PUSH
41673: EMPTY
41674: LIST
41675: LIST
41676: PUSH
41677: LD_INT 2
41679: PUSH
41680: LD_INT 3
41682: PUSH
41683: EMPTY
41684: LIST
41685: LIST
41686: PUSH
41687: EMPTY
41688: LIST
41689: LIST
41690: LIST
41691: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41692: LD_ADDR_VAR 0 14
41696: PUSH
41697: LD_INT 1
41699: PUSH
41700: LD_INT 3
41702: PUSH
41703: EMPTY
41704: LIST
41705: LIST
41706: PUSH
41707: LD_INT 0
41709: PUSH
41710: LD_INT 3
41712: PUSH
41713: EMPTY
41714: LIST
41715: LIST
41716: PUSH
41717: LD_INT 1
41719: NEG
41720: PUSH
41721: LD_INT 2
41723: PUSH
41724: EMPTY
41725: LIST
41726: LIST
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: LIST
41732: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41733: LD_ADDR_VAR 0 15
41737: PUSH
41738: LD_INT 2
41740: NEG
41741: PUSH
41742: LD_INT 1
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: PUSH
41749: LD_INT 3
41751: NEG
41752: PUSH
41753: LD_INT 0
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 3
41762: NEG
41763: PUSH
41764: LD_INT 1
41766: NEG
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: EMPTY
41773: LIST
41774: LIST
41775: LIST
41776: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41777: LD_ADDR_VAR 0 16
41781: PUSH
41782: LD_INT 2
41784: NEG
41785: PUSH
41786: LD_INT 3
41788: NEG
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: LD_INT 3
41796: NEG
41797: PUSH
41798: LD_INT 2
41800: NEG
41801: PUSH
41802: EMPTY
41803: LIST
41804: LIST
41805: PUSH
41806: LD_INT 3
41808: NEG
41809: PUSH
41810: LD_INT 3
41812: NEG
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: LIST
41822: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41823: LD_ADDR_VAR 0 17
41827: PUSH
41828: LD_INT 1
41830: NEG
41831: PUSH
41832: LD_INT 3
41834: NEG
41835: PUSH
41836: EMPTY
41837: LIST
41838: LIST
41839: PUSH
41840: LD_INT 0
41842: PUSH
41843: LD_INT 3
41845: NEG
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PUSH
41851: LD_INT 1
41853: PUSH
41854: LD_INT 2
41856: NEG
41857: PUSH
41858: EMPTY
41859: LIST
41860: LIST
41861: PUSH
41862: EMPTY
41863: LIST
41864: LIST
41865: LIST
41866: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41867: LD_ADDR_VAR 0 18
41871: PUSH
41872: LD_INT 2
41874: PUSH
41875: LD_INT 1
41877: NEG
41878: PUSH
41879: EMPTY
41880: LIST
41881: LIST
41882: PUSH
41883: LD_INT 3
41885: PUSH
41886: LD_INT 0
41888: PUSH
41889: EMPTY
41890: LIST
41891: LIST
41892: PUSH
41893: LD_INT 3
41895: PUSH
41896: LD_INT 1
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: LIST
41907: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41908: LD_ADDR_VAR 0 19
41912: PUSH
41913: LD_INT 3
41915: PUSH
41916: LD_INT 2
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: PUSH
41923: LD_INT 3
41925: PUSH
41926: LD_INT 3
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PUSH
41933: LD_INT 2
41935: PUSH
41936: LD_INT 3
41938: PUSH
41939: EMPTY
41940: LIST
41941: LIST
41942: PUSH
41943: EMPTY
41944: LIST
41945: LIST
41946: LIST
41947: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41948: LD_ADDR_VAR 0 20
41952: PUSH
41953: LD_INT 1
41955: PUSH
41956: LD_INT 3
41958: PUSH
41959: EMPTY
41960: LIST
41961: LIST
41962: PUSH
41963: LD_INT 0
41965: PUSH
41966: LD_INT 3
41968: PUSH
41969: EMPTY
41970: LIST
41971: LIST
41972: PUSH
41973: LD_INT 1
41975: NEG
41976: PUSH
41977: LD_INT 2
41979: PUSH
41980: EMPTY
41981: LIST
41982: LIST
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: LIST
41988: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41989: LD_ADDR_VAR 0 21
41993: PUSH
41994: LD_INT 2
41996: NEG
41997: PUSH
41998: LD_INT 1
42000: PUSH
42001: EMPTY
42002: LIST
42003: LIST
42004: PUSH
42005: LD_INT 3
42007: NEG
42008: PUSH
42009: LD_INT 0
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 3
42018: NEG
42019: PUSH
42020: LD_INT 1
42022: NEG
42023: PUSH
42024: EMPTY
42025: LIST
42026: LIST
42027: PUSH
42028: EMPTY
42029: LIST
42030: LIST
42031: LIST
42032: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42033: LD_ADDR_VAR 0 22
42037: PUSH
42038: LD_INT 2
42040: NEG
42041: PUSH
42042: LD_INT 3
42044: NEG
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 3
42052: NEG
42053: PUSH
42054: LD_INT 2
42056: NEG
42057: PUSH
42058: EMPTY
42059: LIST
42060: LIST
42061: PUSH
42062: LD_INT 3
42064: NEG
42065: PUSH
42066: LD_INT 3
42068: NEG
42069: PUSH
42070: EMPTY
42071: LIST
42072: LIST
42073: PUSH
42074: EMPTY
42075: LIST
42076: LIST
42077: LIST
42078: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
42079: LD_ADDR_VAR 0 23
42083: PUSH
42084: LD_INT 0
42086: PUSH
42087: LD_INT 3
42089: NEG
42090: PUSH
42091: EMPTY
42092: LIST
42093: LIST
42094: PUSH
42095: LD_INT 1
42097: NEG
42098: PUSH
42099: LD_INT 4
42101: NEG
42102: PUSH
42103: EMPTY
42104: LIST
42105: LIST
42106: PUSH
42107: LD_INT 1
42109: PUSH
42110: LD_INT 3
42112: NEG
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: LIST
42122: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
42123: LD_ADDR_VAR 0 24
42127: PUSH
42128: LD_INT 3
42130: PUSH
42131: LD_INT 0
42133: PUSH
42134: EMPTY
42135: LIST
42136: LIST
42137: PUSH
42138: LD_INT 3
42140: PUSH
42141: LD_INT 1
42143: NEG
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: LD_INT 4
42151: PUSH
42152: LD_INT 1
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: EMPTY
42160: LIST
42161: LIST
42162: LIST
42163: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
42164: LD_ADDR_VAR 0 25
42168: PUSH
42169: LD_INT 3
42171: PUSH
42172: LD_INT 3
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 4
42181: PUSH
42182: LD_INT 3
42184: PUSH
42185: EMPTY
42186: LIST
42187: LIST
42188: PUSH
42189: LD_INT 3
42191: PUSH
42192: LD_INT 4
42194: PUSH
42195: EMPTY
42196: LIST
42197: LIST
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: LIST
42203: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
42204: LD_ADDR_VAR 0 26
42208: PUSH
42209: LD_INT 0
42211: PUSH
42212: LD_INT 3
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: PUSH
42219: LD_INT 1
42221: PUSH
42222: LD_INT 4
42224: PUSH
42225: EMPTY
42226: LIST
42227: LIST
42228: PUSH
42229: LD_INT 1
42231: NEG
42232: PUSH
42233: LD_INT 3
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: LIST
42244: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
42245: LD_ADDR_VAR 0 27
42249: PUSH
42250: LD_INT 3
42252: NEG
42253: PUSH
42254: LD_INT 0
42256: PUSH
42257: EMPTY
42258: LIST
42259: LIST
42260: PUSH
42261: LD_INT 3
42263: NEG
42264: PUSH
42265: LD_INT 1
42267: PUSH
42268: EMPTY
42269: LIST
42270: LIST
42271: PUSH
42272: LD_INT 4
42274: NEG
42275: PUSH
42276: LD_INT 1
42278: NEG
42279: PUSH
42280: EMPTY
42281: LIST
42282: LIST
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: LIST
42288: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
42289: LD_ADDR_VAR 0 28
42293: PUSH
42294: LD_INT 3
42296: NEG
42297: PUSH
42298: LD_INT 3
42300: NEG
42301: PUSH
42302: EMPTY
42303: LIST
42304: LIST
42305: PUSH
42306: LD_INT 3
42308: NEG
42309: PUSH
42310: LD_INT 4
42312: NEG
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PUSH
42318: LD_INT 4
42320: NEG
42321: PUSH
42322: LD_INT 3
42324: NEG
42325: PUSH
42326: EMPTY
42327: LIST
42328: LIST
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: LIST
42334: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
42335: LD_ADDR_VAR 0 29
42339: PUSH
42340: LD_INT 1
42342: NEG
42343: PUSH
42344: LD_INT 3
42346: NEG
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PUSH
42352: LD_INT 0
42354: PUSH
42355: LD_INT 3
42357: NEG
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: PUSH
42363: LD_INT 1
42365: PUSH
42366: LD_INT 2
42368: NEG
42369: PUSH
42370: EMPTY
42371: LIST
42372: LIST
42373: PUSH
42374: LD_INT 1
42376: NEG
42377: PUSH
42378: LD_INT 4
42380: NEG
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: PUSH
42386: LD_INT 0
42388: PUSH
42389: LD_INT 4
42391: NEG
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: LD_INT 1
42399: PUSH
42400: LD_INT 3
42402: NEG
42403: PUSH
42404: EMPTY
42405: LIST
42406: LIST
42407: PUSH
42408: LD_INT 1
42410: NEG
42411: PUSH
42412: LD_INT 5
42414: NEG
42415: PUSH
42416: EMPTY
42417: LIST
42418: LIST
42419: PUSH
42420: LD_INT 0
42422: PUSH
42423: LD_INT 5
42425: NEG
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: LD_INT 1
42433: PUSH
42434: LD_INT 4
42436: NEG
42437: PUSH
42438: EMPTY
42439: LIST
42440: LIST
42441: PUSH
42442: LD_INT 1
42444: NEG
42445: PUSH
42446: LD_INT 6
42448: NEG
42449: PUSH
42450: EMPTY
42451: LIST
42452: LIST
42453: PUSH
42454: LD_INT 0
42456: PUSH
42457: LD_INT 6
42459: NEG
42460: PUSH
42461: EMPTY
42462: LIST
42463: LIST
42464: PUSH
42465: LD_INT 1
42467: PUSH
42468: LD_INT 5
42470: NEG
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: LIST
42480: LIST
42481: LIST
42482: LIST
42483: LIST
42484: LIST
42485: LIST
42486: LIST
42487: LIST
42488: LIST
42489: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
42490: LD_ADDR_VAR 0 30
42494: PUSH
42495: LD_INT 2
42497: PUSH
42498: LD_INT 1
42500: NEG
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: LD_INT 3
42508: PUSH
42509: LD_INT 0
42511: PUSH
42512: EMPTY
42513: LIST
42514: LIST
42515: PUSH
42516: LD_INT 3
42518: PUSH
42519: LD_INT 1
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 3
42528: PUSH
42529: LD_INT 1
42531: NEG
42532: PUSH
42533: EMPTY
42534: LIST
42535: LIST
42536: PUSH
42537: LD_INT 4
42539: PUSH
42540: LD_INT 0
42542: PUSH
42543: EMPTY
42544: LIST
42545: LIST
42546: PUSH
42547: LD_INT 4
42549: PUSH
42550: LD_INT 1
42552: PUSH
42553: EMPTY
42554: LIST
42555: LIST
42556: PUSH
42557: LD_INT 4
42559: PUSH
42560: LD_INT 1
42562: NEG
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: PUSH
42568: LD_INT 5
42570: PUSH
42571: LD_INT 0
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: PUSH
42578: LD_INT 5
42580: PUSH
42581: LD_INT 1
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: PUSH
42588: LD_INT 5
42590: PUSH
42591: LD_INT 1
42593: NEG
42594: PUSH
42595: EMPTY
42596: LIST
42597: LIST
42598: PUSH
42599: LD_INT 6
42601: PUSH
42602: LD_INT 0
42604: PUSH
42605: EMPTY
42606: LIST
42607: LIST
42608: PUSH
42609: LD_INT 6
42611: PUSH
42612: LD_INT 1
42614: PUSH
42615: EMPTY
42616: LIST
42617: LIST
42618: PUSH
42619: EMPTY
42620: LIST
42621: LIST
42622: LIST
42623: LIST
42624: LIST
42625: LIST
42626: LIST
42627: LIST
42628: LIST
42629: LIST
42630: LIST
42631: LIST
42632: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
42633: LD_ADDR_VAR 0 31
42637: PUSH
42638: LD_INT 3
42640: PUSH
42641: LD_INT 2
42643: PUSH
42644: EMPTY
42645: LIST
42646: LIST
42647: PUSH
42648: LD_INT 3
42650: PUSH
42651: LD_INT 3
42653: PUSH
42654: EMPTY
42655: LIST
42656: LIST
42657: PUSH
42658: LD_INT 2
42660: PUSH
42661: LD_INT 3
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: PUSH
42668: LD_INT 4
42670: PUSH
42671: LD_INT 3
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PUSH
42678: LD_INT 4
42680: PUSH
42681: LD_INT 4
42683: PUSH
42684: EMPTY
42685: LIST
42686: LIST
42687: PUSH
42688: LD_INT 3
42690: PUSH
42691: LD_INT 4
42693: PUSH
42694: EMPTY
42695: LIST
42696: LIST
42697: PUSH
42698: LD_INT 5
42700: PUSH
42701: LD_INT 4
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PUSH
42708: LD_INT 5
42710: PUSH
42711: LD_INT 5
42713: PUSH
42714: EMPTY
42715: LIST
42716: LIST
42717: PUSH
42718: LD_INT 4
42720: PUSH
42721: LD_INT 5
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: PUSH
42728: LD_INT 6
42730: PUSH
42731: LD_INT 5
42733: PUSH
42734: EMPTY
42735: LIST
42736: LIST
42737: PUSH
42738: LD_INT 6
42740: PUSH
42741: LD_INT 6
42743: PUSH
42744: EMPTY
42745: LIST
42746: LIST
42747: PUSH
42748: LD_INT 5
42750: PUSH
42751: LD_INT 6
42753: PUSH
42754: EMPTY
42755: LIST
42756: LIST
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: LIST
42762: LIST
42763: LIST
42764: LIST
42765: LIST
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: LIST
42771: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42772: LD_ADDR_VAR 0 32
42776: PUSH
42777: LD_INT 1
42779: PUSH
42780: LD_INT 3
42782: PUSH
42783: EMPTY
42784: LIST
42785: LIST
42786: PUSH
42787: LD_INT 0
42789: PUSH
42790: LD_INT 3
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: PUSH
42797: LD_INT 1
42799: NEG
42800: PUSH
42801: LD_INT 2
42803: PUSH
42804: EMPTY
42805: LIST
42806: LIST
42807: PUSH
42808: LD_INT 1
42810: PUSH
42811: LD_INT 4
42813: PUSH
42814: EMPTY
42815: LIST
42816: LIST
42817: PUSH
42818: LD_INT 0
42820: PUSH
42821: LD_INT 4
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: LD_INT 1
42830: NEG
42831: PUSH
42832: LD_INT 3
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PUSH
42839: LD_INT 1
42841: PUSH
42842: LD_INT 5
42844: PUSH
42845: EMPTY
42846: LIST
42847: LIST
42848: PUSH
42849: LD_INT 0
42851: PUSH
42852: LD_INT 5
42854: PUSH
42855: EMPTY
42856: LIST
42857: LIST
42858: PUSH
42859: LD_INT 1
42861: NEG
42862: PUSH
42863: LD_INT 4
42865: PUSH
42866: EMPTY
42867: LIST
42868: LIST
42869: PUSH
42870: LD_INT 1
42872: PUSH
42873: LD_INT 6
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: LD_INT 0
42882: PUSH
42883: LD_INT 6
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PUSH
42890: LD_INT 1
42892: NEG
42893: PUSH
42894: LD_INT 5
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: EMPTY
42902: LIST
42903: LIST
42904: LIST
42905: LIST
42906: LIST
42907: LIST
42908: LIST
42909: LIST
42910: LIST
42911: LIST
42912: LIST
42913: LIST
42914: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42915: LD_ADDR_VAR 0 33
42919: PUSH
42920: LD_INT 2
42922: NEG
42923: PUSH
42924: LD_INT 1
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: PUSH
42931: LD_INT 3
42933: NEG
42934: PUSH
42935: LD_INT 0
42937: PUSH
42938: EMPTY
42939: LIST
42940: LIST
42941: PUSH
42942: LD_INT 3
42944: NEG
42945: PUSH
42946: LD_INT 1
42948: NEG
42949: PUSH
42950: EMPTY
42951: LIST
42952: LIST
42953: PUSH
42954: LD_INT 3
42956: NEG
42957: PUSH
42958: LD_INT 1
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: LD_INT 4
42967: NEG
42968: PUSH
42969: LD_INT 0
42971: PUSH
42972: EMPTY
42973: LIST
42974: LIST
42975: PUSH
42976: LD_INT 4
42978: NEG
42979: PUSH
42980: LD_INT 1
42982: NEG
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: PUSH
42988: LD_INT 4
42990: NEG
42991: PUSH
42992: LD_INT 1
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: LD_INT 5
43001: NEG
43002: PUSH
43003: LD_INT 0
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: PUSH
43010: LD_INT 5
43012: NEG
43013: PUSH
43014: LD_INT 1
43016: NEG
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: PUSH
43022: LD_INT 5
43024: NEG
43025: PUSH
43026: LD_INT 1
43028: PUSH
43029: EMPTY
43030: LIST
43031: LIST
43032: PUSH
43033: LD_INT 6
43035: NEG
43036: PUSH
43037: LD_INT 0
43039: PUSH
43040: EMPTY
43041: LIST
43042: LIST
43043: PUSH
43044: LD_INT 6
43046: NEG
43047: PUSH
43048: LD_INT 1
43050: NEG
43051: PUSH
43052: EMPTY
43053: LIST
43054: LIST
43055: PUSH
43056: EMPTY
43057: LIST
43058: LIST
43059: LIST
43060: LIST
43061: LIST
43062: LIST
43063: LIST
43064: LIST
43065: LIST
43066: LIST
43067: LIST
43068: LIST
43069: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
43070: LD_ADDR_VAR 0 34
43074: PUSH
43075: LD_INT 2
43077: NEG
43078: PUSH
43079: LD_INT 3
43081: NEG
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: PUSH
43087: LD_INT 3
43089: NEG
43090: PUSH
43091: LD_INT 2
43093: NEG
43094: PUSH
43095: EMPTY
43096: LIST
43097: LIST
43098: PUSH
43099: LD_INT 3
43101: NEG
43102: PUSH
43103: LD_INT 3
43105: NEG
43106: PUSH
43107: EMPTY
43108: LIST
43109: LIST
43110: PUSH
43111: LD_INT 3
43113: NEG
43114: PUSH
43115: LD_INT 4
43117: NEG
43118: PUSH
43119: EMPTY
43120: LIST
43121: LIST
43122: PUSH
43123: LD_INT 4
43125: NEG
43126: PUSH
43127: LD_INT 3
43129: NEG
43130: PUSH
43131: EMPTY
43132: LIST
43133: LIST
43134: PUSH
43135: LD_INT 4
43137: NEG
43138: PUSH
43139: LD_INT 4
43141: NEG
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: LD_INT 4
43149: NEG
43150: PUSH
43151: LD_INT 5
43153: NEG
43154: PUSH
43155: EMPTY
43156: LIST
43157: LIST
43158: PUSH
43159: LD_INT 5
43161: NEG
43162: PUSH
43163: LD_INT 4
43165: NEG
43166: PUSH
43167: EMPTY
43168: LIST
43169: LIST
43170: PUSH
43171: LD_INT 5
43173: NEG
43174: PUSH
43175: LD_INT 5
43177: NEG
43178: PUSH
43179: EMPTY
43180: LIST
43181: LIST
43182: PUSH
43183: LD_INT 5
43185: NEG
43186: PUSH
43187: LD_INT 6
43189: NEG
43190: PUSH
43191: EMPTY
43192: LIST
43193: LIST
43194: PUSH
43195: LD_INT 6
43197: NEG
43198: PUSH
43199: LD_INT 5
43201: NEG
43202: PUSH
43203: EMPTY
43204: LIST
43205: LIST
43206: PUSH
43207: LD_INT 6
43209: NEG
43210: PUSH
43211: LD_INT 6
43213: NEG
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PUSH
43219: EMPTY
43220: LIST
43221: LIST
43222: LIST
43223: LIST
43224: LIST
43225: LIST
43226: LIST
43227: LIST
43228: LIST
43229: LIST
43230: LIST
43231: LIST
43232: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
43233: LD_ADDR_VAR 0 41
43237: PUSH
43238: LD_INT 0
43240: PUSH
43241: LD_INT 2
43243: NEG
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: PUSH
43249: LD_INT 1
43251: NEG
43252: PUSH
43253: LD_INT 3
43255: NEG
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: PUSH
43261: LD_INT 1
43263: PUSH
43264: LD_INT 2
43266: NEG
43267: PUSH
43268: EMPTY
43269: LIST
43270: LIST
43271: PUSH
43272: EMPTY
43273: LIST
43274: LIST
43275: LIST
43276: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
43277: LD_ADDR_VAR 0 42
43281: PUSH
43282: LD_INT 2
43284: PUSH
43285: LD_INT 0
43287: PUSH
43288: EMPTY
43289: LIST
43290: LIST
43291: PUSH
43292: LD_INT 2
43294: PUSH
43295: LD_INT 1
43297: NEG
43298: PUSH
43299: EMPTY
43300: LIST
43301: LIST
43302: PUSH
43303: LD_INT 3
43305: PUSH
43306: LD_INT 1
43308: PUSH
43309: EMPTY
43310: LIST
43311: LIST
43312: PUSH
43313: EMPTY
43314: LIST
43315: LIST
43316: LIST
43317: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
43318: LD_ADDR_VAR 0 43
43322: PUSH
43323: LD_INT 2
43325: PUSH
43326: LD_INT 2
43328: PUSH
43329: EMPTY
43330: LIST
43331: LIST
43332: PUSH
43333: LD_INT 3
43335: PUSH
43336: LD_INT 2
43338: PUSH
43339: EMPTY
43340: LIST
43341: LIST
43342: PUSH
43343: LD_INT 2
43345: PUSH
43346: LD_INT 3
43348: PUSH
43349: EMPTY
43350: LIST
43351: LIST
43352: PUSH
43353: EMPTY
43354: LIST
43355: LIST
43356: LIST
43357: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
43358: LD_ADDR_VAR 0 44
43362: PUSH
43363: LD_INT 0
43365: PUSH
43366: LD_INT 2
43368: PUSH
43369: EMPTY
43370: LIST
43371: LIST
43372: PUSH
43373: LD_INT 1
43375: PUSH
43376: LD_INT 3
43378: PUSH
43379: EMPTY
43380: LIST
43381: LIST
43382: PUSH
43383: LD_INT 1
43385: NEG
43386: PUSH
43387: LD_INT 2
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: LIST
43398: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
43399: LD_ADDR_VAR 0 45
43403: PUSH
43404: LD_INT 2
43406: NEG
43407: PUSH
43408: LD_INT 0
43410: PUSH
43411: EMPTY
43412: LIST
43413: LIST
43414: PUSH
43415: LD_INT 2
43417: NEG
43418: PUSH
43419: LD_INT 1
43421: PUSH
43422: EMPTY
43423: LIST
43424: LIST
43425: PUSH
43426: LD_INT 3
43428: NEG
43429: PUSH
43430: LD_INT 1
43432: NEG
43433: PUSH
43434: EMPTY
43435: LIST
43436: LIST
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: LIST
43442: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
43443: LD_ADDR_VAR 0 46
43447: PUSH
43448: LD_INT 2
43450: NEG
43451: PUSH
43452: LD_INT 2
43454: NEG
43455: PUSH
43456: EMPTY
43457: LIST
43458: LIST
43459: PUSH
43460: LD_INT 2
43462: NEG
43463: PUSH
43464: LD_INT 3
43466: NEG
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 3
43474: NEG
43475: PUSH
43476: LD_INT 2
43478: NEG
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: EMPTY
43485: LIST
43486: LIST
43487: LIST
43488: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
43489: LD_ADDR_VAR 0 47
43493: PUSH
43494: LD_INT 2
43496: NEG
43497: PUSH
43498: LD_INT 3
43500: NEG
43501: PUSH
43502: EMPTY
43503: LIST
43504: LIST
43505: PUSH
43506: LD_INT 1
43508: NEG
43509: PUSH
43510: LD_INT 3
43512: NEG
43513: PUSH
43514: EMPTY
43515: LIST
43516: LIST
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
43522: LD_ADDR_VAR 0 48
43526: PUSH
43527: LD_INT 1
43529: PUSH
43530: LD_INT 2
43532: NEG
43533: PUSH
43534: EMPTY
43535: LIST
43536: LIST
43537: PUSH
43538: LD_INT 2
43540: PUSH
43541: LD_INT 1
43543: NEG
43544: PUSH
43545: EMPTY
43546: LIST
43547: LIST
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
43553: LD_ADDR_VAR 0 49
43557: PUSH
43558: LD_INT 3
43560: PUSH
43561: LD_INT 1
43563: PUSH
43564: EMPTY
43565: LIST
43566: LIST
43567: PUSH
43568: LD_INT 3
43570: PUSH
43571: LD_INT 2
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
43582: LD_ADDR_VAR 0 50
43586: PUSH
43587: LD_INT 2
43589: PUSH
43590: LD_INT 3
43592: PUSH
43593: EMPTY
43594: LIST
43595: LIST
43596: PUSH
43597: LD_INT 1
43599: PUSH
43600: LD_INT 3
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: EMPTY
43608: LIST
43609: LIST
43610: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
43611: LD_ADDR_VAR 0 51
43615: PUSH
43616: LD_INT 1
43618: NEG
43619: PUSH
43620: LD_INT 2
43622: PUSH
43623: EMPTY
43624: LIST
43625: LIST
43626: PUSH
43627: LD_INT 2
43629: NEG
43630: PUSH
43631: LD_INT 1
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: PUSH
43638: EMPTY
43639: LIST
43640: LIST
43641: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
43642: LD_ADDR_VAR 0 52
43646: PUSH
43647: LD_INT 3
43649: NEG
43650: PUSH
43651: LD_INT 1
43653: NEG
43654: PUSH
43655: EMPTY
43656: LIST
43657: LIST
43658: PUSH
43659: LD_INT 3
43661: NEG
43662: PUSH
43663: LD_INT 2
43665: NEG
43666: PUSH
43667: EMPTY
43668: LIST
43669: LIST
43670: PUSH
43671: EMPTY
43672: LIST
43673: LIST
43674: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43675: LD_ADDR_VAR 0 53
43679: PUSH
43680: LD_INT 1
43682: NEG
43683: PUSH
43684: LD_INT 3
43686: NEG
43687: PUSH
43688: EMPTY
43689: LIST
43690: LIST
43691: PUSH
43692: LD_INT 0
43694: PUSH
43695: LD_INT 3
43697: NEG
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: LD_INT 1
43705: PUSH
43706: LD_INT 2
43708: NEG
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: LIST
43718: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43719: LD_ADDR_VAR 0 54
43723: PUSH
43724: LD_INT 2
43726: PUSH
43727: LD_INT 1
43729: NEG
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PUSH
43735: LD_INT 3
43737: PUSH
43738: LD_INT 0
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: PUSH
43745: LD_INT 3
43747: PUSH
43748: LD_INT 1
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: EMPTY
43756: LIST
43757: LIST
43758: LIST
43759: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43760: LD_ADDR_VAR 0 55
43764: PUSH
43765: LD_INT 3
43767: PUSH
43768: LD_INT 2
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: PUSH
43775: LD_INT 3
43777: PUSH
43778: LD_INT 3
43780: PUSH
43781: EMPTY
43782: LIST
43783: LIST
43784: PUSH
43785: LD_INT 2
43787: PUSH
43788: LD_INT 3
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PUSH
43795: EMPTY
43796: LIST
43797: LIST
43798: LIST
43799: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43800: LD_ADDR_VAR 0 56
43804: PUSH
43805: LD_INT 1
43807: PUSH
43808: LD_INT 3
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: PUSH
43815: LD_INT 0
43817: PUSH
43818: LD_INT 3
43820: PUSH
43821: EMPTY
43822: LIST
43823: LIST
43824: PUSH
43825: LD_INT 1
43827: NEG
43828: PUSH
43829: LD_INT 2
43831: PUSH
43832: EMPTY
43833: LIST
43834: LIST
43835: PUSH
43836: EMPTY
43837: LIST
43838: LIST
43839: LIST
43840: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43841: LD_ADDR_VAR 0 57
43845: PUSH
43846: LD_INT 2
43848: NEG
43849: PUSH
43850: LD_INT 1
43852: PUSH
43853: EMPTY
43854: LIST
43855: LIST
43856: PUSH
43857: LD_INT 3
43859: NEG
43860: PUSH
43861: LD_INT 0
43863: PUSH
43864: EMPTY
43865: LIST
43866: LIST
43867: PUSH
43868: LD_INT 3
43870: NEG
43871: PUSH
43872: LD_INT 1
43874: NEG
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: PUSH
43880: EMPTY
43881: LIST
43882: LIST
43883: LIST
43884: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43885: LD_ADDR_VAR 0 58
43889: PUSH
43890: LD_INT 2
43892: NEG
43893: PUSH
43894: LD_INT 3
43896: NEG
43897: PUSH
43898: EMPTY
43899: LIST
43900: LIST
43901: PUSH
43902: LD_INT 3
43904: NEG
43905: PUSH
43906: LD_INT 2
43908: NEG
43909: PUSH
43910: EMPTY
43911: LIST
43912: LIST
43913: PUSH
43914: LD_INT 3
43916: NEG
43917: PUSH
43918: LD_INT 3
43920: NEG
43921: PUSH
43922: EMPTY
43923: LIST
43924: LIST
43925: PUSH
43926: EMPTY
43927: LIST
43928: LIST
43929: LIST
43930: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43931: LD_ADDR_VAR 0 59
43935: PUSH
43936: LD_INT 1
43938: NEG
43939: PUSH
43940: LD_INT 2
43942: NEG
43943: PUSH
43944: EMPTY
43945: LIST
43946: LIST
43947: PUSH
43948: LD_INT 0
43950: PUSH
43951: LD_INT 2
43953: NEG
43954: PUSH
43955: EMPTY
43956: LIST
43957: LIST
43958: PUSH
43959: LD_INT 1
43961: PUSH
43962: LD_INT 1
43964: NEG
43965: PUSH
43966: EMPTY
43967: LIST
43968: LIST
43969: PUSH
43970: EMPTY
43971: LIST
43972: LIST
43973: LIST
43974: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43975: LD_ADDR_VAR 0 60
43979: PUSH
43980: LD_INT 1
43982: PUSH
43983: LD_INT 1
43985: NEG
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: PUSH
43991: LD_INT 2
43993: PUSH
43994: LD_INT 0
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 2
44003: PUSH
44004: LD_INT 1
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: EMPTY
44012: LIST
44013: LIST
44014: LIST
44015: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
44016: LD_ADDR_VAR 0 61
44020: PUSH
44021: LD_INT 2
44023: PUSH
44024: LD_INT 1
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: LD_INT 2
44033: PUSH
44034: LD_INT 2
44036: PUSH
44037: EMPTY
44038: LIST
44039: LIST
44040: PUSH
44041: LD_INT 1
44043: PUSH
44044: LD_INT 2
44046: PUSH
44047: EMPTY
44048: LIST
44049: LIST
44050: PUSH
44051: EMPTY
44052: LIST
44053: LIST
44054: LIST
44055: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
44056: LD_ADDR_VAR 0 62
44060: PUSH
44061: LD_INT 1
44063: PUSH
44064: LD_INT 2
44066: PUSH
44067: EMPTY
44068: LIST
44069: LIST
44070: PUSH
44071: LD_INT 0
44073: PUSH
44074: LD_INT 2
44076: PUSH
44077: EMPTY
44078: LIST
44079: LIST
44080: PUSH
44081: LD_INT 1
44083: NEG
44084: PUSH
44085: LD_INT 1
44087: PUSH
44088: EMPTY
44089: LIST
44090: LIST
44091: PUSH
44092: EMPTY
44093: LIST
44094: LIST
44095: LIST
44096: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
44097: LD_ADDR_VAR 0 63
44101: PUSH
44102: LD_INT 1
44104: NEG
44105: PUSH
44106: LD_INT 1
44108: PUSH
44109: EMPTY
44110: LIST
44111: LIST
44112: PUSH
44113: LD_INT 2
44115: NEG
44116: PUSH
44117: LD_INT 0
44119: PUSH
44120: EMPTY
44121: LIST
44122: LIST
44123: PUSH
44124: LD_INT 2
44126: NEG
44127: PUSH
44128: LD_INT 1
44130: NEG
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: EMPTY
44137: LIST
44138: LIST
44139: LIST
44140: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44141: LD_ADDR_VAR 0 64
44145: PUSH
44146: LD_INT 1
44148: NEG
44149: PUSH
44150: LD_INT 2
44152: NEG
44153: PUSH
44154: EMPTY
44155: LIST
44156: LIST
44157: PUSH
44158: LD_INT 2
44160: NEG
44161: PUSH
44162: LD_INT 1
44164: NEG
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 2
44172: NEG
44173: PUSH
44174: LD_INT 2
44176: NEG
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: LIST
44186: ST_TO_ADDR
// end ; 2 :
44187: GO 47453
44189: LD_INT 2
44191: DOUBLE
44192: EQUAL
44193: IFTRUE 44197
44195: GO 47452
44197: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
44198: LD_ADDR_VAR 0 29
44202: PUSH
44203: LD_INT 4
44205: PUSH
44206: LD_INT 0
44208: PUSH
44209: EMPTY
44210: LIST
44211: LIST
44212: PUSH
44213: LD_INT 4
44215: PUSH
44216: LD_INT 1
44218: NEG
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: LD_INT 5
44226: PUSH
44227: LD_INT 0
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: PUSH
44234: LD_INT 5
44236: PUSH
44237: LD_INT 1
44239: PUSH
44240: EMPTY
44241: LIST
44242: LIST
44243: PUSH
44244: LD_INT 4
44246: PUSH
44247: LD_INT 1
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 3
44256: PUSH
44257: LD_INT 0
44259: PUSH
44260: EMPTY
44261: LIST
44262: LIST
44263: PUSH
44264: LD_INT 3
44266: PUSH
44267: LD_INT 1
44269: NEG
44270: PUSH
44271: EMPTY
44272: LIST
44273: LIST
44274: PUSH
44275: LD_INT 3
44277: PUSH
44278: LD_INT 2
44280: NEG
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 5
44288: PUSH
44289: LD_INT 2
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PUSH
44296: LD_INT 3
44298: PUSH
44299: LD_INT 3
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PUSH
44306: LD_INT 3
44308: PUSH
44309: LD_INT 2
44311: PUSH
44312: EMPTY
44313: LIST
44314: LIST
44315: PUSH
44316: LD_INT 4
44318: PUSH
44319: LD_INT 3
44321: PUSH
44322: EMPTY
44323: LIST
44324: LIST
44325: PUSH
44326: LD_INT 4
44328: PUSH
44329: LD_INT 4
44331: PUSH
44332: EMPTY
44333: LIST
44334: LIST
44335: PUSH
44336: LD_INT 3
44338: PUSH
44339: LD_INT 4
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: PUSH
44346: LD_INT 2
44348: PUSH
44349: LD_INT 3
44351: PUSH
44352: EMPTY
44353: LIST
44354: LIST
44355: PUSH
44356: LD_INT 2
44358: PUSH
44359: LD_INT 2
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: PUSH
44366: LD_INT 4
44368: PUSH
44369: LD_INT 2
44371: PUSH
44372: EMPTY
44373: LIST
44374: LIST
44375: PUSH
44376: LD_INT 2
44378: PUSH
44379: LD_INT 4
44381: PUSH
44382: EMPTY
44383: LIST
44384: LIST
44385: PUSH
44386: LD_INT 0
44388: PUSH
44389: LD_INT 4
44391: PUSH
44392: EMPTY
44393: LIST
44394: LIST
44395: PUSH
44396: LD_INT 0
44398: PUSH
44399: LD_INT 3
44401: PUSH
44402: EMPTY
44403: LIST
44404: LIST
44405: PUSH
44406: LD_INT 1
44408: PUSH
44409: LD_INT 4
44411: PUSH
44412: EMPTY
44413: LIST
44414: LIST
44415: PUSH
44416: LD_INT 1
44418: PUSH
44419: LD_INT 5
44421: PUSH
44422: EMPTY
44423: LIST
44424: LIST
44425: PUSH
44426: LD_INT 0
44428: PUSH
44429: LD_INT 5
44431: PUSH
44432: EMPTY
44433: LIST
44434: LIST
44435: PUSH
44436: LD_INT 1
44438: NEG
44439: PUSH
44440: LD_INT 4
44442: PUSH
44443: EMPTY
44444: LIST
44445: LIST
44446: PUSH
44447: LD_INT 1
44449: NEG
44450: PUSH
44451: LD_INT 3
44453: PUSH
44454: EMPTY
44455: LIST
44456: LIST
44457: PUSH
44458: LD_INT 2
44460: PUSH
44461: LD_INT 5
44463: PUSH
44464: EMPTY
44465: LIST
44466: LIST
44467: PUSH
44468: LD_INT 2
44470: NEG
44471: PUSH
44472: LD_INT 3
44474: PUSH
44475: EMPTY
44476: LIST
44477: LIST
44478: PUSH
44479: LD_INT 3
44481: NEG
44482: PUSH
44483: LD_INT 0
44485: PUSH
44486: EMPTY
44487: LIST
44488: LIST
44489: PUSH
44490: LD_INT 3
44492: NEG
44493: PUSH
44494: LD_INT 1
44496: NEG
44497: PUSH
44498: EMPTY
44499: LIST
44500: LIST
44501: PUSH
44502: LD_INT 2
44504: NEG
44505: PUSH
44506: LD_INT 0
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: LD_INT 2
44515: NEG
44516: PUSH
44517: LD_INT 1
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: LD_INT 3
44526: NEG
44527: PUSH
44528: LD_INT 1
44530: PUSH
44531: EMPTY
44532: LIST
44533: LIST
44534: PUSH
44535: LD_INT 4
44537: NEG
44538: PUSH
44539: LD_INT 0
44541: PUSH
44542: EMPTY
44543: LIST
44544: LIST
44545: PUSH
44546: LD_INT 4
44548: NEG
44549: PUSH
44550: LD_INT 1
44552: NEG
44553: PUSH
44554: EMPTY
44555: LIST
44556: LIST
44557: PUSH
44558: LD_INT 4
44560: NEG
44561: PUSH
44562: LD_INT 2
44564: NEG
44565: PUSH
44566: EMPTY
44567: LIST
44568: LIST
44569: PUSH
44570: LD_INT 2
44572: NEG
44573: PUSH
44574: LD_INT 2
44576: PUSH
44577: EMPTY
44578: LIST
44579: LIST
44580: PUSH
44581: LD_INT 4
44583: NEG
44584: PUSH
44585: LD_INT 4
44587: NEG
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_INT 4
44595: NEG
44596: PUSH
44597: LD_INT 5
44599: NEG
44600: PUSH
44601: EMPTY
44602: LIST
44603: LIST
44604: PUSH
44605: LD_INT 3
44607: NEG
44608: PUSH
44609: LD_INT 4
44611: NEG
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: PUSH
44617: LD_INT 3
44619: NEG
44620: PUSH
44621: LD_INT 3
44623: NEG
44624: PUSH
44625: EMPTY
44626: LIST
44627: LIST
44628: PUSH
44629: LD_INT 4
44631: NEG
44632: PUSH
44633: LD_INT 3
44635: NEG
44636: PUSH
44637: EMPTY
44638: LIST
44639: LIST
44640: PUSH
44641: LD_INT 5
44643: NEG
44644: PUSH
44645: LD_INT 4
44647: NEG
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: PUSH
44653: LD_INT 5
44655: NEG
44656: PUSH
44657: LD_INT 5
44659: NEG
44660: PUSH
44661: EMPTY
44662: LIST
44663: LIST
44664: PUSH
44665: LD_INT 3
44667: NEG
44668: PUSH
44669: LD_INT 5
44671: NEG
44672: PUSH
44673: EMPTY
44674: LIST
44675: LIST
44676: PUSH
44677: LD_INT 5
44679: NEG
44680: PUSH
44681: LD_INT 3
44683: NEG
44684: PUSH
44685: EMPTY
44686: LIST
44687: LIST
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: LIST
44693: LIST
44694: LIST
44695: LIST
44696: LIST
44697: LIST
44698: LIST
44699: LIST
44700: LIST
44701: LIST
44702: LIST
44703: LIST
44704: LIST
44705: LIST
44706: LIST
44707: LIST
44708: LIST
44709: LIST
44710: LIST
44711: LIST
44712: LIST
44713: LIST
44714: LIST
44715: LIST
44716: LIST
44717: LIST
44718: LIST
44719: LIST
44720: LIST
44721: LIST
44722: LIST
44723: LIST
44724: LIST
44725: LIST
44726: LIST
44727: LIST
44728: LIST
44729: LIST
44730: LIST
44731: LIST
44732: LIST
44733: LIST
44734: LIST
44735: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44736: LD_ADDR_VAR 0 30
44740: PUSH
44741: LD_INT 4
44743: PUSH
44744: LD_INT 4
44746: PUSH
44747: EMPTY
44748: LIST
44749: LIST
44750: PUSH
44751: LD_INT 4
44753: PUSH
44754: LD_INT 3
44756: PUSH
44757: EMPTY
44758: LIST
44759: LIST
44760: PUSH
44761: LD_INT 5
44763: PUSH
44764: LD_INT 4
44766: PUSH
44767: EMPTY
44768: LIST
44769: LIST
44770: PUSH
44771: LD_INT 5
44773: PUSH
44774: LD_INT 5
44776: PUSH
44777: EMPTY
44778: LIST
44779: LIST
44780: PUSH
44781: LD_INT 4
44783: PUSH
44784: LD_INT 5
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: PUSH
44791: LD_INT 3
44793: PUSH
44794: LD_INT 4
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: PUSH
44801: LD_INT 3
44803: PUSH
44804: LD_INT 3
44806: PUSH
44807: EMPTY
44808: LIST
44809: LIST
44810: PUSH
44811: LD_INT 5
44813: PUSH
44814: LD_INT 3
44816: PUSH
44817: EMPTY
44818: LIST
44819: LIST
44820: PUSH
44821: LD_INT 3
44823: PUSH
44824: LD_INT 5
44826: PUSH
44827: EMPTY
44828: LIST
44829: LIST
44830: PUSH
44831: LD_INT 0
44833: PUSH
44834: LD_INT 3
44836: PUSH
44837: EMPTY
44838: LIST
44839: LIST
44840: PUSH
44841: LD_INT 0
44843: PUSH
44844: LD_INT 2
44846: PUSH
44847: EMPTY
44848: LIST
44849: LIST
44850: PUSH
44851: LD_INT 1
44853: PUSH
44854: LD_INT 3
44856: PUSH
44857: EMPTY
44858: LIST
44859: LIST
44860: PUSH
44861: LD_INT 1
44863: PUSH
44864: LD_INT 4
44866: PUSH
44867: EMPTY
44868: LIST
44869: LIST
44870: PUSH
44871: LD_INT 0
44873: PUSH
44874: LD_INT 4
44876: PUSH
44877: EMPTY
44878: LIST
44879: LIST
44880: PUSH
44881: LD_INT 1
44883: NEG
44884: PUSH
44885: LD_INT 3
44887: PUSH
44888: EMPTY
44889: LIST
44890: LIST
44891: PUSH
44892: LD_INT 1
44894: NEG
44895: PUSH
44896: LD_INT 2
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: LD_INT 2
44905: PUSH
44906: LD_INT 4
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: LD_INT 2
44915: NEG
44916: PUSH
44917: LD_INT 2
44919: PUSH
44920: EMPTY
44921: LIST
44922: LIST
44923: PUSH
44924: LD_INT 4
44926: NEG
44927: PUSH
44928: LD_INT 0
44930: PUSH
44931: EMPTY
44932: LIST
44933: LIST
44934: PUSH
44935: LD_INT 4
44937: NEG
44938: PUSH
44939: LD_INT 1
44941: NEG
44942: PUSH
44943: EMPTY
44944: LIST
44945: LIST
44946: PUSH
44947: LD_INT 3
44949: NEG
44950: PUSH
44951: LD_INT 0
44953: PUSH
44954: EMPTY
44955: LIST
44956: LIST
44957: PUSH
44958: LD_INT 3
44960: NEG
44961: PUSH
44962: LD_INT 1
44964: PUSH
44965: EMPTY
44966: LIST
44967: LIST
44968: PUSH
44969: LD_INT 4
44971: NEG
44972: PUSH
44973: LD_INT 1
44975: PUSH
44976: EMPTY
44977: LIST
44978: LIST
44979: PUSH
44980: LD_INT 5
44982: NEG
44983: PUSH
44984: LD_INT 0
44986: PUSH
44987: EMPTY
44988: LIST
44989: LIST
44990: PUSH
44991: LD_INT 5
44993: NEG
44994: PUSH
44995: LD_INT 1
44997: NEG
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: LD_INT 5
45005: NEG
45006: PUSH
45007: LD_INT 2
45009: NEG
45010: PUSH
45011: EMPTY
45012: LIST
45013: LIST
45014: PUSH
45015: LD_INT 3
45017: NEG
45018: PUSH
45019: LD_INT 2
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: LD_INT 3
45028: NEG
45029: PUSH
45030: LD_INT 3
45032: NEG
45033: PUSH
45034: EMPTY
45035: LIST
45036: LIST
45037: PUSH
45038: LD_INT 3
45040: NEG
45041: PUSH
45042: LD_INT 4
45044: NEG
45045: PUSH
45046: EMPTY
45047: LIST
45048: LIST
45049: PUSH
45050: LD_INT 2
45052: NEG
45053: PUSH
45054: LD_INT 3
45056: NEG
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PUSH
45062: LD_INT 2
45064: NEG
45065: PUSH
45066: LD_INT 2
45068: NEG
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PUSH
45074: LD_INT 3
45076: NEG
45077: PUSH
45078: LD_INT 2
45080: NEG
45081: PUSH
45082: EMPTY
45083: LIST
45084: LIST
45085: PUSH
45086: LD_INT 4
45088: NEG
45089: PUSH
45090: LD_INT 3
45092: NEG
45093: PUSH
45094: EMPTY
45095: LIST
45096: LIST
45097: PUSH
45098: LD_INT 4
45100: NEG
45101: PUSH
45102: LD_INT 4
45104: NEG
45105: PUSH
45106: EMPTY
45107: LIST
45108: LIST
45109: PUSH
45110: LD_INT 2
45112: NEG
45113: PUSH
45114: LD_INT 4
45116: NEG
45117: PUSH
45118: EMPTY
45119: LIST
45120: LIST
45121: PUSH
45122: LD_INT 4
45124: NEG
45125: PUSH
45126: LD_INT 2
45128: NEG
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: PUSH
45134: LD_INT 0
45136: PUSH
45137: LD_INT 4
45139: NEG
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 0
45147: PUSH
45148: LD_INT 5
45150: NEG
45151: PUSH
45152: EMPTY
45153: LIST
45154: LIST
45155: PUSH
45156: LD_INT 1
45158: PUSH
45159: LD_INT 4
45161: NEG
45162: PUSH
45163: EMPTY
45164: LIST
45165: LIST
45166: PUSH
45167: LD_INT 1
45169: PUSH
45170: LD_INT 3
45172: NEG
45173: PUSH
45174: EMPTY
45175: LIST
45176: LIST
45177: PUSH
45178: LD_INT 0
45180: PUSH
45181: LD_INT 3
45183: NEG
45184: PUSH
45185: EMPTY
45186: LIST
45187: LIST
45188: PUSH
45189: LD_INT 1
45191: NEG
45192: PUSH
45193: LD_INT 4
45195: NEG
45196: PUSH
45197: EMPTY
45198: LIST
45199: LIST
45200: PUSH
45201: LD_INT 1
45203: NEG
45204: PUSH
45205: LD_INT 5
45207: NEG
45208: PUSH
45209: EMPTY
45210: LIST
45211: LIST
45212: PUSH
45213: LD_INT 2
45215: PUSH
45216: LD_INT 3
45218: NEG
45219: PUSH
45220: EMPTY
45221: LIST
45222: LIST
45223: PUSH
45224: LD_INT 2
45226: NEG
45227: PUSH
45228: LD_INT 5
45230: NEG
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: PUSH
45236: EMPTY
45237: LIST
45238: LIST
45239: LIST
45240: LIST
45241: LIST
45242: LIST
45243: LIST
45244: LIST
45245: LIST
45246: LIST
45247: LIST
45248: LIST
45249: LIST
45250: LIST
45251: LIST
45252: LIST
45253: LIST
45254: LIST
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: LIST
45261: LIST
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: LIST
45271: LIST
45272: LIST
45273: LIST
45274: LIST
45275: LIST
45276: LIST
45277: LIST
45278: LIST
45279: LIST
45280: LIST
45281: LIST
45282: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
45283: LD_ADDR_VAR 0 31
45287: PUSH
45288: LD_INT 0
45290: PUSH
45291: LD_INT 4
45293: PUSH
45294: EMPTY
45295: LIST
45296: LIST
45297: PUSH
45298: LD_INT 0
45300: PUSH
45301: LD_INT 3
45303: PUSH
45304: EMPTY
45305: LIST
45306: LIST
45307: PUSH
45308: LD_INT 1
45310: PUSH
45311: LD_INT 4
45313: PUSH
45314: EMPTY
45315: LIST
45316: LIST
45317: PUSH
45318: LD_INT 1
45320: PUSH
45321: LD_INT 5
45323: PUSH
45324: EMPTY
45325: LIST
45326: LIST
45327: PUSH
45328: LD_INT 0
45330: PUSH
45331: LD_INT 5
45333: PUSH
45334: EMPTY
45335: LIST
45336: LIST
45337: PUSH
45338: LD_INT 1
45340: NEG
45341: PUSH
45342: LD_INT 4
45344: PUSH
45345: EMPTY
45346: LIST
45347: LIST
45348: PUSH
45349: LD_INT 1
45351: NEG
45352: PUSH
45353: LD_INT 3
45355: PUSH
45356: EMPTY
45357: LIST
45358: LIST
45359: PUSH
45360: LD_INT 2
45362: PUSH
45363: LD_INT 5
45365: PUSH
45366: EMPTY
45367: LIST
45368: LIST
45369: PUSH
45370: LD_INT 2
45372: NEG
45373: PUSH
45374: LD_INT 3
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: PUSH
45381: LD_INT 3
45383: NEG
45384: PUSH
45385: LD_INT 0
45387: PUSH
45388: EMPTY
45389: LIST
45390: LIST
45391: PUSH
45392: LD_INT 3
45394: NEG
45395: PUSH
45396: LD_INT 1
45398: NEG
45399: PUSH
45400: EMPTY
45401: LIST
45402: LIST
45403: PUSH
45404: LD_INT 2
45406: NEG
45407: PUSH
45408: LD_INT 0
45410: PUSH
45411: EMPTY
45412: LIST
45413: LIST
45414: PUSH
45415: LD_INT 2
45417: NEG
45418: PUSH
45419: LD_INT 1
45421: PUSH
45422: EMPTY
45423: LIST
45424: LIST
45425: PUSH
45426: LD_INT 3
45428: NEG
45429: PUSH
45430: LD_INT 1
45432: PUSH
45433: EMPTY
45434: LIST
45435: LIST
45436: PUSH
45437: LD_INT 4
45439: NEG
45440: PUSH
45441: LD_INT 0
45443: PUSH
45444: EMPTY
45445: LIST
45446: LIST
45447: PUSH
45448: LD_INT 4
45450: NEG
45451: PUSH
45452: LD_INT 1
45454: NEG
45455: PUSH
45456: EMPTY
45457: LIST
45458: LIST
45459: PUSH
45460: LD_INT 4
45462: NEG
45463: PUSH
45464: LD_INT 2
45466: NEG
45467: PUSH
45468: EMPTY
45469: LIST
45470: LIST
45471: PUSH
45472: LD_INT 2
45474: NEG
45475: PUSH
45476: LD_INT 2
45478: PUSH
45479: EMPTY
45480: LIST
45481: LIST
45482: PUSH
45483: LD_INT 4
45485: NEG
45486: PUSH
45487: LD_INT 4
45489: NEG
45490: PUSH
45491: EMPTY
45492: LIST
45493: LIST
45494: PUSH
45495: LD_INT 4
45497: NEG
45498: PUSH
45499: LD_INT 5
45501: NEG
45502: PUSH
45503: EMPTY
45504: LIST
45505: LIST
45506: PUSH
45507: LD_INT 3
45509: NEG
45510: PUSH
45511: LD_INT 4
45513: NEG
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: PUSH
45519: LD_INT 3
45521: NEG
45522: PUSH
45523: LD_INT 3
45525: NEG
45526: PUSH
45527: EMPTY
45528: LIST
45529: LIST
45530: PUSH
45531: LD_INT 4
45533: NEG
45534: PUSH
45535: LD_INT 3
45537: NEG
45538: PUSH
45539: EMPTY
45540: LIST
45541: LIST
45542: PUSH
45543: LD_INT 5
45545: NEG
45546: PUSH
45547: LD_INT 4
45549: NEG
45550: PUSH
45551: EMPTY
45552: LIST
45553: LIST
45554: PUSH
45555: LD_INT 5
45557: NEG
45558: PUSH
45559: LD_INT 5
45561: NEG
45562: PUSH
45563: EMPTY
45564: LIST
45565: LIST
45566: PUSH
45567: LD_INT 3
45569: NEG
45570: PUSH
45571: LD_INT 5
45573: NEG
45574: PUSH
45575: EMPTY
45576: LIST
45577: LIST
45578: PUSH
45579: LD_INT 5
45581: NEG
45582: PUSH
45583: LD_INT 3
45585: NEG
45586: PUSH
45587: EMPTY
45588: LIST
45589: LIST
45590: PUSH
45591: LD_INT 0
45593: PUSH
45594: LD_INT 3
45596: NEG
45597: PUSH
45598: EMPTY
45599: LIST
45600: LIST
45601: PUSH
45602: LD_INT 0
45604: PUSH
45605: LD_INT 4
45607: NEG
45608: PUSH
45609: EMPTY
45610: LIST
45611: LIST
45612: PUSH
45613: LD_INT 1
45615: PUSH
45616: LD_INT 3
45618: NEG
45619: PUSH
45620: EMPTY
45621: LIST
45622: LIST
45623: PUSH
45624: LD_INT 1
45626: PUSH
45627: LD_INT 2
45629: NEG
45630: PUSH
45631: EMPTY
45632: LIST
45633: LIST
45634: PUSH
45635: LD_INT 0
45637: PUSH
45638: LD_INT 2
45640: NEG
45641: PUSH
45642: EMPTY
45643: LIST
45644: LIST
45645: PUSH
45646: LD_INT 1
45648: NEG
45649: PUSH
45650: LD_INT 3
45652: NEG
45653: PUSH
45654: EMPTY
45655: LIST
45656: LIST
45657: PUSH
45658: LD_INT 1
45660: NEG
45661: PUSH
45662: LD_INT 4
45664: NEG
45665: PUSH
45666: EMPTY
45667: LIST
45668: LIST
45669: PUSH
45670: LD_INT 2
45672: PUSH
45673: LD_INT 2
45675: NEG
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: LD_INT 2
45683: NEG
45684: PUSH
45685: LD_INT 4
45687: NEG
45688: PUSH
45689: EMPTY
45690: LIST
45691: LIST
45692: PUSH
45693: LD_INT 4
45695: PUSH
45696: LD_INT 0
45698: PUSH
45699: EMPTY
45700: LIST
45701: LIST
45702: PUSH
45703: LD_INT 4
45705: PUSH
45706: LD_INT 1
45708: NEG
45709: PUSH
45710: EMPTY
45711: LIST
45712: LIST
45713: PUSH
45714: LD_INT 5
45716: PUSH
45717: LD_INT 0
45719: PUSH
45720: EMPTY
45721: LIST
45722: LIST
45723: PUSH
45724: LD_INT 5
45726: PUSH
45727: LD_INT 1
45729: PUSH
45730: EMPTY
45731: LIST
45732: LIST
45733: PUSH
45734: LD_INT 4
45736: PUSH
45737: LD_INT 1
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: PUSH
45744: LD_INT 3
45746: PUSH
45747: LD_INT 0
45749: PUSH
45750: EMPTY
45751: LIST
45752: LIST
45753: PUSH
45754: LD_INT 3
45756: PUSH
45757: LD_INT 1
45759: NEG
45760: PUSH
45761: EMPTY
45762: LIST
45763: LIST
45764: PUSH
45765: LD_INT 3
45767: PUSH
45768: LD_INT 2
45770: NEG
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: PUSH
45776: LD_INT 5
45778: PUSH
45779: LD_INT 2
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: EMPTY
45787: LIST
45788: LIST
45789: LIST
45790: LIST
45791: LIST
45792: LIST
45793: LIST
45794: LIST
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: LIST
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: LIST
45810: LIST
45811: LIST
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: LIST
45824: LIST
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: LIST
45830: LIST
45831: LIST
45832: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45833: LD_ADDR_VAR 0 32
45837: PUSH
45838: LD_INT 4
45840: NEG
45841: PUSH
45842: LD_INT 0
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: PUSH
45849: LD_INT 4
45851: NEG
45852: PUSH
45853: LD_INT 1
45855: NEG
45856: PUSH
45857: EMPTY
45858: LIST
45859: LIST
45860: PUSH
45861: LD_INT 3
45863: NEG
45864: PUSH
45865: LD_INT 0
45867: PUSH
45868: EMPTY
45869: LIST
45870: LIST
45871: PUSH
45872: LD_INT 3
45874: NEG
45875: PUSH
45876: LD_INT 1
45878: PUSH
45879: EMPTY
45880: LIST
45881: LIST
45882: PUSH
45883: LD_INT 4
45885: NEG
45886: PUSH
45887: LD_INT 1
45889: PUSH
45890: EMPTY
45891: LIST
45892: LIST
45893: PUSH
45894: LD_INT 5
45896: NEG
45897: PUSH
45898: LD_INT 0
45900: PUSH
45901: EMPTY
45902: LIST
45903: LIST
45904: PUSH
45905: LD_INT 5
45907: NEG
45908: PUSH
45909: LD_INT 1
45911: NEG
45912: PUSH
45913: EMPTY
45914: LIST
45915: LIST
45916: PUSH
45917: LD_INT 5
45919: NEG
45920: PUSH
45921: LD_INT 2
45923: NEG
45924: PUSH
45925: EMPTY
45926: LIST
45927: LIST
45928: PUSH
45929: LD_INT 3
45931: NEG
45932: PUSH
45933: LD_INT 2
45935: PUSH
45936: EMPTY
45937: LIST
45938: LIST
45939: PUSH
45940: LD_INT 3
45942: NEG
45943: PUSH
45944: LD_INT 3
45946: NEG
45947: PUSH
45948: EMPTY
45949: LIST
45950: LIST
45951: PUSH
45952: LD_INT 3
45954: NEG
45955: PUSH
45956: LD_INT 4
45958: NEG
45959: PUSH
45960: EMPTY
45961: LIST
45962: LIST
45963: PUSH
45964: LD_INT 2
45966: NEG
45967: PUSH
45968: LD_INT 3
45970: NEG
45971: PUSH
45972: EMPTY
45973: LIST
45974: LIST
45975: PUSH
45976: LD_INT 2
45978: NEG
45979: PUSH
45980: LD_INT 2
45982: NEG
45983: PUSH
45984: EMPTY
45985: LIST
45986: LIST
45987: PUSH
45988: LD_INT 3
45990: NEG
45991: PUSH
45992: LD_INT 2
45994: NEG
45995: PUSH
45996: EMPTY
45997: LIST
45998: LIST
45999: PUSH
46000: LD_INT 4
46002: NEG
46003: PUSH
46004: LD_INT 3
46006: NEG
46007: PUSH
46008: EMPTY
46009: LIST
46010: LIST
46011: PUSH
46012: LD_INT 4
46014: NEG
46015: PUSH
46016: LD_INT 4
46018: NEG
46019: PUSH
46020: EMPTY
46021: LIST
46022: LIST
46023: PUSH
46024: LD_INT 2
46026: NEG
46027: PUSH
46028: LD_INT 4
46030: NEG
46031: PUSH
46032: EMPTY
46033: LIST
46034: LIST
46035: PUSH
46036: LD_INT 4
46038: NEG
46039: PUSH
46040: LD_INT 2
46042: NEG
46043: PUSH
46044: EMPTY
46045: LIST
46046: LIST
46047: PUSH
46048: LD_INT 0
46050: PUSH
46051: LD_INT 4
46053: NEG
46054: PUSH
46055: EMPTY
46056: LIST
46057: LIST
46058: PUSH
46059: LD_INT 0
46061: PUSH
46062: LD_INT 5
46064: NEG
46065: PUSH
46066: EMPTY
46067: LIST
46068: LIST
46069: PUSH
46070: LD_INT 1
46072: PUSH
46073: LD_INT 4
46075: NEG
46076: PUSH
46077: EMPTY
46078: LIST
46079: LIST
46080: PUSH
46081: LD_INT 1
46083: PUSH
46084: LD_INT 3
46086: NEG
46087: PUSH
46088: EMPTY
46089: LIST
46090: LIST
46091: PUSH
46092: LD_INT 0
46094: PUSH
46095: LD_INT 3
46097: NEG
46098: PUSH
46099: EMPTY
46100: LIST
46101: LIST
46102: PUSH
46103: LD_INT 1
46105: NEG
46106: PUSH
46107: LD_INT 4
46109: NEG
46110: PUSH
46111: EMPTY
46112: LIST
46113: LIST
46114: PUSH
46115: LD_INT 1
46117: NEG
46118: PUSH
46119: LD_INT 5
46121: NEG
46122: PUSH
46123: EMPTY
46124: LIST
46125: LIST
46126: PUSH
46127: LD_INT 2
46129: PUSH
46130: LD_INT 3
46132: NEG
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: PUSH
46138: LD_INT 2
46140: NEG
46141: PUSH
46142: LD_INT 5
46144: NEG
46145: PUSH
46146: EMPTY
46147: LIST
46148: LIST
46149: PUSH
46150: LD_INT 3
46152: PUSH
46153: LD_INT 0
46155: PUSH
46156: EMPTY
46157: LIST
46158: LIST
46159: PUSH
46160: LD_INT 3
46162: PUSH
46163: LD_INT 1
46165: NEG
46166: PUSH
46167: EMPTY
46168: LIST
46169: LIST
46170: PUSH
46171: LD_INT 4
46173: PUSH
46174: LD_INT 0
46176: PUSH
46177: EMPTY
46178: LIST
46179: LIST
46180: PUSH
46181: LD_INT 4
46183: PUSH
46184: LD_INT 1
46186: PUSH
46187: EMPTY
46188: LIST
46189: LIST
46190: PUSH
46191: LD_INT 3
46193: PUSH
46194: LD_INT 1
46196: PUSH
46197: EMPTY
46198: LIST
46199: LIST
46200: PUSH
46201: LD_INT 2
46203: PUSH
46204: LD_INT 0
46206: PUSH
46207: EMPTY
46208: LIST
46209: LIST
46210: PUSH
46211: LD_INT 2
46213: PUSH
46214: LD_INT 1
46216: NEG
46217: PUSH
46218: EMPTY
46219: LIST
46220: LIST
46221: PUSH
46222: LD_INT 2
46224: PUSH
46225: LD_INT 2
46227: NEG
46228: PUSH
46229: EMPTY
46230: LIST
46231: LIST
46232: PUSH
46233: LD_INT 4
46235: PUSH
46236: LD_INT 2
46238: PUSH
46239: EMPTY
46240: LIST
46241: LIST
46242: PUSH
46243: LD_INT 4
46245: PUSH
46246: LD_INT 4
46248: PUSH
46249: EMPTY
46250: LIST
46251: LIST
46252: PUSH
46253: LD_INT 4
46255: PUSH
46256: LD_INT 3
46258: PUSH
46259: EMPTY
46260: LIST
46261: LIST
46262: PUSH
46263: LD_INT 5
46265: PUSH
46266: LD_INT 4
46268: PUSH
46269: EMPTY
46270: LIST
46271: LIST
46272: PUSH
46273: LD_INT 5
46275: PUSH
46276: LD_INT 5
46278: PUSH
46279: EMPTY
46280: LIST
46281: LIST
46282: PUSH
46283: LD_INT 4
46285: PUSH
46286: LD_INT 5
46288: PUSH
46289: EMPTY
46290: LIST
46291: LIST
46292: PUSH
46293: LD_INT 3
46295: PUSH
46296: LD_INT 4
46298: PUSH
46299: EMPTY
46300: LIST
46301: LIST
46302: PUSH
46303: LD_INT 3
46305: PUSH
46306: LD_INT 3
46308: PUSH
46309: EMPTY
46310: LIST
46311: LIST
46312: PUSH
46313: LD_INT 5
46315: PUSH
46316: LD_INT 3
46318: PUSH
46319: EMPTY
46320: LIST
46321: LIST
46322: PUSH
46323: LD_INT 3
46325: PUSH
46326: LD_INT 5
46328: PUSH
46329: EMPTY
46330: LIST
46331: LIST
46332: PUSH
46333: EMPTY
46334: LIST
46335: LIST
46336: LIST
46337: LIST
46338: LIST
46339: LIST
46340: LIST
46341: LIST
46342: LIST
46343: LIST
46344: LIST
46345: LIST
46346: LIST
46347: LIST
46348: LIST
46349: LIST
46350: LIST
46351: LIST
46352: LIST
46353: LIST
46354: LIST
46355: LIST
46356: LIST
46357: LIST
46358: LIST
46359: LIST
46360: LIST
46361: LIST
46362: LIST
46363: LIST
46364: LIST
46365: LIST
46366: LIST
46367: LIST
46368: LIST
46369: LIST
46370: LIST
46371: LIST
46372: LIST
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
46380: LD_ADDR_VAR 0 33
46384: PUSH
46385: LD_INT 4
46387: NEG
46388: PUSH
46389: LD_INT 4
46391: NEG
46392: PUSH
46393: EMPTY
46394: LIST
46395: LIST
46396: PUSH
46397: LD_INT 4
46399: NEG
46400: PUSH
46401: LD_INT 5
46403: NEG
46404: PUSH
46405: EMPTY
46406: LIST
46407: LIST
46408: PUSH
46409: LD_INT 3
46411: NEG
46412: PUSH
46413: LD_INT 4
46415: NEG
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: PUSH
46421: LD_INT 3
46423: NEG
46424: PUSH
46425: LD_INT 3
46427: NEG
46428: PUSH
46429: EMPTY
46430: LIST
46431: LIST
46432: PUSH
46433: LD_INT 4
46435: NEG
46436: PUSH
46437: LD_INT 3
46439: NEG
46440: PUSH
46441: EMPTY
46442: LIST
46443: LIST
46444: PUSH
46445: LD_INT 5
46447: NEG
46448: PUSH
46449: LD_INT 4
46451: NEG
46452: PUSH
46453: EMPTY
46454: LIST
46455: LIST
46456: PUSH
46457: LD_INT 5
46459: NEG
46460: PUSH
46461: LD_INT 5
46463: NEG
46464: PUSH
46465: EMPTY
46466: LIST
46467: LIST
46468: PUSH
46469: LD_INT 3
46471: NEG
46472: PUSH
46473: LD_INT 5
46475: NEG
46476: PUSH
46477: EMPTY
46478: LIST
46479: LIST
46480: PUSH
46481: LD_INT 5
46483: NEG
46484: PUSH
46485: LD_INT 3
46487: NEG
46488: PUSH
46489: EMPTY
46490: LIST
46491: LIST
46492: PUSH
46493: LD_INT 0
46495: PUSH
46496: LD_INT 3
46498: NEG
46499: PUSH
46500: EMPTY
46501: LIST
46502: LIST
46503: PUSH
46504: LD_INT 0
46506: PUSH
46507: LD_INT 4
46509: NEG
46510: PUSH
46511: EMPTY
46512: LIST
46513: LIST
46514: PUSH
46515: LD_INT 1
46517: PUSH
46518: LD_INT 3
46520: NEG
46521: PUSH
46522: EMPTY
46523: LIST
46524: LIST
46525: PUSH
46526: LD_INT 1
46528: PUSH
46529: LD_INT 2
46531: NEG
46532: PUSH
46533: EMPTY
46534: LIST
46535: LIST
46536: PUSH
46537: LD_INT 0
46539: PUSH
46540: LD_INT 2
46542: NEG
46543: PUSH
46544: EMPTY
46545: LIST
46546: LIST
46547: PUSH
46548: LD_INT 1
46550: NEG
46551: PUSH
46552: LD_INT 3
46554: NEG
46555: PUSH
46556: EMPTY
46557: LIST
46558: LIST
46559: PUSH
46560: LD_INT 1
46562: NEG
46563: PUSH
46564: LD_INT 4
46566: NEG
46567: PUSH
46568: EMPTY
46569: LIST
46570: LIST
46571: PUSH
46572: LD_INT 2
46574: PUSH
46575: LD_INT 2
46577: NEG
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: PUSH
46583: LD_INT 2
46585: NEG
46586: PUSH
46587: LD_INT 4
46589: NEG
46590: PUSH
46591: EMPTY
46592: LIST
46593: LIST
46594: PUSH
46595: LD_INT 4
46597: PUSH
46598: LD_INT 0
46600: PUSH
46601: EMPTY
46602: LIST
46603: LIST
46604: PUSH
46605: LD_INT 4
46607: PUSH
46608: LD_INT 1
46610: NEG
46611: PUSH
46612: EMPTY
46613: LIST
46614: LIST
46615: PUSH
46616: LD_INT 5
46618: PUSH
46619: LD_INT 0
46621: PUSH
46622: EMPTY
46623: LIST
46624: LIST
46625: PUSH
46626: LD_INT 5
46628: PUSH
46629: LD_INT 1
46631: PUSH
46632: EMPTY
46633: LIST
46634: LIST
46635: PUSH
46636: LD_INT 4
46638: PUSH
46639: LD_INT 1
46641: PUSH
46642: EMPTY
46643: LIST
46644: LIST
46645: PUSH
46646: LD_INT 3
46648: PUSH
46649: LD_INT 0
46651: PUSH
46652: EMPTY
46653: LIST
46654: LIST
46655: PUSH
46656: LD_INT 3
46658: PUSH
46659: LD_INT 1
46661: NEG
46662: PUSH
46663: EMPTY
46664: LIST
46665: LIST
46666: PUSH
46667: LD_INT 3
46669: PUSH
46670: LD_INT 2
46672: NEG
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: LD_INT 5
46680: PUSH
46681: LD_INT 2
46683: PUSH
46684: EMPTY
46685: LIST
46686: LIST
46687: PUSH
46688: LD_INT 3
46690: PUSH
46691: LD_INT 3
46693: PUSH
46694: EMPTY
46695: LIST
46696: LIST
46697: PUSH
46698: LD_INT 3
46700: PUSH
46701: LD_INT 2
46703: PUSH
46704: EMPTY
46705: LIST
46706: LIST
46707: PUSH
46708: LD_INT 4
46710: PUSH
46711: LD_INT 3
46713: PUSH
46714: EMPTY
46715: LIST
46716: LIST
46717: PUSH
46718: LD_INT 4
46720: PUSH
46721: LD_INT 4
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: PUSH
46728: LD_INT 3
46730: PUSH
46731: LD_INT 4
46733: PUSH
46734: EMPTY
46735: LIST
46736: LIST
46737: PUSH
46738: LD_INT 2
46740: PUSH
46741: LD_INT 3
46743: PUSH
46744: EMPTY
46745: LIST
46746: LIST
46747: PUSH
46748: LD_INT 2
46750: PUSH
46751: LD_INT 2
46753: PUSH
46754: EMPTY
46755: LIST
46756: LIST
46757: PUSH
46758: LD_INT 4
46760: PUSH
46761: LD_INT 2
46763: PUSH
46764: EMPTY
46765: LIST
46766: LIST
46767: PUSH
46768: LD_INT 2
46770: PUSH
46771: LD_INT 4
46773: PUSH
46774: EMPTY
46775: LIST
46776: LIST
46777: PUSH
46778: LD_INT 0
46780: PUSH
46781: LD_INT 4
46783: PUSH
46784: EMPTY
46785: LIST
46786: LIST
46787: PUSH
46788: LD_INT 0
46790: PUSH
46791: LD_INT 3
46793: PUSH
46794: EMPTY
46795: LIST
46796: LIST
46797: PUSH
46798: LD_INT 1
46800: PUSH
46801: LD_INT 4
46803: PUSH
46804: EMPTY
46805: LIST
46806: LIST
46807: PUSH
46808: LD_INT 1
46810: PUSH
46811: LD_INT 5
46813: PUSH
46814: EMPTY
46815: LIST
46816: LIST
46817: PUSH
46818: LD_INT 0
46820: PUSH
46821: LD_INT 5
46823: PUSH
46824: EMPTY
46825: LIST
46826: LIST
46827: PUSH
46828: LD_INT 1
46830: NEG
46831: PUSH
46832: LD_INT 4
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: PUSH
46839: LD_INT 1
46841: NEG
46842: PUSH
46843: LD_INT 3
46845: PUSH
46846: EMPTY
46847: LIST
46848: LIST
46849: PUSH
46850: LD_INT 2
46852: PUSH
46853: LD_INT 5
46855: PUSH
46856: EMPTY
46857: LIST
46858: LIST
46859: PUSH
46860: LD_INT 2
46862: NEG
46863: PUSH
46864: LD_INT 3
46866: PUSH
46867: EMPTY
46868: LIST
46869: LIST
46870: PUSH
46871: EMPTY
46872: LIST
46873: LIST
46874: LIST
46875: LIST
46876: LIST
46877: LIST
46878: LIST
46879: LIST
46880: LIST
46881: LIST
46882: LIST
46883: LIST
46884: LIST
46885: LIST
46886: LIST
46887: LIST
46888: LIST
46889: LIST
46890: LIST
46891: LIST
46892: LIST
46893: LIST
46894: LIST
46895: LIST
46896: LIST
46897: LIST
46898: LIST
46899: LIST
46900: LIST
46901: LIST
46902: LIST
46903: LIST
46904: LIST
46905: LIST
46906: LIST
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: LIST
46913: LIST
46914: LIST
46915: LIST
46916: LIST
46917: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46918: LD_ADDR_VAR 0 34
46922: PUSH
46923: LD_INT 0
46925: PUSH
46926: LD_INT 4
46928: NEG
46929: PUSH
46930: EMPTY
46931: LIST
46932: LIST
46933: PUSH
46934: LD_INT 0
46936: PUSH
46937: LD_INT 5
46939: NEG
46940: PUSH
46941: EMPTY
46942: LIST
46943: LIST
46944: PUSH
46945: LD_INT 1
46947: PUSH
46948: LD_INT 4
46950: NEG
46951: PUSH
46952: EMPTY
46953: LIST
46954: LIST
46955: PUSH
46956: LD_INT 1
46958: PUSH
46959: LD_INT 3
46961: NEG
46962: PUSH
46963: EMPTY
46964: LIST
46965: LIST
46966: PUSH
46967: LD_INT 0
46969: PUSH
46970: LD_INT 3
46972: NEG
46973: PUSH
46974: EMPTY
46975: LIST
46976: LIST
46977: PUSH
46978: LD_INT 1
46980: NEG
46981: PUSH
46982: LD_INT 4
46984: NEG
46985: PUSH
46986: EMPTY
46987: LIST
46988: LIST
46989: PUSH
46990: LD_INT 1
46992: NEG
46993: PUSH
46994: LD_INT 5
46996: NEG
46997: PUSH
46998: EMPTY
46999: LIST
47000: LIST
47001: PUSH
47002: LD_INT 2
47004: PUSH
47005: LD_INT 3
47007: NEG
47008: PUSH
47009: EMPTY
47010: LIST
47011: LIST
47012: PUSH
47013: LD_INT 2
47015: NEG
47016: PUSH
47017: LD_INT 5
47019: NEG
47020: PUSH
47021: EMPTY
47022: LIST
47023: LIST
47024: PUSH
47025: LD_INT 3
47027: PUSH
47028: LD_INT 0
47030: PUSH
47031: EMPTY
47032: LIST
47033: LIST
47034: PUSH
47035: LD_INT 3
47037: PUSH
47038: LD_INT 1
47040: NEG
47041: PUSH
47042: EMPTY
47043: LIST
47044: LIST
47045: PUSH
47046: LD_INT 4
47048: PUSH
47049: LD_INT 0
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PUSH
47056: LD_INT 4
47058: PUSH
47059: LD_INT 1
47061: PUSH
47062: EMPTY
47063: LIST
47064: LIST
47065: PUSH
47066: LD_INT 3
47068: PUSH
47069: LD_INT 1
47071: PUSH
47072: EMPTY
47073: LIST
47074: LIST
47075: PUSH
47076: LD_INT 2
47078: PUSH
47079: LD_INT 0
47081: PUSH
47082: EMPTY
47083: LIST
47084: LIST
47085: PUSH
47086: LD_INT 2
47088: PUSH
47089: LD_INT 1
47091: NEG
47092: PUSH
47093: EMPTY
47094: LIST
47095: LIST
47096: PUSH
47097: LD_INT 2
47099: PUSH
47100: LD_INT 2
47102: NEG
47103: PUSH
47104: EMPTY
47105: LIST
47106: LIST
47107: PUSH
47108: LD_INT 4
47110: PUSH
47111: LD_INT 2
47113: PUSH
47114: EMPTY
47115: LIST
47116: LIST
47117: PUSH
47118: LD_INT 4
47120: PUSH
47121: LD_INT 4
47123: PUSH
47124: EMPTY
47125: LIST
47126: LIST
47127: PUSH
47128: LD_INT 4
47130: PUSH
47131: LD_INT 3
47133: PUSH
47134: EMPTY
47135: LIST
47136: LIST
47137: PUSH
47138: LD_INT 5
47140: PUSH
47141: LD_INT 4
47143: PUSH
47144: EMPTY
47145: LIST
47146: LIST
47147: PUSH
47148: LD_INT 5
47150: PUSH
47151: LD_INT 5
47153: PUSH
47154: EMPTY
47155: LIST
47156: LIST
47157: PUSH
47158: LD_INT 4
47160: PUSH
47161: LD_INT 5
47163: PUSH
47164: EMPTY
47165: LIST
47166: LIST
47167: PUSH
47168: LD_INT 3
47170: PUSH
47171: LD_INT 4
47173: PUSH
47174: EMPTY
47175: LIST
47176: LIST
47177: PUSH
47178: LD_INT 3
47180: PUSH
47181: LD_INT 3
47183: PUSH
47184: EMPTY
47185: LIST
47186: LIST
47187: PUSH
47188: LD_INT 5
47190: PUSH
47191: LD_INT 3
47193: PUSH
47194: EMPTY
47195: LIST
47196: LIST
47197: PUSH
47198: LD_INT 3
47200: PUSH
47201: LD_INT 5
47203: PUSH
47204: EMPTY
47205: LIST
47206: LIST
47207: PUSH
47208: LD_INT 0
47210: PUSH
47211: LD_INT 3
47213: PUSH
47214: EMPTY
47215: LIST
47216: LIST
47217: PUSH
47218: LD_INT 0
47220: PUSH
47221: LD_INT 2
47223: PUSH
47224: EMPTY
47225: LIST
47226: LIST
47227: PUSH
47228: LD_INT 1
47230: PUSH
47231: LD_INT 3
47233: PUSH
47234: EMPTY
47235: LIST
47236: LIST
47237: PUSH
47238: LD_INT 1
47240: PUSH
47241: LD_INT 4
47243: PUSH
47244: EMPTY
47245: LIST
47246: LIST
47247: PUSH
47248: LD_INT 0
47250: PUSH
47251: LD_INT 4
47253: PUSH
47254: EMPTY
47255: LIST
47256: LIST
47257: PUSH
47258: LD_INT 1
47260: NEG
47261: PUSH
47262: LD_INT 3
47264: PUSH
47265: EMPTY
47266: LIST
47267: LIST
47268: PUSH
47269: LD_INT 1
47271: NEG
47272: PUSH
47273: LD_INT 2
47275: PUSH
47276: EMPTY
47277: LIST
47278: LIST
47279: PUSH
47280: LD_INT 2
47282: PUSH
47283: LD_INT 4
47285: PUSH
47286: EMPTY
47287: LIST
47288: LIST
47289: PUSH
47290: LD_INT 2
47292: NEG
47293: PUSH
47294: LD_INT 2
47296: PUSH
47297: EMPTY
47298: LIST
47299: LIST
47300: PUSH
47301: LD_INT 4
47303: NEG
47304: PUSH
47305: LD_INT 0
47307: PUSH
47308: EMPTY
47309: LIST
47310: LIST
47311: PUSH
47312: LD_INT 4
47314: NEG
47315: PUSH
47316: LD_INT 1
47318: NEG
47319: PUSH
47320: EMPTY
47321: LIST
47322: LIST
47323: PUSH
47324: LD_INT 3
47326: NEG
47327: PUSH
47328: LD_INT 0
47330: PUSH
47331: EMPTY
47332: LIST
47333: LIST
47334: PUSH
47335: LD_INT 3
47337: NEG
47338: PUSH
47339: LD_INT 1
47341: PUSH
47342: EMPTY
47343: LIST
47344: LIST
47345: PUSH
47346: LD_INT 4
47348: NEG
47349: PUSH
47350: LD_INT 1
47352: PUSH
47353: EMPTY
47354: LIST
47355: LIST
47356: PUSH
47357: LD_INT 5
47359: NEG
47360: PUSH
47361: LD_INT 0
47363: PUSH
47364: EMPTY
47365: LIST
47366: LIST
47367: PUSH
47368: LD_INT 5
47370: NEG
47371: PUSH
47372: LD_INT 1
47374: NEG
47375: PUSH
47376: EMPTY
47377: LIST
47378: LIST
47379: PUSH
47380: LD_INT 5
47382: NEG
47383: PUSH
47384: LD_INT 2
47386: NEG
47387: PUSH
47388: EMPTY
47389: LIST
47390: LIST
47391: PUSH
47392: LD_INT 3
47394: NEG
47395: PUSH
47396: LD_INT 2
47398: PUSH
47399: EMPTY
47400: LIST
47401: LIST
47402: PUSH
47403: EMPTY
47404: LIST
47405: LIST
47406: LIST
47407: LIST
47408: LIST
47409: LIST
47410: LIST
47411: LIST
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: LIST
47417: LIST
47418: LIST
47419: LIST
47420: LIST
47421: LIST
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: LIST
47435: LIST
47436: LIST
47437: LIST
47438: LIST
47439: LIST
47440: LIST
47441: LIST
47442: LIST
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: ST_TO_ADDR
// end ; end ;
47450: GO 47453
47452: POP
// case btype of b_depot , b_warehouse :
47453: LD_VAR 0 1
47457: PUSH
47458: LD_INT 0
47460: DOUBLE
47461: EQUAL
47462: IFTRUE 47472
47464: LD_INT 1
47466: DOUBLE
47467: EQUAL
47468: IFTRUE 47472
47470: GO 47673
47472: POP
// case nation of nation_american :
47473: LD_VAR 0 5
47477: PUSH
47478: LD_INT 1
47480: DOUBLE
47481: EQUAL
47482: IFTRUE 47486
47484: GO 47542
47486: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
47487: LD_ADDR_VAR 0 9
47491: PUSH
47492: LD_VAR 0 11
47496: PUSH
47497: LD_VAR 0 12
47501: PUSH
47502: LD_VAR 0 13
47506: PUSH
47507: LD_VAR 0 14
47511: PUSH
47512: LD_VAR 0 15
47516: PUSH
47517: LD_VAR 0 16
47521: PUSH
47522: EMPTY
47523: LIST
47524: LIST
47525: LIST
47526: LIST
47527: LIST
47528: LIST
47529: PUSH
47530: LD_VAR 0 4
47534: PUSH
47535: LD_INT 1
47537: PLUS
47538: ARRAY
47539: ST_TO_ADDR
47540: GO 47671
47542: LD_INT 2
47544: DOUBLE
47545: EQUAL
47546: IFTRUE 47550
47548: GO 47606
47550: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
47551: LD_ADDR_VAR 0 9
47555: PUSH
47556: LD_VAR 0 17
47560: PUSH
47561: LD_VAR 0 18
47565: PUSH
47566: LD_VAR 0 19
47570: PUSH
47571: LD_VAR 0 20
47575: PUSH
47576: LD_VAR 0 21
47580: PUSH
47581: LD_VAR 0 22
47585: PUSH
47586: EMPTY
47587: LIST
47588: LIST
47589: LIST
47590: LIST
47591: LIST
47592: LIST
47593: PUSH
47594: LD_VAR 0 4
47598: PUSH
47599: LD_INT 1
47601: PLUS
47602: ARRAY
47603: ST_TO_ADDR
47604: GO 47671
47606: LD_INT 3
47608: DOUBLE
47609: EQUAL
47610: IFTRUE 47614
47612: GO 47670
47614: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
47615: LD_ADDR_VAR 0 9
47619: PUSH
47620: LD_VAR 0 23
47624: PUSH
47625: LD_VAR 0 24
47629: PUSH
47630: LD_VAR 0 25
47634: PUSH
47635: LD_VAR 0 26
47639: PUSH
47640: LD_VAR 0 27
47644: PUSH
47645: LD_VAR 0 28
47649: PUSH
47650: EMPTY
47651: LIST
47652: LIST
47653: LIST
47654: LIST
47655: LIST
47656: LIST
47657: PUSH
47658: LD_VAR 0 4
47662: PUSH
47663: LD_INT 1
47665: PLUS
47666: ARRAY
47667: ST_TO_ADDR
47668: GO 47671
47670: POP
47671: GO 48226
47673: LD_INT 2
47675: DOUBLE
47676: EQUAL
47677: IFTRUE 47687
47679: LD_INT 3
47681: DOUBLE
47682: EQUAL
47683: IFTRUE 47687
47685: GO 47743
47687: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47688: LD_ADDR_VAR 0 9
47692: PUSH
47693: LD_VAR 0 29
47697: PUSH
47698: LD_VAR 0 30
47702: PUSH
47703: LD_VAR 0 31
47707: PUSH
47708: LD_VAR 0 32
47712: PUSH
47713: LD_VAR 0 33
47717: PUSH
47718: LD_VAR 0 34
47722: PUSH
47723: EMPTY
47724: LIST
47725: LIST
47726: LIST
47727: LIST
47728: LIST
47729: LIST
47730: PUSH
47731: LD_VAR 0 4
47735: PUSH
47736: LD_INT 1
47738: PLUS
47739: ARRAY
47740: ST_TO_ADDR
47741: GO 48226
47743: LD_INT 16
47745: DOUBLE
47746: EQUAL
47747: IFTRUE 47805
47749: LD_INT 17
47751: DOUBLE
47752: EQUAL
47753: IFTRUE 47805
47755: LD_INT 18
47757: DOUBLE
47758: EQUAL
47759: IFTRUE 47805
47761: LD_INT 19
47763: DOUBLE
47764: EQUAL
47765: IFTRUE 47805
47767: LD_INT 22
47769: DOUBLE
47770: EQUAL
47771: IFTRUE 47805
47773: LD_INT 20
47775: DOUBLE
47776: EQUAL
47777: IFTRUE 47805
47779: LD_INT 21
47781: DOUBLE
47782: EQUAL
47783: IFTRUE 47805
47785: LD_INT 23
47787: DOUBLE
47788: EQUAL
47789: IFTRUE 47805
47791: LD_INT 24
47793: DOUBLE
47794: EQUAL
47795: IFTRUE 47805
47797: LD_INT 25
47799: DOUBLE
47800: EQUAL
47801: IFTRUE 47805
47803: GO 47861
47805: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47806: LD_ADDR_VAR 0 9
47810: PUSH
47811: LD_VAR 0 35
47815: PUSH
47816: LD_VAR 0 36
47820: PUSH
47821: LD_VAR 0 37
47825: PUSH
47826: LD_VAR 0 38
47830: PUSH
47831: LD_VAR 0 39
47835: PUSH
47836: LD_VAR 0 40
47840: PUSH
47841: EMPTY
47842: LIST
47843: LIST
47844: LIST
47845: LIST
47846: LIST
47847: LIST
47848: PUSH
47849: LD_VAR 0 4
47853: PUSH
47854: LD_INT 1
47856: PLUS
47857: ARRAY
47858: ST_TO_ADDR
47859: GO 48226
47861: LD_INT 6
47863: DOUBLE
47864: EQUAL
47865: IFTRUE 47917
47867: LD_INT 7
47869: DOUBLE
47870: EQUAL
47871: IFTRUE 47917
47873: LD_INT 8
47875: DOUBLE
47876: EQUAL
47877: IFTRUE 47917
47879: LD_INT 13
47881: DOUBLE
47882: EQUAL
47883: IFTRUE 47917
47885: LD_INT 12
47887: DOUBLE
47888: EQUAL
47889: IFTRUE 47917
47891: LD_INT 15
47893: DOUBLE
47894: EQUAL
47895: IFTRUE 47917
47897: LD_INT 11
47899: DOUBLE
47900: EQUAL
47901: IFTRUE 47917
47903: LD_INT 14
47905: DOUBLE
47906: EQUAL
47907: IFTRUE 47917
47909: LD_INT 10
47911: DOUBLE
47912: EQUAL
47913: IFTRUE 47917
47915: GO 47973
47917: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47918: LD_ADDR_VAR 0 9
47922: PUSH
47923: LD_VAR 0 41
47927: PUSH
47928: LD_VAR 0 42
47932: PUSH
47933: LD_VAR 0 43
47937: PUSH
47938: LD_VAR 0 44
47942: PUSH
47943: LD_VAR 0 45
47947: PUSH
47948: LD_VAR 0 46
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: LIST
47957: LIST
47958: LIST
47959: LIST
47960: PUSH
47961: LD_VAR 0 4
47965: PUSH
47966: LD_INT 1
47968: PLUS
47969: ARRAY
47970: ST_TO_ADDR
47971: GO 48226
47973: LD_INT 36
47975: DOUBLE
47976: EQUAL
47977: IFTRUE 47981
47979: GO 48037
47981: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47982: LD_ADDR_VAR 0 9
47986: PUSH
47987: LD_VAR 0 47
47991: PUSH
47992: LD_VAR 0 48
47996: PUSH
47997: LD_VAR 0 49
48001: PUSH
48002: LD_VAR 0 50
48006: PUSH
48007: LD_VAR 0 51
48011: PUSH
48012: LD_VAR 0 52
48016: PUSH
48017: EMPTY
48018: LIST
48019: LIST
48020: LIST
48021: LIST
48022: LIST
48023: LIST
48024: PUSH
48025: LD_VAR 0 4
48029: PUSH
48030: LD_INT 1
48032: PLUS
48033: ARRAY
48034: ST_TO_ADDR
48035: GO 48226
48037: LD_INT 4
48039: DOUBLE
48040: EQUAL
48041: IFTRUE 48063
48043: LD_INT 5
48045: DOUBLE
48046: EQUAL
48047: IFTRUE 48063
48049: LD_INT 34
48051: DOUBLE
48052: EQUAL
48053: IFTRUE 48063
48055: LD_INT 37
48057: DOUBLE
48058: EQUAL
48059: IFTRUE 48063
48061: GO 48119
48063: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
48064: LD_ADDR_VAR 0 9
48068: PUSH
48069: LD_VAR 0 53
48073: PUSH
48074: LD_VAR 0 54
48078: PUSH
48079: LD_VAR 0 55
48083: PUSH
48084: LD_VAR 0 56
48088: PUSH
48089: LD_VAR 0 57
48093: PUSH
48094: LD_VAR 0 58
48098: PUSH
48099: EMPTY
48100: LIST
48101: LIST
48102: LIST
48103: LIST
48104: LIST
48105: LIST
48106: PUSH
48107: LD_VAR 0 4
48111: PUSH
48112: LD_INT 1
48114: PLUS
48115: ARRAY
48116: ST_TO_ADDR
48117: GO 48226
48119: LD_INT 31
48121: DOUBLE
48122: EQUAL
48123: IFTRUE 48169
48125: LD_INT 32
48127: DOUBLE
48128: EQUAL
48129: IFTRUE 48169
48131: LD_INT 33
48133: DOUBLE
48134: EQUAL
48135: IFTRUE 48169
48137: LD_INT 27
48139: DOUBLE
48140: EQUAL
48141: IFTRUE 48169
48143: LD_INT 26
48145: DOUBLE
48146: EQUAL
48147: IFTRUE 48169
48149: LD_INT 28
48151: DOUBLE
48152: EQUAL
48153: IFTRUE 48169
48155: LD_INT 29
48157: DOUBLE
48158: EQUAL
48159: IFTRUE 48169
48161: LD_INT 30
48163: DOUBLE
48164: EQUAL
48165: IFTRUE 48169
48167: GO 48225
48169: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
48170: LD_ADDR_VAR 0 9
48174: PUSH
48175: LD_VAR 0 59
48179: PUSH
48180: LD_VAR 0 60
48184: PUSH
48185: LD_VAR 0 61
48189: PUSH
48190: LD_VAR 0 62
48194: PUSH
48195: LD_VAR 0 63
48199: PUSH
48200: LD_VAR 0 64
48204: PUSH
48205: EMPTY
48206: LIST
48207: LIST
48208: LIST
48209: LIST
48210: LIST
48211: LIST
48212: PUSH
48213: LD_VAR 0 4
48217: PUSH
48218: LD_INT 1
48220: PLUS
48221: ARRAY
48222: ST_TO_ADDR
48223: GO 48226
48225: POP
// temp_list2 = [ ] ;
48226: LD_ADDR_VAR 0 10
48230: PUSH
48231: EMPTY
48232: ST_TO_ADDR
// for i in temp_list do
48233: LD_ADDR_VAR 0 8
48237: PUSH
48238: LD_VAR 0 9
48242: PUSH
48243: FOR_IN
48244: IFFALSE 48296
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
48246: LD_ADDR_VAR 0 10
48250: PUSH
48251: LD_VAR 0 10
48255: PUSH
48256: LD_VAR 0 8
48260: PUSH
48261: LD_INT 1
48263: ARRAY
48264: PUSH
48265: LD_VAR 0 2
48269: PLUS
48270: PUSH
48271: LD_VAR 0 8
48275: PUSH
48276: LD_INT 2
48278: ARRAY
48279: PUSH
48280: LD_VAR 0 3
48284: PLUS
48285: PUSH
48286: EMPTY
48287: LIST
48288: LIST
48289: PUSH
48290: EMPTY
48291: LIST
48292: ADD
48293: ST_TO_ADDR
48294: GO 48243
48296: POP
48297: POP
// result = temp_list2 ;
48298: LD_ADDR_VAR 0 7
48302: PUSH
48303: LD_VAR 0 10
48307: ST_TO_ADDR
// end ;
48308: LD_VAR 0 7
48312: RET
// export function EnemyInRange ( unit , dist ) ; begin
48313: LD_INT 0
48315: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
48316: LD_ADDR_VAR 0 3
48320: PUSH
48321: LD_VAR 0 1
48325: PPUSH
48326: CALL_OW 255
48330: PPUSH
48331: LD_VAR 0 1
48335: PPUSH
48336: CALL_OW 250
48340: PPUSH
48341: LD_VAR 0 1
48345: PPUSH
48346: CALL_OW 251
48350: PPUSH
48351: LD_VAR 0 2
48355: PPUSH
48356: CALL 22417 0 4
48360: PUSH
48361: LD_INT 4
48363: ARRAY
48364: ST_TO_ADDR
// end ;
48365: LD_VAR 0 3
48369: RET
// export function PlayerSeeMe ( unit ) ; begin
48370: LD_INT 0
48372: PPUSH
// result := See ( your_side , unit ) ;
48373: LD_ADDR_VAR 0 2
48377: PUSH
48378: LD_OWVAR 2
48382: PPUSH
48383: LD_VAR 0 1
48387: PPUSH
48388: CALL_OW 292
48392: ST_TO_ADDR
// end ;
48393: LD_VAR 0 2
48397: RET
// export function ReverseDir ( unit ) ; begin
48398: LD_INT 0
48400: PPUSH
// if not unit then
48401: LD_VAR 0 1
48405: NOT
48406: IFFALSE 48410
// exit ;
48408: GO 48433
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
48410: LD_ADDR_VAR 0 2
48414: PUSH
48415: LD_VAR 0 1
48419: PPUSH
48420: CALL_OW 254
48424: PUSH
48425: LD_INT 3
48427: PLUS
48428: PUSH
48429: LD_INT 6
48431: MOD
48432: ST_TO_ADDR
// end ;
48433: LD_VAR 0 2
48437: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
48438: LD_INT 0
48440: PPUSH
48441: PPUSH
48442: PPUSH
48443: PPUSH
48444: PPUSH
// if not hexes then
48445: LD_VAR 0 2
48449: NOT
48450: IFFALSE 48454
// exit ;
48452: GO 48602
// dist := 9999 ;
48454: LD_ADDR_VAR 0 5
48458: PUSH
48459: LD_INT 9999
48461: ST_TO_ADDR
// for i = 1 to hexes do
48462: LD_ADDR_VAR 0 4
48466: PUSH
48467: DOUBLE
48468: LD_INT 1
48470: DEC
48471: ST_TO_ADDR
48472: LD_VAR 0 2
48476: PUSH
48477: FOR_TO
48478: IFFALSE 48590
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
48480: LD_VAR 0 1
48484: PPUSH
48485: LD_VAR 0 2
48489: PUSH
48490: LD_VAR 0 4
48494: ARRAY
48495: PUSH
48496: LD_INT 1
48498: ARRAY
48499: PPUSH
48500: LD_VAR 0 2
48504: PUSH
48505: LD_VAR 0 4
48509: ARRAY
48510: PUSH
48511: LD_INT 2
48513: ARRAY
48514: PPUSH
48515: CALL_OW 297
48519: PUSH
48520: LD_VAR 0 5
48524: LESS
48525: IFFALSE 48588
// begin hex := hexes [ i ] ;
48527: LD_ADDR_VAR 0 7
48531: PUSH
48532: LD_VAR 0 2
48536: PUSH
48537: LD_VAR 0 4
48541: ARRAY
48542: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
48543: LD_ADDR_VAR 0 5
48547: PUSH
48548: LD_VAR 0 1
48552: PPUSH
48553: LD_VAR 0 2
48557: PUSH
48558: LD_VAR 0 4
48562: ARRAY
48563: PUSH
48564: LD_INT 1
48566: ARRAY
48567: PPUSH
48568: LD_VAR 0 2
48572: PUSH
48573: LD_VAR 0 4
48577: ARRAY
48578: PUSH
48579: LD_INT 2
48581: ARRAY
48582: PPUSH
48583: CALL_OW 297
48587: ST_TO_ADDR
// end ; end ;
48588: GO 48477
48590: POP
48591: POP
// result := hex ;
48592: LD_ADDR_VAR 0 3
48596: PUSH
48597: LD_VAR 0 7
48601: ST_TO_ADDR
// end ;
48602: LD_VAR 0 3
48606: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
48607: LD_INT 0
48609: PPUSH
48610: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
48611: LD_VAR 0 1
48615: NOT
48616: PUSH
48617: LD_VAR 0 1
48621: PUSH
48622: LD_INT 21
48624: PUSH
48625: LD_INT 2
48627: PUSH
48628: EMPTY
48629: LIST
48630: LIST
48631: PUSH
48632: LD_INT 23
48634: PUSH
48635: LD_INT 2
48637: PUSH
48638: EMPTY
48639: LIST
48640: LIST
48641: PUSH
48642: EMPTY
48643: LIST
48644: LIST
48645: PPUSH
48646: CALL_OW 69
48650: IN
48651: NOT
48652: OR
48653: IFFALSE 48657
// exit ;
48655: GO 48704
// for i = 1 to 3 do
48657: LD_ADDR_VAR 0 3
48661: PUSH
48662: DOUBLE
48663: LD_INT 1
48665: DEC
48666: ST_TO_ADDR
48667: LD_INT 3
48669: PUSH
48670: FOR_TO
48671: IFFALSE 48702
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48673: LD_VAR 0 1
48677: PPUSH
48678: CALL_OW 250
48682: PPUSH
48683: LD_VAR 0 1
48687: PPUSH
48688: CALL_OW 251
48692: PPUSH
48693: LD_INT 1
48695: PPUSH
48696: CALL_OW 453
48700: GO 48670
48702: POP
48703: POP
// end ;
48704: LD_VAR 0 2
48708: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48709: LD_INT 0
48711: PPUSH
48712: PPUSH
48713: PPUSH
48714: PPUSH
48715: PPUSH
48716: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48717: LD_VAR 0 1
48721: NOT
48722: PUSH
48723: LD_VAR 0 2
48727: NOT
48728: OR
48729: PUSH
48730: LD_VAR 0 1
48734: PPUSH
48735: CALL_OW 314
48739: OR
48740: IFFALSE 48744
// exit ;
48742: GO 49185
// x := GetX ( enemy_unit ) ;
48744: LD_ADDR_VAR 0 7
48748: PUSH
48749: LD_VAR 0 2
48753: PPUSH
48754: CALL_OW 250
48758: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48759: LD_ADDR_VAR 0 8
48763: PUSH
48764: LD_VAR 0 2
48768: PPUSH
48769: CALL_OW 251
48773: ST_TO_ADDR
// if not x or not y then
48774: LD_VAR 0 7
48778: NOT
48779: PUSH
48780: LD_VAR 0 8
48784: NOT
48785: OR
48786: IFFALSE 48790
// exit ;
48788: GO 49185
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48790: LD_ADDR_VAR 0 6
48794: PUSH
48795: LD_VAR 0 7
48799: PPUSH
48800: LD_INT 0
48802: PPUSH
48803: LD_INT 4
48805: PPUSH
48806: CALL_OW 272
48810: PUSH
48811: LD_VAR 0 8
48815: PPUSH
48816: LD_INT 0
48818: PPUSH
48819: LD_INT 4
48821: PPUSH
48822: CALL_OW 273
48826: PUSH
48827: EMPTY
48828: LIST
48829: LIST
48830: PUSH
48831: LD_VAR 0 7
48835: PPUSH
48836: LD_INT 1
48838: PPUSH
48839: LD_INT 4
48841: PPUSH
48842: CALL_OW 272
48846: PUSH
48847: LD_VAR 0 8
48851: PPUSH
48852: LD_INT 1
48854: PPUSH
48855: LD_INT 4
48857: PPUSH
48858: CALL_OW 273
48862: PUSH
48863: EMPTY
48864: LIST
48865: LIST
48866: PUSH
48867: LD_VAR 0 7
48871: PPUSH
48872: LD_INT 2
48874: PPUSH
48875: LD_INT 4
48877: PPUSH
48878: CALL_OW 272
48882: PUSH
48883: LD_VAR 0 8
48887: PPUSH
48888: LD_INT 2
48890: PPUSH
48891: LD_INT 4
48893: PPUSH
48894: CALL_OW 273
48898: PUSH
48899: EMPTY
48900: LIST
48901: LIST
48902: PUSH
48903: LD_VAR 0 7
48907: PPUSH
48908: LD_INT 3
48910: PPUSH
48911: LD_INT 4
48913: PPUSH
48914: CALL_OW 272
48918: PUSH
48919: LD_VAR 0 8
48923: PPUSH
48924: LD_INT 3
48926: PPUSH
48927: LD_INT 4
48929: PPUSH
48930: CALL_OW 273
48934: PUSH
48935: EMPTY
48936: LIST
48937: LIST
48938: PUSH
48939: LD_VAR 0 7
48943: PPUSH
48944: LD_INT 4
48946: PPUSH
48947: LD_INT 4
48949: PPUSH
48950: CALL_OW 272
48954: PUSH
48955: LD_VAR 0 8
48959: PPUSH
48960: LD_INT 4
48962: PPUSH
48963: LD_INT 4
48965: PPUSH
48966: CALL_OW 273
48970: PUSH
48971: EMPTY
48972: LIST
48973: LIST
48974: PUSH
48975: LD_VAR 0 7
48979: PPUSH
48980: LD_INT 5
48982: PPUSH
48983: LD_INT 4
48985: PPUSH
48986: CALL_OW 272
48990: PUSH
48991: LD_VAR 0 8
48995: PPUSH
48996: LD_INT 5
48998: PPUSH
48999: LD_INT 4
49001: PPUSH
49002: CALL_OW 273
49006: PUSH
49007: EMPTY
49008: LIST
49009: LIST
49010: PUSH
49011: EMPTY
49012: LIST
49013: LIST
49014: LIST
49015: LIST
49016: LIST
49017: LIST
49018: ST_TO_ADDR
// for i = tmp downto 1 do
49019: LD_ADDR_VAR 0 4
49023: PUSH
49024: DOUBLE
49025: LD_VAR 0 6
49029: INC
49030: ST_TO_ADDR
49031: LD_INT 1
49033: PUSH
49034: FOR_DOWNTO
49035: IFFALSE 49136
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
49037: LD_VAR 0 6
49041: PUSH
49042: LD_VAR 0 4
49046: ARRAY
49047: PUSH
49048: LD_INT 1
49050: ARRAY
49051: PPUSH
49052: LD_VAR 0 6
49056: PUSH
49057: LD_VAR 0 4
49061: ARRAY
49062: PUSH
49063: LD_INT 2
49065: ARRAY
49066: PPUSH
49067: CALL_OW 488
49071: NOT
49072: PUSH
49073: LD_VAR 0 6
49077: PUSH
49078: LD_VAR 0 4
49082: ARRAY
49083: PUSH
49084: LD_INT 1
49086: ARRAY
49087: PPUSH
49088: LD_VAR 0 6
49092: PUSH
49093: LD_VAR 0 4
49097: ARRAY
49098: PUSH
49099: LD_INT 2
49101: ARRAY
49102: PPUSH
49103: CALL_OW 428
49107: PUSH
49108: LD_INT 0
49110: NONEQUAL
49111: OR
49112: IFFALSE 49134
// tmp := Delete ( tmp , i ) ;
49114: LD_ADDR_VAR 0 6
49118: PUSH
49119: LD_VAR 0 6
49123: PPUSH
49124: LD_VAR 0 4
49128: PPUSH
49129: CALL_OW 3
49133: ST_TO_ADDR
49134: GO 49034
49136: POP
49137: POP
// j := GetClosestHex ( unit , tmp ) ;
49138: LD_ADDR_VAR 0 5
49142: PUSH
49143: LD_VAR 0 1
49147: PPUSH
49148: LD_VAR 0 6
49152: PPUSH
49153: CALL 48438 0 2
49157: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
49158: LD_VAR 0 1
49162: PPUSH
49163: LD_VAR 0 5
49167: PUSH
49168: LD_INT 1
49170: ARRAY
49171: PPUSH
49172: LD_VAR 0 5
49176: PUSH
49177: LD_INT 2
49179: ARRAY
49180: PPUSH
49181: CALL_OW 111
// end ;
49185: LD_VAR 0 3
49189: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
49190: LD_INT 0
49192: PPUSH
49193: PPUSH
49194: PPUSH
// uc_side = 0 ;
49195: LD_ADDR_OWVAR 20
49199: PUSH
49200: LD_INT 0
49202: ST_TO_ADDR
// uc_nation = 0 ;
49203: LD_ADDR_OWVAR 21
49207: PUSH
49208: LD_INT 0
49210: ST_TO_ADDR
// InitHc ;
49211: CALL_OW 19
// InitVc ;
49215: CALL_OW 20
// if mastodonts then
49219: LD_VAR 0 6
49223: IFFALSE 49290
// for i = 1 to mastodonts do
49225: LD_ADDR_VAR 0 11
49229: PUSH
49230: DOUBLE
49231: LD_INT 1
49233: DEC
49234: ST_TO_ADDR
49235: LD_VAR 0 6
49239: PUSH
49240: FOR_TO
49241: IFFALSE 49288
// begin vc_chassis := 31 ;
49243: LD_ADDR_OWVAR 37
49247: PUSH
49248: LD_INT 31
49250: ST_TO_ADDR
// vc_control := control_rider ;
49251: LD_ADDR_OWVAR 38
49255: PUSH
49256: LD_INT 4
49258: ST_TO_ADDR
// animal := CreateVehicle ;
49259: LD_ADDR_VAR 0 12
49263: PUSH
49264: CALL_OW 45
49268: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49269: LD_VAR 0 12
49273: PPUSH
49274: LD_VAR 0 8
49278: PPUSH
49279: LD_INT 0
49281: PPUSH
49282: CALL 56061 0 3
// end ;
49286: GO 49240
49288: POP
49289: POP
// if horses then
49290: LD_VAR 0 5
49294: IFFALSE 49361
// for i = 1 to horses do
49296: LD_ADDR_VAR 0 11
49300: PUSH
49301: DOUBLE
49302: LD_INT 1
49304: DEC
49305: ST_TO_ADDR
49306: LD_VAR 0 5
49310: PUSH
49311: FOR_TO
49312: IFFALSE 49359
// begin hc_class := 21 ;
49314: LD_ADDR_OWVAR 28
49318: PUSH
49319: LD_INT 21
49321: ST_TO_ADDR
// hc_gallery :=  ;
49322: LD_ADDR_OWVAR 33
49326: PUSH
49327: LD_STRING 
49329: ST_TO_ADDR
// animal := CreateHuman ;
49330: LD_ADDR_VAR 0 12
49334: PUSH
49335: CALL_OW 44
49339: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49340: LD_VAR 0 12
49344: PPUSH
49345: LD_VAR 0 8
49349: PPUSH
49350: LD_INT 0
49352: PPUSH
49353: CALL 56061 0 3
// end ;
49357: GO 49311
49359: POP
49360: POP
// if birds then
49361: LD_VAR 0 1
49365: IFFALSE 49432
// for i = 1 to birds do
49367: LD_ADDR_VAR 0 11
49371: PUSH
49372: DOUBLE
49373: LD_INT 1
49375: DEC
49376: ST_TO_ADDR
49377: LD_VAR 0 1
49381: PUSH
49382: FOR_TO
49383: IFFALSE 49430
// begin hc_class = 18 ;
49385: LD_ADDR_OWVAR 28
49389: PUSH
49390: LD_INT 18
49392: ST_TO_ADDR
// hc_gallery =  ;
49393: LD_ADDR_OWVAR 33
49397: PUSH
49398: LD_STRING 
49400: ST_TO_ADDR
// animal := CreateHuman ;
49401: LD_ADDR_VAR 0 12
49405: PUSH
49406: CALL_OW 44
49410: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49411: LD_VAR 0 12
49415: PPUSH
49416: LD_VAR 0 8
49420: PPUSH
49421: LD_INT 0
49423: PPUSH
49424: CALL 56061 0 3
// end ;
49428: GO 49382
49430: POP
49431: POP
// if tigers then
49432: LD_VAR 0 2
49436: IFFALSE 49520
// for i = 1 to tigers do
49438: LD_ADDR_VAR 0 11
49442: PUSH
49443: DOUBLE
49444: LD_INT 1
49446: DEC
49447: ST_TO_ADDR
49448: LD_VAR 0 2
49452: PUSH
49453: FOR_TO
49454: IFFALSE 49518
// begin hc_class = class_tiger ;
49456: LD_ADDR_OWVAR 28
49460: PUSH
49461: LD_INT 14
49463: ST_TO_ADDR
// hc_gallery =  ;
49464: LD_ADDR_OWVAR 33
49468: PUSH
49469: LD_STRING 
49471: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49472: LD_ADDR_OWVAR 35
49476: PUSH
49477: LD_INT 7
49479: NEG
49480: PPUSH
49481: LD_INT 7
49483: PPUSH
49484: CALL_OW 12
49488: ST_TO_ADDR
// animal := CreateHuman ;
49489: LD_ADDR_VAR 0 12
49493: PUSH
49494: CALL_OW 44
49498: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49499: LD_VAR 0 12
49503: PPUSH
49504: LD_VAR 0 8
49508: PPUSH
49509: LD_INT 0
49511: PPUSH
49512: CALL 56061 0 3
// end ;
49516: GO 49453
49518: POP
49519: POP
// if apemans then
49520: LD_VAR 0 3
49524: IFFALSE 49647
// for i = 1 to apemans do
49526: LD_ADDR_VAR 0 11
49530: PUSH
49531: DOUBLE
49532: LD_INT 1
49534: DEC
49535: ST_TO_ADDR
49536: LD_VAR 0 3
49540: PUSH
49541: FOR_TO
49542: IFFALSE 49645
// begin hc_class = class_apeman ;
49544: LD_ADDR_OWVAR 28
49548: PUSH
49549: LD_INT 12
49551: ST_TO_ADDR
// hc_gallery =  ;
49552: LD_ADDR_OWVAR 33
49556: PUSH
49557: LD_STRING 
49559: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
49560: LD_ADDR_OWVAR 35
49564: PUSH
49565: LD_INT 5
49567: NEG
49568: PPUSH
49569: LD_INT 5
49571: PPUSH
49572: CALL_OW 12
49576: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49577: LD_ADDR_OWVAR 31
49581: PUSH
49582: LD_INT 1
49584: PPUSH
49585: LD_INT 3
49587: PPUSH
49588: CALL_OW 12
49592: PUSH
49593: LD_INT 1
49595: PPUSH
49596: LD_INT 3
49598: PPUSH
49599: CALL_OW 12
49603: PUSH
49604: LD_INT 0
49606: PUSH
49607: LD_INT 0
49609: PUSH
49610: EMPTY
49611: LIST
49612: LIST
49613: LIST
49614: LIST
49615: ST_TO_ADDR
// animal := CreateHuman ;
49616: LD_ADDR_VAR 0 12
49620: PUSH
49621: CALL_OW 44
49625: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49626: LD_VAR 0 12
49630: PPUSH
49631: LD_VAR 0 8
49635: PPUSH
49636: LD_INT 0
49638: PPUSH
49639: CALL 56061 0 3
// end ;
49643: GO 49541
49645: POP
49646: POP
// if enchidnas then
49647: LD_VAR 0 4
49651: IFFALSE 49718
// for i = 1 to enchidnas do
49653: LD_ADDR_VAR 0 11
49657: PUSH
49658: DOUBLE
49659: LD_INT 1
49661: DEC
49662: ST_TO_ADDR
49663: LD_VAR 0 4
49667: PUSH
49668: FOR_TO
49669: IFFALSE 49716
// begin hc_class = 13 ;
49671: LD_ADDR_OWVAR 28
49675: PUSH
49676: LD_INT 13
49678: ST_TO_ADDR
// hc_gallery =  ;
49679: LD_ADDR_OWVAR 33
49683: PUSH
49684: LD_STRING 
49686: ST_TO_ADDR
// animal := CreateHuman ;
49687: LD_ADDR_VAR 0 12
49691: PUSH
49692: CALL_OW 44
49696: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49697: LD_VAR 0 12
49701: PPUSH
49702: LD_VAR 0 8
49706: PPUSH
49707: LD_INT 0
49709: PPUSH
49710: CALL 56061 0 3
// end ;
49714: GO 49668
49716: POP
49717: POP
// if fishes then
49718: LD_VAR 0 7
49722: IFFALSE 49789
// for i = 1 to fishes do
49724: LD_ADDR_VAR 0 11
49728: PUSH
49729: DOUBLE
49730: LD_INT 1
49732: DEC
49733: ST_TO_ADDR
49734: LD_VAR 0 7
49738: PUSH
49739: FOR_TO
49740: IFFALSE 49787
// begin hc_class = 20 ;
49742: LD_ADDR_OWVAR 28
49746: PUSH
49747: LD_INT 20
49749: ST_TO_ADDR
// hc_gallery =  ;
49750: LD_ADDR_OWVAR 33
49754: PUSH
49755: LD_STRING 
49757: ST_TO_ADDR
// animal := CreateHuman ;
49758: LD_ADDR_VAR 0 12
49762: PUSH
49763: CALL_OW 44
49767: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49768: LD_VAR 0 12
49772: PPUSH
49773: LD_VAR 0 9
49777: PPUSH
49778: LD_INT 0
49780: PPUSH
49781: CALL 56061 0 3
// end ;
49785: GO 49739
49787: POP
49788: POP
// end ;
49789: LD_VAR 0 10
49793: RET
// export function WantHeal ( sci , unit ) ; begin
49794: LD_INT 0
49796: PPUSH
// if GetTaskList ( sci ) > 0 then
49797: LD_VAR 0 1
49801: PPUSH
49802: CALL_OW 437
49806: PUSH
49807: LD_INT 0
49809: GREATER
49810: IFFALSE 49880
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49812: LD_VAR 0 1
49816: PPUSH
49817: CALL_OW 437
49821: PUSH
49822: LD_INT 1
49824: ARRAY
49825: PUSH
49826: LD_INT 1
49828: ARRAY
49829: PUSH
49830: LD_STRING l
49832: EQUAL
49833: PUSH
49834: LD_VAR 0 1
49838: PPUSH
49839: CALL_OW 437
49843: PUSH
49844: LD_INT 1
49846: ARRAY
49847: PUSH
49848: LD_INT 4
49850: ARRAY
49851: PUSH
49852: LD_VAR 0 2
49856: EQUAL
49857: AND
49858: IFFALSE 49870
// result := true else
49860: LD_ADDR_VAR 0 3
49864: PUSH
49865: LD_INT 1
49867: ST_TO_ADDR
49868: GO 49878
// result := false ;
49870: LD_ADDR_VAR 0 3
49874: PUSH
49875: LD_INT 0
49877: ST_TO_ADDR
// end else
49878: GO 49888
// result := false ;
49880: LD_ADDR_VAR 0 3
49884: PUSH
49885: LD_INT 0
49887: ST_TO_ADDR
// end ;
49888: LD_VAR 0 3
49892: RET
// export function HealTarget ( sci ) ; begin
49893: LD_INT 0
49895: PPUSH
// if not sci then
49896: LD_VAR 0 1
49900: NOT
49901: IFFALSE 49905
// exit ;
49903: GO 49970
// result := 0 ;
49905: LD_ADDR_VAR 0 2
49909: PUSH
49910: LD_INT 0
49912: ST_TO_ADDR
// if GetTaskList ( sci ) then
49913: LD_VAR 0 1
49917: PPUSH
49918: CALL_OW 437
49922: IFFALSE 49970
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49924: LD_VAR 0 1
49928: PPUSH
49929: CALL_OW 437
49933: PUSH
49934: LD_INT 1
49936: ARRAY
49937: PUSH
49938: LD_INT 1
49940: ARRAY
49941: PUSH
49942: LD_STRING l
49944: EQUAL
49945: IFFALSE 49970
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49947: LD_ADDR_VAR 0 2
49951: PUSH
49952: LD_VAR 0 1
49956: PPUSH
49957: CALL_OW 437
49961: PUSH
49962: LD_INT 1
49964: ARRAY
49965: PUSH
49966: LD_INT 4
49968: ARRAY
49969: ST_TO_ADDR
// end ;
49970: LD_VAR 0 2
49974: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
49975: LD_INT 0
49977: PPUSH
49978: PPUSH
49979: PPUSH
49980: PPUSH
49981: PPUSH
49982: PPUSH
49983: PPUSH
49984: PPUSH
49985: PPUSH
49986: PPUSH
49987: PPUSH
49988: PPUSH
49989: PPUSH
49990: PPUSH
49991: PPUSH
49992: PPUSH
49993: PPUSH
49994: PPUSH
49995: PPUSH
49996: PPUSH
49997: PPUSH
49998: PPUSH
49999: PPUSH
50000: PPUSH
50001: PPUSH
50002: PPUSH
50003: PPUSH
50004: PPUSH
50005: PPUSH
50006: PPUSH
50007: PPUSH
50008: PPUSH
50009: PPUSH
50010: PPUSH
// if not list then
50011: LD_VAR 0 1
50015: NOT
50016: IFFALSE 50020
// exit ;
50018: GO 54672
// base := list [ 1 ] ;
50020: LD_ADDR_VAR 0 3
50024: PUSH
50025: LD_VAR 0 1
50029: PUSH
50030: LD_INT 1
50032: ARRAY
50033: ST_TO_ADDR
// group := list [ 2 ] ;
50034: LD_ADDR_VAR 0 4
50038: PUSH
50039: LD_VAR 0 1
50043: PUSH
50044: LD_INT 2
50046: ARRAY
50047: ST_TO_ADDR
// path := list [ 3 ] ;
50048: LD_ADDR_VAR 0 5
50052: PUSH
50053: LD_VAR 0 1
50057: PUSH
50058: LD_INT 3
50060: ARRAY
50061: ST_TO_ADDR
// flags := list [ 4 ] ;
50062: LD_ADDR_VAR 0 6
50066: PUSH
50067: LD_VAR 0 1
50071: PUSH
50072: LD_INT 4
50074: ARRAY
50075: ST_TO_ADDR
// mined := [ ] ;
50076: LD_ADDR_VAR 0 27
50080: PUSH
50081: EMPTY
50082: ST_TO_ADDR
// bombed := [ ] ;
50083: LD_ADDR_VAR 0 28
50087: PUSH
50088: EMPTY
50089: ST_TO_ADDR
// healers := [ ] ;
50090: LD_ADDR_VAR 0 31
50094: PUSH
50095: EMPTY
50096: ST_TO_ADDR
// to_heal := [ ] ;
50097: LD_ADDR_VAR 0 30
50101: PUSH
50102: EMPTY
50103: ST_TO_ADDR
// repairs := [ ] ;
50104: LD_ADDR_VAR 0 33
50108: PUSH
50109: EMPTY
50110: ST_TO_ADDR
// to_repair := [ ] ;
50111: LD_ADDR_VAR 0 32
50115: PUSH
50116: EMPTY
50117: ST_TO_ADDR
// if not group or not path then
50118: LD_VAR 0 4
50122: NOT
50123: PUSH
50124: LD_VAR 0 5
50128: NOT
50129: OR
50130: IFFALSE 50134
// exit ;
50132: GO 54672
// side := GetSide ( group [ 1 ] ) ;
50134: LD_ADDR_VAR 0 35
50138: PUSH
50139: LD_VAR 0 4
50143: PUSH
50144: LD_INT 1
50146: ARRAY
50147: PPUSH
50148: CALL_OW 255
50152: ST_TO_ADDR
// if flags then
50153: LD_VAR 0 6
50157: IFFALSE 50301
// begin f_ignore_area := flags [ 1 ] ;
50159: LD_ADDR_VAR 0 17
50163: PUSH
50164: LD_VAR 0 6
50168: PUSH
50169: LD_INT 1
50171: ARRAY
50172: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
50173: LD_ADDR_VAR 0 18
50177: PUSH
50178: LD_VAR 0 6
50182: PUSH
50183: LD_INT 2
50185: ARRAY
50186: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
50187: LD_ADDR_VAR 0 19
50191: PUSH
50192: LD_VAR 0 6
50196: PUSH
50197: LD_INT 3
50199: ARRAY
50200: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
50201: LD_ADDR_VAR 0 20
50205: PUSH
50206: LD_VAR 0 6
50210: PUSH
50211: LD_INT 4
50213: ARRAY
50214: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
50215: LD_ADDR_VAR 0 21
50219: PUSH
50220: LD_VAR 0 6
50224: PUSH
50225: LD_INT 5
50227: ARRAY
50228: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
50229: LD_ADDR_VAR 0 22
50233: PUSH
50234: LD_VAR 0 6
50238: PUSH
50239: LD_INT 6
50241: ARRAY
50242: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
50243: LD_ADDR_VAR 0 23
50247: PUSH
50248: LD_VAR 0 6
50252: PUSH
50253: LD_INT 7
50255: ARRAY
50256: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
50257: LD_ADDR_VAR 0 24
50261: PUSH
50262: LD_VAR 0 6
50266: PUSH
50267: LD_INT 8
50269: ARRAY
50270: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
50271: LD_ADDR_VAR 0 25
50275: PUSH
50276: LD_VAR 0 6
50280: PUSH
50281: LD_INT 9
50283: ARRAY
50284: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
50285: LD_ADDR_VAR 0 26
50289: PUSH
50290: LD_VAR 0 6
50294: PUSH
50295: LD_INT 10
50297: ARRAY
50298: ST_TO_ADDR
// end else
50299: GO 50381
// begin f_ignore_area := false ;
50301: LD_ADDR_VAR 0 17
50305: PUSH
50306: LD_INT 0
50308: ST_TO_ADDR
// f_capture := false ;
50309: LD_ADDR_VAR 0 18
50313: PUSH
50314: LD_INT 0
50316: ST_TO_ADDR
// f_ignore_civ := false ;
50317: LD_ADDR_VAR 0 19
50321: PUSH
50322: LD_INT 0
50324: ST_TO_ADDR
// f_murder := false ;
50325: LD_ADDR_VAR 0 20
50329: PUSH
50330: LD_INT 0
50332: ST_TO_ADDR
// f_mines := false ;
50333: LD_ADDR_VAR 0 21
50337: PUSH
50338: LD_INT 0
50340: ST_TO_ADDR
// f_repair := false ;
50341: LD_ADDR_VAR 0 22
50345: PUSH
50346: LD_INT 0
50348: ST_TO_ADDR
// f_heal := false ;
50349: LD_ADDR_VAR 0 23
50353: PUSH
50354: LD_INT 0
50356: ST_TO_ADDR
// f_spacetime := false ;
50357: LD_ADDR_VAR 0 24
50361: PUSH
50362: LD_INT 0
50364: ST_TO_ADDR
// f_attack_depot := false ;
50365: LD_ADDR_VAR 0 25
50369: PUSH
50370: LD_INT 0
50372: ST_TO_ADDR
// f_crawl := false ;
50373: LD_ADDR_VAR 0 26
50377: PUSH
50378: LD_INT 0
50380: ST_TO_ADDR
// end ; if f_heal then
50381: LD_VAR 0 23
50385: IFFALSE 50412
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
50387: LD_ADDR_VAR 0 31
50391: PUSH
50392: LD_VAR 0 4
50396: PPUSH
50397: LD_INT 25
50399: PUSH
50400: LD_INT 4
50402: PUSH
50403: EMPTY
50404: LIST
50405: LIST
50406: PPUSH
50407: CALL_OW 72
50411: ST_TO_ADDR
// if f_repair then
50412: LD_VAR 0 22
50416: IFFALSE 50443
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
50418: LD_ADDR_VAR 0 33
50422: PUSH
50423: LD_VAR 0 4
50427: PPUSH
50428: LD_INT 25
50430: PUSH
50431: LD_INT 3
50433: PUSH
50434: EMPTY
50435: LIST
50436: LIST
50437: PPUSH
50438: CALL_OW 72
50442: ST_TO_ADDR
// units_path := [ ] ;
50443: LD_ADDR_VAR 0 16
50447: PUSH
50448: EMPTY
50449: ST_TO_ADDR
// for i = 1 to group do
50450: LD_ADDR_VAR 0 7
50454: PUSH
50455: DOUBLE
50456: LD_INT 1
50458: DEC
50459: ST_TO_ADDR
50460: LD_VAR 0 4
50464: PUSH
50465: FOR_TO
50466: IFFALSE 50495
// units_path := Replace ( units_path , i , path ) ;
50468: LD_ADDR_VAR 0 16
50472: PUSH
50473: LD_VAR 0 16
50477: PPUSH
50478: LD_VAR 0 7
50482: PPUSH
50483: LD_VAR 0 5
50487: PPUSH
50488: CALL_OW 1
50492: ST_TO_ADDR
50493: GO 50465
50495: POP
50496: POP
// repeat for i = group downto 1 do
50497: LD_ADDR_VAR 0 7
50501: PUSH
50502: DOUBLE
50503: LD_VAR 0 4
50507: INC
50508: ST_TO_ADDR
50509: LD_INT 1
50511: PUSH
50512: FOR_DOWNTO
50513: IFFALSE 54635
// begin wait ( 5 ) ;
50515: LD_INT 5
50517: PPUSH
50518: CALL_OW 67
// tmp := [ ] ;
50522: LD_ADDR_VAR 0 14
50526: PUSH
50527: EMPTY
50528: ST_TO_ADDR
// attacking := false ;
50529: LD_ADDR_VAR 0 29
50533: PUSH
50534: LD_INT 0
50536: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
50537: LD_VAR 0 4
50541: PUSH
50542: LD_VAR 0 7
50546: ARRAY
50547: PPUSH
50548: CALL_OW 301
50552: PUSH
50553: LD_VAR 0 4
50557: PUSH
50558: LD_VAR 0 7
50562: ARRAY
50563: NOT
50564: OR
50565: IFFALSE 50674
// begin if GetType ( group [ i ] ) = unit_human then
50567: LD_VAR 0 4
50571: PUSH
50572: LD_VAR 0 7
50576: ARRAY
50577: PPUSH
50578: CALL_OW 247
50582: PUSH
50583: LD_INT 1
50585: EQUAL
50586: IFFALSE 50632
// begin to_heal := to_heal diff group [ i ] ;
50588: LD_ADDR_VAR 0 30
50592: PUSH
50593: LD_VAR 0 30
50597: PUSH
50598: LD_VAR 0 4
50602: PUSH
50603: LD_VAR 0 7
50607: ARRAY
50608: DIFF
50609: ST_TO_ADDR
// healers := healers diff group [ i ] ;
50610: LD_ADDR_VAR 0 31
50614: PUSH
50615: LD_VAR 0 31
50619: PUSH
50620: LD_VAR 0 4
50624: PUSH
50625: LD_VAR 0 7
50629: ARRAY
50630: DIFF
50631: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
50632: LD_ADDR_VAR 0 4
50636: PUSH
50637: LD_VAR 0 4
50641: PPUSH
50642: LD_VAR 0 7
50646: PPUSH
50647: CALL_OW 3
50651: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
50652: LD_ADDR_VAR 0 16
50656: PUSH
50657: LD_VAR 0 16
50661: PPUSH
50662: LD_VAR 0 7
50666: PPUSH
50667: CALL_OW 3
50671: ST_TO_ADDR
// continue ;
50672: GO 50512
// end ; if f_repair then
50674: LD_VAR 0 22
50678: IFFALSE 51167
// begin if GetType ( group [ i ] ) = unit_vehicle then
50680: LD_VAR 0 4
50684: PUSH
50685: LD_VAR 0 7
50689: ARRAY
50690: PPUSH
50691: CALL_OW 247
50695: PUSH
50696: LD_INT 2
50698: EQUAL
50699: IFFALSE 50889
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
50701: LD_VAR 0 4
50705: PUSH
50706: LD_VAR 0 7
50710: ARRAY
50711: PPUSH
50712: CALL_OW 256
50716: PUSH
50717: LD_INT 700
50719: LESS
50720: PUSH
50721: LD_VAR 0 4
50725: PUSH
50726: LD_VAR 0 7
50730: ARRAY
50731: PUSH
50732: LD_VAR 0 32
50736: IN
50737: NOT
50738: AND
50739: IFFALSE 50763
// to_repair := to_repair union group [ i ] ;
50741: LD_ADDR_VAR 0 32
50745: PUSH
50746: LD_VAR 0 32
50750: PUSH
50751: LD_VAR 0 4
50755: PUSH
50756: LD_VAR 0 7
50760: ARRAY
50761: UNION
50762: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
50763: LD_VAR 0 4
50767: PUSH
50768: LD_VAR 0 7
50772: ARRAY
50773: PPUSH
50774: CALL_OW 256
50778: PUSH
50779: LD_INT 1000
50781: EQUAL
50782: PUSH
50783: LD_VAR 0 4
50787: PUSH
50788: LD_VAR 0 7
50792: ARRAY
50793: PUSH
50794: LD_VAR 0 32
50798: IN
50799: AND
50800: IFFALSE 50824
// to_repair := to_repair diff group [ i ] ;
50802: LD_ADDR_VAR 0 32
50806: PUSH
50807: LD_VAR 0 32
50811: PUSH
50812: LD_VAR 0 4
50816: PUSH
50817: LD_VAR 0 7
50821: ARRAY
50822: DIFF
50823: ST_TO_ADDR
// if group [ i ] in to_repair then
50824: LD_VAR 0 4
50828: PUSH
50829: LD_VAR 0 7
50833: ARRAY
50834: PUSH
50835: LD_VAR 0 32
50839: IN
50840: IFFALSE 50887
// begin if not IsInArea ( group [ i ] , f_repair ) then
50842: LD_VAR 0 4
50846: PUSH
50847: LD_VAR 0 7
50851: ARRAY
50852: PPUSH
50853: LD_VAR 0 22
50857: PPUSH
50858: CALL_OW 308
50862: NOT
50863: IFFALSE 50885
// ComMoveToArea ( group [ i ] , f_repair ) ;
50865: LD_VAR 0 4
50869: PUSH
50870: LD_VAR 0 7
50874: ARRAY
50875: PPUSH
50876: LD_VAR 0 22
50880: PPUSH
50881: CALL_OW 113
// continue ;
50885: GO 50512
// end ; end else
50887: GO 51167
// if group [ i ] in repairs then
50889: LD_VAR 0 4
50893: PUSH
50894: LD_VAR 0 7
50898: ARRAY
50899: PUSH
50900: LD_VAR 0 33
50904: IN
50905: IFFALSE 51167
// begin if IsInUnit ( group [ i ] ) then
50907: LD_VAR 0 4
50911: PUSH
50912: LD_VAR 0 7
50916: ARRAY
50917: PPUSH
50918: CALL_OW 310
50922: IFFALSE 50990
// begin z := IsInUnit ( group [ i ] ) ;
50924: LD_ADDR_VAR 0 13
50928: PUSH
50929: LD_VAR 0 4
50933: PUSH
50934: LD_VAR 0 7
50938: ARRAY
50939: PPUSH
50940: CALL_OW 310
50944: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50945: LD_VAR 0 13
50949: PUSH
50950: LD_VAR 0 32
50954: IN
50955: PUSH
50956: LD_VAR 0 13
50960: PPUSH
50961: LD_VAR 0 22
50965: PPUSH
50966: CALL_OW 308
50970: AND
50971: IFFALSE 50988
// ComExitVehicle ( group [ i ] ) ;
50973: LD_VAR 0 4
50977: PUSH
50978: LD_VAR 0 7
50982: ARRAY
50983: PPUSH
50984: CALL_OW 121
// end else
50988: GO 51167
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50990: LD_ADDR_VAR 0 13
50994: PUSH
50995: LD_VAR 0 4
50999: PPUSH
51000: LD_INT 95
51002: PUSH
51003: LD_VAR 0 22
51007: PUSH
51008: EMPTY
51009: LIST
51010: LIST
51011: PUSH
51012: LD_INT 58
51014: PUSH
51015: EMPTY
51016: LIST
51017: PUSH
51018: EMPTY
51019: LIST
51020: LIST
51021: PPUSH
51022: CALL_OW 72
51026: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
51027: LD_VAR 0 4
51031: PUSH
51032: LD_VAR 0 7
51036: ARRAY
51037: PPUSH
51038: CALL_OW 314
51042: NOT
51043: IFFALSE 51165
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
51045: LD_ADDR_VAR 0 10
51049: PUSH
51050: LD_VAR 0 13
51054: PPUSH
51055: LD_VAR 0 4
51059: PUSH
51060: LD_VAR 0 7
51064: ARRAY
51065: PPUSH
51066: CALL_OW 74
51070: ST_TO_ADDR
// if not x then
51071: LD_VAR 0 10
51075: NOT
51076: IFFALSE 51080
// continue ;
51078: GO 50512
// if GetLives ( x ) < 1000 then
51080: LD_VAR 0 10
51084: PPUSH
51085: CALL_OW 256
51089: PUSH
51090: LD_INT 1000
51092: LESS
51093: IFFALSE 51117
// ComRepairVehicle ( group [ i ] , x ) else
51095: LD_VAR 0 4
51099: PUSH
51100: LD_VAR 0 7
51104: ARRAY
51105: PPUSH
51106: LD_VAR 0 10
51110: PPUSH
51111: CALL_OW 129
51115: GO 51165
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
51117: LD_VAR 0 23
51121: PUSH
51122: LD_VAR 0 4
51126: PUSH
51127: LD_VAR 0 7
51131: ARRAY
51132: PPUSH
51133: CALL_OW 256
51137: PUSH
51138: LD_INT 1000
51140: LESS
51141: AND
51142: NOT
51143: IFFALSE 51165
// ComEnterUnit ( group [ i ] , x ) ;
51145: LD_VAR 0 4
51149: PUSH
51150: LD_VAR 0 7
51154: ARRAY
51155: PPUSH
51156: LD_VAR 0 10
51160: PPUSH
51161: CALL_OW 120
// end ; continue ;
51165: GO 50512
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
51167: LD_VAR 0 23
51171: PUSH
51172: LD_VAR 0 4
51176: PUSH
51177: LD_VAR 0 7
51181: ARRAY
51182: PPUSH
51183: CALL_OW 247
51187: PUSH
51188: LD_INT 1
51190: EQUAL
51191: AND
51192: IFFALSE 51670
// begin if group [ i ] in healers then
51194: LD_VAR 0 4
51198: PUSH
51199: LD_VAR 0 7
51203: ARRAY
51204: PUSH
51205: LD_VAR 0 31
51209: IN
51210: IFFALSE 51483
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
51212: LD_VAR 0 4
51216: PUSH
51217: LD_VAR 0 7
51221: ARRAY
51222: PPUSH
51223: LD_VAR 0 23
51227: PPUSH
51228: CALL_OW 308
51232: NOT
51233: PUSH
51234: LD_VAR 0 4
51238: PUSH
51239: LD_VAR 0 7
51243: ARRAY
51244: PPUSH
51245: CALL_OW 314
51249: NOT
51250: AND
51251: IFFALSE 51275
// ComMoveToArea ( group [ i ] , f_heal ) else
51253: LD_VAR 0 4
51257: PUSH
51258: LD_VAR 0 7
51262: ARRAY
51263: PPUSH
51264: LD_VAR 0 23
51268: PPUSH
51269: CALL_OW 113
51273: GO 51481
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
51275: LD_VAR 0 4
51279: PUSH
51280: LD_VAR 0 7
51284: ARRAY
51285: PPUSH
51286: CALL 49893 0 1
51290: PPUSH
51291: CALL_OW 256
51295: PUSH
51296: LD_INT 1000
51298: EQUAL
51299: IFFALSE 51318
// ComStop ( group [ i ] ) else
51301: LD_VAR 0 4
51305: PUSH
51306: LD_VAR 0 7
51310: ARRAY
51311: PPUSH
51312: CALL_OW 141
51316: GO 51481
// if not HasTask ( group [ i ] ) and to_heal then
51318: LD_VAR 0 4
51322: PUSH
51323: LD_VAR 0 7
51327: ARRAY
51328: PPUSH
51329: CALL_OW 314
51333: NOT
51334: PUSH
51335: LD_VAR 0 30
51339: AND
51340: IFFALSE 51481
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
51342: LD_ADDR_VAR 0 13
51346: PUSH
51347: LD_VAR 0 30
51351: PPUSH
51352: LD_INT 3
51354: PUSH
51355: LD_INT 54
51357: PUSH
51358: EMPTY
51359: LIST
51360: PUSH
51361: EMPTY
51362: LIST
51363: LIST
51364: PPUSH
51365: CALL_OW 72
51369: PPUSH
51370: LD_VAR 0 4
51374: PUSH
51375: LD_VAR 0 7
51379: ARRAY
51380: PPUSH
51381: CALL_OW 74
51385: ST_TO_ADDR
// if z then
51386: LD_VAR 0 13
51390: IFFALSE 51481
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
51392: LD_INT 91
51394: PUSH
51395: LD_VAR 0 13
51399: PUSH
51400: LD_INT 10
51402: PUSH
51403: EMPTY
51404: LIST
51405: LIST
51406: LIST
51407: PUSH
51408: LD_INT 81
51410: PUSH
51411: LD_VAR 0 13
51415: PPUSH
51416: CALL_OW 255
51420: PUSH
51421: EMPTY
51422: LIST
51423: LIST
51424: PUSH
51425: EMPTY
51426: LIST
51427: LIST
51428: PPUSH
51429: CALL_OW 69
51433: PUSH
51434: LD_INT 0
51436: EQUAL
51437: IFFALSE 51461
// ComHeal ( group [ i ] , z ) else
51439: LD_VAR 0 4
51443: PUSH
51444: LD_VAR 0 7
51448: ARRAY
51449: PPUSH
51450: LD_VAR 0 13
51454: PPUSH
51455: CALL_OW 128
51459: GO 51481
// ComMoveToArea ( group [ i ] , f_heal ) ;
51461: LD_VAR 0 4
51465: PUSH
51466: LD_VAR 0 7
51470: ARRAY
51471: PPUSH
51472: LD_VAR 0 23
51476: PPUSH
51477: CALL_OW 113
// end ; continue ;
51481: GO 50512
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
51483: LD_VAR 0 4
51487: PUSH
51488: LD_VAR 0 7
51492: ARRAY
51493: PPUSH
51494: CALL_OW 256
51498: PUSH
51499: LD_INT 700
51501: LESS
51502: PUSH
51503: LD_VAR 0 4
51507: PUSH
51508: LD_VAR 0 7
51512: ARRAY
51513: PUSH
51514: LD_VAR 0 30
51518: IN
51519: NOT
51520: AND
51521: IFFALSE 51545
// to_heal := to_heal union group [ i ] ;
51523: LD_ADDR_VAR 0 30
51527: PUSH
51528: LD_VAR 0 30
51532: PUSH
51533: LD_VAR 0 4
51537: PUSH
51538: LD_VAR 0 7
51542: ARRAY
51543: UNION
51544: ST_TO_ADDR
// if group [ i ] in to_heal then
51545: LD_VAR 0 4
51549: PUSH
51550: LD_VAR 0 7
51554: ARRAY
51555: PUSH
51556: LD_VAR 0 30
51560: IN
51561: IFFALSE 51670
// begin if GetLives ( group [ i ] ) = 1000 then
51563: LD_VAR 0 4
51567: PUSH
51568: LD_VAR 0 7
51572: ARRAY
51573: PPUSH
51574: CALL_OW 256
51578: PUSH
51579: LD_INT 1000
51581: EQUAL
51582: IFFALSE 51608
// to_heal := to_heal diff group [ i ] else
51584: LD_ADDR_VAR 0 30
51588: PUSH
51589: LD_VAR 0 30
51593: PUSH
51594: LD_VAR 0 4
51598: PUSH
51599: LD_VAR 0 7
51603: ARRAY
51604: DIFF
51605: ST_TO_ADDR
51606: GO 51670
// begin if not IsInArea ( group [ i ] , to_heal ) then
51608: LD_VAR 0 4
51612: PUSH
51613: LD_VAR 0 7
51617: ARRAY
51618: PPUSH
51619: LD_VAR 0 30
51623: PPUSH
51624: CALL_OW 308
51628: NOT
51629: IFFALSE 51653
// ComMoveToArea ( group [ i ] , f_heal ) else
51631: LD_VAR 0 4
51635: PUSH
51636: LD_VAR 0 7
51640: ARRAY
51641: PPUSH
51642: LD_VAR 0 23
51646: PPUSH
51647: CALL_OW 113
51651: GO 51668
// ComHold ( group [ i ] ) ;
51653: LD_VAR 0 4
51657: PUSH
51658: LD_VAR 0 7
51662: ARRAY
51663: PPUSH
51664: CALL_OW 140
// continue ;
51668: GO 50512
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
51670: LD_VAR 0 4
51674: PUSH
51675: LD_VAR 0 7
51679: ARRAY
51680: PPUSH
51681: LD_INT 10
51683: PPUSH
51684: CALL 48313 0 2
51688: NOT
51689: PUSH
51690: LD_VAR 0 16
51694: PUSH
51695: LD_VAR 0 7
51699: ARRAY
51700: PUSH
51701: EMPTY
51702: EQUAL
51703: NOT
51704: AND
51705: IFFALSE 51971
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
51707: LD_VAR 0 4
51711: PUSH
51712: LD_VAR 0 7
51716: ARRAY
51717: PPUSH
51718: CALL_OW 262
51722: PUSH
51723: LD_INT 1
51725: PUSH
51726: LD_INT 2
51728: PUSH
51729: EMPTY
51730: LIST
51731: LIST
51732: IN
51733: IFFALSE 51774
// if GetFuel ( group [ i ] ) < 10 then
51735: LD_VAR 0 4
51739: PUSH
51740: LD_VAR 0 7
51744: ARRAY
51745: PPUSH
51746: CALL_OW 261
51750: PUSH
51751: LD_INT 10
51753: LESS
51754: IFFALSE 51774
// SetFuel ( group [ i ] , 12 ) ;
51756: LD_VAR 0 4
51760: PUSH
51761: LD_VAR 0 7
51765: ARRAY
51766: PPUSH
51767: LD_INT 12
51769: PPUSH
51770: CALL_OW 240
// if units_path [ i ] then
51774: LD_VAR 0 16
51778: PUSH
51779: LD_VAR 0 7
51783: ARRAY
51784: IFFALSE 51969
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
51786: LD_VAR 0 4
51790: PUSH
51791: LD_VAR 0 7
51795: ARRAY
51796: PPUSH
51797: LD_VAR 0 16
51801: PUSH
51802: LD_VAR 0 7
51806: ARRAY
51807: PUSH
51808: LD_INT 1
51810: ARRAY
51811: PUSH
51812: LD_INT 1
51814: ARRAY
51815: PPUSH
51816: LD_VAR 0 16
51820: PUSH
51821: LD_VAR 0 7
51825: ARRAY
51826: PUSH
51827: LD_INT 1
51829: ARRAY
51830: PUSH
51831: LD_INT 2
51833: ARRAY
51834: PPUSH
51835: CALL_OW 297
51839: PUSH
51840: LD_INT 6
51842: GREATER
51843: IFFALSE 51918
// begin if not HasTask ( group [ i ] ) then
51845: LD_VAR 0 4
51849: PUSH
51850: LD_VAR 0 7
51854: ARRAY
51855: PPUSH
51856: CALL_OW 314
51860: NOT
51861: IFFALSE 51916
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51863: LD_VAR 0 4
51867: PUSH
51868: LD_VAR 0 7
51872: ARRAY
51873: PPUSH
51874: LD_VAR 0 16
51878: PUSH
51879: LD_VAR 0 7
51883: ARRAY
51884: PUSH
51885: LD_INT 1
51887: ARRAY
51888: PUSH
51889: LD_INT 1
51891: ARRAY
51892: PPUSH
51893: LD_VAR 0 16
51897: PUSH
51898: LD_VAR 0 7
51902: ARRAY
51903: PUSH
51904: LD_INT 1
51906: ARRAY
51907: PUSH
51908: LD_INT 2
51910: ARRAY
51911: PPUSH
51912: CALL_OW 114
// end else
51916: GO 51969
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51918: LD_ADDR_VAR 0 15
51922: PUSH
51923: LD_VAR 0 16
51927: PUSH
51928: LD_VAR 0 7
51932: ARRAY
51933: PPUSH
51934: LD_INT 1
51936: PPUSH
51937: CALL_OW 3
51941: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51942: LD_ADDR_VAR 0 16
51946: PUSH
51947: LD_VAR 0 16
51951: PPUSH
51952: LD_VAR 0 7
51956: PPUSH
51957: LD_VAR 0 15
51961: PPUSH
51962: CALL_OW 1
51966: ST_TO_ADDR
// continue ;
51967: GO 50512
// end ; end ; end else
51969: GO 54633
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51971: LD_ADDR_VAR 0 14
51975: PUSH
51976: LD_INT 81
51978: PUSH
51979: LD_VAR 0 4
51983: PUSH
51984: LD_VAR 0 7
51988: ARRAY
51989: PPUSH
51990: CALL_OW 255
51994: PUSH
51995: EMPTY
51996: LIST
51997: LIST
51998: PPUSH
51999: CALL_OW 69
52003: ST_TO_ADDR
// if not tmp then
52004: LD_VAR 0 14
52008: NOT
52009: IFFALSE 52013
// continue ;
52011: GO 50512
// if f_ignore_area then
52013: LD_VAR 0 17
52017: IFFALSE 52105
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
52019: LD_ADDR_VAR 0 15
52023: PUSH
52024: LD_VAR 0 14
52028: PPUSH
52029: LD_INT 3
52031: PUSH
52032: LD_INT 92
52034: PUSH
52035: LD_VAR 0 17
52039: PUSH
52040: LD_INT 1
52042: ARRAY
52043: PUSH
52044: LD_VAR 0 17
52048: PUSH
52049: LD_INT 2
52051: ARRAY
52052: PUSH
52053: LD_VAR 0 17
52057: PUSH
52058: LD_INT 3
52060: ARRAY
52061: PUSH
52062: EMPTY
52063: LIST
52064: LIST
52065: LIST
52066: LIST
52067: PUSH
52068: EMPTY
52069: LIST
52070: LIST
52071: PPUSH
52072: CALL_OW 72
52076: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
52077: LD_VAR 0 14
52081: PUSH
52082: LD_VAR 0 15
52086: DIFF
52087: IFFALSE 52105
// tmp := tmp diff tmp2 ;
52089: LD_ADDR_VAR 0 14
52093: PUSH
52094: LD_VAR 0 14
52098: PUSH
52099: LD_VAR 0 15
52103: DIFF
52104: ST_TO_ADDR
// end ; if not f_murder then
52105: LD_VAR 0 20
52109: NOT
52110: IFFALSE 52168
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
52112: LD_ADDR_VAR 0 15
52116: PUSH
52117: LD_VAR 0 14
52121: PPUSH
52122: LD_INT 3
52124: PUSH
52125: LD_INT 50
52127: PUSH
52128: EMPTY
52129: LIST
52130: PUSH
52131: EMPTY
52132: LIST
52133: LIST
52134: PPUSH
52135: CALL_OW 72
52139: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
52140: LD_VAR 0 14
52144: PUSH
52145: LD_VAR 0 15
52149: DIFF
52150: IFFALSE 52168
// tmp := tmp diff tmp2 ;
52152: LD_ADDR_VAR 0 14
52156: PUSH
52157: LD_VAR 0 14
52161: PUSH
52162: LD_VAR 0 15
52166: DIFF
52167: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
52168: LD_ADDR_VAR 0 14
52172: PUSH
52173: LD_VAR 0 4
52177: PUSH
52178: LD_VAR 0 7
52182: ARRAY
52183: PPUSH
52184: LD_VAR 0 14
52188: PPUSH
52189: LD_INT 1
52191: PPUSH
52192: LD_INT 1
52194: PPUSH
52195: CALL 21956 0 4
52199: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
52200: LD_VAR 0 4
52204: PUSH
52205: LD_VAR 0 7
52209: ARRAY
52210: PPUSH
52211: CALL_OW 257
52215: PUSH
52216: LD_INT 1
52218: EQUAL
52219: IFFALSE 52667
// begin if WantPlant ( group [ i ] ) then
52221: LD_VAR 0 4
52225: PUSH
52226: LD_VAR 0 7
52230: ARRAY
52231: PPUSH
52232: CALL 21457 0 1
52236: IFFALSE 52240
// continue ;
52238: GO 50512
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
52240: LD_VAR 0 18
52244: PUSH
52245: LD_VAR 0 4
52249: PUSH
52250: LD_VAR 0 7
52254: ARRAY
52255: PPUSH
52256: CALL_OW 310
52260: NOT
52261: AND
52262: PUSH
52263: LD_VAR 0 14
52267: PUSH
52268: LD_INT 1
52270: ARRAY
52271: PUSH
52272: LD_VAR 0 14
52276: PPUSH
52277: LD_INT 21
52279: PUSH
52280: LD_INT 2
52282: PUSH
52283: EMPTY
52284: LIST
52285: LIST
52286: PUSH
52287: LD_INT 58
52289: PUSH
52290: EMPTY
52291: LIST
52292: PUSH
52293: EMPTY
52294: LIST
52295: LIST
52296: PPUSH
52297: CALL_OW 72
52301: IN
52302: AND
52303: IFFALSE 52339
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
52305: LD_VAR 0 4
52309: PUSH
52310: LD_VAR 0 7
52314: ARRAY
52315: PPUSH
52316: LD_VAR 0 14
52320: PUSH
52321: LD_INT 1
52323: ARRAY
52324: PPUSH
52325: CALL_OW 120
// attacking := true ;
52329: LD_ADDR_VAR 0 29
52333: PUSH
52334: LD_INT 1
52336: ST_TO_ADDR
// continue ;
52337: GO 50512
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
52339: LD_VAR 0 26
52343: PUSH
52344: LD_VAR 0 4
52348: PUSH
52349: LD_VAR 0 7
52353: ARRAY
52354: PPUSH
52355: CALL_OW 257
52359: PUSH
52360: LD_INT 1
52362: EQUAL
52363: AND
52364: PUSH
52365: LD_VAR 0 4
52369: PUSH
52370: LD_VAR 0 7
52374: ARRAY
52375: PPUSH
52376: CALL_OW 256
52380: PUSH
52381: LD_INT 800
52383: LESS
52384: AND
52385: PUSH
52386: LD_VAR 0 4
52390: PUSH
52391: LD_VAR 0 7
52395: ARRAY
52396: PPUSH
52397: CALL_OW 318
52401: NOT
52402: AND
52403: IFFALSE 52420
// ComCrawl ( group [ i ] ) ;
52405: LD_VAR 0 4
52409: PUSH
52410: LD_VAR 0 7
52414: ARRAY
52415: PPUSH
52416: CALL_OW 137
// if f_mines then
52420: LD_VAR 0 21
52424: IFFALSE 52667
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
52426: LD_VAR 0 14
52430: PUSH
52431: LD_INT 1
52433: ARRAY
52434: PPUSH
52435: CALL_OW 247
52439: PUSH
52440: LD_INT 3
52442: EQUAL
52443: PUSH
52444: LD_VAR 0 14
52448: PUSH
52449: LD_INT 1
52451: ARRAY
52452: PUSH
52453: LD_VAR 0 27
52457: IN
52458: NOT
52459: AND
52460: IFFALSE 52667
// begin x := GetX ( tmp [ 1 ] ) ;
52462: LD_ADDR_VAR 0 10
52466: PUSH
52467: LD_VAR 0 14
52471: PUSH
52472: LD_INT 1
52474: ARRAY
52475: PPUSH
52476: CALL_OW 250
52480: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
52481: LD_ADDR_VAR 0 11
52485: PUSH
52486: LD_VAR 0 14
52490: PUSH
52491: LD_INT 1
52493: ARRAY
52494: PPUSH
52495: CALL_OW 251
52499: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
52500: LD_ADDR_VAR 0 12
52504: PUSH
52505: LD_VAR 0 4
52509: PUSH
52510: LD_VAR 0 7
52514: ARRAY
52515: PPUSH
52516: CALL 48398 0 1
52520: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
52521: LD_VAR 0 4
52525: PUSH
52526: LD_VAR 0 7
52530: ARRAY
52531: PPUSH
52532: LD_VAR 0 10
52536: PPUSH
52537: LD_VAR 0 11
52541: PPUSH
52542: LD_VAR 0 14
52546: PUSH
52547: LD_INT 1
52549: ARRAY
52550: PPUSH
52551: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
52555: LD_VAR 0 4
52559: PUSH
52560: LD_VAR 0 7
52564: ARRAY
52565: PPUSH
52566: LD_VAR 0 10
52570: PPUSH
52571: LD_VAR 0 12
52575: PPUSH
52576: LD_INT 7
52578: PPUSH
52579: CALL_OW 272
52583: PPUSH
52584: LD_VAR 0 11
52588: PPUSH
52589: LD_VAR 0 12
52593: PPUSH
52594: LD_INT 7
52596: PPUSH
52597: CALL_OW 273
52601: PPUSH
52602: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
52606: LD_VAR 0 4
52610: PUSH
52611: LD_VAR 0 7
52615: ARRAY
52616: PPUSH
52617: LD_INT 71
52619: PPUSH
52620: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
52624: LD_ADDR_VAR 0 27
52628: PUSH
52629: LD_VAR 0 27
52633: PPUSH
52634: LD_VAR 0 27
52638: PUSH
52639: LD_INT 1
52641: PLUS
52642: PPUSH
52643: LD_VAR 0 14
52647: PUSH
52648: LD_INT 1
52650: ARRAY
52651: PPUSH
52652: CALL_OW 1
52656: ST_TO_ADDR
// attacking := true ;
52657: LD_ADDR_VAR 0 29
52661: PUSH
52662: LD_INT 1
52664: ST_TO_ADDR
// continue ;
52665: GO 50512
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
52667: LD_VAR 0 4
52671: PUSH
52672: LD_VAR 0 7
52676: ARRAY
52677: PPUSH
52678: CALL_OW 257
52682: PUSH
52683: LD_INT 17
52685: EQUAL
52686: PUSH
52687: LD_VAR 0 4
52691: PUSH
52692: LD_VAR 0 7
52696: ARRAY
52697: PPUSH
52698: CALL_OW 110
52702: PUSH
52703: LD_INT 71
52705: EQUAL
52706: NOT
52707: AND
52708: IFFALSE 52854
// begin attacking := false ;
52710: LD_ADDR_VAR 0 29
52714: PUSH
52715: LD_INT 0
52717: ST_TO_ADDR
// k := 5 ;
52718: LD_ADDR_VAR 0 9
52722: PUSH
52723: LD_INT 5
52725: ST_TO_ADDR
// if tmp < k then
52726: LD_VAR 0 14
52730: PUSH
52731: LD_VAR 0 9
52735: LESS
52736: IFFALSE 52748
// k := tmp ;
52738: LD_ADDR_VAR 0 9
52742: PUSH
52743: LD_VAR 0 14
52747: ST_TO_ADDR
// for j = 1 to k do
52748: LD_ADDR_VAR 0 8
52752: PUSH
52753: DOUBLE
52754: LD_INT 1
52756: DEC
52757: ST_TO_ADDR
52758: LD_VAR 0 9
52762: PUSH
52763: FOR_TO
52764: IFFALSE 52852
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
52766: LD_VAR 0 14
52770: PUSH
52771: LD_VAR 0 8
52775: ARRAY
52776: PUSH
52777: LD_VAR 0 14
52781: PPUSH
52782: LD_INT 58
52784: PUSH
52785: EMPTY
52786: LIST
52787: PPUSH
52788: CALL_OW 72
52792: IN
52793: NOT
52794: IFFALSE 52850
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52796: LD_VAR 0 4
52800: PUSH
52801: LD_VAR 0 7
52805: ARRAY
52806: PPUSH
52807: LD_VAR 0 14
52811: PUSH
52812: LD_VAR 0 8
52816: ARRAY
52817: PPUSH
52818: CALL_OW 115
// attacking := true ;
52822: LD_ADDR_VAR 0 29
52826: PUSH
52827: LD_INT 1
52829: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
52830: LD_VAR 0 4
52834: PUSH
52835: LD_VAR 0 7
52839: ARRAY
52840: PPUSH
52841: LD_INT 71
52843: PPUSH
52844: CALL_OW 109
// continue ;
52848: GO 52763
// end ; end ;
52850: GO 52763
52852: POP
52853: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
52854: LD_VAR 0 4
52858: PUSH
52859: LD_VAR 0 7
52863: ARRAY
52864: PPUSH
52865: CALL_OW 257
52869: PUSH
52870: LD_INT 8
52872: EQUAL
52873: PUSH
52874: LD_VAR 0 4
52878: PUSH
52879: LD_VAR 0 7
52883: ARRAY
52884: PPUSH
52885: CALL_OW 264
52889: PUSH
52890: LD_INT 28
52892: PUSH
52893: LD_INT 45
52895: PUSH
52896: LD_INT 7
52898: PUSH
52899: LD_INT 47
52901: PUSH
52902: EMPTY
52903: LIST
52904: LIST
52905: LIST
52906: LIST
52907: IN
52908: OR
52909: IFFALSE 53165
// begin attacking := false ;
52911: LD_ADDR_VAR 0 29
52915: PUSH
52916: LD_INT 0
52918: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52919: LD_VAR 0 14
52923: PUSH
52924: LD_INT 1
52926: ARRAY
52927: PPUSH
52928: CALL_OW 266
52932: PUSH
52933: LD_INT 32
52935: PUSH
52936: LD_INT 31
52938: PUSH
52939: LD_INT 33
52941: PUSH
52942: LD_INT 4
52944: PUSH
52945: LD_INT 5
52947: PUSH
52948: EMPTY
52949: LIST
52950: LIST
52951: LIST
52952: LIST
52953: LIST
52954: IN
52955: IFFALSE 53141
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52957: LD_ADDR_VAR 0 9
52961: PUSH
52962: LD_VAR 0 14
52966: PUSH
52967: LD_INT 1
52969: ARRAY
52970: PPUSH
52971: CALL_OW 266
52975: PPUSH
52976: LD_VAR 0 14
52980: PUSH
52981: LD_INT 1
52983: ARRAY
52984: PPUSH
52985: CALL_OW 250
52989: PPUSH
52990: LD_VAR 0 14
52994: PUSH
52995: LD_INT 1
52997: ARRAY
52998: PPUSH
52999: CALL_OW 251
53003: PPUSH
53004: LD_VAR 0 14
53008: PUSH
53009: LD_INT 1
53011: ARRAY
53012: PPUSH
53013: CALL_OW 254
53017: PPUSH
53018: LD_VAR 0 14
53022: PUSH
53023: LD_INT 1
53025: ARRAY
53026: PPUSH
53027: CALL_OW 248
53031: PPUSH
53032: LD_INT 0
53034: PPUSH
53035: CALL 29768 0 6
53039: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
53040: LD_ADDR_VAR 0 8
53044: PUSH
53045: LD_VAR 0 4
53049: PUSH
53050: LD_VAR 0 7
53054: ARRAY
53055: PPUSH
53056: LD_VAR 0 9
53060: PPUSH
53061: CALL 48438 0 2
53065: ST_TO_ADDR
// if j then
53066: LD_VAR 0 8
53070: IFFALSE 53139
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
53072: LD_VAR 0 8
53076: PUSH
53077: LD_INT 1
53079: ARRAY
53080: PPUSH
53081: LD_VAR 0 8
53085: PUSH
53086: LD_INT 2
53088: ARRAY
53089: PPUSH
53090: CALL_OW 488
53094: IFFALSE 53139
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
53096: LD_VAR 0 4
53100: PUSH
53101: LD_VAR 0 7
53105: ARRAY
53106: PPUSH
53107: LD_VAR 0 8
53111: PUSH
53112: LD_INT 1
53114: ARRAY
53115: PPUSH
53116: LD_VAR 0 8
53120: PUSH
53121: LD_INT 2
53123: ARRAY
53124: PPUSH
53125: CALL_OW 116
// attacking := true ;
53129: LD_ADDR_VAR 0 29
53133: PUSH
53134: LD_INT 1
53136: ST_TO_ADDR
// continue ;
53137: GO 50512
// end ; end else
53139: GO 53165
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53141: LD_VAR 0 4
53145: PUSH
53146: LD_VAR 0 7
53150: ARRAY
53151: PPUSH
53152: LD_VAR 0 14
53156: PUSH
53157: LD_INT 1
53159: ARRAY
53160: PPUSH
53161: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
53165: LD_VAR 0 4
53169: PUSH
53170: LD_VAR 0 7
53174: ARRAY
53175: PPUSH
53176: CALL_OW 265
53180: PUSH
53181: LD_INT 11
53183: EQUAL
53184: IFFALSE 53462
// begin k := 10 ;
53186: LD_ADDR_VAR 0 9
53190: PUSH
53191: LD_INT 10
53193: ST_TO_ADDR
// x := 0 ;
53194: LD_ADDR_VAR 0 10
53198: PUSH
53199: LD_INT 0
53201: ST_TO_ADDR
// if tmp < k then
53202: LD_VAR 0 14
53206: PUSH
53207: LD_VAR 0 9
53211: LESS
53212: IFFALSE 53224
// k := tmp ;
53214: LD_ADDR_VAR 0 9
53218: PUSH
53219: LD_VAR 0 14
53223: ST_TO_ADDR
// for j = k downto 1 do
53224: LD_ADDR_VAR 0 8
53228: PUSH
53229: DOUBLE
53230: LD_VAR 0 9
53234: INC
53235: ST_TO_ADDR
53236: LD_INT 1
53238: PUSH
53239: FOR_DOWNTO
53240: IFFALSE 53315
// begin if GetType ( tmp [ j ] ) = unit_human then
53242: LD_VAR 0 14
53246: PUSH
53247: LD_VAR 0 8
53251: ARRAY
53252: PPUSH
53253: CALL_OW 247
53257: PUSH
53258: LD_INT 1
53260: EQUAL
53261: IFFALSE 53313
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
53263: LD_VAR 0 4
53267: PUSH
53268: LD_VAR 0 7
53272: ARRAY
53273: PPUSH
53274: LD_VAR 0 14
53278: PUSH
53279: LD_VAR 0 8
53283: ARRAY
53284: PPUSH
53285: CALL 48709 0 2
// x := tmp [ j ] ;
53289: LD_ADDR_VAR 0 10
53293: PUSH
53294: LD_VAR 0 14
53298: PUSH
53299: LD_VAR 0 8
53303: ARRAY
53304: ST_TO_ADDR
// attacking := true ;
53305: LD_ADDR_VAR 0 29
53309: PUSH
53310: LD_INT 1
53312: ST_TO_ADDR
// end ; end ;
53313: GO 53239
53315: POP
53316: POP
// if not x then
53317: LD_VAR 0 10
53321: NOT
53322: IFFALSE 53462
// begin attacking := true ;
53324: LD_ADDR_VAR 0 29
53328: PUSH
53329: LD_INT 1
53331: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
53332: LD_VAR 0 4
53336: PUSH
53337: LD_VAR 0 7
53341: ARRAY
53342: PPUSH
53343: CALL_OW 250
53347: PPUSH
53348: LD_VAR 0 4
53352: PUSH
53353: LD_VAR 0 7
53357: ARRAY
53358: PPUSH
53359: CALL_OW 251
53363: PPUSH
53364: CALL_OW 546
53368: PUSH
53369: LD_INT 2
53371: ARRAY
53372: PUSH
53373: LD_VAR 0 14
53377: PUSH
53378: LD_INT 1
53380: ARRAY
53381: PPUSH
53382: CALL_OW 250
53386: PPUSH
53387: LD_VAR 0 14
53391: PUSH
53392: LD_INT 1
53394: ARRAY
53395: PPUSH
53396: CALL_OW 251
53400: PPUSH
53401: CALL_OW 546
53405: PUSH
53406: LD_INT 2
53408: ARRAY
53409: EQUAL
53410: IFFALSE 53438
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
53412: LD_VAR 0 4
53416: PUSH
53417: LD_VAR 0 7
53421: ARRAY
53422: PPUSH
53423: LD_VAR 0 14
53427: PUSH
53428: LD_INT 1
53430: ARRAY
53431: PPUSH
53432: CALL 48709 0 2
53436: GO 53462
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53438: LD_VAR 0 4
53442: PUSH
53443: LD_VAR 0 7
53447: ARRAY
53448: PPUSH
53449: LD_VAR 0 14
53453: PUSH
53454: LD_INT 1
53456: ARRAY
53457: PPUSH
53458: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
53462: LD_VAR 0 4
53466: PUSH
53467: LD_VAR 0 7
53471: ARRAY
53472: PPUSH
53473: CALL_OW 264
53477: PUSH
53478: LD_INT 29
53480: EQUAL
53481: IFFALSE 53847
// begin if WantsToAttack ( group [ i ] ) in bombed then
53483: LD_VAR 0 4
53487: PUSH
53488: LD_VAR 0 7
53492: ARRAY
53493: PPUSH
53494: CALL_OW 319
53498: PUSH
53499: LD_VAR 0 28
53503: IN
53504: IFFALSE 53508
// continue ;
53506: GO 50512
// k := 8 ;
53508: LD_ADDR_VAR 0 9
53512: PUSH
53513: LD_INT 8
53515: ST_TO_ADDR
// x := 0 ;
53516: LD_ADDR_VAR 0 10
53520: PUSH
53521: LD_INT 0
53523: ST_TO_ADDR
// if tmp < k then
53524: LD_VAR 0 14
53528: PUSH
53529: LD_VAR 0 9
53533: LESS
53534: IFFALSE 53546
// k := tmp ;
53536: LD_ADDR_VAR 0 9
53540: PUSH
53541: LD_VAR 0 14
53545: ST_TO_ADDR
// for j = 1 to k do
53546: LD_ADDR_VAR 0 8
53550: PUSH
53551: DOUBLE
53552: LD_INT 1
53554: DEC
53555: ST_TO_ADDR
53556: LD_VAR 0 9
53560: PUSH
53561: FOR_TO
53562: IFFALSE 53694
// begin if GetType ( tmp [ j ] ) = unit_building then
53564: LD_VAR 0 14
53568: PUSH
53569: LD_VAR 0 8
53573: ARRAY
53574: PPUSH
53575: CALL_OW 247
53579: PUSH
53580: LD_INT 3
53582: EQUAL
53583: IFFALSE 53692
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
53585: LD_VAR 0 14
53589: PUSH
53590: LD_VAR 0 8
53594: ARRAY
53595: PUSH
53596: LD_VAR 0 28
53600: IN
53601: NOT
53602: PUSH
53603: LD_VAR 0 14
53607: PUSH
53608: LD_VAR 0 8
53612: ARRAY
53613: PPUSH
53614: CALL_OW 313
53618: AND
53619: IFFALSE 53692
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53621: LD_VAR 0 4
53625: PUSH
53626: LD_VAR 0 7
53630: ARRAY
53631: PPUSH
53632: LD_VAR 0 14
53636: PUSH
53637: LD_VAR 0 8
53641: ARRAY
53642: PPUSH
53643: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
53647: LD_ADDR_VAR 0 28
53651: PUSH
53652: LD_VAR 0 28
53656: PPUSH
53657: LD_VAR 0 28
53661: PUSH
53662: LD_INT 1
53664: PLUS
53665: PPUSH
53666: LD_VAR 0 14
53670: PUSH
53671: LD_VAR 0 8
53675: ARRAY
53676: PPUSH
53677: CALL_OW 1
53681: ST_TO_ADDR
// attacking := true ;
53682: LD_ADDR_VAR 0 29
53686: PUSH
53687: LD_INT 1
53689: ST_TO_ADDR
// break ;
53690: GO 53694
// end ; end ;
53692: GO 53561
53694: POP
53695: POP
// if not attacking and f_attack_depot then
53696: LD_VAR 0 29
53700: NOT
53701: PUSH
53702: LD_VAR 0 25
53706: AND
53707: IFFALSE 53802
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53709: LD_ADDR_VAR 0 13
53713: PUSH
53714: LD_VAR 0 14
53718: PPUSH
53719: LD_INT 2
53721: PUSH
53722: LD_INT 30
53724: PUSH
53725: LD_INT 0
53727: PUSH
53728: EMPTY
53729: LIST
53730: LIST
53731: PUSH
53732: LD_INT 30
53734: PUSH
53735: LD_INT 1
53737: PUSH
53738: EMPTY
53739: LIST
53740: LIST
53741: PUSH
53742: EMPTY
53743: LIST
53744: LIST
53745: LIST
53746: PPUSH
53747: CALL_OW 72
53751: ST_TO_ADDR
// if z then
53752: LD_VAR 0 13
53756: IFFALSE 53802
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
53758: LD_VAR 0 4
53762: PUSH
53763: LD_VAR 0 7
53767: ARRAY
53768: PPUSH
53769: LD_VAR 0 13
53773: PPUSH
53774: LD_VAR 0 4
53778: PUSH
53779: LD_VAR 0 7
53783: ARRAY
53784: PPUSH
53785: CALL_OW 74
53789: PPUSH
53790: CALL_OW 115
// attacking := true ;
53794: LD_ADDR_VAR 0 29
53798: PUSH
53799: LD_INT 1
53801: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
53802: LD_VAR 0 4
53806: PUSH
53807: LD_VAR 0 7
53811: ARRAY
53812: PPUSH
53813: CALL_OW 256
53817: PUSH
53818: LD_INT 500
53820: LESS
53821: IFFALSE 53847
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53823: LD_VAR 0 4
53827: PUSH
53828: LD_VAR 0 7
53832: ARRAY
53833: PPUSH
53834: LD_VAR 0 14
53838: PUSH
53839: LD_INT 1
53841: ARRAY
53842: PPUSH
53843: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
53847: LD_VAR 0 4
53851: PUSH
53852: LD_VAR 0 7
53856: ARRAY
53857: PPUSH
53858: CALL_OW 264
53862: PUSH
53863: LD_INT 49
53865: EQUAL
53866: IFFALSE 53987
// begin if not HasTask ( group [ i ] ) then
53868: LD_VAR 0 4
53872: PUSH
53873: LD_VAR 0 7
53877: ARRAY
53878: PPUSH
53879: CALL_OW 314
53883: NOT
53884: IFFALSE 53987
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53886: LD_ADDR_VAR 0 9
53890: PUSH
53891: LD_INT 81
53893: PUSH
53894: LD_VAR 0 4
53898: PUSH
53899: LD_VAR 0 7
53903: ARRAY
53904: PPUSH
53905: CALL_OW 255
53909: PUSH
53910: EMPTY
53911: LIST
53912: LIST
53913: PPUSH
53914: CALL_OW 69
53918: PPUSH
53919: LD_VAR 0 4
53923: PUSH
53924: LD_VAR 0 7
53928: ARRAY
53929: PPUSH
53930: CALL_OW 74
53934: ST_TO_ADDR
// if k then
53935: LD_VAR 0 9
53939: IFFALSE 53987
// if GetDistUnits ( group [ i ] , k ) > 10 then
53941: LD_VAR 0 4
53945: PUSH
53946: LD_VAR 0 7
53950: ARRAY
53951: PPUSH
53952: LD_VAR 0 9
53956: PPUSH
53957: CALL_OW 296
53961: PUSH
53962: LD_INT 10
53964: GREATER
53965: IFFALSE 53987
// ComMoveUnit ( group [ i ] , k ) ;
53967: LD_VAR 0 4
53971: PUSH
53972: LD_VAR 0 7
53976: ARRAY
53977: PPUSH
53978: LD_VAR 0 9
53982: PPUSH
53983: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53987: LD_VAR 0 4
53991: PUSH
53992: LD_VAR 0 7
53996: ARRAY
53997: PPUSH
53998: CALL_OW 256
54002: PUSH
54003: LD_INT 250
54005: LESS
54006: PUSH
54007: LD_VAR 0 4
54011: PUSH
54012: LD_VAR 0 7
54016: ARRAY
54017: PUSH
54018: LD_INT 21
54020: PUSH
54021: LD_INT 2
54023: PUSH
54024: EMPTY
54025: LIST
54026: LIST
54027: PUSH
54028: LD_INT 23
54030: PUSH
54031: LD_INT 2
54033: PUSH
54034: EMPTY
54035: LIST
54036: LIST
54037: PUSH
54038: EMPTY
54039: LIST
54040: LIST
54041: PPUSH
54042: CALL_OW 69
54046: IN
54047: AND
54048: IFFALSE 54173
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
54050: LD_ADDR_VAR 0 9
54054: PUSH
54055: LD_OWVAR 3
54059: PUSH
54060: LD_VAR 0 4
54064: PUSH
54065: LD_VAR 0 7
54069: ARRAY
54070: DIFF
54071: PPUSH
54072: LD_VAR 0 4
54076: PUSH
54077: LD_VAR 0 7
54081: ARRAY
54082: PPUSH
54083: CALL_OW 74
54087: ST_TO_ADDR
// if not k then
54088: LD_VAR 0 9
54092: NOT
54093: IFFALSE 54097
// continue ;
54095: GO 50512
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
54097: LD_VAR 0 9
54101: PUSH
54102: LD_INT 81
54104: PUSH
54105: LD_VAR 0 4
54109: PUSH
54110: LD_VAR 0 7
54114: ARRAY
54115: PPUSH
54116: CALL_OW 255
54120: PUSH
54121: EMPTY
54122: LIST
54123: LIST
54124: PPUSH
54125: CALL_OW 69
54129: IN
54130: PUSH
54131: LD_VAR 0 9
54135: PPUSH
54136: LD_VAR 0 4
54140: PUSH
54141: LD_VAR 0 7
54145: ARRAY
54146: PPUSH
54147: CALL_OW 296
54151: PUSH
54152: LD_INT 5
54154: LESS
54155: AND
54156: IFFALSE 54173
// ComAutodestruct ( group [ i ] ) ;
54158: LD_VAR 0 4
54162: PUSH
54163: LD_VAR 0 7
54167: ARRAY
54168: PPUSH
54169: CALL 48607 0 1
// end ; if f_attack_depot then
54173: LD_VAR 0 25
54177: IFFALSE 54289
// begin k := 6 ;
54179: LD_ADDR_VAR 0 9
54183: PUSH
54184: LD_INT 6
54186: ST_TO_ADDR
// if tmp < k then
54187: LD_VAR 0 14
54191: PUSH
54192: LD_VAR 0 9
54196: LESS
54197: IFFALSE 54209
// k := tmp ;
54199: LD_ADDR_VAR 0 9
54203: PUSH
54204: LD_VAR 0 14
54208: ST_TO_ADDR
// for j = 1 to k do
54209: LD_ADDR_VAR 0 8
54213: PUSH
54214: DOUBLE
54215: LD_INT 1
54217: DEC
54218: ST_TO_ADDR
54219: LD_VAR 0 9
54223: PUSH
54224: FOR_TO
54225: IFFALSE 54287
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
54227: LD_VAR 0 8
54231: PPUSH
54232: CALL_OW 266
54236: PUSH
54237: LD_INT 0
54239: PUSH
54240: LD_INT 1
54242: PUSH
54243: EMPTY
54244: LIST
54245: LIST
54246: IN
54247: IFFALSE 54285
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
54249: LD_VAR 0 4
54253: PUSH
54254: LD_VAR 0 7
54258: ARRAY
54259: PPUSH
54260: LD_VAR 0 14
54264: PUSH
54265: LD_VAR 0 8
54269: ARRAY
54270: PPUSH
54271: CALL_OW 115
// attacking := true ;
54275: LD_ADDR_VAR 0 29
54279: PUSH
54280: LD_INT 1
54282: ST_TO_ADDR
// break ;
54283: GO 54287
// end ;
54285: GO 54224
54287: POP
54288: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
54289: LD_VAR 0 4
54293: PUSH
54294: LD_VAR 0 7
54298: ARRAY
54299: PPUSH
54300: CALL_OW 302
54304: PUSH
54305: LD_VAR 0 29
54309: NOT
54310: AND
54311: IFFALSE 54633
// begin if GetTag ( group [ i ] ) = 71 then
54313: LD_VAR 0 4
54317: PUSH
54318: LD_VAR 0 7
54322: ARRAY
54323: PPUSH
54324: CALL_OW 110
54328: PUSH
54329: LD_INT 71
54331: EQUAL
54332: IFFALSE 54373
// begin if HasTask ( group [ i ] ) then
54334: LD_VAR 0 4
54338: PUSH
54339: LD_VAR 0 7
54343: ARRAY
54344: PPUSH
54345: CALL_OW 314
54349: IFFALSE 54355
// continue else
54351: GO 50512
54353: GO 54373
// SetTag ( group [ i ] , 0 ) ;
54355: LD_VAR 0 4
54359: PUSH
54360: LD_VAR 0 7
54364: ARRAY
54365: PPUSH
54366: LD_INT 0
54368: PPUSH
54369: CALL_OW 109
// end ; k := 8 ;
54373: LD_ADDR_VAR 0 9
54377: PUSH
54378: LD_INT 8
54380: ST_TO_ADDR
// x := 0 ;
54381: LD_ADDR_VAR 0 10
54385: PUSH
54386: LD_INT 0
54388: ST_TO_ADDR
// if tmp < k then
54389: LD_VAR 0 14
54393: PUSH
54394: LD_VAR 0 9
54398: LESS
54399: IFFALSE 54411
// k := tmp ;
54401: LD_ADDR_VAR 0 9
54405: PUSH
54406: LD_VAR 0 14
54410: ST_TO_ADDR
// for j = 1 to k do
54411: LD_ADDR_VAR 0 8
54415: PUSH
54416: DOUBLE
54417: LD_INT 1
54419: DEC
54420: ST_TO_ADDR
54421: LD_VAR 0 9
54425: PUSH
54426: FOR_TO
54427: IFFALSE 54525
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
54429: LD_VAR 0 14
54433: PUSH
54434: LD_VAR 0 8
54438: ARRAY
54439: PPUSH
54440: CALL_OW 247
54444: PUSH
54445: LD_INT 1
54447: EQUAL
54448: PUSH
54449: LD_VAR 0 14
54453: PUSH
54454: LD_VAR 0 8
54458: ARRAY
54459: PPUSH
54460: CALL_OW 256
54464: PUSH
54465: LD_INT 250
54467: LESS
54468: PUSH
54469: LD_VAR 0 20
54473: AND
54474: PUSH
54475: LD_VAR 0 20
54479: NOT
54480: PUSH
54481: LD_VAR 0 14
54485: PUSH
54486: LD_VAR 0 8
54490: ARRAY
54491: PPUSH
54492: CALL_OW 256
54496: PUSH
54497: LD_INT 250
54499: GREATEREQUAL
54500: AND
54501: OR
54502: AND
54503: IFFALSE 54523
// begin x := tmp [ j ] ;
54505: LD_ADDR_VAR 0 10
54509: PUSH
54510: LD_VAR 0 14
54514: PUSH
54515: LD_VAR 0 8
54519: ARRAY
54520: ST_TO_ADDR
// break ;
54521: GO 54525
// end ;
54523: GO 54426
54525: POP
54526: POP
// if x then
54527: LD_VAR 0 10
54531: IFFALSE 54555
// ComAttackUnit ( group [ i ] , x ) else
54533: LD_VAR 0 4
54537: PUSH
54538: LD_VAR 0 7
54542: ARRAY
54543: PPUSH
54544: LD_VAR 0 10
54548: PPUSH
54549: CALL_OW 115
54553: GO 54579
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
54555: LD_VAR 0 4
54559: PUSH
54560: LD_VAR 0 7
54564: ARRAY
54565: PPUSH
54566: LD_VAR 0 14
54570: PUSH
54571: LD_INT 1
54573: ARRAY
54574: PPUSH
54575: CALL_OW 115
// if not HasTask ( group [ i ] ) then
54579: LD_VAR 0 4
54583: PUSH
54584: LD_VAR 0 7
54588: ARRAY
54589: PPUSH
54590: CALL_OW 314
54594: NOT
54595: IFFALSE 54633
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
54597: LD_VAR 0 4
54601: PUSH
54602: LD_VAR 0 7
54606: ARRAY
54607: PPUSH
54608: LD_VAR 0 14
54612: PPUSH
54613: LD_VAR 0 4
54617: PUSH
54618: LD_VAR 0 7
54622: ARRAY
54623: PPUSH
54624: CALL_OW 74
54628: PPUSH
54629: CALL_OW 115
// end ; end ; end ;
54633: GO 50512
54635: POP
54636: POP
// wait ( 0 0$1 ) ;
54637: LD_INT 35
54639: PPUSH
54640: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
54644: LD_VAR 0 4
54648: PUSH
54649: EMPTY
54650: EQUAL
54651: PUSH
54652: LD_INT 81
54654: PUSH
54655: LD_VAR 0 35
54659: PUSH
54660: EMPTY
54661: LIST
54662: LIST
54663: PPUSH
54664: CALL_OW 69
54668: NOT
54669: OR
54670: IFFALSE 50497
// end ;
54672: LD_VAR 0 2
54676: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54677: LD_INT 0
54679: PPUSH
54680: PPUSH
54681: PPUSH
54682: PPUSH
// if not base_units then
54683: LD_VAR 0 1
54687: NOT
54688: IFFALSE 54692
// exit ;
54690: GO 54779
// result := false ;
54692: LD_ADDR_VAR 0 2
54696: PUSH
54697: LD_INT 0
54699: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54700: LD_ADDR_VAR 0 5
54704: PUSH
54705: LD_VAR 0 1
54709: PPUSH
54710: LD_INT 21
54712: PUSH
54713: LD_INT 3
54715: PUSH
54716: EMPTY
54717: LIST
54718: LIST
54719: PPUSH
54720: CALL_OW 72
54724: ST_TO_ADDR
// if not tmp then
54725: LD_VAR 0 5
54729: NOT
54730: IFFALSE 54734
// exit ;
54732: GO 54779
// for i in tmp do
54734: LD_ADDR_VAR 0 3
54738: PUSH
54739: LD_VAR 0 5
54743: PUSH
54744: FOR_IN
54745: IFFALSE 54777
// begin result := EnemyInRange ( i , 22 ) ;
54747: LD_ADDR_VAR 0 2
54751: PUSH
54752: LD_VAR 0 3
54756: PPUSH
54757: LD_INT 22
54759: PPUSH
54760: CALL 48313 0 2
54764: ST_TO_ADDR
// if result then
54765: LD_VAR 0 2
54769: IFFALSE 54775
// exit ;
54771: POP
54772: POP
54773: GO 54779
// end ;
54775: GO 54744
54777: POP
54778: POP
// end ;
54779: LD_VAR 0 2
54783: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
54784: LD_INT 0
54786: PPUSH
54787: PPUSH
// if not units then
54788: LD_VAR 0 1
54792: NOT
54793: IFFALSE 54797
// exit ;
54795: GO 54867
// result := [ ] ;
54797: LD_ADDR_VAR 0 3
54801: PUSH
54802: EMPTY
54803: ST_TO_ADDR
// for i in units do
54804: LD_ADDR_VAR 0 4
54808: PUSH
54809: LD_VAR 0 1
54813: PUSH
54814: FOR_IN
54815: IFFALSE 54865
// if GetTag ( i ) = tag then
54817: LD_VAR 0 4
54821: PPUSH
54822: CALL_OW 110
54826: PUSH
54827: LD_VAR 0 2
54831: EQUAL
54832: IFFALSE 54863
// result := Insert ( result , result + 1 , i ) ;
54834: LD_ADDR_VAR 0 3
54838: PUSH
54839: LD_VAR 0 3
54843: PPUSH
54844: LD_VAR 0 3
54848: PUSH
54849: LD_INT 1
54851: PLUS
54852: PPUSH
54853: LD_VAR 0 4
54857: PPUSH
54858: CALL_OW 2
54862: ST_TO_ADDR
54863: GO 54814
54865: POP
54866: POP
// end ;
54867: LD_VAR 0 3
54871: RET
// export function IsDriver ( un ) ; begin
54872: LD_INT 0
54874: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54875: LD_ADDR_VAR 0 2
54879: PUSH
54880: LD_VAR 0 1
54884: PUSH
54885: LD_INT 55
54887: PUSH
54888: EMPTY
54889: LIST
54890: PPUSH
54891: CALL_OW 69
54895: IN
54896: ST_TO_ADDR
// end ;
54897: LD_VAR 0 2
54901: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54902: LD_INT 0
54904: PPUSH
54905: PPUSH
// list := [ ] ;
54906: LD_ADDR_VAR 0 5
54910: PUSH
54911: EMPTY
54912: ST_TO_ADDR
// case d of 0 :
54913: LD_VAR 0 3
54917: PUSH
54918: LD_INT 0
54920: DOUBLE
54921: EQUAL
54922: IFTRUE 54926
54924: GO 55059
54926: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54927: LD_ADDR_VAR 0 5
54931: PUSH
54932: LD_VAR 0 1
54936: PUSH
54937: LD_INT 4
54939: MINUS
54940: PUSH
54941: LD_VAR 0 2
54945: PUSH
54946: LD_INT 4
54948: MINUS
54949: PUSH
54950: LD_INT 2
54952: PUSH
54953: EMPTY
54954: LIST
54955: LIST
54956: LIST
54957: PUSH
54958: LD_VAR 0 1
54962: PUSH
54963: LD_INT 3
54965: MINUS
54966: PUSH
54967: LD_VAR 0 2
54971: PUSH
54972: LD_INT 1
54974: PUSH
54975: EMPTY
54976: LIST
54977: LIST
54978: LIST
54979: PUSH
54980: LD_VAR 0 1
54984: PUSH
54985: LD_INT 4
54987: PLUS
54988: PUSH
54989: LD_VAR 0 2
54993: PUSH
54994: LD_INT 4
54996: PUSH
54997: EMPTY
54998: LIST
54999: LIST
55000: LIST
55001: PUSH
55002: LD_VAR 0 1
55006: PUSH
55007: LD_INT 3
55009: PLUS
55010: PUSH
55011: LD_VAR 0 2
55015: PUSH
55016: LD_INT 3
55018: PLUS
55019: PUSH
55020: LD_INT 5
55022: PUSH
55023: EMPTY
55024: LIST
55025: LIST
55026: LIST
55027: PUSH
55028: LD_VAR 0 1
55032: PUSH
55033: LD_VAR 0 2
55037: PUSH
55038: LD_INT 4
55040: PLUS
55041: PUSH
55042: LD_INT 0
55044: PUSH
55045: EMPTY
55046: LIST
55047: LIST
55048: LIST
55049: PUSH
55050: EMPTY
55051: LIST
55052: LIST
55053: LIST
55054: LIST
55055: LIST
55056: ST_TO_ADDR
// end ; 1 :
55057: GO 55757
55059: LD_INT 1
55061: DOUBLE
55062: EQUAL
55063: IFTRUE 55067
55065: GO 55200
55067: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55068: LD_ADDR_VAR 0 5
55072: PUSH
55073: LD_VAR 0 1
55077: PUSH
55078: LD_VAR 0 2
55082: PUSH
55083: LD_INT 4
55085: MINUS
55086: PUSH
55087: LD_INT 3
55089: PUSH
55090: EMPTY
55091: LIST
55092: LIST
55093: LIST
55094: PUSH
55095: LD_VAR 0 1
55099: PUSH
55100: LD_INT 3
55102: MINUS
55103: PUSH
55104: LD_VAR 0 2
55108: PUSH
55109: LD_INT 3
55111: MINUS
55112: PUSH
55113: LD_INT 2
55115: PUSH
55116: EMPTY
55117: LIST
55118: LIST
55119: LIST
55120: PUSH
55121: LD_VAR 0 1
55125: PUSH
55126: LD_INT 4
55128: MINUS
55129: PUSH
55130: LD_VAR 0 2
55134: PUSH
55135: LD_INT 1
55137: PUSH
55138: EMPTY
55139: LIST
55140: LIST
55141: LIST
55142: PUSH
55143: LD_VAR 0 1
55147: PUSH
55148: LD_VAR 0 2
55152: PUSH
55153: LD_INT 3
55155: PLUS
55156: PUSH
55157: LD_INT 0
55159: PUSH
55160: EMPTY
55161: LIST
55162: LIST
55163: LIST
55164: PUSH
55165: LD_VAR 0 1
55169: PUSH
55170: LD_INT 4
55172: PLUS
55173: PUSH
55174: LD_VAR 0 2
55178: PUSH
55179: LD_INT 4
55181: PLUS
55182: PUSH
55183: LD_INT 5
55185: PUSH
55186: EMPTY
55187: LIST
55188: LIST
55189: LIST
55190: PUSH
55191: EMPTY
55192: LIST
55193: LIST
55194: LIST
55195: LIST
55196: LIST
55197: ST_TO_ADDR
// end ; 2 :
55198: GO 55757
55200: LD_INT 2
55202: DOUBLE
55203: EQUAL
55204: IFTRUE 55208
55206: GO 55337
55208: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55209: LD_ADDR_VAR 0 5
55213: PUSH
55214: LD_VAR 0 1
55218: PUSH
55219: LD_VAR 0 2
55223: PUSH
55224: LD_INT 3
55226: MINUS
55227: PUSH
55228: LD_INT 3
55230: PUSH
55231: EMPTY
55232: LIST
55233: LIST
55234: LIST
55235: PUSH
55236: LD_VAR 0 1
55240: PUSH
55241: LD_INT 4
55243: PLUS
55244: PUSH
55245: LD_VAR 0 2
55249: PUSH
55250: LD_INT 4
55252: PUSH
55253: EMPTY
55254: LIST
55255: LIST
55256: LIST
55257: PUSH
55258: LD_VAR 0 1
55262: PUSH
55263: LD_VAR 0 2
55267: PUSH
55268: LD_INT 4
55270: PLUS
55271: PUSH
55272: LD_INT 0
55274: PUSH
55275: EMPTY
55276: LIST
55277: LIST
55278: LIST
55279: PUSH
55280: LD_VAR 0 1
55284: PUSH
55285: LD_INT 3
55287: MINUS
55288: PUSH
55289: LD_VAR 0 2
55293: PUSH
55294: LD_INT 1
55296: PUSH
55297: EMPTY
55298: LIST
55299: LIST
55300: LIST
55301: PUSH
55302: LD_VAR 0 1
55306: PUSH
55307: LD_INT 4
55309: MINUS
55310: PUSH
55311: LD_VAR 0 2
55315: PUSH
55316: LD_INT 4
55318: MINUS
55319: PUSH
55320: LD_INT 2
55322: PUSH
55323: EMPTY
55324: LIST
55325: LIST
55326: LIST
55327: PUSH
55328: EMPTY
55329: LIST
55330: LIST
55331: LIST
55332: LIST
55333: LIST
55334: ST_TO_ADDR
// end ; 3 :
55335: GO 55757
55337: LD_INT 3
55339: DOUBLE
55340: EQUAL
55341: IFTRUE 55345
55343: GO 55478
55345: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55346: LD_ADDR_VAR 0 5
55350: PUSH
55351: LD_VAR 0 1
55355: PUSH
55356: LD_INT 3
55358: PLUS
55359: PUSH
55360: LD_VAR 0 2
55364: PUSH
55365: LD_INT 4
55367: PUSH
55368: EMPTY
55369: LIST
55370: LIST
55371: LIST
55372: PUSH
55373: LD_VAR 0 1
55377: PUSH
55378: LD_INT 4
55380: PLUS
55381: PUSH
55382: LD_VAR 0 2
55386: PUSH
55387: LD_INT 4
55389: PLUS
55390: PUSH
55391: LD_INT 5
55393: PUSH
55394: EMPTY
55395: LIST
55396: LIST
55397: LIST
55398: PUSH
55399: LD_VAR 0 1
55403: PUSH
55404: LD_INT 4
55406: MINUS
55407: PUSH
55408: LD_VAR 0 2
55412: PUSH
55413: LD_INT 1
55415: PUSH
55416: EMPTY
55417: LIST
55418: LIST
55419: LIST
55420: PUSH
55421: LD_VAR 0 1
55425: PUSH
55426: LD_VAR 0 2
55430: PUSH
55431: LD_INT 4
55433: MINUS
55434: PUSH
55435: LD_INT 3
55437: PUSH
55438: EMPTY
55439: LIST
55440: LIST
55441: LIST
55442: PUSH
55443: LD_VAR 0 1
55447: PUSH
55448: LD_INT 3
55450: MINUS
55451: PUSH
55452: LD_VAR 0 2
55456: PUSH
55457: LD_INT 3
55459: MINUS
55460: PUSH
55461: LD_INT 2
55463: PUSH
55464: EMPTY
55465: LIST
55466: LIST
55467: LIST
55468: PUSH
55469: EMPTY
55470: LIST
55471: LIST
55472: LIST
55473: LIST
55474: LIST
55475: ST_TO_ADDR
// end ; 4 :
55476: GO 55757
55478: LD_INT 4
55480: DOUBLE
55481: EQUAL
55482: IFTRUE 55486
55484: GO 55619
55486: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55487: LD_ADDR_VAR 0 5
55491: PUSH
55492: LD_VAR 0 1
55496: PUSH
55497: LD_VAR 0 2
55501: PUSH
55502: LD_INT 4
55504: PLUS
55505: PUSH
55506: LD_INT 0
55508: PUSH
55509: EMPTY
55510: LIST
55511: LIST
55512: LIST
55513: PUSH
55514: LD_VAR 0 1
55518: PUSH
55519: LD_INT 3
55521: PLUS
55522: PUSH
55523: LD_VAR 0 2
55527: PUSH
55528: LD_INT 3
55530: PLUS
55531: PUSH
55532: LD_INT 5
55534: PUSH
55535: EMPTY
55536: LIST
55537: LIST
55538: LIST
55539: PUSH
55540: LD_VAR 0 1
55544: PUSH
55545: LD_INT 4
55547: PLUS
55548: PUSH
55549: LD_VAR 0 2
55553: PUSH
55554: LD_INT 4
55556: PUSH
55557: EMPTY
55558: LIST
55559: LIST
55560: LIST
55561: PUSH
55562: LD_VAR 0 1
55566: PUSH
55567: LD_VAR 0 2
55571: PUSH
55572: LD_INT 3
55574: MINUS
55575: PUSH
55576: LD_INT 3
55578: PUSH
55579: EMPTY
55580: LIST
55581: LIST
55582: LIST
55583: PUSH
55584: LD_VAR 0 1
55588: PUSH
55589: LD_INT 4
55591: MINUS
55592: PUSH
55593: LD_VAR 0 2
55597: PUSH
55598: LD_INT 4
55600: MINUS
55601: PUSH
55602: LD_INT 2
55604: PUSH
55605: EMPTY
55606: LIST
55607: LIST
55608: LIST
55609: PUSH
55610: EMPTY
55611: LIST
55612: LIST
55613: LIST
55614: LIST
55615: LIST
55616: ST_TO_ADDR
// end ; 5 :
55617: GO 55757
55619: LD_INT 5
55621: DOUBLE
55622: EQUAL
55623: IFTRUE 55627
55625: GO 55756
55627: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55628: LD_ADDR_VAR 0 5
55632: PUSH
55633: LD_VAR 0 1
55637: PUSH
55638: LD_INT 4
55640: MINUS
55641: PUSH
55642: LD_VAR 0 2
55646: PUSH
55647: LD_INT 1
55649: PUSH
55650: EMPTY
55651: LIST
55652: LIST
55653: LIST
55654: PUSH
55655: LD_VAR 0 1
55659: PUSH
55660: LD_VAR 0 2
55664: PUSH
55665: LD_INT 4
55667: MINUS
55668: PUSH
55669: LD_INT 3
55671: PUSH
55672: EMPTY
55673: LIST
55674: LIST
55675: LIST
55676: PUSH
55677: LD_VAR 0 1
55681: PUSH
55682: LD_INT 4
55684: PLUS
55685: PUSH
55686: LD_VAR 0 2
55690: PUSH
55691: LD_INT 4
55693: PLUS
55694: PUSH
55695: LD_INT 5
55697: PUSH
55698: EMPTY
55699: LIST
55700: LIST
55701: LIST
55702: PUSH
55703: LD_VAR 0 1
55707: PUSH
55708: LD_INT 3
55710: PLUS
55711: PUSH
55712: LD_VAR 0 2
55716: PUSH
55717: LD_INT 4
55719: PUSH
55720: EMPTY
55721: LIST
55722: LIST
55723: LIST
55724: PUSH
55725: LD_VAR 0 1
55729: PUSH
55730: LD_VAR 0 2
55734: PUSH
55735: LD_INT 3
55737: PLUS
55738: PUSH
55739: LD_INT 0
55741: PUSH
55742: EMPTY
55743: LIST
55744: LIST
55745: LIST
55746: PUSH
55747: EMPTY
55748: LIST
55749: LIST
55750: LIST
55751: LIST
55752: LIST
55753: ST_TO_ADDR
// end ; end ;
55754: GO 55757
55756: POP
// result := list ;
55757: LD_ADDR_VAR 0 4
55761: PUSH
55762: LD_VAR 0 5
55766: ST_TO_ADDR
// end ;
55767: LD_VAR 0 4
55771: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55772: LD_INT 0
55774: PPUSH
55775: PPUSH
55776: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55777: LD_VAR 0 1
55781: NOT
55782: PUSH
55783: LD_VAR 0 2
55787: PUSH
55788: LD_INT 1
55790: PUSH
55791: LD_INT 2
55793: PUSH
55794: LD_INT 3
55796: PUSH
55797: LD_INT 4
55799: PUSH
55800: EMPTY
55801: LIST
55802: LIST
55803: LIST
55804: LIST
55805: IN
55806: NOT
55807: OR
55808: IFFALSE 55812
// exit ;
55810: GO 55904
// tmp := [ ] ;
55812: LD_ADDR_VAR 0 5
55816: PUSH
55817: EMPTY
55818: ST_TO_ADDR
// for i in units do
55819: LD_ADDR_VAR 0 4
55823: PUSH
55824: LD_VAR 0 1
55828: PUSH
55829: FOR_IN
55830: IFFALSE 55873
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55832: LD_ADDR_VAR 0 5
55836: PUSH
55837: LD_VAR 0 5
55841: PPUSH
55842: LD_VAR 0 5
55846: PUSH
55847: LD_INT 1
55849: PLUS
55850: PPUSH
55851: LD_VAR 0 4
55855: PPUSH
55856: LD_VAR 0 2
55860: PPUSH
55861: CALL_OW 259
55865: PPUSH
55866: CALL_OW 2
55870: ST_TO_ADDR
55871: GO 55829
55873: POP
55874: POP
// if not tmp then
55875: LD_VAR 0 5
55879: NOT
55880: IFFALSE 55884
// exit ;
55882: GO 55904
// result := SortListByListDesc ( units , tmp ) ;
55884: LD_ADDR_VAR 0 3
55888: PUSH
55889: LD_VAR 0 1
55893: PPUSH
55894: LD_VAR 0 5
55898: PPUSH
55899: CALL_OW 77
55903: ST_TO_ADDR
// end ;
55904: LD_VAR 0 3
55908: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55909: LD_INT 0
55911: PPUSH
55912: PPUSH
55913: PPUSH
// x := GetX ( building ) ;
55914: LD_ADDR_VAR 0 4
55918: PUSH
55919: LD_VAR 0 2
55923: PPUSH
55924: CALL_OW 250
55928: ST_TO_ADDR
// y := GetY ( building ) ;
55929: LD_ADDR_VAR 0 5
55933: PUSH
55934: LD_VAR 0 2
55938: PPUSH
55939: CALL_OW 251
55943: ST_TO_ADDR
// if GetTaskList ( unit ) then
55944: LD_VAR 0 1
55948: PPUSH
55949: CALL_OW 437
55953: IFFALSE 56048
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55955: LD_STRING e
55957: PUSH
55958: LD_VAR 0 1
55962: PPUSH
55963: CALL_OW 437
55967: PUSH
55968: LD_INT 1
55970: ARRAY
55971: PUSH
55972: LD_INT 1
55974: ARRAY
55975: EQUAL
55976: PUSH
55977: LD_VAR 0 4
55981: PUSH
55982: LD_VAR 0 1
55986: PPUSH
55987: CALL_OW 437
55991: PUSH
55992: LD_INT 1
55994: ARRAY
55995: PUSH
55996: LD_INT 2
55998: ARRAY
55999: EQUAL
56000: AND
56001: PUSH
56002: LD_VAR 0 5
56006: PUSH
56007: LD_VAR 0 1
56011: PPUSH
56012: CALL_OW 437
56016: PUSH
56017: LD_INT 1
56019: ARRAY
56020: PUSH
56021: LD_INT 3
56023: ARRAY
56024: EQUAL
56025: AND
56026: IFFALSE 56038
// result := true else
56028: LD_ADDR_VAR 0 3
56032: PUSH
56033: LD_INT 1
56035: ST_TO_ADDR
56036: GO 56046
// result := false ;
56038: LD_ADDR_VAR 0 3
56042: PUSH
56043: LD_INT 0
56045: ST_TO_ADDR
// end else
56046: GO 56056
// result := false ;
56048: LD_ADDR_VAR 0 3
56052: PUSH
56053: LD_INT 0
56055: ST_TO_ADDR
// end ;
56056: LD_VAR 0 3
56060: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
56061: LD_INT 0
56063: PPUSH
56064: PPUSH
56065: PPUSH
56066: PPUSH
// if not unit or not area then
56067: LD_VAR 0 1
56071: NOT
56072: PUSH
56073: LD_VAR 0 2
56077: NOT
56078: OR
56079: IFFALSE 56083
// exit ;
56081: GO 56247
// tmp := AreaToList ( area , i ) ;
56083: LD_ADDR_VAR 0 6
56087: PUSH
56088: LD_VAR 0 2
56092: PPUSH
56093: LD_VAR 0 5
56097: PPUSH
56098: CALL_OW 517
56102: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
56103: LD_ADDR_VAR 0 5
56107: PUSH
56108: DOUBLE
56109: LD_INT 1
56111: DEC
56112: ST_TO_ADDR
56113: LD_VAR 0 6
56117: PUSH
56118: LD_INT 1
56120: ARRAY
56121: PUSH
56122: FOR_TO
56123: IFFALSE 56245
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
56125: LD_ADDR_VAR 0 7
56129: PUSH
56130: LD_VAR 0 6
56134: PUSH
56135: LD_INT 1
56137: ARRAY
56138: PUSH
56139: LD_VAR 0 5
56143: ARRAY
56144: PUSH
56145: LD_VAR 0 6
56149: PUSH
56150: LD_INT 2
56152: ARRAY
56153: PUSH
56154: LD_VAR 0 5
56158: ARRAY
56159: PUSH
56160: EMPTY
56161: LIST
56162: LIST
56163: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
56164: LD_VAR 0 7
56168: PUSH
56169: LD_INT 1
56171: ARRAY
56172: PPUSH
56173: LD_VAR 0 7
56177: PUSH
56178: LD_INT 2
56180: ARRAY
56181: PPUSH
56182: CALL_OW 428
56186: PUSH
56187: LD_INT 0
56189: EQUAL
56190: IFFALSE 56243
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
56192: LD_VAR 0 1
56196: PPUSH
56197: LD_VAR 0 7
56201: PUSH
56202: LD_INT 1
56204: ARRAY
56205: PPUSH
56206: LD_VAR 0 7
56210: PUSH
56211: LD_INT 2
56213: ARRAY
56214: PPUSH
56215: LD_VAR 0 3
56219: PPUSH
56220: CALL_OW 48
// result := IsPlaced ( unit ) ;
56224: LD_ADDR_VAR 0 4
56228: PUSH
56229: LD_VAR 0 1
56233: PPUSH
56234: CALL_OW 305
56238: ST_TO_ADDR
// exit ;
56239: POP
56240: POP
56241: GO 56247
// end ; end ;
56243: GO 56122
56245: POP
56246: POP
// end ;
56247: LD_VAR 0 4
56251: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56252: LD_INT 0
56254: PPUSH
56255: PPUSH
56256: PPUSH
// if not side or side > 8 then
56257: LD_VAR 0 1
56261: NOT
56262: PUSH
56263: LD_VAR 0 1
56267: PUSH
56268: LD_INT 8
56270: GREATER
56271: OR
56272: IFFALSE 56276
// exit ;
56274: GO 56463
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56276: LD_ADDR_VAR 0 4
56280: PUSH
56281: LD_INT 22
56283: PUSH
56284: LD_VAR 0 1
56288: PUSH
56289: EMPTY
56290: LIST
56291: LIST
56292: PUSH
56293: LD_INT 21
56295: PUSH
56296: LD_INT 3
56298: PUSH
56299: EMPTY
56300: LIST
56301: LIST
56302: PUSH
56303: EMPTY
56304: LIST
56305: LIST
56306: PPUSH
56307: CALL_OW 69
56311: ST_TO_ADDR
// if not tmp then
56312: LD_VAR 0 4
56316: NOT
56317: IFFALSE 56321
// exit ;
56319: GO 56463
// enable_addtolog := true ;
56321: LD_ADDR_OWVAR 81
56325: PUSH
56326: LD_INT 1
56328: ST_TO_ADDR
// AddToLog ( [ ) ;
56329: LD_STRING [
56331: PPUSH
56332: CALL_OW 561
// for i in tmp do
56336: LD_ADDR_VAR 0 3
56340: PUSH
56341: LD_VAR 0 4
56345: PUSH
56346: FOR_IN
56347: IFFALSE 56454
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56349: LD_STRING [
56351: PUSH
56352: LD_VAR 0 3
56356: PPUSH
56357: CALL_OW 266
56361: STR
56362: PUSH
56363: LD_STRING , 
56365: STR
56366: PUSH
56367: LD_VAR 0 3
56371: PPUSH
56372: CALL_OW 250
56376: STR
56377: PUSH
56378: LD_STRING , 
56380: STR
56381: PUSH
56382: LD_VAR 0 3
56386: PPUSH
56387: CALL_OW 251
56391: STR
56392: PUSH
56393: LD_STRING , 
56395: STR
56396: PUSH
56397: LD_VAR 0 3
56401: PPUSH
56402: CALL_OW 254
56406: STR
56407: PUSH
56408: LD_STRING , 
56410: STR
56411: PUSH
56412: LD_VAR 0 3
56416: PPUSH
56417: LD_INT 1
56419: PPUSH
56420: CALL_OW 268
56424: STR
56425: PUSH
56426: LD_STRING , 
56428: STR
56429: PUSH
56430: LD_VAR 0 3
56434: PPUSH
56435: LD_INT 2
56437: PPUSH
56438: CALL_OW 268
56442: STR
56443: PUSH
56444: LD_STRING ],
56446: STR
56447: PPUSH
56448: CALL_OW 561
// end ;
56452: GO 56346
56454: POP
56455: POP
// AddToLog ( ]; ) ;
56456: LD_STRING ];
56458: PPUSH
56459: CALL_OW 561
// end ;
56463: LD_VAR 0 2
56467: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56468: LD_INT 0
56470: PPUSH
56471: PPUSH
56472: PPUSH
56473: PPUSH
56474: PPUSH
// if not area or not rate or not max then
56475: LD_VAR 0 1
56479: NOT
56480: PUSH
56481: LD_VAR 0 2
56485: NOT
56486: OR
56487: PUSH
56488: LD_VAR 0 4
56492: NOT
56493: OR
56494: IFFALSE 56498
// exit ;
56496: GO 56690
// while 1 do
56498: LD_INT 1
56500: IFFALSE 56690
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56502: LD_ADDR_VAR 0 9
56506: PUSH
56507: LD_VAR 0 1
56511: PPUSH
56512: LD_INT 1
56514: PPUSH
56515: CALL_OW 287
56519: PUSH
56520: LD_INT 10
56522: MUL
56523: ST_TO_ADDR
// r := rate / 10 ;
56524: LD_ADDR_VAR 0 7
56528: PUSH
56529: LD_VAR 0 2
56533: PUSH
56534: LD_INT 10
56536: DIVREAL
56537: ST_TO_ADDR
// time := 1 1$00 ;
56538: LD_ADDR_VAR 0 8
56542: PUSH
56543: LD_INT 2100
56545: ST_TO_ADDR
// if amount < min then
56546: LD_VAR 0 9
56550: PUSH
56551: LD_VAR 0 3
56555: LESS
56556: IFFALSE 56574
// r := r * 2 else
56558: LD_ADDR_VAR 0 7
56562: PUSH
56563: LD_VAR 0 7
56567: PUSH
56568: LD_INT 2
56570: MUL
56571: ST_TO_ADDR
56572: GO 56600
// if amount > max then
56574: LD_VAR 0 9
56578: PUSH
56579: LD_VAR 0 4
56583: GREATER
56584: IFFALSE 56600
// r := r / 2 ;
56586: LD_ADDR_VAR 0 7
56590: PUSH
56591: LD_VAR 0 7
56595: PUSH
56596: LD_INT 2
56598: DIVREAL
56599: ST_TO_ADDR
// time := time / r ;
56600: LD_ADDR_VAR 0 8
56604: PUSH
56605: LD_VAR 0 8
56609: PUSH
56610: LD_VAR 0 7
56614: DIVREAL
56615: ST_TO_ADDR
// if time < 0 then
56616: LD_VAR 0 8
56620: PUSH
56621: LD_INT 0
56623: LESS
56624: IFFALSE 56641
// time := time * - 1 ;
56626: LD_ADDR_VAR 0 8
56630: PUSH
56631: LD_VAR 0 8
56635: PUSH
56636: LD_INT 1
56638: NEG
56639: MUL
56640: ST_TO_ADDR
// wait ( time ) ;
56641: LD_VAR 0 8
56645: PPUSH
56646: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
56650: LD_INT 35
56652: PPUSH
56653: LD_INT 875
56655: PPUSH
56656: CALL_OW 12
56660: PPUSH
56661: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56665: LD_INT 1
56667: PPUSH
56668: LD_INT 5
56670: PPUSH
56671: CALL_OW 12
56675: PPUSH
56676: LD_VAR 0 1
56680: PPUSH
56681: LD_INT 1
56683: PPUSH
56684: CALL_OW 55
// end ;
56688: GO 56498
// end ;
56690: LD_VAR 0 5
56694: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56695: LD_INT 0
56697: PPUSH
56698: PPUSH
56699: PPUSH
56700: PPUSH
56701: PPUSH
56702: PPUSH
56703: PPUSH
56704: PPUSH
// if not turrets or not factories then
56705: LD_VAR 0 1
56709: NOT
56710: PUSH
56711: LD_VAR 0 2
56715: NOT
56716: OR
56717: IFFALSE 56721
// exit ;
56719: GO 57028
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56721: LD_ADDR_VAR 0 10
56725: PUSH
56726: LD_INT 5
56728: PUSH
56729: LD_INT 6
56731: PUSH
56732: EMPTY
56733: LIST
56734: LIST
56735: PUSH
56736: LD_INT 2
56738: PUSH
56739: LD_INT 4
56741: PUSH
56742: EMPTY
56743: LIST
56744: LIST
56745: PUSH
56746: LD_INT 3
56748: PUSH
56749: LD_INT 5
56751: PUSH
56752: EMPTY
56753: LIST
56754: LIST
56755: PUSH
56756: EMPTY
56757: LIST
56758: LIST
56759: LIST
56760: PUSH
56761: LD_INT 24
56763: PUSH
56764: LD_INT 25
56766: PUSH
56767: EMPTY
56768: LIST
56769: LIST
56770: PUSH
56771: LD_INT 23
56773: PUSH
56774: LD_INT 27
56776: PUSH
56777: EMPTY
56778: LIST
56779: LIST
56780: PUSH
56781: EMPTY
56782: LIST
56783: LIST
56784: PUSH
56785: LD_INT 42
56787: PUSH
56788: LD_INT 43
56790: PUSH
56791: EMPTY
56792: LIST
56793: LIST
56794: PUSH
56795: LD_INT 44
56797: PUSH
56798: LD_INT 46
56800: PUSH
56801: EMPTY
56802: LIST
56803: LIST
56804: PUSH
56805: LD_INT 45
56807: PUSH
56808: LD_INT 47
56810: PUSH
56811: EMPTY
56812: LIST
56813: LIST
56814: PUSH
56815: EMPTY
56816: LIST
56817: LIST
56818: LIST
56819: PUSH
56820: EMPTY
56821: LIST
56822: LIST
56823: LIST
56824: ST_TO_ADDR
// result := [ ] ;
56825: LD_ADDR_VAR 0 3
56829: PUSH
56830: EMPTY
56831: ST_TO_ADDR
// for i in turrets do
56832: LD_ADDR_VAR 0 4
56836: PUSH
56837: LD_VAR 0 1
56841: PUSH
56842: FOR_IN
56843: IFFALSE 57026
// begin nat := GetNation ( i ) ;
56845: LD_ADDR_VAR 0 7
56849: PUSH
56850: LD_VAR 0 4
56854: PPUSH
56855: CALL_OW 248
56859: ST_TO_ADDR
// weapon := 0 ;
56860: LD_ADDR_VAR 0 8
56864: PUSH
56865: LD_INT 0
56867: ST_TO_ADDR
// if not nat then
56868: LD_VAR 0 7
56872: NOT
56873: IFFALSE 56877
// continue ;
56875: GO 56842
// for j in list [ nat ] do
56877: LD_ADDR_VAR 0 5
56881: PUSH
56882: LD_VAR 0 10
56886: PUSH
56887: LD_VAR 0 7
56891: ARRAY
56892: PUSH
56893: FOR_IN
56894: IFFALSE 56935
// if GetBWeapon ( i ) = j [ 1 ] then
56896: LD_VAR 0 4
56900: PPUSH
56901: CALL_OW 269
56905: PUSH
56906: LD_VAR 0 5
56910: PUSH
56911: LD_INT 1
56913: ARRAY
56914: EQUAL
56915: IFFALSE 56933
// begin weapon := j [ 2 ] ;
56917: LD_ADDR_VAR 0 8
56921: PUSH
56922: LD_VAR 0 5
56926: PUSH
56927: LD_INT 2
56929: ARRAY
56930: ST_TO_ADDR
// break ;
56931: GO 56935
// end ;
56933: GO 56893
56935: POP
56936: POP
// if not weapon then
56937: LD_VAR 0 8
56941: NOT
56942: IFFALSE 56946
// continue ;
56944: GO 56842
// for k in factories do
56946: LD_ADDR_VAR 0 6
56950: PUSH
56951: LD_VAR 0 2
56955: PUSH
56956: FOR_IN
56957: IFFALSE 57022
// begin weapons := AvailableWeaponList ( k ) ;
56959: LD_ADDR_VAR 0 9
56963: PUSH
56964: LD_VAR 0 6
56968: PPUSH
56969: CALL_OW 478
56973: ST_TO_ADDR
// if not weapons then
56974: LD_VAR 0 9
56978: NOT
56979: IFFALSE 56983
// continue ;
56981: GO 56956
// if weapon in weapons then
56983: LD_VAR 0 8
56987: PUSH
56988: LD_VAR 0 9
56992: IN
56993: IFFALSE 57020
// begin result := [ i , weapon ] ;
56995: LD_ADDR_VAR 0 3
56999: PUSH
57000: LD_VAR 0 4
57004: PUSH
57005: LD_VAR 0 8
57009: PUSH
57010: EMPTY
57011: LIST
57012: LIST
57013: ST_TO_ADDR
// exit ;
57014: POP
57015: POP
57016: POP
57017: POP
57018: GO 57028
// end ; end ;
57020: GO 56956
57022: POP
57023: POP
// end ;
57024: GO 56842
57026: POP
57027: POP
// end ;
57028: LD_VAR 0 3
57032: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57033: LD_INT 0
57035: PPUSH
// if not side or side > 8 then
57036: LD_VAR 0 3
57040: NOT
57041: PUSH
57042: LD_VAR 0 3
57046: PUSH
57047: LD_INT 8
57049: GREATER
57050: OR
57051: IFFALSE 57055
// exit ;
57053: GO 57114
// if not range then
57055: LD_VAR 0 4
57059: NOT
57060: IFFALSE 57071
// range := - 12 ;
57062: LD_ADDR_VAR 0 4
57066: PUSH
57067: LD_INT 12
57069: NEG
57070: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
57071: LD_VAR 0 1
57075: PPUSH
57076: LD_VAR 0 2
57080: PPUSH
57081: LD_VAR 0 3
57085: PPUSH
57086: LD_VAR 0 4
57090: PPUSH
57091: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
57095: LD_VAR 0 1
57099: PPUSH
57100: LD_VAR 0 2
57104: PPUSH
57105: LD_VAR 0 3
57109: PPUSH
57110: CALL_OW 331
// end ;
57114: LD_VAR 0 5
57118: RET
// export function Video ( mode ) ; begin
57119: LD_INT 0
57121: PPUSH
// ingame_video = mode ;
57122: LD_ADDR_OWVAR 52
57126: PUSH
57127: LD_VAR 0 1
57131: ST_TO_ADDR
// interface_hidden = mode ;
57132: LD_ADDR_OWVAR 54
57136: PUSH
57137: LD_VAR 0 1
57141: ST_TO_ADDR
// end ;
57142: LD_VAR 0 2
57146: RET
// export function Join ( array , element ) ; begin
57147: LD_INT 0
57149: PPUSH
// result := array ^ element ;
57150: LD_ADDR_VAR 0 3
57154: PUSH
57155: LD_VAR 0 1
57159: PUSH
57160: LD_VAR 0 2
57164: ADD
57165: ST_TO_ADDR
// end ;
57166: LD_VAR 0 3
57170: RET
// export function JoinUnion ( array , element ) ; begin
57171: LD_INT 0
57173: PPUSH
// result := array union element ;
57174: LD_ADDR_VAR 0 3
57178: PUSH
57179: LD_VAR 0 1
57183: PUSH
57184: LD_VAR 0 2
57188: UNION
57189: ST_TO_ADDR
// end ;
57190: LD_VAR 0 3
57194: RET
// export function GetBehemoths ( side ) ; begin
57195: LD_INT 0
57197: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
57198: LD_ADDR_VAR 0 2
57202: PUSH
57203: LD_INT 22
57205: PUSH
57206: LD_VAR 0 1
57210: PUSH
57211: EMPTY
57212: LIST
57213: LIST
57214: PUSH
57215: LD_INT 31
57217: PUSH
57218: LD_INT 25
57220: PUSH
57221: EMPTY
57222: LIST
57223: LIST
57224: PUSH
57225: EMPTY
57226: LIST
57227: LIST
57228: PPUSH
57229: CALL_OW 69
57233: ST_TO_ADDR
// end ;
57234: LD_VAR 0 2
57238: RET
// export function Shuffle ( array ) ; var i , index ; begin
57239: LD_INT 0
57241: PPUSH
57242: PPUSH
57243: PPUSH
// result := [ ] ;
57244: LD_ADDR_VAR 0 2
57248: PUSH
57249: EMPTY
57250: ST_TO_ADDR
// if not array then
57251: LD_VAR 0 1
57255: NOT
57256: IFFALSE 57260
// exit ;
57258: GO 57359
// Randomize ;
57260: CALL_OW 10
// for i = array downto 1 do
57264: LD_ADDR_VAR 0 3
57268: PUSH
57269: DOUBLE
57270: LD_VAR 0 1
57274: INC
57275: ST_TO_ADDR
57276: LD_INT 1
57278: PUSH
57279: FOR_DOWNTO
57280: IFFALSE 57357
// begin index := rand ( 1 , array ) ;
57282: LD_ADDR_VAR 0 4
57286: PUSH
57287: LD_INT 1
57289: PPUSH
57290: LD_VAR 0 1
57294: PPUSH
57295: CALL_OW 12
57299: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57300: LD_ADDR_VAR 0 2
57304: PUSH
57305: LD_VAR 0 2
57309: PPUSH
57310: LD_VAR 0 2
57314: PUSH
57315: LD_INT 1
57317: PLUS
57318: PPUSH
57319: LD_VAR 0 1
57323: PUSH
57324: LD_VAR 0 4
57328: ARRAY
57329: PPUSH
57330: CALL_OW 2
57334: ST_TO_ADDR
// array := Delete ( array , index ) ;
57335: LD_ADDR_VAR 0 1
57339: PUSH
57340: LD_VAR 0 1
57344: PPUSH
57345: LD_VAR 0 4
57349: PPUSH
57350: CALL_OW 3
57354: ST_TO_ADDR
// end ;
57355: GO 57279
57357: POP
57358: POP
// end ;
57359: LD_VAR 0 2
57363: RET
// export function GetBaseMaterials ( base ) ; begin
57364: LD_INT 0
57366: PPUSH
// result := [ 0 , 0 , 0 ] ;
57367: LD_ADDR_VAR 0 2
57371: PUSH
57372: LD_INT 0
57374: PUSH
57375: LD_INT 0
57377: PUSH
57378: LD_INT 0
57380: PUSH
57381: EMPTY
57382: LIST
57383: LIST
57384: LIST
57385: ST_TO_ADDR
// if not base then
57386: LD_VAR 0 1
57390: NOT
57391: IFFALSE 57395
// exit ;
57393: GO 57444
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57395: LD_ADDR_VAR 0 2
57399: PUSH
57400: LD_VAR 0 1
57404: PPUSH
57405: LD_INT 1
57407: PPUSH
57408: CALL_OW 275
57412: PUSH
57413: LD_VAR 0 1
57417: PPUSH
57418: LD_INT 2
57420: PPUSH
57421: CALL_OW 275
57425: PUSH
57426: LD_VAR 0 1
57430: PPUSH
57431: LD_INT 3
57433: PPUSH
57434: CALL_OW 275
57438: PUSH
57439: EMPTY
57440: LIST
57441: LIST
57442: LIST
57443: ST_TO_ADDR
// end ; end_of_file
57444: LD_VAR 0 2
57448: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
57449: LD_INT 0
57451: PPUSH
57452: PPUSH
// skirmish := false ;
57453: LD_ADDR_EXP 57
57457: PUSH
57458: LD_INT 0
57460: ST_TO_ADDR
// debug_mc := false ;
57461: LD_ADDR_EXP 58
57465: PUSH
57466: LD_INT 0
57468: ST_TO_ADDR
// mc_bases := [ ] ;
57469: LD_ADDR_EXP 59
57473: PUSH
57474: EMPTY
57475: ST_TO_ADDR
// mc_sides := [ ] ;
57476: LD_ADDR_EXP 85
57480: PUSH
57481: EMPTY
57482: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
57483: LD_ADDR_EXP 60
57487: PUSH
57488: EMPTY
57489: ST_TO_ADDR
// mc_building_repairs := [ ] ;
57490: LD_ADDR_EXP 61
57494: PUSH
57495: EMPTY
57496: ST_TO_ADDR
// mc_need_heal := [ ] ;
57497: LD_ADDR_EXP 62
57501: PUSH
57502: EMPTY
57503: ST_TO_ADDR
// mc_healers := [ ] ;
57504: LD_ADDR_EXP 63
57508: PUSH
57509: EMPTY
57510: ST_TO_ADDR
// mc_build_list := [ ] ;
57511: LD_ADDR_EXP 64
57515: PUSH
57516: EMPTY
57517: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
57518: LD_ADDR_EXP 91
57522: PUSH
57523: EMPTY
57524: ST_TO_ADDR
// mc_builders := [ ] ;
57525: LD_ADDR_EXP 65
57529: PUSH
57530: EMPTY
57531: ST_TO_ADDR
// mc_construct_list := [ ] ;
57532: LD_ADDR_EXP 66
57536: PUSH
57537: EMPTY
57538: ST_TO_ADDR
// mc_turret_list := [ ] ;
57539: LD_ADDR_EXP 67
57543: PUSH
57544: EMPTY
57545: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
57546: LD_ADDR_EXP 68
57550: PUSH
57551: EMPTY
57552: ST_TO_ADDR
// mc_miners := [ ] ;
57553: LD_ADDR_EXP 73
57557: PUSH
57558: EMPTY
57559: ST_TO_ADDR
// mc_mines := [ ] ;
57560: LD_ADDR_EXP 72
57564: PUSH
57565: EMPTY
57566: ST_TO_ADDR
// mc_minefields := [ ] ;
57567: LD_ADDR_EXP 74
57571: PUSH
57572: EMPTY
57573: ST_TO_ADDR
// mc_crates := [ ] ;
57574: LD_ADDR_EXP 75
57578: PUSH
57579: EMPTY
57580: ST_TO_ADDR
// mc_crates_collector := [ ] ;
57581: LD_ADDR_EXP 76
57585: PUSH
57586: EMPTY
57587: ST_TO_ADDR
// mc_crates_area := [ ] ;
57588: LD_ADDR_EXP 77
57592: PUSH
57593: EMPTY
57594: ST_TO_ADDR
// mc_vehicles := [ ] ;
57595: LD_ADDR_EXP 78
57599: PUSH
57600: EMPTY
57601: ST_TO_ADDR
// mc_attack := [ ] ;
57602: LD_ADDR_EXP 79
57606: PUSH
57607: EMPTY
57608: ST_TO_ADDR
// mc_produce := [ ] ;
57609: LD_ADDR_EXP 80
57613: PUSH
57614: EMPTY
57615: ST_TO_ADDR
// mc_defender := [ ] ;
57616: LD_ADDR_EXP 81
57620: PUSH
57621: EMPTY
57622: ST_TO_ADDR
// mc_parking := [ ] ;
57623: LD_ADDR_EXP 83
57627: PUSH
57628: EMPTY
57629: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
57630: LD_ADDR_EXP 69
57634: PUSH
57635: EMPTY
57636: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
57637: LD_ADDR_EXP 71
57641: PUSH
57642: EMPTY
57643: ST_TO_ADDR
// mc_scan := [ ] ;
57644: LD_ADDR_EXP 82
57648: PUSH
57649: EMPTY
57650: ST_TO_ADDR
// mc_scan_area := [ ] ;
57651: LD_ADDR_EXP 84
57655: PUSH
57656: EMPTY
57657: ST_TO_ADDR
// mc_tech := [ ] ;
57658: LD_ADDR_EXP 86
57662: PUSH
57663: EMPTY
57664: ST_TO_ADDR
// mc_class := [ ] ;
57665: LD_ADDR_EXP 100
57669: PUSH
57670: EMPTY
57671: ST_TO_ADDR
// mc_class_case_use := [ ] ;
57672: LD_ADDR_EXP 101
57676: PUSH
57677: EMPTY
57678: ST_TO_ADDR
// end ;
57679: LD_VAR 0 1
57683: RET
// export function MC_Kill ( base ) ; begin
57684: LD_INT 0
57686: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57687: LD_ADDR_EXP 59
57691: PUSH
57692: LD_EXP 59
57696: PPUSH
57697: LD_VAR 0 1
57701: PPUSH
57702: EMPTY
57703: PPUSH
57704: CALL_OW 1
57708: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57709: LD_ADDR_EXP 60
57713: PUSH
57714: LD_EXP 60
57718: PPUSH
57719: LD_VAR 0 1
57723: PPUSH
57724: EMPTY
57725: PPUSH
57726: CALL_OW 1
57730: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57731: LD_ADDR_EXP 61
57735: PUSH
57736: LD_EXP 61
57740: PPUSH
57741: LD_VAR 0 1
57745: PPUSH
57746: EMPTY
57747: PPUSH
57748: CALL_OW 1
57752: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57753: LD_ADDR_EXP 62
57757: PUSH
57758: LD_EXP 62
57762: PPUSH
57763: LD_VAR 0 1
57767: PPUSH
57768: EMPTY
57769: PPUSH
57770: CALL_OW 1
57774: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57775: LD_ADDR_EXP 63
57779: PUSH
57780: LD_EXP 63
57784: PPUSH
57785: LD_VAR 0 1
57789: PPUSH
57790: EMPTY
57791: PPUSH
57792: CALL_OW 1
57796: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57797: LD_ADDR_EXP 64
57801: PUSH
57802: LD_EXP 64
57806: PPUSH
57807: LD_VAR 0 1
57811: PPUSH
57812: EMPTY
57813: PPUSH
57814: CALL_OW 1
57818: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57819: LD_ADDR_EXP 65
57823: PUSH
57824: LD_EXP 65
57828: PPUSH
57829: LD_VAR 0 1
57833: PPUSH
57834: EMPTY
57835: PPUSH
57836: CALL_OW 1
57840: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57841: LD_ADDR_EXP 66
57845: PUSH
57846: LD_EXP 66
57850: PPUSH
57851: LD_VAR 0 1
57855: PPUSH
57856: EMPTY
57857: PPUSH
57858: CALL_OW 1
57862: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57863: LD_ADDR_EXP 67
57867: PUSH
57868: LD_EXP 67
57872: PPUSH
57873: LD_VAR 0 1
57877: PPUSH
57878: EMPTY
57879: PPUSH
57880: CALL_OW 1
57884: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57885: LD_ADDR_EXP 68
57889: PUSH
57890: LD_EXP 68
57894: PPUSH
57895: LD_VAR 0 1
57899: PPUSH
57900: EMPTY
57901: PPUSH
57902: CALL_OW 1
57906: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57907: LD_ADDR_EXP 69
57911: PUSH
57912: LD_EXP 69
57916: PPUSH
57917: LD_VAR 0 1
57921: PPUSH
57922: EMPTY
57923: PPUSH
57924: CALL_OW 1
57928: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57929: LD_ADDR_EXP 70
57933: PUSH
57934: LD_EXP 70
57938: PPUSH
57939: LD_VAR 0 1
57943: PPUSH
57944: LD_INT 0
57946: PPUSH
57947: CALL_OW 1
57951: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57952: LD_ADDR_EXP 71
57956: PUSH
57957: LD_EXP 71
57961: PPUSH
57962: LD_VAR 0 1
57966: PPUSH
57967: EMPTY
57968: PPUSH
57969: CALL_OW 1
57973: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57974: LD_ADDR_EXP 72
57978: PUSH
57979: LD_EXP 72
57983: PPUSH
57984: LD_VAR 0 1
57988: PPUSH
57989: EMPTY
57990: PPUSH
57991: CALL_OW 1
57995: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57996: LD_ADDR_EXP 73
58000: PUSH
58001: LD_EXP 73
58005: PPUSH
58006: LD_VAR 0 1
58010: PPUSH
58011: EMPTY
58012: PPUSH
58013: CALL_OW 1
58017: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58018: LD_ADDR_EXP 74
58022: PUSH
58023: LD_EXP 74
58027: PPUSH
58028: LD_VAR 0 1
58032: PPUSH
58033: EMPTY
58034: PPUSH
58035: CALL_OW 1
58039: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58040: LD_ADDR_EXP 75
58044: PUSH
58045: LD_EXP 75
58049: PPUSH
58050: LD_VAR 0 1
58054: PPUSH
58055: EMPTY
58056: PPUSH
58057: CALL_OW 1
58061: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58062: LD_ADDR_EXP 76
58066: PUSH
58067: LD_EXP 76
58071: PPUSH
58072: LD_VAR 0 1
58076: PPUSH
58077: EMPTY
58078: PPUSH
58079: CALL_OW 1
58083: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58084: LD_ADDR_EXP 77
58088: PUSH
58089: LD_EXP 77
58093: PPUSH
58094: LD_VAR 0 1
58098: PPUSH
58099: EMPTY
58100: PPUSH
58101: CALL_OW 1
58105: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58106: LD_ADDR_EXP 78
58110: PUSH
58111: LD_EXP 78
58115: PPUSH
58116: LD_VAR 0 1
58120: PPUSH
58121: EMPTY
58122: PPUSH
58123: CALL_OW 1
58127: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58128: LD_ADDR_EXP 79
58132: PUSH
58133: LD_EXP 79
58137: PPUSH
58138: LD_VAR 0 1
58142: PPUSH
58143: EMPTY
58144: PPUSH
58145: CALL_OW 1
58149: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58150: LD_ADDR_EXP 80
58154: PUSH
58155: LD_EXP 80
58159: PPUSH
58160: LD_VAR 0 1
58164: PPUSH
58165: EMPTY
58166: PPUSH
58167: CALL_OW 1
58171: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58172: LD_ADDR_EXP 81
58176: PUSH
58177: LD_EXP 81
58181: PPUSH
58182: LD_VAR 0 1
58186: PPUSH
58187: EMPTY
58188: PPUSH
58189: CALL_OW 1
58193: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58194: LD_ADDR_EXP 82
58198: PUSH
58199: LD_EXP 82
58203: PPUSH
58204: LD_VAR 0 1
58208: PPUSH
58209: EMPTY
58210: PPUSH
58211: CALL_OW 1
58215: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58216: LD_ADDR_EXP 83
58220: PUSH
58221: LD_EXP 83
58225: PPUSH
58226: LD_VAR 0 1
58230: PPUSH
58231: EMPTY
58232: PPUSH
58233: CALL_OW 1
58237: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58238: LD_ADDR_EXP 84
58242: PUSH
58243: LD_EXP 84
58247: PPUSH
58248: LD_VAR 0 1
58252: PPUSH
58253: EMPTY
58254: PPUSH
58255: CALL_OW 1
58259: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58260: LD_ADDR_EXP 86
58264: PUSH
58265: LD_EXP 86
58269: PPUSH
58270: LD_VAR 0 1
58274: PPUSH
58275: EMPTY
58276: PPUSH
58277: CALL_OW 1
58281: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58282: LD_ADDR_EXP 88
58286: PUSH
58287: LD_EXP 88
58291: PPUSH
58292: LD_VAR 0 1
58296: PPUSH
58297: EMPTY
58298: PPUSH
58299: CALL_OW 1
58303: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58304: LD_ADDR_EXP 89
58308: PUSH
58309: LD_EXP 89
58313: PPUSH
58314: LD_VAR 0 1
58318: PPUSH
58319: EMPTY
58320: PPUSH
58321: CALL_OW 1
58325: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58326: LD_ADDR_EXP 90
58330: PUSH
58331: LD_EXP 90
58335: PPUSH
58336: LD_VAR 0 1
58340: PPUSH
58341: EMPTY
58342: PPUSH
58343: CALL_OW 1
58347: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58348: LD_ADDR_EXP 91
58352: PUSH
58353: LD_EXP 91
58357: PPUSH
58358: LD_VAR 0 1
58362: PPUSH
58363: EMPTY
58364: PPUSH
58365: CALL_OW 1
58369: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58370: LD_ADDR_EXP 92
58374: PUSH
58375: LD_EXP 92
58379: PPUSH
58380: LD_VAR 0 1
58384: PPUSH
58385: EMPTY
58386: PPUSH
58387: CALL_OW 1
58391: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58392: LD_ADDR_EXP 93
58396: PUSH
58397: LD_EXP 93
58401: PPUSH
58402: LD_VAR 0 1
58406: PPUSH
58407: EMPTY
58408: PPUSH
58409: CALL_OW 1
58413: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58414: LD_ADDR_EXP 94
58418: PUSH
58419: LD_EXP 94
58423: PPUSH
58424: LD_VAR 0 1
58428: PPUSH
58429: EMPTY
58430: PPUSH
58431: CALL_OW 1
58435: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58436: LD_ADDR_EXP 95
58440: PUSH
58441: LD_EXP 95
58445: PPUSH
58446: LD_VAR 0 1
58450: PPUSH
58451: EMPTY
58452: PPUSH
58453: CALL_OW 1
58457: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58458: LD_ADDR_EXP 96
58462: PUSH
58463: LD_EXP 96
58467: PPUSH
58468: LD_VAR 0 1
58472: PPUSH
58473: EMPTY
58474: PPUSH
58475: CALL_OW 1
58479: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58480: LD_ADDR_EXP 97
58484: PUSH
58485: LD_EXP 97
58489: PPUSH
58490: LD_VAR 0 1
58494: PPUSH
58495: EMPTY
58496: PPUSH
58497: CALL_OW 1
58501: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58502: LD_ADDR_EXP 98
58506: PUSH
58507: LD_EXP 98
58511: PPUSH
58512: LD_VAR 0 1
58516: PPUSH
58517: EMPTY
58518: PPUSH
58519: CALL_OW 1
58523: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58524: LD_ADDR_EXP 99
58528: PUSH
58529: LD_EXP 99
58533: PPUSH
58534: LD_VAR 0 1
58538: PPUSH
58539: EMPTY
58540: PPUSH
58541: CALL_OW 1
58545: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58546: LD_ADDR_EXP 100
58550: PUSH
58551: LD_EXP 100
58555: PPUSH
58556: LD_VAR 0 1
58560: PPUSH
58561: EMPTY
58562: PPUSH
58563: CALL_OW 1
58567: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58568: LD_ADDR_EXP 101
58572: PUSH
58573: LD_EXP 101
58577: PPUSH
58578: LD_VAR 0 1
58582: PPUSH
58583: LD_INT 0
58585: PPUSH
58586: CALL_OW 1
58590: ST_TO_ADDR
// end ;
58591: LD_VAR 0 2
58595: RET
// export function MC_Add ( side , units ) ; var base ; begin
58596: LD_INT 0
58598: PPUSH
58599: PPUSH
// base := mc_bases + 1 ;
58600: LD_ADDR_VAR 0 4
58604: PUSH
58605: LD_EXP 59
58609: PUSH
58610: LD_INT 1
58612: PLUS
58613: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
58614: LD_ADDR_EXP 85
58618: PUSH
58619: LD_EXP 85
58623: PPUSH
58624: LD_VAR 0 4
58628: PPUSH
58629: LD_VAR 0 1
58633: PPUSH
58634: CALL_OW 1
58638: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
58639: LD_ADDR_EXP 59
58643: PUSH
58644: LD_EXP 59
58648: PPUSH
58649: LD_VAR 0 4
58653: PPUSH
58654: LD_VAR 0 2
58658: PPUSH
58659: CALL_OW 1
58663: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58664: LD_ADDR_EXP 60
58668: PUSH
58669: LD_EXP 60
58673: PPUSH
58674: LD_VAR 0 4
58678: PPUSH
58679: EMPTY
58680: PPUSH
58681: CALL_OW 1
58685: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58686: LD_ADDR_EXP 61
58690: PUSH
58691: LD_EXP 61
58695: PPUSH
58696: LD_VAR 0 4
58700: PPUSH
58701: EMPTY
58702: PPUSH
58703: CALL_OW 1
58707: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58708: LD_ADDR_EXP 62
58712: PUSH
58713: LD_EXP 62
58717: PPUSH
58718: LD_VAR 0 4
58722: PPUSH
58723: EMPTY
58724: PPUSH
58725: CALL_OW 1
58729: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58730: LD_ADDR_EXP 63
58734: PUSH
58735: LD_EXP 63
58739: PPUSH
58740: LD_VAR 0 4
58744: PPUSH
58745: EMPTY
58746: PPUSH
58747: CALL_OW 1
58751: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58752: LD_ADDR_EXP 64
58756: PUSH
58757: LD_EXP 64
58761: PPUSH
58762: LD_VAR 0 4
58766: PPUSH
58767: EMPTY
58768: PPUSH
58769: CALL_OW 1
58773: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58774: LD_ADDR_EXP 65
58778: PUSH
58779: LD_EXP 65
58783: PPUSH
58784: LD_VAR 0 4
58788: PPUSH
58789: EMPTY
58790: PPUSH
58791: CALL_OW 1
58795: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58796: LD_ADDR_EXP 66
58800: PUSH
58801: LD_EXP 66
58805: PPUSH
58806: LD_VAR 0 4
58810: PPUSH
58811: EMPTY
58812: PPUSH
58813: CALL_OW 1
58817: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58818: LD_ADDR_EXP 67
58822: PUSH
58823: LD_EXP 67
58827: PPUSH
58828: LD_VAR 0 4
58832: PPUSH
58833: EMPTY
58834: PPUSH
58835: CALL_OW 1
58839: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58840: LD_ADDR_EXP 68
58844: PUSH
58845: LD_EXP 68
58849: PPUSH
58850: LD_VAR 0 4
58854: PPUSH
58855: EMPTY
58856: PPUSH
58857: CALL_OW 1
58861: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58862: LD_ADDR_EXP 69
58866: PUSH
58867: LD_EXP 69
58871: PPUSH
58872: LD_VAR 0 4
58876: PPUSH
58877: EMPTY
58878: PPUSH
58879: CALL_OW 1
58883: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58884: LD_ADDR_EXP 70
58888: PUSH
58889: LD_EXP 70
58893: PPUSH
58894: LD_VAR 0 4
58898: PPUSH
58899: LD_INT 0
58901: PPUSH
58902: CALL_OW 1
58906: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58907: LD_ADDR_EXP 71
58911: PUSH
58912: LD_EXP 71
58916: PPUSH
58917: LD_VAR 0 4
58921: PPUSH
58922: EMPTY
58923: PPUSH
58924: CALL_OW 1
58928: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58929: LD_ADDR_EXP 72
58933: PUSH
58934: LD_EXP 72
58938: PPUSH
58939: LD_VAR 0 4
58943: PPUSH
58944: EMPTY
58945: PPUSH
58946: CALL_OW 1
58950: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58951: LD_ADDR_EXP 73
58955: PUSH
58956: LD_EXP 73
58960: PPUSH
58961: LD_VAR 0 4
58965: PPUSH
58966: EMPTY
58967: PPUSH
58968: CALL_OW 1
58972: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58973: LD_ADDR_EXP 74
58977: PUSH
58978: LD_EXP 74
58982: PPUSH
58983: LD_VAR 0 4
58987: PPUSH
58988: EMPTY
58989: PPUSH
58990: CALL_OW 1
58994: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58995: LD_ADDR_EXP 75
58999: PUSH
59000: LD_EXP 75
59004: PPUSH
59005: LD_VAR 0 4
59009: PPUSH
59010: EMPTY
59011: PPUSH
59012: CALL_OW 1
59016: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
59017: LD_ADDR_EXP 76
59021: PUSH
59022: LD_EXP 76
59026: PPUSH
59027: LD_VAR 0 4
59031: PPUSH
59032: EMPTY
59033: PPUSH
59034: CALL_OW 1
59038: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
59039: LD_ADDR_EXP 77
59043: PUSH
59044: LD_EXP 77
59048: PPUSH
59049: LD_VAR 0 4
59053: PPUSH
59054: EMPTY
59055: PPUSH
59056: CALL_OW 1
59060: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
59061: LD_ADDR_EXP 78
59065: PUSH
59066: LD_EXP 78
59070: PPUSH
59071: LD_VAR 0 4
59075: PPUSH
59076: EMPTY
59077: PPUSH
59078: CALL_OW 1
59082: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
59083: LD_ADDR_EXP 79
59087: PUSH
59088: LD_EXP 79
59092: PPUSH
59093: LD_VAR 0 4
59097: PPUSH
59098: EMPTY
59099: PPUSH
59100: CALL_OW 1
59104: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
59105: LD_ADDR_EXP 80
59109: PUSH
59110: LD_EXP 80
59114: PPUSH
59115: LD_VAR 0 4
59119: PPUSH
59120: EMPTY
59121: PPUSH
59122: CALL_OW 1
59126: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
59127: LD_ADDR_EXP 81
59131: PUSH
59132: LD_EXP 81
59136: PPUSH
59137: LD_VAR 0 4
59141: PPUSH
59142: EMPTY
59143: PPUSH
59144: CALL_OW 1
59148: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
59149: LD_ADDR_EXP 82
59153: PUSH
59154: LD_EXP 82
59158: PPUSH
59159: LD_VAR 0 4
59163: PPUSH
59164: EMPTY
59165: PPUSH
59166: CALL_OW 1
59170: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
59171: LD_ADDR_EXP 83
59175: PUSH
59176: LD_EXP 83
59180: PPUSH
59181: LD_VAR 0 4
59185: PPUSH
59186: EMPTY
59187: PPUSH
59188: CALL_OW 1
59192: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
59193: LD_ADDR_EXP 84
59197: PUSH
59198: LD_EXP 84
59202: PPUSH
59203: LD_VAR 0 4
59207: PPUSH
59208: EMPTY
59209: PPUSH
59210: CALL_OW 1
59214: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
59215: LD_ADDR_EXP 86
59219: PUSH
59220: LD_EXP 86
59224: PPUSH
59225: LD_VAR 0 4
59229: PPUSH
59230: EMPTY
59231: PPUSH
59232: CALL_OW 1
59236: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
59237: LD_ADDR_EXP 88
59241: PUSH
59242: LD_EXP 88
59246: PPUSH
59247: LD_VAR 0 4
59251: PPUSH
59252: EMPTY
59253: PPUSH
59254: CALL_OW 1
59258: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
59259: LD_ADDR_EXP 89
59263: PUSH
59264: LD_EXP 89
59268: PPUSH
59269: LD_VAR 0 4
59273: PPUSH
59274: EMPTY
59275: PPUSH
59276: CALL_OW 1
59280: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
59281: LD_ADDR_EXP 90
59285: PUSH
59286: LD_EXP 90
59290: PPUSH
59291: LD_VAR 0 4
59295: PPUSH
59296: EMPTY
59297: PPUSH
59298: CALL_OW 1
59302: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
59303: LD_ADDR_EXP 91
59307: PUSH
59308: LD_EXP 91
59312: PPUSH
59313: LD_VAR 0 4
59317: PPUSH
59318: EMPTY
59319: PPUSH
59320: CALL_OW 1
59324: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
59325: LD_ADDR_EXP 92
59329: PUSH
59330: LD_EXP 92
59334: PPUSH
59335: LD_VAR 0 4
59339: PPUSH
59340: EMPTY
59341: PPUSH
59342: CALL_OW 1
59346: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
59347: LD_ADDR_EXP 93
59351: PUSH
59352: LD_EXP 93
59356: PPUSH
59357: LD_VAR 0 4
59361: PPUSH
59362: EMPTY
59363: PPUSH
59364: CALL_OW 1
59368: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
59369: LD_ADDR_EXP 94
59373: PUSH
59374: LD_EXP 94
59378: PPUSH
59379: LD_VAR 0 4
59383: PPUSH
59384: EMPTY
59385: PPUSH
59386: CALL_OW 1
59390: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
59391: LD_ADDR_EXP 95
59395: PUSH
59396: LD_EXP 95
59400: PPUSH
59401: LD_VAR 0 4
59405: PPUSH
59406: EMPTY
59407: PPUSH
59408: CALL_OW 1
59412: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
59413: LD_ADDR_EXP 96
59417: PUSH
59418: LD_EXP 96
59422: PPUSH
59423: LD_VAR 0 4
59427: PPUSH
59428: EMPTY
59429: PPUSH
59430: CALL_OW 1
59434: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
59435: LD_ADDR_EXP 97
59439: PUSH
59440: LD_EXP 97
59444: PPUSH
59445: LD_VAR 0 4
59449: PPUSH
59450: EMPTY
59451: PPUSH
59452: CALL_OW 1
59456: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
59457: LD_ADDR_EXP 98
59461: PUSH
59462: LD_EXP 98
59466: PPUSH
59467: LD_VAR 0 4
59471: PPUSH
59472: EMPTY
59473: PPUSH
59474: CALL_OW 1
59478: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59479: LD_ADDR_EXP 99
59483: PUSH
59484: LD_EXP 99
59488: PPUSH
59489: LD_VAR 0 4
59493: PPUSH
59494: EMPTY
59495: PPUSH
59496: CALL_OW 1
59500: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59501: LD_ADDR_EXP 100
59505: PUSH
59506: LD_EXP 100
59510: PPUSH
59511: LD_VAR 0 4
59515: PPUSH
59516: EMPTY
59517: PPUSH
59518: CALL_OW 1
59522: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59523: LD_ADDR_EXP 101
59527: PUSH
59528: LD_EXP 101
59532: PPUSH
59533: LD_VAR 0 4
59537: PPUSH
59538: LD_INT 0
59540: PPUSH
59541: CALL_OW 1
59545: ST_TO_ADDR
// result := base ;
59546: LD_ADDR_VAR 0 3
59550: PUSH
59551: LD_VAR 0 4
59555: ST_TO_ADDR
// end ;
59556: LD_VAR 0 3
59560: RET
// export function MC_Start ( ) ; var i ; begin
59561: LD_INT 0
59563: PPUSH
59564: PPUSH
// for i = 1 to mc_bases do
59565: LD_ADDR_VAR 0 2
59569: PUSH
59570: DOUBLE
59571: LD_INT 1
59573: DEC
59574: ST_TO_ADDR
59575: LD_EXP 59
59579: PUSH
59580: FOR_TO
59581: IFFALSE 60658
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
59583: LD_ADDR_EXP 59
59587: PUSH
59588: LD_EXP 59
59592: PPUSH
59593: LD_VAR 0 2
59597: PPUSH
59598: LD_EXP 59
59602: PUSH
59603: LD_VAR 0 2
59607: ARRAY
59608: PUSH
59609: LD_INT 0
59611: DIFF
59612: PPUSH
59613: CALL_OW 1
59617: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
59618: LD_ADDR_EXP 60
59622: PUSH
59623: LD_EXP 60
59627: PPUSH
59628: LD_VAR 0 2
59632: PPUSH
59633: EMPTY
59634: PPUSH
59635: CALL_OW 1
59639: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59640: LD_ADDR_EXP 61
59644: PUSH
59645: LD_EXP 61
59649: PPUSH
59650: LD_VAR 0 2
59654: PPUSH
59655: EMPTY
59656: PPUSH
59657: CALL_OW 1
59661: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
59662: LD_ADDR_EXP 62
59666: PUSH
59667: LD_EXP 62
59671: PPUSH
59672: LD_VAR 0 2
59676: PPUSH
59677: EMPTY
59678: PPUSH
59679: CALL_OW 1
59683: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
59684: LD_ADDR_EXP 63
59688: PUSH
59689: LD_EXP 63
59693: PPUSH
59694: LD_VAR 0 2
59698: PPUSH
59699: EMPTY
59700: PUSH
59701: EMPTY
59702: PUSH
59703: EMPTY
59704: LIST
59705: LIST
59706: PPUSH
59707: CALL_OW 1
59711: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59712: LD_ADDR_EXP 64
59716: PUSH
59717: LD_EXP 64
59721: PPUSH
59722: LD_VAR 0 2
59726: PPUSH
59727: EMPTY
59728: PPUSH
59729: CALL_OW 1
59733: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59734: LD_ADDR_EXP 91
59738: PUSH
59739: LD_EXP 91
59743: PPUSH
59744: LD_VAR 0 2
59748: PPUSH
59749: EMPTY
59750: PPUSH
59751: CALL_OW 1
59755: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59756: LD_ADDR_EXP 65
59760: PUSH
59761: LD_EXP 65
59765: PPUSH
59766: LD_VAR 0 2
59770: PPUSH
59771: EMPTY
59772: PPUSH
59773: CALL_OW 1
59777: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59778: LD_ADDR_EXP 66
59782: PUSH
59783: LD_EXP 66
59787: PPUSH
59788: LD_VAR 0 2
59792: PPUSH
59793: EMPTY
59794: PPUSH
59795: CALL_OW 1
59799: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59800: LD_ADDR_EXP 67
59804: PUSH
59805: LD_EXP 67
59809: PPUSH
59810: LD_VAR 0 2
59814: PPUSH
59815: LD_EXP 59
59819: PUSH
59820: LD_VAR 0 2
59824: ARRAY
59825: PPUSH
59826: LD_INT 2
59828: PUSH
59829: LD_INT 30
59831: PUSH
59832: LD_INT 32
59834: PUSH
59835: EMPTY
59836: LIST
59837: LIST
59838: PUSH
59839: LD_INT 30
59841: PUSH
59842: LD_INT 33
59844: PUSH
59845: EMPTY
59846: LIST
59847: LIST
59848: PUSH
59849: EMPTY
59850: LIST
59851: LIST
59852: LIST
59853: PPUSH
59854: CALL_OW 72
59858: PPUSH
59859: CALL_OW 1
59863: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59864: LD_ADDR_EXP 68
59868: PUSH
59869: LD_EXP 68
59873: PPUSH
59874: LD_VAR 0 2
59878: PPUSH
59879: LD_EXP 59
59883: PUSH
59884: LD_VAR 0 2
59888: ARRAY
59889: PPUSH
59890: LD_INT 2
59892: PUSH
59893: LD_INT 30
59895: PUSH
59896: LD_INT 32
59898: PUSH
59899: EMPTY
59900: LIST
59901: LIST
59902: PUSH
59903: LD_INT 30
59905: PUSH
59906: LD_INT 31
59908: PUSH
59909: EMPTY
59910: LIST
59911: LIST
59912: PUSH
59913: EMPTY
59914: LIST
59915: LIST
59916: LIST
59917: PUSH
59918: LD_INT 58
59920: PUSH
59921: EMPTY
59922: LIST
59923: PUSH
59924: EMPTY
59925: LIST
59926: LIST
59927: PPUSH
59928: CALL_OW 72
59932: PPUSH
59933: CALL_OW 1
59937: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
59938: LD_ADDR_EXP 69
59942: PUSH
59943: LD_EXP 69
59947: PPUSH
59948: LD_VAR 0 2
59952: PPUSH
59953: EMPTY
59954: PPUSH
59955: CALL_OW 1
59959: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
59960: LD_ADDR_EXP 73
59964: PUSH
59965: LD_EXP 73
59969: PPUSH
59970: LD_VAR 0 2
59974: PPUSH
59975: EMPTY
59976: PPUSH
59977: CALL_OW 1
59981: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59982: LD_ADDR_EXP 72
59986: PUSH
59987: LD_EXP 72
59991: PPUSH
59992: LD_VAR 0 2
59996: PPUSH
59997: EMPTY
59998: PPUSH
59999: CALL_OW 1
60003: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
60004: LD_ADDR_EXP 74
60008: PUSH
60009: LD_EXP 74
60013: PPUSH
60014: LD_VAR 0 2
60018: PPUSH
60019: EMPTY
60020: PPUSH
60021: CALL_OW 1
60025: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
60026: LD_ADDR_EXP 75
60030: PUSH
60031: LD_EXP 75
60035: PPUSH
60036: LD_VAR 0 2
60040: PPUSH
60041: EMPTY
60042: PPUSH
60043: CALL_OW 1
60047: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60048: LD_ADDR_EXP 76
60052: PUSH
60053: LD_EXP 76
60057: PPUSH
60058: LD_VAR 0 2
60062: PPUSH
60063: EMPTY
60064: PPUSH
60065: CALL_OW 1
60069: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
60070: LD_ADDR_EXP 77
60074: PUSH
60075: LD_EXP 77
60079: PPUSH
60080: LD_VAR 0 2
60084: PPUSH
60085: EMPTY
60086: PPUSH
60087: CALL_OW 1
60091: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
60092: LD_ADDR_EXP 78
60096: PUSH
60097: LD_EXP 78
60101: PPUSH
60102: LD_VAR 0 2
60106: PPUSH
60107: EMPTY
60108: PPUSH
60109: CALL_OW 1
60113: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
60114: LD_ADDR_EXP 79
60118: PUSH
60119: LD_EXP 79
60123: PPUSH
60124: LD_VAR 0 2
60128: PPUSH
60129: EMPTY
60130: PPUSH
60131: CALL_OW 1
60135: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
60136: LD_ADDR_EXP 80
60140: PUSH
60141: LD_EXP 80
60145: PPUSH
60146: LD_VAR 0 2
60150: PPUSH
60151: EMPTY
60152: PPUSH
60153: CALL_OW 1
60157: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
60158: LD_ADDR_EXP 81
60162: PUSH
60163: LD_EXP 81
60167: PPUSH
60168: LD_VAR 0 2
60172: PPUSH
60173: EMPTY
60174: PPUSH
60175: CALL_OW 1
60179: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
60180: LD_ADDR_EXP 70
60184: PUSH
60185: LD_EXP 70
60189: PPUSH
60190: LD_VAR 0 2
60194: PPUSH
60195: LD_INT 0
60197: PPUSH
60198: CALL_OW 1
60202: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
60203: LD_ADDR_EXP 83
60207: PUSH
60208: LD_EXP 83
60212: PPUSH
60213: LD_VAR 0 2
60217: PPUSH
60218: LD_INT 0
60220: PPUSH
60221: CALL_OW 1
60225: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
60226: LD_ADDR_EXP 71
60230: PUSH
60231: LD_EXP 71
60235: PPUSH
60236: LD_VAR 0 2
60240: PPUSH
60241: EMPTY
60242: PPUSH
60243: CALL_OW 1
60247: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
60248: LD_ADDR_EXP 82
60252: PUSH
60253: LD_EXP 82
60257: PPUSH
60258: LD_VAR 0 2
60262: PPUSH
60263: LD_INT 0
60265: PPUSH
60266: CALL_OW 1
60270: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
60271: LD_ADDR_EXP 84
60275: PUSH
60276: LD_EXP 84
60280: PPUSH
60281: LD_VAR 0 2
60285: PPUSH
60286: EMPTY
60287: PPUSH
60288: CALL_OW 1
60292: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
60293: LD_ADDR_EXP 87
60297: PUSH
60298: LD_EXP 87
60302: PPUSH
60303: LD_VAR 0 2
60307: PPUSH
60308: LD_INT 0
60310: PPUSH
60311: CALL_OW 1
60315: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
60316: LD_ADDR_EXP 88
60320: PUSH
60321: LD_EXP 88
60325: PPUSH
60326: LD_VAR 0 2
60330: PPUSH
60331: EMPTY
60332: PPUSH
60333: CALL_OW 1
60337: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60338: LD_ADDR_EXP 89
60342: PUSH
60343: LD_EXP 89
60347: PPUSH
60348: LD_VAR 0 2
60352: PPUSH
60353: EMPTY
60354: PPUSH
60355: CALL_OW 1
60359: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60360: LD_ADDR_EXP 90
60364: PUSH
60365: LD_EXP 90
60369: PPUSH
60370: LD_VAR 0 2
60374: PPUSH
60375: EMPTY
60376: PPUSH
60377: CALL_OW 1
60381: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
60382: LD_ADDR_EXP 92
60386: PUSH
60387: LD_EXP 92
60391: PPUSH
60392: LD_VAR 0 2
60396: PPUSH
60397: LD_EXP 59
60401: PUSH
60402: LD_VAR 0 2
60406: ARRAY
60407: PPUSH
60408: LD_INT 2
60410: PUSH
60411: LD_INT 30
60413: PUSH
60414: LD_INT 6
60416: PUSH
60417: EMPTY
60418: LIST
60419: LIST
60420: PUSH
60421: LD_INT 30
60423: PUSH
60424: LD_INT 7
60426: PUSH
60427: EMPTY
60428: LIST
60429: LIST
60430: PUSH
60431: LD_INT 30
60433: PUSH
60434: LD_INT 8
60436: PUSH
60437: EMPTY
60438: LIST
60439: LIST
60440: PUSH
60441: EMPTY
60442: LIST
60443: LIST
60444: LIST
60445: LIST
60446: PPUSH
60447: CALL_OW 72
60451: PPUSH
60452: CALL_OW 1
60456: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
60457: LD_ADDR_EXP 93
60461: PUSH
60462: LD_EXP 93
60466: PPUSH
60467: LD_VAR 0 2
60471: PPUSH
60472: EMPTY
60473: PPUSH
60474: CALL_OW 1
60478: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
60479: LD_ADDR_EXP 94
60483: PUSH
60484: LD_EXP 94
60488: PPUSH
60489: LD_VAR 0 2
60493: PPUSH
60494: EMPTY
60495: PPUSH
60496: CALL_OW 1
60500: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
60501: LD_ADDR_EXP 95
60505: PUSH
60506: LD_EXP 95
60510: PPUSH
60511: LD_VAR 0 2
60515: PPUSH
60516: EMPTY
60517: PPUSH
60518: CALL_OW 1
60522: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
60523: LD_ADDR_EXP 96
60527: PUSH
60528: LD_EXP 96
60532: PPUSH
60533: LD_VAR 0 2
60537: PPUSH
60538: EMPTY
60539: PPUSH
60540: CALL_OW 1
60544: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60545: LD_ADDR_EXP 97
60549: PUSH
60550: LD_EXP 97
60554: PPUSH
60555: LD_VAR 0 2
60559: PPUSH
60560: EMPTY
60561: PPUSH
60562: CALL_OW 1
60566: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
60567: LD_ADDR_EXP 98
60571: PUSH
60572: LD_EXP 98
60576: PPUSH
60577: LD_VAR 0 2
60581: PPUSH
60582: EMPTY
60583: PPUSH
60584: CALL_OW 1
60588: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
60589: LD_ADDR_EXP 99
60593: PUSH
60594: LD_EXP 99
60598: PPUSH
60599: LD_VAR 0 2
60603: PPUSH
60604: EMPTY
60605: PPUSH
60606: CALL_OW 1
60610: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
60611: LD_ADDR_EXP 100
60615: PUSH
60616: LD_EXP 100
60620: PPUSH
60621: LD_VAR 0 2
60625: PPUSH
60626: EMPTY
60627: PPUSH
60628: CALL_OW 1
60632: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
60633: LD_ADDR_EXP 101
60637: PUSH
60638: LD_EXP 101
60642: PPUSH
60643: LD_VAR 0 2
60647: PPUSH
60648: LD_INT 0
60650: PPUSH
60651: CALL_OW 1
60655: ST_TO_ADDR
// end ;
60656: GO 59580
60658: POP
60659: POP
// MC_InitSides ( ) ;
60660: CALL 60946 0 0
// MC_InitResearch ( ) ;
60664: CALL 60685 0 0
// CustomInitMacro ( ) ;
60668: CALL 181 0 0
// skirmish := true ;
60672: LD_ADDR_EXP 57
60676: PUSH
60677: LD_INT 1
60679: ST_TO_ADDR
// end ;
60680: LD_VAR 0 1
60684: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60685: LD_INT 0
60687: PPUSH
60688: PPUSH
60689: PPUSH
60690: PPUSH
60691: PPUSH
60692: PPUSH
// if not mc_bases then
60693: LD_EXP 59
60697: NOT
60698: IFFALSE 60702
// exit ;
60700: GO 60941
// for i = 1 to 8 do
60702: LD_ADDR_VAR 0 2
60706: PUSH
60707: DOUBLE
60708: LD_INT 1
60710: DEC
60711: ST_TO_ADDR
60712: LD_INT 8
60714: PUSH
60715: FOR_TO
60716: IFFALSE 60742
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60718: LD_ADDR_EXP 86
60722: PUSH
60723: LD_EXP 86
60727: PPUSH
60728: LD_VAR 0 2
60732: PPUSH
60733: EMPTY
60734: PPUSH
60735: CALL_OW 1
60739: ST_TO_ADDR
60740: GO 60715
60742: POP
60743: POP
// tmp := [ ] ;
60744: LD_ADDR_VAR 0 5
60748: PUSH
60749: EMPTY
60750: ST_TO_ADDR
// for i = 1 to mc_sides do
60751: LD_ADDR_VAR 0 2
60755: PUSH
60756: DOUBLE
60757: LD_INT 1
60759: DEC
60760: ST_TO_ADDR
60761: LD_EXP 85
60765: PUSH
60766: FOR_TO
60767: IFFALSE 60825
// if not mc_sides [ i ] in tmp then
60769: LD_EXP 85
60773: PUSH
60774: LD_VAR 0 2
60778: ARRAY
60779: PUSH
60780: LD_VAR 0 5
60784: IN
60785: NOT
60786: IFFALSE 60823
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60788: LD_ADDR_VAR 0 5
60792: PUSH
60793: LD_VAR 0 5
60797: PPUSH
60798: LD_VAR 0 5
60802: PUSH
60803: LD_INT 1
60805: PLUS
60806: PPUSH
60807: LD_EXP 85
60811: PUSH
60812: LD_VAR 0 2
60816: ARRAY
60817: PPUSH
60818: CALL_OW 2
60822: ST_TO_ADDR
60823: GO 60766
60825: POP
60826: POP
// if not tmp then
60827: LD_VAR 0 5
60831: NOT
60832: IFFALSE 60836
// exit ;
60834: GO 60941
// for j in tmp do
60836: LD_ADDR_VAR 0 3
60840: PUSH
60841: LD_VAR 0 5
60845: PUSH
60846: FOR_IN
60847: IFFALSE 60939
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60849: LD_ADDR_VAR 0 6
60853: PUSH
60854: LD_INT 22
60856: PUSH
60857: LD_VAR 0 3
60861: PUSH
60862: EMPTY
60863: LIST
60864: LIST
60865: PPUSH
60866: CALL_OW 69
60870: ST_TO_ADDR
// if not un then
60871: LD_VAR 0 6
60875: NOT
60876: IFFALSE 60880
// continue ;
60878: GO 60846
// nation := GetNation ( un [ 1 ] ) ;
60880: LD_ADDR_VAR 0 4
60884: PUSH
60885: LD_VAR 0 6
60889: PUSH
60890: LD_INT 1
60892: ARRAY
60893: PPUSH
60894: CALL_OW 248
60898: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60899: LD_ADDR_EXP 86
60903: PUSH
60904: LD_EXP 86
60908: PPUSH
60909: LD_VAR 0 3
60913: PPUSH
60914: LD_VAR 0 3
60918: PPUSH
60919: LD_VAR 0 4
60923: PPUSH
60924: LD_INT 1
60926: PPUSH
60927: CALL 14347 0 3
60931: PPUSH
60932: CALL_OW 1
60936: ST_TO_ADDR
// end ;
60937: GO 60846
60939: POP
60940: POP
// end ;
60941: LD_VAR 0 1
60945: RET
// export function MC_InitSides ( ) ; var i ; begin
60946: LD_INT 0
60948: PPUSH
60949: PPUSH
// if not mc_bases then
60950: LD_EXP 59
60954: NOT
60955: IFFALSE 60959
// exit ;
60957: GO 61033
// for i = 1 to mc_bases do
60959: LD_ADDR_VAR 0 2
60963: PUSH
60964: DOUBLE
60965: LD_INT 1
60967: DEC
60968: ST_TO_ADDR
60969: LD_EXP 59
60973: PUSH
60974: FOR_TO
60975: IFFALSE 61031
// if mc_bases [ i ] then
60977: LD_EXP 59
60981: PUSH
60982: LD_VAR 0 2
60986: ARRAY
60987: IFFALSE 61029
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60989: LD_ADDR_EXP 85
60993: PUSH
60994: LD_EXP 85
60998: PPUSH
60999: LD_VAR 0 2
61003: PPUSH
61004: LD_EXP 59
61008: PUSH
61009: LD_VAR 0 2
61013: ARRAY
61014: PUSH
61015: LD_INT 1
61017: ARRAY
61018: PPUSH
61019: CALL_OW 255
61023: PPUSH
61024: CALL_OW 1
61028: ST_TO_ADDR
61029: GO 60974
61031: POP
61032: POP
// end ;
61033: LD_VAR 0 1
61037: RET
// every 0 0$01 trigger skirmish do
61038: LD_EXP 57
61042: IFFALSE 61196
61044: GO 61046
61046: DISABLE
// begin enable ;
61047: ENABLE
// MC_CheckBuildings ( ) ;
61048: CALL 65694 0 0
// MC_CheckPeopleLife ( ) ;
61052: CALL 65819 0 0
// RaiseSailEvent ( 100 ) ;
61056: LD_INT 100
61058: PPUSH
61059: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
61063: LD_INT 103
61065: PPUSH
61066: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
61070: LD_INT 104
61072: PPUSH
61073: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
61077: LD_INT 105
61079: PPUSH
61080: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
61084: LD_INT 106
61086: PPUSH
61087: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
61091: LD_INT 107
61093: PPUSH
61094: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
61098: LD_INT 108
61100: PPUSH
61101: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
61105: LD_INT 109
61107: PPUSH
61108: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
61112: LD_INT 110
61114: PPUSH
61115: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
61119: LD_INT 111
61121: PPUSH
61122: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
61126: LD_INT 112
61128: PPUSH
61129: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
61133: LD_INT 113
61135: PPUSH
61136: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
61140: LD_INT 120
61142: PPUSH
61143: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
61147: LD_INT 121
61149: PPUSH
61150: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
61154: LD_INT 122
61156: PPUSH
61157: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
61161: LD_INT 123
61163: PPUSH
61164: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
61168: LD_INT 124
61170: PPUSH
61171: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
61175: LD_INT 125
61177: PPUSH
61178: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
61182: LD_INT 126
61184: PPUSH
61185: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
61189: LD_INT 200
61191: PPUSH
61192: CALL_OW 427
// end ;
61196: END
// on SailEvent ( event ) do begin if event < 100 then
61197: LD_VAR 0 1
61201: PUSH
61202: LD_INT 100
61204: LESS
61205: IFFALSE 61216
// CustomEvent ( event ) ;
61207: LD_VAR 0 1
61211: PPUSH
61212: CALL 13005 0 1
// if event = 100 then
61216: LD_VAR 0 1
61220: PUSH
61221: LD_INT 100
61223: EQUAL
61224: IFFALSE 61230
// MC_ClassManager ( ) ;
61226: CALL 61622 0 0
// if event = 101 then
61230: LD_VAR 0 1
61234: PUSH
61235: LD_INT 101
61237: EQUAL
61238: IFFALSE 61244
// MC_RepairBuildings ( ) ;
61240: CALL 66415 0 0
// if event = 102 then
61244: LD_VAR 0 1
61248: PUSH
61249: LD_INT 102
61251: EQUAL
61252: IFFALSE 61258
// MC_Heal ( ) ;
61254: CALL 67279 0 0
// if event = 103 then
61258: LD_VAR 0 1
61262: PUSH
61263: LD_INT 103
61265: EQUAL
61266: IFFALSE 61272
// MC_Build ( ) ;
61268: CALL 67701 0 0
// if event = 104 then
61272: LD_VAR 0 1
61276: PUSH
61277: LD_INT 104
61279: EQUAL
61280: IFFALSE 61286
// MC_TurretWeapon ( ) ;
61282: CALL 69314 0 0
// if event = 105 then
61286: LD_VAR 0 1
61290: PUSH
61291: LD_INT 105
61293: EQUAL
61294: IFFALSE 61300
// MC_BuildUpgrade ( ) ;
61296: CALL 68865 0 0
// if event = 106 then
61300: LD_VAR 0 1
61304: PUSH
61305: LD_INT 106
61307: EQUAL
61308: IFFALSE 61314
// MC_PlantMines ( ) ;
61310: CALL 69744 0 0
// if event = 107 then
61314: LD_VAR 0 1
61318: PUSH
61319: LD_INT 107
61321: EQUAL
61322: IFFALSE 61328
// MC_CollectCrates ( ) ;
61324: CALL 70542 0 0
// if event = 108 then
61328: LD_VAR 0 1
61332: PUSH
61333: LD_INT 108
61335: EQUAL
61336: IFFALSE 61342
// MC_LinkRemoteControl ( ) ;
61338: CALL 72318 0 0
// if event = 109 then
61342: LD_VAR 0 1
61346: PUSH
61347: LD_INT 109
61349: EQUAL
61350: IFFALSE 61356
// MC_ProduceVehicle ( ) ;
61352: CALL 72499 0 0
// if event = 110 then
61356: LD_VAR 0 1
61360: PUSH
61361: LD_INT 110
61363: EQUAL
61364: IFFALSE 61370
// MC_SendAttack ( ) ;
61366: CALL 72965 0 0
// if event = 111 then
61370: LD_VAR 0 1
61374: PUSH
61375: LD_INT 111
61377: EQUAL
61378: IFFALSE 61384
// MC_Defend ( ) ;
61380: CALL 73073 0 0
// if event = 112 then
61384: LD_VAR 0 1
61388: PUSH
61389: LD_INT 112
61391: EQUAL
61392: IFFALSE 61398
// MC_Research ( ) ;
61394: CALL 73678 0 0
// if event = 113 then
61398: LD_VAR 0 1
61402: PUSH
61403: LD_INT 113
61405: EQUAL
61406: IFFALSE 61412
// MC_MinesTrigger ( ) ;
61408: CALL 74792 0 0
// if event = 120 then
61412: LD_VAR 0 1
61416: PUSH
61417: LD_INT 120
61419: EQUAL
61420: IFFALSE 61426
// MC_RepairVehicle ( ) ;
61422: CALL 74891 0 0
// if event = 121 then
61426: LD_VAR 0 1
61430: PUSH
61431: LD_INT 121
61433: EQUAL
61434: IFFALSE 61440
// MC_TameApe ( ) ;
61436: CALL 75621 0 0
// if event = 122 then
61440: LD_VAR 0 1
61444: PUSH
61445: LD_INT 122
61447: EQUAL
61448: IFFALSE 61454
// MC_ChangeApeClass ( ) ;
61450: CALL 76450 0 0
// if event = 123 then
61454: LD_VAR 0 1
61458: PUSH
61459: LD_INT 123
61461: EQUAL
61462: IFFALSE 61468
// MC_Bazooka ( ) ;
61464: CALL 77100 0 0
// if event = 124 then
61468: LD_VAR 0 1
61472: PUSH
61473: LD_INT 124
61475: EQUAL
61476: IFFALSE 61482
// MC_TeleportExit ( ) ;
61478: CALL 77298 0 0
// if event = 125 then
61482: LD_VAR 0 1
61486: PUSH
61487: LD_INT 125
61489: EQUAL
61490: IFFALSE 61496
// MC_Deposits ( ) ;
61492: CALL 77945 0 0
// if event = 126 then
61496: LD_VAR 0 1
61500: PUSH
61501: LD_INT 126
61503: EQUAL
61504: IFFALSE 61510
// MC_RemoteDriver ( ) ;
61506: CALL 78570 0 0
// if event = 200 then
61510: LD_VAR 0 1
61514: PUSH
61515: LD_INT 200
61517: EQUAL
61518: IFFALSE 61524
// MC_Idle ( ) ;
61520: CALL 80519 0 0
// end ;
61524: PPOPN 1
61526: END
// export function MC_Reset ( base , tag ) ; var i ; begin
61527: LD_INT 0
61529: PPUSH
61530: PPUSH
// if not mc_bases [ base ] or not tag then
61531: LD_EXP 59
61535: PUSH
61536: LD_VAR 0 1
61540: ARRAY
61541: NOT
61542: PUSH
61543: LD_VAR 0 2
61547: NOT
61548: OR
61549: IFFALSE 61553
// exit ;
61551: GO 61617
// for i in mc_bases [ base ] union mc_ape [ base ] do
61553: LD_ADDR_VAR 0 4
61557: PUSH
61558: LD_EXP 59
61562: PUSH
61563: LD_VAR 0 1
61567: ARRAY
61568: PUSH
61569: LD_EXP 88
61573: PUSH
61574: LD_VAR 0 1
61578: ARRAY
61579: UNION
61580: PUSH
61581: FOR_IN
61582: IFFALSE 61615
// if GetTag ( i ) = tag then
61584: LD_VAR 0 4
61588: PPUSH
61589: CALL_OW 110
61593: PUSH
61594: LD_VAR 0 2
61598: EQUAL
61599: IFFALSE 61613
// SetTag ( i , 0 ) ;
61601: LD_VAR 0 4
61605: PPUSH
61606: LD_INT 0
61608: PPUSH
61609: CALL_OW 109
61613: GO 61581
61615: POP
61616: POP
// end ;
61617: LD_VAR 0 3
61621: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
61622: LD_INT 0
61624: PPUSH
61625: PPUSH
61626: PPUSH
61627: PPUSH
61628: PPUSH
61629: PPUSH
61630: PPUSH
61631: PPUSH
// if not mc_bases then
61632: LD_EXP 59
61636: NOT
61637: IFFALSE 61641
// exit ;
61639: GO 62099
// for i = 1 to mc_bases do
61641: LD_ADDR_VAR 0 2
61645: PUSH
61646: DOUBLE
61647: LD_INT 1
61649: DEC
61650: ST_TO_ADDR
61651: LD_EXP 59
61655: PUSH
61656: FOR_TO
61657: IFFALSE 62097
// begin tmp := MC_ClassCheckReq ( i ) ;
61659: LD_ADDR_VAR 0 4
61663: PUSH
61664: LD_VAR 0 2
61668: PPUSH
61669: CALL 62104 0 1
61673: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
61674: LD_ADDR_EXP 100
61678: PUSH
61679: LD_EXP 100
61683: PPUSH
61684: LD_VAR 0 2
61688: PPUSH
61689: LD_VAR 0 4
61693: PPUSH
61694: CALL_OW 1
61698: ST_TO_ADDR
// if not tmp then
61699: LD_VAR 0 4
61703: NOT
61704: IFFALSE 61708
// continue ;
61706: GO 61656
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61708: LD_ADDR_VAR 0 6
61712: PUSH
61713: LD_EXP 59
61717: PUSH
61718: LD_VAR 0 2
61722: ARRAY
61723: PPUSH
61724: LD_INT 2
61726: PUSH
61727: LD_INT 30
61729: PUSH
61730: LD_INT 4
61732: PUSH
61733: EMPTY
61734: LIST
61735: LIST
61736: PUSH
61737: LD_INT 30
61739: PUSH
61740: LD_INT 5
61742: PUSH
61743: EMPTY
61744: LIST
61745: LIST
61746: PUSH
61747: EMPTY
61748: LIST
61749: LIST
61750: LIST
61751: PPUSH
61752: CALL_OW 72
61756: PUSH
61757: LD_EXP 59
61761: PUSH
61762: LD_VAR 0 2
61766: ARRAY
61767: PPUSH
61768: LD_INT 2
61770: PUSH
61771: LD_INT 30
61773: PUSH
61774: LD_INT 0
61776: PUSH
61777: EMPTY
61778: LIST
61779: LIST
61780: PUSH
61781: LD_INT 30
61783: PUSH
61784: LD_INT 1
61786: PUSH
61787: EMPTY
61788: LIST
61789: LIST
61790: PUSH
61791: EMPTY
61792: LIST
61793: LIST
61794: LIST
61795: PPUSH
61796: CALL_OW 72
61800: PUSH
61801: LD_EXP 59
61805: PUSH
61806: LD_VAR 0 2
61810: ARRAY
61811: PPUSH
61812: LD_INT 30
61814: PUSH
61815: LD_INT 3
61817: PUSH
61818: EMPTY
61819: LIST
61820: LIST
61821: PPUSH
61822: CALL_OW 72
61826: PUSH
61827: LD_EXP 59
61831: PUSH
61832: LD_VAR 0 2
61836: ARRAY
61837: PPUSH
61838: LD_INT 2
61840: PUSH
61841: LD_INT 30
61843: PUSH
61844: LD_INT 6
61846: PUSH
61847: EMPTY
61848: LIST
61849: LIST
61850: PUSH
61851: LD_INT 30
61853: PUSH
61854: LD_INT 7
61856: PUSH
61857: EMPTY
61858: LIST
61859: LIST
61860: PUSH
61861: LD_INT 30
61863: PUSH
61864: LD_INT 8
61866: PUSH
61867: EMPTY
61868: LIST
61869: LIST
61870: PUSH
61871: EMPTY
61872: LIST
61873: LIST
61874: LIST
61875: LIST
61876: PPUSH
61877: CALL_OW 72
61881: PUSH
61882: EMPTY
61883: LIST
61884: LIST
61885: LIST
61886: LIST
61887: ST_TO_ADDR
// for j = 1 to 4 do
61888: LD_ADDR_VAR 0 3
61892: PUSH
61893: DOUBLE
61894: LD_INT 1
61896: DEC
61897: ST_TO_ADDR
61898: LD_INT 4
61900: PUSH
61901: FOR_TO
61902: IFFALSE 62093
// begin if not tmp [ j ] then
61904: LD_VAR 0 4
61908: PUSH
61909: LD_VAR 0 3
61913: ARRAY
61914: NOT
61915: IFFALSE 61919
// continue ;
61917: GO 61901
// for p in tmp [ j ] do
61919: LD_ADDR_VAR 0 5
61923: PUSH
61924: LD_VAR 0 4
61928: PUSH
61929: LD_VAR 0 3
61933: ARRAY
61934: PUSH
61935: FOR_IN
61936: IFFALSE 62089
// begin if not b [ j ] then
61938: LD_VAR 0 6
61942: PUSH
61943: LD_VAR 0 3
61947: ARRAY
61948: NOT
61949: IFFALSE 61953
// break ;
61951: GO 62089
// e := 0 ;
61953: LD_ADDR_VAR 0 7
61957: PUSH
61958: LD_INT 0
61960: ST_TO_ADDR
// for k in b [ j ] do
61961: LD_ADDR_VAR 0 8
61965: PUSH
61966: LD_VAR 0 6
61970: PUSH
61971: LD_VAR 0 3
61975: ARRAY
61976: PUSH
61977: FOR_IN
61978: IFFALSE 62005
// if IsNotFull ( k ) then
61980: LD_VAR 0 8
61984: PPUSH
61985: CALL 18787 0 1
61989: IFFALSE 62003
// begin e := k ;
61991: LD_ADDR_VAR 0 7
61995: PUSH
61996: LD_VAR 0 8
62000: ST_TO_ADDR
// break ;
62001: GO 62005
// end ;
62003: GO 61977
62005: POP
62006: POP
// if e and not UnitGoingToBuilding ( p , e ) then
62007: LD_VAR 0 7
62011: PUSH
62012: LD_VAR 0 5
62016: PPUSH
62017: LD_VAR 0 7
62021: PPUSH
62022: CALL 55909 0 2
62026: NOT
62027: AND
62028: IFFALSE 62087
// begin if IsInUnit ( p ) then
62030: LD_VAR 0 5
62034: PPUSH
62035: CALL_OW 310
62039: IFFALSE 62050
// ComExitBuilding ( p ) ;
62041: LD_VAR 0 5
62045: PPUSH
62046: CALL_OW 122
// ComEnterUnit ( p , e ) ;
62050: LD_VAR 0 5
62054: PPUSH
62055: LD_VAR 0 7
62059: PPUSH
62060: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
62064: LD_VAR 0 5
62068: PPUSH
62069: LD_VAR 0 3
62073: PPUSH
62074: CALL_OW 183
// AddComExitBuilding ( p ) ;
62078: LD_VAR 0 5
62082: PPUSH
62083: CALL_OW 182
// end ; end ;
62087: GO 61935
62089: POP
62090: POP
// end ;
62091: GO 61901
62093: POP
62094: POP
// end ;
62095: GO 61656
62097: POP
62098: POP
// end ;
62099: LD_VAR 0 1
62103: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
62104: LD_INT 0
62106: PPUSH
62107: PPUSH
62108: PPUSH
62109: PPUSH
62110: PPUSH
62111: PPUSH
62112: PPUSH
62113: PPUSH
62114: PPUSH
62115: PPUSH
62116: PPUSH
62117: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62118: LD_VAR 0 1
62122: NOT
62123: PUSH
62124: LD_EXP 59
62128: PUSH
62129: LD_VAR 0 1
62133: ARRAY
62134: NOT
62135: OR
62136: PUSH
62137: LD_EXP 59
62141: PUSH
62142: LD_VAR 0 1
62146: ARRAY
62147: PPUSH
62148: LD_INT 2
62150: PUSH
62151: LD_INT 30
62153: PUSH
62154: LD_INT 0
62156: PUSH
62157: EMPTY
62158: LIST
62159: LIST
62160: PUSH
62161: LD_INT 30
62163: PUSH
62164: LD_INT 1
62166: PUSH
62167: EMPTY
62168: LIST
62169: LIST
62170: PUSH
62171: EMPTY
62172: LIST
62173: LIST
62174: LIST
62175: PPUSH
62176: CALL_OW 72
62180: NOT
62181: OR
62182: IFFALSE 62186
// exit ;
62184: GO 65689
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62186: LD_ADDR_VAR 0 4
62190: PUSH
62191: LD_EXP 59
62195: PUSH
62196: LD_VAR 0 1
62200: ARRAY
62201: PPUSH
62202: LD_INT 2
62204: PUSH
62205: LD_INT 25
62207: PUSH
62208: LD_INT 1
62210: PUSH
62211: EMPTY
62212: LIST
62213: LIST
62214: PUSH
62215: LD_INT 25
62217: PUSH
62218: LD_INT 2
62220: PUSH
62221: EMPTY
62222: LIST
62223: LIST
62224: PUSH
62225: LD_INT 25
62227: PUSH
62228: LD_INT 3
62230: PUSH
62231: EMPTY
62232: LIST
62233: LIST
62234: PUSH
62235: LD_INT 25
62237: PUSH
62238: LD_INT 4
62240: PUSH
62241: EMPTY
62242: LIST
62243: LIST
62244: PUSH
62245: LD_INT 25
62247: PUSH
62248: LD_INT 5
62250: PUSH
62251: EMPTY
62252: LIST
62253: LIST
62254: PUSH
62255: LD_INT 25
62257: PUSH
62258: LD_INT 8
62260: PUSH
62261: EMPTY
62262: LIST
62263: LIST
62264: PUSH
62265: LD_INT 25
62267: PUSH
62268: LD_INT 9
62270: PUSH
62271: EMPTY
62272: LIST
62273: LIST
62274: PUSH
62275: EMPTY
62276: LIST
62277: LIST
62278: LIST
62279: LIST
62280: LIST
62281: LIST
62282: LIST
62283: LIST
62284: PPUSH
62285: CALL_OW 72
62289: ST_TO_ADDR
// if not tmp then
62290: LD_VAR 0 4
62294: NOT
62295: IFFALSE 62299
// exit ;
62297: GO 65689
// for i in tmp do
62299: LD_ADDR_VAR 0 3
62303: PUSH
62304: LD_VAR 0 4
62308: PUSH
62309: FOR_IN
62310: IFFALSE 62341
// if GetTag ( i ) then
62312: LD_VAR 0 3
62316: PPUSH
62317: CALL_OW 110
62321: IFFALSE 62339
// tmp := tmp diff i ;
62323: LD_ADDR_VAR 0 4
62327: PUSH
62328: LD_VAR 0 4
62332: PUSH
62333: LD_VAR 0 3
62337: DIFF
62338: ST_TO_ADDR
62339: GO 62309
62341: POP
62342: POP
// if not tmp then
62343: LD_VAR 0 4
62347: NOT
62348: IFFALSE 62352
// exit ;
62350: GO 65689
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62352: LD_ADDR_VAR 0 5
62356: PUSH
62357: LD_EXP 59
62361: PUSH
62362: LD_VAR 0 1
62366: ARRAY
62367: PPUSH
62368: LD_INT 2
62370: PUSH
62371: LD_INT 25
62373: PUSH
62374: LD_INT 1
62376: PUSH
62377: EMPTY
62378: LIST
62379: LIST
62380: PUSH
62381: LD_INT 25
62383: PUSH
62384: LD_INT 5
62386: PUSH
62387: EMPTY
62388: LIST
62389: LIST
62390: PUSH
62391: LD_INT 25
62393: PUSH
62394: LD_INT 8
62396: PUSH
62397: EMPTY
62398: LIST
62399: LIST
62400: PUSH
62401: LD_INT 25
62403: PUSH
62404: LD_INT 9
62406: PUSH
62407: EMPTY
62408: LIST
62409: LIST
62410: PUSH
62411: EMPTY
62412: LIST
62413: LIST
62414: LIST
62415: LIST
62416: LIST
62417: PPUSH
62418: CALL_OW 72
62422: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
62423: LD_ADDR_VAR 0 6
62427: PUSH
62428: LD_EXP 59
62432: PUSH
62433: LD_VAR 0 1
62437: ARRAY
62438: PPUSH
62439: LD_INT 25
62441: PUSH
62442: LD_INT 2
62444: PUSH
62445: EMPTY
62446: LIST
62447: LIST
62448: PPUSH
62449: CALL_OW 72
62453: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
62454: LD_ADDR_VAR 0 7
62458: PUSH
62459: LD_EXP 59
62463: PUSH
62464: LD_VAR 0 1
62468: ARRAY
62469: PPUSH
62470: LD_INT 25
62472: PUSH
62473: LD_INT 3
62475: PUSH
62476: EMPTY
62477: LIST
62478: LIST
62479: PPUSH
62480: CALL_OW 72
62484: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
62485: LD_ADDR_VAR 0 8
62489: PUSH
62490: LD_EXP 59
62494: PUSH
62495: LD_VAR 0 1
62499: ARRAY
62500: PPUSH
62501: LD_INT 25
62503: PUSH
62504: LD_INT 4
62506: PUSH
62507: EMPTY
62508: LIST
62509: LIST
62510: PUSH
62511: LD_INT 24
62513: PUSH
62514: LD_INT 251
62516: PUSH
62517: EMPTY
62518: LIST
62519: LIST
62520: PUSH
62521: EMPTY
62522: LIST
62523: LIST
62524: PPUSH
62525: CALL_OW 72
62529: ST_TO_ADDR
// if mc_scan [ base ] then
62530: LD_EXP 82
62534: PUSH
62535: LD_VAR 0 1
62539: ARRAY
62540: IFFALSE 63001
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
62542: LD_ADDR_EXP 101
62546: PUSH
62547: LD_EXP 101
62551: PPUSH
62552: LD_VAR 0 1
62556: PPUSH
62557: LD_INT 4
62559: PPUSH
62560: CALL_OW 1
62564: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62565: LD_ADDR_VAR 0 12
62569: PUSH
62570: LD_EXP 59
62574: PUSH
62575: LD_VAR 0 1
62579: ARRAY
62580: PPUSH
62581: LD_INT 2
62583: PUSH
62584: LD_INT 30
62586: PUSH
62587: LD_INT 4
62589: PUSH
62590: EMPTY
62591: LIST
62592: LIST
62593: PUSH
62594: LD_INT 30
62596: PUSH
62597: LD_INT 5
62599: PUSH
62600: EMPTY
62601: LIST
62602: LIST
62603: PUSH
62604: EMPTY
62605: LIST
62606: LIST
62607: LIST
62608: PPUSH
62609: CALL_OW 72
62613: ST_TO_ADDR
// if not b then
62614: LD_VAR 0 12
62618: NOT
62619: IFFALSE 62623
// exit ;
62621: GO 65689
// p := [ ] ;
62623: LD_ADDR_VAR 0 11
62627: PUSH
62628: EMPTY
62629: ST_TO_ADDR
// if sci >= 2 then
62630: LD_VAR 0 8
62634: PUSH
62635: LD_INT 2
62637: GREATEREQUAL
62638: IFFALSE 62669
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
62640: LD_ADDR_VAR 0 8
62644: PUSH
62645: LD_VAR 0 8
62649: PUSH
62650: LD_INT 1
62652: ARRAY
62653: PUSH
62654: LD_VAR 0 8
62658: PUSH
62659: LD_INT 2
62661: ARRAY
62662: PUSH
62663: EMPTY
62664: LIST
62665: LIST
62666: ST_TO_ADDR
62667: GO 62730
// if sci = 1 then
62669: LD_VAR 0 8
62673: PUSH
62674: LD_INT 1
62676: EQUAL
62677: IFFALSE 62698
// sci := [ sci [ 1 ] ] else
62679: LD_ADDR_VAR 0 8
62683: PUSH
62684: LD_VAR 0 8
62688: PUSH
62689: LD_INT 1
62691: ARRAY
62692: PUSH
62693: EMPTY
62694: LIST
62695: ST_TO_ADDR
62696: GO 62730
// if sci = 0 then
62698: LD_VAR 0 8
62702: PUSH
62703: LD_INT 0
62705: EQUAL
62706: IFFALSE 62730
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62708: LD_ADDR_VAR 0 11
62712: PUSH
62713: LD_VAR 0 4
62717: PPUSH
62718: LD_INT 4
62720: PPUSH
62721: CALL 55772 0 2
62725: PUSH
62726: LD_INT 1
62728: ARRAY
62729: ST_TO_ADDR
// if eng > 4 then
62730: LD_VAR 0 6
62734: PUSH
62735: LD_INT 4
62737: GREATER
62738: IFFALSE 62784
// for i = eng downto 4 do
62740: LD_ADDR_VAR 0 3
62744: PUSH
62745: DOUBLE
62746: LD_VAR 0 6
62750: INC
62751: ST_TO_ADDR
62752: LD_INT 4
62754: PUSH
62755: FOR_DOWNTO
62756: IFFALSE 62782
// eng := eng diff eng [ i ] ;
62758: LD_ADDR_VAR 0 6
62762: PUSH
62763: LD_VAR 0 6
62767: PUSH
62768: LD_VAR 0 6
62772: PUSH
62773: LD_VAR 0 3
62777: ARRAY
62778: DIFF
62779: ST_TO_ADDR
62780: GO 62755
62782: POP
62783: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62784: LD_ADDR_VAR 0 4
62788: PUSH
62789: LD_VAR 0 4
62793: PUSH
62794: LD_VAR 0 5
62798: PUSH
62799: LD_VAR 0 6
62803: UNION
62804: PUSH
62805: LD_VAR 0 7
62809: UNION
62810: PUSH
62811: LD_VAR 0 8
62815: UNION
62816: DIFF
62817: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62818: LD_ADDR_VAR 0 13
62822: PUSH
62823: LD_EXP 59
62827: PUSH
62828: LD_VAR 0 1
62832: ARRAY
62833: PPUSH
62834: LD_INT 2
62836: PUSH
62837: LD_INT 30
62839: PUSH
62840: LD_INT 32
62842: PUSH
62843: EMPTY
62844: LIST
62845: LIST
62846: PUSH
62847: LD_INT 30
62849: PUSH
62850: LD_INT 31
62852: PUSH
62853: EMPTY
62854: LIST
62855: LIST
62856: PUSH
62857: EMPTY
62858: LIST
62859: LIST
62860: LIST
62861: PPUSH
62862: CALL_OW 72
62866: PUSH
62867: LD_EXP 59
62871: PUSH
62872: LD_VAR 0 1
62876: ARRAY
62877: PPUSH
62878: LD_INT 2
62880: PUSH
62881: LD_INT 30
62883: PUSH
62884: LD_INT 4
62886: PUSH
62887: EMPTY
62888: LIST
62889: LIST
62890: PUSH
62891: LD_INT 30
62893: PUSH
62894: LD_INT 5
62896: PUSH
62897: EMPTY
62898: LIST
62899: LIST
62900: PUSH
62901: EMPTY
62902: LIST
62903: LIST
62904: LIST
62905: PPUSH
62906: CALL_OW 72
62910: PUSH
62911: LD_INT 6
62913: MUL
62914: PLUS
62915: ST_TO_ADDR
// if bcount < tmp then
62916: LD_VAR 0 13
62920: PUSH
62921: LD_VAR 0 4
62925: LESS
62926: IFFALSE 62972
// for i = tmp downto bcount do
62928: LD_ADDR_VAR 0 3
62932: PUSH
62933: DOUBLE
62934: LD_VAR 0 4
62938: INC
62939: ST_TO_ADDR
62940: LD_VAR 0 13
62944: PUSH
62945: FOR_DOWNTO
62946: IFFALSE 62970
// tmp := Delete ( tmp , tmp ) ;
62948: LD_ADDR_VAR 0 4
62952: PUSH
62953: LD_VAR 0 4
62957: PPUSH
62958: LD_VAR 0 4
62962: PPUSH
62963: CALL_OW 3
62967: ST_TO_ADDR
62968: GO 62945
62970: POP
62971: POP
// result := [ tmp , 0 , 0 , p ] ;
62972: LD_ADDR_VAR 0 2
62976: PUSH
62977: LD_VAR 0 4
62981: PUSH
62982: LD_INT 0
62984: PUSH
62985: LD_INT 0
62987: PUSH
62988: LD_VAR 0 11
62992: PUSH
62993: EMPTY
62994: LIST
62995: LIST
62996: LIST
62997: LIST
62998: ST_TO_ADDR
// exit ;
62999: GO 65689
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63001: LD_EXP 59
63005: PUSH
63006: LD_VAR 0 1
63010: ARRAY
63011: PPUSH
63012: LD_INT 2
63014: PUSH
63015: LD_INT 30
63017: PUSH
63018: LD_INT 6
63020: PUSH
63021: EMPTY
63022: LIST
63023: LIST
63024: PUSH
63025: LD_INT 30
63027: PUSH
63028: LD_INT 7
63030: PUSH
63031: EMPTY
63032: LIST
63033: LIST
63034: PUSH
63035: LD_INT 30
63037: PUSH
63038: LD_INT 8
63040: PUSH
63041: EMPTY
63042: LIST
63043: LIST
63044: PUSH
63045: EMPTY
63046: LIST
63047: LIST
63048: LIST
63049: LIST
63050: PPUSH
63051: CALL_OW 72
63055: NOT
63056: PUSH
63057: LD_EXP 59
63061: PUSH
63062: LD_VAR 0 1
63066: ARRAY
63067: PPUSH
63068: LD_INT 30
63070: PUSH
63071: LD_INT 3
63073: PUSH
63074: EMPTY
63075: LIST
63076: LIST
63077: PPUSH
63078: CALL_OW 72
63082: NOT
63083: AND
63084: IFFALSE 63156
// begin if eng = tmp then
63086: LD_VAR 0 6
63090: PUSH
63091: LD_VAR 0 4
63095: EQUAL
63096: IFFALSE 63100
// exit ;
63098: GO 65689
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
63100: LD_ADDR_EXP 101
63104: PUSH
63105: LD_EXP 101
63109: PPUSH
63110: LD_VAR 0 1
63114: PPUSH
63115: LD_INT 1
63117: PPUSH
63118: CALL_OW 1
63122: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
63123: LD_ADDR_VAR 0 2
63127: PUSH
63128: LD_INT 0
63130: PUSH
63131: LD_VAR 0 4
63135: PUSH
63136: LD_VAR 0 6
63140: DIFF
63141: PUSH
63142: LD_INT 0
63144: PUSH
63145: LD_INT 0
63147: PUSH
63148: EMPTY
63149: LIST
63150: LIST
63151: LIST
63152: LIST
63153: ST_TO_ADDR
// exit ;
63154: GO 65689
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63156: LD_EXP 86
63160: PUSH
63161: LD_EXP 85
63165: PUSH
63166: LD_VAR 0 1
63170: ARRAY
63171: ARRAY
63172: PUSH
63173: LD_EXP 59
63177: PUSH
63178: LD_VAR 0 1
63182: ARRAY
63183: PPUSH
63184: LD_INT 2
63186: PUSH
63187: LD_INT 30
63189: PUSH
63190: LD_INT 6
63192: PUSH
63193: EMPTY
63194: LIST
63195: LIST
63196: PUSH
63197: LD_INT 30
63199: PUSH
63200: LD_INT 7
63202: PUSH
63203: EMPTY
63204: LIST
63205: LIST
63206: PUSH
63207: LD_INT 30
63209: PUSH
63210: LD_INT 8
63212: PUSH
63213: EMPTY
63214: LIST
63215: LIST
63216: PUSH
63217: EMPTY
63218: LIST
63219: LIST
63220: LIST
63221: LIST
63222: PPUSH
63223: CALL_OW 72
63227: AND
63228: PUSH
63229: LD_EXP 59
63233: PUSH
63234: LD_VAR 0 1
63238: ARRAY
63239: PPUSH
63240: LD_INT 30
63242: PUSH
63243: LD_INT 3
63245: PUSH
63246: EMPTY
63247: LIST
63248: LIST
63249: PPUSH
63250: CALL_OW 72
63254: NOT
63255: AND
63256: IFFALSE 63470
// begin if sci >= 6 then
63258: LD_VAR 0 8
63262: PUSH
63263: LD_INT 6
63265: GREATEREQUAL
63266: IFFALSE 63270
// exit ;
63268: GO 65689
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
63270: LD_ADDR_EXP 101
63274: PUSH
63275: LD_EXP 101
63279: PPUSH
63280: LD_VAR 0 1
63284: PPUSH
63285: LD_INT 2
63287: PPUSH
63288: CALL_OW 1
63292: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
63293: LD_ADDR_VAR 0 9
63297: PUSH
63298: LD_VAR 0 4
63302: PUSH
63303: LD_VAR 0 8
63307: DIFF
63308: PPUSH
63309: LD_INT 4
63311: PPUSH
63312: CALL 55772 0 2
63316: ST_TO_ADDR
// p := [ ] ;
63317: LD_ADDR_VAR 0 11
63321: PUSH
63322: EMPTY
63323: ST_TO_ADDR
// if sci < 6 and sort > 6 then
63324: LD_VAR 0 8
63328: PUSH
63329: LD_INT 6
63331: LESS
63332: PUSH
63333: LD_VAR 0 9
63337: PUSH
63338: LD_INT 6
63340: GREATER
63341: AND
63342: IFFALSE 63423
// begin for i = 1 to 6 - sci do
63344: LD_ADDR_VAR 0 3
63348: PUSH
63349: DOUBLE
63350: LD_INT 1
63352: DEC
63353: ST_TO_ADDR
63354: LD_INT 6
63356: PUSH
63357: LD_VAR 0 8
63361: MINUS
63362: PUSH
63363: FOR_TO
63364: IFFALSE 63419
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
63366: LD_ADDR_VAR 0 11
63370: PUSH
63371: LD_VAR 0 11
63375: PPUSH
63376: LD_VAR 0 11
63380: PUSH
63381: LD_INT 1
63383: PLUS
63384: PPUSH
63385: LD_VAR 0 9
63389: PUSH
63390: LD_INT 1
63392: ARRAY
63393: PPUSH
63394: CALL_OW 2
63398: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
63399: LD_ADDR_VAR 0 9
63403: PUSH
63404: LD_VAR 0 9
63408: PPUSH
63409: LD_INT 1
63411: PPUSH
63412: CALL_OW 3
63416: ST_TO_ADDR
// end ;
63417: GO 63363
63419: POP
63420: POP
// end else
63421: GO 63443
// if sort then
63423: LD_VAR 0 9
63427: IFFALSE 63443
// p := sort [ 1 ] ;
63429: LD_ADDR_VAR 0 11
63433: PUSH
63434: LD_VAR 0 9
63438: PUSH
63439: LD_INT 1
63441: ARRAY
63442: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
63443: LD_ADDR_VAR 0 2
63447: PUSH
63448: LD_INT 0
63450: PUSH
63451: LD_INT 0
63453: PUSH
63454: LD_INT 0
63456: PUSH
63457: LD_VAR 0 11
63461: PUSH
63462: EMPTY
63463: LIST
63464: LIST
63465: LIST
63466: LIST
63467: ST_TO_ADDR
// exit ;
63468: GO 65689
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63470: LD_EXP 86
63474: PUSH
63475: LD_EXP 85
63479: PUSH
63480: LD_VAR 0 1
63484: ARRAY
63485: ARRAY
63486: PUSH
63487: LD_EXP 59
63491: PUSH
63492: LD_VAR 0 1
63496: ARRAY
63497: PPUSH
63498: LD_INT 2
63500: PUSH
63501: LD_INT 30
63503: PUSH
63504: LD_INT 6
63506: PUSH
63507: EMPTY
63508: LIST
63509: LIST
63510: PUSH
63511: LD_INT 30
63513: PUSH
63514: LD_INT 7
63516: PUSH
63517: EMPTY
63518: LIST
63519: LIST
63520: PUSH
63521: LD_INT 30
63523: PUSH
63524: LD_INT 8
63526: PUSH
63527: EMPTY
63528: LIST
63529: LIST
63530: PUSH
63531: EMPTY
63532: LIST
63533: LIST
63534: LIST
63535: LIST
63536: PPUSH
63537: CALL_OW 72
63541: AND
63542: PUSH
63543: LD_EXP 59
63547: PUSH
63548: LD_VAR 0 1
63552: ARRAY
63553: PPUSH
63554: LD_INT 30
63556: PUSH
63557: LD_INT 3
63559: PUSH
63560: EMPTY
63561: LIST
63562: LIST
63563: PPUSH
63564: CALL_OW 72
63568: AND
63569: IFFALSE 64303
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
63571: LD_ADDR_EXP 101
63575: PUSH
63576: LD_EXP 101
63580: PPUSH
63581: LD_VAR 0 1
63585: PPUSH
63586: LD_INT 3
63588: PPUSH
63589: CALL_OW 1
63593: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63594: LD_ADDR_VAR 0 2
63598: PUSH
63599: LD_INT 0
63601: PUSH
63602: LD_INT 0
63604: PUSH
63605: LD_INT 0
63607: PUSH
63608: LD_INT 0
63610: PUSH
63611: EMPTY
63612: LIST
63613: LIST
63614: LIST
63615: LIST
63616: ST_TO_ADDR
// if not eng then
63617: LD_VAR 0 6
63621: NOT
63622: IFFALSE 63685
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
63624: LD_ADDR_VAR 0 11
63628: PUSH
63629: LD_VAR 0 4
63633: PPUSH
63634: LD_INT 2
63636: PPUSH
63637: CALL 55772 0 2
63641: PUSH
63642: LD_INT 1
63644: ARRAY
63645: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
63646: LD_ADDR_VAR 0 2
63650: PUSH
63651: LD_VAR 0 2
63655: PPUSH
63656: LD_INT 2
63658: PPUSH
63659: LD_VAR 0 11
63663: PPUSH
63664: CALL_OW 1
63668: ST_TO_ADDR
// tmp := tmp diff p ;
63669: LD_ADDR_VAR 0 4
63673: PUSH
63674: LD_VAR 0 4
63678: PUSH
63679: LD_VAR 0 11
63683: DIFF
63684: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63685: LD_VAR 0 4
63689: PUSH
63690: LD_VAR 0 8
63694: PUSH
63695: LD_INT 6
63697: LESS
63698: AND
63699: IFFALSE 63887
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63701: LD_ADDR_VAR 0 9
63705: PUSH
63706: LD_VAR 0 4
63710: PUSH
63711: LD_VAR 0 8
63715: PUSH
63716: LD_VAR 0 7
63720: UNION
63721: DIFF
63722: PPUSH
63723: LD_INT 4
63725: PPUSH
63726: CALL 55772 0 2
63730: ST_TO_ADDR
// p := [ ] ;
63731: LD_ADDR_VAR 0 11
63735: PUSH
63736: EMPTY
63737: ST_TO_ADDR
// if sort then
63738: LD_VAR 0 9
63742: IFFALSE 63858
// for i = 1 to 6 - sci do
63744: LD_ADDR_VAR 0 3
63748: PUSH
63749: DOUBLE
63750: LD_INT 1
63752: DEC
63753: ST_TO_ADDR
63754: LD_INT 6
63756: PUSH
63757: LD_VAR 0 8
63761: MINUS
63762: PUSH
63763: FOR_TO
63764: IFFALSE 63856
// begin if i = sort then
63766: LD_VAR 0 3
63770: PUSH
63771: LD_VAR 0 9
63775: EQUAL
63776: IFFALSE 63780
// break ;
63778: GO 63856
// if GetClass ( i ) = 4 then
63780: LD_VAR 0 3
63784: PPUSH
63785: CALL_OW 257
63789: PUSH
63790: LD_INT 4
63792: EQUAL
63793: IFFALSE 63797
// continue ;
63795: GO 63763
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63797: LD_ADDR_VAR 0 11
63801: PUSH
63802: LD_VAR 0 11
63806: PPUSH
63807: LD_VAR 0 11
63811: PUSH
63812: LD_INT 1
63814: PLUS
63815: PPUSH
63816: LD_VAR 0 9
63820: PUSH
63821: LD_VAR 0 3
63825: ARRAY
63826: PPUSH
63827: CALL_OW 2
63831: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63832: LD_ADDR_VAR 0 4
63836: PUSH
63837: LD_VAR 0 4
63841: PUSH
63842: LD_VAR 0 9
63846: PUSH
63847: LD_VAR 0 3
63851: ARRAY
63852: DIFF
63853: ST_TO_ADDR
// end ;
63854: GO 63763
63856: POP
63857: POP
// if p then
63858: LD_VAR 0 11
63862: IFFALSE 63887
// result := Replace ( result , 4 , p ) ;
63864: LD_ADDR_VAR 0 2
63868: PUSH
63869: LD_VAR 0 2
63873: PPUSH
63874: LD_INT 4
63876: PPUSH
63877: LD_VAR 0 11
63881: PPUSH
63882: CALL_OW 1
63886: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63887: LD_VAR 0 4
63891: PUSH
63892: LD_VAR 0 7
63896: PUSH
63897: LD_INT 6
63899: LESS
63900: AND
63901: IFFALSE 64089
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63903: LD_ADDR_VAR 0 9
63907: PUSH
63908: LD_VAR 0 4
63912: PUSH
63913: LD_VAR 0 8
63917: PUSH
63918: LD_VAR 0 7
63922: UNION
63923: DIFF
63924: PPUSH
63925: LD_INT 3
63927: PPUSH
63928: CALL 55772 0 2
63932: ST_TO_ADDR
// p := [ ] ;
63933: LD_ADDR_VAR 0 11
63937: PUSH
63938: EMPTY
63939: ST_TO_ADDR
// if sort then
63940: LD_VAR 0 9
63944: IFFALSE 64060
// for i = 1 to 6 - mech do
63946: LD_ADDR_VAR 0 3
63950: PUSH
63951: DOUBLE
63952: LD_INT 1
63954: DEC
63955: ST_TO_ADDR
63956: LD_INT 6
63958: PUSH
63959: LD_VAR 0 7
63963: MINUS
63964: PUSH
63965: FOR_TO
63966: IFFALSE 64058
// begin if i = sort then
63968: LD_VAR 0 3
63972: PUSH
63973: LD_VAR 0 9
63977: EQUAL
63978: IFFALSE 63982
// break ;
63980: GO 64058
// if GetClass ( i ) = 3 then
63982: LD_VAR 0 3
63986: PPUSH
63987: CALL_OW 257
63991: PUSH
63992: LD_INT 3
63994: EQUAL
63995: IFFALSE 63999
// continue ;
63997: GO 63965
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63999: LD_ADDR_VAR 0 11
64003: PUSH
64004: LD_VAR 0 11
64008: PPUSH
64009: LD_VAR 0 11
64013: PUSH
64014: LD_INT 1
64016: PLUS
64017: PPUSH
64018: LD_VAR 0 9
64022: PUSH
64023: LD_VAR 0 3
64027: ARRAY
64028: PPUSH
64029: CALL_OW 2
64033: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64034: LD_ADDR_VAR 0 4
64038: PUSH
64039: LD_VAR 0 4
64043: PUSH
64044: LD_VAR 0 9
64048: PUSH
64049: LD_VAR 0 3
64053: ARRAY
64054: DIFF
64055: ST_TO_ADDR
// end ;
64056: GO 63965
64058: POP
64059: POP
// if p then
64060: LD_VAR 0 11
64064: IFFALSE 64089
// result := Replace ( result , 3 , p ) ;
64066: LD_ADDR_VAR 0 2
64070: PUSH
64071: LD_VAR 0 2
64075: PPUSH
64076: LD_INT 3
64078: PPUSH
64079: LD_VAR 0 11
64083: PPUSH
64084: CALL_OW 1
64088: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
64089: LD_VAR 0 4
64093: PUSH
64094: LD_INT 6
64096: GREATER
64097: PUSH
64098: LD_VAR 0 6
64102: PUSH
64103: LD_INT 6
64105: LESS
64106: AND
64107: IFFALSE 64301
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64109: LD_ADDR_VAR 0 9
64113: PUSH
64114: LD_VAR 0 4
64118: PUSH
64119: LD_VAR 0 8
64123: PUSH
64124: LD_VAR 0 7
64128: UNION
64129: PUSH
64130: LD_VAR 0 6
64134: UNION
64135: DIFF
64136: PPUSH
64137: LD_INT 2
64139: PPUSH
64140: CALL 55772 0 2
64144: ST_TO_ADDR
// p := [ ] ;
64145: LD_ADDR_VAR 0 11
64149: PUSH
64150: EMPTY
64151: ST_TO_ADDR
// if sort then
64152: LD_VAR 0 9
64156: IFFALSE 64272
// for i = 1 to 6 - eng do
64158: LD_ADDR_VAR 0 3
64162: PUSH
64163: DOUBLE
64164: LD_INT 1
64166: DEC
64167: ST_TO_ADDR
64168: LD_INT 6
64170: PUSH
64171: LD_VAR 0 6
64175: MINUS
64176: PUSH
64177: FOR_TO
64178: IFFALSE 64270
// begin if i = sort then
64180: LD_VAR 0 3
64184: PUSH
64185: LD_VAR 0 9
64189: EQUAL
64190: IFFALSE 64194
// break ;
64192: GO 64270
// if GetClass ( i ) = 2 then
64194: LD_VAR 0 3
64198: PPUSH
64199: CALL_OW 257
64203: PUSH
64204: LD_INT 2
64206: EQUAL
64207: IFFALSE 64211
// continue ;
64209: GO 64177
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64211: LD_ADDR_VAR 0 11
64215: PUSH
64216: LD_VAR 0 11
64220: PPUSH
64221: LD_VAR 0 11
64225: PUSH
64226: LD_INT 1
64228: PLUS
64229: PPUSH
64230: LD_VAR 0 9
64234: PUSH
64235: LD_VAR 0 3
64239: ARRAY
64240: PPUSH
64241: CALL_OW 2
64245: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64246: LD_ADDR_VAR 0 4
64250: PUSH
64251: LD_VAR 0 4
64255: PUSH
64256: LD_VAR 0 9
64260: PUSH
64261: LD_VAR 0 3
64265: ARRAY
64266: DIFF
64267: ST_TO_ADDR
// end ;
64268: GO 64177
64270: POP
64271: POP
// if p then
64272: LD_VAR 0 11
64276: IFFALSE 64301
// result := Replace ( result , 2 , p ) ;
64278: LD_ADDR_VAR 0 2
64282: PUSH
64283: LD_VAR 0 2
64287: PPUSH
64288: LD_INT 2
64290: PPUSH
64291: LD_VAR 0 11
64295: PPUSH
64296: CALL_OW 1
64300: ST_TO_ADDR
// end ; exit ;
64301: GO 65689
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
64303: LD_EXP 86
64307: PUSH
64308: LD_EXP 85
64312: PUSH
64313: LD_VAR 0 1
64317: ARRAY
64318: ARRAY
64319: NOT
64320: PUSH
64321: LD_EXP 59
64325: PUSH
64326: LD_VAR 0 1
64330: ARRAY
64331: PPUSH
64332: LD_INT 30
64334: PUSH
64335: LD_INT 3
64337: PUSH
64338: EMPTY
64339: LIST
64340: LIST
64341: PPUSH
64342: CALL_OW 72
64346: AND
64347: PUSH
64348: LD_EXP 64
64352: PUSH
64353: LD_VAR 0 1
64357: ARRAY
64358: AND
64359: IFFALSE 64967
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
64361: LD_ADDR_EXP 101
64365: PUSH
64366: LD_EXP 101
64370: PPUSH
64371: LD_VAR 0 1
64375: PPUSH
64376: LD_INT 5
64378: PPUSH
64379: CALL_OW 1
64383: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64384: LD_ADDR_VAR 0 2
64388: PUSH
64389: LD_INT 0
64391: PUSH
64392: LD_INT 0
64394: PUSH
64395: LD_INT 0
64397: PUSH
64398: LD_INT 0
64400: PUSH
64401: EMPTY
64402: LIST
64403: LIST
64404: LIST
64405: LIST
64406: ST_TO_ADDR
// if sci > 1 then
64407: LD_VAR 0 8
64411: PUSH
64412: LD_INT 1
64414: GREATER
64415: IFFALSE 64443
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
64417: LD_ADDR_VAR 0 4
64421: PUSH
64422: LD_VAR 0 4
64426: PUSH
64427: LD_VAR 0 8
64431: PUSH
64432: LD_VAR 0 8
64436: PUSH
64437: LD_INT 1
64439: ARRAY
64440: DIFF
64441: DIFF
64442: ST_TO_ADDR
// if tmp and not sci then
64443: LD_VAR 0 4
64447: PUSH
64448: LD_VAR 0 8
64452: NOT
64453: AND
64454: IFFALSE 64523
// begin sort := SortBySkill ( tmp , 4 ) ;
64456: LD_ADDR_VAR 0 9
64460: PUSH
64461: LD_VAR 0 4
64465: PPUSH
64466: LD_INT 4
64468: PPUSH
64469: CALL 55772 0 2
64473: ST_TO_ADDR
// if sort then
64474: LD_VAR 0 9
64478: IFFALSE 64494
// p := sort [ 1 ] ;
64480: LD_ADDR_VAR 0 11
64484: PUSH
64485: LD_VAR 0 9
64489: PUSH
64490: LD_INT 1
64492: ARRAY
64493: ST_TO_ADDR
// if p then
64494: LD_VAR 0 11
64498: IFFALSE 64523
// result := Replace ( result , 4 , p ) ;
64500: LD_ADDR_VAR 0 2
64504: PUSH
64505: LD_VAR 0 2
64509: PPUSH
64510: LD_INT 4
64512: PPUSH
64513: LD_VAR 0 11
64517: PPUSH
64518: CALL_OW 1
64522: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64523: LD_ADDR_VAR 0 4
64527: PUSH
64528: LD_VAR 0 4
64532: PUSH
64533: LD_VAR 0 7
64537: DIFF
64538: ST_TO_ADDR
// if tmp and mech < 6 then
64539: LD_VAR 0 4
64543: PUSH
64544: LD_VAR 0 7
64548: PUSH
64549: LD_INT 6
64551: LESS
64552: AND
64553: IFFALSE 64741
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64555: LD_ADDR_VAR 0 9
64559: PUSH
64560: LD_VAR 0 4
64564: PUSH
64565: LD_VAR 0 8
64569: PUSH
64570: LD_VAR 0 7
64574: UNION
64575: DIFF
64576: PPUSH
64577: LD_INT 3
64579: PPUSH
64580: CALL 55772 0 2
64584: ST_TO_ADDR
// p := [ ] ;
64585: LD_ADDR_VAR 0 11
64589: PUSH
64590: EMPTY
64591: ST_TO_ADDR
// if sort then
64592: LD_VAR 0 9
64596: IFFALSE 64712
// for i = 1 to 6 - mech do
64598: LD_ADDR_VAR 0 3
64602: PUSH
64603: DOUBLE
64604: LD_INT 1
64606: DEC
64607: ST_TO_ADDR
64608: LD_INT 6
64610: PUSH
64611: LD_VAR 0 7
64615: MINUS
64616: PUSH
64617: FOR_TO
64618: IFFALSE 64710
// begin if i = sort then
64620: LD_VAR 0 3
64624: PUSH
64625: LD_VAR 0 9
64629: EQUAL
64630: IFFALSE 64634
// break ;
64632: GO 64710
// if GetClass ( i ) = 3 then
64634: LD_VAR 0 3
64638: PPUSH
64639: CALL_OW 257
64643: PUSH
64644: LD_INT 3
64646: EQUAL
64647: IFFALSE 64651
// continue ;
64649: GO 64617
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64651: LD_ADDR_VAR 0 11
64655: PUSH
64656: LD_VAR 0 11
64660: PPUSH
64661: LD_VAR 0 11
64665: PUSH
64666: LD_INT 1
64668: PLUS
64669: PPUSH
64670: LD_VAR 0 9
64674: PUSH
64675: LD_VAR 0 3
64679: ARRAY
64680: PPUSH
64681: CALL_OW 2
64685: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64686: LD_ADDR_VAR 0 4
64690: PUSH
64691: LD_VAR 0 4
64695: PUSH
64696: LD_VAR 0 9
64700: PUSH
64701: LD_VAR 0 3
64705: ARRAY
64706: DIFF
64707: ST_TO_ADDR
// end ;
64708: GO 64617
64710: POP
64711: POP
// if p then
64712: LD_VAR 0 11
64716: IFFALSE 64741
// result := Replace ( result , 3 , p ) ;
64718: LD_ADDR_VAR 0 2
64722: PUSH
64723: LD_VAR 0 2
64727: PPUSH
64728: LD_INT 3
64730: PPUSH
64731: LD_VAR 0 11
64735: PPUSH
64736: CALL_OW 1
64740: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64741: LD_ADDR_VAR 0 4
64745: PUSH
64746: LD_VAR 0 4
64750: PUSH
64751: LD_VAR 0 6
64755: DIFF
64756: ST_TO_ADDR
// if tmp and eng < 6 then
64757: LD_VAR 0 4
64761: PUSH
64762: LD_VAR 0 6
64766: PUSH
64767: LD_INT 6
64769: LESS
64770: AND
64771: IFFALSE 64965
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64773: LD_ADDR_VAR 0 9
64777: PUSH
64778: LD_VAR 0 4
64782: PUSH
64783: LD_VAR 0 8
64787: PUSH
64788: LD_VAR 0 7
64792: UNION
64793: PUSH
64794: LD_VAR 0 6
64798: UNION
64799: DIFF
64800: PPUSH
64801: LD_INT 2
64803: PPUSH
64804: CALL 55772 0 2
64808: ST_TO_ADDR
// p := [ ] ;
64809: LD_ADDR_VAR 0 11
64813: PUSH
64814: EMPTY
64815: ST_TO_ADDR
// if sort then
64816: LD_VAR 0 9
64820: IFFALSE 64936
// for i = 1 to 6 - eng do
64822: LD_ADDR_VAR 0 3
64826: PUSH
64827: DOUBLE
64828: LD_INT 1
64830: DEC
64831: ST_TO_ADDR
64832: LD_INT 6
64834: PUSH
64835: LD_VAR 0 6
64839: MINUS
64840: PUSH
64841: FOR_TO
64842: IFFALSE 64934
// begin if i = sort then
64844: LD_VAR 0 3
64848: PUSH
64849: LD_VAR 0 9
64853: EQUAL
64854: IFFALSE 64858
// break ;
64856: GO 64934
// if GetClass ( i ) = 2 then
64858: LD_VAR 0 3
64862: PPUSH
64863: CALL_OW 257
64867: PUSH
64868: LD_INT 2
64870: EQUAL
64871: IFFALSE 64875
// continue ;
64873: GO 64841
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64875: LD_ADDR_VAR 0 11
64879: PUSH
64880: LD_VAR 0 11
64884: PPUSH
64885: LD_VAR 0 11
64889: PUSH
64890: LD_INT 1
64892: PLUS
64893: PPUSH
64894: LD_VAR 0 9
64898: PUSH
64899: LD_VAR 0 3
64903: ARRAY
64904: PPUSH
64905: CALL_OW 2
64909: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64910: LD_ADDR_VAR 0 4
64914: PUSH
64915: LD_VAR 0 4
64919: PUSH
64920: LD_VAR 0 9
64924: PUSH
64925: LD_VAR 0 3
64929: ARRAY
64930: DIFF
64931: ST_TO_ADDR
// end ;
64932: GO 64841
64934: POP
64935: POP
// if p then
64936: LD_VAR 0 11
64940: IFFALSE 64965
// result := Replace ( result , 2 , p ) ;
64942: LD_ADDR_VAR 0 2
64946: PUSH
64947: LD_VAR 0 2
64951: PPUSH
64952: LD_INT 2
64954: PPUSH
64955: LD_VAR 0 11
64959: PPUSH
64960: CALL_OW 1
64964: ST_TO_ADDR
// end ; exit ;
64965: GO 65689
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
64967: LD_EXP 86
64971: PUSH
64972: LD_EXP 85
64976: PUSH
64977: LD_VAR 0 1
64981: ARRAY
64982: ARRAY
64983: NOT
64984: PUSH
64985: LD_EXP 59
64989: PUSH
64990: LD_VAR 0 1
64994: ARRAY
64995: PPUSH
64996: LD_INT 30
64998: PUSH
64999: LD_INT 3
65001: PUSH
65002: EMPTY
65003: LIST
65004: LIST
65005: PPUSH
65006: CALL_OW 72
65010: AND
65011: PUSH
65012: LD_EXP 64
65016: PUSH
65017: LD_VAR 0 1
65021: ARRAY
65022: NOT
65023: AND
65024: IFFALSE 65689
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
65026: LD_ADDR_EXP 101
65030: PUSH
65031: LD_EXP 101
65035: PPUSH
65036: LD_VAR 0 1
65040: PPUSH
65041: LD_INT 6
65043: PPUSH
65044: CALL_OW 1
65048: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
65049: LD_ADDR_VAR 0 2
65053: PUSH
65054: LD_INT 0
65056: PUSH
65057: LD_INT 0
65059: PUSH
65060: LD_INT 0
65062: PUSH
65063: LD_INT 0
65065: PUSH
65066: EMPTY
65067: LIST
65068: LIST
65069: LIST
65070: LIST
65071: ST_TO_ADDR
// if sci >= 1 then
65072: LD_VAR 0 8
65076: PUSH
65077: LD_INT 1
65079: GREATEREQUAL
65080: IFFALSE 65102
// tmp := tmp diff sci [ 1 ] ;
65082: LD_ADDR_VAR 0 4
65086: PUSH
65087: LD_VAR 0 4
65091: PUSH
65092: LD_VAR 0 8
65096: PUSH
65097: LD_INT 1
65099: ARRAY
65100: DIFF
65101: ST_TO_ADDR
// if tmp and not sci then
65102: LD_VAR 0 4
65106: PUSH
65107: LD_VAR 0 8
65111: NOT
65112: AND
65113: IFFALSE 65182
// begin sort := SortBySkill ( tmp , 4 ) ;
65115: LD_ADDR_VAR 0 9
65119: PUSH
65120: LD_VAR 0 4
65124: PPUSH
65125: LD_INT 4
65127: PPUSH
65128: CALL 55772 0 2
65132: ST_TO_ADDR
// if sort then
65133: LD_VAR 0 9
65137: IFFALSE 65153
// p := sort [ 1 ] ;
65139: LD_ADDR_VAR 0 11
65143: PUSH
65144: LD_VAR 0 9
65148: PUSH
65149: LD_INT 1
65151: ARRAY
65152: ST_TO_ADDR
// if p then
65153: LD_VAR 0 11
65157: IFFALSE 65182
// result := Replace ( result , 4 , p ) ;
65159: LD_ADDR_VAR 0 2
65163: PUSH
65164: LD_VAR 0 2
65168: PPUSH
65169: LD_INT 4
65171: PPUSH
65172: LD_VAR 0 11
65176: PPUSH
65177: CALL_OW 1
65181: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
65182: LD_ADDR_VAR 0 4
65186: PUSH
65187: LD_VAR 0 4
65191: PUSH
65192: LD_VAR 0 7
65196: DIFF
65197: ST_TO_ADDR
// if tmp and mech < 6 then
65198: LD_VAR 0 4
65202: PUSH
65203: LD_VAR 0 7
65207: PUSH
65208: LD_INT 6
65210: LESS
65211: AND
65212: IFFALSE 65394
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
65214: LD_ADDR_VAR 0 9
65218: PUSH
65219: LD_VAR 0 4
65223: PUSH
65224: LD_VAR 0 7
65228: DIFF
65229: PPUSH
65230: LD_INT 3
65232: PPUSH
65233: CALL 55772 0 2
65237: ST_TO_ADDR
// p := [ ] ;
65238: LD_ADDR_VAR 0 11
65242: PUSH
65243: EMPTY
65244: ST_TO_ADDR
// if sort then
65245: LD_VAR 0 9
65249: IFFALSE 65365
// for i = 1 to 6 - mech do
65251: LD_ADDR_VAR 0 3
65255: PUSH
65256: DOUBLE
65257: LD_INT 1
65259: DEC
65260: ST_TO_ADDR
65261: LD_INT 6
65263: PUSH
65264: LD_VAR 0 7
65268: MINUS
65269: PUSH
65270: FOR_TO
65271: IFFALSE 65363
// begin if i = sort then
65273: LD_VAR 0 3
65277: PUSH
65278: LD_VAR 0 9
65282: EQUAL
65283: IFFALSE 65287
// break ;
65285: GO 65363
// if GetClass ( i ) = 3 then
65287: LD_VAR 0 3
65291: PPUSH
65292: CALL_OW 257
65296: PUSH
65297: LD_INT 3
65299: EQUAL
65300: IFFALSE 65304
// continue ;
65302: GO 65270
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65304: LD_ADDR_VAR 0 11
65308: PUSH
65309: LD_VAR 0 11
65313: PPUSH
65314: LD_VAR 0 11
65318: PUSH
65319: LD_INT 1
65321: PLUS
65322: PPUSH
65323: LD_VAR 0 9
65327: PUSH
65328: LD_VAR 0 3
65332: ARRAY
65333: PPUSH
65334: CALL_OW 2
65338: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65339: LD_ADDR_VAR 0 4
65343: PUSH
65344: LD_VAR 0 4
65348: PUSH
65349: LD_VAR 0 9
65353: PUSH
65354: LD_VAR 0 3
65358: ARRAY
65359: DIFF
65360: ST_TO_ADDR
// end ;
65361: GO 65270
65363: POP
65364: POP
// if p then
65365: LD_VAR 0 11
65369: IFFALSE 65394
// result := Replace ( result , 3 , p ) ;
65371: LD_ADDR_VAR 0 2
65375: PUSH
65376: LD_VAR 0 2
65380: PPUSH
65381: LD_INT 3
65383: PPUSH
65384: LD_VAR 0 11
65388: PPUSH
65389: CALL_OW 1
65393: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
65394: LD_ADDR_VAR 0 4
65398: PUSH
65399: LD_VAR 0 4
65403: PUSH
65404: LD_VAR 0 6
65408: DIFF
65409: ST_TO_ADDR
// if tmp and eng < 4 then
65410: LD_VAR 0 4
65414: PUSH
65415: LD_VAR 0 6
65419: PUSH
65420: LD_INT 4
65422: LESS
65423: AND
65424: IFFALSE 65614
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
65426: LD_ADDR_VAR 0 9
65430: PUSH
65431: LD_VAR 0 4
65435: PUSH
65436: LD_VAR 0 7
65440: PUSH
65441: LD_VAR 0 6
65445: UNION
65446: DIFF
65447: PPUSH
65448: LD_INT 2
65450: PPUSH
65451: CALL 55772 0 2
65455: ST_TO_ADDR
// p := [ ] ;
65456: LD_ADDR_VAR 0 11
65460: PUSH
65461: EMPTY
65462: ST_TO_ADDR
// if sort then
65463: LD_VAR 0 9
65467: IFFALSE 65583
// for i = 1 to 4 - eng do
65469: LD_ADDR_VAR 0 3
65473: PUSH
65474: DOUBLE
65475: LD_INT 1
65477: DEC
65478: ST_TO_ADDR
65479: LD_INT 4
65481: PUSH
65482: LD_VAR 0 6
65486: MINUS
65487: PUSH
65488: FOR_TO
65489: IFFALSE 65581
// begin if i = sort then
65491: LD_VAR 0 3
65495: PUSH
65496: LD_VAR 0 9
65500: EQUAL
65501: IFFALSE 65505
// break ;
65503: GO 65581
// if GetClass ( i ) = 2 then
65505: LD_VAR 0 3
65509: PPUSH
65510: CALL_OW 257
65514: PUSH
65515: LD_INT 2
65517: EQUAL
65518: IFFALSE 65522
// continue ;
65520: GO 65488
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65522: LD_ADDR_VAR 0 11
65526: PUSH
65527: LD_VAR 0 11
65531: PPUSH
65532: LD_VAR 0 11
65536: PUSH
65537: LD_INT 1
65539: PLUS
65540: PPUSH
65541: LD_VAR 0 9
65545: PUSH
65546: LD_VAR 0 3
65550: ARRAY
65551: PPUSH
65552: CALL_OW 2
65556: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65557: LD_ADDR_VAR 0 4
65561: PUSH
65562: LD_VAR 0 4
65566: PUSH
65567: LD_VAR 0 9
65571: PUSH
65572: LD_VAR 0 3
65576: ARRAY
65577: DIFF
65578: ST_TO_ADDR
// end ;
65579: GO 65488
65581: POP
65582: POP
// if p then
65583: LD_VAR 0 11
65587: IFFALSE 65612
// result := Replace ( result , 2 , p ) ;
65589: LD_ADDR_VAR 0 2
65593: PUSH
65594: LD_VAR 0 2
65598: PPUSH
65599: LD_INT 2
65601: PPUSH
65602: LD_VAR 0 11
65606: PPUSH
65607: CALL_OW 1
65611: ST_TO_ADDR
// end else
65612: GO 65658
// for i = eng downto 5 do
65614: LD_ADDR_VAR 0 3
65618: PUSH
65619: DOUBLE
65620: LD_VAR 0 6
65624: INC
65625: ST_TO_ADDR
65626: LD_INT 5
65628: PUSH
65629: FOR_DOWNTO
65630: IFFALSE 65656
// tmp := tmp union eng [ i ] ;
65632: LD_ADDR_VAR 0 4
65636: PUSH
65637: LD_VAR 0 4
65641: PUSH
65642: LD_VAR 0 6
65646: PUSH
65647: LD_VAR 0 3
65651: ARRAY
65652: UNION
65653: ST_TO_ADDR
65654: GO 65629
65656: POP
65657: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
65658: LD_ADDR_VAR 0 2
65662: PUSH
65663: LD_VAR 0 2
65667: PPUSH
65668: LD_INT 1
65670: PPUSH
65671: LD_VAR 0 4
65675: PUSH
65676: LD_VAR 0 5
65680: DIFF
65681: PPUSH
65682: CALL_OW 1
65686: ST_TO_ADDR
// exit ;
65687: GO 65689
// end ; end ;
65689: LD_VAR 0 2
65693: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65694: LD_INT 0
65696: PPUSH
65697: PPUSH
65698: PPUSH
// if not mc_bases then
65699: LD_EXP 59
65703: NOT
65704: IFFALSE 65708
// exit ;
65706: GO 65814
// for i = 1 to mc_bases do
65708: LD_ADDR_VAR 0 2
65712: PUSH
65713: DOUBLE
65714: LD_INT 1
65716: DEC
65717: ST_TO_ADDR
65718: LD_EXP 59
65722: PUSH
65723: FOR_TO
65724: IFFALSE 65805
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65726: LD_ADDR_VAR 0 3
65730: PUSH
65731: LD_EXP 59
65735: PUSH
65736: LD_VAR 0 2
65740: ARRAY
65741: PPUSH
65742: LD_INT 21
65744: PUSH
65745: LD_INT 3
65747: PUSH
65748: EMPTY
65749: LIST
65750: LIST
65751: PUSH
65752: LD_INT 3
65754: PUSH
65755: LD_INT 24
65757: PUSH
65758: LD_INT 1000
65760: PUSH
65761: EMPTY
65762: LIST
65763: LIST
65764: PUSH
65765: EMPTY
65766: LIST
65767: LIST
65768: PUSH
65769: EMPTY
65770: LIST
65771: LIST
65772: PPUSH
65773: CALL_OW 72
65777: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65778: LD_ADDR_EXP 60
65782: PUSH
65783: LD_EXP 60
65787: PPUSH
65788: LD_VAR 0 2
65792: PPUSH
65793: LD_VAR 0 3
65797: PPUSH
65798: CALL_OW 1
65802: ST_TO_ADDR
// end ;
65803: GO 65723
65805: POP
65806: POP
// RaiseSailEvent ( 101 ) ;
65807: LD_INT 101
65809: PPUSH
65810: CALL_OW 427
// end ;
65814: LD_VAR 0 1
65818: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65819: LD_INT 0
65821: PPUSH
65822: PPUSH
65823: PPUSH
65824: PPUSH
65825: PPUSH
65826: PPUSH
65827: PPUSH
// if not mc_bases then
65828: LD_EXP 59
65832: NOT
65833: IFFALSE 65837
// exit ;
65835: GO 66410
// for i = 1 to mc_bases do
65837: LD_ADDR_VAR 0 2
65841: PUSH
65842: DOUBLE
65843: LD_INT 1
65845: DEC
65846: ST_TO_ADDR
65847: LD_EXP 59
65851: PUSH
65852: FOR_TO
65853: IFFALSE 66401
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
65855: LD_ADDR_VAR 0 5
65859: PUSH
65860: LD_EXP 59
65864: PUSH
65865: LD_VAR 0 2
65869: ARRAY
65870: PUSH
65871: LD_EXP 88
65875: PUSH
65876: LD_VAR 0 2
65880: ARRAY
65881: UNION
65882: PPUSH
65883: LD_INT 21
65885: PUSH
65886: LD_INT 1
65888: PUSH
65889: EMPTY
65890: LIST
65891: LIST
65892: PUSH
65893: LD_INT 1
65895: PUSH
65896: LD_INT 3
65898: PUSH
65899: LD_INT 54
65901: PUSH
65902: EMPTY
65903: LIST
65904: PUSH
65905: EMPTY
65906: LIST
65907: LIST
65908: PUSH
65909: LD_INT 3
65911: PUSH
65912: LD_INT 24
65914: PUSH
65915: LD_INT 800
65917: PUSH
65918: EMPTY
65919: LIST
65920: LIST
65921: PUSH
65922: EMPTY
65923: LIST
65924: LIST
65925: PUSH
65926: EMPTY
65927: LIST
65928: LIST
65929: LIST
65930: PUSH
65931: EMPTY
65932: LIST
65933: LIST
65934: PPUSH
65935: CALL_OW 72
65939: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
65940: LD_ADDR_VAR 0 6
65944: PUSH
65945: LD_EXP 59
65949: PUSH
65950: LD_VAR 0 2
65954: ARRAY
65955: PPUSH
65956: LD_INT 21
65958: PUSH
65959: LD_INT 1
65961: PUSH
65962: EMPTY
65963: LIST
65964: LIST
65965: PUSH
65966: LD_INT 1
65968: PUSH
65969: LD_INT 3
65971: PUSH
65972: LD_INT 54
65974: PUSH
65975: EMPTY
65976: LIST
65977: PUSH
65978: EMPTY
65979: LIST
65980: LIST
65981: PUSH
65982: LD_INT 3
65984: PUSH
65985: LD_INT 24
65987: PUSH
65988: LD_INT 250
65990: PUSH
65991: EMPTY
65992: LIST
65993: LIST
65994: PUSH
65995: EMPTY
65996: LIST
65997: LIST
65998: PUSH
65999: EMPTY
66000: LIST
66001: LIST
66002: LIST
66003: PUSH
66004: EMPTY
66005: LIST
66006: LIST
66007: PPUSH
66008: CALL_OW 72
66012: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
66013: LD_ADDR_VAR 0 7
66017: PUSH
66018: LD_VAR 0 5
66022: PUSH
66023: LD_VAR 0 6
66027: DIFF
66028: ST_TO_ADDR
// if not need_heal_1 then
66029: LD_VAR 0 6
66033: NOT
66034: IFFALSE 66067
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
66036: LD_ADDR_EXP 62
66040: PUSH
66041: LD_EXP 62
66045: PPUSH
66046: LD_VAR 0 2
66050: PUSH
66051: LD_INT 1
66053: PUSH
66054: EMPTY
66055: LIST
66056: LIST
66057: PPUSH
66058: EMPTY
66059: PPUSH
66060: CALL 21521 0 3
66064: ST_TO_ADDR
66065: GO 66137
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
66067: LD_ADDR_EXP 62
66071: PUSH
66072: LD_EXP 62
66076: PPUSH
66077: LD_VAR 0 2
66081: PUSH
66082: LD_INT 1
66084: PUSH
66085: EMPTY
66086: LIST
66087: LIST
66088: PPUSH
66089: LD_EXP 62
66093: PUSH
66094: LD_VAR 0 2
66098: ARRAY
66099: PUSH
66100: LD_INT 1
66102: ARRAY
66103: PPUSH
66104: LD_INT 3
66106: PUSH
66107: LD_INT 24
66109: PUSH
66110: LD_INT 1000
66112: PUSH
66113: EMPTY
66114: LIST
66115: LIST
66116: PUSH
66117: EMPTY
66118: LIST
66119: LIST
66120: PPUSH
66121: CALL_OW 72
66125: PUSH
66126: LD_VAR 0 6
66130: UNION
66131: PPUSH
66132: CALL 21521 0 3
66136: ST_TO_ADDR
// if not need_heal_2 then
66137: LD_VAR 0 7
66141: NOT
66142: IFFALSE 66175
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
66144: LD_ADDR_EXP 62
66148: PUSH
66149: LD_EXP 62
66153: PPUSH
66154: LD_VAR 0 2
66158: PUSH
66159: LD_INT 2
66161: PUSH
66162: EMPTY
66163: LIST
66164: LIST
66165: PPUSH
66166: EMPTY
66167: PPUSH
66168: CALL 21521 0 3
66172: ST_TO_ADDR
66173: GO 66207
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
66175: LD_ADDR_EXP 62
66179: PUSH
66180: LD_EXP 62
66184: PPUSH
66185: LD_VAR 0 2
66189: PUSH
66190: LD_INT 2
66192: PUSH
66193: EMPTY
66194: LIST
66195: LIST
66196: PPUSH
66197: LD_VAR 0 7
66201: PPUSH
66202: CALL 21521 0 3
66206: ST_TO_ADDR
// if need_heal_2 then
66207: LD_VAR 0 7
66211: IFFALSE 66383
// for j in need_heal_2 do
66213: LD_ADDR_VAR 0 3
66217: PUSH
66218: LD_VAR 0 7
66222: PUSH
66223: FOR_IN
66224: IFFALSE 66381
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
66226: LD_ADDR_VAR 0 5
66230: PUSH
66231: LD_EXP 59
66235: PUSH
66236: LD_VAR 0 2
66240: ARRAY
66241: PPUSH
66242: LD_INT 2
66244: PUSH
66245: LD_INT 30
66247: PUSH
66248: LD_INT 6
66250: PUSH
66251: EMPTY
66252: LIST
66253: LIST
66254: PUSH
66255: LD_INT 30
66257: PUSH
66258: LD_INT 7
66260: PUSH
66261: EMPTY
66262: LIST
66263: LIST
66264: PUSH
66265: LD_INT 30
66267: PUSH
66268: LD_INT 8
66270: PUSH
66271: EMPTY
66272: LIST
66273: LIST
66274: PUSH
66275: LD_INT 30
66277: PUSH
66278: LD_INT 0
66280: PUSH
66281: EMPTY
66282: LIST
66283: LIST
66284: PUSH
66285: LD_INT 30
66287: PUSH
66288: LD_INT 1
66290: PUSH
66291: EMPTY
66292: LIST
66293: LIST
66294: PUSH
66295: LD_INT 25
66297: PUSH
66298: LD_INT 4
66300: PUSH
66301: EMPTY
66302: LIST
66303: LIST
66304: PUSH
66305: EMPTY
66306: LIST
66307: LIST
66308: LIST
66309: LIST
66310: LIST
66311: LIST
66312: LIST
66313: PPUSH
66314: CALL_OW 72
66318: ST_TO_ADDR
// if tmp then
66319: LD_VAR 0 5
66323: IFFALSE 66379
// begin k := NearestUnitToUnit ( tmp , j ) ;
66325: LD_ADDR_VAR 0 4
66329: PUSH
66330: LD_VAR 0 5
66334: PPUSH
66335: LD_VAR 0 3
66339: PPUSH
66340: CALL_OW 74
66344: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
66345: LD_VAR 0 3
66349: PPUSH
66350: LD_VAR 0 4
66354: PPUSH
66355: CALL_OW 296
66359: PUSH
66360: LD_INT 7
66362: GREATER
66363: IFFALSE 66379
// ComMoveUnit ( j , k ) ;
66365: LD_VAR 0 3
66369: PPUSH
66370: LD_VAR 0 4
66374: PPUSH
66375: CALL_OW 112
// end ; end ;
66379: GO 66223
66381: POP
66382: POP
// if not need_heal_1 and not need_heal_2 then
66383: LD_VAR 0 6
66387: NOT
66388: PUSH
66389: LD_VAR 0 7
66393: NOT
66394: AND
66395: IFFALSE 66399
// continue ;
66397: GO 65852
// end ;
66399: GO 65852
66401: POP
66402: POP
// RaiseSailEvent ( 102 ) ;
66403: LD_INT 102
66405: PPUSH
66406: CALL_OW 427
// end ;
66410: LD_VAR 0 1
66414: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
66415: LD_INT 0
66417: PPUSH
66418: PPUSH
66419: PPUSH
66420: PPUSH
66421: PPUSH
66422: PPUSH
66423: PPUSH
66424: PPUSH
// if not mc_bases then
66425: LD_EXP 59
66429: NOT
66430: IFFALSE 66434
// exit ;
66432: GO 67274
// for i = 1 to mc_bases do
66434: LD_ADDR_VAR 0 2
66438: PUSH
66439: DOUBLE
66440: LD_INT 1
66442: DEC
66443: ST_TO_ADDR
66444: LD_EXP 59
66448: PUSH
66449: FOR_TO
66450: IFFALSE 67272
// begin if not mc_building_need_repair [ i ] then
66452: LD_EXP 60
66456: PUSH
66457: LD_VAR 0 2
66461: ARRAY
66462: NOT
66463: IFFALSE 66637
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
66465: LD_ADDR_VAR 0 6
66469: PUSH
66470: LD_EXP 78
66474: PUSH
66475: LD_VAR 0 2
66479: ARRAY
66480: PPUSH
66481: LD_INT 3
66483: PUSH
66484: LD_INT 24
66486: PUSH
66487: LD_INT 1000
66489: PUSH
66490: EMPTY
66491: LIST
66492: LIST
66493: PUSH
66494: EMPTY
66495: LIST
66496: LIST
66497: PUSH
66498: LD_INT 2
66500: PUSH
66501: LD_INT 34
66503: PUSH
66504: LD_INT 13
66506: PUSH
66507: EMPTY
66508: LIST
66509: LIST
66510: PUSH
66511: LD_INT 34
66513: PUSH
66514: LD_INT 52
66516: PUSH
66517: EMPTY
66518: LIST
66519: LIST
66520: PUSH
66521: EMPTY
66522: LIST
66523: LIST
66524: LIST
66525: PUSH
66526: EMPTY
66527: LIST
66528: LIST
66529: PPUSH
66530: CALL_OW 72
66534: ST_TO_ADDR
// if cranes then
66535: LD_VAR 0 6
66539: IFFALSE 66601
// for j in cranes do
66541: LD_ADDR_VAR 0 3
66545: PUSH
66546: LD_VAR 0 6
66550: PUSH
66551: FOR_IN
66552: IFFALSE 66599
// if not IsInArea ( j , mc_parking [ i ] ) then
66554: LD_VAR 0 3
66558: PPUSH
66559: LD_EXP 83
66563: PUSH
66564: LD_VAR 0 2
66568: ARRAY
66569: PPUSH
66570: CALL_OW 308
66574: NOT
66575: IFFALSE 66597
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66577: LD_VAR 0 3
66581: PPUSH
66582: LD_EXP 83
66586: PUSH
66587: LD_VAR 0 2
66591: ARRAY
66592: PPUSH
66593: CALL_OW 113
66597: GO 66551
66599: POP
66600: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
66601: LD_ADDR_EXP 61
66605: PUSH
66606: LD_EXP 61
66610: PPUSH
66611: LD_VAR 0 2
66615: PPUSH
66616: EMPTY
66617: PPUSH
66618: CALL_OW 1
66622: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
66623: LD_VAR 0 2
66627: PPUSH
66628: LD_INT 101
66630: PPUSH
66631: CALL 61527 0 2
// continue ;
66635: GO 66449
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
66637: LD_ADDR_EXP 65
66641: PUSH
66642: LD_EXP 65
66646: PPUSH
66647: LD_VAR 0 2
66651: PPUSH
66652: EMPTY
66653: PPUSH
66654: CALL_OW 1
66658: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66659: LD_VAR 0 2
66663: PPUSH
66664: LD_INT 103
66666: PPUSH
66667: CALL 61527 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
66671: LD_ADDR_VAR 0 5
66675: PUSH
66676: LD_EXP 59
66680: PUSH
66681: LD_VAR 0 2
66685: ARRAY
66686: PUSH
66687: LD_EXP 88
66691: PUSH
66692: LD_VAR 0 2
66696: ARRAY
66697: UNION
66698: PPUSH
66699: LD_INT 2
66701: PUSH
66702: LD_INT 25
66704: PUSH
66705: LD_INT 2
66707: PUSH
66708: EMPTY
66709: LIST
66710: LIST
66711: PUSH
66712: LD_INT 25
66714: PUSH
66715: LD_INT 16
66717: PUSH
66718: EMPTY
66719: LIST
66720: LIST
66721: PUSH
66722: EMPTY
66723: LIST
66724: LIST
66725: LIST
66726: PUSH
66727: EMPTY
66728: LIST
66729: PPUSH
66730: CALL_OW 72
66734: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
66735: LD_ADDR_VAR 0 6
66739: PUSH
66740: LD_EXP 78
66744: PUSH
66745: LD_VAR 0 2
66749: ARRAY
66750: PPUSH
66751: LD_INT 2
66753: PUSH
66754: LD_INT 34
66756: PUSH
66757: LD_INT 13
66759: PUSH
66760: EMPTY
66761: LIST
66762: LIST
66763: PUSH
66764: LD_INT 34
66766: PUSH
66767: LD_INT 52
66769: PUSH
66770: EMPTY
66771: LIST
66772: LIST
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: LIST
66778: PPUSH
66779: CALL_OW 72
66783: ST_TO_ADDR
// if cranes then
66784: LD_VAR 0 6
66788: IFFALSE 66924
// begin for j in cranes do
66790: LD_ADDR_VAR 0 3
66794: PUSH
66795: LD_VAR 0 6
66799: PUSH
66800: FOR_IN
66801: IFFALSE 66922
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
66803: LD_VAR 0 3
66807: PPUSH
66808: CALL_OW 256
66812: PUSH
66813: LD_INT 500
66815: GREATEREQUAL
66816: PUSH
66817: LD_VAR 0 3
66821: PPUSH
66822: CALL_OW 314
66826: NOT
66827: AND
66828: IFFALSE 66862
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
66830: LD_VAR 0 3
66834: PPUSH
66835: LD_EXP 60
66839: PUSH
66840: LD_VAR 0 2
66844: ARRAY
66845: PPUSH
66846: LD_VAR 0 3
66850: PPUSH
66851: CALL_OW 74
66855: PPUSH
66856: CALL_OW 130
66860: GO 66920
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66862: LD_VAR 0 3
66866: PPUSH
66867: CALL_OW 256
66871: PUSH
66872: LD_INT 500
66874: LESS
66875: PUSH
66876: LD_VAR 0 3
66880: PPUSH
66881: LD_EXP 83
66885: PUSH
66886: LD_VAR 0 2
66890: ARRAY
66891: PPUSH
66892: CALL_OW 308
66896: NOT
66897: AND
66898: IFFALSE 66920
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66900: LD_VAR 0 3
66904: PPUSH
66905: LD_EXP 83
66909: PUSH
66910: LD_VAR 0 2
66914: ARRAY
66915: PPUSH
66916: CALL_OW 113
66920: GO 66800
66922: POP
66923: POP
// end ; if not tmp then
66924: LD_VAR 0 5
66928: NOT
66929: IFFALSE 66933
// continue ;
66931: GO 66449
// for j in tmp do
66933: LD_ADDR_VAR 0 3
66937: PUSH
66938: LD_VAR 0 5
66942: PUSH
66943: FOR_IN
66944: IFFALSE 67268
// begin if mc_need_heal [ i ] then
66946: LD_EXP 62
66950: PUSH
66951: LD_VAR 0 2
66955: ARRAY
66956: IFFALSE 67004
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
66958: LD_VAR 0 3
66962: PUSH
66963: LD_EXP 62
66967: PUSH
66968: LD_VAR 0 2
66972: ARRAY
66973: PUSH
66974: LD_INT 1
66976: ARRAY
66977: IN
66978: PUSH
66979: LD_VAR 0 3
66983: PUSH
66984: LD_EXP 62
66988: PUSH
66989: LD_VAR 0 2
66993: ARRAY
66994: PUSH
66995: LD_INT 2
66997: ARRAY
66998: IN
66999: OR
67000: IFFALSE 67004
// continue ;
67002: GO 66943
// if IsInUnit ( j ) then
67004: LD_VAR 0 3
67008: PPUSH
67009: CALL_OW 310
67013: IFFALSE 67024
// ComExitBuilding ( j ) ;
67015: LD_VAR 0 3
67019: PPUSH
67020: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
67024: LD_VAR 0 3
67028: PUSH
67029: LD_EXP 61
67033: PUSH
67034: LD_VAR 0 2
67038: ARRAY
67039: IN
67040: NOT
67041: IFFALSE 67099
// begin SetTag ( j , 101 ) ;
67043: LD_VAR 0 3
67047: PPUSH
67048: LD_INT 101
67050: PPUSH
67051: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
67055: LD_ADDR_EXP 61
67059: PUSH
67060: LD_EXP 61
67064: PPUSH
67065: LD_VAR 0 2
67069: PUSH
67070: LD_EXP 61
67074: PUSH
67075: LD_VAR 0 2
67079: ARRAY
67080: PUSH
67081: LD_INT 1
67083: PLUS
67084: PUSH
67085: EMPTY
67086: LIST
67087: LIST
67088: PPUSH
67089: LD_VAR 0 3
67093: PPUSH
67094: CALL 21521 0 3
67098: ST_TO_ADDR
// end ; wait ( 1 ) ;
67099: LD_INT 1
67101: PPUSH
67102: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
67106: LD_ADDR_VAR 0 7
67110: PUSH
67111: LD_EXP 60
67115: PUSH
67116: LD_VAR 0 2
67120: ARRAY
67121: ST_TO_ADDR
// if mc_scan [ i ] then
67122: LD_EXP 82
67126: PUSH
67127: LD_VAR 0 2
67131: ARRAY
67132: IFFALSE 67201
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
67134: LD_ADDR_VAR 0 7
67138: PUSH
67139: LD_EXP 60
67143: PUSH
67144: LD_VAR 0 2
67148: ARRAY
67149: PPUSH
67150: LD_INT 3
67152: PUSH
67153: LD_INT 2
67155: PUSH
67156: LD_INT 30
67158: PUSH
67159: LD_INT 32
67161: PUSH
67162: EMPTY
67163: LIST
67164: LIST
67165: PUSH
67166: LD_INT 30
67168: PUSH
67169: LD_INT 33
67171: PUSH
67172: EMPTY
67173: LIST
67174: LIST
67175: PUSH
67176: LD_INT 30
67178: PUSH
67179: LD_INT 31
67181: PUSH
67182: EMPTY
67183: LIST
67184: LIST
67185: PUSH
67186: EMPTY
67187: LIST
67188: LIST
67189: LIST
67190: LIST
67191: PUSH
67192: EMPTY
67193: LIST
67194: LIST
67195: PPUSH
67196: CALL_OW 72
67200: ST_TO_ADDR
// if not to_repair_tmp then
67201: LD_VAR 0 7
67205: NOT
67206: IFFALSE 67210
// continue ;
67208: GO 66943
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
67210: LD_ADDR_VAR 0 8
67214: PUSH
67215: LD_VAR 0 7
67219: PPUSH
67220: LD_VAR 0 3
67224: PPUSH
67225: CALL_OW 74
67229: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
67230: LD_VAR 0 8
67234: PPUSH
67235: LD_INT 14
67237: PPUSH
67238: CALL 24114 0 2
67242: PUSH
67243: LD_INT 4
67245: ARRAY
67246: PUSH
67247: LD_INT 5
67249: LESS
67250: IFFALSE 67266
// ComRepairBuilding ( j , to_repair ) ;
67252: LD_VAR 0 3
67256: PPUSH
67257: LD_VAR 0 8
67261: PPUSH
67262: CALL_OW 130
// end ;
67266: GO 66943
67268: POP
67269: POP
// end ;
67270: GO 66449
67272: POP
67273: POP
// end ;
67274: LD_VAR 0 1
67278: RET
// export function MC_Heal ; var i , j , tmp ; begin
67279: LD_INT 0
67281: PPUSH
67282: PPUSH
67283: PPUSH
67284: PPUSH
// if not mc_bases then
67285: LD_EXP 59
67289: NOT
67290: IFFALSE 67294
// exit ;
67292: GO 67696
// for i = 1 to mc_bases do
67294: LD_ADDR_VAR 0 2
67298: PUSH
67299: DOUBLE
67300: LD_INT 1
67302: DEC
67303: ST_TO_ADDR
67304: LD_EXP 59
67308: PUSH
67309: FOR_TO
67310: IFFALSE 67694
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
67312: LD_EXP 62
67316: PUSH
67317: LD_VAR 0 2
67321: ARRAY
67322: PUSH
67323: LD_INT 1
67325: ARRAY
67326: NOT
67327: PUSH
67328: LD_EXP 62
67332: PUSH
67333: LD_VAR 0 2
67337: ARRAY
67338: PUSH
67339: LD_INT 2
67341: ARRAY
67342: NOT
67343: AND
67344: IFFALSE 67382
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
67346: LD_ADDR_EXP 63
67350: PUSH
67351: LD_EXP 63
67355: PPUSH
67356: LD_VAR 0 2
67360: PPUSH
67361: EMPTY
67362: PPUSH
67363: CALL_OW 1
67367: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
67368: LD_VAR 0 2
67372: PPUSH
67373: LD_INT 102
67375: PPUSH
67376: CALL 61527 0 2
// continue ;
67380: GO 67309
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67382: LD_ADDR_VAR 0 4
67386: PUSH
67387: LD_EXP 59
67391: PUSH
67392: LD_VAR 0 2
67396: ARRAY
67397: PPUSH
67398: LD_INT 25
67400: PUSH
67401: LD_INT 4
67403: PUSH
67404: EMPTY
67405: LIST
67406: LIST
67407: PPUSH
67408: CALL_OW 72
67412: ST_TO_ADDR
// if not tmp then
67413: LD_VAR 0 4
67417: NOT
67418: IFFALSE 67422
// continue ;
67420: GO 67309
// if mc_taming [ i ] then
67422: LD_EXP 90
67426: PUSH
67427: LD_VAR 0 2
67431: ARRAY
67432: IFFALSE 67456
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
67434: LD_ADDR_EXP 90
67438: PUSH
67439: LD_EXP 90
67443: PPUSH
67444: LD_VAR 0 2
67448: PPUSH
67449: EMPTY
67450: PPUSH
67451: CALL_OW 1
67455: ST_TO_ADDR
// for j in tmp do
67456: LD_ADDR_VAR 0 3
67460: PUSH
67461: LD_VAR 0 4
67465: PUSH
67466: FOR_IN
67467: IFFALSE 67690
// begin if IsInUnit ( j ) then
67469: LD_VAR 0 3
67473: PPUSH
67474: CALL_OW 310
67478: IFFALSE 67489
// ComExitBuilding ( j ) ;
67480: LD_VAR 0 3
67484: PPUSH
67485: CALL_OW 122
// if not j in mc_healers [ i ] then
67489: LD_VAR 0 3
67493: PUSH
67494: LD_EXP 63
67498: PUSH
67499: LD_VAR 0 2
67503: ARRAY
67504: IN
67505: NOT
67506: IFFALSE 67552
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
67508: LD_ADDR_EXP 63
67512: PUSH
67513: LD_EXP 63
67517: PPUSH
67518: LD_VAR 0 2
67522: PUSH
67523: LD_EXP 63
67527: PUSH
67528: LD_VAR 0 2
67532: ARRAY
67533: PUSH
67534: LD_INT 1
67536: PLUS
67537: PUSH
67538: EMPTY
67539: LIST
67540: LIST
67541: PPUSH
67542: LD_VAR 0 3
67546: PPUSH
67547: CALL 21521 0 3
67551: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
67552: LD_VAR 0 3
67556: PPUSH
67557: CALL_OW 110
67561: PUSH
67562: LD_INT 102
67564: NONEQUAL
67565: IFFALSE 67579
// SetTag ( j , 102 ) ;
67567: LD_VAR 0 3
67571: PPUSH
67572: LD_INT 102
67574: PPUSH
67575: CALL_OW 109
// Wait ( 3 ) ;
67579: LD_INT 3
67581: PPUSH
67582: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
67586: LD_EXP 62
67590: PUSH
67591: LD_VAR 0 2
67595: ARRAY
67596: PUSH
67597: LD_INT 1
67599: ARRAY
67600: IFFALSE 67632
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
67602: LD_VAR 0 3
67606: PPUSH
67607: LD_EXP 62
67611: PUSH
67612: LD_VAR 0 2
67616: ARRAY
67617: PUSH
67618: LD_INT 1
67620: ARRAY
67621: PUSH
67622: LD_INT 1
67624: ARRAY
67625: PPUSH
67626: CALL_OW 128
67630: GO 67688
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
67632: LD_VAR 0 3
67636: PPUSH
67637: CALL_OW 314
67641: NOT
67642: PUSH
67643: LD_EXP 62
67647: PUSH
67648: LD_VAR 0 2
67652: ARRAY
67653: PUSH
67654: LD_INT 2
67656: ARRAY
67657: AND
67658: IFFALSE 67688
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
67660: LD_VAR 0 3
67664: PPUSH
67665: LD_EXP 62
67669: PUSH
67670: LD_VAR 0 2
67674: ARRAY
67675: PUSH
67676: LD_INT 2
67678: ARRAY
67679: PUSH
67680: LD_INT 1
67682: ARRAY
67683: PPUSH
67684: CALL_OW 128
// end ;
67688: GO 67466
67690: POP
67691: POP
// end ;
67692: GO 67309
67694: POP
67695: POP
// end ;
67696: LD_VAR 0 1
67700: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
67701: LD_INT 0
67703: PPUSH
67704: PPUSH
67705: PPUSH
67706: PPUSH
67707: PPUSH
// if not mc_bases then
67708: LD_EXP 59
67712: NOT
67713: IFFALSE 67717
// exit ;
67715: GO 68860
// for i = 1 to mc_bases do
67717: LD_ADDR_VAR 0 2
67721: PUSH
67722: DOUBLE
67723: LD_INT 1
67725: DEC
67726: ST_TO_ADDR
67727: LD_EXP 59
67731: PUSH
67732: FOR_TO
67733: IFFALSE 68858
// begin if mc_scan [ i ] then
67735: LD_EXP 82
67739: PUSH
67740: LD_VAR 0 2
67744: ARRAY
67745: IFFALSE 67749
// continue ;
67747: GO 67732
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
67749: LD_EXP 64
67753: PUSH
67754: LD_VAR 0 2
67758: ARRAY
67759: NOT
67760: PUSH
67761: LD_EXP 66
67765: PUSH
67766: LD_VAR 0 2
67770: ARRAY
67771: NOT
67772: AND
67773: PUSH
67774: LD_EXP 65
67778: PUSH
67779: LD_VAR 0 2
67783: ARRAY
67784: AND
67785: IFFALSE 67823
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
67787: LD_ADDR_EXP 65
67791: PUSH
67792: LD_EXP 65
67796: PPUSH
67797: LD_VAR 0 2
67801: PPUSH
67802: EMPTY
67803: PPUSH
67804: CALL_OW 1
67808: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67809: LD_VAR 0 2
67813: PPUSH
67814: LD_INT 103
67816: PPUSH
67817: CALL 61527 0 2
// continue ;
67821: GO 67732
// end ; if mc_construct_list [ i ] then
67823: LD_EXP 66
67827: PUSH
67828: LD_VAR 0 2
67832: ARRAY
67833: IFFALSE 68053
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67835: LD_ADDR_VAR 0 4
67839: PUSH
67840: LD_EXP 59
67844: PUSH
67845: LD_VAR 0 2
67849: ARRAY
67850: PPUSH
67851: LD_INT 25
67853: PUSH
67854: LD_INT 2
67856: PUSH
67857: EMPTY
67858: LIST
67859: LIST
67860: PPUSH
67861: CALL_OW 72
67865: PUSH
67866: LD_EXP 61
67870: PUSH
67871: LD_VAR 0 2
67875: ARRAY
67876: DIFF
67877: ST_TO_ADDR
// if not tmp then
67878: LD_VAR 0 4
67882: NOT
67883: IFFALSE 67887
// continue ;
67885: GO 67732
// for j in tmp do
67887: LD_ADDR_VAR 0 3
67891: PUSH
67892: LD_VAR 0 4
67896: PUSH
67897: FOR_IN
67898: IFFALSE 68049
// begin if not mc_builders [ i ] then
67900: LD_EXP 65
67904: PUSH
67905: LD_VAR 0 2
67909: ARRAY
67910: NOT
67911: IFFALSE 67969
// begin SetTag ( j , 103 ) ;
67913: LD_VAR 0 3
67917: PPUSH
67918: LD_INT 103
67920: PPUSH
67921: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67925: LD_ADDR_EXP 65
67929: PUSH
67930: LD_EXP 65
67934: PPUSH
67935: LD_VAR 0 2
67939: PUSH
67940: LD_EXP 65
67944: PUSH
67945: LD_VAR 0 2
67949: ARRAY
67950: PUSH
67951: LD_INT 1
67953: PLUS
67954: PUSH
67955: EMPTY
67956: LIST
67957: LIST
67958: PPUSH
67959: LD_VAR 0 3
67963: PPUSH
67964: CALL 21521 0 3
67968: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67969: LD_VAR 0 3
67973: PPUSH
67974: CALL_OW 310
67978: IFFALSE 67989
// ComExitBuilding ( j ) ;
67980: LD_VAR 0 3
67984: PPUSH
67985: CALL_OW 122
// wait ( 3 ) ;
67989: LD_INT 3
67991: PPUSH
67992: CALL_OW 67
// if not mc_construct_list [ i ] then
67996: LD_EXP 66
68000: PUSH
68001: LD_VAR 0 2
68005: ARRAY
68006: NOT
68007: IFFALSE 68011
// break ;
68009: GO 68049
// if not HasTask ( j ) then
68011: LD_VAR 0 3
68015: PPUSH
68016: CALL_OW 314
68020: NOT
68021: IFFALSE 68047
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
68023: LD_VAR 0 3
68027: PPUSH
68028: LD_EXP 66
68032: PUSH
68033: LD_VAR 0 2
68037: ARRAY
68038: PUSH
68039: LD_INT 1
68041: ARRAY
68042: PPUSH
68043: CALL 24372 0 2
// end ;
68047: GO 67897
68049: POP
68050: POP
// end else
68051: GO 68856
// if mc_build_list [ i ] then
68053: LD_EXP 64
68057: PUSH
68058: LD_VAR 0 2
68062: ARRAY
68063: IFFALSE 68856
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68065: LD_ADDR_VAR 0 5
68069: PUSH
68070: LD_EXP 59
68074: PUSH
68075: LD_VAR 0 2
68079: ARRAY
68080: PPUSH
68081: LD_INT 2
68083: PUSH
68084: LD_INT 30
68086: PUSH
68087: LD_INT 0
68089: PUSH
68090: EMPTY
68091: LIST
68092: LIST
68093: PUSH
68094: LD_INT 30
68096: PUSH
68097: LD_INT 1
68099: PUSH
68100: EMPTY
68101: LIST
68102: LIST
68103: PUSH
68104: EMPTY
68105: LIST
68106: LIST
68107: LIST
68108: PPUSH
68109: CALL_OW 72
68113: ST_TO_ADDR
// if depot then
68114: LD_VAR 0 5
68118: IFFALSE 68136
// depot := depot [ 1 ] else
68120: LD_ADDR_VAR 0 5
68124: PUSH
68125: LD_VAR 0 5
68129: PUSH
68130: LD_INT 1
68132: ARRAY
68133: ST_TO_ADDR
68134: GO 68144
// depot := 0 ;
68136: LD_ADDR_VAR 0 5
68140: PUSH
68141: LD_INT 0
68143: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
68144: LD_EXP 64
68148: PUSH
68149: LD_VAR 0 2
68153: ARRAY
68154: PUSH
68155: LD_INT 1
68157: ARRAY
68158: PUSH
68159: LD_INT 1
68161: ARRAY
68162: PPUSH
68163: CALL 24202 0 1
68167: PUSH
68168: LD_EXP 59
68172: PUSH
68173: LD_VAR 0 2
68177: ARRAY
68178: PPUSH
68179: LD_INT 2
68181: PUSH
68182: LD_INT 30
68184: PUSH
68185: LD_INT 2
68187: PUSH
68188: EMPTY
68189: LIST
68190: LIST
68191: PUSH
68192: LD_INT 30
68194: PUSH
68195: LD_INT 3
68197: PUSH
68198: EMPTY
68199: LIST
68200: LIST
68201: PUSH
68202: EMPTY
68203: LIST
68204: LIST
68205: LIST
68206: PPUSH
68207: CALL_OW 72
68211: NOT
68212: AND
68213: IFFALSE 68318
// begin for j = 1 to mc_build_list [ i ] do
68215: LD_ADDR_VAR 0 3
68219: PUSH
68220: DOUBLE
68221: LD_INT 1
68223: DEC
68224: ST_TO_ADDR
68225: LD_EXP 64
68229: PUSH
68230: LD_VAR 0 2
68234: ARRAY
68235: PUSH
68236: FOR_TO
68237: IFFALSE 68316
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
68239: LD_EXP 64
68243: PUSH
68244: LD_VAR 0 2
68248: ARRAY
68249: PUSH
68250: LD_VAR 0 3
68254: ARRAY
68255: PUSH
68256: LD_INT 1
68258: ARRAY
68259: PUSH
68260: LD_INT 2
68262: EQUAL
68263: IFFALSE 68314
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
68265: LD_ADDR_EXP 64
68269: PUSH
68270: LD_EXP 64
68274: PPUSH
68275: LD_VAR 0 2
68279: PPUSH
68280: LD_EXP 64
68284: PUSH
68285: LD_VAR 0 2
68289: ARRAY
68290: PPUSH
68291: LD_VAR 0 3
68295: PPUSH
68296: LD_INT 1
68298: PPUSH
68299: LD_INT 0
68301: PPUSH
68302: CALL 20939 0 4
68306: PPUSH
68307: CALL_OW 1
68311: ST_TO_ADDR
// break ;
68312: GO 68316
// end ;
68314: GO 68236
68316: POP
68317: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
68318: LD_EXP 64
68322: PUSH
68323: LD_VAR 0 2
68327: ARRAY
68328: PUSH
68329: LD_INT 1
68331: ARRAY
68332: PUSH
68333: LD_INT 1
68335: ARRAY
68336: PUSH
68337: LD_INT 0
68339: EQUAL
68340: PUSH
68341: LD_VAR 0 5
68345: PUSH
68346: LD_VAR 0 5
68350: PPUSH
68351: LD_EXP 64
68355: PUSH
68356: LD_VAR 0 2
68360: ARRAY
68361: PUSH
68362: LD_INT 1
68364: ARRAY
68365: PUSH
68366: LD_INT 1
68368: ARRAY
68369: PPUSH
68370: LD_EXP 64
68374: PUSH
68375: LD_VAR 0 2
68379: ARRAY
68380: PUSH
68381: LD_INT 1
68383: ARRAY
68384: PUSH
68385: LD_INT 2
68387: ARRAY
68388: PPUSH
68389: LD_EXP 64
68393: PUSH
68394: LD_VAR 0 2
68398: ARRAY
68399: PUSH
68400: LD_INT 1
68402: ARRAY
68403: PUSH
68404: LD_INT 3
68406: ARRAY
68407: PPUSH
68408: LD_EXP 64
68412: PUSH
68413: LD_VAR 0 2
68417: ARRAY
68418: PUSH
68419: LD_INT 1
68421: ARRAY
68422: PUSH
68423: LD_INT 4
68425: ARRAY
68426: PPUSH
68427: CALL 28936 0 5
68431: AND
68432: OR
68433: IFFALSE 68714
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
68435: LD_ADDR_VAR 0 4
68439: PUSH
68440: LD_EXP 59
68444: PUSH
68445: LD_VAR 0 2
68449: ARRAY
68450: PPUSH
68451: LD_INT 25
68453: PUSH
68454: LD_INT 2
68456: PUSH
68457: EMPTY
68458: LIST
68459: LIST
68460: PPUSH
68461: CALL_OW 72
68465: PUSH
68466: LD_EXP 61
68470: PUSH
68471: LD_VAR 0 2
68475: ARRAY
68476: DIFF
68477: ST_TO_ADDR
// if not tmp then
68478: LD_VAR 0 4
68482: NOT
68483: IFFALSE 68487
// continue ;
68485: GO 67732
// for j in tmp do
68487: LD_ADDR_VAR 0 3
68491: PUSH
68492: LD_VAR 0 4
68496: PUSH
68497: FOR_IN
68498: IFFALSE 68710
// begin if not mc_builders [ i ] then
68500: LD_EXP 65
68504: PUSH
68505: LD_VAR 0 2
68509: ARRAY
68510: NOT
68511: IFFALSE 68569
// begin SetTag ( j , 103 ) ;
68513: LD_VAR 0 3
68517: PPUSH
68518: LD_INT 103
68520: PPUSH
68521: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68525: LD_ADDR_EXP 65
68529: PUSH
68530: LD_EXP 65
68534: PPUSH
68535: LD_VAR 0 2
68539: PUSH
68540: LD_EXP 65
68544: PUSH
68545: LD_VAR 0 2
68549: ARRAY
68550: PUSH
68551: LD_INT 1
68553: PLUS
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: PPUSH
68559: LD_VAR 0 3
68563: PPUSH
68564: CALL 21521 0 3
68568: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68569: LD_VAR 0 3
68573: PPUSH
68574: CALL_OW 310
68578: IFFALSE 68589
// ComExitBuilding ( j ) ;
68580: LD_VAR 0 3
68584: PPUSH
68585: CALL_OW 122
// wait ( 3 ) ;
68589: LD_INT 3
68591: PPUSH
68592: CALL_OW 67
// if not mc_build_list [ i ] then
68596: LD_EXP 64
68600: PUSH
68601: LD_VAR 0 2
68605: ARRAY
68606: NOT
68607: IFFALSE 68611
// break ;
68609: GO 68710
// if not HasTask ( j ) then
68611: LD_VAR 0 3
68615: PPUSH
68616: CALL_OW 314
68620: NOT
68621: IFFALSE 68708
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
68623: LD_VAR 0 3
68627: PPUSH
68628: LD_EXP 64
68632: PUSH
68633: LD_VAR 0 2
68637: ARRAY
68638: PUSH
68639: LD_INT 1
68641: ARRAY
68642: PUSH
68643: LD_INT 1
68645: ARRAY
68646: PPUSH
68647: LD_EXP 64
68651: PUSH
68652: LD_VAR 0 2
68656: ARRAY
68657: PUSH
68658: LD_INT 1
68660: ARRAY
68661: PUSH
68662: LD_INT 2
68664: ARRAY
68665: PPUSH
68666: LD_EXP 64
68670: PUSH
68671: LD_VAR 0 2
68675: ARRAY
68676: PUSH
68677: LD_INT 1
68679: ARRAY
68680: PUSH
68681: LD_INT 3
68683: ARRAY
68684: PPUSH
68685: LD_EXP 64
68689: PUSH
68690: LD_VAR 0 2
68694: ARRAY
68695: PUSH
68696: LD_INT 1
68698: ARRAY
68699: PUSH
68700: LD_INT 4
68702: ARRAY
68703: PPUSH
68704: CALL_OW 145
// end ;
68708: GO 68497
68710: POP
68711: POP
// end else
68712: GO 68856
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
68714: LD_EXP 59
68718: PUSH
68719: LD_VAR 0 2
68723: ARRAY
68724: PPUSH
68725: LD_EXP 64
68729: PUSH
68730: LD_VAR 0 2
68734: ARRAY
68735: PUSH
68736: LD_INT 1
68738: ARRAY
68739: PUSH
68740: LD_INT 1
68742: ARRAY
68743: PPUSH
68744: LD_EXP 64
68748: PUSH
68749: LD_VAR 0 2
68753: ARRAY
68754: PUSH
68755: LD_INT 1
68757: ARRAY
68758: PUSH
68759: LD_INT 2
68761: ARRAY
68762: PPUSH
68763: LD_EXP 64
68767: PUSH
68768: LD_VAR 0 2
68772: ARRAY
68773: PUSH
68774: LD_INT 1
68776: ARRAY
68777: PUSH
68778: LD_INT 3
68780: ARRAY
68781: PPUSH
68782: LD_EXP 64
68786: PUSH
68787: LD_VAR 0 2
68791: ARRAY
68792: PUSH
68793: LD_INT 1
68795: ARRAY
68796: PUSH
68797: LD_INT 4
68799: ARRAY
68800: PPUSH
68801: CALL 28272 0 5
68805: NOT
68806: IFFALSE 68856
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
68808: LD_ADDR_EXP 64
68812: PUSH
68813: LD_EXP 64
68817: PPUSH
68818: LD_VAR 0 2
68822: PPUSH
68823: LD_EXP 64
68827: PUSH
68828: LD_VAR 0 2
68832: ARRAY
68833: PPUSH
68834: LD_INT 1
68836: PPUSH
68837: LD_INT 1
68839: NEG
68840: PPUSH
68841: LD_INT 0
68843: PPUSH
68844: CALL 20939 0 4
68848: PPUSH
68849: CALL_OW 1
68853: ST_TO_ADDR
// continue ;
68854: GO 67732
// end ; end ; end ;
68856: GO 67732
68858: POP
68859: POP
// end ;
68860: LD_VAR 0 1
68864: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
68865: LD_INT 0
68867: PPUSH
68868: PPUSH
68869: PPUSH
68870: PPUSH
68871: PPUSH
68872: PPUSH
// if not mc_bases then
68873: LD_EXP 59
68877: NOT
68878: IFFALSE 68882
// exit ;
68880: GO 69309
// for i = 1 to mc_bases do
68882: LD_ADDR_VAR 0 2
68886: PUSH
68887: DOUBLE
68888: LD_INT 1
68890: DEC
68891: ST_TO_ADDR
68892: LD_EXP 59
68896: PUSH
68897: FOR_TO
68898: IFFALSE 69307
// begin tmp := mc_build_upgrade [ i ] ;
68900: LD_ADDR_VAR 0 4
68904: PUSH
68905: LD_EXP 91
68909: PUSH
68910: LD_VAR 0 2
68914: ARRAY
68915: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68916: LD_ADDR_VAR 0 6
68920: PUSH
68921: LD_EXP 92
68925: PUSH
68926: LD_VAR 0 2
68930: ARRAY
68931: PPUSH
68932: LD_INT 2
68934: PUSH
68935: LD_INT 30
68937: PUSH
68938: LD_INT 6
68940: PUSH
68941: EMPTY
68942: LIST
68943: LIST
68944: PUSH
68945: LD_INT 30
68947: PUSH
68948: LD_INT 7
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PUSH
68955: EMPTY
68956: LIST
68957: LIST
68958: LIST
68959: PPUSH
68960: CALL_OW 72
68964: ST_TO_ADDR
// if not tmp and not lab then
68965: LD_VAR 0 4
68969: NOT
68970: PUSH
68971: LD_VAR 0 6
68975: NOT
68976: AND
68977: IFFALSE 68981
// continue ;
68979: GO 68897
// if tmp then
68981: LD_VAR 0 4
68985: IFFALSE 69105
// for j in tmp do
68987: LD_ADDR_VAR 0 3
68991: PUSH
68992: LD_VAR 0 4
68996: PUSH
68997: FOR_IN
68998: IFFALSE 69103
// begin if UpgradeCost ( j ) then
69000: LD_VAR 0 3
69004: PPUSH
69005: CALL 27932 0 1
69009: IFFALSE 69101
// begin ComUpgrade ( j ) ;
69011: LD_VAR 0 3
69015: PPUSH
69016: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
69020: LD_ADDR_EXP 91
69024: PUSH
69025: LD_EXP 91
69029: PPUSH
69030: LD_VAR 0 2
69034: PPUSH
69035: LD_EXP 91
69039: PUSH
69040: LD_VAR 0 2
69044: ARRAY
69045: PUSH
69046: LD_VAR 0 3
69050: DIFF
69051: PPUSH
69052: CALL_OW 1
69056: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69057: LD_ADDR_EXP 66
69061: PUSH
69062: LD_EXP 66
69066: PPUSH
69067: LD_VAR 0 2
69071: PUSH
69072: LD_EXP 66
69076: PUSH
69077: LD_VAR 0 2
69081: ARRAY
69082: PUSH
69083: LD_INT 1
69085: PLUS
69086: PUSH
69087: EMPTY
69088: LIST
69089: LIST
69090: PPUSH
69091: LD_VAR 0 3
69095: PPUSH
69096: CALL 21521 0 3
69100: ST_TO_ADDR
// end ; end ;
69101: GO 68997
69103: POP
69104: POP
// if not lab or not mc_lab_upgrade [ i ] then
69105: LD_VAR 0 6
69109: NOT
69110: PUSH
69111: LD_EXP 93
69115: PUSH
69116: LD_VAR 0 2
69120: ARRAY
69121: NOT
69122: OR
69123: IFFALSE 69127
// continue ;
69125: GO 68897
// for j in lab do
69127: LD_ADDR_VAR 0 3
69131: PUSH
69132: LD_VAR 0 6
69136: PUSH
69137: FOR_IN
69138: IFFALSE 69303
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
69140: LD_VAR 0 3
69144: PPUSH
69145: CALL_OW 266
69149: PUSH
69150: LD_INT 6
69152: PUSH
69153: LD_INT 7
69155: PUSH
69156: EMPTY
69157: LIST
69158: LIST
69159: IN
69160: PUSH
69161: LD_VAR 0 3
69165: PPUSH
69166: CALL_OW 461
69170: PUSH
69171: LD_INT 1
69173: NONEQUAL
69174: AND
69175: IFFALSE 69301
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
69177: LD_VAR 0 3
69181: PPUSH
69182: LD_EXP 93
69186: PUSH
69187: LD_VAR 0 2
69191: ARRAY
69192: PUSH
69193: LD_INT 1
69195: ARRAY
69196: PPUSH
69197: CALL 28137 0 2
69201: IFFALSE 69301
// begin ComCancel ( j ) ;
69203: LD_VAR 0 3
69207: PPUSH
69208: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
69212: LD_VAR 0 3
69216: PPUSH
69217: LD_EXP 93
69221: PUSH
69222: LD_VAR 0 2
69226: ARRAY
69227: PUSH
69228: LD_INT 1
69230: ARRAY
69231: PPUSH
69232: CALL_OW 207
// if not j in mc_construct_list [ i ] then
69236: LD_VAR 0 3
69240: PUSH
69241: LD_EXP 66
69245: PUSH
69246: LD_VAR 0 2
69250: ARRAY
69251: IN
69252: NOT
69253: IFFALSE 69299
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69255: LD_ADDR_EXP 66
69259: PUSH
69260: LD_EXP 66
69264: PPUSH
69265: LD_VAR 0 2
69269: PUSH
69270: LD_EXP 66
69274: PUSH
69275: LD_VAR 0 2
69279: ARRAY
69280: PUSH
69281: LD_INT 1
69283: PLUS
69284: PUSH
69285: EMPTY
69286: LIST
69287: LIST
69288: PPUSH
69289: LD_VAR 0 3
69293: PPUSH
69294: CALL 21521 0 3
69298: ST_TO_ADDR
// break ;
69299: GO 69303
// end ; end ; end ;
69301: GO 69137
69303: POP
69304: POP
// end ;
69305: GO 68897
69307: POP
69308: POP
// end ;
69309: LD_VAR 0 1
69313: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
69314: LD_INT 0
69316: PPUSH
69317: PPUSH
69318: PPUSH
69319: PPUSH
69320: PPUSH
69321: PPUSH
69322: PPUSH
69323: PPUSH
69324: PPUSH
// if not mc_bases then
69325: LD_EXP 59
69329: NOT
69330: IFFALSE 69334
// exit ;
69332: GO 69739
// for i = 1 to mc_bases do
69334: LD_ADDR_VAR 0 2
69338: PUSH
69339: DOUBLE
69340: LD_INT 1
69342: DEC
69343: ST_TO_ADDR
69344: LD_EXP 59
69348: PUSH
69349: FOR_TO
69350: IFFALSE 69737
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
69352: LD_EXP 67
69356: PUSH
69357: LD_VAR 0 2
69361: ARRAY
69362: NOT
69363: PUSH
69364: LD_EXP 59
69368: PUSH
69369: LD_VAR 0 2
69373: ARRAY
69374: PPUSH
69375: LD_INT 30
69377: PUSH
69378: LD_INT 3
69380: PUSH
69381: EMPTY
69382: LIST
69383: LIST
69384: PPUSH
69385: CALL_OW 72
69389: NOT
69390: OR
69391: IFFALSE 69395
// continue ;
69393: GO 69349
// busy := false ;
69395: LD_ADDR_VAR 0 8
69399: PUSH
69400: LD_INT 0
69402: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69403: LD_ADDR_VAR 0 4
69407: PUSH
69408: LD_EXP 59
69412: PUSH
69413: LD_VAR 0 2
69417: ARRAY
69418: PPUSH
69419: LD_INT 30
69421: PUSH
69422: LD_INT 3
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: PPUSH
69429: CALL_OW 72
69433: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
69434: LD_ADDR_VAR 0 6
69438: PUSH
69439: LD_EXP 67
69443: PUSH
69444: LD_VAR 0 2
69448: ARRAY
69449: PPUSH
69450: LD_INT 2
69452: PUSH
69453: LD_INT 30
69455: PUSH
69456: LD_INT 32
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: PUSH
69463: LD_INT 30
69465: PUSH
69466: LD_INT 33
69468: PUSH
69469: EMPTY
69470: LIST
69471: LIST
69472: PUSH
69473: EMPTY
69474: LIST
69475: LIST
69476: LIST
69477: PPUSH
69478: CALL_OW 72
69482: ST_TO_ADDR
// if not t then
69483: LD_VAR 0 6
69487: NOT
69488: IFFALSE 69492
// continue ;
69490: GO 69349
// for j in tmp do
69492: LD_ADDR_VAR 0 3
69496: PUSH
69497: LD_VAR 0 4
69501: PUSH
69502: FOR_IN
69503: IFFALSE 69533
// if not BuildingStatus ( j ) = bs_idle then
69505: LD_VAR 0 3
69509: PPUSH
69510: CALL_OW 461
69514: PUSH
69515: LD_INT 2
69517: EQUAL
69518: NOT
69519: IFFALSE 69531
// begin busy := true ;
69521: LD_ADDR_VAR 0 8
69525: PUSH
69526: LD_INT 1
69528: ST_TO_ADDR
// break ;
69529: GO 69533
// end ;
69531: GO 69502
69533: POP
69534: POP
// if busy then
69535: LD_VAR 0 8
69539: IFFALSE 69543
// continue ;
69541: GO 69349
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
69543: LD_ADDR_VAR 0 7
69547: PUSH
69548: LD_VAR 0 6
69552: PPUSH
69553: LD_INT 35
69555: PUSH
69556: LD_INT 0
69558: PUSH
69559: EMPTY
69560: LIST
69561: LIST
69562: PPUSH
69563: CALL_OW 72
69567: ST_TO_ADDR
// if tw then
69568: LD_VAR 0 7
69572: IFFALSE 69649
// begin tw := tw [ 1 ] ;
69574: LD_ADDR_VAR 0 7
69578: PUSH
69579: LD_VAR 0 7
69583: PUSH
69584: LD_INT 1
69586: ARRAY
69587: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
69588: LD_ADDR_VAR 0 9
69592: PUSH
69593: LD_VAR 0 7
69597: PPUSH
69598: LD_EXP 84
69602: PUSH
69603: LD_VAR 0 2
69607: ARRAY
69608: PPUSH
69609: CALL 26491 0 2
69613: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
69614: LD_EXP 98
69618: PUSH
69619: LD_VAR 0 2
69623: ARRAY
69624: IFFALSE 69647
// if not weapon in mc_allowed_tower_weapons [ i ] then
69626: LD_VAR 0 9
69630: PUSH
69631: LD_EXP 98
69635: PUSH
69636: LD_VAR 0 2
69640: ARRAY
69641: IN
69642: NOT
69643: IFFALSE 69647
// continue ;
69645: GO 69349
// end else
69647: GO 69712
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
69649: LD_ADDR_VAR 0 5
69653: PUSH
69654: LD_EXP 67
69658: PUSH
69659: LD_VAR 0 2
69663: ARRAY
69664: PPUSH
69665: LD_VAR 0 4
69669: PPUSH
69670: CALL 56695 0 2
69674: ST_TO_ADDR
// if not tmp2 then
69675: LD_VAR 0 5
69679: NOT
69680: IFFALSE 69684
// continue ;
69682: GO 69349
// tw := tmp2 [ 1 ] ;
69684: LD_ADDR_VAR 0 7
69688: PUSH
69689: LD_VAR 0 5
69693: PUSH
69694: LD_INT 1
69696: ARRAY
69697: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
69698: LD_ADDR_VAR 0 9
69702: PUSH
69703: LD_VAR 0 5
69707: PUSH
69708: LD_INT 2
69710: ARRAY
69711: ST_TO_ADDR
// end ; if not weapon then
69712: LD_VAR 0 9
69716: NOT
69717: IFFALSE 69721
// continue ;
69719: GO 69349
// ComPlaceWeapon ( tw , weapon ) ;
69721: LD_VAR 0 7
69725: PPUSH
69726: LD_VAR 0 9
69730: PPUSH
69731: CALL_OW 148
// end ;
69735: GO 69349
69737: POP
69738: POP
// end ;
69739: LD_VAR 0 1
69743: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
69744: LD_INT 0
69746: PPUSH
69747: PPUSH
69748: PPUSH
69749: PPUSH
69750: PPUSH
69751: PPUSH
// if not mc_bases then
69752: LD_EXP 59
69756: NOT
69757: IFFALSE 69761
// exit ;
69759: GO 70537
// for i = 1 to mc_bases do
69761: LD_ADDR_VAR 0 2
69765: PUSH
69766: DOUBLE
69767: LD_INT 1
69769: DEC
69770: ST_TO_ADDR
69771: LD_EXP 59
69775: PUSH
69776: FOR_TO
69777: IFFALSE 70535
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
69779: LD_EXP 72
69783: PUSH
69784: LD_VAR 0 2
69788: ARRAY
69789: NOT
69790: PUSH
69791: LD_EXP 72
69795: PUSH
69796: LD_VAR 0 2
69800: ARRAY
69801: PUSH
69802: LD_EXP 73
69806: PUSH
69807: LD_VAR 0 2
69811: ARRAY
69812: EQUAL
69813: OR
69814: PUSH
69815: LD_EXP 82
69819: PUSH
69820: LD_VAR 0 2
69824: ARRAY
69825: OR
69826: IFFALSE 69830
// continue ;
69828: GO 69776
// if mc_miners [ i ] then
69830: LD_EXP 73
69834: PUSH
69835: LD_VAR 0 2
69839: ARRAY
69840: IFFALSE 70222
// begin for j = mc_miners [ i ] downto 1 do
69842: LD_ADDR_VAR 0 3
69846: PUSH
69847: DOUBLE
69848: LD_EXP 73
69852: PUSH
69853: LD_VAR 0 2
69857: ARRAY
69858: INC
69859: ST_TO_ADDR
69860: LD_INT 1
69862: PUSH
69863: FOR_DOWNTO
69864: IFFALSE 70220
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
69866: LD_EXP 73
69870: PUSH
69871: LD_VAR 0 2
69875: ARRAY
69876: PUSH
69877: LD_VAR 0 3
69881: ARRAY
69882: PPUSH
69883: CALL_OW 301
69887: PUSH
69888: LD_EXP 73
69892: PUSH
69893: LD_VAR 0 2
69897: ARRAY
69898: PUSH
69899: LD_VAR 0 3
69903: ARRAY
69904: PPUSH
69905: CALL_OW 257
69909: PUSH
69910: LD_INT 1
69912: NONEQUAL
69913: OR
69914: IFFALSE 69977
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69916: LD_ADDR_VAR 0 5
69920: PUSH
69921: LD_EXP 73
69925: PUSH
69926: LD_VAR 0 2
69930: ARRAY
69931: PUSH
69932: LD_EXP 73
69936: PUSH
69937: LD_VAR 0 2
69941: ARRAY
69942: PUSH
69943: LD_VAR 0 3
69947: ARRAY
69948: DIFF
69949: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69950: LD_ADDR_EXP 73
69954: PUSH
69955: LD_EXP 73
69959: PPUSH
69960: LD_VAR 0 2
69964: PPUSH
69965: LD_VAR 0 5
69969: PPUSH
69970: CALL_OW 1
69974: ST_TO_ADDR
// continue ;
69975: GO 69863
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
69977: LD_EXP 73
69981: PUSH
69982: LD_VAR 0 2
69986: ARRAY
69987: PUSH
69988: LD_VAR 0 3
69992: ARRAY
69993: PPUSH
69994: CALL_OW 257
69998: PUSH
69999: LD_INT 1
70001: EQUAL
70002: PUSH
70003: LD_EXP 73
70007: PUSH
70008: LD_VAR 0 2
70012: ARRAY
70013: PUSH
70014: LD_VAR 0 3
70018: ARRAY
70019: PPUSH
70020: CALL_OW 459
70024: NOT
70025: AND
70026: PUSH
70027: LD_EXP 73
70031: PUSH
70032: LD_VAR 0 2
70036: ARRAY
70037: PUSH
70038: LD_VAR 0 3
70042: ARRAY
70043: PPUSH
70044: CALL_OW 314
70048: NOT
70049: AND
70050: IFFALSE 70218
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
70052: LD_EXP 73
70056: PUSH
70057: LD_VAR 0 2
70061: ARRAY
70062: PUSH
70063: LD_VAR 0 3
70067: ARRAY
70068: PPUSH
70069: CALL_OW 310
70073: IFFALSE 70096
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
70075: LD_EXP 73
70079: PUSH
70080: LD_VAR 0 2
70084: ARRAY
70085: PUSH
70086: LD_VAR 0 3
70090: ARRAY
70091: PPUSH
70092: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
70096: LD_EXP 73
70100: PUSH
70101: LD_VAR 0 2
70105: ARRAY
70106: PUSH
70107: LD_VAR 0 3
70111: ARRAY
70112: PPUSH
70113: CALL_OW 314
70117: NOT
70118: IFFALSE 70218
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
70120: LD_EXP 73
70124: PUSH
70125: LD_VAR 0 2
70129: ARRAY
70130: PUSH
70131: LD_VAR 0 3
70135: ARRAY
70136: PPUSH
70137: LD_EXP 72
70141: PUSH
70142: LD_VAR 0 2
70146: ARRAY
70147: PUSH
70148: LD_VAR 0 3
70152: PUSH
70153: LD_EXP 72
70157: PUSH
70158: LD_VAR 0 2
70162: ARRAY
70163: MOD
70164: PUSH
70165: LD_INT 1
70167: PLUS
70168: ARRAY
70169: PUSH
70170: LD_INT 1
70172: ARRAY
70173: PPUSH
70174: LD_EXP 72
70178: PUSH
70179: LD_VAR 0 2
70183: ARRAY
70184: PUSH
70185: LD_VAR 0 3
70189: PUSH
70190: LD_EXP 72
70194: PUSH
70195: LD_VAR 0 2
70199: ARRAY
70200: MOD
70201: PUSH
70202: LD_INT 1
70204: PLUS
70205: ARRAY
70206: PUSH
70207: LD_INT 2
70209: ARRAY
70210: PPUSH
70211: LD_INT 0
70213: PPUSH
70214: CALL_OW 193
// end ; end ;
70218: GO 69863
70220: POP
70221: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
70222: LD_ADDR_VAR 0 5
70226: PUSH
70227: LD_EXP 59
70231: PUSH
70232: LD_VAR 0 2
70236: ARRAY
70237: PPUSH
70238: LD_INT 2
70240: PUSH
70241: LD_INT 30
70243: PUSH
70244: LD_INT 4
70246: PUSH
70247: EMPTY
70248: LIST
70249: LIST
70250: PUSH
70251: LD_INT 30
70253: PUSH
70254: LD_INT 5
70256: PUSH
70257: EMPTY
70258: LIST
70259: LIST
70260: PUSH
70261: LD_INT 30
70263: PUSH
70264: LD_INT 32
70266: PUSH
70267: EMPTY
70268: LIST
70269: LIST
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: LIST
70275: LIST
70276: PPUSH
70277: CALL_OW 72
70281: ST_TO_ADDR
// if not tmp then
70282: LD_VAR 0 5
70286: NOT
70287: IFFALSE 70291
// continue ;
70289: GO 69776
// list := [ ] ;
70291: LD_ADDR_VAR 0 6
70295: PUSH
70296: EMPTY
70297: ST_TO_ADDR
// for j in tmp do
70298: LD_ADDR_VAR 0 3
70302: PUSH
70303: LD_VAR 0 5
70307: PUSH
70308: FOR_IN
70309: IFFALSE 70378
// begin for k in UnitsInside ( j ) do
70311: LD_ADDR_VAR 0 4
70315: PUSH
70316: LD_VAR 0 3
70320: PPUSH
70321: CALL_OW 313
70325: PUSH
70326: FOR_IN
70327: IFFALSE 70374
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
70329: LD_VAR 0 4
70333: PPUSH
70334: CALL_OW 257
70338: PUSH
70339: LD_INT 1
70341: EQUAL
70342: PUSH
70343: LD_VAR 0 4
70347: PPUSH
70348: CALL_OW 459
70352: NOT
70353: AND
70354: IFFALSE 70372
// list := list ^ k ;
70356: LD_ADDR_VAR 0 6
70360: PUSH
70361: LD_VAR 0 6
70365: PUSH
70366: LD_VAR 0 4
70370: ADD
70371: ST_TO_ADDR
70372: GO 70326
70374: POP
70375: POP
// end ;
70376: GO 70308
70378: POP
70379: POP
// list := list diff mc_miners [ i ] ;
70380: LD_ADDR_VAR 0 6
70384: PUSH
70385: LD_VAR 0 6
70389: PUSH
70390: LD_EXP 73
70394: PUSH
70395: LD_VAR 0 2
70399: ARRAY
70400: DIFF
70401: ST_TO_ADDR
// if not list then
70402: LD_VAR 0 6
70406: NOT
70407: IFFALSE 70411
// continue ;
70409: GO 69776
// k := mc_mines [ i ] - mc_miners [ i ] ;
70411: LD_ADDR_VAR 0 4
70415: PUSH
70416: LD_EXP 72
70420: PUSH
70421: LD_VAR 0 2
70425: ARRAY
70426: PUSH
70427: LD_EXP 73
70431: PUSH
70432: LD_VAR 0 2
70436: ARRAY
70437: MINUS
70438: ST_TO_ADDR
// if k > list then
70439: LD_VAR 0 4
70443: PUSH
70444: LD_VAR 0 6
70448: GREATER
70449: IFFALSE 70461
// k := list ;
70451: LD_ADDR_VAR 0 4
70455: PUSH
70456: LD_VAR 0 6
70460: ST_TO_ADDR
// for j = 1 to k do
70461: LD_ADDR_VAR 0 3
70465: PUSH
70466: DOUBLE
70467: LD_INT 1
70469: DEC
70470: ST_TO_ADDR
70471: LD_VAR 0 4
70475: PUSH
70476: FOR_TO
70477: IFFALSE 70531
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
70479: LD_ADDR_EXP 73
70483: PUSH
70484: LD_EXP 73
70488: PPUSH
70489: LD_VAR 0 2
70493: PUSH
70494: LD_EXP 73
70498: PUSH
70499: LD_VAR 0 2
70503: ARRAY
70504: PUSH
70505: LD_INT 1
70507: PLUS
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: PPUSH
70513: LD_VAR 0 6
70517: PUSH
70518: LD_VAR 0 3
70522: ARRAY
70523: PPUSH
70524: CALL 21521 0 3
70528: ST_TO_ADDR
70529: GO 70476
70531: POP
70532: POP
// end ;
70533: GO 69776
70535: POP
70536: POP
// end ;
70537: LD_VAR 0 1
70541: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
70542: LD_INT 0
70544: PPUSH
70545: PPUSH
70546: PPUSH
70547: PPUSH
70548: PPUSH
70549: PPUSH
70550: PPUSH
70551: PPUSH
70552: PPUSH
70553: PPUSH
// if not mc_bases then
70554: LD_EXP 59
70558: NOT
70559: IFFALSE 70563
// exit ;
70561: GO 72313
// for i = 1 to mc_bases do
70563: LD_ADDR_VAR 0 2
70567: PUSH
70568: DOUBLE
70569: LD_INT 1
70571: DEC
70572: ST_TO_ADDR
70573: LD_EXP 59
70577: PUSH
70578: FOR_TO
70579: IFFALSE 72311
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70581: LD_EXP 59
70585: PUSH
70586: LD_VAR 0 2
70590: ARRAY
70591: NOT
70592: PUSH
70593: LD_EXP 66
70597: PUSH
70598: LD_VAR 0 2
70602: ARRAY
70603: OR
70604: IFFALSE 70608
// continue ;
70606: GO 70578
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70608: LD_EXP 75
70612: PUSH
70613: LD_VAR 0 2
70617: ARRAY
70618: NOT
70619: PUSH
70620: LD_EXP 76
70624: PUSH
70625: LD_VAR 0 2
70629: ARRAY
70630: AND
70631: IFFALSE 70669
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70633: LD_ADDR_EXP 76
70637: PUSH
70638: LD_EXP 76
70642: PPUSH
70643: LD_VAR 0 2
70647: PPUSH
70648: EMPTY
70649: PPUSH
70650: CALL_OW 1
70654: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70655: LD_VAR 0 2
70659: PPUSH
70660: LD_INT 107
70662: PPUSH
70663: CALL 61527 0 2
// continue ;
70667: GO 70578
// end ; target := [ ] ;
70669: LD_ADDR_VAR 0 6
70673: PUSH
70674: EMPTY
70675: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70676: LD_ADDR_VAR 0 3
70680: PUSH
70681: DOUBLE
70682: LD_EXP 75
70686: PUSH
70687: LD_VAR 0 2
70691: ARRAY
70692: INC
70693: ST_TO_ADDR
70694: LD_INT 1
70696: PUSH
70697: FOR_DOWNTO
70698: IFFALSE 70958
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70700: LD_EXP 75
70704: PUSH
70705: LD_VAR 0 2
70709: ARRAY
70710: PUSH
70711: LD_VAR 0 3
70715: ARRAY
70716: PUSH
70717: LD_INT 2
70719: ARRAY
70720: PPUSH
70721: LD_EXP 75
70725: PUSH
70726: LD_VAR 0 2
70730: ARRAY
70731: PUSH
70732: LD_VAR 0 3
70736: ARRAY
70737: PUSH
70738: LD_INT 3
70740: ARRAY
70741: PPUSH
70742: CALL_OW 488
70746: PUSH
70747: LD_EXP 75
70751: PUSH
70752: LD_VAR 0 2
70756: ARRAY
70757: PUSH
70758: LD_VAR 0 3
70762: ARRAY
70763: PUSH
70764: LD_INT 2
70766: ARRAY
70767: PPUSH
70768: LD_EXP 75
70772: PUSH
70773: LD_VAR 0 2
70777: ARRAY
70778: PUSH
70779: LD_VAR 0 3
70783: ARRAY
70784: PUSH
70785: LD_INT 3
70787: ARRAY
70788: PPUSH
70789: CALL_OW 284
70793: PUSH
70794: LD_INT 0
70796: EQUAL
70797: AND
70798: IFFALSE 70853
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70800: LD_ADDR_VAR 0 5
70804: PUSH
70805: LD_EXP 75
70809: PUSH
70810: LD_VAR 0 2
70814: ARRAY
70815: PPUSH
70816: LD_VAR 0 3
70820: PPUSH
70821: CALL_OW 3
70825: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70826: LD_ADDR_EXP 75
70830: PUSH
70831: LD_EXP 75
70835: PPUSH
70836: LD_VAR 0 2
70840: PPUSH
70841: LD_VAR 0 5
70845: PPUSH
70846: CALL_OW 1
70850: ST_TO_ADDR
// continue ;
70851: GO 70697
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70853: LD_EXP 59
70857: PUSH
70858: LD_VAR 0 2
70862: ARRAY
70863: PUSH
70864: LD_INT 1
70866: ARRAY
70867: PPUSH
70868: CALL_OW 255
70872: PPUSH
70873: LD_EXP 75
70877: PUSH
70878: LD_VAR 0 2
70882: ARRAY
70883: PUSH
70884: LD_VAR 0 3
70888: ARRAY
70889: PUSH
70890: LD_INT 2
70892: ARRAY
70893: PPUSH
70894: LD_EXP 75
70898: PUSH
70899: LD_VAR 0 2
70903: ARRAY
70904: PUSH
70905: LD_VAR 0 3
70909: ARRAY
70910: PUSH
70911: LD_INT 3
70913: ARRAY
70914: PPUSH
70915: LD_INT 30
70917: PPUSH
70918: CALL 22417 0 4
70922: PUSH
70923: LD_INT 4
70925: ARRAY
70926: PUSH
70927: LD_INT 0
70929: EQUAL
70930: IFFALSE 70956
// begin target := mc_crates [ i ] [ j ] ;
70932: LD_ADDR_VAR 0 6
70936: PUSH
70937: LD_EXP 75
70941: PUSH
70942: LD_VAR 0 2
70946: ARRAY
70947: PUSH
70948: LD_VAR 0 3
70952: ARRAY
70953: ST_TO_ADDR
// break ;
70954: GO 70958
// end ; end ;
70956: GO 70697
70958: POP
70959: POP
// if not target then
70960: LD_VAR 0 6
70964: NOT
70965: IFFALSE 70969
// continue ;
70967: GO 70578
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70969: LD_ADDR_VAR 0 7
70973: PUSH
70974: LD_EXP 78
70978: PUSH
70979: LD_VAR 0 2
70983: ARRAY
70984: PPUSH
70985: LD_INT 2
70987: PUSH
70988: LD_INT 3
70990: PUSH
70991: LD_INT 58
70993: PUSH
70994: EMPTY
70995: LIST
70996: PUSH
70997: EMPTY
70998: LIST
70999: LIST
71000: PUSH
71001: LD_INT 61
71003: PUSH
71004: EMPTY
71005: LIST
71006: PUSH
71007: LD_INT 33
71009: PUSH
71010: LD_INT 5
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: PUSH
71017: LD_INT 33
71019: PUSH
71020: LD_INT 3
71022: PUSH
71023: EMPTY
71024: LIST
71025: LIST
71026: PUSH
71027: EMPTY
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: PUSH
71034: LD_INT 2
71036: PUSH
71037: LD_INT 34
71039: PUSH
71040: LD_INT 32
71042: PUSH
71043: EMPTY
71044: LIST
71045: LIST
71046: PUSH
71047: LD_INT 34
71049: PUSH
71050: LD_INT 51
71052: PUSH
71053: EMPTY
71054: LIST
71055: LIST
71056: PUSH
71057: LD_INT 34
71059: PUSH
71060: LD_INT 12
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: LIST
71071: LIST
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: PPUSH
71077: CALL_OW 72
71081: ST_TO_ADDR
// if not cargo then
71082: LD_VAR 0 7
71086: NOT
71087: IFFALSE 71730
// begin if mc_crates_collector [ i ] < 5 then
71089: LD_EXP 76
71093: PUSH
71094: LD_VAR 0 2
71098: ARRAY
71099: PUSH
71100: LD_INT 5
71102: LESS
71103: IFFALSE 71469
// begin if mc_ape [ i ] then
71105: LD_EXP 88
71109: PUSH
71110: LD_VAR 0 2
71114: ARRAY
71115: IFFALSE 71162
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
71117: LD_ADDR_VAR 0 5
71121: PUSH
71122: LD_EXP 88
71126: PUSH
71127: LD_VAR 0 2
71131: ARRAY
71132: PPUSH
71133: LD_INT 25
71135: PUSH
71136: LD_INT 16
71138: PUSH
71139: EMPTY
71140: LIST
71141: LIST
71142: PUSH
71143: LD_INT 24
71145: PUSH
71146: LD_INT 750
71148: PUSH
71149: EMPTY
71150: LIST
71151: LIST
71152: PUSH
71153: EMPTY
71154: LIST
71155: LIST
71156: PPUSH
71157: CALL_OW 72
71161: ST_TO_ADDR
// if not tmp then
71162: LD_VAR 0 5
71166: NOT
71167: IFFALSE 71214
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
71169: LD_ADDR_VAR 0 5
71173: PUSH
71174: LD_EXP 59
71178: PUSH
71179: LD_VAR 0 2
71183: ARRAY
71184: PPUSH
71185: LD_INT 25
71187: PUSH
71188: LD_INT 2
71190: PUSH
71191: EMPTY
71192: LIST
71193: LIST
71194: PUSH
71195: LD_INT 24
71197: PUSH
71198: LD_INT 750
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: PPUSH
71209: CALL_OW 72
71213: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
71214: LD_EXP 88
71218: PUSH
71219: LD_VAR 0 2
71223: ARRAY
71224: PUSH
71225: LD_EXP 59
71229: PUSH
71230: LD_VAR 0 2
71234: ARRAY
71235: PPUSH
71236: LD_INT 25
71238: PUSH
71239: LD_INT 2
71241: PUSH
71242: EMPTY
71243: LIST
71244: LIST
71245: PUSH
71246: LD_INT 24
71248: PUSH
71249: LD_INT 750
71251: PUSH
71252: EMPTY
71253: LIST
71254: LIST
71255: PUSH
71256: EMPTY
71257: LIST
71258: LIST
71259: PPUSH
71260: CALL_OW 72
71264: AND
71265: PUSH
71266: LD_VAR 0 5
71270: PUSH
71271: LD_INT 5
71273: LESS
71274: AND
71275: IFFALSE 71357
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
71277: LD_ADDR_VAR 0 3
71281: PUSH
71282: LD_EXP 59
71286: PUSH
71287: LD_VAR 0 2
71291: ARRAY
71292: PPUSH
71293: LD_INT 25
71295: PUSH
71296: LD_INT 2
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: PUSH
71303: LD_INT 24
71305: PUSH
71306: LD_INT 750
71308: PUSH
71309: EMPTY
71310: LIST
71311: LIST
71312: PUSH
71313: EMPTY
71314: LIST
71315: LIST
71316: PPUSH
71317: CALL_OW 72
71321: PUSH
71322: FOR_IN
71323: IFFALSE 71355
// begin tmp := tmp union j ;
71325: LD_ADDR_VAR 0 5
71329: PUSH
71330: LD_VAR 0 5
71334: PUSH
71335: LD_VAR 0 3
71339: UNION
71340: ST_TO_ADDR
// if tmp >= 5 then
71341: LD_VAR 0 5
71345: PUSH
71346: LD_INT 5
71348: GREATEREQUAL
71349: IFFALSE 71353
// break ;
71351: GO 71355
// end ;
71353: GO 71322
71355: POP
71356: POP
// end ; if not tmp then
71357: LD_VAR 0 5
71361: NOT
71362: IFFALSE 71366
// continue ;
71364: GO 70578
// for j in tmp do
71366: LD_ADDR_VAR 0 3
71370: PUSH
71371: LD_VAR 0 5
71375: PUSH
71376: FOR_IN
71377: IFFALSE 71467
// if not GetTag ( j ) then
71379: LD_VAR 0 3
71383: PPUSH
71384: CALL_OW 110
71388: NOT
71389: IFFALSE 71465
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
71391: LD_ADDR_EXP 76
71395: PUSH
71396: LD_EXP 76
71400: PPUSH
71401: LD_VAR 0 2
71405: PUSH
71406: LD_EXP 76
71410: PUSH
71411: LD_VAR 0 2
71415: ARRAY
71416: PUSH
71417: LD_INT 1
71419: PLUS
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: PPUSH
71425: LD_VAR 0 3
71429: PPUSH
71430: CALL 21521 0 3
71434: ST_TO_ADDR
// SetTag ( j , 107 ) ;
71435: LD_VAR 0 3
71439: PPUSH
71440: LD_INT 107
71442: PPUSH
71443: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
71447: LD_EXP 76
71451: PUSH
71452: LD_VAR 0 2
71456: ARRAY
71457: PUSH
71458: LD_INT 5
71460: GREATEREQUAL
71461: IFFALSE 71465
// break ;
71463: GO 71467
// end ;
71465: GO 71376
71467: POP
71468: POP
// end ; if mc_crates_collector [ i ] and target then
71469: LD_EXP 76
71473: PUSH
71474: LD_VAR 0 2
71478: ARRAY
71479: PUSH
71480: LD_VAR 0 6
71484: AND
71485: IFFALSE 71728
// begin if mc_crates_collector [ i ] < target [ 1 ] then
71487: LD_EXP 76
71491: PUSH
71492: LD_VAR 0 2
71496: ARRAY
71497: PUSH
71498: LD_VAR 0 6
71502: PUSH
71503: LD_INT 1
71505: ARRAY
71506: LESS
71507: IFFALSE 71527
// tmp := mc_crates_collector [ i ] else
71509: LD_ADDR_VAR 0 5
71513: PUSH
71514: LD_EXP 76
71518: PUSH
71519: LD_VAR 0 2
71523: ARRAY
71524: ST_TO_ADDR
71525: GO 71541
// tmp := target [ 1 ] ;
71527: LD_ADDR_VAR 0 5
71531: PUSH
71532: LD_VAR 0 6
71536: PUSH
71537: LD_INT 1
71539: ARRAY
71540: ST_TO_ADDR
// k := 0 ;
71541: LD_ADDR_VAR 0 4
71545: PUSH
71546: LD_INT 0
71548: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
71549: LD_ADDR_VAR 0 3
71553: PUSH
71554: LD_EXP 76
71558: PUSH
71559: LD_VAR 0 2
71563: ARRAY
71564: PUSH
71565: FOR_IN
71566: IFFALSE 71726
// begin k := k + 1 ;
71568: LD_ADDR_VAR 0 4
71572: PUSH
71573: LD_VAR 0 4
71577: PUSH
71578: LD_INT 1
71580: PLUS
71581: ST_TO_ADDR
// if k > tmp then
71582: LD_VAR 0 4
71586: PUSH
71587: LD_VAR 0 5
71591: GREATER
71592: IFFALSE 71596
// break ;
71594: GO 71726
// if not GetClass ( j ) in [ 2 , 16 ] then
71596: LD_VAR 0 3
71600: PPUSH
71601: CALL_OW 257
71605: PUSH
71606: LD_INT 2
71608: PUSH
71609: LD_INT 16
71611: PUSH
71612: EMPTY
71613: LIST
71614: LIST
71615: IN
71616: NOT
71617: IFFALSE 71670
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71619: LD_ADDR_EXP 76
71623: PUSH
71624: LD_EXP 76
71628: PPUSH
71629: LD_VAR 0 2
71633: PPUSH
71634: LD_EXP 76
71638: PUSH
71639: LD_VAR 0 2
71643: ARRAY
71644: PUSH
71645: LD_VAR 0 3
71649: DIFF
71650: PPUSH
71651: CALL_OW 1
71655: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71656: LD_VAR 0 3
71660: PPUSH
71661: LD_INT 0
71663: PPUSH
71664: CALL_OW 109
// continue ;
71668: GO 71565
// end ; if IsInUnit ( j ) then
71670: LD_VAR 0 3
71674: PPUSH
71675: CALL_OW 310
71679: IFFALSE 71690
// ComExitBuilding ( j ) ;
71681: LD_VAR 0 3
71685: PPUSH
71686: CALL_OW 122
// wait ( 3 ) ;
71690: LD_INT 3
71692: PPUSH
71693: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71697: LD_VAR 0 3
71701: PPUSH
71702: LD_VAR 0 6
71706: PUSH
71707: LD_INT 2
71709: ARRAY
71710: PPUSH
71711: LD_VAR 0 6
71715: PUSH
71716: LD_INT 3
71718: ARRAY
71719: PPUSH
71720: CALL_OW 117
// end ;
71724: GO 71565
71726: POP
71727: POP
// end ; end else
71728: GO 72309
// begin for j in cargo do
71730: LD_ADDR_VAR 0 3
71734: PUSH
71735: LD_VAR 0 7
71739: PUSH
71740: FOR_IN
71741: IFFALSE 72307
// begin if GetTag ( j ) <> 0 then
71743: LD_VAR 0 3
71747: PPUSH
71748: CALL_OW 110
71752: PUSH
71753: LD_INT 0
71755: NONEQUAL
71756: IFFALSE 71760
// continue ;
71758: GO 71740
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71760: LD_VAR 0 3
71764: PPUSH
71765: CALL_OW 256
71769: PUSH
71770: LD_INT 1000
71772: LESS
71773: PUSH
71774: LD_VAR 0 3
71778: PPUSH
71779: LD_EXP 83
71783: PUSH
71784: LD_VAR 0 2
71788: ARRAY
71789: PPUSH
71790: CALL_OW 308
71794: NOT
71795: AND
71796: IFFALSE 71818
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71798: LD_VAR 0 3
71802: PPUSH
71803: LD_EXP 83
71807: PUSH
71808: LD_VAR 0 2
71812: ARRAY
71813: PPUSH
71814: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71818: LD_VAR 0 3
71822: PPUSH
71823: CALL_OW 256
71827: PUSH
71828: LD_INT 1000
71830: LESS
71831: PUSH
71832: LD_VAR 0 3
71836: PPUSH
71837: LD_EXP 83
71841: PUSH
71842: LD_VAR 0 2
71846: ARRAY
71847: PPUSH
71848: CALL_OW 308
71852: AND
71853: IFFALSE 71857
// continue ;
71855: GO 71740
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71857: LD_VAR 0 3
71861: PPUSH
71862: CALL_OW 262
71866: PUSH
71867: LD_INT 2
71869: EQUAL
71870: PUSH
71871: LD_VAR 0 3
71875: PPUSH
71876: CALL_OW 261
71880: PUSH
71881: LD_INT 15
71883: LESS
71884: AND
71885: IFFALSE 71889
// continue ;
71887: GO 71740
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71889: LD_VAR 0 3
71893: PPUSH
71894: CALL_OW 262
71898: PUSH
71899: LD_INT 1
71901: EQUAL
71902: PUSH
71903: LD_VAR 0 3
71907: PPUSH
71908: CALL_OW 261
71912: PUSH
71913: LD_INT 10
71915: LESS
71916: AND
71917: IFFALSE 72246
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71919: LD_ADDR_VAR 0 8
71923: PUSH
71924: LD_EXP 59
71928: PUSH
71929: LD_VAR 0 2
71933: ARRAY
71934: PPUSH
71935: LD_INT 2
71937: PUSH
71938: LD_INT 30
71940: PUSH
71941: LD_INT 0
71943: PUSH
71944: EMPTY
71945: LIST
71946: LIST
71947: PUSH
71948: LD_INT 30
71950: PUSH
71951: LD_INT 1
71953: PUSH
71954: EMPTY
71955: LIST
71956: LIST
71957: PUSH
71958: EMPTY
71959: LIST
71960: LIST
71961: LIST
71962: PPUSH
71963: CALL_OW 72
71967: ST_TO_ADDR
// if not depot then
71968: LD_VAR 0 8
71972: NOT
71973: IFFALSE 71977
// continue ;
71975: GO 71740
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71977: LD_VAR 0 3
71981: PPUSH
71982: LD_VAR 0 8
71986: PPUSH
71987: LD_VAR 0 3
71991: PPUSH
71992: CALL_OW 74
71996: PPUSH
71997: CALL_OW 296
72001: PUSH
72002: LD_INT 6
72004: LESS
72005: IFFALSE 72021
// SetFuel ( j , 100 ) else
72007: LD_VAR 0 3
72011: PPUSH
72012: LD_INT 100
72014: PPUSH
72015: CALL_OW 240
72019: GO 72246
// if GetFuel ( j ) = 0 then
72021: LD_VAR 0 3
72025: PPUSH
72026: CALL_OW 261
72030: PUSH
72031: LD_INT 0
72033: EQUAL
72034: IFFALSE 72246
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
72036: LD_ADDR_EXP 78
72040: PUSH
72041: LD_EXP 78
72045: PPUSH
72046: LD_VAR 0 2
72050: PPUSH
72051: LD_EXP 78
72055: PUSH
72056: LD_VAR 0 2
72060: ARRAY
72061: PUSH
72062: LD_VAR 0 3
72066: DIFF
72067: PPUSH
72068: CALL_OW 1
72072: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
72073: LD_VAR 0 3
72077: PPUSH
72078: CALL_OW 263
72082: PUSH
72083: LD_INT 1
72085: EQUAL
72086: IFFALSE 72102
// ComExitVehicle ( IsInUnit ( j ) ) ;
72088: LD_VAR 0 3
72092: PPUSH
72093: CALL_OW 310
72097: PPUSH
72098: CALL_OW 121
// if GetControl ( j ) = control_remote then
72102: LD_VAR 0 3
72106: PPUSH
72107: CALL_OW 263
72111: PUSH
72112: LD_INT 2
72114: EQUAL
72115: IFFALSE 72126
// ComUnlink ( j ) ;
72117: LD_VAR 0 3
72121: PPUSH
72122: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
72126: LD_ADDR_VAR 0 9
72130: PUSH
72131: LD_VAR 0 2
72135: PPUSH
72136: LD_INT 3
72138: PPUSH
72139: CALL 81599 0 2
72143: ST_TO_ADDR
// if fac then
72144: LD_VAR 0 9
72148: IFFALSE 72244
// begin for k in fac do
72150: LD_ADDR_VAR 0 4
72154: PUSH
72155: LD_VAR 0 9
72159: PUSH
72160: FOR_IN
72161: IFFALSE 72242
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
72163: LD_ADDR_VAR 0 10
72167: PUSH
72168: LD_VAR 0 9
72172: PPUSH
72173: LD_VAR 0 3
72177: PPUSH
72178: CALL_OW 265
72182: PPUSH
72183: LD_VAR 0 3
72187: PPUSH
72188: CALL_OW 262
72192: PPUSH
72193: LD_VAR 0 3
72197: PPUSH
72198: CALL_OW 263
72202: PPUSH
72203: LD_VAR 0 3
72207: PPUSH
72208: CALL_OW 264
72212: PPUSH
72213: CALL 19053 0 5
72217: ST_TO_ADDR
// if components then
72218: LD_VAR 0 10
72222: IFFALSE 72240
// begin MC_InsertProduceList ( i , components ) ;
72224: LD_VAR 0 2
72228: PPUSH
72229: LD_VAR 0 10
72233: PPUSH
72234: CALL 81144 0 2
// break ;
72238: GO 72242
// end ; end ;
72240: GO 72160
72242: POP
72243: POP
// end ; continue ;
72244: GO 71740
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
72246: LD_VAR 0 3
72250: PPUSH
72251: LD_INT 1
72253: PPUSH
72254: CALL_OW 289
72258: PUSH
72259: LD_INT 100
72261: LESS
72262: PUSH
72263: LD_VAR 0 3
72267: PPUSH
72268: CALL_OW 314
72272: NOT
72273: AND
72274: IFFALSE 72303
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
72276: LD_VAR 0 3
72280: PPUSH
72281: LD_VAR 0 6
72285: PUSH
72286: LD_INT 2
72288: ARRAY
72289: PPUSH
72290: LD_VAR 0 6
72294: PUSH
72295: LD_INT 3
72297: ARRAY
72298: PPUSH
72299: CALL_OW 117
// break ;
72303: GO 72307
// end ;
72305: GO 71740
72307: POP
72308: POP
// end ; end ;
72309: GO 70578
72311: POP
72312: POP
// end ;
72313: LD_VAR 0 1
72317: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
72318: LD_INT 0
72320: PPUSH
72321: PPUSH
72322: PPUSH
72323: PPUSH
// if not mc_bases then
72324: LD_EXP 59
72328: NOT
72329: IFFALSE 72333
// exit ;
72331: GO 72494
// for i = 1 to mc_bases do
72333: LD_ADDR_VAR 0 2
72337: PUSH
72338: DOUBLE
72339: LD_INT 1
72341: DEC
72342: ST_TO_ADDR
72343: LD_EXP 59
72347: PUSH
72348: FOR_TO
72349: IFFALSE 72492
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
72351: LD_ADDR_VAR 0 4
72355: PUSH
72356: LD_EXP 78
72360: PUSH
72361: LD_VAR 0 2
72365: ARRAY
72366: PUSH
72367: LD_EXP 81
72371: PUSH
72372: LD_VAR 0 2
72376: ARRAY
72377: UNION
72378: PPUSH
72379: LD_INT 33
72381: PUSH
72382: LD_INT 2
72384: PUSH
72385: EMPTY
72386: LIST
72387: LIST
72388: PPUSH
72389: CALL_OW 72
72393: ST_TO_ADDR
// if tmp then
72394: LD_VAR 0 4
72398: IFFALSE 72490
// for j in tmp do
72400: LD_ADDR_VAR 0 3
72404: PUSH
72405: LD_VAR 0 4
72409: PUSH
72410: FOR_IN
72411: IFFALSE 72488
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
72413: LD_VAR 0 3
72417: PPUSH
72418: CALL_OW 312
72422: NOT
72423: PUSH
72424: LD_VAR 0 3
72428: PPUSH
72429: CALL_OW 256
72433: PUSH
72434: LD_INT 250
72436: GREATEREQUAL
72437: AND
72438: IFFALSE 72451
// Connect ( j ) else
72440: LD_VAR 0 3
72444: PPUSH
72445: CALL 24454 0 1
72449: GO 72486
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
72451: LD_VAR 0 3
72455: PPUSH
72456: CALL_OW 256
72460: PUSH
72461: LD_INT 250
72463: LESS
72464: PUSH
72465: LD_VAR 0 3
72469: PPUSH
72470: CALL_OW 312
72474: AND
72475: IFFALSE 72486
// ComUnlink ( j ) ;
72477: LD_VAR 0 3
72481: PPUSH
72482: CALL_OW 136
72486: GO 72410
72488: POP
72489: POP
// end ;
72490: GO 72348
72492: POP
72493: POP
// end ;
72494: LD_VAR 0 1
72498: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
72499: LD_INT 0
72501: PPUSH
72502: PPUSH
72503: PPUSH
72504: PPUSH
72505: PPUSH
// if not mc_bases then
72506: LD_EXP 59
72510: NOT
72511: IFFALSE 72515
// exit ;
72513: GO 72960
// for i = 1 to mc_bases do
72515: LD_ADDR_VAR 0 2
72519: PUSH
72520: DOUBLE
72521: LD_INT 1
72523: DEC
72524: ST_TO_ADDR
72525: LD_EXP 59
72529: PUSH
72530: FOR_TO
72531: IFFALSE 72958
// begin if not mc_produce [ i ] then
72533: LD_EXP 80
72537: PUSH
72538: LD_VAR 0 2
72542: ARRAY
72543: NOT
72544: IFFALSE 72548
// continue ;
72546: GO 72530
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72548: LD_ADDR_VAR 0 5
72552: PUSH
72553: LD_EXP 59
72557: PUSH
72558: LD_VAR 0 2
72562: ARRAY
72563: PPUSH
72564: LD_INT 30
72566: PUSH
72567: LD_INT 3
72569: PUSH
72570: EMPTY
72571: LIST
72572: LIST
72573: PPUSH
72574: CALL_OW 72
72578: ST_TO_ADDR
// if not fac then
72579: LD_VAR 0 5
72583: NOT
72584: IFFALSE 72588
// continue ;
72586: GO 72530
// for j in fac do
72588: LD_ADDR_VAR 0 3
72592: PUSH
72593: LD_VAR 0 5
72597: PUSH
72598: FOR_IN
72599: IFFALSE 72954
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72601: LD_VAR 0 3
72605: PPUSH
72606: CALL_OW 461
72610: PUSH
72611: LD_INT 2
72613: NONEQUAL
72614: PUSH
72615: LD_VAR 0 3
72619: PPUSH
72620: LD_INT 15
72622: PPUSH
72623: CALL 24114 0 2
72627: PUSH
72628: LD_INT 4
72630: ARRAY
72631: OR
72632: IFFALSE 72636
// continue ;
72634: GO 72598
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72636: LD_VAR 0 3
72640: PPUSH
72641: LD_EXP 80
72645: PUSH
72646: LD_VAR 0 2
72650: ARRAY
72651: PUSH
72652: LD_INT 1
72654: ARRAY
72655: PUSH
72656: LD_INT 1
72658: ARRAY
72659: PPUSH
72660: LD_EXP 80
72664: PUSH
72665: LD_VAR 0 2
72669: ARRAY
72670: PUSH
72671: LD_INT 1
72673: ARRAY
72674: PUSH
72675: LD_INT 2
72677: ARRAY
72678: PPUSH
72679: LD_EXP 80
72683: PUSH
72684: LD_VAR 0 2
72688: ARRAY
72689: PUSH
72690: LD_INT 1
72692: ARRAY
72693: PUSH
72694: LD_INT 3
72696: ARRAY
72697: PPUSH
72698: LD_EXP 80
72702: PUSH
72703: LD_VAR 0 2
72707: ARRAY
72708: PUSH
72709: LD_INT 1
72711: ARRAY
72712: PUSH
72713: LD_INT 4
72715: ARRAY
72716: PPUSH
72717: CALL_OW 448
72721: PUSH
72722: LD_VAR 0 3
72726: PPUSH
72727: LD_EXP 80
72731: PUSH
72732: LD_VAR 0 2
72736: ARRAY
72737: PUSH
72738: LD_INT 1
72740: ARRAY
72741: PUSH
72742: LD_INT 1
72744: ARRAY
72745: PUSH
72746: LD_EXP 80
72750: PUSH
72751: LD_VAR 0 2
72755: ARRAY
72756: PUSH
72757: LD_INT 1
72759: ARRAY
72760: PUSH
72761: LD_INT 2
72763: ARRAY
72764: PUSH
72765: LD_EXP 80
72769: PUSH
72770: LD_VAR 0 2
72774: ARRAY
72775: PUSH
72776: LD_INT 1
72778: ARRAY
72779: PUSH
72780: LD_INT 3
72782: ARRAY
72783: PUSH
72784: LD_EXP 80
72788: PUSH
72789: LD_VAR 0 2
72793: ARRAY
72794: PUSH
72795: LD_INT 1
72797: ARRAY
72798: PUSH
72799: LD_INT 4
72801: ARRAY
72802: PUSH
72803: EMPTY
72804: LIST
72805: LIST
72806: LIST
72807: LIST
72808: PPUSH
72809: CALL 27785 0 2
72813: AND
72814: IFFALSE 72952
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72816: LD_VAR 0 3
72820: PPUSH
72821: LD_EXP 80
72825: PUSH
72826: LD_VAR 0 2
72830: ARRAY
72831: PUSH
72832: LD_INT 1
72834: ARRAY
72835: PUSH
72836: LD_INT 1
72838: ARRAY
72839: PPUSH
72840: LD_EXP 80
72844: PUSH
72845: LD_VAR 0 2
72849: ARRAY
72850: PUSH
72851: LD_INT 1
72853: ARRAY
72854: PUSH
72855: LD_INT 2
72857: ARRAY
72858: PPUSH
72859: LD_EXP 80
72863: PUSH
72864: LD_VAR 0 2
72868: ARRAY
72869: PUSH
72870: LD_INT 1
72872: ARRAY
72873: PUSH
72874: LD_INT 3
72876: ARRAY
72877: PPUSH
72878: LD_EXP 80
72882: PUSH
72883: LD_VAR 0 2
72887: ARRAY
72888: PUSH
72889: LD_INT 1
72891: ARRAY
72892: PUSH
72893: LD_INT 4
72895: ARRAY
72896: PPUSH
72897: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72901: LD_ADDR_VAR 0 4
72905: PUSH
72906: LD_EXP 80
72910: PUSH
72911: LD_VAR 0 2
72915: ARRAY
72916: PPUSH
72917: LD_INT 1
72919: PPUSH
72920: CALL_OW 3
72924: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72925: LD_ADDR_EXP 80
72929: PUSH
72930: LD_EXP 80
72934: PPUSH
72935: LD_VAR 0 2
72939: PPUSH
72940: LD_VAR 0 4
72944: PPUSH
72945: CALL_OW 1
72949: ST_TO_ADDR
// break ;
72950: GO 72954
// end ; end ;
72952: GO 72598
72954: POP
72955: POP
// end ;
72956: GO 72530
72958: POP
72959: POP
// end ;
72960: LD_VAR 0 1
72964: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72965: LD_INT 0
72967: PPUSH
72968: PPUSH
72969: PPUSH
// if not mc_bases then
72970: LD_EXP 59
72974: NOT
72975: IFFALSE 72979
// exit ;
72977: GO 73068
// for i = 1 to mc_bases do
72979: LD_ADDR_VAR 0 2
72983: PUSH
72984: DOUBLE
72985: LD_INT 1
72987: DEC
72988: ST_TO_ADDR
72989: LD_EXP 59
72993: PUSH
72994: FOR_TO
72995: IFFALSE 73066
// begin if mc_attack [ i ] then
72997: LD_EXP 79
73001: PUSH
73002: LD_VAR 0 2
73006: ARRAY
73007: IFFALSE 73064
// begin tmp := mc_attack [ i ] [ 1 ] ;
73009: LD_ADDR_VAR 0 3
73013: PUSH
73014: LD_EXP 79
73018: PUSH
73019: LD_VAR 0 2
73023: ARRAY
73024: PUSH
73025: LD_INT 1
73027: ARRAY
73028: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
73029: LD_ADDR_EXP 79
73033: PUSH
73034: LD_EXP 79
73038: PPUSH
73039: LD_VAR 0 2
73043: PPUSH
73044: EMPTY
73045: PPUSH
73046: CALL_OW 1
73050: ST_TO_ADDR
// Attack ( tmp ) ;
73051: LD_VAR 0 3
73055: PPUSH
73056: CALL 49975 0 1
// exit ;
73060: POP
73061: POP
73062: GO 73068
// end ; end ;
73064: GO 72994
73066: POP
73067: POP
// end ;
73068: LD_VAR 0 1
73072: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
73073: LD_INT 0
73075: PPUSH
73076: PPUSH
73077: PPUSH
73078: PPUSH
73079: PPUSH
73080: PPUSH
73081: PPUSH
// if not mc_bases then
73082: LD_EXP 59
73086: NOT
73087: IFFALSE 73091
// exit ;
73089: GO 73673
// for i = 1 to mc_bases do
73091: LD_ADDR_VAR 0 2
73095: PUSH
73096: DOUBLE
73097: LD_INT 1
73099: DEC
73100: ST_TO_ADDR
73101: LD_EXP 59
73105: PUSH
73106: FOR_TO
73107: IFFALSE 73671
// begin if not mc_bases [ i ] then
73109: LD_EXP 59
73113: PUSH
73114: LD_VAR 0 2
73118: ARRAY
73119: NOT
73120: IFFALSE 73124
// continue ;
73122: GO 73106
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
73124: LD_ADDR_VAR 0 7
73128: PUSH
73129: LD_EXP 59
73133: PUSH
73134: LD_VAR 0 2
73138: ARRAY
73139: PUSH
73140: LD_INT 1
73142: ARRAY
73143: PPUSH
73144: CALL 18357 0 1
73148: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
73149: LD_ADDR_EXP 82
73153: PUSH
73154: LD_EXP 82
73158: PPUSH
73159: LD_VAR 0 2
73163: PPUSH
73164: LD_EXP 59
73168: PUSH
73169: LD_VAR 0 2
73173: ARRAY
73174: PUSH
73175: LD_INT 1
73177: ARRAY
73178: PPUSH
73179: CALL_OW 255
73183: PPUSH
73184: LD_EXP 84
73188: PUSH
73189: LD_VAR 0 2
73193: ARRAY
73194: PPUSH
73195: CALL 15911 0 2
73199: PPUSH
73200: CALL_OW 1
73204: ST_TO_ADDR
// if not mc_scan [ i ] then
73205: LD_EXP 82
73209: PUSH
73210: LD_VAR 0 2
73214: ARRAY
73215: NOT
73216: IFFALSE 73371
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73218: LD_ADDR_VAR 0 4
73222: PUSH
73223: LD_EXP 59
73227: PUSH
73228: LD_VAR 0 2
73232: ARRAY
73233: PPUSH
73234: LD_INT 2
73236: PUSH
73237: LD_INT 25
73239: PUSH
73240: LD_INT 5
73242: PUSH
73243: EMPTY
73244: LIST
73245: LIST
73246: PUSH
73247: LD_INT 25
73249: PUSH
73250: LD_INT 8
73252: PUSH
73253: EMPTY
73254: LIST
73255: LIST
73256: PUSH
73257: LD_INT 25
73259: PUSH
73260: LD_INT 9
73262: PUSH
73263: EMPTY
73264: LIST
73265: LIST
73266: PUSH
73267: EMPTY
73268: LIST
73269: LIST
73270: LIST
73271: LIST
73272: PPUSH
73273: CALL_OW 72
73277: ST_TO_ADDR
// if not tmp then
73278: LD_VAR 0 4
73282: NOT
73283: IFFALSE 73287
// continue ;
73285: GO 73106
// for j in tmp do
73287: LD_ADDR_VAR 0 3
73291: PUSH
73292: LD_VAR 0 4
73296: PUSH
73297: FOR_IN
73298: IFFALSE 73369
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
73300: LD_VAR 0 3
73304: PPUSH
73305: CALL_OW 310
73309: PPUSH
73310: CALL_OW 266
73314: PUSH
73315: LD_INT 5
73317: EQUAL
73318: PUSH
73319: LD_VAR 0 3
73323: PPUSH
73324: CALL_OW 257
73328: PUSH
73329: LD_INT 1
73331: EQUAL
73332: AND
73333: PUSH
73334: LD_VAR 0 3
73338: PPUSH
73339: CALL_OW 459
73343: NOT
73344: AND
73345: PUSH
73346: LD_VAR 0 7
73350: AND
73351: IFFALSE 73367
// ComChangeProfession ( j , class ) ;
73353: LD_VAR 0 3
73357: PPUSH
73358: LD_VAR 0 7
73362: PPUSH
73363: CALL_OW 123
73367: GO 73297
73369: POP
73370: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
73371: LD_EXP 82
73375: PUSH
73376: LD_VAR 0 2
73380: ARRAY
73381: PUSH
73382: LD_EXP 81
73386: PUSH
73387: LD_VAR 0 2
73391: ARRAY
73392: NOT
73393: AND
73394: PUSH
73395: LD_EXP 59
73399: PUSH
73400: LD_VAR 0 2
73404: ARRAY
73405: PPUSH
73406: LD_INT 30
73408: PUSH
73409: LD_INT 32
73411: PUSH
73412: EMPTY
73413: LIST
73414: LIST
73415: PPUSH
73416: CALL_OW 72
73420: NOT
73421: AND
73422: PUSH
73423: LD_EXP 59
73427: PUSH
73428: LD_VAR 0 2
73432: ARRAY
73433: PPUSH
73434: LD_INT 2
73436: PUSH
73437: LD_INT 30
73439: PUSH
73440: LD_INT 4
73442: PUSH
73443: EMPTY
73444: LIST
73445: LIST
73446: PUSH
73447: LD_INT 30
73449: PUSH
73450: LD_INT 5
73452: PUSH
73453: EMPTY
73454: LIST
73455: LIST
73456: PUSH
73457: EMPTY
73458: LIST
73459: LIST
73460: LIST
73461: PPUSH
73462: CALL_OW 72
73466: NOT
73467: AND
73468: IFFALSE 73600
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73470: LD_ADDR_VAR 0 4
73474: PUSH
73475: LD_EXP 59
73479: PUSH
73480: LD_VAR 0 2
73484: ARRAY
73485: PPUSH
73486: LD_INT 2
73488: PUSH
73489: LD_INT 25
73491: PUSH
73492: LD_INT 1
73494: PUSH
73495: EMPTY
73496: LIST
73497: LIST
73498: PUSH
73499: LD_INT 25
73501: PUSH
73502: LD_INT 5
73504: PUSH
73505: EMPTY
73506: LIST
73507: LIST
73508: PUSH
73509: LD_INT 25
73511: PUSH
73512: LD_INT 8
73514: PUSH
73515: EMPTY
73516: LIST
73517: LIST
73518: PUSH
73519: LD_INT 25
73521: PUSH
73522: LD_INT 9
73524: PUSH
73525: EMPTY
73526: LIST
73527: LIST
73528: PUSH
73529: EMPTY
73530: LIST
73531: LIST
73532: LIST
73533: LIST
73534: LIST
73535: PPUSH
73536: CALL_OW 72
73540: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
73541: LD_ADDR_VAR 0 4
73545: PUSH
73546: LD_VAR 0 4
73550: PUSH
73551: LD_VAR 0 4
73555: PPUSH
73556: LD_INT 18
73558: PPUSH
73559: CALL 54784 0 2
73563: DIFF
73564: ST_TO_ADDR
// if tmp then
73565: LD_VAR 0 4
73569: IFFALSE 73600
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
73571: LD_VAR 0 2
73575: PPUSH
73576: LD_VAR 0 4
73580: PPUSH
73581: LD_EXP 84
73585: PUSH
73586: LD_VAR 0 2
73590: ARRAY
73591: PPUSH
73592: CALL 15946 0 3
// exit ;
73596: POP
73597: POP
73598: GO 73673
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
73600: LD_EXP 82
73604: PUSH
73605: LD_VAR 0 2
73609: ARRAY
73610: PUSH
73611: LD_EXP 81
73615: PUSH
73616: LD_VAR 0 2
73620: ARRAY
73621: AND
73622: IFFALSE 73669
// begin tmp := mc_defender [ i ] ;
73624: LD_ADDR_VAR 0 4
73628: PUSH
73629: LD_EXP 81
73633: PUSH
73634: LD_VAR 0 2
73638: ARRAY
73639: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
73640: LD_VAR 0 2
73644: PPUSH
73645: LD_VAR 0 4
73649: PPUSH
73650: LD_EXP 82
73654: PUSH
73655: LD_VAR 0 2
73659: ARRAY
73660: PPUSH
73661: CALL 16507 0 3
// exit ;
73665: POP
73666: POP
73667: GO 73673
// end ; end ;
73669: GO 73106
73671: POP
73672: POP
// end ;
73673: LD_VAR 0 1
73677: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73678: LD_INT 0
73680: PPUSH
73681: PPUSH
73682: PPUSH
73683: PPUSH
73684: PPUSH
73685: PPUSH
73686: PPUSH
73687: PPUSH
73688: PPUSH
73689: PPUSH
73690: PPUSH
// if not mc_bases then
73691: LD_EXP 59
73695: NOT
73696: IFFALSE 73700
// exit ;
73698: GO 74787
// for i = 1 to mc_bases do
73700: LD_ADDR_VAR 0 2
73704: PUSH
73705: DOUBLE
73706: LD_INT 1
73708: DEC
73709: ST_TO_ADDR
73710: LD_EXP 59
73714: PUSH
73715: FOR_TO
73716: IFFALSE 74785
// begin tmp := mc_lab [ i ] ;
73718: LD_ADDR_VAR 0 6
73722: PUSH
73723: LD_EXP 92
73727: PUSH
73728: LD_VAR 0 2
73732: ARRAY
73733: ST_TO_ADDR
// if not tmp then
73734: LD_VAR 0 6
73738: NOT
73739: IFFALSE 73743
// continue ;
73741: GO 73715
// idle_lab := 0 ;
73743: LD_ADDR_VAR 0 11
73747: PUSH
73748: LD_INT 0
73750: ST_TO_ADDR
// for j in tmp do
73751: LD_ADDR_VAR 0 3
73755: PUSH
73756: LD_VAR 0 6
73760: PUSH
73761: FOR_IN
73762: IFFALSE 74781
// begin researching := false ;
73764: LD_ADDR_VAR 0 10
73768: PUSH
73769: LD_INT 0
73771: ST_TO_ADDR
// side := GetSide ( j ) ;
73772: LD_ADDR_VAR 0 4
73776: PUSH
73777: LD_VAR 0 3
73781: PPUSH
73782: CALL_OW 255
73786: ST_TO_ADDR
// if not mc_tech [ side ] then
73787: LD_EXP 86
73791: PUSH
73792: LD_VAR 0 4
73796: ARRAY
73797: NOT
73798: IFFALSE 73802
// continue ;
73800: GO 73761
// if BuildingStatus ( j ) = bs_idle then
73802: LD_VAR 0 3
73806: PPUSH
73807: CALL_OW 461
73811: PUSH
73812: LD_INT 2
73814: EQUAL
73815: IFFALSE 74003
// begin if idle_lab and UnitsInside ( j ) < 6 then
73817: LD_VAR 0 11
73821: PUSH
73822: LD_VAR 0 3
73826: PPUSH
73827: CALL_OW 313
73831: PUSH
73832: LD_INT 6
73834: LESS
73835: AND
73836: IFFALSE 73907
// begin tmp2 := UnitsInside ( idle_lab ) ;
73838: LD_ADDR_VAR 0 9
73842: PUSH
73843: LD_VAR 0 11
73847: PPUSH
73848: CALL_OW 313
73852: ST_TO_ADDR
// if tmp2 then
73853: LD_VAR 0 9
73857: IFFALSE 73899
// for x in tmp2 do
73859: LD_ADDR_VAR 0 7
73863: PUSH
73864: LD_VAR 0 9
73868: PUSH
73869: FOR_IN
73870: IFFALSE 73897
// begin ComExitBuilding ( x ) ;
73872: LD_VAR 0 7
73876: PPUSH
73877: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73881: LD_VAR 0 7
73885: PPUSH
73886: LD_VAR 0 3
73890: PPUSH
73891: CALL_OW 180
// end ;
73895: GO 73869
73897: POP
73898: POP
// idle_lab := 0 ;
73899: LD_ADDR_VAR 0 11
73903: PUSH
73904: LD_INT 0
73906: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73907: LD_ADDR_VAR 0 5
73911: PUSH
73912: LD_EXP 86
73916: PUSH
73917: LD_VAR 0 4
73921: ARRAY
73922: PUSH
73923: FOR_IN
73924: IFFALSE 73984
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73926: LD_VAR 0 3
73930: PPUSH
73931: LD_VAR 0 5
73935: PPUSH
73936: CALL_OW 430
73940: PUSH
73941: LD_VAR 0 4
73945: PPUSH
73946: LD_VAR 0 5
73950: PPUSH
73951: CALL 15016 0 2
73955: AND
73956: IFFALSE 73982
// begin researching := true ;
73958: LD_ADDR_VAR 0 10
73962: PUSH
73963: LD_INT 1
73965: ST_TO_ADDR
// ComResearch ( j , t ) ;
73966: LD_VAR 0 3
73970: PPUSH
73971: LD_VAR 0 5
73975: PPUSH
73976: CALL_OW 124
// break ;
73980: GO 73984
// end ;
73982: GO 73923
73984: POP
73985: POP
// if not researching then
73986: LD_VAR 0 10
73990: NOT
73991: IFFALSE 74003
// idle_lab := j ;
73993: LD_ADDR_VAR 0 11
73997: PUSH
73998: LD_VAR 0 3
74002: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
74003: LD_VAR 0 3
74007: PPUSH
74008: CALL_OW 461
74012: PUSH
74013: LD_INT 10
74015: EQUAL
74016: IFFALSE 74604
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
74018: LD_EXP 88
74022: PUSH
74023: LD_VAR 0 2
74027: ARRAY
74028: NOT
74029: PUSH
74030: LD_EXP 89
74034: PUSH
74035: LD_VAR 0 2
74039: ARRAY
74040: NOT
74041: AND
74042: PUSH
74043: LD_EXP 86
74047: PUSH
74048: LD_VAR 0 4
74052: ARRAY
74053: PUSH
74054: LD_INT 1
74056: GREATER
74057: AND
74058: IFFALSE 74189
// begin ComCancel ( j ) ;
74060: LD_VAR 0 3
74064: PPUSH
74065: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
74069: LD_ADDR_EXP 86
74073: PUSH
74074: LD_EXP 86
74078: PPUSH
74079: LD_VAR 0 4
74083: PPUSH
74084: LD_EXP 86
74088: PUSH
74089: LD_VAR 0 4
74093: ARRAY
74094: PPUSH
74095: LD_EXP 86
74099: PUSH
74100: LD_VAR 0 4
74104: ARRAY
74105: PUSH
74106: LD_INT 1
74108: MINUS
74109: PPUSH
74110: LD_EXP 86
74114: PUSH
74115: LD_VAR 0 4
74119: ARRAY
74120: PPUSH
74121: LD_INT 0
74123: PPUSH
74124: CALL 20939 0 4
74128: PPUSH
74129: CALL_OW 1
74133: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
74134: LD_ADDR_EXP 86
74138: PUSH
74139: LD_EXP 86
74143: PPUSH
74144: LD_VAR 0 4
74148: PPUSH
74149: LD_EXP 86
74153: PUSH
74154: LD_VAR 0 4
74158: ARRAY
74159: PPUSH
74160: LD_EXP 86
74164: PUSH
74165: LD_VAR 0 4
74169: ARRAY
74170: PPUSH
74171: LD_INT 1
74173: PPUSH
74174: LD_INT 0
74176: PPUSH
74177: CALL 20939 0 4
74181: PPUSH
74182: CALL_OW 1
74186: ST_TO_ADDR
// continue ;
74187: GO 73761
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
74189: LD_EXP 88
74193: PUSH
74194: LD_VAR 0 2
74198: ARRAY
74199: PUSH
74200: LD_EXP 89
74204: PUSH
74205: LD_VAR 0 2
74209: ARRAY
74210: NOT
74211: AND
74212: IFFALSE 74339
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
74214: LD_ADDR_EXP 89
74218: PUSH
74219: LD_EXP 89
74223: PPUSH
74224: LD_VAR 0 2
74228: PUSH
74229: LD_EXP 89
74233: PUSH
74234: LD_VAR 0 2
74238: ARRAY
74239: PUSH
74240: LD_INT 1
74242: PLUS
74243: PUSH
74244: EMPTY
74245: LIST
74246: LIST
74247: PPUSH
74248: LD_EXP 88
74252: PUSH
74253: LD_VAR 0 2
74257: ARRAY
74258: PUSH
74259: LD_INT 1
74261: ARRAY
74262: PPUSH
74263: CALL 21521 0 3
74267: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
74268: LD_EXP 88
74272: PUSH
74273: LD_VAR 0 2
74277: ARRAY
74278: PUSH
74279: LD_INT 1
74281: ARRAY
74282: PPUSH
74283: LD_INT 112
74285: PPUSH
74286: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
74290: LD_ADDR_VAR 0 9
74294: PUSH
74295: LD_EXP 88
74299: PUSH
74300: LD_VAR 0 2
74304: ARRAY
74305: PPUSH
74306: LD_INT 1
74308: PPUSH
74309: CALL_OW 3
74313: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
74314: LD_ADDR_EXP 88
74318: PUSH
74319: LD_EXP 88
74323: PPUSH
74324: LD_VAR 0 2
74328: PPUSH
74329: LD_VAR 0 9
74333: PPUSH
74334: CALL_OW 1
74338: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
74339: LD_EXP 88
74343: PUSH
74344: LD_VAR 0 2
74348: ARRAY
74349: PUSH
74350: LD_EXP 89
74354: PUSH
74355: LD_VAR 0 2
74359: ARRAY
74360: AND
74361: PUSH
74362: LD_EXP 89
74366: PUSH
74367: LD_VAR 0 2
74371: ARRAY
74372: PUSH
74373: LD_INT 1
74375: ARRAY
74376: PPUSH
74377: CALL_OW 310
74381: NOT
74382: AND
74383: PUSH
74384: LD_VAR 0 3
74388: PPUSH
74389: CALL_OW 313
74393: PUSH
74394: LD_INT 6
74396: EQUAL
74397: AND
74398: IFFALSE 74454
// begin tmp2 := UnitsInside ( j ) ;
74400: LD_ADDR_VAR 0 9
74404: PUSH
74405: LD_VAR 0 3
74409: PPUSH
74410: CALL_OW 313
74414: ST_TO_ADDR
// if tmp2 = 6 then
74415: LD_VAR 0 9
74419: PUSH
74420: LD_INT 6
74422: EQUAL
74423: IFFALSE 74454
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
74425: LD_VAR 0 9
74429: PUSH
74430: LD_INT 1
74432: ARRAY
74433: PPUSH
74434: LD_INT 112
74436: PPUSH
74437: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
74441: LD_VAR 0 9
74445: PUSH
74446: LD_INT 1
74448: ARRAY
74449: PPUSH
74450: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
74454: LD_EXP 89
74458: PUSH
74459: LD_VAR 0 2
74463: ARRAY
74464: PUSH
74465: LD_EXP 89
74469: PUSH
74470: LD_VAR 0 2
74474: ARRAY
74475: PUSH
74476: LD_INT 1
74478: ARRAY
74479: PPUSH
74480: CALL_OW 314
74484: NOT
74485: AND
74486: PUSH
74487: LD_EXP 89
74491: PUSH
74492: LD_VAR 0 2
74496: ARRAY
74497: PUSH
74498: LD_INT 1
74500: ARRAY
74501: PPUSH
74502: CALL_OW 310
74506: NOT
74507: AND
74508: IFFALSE 74534
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
74510: LD_EXP 89
74514: PUSH
74515: LD_VAR 0 2
74519: ARRAY
74520: PUSH
74521: LD_INT 1
74523: ARRAY
74524: PPUSH
74525: LD_VAR 0 3
74529: PPUSH
74530: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
74534: LD_EXP 89
74538: PUSH
74539: LD_VAR 0 2
74543: ARRAY
74544: PUSH
74545: LD_INT 1
74547: ARRAY
74548: PPUSH
74549: CALL_OW 310
74553: PUSH
74554: LD_EXP 89
74558: PUSH
74559: LD_VAR 0 2
74563: ARRAY
74564: PUSH
74565: LD_INT 1
74567: ARRAY
74568: PPUSH
74569: CALL_OW 310
74573: PPUSH
74574: CALL_OW 461
74578: PUSH
74579: LD_INT 3
74581: NONEQUAL
74582: AND
74583: IFFALSE 74604
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74585: LD_EXP 89
74589: PUSH
74590: LD_VAR 0 2
74594: ARRAY
74595: PUSH
74596: LD_INT 1
74598: ARRAY
74599: PPUSH
74600: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74604: LD_VAR 0 3
74608: PPUSH
74609: CALL_OW 461
74613: PUSH
74614: LD_INT 6
74616: EQUAL
74617: PUSH
74618: LD_VAR 0 6
74622: PUSH
74623: LD_INT 1
74625: GREATER
74626: AND
74627: IFFALSE 74779
// begin sci := [ ] ;
74629: LD_ADDR_VAR 0 8
74633: PUSH
74634: EMPTY
74635: ST_TO_ADDR
// for x in ( tmp diff j ) do
74636: LD_ADDR_VAR 0 7
74640: PUSH
74641: LD_VAR 0 6
74645: PUSH
74646: LD_VAR 0 3
74650: DIFF
74651: PUSH
74652: FOR_IN
74653: IFFALSE 74705
// begin if sci = 6 then
74655: LD_VAR 0 8
74659: PUSH
74660: LD_INT 6
74662: EQUAL
74663: IFFALSE 74667
// break ;
74665: GO 74705
// if BuildingStatus ( x ) = bs_idle then
74667: LD_VAR 0 7
74671: PPUSH
74672: CALL_OW 461
74676: PUSH
74677: LD_INT 2
74679: EQUAL
74680: IFFALSE 74703
// sci := sci ^ UnitsInside ( x ) ;
74682: LD_ADDR_VAR 0 8
74686: PUSH
74687: LD_VAR 0 8
74691: PUSH
74692: LD_VAR 0 7
74696: PPUSH
74697: CALL_OW 313
74701: ADD
74702: ST_TO_ADDR
// end ;
74703: GO 74652
74705: POP
74706: POP
// if not sci then
74707: LD_VAR 0 8
74711: NOT
74712: IFFALSE 74716
// continue ;
74714: GO 73761
// for x in sci do
74716: LD_ADDR_VAR 0 7
74720: PUSH
74721: LD_VAR 0 8
74725: PUSH
74726: FOR_IN
74727: IFFALSE 74777
// if IsInUnit ( x ) and not HasTask ( x ) then
74729: LD_VAR 0 7
74733: PPUSH
74734: CALL_OW 310
74738: PUSH
74739: LD_VAR 0 7
74743: PPUSH
74744: CALL_OW 314
74748: NOT
74749: AND
74750: IFFALSE 74775
// begin ComExitBuilding ( x ) ;
74752: LD_VAR 0 7
74756: PPUSH
74757: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74761: LD_VAR 0 7
74765: PPUSH
74766: LD_VAR 0 3
74770: PPUSH
74771: CALL_OW 180
// end ;
74775: GO 74726
74777: POP
74778: POP
// end ; end ;
74779: GO 73761
74781: POP
74782: POP
// end ;
74783: GO 73715
74785: POP
74786: POP
// end ;
74787: LD_VAR 0 1
74791: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74792: LD_INT 0
74794: PPUSH
74795: PPUSH
// if not mc_bases then
74796: LD_EXP 59
74800: NOT
74801: IFFALSE 74805
// exit ;
74803: GO 74886
// for i = 1 to mc_bases do
74805: LD_ADDR_VAR 0 2
74809: PUSH
74810: DOUBLE
74811: LD_INT 1
74813: DEC
74814: ST_TO_ADDR
74815: LD_EXP 59
74819: PUSH
74820: FOR_TO
74821: IFFALSE 74884
// if mc_mines [ i ] and mc_miners [ i ] then
74823: LD_EXP 72
74827: PUSH
74828: LD_VAR 0 2
74832: ARRAY
74833: PUSH
74834: LD_EXP 73
74838: PUSH
74839: LD_VAR 0 2
74843: ARRAY
74844: AND
74845: IFFALSE 74882
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74847: LD_EXP 73
74851: PUSH
74852: LD_VAR 0 2
74856: ARRAY
74857: PUSH
74858: LD_INT 1
74860: ARRAY
74861: PPUSH
74862: CALL_OW 255
74866: PPUSH
74867: LD_EXP 72
74871: PUSH
74872: LD_VAR 0 2
74876: ARRAY
74877: PPUSH
74878: CALL 18510 0 2
74882: GO 74820
74884: POP
74885: POP
// end ;
74886: LD_VAR 0 1
74890: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74891: LD_INT 0
74893: PPUSH
74894: PPUSH
74895: PPUSH
74896: PPUSH
74897: PPUSH
74898: PPUSH
74899: PPUSH
74900: PPUSH
// if not mc_bases or not mc_parking then
74901: LD_EXP 59
74905: NOT
74906: PUSH
74907: LD_EXP 83
74911: NOT
74912: OR
74913: IFFALSE 74917
// exit ;
74915: GO 75616
// for i = 1 to mc_bases do
74917: LD_ADDR_VAR 0 2
74921: PUSH
74922: DOUBLE
74923: LD_INT 1
74925: DEC
74926: ST_TO_ADDR
74927: LD_EXP 59
74931: PUSH
74932: FOR_TO
74933: IFFALSE 75614
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74935: LD_EXP 59
74939: PUSH
74940: LD_VAR 0 2
74944: ARRAY
74945: NOT
74946: PUSH
74947: LD_EXP 83
74951: PUSH
74952: LD_VAR 0 2
74956: ARRAY
74957: NOT
74958: OR
74959: IFFALSE 74963
// continue ;
74961: GO 74932
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74963: LD_ADDR_VAR 0 5
74967: PUSH
74968: LD_EXP 59
74972: PUSH
74973: LD_VAR 0 2
74977: ARRAY
74978: PUSH
74979: LD_INT 1
74981: ARRAY
74982: PPUSH
74983: CALL_OW 255
74987: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74988: LD_ADDR_VAR 0 6
74992: PUSH
74993: LD_EXP 59
74997: PUSH
74998: LD_VAR 0 2
75002: ARRAY
75003: PPUSH
75004: LD_INT 30
75006: PUSH
75007: LD_INT 3
75009: PUSH
75010: EMPTY
75011: LIST
75012: LIST
75013: PPUSH
75014: CALL_OW 72
75018: ST_TO_ADDR
// if not fac then
75019: LD_VAR 0 6
75023: NOT
75024: IFFALSE 75075
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75026: LD_ADDR_VAR 0 6
75030: PUSH
75031: LD_EXP 59
75035: PUSH
75036: LD_VAR 0 2
75040: ARRAY
75041: PPUSH
75042: LD_INT 2
75044: PUSH
75045: LD_INT 30
75047: PUSH
75048: LD_INT 0
75050: PUSH
75051: EMPTY
75052: LIST
75053: LIST
75054: PUSH
75055: LD_INT 30
75057: PUSH
75058: LD_INT 1
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: PUSH
75065: EMPTY
75066: LIST
75067: LIST
75068: LIST
75069: PPUSH
75070: CALL_OW 72
75074: ST_TO_ADDR
// if not fac then
75075: LD_VAR 0 6
75079: NOT
75080: IFFALSE 75084
// continue ;
75082: GO 74932
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75084: LD_ADDR_VAR 0 7
75088: PUSH
75089: LD_EXP 83
75093: PUSH
75094: LD_VAR 0 2
75098: ARRAY
75099: PPUSH
75100: LD_INT 22
75102: PUSH
75103: LD_VAR 0 5
75107: PUSH
75108: EMPTY
75109: LIST
75110: LIST
75111: PUSH
75112: LD_INT 21
75114: PUSH
75115: LD_INT 2
75117: PUSH
75118: EMPTY
75119: LIST
75120: LIST
75121: PUSH
75122: LD_INT 3
75124: PUSH
75125: LD_INT 24
75127: PUSH
75128: LD_INT 1000
75130: PUSH
75131: EMPTY
75132: LIST
75133: LIST
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PUSH
75139: EMPTY
75140: LIST
75141: LIST
75142: LIST
75143: PPUSH
75144: CALL_OW 70
75148: ST_TO_ADDR
// for j in fac do
75149: LD_ADDR_VAR 0 3
75153: PUSH
75154: LD_VAR 0 6
75158: PUSH
75159: FOR_IN
75160: IFFALSE 75241
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75162: LD_ADDR_VAR 0 7
75166: PUSH
75167: LD_VAR 0 7
75171: PUSH
75172: LD_INT 22
75174: PUSH
75175: LD_VAR 0 5
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: LD_INT 91
75186: PUSH
75187: LD_VAR 0 3
75191: PUSH
75192: LD_INT 15
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: LIST
75199: PUSH
75200: LD_INT 21
75202: PUSH
75203: LD_INT 2
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: PUSH
75210: LD_INT 3
75212: PUSH
75213: LD_INT 24
75215: PUSH
75216: LD_INT 1000
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: LIST
75231: LIST
75232: PPUSH
75233: CALL_OW 69
75237: UNION
75238: ST_TO_ADDR
75239: GO 75159
75241: POP
75242: POP
// if not vehs then
75243: LD_VAR 0 7
75247: NOT
75248: IFFALSE 75274
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
75250: LD_ADDR_EXP 71
75254: PUSH
75255: LD_EXP 71
75259: PPUSH
75260: LD_VAR 0 2
75264: PPUSH
75265: EMPTY
75266: PPUSH
75267: CALL_OW 1
75271: ST_TO_ADDR
// continue ;
75272: GO 74932
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75274: LD_ADDR_VAR 0 8
75278: PUSH
75279: LD_EXP 59
75283: PUSH
75284: LD_VAR 0 2
75288: ARRAY
75289: PPUSH
75290: LD_INT 30
75292: PUSH
75293: LD_INT 3
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PPUSH
75300: CALL_OW 72
75304: ST_TO_ADDR
// if tmp then
75305: LD_VAR 0 8
75309: IFFALSE 75412
// begin for j in tmp do
75311: LD_ADDR_VAR 0 3
75315: PUSH
75316: LD_VAR 0 8
75320: PUSH
75321: FOR_IN
75322: IFFALSE 75410
// for k in UnitsInside ( j ) do
75324: LD_ADDR_VAR 0 4
75328: PUSH
75329: LD_VAR 0 3
75333: PPUSH
75334: CALL_OW 313
75338: PUSH
75339: FOR_IN
75340: IFFALSE 75406
// if k then
75342: LD_VAR 0 4
75346: IFFALSE 75404
// if not k in mc_repair_vehicle [ i ] then
75348: LD_VAR 0 4
75352: PUSH
75353: LD_EXP 71
75357: PUSH
75358: LD_VAR 0 2
75362: ARRAY
75363: IN
75364: NOT
75365: IFFALSE 75404
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
75367: LD_ADDR_EXP 71
75371: PUSH
75372: LD_EXP 71
75376: PPUSH
75377: LD_VAR 0 2
75381: PPUSH
75382: LD_EXP 71
75386: PUSH
75387: LD_VAR 0 2
75391: ARRAY
75392: PUSH
75393: LD_VAR 0 4
75397: UNION
75398: PPUSH
75399: CALL_OW 1
75403: ST_TO_ADDR
75404: GO 75339
75406: POP
75407: POP
75408: GO 75321
75410: POP
75411: POP
// end ; if not mc_repair_vehicle [ i ] then
75412: LD_EXP 71
75416: PUSH
75417: LD_VAR 0 2
75421: ARRAY
75422: NOT
75423: IFFALSE 75427
// continue ;
75425: GO 74932
// for j in mc_repair_vehicle [ i ] do
75427: LD_ADDR_VAR 0 3
75431: PUSH
75432: LD_EXP 71
75436: PUSH
75437: LD_VAR 0 2
75441: ARRAY
75442: PUSH
75443: FOR_IN
75444: IFFALSE 75610
// begin if GetClass ( j ) <> 3 then
75446: LD_VAR 0 3
75450: PPUSH
75451: CALL_OW 257
75455: PUSH
75456: LD_INT 3
75458: NONEQUAL
75459: IFFALSE 75500
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
75461: LD_ADDR_EXP 71
75465: PUSH
75466: LD_EXP 71
75470: PPUSH
75471: LD_VAR 0 2
75475: PPUSH
75476: LD_EXP 71
75480: PUSH
75481: LD_VAR 0 2
75485: ARRAY
75486: PUSH
75487: LD_VAR 0 3
75491: DIFF
75492: PPUSH
75493: CALL_OW 1
75497: ST_TO_ADDR
// continue ;
75498: GO 75443
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75500: LD_VAR 0 3
75504: PPUSH
75505: CALL_OW 311
75509: NOT
75510: PUSH
75511: LD_VAR 0 3
75515: PUSH
75516: LD_EXP 62
75520: PUSH
75521: LD_VAR 0 2
75525: ARRAY
75526: PUSH
75527: LD_INT 1
75529: ARRAY
75530: IN
75531: NOT
75532: AND
75533: PUSH
75534: LD_VAR 0 3
75538: PUSH
75539: LD_EXP 62
75543: PUSH
75544: LD_VAR 0 2
75548: ARRAY
75549: PUSH
75550: LD_INT 2
75552: ARRAY
75553: IN
75554: NOT
75555: AND
75556: IFFALSE 75608
// begin if IsInUnit ( j ) then
75558: LD_VAR 0 3
75562: PPUSH
75563: CALL_OW 310
75567: IFFALSE 75578
// ComExitBuilding ( j ) ;
75569: LD_VAR 0 3
75573: PPUSH
75574: CALL_OW 122
// if not HasTask ( j ) then
75578: LD_VAR 0 3
75582: PPUSH
75583: CALL_OW 314
75587: NOT
75588: IFFALSE 75608
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
75590: LD_VAR 0 3
75594: PPUSH
75595: LD_VAR 0 7
75599: PUSH
75600: LD_INT 1
75602: ARRAY
75603: PPUSH
75604: CALL_OW 189
// end ; end ;
75608: GO 75443
75610: POP
75611: POP
// end ;
75612: GO 74932
75614: POP
75615: POP
// end ;
75616: LD_VAR 0 1
75620: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75621: LD_INT 0
75623: PPUSH
75624: PPUSH
75625: PPUSH
75626: PPUSH
75627: PPUSH
75628: PPUSH
75629: PPUSH
75630: PPUSH
75631: PPUSH
75632: PPUSH
75633: PPUSH
// if not mc_bases then
75634: LD_EXP 59
75638: NOT
75639: IFFALSE 75643
// exit ;
75641: GO 76445
// for i = 1 to mc_bases do
75643: LD_ADDR_VAR 0 2
75647: PUSH
75648: DOUBLE
75649: LD_INT 1
75651: DEC
75652: ST_TO_ADDR
75653: LD_EXP 59
75657: PUSH
75658: FOR_TO
75659: IFFALSE 76443
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75661: LD_EXP 87
75665: PUSH
75666: LD_VAR 0 2
75670: ARRAY
75671: NOT
75672: PUSH
75673: LD_EXP 62
75677: PUSH
75678: LD_VAR 0 2
75682: ARRAY
75683: PUSH
75684: LD_INT 1
75686: ARRAY
75687: OR
75688: PUSH
75689: LD_EXP 62
75693: PUSH
75694: LD_VAR 0 2
75698: ARRAY
75699: PUSH
75700: LD_INT 2
75702: ARRAY
75703: OR
75704: PUSH
75705: LD_EXP 85
75709: PUSH
75710: LD_VAR 0 2
75714: ARRAY
75715: PPUSH
75716: LD_INT 1
75718: PPUSH
75719: CALL_OW 325
75723: NOT
75724: OR
75725: PUSH
75726: LD_EXP 82
75730: PUSH
75731: LD_VAR 0 2
75735: ARRAY
75736: OR
75737: IFFALSE 75741
// continue ;
75739: GO 75658
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75741: LD_ADDR_VAR 0 8
75745: PUSH
75746: LD_EXP 59
75750: PUSH
75751: LD_VAR 0 2
75755: ARRAY
75756: PPUSH
75757: LD_INT 25
75759: PUSH
75760: LD_INT 4
75762: PUSH
75763: EMPTY
75764: LIST
75765: LIST
75766: PUSH
75767: LD_INT 50
75769: PUSH
75770: EMPTY
75771: LIST
75772: PUSH
75773: LD_INT 3
75775: PUSH
75776: LD_INT 60
75778: PUSH
75779: EMPTY
75780: LIST
75781: PUSH
75782: EMPTY
75783: LIST
75784: LIST
75785: PUSH
75786: EMPTY
75787: LIST
75788: LIST
75789: LIST
75790: PPUSH
75791: CALL_OW 72
75795: PUSH
75796: LD_EXP 63
75800: PUSH
75801: LD_VAR 0 2
75805: ARRAY
75806: DIFF
75807: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75808: LD_ADDR_VAR 0 9
75812: PUSH
75813: LD_EXP 59
75817: PUSH
75818: LD_VAR 0 2
75822: ARRAY
75823: PPUSH
75824: LD_INT 2
75826: PUSH
75827: LD_INT 30
75829: PUSH
75830: LD_INT 0
75832: PUSH
75833: EMPTY
75834: LIST
75835: LIST
75836: PUSH
75837: LD_INT 30
75839: PUSH
75840: LD_INT 1
75842: PUSH
75843: EMPTY
75844: LIST
75845: LIST
75846: PUSH
75847: EMPTY
75848: LIST
75849: LIST
75850: LIST
75851: PPUSH
75852: CALL_OW 72
75856: ST_TO_ADDR
// if not tmp or not dep then
75857: LD_VAR 0 8
75861: NOT
75862: PUSH
75863: LD_VAR 0 9
75867: NOT
75868: OR
75869: IFFALSE 75873
// continue ;
75871: GO 75658
// side := GetSide ( tmp [ 1 ] ) ;
75873: LD_ADDR_VAR 0 11
75877: PUSH
75878: LD_VAR 0 8
75882: PUSH
75883: LD_INT 1
75885: ARRAY
75886: PPUSH
75887: CALL_OW 255
75891: ST_TO_ADDR
// dep := dep [ 1 ] ;
75892: LD_ADDR_VAR 0 9
75896: PUSH
75897: LD_VAR 0 9
75901: PUSH
75902: LD_INT 1
75904: ARRAY
75905: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75906: LD_ADDR_VAR 0 7
75910: PUSH
75911: LD_EXP 87
75915: PUSH
75916: LD_VAR 0 2
75920: ARRAY
75921: PPUSH
75922: LD_INT 22
75924: PUSH
75925: LD_INT 0
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: LD_INT 25
75934: PUSH
75935: LD_INT 12
75937: PUSH
75938: EMPTY
75939: LIST
75940: LIST
75941: PUSH
75942: EMPTY
75943: LIST
75944: LIST
75945: PPUSH
75946: CALL_OW 70
75950: PUSH
75951: LD_INT 22
75953: PUSH
75954: LD_INT 0
75956: PUSH
75957: EMPTY
75958: LIST
75959: LIST
75960: PUSH
75961: LD_INT 25
75963: PUSH
75964: LD_INT 12
75966: PUSH
75967: EMPTY
75968: LIST
75969: LIST
75970: PUSH
75971: LD_INT 91
75973: PUSH
75974: LD_VAR 0 9
75978: PUSH
75979: LD_INT 20
75981: PUSH
75982: EMPTY
75983: LIST
75984: LIST
75985: LIST
75986: PUSH
75987: EMPTY
75988: LIST
75989: LIST
75990: LIST
75991: PPUSH
75992: CALL_OW 69
75996: UNION
75997: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
75998: LD_ADDR_VAR 0 10
76002: PUSH
76003: LD_EXP 87
76007: PUSH
76008: LD_VAR 0 2
76012: ARRAY
76013: PPUSH
76014: LD_INT 81
76016: PUSH
76017: LD_VAR 0 11
76021: PUSH
76022: EMPTY
76023: LIST
76024: LIST
76025: PPUSH
76026: CALL_OW 70
76030: ST_TO_ADDR
// if not apes or danger_at_area then
76031: LD_VAR 0 7
76035: NOT
76036: PUSH
76037: LD_VAR 0 10
76041: OR
76042: IFFALSE 76092
// begin if mc_taming [ i ] then
76044: LD_EXP 90
76048: PUSH
76049: LD_VAR 0 2
76053: ARRAY
76054: IFFALSE 76090
// begin MC_Reset ( i , 121 ) ;
76056: LD_VAR 0 2
76060: PPUSH
76061: LD_INT 121
76063: PPUSH
76064: CALL 61527 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
76068: LD_ADDR_EXP 90
76072: PUSH
76073: LD_EXP 90
76077: PPUSH
76078: LD_VAR 0 2
76082: PPUSH
76083: EMPTY
76084: PPUSH
76085: CALL_OW 1
76089: ST_TO_ADDR
// end ; continue ;
76090: GO 75658
// end ; for j in tmp do
76092: LD_ADDR_VAR 0 3
76096: PUSH
76097: LD_VAR 0 8
76101: PUSH
76102: FOR_IN
76103: IFFALSE 76439
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
76105: LD_VAR 0 3
76109: PUSH
76110: LD_EXP 90
76114: PUSH
76115: LD_VAR 0 2
76119: ARRAY
76120: IN
76121: NOT
76122: PUSH
76123: LD_EXP 90
76127: PUSH
76128: LD_VAR 0 2
76132: ARRAY
76133: PUSH
76134: LD_INT 3
76136: LESS
76137: AND
76138: IFFALSE 76196
// begin SetTag ( j , 121 ) ;
76140: LD_VAR 0 3
76144: PPUSH
76145: LD_INT 121
76147: PPUSH
76148: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
76152: LD_ADDR_EXP 90
76156: PUSH
76157: LD_EXP 90
76161: PPUSH
76162: LD_VAR 0 2
76166: PUSH
76167: LD_EXP 90
76171: PUSH
76172: LD_VAR 0 2
76176: ARRAY
76177: PUSH
76178: LD_INT 1
76180: PLUS
76181: PUSH
76182: EMPTY
76183: LIST
76184: LIST
76185: PPUSH
76186: LD_VAR 0 3
76190: PPUSH
76191: CALL 21521 0 3
76195: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
76196: LD_VAR 0 3
76200: PUSH
76201: LD_EXP 90
76205: PUSH
76206: LD_VAR 0 2
76210: ARRAY
76211: IN
76212: IFFALSE 76437
// begin if GetClass ( j ) <> 4 then
76214: LD_VAR 0 3
76218: PPUSH
76219: CALL_OW 257
76223: PUSH
76224: LD_INT 4
76226: NONEQUAL
76227: IFFALSE 76280
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
76229: LD_ADDR_EXP 90
76233: PUSH
76234: LD_EXP 90
76238: PPUSH
76239: LD_VAR 0 2
76243: PPUSH
76244: LD_EXP 90
76248: PUSH
76249: LD_VAR 0 2
76253: ARRAY
76254: PUSH
76255: LD_VAR 0 3
76259: DIFF
76260: PPUSH
76261: CALL_OW 1
76265: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76266: LD_VAR 0 3
76270: PPUSH
76271: LD_INT 0
76273: PPUSH
76274: CALL_OW 109
// continue ;
76278: GO 76102
// end ; if IsInUnit ( j ) then
76280: LD_VAR 0 3
76284: PPUSH
76285: CALL_OW 310
76289: IFFALSE 76300
// ComExitBuilding ( j ) ;
76291: LD_VAR 0 3
76295: PPUSH
76296: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
76300: LD_ADDR_VAR 0 6
76304: PUSH
76305: LD_VAR 0 7
76309: PPUSH
76310: LD_VAR 0 3
76314: PPUSH
76315: CALL_OW 74
76319: ST_TO_ADDR
// if not ape then
76320: LD_VAR 0 6
76324: NOT
76325: IFFALSE 76329
// break ;
76327: GO 76439
// x := GetX ( ape ) ;
76329: LD_ADDR_VAR 0 4
76333: PUSH
76334: LD_VAR 0 6
76338: PPUSH
76339: CALL_OW 250
76343: ST_TO_ADDR
// y := GetY ( ape ) ;
76344: LD_ADDR_VAR 0 5
76348: PUSH
76349: LD_VAR 0 6
76353: PPUSH
76354: CALL_OW 251
76358: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76359: LD_VAR 0 4
76363: PPUSH
76364: LD_VAR 0 5
76368: PPUSH
76369: CALL_OW 488
76373: NOT
76374: PUSH
76375: LD_VAR 0 11
76379: PPUSH
76380: LD_VAR 0 4
76384: PPUSH
76385: LD_VAR 0 5
76389: PPUSH
76390: LD_INT 20
76392: PPUSH
76393: CALL 22417 0 4
76397: PUSH
76398: LD_INT 4
76400: ARRAY
76401: OR
76402: IFFALSE 76406
// break ;
76404: GO 76439
// if not HasTask ( j ) then
76406: LD_VAR 0 3
76410: PPUSH
76411: CALL_OW 314
76415: NOT
76416: IFFALSE 76437
// ComTameXY ( j , x , y ) ;
76418: LD_VAR 0 3
76422: PPUSH
76423: LD_VAR 0 4
76427: PPUSH
76428: LD_VAR 0 5
76432: PPUSH
76433: CALL_OW 131
// end ; end ;
76437: GO 76102
76439: POP
76440: POP
// end ;
76441: GO 75658
76443: POP
76444: POP
// end ;
76445: LD_VAR 0 1
76449: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
76450: LD_INT 0
76452: PPUSH
76453: PPUSH
76454: PPUSH
76455: PPUSH
76456: PPUSH
76457: PPUSH
76458: PPUSH
76459: PPUSH
// if not mc_bases then
76460: LD_EXP 59
76464: NOT
76465: IFFALSE 76469
// exit ;
76467: GO 77095
// for i = 1 to mc_bases do
76469: LD_ADDR_VAR 0 2
76473: PUSH
76474: DOUBLE
76475: LD_INT 1
76477: DEC
76478: ST_TO_ADDR
76479: LD_EXP 59
76483: PUSH
76484: FOR_TO
76485: IFFALSE 77093
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
76487: LD_EXP 88
76491: PUSH
76492: LD_VAR 0 2
76496: ARRAY
76497: NOT
76498: PUSH
76499: LD_EXP 88
76503: PUSH
76504: LD_VAR 0 2
76508: ARRAY
76509: PPUSH
76510: LD_INT 25
76512: PUSH
76513: LD_INT 12
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PPUSH
76520: CALL_OW 72
76524: NOT
76525: OR
76526: IFFALSE 76530
// continue ;
76528: GO 76484
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76530: LD_ADDR_VAR 0 5
76534: PUSH
76535: LD_EXP 88
76539: PUSH
76540: LD_VAR 0 2
76544: ARRAY
76545: PUSH
76546: LD_INT 1
76548: ARRAY
76549: PPUSH
76550: CALL_OW 255
76554: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76555: LD_VAR 0 5
76559: PPUSH
76560: LD_INT 2
76562: PPUSH
76563: CALL_OW 325
76567: IFFALSE 76820
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76569: LD_ADDR_VAR 0 4
76573: PUSH
76574: LD_EXP 88
76578: PUSH
76579: LD_VAR 0 2
76583: ARRAY
76584: PPUSH
76585: LD_INT 25
76587: PUSH
76588: LD_INT 16
76590: PUSH
76591: EMPTY
76592: LIST
76593: LIST
76594: PPUSH
76595: CALL_OW 72
76599: ST_TO_ADDR
// if tmp < 6 then
76600: LD_VAR 0 4
76604: PUSH
76605: LD_INT 6
76607: LESS
76608: IFFALSE 76820
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76610: LD_ADDR_VAR 0 6
76614: PUSH
76615: LD_EXP 59
76619: PUSH
76620: LD_VAR 0 2
76624: ARRAY
76625: PPUSH
76626: LD_INT 2
76628: PUSH
76629: LD_INT 30
76631: PUSH
76632: LD_INT 0
76634: PUSH
76635: EMPTY
76636: LIST
76637: LIST
76638: PUSH
76639: LD_INT 30
76641: PUSH
76642: LD_INT 1
76644: PUSH
76645: EMPTY
76646: LIST
76647: LIST
76648: PUSH
76649: EMPTY
76650: LIST
76651: LIST
76652: LIST
76653: PPUSH
76654: CALL_OW 72
76658: ST_TO_ADDR
// if depot then
76659: LD_VAR 0 6
76663: IFFALSE 76820
// begin selected := 0 ;
76665: LD_ADDR_VAR 0 7
76669: PUSH
76670: LD_INT 0
76672: ST_TO_ADDR
// for j in depot do
76673: LD_ADDR_VAR 0 3
76677: PUSH
76678: LD_VAR 0 6
76682: PUSH
76683: FOR_IN
76684: IFFALSE 76715
// begin if UnitsInside ( j ) < 6 then
76686: LD_VAR 0 3
76690: PPUSH
76691: CALL_OW 313
76695: PUSH
76696: LD_INT 6
76698: LESS
76699: IFFALSE 76713
// begin selected := j ;
76701: LD_ADDR_VAR 0 7
76705: PUSH
76706: LD_VAR 0 3
76710: ST_TO_ADDR
// break ;
76711: GO 76715
// end ; end ;
76713: GO 76683
76715: POP
76716: POP
// if selected then
76717: LD_VAR 0 7
76721: IFFALSE 76820
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76723: LD_ADDR_VAR 0 3
76727: PUSH
76728: LD_EXP 88
76732: PUSH
76733: LD_VAR 0 2
76737: ARRAY
76738: PPUSH
76739: LD_INT 25
76741: PUSH
76742: LD_INT 12
76744: PUSH
76745: EMPTY
76746: LIST
76747: LIST
76748: PPUSH
76749: CALL_OW 72
76753: PUSH
76754: FOR_IN
76755: IFFALSE 76818
// if not HasTask ( j ) then
76757: LD_VAR 0 3
76761: PPUSH
76762: CALL_OW 314
76766: NOT
76767: IFFALSE 76816
// begin if not IsInUnit ( j ) then
76769: LD_VAR 0 3
76773: PPUSH
76774: CALL_OW 310
76778: NOT
76779: IFFALSE 76795
// ComEnterUnit ( j , selected ) ;
76781: LD_VAR 0 3
76785: PPUSH
76786: LD_VAR 0 7
76790: PPUSH
76791: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76795: LD_VAR 0 3
76799: PPUSH
76800: LD_INT 16
76802: PPUSH
76803: CALL_OW 183
// AddComExitBuilding ( j ) ;
76807: LD_VAR 0 3
76811: PPUSH
76812: CALL_OW 182
// end ;
76816: GO 76754
76818: POP
76819: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76820: LD_VAR 0 5
76824: PPUSH
76825: LD_INT 11
76827: PPUSH
76828: CALL_OW 325
76832: IFFALSE 77091
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76834: LD_ADDR_VAR 0 4
76838: PUSH
76839: LD_EXP 88
76843: PUSH
76844: LD_VAR 0 2
76848: ARRAY
76849: PPUSH
76850: LD_INT 25
76852: PUSH
76853: LD_INT 16
76855: PUSH
76856: EMPTY
76857: LIST
76858: LIST
76859: PPUSH
76860: CALL_OW 72
76864: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76865: LD_VAR 0 4
76869: PUSH
76870: LD_INT 6
76872: GREATEREQUAL
76873: PUSH
76874: LD_VAR 0 5
76878: PPUSH
76879: LD_INT 2
76881: PPUSH
76882: CALL_OW 325
76886: NOT
76887: OR
76888: IFFALSE 77091
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76890: LD_ADDR_VAR 0 8
76894: PUSH
76895: LD_EXP 59
76899: PUSH
76900: LD_VAR 0 2
76904: ARRAY
76905: PPUSH
76906: LD_INT 2
76908: PUSH
76909: LD_INT 30
76911: PUSH
76912: LD_INT 4
76914: PUSH
76915: EMPTY
76916: LIST
76917: LIST
76918: PUSH
76919: LD_INT 30
76921: PUSH
76922: LD_INT 5
76924: PUSH
76925: EMPTY
76926: LIST
76927: LIST
76928: PUSH
76929: EMPTY
76930: LIST
76931: LIST
76932: LIST
76933: PPUSH
76934: CALL_OW 72
76938: ST_TO_ADDR
// if barracks then
76939: LD_VAR 0 8
76943: IFFALSE 77091
// begin selected := 0 ;
76945: LD_ADDR_VAR 0 7
76949: PUSH
76950: LD_INT 0
76952: ST_TO_ADDR
// for j in barracks do
76953: LD_ADDR_VAR 0 3
76957: PUSH
76958: LD_VAR 0 8
76962: PUSH
76963: FOR_IN
76964: IFFALSE 76995
// begin if UnitsInside ( j ) < 6 then
76966: LD_VAR 0 3
76970: PPUSH
76971: CALL_OW 313
76975: PUSH
76976: LD_INT 6
76978: LESS
76979: IFFALSE 76993
// begin selected := j ;
76981: LD_ADDR_VAR 0 7
76985: PUSH
76986: LD_VAR 0 3
76990: ST_TO_ADDR
// break ;
76991: GO 76995
// end ; end ;
76993: GO 76963
76995: POP
76996: POP
// if selected then
76997: LD_VAR 0 7
77001: IFFALSE 77091
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
77003: LD_ADDR_VAR 0 3
77007: PUSH
77008: LD_EXP 88
77012: PUSH
77013: LD_VAR 0 2
77017: ARRAY
77018: PPUSH
77019: LD_INT 25
77021: PUSH
77022: LD_INT 12
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: PPUSH
77029: CALL_OW 72
77033: PUSH
77034: FOR_IN
77035: IFFALSE 77089
// if not IsInUnit ( j ) and not HasTask ( j ) then
77037: LD_VAR 0 3
77041: PPUSH
77042: CALL_OW 310
77046: NOT
77047: PUSH
77048: LD_VAR 0 3
77052: PPUSH
77053: CALL_OW 314
77057: NOT
77058: AND
77059: IFFALSE 77087
// begin ComEnterUnit ( j , selected ) ;
77061: LD_VAR 0 3
77065: PPUSH
77066: LD_VAR 0 7
77070: PPUSH
77071: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
77075: LD_VAR 0 3
77079: PPUSH
77080: LD_INT 15
77082: PPUSH
77083: CALL_OW 183
// end ;
77087: GO 77034
77089: POP
77090: POP
// end ; end ; end ; end ; end ;
77091: GO 76484
77093: POP
77094: POP
// end ;
77095: LD_VAR 0 1
77099: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
77100: LD_INT 0
77102: PPUSH
77103: PPUSH
77104: PPUSH
77105: PPUSH
// if not mc_bases then
77106: LD_EXP 59
77110: NOT
77111: IFFALSE 77115
// exit ;
77113: GO 77293
// for i = 1 to mc_bases do
77115: LD_ADDR_VAR 0 2
77119: PUSH
77120: DOUBLE
77121: LD_INT 1
77123: DEC
77124: ST_TO_ADDR
77125: LD_EXP 59
77129: PUSH
77130: FOR_TO
77131: IFFALSE 77291
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
77133: LD_ADDR_VAR 0 4
77137: PUSH
77138: LD_EXP 59
77142: PUSH
77143: LD_VAR 0 2
77147: ARRAY
77148: PPUSH
77149: LD_INT 25
77151: PUSH
77152: LD_INT 9
77154: PUSH
77155: EMPTY
77156: LIST
77157: LIST
77158: PPUSH
77159: CALL_OW 72
77163: ST_TO_ADDR
// if not tmp then
77164: LD_VAR 0 4
77168: NOT
77169: IFFALSE 77173
// continue ;
77171: GO 77130
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
77173: LD_EXP 85
77177: PUSH
77178: LD_VAR 0 2
77182: ARRAY
77183: PPUSH
77184: LD_INT 29
77186: PPUSH
77187: CALL_OW 325
77191: NOT
77192: PUSH
77193: LD_EXP 85
77197: PUSH
77198: LD_VAR 0 2
77202: ARRAY
77203: PPUSH
77204: LD_INT 28
77206: PPUSH
77207: CALL_OW 325
77211: NOT
77212: AND
77213: IFFALSE 77217
// continue ;
77215: GO 77130
// for j in tmp do
77217: LD_ADDR_VAR 0 3
77221: PUSH
77222: LD_VAR 0 4
77226: PUSH
77227: FOR_IN
77228: IFFALSE 77287
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77230: LD_VAR 0 3
77234: PUSH
77235: LD_EXP 62
77239: PUSH
77240: LD_VAR 0 2
77244: ARRAY
77245: PUSH
77246: LD_INT 1
77248: ARRAY
77249: IN
77250: NOT
77251: PUSH
77252: LD_VAR 0 3
77256: PUSH
77257: LD_EXP 62
77261: PUSH
77262: LD_VAR 0 2
77266: ARRAY
77267: PUSH
77268: LD_INT 2
77270: ARRAY
77271: IN
77272: NOT
77273: AND
77274: IFFALSE 77285
// ComSpaceTimeShoot ( j ) ;
77276: LD_VAR 0 3
77280: PPUSH
77281: CALL 15107 0 1
77285: GO 77227
77287: POP
77288: POP
// end ;
77289: GO 77130
77291: POP
77292: POP
// end ;
77293: LD_VAR 0 1
77297: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
77298: LD_INT 0
77300: PPUSH
77301: PPUSH
77302: PPUSH
77303: PPUSH
77304: PPUSH
77305: PPUSH
77306: PPUSH
77307: PPUSH
77308: PPUSH
// if not mc_bases then
77309: LD_EXP 59
77313: NOT
77314: IFFALSE 77318
// exit ;
77316: GO 77940
// for i = 1 to mc_bases do
77318: LD_ADDR_VAR 0 2
77322: PUSH
77323: DOUBLE
77324: LD_INT 1
77326: DEC
77327: ST_TO_ADDR
77328: LD_EXP 59
77332: PUSH
77333: FOR_TO
77334: IFFALSE 77938
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
77336: LD_EXP 94
77340: PUSH
77341: LD_VAR 0 2
77345: ARRAY
77346: NOT
77347: PUSH
77348: LD_INT 38
77350: PPUSH
77351: LD_EXP 85
77355: PUSH
77356: LD_VAR 0 2
77360: ARRAY
77361: PPUSH
77362: CALL_OW 321
77366: PUSH
77367: LD_INT 2
77369: NONEQUAL
77370: OR
77371: IFFALSE 77375
// continue ;
77373: GO 77333
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
77375: LD_ADDR_VAR 0 8
77379: PUSH
77380: LD_EXP 59
77384: PUSH
77385: LD_VAR 0 2
77389: ARRAY
77390: PPUSH
77391: LD_INT 30
77393: PUSH
77394: LD_INT 34
77396: PUSH
77397: EMPTY
77398: LIST
77399: LIST
77400: PPUSH
77401: CALL_OW 72
77405: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
77406: LD_ADDR_VAR 0 9
77410: PUSH
77411: LD_EXP 59
77415: PUSH
77416: LD_VAR 0 2
77420: ARRAY
77421: PPUSH
77422: LD_INT 25
77424: PUSH
77425: LD_INT 4
77427: PUSH
77428: EMPTY
77429: LIST
77430: LIST
77431: PPUSH
77432: CALL_OW 72
77436: PPUSH
77437: LD_INT 0
77439: PPUSH
77440: CALL 54784 0 2
77444: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
77445: LD_VAR 0 9
77449: NOT
77450: PUSH
77451: LD_VAR 0 8
77455: NOT
77456: OR
77457: PUSH
77458: LD_EXP 59
77462: PUSH
77463: LD_VAR 0 2
77467: ARRAY
77468: PPUSH
77469: LD_INT 124
77471: PPUSH
77472: CALL 54784 0 2
77476: OR
77477: IFFALSE 77481
// continue ;
77479: GO 77333
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
77481: LD_EXP 95
77485: PUSH
77486: LD_VAR 0 2
77490: ARRAY
77491: PUSH
77492: LD_EXP 94
77496: PUSH
77497: LD_VAR 0 2
77501: ARRAY
77502: LESS
77503: PUSH
77504: LD_EXP 95
77508: PUSH
77509: LD_VAR 0 2
77513: ARRAY
77514: PUSH
77515: LD_VAR 0 8
77519: LESS
77520: AND
77521: IFFALSE 77936
// begin tmp := sci [ 1 ] ;
77523: LD_ADDR_VAR 0 7
77527: PUSH
77528: LD_VAR 0 9
77532: PUSH
77533: LD_INT 1
77535: ARRAY
77536: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77537: LD_VAR 0 7
77541: PPUSH
77542: LD_INT 124
77544: PPUSH
77545: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77549: LD_ADDR_VAR 0 3
77553: PUSH
77554: DOUBLE
77555: LD_EXP 94
77559: PUSH
77560: LD_VAR 0 2
77564: ARRAY
77565: INC
77566: ST_TO_ADDR
77567: LD_EXP 94
77571: PUSH
77572: LD_VAR 0 2
77576: ARRAY
77577: PUSH
77578: FOR_DOWNTO
77579: IFFALSE 77922
// begin if IsInUnit ( tmp ) then
77581: LD_VAR 0 7
77585: PPUSH
77586: CALL_OW 310
77590: IFFALSE 77601
// ComExitBuilding ( tmp ) ;
77592: LD_VAR 0 7
77596: PPUSH
77597: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77601: LD_INT 35
77603: PPUSH
77604: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77608: LD_VAR 0 7
77612: PPUSH
77613: CALL_OW 310
77617: NOT
77618: PUSH
77619: LD_VAR 0 7
77623: PPUSH
77624: CALL_OW 314
77628: NOT
77629: AND
77630: IFFALSE 77601
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77632: LD_ADDR_VAR 0 6
77636: PUSH
77637: LD_VAR 0 7
77641: PPUSH
77642: CALL_OW 250
77646: PUSH
77647: LD_VAR 0 7
77651: PPUSH
77652: CALL_OW 251
77656: PUSH
77657: EMPTY
77658: LIST
77659: LIST
77660: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77661: LD_INT 35
77663: PPUSH
77664: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77668: LD_ADDR_VAR 0 4
77672: PUSH
77673: LD_EXP 94
77677: PUSH
77678: LD_VAR 0 2
77682: ARRAY
77683: PUSH
77684: LD_VAR 0 3
77688: ARRAY
77689: PUSH
77690: LD_INT 1
77692: ARRAY
77693: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77694: LD_ADDR_VAR 0 5
77698: PUSH
77699: LD_EXP 94
77703: PUSH
77704: LD_VAR 0 2
77708: ARRAY
77709: PUSH
77710: LD_VAR 0 3
77714: ARRAY
77715: PUSH
77716: LD_INT 2
77718: ARRAY
77719: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77720: LD_VAR 0 7
77724: PPUSH
77725: LD_INT 10
77727: PPUSH
77728: CALL 24114 0 2
77732: PUSH
77733: LD_INT 4
77735: ARRAY
77736: IFFALSE 77774
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77738: LD_VAR 0 7
77742: PPUSH
77743: LD_VAR 0 6
77747: PUSH
77748: LD_INT 1
77750: ARRAY
77751: PPUSH
77752: LD_VAR 0 6
77756: PUSH
77757: LD_INT 2
77759: ARRAY
77760: PPUSH
77761: CALL_OW 111
// wait ( 0 0$10 ) ;
77765: LD_INT 350
77767: PPUSH
77768: CALL_OW 67
// end else
77772: GO 77800
// begin ComMoveXY ( tmp , x , y ) ;
77774: LD_VAR 0 7
77778: PPUSH
77779: LD_VAR 0 4
77783: PPUSH
77784: LD_VAR 0 5
77788: PPUSH
77789: CALL_OW 111
// wait ( 0 0$3 ) ;
77793: LD_INT 105
77795: PPUSH
77796: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77800: LD_VAR 0 7
77804: PPUSH
77805: LD_VAR 0 4
77809: PPUSH
77810: LD_VAR 0 5
77814: PPUSH
77815: CALL_OW 307
77819: IFFALSE 77661
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77821: LD_VAR 0 7
77825: PPUSH
77826: LD_VAR 0 4
77830: PPUSH
77831: LD_VAR 0 5
77835: PPUSH
77836: LD_VAR 0 8
77840: PUSH
77841: LD_VAR 0 3
77845: ARRAY
77846: PPUSH
77847: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77851: LD_INT 35
77853: PPUSH
77854: CALL_OW 67
// until not HasTask ( tmp ) ;
77858: LD_VAR 0 7
77862: PPUSH
77863: CALL_OW 314
77867: NOT
77868: IFFALSE 77851
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77870: LD_ADDR_EXP 95
77874: PUSH
77875: LD_EXP 95
77879: PPUSH
77880: LD_VAR 0 2
77884: PUSH
77885: LD_EXP 95
77889: PUSH
77890: LD_VAR 0 2
77894: ARRAY
77895: PUSH
77896: LD_INT 1
77898: PLUS
77899: PUSH
77900: EMPTY
77901: LIST
77902: LIST
77903: PPUSH
77904: LD_VAR 0 8
77908: PUSH
77909: LD_VAR 0 3
77913: ARRAY
77914: PPUSH
77915: CALL 21521 0 3
77919: ST_TO_ADDR
// end ;
77920: GO 77578
77922: POP
77923: POP
// MC_Reset ( i , 124 ) ;
77924: LD_VAR 0 2
77928: PPUSH
77929: LD_INT 124
77931: PPUSH
77932: CALL 61527 0 2
// end ; end ;
77936: GO 77333
77938: POP
77939: POP
// end ;
77940: LD_VAR 0 1
77944: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77945: LD_INT 0
77947: PPUSH
77948: PPUSH
77949: PPUSH
// if not mc_bases then
77950: LD_EXP 59
77954: NOT
77955: IFFALSE 77959
// exit ;
77957: GO 78565
// for i = 1 to mc_bases do
77959: LD_ADDR_VAR 0 2
77963: PUSH
77964: DOUBLE
77965: LD_INT 1
77967: DEC
77968: ST_TO_ADDR
77969: LD_EXP 59
77973: PUSH
77974: FOR_TO
77975: IFFALSE 78563
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77977: LD_ADDR_VAR 0 3
77981: PUSH
77982: LD_EXP 59
77986: PUSH
77987: LD_VAR 0 2
77991: ARRAY
77992: PPUSH
77993: LD_INT 25
77995: PUSH
77996: LD_INT 4
77998: PUSH
77999: EMPTY
78000: LIST
78001: LIST
78002: PPUSH
78003: CALL_OW 72
78007: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78008: LD_VAR 0 3
78012: NOT
78013: PUSH
78014: LD_EXP 96
78018: PUSH
78019: LD_VAR 0 2
78023: ARRAY
78024: NOT
78025: OR
78026: PUSH
78027: LD_EXP 59
78031: PUSH
78032: LD_VAR 0 2
78036: ARRAY
78037: PPUSH
78038: LD_INT 2
78040: PUSH
78041: LD_INT 30
78043: PUSH
78044: LD_INT 0
78046: PUSH
78047: EMPTY
78048: LIST
78049: LIST
78050: PUSH
78051: LD_INT 30
78053: PUSH
78054: LD_INT 1
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: PUSH
78061: EMPTY
78062: LIST
78063: LIST
78064: LIST
78065: PPUSH
78066: CALL_OW 72
78070: NOT
78071: OR
78072: IFFALSE 78122
// begin if mc_deposits_finder [ i ] then
78074: LD_EXP 97
78078: PUSH
78079: LD_VAR 0 2
78083: ARRAY
78084: IFFALSE 78120
// begin MC_Reset ( i , 125 ) ;
78086: LD_VAR 0 2
78090: PPUSH
78091: LD_INT 125
78093: PPUSH
78094: CALL 61527 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78098: LD_ADDR_EXP 97
78102: PUSH
78103: LD_EXP 97
78107: PPUSH
78108: LD_VAR 0 2
78112: PPUSH
78113: EMPTY
78114: PPUSH
78115: CALL_OW 1
78119: ST_TO_ADDR
// end ; continue ;
78120: GO 77974
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
78122: LD_EXP 96
78126: PUSH
78127: LD_VAR 0 2
78131: ARRAY
78132: PUSH
78133: LD_INT 1
78135: ARRAY
78136: PUSH
78137: LD_INT 3
78139: ARRAY
78140: PUSH
78141: LD_INT 1
78143: EQUAL
78144: PUSH
78145: LD_INT 20
78147: PPUSH
78148: LD_EXP 85
78152: PUSH
78153: LD_VAR 0 2
78157: ARRAY
78158: PPUSH
78159: CALL_OW 321
78163: PUSH
78164: LD_INT 2
78166: NONEQUAL
78167: AND
78168: IFFALSE 78218
// begin if mc_deposits_finder [ i ] then
78170: LD_EXP 97
78174: PUSH
78175: LD_VAR 0 2
78179: ARRAY
78180: IFFALSE 78216
// begin MC_Reset ( i , 125 ) ;
78182: LD_VAR 0 2
78186: PPUSH
78187: LD_INT 125
78189: PPUSH
78190: CALL 61527 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78194: LD_ADDR_EXP 97
78198: PUSH
78199: LD_EXP 97
78203: PPUSH
78204: LD_VAR 0 2
78208: PPUSH
78209: EMPTY
78210: PPUSH
78211: CALL_OW 1
78215: ST_TO_ADDR
// end ; continue ;
78216: GO 77974
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
78218: LD_EXP 96
78222: PUSH
78223: LD_VAR 0 2
78227: ARRAY
78228: PUSH
78229: LD_INT 1
78231: ARRAY
78232: PUSH
78233: LD_INT 1
78235: ARRAY
78236: PPUSH
78237: LD_EXP 96
78241: PUSH
78242: LD_VAR 0 2
78246: ARRAY
78247: PUSH
78248: LD_INT 1
78250: ARRAY
78251: PUSH
78252: LD_INT 2
78254: ARRAY
78255: PPUSH
78256: LD_EXP 85
78260: PUSH
78261: LD_VAR 0 2
78265: ARRAY
78266: PPUSH
78267: CALL_OW 440
78271: IFFALSE 78314
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
78273: LD_ADDR_EXP 96
78277: PUSH
78278: LD_EXP 96
78282: PPUSH
78283: LD_VAR 0 2
78287: PPUSH
78288: LD_EXP 96
78292: PUSH
78293: LD_VAR 0 2
78297: ARRAY
78298: PPUSH
78299: LD_INT 1
78301: PPUSH
78302: CALL_OW 3
78306: PPUSH
78307: CALL_OW 1
78311: ST_TO_ADDR
78312: GO 78561
// begin if not mc_deposits_finder [ i ] then
78314: LD_EXP 97
78318: PUSH
78319: LD_VAR 0 2
78323: ARRAY
78324: NOT
78325: IFFALSE 78377
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
78327: LD_ADDR_EXP 97
78331: PUSH
78332: LD_EXP 97
78336: PPUSH
78337: LD_VAR 0 2
78341: PPUSH
78342: LD_VAR 0 3
78346: PUSH
78347: LD_INT 1
78349: ARRAY
78350: PUSH
78351: EMPTY
78352: LIST
78353: PPUSH
78354: CALL_OW 1
78358: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
78359: LD_VAR 0 3
78363: PUSH
78364: LD_INT 1
78366: ARRAY
78367: PPUSH
78368: LD_INT 125
78370: PPUSH
78371: CALL_OW 109
// end else
78375: GO 78561
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
78377: LD_EXP 97
78381: PUSH
78382: LD_VAR 0 2
78386: ARRAY
78387: PUSH
78388: LD_INT 1
78390: ARRAY
78391: PPUSH
78392: CALL_OW 310
78396: IFFALSE 78419
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
78398: LD_EXP 97
78402: PUSH
78403: LD_VAR 0 2
78407: ARRAY
78408: PUSH
78409: LD_INT 1
78411: ARRAY
78412: PPUSH
78413: CALL_OW 122
78417: GO 78561
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
78419: LD_EXP 97
78423: PUSH
78424: LD_VAR 0 2
78428: ARRAY
78429: PUSH
78430: LD_INT 1
78432: ARRAY
78433: PPUSH
78434: CALL_OW 314
78438: NOT
78439: PUSH
78440: LD_EXP 97
78444: PUSH
78445: LD_VAR 0 2
78449: ARRAY
78450: PUSH
78451: LD_INT 1
78453: ARRAY
78454: PPUSH
78455: LD_EXP 96
78459: PUSH
78460: LD_VAR 0 2
78464: ARRAY
78465: PUSH
78466: LD_INT 1
78468: ARRAY
78469: PUSH
78470: LD_INT 1
78472: ARRAY
78473: PPUSH
78474: LD_EXP 96
78478: PUSH
78479: LD_VAR 0 2
78483: ARRAY
78484: PUSH
78485: LD_INT 1
78487: ARRAY
78488: PUSH
78489: LD_INT 2
78491: ARRAY
78492: PPUSH
78493: CALL_OW 297
78497: PUSH
78498: LD_INT 6
78500: GREATER
78501: AND
78502: IFFALSE 78561
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
78504: LD_EXP 97
78508: PUSH
78509: LD_VAR 0 2
78513: ARRAY
78514: PUSH
78515: LD_INT 1
78517: ARRAY
78518: PPUSH
78519: LD_EXP 96
78523: PUSH
78524: LD_VAR 0 2
78528: ARRAY
78529: PUSH
78530: LD_INT 1
78532: ARRAY
78533: PUSH
78534: LD_INT 1
78536: ARRAY
78537: PPUSH
78538: LD_EXP 96
78542: PUSH
78543: LD_VAR 0 2
78547: ARRAY
78548: PUSH
78549: LD_INT 1
78551: ARRAY
78552: PUSH
78553: LD_INT 2
78555: ARRAY
78556: PPUSH
78557: CALL_OW 111
// end ; end ; end ;
78561: GO 77974
78563: POP
78564: POP
// end ;
78565: LD_VAR 0 1
78569: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78570: LD_INT 0
78572: PPUSH
78573: PPUSH
78574: PPUSH
78575: PPUSH
78576: PPUSH
78577: PPUSH
78578: PPUSH
78579: PPUSH
78580: PPUSH
78581: PPUSH
78582: PPUSH
// if not mc_bases then
78583: LD_EXP 59
78587: NOT
78588: IFFALSE 78592
// exit ;
78590: GO 79532
// for i = 1 to mc_bases do
78592: LD_ADDR_VAR 0 2
78596: PUSH
78597: DOUBLE
78598: LD_INT 1
78600: DEC
78601: ST_TO_ADDR
78602: LD_EXP 59
78606: PUSH
78607: FOR_TO
78608: IFFALSE 79530
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78610: LD_EXP 59
78614: PUSH
78615: LD_VAR 0 2
78619: ARRAY
78620: NOT
78621: PUSH
78622: LD_EXP 82
78626: PUSH
78627: LD_VAR 0 2
78631: ARRAY
78632: OR
78633: IFFALSE 78637
// continue ;
78635: GO 78607
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78637: LD_ADDR_VAR 0 7
78641: PUSH
78642: LD_EXP 59
78646: PUSH
78647: LD_VAR 0 2
78651: ARRAY
78652: PUSH
78653: LD_INT 1
78655: ARRAY
78656: PPUSH
78657: CALL_OW 248
78661: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78662: LD_VAR 0 7
78666: PUSH
78667: LD_INT 3
78669: EQUAL
78670: PUSH
78671: LD_EXP 78
78675: PUSH
78676: LD_VAR 0 2
78680: ARRAY
78681: PUSH
78682: LD_EXP 81
78686: PUSH
78687: LD_VAR 0 2
78691: ARRAY
78692: UNION
78693: PPUSH
78694: LD_INT 33
78696: PUSH
78697: LD_INT 2
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PPUSH
78704: CALL_OW 72
78708: NOT
78709: OR
78710: IFFALSE 78714
// continue ;
78712: GO 78607
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78714: LD_ADDR_VAR 0 9
78718: PUSH
78719: LD_EXP 59
78723: PUSH
78724: LD_VAR 0 2
78728: ARRAY
78729: PPUSH
78730: LD_INT 30
78732: PUSH
78733: LD_INT 36
78735: PUSH
78736: EMPTY
78737: LIST
78738: LIST
78739: PPUSH
78740: CALL_OW 72
78744: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78745: LD_ADDR_VAR 0 10
78749: PUSH
78750: LD_EXP 78
78754: PUSH
78755: LD_VAR 0 2
78759: ARRAY
78760: PPUSH
78761: LD_INT 34
78763: PUSH
78764: LD_INT 31
78766: PUSH
78767: EMPTY
78768: LIST
78769: LIST
78770: PPUSH
78771: CALL_OW 72
78775: ST_TO_ADDR
// if not cts and not mcts then
78776: LD_VAR 0 9
78780: NOT
78781: PUSH
78782: LD_VAR 0 10
78786: NOT
78787: AND
78788: IFFALSE 78792
// continue ;
78790: GO 78607
// x := cts ;
78792: LD_ADDR_VAR 0 11
78796: PUSH
78797: LD_VAR 0 9
78801: ST_TO_ADDR
// if not x then
78802: LD_VAR 0 11
78806: NOT
78807: IFFALSE 78819
// x := mcts ;
78809: LD_ADDR_VAR 0 11
78813: PUSH
78814: LD_VAR 0 10
78818: ST_TO_ADDR
// if not x then
78819: LD_VAR 0 11
78823: NOT
78824: IFFALSE 78828
// continue ;
78826: GO 78607
// if mc_remote_driver [ i ] then
78828: LD_EXP 99
78832: PUSH
78833: LD_VAR 0 2
78837: ARRAY
78838: IFFALSE 79225
// for j in mc_remote_driver [ i ] do
78840: LD_ADDR_VAR 0 3
78844: PUSH
78845: LD_EXP 99
78849: PUSH
78850: LD_VAR 0 2
78854: ARRAY
78855: PUSH
78856: FOR_IN
78857: IFFALSE 79223
// begin if GetClass ( j ) <> 3 then
78859: LD_VAR 0 3
78863: PPUSH
78864: CALL_OW 257
78868: PUSH
78869: LD_INT 3
78871: NONEQUAL
78872: IFFALSE 78925
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78874: LD_ADDR_EXP 99
78878: PUSH
78879: LD_EXP 99
78883: PPUSH
78884: LD_VAR 0 2
78888: PPUSH
78889: LD_EXP 99
78893: PUSH
78894: LD_VAR 0 2
78898: ARRAY
78899: PUSH
78900: LD_VAR 0 3
78904: DIFF
78905: PPUSH
78906: CALL_OW 1
78910: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78911: LD_VAR 0 3
78915: PPUSH
78916: LD_INT 0
78918: PPUSH
78919: CALL_OW 109
// continue ;
78923: GO 78856
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
78925: LD_EXP 78
78929: PUSH
78930: LD_VAR 0 2
78934: ARRAY
78935: PPUSH
78936: LD_INT 34
78938: PUSH
78939: LD_INT 31
78941: PUSH
78942: EMPTY
78943: LIST
78944: LIST
78945: PUSH
78946: LD_INT 58
78948: PUSH
78949: EMPTY
78950: LIST
78951: PUSH
78952: EMPTY
78953: LIST
78954: LIST
78955: PPUSH
78956: CALL_OW 72
78960: PUSH
78961: LD_VAR 0 3
78965: PPUSH
78966: CALL 54872 0 1
78970: NOT
78971: AND
78972: IFFALSE 79043
// begin if IsInUnit ( j ) then
78974: LD_VAR 0 3
78978: PPUSH
78979: CALL_OW 310
78983: IFFALSE 78994
// ComExitBuilding ( j ) ;
78985: LD_VAR 0 3
78989: PPUSH
78990: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
78994: LD_VAR 0 3
78998: PPUSH
78999: LD_EXP 78
79003: PUSH
79004: LD_VAR 0 2
79008: ARRAY
79009: PPUSH
79010: LD_INT 34
79012: PUSH
79013: LD_INT 31
79015: PUSH
79016: EMPTY
79017: LIST
79018: LIST
79019: PUSH
79020: LD_INT 58
79022: PUSH
79023: EMPTY
79024: LIST
79025: PUSH
79026: EMPTY
79027: LIST
79028: LIST
79029: PPUSH
79030: CALL_OW 72
79034: PUSH
79035: LD_INT 1
79037: ARRAY
79038: PPUSH
79039: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
79043: LD_VAR 0 3
79047: PPUSH
79048: CALL_OW 310
79052: NOT
79053: PUSH
79054: LD_VAR 0 3
79058: PPUSH
79059: CALL_OW 310
79063: PPUSH
79064: CALL_OW 266
79068: PUSH
79069: LD_INT 36
79071: NONEQUAL
79072: PUSH
79073: LD_VAR 0 3
79077: PPUSH
79078: CALL 54872 0 1
79082: NOT
79083: AND
79084: OR
79085: IFFALSE 79221
// begin if IsInUnit ( j ) then
79087: LD_VAR 0 3
79091: PPUSH
79092: CALL_OW 310
79096: IFFALSE 79107
// ComExitBuilding ( j ) ;
79098: LD_VAR 0 3
79102: PPUSH
79103: CALL_OW 122
// ct := 0 ;
79107: LD_ADDR_VAR 0 8
79111: PUSH
79112: LD_INT 0
79114: ST_TO_ADDR
// for k in x do
79115: LD_ADDR_VAR 0 4
79119: PUSH
79120: LD_VAR 0 11
79124: PUSH
79125: FOR_IN
79126: IFFALSE 79199
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
79128: LD_VAR 0 4
79132: PPUSH
79133: CALL_OW 264
79137: PUSH
79138: LD_INT 31
79140: EQUAL
79141: PUSH
79142: LD_VAR 0 4
79146: PPUSH
79147: CALL_OW 311
79151: NOT
79152: AND
79153: PUSH
79154: LD_VAR 0 4
79158: PPUSH
79159: CALL_OW 266
79163: PUSH
79164: LD_INT 36
79166: EQUAL
79167: PUSH
79168: LD_VAR 0 4
79172: PPUSH
79173: CALL_OW 313
79177: PUSH
79178: LD_INT 3
79180: LESS
79181: AND
79182: OR
79183: IFFALSE 79197
// begin ct := k ;
79185: LD_ADDR_VAR 0 8
79189: PUSH
79190: LD_VAR 0 4
79194: ST_TO_ADDR
// break ;
79195: GO 79199
// end ;
79197: GO 79125
79199: POP
79200: POP
// if ct then
79201: LD_VAR 0 8
79205: IFFALSE 79221
// ComEnterUnit ( j , ct ) ;
79207: LD_VAR 0 3
79211: PPUSH
79212: LD_VAR 0 8
79216: PPUSH
79217: CALL_OW 120
// end ; end ;
79221: GO 78856
79223: POP
79224: POP
// places := 0 ;
79225: LD_ADDR_VAR 0 5
79229: PUSH
79230: LD_INT 0
79232: ST_TO_ADDR
// for j = 1 to x do
79233: LD_ADDR_VAR 0 3
79237: PUSH
79238: DOUBLE
79239: LD_INT 1
79241: DEC
79242: ST_TO_ADDR
79243: LD_VAR 0 11
79247: PUSH
79248: FOR_TO
79249: IFFALSE 79325
// if GetWeapon ( x [ j ] ) = ar_control_tower then
79251: LD_VAR 0 11
79255: PUSH
79256: LD_VAR 0 3
79260: ARRAY
79261: PPUSH
79262: CALL_OW 264
79266: PUSH
79267: LD_INT 31
79269: EQUAL
79270: IFFALSE 79288
// places := places + 1 else
79272: LD_ADDR_VAR 0 5
79276: PUSH
79277: LD_VAR 0 5
79281: PUSH
79282: LD_INT 1
79284: PLUS
79285: ST_TO_ADDR
79286: GO 79323
// if GetBType ( x [ j ] ) = b_control_tower then
79288: LD_VAR 0 11
79292: PUSH
79293: LD_VAR 0 3
79297: ARRAY
79298: PPUSH
79299: CALL_OW 266
79303: PUSH
79304: LD_INT 36
79306: EQUAL
79307: IFFALSE 79323
// places := places + 3 ;
79309: LD_ADDR_VAR 0 5
79313: PUSH
79314: LD_VAR 0 5
79318: PUSH
79319: LD_INT 3
79321: PLUS
79322: ST_TO_ADDR
79323: GO 79248
79325: POP
79326: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
79327: LD_VAR 0 5
79331: PUSH
79332: LD_INT 0
79334: EQUAL
79335: PUSH
79336: LD_VAR 0 5
79340: PUSH
79341: LD_EXP 99
79345: PUSH
79346: LD_VAR 0 2
79350: ARRAY
79351: LESSEQUAL
79352: OR
79353: IFFALSE 79357
// continue ;
79355: GO 78607
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
79357: LD_ADDR_VAR 0 6
79361: PUSH
79362: LD_EXP 59
79366: PUSH
79367: LD_VAR 0 2
79371: ARRAY
79372: PPUSH
79373: LD_INT 25
79375: PUSH
79376: LD_INT 3
79378: PUSH
79379: EMPTY
79380: LIST
79381: LIST
79382: PPUSH
79383: CALL_OW 72
79387: PUSH
79388: LD_EXP 99
79392: PUSH
79393: LD_VAR 0 2
79397: ARRAY
79398: DIFF
79399: PPUSH
79400: LD_INT 3
79402: PPUSH
79403: CALL 55772 0 2
79407: ST_TO_ADDR
// for j in tmp do
79408: LD_ADDR_VAR 0 3
79412: PUSH
79413: LD_VAR 0 6
79417: PUSH
79418: FOR_IN
79419: IFFALSE 79454
// if GetTag ( j ) > 0 then
79421: LD_VAR 0 3
79425: PPUSH
79426: CALL_OW 110
79430: PUSH
79431: LD_INT 0
79433: GREATER
79434: IFFALSE 79452
// tmp := tmp diff j ;
79436: LD_ADDR_VAR 0 6
79440: PUSH
79441: LD_VAR 0 6
79445: PUSH
79446: LD_VAR 0 3
79450: DIFF
79451: ST_TO_ADDR
79452: GO 79418
79454: POP
79455: POP
// if not tmp then
79456: LD_VAR 0 6
79460: NOT
79461: IFFALSE 79465
// continue ;
79463: GO 78607
// if places then
79465: LD_VAR 0 5
79469: IFFALSE 79528
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
79471: LD_ADDR_EXP 99
79475: PUSH
79476: LD_EXP 99
79480: PPUSH
79481: LD_VAR 0 2
79485: PPUSH
79486: LD_EXP 99
79490: PUSH
79491: LD_VAR 0 2
79495: ARRAY
79496: PUSH
79497: LD_VAR 0 6
79501: PUSH
79502: LD_INT 1
79504: ARRAY
79505: UNION
79506: PPUSH
79507: CALL_OW 1
79511: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
79512: LD_VAR 0 6
79516: PUSH
79517: LD_INT 1
79519: ARRAY
79520: PPUSH
79521: LD_INT 126
79523: PPUSH
79524: CALL_OW 109
// end ; end ;
79528: GO 78607
79530: POP
79531: POP
// end ;
79532: LD_VAR 0 1
79536: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79537: LD_INT 0
79539: PPUSH
79540: PPUSH
79541: PPUSH
79542: PPUSH
79543: PPUSH
79544: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79545: LD_VAR 0 1
79549: NOT
79550: PUSH
79551: LD_VAR 0 2
79555: NOT
79556: OR
79557: PUSH
79558: LD_VAR 0 3
79562: NOT
79563: OR
79564: PUSH
79565: LD_VAR 0 4
79569: PUSH
79570: LD_INT 1
79572: PUSH
79573: LD_INT 2
79575: PUSH
79576: LD_INT 3
79578: PUSH
79579: LD_INT 4
79581: PUSH
79582: LD_INT 5
79584: PUSH
79585: LD_INT 8
79587: PUSH
79588: LD_INT 9
79590: PUSH
79591: LD_INT 15
79593: PUSH
79594: LD_INT 16
79596: PUSH
79597: EMPTY
79598: LIST
79599: LIST
79600: LIST
79601: LIST
79602: LIST
79603: LIST
79604: LIST
79605: LIST
79606: LIST
79607: IN
79608: NOT
79609: OR
79610: IFFALSE 79614
// exit ;
79612: GO 80514
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79614: LD_ADDR_VAR 0 2
79618: PUSH
79619: LD_VAR 0 2
79623: PPUSH
79624: LD_INT 21
79626: PUSH
79627: LD_INT 3
79629: PUSH
79630: EMPTY
79631: LIST
79632: LIST
79633: PUSH
79634: LD_INT 24
79636: PUSH
79637: LD_INT 250
79639: PUSH
79640: EMPTY
79641: LIST
79642: LIST
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PPUSH
79648: CALL_OW 72
79652: ST_TO_ADDR
// case class of 1 , 15 :
79653: LD_VAR 0 4
79657: PUSH
79658: LD_INT 1
79660: DOUBLE
79661: EQUAL
79662: IFTRUE 79672
79664: LD_INT 15
79666: DOUBLE
79667: EQUAL
79668: IFTRUE 79672
79670: GO 79757
79672: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79673: LD_ADDR_VAR 0 8
79677: PUSH
79678: LD_VAR 0 2
79682: PPUSH
79683: LD_INT 2
79685: PUSH
79686: LD_INT 30
79688: PUSH
79689: LD_INT 32
79691: PUSH
79692: EMPTY
79693: LIST
79694: LIST
79695: PUSH
79696: LD_INT 30
79698: PUSH
79699: LD_INT 31
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PUSH
79706: EMPTY
79707: LIST
79708: LIST
79709: LIST
79710: PPUSH
79711: CALL_OW 72
79715: PUSH
79716: LD_VAR 0 2
79720: PPUSH
79721: LD_INT 2
79723: PUSH
79724: LD_INT 30
79726: PUSH
79727: LD_INT 4
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PUSH
79734: LD_INT 30
79736: PUSH
79737: LD_INT 5
79739: PUSH
79740: EMPTY
79741: LIST
79742: LIST
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: LIST
79748: PPUSH
79749: CALL_OW 72
79753: ADD
79754: ST_TO_ADDR
79755: GO 80003
79757: LD_INT 2
79759: DOUBLE
79760: EQUAL
79761: IFTRUE 79771
79763: LD_INT 16
79765: DOUBLE
79766: EQUAL
79767: IFTRUE 79771
79769: GO 79817
79771: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79772: LD_ADDR_VAR 0 8
79776: PUSH
79777: LD_VAR 0 2
79781: PPUSH
79782: LD_INT 2
79784: PUSH
79785: LD_INT 30
79787: PUSH
79788: LD_INT 0
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PUSH
79795: LD_INT 30
79797: PUSH
79798: LD_INT 1
79800: PUSH
79801: EMPTY
79802: LIST
79803: LIST
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: LIST
79809: PPUSH
79810: CALL_OW 72
79814: ST_TO_ADDR
79815: GO 80003
79817: LD_INT 3
79819: DOUBLE
79820: EQUAL
79821: IFTRUE 79825
79823: GO 79871
79825: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79826: LD_ADDR_VAR 0 8
79830: PUSH
79831: LD_VAR 0 2
79835: PPUSH
79836: LD_INT 2
79838: PUSH
79839: LD_INT 30
79841: PUSH
79842: LD_INT 2
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: LD_INT 30
79851: PUSH
79852: LD_INT 3
79854: PUSH
79855: EMPTY
79856: LIST
79857: LIST
79858: PUSH
79859: EMPTY
79860: LIST
79861: LIST
79862: LIST
79863: PPUSH
79864: CALL_OW 72
79868: ST_TO_ADDR
79869: GO 80003
79871: LD_INT 4
79873: DOUBLE
79874: EQUAL
79875: IFTRUE 79879
79877: GO 79936
79879: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79880: LD_ADDR_VAR 0 8
79884: PUSH
79885: LD_VAR 0 2
79889: PPUSH
79890: LD_INT 2
79892: PUSH
79893: LD_INT 30
79895: PUSH
79896: LD_INT 6
79898: PUSH
79899: EMPTY
79900: LIST
79901: LIST
79902: PUSH
79903: LD_INT 30
79905: PUSH
79906: LD_INT 7
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PUSH
79913: LD_INT 30
79915: PUSH
79916: LD_INT 8
79918: PUSH
79919: EMPTY
79920: LIST
79921: LIST
79922: PUSH
79923: EMPTY
79924: LIST
79925: LIST
79926: LIST
79927: LIST
79928: PPUSH
79929: CALL_OW 72
79933: ST_TO_ADDR
79934: GO 80003
79936: LD_INT 5
79938: DOUBLE
79939: EQUAL
79940: IFTRUE 79956
79942: LD_INT 8
79944: DOUBLE
79945: EQUAL
79946: IFTRUE 79956
79948: LD_INT 9
79950: DOUBLE
79951: EQUAL
79952: IFTRUE 79956
79954: GO 80002
79956: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79957: LD_ADDR_VAR 0 8
79961: PUSH
79962: LD_VAR 0 2
79966: PPUSH
79967: LD_INT 2
79969: PUSH
79970: LD_INT 30
79972: PUSH
79973: LD_INT 4
79975: PUSH
79976: EMPTY
79977: LIST
79978: LIST
79979: PUSH
79980: LD_INT 30
79982: PUSH
79983: LD_INT 5
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: EMPTY
79991: LIST
79992: LIST
79993: LIST
79994: PPUSH
79995: CALL_OW 72
79999: ST_TO_ADDR
80000: GO 80003
80002: POP
// if not tmp then
80003: LD_VAR 0 8
80007: NOT
80008: IFFALSE 80012
// exit ;
80010: GO 80514
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
80012: LD_VAR 0 4
80016: PUSH
80017: LD_INT 1
80019: PUSH
80020: LD_INT 15
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: IN
80027: PUSH
80028: LD_EXP 68
80032: PUSH
80033: LD_VAR 0 1
80037: ARRAY
80038: AND
80039: IFFALSE 80195
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
80041: LD_ADDR_VAR 0 9
80045: PUSH
80046: LD_EXP 68
80050: PUSH
80051: LD_VAR 0 1
80055: ARRAY
80056: PUSH
80057: LD_INT 1
80059: ARRAY
80060: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
80061: LD_VAR 0 9
80065: PUSH
80066: LD_EXP 69
80070: PUSH
80071: LD_VAR 0 1
80075: ARRAY
80076: IN
80077: NOT
80078: IFFALSE 80193
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
80080: LD_ADDR_EXP 69
80084: PUSH
80085: LD_EXP 69
80089: PPUSH
80090: LD_VAR 0 1
80094: PUSH
80095: LD_EXP 69
80099: PUSH
80100: LD_VAR 0 1
80104: ARRAY
80105: PUSH
80106: LD_INT 1
80108: PLUS
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: PPUSH
80114: LD_VAR 0 9
80118: PPUSH
80119: CALL 21521 0 3
80123: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
80124: LD_ADDR_EXP 68
80128: PUSH
80129: LD_EXP 68
80133: PPUSH
80134: LD_VAR 0 1
80138: PPUSH
80139: LD_EXP 68
80143: PUSH
80144: LD_VAR 0 1
80148: ARRAY
80149: PUSH
80150: LD_VAR 0 9
80154: DIFF
80155: PPUSH
80156: CALL_OW 1
80160: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
80161: LD_VAR 0 3
80165: PPUSH
80166: LD_EXP 69
80170: PUSH
80171: LD_VAR 0 1
80175: ARRAY
80176: PUSH
80177: LD_EXP 69
80181: PUSH
80182: LD_VAR 0 1
80186: ARRAY
80187: ARRAY
80188: PPUSH
80189: CALL_OW 120
// end ; exit ;
80193: GO 80514
// end ; if tmp > 1 then
80195: LD_VAR 0 8
80199: PUSH
80200: LD_INT 1
80202: GREATER
80203: IFFALSE 80307
// for i = 2 to tmp do
80205: LD_ADDR_VAR 0 6
80209: PUSH
80210: DOUBLE
80211: LD_INT 2
80213: DEC
80214: ST_TO_ADDR
80215: LD_VAR 0 8
80219: PUSH
80220: FOR_TO
80221: IFFALSE 80305
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
80223: LD_VAR 0 8
80227: PUSH
80228: LD_VAR 0 6
80232: ARRAY
80233: PPUSH
80234: CALL_OW 461
80238: PUSH
80239: LD_INT 6
80241: EQUAL
80242: IFFALSE 80303
// begin x := tmp [ i ] ;
80244: LD_ADDR_VAR 0 9
80248: PUSH
80249: LD_VAR 0 8
80253: PUSH
80254: LD_VAR 0 6
80258: ARRAY
80259: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
80260: LD_ADDR_VAR 0 8
80264: PUSH
80265: LD_VAR 0 8
80269: PPUSH
80270: LD_VAR 0 6
80274: PPUSH
80275: CALL_OW 3
80279: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
80280: LD_ADDR_VAR 0 8
80284: PUSH
80285: LD_VAR 0 8
80289: PPUSH
80290: LD_INT 1
80292: PPUSH
80293: LD_VAR 0 9
80297: PPUSH
80298: CALL_OW 2
80302: ST_TO_ADDR
// end ;
80303: GO 80220
80305: POP
80306: POP
// for i in tmp do
80307: LD_ADDR_VAR 0 6
80311: PUSH
80312: LD_VAR 0 8
80316: PUSH
80317: FOR_IN
80318: IFFALSE 80387
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
80320: LD_VAR 0 6
80324: PPUSH
80325: CALL_OW 313
80329: PUSH
80330: LD_INT 6
80332: LESS
80333: PUSH
80334: LD_VAR 0 6
80338: PPUSH
80339: CALL_OW 266
80343: PUSH
80344: LD_INT 31
80346: PUSH
80347: LD_INT 32
80349: PUSH
80350: EMPTY
80351: LIST
80352: LIST
80353: IN
80354: NOT
80355: AND
80356: PUSH
80357: LD_VAR 0 6
80361: PPUSH
80362: CALL_OW 313
80366: PUSH
80367: LD_INT 0
80369: EQUAL
80370: OR
80371: IFFALSE 80385
// begin j := i ;
80373: LD_ADDR_VAR 0 7
80377: PUSH
80378: LD_VAR 0 6
80382: ST_TO_ADDR
// break ;
80383: GO 80387
// end ; end ;
80385: GO 80317
80387: POP
80388: POP
// if j then
80389: LD_VAR 0 7
80393: IFFALSE 80411
// ComEnterUnit ( unit , j ) else
80395: LD_VAR 0 3
80399: PPUSH
80400: LD_VAR 0 7
80404: PPUSH
80405: CALL_OW 120
80409: GO 80514
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80411: LD_ADDR_VAR 0 10
80415: PUSH
80416: LD_VAR 0 2
80420: PPUSH
80421: LD_INT 2
80423: PUSH
80424: LD_INT 30
80426: PUSH
80427: LD_INT 0
80429: PUSH
80430: EMPTY
80431: LIST
80432: LIST
80433: PUSH
80434: LD_INT 30
80436: PUSH
80437: LD_INT 1
80439: PUSH
80440: EMPTY
80441: LIST
80442: LIST
80443: PUSH
80444: EMPTY
80445: LIST
80446: LIST
80447: LIST
80448: PPUSH
80449: CALL_OW 72
80453: ST_TO_ADDR
// if depot then
80454: LD_VAR 0 10
80458: IFFALSE 80514
// begin depot := NearestUnitToUnit ( depot , unit ) ;
80460: LD_ADDR_VAR 0 10
80464: PUSH
80465: LD_VAR 0 10
80469: PPUSH
80470: LD_VAR 0 3
80474: PPUSH
80475: CALL_OW 74
80479: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
80480: LD_VAR 0 3
80484: PPUSH
80485: LD_VAR 0 10
80489: PPUSH
80490: CALL_OW 296
80494: PUSH
80495: LD_INT 10
80497: GREATER
80498: IFFALSE 80514
// ComStandNearbyBuilding ( unit , depot ) ;
80500: LD_VAR 0 3
80504: PPUSH
80505: LD_VAR 0 10
80509: PPUSH
80510: CALL 15724 0 2
// end ; end ; end ;
80514: LD_VAR 0 5
80518: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
80519: LD_INT 0
80521: PPUSH
80522: PPUSH
80523: PPUSH
80524: PPUSH
// if not mc_bases then
80525: LD_EXP 59
80529: NOT
80530: IFFALSE 80534
// exit ;
80532: GO 80773
// for i = 1 to mc_bases do
80534: LD_ADDR_VAR 0 2
80538: PUSH
80539: DOUBLE
80540: LD_INT 1
80542: DEC
80543: ST_TO_ADDR
80544: LD_EXP 59
80548: PUSH
80549: FOR_TO
80550: IFFALSE 80771
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80552: LD_ADDR_VAR 0 4
80556: PUSH
80557: LD_EXP 59
80561: PUSH
80562: LD_VAR 0 2
80566: ARRAY
80567: PPUSH
80568: LD_INT 21
80570: PUSH
80571: LD_INT 1
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: PPUSH
80578: CALL_OW 72
80582: PUSH
80583: LD_EXP 88
80587: PUSH
80588: LD_VAR 0 2
80592: ARRAY
80593: UNION
80594: ST_TO_ADDR
// if not tmp then
80595: LD_VAR 0 4
80599: NOT
80600: IFFALSE 80604
// continue ;
80602: GO 80549
// for j in tmp do
80604: LD_ADDR_VAR 0 3
80608: PUSH
80609: LD_VAR 0 4
80613: PUSH
80614: FOR_IN
80615: IFFALSE 80767
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80617: LD_VAR 0 3
80621: PPUSH
80622: CALL_OW 110
80626: NOT
80627: PUSH
80628: LD_VAR 0 3
80632: PPUSH
80633: CALL_OW 314
80637: NOT
80638: AND
80639: PUSH
80640: LD_VAR 0 3
80644: PPUSH
80645: CALL_OW 311
80649: NOT
80650: AND
80651: PUSH
80652: LD_VAR 0 3
80656: PPUSH
80657: CALL_OW 310
80661: NOT
80662: AND
80663: PUSH
80664: LD_VAR 0 3
80668: PUSH
80669: LD_EXP 62
80673: PUSH
80674: LD_VAR 0 2
80678: ARRAY
80679: PUSH
80680: LD_INT 1
80682: ARRAY
80683: IN
80684: NOT
80685: AND
80686: PUSH
80687: LD_VAR 0 3
80691: PUSH
80692: LD_EXP 62
80696: PUSH
80697: LD_VAR 0 2
80701: ARRAY
80702: PUSH
80703: LD_INT 2
80705: ARRAY
80706: IN
80707: NOT
80708: AND
80709: PUSH
80710: LD_VAR 0 3
80714: PUSH
80715: LD_EXP 71
80719: PUSH
80720: LD_VAR 0 2
80724: ARRAY
80725: IN
80726: NOT
80727: AND
80728: IFFALSE 80765
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80730: LD_VAR 0 2
80734: PPUSH
80735: LD_EXP 59
80739: PUSH
80740: LD_VAR 0 2
80744: ARRAY
80745: PPUSH
80746: LD_VAR 0 3
80750: PPUSH
80751: LD_VAR 0 3
80755: PPUSH
80756: CALL_OW 257
80760: PPUSH
80761: CALL 79537 0 4
// end ;
80765: GO 80614
80767: POP
80768: POP
// end ;
80769: GO 80549
80771: POP
80772: POP
// end ;
80773: LD_VAR 0 1
80777: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
80778: LD_INT 0
80780: PPUSH
80781: PPUSH
80782: PPUSH
80783: PPUSH
80784: PPUSH
80785: PPUSH
// if not mc_bases [ base ] then
80786: LD_EXP 59
80790: PUSH
80791: LD_VAR 0 1
80795: ARRAY
80796: NOT
80797: IFFALSE 80801
// exit ;
80799: GO 80983
// tmp := [ ] ;
80801: LD_ADDR_VAR 0 6
80805: PUSH
80806: EMPTY
80807: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80808: LD_ADDR_VAR 0 7
80812: PUSH
80813: LD_VAR 0 3
80817: PPUSH
80818: LD_INT 0
80820: PPUSH
80821: CALL_OW 517
80825: ST_TO_ADDR
// if not list then
80826: LD_VAR 0 7
80830: NOT
80831: IFFALSE 80835
// exit ;
80833: GO 80983
// for i = 1 to amount do
80835: LD_ADDR_VAR 0 5
80839: PUSH
80840: DOUBLE
80841: LD_INT 1
80843: DEC
80844: ST_TO_ADDR
80845: LD_VAR 0 2
80849: PUSH
80850: FOR_TO
80851: IFFALSE 80931
// begin x := rand ( 1 , list [ 1 ] ) ;
80853: LD_ADDR_VAR 0 8
80857: PUSH
80858: LD_INT 1
80860: PPUSH
80861: LD_VAR 0 7
80865: PUSH
80866: LD_INT 1
80868: ARRAY
80869: PPUSH
80870: CALL_OW 12
80874: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
80875: LD_ADDR_VAR 0 6
80879: PUSH
80880: LD_VAR 0 6
80884: PPUSH
80885: LD_VAR 0 5
80889: PPUSH
80890: LD_VAR 0 7
80894: PUSH
80895: LD_INT 1
80897: ARRAY
80898: PUSH
80899: LD_VAR 0 8
80903: ARRAY
80904: PUSH
80905: LD_VAR 0 7
80909: PUSH
80910: LD_INT 2
80912: ARRAY
80913: PUSH
80914: LD_VAR 0 8
80918: ARRAY
80919: PUSH
80920: EMPTY
80921: LIST
80922: LIST
80923: PPUSH
80924: CALL_OW 1
80928: ST_TO_ADDR
// end ;
80929: GO 80850
80931: POP
80932: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80933: LD_ADDR_EXP 72
80937: PUSH
80938: LD_EXP 72
80942: PPUSH
80943: LD_VAR 0 1
80947: PPUSH
80948: LD_VAR 0 6
80952: PPUSH
80953: CALL_OW 1
80957: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80958: LD_ADDR_EXP 74
80962: PUSH
80963: LD_EXP 74
80967: PPUSH
80968: LD_VAR 0 1
80972: PPUSH
80973: LD_VAR 0 3
80977: PPUSH
80978: CALL_OW 1
80982: ST_TO_ADDR
// end ;
80983: LD_VAR 0 4
80987: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
80988: LD_INT 0
80990: PPUSH
// if not mc_bases [ base ] then
80991: LD_EXP 59
80995: PUSH
80996: LD_VAR 0 1
81000: ARRAY
81001: NOT
81002: IFFALSE 81006
// exit ;
81004: GO 81031
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
81006: LD_ADDR_EXP 64
81010: PUSH
81011: LD_EXP 64
81015: PPUSH
81016: LD_VAR 0 1
81020: PPUSH
81021: LD_VAR 0 2
81025: PPUSH
81026: CALL_OW 1
81030: ST_TO_ADDR
// end ;
81031: LD_VAR 0 3
81035: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
81036: LD_INT 0
81038: PPUSH
// if not mc_bases [ base ] then
81039: LD_EXP 59
81043: PUSH
81044: LD_VAR 0 1
81048: ARRAY
81049: NOT
81050: IFFALSE 81054
// exit ;
81052: GO 81091
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
81054: LD_ADDR_EXP 64
81058: PUSH
81059: LD_EXP 64
81063: PPUSH
81064: LD_VAR 0 1
81068: PPUSH
81069: LD_EXP 64
81073: PUSH
81074: LD_VAR 0 1
81078: ARRAY
81079: PUSH
81080: LD_VAR 0 2
81084: UNION
81085: PPUSH
81086: CALL_OW 1
81090: ST_TO_ADDR
// end ;
81091: LD_VAR 0 3
81095: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
81096: LD_INT 0
81098: PPUSH
// if not mc_bases [ base ] then
81099: LD_EXP 59
81103: PUSH
81104: LD_VAR 0 1
81108: ARRAY
81109: NOT
81110: IFFALSE 81114
// exit ;
81112: GO 81139
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
81114: LD_ADDR_EXP 80
81118: PUSH
81119: LD_EXP 80
81123: PPUSH
81124: LD_VAR 0 1
81128: PPUSH
81129: LD_VAR 0 2
81133: PPUSH
81134: CALL_OW 1
81138: ST_TO_ADDR
// end ;
81139: LD_VAR 0 3
81143: RET
// export function MC_InsertProduceList ( base , components ) ; begin
81144: LD_INT 0
81146: PPUSH
// if not mc_bases [ base ] then
81147: LD_EXP 59
81151: PUSH
81152: LD_VAR 0 1
81156: ARRAY
81157: NOT
81158: IFFALSE 81162
// exit ;
81160: GO 81199
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
81162: LD_ADDR_EXP 80
81166: PUSH
81167: LD_EXP 80
81171: PPUSH
81172: LD_VAR 0 1
81176: PPUSH
81177: LD_EXP 80
81181: PUSH
81182: LD_VAR 0 1
81186: ARRAY
81187: PUSH
81188: LD_VAR 0 2
81192: ADD
81193: PPUSH
81194: CALL_OW 1
81198: ST_TO_ADDR
// end ;
81199: LD_VAR 0 3
81203: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
81204: LD_INT 0
81206: PPUSH
// if not mc_bases [ base ] then
81207: LD_EXP 59
81211: PUSH
81212: LD_VAR 0 1
81216: ARRAY
81217: NOT
81218: IFFALSE 81222
// exit ;
81220: GO 81276
// mc_defender := Replace ( mc_defender , base , deflist ) ;
81222: LD_ADDR_EXP 81
81226: PUSH
81227: LD_EXP 81
81231: PPUSH
81232: LD_VAR 0 1
81236: PPUSH
81237: LD_VAR 0 2
81241: PPUSH
81242: CALL_OW 1
81246: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
81247: LD_ADDR_EXP 70
81251: PUSH
81252: LD_EXP 70
81256: PPUSH
81257: LD_VAR 0 1
81261: PPUSH
81262: LD_VAR 0 2
81266: PUSH
81267: LD_INT 0
81269: PLUS
81270: PPUSH
81271: CALL_OW 1
81275: ST_TO_ADDR
// end ;
81276: LD_VAR 0 3
81280: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
81281: LD_INT 0
81283: PPUSH
// if not mc_bases [ base ] then
81284: LD_EXP 59
81288: PUSH
81289: LD_VAR 0 1
81293: ARRAY
81294: NOT
81295: IFFALSE 81299
// exit ;
81297: GO 81324
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
81299: LD_ADDR_EXP 70
81303: PUSH
81304: LD_EXP 70
81308: PPUSH
81309: LD_VAR 0 1
81313: PPUSH
81314: LD_VAR 0 2
81318: PPUSH
81319: CALL_OW 1
81323: ST_TO_ADDR
// end ;
81324: LD_VAR 0 3
81328: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
81329: LD_INT 0
81331: PPUSH
81332: PPUSH
81333: PPUSH
81334: PPUSH
// if not mc_bases [ base ] then
81335: LD_EXP 59
81339: PUSH
81340: LD_VAR 0 1
81344: ARRAY
81345: NOT
81346: IFFALSE 81350
// exit ;
81348: GO 81415
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
81350: LD_ADDR_EXP 79
81354: PUSH
81355: LD_EXP 79
81359: PPUSH
81360: LD_VAR 0 1
81364: PUSH
81365: LD_EXP 79
81369: PUSH
81370: LD_VAR 0 1
81374: ARRAY
81375: PUSH
81376: LD_INT 1
81378: PLUS
81379: PUSH
81380: EMPTY
81381: LIST
81382: LIST
81383: PPUSH
81384: LD_VAR 0 1
81388: PUSH
81389: LD_VAR 0 2
81393: PUSH
81394: LD_VAR 0 3
81398: PUSH
81399: LD_VAR 0 4
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: LIST
81408: LIST
81409: PPUSH
81410: CALL 21521 0 3
81414: ST_TO_ADDR
// end ;
81415: LD_VAR 0 5
81419: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
81420: LD_INT 0
81422: PPUSH
// if not mc_bases [ base ] then
81423: LD_EXP 59
81427: PUSH
81428: LD_VAR 0 1
81432: ARRAY
81433: NOT
81434: IFFALSE 81438
// exit ;
81436: GO 81463
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
81438: LD_ADDR_EXP 96
81442: PUSH
81443: LD_EXP 96
81447: PPUSH
81448: LD_VAR 0 1
81452: PPUSH
81453: LD_VAR 0 2
81457: PPUSH
81458: CALL_OW 1
81462: ST_TO_ADDR
// end ;
81463: LD_VAR 0 3
81467: RET
// export function MC_GetMinesField ( base ) ; begin
81468: LD_INT 0
81470: PPUSH
// result := mc_mines [ base ] ;
81471: LD_ADDR_VAR 0 2
81475: PUSH
81476: LD_EXP 72
81480: PUSH
81481: LD_VAR 0 1
81485: ARRAY
81486: ST_TO_ADDR
// end ;
81487: LD_VAR 0 2
81491: RET
// export function MC_GetProduceList ( base ) ; begin
81492: LD_INT 0
81494: PPUSH
// result := mc_produce [ base ] ;
81495: LD_ADDR_VAR 0 2
81499: PUSH
81500: LD_EXP 80
81504: PUSH
81505: LD_VAR 0 1
81509: ARRAY
81510: ST_TO_ADDR
// end ;
81511: LD_VAR 0 2
81515: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
81516: LD_INT 0
81518: PPUSH
81519: PPUSH
// if not mc_bases then
81520: LD_EXP 59
81524: NOT
81525: IFFALSE 81529
// exit ;
81527: GO 81594
// if mc_bases [ base ] then
81529: LD_EXP 59
81533: PUSH
81534: LD_VAR 0 1
81538: ARRAY
81539: IFFALSE 81594
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81541: LD_ADDR_VAR 0 3
81545: PUSH
81546: LD_EXP 59
81550: PUSH
81551: LD_VAR 0 1
81555: ARRAY
81556: PPUSH
81557: LD_INT 30
81559: PUSH
81560: LD_VAR 0 2
81564: PUSH
81565: EMPTY
81566: LIST
81567: LIST
81568: PPUSH
81569: CALL_OW 72
81573: ST_TO_ADDR
// if result then
81574: LD_VAR 0 3
81578: IFFALSE 81594
// result := result [ 1 ] ;
81580: LD_ADDR_VAR 0 3
81584: PUSH
81585: LD_VAR 0 3
81589: PUSH
81590: LD_INT 1
81592: ARRAY
81593: ST_TO_ADDR
// end ; end ;
81594: LD_VAR 0 3
81598: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81599: LD_INT 0
81601: PPUSH
81602: PPUSH
// if not mc_bases then
81603: LD_EXP 59
81607: NOT
81608: IFFALSE 81612
// exit ;
81610: GO 81657
// if mc_bases [ base ] then
81612: LD_EXP 59
81616: PUSH
81617: LD_VAR 0 1
81621: ARRAY
81622: IFFALSE 81657
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81624: LD_ADDR_VAR 0 3
81628: PUSH
81629: LD_EXP 59
81633: PUSH
81634: LD_VAR 0 1
81638: ARRAY
81639: PPUSH
81640: LD_INT 30
81642: PUSH
81643: LD_VAR 0 2
81647: PUSH
81648: EMPTY
81649: LIST
81650: LIST
81651: PPUSH
81652: CALL_OW 72
81656: ST_TO_ADDR
// end ;
81657: LD_VAR 0 3
81661: RET
// export function MC_SetTame ( base , area ) ; begin
81662: LD_INT 0
81664: PPUSH
// if not mc_bases or not base then
81665: LD_EXP 59
81669: NOT
81670: PUSH
81671: LD_VAR 0 1
81675: NOT
81676: OR
81677: IFFALSE 81681
// exit ;
81679: GO 81706
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81681: LD_ADDR_EXP 87
81685: PUSH
81686: LD_EXP 87
81690: PPUSH
81691: LD_VAR 0 1
81695: PPUSH
81696: LD_VAR 0 2
81700: PPUSH
81701: CALL_OW 1
81705: ST_TO_ADDR
// end ;
81706: LD_VAR 0 3
81710: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81711: LD_INT 0
81713: PPUSH
81714: PPUSH
// if not mc_bases or not base then
81715: LD_EXP 59
81719: NOT
81720: PUSH
81721: LD_VAR 0 1
81725: NOT
81726: OR
81727: IFFALSE 81731
// exit ;
81729: GO 81833
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81731: LD_ADDR_VAR 0 4
81735: PUSH
81736: LD_EXP 59
81740: PUSH
81741: LD_VAR 0 1
81745: ARRAY
81746: PPUSH
81747: LD_INT 30
81749: PUSH
81750: LD_VAR 0 2
81754: PUSH
81755: EMPTY
81756: LIST
81757: LIST
81758: PPUSH
81759: CALL_OW 72
81763: ST_TO_ADDR
// if not tmp then
81764: LD_VAR 0 4
81768: NOT
81769: IFFALSE 81773
// exit ;
81771: GO 81833
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81773: LD_ADDR_EXP 91
81777: PUSH
81778: LD_EXP 91
81782: PPUSH
81783: LD_VAR 0 1
81787: PPUSH
81788: LD_EXP 91
81792: PUSH
81793: LD_VAR 0 1
81797: ARRAY
81798: PPUSH
81799: LD_EXP 91
81803: PUSH
81804: LD_VAR 0 1
81808: ARRAY
81809: PUSH
81810: LD_INT 1
81812: PLUS
81813: PPUSH
81814: LD_VAR 0 4
81818: PUSH
81819: LD_INT 1
81821: ARRAY
81822: PPUSH
81823: CALL_OW 2
81827: PPUSH
81828: CALL_OW 1
81832: ST_TO_ADDR
// end ;
81833: LD_VAR 0 3
81837: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81838: LD_INT 0
81840: PPUSH
81841: PPUSH
// if not mc_bases or not base or not kinds then
81842: LD_EXP 59
81846: NOT
81847: PUSH
81848: LD_VAR 0 1
81852: NOT
81853: OR
81854: PUSH
81855: LD_VAR 0 2
81859: NOT
81860: OR
81861: IFFALSE 81865
// exit ;
81863: GO 81926
// for i in kinds do
81865: LD_ADDR_VAR 0 4
81869: PUSH
81870: LD_VAR 0 2
81874: PUSH
81875: FOR_IN
81876: IFFALSE 81924
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81878: LD_ADDR_EXP 93
81882: PUSH
81883: LD_EXP 93
81887: PPUSH
81888: LD_VAR 0 1
81892: PUSH
81893: LD_EXP 93
81897: PUSH
81898: LD_VAR 0 1
81902: ARRAY
81903: PUSH
81904: LD_INT 1
81906: PLUS
81907: PUSH
81908: EMPTY
81909: LIST
81910: LIST
81911: PPUSH
81912: LD_VAR 0 4
81916: PPUSH
81917: CALL 21521 0 3
81921: ST_TO_ADDR
81922: GO 81875
81924: POP
81925: POP
// end ;
81926: LD_VAR 0 3
81930: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81931: LD_INT 0
81933: PPUSH
// if not mc_bases or not base or not areas then
81934: LD_EXP 59
81938: NOT
81939: PUSH
81940: LD_VAR 0 1
81944: NOT
81945: OR
81946: PUSH
81947: LD_VAR 0 2
81951: NOT
81952: OR
81953: IFFALSE 81957
// exit ;
81955: GO 81982
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81957: LD_ADDR_EXP 77
81961: PUSH
81962: LD_EXP 77
81966: PPUSH
81967: LD_VAR 0 1
81971: PPUSH
81972: LD_VAR 0 2
81976: PPUSH
81977: CALL_OW 1
81981: ST_TO_ADDR
// end ;
81982: LD_VAR 0 3
81986: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
81987: LD_INT 0
81989: PPUSH
// if not mc_bases or not base or not teleports_exit then
81990: LD_EXP 59
81994: NOT
81995: PUSH
81996: LD_VAR 0 1
82000: NOT
82001: OR
82002: PUSH
82003: LD_VAR 0 2
82007: NOT
82008: OR
82009: IFFALSE 82013
// exit ;
82011: GO 82038
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
82013: LD_ADDR_EXP 94
82017: PUSH
82018: LD_EXP 94
82022: PPUSH
82023: LD_VAR 0 1
82027: PPUSH
82028: LD_VAR 0 2
82032: PPUSH
82033: CALL_OW 1
82037: ST_TO_ADDR
// end ;
82038: LD_VAR 0 3
82042: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
82043: LD_INT 0
82045: PPUSH
82046: PPUSH
82047: PPUSH
// if not mc_bases or not base or not ext_list then
82048: LD_EXP 59
82052: NOT
82053: PUSH
82054: LD_VAR 0 1
82058: NOT
82059: OR
82060: PUSH
82061: LD_VAR 0 5
82065: NOT
82066: OR
82067: IFFALSE 82071
// exit ;
82069: GO 82244
// tmp := GetFacExtXYD ( x , y , d ) ;
82071: LD_ADDR_VAR 0 8
82075: PUSH
82076: LD_VAR 0 2
82080: PPUSH
82081: LD_VAR 0 3
82085: PPUSH
82086: LD_VAR 0 4
82090: PPUSH
82091: CALL 54902 0 3
82095: ST_TO_ADDR
// if not tmp then
82096: LD_VAR 0 8
82100: NOT
82101: IFFALSE 82105
// exit ;
82103: GO 82244
// for i in tmp do
82105: LD_ADDR_VAR 0 7
82109: PUSH
82110: LD_VAR 0 8
82114: PUSH
82115: FOR_IN
82116: IFFALSE 82242
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
82118: LD_ADDR_EXP 64
82122: PUSH
82123: LD_EXP 64
82127: PPUSH
82128: LD_VAR 0 1
82132: PPUSH
82133: LD_EXP 64
82137: PUSH
82138: LD_VAR 0 1
82142: ARRAY
82143: PPUSH
82144: LD_EXP 64
82148: PUSH
82149: LD_VAR 0 1
82153: ARRAY
82154: PUSH
82155: LD_INT 1
82157: PLUS
82158: PPUSH
82159: LD_VAR 0 5
82163: PUSH
82164: LD_INT 1
82166: ARRAY
82167: PUSH
82168: LD_VAR 0 7
82172: PUSH
82173: LD_INT 1
82175: ARRAY
82176: PUSH
82177: LD_VAR 0 7
82181: PUSH
82182: LD_INT 2
82184: ARRAY
82185: PUSH
82186: LD_VAR 0 7
82190: PUSH
82191: LD_INT 3
82193: ARRAY
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: LIST
82199: LIST
82200: PPUSH
82201: CALL_OW 2
82205: PPUSH
82206: CALL_OW 1
82210: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
82211: LD_ADDR_VAR 0 5
82215: PUSH
82216: LD_VAR 0 5
82220: PPUSH
82221: LD_INT 1
82223: PPUSH
82224: CALL_OW 3
82228: ST_TO_ADDR
// if not ext_list then
82229: LD_VAR 0 5
82233: NOT
82234: IFFALSE 82240
// exit ;
82236: POP
82237: POP
82238: GO 82244
// end ;
82240: GO 82115
82242: POP
82243: POP
// end ;
82244: LD_VAR 0 6
82248: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
82249: LD_INT 0
82251: PPUSH
// if not mc_bases or not base or not weapon_list then
82252: LD_EXP 59
82256: NOT
82257: PUSH
82258: LD_VAR 0 1
82262: NOT
82263: OR
82264: PUSH
82265: LD_VAR 0 2
82269: NOT
82270: OR
82271: IFFALSE 82275
// exit ;
82273: GO 82300
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
82275: LD_ADDR_EXP 98
82279: PUSH
82280: LD_EXP 98
82284: PPUSH
82285: LD_VAR 0 1
82289: PPUSH
82290: LD_VAR 0 2
82294: PPUSH
82295: CALL_OW 1
82299: ST_TO_ADDR
// end ;
82300: LD_VAR 0 3
82304: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
82305: LD_INT 0
82307: PPUSH
// if not mc_bases or not base or not tech_list then
82308: LD_EXP 59
82312: NOT
82313: PUSH
82314: LD_VAR 0 1
82318: NOT
82319: OR
82320: PUSH
82321: LD_VAR 0 2
82325: NOT
82326: OR
82327: IFFALSE 82331
// exit ;
82329: GO 82356
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
82331: LD_ADDR_EXP 86
82335: PUSH
82336: LD_EXP 86
82340: PPUSH
82341: LD_VAR 0 1
82345: PPUSH
82346: LD_VAR 0 2
82350: PPUSH
82351: CALL_OW 1
82355: ST_TO_ADDR
// end ;
82356: LD_VAR 0 3
82360: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
82361: LD_INT 0
82363: PPUSH
// if not mc_bases or not parking_area or not base then
82364: LD_EXP 59
82368: NOT
82369: PUSH
82370: LD_VAR 0 2
82374: NOT
82375: OR
82376: PUSH
82377: LD_VAR 0 1
82381: NOT
82382: OR
82383: IFFALSE 82387
// exit ;
82385: GO 82412
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
82387: LD_ADDR_EXP 83
82391: PUSH
82392: LD_EXP 83
82396: PPUSH
82397: LD_VAR 0 1
82401: PPUSH
82402: LD_VAR 0 2
82406: PPUSH
82407: CALL_OW 1
82411: ST_TO_ADDR
// end ;
82412: LD_VAR 0 3
82416: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
82417: LD_INT 0
82419: PPUSH
// if not mc_bases or not base or not scan_area then
82420: LD_EXP 59
82424: NOT
82425: PUSH
82426: LD_VAR 0 1
82430: NOT
82431: OR
82432: PUSH
82433: LD_VAR 0 2
82437: NOT
82438: OR
82439: IFFALSE 82443
// exit ;
82441: GO 82468
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
82443: LD_ADDR_EXP 84
82447: PUSH
82448: LD_EXP 84
82452: PPUSH
82453: LD_VAR 0 1
82457: PPUSH
82458: LD_VAR 0 2
82462: PPUSH
82463: CALL_OW 1
82467: ST_TO_ADDR
// end ;
82468: LD_VAR 0 3
82472: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
82473: LD_INT 0
82475: PPUSH
82476: PPUSH
// if not mc_bases or not base then
82477: LD_EXP 59
82481: NOT
82482: PUSH
82483: LD_VAR 0 1
82487: NOT
82488: OR
82489: IFFALSE 82493
// exit ;
82491: GO 82557
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
82493: LD_ADDR_VAR 0 3
82497: PUSH
82498: LD_INT 1
82500: PUSH
82501: LD_INT 2
82503: PUSH
82504: LD_INT 3
82506: PUSH
82507: LD_INT 4
82509: PUSH
82510: LD_INT 11
82512: PUSH
82513: EMPTY
82514: LIST
82515: LIST
82516: LIST
82517: LIST
82518: LIST
82519: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
82520: LD_ADDR_EXP 86
82524: PUSH
82525: LD_EXP 86
82529: PPUSH
82530: LD_VAR 0 1
82534: PPUSH
82535: LD_EXP 86
82539: PUSH
82540: LD_VAR 0 1
82544: ARRAY
82545: PUSH
82546: LD_VAR 0 3
82550: DIFF
82551: PPUSH
82552: CALL_OW 1
82556: ST_TO_ADDR
// end ;
82557: LD_VAR 0 2
82561: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82562: LD_INT 0
82564: PPUSH
// result := mc_vehicles [ base ] ;
82565: LD_ADDR_VAR 0 3
82569: PUSH
82570: LD_EXP 78
82574: PUSH
82575: LD_VAR 0 1
82579: ARRAY
82580: ST_TO_ADDR
// if onlyCombat then
82581: LD_VAR 0 2
82585: IFFALSE 82750
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82587: LD_ADDR_VAR 0 3
82591: PUSH
82592: LD_VAR 0 3
82596: PUSH
82597: LD_VAR 0 3
82601: PPUSH
82602: LD_INT 2
82604: PUSH
82605: LD_INT 34
82607: PUSH
82608: LD_INT 12
82610: PUSH
82611: EMPTY
82612: LIST
82613: LIST
82614: PUSH
82615: LD_INT 34
82617: PUSH
82618: LD_INT 51
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: PUSH
82625: LD_INT 34
82627: PUSH
82628: LD_EXP 103
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: LD_INT 34
82639: PUSH
82640: LD_INT 32
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: LD_INT 34
82649: PUSH
82650: LD_INT 13
82652: PUSH
82653: EMPTY
82654: LIST
82655: LIST
82656: PUSH
82657: LD_INT 34
82659: PUSH
82660: LD_INT 52
82662: PUSH
82663: EMPTY
82664: LIST
82665: LIST
82666: PUSH
82667: LD_INT 34
82669: PUSH
82670: LD_INT 14
82672: PUSH
82673: EMPTY
82674: LIST
82675: LIST
82676: PUSH
82677: LD_INT 34
82679: PUSH
82680: LD_INT 53
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: PUSH
82687: LD_INT 34
82689: PUSH
82690: LD_EXP 102
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: PUSH
82699: LD_INT 34
82701: PUSH
82702: LD_INT 31
82704: PUSH
82705: EMPTY
82706: LIST
82707: LIST
82708: PUSH
82709: LD_INT 34
82711: PUSH
82712: LD_INT 48
82714: PUSH
82715: EMPTY
82716: LIST
82717: LIST
82718: PUSH
82719: LD_INT 34
82721: PUSH
82722: LD_INT 8
82724: PUSH
82725: EMPTY
82726: LIST
82727: LIST
82728: PUSH
82729: EMPTY
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: PPUSH
82744: CALL_OW 72
82748: DIFF
82749: ST_TO_ADDR
// end ; end_of_file
82750: LD_VAR 0 3
82754: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82755: LD_INT 0
82757: PPUSH
82758: PPUSH
82759: PPUSH
// if not mc_bases or not skirmish then
82760: LD_EXP 59
82764: NOT
82765: PUSH
82766: LD_EXP 57
82770: NOT
82771: OR
82772: IFFALSE 82776
// exit ;
82774: GO 82941
// for i = 1 to mc_bases do
82776: LD_ADDR_VAR 0 4
82780: PUSH
82781: DOUBLE
82782: LD_INT 1
82784: DEC
82785: ST_TO_ADDR
82786: LD_EXP 59
82790: PUSH
82791: FOR_TO
82792: IFFALSE 82939
// begin if sci in mc_bases [ i ] then
82794: LD_VAR 0 2
82798: PUSH
82799: LD_EXP 59
82803: PUSH
82804: LD_VAR 0 4
82808: ARRAY
82809: IN
82810: IFFALSE 82937
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82812: LD_ADDR_EXP 88
82816: PUSH
82817: LD_EXP 88
82821: PPUSH
82822: LD_VAR 0 4
82826: PUSH
82827: LD_EXP 88
82831: PUSH
82832: LD_VAR 0 4
82836: ARRAY
82837: PUSH
82838: LD_INT 1
82840: PLUS
82841: PUSH
82842: EMPTY
82843: LIST
82844: LIST
82845: PPUSH
82846: LD_VAR 0 1
82850: PPUSH
82851: CALL 21521 0 3
82855: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82856: LD_ADDR_VAR 0 5
82860: PUSH
82861: LD_EXP 59
82865: PUSH
82866: LD_VAR 0 4
82870: ARRAY
82871: PPUSH
82872: LD_INT 2
82874: PUSH
82875: LD_INT 30
82877: PUSH
82878: LD_INT 0
82880: PUSH
82881: EMPTY
82882: LIST
82883: LIST
82884: PUSH
82885: LD_INT 30
82887: PUSH
82888: LD_INT 1
82890: PUSH
82891: EMPTY
82892: LIST
82893: LIST
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: LIST
82899: PPUSH
82900: CALL_OW 72
82904: PPUSH
82905: LD_VAR 0 1
82909: PPUSH
82910: CALL_OW 74
82914: ST_TO_ADDR
// if tmp then
82915: LD_VAR 0 5
82919: IFFALSE 82935
// ComStandNearbyBuilding ( ape , tmp ) ;
82921: LD_VAR 0 1
82925: PPUSH
82926: LD_VAR 0 5
82930: PPUSH
82931: CALL 15724 0 2
// break ;
82935: GO 82939
// end ; end ;
82937: GO 82791
82939: POP
82940: POP
// end ;
82941: LD_VAR 0 3
82945: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82946: LD_INT 0
82948: PPUSH
82949: PPUSH
82950: PPUSH
// if not mc_bases or not skirmish then
82951: LD_EXP 59
82955: NOT
82956: PUSH
82957: LD_EXP 57
82961: NOT
82962: OR
82963: IFFALSE 82967
// exit ;
82965: GO 83056
// for i = 1 to mc_bases do
82967: LD_ADDR_VAR 0 4
82971: PUSH
82972: DOUBLE
82973: LD_INT 1
82975: DEC
82976: ST_TO_ADDR
82977: LD_EXP 59
82981: PUSH
82982: FOR_TO
82983: IFFALSE 83054
// begin if building in mc_busy_turret_list [ i ] then
82985: LD_VAR 0 1
82989: PUSH
82990: LD_EXP 69
82994: PUSH
82995: LD_VAR 0 4
82999: ARRAY
83000: IN
83001: IFFALSE 83052
// begin tmp := mc_busy_turret_list [ i ] diff building ;
83003: LD_ADDR_VAR 0 5
83007: PUSH
83008: LD_EXP 69
83012: PUSH
83013: LD_VAR 0 4
83017: ARRAY
83018: PUSH
83019: LD_VAR 0 1
83023: DIFF
83024: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
83025: LD_ADDR_EXP 69
83029: PUSH
83030: LD_EXP 69
83034: PPUSH
83035: LD_VAR 0 4
83039: PPUSH
83040: LD_VAR 0 5
83044: PPUSH
83045: CALL_OW 1
83049: ST_TO_ADDR
// break ;
83050: GO 83054
// end ; end ;
83052: GO 82982
83054: POP
83055: POP
// end ;
83056: LD_VAR 0 3
83060: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
83061: LD_INT 0
83063: PPUSH
83064: PPUSH
83065: PPUSH
// if not mc_bases or not skirmish then
83066: LD_EXP 59
83070: NOT
83071: PUSH
83072: LD_EXP 57
83076: NOT
83077: OR
83078: IFFALSE 83082
// exit ;
83080: GO 83281
// for i = 1 to mc_bases do
83082: LD_ADDR_VAR 0 5
83086: PUSH
83087: DOUBLE
83088: LD_INT 1
83090: DEC
83091: ST_TO_ADDR
83092: LD_EXP 59
83096: PUSH
83097: FOR_TO
83098: IFFALSE 83279
// if building in mc_bases [ i ] then
83100: LD_VAR 0 1
83104: PUSH
83105: LD_EXP 59
83109: PUSH
83110: LD_VAR 0 5
83114: ARRAY
83115: IN
83116: IFFALSE 83277
// begin tmp := mc_bases [ i ] diff building ;
83118: LD_ADDR_VAR 0 6
83122: PUSH
83123: LD_EXP 59
83127: PUSH
83128: LD_VAR 0 5
83132: ARRAY
83133: PUSH
83134: LD_VAR 0 1
83138: DIFF
83139: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
83140: LD_ADDR_EXP 59
83144: PUSH
83145: LD_EXP 59
83149: PPUSH
83150: LD_VAR 0 5
83154: PPUSH
83155: LD_VAR 0 6
83159: PPUSH
83160: CALL_OW 1
83164: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
83165: LD_VAR 0 1
83169: PUSH
83170: LD_EXP 67
83174: PUSH
83175: LD_VAR 0 5
83179: ARRAY
83180: IN
83181: IFFALSE 83220
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
83183: LD_ADDR_EXP 67
83187: PUSH
83188: LD_EXP 67
83192: PPUSH
83193: LD_VAR 0 5
83197: PPUSH
83198: LD_EXP 67
83202: PUSH
83203: LD_VAR 0 5
83207: ARRAY
83208: PUSH
83209: LD_VAR 0 1
83213: DIFF
83214: PPUSH
83215: CALL_OW 1
83219: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
83220: LD_VAR 0 1
83224: PUSH
83225: LD_EXP 68
83229: PUSH
83230: LD_VAR 0 5
83234: ARRAY
83235: IN
83236: IFFALSE 83275
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
83238: LD_ADDR_EXP 68
83242: PUSH
83243: LD_EXP 68
83247: PPUSH
83248: LD_VAR 0 5
83252: PPUSH
83253: LD_EXP 68
83257: PUSH
83258: LD_VAR 0 5
83262: ARRAY
83263: PUSH
83264: LD_VAR 0 1
83268: DIFF
83269: PPUSH
83270: CALL_OW 1
83274: ST_TO_ADDR
// break ;
83275: GO 83279
// end ;
83277: GO 83097
83279: POP
83280: POP
// end ;
83281: LD_VAR 0 4
83285: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
83286: LD_INT 0
83288: PPUSH
83289: PPUSH
83290: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
83291: LD_EXP 59
83295: NOT
83296: PUSH
83297: LD_EXP 57
83301: NOT
83302: OR
83303: PUSH
83304: LD_VAR 0 3
83308: PUSH
83309: LD_EXP 85
83313: IN
83314: NOT
83315: OR
83316: IFFALSE 83320
// exit ;
83318: GO 83443
// for i = 1 to mc_vehicles do
83320: LD_ADDR_VAR 0 6
83324: PUSH
83325: DOUBLE
83326: LD_INT 1
83328: DEC
83329: ST_TO_ADDR
83330: LD_EXP 78
83334: PUSH
83335: FOR_TO
83336: IFFALSE 83441
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
83338: LD_VAR 0 2
83342: PUSH
83343: LD_EXP 78
83347: PUSH
83348: LD_VAR 0 6
83352: ARRAY
83353: IN
83354: PUSH
83355: LD_VAR 0 1
83359: PUSH
83360: LD_EXP 78
83364: PUSH
83365: LD_VAR 0 6
83369: ARRAY
83370: IN
83371: OR
83372: IFFALSE 83439
// begin tmp := mc_vehicles [ i ] diff old ;
83374: LD_ADDR_VAR 0 7
83378: PUSH
83379: LD_EXP 78
83383: PUSH
83384: LD_VAR 0 6
83388: ARRAY
83389: PUSH
83390: LD_VAR 0 2
83394: DIFF
83395: ST_TO_ADDR
// tmp := tmp diff new ;
83396: LD_ADDR_VAR 0 7
83400: PUSH
83401: LD_VAR 0 7
83405: PUSH
83406: LD_VAR 0 1
83410: DIFF
83411: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
83412: LD_ADDR_EXP 78
83416: PUSH
83417: LD_EXP 78
83421: PPUSH
83422: LD_VAR 0 6
83426: PPUSH
83427: LD_VAR 0 7
83431: PPUSH
83432: CALL_OW 1
83436: ST_TO_ADDR
// break ;
83437: GO 83441
// end ;
83439: GO 83335
83441: POP
83442: POP
// end ;
83443: LD_VAR 0 5
83447: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
83448: LD_INT 0
83450: PPUSH
83451: PPUSH
83452: PPUSH
83453: PPUSH
// if not mc_bases or not skirmish then
83454: LD_EXP 59
83458: NOT
83459: PUSH
83460: LD_EXP 57
83464: NOT
83465: OR
83466: IFFALSE 83470
// exit ;
83468: GO 83847
// side := GetSide ( vehicle ) ;
83470: LD_ADDR_VAR 0 5
83474: PUSH
83475: LD_VAR 0 1
83479: PPUSH
83480: CALL_OW 255
83484: ST_TO_ADDR
// for i = 1 to mc_bases do
83485: LD_ADDR_VAR 0 4
83489: PUSH
83490: DOUBLE
83491: LD_INT 1
83493: DEC
83494: ST_TO_ADDR
83495: LD_EXP 59
83499: PUSH
83500: FOR_TO
83501: IFFALSE 83845
// begin if factory in mc_bases [ i ] then
83503: LD_VAR 0 2
83507: PUSH
83508: LD_EXP 59
83512: PUSH
83513: LD_VAR 0 4
83517: ARRAY
83518: IN
83519: IFFALSE 83843
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
83521: LD_EXP 81
83525: PUSH
83526: LD_VAR 0 4
83530: ARRAY
83531: PUSH
83532: LD_EXP 70
83536: PUSH
83537: LD_VAR 0 4
83541: ARRAY
83542: LESS
83543: PUSH
83544: LD_VAR 0 1
83548: PPUSH
83549: CALL_OW 264
83553: PUSH
83554: LD_INT 31
83556: PUSH
83557: LD_INT 32
83559: PUSH
83560: LD_INT 51
83562: PUSH
83563: LD_EXP 103
83567: PUSH
83568: LD_INT 12
83570: PUSH
83571: LD_INT 30
83573: PUSH
83574: LD_EXP 102
83578: PUSH
83579: LD_INT 11
83581: PUSH
83582: LD_INT 53
83584: PUSH
83585: LD_INT 14
83587: PUSH
83588: LD_EXP 106
83592: PUSH
83593: LD_INT 29
83595: PUSH
83596: LD_EXP 104
83600: PUSH
83601: LD_INT 13
83603: PUSH
83604: LD_INT 52
83606: PUSH
83607: LD_INT 48
83609: PUSH
83610: LD_INT 8
83612: PUSH
83613: EMPTY
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: LIST
83623: LIST
83624: LIST
83625: LIST
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: IN
83632: NOT
83633: AND
83634: IFFALSE 83682
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83636: LD_ADDR_EXP 81
83640: PUSH
83641: LD_EXP 81
83645: PPUSH
83646: LD_VAR 0 4
83650: PUSH
83651: LD_EXP 81
83655: PUSH
83656: LD_VAR 0 4
83660: ARRAY
83661: PUSH
83662: LD_INT 1
83664: PLUS
83665: PUSH
83666: EMPTY
83667: LIST
83668: LIST
83669: PPUSH
83670: LD_VAR 0 1
83674: PPUSH
83675: CALL 21521 0 3
83679: ST_TO_ADDR
83680: GO 83726
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83682: LD_ADDR_EXP 78
83686: PUSH
83687: LD_EXP 78
83691: PPUSH
83692: LD_VAR 0 4
83696: PUSH
83697: LD_EXP 78
83701: PUSH
83702: LD_VAR 0 4
83706: ARRAY
83707: PUSH
83708: LD_INT 1
83710: PLUS
83711: PUSH
83712: EMPTY
83713: LIST
83714: LIST
83715: PPUSH
83716: LD_VAR 0 1
83720: PPUSH
83721: CALL 21521 0 3
83725: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83726: LD_VAR 0 1
83730: PPUSH
83731: CALL_OW 263
83735: PUSH
83736: LD_INT 2
83738: EQUAL
83739: IFFALSE 83759
// begin repeat wait ( 0 0$1 ) ;
83741: LD_INT 35
83743: PPUSH
83744: CALL_OW 67
// until IsControledBy ( vehicle ) ;
83748: LD_VAR 0 1
83752: PPUSH
83753: CALL_OW 312
83757: IFFALSE 83741
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83759: LD_VAR 0 1
83763: PPUSH
83764: LD_EXP 83
83768: PUSH
83769: LD_VAR 0 4
83773: ARRAY
83774: PPUSH
83775: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83779: LD_VAR 0 1
83783: PPUSH
83784: CALL_OW 263
83788: PUSH
83789: LD_INT 1
83791: NONEQUAL
83792: IFFALSE 83796
// break ;
83794: GO 83845
// repeat wait ( 0 0$1 ) ;
83796: LD_INT 35
83798: PPUSH
83799: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83803: LD_VAR 0 1
83807: PPUSH
83808: LD_EXP 83
83812: PUSH
83813: LD_VAR 0 4
83817: ARRAY
83818: PPUSH
83819: CALL_OW 308
83823: IFFALSE 83796
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83825: LD_VAR 0 1
83829: PPUSH
83830: CALL_OW 311
83834: PPUSH
83835: CALL_OW 121
// exit ;
83839: POP
83840: POP
83841: GO 83847
// end ; end ;
83843: GO 83500
83845: POP
83846: POP
// end ;
83847: LD_VAR 0 3
83851: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83852: LD_INT 0
83854: PPUSH
83855: PPUSH
83856: PPUSH
83857: PPUSH
// if not mc_bases or not skirmish then
83858: LD_EXP 59
83862: NOT
83863: PUSH
83864: LD_EXP 57
83868: NOT
83869: OR
83870: IFFALSE 83874
// exit ;
83872: GO 84227
// repeat wait ( 0 0$1 ) ;
83874: LD_INT 35
83876: PPUSH
83877: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83881: LD_VAR 0 2
83885: PPUSH
83886: LD_VAR 0 3
83890: PPUSH
83891: CALL_OW 284
83895: IFFALSE 83874
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83897: LD_VAR 0 2
83901: PPUSH
83902: LD_VAR 0 3
83906: PPUSH
83907: CALL_OW 283
83911: PUSH
83912: LD_INT 4
83914: EQUAL
83915: IFFALSE 83919
// exit ;
83917: GO 84227
// for i = 1 to mc_bases do
83919: LD_ADDR_VAR 0 7
83923: PUSH
83924: DOUBLE
83925: LD_INT 1
83927: DEC
83928: ST_TO_ADDR
83929: LD_EXP 59
83933: PUSH
83934: FOR_TO
83935: IFFALSE 84225
// begin if mc_crates_area [ i ] then
83937: LD_EXP 77
83941: PUSH
83942: LD_VAR 0 7
83946: ARRAY
83947: IFFALSE 84058
// for j in mc_crates_area [ i ] do
83949: LD_ADDR_VAR 0 8
83953: PUSH
83954: LD_EXP 77
83958: PUSH
83959: LD_VAR 0 7
83963: ARRAY
83964: PUSH
83965: FOR_IN
83966: IFFALSE 84056
// if InArea ( x , y , j ) then
83968: LD_VAR 0 2
83972: PPUSH
83973: LD_VAR 0 3
83977: PPUSH
83978: LD_VAR 0 8
83982: PPUSH
83983: CALL_OW 309
83987: IFFALSE 84054
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83989: LD_ADDR_EXP 75
83993: PUSH
83994: LD_EXP 75
83998: PPUSH
83999: LD_VAR 0 7
84003: PUSH
84004: LD_EXP 75
84008: PUSH
84009: LD_VAR 0 7
84013: ARRAY
84014: PUSH
84015: LD_INT 1
84017: PLUS
84018: PUSH
84019: EMPTY
84020: LIST
84021: LIST
84022: PPUSH
84023: LD_VAR 0 4
84027: PUSH
84028: LD_VAR 0 2
84032: PUSH
84033: LD_VAR 0 3
84037: PUSH
84038: EMPTY
84039: LIST
84040: LIST
84041: LIST
84042: PPUSH
84043: CALL 21521 0 3
84047: ST_TO_ADDR
// exit ;
84048: POP
84049: POP
84050: POP
84051: POP
84052: GO 84227
// end ;
84054: GO 83965
84056: POP
84057: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84058: LD_ADDR_VAR 0 9
84062: PUSH
84063: LD_EXP 59
84067: PUSH
84068: LD_VAR 0 7
84072: ARRAY
84073: PPUSH
84074: LD_INT 2
84076: PUSH
84077: LD_INT 30
84079: PUSH
84080: LD_INT 0
84082: PUSH
84083: EMPTY
84084: LIST
84085: LIST
84086: PUSH
84087: LD_INT 30
84089: PUSH
84090: LD_INT 1
84092: PUSH
84093: EMPTY
84094: LIST
84095: LIST
84096: PUSH
84097: EMPTY
84098: LIST
84099: LIST
84100: LIST
84101: PPUSH
84102: CALL_OW 72
84106: ST_TO_ADDR
// if not depot then
84107: LD_VAR 0 9
84111: NOT
84112: IFFALSE 84116
// continue ;
84114: GO 83934
// for j in depot do
84116: LD_ADDR_VAR 0 8
84120: PUSH
84121: LD_VAR 0 9
84125: PUSH
84126: FOR_IN
84127: IFFALSE 84221
// if GetDistUnitXY ( j , x , y ) < 30 then
84129: LD_VAR 0 8
84133: PPUSH
84134: LD_VAR 0 2
84138: PPUSH
84139: LD_VAR 0 3
84143: PPUSH
84144: CALL_OW 297
84148: PUSH
84149: LD_INT 30
84151: LESS
84152: IFFALSE 84219
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84154: LD_ADDR_EXP 75
84158: PUSH
84159: LD_EXP 75
84163: PPUSH
84164: LD_VAR 0 7
84168: PUSH
84169: LD_EXP 75
84173: PUSH
84174: LD_VAR 0 7
84178: ARRAY
84179: PUSH
84180: LD_INT 1
84182: PLUS
84183: PUSH
84184: EMPTY
84185: LIST
84186: LIST
84187: PPUSH
84188: LD_VAR 0 4
84192: PUSH
84193: LD_VAR 0 2
84197: PUSH
84198: LD_VAR 0 3
84202: PUSH
84203: EMPTY
84204: LIST
84205: LIST
84206: LIST
84207: PPUSH
84208: CALL 21521 0 3
84212: ST_TO_ADDR
// exit ;
84213: POP
84214: POP
84215: POP
84216: POP
84217: GO 84227
// end ;
84219: GO 84126
84221: POP
84222: POP
// end ;
84223: GO 83934
84225: POP
84226: POP
// end ;
84227: LD_VAR 0 6
84231: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
84232: LD_INT 0
84234: PPUSH
84235: PPUSH
84236: PPUSH
84237: PPUSH
// if not mc_bases or not skirmish then
84238: LD_EXP 59
84242: NOT
84243: PUSH
84244: LD_EXP 57
84248: NOT
84249: OR
84250: IFFALSE 84254
// exit ;
84252: GO 84531
// side := GetSide ( lab ) ;
84254: LD_ADDR_VAR 0 4
84258: PUSH
84259: LD_VAR 0 2
84263: PPUSH
84264: CALL_OW 255
84268: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
84269: LD_VAR 0 4
84273: PUSH
84274: LD_EXP 85
84278: IN
84279: NOT
84280: PUSH
84281: LD_EXP 86
84285: NOT
84286: OR
84287: PUSH
84288: LD_EXP 59
84292: NOT
84293: OR
84294: IFFALSE 84298
// exit ;
84296: GO 84531
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
84298: LD_ADDR_EXP 86
84302: PUSH
84303: LD_EXP 86
84307: PPUSH
84308: LD_VAR 0 4
84312: PPUSH
84313: LD_EXP 86
84317: PUSH
84318: LD_VAR 0 4
84322: ARRAY
84323: PUSH
84324: LD_VAR 0 1
84328: DIFF
84329: PPUSH
84330: CALL_OW 1
84334: ST_TO_ADDR
// for i = 1 to mc_bases do
84335: LD_ADDR_VAR 0 5
84339: PUSH
84340: DOUBLE
84341: LD_INT 1
84343: DEC
84344: ST_TO_ADDR
84345: LD_EXP 59
84349: PUSH
84350: FOR_TO
84351: IFFALSE 84529
// begin if lab in mc_bases [ i ] then
84353: LD_VAR 0 2
84357: PUSH
84358: LD_EXP 59
84362: PUSH
84363: LD_VAR 0 5
84367: ARRAY
84368: IN
84369: IFFALSE 84527
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
84371: LD_VAR 0 1
84375: PUSH
84376: LD_INT 11
84378: PUSH
84379: LD_INT 4
84381: PUSH
84382: LD_INT 3
84384: PUSH
84385: LD_INT 2
84387: PUSH
84388: EMPTY
84389: LIST
84390: LIST
84391: LIST
84392: LIST
84393: IN
84394: PUSH
84395: LD_EXP 89
84399: PUSH
84400: LD_VAR 0 5
84404: ARRAY
84405: AND
84406: IFFALSE 84527
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
84408: LD_ADDR_VAR 0 6
84412: PUSH
84413: LD_EXP 89
84417: PUSH
84418: LD_VAR 0 5
84422: ARRAY
84423: PUSH
84424: LD_INT 1
84426: ARRAY
84427: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84428: LD_ADDR_EXP 89
84432: PUSH
84433: LD_EXP 89
84437: PPUSH
84438: LD_VAR 0 5
84442: PPUSH
84443: EMPTY
84444: PPUSH
84445: CALL_OW 1
84449: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
84450: LD_VAR 0 6
84454: PPUSH
84455: LD_INT 0
84457: PPUSH
84458: CALL_OW 109
// ComExitBuilding ( tmp ) ;
84462: LD_VAR 0 6
84466: PPUSH
84467: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
84471: LD_ADDR_EXP 88
84475: PUSH
84476: LD_EXP 88
84480: PPUSH
84481: LD_VAR 0 5
84485: PPUSH
84486: LD_EXP 88
84490: PUSH
84491: LD_VAR 0 5
84495: ARRAY
84496: PPUSH
84497: LD_INT 1
84499: PPUSH
84500: LD_VAR 0 6
84504: PPUSH
84505: CALL_OW 2
84509: PPUSH
84510: CALL_OW 1
84514: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84515: LD_VAR 0 5
84519: PPUSH
84520: LD_INT 112
84522: PPUSH
84523: CALL 61527 0 2
// end ; end ; end ;
84527: GO 84350
84529: POP
84530: POP
// end ;
84531: LD_VAR 0 3
84535: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84536: LD_INT 0
84538: PPUSH
84539: PPUSH
84540: PPUSH
84541: PPUSH
84542: PPUSH
84543: PPUSH
84544: PPUSH
84545: PPUSH
// if not mc_bases or not skirmish then
84546: LD_EXP 59
84550: NOT
84551: PUSH
84552: LD_EXP 57
84556: NOT
84557: OR
84558: IFFALSE 84562
// exit ;
84560: GO 85933
// for i = 1 to mc_bases do
84562: LD_ADDR_VAR 0 3
84566: PUSH
84567: DOUBLE
84568: LD_INT 1
84570: DEC
84571: ST_TO_ADDR
84572: LD_EXP 59
84576: PUSH
84577: FOR_TO
84578: IFFALSE 85931
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84580: LD_VAR 0 1
84584: PUSH
84585: LD_EXP 59
84589: PUSH
84590: LD_VAR 0 3
84594: ARRAY
84595: IN
84596: PUSH
84597: LD_VAR 0 1
84601: PUSH
84602: LD_EXP 66
84606: PUSH
84607: LD_VAR 0 3
84611: ARRAY
84612: IN
84613: OR
84614: PUSH
84615: LD_VAR 0 1
84619: PUSH
84620: LD_EXP 81
84624: PUSH
84625: LD_VAR 0 3
84629: ARRAY
84630: IN
84631: OR
84632: PUSH
84633: LD_VAR 0 1
84637: PUSH
84638: LD_EXP 78
84642: PUSH
84643: LD_VAR 0 3
84647: ARRAY
84648: IN
84649: OR
84650: PUSH
84651: LD_VAR 0 1
84655: PUSH
84656: LD_EXP 88
84660: PUSH
84661: LD_VAR 0 3
84665: ARRAY
84666: IN
84667: OR
84668: PUSH
84669: LD_VAR 0 1
84673: PUSH
84674: LD_EXP 89
84678: PUSH
84679: LD_VAR 0 3
84683: ARRAY
84684: IN
84685: OR
84686: IFFALSE 85929
// begin if un in mc_ape [ i ] then
84688: LD_VAR 0 1
84692: PUSH
84693: LD_EXP 88
84697: PUSH
84698: LD_VAR 0 3
84702: ARRAY
84703: IN
84704: IFFALSE 84743
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84706: LD_ADDR_EXP 88
84710: PUSH
84711: LD_EXP 88
84715: PPUSH
84716: LD_VAR 0 3
84720: PPUSH
84721: LD_EXP 88
84725: PUSH
84726: LD_VAR 0 3
84730: ARRAY
84731: PUSH
84732: LD_VAR 0 1
84736: DIFF
84737: PPUSH
84738: CALL_OW 1
84742: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84743: LD_VAR 0 1
84747: PUSH
84748: LD_EXP 89
84752: PUSH
84753: LD_VAR 0 3
84757: ARRAY
84758: IN
84759: IFFALSE 84783
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84761: LD_ADDR_EXP 89
84765: PUSH
84766: LD_EXP 89
84770: PPUSH
84771: LD_VAR 0 3
84775: PPUSH
84776: EMPTY
84777: PPUSH
84778: CALL_OW 1
84782: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
84783: LD_VAR 0 1
84787: PPUSH
84788: CALL_OW 247
84792: PUSH
84793: LD_INT 2
84795: EQUAL
84796: PUSH
84797: LD_VAR 0 1
84801: PPUSH
84802: CALL_OW 110
84806: PUSH
84807: LD_INT 20
84809: EQUAL
84810: PUSH
84811: LD_VAR 0 1
84815: PUSH
84816: LD_EXP 81
84820: PUSH
84821: LD_VAR 0 3
84825: ARRAY
84826: IN
84827: OR
84828: PUSH
84829: LD_VAR 0 1
84833: PPUSH
84834: CALL_OW 264
84838: PUSH
84839: LD_INT 12
84841: PUSH
84842: LD_INT 51
84844: PUSH
84845: LD_EXP 103
84849: PUSH
84850: LD_INT 32
84852: PUSH
84853: LD_INT 13
84855: PUSH
84856: LD_INT 52
84858: PUSH
84859: LD_INT 31
84861: PUSH
84862: EMPTY
84863: LIST
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: LIST
84869: LIST
84870: IN
84871: OR
84872: AND
84873: IFFALSE 85181
// begin if un in mc_defender [ i ] then
84875: LD_VAR 0 1
84879: PUSH
84880: LD_EXP 81
84884: PUSH
84885: LD_VAR 0 3
84889: ARRAY
84890: IN
84891: IFFALSE 84930
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84893: LD_ADDR_EXP 81
84897: PUSH
84898: LD_EXP 81
84902: PPUSH
84903: LD_VAR 0 3
84907: PPUSH
84908: LD_EXP 81
84912: PUSH
84913: LD_VAR 0 3
84917: ARRAY
84918: PUSH
84919: LD_VAR 0 1
84923: DIFF
84924: PPUSH
84925: CALL_OW 1
84929: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84930: LD_ADDR_VAR 0 8
84934: PUSH
84935: LD_VAR 0 3
84939: PPUSH
84940: LD_INT 3
84942: PPUSH
84943: CALL 81599 0 2
84947: ST_TO_ADDR
// if fac then
84948: LD_VAR 0 8
84952: IFFALSE 85181
// begin for j in fac do
84954: LD_ADDR_VAR 0 4
84958: PUSH
84959: LD_VAR 0 8
84963: PUSH
84964: FOR_IN
84965: IFFALSE 85179
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84967: LD_ADDR_VAR 0 9
84971: PUSH
84972: LD_VAR 0 8
84976: PPUSH
84977: LD_VAR 0 1
84981: PPUSH
84982: CALL_OW 265
84986: PPUSH
84987: LD_VAR 0 1
84991: PPUSH
84992: CALL_OW 262
84996: PPUSH
84997: LD_VAR 0 1
85001: PPUSH
85002: CALL_OW 263
85006: PPUSH
85007: LD_VAR 0 1
85011: PPUSH
85012: CALL_OW 264
85016: PPUSH
85017: CALL 19053 0 5
85021: ST_TO_ADDR
// if components then
85022: LD_VAR 0 9
85026: IFFALSE 85177
// begin if GetWeapon ( un ) = ar_control_tower then
85028: LD_VAR 0 1
85032: PPUSH
85033: CALL_OW 264
85037: PUSH
85038: LD_INT 31
85040: EQUAL
85041: IFFALSE 85158
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
85043: LD_VAR 0 1
85047: PPUSH
85048: CALL_OW 311
85052: PPUSH
85053: LD_INT 0
85055: PPUSH
85056: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
85060: LD_ADDR_EXP 99
85064: PUSH
85065: LD_EXP 99
85069: PPUSH
85070: LD_VAR 0 3
85074: PPUSH
85075: LD_EXP 99
85079: PUSH
85080: LD_VAR 0 3
85084: ARRAY
85085: PUSH
85086: LD_VAR 0 1
85090: PPUSH
85091: CALL_OW 311
85095: DIFF
85096: PPUSH
85097: CALL_OW 1
85101: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
85102: LD_ADDR_VAR 0 7
85106: PUSH
85107: LD_EXP 80
85111: PUSH
85112: LD_VAR 0 3
85116: ARRAY
85117: PPUSH
85118: LD_INT 1
85120: PPUSH
85121: LD_VAR 0 9
85125: PPUSH
85126: CALL_OW 2
85130: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
85131: LD_ADDR_EXP 80
85135: PUSH
85136: LD_EXP 80
85140: PPUSH
85141: LD_VAR 0 3
85145: PPUSH
85146: LD_VAR 0 7
85150: PPUSH
85151: CALL_OW 1
85155: ST_TO_ADDR
// end else
85156: GO 85175
// MC_InsertProduceList ( i , [ components ] ) ;
85158: LD_VAR 0 3
85162: PPUSH
85163: LD_VAR 0 9
85167: PUSH
85168: EMPTY
85169: LIST
85170: PPUSH
85171: CALL 81144 0 2
// break ;
85175: GO 85179
// end ; end ;
85177: GO 84964
85179: POP
85180: POP
// end ; end ; if GetType ( un ) = unit_building then
85181: LD_VAR 0 1
85185: PPUSH
85186: CALL_OW 247
85190: PUSH
85191: LD_INT 3
85193: EQUAL
85194: IFFALSE 85597
// begin btype := GetBType ( un ) ;
85196: LD_ADDR_VAR 0 5
85200: PUSH
85201: LD_VAR 0 1
85205: PPUSH
85206: CALL_OW 266
85210: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
85211: LD_VAR 0 5
85215: PUSH
85216: LD_INT 29
85218: PUSH
85219: LD_INT 30
85221: PUSH
85222: EMPTY
85223: LIST
85224: LIST
85225: IN
85226: IFFALSE 85299
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
85228: LD_VAR 0 1
85232: PPUSH
85233: CALL_OW 250
85237: PPUSH
85238: LD_VAR 0 1
85242: PPUSH
85243: CALL_OW 251
85247: PPUSH
85248: LD_VAR 0 1
85252: PPUSH
85253: CALL_OW 255
85257: PPUSH
85258: CALL_OW 440
85262: NOT
85263: IFFALSE 85299
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
85265: LD_VAR 0 1
85269: PPUSH
85270: CALL_OW 250
85274: PPUSH
85275: LD_VAR 0 1
85279: PPUSH
85280: CALL_OW 251
85284: PPUSH
85285: LD_VAR 0 1
85289: PPUSH
85290: CALL_OW 255
85294: PPUSH
85295: CALL_OW 441
// end ; if btype = b_warehouse then
85299: LD_VAR 0 5
85303: PUSH
85304: LD_INT 1
85306: EQUAL
85307: IFFALSE 85325
// begin btype := b_depot ;
85309: LD_ADDR_VAR 0 5
85313: PUSH
85314: LD_INT 0
85316: ST_TO_ADDR
// pos := 1 ;
85317: LD_ADDR_VAR 0 6
85321: PUSH
85322: LD_INT 1
85324: ST_TO_ADDR
// end ; if btype = b_factory then
85325: LD_VAR 0 5
85329: PUSH
85330: LD_INT 3
85332: EQUAL
85333: IFFALSE 85351
// begin btype := b_workshop ;
85335: LD_ADDR_VAR 0 5
85339: PUSH
85340: LD_INT 2
85342: ST_TO_ADDR
// pos := 1 ;
85343: LD_ADDR_VAR 0 6
85347: PUSH
85348: LD_INT 1
85350: ST_TO_ADDR
// end ; if btype = b_barracks then
85351: LD_VAR 0 5
85355: PUSH
85356: LD_INT 5
85358: EQUAL
85359: IFFALSE 85369
// btype := b_armoury ;
85361: LD_ADDR_VAR 0 5
85365: PUSH
85366: LD_INT 4
85368: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
85369: LD_VAR 0 5
85373: PUSH
85374: LD_INT 7
85376: PUSH
85377: LD_INT 8
85379: PUSH
85380: EMPTY
85381: LIST
85382: LIST
85383: IN
85384: IFFALSE 85394
// btype := b_lab ;
85386: LD_ADDR_VAR 0 5
85390: PUSH
85391: LD_INT 6
85393: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
85394: LD_ADDR_EXP 64
85398: PUSH
85399: LD_EXP 64
85403: PPUSH
85404: LD_VAR 0 3
85408: PUSH
85409: LD_EXP 64
85413: PUSH
85414: LD_VAR 0 3
85418: ARRAY
85419: PUSH
85420: LD_INT 1
85422: PLUS
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: PPUSH
85428: LD_VAR 0 5
85432: PUSH
85433: LD_VAR 0 1
85437: PPUSH
85438: CALL_OW 250
85442: PUSH
85443: LD_VAR 0 1
85447: PPUSH
85448: CALL_OW 251
85452: PUSH
85453: LD_VAR 0 1
85457: PPUSH
85458: CALL_OW 254
85462: PUSH
85463: EMPTY
85464: LIST
85465: LIST
85466: LIST
85467: LIST
85468: PPUSH
85469: CALL 21521 0 3
85473: ST_TO_ADDR
// if pos = 1 then
85474: LD_VAR 0 6
85478: PUSH
85479: LD_INT 1
85481: EQUAL
85482: IFFALSE 85597
// begin tmp := mc_build_list [ i ] ;
85484: LD_ADDR_VAR 0 7
85488: PUSH
85489: LD_EXP 64
85493: PUSH
85494: LD_VAR 0 3
85498: ARRAY
85499: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
85500: LD_VAR 0 7
85504: PPUSH
85505: LD_INT 2
85507: PUSH
85508: LD_INT 30
85510: PUSH
85511: LD_INT 0
85513: PUSH
85514: EMPTY
85515: LIST
85516: LIST
85517: PUSH
85518: LD_INT 30
85520: PUSH
85521: LD_INT 1
85523: PUSH
85524: EMPTY
85525: LIST
85526: LIST
85527: PUSH
85528: EMPTY
85529: LIST
85530: LIST
85531: LIST
85532: PPUSH
85533: CALL_OW 72
85537: IFFALSE 85547
// pos := 2 ;
85539: LD_ADDR_VAR 0 6
85543: PUSH
85544: LD_INT 2
85546: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85547: LD_ADDR_VAR 0 7
85551: PUSH
85552: LD_VAR 0 7
85556: PPUSH
85557: LD_VAR 0 6
85561: PPUSH
85562: LD_VAR 0 7
85566: PPUSH
85567: CALL 21847 0 3
85571: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85572: LD_ADDR_EXP 64
85576: PUSH
85577: LD_EXP 64
85581: PPUSH
85582: LD_VAR 0 3
85586: PPUSH
85587: LD_VAR 0 7
85591: PPUSH
85592: CALL_OW 1
85596: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85597: LD_VAR 0 1
85601: PUSH
85602: LD_EXP 59
85606: PUSH
85607: LD_VAR 0 3
85611: ARRAY
85612: IN
85613: IFFALSE 85652
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85615: LD_ADDR_EXP 59
85619: PUSH
85620: LD_EXP 59
85624: PPUSH
85625: LD_VAR 0 3
85629: PPUSH
85630: LD_EXP 59
85634: PUSH
85635: LD_VAR 0 3
85639: ARRAY
85640: PUSH
85641: LD_VAR 0 1
85645: DIFF
85646: PPUSH
85647: CALL_OW 1
85651: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85652: LD_VAR 0 1
85656: PUSH
85657: LD_EXP 66
85661: PUSH
85662: LD_VAR 0 3
85666: ARRAY
85667: IN
85668: IFFALSE 85707
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85670: LD_ADDR_EXP 66
85674: PUSH
85675: LD_EXP 66
85679: PPUSH
85680: LD_VAR 0 3
85684: PPUSH
85685: LD_EXP 66
85689: PUSH
85690: LD_VAR 0 3
85694: ARRAY
85695: PUSH
85696: LD_VAR 0 1
85700: DIFF
85701: PPUSH
85702: CALL_OW 1
85706: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85707: LD_VAR 0 1
85711: PUSH
85712: LD_EXP 78
85716: PUSH
85717: LD_VAR 0 3
85721: ARRAY
85722: IN
85723: IFFALSE 85762
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85725: LD_ADDR_EXP 78
85729: PUSH
85730: LD_EXP 78
85734: PPUSH
85735: LD_VAR 0 3
85739: PPUSH
85740: LD_EXP 78
85744: PUSH
85745: LD_VAR 0 3
85749: ARRAY
85750: PUSH
85751: LD_VAR 0 1
85755: DIFF
85756: PPUSH
85757: CALL_OW 1
85761: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85762: LD_VAR 0 1
85766: PUSH
85767: LD_EXP 81
85771: PUSH
85772: LD_VAR 0 3
85776: ARRAY
85777: IN
85778: IFFALSE 85817
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85780: LD_ADDR_EXP 81
85784: PUSH
85785: LD_EXP 81
85789: PPUSH
85790: LD_VAR 0 3
85794: PPUSH
85795: LD_EXP 81
85799: PUSH
85800: LD_VAR 0 3
85804: ARRAY
85805: PUSH
85806: LD_VAR 0 1
85810: DIFF
85811: PPUSH
85812: CALL_OW 1
85816: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85817: LD_VAR 0 1
85821: PUSH
85822: LD_EXP 68
85826: PUSH
85827: LD_VAR 0 3
85831: ARRAY
85832: IN
85833: IFFALSE 85872
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85835: LD_ADDR_EXP 68
85839: PUSH
85840: LD_EXP 68
85844: PPUSH
85845: LD_VAR 0 3
85849: PPUSH
85850: LD_EXP 68
85854: PUSH
85855: LD_VAR 0 3
85859: ARRAY
85860: PUSH
85861: LD_VAR 0 1
85865: DIFF
85866: PPUSH
85867: CALL_OW 1
85871: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85872: LD_VAR 0 1
85876: PUSH
85877: LD_EXP 67
85881: PUSH
85882: LD_VAR 0 3
85886: ARRAY
85887: IN
85888: IFFALSE 85927
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85890: LD_ADDR_EXP 67
85894: PUSH
85895: LD_EXP 67
85899: PPUSH
85900: LD_VAR 0 3
85904: PPUSH
85905: LD_EXP 67
85909: PUSH
85910: LD_VAR 0 3
85914: ARRAY
85915: PUSH
85916: LD_VAR 0 1
85920: DIFF
85921: PPUSH
85922: CALL_OW 1
85926: ST_TO_ADDR
// end ; break ;
85927: GO 85931
// end ;
85929: GO 84577
85931: POP
85932: POP
// end ;
85933: LD_VAR 0 2
85937: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85938: LD_INT 0
85940: PPUSH
85941: PPUSH
85942: PPUSH
// if not mc_bases or not skirmish then
85943: LD_EXP 59
85947: NOT
85948: PUSH
85949: LD_EXP 57
85953: NOT
85954: OR
85955: IFFALSE 85959
// exit ;
85957: GO 86174
// for i = 1 to mc_bases do
85959: LD_ADDR_VAR 0 3
85963: PUSH
85964: DOUBLE
85965: LD_INT 1
85967: DEC
85968: ST_TO_ADDR
85969: LD_EXP 59
85973: PUSH
85974: FOR_TO
85975: IFFALSE 86172
// begin if building in mc_construct_list [ i ] then
85977: LD_VAR 0 1
85981: PUSH
85982: LD_EXP 66
85986: PUSH
85987: LD_VAR 0 3
85991: ARRAY
85992: IN
85993: IFFALSE 86170
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85995: LD_ADDR_EXP 66
85999: PUSH
86000: LD_EXP 66
86004: PPUSH
86005: LD_VAR 0 3
86009: PPUSH
86010: LD_EXP 66
86014: PUSH
86015: LD_VAR 0 3
86019: ARRAY
86020: PUSH
86021: LD_VAR 0 1
86025: DIFF
86026: PPUSH
86027: CALL_OW 1
86031: ST_TO_ADDR
// if building in mc_lab [ i ] then
86032: LD_VAR 0 1
86036: PUSH
86037: LD_EXP 92
86041: PUSH
86042: LD_VAR 0 3
86046: ARRAY
86047: IN
86048: IFFALSE 86103
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
86050: LD_ADDR_EXP 93
86054: PUSH
86055: LD_EXP 93
86059: PPUSH
86060: LD_VAR 0 3
86064: PPUSH
86065: LD_EXP 93
86069: PUSH
86070: LD_VAR 0 3
86074: ARRAY
86075: PPUSH
86076: LD_INT 1
86078: PPUSH
86079: LD_EXP 93
86083: PUSH
86084: LD_VAR 0 3
86088: ARRAY
86089: PPUSH
86090: LD_INT 0
86092: PPUSH
86093: CALL 20939 0 4
86097: PPUSH
86098: CALL_OW 1
86102: ST_TO_ADDR
// if not building in mc_bases [ i ] then
86103: LD_VAR 0 1
86107: PUSH
86108: LD_EXP 59
86112: PUSH
86113: LD_VAR 0 3
86117: ARRAY
86118: IN
86119: NOT
86120: IFFALSE 86166
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86122: LD_ADDR_EXP 59
86126: PUSH
86127: LD_EXP 59
86131: PPUSH
86132: LD_VAR 0 3
86136: PUSH
86137: LD_EXP 59
86141: PUSH
86142: LD_VAR 0 3
86146: ARRAY
86147: PUSH
86148: LD_INT 1
86150: PLUS
86151: PUSH
86152: EMPTY
86153: LIST
86154: LIST
86155: PPUSH
86156: LD_VAR 0 1
86160: PPUSH
86161: CALL 21521 0 3
86165: ST_TO_ADDR
// exit ;
86166: POP
86167: POP
86168: GO 86174
// end ; end ;
86170: GO 85974
86172: POP
86173: POP
// end ;
86174: LD_VAR 0 2
86178: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
86179: LD_INT 0
86181: PPUSH
86182: PPUSH
86183: PPUSH
86184: PPUSH
86185: PPUSH
86186: PPUSH
86187: PPUSH
// if not mc_bases or not skirmish then
86188: LD_EXP 59
86192: NOT
86193: PUSH
86194: LD_EXP 57
86198: NOT
86199: OR
86200: IFFALSE 86204
// exit ;
86202: GO 86865
// for i = 1 to mc_bases do
86204: LD_ADDR_VAR 0 3
86208: PUSH
86209: DOUBLE
86210: LD_INT 1
86212: DEC
86213: ST_TO_ADDR
86214: LD_EXP 59
86218: PUSH
86219: FOR_TO
86220: IFFALSE 86863
// begin if building in mc_construct_list [ i ] then
86222: LD_VAR 0 1
86226: PUSH
86227: LD_EXP 66
86231: PUSH
86232: LD_VAR 0 3
86236: ARRAY
86237: IN
86238: IFFALSE 86861
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86240: LD_ADDR_EXP 66
86244: PUSH
86245: LD_EXP 66
86249: PPUSH
86250: LD_VAR 0 3
86254: PPUSH
86255: LD_EXP 66
86259: PUSH
86260: LD_VAR 0 3
86264: ARRAY
86265: PUSH
86266: LD_VAR 0 1
86270: DIFF
86271: PPUSH
86272: CALL_OW 1
86276: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86277: LD_ADDR_EXP 59
86281: PUSH
86282: LD_EXP 59
86286: PPUSH
86287: LD_VAR 0 3
86291: PUSH
86292: LD_EXP 59
86296: PUSH
86297: LD_VAR 0 3
86301: ARRAY
86302: PUSH
86303: LD_INT 1
86305: PLUS
86306: PUSH
86307: EMPTY
86308: LIST
86309: LIST
86310: PPUSH
86311: LD_VAR 0 1
86315: PPUSH
86316: CALL 21521 0 3
86320: ST_TO_ADDR
// btype := GetBType ( building ) ;
86321: LD_ADDR_VAR 0 5
86325: PUSH
86326: LD_VAR 0 1
86330: PPUSH
86331: CALL_OW 266
86335: ST_TO_ADDR
// side := GetSide ( building ) ;
86336: LD_ADDR_VAR 0 8
86340: PUSH
86341: LD_VAR 0 1
86345: PPUSH
86346: CALL_OW 255
86350: ST_TO_ADDR
// if btype = b_lab then
86351: LD_VAR 0 5
86355: PUSH
86356: LD_INT 6
86358: EQUAL
86359: IFFALSE 86409
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
86361: LD_ADDR_EXP 92
86365: PUSH
86366: LD_EXP 92
86370: PPUSH
86371: LD_VAR 0 3
86375: PUSH
86376: LD_EXP 92
86380: PUSH
86381: LD_VAR 0 3
86385: ARRAY
86386: PUSH
86387: LD_INT 1
86389: PLUS
86390: PUSH
86391: EMPTY
86392: LIST
86393: LIST
86394: PPUSH
86395: LD_VAR 0 1
86399: PPUSH
86400: CALL 21521 0 3
86404: ST_TO_ADDR
// exit ;
86405: POP
86406: POP
86407: GO 86865
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
86409: LD_VAR 0 5
86413: PUSH
86414: LD_INT 0
86416: PUSH
86417: LD_INT 2
86419: PUSH
86420: LD_INT 4
86422: PUSH
86423: EMPTY
86424: LIST
86425: LIST
86426: LIST
86427: IN
86428: IFFALSE 86552
// begin if btype = b_armoury then
86430: LD_VAR 0 5
86434: PUSH
86435: LD_INT 4
86437: EQUAL
86438: IFFALSE 86448
// btype := b_barracks ;
86440: LD_ADDR_VAR 0 5
86444: PUSH
86445: LD_INT 5
86447: ST_TO_ADDR
// if btype = b_depot then
86448: LD_VAR 0 5
86452: PUSH
86453: LD_INT 0
86455: EQUAL
86456: IFFALSE 86466
// btype := b_warehouse ;
86458: LD_ADDR_VAR 0 5
86462: PUSH
86463: LD_INT 1
86465: ST_TO_ADDR
// if btype = b_workshop then
86466: LD_VAR 0 5
86470: PUSH
86471: LD_INT 2
86473: EQUAL
86474: IFFALSE 86484
// btype := b_factory ;
86476: LD_ADDR_VAR 0 5
86480: PUSH
86481: LD_INT 3
86483: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
86484: LD_VAR 0 5
86488: PPUSH
86489: LD_VAR 0 8
86493: PPUSH
86494: CALL_OW 323
86498: PUSH
86499: LD_INT 1
86501: EQUAL
86502: IFFALSE 86548
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
86504: LD_ADDR_EXP 91
86508: PUSH
86509: LD_EXP 91
86513: PPUSH
86514: LD_VAR 0 3
86518: PUSH
86519: LD_EXP 91
86523: PUSH
86524: LD_VAR 0 3
86528: ARRAY
86529: PUSH
86530: LD_INT 1
86532: PLUS
86533: PUSH
86534: EMPTY
86535: LIST
86536: LIST
86537: PPUSH
86538: LD_VAR 0 1
86542: PPUSH
86543: CALL 21521 0 3
86547: ST_TO_ADDR
// exit ;
86548: POP
86549: POP
86550: GO 86865
// end ; if btype in [ b_bunker , b_turret ] then
86552: LD_VAR 0 5
86556: PUSH
86557: LD_INT 32
86559: PUSH
86560: LD_INT 33
86562: PUSH
86563: EMPTY
86564: LIST
86565: LIST
86566: IN
86567: IFFALSE 86857
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86569: LD_ADDR_EXP 67
86573: PUSH
86574: LD_EXP 67
86578: PPUSH
86579: LD_VAR 0 3
86583: PUSH
86584: LD_EXP 67
86588: PUSH
86589: LD_VAR 0 3
86593: ARRAY
86594: PUSH
86595: LD_INT 1
86597: PLUS
86598: PUSH
86599: EMPTY
86600: LIST
86601: LIST
86602: PPUSH
86603: LD_VAR 0 1
86607: PPUSH
86608: CALL 21521 0 3
86612: ST_TO_ADDR
// if btype = b_bunker then
86613: LD_VAR 0 5
86617: PUSH
86618: LD_INT 32
86620: EQUAL
86621: IFFALSE 86857
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86623: LD_ADDR_EXP 68
86627: PUSH
86628: LD_EXP 68
86632: PPUSH
86633: LD_VAR 0 3
86637: PUSH
86638: LD_EXP 68
86642: PUSH
86643: LD_VAR 0 3
86647: ARRAY
86648: PUSH
86649: LD_INT 1
86651: PLUS
86652: PUSH
86653: EMPTY
86654: LIST
86655: LIST
86656: PPUSH
86657: LD_VAR 0 1
86661: PPUSH
86662: CALL 21521 0 3
86666: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86667: LD_ADDR_VAR 0 6
86671: PUSH
86672: LD_EXP 59
86676: PUSH
86677: LD_VAR 0 3
86681: ARRAY
86682: PPUSH
86683: LD_INT 25
86685: PUSH
86686: LD_INT 1
86688: PUSH
86689: EMPTY
86690: LIST
86691: LIST
86692: PUSH
86693: LD_INT 3
86695: PUSH
86696: LD_INT 54
86698: PUSH
86699: EMPTY
86700: LIST
86701: PUSH
86702: EMPTY
86703: LIST
86704: LIST
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PPUSH
86710: CALL_OW 72
86714: ST_TO_ADDR
// if tmp then
86715: LD_VAR 0 6
86719: IFFALSE 86725
// exit ;
86721: POP
86722: POP
86723: GO 86865
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86725: LD_ADDR_VAR 0 6
86729: PUSH
86730: LD_EXP 59
86734: PUSH
86735: LD_VAR 0 3
86739: ARRAY
86740: PPUSH
86741: LD_INT 2
86743: PUSH
86744: LD_INT 30
86746: PUSH
86747: LD_INT 4
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: PUSH
86754: LD_INT 30
86756: PUSH
86757: LD_INT 5
86759: PUSH
86760: EMPTY
86761: LIST
86762: LIST
86763: PUSH
86764: EMPTY
86765: LIST
86766: LIST
86767: LIST
86768: PPUSH
86769: CALL_OW 72
86773: ST_TO_ADDR
// if not tmp then
86774: LD_VAR 0 6
86778: NOT
86779: IFFALSE 86785
// exit ;
86781: POP
86782: POP
86783: GO 86865
// for j in tmp do
86785: LD_ADDR_VAR 0 4
86789: PUSH
86790: LD_VAR 0 6
86794: PUSH
86795: FOR_IN
86796: IFFALSE 86855
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86798: LD_ADDR_VAR 0 7
86802: PUSH
86803: LD_VAR 0 4
86807: PPUSH
86808: CALL_OW 313
86812: PPUSH
86813: LD_INT 25
86815: PUSH
86816: LD_INT 1
86818: PUSH
86819: EMPTY
86820: LIST
86821: LIST
86822: PPUSH
86823: CALL_OW 72
86827: ST_TO_ADDR
// if units then
86828: LD_VAR 0 7
86832: IFFALSE 86853
// begin ComExitBuilding ( units [ 1 ] ) ;
86834: LD_VAR 0 7
86838: PUSH
86839: LD_INT 1
86841: ARRAY
86842: PPUSH
86843: CALL_OW 122
// exit ;
86847: POP
86848: POP
86849: POP
86850: POP
86851: GO 86865
// end ; end ;
86853: GO 86795
86855: POP
86856: POP
// end ; end ; exit ;
86857: POP
86858: POP
86859: GO 86865
// end ; end ;
86861: GO 86219
86863: POP
86864: POP
// end ;
86865: LD_VAR 0 2
86869: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86870: LD_INT 0
86872: PPUSH
86873: PPUSH
86874: PPUSH
86875: PPUSH
86876: PPUSH
86877: PPUSH
86878: PPUSH
// if not mc_bases or not skirmish then
86879: LD_EXP 59
86883: NOT
86884: PUSH
86885: LD_EXP 57
86889: NOT
86890: OR
86891: IFFALSE 86895
// exit ;
86893: GO 87126
// btype := GetBType ( building ) ;
86895: LD_ADDR_VAR 0 6
86899: PUSH
86900: LD_VAR 0 1
86904: PPUSH
86905: CALL_OW 266
86909: ST_TO_ADDR
// x := GetX ( building ) ;
86910: LD_ADDR_VAR 0 7
86914: PUSH
86915: LD_VAR 0 1
86919: PPUSH
86920: CALL_OW 250
86924: ST_TO_ADDR
// y := GetY ( building ) ;
86925: LD_ADDR_VAR 0 8
86929: PUSH
86930: LD_VAR 0 1
86934: PPUSH
86935: CALL_OW 251
86939: ST_TO_ADDR
// d := GetDir ( building ) ;
86940: LD_ADDR_VAR 0 9
86944: PUSH
86945: LD_VAR 0 1
86949: PPUSH
86950: CALL_OW 254
86954: ST_TO_ADDR
// for i = 1 to mc_bases do
86955: LD_ADDR_VAR 0 4
86959: PUSH
86960: DOUBLE
86961: LD_INT 1
86963: DEC
86964: ST_TO_ADDR
86965: LD_EXP 59
86969: PUSH
86970: FOR_TO
86971: IFFALSE 87124
// begin if not mc_build_list [ i ] then
86973: LD_EXP 64
86977: PUSH
86978: LD_VAR 0 4
86982: ARRAY
86983: NOT
86984: IFFALSE 86988
// continue ;
86986: GO 86970
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
86988: LD_VAR 0 6
86992: PUSH
86993: LD_VAR 0 7
86997: PUSH
86998: LD_VAR 0 8
87002: PUSH
87003: LD_VAR 0 9
87007: PUSH
87008: EMPTY
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: PPUSH
87014: LD_EXP 64
87018: PUSH
87019: LD_VAR 0 4
87023: ARRAY
87024: PUSH
87025: LD_INT 1
87027: ARRAY
87028: PPUSH
87029: CALL 27690 0 2
87033: IFFALSE 87122
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
87035: LD_ADDR_EXP 64
87039: PUSH
87040: LD_EXP 64
87044: PPUSH
87045: LD_VAR 0 4
87049: PPUSH
87050: LD_EXP 64
87054: PUSH
87055: LD_VAR 0 4
87059: ARRAY
87060: PPUSH
87061: LD_INT 1
87063: PPUSH
87064: CALL_OW 3
87068: PPUSH
87069: CALL_OW 1
87073: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
87074: LD_ADDR_EXP 66
87078: PUSH
87079: LD_EXP 66
87083: PPUSH
87084: LD_VAR 0 4
87088: PUSH
87089: LD_EXP 66
87093: PUSH
87094: LD_VAR 0 4
87098: ARRAY
87099: PUSH
87100: LD_INT 1
87102: PLUS
87103: PUSH
87104: EMPTY
87105: LIST
87106: LIST
87107: PPUSH
87108: LD_VAR 0 1
87112: PPUSH
87113: CALL 21521 0 3
87117: ST_TO_ADDR
// exit ;
87118: POP
87119: POP
87120: GO 87126
// end ; end ;
87122: GO 86970
87124: POP
87125: POP
// end ;
87126: LD_VAR 0 3
87130: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
87131: LD_INT 0
87133: PPUSH
87134: PPUSH
87135: PPUSH
// if not mc_bases or not skirmish then
87136: LD_EXP 59
87140: NOT
87141: PUSH
87142: LD_EXP 57
87146: NOT
87147: OR
87148: IFFALSE 87152
// exit ;
87150: GO 87342
// for i = 1 to mc_bases do
87152: LD_ADDR_VAR 0 4
87156: PUSH
87157: DOUBLE
87158: LD_INT 1
87160: DEC
87161: ST_TO_ADDR
87162: LD_EXP 59
87166: PUSH
87167: FOR_TO
87168: IFFALSE 87255
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
87170: LD_VAR 0 1
87174: PUSH
87175: LD_EXP 67
87179: PUSH
87180: LD_VAR 0 4
87184: ARRAY
87185: IN
87186: PUSH
87187: LD_VAR 0 1
87191: PUSH
87192: LD_EXP 68
87196: PUSH
87197: LD_VAR 0 4
87201: ARRAY
87202: IN
87203: NOT
87204: AND
87205: IFFALSE 87253
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
87207: LD_ADDR_EXP 68
87211: PUSH
87212: LD_EXP 68
87216: PPUSH
87217: LD_VAR 0 4
87221: PUSH
87222: LD_EXP 68
87226: PUSH
87227: LD_VAR 0 4
87231: ARRAY
87232: PUSH
87233: LD_INT 1
87235: PLUS
87236: PUSH
87237: EMPTY
87238: LIST
87239: LIST
87240: PPUSH
87241: LD_VAR 0 1
87245: PPUSH
87246: CALL 21521 0 3
87250: ST_TO_ADDR
// break ;
87251: GO 87255
// end ; end ;
87253: GO 87167
87255: POP
87256: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
87257: LD_VAR 0 1
87261: PPUSH
87262: CALL_OW 257
87266: PUSH
87267: LD_EXP 85
87271: IN
87272: PUSH
87273: LD_VAR 0 1
87277: PPUSH
87278: CALL_OW 266
87282: PUSH
87283: LD_INT 5
87285: EQUAL
87286: AND
87287: PUSH
87288: LD_VAR 0 2
87292: PPUSH
87293: CALL_OW 110
87297: PUSH
87298: LD_INT 18
87300: NONEQUAL
87301: AND
87302: IFFALSE 87342
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
87304: LD_VAR 0 2
87308: PPUSH
87309: CALL_OW 257
87313: PUSH
87314: LD_INT 5
87316: PUSH
87317: LD_INT 8
87319: PUSH
87320: LD_INT 9
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: LIST
87327: IN
87328: IFFALSE 87342
// SetClass ( unit , 1 ) ;
87330: LD_VAR 0 2
87334: PPUSH
87335: LD_INT 1
87337: PPUSH
87338: CALL_OW 336
// end ;
87342: LD_VAR 0 3
87346: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
87347: LD_INT 0
87349: PPUSH
87350: PPUSH
// if not mc_bases or not skirmish then
87351: LD_EXP 59
87355: NOT
87356: PUSH
87357: LD_EXP 57
87361: NOT
87362: OR
87363: IFFALSE 87367
// exit ;
87365: GO 87483
// if GetLives ( abandoned_vehicle ) > 250 then
87367: LD_VAR 0 2
87371: PPUSH
87372: CALL_OW 256
87376: PUSH
87377: LD_INT 250
87379: GREATER
87380: IFFALSE 87384
// exit ;
87382: GO 87483
// for i = 1 to mc_bases do
87384: LD_ADDR_VAR 0 6
87388: PUSH
87389: DOUBLE
87390: LD_INT 1
87392: DEC
87393: ST_TO_ADDR
87394: LD_EXP 59
87398: PUSH
87399: FOR_TO
87400: IFFALSE 87481
// begin if driver in mc_bases [ i ] then
87402: LD_VAR 0 1
87406: PUSH
87407: LD_EXP 59
87411: PUSH
87412: LD_VAR 0 6
87416: ARRAY
87417: IN
87418: IFFALSE 87479
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
87420: LD_VAR 0 1
87424: PPUSH
87425: LD_EXP 59
87429: PUSH
87430: LD_VAR 0 6
87434: ARRAY
87435: PPUSH
87436: LD_INT 2
87438: PUSH
87439: LD_INT 30
87441: PUSH
87442: LD_INT 0
87444: PUSH
87445: EMPTY
87446: LIST
87447: LIST
87448: PUSH
87449: LD_INT 30
87451: PUSH
87452: LD_INT 1
87454: PUSH
87455: EMPTY
87456: LIST
87457: LIST
87458: PUSH
87459: EMPTY
87460: LIST
87461: LIST
87462: LIST
87463: PPUSH
87464: CALL_OW 72
87468: PUSH
87469: LD_INT 1
87471: ARRAY
87472: PPUSH
87473: CALL_OW 112
// break ;
87477: GO 87481
// end ; end ;
87479: GO 87399
87481: POP
87482: POP
// end ; end_of_file
87483: LD_VAR 0 5
87487: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
87488: GO 87490
87490: DISABLE
// begin ru_radar := 98 ;
87491: LD_ADDR_EXP 102
87495: PUSH
87496: LD_INT 98
87498: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
87499: LD_ADDR_EXP 103
87503: PUSH
87504: LD_INT 89
87506: ST_TO_ADDR
// us_hack := 99 ;
87507: LD_ADDR_EXP 104
87511: PUSH
87512: LD_INT 99
87514: ST_TO_ADDR
// us_artillery := 97 ;
87515: LD_ADDR_EXP 105
87519: PUSH
87520: LD_INT 97
87522: ST_TO_ADDR
// ar_bio_bomb := 91 ;
87523: LD_ADDR_EXP 106
87527: PUSH
87528: LD_INT 91
87530: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
87531: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
87532: LD_INT 0
87534: PPUSH
87535: PPUSH
87536: PPUSH
87537: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
87538: LD_VAR 0 1
87542: PPUSH
87543: CALL_OW 264
87547: PUSH
87548: LD_EXP 106
87552: EQUAL
87553: IFFALSE 87625
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
87555: LD_INT 68
87557: PPUSH
87558: LD_VAR 0 1
87562: PPUSH
87563: CALL_OW 255
87567: PPUSH
87568: CALL_OW 321
87572: PUSH
87573: LD_INT 2
87575: EQUAL
87576: IFFALSE 87588
// eff := 70 else
87578: LD_ADDR_VAR 0 6
87582: PUSH
87583: LD_INT 70
87585: ST_TO_ADDR
87586: GO 87596
// eff := 30 ;
87588: LD_ADDR_VAR 0 6
87592: PUSH
87593: LD_INT 30
87595: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
87596: LD_VAR 0 1
87600: PPUSH
87601: CALL_OW 250
87605: PPUSH
87606: LD_VAR 0 1
87610: PPUSH
87611: CALL_OW 251
87615: PPUSH
87616: LD_VAR 0 6
87620: PPUSH
87621: CALL_OW 495
// end ; end ;
87625: LD_VAR 0 4
87629: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
87630: LD_INT 0
87632: PPUSH
87633: PPUSH
87634: PPUSH
87635: PPUSH
87636: PPUSH
87637: PPUSH
// if cmd = 124 then
87638: LD_VAR 0 1
87642: PUSH
87643: LD_INT 124
87645: EQUAL
87646: IFFALSE 87852
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
87648: LD_ADDR_VAR 0 5
87652: PUSH
87653: LD_INT 2
87655: PUSH
87656: LD_INT 34
87658: PUSH
87659: LD_INT 53
87661: PUSH
87662: EMPTY
87663: LIST
87664: LIST
87665: PUSH
87666: LD_INT 34
87668: PUSH
87669: LD_INT 14
87671: PUSH
87672: EMPTY
87673: LIST
87674: LIST
87675: PUSH
87676: EMPTY
87677: LIST
87678: LIST
87679: LIST
87680: PPUSH
87681: CALL_OW 69
87685: ST_TO_ADDR
// if not tmp then
87686: LD_VAR 0 5
87690: NOT
87691: IFFALSE 87695
// exit ;
87693: GO 87852
// for i in tmp do
87695: LD_ADDR_VAR 0 3
87699: PUSH
87700: LD_VAR 0 5
87704: PUSH
87705: FOR_IN
87706: IFFALSE 87850
// begin taskList := GetTaskList ( i ) ;
87708: LD_ADDR_VAR 0 6
87712: PUSH
87713: LD_VAR 0 3
87717: PPUSH
87718: CALL_OW 437
87722: ST_TO_ADDR
// if not taskList then
87723: LD_VAR 0 6
87727: NOT
87728: IFFALSE 87732
// continue ;
87730: GO 87705
// for j = 1 to taskList do
87732: LD_ADDR_VAR 0 4
87736: PUSH
87737: DOUBLE
87738: LD_INT 1
87740: DEC
87741: ST_TO_ADDR
87742: LD_VAR 0 6
87746: PUSH
87747: FOR_TO
87748: IFFALSE 87846
// if taskList [ j ] [ 1 ] = | then
87750: LD_VAR 0 6
87754: PUSH
87755: LD_VAR 0 4
87759: ARRAY
87760: PUSH
87761: LD_INT 1
87763: ARRAY
87764: PUSH
87765: LD_STRING |
87767: EQUAL
87768: IFFALSE 87844
// begin _taskList := Delete ( taskList , 1 ) ;
87770: LD_ADDR_VAR 0 7
87774: PUSH
87775: LD_VAR 0 6
87779: PPUSH
87780: LD_INT 1
87782: PPUSH
87783: CALL_OW 3
87787: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
87788: LD_VAR 0 3
87792: PPUSH
87793: LD_VAR 0 7
87797: PPUSH
87798: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
87802: LD_VAR 0 3
87806: PPUSH
87807: LD_VAR 0 6
87811: PUSH
87812: LD_VAR 0 4
87816: ARRAY
87817: PUSH
87818: LD_INT 2
87820: ARRAY
87821: PPUSH
87822: LD_VAR 0 6
87826: PUSH
87827: LD_VAR 0 4
87831: ARRAY
87832: PUSH
87833: LD_INT 3
87835: ARRAY
87836: PPUSH
87837: LD_INT 8
87839: PPUSH
87840: CALL 87857 0 4
// end ;
87844: GO 87747
87846: POP
87847: POP
// end ;
87848: GO 87705
87850: POP
87851: POP
// end ; end ;
87852: LD_VAR 0 2
87856: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
87857: LD_INT 0
87859: PPUSH
87860: PPUSH
87861: PPUSH
87862: PPUSH
87863: PPUSH
87864: PPUSH
87865: PPUSH
87866: PPUSH
87867: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
87868: LD_VAR 0 1
87872: NOT
87873: PUSH
87874: LD_VAR 0 2
87878: PPUSH
87879: LD_VAR 0 3
87883: PPUSH
87884: CALL_OW 488
87888: NOT
87889: OR
87890: PUSH
87891: LD_VAR 0 4
87895: NOT
87896: OR
87897: IFFALSE 87901
// exit ;
87899: GO 88241
// list := [ ] ;
87901: LD_ADDR_VAR 0 13
87905: PUSH
87906: EMPTY
87907: ST_TO_ADDR
// if x - r < 0 then
87908: LD_VAR 0 2
87912: PUSH
87913: LD_VAR 0 4
87917: MINUS
87918: PUSH
87919: LD_INT 0
87921: LESS
87922: IFFALSE 87934
// min_x := 0 else
87924: LD_ADDR_VAR 0 7
87928: PUSH
87929: LD_INT 0
87931: ST_TO_ADDR
87932: GO 87950
// min_x := x - r ;
87934: LD_ADDR_VAR 0 7
87938: PUSH
87939: LD_VAR 0 2
87943: PUSH
87944: LD_VAR 0 4
87948: MINUS
87949: ST_TO_ADDR
// if y - r < 0 then
87950: LD_VAR 0 3
87954: PUSH
87955: LD_VAR 0 4
87959: MINUS
87960: PUSH
87961: LD_INT 0
87963: LESS
87964: IFFALSE 87976
// min_y := 0 else
87966: LD_ADDR_VAR 0 8
87970: PUSH
87971: LD_INT 0
87973: ST_TO_ADDR
87974: GO 87992
// min_y := y - r ;
87976: LD_ADDR_VAR 0 8
87980: PUSH
87981: LD_VAR 0 3
87985: PUSH
87986: LD_VAR 0 4
87990: MINUS
87991: ST_TO_ADDR
// max_x := x + r ;
87992: LD_ADDR_VAR 0 9
87996: PUSH
87997: LD_VAR 0 2
88001: PUSH
88002: LD_VAR 0 4
88006: PLUS
88007: ST_TO_ADDR
// max_y := y + r ;
88008: LD_ADDR_VAR 0 10
88012: PUSH
88013: LD_VAR 0 3
88017: PUSH
88018: LD_VAR 0 4
88022: PLUS
88023: ST_TO_ADDR
// for _x = min_x to max_x do
88024: LD_ADDR_VAR 0 11
88028: PUSH
88029: DOUBLE
88030: LD_VAR 0 7
88034: DEC
88035: ST_TO_ADDR
88036: LD_VAR 0 9
88040: PUSH
88041: FOR_TO
88042: IFFALSE 88159
// for _y = min_y to max_y do
88044: LD_ADDR_VAR 0 12
88048: PUSH
88049: DOUBLE
88050: LD_VAR 0 8
88054: DEC
88055: ST_TO_ADDR
88056: LD_VAR 0 10
88060: PUSH
88061: FOR_TO
88062: IFFALSE 88155
// begin if not ValidHex ( _x , _y ) then
88064: LD_VAR 0 11
88068: PPUSH
88069: LD_VAR 0 12
88073: PPUSH
88074: CALL_OW 488
88078: NOT
88079: IFFALSE 88083
// continue ;
88081: GO 88061
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
88083: LD_VAR 0 11
88087: PPUSH
88088: LD_VAR 0 12
88092: PPUSH
88093: CALL_OW 351
88097: PUSH
88098: LD_VAR 0 11
88102: PPUSH
88103: LD_VAR 0 12
88107: PPUSH
88108: CALL_OW 554
88112: AND
88113: IFFALSE 88153
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
88115: LD_ADDR_VAR 0 13
88119: PUSH
88120: LD_VAR 0 13
88124: PPUSH
88125: LD_VAR 0 13
88129: PUSH
88130: LD_INT 1
88132: PLUS
88133: PPUSH
88134: LD_VAR 0 11
88138: PUSH
88139: LD_VAR 0 12
88143: PUSH
88144: EMPTY
88145: LIST
88146: LIST
88147: PPUSH
88148: CALL_OW 2
88152: ST_TO_ADDR
// end ;
88153: GO 88061
88155: POP
88156: POP
88157: GO 88041
88159: POP
88160: POP
// if not list then
88161: LD_VAR 0 13
88165: NOT
88166: IFFALSE 88170
// exit ;
88168: GO 88241
// for i in list do
88170: LD_ADDR_VAR 0 6
88174: PUSH
88175: LD_VAR 0 13
88179: PUSH
88180: FOR_IN
88181: IFFALSE 88239
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
88183: LD_VAR 0 1
88187: PPUSH
88188: LD_STRING M
88190: PUSH
88191: LD_VAR 0 6
88195: PUSH
88196: LD_INT 1
88198: ARRAY
88199: PUSH
88200: LD_VAR 0 6
88204: PUSH
88205: LD_INT 2
88207: ARRAY
88208: PUSH
88209: LD_INT 0
88211: PUSH
88212: LD_INT 0
88214: PUSH
88215: LD_INT 0
88217: PUSH
88218: LD_INT 0
88220: PUSH
88221: EMPTY
88222: LIST
88223: LIST
88224: LIST
88225: LIST
88226: LIST
88227: LIST
88228: LIST
88229: PUSH
88230: EMPTY
88231: LIST
88232: PPUSH
88233: CALL_OW 447
88237: GO 88180
88239: POP
88240: POP
// end ;
88241: LD_VAR 0 5
88245: RET
