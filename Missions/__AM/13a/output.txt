// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 619 0 0
// InitMacro ;
  19: CALL 57472 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 49213 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 49213 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 49213 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 49213 0 9
// PrepareArabian ;
 147: CALL 3690 0 0
// PrepareRussian ;
 151: CALL 2825 0 0
// PrepareAlliance ;
 155: CALL 821 0 0
// MC_Start ( ) ;
 159: CALL 59584 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6853 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 83
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 84
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 80801 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 54
 252: PPUSH
 253: CALL 81227 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 81685 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 81954 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 81167 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 81861 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 51
 340: PPUSH
 341: CALL 81227 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 81685 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 81954 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 81011 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 22
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 3
 596: PUSH
 597: LD_INT 52
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL 81167 0 2
// end ;
 614: LD_VAR 0 1
 618: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 619: LD_INT 0
 621: PPUSH
// debug := 0 ;
 622: LD_ADDR_EXP 1
 626: PUSH
 627: LD_INT 0
 629: ST_TO_ADDR
// game := true ;
 630: LD_ADDR_EXP 2
 634: PUSH
 635: LD_INT 1
 637: ST_TO_ADDR
// gossudarov_arrive := false ;
 638: LD_ADDR_EXP 4
 642: PUSH
 643: LD_INT 0
 645: ST_TO_ADDR
// ru_lab_builded := false ;
 646: LD_ADDR_EXP 5
 650: PUSH
 651: LD_INT 0
 653: ST_TO_ADDR
// player_spotted := false ;
 654: LD_ADDR_EXP 6
 658: PUSH
 659: LD_INT 0
 661: ST_TO_ADDR
// first_attack := false ;
 662: LD_ADDR_EXP 7
 666: PUSH
 667: LD_INT 0
 669: ST_TO_ADDR
// ru_attackers := [ ] ;
 670: LD_ADDR_EXP 52
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// ar_base_spotted := false ;
 677: LD_ADDR_EXP 8
 681: PUSH
 682: LD_INT 0
 684: ST_TO_ADDR
// ar_active_attack := false ;
 685: LD_ADDR_EXP 9
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// ar_attackers := [ ] ;
 693: LD_ADDR_EXP 10
 697: PUSH
 698: EMPTY
 699: ST_TO_ADDR
// first_powell_attack := false ;
 700: LD_ADDR_EXP 11
 704: PUSH
 705: LD_INT 0
 707: ST_TO_ADDR
// abdul_escaped := true ;
 708: LD_ADDR_EXP 12
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// loss_counter := 0 ;
 716: LD_ADDR_EXP 13
 720: PUSH
 721: LD_INT 0
 723: ST_TO_ADDR
// hack_counter := 0 ;
 724: LD_ADDR_EXP 14
 728: PUSH
 729: LD_INT 0
 731: ST_TO_ADDR
// end ;
 732: LD_VAR 0 1
 736: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 737: LD_EXP 48
 741: PPUSH
 742: CALL_OW 255
 746: PUSH
 747: LD_INT 7
 749: EQUAL
 750: PUSH
 751: LD_EXP 47
 755: PPUSH
 756: CALL_OW 255
 760: PUSH
 761: LD_INT 7
 763: EQUAL
 764: AND
 765: PUSH
 766: LD_EXP 48
 770: PPUSH
 771: CALL_OW 302
 775: AND
 776: PUSH
 777: LD_EXP 47
 781: PPUSH
 782: CALL_OW 302
 786: AND
 787: IFFALSE 799
 789: GO 791
 791: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 792: LD_STRING ACH_COMRADE
 794: PPUSH
 795: CALL_OW 543
 799: END
// every 0 0$1 trigger hack_counter >= 10 do
 800: LD_EXP 14
 804: PUSH
 805: LD_INT 10
 807: GREATEREQUAL
 808: IFFALSE 820
 810: GO 812
 812: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 813: LD_STRING ACH_HACK
 815: PPUSH
 816: CALL_OW 543
 820: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 821: LD_INT 0
 823: PPUSH
 824: PPUSH
 825: PPUSH
 826: PPUSH
// uc_side := 7 ;
 827: LD_ADDR_OWVAR 20
 831: PUSH
 832: LD_INT 7
 834: ST_TO_ADDR
// uc_nation := 1 ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_INT 1
 842: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 843: LD_ADDR_EXP 15
 847: PUSH
 848: LD_STRING JMM
 850: PPUSH
 851: LD_EXP 1
 855: NOT
 856: PPUSH
 857: LD_STRING 12a_
 859: PPUSH
 860: CALL 14284 0 3
 864: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 865: LD_EXP 15
 869: PPUSH
 870: LD_INT 71
 872: PPUSH
 873: LD_INT 23
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 883: LD_EXP 15
 887: PPUSH
 888: LD_INT 2
 890: PPUSH
 891: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 895: LD_ADDR_EXP 16
 899: PUSH
 900: LD_STRING Roth
 902: PPUSH
 903: LD_EXP 1
 907: NOT
 908: PPUSH
 909: LD_STRING 12a_
 911: PPUSH
 912: CALL 14284 0 3
 916: ST_TO_ADDR
// if Roth then
 917: LD_EXP 16
 921: IFFALSE 941
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 923: LD_EXP 16
 927: PPUSH
 928: LD_INT 71
 930: PPUSH
 931: LD_INT 21
 933: PPUSH
 934: LD_INT 0
 936: PPUSH
 937: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING Lisa
 948: PPUSH
 949: LD_EXP 1
 953: NOT
 954: PPUSH
 955: LD_STRING 12a_
 957: PPUSH
 958: CALL 14284 0 3
 962: ST_TO_ADDR
// if Lisa then
 963: LD_EXP 17
 967: IFFALSE 984
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 969: LD_EXP 17
 973: PPUSH
 974: LD_INT 13
 976: PPUSH
 977: LD_INT 0
 979: PPUSH
 980: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 984: LD_ADDR_EXP 18
 988: PUSH
 989: LD_STRING Donaldson
 991: PPUSH
 992: LD_EXP 1
 996: NOT
 997: PPUSH
 998: LD_STRING 12a_
1000: PPUSH
1001: CALL 14284 0 3
1005: ST_TO_ADDR
// if Donaldson then
1006: LD_EXP 18
1010: IFFALSE 1027
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1012: LD_EXP 18
1016: PPUSH
1017: LD_INT 13
1019: PPUSH
1020: LD_INT 0
1022: PPUSH
1023: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1027: LD_ADDR_EXP 19
1031: PUSH
1032: LD_STRING Bobby
1034: PPUSH
1035: LD_EXP 1
1039: NOT
1040: PPUSH
1041: LD_STRING 12a_
1043: PPUSH
1044: CALL 14284 0 3
1048: ST_TO_ADDR
// if Bobby then
1049: LD_EXP 19
1053: IFFALSE 1070
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1055: LD_EXP 19
1059: PPUSH
1060: LD_INT 13
1062: PPUSH
1063: LD_INT 0
1065: PPUSH
1066: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1070: LD_ADDR_EXP 20
1074: PUSH
1075: LD_STRING Cyrus
1077: PPUSH
1078: LD_EXP 1
1082: NOT
1083: PPUSH
1084: LD_STRING 12a_
1086: PPUSH
1087: CALL 14284 0 3
1091: ST_TO_ADDR
// if Cyrus then
1092: LD_EXP 20
1096: IFFALSE 1113
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1098: LD_EXP 20
1102: PPUSH
1103: LD_INT 13
1105: PPUSH
1106: LD_INT 0
1108: PPUSH
1109: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1113: LD_ADDR_EXP 21
1117: PUSH
1118: LD_STRING Denis
1120: PPUSH
1121: LD_EXP 1
1125: NOT
1126: PPUSH
1127: LD_STRING 12a_
1129: PPUSH
1130: CALL 14284 0 3
1134: ST_TO_ADDR
// if Denis then
1135: LD_EXP 21
1139: IFFALSE 1156
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1141: LD_EXP 21
1145: PPUSH
1146: LD_INT 13
1148: PPUSH
1149: LD_INT 0
1151: PPUSH
1152: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1156: LD_ADDR_EXP 22
1160: PUSH
1161: LD_STRING Brown
1163: PPUSH
1164: LD_EXP 1
1168: NOT
1169: PPUSH
1170: LD_STRING 12a_
1172: PPUSH
1173: CALL 14284 0 3
1177: ST_TO_ADDR
// if Brown then
1178: LD_EXP 22
1182: IFFALSE 1199
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1184: LD_EXP 22
1188: PPUSH
1189: LD_INT 13
1191: PPUSH
1192: LD_INT 0
1194: PPUSH
1195: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1199: LD_ADDR_EXP 23
1203: PUSH
1204: LD_STRING Gladstone
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_STRING 12a_
1215: PPUSH
1216: CALL 14284 0 3
1220: ST_TO_ADDR
// if Gladstone then
1221: LD_EXP 23
1225: IFFALSE 1242
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1227: LD_EXP 23
1231: PPUSH
1232: LD_INT 13
1234: PPUSH
1235: LD_INT 0
1237: PPUSH
1238: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1242: LD_ADDR_EXP 24
1246: PUSH
1247: LD_STRING Houten
1249: PPUSH
1250: LD_EXP 1
1254: NOT
1255: PPUSH
1256: LD_STRING 12a_
1258: PPUSH
1259: CALL 14284 0 3
1263: ST_TO_ADDR
// if Houten then
1264: LD_EXP 24
1268: IFFALSE 1285
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1270: LD_EXP 24
1274: PPUSH
1275: LD_INT 13
1277: PPUSH
1278: LD_INT 0
1280: PPUSH
1281: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1285: LD_ADDR_EXP 25
1289: PUSH
1290: LD_STRING Cornell
1292: PPUSH
1293: LD_EXP 1
1297: NOT
1298: PPUSH
1299: LD_STRING 12a_
1301: PPUSH
1302: CALL 14284 0 3
1306: ST_TO_ADDR
// if Cornel then
1307: LD_EXP 25
1311: IFFALSE 1328
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1313: LD_EXP 25
1317: PPUSH
1318: LD_INT 13
1320: PPUSH
1321: LD_INT 0
1323: PPUSH
1324: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1328: LD_ADDR_EXP 26
1332: PUSH
1333: LD_STRING Gary
1335: PPUSH
1336: LD_EXP 1
1340: NOT
1341: PPUSH
1342: LD_STRING 12a_
1344: PPUSH
1345: CALL 14284 0 3
1349: ST_TO_ADDR
// if Gary then
1350: LD_EXP 26
1354: IFFALSE 1371
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1356: LD_EXP 26
1360: PPUSH
1361: LD_INT 13
1363: PPUSH
1364: LD_INT 0
1366: PPUSH
1367: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1371: LD_ADDR_EXP 27
1375: PUSH
1376: LD_STRING Frank
1378: PPUSH
1379: LD_EXP 1
1383: NOT
1384: PPUSH
1385: LD_STRING 12a_
1387: PPUSH
1388: CALL 14284 0 3
1392: ST_TO_ADDR
// if Frank then
1393: LD_EXP 27
1397: IFFALSE 1414
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1399: LD_EXP 27
1403: PPUSH
1404: LD_INT 13
1406: PPUSH
1407: LD_INT 0
1409: PPUSH
1410: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1414: LD_ADDR_EXP 28
1418: PUSH
1419: LD_STRING Kikuchi
1421: PPUSH
1422: LD_EXP 1
1426: NOT
1427: PPUSH
1428: LD_STRING 12a_
1430: PPUSH
1431: CALL 14284 0 3
1435: ST_TO_ADDR
// if Kikuchi then
1436: LD_EXP 28
1440: IFFALSE 1457
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1442: LD_EXP 28
1446: PPUSH
1447: LD_INT 13
1449: PPUSH
1450: LD_INT 0
1452: PPUSH
1453: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1457: LD_ADDR_EXP 29
1461: PUSH
1462: LD_STRING Simms
1464: PPUSH
1465: LD_EXP 1
1469: NOT
1470: PPUSH
1471: LD_STRING 12a_
1473: PPUSH
1474: CALL 14284 0 3
1478: ST_TO_ADDR
// if Simms then
1479: LD_EXP 29
1483: IFFALSE 1500
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1485: LD_EXP 29
1489: PPUSH
1490: LD_INT 13
1492: PPUSH
1493: LD_INT 0
1495: PPUSH
1496: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1500: LD_ADDR_EXP 30
1504: PUSH
1505: LD_STRING Joan
1507: PPUSH
1508: LD_EXP 1
1512: NOT
1513: PPUSH
1514: LD_STRING 12a_
1516: PPUSH
1517: CALL 14284 0 3
1521: ST_TO_ADDR
// if Joan then
1522: LD_EXP 30
1526: IFFALSE 1543
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1528: LD_EXP 30
1532: PPUSH
1533: LD_INT 13
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1543: LD_ADDR_EXP 31
1547: PUSH
1548: LD_STRING DeltaDoctor
1550: PPUSH
1551: LD_EXP 1
1555: NOT
1556: PPUSH
1557: LD_STRING 12a_
1559: PPUSH
1560: CALL 14284 0 3
1564: ST_TO_ADDR
// if DeltaDoctor then
1565: LD_EXP 31
1569: IFFALSE 1586
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1571: LD_EXP 31
1575: PPUSH
1576: LD_INT 13
1578: PPUSH
1579: LD_INT 0
1581: PPUSH
1582: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1586: LD_ADDR_VAR 0 4
1590: PUSH
1591: LD_STRING 12a_others
1593: PPUSH
1594: CALL_OW 31
1598: ST_TO_ADDR
// if tmp then
1599: LD_VAR 0 4
1603: IFFALSE 1637
// for i in tmp do
1605: LD_ADDR_VAR 0 3
1609: PUSH
1610: LD_VAR 0 4
1614: PUSH
1615: FOR_IN
1616: IFFALSE 1635
// PlaceUnitArea ( i , alliance_start , false ) ;
1618: LD_VAR 0 3
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
1633: GO 1615
1635: POP
1636: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 3
1642: PPUSH
1643: LD_INT 3
1645: PPUSH
1646: LD_INT 12
1648: PPUSH
1649: LD_INT 100
1651: PPUSH
1652: CALL 21399 0 5
// veh := CreateVehicle ;
1656: LD_ADDR_VAR 0 2
1660: PUSH
1661: CALL_OW 45
1665: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1666: LD_VAR 0 2
1670: PPUSH
1671: LD_INT 2
1673: PPUSH
1674: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1678: LD_VAR 0 2
1682: PPUSH
1683: LD_INT 60
1685: PPUSH
1686: LD_INT 6
1688: PPUSH
1689: LD_INT 0
1691: PPUSH
1692: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1696: LD_VAR 0 2
1700: PPUSH
1701: LD_INT 4
1703: PPUSH
1704: LD_INT 30
1706: PPUSH
1707: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1711: LD_STRING 11_artifact_captured
1713: PPUSH
1714: LD_INT 0
1716: PPUSH
1717: CALL_OW 30
1721: IFFALSE 1797
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1723: LD_INT 3
1725: PPUSH
1726: LD_INT 3
1728: PPUSH
1729: LD_INT 3
1731: PPUSH
1732: LD_INT 12
1734: PPUSH
1735: LD_INT 100
1737: PPUSH
1738: CALL 21399 0 5
// veh := CreateVehicle ;
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: CALL_OW 45
1751: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1752: LD_VAR 0 2
1756: PPUSH
1757: LD_INT 3
1759: PPUSH
1760: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1764: LD_VAR 0 2
1768: PPUSH
1769: LD_INT 75
1771: PPUSH
1772: LD_INT 6
1774: PPUSH
1775: LD_INT 0
1777: PPUSH
1778: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1782: LD_VAR 0 2
1786: PPUSH
1787: LD_INT 4
1789: PPUSH
1790: LD_INT 50
1792: PPUSH
1793: CALL_OW 290
// end ; end ;
1797: LD_VAR 0 1
1801: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1802: LD_INT 0
1804: PPUSH
1805: PPUSH
1806: PPUSH
1807: PPUSH
// uc_side := 6 ;
1808: LD_ADDR_OWVAR 20
1812: PUSH
1813: LD_INT 6
1815: ST_TO_ADDR
// uc_nation := 3 ;
1816: LD_ADDR_OWVAR 21
1820: PUSH
1821: LD_INT 3
1823: ST_TO_ADDR
// InitHc ;
1824: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1828: LD_ADDR_EXP 32
1832: PUSH
1833: LD_STRING Gossudarov
1835: PPUSH
1836: CALL_OW 25
1840: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1841: LD_ADDR_EXP 33
1845: PUSH
1846: LD_STRING Kirilenkova
1848: PPUSH
1849: CALL_OW 25
1853: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1854: LD_ADDR_EXP 34
1858: PUSH
1859: LD_STRING Titov
1861: PPUSH
1862: CALL_OW 25
1866: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1867: LD_ADDR_EXP 39
1871: PUSH
1872: LD_STRING Oblukov
1874: PPUSH
1875: CALL_OW 25
1879: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1880: LD_ADDR_EXP 36
1884: PUSH
1885: LD_STRING Dolgov
1887: PPUSH
1888: CALL_OW 25
1892: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1893: LD_ADDR_EXP 37
1897: PUSH
1898: LD_STRING Petrosyan
1900: PPUSH
1901: CALL_OW 25
1905: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1906: LD_ADDR_EXP 38
1910: PUSH
1911: LD_STRING Scholtze
1913: PPUSH
1914: CALL_OW 25
1918: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1919: LD_ADDR_EXP 40
1923: PUSH
1924: LD_STRING Kapitsova
1926: PPUSH
1927: CALL_OW 25
1931: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1932: LD_ADDR_VAR 0 2
1936: PUSH
1937: LD_EXP 32
1941: PUSH
1942: LD_EXP 33
1946: PUSH
1947: LD_EXP 34
1951: PUSH
1952: LD_EXP 39
1956: PUSH
1957: LD_EXP 36
1961: PUSH
1962: LD_EXP 37
1966: PUSH
1967: LD_EXP 38
1971: PUSH
1972: LD_EXP 40
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: LIST
1986: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1987: LD_INT 1
1989: PPUSH
1990: LD_INT 4
1992: PPUSH
1993: LD_INT 8
1995: PPUSH
1996: CALL_OW 380
// un := CreateHuman ;
2000: LD_ADDR_VAR 0 4
2004: PUSH
2005: CALL_OW 44
2009: ST_TO_ADDR
// tmp := tmp ^ un ;
2010: LD_ADDR_VAR 0 2
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_VAR 0 4
2024: ADD
2025: ST_TO_ADDR
// for i in tmp do
2026: LD_ADDR_VAR 0 3
2030: PUSH
2031: LD_VAR 0 2
2035: PUSH
2036: FOR_IN
2037: IFFALSE 2056
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2039: LD_VAR 0 3
2043: PPUSH
2044: LD_INT 14
2046: PPUSH
2047: LD_INT 0
2049: PPUSH
2050: CALL_OW 49
2054: GO 2036
2056: POP
2057: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_EXP 3
2067: PPUSH
2068: CALL_OW 250
2072: PPUSH
2073: LD_EXP 3
2077: PPUSH
2078: CALL_OW 251
2082: PPUSH
2083: CALL_OW 111
// end ;
2087: LD_VAR 0 1
2091: RET
// export function PrepareBelkov ; begin
2092: LD_INT 0
2094: PPUSH
// uc_side := 4 ;
2095: LD_ADDR_OWVAR 20
2099: PUSH
2100: LD_INT 4
2102: ST_TO_ADDR
// uc_nation := 3 ;
2103: LD_ADDR_OWVAR 21
2107: PUSH
2108: LD_INT 3
2110: ST_TO_ADDR
// InitHc ;
2111: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2115: LD_ADDR_EXP 47
2119: PUSH
2120: LD_STRING Belkov
2122: PPUSH
2123: CALL_OW 25
2127: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2128: LD_EXP 47
2132: PPUSH
2133: LD_INT 14
2135: PPUSH
2136: LD_INT 0
2138: PPUSH
2139: CALL_OW 49
// end ;
2143: LD_VAR 0 1
2147: RET
// export function PrepareGnyevko ; begin
2148: LD_INT 0
2150: PPUSH
// uc_side := 4 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 4
2158: ST_TO_ADDR
// uc_nation := 3 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 3
2166: ST_TO_ADDR
// InitHc ;
2167: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2171: LD_ADDR_EXP 48
2175: PUSH
2176: LD_STRING Gnyevko
2178: PPUSH
2179: CALL_OW 25
2183: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2184: LD_EXP 48
2188: PPUSH
2189: LD_INT 14
2191: PPUSH
2192: LD_INT 0
2194: PPUSH
2195: CALL_OW 49
// end ;
2199: LD_VAR 0 1
2203: RET
// export function PrepareBurlak ; var i , tmp ; begin
2204: LD_INT 0
2206: PPUSH
2207: PPUSH
2208: PPUSH
// uc_side := 4 ;
2209: LD_ADDR_OWVAR 20
2213: PUSH
2214: LD_INT 4
2216: ST_TO_ADDR
// uc_nation := 3 ;
2217: LD_ADDR_OWVAR 21
2221: PUSH
2222: LD_INT 3
2224: ST_TO_ADDR
// InitHc ;
2225: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2229: LD_ADDR_EXP 46
2233: PUSH
2234: LD_STRING Burlak
2236: PPUSH
2237: CALL_OW 25
2241: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2242: LD_INT 24
2244: PUSH
2245: LD_INT 23
2247: PUSH
2248: LD_INT 22
2250: PUSH
2251: EMPTY
2252: LIST
2253: LIST
2254: LIST
2255: PUSH
2256: LD_OWVAR 67
2260: ARRAY
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: LD_INT 1
2267: PPUSH
2268: LD_INT 45
2270: PUSH
2271: LD_INT 44
2273: PUSH
2274: LD_INT 43
2276: PUSH
2277: EMPTY
2278: LIST
2279: LIST
2280: LIST
2281: PUSH
2282: LD_OWVAR 67
2286: ARRAY
2287: PPUSH
2288: LD_INT 0
2290: PPUSH
2291: CALL 21399 0 5
// Masha := CreateVehicle ;
2295: LD_ADDR_EXP 49
2299: PUSH
2300: CALL_OW 45
2304: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2305: LD_EXP 49
2309: PUSH
2310: LD_EXP 46
2314: PUSH
2315: EMPTY
2316: LIST
2317: LIST
2318: PPUSH
2319: LD_INT 499
2321: PPUSH
2322: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2326: LD_EXP 49
2330: PPUSH
2331: LD_INT 3
2333: PPUSH
2334: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2338: LD_EXP 49
2342: PPUSH
2343: LD_INT 1
2345: PPUSH
2346: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2350: LD_INT 1
2352: PPUSH
2353: LD_INT 18
2355: PPUSH
2356: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2360: LD_INT 35
2362: PPUSH
2363: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 18
2374: PPUSH
2375: EMPTY
2376: PPUSH
2377: CALL_OW 70
2381: ST_TO_ADDR
// if tmp then
2382: LD_VAR 0 3
2386: IFFALSE 2420
// for i in tmp do
2388: LD_ADDR_VAR 0 2
2392: PUSH
2393: LD_VAR 0 3
2397: PUSH
2398: FOR_IN
2399: IFFALSE 2418
// ComMoveXY ( i , 114 , 9 ) ;
2401: LD_VAR 0 2
2405: PPUSH
2406: LD_INT 114
2408: PPUSH
2409: LD_INT 9
2411: PPUSH
2412: CALL_OW 111
2416: GO 2398
2418: POP
2419: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2420: LD_INT 18
2422: PPUSH
2423: EMPTY
2424: PPUSH
2425: CALL_OW 70
2429: NOT
2430: PUSH
2431: LD_INT 123
2433: PPUSH
2434: LD_INT 3
2436: PPUSH
2437: CALL_OW 428
2441: PUSH
2442: LD_INT 0
2444: EQUAL
2445: AND
2446: IFFALSE 2360
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2448: LD_EXP 49
2452: PPUSH
2453: LD_INT 123
2455: PPUSH
2456: LD_INT 3
2458: PPUSH
2459: LD_INT 0
2461: PPUSH
2462: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2466: LD_EXP 46
2470: PPUSH
2471: LD_INT 125
2473: PPUSH
2474: LD_INT 1
2476: PPUSH
2477: LD_INT 0
2479: PPUSH
2480: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2484: LD_EXP 46
2488: PPUSH
2489: LD_EXP 49
2493: PPUSH
2494: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2498: LD_INT 10
2500: PPUSH
2501: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2505: LD_EXP 49
2509: PPUSH
2510: LD_INT 110
2512: PPUSH
2513: LD_INT 10
2515: PPUSH
2516: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2520: LD_ADDR_EXP 42
2524: PUSH
2525: LD_STRING Petrovova
2527: PPUSH
2528: CALL_OW 25
2532: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2533: LD_ADDR_EXP 44
2537: PUSH
2538: LD_STRING Kuzmov
2540: PPUSH
2541: CALL_OW 25
2545: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2546: LD_ADDR_EXP 43
2550: PUSH
2551: LD_STRING Kovalyuk
2553: PPUSH
2554: CALL_OW 25
2558: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2559: LD_ADDR_EXP 41
2563: PUSH
2564: LD_STRING Lipshchin
2566: PPUSH
2567: CALL_OW 25
2571: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2572: LD_ADDR_EXP 45
2576: PUSH
2577: LD_STRING Karamazov
2579: PPUSH
2580: CALL_OW 25
2584: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2585: LD_ADDR_VAR 0 3
2589: PUSH
2590: LD_EXP 42
2594: PUSH
2595: LD_EXP 44
2599: PUSH
2600: LD_EXP 43
2604: PUSH
2605: LD_EXP 41
2609: PUSH
2610: LD_EXP 45
2614: PUSH
2615: EMPTY
2616: LIST
2617: LIST
2618: LIST
2619: LIST
2620: LIST
2621: ST_TO_ADDR
// for i in tmp do
2622: LD_ADDR_VAR 0 2
2626: PUSH
2627: LD_VAR 0 3
2631: PUSH
2632: FOR_IN
2633: IFFALSE 2672
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2635: LD_VAR 0 2
2639: PPUSH
2640: LD_INT 399
2642: PPUSH
2643: LD_INT 799
2645: PPUSH
2646: CALL_OW 12
2650: PPUSH
2651: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2655: LD_VAR 0 2
2659: PPUSH
2660: LD_INT 19
2662: PPUSH
2663: LD_INT 0
2665: PPUSH
2666: CALL_OW 49
// end ;
2670: GO 2632
2672: POP
2673: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2674: LD_VAR 0 3
2678: PPUSH
2679: LD_INT 116
2681: PPUSH
2682: LD_INT 8
2684: PPUSH
2685: CALL_OW 111
// AddComHold ( tmp ) ;
2689: LD_VAR 0 3
2693: PPUSH
2694: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2698: LD_ADDR_VAR 0 2
2702: PUSH
2703: LD_VAR 0 3
2707: PPUSH
2708: LD_INT 25
2710: PUSH
2711: LD_INT 1
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PPUSH
2718: CALL_OW 72
2722: PUSH
2723: FOR_IN
2724: IFFALSE 2764
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2726: LD_VAR 0 2
2730: PPUSH
2731: LD_INT 20
2733: PPUSH
2734: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2738: LD_VAR 0 2
2742: PPUSH
2743: LD_INT 147
2745: PPUSH
2746: LD_INT 45
2748: PPUSH
2749: CALL_OW 178
// AddComCrawl ( i ) ;
2753: LD_VAR 0 2
2757: PPUSH
2758: CALL_OW 197
// end ;
2762: GO 2723
2764: POP
2765: POP
// repeat wait ( 0 0$1 ) ;
2766: LD_INT 35
2768: PPUSH
2769: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2773: LD_EXP 49
2777: PPUSH
2778: LD_INT 110
2780: PPUSH
2781: LD_INT 10
2783: PPUSH
2784: CALL_OW 307
2788: PUSH
2789: LD_EXP 49
2793: PPUSH
2794: CALL_OW 305
2798: NOT
2799: OR
2800: IFFALSE 2766
// ComStop ( Burlak ) ;
2802: LD_EXP 46
2806: PPUSH
2807: CALL_OW 141
// AddComHold ( Burlak ) ;
2811: LD_EXP 46
2815: PPUSH
2816: CALL_OW 200
// end ; end_of_file
2820: LD_VAR 0 1
2824: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2825: LD_INT 0
2827: PPUSH
2828: PPUSH
2829: PPUSH
2830: PPUSH
// uc_side := 3 ;
2831: LD_ADDR_OWVAR 20
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// uc_nation := 3 ;
2839: LD_ADDR_OWVAR 21
2843: PUSH
2844: LD_INT 3
2846: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2847: LD_ADDR_EXP 50
2851: PUSH
2852: LD_INT 47
2854: PPUSH
2855: LD_INT 4
2857: PPUSH
2858: LD_STRING 
2860: PPUSH
2861: LD_INT 7
2863: PUSH
2864: LD_INT 8
2866: PUSH
2867: LD_INT 9
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: LIST
2874: PUSH
2875: LD_OWVAR 67
2879: ARRAY
2880: PPUSH
2881: LD_INT 10000
2883: PUSH
2884: LD_INT 3000
2886: PUSH
2887: LD_INT 300
2889: PUSH
2890: EMPTY
2891: LIST
2892: LIST
2893: LIST
2894: PPUSH
2895: LD_INT 9
2897: PUSH
2898: LD_INT 5
2900: PUSH
2901: LD_INT 6
2903: PUSH
2904: LD_INT 6
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: PPUSH
2913: CALL 24808 0 6
2917: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2918: LD_ADDR_EXP 59
2922: PUSH
2923: LD_EXP 59
2927: PPUSH
2928: LD_INT 2
2930: PPUSH
2931: LD_EXP 50
2935: PPUSH
2936: CALL_OW 1
2940: ST_TO_ADDR
// tmp := [ ] ;
2941: LD_ADDR_VAR 0 4
2945: PUSH
2946: EMPTY
2947: ST_TO_ADDR
// for i = 1 to 4 do
2948: LD_ADDR_VAR 0 2
2952: PUSH
2953: DOUBLE
2954: LD_INT 1
2956: DEC
2957: ST_TO_ADDR
2958: LD_INT 4
2960: PUSH
2961: FOR_TO
2962: IFFALSE 3055
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2964: LD_INT 22
2966: PPUSH
2967: LD_INT 3
2969: PPUSH
2970: LD_INT 3
2972: PPUSH
2973: LD_INT 43
2975: PUSH
2976: LD_INT 45
2978: PUSH
2979: LD_INT 45
2981: PUSH
2982: LD_INT 44
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: PUSH
2991: LD_VAR 0 2
2995: PUSH
2996: LD_INT 4
2998: MOD
2999: PUSH
3000: LD_INT 1
3002: PLUS
3003: ARRAY
3004: PPUSH
3005: LD_INT 100
3007: PPUSH
3008: CALL 21399 0 5
// veh := CreateVehicle ;
3012: LD_ADDR_VAR 0 3
3016: PUSH
3017: CALL_OW 45
3021: ST_TO_ADDR
// tmp := tmp ^ veh ;
3022: LD_ADDR_VAR 0 4
3026: PUSH
3027: LD_VAR 0 4
3031: PUSH
3032: LD_VAR 0 3
3036: ADD
3037: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3038: LD_VAR 0 3
3042: PPUSH
3043: LD_INT 2
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 49
// end ;
3053: GO 2961
3055: POP
3056: POP
// russian_guard := tmp ;
3057: LD_ADDR_EXP 51
3061: PUSH
3062: LD_VAR 0 4
3066: ST_TO_ADDR
// end ;
3067: LD_VAR 0 1
3071: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
3072: LD_INT 47
3074: PPUSH
3075: CALL_OW 302
3079: PUSH
3080: LD_EXP 6
3084: AND
3085: IFFALSE 3687
3087: GO 3089
3089: DISABLE
3090: LD_INT 0
3092: PPUSH
3093: PPUSH
3094: PPUSH
3095: PPUSH
3096: PPUSH
3097: PPUSH
// begin enable ;
3098: ENABLE
// base := 2 ;
3099: LD_ADDR_VAR 0 2
3103: PUSH
3104: LD_INT 2
3106: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3107: LD_ADDR_VAR 0 4
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: LD_INT 0
3117: PUSH
3118: LD_INT 0
3120: PUSH
3121: LD_INT 0
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 0
3129: PUSH
3130: LD_INT 0
3132: PUSH
3133: LD_INT 0
3135: PUSH
3136: LD_INT 1
3138: PUSH
3139: LD_INT 0
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3154: LD_ADDR_VAR 0 3
3158: PUSH
3159: LD_INT 22
3161: PUSH
3162: LD_INT 1
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: LD_INT 45
3170: PUSH
3171: EMPTY
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: PUSH
3177: LD_INT 21
3179: PUSH
3180: LD_INT 1
3182: PUSH
3183: LD_INT 3
3185: PUSH
3186: LD_INT 45
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 22
3197: PUSH
3198: LD_INT 1
3200: PUSH
3201: LD_INT 3
3203: PUSH
3204: LD_INT 45
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 23
3215: PUSH
3216: LD_INT 1
3218: PUSH
3219: LD_INT 3
3221: PUSH
3222: LD_INT 46
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: LIST
3229: LIST
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: LIST
3235: LIST
3236: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3237: LD_ADDR_VAR 0 1
3241: PUSH
3242: DOUBLE
3243: LD_INT 1
3245: DEC
3246: ST_TO_ADDR
3247: LD_OWVAR 67
3251: PUSH
3252: LD_OWVAR 1
3256: PUSH
3257: LD_INT 21000
3259: DIV
3260: PLUS
3261: PUSH
3262: FOR_TO
3263: IFFALSE 3351
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3265: LD_ADDR_VAR 0 3
3269: PUSH
3270: LD_VAR 0 3
3274: PPUSH
3275: LD_VAR 0 3
3279: PUSH
3280: LD_INT 1
3282: PLUS
3283: PPUSH
3284: LD_INT 23
3286: PUSH
3287: LD_INT 24
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: LD_INT 1
3296: PPUSH
3297: LD_INT 2
3299: PPUSH
3300: CALL_OW 12
3304: ARRAY
3305: PUSH
3306: LD_INT 1
3308: PUSH
3309: LD_INT 3
3311: PUSH
3312: LD_INT 46
3314: PUSH
3315: LD_INT 47
3317: PUSH
3318: LD_INT 45
3320: PUSH
3321: EMPTY
3322: LIST
3323: LIST
3324: LIST
3325: PUSH
3326: LD_INT 1
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: CALL_OW 12
3336: ARRAY
3337: PUSH
3338: EMPTY
3339: LIST
3340: LIST
3341: LIST
3342: LIST
3343: PPUSH
3344: CALL_OW 2
3348: ST_TO_ADDR
3349: GO 3262
3351: POP
3352: POP
// MC_InsertProduceList ( base , tmp ) ;
3353: LD_VAR 0 2
3357: PPUSH
3358: LD_VAR 0 3
3362: PPUSH
3363: CALL 81167 0 2
// repeat wait ( 0 0$1 ) ;
3367: LD_INT 35
3369: PPUSH
3370: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3374: LD_EXP 78
3378: PUSH
3379: LD_VAR 0 2
3383: ARRAY
3384: PUSH
3385: LD_INT 6
3387: GREATER
3388: IFFALSE 3367
// wait ( 0 0$20 ) ;
3390: LD_INT 700
3392: PPUSH
3393: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3397: LD_ADDR_VAR 0 5
3401: PUSH
3402: LD_INT 71
3404: PUSH
3405: LD_INT 19
3407: PUSH
3408: EMPTY
3409: LIST
3410: LIST
3411: PUSH
3412: LD_INT 91
3414: PUSH
3415: LD_INT 67
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: PUSH
3422: LD_INT 52
3424: PUSH
3425: LD_INT 44
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PUSH
3432: LD_INT 68
3434: PUSH
3435: LD_INT 48
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3448: LD_ADDR_VAR 0 6
3452: PUSH
3453: LD_EXP 78
3457: PUSH
3458: LD_VAR 0 2
3462: ARRAY
3463: PUSH
3464: LD_EXP 78
3468: PUSH
3469: LD_VAR 0 2
3473: ARRAY
3474: PPUSH
3475: LD_INT 2
3477: PUSH
3478: LD_INT 34
3480: PUSH
3481: LD_INT 51
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: PUSH
3488: LD_INT 34
3490: PUSH
3491: LD_INT 52
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: LIST
3502: PPUSH
3503: CALL_OW 72
3507: DIFF
3508: ST_TO_ADDR
// if not attackers then
3509: LD_VAR 0 6
3513: NOT
3514: IFFALSE 3518
// exit ;
3516: GO 3687
// ru_attackers := attackers ;
3518: LD_ADDR_EXP 52
3522: PUSH
3523: LD_VAR 0 6
3527: ST_TO_ADDR
// for i = 1 to attackers do
3528: LD_ADDR_VAR 0 1
3532: PUSH
3533: DOUBLE
3534: LD_INT 1
3536: DEC
3537: ST_TO_ADDR
3538: LD_VAR 0 6
3542: PUSH
3543: FOR_TO
3544: IFFALSE 3621
// begin case i mod 3 of 0 :
3546: LD_VAR 0 1
3550: PUSH
3551: LD_INT 3
3553: MOD
3554: PUSH
3555: LD_INT 0
3557: DOUBLE
3558: EQUAL
3559: IFTRUE 3563
3561: GO 3566
3563: POP
// ; 1 :
3564: GO 3619
3566: LD_INT 1
3568: DOUBLE
3569: EQUAL
3570: IFTRUE 3574
3572: GO 3592
3574: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3575: LD_VAR 0 1
3579: PPUSH
3580: LD_INT 32
3582: PPUSH
3583: LD_INT 49
3585: PPUSH
3586: CALL_OW 114
3590: GO 3619
3592: LD_INT 2
3594: DOUBLE
3595: EQUAL
3596: IFTRUE 3600
3598: GO 3618
3600: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3601: LD_VAR 0 1
3605: PPUSH
3606: LD_INT 117
3608: PPUSH
3609: LD_INT 107
3611: PPUSH
3612: CALL_OW 114
3616: GO 3619
3618: POP
// end ;
3619: GO 3543
3621: POP
3622: POP
// repeat wait ( 0 0$1 ) ;
3623: LD_INT 35
3625: PPUSH
3626: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3630: LD_VAR 0 6
3634: PPUSH
3635: LD_INT 60
3637: PUSH
3638: EMPTY
3639: LIST
3640: PPUSH
3641: CALL_OW 72
3645: NOT
3646: IFFALSE 3623
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3648: LD_VAR 0 2
3652: PPUSH
3653: LD_VAR 0 6
3657: PPUSH
3658: LD_VAR 0 5
3662: PPUSH
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL 81352 0 4
// if not first_attack then
3672: LD_EXP 7
3676: NOT
3677: IFFALSE 3687
// first_attack := true ;
3679: LD_ADDR_EXP 7
3683: PUSH
3684: LD_INT 1
3686: ST_TO_ADDR
// end ; end_of_file
3687: PPOPN 6
3689: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3690: LD_INT 0
3692: PPUSH
3693: PPUSH
3694: PPUSH
3695: PPUSH
3696: PPUSH
3697: PPUSH
3698: PPUSH
// uc_side := 2 ;
3699: LD_ADDR_OWVAR 20
3703: PUSH
3704: LD_INT 2
3706: ST_TO_ADDR
// uc_nation := 2 ;
3707: LD_ADDR_OWVAR 21
3711: PUSH
3712: LD_INT 2
3714: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3715: LD_ADDR_EXP 55
3719: PUSH
3720: LD_STRING Abdul
3722: PPUSH
3723: CALL_OW 25
3727: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3728: LD_EXP 55
3732: PPUSH
3733: LD_INT 11
3735: PPUSH
3736: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3740: LD_EXP 55
3744: PPUSH
3745: LD_INT 1
3747: PPUSH
3748: CALL_OW 52
// vc_chassis := 31 ;
3752: LD_ADDR_OWVAR 37
3756: PUSH
3757: LD_INT 31
3759: ST_TO_ADDR
// vc_control := control_rider ;
3760: LD_ADDR_OWVAR 38
3764: PUSH
3765: LD_INT 4
3767: ST_TO_ADDR
// mastodont := CreateVehicle ;
3768: LD_ADDR_EXP 56
3772: PUSH
3773: CALL_OW 45
3777: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3778: LD_EXP 56
3782: PPUSH
3783: LD_INT 153
3785: PPUSH
3786: LD_INT 71
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// InitVc ;
3796: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3800: LD_ADDR_EXP 53
3804: PUSH
3805: LD_INT 1
3807: PPUSH
3808: LD_INT 3
3810: PPUSH
3811: LD_STRING 
3813: PPUSH
3814: LD_INT 7
3816: PUSH
3817: LD_INT 8
3819: PUSH
3820: LD_INT 9
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: PUSH
3828: LD_OWVAR 67
3832: ARRAY
3833: PPUSH
3834: LD_INT 5000
3836: PUSH
3837: LD_INT 1000
3839: PUSH
3840: LD_INT 300
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: PPUSH
3848: LD_INT 22
3850: PUSH
3851: LD_INT 5
3853: PUSH
3854: LD_INT 6
3856: PUSH
3857: LD_INT 9
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: LIST
3864: LIST
3865: PPUSH
3866: CALL 24808 0 6
3870: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3871: LD_ADDR_EXP 59
3875: PUSH
3876: LD_EXP 59
3880: PPUSH
3881: LD_INT 1
3883: PPUSH
3884: LD_EXP 53
3888: PPUSH
3889: CALL_OW 1
3893: ST_TO_ADDR
// tmp := [ ] ;
3894: LD_ADDR_VAR 0 4
3898: PUSH
3899: EMPTY
3900: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3901: LD_ADDR_OWVAR 37
3905: PUSH
3906: LD_INT 14
3908: ST_TO_ADDR
// vc_engine := engine_siberite ;
3909: LD_ADDR_OWVAR 39
3913: PUSH
3914: LD_INT 3
3916: ST_TO_ADDR
// vc_control := control_manual ;
3917: LD_ADDR_OWVAR 38
3921: PUSH
3922: LD_INT 1
3924: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3925: LD_ADDR_OWVAR 40
3929: PUSH
3930: LD_INT 31
3932: ST_TO_ADDR
// for i = 1 to 3 do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: DOUBLE
3939: LD_INT 1
3941: DEC
3942: ST_TO_ADDR
3943: LD_INT 3
3945: PUSH
3946: FOR_TO
3947: IFFALSE 4191
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3949: LD_ADDR_VAR 0 5
3953: PUSH
3954: LD_INT 153
3956: PUSH
3957: LD_INT 71
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PUSH
3964: LD_INT 155
3966: PUSH
3967: LD_INT 81
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PUSH
3978: LD_VAR 0 2
3982: PUSH
3983: LD_INT 2
3985: MOD
3986: PUSH
3987: LD_INT 1
3989: PLUS
3990: ARRAY
3991: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3992: LD_INT 0
3994: PPUSH
3995: LD_INT 3
3997: PPUSH
3998: LD_INT 7
4000: PUSH
4001: LD_INT 8
4003: PUSH
4004: LD_INT 9
4006: PUSH
4007: EMPTY
4008: LIST
4009: LIST
4010: LIST
4011: PUSH
4012: LD_OWVAR 67
4016: ARRAY
4017: PPUSH
4018: CALL_OW 380
// un := CreateVehicle ;
4022: LD_ADDR_VAR 0 6
4026: PUSH
4027: CALL_OW 45
4031: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4032: LD_VAR 0 6
4036: PPUSH
4037: LD_INT 0
4039: PPUSH
4040: LD_INT 5
4042: PPUSH
4043: CALL_OW 12
4047: PPUSH
4048: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4052: LD_VAR 0 6
4056: PPUSH
4057: LD_VAR 0 5
4061: PUSH
4062: LD_INT 1
4064: ARRAY
4065: PPUSH
4066: LD_VAR 0 5
4070: PUSH
4071: LD_INT 2
4073: ARRAY
4074: PPUSH
4075: LD_INT 6
4077: PPUSH
4078: LD_INT 0
4080: PPUSH
4081: CALL_OW 50
// un2 := CreateHuman ;
4085: LD_ADDR_VAR 0 7
4089: PUSH
4090: CALL_OW 44
4094: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4095: LD_VAR 0 7
4099: PPUSH
4100: LD_VAR 0 6
4104: PPUSH
4105: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4109: LD_ADDR_EXP 59
4113: PUSH
4114: LD_EXP 59
4118: PPUSH
4119: LD_INT 1
4121: PUSH
4122: LD_EXP 59
4126: PUSH
4127: LD_INT 1
4129: ARRAY
4130: PUSH
4131: LD_INT 1
4133: PLUS
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: PPUSH
4139: LD_VAR 0 6
4143: PPUSH
4144: CALL 21521 0 3
4148: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4149: LD_ADDR_EXP 59
4153: PUSH
4154: LD_EXP 59
4158: PPUSH
4159: LD_INT 1
4161: PUSH
4162: LD_EXP 59
4166: PUSH
4167: LD_INT 1
4169: ARRAY
4170: PUSH
4171: LD_INT 1
4173: PLUS
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: PPUSH
4179: LD_VAR 0 7
4183: PPUSH
4184: CALL 21521 0 3
4188: ST_TO_ADDR
// end ;
4189: GO 3946
4191: POP
4192: POP
// for i = 1 to 5 do
4193: LD_ADDR_VAR 0 2
4197: PUSH
4198: DOUBLE
4199: LD_INT 1
4201: DEC
4202: ST_TO_ADDR
4203: LD_INT 5
4205: PUSH
4206: FOR_TO
4207: IFFALSE 4300
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4209: LD_INT 14
4211: PPUSH
4212: LD_INT 3
4214: PPUSH
4215: LD_INT 1
4217: PPUSH
4218: LD_INT 25
4220: PUSH
4221: LD_INT 28
4223: PUSH
4224: LD_INT 28
4226: PUSH
4227: LD_INT 26
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: LIST
4235: PUSH
4236: LD_VAR 0 2
4240: PUSH
4241: LD_INT 4
4243: MOD
4244: PUSH
4245: LD_INT 1
4247: PLUS
4248: ARRAY
4249: PPUSH
4250: LD_INT 100
4252: PPUSH
4253: CALL 21399 0 5
// veh := CreateVehicle ;
4257: LD_ADDR_VAR 0 3
4261: PUSH
4262: CALL_OW 45
4266: ST_TO_ADDR
// tmp := tmp ^ veh ;
4267: LD_ADDR_VAR 0 4
4271: PUSH
4272: LD_VAR 0 4
4276: PUSH
4277: LD_VAR 0 3
4281: ADD
4282: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4283: LD_VAR 0 3
4287: PPUSH
4288: LD_INT 1
4290: PPUSH
4291: LD_INT 0
4293: PPUSH
4294: CALL_OW 49
// end ;
4298: GO 4206
4300: POP
4301: POP
// arabian_guard := tmp ;
4302: LD_ADDR_EXP 54
4306: PUSH
4307: LD_VAR 0 4
4311: ST_TO_ADDR
// end ;
4312: LD_VAR 0 1
4316: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4317: LD_INT 22
4319: PUSH
4320: LD_INT 7
4322: PUSH
4323: EMPTY
4324: LIST
4325: LIST
4326: PUSH
4327: LD_INT 91
4329: PUSH
4330: LD_INT 1
4332: PUSH
4333: LD_INT 12
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: PPUSH
4345: CALL_OW 69
4349: PUSH
4350: LD_EXP 56
4354: PPUSH
4355: CALL_OW 256
4359: PUSH
4360: LD_INT 990
4362: LESS
4363: OR
4364: PUSH
4365: LD_EXP 55
4369: PPUSH
4370: CALL_OW 256
4374: PUSH
4375: LD_INT 990
4377: LESS
4378: OR
4379: IFFALSE 4522
4381: GO 4383
4383: DISABLE
// begin if IsInUnit ( Abdul ) then
4384: LD_EXP 55
4388: PPUSH
4389: CALL_OW 310
4393: IFFALSE 4404
// ComExitBuilding ( Abdul ) ;
4395: LD_EXP 55
4399: PPUSH
4400: CALL_OW 122
// if Mastodont then
4404: LD_EXP 56
4408: IFFALSE 4425
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4410: LD_EXP 56
4414: PPUSH
4415: LD_INT 205
4417: PPUSH
4418: LD_INT 132
4420: PPUSH
4421: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4425: LD_EXP 55
4429: PPUSH
4430: LD_INT 205
4432: PPUSH
4433: LD_INT 132
4435: PPUSH
4436: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4440: LD_INT 35
4442: PPUSH
4443: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4447: LD_EXP 55
4451: PPUSH
4452: LD_INT 21
4454: PPUSH
4455: CALL_OW 308
4459: IFFALSE 4440
// RemoveUnit ( Abdul ) ;
4461: LD_EXP 55
4465: PPUSH
4466: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4470: LD_INT 35
4472: PPUSH
4473: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4477: LD_EXP 56
4481: PPUSH
4482: LD_INT 21
4484: PPUSH
4485: CALL_OW 308
4489: PUSH
4490: LD_EXP 56
4494: PPUSH
4495: CALL_OW 301
4499: OR
4500: IFFALSE 4470
// if IsOk ( Mastodont ) then
4502: LD_EXP 56
4506: PPUSH
4507: CALL_OW 302
4511: IFFALSE 4522
// RemoveUnit ( Mastodont ) ;
4513: LD_EXP 56
4517: PPUSH
4518: CALL_OW 64
// end ;
4522: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4523: LD_EXP 55
4527: PPUSH
4528: CALL_OW 301
4532: PUSH
4533: LD_INT 22
4535: PUSH
4536: LD_INT 2
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: PUSH
4543: LD_INT 2
4545: PUSH
4546: LD_INT 25
4548: PUSH
4549: LD_INT 1
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 25
4558: PUSH
4559: LD_INT 2
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 25
4568: PUSH
4569: LD_INT 3
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: LD_INT 25
4578: PUSH
4579: LD_INT 4
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PUSH
4586: LD_INT 25
4588: PUSH
4589: LD_INT 8
4591: PUSH
4592: EMPTY
4593: LIST
4594: LIST
4595: PUSH
4596: EMPTY
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: PPUSH
4608: CALL_OW 69
4612: PUSH
4613: LD_INT 16
4615: PUSH
4616: LD_INT 19
4618: PUSH
4619: LD_INT 22
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: LIST
4626: PUSH
4627: LD_OWVAR 67
4631: ARRAY
4632: LESS
4633: OR
4634: IFFALSE 5307
4636: GO 4638
4638: DISABLE
4639: LD_INT 0
4641: PPUSH
4642: PPUSH
4643: PPUSH
4644: PPUSH
4645: PPUSH
4646: PPUSH
// begin MC_Kill ( 1 ) ;
4647: LD_INT 1
4649: PPUSH
4650: CALL 57707 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4654: LD_ADDR_VAR 0 2
4658: PUSH
4659: LD_INT 22
4661: PUSH
4662: LD_INT 2
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: LD_INT 25
4674: PUSH
4675: LD_INT 1
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: LD_INT 25
4684: PUSH
4685: LD_INT 2
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: PUSH
4692: LD_INT 25
4694: PUSH
4695: LD_INT 3
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PUSH
4702: LD_INT 25
4704: PUSH
4705: LD_INT 4
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: LD_INT 25
4714: PUSH
4715: LD_INT 8
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PPUSH
4734: CALL_OW 69
4738: ST_TO_ADDR
// for i in tmp do
4739: LD_ADDR_VAR 0 5
4743: PUSH
4744: LD_VAR 0 2
4748: PUSH
4749: FOR_IN
4750: IFFALSE 4766
// SetTag ( i , 10 ) ;
4752: LD_VAR 0 5
4756: PPUSH
4757: LD_INT 10
4759: PPUSH
4760: CALL_OW 109
4764: GO 4749
4766: POP
4767: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4768: LD_ADDR_VAR 0 3
4772: PUSH
4773: LD_INT 22
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: LD_INT 21
4785: PUSH
4786: LD_INT 1
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: PPUSH
4797: CALL_OW 69
4801: PUSH
4802: LD_VAR 0 2
4806: DIFF
4807: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4808: LD_ADDR_VAR 0 1
4812: PUSH
4813: LD_INT 22
4815: PUSH
4816: LD_INT 2
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: LD_INT 21
4825: PUSH
4826: LD_INT 2
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: PUSH
4833: LD_INT 24
4835: PUSH
4836: LD_INT 300
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: LIST
4847: PPUSH
4848: CALL_OW 69
4852: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4853: LD_ADDR_VAR 0 4
4857: PUSH
4858: LD_VAR 0 1
4862: PPUSH
4863: LD_INT 33
4865: PUSH
4866: LD_INT 1
4868: PUSH
4869: EMPTY
4870: LIST
4871: LIST
4872: PUSH
4873: LD_INT 58
4875: PUSH
4876: EMPTY
4877: LIST
4878: PUSH
4879: EMPTY
4880: LIST
4881: LIST
4882: PPUSH
4883: CALL_OW 72
4887: ST_TO_ADDR
// for i in tmp do
4888: LD_ADDR_VAR 0 5
4892: PUSH
4893: LD_VAR 0 2
4897: PUSH
4898: FOR_IN
4899: IFFALSE 5083
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4901: LD_VAR 0 5
4905: PUSH
4906: LD_INT 55
4908: PUSH
4909: EMPTY
4910: LIST
4911: PPUSH
4912: CALL_OW 69
4916: IN
4917: IFFALSE 4936
// begin AddComMoveXY ( i , 209 , 132 ) ;
4919: LD_VAR 0 5
4923: PPUSH
4924: LD_INT 209
4926: PPUSH
4927: LD_INT 132
4929: PPUSH
4930: CALL_OW 171
// continue ;
4934: GO 4898
// end ; if IsInUnit ( i ) then
4936: LD_VAR 0 5
4940: PPUSH
4941: CALL_OW 310
4945: IFFALSE 4963
// begin ComExitBuilding ( i ) ;
4947: LD_VAR 0 5
4951: PPUSH
4952: CALL_OW 122
// wait ( 3 ) ;
4956: LD_INT 3
4958: PPUSH
4959: CALL_OW 67
// end ; if tmp_empty then
4963: LD_VAR 0 4
4967: IFFALSE 5066
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4969: LD_VAR 0 5
4973: PPUSH
4974: LD_VAR 0 4
4978: PPUSH
4979: LD_VAR 0 5
4983: PPUSH
4984: CALL_OW 74
4988: PPUSH
4989: CALL_OW 296
4993: PUSH
4994: LD_INT 25
4996: LESS
4997: IFFALSE 5066
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4999: LD_ADDR_VAR 0 6
5003: PUSH
5004: LD_VAR 0 4
5008: PPUSH
5009: LD_VAR 0 5
5013: PPUSH
5014: CALL_OW 74
5018: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5019: LD_VAR 0 5
5023: PPUSH
5024: LD_VAR 0 6
5028: PPUSH
5029: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5033: LD_VAR 0 5
5037: PPUSH
5038: LD_INT 209
5040: PPUSH
5041: LD_INT 132
5043: PPUSH
5044: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5048: LD_ADDR_VAR 0 4
5052: PUSH
5053: LD_VAR 0 4
5057: PUSH
5058: LD_VAR 0 6
5062: DIFF
5063: ST_TO_ADDR
// continue ;
5064: GO 4898
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5066: LD_VAR 0 5
5070: PPUSH
5071: LD_INT 201
5073: PPUSH
5074: LD_INT 132
5076: PPUSH
5077: CALL_OW 171
// end ;
5081: GO 4898
5083: POP
5084: POP
// for i in tmp_ape do
5085: LD_ADDR_VAR 0 5
5089: PUSH
5090: LD_VAR 0 3
5094: PUSH
5095: FOR_IN
5096: IFFALSE 5135
// begin if IsInUnit ( i ) then
5098: LD_VAR 0 5
5102: PPUSH
5103: CALL_OW 310
5107: IFFALSE 5118
// ComExitBuilding ( i ) ;
5109: LD_VAR 0 5
5113: PPUSH
5114: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5118: LD_VAR 0 5
5122: PPUSH
5123: LD_INT 201
5125: PPUSH
5126: LD_INT 132
5128: PPUSH
5129: CALL_OW 171
// end ;
5133: GO 5095
5135: POP
5136: POP
// repeat wait ( 0 0$1 ) ;
5137: LD_INT 35
5139: PPUSH
5140: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5144: LD_ADDR_VAR 0 5
5148: PUSH
5149: LD_VAR 0 2
5153: PUSH
5154: LD_VAR 0 3
5158: UNION
5159: PUSH
5160: LD_VAR 0 1
5164: UNION
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5198
// if not HasTask ( i ) then
5169: LD_VAR 0 5
5173: PPUSH
5174: CALL_OW 314
5178: NOT
5179: IFFALSE 5196
// ComMoveXY ( i , 201 , 132 ) ;
5181: LD_VAR 0 5
5185: PPUSH
5186: LD_INT 201
5188: PPUSH
5189: LD_INT 132
5191: PPUSH
5192: CALL_OW 111
5196: GO 5166
5198: POP
5199: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5200: LD_INT 21
5202: PPUSH
5203: LD_INT 22
5205: PUSH
5206: LD_INT 2
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL_OW 70
5217: IFFALSE 5258
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5219: LD_ADDR_VAR 0 5
5223: PUSH
5224: LD_INT 21
5226: PPUSH
5227: LD_INT 22
5229: PUSH
5230: LD_INT 2
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: PPUSH
5237: CALL_OW 70
5241: PUSH
5242: FOR_IN
5243: IFFALSE 5256
// RemoveUnit ( i ) ;
5245: LD_VAR 0 5
5249: PPUSH
5250: CALL_OW 64
5254: GO 5242
5256: POP
5257: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5258: LD_INT 22
5260: PUSH
5261: LD_INT 2
5263: PUSH
5264: EMPTY
5265: LIST
5266: LIST
5267: PUSH
5268: LD_INT 2
5270: PUSH
5271: LD_INT 21
5273: PUSH
5274: LD_INT 1
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PUSH
5281: LD_INT 21
5283: PUSH
5284: LD_INT 2
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: LIST
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 69
5304: NOT
5305: IFFALSE 5137
// end ;
5307: PPOPN 6
5309: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5310: LD_EXP 9
5314: PUSH
5315: LD_INT 92
5317: PPUSH
5318: LD_INT 40
5320: PPUSH
5321: CALL_OW 428
5325: PPUSH
5326: CALL_OW 266
5330: PUSH
5331: LD_INT 30
5333: EQUAL
5334: AND
5335: IFFALSE 5531
5337: GO 5339
5339: DISABLE
5340: LD_INT 0
5342: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5343: LD_ADDR_VAR 0 1
5347: PUSH
5348: LD_EXP 59
5352: PUSH
5353: LD_INT 1
5355: ARRAY
5356: PPUSH
5357: LD_INT 25
5359: PUSH
5360: LD_INT 4
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PPUSH
5367: CALL_OW 72
5371: ST_TO_ADDR
// if not sci then
5372: LD_VAR 0 1
5376: NOT
5377: IFFALSE 5381
// exit ;
5379: GO 5531
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5381: LD_ADDR_EXP 59
5385: PUSH
5386: LD_EXP 59
5390: PPUSH
5391: LD_INT 1
5393: PPUSH
5394: LD_EXP 59
5398: PUSH
5399: LD_INT 1
5401: ARRAY
5402: PUSH
5403: LD_VAR 0 1
5407: PUSH
5408: LD_INT 1
5410: ARRAY
5411: DIFF
5412: PPUSH
5413: CALL_OW 1
5417: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5418: LD_VAR 0 1
5422: PUSH
5423: LD_INT 1
5425: ARRAY
5426: PPUSH
5427: CALL_OW 310
5431: IFFALSE 5446
// ComExitBuilding ( sci [ 1 ] ) ;
5433: LD_VAR 0 1
5437: PUSH
5438: LD_INT 1
5440: ARRAY
5441: PPUSH
5442: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5446: LD_INT 2
5448: PPUSH
5449: LD_INT 105
5451: PPUSH
5452: LD_INT 14
5454: PPUSH
5455: LD_INT 20
5457: PPUSH
5458: CALL 22417 0 4
5462: PUSH
5463: LD_INT 4
5465: ARRAY
5466: PUSH
5467: LD_INT 10
5469: LESS
5470: IFFALSE 5493
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5472: LD_VAR 0 1
5476: PUSH
5477: LD_INT 1
5479: ARRAY
5480: PPUSH
5481: LD_INT 105
5483: PPUSH
5484: LD_INT 14
5486: PPUSH
5487: CALL_OW 171
5491: GO 5512
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5493: LD_VAR 0 1
5497: PUSH
5498: LD_INT 1
5500: ARRAY
5501: PPUSH
5502: LD_INT 118
5504: PPUSH
5505: LD_INT 77
5507: PPUSH
5508: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5512: LD_VAR 0 1
5516: PUSH
5517: LD_INT 1
5519: ARRAY
5520: PPUSH
5521: LD_INT 92
5523: PPUSH
5524: LD_INT 40
5526: PPUSH
5527: CALL_OW 218
// end ;
5531: PPOPN 1
5533: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5534: LD_INT 1
5536: PPUSH
5537: CALL_OW 302
5541: PUSH
5542: LD_EXP 9
5546: AND
5547: IFFALSE 6006
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
5557: PPUSH
5558: PPUSH
5559: PPUSH
// begin enable ;
5560: ENABLE
// base := 1 ;
5561: LD_ADDR_VAR 0 2
5565: PUSH
5566: LD_INT 1
5568: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5569: LD_ADDR_VAR 0 4
5573: PUSH
5574: LD_INT 0
5576: PUSH
5577: LD_INT 0
5579: PUSH
5580: LD_INT 0
5582: PUSH
5583: LD_INT 0
5585: PUSH
5586: LD_INT 0
5588: PUSH
5589: LD_INT 0
5591: PUSH
5592: LD_INT 0
5594: PUSH
5595: LD_INT 0
5597: PUSH
5598: LD_INT 1
5600: PUSH
5601: LD_INT 0
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: LIST
5614: LIST
5615: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5616: LD_ADDR_VAR 0 3
5620: PUSH
5621: LD_INT 14
5623: PUSH
5624: LD_INT 1
5626: PUSH
5627: LD_INT 2
5629: PUSH
5630: LD_INT 26
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: PUSH
5639: LD_INT 14
5641: PUSH
5642: LD_INT 1
5644: PUSH
5645: LD_INT 2
5647: PUSH
5648: LD_INT 28
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: LD_INT 13
5659: PUSH
5660: LD_INT 1
5662: PUSH
5663: LD_INT 2
5665: PUSH
5666: LD_INT 29
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: LIST
5679: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5680: LD_ADDR_VAR 0 1
5684: PUSH
5685: DOUBLE
5686: LD_INT 1
5688: DEC
5689: ST_TO_ADDR
5690: LD_OWVAR 67
5694: PUSH
5695: LD_OWVAR 1
5699: PUSH
5700: LD_INT 21000
5702: DIV
5703: PLUS
5704: PUSH
5705: FOR_TO
5706: IFFALSE 5798
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5708: LD_ADDR_VAR 0 3
5712: PUSH
5713: LD_VAR 0 3
5717: PPUSH
5718: LD_VAR 0 3
5722: PUSH
5723: LD_INT 1
5725: PLUS
5726: PPUSH
5727: LD_INT 13
5729: PUSH
5730: LD_INT 14
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: PUSH
5737: LD_INT 1
5739: PPUSH
5740: LD_INT 2
5742: PPUSH
5743: CALL_OW 12
5747: ARRAY
5748: PUSH
5749: LD_INT 1
5751: PUSH
5752: LD_INT 2
5754: PUSH
5755: LD_INT 28
5757: PUSH
5758: LD_INT 29
5760: PUSH
5761: LD_INT 25
5763: PUSH
5764: LD_INT 26
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_INT 1
5775: PPUSH
5776: LD_INT 4
5778: PPUSH
5779: CALL_OW 12
5783: ARRAY
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PPUSH
5791: CALL_OW 2
5795: ST_TO_ADDR
5796: GO 5705
5798: POP
5799: POP
// MC_InsertProduceList ( base , tmp ) ;
5800: LD_VAR 0 2
5804: PPUSH
5805: LD_VAR 0 3
5809: PPUSH
5810: CALL 81167 0 2
// repeat wait ( 0 0$1 ) ;
5814: LD_INT 35
5816: PPUSH
5817: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5821: LD_EXP 78
5825: PUSH
5826: LD_VAR 0 2
5830: ARRAY
5831: PUSH
5832: LD_INT 6
5834: GREATER
5835: IFFALSE 5814
// wait ( 0 0$20 ) ;
5837: LD_INT 700
5839: PPUSH
5840: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5844: LD_ADDR_VAR 0 5
5848: PUSH
5849: LD_INT 124
5851: PUSH
5852: LD_INT 85
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: LD_INT 90
5861: PUSH
5862: LD_INT 61
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: PUSH
5869: LD_INT 69
5871: PUSH
5872: LD_INT 48
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: PUSH
5879: LD_INT 68
5881: PUSH
5882: LD_INT 48
5884: PUSH
5885: EMPTY
5886: LIST
5887: LIST
5888: PUSH
5889: EMPTY
5890: LIST
5891: LIST
5892: LIST
5893: LIST
5894: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5895: LD_ADDR_VAR 0 6
5899: PUSH
5900: LD_EXP 78
5904: PUSH
5905: LD_VAR 0 2
5909: ARRAY
5910: PUSH
5911: LD_EXP 78
5915: PUSH
5916: LD_VAR 0 2
5920: ARRAY
5921: PPUSH
5922: LD_INT 34
5924: PUSH
5925: LD_INT 32
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL_OW 72
5936: DIFF
5937: ST_TO_ADDR
// if not attackers then
5938: LD_VAR 0 6
5942: NOT
5943: IFFALSE 5947
// exit ;
5945: GO 6006
// ar_attackers := attackers ;
5947: LD_ADDR_EXP 10
5951: PUSH
5952: LD_VAR 0 6
5956: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5957: LD_INT 35
5959: PPUSH
5960: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5964: LD_VAR 0 6
5968: PPUSH
5969: LD_INT 60
5971: PUSH
5972: EMPTY
5973: LIST
5974: PPUSH
5975: CALL_OW 72
5979: NOT
5980: IFFALSE 5957
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5982: LD_VAR 0 2
5986: PPUSH
5987: LD_VAR 0 6
5991: PPUSH
5992: LD_VAR 0 5
5996: PPUSH
5997: LD_VAR 0 4
6001: PPUSH
6002: CALL 81352 0 4
// end ;
6006: PPOPN 6
6008: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6009: LD_INT 1
6011: PPUSH
6012: CALL_OW 302
6016: PUSH
6017: LD_EXP 9
6021: AND
6022: PUSH
6023: LD_EXP 49
6027: PPUSH
6028: LD_INT 22
6030: PPUSH
6031: CALL_OW 308
6035: AND
6036: PUSH
6037: LD_INT 1
6039: PPUSH
6040: CALL 81515 0 1
6044: PUSH
6045: LD_INT 0
6047: EQUAL
6048: AND
6049: PUSH
6050: LD_EXP 10
6054: NOT
6055: AND
6056: IFFALSE 6520
6058: GO 6060
6060: DISABLE
6061: LD_INT 0
6063: PPUSH
6064: PPUSH
6065: PPUSH
6066: PPUSH
6067: PPUSH
6068: PPUSH
6069: PPUSH
// begin base := 1 ;
6070: LD_ADDR_VAR 0 2
6074: PUSH
6075: LD_INT 1
6077: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6078: LD_ADDR_VAR 0 4
6082: PUSH
6083: LD_INT 0
6085: PUSH
6086: LD_INT 0
6088: PUSH
6089: LD_INT 0
6091: PUSH
6092: LD_INT 0
6094: PUSH
6095: LD_INT 0
6097: PUSH
6098: LD_INT 0
6100: PUSH
6101: LD_INT 0
6103: PUSH
6104: LD_INT 0
6106: PUSH
6107: LD_INT 1
6109: PUSH
6110: LD_INT 0
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6125: LD_ADDR_VAR 0 3
6129: PUSH
6130: LD_INT 13
6132: PUSH
6133: LD_INT 1
6135: PUSH
6136: LD_INT 2
6138: PUSH
6139: LD_INT 28
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 13
6150: PUSH
6151: LD_INT 1
6153: PUSH
6154: LD_INT 2
6156: PUSH
6157: LD_INT 27
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: PUSH
6166: LD_INT 13
6168: PUSH
6169: LD_INT 1
6171: PUSH
6172: LD_INT 2
6174: PUSH
6175: LD_INT 25
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 11
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 2
6192: PUSH
6193: LD_INT 24
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: PUSH
6202: LD_INT 11
6204: PUSH
6205: LD_INT 2
6207: PUSH
6208: LD_INT 2
6210: PUSH
6211: LD_INT 24
6213: PUSH
6214: EMPTY
6215: LIST
6216: LIST
6217: LIST
6218: LIST
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6227: LD_VAR 0 2
6231: PPUSH
6232: LD_VAR 0 3
6236: PPUSH
6237: CALL 81167 0 2
// repeat wait ( 0 0$1 ) ;
6241: LD_INT 35
6243: PPUSH
6244: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6248: LD_EXP 78
6252: PUSH
6253: LD_VAR 0 2
6257: ARRAY
6258: PUSH
6259: LD_INT 6
6261: GREATEREQUAL
6262: IFFALSE 6241
// wait ( 0 0$20 ) ;
6264: LD_INT 700
6266: PPUSH
6267: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6271: LD_ADDR_VAR 0 5
6275: PUSH
6276: LD_INT 119
6278: PUSH
6279: LD_INT 9
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: PUSH
6286: EMPTY
6287: LIST
6288: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6289: LD_ADDR_VAR 0 6
6293: PUSH
6294: LD_EXP 78
6298: PUSH
6299: LD_VAR 0 2
6303: ARRAY
6304: PUSH
6305: LD_EXP 78
6309: PUSH
6310: LD_VAR 0 2
6314: ARRAY
6315: PPUSH
6316: LD_INT 34
6318: PUSH
6319: LD_INT 32
6321: PUSH
6322: EMPTY
6323: LIST
6324: LIST
6325: PPUSH
6326: CALL_OW 72
6330: DIFF
6331: ST_TO_ADDR
// if not attackers then
6332: LD_VAR 0 6
6336: NOT
6337: IFFALSE 6341
// exit ;
6339: GO 6520
// uc_side := 2 ;
6341: LD_ADDR_OWVAR 20
6345: PUSH
6346: LD_INT 2
6348: ST_TO_ADDR
// uc_nation := 2 ;
6349: LD_ADDR_OWVAR 21
6353: PUSH
6354: LD_INT 2
6356: ST_TO_ADDR
// InitHc ;
6357: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6361: LD_ADDR_VAR 0 1
6365: PUSH
6366: DOUBLE
6367: LD_INT 1
6369: DEC
6370: ST_TO_ADDR
6371: LD_INT 4
6373: PUSH
6374: LD_INT 5
6376: PUSH
6377: LD_INT 6
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: LD_OWVAR 67
6389: ARRAY
6390: PUSH
6391: FOR_TO
6392: IFFALSE 6469
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6394: LD_INT 0
6396: PPUSH
6397: LD_INT 15
6399: PUSH
6400: LD_INT 17
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: CALL_OW 12
6417: ARRAY
6418: PPUSH
6419: LD_INT 8
6421: PPUSH
6422: CALL_OW 380
// un := CreateHuman ;
6426: LD_ADDR_VAR 0 7
6430: PUSH
6431: CALL_OW 44
6435: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6436: LD_VAR 0 7
6440: PPUSH
6441: LD_INT 23
6443: PPUSH
6444: LD_INT 0
6446: PPUSH
6447: CALL_OW 49
// attackers := attackers union un ;
6451: LD_ADDR_VAR 0 6
6455: PUSH
6456: LD_VAR 0 6
6460: PUSH
6461: LD_VAR 0 7
6465: UNION
6466: ST_TO_ADDR
// end ;
6467: GO 6391
6469: POP
6470: POP
// repeat wait ( 0 0$1 ) ;
6471: LD_INT 35
6473: PPUSH
6474: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6478: LD_VAR 0 6
6482: PPUSH
6483: LD_INT 60
6485: PUSH
6486: EMPTY
6487: LIST
6488: PPUSH
6489: CALL_OW 72
6493: NOT
6494: IFFALSE 6471
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6496: LD_VAR 0 2
6500: PPUSH
6501: LD_VAR 0 6
6505: PPUSH
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 4
6515: PPUSH
6516: CALL 81352 0 4
// end ; end_of_file
6520: PPOPN 7
6522: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6523: LD_INT 0
6525: PPUSH
6526: PPUSH
6527: PPUSH
6528: PPUSH
// uc_side := 1 ;
6529: LD_ADDR_OWVAR 20
6533: PUSH
6534: LD_INT 1
6536: ST_TO_ADDR
// uc_nation := 1 ;
6537: LD_ADDR_OWVAR 21
6541: PUSH
6542: LD_INT 1
6544: ST_TO_ADDR
// InitHc ;
6545: CALL_OW 19
// InitVc ;
6549: CALL_OW 20
// tmp := [ ] ;
6553: LD_ADDR_VAR 0 3
6557: PUSH
6558: EMPTY
6559: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6560: LD_ADDR_VAR 0 2
6564: PUSH
6565: DOUBLE
6566: LD_INT 1
6568: DEC
6569: ST_TO_ADDR
6570: LD_INT 5
6572: PUSH
6573: LD_INT 6
6575: PUSH
6576: LD_INT 6
6578: PUSH
6579: EMPTY
6580: LIST
6581: LIST
6582: LIST
6583: PUSH
6584: LD_OWVAR 67
6588: ARRAY
6589: PUSH
6590: FOR_TO
6591: IFFALSE 6728
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6593: LD_INT 2
6595: PUSH
6596: LD_INT 4
6598: PUSH
6599: LD_INT 5
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: LIST
6606: PUSH
6607: LD_INT 1
6609: PPUSH
6610: LD_INT 3
6612: PPUSH
6613: CALL_OW 12
6617: ARRAY
6618: PPUSH
6619: LD_INT 1
6621: PUSH
6622: LD_INT 3
6624: PUSH
6625: EMPTY
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 1
6631: PPUSH
6632: LD_INT 2
6634: PPUSH
6635: CALL_OW 12
6639: ARRAY
6640: PPUSH
6641: LD_INT 3
6643: PPUSH
6644: LD_INT 9
6646: PUSH
6647: LD_INT 7
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 1
6656: PPUSH
6657: LD_INT 2
6659: PPUSH
6660: CALL_OW 12
6664: ARRAY
6665: PPUSH
6666: LD_INT 78
6668: PPUSH
6669: CALL 21399 0 5
// veh := CreateVehicle ;
6673: LD_ADDR_VAR 0 4
6677: PUSH
6678: CALL_OW 45
6682: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6683: LD_VAR 0 4
6687: PPUSH
6688: LD_INT 2
6690: PPUSH
6691: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6695: LD_VAR 0 4
6699: PPUSH
6700: LD_INT 17
6702: PPUSH
6703: LD_INT 0
6705: PPUSH
6706: CALL_OW 49
// tmp := tmp ^ veh ;
6710: LD_ADDR_VAR 0 3
6714: PUSH
6715: LD_VAR 0 3
6719: PUSH
6720: LD_VAR 0 4
6724: ADD
6725: ST_TO_ADDR
// end ;
6726: GO 6590
6728: POP
6729: POP
// if not tmp then
6730: LD_VAR 0 3
6734: NOT
6735: IFFALSE 6739
// exit ;
6737: GO 6848
// if not first_powell_attack then
6739: LD_EXP 11
6743: NOT
6744: IFFALSE 6754
// first_powell_attack := true ;
6746: LD_ADDR_EXP 11
6750: PUSH
6751: LD_INT 1
6753: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6754: LD_INT 70
6756: PPUSH
6757: CALL_OW 67
// for i in tmp do
6761: LD_ADDR_VAR 0 2
6765: PUSH
6766: LD_VAR 0 3
6770: PUSH
6771: FOR_IN
6772: IFFALSE 6839
// if IsOk ( i ) then
6774: LD_VAR 0 2
6778: PPUSH
6779: CALL_OW 302
6783: IFFALSE 6821
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6785: LD_VAR 0 2
6789: PPUSH
6790: LD_INT 81
6792: PUSH
6793: LD_INT 1
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: PPUSH
6800: CALL_OW 69
6804: PPUSH
6805: LD_VAR 0 2
6809: PPUSH
6810: CALL_OW 74
6814: PPUSH
6815: CALL_OW 115
6819: GO 6837
// tmp := tmp diff i ;
6821: LD_ADDR_VAR 0 3
6825: PUSH
6826: LD_VAR 0 3
6830: PUSH
6831: LD_VAR 0 2
6835: DIFF
6836: ST_TO_ADDR
6837: GO 6771
6839: POP
6840: POP
// until not tmp ;
6841: LD_VAR 0 3
6845: NOT
6846: IFFALSE 6754
// end ; end_of_file
6848: LD_VAR 0 1
6852: RET
// export function Action ; var tmp , i , un ; begin
6853: LD_INT 0
6855: PPUSH
6856: PPUSH
6857: PPUSH
6858: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6859: LD_INT 68
6861: PPUSH
6862: LD_INT 39
6864: PPUSH
6865: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6869: LD_ADDR_VAR 0 2
6873: PUSH
6874: LD_INT 22
6876: PUSH
6877: LD_INT 7
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: PPUSH
6884: CALL_OW 69
6888: ST_TO_ADDR
// InGameOn ;
6889: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6893: LD_VAR 0 2
6897: PPUSH
6898: LD_INT 71
6900: PPUSH
6901: LD_INT 49
6903: PPUSH
6904: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6908: LD_INT 35
6910: PPUSH
6911: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6915: LD_INT 7
6917: PPUSH
6918: LD_INT 71
6920: PPUSH
6921: LD_INT 51
6923: PPUSH
6924: CALL_OW 293
6928: IFFALSE 6908
// DialogueOn ;
6930: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6934: LD_EXP 15
6938: PPUSH
6939: LD_STRING D1-JMM-1
6941: PPUSH
6942: CALL_OW 88
// if Joan then
6946: LD_EXP 30
6950: IFFALSE 6964
// Say ( Joan , D1-Joan-1 ) ;
6952: LD_EXP 30
6956: PPUSH
6957: LD_STRING D1-Joan-1
6959: PPUSH
6960: CALL_OW 88
// if Lisa then
6964: LD_EXP 17
6968: IFFALSE 6982
// Say ( Lisa , D1-Lisa-1 ) ;
6970: LD_EXP 17
6974: PPUSH
6975: LD_STRING D1-Lisa-1
6977: PPUSH
6978: CALL_OW 88
// if Joan or Lisa then
6982: LD_EXP 30
6986: PUSH
6987: LD_EXP 17
6991: OR
6992: IFFALSE 7006
// Say ( JMM , D1-JMM-2 ) ;
6994: LD_EXP 15
6998: PPUSH
6999: LD_STRING D1-JMM-2
7001: PPUSH
7002: CALL_OW 88
// DialogueOff ;
7006: CALL_OW 7
// InGameOff ;
7010: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7014: LD_INT 71
7016: PPUSH
7017: LD_INT 50
7019: PPUSH
7020: LD_INT 7
7022: PPUSH
7023: LD_INT 30
7025: NEG
7026: PPUSH
7027: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7031: LD_INT 71
7033: PPUSH
7034: LD_INT 50
7036: PPUSH
7037: LD_INT 7
7039: PPUSH
7040: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7044: LD_STRING M1
7046: PPUSH
7047: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7051: LD_INT 35
7053: PPUSH
7054: CALL_OW 67
// until freedom ;
7058: LD_EXP 3
7062: IFFALSE 7051
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7064: LD_INT 350
7066: PPUSH
7067: LD_INT 700
7069: PPUSH
7070: CALL_OW 12
7074: PPUSH
7075: CALL_OW 67
// PrepareGossudarov ;
7079: CALL 1802 0 0
// repeat wait ( 0 0$1 ) ;
7083: LD_INT 35
7085: PPUSH
7086: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7090: LD_INT 22
7092: PUSH
7093: LD_INT 6
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 24
7105: PUSH
7106: LD_INT 1000
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: PPUSH
7121: CALL_OW 69
7125: PUSH
7126: LD_INT 7
7128: PPUSH
7129: LD_EXP 32
7133: PPUSH
7134: CALL_OW 292
7138: OR
7139: IFFALSE 7083
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7141: LD_ADDR_VAR 0 2
7145: PUSH
7146: LD_INT 22
7148: PUSH
7149: LD_INT 6
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PPUSH
7156: CALL_OW 69
7160: ST_TO_ADDR
// for i in tmp do
7161: LD_ADDR_VAR 0 3
7165: PUSH
7166: LD_VAR 0 2
7170: PUSH
7171: FOR_IN
7172: IFFALSE 7188
// SetSide ( i , 7 ) ;
7174: LD_VAR 0 3
7178: PPUSH
7179: LD_INT 7
7181: PPUSH
7182: CALL_OW 235
7186: GO 7171
7188: POP
7189: POP
// DialogueOn ;
7190: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7194: LD_EXP 15
7198: PUSH
7199: LD_EXP 16
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: PPUSH
7208: LD_EXP 32
7212: PPUSH
7213: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7217: LD_EXP 32
7221: PPUSH
7222: CALL_OW 87
// if not Roth then
7226: LD_EXP 16
7230: NOT
7231: IFFALSE 7323
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7233: LD_VAR 0 2
7237: PPUSH
7238: LD_INT 3
7240: PUSH
7241: LD_INT 24
7243: PUSH
7244: LD_INT 1000
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PPUSH
7255: CALL_OW 72
7259: IFFALSE 7273
// Say ( JMM , D2-JMM-1 ) ;
7261: LD_EXP 15
7265: PPUSH
7266: LD_STRING D2-JMM-1
7268: PPUSH
7269: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7273: LD_EXP 15
7277: PPUSH
7278: LD_STRING D2-JMM-1b
7280: PPUSH
7281: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7285: LD_EXP 32
7289: PPUSH
7290: LD_STRING D2-Gos-1
7292: PPUSH
7293: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7297: LD_EXP 15
7301: PPUSH
7302: LD_STRING D2-JMM-2
7304: PPUSH
7305: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7309: LD_EXP 32
7313: PPUSH
7314: LD_STRING D2-Gos-2
7316: PPUSH
7317: CALL_OW 88
// end else
7321: GO 7475
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7323: LD_VAR 0 2
7327: PPUSH
7328: LD_INT 3
7330: PUSH
7331: LD_INT 24
7333: PUSH
7334: LD_INT 1000
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL_OW 72
7349: IFFALSE 7375
// begin Say ( Roth , D2-Roth-2 ) ;
7351: LD_EXP 16
7355: PPUSH
7356: LD_STRING D2-Roth-2
7358: PPUSH
7359: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7363: LD_EXP 15
7367: PPUSH
7368: LD_STRING D2-JMM-1a
7370: PPUSH
7371: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7375: LD_EXP 16
7379: PPUSH
7380: LD_STRING D2-Roth-2a
7382: PPUSH
7383: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7387: LD_EXP 16
7391: PPUSH
7392: LD_STRING D2-Roth-2b
7394: PPUSH
7395: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7399: LD_EXP 15
7403: PPUSH
7404: LD_STRING D2-JMM-3
7406: PPUSH
7407: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7411: LD_VAR 0 2
7415: PPUSH
7416: LD_INT 3
7418: PUSH
7419: LD_INT 24
7421: PUSH
7422: LD_INT 1000
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: PPUSH
7433: CALL_OW 72
7437: IFFALSE 7475
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7439: LD_EXP 32
7443: PPUSH
7444: LD_STRING D2-Gos-3
7446: PPUSH
7447: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7451: LD_EXP 15
7455: PPUSH
7456: LD_STRING D2-JMM-4
7458: PPUSH
7459: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7463: LD_EXP 32
7467: PPUSH
7468: LD_STRING D2-Gos-4
7470: PPUSH
7471: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7475: LD_EXP 15
7479: PPUSH
7480: LD_STRING D2-JMM-5
7482: PPUSH
7483: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7487: LD_EXP 32
7491: PPUSH
7492: LD_STRING D2-Gos-5
7494: PPUSH
7495: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7499: LD_EXP 15
7503: PPUSH
7504: LD_STRING D2-JMM-6
7506: PPUSH
7507: CALL_OW 88
// DialogueOff ;
7511: CALL_OW 7
// wait ( 0 0$2 ) ;
7515: LD_INT 70
7517: PPUSH
7518: CALL_OW 67
// if Kirilenkova then
7522: LD_EXP 33
7526: IFFALSE 7540
// Say ( Kirilenkova , D3-Kir-1 ) ;
7528: LD_EXP 33
7532: PPUSH
7533: LD_STRING D3-Kir-1
7535: PPUSH
7536: CALL_OW 88
// gossudarov_arrive := true ;
7540: LD_ADDR_EXP 4
7544: PUSH
7545: LD_INT 1
7547: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7548: LD_INT 35
7550: PPUSH
7551: CALL_OW 67
// until ru_lab_builded ;
7555: LD_EXP 5
7559: IFFALSE 7548
// if Kirilenkova then
7561: LD_EXP 33
7565: IFFALSE 7581
// Say ( Kirilenkova , D3a-Kir-1 ) else
7567: LD_EXP 33
7571: PPUSH
7572: LD_STRING D3a-Kir-1
7574: PPUSH
7575: CALL_OW 88
7579: GO 7603
// begin un := SciRu ;
7581: LD_ADDR_VAR 0 4
7585: PUSH
7586: CALL 12711 0 0
7590: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7591: LD_VAR 0 4
7595: PPUSH
7596: LD_STRING D3a-Sci1-1
7598: PPUSH
7599: CALL_OW 88
// end ; if Kirilenkova or un then
7603: LD_EXP 33
7607: PUSH
7608: LD_VAR 0 4
7612: OR
7613: IFFALSE 7627
// Say ( JMM , D3a-JMM-1 ) ;
7615: LD_EXP 15
7619: PPUSH
7620: LD_STRING D3a-JMM-1
7622: PPUSH
7623: CALL_OW 88
// end ;
7627: LD_VAR 0 1
7631: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7632: LD_EXP 4
7636: PUSH
7637: LD_INT 22
7639: PUSH
7640: LD_INT 7
7642: PUSH
7643: EMPTY
7644: LIST
7645: LIST
7646: PUSH
7647: LD_INT 2
7649: PUSH
7650: LD_INT 25
7652: PUSH
7653: LD_INT 1
7655: PUSH
7656: EMPTY
7657: LIST
7658: LIST
7659: PUSH
7660: LD_INT 25
7662: PUSH
7663: LD_INT 2
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: PUSH
7670: LD_INT 25
7672: PUSH
7673: LD_INT 3
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: PUSH
7680: LD_INT 25
7682: PUSH
7683: LD_INT 4
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: PUSH
7690: LD_INT 25
7692: PUSH
7693: LD_INT 5
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PUSH
7700: LD_INT 25
7702: PUSH
7703: LD_INT 8
7705: PUSH
7706: EMPTY
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 25
7712: PUSH
7713: LD_INT 9
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: LIST
7724: LIST
7725: LIST
7726: LIST
7727: LIST
7728: LIST
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PPUSH
7734: CALL_OW 69
7738: PUSH
7739: LD_INT 7
7741: LESS
7742: AND
7743: IFFALSE 7755
7745: GO 7747
7747: DISABLE
// YouLost ( TooMany ) ;
7748: LD_STRING TooMany
7750: PPUSH
7751: CALL_OW 104
7755: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7756: LD_EXP 32
7760: PPUSH
7761: CALL_OW 255
7765: PUSH
7766: LD_INT 7
7768: EQUAL
7769: IFFALSE 7969
7771: GO 7773
7773: DISABLE
7774: LD_INT 0
7776: PPUSH
7777: PPUSH
7778: PPUSH
// begin uc_side := 3 ;
7779: LD_ADDR_OWVAR 20
7783: PUSH
7784: LD_INT 3
7786: ST_TO_ADDR
// uc_nation := 3 ;
7787: LD_ADDR_OWVAR 21
7791: PUSH
7792: LD_INT 3
7794: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7795: LD_INT 21
7797: PPUSH
7798: LD_INT 3
7800: PPUSH
7801: LD_INT 3
7803: PPUSH
7804: LD_INT 42
7806: PPUSH
7807: LD_INT 100
7809: PPUSH
7810: CALL 21399 0 5
// un := CreateVehicle ;
7814: LD_ADDR_VAR 0 3
7818: PUSH
7819: CALL_OW 45
7823: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7824: LD_VAR 0 3
7828: PPUSH
7829: LD_INT 15
7831: PPUSH
7832: LD_INT 0
7834: PPUSH
7835: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7839: LD_VAR 0 3
7843: PPUSH
7844: LD_INT 67
7846: PPUSH
7847: LD_INT 45
7849: PPUSH
7850: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7854: LD_VAR 0 3
7858: PPUSH
7859: LD_INT 70
7861: PPUSH
7862: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7866: LD_VAR 0 3
7870: PPUSH
7871: LD_INT 69
7873: PPUSH
7874: LD_INT 18
7876: PPUSH
7877: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7881: LD_VAR 0 3
7885: PPUSH
7886: LD_INT 60
7888: PPUSH
7889: LD_INT 2
7891: PPUSH
7892: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7896: LD_INT 35
7898: PPUSH
7899: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7903: LD_VAR 0 3
7907: PPUSH
7908: CALL_OW 302
7912: NOT
7913: PUSH
7914: LD_VAR 0 3
7918: PPUSH
7919: LD_INT 17
7921: PPUSH
7922: CALL_OW 308
7926: OR
7927: IFFALSE 7896
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7929: LD_VAR 0 3
7933: PPUSH
7934: LD_INT 17
7936: PPUSH
7937: CALL_OW 308
7941: PUSH
7942: LD_VAR 0 3
7946: PPUSH
7947: LD_INT 60
7949: PPUSH
7950: LD_INT 2
7952: PPUSH
7953: CALL_OW 307
7957: OR
7958: IFFALSE 7969
// RemoveUnit ( un ) ;
7960: LD_VAR 0 3
7964: PPUSH
7965: CALL_OW 64
// end ;
7969: PPOPN 3
7971: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
7972: LD_EXP 4
7976: IFFALSE 8218
7978: GO 7980
7980: DISABLE
7981: LD_INT 0
7983: PPUSH
7984: PPUSH
7985: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7986: LD_INT 70
7988: PPUSH
7989: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7993: LD_ADDR_VAR 0 3
7997: PUSH
7998: LD_INT 22
8000: PUSH
8001: LD_INT 7
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PUSH
8008: LD_INT 101
8010: PUSH
8011: LD_INT 3
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: PUSH
8018: EMPTY
8019: LIST
8020: LIST
8021: PPUSH
8022: CALL_OW 69
8026: ST_TO_ADDR
// until tmp ;
8027: LD_VAR 0 3
8031: IFFALSE 7986
// un := NearestUnitToUnit ( tmp , JMM ) ;
8033: LD_ADDR_VAR 0 2
8037: PUSH
8038: LD_VAR 0 3
8042: PPUSH
8043: LD_EXP 15
8047: PPUSH
8048: CALL_OW 74
8052: ST_TO_ADDR
// player_spotted := true ;
8053: LD_ADDR_EXP 6
8057: PUSH
8058: LD_INT 1
8060: ST_TO_ADDR
// tmp := SciRu ;
8061: LD_ADDR_VAR 0 3
8065: PUSH
8066: CALL 12711 0 0
8070: ST_TO_ADDR
// if not tmp then
8071: LD_VAR 0 3
8075: NOT
8076: IFFALSE 8088
// tmp := SolRu ;
8078: LD_ADDR_VAR 0 3
8082: PUSH
8083: CALL 12858 0 0
8087: ST_TO_ADDR
// DialogueOn ;
8088: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8092: LD_VAR 0 2
8096: PPUSH
8097: CALL_OW 250
8101: PPUSH
8102: LD_VAR 0 2
8106: PPUSH
8107: CALL_OW 251
8111: PPUSH
8112: LD_INT 7
8114: PPUSH
8115: LD_INT 8
8117: NEG
8118: PPUSH
8119: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8123: LD_VAR 0 2
8127: PPUSH
8128: CALL_OW 87
// if tmp then
8132: LD_VAR 0 3
8136: IFFALSE 8150
// Say ( tmp , D4-RSci1-1 ) ;
8138: LD_VAR 0 3
8142: PPUSH
8143: LD_STRING D4-RSci1-1
8145: PPUSH
8146: CALL_OW 88
// if Gossudarov then
8150: LD_EXP 32
8154: IFFALSE 8180
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8156: LD_EXP 32
8160: PPUSH
8161: LD_STRING D4-Gos-1
8163: PPUSH
8164: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8168: LD_EXP 15
8172: PPUSH
8173: LD_STRING D4-JMM-1
8175: PPUSH
8176: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8180: LD_VAR 0 2
8184: PPUSH
8185: CALL_OW 250
8189: PPUSH
8190: LD_VAR 0 2
8194: PPUSH
8195: CALL_OW 251
8199: PPUSH
8200: LD_INT 7
8202: PPUSH
8203: CALL_OW 331
// DialogueOff ;
8207: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8211: LD_STRING M5
8213: PPUSH
8214: CALL_OW 337
// end ;
8218: PPOPN 3
8220: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8221: LD_EXP 6
8225: IFFALSE 8814
8227: GO 8229
8229: DISABLE
8230: LD_INT 0
8232: PPUSH
8233: PPUSH
8234: PPUSH
// begin PrepareBelkov ;
8235: CALL 2092 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8239: LD_EXP 47
8243: PPUSH
8244: LD_INT 118
8246: PPUSH
8247: LD_INT 106
8249: PPUSH
8250: CALL_OW 111
// AddComHold ( Belkov ) ;
8254: LD_EXP 47
8258: PPUSH
8259: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8263: LD_INT 35
8265: PPUSH
8266: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8270: LD_EXP 47
8274: PPUSH
8275: LD_INT 118
8277: PPUSH
8278: LD_INT 106
8280: PPUSH
8281: CALL_OW 307
8285: IFFALSE 8263
// ChangeSideFog ( 4 , 7 ) ;
8287: LD_INT 4
8289: PPUSH
8290: LD_INT 7
8292: PPUSH
8293: CALL_OW 343
// if IsOk ( Belkov ) then
8297: LD_EXP 47
8301: PPUSH
8302: CALL_OW 302
8306: IFFALSE 8390
// begin InGameOn ;
8308: CALL_OW 8
// DialogueOn ;
8312: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8316: LD_EXP 47
8320: PPUSH
8321: LD_STRING D5-Bel-1
8323: PPUSH
8324: CALL_OW 94
// if Gossudarov then
8328: LD_EXP 32
8332: IFFALSE 8382
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8334: LD_EXP 32
8338: PPUSH
8339: LD_STRING D5-Gos-1
8341: PPUSH
8342: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8346: LD_EXP 15
8350: PPUSH
8351: LD_STRING D5-JMM-1
8353: PPUSH
8354: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8358: LD_EXP 32
8362: PPUSH
8363: LD_STRING D5-Gos-2
8365: PPUSH
8366: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8370: LD_EXP 15
8374: PPUSH
8375: LD_STRING D5-JMM-2
8377: PPUSH
8378: CALL_OW 88
// end ; DialogueOff ;
8382: CALL_OW 7
// InGameOff ;
8386: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8390: LD_STRING QSaveBelkov
8392: PPUSH
8393: CALL_OW 97
8397: PUSH
8398: LD_INT 1
8400: DOUBLE
8401: EQUAL
8402: IFTRUE 8406
8404: GO 8456
8406: POP
// begin DialogueOn ;
8407: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8411: LD_EXP 15
8415: PPUSH
8416: LD_STRING D5a-JMM-1
8418: PPUSH
8419: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8423: LD_EXP 47
8427: PPUSH
8428: LD_STRING D5a-Bel-1
8430: PPUSH
8431: CALL_OW 94
// DialogueOff ;
8435: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8439: LD_EXP 47
8443: PPUSH
8444: LD_INT 83
8446: PPUSH
8447: LD_INT 49
8449: PPUSH
8450: CALL_OW 111
// end ; 2 :
8454: GO 8489
8456: LD_INT 2
8458: DOUBLE
8459: EQUAL
8460: IFTRUE 8464
8462: GO 8488
8464: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8465: LD_EXP 15
8469: PPUSH
8470: LD_STRING D5a-JMM-2
8472: PPUSH
8473: CALL_OW 88
// ComHold ( Belkov ) ;
8477: LD_EXP 47
8481: PPUSH
8482: CALL_OW 140
// end ; end ;
8486: GO 8489
8488: POP
// time := 0 0$00 ;
8489: LD_ADDR_VAR 0 1
8493: PUSH
8494: LD_INT 0
8496: ST_TO_ADDR
// vehSpawned := false ;
8497: LD_ADDR_VAR 0 3
8501: PUSH
8502: LD_INT 0
8504: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8505: LD_INT 35
8507: PPUSH
8508: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8512: LD_VAR 0 1
8516: PUSH
8517: LD_INT 350
8519: PUSH
8520: LD_INT 175
8522: PUSH
8523: LD_INT 70
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: LIST
8530: PUSH
8531: LD_OWVAR 67
8535: ARRAY
8536: GREATEREQUAL
8537: PUSH
8538: LD_VAR 0 3
8542: NOT
8543: AND
8544: IFFALSE 8634
// begin vehSpawned := true ;
8546: LD_ADDR_VAR 0 3
8550: PUSH
8551: LD_INT 1
8553: ST_TO_ADDR
// uc_side := 3 ;
8554: LD_ADDR_OWVAR 20
8558: PUSH
8559: LD_INT 3
8561: ST_TO_ADDR
// uc_nation := 3 ;
8562: LD_ADDR_OWVAR 21
8566: PUSH
8567: LD_INT 3
8569: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8570: LD_INT 22
8572: PPUSH
8573: LD_INT 3
8575: PPUSH
8576: LD_INT 3
8578: PPUSH
8579: LD_INT 43
8581: PPUSH
8582: LD_INT 100
8584: PPUSH
8585: CALL 21399 0 5
// veh := CreateVehicle ;
8589: LD_ADDR_VAR 0 2
8593: PUSH
8594: CALL_OW 45
8598: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8599: LD_VAR 0 2
8603: PPUSH
8604: LD_INT 130
8606: PPUSH
8607: LD_INT 131
8609: PPUSH
8610: LD_INT 0
8612: PPUSH
8613: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8617: LD_VAR 0 2
8621: PPUSH
8622: LD_INT 100
8624: PPUSH
8625: LD_INT 82
8627: PPUSH
8628: CALL_OW 114
// end else
8632: GO 8648
// time := time + 0 0$1 ;
8634: LD_ADDR_VAR 0 1
8638: PUSH
8639: LD_VAR 0 1
8643: PUSH
8644: LD_INT 35
8646: PLUS
8647: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8648: LD_EXP 47
8652: PPUSH
8653: CALL_OW 301
8657: PUSH
8658: LD_EXP 47
8662: PPUSH
8663: CALL_OW 255
8667: PUSH
8668: LD_INT 4
8670: EQUAL
8671: AND
8672: PUSH
8673: LD_INT 22
8675: PUSH
8676: LD_INT 7
8678: PUSH
8679: EMPTY
8680: LIST
8681: LIST
8682: PPUSH
8683: CALL_OW 69
8687: PPUSH
8688: LD_EXP 47
8692: PPUSH
8693: CALL_OW 74
8697: PPUSH
8698: LD_EXP 47
8702: PPUSH
8703: CALL_OW 296
8707: PUSH
8708: LD_INT 10
8710: LESS
8711: OR
8712: IFFALSE 8505
// if IsDead ( Belkov ) then
8714: LD_EXP 47
8718: PPUSH
8719: CALL_OW 301
8723: IFFALSE 8748
// begin CenterNowOnUnits ( Belkov ) ;
8725: LD_EXP 47
8729: PPUSH
8730: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8734: LD_EXP 15
8738: PPUSH
8739: LD_STRING D5a-JMM-2a
8741: PPUSH
8742: CALL_OW 88
// exit ;
8746: GO 8814
// end ; if See ( 7 , Belkov ) then
8748: LD_INT 7
8750: PPUSH
8751: LD_EXP 47
8755: PPUSH
8756: CALL_OW 292
8760: IFFALSE 8774
// SetSide ( Belkov , 7 ) ;
8762: LD_EXP 47
8766: PPUSH
8767: LD_INT 7
8769: PPUSH
8770: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8774: LD_INT 35
8776: PPUSH
8777: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8781: LD_EXP 47
8785: PPUSH
8786: LD_INT 66
8788: PPUSH
8789: LD_INT 45
8791: PPUSH
8792: CALL_OW 297
8796: PUSH
8797: LD_INT 30
8799: LESS
8800: IFFALSE 8774
// Say ( Belkov , D6-Bel-1 ) ;
8802: LD_EXP 47
8806: PPUSH
8807: LD_STRING D6-Bel-1
8809: PPUSH
8810: CALL_OW 88
// end ;
8814: PPOPN 3
8816: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8817: LD_EXP 47
8821: PPUSH
8822: CALL_OW 302
8826: PUSH
8827: LD_EXP 47
8831: PPUSH
8832: CALL_OW 504
8836: PUSH
8837: LD_INT 2
8839: PUSH
8840: LD_INT 34
8842: PUSH
8843: LD_INT 47
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: PUSH
8850: LD_INT 34
8852: PUSH
8853: LD_INT 45
8855: PUSH
8856: EMPTY
8857: LIST
8858: LIST
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: LIST
8864: PPUSH
8865: CALL_OW 69
8869: IN
8870: AND
8871: IFFALSE 8888
8873: GO 8875
8875: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8876: LD_EXP 47
8880: PPUSH
8881: LD_STRING D7-Bel-1
8883: PPUSH
8884: CALL_OW 88
8888: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8889: LD_INT 22
8891: PUSH
8892: LD_INT 7
8894: PUSH
8895: EMPTY
8896: LIST
8897: LIST
8898: PUSH
8899: LD_INT 101
8901: PUSH
8902: LD_INT 2
8904: PUSH
8905: EMPTY
8906: LIST
8907: LIST
8908: PUSH
8909: EMPTY
8910: LIST
8911: LIST
8912: PPUSH
8913: CALL_OW 69
8917: PUSH
8918: LD_EXP 8
8922: NOT
8923: AND
8924: PUSH
8925: LD_EXP 46
8929: PPUSH
8930: CALL_OW 305
8934: NOT
8935: AND
8936: IFFALSE 9406
8938: GO 8940
8940: DISABLE
8941: LD_INT 0
8943: PPUSH
// begin ar_base_spotted := true ;
8944: LD_ADDR_EXP 8
8948: PUSH
8949: LD_INT 1
8951: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8952: LD_ADDR_VAR 0 1
8956: PUSH
8957: LD_INT 22
8959: PUSH
8960: LD_INT 2
8962: PUSH
8963: EMPTY
8964: LIST
8965: LIST
8966: PUSH
8967: LD_INT 21
8969: PUSH
8970: LD_INT 3
8972: PUSH
8973: EMPTY
8974: LIST
8975: LIST
8976: PUSH
8977: EMPTY
8978: LIST
8979: LIST
8980: PPUSH
8981: CALL_OW 69
8985: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8986: LD_ADDR_VAR 0 1
8990: PUSH
8991: LD_VAR 0 1
8995: PPUSH
8996: LD_EXP 15
9000: PPUSH
9001: CALL_OW 74
9005: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9006: LD_INT 7
9008: PPUSH
9009: LD_INT 3
9011: PPUSH
9012: CALL_OW 332
// DialogueOn ;
9016: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9020: LD_VAR 0 1
9024: PPUSH
9025: CALL_OW 250
9029: PPUSH
9030: LD_VAR 0 1
9034: PPUSH
9035: CALL_OW 251
9039: PPUSH
9040: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9044: LD_ADDR_VAR 0 1
9048: PUSH
9049: LD_INT 22
9051: PUSH
9052: LD_INT 7
9054: PUSH
9055: EMPTY
9056: LIST
9057: LIST
9058: PUSH
9059: LD_INT 23
9061: PUSH
9062: LD_INT 1
9064: PUSH
9065: EMPTY
9066: LIST
9067: LIST
9068: PUSH
9069: LD_INT 26
9071: PUSH
9072: LD_INT 1
9074: PUSH
9075: EMPTY
9076: LIST
9077: LIST
9078: PUSH
9079: EMPTY
9080: LIST
9081: LIST
9082: LIST
9083: PPUSH
9084: CALL_OW 69
9088: PUSH
9089: LD_EXP 15
9093: PUSH
9094: LD_EXP 19
9098: PUSH
9099: LD_EXP 20
9103: PUSH
9104: LD_EXP 27
9108: PUSH
9109: LD_EXP 16
9113: PUSH
9114: LD_EXP 25
9118: PUSH
9119: LD_EXP 21
9123: PUSH
9124: LD_EXP 23
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: LIST
9133: LIST
9134: LIST
9135: LIST
9136: LIST
9137: LIST
9138: DIFF
9139: ST_TO_ADDR
// if not tmp then
9140: LD_VAR 0 1
9144: NOT
9145: IFFALSE 9219
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9147: LD_ADDR_VAR 0 1
9151: PUSH
9152: LD_INT 22
9154: PUSH
9155: LD_INT 7
9157: PUSH
9158: EMPTY
9159: LIST
9160: LIST
9161: PUSH
9162: LD_INT 23
9164: PUSH
9165: LD_INT 1
9167: PUSH
9168: EMPTY
9169: LIST
9170: LIST
9171: PUSH
9172: LD_INT 26
9174: PUSH
9175: LD_INT 2
9177: PUSH
9178: EMPTY
9179: LIST
9180: LIST
9181: PUSH
9182: EMPTY
9183: LIST
9184: LIST
9185: LIST
9186: PPUSH
9187: CALL_OW 69
9191: PUSH
9192: LD_EXP 30
9196: PUSH
9197: LD_EXP 17
9201: PUSH
9202: LD_EXP 28
9206: PUSH
9207: LD_EXP 29
9211: PUSH
9212: EMPTY
9213: LIST
9214: LIST
9215: LIST
9216: LIST
9217: DIFF
9218: ST_TO_ADDR
// if tmp then
9219: LD_VAR 0 1
9223: IFFALSE 9294
// case GetSex ( tmp [ 1 ] ) of sex_male :
9225: LD_VAR 0 1
9229: PUSH
9230: LD_INT 1
9232: ARRAY
9233: PPUSH
9234: CALL_OW 258
9238: PUSH
9239: LD_INT 1
9241: DOUBLE
9242: EQUAL
9243: IFTRUE 9247
9245: GO 9266
9247: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9248: LD_VAR 0 1
9252: PUSH
9253: LD_INT 1
9255: ARRAY
9256: PPUSH
9257: LD_STRING D9-Sol1-1
9259: PPUSH
9260: CALL_OW 88
9264: GO 9294
9266: LD_INT 2
9268: DOUBLE
9269: EQUAL
9270: IFTRUE 9274
9272: GO 9293
9274: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9275: LD_VAR 0 1
9279: PUSH
9280: LD_INT 1
9282: ARRAY
9283: PPUSH
9284: LD_STRING D9-FSol1-1
9286: PPUSH
9287: CALL_OW 88
9291: GO 9294
9293: POP
// if Frank then
9294: LD_EXP 27
9298: IFFALSE 9402
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9300: LD_EXP 56
9304: PPUSH
9305: CALL_OW 250
9309: PPUSH
9310: LD_EXP 56
9314: PPUSH
9315: CALL_OW 251
9319: PPUSH
9320: LD_INT 7
9322: PPUSH
9323: LD_INT 8
9325: PPUSH
9326: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9330: LD_EXP 56
9334: PPUSH
9335: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9339: LD_EXP 27
9343: PPUSH
9344: LD_STRING D9-Frank-1
9346: PPUSH
9347: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9351: LD_EXP 15
9355: PPUSH
9356: LD_STRING D9-JMM-1
9358: PPUSH
9359: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9363: LD_EXP 27
9367: PPUSH
9368: LD_STRING D9-Frank-2
9370: PPUSH
9371: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9375: LD_EXP 56
9379: PPUSH
9380: CALL_OW 250
9384: PPUSH
9385: LD_EXP 56
9389: PPUSH
9390: CALL_OW 251
9394: PPUSH
9395: LD_INT 7
9397: PPUSH
9398: CALL_OW 331
// end ; DialogueOff ;
9402: CALL_OW 7
// end ;
9406: PPOPN 1
9408: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9409: LD_EXP 7
9413: PUSH
9414: LD_OWVAR 1
9418: PUSH
9419: LD_INT 42000
9421: GREATEREQUAL
9422: OR
9423: IFFALSE 10450
9425: GO 9427
9427: DISABLE
9428: LD_INT 0
9430: PPUSH
9431: PPUSH
// begin selected_option := 1 ;
9432: LD_ADDR_VAR 0 2
9436: PUSH
9437: LD_INT 1
9439: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9440: LD_INT 10500
9442: PPUSH
9443: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9447: LD_INT 35
9449: PPUSH
9450: CALL_OW 67
// until not ru_attackers ;
9454: LD_EXP 52
9458: NOT
9459: IFFALSE 9447
// PrepareBurlak ;
9461: CALL 2204 0 0
// repeat wait ( 0 0$2 ) ;
9465: LD_INT 70
9467: PPUSH
9468: CALL_OW 67
// until not HasTask ( Burlak ) ;
9472: LD_EXP 46
9476: PPUSH
9477: CALL_OW 314
9481: NOT
9482: IFFALSE 9465
// InGameOn ;
9484: CALL_OW 8
// DialogueOn ;
9488: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9492: LD_EXP 49
9496: PPUSH
9497: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9501: LD_EXP 46
9505: PPUSH
9506: LD_STRING D10-Bur-1
9508: PPUSH
9509: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9513: LD_EXP 47
9517: PUSH
9518: LD_EXP 47
9522: PPUSH
9523: CALL_OW 255
9527: PUSH
9528: LD_INT 7
9530: EQUAL
9531: AND
9532: IFFALSE 9546
// Say ( Belkov , D10-Bel-1 ) ;
9534: LD_EXP 47
9538: PPUSH
9539: LD_STRING D10-Bel-1
9541: PPUSH
9542: CALL_OW 88
// if Gossudarov then
9546: LD_EXP 32
9550: IFFALSE 9564
// Say ( Gossudarov , D10-Gos-1 ) ;
9552: LD_EXP 32
9556: PPUSH
9557: LD_STRING D10-Gos-1
9559: PPUSH
9560: CALL_OW 88
// if Kirilenkova then
9564: LD_EXP 33
9568: IFFALSE 9582
// Say ( Kirilenkova , D10-Kir-1 ) ;
9570: LD_EXP 33
9574: PPUSH
9575: LD_STRING D10-Kir-1
9577: PPUSH
9578: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9582: CALL 12858 0 0
9586: PPUSH
9587: LD_STRING D10-RSol1-1
9589: PPUSH
9590: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9594: LD_EXP 46
9598: PPUSH
9599: LD_STRING D10-Bur-2
9601: PPUSH
9602: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9606: LD_EXP 15
9610: PPUSH
9611: LD_STRING D10-JMM-2
9613: PPUSH
9614: CALL_OW 88
// if Kirilenkova then
9618: LD_EXP 33
9622: IFFALSE 9638
// Say ( Kirilenkova , D10-Kir-2 ) else
9624: LD_EXP 33
9628: PPUSH
9629: LD_STRING D10-Kir-2
9631: PPUSH
9632: CALL_OW 88
9636: GO 9650
// Say ( SolRu , D10-RSol1-2 ) ;
9638: CALL 12858 0 0
9642: PPUSH
9643: LD_STRING D10-RSol1-2
9645: PPUSH
9646: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9650: LD_EXP 15
9654: PPUSH
9655: LD_STRING D10-JMM-3
9657: PPUSH
9658: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9662: LD_EXP 46
9666: PPUSH
9667: LD_STRING D10-Bur-3
9669: PPUSH
9670: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9674: LD_EXP 15
9678: PPUSH
9679: LD_STRING D10-JMM-4
9681: PPUSH
9682: CALL_OW 88
// DialogueOff ;
9686: CALL_OW 7
// InGameOff ;
9690: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9694: LD_STRING M2
9696: PPUSH
9697: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9701: LD_INT 35
9703: PPUSH
9704: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9708: LD_INT 22
9710: PUSH
9711: LD_INT 7
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: PUSH
9718: LD_INT 91
9720: PUSH
9721: LD_EXP 46
9725: PUSH
9726: LD_INT 8
9728: PUSH
9729: EMPTY
9730: LIST
9731: LIST
9732: LIST
9733: PUSH
9734: EMPTY
9735: LIST
9736: LIST
9737: PPUSH
9738: CALL_OW 69
9742: IFFALSE 9701
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9744: LD_ADDR_VAR 0 1
9748: PUSH
9749: LD_INT 22
9751: PUSH
9752: LD_INT 4
9754: PUSH
9755: EMPTY
9756: LIST
9757: LIST
9758: PPUSH
9759: CALL_OW 69
9763: PUSH
9764: FOR_IN
9765: IFFALSE 9781
// SetSide ( i , 7 ) ;
9767: LD_VAR 0 1
9771: PPUSH
9772: LD_INT 7
9774: PPUSH
9775: CALL_OW 235
9779: GO 9764
9781: POP
9782: POP
// ChangeMissionObjectives ( M3 ) ;
9783: LD_STRING M3
9785: PPUSH
9786: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9790: LD_INT 35
9792: PPUSH
9793: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9797: LD_EXP 15
9801: PPUSH
9802: LD_EXP 46
9806: PPUSH
9807: CALL_OW 296
9811: PUSH
9812: LD_INT 8
9814: LESS
9815: IFFALSE 9790
// ComTurnUnit ( JMM , Burlak ) ;
9817: LD_EXP 15
9821: PPUSH
9822: LD_EXP 46
9826: PPUSH
9827: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9831: LD_EXP 46
9835: PPUSH
9836: LD_EXP 15
9840: PPUSH
9841: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9845: LD_INT 10
9847: PPUSH
9848: CALL_OW 67
// DialogueOn ;
9852: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9856: LD_EXP 15
9860: PPUSH
9861: LD_STRING D11-JMM-1
9863: PPUSH
9864: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9868: LD_EXP 46
9872: PPUSH
9873: LD_STRING D11-Bur-1
9875: PPUSH
9876: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9880: LD_EXP 15
9884: PPUSH
9885: LD_STRING D11-JMM-2
9887: PPUSH
9888: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9892: LD_EXP 46
9896: PPUSH
9897: LD_STRING D11-Bur-2
9899: PPUSH
9900: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9904: LD_EXP 15
9908: PPUSH
9909: LD_STRING D11-JMM-3
9911: PPUSH
9912: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9916: LD_EXP 46
9920: PPUSH
9921: LD_STRING D11-Bur-3
9923: PPUSH
9924: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9928: LD_EXP 15
9932: PPUSH
9933: LD_STRING D11-JMM-4
9935: PPUSH
9936: CALL_OW 88
// if ar_base_spotted then
9940: LD_EXP 8
9944: IFFALSE 9960
// Say ( Burlak , D12-Bur-1 ) else
9946: LD_EXP 46
9950: PPUSH
9951: LD_STRING D12-Bur-1
9953: PPUSH
9954: CALL_OW 88
9958: GO 9999
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9960: LD_INT 7
9962: PPUSH
9963: LD_INT 3
9965: PPUSH
9966: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9970: LD_INT 127
9972: PPUSH
9973: LD_INT 45
9975: PPUSH
9976: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9980: LD_EXP 46
9984: PPUSH
9985: LD_STRING D12-Bur-1a
9987: PPUSH
9988: CALL_OW 88
// dwait ( 0 0$2 ) ;
9992: LD_INT 70
9994: PPUSH
9995: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9999: LD_EXP 46
10003: PPUSH
10004: LD_STRING D12-Bur-1b
10006: PPUSH
10007: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10011: LD_EXP 15
10015: PPUSH
10016: LD_STRING D12-JMM-1
10018: PPUSH
10019: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10023: LD_EXP 46
10027: PPUSH
10028: LD_STRING D12-Bur-2
10030: PPUSH
10031: CALL_OW 88
// if Roth then
10035: LD_EXP 16
10039: IFFALSE 10055
// Say ( Roth , D12-Roth-2 ) else
10041: LD_EXP 16
10045: PPUSH
10046: LD_STRING D12-Roth-2
10048: PPUSH
10049: CALL_OW 88
10053: GO 10067
// Say ( SciRu , D12-RSci1-2 ) ;
10055: CALL 12711 0 0
10059: PPUSH
10060: LD_STRING D12-RSci1-2
10062: PPUSH
10063: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10067: LD_EXP 15
10071: PPUSH
10072: LD_STRING D12-JMM-2
10074: PPUSH
10075: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10079: LD_EXP 46
10083: PPUSH
10084: LD_STRING D12-Bur-3
10086: PPUSH
10087: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10091: LD_EXP 15
10095: PPUSH
10096: LD_STRING D12-JMM-3
10098: PPUSH
10099: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10103: LD_EXP 46
10107: PPUSH
10108: LD_STRING D12-Bur-4
10110: PPUSH
10111: CALL_OW 88
// case Query ( QBase ) of 1 :
10115: LD_STRING QBase
10117: PPUSH
10118: CALL_OW 97
10122: PUSH
10123: LD_INT 1
10125: DOUBLE
10126: EQUAL
10127: IFTRUE 10131
10129: GO 10249
10131: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10132: LD_EXP 15
10136: PPUSH
10137: LD_STRING D13a-JMM-1
10139: PPUSH
10140: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10144: LD_EXP 46
10148: PPUSH
10149: LD_STRING D13a-Bur-1
10151: PPUSH
10152: CALL_OW 88
// if Roth then
10156: LD_EXP 16
10160: IFFALSE 10176
// Say ( Roth , D13a-Roth-1 ) else
10162: LD_EXP 16
10166: PPUSH
10167: LD_STRING D13a-Roth-1
10169: PPUSH
10170: CALL_OW 88
10174: GO 10188
// Say ( SciRu , D13a-RSci1-1 ) ;
10176: CALL 12711 0 0
10180: PPUSH
10181: LD_STRING D13a-RSci1-1
10183: PPUSH
10184: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10188: LD_EXP 15
10192: PPUSH
10193: LD_STRING D13a-JMM-2
10195: PPUSH
10196: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10200: LD_STRING QBaseAgain
10202: PPUSH
10203: CALL_OW 97
10207: PUSH
10208: LD_INT 1
10210: DOUBLE
10211: EQUAL
10212: IFTRUE 10216
10214: GO 10227
10216: POP
// selected_option := 2 ; 2 :
10217: LD_ADDR_VAR 0 2
10221: PUSH
10222: LD_INT 2
10224: ST_TO_ADDR
10225: GO 10247
10227: LD_INT 2
10229: DOUBLE
10230: EQUAL
10231: IFTRUE 10235
10233: GO 10246
10235: POP
// selected_option := 3 ; end ;
10236: LD_ADDR_VAR 0 2
10240: PUSH
10241: LD_INT 3
10243: ST_TO_ADDR
10244: GO 10247
10246: POP
// end ; 2 :
10247: GO 10288
10249: LD_INT 2
10251: DOUBLE
10252: EQUAL
10253: IFTRUE 10257
10255: GO 10268
10257: POP
// selected_option := 2 ; 3 :
10258: LD_ADDR_VAR 0 2
10262: PUSH
10263: LD_INT 2
10265: ST_TO_ADDR
10266: GO 10288
10268: LD_INT 3
10270: DOUBLE
10271: EQUAL
10272: IFTRUE 10276
10274: GO 10287
10276: POP
// selected_option := 3 ; end ;
10277: LD_ADDR_VAR 0 2
10281: PUSH
10282: LD_INT 3
10284: ST_TO_ADDR
10285: GO 10288
10287: POP
// if selected_option = 2 then
10288: LD_VAR 0 2
10292: PUSH
10293: LD_INT 2
10295: EQUAL
10296: IFFALSE 10390
// begin Say ( JMM , D13b-JMM-1 ) ;
10298: LD_EXP 15
10302: PPUSH
10303: LD_STRING D13b-JMM-1
10305: PPUSH
10306: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10310: LD_EXP 46
10314: PPUSH
10315: LD_STRING D13b-Bur-1
10317: PPUSH
10318: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10322: LD_EXP 15
10326: PPUSH
10327: LD_STRING D13b-JMM-2
10329: PPUSH
10330: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10334: LD_EXP 55
10338: PPUSH
10339: LD_STRING D13b-Abd-2
10341: PPUSH
10342: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10346: LD_EXP 15
10350: PPUSH
10351: LD_STRING D13b-JMM-3
10353: PPUSH
10354: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10358: LD_EXP 55
10362: PPUSH
10363: LD_STRING D13b-Abd-3
10365: PPUSH
10366: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10370: LD_EXP 15
10374: PPUSH
10375: LD_STRING D13b-JMM-4
10377: PPUSH
10378: CALL_OW 88
// ar_active_attack := true ;
10382: LD_ADDR_EXP 9
10386: PUSH
10387: LD_INT 1
10389: ST_TO_ADDR
// end ; if selected_option = 3 then
10390: LD_VAR 0 2
10394: PUSH
10395: LD_INT 3
10397: EQUAL
10398: IFFALSE 10424
// begin Say ( JMM , D13c-JMM-1 ) ;
10400: LD_EXP 15
10404: PPUSH
10405: LD_STRING D13c-JMM-1
10407: PPUSH
10408: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10412: LD_EXP 46
10416: PPUSH
10417: LD_STRING D13c-Bur-1
10419: PPUSH
10420: CALL_OW 88
// end ; DialogueOff ;
10424: CALL_OW 7
// if not ar_active_attack then
10428: LD_EXP 9
10432: NOT
10433: IFFALSE 10450
// begin wait ( 6 6$00 ) ;
10435: LD_INT 12600
10437: PPUSH
10438: CALL_OW 67
// ar_active_attack := true ;
10442: LD_ADDR_EXP 9
10446: PUSH
10447: LD_INT 1
10449: ST_TO_ADDR
// end ; end ;
10450: PPOPN 2
10452: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10453: LD_EXP 46
10457: PPUSH
10458: CALL_OW 305
10462: PUSH
10463: LD_EXP 46
10467: PPUSH
10468: CALL_OW 255
10472: PUSH
10473: LD_INT 7
10475: EQUAL
10476: AND
10477: IFFALSE 10673
10479: GO 10481
10481: DISABLE
10482: LD_INT 0
10484: PPUSH
// begin wait ( 4 4$40 ) ;
10485: LD_INT 9800
10487: PPUSH
10488: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10492: LD_INT 35
10494: PPUSH
10495: CALL_OW 67
// until not ru_attackers ;
10499: LD_EXP 52
10503: NOT
10504: IFFALSE 10492
// PrepareGnyevko ;
10506: CALL 2148 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10510: LD_EXP 48
10514: PPUSH
10515: LD_INT 124
10517: PPUSH
10518: LD_INT 118
10520: PPUSH
10521: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10525: LD_EXP 48
10529: PPUSH
10530: CALL_OW 200
// time := 0 0$00 ;
10534: LD_ADDR_VAR 0 1
10538: PUSH
10539: LD_INT 0
10541: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10542: LD_INT 35
10544: PPUSH
10545: CALL_OW 67
// time := time + 0 0$1 ;
10549: LD_ADDR_VAR 0 1
10553: PUSH
10554: LD_VAR 0 1
10558: PUSH
10559: LD_INT 35
10561: PLUS
10562: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10563: LD_EXP 48
10567: PPUSH
10568: LD_INT 124
10570: PPUSH
10571: LD_INT 118
10573: PPUSH
10574: CALL_OW 307
10578: PUSH
10579: LD_VAR 0 1
10583: PUSH
10584: LD_INT 1050
10586: GREATEREQUAL
10587: OR
10588: IFFALSE 10542
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10590: LD_EXP 48
10594: PPUSH
10595: LD_STRING DBelkov-Gny-1
10597: PPUSH
10598: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10602: LD_EXP 46
10606: PPUSH
10607: LD_STRING DBelkov-Bur-1a
10609: PPUSH
10610: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10614: LD_INT 35
10616: PPUSH
10617: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10621: LD_EXP 48
10625: PPUSH
10626: LD_INT 22
10628: PUSH
10629: LD_INT 7
10631: PUSH
10632: EMPTY
10633: LIST
10634: LIST
10635: PPUSH
10636: CALL_OW 69
10640: PPUSH
10641: LD_EXP 48
10645: PPUSH
10646: CALL_OW 74
10650: PPUSH
10651: CALL_OW 296
10655: PUSH
10656: LD_INT 8
10658: LESS
10659: IFFALSE 10614
// SetSide ( Gnyevko , 7 ) ;
10661: LD_EXP 48
10665: PPUSH
10666: LD_INT 7
10668: PPUSH
10669: CALL_OW 235
// end ;
10673: PPOPN 1
10675: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10676: LD_EXP 46
10680: PPUSH
10681: CALL_OW 255
10685: PUSH
10686: LD_INT 7
10688: EQUAL
10689: IFFALSE 10699
10691: GO 10693
10693: DISABLE
// begin enable ;
10694: ENABLE
// PrepareAmericanAttack ;
10695: CALL 6523 0 0
// end ;
10699: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10700: LD_INT 22
10702: PUSH
10703: LD_INT 1
10705: PUSH
10706: EMPTY
10707: LIST
10708: LIST
10709: PPUSH
10710: CALL_OW 69
10714: IFFALSE 10898
10716: GO 10718
10718: DISABLE
10719: LD_INT 0
10721: PPUSH
10722: PPUSH
// begin while true do
10723: LD_INT 1
10725: IFFALSE 10782
// begin wait ( 0 0$1 ) ;
10727: LD_INT 35
10729: PPUSH
10730: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10734: LD_ADDR_VAR 0 2
10738: PUSH
10739: LD_INT 22
10741: PUSH
10742: LD_INT 1
10744: PUSH
10745: EMPTY
10746: LIST
10747: LIST
10748: PPUSH
10749: CALL_OW 69
10753: PPUSH
10754: LD_EXP 15
10758: PPUSH
10759: CALL_OW 74
10763: ST_TO_ADDR
// if See ( 7 , tmp ) then
10764: LD_INT 7
10766: PPUSH
10767: LD_VAR 0 2
10771: PPUSH
10772: CALL_OW 292
10776: IFFALSE 10780
// break ;
10778: GO 10782
// end ;
10780: GO 10723
// DialogueOn ;
10782: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10786: LD_VAR 0 2
10790: PPUSH
10791: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10795: LD_VAR 0 2
10799: PPUSH
10800: CALL_OW 250
10804: PPUSH
10805: LD_VAR 0 2
10809: PPUSH
10810: CALL_OW 251
10814: PPUSH
10815: LD_INT 7
10817: PPUSH
10818: LD_INT 8
10820: PPUSH
10821: CALL_OW 330
// if Denis then
10825: LD_EXP 21
10829: IFFALSE 10843
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10831: LD_EXP 21
10835: PPUSH
10836: LD_STRING DAmerAttack-Pet-1
10838: PPUSH
10839: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10843: LD_EXP 15
10847: PPUSH
10848: LD_STRING DAmerAttack-JMM-1
10850: PPUSH
10851: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10855: LD_EXP 46
10859: PPUSH
10860: LD_STRING DStop-Bur-1
10862: PPUSH
10863: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10867: LD_VAR 0 2
10871: PPUSH
10872: CALL_OW 250
10876: PPUSH
10877: LD_VAR 0 2
10881: PPUSH
10882: CALL_OW 251
10886: PPUSH
10887: LD_INT 7
10889: PPUSH
10890: CALL_OW 331
// DialogueOff ;
10894: CALL_OW 7
// end ;
10898: PPOPN 2
10900: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10901: LD_INT 22
10903: PUSH
10904: LD_INT 3
10906: PUSH
10907: EMPTY
10908: LIST
10909: LIST
10910: PUSH
10911: LD_INT 21
10913: PUSH
10914: LD_INT 1
10916: PUSH
10917: EMPTY
10918: LIST
10919: LIST
10920: PUSH
10921: EMPTY
10922: LIST
10923: LIST
10924: PPUSH
10925: CALL_OW 69
10929: PUSH
10930: LD_INT 0
10932: EQUAL
10933: IFFALSE 10975
10935: GO 10937
10937: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10938: LD_STRING M5a
10940: PPUSH
10941: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10945: LD_EXP 15
10949: PPUSH
10950: LD_STRING D8-JMM-1
10952: PPUSH
10953: CALL_OW 88
// if Gossudarov then
10957: LD_EXP 32
10961: IFFALSE 10975
// Say ( Gossudarov , D8-Gos-1 ) ;
10963: LD_EXP 32
10967: PPUSH
10968: LD_STRING D8-Gos-1
10970: PPUSH
10971: CALL_OW 88
// end ;
10975: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10976: LD_INT 22
10978: PUSH
10979: LD_INT 2
10981: PUSH
10982: EMPTY
10983: LIST
10984: LIST
10985: PUSH
10986: LD_INT 21
10988: PUSH
10989: LD_INT 1
10991: PUSH
10992: EMPTY
10993: LIST
10994: LIST
10995: PUSH
10996: EMPTY
10997: LIST
10998: LIST
10999: PPUSH
11000: CALL_OW 69
11004: PUSH
11005: LD_INT 0
11007: EQUAL
11008: IFFALSE 11058
11010: GO 11012
11012: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11013: LD_STRING M4c
11015: PPUSH
11016: CALL_OW 337
// if Roth then
11020: LD_EXP 16
11024: IFFALSE 11040
// Say ( Roth , DStop-Roth-1 ) else
11026: LD_EXP 16
11030: PPUSH
11031: LD_STRING DStop-Roth-1
11033: PPUSH
11034: CALL_OW 88
11038: GO 11058
// if Gossudarov then
11040: LD_EXP 32
11044: IFFALSE 11058
// Say ( Gossudarov , D8-Gos-1a ) ;
11046: LD_EXP 32
11050: PPUSH
11051: LD_STRING D8-Gos-1a
11053: PPUSH
11054: CALL_OW 88
// end ;
11058: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11059: LD_INT 7
11061: PPUSH
11062: LD_INT 1
11064: PPUSH
11065: LD_INT 1
11067: PPUSH
11068: CALL 14347 0 3
11072: PUSH
11073: LD_INT 0
11075: EQUAL
11076: PUSH
11077: LD_INT 7
11079: PPUSH
11080: LD_INT 3
11082: PPUSH
11083: LD_INT 1
11085: PPUSH
11086: CALL 14347 0 3
11090: PUSH
11091: LD_INT 0
11093: EQUAL
11094: AND
11095: IFFALSE 11107
11097: GO 11099
11099: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11100: LD_STRING M1a
11102: PPUSH
11103: CALL_OW 337
// end ;
11107: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11108: LD_INT 22
11110: PUSH
11111: LD_INT 2
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: PUSH
11118: LD_INT 21
11120: PUSH
11121: LD_INT 1
11123: PUSH
11124: EMPTY
11125: LIST
11126: LIST
11127: PUSH
11128: EMPTY
11129: LIST
11130: LIST
11131: PPUSH
11132: CALL_OW 69
11136: PUSH
11137: LD_INT 0
11139: EQUAL
11140: PUSH
11141: LD_INT 22
11143: PUSH
11144: LD_INT 3
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: PUSH
11151: LD_INT 21
11153: PUSH
11154: LD_INT 1
11156: PUSH
11157: EMPTY
11158: LIST
11159: LIST
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: PPUSH
11165: CALL_OW 69
11169: PUSH
11170: LD_INT 0
11172: EQUAL
11173: AND
11174: PUSH
11175: LD_INT 22
11177: PUSH
11178: LD_INT 1
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PPUSH
11185: CALL_OW 69
11189: PUSH
11190: LD_INT 0
11192: EQUAL
11193: AND
11194: PUSH
11195: LD_INT 7
11197: PPUSH
11198: LD_INT 1
11200: PPUSH
11201: LD_INT 1
11203: PPUSH
11204: CALL 14347 0 3
11208: PUSH
11209: LD_INT 0
11211: EQUAL
11212: AND
11213: PUSH
11214: LD_INT 7
11216: PPUSH
11217: LD_INT 3
11219: PPUSH
11220: LD_INT 1
11222: PPUSH
11223: CALL 14347 0 3
11227: PUSH
11228: LD_INT 0
11230: EQUAL
11231: AND
11232: IFFALSE 12708
11234: GO 11236
11236: DISABLE
11237: LD_INT 0
11239: PPUSH
11240: PPUSH
11241: PPUSH
11242: PPUSH
11243: PPUSH
11244: PPUSH
// begin m1 := false ;
11245: LD_ADDR_VAR 0 4
11249: PUSH
11250: LD_INT 0
11252: ST_TO_ADDR
// m2 := false ;
11253: LD_ADDR_VAR 0 5
11257: PUSH
11258: LD_INT 0
11260: ST_TO_ADDR
// m3 := false ;
11261: LD_ADDR_VAR 0 6
11265: PUSH
11266: LD_INT 0
11268: ST_TO_ADDR
// if tick < 40 40$00 then
11269: LD_OWVAR 1
11273: PUSH
11274: LD_INT 84000
11276: LESS
11277: IFFALSE 11286
// SetAchievement ( ACH_ASPEED_17 ) ;
11279: LD_STRING ACH_ASPEED_17
11281: PPUSH
11282: CALL_OW 543
// wait ( 0 0$1 ) ;
11286: LD_INT 35
11288: PPUSH
11289: CALL_OW 67
// if not IsDead ( Masha ) then
11293: LD_EXP 49
11297: PPUSH
11298: CALL_OW 301
11302: NOT
11303: IFFALSE 11325
// begin m1 := true ;
11305: LD_ADDR_VAR 0 4
11309: PUSH
11310: LD_INT 1
11312: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11313: LD_STRING Masha
11315: PPUSH
11316: LD_INT 1
11318: PPUSH
11319: CALL_OW 101
// end else
11323: GO 11336
// AddMedal ( Masha , - 1 ) ;
11325: LD_STRING Masha
11327: PPUSH
11328: LD_INT 1
11330: NEG
11331: PPUSH
11332: CALL_OW 101
// if abdul_escaped then
11336: LD_EXP 12
11340: IFFALSE 11355
// AddMedal ( Abdul , - 1 ) else
11342: LD_STRING Abdul
11344: PPUSH
11345: LD_INT 1
11347: NEG
11348: PPUSH
11349: CALL_OW 101
11353: GO 11373
// begin m2 := true ;
11355: LD_ADDR_VAR 0 5
11359: PUSH
11360: LD_INT 1
11362: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11363: LD_STRING Abdul
11365: PPUSH
11366: LD_INT 1
11368: PPUSH
11369: CALL_OW 101
// end ; if loss_counter = 0 then
11373: LD_EXP 13
11377: PUSH
11378: LD_INT 0
11380: EQUAL
11381: IFFALSE 11403
// begin m3 := true ;
11383: LD_ADDR_VAR 0 6
11387: PUSH
11388: LD_INT 1
11390: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11391: LD_STRING People
11393: PPUSH
11394: LD_INT 2
11396: PPUSH
11397: CALL_OW 101
// end else
11401: GO 11461
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11403: LD_EXP 13
11407: PUSH
11408: LD_INT 3
11410: PUSH
11411: LD_INT 2
11413: PUSH
11414: LD_INT 2
11416: PUSH
11417: EMPTY
11418: LIST
11419: LIST
11420: LIST
11421: PUSH
11422: LD_OWVAR 67
11426: ARRAY
11427: LESSEQUAL
11428: IFFALSE 11450
// begin AddMedal ( People , 1 ) ;
11430: LD_STRING People
11432: PPUSH
11433: LD_INT 1
11435: PPUSH
11436: CALL_OW 101
// m3 := true ;
11440: LD_ADDR_VAR 0 6
11444: PUSH
11445: LD_INT 1
11447: ST_TO_ADDR
// end else
11448: GO 11461
// AddMedal ( People , - 1 ) ;
11450: LD_STRING People
11452: PPUSH
11453: LD_INT 1
11455: NEG
11456: PPUSH
11457: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11461: LD_OWVAR 67
11465: PUSH
11466: LD_INT 3
11468: EQUAL
11469: PUSH
11470: LD_VAR 0 4
11474: AND
11475: PUSH
11476: LD_VAR 0 5
11480: AND
11481: PUSH
11482: LD_VAR 0 6
11486: AND
11487: IFFALSE 11499
// SetAchievementEX ( ACH_AMER , 17 ) ;
11489: LD_STRING ACH_AMER
11491: PPUSH
11492: LD_INT 17
11494: PPUSH
11495: CALL_OW 564
// GiveMedals ( MAIN ) ;
11499: LD_STRING MAIN
11501: PPUSH
11502: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11506: LD_ADDR_VAR 0 2
11510: PUSH
11511: LD_INT 22
11513: PUSH
11514: LD_INT 7
11516: PUSH
11517: EMPTY
11518: LIST
11519: LIST
11520: PUSH
11521: LD_INT 2
11523: PUSH
11524: LD_INT 25
11526: PUSH
11527: LD_INT 1
11529: PUSH
11530: EMPTY
11531: LIST
11532: LIST
11533: PUSH
11534: LD_INT 25
11536: PUSH
11537: LD_INT 2
11539: PUSH
11540: EMPTY
11541: LIST
11542: LIST
11543: PUSH
11544: LD_INT 25
11546: PUSH
11547: LD_INT 3
11549: PUSH
11550: EMPTY
11551: LIST
11552: LIST
11553: PUSH
11554: LD_INT 25
11556: PUSH
11557: LD_INT 4
11559: PUSH
11560: EMPTY
11561: LIST
11562: LIST
11563: PUSH
11564: LD_INT 25
11566: PUSH
11567: LD_INT 5
11569: PUSH
11570: EMPTY
11571: LIST
11572: LIST
11573: PUSH
11574: LD_INT 25
11576: PUSH
11577: LD_INT 8
11579: PUSH
11580: EMPTY
11581: LIST
11582: LIST
11583: PUSH
11584: LD_INT 25
11586: PUSH
11587: LD_INT 9
11589: PUSH
11590: EMPTY
11591: LIST
11592: LIST
11593: PUSH
11594: EMPTY
11595: LIST
11596: LIST
11597: LIST
11598: LIST
11599: LIST
11600: LIST
11601: LIST
11602: LIST
11603: PUSH
11604: EMPTY
11605: LIST
11606: LIST
11607: PPUSH
11608: CALL_OW 69
11612: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11613: LD_VAR 0 2
11617: PPUSH
11618: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11622: LD_ADDR_VAR 0 3
11626: PUSH
11627: LD_EXP 15
11631: PUSH
11632: LD_EXP 16
11636: PUSH
11637: LD_EXP 17
11641: PUSH
11642: LD_EXP 18
11646: PUSH
11647: LD_EXP 19
11651: PUSH
11652: LD_EXP 20
11656: PUSH
11657: LD_EXP 21
11661: PUSH
11662: LD_EXP 22
11666: PUSH
11667: LD_EXP 23
11671: PUSH
11672: LD_EXP 24
11676: PUSH
11677: LD_EXP 25
11681: PUSH
11682: LD_EXP 26
11686: PUSH
11687: LD_EXP 27
11691: PUSH
11692: LD_EXP 28
11696: PUSH
11697: LD_EXP 29
11701: PUSH
11702: LD_EXP 30
11706: PUSH
11707: LD_EXP 31
11711: PUSH
11712: LD_EXP 32
11716: PUSH
11717: LD_EXP 33
11721: PUSH
11722: LD_EXP 34
11726: PUSH
11727: LD_EXP 36
11731: PUSH
11732: LD_EXP 37
11736: PUSH
11737: LD_EXP 38
11741: PUSH
11742: LD_EXP 39
11746: PUSH
11747: LD_EXP 40
11751: PUSH
11752: LD_EXP 41
11756: PUSH
11757: LD_EXP 42
11761: PUSH
11762: LD_EXP 43
11766: PUSH
11767: LD_EXP 44
11771: PUSH
11772: LD_EXP 45
11776: PUSH
11777: LD_EXP 46
11781: PUSH
11782: LD_EXP 47
11786: PUSH
11787: LD_EXP 48
11791: PUSH
11792: EMPTY
11793: LIST
11794: LIST
11795: LIST
11796: LIST
11797: LIST
11798: LIST
11799: LIST
11800: LIST
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: LIST
11809: LIST
11810: LIST
11811: LIST
11812: LIST
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: ST_TO_ADDR
// if tmp diff tmp2 then
11827: LD_VAR 0 2
11831: PUSH
11832: LD_VAR 0 3
11836: DIFF
11837: IFFALSE 11857
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11839: LD_VAR 0 2
11843: PUSH
11844: LD_VAR 0 3
11848: DIFF
11849: PPUSH
11850: LD_STRING 13a_others
11852: PPUSH
11853: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11857: LD_EXP 15
11861: PPUSH
11862: LD_STRING 13a_JMM
11864: PPUSH
11865: CALL_OW 38
// if Titov then
11869: LD_EXP 34
11873: IFFALSE 11887
// SaveCharacters ( Titov , 13a_Titov ) ;
11875: LD_EXP 34
11879: PPUSH
11880: LD_STRING 13a_Titov
11882: PPUSH
11883: CALL_OW 38
// if Dolgov then
11887: LD_EXP 36
11891: IFFALSE 11905
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11893: LD_EXP 36
11897: PPUSH
11898: LD_STRING 13a_Dolgov
11900: PPUSH
11901: CALL_OW 38
// if Petrosyan then
11905: LD_EXP 37
11909: IFFALSE 11923
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11911: LD_EXP 37
11915: PPUSH
11916: LD_STRING 13a_Petrosyan
11918: PPUSH
11919: CALL_OW 38
// if Scholtze then
11923: LD_EXP 38
11927: IFFALSE 11941
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11929: LD_EXP 38
11933: PPUSH
11934: LD_STRING 13a_Scholtze
11936: PPUSH
11937: CALL_OW 38
// if Oblukov then
11941: LD_EXP 39
11945: IFFALSE 11959
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11947: LD_EXP 39
11951: PPUSH
11952: LD_STRING 13a_Oblukov
11954: PPUSH
11955: CALL_OW 38
// if Kapitsova then
11959: LD_EXP 40
11963: IFFALSE 11977
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11965: LD_EXP 40
11969: PPUSH
11970: LD_STRING 13a_Kapitsova
11972: PPUSH
11973: CALL_OW 38
// if Lipshchin then
11977: LD_EXP 41
11981: IFFALSE 11995
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11983: LD_EXP 41
11987: PPUSH
11988: LD_STRING 13a_Lipshchin
11990: PPUSH
11991: CALL_OW 38
// if Petrovova then
11995: LD_EXP 42
11999: IFFALSE 12013
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12001: LD_EXP 42
12005: PPUSH
12006: LD_STRING 13a_Petrovova
12008: PPUSH
12009: CALL_OW 38
// if Kovalyuk then
12013: LD_EXP 43
12017: IFFALSE 12031
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12019: LD_EXP 43
12023: PPUSH
12024: LD_STRING 13a_Kovalyuk
12026: PPUSH
12027: CALL_OW 38
// if Kuzmov then
12031: LD_EXP 44
12035: IFFALSE 12049
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12037: LD_EXP 44
12041: PPUSH
12042: LD_STRING 13a_Kuzmov
12044: PPUSH
12045: CALL_OW 38
// if Karamazov then
12049: LD_EXP 45
12053: IFFALSE 12067
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12055: LD_EXP 45
12059: PPUSH
12060: LD_STRING 13a_Karamazov
12062: PPUSH
12063: CALL_OW 38
// if Burlak then
12067: LD_EXP 46
12071: IFFALSE 12085
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12073: LD_EXP 46
12077: PPUSH
12078: LD_STRING 13a_Burlak
12080: PPUSH
12081: CALL_OW 38
// if Belkov then
12085: LD_EXP 47
12089: IFFALSE 12103
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12091: LD_EXP 47
12095: PPUSH
12096: LD_STRING 13a_Belkov
12098: PPUSH
12099: CALL_OW 38
// if Gnyevko then
12103: LD_EXP 48
12107: IFFALSE 12121
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12109: LD_EXP 48
12113: PPUSH
12114: LD_STRING 13a_Gnyevko
12116: PPUSH
12117: CALL_OW 38
// if Lisa then
12121: LD_EXP 17
12125: IFFALSE 12139
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12127: LD_EXP 17
12131: PPUSH
12132: LD_STRING 13a_Lisa
12134: PPUSH
12135: CALL_OW 38
// if Donaldson then
12139: LD_EXP 18
12143: IFFALSE 12157
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12145: LD_EXP 18
12149: PPUSH
12150: LD_STRING 13a_Donaldson
12152: PPUSH
12153: CALL_OW 38
// if Bobby then
12157: LD_EXP 19
12161: IFFALSE 12175
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12163: LD_EXP 19
12167: PPUSH
12168: LD_STRING 13a_Bobby
12170: PPUSH
12171: CALL_OW 38
// if Cyrus then
12175: LD_EXP 20
12179: IFFALSE 12193
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12181: LD_EXP 20
12185: PPUSH
12186: LD_STRING 13a_Cyrus
12188: PPUSH
12189: CALL_OW 38
// if Denis then
12193: LD_EXP 21
12197: IFFALSE 12211
// SaveCharacters ( Denis , 13a_Denis ) ;
12199: LD_EXP 21
12203: PPUSH
12204: LD_STRING 13a_Denis
12206: PPUSH
12207: CALL_OW 38
// if Brown then
12211: LD_EXP 22
12215: IFFALSE 12229
// SaveCharacters ( Brown , 13a_Brown ) ;
12217: LD_EXP 22
12221: PPUSH
12222: LD_STRING 13a_Brown
12224: PPUSH
12225: CALL_OW 38
// if Gladstone then
12229: LD_EXP 23
12233: IFFALSE 12247
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12235: LD_EXP 23
12239: PPUSH
12240: LD_STRING 13a_Gladstone
12242: PPUSH
12243: CALL_OW 38
// if Houten then
12247: LD_EXP 24
12251: IFFALSE 12265
// SaveCharacters ( Houten , 13a_Houten ) ;
12253: LD_EXP 24
12257: PPUSH
12258: LD_STRING 13a_Houten
12260: PPUSH
12261: CALL_OW 38
// if Cornel then
12265: LD_EXP 25
12269: IFFALSE 12283
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12271: LD_EXP 25
12275: PPUSH
12276: LD_STRING 13a_Cornel
12278: PPUSH
12279: CALL_OW 38
// if Gary then
12283: LD_EXP 26
12287: IFFALSE 12301
// SaveCharacters ( Gary , 13a_Gary ) ;
12289: LD_EXP 26
12293: PPUSH
12294: LD_STRING 13a_Gary
12296: PPUSH
12297: CALL_OW 38
// if Frank then
12301: LD_EXP 27
12305: IFFALSE 12319
// SaveCharacters ( Frank , 13a_Frank ) ;
12307: LD_EXP 27
12311: PPUSH
12312: LD_STRING 13a_Frank
12314: PPUSH
12315: CALL_OW 38
// if Kikuchi then
12319: LD_EXP 28
12323: IFFALSE 12337
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12325: LD_EXP 28
12329: PPUSH
12330: LD_STRING 13a_Kikuchi
12332: PPUSH
12333: CALL_OW 38
// if Simms then
12337: LD_EXP 29
12341: IFFALSE 12355
// SaveCharacters ( Simms , 13a_Simms ) ;
12343: LD_EXP 29
12347: PPUSH
12348: LD_STRING 13a_Simms
12350: PPUSH
12351: CALL_OW 38
// if Joan then
12355: LD_EXP 30
12359: IFFALSE 12373
// SaveCharacters ( Joan , 13a_Joan ) ;
12361: LD_EXP 30
12365: PPUSH
12366: LD_STRING 13a_Joan
12368: PPUSH
12369: CALL_OW 38
// if DeltaDoctor then
12373: LD_EXP 31
12377: IFFALSE 12391
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12379: LD_EXP 31
12383: PPUSH
12384: LD_STRING 13a_DeltaDoctor
12386: PPUSH
12387: CALL_OW 38
// if Gossudarov then
12391: LD_EXP 32
12395: IFFALSE 12409
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12397: LD_EXP 32
12401: PPUSH
12402: LD_STRING 13a_Gossudarov
12404: PPUSH
12405: CALL_OW 38
// if Kirilenkova then
12409: LD_EXP 33
12413: IFFALSE 12427
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12415: LD_EXP 33
12419: PPUSH
12420: LD_STRING 13a_Kirilenkova
12422: PPUSH
12423: CALL_OW 38
// if Roth then
12427: LD_EXP 16
12431: IFFALSE 12445
// SaveCharacters ( Roth , 13a_Roth ) ;
12433: LD_EXP 16
12437: PPUSH
12438: LD_STRING 13a_Roth
12440: PPUSH
12441: CALL_OW 38
// if Masha then
12445: LD_EXP 49
12449: IFFALSE 12504
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12451: LD_EXP 49
12455: PPUSH
12456: CALL_OW 265
12460: PUSH
12461: LD_EXP 49
12465: PPUSH
12466: CALL_OW 262
12470: PUSH
12471: LD_EXP 49
12475: PPUSH
12476: CALL_OW 263
12480: PUSH
12481: LD_EXP 49
12485: PPUSH
12486: CALL_OW 264
12490: PUSH
12491: EMPTY
12492: LIST
12493: LIST
12494: LIST
12495: LIST
12496: PPUSH
12497: LD_STRING 13a_Masha
12499: PPUSH
12500: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12504: LD_ADDR_VAR 0 2
12508: PUSH
12509: LD_INT 21
12511: PUSH
12512: LD_INT 3
12514: PUSH
12515: EMPTY
12516: LIST
12517: LIST
12518: PPUSH
12519: CALL_OW 69
12523: ST_TO_ADDR
// tmp2 := [ ] ;
12524: LD_ADDR_VAR 0 3
12528: PUSH
12529: EMPTY
12530: ST_TO_ADDR
// if tmp then
12531: LD_VAR 0 2
12535: IFFALSE 12686
// for i in tmp do
12537: LD_ADDR_VAR 0 1
12541: PUSH
12542: LD_VAR 0 2
12546: PUSH
12547: FOR_IN
12548: IFFALSE 12684
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12550: LD_ADDR_VAR 0 3
12554: PUSH
12555: LD_VAR 0 3
12559: PUSH
12560: LD_VAR 0 1
12564: PPUSH
12565: CALL_OW 255
12569: PUSH
12570: LD_VAR 0 1
12574: PPUSH
12575: CALL_OW 248
12579: PUSH
12580: LD_VAR 0 1
12584: PPUSH
12585: CALL_OW 266
12589: PUSH
12590: LD_VAR 0 1
12594: PPUSH
12595: CALL_OW 250
12599: PUSH
12600: LD_VAR 0 1
12604: PPUSH
12605: CALL_OW 251
12609: PUSH
12610: LD_VAR 0 1
12614: PPUSH
12615: CALL_OW 254
12619: PUSH
12620: LD_VAR 0 1
12624: PPUSH
12625: CALL_OW 267
12629: PUSH
12630: LD_VAR 0 1
12634: PPUSH
12635: LD_INT 1
12637: PPUSH
12638: CALL_OW 268
12642: PUSH
12643: LD_VAR 0 1
12647: PPUSH
12648: LD_INT 2
12650: PPUSH
12651: CALL_OW 268
12655: PUSH
12656: LD_VAR 0 1
12660: PPUSH
12661: CALL_OW 269
12665: PUSH
12666: EMPTY
12667: LIST
12668: LIST
12669: LIST
12670: LIST
12671: LIST
12672: LIST
12673: LIST
12674: LIST
12675: LIST
12676: LIST
12677: PUSH
12678: EMPTY
12679: LIST
12680: ADD
12681: ST_TO_ADDR
12682: GO 12547
12684: POP
12685: POP
// if tmp2 then
12686: LD_VAR 0 3
12690: IFFALSE 12704
// SaveVariable ( tmp2 , 13a_buildings ) ;
12692: LD_VAR 0 3
12696: PPUSH
12697: LD_STRING 13a_buildings
12699: PPUSH
12700: CALL_OW 39
// YouWin ;
12704: CALL_OW 103
// end ;
12708: PPOPN 6
12710: END
// export function SciRu ; var tmp , t ; begin
12711: LD_INT 0
12713: PPUSH
12714: PPUSH
12715: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12716: LD_ADDR_VAR 0 3
12720: PUSH
12721: LD_EXP 32
12725: PUSH
12726: LD_EXP 46
12730: PUSH
12731: LD_EXP 34
12735: PUSH
12736: LD_EXP 47
12740: PUSH
12741: LD_EXP 48
12745: PUSH
12746: LD_EXP 37
12750: PUSH
12751: LD_EXP 38
12755: PUSH
12756: LD_EXP 36
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: LIST
12765: LIST
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12771: LD_ADDR_VAR 0 2
12775: PUSH
12776: LD_INT 22
12778: PUSH
12779: LD_INT 7
12781: PUSH
12782: EMPTY
12783: LIST
12784: LIST
12785: PUSH
12786: LD_INT 23
12788: PUSH
12789: LD_INT 3
12791: PUSH
12792: EMPTY
12793: LIST
12794: LIST
12795: PUSH
12796: LD_INT 25
12798: PUSH
12799: LD_INT 4
12801: PUSH
12802: EMPTY
12803: LIST
12804: LIST
12805: PUSH
12806: LD_INT 26
12808: PUSH
12809: LD_INT 1
12811: PUSH
12812: EMPTY
12813: LIST
12814: LIST
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: PPUSH
12822: CALL_OW 69
12826: PUSH
12827: LD_VAR 0 3
12831: DIFF
12832: ST_TO_ADDR
// if tmp then
12833: LD_VAR 0 2
12837: IFFALSE 12853
// result := tmp [ 1 ] ;
12839: LD_ADDR_VAR 0 1
12843: PUSH
12844: LD_VAR 0 2
12848: PUSH
12849: LD_INT 1
12851: ARRAY
12852: ST_TO_ADDR
// end ;
12853: LD_VAR 0 1
12857: RET
// export function SolRu ; var tmp , t ; begin
12858: LD_INT 0
12860: PPUSH
12861: PPUSH
12862: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12863: LD_ADDR_VAR 0 3
12867: PUSH
12868: LD_EXP 32
12872: PUSH
12873: LD_EXP 46
12877: PUSH
12878: LD_EXP 34
12882: PUSH
12883: LD_EXP 47
12887: PUSH
12888: LD_EXP 48
12892: PUSH
12893: LD_EXP 37
12897: PUSH
12898: LD_EXP 38
12902: PUSH
12903: LD_EXP 36
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: LIST
12912: LIST
12913: LIST
12914: LIST
12915: LIST
12916: LIST
12917: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12918: LD_ADDR_VAR 0 2
12922: PUSH
12923: LD_INT 22
12925: PUSH
12926: LD_INT 7
12928: PUSH
12929: EMPTY
12930: LIST
12931: LIST
12932: PUSH
12933: LD_INT 23
12935: PUSH
12936: LD_INT 3
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: PUSH
12943: LD_INT 25
12945: PUSH
12946: LD_INT 1
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PUSH
12953: LD_INT 26
12955: PUSH
12956: LD_INT 1
12958: PUSH
12959: EMPTY
12960: LIST
12961: LIST
12962: PUSH
12963: EMPTY
12964: LIST
12965: LIST
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 69
12973: PUSH
12974: LD_VAR 0 3
12978: DIFF
12979: ST_TO_ADDR
// if tmp then
12980: LD_VAR 0 2
12984: IFFALSE 13000
// result := tmp [ 1 ] ;
12986: LD_ADDR_VAR 0 1
12990: PUSH
12991: LD_VAR 0 2
12995: PUSH
12996: LD_INT 1
12998: ARRAY
12999: ST_TO_ADDR
// end ; end_of_file
13000: LD_VAR 0 1
13004: RET
// export function CustomEvent ( event ) ; begin
13005: LD_INT 0
13007: PPUSH
// end ;
13008: LD_VAR 0 2
13012: RET
// on UnitDestroyed ( un ) do var i , side ;
13013: LD_INT 0
13015: PPUSH
13016: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13017: LD_VAR 0 1
13021: PUSH
13022: LD_INT 22
13024: PUSH
13025: LD_INT 7
13027: PUSH
13028: EMPTY
13029: LIST
13030: LIST
13031: PUSH
13032: LD_INT 2
13034: PUSH
13035: LD_INT 25
13037: PUSH
13038: LD_INT 1
13040: PUSH
13041: EMPTY
13042: LIST
13043: LIST
13044: PUSH
13045: LD_INT 25
13047: PUSH
13048: LD_INT 2
13050: PUSH
13051: EMPTY
13052: LIST
13053: LIST
13054: PUSH
13055: LD_INT 25
13057: PUSH
13058: LD_INT 3
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: PUSH
13065: LD_INT 25
13067: PUSH
13068: LD_INT 4
13070: PUSH
13071: EMPTY
13072: LIST
13073: LIST
13074: PUSH
13075: LD_INT 25
13077: PUSH
13078: LD_INT 5
13080: PUSH
13081: EMPTY
13082: LIST
13083: LIST
13084: PUSH
13085: LD_INT 25
13087: PUSH
13088: LD_INT 8
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: PUSH
13095: LD_INT 25
13097: PUSH
13098: LD_INT 9
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: PUSH
13105: EMPTY
13106: LIST
13107: LIST
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: LIST
13114: PUSH
13115: EMPTY
13116: LIST
13117: LIST
13118: PPUSH
13119: CALL_OW 69
13123: IN
13124: IFFALSE 13140
// loss_counter := loss_counter + 1 ;
13126: LD_ADDR_EXP 13
13130: PUSH
13131: LD_EXP 13
13135: PUSH
13136: LD_INT 1
13138: PLUS
13139: ST_TO_ADDR
// if un = Abdul then
13140: LD_VAR 0 1
13144: PUSH
13145: LD_EXP 55
13149: EQUAL
13150: IFFALSE 13160
// abdul_escaped := false ;
13152: LD_ADDR_EXP 12
13156: PUSH
13157: LD_INT 0
13159: ST_TO_ADDR
// if un in ru_attackers then
13160: LD_VAR 0 1
13164: PUSH
13165: LD_EXP 52
13169: IN
13170: IFFALSE 13188
// ru_attackers := ru_attackers diff un ;
13172: LD_ADDR_EXP 52
13176: PUSH
13177: LD_EXP 52
13181: PUSH
13182: LD_VAR 0 1
13186: DIFF
13187: ST_TO_ADDR
// if un in ar_attackers then
13188: LD_VAR 0 1
13192: PUSH
13193: LD_EXP 10
13197: IN
13198: IFFALSE 13216
// ar_attackers := ar_attackers diff un ;
13200: LD_ADDR_EXP 10
13204: PUSH
13205: LD_EXP 10
13209: PUSH
13210: LD_VAR 0 1
13214: DIFF
13215: ST_TO_ADDR
// if un = JMM then
13216: LD_VAR 0 1
13220: PUSH
13221: LD_EXP 15
13225: EQUAL
13226: IFFALSE 13237
// begin YouLost ( JMM ) ;
13228: LD_STRING JMM
13230: PPUSH
13231: CALL_OW 104
// exit ;
13235: GO 13326
// end ; if un = Burlak then
13237: LD_VAR 0 1
13241: PUSH
13242: LD_EXP 46
13246: EQUAL
13247: IFFALSE 13258
// begin YouLost ( Burlak ) ;
13249: LD_STRING Burlak
13251: PPUSH
13252: CALL_OW 104
// exit ;
13256: GO 13326
// end ; if un = freedom then
13258: LD_VAR 0 1
13262: PUSH
13263: LD_EXP 3
13267: EQUAL
13268: IFFALSE 13279
// begin YouLost ( Destroyed ) ;
13270: LD_STRING Destroyed
13272: PPUSH
13273: CALL_OW 104
// exit ;
13277: GO 13326
// end ; if un = Masha then
13279: LD_VAR 0 1
13283: PUSH
13284: LD_EXP 49
13288: EQUAL
13289: IFFALSE 13298
// ChangeMissionObjectives ( M4b ) ;
13291: LD_STRING M4b
13293: PPUSH
13294: CALL_OW 337
// if un = Mastodont then
13298: LD_VAR 0 1
13302: PUSH
13303: LD_EXP 56
13307: EQUAL
13308: IFFALSE 13317
// ChangeMissionObjectives ( M4a ) ;
13310: LD_STRING M4a
13312: PPUSH
13313: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13317: LD_VAR 0 1
13321: PPUSH
13322: CALL 84559 0 1
// end ;
13326: PPOPN 3
13328: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13329: LD_VAR 0 1
13333: PPUSH
13334: LD_VAR 0 2
13338: PPUSH
13339: CALL 86893 0 2
// end ;
13343: PPOPN 2
13345: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13346: LD_VAR 0 1
13350: PPUSH
13351: CALL 85961 0 1
// end ;
13355: PPOPN 1
13357: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13358: LD_VAR 0 1
13362: PUSH
13363: LD_INT 22
13365: PUSH
13366: LD_INT 7
13368: PUSH
13369: EMPTY
13370: LIST
13371: LIST
13372: PUSH
13373: LD_INT 30
13375: PUSH
13376: LD_INT 0
13378: PUSH
13379: EMPTY
13380: LIST
13381: LIST
13382: PUSH
13383: EMPTY
13384: LIST
13385: LIST
13386: PPUSH
13387: CALL_OW 69
13391: IN
13392: IFFALSE 13431
// begin SetBName ( building , freedom ) ;
13394: LD_VAR 0 1
13398: PPUSH
13399: LD_STRING freedom
13401: PPUSH
13402: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13406: LD_INT 0
13408: PPUSH
13409: LD_INT 7
13411: PPUSH
13412: LD_INT 0
13414: PPUSH
13415: CALL_OW 324
// freedom := building ;
13419: LD_ADDR_EXP 3
13423: PUSH
13424: LD_VAR 0 1
13428: ST_TO_ADDR
// exit ;
13429: GO 13497
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13431: LD_VAR 0 1
13435: PUSH
13436: LD_INT 22
13438: PUSH
13439: LD_INT 7
13441: PUSH
13442: EMPTY
13443: LIST
13444: LIST
13445: PUSH
13446: LD_INT 23
13448: PUSH
13449: LD_INT 3
13451: PUSH
13452: EMPTY
13453: LIST
13454: LIST
13455: PUSH
13456: LD_INT 30
13458: PUSH
13459: LD_INT 6
13461: PUSH
13462: EMPTY
13463: LIST
13464: LIST
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: LIST
13470: PPUSH
13471: CALL_OW 69
13475: IN
13476: IFFALSE 13488
// begin ru_lab_builded := true ;
13478: LD_ADDR_EXP 5
13482: PUSH
13483: LD_INT 1
13485: ST_TO_ADDR
// exit ;
13486: GO 13497
// end ; MCE_BuildingComplete ( building ) ;
13488: LD_VAR 0 1
13492: PPUSH
13493: CALL 86202 0 1
// end ;
13497: PPOPN 1
13499: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13500: LD_VAR 0 1
13504: PPUSH
13505: LD_VAR 0 2
13509: PPUSH
13510: CALL 84255 0 2
// end ;
13514: PPOPN 2
13516: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13517: LD_VAR 0 1
13521: PPUSH
13522: LD_VAR 0 2
13526: PPUSH
13527: LD_VAR 0 3
13531: PPUSH
13532: LD_VAR 0 4
13536: PPUSH
13537: LD_VAR 0 5
13541: PPUSH
13542: CALL 83875 0 5
// end ;
13546: PPOPN 5
13548: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13549: LD_VAR 0 1
13553: PPUSH
13554: LD_VAR 0 2
13558: PPUSH
13559: CALL 83471 0 2
// end ;
13563: PPOPN 2
13565: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
13566: LD_VAR 0 1
13570: PPUSH
13571: CALL_OW 263
13575: PUSH
13576: LD_INT 3
13578: EQUAL
13579: PUSH
13580: LD_VAR 0 2
13584: PPUSH
13585: CALL_OW 263
13589: PUSH
13590: LD_INT 3
13592: EQUAL
13593: OR
13594: IFFALSE 13610
// hack_counter := hack_counter + 1 ;
13596: LD_ADDR_EXP 14
13600: PUSH
13601: LD_EXP 14
13605: PUSH
13606: LD_INT 1
13608: PLUS
13609: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13610: LD_VAR 0 1
13614: PPUSH
13615: LD_VAR 0 2
13619: PPUSH
13620: LD_VAR 0 3
13624: PPUSH
13625: LD_VAR 0 4
13629: PPUSH
13630: CALL 83309 0 4
// end ;
13634: PPOPN 4
13636: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13637: LD_VAR 0 1
13641: PPUSH
13642: LD_VAR 0 2
13646: PPUSH
13647: LD_VAR 0 3
13651: PPUSH
13652: CALL 83084 0 3
// end ;
13656: PPOPN 3
13658: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13659: LD_VAR 0 1
13663: PPUSH
13664: LD_VAR 0 2
13668: PPUSH
13669: CALL 82969 0 2
// end ;
13673: PPOPN 2
13675: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13676: LD_VAR 0 1
13680: PPUSH
13681: LD_VAR 0 2
13685: PPUSH
13686: CALL 87154 0 2
// end ;
13690: PPOPN 2
13692: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13693: LD_VAR 0 1
13697: PPUSH
13698: LD_VAR 0 2
13702: PPUSH
13703: LD_VAR 0 3
13707: PPUSH
13708: LD_VAR 0 4
13712: PPUSH
13713: CALL 87370 0 4
// end ;
13717: PPOPN 4
13719: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13720: LD_VAR 0 1
13724: PPUSH
13725: LD_VAR 0 2
13729: PPUSH
13730: CALL 82778 0 2
// end ;
13734: PPOPN 2
13736: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13737: LD_VAR 0 1
13741: PPUSH
13742: CALL 87653 0 1
// end ; end_of_file
13746: PPOPN 1
13748: END
// every 0 0$30 do var cr , time ;
13749: GO 13751
13751: DISABLE
13752: LD_INT 0
13754: PPUSH
13755: PPUSH
// begin time := 0 0$30 ;
13756: LD_ADDR_VAR 0 2
13760: PUSH
13761: LD_INT 1050
13763: ST_TO_ADDR
// while game do
13764: LD_EXP 2
13768: IFFALSE 13867
// begin wait ( time ) ;
13770: LD_VAR 0 2
13774: PPUSH
13775: CALL_OW 67
// if tick > 2 2$00 then
13779: LD_OWVAR 1
13783: PUSH
13784: LD_INT 4200
13786: GREATER
13787: IFFALSE 13820
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13789: LD_ADDR_VAR 0 2
13793: PUSH
13794: LD_VAR 0 2
13798: PUSH
13799: LD_INT 280
13801: PUSH
13802: LD_INT 420
13804: PUSH
13805: LD_INT 630
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: LIST
13812: PUSH
13813: LD_OWVAR 67
13817: ARRAY
13818: PLUS
13819: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13820: LD_INT 1
13822: PPUSH
13823: LD_INT 5
13825: PPUSH
13826: CALL_OW 12
13830: PPUSH
13831: LD_INT 70
13833: PPUSH
13834: LD_INT 49
13836: PPUSH
13837: LD_INT 25
13839: PPUSH
13840: LD_INT 1
13842: PPUSH
13843: CALL_OW 56
// if time > 5 5$00 then
13847: LD_VAR 0 2
13851: PUSH
13852: LD_INT 10500
13854: GREATER
13855: IFFALSE 13865
// time := 0 0$30 ;
13857: LD_ADDR_VAR 0 2
13861: PUSH
13862: LD_INT 1050
13864: ST_TO_ADDR
// end ;
13865: GO 13764
// end ;
13867: PPOPN 2
13869: END
// every 0 0$30 do var cr , time ;
13870: GO 13872
13872: DISABLE
13873: LD_INT 0
13875: PPUSH
13876: PPUSH
// begin time := 0 0$20 ;
13877: LD_ADDR_VAR 0 2
13881: PUSH
13882: LD_INT 700
13884: ST_TO_ADDR
// while game do
13885: LD_EXP 2
13889: IFFALSE 13978
// begin wait ( time ) ;
13891: LD_VAR 0 2
13895: PPUSH
13896: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13900: LD_ADDR_VAR 0 2
13904: PUSH
13905: LD_VAR 0 2
13909: PUSH
13910: LD_INT 490
13912: PUSH
13913: LD_INT 525
13915: PUSH
13916: LD_INT 560
13918: PUSH
13919: EMPTY
13920: LIST
13921: LIST
13922: LIST
13923: PUSH
13924: LD_OWVAR 67
13928: ARRAY
13929: PLUS
13930: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13931: LD_INT 3
13933: PPUSH
13934: LD_INT 5
13936: PPUSH
13937: CALL_OW 12
13941: PPUSH
13942: LD_INT 26
13944: PPUSH
13945: LD_INT 9
13947: PPUSH
13948: LD_INT 30
13950: PPUSH
13951: LD_INT 1
13953: PPUSH
13954: CALL_OW 56
// if time > 3 3$00 then
13958: LD_VAR 0 2
13962: PUSH
13963: LD_INT 6300
13965: GREATER
13966: IFFALSE 13976
// time := 0 0$20 ;
13968: LD_ADDR_VAR 0 2
13972: PUSH
13973: LD_INT 700
13975: ST_TO_ADDR
// end ;
13976: GO 13885
// end ;
13978: PPOPN 2
13980: END
// every 0 0$30 do var cr , time ;
13981: GO 13983
13983: DISABLE
13984: LD_INT 0
13986: PPUSH
13987: PPUSH
// begin time := 0 0$20 ;
13988: LD_ADDR_VAR 0 2
13992: PUSH
13993: LD_INT 700
13995: ST_TO_ADDR
// while game do
13996: LD_EXP 2
14000: IFFALSE 14125
// begin wait ( time ) ;
14002: LD_VAR 0 2
14006: PPUSH
14007: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14011: LD_ADDR_VAR 0 2
14015: PUSH
14016: LD_VAR 0 2
14020: PUSH
14021: LD_INT 175
14023: PUSH
14024: LD_INT 210
14026: PUSH
14027: LD_INT 280
14029: PUSH
14030: EMPTY
14031: LIST
14032: LIST
14033: LIST
14034: PUSH
14035: LD_OWVAR 67
14039: ARRAY
14040: PLUS
14041: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14042: LD_INT 1
14044: PPUSH
14045: LD_INT 5
14047: PPUSH
14048: CALL_OW 12
14052: PPUSH
14053: LD_INT 179
14055: PPUSH
14056: LD_INT 101
14058: PPUSH
14059: LD_INT 20
14061: PPUSH
14062: LD_INT 1
14064: PPUSH
14065: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14069: LD_INT 350
14071: PPUSH
14072: LD_INT 525
14074: PPUSH
14075: CALL_OW 12
14079: PPUSH
14080: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14084: LD_INT 1
14086: PPUSH
14087: LD_INT 5
14089: PPUSH
14090: CALL_OW 12
14094: PPUSH
14095: LD_INT 9
14097: PPUSH
14098: LD_INT 1
14100: PPUSH
14101: CALL_OW 55
// if time > 4 4$00 then
14105: LD_VAR 0 2
14109: PUSH
14110: LD_INT 8400
14112: GREATER
14113: IFFALSE 14123
// time := 0 0$30 ;
14115: LD_ADDR_VAR 0 2
14119: PUSH
14120: LD_INT 1050
14122: ST_TO_ADDR
// end ;
14123: GO 13996
// end ;
14125: PPOPN 2
14127: END
// every 0 0$30 do var cr , time ;
14128: GO 14130
14130: DISABLE
14131: LD_INT 0
14133: PPUSH
14134: PPUSH
// begin time := 0 0$10 ;
14135: LD_ADDR_VAR 0 2
14139: PUSH
14140: LD_INT 350
14142: ST_TO_ADDR
// while game do
14143: LD_EXP 2
14147: IFFALSE 14281
// begin wait ( time ) ;
14149: LD_VAR 0 2
14153: PPUSH
14154: CALL_OW 67
// time := time + 0 0$10 ;
14158: LD_ADDR_VAR 0 2
14162: PUSH
14163: LD_VAR 0 2
14167: PUSH
14168: LD_INT 350
14170: PLUS
14171: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14172: LD_INT 1
14174: PPUSH
14175: LD_INT 5
14177: PPUSH
14178: CALL_OW 12
14182: PPUSH
14183: LD_INT 11
14185: PPUSH
14186: LD_INT 1
14188: PPUSH
14189: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14193: LD_ADDR_VAR 0 1
14197: PUSH
14198: LD_INT 1
14200: PPUSH
14201: LD_INT 3
14203: PPUSH
14204: CALL_OW 12
14208: ST_TO_ADDR
// if cr = 1 then
14209: LD_VAR 0 1
14213: PUSH
14214: LD_INT 1
14216: EQUAL
14217: IFFALSE 14261
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14219: LD_INT 700
14221: PPUSH
14222: LD_INT 1575
14224: PPUSH
14225: CALL_OW 12
14229: PPUSH
14230: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14234: LD_INT 1
14236: PPUSH
14237: LD_INT 5
14239: PPUSH
14240: CALL_OW 12
14244: PPUSH
14245: LD_INT 34
14247: PPUSH
14248: LD_INT 50
14250: PPUSH
14251: LD_INT 7
14253: PPUSH
14254: LD_INT 1
14256: PPUSH
14257: CALL_OW 56
// end ; if time > 8 8$00 then
14261: LD_VAR 0 2
14265: PUSH
14266: LD_INT 16800
14268: GREATER
14269: IFFALSE 14279
// time := 0 0$40 ;
14271: LD_ADDR_VAR 0 2
14275: PUSH
14276: LD_INT 1400
14278: ST_TO_ADDR
// end ;
14279: GO 14143
// end ; end_of_file
14281: PPOPN 2
14283: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14284: LD_INT 0
14286: PPUSH
14287: PPUSH
// if exist_mode then
14288: LD_VAR 0 2
14292: IFFALSE 14317
// unit := CreateCharacter ( prefix & ident ) else
14294: LD_ADDR_VAR 0 5
14298: PUSH
14299: LD_VAR 0 3
14303: PUSH
14304: LD_VAR 0 1
14308: STR
14309: PPUSH
14310: CALL_OW 34
14314: ST_TO_ADDR
14315: GO 14332
// unit := NewCharacter ( ident ) ;
14317: LD_ADDR_VAR 0 5
14321: PUSH
14322: LD_VAR 0 1
14326: PPUSH
14327: CALL_OW 25
14331: ST_TO_ADDR
// result := unit ;
14332: LD_ADDR_VAR 0 4
14336: PUSH
14337: LD_VAR 0 5
14341: ST_TO_ADDR
// end ;
14342: LD_VAR 0 4
14346: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14347: LD_INT 0
14349: PPUSH
14350: PPUSH
// if not side or not nation then
14351: LD_VAR 0 1
14355: NOT
14356: PUSH
14357: LD_VAR 0 2
14361: NOT
14362: OR
14363: IFFALSE 14367
// exit ;
14365: GO 15011
// case nation of nation_american :
14367: LD_VAR 0 2
14371: PUSH
14372: LD_INT 1
14374: DOUBLE
14375: EQUAL
14376: IFTRUE 14380
14378: GO 14554
14380: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
14381: LD_ADDR_VAR 0 4
14385: PUSH
14386: LD_INT 35
14388: PUSH
14389: LD_INT 45
14391: PUSH
14392: LD_INT 46
14394: PUSH
14395: LD_INT 47
14397: PUSH
14398: LD_INT 1
14400: PUSH
14401: LD_INT 2
14403: PUSH
14404: LD_INT 6
14406: PUSH
14407: LD_INT 15
14409: PUSH
14410: LD_INT 16
14412: PUSH
14413: LD_INT 7
14415: PUSH
14416: LD_INT 12
14418: PUSH
14419: LD_INT 13
14421: PUSH
14422: LD_INT 10
14424: PUSH
14425: LD_INT 14
14427: PUSH
14428: LD_INT 20
14430: PUSH
14431: LD_INT 21
14433: PUSH
14434: LD_INT 22
14436: PUSH
14437: LD_INT 25
14439: PUSH
14440: LD_INT 32
14442: PUSH
14443: LD_INT 27
14445: PUSH
14446: LD_INT 36
14448: PUSH
14449: LD_INT 69
14451: PUSH
14452: LD_INT 39
14454: PUSH
14455: LD_INT 34
14457: PUSH
14458: LD_INT 40
14460: PUSH
14461: LD_INT 48
14463: PUSH
14464: LD_INT 49
14466: PUSH
14467: LD_INT 50
14469: PUSH
14470: LD_INT 51
14472: PUSH
14473: LD_INT 52
14475: PUSH
14476: LD_INT 53
14478: PUSH
14479: LD_INT 54
14481: PUSH
14482: LD_INT 55
14484: PUSH
14485: LD_INT 56
14487: PUSH
14488: LD_INT 57
14490: PUSH
14491: LD_INT 58
14493: PUSH
14494: LD_INT 59
14496: PUSH
14497: LD_INT 60
14499: PUSH
14500: LD_INT 61
14502: PUSH
14503: LD_INT 62
14505: PUSH
14506: LD_INT 80
14508: PUSH
14509: EMPTY
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: LIST
14521: LIST
14522: LIST
14523: LIST
14524: LIST
14525: LIST
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: ST_TO_ADDR
14552: GO 14935
14554: LD_INT 2
14556: DOUBLE
14557: EQUAL
14558: IFTRUE 14562
14560: GO 14744
14562: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
14563: LD_ADDR_VAR 0 4
14567: PUSH
14568: LD_INT 35
14570: PUSH
14571: LD_INT 45
14573: PUSH
14574: LD_INT 46
14576: PUSH
14577: LD_INT 47
14579: PUSH
14580: LD_INT 70
14582: PUSH
14583: LD_INT 1
14585: PUSH
14586: LD_INT 11
14588: PUSH
14589: LD_INT 3
14591: PUSH
14592: LD_INT 4
14594: PUSH
14595: LD_INT 5
14597: PUSH
14598: LD_INT 6
14600: PUSH
14601: LD_INT 15
14603: PUSH
14604: LD_INT 18
14606: PUSH
14607: LD_INT 7
14609: PUSH
14610: LD_INT 17
14612: PUSH
14613: LD_INT 8
14615: PUSH
14616: LD_INT 20
14618: PUSH
14619: LD_INT 21
14621: PUSH
14622: LD_INT 22
14624: PUSH
14625: LD_INT 72
14627: PUSH
14628: LD_INT 26
14630: PUSH
14631: LD_INT 69
14633: PUSH
14634: LD_INT 39
14636: PUSH
14637: LD_INT 40
14639: PUSH
14640: LD_INT 41
14642: PUSH
14643: LD_INT 42
14645: PUSH
14646: LD_INT 43
14648: PUSH
14649: LD_INT 48
14651: PUSH
14652: LD_INT 49
14654: PUSH
14655: LD_INT 50
14657: PUSH
14658: LD_INT 51
14660: PUSH
14661: LD_INT 52
14663: PUSH
14664: LD_INT 53
14666: PUSH
14667: LD_INT 54
14669: PUSH
14670: LD_INT 55
14672: PUSH
14673: LD_INT 56
14675: PUSH
14676: LD_INT 60
14678: PUSH
14679: LD_INT 61
14681: PUSH
14682: LD_INT 62
14684: PUSH
14685: LD_INT 66
14687: PUSH
14688: LD_INT 67
14690: PUSH
14691: LD_INT 68
14693: PUSH
14694: LD_INT 81
14696: PUSH
14697: EMPTY
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: LIST
14706: LIST
14707: LIST
14708: LIST
14709: LIST
14710: LIST
14711: LIST
14712: LIST
14713: LIST
14714: LIST
14715: LIST
14716: LIST
14717: LIST
14718: LIST
14719: LIST
14720: LIST
14721: LIST
14722: LIST
14723: LIST
14724: LIST
14725: LIST
14726: LIST
14727: LIST
14728: LIST
14729: LIST
14730: LIST
14731: LIST
14732: LIST
14733: LIST
14734: LIST
14735: LIST
14736: LIST
14737: LIST
14738: LIST
14739: LIST
14740: LIST
14741: ST_TO_ADDR
14742: GO 14935
14744: LD_INT 3
14746: DOUBLE
14747: EQUAL
14748: IFTRUE 14752
14750: GO 14934
14752: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14753: LD_ADDR_VAR 0 4
14757: PUSH
14758: LD_INT 46
14760: PUSH
14761: LD_INT 47
14763: PUSH
14764: LD_INT 1
14766: PUSH
14767: LD_INT 2
14769: PUSH
14770: LD_INT 11
14772: PUSH
14773: LD_INT 9
14775: PUSH
14776: LD_INT 20
14778: PUSH
14779: LD_INT 19
14781: PUSH
14782: LD_INT 21
14784: PUSH
14785: LD_INT 24
14787: PUSH
14788: LD_INT 22
14790: PUSH
14791: LD_INT 25
14793: PUSH
14794: LD_INT 28
14796: PUSH
14797: LD_INT 29
14799: PUSH
14800: LD_INT 30
14802: PUSH
14803: LD_INT 31
14805: PUSH
14806: LD_INT 37
14808: PUSH
14809: LD_INT 38
14811: PUSH
14812: LD_INT 32
14814: PUSH
14815: LD_INT 27
14817: PUSH
14818: LD_INT 33
14820: PUSH
14821: LD_INT 69
14823: PUSH
14824: LD_INT 39
14826: PUSH
14827: LD_INT 34
14829: PUSH
14830: LD_INT 40
14832: PUSH
14833: LD_INT 71
14835: PUSH
14836: LD_INT 23
14838: PUSH
14839: LD_INT 44
14841: PUSH
14842: LD_INT 48
14844: PUSH
14845: LD_INT 49
14847: PUSH
14848: LD_INT 50
14850: PUSH
14851: LD_INT 51
14853: PUSH
14854: LD_INT 52
14856: PUSH
14857: LD_INT 53
14859: PUSH
14860: LD_INT 54
14862: PUSH
14863: LD_INT 55
14865: PUSH
14866: LD_INT 56
14868: PUSH
14869: LD_INT 57
14871: PUSH
14872: LD_INT 58
14874: PUSH
14875: LD_INT 59
14877: PUSH
14878: LD_INT 63
14880: PUSH
14881: LD_INT 64
14883: PUSH
14884: LD_INT 65
14886: PUSH
14887: EMPTY
14888: LIST
14889: LIST
14890: LIST
14891: LIST
14892: LIST
14893: LIST
14894: LIST
14895: LIST
14896: LIST
14897: LIST
14898: LIST
14899: LIST
14900: LIST
14901: LIST
14902: LIST
14903: LIST
14904: LIST
14905: LIST
14906: LIST
14907: LIST
14908: LIST
14909: LIST
14910: LIST
14911: LIST
14912: LIST
14913: LIST
14914: LIST
14915: LIST
14916: LIST
14917: LIST
14918: LIST
14919: LIST
14920: LIST
14921: LIST
14922: LIST
14923: LIST
14924: LIST
14925: LIST
14926: LIST
14927: LIST
14928: LIST
14929: LIST
14930: LIST
14931: ST_TO_ADDR
14932: GO 14935
14934: POP
// if state > - 1 and state < 3 then
14935: LD_VAR 0 3
14939: PUSH
14940: LD_INT 1
14942: NEG
14943: GREATER
14944: PUSH
14945: LD_VAR 0 3
14949: PUSH
14950: LD_INT 3
14952: LESS
14953: AND
14954: IFFALSE 15011
// for i in result do
14956: LD_ADDR_VAR 0 5
14960: PUSH
14961: LD_VAR 0 4
14965: PUSH
14966: FOR_IN
14967: IFFALSE 15009
// if GetTech ( i , side ) <> state then
14969: LD_VAR 0 5
14973: PPUSH
14974: LD_VAR 0 1
14978: PPUSH
14979: CALL_OW 321
14983: PUSH
14984: LD_VAR 0 3
14988: NONEQUAL
14989: IFFALSE 15007
// result := result diff i ;
14991: LD_ADDR_VAR 0 4
14995: PUSH
14996: LD_VAR 0 4
15000: PUSH
15001: LD_VAR 0 5
15005: DIFF
15006: ST_TO_ADDR
15007: GO 14966
15009: POP
15010: POP
// end ;
15011: LD_VAR 0 4
15015: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15016: LD_INT 0
15018: PPUSH
15019: PPUSH
15020: PPUSH
// result := true ;
15021: LD_ADDR_VAR 0 3
15025: PUSH
15026: LD_INT 1
15028: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15029: LD_ADDR_VAR 0 5
15033: PUSH
15034: LD_VAR 0 2
15038: PPUSH
15039: CALL_OW 480
15043: ST_TO_ADDR
// if not tmp then
15044: LD_VAR 0 5
15048: NOT
15049: IFFALSE 15053
// exit ;
15051: GO 15102
// for i in tmp do
15053: LD_ADDR_VAR 0 4
15057: PUSH
15058: LD_VAR 0 5
15062: PUSH
15063: FOR_IN
15064: IFFALSE 15100
// if GetTech ( i , side ) <> state_researched then
15066: LD_VAR 0 4
15070: PPUSH
15071: LD_VAR 0 1
15075: PPUSH
15076: CALL_OW 321
15080: PUSH
15081: LD_INT 2
15083: NONEQUAL
15084: IFFALSE 15098
// begin result := false ;
15086: LD_ADDR_VAR 0 3
15090: PUSH
15091: LD_INT 0
15093: ST_TO_ADDR
// exit ;
15094: POP
15095: POP
15096: GO 15102
// end ;
15098: GO 15063
15100: POP
15101: POP
// end ;
15102: LD_VAR 0 3
15106: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15107: LD_INT 0
15109: PPUSH
15110: PPUSH
15111: PPUSH
15112: PPUSH
15113: PPUSH
15114: PPUSH
15115: PPUSH
15116: PPUSH
15117: PPUSH
15118: PPUSH
15119: PPUSH
15120: PPUSH
15121: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15122: LD_VAR 0 1
15126: NOT
15127: PUSH
15128: LD_VAR 0 1
15132: PPUSH
15133: CALL_OW 257
15137: PUSH
15138: LD_INT 9
15140: NONEQUAL
15141: OR
15142: IFFALSE 15146
// exit ;
15144: GO 15719
// side := GetSide ( unit ) ;
15146: LD_ADDR_VAR 0 9
15150: PUSH
15151: LD_VAR 0 1
15155: PPUSH
15156: CALL_OW 255
15160: ST_TO_ADDR
// tech_space := tech_spacanom ;
15161: LD_ADDR_VAR 0 12
15165: PUSH
15166: LD_INT 29
15168: ST_TO_ADDR
// tech_time := tech_taurad ;
15169: LD_ADDR_VAR 0 13
15173: PUSH
15174: LD_INT 28
15176: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15177: LD_ADDR_VAR 0 11
15181: PUSH
15182: LD_VAR 0 1
15186: PPUSH
15187: CALL_OW 310
15191: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15192: LD_VAR 0 11
15196: PPUSH
15197: CALL_OW 247
15201: PUSH
15202: LD_INT 2
15204: EQUAL
15205: IFFALSE 15209
// exit ;
15207: GO 15719
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15209: LD_ADDR_VAR 0 8
15213: PUSH
15214: LD_INT 81
15216: PUSH
15217: LD_VAR 0 9
15221: PUSH
15222: EMPTY
15223: LIST
15224: LIST
15225: PUSH
15226: LD_INT 3
15228: PUSH
15229: LD_INT 21
15231: PUSH
15232: LD_INT 3
15234: PUSH
15235: EMPTY
15236: LIST
15237: LIST
15238: PUSH
15239: EMPTY
15240: LIST
15241: LIST
15242: PUSH
15243: EMPTY
15244: LIST
15245: LIST
15246: PPUSH
15247: CALL_OW 69
15251: ST_TO_ADDR
// if not tmp then
15252: LD_VAR 0 8
15256: NOT
15257: IFFALSE 15261
// exit ;
15259: GO 15719
// if in_unit then
15261: LD_VAR 0 11
15265: IFFALSE 15289
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15267: LD_ADDR_VAR 0 10
15271: PUSH
15272: LD_VAR 0 8
15276: PPUSH
15277: LD_VAR 0 11
15281: PPUSH
15282: CALL_OW 74
15286: ST_TO_ADDR
15287: GO 15309
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15289: LD_ADDR_VAR 0 10
15293: PUSH
15294: LD_VAR 0 8
15298: PPUSH
15299: LD_VAR 0 1
15303: PPUSH
15304: CALL_OW 74
15308: ST_TO_ADDR
// if not enemy then
15309: LD_VAR 0 10
15313: NOT
15314: IFFALSE 15318
// exit ;
15316: GO 15719
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15318: LD_VAR 0 11
15322: PUSH
15323: LD_VAR 0 11
15327: PPUSH
15328: LD_VAR 0 10
15332: PPUSH
15333: CALL_OW 296
15337: PUSH
15338: LD_INT 13
15340: GREATER
15341: AND
15342: PUSH
15343: LD_VAR 0 1
15347: PPUSH
15348: LD_VAR 0 10
15352: PPUSH
15353: CALL_OW 296
15357: PUSH
15358: LD_INT 12
15360: GREATER
15361: OR
15362: IFFALSE 15366
// exit ;
15364: GO 15719
// missile := [ 1 ] ;
15366: LD_ADDR_VAR 0 14
15370: PUSH
15371: LD_INT 1
15373: PUSH
15374: EMPTY
15375: LIST
15376: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15377: LD_VAR 0 9
15381: PPUSH
15382: LD_VAR 0 12
15386: PPUSH
15387: CALL_OW 325
15391: IFFALSE 15420
// missile := Insert ( missile , missile + 1 , 2 ) ;
15393: LD_ADDR_VAR 0 14
15397: PUSH
15398: LD_VAR 0 14
15402: PPUSH
15403: LD_VAR 0 14
15407: PUSH
15408: LD_INT 1
15410: PLUS
15411: PPUSH
15412: LD_INT 2
15414: PPUSH
15415: CALL_OW 2
15419: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15420: LD_VAR 0 9
15424: PPUSH
15425: LD_VAR 0 13
15429: PPUSH
15430: CALL_OW 325
15434: PUSH
15435: LD_VAR 0 10
15439: PPUSH
15440: CALL_OW 255
15444: PPUSH
15445: LD_VAR 0 13
15449: PPUSH
15450: CALL_OW 325
15454: NOT
15455: AND
15456: IFFALSE 15485
// missile := Insert ( missile , missile + 1 , 3 ) ;
15458: LD_ADDR_VAR 0 14
15462: PUSH
15463: LD_VAR 0 14
15467: PPUSH
15468: LD_VAR 0 14
15472: PUSH
15473: LD_INT 1
15475: PLUS
15476: PPUSH
15477: LD_INT 3
15479: PPUSH
15480: CALL_OW 2
15484: ST_TO_ADDR
// if missile < 2 then
15485: LD_VAR 0 14
15489: PUSH
15490: LD_INT 2
15492: LESS
15493: IFFALSE 15497
// exit ;
15495: GO 15719
// x := GetX ( enemy ) ;
15497: LD_ADDR_VAR 0 4
15501: PUSH
15502: LD_VAR 0 10
15506: PPUSH
15507: CALL_OW 250
15511: ST_TO_ADDR
// y := GetY ( enemy ) ;
15512: LD_ADDR_VAR 0 5
15516: PUSH
15517: LD_VAR 0 10
15521: PPUSH
15522: CALL_OW 251
15526: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15527: LD_ADDR_VAR 0 6
15531: PUSH
15532: LD_VAR 0 4
15536: PUSH
15537: LD_INT 1
15539: NEG
15540: PPUSH
15541: LD_INT 1
15543: PPUSH
15544: CALL_OW 12
15548: PLUS
15549: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15550: LD_ADDR_VAR 0 7
15554: PUSH
15555: LD_VAR 0 5
15559: PUSH
15560: LD_INT 1
15562: NEG
15563: PPUSH
15564: LD_INT 1
15566: PPUSH
15567: CALL_OW 12
15571: PLUS
15572: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15573: LD_VAR 0 6
15577: PPUSH
15578: LD_VAR 0 7
15582: PPUSH
15583: CALL_OW 488
15587: NOT
15588: IFFALSE 15610
// begin _x := x ;
15590: LD_ADDR_VAR 0 6
15594: PUSH
15595: LD_VAR 0 4
15599: ST_TO_ADDR
// _y := y ;
15600: LD_ADDR_VAR 0 7
15604: PUSH
15605: LD_VAR 0 5
15609: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15610: LD_ADDR_VAR 0 3
15614: PUSH
15615: LD_INT 1
15617: PPUSH
15618: LD_VAR 0 14
15622: PPUSH
15623: CALL_OW 12
15627: ST_TO_ADDR
// case i of 1 :
15628: LD_VAR 0 3
15632: PUSH
15633: LD_INT 1
15635: DOUBLE
15636: EQUAL
15637: IFTRUE 15641
15639: GO 15658
15641: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15642: LD_VAR 0 1
15646: PPUSH
15647: LD_VAR 0 10
15651: PPUSH
15652: CALL_OW 115
15656: GO 15719
15658: LD_INT 2
15660: DOUBLE
15661: EQUAL
15662: IFTRUE 15666
15664: GO 15688
15666: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15667: LD_VAR 0 1
15671: PPUSH
15672: LD_VAR 0 6
15676: PPUSH
15677: LD_VAR 0 7
15681: PPUSH
15682: CALL_OW 153
15686: GO 15719
15688: LD_INT 3
15690: DOUBLE
15691: EQUAL
15692: IFTRUE 15696
15694: GO 15718
15696: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15697: LD_VAR 0 1
15701: PPUSH
15702: LD_VAR 0 6
15706: PPUSH
15707: LD_VAR 0 7
15711: PPUSH
15712: CALL_OW 154
15716: GO 15719
15718: POP
// end ;
15719: LD_VAR 0 2
15723: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15724: LD_INT 0
15726: PPUSH
15727: PPUSH
15728: PPUSH
15729: PPUSH
15730: PPUSH
15731: PPUSH
// if not unit or not building then
15732: LD_VAR 0 1
15736: NOT
15737: PUSH
15738: LD_VAR 0 2
15742: NOT
15743: OR
15744: IFFALSE 15748
// exit ;
15746: GO 15906
// x := GetX ( building ) ;
15748: LD_ADDR_VAR 0 5
15752: PUSH
15753: LD_VAR 0 2
15757: PPUSH
15758: CALL_OW 250
15762: ST_TO_ADDR
// y := GetY ( building ) ;
15763: LD_ADDR_VAR 0 6
15767: PUSH
15768: LD_VAR 0 2
15772: PPUSH
15773: CALL_OW 251
15777: ST_TO_ADDR
// for i = 0 to 5 do
15778: LD_ADDR_VAR 0 4
15782: PUSH
15783: DOUBLE
15784: LD_INT 0
15786: DEC
15787: ST_TO_ADDR
15788: LD_INT 5
15790: PUSH
15791: FOR_TO
15792: IFFALSE 15904
// begin _x := ShiftX ( x , i , 3 ) ;
15794: LD_ADDR_VAR 0 7
15798: PUSH
15799: LD_VAR 0 5
15803: PPUSH
15804: LD_VAR 0 4
15808: PPUSH
15809: LD_INT 3
15811: PPUSH
15812: CALL_OW 272
15816: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15817: LD_ADDR_VAR 0 8
15821: PUSH
15822: LD_VAR 0 6
15826: PPUSH
15827: LD_VAR 0 4
15831: PPUSH
15832: LD_INT 3
15834: PPUSH
15835: CALL_OW 273
15839: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15840: LD_VAR 0 7
15844: PPUSH
15845: LD_VAR 0 8
15849: PPUSH
15850: CALL_OW 488
15854: NOT
15855: IFFALSE 15859
// continue ;
15857: GO 15791
// if HexInfo ( _x , _y ) = 0 then
15859: LD_VAR 0 7
15863: PPUSH
15864: LD_VAR 0 8
15868: PPUSH
15869: CALL_OW 428
15873: PUSH
15874: LD_INT 0
15876: EQUAL
15877: IFFALSE 15902
// begin ComMoveXY ( unit , _x , _y ) ;
15879: LD_VAR 0 1
15883: PPUSH
15884: LD_VAR 0 7
15888: PPUSH
15889: LD_VAR 0 8
15893: PPUSH
15894: CALL_OW 111
// exit ;
15898: POP
15899: POP
15900: GO 15906
// end ; end ;
15902: GO 15791
15904: POP
15905: POP
// end ;
15906: LD_VAR 0 3
15910: RET
// export function ScanBase ( side , base_area ) ; begin
15911: LD_INT 0
15913: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15914: LD_ADDR_VAR 0 3
15918: PUSH
15919: LD_VAR 0 2
15923: PPUSH
15924: LD_INT 81
15926: PUSH
15927: LD_VAR 0 1
15931: PUSH
15932: EMPTY
15933: LIST
15934: LIST
15935: PPUSH
15936: CALL_OW 70
15940: ST_TO_ADDR
// end ;
15941: LD_VAR 0 3
15945: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15946: LD_INT 0
15948: PPUSH
15949: PPUSH
15950: PPUSH
15951: PPUSH
15952: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15953: LD_VAR 0 1
15957: NOT
15958: PUSH
15959: LD_EXP 59
15963: PUSH
15964: LD_VAR 0 1
15968: ARRAY
15969: NOT
15970: OR
15971: PUSH
15972: LD_VAR 0 2
15976: NOT
15977: OR
15978: PUSH
15979: LD_VAR 0 3
15983: NOT
15984: OR
15985: IFFALSE 15989
// exit ;
15987: GO 16502
// side := mc_sides [ base ] ;
15989: LD_ADDR_VAR 0 6
15993: PUSH
15994: LD_EXP 85
15998: PUSH
15999: LD_VAR 0 1
16003: ARRAY
16004: ST_TO_ADDR
// if not side then
16005: LD_VAR 0 6
16009: NOT
16010: IFFALSE 16014
// exit ;
16012: GO 16502
// for i in solds do
16014: LD_ADDR_VAR 0 7
16018: PUSH
16019: LD_VAR 0 2
16023: PUSH
16024: FOR_IN
16025: IFFALSE 16086
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
16027: LD_VAR 0 7
16031: PPUSH
16032: CALL_OW 310
16036: PPUSH
16037: CALL_OW 266
16041: PUSH
16042: LD_INT 32
16044: PUSH
16045: LD_INT 31
16047: PUSH
16048: EMPTY
16049: LIST
16050: LIST
16051: IN
16052: IFFALSE 16072
// solds := solds diff i else
16054: LD_ADDR_VAR 0 2
16058: PUSH
16059: LD_VAR 0 2
16063: PUSH
16064: LD_VAR 0 7
16068: DIFF
16069: ST_TO_ADDR
16070: GO 16084
// SetTag ( i , 18 ) ;
16072: LD_VAR 0 7
16076: PPUSH
16077: LD_INT 18
16079: PPUSH
16080: CALL_OW 109
16084: GO 16024
16086: POP
16087: POP
// if not solds then
16088: LD_VAR 0 2
16092: NOT
16093: IFFALSE 16097
// exit ;
16095: GO 16502
// repeat wait ( 0 0$1 ) ;
16097: LD_INT 35
16099: PPUSH
16100: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
16104: LD_ADDR_VAR 0 5
16108: PUSH
16109: LD_VAR 0 6
16113: PPUSH
16114: LD_VAR 0 3
16118: PPUSH
16119: CALL 15911 0 2
16123: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16124: LD_EXP 59
16128: PUSH
16129: LD_VAR 0 1
16133: ARRAY
16134: NOT
16135: PUSH
16136: LD_EXP 59
16140: PUSH
16141: LD_VAR 0 1
16145: ARRAY
16146: PUSH
16147: EMPTY
16148: EQUAL
16149: OR
16150: IFFALSE 16187
// begin for i in solds do
16152: LD_ADDR_VAR 0 7
16156: PUSH
16157: LD_VAR 0 2
16161: PUSH
16162: FOR_IN
16163: IFFALSE 16176
// ComStop ( i ) ;
16165: LD_VAR 0 7
16169: PPUSH
16170: CALL_OW 141
16174: GO 16162
16176: POP
16177: POP
// solds := [ ] ;
16178: LD_ADDR_VAR 0 2
16182: PUSH
16183: EMPTY
16184: ST_TO_ADDR
// exit ;
16185: GO 16502
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
16187: LD_VAR 0 5
16191: NOT
16192: PUSH
16193: LD_VAR 0 5
16197: PUSH
16198: LD_INT 3
16200: GREATER
16201: OR
16202: PUSH
16203: LD_EXP 81
16207: PUSH
16208: LD_VAR 0 1
16212: ARRAY
16213: OR
16214: IFFALSE 16255
// begin for i in solds do
16216: LD_ADDR_VAR 0 7
16220: PUSH
16221: LD_VAR 0 2
16225: PUSH
16226: FOR_IN
16227: IFFALSE 16251
// if HasTask ( i ) then
16229: LD_VAR 0 7
16233: PPUSH
16234: CALL_OW 314
16238: IFFALSE 16249
// ComStop ( i ) ;
16240: LD_VAR 0 7
16244: PPUSH
16245: CALL_OW 141
16249: GO 16226
16251: POP
16252: POP
// break ;
16253: GO 16490
// end ; for i in solds do
16255: LD_ADDR_VAR 0 7
16259: PUSH
16260: LD_VAR 0 2
16264: PUSH
16265: FOR_IN
16266: IFFALSE 16482
// begin if IsInUnit ( i ) then
16268: LD_VAR 0 7
16272: PPUSH
16273: CALL_OW 310
16277: IFFALSE 16288
// ComExitBuilding ( i ) ;
16279: LD_VAR 0 7
16283: PPUSH
16284: CALL_OW 122
// if GetLives ( i ) > 333 then
16288: LD_VAR 0 7
16292: PPUSH
16293: CALL_OW 256
16297: PUSH
16298: LD_INT 333
16300: GREATER
16301: IFFALSE 16329
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
16303: LD_VAR 0 7
16307: PPUSH
16308: LD_VAR 0 5
16312: PPUSH
16313: LD_VAR 0 7
16317: PPUSH
16318: CALL_OW 74
16322: PPUSH
16323: CALL_OW 115
16327: GO 16480
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
16329: LD_ADDR_VAR 0 8
16333: PUSH
16334: LD_EXP 59
16338: PUSH
16339: LD_VAR 0 1
16343: ARRAY
16344: PPUSH
16345: LD_INT 2
16347: PUSH
16348: LD_INT 30
16350: PUSH
16351: LD_INT 0
16353: PUSH
16354: EMPTY
16355: LIST
16356: LIST
16357: PUSH
16358: LD_INT 30
16360: PUSH
16361: LD_INT 1
16363: PUSH
16364: EMPTY
16365: LIST
16366: LIST
16367: PUSH
16368: LD_INT 30
16370: PUSH
16371: LD_INT 6
16373: PUSH
16374: EMPTY
16375: LIST
16376: LIST
16377: PUSH
16378: EMPTY
16379: LIST
16380: LIST
16381: LIST
16382: LIST
16383: PPUSH
16384: CALL_OW 72
16388: PPUSH
16389: LD_VAR 0 7
16393: PPUSH
16394: CALL_OW 74
16398: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
16399: LD_VAR 0 7
16403: PPUSH
16404: LD_VAR 0 8
16408: PPUSH
16409: CALL_OW 250
16413: PPUSH
16414: LD_INT 3
16416: PPUSH
16417: LD_INT 5
16419: PPUSH
16420: CALL_OW 272
16424: PPUSH
16425: LD_VAR 0 8
16429: PPUSH
16430: CALL_OW 251
16434: PPUSH
16435: LD_INT 3
16437: PPUSH
16438: LD_INT 5
16440: PPUSH
16441: CALL_OW 273
16445: PPUSH
16446: CALL_OW 111
// SetTag ( i , 0 ) ;
16450: LD_VAR 0 7
16454: PPUSH
16455: LD_INT 0
16457: PPUSH
16458: CALL_OW 109
// solds := solds diff i ;
16462: LD_ADDR_VAR 0 2
16466: PUSH
16467: LD_VAR 0 2
16471: PUSH
16472: LD_VAR 0 7
16476: DIFF
16477: ST_TO_ADDR
// continue ;
16478: GO 16265
// end ; end ;
16480: GO 16265
16482: POP
16483: POP
// until solds ;
16484: LD_VAR 0 2
16488: IFFALSE 16097
// MC_Reset ( base , 18 ) ;
16490: LD_VAR 0 1
16494: PPUSH
16495: LD_INT 18
16497: PPUSH
16498: CALL 61550 0 2
// end ;
16502: LD_VAR 0 4
16506: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16507: LD_INT 0
16509: PPUSH
16510: PPUSH
16511: PPUSH
16512: PPUSH
16513: PPUSH
16514: PPUSH
16515: PPUSH
16516: PPUSH
16517: PPUSH
16518: PPUSH
16519: PPUSH
16520: PPUSH
16521: PPUSH
16522: PPUSH
16523: PPUSH
16524: PPUSH
16525: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16526: LD_ADDR_VAR 0 13
16530: PUSH
16531: LD_EXP 59
16535: PUSH
16536: LD_VAR 0 1
16540: ARRAY
16541: PPUSH
16542: LD_INT 25
16544: PUSH
16545: LD_INT 3
16547: PUSH
16548: EMPTY
16549: LIST
16550: LIST
16551: PPUSH
16552: CALL_OW 72
16556: ST_TO_ADDR
// if mc_remote_driver [ base ] then
16557: LD_EXP 99
16561: PUSH
16562: LD_VAR 0 1
16566: ARRAY
16567: IFFALSE 16591
// mechs := mechs diff mc_remote_driver [ base ] ;
16569: LD_ADDR_VAR 0 13
16573: PUSH
16574: LD_VAR 0 13
16578: PUSH
16579: LD_EXP 99
16583: PUSH
16584: LD_VAR 0 1
16588: ARRAY
16589: DIFF
16590: ST_TO_ADDR
// for i in mechs do
16591: LD_ADDR_VAR 0 5
16595: PUSH
16596: LD_VAR 0 13
16600: PUSH
16601: FOR_IN
16602: IFFALSE 16637
// if GetTag ( i ) > 0 then
16604: LD_VAR 0 5
16608: PPUSH
16609: CALL_OW 110
16613: PUSH
16614: LD_INT 0
16616: GREATER
16617: IFFALSE 16635
// mechs := mechs diff i ;
16619: LD_ADDR_VAR 0 13
16623: PUSH
16624: LD_VAR 0 13
16628: PUSH
16629: LD_VAR 0 5
16633: DIFF
16634: ST_TO_ADDR
16635: GO 16601
16637: POP
16638: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16639: LD_ADDR_VAR 0 9
16643: PUSH
16644: LD_EXP 59
16648: PUSH
16649: LD_VAR 0 1
16653: ARRAY
16654: PPUSH
16655: LD_INT 2
16657: PUSH
16658: LD_INT 25
16660: PUSH
16661: LD_INT 1
16663: PUSH
16664: EMPTY
16665: LIST
16666: LIST
16667: PUSH
16668: LD_INT 25
16670: PUSH
16671: LD_INT 5
16673: PUSH
16674: EMPTY
16675: LIST
16676: LIST
16677: PUSH
16678: LD_INT 25
16680: PUSH
16681: LD_INT 8
16683: PUSH
16684: EMPTY
16685: LIST
16686: LIST
16687: PUSH
16688: LD_INT 25
16690: PUSH
16691: LD_INT 9
16693: PUSH
16694: EMPTY
16695: LIST
16696: LIST
16697: PUSH
16698: EMPTY
16699: LIST
16700: LIST
16701: LIST
16702: LIST
16703: LIST
16704: PPUSH
16705: CALL_OW 72
16709: ST_TO_ADDR
// if not defenders and not solds then
16710: LD_VAR 0 2
16714: NOT
16715: PUSH
16716: LD_VAR 0 9
16720: NOT
16721: AND
16722: IFFALSE 16726
// exit ;
16724: GO 18352
// depot_under_attack := false ;
16726: LD_ADDR_VAR 0 17
16730: PUSH
16731: LD_INT 0
16733: ST_TO_ADDR
// sold_defenders := [ ] ;
16734: LD_ADDR_VAR 0 18
16738: PUSH
16739: EMPTY
16740: ST_TO_ADDR
// if mechs then
16741: LD_VAR 0 13
16745: IFFALSE 16874
// for i in defenders do
16747: LD_ADDR_VAR 0 5
16751: PUSH
16752: LD_VAR 0 2
16756: PUSH
16757: FOR_IN
16758: IFFALSE 16872
// begin SetTag ( i , 20 ) ;
16760: LD_VAR 0 5
16764: PPUSH
16765: LD_INT 20
16767: PPUSH
16768: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16772: LD_VAR 0 5
16776: PPUSH
16777: CALL_OW 263
16781: PUSH
16782: LD_INT 1
16784: EQUAL
16785: PUSH
16786: LD_VAR 0 5
16790: PPUSH
16791: CALL_OW 311
16795: NOT
16796: AND
16797: PUSH
16798: LD_VAR 0 13
16802: AND
16803: IFFALSE 16870
// begin un := mechs [ 1 ] ;
16805: LD_ADDR_VAR 0 11
16809: PUSH
16810: LD_VAR 0 13
16814: PUSH
16815: LD_INT 1
16817: ARRAY
16818: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16819: LD_VAR 0 11
16823: PPUSH
16824: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16828: LD_VAR 0 11
16832: PPUSH
16833: LD_VAR 0 5
16837: PPUSH
16838: CALL_OW 180
// SetTag ( un , 19 ) ;
16842: LD_VAR 0 11
16846: PPUSH
16847: LD_INT 19
16849: PPUSH
16850: CALL_OW 109
// mechs := mechs diff un ;
16854: LD_ADDR_VAR 0 13
16858: PUSH
16859: LD_VAR 0 13
16863: PUSH
16864: LD_VAR 0 11
16868: DIFF
16869: ST_TO_ADDR
// end ; end ;
16870: GO 16757
16872: POP
16873: POP
// if solds then
16874: LD_VAR 0 9
16878: IFFALSE 16937
// for i in solds do
16880: LD_ADDR_VAR 0 5
16884: PUSH
16885: LD_VAR 0 9
16889: PUSH
16890: FOR_IN
16891: IFFALSE 16935
// if not GetTag ( i ) then
16893: LD_VAR 0 5
16897: PPUSH
16898: CALL_OW 110
16902: NOT
16903: IFFALSE 16933
// begin defenders := defenders union i ;
16905: LD_ADDR_VAR 0 2
16909: PUSH
16910: LD_VAR 0 2
16914: PUSH
16915: LD_VAR 0 5
16919: UNION
16920: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16921: LD_VAR 0 5
16925: PPUSH
16926: LD_INT 18
16928: PPUSH
16929: CALL_OW 109
// end ;
16933: GO 16890
16935: POP
16936: POP
// repeat wait ( 0 0$1 ) ;
16937: LD_INT 35
16939: PPUSH
16940: CALL_OW 67
// enemy := mc_scan [ base ] ;
16944: LD_ADDR_VAR 0 3
16948: PUSH
16949: LD_EXP 82
16953: PUSH
16954: LD_VAR 0 1
16958: ARRAY
16959: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16960: LD_EXP 59
16964: PUSH
16965: LD_VAR 0 1
16969: ARRAY
16970: NOT
16971: PUSH
16972: LD_EXP 59
16976: PUSH
16977: LD_VAR 0 1
16981: ARRAY
16982: PUSH
16983: EMPTY
16984: EQUAL
16985: OR
16986: IFFALSE 17023
// begin for i in defenders do
16988: LD_ADDR_VAR 0 5
16992: PUSH
16993: LD_VAR 0 2
16997: PUSH
16998: FOR_IN
16999: IFFALSE 17012
// ComStop ( i ) ;
17001: LD_VAR 0 5
17005: PPUSH
17006: CALL_OW 141
17010: GO 16998
17012: POP
17013: POP
// defenders := [ ] ;
17014: LD_ADDR_VAR 0 2
17018: PUSH
17019: EMPTY
17020: ST_TO_ADDR
// exit ;
17021: GO 18352
// end ; for i in defenders do
17023: LD_ADDR_VAR 0 5
17027: PUSH
17028: LD_VAR 0 2
17032: PUSH
17033: FOR_IN
17034: IFFALSE 17852
// begin e := NearestUnitToUnit ( enemy , i ) ;
17036: LD_ADDR_VAR 0 14
17040: PUSH
17041: LD_VAR 0 3
17045: PPUSH
17046: LD_VAR 0 5
17050: PPUSH
17051: CALL_OW 74
17055: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
17056: LD_ADDR_VAR 0 8
17060: PUSH
17061: LD_EXP 59
17065: PUSH
17066: LD_VAR 0 1
17070: ARRAY
17071: PPUSH
17072: LD_INT 2
17074: PUSH
17075: LD_INT 30
17077: PUSH
17078: LD_INT 0
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: PUSH
17085: LD_INT 30
17087: PUSH
17088: LD_INT 1
17090: PUSH
17091: EMPTY
17092: LIST
17093: LIST
17094: PUSH
17095: EMPTY
17096: LIST
17097: LIST
17098: LIST
17099: PPUSH
17100: CALL_OW 72
17104: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
17105: LD_ADDR_VAR 0 17
17109: PUSH
17110: LD_VAR 0 8
17114: NOT
17115: PUSH
17116: LD_VAR 0 8
17120: PPUSH
17121: LD_INT 3
17123: PUSH
17124: LD_INT 24
17126: PUSH
17127: LD_INT 600
17129: PUSH
17130: EMPTY
17131: LIST
17132: LIST
17133: PUSH
17134: EMPTY
17135: LIST
17136: LIST
17137: PPUSH
17138: CALL_OW 72
17142: OR
17143: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
17144: LD_VAR 0 5
17148: PPUSH
17149: CALL_OW 247
17153: PUSH
17154: LD_INT 2
17156: DOUBLE
17157: EQUAL
17158: IFTRUE 17162
17160: GO 17558
17162: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
17163: LD_VAR 0 5
17167: PPUSH
17168: CALL_OW 256
17172: PUSH
17173: LD_INT 650
17175: GREATER
17176: PUSH
17177: LD_VAR 0 5
17181: PPUSH
17182: LD_VAR 0 14
17186: PPUSH
17187: CALL_OW 296
17191: PUSH
17192: LD_INT 40
17194: LESS
17195: PUSH
17196: LD_VAR 0 14
17200: PPUSH
17201: LD_EXP 84
17205: PUSH
17206: LD_VAR 0 1
17210: ARRAY
17211: PPUSH
17212: CALL_OW 308
17216: OR
17217: AND
17218: IFFALSE 17340
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
17220: LD_VAR 0 5
17224: PPUSH
17225: CALL_OW 262
17229: PUSH
17230: LD_INT 1
17232: EQUAL
17233: PUSH
17234: LD_VAR 0 5
17238: PPUSH
17239: CALL_OW 261
17243: PUSH
17244: LD_INT 30
17246: LESS
17247: AND
17248: PUSH
17249: LD_VAR 0 8
17253: AND
17254: IFFALSE 17324
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
17256: LD_VAR 0 5
17260: PPUSH
17261: LD_VAR 0 8
17265: PPUSH
17266: LD_VAR 0 5
17270: PPUSH
17271: CALL_OW 74
17275: PPUSH
17276: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
17280: LD_VAR 0 5
17284: PPUSH
17285: LD_VAR 0 8
17289: PPUSH
17290: LD_VAR 0 5
17294: PPUSH
17295: CALL_OW 74
17299: PPUSH
17300: CALL_OW 296
17304: PUSH
17305: LD_INT 6
17307: LESS
17308: IFFALSE 17322
// SetFuel ( i , 100 ) ;
17310: LD_VAR 0 5
17314: PPUSH
17315: LD_INT 100
17317: PPUSH
17318: CALL_OW 240
// end else
17322: GO 17338
// ComAttackUnit ( i , e ) ;
17324: LD_VAR 0 5
17328: PPUSH
17329: LD_VAR 0 14
17333: PPUSH
17334: CALL_OW 115
// end else
17338: GO 17441
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
17340: LD_VAR 0 14
17344: PPUSH
17345: LD_EXP 84
17349: PUSH
17350: LD_VAR 0 1
17354: ARRAY
17355: PPUSH
17356: CALL_OW 308
17360: NOT
17361: PUSH
17362: LD_VAR 0 5
17366: PPUSH
17367: LD_VAR 0 14
17371: PPUSH
17372: CALL_OW 296
17376: PUSH
17377: LD_INT 40
17379: GREATEREQUAL
17380: AND
17381: PUSH
17382: LD_VAR 0 5
17386: PPUSH
17387: CALL_OW 256
17391: PUSH
17392: LD_INT 650
17394: LESSEQUAL
17395: OR
17396: PUSH
17397: LD_VAR 0 5
17401: PPUSH
17402: LD_EXP 83
17406: PUSH
17407: LD_VAR 0 1
17411: ARRAY
17412: PPUSH
17413: CALL_OW 308
17417: NOT
17418: AND
17419: IFFALSE 17441
// ComMoveToArea ( i , mc_parking [ base ] ) ;
17421: LD_VAR 0 5
17425: PPUSH
17426: LD_EXP 83
17430: PUSH
17431: LD_VAR 0 1
17435: ARRAY
17436: PPUSH
17437: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
17441: LD_VAR 0 5
17445: PPUSH
17446: CALL_OW 256
17450: PUSH
17451: LD_INT 998
17453: LESS
17454: PUSH
17455: LD_VAR 0 5
17459: PPUSH
17460: CALL_OW 263
17464: PUSH
17465: LD_INT 1
17467: EQUAL
17468: AND
17469: PUSH
17470: LD_VAR 0 5
17474: PPUSH
17475: CALL_OW 311
17479: AND
17480: PUSH
17481: LD_VAR 0 5
17485: PPUSH
17486: LD_EXP 83
17490: PUSH
17491: LD_VAR 0 1
17495: ARRAY
17496: PPUSH
17497: CALL_OW 308
17501: AND
17502: IFFALSE 17556
// begin mech := IsDrivenBy ( i ) ;
17504: LD_ADDR_VAR 0 10
17508: PUSH
17509: LD_VAR 0 5
17513: PPUSH
17514: CALL_OW 311
17518: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
17519: LD_VAR 0 10
17523: PPUSH
17524: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
17528: LD_VAR 0 10
17532: PPUSH
17533: LD_VAR 0 5
17537: PPUSH
17538: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
17542: LD_VAR 0 10
17546: PPUSH
17547: LD_VAR 0 5
17551: PPUSH
17552: CALL_OW 180
// end ; end ; unit_human :
17556: GO 17823
17558: LD_INT 1
17560: DOUBLE
17561: EQUAL
17562: IFTRUE 17566
17564: GO 17822
17566: POP
// begin b := IsInUnit ( i ) ;
17567: LD_ADDR_VAR 0 19
17571: PUSH
17572: LD_VAR 0 5
17576: PPUSH
17577: CALL_OW 310
17581: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
17582: LD_ADDR_VAR 0 20
17586: PUSH
17587: LD_VAR 0 19
17591: NOT
17592: PUSH
17593: LD_VAR 0 19
17597: PPUSH
17598: CALL_OW 266
17602: PUSH
17603: LD_INT 32
17605: PUSH
17606: LD_INT 31
17608: PUSH
17609: EMPTY
17610: LIST
17611: LIST
17612: IN
17613: OR
17614: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
17615: LD_VAR 0 17
17619: PUSH
17620: LD_VAR 0 2
17624: PPUSH
17625: LD_INT 21
17627: PUSH
17628: LD_INT 2
17630: PUSH
17631: EMPTY
17632: LIST
17633: LIST
17634: PPUSH
17635: CALL_OW 72
17639: PUSH
17640: LD_INT 1
17642: LESSEQUAL
17643: OR
17644: PUSH
17645: LD_VAR 0 20
17649: AND
17650: PUSH
17651: LD_VAR 0 5
17655: PUSH
17656: LD_VAR 0 18
17660: IN
17661: NOT
17662: AND
17663: IFFALSE 17756
// begin if b then
17665: LD_VAR 0 19
17669: IFFALSE 17718
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
17671: LD_VAR 0 19
17675: PPUSH
17676: LD_VAR 0 3
17680: PPUSH
17681: LD_VAR 0 19
17685: PPUSH
17686: CALL_OW 74
17690: PPUSH
17691: CALL_OW 296
17695: PUSH
17696: LD_INT 10
17698: LESS
17699: PUSH
17700: LD_VAR 0 19
17704: PPUSH
17705: CALL_OW 461
17709: PUSH
17710: LD_INT 7
17712: NONEQUAL
17713: AND
17714: IFFALSE 17718
// continue ;
17716: GO 17033
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17718: LD_ADDR_VAR 0 18
17722: PUSH
17723: LD_VAR 0 18
17727: PPUSH
17728: LD_VAR 0 18
17732: PUSH
17733: LD_INT 1
17735: PLUS
17736: PPUSH
17737: LD_VAR 0 5
17741: PPUSH
17742: CALL_OW 1
17746: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17747: LD_VAR 0 5
17751: PPUSH
17752: CALL_OW 122
// end ; if sold_defenders then
17756: LD_VAR 0 18
17760: IFFALSE 17820
// if i in sold_defenders then
17762: LD_VAR 0 5
17766: PUSH
17767: LD_VAR 0 18
17771: IN
17772: IFFALSE 17820
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17774: LD_VAR 0 5
17778: PPUSH
17779: CALL_OW 314
17783: NOT
17784: PUSH
17785: LD_VAR 0 5
17789: PPUSH
17790: LD_VAR 0 14
17794: PPUSH
17795: CALL_OW 296
17799: PUSH
17800: LD_INT 30
17802: LESS
17803: AND
17804: IFFALSE 17820
// ComAttackUnit ( i , e ) ;
17806: LD_VAR 0 5
17810: PPUSH
17811: LD_VAR 0 14
17815: PPUSH
17816: CALL_OW 115
// end ; end ; end ;
17820: GO 17823
17822: POP
// if IsDead ( i ) then
17823: LD_VAR 0 5
17827: PPUSH
17828: CALL_OW 301
17832: IFFALSE 17850
// defenders := defenders diff i ;
17834: LD_ADDR_VAR 0 2
17838: PUSH
17839: LD_VAR 0 2
17843: PUSH
17844: LD_VAR 0 5
17848: DIFF
17849: ST_TO_ADDR
// end ;
17850: GO 17033
17852: POP
17853: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
17854: LD_VAR 0 3
17858: NOT
17859: PUSH
17860: LD_VAR 0 2
17864: NOT
17865: OR
17866: PUSH
17867: LD_EXP 59
17871: PUSH
17872: LD_VAR 0 1
17876: ARRAY
17877: NOT
17878: OR
17879: IFFALSE 16937
// MC_Reset ( base , 18 ) ;
17881: LD_VAR 0 1
17885: PPUSH
17886: LD_INT 18
17888: PPUSH
17889: CALL 61550 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17893: LD_ADDR_VAR 0 2
17897: PUSH
17898: LD_VAR 0 2
17902: PUSH
17903: LD_VAR 0 2
17907: PPUSH
17908: LD_INT 2
17910: PUSH
17911: LD_INT 25
17913: PUSH
17914: LD_INT 1
17916: PUSH
17917: EMPTY
17918: LIST
17919: LIST
17920: PUSH
17921: LD_INT 25
17923: PUSH
17924: LD_INT 5
17926: PUSH
17927: EMPTY
17928: LIST
17929: LIST
17930: PUSH
17931: LD_INT 25
17933: PUSH
17934: LD_INT 8
17936: PUSH
17937: EMPTY
17938: LIST
17939: LIST
17940: PUSH
17941: LD_INT 25
17943: PUSH
17944: LD_INT 9
17946: PUSH
17947: EMPTY
17948: LIST
17949: LIST
17950: PUSH
17951: EMPTY
17952: LIST
17953: LIST
17954: LIST
17955: LIST
17956: LIST
17957: PPUSH
17958: CALL_OW 72
17962: DIFF
17963: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17964: LD_VAR 0 3
17968: NOT
17969: PUSH
17970: LD_VAR 0 2
17974: PPUSH
17975: LD_INT 21
17977: PUSH
17978: LD_INT 2
17980: PUSH
17981: EMPTY
17982: LIST
17983: LIST
17984: PPUSH
17985: CALL_OW 72
17989: AND
17990: IFFALSE 18328
// begin tmp := FilterByTag ( defenders , 19 ) ;
17992: LD_ADDR_VAR 0 12
17996: PUSH
17997: LD_VAR 0 2
18001: PPUSH
18002: LD_INT 19
18004: PPUSH
18005: CALL 54807 0 2
18009: ST_TO_ADDR
// if tmp then
18010: LD_VAR 0 12
18014: IFFALSE 18084
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
18016: LD_ADDR_VAR 0 12
18020: PUSH
18021: LD_VAR 0 12
18025: PPUSH
18026: LD_INT 25
18028: PUSH
18029: LD_INT 3
18031: PUSH
18032: EMPTY
18033: LIST
18034: LIST
18035: PPUSH
18036: CALL_OW 72
18040: ST_TO_ADDR
// if tmp then
18041: LD_VAR 0 12
18045: IFFALSE 18084
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
18047: LD_ADDR_EXP 71
18051: PUSH
18052: LD_EXP 71
18056: PPUSH
18057: LD_VAR 0 1
18061: PPUSH
18062: LD_EXP 71
18066: PUSH
18067: LD_VAR 0 1
18071: ARRAY
18072: PUSH
18073: LD_VAR 0 12
18077: UNION
18078: PPUSH
18079: CALL_OW 1
18083: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
18084: LD_VAR 0 1
18088: PPUSH
18089: LD_INT 19
18091: PPUSH
18092: CALL 61550 0 2
// repeat wait ( 0 0$1 ) ;
18096: LD_INT 35
18098: PPUSH
18099: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
18103: LD_EXP 59
18107: PUSH
18108: LD_VAR 0 1
18112: ARRAY
18113: NOT
18114: PUSH
18115: LD_EXP 59
18119: PUSH
18120: LD_VAR 0 1
18124: ARRAY
18125: PUSH
18126: EMPTY
18127: EQUAL
18128: OR
18129: IFFALSE 18166
// begin for i in defenders do
18131: LD_ADDR_VAR 0 5
18135: PUSH
18136: LD_VAR 0 2
18140: PUSH
18141: FOR_IN
18142: IFFALSE 18155
// ComStop ( i ) ;
18144: LD_VAR 0 5
18148: PPUSH
18149: CALL_OW 141
18153: GO 18141
18155: POP
18156: POP
// defenders := [ ] ;
18157: LD_ADDR_VAR 0 2
18161: PUSH
18162: EMPTY
18163: ST_TO_ADDR
// exit ;
18164: GO 18352
// end ; for i in defenders do
18166: LD_ADDR_VAR 0 5
18170: PUSH
18171: LD_VAR 0 2
18175: PUSH
18176: FOR_IN
18177: IFFALSE 18266
// begin if not IsInArea ( i , mc_parking [ base ] ) then
18179: LD_VAR 0 5
18183: PPUSH
18184: LD_EXP 83
18188: PUSH
18189: LD_VAR 0 1
18193: ARRAY
18194: PPUSH
18195: CALL_OW 308
18199: NOT
18200: IFFALSE 18224
// ComMoveToArea ( i , mc_parking [ base ] ) else
18202: LD_VAR 0 5
18206: PPUSH
18207: LD_EXP 83
18211: PUSH
18212: LD_VAR 0 1
18216: ARRAY
18217: PPUSH
18218: CALL_OW 113
18222: GO 18264
// if GetControl ( i ) = control_manual then
18224: LD_VAR 0 5
18228: PPUSH
18229: CALL_OW 263
18233: PUSH
18234: LD_INT 1
18236: EQUAL
18237: IFFALSE 18264
// if IsDrivenBy ( i ) then
18239: LD_VAR 0 5
18243: PPUSH
18244: CALL_OW 311
18248: IFFALSE 18264
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
18250: LD_VAR 0 5
18254: PPUSH
18255: CALL_OW 311
18259: PPUSH
18260: CALL_OW 121
// end ;
18264: GO 18176
18266: POP
18267: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
18268: LD_VAR 0 2
18272: PPUSH
18273: LD_INT 95
18275: PUSH
18276: LD_EXP 83
18280: PUSH
18281: LD_VAR 0 1
18285: ARRAY
18286: PUSH
18287: EMPTY
18288: LIST
18289: LIST
18290: PPUSH
18291: CALL_OW 72
18295: PUSH
18296: LD_VAR 0 2
18300: EQUAL
18301: PUSH
18302: LD_EXP 82
18306: PUSH
18307: LD_VAR 0 1
18311: ARRAY
18312: OR
18313: PUSH
18314: LD_EXP 59
18318: PUSH
18319: LD_VAR 0 1
18323: ARRAY
18324: NOT
18325: OR
18326: IFFALSE 18096
// end ; MC_Reset ( base , 19 ) ;
18328: LD_VAR 0 1
18332: PPUSH
18333: LD_INT 19
18335: PPUSH
18336: CALL 61550 0 2
// MC_Reset ( base , 20 ) ;
18340: LD_VAR 0 1
18344: PPUSH
18345: LD_INT 20
18347: PPUSH
18348: CALL 61550 0 2
// end ;
18352: LD_VAR 0 4
18356: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
18357: LD_INT 0
18359: PPUSH
18360: PPUSH
18361: PPUSH
18362: PPUSH
// result := false ;
18363: LD_ADDR_VAR 0 2
18367: PUSH
18368: LD_INT 0
18370: ST_TO_ADDR
// side := GetSide ( unit ) ;
18371: LD_ADDR_VAR 0 3
18375: PUSH
18376: LD_VAR 0 1
18380: PPUSH
18381: CALL_OW 255
18385: ST_TO_ADDR
// nat := GetNation ( unit ) ;
18386: LD_ADDR_VAR 0 4
18390: PUSH
18391: LD_VAR 0 1
18395: PPUSH
18396: CALL_OW 248
18400: ST_TO_ADDR
// case nat of 1 :
18401: LD_VAR 0 4
18405: PUSH
18406: LD_INT 1
18408: DOUBLE
18409: EQUAL
18410: IFTRUE 18414
18412: GO 18425
18414: POP
// tech := tech_lassight ; 2 :
18415: LD_ADDR_VAR 0 5
18419: PUSH
18420: LD_INT 12
18422: ST_TO_ADDR
18423: GO 18464
18425: LD_INT 2
18427: DOUBLE
18428: EQUAL
18429: IFTRUE 18433
18431: GO 18444
18433: POP
// tech := tech_mortar ; 3 :
18434: LD_ADDR_VAR 0 5
18438: PUSH
18439: LD_INT 41
18441: ST_TO_ADDR
18442: GO 18464
18444: LD_INT 3
18446: DOUBLE
18447: EQUAL
18448: IFTRUE 18452
18450: GO 18463
18452: POP
// tech := tech_bazooka ; end ;
18453: LD_ADDR_VAR 0 5
18457: PUSH
18458: LD_INT 44
18460: ST_TO_ADDR
18461: GO 18464
18463: POP
// if Researched ( side , tech ) then
18464: LD_VAR 0 3
18468: PPUSH
18469: LD_VAR 0 5
18473: PPUSH
18474: CALL_OW 325
18478: IFFALSE 18505
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18480: LD_ADDR_VAR 0 2
18484: PUSH
18485: LD_INT 5
18487: PUSH
18488: LD_INT 8
18490: PUSH
18491: LD_INT 9
18493: PUSH
18494: EMPTY
18495: LIST
18496: LIST
18497: LIST
18498: PUSH
18499: LD_VAR 0 4
18503: ARRAY
18504: ST_TO_ADDR
// end ;
18505: LD_VAR 0 2
18509: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18510: LD_INT 0
18512: PPUSH
18513: PPUSH
18514: PPUSH
// if not mines then
18515: LD_VAR 0 2
18519: NOT
18520: IFFALSE 18524
// exit ;
18522: GO 18668
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18524: LD_ADDR_VAR 0 5
18528: PUSH
18529: LD_INT 81
18531: PUSH
18532: LD_VAR 0 1
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: PUSH
18541: LD_INT 3
18543: PUSH
18544: LD_INT 21
18546: PUSH
18547: LD_INT 3
18549: PUSH
18550: EMPTY
18551: LIST
18552: LIST
18553: PUSH
18554: EMPTY
18555: LIST
18556: LIST
18557: PUSH
18558: EMPTY
18559: LIST
18560: LIST
18561: PPUSH
18562: CALL_OW 69
18566: ST_TO_ADDR
// for i in mines do
18567: LD_ADDR_VAR 0 4
18571: PUSH
18572: LD_VAR 0 2
18576: PUSH
18577: FOR_IN
18578: IFFALSE 18666
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18580: LD_VAR 0 4
18584: PUSH
18585: LD_INT 1
18587: ARRAY
18588: PPUSH
18589: LD_VAR 0 4
18593: PUSH
18594: LD_INT 2
18596: ARRAY
18597: PPUSH
18598: CALL_OW 458
18602: NOT
18603: IFFALSE 18607
// continue ;
18605: GO 18577
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18607: LD_VAR 0 4
18611: PUSH
18612: LD_INT 1
18614: ARRAY
18615: PPUSH
18616: LD_VAR 0 4
18620: PUSH
18621: LD_INT 2
18623: ARRAY
18624: PPUSH
18625: CALL_OW 428
18629: PUSH
18630: LD_VAR 0 5
18634: IN
18635: IFFALSE 18664
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18637: LD_VAR 0 4
18641: PUSH
18642: LD_INT 1
18644: ARRAY
18645: PPUSH
18646: LD_VAR 0 4
18650: PUSH
18651: LD_INT 2
18653: ARRAY
18654: PPUSH
18655: LD_VAR 0 1
18659: PPUSH
18660: CALL_OW 456
// end ;
18664: GO 18577
18666: POP
18667: POP
// end ;
18668: LD_VAR 0 3
18672: RET
// export function Count ( array ) ; var i ; begin
18673: LD_INT 0
18675: PPUSH
18676: PPUSH
// result := 0 ;
18677: LD_ADDR_VAR 0 2
18681: PUSH
18682: LD_INT 0
18684: ST_TO_ADDR
// for i in array do
18685: LD_ADDR_VAR 0 3
18689: PUSH
18690: LD_VAR 0 1
18694: PUSH
18695: FOR_IN
18696: IFFALSE 18720
// if i then
18698: LD_VAR 0 3
18702: IFFALSE 18718
// result := result + 1 ;
18704: LD_ADDR_VAR 0 2
18708: PUSH
18709: LD_VAR 0 2
18713: PUSH
18714: LD_INT 1
18716: PLUS
18717: ST_TO_ADDR
18718: GO 18695
18720: POP
18721: POP
// end ;
18722: LD_VAR 0 2
18726: RET
// export function IsEmpty ( building ) ; begin
18727: LD_INT 0
18729: PPUSH
// if not building then
18730: LD_VAR 0 1
18734: NOT
18735: IFFALSE 18739
// exit ;
18737: GO 18782
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18739: LD_ADDR_VAR 0 2
18743: PUSH
18744: LD_VAR 0 1
18748: PUSH
18749: LD_INT 22
18751: PUSH
18752: LD_VAR 0 1
18756: PPUSH
18757: CALL_OW 255
18761: PUSH
18762: EMPTY
18763: LIST
18764: LIST
18765: PUSH
18766: LD_INT 58
18768: PUSH
18769: EMPTY
18770: LIST
18771: PUSH
18772: EMPTY
18773: LIST
18774: LIST
18775: PPUSH
18776: CALL_OW 69
18780: IN
18781: ST_TO_ADDR
// end ;
18782: LD_VAR 0 2
18786: RET
// export function IsNotFull ( building ) ; begin
18787: LD_INT 0
18789: PPUSH
// if not building then
18790: LD_VAR 0 1
18794: NOT
18795: IFFALSE 18799
// exit ;
18797: GO 18818
// result := UnitsInside ( building ) < 6 ;
18799: LD_ADDR_VAR 0 2
18803: PUSH
18804: LD_VAR 0 1
18808: PPUSH
18809: CALL_OW 313
18813: PUSH
18814: LD_INT 6
18816: LESS
18817: ST_TO_ADDR
// end ;
18818: LD_VAR 0 2
18822: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18823: LD_INT 0
18825: PPUSH
18826: PPUSH
18827: PPUSH
18828: PPUSH
// tmp := [ ] ;
18829: LD_ADDR_VAR 0 3
18833: PUSH
18834: EMPTY
18835: ST_TO_ADDR
// list := [ ] ;
18836: LD_ADDR_VAR 0 5
18840: PUSH
18841: EMPTY
18842: ST_TO_ADDR
// for i = 16 to 25 do
18843: LD_ADDR_VAR 0 4
18847: PUSH
18848: DOUBLE
18849: LD_INT 16
18851: DEC
18852: ST_TO_ADDR
18853: LD_INT 25
18855: PUSH
18856: FOR_TO
18857: IFFALSE 18930
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18859: LD_ADDR_VAR 0 3
18863: PUSH
18864: LD_VAR 0 3
18868: PUSH
18869: LD_INT 22
18871: PUSH
18872: LD_VAR 0 1
18876: PPUSH
18877: CALL_OW 255
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: PUSH
18886: LD_INT 91
18888: PUSH
18889: LD_VAR 0 1
18893: PUSH
18894: LD_INT 6
18896: PUSH
18897: EMPTY
18898: LIST
18899: LIST
18900: LIST
18901: PUSH
18902: LD_INT 30
18904: PUSH
18905: LD_VAR 0 4
18909: PUSH
18910: EMPTY
18911: LIST
18912: LIST
18913: PUSH
18914: EMPTY
18915: LIST
18916: LIST
18917: LIST
18918: PUSH
18919: EMPTY
18920: LIST
18921: PPUSH
18922: CALL_OW 69
18926: ADD
18927: ST_TO_ADDR
18928: GO 18856
18930: POP
18931: POP
// for i = 1 to tmp do
18932: LD_ADDR_VAR 0 4
18936: PUSH
18937: DOUBLE
18938: LD_INT 1
18940: DEC
18941: ST_TO_ADDR
18942: LD_VAR 0 3
18946: PUSH
18947: FOR_TO
18948: IFFALSE 19036
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18950: LD_ADDR_VAR 0 5
18954: PUSH
18955: LD_VAR 0 5
18959: PUSH
18960: LD_VAR 0 3
18964: PUSH
18965: LD_VAR 0 4
18969: ARRAY
18970: PPUSH
18971: CALL_OW 266
18975: PUSH
18976: LD_VAR 0 3
18980: PUSH
18981: LD_VAR 0 4
18985: ARRAY
18986: PPUSH
18987: CALL_OW 250
18991: PUSH
18992: LD_VAR 0 3
18996: PUSH
18997: LD_VAR 0 4
19001: ARRAY
19002: PPUSH
19003: CALL_OW 251
19007: PUSH
19008: LD_VAR 0 3
19012: PUSH
19013: LD_VAR 0 4
19017: ARRAY
19018: PPUSH
19019: CALL_OW 254
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: LIST
19028: LIST
19029: PUSH
19030: EMPTY
19031: LIST
19032: ADD
19033: ST_TO_ADDR
19034: GO 18947
19036: POP
19037: POP
// result := list ;
19038: LD_ADDR_VAR 0 2
19042: PUSH
19043: LD_VAR 0 5
19047: ST_TO_ADDR
// end ;
19048: LD_VAR 0 2
19052: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
19053: LD_INT 0
19055: PPUSH
19056: PPUSH
19057: PPUSH
19058: PPUSH
19059: PPUSH
19060: PPUSH
19061: PPUSH
// if not factory then
19062: LD_VAR 0 1
19066: NOT
19067: IFFALSE 19071
// exit ;
19069: GO 19664
// if control = control_apeman then
19071: LD_VAR 0 4
19075: PUSH
19076: LD_INT 5
19078: EQUAL
19079: IFFALSE 19188
// begin tmp := UnitsInside ( factory ) ;
19081: LD_ADDR_VAR 0 8
19085: PUSH
19086: LD_VAR 0 1
19090: PPUSH
19091: CALL_OW 313
19095: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
19096: LD_VAR 0 8
19100: PPUSH
19101: LD_INT 25
19103: PUSH
19104: LD_INT 12
19106: PUSH
19107: EMPTY
19108: LIST
19109: LIST
19110: PPUSH
19111: CALL_OW 72
19115: NOT
19116: IFFALSE 19126
// control := control_manual ;
19118: LD_ADDR_VAR 0 4
19122: PUSH
19123: LD_INT 1
19125: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
19126: LD_ADDR_VAR 0 8
19130: PUSH
19131: LD_VAR 0 1
19135: PPUSH
19136: CALL 18823 0 1
19140: ST_TO_ADDR
// if tmp then
19141: LD_VAR 0 8
19145: IFFALSE 19188
// begin for i in tmp do
19147: LD_ADDR_VAR 0 7
19151: PUSH
19152: LD_VAR 0 8
19156: PUSH
19157: FOR_IN
19158: IFFALSE 19186
// if i [ 1 ] = b_ext_radio then
19160: LD_VAR 0 7
19164: PUSH
19165: LD_INT 1
19167: ARRAY
19168: PUSH
19169: LD_INT 22
19171: EQUAL
19172: IFFALSE 19184
// begin control := control_remote ;
19174: LD_ADDR_VAR 0 4
19178: PUSH
19179: LD_INT 2
19181: ST_TO_ADDR
// break ;
19182: GO 19186
// end ;
19184: GO 19157
19186: POP
19187: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19188: LD_VAR 0 1
19192: PPUSH
19193: LD_VAR 0 2
19197: PPUSH
19198: LD_VAR 0 3
19202: PPUSH
19203: LD_VAR 0 4
19207: PPUSH
19208: LD_VAR 0 5
19212: PPUSH
19213: CALL_OW 448
19217: IFFALSE 19252
// begin result := [ chassis , engine , control , weapon ] ;
19219: LD_ADDR_VAR 0 6
19223: PUSH
19224: LD_VAR 0 2
19228: PUSH
19229: LD_VAR 0 3
19233: PUSH
19234: LD_VAR 0 4
19238: PUSH
19239: LD_VAR 0 5
19243: PUSH
19244: EMPTY
19245: LIST
19246: LIST
19247: LIST
19248: LIST
19249: ST_TO_ADDR
// exit ;
19250: GO 19664
// end ; _chassis := AvailableChassisList ( factory ) ;
19252: LD_ADDR_VAR 0 9
19256: PUSH
19257: LD_VAR 0 1
19261: PPUSH
19262: CALL_OW 475
19266: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
19267: LD_ADDR_VAR 0 11
19271: PUSH
19272: LD_VAR 0 1
19276: PPUSH
19277: CALL_OW 476
19281: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
19282: LD_ADDR_VAR 0 12
19286: PUSH
19287: LD_VAR 0 1
19291: PPUSH
19292: CALL_OW 477
19296: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
19297: LD_ADDR_VAR 0 10
19301: PUSH
19302: LD_VAR 0 1
19306: PPUSH
19307: CALL_OW 478
19311: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
19312: LD_VAR 0 9
19316: NOT
19317: PUSH
19318: LD_VAR 0 11
19322: NOT
19323: OR
19324: PUSH
19325: LD_VAR 0 12
19329: NOT
19330: OR
19331: PUSH
19332: LD_VAR 0 10
19336: NOT
19337: OR
19338: IFFALSE 19373
// begin result := [ chassis , engine , control , weapon ] ;
19340: LD_ADDR_VAR 0 6
19344: PUSH
19345: LD_VAR 0 2
19349: PUSH
19350: LD_VAR 0 3
19354: PUSH
19355: LD_VAR 0 4
19359: PUSH
19360: LD_VAR 0 5
19364: PUSH
19365: EMPTY
19366: LIST
19367: LIST
19368: LIST
19369: LIST
19370: ST_TO_ADDR
// exit ;
19371: GO 19664
// end ; if not chassis in _chassis then
19373: LD_VAR 0 2
19377: PUSH
19378: LD_VAR 0 9
19382: IN
19383: NOT
19384: IFFALSE 19410
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
19386: LD_ADDR_VAR 0 2
19390: PUSH
19391: LD_VAR 0 9
19395: PUSH
19396: LD_INT 1
19398: PPUSH
19399: LD_VAR 0 9
19403: PPUSH
19404: CALL_OW 12
19408: ARRAY
19409: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
19410: LD_VAR 0 2
19414: PPUSH
19415: LD_VAR 0 3
19419: PPUSH
19420: CALL 19669 0 2
19424: NOT
19425: IFFALSE 19484
// repeat engine := _engine [ 1 ] ;
19427: LD_ADDR_VAR 0 3
19431: PUSH
19432: LD_VAR 0 11
19436: PUSH
19437: LD_INT 1
19439: ARRAY
19440: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
19441: LD_ADDR_VAR 0 11
19445: PUSH
19446: LD_VAR 0 11
19450: PPUSH
19451: LD_INT 1
19453: PPUSH
19454: CALL_OW 3
19458: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
19459: LD_VAR 0 2
19463: PPUSH
19464: LD_VAR 0 3
19468: PPUSH
19469: CALL 19669 0 2
19473: PUSH
19474: LD_VAR 0 11
19478: PUSH
19479: EMPTY
19480: EQUAL
19481: OR
19482: IFFALSE 19427
// if not control in _control then
19484: LD_VAR 0 4
19488: PUSH
19489: LD_VAR 0 12
19493: IN
19494: NOT
19495: IFFALSE 19521
// control := _control [ rand ( 1 , _control ) ] ;
19497: LD_ADDR_VAR 0 4
19501: PUSH
19502: LD_VAR 0 12
19506: PUSH
19507: LD_INT 1
19509: PPUSH
19510: LD_VAR 0 12
19514: PPUSH
19515: CALL_OW 12
19519: ARRAY
19520: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19521: LD_VAR 0 2
19525: PPUSH
19526: LD_VAR 0 5
19530: PPUSH
19531: CALL 19889 0 2
19535: NOT
19536: IFFALSE 19595
// repeat weapon := _weapon [ 1 ] ;
19538: LD_ADDR_VAR 0 5
19542: PUSH
19543: LD_VAR 0 10
19547: PUSH
19548: LD_INT 1
19550: ARRAY
19551: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19552: LD_ADDR_VAR 0 10
19556: PUSH
19557: LD_VAR 0 10
19561: PPUSH
19562: LD_INT 1
19564: PPUSH
19565: CALL_OW 3
19569: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19570: LD_VAR 0 2
19574: PPUSH
19575: LD_VAR 0 5
19579: PPUSH
19580: CALL 19889 0 2
19584: PUSH
19585: LD_VAR 0 10
19589: PUSH
19590: EMPTY
19591: EQUAL
19592: OR
19593: IFFALSE 19538
// result := [ ] ;
19595: LD_ADDR_VAR 0 6
19599: PUSH
19600: EMPTY
19601: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19602: LD_VAR 0 1
19606: PPUSH
19607: LD_VAR 0 2
19611: PPUSH
19612: LD_VAR 0 3
19616: PPUSH
19617: LD_VAR 0 4
19621: PPUSH
19622: LD_VAR 0 5
19626: PPUSH
19627: CALL_OW 448
19631: IFFALSE 19664
// result := [ chassis , engine , control , weapon ] ;
19633: LD_ADDR_VAR 0 6
19637: PUSH
19638: LD_VAR 0 2
19642: PUSH
19643: LD_VAR 0 3
19647: PUSH
19648: LD_VAR 0 4
19652: PUSH
19653: LD_VAR 0 5
19657: PUSH
19658: EMPTY
19659: LIST
19660: LIST
19661: LIST
19662: LIST
19663: ST_TO_ADDR
// end ;
19664: LD_VAR 0 6
19668: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19669: LD_INT 0
19671: PPUSH
// if not chassis or not engine then
19672: LD_VAR 0 1
19676: NOT
19677: PUSH
19678: LD_VAR 0 2
19682: NOT
19683: OR
19684: IFFALSE 19688
// exit ;
19686: GO 19884
// case engine of engine_solar :
19688: LD_VAR 0 2
19692: PUSH
19693: LD_INT 2
19695: DOUBLE
19696: EQUAL
19697: IFTRUE 19701
19699: GO 19739
19701: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19702: LD_ADDR_VAR 0 3
19706: PUSH
19707: LD_INT 11
19709: PUSH
19710: LD_INT 12
19712: PUSH
19713: LD_INT 13
19715: PUSH
19716: LD_INT 14
19718: PUSH
19719: LD_INT 1
19721: PUSH
19722: LD_INT 2
19724: PUSH
19725: LD_INT 3
19727: PUSH
19728: EMPTY
19729: LIST
19730: LIST
19731: LIST
19732: LIST
19733: LIST
19734: LIST
19735: LIST
19736: ST_TO_ADDR
19737: GO 19868
19739: LD_INT 1
19741: DOUBLE
19742: EQUAL
19743: IFTRUE 19747
19745: GO 19809
19747: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19748: LD_ADDR_VAR 0 3
19752: PUSH
19753: LD_INT 11
19755: PUSH
19756: LD_INT 12
19758: PUSH
19759: LD_INT 13
19761: PUSH
19762: LD_INT 14
19764: PUSH
19765: LD_INT 1
19767: PUSH
19768: LD_INT 2
19770: PUSH
19771: LD_INT 3
19773: PUSH
19774: LD_INT 4
19776: PUSH
19777: LD_INT 5
19779: PUSH
19780: LD_INT 21
19782: PUSH
19783: LD_INT 23
19785: PUSH
19786: LD_INT 22
19788: PUSH
19789: LD_INT 24
19791: PUSH
19792: EMPTY
19793: LIST
19794: LIST
19795: LIST
19796: LIST
19797: LIST
19798: LIST
19799: LIST
19800: LIST
19801: LIST
19802: LIST
19803: LIST
19804: LIST
19805: LIST
19806: ST_TO_ADDR
19807: GO 19868
19809: LD_INT 3
19811: DOUBLE
19812: EQUAL
19813: IFTRUE 19817
19815: GO 19867
19817: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19818: LD_ADDR_VAR 0 3
19822: PUSH
19823: LD_INT 13
19825: PUSH
19826: LD_INT 14
19828: PUSH
19829: LD_INT 2
19831: PUSH
19832: LD_INT 3
19834: PUSH
19835: LD_INT 4
19837: PUSH
19838: LD_INT 5
19840: PUSH
19841: LD_INT 21
19843: PUSH
19844: LD_INT 22
19846: PUSH
19847: LD_INT 23
19849: PUSH
19850: LD_INT 24
19852: PUSH
19853: EMPTY
19854: LIST
19855: LIST
19856: LIST
19857: LIST
19858: LIST
19859: LIST
19860: LIST
19861: LIST
19862: LIST
19863: LIST
19864: ST_TO_ADDR
19865: GO 19868
19867: POP
// result := ( chassis in result ) ;
19868: LD_ADDR_VAR 0 3
19872: PUSH
19873: LD_VAR 0 1
19877: PUSH
19878: LD_VAR 0 3
19882: IN
19883: ST_TO_ADDR
// end ;
19884: LD_VAR 0 3
19888: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19889: LD_INT 0
19891: PPUSH
// if not chassis or not weapon then
19892: LD_VAR 0 1
19896: NOT
19897: PUSH
19898: LD_VAR 0 2
19902: NOT
19903: OR
19904: IFFALSE 19908
// exit ;
19906: GO 20934
// case weapon of us_machine_gun :
19908: LD_VAR 0 2
19912: PUSH
19913: LD_INT 2
19915: DOUBLE
19916: EQUAL
19917: IFTRUE 19921
19919: GO 19951
19921: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19922: LD_ADDR_VAR 0 3
19926: PUSH
19927: LD_INT 1
19929: PUSH
19930: LD_INT 2
19932: PUSH
19933: LD_INT 3
19935: PUSH
19936: LD_INT 4
19938: PUSH
19939: LD_INT 5
19941: PUSH
19942: EMPTY
19943: LIST
19944: LIST
19945: LIST
19946: LIST
19947: LIST
19948: ST_TO_ADDR
19949: GO 20918
19951: LD_INT 3
19953: DOUBLE
19954: EQUAL
19955: IFTRUE 19959
19957: GO 19989
19959: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19960: LD_ADDR_VAR 0 3
19964: PUSH
19965: LD_INT 1
19967: PUSH
19968: LD_INT 2
19970: PUSH
19971: LD_INT 3
19973: PUSH
19974: LD_INT 4
19976: PUSH
19977: LD_INT 5
19979: PUSH
19980: EMPTY
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: ST_TO_ADDR
19987: GO 20918
19989: LD_INT 11
19991: DOUBLE
19992: EQUAL
19993: IFTRUE 19997
19995: GO 20027
19997: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19998: LD_ADDR_VAR 0 3
20002: PUSH
20003: LD_INT 1
20005: PUSH
20006: LD_INT 2
20008: PUSH
20009: LD_INT 3
20011: PUSH
20012: LD_INT 4
20014: PUSH
20015: LD_INT 5
20017: PUSH
20018: EMPTY
20019: LIST
20020: LIST
20021: LIST
20022: LIST
20023: LIST
20024: ST_TO_ADDR
20025: GO 20918
20027: LD_INT 4
20029: DOUBLE
20030: EQUAL
20031: IFTRUE 20035
20033: GO 20061
20035: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
20036: LD_ADDR_VAR 0 3
20040: PUSH
20041: LD_INT 2
20043: PUSH
20044: LD_INT 3
20046: PUSH
20047: LD_INT 4
20049: PUSH
20050: LD_INT 5
20052: PUSH
20053: EMPTY
20054: LIST
20055: LIST
20056: LIST
20057: LIST
20058: ST_TO_ADDR
20059: GO 20918
20061: LD_INT 5
20063: DOUBLE
20064: EQUAL
20065: IFTRUE 20069
20067: GO 20095
20069: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
20070: LD_ADDR_VAR 0 3
20074: PUSH
20075: LD_INT 2
20077: PUSH
20078: LD_INT 3
20080: PUSH
20081: LD_INT 4
20083: PUSH
20084: LD_INT 5
20086: PUSH
20087: EMPTY
20088: LIST
20089: LIST
20090: LIST
20091: LIST
20092: ST_TO_ADDR
20093: GO 20918
20095: LD_INT 9
20097: DOUBLE
20098: EQUAL
20099: IFTRUE 20103
20101: GO 20129
20103: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
20104: LD_ADDR_VAR 0 3
20108: PUSH
20109: LD_INT 2
20111: PUSH
20112: LD_INT 3
20114: PUSH
20115: LD_INT 4
20117: PUSH
20118: LD_INT 5
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: LIST
20125: LIST
20126: ST_TO_ADDR
20127: GO 20918
20129: LD_INT 7
20131: DOUBLE
20132: EQUAL
20133: IFTRUE 20137
20135: GO 20163
20137: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
20138: LD_ADDR_VAR 0 3
20142: PUSH
20143: LD_INT 2
20145: PUSH
20146: LD_INT 3
20148: PUSH
20149: LD_INT 4
20151: PUSH
20152: LD_INT 5
20154: PUSH
20155: EMPTY
20156: LIST
20157: LIST
20158: LIST
20159: LIST
20160: ST_TO_ADDR
20161: GO 20918
20163: LD_INT 12
20165: DOUBLE
20166: EQUAL
20167: IFTRUE 20171
20169: GO 20197
20171: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
20172: LD_ADDR_VAR 0 3
20176: PUSH
20177: LD_INT 2
20179: PUSH
20180: LD_INT 3
20182: PUSH
20183: LD_INT 4
20185: PUSH
20186: LD_INT 5
20188: PUSH
20189: EMPTY
20190: LIST
20191: LIST
20192: LIST
20193: LIST
20194: ST_TO_ADDR
20195: GO 20918
20197: LD_INT 13
20199: DOUBLE
20200: EQUAL
20201: IFTRUE 20205
20203: GO 20231
20205: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
20206: LD_ADDR_VAR 0 3
20210: PUSH
20211: LD_INT 2
20213: PUSH
20214: LD_INT 3
20216: PUSH
20217: LD_INT 4
20219: PUSH
20220: LD_INT 5
20222: PUSH
20223: EMPTY
20224: LIST
20225: LIST
20226: LIST
20227: LIST
20228: ST_TO_ADDR
20229: GO 20918
20231: LD_INT 14
20233: DOUBLE
20234: EQUAL
20235: IFTRUE 20239
20237: GO 20257
20239: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
20240: LD_ADDR_VAR 0 3
20244: PUSH
20245: LD_INT 4
20247: PUSH
20248: LD_INT 5
20250: PUSH
20251: EMPTY
20252: LIST
20253: LIST
20254: ST_TO_ADDR
20255: GO 20918
20257: LD_INT 6
20259: DOUBLE
20260: EQUAL
20261: IFTRUE 20265
20263: GO 20283
20265: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
20266: LD_ADDR_VAR 0 3
20270: PUSH
20271: LD_INT 4
20273: PUSH
20274: LD_INT 5
20276: PUSH
20277: EMPTY
20278: LIST
20279: LIST
20280: ST_TO_ADDR
20281: GO 20918
20283: LD_INT 10
20285: DOUBLE
20286: EQUAL
20287: IFTRUE 20291
20289: GO 20309
20291: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
20292: LD_ADDR_VAR 0 3
20296: PUSH
20297: LD_INT 4
20299: PUSH
20300: LD_INT 5
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: ST_TO_ADDR
20307: GO 20918
20309: LD_INT 22
20311: DOUBLE
20312: EQUAL
20313: IFTRUE 20317
20315: GO 20343
20317: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
20318: LD_ADDR_VAR 0 3
20322: PUSH
20323: LD_INT 11
20325: PUSH
20326: LD_INT 12
20328: PUSH
20329: LD_INT 13
20331: PUSH
20332: LD_INT 14
20334: PUSH
20335: EMPTY
20336: LIST
20337: LIST
20338: LIST
20339: LIST
20340: ST_TO_ADDR
20341: GO 20918
20343: LD_INT 23
20345: DOUBLE
20346: EQUAL
20347: IFTRUE 20351
20349: GO 20377
20351: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
20352: LD_ADDR_VAR 0 3
20356: PUSH
20357: LD_INT 11
20359: PUSH
20360: LD_INT 12
20362: PUSH
20363: LD_INT 13
20365: PUSH
20366: LD_INT 14
20368: PUSH
20369: EMPTY
20370: LIST
20371: LIST
20372: LIST
20373: LIST
20374: ST_TO_ADDR
20375: GO 20918
20377: LD_INT 24
20379: DOUBLE
20380: EQUAL
20381: IFTRUE 20385
20383: GO 20411
20385: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
20386: LD_ADDR_VAR 0 3
20390: PUSH
20391: LD_INT 11
20393: PUSH
20394: LD_INT 12
20396: PUSH
20397: LD_INT 13
20399: PUSH
20400: LD_INT 14
20402: PUSH
20403: EMPTY
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: ST_TO_ADDR
20409: GO 20918
20411: LD_INT 30
20413: DOUBLE
20414: EQUAL
20415: IFTRUE 20419
20417: GO 20445
20419: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
20420: LD_ADDR_VAR 0 3
20424: PUSH
20425: LD_INT 11
20427: PUSH
20428: LD_INT 12
20430: PUSH
20431: LD_INT 13
20433: PUSH
20434: LD_INT 14
20436: PUSH
20437: EMPTY
20438: LIST
20439: LIST
20440: LIST
20441: LIST
20442: ST_TO_ADDR
20443: GO 20918
20445: LD_INT 25
20447: DOUBLE
20448: EQUAL
20449: IFTRUE 20453
20451: GO 20471
20453: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
20454: LD_ADDR_VAR 0 3
20458: PUSH
20459: LD_INT 13
20461: PUSH
20462: LD_INT 14
20464: PUSH
20465: EMPTY
20466: LIST
20467: LIST
20468: ST_TO_ADDR
20469: GO 20918
20471: LD_INT 27
20473: DOUBLE
20474: EQUAL
20475: IFTRUE 20479
20477: GO 20497
20479: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20480: LD_ADDR_VAR 0 3
20484: PUSH
20485: LD_INT 13
20487: PUSH
20488: LD_INT 14
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: ST_TO_ADDR
20495: GO 20918
20497: LD_INT 28
20499: DOUBLE
20500: EQUAL
20501: IFTRUE 20505
20503: GO 20523
20505: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20506: LD_ADDR_VAR 0 3
20510: PUSH
20511: LD_INT 13
20513: PUSH
20514: LD_INT 14
20516: PUSH
20517: EMPTY
20518: LIST
20519: LIST
20520: ST_TO_ADDR
20521: GO 20918
20523: LD_INT 29
20525: DOUBLE
20526: EQUAL
20527: IFTRUE 20531
20529: GO 20549
20531: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20532: LD_ADDR_VAR 0 3
20536: PUSH
20537: LD_INT 13
20539: PUSH
20540: LD_INT 14
20542: PUSH
20543: EMPTY
20544: LIST
20545: LIST
20546: ST_TO_ADDR
20547: GO 20918
20549: LD_INT 31
20551: DOUBLE
20552: EQUAL
20553: IFTRUE 20557
20555: GO 20575
20557: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20558: LD_ADDR_VAR 0 3
20562: PUSH
20563: LD_INT 13
20565: PUSH
20566: LD_INT 14
20568: PUSH
20569: EMPTY
20570: LIST
20571: LIST
20572: ST_TO_ADDR
20573: GO 20918
20575: LD_INT 26
20577: DOUBLE
20578: EQUAL
20579: IFTRUE 20583
20581: GO 20601
20583: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20584: LD_ADDR_VAR 0 3
20588: PUSH
20589: LD_INT 13
20591: PUSH
20592: LD_INT 14
20594: PUSH
20595: EMPTY
20596: LIST
20597: LIST
20598: ST_TO_ADDR
20599: GO 20918
20601: LD_INT 42
20603: DOUBLE
20604: EQUAL
20605: IFTRUE 20609
20607: GO 20635
20609: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20610: LD_ADDR_VAR 0 3
20614: PUSH
20615: LD_INT 21
20617: PUSH
20618: LD_INT 22
20620: PUSH
20621: LD_INT 23
20623: PUSH
20624: LD_INT 24
20626: PUSH
20627: EMPTY
20628: LIST
20629: LIST
20630: LIST
20631: LIST
20632: ST_TO_ADDR
20633: GO 20918
20635: LD_INT 43
20637: DOUBLE
20638: EQUAL
20639: IFTRUE 20643
20641: GO 20669
20643: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20644: LD_ADDR_VAR 0 3
20648: PUSH
20649: LD_INT 21
20651: PUSH
20652: LD_INT 22
20654: PUSH
20655: LD_INT 23
20657: PUSH
20658: LD_INT 24
20660: PUSH
20661: EMPTY
20662: LIST
20663: LIST
20664: LIST
20665: LIST
20666: ST_TO_ADDR
20667: GO 20918
20669: LD_INT 44
20671: DOUBLE
20672: EQUAL
20673: IFTRUE 20677
20675: GO 20703
20677: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20678: LD_ADDR_VAR 0 3
20682: PUSH
20683: LD_INT 21
20685: PUSH
20686: LD_INT 22
20688: PUSH
20689: LD_INT 23
20691: PUSH
20692: LD_INT 24
20694: PUSH
20695: EMPTY
20696: LIST
20697: LIST
20698: LIST
20699: LIST
20700: ST_TO_ADDR
20701: GO 20918
20703: LD_INT 45
20705: DOUBLE
20706: EQUAL
20707: IFTRUE 20711
20709: GO 20737
20711: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20712: LD_ADDR_VAR 0 3
20716: PUSH
20717: LD_INT 21
20719: PUSH
20720: LD_INT 22
20722: PUSH
20723: LD_INT 23
20725: PUSH
20726: LD_INT 24
20728: PUSH
20729: EMPTY
20730: LIST
20731: LIST
20732: LIST
20733: LIST
20734: ST_TO_ADDR
20735: GO 20918
20737: LD_INT 49
20739: DOUBLE
20740: EQUAL
20741: IFTRUE 20745
20743: GO 20771
20745: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20746: LD_ADDR_VAR 0 3
20750: PUSH
20751: LD_INT 21
20753: PUSH
20754: LD_INT 22
20756: PUSH
20757: LD_INT 23
20759: PUSH
20760: LD_INT 24
20762: PUSH
20763: EMPTY
20764: LIST
20765: LIST
20766: LIST
20767: LIST
20768: ST_TO_ADDR
20769: GO 20918
20771: LD_INT 51
20773: DOUBLE
20774: EQUAL
20775: IFTRUE 20779
20777: GO 20805
20779: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20780: LD_ADDR_VAR 0 3
20784: PUSH
20785: LD_INT 21
20787: PUSH
20788: LD_INT 22
20790: PUSH
20791: LD_INT 23
20793: PUSH
20794: LD_INT 24
20796: PUSH
20797: EMPTY
20798: LIST
20799: LIST
20800: LIST
20801: LIST
20802: ST_TO_ADDR
20803: GO 20918
20805: LD_INT 52
20807: DOUBLE
20808: EQUAL
20809: IFTRUE 20813
20811: GO 20839
20813: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20814: LD_ADDR_VAR 0 3
20818: PUSH
20819: LD_INT 21
20821: PUSH
20822: LD_INT 22
20824: PUSH
20825: LD_INT 23
20827: PUSH
20828: LD_INT 24
20830: PUSH
20831: EMPTY
20832: LIST
20833: LIST
20834: LIST
20835: LIST
20836: ST_TO_ADDR
20837: GO 20918
20839: LD_INT 53
20841: DOUBLE
20842: EQUAL
20843: IFTRUE 20847
20845: GO 20865
20847: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20848: LD_ADDR_VAR 0 3
20852: PUSH
20853: LD_INT 23
20855: PUSH
20856: LD_INT 24
20858: PUSH
20859: EMPTY
20860: LIST
20861: LIST
20862: ST_TO_ADDR
20863: GO 20918
20865: LD_INT 46
20867: DOUBLE
20868: EQUAL
20869: IFTRUE 20873
20871: GO 20891
20873: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20874: LD_ADDR_VAR 0 3
20878: PUSH
20879: LD_INT 23
20881: PUSH
20882: LD_INT 24
20884: PUSH
20885: EMPTY
20886: LIST
20887: LIST
20888: ST_TO_ADDR
20889: GO 20918
20891: LD_INT 47
20893: DOUBLE
20894: EQUAL
20895: IFTRUE 20899
20897: GO 20917
20899: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20900: LD_ADDR_VAR 0 3
20904: PUSH
20905: LD_INT 23
20907: PUSH
20908: LD_INT 24
20910: PUSH
20911: EMPTY
20912: LIST
20913: LIST
20914: ST_TO_ADDR
20915: GO 20918
20917: POP
// result := ( chassis in result ) ;
20918: LD_ADDR_VAR 0 3
20922: PUSH
20923: LD_VAR 0 1
20927: PUSH
20928: LD_VAR 0 3
20932: IN
20933: ST_TO_ADDR
// end ;
20934: LD_VAR 0 3
20938: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20939: LD_INT 0
20941: PPUSH
20942: PPUSH
20943: PPUSH
20944: PPUSH
20945: PPUSH
20946: PPUSH
20947: PPUSH
// result := array ;
20948: LD_ADDR_VAR 0 5
20952: PUSH
20953: LD_VAR 0 1
20957: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20958: LD_VAR 0 1
20962: NOT
20963: PUSH
20964: LD_VAR 0 2
20968: NOT
20969: OR
20970: PUSH
20971: LD_VAR 0 3
20975: NOT
20976: OR
20977: PUSH
20978: LD_VAR 0 2
20982: PUSH
20983: LD_VAR 0 1
20987: GREATER
20988: OR
20989: PUSH
20990: LD_VAR 0 3
20994: PUSH
20995: LD_VAR 0 1
20999: GREATER
21000: OR
21001: IFFALSE 21005
// exit ;
21003: GO 21301
// if direction then
21005: LD_VAR 0 4
21009: IFFALSE 21073
// begin d := 1 ;
21011: LD_ADDR_VAR 0 9
21015: PUSH
21016: LD_INT 1
21018: ST_TO_ADDR
// if i_from > i_to then
21019: LD_VAR 0 2
21023: PUSH
21024: LD_VAR 0 3
21028: GREATER
21029: IFFALSE 21055
// length := ( array - i_from ) + i_to else
21031: LD_ADDR_VAR 0 11
21035: PUSH
21036: LD_VAR 0 1
21040: PUSH
21041: LD_VAR 0 2
21045: MINUS
21046: PUSH
21047: LD_VAR 0 3
21051: PLUS
21052: ST_TO_ADDR
21053: GO 21071
// length := i_to - i_from ;
21055: LD_ADDR_VAR 0 11
21059: PUSH
21060: LD_VAR 0 3
21064: PUSH
21065: LD_VAR 0 2
21069: MINUS
21070: ST_TO_ADDR
// end else
21071: GO 21134
// begin d := - 1 ;
21073: LD_ADDR_VAR 0 9
21077: PUSH
21078: LD_INT 1
21080: NEG
21081: ST_TO_ADDR
// if i_from > i_to then
21082: LD_VAR 0 2
21086: PUSH
21087: LD_VAR 0 3
21091: GREATER
21092: IFFALSE 21112
// length := i_from - i_to else
21094: LD_ADDR_VAR 0 11
21098: PUSH
21099: LD_VAR 0 2
21103: PUSH
21104: LD_VAR 0 3
21108: MINUS
21109: ST_TO_ADDR
21110: GO 21134
// length := ( array - i_to ) + i_from ;
21112: LD_ADDR_VAR 0 11
21116: PUSH
21117: LD_VAR 0 1
21121: PUSH
21122: LD_VAR 0 3
21126: MINUS
21127: PUSH
21128: LD_VAR 0 2
21132: PLUS
21133: ST_TO_ADDR
// end ; if not length then
21134: LD_VAR 0 11
21138: NOT
21139: IFFALSE 21143
// exit ;
21141: GO 21301
// tmp := array ;
21143: LD_ADDR_VAR 0 10
21147: PUSH
21148: LD_VAR 0 1
21152: ST_TO_ADDR
// for i = 1 to length do
21153: LD_ADDR_VAR 0 6
21157: PUSH
21158: DOUBLE
21159: LD_INT 1
21161: DEC
21162: ST_TO_ADDR
21163: LD_VAR 0 11
21167: PUSH
21168: FOR_TO
21169: IFFALSE 21289
// begin for j = 1 to array do
21171: LD_ADDR_VAR 0 7
21175: PUSH
21176: DOUBLE
21177: LD_INT 1
21179: DEC
21180: ST_TO_ADDR
21181: LD_VAR 0 1
21185: PUSH
21186: FOR_TO
21187: IFFALSE 21275
// begin k := j + d ;
21189: LD_ADDR_VAR 0 8
21193: PUSH
21194: LD_VAR 0 7
21198: PUSH
21199: LD_VAR 0 9
21203: PLUS
21204: ST_TO_ADDR
// if k > array then
21205: LD_VAR 0 8
21209: PUSH
21210: LD_VAR 0 1
21214: GREATER
21215: IFFALSE 21225
// k := 1 ;
21217: LD_ADDR_VAR 0 8
21221: PUSH
21222: LD_INT 1
21224: ST_TO_ADDR
// if not k then
21225: LD_VAR 0 8
21229: NOT
21230: IFFALSE 21242
// k := array ;
21232: LD_ADDR_VAR 0 8
21236: PUSH
21237: LD_VAR 0 1
21241: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
21242: LD_ADDR_VAR 0 10
21246: PUSH
21247: LD_VAR 0 10
21251: PPUSH
21252: LD_VAR 0 8
21256: PPUSH
21257: LD_VAR 0 1
21261: PUSH
21262: LD_VAR 0 7
21266: ARRAY
21267: PPUSH
21268: CALL_OW 1
21272: ST_TO_ADDR
// end ;
21273: GO 21186
21275: POP
21276: POP
// array := tmp ;
21277: LD_ADDR_VAR 0 1
21281: PUSH
21282: LD_VAR 0 10
21286: ST_TO_ADDR
// end ;
21287: GO 21168
21289: POP
21290: POP
// result := array ;
21291: LD_ADDR_VAR 0 5
21295: PUSH
21296: LD_VAR 0 1
21300: ST_TO_ADDR
// end ;
21301: LD_VAR 0 5
21305: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
21306: LD_INT 0
21308: PPUSH
21309: PPUSH
// result := 0 ;
21310: LD_ADDR_VAR 0 3
21314: PUSH
21315: LD_INT 0
21317: ST_TO_ADDR
// if not array or not value in array then
21318: LD_VAR 0 1
21322: NOT
21323: PUSH
21324: LD_VAR 0 2
21328: PUSH
21329: LD_VAR 0 1
21333: IN
21334: NOT
21335: OR
21336: IFFALSE 21340
// exit ;
21338: GO 21394
// for i = 1 to array do
21340: LD_ADDR_VAR 0 4
21344: PUSH
21345: DOUBLE
21346: LD_INT 1
21348: DEC
21349: ST_TO_ADDR
21350: LD_VAR 0 1
21354: PUSH
21355: FOR_TO
21356: IFFALSE 21392
// if value = array [ i ] then
21358: LD_VAR 0 2
21362: PUSH
21363: LD_VAR 0 1
21367: PUSH
21368: LD_VAR 0 4
21372: ARRAY
21373: EQUAL
21374: IFFALSE 21390
// begin result := i ;
21376: LD_ADDR_VAR 0 3
21380: PUSH
21381: LD_VAR 0 4
21385: ST_TO_ADDR
// exit ;
21386: POP
21387: POP
21388: GO 21394
// end ;
21390: GO 21355
21392: POP
21393: POP
// end ;
21394: LD_VAR 0 3
21398: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
21399: LD_INT 0
21401: PPUSH
// vc_chassis := chassis ;
21402: LD_ADDR_OWVAR 37
21406: PUSH
21407: LD_VAR 0 1
21411: ST_TO_ADDR
// vc_engine := engine ;
21412: LD_ADDR_OWVAR 39
21416: PUSH
21417: LD_VAR 0 2
21421: ST_TO_ADDR
// vc_control := control ;
21422: LD_ADDR_OWVAR 38
21426: PUSH
21427: LD_VAR 0 3
21431: ST_TO_ADDR
// vc_weapon := weapon ;
21432: LD_ADDR_OWVAR 40
21436: PUSH
21437: LD_VAR 0 4
21441: ST_TO_ADDR
// vc_fuel_battery := fuel ;
21442: LD_ADDR_OWVAR 41
21446: PUSH
21447: LD_VAR 0 5
21451: ST_TO_ADDR
// end ;
21452: LD_VAR 0 6
21456: RET
// export function WantPlant ( unit ) ; var task ; begin
21457: LD_INT 0
21459: PPUSH
21460: PPUSH
// result := false ;
21461: LD_ADDR_VAR 0 2
21465: PUSH
21466: LD_INT 0
21468: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21469: LD_ADDR_VAR 0 3
21473: PUSH
21474: LD_VAR 0 1
21478: PPUSH
21479: CALL_OW 437
21483: ST_TO_ADDR
// if task then
21484: LD_VAR 0 3
21488: IFFALSE 21516
// if task [ 1 ] [ 1 ] = p then
21490: LD_VAR 0 3
21494: PUSH
21495: LD_INT 1
21497: ARRAY
21498: PUSH
21499: LD_INT 1
21501: ARRAY
21502: PUSH
21503: LD_STRING p
21505: EQUAL
21506: IFFALSE 21516
// result := true ;
21508: LD_ADDR_VAR 0 2
21512: PUSH
21513: LD_INT 1
21515: ST_TO_ADDR
// end ;
21516: LD_VAR 0 2
21520: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21521: LD_INT 0
21523: PPUSH
21524: PPUSH
21525: PPUSH
21526: PPUSH
// if pos < 1 then
21527: LD_VAR 0 2
21531: PUSH
21532: LD_INT 1
21534: LESS
21535: IFFALSE 21539
// exit ;
21537: GO 21842
// if pos = 1 then
21539: LD_VAR 0 2
21543: PUSH
21544: LD_INT 1
21546: EQUAL
21547: IFFALSE 21580
// result := Replace ( arr , pos [ 1 ] , value ) else
21549: LD_ADDR_VAR 0 4
21553: PUSH
21554: LD_VAR 0 1
21558: PPUSH
21559: LD_VAR 0 2
21563: PUSH
21564: LD_INT 1
21566: ARRAY
21567: PPUSH
21568: LD_VAR 0 3
21572: PPUSH
21573: CALL_OW 1
21577: ST_TO_ADDR
21578: GO 21842
// begin tmp := arr ;
21580: LD_ADDR_VAR 0 6
21584: PUSH
21585: LD_VAR 0 1
21589: ST_TO_ADDR
// s_arr := [ tmp ] ;
21590: LD_ADDR_VAR 0 7
21594: PUSH
21595: LD_VAR 0 6
21599: PUSH
21600: EMPTY
21601: LIST
21602: ST_TO_ADDR
// for i = 1 to pos - 1 do
21603: LD_ADDR_VAR 0 5
21607: PUSH
21608: DOUBLE
21609: LD_INT 1
21611: DEC
21612: ST_TO_ADDR
21613: LD_VAR 0 2
21617: PUSH
21618: LD_INT 1
21620: MINUS
21621: PUSH
21622: FOR_TO
21623: IFFALSE 21668
// begin tmp := tmp [ pos [ i ] ] ;
21625: LD_ADDR_VAR 0 6
21629: PUSH
21630: LD_VAR 0 6
21634: PUSH
21635: LD_VAR 0 2
21639: PUSH
21640: LD_VAR 0 5
21644: ARRAY
21645: ARRAY
21646: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21647: LD_ADDR_VAR 0 7
21651: PUSH
21652: LD_VAR 0 7
21656: PUSH
21657: LD_VAR 0 6
21661: PUSH
21662: EMPTY
21663: LIST
21664: ADD
21665: ST_TO_ADDR
// end ;
21666: GO 21622
21668: POP
21669: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21670: LD_ADDR_VAR 0 6
21674: PUSH
21675: LD_VAR 0 6
21679: PPUSH
21680: LD_VAR 0 2
21684: PUSH
21685: LD_VAR 0 2
21689: ARRAY
21690: PPUSH
21691: LD_VAR 0 3
21695: PPUSH
21696: CALL_OW 1
21700: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21701: LD_ADDR_VAR 0 7
21705: PUSH
21706: LD_VAR 0 7
21710: PPUSH
21711: LD_VAR 0 7
21715: PPUSH
21716: LD_VAR 0 6
21720: PPUSH
21721: CALL_OW 1
21725: ST_TO_ADDR
// for i = s_arr downto 2 do
21726: LD_ADDR_VAR 0 5
21730: PUSH
21731: DOUBLE
21732: LD_VAR 0 7
21736: INC
21737: ST_TO_ADDR
21738: LD_INT 2
21740: PUSH
21741: FOR_DOWNTO
21742: IFFALSE 21826
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21744: LD_ADDR_VAR 0 6
21748: PUSH
21749: LD_VAR 0 7
21753: PUSH
21754: LD_VAR 0 5
21758: PUSH
21759: LD_INT 1
21761: MINUS
21762: ARRAY
21763: PPUSH
21764: LD_VAR 0 2
21768: PUSH
21769: LD_VAR 0 5
21773: PUSH
21774: LD_INT 1
21776: MINUS
21777: ARRAY
21778: PPUSH
21779: LD_VAR 0 7
21783: PUSH
21784: LD_VAR 0 5
21788: ARRAY
21789: PPUSH
21790: CALL_OW 1
21794: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21795: LD_ADDR_VAR 0 7
21799: PUSH
21800: LD_VAR 0 7
21804: PPUSH
21805: LD_VAR 0 5
21809: PUSH
21810: LD_INT 1
21812: MINUS
21813: PPUSH
21814: LD_VAR 0 6
21818: PPUSH
21819: CALL_OW 1
21823: ST_TO_ADDR
// end ;
21824: GO 21741
21826: POP
21827: POP
// result := s_arr [ 1 ] ;
21828: LD_ADDR_VAR 0 4
21832: PUSH
21833: LD_VAR 0 7
21837: PUSH
21838: LD_INT 1
21840: ARRAY
21841: ST_TO_ADDR
// end ; end ;
21842: LD_VAR 0 4
21846: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21847: LD_INT 0
21849: PPUSH
21850: PPUSH
// if not list then
21851: LD_VAR 0 1
21855: NOT
21856: IFFALSE 21860
// exit ;
21858: GO 21951
// i := list [ pos1 ] ;
21860: LD_ADDR_VAR 0 5
21864: PUSH
21865: LD_VAR 0 1
21869: PUSH
21870: LD_VAR 0 2
21874: ARRAY
21875: ST_TO_ADDR
// if not i then
21876: LD_VAR 0 5
21880: NOT
21881: IFFALSE 21885
// exit ;
21883: GO 21951
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21885: LD_ADDR_VAR 0 1
21889: PUSH
21890: LD_VAR 0 1
21894: PPUSH
21895: LD_VAR 0 2
21899: PPUSH
21900: LD_VAR 0 1
21904: PUSH
21905: LD_VAR 0 3
21909: ARRAY
21910: PPUSH
21911: CALL_OW 1
21915: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21916: LD_ADDR_VAR 0 1
21920: PUSH
21921: LD_VAR 0 1
21925: PPUSH
21926: LD_VAR 0 3
21930: PPUSH
21931: LD_VAR 0 5
21935: PPUSH
21936: CALL_OW 1
21940: ST_TO_ADDR
// result := list ;
21941: LD_ADDR_VAR 0 4
21945: PUSH
21946: LD_VAR 0 1
21950: ST_TO_ADDR
// end ;
21951: LD_VAR 0 4
21955: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21956: LD_INT 0
21958: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21959: LD_ADDR_VAR 0 5
21963: PUSH
21964: LD_VAR 0 1
21968: PPUSH
21969: CALL_OW 250
21973: PPUSH
21974: LD_VAR 0 1
21978: PPUSH
21979: CALL_OW 251
21983: PPUSH
21984: LD_VAR 0 2
21988: PPUSH
21989: LD_VAR 0 3
21993: PPUSH
21994: LD_VAR 0 4
21998: PPUSH
21999: CALL 22009 0 5
22003: ST_TO_ADDR
// end ;
22004: LD_VAR 0 5
22008: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
22009: LD_INT 0
22011: PPUSH
22012: PPUSH
22013: PPUSH
22014: PPUSH
// if not list then
22015: LD_VAR 0 3
22019: NOT
22020: IFFALSE 22024
// exit ;
22022: GO 22412
// result := [ ] ;
22024: LD_ADDR_VAR 0 6
22028: PUSH
22029: EMPTY
22030: ST_TO_ADDR
// for i in list do
22031: LD_ADDR_VAR 0 7
22035: PUSH
22036: LD_VAR 0 3
22040: PUSH
22041: FOR_IN
22042: IFFALSE 22244
// begin tmp := GetDistUnitXY ( i , x , y ) ;
22044: LD_ADDR_VAR 0 9
22048: PUSH
22049: LD_VAR 0 7
22053: PPUSH
22054: LD_VAR 0 1
22058: PPUSH
22059: LD_VAR 0 2
22063: PPUSH
22064: CALL_OW 297
22068: ST_TO_ADDR
// if not result then
22069: LD_VAR 0 6
22073: NOT
22074: IFFALSE 22100
// result := [ [ i , tmp ] ] else
22076: LD_ADDR_VAR 0 6
22080: PUSH
22081: LD_VAR 0 7
22085: PUSH
22086: LD_VAR 0 9
22090: PUSH
22091: EMPTY
22092: LIST
22093: LIST
22094: PUSH
22095: EMPTY
22096: LIST
22097: ST_TO_ADDR
22098: GO 22242
// begin if result [ result ] [ 2 ] < tmp then
22100: LD_VAR 0 6
22104: PUSH
22105: LD_VAR 0 6
22109: ARRAY
22110: PUSH
22111: LD_INT 2
22113: ARRAY
22114: PUSH
22115: LD_VAR 0 9
22119: LESS
22120: IFFALSE 22162
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
22122: LD_ADDR_VAR 0 6
22126: PUSH
22127: LD_VAR 0 6
22131: PPUSH
22132: LD_VAR 0 6
22136: PUSH
22137: LD_INT 1
22139: PLUS
22140: PPUSH
22141: LD_VAR 0 7
22145: PUSH
22146: LD_VAR 0 9
22150: PUSH
22151: EMPTY
22152: LIST
22153: LIST
22154: PPUSH
22155: CALL_OW 2
22159: ST_TO_ADDR
22160: GO 22242
// for j = 1 to result do
22162: LD_ADDR_VAR 0 8
22166: PUSH
22167: DOUBLE
22168: LD_INT 1
22170: DEC
22171: ST_TO_ADDR
22172: LD_VAR 0 6
22176: PUSH
22177: FOR_TO
22178: IFFALSE 22240
// begin if tmp < result [ j ] [ 2 ] then
22180: LD_VAR 0 9
22184: PUSH
22185: LD_VAR 0 6
22189: PUSH
22190: LD_VAR 0 8
22194: ARRAY
22195: PUSH
22196: LD_INT 2
22198: ARRAY
22199: LESS
22200: IFFALSE 22238
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22202: LD_ADDR_VAR 0 6
22206: PUSH
22207: LD_VAR 0 6
22211: PPUSH
22212: LD_VAR 0 8
22216: PPUSH
22217: LD_VAR 0 7
22221: PUSH
22222: LD_VAR 0 9
22226: PUSH
22227: EMPTY
22228: LIST
22229: LIST
22230: PPUSH
22231: CALL_OW 2
22235: ST_TO_ADDR
// break ;
22236: GO 22240
// end ; end ;
22238: GO 22177
22240: POP
22241: POP
// end ; end ;
22242: GO 22041
22244: POP
22245: POP
// if result and not asc then
22246: LD_VAR 0 6
22250: PUSH
22251: LD_VAR 0 4
22255: NOT
22256: AND
22257: IFFALSE 22332
// begin tmp := result ;
22259: LD_ADDR_VAR 0 9
22263: PUSH
22264: LD_VAR 0 6
22268: ST_TO_ADDR
// for i = tmp downto 1 do
22269: LD_ADDR_VAR 0 7
22273: PUSH
22274: DOUBLE
22275: LD_VAR 0 9
22279: INC
22280: ST_TO_ADDR
22281: LD_INT 1
22283: PUSH
22284: FOR_DOWNTO
22285: IFFALSE 22330
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
22287: LD_ADDR_VAR 0 6
22291: PUSH
22292: LD_VAR 0 6
22296: PPUSH
22297: LD_VAR 0 9
22301: PUSH
22302: LD_VAR 0 7
22306: MINUS
22307: PUSH
22308: LD_INT 1
22310: PLUS
22311: PPUSH
22312: LD_VAR 0 9
22316: PUSH
22317: LD_VAR 0 7
22321: ARRAY
22322: PPUSH
22323: CALL_OW 1
22327: ST_TO_ADDR
22328: GO 22284
22330: POP
22331: POP
// end ; tmp := [ ] ;
22332: LD_ADDR_VAR 0 9
22336: PUSH
22337: EMPTY
22338: ST_TO_ADDR
// if mode then
22339: LD_VAR 0 5
22343: IFFALSE 22412
// begin for i = 1 to result do
22345: LD_ADDR_VAR 0 7
22349: PUSH
22350: DOUBLE
22351: LD_INT 1
22353: DEC
22354: ST_TO_ADDR
22355: LD_VAR 0 6
22359: PUSH
22360: FOR_TO
22361: IFFALSE 22400
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
22363: LD_ADDR_VAR 0 9
22367: PUSH
22368: LD_VAR 0 9
22372: PPUSH
22373: LD_VAR 0 7
22377: PPUSH
22378: LD_VAR 0 6
22382: PUSH
22383: LD_VAR 0 7
22387: ARRAY
22388: PUSH
22389: LD_INT 1
22391: ARRAY
22392: PPUSH
22393: CALL_OW 1
22397: ST_TO_ADDR
22398: GO 22360
22400: POP
22401: POP
// result := tmp ;
22402: LD_ADDR_VAR 0 6
22406: PUSH
22407: LD_VAR 0 9
22411: ST_TO_ADDR
// end ; end ;
22412: LD_VAR 0 6
22416: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22417: LD_INT 0
22419: PPUSH
22420: PPUSH
22421: PPUSH
22422: PPUSH
22423: PPUSH
22424: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22425: LD_ADDR_VAR 0 5
22429: PUSH
22430: LD_INT 0
22432: PUSH
22433: LD_INT 0
22435: PUSH
22436: LD_INT 0
22438: PUSH
22439: EMPTY
22440: PUSH
22441: EMPTY
22442: LIST
22443: LIST
22444: LIST
22445: LIST
22446: ST_TO_ADDR
// if not x or not y then
22447: LD_VAR 0 2
22451: NOT
22452: PUSH
22453: LD_VAR 0 3
22457: NOT
22458: OR
22459: IFFALSE 22463
// exit ;
22461: GO 24109
// if not range then
22463: LD_VAR 0 4
22467: NOT
22468: IFFALSE 22478
// range := 10 ;
22470: LD_ADDR_VAR 0 4
22474: PUSH
22475: LD_INT 10
22477: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22478: LD_ADDR_VAR 0 8
22482: PUSH
22483: LD_INT 81
22485: PUSH
22486: LD_VAR 0 1
22490: PUSH
22491: EMPTY
22492: LIST
22493: LIST
22494: PUSH
22495: LD_INT 92
22497: PUSH
22498: LD_VAR 0 2
22502: PUSH
22503: LD_VAR 0 3
22507: PUSH
22508: LD_VAR 0 4
22512: PUSH
22513: EMPTY
22514: LIST
22515: LIST
22516: LIST
22517: LIST
22518: PUSH
22519: LD_INT 3
22521: PUSH
22522: LD_INT 21
22524: PUSH
22525: LD_INT 3
22527: PUSH
22528: EMPTY
22529: LIST
22530: LIST
22531: PUSH
22532: EMPTY
22533: LIST
22534: LIST
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: LIST
22540: PPUSH
22541: CALL_OW 69
22545: ST_TO_ADDR
// if not tmp then
22546: LD_VAR 0 8
22550: NOT
22551: IFFALSE 22555
// exit ;
22553: GO 24109
// for i in tmp do
22555: LD_ADDR_VAR 0 6
22559: PUSH
22560: LD_VAR 0 8
22564: PUSH
22565: FOR_IN
22566: IFFALSE 24084
// begin points := [ 0 , 0 , 0 ] ;
22568: LD_ADDR_VAR 0 9
22572: PUSH
22573: LD_INT 0
22575: PUSH
22576: LD_INT 0
22578: PUSH
22579: LD_INT 0
22581: PUSH
22582: EMPTY
22583: LIST
22584: LIST
22585: LIST
22586: ST_TO_ADDR
// bpoints := 1 ;
22587: LD_ADDR_VAR 0 10
22591: PUSH
22592: LD_INT 1
22594: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22595: LD_VAR 0 6
22599: PPUSH
22600: CALL_OW 247
22604: PUSH
22605: LD_INT 1
22607: DOUBLE
22608: EQUAL
22609: IFTRUE 22613
22611: GO 23191
22613: POP
// begin if GetClass ( i ) = 1 then
22614: LD_VAR 0 6
22618: PPUSH
22619: CALL_OW 257
22623: PUSH
22624: LD_INT 1
22626: EQUAL
22627: IFFALSE 22648
// points := [ 10 , 5 , 3 ] ;
22629: LD_ADDR_VAR 0 9
22633: PUSH
22634: LD_INT 10
22636: PUSH
22637: LD_INT 5
22639: PUSH
22640: LD_INT 3
22642: PUSH
22643: EMPTY
22644: LIST
22645: LIST
22646: LIST
22647: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22648: LD_VAR 0 6
22652: PPUSH
22653: CALL_OW 257
22657: PUSH
22658: LD_INT 2
22660: PUSH
22661: LD_INT 3
22663: PUSH
22664: LD_INT 4
22666: PUSH
22667: EMPTY
22668: LIST
22669: LIST
22670: LIST
22671: IN
22672: IFFALSE 22693
// points := [ 3 , 2 , 1 ] ;
22674: LD_ADDR_VAR 0 9
22678: PUSH
22679: LD_INT 3
22681: PUSH
22682: LD_INT 2
22684: PUSH
22685: LD_INT 1
22687: PUSH
22688: EMPTY
22689: LIST
22690: LIST
22691: LIST
22692: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22693: LD_VAR 0 6
22697: PPUSH
22698: CALL_OW 257
22702: PUSH
22703: LD_INT 5
22705: EQUAL
22706: IFFALSE 22727
// points := [ 130 , 5 , 2 ] ;
22708: LD_ADDR_VAR 0 9
22712: PUSH
22713: LD_INT 130
22715: PUSH
22716: LD_INT 5
22718: PUSH
22719: LD_INT 2
22721: PUSH
22722: EMPTY
22723: LIST
22724: LIST
22725: LIST
22726: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22727: LD_VAR 0 6
22731: PPUSH
22732: CALL_OW 257
22736: PUSH
22737: LD_INT 8
22739: EQUAL
22740: IFFALSE 22761
// points := [ 35 , 35 , 30 ] ;
22742: LD_ADDR_VAR 0 9
22746: PUSH
22747: LD_INT 35
22749: PUSH
22750: LD_INT 35
22752: PUSH
22753: LD_INT 30
22755: PUSH
22756: EMPTY
22757: LIST
22758: LIST
22759: LIST
22760: ST_TO_ADDR
// if GetClass ( i ) = 9 then
22761: LD_VAR 0 6
22765: PPUSH
22766: CALL_OW 257
22770: PUSH
22771: LD_INT 9
22773: EQUAL
22774: IFFALSE 22795
// points := [ 20 , 55 , 40 ] ;
22776: LD_ADDR_VAR 0 9
22780: PUSH
22781: LD_INT 20
22783: PUSH
22784: LD_INT 55
22786: PUSH
22787: LD_INT 40
22789: PUSH
22790: EMPTY
22791: LIST
22792: LIST
22793: LIST
22794: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
22795: LD_VAR 0 6
22799: PPUSH
22800: CALL_OW 257
22804: PUSH
22805: LD_INT 12
22807: PUSH
22808: LD_INT 16
22810: PUSH
22811: EMPTY
22812: LIST
22813: LIST
22814: IN
22815: IFFALSE 22836
// points := [ 5 , 3 , 2 ] ;
22817: LD_ADDR_VAR 0 9
22821: PUSH
22822: LD_INT 5
22824: PUSH
22825: LD_INT 3
22827: PUSH
22828: LD_INT 2
22830: PUSH
22831: EMPTY
22832: LIST
22833: LIST
22834: LIST
22835: ST_TO_ADDR
// if GetClass ( i ) = 17 then
22836: LD_VAR 0 6
22840: PPUSH
22841: CALL_OW 257
22845: PUSH
22846: LD_INT 17
22848: EQUAL
22849: IFFALSE 22870
// points := [ 100 , 50 , 75 ] ;
22851: LD_ADDR_VAR 0 9
22855: PUSH
22856: LD_INT 100
22858: PUSH
22859: LD_INT 50
22861: PUSH
22862: LD_INT 75
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: LIST
22869: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22870: LD_VAR 0 6
22874: PPUSH
22875: CALL_OW 257
22879: PUSH
22880: LD_INT 15
22882: EQUAL
22883: IFFALSE 22904
// points := [ 10 , 5 , 3 ] ;
22885: LD_ADDR_VAR 0 9
22889: PUSH
22890: LD_INT 10
22892: PUSH
22893: LD_INT 5
22895: PUSH
22896: LD_INT 3
22898: PUSH
22899: EMPTY
22900: LIST
22901: LIST
22902: LIST
22903: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22904: LD_VAR 0 6
22908: PPUSH
22909: CALL_OW 257
22913: PUSH
22914: LD_INT 14
22916: EQUAL
22917: IFFALSE 22938
// points := [ 10 , 0 , 0 ] ;
22919: LD_ADDR_VAR 0 9
22923: PUSH
22924: LD_INT 10
22926: PUSH
22927: LD_INT 0
22929: PUSH
22930: LD_INT 0
22932: PUSH
22933: EMPTY
22934: LIST
22935: LIST
22936: LIST
22937: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22938: LD_VAR 0 6
22942: PPUSH
22943: CALL_OW 257
22947: PUSH
22948: LD_INT 11
22950: EQUAL
22951: IFFALSE 22972
// points := [ 30 , 10 , 5 ] ;
22953: LD_ADDR_VAR 0 9
22957: PUSH
22958: LD_INT 30
22960: PUSH
22961: LD_INT 10
22963: PUSH
22964: LD_INT 5
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: LIST
22971: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22972: LD_VAR 0 1
22976: PPUSH
22977: LD_INT 5
22979: PPUSH
22980: CALL_OW 321
22984: PUSH
22985: LD_INT 2
22987: EQUAL
22988: IFFALSE 23005
// bpoints := bpoints * 1.8 ;
22990: LD_ADDR_VAR 0 10
22994: PUSH
22995: LD_VAR 0 10
22999: PUSH
23000: LD_REAL  1.80000000000000E+0000
23003: MUL
23004: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
23005: LD_VAR 0 6
23009: PPUSH
23010: CALL_OW 257
23014: PUSH
23015: LD_INT 1
23017: PUSH
23018: LD_INT 2
23020: PUSH
23021: LD_INT 3
23023: PUSH
23024: LD_INT 4
23026: PUSH
23027: EMPTY
23028: LIST
23029: LIST
23030: LIST
23031: LIST
23032: IN
23033: PUSH
23034: LD_VAR 0 1
23038: PPUSH
23039: LD_INT 51
23041: PPUSH
23042: CALL_OW 321
23046: PUSH
23047: LD_INT 2
23049: EQUAL
23050: AND
23051: IFFALSE 23068
// bpoints := bpoints * 1.2 ;
23053: LD_ADDR_VAR 0 10
23057: PUSH
23058: LD_VAR 0 10
23062: PUSH
23063: LD_REAL  1.20000000000000E+0000
23066: MUL
23067: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
23068: LD_VAR 0 6
23072: PPUSH
23073: CALL_OW 257
23077: PUSH
23078: LD_INT 5
23080: PUSH
23081: LD_INT 7
23083: PUSH
23084: LD_INT 9
23086: PUSH
23087: EMPTY
23088: LIST
23089: LIST
23090: LIST
23091: IN
23092: PUSH
23093: LD_VAR 0 1
23097: PPUSH
23098: LD_INT 52
23100: PPUSH
23101: CALL_OW 321
23105: PUSH
23106: LD_INT 2
23108: EQUAL
23109: AND
23110: IFFALSE 23127
// bpoints := bpoints * 1.5 ;
23112: LD_ADDR_VAR 0 10
23116: PUSH
23117: LD_VAR 0 10
23121: PUSH
23122: LD_REAL  1.50000000000000E+0000
23125: MUL
23126: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
23127: LD_VAR 0 1
23131: PPUSH
23132: LD_INT 66
23134: PPUSH
23135: CALL_OW 321
23139: PUSH
23140: LD_INT 2
23142: EQUAL
23143: IFFALSE 23160
// bpoints := bpoints * 1.1 ;
23145: LD_ADDR_VAR 0 10
23149: PUSH
23150: LD_VAR 0 10
23154: PUSH
23155: LD_REAL  1.10000000000000E+0000
23158: MUL
23159: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
23160: LD_ADDR_VAR 0 10
23164: PUSH
23165: LD_VAR 0 10
23169: PUSH
23170: LD_VAR 0 6
23174: PPUSH
23175: LD_INT 1
23177: PPUSH
23178: CALL_OW 259
23182: PUSH
23183: LD_REAL  1.15000000000000E+0000
23186: MUL
23187: MUL
23188: ST_TO_ADDR
// end ; unit_vehicle :
23189: GO 24013
23191: LD_INT 2
23193: DOUBLE
23194: EQUAL
23195: IFTRUE 23199
23197: GO 24001
23199: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
23200: LD_VAR 0 6
23204: PPUSH
23205: CALL_OW 264
23209: PUSH
23210: LD_INT 2
23212: PUSH
23213: LD_INT 42
23215: PUSH
23216: LD_INT 24
23218: PUSH
23219: EMPTY
23220: LIST
23221: LIST
23222: LIST
23223: IN
23224: IFFALSE 23245
// points := [ 25 , 5 , 3 ] ;
23226: LD_ADDR_VAR 0 9
23230: PUSH
23231: LD_INT 25
23233: PUSH
23234: LD_INT 5
23236: PUSH
23237: LD_INT 3
23239: PUSH
23240: EMPTY
23241: LIST
23242: LIST
23243: LIST
23244: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
23245: LD_VAR 0 6
23249: PPUSH
23250: CALL_OW 264
23254: PUSH
23255: LD_INT 4
23257: PUSH
23258: LD_INT 43
23260: PUSH
23261: LD_INT 25
23263: PUSH
23264: EMPTY
23265: LIST
23266: LIST
23267: LIST
23268: IN
23269: IFFALSE 23290
// points := [ 40 , 15 , 5 ] ;
23271: LD_ADDR_VAR 0 9
23275: PUSH
23276: LD_INT 40
23278: PUSH
23279: LD_INT 15
23281: PUSH
23282: LD_INT 5
23284: PUSH
23285: EMPTY
23286: LIST
23287: LIST
23288: LIST
23289: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
23290: LD_VAR 0 6
23294: PPUSH
23295: CALL_OW 264
23299: PUSH
23300: LD_INT 3
23302: PUSH
23303: LD_INT 23
23305: PUSH
23306: EMPTY
23307: LIST
23308: LIST
23309: IN
23310: IFFALSE 23331
// points := [ 7 , 25 , 8 ] ;
23312: LD_ADDR_VAR 0 9
23316: PUSH
23317: LD_INT 7
23319: PUSH
23320: LD_INT 25
23322: PUSH
23323: LD_INT 8
23325: PUSH
23326: EMPTY
23327: LIST
23328: LIST
23329: LIST
23330: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
23331: LD_VAR 0 6
23335: PPUSH
23336: CALL_OW 264
23340: PUSH
23341: LD_INT 5
23343: PUSH
23344: LD_INT 27
23346: PUSH
23347: LD_INT 44
23349: PUSH
23350: EMPTY
23351: LIST
23352: LIST
23353: LIST
23354: IN
23355: IFFALSE 23376
// points := [ 14 , 50 , 16 ] ;
23357: LD_ADDR_VAR 0 9
23361: PUSH
23362: LD_INT 14
23364: PUSH
23365: LD_INT 50
23367: PUSH
23368: LD_INT 16
23370: PUSH
23371: EMPTY
23372: LIST
23373: LIST
23374: LIST
23375: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23376: LD_VAR 0 6
23380: PPUSH
23381: CALL_OW 264
23385: PUSH
23386: LD_INT 6
23388: PUSH
23389: LD_INT 46
23391: PUSH
23392: EMPTY
23393: LIST
23394: LIST
23395: IN
23396: IFFALSE 23417
// points := [ 32 , 120 , 70 ] ;
23398: LD_ADDR_VAR 0 9
23402: PUSH
23403: LD_INT 32
23405: PUSH
23406: LD_INT 120
23408: PUSH
23409: LD_INT 70
23411: PUSH
23412: EMPTY
23413: LIST
23414: LIST
23415: LIST
23416: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
23417: LD_VAR 0 6
23421: PPUSH
23422: CALL_OW 264
23426: PUSH
23427: LD_INT 7
23429: PUSH
23430: LD_INT 28
23432: PUSH
23433: LD_INT 45
23435: PUSH
23436: EMPTY
23437: LIST
23438: LIST
23439: LIST
23440: IN
23441: IFFALSE 23462
// points := [ 35 , 20 , 45 ] ;
23443: LD_ADDR_VAR 0 9
23447: PUSH
23448: LD_INT 35
23450: PUSH
23451: LD_INT 20
23453: PUSH
23454: LD_INT 45
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: LIST
23461: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23462: LD_VAR 0 6
23466: PPUSH
23467: CALL_OW 264
23471: PUSH
23472: LD_INT 47
23474: PUSH
23475: EMPTY
23476: LIST
23477: IN
23478: IFFALSE 23499
// points := [ 67 , 45 , 75 ] ;
23480: LD_ADDR_VAR 0 9
23484: PUSH
23485: LD_INT 67
23487: PUSH
23488: LD_INT 45
23490: PUSH
23491: LD_INT 75
23493: PUSH
23494: EMPTY
23495: LIST
23496: LIST
23497: LIST
23498: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23499: LD_VAR 0 6
23503: PPUSH
23504: CALL_OW 264
23508: PUSH
23509: LD_INT 26
23511: PUSH
23512: EMPTY
23513: LIST
23514: IN
23515: IFFALSE 23536
// points := [ 120 , 30 , 80 ] ;
23517: LD_ADDR_VAR 0 9
23521: PUSH
23522: LD_INT 120
23524: PUSH
23525: LD_INT 30
23527: PUSH
23528: LD_INT 80
23530: PUSH
23531: EMPTY
23532: LIST
23533: LIST
23534: LIST
23535: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23536: LD_VAR 0 6
23540: PPUSH
23541: CALL_OW 264
23545: PUSH
23546: LD_INT 22
23548: PUSH
23549: EMPTY
23550: LIST
23551: IN
23552: IFFALSE 23573
// points := [ 40 , 1 , 1 ] ;
23554: LD_ADDR_VAR 0 9
23558: PUSH
23559: LD_INT 40
23561: PUSH
23562: LD_INT 1
23564: PUSH
23565: LD_INT 1
23567: PUSH
23568: EMPTY
23569: LIST
23570: LIST
23571: LIST
23572: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23573: LD_VAR 0 6
23577: PPUSH
23578: CALL_OW 264
23582: PUSH
23583: LD_INT 29
23585: PUSH
23586: EMPTY
23587: LIST
23588: IN
23589: IFFALSE 23610
// points := [ 70 , 200 , 400 ] ;
23591: LD_ADDR_VAR 0 9
23595: PUSH
23596: LD_INT 70
23598: PUSH
23599: LD_INT 200
23601: PUSH
23602: LD_INT 400
23604: PUSH
23605: EMPTY
23606: LIST
23607: LIST
23608: LIST
23609: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23610: LD_VAR 0 6
23614: PPUSH
23615: CALL_OW 264
23619: PUSH
23620: LD_INT 14
23622: PUSH
23623: LD_INT 53
23625: PUSH
23626: EMPTY
23627: LIST
23628: LIST
23629: IN
23630: IFFALSE 23651
// points := [ 40 , 10 , 20 ] ;
23632: LD_ADDR_VAR 0 9
23636: PUSH
23637: LD_INT 40
23639: PUSH
23640: LD_INT 10
23642: PUSH
23643: LD_INT 20
23645: PUSH
23646: EMPTY
23647: LIST
23648: LIST
23649: LIST
23650: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23651: LD_VAR 0 6
23655: PPUSH
23656: CALL_OW 264
23660: PUSH
23661: LD_INT 9
23663: PUSH
23664: EMPTY
23665: LIST
23666: IN
23667: IFFALSE 23688
// points := [ 5 , 70 , 20 ] ;
23669: LD_ADDR_VAR 0 9
23673: PUSH
23674: LD_INT 5
23676: PUSH
23677: LD_INT 70
23679: PUSH
23680: LD_INT 20
23682: PUSH
23683: EMPTY
23684: LIST
23685: LIST
23686: LIST
23687: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23688: LD_VAR 0 6
23692: PPUSH
23693: CALL_OW 264
23697: PUSH
23698: LD_INT 10
23700: PUSH
23701: EMPTY
23702: LIST
23703: IN
23704: IFFALSE 23725
// points := [ 35 , 110 , 70 ] ;
23706: LD_ADDR_VAR 0 9
23710: PUSH
23711: LD_INT 35
23713: PUSH
23714: LD_INT 110
23716: PUSH
23717: LD_INT 70
23719: PUSH
23720: EMPTY
23721: LIST
23722: LIST
23723: LIST
23724: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23725: LD_VAR 0 6
23729: PPUSH
23730: CALL_OW 265
23734: PUSH
23735: LD_INT 25
23737: EQUAL
23738: IFFALSE 23759
// points := [ 80 , 65 , 100 ] ;
23740: LD_ADDR_VAR 0 9
23744: PUSH
23745: LD_INT 80
23747: PUSH
23748: LD_INT 65
23750: PUSH
23751: LD_INT 100
23753: PUSH
23754: EMPTY
23755: LIST
23756: LIST
23757: LIST
23758: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
23759: LD_VAR 0 6
23763: PPUSH
23764: CALL_OW 263
23768: PUSH
23769: LD_INT 1
23771: EQUAL
23772: IFFALSE 23807
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
23774: LD_ADDR_VAR 0 10
23778: PUSH
23779: LD_VAR 0 10
23783: PUSH
23784: LD_VAR 0 6
23788: PPUSH
23789: CALL_OW 311
23793: PPUSH
23794: LD_INT 3
23796: PPUSH
23797: CALL_OW 259
23801: PUSH
23802: LD_INT 4
23804: MUL
23805: MUL
23806: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
23807: LD_VAR 0 6
23811: PPUSH
23812: CALL_OW 263
23816: PUSH
23817: LD_INT 2
23819: EQUAL
23820: IFFALSE 23871
// begin j := IsControledBy ( i ) ;
23822: LD_ADDR_VAR 0 7
23826: PUSH
23827: LD_VAR 0 6
23831: PPUSH
23832: CALL_OW 312
23836: ST_TO_ADDR
// if j then
23837: LD_VAR 0 7
23841: IFFALSE 23871
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
23843: LD_ADDR_VAR 0 10
23847: PUSH
23848: LD_VAR 0 10
23852: PUSH
23853: LD_VAR 0 7
23857: PPUSH
23858: LD_INT 3
23860: PPUSH
23861: CALL_OW 259
23865: PUSH
23866: LD_INT 3
23868: MUL
23869: MUL
23870: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23871: LD_VAR 0 6
23875: PPUSH
23876: CALL_OW 264
23880: PUSH
23881: LD_INT 5
23883: PUSH
23884: LD_INT 6
23886: PUSH
23887: LD_INT 46
23889: PUSH
23890: LD_INT 44
23892: PUSH
23893: LD_INT 47
23895: PUSH
23896: LD_INT 45
23898: PUSH
23899: LD_INT 28
23901: PUSH
23902: LD_INT 7
23904: PUSH
23905: LD_INT 27
23907: PUSH
23908: LD_INT 29
23910: PUSH
23911: EMPTY
23912: LIST
23913: LIST
23914: LIST
23915: LIST
23916: LIST
23917: LIST
23918: LIST
23919: LIST
23920: LIST
23921: LIST
23922: IN
23923: PUSH
23924: LD_VAR 0 1
23928: PPUSH
23929: LD_INT 52
23931: PPUSH
23932: CALL_OW 321
23936: PUSH
23937: LD_INT 2
23939: EQUAL
23940: AND
23941: IFFALSE 23958
// bpoints := bpoints * 1.2 ;
23943: LD_ADDR_VAR 0 10
23947: PUSH
23948: LD_VAR 0 10
23952: PUSH
23953: LD_REAL  1.20000000000000E+0000
23956: MUL
23957: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23958: LD_VAR 0 6
23962: PPUSH
23963: CALL_OW 264
23967: PUSH
23968: LD_INT 6
23970: PUSH
23971: LD_INT 46
23973: PUSH
23974: LD_INT 47
23976: PUSH
23977: EMPTY
23978: LIST
23979: LIST
23980: LIST
23981: IN
23982: IFFALSE 23999
// bpoints := bpoints * 1.2 ;
23984: LD_ADDR_VAR 0 10
23988: PUSH
23989: LD_VAR 0 10
23993: PUSH
23994: LD_REAL  1.20000000000000E+0000
23997: MUL
23998: ST_TO_ADDR
// end ; unit_building :
23999: GO 24013
24001: LD_INT 3
24003: DOUBLE
24004: EQUAL
24005: IFTRUE 24009
24007: GO 24012
24009: POP
// ; end ;
24010: GO 24013
24012: POP
// for j = 1 to 3 do
24013: LD_ADDR_VAR 0 7
24017: PUSH
24018: DOUBLE
24019: LD_INT 1
24021: DEC
24022: ST_TO_ADDR
24023: LD_INT 3
24025: PUSH
24026: FOR_TO
24027: IFFALSE 24080
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
24029: LD_ADDR_VAR 0 5
24033: PUSH
24034: LD_VAR 0 5
24038: PPUSH
24039: LD_VAR 0 7
24043: PPUSH
24044: LD_VAR 0 5
24048: PUSH
24049: LD_VAR 0 7
24053: ARRAY
24054: PUSH
24055: LD_VAR 0 9
24059: PUSH
24060: LD_VAR 0 7
24064: ARRAY
24065: PUSH
24066: LD_VAR 0 10
24070: MUL
24071: PLUS
24072: PPUSH
24073: CALL_OW 1
24077: ST_TO_ADDR
24078: GO 24026
24080: POP
24081: POP
// end ;
24082: GO 22565
24084: POP
24085: POP
// result := Replace ( result , 4 , tmp ) ;
24086: LD_ADDR_VAR 0 5
24090: PUSH
24091: LD_VAR 0 5
24095: PPUSH
24096: LD_INT 4
24098: PPUSH
24099: LD_VAR 0 8
24103: PPUSH
24104: CALL_OW 1
24108: ST_TO_ADDR
// end ;
24109: LD_VAR 0 5
24113: RET
// export function DangerAtRange ( unit , range ) ; begin
24114: LD_INT 0
24116: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
24117: LD_ADDR_VAR 0 3
24121: PUSH
24122: LD_VAR 0 1
24126: PPUSH
24127: CALL_OW 255
24131: PPUSH
24132: LD_VAR 0 1
24136: PPUSH
24137: CALL_OW 250
24141: PPUSH
24142: LD_VAR 0 1
24146: PPUSH
24147: CALL_OW 251
24151: PPUSH
24152: LD_VAR 0 2
24156: PPUSH
24157: CALL 22417 0 4
24161: ST_TO_ADDR
// end ;
24162: LD_VAR 0 3
24166: RET
// export function DangerInArea ( side , area ) ; begin
24167: LD_INT 0
24169: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
24170: LD_ADDR_VAR 0 3
24174: PUSH
24175: LD_VAR 0 2
24179: PPUSH
24180: LD_INT 81
24182: PUSH
24183: LD_VAR 0 1
24187: PUSH
24188: EMPTY
24189: LIST
24190: LIST
24191: PPUSH
24192: CALL_OW 70
24196: ST_TO_ADDR
// end ;
24197: LD_VAR 0 3
24201: RET
// export function IsExtension ( b ) ; begin
24202: LD_INT 0
24204: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
24205: LD_ADDR_VAR 0 2
24209: PUSH
24210: LD_VAR 0 1
24214: PUSH
24215: LD_INT 23
24217: PUSH
24218: LD_INT 20
24220: PUSH
24221: LD_INT 22
24223: PUSH
24224: LD_INT 17
24226: PUSH
24227: LD_INT 24
24229: PUSH
24230: LD_INT 21
24232: PUSH
24233: LD_INT 19
24235: PUSH
24236: LD_INT 16
24238: PUSH
24239: LD_INT 25
24241: PUSH
24242: LD_INT 18
24244: PUSH
24245: EMPTY
24246: LIST
24247: LIST
24248: LIST
24249: LIST
24250: LIST
24251: LIST
24252: LIST
24253: LIST
24254: LIST
24255: LIST
24256: IN
24257: ST_TO_ADDR
// end ;
24258: LD_VAR 0 2
24262: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
24263: LD_INT 0
24265: PPUSH
24266: PPUSH
24267: PPUSH
// result := [ ] ;
24268: LD_ADDR_VAR 0 3
24272: PUSH
24273: EMPTY
24274: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
24275: LD_ADDR_VAR 0 4
24279: PUSH
24280: LD_VAR 0 2
24284: PPUSH
24285: LD_INT 21
24287: PUSH
24288: LD_INT 3
24290: PUSH
24291: EMPTY
24292: LIST
24293: LIST
24294: PPUSH
24295: CALL_OW 70
24299: ST_TO_ADDR
// if not tmp then
24300: LD_VAR 0 4
24304: NOT
24305: IFFALSE 24309
// exit ;
24307: GO 24367
// for i in tmp do
24309: LD_ADDR_VAR 0 5
24313: PUSH
24314: LD_VAR 0 4
24318: PUSH
24319: FOR_IN
24320: IFFALSE 24355
// if GetBase ( i ) <> base then
24322: LD_VAR 0 5
24326: PPUSH
24327: CALL_OW 274
24331: PUSH
24332: LD_VAR 0 1
24336: NONEQUAL
24337: IFFALSE 24353
// ComLinkToBase ( base , i ) ;
24339: LD_VAR 0 1
24343: PPUSH
24344: LD_VAR 0 5
24348: PPUSH
24349: CALL_OW 169
24353: GO 24319
24355: POP
24356: POP
// result := tmp ;
24357: LD_ADDR_VAR 0 3
24361: PUSH
24362: LD_VAR 0 4
24366: ST_TO_ADDR
// end ;
24367: LD_VAR 0 3
24371: RET
// export function ComComplete ( unit , b ) ; var i ; begin
24372: LD_INT 0
24374: PPUSH
24375: PPUSH
// if BuildingStatus ( b ) = bs_build then
24376: LD_VAR 0 2
24380: PPUSH
24381: CALL_OW 461
24385: PUSH
24386: LD_INT 1
24388: EQUAL
24389: IFFALSE 24449
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24391: LD_VAR 0 1
24395: PPUSH
24396: LD_STRING h
24398: PUSH
24399: LD_VAR 0 2
24403: PPUSH
24404: CALL_OW 250
24408: PUSH
24409: LD_VAR 0 2
24413: PPUSH
24414: CALL_OW 251
24418: PUSH
24419: LD_VAR 0 2
24423: PUSH
24424: LD_INT 0
24426: PUSH
24427: LD_INT 0
24429: PUSH
24430: LD_INT 0
24432: PUSH
24433: EMPTY
24434: LIST
24435: LIST
24436: LIST
24437: LIST
24438: LIST
24439: LIST
24440: LIST
24441: PUSH
24442: EMPTY
24443: LIST
24444: PPUSH
24445: CALL_OW 446
// end ;
24449: LD_VAR 0 3
24453: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24454: LD_INT 0
24456: PPUSH
24457: PPUSH
24458: PPUSH
24459: PPUSH
24460: PPUSH
24461: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
24462: LD_VAR 0 1
24466: NOT
24467: PUSH
24468: LD_VAR 0 1
24472: PPUSH
24473: CALL_OW 263
24477: PUSH
24478: LD_INT 2
24480: EQUAL
24481: NOT
24482: OR
24483: IFFALSE 24487
// exit ;
24485: GO 24803
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24487: LD_ADDR_VAR 0 6
24491: PUSH
24492: LD_INT 22
24494: PUSH
24495: LD_VAR 0 1
24499: PPUSH
24500: CALL_OW 255
24504: PUSH
24505: EMPTY
24506: LIST
24507: LIST
24508: PUSH
24509: LD_INT 2
24511: PUSH
24512: LD_INT 30
24514: PUSH
24515: LD_INT 36
24517: PUSH
24518: EMPTY
24519: LIST
24520: LIST
24521: PUSH
24522: LD_INT 34
24524: PUSH
24525: LD_INT 31
24527: PUSH
24528: EMPTY
24529: LIST
24530: LIST
24531: PUSH
24532: EMPTY
24533: LIST
24534: LIST
24535: LIST
24536: PUSH
24537: EMPTY
24538: LIST
24539: LIST
24540: PPUSH
24541: CALL_OW 69
24545: ST_TO_ADDR
// if not tmp then
24546: LD_VAR 0 6
24550: NOT
24551: IFFALSE 24555
// exit ;
24553: GO 24803
// result := [ ] ;
24555: LD_ADDR_VAR 0 2
24559: PUSH
24560: EMPTY
24561: ST_TO_ADDR
// for i in tmp do
24562: LD_ADDR_VAR 0 3
24566: PUSH
24567: LD_VAR 0 6
24571: PUSH
24572: FOR_IN
24573: IFFALSE 24644
// begin t := UnitsInside ( i ) ;
24575: LD_ADDR_VAR 0 4
24579: PUSH
24580: LD_VAR 0 3
24584: PPUSH
24585: CALL_OW 313
24589: ST_TO_ADDR
// if t then
24590: LD_VAR 0 4
24594: IFFALSE 24642
// for j in t do
24596: LD_ADDR_VAR 0 7
24600: PUSH
24601: LD_VAR 0 4
24605: PUSH
24606: FOR_IN
24607: IFFALSE 24640
// result := Insert ( result , result + 1 , j ) ;
24609: LD_ADDR_VAR 0 2
24613: PUSH
24614: LD_VAR 0 2
24618: PPUSH
24619: LD_VAR 0 2
24623: PUSH
24624: LD_INT 1
24626: PLUS
24627: PPUSH
24628: LD_VAR 0 7
24632: PPUSH
24633: CALL_OW 2
24637: ST_TO_ADDR
24638: GO 24606
24640: POP
24641: POP
// end ;
24642: GO 24572
24644: POP
24645: POP
// if not result then
24646: LD_VAR 0 2
24650: NOT
24651: IFFALSE 24655
// exit ;
24653: GO 24803
// mech := result [ 1 ] ;
24655: LD_ADDR_VAR 0 5
24659: PUSH
24660: LD_VAR 0 2
24664: PUSH
24665: LD_INT 1
24667: ARRAY
24668: ST_TO_ADDR
// if result > 1 then
24669: LD_VAR 0 2
24673: PUSH
24674: LD_INT 1
24676: GREATER
24677: IFFALSE 24789
// for i = 2 to result do
24679: LD_ADDR_VAR 0 3
24683: PUSH
24684: DOUBLE
24685: LD_INT 2
24687: DEC
24688: ST_TO_ADDR
24689: LD_VAR 0 2
24693: PUSH
24694: FOR_TO
24695: IFFALSE 24787
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24697: LD_ADDR_VAR 0 4
24701: PUSH
24702: LD_VAR 0 2
24706: PUSH
24707: LD_VAR 0 3
24711: ARRAY
24712: PPUSH
24713: LD_INT 3
24715: PPUSH
24716: CALL_OW 259
24720: PUSH
24721: LD_VAR 0 2
24725: PUSH
24726: LD_VAR 0 3
24730: ARRAY
24731: PPUSH
24732: CALL_OW 432
24736: MINUS
24737: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
24738: LD_VAR 0 4
24742: PUSH
24743: LD_VAR 0 5
24747: PPUSH
24748: LD_INT 3
24750: PPUSH
24751: CALL_OW 259
24755: PUSH
24756: LD_VAR 0 5
24760: PPUSH
24761: CALL_OW 432
24765: MINUS
24766: GREATEREQUAL
24767: IFFALSE 24785
// mech := result [ i ] ;
24769: LD_ADDR_VAR 0 5
24773: PUSH
24774: LD_VAR 0 2
24778: PUSH
24779: LD_VAR 0 3
24783: ARRAY
24784: ST_TO_ADDR
// end ;
24785: GO 24694
24787: POP
24788: POP
// ComLinkTo ( vehicle , mech ) ;
24789: LD_VAR 0 1
24793: PPUSH
24794: LD_VAR 0 5
24798: PPUSH
24799: CALL_OW 135
// end ;
24803: LD_VAR 0 2
24807: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
24808: LD_INT 0
24810: PPUSH
24811: PPUSH
24812: PPUSH
24813: PPUSH
24814: PPUSH
24815: PPUSH
24816: PPUSH
24817: PPUSH
24818: PPUSH
24819: PPUSH
24820: PPUSH
24821: PPUSH
24822: PPUSH
// result := [ ] ;
24823: LD_ADDR_VAR 0 7
24827: PUSH
24828: EMPTY
24829: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
24830: LD_VAR 0 1
24834: PPUSH
24835: CALL_OW 266
24839: PUSH
24840: LD_INT 0
24842: PUSH
24843: LD_INT 1
24845: PUSH
24846: EMPTY
24847: LIST
24848: LIST
24849: IN
24850: NOT
24851: IFFALSE 24855
// exit ;
24853: GO 26486
// if name then
24855: LD_VAR 0 3
24859: IFFALSE 24875
// SetBName ( base_dep , name ) ;
24861: LD_VAR 0 1
24865: PPUSH
24866: LD_VAR 0 3
24870: PPUSH
24871: CALL_OW 500
// base := GetBase ( base_dep ) ;
24875: LD_ADDR_VAR 0 15
24879: PUSH
24880: LD_VAR 0 1
24884: PPUSH
24885: CALL_OW 274
24889: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24890: LD_ADDR_VAR 0 16
24894: PUSH
24895: LD_VAR 0 1
24899: PPUSH
24900: CALL_OW 255
24904: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24905: LD_ADDR_VAR 0 17
24909: PUSH
24910: LD_VAR 0 1
24914: PPUSH
24915: CALL_OW 248
24919: ST_TO_ADDR
// if sources then
24920: LD_VAR 0 5
24924: IFFALSE 24971
// for i = 1 to 3 do
24926: LD_ADDR_VAR 0 8
24930: PUSH
24931: DOUBLE
24932: LD_INT 1
24934: DEC
24935: ST_TO_ADDR
24936: LD_INT 3
24938: PUSH
24939: FOR_TO
24940: IFFALSE 24969
// AddResourceType ( base , i , sources [ i ] ) ;
24942: LD_VAR 0 15
24946: PPUSH
24947: LD_VAR 0 8
24951: PPUSH
24952: LD_VAR 0 5
24956: PUSH
24957: LD_VAR 0 8
24961: ARRAY
24962: PPUSH
24963: CALL_OW 276
24967: GO 24939
24969: POP
24970: POP
// buildings := GetBaseBuildings ( base , area ) ;
24971: LD_ADDR_VAR 0 18
24975: PUSH
24976: LD_VAR 0 15
24980: PPUSH
24981: LD_VAR 0 2
24985: PPUSH
24986: CALL 24263 0 2
24990: ST_TO_ADDR
// InitHc ;
24991: CALL_OW 19
// InitUc ;
24995: CALL_OW 18
// uc_side := side ;
24999: LD_ADDR_OWVAR 20
25003: PUSH
25004: LD_VAR 0 16
25008: ST_TO_ADDR
// uc_nation := nation ;
25009: LD_ADDR_OWVAR 21
25013: PUSH
25014: LD_VAR 0 17
25018: ST_TO_ADDR
// if buildings then
25019: LD_VAR 0 18
25023: IFFALSE 26345
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
25025: LD_ADDR_VAR 0 19
25029: PUSH
25030: LD_VAR 0 18
25034: PPUSH
25035: LD_INT 2
25037: PUSH
25038: LD_INT 30
25040: PUSH
25041: LD_INT 29
25043: PUSH
25044: EMPTY
25045: LIST
25046: LIST
25047: PUSH
25048: LD_INT 30
25050: PUSH
25051: LD_INT 30
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: PUSH
25058: EMPTY
25059: LIST
25060: LIST
25061: LIST
25062: PPUSH
25063: CALL_OW 72
25067: ST_TO_ADDR
// if tmp then
25068: LD_VAR 0 19
25072: IFFALSE 25120
// for i in tmp do
25074: LD_ADDR_VAR 0 8
25078: PUSH
25079: LD_VAR 0 19
25083: PUSH
25084: FOR_IN
25085: IFFALSE 25118
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
25087: LD_VAR 0 8
25091: PPUSH
25092: CALL_OW 250
25096: PPUSH
25097: LD_VAR 0 8
25101: PPUSH
25102: CALL_OW 251
25106: PPUSH
25107: LD_VAR 0 16
25111: PPUSH
25112: CALL_OW 441
25116: GO 25084
25118: POP
25119: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
25120: LD_VAR 0 18
25124: PPUSH
25125: LD_INT 2
25127: PUSH
25128: LD_INT 30
25130: PUSH
25131: LD_INT 32
25133: PUSH
25134: EMPTY
25135: LIST
25136: LIST
25137: PUSH
25138: LD_INT 30
25140: PUSH
25141: LD_INT 33
25143: PUSH
25144: EMPTY
25145: LIST
25146: LIST
25147: PUSH
25148: EMPTY
25149: LIST
25150: LIST
25151: LIST
25152: PPUSH
25153: CALL_OW 72
25157: IFFALSE 25245
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
25159: LD_ADDR_VAR 0 8
25163: PUSH
25164: LD_VAR 0 18
25168: PPUSH
25169: LD_INT 2
25171: PUSH
25172: LD_INT 30
25174: PUSH
25175: LD_INT 32
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: PUSH
25182: LD_INT 30
25184: PUSH
25185: LD_INT 33
25187: PUSH
25188: EMPTY
25189: LIST
25190: LIST
25191: PUSH
25192: EMPTY
25193: LIST
25194: LIST
25195: LIST
25196: PPUSH
25197: CALL_OW 72
25201: PUSH
25202: FOR_IN
25203: IFFALSE 25243
// begin if not GetBWeapon ( i ) then
25205: LD_VAR 0 8
25209: PPUSH
25210: CALL_OW 269
25214: NOT
25215: IFFALSE 25241
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
25217: LD_VAR 0 8
25221: PPUSH
25222: LD_VAR 0 8
25226: PPUSH
25227: LD_VAR 0 2
25231: PPUSH
25232: CALL 26491 0 2
25236: PPUSH
25237: CALL_OW 431
// end ;
25241: GO 25202
25243: POP
25244: POP
// end ; for i = 1 to personel do
25245: LD_ADDR_VAR 0 8
25249: PUSH
25250: DOUBLE
25251: LD_INT 1
25253: DEC
25254: ST_TO_ADDR
25255: LD_VAR 0 6
25259: PUSH
25260: FOR_TO
25261: IFFALSE 26325
// begin if i > 4 then
25263: LD_VAR 0 8
25267: PUSH
25268: LD_INT 4
25270: GREATER
25271: IFFALSE 25275
// break ;
25273: GO 26325
// case i of 1 :
25275: LD_VAR 0 8
25279: PUSH
25280: LD_INT 1
25282: DOUBLE
25283: EQUAL
25284: IFTRUE 25288
25286: GO 25368
25288: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
25289: LD_ADDR_VAR 0 12
25293: PUSH
25294: LD_VAR 0 18
25298: PPUSH
25299: LD_INT 22
25301: PUSH
25302: LD_VAR 0 16
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: PUSH
25311: LD_INT 58
25313: PUSH
25314: EMPTY
25315: LIST
25316: PUSH
25317: LD_INT 2
25319: PUSH
25320: LD_INT 30
25322: PUSH
25323: LD_INT 32
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: PUSH
25330: LD_INT 30
25332: PUSH
25333: LD_INT 4
25335: PUSH
25336: EMPTY
25337: LIST
25338: LIST
25339: PUSH
25340: LD_INT 30
25342: PUSH
25343: LD_INT 5
25345: PUSH
25346: EMPTY
25347: LIST
25348: LIST
25349: PUSH
25350: EMPTY
25351: LIST
25352: LIST
25353: LIST
25354: LIST
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: LIST
25360: PPUSH
25361: CALL_OW 72
25365: ST_TO_ADDR
25366: GO 25590
25368: LD_INT 2
25370: DOUBLE
25371: EQUAL
25372: IFTRUE 25376
25374: GO 25438
25376: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25377: LD_ADDR_VAR 0 12
25381: PUSH
25382: LD_VAR 0 18
25386: PPUSH
25387: LD_INT 22
25389: PUSH
25390: LD_VAR 0 16
25394: PUSH
25395: EMPTY
25396: LIST
25397: LIST
25398: PUSH
25399: LD_INT 2
25401: PUSH
25402: LD_INT 30
25404: PUSH
25405: LD_INT 0
25407: PUSH
25408: EMPTY
25409: LIST
25410: LIST
25411: PUSH
25412: LD_INT 30
25414: PUSH
25415: LD_INT 1
25417: PUSH
25418: EMPTY
25419: LIST
25420: LIST
25421: PUSH
25422: EMPTY
25423: LIST
25424: LIST
25425: LIST
25426: PUSH
25427: EMPTY
25428: LIST
25429: LIST
25430: PPUSH
25431: CALL_OW 72
25435: ST_TO_ADDR
25436: GO 25590
25438: LD_INT 3
25440: DOUBLE
25441: EQUAL
25442: IFTRUE 25446
25444: GO 25508
25446: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25447: LD_ADDR_VAR 0 12
25451: PUSH
25452: LD_VAR 0 18
25456: PPUSH
25457: LD_INT 22
25459: PUSH
25460: LD_VAR 0 16
25464: PUSH
25465: EMPTY
25466: LIST
25467: LIST
25468: PUSH
25469: LD_INT 2
25471: PUSH
25472: LD_INT 30
25474: PUSH
25475: LD_INT 2
25477: PUSH
25478: EMPTY
25479: LIST
25480: LIST
25481: PUSH
25482: LD_INT 30
25484: PUSH
25485: LD_INT 3
25487: PUSH
25488: EMPTY
25489: LIST
25490: LIST
25491: PUSH
25492: EMPTY
25493: LIST
25494: LIST
25495: LIST
25496: PUSH
25497: EMPTY
25498: LIST
25499: LIST
25500: PPUSH
25501: CALL_OW 72
25505: ST_TO_ADDR
25506: GO 25590
25508: LD_INT 4
25510: DOUBLE
25511: EQUAL
25512: IFTRUE 25516
25514: GO 25589
25516: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25517: LD_ADDR_VAR 0 12
25521: PUSH
25522: LD_VAR 0 18
25526: PPUSH
25527: LD_INT 22
25529: PUSH
25530: LD_VAR 0 16
25534: PUSH
25535: EMPTY
25536: LIST
25537: LIST
25538: PUSH
25539: LD_INT 2
25541: PUSH
25542: LD_INT 30
25544: PUSH
25545: LD_INT 6
25547: PUSH
25548: EMPTY
25549: LIST
25550: LIST
25551: PUSH
25552: LD_INT 30
25554: PUSH
25555: LD_INT 7
25557: PUSH
25558: EMPTY
25559: LIST
25560: LIST
25561: PUSH
25562: LD_INT 30
25564: PUSH
25565: LD_INT 8
25567: PUSH
25568: EMPTY
25569: LIST
25570: LIST
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: LIST
25576: LIST
25577: PUSH
25578: EMPTY
25579: LIST
25580: LIST
25581: PPUSH
25582: CALL_OW 72
25586: ST_TO_ADDR
25587: GO 25590
25589: POP
// if i = 1 then
25590: LD_VAR 0 8
25594: PUSH
25595: LD_INT 1
25597: EQUAL
25598: IFFALSE 25709
// begin tmp := [ ] ;
25600: LD_ADDR_VAR 0 19
25604: PUSH
25605: EMPTY
25606: ST_TO_ADDR
// for j in f do
25607: LD_ADDR_VAR 0 9
25611: PUSH
25612: LD_VAR 0 12
25616: PUSH
25617: FOR_IN
25618: IFFALSE 25691
// if GetBType ( j ) = b_bunker then
25620: LD_VAR 0 9
25624: PPUSH
25625: CALL_OW 266
25629: PUSH
25630: LD_INT 32
25632: EQUAL
25633: IFFALSE 25660
// tmp := Insert ( tmp , 1 , j ) else
25635: LD_ADDR_VAR 0 19
25639: PUSH
25640: LD_VAR 0 19
25644: PPUSH
25645: LD_INT 1
25647: PPUSH
25648: LD_VAR 0 9
25652: PPUSH
25653: CALL_OW 2
25657: ST_TO_ADDR
25658: GO 25689
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25660: LD_ADDR_VAR 0 19
25664: PUSH
25665: LD_VAR 0 19
25669: PPUSH
25670: LD_VAR 0 19
25674: PUSH
25675: LD_INT 1
25677: PLUS
25678: PPUSH
25679: LD_VAR 0 9
25683: PPUSH
25684: CALL_OW 2
25688: ST_TO_ADDR
25689: GO 25617
25691: POP
25692: POP
// if tmp then
25693: LD_VAR 0 19
25697: IFFALSE 25709
// f := tmp ;
25699: LD_ADDR_VAR 0 12
25703: PUSH
25704: LD_VAR 0 19
25708: ST_TO_ADDR
// end ; x := personel [ i ] ;
25709: LD_ADDR_VAR 0 13
25713: PUSH
25714: LD_VAR 0 6
25718: PUSH
25719: LD_VAR 0 8
25723: ARRAY
25724: ST_TO_ADDR
// if x = - 1 then
25725: LD_VAR 0 13
25729: PUSH
25730: LD_INT 1
25732: NEG
25733: EQUAL
25734: IFFALSE 25943
// begin for j in f do
25736: LD_ADDR_VAR 0 9
25740: PUSH
25741: LD_VAR 0 12
25745: PUSH
25746: FOR_IN
25747: IFFALSE 25939
// repeat InitHc ;
25749: CALL_OW 19
// if GetBType ( j ) = b_barracks then
25753: LD_VAR 0 9
25757: PPUSH
25758: CALL_OW 266
25762: PUSH
25763: LD_INT 5
25765: EQUAL
25766: IFFALSE 25836
// begin if UnitsInside ( j ) < 3 then
25768: LD_VAR 0 9
25772: PPUSH
25773: CALL_OW 313
25777: PUSH
25778: LD_INT 3
25780: LESS
25781: IFFALSE 25817
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25783: LD_INT 0
25785: PPUSH
25786: LD_INT 5
25788: PUSH
25789: LD_INT 8
25791: PUSH
25792: LD_INT 9
25794: PUSH
25795: EMPTY
25796: LIST
25797: LIST
25798: LIST
25799: PUSH
25800: LD_VAR 0 17
25804: ARRAY
25805: PPUSH
25806: LD_VAR 0 4
25810: PPUSH
25811: CALL_OW 380
25815: GO 25834
// PrepareHuman ( false , i , skill ) ;
25817: LD_INT 0
25819: PPUSH
25820: LD_VAR 0 8
25824: PPUSH
25825: LD_VAR 0 4
25829: PPUSH
25830: CALL_OW 380
// end else
25834: GO 25853
// PrepareHuman ( false , i , skill ) ;
25836: LD_INT 0
25838: PPUSH
25839: LD_VAR 0 8
25843: PPUSH
25844: LD_VAR 0 4
25848: PPUSH
25849: CALL_OW 380
// un := CreateHuman ;
25853: LD_ADDR_VAR 0 14
25857: PUSH
25858: CALL_OW 44
25862: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25863: LD_ADDR_VAR 0 7
25867: PUSH
25868: LD_VAR 0 7
25872: PPUSH
25873: LD_INT 1
25875: PPUSH
25876: LD_VAR 0 14
25880: PPUSH
25881: CALL_OW 2
25885: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25886: LD_VAR 0 14
25890: PPUSH
25891: LD_VAR 0 9
25895: PPUSH
25896: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25900: LD_VAR 0 9
25904: PPUSH
25905: CALL_OW 313
25909: PUSH
25910: LD_INT 6
25912: EQUAL
25913: PUSH
25914: LD_VAR 0 9
25918: PPUSH
25919: CALL_OW 266
25923: PUSH
25924: LD_INT 32
25926: PUSH
25927: LD_INT 31
25929: PUSH
25930: EMPTY
25931: LIST
25932: LIST
25933: IN
25934: OR
25935: IFFALSE 25749
25937: GO 25746
25939: POP
25940: POP
// end else
25941: GO 26323
// for j = 1 to x do
25943: LD_ADDR_VAR 0 9
25947: PUSH
25948: DOUBLE
25949: LD_INT 1
25951: DEC
25952: ST_TO_ADDR
25953: LD_VAR 0 13
25957: PUSH
25958: FOR_TO
25959: IFFALSE 26321
// begin InitHc ;
25961: CALL_OW 19
// if not f then
25965: LD_VAR 0 12
25969: NOT
25970: IFFALSE 26059
// begin PrepareHuman ( false , i , skill ) ;
25972: LD_INT 0
25974: PPUSH
25975: LD_VAR 0 8
25979: PPUSH
25980: LD_VAR 0 4
25984: PPUSH
25985: CALL_OW 380
// un := CreateHuman ;
25989: LD_ADDR_VAR 0 14
25993: PUSH
25994: CALL_OW 44
25998: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25999: LD_ADDR_VAR 0 7
26003: PUSH
26004: LD_VAR 0 7
26008: PPUSH
26009: LD_INT 1
26011: PPUSH
26012: LD_VAR 0 14
26016: PPUSH
26017: CALL_OW 2
26021: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26022: LD_VAR 0 14
26026: PPUSH
26027: LD_VAR 0 1
26031: PPUSH
26032: CALL_OW 250
26036: PPUSH
26037: LD_VAR 0 1
26041: PPUSH
26042: CALL_OW 251
26046: PPUSH
26047: LD_INT 10
26049: PPUSH
26050: LD_INT 0
26052: PPUSH
26053: CALL_OW 50
// continue ;
26057: GO 25958
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
26059: LD_VAR 0 12
26063: PUSH
26064: LD_INT 1
26066: ARRAY
26067: PPUSH
26068: CALL_OW 313
26072: PUSH
26073: LD_VAR 0 12
26077: PUSH
26078: LD_INT 1
26080: ARRAY
26081: PPUSH
26082: CALL_OW 266
26086: PUSH
26087: LD_INT 32
26089: PUSH
26090: LD_INT 31
26092: PUSH
26093: EMPTY
26094: LIST
26095: LIST
26096: IN
26097: AND
26098: PUSH
26099: LD_VAR 0 12
26103: PUSH
26104: LD_INT 1
26106: ARRAY
26107: PPUSH
26108: CALL_OW 313
26112: PUSH
26113: LD_INT 6
26115: EQUAL
26116: OR
26117: IFFALSE 26137
// f := Delete ( f , 1 ) ;
26119: LD_ADDR_VAR 0 12
26123: PUSH
26124: LD_VAR 0 12
26128: PPUSH
26129: LD_INT 1
26131: PPUSH
26132: CALL_OW 3
26136: ST_TO_ADDR
// if not f then
26137: LD_VAR 0 12
26141: NOT
26142: IFFALSE 26160
// begin x := x + 2 ;
26144: LD_ADDR_VAR 0 13
26148: PUSH
26149: LD_VAR 0 13
26153: PUSH
26154: LD_INT 2
26156: PLUS
26157: ST_TO_ADDR
// continue ;
26158: GO 25958
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
26160: LD_VAR 0 12
26164: PUSH
26165: LD_INT 1
26167: ARRAY
26168: PPUSH
26169: CALL_OW 266
26173: PUSH
26174: LD_INT 5
26176: EQUAL
26177: IFFALSE 26251
// begin if UnitsInside ( f [ 1 ] ) < 3 then
26179: LD_VAR 0 12
26183: PUSH
26184: LD_INT 1
26186: ARRAY
26187: PPUSH
26188: CALL_OW 313
26192: PUSH
26193: LD_INT 3
26195: LESS
26196: IFFALSE 26232
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26198: LD_INT 0
26200: PPUSH
26201: LD_INT 5
26203: PUSH
26204: LD_INT 8
26206: PUSH
26207: LD_INT 9
26209: PUSH
26210: EMPTY
26211: LIST
26212: LIST
26213: LIST
26214: PUSH
26215: LD_VAR 0 17
26219: ARRAY
26220: PPUSH
26221: LD_VAR 0 4
26225: PPUSH
26226: CALL_OW 380
26230: GO 26249
// PrepareHuman ( false , i , skill ) ;
26232: LD_INT 0
26234: PPUSH
26235: LD_VAR 0 8
26239: PPUSH
26240: LD_VAR 0 4
26244: PPUSH
26245: CALL_OW 380
// end else
26249: GO 26268
// PrepareHuman ( false , i , skill ) ;
26251: LD_INT 0
26253: PPUSH
26254: LD_VAR 0 8
26258: PPUSH
26259: LD_VAR 0 4
26263: PPUSH
26264: CALL_OW 380
// un := CreateHuman ;
26268: LD_ADDR_VAR 0 14
26272: PUSH
26273: CALL_OW 44
26277: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26278: LD_ADDR_VAR 0 7
26282: PUSH
26283: LD_VAR 0 7
26287: PPUSH
26288: LD_INT 1
26290: PPUSH
26291: LD_VAR 0 14
26295: PPUSH
26296: CALL_OW 2
26300: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
26301: LD_VAR 0 14
26305: PPUSH
26306: LD_VAR 0 12
26310: PUSH
26311: LD_INT 1
26313: ARRAY
26314: PPUSH
26315: CALL_OW 52
// end ;
26319: GO 25958
26321: POP
26322: POP
// end ;
26323: GO 25260
26325: POP
26326: POP
// result := result ^ buildings ;
26327: LD_ADDR_VAR 0 7
26331: PUSH
26332: LD_VAR 0 7
26336: PUSH
26337: LD_VAR 0 18
26341: ADD
26342: ST_TO_ADDR
// end else
26343: GO 26486
// begin for i = 1 to personel do
26345: LD_ADDR_VAR 0 8
26349: PUSH
26350: DOUBLE
26351: LD_INT 1
26353: DEC
26354: ST_TO_ADDR
26355: LD_VAR 0 6
26359: PUSH
26360: FOR_TO
26361: IFFALSE 26484
// begin if i > 4 then
26363: LD_VAR 0 8
26367: PUSH
26368: LD_INT 4
26370: GREATER
26371: IFFALSE 26375
// break ;
26373: GO 26484
// x := personel [ i ] ;
26375: LD_ADDR_VAR 0 13
26379: PUSH
26380: LD_VAR 0 6
26384: PUSH
26385: LD_VAR 0 8
26389: ARRAY
26390: ST_TO_ADDR
// if x = - 1 then
26391: LD_VAR 0 13
26395: PUSH
26396: LD_INT 1
26398: NEG
26399: EQUAL
26400: IFFALSE 26404
// continue ;
26402: GO 26360
// PrepareHuman ( false , i , skill ) ;
26404: LD_INT 0
26406: PPUSH
26407: LD_VAR 0 8
26411: PPUSH
26412: LD_VAR 0 4
26416: PPUSH
26417: CALL_OW 380
// un := CreateHuman ;
26421: LD_ADDR_VAR 0 14
26425: PUSH
26426: CALL_OW 44
26430: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26431: LD_VAR 0 14
26435: PPUSH
26436: LD_VAR 0 1
26440: PPUSH
26441: CALL_OW 250
26445: PPUSH
26446: LD_VAR 0 1
26450: PPUSH
26451: CALL_OW 251
26455: PPUSH
26456: LD_INT 10
26458: PPUSH
26459: LD_INT 0
26461: PPUSH
26462: CALL_OW 50
// result := result ^ un ;
26466: LD_ADDR_VAR 0 7
26470: PUSH
26471: LD_VAR 0 7
26475: PUSH
26476: LD_VAR 0 14
26480: ADD
26481: ST_TO_ADDR
// end ;
26482: GO 26360
26484: POP
26485: POP
// end ; end ;
26486: LD_VAR 0 7
26490: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26491: LD_INT 0
26493: PPUSH
26494: PPUSH
26495: PPUSH
26496: PPUSH
26497: PPUSH
26498: PPUSH
26499: PPUSH
26500: PPUSH
26501: PPUSH
26502: PPUSH
26503: PPUSH
26504: PPUSH
26505: PPUSH
26506: PPUSH
26507: PPUSH
26508: PPUSH
// result := false ;
26509: LD_ADDR_VAR 0 3
26513: PUSH
26514: LD_INT 0
26516: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26517: LD_VAR 0 1
26521: NOT
26522: PUSH
26523: LD_VAR 0 1
26527: PPUSH
26528: CALL_OW 266
26532: PUSH
26533: LD_INT 32
26535: PUSH
26536: LD_INT 33
26538: PUSH
26539: EMPTY
26540: LIST
26541: LIST
26542: IN
26543: NOT
26544: OR
26545: IFFALSE 26549
// exit ;
26547: GO 27685
// nat := GetNation ( tower ) ;
26549: LD_ADDR_VAR 0 12
26553: PUSH
26554: LD_VAR 0 1
26558: PPUSH
26559: CALL_OW 248
26563: ST_TO_ADDR
// side := GetSide ( tower ) ;
26564: LD_ADDR_VAR 0 16
26568: PUSH
26569: LD_VAR 0 1
26573: PPUSH
26574: CALL_OW 255
26578: ST_TO_ADDR
// x := GetX ( tower ) ;
26579: LD_ADDR_VAR 0 10
26583: PUSH
26584: LD_VAR 0 1
26588: PPUSH
26589: CALL_OW 250
26593: ST_TO_ADDR
// y := GetY ( tower ) ;
26594: LD_ADDR_VAR 0 11
26598: PUSH
26599: LD_VAR 0 1
26603: PPUSH
26604: CALL_OW 251
26608: ST_TO_ADDR
// if not x or not y then
26609: LD_VAR 0 10
26613: NOT
26614: PUSH
26615: LD_VAR 0 11
26619: NOT
26620: OR
26621: IFFALSE 26625
// exit ;
26623: GO 27685
// weapon := 0 ;
26625: LD_ADDR_VAR 0 18
26629: PUSH
26630: LD_INT 0
26632: ST_TO_ADDR
// fac_list := [ ] ;
26633: LD_ADDR_VAR 0 17
26637: PUSH
26638: EMPTY
26639: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
26640: LD_ADDR_VAR 0 6
26644: PUSH
26645: LD_VAR 0 1
26649: PPUSH
26650: CALL_OW 274
26654: PPUSH
26655: LD_VAR 0 2
26659: PPUSH
26660: CALL 24263 0 2
26664: PPUSH
26665: LD_INT 30
26667: PUSH
26668: LD_INT 3
26670: PUSH
26671: EMPTY
26672: LIST
26673: LIST
26674: PPUSH
26675: CALL_OW 72
26679: ST_TO_ADDR
// if not factories then
26680: LD_VAR 0 6
26684: NOT
26685: IFFALSE 26689
// exit ;
26687: GO 27685
// for i in factories do
26689: LD_ADDR_VAR 0 8
26693: PUSH
26694: LD_VAR 0 6
26698: PUSH
26699: FOR_IN
26700: IFFALSE 26725
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26702: LD_ADDR_VAR 0 17
26706: PUSH
26707: LD_VAR 0 17
26711: PUSH
26712: LD_VAR 0 8
26716: PPUSH
26717: CALL_OW 478
26721: UNION
26722: ST_TO_ADDR
26723: GO 26699
26725: POP
26726: POP
// if not fac_list then
26727: LD_VAR 0 17
26731: NOT
26732: IFFALSE 26736
// exit ;
26734: GO 27685
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
26736: LD_ADDR_VAR 0 5
26740: PUSH
26741: LD_INT 4
26743: PUSH
26744: LD_INT 5
26746: PUSH
26747: LD_INT 9
26749: PUSH
26750: LD_INT 10
26752: PUSH
26753: LD_INT 6
26755: PUSH
26756: LD_INT 7
26758: PUSH
26759: LD_INT 11
26761: PUSH
26762: EMPTY
26763: LIST
26764: LIST
26765: LIST
26766: LIST
26767: LIST
26768: LIST
26769: LIST
26770: PUSH
26771: LD_INT 27
26773: PUSH
26774: LD_INT 28
26776: PUSH
26777: LD_INT 26
26779: PUSH
26780: LD_INT 30
26782: PUSH
26783: EMPTY
26784: LIST
26785: LIST
26786: LIST
26787: LIST
26788: PUSH
26789: LD_INT 43
26791: PUSH
26792: LD_INT 44
26794: PUSH
26795: LD_INT 46
26797: PUSH
26798: LD_INT 45
26800: PUSH
26801: LD_INT 47
26803: PUSH
26804: LD_INT 49
26806: PUSH
26807: EMPTY
26808: LIST
26809: LIST
26810: LIST
26811: LIST
26812: LIST
26813: LIST
26814: PUSH
26815: EMPTY
26816: LIST
26817: LIST
26818: LIST
26819: PUSH
26820: LD_VAR 0 12
26824: ARRAY
26825: ST_TO_ADDR
// for i in list do
26826: LD_ADDR_VAR 0 8
26830: PUSH
26831: LD_VAR 0 5
26835: PUSH
26836: FOR_IN
26837: IFFALSE 26870
// if not i in fac_list then
26839: LD_VAR 0 8
26843: PUSH
26844: LD_VAR 0 17
26848: IN
26849: NOT
26850: IFFALSE 26868
// list := list diff i ;
26852: LD_ADDR_VAR 0 5
26856: PUSH
26857: LD_VAR 0 5
26861: PUSH
26862: LD_VAR 0 8
26866: DIFF
26867: ST_TO_ADDR
26868: GO 26836
26870: POP
26871: POP
// if not list then
26872: LD_VAR 0 5
26876: NOT
26877: IFFALSE 26881
// exit ;
26879: GO 27685
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26881: LD_VAR 0 12
26885: PUSH
26886: LD_INT 3
26888: EQUAL
26889: PUSH
26890: LD_INT 49
26892: PUSH
26893: LD_VAR 0 5
26897: IN
26898: AND
26899: PUSH
26900: LD_INT 31
26902: PPUSH
26903: LD_VAR 0 16
26907: PPUSH
26908: CALL_OW 321
26912: PUSH
26913: LD_INT 2
26915: EQUAL
26916: AND
26917: IFFALSE 26977
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26919: LD_INT 22
26921: PUSH
26922: LD_VAR 0 16
26926: PUSH
26927: EMPTY
26928: LIST
26929: LIST
26930: PUSH
26931: LD_INT 35
26933: PUSH
26934: LD_INT 49
26936: PUSH
26937: EMPTY
26938: LIST
26939: LIST
26940: PUSH
26941: LD_INT 91
26943: PUSH
26944: LD_VAR 0 1
26948: PUSH
26949: LD_INT 10
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: LIST
26956: PUSH
26957: EMPTY
26958: LIST
26959: LIST
26960: LIST
26961: PPUSH
26962: CALL_OW 69
26966: NOT
26967: IFFALSE 26977
// weapon := ru_time_lapser ;
26969: LD_ADDR_VAR 0 18
26973: PUSH
26974: LD_INT 49
26976: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26977: LD_VAR 0 12
26981: PUSH
26982: LD_INT 1
26984: PUSH
26985: LD_INT 2
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: IN
26992: PUSH
26993: LD_INT 11
26995: PUSH
26996: LD_VAR 0 5
27000: IN
27001: PUSH
27002: LD_INT 30
27004: PUSH
27005: LD_VAR 0 5
27009: IN
27010: OR
27011: AND
27012: PUSH
27013: LD_INT 6
27015: PPUSH
27016: LD_VAR 0 16
27020: PPUSH
27021: CALL_OW 321
27025: PUSH
27026: LD_INT 2
27028: EQUAL
27029: AND
27030: IFFALSE 27195
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
27032: LD_INT 22
27034: PUSH
27035: LD_VAR 0 16
27039: PUSH
27040: EMPTY
27041: LIST
27042: LIST
27043: PUSH
27044: LD_INT 2
27046: PUSH
27047: LD_INT 35
27049: PUSH
27050: LD_INT 11
27052: PUSH
27053: EMPTY
27054: LIST
27055: LIST
27056: PUSH
27057: LD_INT 35
27059: PUSH
27060: LD_INT 30
27062: PUSH
27063: EMPTY
27064: LIST
27065: LIST
27066: PUSH
27067: EMPTY
27068: LIST
27069: LIST
27070: LIST
27071: PUSH
27072: LD_INT 91
27074: PUSH
27075: LD_VAR 0 1
27079: PUSH
27080: LD_INT 18
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: LIST
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: LIST
27092: PPUSH
27093: CALL_OW 69
27097: NOT
27098: PUSH
27099: LD_INT 22
27101: PUSH
27102: LD_VAR 0 16
27106: PUSH
27107: EMPTY
27108: LIST
27109: LIST
27110: PUSH
27111: LD_INT 2
27113: PUSH
27114: LD_INT 30
27116: PUSH
27117: LD_INT 32
27119: PUSH
27120: EMPTY
27121: LIST
27122: LIST
27123: PUSH
27124: LD_INT 30
27126: PUSH
27127: LD_INT 33
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: PUSH
27134: EMPTY
27135: LIST
27136: LIST
27137: LIST
27138: PUSH
27139: LD_INT 91
27141: PUSH
27142: LD_VAR 0 1
27146: PUSH
27147: LD_INT 12
27149: PUSH
27150: EMPTY
27151: LIST
27152: LIST
27153: LIST
27154: PUSH
27155: EMPTY
27156: LIST
27157: LIST
27158: LIST
27159: PUSH
27160: EMPTY
27161: LIST
27162: PPUSH
27163: CALL_OW 69
27167: PUSH
27168: LD_INT 2
27170: GREATER
27171: AND
27172: IFFALSE 27195
// weapon := [ us_radar , ar_radar ] [ nat ] ;
27174: LD_ADDR_VAR 0 18
27178: PUSH
27179: LD_INT 11
27181: PUSH
27182: LD_INT 30
27184: PUSH
27185: EMPTY
27186: LIST
27187: LIST
27188: PUSH
27189: LD_VAR 0 12
27193: ARRAY
27194: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
27195: LD_VAR 0 18
27199: NOT
27200: PUSH
27201: LD_INT 40
27203: PPUSH
27204: LD_VAR 0 16
27208: PPUSH
27209: CALL_OW 321
27213: PUSH
27214: LD_INT 2
27216: EQUAL
27217: AND
27218: PUSH
27219: LD_INT 7
27221: PUSH
27222: LD_VAR 0 5
27226: IN
27227: PUSH
27228: LD_INT 28
27230: PUSH
27231: LD_VAR 0 5
27235: IN
27236: OR
27237: PUSH
27238: LD_INT 45
27240: PUSH
27241: LD_VAR 0 5
27245: IN
27246: OR
27247: AND
27248: IFFALSE 27502
// begin hex := GetHexInfo ( x , y ) ;
27250: LD_ADDR_VAR 0 4
27254: PUSH
27255: LD_VAR 0 10
27259: PPUSH
27260: LD_VAR 0 11
27264: PPUSH
27265: CALL_OW 546
27269: ST_TO_ADDR
// if hex [ 1 ] then
27270: LD_VAR 0 4
27274: PUSH
27275: LD_INT 1
27277: ARRAY
27278: IFFALSE 27282
// exit ;
27280: GO 27685
// height := hex [ 2 ] ;
27282: LD_ADDR_VAR 0 15
27286: PUSH
27287: LD_VAR 0 4
27291: PUSH
27292: LD_INT 2
27294: ARRAY
27295: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
27296: LD_ADDR_VAR 0 14
27300: PUSH
27301: LD_INT 0
27303: PUSH
27304: LD_INT 2
27306: PUSH
27307: LD_INT 3
27309: PUSH
27310: LD_INT 5
27312: PUSH
27313: EMPTY
27314: LIST
27315: LIST
27316: LIST
27317: LIST
27318: ST_TO_ADDR
// for i in tmp do
27319: LD_ADDR_VAR 0 8
27323: PUSH
27324: LD_VAR 0 14
27328: PUSH
27329: FOR_IN
27330: IFFALSE 27500
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
27332: LD_ADDR_VAR 0 9
27336: PUSH
27337: LD_VAR 0 10
27341: PPUSH
27342: LD_VAR 0 8
27346: PPUSH
27347: LD_INT 5
27349: PPUSH
27350: CALL_OW 272
27354: PUSH
27355: LD_VAR 0 11
27359: PPUSH
27360: LD_VAR 0 8
27364: PPUSH
27365: LD_INT 5
27367: PPUSH
27368: CALL_OW 273
27372: PUSH
27373: EMPTY
27374: LIST
27375: LIST
27376: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27377: LD_VAR 0 9
27381: PUSH
27382: LD_INT 1
27384: ARRAY
27385: PPUSH
27386: LD_VAR 0 9
27390: PUSH
27391: LD_INT 2
27393: ARRAY
27394: PPUSH
27395: CALL_OW 488
27399: IFFALSE 27498
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27401: LD_ADDR_VAR 0 4
27405: PUSH
27406: LD_VAR 0 9
27410: PUSH
27411: LD_INT 1
27413: ARRAY
27414: PPUSH
27415: LD_VAR 0 9
27419: PUSH
27420: LD_INT 2
27422: ARRAY
27423: PPUSH
27424: CALL_OW 546
27428: ST_TO_ADDR
// if hex [ 1 ] then
27429: LD_VAR 0 4
27433: PUSH
27434: LD_INT 1
27436: ARRAY
27437: IFFALSE 27441
// continue ;
27439: GO 27329
// h := hex [ 2 ] ;
27441: LD_ADDR_VAR 0 13
27445: PUSH
27446: LD_VAR 0 4
27450: PUSH
27451: LD_INT 2
27453: ARRAY
27454: ST_TO_ADDR
// if h + 7 < height then
27455: LD_VAR 0 13
27459: PUSH
27460: LD_INT 7
27462: PLUS
27463: PUSH
27464: LD_VAR 0 15
27468: LESS
27469: IFFALSE 27498
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27471: LD_ADDR_VAR 0 18
27475: PUSH
27476: LD_INT 7
27478: PUSH
27479: LD_INT 28
27481: PUSH
27482: LD_INT 45
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: LIST
27489: PUSH
27490: LD_VAR 0 12
27494: ARRAY
27495: ST_TO_ADDR
// break ;
27496: GO 27500
// end ; end ; end ;
27498: GO 27329
27500: POP
27501: POP
// end ; if not weapon then
27502: LD_VAR 0 18
27506: NOT
27507: IFFALSE 27567
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27509: LD_ADDR_VAR 0 5
27513: PUSH
27514: LD_VAR 0 5
27518: PUSH
27519: LD_INT 11
27521: PUSH
27522: LD_INT 30
27524: PUSH
27525: LD_INT 49
27527: PUSH
27528: EMPTY
27529: LIST
27530: LIST
27531: LIST
27532: DIFF
27533: ST_TO_ADDR
// if not list then
27534: LD_VAR 0 5
27538: NOT
27539: IFFALSE 27543
// exit ;
27541: GO 27685
// weapon := list [ rand ( 1 , list ) ] ;
27543: LD_ADDR_VAR 0 18
27547: PUSH
27548: LD_VAR 0 5
27552: PUSH
27553: LD_INT 1
27555: PPUSH
27556: LD_VAR 0 5
27560: PPUSH
27561: CALL_OW 12
27565: ARRAY
27566: ST_TO_ADDR
// end ; if weapon then
27567: LD_VAR 0 18
27571: IFFALSE 27685
// begin tmp := CostOfWeapon ( weapon ) ;
27573: LD_ADDR_VAR 0 14
27577: PUSH
27578: LD_VAR 0 18
27582: PPUSH
27583: CALL_OW 451
27587: ST_TO_ADDR
// j := GetBase ( tower ) ;
27588: LD_ADDR_VAR 0 9
27592: PUSH
27593: LD_VAR 0 1
27597: PPUSH
27598: CALL_OW 274
27602: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27603: LD_VAR 0 9
27607: PPUSH
27608: LD_INT 1
27610: PPUSH
27611: CALL_OW 275
27615: PUSH
27616: LD_VAR 0 14
27620: PUSH
27621: LD_INT 1
27623: ARRAY
27624: GREATEREQUAL
27625: PUSH
27626: LD_VAR 0 9
27630: PPUSH
27631: LD_INT 2
27633: PPUSH
27634: CALL_OW 275
27638: PUSH
27639: LD_VAR 0 14
27643: PUSH
27644: LD_INT 2
27646: ARRAY
27647: GREATEREQUAL
27648: AND
27649: PUSH
27650: LD_VAR 0 9
27654: PPUSH
27655: LD_INT 3
27657: PPUSH
27658: CALL_OW 275
27662: PUSH
27663: LD_VAR 0 14
27667: PUSH
27668: LD_INT 3
27670: ARRAY
27671: GREATEREQUAL
27672: AND
27673: IFFALSE 27685
// result := weapon ;
27675: LD_ADDR_VAR 0 3
27679: PUSH
27680: LD_VAR 0 18
27684: ST_TO_ADDR
// end ; end ;
27685: LD_VAR 0 3
27689: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27690: LD_INT 0
27692: PPUSH
27693: PPUSH
// result := true ;
27694: LD_ADDR_VAR 0 3
27698: PUSH
27699: LD_INT 1
27701: ST_TO_ADDR
// if array1 = array2 then
27702: LD_VAR 0 1
27706: PUSH
27707: LD_VAR 0 2
27711: EQUAL
27712: IFFALSE 27772
// begin for i = 1 to array1 do
27714: LD_ADDR_VAR 0 4
27718: PUSH
27719: DOUBLE
27720: LD_INT 1
27722: DEC
27723: ST_TO_ADDR
27724: LD_VAR 0 1
27728: PUSH
27729: FOR_TO
27730: IFFALSE 27768
// if array1 [ i ] <> array2 [ i ] then
27732: LD_VAR 0 1
27736: PUSH
27737: LD_VAR 0 4
27741: ARRAY
27742: PUSH
27743: LD_VAR 0 2
27747: PUSH
27748: LD_VAR 0 4
27752: ARRAY
27753: NONEQUAL
27754: IFFALSE 27766
// begin result := false ;
27756: LD_ADDR_VAR 0 3
27760: PUSH
27761: LD_INT 0
27763: ST_TO_ADDR
// break ;
27764: GO 27768
// end ;
27766: GO 27729
27768: POP
27769: POP
// end else
27770: GO 27780
// result := false ;
27772: LD_ADDR_VAR 0 3
27776: PUSH
27777: LD_INT 0
27779: ST_TO_ADDR
// end ;
27780: LD_VAR 0 3
27784: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
27785: LD_INT 0
27787: PPUSH
27788: PPUSH
27789: PPUSH
// pom := GetBase ( fac ) ;
27790: LD_ADDR_VAR 0 5
27794: PUSH
27795: LD_VAR 0 1
27799: PPUSH
27800: CALL_OW 274
27804: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
27805: LD_ADDR_VAR 0 4
27809: PUSH
27810: LD_VAR 0 2
27814: PUSH
27815: LD_INT 1
27817: ARRAY
27818: PPUSH
27819: LD_VAR 0 2
27823: PUSH
27824: LD_INT 2
27826: ARRAY
27827: PPUSH
27828: LD_VAR 0 2
27832: PUSH
27833: LD_INT 3
27835: ARRAY
27836: PPUSH
27837: LD_VAR 0 2
27841: PUSH
27842: LD_INT 4
27844: ARRAY
27845: PPUSH
27846: CALL_OW 449
27850: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27851: LD_ADDR_VAR 0 3
27855: PUSH
27856: LD_VAR 0 5
27860: PPUSH
27861: LD_INT 1
27863: PPUSH
27864: CALL_OW 275
27868: PUSH
27869: LD_VAR 0 4
27873: PUSH
27874: LD_INT 1
27876: ARRAY
27877: GREATEREQUAL
27878: PUSH
27879: LD_VAR 0 5
27883: PPUSH
27884: LD_INT 2
27886: PPUSH
27887: CALL_OW 275
27891: PUSH
27892: LD_VAR 0 4
27896: PUSH
27897: LD_INT 2
27899: ARRAY
27900: GREATEREQUAL
27901: AND
27902: PUSH
27903: LD_VAR 0 5
27907: PPUSH
27908: LD_INT 3
27910: PPUSH
27911: CALL_OW 275
27915: PUSH
27916: LD_VAR 0 4
27920: PUSH
27921: LD_INT 3
27923: ARRAY
27924: GREATEREQUAL
27925: AND
27926: ST_TO_ADDR
// end ;
27927: LD_VAR 0 3
27931: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27932: LD_INT 0
27934: PPUSH
27935: PPUSH
27936: PPUSH
27937: PPUSH
// pom := GetBase ( building ) ;
27938: LD_ADDR_VAR 0 3
27942: PUSH
27943: LD_VAR 0 1
27947: PPUSH
27948: CALL_OW 274
27952: ST_TO_ADDR
// if not pom then
27953: LD_VAR 0 3
27957: NOT
27958: IFFALSE 27962
// exit ;
27960: GO 28132
// btype := GetBType ( building ) ;
27962: LD_ADDR_VAR 0 5
27966: PUSH
27967: LD_VAR 0 1
27971: PPUSH
27972: CALL_OW 266
27976: ST_TO_ADDR
// if btype = b_armoury then
27977: LD_VAR 0 5
27981: PUSH
27982: LD_INT 4
27984: EQUAL
27985: IFFALSE 27995
// btype := b_barracks ;
27987: LD_ADDR_VAR 0 5
27991: PUSH
27992: LD_INT 5
27994: ST_TO_ADDR
// if btype = b_depot then
27995: LD_VAR 0 5
27999: PUSH
28000: LD_INT 0
28002: EQUAL
28003: IFFALSE 28013
// btype := b_warehouse ;
28005: LD_ADDR_VAR 0 5
28009: PUSH
28010: LD_INT 1
28012: ST_TO_ADDR
// if btype = b_workshop then
28013: LD_VAR 0 5
28017: PUSH
28018: LD_INT 2
28020: EQUAL
28021: IFFALSE 28031
// btype := b_factory ;
28023: LD_ADDR_VAR 0 5
28027: PUSH
28028: LD_INT 3
28030: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28031: LD_ADDR_VAR 0 4
28035: PUSH
28036: LD_VAR 0 5
28040: PPUSH
28041: LD_VAR 0 1
28045: PPUSH
28046: CALL_OW 248
28050: PPUSH
28051: CALL_OW 450
28055: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28056: LD_ADDR_VAR 0 2
28060: PUSH
28061: LD_VAR 0 3
28065: PPUSH
28066: LD_INT 1
28068: PPUSH
28069: CALL_OW 275
28073: PUSH
28074: LD_VAR 0 4
28078: PUSH
28079: LD_INT 1
28081: ARRAY
28082: GREATEREQUAL
28083: PUSH
28084: LD_VAR 0 3
28088: PPUSH
28089: LD_INT 2
28091: PPUSH
28092: CALL_OW 275
28096: PUSH
28097: LD_VAR 0 4
28101: PUSH
28102: LD_INT 2
28104: ARRAY
28105: GREATEREQUAL
28106: AND
28107: PUSH
28108: LD_VAR 0 3
28112: PPUSH
28113: LD_INT 3
28115: PPUSH
28116: CALL_OW 275
28120: PUSH
28121: LD_VAR 0 4
28125: PUSH
28126: LD_INT 3
28128: ARRAY
28129: GREATEREQUAL
28130: AND
28131: ST_TO_ADDR
// end ;
28132: LD_VAR 0 2
28136: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
28137: LD_INT 0
28139: PPUSH
28140: PPUSH
28141: PPUSH
// pom := GetBase ( building ) ;
28142: LD_ADDR_VAR 0 4
28146: PUSH
28147: LD_VAR 0 1
28151: PPUSH
28152: CALL_OW 274
28156: ST_TO_ADDR
// if not pom then
28157: LD_VAR 0 4
28161: NOT
28162: IFFALSE 28166
// exit ;
28164: GO 28267
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28166: LD_ADDR_VAR 0 5
28170: PUSH
28171: LD_VAR 0 2
28175: PPUSH
28176: LD_VAR 0 1
28180: PPUSH
28181: CALL_OW 248
28185: PPUSH
28186: CALL_OW 450
28190: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28191: LD_ADDR_VAR 0 3
28195: PUSH
28196: LD_VAR 0 4
28200: PPUSH
28201: LD_INT 1
28203: PPUSH
28204: CALL_OW 275
28208: PUSH
28209: LD_VAR 0 5
28213: PUSH
28214: LD_INT 1
28216: ARRAY
28217: GREATEREQUAL
28218: PUSH
28219: LD_VAR 0 4
28223: PPUSH
28224: LD_INT 2
28226: PPUSH
28227: CALL_OW 275
28231: PUSH
28232: LD_VAR 0 5
28236: PUSH
28237: LD_INT 2
28239: ARRAY
28240: GREATEREQUAL
28241: AND
28242: PUSH
28243: LD_VAR 0 4
28247: PPUSH
28248: LD_INT 3
28250: PPUSH
28251: CALL_OW 275
28255: PUSH
28256: LD_VAR 0 5
28260: PUSH
28261: LD_INT 3
28263: ARRAY
28264: GREATEREQUAL
28265: AND
28266: ST_TO_ADDR
// end ;
28267: LD_VAR 0 3
28271: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
28272: LD_INT 0
28274: PPUSH
28275: PPUSH
28276: PPUSH
28277: PPUSH
28278: PPUSH
28279: PPUSH
28280: PPUSH
28281: PPUSH
28282: PPUSH
28283: PPUSH
// result := false ;
28284: LD_ADDR_VAR 0 6
28288: PUSH
28289: LD_INT 0
28291: ST_TO_ADDR
// if not base or not btype or not x or not y then
28292: LD_VAR 0 1
28296: NOT
28297: PUSH
28298: LD_VAR 0 2
28302: NOT
28303: OR
28304: PUSH
28305: LD_VAR 0 3
28309: NOT
28310: OR
28311: PUSH
28312: LD_VAR 0 4
28316: NOT
28317: OR
28318: IFFALSE 28322
// exit ;
28320: GO 28931
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
28322: LD_ADDR_VAR 0 12
28326: PUSH
28327: LD_VAR 0 2
28331: PPUSH
28332: LD_VAR 0 3
28336: PPUSH
28337: LD_VAR 0 4
28341: PPUSH
28342: LD_VAR 0 5
28346: PPUSH
28347: LD_VAR 0 1
28351: PUSH
28352: LD_INT 1
28354: ARRAY
28355: PPUSH
28356: CALL_OW 248
28360: PPUSH
28361: LD_INT 0
28363: PPUSH
28364: CALL 29768 0 6
28368: ST_TO_ADDR
// if not hexes then
28369: LD_VAR 0 12
28373: NOT
28374: IFFALSE 28378
// exit ;
28376: GO 28931
// for i = 1 to hexes do
28378: LD_ADDR_VAR 0 7
28382: PUSH
28383: DOUBLE
28384: LD_INT 1
28386: DEC
28387: ST_TO_ADDR
28388: LD_VAR 0 12
28392: PUSH
28393: FOR_TO
28394: IFFALSE 28929
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28396: LD_ADDR_VAR 0 11
28400: PUSH
28401: LD_VAR 0 12
28405: PUSH
28406: LD_VAR 0 7
28410: ARRAY
28411: PUSH
28412: LD_INT 1
28414: ARRAY
28415: PPUSH
28416: LD_VAR 0 12
28420: PUSH
28421: LD_VAR 0 7
28425: ARRAY
28426: PUSH
28427: LD_INT 2
28429: ARRAY
28430: PPUSH
28431: CALL_OW 428
28435: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28436: LD_VAR 0 12
28440: PUSH
28441: LD_VAR 0 7
28445: ARRAY
28446: PUSH
28447: LD_INT 1
28449: ARRAY
28450: PPUSH
28451: LD_VAR 0 12
28455: PUSH
28456: LD_VAR 0 7
28460: ARRAY
28461: PUSH
28462: LD_INT 2
28464: ARRAY
28465: PPUSH
28466: CALL_OW 351
28470: PUSH
28471: LD_VAR 0 12
28475: PUSH
28476: LD_VAR 0 7
28480: ARRAY
28481: PUSH
28482: LD_INT 1
28484: ARRAY
28485: PPUSH
28486: LD_VAR 0 12
28490: PUSH
28491: LD_VAR 0 7
28495: ARRAY
28496: PUSH
28497: LD_INT 2
28499: ARRAY
28500: PPUSH
28501: CALL_OW 488
28505: NOT
28506: OR
28507: PUSH
28508: LD_VAR 0 11
28512: PPUSH
28513: CALL_OW 247
28517: PUSH
28518: LD_INT 3
28520: EQUAL
28521: OR
28522: IFFALSE 28528
// exit ;
28524: POP
28525: POP
28526: GO 28931
// if not tmp or not tmp in base then
28528: LD_VAR 0 11
28532: NOT
28533: PUSH
28534: LD_VAR 0 11
28538: PUSH
28539: LD_VAR 0 1
28543: IN
28544: NOT
28545: OR
28546: IFFALSE 28550
// continue ;
28548: GO 28393
// result := true ;
28550: LD_ADDR_VAR 0 6
28554: PUSH
28555: LD_INT 1
28557: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28558: LD_ADDR_VAR 0 15
28562: PUSH
28563: LD_VAR 0 1
28567: PPUSH
28568: LD_INT 22
28570: PUSH
28571: LD_VAR 0 11
28575: PPUSH
28576: CALL_OW 255
28580: PUSH
28581: EMPTY
28582: LIST
28583: LIST
28584: PUSH
28585: LD_INT 2
28587: PUSH
28588: LD_INT 30
28590: PUSH
28591: LD_INT 0
28593: PUSH
28594: EMPTY
28595: LIST
28596: LIST
28597: PUSH
28598: LD_INT 30
28600: PUSH
28601: LD_INT 1
28603: PUSH
28604: EMPTY
28605: LIST
28606: LIST
28607: PUSH
28608: EMPTY
28609: LIST
28610: LIST
28611: LIST
28612: PUSH
28613: EMPTY
28614: LIST
28615: LIST
28616: PPUSH
28617: CALL_OW 72
28621: ST_TO_ADDR
// if dep then
28622: LD_VAR 0 15
28626: IFFALSE 28762
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
28628: LD_ADDR_VAR 0 14
28632: PUSH
28633: LD_VAR 0 15
28637: PUSH
28638: LD_INT 1
28640: ARRAY
28641: PPUSH
28642: CALL_OW 250
28646: PPUSH
28647: LD_VAR 0 15
28651: PUSH
28652: LD_INT 1
28654: ARRAY
28655: PPUSH
28656: CALL_OW 254
28660: PPUSH
28661: LD_INT 5
28663: PPUSH
28664: CALL_OW 272
28668: PUSH
28669: LD_VAR 0 15
28673: PUSH
28674: LD_INT 1
28676: ARRAY
28677: PPUSH
28678: CALL_OW 251
28682: PPUSH
28683: LD_VAR 0 15
28687: PUSH
28688: LD_INT 1
28690: ARRAY
28691: PPUSH
28692: CALL_OW 254
28696: PPUSH
28697: LD_INT 5
28699: PPUSH
28700: CALL_OW 273
28704: PUSH
28705: EMPTY
28706: LIST
28707: LIST
28708: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
28709: LD_VAR 0 14
28713: PUSH
28714: LD_INT 1
28716: ARRAY
28717: PPUSH
28718: LD_VAR 0 14
28722: PUSH
28723: LD_INT 2
28725: ARRAY
28726: PPUSH
28727: CALL_OW 488
28731: IFFALSE 28762
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
28733: LD_VAR 0 11
28737: PPUSH
28738: LD_VAR 0 14
28742: PUSH
28743: LD_INT 1
28745: ARRAY
28746: PPUSH
28747: LD_VAR 0 14
28751: PUSH
28752: LD_INT 2
28754: ARRAY
28755: PPUSH
28756: CALL_OW 111
// continue ;
28760: GO 28393
// end ; end ; r := GetDir ( tmp ) ;
28762: LD_ADDR_VAR 0 13
28766: PUSH
28767: LD_VAR 0 11
28771: PPUSH
28772: CALL_OW 254
28776: ST_TO_ADDR
// if r = 5 then
28777: LD_VAR 0 13
28781: PUSH
28782: LD_INT 5
28784: EQUAL
28785: IFFALSE 28795
// r := 0 ;
28787: LD_ADDR_VAR 0 13
28791: PUSH
28792: LD_INT 0
28794: ST_TO_ADDR
// for j = r to 5 do
28795: LD_ADDR_VAR 0 8
28799: PUSH
28800: DOUBLE
28801: LD_VAR 0 13
28805: DEC
28806: ST_TO_ADDR
28807: LD_INT 5
28809: PUSH
28810: FOR_TO
28811: IFFALSE 28925
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28813: LD_ADDR_VAR 0 9
28817: PUSH
28818: LD_VAR 0 11
28822: PPUSH
28823: CALL_OW 250
28827: PPUSH
28828: LD_VAR 0 8
28832: PPUSH
28833: LD_INT 2
28835: PPUSH
28836: CALL_OW 272
28840: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28841: LD_ADDR_VAR 0 10
28845: PUSH
28846: LD_VAR 0 11
28850: PPUSH
28851: CALL_OW 251
28855: PPUSH
28856: LD_VAR 0 8
28860: PPUSH
28861: LD_INT 2
28863: PPUSH
28864: CALL_OW 273
28868: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28869: LD_VAR 0 9
28873: PPUSH
28874: LD_VAR 0 10
28878: PPUSH
28879: CALL_OW 488
28883: PUSH
28884: LD_VAR 0 9
28888: PPUSH
28889: LD_VAR 0 10
28893: PPUSH
28894: CALL_OW 428
28898: NOT
28899: AND
28900: IFFALSE 28923
// begin ComMoveXY ( tmp , _x , _y ) ;
28902: LD_VAR 0 11
28906: PPUSH
28907: LD_VAR 0 9
28911: PPUSH
28912: LD_VAR 0 10
28916: PPUSH
28917: CALL_OW 111
// break ;
28921: GO 28925
// end ; end ;
28923: GO 28810
28925: POP
28926: POP
// end ;
28927: GO 28393
28929: POP
28930: POP
// end ;
28931: LD_VAR 0 6
28935: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28936: LD_INT 0
28938: PPUSH
28939: PPUSH
28940: PPUSH
28941: PPUSH
28942: PPUSH
28943: PPUSH
28944: PPUSH
28945: PPUSH
28946: PPUSH
28947: PPUSH
// result := false ;
28948: LD_ADDR_VAR 0 6
28952: PUSH
28953: LD_INT 0
28955: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28956: LD_VAR 0 1
28960: NOT
28961: PUSH
28962: LD_VAR 0 1
28966: PPUSH
28967: CALL_OW 266
28971: PUSH
28972: LD_INT 0
28974: PUSH
28975: LD_INT 1
28977: PUSH
28978: EMPTY
28979: LIST
28980: LIST
28981: IN
28982: NOT
28983: OR
28984: PUSH
28985: LD_VAR 0 2
28989: NOT
28990: OR
28991: PUSH
28992: LD_VAR 0 5
28996: PUSH
28997: LD_INT 0
28999: PUSH
29000: LD_INT 1
29002: PUSH
29003: LD_INT 2
29005: PUSH
29006: LD_INT 3
29008: PUSH
29009: LD_INT 4
29011: PUSH
29012: LD_INT 5
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: IN
29023: NOT
29024: OR
29025: PUSH
29026: LD_VAR 0 3
29030: PPUSH
29031: LD_VAR 0 4
29035: PPUSH
29036: CALL_OW 488
29040: NOT
29041: OR
29042: IFFALSE 29046
// exit ;
29044: GO 29763
// pom := GetBase ( depot ) ;
29046: LD_ADDR_VAR 0 10
29050: PUSH
29051: LD_VAR 0 1
29055: PPUSH
29056: CALL_OW 274
29060: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
29061: LD_ADDR_VAR 0 11
29065: PUSH
29066: LD_VAR 0 2
29070: PPUSH
29071: LD_VAR 0 1
29075: PPUSH
29076: CALL_OW 248
29080: PPUSH
29081: CALL_OW 450
29085: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
29086: LD_VAR 0 10
29090: PPUSH
29091: LD_INT 1
29093: PPUSH
29094: CALL_OW 275
29098: PUSH
29099: LD_VAR 0 11
29103: PUSH
29104: LD_INT 1
29106: ARRAY
29107: GREATEREQUAL
29108: PUSH
29109: LD_VAR 0 10
29113: PPUSH
29114: LD_INT 2
29116: PPUSH
29117: CALL_OW 275
29121: PUSH
29122: LD_VAR 0 11
29126: PUSH
29127: LD_INT 2
29129: ARRAY
29130: GREATEREQUAL
29131: AND
29132: PUSH
29133: LD_VAR 0 10
29137: PPUSH
29138: LD_INT 3
29140: PPUSH
29141: CALL_OW 275
29145: PUSH
29146: LD_VAR 0 11
29150: PUSH
29151: LD_INT 3
29153: ARRAY
29154: GREATEREQUAL
29155: AND
29156: NOT
29157: IFFALSE 29161
// exit ;
29159: GO 29763
// if GetBType ( depot ) = b_depot then
29161: LD_VAR 0 1
29165: PPUSH
29166: CALL_OW 266
29170: PUSH
29171: LD_INT 0
29173: EQUAL
29174: IFFALSE 29186
// dist := 28 else
29176: LD_ADDR_VAR 0 14
29180: PUSH
29181: LD_INT 28
29183: ST_TO_ADDR
29184: GO 29194
// dist := 36 ;
29186: LD_ADDR_VAR 0 14
29190: PUSH
29191: LD_INT 36
29193: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
29194: LD_VAR 0 1
29198: PPUSH
29199: LD_VAR 0 3
29203: PPUSH
29204: LD_VAR 0 4
29208: PPUSH
29209: CALL_OW 297
29213: PUSH
29214: LD_VAR 0 14
29218: GREATER
29219: IFFALSE 29223
// exit ;
29221: GO 29763
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
29223: LD_ADDR_VAR 0 12
29227: PUSH
29228: LD_VAR 0 2
29232: PPUSH
29233: LD_VAR 0 3
29237: PPUSH
29238: LD_VAR 0 4
29242: PPUSH
29243: LD_VAR 0 5
29247: PPUSH
29248: LD_VAR 0 1
29252: PPUSH
29253: CALL_OW 248
29257: PPUSH
29258: LD_INT 0
29260: PPUSH
29261: CALL 29768 0 6
29265: ST_TO_ADDR
// if not hexes then
29266: LD_VAR 0 12
29270: NOT
29271: IFFALSE 29275
// exit ;
29273: GO 29763
// hex := GetHexInfo ( x , y ) ;
29275: LD_ADDR_VAR 0 15
29279: PUSH
29280: LD_VAR 0 3
29284: PPUSH
29285: LD_VAR 0 4
29289: PPUSH
29290: CALL_OW 546
29294: ST_TO_ADDR
// if hex [ 1 ] then
29295: LD_VAR 0 15
29299: PUSH
29300: LD_INT 1
29302: ARRAY
29303: IFFALSE 29307
// exit ;
29305: GO 29763
// height := hex [ 2 ] ;
29307: LD_ADDR_VAR 0 13
29311: PUSH
29312: LD_VAR 0 15
29316: PUSH
29317: LD_INT 2
29319: ARRAY
29320: ST_TO_ADDR
// for i = 1 to hexes do
29321: LD_ADDR_VAR 0 7
29325: PUSH
29326: DOUBLE
29327: LD_INT 1
29329: DEC
29330: ST_TO_ADDR
29331: LD_VAR 0 12
29335: PUSH
29336: FOR_TO
29337: IFFALSE 29667
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
29339: LD_VAR 0 12
29343: PUSH
29344: LD_VAR 0 7
29348: ARRAY
29349: PUSH
29350: LD_INT 1
29352: ARRAY
29353: PPUSH
29354: LD_VAR 0 12
29358: PUSH
29359: LD_VAR 0 7
29363: ARRAY
29364: PUSH
29365: LD_INT 2
29367: ARRAY
29368: PPUSH
29369: CALL_OW 488
29373: NOT
29374: PUSH
29375: LD_VAR 0 12
29379: PUSH
29380: LD_VAR 0 7
29384: ARRAY
29385: PUSH
29386: LD_INT 1
29388: ARRAY
29389: PPUSH
29390: LD_VAR 0 12
29394: PUSH
29395: LD_VAR 0 7
29399: ARRAY
29400: PUSH
29401: LD_INT 2
29403: ARRAY
29404: PPUSH
29405: CALL_OW 428
29409: PUSH
29410: LD_INT 0
29412: GREATER
29413: OR
29414: PUSH
29415: LD_VAR 0 12
29419: PUSH
29420: LD_VAR 0 7
29424: ARRAY
29425: PUSH
29426: LD_INT 1
29428: ARRAY
29429: PPUSH
29430: LD_VAR 0 12
29434: PUSH
29435: LD_VAR 0 7
29439: ARRAY
29440: PUSH
29441: LD_INT 2
29443: ARRAY
29444: PPUSH
29445: CALL_OW 351
29449: OR
29450: IFFALSE 29456
// exit ;
29452: POP
29453: POP
29454: GO 29763
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29456: LD_ADDR_VAR 0 8
29460: PUSH
29461: LD_VAR 0 12
29465: PUSH
29466: LD_VAR 0 7
29470: ARRAY
29471: PUSH
29472: LD_INT 1
29474: ARRAY
29475: PPUSH
29476: LD_VAR 0 12
29480: PUSH
29481: LD_VAR 0 7
29485: ARRAY
29486: PUSH
29487: LD_INT 2
29489: ARRAY
29490: PPUSH
29491: CALL_OW 546
29495: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
29496: LD_VAR 0 8
29500: PUSH
29501: LD_INT 1
29503: ARRAY
29504: PUSH
29505: LD_VAR 0 8
29509: PUSH
29510: LD_INT 2
29512: ARRAY
29513: PUSH
29514: LD_VAR 0 13
29518: PUSH
29519: LD_INT 2
29521: PLUS
29522: GREATER
29523: OR
29524: PUSH
29525: LD_VAR 0 8
29529: PUSH
29530: LD_INT 2
29532: ARRAY
29533: PUSH
29534: LD_VAR 0 13
29538: PUSH
29539: LD_INT 2
29541: MINUS
29542: LESS
29543: OR
29544: PUSH
29545: LD_VAR 0 8
29549: PUSH
29550: LD_INT 3
29552: ARRAY
29553: PUSH
29554: LD_INT 0
29556: PUSH
29557: LD_INT 8
29559: PUSH
29560: LD_INT 9
29562: PUSH
29563: LD_INT 10
29565: PUSH
29566: LD_INT 11
29568: PUSH
29569: LD_INT 12
29571: PUSH
29572: LD_INT 13
29574: PUSH
29575: LD_INT 16
29577: PUSH
29578: LD_INT 17
29580: PUSH
29581: LD_INT 18
29583: PUSH
29584: LD_INT 19
29586: PUSH
29587: LD_INT 20
29589: PUSH
29590: LD_INT 21
29592: PUSH
29593: EMPTY
29594: LIST
29595: LIST
29596: LIST
29597: LIST
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: IN
29608: NOT
29609: OR
29610: PUSH
29611: LD_VAR 0 8
29615: PUSH
29616: LD_INT 5
29618: ARRAY
29619: NOT
29620: OR
29621: PUSH
29622: LD_VAR 0 8
29626: PUSH
29627: LD_INT 6
29629: ARRAY
29630: PUSH
29631: LD_INT 1
29633: PUSH
29634: LD_INT 2
29636: PUSH
29637: LD_INT 7
29639: PUSH
29640: LD_INT 9
29642: PUSH
29643: LD_INT 10
29645: PUSH
29646: LD_INT 11
29648: PUSH
29649: EMPTY
29650: LIST
29651: LIST
29652: LIST
29653: LIST
29654: LIST
29655: LIST
29656: IN
29657: NOT
29658: OR
29659: IFFALSE 29665
// exit ;
29661: POP
29662: POP
29663: GO 29763
// end ;
29665: GO 29336
29667: POP
29668: POP
// side := GetSide ( depot ) ;
29669: LD_ADDR_VAR 0 9
29673: PUSH
29674: LD_VAR 0 1
29678: PPUSH
29679: CALL_OW 255
29683: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29684: LD_VAR 0 9
29688: PPUSH
29689: LD_VAR 0 3
29693: PPUSH
29694: LD_VAR 0 4
29698: PPUSH
29699: LD_INT 20
29701: PPUSH
29702: CALL 22417 0 4
29706: PUSH
29707: LD_INT 4
29709: ARRAY
29710: IFFALSE 29714
// exit ;
29712: GO 29763
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29714: LD_VAR 0 2
29718: PUSH
29719: LD_INT 29
29721: PUSH
29722: LD_INT 30
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: IN
29729: PUSH
29730: LD_VAR 0 3
29734: PPUSH
29735: LD_VAR 0 4
29739: PPUSH
29740: LD_VAR 0 9
29744: PPUSH
29745: CALL_OW 440
29749: NOT
29750: AND
29751: IFFALSE 29755
// exit ;
29753: GO 29763
// result := true ;
29755: LD_ADDR_VAR 0 6
29759: PUSH
29760: LD_INT 1
29762: ST_TO_ADDR
// end ;
29763: LD_VAR 0 6
29767: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
29768: LD_INT 0
29770: PPUSH
29771: PPUSH
29772: PPUSH
29773: PPUSH
29774: PPUSH
29775: PPUSH
29776: PPUSH
29777: PPUSH
29778: PPUSH
29779: PPUSH
29780: PPUSH
29781: PPUSH
29782: PPUSH
29783: PPUSH
29784: PPUSH
29785: PPUSH
29786: PPUSH
29787: PPUSH
29788: PPUSH
29789: PPUSH
29790: PPUSH
29791: PPUSH
29792: PPUSH
29793: PPUSH
29794: PPUSH
29795: PPUSH
29796: PPUSH
29797: PPUSH
29798: PPUSH
29799: PPUSH
29800: PPUSH
29801: PPUSH
29802: PPUSH
29803: PPUSH
29804: PPUSH
29805: PPUSH
29806: PPUSH
29807: PPUSH
29808: PPUSH
29809: PPUSH
29810: PPUSH
29811: PPUSH
29812: PPUSH
29813: PPUSH
29814: PPUSH
29815: PPUSH
29816: PPUSH
29817: PPUSH
29818: PPUSH
29819: PPUSH
29820: PPUSH
29821: PPUSH
29822: PPUSH
29823: PPUSH
29824: PPUSH
29825: PPUSH
29826: PPUSH
29827: PPUSH
// result = [ ] ;
29828: LD_ADDR_VAR 0 7
29832: PUSH
29833: EMPTY
29834: ST_TO_ADDR
// temp_list = [ ] ;
29835: LD_ADDR_VAR 0 9
29839: PUSH
29840: EMPTY
29841: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29842: LD_VAR 0 4
29846: PUSH
29847: LD_INT 0
29849: PUSH
29850: LD_INT 1
29852: PUSH
29853: LD_INT 2
29855: PUSH
29856: LD_INT 3
29858: PUSH
29859: LD_INT 4
29861: PUSH
29862: LD_INT 5
29864: PUSH
29865: EMPTY
29866: LIST
29867: LIST
29868: LIST
29869: LIST
29870: LIST
29871: LIST
29872: IN
29873: NOT
29874: PUSH
29875: LD_VAR 0 1
29879: PUSH
29880: LD_INT 0
29882: PUSH
29883: LD_INT 1
29885: PUSH
29886: EMPTY
29887: LIST
29888: LIST
29889: IN
29890: PUSH
29891: LD_VAR 0 5
29895: PUSH
29896: LD_INT 1
29898: PUSH
29899: LD_INT 2
29901: PUSH
29902: LD_INT 3
29904: PUSH
29905: EMPTY
29906: LIST
29907: LIST
29908: LIST
29909: IN
29910: NOT
29911: AND
29912: OR
29913: IFFALSE 29917
// exit ;
29915: GO 48308
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29917: LD_VAR 0 1
29921: PUSH
29922: LD_INT 6
29924: PUSH
29925: LD_INT 7
29927: PUSH
29928: LD_INT 8
29930: PUSH
29931: LD_INT 13
29933: PUSH
29934: LD_INT 12
29936: PUSH
29937: LD_INT 15
29939: PUSH
29940: LD_INT 11
29942: PUSH
29943: LD_INT 14
29945: PUSH
29946: LD_INT 10
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: LIST
29953: LIST
29954: LIST
29955: LIST
29956: LIST
29957: LIST
29958: LIST
29959: IN
29960: IFFALSE 29970
// btype = b_lab ;
29962: LD_ADDR_VAR 0 1
29966: PUSH
29967: LD_INT 6
29969: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29970: LD_VAR 0 6
29974: PUSH
29975: LD_INT 0
29977: PUSH
29978: LD_INT 1
29980: PUSH
29981: LD_INT 2
29983: PUSH
29984: EMPTY
29985: LIST
29986: LIST
29987: LIST
29988: IN
29989: NOT
29990: PUSH
29991: LD_VAR 0 1
29995: PUSH
29996: LD_INT 0
29998: PUSH
29999: LD_INT 1
30001: PUSH
30002: LD_INT 2
30004: PUSH
30005: LD_INT 3
30007: PUSH
30008: LD_INT 6
30010: PUSH
30011: LD_INT 36
30013: PUSH
30014: LD_INT 4
30016: PUSH
30017: LD_INT 5
30019: PUSH
30020: LD_INT 31
30022: PUSH
30023: LD_INT 32
30025: PUSH
30026: LD_INT 33
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: LIST
30033: LIST
30034: LIST
30035: LIST
30036: LIST
30037: LIST
30038: LIST
30039: LIST
30040: LIST
30041: IN
30042: NOT
30043: PUSH
30044: LD_VAR 0 6
30048: PUSH
30049: LD_INT 1
30051: EQUAL
30052: AND
30053: OR
30054: PUSH
30055: LD_VAR 0 1
30059: PUSH
30060: LD_INT 2
30062: PUSH
30063: LD_INT 3
30065: PUSH
30066: EMPTY
30067: LIST
30068: LIST
30069: IN
30070: NOT
30071: PUSH
30072: LD_VAR 0 6
30076: PUSH
30077: LD_INT 2
30079: EQUAL
30080: AND
30081: OR
30082: IFFALSE 30092
// mode = 0 ;
30084: LD_ADDR_VAR 0 6
30088: PUSH
30089: LD_INT 0
30091: ST_TO_ADDR
// case mode of 0 :
30092: LD_VAR 0 6
30096: PUSH
30097: LD_INT 0
30099: DOUBLE
30100: EQUAL
30101: IFTRUE 30105
30103: GO 41558
30105: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
30106: LD_ADDR_VAR 0 11
30110: PUSH
30111: LD_INT 0
30113: PUSH
30114: LD_INT 0
30116: PUSH
30117: EMPTY
30118: LIST
30119: LIST
30120: PUSH
30121: LD_INT 0
30123: PUSH
30124: LD_INT 1
30126: NEG
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PUSH
30132: LD_INT 1
30134: PUSH
30135: LD_INT 0
30137: PUSH
30138: EMPTY
30139: LIST
30140: LIST
30141: PUSH
30142: LD_INT 1
30144: PUSH
30145: LD_INT 1
30147: PUSH
30148: EMPTY
30149: LIST
30150: LIST
30151: PUSH
30152: LD_INT 0
30154: PUSH
30155: LD_INT 1
30157: PUSH
30158: EMPTY
30159: LIST
30160: LIST
30161: PUSH
30162: LD_INT 1
30164: NEG
30165: PUSH
30166: LD_INT 0
30168: PUSH
30169: EMPTY
30170: LIST
30171: LIST
30172: PUSH
30173: LD_INT 1
30175: NEG
30176: PUSH
30177: LD_INT 1
30179: NEG
30180: PUSH
30181: EMPTY
30182: LIST
30183: LIST
30184: PUSH
30185: LD_INT 1
30187: NEG
30188: PUSH
30189: LD_INT 2
30191: NEG
30192: PUSH
30193: EMPTY
30194: LIST
30195: LIST
30196: PUSH
30197: LD_INT 0
30199: PUSH
30200: LD_INT 2
30202: NEG
30203: PUSH
30204: EMPTY
30205: LIST
30206: LIST
30207: PUSH
30208: LD_INT 1
30210: PUSH
30211: LD_INT 1
30213: NEG
30214: PUSH
30215: EMPTY
30216: LIST
30217: LIST
30218: PUSH
30219: LD_INT 1
30221: PUSH
30222: LD_INT 2
30224: PUSH
30225: EMPTY
30226: LIST
30227: LIST
30228: PUSH
30229: LD_INT 0
30231: PUSH
30232: LD_INT 2
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PUSH
30239: LD_INT 1
30241: NEG
30242: PUSH
30243: LD_INT 1
30245: PUSH
30246: EMPTY
30247: LIST
30248: LIST
30249: PUSH
30250: LD_INT 1
30252: PUSH
30253: LD_INT 3
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PUSH
30260: LD_INT 0
30262: PUSH
30263: LD_INT 3
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 1
30272: NEG
30273: PUSH
30274: LD_INT 2
30276: PUSH
30277: EMPTY
30278: LIST
30279: LIST
30280: PUSH
30281: EMPTY
30282: LIST
30283: LIST
30284: LIST
30285: LIST
30286: LIST
30287: LIST
30288: LIST
30289: LIST
30290: LIST
30291: LIST
30292: LIST
30293: LIST
30294: LIST
30295: LIST
30296: LIST
30297: LIST
30298: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30299: LD_ADDR_VAR 0 12
30303: PUSH
30304: LD_INT 0
30306: PUSH
30307: LD_INT 0
30309: PUSH
30310: EMPTY
30311: LIST
30312: LIST
30313: PUSH
30314: LD_INT 0
30316: PUSH
30317: LD_INT 1
30319: NEG
30320: PUSH
30321: EMPTY
30322: LIST
30323: LIST
30324: PUSH
30325: LD_INT 1
30327: PUSH
30328: LD_INT 0
30330: PUSH
30331: EMPTY
30332: LIST
30333: LIST
30334: PUSH
30335: LD_INT 1
30337: PUSH
30338: LD_INT 1
30340: PUSH
30341: EMPTY
30342: LIST
30343: LIST
30344: PUSH
30345: LD_INT 0
30347: PUSH
30348: LD_INT 1
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: PUSH
30355: LD_INT 1
30357: NEG
30358: PUSH
30359: LD_INT 0
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: LD_INT 1
30368: NEG
30369: PUSH
30370: LD_INT 1
30372: NEG
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: PUSH
30378: LD_INT 1
30380: PUSH
30381: LD_INT 1
30383: NEG
30384: PUSH
30385: EMPTY
30386: LIST
30387: LIST
30388: PUSH
30389: LD_INT 2
30391: PUSH
30392: LD_INT 0
30394: PUSH
30395: EMPTY
30396: LIST
30397: LIST
30398: PUSH
30399: LD_INT 2
30401: PUSH
30402: LD_INT 1
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: LD_INT 1
30411: NEG
30412: PUSH
30413: LD_INT 1
30415: PUSH
30416: EMPTY
30417: LIST
30418: LIST
30419: PUSH
30420: LD_INT 2
30422: NEG
30423: PUSH
30424: LD_INT 0
30426: PUSH
30427: EMPTY
30428: LIST
30429: LIST
30430: PUSH
30431: LD_INT 2
30433: NEG
30434: PUSH
30435: LD_INT 1
30437: NEG
30438: PUSH
30439: EMPTY
30440: LIST
30441: LIST
30442: PUSH
30443: LD_INT 2
30445: NEG
30446: PUSH
30447: LD_INT 1
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: PUSH
30454: LD_INT 3
30456: NEG
30457: PUSH
30458: LD_INT 0
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 3
30467: NEG
30468: PUSH
30469: LD_INT 1
30471: NEG
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: LIST
30481: LIST
30482: LIST
30483: LIST
30484: LIST
30485: LIST
30486: LIST
30487: LIST
30488: LIST
30489: LIST
30490: LIST
30491: LIST
30492: LIST
30493: LIST
30494: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30495: LD_ADDR_VAR 0 13
30499: PUSH
30500: LD_INT 0
30502: PUSH
30503: LD_INT 0
30505: PUSH
30506: EMPTY
30507: LIST
30508: LIST
30509: PUSH
30510: LD_INT 0
30512: PUSH
30513: LD_INT 1
30515: NEG
30516: PUSH
30517: EMPTY
30518: LIST
30519: LIST
30520: PUSH
30521: LD_INT 1
30523: PUSH
30524: LD_INT 0
30526: PUSH
30527: EMPTY
30528: LIST
30529: LIST
30530: PUSH
30531: LD_INT 1
30533: PUSH
30534: LD_INT 1
30536: PUSH
30537: EMPTY
30538: LIST
30539: LIST
30540: PUSH
30541: LD_INT 0
30543: PUSH
30544: LD_INT 1
30546: PUSH
30547: EMPTY
30548: LIST
30549: LIST
30550: PUSH
30551: LD_INT 1
30553: NEG
30554: PUSH
30555: LD_INT 0
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PUSH
30562: LD_INT 1
30564: NEG
30565: PUSH
30566: LD_INT 1
30568: NEG
30569: PUSH
30570: EMPTY
30571: LIST
30572: LIST
30573: PUSH
30574: LD_INT 1
30576: NEG
30577: PUSH
30578: LD_INT 2
30580: NEG
30581: PUSH
30582: EMPTY
30583: LIST
30584: LIST
30585: PUSH
30586: LD_INT 2
30588: PUSH
30589: LD_INT 1
30591: PUSH
30592: EMPTY
30593: LIST
30594: LIST
30595: PUSH
30596: LD_INT 2
30598: PUSH
30599: LD_INT 2
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 1
30608: PUSH
30609: LD_INT 2
30611: PUSH
30612: EMPTY
30613: LIST
30614: LIST
30615: PUSH
30616: LD_INT 2
30618: NEG
30619: PUSH
30620: LD_INT 1
30622: NEG
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: LD_INT 2
30630: NEG
30631: PUSH
30632: LD_INT 2
30634: NEG
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: PUSH
30640: LD_INT 2
30642: NEG
30643: PUSH
30644: LD_INT 3
30646: NEG
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 3
30654: NEG
30655: PUSH
30656: LD_INT 2
30658: NEG
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: LD_INT 3
30666: NEG
30667: PUSH
30668: LD_INT 3
30670: NEG
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: LIST
30680: LIST
30681: LIST
30682: LIST
30683: LIST
30684: LIST
30685: LIST
30686: LIST
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: LIST
30693: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30694: LD_ADDR_VAR 0 14
30698: PUSH
30699: LD_INT 0
30701: PUSH
30702: LD_INT 0
30704: PUSH
30705: EMPTY
30706: LIST
30707: LIST
30708: PUSH
30709: LD_INT 0
30711: PUSH
30712: LD_INT 1
30714: NEG
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: PUSH
30720: LD_INT 1
30722: PUSH
30723: LD_INT 0
30725: PUSH
30726: EMPTY
30727: LIST
30728: LIST
30729: PUSH
30730: LD_INT 1
30732: PUSH
30733: LD_INT 1
30735: PUSH
30736: EMPTY
30737: LIST
30738: LIST
30739: PUSH
30740: LD_INT 0
30742: PUSH
30743: LD_INT 1
30745: PUSH
30746: EMPTY
30747: LIST
30748: LIST
30749: PUSH
30750: LD_INT 1
30752: NEG
30753: PUSH
30754: LD_INT 0
30756: PUSH
30757: EMPTY
30758: LIST
30759: LIST
30760: PUSH
30761: LD_INT 1
30763: NEG
30764: PUSH
30765: LD_INT 1
30767: NEG
30768: PUSH
30769: EMPTY
30770: LIST
30771: LIST
30772: PUSH
30773: LD_INT 1
30775: NEG
30776: PUSH
30777: LD_INT 2
30779: NEG
30780: PUSH
30781: EMPTY
30782: LIST
30783: LIST
30784: PUSH
30785: LD_INT 0
30787: PUSH
30788: LD_INT 2
30790: NEG
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 1
30798: PUSH
30799: LD_INT 1
30801: NEG
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: PUSH
30807: LD_INT 1
30809: PUSH
30810: LD_INT 2
30812: PUSH
30813: EMPTY
30814: LIST
30815: LIST
30816: PUSH
30817: LD_INT 0
30819: PUSH
30820: LD_INT 2
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: LD_INT 1
30829: NEG
30830: PUSH
30831: LD_INT 1
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: LD_INT 1
30840: NEG
30841: PUSH
30842: LD_INT 3
30844: NEG
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 0
30852: PUSH
30853: LD_INT 3
30855: NEG
30856: PUSH
30857: EMPTY
30858: LIST
30859: LIST
30860: PUSH
30861: LD_INT 1
30863: PUSH
30864: LD_INT 2
30866: NEG
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: PUSH
30872: EMPTY
30873: LIST
30874: LIST
30875: LIST
30876: LIST
30877: LIST
30878: LIST
30879: LIST
30880: LIST
30881: LIST
30882: LIST
30883: LIST
30884: LIST
30885: LIST
30886: LIST
30887: LIST
30888: LIST
30889: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30890: LD_ADDR_VAR 0 15
30894: PUSH
30895: LD_INT 0
30897: PUSH
30898: LD_INT 0
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PUSH
30905: LD_INT 0
30907: PUSH
30908: LD_INT 1
30910: NEG
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: LD_INT 1
30918: PUSH
30919: LD_INT 0
30921: PUSH
30922: EMPTY
30923: LIST
30924: LIST
30925: PUSH
30926: LD_INT 1
30928: PUSH
30929: LD_INT 1
30931: PUSH
30932: EMPTY
30933: LIST
30934: LIST
30935: PUSH
30936: LD_INT 0
30938: PUSH
30939: LD_INT 1
30941: PUSH
30942: EMPTY
30943: LIST
30944: LIST
30945: PUSH
30946: LD_INT 1
30948: NEG
30949: PUSH
30950: LD_INT 0
30952: PUSH
30953: EMPTY
30954: LIST
30955: LIST
30956: PUSH
30957: LD_INT 1
30959: NEG
30960: PUSH
30961: LD_INT 1
30963: NEG
30964: PUSH
30965: EMPTY
30966: LIST
30967: LIST
30968: PUSH
30969: LD_INT 1
30971: PUSH
30972: LD_INT 1
30974: NEG
30975: PUSH
30976: EMPTY
30977: LIST
30978: LIST
30979: PUSH
30980: LD_INT 2
30982: PUSH
30983: LD_INT 0
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PUSH
30990: LD_INT 2
30992: PUSH
30993: LD_INT 1
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PUSH
31000: LD_INT 1
31002: NEG
31003: PUSH
31004: LD_INT 1
31006: PUSH
31007: EMPTY
31008: LIST
31009: LIST
31010: PUSH
31011: LD_INT 2
31013: NEG
31014: PUSH
31015: LD_INT 0
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: PUSH
31022: LD_INT 2
31024: NEG
31025: PUSH
31026: LD_INT 1
31028: NEG
31029: PUSH
31030: EMPTY
31031: LIST
31032: LIST
31033: PUSH
31034: LD_INT 2
31036: PUSH
31037: LD_INT 1
31039: NEG
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: PUSH
31045: LD_INT 3
31047: PUSH
31048: LD_INT 0
31050: PUSH
31051: EMPTY
31052: LIST
31053: LIST
31054: PUSH
31055: LD_INT 3
31057: PUSH
31058: LD_INT 1
31060: PUSH
31061: EMPTY
31062: LIST
31063: LIST
31064: PUSH
31065: EMPTY
31066: LIST
31067: LIST
31068: LIST
31069: LIST
31070: LIST
31071: LIST
31072: LIST
31073: LIST
31074: LIST
31075: LIST
31076: LIST
31077: LIST
31078: LIST
31079: LIST
31080: LIST
31081: LIST
31082: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
31083: LD_ADDR_VAR 0 16
31087: PUSH
31088: LD_INT 0
31090: PUSH
31091: LD_INT 0
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 0
31100: PUSH
31101: LD_INT 1
31103: NEG
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 1
31111: PUSH
31112: LD_INT 0
31114: PUSH
31115: EMPTY
31116: LIST
31117: LIST
31118: PUSH
31119: LD_INT 1
31121: PUSH
31122: LD_INT 1
31124: PUSH
31125: EMPTY
31126: LIST
31127: LIST
31128: PUSH
31129: LD_INT 0
31131: PUSH
31132: LD_INT 1
31134: PUSH
31135: EMPTY
31136: LIST
31137: LIST
31138: PUSH
31139: LD_INT 1
31141: NEG
31142: PUSH
31143: LD_INT 0
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: LD_INT 1
31152: NEG
31153: PUSH
31154: LD_INT 1
31156: NEG
31157: PUSH
31158: EMPTY
31159: LIST
31160: LIST
31161: PUSH
31162: LD_INT 1
31164: NEG
31165: PUSH
31166: LD_INT 2
31168: NEG
31169: PUSH
31170: EMPTY
31171: LIST
31172: LIST
31173: PUSH
31174: LD_INT 2
31176: PUSH
31177: LD_INT 1
31179: PUSH
31180: EMPTY
31181: LIST
31182: LIST
31183: PUSH
31184: LD_INT 2
31186: PUSH
31187: LD_INT 2
31189: PUSH
31190: EMPTY
31191: LIST
31192: LIST
31193: PUSH
31194: LD_INT 1
31196: PUSH
31197: LD_INT 2
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: LD_INT 2
31206: NEG
31207: PUSH
31208: LD_INT 1
31210: NEG
31211: PUSH
31212: EMPTY
31213: LIST
31214: LIST
31215: PUSH
31216: LD_INT 2
31218: NEG
31219: PUSH
31220: LD_INT 2
31222: NEG
31223: PUSH
31224: EMPTY
31225: LIST
31226: LIST
31227: PUSH
31228: LD_INT 3
31230: PUSH
31231: LD_INT 2
31233: PUSH
31234: EMPTY
31235: LIST
31236: LIST
31237: PUSH
31238: LD_INT 3
31240: PUSH
31241: LD_INT 3
31243: PUSH
31244: EMPTY
31245: LIST
31246: LIST
31247: PUSH
31248: LD_INT 2
31250: PUSH
31251: LD_INT 3
31253: PUSH
31254: EMPTY
31255: LIST
31256: LIST
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: LIST
31262: LIST
31263: LIST
31264: LIST
31265: LIST
31266: LIST
31267: LIST
31268: LIST
31269: LIST
31270: LIST
31271: LIST
31272: LIST
31273: LIST
31274: LIST
31275: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31276: LD_ADDR_VAR 0 17
31280: PUSH
31281: LD_INT 0
31283: PUSH
31284: LD_INT 0
31286: PUSH
31287: EMPTY
31288: LIST
31289: LIST
31290: PUSH
31291: LD_INT 0
31293: PUSH
31294: LD_INT 1
31296: NEG
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 1
31304: PUSH
31305: LD_INT 0
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 1
31314: PUSH
31315: LD_INT 1
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: PUSH
31322: LD_INT 0
31324: PUSH
31325: LD_INT 1
31327: PUSH
31328: EMPTY
31329: LIST
31330: LIST
31331: PUSH
31332: LD_INT 1
31334: NEG
31335: PUSH
31336: LD_INT 0
31338: PUSH
31339: EMPTY
31340: LIST
31341: LIST
31342: PUSH
31343: LD_INT 1
31345: NEG
31346: PUSH
31347: LD_INT 1
31349: NEG
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 1
31357: NEG
31358: PUSH
31359: LD_INT 2
31361: NEG
31362: PUSH
31363: EMPTY
31364: LIST
31365: LIST
31366: PUSH
31367: LD_INT 0
31369: PUSH
31370: LD_INT 2
31372: NEG
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PUSH
31378: LD_INT 1
31380: PUSH
31381: LD_INT 1
31383: NEG
31384: PUSH
31385: EMPTY
31386: LIST
31387: LIST
31388: PUSH
31389: LD_INT 2
31391: PUSH
31392: LD_INT 0
31394: PUSH
31395: EMPTY
31396: LIST
31397: LIST
31398: PUSH
31399: LD_INT 2
31401: PUSH
31402: LD_INT 1
31404: PUSH
31405: EMPTY
31406: LIST
31407: LIST
31408: PUSH
31409: LD_INT 2
31411: PUSH
31412: LD_INT 2
31414: PUSH
31415: EMPTY
31416: LIST
31417: LIST
31418: PUSH
31419: LD_INT 1
31421: PUSH
31422: LD_INT 2
31424: PUSH
31425: EMPTY
31426: LIST
31427: LIST
31428: PUSH
31429: LD_INT 0
31431: PUSH
31432: LD_INT 2
31434: PUSH
31435: EMPTY
31436: LIST
31437: LIST
31438: PUSH
31439: LD_INT 1
31441: NEG
31442: PUSH
31443: LD_INT 1
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: PUSH
31450: LD_INT 2
31452: NEG
31453: PUSH
31454: LD_INT 0
31456: PUSH
31457: EMPTY
31458: LIST
31459: LIST
31460: PUSH
31461: LD_INT 2
31463: NEG
31464: PUSH
31465: LD_INT 1
31467: NEG
31468: PUSH
31469: EMPTY
31470: LIST
31471: LIST
31472: PUSH
31473: LD_INT 2
31475: NEG
31476: PUSH
31477: LD_INT 2
31479: NEG
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PUSH
31485: EMPTY
31486: LIST
31487: LIST
31488: LIST
31489: LIST
31490: LIST
31491: LIST
31492: LIST
31493: LIST
31494: LIST
31495: LIST
31496: LIST
31497: LIST
31498: LIST
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31506: LD_ADDR_VAR 0 18
31510: PUSH
31511: LD_INT 0
31513: PUSH
31514: LD_INT 0
31516: PUSH
31517: EMPTY
31518: LIST
31519: LIST
31520: PUSH
31521: LD_INT 0
31523: PUSH
31524: LD_INT 1
31526: NEG
31527: PUSH
31528: EMPTY
31529: LIST
31530: LIST
31531: PUSH
31532: LD_INT 1
31534: PUSH
31535: LD_INT 0
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: PUSH
31542: LD_INT 1
31544: PUSH
31545: LD_INT 1
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: PUSH
31552: LD_INT 0
31554: PUSH
31555: LD_INT 1
31557: PUSH
31558: EMPTY
31559: LIST
31560: LIST
31561: PUSH
31562: LD_INT 1
31564: NEG
31565: PUSH
31566: LD_INT 0
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PUSH
31573: LD_INT 1
31575: NEG
31576: PUSH
31577: LD_INT 1
31579: NEG
31580: PUSH
31581: EMPTY
31582: LIST
31583: LIST
31584: PUSH
31585: LD_INT 1
31587: NEG
31588: PUSH
31589: LD_INT 2
31591: NEG
31592: PUSH
31593: EMPTY
31594: LIST
31595: LIST
31596: PUSH
31597: LD_INT 0
31599: PUSH
31600: LD_INT 2
31602: NEG
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 1
31610: PUSH
31611: LD_INT 1
31613: NEG
31614: PUSH
31615: EMPTY
31616: LIST
31617: LIST
31618: PUSH
31619: LD_INT 2
31621: PUSH
31622: LD_INT 0
31624: PUSH
31625: EMPTY
31626: LIST
31627: LIST
31628: PUSH
31629: LD_INT 2
31631: PUSH
31632: LD_INT 1
31634: PUSH
31635: EMPTY
31636: LIST
31637: LIST
31638: PUSH
31639: LD_INT 2
31641: PUSH
31642: LD_INT 2
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 1
31651: PUSH
31652: LD_INT 2
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: LD_INT 0
31661: PUSH
31662: LD_INT 2
31664: PUSH
31665: EMPTY
31666: LIST
31667: LIST
31668: PUSH
31669: LD_INT 1
31671: NEG
31672: PUSH
31673: LD_INT 1
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 2
31682: NEG
31683: PUSH
31684: LD_INT 0
31686: PUSH
31687: EMPTY
31688: LIST
31689: LIST
31690: PUSH
31691: LD_INT 2
31693: NEG
31694: PUSH
31695: LD_INT 1
31697: NEG
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: PUSH
31703: LD_INT 2
31705: NEG
31706: PUSH
31707: LD_INT 2
31709: NEG
31710: PUSH
31711: EMPTY
31712: LIST
31713: LIST
31714: PUSH
31715: EMPTY
31716: LIST
31717: LIST
31718: LIST
31719: LIST
31720: LIST
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: LIST
31733: LIST
31734: LIST
31735: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31736: LD_ADDR_VAR 0 19
31740: PUSH
31741: LD_INT 0
31743: PUSH
31744: LD_INT 0
31746: PUSH
31747: EMPTY
31748: LIST
31749: LIST
31750: PUSH
31751: LD_INT 0
31753: PUSH
31754: LD_INT 1
31756: NEG
31757: PUSH
31758: EMPTY
31759: LIST
31760: LIST
31761: PUSH
31762: LD_INT 1
31764: PUSH
31765: LD_INT 0
31767: PUSH
31768: EMPTY
31769: LIST
31770: LIST
31771: PUSH
31772: LD_INT 1
31774: PUSH
31775: LD_INT 1
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: PUSH
31782: LD_INT 0
31784: PUSH
31785: LD_INT 1
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: LD_INT 1
31794: NEG
31795: PUSH
31796: LD_INT 0
31798: PUSH
31799: EMPTY
31800: LIST
31801: LIST
31802: PUSH
31803: LD_INT 1
31805: NEG
31806: PUSH
31807: LD_INT 1
31809: NEG
31810: PUSH
31811: EMPTY
31812: LIST
31813: LIST
31814: PUSH
31815: LD_INT 1
31817: NEG
31818: PUSH
31819: LD_INT 2
31821: NEG
31822: PUSH
31823: EMPTY
31824: LIST
31825: LIST
31826: PUSH
31827: LD_INT 0
31829: PUSH
31830: LD_INT 2
31832: NEG
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: PUSH
31838: LD_INT 1
31840: PUSH
31841: LD_INT 1
31843: NEG
31844: PUSH
31845: EMPTY
31846: LIST
31847: LIST
31848: PUSH
31849: LD_INT 2
31851: PUSH
31852: LD_INT 0
31854: PUSH
31855: EMPTY
31856: LIST
31857: LIST
31858: PUSH
31859: LD_INT 2
31861: PUSH
31862: LD_INT 1
31864: PUSH
31865: EMPTY
31866: LIST
31867: LIST
31868: PUSH
31869: LD_INT 2
31871: PUSH
31872: LD_INT 2
31874: PUSH
31875: EMPTY
31876: LIST
31877: LIST
31878: PUSH
31879: LD_INT 1
31881: PUSH
31882: LD_INT 2
31884: PUSH
31885: EMPTY
31886: LIST
31887: LIST
31888: PUSH
31889: LD_INT 0
31891: PUSH
31892: LD_INT 2
31894: PUSH
31895: EMPTY
31896: LIST
31897: LIST
31898: PUSH
31899: LD_INT 1
31901: NEG
31902: PUSH
31903: LD_INT 1
31905: PUSH
31906: EMPTY
31907: LIST
31908: LIST
31909: PUSH
31910: LD_INT 2
31912: NEG
31913: PUSH
31914: LD_INT 0
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 2
31923: NEG
31924: PUSH
31925: LD_INT 1
31927: NEG
31928: PUSH
31929: EMPTY
31930: LIST
31931: LIST
31932: PUSH
31933: LD_INT 2
31935: NEG
31936: PUSH
31937: LD_INT 2
31939: NEG
31940: PUSH
31941: EMPTY
31942: LIST
31943: LIST
31944: PUSH
31945: EMPTY
31946: LIST
31947: LIST
31948: LIST
31949: LIST
31950: LIST
31951: LIST
31952: LIST
31953: LIST
31954: LIST
31955: LIST
31956: LIST
31957: LIST
31958: LIST
31959: LIST
31960: LIST
31961: LIST
31962: LIST
31963: LIST
31964: LIST
31965: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31966: LD_ADDR_VAR 0 20
31970: PUSH
31971: LD_INT 0
31973: PUSH
31974: LD_INT 0
31976: PUSH
31977: EMPTY
31978: LIST
31979: LIST
31980: PUSH
31981: LD_INT 0
31983: PUSH
31984: LD_INT 1
31986: NEG
31987: PUSH
31988: EMPTY
31989: LIST
31990: LIST
31991: PUSH
31992: LD_INT 1
31994: PUSH
31995: LD_INT 0
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: PUSH
32002: LD_INT 1
32004: PUSH
32005: LD_INT 1
32007: PUSH
32008: EMPTY
32009: LIST
32010: LIST
32011: PUSH
32012: LD_INT 0
32014: PUSH
32015: LD_INT 1
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PUSH
32022: LD_INT 1
32024: NEG
32025: PUSH
32026: LD_INT 0
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: PUSH
32033: LD_INT 1
32035: NEG
32036: PUSH
32037: LD_INT 1
32039: NEG
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: PUSH
32045: LD_INT 1
32047: NEG
32048: PUSH
32049: LD_INT 2
32051: NEG
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: PUSH
32057: LD_INT 0
32059: PUSH
32060: LD_INT 2
32062: NEG
32063: PUSH
32064: EMPTY
32065: LIST
32066: LIST
32067: PUSH
32068: LD_INT 1
32070: PUSH
32071: LD_INT 1
32073: NEG
32074: PUSH
32075: EMPTY
32076: LIST
32077: LIST
32078: PUSH
32079: LD_INT 2
32081: PUSH
32082: LD_INT 0
32084: PUSH
32085: EMPTY
32086: LIST
32087: LIST
32088: PUSH
32089: LD_INT 2
32091: PUSH
32092: LD_INT 1
32094: PUSH
32095: EMPTY
32096: LIST
32097: LIST
32098: PUSH
32099: LD_INT 2
32101: PUSH
32102: LD_INT 2
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: PUSH
32109: LD_INT 1
32111: PUSH
32112: LD_INT 2
32114: PUSH
32115: EMPTY
32116: LIST
32117: LIST
32118: PUSH
32119: LD_INT 0
32121: PUSH
32122: LD_INT 2
32124: PUSH
32125: EMPTY
32126: LIST
32127: LIST
32128: PUSH
32129: LD_INT 1
32131: NEG
32132: PUSH
32133: LD_INT 1
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 2
32142: NEG
32143: PUSH
32144: LD_INT 0
32146: PUSH
32147: EMPTY
32148: LIST
32149: LIST
32150: PUSH
32151: LD_INT 2
32153: NEG
32154: PUSH
32155: LD_INT 1
32157: NEG
32158: PUSH
32159: EMPTY
32160: LIST
32161: LIST
32162: PUSH
32163: LD_INT 2
32165: NEG
32166: PUSH
32167: LD_INT 2
32169: NEG
32170: PUSH
32171: EMPTY
32172: LIST
32173: LIST
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: LIST
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: LIST
32195: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32196: LD_ADDR_VAR 0 21
32200: PUSH
32201: LD_INT 0
32203: PUSH
32204: LD_INT 0
32206: PUSH
32207: EMPTY
32208: LIST
32209: LIST
32210: PUSH
32211: LD_INT 0
32213: PUSH
32214: LD_INT 1
32216: NEG
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 1
32224: PUSH
32225: LD_INT 0
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 1
32234: PUSH
32235: LD_INT 1
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 0
32244: PUSH
32245: LD_INT 1
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 1
32254: NEG
32255: PUSH
32256: LD_INT 0
32258: PUSH
32259: EMPTY
32260: LIST
32261: LIST
32262: PUSH
32263: LD_INT 1
32265: NEG
32266: PUSH
32267: LD_INT 1
32269: NEG
32270: PUSH
32271: EMPTY
32272: LIST
32273: LIST
32274: PUSH
32275: LD_INT 1
32277: NEG
32278: PUSH
32279: LD_INT 2
32281: NEG
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 0
32289: PUSH
32290: LD_INT 2
32292: NEG
32293: PUSH
32294: EMPTY
32295: LIST
32296: LIST
32297: PUSH
32298: LD_INT 1
32300: PUSH
32301: LD_INT 1
32303: NEG
32304: PUSH
32305: EMPTY
32306: LIST
32307: LIST
32308: PUSH
32309: LD_INT 2
32311: PUSH
32312: LD_INT 0
32314: PUSH
32315: EMPTY
32316: LIST
32317: LIST
32318: PUSH
32319: LD_INT 2
32321: PUSH
32322: LD_INT 1
32324: PUSH
32325: EMPTY
32326: LIST
32327: LIST
32328: PUSH
32329: LD_INT 2
32331: PUSH
32332: LD_INT 2
32334: PUSH
32335: EMPTY
32336: LIST
32337: LIST
32338: PUSH
32339: LD_INT 1
32341: PUSH
32342: LD_INT 2
32344: PUSH
32345: EMPTY
32346: LIST
32347: LIST
32348: PUSH
32349: LD_INT 0
32351: PUSH
32352: LD_INT 2
32354: PUSH
32355: EMPTY
32356: LIST
32357: LIST
32358: PUSH
32359: LD_INT 1
32361: NEG
32362: PUSH
32363: LD_INT 1
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PUSH
32370: LD_INT 2
32372: NEG
32373: PUSH
32374: LD_INT 0
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: PUSH
32381: LD_INT 2
32383: NEG
32384: PUSH
32385: LD_INT 1
32387: NEG
32388: PUSH
32389: EMPTY
32390: LIST
32391: LIST
32392: PUSH
32393: LD_INT 2
32395: NEG
32396: PUSH
32397: LD_INT 2
32399: NEG
32400: PUSH
32401: EMPTY
32402: LIST
32403: LIST
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: LIST
32409: LIST
32410: LIST
32411: LIST
32412: LIST
32413: LIST
32414: LIST
32415: LIST
32416: LIST
32417: LIST
32418: LIST
32419: LIST
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32426: LD_ADDR_VAR 0 22
32430: PUSH
32431: LD_INT 0
32433: PUSH
32434: LD_INT 0
32436: PUSH
32437: EMPTY
32438: LIST
32439: LIST
32440: PUSH
32441: LD_INT 0
32443: PUSH
32444: LD_INT 1
32446: NEG
32447: PUSH
32448: EMPTY
32449: LIST
32450: LIST
32451: PUSH
32452: LD_INT 1
32454: PUSH
32455: LD_INT 0
32457: PUSH
32458: EMPTY
32459: LIST
32460: LIST
32461: PUSH
32462: LD_INT 1
32464: PUSH
32465: LD_INT 1
32467: PUSH
32468: EMPTY
32469: LIST
32470: LIST
32471: PUSH
32472: LD_INT 0
32474: PUSH
32475: LD_INT 1
32477: PUSH
32478: EMPTY
32479: LIST
32480: LIST
32481: PUSH
32482: LD_INT 1
32484: NEG
32485: PUSH
32486: LD_INT 0
32488: PUSH
32489: EMPTY
32490: LIST
32491: LIST
32492: PUSH
32493: LD_INT 1
32495: NEG
32496: PUSH
32497: LD_INT 1
32499: NEG
32500: PUSH
32501: EMPTY
32502: LIST
32503: LIST
32504: PUSH
32505: LD_INT 1
32507: NEG
32508: PUSH
32509: LD_INT 2
32511: NEG
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: PUSH
32517: LD_INT 0
32519: PUSH
32520: LD_INT 2
32522: NEG
32523: PUSH
32524: EMPTY
32525: LIST
32526: LIST
32527: PUSH
32528: LD_INT 1
32530: PUSH
32531: LD_INT 1
32533: NEG
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: PUSH
32539: LD_INT 2
32541: PUSH
32542: LD_INT 0
32544: PUSH
32545: EMPTY
32546: LIST
32547: LIST
32548: PUSH
32549: LD_INT 2
32551: PUSH
32552: LD_INT 1
32554: PUSH
32555: EMPTY
32556: LIST
32557: LIST
32558: PUSH
32559: LD_INT 2
32561: PUSH
32562: LD_INT 2
32564: PUSH
32565: EMPTY
32566: LIST
32567: LIST
32568: PUSH
32569: LD_INT 1
32571: PUSH
32572: LD_INT 2
32574: PUSH
32575: EMPTY
32576: LIST
32577: LIST
32578: PUSH
32579: LD_INT 0
32581: PUSH
32582: LD_INT 2
32584: PUSH
32585: EMPTY
32586: LIST
32587: LIST
32588: PUSH
32589: LD_INT 1
32591: NEG
32592: PUSH
32593: LD_INT 1
32595: PUSH
32596: EMPTY
32597: LIST
32598: LIST
32599: PUSH
32600: LD_INT 2
32602: NEG
32603: PUSH
32604: LD_INT 0
32606: PUSH
32607: EMPTY
32608: LIST
32609: LIST
32610: PUSH
32611: LD_INT 2
32613: NEG
32614: PUSH
32615: LD_INT 1
32617: NEG
32618: PUSH
32619: EMPTY
32620: LIST
32621: LIST
32622: PUSH
32623: LD_INT 2
32625: NEG
32626: PUSH
32627: LD_INT 2
32629: NEG
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: PUSH
32635: EMPTY
32636: LIST
32637: LIST
32638: LIST
32639: LIST
32640: LIST
32641: LIST
32642: LIST
32643: LIST
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
32656: LD_ADDR_VAR 0 23
32660: PUSH
32661: LD_INT 0
32663: PUSH
32664: LD_INT 0
32666: PUSH
32667: EMPTY
32668: LIST
32669: LIST
32670: PUSH
32671: LD_INT 0
32673: PUSH
32674: LD_INT 1
32676: NEG
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PUSH
32682: LD_INT 1
32684: PUSH
32685: LD_INT 0
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 1
32694: PUSH
32695: LD_INT 1
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 0
32704: PUSH
32705: LD_INT 1
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: LD_INT 1
32714: NEG
32715: PUSH
32716: LD_INT 0
32718: PUSH
32719: EMPTY
32720: LIST
32721: LIST
32722: PUSH
32723: LD_INT 1
32725: NEG
32726: PUSH
32727: LD_INT 1
32729: NEG
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 1
32737: NEG
32738: PUSH
32739: LD_INT 2
32741: NEG
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 0
32749: PUSH
32750: LD_INT 2
32752: NEG
32753: PUSH
32754: EMPTY
32755: LIST
32756: LIST
32757: PUSH
32758: LD_INT 1
32760: PUSH
32761: LD_INT 1
32763: NEG
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: PUSH
32769: LD_INT 2
32771: PUSH
32772: LD_INT 0
32774: PUSH
32775: EMPTY
32776: LIST
32777: LIST
32778: PUSH
32779: LD_INT 2
32781: PUSH
32782: LD_INT 1
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: PUSH
32789: LD_INT 2
32791: PUSH
32792: LD_INT 2
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 1
32801: PUSH
32802: LD_INT 2
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 0
32811: PUSH
32812: LD_INT 2
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 1
32821: NEG
32822: PUSH
32823: LD_INT 1
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 2
32832: NEG
32833: PUSH
32834: LD_INT 0
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PUSH
32841: LD_INT 2
32843: NEG
32844: PUSH
32845: LD_INT 1
32847: NEG
32848: PUSH
32849: EMPTY
32850: LIST
32851: LIST
32852: PUSH
32853: LD_INT 2
32855: NEG
32856: PUSH
32857: LD_INT 2
32859: NEG
32860: PUSH
32861: EMPTY
32862: LIST
32863: LIST
32864: PUSH
32865: LD_INT 2
32867: NEG
32868: PUSH
32869: LD_INT 3
32871: NEG
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PUSH
32877: LD_INT 1
32879: NEG
32880: PUSH
32881: LD_INT 3
32883: NEG
32884: PUSH
32885: EMPTY
32886: LIST
32887: LIST
32888: PUSH
32889: LD_INT 1
32891: PUSH
32892: LD_INT 2
32894: NEG
32895: PUSH
32896: EMPTY
32897: LIST
32898: LIST
32899: PUSH
32900: LD_INT 2
32902: PUSH
32903: LD_INT 1
32905: NEG
32906: PUSH
32907: EMPTY
32908: LIST
32909: LIST
32910: PUSH
32911: EMPTY
32912: LIST
32913: LIST
32914: LIST
32915: LIST
32916: LIST
32917: LIST
32918: LIST
32919: LIST
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32936: LD_ADDR_VAR 0 24
32940: PUSH
32941: LD_INT 0
32943: PUSH
32944: LD_INT 0
32946: PUSH
32947: EMPTY
32948: LIST
32949: LIST
32950: PUSH
32951: LD_INT 0
32953: PUSH
32954: LD_INT 1
32956: NEG
32957: PUSH
32958: EMPTY
32959: LIST
32960: LIST
32961: PUSH
32962: LD_INT 1
32964: PUSH
32965: LD_INT 0
32967: PUSH
32968: EMPTY
32969: LIST
32970: LIST
32971: PUSH
32972: LD_INT 1
32974: PUSH
32975: LD_INT 1
32977: PUSH
32978: EMPTY
32979: LIST
32980: LIST
32981: PUSH
32982: LD_INT 0
32984: PUSH
32985: LD_INT 1
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: PUSH
32992: LD_INT 1
32994: NEG
32995: PUSH
32996: LD_INT 0
32998: PUSH
32999: EMPTY
33000: LIST
33001: LIST
33002: PUSH
33003: LD_INT 1
33005: NEG
33006: PUSH
33007: LD_INT 1
33009: NEG
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 1
33017: NEG
33018: PUSH
33019: LD_INT 2
33021: NEG
33022: PUSH
33023: EMPTY
33024: LIST
33025: LIST
33026: PUSH
33027: LD_INT 0
33029: PUSH
33030: LD_INT 2
33032: NEG
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: LD_INT 1
33040: PUSH
33041: LD_INT 1
33043: NEG
33044: PUSH
33045: EMPTY
33046: LIST
33047: LIST
33048: PUSH
33049: LD_INT 2
33051: PUSH
33052: LD_INT 0
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 2
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 2
33071: PUSH
33072: LD_INT 2
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 1
33081: PUSH
33082: LD_INT 2
33084: PUSH
33085: EMPTY
33086: LIST
33087: LIST
33088: PUSH
33089: LD_INT 0
33091: PUSH
33092: LD_INT 2
33094: PUSH
33095: EMPTY
33096: LIST
33097: LIST
33098: PUSH
33099: LD_INT 1
33101: NEG
33102: PUSH
33103: LD_INT 1
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: LD_INT 2
33112: NEG
33113: PUSH
33114: LD_INT 0
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 2
33123: NEG
33124: PUSH
33125: LD_INT 1
33127: NEG
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: PUSH
33133: LD_INT 2
33135: NEG
33136: PUSH
33137: LD_INT 2
33139: NEG
33140: PUSH
33141: EMPTY
33142: LIST
33143: LIST
33144: PUSH
33145: LD_INT 1
33147: PUSH
33148: LD_INT 2
33150: NEG
33151: PUSH
33152: EMPTY
33153: LIST
33154: LIST
33155: PUSH
33156: LD_INT 2
33158: PUSH
33159: LD_INT 1
33161: NEG
33162: PUSH
33163: EMPTY
33164: LIST
33165: LIST
33166: PUSH
33167: LD_INT 3
33169: PUSH
33170: LD_INT 1
33172: PUSH
33173: EMPTY
33174: LIST
33175: LIST
33176: PUSH
33177: LD_INT 3
33179: PUSH
33180: LD_INT 2
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: LIST
33191: LIST
33192: LIST
33193: LIST
33194: LIST
33195: LIST
33196: LIST
33197: LIST
33198: LIST
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
33212: LD_ADDR_VAR 0 25
33216: PUSH
33217: LD_INT 0
33219: PUSH
33220: LD_INT 0
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 0
33229: PUSH
33230: LD_INT 1
33232: NEG
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: PUSH
33238: LD_INT 1
33240: PUSH
33241: LD_INT 0
33243: PUSH
33244: EMPTY
33245: LIST
33246: LIST
33247: PUSH
33248: LD_INT 1
33250: PUSH
33251: LD_INT 1
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 0
33260: PUSH
33261: LD_INT 1
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: LD_INT 1
33270: NEG
33271: PUSH
33272: LD_INT 0
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 1
33281: NEG
33282: PUSH
33283: LD_INT 1
33285: NEG
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: PUSH
33291: LD_INT 1
33293: NEG
33294: PUSH
33295: LD_INT 2
33297: NEG
33298: PUSH
33299: EMPTY
33300: LIST
33301: LIST
33302: PUSH
33303: LD_INT 0
33305: PUSH
33306: LD_INT 2
33308: NEG
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 1
33316: PUSH
33317: LD_INT 1
33319: NEG
33320: PUSH
33321: EMPTY
33322: LIST
33323: LIST
33324: PUSH
33325: LD_INT 2
33327: PUSH
33328: LD_INT 0
33330: PUSH
33331: EMPTY
33332: LIST
33333: LIST
33334: PUSH
33335: LD_INT 2
33337: PUSH
33338: LD_INT 1
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 2
33347: PUSH
33348: LD_INT 2
33350: PUSH
33351: EMPTY
33352: LIST
33353: LIST
33354: PUSH
33355: LD_INT 1
33357: PUSH
33358: LD_INT 2
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 0
33367: PUSH
33368: LD_INT 2
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PUSH
33375: LD_INT 1
33377: NEG
33378: PUSH
33379: LD_INT 1
33381: PUSH
33382: EMPTY
33383: LIST
33384: LIST
33385: PUSH
33386: LD_INT 2
33388: NEG
33389: PUSH
33390: LD_INT 0
33392: PUSH
33393: EMPTY
33394: LIST
33395: LIST
33396: PUSH
33397: LD_INT 2
33399: NEG
33400: PUSH
33401: LD_INT 1
33403: NEG
33404: PUSH
33405: EMPTY
33406: LIST
33407: LIST
33408: PUSH
33409: LD_INT 2
33411: NEG
33412: PUSH
33413: LD_INT 2
33415: NEG
33416: PUSH
33417: EMPTY
33418: LIST
33419: LIST
33420: PUSH
33421: LD_INT 3
33423: PUSH
33424: LD_INT 1
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: PUSH
33431: LD_INT 3
33433: PUSH
33434: LD_INT 2
33436: PUSH
33437: EMPTY
33438: LIST
33439: LIST
33440: PUSH
33441: LD_INT 2
33443: PUSH
33444: LD_INT 3
33446: PUSH
33447: EMPTY
33448: LIST
33449: LIST
33450: PUSH
33451: LD_INT 1
33453: PUSH
33454: LD_INT 3
33456: PUSH
33457: EMPTY
33458: LIST
33459: LIST
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: LIST
33465: LIST
33466: LIST
33467: LIST
33468: LIST
33469: LIST
33470: LIST
33471: LIST
33472: LIST
33473: LIST
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
33486: LD_ADDR_VAR 0 26
33490: PUSH
33491: LD_INT 0
33493: PUSH
33494: LD_INT 0
33496: PUSH
33497: EMPTY
33498: LIST
33499: LIST
33500: PUSH
33501: LD_INT 0
33503: PUSH
33504: LD_INT 1
33506: NEG
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 1
33514: PUSH
33515: LD_INT 0
33517: PUSH
33518: EMPTY
33519: LIST
33520: LIST
33521: PUSH
33522: LD_INT 1
33524: PUSH
33525: LD_INT 1
33527: PUSH
33528: EMPTY
33529: LIST
33530: LIST
33531: PUSH
33532: LD_INT 0
33534: PUSH
33535: LD_INT 1
33537: PUSH
33538: EMPTY
33539: LIST
33540: LIST
33541: PUSH
33542: LD_INT 1
33544: NEG
33545: PUSH
33546: LD_INT 0
33548: PUSH
33549: EMPTY
33550: LIST
33551: LIST
33552: PUSH
33553: LD_INT 1
33555: NEG
33556: PUSH
33557: LD_INT 1
33559: NEG
33560: PUSH
33561: EMPTY
33562: LIST
33563: LIST
33564: PUSH
33565: LD_INT 1
33567: NEG
33568: PUSH
33569: LD_INT 2
33571: NEG
33572: PUSH
33573: EMPTY
33574: LIST
33575: LIST
33576: PUSH
33577: LD_INT 0
33579: PUSH
33580: LD_INT 2
33582: NEG
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: LD_INT 1
33590: PUSH
33591: LD_INT 1
33593: NEG
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: LD_INT 2
33601: PUSH
33602: LD_INT 0
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 2
33611: PUSH
33612: LD_INT 1
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 2
33621: PUSH
33622: LD_INT 2
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 1
33631: PUSH
33632: LD_INT 2
33634: PUSH
33635: EMPTY
33636: LIST
33637: LIST
33638: PUSH
33639: LD_INT 0
33641: PUSH
33642: LD_INT 2
33644: PUSH
33645: EMPTY
33646: LIST
33647: LIST
33648: PUSH
33649: LD_INT 1
33651: NEG
33652: PUSH
33653: LD_INT 1
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 2
33662: NEG
33663: PUSH
33664: LD_INT 0
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 2
33673: NEG
33674: PUSH
33675: LD_INT 1
33677: NEG
33678: PUSH
33679: EMPTY
33680: LIST
33681: LIST
33682: PUSH
33683: LD_INT 2
33685: NEG
33686: PUSH
33687: LD_INT 2
33689: NEG
33690: PUSH
33691: EMPTY
33692: LIST
33693: LIST
33694: PUSH
33695: LD_INT 2
33697: PUSH
33698: LD_INT 3
33700: PUSH
33701: EMPTY
33702: LIST
33703: LIST
33704: PUSH
33705: LD_INT 1
33707: PUSH
33708: LD_INT 3
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PUSH
33715: LD_INT 1
33717: NEG
33718: PUSH
33719: LD_INT 2
33721: PUSH
33722: EMPTY
33723: LIST
33724: LIST
33725: PUSH
33726: LD_INT 2
33728: NEG
33729: PUSH
33730: LD_INT 1
33732: PUSH
33733: EMPTY
33734: LIST
33735: LIST
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: LIST
33741: LIST
33742: LIST
33743: LIST
33744: LIST
33745: LIST
33746: LIST
33747: LIST
33748: LIST
33749: LIST
33750: LIST
33751: LIST
33752: LIST
33753: LIST
33754: LIST
33755: LIST
33756: LIST
33757: LIST
33758: LIST
33759: LIST
33760: LIST
33761: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33762: LD_ADDR_VAR 0 27
33766: PUSH
33767: LD_INT 0
33769: PUSH
33770: LD_INT 0
33772: PUSH
33773: EMPTY
33774: LIST
33775: LIST
33776: PUSH
33777: LD_INT 0
33779: PUSH
33780: LD_INT 1
33782: NEG
33783: PUSH
33784: EMPTY
33785: LIST
33786: LIST
33787: PUSH
33788: LD_INT 1
33790: PUSH
33791: LD_INT 0
33793: PUSH
33794: EMPTY
33795: LIST
33796: LIST
33797: PUSH
33798: LD_INT 1
33800: PUSH
33801: LD_INT 1
33803: PUSH
33804: EMPTY
33805: LIST
33806: LIST
33807: PUSH
33808: LD_INT 0
33810: PUSH
33811: LD_INT 1
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: LD_INT 1
33820: NEG
33821: PUSH
33822: LD_INT 0
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: LD_INT 1
33831: NEG
33832: PUSH
33833: LD_INT 1
33835: NEG
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: LD_INT 1
33843: NEG
33844: PUSH
33845: LD_INT 2
33847: NEG
33848: PUSH
33849: EMPTY
33850: LIST
33851: LIST
33852: PUSH
33853: LD_INT 0
33855: PUSH
33856: LD_INT 2
33858: NEG
33859: PUSH
33860: EMPTY
33861: LIST
33862: LIST
33863: PUSH
33864: LD_INT 1
33866: PUSH
33867: LD_INT 1
33869: NEG
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 2
33877: PUSH
33878: LD_INT 0
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 2
33887: PUSH
33888: LD_INT 1
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 2
33897: PUSH
33898: LD_INT 2
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 1
33907: PUSH
33908: LD_INT 2
33910: PUSH
33911: EMPTY
33912: LIST
33913: LIST
33914: PUSH
33915: LD_INT 0
33917: PUSH
33918: LD_INT 2
33920: PUSH
33921: EMPTY
33922: LIST
33923: LIST
33924: PUSH
33925: LD_INT 1
33927: NEG
33928: PUSH
33929: LD_INT 1
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 2
33938: NEG
33939: PUSH
33940: LD_INT 0
33942: PUSH
33943: EMPTY
33944: LIST
33945: LIST
33946: PUSH
33947: LD_INT 2
33949: NEG
33950: PUSH
33951: LD_INT 1
33953: NEG
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 2
33961: NEG
33962: PUSH
33963: LD_INT 2
33965: NEG
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PUSH
33971: LD_INT 1
33973: NEG
33974: PUSH
33975: LD_INT 2
33977: PUSH
33978: EMPTY
33979: LIST
33980: LIST
33981: PUSH
33982: LD_INT 2
33984: NEG
33985: PUSH
33986: LD_INT 1
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 3
33995: NEG
33996: PUSH
33997: LD_INT 1
33999: NEG
34000: PUSH
34001: EMPTY
34002: LIST
34003: LIST
34004: PUSH
34005: LD_INT 3
34007: NEG
34008: PUSH
34009: LD_INT 2
34011: NEG
34012: PUSH
34013: EMPTY
34014: LIST
34015: LIST
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: LIST
34021: LIST
34022: LIST
34023: LIST
34024: LIST
34025: LIST
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34042: LD_ADDR_VAR 0 28
34046: PUSH
34047: LD_INT 0
34049: PUSH
34050: LD_INT 0
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: PUSH
34057: LD_INT 0
34059: PUSH
34060: LD_INT 1
34062: NEG
34063: PUSH
34064: EMPTY
34065: LIST
34066: LIST
34067: PUSH
34068: LD_INT 1
34070: PUSH
34071: LD_INT 0
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PUSH
34078: LD_INT 1
34080: PUSH
34081: LD_INT 1
34083: PUSH
34084: EMPTY
34085: LIST
34086: LIST
34087: PUSH
34088: LD_INT 0
34090: PUSH
34091: LD_INT 1
34093: PUSH
34094: EMPTY
34095: LIST
34096: LIST
34097: PUSH
34098: LD_INT 1
34100: NEG
34101: PUSH
34102: LD_INT 0
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: PUSH
34109: LD_INT 1
34111: NEG
34112: PUSH
34113: LD_INT 1
34115: NEG
34116: PUSH
34117: EMPTY
34118: LIST
34119: LIST
34120: PUSH
34121: LD_INT 1
34123: NEG
34124: PUSH
34125: LD_INT 2
34127: NEG
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 0
34135: PUSH
34136: LD_INT 2
34138: NEG
34139: PUSH
34140: EMPTY
34141: LIST
34142: LIST
34143: PUSH
34144: LD_INT 1
34146: PUSH
34147: LD_INT 1
34149: NEG
34150: PUSH
34151: EMPTY
34152: LIST
34153: LIST
34154: PUSH
34155: LD_INT 2
34157: PUSH
34158: LD_INT 0
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PUSH
34165: LD_INT 2
34167: PUSH
34168: LD_INT 1
34170: PUSH
34171: EMPTY
34172: LIST
34173: LIST
34174: PUSH
34175: LD_INT 2
34177: PUSH
34178: LD_INT 2
34180: PUSH
34181: EMPTY
34182: LIST
34183: LIST
34184: PUSH
34185: LD_INT 1
34187: PUSH
34188: LD_INT 2
34190: PUSH
34191: EMPTY
34192: LIST
34193: LIST
34194: PUSH
34195: LD_INT 0
34197: PUSH
34198: LD_INT 2
34200: PUSH
34201: EMPTY
34202: LIST
34203: LIST
34204: PUSH
34205: LD_INT 1
34207: NEG
34208: PUSH
34209: LD_INT 1
34211: PUSH
34212: EMPTY
34213: LIST
34214: LIST
34215: PUSH
34216: LD_INT 2
34218: NEG
34219: PUSH
34220: LD_INT 0
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 2
34229: NEG
34230: PUSH
34231: LD_INT 1
34233: NEG
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: LD_INT 2
34241: NEG
34242: PUSH
34243: LD_INT 2
34245: NEG
34246: PUSH
34247: EMPTY
34248: LIST
34249: LIST
34250: PUSH
34251: LD_INT 2
34253: NEG
34254: PUSH
34255: LD_INT 3
34257: NEG
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: PUSH
34263: LD_INT 1
34265: NEG
34266: PUSH
34267: LD_INT 3
34269: NEG
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 3
34277: NEG
34278: PUSH
34279: LD_INT 1
34281: NEG
34282: PUSH
34283: EMPTY
34284: LIST
34285: LIST
34286: PUSH
34287: LD_INT 3
34289: NEG
34290: PUSH
34291: LD_INT 2
34293: NEG
34294: PUSH
34295: EMPTY
34296: LIST
34297: LIST
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: LIST
34303: LIST
34304: LIST
34305: LIST
34306: LIST
34307: LIST
34308: LIST
34309: LIST
34310: LIST
34311: LIST
34312: LIST
34313: LIST
34314: LIST
34315: LIST
34316: LIST
34317: LIST
34318: LIST
34319: LIST
34320: LIST
34321: LIST
34322: LIST
34323: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34324: LD_ADDR_VAR 0 29
34328: PUSH
34329: LD_INT 0
34331: PUSH
34332: LD_INT 0
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: LD_INT 0
34341: PUSH
34342: LD_INT 1
34344: NEG
34345: PUSH
34346: EMPTY
34347: LIST
34348: LIST
34349: PUSH
34350: LD_INT 1
34352: PUSH
34353: LD_INT 0
34355: PUSH
34356: EMPTY
34357: LIST
34358: LIST
34359: PUSH
34360: LD_INT 1
34362: PUSH
34363: LD_INT 1
34365: PUSH
34366: EMPTY
34367: LIST
34368: LIST
34369: PUSH
34370: LD_INT 0
34372: PUSH
34373: LD_INT 1
34375: PUSH
34376: EMPTY
34377: LIST
34378: LIST
34379: PUSH
34380: LD_INT 1
34382: NEG
34383: PUSH
34384: LD_INT 0
34386: PUSH
34387: EMPTY
34388: LIST
34389: LIST
34390: PUSH
34391: LD_INT 1
34393: NEG
34394: PUSH
34395: LD_INT 1
34397: NEG
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: PUSH
34403: LD_INT 1
34405: NEG
34406: PUSH
34407: LD_INT 2
34409: NEG
34410: PUSH
34411: EMPTY
34412: LIST
34413: LIST
34414: PUSH
34415: LD_INT 0
34417: PUSH
34418: LD_INT 2
34420: NEG
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: PUSH
34426: LD_INT 1
34428: PUSH
34429: LD_INT 1
34431: NEG
34432: PUSH
34433: EMPTY
34434: LIST
34435: LIST
34436: PUSH
34437: LD_INT 2
34439: PUSH
34440: LD_INT 0
34442: PUSH
34443: EMPTY
34444: LIST
34445: LIST
34446: PUSH
34447: LD_INT 2
34449: PUSH
34450: LD_INT 1
34452: PUSH
34453: EMPTY
34454: LIST
34455: LIST
34456: PUSH
34457: LD_INT 1
34459: PUSH
34460: LD_INT 2
34462: PUSH
34463: EMPTY
34464: LIST
34465: LIST
34466: PUSH
34467: LD_INT 0
34469: PUSH
34470: LD_INT 2
34472: PUSH
34473: EMPTY
34474: LIST
34475: LIST
34476: PUSH
34477: LD_INT 1
34479: NEG
34480: PUSH
34481: LD_INT 1
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: LD_INT 2
34490: NEG
34491: PUSH
34492: LD_INT 1
34494: NEG
34495: PUSH
34496: EMPTY
34497: LIST
34498: LIST
34499: PUSH
34500: LD_INT 2
34502: NEG
34503: PUSH
34504: LD_INT 2
34506: NEG
34507: PUSH
34508: EMPTY
34509: LIST
34510: LIST
34511: PUSH
34512: LD_INT 2
34514: NEG
34515: PUSH
34516: LD_INT 3
34518: NEG
34519: PUSH
34520: EMPTY
34521: LIST
34522: LIST
34523: PUSH
34524: LD_INT 2
34526: PUSH
34527: LD_INT 1
34529: NEG
34530: PUSH
34531: EMPTY
34532: LIST
34533: LIST
34534: PUSH
34535: LD_INT 3
34537: PUSH
34538: LD_INT 1
34540: PUSH
34541: EMPTY
34542: LIST
34543: LIST
34544: PUSH
34545: LD_INT 1
34547: PUSH
34548: LD_INT 3
34550: PUSH
34551: EMPTY
34552: LIST
34553: LIST
34554: PUSH
34555: LD_INT 1
34557: NEG
34558: PUSH
34559: LD_INT 2
34561: PUSH
34562: EMPTY
34563: LIST
34564: LIST
34565: PUSH
34566: LD_INT 3
34568: NEG
34569: PUSH
34570: LD_INT 2
34572: NEG
34573: PUSH
34574: EMPTY
34575: LIST
34576: LIST
34577: PUSH
34578: EMPTY
34579: LIST
34580: LIST
34581: LIST
34582: LIST
34583: LIST
34584: LIST
34585: LIST
34586: LIST
34587: LIST
34588: LIST
34589: LIST
34590: LIST
34591: LIST
34592: LIST
34593: LIST
34594: LIST
34595: LIST
34596: LIST
34597: LIST
34598: LIST
34599: LIST
34600: LIST
34601: LIST
34602: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34603: LD_ADDR_VAR 0 30
34607: PUSH
34608: LD_INT 0
34610: PUSH
34611: LD_INT 0
34613: PUSH
34614: EMPTY
34615: LIST
34616: LIST
34617: PUSH
34618: LD_INT 0
34620: PUSH
34621: LD_INT 1
34623: NEG
34624: PUSH
34625: EMPTY
34626: LIST
34627: LIST
34628: PUSH
34629: LD_INT 1
34631: PUSH
34632: LD_INT 0
34634: PUSH
34635: EMPTY
34636: LIST
34637: LIST
34638: PUSH
34639: LD_INT 1
34641: PUSH
34642: LD_INT 1
34644: PUSH
34645: EMPTY
34646: LIST
34647: LIST
34648: PUSH
34649: LD_INT 0
34651: PUSH
34652: LD_INT 1
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: PUSH
34659: LD_INT 1
34661: NEG
34662: PUSH
34663: LD_INT 0
34665: PUSH
34666: EMPTY
34667: LIST
34668: LIST
34669: PUSH
34670: LD_INT 1
34672: NEG
34673: PUSH
34674: LD_INT 1
34676: NEG
34677: PUSH
34678: EMPTY
34679: LIST
34680: LIST
34681: PUSH
34682: LD_INT 1
34684: NEG
34685: PUSH
34686: LD_INT 2
34688: NEG
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 0
34696: PUSH
34697: LD_INT 2
34699: NEG
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 1
34707: PUSH
34708: LD_INT 1
34710: NEG
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: LD_INT 2
34718: PUSH
34719: LD_INT 0
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PUSH
34726: LD_INT 2
34728: PUSH
34729: LD_INT 1
34731: PUSH
34732: EMPTY
34733: LIST
34734: LIST
34735: PUSH
34736: LD_INT 2
34738: PUSH
34739: LD_INT 2
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: LD_INT 1
34748: PUSH
34749: LD_INT 2
34751: PUSH
34752: EMPTY
34753: LIST
34754: LIST
34755: PUSH
34756: LD_INT 1
34758: NEG
34759: PUSH
34760: LD_INT 1
34762: PUSH
34763: EMPTY
34764: LIST
34765: LIST
34766: PUSH
34767: LD_INT 2
34769: NEG
34770: PUSH
34771: LD_INT 0
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: PUSH
34778: LD_INT 2
34780: NEG
34781: PUSH
34782: LD_INT 1
34784: NEG
34785: PUSH
34786: EMPTY
34787: LIST
34788: LIST
34789: PUSH
34790: LD_INT 1
34792: NEG
34793: PUSH
34794: LD_INT 3
34796: NEG
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: PUSH
34802: LD_INT 1
34804: PUSH
34805: LD_INT 2
34807: NEG
34808: PUSH
34809: EMPTY
34810: LIST
34811: LIST
34812: PUSH
34813: LD_INT 3
34815: PUSH
34816: LD_INT 2
34818: PUSH
34819: EMPTY
34820: LIST
34821: LIST
34822: PUSH
34823: LD_INT 2
34825: PUSH
34826: LD_INT 3
34828: PUSH
34829: EMPTY
34830: LIST
34831: LIST
34832: PUSH
34833: LD_INT 2
34835: NEG
34836: PUSH
34837: LD_INT 1
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PUSH
34844: LD_INT 3
34846: NEG
34847: PUSH
34848: LD_INT 1
34850: NEG
34851: PUSH
34852: EMPTY
34853: LIST
34854: LIST
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: LIST
34860: LIST
34861: LIST
34862: LIST
34863: LIST
34864: LIST
34865: LIST
34866: LIST
34867: LIST
34868: LIST
34869: LIST
34870: LIST
34871: LIST
34872: LIST
34873: LIST
34874: LIST
34875: LIST
34876: LIST
34877: LIST
34878: LIST
34879: LIST
34880: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34881: LD_ADDR_VAR 0 31
34885: PUSH
34886: LD_INT 0
34888: PUSH
34889: LD_INT 0
34891: PUSH
34892: EMPTY
34893: LIST
34894: LIST
34895: PUSH
34896: LD_INT 0
34898: PUSH
34899: LD_INT 1
34901: NEG
34902: PUSH
34903: EMPTY
34904: LIST
34905: LIST
34906: PUSH
34907: LD_INT 1
34909: PUSH
34910: LD_INT 0
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: PUSH
34917: LD_INT 1
34919: PUSH
34920: LD_INT 1
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 0
34929: PUSH
34930: LD_INT 1
34932: PUSH
34933: EMPTY
34934: LIST
34935: LIST
34936: PUSH
34937: LD_INT 1
34939: NEG
34940: PUSH
34941: LD_INT 0
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: LD_INT 1
34950: NEG
34951: PUSH
34952: LD_INT 1
34954: NEG
34955: PUSH
34956: EMPTY
34957: LIST
34958: LIST
34959: PUSH
34960: LD_INT 1
34962: NEG
34963: PUSH
34964: LD_INT 2
34966: NEG
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: PUSH
34972: LD_INT 1
34974: PUSH
34975: LD_INT 1
34977: NEG
34978: PUSH
34979: EMPTY
34980: LIST
34981: LIST
34982: PUSH
34983: LD_INT 2
34985: PUSH
34986: LD_INT 0
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 2
34995: PUSH
34996: LD_INT 1
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: LD_INT 2
35005: PUSH
35006: LD_INT 2
35008: PUSH
35009: EMPTY
35010: LIST
35011: LIST
35012: PUSH
35013: LD_INT 1
35015: PUSH
35016: LD_INT 2
35018: PUSH
35019: EMPTY
35020: LIST
35021: LIST
35022: PUSH
35023: LD_INT 0
35025: PUSH
35026: LD_INT 2
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 1
35035: NEG
35036: PUSH
35037: LD_INT 1
35039: PUSH
35040: EMPTY
35041: LIST
35042: LIST
35043: PUSH
35044: LD_INT 2
35046: NEG
35047: PUSH
35048: LD_INT 1
35050: NEG
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: PUSH
35056: LD_INT 2
35058: NEG
35059: PUSH
35060: LD_INT 2
35062: NEG
35063: PUSH
35064: EMPTY
35065: LIST
35066: LIST
35067: PUSH
35068: LD_INT 2
35070: NEG
35071: PUSH
35072: LD_INT 3
35074: NEG
35075: PUSH
35076: EMPTY
35077: LIST
35078: LIST
35079: PUSH
35080: LD_INT 2
35082: PUSH
35083: LD_INT 1
35085: NEG
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: PUSH
35091: LD_INT 3
35093: PUSH
35094: LD_INT 1
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: PUSH
35101: LD_INT 1
35103: PUSH
35104: LD_INT 3
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 1
35113: NEG
35114: PUSH
35115: LD_INT 2
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: LD_INT 3
35124: NEG
35125: PUSH
35126: LD_INT 2
35128: NEG
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: LIST
35138: LIST
35139: LIST
35140: LIST
35141: LIST
35142: LIST
35143: LIST
35144: LIST
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: LIST
35150: LIST
35151: LIST
35152: LIST
35153: LIST
35154: LIST
35155: LIST
35156: LIST
35157: LIST
35158: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35159: LD_ADDR_VAR 0 32
35163: PUSH
35164: LD_INT 0
35166: PUSH
35167: LD_INT 0
35169: PUSH
35170: EMPTY
35171: LIST
35172: LIST
35173: PUSH
35174: LD_INT 0
35176: PUSH
35177: LD_INT 1
35179: NEG
35180: PUSH
35181: EMPTY
35182: LIST
35183: LIST
35184: PUSH
35185: LD_INT 1
35187: PUSH
35188: LD_INT 0
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: PUSH
35195: LD_INT 1
35197: PUSH
35198: LD_INT 1
35200: PUSH
35201: EMPTY
35202: LIST
35203: LIST
35204: PUSH
35205: LD_INT 0
35207: PUSH
35208: LD_INT 1
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PUSH
35215: LD_INT 1
35217: NEG
35218: PUSH
35219: LD_INT 0
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: PUSH
35226: LD_INT 1
35228: NEG
35229: PUSH
35230: LD_INT 1
35232: NEG
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: LD_INT 2
35244: NEG
35245: PUSH
35246: EMPTY
35247: LIST
35248: LIST
35249: PUSH
35250: LD_INT 0
35252: PUSH
35253: LD_INT 2
35255: NEG
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: PUSH
35261: LD_INT 1
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: LD_INT 2
35274: PUSH
35275: LD_INT 1
35277: PUSH
35278: EMPTY
35279: LIST
35280: LIST
35281: PUSH
35282: LD_INT 2
35284: PUSH
35285: LD_INT 2
35287: PUSH
35288: EMPTY
35289: LIST
35290: LIST
35291: PUSH
35292: LD_INT 1
35294: PUSH
35295: LD_INT 2
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: LD_INT 0
35304: PUSH
35305: LD_INT 2
35307: PUSH
35308: EMPTY
35309: LIST
35310: LIST
35311: PUSH
35312: LD_INT 1
35314: NEG
35315: PUSH
35316: LD_INT 1
35318: PUSH
35319: EMPTY
35320: LIST
35321: LIST
35322: PUSH
35323: LD_INT 2
35325: NEG
35326: PUSH
35327: LD_INT 0
35329: PUSH
35330: EMPTY
35331: LIST
35332: LIST
35333: PUSH
35334: LD_INT 2
35336: NEG
35337: PUSH
35338: LD_INT 1
35340: NEG
35341: PUSH
35342: EMPTY
35343: LIST
35344: LIST
35345: PUSH
35346: LD_INT 1
35348: NEG
35349: PUSH
35350: LD_INT 3
35352: NEG
35353: PUSH
35354: EMPTY
35355: LIST
35356: LIST
35357: PUSH
35358: LD_INT 1
35360: PUSH
35361: LD_INT 2
35363: NEG
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 3
35371: PUSH
35372: LD_INT 2
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 2
35381: PUSH
35382: LD_INT 3
35384: PUSH
35385: EMPTY
35386: LIST
35387: LIST
35388: PUSH
35389: LD_INT 2
35391: NEG
35392: PUSH
35393: LD_INT 1
35395: PUSH
35396: EMPTY
35397: LIST
35398: LIST
35399: PUSH
35400: LD_INT 3
35402: NEG
35403: PUSH
35404: LD_INT 1
35406: NEG
35407: PUSH
35408: EMPTY
35409: LIST
35410: LIST
35411: PUSH
35412: EMPTY
35413: LIST
35414: LIST
35415: LIST
35416: LIST
35417: LIST
35418: LIST
35419: LIST
35420: LIST
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: LIST
35436: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35437: LD_ADDR_VAR 0 33
35441: PUSH
35442: LD_INT 0
35444: PUSH
35445: LD_INT 0
35447: PUSH
35448: EMPTY
35449: LIST
35450: LIST
35451: PUSH
35452: LD_INT 0
35454: PUSH
35455: LD_INT 1
35457: NEG
35458: PUSH
35459: EMPTY
35460: LIST
35461: LIST
35462: PUSH
35463: LD_INT 1
35465: PUSH
35466: LD_INT 0
35468: PUSH
35469: EMPTY
35470: LIST
35471: LIST
35472: PUSH
35473: LD_INT 1
35475: PUSH
35476: LD_INT 1
35478: PUSH
35479: EMPTY
35480: LIST
35481: LIST
35482: PUSH
35483: LD_INT 0
35485: PUSH
35486: LD_INT 1
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PUSH
35493: LD_INT 1
35495: NEG
35496: PUSH
35497: LD_INT 0
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 1
35506: NEG
35507: PUSH
35508: LD_INT 1
35510: NEG
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: PUSH
35516: LD_INT 1
35518: NEG
35519: PUSH
35520: LD_INT 2
35522: NEG
35523: PUSH
35524: EMPTY
35525: LIST
35526: LIST
35527: PUSH
35528: LD_INT 1
35530: PUSH
35531: LD_INT 1
35533: NEG
35534: PUSH
35535: EMPTY
35536: LIST
35537: LIST
35538: PUSH
35539: LD_INT 2
35541: PUSH
35542: LD_INT 0
35544: PUSH
35545: EMPTY
35546: LIST
35547: LIST
35548: PUSH
35549: LD_INT 2
35551: PUSH
35552: LD_INT 1
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 1
35561: PUSH
35562: LD_INT 2
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PUSH
35569: LD_INT 0
35571: PUSH
35572: LD_INT 2
35574: PUSH
35575: EMPTY
35576: LIST
35577: LIST
35578: PUSH
35579: LD_INT 1
35581: NEG
35582: PUSH
35583: LD_INT 1
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: LD_INT 2
35592: NEG
35593: PUSH
35594: LD_INT 0
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 2
35603: NEG
35604: PUSH
35605: LD_INT 1
35607: NEG
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: LD_INT 2
35615: NEG
35616: PUSH
35617: LD_INT 2
35619: NEG
35620: PUSH
35621: EMPTY
35622: LIST
35623: LIST
35624: PUSH
35625: LD_INT 2
35627: NEG
35628: PUSH
35629: LD_INT 3
35631: NEG
35632: PUSH
35633: EMPTY
35634: LIST
35635: LIST
35636: PUSH
35637: LD_INT 2
35639: PUSH
35640: LD_INT 1
35642: NEG
35643: PUSH
35644: EMPTY
35645: LIST
35646: LIST
35647: PUSH
35648: LD_INT 3
35650: PUSH
35651: LD_INT 1
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PUSH
35658: LD_INT 1
35660: PUSH
35661: LD_INT 3
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: LD_INT 1
35670: NEG
35671: PUSH
35672: LD_INT 2
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 3
35681: NEG
35682: PUSH
35683: LD_INT 2
35685: NEG
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: LIST
35695: LIST
35696: LIST
35697: LIST
35698: LIST
35699: LIST
35700: LIST
35701: LIST
35702: LIST
35703: LIST
35704: LIST
35705: LIST
35706: LIST
35707: LIST
35708: LIST
35709: LIST
35710: LIST
35711: LIST
35712: LIST
35713: LIST
35714: LIST
35715: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35716: LD_ADDR_VAR 0 34
35720: PUSH
35721: LD_INT 0
35723: PUSH
35724: LD_INT 0
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 0
35733: PUSH
35734: LD_INT 1
35736: NEG
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 1
35744: PUSH
35745: LD_INT 0
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: LD_INT 1
35754: PUSH
35755: LD_INT 1
35757: PUSH
35758: EMPTY
35759: LIST
35760: LIST
35761: PUSH
35762: LD_INT 0
35764: PUSH
35765: LD_INT 1
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 1
35774: NEG
35775: PUSH
35776: LD_INT 0
35778: PUSH
35779: EMPTY
35780: LIST
35781: LIST
35782: PUSH
35783: LD_INT 1
35785: NEG
35786: PUSH
35787: LD_INT 1
35789: NEG
35790: PUSH
35791: EMPTY
35792: LIST
35793: LIST
35794: PUSH
35795: LD_INT 1
35797: NEG
35798: PUSH
35799: LD_INT 2
35801: NEG
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PUSH
35807: LD_INT 0
35809: PUSH
35810: LD_INT 2
35812: NEG
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: LD_INT 1
35820: PUSH
35821: LD_INT 1
35823: NEG
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 2
35831: PUSH
35832: LD_INT 1
35834: PUSH
35835: EMPTY
35836: LIST
35837: LIST
35838: PUSH
35839: LD_INT 2
35841: PUSH
35842: LD_INT 2
35844: PUSH
35845: EMPTY
35846: LIST
35847: LIST
35848: PUSH
35849: LD_INT 1
35851: PUSH
35852: LD_INT 2
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 1
35861: NEG
35862: PUSH
35863: LD_INT 1
35865: PUSH
35866: EMPTY
35867: LIST
35868: LIST
35869: PUSH
35870: LD_INT 2
35872: NEG
35873: PUSH
35874: LD_INT 0
35876: PUSH
35877: EMPTY
35878: LIST
35879: LIST
35880: PUSH
35881: LD_INT 2
35883: NEG
35884: PUSH
35885: LD_INT 1
35887: NEG
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 2
35895: NEG
35896: PUSH
35897: LD_INT 2
35899: NEG
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: PUSH
35905: LD_INT 1
35907: NEG
35908: PUSH
35909: LD_INT 3
35911: NEG
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 1
35919: PUSH
35920: LD_INT 2
35922: NEG
35923: PUSH
35924: EMPTY
35925: LIST
35926: LIST
35927: PUSH
35928: LD_INT 3
35930: PUSH
35931: LD_INT 2
35933: PUSH
35934: EMPTY
35935: LIST
35936: LIST
35937: PUSH
35938: LD_INT 2
35940: PUSH
35941: LD_INT 3
35943: PUSH
35944: EMPTY
35945: LIST
35946: LIST
35947: PUSH
35948: LD_INT 2
35950: NEG
35951: PUSH
35952: LD_INT 1
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PUSH
35959: LD_INT 3
35961: NEG
35962: PUSH
35963: LD_INT 1
35965: NEG
35966: PUSH
35967: EMPTY
35968: LIST
35969: LIST
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: LIST
35975: LIST
35976: LIST
35977: LIST
35978: LIST
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: LIST
35993: LIST
35994: LIST
35995: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35996: LD_ADDR_VAR 0 35
36000: PUSH
36001: LD_INT 0
36003: PUSH
36004: LD_INT 0
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 0
36013: PUSH
36014: LD_INT 1
36016: NEG
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 1
36024: PUSH
36025: LD_INT 0
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 1
36034: PUSH
36035: LD_INT 1
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 0
36044: PUSH
36045: LD_INT 1
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 1
36054: NEG
36055: PUSH
36056: LD_INT 0
36058: PUSH
36059: EMPTY
36060: LIST
36061: LIST
36062: PUSH
36063: LD_INT 1
36065: NEG
36066: PUSH
36067: LD_INT 1
36069: NEG
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: LD_INT 2
36077: PUSH
36078: LD_INT 1
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 2
36087: NEG
36088: PUSH
36089: LD_INT 1
36091: NEG
36092: PUSH
36093: EMPTY
36094: LIST
36095: LIST
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: LIST
36101: LIST
36102: LIST
36103: LIST
36104: LIST
36105: LIST
36106: LIST
36107: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36108: LD_ADDR_VAR 0 36
36112: PUSH
36113: LD_INT 0
36115: PUSH
36116: LD_INT 0
36118: PUSH
36119: EMPTY
36120: LIST
36121: LIST
36122: PUSH
36123: LD_INT 0
36125: PUSH
36126: LD_INT 1
36128: NEG
36129: PUSH
36130: EMPTY
36131: LIST
36132: LIST
36133: PUSH
36134: LD_INT 1
36136: PUSH
36137: LD_INT 0
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PUSH
36144: LD_INT 1
36146: PUSH
36147: LD_INT 1
36149: PUSH
36150: EMPTY
36151: LIST
36152: LIST
36153: PUSH
36154: LD_INT 0
36156: PUSH
36157: LD_INT 1
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: PUSH
36164: LD_INT 1
36166: NEG
36167: PUSH
36168: LD_INT 0
36170: PUSH
36171: EMPTY
36172: LIST
36173: LIST
36174: PUSH
36175: LD_INT 1
36177: NEG
36178: PUSH
36179: LD_INT 1
36181: NEG
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 1
36189: NEG
36190: PUSH
36191: LD_INT 2
36193: NEG
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: LD_INT 1
36201: PUSH
36202: LD_INT 2
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: LIST
36213: LIST
36214: LIST
36215: LIST
36216: LIST
36217: LIST
36218: LIST
36219: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36220: LD_ADDR_VAR 0 37
36224: PUSH
36225: LD_INT 0
36227: PUSH
36228: LD_INT 0
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 0
36237: PUSH
36238: LD_INT 1
36240: NEG
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 1
36248: PUSH
36249: LD_INT 0
36251: PUSH
36252: EMPTY
36253: LIST
36254: LIST
36255: PUSH
36256: LD_INT 1
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: PUSH
36266: LD_INT 0
36268: PUSH
36269: LD_INT 1
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 1
36278: NEG
36279: PUSH
36280: LD_INT 0
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 1
36289: NEG
36290: PUSH
36291: LD_INT 1
36293: NEG
36294: PUSH
36295: EMPTY
36296: LIST
36297: LIST
36298: PUSH
36299: LD_INT 1
36301: PUSH
36302: LD_INT 1
36304: NEG
36305: PUSH
36306: EMPTY
36307: LIST
36308: LIST
36309: PUSH
36310: LD_INT 1
36312: NEG
36313: PUSH
36314: LD_INT 1
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: LIST
36325: LIST
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36332: LD_ADDR_VAR 0 38
36336: PUSH
36337: LD_INT 0
36339: PUSH
36340: LD_INT 0
36342: PUSH
36343: EMPTY
36344: LIST
36345: LIST
36346: PUSH
36347: LD_INT 0
36349: PUSH
36350: LD_INT 1
36352: NEG
36353: PUSH
36354: EMPTY
36355: LIST
36356: LIST
36357: PUSH
36358: LD_INT 1
36360: PUSH
36361: LD_INT 0
36363: PUSH
36364: EMPTY
36365: LIST
36366: LIST
36367: PUSH
36368: LD_INT 1
36370: PUSH
36371: LD_INT 1
36373: PUSH
36374: EMPTY
36375: LIST
36376: LIST
36377: PUSH
36378: LD_INT 0
36380: PUSH
36381: LD_INT 1
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 1
36390: NEG
36391: PUSH
36392: LD_INT 0
36394: PUSH
36395: EMPTY
36396: LIST
36397: LIST
36398: PUSH
36399: LD_INT 1
36401: NEG
36402: PUSH
36403: LD_INT 1
36405: NEG
36406: PUSH
36407: EMPTY
36408: LIST
36409: LIST
36410: PUSH
36411: LD_INT 2
36413: PUSH
36414: LD_INT 1
36416: PUSH
36417: EMPTY
36418: LIST
36419: LIST
36420: PUSH
36421: LD_INT 2
36423: NEG
36424: PUSH
36425: LD_INT 1
36427: NEG
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: LIST
36437: LIST
36438: LIST
36439: LIST
36440: LIST
36441: LIST
36442: LIST
36443: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36444: LD_ADDR_VAR 0 39
36448: PUSH
36449: LD_INT 0
36451: PUSH
36452: LD_INT 0
36454: PUSH
36455: EMPTY
36456: LIST
36457: LIST
36458: PUSH
36459: LD_INT 0
36461: PUSH
36462: LD_INT 1
36464: NEG
36465: PUSH
36466: EMPTY
36467: LIST
36468: LIST
36469: PUSH
36470: LD_INT 1
36472: PUSH
36473: LD_INT 0
36475: PUSH
36476: EMPTY
36477: LIST
36478: LIST
36479: PUSH
36480: LD_INT 1
36482: PUSH
36483: LD_INT 1
36485: PUSH
36486: EMPTY
36487: LIST
36488: LIST
36489: PUSH
36490: LD_INT 0
36492: PUSH
36493: LD_INT 1
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: LD_INT 1
36502: NEG
36503: PUSH
36504: LD_INT 0
36506: PUSH
36507: EMPTY
36508: LIST
36509: LIST
36510: PUSH
36511: LD_INT 1
36513: NEG
36514: PUSH
36515: LD_INT 1
36517: NEG
36518: PUSH
36519: EMPTY
36520: LIST
36521: LIST
36522: PUSH
36523: LD_INT 1
36525: NEG
36526: PUSH
36527: LD_INT 2
36529: NEG
36530: PUSH
36531: EMPTY
36532: LIST
36533: LIST
36534: PUSH
36535: LD_INT 1
36537: PUSH
36538: LD_INT 2
36540: PUSH
36541: EMPTY
36542: LIST
36543: LIST
36544: PUSH
36545: EMPTY
36546: LIST
36547: LIST
36548: LIST
36549: LIST
36550: LIST
36551: LIST
36552: LIST
36553: LIST
36554: LIST
36555: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36556: LD_ADDR_VAR 0 40
36560: PUSH
36561: LD_INT 0
36563: PUSH
36564: LD_INT 0
36566: PUSH
36567: EMPTY
36568: LIST
36569: LIST
36570: PUSH
36571: LD_INT 0
36573: PUSH
36574: LD_INT 1
36576: NEG
36577: PUSH
36578: EMPTY
36579: LIST
36580: LIST
36581: PUSH
36582: LD_INT 1
36584: PUSH
36585: LD_INT 0
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 1
36594: PUSH
36595: LD_INT 1
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: LD_INT 0
36604: PUSH
36605: LD_INT 1
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 1
36614: NEG
36615: PUSH
36616: LD_INT 0
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: LD_INT 1
36625: NEG
36626: PUSH
36627: LD_INT 1
36629: NEG
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 1
36637: PUSH
36638: LD_INT 1
36640: NEG
36641: PUSH
36642: EMPTY
36643: LIST
36644: LIST
36645: PUSH
36646: LD_INT 1
36648: NEG
36649: PUSH
36650: LD_INT 1
36652: PUSH
36653: EMPTY
36654: LIST
36655: LIST
36656: PUSH
36657: EMPTY
36658: LIST
36659: LIST
36660: LIST
36661: LIST
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36668: LD_ADDR_VAR 0 41
36672: PUSH
36673: LD_INT 0
36675: PUSH
36676: LD_INT 0
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PUSH
36683: LD_INT 0
36685: PUSH
36686: LD_INT 1
36688: NEG
36689: PUSH
36690: EMPTY
36691: LIST
36692: LIST
36693: PUSH
36694: LD_INT 1
36696: PUSH
36697: LD_INT 0
36699: PUSH
36700: EMPTY
36701: LIST
36702: LIST
36703: PUSH
36704: LD_INT 1
36706: PUSH
36707: LD_INT 1
36709: PUSH
36710: EMPTY
36711: LIST
36712: LIST
36713: PUSH
36714: LD_INT 0
36716: PUSH
36717: LD_INT 1
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: LD_INT 1
36726: NEG
36727: PUSH
36728: LD_INT 0
36730: PUSH
36731: EMPTY
36732: LIST
36733: LIST
36734: PUSH
36735: LD_INT 1
36737: NEG
36738: PUSH
36739: LD_INT 1
36741: NEG
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: LD_INT 1
36749: NEG
36750: PUSH
36751: LD_INT 2
36753: NEG
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PUSH
36759: LD_INT 1
36761: PUSH
36762: LD_INT 1
36764: NEG
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: PUSH
36770: LD_INT 2
36772: PUSH
36773: LD_INT 0
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: LD_INT 2
36782: PUSH
36783: LD_INT 1
36785: PUSH
36786: EMPTY
36787: LIST
36788: LIST
36789: PUSH
36790: LD_INT 2
36792: PUSH
36793: LD_INT 2
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: PUSH
36800: LD_INT 1
36802: PUSH
36803: LD_INT 2
36805: PUSH
36806: EMPTY
36807: LIST
36808: LIST
36809: PUSH
36810: LD_INT 1
36812: NEG
36813: PUSH
36814: LD_INT 1
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: PUSH
36821: LD_INT 2
36823: NEG
36824: PUSH
36825: LD_INT 0
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: PUSH
36832: LD_INT 2
36834: NEG
36835: PUSH
36836: LD_INT 1
36838: NEG
36839: PUSH
36840: EMPTY
36841: LIST
36842: LIST
36843: PUSH
36844: LD_INT 2
36846: NEG
36847: PUSH
36848: LD_INT 2
36850: NEG
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: PUSH
36856: LD_INT 2
36858: NEG
36859: PUSH
36860: LD_INT 3
36862: NEG
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 2
36870: PUSH
36871: LD_INT 1
36873: NEG
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: PUSH
36879: LD_INT 3
36881: PUSH
36882: LD_INT 0
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 3
36891: PUSH
36892: LD_INT 1
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 3
36901: PUSH
36902: LD_INT 2
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 3
36911: PUSH
36912: LD_INT 3
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: LD_INT 2
36921: PUSH
36922: LD_INT 3
36924: PUSH
36925: EMPTY
36926: LIST
36927: LIST
36928: PUSH
36929: LD_INT 2
36931: NEG
36932: PUSH
36933: LD_INT 1
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: PUSH
36940: LD_INT 3
36942: NEG
36943: PUSH
36944: LD_INT 0
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: LD_INT 3
36953: NEG
36954: PUSH
36955: LD_INT 1
36957: NEG
36958: PUSH
36959: EMPTY
36960: LIST
36961: LIST
36962: PUSH
36963: LD_INT 3
36965: NEG
36966: PUSH
36967: LD_INT 2
36969: NEG
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: PUSH
36975: LD_INT 3
36977: NEG
36978: PUSH
36979: LD_INT 3
36981: NEG
36982: PUSH
36983: EMPTY
36984: LIST
36985: LIST
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: LIST
36991: LIST
36992: LIST
36993: LIST
36994: LIST
36995: LIST
36996: LIST
36997: LIST
36998: LIST
36999: LIST
37000: LIST
37001: LIST
37002: LIST
37003: LIST
37004: LIST
37005: LIST
37006: LIST
37007: LIST
37008: LIST
37009: LIST
37010: LIST
37011: LIST
37012: LIST
37013: LIST
37014: LIST
37015: LIST
37016: LIST
37017: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37018: LD_ADDR_VAR 0 42
37022: PUSH
37023: LD_INT 0
37025: PUSH
37026: LD_INT 0
37028: PUSH
37029: EMPTY
37030: LIST
37031: LIST
37032: PUSH
37033: LD_INT 0
37035: PUSH
37036: LD_INT 1
37038: NEG
37039: PUSH
37040: EMPTY
37041: LIST
37042: LIST
37043: PUSH
37044: LD_INT 1
37046: PUSH
37047: LD_INT 0
37049: PUSH
37050: EMPTY
37051: LIST
37052: LIST
37053: PUSH
37054: LD_INT 1
37056: PUSH
37057: LD_INT 1
37059: PUSH
37060: EMPTY
37061: LIST
37062: LIST
37063: PUSH
37064: LD_INT 0
37066: PUSH
37067: LD_INT 1
37069: PUSH
37070: EMPTY
37071: LIST
37072: LIST
37073: PUSH
37074: LD_INT 1
37076: NEG
37077: PUSH
37078: LD_INT 0
37080: PUSH
37081: EMPTY
37082: LIST
37083: LIST
37084: PUSH
37085: LD_INT 1
37087: NEG
37088: PUSH
37089: LD_INT 1
37091: NEG
37092: PUSH
37093: EMPTY
37094: LIST
37095: LIST
37096: PUSH
37097: LD_INT 1
37099: NEG
37100: PUSH
37101: LD_INT 2
37103: NEG
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: LD_INT 0
37111: PUSH
37112: LD_INT 2
37114: NEG
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: LD_INT 1
37122: PUSH
37123: LD_INT 1
37125: NEG
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 2
37133: PUSH
37134: LD_INT 1
37136: PUSH
37137: EMPTY
37138: LIST
37139: LIST
37140: PUSH
37141: LD_INT 2
37143: PUSH
37144: LD_INT 2
37146: PUSH
37147: EMPTY
37148: LIST
37149: LIST
37150: PUSH
37151: LD_INT 1
37153: PUSH
37154: LD_INT 2
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 0
37163: PUSH
37164: LD_INT 2
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 1
37173: NEG
37174: PUSH
37175: LD_INT 1
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 2
37184: NEG
37185: PUSH
37186: LD_INT 1
37188: NEG
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: LD_INT 2
37196: NEG
37197: PUSH
37198: LD_INT 2
37200: NEG
37201: PUSH
37202: EMPTY
37203: LIST
37204: LIST
37205: PUSH
37206: LD_INT 2
37208: NEG
37209: PUSH
37210: LD_INT 3
37212: NEG
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: PUSH
37218: LD_INT 1
37220: NEG
37221: PUSH
37222: LD_INT 3
37224: NEG
37225: PUSH
37226: EMPTY
37227: LIST
37228: LIST
37229: PUSH
37230: LD_INT 0
37232: PUSH
37233: LD_INT 3
37235: NEG
37236: PUSH
37237: EMPTY
37238: LIST
37239: LIST
37240: PUSH
37241: LD_INT 1
37243: PUSH
37244: LD_INT 2
37246: NEG
37247: PUSH
37248: EMPTY
37249: LIST
37250: LIST
37251: PUSH
37252: LD_INT 3
37254: PUSH
37255: LD_INT 2
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 3
37264: PUSH
37265: LD_INT 3
37267: PUSH
37268: EMPTY
37269: LIST
37270: LIST
37271: PUSH
37272: LD_INT 2
37274: PUSH
37275: LD_INT 3
37277: PUSH
37278: EMPTY
37279: LIST
37280: LIST
37281: PUSH
37282: LD_INT 1
37284: PUSH
37285: LD_INT 3
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 0
37294: PUSH
37295: LD_INT 3
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: LD_INT 1
37304: NEG
37305: PUSH
37306: LD_INT 2
37308: PUSH
37309: EMPTY
37310: LIST
37311: LIST
37312: PUSH
37313: LD_INT 3
37315: NEG
37316: PUSH
37317: LD_INT 2
37319: NEG
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: PUSH
37325: LD_INT 3
37327: NEG
37328: PUSH
37329: LD_INT 3
37331: NEG
37332: PUSH
37333: EMPTY
37334: LIST
37335: LIST
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: LIST
37341: LIST
37342: LIST
37343: LIST
37344: LIST
37345: LIST
37346: LIST
37347: LIST
37348: LIST
37349: LIST
37350: LIST
37351: LIST
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: LIST
37365: LIST
37366: LIST
37367: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37368: LD_ADDR_VAR 0 43
37372: PUSH
37373: LD_INT 0
37375: PUSH
37376: LD_INT 0
37378: PUSH
37379: EMPTY
37380: LIST
37381: LIST
37382: PUSH
37383: LD_INT 0
37385: PUSH
37386: LD_INT 1
37388: NEG
37389: PUSH
37390: EMPTY
37391: LIST
37392: LIST
37393: PUSH
37394: LD_INT 1
37396: PUSH
37397: LD_INT 0
37399: PUSH
37400: EMPTY
37401: LIST
37402: LIST
37403: PUSH
37404: LD_INT 1
37406: PUSH
37407: LD_INT 1
37409: PUSH
37410: EMPTY
37411: LIST
37412: LIST
37413: PUSH
37414: LD_INT 0
37416: PUSH
37417: LD_INT 1
37419: PUSH
37420: EMPTY
37421: LIST
37422: LIST
37423: PUSH
37424: LD_INT 1
37426: NEG
37427: PUSH
37428: LD_INT 0
37430: PUSH
37431: EMPTY
37432: LIST
37433: LIST
37434: PUSH
37435: LD_INT 1
37437: NEG
37438: PUSH
37439: LD_INT 1
37441: NEG
37442: PUSH
37443: EMPTY
37444: LIST
37445: LIST
37446: PUSH
37447: LD_INT 1
37449: NEG
37450: PUSH
37451: LD_INT 2
37453: NEG
37454: PUSH
37455: EMPTY
37456: LIST
37457: LIST
37458: PUSH
37459: LD_INT 0
37461: PUSH
37462: LD_INT 2
37464: NEG
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 1
37472: PUSH
37473: LD_INT 1
37475: NEG
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PUSH
37481: LD_INT 2
37483: PUSH
37484: LD_INT 0
37486: PUSH
37487: EMPTY
37488: LIST
37489: LIST
37490: PUSH
37491: LD_INT 2
37493: PUSH
37494: LD_INT 1
37496: PUSH
37497: EMPTY
37498: LIST
37499: LIST
37500: PUSH
37501: LD_INT 1
37503: PUSH
37504: LD_INT 2
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: LD_INT 0
37513: PUSH
37514: LD_INT 2
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PUSH
37521: LD_INT 1
37523: NEG
37524: PUSH
37525: LD_INT 1
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PUSH
37532: LD_INT 2
37534: NEG
37535: PUSH
37536: LD_INT 0
37538: PUSH
37539: EMPTY
37540: LIST
37541: LIST
37542: PUSH
37543: LD_INT 2
37545: NEG
37546: PUSH
37547: LD_INT 1
37549: NEG
37550: PUSH
37551: EMPTY
37552: LIST
37553: LIST
37554: PUSH
37555: LD_INT 1
37557: NEG
37558: PUSH
37559: LD_INT 3
37561: NEG
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: LD_INT 0
37569: PUSH
37570: LD_INT 3
37572: NEG
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: LD_INT 1
37580: PUSH
37581: LD_INT 2
37583: NEG
37584: PUSH
37585: EMPTY
37586: LIST
37587: LIST
37588: PUSH
37589: LD_INT 2
37591: PUSH
37592: LD_INT 1
37594: NEG
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PUSH
37600: LD_INT 3
37602: PUSH
37603: LD_INT 0
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 3
37612: PUSH
37613: LD_INT 1
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 1
37622: PUSH
37623: LD_INT 3
37625: PUSH
37626: EMPTY
37627: LIST
37628: LIST
37629: PUSH
37630: LD_INT 0
37632: PUSH
37633: LD_INT 3
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 1
37642: NEG
37643: PUSH
37644: LD_INT 2
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 2
37653: NEG
37654: PUSH
37655: LD_INT 1
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 3
37664: NEG
37665: PUSH
37666: LD_INT 0
37668: PUSH
37669: EMPTY
37670: LIST
37671: LIST
37672: PUSH
37673: LD_INT 3
37675: NEG
37676: PUSH
37677: LD_INT 1
37679: NEG
37680: PUSH
37681: EMPTY
37682: LIST
37683: LIST
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: LIST
37689: LIST
37690: LIST
37691: LIST
37692: LIST
37693: LIST
37694: LIST
37695: LIST
37696: LIST
37697: LIST
37698: LIST
37699: LIST
37700: LIST
37701: LIST
37702: LIST
37703: LIST
37704: LIST
37705: LIST
37706: LIST
37707: LIST
37708: LIST
37709: LIST
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37716: LD_ADDR_VAR 0 44
37720: PUSH
37721: LD_INT 0
37723: PUSH
37724: LD_INT 0
37726: PUSH
37727: EMPTY
37728: LIST
37729: LIST
37730: PUSH
37731: LD_INT 0
37733: PUSH
37734: LD_INT 1
37736: NEG
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: PUSH
37742: LD_INT 1
37744: PUSH
37745: LD_INT 0
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: LD_INT 1
37754: PUSH
37755: LD_INT 1
37757: PUSH
37758: EMPTY
37759: LIST
37760: LIST
37761: PUSH
37762: LD_INT 0
37764: PUSH
37765: LD_INT 1
37767: PUSH
37768: EMPTY
37769: LIST
37770: LIST
37771: PUSH
37772: LD_INT 1
37774: NEG
37775: PUSH
37776: LD_INT 0
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: PUSH
37783: LD_INT 1
37785: NEG
37786: PUSH
37787: LD_INT 1
37789: NEG
37790: PUSH
37791: EMPTY
37792: LIST
37793: LIST
37794: PUSH
37795: LD_INT 1
37797: NEG
37798: PUSH
37799: LD_INT 2
37801: NEG
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: LD_INT 1
37809: PUSH
37810: LD_INT 1
37812: NEG
37813: PUSH
37814: EMPTY
37815: LIST
37816: LIST
37817: PUSH
37818: LD_INT 2
37820: PUSH
37821: LD_INT 0
37823: PUSH
37824: EMPTY
37825: LIST
37826: LIST
37827: PUSH
37828: LD_INT 2
37830: PUSH
37831: LD_INT 1
37833: PUSH
37834: EMPTY
37835: LIST
37836: LIST
37837: PUSH
37838: LD_INT 2
37840: PUSH
37841: LD_INT 2
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 1
37850: PUSH
37851: LD_INT 2
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PUSH
37858: LD_INT 1
37860: NEG
37861: PUSH
37862: LD_INT 1
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 2
37871: NEG
37872: PUSH
37873: LD_INT 0
37875: PUSH
37876: EMPTY
37877: LIST
37878: LIST
37879: PUSH
37880: LD_INT 2
37882: NEG
37883: PUSH
37884: LD_INT 1
37886: NEG
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: PUSH
37892: LD_INT 2
37894: NEG
37895: PUSH
37896: LD_INT 2
37898: NEG
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: LD_INT 2
37906: NEG
37907: PUSH
37908: LD_INT 3
37910: NEG
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: PUSH
37916: LD_INT 2
37918: PUSH
37919: LD_INT 1
37921: NEG
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: PUSH
37927: LD_INT 3
37929: PUSH
37930: LD_INT 0
37932: PUSH
37933: EMPTY
37934: LIST
37935: LIST
37936: PUSH
37937: LD_INT 3
37939: PUSH
37940: LD_INT 1
37942: PUSH
37943: EMPTY
37944: LIST
37945: LIST
37946: PUSH
37947: LD_INT 3
37949: PUSH
37950: LD_INT 2
37952: PUSH
37953: EMPTY
37954: LIST
37955: LIST
37956: PUSH
37957: LD_INT 3
37959: PUSH
37960: LD_INT 3
37962: PUSH
37963: EMPTY
37964: LIST
37965: LIST
37966: PUSH
37967: LD_INT 2
37969: PUSH
37970: LD_INT 3
37972: PUSH
37973: EMPTY
37974: LIST
37975: LIST
37976: PUSH
37977: LD_INT 2
37979: NEG
37980: PUSH
37981: LD_INT 1
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: PUSH
37988: LD_INT 3
37990: NEG
37991: PUSH
37992: LD_INT 0
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 3
38001: NEG
38002: PUSH
38003: LD_INT 1
38005: NEG
38006: PUSH
38007: EMPTY
38008: LIST
38009: LIST
38010: PUSH
38011: LD_INT 3
38013: NEG
38014: PUSH
38015: LD_INT 2
38017: NEG
38018: PUSH
38019: EMPTY
38020: LIST
38021: LIST
38022: PUSH
38023: LD_INT 3
38025: NEG
38026: PUSH
38027: LD_INT 3
38029: NEG
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38066: LD_ADDR_VAR 0 45
38070: PUSH
38071: LD_INT 0
38073: PUSH
38074: LD_INT 0
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 0
38083: PUSH
38084: LD_INT 1
38086: NEG
38087: PUSH
38088: EMPTY
38089: LIST
38090: LIST
38091: PUSH
38092: LD_INT 1
38094: PUSH
38095: LD_INT 0
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: LD_INT 1
38104: PUSH
38105: LD_INT 1
38107: PUSH
38108: EMPTY
38109: LIST
38110: LIST
38111: PUSH
38112: LD_INT 0
38114: PUSH
38115: LD_INT 1
38117: PUSH
38118: EMPTY
38119: LIST
38120: LIST
38121: PUSH
38122: LD_INT 1
38124: NEG
38125: PUSH
38126: LD_INT 0
38128: PUSH
38129: EMPTY
38130: LIST
38131: LIST
38132: PUSH
38133: LD_INT 1
38135: NEG
38136: PUSH
38137: LD_INT 1
38139: NEG
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: PUSH
38145: LD_INT 1
38147: NEG
38148: PUSH
38149: LD_INT 2
38151: NEG
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: LD_INT 0
38159: PUSH
38160: LD_INT 2
38162: NEG
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 1
38170: PUSH
38171: LD_INT 1
38173: NEG
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 2
38181: PUSH
38182: LD_INT 1
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PUSH
38189: LD_INT 2
38191: PUSH
38192: LD_INT 2
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 1
38201: PUSH
38202: LD_INT 2
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: PUSH
38209: LD_INT 0
38211: PUSH
38212: LD_INT 2
38214: PUSH
38215: EMPTY
38216: LIST
38217: LIST
38218: PUSH
38219: LD_INT 1
38221: NEG
38222: PUSH
38223: LD_INT 1
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 2
38232: NEG
38233: PUSH
38234: LD_INT 1
38236: NEG
38237: PUSH
38238: EMPTY
38239: LIST
38240: LIST
38241: PUSH
38242: LD_INT 2
38244: NEG
38245: PUSH
38246: LD_INT 2
38248: NEG
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 2
38256: NEG
38257: PUSH
38258: LD_INT 3
38260: NEG
38261: PUSH
38262: EMPTY
38263: LIST
38264: LIST
38265: PUSH
38266: LD_INT 1
38268: NEG
38269: PUSH
38270: LD_INT 3
38272: NEG
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 0
38280: PUSH
38281: LD_INT 3
38283: NEG
38284: PUSH
38285: EMPTY
38286: LIST
38287: LIST
38288: PUSH
38289: LD_INT 1
38291: PUSH
38292: LD_INT 2
38294: NEG
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 3
38302: PUSH
38303: LD_INT 2
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 3
38312: PUSH
38313: LD_INT 3
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: PUSH
38320: LD_INT 2
38322: PUSH
38323: LD_INT 3
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: LD_INT 1
38332: PUSH
38333: LD_INT 3
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 0
38342: PUSH
38343: LD_INT 3
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: LD_INT 1
38352: NEG
38353: PUSH
38354: LD_INT 2
38356: PUSH
38357: EMPTY
38358: LIST
38359: LIST
38360: PUSH
38361: LD_INT 3
38363: NEG
38364: PUSH
38365: LD_INT 2
38367: NEG
38368: PUSH
38369: EMPTY
38370: LIST
38371: LIST
38372: PUSH
38373: LD_INT 3
38375: NEG
38376: PUSH
38377: LD_INT 3
38379: NEG
38380: PUSH
38381: EMPTY
38382: LIST
38383: LIST
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: LIST
38389: LIST
38390: LIST
38391: LIST
38392: LIST
38393: LIST
38394: LIST
38395: LIST
38396: LIST
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: LIST
38408: LIST
38409: LIST
38410: LIST
38411: LIST
38412: LIST
38413: LIST
38414: LIST
38415: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38416: LD_ADDR_VAR 0 46
38420: PUSH
38421: LD_INT 0
38423: PUSH
38424: LD_INT 0
38426: PUSH
38427: EMPTY
38428: LIST
38429: LIST
38430: PUSH
38431: LD_INT 0
38433: PUSH
38434: LD_INT 1
38436: NEG
38437: PUSH
38438: EMPTY
38439: LIST
38440: LIST
38441: PUSH
38442: LD_INT 1
38444: PUSH
38445: LD_INT 0
38447: PUSH
38448: EMPTY
38449: LIST
38450: LIST
38451: PUSH
38452: LD_INT 1
38454: PUSH
38455: LD_INT 1
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: PUSH
38462: LD_INT 0
38464: PUSH
38465: LD_INT 1
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 1
38474: NEG
38475: PUSH
38476: LD_INT 0
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: PUSH
38483: LD_INT 1
38485: NEG
38486: PUSH
38487: LD_INT 1
38489: NEG
38490: PUSH
38491: EMPTY
38492: LIST
38493: LIST
38494: PUSH
38495: LD_INT 1
38497: NEG
38498: PUSH
38499: LD_INT 2
38501: NEG
38502: PUSH
38503: EMPTY
38504: LIST
38505: LIST
38506: PUSH
38507: LD_INT 0
38509: PUSH
38510: LD_INT 2
38512: NEG
38513: PUSH
38514: EMPTY
38515: LIST
38516: LIST
38517: PUSH
38518: LD_INT 1
38520: PUSH
38521: LD_INT 1
38523: NEG
38524: PUSH
38525: EMPTY
38526: LIST
38527: LIST
38528: PUSH
38529: LD_INT 2
38531: PUSH
38532: LD_INT 0
38534: PUSH
38535: EMPTY
38536: LIST
38537: LIST
38538: PUSH
38539: LD_INT 2
38541: PUSH
38542: LD_INT 1
38544: PUSH
38545: EMPTY
38546: LIST
38547: LIST
38548: PUSH
38549: LD_INT 1
38551: PUSH
38552: LD_INT 2
38554: PUSH
38555: EMPTY
38556: LIST
38557: LIST
38558: PUSH
38559: LD_INT 0
38561: PUSH
38562: LD_INT 2
38564: PUSH
38565: EMPTY
38566: LIST
38567: LIST
38568: PUSH
38569: LD_INT 1
38571: NEG
38572: PUSH
38573: LD_INT 1
38575: PUSH
38576: EMPTY
38577: LIST
38578: LIST
38579: PUSH
38580: LD_INT 2
38582: NEG
38583: PUSH
38584: LD_INT 0
38586: PUSH
38587: EMPTY
38588: LIST
38589: LIST
38590: PUSH
38591: LD_INT 2
38593: NEG
38594: PUSH
38595: LD_INT 1
38597: NEG
38598: PUSH
38599: EMPTY
38600: LIST
38601: LIST
38602: PUSH
38603: LD_INT 1
38605: NEG
38606: PUSH
38607: LD_INT 3
38609: NEG
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: LD_INT 0
38617: PUSH
38618: LD_INT 3
38620: NEG
38621: PUSH
38622: EMPTY
38623: LIST
38624: LIST
38625: PUSH
38626: LD_INT 1
38628: PUSH
38629: LD_INT 2
38631: NEG
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 2
38639: PUSH
38640: LD_INT 1
38642: NEG
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 3
38650: PUSH
38651: LD_INT 0
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 3
38660: PUSH
38661: LD_INT 1
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 1
38670: PUSH
38671: LD_INT 3
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 0
38680: PUSH
38681: LD_INT 3
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 1
38690: NEG
38691: PUSH
38692: LD_INT 2
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 2
38701: NEG
38702: PUSH
38703: LD_INT 1
38705: PUSH
38706: EMPTY
38707: LIST
38708: LIST
38709: PUSH
38710: LD_INT 3
38712: NEG
38713: PUSH
38714: LD_INT 0
38716: PUSH
38717: EMPTY
38718: LIST
38719: LIST
38720: PUSH
38721: LD_INT 3
38723: NEG
38724: PUSH
38725: LD_INT 1
38727: NEG
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: LIST
38744: LIST
38745: LIST
38746: LIST
38747: LIST
38748: LIST
38749: LIST
38750: LIST
38751: LIST
38752: LIST
38753: LIST
38754: LIST
38755: LIST
38756: LIST
38757: LIST
38758: LIST
38759: LIST
38760: LIST
38761: LIST
38762: LIST
38763: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38764: LD_ADDR_VAR 0 47
38768: PUSH
38769: LD_INT 0
38771: PUSH
38772: LD_INT 0
38774: PUSH
38775: EMPTY
38776: LIST
38777: LIST
38778: PUSH
38779: LD_INT 0
38781: PUSH
38782: LD_INT 1
38784: NEG
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: PUSH
38790: LD_INT 1
38792: PUSH
38793: LD_INT 0
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: LD_INT 1
38802: PUSH
38803: LD_INT 1
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: PUSH
38810: LD_INT 0
38812: PUSH
38813: LD_INT 1
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PUSH
38820: LD_INT 1
38822: NEG
38823: PUSH
38824: LD_INT 0
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 1
38833: NEG
38834: PUSH
38835: LD_INT 1
38837: NEG
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: PUSH
38843: LD_INT 1
38845: NEG
38846: PUSH
38847: LD_INT 2
38849: NEG
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: LD_INT 0
38857: PUSH
38858: LD_INT 2
38860: NEG
38861: PUSH
38862: EMPTY
38863: LIST
38864: LIST
38865: PUSH
38866: LD_INT 1
38868: PUSH
38869: LD_INT 1
38871: NEG
38872: PUSH
38873: EMPTY
38874: LIST
38875: LIST
38876: PUSH
38877: LD_INT 2
38879: NEG
38880: PUSH
38881: LD_INT 1
38883: NEG
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: LD_INT 2
38891: NEG
38892: PUSH
38893: LD_INT 2
38895: NEG
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: LIST
38905: LIST
38906: LIST
38907: LIST
38908: LIST
38909: LIST
38910: LIST
38911: LIST
38912: LIST
38913: LIST
38914: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38915: LD_ADDR_VAR 0 48
38919: PUSH
38920: LD_INT 0
38922: PUSH
38923: LD_INT 0
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PUSH
38930: LD_INT 0
38932: PUSH
38933: LD_INT 1
38935: NEG
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PUSH
38941: LD_INT 1
38943: PUSH
38944: LD_INT 0
38946: PUSH
38947: EMPTY
38948: LIST
38949: LIST
38950: PUSH
38951: LD_INT 1
38953: PUSH
38954: LD_INT 1
38956: PUSH
38957: EMPTY
38958: LIST
38959: LIST
38960: PUSH
38961: LD_INT 0
38963: PUSH
38964: LD_INT 1
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 1
38973: NEG
38974: PUSH
38975: LD_INT 0
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 1
38984: NEG
38985: PUSH
38986: LD_INT 1
38988: NEG
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: PUSH
38994: LD_INT 1
38996: NEG
38997: PUSH
38998: LD_INT 2
39000: NEG
39001: PUSH
39002: EMPTY
39003: LIST
39004: LIST
39005: PUSH
39006: LD_INT 0
39008: PUSH
39009: LD_INT 2
39011: NEG
39012: PUSH
39013: EMPTY
39014: LIST
39015: LIST
39016: PUSH
39017: LD_INT 1
39019: PUSH
39020: LD_INT 1
39022: NEG
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: PUSH
39028: LD_INT 2
39030: PUSH
39031: LD_INT 0
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 2
39040: PUSH
39041: LD_INT 1
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: LIST
39052: LIST
39053: LIST
39054: LIST
39055: LIST
39056: LIST
39057: LIST
39058: LIST
39059: LIST
39060: LIST
39061: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39062: LD_ADDR_VAR 0 49
39066: PUSH
39067: LD_INT 0
39069: PUSH
39070: LD_INT 0
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PUSH
39077: LD_INT 0
39079: PUSH
39080: LD_INT 1
39082: NEG
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: LD_INT 1
39090: PUSH
39091: LD_INT 0
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 1
39100: PUSH
39101: LD_INT 1
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: PUSH
39108: LD_INT 0
39110: PUSH
39111: LD_INT 1
39113: PUSH
39114: EMPTY
39115: LIST
39116: LIST
39117: PUSH
39118: LD_INT 1
39120: NEG
39121: PUSH
39122: LD_INT 0
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 1
39131: NEG
39132: PUSH
39133: LD_INT 1
39135: NEG
39136: PUSH
39137: EMPTY
39138: LIST
39139: LIST
39140: PUSH
39141: LD_INT 1
39143: PUSH
39144: LD_INT 1
39146: NEG
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: PUSH
39152: LD_INT 2
39154: PUSH
39155: LD_INT 0
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 2
39164: PUSH
39165: LD_INT 1
39167: PUSH
39168: EMPTY
39169: LIST
39170: LIST
39171: PUSH
39172: LD_INT 2
39174: PUSH
39175: LD_INT 2
39177: PUSH
39178: EMPTY
39179: LIST
39180: LIST
39181: PUSH
39182: LD_INT 1
39184: PUSH
39185: LD_INT 2
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: LIST
39196: LIST
39197: LIST
39198: LIST
39199: LIST
39200: LIST
39201: LIST
39202: LIST
39203: LIST
39204: LIST
39205: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39206: LD_ADDR_VAR 0 50
39210: PUSH
39211: LD_INT 0
39213: PUSH
39214: LD_INT 0
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 0
39223: PUSH
39224: LD_INT 1
39226: NEG
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: PUSH
39232: LD_INT 1
39234: PUSH
39235: LD_INT 0
39237: PUSH
39238: EMPTY
39239: LIST
39240: LIST
39241: PUSH
39242: LD_INT 1
39244: PUSH
39245: LD_INT 1
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 0
39254: PUSH
39255: LD_INT 1
39257: PUSH
39258: EMPTY
39259: LIST
39260: LIST
39261: PUSH
39262: LD_INT 1
39264: NEG
39265: PUSH
39266: LD_INT 0
39268: PUSH
39269: EMPTY
39270: LIST
39271: LIST
39272: PUSH
39273: LD_INT 1
39275: NEG
39276: PUSH
39277: LD_INT 1
39279: NEG
39280: PUSH
39281: EMPTY
39282: LIST
39283: LIST
39284: PUSH
39285: LD_INT 2
39287: PUSH
39288: LD_INT 1
39290: PUSH
39291: EMPTY
39292: LIST
39293: LIST
39294: PUSH
39295: LD_INT 2
39297: PUSH
39298: LD_INT 2
39300: PUSH
39301: EMPTY
39302: LIST
39303: LIST
39304: PUSH
39305: LD_INT 1
39307: PUSH
39308: LD_INT 2
39310: PUSH
39311: EMPTY
39312: LIST
39313: LIST
39314: PUSH
39315: LD_INT 0
39317: PUSH
39318: LD_INT 2
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 1
39327: NEG
39328: PUSH
39329: LD_INT 1
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: EMPTY
39337: LIST
39338: LIST
39339: LIST
39340: LIST
39341: LIST
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39350: LD_ADDR_VAR 0 51
39354: PUSH
39355: LD_INT 0
39357: PUSH
39358: LD_INT 0
39360: PUSH
39361: EMPTY
39362: LIST
39363: LIST
39364: PUSH
39365: LD_INT 0
39367: PUSH
39368: LD_INT 1
39370: NEG
39371: PUSH
39372: EMPTY
39373: LIST
39374: LIST
39375: PUSH
39376: LD_INT 1
39378: PUSH
39379: LD_INT 0
39381: PUSH
39382: EMPTY
39383: LIST
39384: LIST
39385: PUSH
39386: LD_INT 1
39388: PUSH
39389: LD_INT 1
39391: PUSH
39392: EMPTY
39393: LIST
39394: LIST
39395: PUSH
39396: LD_INT 0
39398: PUSH
39399: LD_INT 1
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: PUSH
39406: LD_INT 1
39408: NEG
39409: PUSH
39410: LD_INT 0
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 1
39419: NEG
39420: PUSH
39421: LD_INT 1
39423: NEG
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: LD_INT 1
39431: PUSH
39432: LD_INT 2
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PUSH
39439: LD_INT 0
39441: PUSH
39442: LD_INT 2
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 1
39451: NEG
39452: PUSH
39453: LD_INT 1
39455: PUSH
39456: EMPTY
39457: LIST
39458: LIST
39459: PUSH
39460: LD_INT 2
39462: NEG
39463: PUSH
39464: LD_INT 0
39466: PUSH
39467: EMPTY
39468: LIST
39469: LIST
39470: PUSH
39471: LD_INT 2
39473: NEG
39474: PUSH
39475: LD_INT 1
39477: NEG
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: PUSH
39483: EMPTY
39484: LIST
39485: LIST
39486: LIST
39487: LIST
39488: LIST
39489: LIST
39490: LIST
39491: LIST
39492: LIST
39493: LIST
39494: LIST
39495: LIST
39496: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39497: LD_ADDR_VAR 0 52
39501: PUSH
39502: LD_INT 0
39504: PUSH
39505: LD_INT 0
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: LD_INT 0
39514: PUSH
39515: LD_INT 1
39517: NEG
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 1
39525: PUSH
39526: LD_INT 0
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 1
39535: PUSH
39536: LD_INT 1
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 0
39545: PUSH
39546: LD_INT 1
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: LD_INT 1
39555: NEG
39556: PUSH
39557: LD_INT 0
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 1
39566: NEG
39567: PUSH
39568: LD_INT 1
39570: NEG
39571: PUSH
39572: EMPTY
39573: LIST
39574: LIST
39575: PUSH
39576: LD_INT 1
39578: NEG
39579: PUSH
39580: LD_INT 2
39582: NEG
39583: PUSH
39584: EMPTY
39585: LIST
39586: LIST
39587: PUSH
39588: LD_INT 1
39590: NEG
39591: PUSH
39592: LD_INT 1
39594: PUSH
39595: EMPTY
39596: LIST
39597: LIST
39598: PUSH
39599: LD_INT 2
39601: NEG
39602: PUSH
39603: LD_INT 0
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: PUSH
39610: LD_INT 2
39612: NEG
39613: PUSH
39614: LD_INT 1
39616: NEG
39617: PUSH
39618: EMPTY
39619: LIST
39620: LIST
39621: PUSH
39622: LD_INT 2
39624: NEG
39625: PUSH
39626: LD_INT 2
39628: NEG
39629: PUSH
39630: EMPTY
39631: LIST
39632: LIST
39633: PUSH
39634: EMPTY
39635: LIST
39636: LIST
39637: LIST
39638: LIST
39639: LIST
39640: LIST
39641: LIST
39642: LIST
39643: LIST
39644: LIST
39645: LIST
39646: LIST
39647: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39648: LD_ADDR_VAR 0 53
39652: PUSH
39653: LD_INT 0
39655: PUSH
39656: LD_INT 0
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 0
39665: PUSH
39666: LD_INT 1
39668: NEG
39669: PUSH
39670: EMPTY
39671: LIST
39672: LIST
39673: PUSH
39674: LD_INT 1
39676: PUSH
39677: LD_INT 0
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 1
39686: PUSH
39687: LD_INT 1
39689: PUSH
39690: EMPTY
39691: LIST
39692: LIST
39693: PUSH
39694: LD_INT 0
39696: PUSH
39697: LD_INT 1
39699: PUSH
39700: EMPTY
39701: LIST
39702: LIST
39703: PUSH
39704: LD_INT 1
39706: NEG
39707: PUSH
39708: LD_INT 0
39710: PUSH
39711: EMPTY
39712: LIST
39713: LIST
39714: PUSH
39715: LD_INT 1
39717: NEG
39718: PUSH
39719: LD_INT 1
39721: NEG
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PUSH
39727: LD_INT 1
39729: NEG
39730: PUSH
39731: LD_INT 2
39733: NEG
39734: PUSH
39735: EMPTY
39736: LIST
39737: LIST
39738: PUSH
39739: LD_INT 0
39741: PUSH
39742: LD_INT 2
39744: NEG
39745: PUSH
39746: EMPTY
39747: LIST
39748: LIST
39749: PUSH
39750: LD_INT 1
39752: PUSH
39753: LD_INT 1
39755: NEG
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: PUSH
39761: LD_INT 2
39763: PUSH
39764: LD_INT 0
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: PUSH
39771: LD_INT 2
39773: PUSH
39774: LD_INT 1
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: PUSH
39781: LD_INT 2
39783: PUSH
39784: LD_INT 2
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 1
39793: PUSH
39794: LD_INT 2
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 0
39803: PUSH
39804: LD_INT 2
39806: PUSH
39807: EMPTY
39808: LIST
39809: LIST
39810: PUSH
39811: LD_INT 1
39813: NEG
39814: PUSH
39815: LD_INT 1
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: LD_INT 2
39824: NEG
39825: PUSH
39826: LD_INT 0
39828: PUSH
39829: EMPTY
39830: LIST
39831: LIST
39832: PUSH
39833: LD_INT 2
39835: NEG
39836: PUSH
39837: LD_INT 1
39839: NEG
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 2
39847: NEG
39848: PUSH
39849: LD_INT 2
39851: NEG
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: EMPTY
39858: LIST
39859: LIST
39860: LIST
39861: LIST
39862: LIST
39863: LIST
39864: LIST
39865: LIST
39866: LIST
39867: LIST
39868: LIST
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39878: LD_ADDR_VAR 0 54
39882: PUSH
39883: LD_INT 0
39885: PUSH
39886: LD_INT 0
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: LD_INT 0
39895: PUSH
39896: LD_INT 1
39898: NEG
39899: PUSH
39900: EMPTY
39901: LIST
39902: LIST
39903: PUSH
39904: LD_INT 1
39906: PUSH
39907: LD_INT 0
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 1
39916: PUSH
39917: LD_INT 1
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: PUSH
39924: LD_INT 0
39926: PUSH
39927: LD_INT 1
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: PUSH
39934: LD_INT 1
39936: NEG
39937: PUSH
39938: LD_INT 0
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: PUSH
39945: LD_INT 1
39947: NEG
39948: PUSH
39949: LD_INT 1
39951: NEG
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: LD_INT 1
39959: NEG
39960: PUSH
39961: LD_INT 2
39963: NEG
39964: PUSH
39965: EMPTY
39966: LIST
39967: LIST
39968: PUSH
39969: LD_INT 0
39971: PUSH
39972: LD_INT 2
39974: NEG
39975: PUSH
39976: EMPTY
39977: LIST
39978: LIST
39979: PUSH
39980: LD_INT 1
39982: PUSH
39983: LD_INT 1
39985: NEG
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 2
39993: PUSH
39994: LD_INT 0
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: LD_INT 2
40003: PUSH
40004: LD_INT 1
40006: PUSH
40007: EMPTY
40008: LIST
40009: LIST
40010: PUSH
40011: LD_INT 2
40013: PUSH
40014: LD_INT 2
40016: PUSH
40017: EMPTY
40018: LIST
40019: LIST
40020: PUSH
40021: LD_INT 1
40023: PUSH
40024: LD_INT 2
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 0
40033: PUSH
40034: LD_INT 2
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: LD_INT 1
40043: NEG
40044: PUSH
40045: LD_INT 1
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 2
40054: NEG
40055: PUSH
40056: LD_INT 0
40058: PUSH
40059: EMPTY
40060: LIST
40061: LIST
40062: PUSH
40063: LD_INT 2
40065: NEG
40066: PUSH
40067: LD_INT 1
40069: NEG
40070: PUSH
40071: EMPTY
40072: LIST
40073: LIST
40074: PUSH
40075: LD_INT 2
40077: NEG
40078: PUSH
40079: LD_INT 2
40081: NEG
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: LIST
40091: LIST
40092: LIST
40093: LIST
40094: LIST
40095: LIST
40096: LIST
40097: LIST
40098: LIST
40099: LIST
40100: LIST
40101: LIST
40102: LIST
40103: LIST
40104: LIST
40105: LIST
40106: LIST
40107: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40108: LD_ADDR_VAR 0 55
40112: PUSH
40113: LD_INT 0
40115: PUSH
40116: LD_INT 0
40118: PUSH
40119: EMPTY
40120: LIST
40121: LIST
40122: PUSH
40123: LD_INT 0
40125: PUSH
40126: LD_INT 1
40128: NEG
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: PUSH
40134: LD_INT 1
40136: PUSH
40137: LD_INT 0
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 1
40146: PUSH
40147: LD_INT 1
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PUSH
40154: LD_INT 0
40156: PUSH
40157: LD_INT 1
40159: PUSH
40160: EMPTY
40161: LIST
40162: LIST
40163: PUSH
40164: LD_INT 1
40166: NEG
40167: PUSH
40168: LD_INT 0
40170: PUSH
40171: EMPTY
40172: LIST
40173: LIST
40174: PUSH
40175: LD_INT 1
40177: NEG
40178: PUSH
40179: LD_INT 1
40181: NEG
40182: PUSH
40183: EMPTY
40184: LIST
40185: LIST
40186: PUSH
40187: LD_INT 1
40189: NEG
40190: PUSH
40191: LD_INT 2
40193: NEG
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: PUSH
40199: LD_INT 0
40201: PUSH
40202: LD_INT 2
40204: NEG
40205: PUSH
40206: EMPTY
40207: LIST
40208: LIST
40209: PUSH
40210: LD_INT 1
40212: PUSH
40213: LD_INT 1
40215: NEG
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PUSH
40221: LD_INT 2
40223: PUSH
40224: LD_INT 0
40226: PUSH
40227: EMPTY
40228: LIST
40229: LIST
40230: PUSH
40231: LD_INT 2
40233: PUSH
40234: LD_INT 1
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 2
40243: PUSH
40244: LD_INT 2
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: LD_INT 1
40253: PUSH
40254: LD_INT 2
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 0
40263: PUSH
40264: LD_INT 2
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: PUSH
40271: LD_INT 1
40273: NEG
40274: PUSH
40275: LD_INT 1
40277: PUSH
40278: EMPTY
40279: LIST
40280: LIST
40281: PUSH
40282: LD_INT 2
40284: NEG
40285: PUSH
40286: LD_INT 0
40288: PUSH
40289: EMPTY
40290: LIST
40291: LIST
40292: PUSH
40293: LD_INT 2
40295: NEG
40296: PUSH
40297: LD_INT 1
40299: NEG
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: LD_INT 2
40307: NEG
40308: PUSH
40309: LD_INT 2
40311: NEG
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: LIST
40321: LIST
40322: LIST
40323: LIST
40324: LIST
40325: LIST
40326: LIST
40327: LIST
40328: LIST
40329: LIST
40330: LIST
40331: LIST
40332: LIST
40333: LIST
40334: LIST
40335: LIST
40336: LIST
40337: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40338: LD_ADDR_VAR 0 56
40342: PUSH
40343: LD_INT 0
40345: PUSH
40346: LD_INT 0
40348: PUSH
40349: EMPTY
40350: LIST
40351: LIST
40352: PUSH
40353: LD_INT 0
40355: PUSH
40356: LD_INT 1
40358: NEG
40359: PUSH
40360: EMPTY
40361: LIST
40362: LIST
40363: PUSH
40364: LD_INT 1
40366: PUSH
40367: LD_INT 0
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 1
40376: PUSH
40377: LD_INT 1
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PUSH
40384: LD_INT 0
40386: PUSH
40387: LD_INT 1
40389: PUSH
40390: EMPTY
40391: LIST
40392: LIST
40393: PUSH
40394: LD_INT 1
40396: NEG
40397: PUSH
40398: LD_INT 0
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 1
40407: NEG
40408: PUSH
40409: LD_INT 1
40411: NEG
40412: PUSH
40413: EMPTY
40414: LIST
40415: LIST
40416: PUSH
40417: LD_INT 1
40419: NEG
40420: PUSH
40421: LD_INT 2
40423: NEG
40424: PUSH
40425: EMPTY
40426: LIST
40427: LIST
40428: PUSH
40429: LD_INT 0
40431: PUSH
40432: LD_INT 2
40434: NEG
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 1
40442: PUSH
40443: LD_INT 1
40445: NEG
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 2
40453: PUSH
40454: LD_INT 0
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 2
40463: PUSH
40464: LD_INT 1
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 2
40473: PUSH
40474: LD_INT 2
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PUSH
40481: LD_INT 1
40483: PUSH
40484: LD_INT 2
40486: PUSH
40487: EMPTY
40488: LIST
40489: LIST
40490: PUSH
40491: LD_INT 0
40493: PUSH
40494: LD_INT 2
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 1
40503: NEG
40504: PUSH
40505: LD_INT 1
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 2
40514: NEG
40515: PUSH
40516: LD_INT 0
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PUSH
40523: LD_INT 2
40525: NEG
40526: PUSH
40527: LD_INT 1
40529: NEG
40530: PUSH
40531: EMPTY
40532: LIST
40533: LIST
40534: PUSH
40535: LD_INT 2
40537: NEG
40538: PUSH
40539: LD_INT 2
40541: NEG
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: PUSH
40547: EMPTY
40548: LIST
40549: LIST
40550: LIST
40551: LIST
40552: LIST
40553: LIST
40554: LIST
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: LIST
40560: LIST
40561: LIST
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40568: LD_ADDR_VAR 0 57
40572: PUSH
40573: LD_INT 0
40575: PUSH
40576: LD_INT 0
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: PUSH
40583: LD_INT 0
40585: PUSH
40586: LD_INT 1
40588: NEG
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: PUSH
40594: LD_INT 1
40596: PUSH
40597: LD_INT 0
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PUSH
40604: LD_INT 1
40606: PUSH
40607: LD_INT 1
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 0
40616: PUSH
40617: LD_INT 1
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 1
40626: NEG
40627: PUSH
40628: LD_INT 0
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 1
40637: NEG
40638: PUSH
40639: LD_INT 1
40641: NEG
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: PUSH
40647: LD_INT 1
40649: NEG
40650: PUSH
40651: LD_INT 2
40653: NEG
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 0
40661: PUSH
40662: LD_INT 2
40664: NEG
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: PUSH
40670: LD_INT 1
40672: PUSH
40673: LD_INT 1
40675: NEG
40676: PUSH
40677: EMPTY
40678: LIST
40679: LIST
40680: PUSH
40681: LD_INT 2
40683: PUSH
40684: LD_INT 0
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: LD_INT 2
40693: PUSH
40694: LD_INT 1
40696: PUSH
40697: EMPTY
40698: LIST
40699: LIST
40700: PUSH
40701: LD_INT 2
40703: PUSH
40704: LD_INT 2
40706: PUSH
40707: EMPTY
40708: LIST
40709: LIST
40710: PUSH
40711: LD_INT 1
40713: PUSH
40714: LD_INT 2
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: PUSH
40721: LD_INT 0
40723: PUSH
40724: LD_INT 2
40726: PUSH
40727: EMPTY
40728: LIST
40729: LIST
40730: PUSH
40731: LD_INT 1
40733: NEG
40734: PUSH
40735: LD_INT 1
40737: PUSH
40738: EMPTY
40739: LIST
40740: LIST
40741: PUSH
40742: LD_INT 2
40744: NEG
40745: PUSH
40746: LD_INT 0
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: PUSH
40753: LD_INT 2
40755: NEG
40756: PUSH
40757: LD_INT 1
40759: NEG
40760: PUSH
40761: EMPTY
40762: LIST
40763: LIST
40764: PUSH
40765: LD_INT 2
40767: NEG
40768: PUSH
40769: LD_INT 2
40771: NEG
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: PUSH
40777: EMPTY
40778: LIST
40779: LIST
40780: LIST
40781: LIST
40782: LIST
40783: LIST
40784: LIST
40785: LIST
40786: LIST
40787: LIST
40788: LIST
40789: LIST
40790: LIST
40791: LIST
40792: LIST
40793: LIST
40794: LIST
40795: LIST
40796: LIST
40797: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40798: LD_ADDR_VAR 0 58
40802: PUSH
40803: LD_INT 0
40805: PUSH
40806: LD_INT 0
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: LD_INT 0
40815: PUSH
40816: LD_INT 1
40818: NEG
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: PUSH
40824: LD_INT 1
40826: PUSH
40827: LD_INT 0
40829: PUSH
40830: EMPTY
40831: LIST
40832: LIST
40833: PUSH
40834: LD_INT 1
40836: PUSH
40837: LD_INT 1
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: LD_INT 0
40846: PUSH
40847: LD_INT 1
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PUSH
40854: LD_INT 1
40856: NEG
40857: PUSH
40858: LD_INT 0
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: PUSH
40865: LD_INT 1
40867: NEG
40868: PUSH
40869: LD_INT 1
40871: NEG
40872: PUSH
40873: EMPTY
40874: LIST
40875: LIST
40876: PUSH
40877: LD_INT 1
40879: NEG
40880: PUSH
40881: LD_INT 2
40883: NEG
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 0
40891: PUSH
40892: LD_INT 2
40894: NEG
40895: PUSH
40896: EMPTY
40897: LIST
40898: LIST
40899: PUSH
40900: LD_INT 1
40902: PUSH
40903: LD_INT 1
40905: NEG
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: PUSH
40911: LD_INT 2
40913: PUSH
40914: LD_INT 0
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: LD_INT 2
40923: PUSH
40924: LD_INT 1
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: LD_INT 2
40933: PUSH
40934: LD_INT 2
40936: PUSH
40937: EMPTY
40938: LIST
40939: LIST
40940: PUSH
40941: LD_INT 1
40943: PUSH
40944: LD_INT 2
40946: PUSH
40947: EMPTY
40948: LIST
40949: LIST
40950: PUSH
40951: LD_INT 0
40953: PUSH
40954: LD_INT 2
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 1
40963: NEG
40964: PUSH
40965: LD_INT 1
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 2
40974: NEG
40975: PUSH
40976: LD_INT 0
40978: PUSH
40979: EMPTY
40980: LIST
40981: LIST
40982: PUSH
40983: LD_INT 2
40985: NEG
40986: PUSH
40987: LD_INT 1
40989: NEG
40990: PUSH
40991: EMPTY
40992: LIST
40993: LIST
40994: PUSH
40995: LD_INT 2
40997: NEG
40998: PUSH
40999: LD_INT 2
41001: NEG
41002: PUSH
41003: EMPTY
41004: LIST
41005: LIST
41006: PUSH
41007: EMPTY
41008: LIST
41009: LIST
41010: LIST
41011: LIST
41012: LIST
41013: LIST
41014: LIST
41015: LIST
41016: LIST
41017: LIST
41018: LIST
41019: LIST
41020: LIST
41021: LIST
41022: LIST
41023: LIST
41024: LIST
41025: LIST
41026: LIST
41027: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41028: LD_ADDR_VAR 0 59
41032: PUSH
41033: LD_INT 0
41035: PUSH
41036: LD_INT 0
41038: PUSH
41039: EMPTY
41040: LIST
41041: LIST
41042: PUSH
41043: LD_INT 0
41045: PUSH
41046: LD_INT 1
41048: NEG
41049: PUSH
41050: EMPTY
41051: LIST
41052: LIST
41053: PUSH
41054: LD_INT 1
41056: PUSH
41057: LD_INT 0
41059: PUSH
41060: EMPTY
41061: LIST
41062: LIST
41063: PUSH
41064: LD_INT 1
41066: PUSH
41067: LD_INT 1
41069: PUSH
41070: EMPTY
41071: LIST
41072: LIST
41073: PUSH
41074: LD_INT 0
41076: PUSH
41077: LD_INT 1
41079: PUSH
41080: EMPTY
41081: LIST
41082: LIST
41083: PUSH
41084: LD_INT 1
41086: NEG
41087: PUSH
41088: LD_INT 0
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: PUSH
41095: LD_INT 1
41097: NEG
41098: PUSH
41099: LD_INT 1
41101: NEG
41102: PUSH
41103: EMPTY
41104: LIST
41105: LIST
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: LIST
41111: LIST
41112: LIST
41113: LIST
41114: LIST
41115: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41116: LD_ADDR_VAR 0 60
41120: PUSH
41121: LD_INT 0
41123: PUSH
41124: LD_INT 0
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 0
41133: PUSH
41134: LD_INT 1
41136: NEG
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 1
41144: PUSH
41145: LD_INT 0
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 1
41154: PUSH
41155: LD_INT 1
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 0
41164: PUSH
41165: LD_INT 1
41167: PUSH
41168: EMPTY
41169: LIST
41170: LIST
41171: PUSH
41172: LD_INT 1
41174: NEG
41175: PUSH
41176: LD_INT 0
41178: PUSH
41179: EMPTY
41180: LIST
41181: LIST
41182: PUSH
41183: LD_INT 1
41185: NEG
41186: PUSH
41187: LD_INT 1
41189: NEG
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: PUSH
41195: EMPTY
41196: LIST
41197: LIST
41198: LIST
41199: LIST
41200: LIST
41201: LIST
41202: LIST
41203: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41204: LD_ADDR_VAR 0 61
41208: PUSH
41209: LD_INT 0
41211: PUSH
41212: LD_INT 0
41214: PUSH
41215: EMPTY
41216: LIST
41217: LIST
41218: PUSH
41219: LD_INT 0
41221: PUSH
41222: LD_INT 1
41224: NEG
41225: PUSH
41226: EMPTY
41227: LIST
41228: LIST
41229: PUSH
41230: LD_INT 1
41232: PUSH
41233: LD_INT 0
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: LD_INT 1
41242: PUSH
41243: LD_INT 1
41245: PUSH
41246: EMPTY
41247: LIST
41248: LIST
41249: PUSH
41250: LD_INT 0
41252: PUSH
41253: LD_INT 1
41255: PUSH
41256: EMPTY
41257: LIST
41258: LIST
41259: PUSH
41260: LD_INT 1
41262: NEG
41263: PUSH
41264: LD_INT 0
41266: PUSH
41267: EMPTY
41268: LIST
41269: LIST
41270: PUSH
41271: LD_INT 1
41273: NEG
41274: PUSH
41275: LD_INT 1
41277: NEG
41278: PUSH
41279: EMPTY
41280: LIST
41281: LIST
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: LIST
41287: LIST
41288: LIST
41289: LIST
41290: LIST
41291: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41292: LD_ADDR_VAR 0 62
41296: PUSH
41297: LD_INT 0
41299: PUSH
41300: LD_INT 0
41302: PUSH
41303: EMPTY
41304: LIST
41305: LIST
41306: PUSH
41307: LD_INT 0
41309: PUSH
41310: LD_INT 1
41312: NEG
41313: PUSH
41314: EMPTY
41315: LIST
41316: LIST
41317: PUSH
41318: LD_INT 1
41320: PUSH
41321: LD_INT 0
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: PUSH
41328: LD_INT 1
41330: PUSH
41331: LD_INT 1
41333: PUSH
41334: EMPTY
41335: LIST
41336: LIST
41337: PUSH
41338: LD_INT 0
41340: PUSH
41341: LD_INT 1
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: LD_INT 1
41350: NEG
41351: PUSH
41352: LD_INT 0
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 1
41361: NEG
41362: PUSH
41363: LD_INT 1
41365: NEG
41366: PUSH
41367: EMPTY
41368: LIST
41369: LIST
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: LIST
41375: LIST
41376: LIST
41377: LIST
41378: LIST
41379: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41380: LD_ADDR_VAR 0 63
41384: PUSH
41385: LD_INT 0
41387: PUSH
41388: LD_INT 0
41390: PUSH
41391: EMPTY
41392: LIST
41393: LIST
41394: PUSH
41395: LD_INT 0
41397: PUSH
41398: LD_INT 1
41400: NEG
41401: PUSH
41402: EMPTY
41403: LIST
41404: LIST
41405: PUSH
41406: LD_INT 1
41408: PUSH
41409: LD_INT 0
41411: PUSH
41412: EMPTY
41413: LIST
41414: LIST
41415: PUSH
41416: LD_INT 1
41418: PUSH
41419: LD_INT 1
41421: PUSH
41422: EMPTY
41423: LIST
41424: LIST
41425: PUSH
41426: LD_INT 0
41428: PUSH
41429: LD_INT 1
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: PUSH
41436: LD_INT 1
41438: NEG
41439: PUSH
41440: LD_INT 0
41442: PUSH
41443: EMPTY
41444: LIST
41445: LIST
41446: PUSH
41447: LD_INT 1
41449: NEG
41450: PUSH
41451: LD_INT 1
41453: NEG
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: PUSH
41459: EMPTY
41460: LIST
41461: LIST
41462: LIST
41463: LIST
41464: LIST
41465: LIST
41466: LIST
41467: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41468: LD_ADDR_VAR 0 64
41472: PUSH
41473: LD_INT 0
41475: PUSH
41476: LD_INT 0
41478: PUSH
41479: EMPTY
41480: LIST
41481: LIST
41482: PUSH
41483: LD_INT 0
41485: PUSH
41486: LD_INT 1
41488: NEG
41489: PUSH
41490: EMPTY
41491: LIST
41492: LIST
41493: PUSH
41494: LD_INT 1
41496: PUSH
41497: LD_INT 0
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 1
41506: PUSH
41507: LD_INT 1
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: PUSH
41514: LD_INT 0
41516: PUSH
41517: LD_INT 1
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: PUSH
41524: LD_INT 1
41526: NEG
41527: PUSH
41528: LD_INT 0
41530: PUSH
41531: EMPTY
41532: LIST
41533: LIST
41534: PUSH
41535: LD_INT 1
41537: NEG
41538: PUSH
41539: LD_INT 1
41541: NEG
41542: PUSH
41543: EMPTY
41544: LIST
41545: LIST
41546: PUSH
41547: EMPTY
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: LIST
41554: LIST
41555: ST_TO_ADDR
// end ; 1 :
41556: GO 47453
41558: LD_INT 1
41560: DOUBLE
41561: EQUAL
41562: IFTRUE 41566
41564: GO 44189
41566: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41567: LD_ADDR_VAR 0 11
41571: PUSH
41572: LD_INT 1
41574: NEG
41575: PUSH
41576: LD_INT 3
41578: NEG
41579: PUSH
41580: EMPTY
41581: LIST
41582: LIST
41583: PUSH
41584: LD_INT 0
41586: PUSH
41587: LD_INT 3
41589: NEG
41590: PUSH
41591: EMPTY
41592: LIST
41593: LIST
41594: PUSH
41595: LD_INT 1
41597: PUSH
41598: LD_INT 2
41600: NEG
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: LIST
41610: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41611: LD_ADDR_VAR 0 12
41615: PUSH
41616: LD_INT 2
41618: PUSH
41619: LD_INT 1
41621: NEG
41622: PUSH
41623: EMPTY
41624: LIST
41625: LIST
41626: PUSH
41627: LD_INT 3
41629: PUSH
41630: LD_INT 0
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: PUSH
41637: LD_INT 3
41639: PUSH
41640: LD_INT 1
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: LIST
41651: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41652: LD_ADDR_VAR 0 13
41656: PUSH
41657: LD_INT 3
41659: PUSH
41660: LD_INT 2
41662: PUSH
41663: EMPTY
41664: LIST
41665: LIST
41666: PUSH
41667: LD_INT 3
41669: PUSH
41670: LD_INT 3
41672: PUSH
41673: EMPTY
41674: LIST
41675: LIST
41676: PUSH
41677: LD_INT 2
41679: PUSH
41680: LD_INT 3
41682: PUSH
41683: EMPTY
41684: LIST
41685: LIST
41686: PUSH
41687: EMPTY
41688: LIST
41689: LIST
41690: LIST
41691: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41692: LD_ADDR_VAR 0 14
41696: PUSH
41697: LD_INT 1
41699: PUSH
41700: LD_INT 3
41702: PUSH
41703: EMPTY
41704: LIST
41705: LIST
41706: PUSH
41707: LD_INT 0
41709: PUSH
41710: LD_INT 3
41712: PUSH
41713: EMPTY
41714: LIST
41715: LIST
41716: PUSH
41717: LD_INT 1
41719: NEG
41720: PUSH
41721: LD_INT 2
41723: PUSH
41724: EMPTY
41725: LIST
41726: LIST
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: LIST
41732: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41733: LD_ADDR_VAR 0 15
41737: PUSH
41738: LD_INT 2
41740: NEG
41741: PUSH
41742: LD_INT 1
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: PUSH
41749: LD_INT 3
41751: NEG
41752: PUSH
41753: LD_INT 0
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 3
41762: NEG
41763: PUSH
41764: LD_INT 1
41766: NEG
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: EMPTY
41773: LIST
41774: LIST
41775: LIST
41776: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41777: LD_ADDR_VAR 0 16
41781: PUSH
41782: LD_INT 2
41784: NEG
41785: PUSH
41786: LD_INT 3
41788: NEG
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: LD_INT 3
41796: NEG
41797: PUSH
41798: LD_INT 2
41800: NEG
41801: PUSH
41802: EMPTY
41803: LIST
41804: LIST
41805: PUSH
41806: LD_INT 3
41808: NEG
41809: PUSH
41810: LD_INT 3
41812: NEG
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: LIST
41822: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41823: LD_ADDR_VAR 0 17
41827: PUSH
41828: LD_INT 1
41830: NEG
41831: PUSH
41832: LD_INT 3
41834: NEG
41835: PUSH
41836: EMPTY
41837: LIST
41838: LIST
41839: PUSH
41840: LD_INT 0
41842: PUSH
41843: LD_INT 3
41845: NEG
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PUSH
41851: LD_INT 1
41853: PUSH
41854: LD_INT 2
41856: NEG
41857: PUSH
41858: EMPTY
41859: LIST
41860: LIST
41861: PUSH
41862: EMPTY
41863: LIST
41864: LIST
41865: LIST
41866: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41867: LD_ADDR_VAR 0 18
41871: PUSH
41872: LD_INT 2
41874: PUSH
41875: LD_INT 1
41877: NEG
41878: PUSH
41879: EMPTY
41880: LIST
41881: LIST
41882: PUSH
41883: LD_INT 3
41885: PUSH
41886: LD_INT 0
41888: PUSH
41889: EMPTY
41890: LIST
41891: LIST
41892: PUSH
41893: LD_INT 3
41895: PUSH
41896: LD_INT 1
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: LIST
41907: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41908: LD_ADDR_VAR 0 19
41912: PUSH
41913: LD_INT 3
41915: PUSH
41916: LD_INT 2
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: PUSH
41923: LD_INT 3
41925: PUSH
41926: LD_INT 3
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PUSH
41933: LD_INT 2
41935: PUSH
41936: LD_INT 3
41938: PUSH
41939: EMPTY
41940: LIST
41941: LIST
41942: PUSH
41943: EMPTY
41944: LIST
41945: LIST
41946: LIST
41947: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41948: LD_ADDR_VAR 0 20
41952: PUSH
41953: LD_INT 1
41955: PUSH
41956: LD_INT 3
41958: PUSH
41959: EMPTY
41960: LIST
41961: LIST
41962: PUSH
41963: LD_INT 0
41965: PUSH
41966: LD_INT 3
41968: PUSH
41969: EMPTY
41970: LIST
41971: LIST
41972: PUSH
41973: LD_INT 1
41975: NEG
41976: PUSH
41977: LD_INT 2
41979: PUSH
41980: EMPTY
41981: LIST
41982: LIST
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: LIST
41988: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41989: LD_ADDR_VAR 0 21
41993: PUSH
41994: LD_INT 2
41996: NEG
41997: PUSH
41998: LD_INT 1
42000: PUSH
42001: EMPTY
42002: LIST
42003: LIST
42004: PUSH
42005: LD_INT 3
42007: NEG
42008: PUSH
42009: LD_INT 0
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 3
42018: NEG
42019: PUSH
42020: LD_INT 1
42022: NEG
42023: PUSH
42024: EMPTY
42025: LIST
42026: LIST
42027: PUSH
42028: EMPTY
42029: LIST
42030: LIST
42031: LIST
42032: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42033: LD_ADDR_VAR 0 22
42037: PUSH
42038: LD_INT 2
42040: NEG
42041: PUSH
42042: LD_INT 3
42044: NEG
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 3
42052: NEG
42053: PUSH
42054: LD_INT 2
42056: NEG
42057: PUSH
42058: EMPTY
42059: LIST
42060: LIST
42061: PUSH
42062: LD_INT 3
42064: NEG
42065: PUSH
42066: LD_INT 3
42068: NEG
42069: PUSH
42070: EMPTY
42071: LIST
42072: LIST
42073: PUSH
42074: EMPTY
42075: LIST
42076: LIST
42077: LIST
42078: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
42079: LD_ADDR_VAR 0 23
42083: PUSH
42084: LD_INT 0
42086: PUSH
42087: LD_INT 3
42089: NEG
42090: PUSH
42091: EMPTY
42092: LIST
42093: LIST
42094: PUSH
42095: LD_INT 1
42097: NEG
42098: PUSH
42099: LD_INT 4
42101: NEG
42102: PUSH
42103: EMPTY
42104: LIST
42105: LIST
42106: PUSH
42107: LD_INT 1
42109: PUSH
42110: LD_INT 3
42112: NEG
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: LIST
42122: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
42123: LD_ADDR_VAR 0 24
42127: PUSH
42128: LD_INT 3
42130: PUSH
42131: LD_INT 0
42133: PUSH
42134: EMPTY
42135: LIST
42136: LIST
42137: PUSH
42138: LD_INT 3
42140: PUSH
42141: LD_INT 1
42143: NEG
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: LD_INT 4
42151: PUSH
42152: LD_INT 1
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: EMPTY
42160: LIST
42161: LIST
42162: LIST
42163: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
42164: LD_ADDR_VAR 0 25
42168: PUSH
42169: LD_INT 3
42171: PUSH
42172: LD_INT 3
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 4
42181: PUSH
42182: LD_INT 3
42184: PUSH
42185: EMPTY
42186: LIST
42187: LIST
42188: PUSH
42189: LD_INT 3
42191: PUSH
42192: LD_INT 4
42194: PUSH
42195: EMPTY
42196: LIST
42197: LIST
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: LIST
42203: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
42204: LD_ADDR_VAR 0 26
42208: PUSH
42209: LD_INT 0
42211: PUSH
42212: LD_INT 3
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: PUSH
42219: LD_INT 1
42221: PUSH
42222: LD_INT 4
42224: PUSH
42225: EMPTY
42226: LIST
42227: LIST
42228: PUSH
42229: LD_INT 1
42231: NEG
42232: PUSH
42233: LD_INT 3
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: LIST
42244: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
42245: LD_ADDR_VAR 0 27
42249: PUSH
42250: LD_INT 3
42252: NEG
42253: PUSH
42254: LD_INT 0
42256: PUSH
42257: EMPTY
42258: LIST
42259: LIST
42260: PUSH
42261: LD_INT 3
42263: NEG
42264: PUSH
42265: LD_INT 1
42267: PUSH
42268: EMPTY
42269: LIST
42270: LIST
42271: PUSH
42272: LD_INT 4
42274: NEG
42275: PUSH
42276: LD_INT 1
42278: NEG
42279: PUSH
42280: EMPTY
42281: LIST
42282: LIST
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: LIST
42288: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
42289: LD_ADDR_VAR 0 28
42293: PUSH
42294: LD_INT 3
42296: NEG
42297: PUSH
42298: LD_INT 3
42300: NEG
42301: PUSH
42302: EMPTY
42303: LIST
42304: LIST
42305: PUSH
42306: LD_INT 3
42308: NEG
42309: PUSH
42310: LD_INT 4
42312: NEG
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PUSH
42318: LD_INT 4
42320: NEG
42321: PUSH
42322: LD_INT 3
42324: NEG
42325: PUSH
42326: EMPTY
42327: LIST
42328: LIST
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: LIST
42334: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
42335: LD_ADDR_VAR 0 29
42339: PUSH
42340: LD_INT 1
42342: NEG
42343: PUSH
42344: LD_INT 3
42346: NEG
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PUSH
42352: LD_INT 0
42354: PUSH
42355: LD_INT 3
42357: NEG
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: PUSH
42363: LD_INT 1
42365: PUSH
42366: LD_INT 2
42368: NEG
42369: PUSH
42370: EMPTY
42371: LIST
42372: LIST
42373: PUSH
42374: LD_INT 1
42376: NEG
42377: PUSH
42378: LD_INT 4
42380: NEG
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: PUSH
42386: LD_INT 0
42388: PUSH
42389: LD_INT 4
42391: NEG
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: LD_INT 1
42399: PUSH
42400: LD_INT 3
42402: NEG
42403: PUSH
42404: EMPTY
42405: LIST
42406: LIST
42407: PUSH
42408: LD_INT 1
42410: NEG
42411: PUSH
42412: LD_INT 5
42414: NEG
42415: PUSH
42416: EMPTY
42417: LIST
42418: LIST
42419: PUSH
42420: LD_INT 0
42422: PUSH
42423: LD_INT 5
42425: NEG
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: LD_INT 1
42433: PUSH
42434: LD_INT 4
42436: NEG
42437: PUSH
42438: EMPTY
42439: LIST
42440: LIST
42441: PUSH
42442: LD_INT 1
42444: NEG
42445: PUSH
42446: LD_INT 6
42448: NEG
42449: PUSH
42450: EMPTY
42451: LIST
42452: LIST
42453: PUSH
42454: LD_INT 0
42456: PUSH
42457: LD_INT 6
42459: NEG
42460: PUSH
42461: EMPTY
42462: LIST
42463: LIST
42464: PUSH
42465: LD_INT 1
42467: PUSH
42468: LD_INT 5
42470: NEG
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: LIST
42480: LIST
42481: LIST
42482: LIST
42483: LIST
42484: LIST
42485: LIST
42486: LIST
42487: LIST
42488: LIST
42489: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
42490: LD_ADDR_VAR 0 30
42494: PUSH
42495: LD_INT 2
42497: PUSH
42498: LD_INT 1
42500: NEG
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: LD_INT 3
42508: PUSH
42509: LD_INT 0
42511: PUSH
42512: EMPTY
42513: LIST
42514: LIST
42515: PUSH
42516: LD_INT 3
42518: PUSH
42519: LD_INT 1
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 3
42528: PUSH
42529: LD_INT 1
42531: NEG
42532: PUSH
42533: EMPTY
42534: LIST
42535: LIST
42536: PUSH
42537: LD_INT 4
42539: PUSH
42540: LD_INT 0
42542: PUSH
42543: EMPTY
42544: LIST
42545: LIST
42546: PUSH
42547: LD_INT 4
42549: PUSH
42550: LD_INT 1
42552: PUSH
42553: EMPTY
42554: LIST
42555: LIST
42556: PUSH
42557: LD_INT 4
42559: PUSH
42560: LD_INT 1
42562: NEG
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: PUSH
42568: LD_INT 5
42570: PUSH
42571: LD_INT 0
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: PUSH
42578: LD_INT 5
42580: PUSH
42581: LD_INT 1
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: PUSH
42588: LD_INT 5
42590: PUSH
42591: LD_INT 1
42593: NEG
42594: PUSH
42595: EMPTY
42596: LIST
42597: LIST
42598: PUSH
42599: LD_INT 6
42601: PUSH
42602: LD_INT 0
42604: PUSH
42605: EMPTY
42606: LIST
42607: LIST
42608: PUSH
42609: LD_INT 6
42611: PUSH
42612: LD_INT 1
42614: PUSH
42615: EMPTY
42616: LIST
42617: LIST
42618: PUSH
42619: EMPTY
42620: LIST
42621: LIST
42622: LIST
42623: LIST
42624: LIST
42625: LIST
42626: LIST
42627: LIST
42628: LIST
42629: LIST
42630: LIST
42631: LIST
42632: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
42633: LD_ADDR_VAR 0 31
42637: PUSH
42638: LD_INT 3
42640: PUSH
42641: LD_INT 2
42643: PUSH
42644: EMPTY
42645: LIST
42646: LIST
42647: PUSH
42648: LD_INT 3
42650: PUSH
42651: LD_INT 3
42653: PUSH
42654: EMPTY
42655: LIST
42656: LIST
42657: PUSH
42658: LD_INT 2
42660: PUSH
42661: LD_INT 3
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: PUSH
42668: LD_INT 4
42670: PUSH
42671: LD_INT 3
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PUSH
42678: LD_INT 4
42680: PUSH
42681: LD_INT 4
42683: PUSH
42684: EMPTY
42685: LIST
42686: LIST
42687: PUSH
42688: LD_INT 3
42690: PUSH
42691: LD_INT 4
42693: PUSH
42694: EMPTY
42695: LIST
42696: LIST
42697: PUSH
42698: LD_INT 5
42700: PUSH
42701: LD_INT 4
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PUSH
42708: LD_INT 5
42710: PUSH
42711: LD_INT 5
42713: PUSH
42714: EMPTY
42715: LIST
42716: LIST
42717: PUSH
42718: LD_INT 4
42720: PUSH
42721: LD_INT 5
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: PUSH
42728: LD_INT 6
42730: PUSH
42731: LD_INT 5
42733: PUSH
42734: EMPTY
42735: LIST
42736: LIST
42737: PUSH
42738: LD_INT 6
42740: PUSH
42741: LD_INT 6
42743: PUSH
42744: EMPTY
42745: LIST
42746: LIST
42747: PUSH
42748: LD_INT 5
42750: PUSH
42751: LD_INT 6
42753: PUSH
42754: EMPTY
42755: LIST
42756: LIST
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: LIST
42762: LIST
42763: LIST
42764: LIST
42765: LIST
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: LIST
42771: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42772: LD_ADDR_VAR 0 32
42776: PUSH
42777: LD_INT 1
42779: PUSH
42780: LD_INT 3
42782: PUSH
42783: EMPTY
42784: LIST
42785: LIST
42786: PUSH
42787: LD_INT 0
42789: PUSH
42790: LD_INT 3
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: PUSH
42797: LD_INT 1
42799: NEG
42800: PUSH
42801: LD_INT 2
42803: PUSH
42804: EMPTY
42805: LIST
42806: LIST
42807: PUSH
42808: LD_INT 1
42810: PUSH
42811: LD_INT 4
42813: PUSH
42814: EMPTY
42815: LIST
42816: LIST
42817: PUSH
42818: LD_INT 0
42820: PUSH
42821: LD_INT 4
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: LD_INT 1
42830: NEG
42831: PUSH
42832: LD_INT 3
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PUSH
42839: LD_INT 1
42841: PUSH
42842: LD_INT 5
42844: PUSH
42845: EMPTY
42846: LIST
42847: LIST
42848: PUSH
42849: LD_INT 0
42851: PUSH
42852: LD_INT 5
42854: PUSH
42855: EMPTY
42856: LIST
42857: LIST
42858: PUSH
42859: LD_INT 1
42861: NEG
42862: PUSH
42863: LD_INT 4
42865: PUSH
42866: EMPTY
42867: LIST
42868: LIST
42869: PUSH
42870: LD_INT 1
42872: PUSH
42873: LD_INT 6
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: LD_INT 0
42882: PUSH
42883: LD_INT 6
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PUSH
42890: LD_INT 1
42892: NEG
42893: PUSH
42894: LD_INT 5
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: EMPTY
42902: LIST
42903: LIST
42904: LIST
42905: LIST
42906: LIST
42907: LIST
42908: LIST
42909: LIST
42910: LIST
42911: LIST
42912: LIST
42913: LIST
42914: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42915: LD_ADDR_VAR 0 33
42919: PUSH
42920: LD_INT 2
42922: NEG
42923: PUSH
42924: LD_INT 1
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: PUSH
42931: LD_INT 3
42933: NEG
42934: PUSH
42935: LD_INT 0
42937: PUSH
42938: EMPTY
42939: LIST
42940: LIST
42941: PUSH
42942: LD_INT 3
42944: NEG
42945: PUSH
42946: LD_INT 1
42948: NEG
42949: PUSH
42950: EMPTY
42951: LIST
42952: LIST
42953: PUSH
42954: LD_INT 3
42956: NEG
42957: PUSH
42958: LD_INT 1
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: LD_INT 4
42967: NEG
42968: PUSH
42969: LD_INT 0
42971: PUSH
42972: EMPTY
42973: LIST
42974: LIST
42975: PUSH
42976: LD_INT 4
42978: NEG
42979: PUSH
42980: LD_INT 1
42982: NEG
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: PUSH
42988: LD_INT 4
42990: NEG
42991: PUSH
42992: LD_INT 1
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: LD_INT 5
43001: NEG
43002: PUSH
43003: LD_INT 0
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: PUSH
43010: LD_INT 5
43012: NEG
43013: PUSH
43014: LD_INT 1
43016: NEG
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: PUSH
43022: LD_INT 5
43024: NEG
43025: PUSH
43026: LD_INT 1
43028: PUSH
43029: EMPTY
43030: LIST
43031: LIST
43032: PUSH
43033: LD_INT 6
43035: NEG
43036: PUSH
43037: LD_INT 0
43039: PUSH
43040: EMPTY
43041: LIST
43042: LIST
43043: PUSH
43044: LD_INT 6
43046: NEG
43047: PUSH
43048: LD_INT 1
43050: NEG
43051: PUSH
43052: EMPTY
43053: LIST
43054: LIST
43055: PUSH
43056: EMPTY
43057: LIST
43058: LIST
43059: LIST
43060: LIST
43061: LIST
43062: LIST
43063: LIST
43064: LIST
43065: LIST
43066: LIST
43067: LIST
43068: LIST
43069: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
43070: LD_ADDR_VAR 0 34
43074: PUSH
43075: LD_INT 2
43077: NEG
43078: PUSH
43079: LD_INT 3
43081: NEG
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: PUSH
43087: LD_INT 3
43089: NEG
43090: PUSH
43091: LD_INT 2
43093: NEG
43094: PUSH
43095: EMPTY
43096: LIST
43097: LIST
43098: PUSH
43099: LD_INT 3
43101: NEG
43102: PUSH
43103: LD_INT 3
43105: NEG
43106: PUSH
43107: EMPTY
43108: LIST
43109: LIST
43110: PUSH
43111: LD_INT 3
43113: NEG
43114: PUSH
43115: LD_INT 4
43117: NEG
43118: PUSH
43119: EMPTY
43120: LIST
43121: LIST
43122: PUSH
43123: LD_INT 4
43125: NEG
43126: PUSH
43127: LD_INT 3
43129: NEG
43130: PUSH
43131: EMPTY
43132: LIST
43133: LIST
43134: PUSH
43135: LD_INT 4
43137: NEG
43138: PUSH
43139: LD_INT 4
43141: NEG
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: LD_INT 4
43149: NEG
43150: PUSH
43151: LD_INT 5
43153: NEG
43154: PUSH
43155: EMPTY
43156: LIST
43157: LIST
43158: PUSH
43159: LD_INT 5
43161: NEG
43162: PUSH
43163: LD_INT 4
43165: NEG
43166: PUSH
43167: EMPTY
43168: LIST
43169: LIST
43170: PUSH
43171: LD_INT 5
43173: NEG
43174: PUSH
43175: LD_INT 5
43177: NEG
43178: PUSH
43179: EMPTY
43180: LIST
43181: LIST
43182: PUSH
43183: LD_INT 5
43185: NEG
43186: PUSH
43187: LD_INT 6
43189: NEG
43190: PUSH
43191: EMPTY
43192: LIST
43193: LIST
43194: PUSH
43195: LD_INT 6
43197: NEG
43198: PUSH
43199: LD_INT 5
43201: NEG
43202: PUSH
43203: EMPTY
43204: LIST
43205: LIST
43206: PUSH
43207: LD_INT 6
43209: NEG
43210: PUSH
43211: LD_INT 6
43213: NEG
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PUSH
43219: EMPTY
43220: LIST
43221: LIST
43222: LIST
43223: LIST
43224: LIST
43225: LIST
43226: LIST
43227: LIST
43228: LIST
43229: LIST
43230: LIST
43231: LIST
43232: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
43233: LD_ADDR_VAR 0 41
43237: PUSH
43238: LD_INT 0
43240: PUSH
43241: LD_INT 2
43243: NEG
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: PUSH
43249: LD_INT 1
43251: NEG
43252: PUSH
43253: LD_INT 3
43255: NEG
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: PUSH
43261: LD_INT 1
43263: PUSH
43264: LD_INT 2
43266: NEG
43267: PUSH
43268: EMPTY
43269: LIST
43270: LIST
43271: PUSH
43272: EMPTY
43273: LIST
43274: LIST
43275: LIST
43276: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
43277: LD_ADDR_VAR 0 42
43281: PUSH
43282: LD_INT 2
43284: PUSH
43285: LD_INT 0
43287: PUSH
43288: EMPTY
43289: LIST
43290: LIST
43291: PUSH
43292: LD_INT 2
43294: PUSH
43295: LD_INT 1
43297: NEG
43298: PUSH
43299: EMPTY
43300: LIST
43301: LIST
43302: PUSH
43303: LD_INT 3
43305: PUSH
43306: LD_INT 1
43308: PUSH
43309: EMPTY
43310: LIST
43311: LIST
43312: PUSH
43313: EMPTY
43314: LIST
43315: LIST
43316: LIST
43317: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
43318: LD_ADDR_VAR 0 43
43322: PUSH
43323: LD_INT 2
43325: PUSH
43326: LD_INT 2
43328: PUSH
43329: EMPTY
43330: LIST
43331: LIST
43332: PUSH
43333: LD_INT 3
43335: PUSH
43336: LD_INT 2
43338: PUSH
43339: EMPTY
43340: LIST
43341: LIST
43342: PUSH
43343: LD_INT 2
43345: PUSH
43346: LD_INT 3
43348: PUSH
43349: EMPTY
43350: LIST
43351: LIST
43352: PUSH
43353: EMPTY
43354: LIST
43355: LIST
43356: LIST
43357: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
43358: LD_ADDR_VAR 0 44
43362: PUSH
43363: LD_INT 0
43365: PUSH
43366: LD_INT 2
43368: PUSH
43369: EMPTY
43370: LIST
43371: LIST
43372: PUSH
43373: LD_INT 1
43375: PUSH
43376: LD_INT 3
43378: PUSH
43379: EMPTY
43380: LIST
43381: LIST
43382: PUSH
43383: LD_INT 1
43385: NEG
43386: PUSH
43387: LD_INT 2
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: LIST
43398: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
43399: LD_ADDR_VAR 0 45
43403: PUSH
43404: LD_INT 2
43406: NEG
43407: PUSH
43408: LD_INT 0
43410: PUSH
43411: EMPTY
43412: LIST
43413: LIST
43414: PUSH
43415: LD_INT 2
43417: NEG
43418: PUSH
43419: LD_INT 1
43421: PUSH
43422: EMPTY
43423: LIST
43424: LIST
43425: PUSH
43426: LD_INT 3
43428: NEG
43429: PUSH
43430: LD_INT 1
43432: NEG
43433: PUSH
43434: EMPTY
43435: LIST
43436: LIST
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: LIST
43442: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
43443: LD_ADDR_VAR 0 46
43447: PUSH
43448: LD_INT 2
43450: NEG
43451: PUSH
43452: LD_INT 2
43454: NEG
43455: PUSH
43456: EMPTY
43457: LIST
43458: LIST
43459: PUSH
43460: LD_INT 2
43462: NEG
43463: PUSH
43464: LD_INT 3
43466: NEG
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 3
43474: NEG
43475: PUSH
43476: LD_INT 2
43478: NEG
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: EMPTY
43485: LIST
43486: LIST
43487: LIST
43488: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
43489: LD_ADDR_VAR 0 47
43493: PUSH
43494: LD_INT 2
43496: NEG
43497: PUSH
43498: LD_INT 3
43500: NEG
43501: PUSH
43502: EMPTY
43503: LIST
43504: LIST
43505: PUSH
43506: LD_INT 1
43508: NEG
43509: PUSH
43510: LD_INT 3
43512: NEG
43513: PUSH
43514: EMPTY
43515: LIST
43516: LIST
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
43522: LD_ADDR_VAR 0 48
43526: PUSH
43527: LD_INT 1
43529: PUSH
43530: LD_INT 2
43532: NEG
43533: PUSH
43534: EMPTY
43535: LIST
43536: LIST
43537: PUSH
43538: LD_INT 2
43540: PUSH
43541: LD_INT 1
43543: NEG
43544: PUSH
43545: EMPTY
43546: LIST
43547: LIST
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
43553: LD_ADDR_VAR 0 49
43557: PUSH
43558: LD_INT 3
43560: PUSH
43561: LD_INT 1
43563: PUSH
43564: EMPTY
43565: LIST
43566: LIST
43567: PUSH
43568: LD_INT 3
43570: PUSH
43571: LD_INT 2
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
43582: LD_ADDR_VAR 0 50
43586: PUSH
43587: LD_INT 2
43589: PUSH
43590: LD_INT 3
43592: PUSH
43593: EMPTY
43594: LIST
43595: LIST
43596: PUSH
43597: LD_INT 1
43599: PUSH
43600: LD_INT 3
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: EMPTY
43608: LIST
43609: LIST
43610: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
43611: LD_ADDR_VAR 0 51
43615: PUSH
43616: LD_INT 1
43618: NEG
43619: PUSH
43620: LD_INT 2
43622: PUSH
43623: EMPTY
43624: LIST
43625: LIST
43626: PUSH
43627: LD_INT 2
43629: NEG
43630: PUSH
43631: LD_INT 1
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: PUSH
43638: EMPTY
43639: LIST
43640: LIST
43641: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
43642: LD_ADDR_VAR 0 52
43646: PUSH
43647: LD_INT 3
43649: NEG
43650: PUSH
43651: LD_INT 1
43653: NEG
43654: PUSH
43655: EMPTY
43656: LIST
43657: LIST
43658: PUSH
43659: LD_INT 3
43661: NEG
43662: PUSH
43663: LD_INT 2
43665: NEG
43666: PUSH
43667: EMPTY
43668: LIST
43669: LIST
43670: PUSH
43671: EMPTY
43672: LIST
43673: LIST
43674: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43675: LD_ADDR_VAR 0 53
43679: PUSH
43680: LD_INT 1
43682: NEG
43683: PUSH
43684: LD_INT 3
43686: NEG
43687: PUSH
43688: EMPTY
43689: LIST
43690: LIST
43691: PUSH
43692: LD_INT 0
43694: PUSH
43695: LD_INT 3
43697: NEG
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: LD_INT 1
43705: PUSH
43706: LD_INT 2
43708: NEG
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: LIST
43718: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43719: LD_ADDR_VAR 0 54
43723: PUSH
43724: LD_INT 2
43726: PUSH
43727: LD_INT 1
43729: NEG
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PUSH
43735: LD_INT 3
43737: PUSH
43738: LD_INT 0
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: PUSH
43745: LD_INT 3
43747: PUSH
43748: LD_INT 1
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: EMPTY
43756: LIST
43757: LIST
43758: LIST
43759: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43760: LD_ADDR_VAR 0 55
43764: PUSH
43765: LD_INT 3
43767: PUSH
43768: LD_INT 2
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: PUSH
43775: LD_INT 3
43777: PUSH
43778: LD_INT 3
43780: PUSH
43781: EMPTY
43782: LIST
43783: LIST
43784: PUSH
43785: LD_INT 2
43787: PUSH
43788: LD_INT 3
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PUSH
43795: EMPTY
43796: LIST
43797: LIST
43798: LIST
43799: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43800: LD_ADDR_VAR 0 56
43804: PUSH
43805: LD_INT 1
43807: PUSH
43808: LD_INT 3
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: PUSH
43815: LD_INT 0
43817: PUSH
43818: LD_INT 3
43820: PUSH
43821: EMPTY
43822: LIST
43823: LIST
43824: PUSH
43825: LD_INT 1
43827: NEG
43828: PUSH
43829: LD_INT 2
43831: PUSH
43832: EMPTY
43833: LIST
43834: LIST
43835: PUSH
43836: EMPTY
43837: LIST
43838: LIST
43839: LIST
43840: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43841: LD_ADDR_VAR 0 57
43845: PUSH
43846: LD_INT 2
43848: NEG
43849: PUSH
43850: LD_INT 1
43852: PUSH
43853: EMPTY
43854: LIST
43855: LIST
43856: PUSH
43857: LD_INT 3
43859: NEG
43860: PUSH
43861: LD_INT 0
43863: PUSH
43864: EMPTY
43865: LIST
43866: LIST
43867: PUSH
43868: LD_INT 3
43870: NEG
43871: PUSH
43872: LD_INT 1
43874: NEG
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: PUSH
43880: EMPTY
43881: LIST
43882: LIST
43883: LIST
43884: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43885: LD_ADDR_VAR 0 58
43889: PUSH
43890: LD_INT 2
43892: NEG
43893: PUSH
43894: LD_INT 3
43896: NEG
43897: PUSH
43898: EMPTY
43899: LIST
43900: LIST
43901: PUSH
43902: LD_INT 3
43904: NEG
43905: PUSH
43906: LD_INT 2
43908: NEG
43909: PUSH
43910: EMPTY
43911: LIST
43912: LIST
43913: PUSH
43914: LD_INT 3
43916: NEG
43917: PUSH
43918: LD_INT 3
43920: NEG
43921: PUSH
43922: EMPTY
43923: LIST
43924: LIST
43925: PUSH
43926: EMPTY
43927: LIST
43928: LIST
43929: LIST
43930: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43931: LD_ADDR_VAR 0 59
43935: PUSH
43936: LD_INT 1
43938: NEG
43939: PUSH
43940: LD_INT 2
43942: NEG
43943: PUSH
43944: EMPTY
43945: LIST
43946: LIST
43947: PUSH
43948: LD_INT 0
43950: PUSH
43951: LD_INT 2
43953: NEG
43954: PUSH
43955: EMPTY
43956: LIST
43957: LIST
43958: PUSH
43959: LD_INT 1
43961: PUSH
43962: LD_INT 1
43964: NEG
43965: PUSH
43966: EMPTY
43967: LIST
43968: LIST
43969: PUSH
43970: EMPTY
43971: LIST
43972: LIST
43973: LIST
43974: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43975: LD_ADDR_VAR 0 60
43979: PUSH
43980: LD_INT 1
43982: PUSH
43983: LD_INT 1
43985: NEG
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: PUSH
43991: LD_INT 2
43993: PUSH
43994: LD_INT 0
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 2
44003: PUSH
44004: LD_INT 1
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: EMPTY
44012: LIST
44013: LIST
44014: LIST
44015: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
44016: LD_ADDR_VAR 0 61
44020: PUSH
44021: LD_INT 2
44023: PUSH
44024: LD_INT 1
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: LD_INT 2
44033: PUSH
44034: LD_INT 2
44036: PUSH
44037: EMPTY
44038: LIST
44039: LIST
44040: PUSH
44041: LD_INT 1
44043: PUSH
44044: LD_INT 2
44046: PUSH
44047: EMPTY
44048: LIST
44049: LIST
44050: PUSH
44051: EMPTY
44052: LIST
44053: LIST
44054: LIST
44055: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
44056: LD_ADDR_VAR 0 62
44060: PUSH
44061: LD_INT 1
44063: PUSH
44064: LD_INT 2
44066: PUSH
44067: EMPTY
44068: LIST
44069: LIST
44070: PUSH
44071: LD_INT 0
44073: PUSH
44074: LD_INT 2
44076: PUSH
44077: EMPTY
44078: LIST
44079: LIST
44080: PUSH
44081: LD_INT 1
44083: NEG
44084: PUSH
44085: LD_INT 1
44087: PUSH
44088: EMPTY
44089: LIST
44090: LIST
44091: PUSH
44092: EMPTY
44093: LIST
44094: LIST
44095: LIST
44096: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
44097: LD_ADDR_VAR 0 63
44101: PUSH
44102: LD_INT 1
44104: NEG
44105: PUSH
44106: LD_INT 1
44108: PUSH
44109: EMPTY
44110: LIST
44111: LIST
44112: PUSH
44113: LD_INT 2
44115: NEG
44116: PUSH
44117: LD_INT 0
44119: PUSH
44120: EMPTY
44121: LIST
44122: LIST
44123: PUSH
44124: LD_INT 2
44126: NEG
44127: PUSH
44128: LD_INT 1
44130: NEG
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: EMPTY
44137: LIST
44138: LIST
44139: LIST
44140: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44141: LD_ADDR_VAR 0 64
44145: PUSH
44146: LD_INT 1
44148: NEG
44149: PUSH
44150: LD_INT 2
44152: NEG
44153: PUSH
44154: EMPTY
44155: LIST
44156: LIST
44157: PUSH
44158: LD_INT 2
44160: NEG
44161: PUSH
44162: LD_INT 1
44164: NEG
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 2
44172: NEG
44173: PUSH
44174: LD_INT 2
44176: NEG
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: LIST
44186: ST_TO_ADDR
// end ; 2 :
44187: GO 47453
44189: LD_INT 2
44191: DOUBLE
44192: EQUAL
44193: IFTRUE 44197
44195: GO 47452
44197: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
44198: LD_ADDR_VAR 0 29
44202: PUSH
44203: LD_INT 4
44205: PUSH
44206: LD_INT 0
44208: PUSH
44209: EMPTY
44210: LIST
44211: LIST
44212: PUSH
44213: LD_INT 4
44215: PUSH
44216: LD_INT 1
44218: NEG
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: LD_INT 5
44226: PUSH
44227: LD_INT 0
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: PUSH
44234: LD_INT 5
44236: PUSH
44237: LD_INT 1
44239: PUSH
44240: EMPTY
44241: LIST
44242: LIST
44243: PUSH
44244: LD_INT 4
44246: PUSH
44247: LD_INT 1
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 3
44256: PUSH
44257: LD_INT 0
44259: PUSH
44260: EMPTY
44261: LIST
44262: LIST
44263: PUSH
44264: LD_INT 3
44266: PUSH
44267: LD_INT 1
44269: NEG
44270: PUSH
44271: EMPTY
44272: LIST
44273: LIST
44274: PUSH
44275: LD_INT 3
44277: PUSH
44278: LD_INT 2
44280: NEG
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 5
44288: PUSH
44289: LD_INT 2
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PUSH
44296: LD_INT 3
44298: PUSH
44299: LD_INT 3
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PUSH
44306: LD_INT 3
44308: PUSH
44309: LD_INT 2
44311: PUSH
44312: EMPTY
44313: LIST
44314: LIST
44315: PUSH
44316: LD_INT 4
44318: PUSH
44319: LD_INT 3
44321: PUSH
44322: EMPTY
44323: LIST
44324: LIST
44325: PUSH
44326: LD_INT 4
44328: PUSH
44329: LD_INT 4
44331: PUSH
44332: EMPTY
44333: LIST
44334: LIST
44335: PUSH
44336: LD_INT 3
44338: PUSH
44339: LD_INT 4
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: PUSH
44346: LD_INT 2
44348: PUSH
44349: LD_INT 3
44351: PUSH
44352: EMPTY
44353: LIST
44354: LIST
44355: PUSH
44356: LD_INT 2
44358: PUSH
44359: LD_INT 2
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: PUSH
44366: LD_INT 4
44368: PUSH
44369: LD_INT 2
44371: PUSH
44372: EMPTY
44373: LIST
44374: LIST
44375: PUSH
44376: LD_INT 2
44378: PUSH
44379: LD_INT 4
44381: PUSH
44382: EMPTY
44383: LIST
44384: LIST
44385: PUSH
44386: LD_INT 0
44388: PUSH
44389: LD_INT 4
44391: PUSH
44392: EMPTY
44393: LIST
44394: LIST
44395: PUSH
44396: LD_INT 0
44398: PUSH
44399: LD_INT 3
44401: PUSH
44402: EMPTY
44403: LIST
44404: LIST
44405: PUSH
44406: LD_INT 1
44408: PUSH
44409: LD_INT 4
44411: PUSH
44412: EMPTY
44413: LIST
44414: LIST
44415: PUSH
44416: LD_INT 1
44418: PUSH
44419: LD_INT 5
44421: PUSH
44422: EMPTY
44423: LIST
44424: LIST
44425: PUSH
44426: LD_INT 0
44428: PUSH
44429: LD_INT 5
44431: PUSH
44432: EMPTY
44433: LIST
44434: LIST
44435: PUSH
44436: LD_INT 1
44438: NEG
44439: PUSH
44440: LD_INT 4
44442: PUSH
44443: EMPTY
44444: LIST
44445: LIST
44446: PUSH
44447: LD_INT 1
44449: NEG
44450: PUSH
44451: LD_INT 3
44453: PUSH
44454: EMPTY
44455: LIST
44456: LIST
44457: PUSH
44458: LD_INT 2
44460: PUSH
44461: LD_INT 5
44463: PUSH
44464: EMPTY
44465: LIST
44466: LIST
44467: PUSH
44468: LD_INT 2
44470: NEG
44471: PUSH
44472: LD_INT 3
44474: PUSH
44475: EMPTY
44476: LIST
44477: LIST
44478: PUSH
44479: LD_INT 3
44481: NEG
44482: PUSH
44483: LD_INT 0
44485: PUSH
44486: EMPTY
44487: LIST
44488: LIST
44489: PUSH
44490: LD_INT 3
44492: NEG
44493: PUSH
44494: LD_INT 1
44496: NEG
44497: PUSH
44498: EMPTY
44499: LIST
44500: LIST
44501: PUSH
44502: LD_INT 2
44504: NEG
44505: PUSH
44506: LD_INT 0
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: LD_INT 2
44515: NEG
44516: PUSH
44517: LD_INT 1
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: LD_INT 3
44526: NEG
44527: PUSH
44528: LD_INT 1
44530: PUSH
44531: EMPTY
44532: LIST
44533: LIST
44534: PUSH
44535: LD_INT 4
44537: NEG
44538: PUSH
44539: LD_INT 0
44541: PUSH
44542: EMPTY
44543: LIST
44544: LIST
44545: PUSH
44546: LD_INT 4
44548: NEG
44549: PUSH
44550: LD_INT 1
44552: NEG
44553: PUSH
44554: EMPTY
44555: LIST
44556: LIST
44557: PUSH
44558: LD_INT 4
44560: NEG
44561: PUSH
44562: LD_INT 2
44564: NEG
44565: PUSH
44566: EMPTY
44567: LIST
44568: LIST
44569: PUSH
44570: LD_INT 2
44572: NEG
44573: PUSH
44574: LD_INT 2
44576: PUSH
44577: EMPTY
44578: LIST
44579: LIST
44580: PUSH
44581: LD_INT 4
44583: NEG
44584: PUSH
44585: LD_INT 4
44587: NEG
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_INT 4
44595: NEG
44596: PUSH
44597: LD_INT 5
44599: NEG
44600: PUSH
44601: EMPTY
44602: LIST
44603: LIST
44604: PUSH
44605: LD_INT 3
44607: NEG
44608: PUSH
44609: LD_INT 4
44611: NEG
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: PUSH
44617: LD_INT 3
44619: NEG
44620: PUSH
44621: LD_INT 3
44623: NEG
44624: PUSH
44625: EMPTY
44626: LIST
44627: LIST
44628: PUSH
44629: LD_INT 4
44631: NEG
44632: PUSH
44633: LD_INT 3
44635: NEG
44636: PUSH
44637: EMPTY
44638: LIST
44639: LIST
44640: PUSH
44641: LD_INT 5
44643: NEG
44644: PUSH
44645: LD_INT 4
44647: NEG
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: PUSH
44653: LD_INT 5
44655: NEG
44656: PUSH
44657: LD_INT 5
44659: NEG
44660: PUSH
44661: EMPTY
44662: LIST
44663: LIST
44664: PUSH
44665: LD_INT 3
44667: NEG
44668: PUSH
44669: LD_INT 5
44671: NEG
44672: PUSH
44673: EMPTY
44674: LIST
44675: LIST
44676: PUSH
44677: LD_INT 5
44679: NEG
44680: PUSH
44681: LD_INT 3
44683: NEG
44684: PUSH
44685: EMPTY
44686: LIST
44687: LIST
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: LIST
44693: LIST
44694: LIST
44695: LIST
44696: LIST
44697: LIST
44698: LIST
44699: LIST
44700: LIST
44701: LIST
44702: LIST
44703: LIST
44704: LIST
44705: LIST
44706: LIST
44707: LIST
44708: LIST
44709: LIST
44710: LIST
44711: LIST
44712: LIST
44713: LIST
44714: LIST
44715: LIST
44716: LIST
44717: LIST
44718: LIST
44719: LIST
44720: LIST
44721: LIST
44722: LIST
44723: LIST
44724: LIST
44725: LIST
44726: LIST
44727: LIST
44728: LIST
44729: LIST
44730: LIST
44731: LIST
44732: LIST
44733: LIST
44734: LIST
44735: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44736: LD_ADDR_VAR 0 30
44740: PUSH
44741: LD_INT 4
44743: PUSH
44744: LD_INT 4
44746: PUSH
44747: EMPTY
44748: LIST
44749: LIST
44750: PUSH
44751: LD_INT 4
44753: PUSH
44754: LD_INT 3
44756: PUSH
44757: EMPTY
44758: LIST
44759: LIST
44760: PUSH
44761: LD_INT 5
44763: PUSH
44764: LD_INT 4
44766: PUSH
44767: EMPTY
44768: LIST
44769: LIST
44770: PUSH
44771: LD_INT 5
44773: PUSH
44774: LD_INT 5
44776: PUSH
44777: EMPTY
44778: LIST
44779: LIST
44780: PUSH
44781: LD_INT 4
44783: PUSH
44784: LD_INT 5
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: PUSH
44791: LD_INT 3
44793: PUSH
44794: LD_INT 4
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: PUSH
44801: LD_INT 3
44803: PUSH
44804: LD_INT 3
44806: PUSH
44807: EMPTY
44808: LIST
44809: LIST
44810: PUSH
44811: LD_INT 5
44813: PUSH
44814: LD_INT 3
44816: PUSH
44817: EMPTY
44818: LIST
44819: LIST
44820: PUSH
44821: LD_INT 3
44823: PUSH
44824: LD_INT 5
44826: PUSH
44827: EMPTY
44828: LIST
44829: LIST
44830: PUSH
44831: LD_INT 0
44833: PUSH
44834: LD_INT 3
44836: PUSH
44837: EMPTY
44838: LIST
44839: LIST
44840: PUSH
44841: LD_INT 0
44843: PUSH
44844: LD_INT 2
44846: PUSH
44847: EMPTY
44848: LIST
44849: LIST
44850: PUSH
44851: LD_INT 1
44853: PUSH
44854: LD_INT 3
44856: PUSH
44857: EMPTY
44858: LIST
44859: LIST
44860: PUSH
44861: LD_INT 1
44863: PUSH
44864: LD_INT 4
44866: PUSH
44867: EMPTY
44868: LIST
44869: LIST
44870: PUSH
44871: LD_INT 0
44873: PUSH
44874: LD_INT 4
44876: PUSH
44877: EMPTY
44878: LIST
44879: LIST
44880: PUSH
44881: LD_INT 1
44883: NEG
44884: PUSH
44885: LD_INT 3
44887: PUSH
44888: EMPTY
44889: LIST
44890: LIST
44891: PUSH
44892: LD_INT 1
44894: NEG
44895: PUSH
44896: LD_INT 2
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: LD_INT 2
44905: PUSH
44906: LD_INT 4
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: LD_INT 2
44915: NEG
44916: PUSH
44917: LD_INT 2
44919: PUSH
44920: EMPTY
44921: LIST
44922: LIST
44923: PUSH
44924: LD_INT 4
44926: NEG
44927: PUSH
44928: LD_INT 0
44930: PUSH
44931: EMPTY
44932: LIST
44933: LIST
44934: PUSH
44935: LD_INT 4
44937: NEG
44938: PUSH
44939: LD_INT 1
44941: NEG
44942: PUSH
44943: EMPTY
44944: LIST
44945: LIST
44946: PUSH
44947: LD_INT 3
44949: NEG
44950: PUSH
44951: LD_INT 0
44953: PUSH
44954: EMPTY
44955: LIST
44956: LIST
44957: PUSH
44958: LD_INT 3
44960: NEG
44961: PUSH
44962: LD_INT 1
44964: PUSH
44965: EMPTY
44966: LIST
44967: LIST
44968: PUSH
44969: LD_INT 4
44971: NEG
44972: PUSH
44973: LD_INT 1
44975: PUSH
44976: EMPTY
44977: LIST
44978: LIST
44979: PUSH
44980: LD_INT 5
44982: NEG
44983: PUSH
44984: LD_INT 0
44986: PUSH
44987: EMPTY
44988: LIST
44989: LIST
44990: PUSH
44991: LD_INT 5
44993: NEG
44994: PUSH
44995: LD_INT 1
44997: NEG
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: LD_INT 5
45005: NEG
45006: PUSH
45007: LD_INT 2
45009: NEG
45010: PUSH
45011: EMPTY
45012: LIST
45013: LIST
45014: PUSH
45015: LD_INT 3
45017: NEG
45018: PUSH
45019: LD_INT 2
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: LD_INT 3
45028: NEG
45029: PUSH
45030: LD_INT 3
45032: NEG
45033: PUSH
45034: EMPTY
45035: LIST
45036: LIST
45037: PUSH
45038: LD_INT 3
45040: NEG
45041: PUSH
45042: LD_INT 4
45044: NEG
45045: PUSH
45046: EMPTY
45047: LIST
45048: LIST
45049: PUSH
45050: LD_INT 2
45052: NEG
45053: PUSH
45054: LD_INT 3
45056: NEG
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PUSH
45062: LD_INT 2
45064: NEG
45065: PUSH
45066: LD_INT 2
45068: NEG
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PUSH
45074: LD_INT 3
45076: NEG
45077: PUSH
45078: LD_INT 2
45080: NEG
45081: PUSH
45082: EMPTY
45083: LIST
45084: LIST
45085: PUSH
45086: LD_INT 4
45088: NEG
45089: PUSH
45090: LD_INT 3
45092: NEG
45093: PUSH
45094: EMPTY
45095: LIST
45096: LIST
45097: PUSH
45098: LD_INT 4
45100: NEG
45101: PUSH
45102: LD_INT 4
45104: NEG
45105: PUSH
45106: EMPTY
45107: LIST
45108: LIST
45109: PUSH
45110: LD_INT 2
45112: NEG
45113: PUSH
45114: LD_INT 4
45116: NEG
45117: PUSH
45118: EMPTY
45119: LIST
45120: LIST
45121: PUSH
45122: LD_INT 4
45124: NEG
45125: PUSH
45126: LD_INT 2
45128: NEG
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: PUSH
45134: LD_INT 0
45136: PUSH
45137: LD_INT 4
45139: NEG
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 0
45147: PUSH
45148: LD_INT 5
45150: NEG
45151: PUSH
45152: EMPTY
45153: LIST
45154: LIST
45155: PUSH
45156: LD_INT 1
45158: PUSH
45159: LD_INT 4
45161: NEG
45162: PUSH
45163: EMPTY
45164: LIST
45165: LIST
45166: PUSH
45167: LD_INT 1
45169: PUSH
45170: LD_INT 3
45172: NEG
45173: PUSH
45174: EMPTY
45175: LIST
45176: LIST
45177: PUSH
45178: LD_INT 0
45180: PUSH
45181: LD_INT 3
45183: NEG
45184: PUSH
45185: EMPTY
45186: LIST
45187: LIST
45188: PUSH
45189: LD_INT 1
45191: NEG
45192: PUSH
45193: LD_INT 4
45195: NEG
45196: PUSH
45197: EMPTY
45198: LIST
45199: LIST
45200: PUSH
45201: LD_INT 1
45203: NEG
45204: PUSH
45205: LD_INT 5
45207: NEG
45208: PUSH
45209: EMPTY
45210: LIST
45211: LIST
45212: PUSH
45213: LD_INT 2
45215: PUSH
45216: LD_INT 3
45218: NEG
45219: PUSH
45220: EMPTY
45221: LIST
45222: LIST
45223: PUSH
45224: LD_INT 2
45226: NEG
45227: PUSH
45228: LD_INT 5
45230: NEG
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: PUSH
45236: EMPTY
45237: LIST
45238: LIST
45239: LIST
45240: LIST
45241: LIST
45242: LIST
45243: LIST
45244: LIST
45245: LIST
45246: LIST
45247: LIST
45248: LIST
45249: LIST
45250: LIST
45251: LIST
45252: LIST
45253: LIST
45254: LIST
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: LIST
45261: LIST
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: LIST
45271: LIST
45272: LIST
45273: LIST
45274: LIST
45275: LIST
45276: LIST
45277: LIST
45278: LIST
45279: LIST
45280: LIST
45281: LIST
45282: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
45283: LD_ADDR_VAR 0 31
45287: PUSH
45288: LD_INT 0
45290: PUSH
45291: LD_INT 4
45293: PUSH
45294: EMPTY
45295: LIST
45296: LIST
45297: PUSH
45298: LD_INT 0
45300: PUSH
45301: LD_INT 3
45303: PUSH
45304: EMPTY
45305: LIST
45306: LIST
45307: PUSH
45308: LD_INT 1
45310: PUSH
45311: LD_INT 4
45313: PUSH
45314: EMPTY
45315: LIST
45316: LIST
45317: PUSH
45318: LD_INT 1
45320: PUSH
45321: LD_INT 5
45323: PUSH
45324: EMPTY
45325: LIST
45326: LIST
45327: PUSH
45328: LD_INT 0
45330: PUSH
45331: LD_INT 5
45333: PUSH
45334: EMPTY
45335: LIST
45336: LIST
45337: PUSH
45338: LD_INT 1
45340: NEG
45341: PUSH
45342: LD_INT 4
45344: PUSH
45345: EMPTY
45346: LIST
45347: LIST
45348: PUSH
45349: LD_INT 1
45351: NEG
45352: PUSH
45353: LD_INT 3
45355: PUSH
45356: EMPTY
45357: LIST
45358: LIST
45359: PUSH
45360: LD_INT 2
45362: PUSH
45363: LD_INT 5
45365: PUSH
45366: EMPTY
45367: LIST
45368: LIST
45369: PUSH
45370: LD_INT 2
45372: NEG
45373: PUSH
45374: LD_INT 3
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: PUSH
45381: LD_INT 3
45383: NEG
45384: PUSH
45385: LD_INT 0
45387: PUSH
45388: EMPTY
45389: LIST
45390: LIST
45391: PUSH
45392: LD_INT 3
45394: NEG
45395: PUSH
45396: LD_INT 1
45398: NEG
45399: PUSH
45400: EMPTY
45401: LIST
45402: LIST
45403: PUSH
45404: LD_INT 2
45406: NEG
45407: PUSH
45408: LD_INT 0
45410: PUSH
45411: EMPTY
45412: LIST
45413: LIST
45414: PUSH
45415: LD_INT 2
45417: NEG
45418: PUSH
45419: LD_INT 1
45421: PUSH
45422: EMPTY
45423: LIST
45424: LIST
45425: PUSH
45426: LD_INT 3
45428: NEG
45429: PUSH
45430: LD_INT 1
45432: PUSH
45433: EMPTY
45434: LIST
45435: LIST
45436: PUSH
45437: LD_INT 4
45439: NEG
45440: PUSH
45441: LD_INT 0
45443: PUSH
45444: EMPTY
45445: LIST
45446: LIST
45447: PUSH
45448: LD_INT 4
45450: NEG
45451: PUSH
45452: LD_INT 1
45454: NEG
45455: PUSH
45456: EMPTY
45457: LIST
45458: LIST
45459: PUSH
45460: LD_INT 4
45462: NEG
45463: PUSH
45464: LD_INT 2
45466: NEG
45467: PUSH
45468: EMPTY
45469: LIST
45470: LIST
45471: PUSH
45472: LD_INT 2
45474: NEG
45475: PUSH
45476: LD_INT 2
45478: PUSH
45479: EMPTY
45480: LIST
45481: LIST
45482: PUSH
45483: LD_INT 4
45485: NEG
45486: PUSH
45487: LD_INT 4
45489: NEG
45490: PUSH
45491: EMPTY
45492: LIST
45493: LIST
45494: PUSH
45495: LD_INT 4
45497: NEG
45498: PUSH
45499: LD_INT 5
45501: NEG
45502: PUSH
45503: EMPTY
45504: LIST
45505: LIST
45506: PUSH
45507: LD_INT 3
45509: NEG
45510: PUSH
45511: LD_INT 4
45513: NEG
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: PUSH
45519: LD_INT 3
45521: NEG
45522: PUSH
45523: LD_INT 3
45525: NEG
45526: PUSH
45527: EMPTY
45528: LIST
45529: LIST
45530: PUSH
45531: LD_INT 4
45533: NEG
45534: PUSH
45535: LD_INT 3
45537: NEG
45538: PUSH
45539: EMPTY
45540: LIST
45541: LIST
45542: PUSH
45543: LD_INT 5
45545: NEG
45546: PUSH
45547: LD_INT 4
45549: NEG
45550: PUSH
45551: EMPTY
45552: LIST
45553: LIST
45554: PUSH
45555: LD_INT 5
45557: NEG
45558: PUSH
45559: LD_INT 5
45561: NEG
45562: PUSH
45563: EMPTY
45564: LIST
45565: LIST
45566: PUSH
45567: LD_INT 3
45569: NEG
45570: PUSH
45571: LD_INT 5
45573: NEG
45574: PUSH
45575: EMPTY
45576: LIST
45577: LIST
45578: PUSH
45579: LD_INT 5
45581: NEG
45582: PUSH
45583: LD_INT 3
45585: NEG
45586: PUSH
45587: EMPTY
45588: LIST
45589: LIST
45590: PUSH
45591: LD_INT 0
45593: PUSH
45594: LD_INT 3
45596: NEG
45597: PUSH
45598: EMPTY
45599: LIST
45600: LIST
45601: PUSH
45602: LD_INT 0
45604: PUSH
45605: LD_INT 4
45607: NEG
45608: PUSH
45609: EMPTY
45610: LIST
45611: LIST
45612: PUSH
45613: LD_INT 1
45615: PUSH
45616: LD_INT 3
45618: NEG
45619: PUSH
45620: EMPTY
45621: LIST
45622: LIST
45623: PUSH
45624: LD_INT 1
45626: PUSH
45627: LD_INT 2
45629: NEG
45630: PUSH
45631: EMPTY
45632: LIST
45633: LIST
45634: PUSH
45635: LD_INT 0
45637: PUSH
45638: LD_INT 2
45640: NEG
45641: PUSH
45642: EMPTY
45643: LIST
45644: LIST
45645: PUSH
45646: LD_INT 1
45648: NEG
45649: PUSH
45650: LD_INT 3
45652: NEG
45653: PUSH
45654: EMPTY
45655: LIST
45656: LIST
45657: PUSH
45658: LD_INT 1
45660: NEG
45661: PUSH
45662: LD_INT 4
45664: NEG
45665: PUSH
45666: EMPTY
45667: LIST
45668: LIST
45669: PUSH
45670: LD_INT 2
45672: PUSH
45673: LD_INT 2
45675: NEG
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: LD_INT 2
45683: NEG
45684: PUSH
45685: LD_INT 4
45687: NEG
45688: PUSH
45689: EMPTY
45690: LIST
45691: LIST
45692: PUSH
45693: LD_INT 4
45695: PUSH
45696: LD_INT 0
45698: PUSH
45699: EMPTY
45700: LIST
45701: LIST
45702: PUSH
45703: LD_INT 4
45705: PUSH
45706: LD_INT 1
45708: NEG
45709: PUSH
45710: EMPTY
45711: LIST
45712: LIST
45713: PUSH
45714: LD_INT 5
45716: PUSH
45717: LD_INT 0
45719: PUSH
45720: EMPTY
45721: LIST
45722: LIST
45723: PUSH
45724: LD_INT 5
45726: PUSH
45727: LD_INT 1
45729: PUSH
45730: EMPTY
45731: LIST
45732: LIST
45733: PUSH
45734: LD_INT 4
45736: PUSH
45737: LD_INT 1
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: PUSH
45744: LD_INT 3
45746: PUSH
45747: LD_INT 0
45749: PUSH
45750: EMPTY
45751: LIST
45752: LIST
45753: PUSH
45754: LD_INT 3
45756: PUSH
45757: LD_INT 1
45759: NEG
45760: PUSH
45761: EMPTY
45762: LIST
45763: LIST
45764: PUSH
45765: LD_INT 3
45767: PUSH
45768: LD_INT 2
45770: NEG
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: PUSH
45776: LD_INT 5
45778: PUSH
45779: LD_INT 2
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: EMPTY
45787: LIST
45788: LIST
45789: LIST
45790: LIST
45791: LIST
45792: LIST
45793: LIST
45794: LIST
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: LIST
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: LIST
45810: LIST
45811: LIST
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: LIST
45824: LIST
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: LIST
45830: LIST
45831: LIST
45832: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45833: LD_ADDR_VAR 0 32
45837: PUSH
45838: LD_INT 4
45840: NEG
45841: PUSH
45842: LD_INT 0
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: PUSH
45849: LD_INT 4
45851: NEG
45852: PUSH
45853: LD_INT 1
45855: NEG
45856: PUSH
45857: EMPTY
45858: LIST
45859: LIST
45860: PUSH
45861: LD_INT 3
45863: NEG
45864: PUSH
45865: LD_INT 0
45867: PUSH
45868: EMPTY
45869: LIST
45870: LIST
45871: PUSH
45872: LD_INT 3
45874: NEG
45875: PUSH
45876: LD_INT 1
45878: PUSH
45879: EMPTY
45880: LIST
45881: LIST
45882: PUSH
45883: LD_INT 4
45885: NEG
45886: PUSH
45887: LD_INT 1
45889: PUSH
45890: EMPTY
45891: LIST
45892: LIST
45893: PUSH
45894: LD_INT 5
45896: NEG
45897: PUSH
45898: LD_INT 0
45900: PUSH
45901: EMPTY
45902: LIST
45903: LIST
45904: PUSH
45905: LD_INT 5
45907: NEG
45908: PUSH
45909: LD_INT 1
45911: NEG
45912: PUSH
45913: EMPTY
45914: LIST
45915: LIST
45916: PUSH
45917: LD_INT 5
45919: NEG
45920: PUSH
45921: LD_INT 2
45923: NEG
45924: PUSH
45925: EMPTY
45926: LIST
45927: LIST
45928: PUSH
45929: LD_INT 3
45931: NEG
45932: PUSH
45933: LD_INT 2
45935: PUSH
45936: EMPTY
45937: LIST
45938: LIST
45939: PUSH
45940: LD_INT 3
45942: NEG
45943: PUSH
45944: LD_INT 3
45946: NEG
45947: PUSH
45948: EMPTY
45949: LIST
45950: LIST
45951: PUSH
45952: LD_INT 3
45954: NEG
45955: PUSH
45956: LD_INT 4
45958: NEG
45959: PUSH
45960: EMPTY
45961: LIST
45962: LIST
45963: PUSH
45964: LD_INT 2
45966: NEG
45967: PUSH
45968: LD_INT 3
45970: NEG
45971: PUSH
45972: EMPTY
45973: LIST
45974: LIST
45975: PUSH
45976: LD_INT 2
45978: NEG
45979: PUSH
45980: LD_INT 2
45982: NEG
45983: PUSH
45984: EMPTY
45985: LIST
45986: LIST
45987: PUSH
45988: LD_INT 3
45990: NEG
45991: PUSH
45992: LD_INT 2
45994: NEG
45995: PUSH
45996: EMPTY
45997: LIST
45998: LIST
45999: PUSH
46000: LD_INT 4
46002: NEG
46003: PUSH
46004: LD_INT 3
46006: NEG
46007: PUSH
46008: EMPTY
46009: LIST
46010: LIST
46011: PUSH
46012: LD_INT 4
46014: NEG
46015: PUSH
46016: LD_INT 4
46018: NEG
46019: PUSH
46020: EMPTY
46021: LIST
46022: LIST
46023: PUSH
46024: LD_INT 2
46026: NEG
46027: PUSH
46028: LD_INT 4
46030: NEG
46031: PUSH
46032: EMPTY
46033: LIST
46034: LIST
46035: PUSH
46036: LD_INT 4
46038: NEG
46039: PUSH
46040: LD_INT 2
46042: NEG
46043: PUSH
46044: EMPTY
46045: LIST
46046: LIST
46047: PUSH
46048: LD_INT 0
46050: PUSH
46051: LD_INT 4
46053: NEG
46054: PUSH
46055: EMPTY
46056: LIST
46057: LIST
46058: PUSH
46059: LD_INT 0
46061: PUSH
46062: LD_INT 5
46064: NEG
46065: PUSH
46066: EMPTY
46067: LIST
46068: LIST
46069: PUSH
46070: LD_INT 1
46072: PUSH
46073: LD_INT 4
46075: NEG
46076: PUSH
46077: EMPTY
46078: LIST
46079: LIST
46080: PUSH
46081: LD_INT 1
46083: PUSH
46084: LD_INT 3
46086: NEG
46087: PUSH
46088: EMPTY
46089: LIST
46090: LIST
46091: PUSH
46092: LD_INT 0
46094: PUSH
46095: LD_INT 3
46097: NEG
46098: PUSH
46099: EMPTY
46100: LIST
46101: LIST
46102: PUSH
46103: LD_INT 1
46105: NEG
46106: PUSH
46107: LD_INT 4
46109: NEG
46110: PUSH
46111: EMPTY
46112: LIST
46113: LIST
46114: PUSH
46115: LD_INT 1
46117: NEG
46118: PUSH
46119: LD_INT 5
46121: NEG
46122: PUSH
46123: EMPTY
46124: LIST
46125: LIST
46126: PUSH
46127: LD_INT 2
46129: PUSH
46130: LD_INT 3
46132: NEG
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: PUSH
46138: LD_INT 2
46140: NEG
46141: PUSH
46142: LD_INT 5
46144: NEG
46145: PUSH
46146: EMPTY
46147: LIST
46148: LIST
46149: PUSH
46150: LD_INT 3
46152: PUSH
46153: LD_INT 0
46155: PUSH
46156: EMPTY
46157: LIST
46158: LIST
46159: PUSH
46160: LD_INT 3
46162: PUSH
46163: LD_INT 1
46165: NEG
46166: PUSH
46167: EMPTY
46168: LIST
46169: LIST
46170: PUSH
46171: LD_INT 4
46173: PUSH
46174: LD_INT 0
46176: PUSH
46177: EMPTY
46178: LIST
46179: LIST
46180: PUSH
46181: LD_INT 4
46183: PUSH
46184: LD_INT 1
46186: PUSH
46187: EMPTY
46188: LIST
46189: LIST
46190: PUSH
46191: LD_INT 3
46193: PUSH
46194: LD_INT 1
46196: PUSH
46197: EMPTY
46198: LIST
46199: LIST
46200: PUSH
46201: LD_INT 2
46203: PUSH
46204: LD_INT 0
46206: PUSH
46207: EMPTY
46208: LIST
46209: LIST
46210: PUSH
46211: LD_INT 2
46213: PUSH
46214: LD_INT 1
46216: NEG
46217: PUSH
46218: EMPTY
46219: LIST
46220: LIST
46221: PUSH
46222: LD_INT 2
46224: PUSH
46225: LD_INT 2
46227: NEG
46228: PUSH
46229: EMPTY
46230: LIST
46231: LIST
46232: PUSH
46233: LD_INT 4
46235: PUSH
46236: LD_INT 2
46238: PUSH
46239: EMPTY
46240: LIST
46241: LIST
46242: PUSH
46243: LD_INT 4
46245: PUSH
46246: LD_INT 4
46248: PUSH
46249: EMPTY
46250: LIST
46251: LIST
46252: PUSH
46253: LD_INT 4
46255: PUSH
46256: LD_INT 3
46258: PUSH
46259: EMPTY
46260: LIST
46261: LIST
46262: PUSH
46263: LD_INT 5
46265: PUSH
46266: LD_INT 4
46268: PUSH
46269: EMPTY
46270: LIST
46271: LIST
46272: PUSH
46273: LD_INT 5
46275: PUSH
46276: LD_INT 5
46278: PUSH
46279: EMPTY
46280: LIST
46281: LIST
46282: PUSH
46283: LD_INT 4
46285: PUSH
46286: LD_INT 5
46288: PUSH
46289: EMPTY
46290: LIST
46291: LIST
46292: PUSH
46293: LD_INT 3
46295: PUSH
46296: LD_INT 4
46298: PUSH
46299: EMPTY
46300: LIST
46301: LIST
46302: PUSH
46303: LD_INT 3
46305: PUSH
46306: LD_INT 3
46308: PUSH
46309: EMPTY
46310: LIST
46311: LIST
46312: PUSH
46313: LD_INT 5
46315: PUSH
46316: LD_INT 3
46318: PUSH
46319: EMPTY
46320: LIST
46321: LIST
46322: PUSH
46323: LD_INT 3
46325: PUSH
46326: LD_INT 5
46328: PUSH
46329: EMPTY
46330: LIST
46331: LIST
46332: PUSH
46333: EMPTY
46334: LIST
46335: LIST
46336: LIST
46337: LIST
46338: LIST
46339: LIST
46340: LIST
46341: LIST
46342: LIST
46343: LIST
46344: LIST
46345: LIST
46346: LIST
46347: LIST
46348: LIST
46349: LIST
46350: LIST
46351: LIST
46352: LIST
46353: LIST
46354: LIST
46355: LIST
46356: LIST
46357: LIST
46358: LIST
46359: LIST
46360: LIST
46361: LIST
46362: LIST
46363: LIST
46364: LIST
46365: LIST
46366: LIST
46367: LIST
46368: LIST
46369: LIST
46370: LIST
46371: LIST
46372: LIST
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
46380: LD_ADDR_VAR 0 33
46384: PUSH
46385: LD_INT 4
46387: NEG
46388: PUSH
46389: LD_INT 4
46391: NEG
46392: PUSH
46393: EMPTY
46394: LIST
46395: LIST
46396: PUSH
46397: LD_INT 4
46399: NEG
46400: PUSH
46401: LD_INT 5
46403: NEG
46404: PUSH
46405: EMPTY
46406: LIST
46407: LIST
46408: PUSH
46409: LD_INT 3
46411: NEG
46412: PUSH
46413: LD_INT 4
46415: NEG
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: PUSH
46421: LD_INT 3
46423: NEG
46424: PUSH
46425: LD_INT 3
46427: NEG
46428: PUSH
46429: EMPTY
46430: LIST
46431: LIST
46432: PUSH
46433: LD_INT 4
46435: NEG
46436: PUSH
46437: LD_INT 3
46439: NEG
46440: PUSH
46441: EMPTY
46442: LIST
46443: LIST
46444: PUSH
46445: LD_INT 5
46447: NEG
46448: PUSH
46449: LD_INT 4
46451: NEG
46452: PUSH
46453: EMPTY
46454: LIST
46455: LIST
46456: PUSH
46457: LD_INT 5
46459: NEG
46460: PUSH
46461: LD_INT 5
46463: NEG
46464: PUSH
46465: EMPTY
46466: LIST
46467: LIST
46468: PUSH
46469: LD_INT 3
46471: NEG
46472: PUSH
46473: LD_INT 5
46475: NEG
46476: PUSH
46477: EMPTY
46478: LIST
46479: LIST
46480: PUSH
46481: LD_INT 5
46483: NEG
46484: PUSH
46485: LD_INT 3
46487: NEG
46488: PUSH
46489: EMPTY
46490: LIST
46491: LIST
46492: PUSH
46493: LD_INT 0
46495: PUSH
46496: LD_INT 3
46498: NEG
46499: PUSH
46500: EMPTY
46501: LIST
46502: LIST
46503: PUSH
46504: LD_INT 0
46506: PUSH
46507: LD_INT 4
46509: NEG
46510: PUSH
46511: EMPTY
46512: LIST
46513: LIST
46514: PUSH
46515: LD_INT 1
46517: PUSH
46518: LD_INT 3
46520: NEG
46521: PUSH
46522: EMPTY
46523: LIST
46524: LIST
46525: PUSH
46526: LD_INT 1
46528: PUSH
46529: LD_INT 2
46531: NEG
46532: PUSH
46533: EMPTY
46534: LIST
46535: LIST
46536: PUSH
46537: LD_INT 0
46539: PUSH
46540: LD_INT 2
46542: NEG
46543: PUSH
46544: EMPTY
46545: LIST
46546: LIST
46547: PUSH
46548: LD_INT 1
46550: NEG
46551: PUSH
46552: LD_INT 3
46554: NEG
46555: PUSH
46556: EMPTY
46557: LIST
46558: LIST
46559: PUSH
46560: LD_INT 1
46562: NEG
46563: PUSH
46564: LD_INT 4
46566: NEG
46567: PUSH
46568: EMPTY
46569: LIST
46570: LIST
46571: PUSH
46572: LD_INT 2
46574: PUSH
46575: LD_INT 2
46577: NEG
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: PUSH
46583: LD_INT 2
46585: NEG
46586: PUSH
46587: LD_INT 4
46589: NEG
46590: PUSH
46591: EMPTY
46592: LIST
46593: LIST
46594: PUSH
46595: LD_INT 4
46597: PUSH
46598: LD_INT 0
46600: PUSH
46601: EMPTY
46602: LIST
46603: LIST
46604: PUSH
46605: LD_INT 4
46607: PUSH
46608: LD_INT 1
46610: NEG
46611: PUSH
46612: EMPTY
46613: LIST
46614: LIST
46615: PUSH
46616: LD_INT 5
46618: PUSH
46619: LD_INT 0
46621: PUSH
46622: EMPTY
46623: LIST
46624: LIST
46625: PUSH
46626: LD_INT 5
46628: PUSH
46629: LD_INT 1
46631: PUSH
46632: EMPTY
46633: LIST
46634: LIST
46635: PUSH
46636: LD_INT 4
46638: PUSH
46639: LD_INT 1
46641: PUSH
46642: EMPTY
46643: LIST
46644: LIST
46645: PUSH
46646: LD_INT 3
46648: PUSH
46649: LD_INT 0
46651: PUSH
46652: EMPTY
46653: LIST
46654: LIST
46655: PUSH
46656: LD_INT 3
46658: PUSH
46659: LD_INT 1
46661: NEG
46662: PUSH
46663: EMPTY
46664: LIST
46665: LIST
46666: PUSH
46667: LD_INT 3
46669: PUSH
46670: LD_INT 2
46672: NEG
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: LD_INT 5
46680: PUSH
46681: LD_INT 2
46683: PUSH
46684: EMPTY
46685: LIST
46686: LIST
46687: PUSH
46688: LD_INT 3
46690: PUSH
46691: LD_INT 3
46693: PUSH
46694: EMPTY
46695: LIST
46696: LIST
46697: PUSH
46698: LD_INT 3
46700: PUSH
46701: LD_INT 2
46703: PUSH
46704: EMPTY
46705: LIST
46706: LIST
46707: PUSH
46708: LD_INT 4
46710: PUSH
46711: LD_INT 3
46713: PUSH
46714: EMPTY
46715: LIST
46716: LIST
46717: PUSH
46718: LD_INT 4
46720: PUSH
46721: LD_INT 4
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: PUSH
46728: LD_INT 3
46730: PUSH
46731: LD_INT 4
46733: PUSH
46734: EMPTY
46735: LIST
46736: LIST
46737: PUSH
46738: LD_INT 2
46740: PUSH
46741: LD_INT 3
46743: PUSH
46744: EMPTY
46745: LIST
46746: LIST
46747: PUSH
46748: LD_INT 2
46750: PUSH
46751: LD_INT 2
46753: PUSH
46754: EMPTY
46755: LIST
46756: LIST
46757: PUSH
46758: LD_INT 4
46760: PUSH
46761: LD_INT 2
46763: PUSH
46764: EMPTY
46765: LIST
46766: LIST
46767: PUSH
46768: LD_INT 2
46770: PUSH
46771: LD_INT 4
46773: PUSH
46774: EMPTY
46775: LIST
46776: LIST
46777: PUSH
46778: LD_INT 0
46780: PUSH
46781: LD_INT 4
46783: PUSH
46784: EMPTY
46785: LIST
46786: LIST
46787: PUSH
46788: LD_INT 0
46790: PUSH
46791: LD_INT 3
46793: PUSH
46794: EMPTY
46795: LIST
46796: LIST
46797: PUSH
46798: LD_INT 1
46800: PUSH
46801: LD_INT 4
46803: PUSH
46804: EMPTY
46805: LIST
46806: LIST
46807: PUSH
46808: LD_INT 1
46810: PUSH
46811: LD_INT 5
46813: PUSH
46814: EMPTY
46815: LIST
46816: LIST
46817: PUSH
46818: LD_INT 0
46820: PUSH
46821: LD_INT 5
46823: PUSH
46824: EMPTY
46825: LIST
46826: LIST
46827: PUSH
46828: LD_INT 1
46830: NEG
46831: PUSH
46832: LD_INT 4
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: PUSH
46839: LD_INT 1
46841: NEG
46842: PUSH
46843: LD_INT 3
46845: PUSH
46846: EMPTY
46847: LIST
46848: LIST
46849: PUSH
46850: LD_INT 2
46852: PUSH
46853: LD_INT 5
46855: PUSH
46856: EMPTY
46857: LIST
46858: LIST
46859: PUSH
46860: LD_INT 2
46862: NEG
46863: PUSH
46864: LD_INT 3
46866: PUSH
46867: EMPTY
46868: LIST
46869: LIST
46870: PUSH
46871: EMPTY
46872: LIST
46873: LIST
46874: LIST
46875: LIST
46876: LIST
46877: LIST
46878: LIST
46879: LIST
46880: LIST
46881: LIST
46882: LIST
46883: LIST
46884: LIST
46885: LIST
46886: LIST
46887: LIST
46888: LIST
46889: LIST
46890: LIST
46891: LIST
46892: LIST
46893: LIST
46894: LIST
46895: LIST
46896: LIST
46897: LIST
46898: LIST
46899: LIST
46900: LIST
46901: LIST
46902: LIST
46903: LIST
46904: LIST
46905: LIST
46906: LIST
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: LIST
46913: LIST
46914: LIST
46915: LIST
46916: LIST
46917: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46918: LD_ADDR_VAR 0 34
46922: PUSH
46923: LD_INT 0
46925: PUSH
46926: LD_INT 4
46928: NEG
46929: PUSH
46930: EMPTY
46931: LIST
46932: LIST
46933: PUSH
46934: LD_INT 0
46936: PUSH
46937: LD_INT 5
46939: NEG
46940: PUSH
46941: EMPTY
46942: LIST
46943: LIST
46944: PUSH
46945: LD_INT 1
46947: PUSH
46948: LD_INT 4
46950: NEG
46951: PUSH
46952: EMPTY
46953: LIST
46954: LIST
46955: PUSH
46956: LD_INT 1
46958: PUSH
46959: LD_INT 3
46961: NEG
46962: PUSH
46963: EMPTY
46964: LIST
46965: LIST
46966: PUSH
46967: LD_INT 0
46969: PUSH
46970: LD_INT 3
46972: NEG
46973: PUSH
46974: EMPTY
46975: LIST
46976: LIST
46977: PUSH
46978: LD_INT 1
46980: NEG
46981: PUSH
46982: LD_INT 4
46984: NEG
46985: PUSH
46986: EMPTY
46987: LIST
46988: LIST
46989: PUSH
46990: LD_INT 1
46992: NEG
46993: PUSH
46994: LD_INT 5
46996: NEG
46997: PUSH
46998: EMPTY
46999: LIST
47000: LIST
47001: PUSH
47002: LD_INT 2
47004: PUSH
47005: LD_INT 3
47007: NEG
47008: PUSH
47009: EMPTY
47010: LIST
47011: LIST
47012: PUSH
47013: LD_INT 2
47015: NEG
47016: PUSH
47017: LD_INT 5
47019: NEG
47020: PUSH
47021: EMPTY
47022: LIST
47023: LIST
47024: PUSH
47025: LD_INT 3
47027: PUSH
47028: LD_INT 0
47030: PUSH
47031: EMPTY
47032: LIST
47033: LIST
47034: PUSH
47035: LD_INT 3
47037: PUSH
47038: LD_INT 1
47040: NEG
47041: PUSH
47042: EMPTY
47043: LIST
47044: LIST
47045: PUSH
47046: LD_INT 4
47048: PUSH
47049: LD_INT 0
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PUSH
47056: LD_INT 4
47058: PUSH
47059: LD_INT 1
47061: PUSH
47062: EMPTY
47063: LIST
47064: LIST
47065: PUSH
47066: LD_INT 3
47068: PUSH
47069: LD_INT 1
47071: PUSH
47072: EMPTY
47073: LIST
47074: LIST
47075: PUSH
47076: LD_INT 2
47078: PUSH
47079: LD_INT 0
47081: PUSH
47082: EMPTY
47083: LIST
47084: LIST
47085: PUSH
47086: LD_INT 2
47088: PUSH
47089: LD_INT 1
47091: NEG
47092: PUSH
47093: EMPTY
47094: LIST
47095: LIST
47096: PUSH
47097: LD_INT 2
47099: PUSH
47100: LD_INT 2
47102: NEG
47103: PUSH
47104: EMPTY
47105: LIST
47106: LIST
47107: PUSH
47108: LD_INT 4
47110: PUSH
47111: LD_INT 2
47113: PUSH
47114: EMPTY
47115: LIST
47116: LIST
47117: PUSH
47118: LD_INT 4
47120: PUSH
47121: LD_INT 4
47123: PUSH
47124: EMPTY
47125: LIST
47126: LIST
47127: PUSH
47128: LD_INT 4
47130: PUSH
47131: LD_INT 3
47133: PUSH
47134: EMPTY
47135: LIST
47136: LIST
47137: PUSH
47138: LD_INT 5
47140: PUSH
47141: LD_INT 4
47143: PUSH
47144: EMPTY
47145: LIST
47146: LIST
47147: PUSH
47148: LD_INT 5
47150: PUSH
47151: LD_INT 5
47153: PUSH
47154: EMPTY
47155: LIST
47156: LIST
47157: PUSH
47158: LD_INT 4
47160: PUSH
47161: LD_INT 5
47163: PUSH
47164: EMPTY
47165: LIST
47166: LIST
47167: PUSH
47168: LD_INT 3
47170: PUSH
47171: LD_INT 4
47173: PUSH
47174: EMPTY
47175: LIST
47176: LIST
47177: PUSH
47178: LD_INT 3
47180: PUSH
47181: LD_INT 3
47183: PUSH
47184: EMPTY
47185: LIST
47186: LIST
47187: PUSH
47188: LD_INT 5
47190: PUSH
47191: LD_INT 3
47193: PUSH
47194: EMPTY
47195: LIST
47196: LIST
47197: PUSH
47198: LD_INT 3
47200: PUSH
47201: LD_INT 5
47203: PUSH
47204: EMPTY
47205: LIST
47206: LIST
47207: PUSH
47208: LD_INT 0
47210: PUSH
47211: LD_INT 3
47213: PUSH
47214: EMPTY
47215: LIST
47216: LIST
47217: PUSH
47218: LD_INT 0
47220: PUSH
47221: LD_INT 2
47223: PUSH
47224: EMPTY
47225: LIST
47226: LIST
47227: PUSH
47228: LD_INT 1
47230: PUSH
47231: LD_INT 3
47233: PUSH
47234: EMPTY
47235: LIST
47236: LIST
47237: PUSH
47238: LD_INT 1
47240: PUSH
47241: LD_INT 4
47243: PUSH
47244: EMPTY
47245: LIST
47246: LIST
47247: PUSH
47248: LD_INT 0
47250: PUSH
47251: LD_INT 4
47253: PUSH
47254: EMPTY
47255: LIST
47256: LIST
47257: PUSH
47258: LD_INT 1
47260: NEG
47261: PUSH
47262: LD_INT 3
47264: PUSH
47265: EMPTY
47266: LIST
47267: LIST
47268: PUSH
47269: LD_INT 1
47271: NEG
47272: PUSH
47273: LD_INT 2
47275: PUSH
47276: EMPTY
47277: LIST
47278: LIST
47279: PUSH
47280: LD_INT 2
47282: PUSH
47283: LD_INT 4
47285: PUSH
47286: EMPTY
47287: LIST
47288: LIST
47289: PUSH
47290: LD_INT 2
47292: NEG
47293: PUSH
47294: LD_INT 2
47296: PUSH
47297: EMPTY
47298: LIST
47299: LIST
47300: PUSH
47301: LD_INT 4
47303: NEG
47304: PUSH
47305: LD_INT 0
47307: PUSH
47308: EMPTY
47309: LIST
47310: LIST
47311: PUSH
47312: LD_INT 4
47314: NEG
47315: PUSH
47316: LD_INT 1
47318: NEG
47319: PUSH
47320: EMPTY
47321: LIST
47322: LIST
47323: PUSH
47324: LD_INT 3
47326: NEG
47327: PUSH
47328: LD_INT 0
47330: PUSH
47331: EMPTY
47332: LIST
47333: LIST
47334: PUSH
47335: LD_INT 3
47337: NEG
47338: PUSH
47339: LD_INT 1
47341: PUSH
47342: EMPTY
47343: LIST
47344: LIST
47345: PUSH
47346: LD_INT 4
47348: NEG
47349: PUSH
47350: LD_INT 1
47352: PUSH
47353: EMPTY
47354: LIST
47355: LIST
47356: PUSH
47357: LD_INT 5
47359: NEG
47360: PUSH
47361: LD_INT 0
47363: PUSH
47364: EMPTY
47365: LIST
47366: LIST
47367: PUSH
47368: LD_INT 5
47370: NEG
47371: PUSH
47372: LD_INT 1
47374: NEG
47375: PUSH
47376: EMPTY
47377: LIST
47378: LIST
47379: PUSH
47380: LD_INT 5
47382: NEG
47383: PUSH
47384: LD_INT 2
47386: NEG
47387: PUSH
47388: EMPTY
47389: LIST
47390: LIST
47391: PUSH
47392: LD_INT 3
47394: NEG
47395: PUSH
47396: LD_INT 2
47398: PUSH
47399: EMPTY
47400: LIST
47401: LIST
47402: PUSH
47403: EMPTY
47404: LIST
47405: LIST
47406: LIST
47407: LIST
47408: LIST
47409: LIST
47410: LIST
47411: LIST
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: LIST
47417: LIST
47418: LIST
47419: LIST
47420: LIST
47421: LIST
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: LIST
47435: LIST
47436: LIST
47437: LIST
47438: LIST
47439: LIST
47440: LIST
47441: LIST
47442: LIST
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: ST_TO_ADDR
// end ; end ;
47450: GO 47453
47452: POP
// case btype of b_depot , b_warehouse :
47453: LD_VAR 0 1
47457: PUSH
47458: LD_INT 0
47460: DOUBLE
47461: EQUAL
47462: IFTRUE 47472
47464: LD_INT 1
47466: DOUBLE
47467: EQUAL
47468: IFTRUE 47472
47470: GO 47673
47472: POP
// case nation of nation_american :
47473: LD_VAR 0 5
47477: PUSH
47478: LD_INT 1
47480: DOUBLE
47481: EQUAL
47482: IFTRUE 47486
47484: GO 47542
47486: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
47487: LD_ADDR_VAR 0 9
47491: PUSH
47492: LD_VAR 0 11
47496: PUSH
47497: LD_VAR 0 12
47501: PUSH
47502: LD_VAR 0 13
47506: PUSH
47507: LD_VAR 0 14
47511: PUSH
47512: LD_VAR 0 15
47516: PUSH
47517: LD_VAR 0 16
47521: PUSH
47522: EMPTY
47523: LIST
47524: LIST
47525: LIST
47526: LIST
47527: LIST
47528: LIST
47529: PUSH
47530: LD_VAR 0 4
47534: PUSH
47535: LD_INT 1
47537: PLUS
47538: ARRAY
47539: ST_TO_ADDR
47540: GO 47671
47542: LD_INT 2
47544: DOUBLE
47545: EQUAL
47546: IFTRUE 47550
47548: GO 47606
47550: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
47551: LD_ADDR_VAR 0 9
47555: PUSH
47556: LD_VAR 0 17
47560: PUSH
47561: LD_VAR 0 18
47565: PUSH
47566: LD_VAR 0 19
47570: PUSH
47571: LD_VAR 0 20
47575: PUSH
47576: LD_VAR 0 21
47580: PUSH
47581: LD_VAR 0 22
47585: PUSH
47586: EMPTY
47587: LIST
47588: LIST
47589: LIST
47590: LIST
47591: LIST
47592: LIST
47593: PUSH
47594: LD_VAR 0 4
47598: PUSH
47599: LD_INT 1
47601: PLUS
47602: ARRAY
47603: ST_TO_ADDR
47604: GO 47671
47606: LD_INT 3
47608: DOUBLE
47609: EQUAL
47610: IFTRUE 47614
47612: GO 47670
47614: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
47615: LD_ADDR_VAR 0 9
47619: PUSH
47620: LD_VAR 0 23
47624: PUSH
47625: LD_VAR 0 24
47629: PUSH
47630: LD_VAR 0 25
47634: PUSH
47635: LD_VAR 0 26
47639: PUSH
47640: LD_VAR 0 27
47644: PUSH
47645: LD_VAR 0 28
47649: PUSH
47650: EMPTY
47651: LIST
47652: LIST
47653: LIST
47654: LIST
47655: LIST
47656: LIST
47657: PUSH
47658: LD_VAR 0 4
47662: PUSH
47663: LD_INT 1
47665: PLUS
47666: ARRAY
47667: ST_TO_ADDR
47668: GO 47671
47670: POP
47671: GO 48226
47673: LD_INT 2
47675: DOUBLE
47676: EQUAL
47677: IFTRUE 47687
47679: LD_INT 3
47681: DOUBLE
47682: EQUAL
47683: IFTRUE 47687
47685: GO 47743
47687: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47688: LD_ADDR_VAR 0 9
47692: PUSH
47693: LD_VAR 0 29
47697: PUSH
47698: LD_VAR 0 30
47702: PUSH
47703: LD_VAR 0 31
47707: PUSH
47708: LD_VAR 0 32
47712: PUSH
47713: LD_VAR 0 33
47717: PUSH
47718: LD_VAR 0 34
47722: PUSH
47723: EMPTY
47724: LIST
47725: LIST
47726: LIST
47727: LIST
47728: LIST
47729: LIST
47730: PUSH
47731: LD_VAR 0 4
47735: PUSH
47736: LD_INT 1
47738: PLUS
47739: ARRAY
47740: ST_TO_ADDR
47741: GO 48226
47743: LD_INT 16
47745: DOUBLE
47746: EQUAL
47747: IFTRUE 47805
47749: LD_INT 17
47751: DOUBLE
47752: EQUAL
47753: IFTRUE 47805
47755: LD_INT 18
47757: DOUBLE
47758: EQUAL
47759: IFTRUE 47805
47761: LD_INT 19
47763: DOUBLE
47764: EQUAL
47765: IFTRUE 47805
47767: LD_INT 22
47769: DOUBLE
47770: EQUAL
47771: IFTRUE 47805
47773: LD_INT 20
47775: DOUBLE
47776: EQUAL
47777: IFTRUE 47805
47779: LD_INT 21
47781: DOUBLE
47782: EQUAL
47783: IFTRUE 47805
47785: LD_INT 23
47787: DOUBLE
47788: EQUAL
47789: IFTRUE 47805
47791: LD_INT 24
47793: DOUBLE
47794: EQUAL
47795: IFTRUE 47805
47797: LD_INT 25
47799: DOUBLE
47800: EQUAL
47801: IFTRUE 47805
47803: GO 47861
47805: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47806: LD_ADDR_VAR 0 9
47810: PUSH
47811: LD_VAR 0 35
47815: PUSH
47816: LD_VAR 0 36
47820: PUSH
47821: LD_VAR 0 37
47825: PUSH
47826: LD_VAR 0 38
47830: PUSH
47831: LD_VAR 0 39
47835: PUSH
47836: LD_VAR 0 40
47840: PUSH
47841: EMPTY
47842: LIST
47843: LIST
47844: LIST
47845: LIST
47846: LIST
47847: LIST
47848: PUSH
47849: LD_VAR 0 4
47853: PUSH
47854: LD_INT 1
47856: PLUS
47857: ARRAY
47858: ST_TO_ADDR
47859: GO 48226
47861: LD_INT 6
47863: DOUBLE
47864: EQUAL
47865: IFTRUE 47917
47867: LD_INT 7
47869: DOUBLE
47870: EQUAL
47871: IFTRUE 47917
47873: LD_INT 8
47875: DOUBLE
47876: EQUAL
47877: IFTRUE 47917
47879: LD_INT 13
47881: DOUBLE
47882: EQUAL
47883: IFTRUE 47917
47885: LD_INT 12
47887: DOUBLE
47888: EQUAL
47889: IFTRUE 47917
47891: LD_INT 15
47893: DOUBLE
47894: EQUAL
47895: IFTRUE 47917
47897: LD_INT 11
47899: DOUBLE
47900: EQUAL
47901: IFTRUE 47917
47903: LD_INT 14
47905: DOUBLE
47906: EQUAL
47907: IFTRUE 47917
47909: LD_INT 10
47911: DOUBLE
47912: EQUAL
47913: IFTRUE 47917
47915: GO 47973
47917: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47918: LD_ADDR_VAR 0 9
47922: PUSH
47923: LD_VAR 0 41
47927: PUSH
47928: LD_VAR 0 42
47932: PUSH
47933: LD_VAR 0 43
47937: PUSH
47938: LD_VAR 0 44
47942: PUSH
47943: LD_VAR 0 45
47947: PUSH
47948: LD_VAR 0 46
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: LIST
47957: LIST
47958: LIST
47959: LIST
47960: PUSH
47961: LD_VAR 0 4
47965: PUSH
47966: LD_INT 1
47968: PLUS
47969: ARRAY
47970: ST_TO_ADDR
47971: GO 48226
47973: LD_INT 36
47975: DOUBLE
47976: EQUAL
47977: IFTRUE 47981
47979: GO 48037
47981: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47982: LD_ADDR_VAR 0 9
47986: PUSH
47987: LD_VAR 0 47
47991: PUSH
47992: LD_VAR 0 48
47996: PUSH
47997: LD_VAR 0 49
48001: PUSH
48002: LD_VAR 0 50
48006: PUSH
48007: LD_VAR 0 51
48011: PUSH
48012: LD_VAR 0 52
48016: PUSH
48017: EMPTY
48018: LIST
48019: LIST
48020: LIST
48021: LIST
48022: LIST
48023: LIST
48024: PUSH
48025: LD_VAR 0 4
48029: PUSH
48030: LD_INT 1
48032: PLUS
48033: ARRAY
48034: ST_TO_ADDR
48035: GO 48226
48037: LD_INT 4
48039: DOUBLE
48040: EQUAL
48041: IFTRUE 48063
48043: LD_INT 5
48045: DOUBLE
48046: EQUAL
48047: IFTRUE 48063
48049: LD_INT 34
48051: DOUBLE
48052: EQUAL
48053: IFTRUE 48063
48055: LD_INT 37
48057: DOUBLE
48058: EQUAL
48059: IFTRUE 48063
48061: GO 48119
48063: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
48064: LD_ADDR_VAR 0 9
48068: PUSH
48069: LD_VAR 0 53
48073: PUSH
48074: LD_VAR 0 54
48078: PUSH
48079: LD_VAR 0 55
48083: PUSH
48084: LD_VAR 0 56
48088: PUSH
48089: LD_VAR 0 57
48093: PUSH
48094: LD_VAR 0 58
48098: PUSH
48099: EMPTY
48100: LIST
48101: LIST
48102: LIST
48103: LIST
48104: LIST
48105: LIST
48106: PUSH
48107: LD_VAR 0 4
48111: PUSH
48112: LD_INT 1
48114: PLUS
48115: ARRAY
48116: ST_TO_ADDR
48117: GO 48226
48119: LD_INT 31
48121: DOUBLE
48122: EQUAL
48123: IFTRUE 48169
48125: LD_INT 32
48127: DOUBLE
48128: EQUAL
48129: IFTRUE 48169
48131: LD_INT 33
48133: DOUBLE
48134: EQUAL
48135: IFTRUE 48169
48137: LD_INT 27
48139: DOUBLE
48140: EQUAL
48141: IFTRUE 48169
48143: LD_INT 26
48145: DOUBLE
48146: EQUAL
48147: IFTRUE 48169
48149: LD_INT 28
48151: DOUBLE
48152: EQUAL
48153: IFTRUE 48169
48155: LD_INT 29
48157: DOUBLE
48158: EQUAL
48159: IFTRUE 48169
48161: LD_INT 30
48163: DOUBLE
48164: EQUAL
48165: IFTRUE 48169
48167: GO 48225
48169: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
48170: LD_ADDR_VAR 0 9
48174: PUSH
48175: LD_VAR 0 59
48179: PUSH
48180: LD_VAR 0 60
48184: PUSH
48185: LD_VAR 0 61
48189: PUSH
48190: LD_VAR 0 62
48194: PUSH
48195: LD_VAR 0 63
48199: PUSH
48200: LD_VAR 0 64
48204: PUSH
48205: EMPTY
48206: LIST
48207: LIST
48208: LIST
48209: LIST
48210: LIST
48211: LIST
48212: PUSH
48213: LD_VAR 0 4
48217: PUSH
48218: LD_INT 1
48220: PLUS
48221: ARRAY
48222: ST_TO_ADDR
48223: GO 48226
48225: POP
// temp_list2 = [ ] ;
48226: LD_ADDR_VAR 0 10
48230: PUSH
48231: EMPTY
48232: ST_TO_ADDR
// for i in temp_list do
48233: LD_ADDR_VAR 0 8
48237: PUSH
48238: LD_VAR 0 9
48242: PUSH
48243: FOR_IN
48244: IFFALSE 48296
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
48246: LD_ADDR_VAR 0 10
48250: PUSH
48251: LD_VAR 0 10
48255: PUSH
48256: LD_VAR 0 8
48260: PUSH
48261: LD_INT 1
48263: ARRAY
48264: PUSH
48265: LD_VAR 0 2
48269: PLUS
48270: PUSH
48271: LD_VAR 0 8
48275: PUSH
48276: LD_INT 2
48278: ARRAY
48279: PUSH
48280: LD_VAR 0 3
48284: PLUS
48285: PUSH
48286: EMPTY
48287: LIST
48288: LIST
48289: PUSH
48290: EMPTY
48291: LIST
48292: ADD
48293: ST_TO_ADDR
48294: GO 48243
48296: POP
48297: POP
// result = temp_list2 ;
48298: LD_ADDR_VAR 0 7
48302: PUSH
48303: LD_VAR 0 10
48307: ST_TO_ADDR
// end ;
48308: LD_VAR 0 7
48312: RET
// export function EnemyInRange ( unit , dist ) ; begin
48313: LD_INT 0
48315: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
48316: LD_ADDR_VAR 0 3
48320: PUSH
48321: LD_VAR 0 1
48325: PPUSH
48326: CALL_OW 255
48330: PPUSH
48331: LD_VAR 0 1
48335: PPUSH
48336: CALL_OW 250
48340: PPUSH
48341: LD_VAR 0 1
48345: PPUSH
48346: CALL_OW 251
48350: PPUSH
48351: LD_VAR 0 2
48355: PPUSH
48356: CALL 22417 0 4
48360: PUSH
48361: LD_INT 4
48363: ARRAY
48364: ST_TO_ADDR
// end ;
48365: LD_VAR 0 3
48369: RET
// export function PlayerSeeMe ( unit ) ; begin
48370: LD_INT 0
48372: PPUSH
// result := See ( your_side , unit ) ;
48373: LD_ADDR_VAR 0 2
48377: PUSH
48378: LD_OWVAR 2
48382: PPUSH
48383: LD_VAR 0 1
48387: PPUSH
48388: CALL_OW 292
48392: ST_TO_ADDR
// end ;
48393: LD_VAR 0 2
48397: RET
// export function ReverseDir ( unit ) ; begin
48398: LD_INT 0
48400: PPUSH
// if not unit then
48401: LD_VAR 0 1
48405: NOT
48406: IFFALSE 48410
// exit ;
48408: GO 48456
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
48410: LD_ADDR_VAR 0 2
48414: PUSH
48415: LD_INT 3
48417: PUSH
48418: LD_INT 4
48420: PUSH
48421: LD_INT 5
48423: PUSH
48424: LD_INT 0
48426: PUSH
48427: LD_INT 1
48429: PUSH
48430: LD_INT 2
48432: PUSH
48433: EMPTY
48434: LIST
48435: LIST
48436: LIST
48437: LIST
48438: LIST
48439: LIST
48440: PUSH
48441: LD_VAR 0 1
48445: PPUSH
48446: CALL_OW 254
48450: PUSH
48451: LD_INT 1
48453: PLUS
48454: ARRAY
48455: ST_TO_ADDR
// end ;
48456: LD_VAR 0 2
48460: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
48461: LD_INT 0
48463: PPUSH
48464: PPUSH
48465: PPUSH
48466: PPUSH
48467: PPUSH
// if not hexes then
48468: LD_VAR 0 2
48472: NOT
48473: IFFALSE 48477
// exit ;
48475: GO 48625
// dist := 9999 ;
48477: LD_ADDR_VAR 0 5
48481: PUSH
48482: LD_INT 9999
48484: ST_TO_ADDR
// for i = 1 to hexes do
48485: LD_ADDR_VAR 0 4
48489: PUSH
48490: DOUBLE
48491: LD_INT 1
48493: DEC
48494: ST_TO_ADDR
48495: LD_VAR 0 2
48499: PUSH
48500: FOR_TO
48501: IFFALSE 48613
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
48503: LD_VAR 0 1
48507: PPUSH
48508: LD_VAR 0 2
48512: PUSH
48513: LD_VAR 0 4
48517: ARRAY
48518: PUSH
48519: LD_INT 1
48521: ARRAY
48522: PPUSH
48523: LD_VAR 0 2
48527: PUSH
48528: LD_VAR 0 4
48532: ARRAY
48533: PUSH
48534: LD_INT 2
48536: ARRAY
48537: PPUSH
48538: CALL_OW 297
48542: PUSH
48543: LD_VAR 0 5
48547: LESS
48548: IFFALSE 48611
// begin hex := hexes [ i ] ;
48550: LD_ADDR_VAR 0 7
48554: PUSH
48555: LD_VAR 0 2
48559: PUSH
48560: LD_VAR 0 4
48564: ARRAY
48565: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
48566: LD_ADDR_VAR 0 5
48570: PUSH
48571: LD_VAR 0 1
48575: PPUSH
48576: LD_VAR 0 2
48580: PUSH
48581: LD_VAR 0 4
48585: ARRAY
48586: PUSH
48587: LD_INT 1
48589: ARRAY
48590: PPUSH
48591: LD_VAR 0 2
48595: PUSH
48596: LD_VAR 0 4
48600: ARRAY
48601: PUSH
48602: LD_INT 2
48604: ARRAY
48605: PPUSH
48606: CALL_OW 297
48610: ST_TO_ADDR
// end ; end ;
48611: GO 48500
48613: POP
48614: POP
// result := hex ;
48615: LD_ADDR_VAR 0 3
48619: PUSH
48620: LD_VAR 0 7
48624: ST_TO_ADDR
// end ;
48625: LD_VAR 0 3
48629: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
48630: LD_INT 0
48632: PPUSH
48633: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
48634: LD_VAR 0 1
48638: NOT
48639: PUSH
48640: LD_VAR 0 1
48644: PUSH
48645: LD_INT 21
48647: PUSH
48648: LD_INT 2
48650: PUSH
48651: EMPTY
48652: LIST
48653: LIST
48654: PUSH
48655: LD_INT 23
48657: PUSH
48658: LD_INT 2
48660: PUSH
48661: EMPTY
48662: LIST
48663: LIST
48664: PUSH
48665: EMPTY
48666: LIST
48667: LIST
48668: PPUSH
48669: CALL_OW 69
48673: IN
48674: NOT
48675: OR
48676: IFFALSE 48680
// exit ;
48678: GO 48727
// for i = 1 to 3 do
48680: LD_ADDR_VAR 0 3
48684: PUSH
48685: DOUBLE
48686: LD_INT 1
48688: DEC
48689: ST_TO_ADDR
48690: LD_INT 3
48692: PUSH
48693: FOR_TO
48694: IFFALSE 48725
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48696: LD_VAR 0 1
48700: PPUSH
48701: CALL_OW 250
48705: PPUSH
48706: LD_VAR 0 1
48710: PPUSH
48711: CALL_OW 251
48715: PPUSH
48716: LD_INT 1
48718: PPUSH
48719: CALL_OW 453
48723: GO 48693
48725: POP
48726: POP
// end ;
48727: LD_VAR 0 2
48731: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48732: LD_INT 0
48734: PPUSH
48735: PPUSH
48736: PPUSH
48737: PPUSH
48738: PPUSH
48739: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48740: LD_VAR 0 1
48744: NOT
48745: PUSH
48746: LD_VAR 0 2
48750: NOT
48751: OR
48752: PUSH
48753: LD_VAR 0 1
48757: PPUSH
48758: CALL_OW 314
48762: OR
48763: IFFALSE 48767
// exit ;
48765: GO 49208
// x := GetX ( enemy_unit ) ;
48767: LD_ADDR_VAR 0 7
48771: PUSH
48772: LD_VAR 0 2
48776: PPUSH
48777: CALL_OW 250
48781: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48782: LD_ADDR_VAR 0 8
48786: PUSH
48787: LD_VAR 0 2
48791: PPUSH
48792: CALL_OW 251
48796: ST_TO_ADDR
// if not x or not y then
48797: LD_VAR 0 7
48801: NOT
48802: PUSH
48803: LD_VAR 0 8
48807: NOT
48808: OR
48809: IFFALSE 48813
// exit ;
48811: GO 49208
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48813: LD_ADDR_VAR 0 6
48817: PUSH
48818: LD_VAR 0 7
48822: PPUSH
48823: LD_INT 0
48825: PPUSH
48826: LD_INT 4
48828: PPUSH
48829: CALL_OW 272
48833: PUSH
48834: LD_VAR 0 8
48838: PPUSH
48839: LD_INT 0
48841: PPUSH
48842: LD_INT 4
48844: PPUSH
48845: CALL_OW 273
48849: PUSH
48850: EMPTY
48851: LIST
48852: LIST
48853: PUSH
48854: LD_VAR 0 7
48858: PPUSH
48859: LD_INT 1
48861: PPUSH
48862: LD_INT 4
48864: PPUSH
48865: CALL_OW 272
48869: PUSH
48870: LD_VAR 0 8
48874: PPUSH
48875: LD_INT 1
48877: PPUSH
48878: LD_INT 4
48880: PPUSH
48881: CALL_OW 273
48885: PUSH
48886: EMPTY
48887: LIST
48888: LIST
48889: PUSH
48890: LD_VAR 0 7
48894: PPUSH
48895: LD_INT 2
48897: PPUSH
48898: LD_INT 4
48900: PPUSH
48901: CALL_OW 272
48905: PUSH
48906: LD_VAR 0 8
48910: PPUSH
48911: LD_INT 2
48913: PPUSH
48914: LD_INT 4
48916: PPUSH
48917: CALL_OW 273
48921: PUSH
48922: EMPTY
48923: LIST
48924: LIST
48925: PUSH
48926: LD_VAR 0 7
48930: PPUSH
48931: LD_INT 3
48933: PPUSH
48934: LD_INT 4
48936: PPUSH
48937: CALL_OW 272
48941: PUSH
48942: LD_VAR 0 8
48946: PPUSH
48947: LD_INT 3
48949: PPUSH
48950: LD_INT 4
48952: PPUSH
48953: CALL_OW 273
48957: PUSH
48958: EMPTY
48959: LIST
48960: LIST
48961: PUSH
48962: LD_VAR 0 7
48966: PPUSH
48967: LD_INT 4
48969: PPUSH
48970: LD_INT 4
48972: PPUSH
48973: CALL_OW 272
48977: PUSH
48978: LD_VAR 0 8
48982: PPUSH
48983: LD_INT 4
48985: PPUSH
48986: LD_INT 4
48988: PPUSH
48989: CALL_OW 273
48993: PUSH
48994: EMPTY
48995: LIST
48996: LIST
48997: PUSH
48998: LD_VAR 0 7
49002: PPUSH
49003: LD_INT 5
49005: PPUSH
49006: LD_INT 4
49008: PPUSH
49009: CALL_OW 272
49013: PUSH
49014: LD_VAR 0 8
49018: PPUSH
49019: LD_INT 5
49021: PPUSH
49022: LD_INT 4
49024: PPUSH
49025: CALL_OW 273
49029: PUSH
49030: EMPTY
49031: LIST
49032: LIST
49033: PUSH
49034: EMPTY
49035: LIST
49036: LIST
49037: LIST
49038: LIST
49039: LIST
49040: LIST
49041: ST_TO_ADDR
// for i = tmp downto 1 do
49042: LD_ADDR_VAR 0 4
49046: PUSH
49047: DOUBLE
49048: LD_VAR 0 6
49052: INC
49053: ST_TO_ADDR
49054: LD_INT 1
49056: PUSH
49057: FOR_DOWNTO
49058: IFFALSE 49159
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
49060: LD_VAR 0 6
49064: PUSH
49065: LD_VAR 0 4
49069: ARRAY
49070: PUSH
49071: LD_INT 1
49073: ARRAY
49074: PPUSH
49075: LD_VAR 0 6
49079: PUSH
49080: LD_VAR 0 4
49084: ARRAY
49085: PUSH
49086: LD_INT 2
49088: ARRAY
49089: PPUSH
49090: CALL_OW 488
49094: NOT
49095: PUSH
49096: LD_VAR 0 6
49100: PUSH
49101: LD_VAR 0 4
49105: ARRAY
49106: PUSH
49107: LD_INT 1
49109: ARRAY
49110: PPUSH
49111: LD_VAR 0 6
49115: PUSH
49116: LD_VAR 0 4
49120: ARRAY
49121: PUSH
49122: LD_INT 2
49124: ARRAY
49125: PPUSH
49126: CALL_OW 428
49130: PUSH
49131: LD_INT 0
49133: NONEQUAL
49134: OR
49135: IFFALSE 49157
// tmp := Delete ( tmp , i ) ;
49137: LD_ADDR_VAR 0 6
49141: PUSH
49142: LD_VAR 0 6
49146: PPUSH
49147: LD_VAR 0 4
49151: PPUSH
49152: CALL_OW 3
49156: ST_TO_ADDR
49157: GO 49057
49159: POP
49160: POP
// j := GetClosestHex ( unit , tmp ) ;
49161: LD_ADDR_VAR 0 5
49165: PUSH
49166: LD_VAR 0 1
49170: PPUSH
49171: LD_VAR 0 6
49175: PPUSH
49176: CALL 48461 0 2
49180: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
49181: LD_VAR 0 1
49185: PPUSH
49186: LD_VAR 0 5
49190: PUSH
49191: LD_INT 1
49193: ARRAY
49194: PPUSH
49195: LD_VAR 0 5
49199: PUSH
49200: LD_INT 2
49202: ARRAY
49203: PPUSH
49204: CALL_OW 111
// end ;
49208: LD_VAR 0 3
49212: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
49213: LD_INT 0
49215: PPUSH
49216: PPUSH
49217: PPUSH
// uc_side = 0 ;
49218: LD_ADDR_OWVAR 20
49222: PUSH
49223: LD_INT 0
49225: ST_TO_ADDR
// uc_nation = 0 ;
49226: LD_ADDR_OWVAR 21
49230: PUSH
49231: LD_INT 0
49233: ST_TO_ADDR
// InitHc ;
49234: CALL_OW 19
// InitVc ;
49238: CALL_OW 20
// if mastodonts then
49242: LD_VAR 0 6
49246: IFFALSE 49313
// for i = 1 to mastodonts do
49248: LD_ADDR_VAR 0 11
49252: PUSH
49253: DOUBLE
49254: LD_INT 1
49256: DEC
49257: ST_TO_ADDR
49258: LD_VAR 0 6
49262: PUSH
49263: FOR_TO
49264: IFFALSE 49311
// begin vc_chassis := 31 ;
49266: LD_ADDR_OWVAR 37
49270: PUSH
49271: LD_INT 31
49273: ST_TO_ADDR
// vc_control := control_rider ;
49274: LD_ADDR_OWVAR 38
49278: PUSH
49279: LD_INT 4
49281: ST_TO_ADDR
// animal := CreateVehicle ;
49282: LD_ADDR_VAR 0 12
49286: PUSH
49287: CALL_OW 45
49291: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49292: LD_VAR 0 12
49296: PPUSH
49297: LD_VAR 0 8
49301: PPUSH
49302: LD_INT 0
49304: PPUSH
49305: CALL 56084 0 3
// end ;
49309: GO 49263
49311: POP
49312: POP
// if horses then
49313: LD_VAR 0 5
49317: IFFALSE 49384
// for i = 1 to horses do
49319: LD_ADDR_VAR 0 11
49323: PUSH
49324: DOUBLE
49325: LD_INT 1
49327: DEC
49328: ST_TO_ADDR
49329: LD_VAR 0 5
49333: PUSH
49334: FOR_TO
49335: IFFALSE 49382
// begin hc_class := 21 ;
49337: LD_ADDR_OWVAR 28
49341: PUSH
49342: LD_INT 21
49344: ST_TO_ADDR
// hc_gallery :=  ;
49345: LD_ADDR_OWVAR 33
49349: PUSH
49350: LD_STRING 
49352: ST_TO_ADDR
// animal := CreateHuman ;
49353: LD_ADDR_VAR 0 12
49357: PUSH
49358: CALL_OW 44
49362: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49363: LD_VAR 0 12
49367: PPUSH
49368: LD_VAR 0 8
49372: PPUSH
49373: LD_INT 0
49375: PPUSH
49376: CALL 56084 0 3
// end ;
49380: GO 49334
49382: POP
49383: POP
// if birds then
49384: LD_VAR 0 1
49388: IFFALSE 49455
// for i = 1 to birds do
49390: LD_ADDR_VAR 0 11
49394: PUSH
49395: DOUBLE
49396: LD_INT 1
49398: DEC
49399: ST_TO_ADDR
49400: LD_VAR 0 1
49404: PUSH
49405: FOR_TO
49406: IFFALSE 49453
// begin hc_class = 18 ;
49408: LD_ADDR_OWVAR 28
49412: PUSH
49413: LD_INT 18
49415: ST_TO_ADDR
// hc_gallery =  ;
49416: LD_ADDR_OWVAR 33
49420: PUSH
49421: LD_STRING 
49423: ST_TO_ADDR
// animal := CreateHuman ;
49424: LD_ADDR_VAR 0 12
49428: PUSH
49429: CALL_OW 44
49433: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49434: LD_VAR 0 12
49438: PPUSH
49439: LD_VAR 0 8
49443: PPUSH
49444: LD_INT 0
49446: PPUSH
49447: CALL 56084 0 3
// end ;
49451: GO 49405
49453: POP
49454: POP
// if tigers then
49455: LD_VAR 0 2
49459: IFFALSE 49543
// for i = 1 to tigers do
49461: LD_ADDR_VAR 0 11
49465: PUSH
49466: DOUBLE
49467: LD_INT 1
49469: DEC
49470: ST_TO_ADDR
49471: LD_VAR 0 2
49475: PUSH
49476: FOR_TO
49477: IFFALSE 49541
// begin hc_class = class_tiger ;
49479: LD_ADDR_OWVAR 28
49483: PUSH
49484: LD_INT 14
49486: ST_TO_ADDR
// hc_gallery =  ;
49487: LD_ADDR_OWVAR 33
49491: PUSH
49492: LD_STRING 
49494: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49495: LD_ADDR_OWVAR 35
49499: PUSH
49500: LD_INT 7
49502: NEG
49503: PPUSH
49504: LD_INT 7
49506: PPUSH
49507: CALL_OW 12
49511: ST_TO_ADDR
// animal := CreateHuman ;
49512: LD_ADDR_VAR 0 12
49516: PUSH
49517: CALL_OW 44
49521: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49522: LD_VAR 0 12
49526: PPUSH
49527: LD_VAR 0 8
49531: PPUSH
49532: LD_INT 0
49534: PPUSH
49535: CALL 56084 0 3
// end ;
49539: GO 49476
49541: POP
49542: POP
// if apemans then
49543: LD_VAR 0 3
49547: IFFALSE 49670
// for i = 1 to apemans do
49549: LD_ADDR_VAR 0 11
49553: PUSH
49554: DOUBLE
49555: LD_INT 1
49557: DEC
49558: ST_TO_ADDR
49559: LD_VAR 0 3
49563: PUSH
49564: FOR_TO
49565: IFFALSE 49668
// begin hc_class = class_apeman ;
49567: LD_ADDR_OWVAR 28
49571: PUSH
49572: LD_INT 12
49574: ST_TO_ADDR
// hc_gallery =  ;
49575: LD_ADDR_OWVAR 33
49579: PUSH
49580: LD_STRING 
49582: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
49583: LD_ADDR_OWVAR 35
49587: PUSH
49588: LD_INT 5
49590: NEG
49591: PPUSH
49592: LD_INT 5
49594: PPUSH
49595: CALL_OW 12
49599: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49600: LD_ADDR_OWVAR 31
49604: PUSH
49605: LD_INT 1
49607: PPUSH
49608: LD_INT 3
49610: PPUSH
49611: CALL_OW 12
49615: PUSH
49616: LD_INT 1
49618: PPUSH
49619: LD_INT 3
49621: PPUSH
49622: CALL_OW 12
49626: PUSH
49627: LD_INT 0
49629: PUSH
49630: LD_INT 0
49632: PUSH
49633: EMPTY
49634: LIST
49635: LIST
49636: LIST
49637: LIST
49638: ST_TO_ADDR
// animal := CreateHuman ;
49639: LD_ADDR_VAR 0 12
49643: PUSH
49644: CALL_OW 44
49648: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49649: LD_VAR 0 12
49653: PPUSH
49654: LD_VAR 0 8
49658: PPUSH
49659: LD_INT 0
49661: PPUSH
49662: CALL 56084 0 3
// end ;
49666: GO 49564
49668: POP
49669: POP
// if enchidnas then
49670: LD_VAR 0 4
49674: IFFALSE 49741
// for i = 1 to enchidnas do
49676: LD_ADDR_VAR 0 11
49680: PUSH
49681: DOUBLE
49682: LD_INT 1
49684: DEC
49685: ST_TO_ADDR
49686: LD_VAR 0 4
49690: PUSH
49691: FOR_TO
49692: IFFALSE 49739
// begin hc_class = 13 ;
49694: LD_ADDR_OWVAR 28
49698: PUSH
49699: LD_INT 13
49701: ST_TO_ADDR
// hc_gallery =  ;
49702: LD_ADDR_OWVAR 33
49706: PUSH
49707: LD_STRING 
49709: ST_TO_ADDR
// animal := CreateHuman ;
49710: LD_ADDR_VAR 0 12
49714: PUSH
49715: CALL_OW 44
49719: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49720: LD_VAR 0 12
49724: PPUSH
49725: LD_VAR 0 8
49729: PPUSH
49730: LD_INT 0
49732: PPUSH
49733: CALL 56084 0 3
// end ;
49737: GO 49691
49739: POP
49740: POP
// if fishes then
49741: LD_VAR 0 7
49745: IFFALSE 49812
// for i = 1 to fishes do
49747: LD_ADDR_VAR 0 11
49751: PUSH
49752: DOUBLE
49753: LD_INT 1
49755: DEC
49756: ST_TO_ADDR
49757: LD_VAR 0 7
49761: PUSH
49762: FOR_TO
49763: IFFALSE 49810
// begin hc_class = 20 ;
49765: LD_ADDR_OWVAR 28
49769: PUSH
49770: LD_INT 20
49772: ST_TO_ADDR
// hc_gallery =  ;
49773: LD_ADDR_OWVAR 33
49777: PUSH
49778: LD_STRING 
49780: ST_TO_ADDR
// animal := CreateHuman ;
49781: LD_ADDR_VAR 0 12
49785: PUSH
49786: CALL_OW 44
49790: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49791: LD_VAR 0 12
49795: PPUSH
49796: LD_VAR 0 9
49800: PPUSH
49801: LD_INT 0
49803: PPUSH
49804: CALL 56084 0 3
// end ;
49808: GO 49762
49810: POP
49811: POP
// end ;
49812: LD_VAR 0 10
49816: RET
// export function WantHeal ( sci , unit ) ; begin
49817: LD_INT 0
49819: PPUSH
// if GetTaskList ( sci ) > 0 then
49820: LD_VAR 0 1
49824: PPUSH
49825: CALL_OW 437
49829: PUSH
49830: LD_INT 0
49832: GREATER
49833: IFFALSE 49903
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49835: LD_VAR 0 1
49839: PPUSH
49840: CALL_OW 437
49844: PUSH
49845: LD_INT 1
49847: ARRAY
49848: PUSH
49849: LD_INT 1
49851: ARRAY
49852: PUSH
49853: LD_STRING l
49855: EQUAL
49856: PUSH
49857: LD_VAR 0 1
49861: PPUSH
49862: CALL_OW 437
49866: PUSH
49867: LD_INT 1
49869: ARRAY
49870: PUSH
49871: LD_INT 4
49873: ARRAY
49874: PUSH
49875: LD_VAR 0 2
49879: EQUAL
49880: AND
49881: IFFALSE 49893
// result := true else
49883: LD_ADDR_VAR 0 3
49887: PUSH
49888: LD_INT 1
49890: ST_TO_ADDR
49891: GO 49901
// result := false ;
49893: LD_ADDR_VAR 0 3
49897: PUSH
49898: LD_INT 0
49900: ST_TO_ADDR
// end else
49901: GO 49911
// result := false ;
49903: LD_ADDR_VAR 0 3
49907: PUSH
49908: LD_INT 0
49910: ST_TO_ADDR
// end ;
49911: LD_VAR 0 3
49915: RET
// export function HealTarget ( sci ) ; begin
49916: LD_INT 0
49918: PPUSH
// if not sci then
49919: LD_VAR 0 1
49923: NOT
49924: IFFALSE 49928
// exit ;
49926: GO 49993
// result := 0 ;
49928: LD_ADDR_VAR 0 2
49932: PUSH
49933: LD_INT 0
49935: ST_TO_ADDR
// if GetTaskList ( sci ) then
49936: LD_VAR 0 1
49940: PPUSH
49941: CALL_OW 437
49945: IFFALSE 49993
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49947: LD_VAR 0 1
49951: PPUSH
49952: CALL_OW 437
49956: PUSH
49957: LD_INT 1
49959: ARRAY
49960: PUSH
49961: LD_INT 1
49963: ARRAY
49964: PUSH
49965: LD_STRING l
49967: EQUAL
49968: IFFALSE 49993
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49970: LD_ADDR_VAR 0 2
49974: PUSH
49975: LD_VAR 0 1
49979: PPUSH
49980: CALL_OW 437
49984: PUSH
49985: LD_INT 1
49987: ARRAY
49988: PUSH
49989: LD_INT 4
49991: ARRAY
49992: ST_TO_ADDR
// end ;
49993: LD_VAR 0 2
49997: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
49998: LD_INT 0
50000: PPUSH
50001: PPUSH
50002: PPUSH
50003: PPUSH
50004: PPUSH
50005: PPUSH
50006: PPUSH
50007: PPUSH
50008: PPUSH
50009: PPUSH
50010: PPUSH
50011: PPUSH
50012: PPUSH
50013: PPUSH
50014: PPUSH
50015: PPUSH
50016: PPUSH
50017: PPUSH
50018: PPUSH
50019: PPUSH
50020: PPUSH
50021: PPUSH
50022: PPUSH
50023: PPUSH
50024: PPUSH
50025: PPUSH
50026: PPUSH
50027: PPUSH
50028: PPUSH
50029: PPUSH
50030: PPUSH
50031: PPUSH
50032: PPUSH
50033: PPUSH
// if not list then
50034: LD_VAR 0 1
50038: NOT
50039: IFFALSE 50043
// exit ;
50041: GO 54695
// base := list [ 1 ] ;
50043: LD_ADDR_VAR 0 3
50047: PUSH
50048: LD_VAR 0 1
50052: PUSH
50053: LD_INT 1
50055: ARRAY
50056: ST_TO_ADDR
// group := list [ 2 ] ;
50057: LD_ADDR_VAR 0 4
50061: PUSH
50062: LD_VAR 0 1
50066: PUSH
50067: LD_INT 2
50069: ARRAY
50070: ST_TO_ADDR
// path := list [ 3 ] ;
50071: LD_ADDR_VAR 0 5
50075: PUSH
50076: LD_VAR 0 1
50080: PUSH
50081: LD_INT 3
50083: ARRAY
50084: ST_TO_ADDR
// flags := list [ 4 ] ;
50085: LD_ADDR_VAR 0 6
50089: PUSH
50090: LD_VAR 0 1
50094: PUSH
50095: LD_INT 4
50097: ARRAY
50098: ST_TO_ADDR
// mined := [ ] ;
50099: LD_ADDR_VAR 0 27
50103: PUSH
50104: EMPTY
50105: ST_TO_ADDR
// bombed := [ ] ;
50106: LD_ADDR_VAR 0 28
50110: PUSH
50111: EMPTY
50112: ST_TO_ADDR
// healers := [ ] ;
50113: LD_ADDR_VAR 0 31
50117: PUSH
50118: EMPTY
50119: ST_TO_ADDR
// to_heal := [ ] ;
50120: LD_ADDR_VAR 0 30
50124: PUSH
50125: EMPTY
50126: ST_TO_ADDR
// repairs := [ ] ;
50127: LD_ADDR_VAR 0 33
50131: PUSH
50132: EMPTY
50133: ST_TO_ADDR
// to_repair := [ ] ;
50134: LD_ADDR_VAR 0 32
50138: PUSH
50139: EMPTY
50140: ST_TO_ADDR
// if not group or not path then
50141: LD_VAR 0 4
50145: NOT
50146: PUSH
50147: LD_VAR 0 5
50151: NOT
50152: OR
50153: IFFALSE 50157
// exit ;
50155: GO 54695
// side := GetSide ( group [ 1 ] ) ;
50157: LD_ADDR_VAR 0 35
50161: PUSH
50162: LD_VAR 0 4
50166: PUSH
50167: LD_INT 1
50169: ARRAY
50170: PPUSH
50171: CALL_OW 255
50175: ST_TO_ADDR
// if flags then
50176: LD_VAR 0 6
50180: IFFALSE 50324
// begin f_ignore_area := flags [ 1 ] ;
50182: LD_ADDR_VAR 0 17
50186: PUSH
50187: LD_VAR 0 6
50191: PUSH
50192: LD_INT 1
50194: ARRAY
50195: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
50196: LD_ADDR_VAR 0 18
50200: PUSH
50201: LD_VAR 0 6
50205: PUSH
50206: LD_INT 2
50208: ARRAY
50209: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
50210: LD_ADDR_VAR 0 19
50214: PUSH
50215: LD_VAR 0 6
50219: PUSH
50220: LD_INT 3
50222: ARRAY
50223: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
50224: LD_ADDR_VAR 0 20
50228: PUSH
50229: LD_VAR 0 6
50233: PUSH
50234: LD_INT 4
50236: ARRAY
50237: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
50238: LD_ADDR_VAR 0 21
50242: PUSH
50243: LD_VAR 0 6
50247: PUSH
50248: LD_INT 5
50250: ARRAY
50251: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
50252: LD_ADDR_VAR 0 22
50256: PUSH
50257: LD_VAR 0 6
50261: PUSH
50262: LD_INT 6
50264: ARRAY
50265: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
50266: LD_ADDR_VAR 0 23
50270: PUSH
50271: LD_VAR 0 6
50275: PUSH
50276: LD_INT 7
50278: ARRAY
50279: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
50280: LD_ADDR_VAR 0 24
50284: PUSH
50285: LD_VAR 0 6
50289: PUSH
50290: LD_INT 8
50292: ARRAY
50293: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
50294: LD_ADDR_VAR 0 25
50298: PUSH
50299: LD_VAR 0 6
50303: PUSH
50304: LD_INT 9
50306: ARRAY
50307: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
50308: LD_ADDR_VAR 0 26
50312: PUSH
50313: LD_VAR 0 6
50317: PUSH
50318: LD_INT 10
50320: ARRAY
50321: ST_TO_ADDR
// end else
50322: GO 50404
// begin f_ignore_area := false ;
50324: LD_ADDR_VAR 0 17
50328: PUSH
50329: LD_INT 0
50331: ST_TO_ADDR
// f_capture := false ;
50332: LD_ADDR_VAR 0 18
50336: PUSH
50337: LD_INT 0
50339: ST_TO_ADDR
// f_ignore_civ := false ;
50340: LD_ADDR_VAR 0 19
50344: PUSH
50345: LD_INT 0
50347: ST_TO_ADDR
// f_murder := false ;
50348: LD_ADDR_VAR 0 20
50352: PUSH
50353: LD_INT 0
50355: ST_TO_ADDR
// f_mines := false ;
50356: LD_ADDR_VAR 0 21
50360: PUSH
50361: LD_INT 0
50363: ST_TO_ADDR
// f_repair := false ;
50364: LD_ADDR_VAR 0 22
50368: PUSH
50369: LD_INT 0
50371: ST_TO_ADDR
// f_heal := false ;
50372: LD_ADDR_VAR 0 23
50376: PUSH
50377: LD_INT 0
50379: ST_TO_ADDR
// f_spacetime := false ;
50380: LD_ADDR_VAR 0 24
50384: PUSH
50385: LD_INT 0
50387: ST_TO_ADDR
// f_attack_depot := false ;
50388: LD_ADDR_VAR 0 25
50392: PUSH
50393: LD_INT 0
50395: ST_TO_ADDR
// f_crawl := false ;
50396: LD_ADDR_VAR 0 26
50400: PUSH
50401: LD_INT 0
50403: ST_TO_ADDR
// end ; if f_heal then
50404: LD_VAR 0 23
50408: IFFALSE 50435
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
50410: LD_ADDR_VAR 0 31
50414: PUSH
50415: LD_VAR 0 4
50419: PPUSH
50420: LD_INT 25
50422: PUSH
50423: LD_INT 4
50425: PUSH
50426: EMPTY
50427: LIST
50428: LIST
50429: PPUSH
50430: CALL_OW 72
50434: ST_TO_ADDR
// if f_repair then
50435: LD_VAR 0 22
50439: IFFALSE 50466
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
50441: LD_ADDR_VAR 0 33
50445: PUSH
50446: LD_VAR 0 4
50450: PPUSH
50451: LD_INT 25
50453: PUSH
50454: LD_INT 3
50456: PUSH
50457: EMPTY
50458: LIST
50459: LIST
50460: PPUSH
50461: CALL_OW 72
50465: ST_TO_ADDR
// units_path := [ ] ;
50466: LD_ADDR_VAR 0 16
50470: PUSH
50471: EMPTY
50472: ST_TO_ADDR
// for i = 1 to group do
50473: LD_ADDR_VAR 0 7
50477: PUSH
50478: DOUBLE
50479: LD_INT 1
50481: DEC
50482: ST_TO_ADDR
50483: LD_VAR 0 4
50487: PUSH
50488: FOR_TO
50489: IFFALSE 50518
// units_path := Replace ( units_path , i , path ) ;
50491: LD_ADDR_VAR 0 16
50495: PUSH
50496: LD_VAR 0 16
50500: PPUSH
50501: LD_VAR 0 7
50505: PPUSH
50506: LD_VAR 0 5
50510: PPUSH
50511: CALL_OW 1
50515: ST_TO_ADDR
50516: GO 50488
50518: POP
50519: POP
// repeat for i = group downto 1 do
50520: LD_ADDR_VAR 0 7
50524: PUSH
50525: DOUBLE
50526: LD_VAR 0 4
50530: INC
50531: ST_TO_ADDR
50532: LD_INT 1
50534: PUSH
50535: FOR_DOWNTO
50536: IFFALSE 54658
// begin wait ( 5 ) ;
50538: LD_INT 5
50540: PPUSH
50541: CALL_OW 67
// tmp := [ ] ;
50545: LD_ADDR_VAR 0 14
50549: PUSH
50550: EMPTY
50551: ST_TO_ADDR
// attacking := false ;
50552: LD_ADDR_VAR 0 29
50556: PUSH
50557: LD_INT 0
50559: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
50560: LD_VAR 0 4
50564: PUSH
50565: LD_VAR 0 7
50569: ARRAY
50570: PPUSH
50571: CALL_OW 301
50575: PUSH
50576: LD_VAR 0 4
50580: PUSH
50581: LD_VAR 0 7
50585: ARRAY
50586: NOT
50587: OR
50588: IFFALSE 50697
// begin if GetType ( group [ i ] ) = unit_human then
50590: LD_VAR 0 4
50594: PUSH
50595: LD_VAR 0 7
50599: ARRAY
50600: PPUSH
50601: CALL_OW 247
50605: PUSH
50606: LD_INT 1
50608: EQUAL
50609: IFFALSE 50655
// begin to_heal := to_heal diff group [ i ] ;
50611: LD_ADDR_VAR 0 30
50615: PUSH
50616: LD_VAR 0 30
50620: PUSH
50621: LD_VAR 0 4
50625: PUSH
50626: LD_VAR 0 7
50630: ARRAY
50631: DIFF
50632: ST_TO_ADDR
// healers := healers diff group [ i ] ;
50633: LD_ADDR_VAR 0 31
50637: PUSH
50638: LD_VAR 0 31
50642: PUSH
50643: LD_VAR 0 4
50647: PUSH
50648: LD_VAR 0 7
50652: ARRAY
50653: DIFF
50654: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
50655: LD_ADDR_VAR 0 4
50659: PUSH
50660: LD_VAR 0 4
50664: PPUSH
50665: LD_VAR 0 7
50669: PPUSH
50670: CALL_OW 3
50674: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
50675: LD_ADDR_VAR 0 16
50679: PUSH
50680: LD_VAR 0 16
50684: PPUSH
50685: LD_VAR 0 7
50689: PPUSH
50690: CALL_OW 3
50694: ST_TO_ADDR
// continue ;
50695: GO 50535
// end ; if f_repair then
50697: LD_VAR 0 22
50701: IFFALSE 51190
// begin if GetType ( group [ i ] ) = unit_vehicle then
50703: LD_VAR 0 4
50707: PUSH
50708: LD_VAR 0 7
50712: ARRAY
50713: PPUSH
50714: CALL_OW 247
50718: PUSH
50719: LD_INT 2
50721: EQUAL
50722: IFFALSE 50912
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
50724: LD_VAR 0 4
50728: PUSH
50729: LD_VAR 0 7
50733: ARRAY
50734: PPUSH
50735: CALL_OW 256
50739: PUSH
50740: LD_INT 700
50742: LESS
50743: PUSH
50744: LD_VAR 0 4
50748: PUSH
50749: LD_VAR 0 7
50753: ARRAY
50754: PUSH
50755: LD_VAR 0 32
50759: IN
50760: NOT
50761: AND
50762: IFFALSE 50786
// to_repair := to_repair union group [ i ] ;
50764: LD_ADDR_VAR 0 32
50768: PUSH
50769: LD_VAR 0 32
50773: PUSH
50774: LD_VAR 0 4
50778: PUSH
50779: LD_VAR 0 7
50783: ARRAY
50784: UNION
50785: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
50786: LD_VAR 0 4
50790: PUSH
50791: LD_VAR 0 7
50795: ARRAY
50796: PPUSH
50797: CALL_OW 256
50801: PUSH
50802: LD_INT 1000
50804: EQUAL
50805: PUSH
50806: LD_VAR 0 4
50810: PUSH
50811: LD_VAR 0 7
50815: ARRAY
50816: PUSH
50817: LD_VAR 0 32
50821: IN
50822: AND
50823: IFFALSE 50847
// to_repair := to_repair diff group [ i ] ;
50825: LD_ADDR_VAR 0 32
50829: PUSH
50830: LD_VAR 0 32
50834: PUSH
50835: LD_VAR 0 4
50839: PUSH
50840: LD_VAR 0 7
50844: ARRAY
50845: DIFF
50846: ST_TO_ADDR
// if group [ i ] in to_repair then
50847: LD_VAR 0 4
50851: PUSH
50852: LD_VAR 0 7
50856: ARRAY
50857: PUSH
50858: LD_VAR 0 32
50862: IN
50863: IFFALSE 50910
// begin if not IsInArea ( group [ i ] , f_repair ) then
50865: LD_VAR 0 4
50869: PUSH
50870: LD_VAR 0 7
50874: ARRAY
50875: PPUSH
50876: LD_VAR 0 22
50880: PPUSH
50881: CALL_OW 308
50885: NOT
50886: IFFALSE 50908
// ComMoveToArea ( group [ i ] , f_repair ) ;
50888: LD_VAR 0 4
50892: PUSH
50893: LD_VAR 0 7
50897: ARRAY
50898: PPUSH
50899: LD_VAR 0 22
50903: PPUSH
50904: CALL_OW 113
// continue ;
50908: GO 50535
// end ; end else
50910: GO 51190
// if group [ i ] in repairs then
50912: LD_VAR 0 4
50916: PUSH
50917: LD_VAR 0 7
50921: ARRAY
50922: PUSH
50923: LD_VAR 0 33
50927: IN
50928: IFFALSE 51190
// begin if IsInUnit ( group [ i ] ) then
50930: LD_VAR 0 4
50934: PUSH
50935: LD_VAR 0 7
50939: ARRAY
50940: PPUSH
50941: CALL_OW 310
50945: IFFALSE 51013
// begin z := IsInUnit ( group [ i ] ) ;
50947: LD_ADDR_VAR 0 13
50951: PUSH
50952: LD_VAR 0 4
50956: PUSH
50957: LD_VAR 0 7
50961: ARRAY
50962: PPUSH
50963: CALL_OW 310
50967: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50968: LD_VAR 0 13
50972: PUSH
50973: LD_VAR 0 32
50977: IN
50978: PUSH
50979: LD_VAR 0 13
50983: PPUSH
50984: LD_VAR 0 22
50988: PPUSH
50989: CALL_OW 308
50993: AND
50994: IFFALSE 51011
// ComExitVehicle ( group [ i ] ) ;
50996: LD_VAR 0 4
51000: PUSH
51001: LD_VAR 0 7
51005: ARRAY
51006: PPUSH
51007: CALL_OW 121
// end else
51011: GO 51190
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
51013: LD_ADDR_VAR 0 13
51017: PUSH
51018: LD_VAR 0 4
51022: PPUSH
51023: LD_INT 95
51025: PUSH
51026: LD_VAR 0 22
51030: PUSH
51031: EMPTY
51032: LIST
51033: LIST
51034: PUSH
51035: LD_INT 58
51037: PUSH
51038: EMPTY
51039: LIST
51040: PUSH
51041: EMPTY
51042: LIST
51043: LIST
51044: PPUSH
51045: CALL_OW 72
51049: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
51050: LD_VAR 0 4
51054: PUSH
51055: LD_VAR 0 7
51059: ARRAY
51060: PPUSH
51061: CALL_OW 314
51065: NOT
51066: IFFALSE 51188
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
51068: LD_ADDR_VAR 0 10
51072: PUSH
51073: LD_VAR 0 13
51077: PPUSH
51078: LD_VAR 0 4
51082: PUSH
51083: LD_VAR 0 7
51087: ARRAY
51088: PPUSH
51089: CALL_OW 74
51093: ST_TO_ADDR
// if not x then
51094: LD_VAR 0 10
51098: NOT
51099: IFFALSE 51103
// continue ;
51101: GO 50535
// if GetLives ( x ) < 1000 then
51103: LD_VAR 0 10
51107: PPUSH
51108: CALL_OW 256
51112: PUSH
51113: LD_INT 1000
51115: LESS
51116: IFFALSE 51140
// ComRepairVehicle ( group [ i ] , x ) else
51118: LD_VAR 0 4
51122: PUSH
51123: LD_VAR 0 7
51127: ARRAY
51128: PPUSH
51129: LD_VAR 0 10
51133: PPUSH
51134: CALL_OW 129
51138: GO 51188
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
51140: LD_VAR 0 23
51144: PUSH
51145: LD_VAR 0 4
51149: PUSH
51150: LD_VAR 0 7
51154: ARRAY
51155: PPUSH
51156: CALL_OW 256
51160: PUSH
51161: LD_INT 1000
51163: LESS
51164: AND
51165: NOT
51166: IFFALSE 51188
// ComEnterUnit ( group [ i ] , x ) ;
51168: LD_VAR 0 4
51172: PUSH
51173: LD_VAR 0 7
51177: ARRAY
51178: PPUSH
51179: LD_VAR 0 10
51183: PPUSH
51184: CALL_OW 120
// end ; continue ;
51188: GO 50535
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
51190: LD_VAR 0 23
51194: PUSH
51195: LD_VAR 0 4
51199: PUSH
51200: LD_VAR 0 7
51204: ARRAY
51205: PPUSH
51206: CALL_OW 247
51210: PUSH
51211: LD_INT 1
51213: EQUAL
51214: AND
51215: IFFALSE 51693
// begin if group [ i ] in healers then
51217: LD_VAR 0 4
51221: PUSH
51222: LD_VAR 0 7
51226: ARRAY
51227: PUSH
51228: LD_VAR 0 31
51232: IN
51233: IFFALSE 51506
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
51235: LD_VAR 0 4
51239: PUSH
51240: LD_VAR 0 7
51244: ARRAY
51245: PPUSH
51246: LD_VAR 0 23
51250: PPUSH
51251: CALL_OW 308
51255: NOT
51256: PUSH
51257: LD_VAR 0 4
51261: PUSH
51262: LD_VAR 0 7
51266: ARRAY
51267: PPUSH
51268: CALL_OW 314
51272: NOT
51273: AND
51274: IFFALSE 51298
// ComMoveToArea ( group [ i ] , f_heal ) else
51276: LD_VAR 0 4
51280: PUSH
51281: LD_VAR 0 7
51285: ARRAY
51286: PPUSH
51287: LD_VAR 0 23
51291: PPUSH
51292: CALL_OW 113
51296: GO 51504
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
51298: LD_VAR 0 4
51302: PUSH
51303: LD_VAR 0 7
51307: ARRAY
51308: PPUSH
51309: CALL 49916 0 1
51313: PPUSH
51314: CALL_OW 256
51318: PUSH
51319: LD_INT 1000
51321: EQUAL
51322: IFFALSE 51341
// ComStop ( group [ i ] ) else
51324: LD_VAR 0 4
51328: PUSH
51329: LD_VAR 0 7
51333: ARRAY
51334: PPUSH
51335: CALL_OW 141
51339: GO 51504
// if not HasTask ( group [ i ] ) and to_heal then
51341: LD_VAR 0 4
51345: PUSH
51346: LD_VAR 0 7
51350: ARRAY
51351: PPUSH
51352: CALL_OW 314
51356: NOT
51357: PUSH
51358: LD_VAR 0 30
51362: AND
51363: IFFALSE 51504
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
51365: LD_ADDR_VAR 0 13
51369: PUSH
51370: LD_VAR 0 30
51374: PPUSH
51375: LD_INT 3
51377: PUSH
51378: LD_INT 54
51380: PUSH
51381: EMPTY
51382: LIST
51383: PUSH
51384: EMPTY
51385: LIST
51386: LIST
51387: PPUSH
51388: CALL_OW 72
51392: PPUSH
51393: LD_VAR 0 4
51397: PUSH
51398: LD_VAR 0 7
51402: ARRAY
51403: PPUSH
51404: CALL_OW 74
51408: ST_TO_ADDR
// if z then
51409: LD_VAR 0 13
51413: IFFALSE 51504
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
51415: LD_INT 91
51417: PUSH
51418: LD_VAR 0 13
51422: PUSH
51423: LD_INT 10
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: LIST
51430: PUSH
51431: LD_INT 81
51433: PUSH
51434: LD_VAR 0 13
51438: PPUSH
51439: CALL_OW 255
51443: PUSH
51444: EMPTY
51445: LIST
51446: LIST
51447: PUSH
51448: EMPTY
51449: LIST
51450: LIST
51451: PPUSH
51452: CALL_OW 69
51456: PUSH
51457: LD_INT 0
51459: EQUAL
51460: IFFALSE 51484
// ComHeal ( group [ i ] , z ) else
51462: LD_VAR 0 4
51466: PUSH
51467: LD_VAR 0 7
51471: ARRAY
51472: PPUSH
51473: LD_VAR 0 13
51477: PPUSH
51478: CALL_OW 128
51482: GO 51504
// ComMoveToArea ( group [ i ] , f_heal ) ;
51484: LD_VAR 0 4
51488: PUSH
51489: LD_VAR 0 7
51493: ARRAY
51494: PPUSH
51495: LD_VAR 0 23
51499: PPUSH
51500: CALL_OW 113
// end ; continue ;
51504: GO 50535
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
51506: LD_VAR 0 4
51510: PUSH
51511: LD_VAR 0 7
51515: ARRAY
51516: PPUSH
51517: CALL_OW 256
51521: PUSH
51522: LD_INT 700
51524: LESS
51525: PUSH
51526: LD_VAR 0 4
51530: PUSH
51531: LD_VAR 0 7
51535: ARRAY
51536: PUSH
51537: LD_VAR 0 30
51541: IN
51542: NOT
51543: AND
51544: IFFALSE 51568
// to_heal := to_heal union group [ i ] ;
51546: LD_ADDR_VAR 0 30
51550: PUSH
51551: LD_VAR 0 30
51555: PUSH
51556: LD_VAR 0 4
51560: PUSH
51561: LD_VAR 0 7
51565: ARRAY
51566: UNION
51567: ST_TO_ADDR
// if group [ i ] in to_heal then
51568: LD_VAR 0 4
51572: PUSH
51573: LD_VAR 0 7
51577: ARRAY
51578: PUSH
51579: LD_VAR 0 30
51583: IN
51584: IFFALSE 51693
// begin if GetLives ( group [ i ] ) = 1000 then
51586: LD_VAR 0 4
51590: PUSH
51591: LD_VAR 0 7
51595: ARRAY
51596: PPUSH
51597: CALL_OW 256
51601: PUSH
51602: LD_INT 1000
51604: EQUAL
51605: IFFALSE 51631
// to_heal := to_heal diff group [ i ] else
51607: LD_ADDR_VAR 0 30
51611: PUSH
51612: LD_VAR 0 30
51616: PUSH
51617: LD_VAR 0 4
51621: PUSH
51622: LD_VAR 0 7
51626: ARRAY
51627: DIFF
51628: ST_TO_ADDR
51629: GO 51693
// begin if not IsInArea ( group [ i ] , to_heal ) then
51631: LD_VAR 0 4
51635: PUSH
51636: LD_VAR 0 7
51640: ARRAY
51641: PPUSH
51642: LD_VAR 0 30
51646: PPUSH
51647: CALL_OW 308
51651: NOT
51652: IFFALSE 51676
// ComMoveToArea ( group [ i ] , f_heal ) else
51654: LD_VAR 0 4
51658: PUSH
51659: LD_VAR 0 7
51663: ARRAY
51664: PPUSH
51665: LD_VAR 0 23
51669: PPUSH
51670: CALL_OW 113
51674: GO 51691
// ComHold ( group [ i ] ) ;
51676: LD_VAR 0 4
51680: PUSH
51681: LD_VAR 0 7
51685: ARRAY
51686: PPUSH
51687: CALL_OW 140
// continue ;
51691: GO 50535
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
51693: LD_VAR 0 4
51697: PUSH
51698: LD_VAR 0 7
51702: ARRAY
51703: PPUSH
51704: LD_INT 10
51706: PPUSH
51707: CALL 48313 0 2
51711: NOT
51712: PUSH
51713: LD_VAR 0 16
51717: PUSH
51718: LD_VAR 0 7
51722: ARRAY
51723: PUSH
51724: EMPTY
51725: EQUAL
51726: NOT
51727: AND
51728: IFFALSE 51994
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
51730: LD_VAR 0 4
51734: PUSH
51735: LD_VAR 0 7
51739: ARRAY
51740: PPUSH
51741: CALL_OW 262
51745: PUSH
51746: LD_INT 1
51748: PUSH
51749: LD_INT 2
51751: PUSH
51752: EMPTY
51753: LIST
51754: LIST
51755: IN
51756: IFFALSE 51797
// if GetFuel ( group [ i ] ) < 10 then
51758: LD_VAR 0 4
51762: PUSH
51763: LD_VAR 0 7
51767: ARRAY
51768: PPUSH
51769: CALL_OW 261
51773: PUSH
51774: LD_INT 10
51776: LESS
51777: IFFALSE 51797
// SetFuel ( group [ i ] , 12 ) ;
51779: LD_VAR 0 4
51783: PUSH
51784: LD_VAR 0 7
51788: ARRAY
51789: PPUSH
51790: LD_INT 12
51792: PPUSH
51793: CALL_OW 240
// if units_path [ i ] then
51797: LD_VAR 0 16
51801: PUSH
51802: LD_VAR 0 7
51806: ARRAY
51807: IFFALSE 51992
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
51809: LD_VAR 0 4
51813: PUSH
51814: LD_VAR 0 7
51818: ARRAY
51819: PPUSH
51820: LD_VAR 0 16
51824: PUSH
51825: LD_VAR 0 7
51829: ARRAY
51830: PUSH
51831: LD_INT 1
51833: ARRAY
51834: PUSH
51835: LD_INT 1
51837: ARRAY
51838: PPUSH
51839: LD_VAR 0 16
51843: PUSH
51844: LD_VAR 0 7
51848: ARRAY
51849: PUSH
51850: LD_INT 1
51852: ARRAY
51853: PUSH
51854: LD_INT 2
51856: ARRAY
51857: PPUSH
51858: CALL_OW 297
51862: PUSH
51863: LD_INT 6
51865: GREATER
51866: IFFALSE 51941
// begin if not HasTask ( group [ i ] ) then
51868: LD_VAR 0 4
51872: PUSH
51873: LD_VAR 0 7
51877: ARRAY
51878: PPUSH
51879: CALL_OW 314
51883: NOT
51884: IFFALSE 51939
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51886: LD_VAR 0 4
51890: PUSH
51891: LD_VAR 0 7
51895: ARRAY
51896: PPUSH
51897: LD_VAR 0 16
51901: PUSH
51902: LD_VAR 0 7
51906: ARRAY
51907: PUSH
51908: LD_INT 1
51910: ARRAY
51911: PUSH
51912: LD_INT 1
51914: ARRAY
51915: PPUSH
51916: LD_VAR 0 16
51920: PUSH
51921: LD_VAR 0 7
51925: ARRAY
51926: PUSH
51927: LD_INT 1
51929: ARRAY
51930: PUSH
51931: LD_INT 2
51933: ARRAY
51934: PPUSH
51935: CALL_OW 114
// end else
51939: GO 51992
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51941: LD_ADDR_VAR 0 15
51945: PUSH
51946: LD_VAR 0 16
51950: PUSH
51951: LD_VAR 0 7
51955: ARRAY
51956: PPUSH
51957: LD_INT 1
51959: PPUSH
51960: CALL_OW 3
51964: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51965: LD_ADDR_VAR 0 16
51969: PUSH
51970: LD_VAR 0 16
51974: PPUSH
51975: LD_VAR 0 7
51979: PPUSH
51980: LD_VAR 0 15
51984: PPUSH
51985: CALL_OW 1
51989: ST_TO_ADDR
// continue ;
51990: GO 50535
// end ; end ; end else
51992: GO 54656
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51994: LD_ADDR_VAR 0 14
51998: PUSH
51999: LD_INT 81
52001: PUSH
52002: LD_VAR 0 4
52006: PUSH
52007: LD_VAR 0 7
52011: ARRAY
52012: PPUSH
52013: CALL_OW 255
52017: PUSH
52018: EMPTY
52019: LIST
52020: LIST
52021: PPUSH
52022: CALL_OW 69
52026: ST_TO_ADDR
// if not tmp then
52027: LD_VAR 0 14
52031: NOT
52032: IFFALSE 52036
// continue ;
52034: GO 50535
// if f_ignore_area then
52036: LD_VAR 0 17
52040: IFFALSE 52128
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
52042: LD_ADDR_VAR 0 15
52046: PUSH
52047: LD_VAR 0 14
52051: PPUSH
52052: LD_INT 3
52054: PUSH
52055: LD_INT 92
52057: PUSH
52058: LD_VAR 0 17
52062: PUSH
52063: LD_INT 1
52065: ARRAY
52066: PUSH
52067: LD_VAR 0 17
52071: PUSH
52072: LD_INT 2
52074: ARRAY
52075: PUSH
52076: LD_VAR 0 17
52080: PUSH
52081: LD_INT 3
52083: ARRAY
52084: PUSH
52085: EMPTY
52086: LIST
52087: LIST
52088: LIST
52089: LIST
52090: PUSH
52091: EMPTY
52092: LIST
52093: LIST
52094: PPUSH
52095: CALL_OW 72
52099: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
52100: LD_VAR 0 14
52104: PUSH
52105: LD_VAR 0 15
52109: DIFF
52110: IFFALSE 52128
// tmp := tmp diff tmp2 ;
52112: LD_ADDR_VAR 0 14
52116: PUSH
52117: LD_VAR 0 14
52121: PUSH
52122: LD_VAR 0 15
52126: DIFF
52127: ST_TO_ADDR
// end ; if not f_murder then
52128: LD_VAR 0 20
52132: NOT
52133: IFFALSE 52191
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
52135: LD_ADDR_VAR 0 15
52139: PUSH
52140: LD_VAR 0 14
52144: PPUSH
52145: LD_INT 3
52147: PUSH
52148: LD_INT 50
52150: PUSH
52151: EMPTY
52152: LIST
52153: PUSH
52154: EMPTY
52155: LIST
52156: LIST
52157: PPUSH
52158: CALL_OW 72
52162: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
52163: LD_VAR 0 14
52167: PUSH
52168: LD_VAR 0 15
52172: DIFF
52173: IFFALSE 52191
// tmp := tmp diff tmp2 ;
52175: LD_ADDR_VAR 0 14
52179: PUSH
52180: LD_VAR 0 14
52184: PUSH
52185: LD_VAR 0 15
52189: DIFF
52190: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
52191: LD_ADDR_VAR 0 14
52195: PUSH
52196: LD_VAR 0 4
52200: PUSH
52201: LD_VAR 0 7
52205: ARRAY
52206: PPUSH
52207: LD_VAR 0 14
52211: PPUSH
52212: LD_INT 1
52214: PPUSH
52215: LD_INT 1
52217: PPUSH
52218: CALL 21956 0 4
52222: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
52223: LD_VAR 0 4
52227: PUSH
52228: LD_VAR 0 7
52232: ARRAY
52233: PPUSH
52234: CALL_OW 257
52238: PUSH
52239: LD_INT 1
52241: EQUAL
52242: IFFALSE 52690
// begin if WantPlant ( group [ i ] ) then
52244: LD_VAR 0 4
52248: PUSH
52249: LD_VAR 0 7
52253: ARRAY
52254: PPUSH
52255: CALL 21457 0 1
52259: IFFALSE 52263
// continue ;
52261: GO 50535
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
52263: LD_VAR 0 18
52267: PUSH
52268: LD_VAR 0 4
52272: PUSH
52273: LD_VAR 0 7
52277: ARRAY
52278: PPUSH
52279: CALL_OW 310
52283: NOT
52284: AND
52285: PUSH
52286: LD_VAR 0 14
52290: PUSH
52291: LD_INT 1
52293: ARRAY
52294: PUSH
52295: LD_VAR 0 14
52299: PPUSH
52300: LD_INT 21
52302: PUSH
52303: LD_INT 2
52305: PUSH
52306: EMPTY
52307: LIST
52308: LIST
52309: PUSH
52310: LD_INT 58
52312: PUSH
52313: EMPTY
52314: LIST
52315: PUSH
52316: EMPTY
52317: LIST
52318: LIST
52319: PPUSH
52320: CALL_OW 72
52324: IN
52325: AND
52326: IFFALSE 52362
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
52328: LD_VAR 0 4
52332: PUSH
52333: LD_VAR 0 7
52337: ARRAY
52338: PPUSH
52339: LD_VAR 0 14
52343: PUSH
52344: LD_INT 1
52346: ARRAY
52347: PPUSH
52348: CALL_OW 120
// attacking := true ;
52352: LD_ADDR_VAR 0 29
52356: PUSH
52357: LD_INT 1
52359: ST_TO_ADDR
// continue ;
52360: GO 50535
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
52362: LD_VAR 0 26
52366: PUSH
52367: LD_VAR 0 4
52371: PUSH
52372: LD_VAR 0 7
52376: ARRAY
52377: PPUSH
52378: CALL_OW 257
52382: PUSH
52383: LD_INT 1
52385: EQUAL
52386: AND
52387: PUSH
52388: LD_VAR 0 4
52392: PUSH
52393: LD_VAR 0 7
52397: ARRAY
52398: PPUSH
52399: CALL_OW 256
52403: PUSH
52404: LD_INT 800
52406: LESS
52407: AND
52408: PUSH
52409: LD_VAR 0 4
52413: PUSH
52414: LD_VAR 0 7
52418: ARRAY
52419: PPUSH
52420: CALL_OW 318
52424: NOT
52425: AND
52426: IFFALSE 52443
// ComCrawl ( group [ i ] ) ;
52428: LD_VAR 0 4
52432: PUSH
52433: LD_VAR 0 7
52437: ARRAY
52438: PPUSH
52439: CALL_OW 137
// if f_mines then
52443: LD_VAR 0 21
52447: IFFALSE 52690
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
52449: LD_VAR 0 14
52453: PUSH
52454: LD_INT 1
52456: ARRAY
52457: PPUSH
52458: CALL_OW 247
52462: PUSH
52463: LD_INT 3
52465: EQUAL
52466: PUSH
52467: LD_VAR 0 14
52471: PUSH
52472: LD_INT 1
52474: ARRAY
52475: PUSH
52476: LD_VAR 0 27
52480: IN
52481: NOT
52482: AND
52483: IFFALSE 52690
// begin x := GetX ( tmp [ 1 ] ) ;
52485: LD_ADDR_VAR 0 10
52489: PUSH
52490: LD_VAR 0 14
52494: PUSH
52495: LD_INT 1
52497: ARRAY
52498: PPUSH
52499: CALL_OW 250
52503: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
52504: LD_ADDR_VAR 0 11
52508: PUSH
52509: LD_VAR 0 14
52513: PUSH
52514: LD_INT 1
52516: ARRAY
52517: PPUSH
52518: CALL_OW 251
52522: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
52523: LD_ADDR_VAR 0 12
52527: PUSH
52528: LD_VAR 0 4
52532: PUSH
52533: LD_VAR 0 7
52537: ARRAY
52538: PPUSH
52539: CALL 48398 0 1
52543: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
52544: LD_VAR 0 4
52548: PUSH
52549: LD_VAR 0 7
52553: ARRAY
52554: PPUSH
52555: LD_VAR 0 10
52559: PPUSH
52560: LD_VAR 0 11
52564: PPUSH
52565: LD_VAR 0 14
52569: PUSH
52570: LD_INT 1
52572: ARRAY
52573: PPUSH
52574: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
52578: LD_VAR 0 4
52582: PUSH
52583: LD_VAR 0 7
52587: ARRAY
52588: PPUSH
52589: LD_VAR 0 10
52593: PPUSH
52594: LD_VAR 0 12
52598: PPUSH
52599: LD_INT 7
52601: PPUSH
52602: CALL_OW 272
52606: PPUSH
52607: LD_VAR 0 11
52611: PPUSH
52612: LD_VAR 0 12
52616: PPUSH
52617: LD_INT 7
52619: PPUSH
52620: CALL_OW 273
52624: PPUSH
52625: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
52629: LD_VAR 0 4
52633: PUSH
52634: LD_VAR 0 7
52638: ARRAY
52639: PPUSH
52640: LD_INT 71
52642: PPUSH
52643: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
52647: LD_ADDR_VAR 0 27
52651: PUSH
52652: LD_VAR 0 27
52656: PPUSH
52657: LD_VAR 0 27
52661: PUSH
52662: LD_INT 1
52664: PLUS
52665: PPUSH
52666: LD_VAR 0 14
52670: PUSH
52671: LD_INT 1
52673: ARRAY
52674: PPUSH
52675: CALL_OW 1
52679: ST_TO_ADDR
// attacking := true ;
52680: LD_ADDR_VAR 0 29
52684: PUSH
52685: LD_INT 1
52687: ST_TO_ADDR
// continue ;
52688: GO 50535
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
52690: LD_VAR 0 4
52694: PUSH
52695: LD_VAR 0 7
52699: ARRAY
52700: PPUSH
52701: CALL_OW 257
52705: PUSH
52706: LD_INT 17
52708: EQUAL
52709: PUSH
52710: LD_VAR 0 4
52714: PUSH
52715: LD_VAR 0 7
52719: ARRAY
52720: PPUSH
52721: CALL_OW 110
52725: PUSH
52726: LD_INT 71
52728: EQUAL
52729: NOT
52730: AND
52731: IFFALSE 52877
// begin attacking := false ;
52733: LD_ADDR_VAR 0 29
52737: PUSH
52738: LD_INT 0
52740: ST_TO_ADDR
// k := 5 ;
52741: LD_ADDR_VAR 0 9
52745: PUSH
52746: LD_INT 5
52748: ST_TO_ADDR
// if tmp < k then
52749: LD_VAR 0 14
52753: PUSH
52754: LD_VAR 0 9
52758: LESS
52759: IFFALSE 52771
// k := tmp ;
52761: LD_ADDR_VAR 0 9
52765: PUSH
52766: LD_VAR 0 14
52770: ST_TO_ADDR
// for j = 1 to k do
52771: LD_ADDR_VAR 0 8
52775: PUSH
52776: DOUBLE
52777: LD_INT 1
52779: DEC
52780: ST_TO_ADDR
52781: LD_VAR 0 9
52785: PUSH
52786: FOR_TO
52787: IFFALSE 52875
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
52789: LD_VAR 0 14
52793: PUSH
52794: LD_VAR 0 8
52798: ARRAY
52799: PUSH
52800: LD_VAR 0 14
52804: PPUSH
52805: LD_INT 58
52807: PUSH
52808: EMPTY
52809: LIST
52810: PPUSH
52811: CALL_OW 72
52815: IN
52816: NOT
52817: IFFALSE 52873
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52819: LD_VAR 0 4
52823: PUSH
52824: LD_VAR 0 7
52828: ARRAY
52829: PPUSH
52830: LD_VAR 0 14
52834: PUSH
52835: LD_VAR 0 8
52839: ARRAY
52840: PPUSH
52841: CALL_OW 115
// attacking := true ;
52845: LD_ADDR_VAR 0 29
52849: PUSH
52850: LD_INT 1
52852: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
52853: LD_VAR 0 4
52857: PUSH
52858: LD_VAR 0 7
52862: ARRAY
52863: PPUSH
52864: LD_INT 71
52866: PPUSH
52867: CALL_OW 109
// continue ;
52871: GO 52786
// end ; end ;
52873: GO 52786
52875: POP
52876: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
52877: LD_VAR 0 4
52881: PUSH
52882: LD_VAR 0 7
52886: ARRAY
52887: PPUSH
52888: CALL_OW 257
52892: PUSH
52893: LD_INT 8
52895: EQUAL
52896: PUSH
52897: LD_VAR 0 4
52901: PUSH
52902: LD_VAR 0 7
52906: ARRAY
52907: PPUSH
52908: CALL_OW 264
52912: PUSH
52913: LD_INT 28
52915: PUSH
52916: LD_INT 45
52918: PUSH
52919: LD_INT 7
52921: PUSH
52922: LD_INT 47
52924: PUSH
52925: EMPTY
52926: LIST
52927: LIST
52928: LIST
52929: LIST
52930: IN
52931: OR
52932: IFFALSE 53188
// begin attacking := false ;
52934: LD_ADDR_VAR 0 29
52938: PUSH
52939: LD_INT 0
52941: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52942: LD_VAR 0 14
52946: PUSH
52947: LD_INT 1
52949: ARRAY
52950: PPUSH
52951: CALL_OW 266
52955: PUSH
52956: LD_INT 32
52958: PUSH
52959: LD_INT 31
52961: PUSH
52962: LD_INT 33
52964: PUSH
52965: LD_INT 4
52967: PUSH
52968: LD_INT 5
52970: PUSH
52971: EMPTY
52972: LIST
52973: LIST
52974: LIST
52975: LIST
52976: LIST
52977: IN
52978: IFFALSE 53164
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52980: LD_ADDR_VAR 0 9
52984: PUSH
52985: LD_VAR 0 14
52989: PUSH
52990: LD_INT 1
52992: ARRAY
52993: PPUSH
52994: CALL_OW 266
52998: PPUSH
52999: LD_VAR 0 14
53003: PUSH
53004: LD_INT 1
53006: ARRAY
53007: PPUSH
53008: CALL_OW 250
53012: PPUSH
53013: LD_VAR 0 14
53017: PUSH
53018: LD_INT 1
53020: ARRAY
53021: PPUSH
53022: CALL_OW 251
53026: PPUSH
53027: LD_VAR 0 14
53031: PUSH
53032: LD_INT 1
53034: ARRAY
53035: PPUSH
53036: CALL_OW 254
53040: PPUSH
53041: LD_VAR 0 14
53045: PUSH
53046: LD_INT 1
53048: ARRAY
53049: PPUSH
53050: CALL_OW 248
53054: PPUSH
53055: LD_INT 0
53057: PPUSH
53058: CALL 29768 0 6
53062: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
53063: LD_ADDR_VAR 0 8
53067: PUSH
53068: LD_VAR 0 4
53072: PUSH
53073: LD_VAR 0 7
53077: ARRAY
53078: PPUSH
53079: LD_VAR 0 9
53083: PPUSH
53084: CALL 48461 0 2
53088: ST_TO_ADDR
// if j then
53089: LD_VAR 0 8
53093: IFFALSE 53162
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
53095: LD_VAR 0 8
53099: PUSH
53100: LD_INT 1
53102: ARRAY
53103: PPUSH
53104: LD_VAR 0 8
53108: PUSH
53109: LD_INT 2
53111: ARRAY
53112: PPUSH
53113: CALL_OW 488
53117: IFFALSE 53162
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
53119: LD_VAR 0 4
53123: PUSH
53124: LD_VAR 0 7
53128: ARRAY
53129: PPUSH
53130: LD_VAR 0 8
53134: PUSH
53135: LD_INT 1
53137: ARRAY
53138: PPUSH
53139: LD_VAR 0 8
53143: PUSH
53144: LD_INT 2
53146: ARRAY
53147: PPUSH
53148: CALL_OW 116
// attacking := true ;
53152: LD_ADDR_VAR 0 29
53156: PUSH
53157: LD_INT 1
53159: ST_TO_ADDR
// continue ;
53160: GO 50535
// end ; end else
53162: GO 53188
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53164: LD_VAR 0 4
53168: PUSH
53169: LD_VAR 0 7
53173: ARRAY
53174: PPUSH
53175: LD_VAR 0 14
53179: PUSH
53180: LD_INT 1
53182: ARRAY
53183: PPUSH
53184: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
53188: LD_VAR 0 4
53192: PUSH
53193: LD_VAR 0 7
53197: ARRAY
53198: PPUSH
53199: CALL_OW 265
53203: PUSH
53204: LD_INT 11
53206: EQUAL
53207: IFFALSE 53485
// begin k := 10 ;
53209: LD_ADDR_VAR 0 9
53213: PUSH
53214: LD_INT 10
53216: ST_TO_ADDR
// x := 0 ;
53217: LD_ADDR_VAR 0 10
53221: PUSH
53222: LD_INT 0
53224: ST_TO_ADDR
// if tmp < k then
53225: LD_VAR 0 14
53229: PUSH
53230: LD_VAR 0 9
53234: LESS
53235: IFFALSE 53247
// k := tmp ;
53237: LD_ADDR_VAR 0 9
53241: PUSH
53242: LD_VAR 0 14
53246: ST_TO_ADDR
// for j = k downto 1 do
53247: LD_ADDR_VAR 0 8
53251: PUSH
53252: DOUBLE
53253: LD_VAR 0 9
53257: INC
53258: ST_TO_ADDR
53259: LD_INT 1
53261: PUSH
53262: FOR_DOWNTO
53263: IFFALSE 53338
// begin if GetType ( tmp [ j ] ) = unit_human then
53265: LD_VAR 0 14
53269: PUSH
53270: LD_VAR 0 8
53274: ARRAY
53275: PPUSH
53276: CALL_OW 247
53280: PUSH
53281: LD_INT 1
53283: EQUAL
53284: IFFALSE 53336
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
53286: LD_VAR 0 4
53290: PUSH
53291: LD_VAR 0 7
53295: ARRAY
53296: PPUSH
53297: LD_VAR 0 14
53301: PUSH
53302: LD_VAR 0 8
53306: ARRAY
53307: PPUSH
53308: CALL 48732 0 2
// x := tmp [ j ] ;
53312: LD_ADDR_VAR 0 10
53316: PUSH
53317: LD_VAR 0 14
53321: PUSH
53322: LD_VAR 0 8
53326: ARRAY
53327: ST_TO_ADDR
// attacking := true ;
53328: LD_ADDR_VAR 0 29
53332: PUSH
53333: LD_INT 1
53335: ST_TO_ADDR
// end ; end ;
53336: GO 53262
53338: POP
53339: POP
// if not x then
53340: LD_VAR 0 10
53344: NOT
53345: IFFALSE 53485
// begin attacking := true ;
53347: LD_ADDR_VAR 0 29
53351: PUSH
53352: LD_INT 1
53354: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
53355: LD_VAR 0 4
53359: PUSH
53360: LD_VAR 0 7
53364: ARRAY
53365: PPUSH
53366: CALL_OW 250
53370: PPUSH
53371: LD_VAR 0 4
53375: PUSH
53376: LD_VAR 0 7
53380: ARRAY
53381: PPUSH
53382: CALL_OW 251
53386: PPUSH
53387: CALL_OW 546
53391: PUSH
53392: LD_INT 2
53394: ARRAY
53395: PUSH
53396: LD_VAR 0 14
53400: PUSH
53401: LD_INT 1
53403: ARRAY
53404: PPUSH
53405: CALL_OW 250
53409: PPUSH
53410: LD_VAR 0 14
53414: PUSH
53415: LD_INT 1
53417: ARRAY
53418: PPUSH
53419: CALL_OW 251
53423: PPUSH
53424: CALL_OW 546
53428: PUSH
53429: LD_INT 2
53431: ARRAY
53432: EQUAL
53433: IFFALSE 53461
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
53435: LD_VAR 0 4
53439: PUSH
53440: LD_VAR 0 7
53444: ARRAY
53445: PPUSH
53446: LD_VAR 0 14
53450: PUSH
53451: LD_INT 1
53453: ARRAY
53454: PPUSH
53455: CALL 48732 0 2
53459: GO 53485
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53461: LD_VAR 0 4
53465: PUSH
53466: LD_VAR 0 7
53470: ARRAY
53471: PPUSH
53472: LD_VAR 0 14
53476: PUSH
53477: LD_INT 1
53479: ARRAY
53480: PPUSH
53481: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
53485: LD_VAR 0 4
53489: PUSH
53490: LD_VAR 0 7
53494: ARRAY
53495: PPUSH
53496: CALL_OW 264
53500: PUSH
53501: LD_INT 29
53503: EQUAL
53504: IFFALSE 53870
// begin if WantsToAttack ( group [ i ] ) in bombed then
53506: LD_VAR 0 4
53510: PUSH
53511: LD_VAR 0 7
53515: ARRAY
53516: PPUSH
53517: CALL_OW 319
53521: PUSH
53522: LD_VAR 0 28
53526: IN
53527: IFFALSE 53531
// continue ;
53529: GO 50535
// k := 8 ;
53531: LD_ADDR_VAR 0 9
53535: PUSH
53536: LD_INT 8
53538: ST_TO_ADDR
// x := 0 ;
53539: LD_ADDR_VAR 0 10
53543: PUSH
53544: LD_INT 0
53546: ST_TO_ADDR
// if tmp < k then
53547: LD_VAR 0 14
53551: PUSH
53552: LD_VAR 0 9
53556: LESS
53557: IFFALSE 53569
// k := tmp ;
53559: LD_ADDR_VAR 0 9
53563: PUSH
53564: LD_VAR 0 14
53568: ST_TO_ADDR
// for j = 1 to k do
53569: LD_ADDR_VAR 0 8
53573: PUSH
53574: DOUBLE
53575: LD_INT 1
53577: DEC
53578: ST_TO_ADDR
53579: LD_VAR 0 9
53583: PUSH
53584: FOR_TO
53585: IFFALSE 53717
// begin if GetType ( tmp [ j ] ) = unit_building then
53587: LD_VAR 0 14
53591: PUSH
53592: LD_VAR 0 8
53596: ARRAY
53597: PPUSH
53598: CALL_OW 247
53602: PUSH
53603: LD_INT 3
53605: EQUAL
53606: IFFALSE 53715
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
53608: LD_VAR 0 14
53612: PUSH
53613: LD_VAR 0 8
53617: ARRAY
53618: PUSH
53619: LD_VAR 0 28
53623: IN
53624: NOT
53625: PUSH
53626: LD_VAR 0 14
53630: PUSH
53631: LD_VAR 0 8
53635: ARRAY
53636: PPUSH
53637: CALL_OW 313
53641: AND
53642: IFFALSE 53715
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53644: LD_VAR 0 4
53648: PUSH
53649: LD_VAR 0 7
53653: ARRAY
53654: PPUSH
53655: LD_VAR 0 14
53659: PUSH
53660: LD_VAR 0 8
53664: ARRAY
53665: PPUSH
53666: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
53670: LD_ADDR_VAR 0 28
53674: PUSH
53675: LD_VAR 0 28
53679: PPUSH
53680: LD_VAR 0 28
53684: PUSH
53685: LD_INT 1
53687: PLUS
53688: PPUSH
53689: LD_VAR 0 14
53693: PUSH
53694: LD_VAR 0 8
53698: ARRAY
53699: PPUSH
53700: CALL_OW 1
53704: ST_TO_ADDR
// attacking := true ;
53705: LD_ADDR_VAR 0 29
53709: PUSH
53710: LD_INT 1
53712: ST_TO_ADDR
// break ;
53713: GO 53717
// end ; end ;
53715: GO 53584
53717: POP
53718: POP
// if not attacking and f_attack_depot then
53719: LD_VAR 0 29
53723: NOT
53724: PUSH
53725: LD_VAR 0 25
53729: AND
53730: IFFALSE 53825
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53732: LD_ADDR_VAR 0 13
53736: PUSH
53737: LD_VAR 0 14
53741: PPUSH
53742: LD_INT 2
53744: PUSH
53745: LD_INT 30
53747: PUSH
53748: LD_INT 0
53750: PUSH
53751: EMPTY
53752: LIST
53753: LIST
53754: PUSH
53755: LD_INT 30
53757: PUSH
53758: LD_INT 1
53760: PUSH
53761: EMPTY
53762: LIST
53763: LIST
53764: PUSH
53765: EMPTY
53766: LIST
53767: LIST
53768: LIST
53769: PPUSH
53770: CALL_OW 72
53774: ST_TO_ADDR
// if z then
53775: LD_VAR 0 13
53779: IFFALSE 53825
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
53781: LD_VAR 0 4
53785: PUSH
53786: LD_VAR 0 7
53790: ARRAY
53791: PPUSH
53792: LD_VAR 0 13
53796: PPUSH
53797: LD_VAR 0 4
53801: PUSH
53802: LD_VAR 0 7
53806: ARRAY
53807: PPUSH
53808: CALL_OW 74
53812: PPUSH
53813: CALL_OW 115
// attacking := true ;
53817: LD_ADDR_VAR 0 29
53821: PUSH
53822: LD_INT 1
53824: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
53825: LD_VAR 0 4
53829: PUSH
53830: LD_VAR 0 7
53834: ARRAY
53835: PPUSH
53836: CALL_OW 256
53840: PUSH
53841: LD_INT 500
53843: LESS
53844: IFFALSE 53870
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53846: LD_VAR 0 4
53850: PUSH
53851: LD_VAR 0 7
53855: ARRAY
53856: PPUSH
53857: LD_VAR 0 14
53861: PUSH
53862: LD_INT 1
53864: ARRAY
53865: PPUSH
53866: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
53870: LD_VAR 0 4
53874: PUSH
53875: LD_VAR 0 7
53879: ARRAY
53880: PPUSH
53881: CALL_OW 264
53885: PUSH
53886: LD_INT 49
53888: EQUAL
53889: IFFALSE 54010
// begin if not HasTask ( group [ i ] ) then
53891: LD_VAR 0 4
53895: PUSH
53896: LD_VAR 0 7
53900: ARRAY
53901: PPUSH
53902: CALL_OW 314
53906: NOT
53907: IFFALSE 54010
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53909: LD_ADDR_VAR 0 9
53913: PUSH
53914: LD_INT 81
53916: PUSH
53917: LD_VAR 0 4
53921: PUSH
53922: LD_VAR 0 7
53926: ARRAY
53927: PPUSH
53928: CALL_OW 255
53932: PUSH
53933: EMPTY
53934: LIST
53935: LIST
53936: PPUSH
53937: CALL_OW 69
53941: PPUSH
53942: LD_VAR 0 4
53946: PUSH
53947: LD_VAR 0 7
53951: ARRAY
53952: PPUSH
53953: CALL_OW 74
53957: ST_TO_ADDR
// if k then
53958: LD_VAR 0 9
53962: IFFALSE 54010
// if GetDistUnits ( group [ i ] , k ) > 10 then
53964: LD_VAR 0 4
53968: PUSH
53969: LD_VAR 0 7
53973: ARRAY
53974: PPUSH
53975: LD_VAR 0 9
53979: PPUSH
53980: CALL_OW 296
53984: PUSH
53985: LD_INT 10
53987: GREATER
53988: IFFALSE 54010
// ComMoveUnit ( group [ i ] , k ) ;
53990: LD_VAR 0 4
53994: PUSH
53995: LD_VAR 0 7
53999: ARRAY
54000: PPUSH
54001: LD_VAR 0 9
54005: PPUSH
54006: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
54010: LD_VAR 0 4
54014: PUSH
54015: LD_VAR 0 7
54019: ARRAY
54020: PPUSH
54021: CALL_OW 256
54025: PUSH
54026: LD_INT 250
54028: LESS
54029: PUSH
54030: LD_VAR 0 4
54034: PUSH
54035: LD_VAR 0 7
54039: ARRAY
54040: PUSH
54041: LD_INT 21
54043: PUSH
54044: LD_INT 2
54046: PUSH
54047: EMPTY
54048: LIST
54049: LIST
54050: PUSH
54051: LD_INT 23
54053: PUSH
54054: LD_INT 2
54056: PUSH
54057: EMPTY
54058: LIST
54059: LIST
54060: PUSH
54061: EMPTY
54062: LIST
54063: LIST
54064: PPUSH
54065: CALL_OW 69
54069: IN
54070: AND
54071: IFFALSE 54196
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
54073: LD_ADDR_VAR 0 9
54077: PUSH
54078: LD_OWVAR 3
54082: PUSH
54083: LD_VAR 0 4
54087: PUSH
54088: LD_VAR 0 7
54092: ARRAY
54093: DIFF
54094: PPUSH
54095: LD_VAR 0 4
54099: PUSH
54100: LD_VAR 0 7
54104: ARRAY
54105: PPUSH
54106: CALL_OW 74
54110: ST_TO_ADDR
// if not k then
54111: LD_VAR 0 9
54115: NOT
54116: IFFALSE 54120
// continue ;
54118: GO 50535
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
54120: LD_VAR 0 9
54124: PUSH
54125: LD_INT 81
54127: PUSH
54128: LD_VAR 0 4
54132: PUSH
54133: LD_VAR 0 7
54137: ARRAY
54138: PPUSH
54139: CALL_OW 255
54143: PUSH
54144: EMPTY
54145: LIST
54146: LIST
54147: PPUSH
54148: CALL_OW 69
54152: IN
54153: PUSH
54154: LD_VAR 0 9
54158: PPUSH
54159: LD_VAR 0 4
54163: PUSH
54164: LD_VAR 0 7
54168: ARRAY
54169: PPUSH
54170: CALL_OW 296
54174: PUSH
54175: LD_INT 5
54177: LESS
54178: AND
54179: IFFALSE 54196
// ComAutodestruct ( group [ i ] ) ;
54181: LD_VAR 0 4
54185: PUSH
54186: LD_VAR 0 7
54190: ARRAY
54191: PPUSH
54192: CALL 48630 0 1
// end ; if f_attack_depot then
54196: LD_VAR 0 25
54200: IFFALSE 54312
// begin k := 6 ;
54202: LD_ADDR_VAR 0 9
54206: PUSH
54207: LD_INT 6
54209: ST_TO_ADDR
// if tmp < k then
54210: LD_VAR 0 14
54214: PUSH
54215: LD_VAR 0 9
54219: LESS
54220: IFFALSE 54232
// k := tmp ;
54222: LD_ADDR_VAR 0 9
54226: PUSH
54227: LD_VAR 0 14
54231: ST_TO_ADDR
// for j = 1 to k do
54232: LD_ADDR_VAR 0 8
54236: PUSH
54237: DOUBLE
54238: LD_INT 1
54240: DEC
54241: ST_TO_ADDR
54242: LD_VAR 0 9
54246: PUSH
54247: FOR_TO
54248: IFFALSE 54310
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
54250: LD_VAR 0 8
54254: PPUSH
54255: CALL_OW 266
54259: PUSH
54260: LD_INT 0
54262: PUSH
54263: LD_INT 1
54265: PUSH
54266: EMPTY
54267: LIST
54268: LIST
54269: IN
54270: IFFALSE 54308
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
54272: LD_VAR 0 4
54276: PUSH
54277: LD_VAR 0 7
54281: ARRAY
54282: PPUSH
54283: LD_VAR 0 14
54287: PUSH
54288: LD_VAR 0 8
54292: ARRAY
54293: PPUSH
54294: CALL_OW 115
// attacking := true ;
54298: LD_ADDR_VAR 0 29
54302: PUSH
54303: LD_INT 1
54305: ST_TO_ADDR
// break ;
54306: GO 54310
// end ;
54308: GO 54247
54310: POP
54311: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
54312: LD_VAR 0 4
54316: PUSH
54317: LD_VAR 0 7
54321: ARRAY
54322: PPUSH
54323: CALL_OW 302
54327: PUSH
54328: LD_VAR 0 29
54332: NOT
54333: AND
54334: IFFALSE 54656
// begin if GetTag ( group [ i ] ) = 71 then
54336: LD_VAR 0 4
54340: PUSH
54341: LD_VAR 0 7
54345: ARRAY
54346: PPUSH
54347: CALL_OW 110
54351: PUSH
54352: LD_INT 71
54354: EQUAL
54355: IFFALSE 54396
// begin if HasTask ( group [ i ] ) then
54357: LD_VAR 0 4
54361: PUSH
54362: LD_VAR 0 7
54366: ARRAY
54367: PPUSH
54368: CALL_OW 314
54372: IFFALSE 54378
// continue else
54374: GO 50535
54376: GO 54396
// SetTag ( group [ i ] , 0 ) ;
54378: LD_VAR 0 4
54382: PUSH
54383: LD_VAR 0 7
54387: ARRAY
54388: PPUSH
54389: LD_INT 0
54391: PPUSH
54392: CALL_OW 109
// end ; k := 8 ;
54396: LD_ADDR_VAR 0 9
54400: PUSH
54401: LD_INT 8
54403: ST_TO_ADDR
// x := 0 ;
54404: LD_ADDR_VAR 0 10
54408: PUSH
54409: LD_INT 0
54411: ST_TO_ADDR
// if tmp < k then
54412: LD_VAR 0 14
54416: PUSH
54417: LD_VAR 0 9
54421: LESS
54422: IFFALSE 54434
// k := tmp ;
54424: LD_ADDR_VAR 0 9
54428: PUSH
54429: LD_VAR 0 14
54433: ST_TO_ADDR
// for j = 1 to k do
54434: LD_ADDR_VAR 0 8
54438: PUSH
54439: DOUBLE
54440: LD_INT 1
54442: DEC
54443: ST_TO_ADDR
54444: LD_VAR 0 9
54448: PUSH
54449: FOR_TO
54450: IFFALSE 54548
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
54452: LD_VAR 0 14
54456: PUSH
54457: LD_VAR 0 8
54461: ARRAY
54462: PPUSH
54463: CALL_OW 247
54467: PUSH
54468: LD_INT 1
54470: EQUAL
54471: PUSH
54472: LD_VAR 0 14
54476: PUSH
54477: LD_VAR 0 8
54481: ARRAY
54482: PPUSH
54483: CALL_OW 256
54487: PUSH
54488: LD_INT 250
54490: LESS
54491: PUSH
54492: LD_VAR 0 20
54496: AND
54497: PUSH
54498: LD_VAR 0 20
54502: NOT
54503: PUSH
54504: LD_VAR 0 14
54508: PUSH
54509: LD_VAR 0 8
54513: ARRAY
54514: PPUSH
54515: CALL_OW 256
54519: PUSH
54520: LD_INT 250
54522: GREATEREQUAL
54523: AND
54524: OR
54525: AND
54526: IFFALSE 54546
// begin x := tmp [ j ] ;
54528: LD_ADDR_VAR 0 10
54532: PUSH
54533: LD_VAR 0 14
54537: PUSH
54538: LD_VAR 0 8
54542: ARRAY
54543: ST_TO_ADDR
// break ;
54544: GO 54548
// end ;
54546: GO 54449
54548: POP
54549: POP
// if x then
54550: LD_VAR 0 10
54554: IFFALSE 54578
// ComAttackUnit ( group [ i ] , x ) else
54556: LD_VAR 0 4
54560: PUSH
54561: LD_VAR 0 7
54565: ARRAY
54566: PPUSH
54567: LD_VAR 0 10
54571: PPUSH
54572: CALL_OW 115
54576: GO 54602
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
54578: LD_VAR 0 4
54582: PUSH
54583: LD_VAR 0 7
54587: ARRAY
54588: PPUSH
54589: LD_VAR 0 14
54593: PUSH
54594: LD_INT 1
54596: ARRAY
54597: PPUSH
54598: CALL_OW 115
// if not HasTask ( group [ i ] ) then
54602: LD_VAR 0 4
54606: PUSH
54607: LD_VAR 0 7
54611: ARRAY
54612: PPUSH
54613: CALL_OW 314
54617: NOT
54618: IFFALSE 54656
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
54620: LD_VAR 0 4
54624: PUSH
54625: LD_VAR 0 7
54629: ARRAY
54630: PPUSH
54631: LD_VAR 0 14
54635: PPUSH
54636: LD_VAR 0 4
54640: PUSH
54641: LD_VAR 0 7
54645: ARRAY
54646: PPUSH
54647: CALL_OW 74
54651: PPUSH
54652: CALL_OW 115
// end ; end ; end ;
54656: GO 50535
54658: POP
54659: POP
// wait ( 0 0$1 ) ;
54660: LD_INT 35
54662: PPUSH
54663: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
54667: LD_VAR 0 4
54671: PUSH
54672: EMPTY
54673: EQUAL
54674: PUSH
54675: LD_INT 81
54677: PUSH
54678: LD_VAR 0 35
54682: PUSH
54683: EMPTY
54684: LIST
54685: LIST
54686: PPUSH
54687: CALL_OW 69
54691: NOT
54692: OR
54693: IFFALSE 50520
// end ;
54695: LD_VAR 0 2
54699: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54700: LD_INT 0
54702: PPUSH
54703: PPUSH
54704: PPUSH
54705: PPUSH
// if not base_units then
54706: LD_VAR 0 1
54710: NOT
54711: IFFALSE 54715
// exit ;
54713: GO 54802
// result := false ;
54715: LD_ADDR_VAR 0 2
54719: PUSH
54720: LD_INT 0
54722: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54723: LD_ADDR_VAR 0 5
54727: PUSH
54728: LD_VAR 0 1
54732: PPUSH
54733: LD_INT 21
54735: PUSH
54736: LD_INT 3
54738: PUSH
54739: EMPTY
54740: LIST
54741: LIST
54742: PPUSH
54743: CALL_OW 72
54747: ST_TO_ADDR
// if not tmp then
54748: LD_VAR 0 5
54752: NOT
54753: IFFALSE 54757
// exit ;
54755: GO 54802
// for i in tmp do
54757: LD_ADDR_VAR 0 3
54761: PUSH
54762: LD_VAR 0 5
54766: PUSH
54767: FOR_IN
54768: IFFALSE 54800
// begin result := EnemyInRange ( i , 22 ) ;
54770: LD_ADDR_VAR 0 2
54774: PUSH
54775: LD_VAR 0 3
54779: PPUSH
54780: LD_INT 22
54782: PPUSH
54783: CALL 48313 0 2
54787: ST_TO_ADDR
// if result then
54788: LD_VAR 0 2
54792: IFFALSE 54798
// exit ;
54794: POP
54795: POP
54796: GO 54802
// end ;
54798: GO 54767
54800: POP
54801: POP
// end ;
54802: LD_VAR 0 2
54806: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
54807: LD_INT 0
54809: PPUSH
54810: PPUSH
// if not units then
54811: LD_VAR 0 1
54815: NOT
54816: IFFALSE 54820
// exit ;
54818: GO 54890
// result := [ ] ;
54820: LD_ADDR_VAR 0 3
54824: PUSH
54825: EMPTY
54826: ST_TO_ADDR
// for i in units do
54827: LD_ADDR_VAR 0 4
54831: PUSH
54832: LD_VAR 0 1
54836: PUSH
54837: FOR_IN
54838: IFFALSE 54888
// if GetTag ( i ) = tag then
54840: LD_VAR 0 4
54844: PPUSH
54845: CALL_OW 110
54849: PUSH
54850: LD_VAR 0 2
54854: EQUAL
54855: IFFALSE 54886
// result := Insert ( result , result + 1 , i ) ;
54857: LD_ADDR_VAR 0 3
54861: PUSH
54862: LD_VAR 0 3
54866: PPUSH
54867: LD_VAR 0 3
54871: PUSH
54872: LD_INT 1
54874: PLUS
54875: PPUSH
54876: LD_VAR 0 4
54880: PPUSH
54881: CALL_OW 2
54885: ST_TO_ADDR
54886: GO 54837
54888: POP
54889: POP
// end ;
54890: LD_VAR 0 3
54894: RET
// export function IsDriver ( un ) ; begin
54895: LD_INT 0
54897: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54898: LD_ADDR_VAR 0 2
54902: PUSH
54903: LD_VAR 0 1
54907: PUSH
54908: LD_INT 55
54910: PUSH
54911: EMPTY
54912: LIST
54913: PPUSH
54914: CALL_OW 69
54918: IN
54919: ST_TO_ADDR
// end ;
54920: LD_VAR 0 2
54924: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54925: LD_INT 0
54927: PPUSH
54928: PPUSH
// list := [ ] ;
54929: LD_ADDR_VAR 0 5
54933: PUSH
54934: EMPTY
54935: ST_TO_ADDR
// case d of 0 :
54936: LD_VAR 0 3
54940: PUSH
54941: LD_INT 0
54943: DOUBLE
54944: EQUAL
54945: IFTRUE 54949
54947: GO 55082
54949: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54950: LD_ADDR_VAR 0 5
54954: PUSH
54955: LD_VAR 0 1
54959: PUSH
54960: LD_INT 4
54962: MINUS
54963: PUSH
54964: LD_VAR 0 2
54968: PUSH
54969: LD_INT 4
54971: MINUS
54972: PUSH
54973: LD_INT 2
54975: PUSH
54976: EMPTY
54977: LIST
54978: LIST
54979: LIST
54980: PUSH
54981: LD_VAR 0 1
54985: PUSH
54986: LD_INT 3
54988: MINUS
54989: PUSH
54990: LD_VAR 0 2
54994: PUSH
54995: LD_INT 1
54997: PUSH
54998: EMPTY
54999: LIST
55000: LIST
55001: LIST
55002: PUSH
55003: LD_VAR 0 1
55007: PUSH
55008: LD_INT 4
55010: PLUS
55011: PUSH
55012: LD_VAR 0 2
55016: PUSH
55017: LD_INT 4
55019: PUSH
55020: EMPTY
55021: LIST
55022: LIST
55023: LIST
55024: PUSH
55025: LD_VAR 0 1
55029: PUSH
55030: LD_INT 3
55032: PLUS
55033: PUSH
55034: LD_VAR 0 2
55038: PUSH
55039: LD_INT 3
55041: PLUS
55042: PUSH
55043: LD_INT 5
55045: PUSH
55046: EMPTY
55047: LIST
55048: LIST
55049: LIST
55050: PUSH
55051: LD_VAR 0 1
55055: PUSH
55056: LD_VAR 0 2
55060: PUSH
55061: LD_INT 4
55063: PLUS
55064: PUSH
55065: LD_INT 0
55067: PUSH
55068: EMPTY
55069: LIST
55070: LIST
55071: LIST
55072: PUSH
55073: EMPTY
55074: LIST
55075: LIST
55076: LIST
55077: LIST
55078: LIST
55079: ST_TO_ADDR
// end ; 1 :
55080: GO 55780
55082: LD_INT 1
55084: DOUBLE
55085: EQUAL
55086: IFTRUE 55090
55088: GO 55223
55090: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55091: LD_ADDR_VAR 0 5
55095: PUSH
55096: LD_VAR 0 1
55100: PUSH
55101: LD_VAR 0 2
55105: PUSH
55106: LD_INT 4
55108: MINUS
55109: PUSH
55110: LD_INT 3
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: LIST
55117: PUSH
55118: LD_VAR 0 1
55122: PUSH
55123: LD_INT 3
55125: MINUS
55126: PUSH
55127: LD_VAR 0 2
55131: PUSH
55132: LD_INT 3
55134: MINUS
55135: PUSH
55136: LD_INT 2
55138: PUSH
55139: EMPTY
55140: LIST
55141: LIST
55142: LIST
55143: PUSH
55144: LD_VAR 0 1
55148: PUSH
55149: LD_INT 4
55151: MINUS
55152: PUSH
55153: LD_VAR 0 2
55157: PUSH
55158: LD_INT 1
55160: PUSH
55161: EMPTY
55162: LIST
55163: LIST
55164: LIST
55165: PUSH
55166: LD_VAR 0 1
55170: PUSH
55171: LD_VAR 0 2
55175: PUSH
55176: LD_INT 3
55178: PLUS
55179: PUSH
55180: LD_INT 0
55182: PUSH
55183: EMPTY
55184: LIST
55185: LIST
55186: LIST
55187: PUSH
55188: LD_VAR 0 1
55192: PUSH
55193: LD_INT 4
55195: PLUS
55196: PUSH
55197: LD_VAR 0 2
55201: PUSH
55202: LD_INT 4
55204: PLUS
55205: PUSH
55206: LD_INT 5
55208: PUSH
55209: EMPTY
55210: LIST
55211: LIST
55212: LIST
55213: PUSH
55214: EMPTY
55215: LIST
55216: LIST
55217: LIST
55218: LIST
55219: LIST
55220: ST_TO_ADDR
// end ; 2 :
55221: GO 55780
55223: LD_INT 2
55225: DOUBLE
55226: EQUAL
55227: IFTRUE 55231
55229: GO 55360
55231: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55232: LD_ADDR_VAR 0 5
55236: PUSH
55237: LD_VAR 0 1
55241: PUSH
55242: LD_VAR 0 2
55246: PUSH
55247: LD_INT 3
55249: MINUS
55250: PUSH
55251: LD_INT 3
55253: PUSH
55254: EMPTY
55255: LIST
55256: LIST
55257: LIST
55258: PUSH
55259: LD_VAR 0 1
55263: PUSH
55264: LD_INT 4
55266: PLUS
55267: PUSH
55268: LD_VAR 0 2
55272: PUSH
55273: LD_INT 4
55275: PUSH
55276: EMPTY
55277: LIST
55278: LIST
55279: LIST
55280: PUSH
55281: LD_VAR 0 1
55285: PUSH
55286: LD_VAR 0 2
55290: PUSH
55291: LD_INT 4
55293: PLUS
55294: PUSH
55295: LD_INT 0
55297: PUSH
55298: EMPTY
55299: LIST
55300: LIST
55301: LIST
55302: PUSH
55303: LD_VAR 0 1
55307: PUSH
55308: LD_INT 3
55310: MINUS
55311: PUSH
55312: LD_VAR 0 2
55316: PUSH
55317: LD_INT 1
55319: PUSH
55320: EMPTY
55321: LIST
55322: LIST
55323: LIST
55324: PUSH
55325: LD_VAR 0 1
55329: PUSH
55330: LD_INT 4
55332: MINUS
55333: PUSH
55334: LD_VAR 0 2
55338: PUSH
55339: LD_INT 4
55341: MINUS
55342: PUSH
55343: LD_INT 2
55345: PUSH
55346: EMPTY
55347: LIST
55348: LIST
55349: LIST
55350: PUSH
55351: EMPTY
55352: LIST
55353: LIST
55354: LIST
55355: LIST
55356: LIST
55357: ST_TO_ADDR
// end ; 3 :
55358: GO 55780
55360: LD_INT 3
55362: DOUBLE
55363: EQUAL
55364: IFTRUE 55368
55366: GO 55501
55368: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55369: LD_ADDR_VAR 0 5
55373: PUSH
55374: LD_VAR 0 1
55378: PUSH
55379: LD_INT 3
55381: PLUS
55382: PUSH
55383: LD_VAR 0 2
55387: PUSH
55388: LD_INT 4
55390: PUSH
55391: EMPTY
55392: LIST
55393: LIST
55394: LIST
55395: PUSH
55396: LD_VAR 0 1
55400: PUSH
55401: LD_INT 4
55403: PLUS
55404: PUSH
55405: LD_VAR 0 2
55409: PUSH
55410: LD_INT 4
55412: PLUS
55413: PUSH
55414: LD_INT 5
55416: PUSH
55417: EMPTY
55418: LIST
55419: LIST
55420: LIST
55421: PUSH
55422: LD_VAR 0 1
55426: PUSH
55427: LD_INT 4
55429: MINUS
55430: PUSH
55431: LD_VAR 0 2
55435: PUSH
55436: LD_INT 1
55438: PUSH
55439: EMPTY
55440: LIST
55441: LIST
55442: LIST
55443: PUSH
55444: LD_VAR 0 1
55448: PUSH
55449: LD_VAR 0 2
55453: PUSH
55454: LD_INT 4
55456: MINUS
55457: PUSH
55458: LD_INT 3
55460: PUSH
55461: EMPTY
55462: LIST
55463: LIST
55464: LIST
55465: PUSH
55466: LD_VAR 0 1
55470: PUSH
55471: LD_INT 3
55473: MINUS
55474: PUSH
55475: LD_VAR 0 2
55479: PUSH
55480: LD_INT 3
55482: MINUS
55483: PUSH
55484: LD_INT 2
55486: PUSH
55487: EMPTY
55488: LIST
55489: LIST
55490: LIST
55491: PUSH
55492: EMPTY
55493: LIST
55494: LIST
55495: LIST
55496: LIST
55497: LIST
55498: ST_TO_ADDR
// end ; 4 :
55499: GO 55780
55501: LD_INT 4
55503: DOUBLE
55504: EQUAL
55505: IFTRUE 55509
55507: GO 55642
55509: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55510: LD_ADDR_VAR 0 5
55514: PUSH
55515: LD_VAR 0 1
55519: PUSH
55520: LD_VAR 0 2
55524: PUSH
55525: LD_INT 4
55527: PLUS
55528: PUSH
55529: LD_INT 0
55531: PUSH
55532: EMPTY
55533: LIST
55534: LIST
55535: LIST
55536: PUSH
55537: LD_VAR 0 1
55541: PUSH
55542: LD_INT 3
55544: PLUS
55545: PUSH
55546: LD_VAR 0 2
55550: PUSH
55551: LD_INT 3
55553: PLUS
55554: PUSH
55555: LD_INT 5
55557: PUSH
55558: EMPTY
55559: LIST
55560: LIST
55561: LIST
55562: PUSH
55563: LD_VAR 0 1
55567: PUSH
55568: LD_INT 4
55570: PLUS
55571: PUSH
55572: LD_VAR 0 2
55576: PUSH
55577: LD_INT 4
55579: PUSH
55580: EMPTY
55581: LIST
55582: LIST
55583: LIST
55584: PUSH
55585: LD_VAR 0 1
55589: PUSH
55590: LD_VAR 0 2
55594: PUSH
55595: LD_INT 3
55597: MINUS
55598: PUSH
55599: LD_INT 3
55601: PUSH
55602: EMPTY
55603: LIST
55604: LIST
55605: LIST
55606: PUSH
55607: LD_VAR 0 1
55611: PUSH
55612: LD_INT 4
55614: MINUS
55615: PUSH
55616: LD_VAR 0 2
55620: PUSH
55621: LD_INT 4
55623: MINUS
55624: PUSH
55625: LD_INT 2
55627: PUSH
55628: EMPTY
55629: LIST
55630: LIST
55631: LIST
55632: PUSH
55633: EMPTY
55634: LIST
55635: LIST
55636: LIST
55637: LIST
55638: LIST
55639: ST_TO_ADDR
// end ; 5 :
55640: GO 55780
55642: LD_INT 5
55644: DOUBLE
55645: EQUAL
55646: IFTRUE 55650
55648: GO 55779
55650: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55651: LD_ADDR_VAR 0 5
55655: PUSH
55656: LD_VAR 0 1
55660: PUSH
55661: LD_INT 4
55663: MINUS
55664: PUSH
55665: LD_VAR 0 2
55669: PUSH
55670: LD_INT 1
55672: PUSH
55673: EMPTY
55674: LIST
55675: LIST
55676: LIST
55677: PUSH
55678: LD_VAR 0 1
55682: PUSH
55683: LD_VAR 0 2
55687: PUSH
55688: LD_INT 4
55690: MINUS
55691: PUSH
55692: LD_INT 3
55694: PUSH
55695: EMPTY
55696: LIST
55697: LIST
55698: LIST
55699: PUSH
55700: LD_VAR 0 1
55704: PUSH
55705: LD_INT 4
55707: PLUS
55708: PUSH
55709: LD_VAR 0 2
55713: PUSH
55714: LD_INT 4
55716: PLUS
55717: PUSH
55718: LD_INT 5
55720: PUSH
55721: EMPTY
55722: LIST
55723: LIST
55724: LIST
55725: PUSH
55726: LD_VAR 0 1
55730: PUSH
55731: LD_INT 3
55733: PLUS
55734: PUSH
55735: LD_VAR 0 2
55739: PUSH
55740: LD_INT 4
55742: PUSH
55743: EMPTY
55744: LIST
55745: LIST
55746: LIST
55747: PUSH
55748: LD_VAR 0 1
55752: PUSH
55753: LD_VAR 0 2
55757: PUSH
55758: LD_INT 3
55760: PLUS
55761: PUSH
55762: LD_INT 0
55764: PUSH
55765: EMPTY
55766: LIST
55767: LIST
55768: LIST
55769: PUSH
55770: EMPTY
55771: LIST
55772: LIST
55773: LIST
55774: LIST
55775: LIST
55776: ST_TO_ADDR
// end ; end ;
55777: GO 55780
55779: POP
// result := list ;
55780: LD_ADDR_VAR 0 4
55784: PUSH
55785: LD_VAR 0 5
55789: ST_TO_ADDR
// end ;
55790: LD_VAR 0 4
55794: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55795: LD_INT 0
55797: PPUSH
55798: PPUSH
55799: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55800: LD_VAR 0 1
55804: NOT
55805: PUSH
55806: LD_VAR 0 2
55810: PUSH
55811: LD_INT 1
55813: PUSH
55814: LD_INT 2
55816: PUSH
55817: LD_INT 3
55819: PUSH
55820: LD_INT 4
55822: PUSH
55823: EMPTY
55824: LIST
55825: LIST
55826: LIST
55827: LIST
55828: IN
55829: NOT
55830: OR
55831: IFFALSE 55835
// exit ;
55833: GO 55927
// tmp := [ ] ;
55835: LD_ADDR_VAR 0 5
55839: PUSH
55840: EMPTY
55841: ST_TO_ADDR
// for i in units do
55842: LD_ADDR_VAR 0 4
55846: PUSH
55847: LD_VAR 0 1
55851: PUSH
55852: FOR_IN
55853: IFFALSE 55896
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55855: LD_ADDR_VAR 0 5
55859: PUSH
55860: LD_VAR 0 5
55864: PPUSH
55865: LD_VAR 0 5
55869: PUSH
55870: LD_INT 1
55872: PLUS
55873: PPUSH
55874: LD_VAR 0 4
55878: PPUSH
55879: LD_VAR 0 2
55883: PPUSH
55884: CALL_OW 259
55888: PPUSH
55889: CALL_OW 2
55893: ST_TO_ADDR
55894: GO 55852
55896: POP
55897: POP
// if not tmp then
55898: LD_VAR 0 5
55902: NOT
55903: IFFALSE 55907
// exit ;
55905: GO 55927
// result := SortListByListDesc ( units , tmp ) ;
55907: LD_ADDR_VAR 0 3
55911: PUSH
55912: LD_VAR 0 1
55916: PPUSH
55917: LD_VAR 0 5
55921: PPUSH
55922: CALL_OW 77
55926: ST_TO_ADDR
// end ;
55927: LD_VAR 0 3
55931: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55932: LD_INT 0
55934: PPUSH
55935: PPUSH
55936: PPUSH
// x := GetX ( building ) ;
55937: LD_ADDR_VAR 0 4
55941: PUSH
55942: LD_VAR 0 2
55946: PPUSH
55947: CALL_OW 250
55951: ST_TO_ADDR
// y := GetY ( building ) ;
55952: LD_ADDR_VAR 0 5
55956: PUSH
55957: LD_VAR 0 2
55961: PPUSH
55962: CALL_OW 251
55966: ST_TO_ADDR
// if GetTaskList ( unit ) then
55967: LD_VAR 0 1
55971: PPUSH
55972: CALL_OW 437
55976: IFFALSE 56071
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55978: LD_STRING e
55980: PUSH
55981: LD_VAR 0 1
55985: PPUSH
55986: CALL_OW 437
55990: PUSH
55991: LD_INT 1
55993: ARRAY
55994: PUSH
55995: LD_INT 1
55997: ARRAY
55998: EQUAL
55999: PUSH
56000: LD_VAR 0 4
56004: PUSH
56005: LD_VAR 0 1
56009: PPUSH
56010: CALL_OW 437
56014: PUSH
56015: LD_INT 1
56017: ARRAY
56018: PUSH
56019: LD_INT 2
56021: ARRAY
56022: EQUAL
56023: AND
56024: PUSH
56025: LD_VAR 0 5
56029: PUSH
56030: LD_VAR 0 1
56034: PPUSH
56035: CALL_OW 437
56039: PUSH
56040: LD_INT 1
56042: ARRAY
56043: PUSH
56044: LD_INT 3
56046: ARRAY
56047: EQUAL
56048: AND
56049: IFFALSE 56061
// result := true else
56051: LD_ADDR_VAR 0 3
56055: PUSH
56056: LD_INT 1
56058: ST_TO_ADDR
56059: GO 56069
// result := false ;
56061: LD_ADDR_VAR 0 3
56065: PUSH
56066: LD_INT 0
56068: ST_TO_ADDR
// end else
56069: GO 56079
// result := false ;
56071: LD_ADDR_VAR 0 3
56075: PUSH
56076: LD_INT 0
56078: ST_TO_ADDR
// end ;
56079: LD_VAR 0 3
56083: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
56084: LD_INT 0
56086: PPUSH
56087: PPUSH
56088: PPUSH
56089: PPUSH
// if not unit or not area then
56090: LD_VAR 0 1
56094: NOT
56095: PUSH
56096: LD_VAR 0 2
56100: NOT
56101: OR
56102: IFFALSE 56106
// exit ;
56104: GO 56270
// tmp := AreaToList ( area , i ) ;
56106: LD_ADDR_VAR 0 6
56110: PUSH
56111: LD_VAR 0 2
56115: PPUSH
56116: LD_VAR 0 5
56120: PPUSH
56121: CALL_OW 517
56125: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
56126: LD_ADDR_VAR 0 5
56130: PUSH
56131: DOUBLE
56132: LD_INT 1
56134: DEC
56135: ST_TO_ADDR
56136: LD_VAR 0 6
56140: PUSH
56141: LD_INT 1
56143: ARRAY
56144: PUSH
56145: FOR_TO
56146: IFFALSE 56268
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
56148: LD_ADDR_VAR 0 7
56152: PUSH
56153: LD_VAR 0 6
56157: PUSH
56158: LD_INT 1
56160: ARRAY
56161: PUSH
56162: LD_VAR 0 5
56166: ARRAY
56167: PUSH
56168: LD_VAR 0 6
56172: PUSH
56173: LD_INT 2
56175: ARRAY
56176: PUSH
56177: LD_VAR 0 5
56181: ARRAY
56182: PUSH
56183: EMPTY
56184: LIST
56185: LIST
56186: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
56187: LD_VAR 0 7
56191: PUSH
56192: LD_INT 1
56194: ARRAY
56195: PPUSH
56196: LD_VAR 0 7
56200: PUSH
56201: LD_INT 2
56203: ARRAY
56204: PPUSH
56205: CALL_OW 428
56209: PUSH
56210: LD_INT 0
56212: EQUAL
56213: IFFALSE 56266
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
56215: LD_VAR 0 1
56219: PPUSH
56220: LD_VAR 0 7
56224: PUSH
56225: LD_INT 1
56227: ARRAY
56228: PPUSH
56229: LD_VAR 0 7
56233: PUSH
56234: LD_INT 2
56236: ARRAY
56237: PPUSH
56238: LD_VAR 0 3
56242: PPUSH
56243: CALL_OW 48
// result := IsPlaced ( unit ) ;
56247: LD_ADDR_VAR 0 4
56251: PUSH
56252: LD_VAR 0 1
56256: PPUSH
56257: CALL_OW 305
56261: ST_TO_ADDR
// exit ;
56262: POP
56263: POP
56264: GO 56270
// end ; end ;
56266: GO 56145
56268: POP
56269: POP
// end ;
56270: LD_VAR 0 4
56274: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56275: LD_INT 0
56277: PPUSH
56278: PPUSH
56279: PPUSH
// if not side or side > 8 then
56280: LD_VAR 0 1
56284: NOT
56285: PUSH
56286: LD_VAR 0 1
56290: PUSH
56291: LD_INT 8
56293: GREATER
56294: OR
56295: IFFALSE 56299
// exit ;
56297: GO 56486
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56299: LD_ADDR_VAR 0 4
56303: PUSH
56304: LD_INT 22
56306: PUSH
56307: LD_VAR 0 1
56311: PUSH
56312: EMPTY
56313: LIST
56314: LIST
56315: PUSH
56316: LD_INT 21
56318: PUSH
56319: LD_INT 3
56321: PUSH
56322: EMPTY
56323: LIST
56324: LIST
56325: PUSH
56326: EMPTY
56327: LIST
56328: LIST
56329: PPUSH
56330: CALL_OW 69
56334: ST_TO_ADDR
// if not tmp then
56335: LD_VAR 0 4
56339: NOT
56340: IFFALSE 56344
// exit ;
56342: GO 56486
// enable_addtolog := true ;
56344: LD_ADDR_OWVAR 81
56348: PUSH
56349: LD_INT 1
56351: ST_TO_ADDR
// AddToLog ( [ ) ;
56352: LD_STRING [
56354: PPUSH
56355: CALL_OW 561
// for i in tmp do
56359: LD_ADDR_VAR 0 3
56363: PUSH
56364: LD_VAR 0 4
56368: PUSH
56369: FOR_IN
56370: IFFALSE 56477
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56372: LD_STRING [
56374: PUSH
56375: LD_VAR 0 3
56379: PPUSH
56380: CALL_OW 266
56384: STR
56385: PUSH
56386: LD_STRING , 
56388: STR
56389: PUSH
56390: LD_VAR 0 3
56394: PPUSH
56395: CALL_OW 250
56399: STR
56400: PUSH
56401: LD_STRING , 
56403: STR
56404: PUSH
56405: LD_VAR 0 3
56409: PPUSH
56410: CALL_OW 251
56414: STR
56415: PUSH
56416: LD_STRING , 
56418: STR
56419: PUSH
56420: LD_VAR 0 3
56424: PPUSH
56425: CALL_OW 254
56429: STR
56430: PUSH
56431: LD_STRING , 
56433: STR
56434: PUSH
56435: LD_VAR 0 3
56439: PPUSH
56440: LD_INT 1
56442: PPUSH
56443: CALL_OW 268
56447: STR
56448: PUSH
56449: LD_STRING , 
56451: STR
56452: PUSH
56453: LD_VAR 0 3
56457: PPUSH
56458: LD_INT 2
56460: PPUSH
56461: CALL_OW 268
56465: STR
56466: PUSH
56467: LD_STRING ],
56469: STR
56470: PPUSH
56471: CALL_OW 561
// end ;
56475: GO 56369
56477: POP
56478: POP
// AddToLog ( ]; ) ;
56479: LD_STRING ];
56481: PPUSH
56482: CALL_OW 561
// end ;
56486: LD_VAR 0 2
56490: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56491: LD_INT 0
56493: PPUSH
56494: PPUSH
56495: PPUSH
56496: PPUSH
56497: PPUSH
// if not area or not rate or not max then
56498: LD_VAR 0 1
56502: NOT
56503: PUSH
56504: LD_VAR 0 2
56508: NOT
56509: OR
56510: PUSH
56511: LD_VAR 0 4
56515: NOT
56516: OR
56517: IFFALSE 56521
// exit ;
56519: GO 56713
// while 1 do
56521: LD_INT 1
56523: IFFALSE 56713
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56525: LD_ADDR_VAR 0 9
56529: PUSH
56530: LD_VAR 0 1
56534: PPUSH
56535: LD_INT 1
56537: PPUSH
56538: CALL_OW 287
56542: PUSH
56543: LD_INT 10
56545: MUL
56546: ST_TO_ADDR
// r := rate / 10 ;
56547: LD_ADDR_VAR 0 7
56551: PUSH
56552: LD_VAR 0 2
56556: PUSH
56557: LD_INT 10
56559: DIVREAL
56560: ST_TO_ADDR
// time := 1 1$00 ;
56561: LD_ADDR_VAR 0 8
56565: PUSH
56566: LD_INT 2100
56568: ST_TO_ADDR
// if amount < min then
56569: LD_VAR 0 9
56573: PUSH
56574: LD_VAR 0 3
56578: LESS
56579: IFFALSE 56597
// r := r * 2 else
56581: LD_ADDR_VAR 0 7
56585: PUSH
56586: LD_VAR 0 7
56590: PUSH
56591: LD_INT 2
56593: MUL
56594: ST_TO_ADDR
56595: GO 56623
// if amount > max then
56597: LD_VAR 0 9
56601: PUSH
56602: LD_VAR 0 4
56606: GREATER
56607: IFFALSE 56623
// r := r / 2 ;
56609: LD_ADDR_VAR 0 7
56613: PUSH
56614: LD_VAR 0 7
56618: PUSH
56619: LD_INT 2
56621: DIVREAL
56622: ST_TO_ADDR
// time := time / r ;
56623: LD_ADDR_VAR 0 8
56627: PUSH
56628: LD_VAR 0 8
56632: PUSH
56633: LD_VAR 0 7
56637: DIVREAL
56638: ST_TO_ADDR
// if time < 0 then
56639: LD_VAR 0 8
56643: PUSH
56644: LD_INT 0
56646: LESS
56647: IFFALSE 56664
// time := time * - 1 ;
56649: LD_ADDR_VAR 0 8
56653: PUSH
56654: LD_VAR 0 8
56658: PUSH
56659: LD_INT 1
56661: NEG
56662: MUL
56663: ST_TO_ADDR
// wait ( time ) ;
56664: LD_VAR 0 8
56668: PPUSH
56669: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
56673: LD_INT 35
56675: PPUSH
56676: LD_INT 875
56678: PPUSH
56679: CALL_OW 12
56683: PPUSH
56684: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56688: LD_INT 1
56690: PPUSH
56691: LD_INT 5
56693: PPUSH
56694: CALL_OW 12
56698: PPUSH
56699: LD_VAR 0 1
56703: PPUSH
56704: LD_INT 1
56706: PPUSH
56707: CALL_OW 55
// end ;
56711: GO 56521
// end ;
56713: LD_VAR 0 5
56717: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56718: LD_INT 0
56720: PPUSH
56721: PPUSH
56722: PPUSH
56723: PPUSH
56724: PPUSH
56725: PPUSH
56726: PPUSH
56727: PPUSH
// if not turrets or not factories then
56728: LD_VAR 0 1
56732: NOT
56733: PUSH
56734: LD_VAR 0 2
56738: NOT
56739: OR
56740: IFFALSE 56744
// exit ;
56742: GO 57051
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56744: LD_ADDR_VAR 0 10
56748: PUSH
56749: LD_INT 5
56751: PUSH
56752: LD_INT 6
56754: PUSH
56755: EMPTY
56756: LIST
56757: LIST
56758: PUSH
56759: LD_INT 2
56761: PUSH
56762: LD_INT 4
56764: PUSH
56765: EMPTY
56766: LIST
56767: LIST
56768: PUSH
56769: LD_INT 3
56771: PUSH
56772: LD_INT 5
56774: PUSH
56775: EMPTY
56776: LIST
56777: LIST
56778: PUSH
56779: EMPTY
56780: LIST
56781: LIST
56782: LIST
56783: PUSH
56784: LD_INT 24
56786: PUSH
56787: LD_INT 25
56789: PUSH
56790: EMPTY
56791: LIST
56792: LIST
56793: PUSH
56794: LD_INT 23
56796: PUSH
56797: LD_INT 27
56799: PUSH
56800: EMPTY
56801: LIST
56802: LIST
56803: PUSH
56804: EMPTY
56805: LIST
56806: LIST
56807: PUSH
56808: LD_INT 42
56810: PUSH
56811: LD_INT 43
56813: PUSH
56814: EMPTY
56815: LIST
56816: LIST
56817: PUSH
56818: LD_INT 44
56820: PUSH
56821: LD_INT 46
56823: PUSH
56824: EMPTY
56825: LIST
56826: LIST
56827: PUSH
56828: LD_INT 45
56830: PUSH
56831: LD_INT 47
56833: PUSH
56834: EMPTY
56835: LIST
56836: LIST
56837: PUSH
56838: EMPTY
56839: LIST
56840: LIST
56841: LIST
56842: PUSH
56843: EMPTY
56844: LIST
56845: LIST
56846: LIST
56847: ST_TO_ADDR
// result := [ ] ;
56848: LD_ADDR_VAR 0 3
56852: PUSH
56853: EMPTY
56854: ST_TO_ADDR
// for i in turrets do
56855: LD_ADDR_VAR 0 4
56859: PUSH
56860: LD_VAR 0 1
56864: PUSH
56865: FOR_IN
56866: IFFALSE 57049
// begin nat := GetNation ( i ) ;
56868: LD_ADDR_VAR 0 7
56872: PUSH
56873: LD_VAR 0 4
56877: PPUSH
56878: CALL_OW 248
56882: ST_TO_ADDR
// weapon := 0 ;
56883: LD_ADDR_VAR 0 8
56887: PUSH
56888: LD_INT 0
56890: ST_TO_ADDR
// if not nat then
56891: LD_VAR 0 7
56895: NOT
56896: IFFALSE 56900
// continue ;
56898: GO 56865
// for j in list [ nat ] do
56900: LD_ADDR_VAR 0 5
56904: PUSH
56905: LD_VAR 0 10
56909: PUSH
56910: LD_VAR 0 7
56914: ARRAY
56915: PUSH
56916: FOR_IN
56917: IFFALSE 56958
// if GetBWeapon ( i ) = j [ 1 ] then
56919: LD_VAR 0 4
56923: PPUSH
56924: CALL_OW 269
56928: PUSH
56929: LD_VAR 0 5
56933: PUSH
56934: LD_INT 1
56936: ARRAY
56937: EQUAL
56938: IFFALSE 56956
// begin weapon := j [ 2 ] ;
56940: LD_ADDR_VAR 0 8
56944: PUSH
56945: LD_VAR 0 5
56949: PUSH
56950: LD_INT 2
56952: ARRAY
56953: ST_TO_ADDR
// break ;
56954: GO 56958
// end ;
56956: GO 56916
56958: POP
56959: POP
// if not weapon then
56960: LD_VAR 0 8
56964: NOT
56965: IFFALSE 56969
// continue ;
56967: GO 56865
// for k in factories do
56969: LD_ADDR_VAR 0 6
56973: PUSH
56974: LD_VAR 0 2
56978: PUSH
56979: FOR_IN
56980: IFFALSE 57045
// begin weapons := AvailableWeaponList ( k ) ;
56982: LD_ADDR_VAR 0 9
56986: PUSH
56987: LD_VAR 0 6
56991: PPUSH
56992: CALL_OW 478
56996: ST_TO_ADDR
// if not weapons then
56997: LD_VAR 0 9
57001: NOT
57002: IFFALSE 57006
// continue ;
57004: GO 56979
// if weapon in weapons then
57006: LD_VAR 0 8
57010: PUSH
57011: LD_VAR 0 9
57015: IN
57016: IFFALSE 57043
// begin result := [ i , weapon ] ;
57018: LD_ADDR_VAR 0 3
57022: PUSH
57023: LD_VAR 0 4
57027: PUSH
57028: LD_VAR 0 8
57032: PUSH
57033: EMPTY
57034: LIST
57035: LIST
57036: ST_TO_ADDR
// exit ;
57037: POP
57038: POP
57039: POP
57040: POP
57041: GO 57051
// end ; end ;
57043: GO 56979
57045: POP
57046: POP
// end ;
57047: GO 56865
57049: POP
57050: POP
// end ;
57051: LD_VAR 0 3
57055: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57056: LD_INT 0
57058: PPUSH
// if not side or side > 8 then
57059: LD_VAR 0 3
57063: NOT
57064: PUSH
57065: LD_VAR 0 3
57069: PUSH
57070: LD_INT 8
57072: GREATER
57073: OR
57074: IFFALSE 57078
// exit ;
57076: GO 57137
// if not range then
57078: LD_VAR 0 4
57082: NOT
57083: IFFALSE 57094
// range := - 12 ;
57085: LD_ADDR_VAR 0 4
57089: PUSH
57090: LD_INT 12
57092: NEG
57093: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
57094: LD_VAR 0 1
57098: PPUSH
57099: LD_VAR 0 2
57103: PPUSH
57104: LD_VAR 0 3
57108: PPUSH
57109: LD_VAR 0 4
57113: PPUSH
57114: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
57118: LD_VAR 0 1
57122: PPUSH
57123: LD_VAR 0 2
57127: PPUSH
57128: LD_VAR 0 3
57132: PPUSH
57133: CALL_OW 331
// end ;
57137: LD_VAR 0 5
57141: RET
// export function Video ( mode ) ; begin
57142: LD_INT 0
57144: PPUSH
// ingame_video = mode ;
57145: LD_ADDR_OWVAR 52
57149: PUSH
57150: LD_VAR 0 1
57154: ST_TO_ADDR
// interface_hidden = mode ;
57155: LD_ADDR_OWVAR 54
57159: PUSH
57160: LD_VAR 0 1
57164: ST_TO_ADDR
// end ;
57165: LD_VAR 0 2
57169: RET
// export function Join ( array , element ) ; begin
57170: LD_INT 0
57172: PPUSH
// result := array ^ element ;
57173: LD_ADDR_VAR 0 3
57177: PUSH
57178: LD_VAR 0 1
57182: PUSH
57183: LD_VAR 0 2
57187: ADD
57188: ST_TO_ADDR
// end ;
57189: LD_VAR 0 3
57193: RET
// export function JoinUnion ( array , element ) ; begin
57194: LD_INT 0
57196: PPUSH
// result := array union element ;
57197: LD_ADDR_VAR 0 3
57201: PUSH
57202: LD_VAR 0 1
57206: PUSH
57207: LD_VAR 0 2
57211: UNION
57212: ST_TO_ADDR
// end ;
57213: LD_VAR 0 3
57217: RET
// export function GetBehemoths ( side ) ; begin
57218: LD_INT 0
57220: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
57221: LD_ADDR_VAR 0 2
57225: PUSH
57226: LD_INT 22
57228: PUSH
57229: LD_VAR 0 1
57233: PUSH
57234: EMPTY
57235: LIST
57236: LIST
57237: PUSH
57238: LD_INT 31
57240: PUSH
57241: LD_INT 25
57243: PUSH
57244: EMPTY
57245: LIST
57246: LIST
57247: PUSH
57248: EMPTY
57249: LIST
57250: LIST
57251: PPUSH
57252: CALL_OW 69
57256: ST_TO_ADDR
// end ;
57257: LD_VAR 0 2
57261: RET
// export function Shuffle ( array ) ; var i , index ; begin
57262: LD_INT 0
57264: PPUSH
57265: PPUSH
57266: PPUSH
// result := [ ] ;
57267: LD_ADDR_VAR 0 2
57271: PUSH
57272: EMPTY
57273: ST_TO_ADDR
// if not array then
57274: LD_VAR 0 1
57278: NOT
57279: IFFALSE 57283
// exit ;
57281: GO 57382
// Randomize ;
57283: CALL_OW 10
// for i = array downto 1 do
57287: LD_ADDR_VAR 0 3
57291: PUSH
57292: DOUBLE
57293: LD_VAR 0 1
57297: INC
57298: ST_TO_ADDR
57299: LD_INT 1
57301: PUSH
57302: FOR_DOWNTO
57303: IFFALSE 57380
// begin index := rand ( 1 , array ) ;
57305: LD_ADDR_VAR 0 4
57309: PUSH
57310: LD_INT 1
57312: PPUSH
57313: LD_VAR 0 1
57317: PPUSH
57318: CALL_OW 12
57322: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57323: LD_ADDR_VAR 0 2
57327: PUSH
57328: LD_VAR 0 2
57332: PPUSH
57333: LD_VAR 0 2
57337: PUSH
57338: LD_INT 1
57340: PLUS
57341: PPUSH
57342: LD_VAR 0 1
57346: PUSH
57347: LD_VAR 0 4
57351: ARRAY
57352: PPUSH
57353: CALL_OW 2
57357: ST_TO_ADDR
// array := Delete ( array , index ) ;
57358: LD_ADDR_VAR 0 1
57362: PUSH
57363: LD_VAR 0 1
57367: PPUSH
57368: LD_VAR 0 4
57372: PPUSH
57373: CALL_OW 3
57377: ST_TO_ADDR
// end ;
57378: GO 57302
57380: POP
57381: POP
// end ;
57382: LD_VAR 0 2
57386: RET
// export function GetBaseMaterials ( base ) ; begin
57387: LD_INT 0
57389: PPUSH
// result := [ 0 , 0 , 0 ] ;
57390: LD_ADDR_VAR 0 2
57394: PUSH
57395: LD_INT 0
57397: PUSH
57398: LD_INT 0
57400: PUSH
57401: LD_INT 0
57403: PUSH
57404: EMPTY
57405: LIST
57406: LIST
57407: LIST
57408: ST_TO_ADDR
// if not base then
57409: LD_VAR 0 1
57413: NOT
57414: IFFALSE 57418
// exit ;
57416: GO 57467
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57418: LD_ADDR_VAR 0 2
57422: PUSH
57423: LD_VAR 0 1
57427: PPUSH
57428: LD_INT 1
57430: PPUSH
57431: CALL_OW 275
57435: PUSH
57436: LD_VAR 0 1
57440: PPUSH
57441: LD_INT 2
57443: PPUSH
57444: CALL_OW 275
57448: PUSH
57449: LD_VAR 0 1
57453: PPUSH
57454: LD_INT 3
57456: PPUSH
57457: CALL_OW 275
57461: PUSH
57462: EMPTY
57463: LIST
57464: LIST
57465: LIST
57466: ST_TO_ADDR
// end ; end_of_file
57467: LD_VAR 0 2
57471: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
57472: LD_INT 0
57474: PPUSH
57475: PPUSH
// skirmish := false ;
57476: LD_ADDR_EXP 57
57480: PUSH
57481: LD_INT 0
57483: ST_TO_ADDR
// debug_mc := false ;
57484: LD_ADDR_EXP 58
57488: PUSH
57489: LD_INT 0
57491: ST_TO_ADDR
// mc_bases := [ ] ;
57492: LD_ADDR_EXP 59
57496: PUSH
57497: EMPTY
57498: ST_TO_ADDR
// mc_sides := [ ] ;
57499: LD_ADDR_EXP 85
57503: PUSH
57504: EMPTY
57505: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
57506: LD_ADDR_EXP 60
57510: PUSH
57511: EMPTY
57512: ST_TO_ADDR
// mc_building_repairs := [ ] ;
57513: LD_ADDR_EXP 61
57517: PUSH
57518: EMPTY
57519: ST_TO_ADDR
// mc_need_heal := [ ] ;
57520: LD_ADDR_EXP 62
57524: PUSH
57525: EMPTY
57526: ST_TO_ADDR
// mc_healers := [ ] ;
57527: LD_ADDR_EXP 63
57531: PUSH
57532: EMPTY
57533: ST_TO_ADDR
// mc_build_list := [ ] ;
57534: LD_ADDR_EXP 64
57538: PUSH
57539: EMPTY
57540: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
57541: LD_ADDR_EXP 91
57545: PUSH
57546: EMPTY
57547: ST_TO_ADDR
// mc_builders := [ ] ;
57548: LD_ADDR_EXP 65
57552: PUSH
57553: EMPTY
57554: ST_TO_ADDR
// mc_construct_list := [ ] ;
57555: LD_ADDR_EXP 66
57559: PUSH
57560: EMPTY
57561: ST_TO_ADDR
// mc_turret_list := [ ] ;
57562: LD_ADDR_EXP 67
57566: PUSH
57567: EMPTY
57568: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
57569: LD_ADDR_EXP 68
57573: PUSH
57574: EMPTY
57575: ST_TO_ADDR
// mc_miners := [ ] ;
57576: LD_ADDR_EXP 73
57580: PUSH
57581: EMPTY
57582: ST_TO_ADDR
// mc_mines := [ ] ;
57583: LD_ADDR_EXP 72
57587: PUSH
57588: EMPTY
57589: ST_TO_ADDR
// mc_minefields := [ ] ;
57590: LD_ADDR_EXP 74
57594: PUSH
57595: EMPTY
57596: ST_TO_ADDR
// mc_crates := [ ] ;
57597: LD_ADDR_EXP 75
57601: PUSH
57602: EMPTY
57603: ST_TO_ADDR
// mc_crates_collector := [ ] ;
57604: LD_ADDR_EXP 76
57608: PUSH
57609: EMPTY
57610: ST_TO_ADDR
// mc_crates_area := [ ] ;
57611: LD_ADDR_EXP 77
57615: PUSH
57616: EMPTY
57617: ST_TO_ADDR
// mc_vehicles := [ ] ;
57618: LD_ADDR_EXP 78
57622: PUSH
57623: EMPTY
57624: ST_TO_ADDR
// mc_attack := [ ] ;
57625: LD_ADDR_EXP 79
57629: PUSH
57630: EMPTY
57631: ST_TO_ADDR
// mc_produce := [ ] ;
57632: LD_ADDR_EXP 80
57636: PUSH
57637: EMPTY
57638: ST_TO_ADDR
// mc_defender := [ ] ;
57639: LD_ADDR_EXP 81
57643: PUSH
57644: EMPTY
57645: ST_TO_ADDR
// mc_parking := [ ] ;
57646: LD_ADDR_EXP 83
57650: PUSH
57651: EMPTY
57652: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
57653: LD_ADDR_EXP 69
57657: PUSH
57658: EMPTY
57659: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
57660: LD_ADDR_EXP 71
57664: PUSH
57665: EMPTY
57666: ST_TO_ADDR
// mc_scan := [ ] ;
57667: LD_ADDR_EXP 82
57671: PUSH
57672: EMPTY
57673: ST_TO_ADDR
// mc_scan_area := [ ] ;
57674: LD_ADDR_EXP 84
57678: PUSH
57679: EMPTY
57680: ST_TO_ADDR
// mc_tech := [ ] ;
57681: LD_ADDR_EXP 86
57685: PUSH
57686: EMPTY
57687: ST_TO_ADDR
// mc_class := [ ] ;
57688: LD_ADDR_EXP 100
57692: PUSH
57693: EMPTY
57694: ST_TO_ADDR
// mc_class_case_use := [ ] ;
57695: LD_ADDR_EXP 101
57699: PUSH
57700: EMPTY
57701: ST_TO_ADDR
// end ;
57702: LD_VAR 0 1
57706: RET
// export function MC_Kill ( base ) ; begin
57707: LD_INT 0
57709: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57710: LD_ADDR_EXP 59
57714: PUSH
57715: LD_EXP 59
57719: PPUSH
57720: LD_VAR 0 1
57724: PPUSH
57725: EMPTY
57726: PPUSH
57727: CALL_OW 1
57731: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57732: LD_ADDR_EXP 60
57736: PUSH
57737: LD_EXP 60
57741: PPUSH
57742: LD_VAR 0 1
57746: PPUSH
57747: EMPTY
57748: PPUSH
57749: CALL_OW 1
57753: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57754: LD_ADDR_EXP 61
57758: PUSH
57759: LD_EXP 61
57763: PPUSH
57764: LD_VAR 0 1
57768: PPUSH
57769: EMPTY
57770: PPUSH
57771: CALL_OW 1
57775: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57776: LD_ADDR_EXP 62
57780: PUSH
57781: LD_EXP 62
57785: PPUSH
57786: LD_VAR 0 1
57790: PPUSH
57791: EMPTY
57792: PPUSH
57793: CALL_OW 1
57797: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57798: LD_ADDR_EXP 63
57802: PUSH
57803: LD_EXP 63
57807: PPUSH
57808: LD_VAR 0 1
57812: PPUSH
57813: EMPTY
57814: PPUSH
57815: CALL_OW 1
57819: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57820: LD_ADDR_EXP 64
57824: PUSH
57825: LD_EXP 64
57829: PPUSH
57830: LD_VAR 0 1
57834: PPUSH
57835: EMPTY
57836: PPUSH
57837: CALL_OW 1
57841: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57842: LD_ADDR_EXP 65
57846: PUSH
57847: LD_EXP 65
57851: PPUSH
57852: LD_VAR 0 1
57856: PPUSH
57857: EMPTY
57858: PPUSH
57859: CALL_OW 1
57863: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57864: LD_ADDR_EXP 66
57868: PUSH
57869: LD_EXP 66
57873: PPUSH
57874: LD_VAR 0 1
57878: PPUSH
57879: EMPTY
57880: PPUSH
57881: CALL_OW 1
57885: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57886: LD_ADDR_EXP 67
57890: PUSH
57891: LD_EXP 67
57895: PPUSH
57896: LD_VAR 0 1
57900: PPUSH
57901: EMPTY
57902: PPUSH
57903: CALL_OW 1
57907: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57908: LD_ADDR_EXP 68
57912: PUSH
57913: LD_EXP 68
57917: PPUSH
57918: LD_VAR 0 1
57922: PPUSH
57923: EMPTY
57924: PPUSH
57925: CALL_OW 1
57929: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57930: LD_ADDR_EXP 69
57934: PUSH
57935: LD_EXP 69
57939: PPUSH
57940: LD_VAR 0 1
57944: PPUSH
57945: EMPTY
57946: PPUSH
57947: CALL_OW 1
57951: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57952: LD_ADDR_EXP 70
57956: PUSH
57957: LD_EXP 70
57961: PPUSH
57962: LD_VAR 0 1
57966: PPUSH
57967: LD_INT 0
57969: PPUSH
57970: CALL_OW 1
57974: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57975: LD_ADDR_EXP 71
57979: PUSH
57980: LD_EXP 71
57984: PPUSH
57985: LD_VAR 0 1
57989: PPUSH
57990: EMPTY
57991: PPUSH
57992: CALL_OW 1
57996: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57997: LD_ADDR_EXP 72
58001: PUSH
58002: LD_EXP 72
58006: PPUSH
58007: LD_VAR 0 1
58011: PPUSH
58012: EMPTY
58013: PPUSH
58014: CALL_OW 1
58018: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58019: LD_ADDR_EXP 73
58023: PUSH
58024: LD_EXP 73
58028: PPUSH
58029: LD_VAR 0 1
58033: PPUSH
58034: EMPTY
58035: PPUSH
58036: CALL_OW 1
58040: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58041: LD_ADDR_EXP 74
58045: PUSH
58046: LD_EXP 74
58050: PPUSH
58051: LD_VAR 0 1
58055: PPUSH
58056: EMPTY
58057: PPUSH
58058: CALL_OW 1
58062: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58063: LD_ADDR_EXP 75
58067: PUSH
58068: LD_EXP 75
58072: PPUSH
58073: LD_VAR 0 1
58077: PPUSH
58078: EMPTY
58079: PPUSH
58080: CALL_OW 1
58084: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58085: LD_ADDR_EXP 76
58089: PUSH
58090: LD_EXP 76
58094: PPUSH
58095: LD_VAR 0 1
58099: PPUSH
58100: EMPTY
58101: PPUSH
58102: CALL_OW 1
58106: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58107: LD_ADDR_EXP 77
58111: PUSH
58112: LD_EXP 77
58116: PPUSH
58117: LD_VAR 0 1
58121: PPUSH
58122: EMPTY
58123: PPUSH
58124: CALL_OW 1
58128: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58129: LD_ADDR_EXP 78
58133: PUSH
58134: LD_EXP 78
58138: PPUSH
58139: LD_VAR 0 1
58143: PPUSH
58144: EMPTY
58145: PPUSH
58146: CALL_OW 1
58150: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58151: LD_ADDR_EXP 79
58155: PUSH
58156: LD_EXP 79
58160: PPUSH
58161: LD_VAR 0 1
58165: PPUSH
58166: EMPTY
58167: PPUSH
58168: CALL_OW 1
58172: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58173: LD_ADDR_EXP 80
58177: PUSH
58178: LD_EXP 80
58182: PPUSH
58183: LD_VAR 0 1
58187: PPUSH
58188: EMPTY
58189: PPUSH
58190: CALL_OW 1
58194: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58195: LD_ADDR_EXP 81
58199: PUSH
58200: LD_EXP 81
58204: PPUSH
58205: LD_VAR 0 1
58209: PPUSH
58210: EMPTY
58211: PPUSH
58212: CALL_OW 1
58216: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58217: LD_ADDR_EXP 82
58221: PUSH
58222: LD_EXP 82
58226: PPUSH
58227: LD_VAR 0 1
58231: PPUSH
58232: EMPTY
58233: PPUSH
58234: CALL_OW 1
58238: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58239: LD_ADDR_EXP 83
58243: PUSH
58244: LD_EXP 83
58248: PPUSH
58249: LD_VAR 0 1
58253: PPUSH
58254: EMPTY
58255: PPUSH
58256: CALL_OW 1
58260: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58261: LD_ADDR_EXP 84
58265: PUSH
58266: LD_EXP 84
58270: PPUSH
58271: LD_VAR 0 1
58275: PPUSH
58276: EMPTY
58277: PPUSH
58278: CALL_OW 1
58282: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58283: LD_ADDR_EXP 86
58287: PUSH
58288: LD_EXP 86
58292: PPUSH
58293: LD_VAR 0 1
58297: PPUSH
58298: EMPTY
58299: PPUSH
58300: CALL_OW 1
58304: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58305: LD_ADDR_EXP 88
58309: PUSH
58310: LD_EXP 88
58314: PPUSH
58315: LD_VAR 0 1
58319: PPUSH
58320: EMPTY
58321: PPUSH
58322: CALL_OW 1
58326: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58327: LD_ADDR_EXP 89
58331: PUSH
58332: LD_EXP 89
58336: PPUSH
58337: LD_VAR 0 1
58341: PPUSH
58342: EMPTY
58343: PPUSH
58344: CALL_OW 1
58348: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58349: LD_ADDR_EXP 90
58353: PUSH
58354: LD_EXP 90
58358: PPUSH
58359: LD_VAR 0 1
58363: PPUSH
58364: EMPTY
58365: PPUSH
58366: CALL_OW 1
58370: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58371: LD_ADDR_EXP 91
58375: PUSH
58376: LD_EXP 91
58380: PPUSH
58381: LD_VAR 0 1
58385: PPUSH
58386: EMPTY
58387: PPUSH
58388: CALL_OW 1
58392: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58393: LD_ADDR_EXP 92
58397: PUSH
58398: LD_EXP 92
58402: PPUSH
58403: LD_VAR 0 1
58407: PPUSH
58408: EMPTY
58409: PPUSH
58410: CALL_OW 1
58414: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58415: LD_ADDR_EXP 93
58419: PUSH
58420: LD_EXP 93
58424: PPUSH
58425: LD_VAR 0 1
58429: PPUSH
58430: EMPTY
58431: PPUSH
58432: CALL_OW 1
58436: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58437: LD_ADDR_EXP 94
58441: PUSH
58442: LD_EXP 94
58446: PPUSH
58447: LD_VAR 0 1
58451: PPUSH
58452: EMPTY
58453: PPUSH
58454: CALL_OW 1
58458: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58459: LD_ADDR_EXP 95
58463: PUSH
58464: LD_EXP 95
58468: PPUSH
58469: LD_VAR 0 1
58473: PPUSH
58474: EMPTY
58475: PPUSH
58476: CALL_OW 1
58480: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58481: LD_ADDR_EXP 96
58485: PUSH
58486: LD_EXP 96
58490: PPUSH
58491: LD_VAR 0 1
58495: PPUSH
58496: EMPTY
58497: PPUSH
58498: CALL_OW 1
58502: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58503: LD_ADDR_EXP 97
58507: PUSH
58508: LD_EXP 97
58512: PPUSH
58513: LD_VAR 0 1
58517: PPUSH
58518: EMPTY
58519: PPUSH
58520: CALL_OW 1
58524: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58525: LD_ADDR_EXP 98
58529: PUSH
58530: LD_EXP 98
58534: PPUSH
58535: LD_VAR 0 1
58539: PPUSH
58540: EMPTY
58541: PPUSH
58542: CALL_OW 1
58546: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58547: LD_ADDR_EXP 99
58551: PUSH
58552: LD_EXP 99
58556: PPUSH
58557: LD_VAR 0 1
58561: PPUSH
58562: EMPTY
58563: PPUSH
58564: CALL_OW 1
58568: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58569: LD_ADDR_EXP 100
58573: PUSH
58574: LD_EXP 100
58578: PPUSH
58579: LD_VAR 0 1
58583: PPUSH
58584: EMPTY
58585: PPUSH
58586: CALL_OW 1
58590: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58591: LD_ADDR_EXP 101
58595: PUSH
58596: LD_EXP 101
58600: PPUSH
58601: LD_VAR 0 1
58605: PPUSH
58606: LD_INT 0
58608: PPUSH
58609: CALL_OW 1
58613: ST_TO_ADDR
// end ;
58614: LD_VAR 0 2
58618: RET
// export function MC_Add ( side , units ) ; var base ; begin
58619: LD_INT 0
58621: PPUSH
58622: PPUSH
// base := mc_bases + 1 ;
58623: LD_ADDR_VAR 0 4
58627: PUSH
58628: LD_EXP 59
58632: PUSH
58633: LD_INT 1
58635: PLUS
58636: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
58637: LD_ADDR_EXP 85
58641: PUSH
58642: LD_EXP 85
58646: PPUSH
58647: LD_VAR 0 4
58651: PPUSH
58652: LD_VAR 0 1
58656: PPUSH
58657: CALL_OW 1
58661: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
58662: LD_ADDR_EXP 59
58666: PUSH
58667: LD_EXP 59
58671: PPUSH
58672: LD_VAR 0 4
58676: PPUSH
58677: LD_VAR 0 2
58681: PPUSH
58682: CALL_OW 1
58686: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58687: LD_ADDR_EXP 60
58691: PUSH
58692: LD_EXP 60
58696: PPUSH
58697: LD_VAR 0 4
58701: PPUSH
58702: EMPTY
58703: PPUSH
58704: CALL_OW 1
58708: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58709: LD_ADDR_EXP 61
58713: PUSH
58714: LD_EXP 61
58718: PPUSH
58719: LD_VAR 0 4
58723: PPUSH
58724: EMPTY
58725: PPUSH
58726: CALL_OW 1
58730: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58731: LD_ADDR_EXP 62
58735: PUSH
58736: LD_EXP 62
58740: PPUSH
58741: LD_VAR 0 4
58745: PPUSH
58746: EMPTY
58747: PPUSH
58748: CALL_OW 1
58752: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58753: LD_ADDR_EXP 63
58757: PUSH
58758: LD_EXP 63
58762: PPUSH
58763: LD_VAR 0 4
58767: PPUSH
58768: EMPTY
58769: PPUSH
58770: CALL_OW 1
58774: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58775: LD_ADDR_EXP 64
58779: PUSH
58780: LD_EXP 64
58784: PPUSH
58785: LD_VAR 0 4
58789: PPUSH
58790: EMPTY
58791: PPUSH
58792: CALL_OW 1
58796: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58797: LD_ADDR_EXP 65
58801: PUSH
58802: LD_EXP 65
58806: PPUSH
58807: LD_VAR 0 4
58811: PPUSH
58812: EMPTY
58813: PPUSH
58814: CALL_OW 1
58818: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58819: LD_ADDR_EXP 66
58823: PUSH
58824: LD_EXP 66
58828: PPUSH
58829: LD_VAR 0 4
58833: PPUSH
58834: EMPTY
58835: PPUSH
58836: CALL_OW 1
58840: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58841: LD_ADDR_EXP 67
58845: PUSH
58846: LD_EXP 67
58850: PPUSH
58851: LD_VAR 0 4
58855: PPUSH
58856: EMPTY
58857: PPUSH
58858: CALL_OW 1
58862: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58863: LD_ADDR_EXP 68
58867: PUSH
58868: LD_EXP 68
58872: PPUSH
58873: LD_VAR 0 4
58877: PPUSH
58878: EMPTY
58879: PPUSH
58880: CALL_OW 1
58884: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58885: LD_ADDR_EXP 69
58889: PUSH
58890: LD_EXP 69
58894: PPUSH
58895: LD_VAR 0 4
58899: PPUSH
58900: EMPTY
58901: PPUSH
58902: CALL_OW 1
58906: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58907: LD_ADDR_EXP 70
58911: PUSH
58912: LD_EXP 70
58916: PPUSH
58917: LD_VAR 0 4
58921: PPUSH
58922: LD_INT 0
58924: PPUSH
58925: CALL_OW 1
58929: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58930: LD_ADDR_EXP 71
58934: PUSH
58935: LD_EXP 71
58939: PPUSH
58940: LD_VAR 0 4
58944: PPUSH
58945: EMPTY
58946: PPUSH
58947: CALL_OW 1
58951: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58952: LD_ADDR_EXP 72
58956: PUSH
58957: LD_EXP 72
58961: PPUSH
58962: LD_VAR 0 4
58966: PPUSH
58967: EMPTY
58968: PPUSH
58969: CALL_OW 1
58973: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58974: LD_ADDR_EXP 73
58978: PUSH
58979: LD_EXP 73
58983: PPUSH
58984: LD_VAR 0 4
58988: PPUSH
58989: EMPTY
58990: PPUSH
58991: CALL_OW 1
58995: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58996: LD_ADDR_EXP 74
59000: PUSH
59001: LD_EXP 74
59005: PPUSH
59006: LD_VAR 0 4
59010: PPUSH
59011: EMPTY
59012: PPUSH
59013: CALL_OW 1
59017: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
59018: LD_ADDR_EXP 75
59022: PUSH
59023: LD_EXP 75
59027: PPUSH
59028: LD_VAR 0 4
59032: PPUSH
59033: EMPTY
59034: PPUSH
59035: CALL_OW 1
59039: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
59040: LD_ADDR_EXP 76
59044: PUSH
59045: LD_EXP 76
59049: PPUSH
59050: LD_VAR 0 4
59054: PPUSH
59055: EMPTY
59056: PPUSH
59057: CALL_OW 1
59061: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
59062: LD_ADDR_EXP 77
59066: PUSH
59067: LD_EXP 77
59071: PPUSH
59072: LD_VAR 0 4
59076: PPUSH
59077: EMPTY
59078: PPUSH
59079: CALL_OW 1
59083: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
59084: LD_ADDR_EXP 78
59088: PUSH
59089: LD_EXP 78
59093: PPUSH
59094: LD_VAR 0 4
59098: PPUSH
59099: EMPTY
59100: PPUSH
59101: CALL_OW 1
59105: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
59106: LD_ADDR_EXP 79
59110: PUSH
59111: LD_EXP 79
59115: PPUSH
59116: LD_VAR 0 4
59120: PPUSH
59121: EMPTY
59122: PPUSH
59123: CALL_OW 1
59127: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
59128: LD_ADDR_EXP 80
59132: PUSH
59133: LD_EXP 80
59137: PPUSH
59138: LD_VAR 0 4
59142: PPUSH
59143: EMPTY
59144: PPUSH
59145: CALL_OW 1
59149: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
59150: LD_ADDR_EXP 81
59154: PUSH
59155: LD_EXP 81
59159: PPUSH
59160: LD_VAR 0 4
59164: PPUSH
59165: EMPTY
59166: PPUSH
59167: CALL_OW 1
59171: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
59172: LD_ADDR_EXP 82
59176: PUSH
59177: LD_EXP 82
59181: PPUSH
59182: LD_VAR 0 4
59186: PPUSH
59187: EMPTY
59188: PPUSH
59189: CALL_OW 1
59193: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
59194: LD_ADDR_EXP 83
59198: PUSH
59199: LD_EXP 83
59203: PPUSH
59204: LD_VAR 0 4
59208: PPUSH
59209: EMPTY
59210: PPUSH
59211: CALL_OW 1
59215: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
59216: LD_ADDR_EXP 84
59220: PUSH
59221: LD_EXP 84
59225: PPUSH
59226: LD_VAR 0 4
59230: PPUSH
59231: EMPTY
59232: PPUSH
59233: CALL_OW 1
59237: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
59238: LD_ADDR_EXP 86
59242: PUSH
59243: LD_EXP 86
59247: PPUSH
59248: LD_VAR 0 4
59252: PPUSH
59253: EMPTY
59254: PPUSH
59255: CALL_OW 1
59259: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
59260: LD_ADDR_EXP 88
59264: PUSH
59265: LD_EXP 88
59269: PPUSH
59270: LD_VAR 0 4
59274: PPUSH
59275: EMPTY
59276: PPUSH
59277: CALL_OW 1
59281: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
59282: LD_ADDR_EXP 89
59286: PUSH
59287: LD_EXP 89
59291: PPUSH
59292: LD_VAR 0 4
59296: PPUSH
59297: EMPTY
59298: PPUSH
59299: CALL_OW 1
59303: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
59304: LD_ADDR_EXP 90
59308: PUSH
59309: LD_EXP 90
59313: PPUSH
59314: LD_VAR 0 4
59318: PPUSH
59319: EMPTY
59320: PPUSH
59321: CALL_OW 1
59325: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
59326: LD_ADDR_EXP 91
59330: PUSH
59331: LD_EXP 91
59335: PPUSH
59336: LD_VAR 0 4
59340: PPUSH
59341: EMPTY
59342: PPUSH
59343: CALL_OW 1
59347: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
59348: LD_ADDR_EXP 92
59352: PUSH
59353: LD_EXP 92
59357: PPUSH
59358: LD_VAR 0 4
59362: PPUSH
59363: EMPTY
59364: PPUSH
59365: CALL_OW 1
59369: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
59370: LD_ADDR_EXP 93
59374: PUSH
59375: LD_EXP 93
59379: PPUSH
59380: LD_VAR 0 4
59384: PPUSH
59385: EMPTY
59386: PPUSH
59387: CALL_OW 1
59391: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
59392: LD_ADDR_EXP 94
59396: PUSH
59397: LD_EXP 94
59401: PPUSH
59402: LD_VAR 0 4
59406: PPUSH
59407: EMPTY
59408: PPUSH
59409: CALL_OW 1
59413: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
59414: LD_ADDR_EXP 95
59418: PUSH
59419: LD_EXP 95
59423: PPUSH
59424: LD_VAR 0 4
59428: PPUSH
59429: EMPTY
59430: PPUSH
59431: CALL_OW 1
59435: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
59436: LD_ADDR_EXP 96
59440: PUSH
59441: LD_EXP 96
59445: PPUSH
59446: LD_VAR 0 4
59450: PPUSH
59451: EMPTY
59452: PPUSH
59453: CALL_OW 1
59457: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
59458: LD_ADDR_EXP 97
59462: PUSH
59463: LD_EXP 97
59467: PPUSH
59468: LD_VAR 0 4
59472: PPUSH
59473: EMPTY
59474: PPUSH
59475: CALL_OW 1
59479: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
59480: LD_ADDR_EXP 98
59484: PUSH
59485: LD_EXP 98
59489: PPUSH
59490: LD_VAR 0 4
59494: PPUSH
59495: EMPTY
59496: PPUSH
59497: CALL_OW 1
59501: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59502: LD_ADDR_EXP 99
59506: PUSH
59507: LD_EXP 99
59511: PPUSH
59512: LD_VAR 0 4
59516: PPUSH
59517: EMPTY
59518: PPUSH
59519: CALL_OW 1
59523: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59524: LD_ADDR_EXP 100
59528: PUSH
59529: LD_EXP 100
59533: PPUSH
59534: LD_VAR 0 4
59538: PPUSH
59539: EMPTY
59540: PPUSH
59541: CALL_OW 1
59545: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59546: LD_ADDR_EXP 101
59550: PUSH
59551: LD_EXP 101
59555: PPUSH
59556: LD_VAR 0 4
59560: PPUSH
59561: LD_INT 0
59563: PPUSH
59564: CALL_OW 1
59568: ST_TO_ADDR
// result := base ;
59569: LD_ADDR_VAR 0 3
59573: PUSH
59574: LD_VAR 0 4
59578: ST_TO_ADDR
// end ;
59579: LD_VAR 0 3
59583: RET
// export function MC_Start ( ) ; var i ; begin
59584: LD_INT 0
59586: PPUSH
59587: PPUSH
// for i = 1 to mc_bases do
59588: LD_ADDR_VAR 0 2
59592: PUSH
59593: DOUBLE
59594: LD_INT 1
59596: DEC
59597: ST_TO_ADDR
59598: LD_EXP 59
59602: PUSH
59603: FOR_TO
59604: IFFALSE 60681
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
59606: LD_ADDR_EXP 59
59610: PUSH
59611: LD_EXP 59
59615: PPUSH
59616: LD_VAR 0 2
59620: PPUSH
59621: LD_EXP 59
59625: PUSH
59626: LD_VAR 0 2
59630: ARRAY
59631: PUSH
59632: LD_INT 0
59634: DIFF
59635: PPUSH
59636: CALL_OW 1
59640: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
59641: LD_ADDR_EXP 60
59645: PUSH
59646: LD_EXP 60
59650: PPUSH
59651: LD_VAR 0 2
59655: PPUSH
59656: EMPTY
59657: PPUSH
59658: CALL_OW 1
59662: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59663: LD_ADDR_EXP 61
59667: PUSH
59668: LD_EXP 61
59672: PPUSH
59673: LD_VAR 0 2
59677: PPUSH
59678: EMPTY
59679: PPUSH
59680: CALL_OW 1
59684: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
59685: LD_ADDR_EXP 62
59689: PUSH
59690: LD_EXP 62
59694: PPUSH
59695: LD_VAR 0 2
59699: PPUSH
59700: EMPTY
59701: PPUSH
59702: CALL_OW 1
59706: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
59707: LD_ADDR_EXP 63
59711: PUSH
59712: LD_EXP 63
59716: PPUSH
59717: LD_VAR 0 2
59721: PPUSH
59722: EMPTY
59723: PUSH
59724: EMPTY
59725: PUSH
59726: EMPTY
59727: LIST
59728: LIST
59729: PPUSH
59730: CALL_OW 1
59734: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59735: LD_ADDR_EXP 64
59739: PUSH
59740: LD_EXP 64
59744: PPUSH
59745: LD_VAR 0 2
59749: PPUSH
59750: EMPTY
59751: PPUSH
59752: CALL_OW 1
59756: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59757: LD_ADDR_EXP 91
59761: PUSH
59762: LD_EXP 91
59766: PPUSH
59767: LD_VAR 0 2
59771: PPUSH
59772: EMPTY
59773: PPUSH
59774: CALL_OW 1
59778: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59779: LD_ADDR_EXP 65
59783: PUSH
59784: LD_EXP 65
59788: PPUSH
59789: LD_VAR 0 2
59793: PPUSH
59794: EMPTY
59795: PPUSH
59796: CALL_OW 1
59800: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59801: LD_ADDR_EXP 66
59805: PUSH
59806: LD_EXP 66
59810: PPUSH
59811: LD_VAR 0 2
59815: PPUSH
59816: EMPTY
59817: PPUSH
59818: CALL_OW 1
59822: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59823: LD_ADDR_EXP 67
59827: PUSH
59828: LD_EXP 67
59832: PPUSH
59833: LD_VAR 0 2
59837: PPUSH
59838: LD_EXP 59
59842: PUSH
59843: LD_VAR 0 2
59847: ARRAY
59848: PPUSH
59849: LD_INT 2
59851: PUSH
59852: LD_INT 30
59854: PUSH
59855: LD_INT 32
59857: PUSH
59858: EMPTY
59859: LIST
59860: LIST
59861: PUSH
59862: LD_INT 30
59864: PUSH
59865: LD_INT 33
59867: PUSH
59868: EMPTY
59869: LIST
59870: LIST
59871: PUSH
59872: EMPTY
59873: LIST
59874: LIST
59875: LIST
59876: PPUSH
59877: CALL_OW 72
59881: PPUSH
59882: CALL_OW 1
59886: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59887: LD_ADDR_EXP 68
59891: PUSH
59892: LD_EXP 68
59896: PPUSH
59897: LD_VAR 0 2
59901: PPUSH
59902: LD_EXP 59
59906: PUSH
59907: LD_VAR 0 2
59911: ARRAY
59912: PPUSH
59913: LD_INT 2
59915: PUSH
59916: LD_INT 30
59918: PUSH
59919: LD_INT 32
59921: PUSH
59922: EMPTY
59923: LIST
59924: LIST
59925: PUSH
59926: LD_INT 30
59928: PUSH
59929: LD_INT 31
59931: PUSH
59932: EMPTY
59933: LIST
59934: LIST
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: LIST
59940: PUSH
59941: LD_INT 58
59943: PUSH
59944: EMPTY
59945: LIST
59946: PUSH
59947: EMPTY
59948: LIST
59949: LIST
59950: PPUSH
59951: CALL_OW 72
59955: PPUSH
59956: CALL_OW 1
59960: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
59961: LD_ADDR_EXP 69
59965: PUSH
59966: LD_EXP 69
59970: PPUSH
59971: LD_VAR 0 2
59975: PPUSH
59976: EMPTY
59977: PPUSH
59978: CALL_OW 1
59982: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
59983: LD_ADDR_EXP 73
59987: PUSH
59988: LD_EXP 73
59992: PPUSH
59993: LD_VAR 0 2
59997: PPUSH
59998: EMPTY
59999: PPUSH
60000: CALL_OW 1
60004: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
60005: LD_ADDR_EXP 72
60009: PUSH
60010: LD_EXP 72
60014: PPUSH
60015: LD_VAR 0 2
60019: PPUSH
60020: EMPTY
60021: PPUSH
60022: CALL_OW 1
60026: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
60027: LD_ADDR_EXP 74
60031: PUSH
60032: LD_EXP 74
60036: PPUSH
60037: LD_VAR 0 2
60041: PPUSH
60042: EMPTY
60043: PPUSH
60044: CALL_OW 1
60048: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
60049: LD_ADDR_EXP 75
60053: PUSH
60054: LD_EXP 75
60058: PPUSH
60059: LD_VAR 0 2
60063: PPUSH
60064: EMPTY
60065: PPUSH
60066: CALL_OW 1
60070: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60071: LD_ADDR_EXP 76
60075: PUSH
60076: LD_EXP 76
60080: PPUSH
60081: LD_VAR 0 2
60085: PPUSH
60086: EMPTY
60087: PPUSH
60088: CALL_OW 1
60092: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
60093: LD_ADDR_EXP 77
60097: PUSH
60098: LD_EXP 77
60102: PPUSH
60103: LD_VAR 0 2
60107: PPUSH
60108: EMPTY
60109: PPUSH
60110: CALL_OW 1
60114: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
60115: LD_ADDR_EXP 78
60119: PUSH
60120: LD_EXP 78
60124: PPUSH
60125: LD_VAR 0 2
60129: PPUSH
60130: EMPTY
60131: PPUSH
60132: CALL_OW 1
60136: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
60137: LD_ADDR_EXP 79
60141: PUSH
60142: LD_EXP 79
60146: PPUSH
60147: LD_VAR 0 2
60151: PPUSH
60152: EMPTY
60153: PPUSH
60154: CALL_OW 1
60158: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
60159: LD_ADDR_EXP 80
60163: PUSH
60164: LD_EXP 80
60168: PPUSH
60169: LD_VAR 0 2
60173: PPUSH
60174: EMPTY
60175: PPUSH
60176: CALL_OW 1
60180: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
60181: LD_ADDR_EXP 81
60185: PUSH
60186: LD_EXP 81
60190: PPUSH
60191: LD_VAR 0 2
60195: PPUSH
60196: EMPTY
60197: PPUSH
60198: CALL_OW 1
60202: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
60203: LD_ADDR_EXP 70
60207: PUSH
60208: LD_EXP 70
60212: PPUSH
60213: LD_VAR 0 2
60217: PPUSH
60218: LD_INT 0
60220: PPUSH
60221: CALL_OW 1
60225: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
60226: LD_ADDR_EXP 83
60230: PUSH
60231: LD_EXP 83
60235: PPUSH
60236: LD_VAR 0 2
60240: PPUSH
60241: LD_INT 0
60243: PPUSH
60244: CALL_OW 1
60248: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
60249: LD_ADDR_EXP 71
60253: PUSH
60254: LD_EXP 71
60258: PPUSH
60259: LD_VAR 0 2
60263: PPUSH
60264: EMPTY
60265: PPUSH
60266: CALL_OW 1
60270: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
60271: LD_ADDR_EXP 82
60275: PUSH
60276: LD_EXP 82
60280: PPUSH
60281: LD_VAR 0 2
60285: PPUSH
60286: LD_INT 0
60288: PPUSH
60289: CALL_OW 1
60293: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
60294: LD_ADDR_EXP 84
60298: PUSH
60299: LD_EXP 84
60303: PPUSH
60304: LD_VAR 0 2
60308: PPUSH
60309: EMPTY
60310: PPUSH
60311: CALL_OW 1
60315: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
60316: LD_ADDR_EXP 87
60320: PUSH
60321: LD_EXP 87
60325: PPUSH
60326: LD_VAR 0 2
60330: PPUSH
60331: LD_INT 0
60333: PPUSH
60334: CALL_OW 1
60338: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
60339: LD_ADDR_EXP 88
60343: PUSH
60344: LD_EXP 88
60348: PPUSH
60349: LD_VAR 0 2
60353: PPUSH
60354: EMPTY
60355: PPUSH
60356: CALL_OW 1
60360: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60361: LD_ADDR_EXP 89
60365: PUSH
60366: LD_EXP 89
60370: PPUSH
60371: LD_VAR 0 2
60375: PPUSH
60376: EMPTY
60377: PPUSH
60378: CALL_OW 1
60382: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60383: LD_ADDR_EXP 90
60387: PUSH
60388: LD_EXP 90
60392: PPUSH
60393: LD_VAR 0 2
60397: PPUSH
60398: EMPTY
60399: PPUSH
60400: CALL_OW 1
60404: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
60405: LD_ADDR_EXP 92
60409: PUSH
60410: LD_EXP 92
60414: PPUSH
60415: LD_VAR 0 2
60419: PPUSH
60420: LD_EXP 59
60424: PUSH
60425: LD_VAR 0 2
60429: ARRAY
60430: PPUSH
60431: LD_INT 2
60433: PUSH
60434: LD_INT 30
60436: PUSH
60437: LD_INT 6
60439: PUSH
60440: EMPTY
60441: LIST
60442: LIST
60443: PUSH
60444: LD_INT 30
60446: PUSH
60447: LD_INT 7
60449: PUSH
60450: EMPTY
60451: LIST
60452: LIST
60453: PUSH
60454: LD_INT 30
60456: PUSH
60457: LD_INT 8
60459: PUSH
60460: EMPTY
60461: LIST
60462: LIST
60463: PUSH
60464: EMPTY
60465: LIST
60466: LIST
60467: LIST
60468: LIST
60469: PPUSH
60470: CALL_OW 72
60474: PPUSH
60475: CALL_OW 1
60479: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
60480: LD_ADDR_EXP 93
60484: PUSH
60485: LD_EXP 93
60489: PPUSH
60490: LD_VAR 0 2
60494: PPUSH
60495: EMPTY
60496: PPUSH
60497: CALL_OW 1
60501: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
60502: LD_ADDR_EXP 94
60506: PUSH
60507: LD_EXP 94
60511: PPUSH
60512: LD_VAR 0 2
60516: PPUSH
60517: EMPTY
60518: PPUSH
60519: CALL_OW 1
60523: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
60524: LD_ADDR_EXP 95
60528: PUSH
60529: LD_EXP 95
60533: PPUSH
60534: LD_VAR 0 2
60538: PPUSH
60539: EMPTY
60540: PPUSH
60541: CALL_OW 1
60545: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
60546: LD_ADDR_EXP 96
60550: PUSH
60551: LD_EXP 96
60555: PPUSH
60556: LD_VAR 0 2
60560: PPUSH
60561: EMPTY
60562: PPUSH
60563: CALL_OW 1
60567: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60568: LD_ADDR_EXP 97
60572: PUSH
60573: LD_EXP 97
60577: PPUSH
60578: LD_VAR 0 2
60582: PPUSH
60583: EMPTY
60584: PPUSH
60585: CALL_OW 1
60589: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
60590: LD_ADDR_EXP 98
60594: PUSH
60595: LD_EXP 98
60599: PPUSH
60600: LD_VAR 0 2
60604: PPUSH
60605: EMPTY
60606: PPUSH
60607: CALL_OW 1
60611: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
60612: LD_ADDR_EXP 99
60616: PUSH
60617: LD_EXP 99
60621: PPUSH
60622: LD_VAR 0 2
60626: PPUSH
60627: EMPTY
60628: PPUSH
60629: CALL_OW 1
60633: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
60634: LD_ADDR_EXP 100
60638: PUSH
60639: LD_EXP 100
60643: PPUSH
60644: LD_VAR 0 2
60648: PPUSH
60649: EMPTY
60650: PPUSH
60651: CALL_OW 1
60655: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
60656: LD_ADDR_EXP 101
60660: PUSH
60661: LD_EXP 101
60665: PPUSH
60666: LD_VAR 0 2
60670: PPUSH
60671: LD_INT 0
60673: PPUSH
60674: CALL_OW 1
60678: ST_TO_ADDR
// end ;
60679: GO 59603
60681: POP
60682: POP
// MC_InitSides ( ) ;
60683: CALL 60969 0 0
// MC_InitResearch ( ) ;
60687: CALL 60708 0 0
// CustomInitMacro ( ) ;
60691: CALL 181 0 0
// skirmish := true ;
60695: LD_ADDR_EXP 57
60699: PUSH
60700: LD_INT 1
60702: ST_TO_ADDR
// end ;
60703: LD_VAR 0 1
60707: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60708: LD_INT 0
60710: PPUSH
60711: PPUSH
60712: PPUSH
60713: PPUSH
60714: PPUSH
60715: PPUSH
// if not mc_bases then
60716: LD_EXP 59
60720: NOT
60721: IFFALSE 60725
// exit ;
60723: GO 60964
// for i = 1 to 8 do
60725: LD_ADDR_VAR 0 2
60729: PUSH
60730: DOUBLE
60731: LD_INT 1
60733: DEC
60734: ST_TO_ADDR
60735: LD_INT 8
60737: PUSH
60738: FOR_TO
60739: IFFALSE 60765
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60741: LD_ADDR_EXP 86
60745: PUSH
60746: LD_EXP 86
60750: PPUSH
60751: LD_VAR 0 2
60755: PPUSH
60756: EMPTY
60757: PPUSH
60758: CALL_OW 1
60762: ST_TO_ADDR
60763: GO 60738
60765: POP
60766: POP
// tmp := [ ] ;
60767: LD_ADDR_VAR 0 5
60771: PUSH
60772: EMPTY
60773: ST_TO_ADDR
// for i = 1 to mc_sides do
60774: LD_ADDR_VAR 0 2
60778: PUSH
60779: DOUBLE
60780: LD_INT 1
60782: DEC
60783: ST_TO_ADDR
60784: LD_EXP 85
60788: PUSH
60789: FOR_TO
60790: IFFALSE 60848
// if not mc_sides [ i ] in tmp then
60792: LD_EXP 85
60796: PUSH
60797: LD_VAR 0 2
60801: ARRAY
60802: PUSH
60803: LD_VAR 0 5
60807: IN
60808: NOT
60809: IFFALSE 60846
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60811: LD_ADDR_VAR 0 5
60815: PUSH
60816: LD_VAR 0 5
60820: PPUSH
60821: LD_VAR 0 5
60825: PUSH
60826: LD_INT 1
60828: PLUS
60829: PPUSH
60830: LD_EXP 85
60834: PUSH
60835: LD_VAR 0 2
60839: ARRAY
60840: PPUSH
60841: CALL_OW 2
60845: ST_TO_ADDR
60846: GO 60789
60848: POP
60849: POP
// if not tmp then
60850: LD_VAR 0 5
60854: NOT
60855: IFFALSE 60859
// exit ;
60857: GO 60964
// for j in tmp do
60859: LD_ADDR_VAR 0 3
60863: PUSH
60864: LD_VAR 0 5
60868: PUSH
60869: FOR_IN
60870: IFFALSE 60962
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60872: LD_ADDR_VAR 0 6
60876: PUSH
60877: LD_INT 22
60879: PUSH
60880: LD_VAR 0 3
60884: PUSH
60885: EMPTY
60886: LIST
60887: LIST
60888: PPUSH
60889: CALL_OW 69
60893: ST_TO_ADDR
// if not un then
60894: LD_VAR 0 6
60898: NOT
60899: IFFALSE 60903
// continue ;
60901: GO 60869
// nation := GetNation ( un [ 1 ] ) ;
60903: LD_ADDR_VAR 0 4
60907: PUSH
60908: LD_VAR 0 6
60912: PUSH
60913: LD_INT 1
60915: ARRAY
60916: PPUSH
60917: CALL_OW 248
60921: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60922: LD_ADDR_EXP 86
60926: PUSH
60927: LD_EXP 86
60931: PPUSH
60932: LD_VAR 0 3
60936: PPUSH
60937: LD_VAR 0 3
60941: PPUSH
60942: LD_VAR 0 4
60946: PPUSH
60947: LD_INT 1
60949: PPUSH
60950: CALL 14347 0 3
60954: PPUSH
60955: CALL_OW 1
60959: ST_TO_ADDR
// end ;
60960: GO 60869
60962: POP
60963: POP
// end ;
60964: LD_VAR 0 1
60968: RET
// export function MC_InitSides ( ) ; var i ; begin
60969: LD_INT 0
60971: PPUSH
60972: PPUSH
// if not mc_bases then
60973: LD_EXP 59
60977: NOT
60978: IFFALSE 60982
// exit ;
60980: GO 61056
// for i = 1 to mc_bases do
60982: LD_ADDR_VAR 0 2
60986: PUSH
60987: DOUBLE
60988: LD_INT 1
60990: DEC
60991: ST_TO_ADDR
60992: LD_EXP 59
60996: PUSH
60997: FOR_TO
60998: IFFALSE 61054
// if mc_bases [ i ] then
61000: LD_EXP 59
61004: PUSH
61005: LD_VAR 0 2
61009: ARRAY
61010: IFFALSE 61052
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
61012: LD_ADDR_EXP 85
61016: PUSH
61017: LD_EXP 85
61021: PPUSH
61022: LD_VAR 0 2
61026: PPUSH
61027: LD_EXP 59
61031: PUSH
61032: LD_VAR 0 2
61036: ARRAY
61037: PUSH
61038: LD_INT 1
61040: ARRAY
61041: PPUSH
61042: CALL_OW 255
61046: PPUSH
61047: CALL_OW 1
61051: ST_TO_ADDR
61052: GO 60997
61054: POP
61055: POP
// end ;
61056: LD_VAR 0 1
61060: RET
// every 0 0$01 trigger skirmish do
61061: LD_EXP 57
61065: IFFALSE 61219
61067: GO 61069
61069: DISABLE
// begin enable ;
61070: ENABLE
// MC_CheckBuildings ( ) ;
61071: CALL 65717 0 0
// MC_CheckPeopleLife ( ) ;
61075: CALL 65842 0 0
// RaiseSailEvent ( 100 ) ;
61079: LD_INT 100
61081: PPUSH
61082: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
61086: LD_INT 103
61088: PPUSH
61089: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
61093: LD_INT 104
61095: PPUSH
61096: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
61100: LD_INT 105
61102: PPUSH
61103: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
61107: LD_INT 106
61109: PPUSH
61110: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
61114: LD_INT 107
61116: PPUSH
61117: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
61121: LD_INT 108
61123: PPUSH
61124: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
61128: LD_INT 109
61130: PPUSH
61131: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
61135: LD_INT 110
61137: PPUSH
61138: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
61142: LD_INT 111
61144: PPUSH
61145: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
61149: LD_INT 112
61151: PPUSH
61152: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
61156: LD_INT 113
61158: PPUSH
61159: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
61163: LD_INT 120
61165: PPUSH
61166: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
61170: LD_INT 121
61172: PPUSH
61173: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
61177: LD_INT 122
61179: PPUSH
61180: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
61184: LD_INT 123
61186: PPUSH
61187: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
61191: LD_INT 124
61193: PPUSH
61194: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
61198: LD_INT 125
61200: PPUSH
61201: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
61205: LD_INT 126
61207: PPUSH
61208: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
61212: LD_INT 200
61214: PPUSH
61215: CALL_OW 427
// end ;
61219: END
// on SailEvent ( event ) do begin if event < 100 then
61220: LD_VAR 0 1
61224: PUSH
61225: LD_INT 100
61227: LESS
61228: IFFALSE 61239
// CustomEvent ( event ) ;
61230: LD_VAR 0 1
61234: PPUSH
61235: CALL 13005 0 1
// if event = 100 then
61239: LD_VAR 0 1
61243: PUSH
61244: LD_INT 100
61246: EQUAL
61247: IFFALSE 61253
// MC_ClassManager ( ) ;
61249: CALL 61645 0 0
// if event = 101 then
61253: LD_VAR 0 1
61257: PUSH
61258: LD_INT 101
61260: EQUAL
61261: IFFALSE 61267
// MC_RepairBuildings ( ) ;
61263: CALL 66438 0 0
// if event = 102 then
61267: LD_VAR 0 1
61271: PUSH
61272: LD_INT 102
61274: EQUAL
61275: IFFALSE 61281
// MC_Heal ( ) ;
61277: CALL 67302 0 0
// if event = 103 then
61281: LD_VAR 0 1
61285: PUSH
61286: LD_INT 103
61288: EQUAL
61289: IFFALSE 61295
// MC_Build ( ) ;
61291: CALL 67724 0 0
// if event = 104 then
61295: LD_VAR 0 1
61299: PUSH
61300: LD_INT 104
61302: EQUAL
61303: IFFALSE 61309
// MC_TurretWeapon ( ) ;
61305: CALL 69337 0 0
// if event = 105 then
61309: LD_VAR 0 1
61313: PUSH
61314: LD_INT 105
61316: EQUAL
61317: IFFALSE 61323
// MC_BuildUpgrade ( ) ;
61319: CALL 68888 0 0
// if event = 106 then
61323: LD_VAR 0 1
61327: PUSH
61328: LD_INT 106
61330: EQUAL
61331: IFFALSE 61337
// MC_PlantMines ( ) ;
61333: CALL 69767 0 0
// if event = 107 then
61337: LD_VAR 0 1
61341: PUSH
61342: LD_INT 107
61344: EQUAL
61345: IFFALSE 61351
// MC_CollectCrates ( ) ;
61347: CALL 70565 0 0
// if event = 108 then
61351: LD_VAR 0 1
61355: PUSH
61356: LD_INT 108
61358: EQUAL
61359: IFFALSE 61365
// MC_LinkRemoteControl ( ) ;
61361: CALL 72341 0 0
// if event = 109 then
61365: LD_VAR 0 1
61369: PUSH
61370: LD_INT 109
61372: EQUAL
61373: IFFALSE 61379
// MC_ProduceVehicle ( ) ;
61375: CALL 72522 0 0
// if event = 110 then
61379: LD_VAR 0 1
61383: PUSH
61384: LD_INT 110
61386: EQUAL
61387: IFFALSE 61393
// MC_SendAttack ( ) ;
61389: CALL 72988 0 0
// if event = 111 then
61393: LD_VAR 0 1
61397: PUSH
61398: LD_INT 111
61400: EQUAL
61401: IFFALSE 61407
// MC_Defend ( ) ;
61403: CALL 73096 0 0
// if event = 112 then
61407: LD_VAR 0 1
61411: PUSH
61412: LD_INT 112
61414: EQUAL
61415: IFFALSE 61421
// MC_Research ( ) ;
61417: CALL 73701 0 0
// if event = 113 then
61421: LD_VAR 0 1
61425: PUSH
61426: LD_INT 113
61428: EQUAL
61429: IFFALSE 61435
// MC_MinesTrigger ( ) ;
61431: CALL 74815 0 0
// if event = 120 then
61435: LD_VAR 0 1
61439: PUSH
61440: LD_INT 120
61442: EQUAL
61443: IFFALSE 61449
// MC_RepairVehicle ( ) ;
61445: CALL 74914 0 0
// if event = 121 then
61449: LD_VAR 0 1
61453: PUSH
61454: LD_INT 121
61456: EQUAL
61457: IFFALSE 61463
// MC_TameApe ( ) ;
61459: CALL 75644 0 0
// if event = 122 then
61463: LD_VAR 0 1
61467: PUSH
61468: LD_INT 122
61470: EQUAL
61471: IFFALSE 61477
// MC_ChangeApeClass ( ) ;
61473: CALL 76473 0 0
// if event = 123 then
61477: LD_VAR 0 1
61481: PUSH
61482: LD_INT 123
61484: EQUAL
61485: IFFALSE 61491
// MC_Bazooka ( ) ;
61487: CALL 77123 0 0
// if event = 124 then
61491: LD_VAR 0 1
61495: PUSH
61496: LD_INT 124
61498: EQUAL
61499: IFFALSE 61505
// MC_TeleportExit ( ) ;
61501: CALL 77321 0 0
// if event = 125 then
61505: LD_VAR 0 1
61509: PUSH
61510: LD_INT 125
61512: EQUAL
61513: IFFALSE 61519
// MC_Deposits ( ) ;
61515: CALL 77968 0 0
// if event = 126 then
61519: LD_VAR 0 1
61523: PUSH
61524: LD_INT 126
61526: EQUAL
61527: IFFALSE 61533
// MC_RemoteDriver ( ) ;
61529: CALL 78593 0 0
// if event = 200 then
61533: LD_VAR 0 1
61537: PUSH
61538: LD_INT 200
61540: EQUAL
61541: IFFALSE 61547
// MC_Idle ( ) ;
61543: CALL 80542 0 0
// end ;
61547: PPOPN 1
61549: END
// export function MC_Reset ( base , tag ) ; var i ; begin
61550: LD_INT 0
61552: PPUSH
61553: PPUSH
// if not mc_bases [ base ] or not tag then
61554: LD_EXP 59
61558: PUSH
61559: LD_VAR 0 1
61563: ARRAY
61564: NOT
61565: PUSH
61566: LD_VAR 0 2
61570: NOT
61571: OR
61572: IFFALSE 61576
// exit ;
61574: GO 61640
// for i in mc_bases [ base ] union mc_ape [ base ] do
61576: LD_ADDR_VAR 0 4
61580: PUSH
61581: LD_EXP 59
61585: PUSH
61586: LD_VAR 0 1
61590: ARRAY
61591: PUSH
61592: LD_EXP 88
61596: PUSH
61597: LD_VAR 0 1
61601: ARRAY
61602: UNION
61603: PUSH
61604: FOR_IN
61605: IFFALSE 61638
// if GetTag ( i ) = tag then
61607: LD_VAR 0 4
61611: PPUSH
61612: CALL_OW 110
61616: PUSH
61617: LD_VAR 0 2
61621: EQUAL
61622: IFFALSE 61636
// SetTag ( i , 0 ) ;
61624: LD_VAR 0 4
61628: PPUSH
61629: LD_INT 0
61631: PPUSH
61632: CALL_OW 109
61636: GO 61604
61638: POP
61639: POP
// end ;
61640: LD_VAR 0 3
61644: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
61645: LD_INT 0
61647: PPUSH
61648: PPUSH
61649: PPUSH
61650: PPUSH
61651: PPUSH
61652: PPUSH
61653: PPUSH
61654: PPUSH
// if not mc_bases then
61655: LD_EXP 59
61659: NOT
61660: IFFALSE 61664
// exit ;
61662: GO 62122
// for i = 1 to mc_bases do
61664: LD_ADDR_VAR 0 2
61668: PUSH
61669: DOUBLE
61670: LD_INT 1
61672: DEC
61673: ST_TO_ADDR
61674: LD_EXP 59
61678: PUSH
61679: FOR_TO
61680: IFFALSE 62120
// begin tmp := MC_ClassCheckReq ( i ) ;
61682: LD_ADDR_VAR 0 4
61686: PUSH
61687: LD_VAR 0 2
61691: PPUSH
61692: CALL 62127 0 1
61696: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
61697: LD_ADDR_EXP 100
61701: PUSH
61702: LD_EXP 100
61706: PPUSH
61707: LD_VAR 0 2
61711: PPUSH
61712: LD_VAR 0 4
61716: PPUSH
61717: CALL_OW 1
61721: ST_TO_ADDR
// if not tmp then
61722: LD_VAR 0 4
61726: NOT
61727: IFFALSE 61731
// continue ;
61729: GO 61679
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61731: LD_ADDR_VAR 0 6
61735: PUSH
61736: LD_EXP 59
61740: PUSH
61741: LD_VAR 0 2
61745: ARRAY
61746: PPUSH
61747: LD_INT 2
61749: PUSH
61750: LD_INT 30
61752: PUSH
61753: LD_INT 4
61755: PUSH
61756: EMPTY
61757: LIST
61758: LIST
61759: PUSH
61760: LD_INT 30
61762: PUSH
61763: LD_INT 5
61765: PUSH
61766: EMPTY
61767: LIST
61768: LIST
61769: PUSH
61770: EMPTY
61771: LIST
61772: LIST
61773: LIST
61774: PPUSH
61775: CALL_OW 72
61779: PUSH
61780: LD_EXP 59
61784: PUSH
61785: LD_VAR 0 2
61789: ARRAY
61790: PPUSH
61791: LD_INT 2
61793: PUSH
61794: LD_INT 30
61796: PUSH
61797: LD_INT 0
61799: PUSH
61800: EMPTY
61801: LIST
61802: LIST
61803: PUSH
61804: LD_INT 30
61806: PUSH
61807: LD_INT 1
61809: PUSH
61810: EMPTY
61811: LIST
61812: LIST
61813: PUSH
61814: EMPTY
61815: LIST
61816: LIST
61817: LIST
61818: PPUSH
61819: CALL_OW 72
61823: PUSH
61824: LD_EXP 59
61828: PUSH
61829: LD_VAR 0 2
61833: ARRAY
61834: PPUSH
61835: LD_INT 30
61837: PUSH
61838: LD_INT 3
61840: PUSH
61841: EMPTY
61842: LIST
61843: LIST
61844: PPUSH
61845: CALL_OW 72
61849: PUSH
61850: LD_EXP 59
61854: PUSH
61855: LD_VAR 0 2
61859: ARRAY
61860: PPUSH
61861: LD_INT 2
61863: PUSH
61864: LD_INT 30
61866: PUSH
61867: LD_INT 6
61869: PUSH
61870: EMPTY
61871: LIST
61872: LIST
61873: PUSH
61874: LD_INT 30
61876: PUSH
61877: LD_INT 7
61879: PUSH
61880: EMPTY
61881: LIST
61882: LIST
61883: PUSH
61884: LD_INT 30
61886: PUSH
61887: LD_INT 8
61889: PUSH
61890: EMPTY
61891: LIST
61892: LIST
61893: PUSH
61894: EMPTY
61895: LIST
61896: LIST
61897: LIST
61898: LIST
61899: PPUSH
61900: CALL_OW 72
61904: PUSH
61905: EMPTY
61906: LIST
61907: LIST
61908: LIST
61909: LIST
61910: ST_TO_ADDR
// for j = 1 to 4 do
61911: LD_ADDR_VAR 0 3
61915: PUSH
61916: DOUBLE
61917: LD_INT 1
61919: DEC
61920: ST_TO_ADDR
61921: LD_INT 4
61923: PUSH
61924: FOR_TO
61925: IFFALSE 62116
// begin if not tmp [ j ] then
61927: LD_VAR 0 4
61931: PUSH
61932: LD_VAR 0 3
61936: ARRAY
61937: NOT
61938: IFFALSE 61942
// continue ;
61940: GO 61924
// for p in tmp [ j ] do
61942: LD_ADDR_VAR 0 5
61946: PUSH
61947: LD_VAR 0 4
61951: PUSH
61952: LD_VAR 0 3
61956: ARRAY
61957: PUSH
61958: FOR_IN
61959: IFFALSE 62112
// begin if not b [ j ] then
61961: LD_VAR 0 6
61965: PUSH
61966: LD_VAR 0 3
61970: ARRAY
61971: NOT
61972: IFFALSE 61976
// break ;
61974: GO 62112
// e := 0 ;
61976: LD_ADDR_VAR 0 7
61980: PUSH
61981: LD_INT 0
61983: ST_TO_ADDR
// for k in b [ j ] do
61984: LD_ADDR_VAR 0 8
61988: PUSH
61989: LD_VAR 0 6
61993: PUSH
61994: LD_VAR 0 3
61998: ARRAY
61999: PUSH
62000: FOR_IN
62001: IFFALSE 62028
// if IsNotFull ( k ) then
62003: LD_VAR 0 8
62007: PPUSH
62008: CALL 18787 0 1
62012: IFFALSE 62026
// begin e := k ;
62014: LD_ADDR_VAR 0 7
62018: PUSH
62019: LD_VAR 0 8
62023: ST_TO_ADDR
// break ;
62024: GO 62028
// end ;
62026: GO 62000
62028: POP
62029: POP
// if e and not UnitGoingToBuilding ( p , e ) then
62030: LD_VAR 0 7
62034: PUSH
62035: LD_VAR 0 5
62039: PPUSH
62040: LD_VAR 0 7
62044: PPUSH
62045: CALL 55932 0 2
62049: NOT
62050: AND
62051: IFFALSE 62110
// begin if IsInUnit ( p ) then
62053: LD_VAR 0 5
62057: PPUSH
62058: CALL_OW 310
62062: IFFALSE 62073
// ComExitBuilding ( p ) ;
62064: LD_VAR 0 5
62068: PPUSH
62069: CALL_OW 122
// ComEnterUnit ( p , e ) ;
62073: LD_VAR 0 5
62077: PPUSH
62078: LD_VAR 0 7
62082: PPUSH
62083: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
62087: LD_VAR 0 5
62091: PPUSH
62092: LD_VAR 0 3
62096: PPUSH
62097: CALL_OW 183
// AddComExitBuilding ( p ) ;
62101: LD_VAR 0 5
62105: PPUSH
62106: CALL_OW 182
// end ; end ;
62110: GO 61958
62112: POP
62113: POP
// end ;
62114: GO 61924
62116: POP
62117: POP
// end ;
62118: GO 61679
62120: POP
62121: POP
// end ;
62122: LD_VAR 0 1
62126: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
62127: LD_INT 0
62129: PPUSH
62130: PPUSH
62131: PPUSH
62132: PPUSH
62133: PPUSH
62134: PPUSH
62135: PPUSH
62136: PPUSH
62137: PPUSH
62138: PPUSH
62139: PPUSH
62140: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62141: LD_VAR 0 1
62145: NOT
62146: PUSH
62147: LD_EXP 59
62151: PUSH
62152: LD_VAR 0 1
62156: ARRAY
62157: NOT
62158: OR
62159: PUSH
62160: LD_EXP 59
62164: PUSH
62165: LD_VAR 0 1
62169: ARRAY
62170: PPUSH
62171: LD_INT 2
62173: PUSH
62174: LD_INT 30
62176: PUSH
62177: LD_INT 0
62179: PUSH
62180: EMPTY
62181: LIST
62182: LIST
62183: PUSH
62184: LD_INT 30
62186: PUSH
62187: LD_INT 1
62189: PUSH
62190: EMPTY
62191: LIST
62192: LIST
62193: PUSH
62194: EMPTY
62195: LIST
62196: LIST
62197: LIST
62198: PPUSH
62199: CALL_OW 72
62203: NOT
62204: OR
62205: IFFALSE 62209
// exit ;
62207: GO 65712
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62209: LD_ADDR_VAR 0 4
62213: PUSH
62214: LD_EXP 59
62218: PUSH
62219: LD_VAR 0 1
62223: ARRAY
62224: PPUSH
62225: LD_INT 2
62227: PUSH
62228: LD_INT 25
62230: PUSH
62231: LD_INT 1
62233: PUSH
62234: EMPTY
62235: LIST
62236: LIST
62237: PUSH
62238: LD_INT 25
62240: PUSH
62241: LD_INT 2
62243: PUSH
62244: EMPTY
62245: LIST
62246: LIST
62247: PUSH
62248: LD_INT 25
62250: PUSH
62251: LD_INT 3
62253: PUSH
62254: EMPTY
62255: LIST
62256: LIST
62257: PUSH
62258: LD_INT 25
62260: PUSH
62261: LD_INT 4
62263: PUSH
62264: EMPTY
62265: LIST
62266: LIST
62267: PUSH
62268: LD_INT 25
62270: PUSH
62271: LD_INT 5
62273: PUSH
62274: EMPTY
62275: LIST
62276: LIST
62277: PUSH
62278: LD_INT 25
62280: PUSH
62281: LD_INT 8
62283: PUSH
62284: EMPTY
62285: LIST
62286: LIST
62287: PUSH
62288: LD_INT 25
62290: PUSH
62291: LD_INT 9
62293: PUSH
62294: EMPTY
62295: LIST
62296: LIST
62297: PUSH
62298: EMPTY
62299: LIST
62300: LIST
62301: LIST
62302: LIST
62303: LIST
62304: LIST
62305: LIST
62306: LIST
62307: PPUSH
62308: CALL_OW 72
62312: ST_TO_ADDR
// if not tmp then
62313: LD_VAR 0 4
62317: NOT
62318: IFFALSE 62322
// exit ;
62320: GO 65712
// for i in tmp do
62322: LD_ADDR_VAR 0 3
62326: PUSH
62327: LD_VAR 0 4
62331: PUSH
62332: FOR_IN
62333: IFFALSE 62364
// if GetTag ( i ) then
62335: LD_VAR 0 3
62339: PPUSH
62340: CALL_OW 110
62344: IFFALSE 62362
// tmp := tmp diff i ;
62346: LD_ADDR_VAR 0 4
62350: PUSH
62351: LD_VAR 0 4
62355: PUSH
62356: LD_VAR 0 3
62360: DIFF
62361: ST_TO_ADDR
62362: GO 62332
62364: POP
62365: POP
// if not tmp then
62366: LD_VAR 0 4
62370: NOT
62371: IFFALSE 62375
// exit ;
62373: GO 65712
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62375: LD_ADDR_VAR 0 5
62379: PUSH
62380: LD_EXP 59
62384: PUSH
62385: LD_VAR 0 1
62389: ARRAY
62390: PPUSH
62391: LD_INT 2
62393: PUSH
62394: LD_INT 25
62396: PUSH
62397: LD_INT 1
62399: PUSH
62400: EMPTY
62401: LIST
62402: LIST
62403: PUSH
62404: LD_INT 25
62406: PUSH
62407: LD_INT 5
62409: PUSH
62410: EMPTY
62411: LIST
62412: LIST
62413: PUSH
62414: LD_INT 25
62416: PUSH
62417: LD_INT 8
62419: PUSH
62420: EMPTY
62421: LIST
62422: LIST
62423: PUSH
62424: LD_INT 25
62426: PUSH
62427: LD_INT 9
62429: PUSH
62430: EMPTY
62431: LIST
62432: LIST
62433: PUSH
62434: EMPTY
62435: LIST
62436: LIST
62437: LIST
62438: LIST
62439: LIST
62440: PPUSH
62441: CALL_OW 72
62445: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
62446: LD_ADDR_VAR 0 6
62450: PUSH
62451: LD_EXP 59
62455: PUSH
62456: LD_VAR 0 1
62460: ARRAY
62461: PPUSH
62462: LD_INT 25
62464: PUSH
62465: LD_INT 2
62467: PUSH
62468: EMPTY
62469: LIST
62470: LIST
62471: PPUSH
62472: CALL_OW 72
62476: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
62477: LD_ADDR_VAR 0 7
62481: PUSH
62482: LD_EXP 59
62486: PUSH
62487: LD_VAR 0 1
62491: ARRAY
62492: PPUSH
62493: LD_INT 25
62495: PUSH
62496: LD_INT 3
62498: PUSH
62499: EMPTY
62500: LIST
62501: LIST
62502: PPUSH
62503: CALL_OW 72
62507: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
62508: LD_ADDR_VAR 0 8
62512: PUSH
62513: LD_EXP 59
62517: PUSH
62518: LD_VAR 0 1
62522: ARRAY
62523: PPUSH
62524: LD_INT 25
62526: PUSH
62527: LD_INT 4
62529: PUSH
62530: EMPTY
62531: LIST
62532: LIST
62533: PUSH
62534: LD_INT 24
62536: PUSH
62537: LD_INT 251
62539: PUSH
62540: EMPTY
62541: LIST
62542: LIST
62543: PUSH
62544: EMPTY
62545: LIST
62546: LIST
62547: PPUSH
62548: CALL_OW 72
62552: ST_TO_ADDR
// if mc_scan [ base ] then
62553: LD_EXP 82
62557: PUSH
62558: LD_VAR 0 1
62562: ARRAY
62563: IFFALSE 63024
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
62565: LD_ADDR_EXP 101
62569: PUSH
62570: LD_EXP 101
62574: PPUSH
62575: LD_VAR 0 1
62579: PPUSH
62580: LD_INT 4
62582: PPUSH
62583: CALL_OW 1
62587: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62588: LD_ADDR_VAR 0 12
62592: PUSH
62593: LD_EXP 59
62597: PUSH
62598: LD_VAR 0 1
62602: ARRAY
62603: PPUSH
62604: LD_INT 2
62606: PUSH
62607: LD_INT 30
62609: PUSH
62610: LD_INT 4
62612: PUSH
62613: EMPTY
62614: LIST
62615: LIST
62616: PUSH
62617: LD_INT 30
62619: PUSH
62620: LD_INT 5
62622: PUSH
62623: EMPTY
62624: LIST
62625: LIST
62626: PUSH
62627: EMPTY
62628: LIST
62629: LIST
62630: LIST
62631: PPUSH
62632: CALL_OW 72
62636: ST_TO_ADDR
// if not b then
62637: LD_VAR 0 12
62641: NOT
62642: IFFALSE 62646
// exit ;
62644: GO 65712
// p := [ ] ;
62646: LD_ADDR_VAR 0 11
62650: PUSH
62651: EMPTY
62652: ST_TO_ADDR
// if sci >= 2 then
62653: LD_VAR 0 8
62657: PUSH
62658: LD_INT 2
62660: GREATEREQUAL
62661: IFFALSE 62692
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
62663: LD_ADDR_VAR 0 8
62667: PUSH
62668: LD_VAR 0 8
62672: PUSH
62673: LD_INT 1
62675: ARRAY
62676: PUSH
62677: LD_VAR 0 8
62681: PUSH
62682: LD_INT 2
62684: ARRAY
62685: PUSH
62686: EMPTY
62687: LIST
62688: LIST
62689: ST_TO_ADDR
62690: GO 62753
// if sci = 1 then
62692: LD_VAR 0 8
62696: PUSH
62697: LD_INT 1
62699: EQUAL
62700: IFFALSE 62721
// sci := [ sci [ 1 ] ] else
62702: LD_ADDR_VAR 0 8
62706: PUSH
62707: LD_VAR 0 8
62711: PUSH
62712: LD_INT 1
62714: ARRAY
62715: PUSH
62716: EMPTY
62717: LIST
62718: ST_TO_ADDR
62719: GO 62753
// if sci = 0 then
62721: LD_VAR 0 8
62725: PUSH
62726: LD_INT 0
62728: EQUAL
62729: IFFALSE 62753
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62731: LD_ADDR_VAR 0 11
62735: PUSH
62736: LD_VAR 0 4
62740: PPUSH
62741: LD_INT 4
62743: PPUSH
62744: CALL 55795 0 2
62748: PUSH
62749: LD_INT 1
62751: ARRAY
62752: ST_TO_ADDR
// if eng > 4 then
62753: LD_VAR 0 6
62757: PUSH
62758: LD_INT 4
62760: GREATER
62761: IFFALSE 62807
// for i = eng downto 4 do
62763: LD_ADDR_VAR 0 3
62767: PUSH
62768: DOUBLE
62769: LD_VAR 0 6
62773: INC
62774: ST_TO_ADDR
62775: LD_INT 4
62777: PUSH
62778: FOR_DOWNTO
62779: IFFALSE 62805
// eng := eng diff eng [ i ] ;
62781: LD_ADDR_VAR 0 6
62785: PUSH
62786: LD_VAR 0 6
62790: PUSH
62791: LD_VAR 0 6
62795: PUSH
62796: LD_VAR 0 3
62800: ARRAY
62801: DIFF
62802: ST_TO_ADDR
62803: GO 62778
62805: POP
62806: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62807: LD_ADDR_VAR 0 4
62811: PUSH
62812: LD_VAR 0 4
62816: PUSH
62817: LD_VAR 0 5
62821: PUSH
62822: LD_VAR 0 6
62826: UNION
62827: PUSH
62828: LD_VAR 0 7
62832: UNION
62833: PUSH
62834: LD_VAR 0 8
62838: UNION
62839: DIFF
62840: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62841: LD_ADDR_VAR 0 13
62845: PUSH
62846: LD_EXP 59
62850: PUSH
62851: LD_VAR 0 1
62855: ARRAY
62856: PPUSH
62857: LD_INT 2
62859: PUSH
62860: LD_INT 30
62862: PUSH
62863: LD_INT 32
62865: PUSH
62866: EMPTY
62867: LIST
62868: LIST
62869: PUSH
62870: LD_INT 30
62872: PUSH
62873: LD_INT 31
62875: PUSH
62876: EMPTY
62877: LIST
62878: LIST
62879: PUSH
62880: EMPTY
62881: LIST
62882: LIST
62883: LIST
62884: PPUSH
62885: CALL_OW 72
62889: PUSH
62890: LD_EXP 59
62894: PUSH
62895: LD_VAR 0 1
62899: ARRAY
62900: PPUSH
62901: LD_INT 2
62903: PUSH
62904: LD_INT 30
62906: PUSH
62907: LD_INT 4
62909: PUSH
62910: EMPTY
62911: LIST
62912: LIST
62913: PUSH
62914: LD_INT 30
62916: PUSH
62917: LD_INT 5
62919: PUSH
62920: EMPTY
62921: LIST
62922: LIST
62923: PUSH
62924: EMPTY
62925: LIST
62926: LIST
62927: LIST
62928: PPUSH
62929: CALL_OW 72
62933: PUSH
62934: LD_INT 6
62936: MUL
62937: PLUS
62938: ST_TO_ADDR
// if bcount < tmp then
62939: LD_VAR 0 13
62943: PUSH
62944: LD_VAR 0 4
62948: LESS
62949: IFFALSE 62995
// for i = tmp downto bcount do
62951: LD_ADDR_VAR 0 3
62955: PUSH
62956: DOUBLE
62957: LD_VAR 0 4
62961: INC
62962: ST_TO_ADDR
62963: LD_VAR 0 13
62967: PUSH
62968: FOR_DOWNTO
62969: IFFALSE 62993
// tmp := Delete ( tmp , tmp ) ;
62971: LD_ADDR_VAR 0 4
62975: PUSH
62976: LD_VAR 0 4
62980: PPUSH
62981: LD_VAR 0 4
62985: PPUSH
62986: CALL_OW 3
62990: ST_TO_ADDR
62991: GO 62968
62993: POP
62994: POP
// result := [ tmp , 0 , 0 , p ] ;
62995: LD_ADDR_VAR 0 2
62999: PUSH
63000: LD_VAR 0 4
63004: PUSH
63005: LD_INT 0
63007: PUSH
63008: LD_INT 0
63010: PUSH
63011: LD_VAR 0 11
63015: PUSH
63016: EMPTY
63017: LIST
63018: LIST
63019: LIST
63020: LIST
63021: ST_TO_ADDR
// exit ;
63022: GO 65712
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63024: LD_EXP 59
63028: PUSH
63029: LD_VAR 0 1
63033: ARRAY
63034: PPUSH
63035: LD_INT 2
63037: PUSH
63038: LD_INT 30
63040: PUSH
63041: LD_INT 6
63043: PUSH
63044: EMPTY
63045: LIST
63046: LIST
63047: PUSH
63048: LD_INT 30
63050: PUSH
63051: LD_INT 7
63053: PUSH
63054: EMPTY
63055: LIST
63056: LIST
63057: PUSH
63058: LD_INT 30
63060: PUSH
63061: LD_INT 8
63063: PUSH
63064: EMPTY
63065: LIST
63066: LIST
63067: PUSH
63068: EMPTY
63069: LIST
63070: LIST
63071: LIST
63072: LIST
63073: PPUSH
63074: CALL_OW 72
63078: NOT
63079: PUSH
63080: LD_EXP 59
63084: PUSH
63085: LD_VAR 0 1
63089: ARRAY
63090: PPUSH
63091: LD_INT 30
63093: PUSH
63094: LD_INT 3
63096: PUSH
63097: EMPTY
63098: LIST
63099: LIST
63100: PPUSH
63101: CALL_OW 72
63105: NOT
63106: AND
63107: IFFALSE 63179
// begin if eng = tmp then
63109: LD_VAR 0 6
63113: PUSH
63114: LD_VAR 0 4
63118: EQUAL
63119: IFFALSE 63123
// exit ;
63121: GO 65712
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
63123: LD_ADDR_EXP 101
63127: PUSH
63128: LD_EXP 101
63132: PPUSH
63133: LD_VAR 0 1
63137: PPUSH
63138: LD_INT 1
63140: PPUSH
63141: CALL_OW 1
63145: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
63146: LD_ADDR_VAR 0 2
63150: PUSH
63151: LD_INT 0
63153: PUSH
63154: LD_VAR 0 4
63158: PUSH
63159: LD_VAR 0 6
63163: DIFF
63164: PUSH
63165: LD_INT 0
63167: PUSH
63168: LD_INT 0
63170: PUSH
63171: EMPTY
63172: LIST
63173: LIST
63174: LIST
63175: LIST
63176: ST_TO_ADDR
// exit ;
63177: GO 65712
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63179: LD_EXP 86
63183: PUSH
63184: LD_EXP 85
63188: PUSH
63189: LD_VAR 0 1
63193: ARRAY
63194: ARRAY
63195: PUSH
63196: LD_EXP 59
63200: PUSH
63201: LD_VAR 0 1
63205: ARRAY
63206: PPUSH
63207: LD_INT 2
63209: PUSH
63210: LD_INT 30
63212: PUSH
63213: LD_INT 6
63215: PUSH
63216: EMPTY
63217: LIST
63218: LIST
63219: PUSH
63220: LD_INT 30
63222: PUSH
63223: LD_INT 7
63225: PUSH
63226: EMPTY
63227: LIST
63228: LIST
63229: PUSH
63230: LD_INT 30
63232: PUSH
63233: LD_INT 8
63235: PUSH
63236: EMPTY
63237: LIST
63238: LIST
63239: PUSH
63240: EMPTY
63241: LIST
63242: LIST
63243: LIST
63244: LIST
63245: PPUSH
63246: CALL_OW 72
63250: AND
63251: PUSH
63252: LD_EXP 59
63256: PUSH
63257: LD_VAR 0 1
63261: ARRAY
63262: PPUSH
63263: LD_INT 30
63265: PUSH
63266: LD_INT 3
63268: PUSH
63269: EMPTY
63270: LIST
63271: LIST
63272: PPUSH
63273: CALL_OW 72
63277: NOT
63278: AND
63279: IFFALSE 63493
// begin if sci >= 6 then
63281: LD_VAR 0 8
63285: PUSH
63286: LD_INT 6
63288: GREATEREQUAL
63289: IFFALSE 63293
// exit ;
63291: GO 65712
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
63293: LD_ADDR_EXP 101
63297: PUSH
63298: LD_EXP 101
63302: PPUSH
63303: LD_VAR 0 1
63307: PPUSH
63308: LD_INT 2
63310: PPUSH
63311: CALL_OW 1
63315: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
63316: LD_ADDR_VAR 0 9
63320: PUSH
63321: LD_VAR 0 4
63325: PUSH
63326: LD_VAR 0 8
63330: DIFF
63331: PPUSH
63332: LD_INT 4
63334: PPUSH
63335: CALL 55795 0 2
63339: ST_TO_ADDR
// p := [ ] ;
63340: LD_ADDR_VAR 0 11
63344: PUSH
63345: EMPTY
63346: ST_TO_ADDR
// if sci < 6 and sort > 6 then
63347: LD_VAR 0 8
63351: PUSH
63352: LD_INT 6
63354: LESS
63355: PUSH
63356: LD_VAR 0 9
63360: PUSH
63361: LD_INT 6
63363: GREATER
63364: AND
63365: IFFALSE 63446
// begin for i = 1 to 6 - sci do
63367: LD_ADDR_VAR 0 3
63371: PUSH
63372: DOUBLE
63373: LD_INT 1
63375: DEC
63376: ST_TO_ADDR
63377: LD_INT 6
63379: PUSH
63380: LD_VAR 0 8
63384: MINUS
63385: PUSH
63386: FOR_TO
63387: IFFALSE 63442
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
63389: LD_ADDR_VAR 0 11
63393: PUSH
63394: LD_VAR 0 11
63398: PPUSH
63399: LD_VAR 0 11
63403: PUSH
63404: LD_INT 1
63406: PLUS
63407: PPUSH
63408: LD_VAR 0 9
63412: PUSH
63413: LD_INT 1
63415: ARRAY
63416: PPUSH
63417: CALL_OW 2
63421: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
63422: LD_ADDR_VAR 0 9
63426: PUSH
63427: LD_VAR 0 9
63431: PPUSH
63432: LD_INT 1
63434: PPUSH
63435: CALL_OW 3
63439: ST_TO_ADDR
// end ;
63440: GO 63386
63442: POP
63443: POP
// end else
63444: GO 63466
// if sort then
63446: LD_VAR 0 9
63450: IFFALSE 63466
// p := sort [ 1 ] ;
63452: LD_ADDR_VAR 0 11
63456: PUSH
63457: LD_VAR 0 9
63461: PUSH
63462: LD_INT 1
63464: ARRAY
63465: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
63466: LD_ADDR_VAR 0 2
63470: PUSH
63471: LD_INT 0
63473: PUSH
63474: LD_INT 0
63476: PUSH
63477: LD_INT 0
63479: PUSH
63480: LD_VAR 0 11
63484: PUSH
63485: EMPTY
63486: LIST
63487: LIST
63488: LIST
63489: LIST
63490: ST_TO_ADDR
// exit ;
63491: GO 65712
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63493: LD_EXP 86
63497: PUSH
63498: LD_EXP 85
63502: PUSH
63503: LD_VAR 0 1
63507: ARRAY
63508: ARRAY
63509: PUSH
63510: LD_EXP 59
63514: PUSH
63515: LD_VAR 0 1
63519: ARRAY
63520: PPUSH
63521: LD_INT 2
63523: PUSH
63524: LD_INT 30
63526: PUSH
63527: LD_INT 6
63529: PUSH
63530: EMPTY
63531: LIST
63532: LIST
63533: PUSH
63534: LD_INT 30
63536: PUSH
63537: LD_INT 7
63539: PUSH
63540: EMPTY
63541: LIST
63542: LIST
63543: PUSH
63544: LD_INT 30
63546: PUSH
63547: LD_INT 8
63549: PUSH
63550: EMPTY
63551: LIST
63552: LIST
63553: PUSH
63554: EMPTY
63555: LIST
63556: LIST
63557: LIST
63558: LIST
63559: PPUSH
63560: CALL_OW 72
63564: AND
63565: PUSH
63566: LD_EXP 59
63570: PUSH
63571: LD_VAR 0 1
63575: ARRAY
63576: PPUSH
63577: LD_INT 30
63579: PUSH
63580: LD_INT 3
63582: PUSH
63583: EMPTY
63584: LIST
63585: LIST
63586: PPUSH
63587: CALL_OW 72
63591: AND
63592: IFFALSE 64326
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
63594: LD_ADDR_EXP 101
63598: PUSH
63599: LD_EXP 101
63603: PPUSH
63604: LD_VAR 0 1
63608: PPUSH
63609: LD_INT 3
63611: PPUSH
63612: CALL_OW 1
63616: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63617: LD_ADDR_VAR 0 2
63621: PUSH
63622: LD_INT 0
63624: PUSH
63625: LD_INT 0
63627: PUSH
63628: LD_INT 0
63630: PUSH
63631: LD_INT 0
63633: PUSH
63634: EMPTY
63635: LIST
63636: LIST
63637: LIST
63638: LIST
63639: ST_TO_ADDR
// if not eng then
63640: LD_VAR 0 6
63644: NOT
63645: IFFALSE 63708
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
63647: LD_ADDR_VAR 0 11
63651: PUSH
63652: LD_VAR 0 4
63656: PPUSH
63657: LD_INT 2
63659: PPUSH
63660: CALL 55795 0 2
63664: PUSH
63665: LD_INT 1
63667: ARRAY
63668: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
63669: LD_ADDR_VAR 0 2
63673: PUSH
63674: LD_VAR 0 2
63678: PPUSH
63679: LD_INT 2
63681: PPUSH
63682: LD_VAR 0 11
63686: PPUSH
63687: CALL_OW 1
63691: ST_TO_ADDR
// tmp := tmp diff p ;
63692: LD_ADDR_VAR 0 4
63696: PUSH
63697: LD_VAR 0 4
63701: PUSH
63702: LD_VAR 0 11
63706: DIFF
63707: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63708: LD_VAR 0 4
63712: PUSH
63713: LD_VAR 0 8
63717: PUSH
63718: LD_INT 6
63720: LESS
63721: AND
63722: IFFALSE 63910
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63724: LD_ADDR_VAR 0 9
63728: PUSH
63729: LD_VAR 0 4
63733: PUSH
63734: LD_VAR 0 8
63738: PUSH
63739: LD_VAR 0 7
63743: UNION
63744: DIFF
63745: PPUSH
63746: LD_INT 4
63748: PPUSH
63749: CALL 55795 0 2
63753: ST_TO_ADDR
// p := [ ] ;
63754: LD_ADDR_VAR 0 11
63758: PUSH
63759: EMPTY
63760: ST_TO_ADDR
// if sort then
63761: LD_VAR 0 9
63765: IFFALSE 63881
// for i = 1 to 6 - sci do
63767: LD_ADDR_VAR 0 3
63771: PUSH
63772: DOUBLE
63773: LD_INT 1
63775: DEC
63776: ST_TO_ADDR
63777: LD_INT 6
63779: PUSH
63780: LD_VAR 0 8
63784: MINUS
63785: PUSH
63786: FOR_TO
63787: IFFALSE 63879
// begin if i = sort then
63789: LD_VAR 0 3
63793: PUSH
63794: LD_VAR 0 9
63798: EQUAL
63799: IFFALSE 63803
// break ;
63801: GO 63879
// if GetClass ( i ) = 4 then
63803: LD_VAR 0 3
63807: PPUSH
63808: CALL_OW 257
63812: PUSH
63813: LD_INT 4
63815: EQUAL
63816: IFFALSE 63820
// continue ;
63818: GO 63786
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63820: LD_ADDR_VAR 0 11
63824: PUSH
63825: LD_VAR 0 11
63829: PPUSH
63830: LD_VAR 0 11
63834: PUSH
63835: LD_INT 1
63837: PLUS
63838: PPUSH
63839: LD_VAR 0 9
63843: PUSH
63844: LD_VAR 0 3
63848: ARRAY
63849: PPUSH
63850: CALL_OW 2
63854: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63855: LD_ADDR_VAR 0 4
63859: PUSH
63860: LD_VAR 0 4
63864: PUSH
63865: LD_VAR 0 9
63869: PUSH
63870: LD_VAR 0 3
63874: ARRAY
63875: DIFF
63876: ST_TO_ADDR
// end ;
63877: GO 63786
63879: POP
63880: POP
// if p then
63881: LD_VAR 0 11
63885: IFFALSE 63910
// result := Replace ( result , 4 , p ) ;
63887: LD_ADDR_VAR 0 2
63891: PUSH
63892: LD_VAR 0 2
63896: PPUSH
63897: LD_INT 4
63899: PPUSH
63900: LD_VAR 0 11
63904: PPUSH
63905: CALL_OW 1
63909: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63910: LD_VAR 0 4
63914: PUSH
63915: LD_VAR 0 7
63919: PUSH
63920: LD_INT 6
63922: LESS
63923: AND
63924: IFFALSE 64112
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63926: LD_ADDR_VAR 0 9
63930: PUSH
63931: LD_VAR 0 4
63935: PUSH
63936: LD_VAR 0 8
63940: PUSH
63941: LD_VAR 0 7
63945: UNION
63946: DIFF
63947: PPUSH
63948: LD_INT 3
63950: PPUSH
63951: CALL 55795 0 2
63955: ST_TO_ADDR
// p := [ ] ;
63956: LD_ADDR_VAR 0 11
63960: PUSH
63961: EMPTY
63962: ST_TO_ADDR
// if sort then
63963: LD_VAR 0 9
63967: IFFALSE 64083
// for i = 1 to 6 - mech do
63969: LD_ADDR_VAR 0 3
63973: PUSH
63974: DOUBLE
63975: LD_INT 1
63977: DEC
63978: ST_TO_ADDR
63979: LD_INT 6
63981: PUSH
63982: LD_VAR 0 7
63986: MINUS
63987: PUSH
63988: FOR_TO
63989: IFFALSE 64081
// begin if i = sort then
63991: LD_VAR 0 3
63995: PUSH
63996: LD_VAR 0 9
64000: EQUAL
64001: IFFALSE 64005
// break ;
64003: GO 64081
// if GetClass ( i ) = 3 then
64005: LD_VAR 0 3
64009: PPUSH
64010: CALL_OW 257
64014: PUSH
64015: LD_INT 3
64017: EQUAL
64018: IFFALSE 64022
// continue ;
64020: GO 63988
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64022: LD_ADDR_VAR 0 11
64026: PUSH
64027: LD_VAR 0 11
64031: PPUSH
64032: LD_VAR 0 11
64036: PUSH
64037: LD_INT 1
64039: PLUS
64040: PPUSH
64041: LD_VAR 0 9
64045: PUSH
64046: LD_VAR 0 3
64050: ARRAY
64051: PPUSH
64052: CALL_OW 2
64056: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64057: LD_ADDR_VAR 0 4
64061: PUSH
64062: LD_VAR 0 4
64066: PUSH
64067: LD_VAR 0 9
64071: PUSH
64072: LD_VAR 0 3
64076: ARRAY
64077: DIFF
64078: ST_TO_ADDR
// end ;
64079: GO 63988
64081: POP
64082: POP
// if p then
64083: LD_VAR 0 11
64087: IFFALSE 64112
// result := Replace ( result , 3 , p ) ;
64089: LD_ADDR_VAR 0 2
64093: PUSH
64094: LD_VAR 0 2
64098: PPUSH
64099: LD_INT 3
64101: PPUSH
64102: LD_VAR 0 11
64106: PPUSH
64107: CALL_OW 1
64111: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
64112: LD_VAR 0 4
64116: PUSH
64117: LD_INT 6
64119: GREATER
64120: PUSH
64121: LD_VAR 0 6
64125: PUSH
64126: LD_INT 6
64128: LESS
64129: AND
64130: IFFALSE 64324
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64132: LD_ADDR_VAR 0 9
64136: PUSH
64137: LD_VAR 0 4
64141: PUSH
64142: LD_VAR 0 8
64146: PUSH
64147: LD_VAR 0 7
64151: UNION
64152: PUSH
64153: LD_VAR 0 6
64157: UNION
64158: DIFF
64159: PPUSH
64160: LD_INT 2
64162: PPUSH
64163: CALL 55795 0 2
64167: ST_TO_ADDR
// p := [ ] ;
64168: LD_ADDR_VAR 0 11
64172: PUSH
64173: EMPTY
64174: ST_TO_ADDR
// if sort then
64175: LD_VAR 0 9
64179: IFFALSE 64295
// for i = 1 to 6 - eng do
64181: LD_ADDR_VAR 0 3
64185: PUSH
64186: DOUBLE
64187: LD_INT 1
64189: DEC
64190: ST_TO_ADDR
64191: LD_INT 6
64193: PUSH
64194: LD_VAR 0 6
64198: MINUS
64199: PUSH
64200: FOR_TO
64201: IFFALSE 64293
// begin if i = sort then
64203: LD_VAR 0 3
64207: PUSH
64208: LD_VAR 0 9
64212: EQUAL
64213: IFFALSE 64217
// break ;
64215: GO 64293
// if GetClass ( i ) = 2 then
64217: LD_VAR 0 3
64221: PPUSH
64222: CALL_OW 257
64226: PUSH
64227: LD_INT 2
64229: EQUAL
64230: IFFALSE 64234
// continue ;
64232: GO 64200
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64234: LD_ADDR_VAR 0 11
64238: PUSH
64239: LD_VAR 0 11
64243: PPUSH
64244: LD_VAR 0 11
64248: PUSH
64249: LD_INT 1
64251: PLUS
64252: PPUSH
64253: LD_VAR 0 9
64257: PUSH
64258: LD_VAR 0 3
64262: ARRAY
64263: PPUSH
64264: CALL_OW 2
64268: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64269: LD_ADDR_VAR 0 4
64273: PUSH
64274: LD_VAR 0 4
64278: PUSH
64279: LD_VAR 0 9
64283: PUSH
64284: LD_VAR 0 3
64288: ARRAY
64289: DIFF
64290: ST_TO_ADDR
// end ;
64291: GO 64200
64293: POP
64294: POP
// if p then
64295: LD_VAR 0 11
64299: IFFALSE 64324
// result := Replace ( result , 2 , p ) ;
64301: LD_ADDR_VAR 0 2
64305: PUSH
64306: LD_VAR 0 2
64310: PPUSH
64311: LD_INT 2
64313: PPUSH
64314: LD_VAR 0 11
64318: PPUSH
64319: CALL_OW 1
64323: ST_TO_ADDR
// end ; exit ;
64324: GO 65712
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
64326: LD_EXP 86
64330: PUSH
64331: LD_EXP 85
64335: PUSH
64336: LD_VAR 0 1
64340: ARRAY
64341: ARRAY
64342: NOT
64343: PUSH
64344: LD_EXP 59
64348: PUSH
64349: LD_VAR 0 1
64353: ARRAY
64354: PPUSH
64355: LD_INT 30
64357: PUSH
64358: LD_INT 3
64360: PUSH
64361: EMPTY
64362: LIST
64363: LIST
64364: PPUSH
64365: CALL_OW 72
64369: AND
64370: PUSH
64371: LD_EXP 64
64375: PUSH
64376: LD_VAR 0 1
64380: ARRAY
64381: AND
64382: IFFALSE 64990
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
64384: LD_ADDR_EXP 101
64388: PUSH
64389: LD_EXP 101
64393: PPUSH
64394: LD_VAR 0 1
64398: PPUSH
64399: LD_INT 5
64401: PPUSH
64402: CALL_OW 1
64406: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64407: LD_ADDR_VAR 0 2
64411: PUSH
64412: LD_INT 0
64414: PUSH
64415: LD_INT 0
64417: PUSH
64418: LD_INT 0
64420: PUSH
64421: LD_INT 0
64423: PUSH
64424: EMPTY
64425: LIST
64426: LIST
64427: LIST
64428: LIST
64429: ST_TO_ADDR
// if sci > 1 then
64430: LD_VAR 0 8
64434: PUSH
64435: LD_INT 1
64437: GREATER
64438: IFFALSE 64466
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
64440: LD_ADDR_VAR 0 4
64444: PUSH
64445: LD_VAR 0 4
64449: PUSH
64450: LD_VAR 0 8
64454: PUSH
64455: LD_VAR 0 8
64459: PUSH
64460: LD_INT 1
64462: ARRAY
64463: DIFF
64464: DIFF
64465: ST_TO_ADDR
// if tmp and not sci then
64466: LD_VAR 0 4
64470: PUSH
64471: LD_VAR 0 8
64475: NOT
64476: AND
64477: IFFALSE 64546
// begin sort := SortBySkill ( tmp , 4 ) ;
64479: LD_ADDR_VAR 0 9
64483: PUSH
64484: LD_VAR 0 4
64488: PPUSH
64489: LD_INT 4
64491: PPUSH
64492: CALL 55795 0 2
64496: ST_TO_ADDR
// if sort then
64497: LD_VAR 0 9
64501: IFFALSE 64517
// p := sort [ 1 ] ;
64503: LD_ADDR_VAR 0 11
64507: PUSH
64508: LD_VAR 0 9
64512: PUSH
64513: LD_INT 1
64515: ARRAY
64516: ST_TO_ADDR
// if p then
64517: LD_VAR 0 11
64521: IFFALSE 64546
// result := Replace ( result , 4 , p ) ;
64523: LD_ADDR_VAR 0 2
64527: PUSH
64528: LD_VAR 0 2
64532: PPUSH
64533: LD_INT 4
64535: PPUSH
64536: LD_VAR 0 11
64540: PPUSH
64541: CALL_OW 1
64545: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64546: LD_ADDR_VAR 0 4
64550: PUSH
64551: LD_VAR 0 4
64555: PUSH
64556: LD_VAR 0 7
64560: DIFF
64561: ST_TO_ADDR
// if tmp and mech < 6 then
64562: LD_VAR 0 4
64566: PUSH
64567: LD_VAR 0 7
64571: PUSH
64572: LD_INT 6
64574: LESS
64575: AND
64576: IFFALSE 64764
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64578: LD_ADDR_VAR 0 9
64582: PUSH
64583: LD_VAR 0 4
64587: PUSH
64588: LD_VAR 0 8
64592: PUSH
64593: LD_VAR 0 7
64597: UNION
64598: DIFF
64599: PPUSH
64600: LD_INT 3
64602: PPUSH
64603: CALL 55795 0 2
64607: ST_TO_ADDR
// p := [ ] ;
64608: LD_ADDR_VAR 0 11
64612: PUSH
64613: EMPTY
64614: ST_TO_ADDR
// if sort then
64615: LD_VAR 0 9
64619: IFFALSE 64735
// for i = 1 to 6 - mech do
64621: LD_ADDR_VAR 0 3
64625: PUSH
64626: DOUBLE
64627: LD_INT 1
64629: DEC
64630: ST_TO_ADDR
64631: LD_INT 6
64633: PUSH
64634: LD_VAR 0 7
64638: MINUS
64639: PUSH
64640: FOR_TO
64641: IFFALSE 64733
// begin if i = sort then
64643: LD_VAR 0 3
64647: PUSH
64648: LD_VAR 0 9
64652: EQUAL
64653: IFFALSE 64657
// break ;
64655: GO 64733
// if GetClass ( i ) = 3 then
64657: LD_VAR 0 3
64661: PPUSH
64662: CALL_OW 257
64666: PUSH
64667: LD_INT 3
64669: EQUAL
64670: IFFALSE 64674
// continue ;
64672: GO 64640
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64674: LD_ADDR_VAR 0 11
64678: PUSH
64679: LD_VAR 0 11
64683: PPUSH
64684: LD_VAR 0 11
64688: PUSH
64689: LD_INT 1
64691: PLUS
64692: PPUSH
64693: LD_VAR 0 9
64697: PUSH
64698: LD_VAR 0 3
64702: ARRAY
64703: PPUSH
64704: CALL_OW 2
64708: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64709: LD_ADDR_VAR 0 4
64713: PUSH
64714: LD_VAR 0 4
64718: PUSH
64719: LD_VAR 0 9
64723: PUSH
64724: LD_VAR 0 3
64728: ARRAY
64729: DIFF
64730: ST_TO_ADDR
// end ;
64731: GO 64640
64733: POP
64734: POP
// if p then
64735: LD_VAR 0 11
64739: IFFALSE 64764
// result := Replace ( result , 3 , p ) ;
64741: LD_ADDR_VAR 0 2
64745: PUSH
64746: LD_VAR 0 2
64750: PPUSH
64751: LD_INT 3
64753: PPUSH
64754: LD_VAR 0 11
64758: PPUSH
64759: CALL_OW 1
64763: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64764: LD_ADDR_VAR 0 4
64768: PUSH
64769: LD_VAR 0 4
64773: PUSH
64774: LD_VAR 0 6
64778: DIFF
64779: ST_TO_ADDR
// if tmp and eng < 6 then
64780: LD_VAR 0 4
64784: PUSH
64785: LD_VAR 0 6
64789: PUSH
64790: LD_INT 6
64792: LESS
64793: AND
64794: IFFALSE 64988
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64796: LD_ADDR_VAR 0 9
64800: PUSH
64801: LD_VAR 0 4
64805: PUSH
64806: LD_VAR 0 8
64810: PUSH
64811: LD_VAR 0 7
64815: UNION
64816: PUSH
64817: LD_VAR 0 6
64821: UNION
64822: DIFF
64823: PPUSH
64824: LD_INT 2
64826: PPUSH
64827: CALL 55795 0 2
64831: ST_TO_ADDR
// p := [ ] ;
64832: LD_ADDR_VAR 0 11
64836: PUSH
64837: EMPTY
64838: ST_TO_ADDR
// if sort then
64839: LD_VAR 0 9
64843: IFFALSE 64959
// for i = 1 to 6 - eng do
64845: LD_ADDR_VAR 0 3
64849: PUSH
64850: DOUBLE
64851: LD_INT 1
64853: DEC
64854: ST_TO_ADDR
64855: LD_INT 6
64857: PUSH
64858: LD_VAR 0 6
64862: MINUS
64863: PUSH
64864: FOR_TO
64865: IFFALSE 64957
// begin if i = sort then
64867: LD_VAR 0 3
64871: PUSH
64872: LD_VAR 0 9
64876: EQUAL
64877: IFFALSE 64881
// break ;
64879: GO 64957
// if GetClass ( i ) = 2 then
64881: LD_VAR 0 3
64885: PPUSH
64886: CALL_OW 257
64890: PUSH
64891: LD_INT 2
64893: EQUAL
64894: IFFALSE 64898
// continue ;
64896: GO 64864
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64898: LD_ADDR_VAR 0 11
64902: PUSH
64903: LD_VAR 0 11
64907: PPUSH
64908: LD_VAR 0 11
64912: PUSH
64913: LD_INT 1
64915: PLUS
64916: PPUSH
64917: LD_VAR 0 9
64921: PUSH
64922: LD_VAR 0 3
64926: ARRAY
64927: PPUSH
64928: CALL_OW 2
64932: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64933: LD_ADDR_VAR 0 4
64937: PUSH
64938: LD_VAR 0 4
64942: PUSH
64943: LD_VAR 0 9
64947: PUSH
64948: LD_VAR 0 3
64952: ARRAY
64953: DIFF
64954: ST_TO_ADDR
// end ;
64955: GO 64864
64957: POP
64958: POP
// if p then
64959: LD_VAR 0 11
64963: IFFALSE 64988
// result := Replace ( result , 2 , p ) ;
64965: LD_ADDR_VAR 0 2
64969: PUSH
64970: LD_VAR 0 2
64974: PPUSH
64975: LD_INT 2
64977: PPUSH
64978: LD_VAR 0 11
64982: PPUSH
64983: CALL_OW 1
64987: ST_TO_ADDR
// end ; exit ;
64988: GO 65712
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
64990: LD_EXP 86
64994: PUSH
64995: LD_EXP 85
64999: PUSH
65000: LD_VAR 0 1
65004: ARRAY
65005: ARRAY
65006: NOT
65007: PUSH
65008: LD_EXP 59
65012: PUSH
65013: LD_VAR 0 1
65017: ARRAY
65018: PPUSH
65019: LD_INT 30
65021: PUSH
65022: LD_INT 3
65024: PUSH
65025: EMPTY
65026: LIST
65027: LIST
65028: PPUSH
65029: CALL_OW 72
65033: AND
65034: PUSH
65035: LD_EXP 64
65039: PUSH
65040: LD_VAR 0 1
65044: ARRAY
65045: NOT
65046: AND
65047: IFFALSE 65712
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
65049: LD_ADDR_EXP 101
65053: PUSH
65054: LD_EXP 101
65058: PPUSH
65059: LD_VAR 0 1
65063: PPUSH
65064: LD_INT 6
65066: PPUSH
65067: CALL_OW 1
65071: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
65072: LD_ADDR_VAR 0 2
65076: PUSH
65077: LD_INT 0
65079: PUSH
65080: LD_INT 0
65082: PUSH
65083: LD_INT 0
65085: PUSH
65086: LD_INT 0
65088: PUSH
65089: EMPTY
65090: LIST
65091: LIST
65092: LIST
65093: LIST
65094: ST_TO_ADDR
// if sci >= 1 then
65095: LD_VAR 0 8
65099: PUSH
65100: LD_INT 1
65102: GREATEREQUAL
65103: IFFALSE 65125
// tmp := tmp diff sci [ 1 ] ;
65105: LD_ADDR_VAR 0 4
65109: PUSH
65110: LD_VAR 0 4
65114: PUSH
65115: LD_VAR 0 8
65119: PUSH
65120: LD_INT 1
65122: ARRAY
65123: DIFF
65124: ST_TO_ADDR
// if tmp and not sci then
65125: LD_VAR 0 4
65129: PUSH
65130: LD_VAR 0 8
65134: NOT
65135: AND
65136: IFFALSE 65205
// begin sort := SortBySkill ( tmp , 4 ) ;
65138: LD_ADDR_VAR 0 9
65142: PUSH
65143: LD_VAR 0 4
65147: PPUSH
65148: LD_INT 4
65150: PPUSH
65151: CALL 55795 0 2
65155: ST_TO_ADDR
// if sort then
65156: LD_VAR 0 9
65160: IFFALSE 65176
// p := sort [ 1 ] ;
65162: LD_ADDR_VAR 0 11
65166: PUSH
65167: LD_VAR 0 9
65171: PUSH
65172: LD_INT 1
65174: ARRAY
65175: ST_TO_ADDR
// if p then
65176: LD_VAR 0 11
65180: IFFALSE 65205
// result := Replace ( result , 4 , p ) ;
65182: LD_ADDR_VAR 0 2
65186: PUSH
65187: LD_VAR 0 2
65191: PPUSH
65192: LD_INT 4
65194: PPUSH
65195: LD_VAR 0 11
65199: PPUSH
65200: CALL_OW 1
65204: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
65205: LD_ADDR_VAR 0 4
65209: PUSH
65210: LD_VAR 0 4
65214: PUSH
65215: LD_VAR 0 7
65219: DIFF
65220: ST_TO_ADDR
// if tmp and mech < 6 then
65221: LD_VAR 0 4
65225: PUSH
65226: LD_VAR 0 7
65230: PUSH
65231: LD_INT 6
65233: LESS
65234: AND
65235: IFFALSE 65417
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
65237: LD_ADDR_VAR 0 9
65241: PUSH
65242: LD_VAR 0 4
65246: PUSH
65247: LD_VAR 0 7
65251: DIFF
65252: PPUSH
65253: LD_INT 3
65255: PPUSH
65256: CALL 55795 0 2
65260: ST_TO_ADDR
// p := [ ] ;
65261: LD_ADDR_VAR 0 11
65265: PUSH
65266: EMPTY
65267: ST_TO_ADDR
// if sort then
65268: LD_VAR 0 9
65272: IFFALSE 65388
// for i = 1 to 6 - mech do
65274: LD_ADDR_VAR 0 3
65278: PUSH
65279: DOUBLE
65280: LD_INT 1
65282: DEC
65283: ST_TO_ADDR
65284: LD_INT 6
65286: PUSH
65287: LD_VAR 0 7
65291: MINUS
65292: PUSH
65293: FOR_TO
65294: IFFALSE 65386
// begin if i = sort then
65296: LD_VAR 0 3
65300: PUSH
65301: LD_VAR 0 9
65305: EQUAL
65306: IFFALSE 65310
// break ;
65308: GO 65386
// if GetClass ( i ) = 3 then
65310: LD_VAR 0 3
65314: PPUSH
65315: CALL_OW 257
65319: PUSH
65320: LD_INT 3
65322: EQUAL
65323: IFFALSE 65327
// continue ;
65325: GO 65293
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65327: LD_ADDR_VAR 0 11
65331: PUSH
65332: LD_VAR 0 11
65336: PPUSH
65337: LD_VAR 0 11
65341: PUSH
65342: LD_INT 1
65344: PLUS
65345: PPUSH
65346: LD_VAR 0 9
65350: PUSH
65351: LD_VAR 0 3
65355: ARRAY
65356: PPUSH
65357: CALL_OW 2
65361: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65362: LD_ADDR_VAR 0 4
65366: PUSH
65367: LD_VAR 0 4
65371: PUSH
65372: LD_VAR 0 9
65376: PUSH
65377: LD_VAR 0 3
65381: ARRAY
65382: DIFF
65383: ST_TO_ADDR
// end ;
65384: GO 65293
65386: POP
65387: POP
// if p then
65388: LD_VAR 0 11
65392: IFFALSE 65417
// result := Replace ( result , 3 , p ) ;
65394: LD_ADDR_VAR 0 2
65398: PUSH
65399: LD_VAR 0 2
65403: PPUSH
65404: LD_INT 3
65406: PPUSH
65407: LD_VAR 0 11
65411: PPUSH
65412: CALL_OW 1
65416: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
65417: LD_ADDR_VAR 0 4
65421: PUSH
65422: LD_VAR 0 4
65426: PUSH
65427: LD_VAR 0 6
65431: DIFF
65432: ST_TO_ADDR
// if tmp and eng < 4 then
65433: LD_VAR 0 4
65437: PUSH
65438: LD_VAR 0 6
65442: PUSH
65443: LD_INT 4
65445: LESS
65446: AND
65447: IFFALSE 65637
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
65449: LD_ADDR_VAR 0 9
65453: PUSH
65454: LD_VAR 0 4
65458: PUSH
65459: LD_VAR 0 7
65463: PUSH
65464: LD_VAR 0 6
65468: UNION
65469: DIFF
65470: PPUSH
65471: LD_INT 2
65473: PPUSH
65474: CALL 55795 0 2
65478: ST_TO_ADDR
// p := [ ] ;
65479: LD_ADDR_VAR 0 11
65483: PUSH
65484: EMPTY
65485: ST_TO_ADDR
// if sort then
65486: LD_VAR 0 9
65490: IFFALSE 65606
// for i = 1 to 4 - eng do
65492: LD_ADDR_VAR 0 3
65496: PUSH
65497: DOUBLE
65498: LD_INT 1
65500: DEC
65501: ST_TO_ADDR
65502: LD_INT 4
65504: PUSH
65505: LD_VAR 0 6
65509: MINUS
65510: PUSH
65511: FOR_TO
65512: IFFALSE 65604
// begin if i = sort then
65514: LD_VAR 0 3
65518: PUSH
65519: LD_VAR 0 9
65523: EQUAL
65524: IFFALSE 65528
// break ;
65526: GO 65604
// if GetClass ( i ) = 2 then
65528: LD_VAR 0 3
65532: PPUSH
65533: CALL_OW 257
65537: PUSH
65538: LD_INT 2
65540: EQUAL
65541: IFFALSE 65545
// continue ;
65543: GO 65511
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65545: LD_ADDR_VAR 0 11
65549: PUSH
65550: LD_VAR 0 11
65554: PPUSH
65555: LD_VAR 0 11
65559: PUSH
65560: LD_INT 1
65562: PLUS
65563: PPUSH
65564: LD_VAR 0 9
65568: PUSH
65569: LD_VAR 0 3
65573: ARRAY
65574: PPUSH
65575: CALL_OW 2
65579: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65580: LD_ADDR_VAR 0 4
65584: PUSH
65585: LD_VAR 0 4
65589: PUSH
65590: LD_VAR 0 9
65594: PUSH
65595: LD_VAR 0 3
65599: ARRAY
65600: DIFF
65601: ST_TO_ADDR
// end ;
65602: GO 65511
65604: POP
65605: POP
// if p then
65606: LD_VAR 0 11
65610: IFFALSE 65635
// result := Replace ( result , 2 , p ) ;
65612: LD_ADDR_VAR 0 2
65616: PUSH
65617: LD_VAR 0 2
65621: PPUSH
65622: LD_INT 2
65624: PPUSH
65625: LD_VAR 0 11
65629: PPUSH
65630: CALL_OW 1
65634: ST_TO_ADDR
// end else
65635: GO 65681
// for i = eng downto 5 do
65637: LD_ADDR_VAR 0 3
65641: PUSH
65642: DOUBLE
65643: LD_VAR 0 6
65647: INC
65648: ST_TO_ADDR
65649: LD_INT 5
65651: PUSH
65652: FOR_DOWNTO
65653: IFFALSE 65679
// tmp := tmp union eng [ i ] ;
65655: LD_ADDR_VAR 0 4
65659: PUSH
65660: LD_VAR 0 4
65664: PUSH
65665: LD_VAR 0 6
65669: PUSH
65670: LD_VAR 0 3
65674: ARRAY
65675: UNION
65676: ST_TO_ADDR
65677: GO 65652
65679: POP
65680: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
65681: LD_ADDR_VAR 0 2
65685: PUSH
65686: LD_VAR 0 2
65690: PPUSH
65691: LD_INT 1
65693: PPUSH
65694: LD_VAR 0 4
65698: PUSH
65699: LD_VAR 0 5
65703: DIFF
65704: PPUSH
65705: CALL_OW 1
65709: ST_TO_ADDR
// exit ;
65710: GO 65712
// end ; end ;
65712: LD_VAR 0 2
65716: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65717: LD_INT 0
65719: PPUSH
65720: PPUSH
65721: PPUSH
// if not mc_bases then
65722: LD_EXP 59
65726: NOT
65727: IFFALSE 65731
// exit ;
65729: GO 65837
// for i = 1 to mc_bases do
65731: LD_ADDR_VAR 0 2
65735: PUSH
65736: DOUBLE
65737: LD_INT 1
65739: DEC
65740: ST_TO_ADDR
65741: LD_EXP 59
65745: PUSH
65746: FOR_TO
65747: IFFALSE 65828
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65749: LD_ADDR_VAR 0 3
65753: PUSH
65754: LD_EXP 59
65758: PUSH
65759: LD_VAR 0 2
65763: ARRAY
65764: PPUSH
65765: LD_INT 21
65767: PUSH
65768: LD_INT 3
65770: PUSH
65771: EMPTY
65772: LIST
65773: LIST
65774: PUSH
65775: LD_INT 3
65777: PUSH
65778: LD_INT 24
65780: PUSH
65781: LD_INT 1000
65783: PUSH
65784: EMPTY
65785: LIST
65786: LIST
65787: PUSH
65788: EMPTY
65789: LIST
65790: LIST
65791: PUSH
65792: EMPTY
65793: LIST
65794: LIST
65795: PPUSH
65796: CALL_OW 72
65800: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65801: LD_ADDR_EXP 60
65805: PUSH
65806: LD_EXP 60
65810: PPUSH
65811: LD_VAR 0 2
65815: PPUSH
65816: LD_VAR 0 3
65820: PPUSH
65821: CALL_OW 1
65825: ST_TO_ADDR
// end ;
65826: GO 65746
65828: POP
65829: POP
// RaiseSailEvent ( 101 ) ;
65830: LD_INT 101
65832: PPUSH
65833: CALL_OW 427
// end ;
65837: LD_VAR 0 1
65841: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65842: LD_INT 0
65844: PPUSH
65845: PPUSH
65846: PPUSH
65847: PPUSH
65848: PPUSH
65849: PPUSH
65850: PPUSH
// if not mc_bases then
65851: LD_EXP 59
65855: NOT
65856: IFFALSE 65860
// exit ;
65858: GO 66433
// for i = 1 to mc_bases do
65860: LD_ADDR_VAR 0 2
65864: PUSH
65865: DOUBLE
65866: LD_INT 1
65868: DEC
65869: ST_TO_ADDR
65870: LD_EXP 59
65874: PUSH
65875: FOR_TO
65876: IFFALSE 66424
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
65878: LD_ADDR_VAR 0 5
65882: PUSH
65883: LD_EXP 59
65887: PUSH
65888: LD_VAR 0 2
65892: ARRAY
65893: PUSH
65894: LD_EXP 88
65898: PUSH
65899: LD_VAR 0 2
65903: ARRAY
65904: UNION
65905: PPUSH
65906: LD_INT 21
65908: PUSH
65909: LD_INT 1
65911: PUSH
65912: EMPTY
65913: LIST
65914: LIST
65915: PUSH
65916: LD_INT 1
65918: PUSH
65919: LD_INT 3
65921: PUSH
65922: LD_INT 54
65924: PUSH
65925: EMPTY
65926: LIST
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: LD_INT 3
65934: PUSH
65935: LD_INT 24
65937: PUSH
65938: LD_INT 800
65940: PUSH
65941: EMPTY
65942: LIST
65943: LIST
65944: PUSH
65945: EMPTY
65946: LIST
65947: LIST
65948: PUSH
65949: EMPTY
65950: LIST
65951: LIST
65952: LIST
65953: PUSH
65954: EMPTY
65955: LIST
65956: LIST
65957: PPUSH
65958: CALL_OW 72
65962: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
65963: LD_ADDR_VAR 0 6
65967: PUSH
65968: LD_EXP 59
65972: PUSH
65973: LD_VAR 0 2
65977: ARRAY
65978: PPUSH
65979: LD_INT 21
65981: PUSH
65982: LD_INT 1
65984: PUSH
65985: EMPTY
65986: LIST
65987: LIST
65988: PUSH
65989: LD_INT 1
65991: PUSH
65992: LD_INT 3
65994: PUSH
65995: LD_INT 54
65997: PUSH
65998: EMPTY
65999: LIST
66000: PUSH
66001: EMPTY
66002: LIST
66003: LIST
66004: PUSH
66005: LD_INT 3
66007: PUSH
66008: LD_INT 24
66010: PUSH
66011: LD_INT 250
66013: PUSH
66014: EMPTY
66015: LIST
66016: LIST
66017: PUSH
66018: EMPTY
66019: LIST
66020: LIST
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: LIST
66026: PUSH
66027: EMPTY
66028: LIST
66029: LIST
66030: PPUSH
66031: CALL_OW 72
66035: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
66036: LD_ADDR_VAR 0 7
66040: PUSH
66041: LD_VAR 0 5
66045: PUSH
66046: LD_VAR 0 6
66050: DIFF
66051: ST_TO_ADDR
// if not need_heal_1 then
66052: LD_VAR 0 6
66056: NOT
66057: IFFALSE 66090
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
66059: LD_ADDR_EXP 62
66063: PUSH
66064: LD_EXP 62
66068: PPUSH
66069: LD_VAR 0 2
66073: PUSH
66074: LD_INT 1
66076: PUSH
66077: EMPTY
66078: LIST
66079: LIST
66080: PPUSH
66081: EMPTY
66082: PPUSH
66083: CALL 21521 0 3
66087: ST_TO_ADDR
66088: GO 66160
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
66090: LD_ADDR_EXP 62
66094: PUSH
66095: LD_EXP 62
66099: PPUSH
66100: LD_VAR 0 2
66104: PUSH
66105: LD_INT 1
66107: PUSH
66108: EMPTY
66109: LIST
66110: LIST
66111: PPUSH
66112: LD_EXP 62
66116: PUSH
66117: LD_VAR 0 2
66121: ARRAY
66122: PUSH
66123: LD_INT 1
66125: ARRAY
66126: PPUSH
66127: LD_INT 3
66129: PUSH
66130: LD_INT 24
66132: PUSH
66133: LD_INT 1000
66135: PUSH
66136: EMPTY
66137: LIST
66138: LIST
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: PPUSH
66144: CALL_OW 72
66148: PUSH
66149: LD_VAR 0 6
66153: UNION
66154: PPUSH
66155: CALL 21521 0 3
66159: ST_TO_ADDR
// if not need_heal_2 then
66160: LD_VAR 0 7
66164: NOT
66165: IFFALSE 66198
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
66167: LD_ADDR_EXP 62
66171: PUSH
66172: LD_EXP 62
66176: PPUSH
66177: LD_VAR 0 2
66181: PUSH
66182: LD_INT 2
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: PPUSH
66189: EMPTY
66190: PPUSH
66191: CALL 21521 0 3
66195: ST_TO_ADDR
66196: GO 66230
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
66198: LD_ADDR_EXP 62
66202: PUSH
66203: LD_EXP 62
66207: PPUSH
66208: LD_VAR 0 2
66212: PUSH
66213: LD_INT 2
66215: PUSH
66216: EMPTY
66217: LIST
66218: LIST
66219: PPUSH
66220: LD_VAR 0 7
66224: PPUSH
66225: CALL 21521 0 3
66229: ST_TO_ADDR
// if need_heal_2 then
66230: LD_VAR 0 7
66234: IFFALSE 66406
// for j in need_heal_2 do
66236: LD_ADDR_VAR 0 3
66240: PUSH
66241: LD_VAR 0 7
66245: PUSH
66246: FOR_IN
66247: IFFALSE 66404
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
66249: LD_ADDR_VAR 0 5
66253: PUSH
66254: LD_EXP 59
66258: PUSH
66259: LD_VAR 0 2
66263: ARRAY
66264: PPUSH
66265: LD_INT 2
66267: PUSH
66268: LD_INT 30
66270: PUSH
66271: LD_INT 6
66273: PUSH
66274: EMPTY
66275: LIST
66276: LIST
66277: PUSH
66278: LD_INT 30
66280: PUSH
66281: LD_INT 7
66283: PUSH
66284: EMPTY
66285: LIST
66286: LIST
66287: PUSH
66288: LD_INT 30
66290: PUSH
66291: LD_INT 8
66293: PUSH
66294: EMPTY
66295: LIST
66296: LIST
66297: PUSH
66298: LD_INT 30
66300: PUSH
66301: LD_INT 0
66303: PUSH
66304: EMPTY
66305: LIST
66306: LIST
66307: PUSH
66308: LD_INT 30
66310: PUSH
66311: LD_INT 1
66313: PUSH
66314: EMPTY
66315: LIST
66316: LIST
66317: PUSH
66318: LD_INT 25
66320: PUSH
66321: LD_INT 4
66323: PUSH
66324: EMPTY
66325: LIST
66326: LIST
66327: PUSH
66328: EMPTY
66329: LIST
66330: LIST
66331: LIST
66332: LIST
66333: LIST
66334: LIST
66335: LIST
66336: PPUSH
66337: CALL_OW 72
66341: ST_TO_ADDR
// if tmp then
66342: LD_VAR 0 5
66346: IFFALSE 66402
// begin k := NearestUnitToUnit ( tmp , j ) ;
66348: LD_ADDR_VAR 0 4
66352: PUSH
66353: LD_VAR 0 5
66357: PPUSH
66358: LD_VAR 0 3
66362: PPUSH
66363: CALL_OW 74
66367: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
66368: LD_VAR 0 3
66372: PPUSH
66373: LD_VAR 0 4
66377: PPUSH
66378: CALL_OW 296
66382: PUSH
66383: LD_INT 7
66385: GREATER
66386: IFFALSE 66402
// ComMoveUnit ( j , k ) ;
66388: LD_VAR 0 3
66392: PPUSH
66393: LD_VAR 0 4
66397: PPUSH
66398: CALL_OW 112
// end ; end ;
66402: GO 66246
66404: POP
66405: POP
// if not need_heal_1 and not need_heal_2 then
66406: LD_VAR 0 6
66410: NOT
66411: PUSH
66412: LD_VAR 0 7
66416: NOT
66417: AND
66418: IFFALSE 66422
// continue ;
66420: GO 65875
// end ;
66422: GO 65875
66424: POP
66425: POP
// RaiseSailEvent ( 102 ) ;
66426: LD_INT 102
66428: PPUSH
66429: CALL_OW 427
// end ;
66433: LD_VAR 0 1
66437: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
66438: LD_INT 0
66440: PPUSH
66441: PPUSH
66442: PPUSH
66443: PPUSH
66444: PPUSH
66445: PPUSH
66446: PPUSH
66447: PPUSH
// if not mc_bases then
66448: LD_EXP 59
66452: NOT
66453: IFFALSE 66457
// exit ;
66455: GO 67297
// for i = 1 to mc_bases do
66457: LD_ADDR_VAR 0 2
66461: PUSH
66462: DOUBLE
66463: LD_INT 1
66465: DEC
66466: ST_TO_ADDR
66467: LD_EXP 59
66471: PUSH
66472: FOR_TO
66473: IFFALSE 67295
// begin if not mc_building_need_repair [ i ] then
66475: LD_EXP 60
66479: PUSH
66480: LD_VAR 0 2
66484: ARRAY
66485: NOT
66486: IFFALSE 66660
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
66488: LD_ADDR_VAR 0 6
66492: PUSH
66493: LD_EXP 78
66497: PUSH
66498: LD_VAR 0 2
66502: ARRAY
66503: PPUSH
66504: LD_INT 3
66506: PUSH
66507: LD_INT 24
66509: PUSH
66510: LD_INT 1000
66512: PUSH
66513: EMPTY
66514: LIST
66515: LIST
66516: PUSH
66517: EMPTY
66518: LIST
66519: LIST
66520: PUSH
66521: LD_INT 2
66523: PUSH
66524: LD_INT 34
66526: PUSH
66527: LD_INT 13
66529: PUSH
66530: EMPTY
66531: LIST
66532: LIST
66533: PUSH
66534: LD_INT 34
66536: PUSH
66537: LD_INT 52
66539: PUSH
66540: EMPTY
66541: LIST
66542: LIST
66543: PUSH
66544: EMPTY
66545: LIST
66546: LIST
66547: LIST
66548: PUSH
66549: EMPTY
66550: LIST
66551: LIST
66552: PPUSH
66553: CALL_OW 72
66557: ST_TO_ADDR
// if cranes then
66558: LD_VAR 0 6
66562: IFFALSE 66624
// for j in cranes do
66564: LD_ADDR_VAR 0 3
66568: PUSH
66569: LD_VAR 0 6
66573: PUSH
66574: FOR_IN
66575: IFFALSE 66622
// if not IsInArea ( j , mc_parking [ i ] ) then
66577: LD_VAR 0 3
66581: PPUSH
66582: LD_EXP 83
66586: PUSH
66587: LD_VAR 0 2
66591: ARRAY
66592: PPUSH
66593: CALL_OW 308
66597: NOT
66598: IFFALSE 66620
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66600: LD_VAR 0 3
66604: PPUSH
66605: LD_EXP 83
66609: PUSH
66610: LD_VAR 0 2
66614: ARRAY
66615: PPUSH
66616: CALL_OW 113
66620: GO 66574
66622: POP
66623: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
66624: LD_ADDR_EXP 61
66628: PUSH
66629: LD_EXP 61
66633: PPUSH
66634: LD_VAR 0 2
66638: PPUSH
66639: EMPTY
66640: PPUSH
66641: CALL_OW 1
66645: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
66646: LD_VAR 0 2
66650: PPUSH
66651: LD_INT 101
66653: PPUSH
66654: CALL 61550 0 2
// continue ;
66658: GO 66472
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
66660: LD_ADDR_EXP 65
66664: PUSH
66665: LD_EXP 65
66669: PPUSH
66670: LD_VAR 0 2
66674: PPUSH
66675: EMPTY
66676: PPUSH
66677: CALL_OW 1
66681: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66682: LD_VAR 0 2
66686: PPUSH
66687: LD_INT 103
66689: PPUSH
66690: CALL 61550 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
66694: LD_ADDR_VAR 0 5
66698: PUSH
66699: LD_EXP 59
66703: PUSH
66704: LD_VAR 0 2
66708: ARRAY
66709: PUSH
66710: LD_EXP 88
66714: PUSH
66715: LD_VAR 0 2
66719: ARRAY
66720: UNION
66721: PPUSH
66722: LD_INT 2
66724: PUSH
66725: LD_INT 25
66727: PUSH
66728: LD_INT 2
66730: PUSH
66731: EMPTY
66732: LIST
66733: LIST
66734: PUSH
66735: LD_INT 25
66737: PUSH
66738: LD_INT 16
66740: PUSH
66741: EMPTY
66742: LIST
66743: LIST
66744: PUSH
66745: EMPTY
66746: LIST
66747: LIST
66748: LIST
66749: PUSH
66750: EMPTY
66751: LIST
66752: PPUSH
66753: CALL_OW 72
66757: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
66758: LD_ADDR_VAR 0 6
66762: PUSH
66763: LD_EXP 78
66767: PUSH
66768: LD_VAR 0 2
66772: ARRAY
66773: PPUSH
66774: LD_INT 2
66776: PUSH
66777: LD_INT 34
66779: PUSH
66780: LD_INT 13
66782: PUSH
66783: EMPTY
66784: LIST
66785: LIST
66786: PUSH
66787: LD_INT 34
66789: PUSH
66790: LD_INT 52
66792: PUSH
66793: EMPTY
66794: LIST
66795: LIST
66796: PUSH
66797: EMPTY
66798: LIST
66799: LIST
66800: LIST
66801: PPUSH
66802: CALL_OW 72
66806: ST_TO_ADDR
// if cranes then
66807: LD_VAR 0 6
66811: IFFALSE 66947
// begin for j in cranes do
66813: LD_ADDR_VAR 0 3
66817: PUSH
66818: LD_VAR 0 6
66822: PUSH
66823: FOR_IN
66824: IFFALSE 66945
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
66826: LD_VAR 0 3
66830: PPUSH
66831: CALL_OW 256
66835: PUSH
66836: LD_INT 500
66838: GREATEREQUAL
66839: PUSH
66840: LD_VAR 0 3
66844: PPUSH
66845: CALL_OW 314
66849: NOT
66850: AND
66851: IFFALSE 66885
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
66853: LD_VAR 0 3
66857: PPUSH
66858: LD_EXP 60
66862: PUSH
66863: LD_VAR 0 2
66867: ARRAY
66868: PPUSH
66869: LD_VAR 0 3
66873: PPUSH
66874: CALL_OW 74
66878: PPUSH
66879: CALL_OW 130
66883: GO 66943
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66885: LD_VAR 0 3
66889: PPUSH
66890: CALL_OW 256
66894: PUSH
66895: LD_INT 500
66897: LESS
66898: PUSH
66899: LD_VAR 0 3
66903: PPUSH
66904: LD_EXP 83
66908: PUSH
66909: LD_VAR 0 2
66913: ARRAY
66914: PPUSH
66915: CALL_OW 308
66919: NOT
66920: AND
66921: IFFALSE 66943
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66923: LD_VAR 0 3
66927: PPUSH
66928: LD_EXP 83
66932: PUSH
66933: LD_VAR 0 2
66937: ARRAY
66938: PPUSH
66939: CALL_OW 113
66943: GO 66823
66945: POP
66946: POP
// end ; if not tmp then
66947: LD_VAR 0 5
66951: NOT
66952: IFFALSE 66956
// continue ;
66954: GO 66472
// for j in tmp do
66956: LD_ADDR_VAR 0 3
66960: PUSH
66961: LD_VAR 0 5
66965: PUSH
66966: FOR_IN
66967: IFFALSE 67291
// begin if mc_need_heal [ i ] then
66969: LD_EXP 62
66973: PUSH
66974: LD_VAR 0 2
66978: ARRAY
66979: IFFALSE 67027
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
66981: LD_VAR 0 3
66985: PUSH
66986: LD_EXP 62
66990: PUSH
66991: LD_VAR 0 2
66995: ARRAY
66996: PUSH
66997: LD_INT 1
66999: ARRAY
67000: IN
67001: PUSH
67002: LD_VAR 0 3
67006: PUSH
67007: LD_EXP 62
67011: PUSH
67012: LD_VAR 0 2
67016: ARRAY
67017: PUSH
67018: LD_INT 2
67020: ARRAY
67021: IN
67022: OR
67023: IFFALSE 67027
// continue ;
67025: GO 66966
// if IsInUnit ( j ) then
67027: LD_VAR 0 3
67031: PPUSH
67032: CALL_OW 310
67036: IFFALSE 67047
// ComExitBuilding ( j ) ;
67038: LD_VAR 0 3
67042: PPUSH
67043: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
67047: LD_VAR 0 3
67051: PUSH
67052: LD_EXP 61
67056: PUSH
67057: LD_VAR 0 2
67061: ARRAY
67062: IN
67063: NOT
67064: IFFALSE 67122
// begin SetTag ( j , 101 ) ;
67066: LD_VAR 0 3
67070: PPUSH
67071: LD_INT 101
67073: PPUSH
67074: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
67078: LD_ADDR_EXP 61
67082: PUSH
67083: LD_EXP 61
67087: PPUSH
67088: LD_VAR 0 2
67092: PUSH
67093: LD_EXP 61
67097: PUSH
67098: LD_VAR 0 2
67102: ARRAY
67103: PUSH
67104: LD_INT 1
67106: PLUS
67107: PUSH
67108: EMPTY
67109: LIST
67110: LIST
67111: PPUSH
67112: LD_VAR 0 3
67116: PPUSH
67117: CALL 21521 0 3
67121: ST_TO_ADDR
// end ; wait ( 1 ) ;
67122: LD_INT 1
67124: PPUSH
67125: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
67129: LD_ADDR_VAR 0 7
67133: PUSH
67134: LD_EXP 60
67138: PUSH
67139: LD_VAR 0 2
67143: ARRAY
67144: ST_TO_ADDR
// if mc_scan [ i ] then
67145: LD_EXP 82
67149: PUSH
67150: LD_VAR 0 2
67154: ARRAY
67155: IFFALSE 67224
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
67157: LD_ADDR_VAR 0 7
67161: PUSH
67162: LD_EXP 60
67166: PUSH
67167: LD_VAR 0 2
67171: ARRAY
67172: PPUSH
67173: LD_INT 3
67175: PUSH
67176: LD_INT 2
67178: PUSH
67179: LD_INT 30
67181: PUSH
67182: LD_INT 32
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: PUSH
67189: LD_INT 30
67191: PUSH
67192: LD_INT 33
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: PUSH
67199: LD_INT 30
67201: PUSH
67202: LD_INT 31
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: PUSH
67209: EMPTY
67210: LIST
67211: LIST
67212: LIST
67213: LIST
67214: PUSH
67215: EMPTY
67216: LIST
67217: LIST
67218: PPUSH
67219: CALL_OW 72
67223: ST_TO_ADDR
// if not to_repair_tmp then
67224: LD_VAR 0 7
67228: NOT
67229: IFFALSE 67233
// continue ;
67231: GO 66966
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
67233: LD_ADDR_VAR 0 8
67237: PUSH
67238: LD_VAR 0 7
67242: PPUSH
67243: LD_VAR 0 3
67247: PPUSH
67248: CALL_OW 74
67252: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
67253: LD_VAR 0 8
67257: PPUSH
67258: LD_INT 14
67260: PPUSH
67261: CALL 24114 0 2
67265: PUSH
67266: LD_INT 4
67268: ARRAY
67269: PUSH
67270: LD_INT 5
67272: LESS
67273: IFFALSE 67289
// ComRepairBuilding ( j , to_repair ) ;
67275: LD_VAR 0 3
67279: PPUSH
67280: LD_VAR 0 8
67284: PPUSH
67285: CALL_OW 130
// end ;
67289: GO 66966
67291: POP
67292: POP
// end ;
67293: GO 66472
67295: POP
67296: POP
// end ;
67297: LD_VAR 0 1
67301: RET
// export function MC_Heal ; var i , j , tmp ; begin
67302: LD_INT 0
67304: PPUSH
67305: PPUSH
67306: PPUSH
67307: PPUSH
// if not mc_bases then
67308: LD_EXP 59
67312: NOT
67313: IFFALSE 67317
// exit ;
67315: GO 67719
// for i = 1 to mc_bases do
67317: LD_ADDR_VAR 0 2
67321: PUSH
67322: DOUBLE
67323: LD_INT 1
67325: DEC
67326: ST_TO_ADDR
67327: LD_EXP 59
67331: PUSH
67332: FOR_TO
67333: IFFALSE 67717
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
67335: LD_EXP 62
67339: PUSH
67340: LD_VAR 0 2
67344: ARRAY
67345: PUSH
67346: LD_INT 1
67348: ARRAY
67349: NOT
67350: PUSH
67351: LD_EXP 62
67355: PUSH
67356: LD_VAR 0 2
67360: ARRAY
67361: PUSH
67362: LD_INT 2
67364: ARRAY
67365: NOT
67366: AND
67367: IFFALSE 67405
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
67369: LD_ADDR_EXP 63
67373: PUSH
67374: LD_EXP 63
67378: PPUSH
67379: LD_VAR 0 2
67383: PPUSH
67384: EMPTY
67385: PPUSH
67386: CALL_OW 1
67390: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
67391: LD_VAR 0 2
67395: PPUSH
67396: LD_INT 102
67398: PPUSH
67399: CALL 61550 0 2
// continue ;
67403: GO 67332
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67405: LD_ADDR_VAR 0 4
67409: PUSH
67410: LD_EXP 59
67414: PUSH
67415: LD_VAR 0 2
67419: ARRAY
67420: PPUSH
67421: LD_INT 25
67423: PUSH
67424: LD_INT 4
67426: PUSH
67427: EMPTY
67428: LIST
67429: LIST
67430: PPUSH
67431: CALL_OW 72
67435: ST_TO_ADDR
// if not tmp then
67436: LD_VAR 0 4
67440: NOT
67441: IFFALSE 67445
// continue ;
67443: GO 67332
// if mc_taming [ i ] then
67445: LD_EXP 90
67449: PUSH
67450: LD_VAR 0 2
67454: ARRAY
67455: IFFALSE 67479
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
67457: LD_ADDR_EXP 90
67461: PUSH
67462: LD_EXP 90
67466: PPUSH
67467: LD_VAR 0 2
67471: PPUSH
67472: EMPTY
67473: PPUSH
67474: CALL_OW 1
67478: ST_TO_ADDR
// for j in tmp do
67479: LD_ADDR_VAR 0 3
67483: PUSH
67484: LD_VAR 0 4
67488: PUSH
67489: FOR_IN
67490: IFFALSE 67713
// begin if IsInUnit ( j ) then
67492: LD_VAR 0 3
67496: PPUSH
67497: CALL_OW 310
67501: IFFALSE 67512
// ComExitBuilding ( j ) ;
67503: LD_VAR 0 3
67507: PPUSH
67508: CALL_OW 122
// if not j in mc_healers [ i ] then
67512: LD_VAR 0 3
67516: PUSH
67517: LD_EXP 63
67521: PUSH
67522: LD_VAR 0 2
67526: ARRAY
67527: IN
67528: NOT
67529: IFFALSE 67575
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
67531: LD_ADDR_EXP 63
67535: PUSH
67536: LD_EXP 63
67540: PPUSH
67541: LD_VAR 0 2
67545: PUSH
67546: LD_EXP 63
67550: PUSH
67551: LD_VAR 0 2
67555: ARRAY
67556: PUSH
67557: LD_INT 1
67559: PLUS
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PPUSH
67565: LD_VAR 0 3
67569: PPUSH
67570: CALL 21521 0 3
67574: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
67575: LD_VAR 0 3
67579: PPUSH
67580: CALL_OW 110
67584: PUSH
67585: LD_INT 102
67587: NONEQUAL
67588: IFFALSE 67602
// SetTag ( j , 102 ) ;
67590: LD_VAR 0 3
67594: PPUSH
67595: LD_INT 102
67597: PPUSH
67598: CALL_OW 109
// Wait ( 3 ) ;
67602: LD_INT 3
67604: PPUSH
67605: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
67609: LD_EXP 62
67613: PUSH
67614: LD_VAR 0 2
67618: ARRAY
67619: PUSH
67620: LD_INT 1
67622: ARRAY
67623: IFFALSE 67655
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
67625: LD_VAR 0 3
67629: PPUSH
67630: LD_EXP 62
67634: PUSH
67635: LD_VAR 0 2
67639: ARRAY
67640: PUSH
67641: LD_INT 1
67643: ARRAY
67644: PUSH
67645: LD_INT 1
67647: ARRAY
67648: PPUSH
67649: CALL_OW 128
67653: GO 67711
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
67655: LD_VAR 0 3
67659: PPUSH
67660: CALL_OW 314
67664: NOT
67665: PUSH
67666: LD_EXP 62
67670: PUSH
67671: LD_VAR 0 2
67675: ARRAY
67676: PUSH
67677: LD_INT 2
67679: ARRAY
67680: AND
67681: IFFALSE 67711
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
67683: LD_VAR 0 3
67687: PPUSH
67688: LD_EXP 62
67692: PUSH
67693: LD_VAR 0 2
67697: ARRAY
67698: PUSH
67699: LD_INT 2
67701: ARRAY
67702: PUSH
67703: LD_INT 1
67705: ARRAY
67706: PPUSH
67707: CALL_OW 128
// end ;
67711: GO 67489
67713: POP
67714: POP
// end ;
67715: GO 67332
67717: POP
67718: POP
// end ;
67719: LD_VAR 0 1
67723: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
67724: LD_INT 0
67726: PPUSH
67727: PPUSH
67728: PPUSH
67729: PPUSH
67730: PPUSH
// if not mc_bases then
67731: LD_EXP 59
67735: NOT
67736: IFFALSE 67740
// exit ;
67738: GO 68883
// for i = 1 to mc_bases do
67740: LD_ADDR_VAR 0 2
67744: PUSH
67745: DOUBLE
67746: LD_INT 1
67748: DEC
67749: ST_TO_ADDR
67750: LD_EXP 59
67754: PUSH
67755: FOR_TO
67756: IFFALSE 68881
// begin if mc_scan [ i ] then
67758: LD_EXP 82
67762: PUSH
67763: LD_VAR 0 2
67767: ARRAY
67768: IFFALSE 67772
// continue ;
67770: GO 67755
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
67772: LD_EXP 64
67776: PUSH
67777: LD_VAR 0 2
67781: ARRAY
67782: NOT
67783: PUSH
67784: LD_EXP 66
67788: PUSH
67789: LD_VAR 0 2
67793: ARRAY
67794: NOT
67795: AND
67796: PUSH
67797: LD_EXP 65
67801: PUSH
67802: LD_VAR 0 2
67806: ARRAY
67807: AND
67808: IFFALSE 67846
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
67810: LD_ADDR_EXP 65
67814: PUSH
67815: LD_EXP 65
67819: PPUSH
67820: LD_VAR 0 2
67824: PPUSH
67825: EMPTY
67826: PPUSH
67827: CALL_OW 1
67831: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67832: LD_VAR 0 2
67836: PPUSH
67837: LD_INT 103
67839: PPUSH
67840: CALL 61550 0 2
// continue ;
67844: GO 67755
// end ; if mc_construct_list [ i ] then
67846: LD_EXP 66
67850: PUSH
67851: LD_VAR 0 2
67855: ARRAY
67856: IFFALSE 68076
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67858: LD_ADDR_VAR 0 4
67862: PUSH
67863: LD_EXP 59
67867: PUSH
67868: LD_VAR 0 2
67872: ARRAY
67873: PPUSH
67874: LD_INT 25
67876: PUSH
67877: LD_INT 2
67879: PUSH
67880: EMPTY
67881: LIST
67882: LIST
67883: PPUSH
67884: CALL_OW 72
67888: PUSH
67889: LD_EXP 61
67893: PUSH
67894: LD_VAR 0 2
67898: ARRAY
67899: DIFF
67900: ST_TO_ADDR
// if not tmp then
67901: LD_VAR 0 4
67905: NOT
67906: IFFALSE 67910
// continue ;
67908: GO 67755
// for j in tmp do
67910: LD_ADDR_VAR 0 3
67914: PUSH
67915: LD_VAR 0 4
67919: PUSH
67920: FOR_IN
67921: IFFALSE 68072
// begin if not mc_builders [ i ] then
67923: LD_EXP 65
67927: PUSH
67928: LD_VAR 0 2
67932: ARRAY
67933: NOT
67934: IFFALSE 67992
// begin SetTag ( j , 103 ) ;
67936: LD_VAR 0 3
67940: PPUSH
67941: LD_INT 103
67943: PPUSH
67944: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67948: LD_ADDR_EXP 65
67952: PUSH
67953: LD_EXP 65
67957: PPUSH
67958: LD_VAR 0 2
67962: PUSH
67963: LD_EXP 65
67967: PUSH
67968: LD_VAR 0 2
67972: ARRAY
67973: PUSH
67974: LD_INT 1
67976: PLUS
67977: PUSH
67978: EMPTY
67979: LIST
67980: LIST
67981: PPUSH
67982: LD_VAR 0 3
67986: PPUSH
67987: CALL 21521 0 3
67991: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67992: LD_VAR 0 3
67996: PPUSH
67997: CALL_OW 310
68001: IFFALSE 68012
// ComExitBuilding ( j ) ;
68003: LD_VAR 0 3
68007: PPUSH
68008: CALL_OW 122
// wait ( 3 ) ;
68012: LD_INT 3
68014: PPUSH
68015: CALL_OW 67
// if not mc_construct_list [ i ] then
68019: LD_EXP 66
68023: PUSH
68024: LD_VAR 0 2
68028: ARRAY
68029: NOT
68030: IFFALSE 68034
// break ;
68032: GO 68072
// if not HasTask ( j ) then
68034: LD_VAR 0 3
68038: PPUSH
68039: CALL_OW 314
68043: NOT
68044: IFFALSE 68070
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
68046: LD_VAR 0 3
68050: PPUSH
68051: LD_EXP 66
68055: PUSH
68056: LD_VAR 0 2
68060: ARRAY
68061: PUSH
68062: LD_INT 1
68064: ARRAY
68065: PPUSH
68066: CALL 24372 0 2
// end ;
68070: GO 67920
68072: POP
68073: POP
// end else
68074: GO 68879
// if mc_build_list [ i ] then
68076: LD_EXP 64
68080: PUSH
68081: LD_VAR 0 2
68085: ARRAY
68086: IFFALSE 68879
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68088: LD_ADDR_VAR 0 5
68092: PUSH
68093: LD_EXP 59
68097: PUSH
68098: LD_VAR 0 2
68102: ARRAY
68103: PPUSH
68104: LD_INT 2
68106: PUSH
68107: LD_INT 30
68109: PUSH
68110: LD_INT 0
68112: PUSH
68113: EMPTY
68114: LIST
68115: LIST
68116: PUSH
68117: LD_INT 30
68119: PUSH
68120: LD_INT 1
68122: PUSH
68123: EMPTY
68124: LIST
68125: LIST
68126: PUSH
68127: EMPTY
68128: LIST
68129: LIST
68130: LIST
68131: PPUSH
68132: CALL_OW 72
68136: ST_TO_ADDR
// if depot then
68137: LD_VAR 0 5
68141: IFFALSE 68159
// depot := depot [ 1 ] else
68143: LD_ADDR_VAR 0 5
68147: PUSH
68148: LD_VAR 0 5
68152: PUSH
68153: LD_INT 1
68155: ARRAY
68156: ST_TO_ADDR
68157: GO 68167
// depot := 0 ;
68159: LD_ADDR_VAR 0 5
68163: PUSH
68164: LD_INT 0
68166: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
68167: LD_EXP 64
68171: PUSH
68172: LD_VAR 0 2
68176: ARRAY
68177: PUSH
68178: LD_INT 1
68180: ARRAY
68181: PUSH
68182: LD_INT 1
68184: ARRAY
68185: PPUSH
68186: CALL 24202 0 1
68190: PUSH
68191: LD_EXP 59
68195: PUSH
68196: LD_VAR 0 2
68200: ARRAY
68201: PPUSH
68202: LD_INT 2
68204: PUSH
68205: LD_INT 30
68207: PUSH
68208: LD_INT 2
68210: PUSH
68211: EMPTY
68212: LIST
68213: LIST
68214: PUSH
68215: LD_INT 30
68217: PUSH
68218: LD_INT 3
68220: PUSH
68221: EMPTY
68222: LIST
68223: LIST
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: LIST
68229: PPUSH
68230: CALL_OW 72
68234: NOT
68235: AND
68236: IFFALSE 68341
// begin for j = 1 to mc_build_list [ i ] do
68238: LD_ADDR_VAR 0 3
68242: PUSH
68243: DOUBLE
68244: LD_INT 1
68246: DEC
68247: ST_TO_ADDR
68248: LD_EXP 64
68252: PUSH
68253: LD_VAR 0 2
68257: ARRAY
68258: PUSH
68259: FOR_TO
68260: IFFALSE 68339
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
68262: LD_EXP 64
68266: PUSH
68267: LD_VAR 0 2
68271: ARRAY
68272: PUSH
68273: LD_VAR 0 3
68277: ARRAY
68278: PUSH
68279: LD_INT 1
68281: ARRAY
68282: PUSH
68283: LD_INT 2
68285: EQUAL
68286: IFFALSE 68337
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
68288: LD_ADDR_EXP 64
68292: PUSH
68293: LD_EXP 64
68297: PPUSH
68298: LD_VAR 0 2
68302: PPUSH
68303: LD_EXP 64
68307: PUSH
68308: LD_VAR 0 2
68312: ARRAY
68313: PPUSH
68314: LD_VAR 0 3
68318: PPUSH
68319: LD_INT 1
68321: PPUSH
68322: LD_INT 0
68324: PPUSH
68325: CALL 20939 0 4
68329: PPUSH
68330: CALL_OW 1
68334: ST_TO_ADDR
// break ;
68335: GO 68339
// end ;
68337: GO 68259
68339: POP
68340: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
68341: LD_EXP 64
68345: PUSH
68346: LD_VAR 0 2
68350: ARRAY
68351: PUSH
68352: LD_INT 1
68354: ARRAY
68355: PUSH
68356: LD_INT 1
68358: ARRAY
68359: PUSH
68360: LD_INT 0
68362: EQUAL
68363: PUSH
68364: LD_VAR 0 5
68368: PUSH
68369: LD_VAR 0 5
68373: PPUSH
68374: LD_EXP 64
68378: PUSH
68379: LD_VAR 0 2
68383: ARRAY
68384: PUSH
68385: LD_INT 1
68387: ARRAY
68388: PUSH
68389: LD_INT 1
68391: ARRAY
68392: PPUSH
68393: LD_EXP 64
68397: PUSH
68398: LD_VAR 0 2
68402: ARRAY
68403: PUSH
68404: LD_INT 1
68406: ARRAY
68407: PUSH
68408: LD_INT 2
68410: ARRAY
68411: PPUSH
68412: LD_EXP 64
68416: PUSH
68417: LD_VAR 0 2
68421: ARRAY
68422: PUSH
68423: LD_INT 1
68425: ARRAY
68426: PUSH
68427: LD_INT 3
68429: ARRAY
68430: PPUSH
68431: LD_EXP 64
68435: PUSH
68436: LD_VAR 0 2
68440: ARRAY
68441: PUSH
68442: LD_INT 1
68444: ARRAY
68445: PUSH
68446: LD_INT 4
68448: ARRAY
68449: PPUSH
68450: CALL 28936 0 5
68454: AND
68455: OR
68456: IFFALSE 68737
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
68458: LD_ADDR_VAR 0 4
68462: PUSH
68463: LD_EXP 59
68467: PUSH
68468: LD_VAR 0 2
68472: ARRAY
68473: PPUSH
68474: LD_INT 25
68476: PUSH
68477: LD_INT 2
68479: PUSH
68480: EMPTY
68481: LIST
68482: LIST
68483: PPUSH
68484: CALL_OW 72
68488: PUSH
68489: LD_EXP 61
68493: PUSH
68494: LD_VAR 0 2
68498: ARRAY
68499: DIFF
68500: ST_TO_ADDR
// if not tmp then
68501: LD_VAR 0 4
68505: NOT
68506: IFFALSE 68510
// continue ;
68508: GO 67755
// for j in tmp do
68510: LD_ADDR_VAR 0 3
68514: PUSH
68515: LD_VAR 0 4
68519: PUSH
68520: FOR_IN
68521: IFFALSE 68733
// begin if not mc_builders [ i ] then
68523: LD_EXP 65
68527: PUSH
68528: LD_VAR 0 2
68532: ARRAY
68533: NOT
68534: IFFALSE 68592
// begin SetTag ( j , 103 ) ;
68536: LD_VAR 0 3
68540: PPUSH
68541: LD_INT 103
68543: PPUSH
68544: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68548: LD_ADDR_EXP 65
68552: PUSH
68553: LD_EXP 65
68557: PPUSH
68558: LD_VAR 0 2
68562: PUSH
68563: LD_EXP 65
68567: PUSH
68568: LD_VAR 0 2
68572: ARRAY
68573: PUSH
68574: LD_INT 1
68576: PLUS
68577: PUSH
68578: EMPTY
68579: LIST
68580: LIST
68581: PPUSH
68582: LD_VAR 0 3
68586: PPUSH
68587: CALL 21521 0 3
68591: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68592: LD_VAR 0 3
68596: PPUSH
68597: CALL_OW 310
68601: IFFALSE 68612
// ComExitBuilding ( j ) ;
68603: LD_VAR 0 3
68607: PPUSH
68608: CALL_OW 122
// wait ( 3 ) ;
68612: LD_INT 3
68614: PPUSH
68615: CALL_OW 67
// if not mc_build_list [ i ] then
68619: LD_EXP 64
68623: PUSH
68624: LD_VAR 0 2
68628: ARRAY
68629: NOT
68630: IFFALSE 68634
// break ;
68632: GO 68733
// if not HasTask ( j ) then
68634: LD_VAR 0 3
68638: PPUSH
68639: CALL_OW 314
68643: NOT
68644: IFFALSE 68731
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
68646: LD_VAR 0 3
68650: PPUSH
68651: LD_EXP 64
68655: PUSH
68656: LD_VAR 0 2
68660: ARRAY
68661: PUSH
68662: LD_INT 1
68664: ARRAY
68665: PUSH
68666: LD_INT 1
68668: ARRAY
68669: PPUSH
68670: LD_EXP 64
68674: PUSH
68675: LD_VAR 0 2
68679: ARRAY
68680: PUSH
68681: LD_INT 1
68683: ARRAY
68684: PUSH
68685: LD_INT 2
68687: ARRAY
68688: PPUSH
68689: LD_EXP 64
68693: PUSH
68694: LD_VAR 0 2
68698: ARRAY
68699: PUSH
68700: LD_INT 1
68702: ARRAY
68703: PUSH
68704: LD_INT 3
68706: ARRAY
68707: PPUSH
68708: LD_EXP 64
68712: PUSH
68713: LD_VAR 0 2
68717: ARRAY
68718: PUSH
68719: LD_INT 1
68721: ARRAY
68722: PUSH
68723: LD_INT 4
68725: ARRAY
68726: PPUSH
68727: CALL_OW 145
// end ;
68731: GO 68520
68733: POP
68734: POP
// end else
68735: GO 68879
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
68737: LD_EXP 59
68741: PUSH
68742: LD_VAR 0 2
68746: ARRAY
68747: PPUSH
68748: LD_EXP 64
68752: PUSH
68753: LD_VAR 0 2
68757: ARRAY
68758: PUSH
68759: LD_INT 1
68761: ARRAY
68762: PUSH
68763: LD_INT 1
68765: ARRAY
68766: PPUSH
68767: LD_EXP 64
68771: PUSH
68772: LD_VAR 0 2
68776: ARRAY
68777: PUSH
68778: LD_INT 1
68780: ARRAY
68781: PUSH
68782: LD_INT 2
68784: ARRAY
68785: PPUSH
68786: LD_EXP 64
68790: PUSH
68791: LD_VAR 0 2
68795: ARRAY
68796: PUSH
68797: LD_INT 1
68799: ARRAY
68800: PUSH
68801: LD_INT 3
68803: ARRAY
68804: PPUSH
68805: LD_EXP 64
68809: PUSH
68810: LD_VAR 0 2
68814: ARRAY
68815: PUSH
68816: LD_INT 1
68818: ARRAY
68819: PUSH
68820: LD_INT 4
68822: ARRAY
68823: PPUSH
68824: CALL 28272 0 5
68828: NOT
68829: IFFALSE 68879
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
68831: LD_ADDR_EXP 64
68835: PUSH
68836: LD_EXP 64
68840: PPUSH
68841: LD_VAR 0 2
68845: PPUSH
68846: LD_EXP 64
68850: PUSH
68851: LD_VAR 0 2
68855: ARRAY
68856: PPUSH
68857: LD_INT 1
68859: PPUSH
68860: LD_INT 1
68862: NEG
68863: PPUSH
68864: LD_INT 0
68866: PPUSH
68867: CALL 20939 0 4
68871: PPUSH
68872: CALL_OW 1
68876: ST_TO_ADDR
// continue ;
68877: GO 67755
// end ; end ; end ;
68879: GO 67755
68881: POP
68882: POP
// end ;
68883: LD_VAR 0 1
68887: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
68888: LD_INT 0
68890: PPUSH
68891: PPUSH
68892: PPUSH
68893: PPUSH
68894: PPUSH
68895: PPUSH
// if not mc_bases then
68896: LD_EXP 59
68900: NOT
68901: IFFALSE 68905
// exit ;
68903: GO 69332
// for i = 1 to mc_bases do
68905: LD_ADDR_VAR 0 2
68909: PUSH
68910: DOUBLE
68911: LD_INT 1
68913: DEC
68914: ST_TO_ADDR
68915: LD_EXP 59
68919: PUSH
68920: FOR_TO
68921: IFFALSE 69330
// begin tmp := mc_build_upgrade [ i ] ;
68923: LD_ADDR_VAR 0 4
68927: PUSH
68928: LD_EXP 91
68932: PUSH
68933: LD_VAR 0 2
68937: ARRAY
68938: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68939: LD_ADDR_VAR 0 6
68943: PUSH
68944: LD_EXP 92
68948: PUSH
68949: LD_VAR 0 2
68953: ARRAY
68954: PPUSH
68955: LD_INT 2
68957: PUSH
68958: LD_INT 30
68960: PUSH
68961: LD_INT 6
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: LD_INT 30
68970: PUSH
68971: LD_INT 7
68973: PUSH
68974: EMPTY
68975: LIST
68976: LIST
68977: PUSH
68978: EMPTY
68979: LIST
68980: LIST
68981: LIST
68982: PPUSH
68983: CALL_OW 72
68987: ST_TO_ADDR
// if not tmp and not lab then
68988: LD_VAR 0 4
68992: NOT
68993: PUSH
68994: LD_VAR 0 6
68998: NOT
68999: AND
69000: IFFALSE 69004
// continue ;
69002: GO 68920
// if tmp then
69004: LD_VAR 0 4
69008: IFFALSE 69128
// for j in tmp do
69010: LD_ADDR_VAR 0 3
69014: PUSH
69015: LD_VAR 0 4
69019: PUSH
69020: FOR_IN
69021: IFFALSE 69126
// begin if UpgradeCost ( j ) then
69023: LD_VAR 0 3
69027: PPUSH
69028: CALL 27932 0 1
69032: IFFALSE 69124
// begin ComUpgrade ( j ) ;
69034: LD_VAR 0 3
69038: PPUSH
69039: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
69043: LD_ADDR_EXP 91
69047: PUSH
69048: LD_EXP 91
69052: PPUSH
69053: LD_VAR 0 2
69057: PPUSH
69058: LD_EXP 91
69062: PUSH
69063: LD_VAR 0 2
69067: ARRAY
69068: PUSH
69069: LD_VAR 0 3
69073: DIFF
69074: PPUSH
69075: CALL_OW 1
69079: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69080: LD_ADDR_EXP 66
69084: PUSH
69085: LD_EXP 66
69089: PPUSH
69090: LD_VAR 0 2
69094: PUSH
69095: LD_EXP 66
69099: PUSH
69100: LD_VAR 0 2
69104: ARRAY
69105: PUSH
69106: LD_INT 1
69108: PLUS
69109: PUSH
69110: EMPTY
69111: LIST
69112: LIST
69113: PPUSH
69114: LD_VAR 0 3
69118: PPUSH
69119: CALL 21521 0 3
69123: ST_TO_ADDR
// end ; end ;
69124: GO 69020
69126: POP
69127: POP
// if not lab or not mc_lab_upgrade [ i ] then
69128: LD_VAR 0 6
69132: NOT
69133: PUSH
69134: LD_EXP 93
69138: PUSH
69139: LD_VAR 0 2
69143: ARRAY
69144: NOT
69145: OR
69146: IFFALSE 69150
// continue ;
69148: GO 68920
// for j in lab do
69150: LD_ADDR_VAR 0 3
69154: PUSH
69155: LD_VAR 0 6
69159: PUSH
69160: FOR_IN
69161: IFFALSE 69326
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
69163: LD_VAR 0 3
69167: PPUSH
69168: CALL_OW 266
69172: PUSH
69173: LD_INT 6
69175: PUSH
69176: LD_INT 7
69178: PUSH
69179: EMPTY
69180: LIST
69181: LIST
69182: IN
69183: PUSH
69184: LD_VAR 0 3
69188: PPUSH
69189: CALL_OW 461
69193: PUSH
69194: LD_INT 1
69196: NONEQUAL
69197: AND
69198: IFFALSE 69324
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
69200: LD_VAR 0 3
69204: PPUSH
69205: LD_EXP 93
69209: PUSH
69210: LD_VAR 0 2
69214: ARRAY
69215: PUSH
69216: LD_INT 1
69218: ARRAY
69219: PPUSH
69220: CALL 28137 0 2
69224: IFFALSE 69324
// begin ComCancel ( j ) ;
69226: LD_VAR 0 3
69230: PPUSH
69231: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
69235: LD_VAR 0 3
69239: PPUSH
69240: LD_EXP 93
69244: PUSH
69245: LD_VAR 0 2
69249: ARRAY
69250: PUSH
69251: LD_INT 1
69253: ARRAY
69254: PPUSH
69255: CALL_OW 207
// if not j in mc_construct_list [ i ] then
69259: LD_VAR 0 3
69263: PUSH
69264: LD_EXP 66
69268: PUSH
69269: LD_VAR 0 2
69273: ARRAY
69274: IN
69275: NOT
69276: IFFALSE 69322
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69278: LD_ADDR_EXP 66
69282: PUSH
69283: LD_EXP 66
69287: PPUSH
69288: LD_VAR 0 2
69292: PUSH
69293: LD_EXP 66
69297: PUSH
69298: LD_VAR 0 2
69302: ARRAY
69303: PUSH
69304: LD_INT 1
69306: PLUS
69307: PUSH
69308: EMPTY
69309: LIST
69310: LIST
69311: PPUSH
69312: LD_VAR 0 3
69316: PPUSH
69317: CALL 21521 0 3
69321: ST_TO_ADDR
// break ;
69322: GO 69326
// end ; end ; end ;
69324: GO 69160
69326: POP
69327: POP
// end ;
69328: GO 68920
69330: POP
69331: POP
// end ;
69332: LD_VAR 0 1
69336: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
69337: LD_INT 0
69339: PPUSH
69340: PPUSH
69341: PPUSH
69342: PPUSH
69343: PPUSH
69344: PPUSH
69345: PPUSH
69346: PPUSH
69347: PPUSH
// if not mc_bases then
69348: LD_EXP 59
69352: NOT
69353: IFFALSE 69357
// exit ;
69355: GO 69762
// for i = 1 to mc_bases do
69357: LD_ADDR_VAR 0 2
69361: PUSH
69362: DOUBLE
69363: LD_INT 1
69365: DEC
69366: ST_TO_ADDR
69367: LD_EXP 59
69371: PUSH
69372: FOR_TO
69373: IFFALSE 69760
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
69375: LD_EXP 67
69379: PUSH
69380: LD_VAR 0 2
69384: ARRAY
69385: NOT
69386: PUSH
69387: LD_EXP 59
69391: PUSH
69392: LD_VAR 0 2
69396: ARRAY
69397: PPUSH
69398: LD_INT 30
69400: PUSH
69401: LD_INT 3
69403: PUSH
69404: EMPTY
69405: LIST
69406: LIST
69407: PPUSH
69408: CALL_OW 72
69412: NOT
69413: OR
69414: IFFALSE 69418
// continue ;
69416: GO 69372
// busy := false ;
69418: LD_ADDR_VAR 0 8
69422: PUSH
69423: LD_INT 0
69425: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69426: LD_ADDR_VAR 0 4
69430: PUSH
69431: LD_EXP 59
69435: PUSH
69436: LD_VAR 0 2
69440: ARRAY
69441: PPUSH
69442: LD_INT 30
69444: PUSH
69445: LD_INT 3
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: PPUSH
69452: CALL_OW 72
69456: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
69457: LD_ADDR_VAR 0 6
69461: PUSH
69462: LD_EXP 67
69466: PUSH
69467: LD_VAR 0 2
69471: ARRAY
69472: PPUSH
69473: LD_INT 2
69475: PUSH
69476: LD_INT 30
69478: PUSH
69479: LD_INT 32
69481: PUSH
69482: EMPTY
69483: LIST
69484: LIST
69485: PUSH
69486: LD_INT 30
69488: PUSH
69489: LD_INT 33
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: PUSH
69496: EMPTY
69497: LIST
69498: LIST
69499: LIST
69500: PPUSH
69501: CALL_OW 72
69505: ST_TO_ADDR
// if not t then
69506: LD_VAR 0 6
69510: NOT
69511: IFFALSE 69515
// continue ;
69513: GO 69372
// for j in tmp do
69515: LD_ADDR_VAR 0 3
69519: PUSH
69520: LD_VAR 0 4
69524: PUSH
69525: FOR_IN
69526: IFFALSE 69556
// if not BuildingStatus ( j ) = bs_idle then
69528: LD_VAR 0 3
69532: PPUSH
69533: CALL_OW 461
69537: PUSH
69538: LD_INT 2
69540: EQUAL
69541: NOT
69542: IFFALSE 69554
// begin busy := true ;
69544: LD_ADDR_VAR 0 8
69548: PUSH
69549: LD_INT 1
69551: ST_TO_ADDR
// break ;
69552: GO 69556
// end ;
69554: GO 69525
69556: POP
69557: POP
// if busy then
69558: LD_VAR 0 8
69562: IFFALSE 69566
// continue ;
69564: GO 69372
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
69566: LD_ADDR_VAR 0 7
69570: PUSH
69571: LD_VAR 0 6
69575: PPUSH
69576: LD_INT 35
69578: PUSH
69579: LD_INT 0
69581: PUSH
69582: EMPTY
69583: LIST
69584: LIST
69585: PPUSH
69586: CALL_OW 72
69590: ST_TO_ADDR
// if tw then
69591: LD_VAR 0 7
69595: IFFALSE 69672
// begin tw := tw [ 1 ] ;
69597: LD_ADDR_VAR 0 7
69601: PUSH
69602: LD_VAR 0 7
69606: PUSH
69607: LD_INT 1
69609: ARRAY
69610: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
69611: LD_ADDR_VAR 0 9
69615: PUSH
69616: LD_VAR 0 7
69620: PPUSH
69621: LD_EXP 84
69625: PUSH
69626: LD_VAR 0 2
69630: ARRAY
69631: PPUSH
69632: CALL 26491 0 2
69636: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
69637: LD_EXP 98
69641: PUSH
69642: LD_VAR 0 2
69646: ARRAY
69647: IFFALSE 69670
// if not weapon in mc_allowed_tower_weapons [ i ] then
69649: LD_VAR 0 9
69653: PUSH
69654: LD_EXP 98
69658: PUSH
69659: LD_VAR 0 2
69663: ARRAY
69664: IN
69665: NOT
69666: IFFALSE 69670
// continue ;
69668: GO 69372
// end else
69670: GO 69735
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
69672: LD_ADDR_VAR 0 5
69676: PUSH
69677: LD_EXP 67
69681: PUSH
69682: LD_VAR 0 2
69686: ARRAY
69687: PPUSH
69688: LD_VAR 0 4
69692: PPUSH
69693: CALL 56718 0 2
69697: ST_TO_ADDR
// if not tmp2 then
69698: LD_VAR 0 5
69702: NOT
69703: IFFALSE 69707
// continue ;
69705: GO 69372
// tw := tmp2 [ 1 ] ;
69707: LD_ADDR_VAR 0 7
69711: PUSH
69712: LD_VAR 0 5
69716: PUSH
69717: LD_INT 1
69719: ARRAY
69720: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
69721: LD_ADDR_VAR 0 9
69725: PUSH
69726: LD_VAR 0 5
69730: PUSH
69731: LD_INT 2
69733: ARRAY
69734: ST_TO_ADDR
// end ; if not weapon then
69735: LD_VAR 0 9
69739: NOT
69740: IFFALSE 69744
// continue ;
69742: GO 69372
// ComPlaceWeapon ( tw , weapon ) ;
69744: LD_VAR 0 7
69748: PPUSH
69749: LD_VAR 0 9
69753: PPUSH
69754: CALL_OW 148
// end ;
69758: GO 69372
69760: POP
69761: POP
// end ;
69762: LD_VAR 0 1
69766: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
69767: LD_INT 0
69769: PPUSH
69770: PPUSH
69771: PPUSH
69772: PPUSH
69773: PPUSH
69774: PPUSH
// if not mc_bases then
69775: LD_EXP 59
69779: NOT
69780: IFFALSE 69784
// exit ;
69782: GO 70560
// for i = 1 to mc_bases do
69784: LD_ADDR_VAR 0 2
69788: PUSH
69789: DOUBLE
69790: LD_INT 1
69792: DEC
69793: ST_TO_ADDR
69794: LD_EXP 59
69798: PUSH
69799: FOR_TO
69800: IFFALSE 70558
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
69802: LD_EXP 72
69806: PUSH
69807: LD_VAR 0 2
69811: ARRAY
69812: NOT
69813: PUSH
69814: LD_EXP 72
69818: PUSH
69819: LD_VAR 0 2
69823: ARRAY
69824: PUSH
69825: LD_EXP 73
69829: PUSH
69830: LD_VAR 0 2
69834: ARRAY
69835: EQUAL
69836: OR
69837: PUSH
69838: LD_EXP 82
69842: PUSH
69843: LD_VAR 0 2
69847: ARRAY
69848: OR
69849: IFFALSE 69853
// continue ;
69851: GO 69799
// if mc_miners [ i ] then
69853: LD_EXP 73
69857: PUSH
69858: LD_VAR 0 2
69862: ARRAY
69863: IFFALSE 70245
// begin for j = mc_miners [ i ] downto 1 do
69865: LD_ADDR_VAR 0 3
69869: PUSH
69870: DOUBLE
69871: LD_EXP 73
69875: PUSH
69876: LD_VAR 0 2
69880: ARRAY
69881: INC
69882: ST_TO_ADDR
69883: LD_INT 1
69885: PUSH
69886: FOR_DOWNTO
69887: IFFALSE 70243
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
69889: LD_EXP 73
69893: PUSH
69894: LD_VAR 0 2
69898: ARRAY
69899: PUSH
69900: LD_VAR 0 3
69904: ARRAY
69905: PPUSH
69906: CALL_OW 301
69910: PUSH
69911: LD_EXP 73
69915: PUSH
69916: LD_VAR 0 2
69920: ARRAY
69921: PUSH
69922: LD_VAR 0 3
69926: ARRAY
69927: PPUSH
69928: CALL_OW 257
69932: PUSH
69933: LD_INT 1
69935: NONEQUAL
69936: OR
69937: IFFALSE 70000
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69939: LD_ADDR_VAR 0 5
69943: PUSH
69944: LD_EXP 73
69948: PUSH
69949: LD_VAR 0 2
69953: ARRAY
69954: PUSH
69955: LD_EXP 73
69959: PUSH
69960: LD_VAR 0 2
69964: ARRAY
69965: PUSH
69966: LD_VAR 0 3
69970: ARRAY
69971: DIFF
69972: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69973: LD_ADDR_EXP 73
69977: PUSH
69978: LD_EXP 73
69982: PPUSH
69983: LD_VAR 0 2
69987: PPUSH
69988: LD_VAR 0 5
69992: PPUSH
69993: CALL_OW 1
69997: ST_TO_ADDR
// continue ;
69998: GO 69886
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
70000: LD_EXP 73
70004: PUSH
70005: LD_VAR 0 2
70009: ARRAY
70010: PUSH
70011: LD_VAR 0 3
70015: ARRAY
70016: PPUSH
70017: CALL_OW 257
70021: PUSH
70022: LD_INT 1
70024: EQUAL
70025: PUSH
70026: LD_EXP 73
70030: PUSH
70031: LD_VAR 0 2
70035: ARRAY
70036: PUSH
70037: LD_VAR 0 3
70041: ARRAY
70042: PPUSH
70043: CALL_OW 459
70047: NOT
70048: AND
70049: PUSH
70050: LD_EXP 73
70054: PUSH
70055: LD_VAR 0 2
70059: ARRAY
70060: PUSH
70061: LD_VAR 0 3
70065: ARRAY
70066: PPUSH
70067: CALL_OW 314
70071: NOT
70072: AND
70073: IFFALSE 70241
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
70075: LD_EXP 73
70079: PUSH
70080: LD_VAR 0 2
70084: ARRAY
70085: PUSH
70086: LD_VAR 0 3
70090: ARRAY
70091: PPUSH
70092: CALL_OW 310
70096: IFFALSE 70119
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
70098: LD_EXP 73
70102: PUSH
70103: LD_VAR 0 2
70107: ARRAY
70108: PUSH
70109: LD_VAR 0 3
70113: ARRAY
70114: PPUSH
70115: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
70119: LD_EXP 73
70123: PUSH
70124: LD_VAR 0 2
70128: ARRAY
70129: PUSH
70130: LD_VAR 0 3
70134: ARRAY
70135: PPUSH
70136: CALL_OW 314
70140: NOT
70141: IFFALSE 70241
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
70143: LD_EXP 73
70147: PUSH
70148: LD_VAR 0 2
70152: ARRAY
70153: PUSH
70154: LD_VAR 0 3
70158: ARRAY
70159: PPUSH
70160: LD_EXP 72
70164: PUSH
70165: LD_VAR 0 2
70169: ARRAY
70170: PUSH
70171: LD_VAR 0 3
70175: PUSH
70176: LD_EXP 72
70180: PUSH
70181: LD_VAR 0 2
70185: ARRAY
70186: MOD
70187: PUSH
70188: LD_INT 1
70190: PLUS
70191: ARRAY
70192: PUSH
70193: LD_INT 1
70195: ARRAY
70196: PPUSH
70197: LD_EXP 72
70201: PUSH
70202: LD_VAR 0 2
70206: ARRAY
70207: PUSH
70208: LD_VAR 0 3
70212: PUSH
70213: LD_EXP 72
70217: PUSH
70218: LD_VAR 0 2
70222: ARRAY
70223: MOD
70224: PUSH
70225: LD_INT 1
70227: PLUS
70228: ARRAY
70229: PUSH
70230: LD_INT 2
70232: ARRAY
70233: PPUSH
70234: LD_INT 0
70236: PPUSH
70237: CALL_OW 193
// end ; end ;
70241: GO 69886
70243: POP
70244: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
70245: LD_ADDR_VAR 0 5
70249: PUSH
70250: LD_EXP 59
70254: PUSH
70255: LD_VAR 0 2
70259: ARRAY
70260: PPUSH
70261: LD_INT 2
70263: PUSH
70264: LD_INT 30
70266: PUSH
70267: LD_INT 4
70269: PUSH
70270: EMPTY
70271: LIST
70272: LIST
70273: PUSH
70274: LD_INT 30
70276: PUSH
70277: LD_INT 5
70279: PUSH
70280: EMPTY
70281: LIST
70282: LIST
70283: PUSH
70284: LD_INT 30
70286: PUSH
70287: LD_INT 32
70289: PUSH
70290: EMPTY
70291: LIST
70292: LIST
70293: PUSH
70294: EMPTY
70295: LIST
70296: LIST
70297: LIST
70298: LIST
70299: PPUSH
70300: CALL_OW 72
70304: ST_TO_ADDR
// if not tmp then
70305: LD_VAR 0 5
70309: NOT
70310: IFFALSE 70314
// continue ;
70312: GO 69799
// list := [ ] ;
70314: LD_ADDR_VAR 0 6
70318: PUSH
70319: EMPTY
70320: ST_TO_ADDR
// for j in tmp do
70321: LD_ADDR_VAR 0 3
70325: PUSH
70326: LD_VAR 0 5
70330: PUSH
70331: FOR_IN
70332: IFFALSE 70401
// begin for k in UnitsInside ( j ) do
70334: LD_ADDR_VAR 0 4
70338: PUSH
70339: LD_VAR 0 3
70343: PPUSH
70344: CALL_OW 313
70348: PUSH
70349: FOR_IN
70350: IFFALSE 70397
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
70352: LD_VAR 0 4
70356: PPUSH
70357: CALL_OW 257
70361: PUSH
70362: LD_INT 1
70364: EQUAL
70365: PUSH
70366: LD_VAR 0 4
70370: PPUSH
70371: CALL_OW 459
70375: NOT
70376: AND
70377: IFFALSE 70395
// list := list ^ k ;
70379: LD_ADDR_VAR 0 6
70383: PUSH
70384: LD_VAR 0 6
70388: PUSH
70389: LD_VAR 0 4
70393: ADD
70394: ST_TO_ADDR
70395: GO 70349
70397: POP
70398: POP
// end ;
70399: GO 70331
70401: POP
70402: POP
// list := list diff mc_miners [ i ] ;
70403: LD_ADDR_VAR 0 6
70407: PUSH
70408: LD_VAR 0 6
70412: PUSH
70413: LD_EXP 73
70417: PUSH
70418: LD_VAR 0 2
70422: ARRAY
70423: DIFF
70424: ST_TO_ADDR
// if not list then
70425: LD_VAR 0 6
70429: NOT
70430: IFFALSE 70434
// continue ;
70432: GO 69799
// k := mc_mines [ i ] - mc_miners [ i ] ;
70434: LD_ADDR_VAR 0 4
70438: PUSH
70439: LD_EXP 72
70443: PUSH
70444: LD_VAR 0 2
70448: ARRAY
70449: PUSH
70450: LD_EXP 73
70454: PUSH
70455: LD_VAR 0 2
70459: ARRAY
70460: MINUS
70461: ST_TO_ADDR
// if k > list then
70462: LD_VAR 0 4
70466: PUSH
70467: LD_VAR 0 6
70471: GREATER
70472: IFFALSE 70484
// k := list ;
70474: LD_ADDR_VAR 0 4
70478: PUSH
70479: LD_VAR 0 6
70483: ST_TO_ADDR
// for j = 1 to k do
70484: LD_ADDR_VAR 0 3
70488: PUSH
70489: DOUBLE
70490: LD_INT 1
70492: DEC
70493: ST_TO_ADDR
70494: LD_VAR 0 4
70498: PUSH
70499: FOR_TO
70500: IFFALSE 70554
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
70502: LD_ADDR_EXP 73
70506: PUSH
70507: LD_EXP 73
70511: PPUSH
70512: LD_VAR 0 2
70516: PUSH
70517: LD_EXP 73
70521: PUSH
70522: LD_VAR 0 2
70526: ARRAY
70527: PUSH
70528: LD_INT 1
70530: PLUS
70531: PUSH
70532: EMPTY
70533: LIST
70534: LIST
70535: PPUSH
70536: LD_VAR 0 6
70540: PUSH
70541: LD_VAR 0 3
70545: ARRAY
70546: PPUSH
70547: CALL 21521 0 3
70551: ST_TO_ADDR
70552: GO 70499
70554: POP
70555: POP
// end ;
70556: GO 69799
70558: POP
70559: POP
// end ;
70560: LD_VAR 0 1
70564: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
70565: LD_INT 0
70567: PPUSH
70568: PPUSH
70569: PPUSH
70570: PPUSH
70571: PPUSH
70572: PPUSH
70573: PPUSH
70574: PPUSH
70575: PPUSH
70576: PPUSH
// if not mc_bases then
70577: LD_EXP 59
70581: NOT
70582: IFFALSE 70586
// exit ;
70584: GO 72336
// for i = 1 to mc_bases do
70586: LD_ADDR_VAR 0 2
70590: PUSH
70591: DOUBLE
70592: LD_INT 1
70594: DEC
70595: ST_TO_ADDR
70596: LD_EXP 59
70600: PUSH
70601: FOR_TO
70602: IFFALSE 72334
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70604: LD_EXP 59
70608: PUSH
70609: LD_VAR 0 2
70613: ARRAY
70614: NOT
70615: PUSH
70616: LD_EXP 66
70620: PUSH
70621: LD_VAR 0 2
70625: ARRAY
70626: OR
70627: IFFALSE 70631
// continue ;
70629: GO 70601
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70631: LD_EXP 75
70635: PUSH
70636: LD_VAR 0 2
70640: ARRAY
70641: NOT
70642: PUSH
70643: LD_EXP 76
70647: PUSH
70648: LD_VAR 0 2
70652: ARRAY
70653: AND
70654: IFFALSE 70692
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70656: LD_ADDR_EXP 76
70660: PUSH
70661: LD_EXP 76
70665: PPUSH
70666: LD_VAR 0 2
70670: PPUSH
70671: EMPTY
70672: PPUSH
70673: CALL_OW 1
70677: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70678: LD_VAR 0 2
70682: PPUSH
70683: LD_INT 107
70685: PPUSH
70686: CALL 61550 0 2
// continue ;
70690: GO 70601
// end ; target := [ ] ;
70692: LD_ADDR_VAR 0 6
70696: PUSH
70697: EMPTY
70698: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70699: LD_ADDR_VAR 0 3
70703: PUSH
70704: DOUBLE
70705: LD_EXP 75
70709: PUSH
70710: LD_VAR 0 2
70714: ARRAY
70715: INC
70716: ST_TO_ADDR
70717: LD_INT 1
70719: PUSH
70720: FOR_DOWNTO
70721: IFFALSE 70981
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70723: LD_EXP 75
70727: PUSH
70728: LD_VAR 0 2
70732: ARRAY
70733: PUSH
70734: LD_VAR 0 3
70738: ARRAY
70739: PUSH
70740: LD_INT 2
70742: ARRAY
70743: PPUSH
70744: LD_EXP 75
70748: PUSH
70749: LD_VAR 0 2
70753: ARRAY
70754: PUSH
70755: LD_VAR 0 3
70759: ARRAY
70760: PUSH
70761: LD_INT 3
70763: ARRAY
70764: PPUSH
70765: CALL_OW 488
70769: PUSH
70770: LD_EXP 75
70774: PUSH
70775: LD_VAR 0 2
70779: ARRAY
70780: PUSH
70781: LD_VAR 0 3
70785: ARRAY
70786: PUSH
70787: LD_INT 2
70789: ARRAY
70790: PPUSH
70791: LD_EXP 75
70795: PUSH
70796: LD_VAR 0 2
70800: ARRAY
70801: PUSH
70802: LD_VAR 0 3
70806: ARRAY
70807: PUSH
70808: LD_INT 3
70810: ARRAY
70811: PPUSH
70812: CALL_OW 284
70816: PUSH
70817: LD_INT 0
70819: EQUAL
70820: AND
70821: IFFALSE 70876
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70823: LD_ADDR_VAR 0 5
70827: PUSH
70828: LD_EXP 75
70832: PUSH
70833: LD_VAR 0 2
70837: ARRAY
70838: PPUSH
70839: LD_VAR 0 3
70843: PPUSH
70844: CALL_OW 3
70848: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70849: LD_ADDR_EXP 75
70853: PUSH
70854: LD_EXP 75
70858: PPUSH
70859: LD_VAR 0 2
70863: PPUSH
70864: LD_VAR 0 5
70868: PPUSH
70869: CALL_OW 1
70873: ST_TO_ADDR
// continue ;
70874: GO 70720
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70876: LD_EXP 59
70880: PUSH
70881: LD_VAR 0 2
70885: ARRAY
70886: PUSH
70887: LD_INT 1
70889: ARRAY
70890: PPUSH
70891: CALL_OW 255
70895: PPUSH
70896: LD_EXP 75
70900: PUSH
70901: LD_VAR 0 2
70905: ARRAY
70906: PUSH
70907: LD_VAR 0 3
70911: ARRAY
70912: PUSH
70913: LD_INT 2
70915: ARRAY
70916: PPUSH
70917: LD_EXP 75
70921: PUSH
70922: LD_VAR 0 2
70926: ARRAY
70927: PUSH
70928: LD_VAR 0 3
70932: ARRAY
70933: PUSH
70934: LD_INT 3
70936: ARRAY
70937: PPUSH
70938: LD_INT 30
70940: PPUSH
70941: CALL 22417 0 4
70945: PUSH
70946: LD_INT 4
70948: ARRAY
70949: PUSH
70950: LD_INT 0
70952: EQUAL
70953: IFFALSE 70979
// begin target := mc_crates [ i ] [ j ] ;
70955: LD_ADDR_VAR 0 6
70959: PUSH
70960: LD_EXP 75
70964: PUSH
70965: LD_VAR 0 2
70969: ARRAY
70970: PUSH
70971: LD_VAR 0 3
70975: ARRAY
70976: ST_TO_ADDR
// break ;
70977: GO 70981
// end ; end ;
70979: GO 70720
70981: POP
70982: POP
// if not target then
70983: LD_VAR 0 6
70987: NOT
70988: IFFALSE 70992
// continue ;
70990: GO 70601
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70992: LD_ADDR_VAR 0 7
70996: PUSH
70997: LD_EXP 78
71001: PUSH
71002: LD_VAR 0 2
71006: ARRAY
71007: PPUSH
71008: LD_INT 2
71010: PUSH
71011: LD_INT 3
71013: PUSH
71014: LD_INT 58
71016: PUSH
71017: EMPTY
71018: LIST
71019: PUSH
71020: EMPTY
71021: LIST
71022: LIST
71023: PUSH
71024: LD_INT 61
71026: PUSH
71027: EMPTY
71028: LIST
71029: PUSH
71030: LD_INT 33
71032: PUSH
71033: LD_INT 5
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PUSH
71040: LD_INT 33
71042: PUSH
71043: LD_INT 3
71045: PUSH
71046: EMPTY
71047: LIST
71048: LIST
71049: PUSH
71050: EMPTY
71051: LIST
71052: LIST
71053: LIST
71054: LIST
71055: LIST
71056: PUSH
71057: LD_INT 2
71059: PUSH
71060: LD_INT 34
71062: PUSH
71063: LD_INT 32
71065: PUSH
71066: EMPTY
71067: LIST
71068: LIST
71069: PUSH
71070: LD_INT 34
71072: PUSH
71073: LD_INT 51
71075: PUSH
71076: EMPTY
71077: LIST
71078: LIST
71079: PUSH
71080: LD_INT 34
71082: PUSH
71083: LD_INT 12
71085: PUSH
71086: EMPTY
71087: LIST
71088: LIST
71089: PUSH
71090: EMPTY
71091: LIST
71092: LIST
71093: LIST
71094: LIST
71095: PUSH
71096: EMPTY
71097: LIST
71098: LIST
71099: PPUSH
71100: CALL_OW 72
71104: ST_TO_ADDR
// if not cargo then
71105: LD_VAR 0 7
71109: NOT
71110: IFFALSE 71753
// begin if mc_crates_collector [ i ] < 5 then
71112: LD_EXP 76
71116: PUSH
71117: LD_VAR 0 2
71121: ARRAY
71122: PUSH
71123: LD_INT 5
71125: LESS
71126: IFFALSE 71492
// begin if mc_ape [ i ] then
71128: LD_EXP 88
71132: PUSH
71133: LD_VAR 0 2
71137: ARRAY
71138: IFFALSE 71185
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
71140: LD_ADDR_VAR 0 5
71144: PUSH
71145: LD_EXP 88
71149: PUSH
71150: LD_VAR 0 2
71154: ARRAY
71155: PPUSH
71156: LD_INT 25
71158: PUSH
71159: LD_INT 16
71161: PUSH
71162: EMPTY
71163: LIST
71164: LIST
71165: PUSH
71166: LD_INT 24
71168: PUSH
71169: LD_INT 750
71171: PUSH
71172: EMPTY
71173: LIST
71174: LIST
71175: PUSH
71176: EMPTY
71177: LIST
71178: LIST
71179: PPUSH
71180: CALL_OW 72
71184: ST_TO_ADDR
// if not tmp then
71185: LD_VAR 0 5
71189: NOT
71190: IFFALSE 71237
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
71192: LD_ADDR_VAR 0 5
71196: PUSH
71197: LD_EXP 59
71201: PUSH
71202: LD_VAR 0 2
71206: ARRAY
71207: PPUSH
71208: LD_INT 25
71210: PUSH
71211: LD_INT 2
71213: PUSH
71214: EMPTY
71215: LIST
71216: LIST
71217: PUSH
71218: LD_INT 24
71220: PUSH
71221: LD_INT 750
71223: PUSH
71224: EMPTY
71225: LIST
71226: LIST
71227: PUSH
71228: EMPTY
71229: LIST
71230: LIST
71231: PPUSH
71232: CALL_OW 72
71236: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
71237: LD_EXP 88
71241: PUSH
71242: LD_VAR 0 2
71246: ARRAY
71247: PUSH
71248: LD_EXP 59
71252: PUSH
71253: LD_VAR 0 2
71257: ARRAY
71258: PPUSH
71259: LD_INT 25
71261: PUSH
71262: LD_INT 2
71264: PUSH
71265: EMPTY
71266: LIST
71267: LIST
71268: PUSH
71269: LD_INT 24
71271: PUSH
71272: LD_INT 750
71274: PUSH
71275: EMPTY
71276: LIST
71277: LIST
71278: PUSH
71279: EMPTY
71280: LIST
71281: LIST
71282: PPUSH
71283: CALL_OW 72
71287: AND
71288: PUSH
71289: LD_VAR 0 5
71293: PUSH
71294: LD_INT 5
71296: LESS
71297: AND
71298: IFFALSE 71380
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
71300: LD_ADDR_VAR 0 3
71304: PUSH
71305: LD_EXP 59
71309: PUSH
71310: LD_VAR 0 2
71314: ARRAY
71315: PPUSH
71316: LD_INT 25
71318: PUSH
71319: LD_INT 2
71321: PUSH
71322: EMPTY
71323: LIST
71324: LIST
71325: PUSH
71326: LD_INT 24
71328: PUSH
71329: LD_INT 750
71331: PUSH
71332: EMPTY
71333: LIST
71334: LIST
71335: PUSH
71336: EMPTY
71337: LIST
71338: LIST
71339: PPUSH
71340: CALL_OW 72
71344: PUSH
71345: FOR_IN
71346: IFFALSE 71378
// begin tmp := tmp union j ;
71348: LD_ADDR_VAR 0 5
71352: PUSH
71353: LD_VAR 0 5
71357: PUSH
71358: LD_VAR 0 3
71362: UNION
71363: ST_TO_ADDR
// if tmp >= 5 then
71364: LD_VAR 0 5
71368: PUSH
71369: LD_INT 5
71371: GREATEREQUAL
71372: IFFALSE 71376
// break ;
71374: GO 71378
// end ;
71376: GO 71345
71378: POP
71379: POP
// end ; if not tmp then
71380: LD_VAR 0 5
71384: NOT
71385: IFFALSE 71389
// continue ;
71387: GO 70601
// for j in tmp do
71389: LD_ADDR_VAR 0 3
71393: PUSH
71394: LD_VAR 0 5
71398: PUSH
71399: FOR_IN
71400: IFFALSE 71490
// if not GetTag ( j ) then
71402: LD_VAR 0 3
71406: PPUSH
71407: CALL_OW 110
71411: NOT
71412: IFFALSE 71488
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
71414: LD_ADDR_EXP 76
71418: PUSH
71419: LD_EXP 76
71423: PPUSH
71424: LD_VAR 0 2
71428: PUSH
71429: LD_EXP 76
71433: PUSH
71434: LD_VAR 0 2
71438: ARRAY
71439: PUSH
71440: LD_INT 1
71442: PLUS
71443: PUSH
71444: EMPTY
71445: LIST
71446: LIST
71447: PPUSH
71448: LD_VAR 0 3
71452: PPUSH
71453: CALL 21521 0 3
71457: ST_TO_ADDR
// SetTag ( j , 107 ) ;
71458: LD_VAR 0 3
71462: PPUSH
71463: LD_INT 107
71465: PPUSH
71466: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
71470: LD_EXP 76
71474: PUSH
71475: LD_VAR 0 2
71479: ARRAY
71480: PUSH
71481: LD_INT 5
71483: GREATEREQUAL
71484: IFFALSE 71488
// break ;
71486: GO 71490
// end ;
71488: GO 71399
71490: POP
71491: POP
// end ; if mc_crates_collector [ i ] and target then
71492: LD_EXP 76
71496: PUSH
71497: LD_VAR 0 2
71501: ARRAY
71502: PUSH
71503: LD_VAR 0 6
71507: AND
71508: IFFALSE 71751
// begin if mc_crates_collector [ i ] < target [ 1 ] then
71510: LD_EXP 76
71514: PUSH
71515: LD_VAR 0 2
71519: ARRAY
71520: PUSH
71521: LD_VAR 0 6
71525: PUSH
71526: LD_INT 1
71528: ARRAY
71529: LESS
71530: IFFALSE 71550
// tmp := mc_crates_collector [ i ] else
71532: LD_ADDR_VAR 0 5
71536: PUSH
71537: LD_EXP 76
71541: PUSH
71542: LD_VAR 0 2
71546: ARRAY
71547: ST_TO_ADDR
71548: GO 71564
// tmp := target [ 1 ] ;
71550: LD_ADDR_VAR 0 5
71554: PUSH
71555: LD_VAR 0 6
71559: PUSH
71560: LD_INT 1
71562: ARRAY
71563: ST_TO_ADDR
// k := 0 ;
71564: LD_ADDR_VAR 0 4
71568: PUSH
71569: LD_INT 0
71571: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
71572: LD_ADDR_VAR 0 3
71576: PUSH
71577: LD_EXP 76
71581: PUSH
71582: LD_VAR 0 2
71586: ARRAY
71587: PUSH
71588: FOR_IN
71589: IFFALSE 71749
// begin k := k + 1 ;
71591: LD_ADDR_VAR 0 4
71595: PUSH
71596: LD_VAR 0 4
71600: PUSH
71601: LD_INT 1
71603: PLUS
71604: ST_TO_ADDR
// if k > tmp then
71605: LD_VAR 0 4
71609: PUSH
71610: LD_VAR 0 5
71614: GREATER
71615: IFFALSE 71619
// break ;
71617: GO 71749
// if not GetClass ( j ) in [ 2 , 16 ] then
71619: LD_VAR 0 3
71623: PPUSH
71624: CALL_OW 257
71628: PUSH
71629: LD_INT 2
71631: PUSH
71632: LD_INT 16
71634: PUSH
71635: EMPTY
71636: LIST
71637: LIST
71638: IN
71639: NOT
71640: IFFALSE 71693
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71642: LD_ADDR_EXP 76
71646: PUSH
71647: LD_EXP 76
71651: PPUSH
71652: LD_VAR 0 2
71656: PPUSH
71657: LD_EXP 76
71661: PUSH
71662: LD_VAR 0 2
71666: ARRAY
71667: PUSH
71668: LD_VAR 0 3
71672: DIFF
71673: PPUSH
71674: CALL_OW 1
71678: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71679: LD_VAR 0 3
71683: PPUSH
71684: LD_INT 0
71686: PPUSH
71687: CALL_OW 109
// continue ;
71691: GO 71588
// end ; if IsInUnit ( j ) then
71693: LD_VAR 0 3
71697: PPUSH
71698: CALL_OW 310
71702: IFFALSE 71713
// ComExitBuilding ( j ) ;
71704: LD_VAR 0 3
71708: PPUSH
71709: CALL_OW 122
// wait ( 3 ) ;
71713: LD_INT 3
71715: PPUSH
71716: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71720: LD_VAR 0 3
71724: PPUSH
71725: LD_VAR 0 6
71729: PUSH
71730: LD_INT 2
71732: ARRAY
71733: PPUSH
71734: LD_VAR 0 6
71738: PUSH
71739: LD_INT 3
71741: ARRAY
71742: PPUSH
71743: CALL_OW 117
// end ;
71747: GO 71588
71749: POP
71750: POP
// end ; end else
71751: GO 72332
// begin for j in cargo do
71753: LD_ADDR_VAR 0 3
71757: PUSH
71758: LD_VAR 0 7
71762: PUSH
71763: FOR_IN
71764: IFFALSE 72330
// begin if GetTag ( j ) <> 0 then
71766: LD_VAR 0 3
71770: PPUSH
71771: CALL_OW 110
71775: PUSH
71776: LD_INT 0
71778: NONEQUAL
71779: IFFALSE 71783
// continue ;
71781: GO 71763
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71783: LD_VAR 0 3
71787: PPUSH
71788: CALL_OW 256
71792: PUSH
71793: LD_INT 1000
71795: LESS
71796: PUSH
71797: LD_VAR 0 3
71801: PPUSH
71802: LD_EXP 83
71806: PUSH
71807: LD_VAR 0 2
71811: ARRAY
71812: PPUSH
71813: CALL_OW 308
71817: NOT
71818: AND
71819: IFFALSE 71841
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71821: LD_VAR 0 3
71825: PPUSH
71826: LD_EXP 83
71830: PUSH
71831: LD_VAR 0 2
71835: ARRAY
71836: PPUSH
71837: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71841: LD_VAR 0 3
71845: PPUSH
71846: CALL_OW 256
71850: PUSH
71851: LD_INT 1000
71853: LESS
71854: PUSH
71855: LD_VAR 0 3
71859: PPUSH
71860: LD_EXP 83
71864: PUSH
71865: LD_VAR 0 2
71869: ARRAY
71870: PPUSH
71871: CALL_OW 308
71875: AND
71876: IFFALSE 71880
// continue ;
71878: GO 71763
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71880: LD_VAR 0 3
71884: PPUSH
71885: CALL_OW 262
71889: PUSH
71890: LD_INT 2
71892: EQUAL
71893: PUSH
71894: LD_VAR 0 3
71898: PPUSH
71899: CALL_OW 261
71903: PUSH
71904: LD_INT 15
71906: LESS
71907: AND
71908: IFFALSE 71912
// continue ;
71910: GO 71763
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71912: LD_VAR 0 3
71916: PPUSH
71917: CALL_OW 262
71921: PUSH
71922: LD_INT 1
71924: EQUAL
71925: PUSH
71926: LD_VAR 0 3
71930: PPUSH
71931: CALL_OW 261
71935: PUSH
71936: LD_INT 10
71938: LESS
71939: AND
71940: IFFALSE 72269
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71942: LD_ADDR_VAR 0 8
71946: PUSH
71947: LD_EXP 59
71951: PUSH
71952: LD_VAR 0 2
71956: ARRAY
71957: PPUSH
71958: LD_INT 2
71960: PUSH
71961: LD_INT 30
71963: PUSH
71964: LD_INT 0
71966: PUSH
71967: EMPTY
71968: LIST
71969: LIST
71970: PUSH
71971: LD_INT 30
71973: PUSH
71974: LD_INT 1
71976: PUSH
71977: EMPTY
71978: LIST
71979: LIST
71980: PUSH
71981: EMPTY
71982: LIST
71983: LIST
71984: LIST
71985: PPUSH
71986: CALL_OW 72
71990: ST_TO_ADDR
// if not depot then
71991: LD_VAR 0 8
71995: NOT
71996: IFFALSE 72000
// continue ;
71998: GO 71763
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
72000: LD_VAR 0 3
72004: PPUSH
72005: LD_VAR 0 8
72009: PPUSH
72010: LD_VAR 0 3
72014: PPUSH
72015: CALL_OW 74
72019: PPUSH
72020: CALL_OW 296
72024: PUSH
72025: LD_INT 6
72027: LESS
72028: IFFALSE 72044
// SetFuel ( j , 100 ) else
72030: LD_VAR 0 3
72034: PPUSH
72035: LD_INT 100
72037: PPUSH
72038: CALL_OW 240
72042: GO 72269
// if GetFuel ( j ) = 0 then
72044: LD_VAR 0 3
72048: PPUSH
72049: CALL_OW 261
72053: PUSH
72054: LD_INT 0
72056: EQUAL
72057: IFFALSE 72269
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
72059: LD_ADDR_EXP 78
72063: PUSH
72064: LD_EXP 78
72068: PPUSH
72069: LD_VAR 0 2
72073: PPUSH
72074: LD_EXP 78
72078: PUSH
72079: LD_VAR 0 2
72083: ARRAY
72084: PUSH
72085: LD_VAR 0 3
72089: DIFF
72090: PPUSH
72091: CALL_OW 1
72095: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
72096: LD_VAR 0 3
72100: PPUSH
72101: CALL_OW 263
72105: PUSH
72106: LD_INT 1
72108: EQUAL
72109: IFFALSE 72125
// ComExitVehicle ( IsInUnit ( j ) ) ;
72111: LD_VAR 0 3
72115: PPUSH
72116: CALL_OW 310
72120: PPUSH
72121: CALL_OW 121
// if GetControl ( j ) = control_remote then
72125: LD_VAR 0 3
72129: PPUSH
72130: CALL_OW 263
72134: PUSH
72135: LD_INT 2
72137: EQUAL
72138: IFFALSE 72149
// ComUnlink ( j ) ;
72140: LD_VAR 0 3
72144: PPUSH
72145: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
72149: LD_ADDR_VAR 0 9
72153: PUSH
72154: LD_VAR 0 2
72158: PPUSH
72159: LD_INT 3
72161: PPUSH
72162: CALL 81622 0 2
72166: ST_TO_ADDR
// if fac then
72167: LD_VAR 0 9
72171: IFFALSE 72267
// begin for k in fac do
72173: LD_ADDR_VAR 0 4
72177: PUSH
72178: LD_VAR 0 9
72182: PUSH
72183: FOR_IN
72184: IFFALSE 72265
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
72186: LD_ADDR_VAR 0 10
72190: PUSH
72191: LD_VAR 0 9
72195: PPUSH
72196: LD_VAR 0 3
72200: PPUSH
72201: CALL_OW 265
72205: PPUSH
72206: LD_VAR 0 3
72210: PPUSH
72211: CALL_OW 262
72215: PPUSH
72216: LD_VAR 0 3
72220: PPUSH
72221: CALL_OW 263
72225: PPUSH
72226: LD_VAR 0 3
72230: PPUSH
72231: CALL_OW 264
72235: PPUSH
72236: CALL 19053 0 5
72240: ST_TO_ADDR
// if components then
72241: LD_VAR 0 10
72245: IFFALSE 72263
// begin MC_InsertProduceList ( i , components ) ;
72247: LD_VAR 0 2
72251: PPUSH
72252: LD_VAR 0 10
72256: PPUSH
72257: CALL 81167 0 2
// break ;
72261: GO 72265
// end ; end ;
72263: GO 72183
72265: POP
72266: POP
// end ; continue ;
72267: GO 71763
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
72269: LD_VAR 0 3
72273: PPUSH
72274: LD_INT 1
72276: PPUSH
72277: CALL_OW 289
72281: PUSH
72282: LD_INT 100
72284: LESS
72285: PUSH
72286: LD_VAR 0 3
72290: PPUSH
72291: CALL_OW 314
72295: NOT
72296: AND
72297: IFFALSE 72326
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
72299: LD_VAR 0 3
72303: PPUSH
72304: LD_VAR 0 6
72308: PUSH
72309: LD_INT 2
72311: ARRAY
72312: PPUSH
72313: LD_VAR 0 6
72317: PUSH
72318: LD_INT 3
72320: ARRAY
72321: PPUSH
72322: CALL_OW 117
// break ;
72326: GO 72330
// end ;
72328: GO 71763
72330: POP
72331: POP
// end ; end ;
72332: GO 70601
72334: POP
72335: POP
// end ;
72336: LD_VAR 0 1
72340: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
72341: LD_INT 0
72343: PPUSH
72344: PPUSH
72345: PPUSH
72346: PPUSH
// if not mc_bases then
72347: LD_EXP 59
72351: NOT
72352: IFFALSE 72356
// exit ;
72354: GO 72517
// for i = 1 to mc_bases do
72356: LD_ADDR_VAR 0 2
72360: PUSH
72361: DOUBLE
72362: LD_INT 1
72364: DEC
72365: ST_TO_ADDR
72366: LD_EXP 59
72370: PUSH
72371: FOR_TO
72372: IFFALSE 72515
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
72374: LD_ADDR_VAR 0 4
72378: PUSH
72379: LD_EXP 78
72383: PUSH
72384: LD_VAR 0 2
72388: ARRAY
72389: PUSH
72390: LD_EXP 81
72394: PUSH
72395: LD_VAR 0 2
72399: ARRAY
72400: UNION
72401: PPUSH
72402: LD_INT 33
72404: PUSH
72405: LD_INT 2
72407: PUSH
72408: EMPTY
72409: LIST
72410: LIST
72411: PPUSH
72412: CALL_OW 72
72416: ST_TO_ADDR
// if tmp then
72417: LD_VAR 0 4
72421: IFFALSE 72513
// for j in tmp do
72423: LD_ADDR_VAR 0 3
72427: PUSH
72428: LD_VAR 0 4
72432: PUSH
72433: FOR_IN
72434: IFFALSE 72511
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
72436: LD_VAR 0 3
72440: PPUSH
72441: CALL_OW 312
72445: NOT
72446: PUSH
72447: LD_VAR 0 3
72451: PPUSH
72452: CALL_OW 256
72456: PUSH
72457: LD_INT 250
72459: GREATEREQUAL
72460: AND
72461: IFFALSE 72474
// Connect ( j ) else
72463: LD_VAR 0 3
72467: PPUSH
72468: CALL 24454 0 1
72472: GO 72509
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
72474: LD_VAR 0 3
72478: PPUSH
72479: CALL_OW 256
72483: PUSH
72484: LD_INT 250
72486: LESS
72487: PUSH
72488: LD_VAR 0 3
72492: PPUSH
72493: CALL_OW 312
72497: AND
72498: IFFALSE 72509
// ComUnlink ( j ) ;
72500: LD_VAR 0 3
72504: PPUSH
72505: CALL_OW 136
72509: GO 72433
72511: POP
72512: POP
// end ;
72513: GO 72371
72515: POP
72516: POP
// end ;
72517: LD_VAR 0 1
72521: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
72522: LD_INT 0
72524: PPUSH
72525: PPUSH
72526: PPUSH
72527: PPUSH
72528: PPUSH
// if not mc_bases then
72529: LD_EXP 59
72533: NOT
72534: IFFALSE 72538
// exit ;
72536: GO 72983
// for i = 1 to mc_bases do
72538: LD_ADDR_VAR 0 2
72542: PUSH
72543: DOUBLE
72544: LD_INT 1
72546: DEC
72547: ST_TO_ADDR
72548: LD_EXP 59
72552: PUSH
72553: FOR_TO
72554: IFFALSE 72981
// begin if not mc_produce [ i ] then
72556: LD_EXP 80
72560: PUSH
72561: LD_VAR 0 2
72565: ARRAY
72566: NOT
72567: IFFALSE 72571
// continue ;
72569: GO 72553
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72571: LD_ADDR_VAR 0 5
72575: PUSH
72576: LD_EXP 59
72580: PUSH
72581: LD_VAR 0 2
72585: ARRAY
72586: PPUSH
72587: LD_INT 30
72589: PUSH
72590: LD_INT 3
72592: PUSH
72593: EMPTY
72594: LIST
72595: LIST
72596: PPUSH
72597: CALL_OW 72
72601: ST_TO_ADDR
// if not fac then
72602: LD_VAR 0 5
72606: NOT
72607: IFFALSE 72611
// continue ;
72609: GO 72553
// for j in fac do
72611: LD_ADDR_VAR 0 3
72615: PUSH
72616: LD_VAR 0 5
72620: PUSH
72621: FOR_IN
72622: IFFALSE 72977
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72624: LD_VAR 0 3
72628: PPUSH
72629: CALL_OW 461
72633: PUSH
72634: LD_INT 2
72636: NONEQUAL
72637: PUSH
72638: LD_VAR 0 3
72642: PPUSH
72643: LD_INT 15
72645: PPUSH
72646: CALL 24114 0 2
72650: PUSH
72651: LD_INT 4
72653: ARRAY
72654: OR
72655: IFFALSE 72659
// continue ;
72657: GO 72621
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72659: LD_VAR 0 3
72663: PPUSH
72664: LD_EXP 80
72668: PUSH
72669: LD_VAR 0 2
72673: ARRAY
72674: PUSH
72675: LD_INT 1
72677: ARRAY
72678: PUSH
72679: LD_INT 1
72681: ARRAY
72682: PPUSH
72683: LD_EXP 80
72687: PUSH
72688: LD_VAR 0 2
72692: ARRAY
72693: PUSH
72694: LD_INT 1
72696: ARRAY
72697: PUSH
72698: LD_INT 2
72700: ARRAY
72701: PPUSH
72702: LD_EXP 80
72706: PUSH
72707: LD_VAR 0 2
72711: ARRAY
72712: PUSH
72713: LD_INT 1
72715: ARRAY
72716: PUSH
72717: LD_INT 3
72719: ARRAY
72720: PPUSH
72721: LD_EXP 80
72725: PUSH
72726: LD_VAR 0 2
72730: ARRAY
72731: PUSH
72732: LD_INT 1
72734: ARRAY
72735: PUSH
72736: LD_INT 4
72738: ARRAY
72739: PPUSH
72740: CALL_OW 448
72744: PUSH
72745: LD_VAR 0 3
72749: PPUSH
72750: LD_EXP 80
72754: PUSH
72755: LD_VAR 0 2
72759: ARRAY
72760: PUSH
72761: LD_INT 1
72763: ARRAY
72764: PUSH
72765: LD_INT 1
72767: ARRAY
72768: PUSH
72769: LD_EXP 80
72773: PUSH
72774: LD_VAR 0 2
72778: ARRAY
72779: PUSH
72780: LD_INT 1
72782: ARRAY
72783: PUSH
72784: LD_INT 2
72786: ARRAY
72787: PUSH
72788: LD_EXP 80
72792: PUSH
72793: LD_VAR 0 2
72797: ARRAY
72798: PUSH
72799: LD_INT 1
72801: ARRAY
72802: PUSH
72803: LD_INT 3
72805: ARRAY
72806: PUSH
72807: LD_EXP 80
72811: PUSH
72812: LD_VAR 0 2
72816: ARRAY
72817: PUSH
72818: LD_INT 1
72820: ARRAY
72821: PUSH
72822: LD_INT 4
72824: ARRAY
72825: PUSH
72826: EMPTY
72827: LIST
72828: LIST
72829: LIST
72830: LIST
72831: PPUSH
72832: CALL 27785 0 2
72836: AND
72837: IFFALSE 72975
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72839: LD_VAR 0 3
72843: PPUSH
72844: LD_EXP 80
72848: PUSH
72849: LD_VAR 0 2
72853: ARRAY
72854: PUSH
72855: LD_INT 1
72857: ARRAY
72858: PUSH
72859: LD_INT 1
72861: ARRAY
72862: PPUSH
72863: LD_EXP 80
72867: PUSH
72868: LD_VAR 0 2
72872: ARRAY
72873: PUSH
72874: LD_INT 1
72876: ARRAY
72877: PUSH
72878: LD_INT 2
72880: ARRAY
72881: PPUSH
72882: LD_EXP 80
72886: PUSH
72887: LD_VAR 0 2
72891: ARRAY
72892: PUSH
72893: LD_INT 1
72895: ARRAY
72896: PUSH
72897: LD_INT 3
72899: ARRAY
72900: PPUSH
72901: LD_EXP 80
72905: PUSH
72906: LD_VAR 0 2
72910: ARRAY
72911: PUSH
72912: LD_INT 1
72914: ARRAY
72915: PUSH
72916: LD_INT 4
72918: ARRAY
72919: PPUSH
72920: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72924: LD_ADDR_VAR 0 4
72928: PUSH
72929: LD_EXP 80
72933: PUSH
72934: LD_VAR 0 2
72938: ARRAY
72939: PPUSH
72940: LD_INT 1
72942: PPUSH
72943: CALL_OW 3
72947: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72948: LD_ADDR_EXP 80
72952: PUSH
72953: LD_EXP 80
72957: PPUSH
72958: LD_VAR 0 2
72962: PPUSH
72963: LD_VAR 0 4
72967: PPUSH
72968: CALL_OW 1
72972: ST_TO_ADDR
// break ;
72973: GO 72977
// end ; end ;
72975: GO 72621
72977: POP
72978: POP
// end ;
72979: GO 72553
72981: POP
72982: POP
// end ;
72983: LD_VAR 0 1
72987: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72988: LD_INT 0
72990: PPUSH
72991: PPUSH
72992: PPUSH
// if not mc_bases then
72993: LD_EXP 59
72997: NOT
72998: IFFALSE 73002
// exit ;
73000: GO 73091
// for i = 1 to mc_bases do
73002: LD_ADDR_VAR 0 2
73006: PUSH
73007: DOUBLE
73008: LD_INT 1
73010: DEC
73011: ST_TO_ADDR
73012: LD_EXP 59
73016: PUSH
73017: FOR_TO
73018: IFFALSE 73089
// begin if mc_attack [ i ] then
73020: LD_EXP 79
73024: PUSH
73025: LD_VAR 0 2
73029: ARRAY
73030: IFFALSE 73087
// begin tmp := mc_attack [ i ] [ 1 ] ;
73032: LD_ADDR_VAR 0 3
73036: PUSH
73037: LD_EXP 79
73041: PUSH
73042: LD_VAR 0 2
73046: ARRAY
73047: PUSH
73048: LD_INT 1
73050: ARRAY
73051: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
73052: LD_ADDR_EXP 79
73056: PUSH
73057: LD_EXP 79
73061: PPUSH
73062: LD_VAR 0 2
73066: PPUSH
73067: EMPTY
73068: PPUSH
73069: CALL_OW 1
73073: ST_TO_ADDR
// Attack ( tmp ) ;
73074: LD_VAR 0 3
73078: PPUSH
73079: CALL 49998 0 1
// exit ;
73083: POP
73084: POP
73085: GO 73091
// end ; end ;
73087: GO 73017
73089: POP
73090: POP
// end ;
73091: LD_VAR 0 1
73095: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
73096: LD_INT 0
73098: PPUSH
73099: PPUSH
73100: PPUSH
73101: PPUSH
73102: PPUSH
73103: PPUSH
73104: PPUSH
// if not mc_bases then
73105: LD_EXP 59
73109: NOT
73110: IFFALSE 73114
// exit ;
73112: GO 73696
// for i = 1 to mc_bases do
73114: LD_ADDR_VAR 0 2
73118: PUSH
73119: DOUBLE
73120: LD_INT 1
73122: DEC
73123: ST_TO_ADDR
73124: LD_EXP 59
73128: PUSH
73129: FOR_TO
73130: IFFALSE 73694
// begin if not mc_bases [ i ] then
73132: LD_EXP 59
73136: PUSH
73137: LD_VAR 0 2
73141: ARRAY
73142: NOT
73143: IFFALSE 73147
// continue ;
73145: GO 73129
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
73147: LD_ADDR_VAR 0 7
73151: PUSH
73152: LD_EXP 59
73156: PUSH
73157: LD_VAR 0 2
73161: ARRAY
73162: PUSH
73163: LD_INT 1
73165: ARRAY
73166: PPUSH
73167: CALL 18357 0 1
73171: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
73172: LD_ADDR_EXP 82
73176: PUSH
73177: LD_EXP 82
73181: PPUSH
73182: LD_VAR 0 2
73186: PPUSH
73187: LD_EXP 59
73191: PUSH
73192: LD_VAR 0 2
73196: ARRAY
73197: PUSH
73198: LD_INT 1
73200: ARRAY
73201: PPUSH
73202: CALL_OW 255
73206: PPUSH
73207: LD_EXP 84
73211: PUSH
73212: LD_VAR 0 2
73216: ARRAY
73217: PPUSH
73218: CALL 15911 0 2
73222: PPUSH
73223: CALL_OW 1
73227: ST_TO_ADDR
// if not mc_scan [ i ] then
73228: LD_EXP 82
73232: PUSH
73233: LD_VAR 0 2
73237: ARRAY
73238: NOT
73239: IFFALSE 73394
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73241: LD_ADDR_VAR 0 4
73245: PUSH
73246: LD_EXP 59
73250: PUSH
73251: LD_VAR 0 2
73255: ARRAY
73256: PPUSH
73257: LD_INT 2
73259: PUSH
73260: LD_INT 25
73262: PUSH
73263: LD_INT 5
73265: PUSH
73266: EMPTY
73267: LIST
73268: LIST
73269: PUSH
73270: LD_INT 25
73272: PUSH
73273: LD_INT 8
73275: PUSH
73276: EMPTY
73277: LIST
73278: LIST
73279: PUSH
73280: LD_INT 25
73282: PUSH
73283: LD_INT 9
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: PUSH
73290: EMPTY
73291: LIST
73292: LIST
73293: LIST
73294: LIST
73295: PPUSH
73296: CALL_OW 72
73300: ST_TO_ADDR
// if not tmp then
73301: LD_VAR 0 4
73305: NOT
73306: IFFALSE 73310
// continue ;
73308: GO 73129
// for j in tmp do
73310: LD_ADDR_VAR 0 3
73314: PUSH
73315: LD_VAR 0 4
73319: PUSH
73320: FOR_IN
73321: IFFALSE 73392
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
73323: LD_VAR 0 3
73327: PPUSH
73328: CALL_OW 310
73332: PPUSH
73333: CALL_OW 266
73337: PUSH
73338: LD_INT 5
73340: EQUAL
73341: PUSH
73342: LD_VAR 0 3
73346: PPUSH
73347: CALL_OW 257
73351: PUSH
73352: LD_INT 1
73354: EQUAL
73355: AND
73356: PUSH
73357: LD_VAR 0 3
73361: PPUSH
73362: CALL_OW 459
73366: NOT
73367: AND
73368: PUSH
73369: LD_VAR 0 7
73373: AND
73374: IFFALSE 73390
// ComChangeProfession ( j , class ) ;
73376: LD_VAR 0 3
73380: PPUSH
73381: LD_VAR 0 7
73385: PPUSH
73386: CALL_OW 123
73390: GO 73320
73392: POP
73393: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
73394: LD_EXP 82
73398: PUSH
73399: LD_VAR 0 2
73403: ARRAY
73404: PUSH
73405: LD_EXP 81
73409: PUSH
73410: LD_VAR 0 2
73414: ARRAY
73415: NOT
73416: AND
73417: PUSH
73418: LD_EXP 59
73422: PUSH
73423: LD_VAR 0 2
73427: ARRAY
73428: PPUSH
73429: LD_INT 30
73431: PUSH
73432: LD_INT 32
73434: PUSH
73435: EMPTY
73436: LIST
73437: LIST
73438: PPUSH
73439: CALL_OW 72
73443: NOT
73444: AND
73445: PUSH
73446: LD_EXP 59
73450: PUSH
73451: LD_VAR 0 2
73455: ARRAY
73456: PPUSH
73457: LD_INT 2
73459: PUSH
73460: LD_INT 30
73462: PUSH
73463: LD_INT 4
73465: PUSH
73466: EMPTY
73467: LIST
73468: LIST
73469: PUSH
73470: LD_INT 30
73472: PUSH
73473: LD_INT 5
73475: PUSH
73476: EMPTY
73477: LIST
73478: LIST
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: LIST
73484: PPUSH
73485: CALL_OW 72
73489: NOT
73490: AND
73491: IFFALSE 73623
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73493: LD_ADDR_VAR 0 4
73497: PUSH
73498: LD_EXP 59
73502: PUSH
73503: LD_VAR 0 2
73507: ARRAY
73508: PPUSH
73509: LD_INT 2
73511: PUSH
73512: LD_INT 25
73514: PUSH
73515: LD_INT 1
73517: PUSH
73518: EMPTY
73519: LIST
73520: LIST
73521: PUSH
73522: LD_INT 25
73524: PUSH
73525: LD_INT 5
73527: PUSH
73528: EMPTY
73529: LIST
73530: LIST
73531: PUSH
73532: LD_INT 25
73534: PUSH
73535: LD_INT 8
73537: PUSH
73538: EMPTY
73539: LIST
73540: LIST
73541: PUSH
73542: LD_INT 25
73544: PUSH
73545: LD_INT 9
73547: PUSH
73548: EMPTY
73549: LIST
73550: LIST
73551: PUSH
73552: EMPTY
73553: LIST
73554: LIST
73555: LIST
73556: LIST
73557: LIST
73558: PPUSH
73559: CALL_OW 72
73563: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
73564: LD_ADDR_VAR 0 4
73568: PUSH
73569: LD_VAR 0 4
73573: PUSH
73574: LD_VAR 0 4
73578: PPUSH
73579: LD_INT 18
73581: PPUSH
73582: CALL 54807 0 2
73586: DIFF
73587: ST_TO_ADDR
// if tmp then
73588: LD_VAR 0 4
73592: IFFALSE 73623
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
73594: LD_VAR 0 2
73598: PPUSH
73599: LD_VAR 0 4
73603: PPUSH
73604: LD_EXP 84
73608: PUSH
73609: LD_VAR 0 2
73613: ARRAY
73614: PPUSH
73615: CALL 15946 0 3
// exit ;
73619: POP
73620: POP
73621: GO 73696
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
73623: LD_EXP 82
73627: PUSH
73628: LD_VAR 0 2
73632: ARRAY
73633: PUSH
73634: LD_EXP 81
73638: PUSH
73639: LD_VAR 0 2
73643: ARRAY
73644: AND
73645: IFFALSE 73692
// begin tmp := mc_defender [ i ] ;
73647: LD_ADDR_VAR 0 4
73651: PUSH
73652: LD_EXP 81
73656: PUSH
73657: LD_VAR 0 2
73661: ARRAY
73662: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
73663: LD_VAR 0 2
73667: PPUSH
73668: LD_VAR 0 4
73672: PPUSH
73673: LD_EXP 82
73677: PUSH
73678: LD_VAR 0 2
73682: ARRAY
73683: PPUSH
73684: CALL 16507 0 3
// exit ;
73688: POP
73689: POP
73690: GO 73696
// end ; end ;
73692: GO 73129
73694: POP
73695: POP
// end ;
73696: LD_VAR 0 1
73700: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73701: LD_INT 0
73703: PPUSH
73704: PPUSH
73705: PPUSH
73706: PPUSH
73707: PPUSH
73708: PPUSH
73709: PPUSH
73710: PPUSH
73711: PPUSH
73712: PPUSH
73713: PPUSH
// if not mc_bases then
73714: LD_EXP 59
73718: NOT
73719: IFFALSE 73723
// exit ;
73721: GO 74810
// for i = 1 to mc_bases do
73723: LD_ADDR_VAR 0 2
73727: PUSH
73728: DOUBLE
73729: LD_INT 1
73731: DEC
73732: ST_TO_ADDR
73733: LD_EXP 59
73737: PUSH
73738: FOR_TO
73739: IFFALSE 74808
// begin tmp := mc_lab [ i ] ;
73741: LD_ADDR_VAR 0 6
73745: PUSH
73746: LD_EXP 92
73750: PUSH
73751: LD_VAR 0 2
73755: ARRAY
73756: ST_TO_ADDR
// if not tmp then
73757: LD_VAR 0 6
73761: NOT
73762: IFFALSE 73766
// continue ;
73764: GO 73738
// idle_lab := 0 ;
73766: LD_ADDR_VAR 0 11
73770: PUSH
73771: LD_INT 0
73773: ST_TO_ADDR
// for j in tmp do
73774: LD_ADDR_VAR 0 3
73778: PUSH
73779: LD_VAR 0 6
73783: PUSH
73784: FOR_IN
73785: IFFALSE 74804
// begin researching := false ;
73787: LD_ADDR_VAR 0 10
73791: PUSH
73792: LD_INT 0
73794: ST_TO_ADDR
// side := GetSide ( j ) ;
73795: LD_ADDR_VAR 0 4
73799: PUSH
73800: LD_VAR 0 3
73804: PPUSH
73805: CALL_OW 255
73809: ST_TO_ADDR
// if not mc_tech [ side ] then
73810: LD_EXP 86
73814: PUSH
73815: LD_VAR 0 4
73819: ARRAY
73820: NOT
73821: IFFALSE 73825
// continue ;
73823: GO 73784
// if BuildingStatus ( j ) = bs_idle then
73825: LD_VAR 0 3
73829: PPUSH
73830: CALL_OW 461
73834: PUSH
73835: LD_INT 2
73837: EQUAL
73838: IFFALSE 74026
// begin if idle_lab and UnitsInside ( j ) < 6 then
73840: LD_VAR 0 11
73844: PUSH
73845: LD_VAR 0 3
73849: PPUSH
73850: CALL_OW 313
73854: PUSH
73855: LD_INT 6
73857: LESS
73858: AND
73859: IFFALSE 73930
// begin tmp2 := UnitsInside ( idle_lab ) ;
73861: LD_ADDR_VAR 0 9
73865: PUSH
73866: LD_VAR 0 11
73870: PPUSH
73871: CALL_OW 313
73875: ST_TO_ADDR
// if tmp2 then
73876: LD_VAR 0 9
73880: IFFALSE 73922
// for x in tmp2 do
73882: LD_ADDR_VAR 0 7
73886: PUSH
73887: LD_VAR 0 9
73891: PUSH
73892: FOR_IN
73893: IFFALSE 73920
// begin ComExitBuilding ( x ) ;
73895: LD_VAR 0 7
73899: PPUSH
73900: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73904: LD_VAR 0 7
73908: PPUSH
73909: LD_VAR 0 3
73913: PPUSH
73914: CALL_OW 180
// end ;
73918: GO 73892
73920: POP
73921: POP
// idle_lab := 0 ;
73922: LD_ADDR_VAR 0 11
73926: PUSH
73927: LD_INT 0
73929: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73930: LD_ADDR_VAR 0 5
73934: PUSH
73935: LD_EXP 86
73939: PUSH
73940: LD_VAR 0 4
73944: ARRAY
73945: PUSH
73946: FOR_IN
73947: IFFALSE 74007
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73949: LD_VAR 0 3
73953: PPUSH
73954: LD_VAR 0 5
73958: PPUSH
73959: CALL_OW 430
73963: PUSH
73964: LD_VAR 0 4
73968: PPUSH
73969: LD_VAR 0 5
73973: PPUSH
73974: CALL 15016 0 2
73978: AND
73979: IFFALSE 74005
// begin researching := true ;
73981: LD_ADDR_VAR 0 10
73985: PUSH
73986: LD_INT 1
73988: ST_TO_ADDR
// ComResearch ( j , t ) ;
73989: LD_VAR 0 3
73993: PPUSH
73994: LD_VAR 0 5
73998: PPUSH
73999: CALL_OW 124
// break ;
74003: GO 74007
// end ;
74005: GO 73946
74007: POP
74008: POP
// if not researching then
74009: LD_VAR 0 10
74013: NOT
74014: IFFALSE 74026
// idle_lab := j ;
74016: LD_ADDR_VAR 0 11
74020: PUSH
74021: LD_VAR 0 3
74025: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
74026: LD_VAR 0 3
74030: PPUSH
74031: CALL_OW 461
74035: PUSH
74036: LD_INT 10
74038: EQUAL
74039: IFFALSE 74627
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
74041: LD_EXP 88
74045: PUSH
74046: LD_VAR 0 2
74050: ARRAY
74051: NOT
74052: PUSH
74053: LD_EXP 89
74057: PUSH
74058: LD_VAR 0 2
74062: ARRAY
74063: NOT
74064: AND
74065: PUSH
74066: LD_EXP 86
74070: PUSH
74071: LD_VAR 0 4
74075: ARRAY
74076: PUSH
74077: LD_INT 1
74079: GREATER
74080: AND
74081: IFFALSE 74212
// begin ComCancel ( j ) ;
74083: LD_VAR 0 3
74087: PPUSH
74088: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
74092: LD_ADDR_EXP 86
74096: PUSH
74097: LD_EXP 86
74101: PPUSH
74102: LD_VAR 0 4
74106: PPUSH
74107: LD_EXP 86
74111: PUSH
74112: LD_VAR 0 4
74116: ARRAY
74117: PPUSH
74118: LD_EXP 86
74122: PUSH
74123: LD_VAR 0 4
74127: ARRAY
74128: PUSH
74129: LD_INT 1
74131: MINUS
74132: PPUSH
74133: LD_EXP 86
74137: PUSH
74138: LD_VAR 0 4
74142: ARRAY
74143: PPUSH
74144: LD_INT 0
74146: PPUSH
74147: CALL 20939 0 4
74151: PPUSH
74152: CALL_OW 1
74156: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
74157: LD_ADDR_EXP 86
74161: PUSH
74162: LD_EXP 86
74166: PPUSH
74167: LD_VAR 0 4
74171: PPUSH
74172: LD_EXP 86
74176: PUSH
74177: LD_VAR 0 4
74181: ARRAY
74182: PPUSH
74183: LD_EXP 86
74187: PUSH
74188: LD_VAR 0 4
74192: ARRAY
74193: PPUSH
74194: LD_INT 1
74196: PPUSH
74197: LD_INT 0
74199: PPUSH
74200: CALL 20939 0 4
74204: PPUSH
74205: CALL_OW 1
74209: ST_TO_ADDR
// continue ;
74210: GO 73784
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
74212: LD_EXP 88
74216: PUSH
74217: LD_VAR 0 2
74221: ARRAY
74222: PUSH
74223: LD_EXP 89
74227: PUSH
74228: LD_VAR 0 2
74232: ARRAY
74233: NOT
74234: AND
74235: IFFALSE 74362
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
74237: LD_ADDR_EXP 89
74241: PUSH
74242: LD_EXP 89
74246: PPUSH
74247: LD_VAR 0 2
74251: PUSH
74252: LD_EXP 89
74256: PUSH
74257: LD_VAR 0 2
74261: ARRAY
74262: PUSH
74263: LD_INT 1
74265: PLUS
74266: PUSH
74267: EMPTY
74268: LIST
74269: LIST
74270: PPUSH
74271: LD_EXP 88
74275: PUSH
74276: LD_VAR 0 2
74280: ARRAY
74281: PUSH
74282: LD_INT 1
74284: ARRAY
74285: PPUSH
74286: CALL 21521 0 3
74290: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
74291: LD_EXP 88
74295: PUSH
74296: LD_VAR 0 2
74300: ARRAY
74301: PUSH
74302: LD_INT 1
74304: ARRAY
74305: PPUSH
74306: LD_INT 112
74308: PPUSH
74309: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
74313: LD_ADDR_VAR 0 9
74317: PUSH
74318: LD_EXP 88
74322: PUSH
74323: LD_VAR 0 2
74327: ARRAY
74328: PPUSH
74329: LD_INT 1
74331: PPUSH
74332: CALL_OW 3
74336: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
74337: LD_ADDR_EXP 88
74341: PUSH
74342: LD_EXP 88
74346: PPUSH
74347: LD_VAR 0 2
74351: PPUSH
74352: LD_VAR 0 9
74356: PPUSH
74357: CALL_OW 1
74361: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
74362: LD_EXP 88
74366: PUSH
74367: LD_VAR 0 2
74371: ARRAY
74372: PUSH
74373: LD_EXP 89
74377: PUSH
74378: LD_VAR 0 2
74382: ARRAY
74383: AND
74384: PUSH
74385: LD_EXP 89
74389: PUSH
74390: LD_VAR 0 2
74394: ARRAY
74395: PUSH
74396: LD_INT 1
74398: ARRAY
74399: PPUSH
74400: CALL_OW 310
74404: NOT
74405: AND
74406: PUSH
74407: LD_VAR 0 3
74411: PPUSH
74412: CALL_OW 313
74416: PUSH
74417: LD_INT 6
74419: EQUAL
74420: AND
74421: IFFALSE 74477
// begin tmp2 := UnitsInside ( j ) ;
74423: LD_ADDR_VAR 0 9
74427: PUSH
74428: LD_VAR 0 3
74432: PPUSH
74433: CALL_OW 313
74437: ST_TO_ADDR
// if tmp2 = 6 then
74438: LD_VAR 0 9
74442: PUSH
74443: LD_INT 6
74445: EQUAL
74446: IFFALSE 74477
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
74448: LD_VAR 0 9
74452: PUSH
74453: LD_INT 1
74455: ARRAY
74456: PPUSH
74457: LD_INT 112
74459: PPUSH
74460: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
74464: LD_VAR 0 9
74468: PUSH
74469: LD_INT 1
74471: ARRAY
74472: PPUSH
74473: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
74477: LD_EXP 89
74481: PUSH
74482: LD_VAR 0 2
74486: ARRAY
74487: PUSH
74488: LD_EXP 89
74492: PUSH
74493: LD_VAR 0 2
74497: ARRAY
74498: PUSH
74499: LD_INT 1
74501: ARRAY
74502: PPUSH
74503: CALL_OW 314
74507: NOT
74508: AND
74509: PUSH
74510: LD_EXP 89
74514: PUSH
74515: LD_VAR 0 2
74519: ARRAY
74520: PUSH
74521: LD_INT 1
74523: ARRAY
74524: PPUSH
74525: CALL_OW 310
74529: NOT
74530: AND
74531: IFFALSE 74557
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
74533: LD_EXP 89
74537: PUSH
74538: LD_VAR 0 2
74542: ARRAY
74543: PUSH
74544: LD_INT 1
74546: ARRAY
74547: PPUSH
74548: LD_VAR 0 3
74552: PPUSH
74553: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
74557: LD_EXP 89
74561: PUSH
74562: LD_VAR 0 2
74566: ARRAY
74567: PUSH
74568: LD_INT 1
74570: ARRAY
74571: PPUSH
74572: CALL_OW 310
74576: PUSH
74577: LD_EXP 89
74581: PUSH
74582: LD_VAR 0 2
74586: ARRAY
74587: PUSH
74588: LD_INT 1
74590: ARRAY
74591: PPUSH
74592: CALL_OW 310
74596: PPUSH
74597: CALL_OW 461
74601: PUSH
74602: LD_INT 3
74604: NONEQUAL
74605: AND
74606: IFFALSE 74627
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74608: LD_EXP 89
74612: PUSH
74613: LD_VAR 0 2
74617: ARRAY
74618: PUSH
74619: LD_INT 1
74621: ARRAY
74622: PPUSH
74623: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74627: LD_VAR 0 3
74631: PPUSH
74632: CALL_OW 461
74636: PUSH
74637: LD_INT 6
74639: EQUAL
74640: PUSH
74641: LD_VAR 0 6
74645: PUSH
74646: LD_INT 1
74648: GREATER
74649: AND
74650: IFFALSE 74802
// begin sci := [ ] ;
74652: LD_ADDR_VAR 0 8
74656: PUSH
74657: EMPTY
74658: ST_TO_ADDR
// for x in ( tmp diff j ) do
74659: LD_ADDR_VAR 0 7
74663: PUSH
74664: LD_VAR 0 6
74668: PUSH
74669: LD_VAR 0 3
74673: DIFF
74674: PUSH
74675: FOR_IN
74676: IFFALSE 74728
// begin if sci = 6 then
74678: LD_VAR 0 8
74682: PUSH
74683: LD_INT 6
74685: EQUAL
74686: IFFALSE 74690
// break ;
74688: GO 74728
// if BuildingStatus ( x ) = bs_idle then
74690: LD_VAR 0 7
74694: PPUSH
74695: CALL_OW 461
74699: PUSH
74700: LD_INT 2
74702: EQUAL
74703: IFFALSE 74726
// sci := sci ^ UnitsInside ( x ) ;
74705: LD_ADDR_VAR 0 8
74709: PUSH
74710: LD_VAR 0 8
74714: PUSH
74715: LD_VAR 0 7
74719: PPUSH
74720: CALL_OW 313
74724: ADD
74725: ST_TO_ADDR
// end ;
74726: GO 74675
74728: POP
74729: POP
// if not sci then
74730: LD_VAR 0 8
74734: NOT
74735: IFFALSE 74739
// continue ;
74737: GO 73784
// for x in sci do
74739: LD_ADDR_VAR 0 7
74743: PUSH
74744: LD_VAR 0 8
74748: PUSH
74749: FOR_IN
74750: IFFALSE 74800
// if IsInUnit ( x ) and not HasTask ( x ) then
74752: LD_VAR 0 7
74756: PPUSH
74757: CALL_OW 310
74761: PUSH
74762: LD_VAR 0 7
74766: PPUSH
74767: CALL_OW 314
74771: NOT
74772: AND
74773: IFFALSE 74798
// begin ComExitBuilding ( x ) ;
74775: LD_VAR 0 7
74779: PPUSH
74780: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74784: LD_VAR 0 7
74788: PPUSH
74789: LD_VAR 0 3
74793: PPUSH
74794: CALL_OW 180
// end ;
74798: GO 74749
74800: POP
74801: POP
// end ; end ;
74802: GO 73784
74804: POP
74805: POP
// end ;
74806: GO 73738
74808: POP
74809: POP
// end ;
74810: LD_VAR 0 1
74814: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74815: LD_INT 0
74817: PPUSH
74818: PPUSH
// if not mc_bases then
74819: LD_EXP 59
74823: NOT
74824: IFFALSE 74828
// exit ;
74826: GO 74909
// for i = 1 to mc_bases do
74828: LD_ADDR_VAR 0 2
74832: PUSH
74833: DOUBLE
74834: LD_INT 1
74836: DEC
74837: ST_TO_ADDR
74838: LD_EXP 59
74842: PUSH
74843: FOR_TO
74844: IFFALSE 74907
// if mc_mines [ i ] and mc_miners [ i ] then
74846: LD_EXP 72
74850: PUSH
74851: LD_VAR 0 2
74855: ARRAY
74856: PUSH
74857: LD_EXP 73
74861: PUSH
74862: LD_VAR 0 2
74866: ARRAY
74867: AND
74868: IFFALSE 74905
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74870: LD_EXP 73
74874: PUSH
74875: LD_VAR 0 2
74879: ARRAY
74880: PUSH
74881: LD_INT 1
74883: ARRAY
74884: PPUSH
74885: CALL_OW 255
74889: PPUSH
74890: LD_EXP 72
74894: PUSH
74895: LD_VAR 0 2
74899: ARRAY
74900: PPUSH
74901: CALL 18510 0 2
74905: GO 74843
74907: POP
74908: POP
// end ;
74909: LD_VAR 0 1
74913: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74914: LD_INT 0
74916: PPUSH
74917: PPUSH
74918: PPUSH
74919: PPUSH
74920: PPUSH
74921: PPUSH
74922: PPUSH
74923: PPUSH
// if not mc_bases or not mc_parking then
74924: LD_EXP 59
74928: NOT
74929: PUSH
74930: LD_EXP 83
74934: NOT
74935: OR
74936: IFFALSE 74940
// exit ;
74938: GO 75639
// for i = 1 to mc_bases do
74940: LD_ADDR_VAR 0 2
74944: PUSH
74945: DOUBLE
74946: LD_INT 1
74948: DEC
74949: ST_TO_ADDR
74950: LD_EXP 59
74954: PUSH
74955: FOR_TO
74956: IFFALSE 75637
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74958: LD_EXP 59
74962: PUSH
74963: LD_VAR 0 2
74967: ARRAY
74968: NOT
74969: PUSH
74970: LD_EXP 83
74974: PUSH
74975: LD_VAR 0 2
74979: ARRAY
74980: NOT
74981: OR
74982: IFFALSE 74986
// continue ;
74984: GO 74955
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74986: LD_ADDR_VAR 0 5
74990: PUSH
74991: LD_EXP 59
74995: PUSH
74996: LD_VAR 0 2
75000: ARRAY
75001: PUSH
75002: LD_INT 1
75004: ARRAY
75005: PPUSH
75006: CALL_OW 255
75010: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75011: LD_ADDR_VAR 0 6
75015: PUSH
75016: LD_EXP 59
75020: PUSH
75021: LD_VAR 0 2
75025: ARRAY
75026: PPUSH
75027: LD_INT 30
75029: PUSH
75030: LD_INT 3
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PPUSH
75037: CALL_OW 72
75041: ST_TO_ADDR
// if not fac then
75042: LD_VAR 0 6
75046: NOT
75047: IFFALSE 75098
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75049: LD_ADDR_VAR 0 6
75053: PUSH
75054: LD_EXP 59
75058: PUSH
75059: LD_VAR 0 2
75063: ARRAY
75064: PPUSH
75065: LD_INT 2
75067: PUSH
75068: LD_INT 30
75070: PUSH
75071: LD_INT 0
75073: PUSH
75074: EMPTY
75075: LIST
75076: LIST
75077: PUSH
75078: LD_INT 30
75080: PUSH
75081: LD_INT 1
75083: PUSH
75084: EMPTY
75085: LIST
75086: LIST
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: LIST
75092: PPUSH
75093: CALL_OW 72
75097: ST_TO_ADDR
// if not fac then
75098: LD_VAR 0 6
75102: NOT
75103: IFFALSE 75107
// continue ;
75105: GO 74955
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75107: LD_ADDR_VAR 0 7
75111: PUSH
75112: LD_EXP 83
75116: PUSH
75117: LD_VAR 0 2
75121: ARRAY
75122: PPUSH
75123: LD_INT 22
75125: PUSH
75126: LD_VAR 0 5
75130: PUSH
75131: EMPTY
75132: LIST
75133: LIST
75134: PUSH
75135: LD_INT 21
75137: PUSH
75138: LD_INT 2
75140: PUSH
75141: EMPTY
75142: LIST
75143: LIST
75144: PUSH
75145: LD_INT 3
75147: PUSH
75148: LD_INT 24
75150: PUSH
75151: LD_INT 1000
75153: PUSH
75154: EMPTY
75155: LIST
75156: LIST
75157: PUSH
75158: EMPTY
75159: LIST
75160: LIST
75161: PUSH
75162: EMPTY
75163: LIST
75164: LIST
75165: LIST
75166: PPUSH
75167: CALL_OW 70
75171: ST_TO_ADDR
// for j in fac do
75172: LD_ADDR_VAR 0 3
75176: PUSH
75177: LD_VAR 0 6
75181: PUSH
75182: FOR_IN
75183: IFFALSE 75264
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75185: LD_ADDR_VAR 0 7
75189: PUSH
75190: LD_VAR 0 7
75194: PUSH
75195: LD_INT 22
75197: PUSH
75198: LD_VAR 0 5
75202: PUSH
75203: EMPTY
75204: LIST
75205: LIST
75206: PUSH
75207: LD_INT 91
75209: PUSH
75210: LD_VAR 0 3
75214: PUSH
75215: LD_INT 15
75217: PUSH
75218: EMPTY
75219: LIST
75220: LIST
75221: LIST
75222: PUSH
75223: LD_INT 21
75225: PUSH
75226: LD_INT 2
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PUSH
75233: LD_INT 3
75235: PUSH
75236: LD_INT 24
75238: PUSH
75239: LD_INT 1000
75241: PUSH
75242: EMPTY
75243: LIST
75244: LIST
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: LIST
75254: LIST
75255: PPUSH
75256: CALL_OW 69
75260: UNION
75261: ST_TO_ADDR
75262: GO 75182
75264: POP
75265: POP
// if not vehs then
75266: LD_VAR 0 7
75270: NOT
75271: IFFALSE 75297
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
75273: LD_ADDR_EXP 71
75277: PUSH
75278: LD_EXP 71
75282: PPUSH
75283: LD_VAR 0 2
75287: PPUSH
75288: EMPTY
75289: PPUSH
75290: CALL_OW 1
75294: ST_TO_ADDR
// continue ;
75295: GO 74955
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75297: LD_ADDR_VAR 0 8
75301: PUSH
75302: LD_EXP 59
75306: PUSH
75307: LD_VAR 0 2
75311: ARRAY
75312: PPUSH
75313: LD_INT 30
75315: PUSH
75316: LD_INT 3
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PPUSH
75323: CALL_OW 72
75327: ST_TO_ADDR
// if tmp then
75328: LD_VAR 0 8
75332: IFFALSE 75435
// begin for j in tmp do
75334: LD_ADDR_VAR 0 3
75338: PUSH
75339: LD_VAR 0 8
75343: PUSH
75344: FOR_IN
75345: IFFALSE 75433
// for k in UnitsInside ( j ) do
75347: LD_ADDR_VAR 0 4
75351: PUSH
75352: LD_VAR 0 3
75356: PPUSH
75357: CALL_OW 313
75361: PUSH
75362: FOR_IN
75363: IFFALSE 75429
// if k then
75365: LD_VAR 0 4
75369: IFFALSE 75427
// if not k in mc_repair_vehicle [ i ] then
75371: LD_VAR 0 4
75375: PUSH
75376: LD_EXP 71
75380: PUSH
75381: LD_VAR 0 2
75385: ARRAY
75386: IN
75387: NOT
75388: IFFALSE 75427
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
75390: LD_ADDR_EXP 71
75394: PUSH
75395: LD_EXP 71
75399: PPUSH
75400: LD_VAR 0 2
75404: PPUSH
75405: LD_EXP 71
75409: PUSH
75410: LD_VAR 0 2
75414: ARRAY
75415: PUSH
75416: LD_VAR 0 4
75420: UNION
75421: PPUSH
75422: CALL_OW 1
75426: ST_TO_ADDR
75427: GO 75362
75429: POP
75430: POP
75431: GO 75344
75433: POP
75434: POP
// end ; if not mc_repair_vehicle [ i ] then
75435: LD_EXP 71
75439: PUSH
75440: LD_VAR 0 2
75444: ARRAY
75445: NOT
75446: IFFALSE 75450
// continue ;
75448: GO 74955
// for j in mc_repair_vehicle [ i ] do
75450: LD_ADDR_VAR 0 3
75454: PUSH
75455: LD_EXP 71
75459: PUSH
75460: LD_VAR 0 2
75464: ARRAY
75465: PUSH
75466: FOR_IN
75467: IFFALSE 75633
// begin if GetClass ( j ) <> 3 then
75469: LD_VAR 0 3
75473: PPUSH
75474: CALL_OW 257
75478: PUSH
75479: LD_INT 3
75481: NONEQUAL
75482: IFFALSE 75523
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
75484: LD_ADDR_EXP 71
75488: PUSH
75489: LD_EXP 71
75493: PPUSH
75494: LD_VAR 0 2
75498: PPUSH
75499: LD_EXP 71
75503: PUSH
75504: LD_VAR 0 2
75508: ARRAY
75509: PUSH
75510: LD_VAR 0 3
75514: DIFF
75515: PPUSH
75516: CALL_OW 1
75520: ST_TO_ADDR
// continue ;
75521: GO 75466
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75523: LD_VAR 0 3
75527: PPUSH
75528: CALL_OW 311
75532: NOT
75533: PUSH
75534: LD_VAR 0 3
75538: PUSH
75539: LD_EXP 62
75543: PUSH
75544: LD_VAR 0 2
75548: ARRAY
75549: PUSH
75550: LD_INT 1
75552: ARRAY
75553: IN
75554: NOT
75555: AND
75556: PUSH
75557: LD_VAR 0 3
75561: PUSH
75562: LD_EXP 62
75566: PUSH
75567: LD_VAR 0 2
75571: ARRAY
75572: PUSH
75573: LD_INT 2
75575: ARRAY
75576: IN
75577: NOT
75578: AND
75579: IFFALSE 75631
// begin if IsInUnit ( j ) then
75581: LD_VAR 0 3
75585: PPUSH
75586: CALL_OW 310
75590: IFFALSE 75601
// ComExitBuilding ( j ) ;
75592: LD_VAR 0 3
75596: PPUSH
75597: CALL_OW 122
// if not HasTask ( j ) then
75601: LD_VAR 0 3
75605: PPUSH
75606: CALL_OW 314
75610: NOT
75611: IFFALSE 75631
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
75613: LD_VAR 0 3
75617: PPUSH
75618: LD_VAR 0 7
75622: PUSH
75623: LD_INT 1
75625: ARRAY
75626: PPUSH
75627: CALL_OW 189
// end ; end ;
75631: GO 75466
75633: POP
75634: POP
// end ;
75635: GO 74955
75637: POP
75638: POP
// end ;
75639: LD_VAR 0 1
75643: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75644: LD_INT 0
75646: PPUSH
75647: PPUSH
75648: PPUSH
75649: PPUSH
75650: PPUSH
75651: PPUSH
75652: PPUSH
75653: PPUSH
75654: PPUSH
75655: PPUSH
75656: PPUSH
// if not mc_bases then
75657: LD_EXP 59
75661: NOT
75662: IFFALSE 75666
// exit ;
75664: GO 76468
// for i = 1 to mc_bases do
75666: LD_ADDR_VAR 0 2
75670: PUSH
75671: DOUBLE
75672: LD_INT 1
75674: DEC
75675: ST_TO_ADDR
75676: LD_EXP 59
75680: PUSH
75681: FOR_TO
75682: IFFALSE 76466
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75684: LD_EXP 87
75688: PUSH
75689: LD_VAR 0 2
75693: ARRAY
75694: NOT
75695: PUSH
75696: LD_EXP 62
75700: PUSH
75701: LD_VAR 0 2
75705: ARRAY
75706: PUSH
75707: LD_INT 1
75709: ARRAY
75710: OR
75711: PUSH
75712: LD_EXP 62
75716: PUSH
75717: LD_VAR 0 2
75721: ARRAY
75722: PUSH
75723: LD_INT 2
75725: ARRAY
75726: OR
75727: PUSH
75728: LD_EXP 85
75732: PUSH
75733: LD_VAR 0 2
75737: ARRAY
75738: PPUSH
75739: LD_INT 1
75741: PPUSH
75742: CALL_OW 325
75746: NOT
75747: OR
75748: PUSH
75749: LD_EXP 82
75753: PUSH
75754: LD_VAR 0 2
75758: ARRAY
75759: OR
75760: IFFALSE 75764
// continue ;
75762: GO 75681
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75764: LD_ADDR_VAR 0 8
75768: PUSH
75769: LD_EXP 59
75773: PUSH
75774: LD_VAR 0 2
75778: ARRAY
75779: PPUSH
75780: LD_INT 25
75782: PUSH
75783: LD_INT 4
75785: PUSH
75786: EMPTY
75787: LIST
75788: LIST
75789: PUSH
75790: LD_INT 50
75792: PUSH
75793: EMPTY
75794: LIST
75795: PUSH
75796: LD_INT 3
75798: PUSH
75799: LD_INT 60
75801: PUSH
75802: EMPTY
75803: LIST
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: PUSH
75809: EMPTY
75810: LIST
75811: LIST
75812: LIST
75813: PPUSH
75814: CALL_OW 72
75818: PUSH
75819: LD_EXP 63
75823: PUSH
75824: LD_VAR 0 2
75828: ARRAY
75829: DIFF
75830: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75831: LD_ADDR_VAR 0 9
75835: PUSH
75836: LD_EXP 59
75840: PUSH
75841: LD_VAR 0 2
75845: ARRAY
75846: PPUSH
75847: LD_INT 2
75849: PUSH
75850: LD_INT 30
75852: PUSH
75853: LD_INT 0
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: PUSH
75860: LD_INT 30
75862: PUSH
75863: LD_INT 1
75865: PUSH
75866: EMPTY
75867: LIST
75868: LIST
75869: PUSH
75870: EMPTY
75871: LIST
75872: LIST
75873: LIST
75874: PPUSH
75875: CALL_OW 72
75879: ST_TO_ADDR
// if not tmp or not dep then
75880: LD_VAR 0 8
75884: NOT
75885: PUSH
75886: LD_VAR 0 9
75890: NOT
75891: OR
75892: IFFALSE 75896
// continue ;
75894: GO 75681
// side := GetSide ( tmp [ 1 ] ) ;
75896: LD_ADDR_VAR 0 11
75900: PUSH
75901: LD_VAR 0 8
75905: PUSH
75906: LD_INT 1
75908: ARRAY
75909: PPUSH
75910: CALL_OW 255
75914: ST_TO_ADDR
// dep := dep [ 1 ] ;
75915: LD_ADDR_VAR 0 9
75919: PUSH
75920: LD_VAR 0 9
75924: PUSH
75925: LD_INT 1
75927: ARRAY
75928: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75929: LD_ADDR_VAR 0 7
75933: PUSH
75934: LD_EXP 87
75938: PUSH
75939: LD_VAR 0 2
75943: ARRAY
75944: PPUSH
75945: LD_INT 22
75947: PUSH
75948: LD_INT 0
75950: PUSH
75951: EMPTY
75952: LIST
75953: LIST
75954: PUSH
75955: LD_INT 25
75957: PUSH
75958: LD_INT 12
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: EMPTY
75966: LIST
75967: LIST
75968: PPUSH
75969: CALL_OW 70
75973: PUSH
75974: LD_INT 22
75976: PUSH
75977: LD_INT 0
75979: PUSH
75980: EMPTY
75981: LIST
75982: LIST
75983: PUSH
75984: LD_INT 25
75986: PUSH
75987: LD_INT 12
75989: PUSH
75990: EMPTY
75991: LIST
75992: LIST
75993: PUSH
75994: LD_INT 91
75996: PUSH
75997: LD_VAR 0 9
76001: PUSH
76002: LD_INT 20
76004: PUSH
76005: EMPTY
76006: LIST
76007: LIST
76008: LIST
76009: PUSH
76010: EMPTY
76011: LIST
76012: LIST
76013: LIST
76014: PPUSH
76015: CALL_OW 69
76019: UNION
76020: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
76021: LD_ADDR_VAR 0 10
76025: PUSH
76026: LD_EXP 87
76030: PUSH
76031: LD_VAR 0 2
76035: ARRAY
76036: PPUSH
76037: LD_INT 81
76039: PUSH
76040: LD_VAR 0 11
76044: PUSH
76045: EMPTY
76046: LIST
76047: LIST
76048: PPUSH
76049: CALL_OW 70
76053: ST_TO_ADDR
// if not apes or danger_at_area then
76054: LD_VAR 0 7
76058: NOT
76059: PUSH
76060: LD_VAR 0 10
76064: OR
76065: IFFALSE 76115
// begin if mc_taming [ i ] then
76067: LD_EXP 90
76071: PUSH
76072: LD_VAR 0 2
76076: ARRAY
76077: IFFALSE 76113
// begin MC_Reset ( i , 121 ) ;
76079: LD_VAR 0 2
76083: PPUSH
76084: LD_INT 121
76086: PPUSH
76087: CALL 61550 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
76091: LD_ADDR_EXP 90
76095: PUSH
76096: LD_EXP 90
76100: PPUSH
76101: LD_VAR 0 2
76105: PPUSH
76106: EMPTY
76107: PPUSH
76108: CALL_OW 1
76112: ST_TO_ADDR
// end ; continue ;
76113: GO 75681
// end ; for j in tmp do
76115: LD_ADDR_VAR 0 3
76119: PUSH
76120: LD_VAR 0 8
76124: PUSH
76125: FOR_IN
76126: IFFALSE 76462
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
76128: LD_VAR 0 3
76132: PUSH
76133: LD_EXP 90
76137: PUSH
76138: LD_VAR 0 2
76142: ARRAY
76143: IN
76144: NOT
76145: PUSH
76146: LD_EXP 90
76150: PUSH
76151: LD_VAR 0 2
76155: ARRAY
76156: PUSH
76157: LD_INT 3
76159: LESS
76160: AND
76161: IFFALSE 76219
// begin SetTag ( j , 121 ) ;
76163: LD_VAR 0 3
76167: PPUSH
76168: LD_INT 121
76170: PPUSH
76171: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
76175: LD_ADDR_EXP 90
76179: PUSH
76180: LD_EXP 90
76184: PPUSH
76185: LD_VAR 0 2
76189: PUSH
76190: LD_EXP 90
76194: PUSH
76195: LD_VAR 0 2
76199: ARRAY
76200: PUSH
76201: LD_INT 1
76203: PLUS
76204: PUSH
76205: EMPTY
76206: LIST
76207: LIST
76208: PPUSH
76209: LD_VAR 0 3
76213: PPUSH
76214: CALL 21521 0 3
76218: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
76219: LD_VAR 0 3
76223: PUSH
76224: LD_EXP 90
76228: PUSH
76229: LD_VAR 0 2
76233: ARRAY
76234: IN
76235: IFFALSE 76460
// begin if GetClass ( j ) <> 4 then
76237: LD_VAR 0 3
76241: PPUSH
76242: CALL_OW 257
76246: PUSH
76247: LD_INT 4
76249: NONEQUAL
76250: IFFALSE 76303
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
76252: LD_ADDR_EXP 90
76256: PUSH
76257: LD_EXP 90
76261: PPUSH
76262: LD_VAR 0 2
76266: PPUSH
76267: LD_EXP 90
76271: PUSH
76272: LD_VAR 0 2
76276: ARRAY
76277: PUSH
76278: LD_VAR 0 3
76282: DIFF
76283: PPUSH
76284: CALL_OW 1
76288: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76289: LD_VAR 0 3
76293: PPUSH
76294: LD_INT 0
76296: PPUSH
76297: CALL_OW 109
// continue ;
76301: GO 76125
// end ; if IsInUnit ( j ) then
76303: LD_VAR 0 3
76307: PPUSH
76308: CALL_OW 310
76312: IFFALSE 76323
// ComExitBuilding ( j ) ;
76314: LD_VAR 0 3
76318: PPUSH
76319: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
76323: LD_ADDR_VAR 0 6
76327: PUSH
76328: LD_VAR 0 7
76332: PPUSH
76333: LD_VAR 0 3
76337: PPUSH
76338: CALL_OW 74
76342: ST_TO_ADDR
// if not ape then
76343: LD_VAR 0 6
76347: NOT
76348: IFFALSE 76352
// break ;
76350: GO 76462
// x := GetX ( ape ) ;
76352: LD_ADDR_VAR 0 4
76356: PUSH
76357: LD_VAR 0 6
76361: PPUSH
76362: CALL_OW 250
76366: ST_TO_ADDR
// y := GetY ( ape ) ;
76367: LD_ADDR_VAR 0 5
76371: PUSH
76372: LD_VAR 0 6
76376: PPUSH
76377: CALL_OW 251
76381: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76382: LD_VAR 0 4
76386: PPUSH
76387: LD_VAR 0 5
76391: PPUSH
76392: CALL_OW 488
76396: NOT
76397: PUSH
76398: LD_VAR 0 11
76402: PPUSH
76403: LD_VAR 0 4
76407: PPUSH
76408: LD_VAR 0 5
76412: PPUSH
76413: LD_INT 20
76415: PPUSH
76416: CALL 22417 0 4
76420: PUSH
76421: LD_INT 4
76423: ARRAY
76424: OR
76425: IFFALSE 76429
// break ;
76427: GO 76462
// if not HasTask ( j ) then
76429: LD_VAR 0 3
76433: PPUSH
76434: CALL_OW 314
76438: NOT
76439: IFFALSE 76460
// ComTameXY ( j , x , y ) ;
76441: LD_VAR 0 3
76445: PPUSH
76446: LD_VAR 0 4
76450: PPUSH
76451: LD_VAR 0 5
76455: PPUSH
76456: CALL_OW 131
// end ; end ;
76460: GO 76125
76462: POP
76463: POP
// end ;
76464: GO 75681
76466: POP
76467: POP
// end ;
76468: LD_VAR 0 1
76472: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
76473: LD_INT 0
76475: PPUSH
76476: PPUSH
76477: PPUSH
76478: PPUSH
76479: PPUSH
76480: PPUSH
76481: PPUSH
76482: PPUSH
// if not mc_bases then
76483: LD_EXP 59
76487: NOT
76488: IFFALSE 76492
// exit ;
76490: GO 77118
// for i = 1 to mc_bases do
76492: LD_ADDR_VAR 0 2
76496: PUSH
76497: DOUBLE
76498: LD_INT 1
76500: DEC
76501: ST_TO_ADDR
76502: LD_EXP 59
76506: PUSH
76507: FOR_TO
76508: IFFALSE 77116
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
76510: LD_EXP 88
76514: PUSH
76515: LD_VAR 0 2
76519: ARRAY
76520: NOT
76521: PUSH
76522: LD_EXP 88
76526: PUSH
76527: LD_VAR 0 2
76531: ARRAY
76532: PPUSH
76533: LD_INT 25
76535: PUSH
76536: LD_INT 12
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PPUSH
76543: CALL_OW 72
76547: NOT
76548: OR
76549: IFFALSE 76553
// continue ;
76551: GO 76507
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76553: LD_ADDR_VAR 0 5
76557: PUSH
76558: LD_EXP 88
76562: PUSH
76563: LD_VAR 0 2
76567: ARRAY
76568: PUSH
76569: LD_INT 1
76571: ARRAY
76572: PPUSH
76573: CALL_OW 255
76577: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76578: LD_VAR 0 5
76582: PPUSH
76583: LD_INT 2
76585: PPUSH
76586: CALL_OW 325
76590: IFFALSE 76843
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76592: LD_ADDR_VAR 0 4
76596: PUSH
76597: LD_EXP 88
76601: PUSH
76602: LD_VAR 0 2
76606: ARRAY
76607: PPUSH
76608: LD_INT 25
76610: PUSH
76611: LD_INT 16
76613: PUSH
76614: EMPTY
76615: LIST
76616: LIST
76617: PPUSH
76618: CALL_OW 72
76622: ST_TO_ADDR
// if tmp < 6 then
76623: LD_VAR 0 4
76627: PUSH
76628: LD_INT 6
76630: LESS
76631: IFFALSE 76843
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76633: LD_ADDR_VAR 0 6
76637: PUSH
76638: LD_EXP 59
76642: PUSH
76643: LD_VAR 0 2
76647: ARRAY
76648: PPUSH
76649: LD_INT 2
76651: PUSH
76652: LD_INT 30
76654: PUSH
76655: LD_INT 0
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: PUSH
76662: LD_INT 30
76664: PUSH
76665: LD_INT 1
76667: PUSH
76668: EMPTY
76669: LIST
76670: LIST
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: LIST
76676: PPUSH
76677: CALL_OW 72
76681: ST_TO_ADDR
// if depot then
76682: LD_VAR 0 6
76686: IFFALSE 76843
// begin selected := 0 ;
76688: LD_ADDR_VAR 0 7
76692: PUSH
76693: LD_INT 0
76695: ST_TO_ADDR
// for j in depot do
76696: LD_ADDR_VAR 0 3
76700: PUSH
76701: LD_VAR 0 6
76705: PUSH
76706: FOR_IN
76707: IFFALSE 76738
// begin if UnitsInside ( j ) < 6 then
76709: LD_VAR 0 3
76713: PPUSH
76714: CALL_OW 313
76718: PUSH
76719: LD_INT 6
76721: LESS
76722: IFFALSE 76736
// begin selected := j ;
76724: LD_ADDR_VAR 0 7
76728: PUSH
76729: LD_VAR 0 3
76733: ST_TO_ADDR
// break ;
76734: GO 76738
// end ; end ;
76736: GO 76706
76738: POP
76739: POP
// if selected then
76740: LD_VAR 0 7
76744: IFFALSE 76843
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76746: LD_ADDR_VAR 0 3
76750: PUSH
76751: LD_EXP 88
76755: PUSH
76756: LD_VAR 0 2
76760: ARRAY
76761: PPUSH
76762: LD_INT 25
76764: PUSH
76765: LD_INT 12
76767: PUSH
76768: EMPTY
76769: LIST
76770: LIST
76771: PPUSH
76772: CALL_OW 72
76776: PUSH
76777: FOR_IN
76778: IFFALSE 76841
// if not HasTask ( j ) then
76780: LD_VAR 0 3
76784: PPUSH
76785: CALL_OW 314
76789: NOT
76790: IFFALSE 76839
// begin if not IsInUnit ( j ) then
76792: LD_VAR 0 3
76796: PPUSH
76797: CALL_OW 310
76801: NOT
76802: IFFALSE 76818
// ComEnterUnit ( j , selected ) ;
76804: LD_VAR 0 3
76808: PPUSH
76809: LD_VAR 0 7
76813: PPUSH
76814: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76818: LD_VAR 0 3
76822: PPUSH
76823: LD_INT 16
76825: PPUSH
76826: CALL_OW 183
// AddComExitBuilding ( j ) ;
76830: LD_VAR 0 3
76834: PPUSH
76835: CALL_OW 182
// end ;
76839: GO 76777
76841: POP
76842: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76843: LD_VAR 0 5
76847: PPUSH
76848: LD_INT 11
76850: PPUSH
76851: CALL_OW 325
76855: IFFALSE 77114
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76857: LD_ADDR_VAR 0 4
76861: PUSH
76862: LD_EXP 88
76866: PUSH
76867: LD_VAR 0 2
76871: ARRAY
76872: PPUSH
76873: LD_INT 25
76875: PUSH
76876: LD_INT 16
76878: PUSH
76879: EMPTY
76880: LIST
76881: LIST
76882: PPUSH
76883: CALL_OW 72
76887: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76888: LD_VAR 0 4
76892: PUSH
76893: LD_INT 6
76895: GREATEREQUAL
76896: PUSH
76897: LD_VAR 0 5
76901: PPUSH
76902: LD_INT 2
76904: PPUSH
76905: CALL_OW 325
76909: NOT
76910: OR
76911: IFFALSE 77114
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76913: LD_ADDR_VAR 0 8
76917: PUSH
76918: LD_EXP 59
76922: PUSH
76923: LD_VAR 0 2
76927: ARRAY
76928: PPUSH
76929: LD_INT 2
76931: PUSH
76932: LD_INT 30
76934: PUSH
76935: LD_INT 4
76937: PUSH
76938: EMPTY
76939: LIST
76940: LIST
76941: PUSH
76942: LD_INT 30
76944: PUSH
76945: LD_INT 5
76947: PUSH
76948: EMPTY
76949: LIST
76950: LIST
76951: PUSH
76952: EMPTY
76953: LIST
76954: LIST
76955: LIST
76956: PPUSH
76957: CALL_OW 72
76961: ST_TO_ADDR
// if barracks then
76962: LD_VAR 0 8
76966: IFFALSE 77114
// begin selected := 0 ;
76968: LD_ADDR_VAR 0 7
76972: PUSH
76973: LD_INT 0
76975: ST_TO_ADDR
// for j in barracks do
76976: LD_ADDR_VAR 0 3
76980: PUSH
76981: LD_VAR 0 8
76985: PUSH
76986: FOR_IN
76987: IFFALSE 77018
// begin if UnitsInside ( j ) < 6 then
76989: LD_VAR 0 3
76993: PPUSH
76994: CALL_OW 313
76998: PUSH
76999: LD_INT 6
77001: LESS
77002: IFFALSE 77016
// begin selected := j ;
77004: LD_ADDR_VAR 0 7
77008: PUSH
77009: LD_VAR 0 3
77013: ST_TO_ADDR
// break ;
77014: GO 77018
// end ; end ;
77016: GO 76986
77018: POP
77019: POP
// if selected then
77020: LD_VAR 0 7
77024: IFFALSE 77114
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
77026: LD_ADDR_VAR 0 3
77030: PUSH
77031: LD_EXP 88
77035: PUSH
77036: LD_VAR 0 2
77040: ARRAY
77041: PPUSH
77042: LD_INT 25
77044: PUSH
77045: LD_INT 12
77047: PUSH
77048: EMPTY
77049: LIST
77050: LIST
77051: PPUSH
77052: CALL_OW 72
77056: PUSH
77057: FOR_IN
77058: IFFALSE 77112
// if not IsInUnit ( j ) and not HasTask ( j ) then
77060: LD_VAR 0 3
77064: PPUSH
77065: CALL_OW 310
77069: NOT
77070: PUSH
77071: LD_VAR 0 3
77075: PPUSH
77076: CALL_OW 314
77080: NOT
77081: AND
77082: IFFALSE 77110
// begin ComEnterUnit ( j , selected ) ;
77084: LD_VAR 0 3
77088: PPUSH
77089: LD_VAR 0 7
77093: PPUSH
77094: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
77098: LD_VAR 0 3
77102: PPUSH
77103: LD_INT 15
77105: PPUSH
77106: CALL_OW 183
// end ;
77110: GO 77057
77112: POP
77113: POP
// end ; end ; end ; end ; end ;
77114: GO 76507
77116: POP
77117: POP
// end ;
77118: LD_VAR 0 1
77122: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
77123: LD_INT 0
77125: PPUSH
77126: PPUSH
77127: PPUSH
77128: PPUSH
// if not mc_bases then
77129: LD_EXP 59
77133: NOT
77134: IFFALSE 77138
// exit ;
77136: GO 77316
// for i = 1 to mc_bases do
77138: LD_ADDR_VAR 0 2
77142: PUSH
77143: DOUBLE
77144: LD_INT 1
77146: DEC
77147: ST_TO_ADDR
77148: LD_EXP 59
77152: PUSH
77153: FOR_TO
77154: IFFALSE 77314
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
77156: LD_ADDR_VAR 0 4
77160: PUSH
77161: LD_EXP 59
77165: PUSH
77166: LD_VAR 0 2
77170: ARRAY
77171: PPUSH
77172: LD_INT 25
77174: PUSH
77175: LD_INT 9
77177: PUSH
77178: EMPTY
77179: LIST
77180: LIST
77181: PPUSH
77182: CALL_OW 72
77186: ST_TO_ADDR
// if not tmp then
77187: LD_VAR 0 4
77191: NOT
77192: IFFALSE 77196
// continue ;
77194: GO 77153
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
77196: LD_EXP 85
77200: PUSH
77201: LD_VAR 0 2
77205: ARRAY
77206: PPUSH
77207: LD_INT 29
77209: PPUSH
77210: CALL_OW 325
77214: NOT
77215: PUSH
77216: LD_EXP 85
77220: PUSH
77221: LD_VAR 0 2
77225: ARRAY
77226: PPUSH
77227: LD_INT 28
77229: PPUSH
77230: CALL_OW 325
77234: NOT
77235: AND
77236: IFFALSE 77240
// continue ;
77238: GO 77153
// for j in tmp do
77240: LD_ADDR_VAR 0 3
77244: PUSH
77245: LD_VAR 0 4
77249: PUSH
77250: FOR_IN
77251: IFFALSE 77310
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77253: LD_VAR 0 3
77257: PUSH
77258: LD_EXP 62
77262: PUSH
77263: LD_VAR 0 2
77267: ARRAY
77268: PUSH
77269: LD_INT 1
77271: ARRAY
77272: IN
77273: NOT
77274: PUSH
77275: LD_VAR 0 3
77279: PUSH
77280: LD_EXP 62
77284: PUSH
77285: LD_VAR 0 2
77289: ARRAY
77290: PUSH
77291: LD_INT 2
77293: ARRAY
77294: IN
77295: NOT
77296: AND
77297: IFFALSE 77308
// ComSpaceTimeShoot ( j ) ;
77299: LD_VAR 0 3
77303: PPUSH
77304: CALL 15107 0 1
77308: GO 77250
77310: POP
77311: POP
// end ;
77312: GO 77153
77314: POP
77315: POP
// end ;
77316: LD_VAR 0 1
77320: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
77321: LD_INT 0
77323: PPUSH
77324: PPUSH
77325: PPUSH
77326: PPUSH
77327: PPUSH
77328: PPUSH
77329: PPUSH
77330: PPUSH
77331: PPUSH
// if not mc_bases then
77332: LD_EXP 59
77336: NOT
77337: IFFALSE 77341
// exit ;
77339: GO 77963
// for i = 1 to mc_bases do
77341: LD_ADDR_VAR 0 2
77345: PUSH
77346: DOUBLE
77347: LD_INT 1
77349: DEC
77350: ST_TO_ADDR
77351: LD_EXP 59
77355: PUSH
77356: FOR_TO
77357: IFFALSE 77961
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
77359: LD_EXP 94
77363: PUSH
77364: LD_VAR 0 2
77368: ARRAY
77369: NOT
77370: PUSH
77371: LD_INT 38
77373: PPUSH
77374: LD_EXP 85
77378: PUSH
77379: LD_VAR 0 2
77383: ARRAY
77384: PPUSH
77385: CALL_OW 321
77389: PUSH
77390: LD_INT 2
77392: NONEQUAL
77393: OR
77394: IFFALSE 77398
// continue ;
77396: GO 77356
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
77398: LD_ADDR_VAR 0 8
77402: PUSH
77403: LD_EXP 59
77407: PUSH
77408: LD_VAR 0 2
77412: ARRAY
77413: PPUSH
77414: LD_INT 30
77416: PUSH
77417: LD_INT 34
77419: PUSH
77420: EMPTY
77421: LIST
77422: LIST
77423: PPUSH
77424: CALL_OW 72
77428: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
77429: LD_ADDR_VAR 0 9
77433: PUSH
77434: LD_EXP 59
77438: PUSH
77439: LD_VAR 0 2
77443: ARRAY
77444: PPUSH
77445: LD_INT 25
77447: PUSH
77448: LD_INT 4
77450: PUSH
77451: EMPTY
77452: LIST
77453: LIST
77454: PPUSH
77455: CALL_OW 72
77459: PPUSH
77460: LD_INT 0
77462: PPUSH
77463: CALL 54807 0 2
77467: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
77468: LD_VAR 0 9
77472: NOT
77473: PUSH
77474: LD_VAR 0 8
77478: NOT
77479: OR
77480: PUSH
77481: LD_EXP 59
77485: PUSH
77486: LD_VAR 0 2
77490: ARRAY
77491: PPUSH
77492: LD_INT 124
77494: PPUSH
77495: CALL 54807 0 2
77499: OR
77500: IFFALSE 77504
// continue ;
77502: GO 77356
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
77504: LD_EXP 95
77508: PUSH
77509: LD_VAR 0 2
77513: ARRAY
77514: PUSH
77515: LD_EXP 94
77519: PUSH
77520: LD_VAR 0 2
77524: ARRAY
77525: LESS
77526: PUSH
77527: LD_EXP 95
77531: PUSH
77532: LD_VAR 0 2
77536: ARRAY
77537: PUSH
77538: LD_VAR 0 8
77542: LESS
77543: AND
77544: IFFALSE 77959
// begin tmp := sci [ 1 ] ;
77546: LD_ADDR_VAR 0 7
77550: PUSH
77551: LD_VAR 0 9
77555: PUSH
77556: LD_INT 1
77558: ARRAY
77559: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77560: LD_VAR 0 7
77564: PPUSH
77565: LD_INT 124
77567: PPUSH
77568: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77572: LD_ADDR_VAR 0 3
77576: PUSH
77577: DOUBLE
77578: LD_EXP 94
77582: PUSH
77583: LD_VAR 0 2
77587: ARRAY
77588: INC
77589: ST_TO_ADDR
77590: LD_EXP 94
77594: PUSH
77595: LD_VAR 0 2
77599: ARRAY
77600: PUSH
77601: FOR_DOWNTO
77602: IFFALSE 77945
// begin if IsInUnit ( tmp ) then
77604: LD_VAR 0 7
77608: PPUSH
77609: CALL_OW 310
77613: IFFALSE 77624
// ComExitBuilding ( tmp ) ;
77615: LD_VAR 0 7
77619: PPUSH
77620: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77624: LD_INT 35
77626: PPUSH
77627: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77631: LD_VAR 0 7
77635: PPUSH
77636: CALL_OW 310
77640: NOT
77641: PUSH
77642: LD_VAR 0 7
77646: PPUSH
77647: CALL_OW 314
77651: NOT
77652: AND
77653: IFFALSE 77624
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77655: LD_ADDR_VAR 0 6
77659: PUSH
77660: LD_VAR 0 7
77664: PPUSH
77665: CALL_OW 250
77669: PUSH
77670: LD_VAR 0 7
77674: PPUSH
77675: CALL_OW 251
77679: PUSH
77680: EMPTY
77681: LIST
77682: LIST
77683: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77684: LD_INT 35
77686: PPUSH
77687: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77691: LD_ADDR_VAR 0 4
77695: PUSH
77696: LD_EXP 94
77700: PUSH
77701: LD_VAR 0 2
77705: ARRAY
77706: PUSH
77707: LD_VAR 0 3
77711: ARRAY
77712: PUSH
77713: LD_INT 1
77715: ARRAY
77716: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77717: LD_ADDR_VAR 0 5
77721: PUSH
77722: LD_EXP 94
77726: PUSH
77727: LD_VAR 0 2
77731: ARRAY
77732: PUSH
77733: LD_VAR 0 3
77737: ARRAY
77738: PUSH
77739: LD_INT 2
77741: ARRAY
77742: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77743: LD_VAR 0 7
77747: PPUSH
77748: LD_INT 10
77750: PPUSH
77751: CALL 24114 0 2
77755: PUSH
77756: LD_INT 4
77758: ARRAY
77759: IFFALSE 77797
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77761: LD_VAR 0 7
77765: PPUSH
77766: LD_VAR 0 6
77770: PUSH
77771: LD_INT 1
77773: ARRAY
77774: PPUSH
77775: LD_VAR 0 6
77779: PUSH
77780: LD_INT 2
77782: ARRAY
77783: PPUSH
77784: CALL_OW 111
// wait ( 0 0$10 ) ;
77788: LD_INT 350
77790: PPUSH
77791: CALL_OW 67
// end else
77795: GO 77823
// begin ComMoveXY ( tmp , x , y ) ;
77797: LD_VAR 0 7
77801: PPUSH
77802: LD_VAR 0 4
77806: PPUSH
77807: LD_VAR 0 5
77811: PPUSH
77812: CALL_OW 111
// wait ( 0 0$3 ) ;
77816: LD_INT 105
77818: PPUSH
77819: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77823: LD_VAR 0 7
77827: PPUSH
77828: LD_VAR 0 4
77832: PPUSH
77833: LD_VAR 0 5
77837: PPUSH
77838: CALL_OW 307
77842: IFFALSE 77684
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77844: LD_VAR 0 7
77848: PPUSH
77849: LD_VAR 0 4
77853: PPUSH
77854: LD_VAR 0 5
77858: PPUSH
77859: LD_VAR 0 8
77863: PUSH
77864: LD_VAR 0 3
77868: ARRAY
77869: PPUSH
77870: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77874: LD_INT 35
77876: PPUSH
77877: CALL_OW 67
// until not HasTask ( tmp ) ;
77881: LD_VAR 0 7
77885: PPUSH
77886: CALL_OW 314
77890: NOT
77891: IFFALSE 77874
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77893: LD_ADDR_EXP 95
77897: PUSH
77898: LD_EXP 95
77902: PPUSH
77903: LD_VAR 0 2
77907: PUSH
77908: LD_EXP 95
77912: PUSH
77913: LD_VAR 0 2
77917: ARRAY
77918: PUSH
77919: LD_INT 1
77921: PLUS
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PPUSH
77927: LD_VAR 0 8
77931: PUSH
77932: LD_VAR 0 3
77936: ARRAY
77937: PPUSH
77938: CALL 21521 0 3
77942: ST_TO_ADDR
// end ;
77943: GO 77601
77945: POP
77946: POP
// MC_Reset ( i , 124 ) ;
77947: LD_VAR 0 2
77951: PPUSH
77952: LD_INT 124
77954: PPUSH
77955: CALL 61550 0 2
// end ; end ;
77959: GO 77356
77961: POP
77962: POP
// end ;
77963: LD_VAR 0 1
77967: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77968: LD_INT 0
77970: PPUSH
77971: PPUSH
77972: PPUSH
// if not mc_bases then
77973: LD_EXP 59
77977: NOT
77978: IFFALSE 77982
// exit ;
77980: GO 78588
// for i = 1 to mc_bases do
77982: LD_ADDR_VAR 0 2
77986: PUSH
77987: DOUBLE
77988: LD_INT 1
77990: DEC
77991: ST_TO_ADDR
77992: LD_EXP 59
77996: PUSH
77997: FOR_TO
77998: IFFALSE 78586
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
78000: LD_ADDR_VAR 0 3
78004: PUSH
78005: LD_EXP 59
78009: PUSH
78010: LD_VAR 0 2
78014: ARRAY
78015: PPUSH
78016: LD_INT 25
78018: PUSH
78019: LD_INT 4
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: PPUSH
78026: CALL_OW 72
78030: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78031: LD_VAR 0 3
78035: NOT
78036: PUSH
78037: LD_EXP 96
78041: PUSH
78042: LD_VAR 0 2
78046: ARRAY
78047: NOT
78048: OR
78049: PUSH
78050: LD_EXP 59
78054: PUSH
78055: LD_VAR 0 2
78059: ARRAY
78060: PPUSH
78061: LD_INT 2
78063: PUSH
78064: LD_INT 30
78066: PUSH
78067: LD_INT 0
78069: PUSH
78070: EMPTY
78071: LIST
78072: LIST
78073: PUSH
78074: LD_INT 30
78076: PUSH
78077: LD_INT 1
78079: PUSH
78080: EMPTY
78081: LIST
78082: LIST
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: LIST
78088: PPUSH
78089: CALL_OW 72
78093: NOT
78094: OR
78095: IFFALSE 78145
// begin if mc_deposits_finder [ i ] then
78097: LD_EXP 97
78101: PUSH
78102: LD_VAR 0 2
78106: ARRAY
78107: IFFALSE 78143
// begin MC_Reset ( i , 125 ) ;
78109: LD_VAR 0 2
78113: PPUSH
78114: LD_INT 125
78116: PPUSH
78117: CALL 61550 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78121: LD_ADDR_EXP 97
78125: PUSH
78126: LD_EXP 97
78130: PPUSH
78131: LD_VAR 0 2
78135: PPUSH
78136: EMPTY
78137: PPUSH
78138: CALL_OW 1
78142: ST_TO_ADDR
// end ; continue ;
78143: GO 77997
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
78145: LD_EXP 96
78149: PUSH
78150: LD_VAR 0 2
78154: ARRAY
78155: PUSH
78156: LD_INT 1
78158: ARRAY
78159: PUSH
78160: LD_INT 3
78162: ARRAY
78163: PUSH
78164: LD_INT 1
78166: EQUAL
78167: PUSH
78168: LD_INT 20
78170: PPUSH
78171: LD_EXP 85
78175: PUSH
78176: LD_VAR 0 2
78180: ARRAY
78181: PPUSH
78182: CALL_OW 321
78186: PUSH
78187: LD_INT 2
78189: NONEQUAL
78190: AND
78191: IFFALSE 78241
// begin if mc_deposits_finder [ i ] then
78193: LD_EXP 97
78197: PUSH
78198: LD_VAR 0 2
78202: ARRAY
78203: IFFALSE 78239
// begin MC_Reset ( i , 125 ) ;
78205: LD_VAR 0 2
78209: PPUSH
78210: LD_INT 125
78212: PPUSH
78213: CALL 61550 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78217: LD_ADDR_EXP 97
78221: PUSH
78222: LD_EXP 97
78226: PPUSH
78227: LD_VAR 0 2
78231: PPUSH
78232: EMPTY
78233: PPUSH
78234: CALL_OW 1
78238: ST_TO_ADDR
// end ; continue ;
78239: GO 77997
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
78241: LD_EXP 96
78245: PUSH
78246: LD_VAR 0 2
78250: ARRAY
78251: PUSH
78252: LD_INT 1
78254: ARRAY
78255: PUSH
78256: LD_INT 1
78258: ARRAY
78259: PPUSH
78260: LD_EXP 96
78264: PUSH
78265: LD_VAR 0 2
78269: ARRAY
78270: PUSH
78271: LD_INT 1
78273: ARRAY
78274: PUSH
78275: LD_INT 2
78277: ARRAY
78278: PPUSH
78279: LD_EXP 85
78283: PUSH
78284: LD_VAR 0 2
78288: ARRAY
78289: PPUSH
78290: CALL_OW 440
78294: IFFALSE 78337
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
78296: LD_ADDR_EXP 96
78300: PUSH
78301: LD_EXP 96
78305: PPUSH
78306: LD_VAR 0 2
78310: PPUSH
78311: LD_EXP 96
78315: PUSH
78316: LD_VAR 0 2
78320: ARRAY
78321: PPUSH
78322: LD_INT 1
78324: PPUSH
78325: CALL_OW 3
78329: PPUSH
78330: CALL_OW 1
78334: ST_TO_ADDR
78335: GO 78584
// begin if not mc_deposits_finder [ i ] then
78337: LD_EXP 97
78341: PUSH
78342: LD_VAR 0 2
78346: ARRAY
78347: NOT
78348: IFFALSE 78400
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
78350: LD_ADDR_EXP 97
78354: PUSH
78355: LD_EXP 97
78359: PPUSH
78360: LD_VAR 0 2
78364: PPUSH
78365: LD_VAR 0 3
78369: PUSH
78370: LD_INT 1
78372: ARRAY
78373: PUSH
78374: EMPTY
78375: LIST
78376: PPUSH
78377: CALL_OW 1
78381: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
78382: LD_VAR 0 3
78386: PUSH
78387: LD_INT 1
78389: ARRAY
78390: PPUSH
78391: LD_INT 125
78393: PPUSH
78394: CALL_OW 109
// end else
78398: GO 78584
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
78400: LD_EXP 97
78404: PUSH
78405: LD_VAR 0 2
78409: ARRAY
78410: PUSH
78411: LD_INT 1
78413: ARRAY
78414: PPUSH
78415: CALL_OW 310
78419: IFFALSE 78442
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
78421: LD_EXP 97
78425: PUSH
78426: LD_VAR 0 2
78430: ARRAY
78431: PUSH
78432: LD_INT 1
78434: ARRAY
78435: PPUSH
78436: CALL_OW 122
78440: GO 78584
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
78442: LD_EXP 97
78446: PUSH
78447: LD_VAR 0 2
78451: ARRAY
78452: PUSH
78453: LD_INT 1
78455: ARRAY
78456: PPUSH
78457: CALL_OW 314
78461: NOT
78462: PUSH
78463: LD_EXP 97
78467: PUSH
78468: LD_VAR 0 2
78472: ARRAY
78473: PUSH
78474: LD_INT 1
78476: ARRAY
78477: PPUSH
78478: LD_EXP 96
78482: PUSH
78483: LD_VAR 0 2
78487: ARRAY
78488: PUSH
78489: LD_INT 1
78491: ARRAY
78492: PUSH
78493: LD_INT 1
78495: ARRAY
78496: PPUSH
78497: LD_EXP 96
78501: PUSH
78502: LD_VAR 0 2
78506: ARRAY
78507: PUSH
78508: LD_INT 1
78510: ARRAY
78511: PUSH
78512: LD_INT 2
78514: ARRAY
78515: PPUSH
78516: CALL_OW 297
78520: PUSH
78521: LD_INT 6
78523: GREATER
78524: AND
78525: IFFALSE 78584
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
78527: LD_EXP 97
78531: PUSH
78532: LD_VAR 0 2
78536: ARRAY
78537: PUSH
78538: LD_INT 1
78540: ARRAY
78541: PPUSH
78542: LD_EXP 96
78546: PUSH
78547: LD_VAR 0 2
78551: ARRAY
78552: PUSH
78553: LD_INT 1
78555: ARRAY
78556: PUSH
78557: LD_INT 1
78559: ARRAY
78560: PPUSH
78561: LD_EXP 96
78565: PUSH
78566: LD_VAR 0 2
78570: ARRAY
78571: PUSH
78572: LD_INT 1
78574: ARRAY
78575: PUSH
78576: LD_INT 2
78578: ARRAY
78579: PPUSH
78580: CALL_OW 111
// end ; end ; end ;
78584: GO 77997
78586: POP
78587: POP
// end ;
78588: LD_VAR 0 1
78592: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78593: LD_INT 0
78595: PPUSH
78596: PPUSH
78597: PPUSH
78598: PPUSH
78599: PPUSH
78600: PPUSH
78601: PPUSH
78602: PPUSH
78603: PPUSH
78604: PPUSH
78605: PPUSH
// if not mc_bases then
78606: LD_EXP 59
78610: NOT
78611: IFFALSE 78615
// exit ;
78613: GO 79555
// for i = 1 to mc_bases do
78615: LD_ADDR_VAR 0 2
78619: PUSH
78620: DOUBLE
78621: LD_INT 1
78623: DEC
78624: ST_TO_ADDR
78625: LD_EXP 59
78629: PUSH
78630: FOR_TO
78631: IFFALSE 79553
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78633: LD_EXP 59
78637: PUSH
78638: LD_VAR 0 2
78642: ARRAY
78643: NOT
78644: PUSH
78645: LD_EXP 82
78649: PUSH
78650: LD_VAR 0 2
78654: ARRAY
78655: OR
78656: IFFALSE 78660
// continue ;
78658: GO 78630
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78660: LD_ADDR_VAR 0 7
78664: PUSH
78665: LD_EXP 59
78669: PUSH
78670: LD_VAR 0 2
78674: ARRAY
78675: PUSH
78676: LD_INT 1
78678: ARRAY
78679: PPUSH
78680: CALL_OW 248
78684: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78685: LD_VAR 0 7
78689: PUSH
78690: LD_INT 3
78692: EQUAL
78693: PUSH
78694: LD_EXP 78
78698: PUSH
78699: LD_VAR 0 2
78703: ARRAY
78704: PUSH
78705: LD_EXP 81
78709: PUSH
78710: LD_VAR 0 2
78714: ARRAY
78715: UNION
78716: PPUSH
78717: LD_INT 33
78719: PUSH
78720: LD_INT 2
78722: PUSH
78723: EMPTY
78724: LIST
78725: LIST
78726: PPUSH
78727: CALL_OW 72
78731: NOT
78732: OR
78733: IFFALSE 78737
// continue ;
78735: GO 78630
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78737: LD_ADDR_VAR 0 9
78741: PUSH
78742: LD_EXP 59
78746: PUSH
78747: LD_VAR 0 2
78751: ARRAY
78752: PPUSH
78753: LD_INT 30
78755: PUSH
78756: LD_INT 36
78758: PUSH
78759: EMPTY
78760: LIST
78761: LIST
78762: PPUSH
78763: CALL_OW 72
78767: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78768: LD_ADDR_VAR 0 10
78772: PUSH
78773: LD_EXP 78
78777: PUSH
78778: LD_VAR 0 2
78782: ARRAY
78783: PPUSH
78784: LD_INT 34
78786: PUSH
78787: LD_INT 31
78789: PUSH
78790: EMPTY
78791: LIST
78792: LIST
78793: PPUSH
78794: CALL_OW 72
78798: ST_TO_ADDR
// if not cts and not mcts then
78799: LD_VAR 0 9
78803: NOT
78804: PUSH
78805: LD_VAR 0 10
78809: NOT
78810: AND
78811: IFFALSE 78815
// continue ;
78813: GO 78630
// x := cts ;
78815: LD_ADDR_VAR 0 11
78819: PUSH
78820: LD_VAR 0 9
78824: ST_TO_ADDR
// if not x then
78825: LD_VAR 0 11
78829: NOT
78830: IFFALSE 78842
// x := mcts ;
78832: LD_ADDR_VAR 0 11
78836: PUSH
78837: LD_VAR 0 10
78841: ST_TO_ADDR
// if not x then
78842: LD_VAR 0 11
78846: NOT
78847: IFFALSE 78851
// continue ;
78849: GO 78630
// if mc_remote_driver [ i ] then
78851: LD_EXP 99
78855: PUSH
78856: LD_VAR 0 2
78860: ARRAY
78861: IFFALSE 79248
// for j in mc_remote_driver [ i ] do
78863: LD_ADDR_VAR 0 3
78867: PUSH
78868: LD_EXP 99
78872: PUSH
78873: LD_VAR 0 2
78877: ARRAY
78878: PUSH
78879: FOR_IN
78880: IFFALSE 79246
// begin if GetClass ( j ) <> 3 then
78882: LD_VAR 0 3
78886: PPUSH
78887: CALL_OW 257
78891: PUSH
78892: LD_INT 3
78894: NONEQUAL
78895: IFFALSE 78948
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78897: LD_ADDR_EXP 99
78901: PUSH
78902: LD_EXP 99
78906: PPUSH
78907: LD_VAR 0 2
78911: PPUSH
78912: LD_EXP 99
78916: PUSH
78917: LD_VAR 0 2
78921: ARRAY
78922: PUSH
78923: LD_VAR 0 3
78927: DIFF
78928: PPUSH
78929: CALL_OW 1
78933: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78934: LD_VAR 0 3
78938: PPUSH
78939: LD_INT 0
78941: PPUSH
78942: CALL_OW 109
// continue ;
78946: GO 78879
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
78948: LD_EXP 78
78952: PUSH
78953: LD_VAR 0 2
78957: ARRAY
78958: PPUSH
78959: LD_INT 34
78961: PUSH
78962: LD_INT 31
78964: PUSH
78965: EMPTY
78966: LIST
78967: LIST
78968: PUSH
78969: LD_INT 58
78971: PUSH
78972: EMPTY
78973: LIST
78974: PUSH
78975: EMPTY
78976: LIST
78977: LIST
78978: PPUSH
78979: CALL_OW 72
78983: PUSH
78984: LD_VAR 0 3
78988: PPUSH
78989: CALL 54895 0 1
78993: NOT
78994: AND
78995: IFFALSE 79066
// begin if IsInUnit ( j ) then
78997: LD_VAR 0 3
79001: PPUSH
79002: CALL_OW 310
79006: IFFALSE 79017
// ComExitBuilding ( j ) ;
79008: LD_VAR 0 3
79012: PPUSH
79013: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
79017: LD_VAR 0 3
79021: PPUSH
79022: LD_EXP 78
79026: PUSH
79027: LD_VAR 0 2
79031: ARRAY
79032: PPUSH
79033: LD_INT 34
79035: PUSH
79036: LD_INT 31
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: PUSH
79043: LD_INT 58
79045: PUSH
79046: EMPTY
79047: LIST
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: PPUSH
79053: CALL_OW 72
79057: PUSH
79058: LD_INT 1
79060: ARRAY
79061: PPUSH
79062: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
79066: LD_VAR 0 3
79070: PPUSH
79071: CALL_OW 310
79075: NOT
79076: PUSH
79077: LD_VAR 0 3
79081: PPUSH
79082: CALL_OW 310
79086: PPUSH
79087: CALL_OW 266
79091: PUSH
79092: LD_INT 36
79094: NONEQUAL
79095: PUSH
79096: LD_VAR 0 3
79100: PPUSH
79101: CALL 54895 0 1
79105: NOT
79106: AND
79107: OR
79108: IFFALSE 79244
// begin if IsInUnit ( j ) then
79110: LD_VAR 0 3
79114: PPUSH
79115: CALL_OW 310
79119: IFFALSE 79130
// ComExitBuilding ( j ) ;
79121: LD_VAR 0 3
79125: PPUSH
79126: CALL_OW 122
// ct := 0 ;
79130: LD_ADDR_VAR 0 8
79134: PUSH
79135: LD_INT 0
79137: ST_TO_ADDR
// for k in x do
79138: LD_ADDR_VAR 0 4
79142: PUSH
79143: LD_VAR 0 11
79147: PUSH
79148: FOR_IN
79149: IFFALSE 79222
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
79151: LD_VAR 0 4
79155: PPUSH
79156: CALL_OW 264
79160: PUSH
79161: LD_INT 31
79163: EQUAL
79164: PUSH
79165: LD_VAR 0 4
79169: PPUSH
79170: CALL_OW 311
79174: NOT
79175: AND
79176: PUSH
79177: LD_VAR 0 4
79181: PPUSH
79182: CALL_OW 266
79186: PUSH
79187: LD_INT 36
79189: EQUAL
79190: PUSH
79191: LD_VAR 0 4
79195: PPUSH
79196: CALL_OW 313
79200: PUSH
79201: LD_INT 3
79203: LESS
79204: AND
79205: OR
79206: IFFALSE 79220
// begin ct := k ;
79208: LD_ADDR_VAR 0 8
79212: PUSH
79213: LD_VAR 0 4
79217: ST_TO_ADDR
// break ;
79218: GO 79222
// end ;
79220: GO 79148
79222: POP
79223: POP
// if ct then
79224: LD_VAR 0 8
79228: IFFALSE 79244
// ComEnterUnit ( j , ct ) ;
79230: LD_VAR 0 3
79234: PPUSH
79235: LD_VAR 0 8
79239: PPUSH
79240: CALL_OW 120
// end ; end ;
79244: GO 78879
79246: POP
79247: POP
// places := 0 ;
79248: LD_ADDR_VAR 0 5
79252: PUSH
79253: LD_INT 0
79255: ST_TO_ADDR
// for j = 1 to x do
79256: LD_ADDR_VAR 0 3
79260: PUSH
79261: DOUBLE
79262: LD_INT 1
79264: DEC
79265: ST_TO_ADDR
79266: LD_VAR 0 11
79270: PUSH
79271: FOR_TO
79272: IFFALSE 79348
// if GetWeapon ( x [ j ] ) = ar_control_tower then
79274: LD_VAR 0 11
79278: PUSH
79279: LD_VAR 0 3
79283: ARRAY
79284: PPUSH
79285: CALL_OW 264
79289: PUSH
79290: LD_INT 31
79292: EQUAL
79293: IFFALSE 79311
// places := places + 1 else
79295: LD_ADDR_VAR 0 5
79299: PUSH
79300: LD_VAR 0 5
79304: PUSH
79305: LD_INT 1
79307: PLUS
79308: ST_TO_ADDR
79309: GO 79346
// if GetBType ( x [ j ] ) = b_control_tower then
79311: LD_VAR 0 11
79315: PUSH
79316: LD_VAR 0 3
79320: ARRAY
79321: PPUSH
79322: CALL_OW 266
79326: PUSH
79327: LD_INT 36
79329: EQUAL
79330: IFFALSE 79346
// places := places + 3 ;
79332: LD_ADDR_VAR 0 5
79336: PUSH
79337: LD_VAR 0 5
79341: PUSH
79342: LD_INT 3
79344: PLUS
79345: ST_TO_ADDR
79346: GO 79271
79348: POP
79349: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
79350: LD_VAR 0 5
79354: PUSH
79355: LD_INT 0
79357: EQUAL
79358: PUSH
79359: LD_VAR 0 5
79363: PUSH
79364: LD_EXP 99
79368: PUSH
79369: LD_VAR 0 2
79373: ARRAY
79374: LESSEQUAL
79375: OR
79376: IFFALSE 79380
// continue ;
79378: GO 78630
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
79380: LD_ADDR_VAR 0 6
79384: PUSH
79385: LD_EXP 59
79389: PUSH
79390: LD_VAR 0 2
79394: ARRAY
79395: PPUSH
79396: LD_INT 25
79398: PUSH
79399: LD_INT 3
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PPUSH
79406: CALL_OW 72
79410: PUSH
79411: LD_EXP 99
79415: PUSH
79416: LD_VAR 0 2
79420: ARRAY
79421: DIFF
79422: PPUSH
79423: LD_INT 3
79425: PPUSH
79426: CALL 55795 0 2
79430: ST_TO_ADDR
// for j in tmp do
79431: LD_ADDR_VAR 0 3
79435: PUSH
79436: LD_VAR 0 6
79440: PUSH
79441: FOR_IN
79442: IFFALSE 79477
// if GetTag ( j ) > 0 then
79444: LD_VAR 0 3
79448: PPUSH
79449: CALL_OW 110
79453: PUSH
79454: LD_INT 0
79456: GREATER
79457: IFFALSE 79475
// tmp := tmp diff j ;
79459: LD_ADDR_VAR 0 6
79463: PUSH
79464: LD_VAR 0 6
79468: PUSH
79469: LD_VAR 0 3
79473: DIFF
79474: ST_TO_ADDR
79475: GO 79441
79477: POP
79478: POP
// if not tmp then
79479: LD_VAR 0 6
79483: NOT
79484: IFFALSE 79488
// continue ;
79486: GO 78630
// if places then
79488: LD_VAR 0 5
79492: IFFALSE 79551
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
79494: LD_ADDR_EXP 99
79498: PUSH
79499: LD_EXP 99
79503: PPUSH
79504: LD_VAR 0 2
79508: PPUSH
79509: LD_EXP 99
79513: PUSH
79514: LD_VAR 0 2
79518: ARRAY
79519: PUSH
79520: LD_VAR 0 6
79524: PUSH
79525: LD_INT 1
79527: ARRAY
79528: UNION
79529: PPUSH
79530: CALL_OW 1
79534: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
79535: LD_VAR 0 6
79539: PUSH
79540: LD_INT 1
79542: ARRAY
79543: PPUSH
79544: LD_INT 126
79546: PPUSH
79547: CALL_OW 109
// end ; end ;
79551: GO 78630
79553: POP
79554: POP
// end ;
79555: LD_VAR 0 1
79559: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79560: LD_INT 0
79562: PPUSH
79563: PPUSH
79564: PPUSH
79565: PPUSH
79566: PPUSH
79567: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79568: LD_VAR 0 1
79572: NOT
79573: PUSH
79574: LD_VAR 0 2
79578: NOT
79579: OR
79580: PUSH
79581: LD_VAR 0 3
79585: NOT
79586: OR
79587: PUSH
79588: LD_VAR 0 4
79592: PUSH
79593: LD_INT 1
79595: PUSH
79596: LD_INT 2
79598: PUSH
79599: LD_INT 3
79601: PUSH
79602: LD_INT 4
79604: PUSH
79605: LD_INT 5
79607: PUSH
79608: LD_INT 8
79610: PUSH
79611: LD_INT 9
79613: PUSH
79614: LD_INT 15
79616: PUSH
79617: LD_INT 16
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: LIST
79624: LIST
79625: LIST
79626: LIST
79627: LIST
79628: LIST
79629: LIST
79630: IN
79631: NOT
79632: OR
79633: IFFALSE 79637
// exit ;
79635: GO 80537
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79637: LD_ADDR_VAR 0 2
79641: PUSH
79642: LD_VAR 0 2
79646: PPUSH
79647: LD_INT 21
79649: PUSH
79650: LD_INT 3
79652: PUSH
79653: EMPTY
79654: LIST
79655: LIST
79656: PUSH
79657: LD_INT 24
79659: PUSH
79660: LD_INT 250
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PUSH
79667: EMPTY
79668: LIST
79669: LIST
79670: PPUSH
79671: CALL_OW 72
79675: ST_TO_ADDR
// case class of 1 , 15 :
79676: LD_VAR 0 4
79680: PUSH
79681: LD_INT 1
79683: DOUBLE
79684: EQUAL
79685: IFTRUE 79695
79687: LD_INT 15
79689: DOUBLE
79690: EQUAL
79691: IFTRUE 79695
79693: GO 79780
79695: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79696: LD_ADDR_VAR 0 8
79700: PUSH
79701: LD_VAR 0 2
79705: PPUSH
79706: LD_INT 2
79708: PUSH
79709: LD_INT 30
79711: PUSH
79712: LD_INT 32
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: PUSH
79719: LD_INT 30
79721: PUSH
79722: LD_INT 31
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: LIST
79733: PPUSH
79734: CALL_OW 72
79738: PUSH
79739: LD_VAR 0 2
79743: PPUSH
79744: LD_INT 2
79746: PUSH
79747: LD_INT 30
79749: PUSH
79750: LD_INT 4
79752: PUSH
79753: EMPTY
79754: LIST
79755: LIST
79756: PUSH
79757: LD_INT 30
79759: PUSH
79760: LD_INT 5
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: PUSH
79767: EMPTY
79768: LIST
79769: LIST
79770: LIST
79771: PPUSH
79772: CALL_OW 72
79776: ADD
79777: ST_TO_ADDR
79778: GO 80026
79780: LD_INT 2
79782: DOUBLE
79783: EQUAL
79784: IFTRUE 79794
79786: LD_INT 16
79788: DOUBLE
79789: EQUAL
79790: IFTRUE 79794
79792: GO 79840
79794: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79795: LD_ADDR_VAR 0 8
79799: PUSH
79800: LD_VAR 0 2
79804: PPUSH
79805: LD_INT 2
79807: PUSH
79808: LD_INT 30
79810: PUSH
79811: LD_INT 0
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: PUSH
79818: LD_INT 30
79820: PUSH
79821: LD_INT 1
79823: PUSH
79824: EMPTY
79825: LIST
79826: LIST
79827: PUSH
79828: EMPTY
79829: LIST
79830: LIST
79831: LIST
79832: PPUSH
79833: CALL_OW 72
79837: ST_TO_ADDR
79838: GO 80026
79840: LD_INT 3
79842: DOUBLE
79843: EQUAL
79844: IFTRUE 79848
79846: GO 79894
79848: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79849: LD_ADDR_VAR 0 8
79853: PUSH
79854: LD_VAR 0 2
79858: PPUSH
79859: LD_INT 2
79861: PUSH
79862: LD_INT 30
79864: PUSH
79865: LD_INT 2
79867: PUSH
79868: EMPTY
79869: LIST
79870: LIST
79871: PUSH
79872: LD_INT 30
79874: PUSH
79875: LD_INT 3
79877: PUSH
79878: EMPTY
79879: LIST
79880: LIST
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: LIST
79886: PPUSH
79887: CALL_OW 72
79891: ST_TO_ADDR
79892: GO 80026
79894: LD_INT 4
79896: DOUBLE
79897: EQUAL
79898: IFTRUE 79902
79900: GO 79959
79902: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79903: LD_ADDR_VAR 0 8
79907: PUSH
79908: LD_VAR 0 2
79912: PPUSH
79913: LD_INT 2
79915: PUSH
79916: LD_INT 30
79918: PUSH
79919: LD_INT 6
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: PUSH
79926: LD_INT 30
79928: PUSH
79929: LD_INT 7
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: LD_INT 30
79938: PUSH
79939: LD_INT 8
79941: PUSH
79942: EMPTY
79943: LIST
79944: LIST
79945: PUSH
79946: EMPTY
79947: LIST
79948: LIST
79949: LIST
79950: LIST
79951: PPUSH
79952: CALL_OW 72
79956: ST_TO_ADDR
79957: GO 80026
79959: LD_INT 5
79961: DOUBLE
79962: EQUAL
79963: IFTRUE 79979
79965: LD_INT 8
79967: DOUBLE
79968: EQUAL
79969: IFTRUE 79979
79971: LD_INT 9
79973: DOUBLE
79974: EQUAL
79975: IFTRUE 79979
79977: GO 80025
79979: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79980: LD_ADDR_VAR 0 8
79984: PUSH
79985: LD_VAR 0 2
79989: PPUSH
79990: LD_INT 2
79992: PUSH
79993: LD_INT 30
79995: PUSH
79996: LD_INT 4
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: PUSH
80003: LD_INT 30
80005: PUSH
80006: LD_INT 5
80008: PUSH
80009: EMPTY
80010: LIST
80011: LIST
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: LIST
80017: PPUSH
80018: CALL_OW 72
80022: ST_TO_ADDR
80023: GO 80026
80025: POP
// if not tmp then
80026: LD_VAR 0 8
80030: NOT
80031: IFFALSE 80035
// exit ;
80033: GO 80537
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
80035: LD_VAR 0 4
80039: PUSH
80040: LD_INT 1
80042: PUSH
80043: LD_INT 15
80045: PUSH
80046: EMPTY
80047: LIST
80048: LIST
80049: IN
80050: PUSH
80051: LD_EXP 68
80055: PUSH
80056: LD_VAR 0 1
80060: ARRAY
80061: AND
80062: IFFALSE 80218
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
80064: LD_ADDR_VAR 0 9
80068: PUSH
80069: LD_EXP 68
80073: PUSH
80074: LD_VAR 0 1
80078: ARRAY
80079: PUSH
80080: LD_INT 1
80082: ARRAY
80083: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
80084: LD_VAR 0 9
80088: PUSH
80089: LD_EXP 69
80093: PUSH
80094: LD_VAR 0 1
80098: ARRAY
80099: IN
80100: NOT
80101: IFFALSE 80216
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
80103: LD_ADDR_EXP 69
80107: PUSH
80108: LD_EXP 69
80112: PPUSH
80113: LD_VAR 0 1
80117: PUSH
80118: LD_EXP 69
80122: PUSH
80123: LD_VAR 0 1
80127: ARRAY
80128: PUSH
80129: LD_INT 1
80131: PLUS
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: PPUSH
80137: LD_VAR 0 9
80141: PPUSH
80142: CALL 21521 0 3
80146: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
80147: LD_ADDR_EXP 68
80151: PUSH
80152: LD_EXP 68
80156: PPUSH
80157: LD_VAR 0 1
80161: PPUSH
80162: LD_EXP 68
80166: PUSH
80167: LD_VAR 0 1
80171: ARRAY
80172: PUSH
80173: LD_VAR 0 9
80177: DIFF
80178: PPUSH
80179: CALL_OW 1
80183: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
80184: LD_VAR 0 3
80188: PPUSH
80189: LD_EXP 69
80193: PUSH
80194: LD_VAR 0 1
80198: ARRAY
80199: PUSH
80200: LD_EXP 69
80204: PUSH
80205: LD_VAR 0 1
80209: ARRAY
80210: ARRAY
80211: PPUSH
80212: CALL_OW 120
// end ; exit ;
80216: GO 80537
// end ; if tmp > 1 then
80218: LD_VAR 0 8
80222: PUSH
80223: LD_INT 1
80225: GREATER
80226: IFFALSE 80330
// for i = 2 to tmp do
80228: LD_ADDR_VAR 0 6
80232: PUSH
80233: DOUBLE
80234: LD_INT 2
80236: DEC
80237: ST_TO_ADDR
80238: LD_VAR 0 8
80242: PUSH
80243: FOR_TO
80244: IFFALSE 80328
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
80246: LD_VAR 0 8
80250: PUSH
80251: LD_VAR 0 6
80255: ARRAY
80256: PPUSH
80257: CALL_OW 461
80261: PUSH
80262: LD_INT 6
80264: EQUAL
80265: IFFALSE 80326
// begin x := tmp [ i ] ;
80267: LD_ADDR_VAR 0 9
80271: PUSH
80272: LD_VAR 0 8
80276: PUSH
80277: LD_VAR 0 6
80281: ARRAY
80282: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
80283: LD_ADDR_VAR 0 8
80287: PUSH
80288: LD_VAR 0 8
80292: PPUSH
80293: LD_VAR 0 6
80297: PPUSH
80298: CALL_OW 3
80302: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
80303: LD_ADDR_VAR 0 8
80307: PUSH
80308: LD_VAR 0 8
80312: PPUSH
80313: LD_INT 1
80315: PPUSH
80316: LD_VAR 0 9
80320: PPUSH
80321: CALL_OW 2
80325: ST_TO_ADDR
// end ;
80326: GO 80243
80328: POP
80329: POP
// for i in tmp do
80330: LD_ADDR_VAR 0 6
80334: PUSH
80335: LD_VAR 0 8
80339: PUSH
80340: FOR_IN
80341: IFFALSE 80410
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
80343: LD_VAR 0 6
80347: PPUSH
80348: CALL_OW 313
80352: PUSH
80353: LD_INT 6
80355: LESS
80356: PUSH
80357: LD_VAR 0 6
80361: PPUSH
80362: CALL_OW 266
80366: PUSH
80367: LD_INT 31
80369: PUSH
80370: LD_INT 32
80372: PUSH
80373: EMPTY
80374: LIST
80375: LIST
80376: IN
80377: NOT
80378: AND
80379: PUSH
80380: LD_VAR 0 6
80384: PPUSH
80385: CALL_OW 313
80389: PUSH
80390: LD_INT 0
80392: EQUAL
80393: OR
80394: IFFALSE 80408
// begin j := i ;
80396: LD_ADDR_VAR 0 7
80400: PUSH
80401: LD_VAR 0 6
80405: ST_TO_ADDR
// break ;
80406: GO 80410
// end ; end ;
80408: GO 80340
80410: POP
80411: POP
// if j then
80412: LD_VAR 0 7
80416: IFFALSE 80434
// ComEnterUnit ( unit , j ) else
80418: LD_VAR 0 3
80422: PPUSH
80423: LD_VAR 0 7
80427: PPUSH
80428: CALL_OW 120
80432: GO 80537
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80434: LD_ADDR_VAR 0 10
80438: PUSH
80439: LD_VAR 0 2
80443: PPUSH
80444: LD_INT 2
80446: PUSH
80447: LD_INT 30
80449: PUSH
80450: LD_INT 0
80452: PUSH
80453: EMPTY
80454: LIST
80455: LIST
80456: PUSH
80457: LD_INT 30
80459: PUSH
80460: LD_INT 1
80462: PUSH
80463: EMPTY
80464: LIST
80465: LIST
80466: PUSH
80467: EMPTY
80468: LIST
80469: LIST
80470: LIST
80471: PPUSH
80472: CALL_OW 72
80476: ST_TO_ADDR
// if depot then
80477: LD_VAR 0 10
80481: IFFALSE 80537
// begin depot := NearestUnitToUnit ( depot , unit ) ;
80483: LD_ADDR_VAR 0 10
80487: PUSH
80488: LD_VAR 0 10
80492: PPUSH
80493: LD_VAR 0 3
80497: PPUSH
80498: CALL_OW 74
80502: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
80503: LD_VAR 0 3
80507: PPUSH
80508: LD_VAR 0 10
80512: PPUSH
80513: CALL_OW 296
80517: PUSH
80518: LD_INT 10
80520: GREATER
80521: IFFALSE 80537
// ComStandNearbyBuilding ( unit , depot ) ;
80523: LD_VAR 0 3
80527: PPUSH
80528: LD_VAR 0 10
80532: PPUSH
80533: CALL 15724 0 2
// end ; end ; end ;
80537: LD_VAR 0 5
80541: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
80542: LD_INT 0
80544: PPUSH
80545: PPUSH
80546: PPUSH
80547: PPUSH
// if not mc_bases then
80548: LD_EXP 59
80552: NOT
80553: IFFALSE 80557
// exit ;
80555: GO 80796
// for i = 1 to mc_bases do
80557: LD_ADDR_VAR 0 2
80561: PUSH
80562: DOUBLE
80563: LD_INT 1
80565: DEC
80566: ST_TO_ADDR
80567: LD_EXP 59
80571: PUSH
80572: FOR_TO
80573: IFFALSE 80794
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80575: LD_ADDR_VAR 0 4
80579: PUSH
80580: LD_EXP 59
80584: PUSH
80585: LD_VAR 0 2
80589: ARRAY
80590: PPUSH
80591: LD_INT 21
80593: PUSH
80594: LD_INT 1
80596: PUSH
80597: EMPTY
80598: LIST
80599: LIST
80600: PPUSH
80601: CALL_OW 72
80605: PUSH
80606: LD_EXP 88
80610: PUSH
80611: LD_VAR 0 2
80615: ARRAY
80616: UNION
80617: ST_TO_ADDR
// if not tmp then
80618: LD_VAR 0 4
80622: NOT
80623: IFFALSE 80627
// continue ;
80625: GO 80572
// for j in tmp do
80627: LD_ADDR_VAR 0 3
80631: PUSH
80632: LD_VAR 0 4
80636: PUSH
80637: FOR_IN
80638: IFFALSE 80790
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80640: LD_VAR 0 3
80644: PPUSH
80645: CALL_OW 110
80649: NOT
80650: PUSH
80651: LD_VAR 0 3
80655: PPUSH
80656: CALL_OW 314
80660: NOT
80661: AND
80662: PUSH
80663: LD_VAR 0 3
80667: PPUSH
80668: CALL_OW 311
80672: NOT
80673: AND
80674: PUSH
80675: LD_VAR 0 3
80679: PPUSH
80680: CALL_OW 310
80684: NOT
80685: AND
80686: PUSH
80687: LD_VAR 0 3
80691: PUSH
80692: LD_EXP 62
80696: PUSH
80697: LD_VAR 0 2
80701: ARRAY
80702: PUSH
80703: LD_INT 1
80705: ARRAY
80706: IN
80707: NOT
80708: AND
80709: PUSH
80710: LD_VAR 0 3
80714: PUSH
80715: LD_EXP 62
80719: PUSH
80720: LD_VAR 0 2
80724: ARRAY
80725: PUSH
80726: LD_INT 2
80728: ARRAY
80729: IN
80730: NOT
80731: AND
80732: PUSH
80733: LD_VAR 0 3
80737: PUSH
80738: LD_EXP 71
80742: PUSH
80743: LD_VAR 0 2
80747: ARRAY
80748: IN
80749: NOT
80750: AND
80751: IFFALSE 80788
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80753: LD_VAR 0 2
80757: PPUSH
80758: LD_EXP 59
80762: PUSH
80763: LD_VAR 0 2
80767: ARRAY
80768: PPUSH
80769: LD_VAR 0 3
80773: PPUSH
80774: LD_VAR 0 3
80778: PPUSH
80779: CALL_OW 257
80783: PPUSH
80784: CALL 79560 0 4
// end ;
80788: GO 80637
80790: POP
80791: POP
// end ;
80792: GO 80572
80794: POP
80795: POP
// end ;
80796: LD_VAR 0 1
80800: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
80801: LD_INT 0
80803: PPUSH
80804: PPUSH
80805: PPUSH
80806: PPUSH
80807: PPUSH
80808: PPUSH
// if not mc_bases [ base ] then
80809: LD_EXP 59
80813: PUSH
80814: LD_VAR 0 1
80818: ARRAY
80819: NOT
80820: IFFALSE 80824
// exit ;
80822: GO 81006
// tmp := [ ] ;
80824: LD_ADDR_VAR 0 6
80828: PUSH
80829: EMPTY
80830: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80831: LD_ADDR_VAR 0 7
80835: PUSH
80836: LD_VAR 0 3
80840: PPUSH
80841: LD_INT 0
80843: PPUSH
80844: CALL_OW 517
80848: ST_TO_ADDR
// if not list then
80849: LD_VAR 0 7
80853: NOT
80854: IFFALSE 80858
// exit ;
80856: GO 81006
// for i = 1 to amount do
80858: LD_ADDR_VAR 0 5
80862: PUSH
80863: DOUBLE
80864: LD_INT 1
80866: DEC
80867: ST_TO_ADDR
80868: LD_VAR 0 2
80872: PUSH
80873: FOR_TO
80874: IFFALSE 80954
// begin x := rand ( 1 , list [ 1 ] ) ;
80876: LD_ADDR_VAR 0 8
80880: PUSH
80881: LD_INT 1
80883: PPUSH
80884: LD_VAR 0 7
80888: PUSH
80889: LD_INT 1
80891: ARRAY
80892: PPUSH
80893: CALL_OW 12
80897: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
80898: LD_ADDR_VAR 0 6
80902: PUSH
80903: LD_VAR 0 6
80907: PPUSH
80908: LD_VAR 0 5
80912: PPUSH
80913: LD_VAR 0 7
80917: PUSH
80918: LD_INT 1
80920: ARRAY
80921: PUSH
80922: LD_VAR 0 8
80926: ARRAY
80927: PUSH
80928: LD_VAR 0 7
80932: PUSH
80933: LD_INT 2
80935: ARRAY
80936: PUSH
80937: LD_VAR 0 8
80941: ARRAY
80942: PUSH
80943: EMPTY
80944: LIST
80945: LIST
80946: PPUSH
80947: CALL_OW 1
80951: ST_TO_ADDR
// end ;
80952: GO 80873
80954: POP
80955: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80956: LD_ADDR_EXP 72
80960: PUSH
80961: LD_EXP 72
80965: PPUSH
80966: LD_VAR 0 1
80970: PPUSH
80971: LD_VAR 0 6
80975: PPUSH
80976: CALL_OW 1
80980: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80981: LD_ADDR_EXP 74
80985: PUSH
80986: LD_EXP 74
80990: PPUSH
80991: LD_VAR 0 1
80995: PPUSH
80996: LD_VAR 0 3
81000: PPUSH
81001: CALL_OW 1
81005: ST_TO_ADDR
// end ;
81006: LD_VAR 0 4
81010: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
81011: LD_INT 0
81013: PPUSH
// if not mc_bases [ base ] then
81014: LD_EXP 59
81018: PUSH
81019: LD_VAR 0 1
81023: ARRAY
81024: NOT
81025: IFFALSE 81029
// exit ;
81027: GO 81054
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
81029: LD_ADDR_EXP 64
81033: PUSH
81034: LD_EXP 64
81038: PPUSH
81039: LD_VAR 0 1
81043: PPUSH
81044: LD_VAR 0 2
81048: PPUSH
81049: CALL_OW 1
81053: ST_TO_ADDR
// end ;
81054: LD_VAR 0 3
81058: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
81059: LD_INT 0
81061: PPUSH
// if not mc_bases [ base ] then
81062: LD_EXP 59
81066: PUSH
81067: LD_VAR 0 1
81071: ARRAY
81072: NOT
81073: IFFALSE 81077
// exit ;
81075: GO 81114
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
81077: LD_ADDR_EXP 64
81081: PUSH
81082: LD_EXP 64
81086: PPUSH
81087: LD_VAR 0 1
81091: PPUSH
81092: LD_EXP 64
81096: PUSH
81097: LD_VAR 0 1
81101: ARRAY
81102: PUSH
81103: LD_VAR 0 2
81107: UNION
81108: PPUSH
81109: CALL_OW 1
81113: ST_TO_ADDR
// end ;
81114: LD_VAR 0 3
81118: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
81119: LD_INT 0
81121: PPUSH
// if not mc_bases [ base ] then
81122: LD_EXP 59
81126: PUSH
81127: LD_VAR 0 1
81131: ARRAY
81132: NOT
81133: IFFALSE 81137
// exit ;
81135: GO 81162
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
81137: LD_ADDR_EXP 80
81141: PUSH
81142: LD_EXP 80
81146: PPUSH
81147: LD_VAR 0 1
81151: PPUSH
81152: LD_VAR 0 2
81156: PPUSH
81157: CALL_OW 1
81161: ST_TO_ADDR
// end ;
81162: LD_VAR 0 3
81166: RET
// export function MC_InsertProduceList ( base , components ) ; begin
81167: LD_INT 0
81169: PPUSH
// if not mc_bases [ base ] then
81170: LD_EXP 59
81174: PUSH
81175: LD_VAR 0 1
81179: ARRAY
81180: NOT
81181: IFFALSE 81185
// exit ;
81183: GO 81222
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
81185: LD_ADDR_EXP 80
81189: PUSH
81190: LD_EXP 80
81194: PPUSH
81195: LD_VAR 0 1
81199: PPUSH
81200: LD_EXP 80
81204: PUSH
81205: LD_VAR 0 1
81209: ARRAY
81210: PUSH
81211: LD_VAR 0 2
81215: ADD
81216: PPUSH
81217: CALL_OW 1
81221: ST_TO_ADDR
// end ;
81222: LD_VAR 0 3
81226: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
81227: LD_INT 0
81229: PPUSH
// if not mc_bases [ base ] then
81230: LD_EXP 59
81234: PUSH
81235: LD_VAR 0 1
81239: ARRAY
81240: NOT
81241: IFFALSE 81245
// exit ;
81243: GO 81299
// mc_defender := Replace ( mc_defender , base , deflist ) ;
81245: LD_ADDR_EXP 81
81249: PUSH
81250: LD_EXP 81
81254: PPUSH
81255: LD_VAR 0 1
81259: PPUSH
81260: LD_VAR 0 2
81264: PPUSH
81265: CALL_OW 1
81269: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
81270: LD_ADDR_EXP 70
81274: PUSH
81275: LD_EXP 70
81279: PPUSH
81280: LD_VAR 0 1
81284: PPUSH
81285: LD_VAR 0 2
81289: PUSH
81290: LD_INT 0
81292: PLUS
81293: PPUSH
81294: CALL_OW 1
81298: ST_TO_ADDR
// end ;
81299: LD_VAR 0 3
81303: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
81304: LD_INT 0
81306: PPUSH
// if not mc_bases [ base ] then
81307: LD_EXP 59
81311: PUSH
81312: LD_VAR 0 1
81316: ARRAY
81317: NOT
81318: IFFALSE 81322
// exit ;
81320: GO 81347
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
81322: LD_ADDR_EXP 70
81326: PUSH
81327: LD_EXP 70
81331: PPUSH
81332: LD_VAR 0 1
81336: PPUSH
81337: LD_VAR 0 2
81341: PPUSH
81342: CALL_OW 1
81346: ST_TO_ADDR
// end ;
81347: LD_VAR 0 3
81351: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
81352: LD_INT 0
81354: PPUSH
81355: PPUSH
81356: PPUSH
81357: PPUSH
// if not mc_bases [ base ] then
81358: LD_EXP 59
81362: PUSH
81363: LD_VAR 0 1
81367: ARRAY
81368: NOT
81369: IFFALSE 81373
// exit ;
81371: GO 81438
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
81373: LD_ADDR_EXP 79
81377: PUSH
81378: LD_EXP 79
81382: PPUSH
81383: LD_VAR 0 1
81387: PUSH
81388: LD_EXP 79
81392: PUSH
81393: LD_VAR 0 1
81397: ARRAY
81398: PUSH
81399: LD_INT 1
81401: PLUS
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: PPUSH
81407: LD_VAR 0 1
81411: PUSH
81412: LD_VAR 0 2
81416: PUSH
81417: LD_VAR 0 3
81421: PUSH
81422: LD_VAR 0 4
81426: PUSH
81427: EMPTY
81428: LIST
81429: LIST
81430: LIST
81431: LIST
81432: PPUSH
81433: CALL 21521 0 3
81437: ST_TO_ADDR
// end ;
81438: LD_VAR 0 5
81442: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
81443: LD_INT 0
81445: PPUSH
// if not mc_bases [ base ] then
81446: LD_EXP 59
81450: PUSH
81451: LD_VAR 0 1
81455: ARRAY
81456: NOT
81457: IFFALSE 81461
// exit ;
81459: GO 81486
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
81461: LD_ADDR_EXP 96
81465: PUSH
81466: LD_EXP 96
81470: PPUSH
81471: LD_VAR 0 1
81475: PPUSH
81476: LD_VAR 0 2
81480: PPUSH
81481: CALL_OW 1
81485: ST_TO_ADDR
// end ;
81486: LD_VAR 0 3
81490: RET
// export function MC_GetMinesField ( base ) ; begin
81491: LD_INT 0
81493: PPUSH
// result := mc_mines [ base ] ;
81494: LD_ADDR_VAR 0 2
81498: PUSH
81499: LD_EXP 72
81503: PUSH
81504: LD_VAR 0 1
81508: ARRAY
81509: ST_TO_ADDR
// end ;
81510: LD_VAR 0 2
81514: RET
// export function MC_GetProduceList ( base ) ; begin
81515: LD_INT 0
81517: PPUSH
// result := mc_produce [ base ] ;
81518: LD_ADDR_VAR 0 2
81522: PUSH
81523: LD_EXP 80
81527: PUSH
81528: LD_VAR 0 1
81532: ARRAY
81533: ST_TO_ADDR
// end ;
81534: LD_VAR 0 2
81538: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
81539: LD_INT 0
81541: PPUSH
81542: PPUSH
// if not mc_bases then
81543: LD_EXP 59
81547: NOT
81548: IFFALSE 81552
// exit ;
81550: GO 81617
// if mc_bases [ base ] then
81552: LD_EXP 59
81556: PUSH
81557: LD_VAR 0 1
81561: ARRAY
81562: IFFALSE 81617
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81564: LD_ADDR_VAR 0 3
81568: PUSH
81569: LD_EXP 59
81573: PUSH
81574: LD_VAR 0 1
81578: ARRAY
81579: PPUSH
81580: LD_INT 30
81582: PUSH
81583: LD_VAR 0 2
81587: PUSH
81588: EMPTY
81589: LIST
81590: LIST
81591: PPUSH
81592: CALL_OW 72
81596: ST_TO_ADDR
// if result then
81597: LD_VAR 0 3
81601: IFFALSE 81617
// result := result [ 1 ] ;
81603: LD_ADDR_VAR 0 3
81607: PUSH
81608: LD_VAR 0 3
81612: PUSH
81613: LD_INT 1
81615: ARRAY
81616: ST_TO_ADDR
// end ; end ;
81617: LD_VAR 0 3
81621: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81622: LD_INT 0
81624: PPUSH
81625: PPUSH
// if not mc_bases then
81626: LD_EXP 59
81630: NOT
81631: IFFALSE 81635
// exit ;
81633: GO 81680
// if mc_bases [ base ] then
81635: LD_EXP 59
81639: PUSH
81640: LD_VAR 0 1
81644: ARRAY
81645: IFFALSE 81680
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81647: LD_ADDR_VAR 0 3
81651: PUSH
81652: LD_EXP 59
81656: PUSH
81657: LD_VAR 0 1
81661: ARRAY
81662: PPUSH
81663: LD_INT 30
81665: PUSH
81666: LD_VAR 0 2
81670: PUSH
81671: EMPTY
81672: LIST
81673: LIST
81674: PPUSH
81675: CALL_OW 72
81679: ST_TO_ADDR
// end ;
81680: LD_VAR 0 3
81684: RET
// export function MC_SetTame ( base , area ) ; begin
81685: LD_INT 0
81687: PPUSH
// if not mc_bases or not base then
81688: LD_EXP 59
81692: NOT
81693: PUSH
81694: LD_VAR 0 1
81698: NOT
81699: OR
81700: IFFALSE 81704
// exit ;
81702: GO 81729
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81704: LD_ADDR_EXP 87
81708: PUSH
81709: LD_EXP 87
81713: PPUSH
81714: LD_VAR 0 1
81718: PPUSH
81719: LD_VAR 0 2
81723: PPUSH
81724: CALL_OW 1
81728: ST_TO_ADDR
// end ;
81729: LD_VAR 0 3
81733: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81734: LD_INT 0
81736: PPUSH
81737: PPUSH
// if not mc_bases or not base then
81738: LD_EXP 59
81742: NOT
81743: PUSH
81744: LD_VAR 0 1
81748: NOT
81749: OR
81750: IFFALSE 81754
// exit ;
81752: GO 81856
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81754: LD_ADDR_VAR 0 4
81758: PUSH
81759: LD_EXP 59
81763: PUSH
81764: LD_VAR 0 1
81768: ARRAY
81769: PPUSH
81770: LD_INT 30
81772: PUSH
81773: LD_VAR 0 2
81777: PUSH
81778: EMPTY
81779: LIST
81780: LIST
81781: PPUSH
81782: CALL_OW 72
81786: ST_TO_ADDR
// if not tmp then
81787: LD_VAR 0 4
81791: NOT
81792: IFFALSE 81796
// exit ;
81794: GO 81856
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81796: LD_ADDR_EXP 91
81800: PUSH
81801: LD_EXP 91
81805: PPUSH
81806: LD_VAR 0 1
81810: PPUSH
81811: LD_EXP 91
81815: PUSH
81816: LD_VAR 0 1
81820: ARRAY
81821: PPUSH
81822: LD_EXP 91
81826: PUSH
81827: LD_VAR 0 1
81831: ARRAY
81832: PUSH
81833: LD_INT 1
81835: PLUS
81836: PPUSH
81837: LD_VAR 0 4
81841: PUSH
81842: LD_INT 1
81844: ARRAY
81845: PPUSH
81846: CALL_OW 2
81850: PPUSH
81851: CALL_OW 1
81855: ST_TO_ADDR
// end ;
81856: LD_VAR 0 3
81860: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81861: LD_INT 0
81863: PPUSH
81864: PPUSH
// if not mc_bases or not base or not kinds then
81865: LD_EXP 59
81869: NOT
81870: PUSH
81871: LD_VAR 0 1
81875: NOT
81876: OR
81877: PUSH
81878: LD_VAR 0 2
81882: NOT
81883: OR
81884: IFFALSE 81888
// exit ;
81886: GO 81949
// for i in kinds do
81888: LD_ADDR_VAR 0 4
81892: PUSH
81893: LD_VAR 0 2
81897: PUSH
81898: FOR_IN
81899: IFFALSE 81947
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81901: LD_ADDR_EXP 93
81905: PUSH
81906: LD_EXP 93
81910: PPUSH
81911: LD_VAR 0 1
81915: PUSH
81916: LD_EXP 93
81920: PUSH
81921: LD_VAR 0 1
81925: ARRAY
81926: PUSH
81927: LD_INT 1
81929: PLUS
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: PPUSH
81935: LD_VAR 0 4
81939: PPUSH
81940: CALL 21521 0 3
81944: ST_TO_ADDR
81945: GO 81898
81947: POP
81948: POP
// end ;
81949: LD_VAR 0 3
81953: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81954: LD_INT 0
81956: PPUSH
// if not mc_bases or not base or not areas then
81957: LD_EXP 59
81961: NOT
81962: PUSH
81963: LD_VAR 0 1
81967: NOT
81968: OR
81969: PUSH
81970: LD_VAR 0 2
81974: NOT
81975: OR
81976: IFFALSE 81980
// exit ;
81978: GO 82005
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81980: LD_ADDR_EXP 77
81984: PUSH
81985: LD_EXP 77
81989: PPUSH
81990: LD_VAR 0 1
81994: PPUSH
81995: LD_VAR 0 2
81999: PPUSH
82000: CALL_OW 1
82004: ST_TO_ADDR
// end ;
82005: LD_VAR 0 3
82009: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
82010: LD_INT 0
82012: PPUSH
// if not mc_bases or not base or not teleports_exit then
82013: LD_EXP 59
82017: NOT
82018: PUSH
82019: LD_VAR 0 1
82023: NOT
82024: OR
82025: PUSH
82026: LD_VAR 0 2
82030: NOT
82031: OR
82032: IFFALSE 82036
// exit ;
82034: GO 82061
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
82036: LD_ADDR_EXP 94
82040: PUSH
82041: LD_EXP 94
82045: PPUSH
82046: LD_VAR 0 1
82050: PPUSH
82051: LD_VAR 0 2
82055: PPUSH
82056: CALL_OW 1
82060: ST_TO_ADDR
// end ;
82061: LD_VAR 0 3
82065: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
82066: LD_INT 0
82068: PPUSH
82069: PPUSH
82070: PPUSH
// if not mc_bases or not base or not ext_list then
82071: LD_EXP 59
82075: NOT
82076: PUSH
82077: LD_VAR 0 1
82081: NOT
82082: OR
82083: PUSH
82084: LD_VAR 0 5
82088: NOT
82089: OR
82090: IFFALSE 82094
// exit ;
82092: GO 82267
// tmp := GetFacExtXYD ( x , y , d ) ;
82094: LD_ADDR_VAR 0 8
82098: PUSH
82099: LD_VAR 0 2
82103: PPUSH
82104: LD_VAR 0 3
82108: PPUSH
82109: LD_VAR 0 4
82113: PPUSH
82114: CALL 54925 0 3
82118: ST_TO_ADDR
// if not tmp then
82119: LD_VAR 0 8
82123: NOT
82124: IFFALSE 82128
// exit ;
82126: GO 82267
// for i in tmp do
82128: LD_ADDR_VAR 0 7
82132: PUSH
82133: LD_VAR 0 8
82137: PUSH
82138: FOR_IN
82139: IFFALSE 82265
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
82141: LD_ADDR_EXP 64
82145: PUSH
82146: LD_EXP 64
82150: PPUSH
82151: LD_VAR 0 1
82155: PPUSH
82156: LD_EXP 64
82160: PUSH
82161: LD_VAR 0 1
82165: ARRAY
82166: PPUSH
82167: LD_EXP 64
82171: PUSH
82172: LD_VAR 0 1
82176: ARRAY
82177: PUSH
82178: LD_INT 1
82180: PLUS
82181: PPUSH
82182: LD_VAR 0 5
82186: PUSH
82187: LD_INT 1
82189: ARRAY
82190: PUSH
82191: LD_VAR 0 7
82195: PUSH
82196: LD_INT 1
82198: ARRAY
82199: PUSH
82200: LD_VAR 0 7
82204: PUSH
82205: LD_INT 2
82207: ARRAY
82208: PUSH
82209: LD_VAR 0 7
82213: PUSH
82214: LD_INT 3
82216: ARRAY
82217: PUSH
82218: EMPTY
82219: LIST
82220: LIST
82221: LIST
82222: LIST
82223: PPUSH
82224: CALL_OW 2
82228: PPUSH
82229: CALL_OW 1
82233: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
82234: LD_ADDR_VAR 0 5
82238: PUSH
82239: LD_VAR 0 5
82243: PPUSH
82244: LD_INT 1
82246: PPUSH
82247: CALL_OW 3
82251: ST_TO_ADDR
// if not ext_list then
82252: LD_VAR 0 5
82256: NOT
82257: IFFALSE 82263
// exit ;
82259: POP
82260: POP
82261: GO 82267
// end ;
82263: GO 82138
82265: POP
82266: POP
// end ;
82267: LD_VAR 0 6
82271: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
82272: LD_INT 0
82274: PPUSH
// if not mc_bases or not base or not weapon_list then
82275: LD_EXP 59
82279: NOT
82280: PUSH
82281: LD_VAR 0 1
82285: NOT
82286: OR
82287: PUSH
82288: LD_VAR 0 2
82292: NOT
82293: OR
82294: IFFALSE 82298
// exit ;
82296: GO 82323
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
82298: LD_ADDR_EXP 98
82302: PUSH
82303: LD_EXP 98
82307: PPUSH
82308: LD_VAR 0 1
82312: PPUSH
82313: LD_VAR 0 2
82317: PPUSH
82318: CALL_OW 1
82322: ST_TO_ADDR
// end ;
82323: LD_VAR 0 3
82327: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
82328: LD_INT 0
82330: PPUSH
// if not mc_bases or not base or not tech_list then
82331: LD_EXP 59
82335: NOT
82336: PUSH
82337: LD_VAR 0 1
82341: NOT
82342: OR
82343: PUSH
82344: LD_VAR 0 2
82348: NOT
82349: OR
82350: IFFALSE 82354
// exit ;
82352: GO 82379
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
82354: LD_ADDR_EXP 86
82358: PUSH
82359: LD_EXP 86
82363: PPUSH
82364: LD_VAR 0 1
82368: PPUSH
82369: LD_VAR 0 2
82373: PPUSH
82374: CALL_OW 1
82378: ST_TO_ADDR
// end ;
82379: LD_VAR 0 3
82383: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
82384: LD_INT 0
82386: PPUSH
// if not mc_bases or not parking_area or not base then
82387: LD_EXP 59
82391: NOT
82392: PUSH
82393: LD_VAR 0 2
82397: NOT
82398: OR
82399: PUSH
82400: LD_VAR 0 1
82404: NOT
82405: OR
82406: IFFALSE 82410
// exit ;
82408: GO 82435
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
82410: LD_ADDR_EXP 83
82414: PUSH
82415: LD_EXP 83
82419: PPUSH
82420: LD_VAR 0 1
82424: PPUSH
82425: LD_VAR 0 2
82429: PPUSH
82430: CALL_OW 1
82434: ST_TO_ADDR
// end ;
82435: LD_VAR 0 3
82439: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
82440: LD_INT 0
82442: PPUSH
// if not mc_bases or not base or not scan_area then
82443: LD_EXP 59
82447: NOT
82448: PUSH
82449: LD_VAR 0 1
82453: NOT
82454: OR
82455: PUSH
82456: LD_VAR 0 2
82460: NOT
82461: OR
82462: IFFALSE 82466
// exit ;
82464: GO 82491
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
82466: LD_ADDR_EXP 84
82470: PUSH
82471: LD_EXP 84
82475: PPUSH
82476: LD_VAR 0 1
82480: PPUSH
82481: LD_VAR 0 2
82485: PPUSH
82486: CALL_OW 1
82490: ST_TO_ADDR
// end ;
82491: LD_VAR 0 3
82495: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
82496: LD_INT 0
82498: PPUSH
82499: PPUSH
// if not mc_bases or not base then
82500: LD_EXP 59
82504: NOT
82505: PUSH
82506: LD_VAR 0 1
82510: NOT
82511: OR
82512: IFFALSE 82516
// exit ;
82514: GO 82580
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
82516: LD_ADDR_VAR 0 3
82520: PUSH
82521: LD_INT 1
82523: PUSH
82524: LD_INT 2
82526: PUSH
82527: LD_INT 3
82529: PUSH
82530: LD_INT 4
82532: PUSH
82533: LD_INT 11
82535: PUSH
82536: EMPTY
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
82543: LD_ADDR_EXP 86
82547: PUSH
82548: LD_EXP 86
82552: PPUSH
82553: LD_VAR 0 1
82557: PPUSH
82558: LD_EXP 86
82562: PUSH
82563: LD_VAR 0 1
82567: ARRAY
82568: PUSH
82569: LD_VAR 0 3
82573: DIFF
82574: PPUSH
82575: CALL_OW 1
82579: ST_TO_ADDR
// end ;
82580: LD_VAR 0 2
82584: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82585: LD_INT 0
82587: PPUSH
// result := mc_vehicles [ base ] ;
82588: LD_ADDR_VAR 0 3
82592: PUSH
82593: LD_EXP 78
82597: PUSH
82598: LD_VAR 0 1
82602: ARRAY
82603: ST_TO_ADDR
// if onlyCombat then
82604: LD_VAR 0 2
82608: IFFALSE 82773
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82610: LD_ADDR_VAR 0 3
82614: PUSH
82615: LD_VAR 0 3
82619: PUSH
82620: LD_VAR 0 3
82624: PPUSH
82625: LD_INT 2
82627: PUSH
82628: LD_INT 34
82630: PUSH
82631: LD_INT 12
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: LD_INT 34
82640: PUSH
82641: LD_INT 51
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: PUSH
82648: LD_INT 34
82650: PUSH
82651: LD_EXP 103
82655: PUSH
82656: EMPTY
82657: LIST
82658: LIST
82659: PUSH
82660: LD_INT 34
82662: PUSH
82663: LD_INT 32
82665: PUSH
82666: EMPTY
82667: LIST
82668: LIST
82669: PUSH
82670: LD_INT 34
82672: PUSH
82673: LD_INT 13
82675: PUSH
82676: EMPTY
82677: LIST
82678: LIST
82679: PUSH
82680: LD_INT 34
82682: PUSH
82683: LD_INT 52
82685: PUSH
82686: EMPTY
82687: LIST
82688: LIST
82689: PUSH
82690: LD_INT 34
82692: PUSH
82693: LD_INT 14
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: PUSH
82700: LD_INT 34
82702: PUSH
82703: LD_INT 53
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: PUSH
82710: LD_INT 34
82712: PUSH
82713: LD_EXP 102
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 34
82724: PUSH
82725: LD_INT 31
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PUSH
82732: LD_INT 34
82734: PUSH
82735: LD_INT 48
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 34
82744: PUSH
82745: LD_INT 8
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: LIST
82756: LIST
82757: LIST
82758: LIST
82759: LIST
82760: LIST
82761: LIST
82762: LIST
82763: LIST
82764: LIST
82765: LIST
82766: PPUSH
82767: CALL_OW 72
82771: DIFF
82772: ST_TO_ADDR
// end ; end_of_file
82773: LD_VAR 0 3
82777: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82778: LD_INT 0
82780: PPUSH
82781: PPUSH
82782: PPUSH
// if not mc_bases or not skirmish then
82783: LD_EXP 59
82787: NOT
82788: PUSH
82789: LD_EXP 57
82793: NOT
82794: OR
82795: IFFALSE 82799
// exit ;
82797: GO 82964
// for i = 1 to mc_bases do
82799: LD_ADDR_VAR 0 4
82803: PUSH
82804: DOUBLE
82805: LD_INT 1
82807: DEC
82808: ST_TO_ADDR
82809: LD_EXP 59
82813: PUSH
82814: FOR_TO
82815: IFFALSE 82962
// begin if sci in mc_bases [ i ] then
82817: LD_VAR 0 2
82821: PUSH
82822: LD_EXP 59
82826: PUSH
82827: LD_VAR 0 4
82831: ARRAY
82832: IN
82833: IFFALSE 82960
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82835: LD_ADDR_EXP 88
82839: PUSH
82840: LD_EXP 88
82844: PPUSH
82845: LD_VAR 0 4
82849: PUSH
82850: LD_EXP 88
82854: PUSH
82855: LD_VAR 0 4
82859: ARRAY
82860: PUSH
82861: LD_INT 1
82863: PLUS
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PPUSH
82869: LD_VAR 0 1
82873: PPUSH
82874: CALL 21521 0 3
82878: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82879: LD_ADDR_VAR 0 5
82883: PUSH
82884: LD_EXP 59
82888: PUSH
82889: LD_VAR 0 4
82893: ARRAY
82894: PPUSH
82895: LD_INT 2
82897: PUSH
82898: LD_INT 30
82900: PUSH
82901: LD_INT 0
82903: PUSH
82904: EMPTY
82905: LIST
82906: LIST
82907: PUSH
82908: LD_INT 30
82910: PUSH
82911: LD_INT 1
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: PUSH
82918: EMPTY
82919: LIST
82920: LIST
82921: LIST
82922: PPUSH
82923: CALL_OW 72
82927: PPUSH
82928: LD_VAR 0 1
82932: PPUSH
82933: CALL_OW 74
82937: ST_TO_ADDR
// if tmp then
82938: LD_VAR 0 5
82942: IFFALSE 82958
// ComStandNearbyBuilding ( ape , tmp ) ;
82944: LD_VAR 0 1
82948: PPUSH
82949: LD_VAR 0 5
82953: PPUSH
82954: CALL 15724 0 2
// break ;
82958: GO 82962
// end ; end ;
82960: GO 82814
82962: POP
82963: POP
// end ;
82964: LD_VAR 0 3
82968: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82969: LD_INT 0
82971: PPUSH
82972: PPUSH
82973: PPUSH
// if not mc_bases or not skirmish then
82974: LD_EXP 59
82978: NOT
82979: PUSH
82980: LD_EXP 57
82984: NOT
82985: OR
82986: IFFALSE 82990
// exit ;
82988: GO 83079
// for i = 1 to mc_bases do
82990: LD_ADDR_VAR 0 4
82994: PUSH
82995: DOUBLE
82996: LD_INT 1
82998: DEC
82999: ST_TO_ADDR
83000: LD_EXP 59
83004: PUSH
83005: FOR_TO
83006: IFFALSE 83077
// begin if building in mc_busy_turret_list [ i ] then
83008: LD_VAR 0 1
83012: PUSH
83013: LD_EXP 69
83017: PUSH
83018: LD_VAR 0 4
83022: ARRAY
83023: IN
83024: IFFALSE 83075
// begin tmp := mc_busy_turret_list [ i ] diff building ;
83026: LD_ADDR_VAR 0 5
83030: PUSH
83031: LD_EXP 69
83035: PUSH
83036: LD_VAR 0 4
83040: ARRAY
83041: PUSH
83042: LD_VAR 0 1
83046: DIFF
83047: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
83048: LD_ADDR_EXP 69
83052: PUSH
83053: LD_EXP 69
83057: PPUSH
83058: LD_VAR 0 4
83062: PPUSH
83063: LD_VAR 0 5
83067: PPUSH
83068: CALL_OW 1
83072: ST_TO_ADDR
// break ;
83073: GO 83077
// end ; end ;
83075: GO 83005
83077: POP
83078: POP
// end ;
83079: LD_VAR 0 3
83083: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
83084: LD_INT 0
83086: PPUSH
83087: PPUSH
83088: PPUSH
// if not mc_bases or not skirmish then
83089: LD_EXP 59
83093: NOT
83094: PUSH
83095: LD_EXP 57
83099: NOT
83100: OR
83101: IFFALSE 83105
// exit ;
83103: GO 83304
// for i = 1 to mc_bases do
83105: LD_ADDR_VAR 0 5
83109: PUSH
83110: DOUBLE
83111: LD_INT 1
83113: DEC
83114: ST_TO_ADDR
83115: LD_EXP 59
83119: PUSH
83120: FOR_TO
83121: IFFALSE 83302
// if building in mc_bases [ i ] then
83123: LD_VAR 0 1
83127: PUSH
83128: LD_EXP 59
83132: PUSH
83133: LD_VAR 0 5
83137: ARRAY
83138: IN
83139: IFFALSE 83300
// begin tmp := mc_bases [ i ] diff building ;
83141: LD_ADDR_VAR 0 6
83145: PUSH
83146: LD_EXP 59
83150: PUSH
83151: LD_VAR 0 5
83155: ARRAY
83156: PUSH
83157: LD_VAR 0 1
83161: DIFF
83162: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
83163: LD_ADDR_EXP 59
83167: PUSH
83168: LD_EXP 59
83172: PPUSH
83173: LD_VAR 0 5
83177: PPUSH
83178: LD_VAR 0 6
83182: PPUSH
83183: CALL_OW 1
83187: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
83188: LD_VAR 0 1
83192: PUSH
83193: LD_EXP 67
83197: PUSH
83198: LD_VAR 0 5
83202: ARRAY
83203: IN
83204: IFFALSE 83243
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
83206: LD_ADDR_EXP 67
83210: PUSH
83211: LD_EXP 67
83215: PPUSH
83216: LD_VAR 0 5
83220: PPUSH
83221: LD_EXP 67
83225: PUSH
83226: LD_VAR 0 5
83230: ARRAY
83231: PUSH
83232: LD_VAR 0 1
83236: DIFF
83237: PPUSH
83238: CALL_OW 1
83242: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
83243: LD_VAR 0 1
83247: PUSH
83248: LD_EXP 68
83252: PUSH
83253: LD_VAR 0 5
83257: ARRAY
83258: IN
83259: IFFALSE 83298
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
83261: LD_ADDR_EXP 68
83265: PUSH
83266: LD_EXP 68
83270: PPUSH
83271: LD_VAR 0 5
83275: PPUSH
83276: LD_EXP 68
83280: PUSH
83281: LD_VAR 0 5
83285: ARRAY
83286: PUSH
83287: LD_VAR 0 1
83291: DIFF
83292: PPUSH
83293: CALL_OW 1
83297: ST_TO_ADDR
// break ;
83298: GO 83302
// end ;
83300: GO 83120
83302: POP
83303: POP
// end ;
83304: LD_VAR 0 4
83308: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
83309: LD_INT 0
83311: PPUSH
83312: PPUSH
83313: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
83314: LD_EXP 59
83318: NOT
83319: PUSH
83320: LD_EXP 57
83324: NOT
83325: OR
83326: PUSH
83327: LD_VAR 0 3
83331: PUSH
83332: LD_EXP 85
83336: IN
83337: NOT
83338: OR
83339: IFFALSE 83343
// exit ;
83341: GO 83466
// for i = 1 to mc_vehicles do
83343: LD_ADDR_VAR 0 6
83347: PUSH
83348: DOUBLE
83349: LD_INT 1
83351: DEC
83352: ST_TO_ADDR
83353: LD_EXP 78
83357: PUSH
83358: FOR_TO
83359: IFFALSE 83464
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
83361: LD_VAR 0 2
83365: PUSH
83366: LD_EXP 78
83370: PUSH
83371: LD_VAR 0 6
83375: ARRAY
83376: IN
83377: PUSH
83378: LD_VAR 0 1
83382: PUSH
83383: LD_EXP 78
83387: PUSH
83388: LD_VAR 0 6
83392: ARRAY
83393: IN
83394: OR
83395: IFFALSE 83462
// begin tmp := mc_vehicles [ i ] diff old ;
83397: LD_ADDR_VAR 0 7
83401: PUSH
83402: LD_EXP 78
83406: PUSH
83407: LD_VAR 0 6
83411: ARRAY
83412: PUSH
83413: LD_VAR 0 2
83417: DIFF
83418: ST_TO_ADDR
// tmp := tmp diff new ;
83419: LD_ADDR_VAR 0 7
83423: PUSH
83424: LD_VAR 0 7
83428: PUSH
83429: LD_VAR 0 1
83433: DIFF
83434: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
83435: LD_ADDR_EXP 78
83439: PUSH
83440: LD_EXP 78
83444: PPUSH
83445: LD_VAR 0 6
83449: PPUSH
83450: LD_VAR 0 7
83454: PPUSH
83455: CALL_OW 1
83459: ST_TO_ADDR
// break ;
83460: GO 83464
// end ;
83462: GO 83358
83464: POP
83465: POP
// end ;
83466: LD_VAR 0 5
83470: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
83471: LD_INT 0
83473: PPUSH
83474: PPUSH
83475: PPUSH
83476: PPUSH
// if not mc_bases or not skirmish then
83477: LD_EXP 59
83481: NOT
83482: PUSH
83483: LD_EXP 57
83487: NOT
83488: OR
83489: IFFALSE 83493
// exit ;
83491: GO 83870
// side := GetSide ( vehicle ) ;
83493: LD_ADDR_VAR 0 5
83497: PUSH
83498: LD_VAR 0 1
83502: PPUSH
83503: CALL_OW 255
83507: ST_TO_ADDR
// for i = 1 to mc_bases do
83508: LD_ADDR_VAR 0 4
83512: PUSH
83513: DOUBLE
83514: LD_INT 1
83516: DEC
83517: ST_TO_ADDR
83518: LD_EXP 59
83522: PUSH
83523: FOR_TO
83524: IFFALSE 83868
// begin if factory in mc_bases [ i ] then
83526: LD_VAR 0 2
83530: PUSH
83531: LD_EXP 59
83535: PUSH
83536: LD_VAR 0 4
83540: ARRAY
83541: IN
83542: IFFALSE 83866
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
83544: LD_EXP 81
83548: PUSH
83549: LD_VAR 0 4
83553: ARRAY
83554: PUSH
83555: LD_EXP 70
83559: PUSH
83560: LD_VAR 0 4
83564: ARRAY
83565: LESS
83566: PUSH
83567: LD_VAR 0 1
83571: PPUSH
83572: CALL_OW 264
83576: PUSH
83577: LD_INT 31
83579: PUSH
83580: LD_INT 32
83582: PUSH
83583: LD_INT 51
83585: PUSH
83586: LD_EXP 103
83590: PUSH
83591: LD_INT 12
83593: PUSH
83594: LD_INT 30
83596: PUSH
83597: LD_EXP 102
83601: PUSH
83602: LD_INT 11
83604: PUSH
83605: LD_INT 53
83607: PUSH
83608: LD_INT 14
83610: PUSH
83611: LD_EXP 106
83615: PUSH
83616: LD_INT 29
83618: PUSH
83619: LD_EXP 104
83623: PUSH
83624: LD_INT 13
83626: PUSH
83627: LD_INT 52
83629: PUSH
83630: LD_INT 48
83632: PUSH
83633: LD_INT 8
83635: PUSH
83636: EMPTY
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: LIST
83644: LIST
83645: LIST
83646: LIST
83647: LIST
83648: LIST
83649: LIST
83650: LIST
83651: LIST
83652: LIST
83653: LIST
83654: IN
83655: NOT
83656: AND
83657: IFFALSE 83705
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83659: LD_ADDR_EXP 81
83663: PUSH
83664: LD_EXP 81
83668: PPUSH
83669: LD_VAR 0 4
83673: PUSH
83674: LD_EXP 81
83678: PUSH
83679: LD_VAR 0 4
83683: ARRAY
83684: PUSH
83685: LD_INT 1
83687: PLUS
83688: PUSH
83689: EMPTY
83690: LIST
83691: LIST
83692: PPUSH
83693: LD_VAR 0 1
83697: PPUSH
83698: CALL 21521 0 3
83702: ST_TO_ADDR
83703: GO 83749
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83705: LD_ADDR_EXP 78
83709: PUSH
83710: LD_EXP 78
83714: PPUSH
83715: LD_VAR 0 4
83719: PUSH
83720: LD_EXP 78
83724: PUSH
83725: LD_VAR 0 4
83729: ARRAY
83730: PUSH
83731: LD_INT 1
83733: PLUS
83734: PUSH
83735: EMPTY
83736: LIST
83737: LIST
83738: PPUSH
83739: LD_VAR 0 1
83743: PPUSH
83744: CALL 21521 0 3
83748: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83749: LD_VAR 0 1
83753: PPUSH
83754: CALL_OW 263
83758: PUSH
83759: LD_INT 2
83761: EQUAL
83762: IFFALSE 83782
// begin repeat wait ( 0 0$1 ) ;
83764: LD_INT 35
83766: PPUSH
83767: CALL_OW 67
// until IsControledBy ( vehicle ) ;
83771: LD_VAR 0 1
83775: PPUSH
83776: CALL_OW 312
83780: IFFALSE 83764
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83782: LD_VAR 0 1
83786: PPUSH
83787: LD_EXP 83
83791: PUSH
83792: LD_VAR 0 4
83796: ARRAY
83797: PPUSH
83798: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83802: LD_VAR 0 1
83806: PPUSH
83807: CALL_OW 263
83811: PUSH
83812: LD_INT 1
83814: NONEQUAL
83815: IFFALSE 83819
// break ;
83817: GO 83868
// repeat wait ( 0 0$1 ) ;
83819: LD_INT 35
83821: PPUSH
83822: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83826: LD_VAR 0 1
83830: PPUSH
83831: LD_EXP 83
83835: PUSH
83836: LD_VAR 0 4
83840: ARRAY
83841: PPUSH
83842: CALL_OW 308
83846: IFFALSE 83819
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83848: LD_VAR 0 1
83852: PPUSH
83853: CALL_OW 311
83857: PPUSH
83858: CALL_OW 121
// exit ;
83862: POP
83863: POP
83864: GO 83870
// end ; end ;
83866: GO 83523
83868: POP
83869: POP
// end ;
83870: LD_VAR 0 3
83874: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83875: LD_INT 0
83877: PPUSH
83878: PPUSH
83879: PPUSH
83880: PPUSH
// if not mc_bases or not skirmish then
83881: LD_EXP 59
83885: NOT
83886: PUSH
83887: LD_EXP 57
83891: NOT
83892: OR
83893: IFFALSE 83897
// exit ;
83895: GO 84250
// repeat wait ( 0 0$1 ) ;
83897: LD_INT 35
83899: PPUSH
83900: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83904: LD_VAR 0 2
83908: PPUSH
83909: LD_VAR 0 3
83913: PPUSH
83914: CALL_OW 284
83918: IFFALSE 83897
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83920: LD_VAR 0 2
83924: PPUSH
83925: LD_VAR 0 3
83929: PPUSH
83930: CALL_OW 283
83934: PUSH
83935: LD_INT 4
83937: EQUAL
83938: IFFALSE 83942
// exit ;
83940: GO 84250
// for i = 1 to mc_bases do
83942: LD_ADDR_VAR 0 7
83946: PUSH
83947: DOUBLE
83948: LD_INT 1
83950: DEC
83951: ST_TO_ADDR
83952: LD_EXP 59
83956: PUSH
83957: FOR_TO
83958: IFFALSE 84248
// begin if mc_crates_area [ i ] then
83960: LD_EXP 77
83964: PUSH
83965: LD_VAR 0 7
83969: ARRAY
83970: IFFALSE 84081
// for j in mc_crates_area [ i ] do
83972: LD_ADDR_VAR 0 8
83976: PUSH
83977: LD_EXP 77
83981: PUSH
83982: LD_VAR 0 7
83986: ARRAY
83987: PUSH
83988: FOR_IN
83989: IFFALSE 84079
// if InArea ( x , y , j ) then
83991: LD_VAR 0 2
83995: PPUSH
83996: LD_VAR 0 3
84000: PPUSH
84001: LD_VAR 0 8
84005: PPUSH
84006: CALL_OW 309
84010: IFFALSE 84077
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84012: LD_ADDR_EXP 75
84016: PUSH
84017: LD_EXP 75
84021: PPUSH
84022: LD_VAR 0 7
84026: PUSH
84027: LD_EXP 75
84031: PUSH
84032: LD_VAR 0 7
84036: ARRAY
84037: PUSH
84038: LD_INT 1
84040: PLUS
84041: PUSH
84042: EMPTY
84043: LIST
84044: LIST
84045: PPUSH
84046: LD_VAR 0 4
84050: PUSH
84051: LD_VAR 0 2
84055: PUSH
84056: LD_VAR 0 3
84060: PUSH
84061: EMPTY
84062: LIST
84063: LIST
84064: LIST
84065: PPUSH
84066: CALL 21521 0 3
84070: ST_TO_ADDR
// exit ;
84071: POP
84072: POP
84073: POP
84074: POP
84075: GO 84250
// end ;
84077: GO 83988
84079: POP
84080: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84081: LD_ADDR_VAR 0 9
84085: PUSH
84086: LD_EXP 59
84090: PUSH
84091: LD_VAR 0 7
84095: ARRAY
84096: PPUSH
84097: LD_INT 2
84099: PUSH
84100: LD_INT 30
84102: PUSH
84103: LD_INT 0
84105: PUSH
84106: EMPTY
84107: LIST
84108: LIST
84109: PUSH
84110: LD_INT 30
84112: PUSH
84113: LD_INT 1
84115: PUSH
84116: EMPTY
84117: LIST
84118: LIST
84119: PUSH
84120: EMPTY
84121: LIST
84122: LIST
84123: LIST
84124: PPUSH
84125: CALL_OW 72
84129: ST_TO_ADDR
// if not depot then
84130: LD_VAR 0 9
84134: NOT
84135: IFFALSE 84139
// continue ;
84137: GO 83957
// for j in depot do
84139: LD_ADDR_VAR 0 8
84143: PUSH
84144: LD_VAR 0 9
84148: PUSH
84149: FOR_IN
84150: IFFALSE 84244
// if GetDistUnitXY ( j , x , y ) < 30 then
84152: LD_VAR 0 8
84156: PPUSH
84157: LD_VAR 0 2
84161: PPUSH
84162: LD_VAR 0 3
84166: PPUSH
84167: CALL_OW 297
84171: PUSH
84172: LD_INT 30
84174: LESS
84175: IFFALSE 84242
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84177: LD_ADDR_EXP 75
84181: PUSH
84182: LD_EXP 75
84186: PPUSH
84187: LD_VAR 0 7
84191: PUSH
84192: LD_EXP 75
84196: PUSH
84197: LD_VAR 0 7
84201: ARRAY
84202: PUSH
84203: LD_INT 1
84205: PLUS
84206: PUSH
84207: EMPTY
84208: LIST
84209: LIST
84210: PPUSH
84211: LD_VAR 0 4
84215: PUSH
84216: LD_VAR 0 2
84220: PUSH
84221: LD_VAR 0 3
84225: PUSH
84226: EMPTY
84227: LIST
84228: LIST
84229: LIST
84230: PPUSH
84231: CALL 21521 0 3
84235: ST_TO_ADDR
// exit ;
84236: POP
84237: POP
84238: POP
84239: POP
84240: GO 84250
// end ;
84242: GO 84149
84244: POP
84245: POP
// end ;
84246: GO 83957
84248: POP
84249: POP
// end ;
84250: LD_VAR 0 6
84254: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
84255: LD_INT 0
84257: PPUSH
84258: PPUSH
84259: PPUSH
84260: PPUSH
// if not mc_bases or not skirmish then
84261: LD_EXP 59
84265: NOT
84266: PUSH
84267: LD_EXP 57
84271: NOT
84272: OR
84273: IFFALSE 84277
// exit ;
84275: GO 84554
// side := GetSide ( lab ) ;
84277: LD_ADDR_VAR 0 4
84281: PUSH
84282: LD_VAR 0 2
84286: PPUSH
84287: CALL_OW 255
84291: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
84292: LD_VAR 0 4
84296: PUSH
84297: LD_EXP 85
84301: IN
84302: NOT
84303: PUSH
84304: LD_EXP 86
84308: NOT
84309: OR
84310: PUSH
84311: LD_EXP 59
84315: NOT
84316: OR
84317: IFFALSE 84321
// exit ;
84319: GO 84554
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
84321: LD_ADDR_EXP 86
84325: PUSH
84326: LD_EXP 86
84330: PPUSH
84331: LD_VAR 0 4
84335: PPUSH
84336: LD_EXP 86
84340: PUSH
84341: LD_VAR 0 4
84345: ARRAY
84346: PUSH
84347: LD_VAR 0 1
84351: DIFF
84352: PPUSH
84353: CALL_OW 1
84357: ST_TO_ADDR
// for i = 1 to mc_bases do
84358: LD_ADDR_VAR 0 5
84362: PUSH
84363: DOUBLE
84364: LD_INT 1
84366: DEC
84367: ST_TO_ADDR
84368: LD_EXP 59
84372: PUSH
84373: FOR_TO
84374: IFFALSE 84552
// begin if lab in mc_bases [ i ] then
84376: LD_VAR 0 2
84380: PUSH
84381: LD_EXP 59
84385: PUSH
84386: LD_VAR 0 5
84390: ARRAY
84391: IN
84392: IFFALSE 84550
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
84394: LD_VAR 0 1
84398: PUSH
84399: LD_INT 11
84401: PUSH
84402: LD_INT 4
84404: PUSH
84405: LD_INT 3
84407: PUSH
84408: LD_INT 2
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: LIST
84415: LIST
84416: IN
84417: PUSH
84418: LD_EXP 89
84422: PUSH
84423: LD_VAR 0 5
84427: ARRAY
84428: AND
84429: IFFALSE 84550
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
84431: LD_ADDR_VAR 0 6
84435: PUSH
84436: LD_EXP 89
84440: PUSH
84441: LD_VAR 0 5
84445: ARRAY
84446: PUSH
84447: LD_INT 1
84449: ARRAY
84450: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84451: LD_ADDR_EXP 89
84455: PUSH
84456: LD_EXP 89
84460: PPUSH
84461: LD_VAR 0 5
84465: PPUSH
84466: EMPTY
84467: PPUSH
84468: CALL_OW 1
84472: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
84473: LD_VAR 0 6
84477: PPUSH
84478: LD_INT 0
84480: PPUSH
84481: CALL_OW 109
// ComExitBuilding ( tmp ) ;
84485: LD_VAR 0 6
84489: PPUSH
84490: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
84494: LD_ADDR_EXP 88
84498: PUSH
84499: LD_EXP 88
84503: PPUSH
84504: LD_VAR 0 5
84508: PPUSH
84509: LD_EXP 88
84513: PUSH
84514: LD_VAR 0 5
84518: ARRAY
84519: PPUSH
84520: LD_INT 1
84522: PPUSH
84523: LD_VAR 0 6
84527: PPUSH
84528: CALL_OW 2
84532: PPUSH
84533: CALL_OW 1
84537: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84538: LD_VAR 0 5
84542: PPUSH
84543: LD_INT 112
84545: PPUSH
84546: CALL 61550 0 2
// end ; end ; end ;
84550: GO 84373
84552: POP
84553: POP
// end ;
84554: LD_VAR 0 3
84558: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84559: LD_INT 0
84561: PPUSH
84562: PPUSH
84563: PPUSH
84564: PPUSH
84565: PPUSH
84566: PPUSH
84567: PPUSH
84568: PPUSH
// if not mc_bases or not skirmish then
84569: LD_EXP 59
84573: NOT
84574: PUSH
84575: LD_EXP 57
84579: NOT
84580: OR
84581: IFFALSE 84585
// exit ;
84583: GO 85956
// for i = 1 to mc_bases do
84585: LD_ADDR_VAR 0 3
84589: PUSH
84590: DOUBLE
84591: LD_INT 1
84593: DEC
84594: ST_TO_ADDR
84595: LD_EXP 59
84599: PUSH
84600: FOR_TO
84601: IFFALSE 85954
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84603: LD_VAR 0 1
84607: PUSH
84608: LD_EXP 59
84612: PUSH
84613: LD_VAR 0 3
84617: ARRAY
84618: IN
84619: PUSH
84620: LD_VAR 0 1
84624: PUSH
84625: LD_EXP 66
84629: PUSH
84630: LD_VAR 0 3
84634: ARRAY
84635: IN
84636: OR
84637: PUSH
84638: LD_VAR 0 1
84642: PUSH
84643: LD_EXP 81
84647: PUSH
84648: LD_VAR 0 3
84652: ARRAY
84653: IN
84654: OR
84655: PUSH
84656: LD_VAR 0 1
84660: PUSH
84661: LD_EXP 78
84665: PUSH
84666: LD_VAR 0 3
84670: ARRAY
84671: IN
84672: OR
84673: PUSH
84674: LD_VAR 0 1
84678: PUSH
84679: LD_EXP 88
84683: PUSH
84684: LD_VAR 0 3
84688: ARRAY
84689: IN
84690: OR
84691: PUSH
84692: LD_VAR 0 1
84696: PUSH
84697: LD_EXP 89
84701: PUSH
84702: LD_VAR 0 3
84706: ARRAY
84707: IN
84708: OR
84709: IFFALSE 85952
// begin if un in mc_ape [ i ] then
84711: LD_VAR 0 1
84715: PUSH
84716: LD_EXP 88
84720: PUSH
84721: LD_VAR 0 3
84725: ARRAY
84726: IN
84727: IFFALSE 84766
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84729: LD_ADDR_EXP 88
84733: PUSH
84734: LD_EXP 88
84738: PPUSH
84739: LD_VAR 0 3
84743: PPUSH
84744: LD_EXP 88
84748: PUSH
84749: LD_VAR 0 3
84753: ARRAY
84754: PUSH
84755: LD_VAR 0 1
84759: DIFF
84760: PPUSH
84761: CALL_OW 1
84765: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84766: LD_VAR 0 1
84770: PUSH
84771: LD_EXP 89
84775: PUSH
84776: LD_VAR 0 3
84780: ARRAY
84781: IN
84782: IFFALSE 84806
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84784: LD_ADDR_EXP 89
84788: PUSH
84789: LD_EXP 89
84793: PPUSH
84794: LD_VAR 0 3
84798: PPUSH
84799: EMPTY
84800: PPUSH
84801: CALL_OW 1
84805: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
84806: LD_VAR 0 1
84810: PPUSH
84811: CALL_OW 247
84815: PUSH
84816: LD_INT 2
84818: EQUAL
84819: PUSH
84820: LD_VAR 0 1
84824: PPUSH
84825: CALL_OW 110
84829: PUSH
84830: LD_INT 20
84832: EQUAL
84833: PUSH
84834: LD_VAR 0 1
84838: PUSH
84839: LD_EXP 81
84843: PUSH
84844: LD_VAR 0 3
84848: ARRAY
84849: IN
84850: OR
84851: PUSH
84852: LD_VAR 0 1
84856: PPUSH
84857: CALL_OW 264
84861: PUSH
84862: LD_INT 12
84864: PUSH
84865: LD_INT 51
84867: PUSH
84868: LD_EXP 103
84872: PUSH
84873: LD_INT 32
84875: PUSH
84876: LD_INT 13
84878: PUSH
84879: LD_INT 52
84881: PUSH
84882: LD_INT 31
84884: PUSH
84885: EMPTY
84886: LIST
84887: LIST
84888: LIST
84889: LIST
84890: LIST
84891: LIST
84892: LIST
84893: IN
84894: OR
84895: AND
84896: IFFALSE 85204
// begin if un in mc_defender [ i ] then
84898: LD_VAR 0 1
84902: PUSH
84903: LD_EXP 81
84907: PUSH
84908: LD_VAR 0 3
84912: ARRAY
84913: IN
84914: IFFALSE 84953
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84916: LD_ADDR_EXP 81
84920: PUSH
84921: LD_EXP 81
84925: PPUSH
84926: LD_VAR 0 3
84930: PPUSH
84931: LD_EXP 81
84935: PUSH
84936: LD_VAR 0 3
84940: ARRAY
84941: PUSH
84942: LD_VAR 0 1
84946: DIFF
84947: PPUSH
84948: CALL_OW 1
84952: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84953: LD_ADDR_VAR 0 8
84957: PUSH
84958: LD_VAR 0 3
84962: PPUSH
84963: LD_INT 3
84965: PPUSH
84966: CALL 81622 0 2
84970: ST_TO_ADDR
// if fac then
84971: LD_VAR 0 8
84975: IFFALSE 85204
// begin for j in fac do
84977: LD_ADDR_VAR 0 4
84981: PUSH
84982: LD_VAR 0 8
84986: PUSH
84987: FOR_IN
84988: IFFALSE 85202
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84990: LD_ADDR_VAR 0 9
84994: PUSH
84995: LD_VAR 0 8
84999: PPUSH
85000: LD_VAR 0 1
85004: PPUSH
85005: CALL_OW 265
85009: PPUSH
85010: LD_VAR 0 1
85014: PPUSH
85015: CALL_OW 262
85019: PPUSH
85020: LD_VAR 0 1
85024: PPUSH
85025: CALL_OW 263
85029: PPUSH
85030: LD_VAR 0 1
85034: PPUSH
85035: CALL_OW 264
85039: PPUSH
85040: CALL 19053 0 5
85044: ST_TO_ADDR
// if components then
85045: LD_VAR 0 9
85049: IFFALSE 85200
// begin if GetWeapon ( un ) = ar_control_tower then
85051: LD_VAR 0 1
85055: PPUSH
85056: CALL_OW 264
85060: PUSH
85061: LD_INT 31
85063: EQUAL
85064: IFFALSE 85181
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
85066: LD_VAR 0 1
85070: PPUSH
85071: CALL_OW 311
85075: PPUSH
85076: LD_INT 0
85078: PPUSH
85079: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
85083: LD_ADDR_EXP 99
85087: PUSH
85088: LD_EXP 99
85092: PPUSH
85093: LD_VAR 0 3
85097: PPUSH
85098: LD_EXP 99
85102: PUSH
85103: LD_VAR 0 3
85107: ARRAY
85108: PUSH
85109: LD_VAR 0 1
85113: PPUSH
85114: CALL_OW 311
85118: DIFF
85119: PPUSH
85120: CALL_OW 1
85124: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
85125: LD_ADDR_VAR 0 7
85129: PUSH
85130: LD_EXP 80
85134: PUSH
85135: LD_VAR 0 3
85139: ARRAY
85140: PPUSH
85141: LD_INT 1
85143: PPUSH
85144: LD_VAR 0 9
85148: PPUSH
85149: CALL_OW 2
85153: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
85154: LD_ADDR_EXP 80
85158: PUSH
85159: LD_EXP 80
85163: PPUSH
85164: LD_VAR 0 3
85168: PPUSH
85169: LD_VAR 0 7
85173: PPUSH
85174: CALL_OW 1
85178: ST_TO_ADDR
// end else
85179: GO 85198
// MC_InsertProduceList ( i , [ components ] ) ;
85181: LD_VAR 0 3
85185: PPUSH
85186: LD_VAR 0 9
85190: PUSH
85191: EMPTY
85192: LIST
85193: PPUSH
85194: CALL 81167 0 2
// break ;
85198: GO 85202
// end ; end ;
85200: GO 84987
85202: POP
85203: POP
// end ; end ; if GetType ( un ) = unit_building then
85204: LD_VAR 0 1
85208: PPUSH
85209: CALL_OW 247
85213: PUSH
85214: LD_INT 3
85216: EQUAL
85217: IFFALSE 85620
// begin btype := GetBType ( un ) ;
85219: LD_ADDR_VAR 0 5
85223: PUSH
85224: LD_VAR 0 1
85228: PPUSH
85229: CALL_OW 266
85233: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
85234: LD_VAR 0 5
85238: PUSH
85239: LD_INT 29
85241: PUSH
85242: LD_INT 30
85244: PUSH
85245: EMPTY
85246: LIST
85247: LIST
85248: IN
85249: IFFALSE 85322
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
85251: LD_VAR 0 1
85255: PPUSH
85256: CALL_OW 250
85260: PPUSH
85261: LD_VAR 0 1
85265: PPUSH
85266: CALL_OW 251
85270: PPUSH
85271: LD_VAR 0 1
85275: PPUSH
85276: CALL_OW 255
85280: PPUSH
85281: CALL_OW 440
85285: NOT
85286: IFFALSE 85322
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
85288: LD_VAR 0 1
85292: PPUSH
85293: CALL_OW 250
85297: PPUSH
85298: LD_VAR 0 1
85302: PPUSH
85303: CALL_OW 251
85307: PPUSH
85308: LD_VAR 0 1
85312: PPUSH
85313: CALL_OW 255
85317: PPUSH
85318: CALL_OW 441
// end ; if btype = b_warehouse then
85322: LD_VAR 0 5
85326: PUSH
85327: LD_INT 1
85329: EQUAL
85330: IFFALSE 85348
// begin btype := b_depot ;
85332: LD_ADDR_VAR 0 5
85336: PUSH
85337: LD_INT 0
85339: ST_TO_ADDR
// pos := 1 ;
85340: LD_ADDR_VAR 0 6
85344: PUSH
85345: LD_INT 1
85347: ST_TO_ADDR
// end ; if btype = b_factory then
85348: LD_VAR 0 5
85352: PUSH
85353: LD_INT 3
85355: EQUAL
85356: IFFALSE 85374
// begin btype := b_workshop ;
85358: LD_ADDR_VAR 0 5
85362: PUSH
85363: LD_INT 2
85365: ST_TO_ADDR
// pos := 1 ;
85366: LD_ADDR_VAR 0 6
85370: PUSH
85371: LD_INT 1
85373: ST_TO_ADDR
// end ; if btype = b_barracks then
85374: LD_VAR 0 5
85378: PUSH
85379: LD_INT 5
85381: EQUAL
85382: IFFALSE 85392
// btype := b_armoury ;
85384: LD_ADDR_VAR 0 5
85388: PUSH
85389: LD_INT 4
85391: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
85392: LD_VAR 0 5
85396: PUSH
85397: LD_INT 7
85399: PUSH
85400: LD_INT 8
85402: PUSH
85403: EMPTY
85404: LIST
85405: LIST
85406: IN
85407: IFFALSE 85417
// btype := b_lab ;
85409: LD_ADDR_VAR 0 5
85413: PUSH
85414: LD_INT 6
85416: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
85417: LD_ADDR_EXP 64
85421: PUSH
85422: LD_EXP 64
85426: PPUSH
85427: LD_VAR 0 3
85431: PUSH
85432: LD_EXP 64
85436: PUSH
85437: LD_VAR 0 3
85441: ARRAY
85442: PUSH
85443: LD_INT 1
85445: PLUS
85446: PUSH
85447: EMPTY
85448: LIST
85449: LIST
85450: PPUSH
85451: LD_VAR 0 5
85455: PUSH
85456: LD_VAR 0 1
85460: PPUSH
85461: CALL_OW 250
85465: PUSH
85466: LD_VAR 0 1
85470: PPUSH
85471: CALL_OW 251
85475: PUSH
85476: LD_VAR 0 1
85480: PPUSH
85481: CALL_OW 254
85485: PUSH
85486: EMPTY
85487: LIST
85488: LIST
85489: LIST
85490: LIST
85491: PPUSH
85492: CALL 21521 0 3
85496: ST_TO_ADDR
// if pos = 1 then
85497: LD_VAR 0 6
85501: PUSH
85502: LD_INT 1
85504: EQUAL
85505: IFFALSE 85620
// begin tmp := mc_build_list [ i ] ;
85507: LD_ADDR_VAR 0 7
85511: PUSH
85512: LD_EXP 64
85516: PUSH
85517: LD_VAR 0 3
85521: ARRAY
85522: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
85523: LD_VAR 0 7
85527: PPUSH
85528: LD_INT 2
85530: PUSH
85531: LD_INT 30
85533: PUSH
85534: LD_INT 0
85536: PUSH
85537: EMPTY
85538: LIST
85539: LIST
85540: PUSH
85541: LD_INT 30
85543: PUSH
85544: LD_INT 1
85546: PUSH
85547: EMPTY
85548: LIST
85549: LIST
85550: PUSH
85551: EMPTY
85552: LIST
85553: LIST
85554: LIST
85555: PPUSH
85556: CALL_OW 72
85560: IFFALSE 85570
// pos := 2 ;
85562: LD_ADDR_VAR 0 6
85566: PUSH
85567: LD_INT 2
85569: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85570: LD_ADDR_VAR 0 7
85574: PUSH
85575: LD_VAR 0 7
85579: PPUSH
85580: LD_VAR 0 6
85584: PPUSH
85585: LD_VAR 0 7
85589: PPUSH
85590: CALL 21847 0 3
85594: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85595: LD_ADDR_EXP 64
85599: PUSH
85600: LD_EXP 64
85604: PPUSH
85605: LD_VAR 0 3
85609: PPUSH
85610: LD_VAR 0 7
85614: PPUSH
85615: CALL_OW 1
85619: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85620: LD_VAR 0 1
85624: PUSH
85625: LD_EXP 59
85629: PUSH
85630: LD_VAR 0 3
85634: ARRAY
85635: IN
85636: IFFALSE 85675
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85638: LD_ADDR_EXP 59
85642: PUSH
85643: LD_EXP 59
85647: PPUSH
85648: LD_VAR 0 3
85652: PPUSH
85653: LD_EXP 59
85657: PUSH
85658: LD_VAR 0 3
85662: ARRAY
85663: PUSH
85664: LD_VAR 0 1
85668: DIFF
85669: PPUSH
85670: CALL_OW 1
85674: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85675: LD_VAR 0 1
85679: PUSH
85680: LD_EXP 66
85684: PUSH
85685: LD_VAR 0 3
85689: ARRAY
85690: IN
85691: IFFALSE 85730
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85693: LD_ADDR_EXP 66
85697: PUSH
85698: LD_EXP 66
85702: PPUSH
85703: LD_VAR 0 3
85707: PPUSH
85708: LD_EXP 66
85712: PUSH
85713: LD_VAR 0 3
85717: ARRAY
85718: PUSH
85719: LD_VAR 0 1
85723: DIFF
85724: PPUSH
85725: CALL_OW 1
85729: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85730: LD_VAR 0 1
85734: PUSH
85735: LD_EXP 78
85739: PUSH
85740: LD_VAR 0 3
85744: ARRAY
85745: IN
85746: IFFALSE 85785
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85748: LD_ADDR_EXP 78
85752: PUSH
85753: LD_EXP 78
85757: PPUSH
85758: LD_VAR 0 3
85762: PPUSH
85763: LD_EXP 78
85767: PUSH
85768: LD_VAR 0 3
85772: ARRAY
85773: PUSH
85774: LD_VAR 0 1
85778: DIFF
85779: PPUSH
85780: CALL_OW 1
85784: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85785: LD_VAR 0 1
85789: PUSH
85790: LD_EXP 81
85794: PUSH
85795: LD_VAR 0 3
85799: ARRAY
85800: IN
85801: IFFALSE 85840
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85803: LD_ADDR_EXP 81
85807: PUSH
85808: LD_EXP 81
85812: PPUSH
85813: LD_VAR 0 3
85817: PPUSH
85818: LD_EXP 81
85822: PUSH
85823: LD_VAR 0 3
85827: ARRAY
85828: PUSH
85829: LD_VAR 0 1
85833: DIFF
85834: PPUSH
85835: CALL_OW 1
85839: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85840: LD_VAR 0 1
85844: PUSH
85845: LD_EXP 68
85849: PUSH
85850: LD_VAR 0 3
85854: ARRAY
85855: IN
85856: IFFALSE 85895
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85858: LD_ADDR_EXP 68
85862: PUSH
85863: LD_EXP 68
85867: PPUSH
85868: LD_VAR 0 3
85872: PPUSH
85873: LD_EXP 68
85877: PUSH
85878: LD_VAR 0 3
85882: ARRAY
85883: PUSH
85884: LD_VAR 0 1
85888: DIFF
85889: PPUSH
85890: CALL_OW 1
85894: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85895: LD_VAR 0 1
85899: PUSH
85900: LD_EXP 67
85904: PUSH
85905: LD_VAR 0 3
85909: ARRAY
85910: IN
85911: IFFALSE 85950
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85913: LD_ADDR_EXP 67
85917: PUSH
85918: LD_EXP 67
85922: PPUSH
85923: LD_VAR 0 3
85927: PPUSH
85928: LD_EXP 67
85932: PUSH
85933: LD_VAR 0 3
85937: ARRAY
85938: PUSH
85939: LD_VAR 0 1
85943: DIFF
85944: PPUSH
85945: CALL_OW 1
85949: ST_TO_ADDR
// end ; break ;
85950: GO 85954
// end ;
85952: GO 84600
85954: POP
85955: POP
// end ;
85956: LD_VAR 0 2
85960: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85961: LD_INT 0
85963: PPUSH
85964: PPUSH
85965: PPUSH
// if not mc_bases or not skirmish then
85966: LD_EXP 59
85970: NOT
85971: PUSH
85972: LD_EXP 57
85976: NOT
85977: OR
85978: IFFALSE 85982
// exit ;
85980: GO 86197
// for i = 1 to mc_bases do
85982: LD_ADDR_VAR 0 3
85986: PUSH
85987: DOUBLE
85988: LD_INT 1
85990: DEC
85991: ST_TO_ADDR
85992: LD_EXP 59
85996: PUSH
85997: FOR_TO
85998: IFFALSE 86195
// begin if building in mc_construct_list [ i ] then
86000: LD_VAR 0 1
86004: PUSH
86005: LD_EXP 66
86009: PUSH
86010: LD_VAR 0 3
86014: ARRAY
86015: IN
86016: IFFALSE 86193
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86018: LD_ADDR_EXP 66
86022: PUSH
86023: LD_EXP 66
86027: PPUSH
86028: LD_VAR 0 3
86032: PPUSH
86033: LD_EXP 66
86037: PUSH
86038: LD_VAR 0 3
86042: ARRAY
86043: PUSH
86044: LD_VAR 0 1
86048: DIFF
86049: PPUSH
86050: CALL_OW 1
86054: ST_TO_ADDR
// if building in mc_lab [ i ] then
86055: LD_VAR 0 1
86059: PUSH
86060: LD_EXP 92
86064: PUSH
86065: LD_VAR 0 3
86069: ARRAY
86070: IN
86071: IFFALSE 86126
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
86073: LD_ADDR_EXP 93
86077: PUSH
86078: LD_EXP 93
86082: PPUSH
86083: LD_VAR 0 3
86087: PPUSH
86088: LD_EXP 93
86092: PUSH
86093: LD_VAR 0 3
86097: ARRAY
86098: PPUSH
86099: LD_INT 1
86101: PPUSH
86102: LD_EXP 93
86106: PUSH
86107: LD_VAR 0 3
86111: ARRAY
86112: PPUSH
86113: LD_INT 0
86115: PPUSH
86116: CALL 20939 0 4
86120: PPUSH
86121: CALL_OW 1
86125: ST_TO_ADDR
// if not building in mc_bases [ i ] then
86126: LD_VAR 0 1
86130: PUSH
86131: LD_EXP 59
86135: PUSH
86136: LD_VAR 0 3
86140: ARRAY
86141: IN
86142: NOT
86143: IFFALSE 86189
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86145: LD_ADDR_EXP 59
86149: PUSH
86150: LD_EXP 59
86154: PPUSH
86155: LD_VAR 0 3
86159: PUSH
86160: LD_EXP 59
86164: PUSH
86165: LD_VAR 0 3
86169: ARRAY
86170: PUSH
86171: LD_INT 1
86173: PLUS
86174: PUSH
86175: EMPTY
86176: LIST
86177: LIST
86178: PPUSH
86179: LD_VAR 0 1
86183: PPUSH
86184: CALL 21521 0 3
86188: ST_TO_ADDR
// exit ;
86189: POP
86190: POP
86191: GO 86197
// end ; end ;
86193: GO 85997
86195: POP
86196: POP
// end ;
86197: LD_VAR 0 2
86201: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
86202: LD_INT 0
86204: PPUSH
86205: PPUSH
86206: PPUSH
86207: PPUSH
86208: PPUSH
86209: PPUSH
86210: PPUSH
// if not mc_bases or not skirmish then
86211: LD_EXP 59
86215: NOT
86216: PUSH
86217: LD_EXP 57
86221: NOT
86222: OR
86223: IFFALSE 86227
// exit ;
86225: GO 86888
// for i = 1 to mc_bases do
86227: LD_ADDR_VAR 0 3
86231: PUSH
86232: DOUBLE
86233: LD_INT 1
86235: DEC
86236: ST_TO_ADDR
86237: LD_EXP 59
86241: PUSH
86242: FOR_TO
86243: IFFALSE 86886
// begin if building in mc_construct_list [ i ] then
86245: LD_VAR 0 1
86249: PUSH
86250: LD_EXP 66
86254: PUSH
86255: LD_VAR 0 3
86259: ARRAY
86260: IN
86261: IFFALSE 86884
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86263: LD_ADDR_EXP 66
86267: PUSH
86268: LD_EXP 66
86272: PPUSH
86273: LD_VAR 0 3
86277: PPUSH
86278: LD_EXP 66
86282: PUSH
86283: LD_VAR 0 3
86287: ARRAY
86288: PUSH
86289: LD_VAR 0 1
86293: DIFF
86294: PPUSH
86295: CALL_OW 1
86299: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86300: LD_ADDR_EXP 59
86304: PUSH
86305: LD_EXP 59
86309: PPUSH
86310: LD_VAR 0 3
86314: PUSH
86315: LD_EXP 59
86319: PUSH
86320: LD_VAR 0 3
86324: ARRAY
86325: PUSH
86326: LD_INT 1
86328: PLUS
86329: PUSH
86330: EMPTY
86331: LIST
86332: LIST
86333: PPUSH
86334: LD_VAR 0 1
86338: PPUSH
86339: CALL 21521 0 3
86343: ST_TO_ADDR
// btype := GetBType ( building ) ;
86344: LD_ADDR_VAR 0 5
86348: PUSH
86349: LD_VAR 0 1
86353: PPUSH
86354: CALL_OW 266
86358: ST_TO_ADDR
// side := GetSide ( building ) ;
86359: LD_ADDR_VAR 0 8
86363: PUSH
86364: LD_VAR 0 1
86368: PPUSH
86369: CALL_OW 255
86373: ST_TO_ADDR
// if btype = b_lab then
86374: LD_VAR 0 5
86378: PUSH
86379: LD_INT 6
86381: EQUAL
86382: IFFALSE 86432
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
86384: LD_ADDR_EXP 92
86388: PUSH
86389: LD_EXP 92
86393: PPUSH
86394: LD_VAR 0 3
86398: PUSH
86399: LD_EXP 92
86403: PUSH
86404: LD_VAR 0 3
86408: ARRAY
86409: PUSH
86410: LD_INT 1
86412: PLUS
86413: PUSH
86414: EMPTY
86415: LIST
86416: LIST
86417: PPUSH
86418: LD_VAR 0 1
86422: PPUSH
86423: CALL 21521 0 3
86427: ST_TO_ADDR
// exit ;
86428: POP
86429: POP
86430: GO 86888
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
86432: LD_VAR 0 5
86436: PUSH
86437: LD_INT 0
86439: PUSH
86440: LD_INT 2
86442: PUSH
86443: LD_INT 4
86445: PUSH
86446: EMPTY
86447: LIST
86448: LIST
86449: LIST
86450: IN
86451: IFFALSE 86575
// begin if btype = b_armoury then
86453: LD_VAR 0 5
86457: PUSH
86458: LD_INT 4
86460: EQUAL
86461: IFFALSE 86471
// btype := b_barracks ;
86463: LD_ADDR_VAR 0 5
86467: PUSH
86468: LD_INT 5
86470: ST_TO_ADDR
// if btype = b_depot then
86471: LD_VAR 0 5
86475: PUSH
86476: LD_INT 0
86478: EQUAL
86479: IFFALSE 86489
// btype := b_warehouse ;
86481: LD_ADDR_VAR 0 5
86485: PUSH
86486: LD_INT 1
86488: ST_TO_ADDR
// if btype = b_workshop then
86489: LD_VAR 0 5
86493: PUSH
86494: LD_INT 2
86496: EQUAL
86497: IFFALSE 86507
// btype := b_factory ;
86499: LD_ADDR_VAR 0 5
86503: PUSH
86504: LD_INT 3
86506: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
86507: LD_VAR 0 5
86511: PPUSH
86512: LD_VAR 0 8
86516: PPUSH
86517: CALL_OW 323
86521: PUSH
86522: LD_INT 1
86524: EQUAL
86525: IFFALSE 86571
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
86527: LD_ADDR_EXP 91
86531: PUSH
86532: LD_EXP 91
86536: PPUSH
86537: LD_VAR 0 3
86541: PUSH
86542: LD_EXP 91
86546: PUSH
86547: LD_VAR 0 3
86551: ARRAY
86552: PUSH
86553: LD_INT 1
86555: PLUS
86556: PUSH
86557: EMPTY
86558: LIST
86559: LIST
86560: PPUSH
86561: LD_VAR 0 1
86565: PPUSH
86566: CALL 21521 0 3
86570: ST_TO_ADDR
// exit ;
86571: POP
86572: POP
86573: GO 86888
// end ; if btype in [ b_bunker , b_turret ] then
86575: LD_VAR 0 5
86579: PUSH
86580: LD_INT 32
86582: PUSH
86583: LD_INT 33
86585: PUSH
86586: EMPTY
86587: LIST
86588: LIST
86589: IN
86590: IFFALSE 86880
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86592: LD_ADDR_EXP 67
86596: PUSH
86597: LD_EXP 67
86601: PPUSH
86602: LD_VAR 0 3
86606: PUSH
86607: LD_EXP 67
86611: PUSH
86612: LD_VAR 0 3
86616: ARRAY
86617: PUSH
86618: LD_INT 1
86620: PLUS
86621: PUSH
86622: EMPTY
86623: LIST
86624: LIST
86625: PPUSH
86626: LD_VAR 0 1
86630: PPUSH
86631: CALL 21521 0 3
86635: ST_TO_ADDR
// if btype = b_bunker then
86636: LD_VAR 0 5
86640: PUSH
86641: LD_INT 32
86643: EQUAL
86644: IFFALSE 86880
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86646: LD_ADDR_EXP 68
86650: PUSH
86651: LD_EXP 68
86655: PPUSH
86656: LD_VAR 0 3
86660: PUSH
86661: LD_EXP 68
86665: PUSH
86666: LD_VAR 0 3
86670: ARRAY
86671: PUSH
86672: LD_INT 1
86674: PLUS
86675: PUSH
86676: EMPTY
86677: LIST
86678: LIST
86679: PPUSH
86680: LD_VAR 0 1
86684: PPUSH
86685: CALL 21521 0 3
86689: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86690: LD_ADDR_VAR 0 6
86694: PUSH
86695: LD_EXP 59
86699: PUSH
86700: LD_VAR 0 3
86704: ARRAY
86705: PPUSH
86706: LD_INT 25
86708: PUSH
86709: LD_INT 1
86711: PUSH
86712: EMPTY
86713: LIST
86714: LIST
86715: PUSH
86716: LD_INT 3
86718: PUSH
86719: LD_INT 54
86721: PUSH
86722: EMPTY
86723: LIST
86724: PUSH
86725: EMPTY
86726: LIST
86727: LIST
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: PPUSH
86733: CALL_OW 72
86737: ST_TO_ADDR
// if tmp then
86738: LD_VAR 0 6
86742: IFFALSE 86748
// exit ;
86744: POP
86745: POP
86746: GO 86888
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86748: LD_ADDR_VAR 0 6
86752: PUSH
86753: LD_EXP 59
86757: PUSH
86758: LD_VAR 0 3
86762: ARRAY
86763: PPUSH
86764: LD_INT 2
86766: PUSH
86767: LD_INT 30
86769: PUSH
86770: LD_INT 4
86772: PUSH
86773: EMPTY
86774: LIST
86775: LIST
86776: PUSH
86777: LD_INT 30
86779: PUSH
86780: LD_INT 5
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: LIST
86791: PPUSH
86792: CALL_OW 72
86796: ST_TO_ADDR
// if not tmp then
86797: LD_VAR 0 6
86801: NOT
86802: IFFALSE 86808
// exit ;
86804: POP
86805: POP
86806: GO 86888
// for j in tmp do
86808: LD_ADDR_VAR 0 4
86812: PUSH
86813: LD_VAR 0 6
86817: PUSH
86818: FOR_IN
86819: IFFALSE 86878
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86821: LD_ADDR_VAR 0 7
86825: PUSH
86826: LD_VAR 0 4
86830: PPUSH
86831: CALL_OW 313
86835: PPUSH
86836: LD_INT 25
86838: PUSH
86839: LD_INT 1
86841: PUSH
86842: EMPTY
86843: LIST
86844: LIST
86845: PPUSH
86846: CALL_OW 72
86850: ST_TO_ADDR
// if units then
86851: LD_VAR 0 7
86855: IFFALSE 86876
// begin ComExitBuilding ( units [ 1 ] ) ;
86857: LD_VAR 0 7
86861: PUSH
86862: LD_INT 1
86864: ARRAY
86865: PPUSH
86866: CALL_OW 122
// exit ;
86870: POP
86871: POP
86872: POP
86873: POP
86874: GO 86888
// end ; end ;
86876: GO 86818
86878: POP
86879: POP
// end ; end ; exit ;
86880: POP
86881: POP
86882: GO 86888
// end ; end ;
86884: GO 86242
86886: POP
86887: POP
// end ;
86888: LD_VAR 0 2
86892: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86893: LD_INT 0
86895: PPUSH
86896: PPUSH
86897: PPUSH
86898: PPUSH
86899: PPUSH
86900: PPUSH
86901: PPUSH
// if not mc_bases or not skirmish then
86902: LD_EXP 59
86906: NOT
86907: PUSH
86908: LD_EXP 57
86912: NOT
86913: OR
86914: IFFALSE 86918
// exit ;
86916: GO 87149
// btype := GetBType ( building ) ;
86918: LD_ADDR_VAR 0 6
86922: PUSH
86923: LD_VAR 0 1
86927: PPUSH
86928: CALL_OW 266
86932: ST_TO_ADDR
// x := GetX ( building ) ;
86933: LD_ADDR_VAR 0 7
86937: PUSH
86938: LD_VAR 0 1
86942: PPUSH
86943: CALL_OW 250
86947: ST_TO_ADDR
// y := GetY ( building ) ;
86948: LD_ADDR_VAR 0 8
86952: PUSH
86953: LD_VAR 0 1
86957: PPUSH
86958: CALL_OW 251
86962: ST_TO_ADDR
// d := GetDir ( building ) ;
86963: LD_ADDR_VAR 0 9
86967: PUSH
86968: LD_VAR 0 1
86972: PPUSH
86973: CALL_OW 254
86977: ST_TO_ADDR
// for i = 1 to mc_bases do
86978: LD_ADDR_VAR 0 4
86982: PUSH
86983: DOUBLE
86984: LD_INT 1
86986: DEC
86987: ST_TO_ADDR
86988: LD_EXP 59
86992: PUSH
86993: FOR_TO
86994: IFFALSE 87147
// begin if not mc_build_list [ i ] then
86996: LD_EXP 64
87000: PUSH
87001: LD_VAR 0 4
87005: ARRAY
87006: NOT
87007: IFFALSE 87011
// continue ;
87009: GO 86993
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
87011: LD_VAR 0 6
87015: PUSH
87016: LD_VAR 0 7
87020: PUSH
87021: LD_VAR 0 8
87025: PUSH
87026: LD_VAR 0 9
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: LIST
87035: LIST
87036: PPUSH
87037: LD_EXP 64
87041: PUSH
87042: LD_VAR 0 4
87046: ARRAY
87047: PUSH
87048: LD_INT 1
87050: ARRAY
87051: PPUSH
87052: CALL 27690 0 2
87056: IFFALSE 87145
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
87058: LD_ADDR_EXP 64
87062: PUSH
87063: LD_EXP 64
87067: PPUSH
87068: LD_VAR 0 4
87072: PPUSH
87073: LD_EXP 64
87077: PUSH
87078: LD_VAR 0 4
87082: ARRAY
87083: PPUSH
87084: LD_INT 1
87086: PPUSH
87087: CALL_OW 3
87091: PPUSH
87092: CALL_OW 1
87096: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
87097: LD_ADDR_EXP 66
87101: PUSH
87102: LD_EXP 66
87106: PPUSH
87107: LD_VAR 0 4
87111: PUSH
87112: LD_EXP 66
87116: PUSH
87117: LD_VAR 0 4
87121: ARRAY
87122: PUSH
87123: LD_INT 1
87125: PLUS
87126: PUSH
87127: EMPTY
87128: LIST
87129: LIST
87130: PPUSH
87131: LD_VAR 0 1
87135: PPUSH
87136: CALL 21521 0 3
87140: ST_TO_ADDR
// exit ;
87141: POP
87142: POP
87143: GO 87149
// end ; end ;
87145: GO 86993
87147: POP
87148: POP
// end ;
87149: LD_VAR 0 3
87153: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
87154: LD_INT 0
87156: PPUSH
87157: PPUSH
87158: PPUSH
// if not mc_bases or not skirmish then
87159: LD_EXP 59
87163: NOT
87164: PUSH
87165: LD_EXP 57
87169: NOT
87170: OR
87171: IFFALSE 87175
// exit ;
87173: GO 87365
// for i = 1 to mc_bases do
87175: LD_ADDR_VAR 0 4
87179: PUSH
87180: DOUBLE
87181: LD_INT 1
87183: DEC
87184: ST_TO_ADDR
87185: LD_EXP 59
87189: PUSH
87190: FOR_TO
87191: IFFALSE 87278
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
87193: LD_VAR 0 1
87197: PUSH
87198: LD_EXP 67
87202: PUSH
87203: LD_VAR 0 4
87207: ARRAY
87208: IN
87209: PUSH
87210: LD_VAR 0 1
87214: PUSH
87215: LD_EXP 68
87219: PUSH
87220: LD_VAR 0 4
87224: ARRAY
87225: IN
87226: NOT
87227: AND
87228: IFFALSE 87276
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
87230: LD_ADDR_EXP 68
87234: PUSH
87235: LD_EXP 68
87239: PPUSH
87240: LD_VAR 0 4
87244: PUSH
87245: LD_EXP 68
87249: PUSH
87250: LD_VAR 0 4
87254: ARRAY
87255: PUSH
87256: LD_INT 1
87258: PLUS
87259: PUSH
87260: EMPTY
87261: LIST
87262: LIST
87263: PPUSH
87264: LD_VAR 0 1
87268: PPUSH
87269: CALL 21521 0 3
87273: ST_TO_ADDR
// break ;
87274: GO 87278
// end ; end ;
87276: GO 87190
87278: POP
87279: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
87280: LD_VAR 0 1
87284: PPUSH
87285: CALL_OW 257
87289: PUSH
87290: LD_EXP 85
87294: IN
87295: PUSH
87296: LD_VAR 0 1
87300: PPUSH
87301: CALL_OW 266
87305: PUSH
87306: LD_INT 5
87308: EQUAL
87309: AND
87310: PUSH
87311: LD_VAR 0 2
87315: PPUSH
87316: CALL_OW 110
87320: PUSH
87321: LD_INT 18
87323: NONEQUAL
87324: AND
87325: IFFALSE 87365
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
87327: LD_VAR 0 2
87331: PPUSH
87332: CALL_OW 257
87336: PUSH
87337: LD_INT 5
87339: PUSH
87340: LD_INT 8
87342: PUSH
87343: LD_INT 9
87345: PUSH
87346: EMPTY
87347: LIST
87348: LIST
87349: LIST
87350: IN
87351: IFFALSE 87365
// SetClass ( unit , 1 ) ;
87353: LD_VAR 0 2
87357: PPUSH
87358: LD_INT 1
87360: PPUSH
87361: CALL_OW 336
// end ;
87365: LD_VAR 0 3
87369: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
87370: LD_INT 0
87372: PPUSH
87373: PPUSH
// if not mc_bases or not skirmish then
87374: LD_EXP 59
87378: NOT
87379: PUSH
87380: LD_EXP 57
87384: NOT
87385: OR
87386: IFFALSE 87390
// exit ;
87388: GO 87506
// if GetLives ( abandoned_vehicle ) > 250 then
87390: LD_VAR 0 2
87394: PPUSH
87395: CALL_OW 256
87399: PUSH
87400: LD_INT 250
87402: GREATER
87403: IFFALSE 87407
// exit ;
87405: GO 87506
// for i = 1 to mc_bases do
87407: LD_ADDR_VAR 0 6
87411: PUSH
87412: DOUBLE
87413: LD_INT 1
87415: DEC
87416: ST_TO_ADDR
87417: LD_EXP 59
87421: PUSH
87422: FOR_TO
87423: IFFALSE 87504
// begin if driver in mc_bases [ i ] then
87425: LD_VAR 0 1
87429: PUSH
87430: LD_EXP 59
87434: PUSH
87435: LD_VAR 0 6
87439: ARRAY
87440: IN
87441: IFFALSE 87502
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
87443: LD_VAR 0 1
87447: PPUSH
87448: LD_EXP 59
87452: PUSH
87453: LD_VAR 0 6
87457: ARRAY
87458: PPUSH
87459: LD_INT 2
87461: PUSH
87462: LD_INT 30
87464: PUSH
87465: LD_INT 0
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 30
87474: PUSH
87475: LD_INT 1
87477: PUSH
87478: EMPTY
87479: LIST
87480: LIST
87481: PUSH
87482: EMPTY
87483: LIST
87484: LIST
87485: LIST
87486: PPUSH
87487: CALL_OW 72
87491: PUSH
87492: LD_INT 1
87494: ARRAY
87495: PPUSH
87496: CALL_OW 112
// break ;
87500: GO 87504
// end ; end ;
87502: GO 87422
87504: POP
87505: POP
// end ; end_of_file
87506: LD_VAR 0 5
87510: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
87511: GO 87513
87513: DISABLE
// begin ru_radar := 98 ;
87514: LD_ADDR_EXP 102
87518: PUSH
87519: LD_INT 98
87521: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
87522: LD_ADDR_EXP 103
87526: PUSH
87527: LD_INT 89
87529: ST_TO_ADDR
// us_hack := 99 ;
87530: LD_ADDR_EXP 104
87534: PUSH
87535: LD_INT 99
87537: ST_TO_ADDR
// us_artillery := 97 ;
87538: LD_ADDR_EXP 105
87542: PUSH
87543: LD_INT 97
87545: ST_TO_ADDR
// ar_bio_bomb := 91 ;
87546: LD_ADDR_EXP 106
87550: PUSH
87551: LD_INT 91
87553: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
87554: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
87555: LD_INT 0
87557: PPUSH
87558: PPUSH
87559: PPUSH
87560: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
87561: LD_VAR 0 1
87565: PPUSH
87566: CALL_OW 264
87570: PUSH
87571: LD_EXP 106
87575: EQUAL
87576: IFFALSE 87648
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
87578: LD_INT 68
87580: PPUSH
87581: LD_VAR 0 1
87585: PPUSH
87586: CALL_OW 255
87590: PPUSH
87591: CALL_OW 321
87595: PUSH
87596: LD_INT 2
87598: EQUAL
87599: IFFALSE 87611
// eff := 70 else
87601: LD_ADDR_VAR 0 6
87605: PUSH
87606: LD_INT 70
87608: ST_TO_ADDR
87609: GO 87619
// eff := 30 ;
87611: LD_ADDR_VAR 0 6
87615: PUSH
87616: LD_INT 30
87618: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
87619: LD_VAR 0 1
87623: PPUSH
87624: CALL_OW 250
87628: PPUSH
87629: LD_VAR 0 1
87633: PPUSH
87634: CALL_OW 251
87638: PPUSH
87639: LD_VAR 0 6
87643: PPUSH
87644: CALL_OW 495
// end ; end ;
87648: LD_VAR 0 4
87652: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
87653: LD_INT 0
87655: PPUSH
87656: PPUSH
87657: PPUSH
87658: PPUSH
87659: PPUSH
87660: PPUSH
// if cmd = 124 then
87661: LD_VAR 0 1
87665: PUSH
87666: LD_INT 124
87668: EQUAL
87669: IFFALSE 87875
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
87671: LD_ADDR_VAR 0 5
87675: PUSH
87676: LD_INT 2
87678: PUSH
87679: LD_INT 34
87681: PUSH
87682: LD_INT 53
87684: PUSH
87685: EMPTY
87686: LIST
87687: LIST
87688: PUSH
87689: LD_INT 34
87691: PUSH
87692: LD_INT 14
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: EMPTY
87700: LIST
87701: LIST
87702: LIST
87703: PPUSH
87704: CALL_OW 69
87708: ST_TO_ADDR
// if not tmp then
87709: LD_VAR 0 5
87713: NOT
87714: IFFALSE 87718
// exit ;
87716: GO 87875
// for i in tmp do
87718: LD_ADDR_VAR 0 3
87722: PUSH
87723: LD_VAR 0 5
87727: PUSH
87728: FOR_IN
87729: IFFALSE 87873
// begin taskList := GetTaskList ( i ) ;
87731: LD_ADDR_VAR 0 6
87735: PUSH
87736: LD_VAR 0 3
87740: PPUSH
87741: CALL_OW 437
87745: ST_TO_ADDR
// if not taskList then
87746: LD_VAR 0 6
87750: NOT
87751: IFFALSE 87755
// continue ;
87753: GO 87728
// for j = 1 to taskList do
87755: LD_ADDR_VAR 0 4
87759: PUSH
87760: DOUBLE
87761: LD_INT 1
87763: DEC
87764: ST_TO_ADDR
87765: LD_VAR 0 6
87769: PUSH
87770: FOR_TO
87771: IFFALSE 87869
// if taskList [ j ] [ 1 ] = | then
87773: LD_VAR 0 6
87777: PUSH
87778: LD_VAR 0 4
87782: ARRAY
87783: PUSH
87784: LD_INT 1
87786: ARRAY
87787: PUSH
87788: LD_STRING |
87790: EQUAL
87791: IFFALSE 87867
// begin _taskList := Delete ( taskList , 1 ) ;
87793: LD_ADDR_VAR 0 7
87797: PUSH
87798: LD_VAR 0 6
87802: PPUSH
87803: LD_INT 1
87805: PPUSH
87806: CALL_OW 3
87810: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
87811: LD_VAR 0 3
87815: PPUSH
87816: LD_VAR 0 7
87820: PPUSH
87821: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
87825: LD_VAR 0 3
87829: PPUSH
87830: LD_VAR 0 6
87834: PUSH
87835: LD_VAR 0 4
87839: ARRAY
87840: PUSH
87841: LD_INT 2
87843: ARRAY
87844: PPUSH
87845: LD_VAR 0 6
87849: PUSH
87850: LD_VAR 0 4
87854: ARRAY
87855: PUSH
87856: LD_INT 3
87858: ARRAY
87859: PPUSH
87860: LD_INT 8
87862: PPUSH
87863: CALL 87880 0 4
// end ;
87867: GO 87770
87869: POP
87870: POP
// end ;
87871: GO 87728
87873: POP
87874: POP
// end ; end ;
87875: LD_VAR 0 2
87879: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
87880: LD_INT 0
87882: PPUSH
87883: PPUSH
87884: PPUSH
87885: PPUSH
87886: PPUSH
87887: PPUSH
87888: PPUSH
87889: PPUSH
87890: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
87891: LD_VAR 0 1
87895: NOT
87896: PUSH
87897: LD_VAR 0 2
87901: PPUSH
87902: LD_VAR 0 3
87906: PPUSH
87907: CALL_OW 488
87911: NOT
87912: OR
87913: PUSH
87914: LD_VAR 0 4
87918: NOT
87919: OR
87920: IFFALSE 87924
// exit ;
87922: GO 88264
// list := [ ] ;
87924: LD_ADDR_VAR 0 13
87928: PUSH
87929: EMPTY
87930: ST_TO_ADDR
// if x - r < 0 then
87931: LD_VAR 0 2
87935: PUSH
87936: LD_VAR 0 4
87940: MINUS
87941: PUSH
87942: LD_INT 0
87944: LESS
87945: IFFALSE 87957
// min_x := 0 else
87947: LD_ADDR_VAR 0 7
87951: PUSH
87952: LD_INT 0
87954: ST_TO_ADDR
87955: GO 87973
// min_x := x - r ;
87957: LD_ADDR_VAR 0 7
87961: PUSH
87962: LD_VAR 0 2
87966: PUSH
87967: LD_VAR 0 4
87971: MINUS
87972: ST_TO_ADDR
// if y - r < 0 then
87973: LD_VAR 0 3
87977: PUSH
87978: LD_VAR 0 4
87982: MINUS
87983: PUSH
87984: LD_INT 0
87986: LESS
87987: IFFALSE 87999
// min_y := 0 else
87989: LD_ADDR_VAR 0 8
87993: PUSH
87994: LD_INT 0
87996: ST_TO_ADDR
87997: GO 88015
// min_y := y - r ;
87999: LD_ADDR_VAR 0 8
88003: PUSH
88004: LD_VAR 0 3
88008: PUSH
88009: LD_VAR 0 4
88013: MINUS
88014: ST_TO_ADDR
// max_x := x + r ;
88015: LD_ADDR_VAR 0 9
88019: PUSH
88020: LD_VAR 0 2
88024: PUSH
88025: LD_VAR 0 4
88029: PLUS
88030: ST_TO_ADDR
// max_y := y + r ;
88031: LD_ADDR_VAR 0 10
88035: PUSH
88036: LD_VAR 0 3
88040: PUSH
88041: LD_VAR 0 4
88045: PLUS
88046: ST_TO_ADDR
// for _x = min_x to max_x do
88047: LD_ADDR_VAR 0 11
88051: PUSH
88052: DOUBLE
88053: LD_VAR 0 7
88057: DEC
88058: ST_TO_ADDR
88059: LD_VAR 0 9
88063: PUSH
88064: FOR_TO
88065: IFFALSE 88182
// for _y = min_y to max_y do
88067: LD_ADDR_VAR 0 12
88071: PUSH
88072: DOUBLE
88073: LD_VAR 0 8
88077: DEC
88078: ST_TO_ADDR
88079: LD_VAR 0 10
88083: PUSH
88084: FOR_TO
88085: IFFALSE 88178
// begin if not ValidHex ( _x , _y ) then
88087: LD_VAR 0 11
88091: PPUSH
88092: LD_VAR 0 12
88096: PPUSH
88097: CALL_OW 488
88101: NOT
88102: IFFALSE 88106
// continue ;
88104: GO 88084
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
88106: LD_VAR 0 11
88110: PPUSH
88111: LD_VAR 0 12
88115: PPUSH
88116: CALL_OW 351
88120: PUSH
88121: LD_VAR 0 11
88125: PPUSH
88126: LD_VAR 0 12
88130: PPUSH
88131: CALL_OW 554
88135: AND
88136: IFFALSE 88176
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
88138: LD_ADDR_VAR 0 13
88142: PUSH
88143: LD_VAR 0 13
88147: PPUSH
88148: LD_VAR 0 13
88152: PUSH
88153: LD_INT 1
88155: PLUS
88156: PPUSH
88157: LD_VAR 0 11
88161: PUSH
88162: LD_VAR 0 12
88166: PUSH
88167: EMPTY
88168: LIST
88169: LIST
88170: PPUSH
88171: CALL_OW 2
88175: ST_TO_ADDR
// end ;
88176: GO 88084
88178: POP
88179: POP
88180: GO 88064
88182: POP
88183: POP
// if not list then
88184: LD_VAR 0 13
88188: NOT
88189: IFFALSE 88193
// exit ;
88191: GO 88264
// for i in list do
88193: LD_ADDR_VAR 0 6
88197: PUSH
88198: LD_VAR 0 13
88202: PUSH
88203: FOR_IN
88204: IFFALSE 88262
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
88206: LD_VAR 0 1
88210: PPUSH
88211: LD_STRING M
88213: PUSH
88214: LD_VAR 0 6
88218: PUSH
88219: LD_INT 1
88221: ARRAY
88222: PUSH
88223: LD_VAR 0 6
88227: PUSH
88228: LD_INT 2
88230: ARRAY
88231: PUSH
88232: LD_INT 0
88234: PUSH
88235: LD_INT 0
88237: PUSH
88238: LD_INT 0
88240: PUSH
88241: LD_INT 0
88243: PUSH
88244: EMPTY
88245: LIST
88246: LIST
88247: LIST
88248: LIST
88249: LIST
88250: LIST
88251: LIST
88252: PUSH
88253: EMPTY
88254: LIST
88255: PPUSH
88256: CALL_OW 447
88260: GO 88203
88262: POP
88263: POP
// end ;
88264: LD_VAR 0 5
88268: RET
