// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 619 0 0
// InitMacro ;
  19: CALL 57524 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 49258 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 49258 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 49258 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 49258 0 9
// PrepareArabian ;
 147: CALL 3690 0 0
// PrepareRussian ;
 151: CALL 2825 0 0
// PrepareAlliance ;
 155: CALL 821 0 0
// MC_Start ( ) ;
 159: CALL 59636 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6853 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 83
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 84
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 80853 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 54
 252: PPUSH
 253: CALL 81279 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 81737 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 82006 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 81219 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 81913 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 51
 340: PPUSH
 341: CALL 81279 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 81737 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 82006 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 81063 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 22
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 3
 596: PUSH
 597: LD_INT 52
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL 81219 0 2
// end ;
 614: LD_VAR 0 1
 618: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 619: LD_INT 0
 621: PPUSH
// debug := 0 ;
 622: LD_ADDR_EXP 1
 626: PUSH
 627: LD_INT 0
 629: ST_TO_ADDR
// game := true ;
 630: LD_ADDR_EXP 2
 634: PUSH
 635: LD_INT 1
 637: ST_TO_ADDR
// gossudarov_arrive := false ;
 638: LD_ADDR_EXP 4
 642: PUSH
 643: LD_INT 0
 645: ST_TO_ADDR
// ru_lab_builded := false ;
 646: LD_ADDR_EXP 5
 650: PUSH
 651: LD_INT 0
 653: ST_TO_ADDR
// player_spotted := false ;
 654: LD_ADDR_EXP 6
 658: PUSH
 659: LD_INT 0
 661: ST_TO_ADDR
// first_attack := false ;
 662: LD_ADDR_EXP 7
 666: PUSH
 667: LD_INT 0
 669: ST_TO_ADDR
// ru_attackers := [ ] ;
 670: LD_ADDR_EXP 52
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// ar_base_spotted := false ;
 677: LD_ADDR_EXP 8
 681: PUSH
 682: LD_INT 0
 684: ST_TO_ADDR
// ar_active_attack := false ;
 685: LD_ADDR_EXP 9
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// ar_attackers := [ ] ;
 693: LD_ADDR_EXP 10
 697: PUSH
 698: EMPTY
 699: ST_TO_ADDR
// first_powell_attack := false ;
 700: LD_ADDR_EXP 11
 704: PUSH
 705: LD_INT 0
 707: ST_TO_ADDR
// abdul_escaped := true ;
 708: LD_ADDR_EXP 12
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// loss_counter := 0 ;
 716: LD_ADDR_EXP 13
 720: PUSH
 721: LD_INT 0
 723: ST_TO_ADDR
// hack_counter := 0 ;
 724: LD_ADDR_EXP 14
 728: PUSH
 729: LD_INT 0
 731: ST_TO_ADDR
// end ;
 732: LD_VAR 0 1
 736: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 737: LD_EXP 48
 741: PPUSH
 742: CALL_OW 255
 746: PUSH
 747: LD_INT 7
 749: EQUAL
 750: PUSH
 751: LD_EXP 47
 755: PPUSH
 756: CALL_OW 255
 760: PUSH
 761: LD_INT 7
 763: EQUAL
 764: AND
 765: PUSH
 766: LD_EXP 48
 770: PPUSH
 771: CALL_OW 302
 775: AND
 776: PUSH
 777: LD_EXP 47
 781: PPUSH
 782: CALL_OW 302
 786: AND
 787: IFFALSE 799
 789: GO 791
 791: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 792: LD_STRING ACH_COMRADE
 794: PPUSH
 795: CALL_OW 543
 799: END
// every 0 0$1 trigger hack_counter >= 10 do
 800: LD_EXP 14
 804: PUSH
 805: LD_INT 10
 807: GREATEREQUAL
 808: IFFALSE 820
 810: GO 812
 812: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 813: LD_STRING ACH_HACK
 815: PPUSH
 816: CALL_OW 543
 820: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 821: LD_INT 0
 823: PPUSH
 824: PPUSH
 825: PPUSH
 826: PPUSH
// uc_side := 7 ;
 827: LD_ADDR_OWVAR 20
 831: PUSH
 832: LD_INT 7
 834: ST_TO_ADDR
// uc_nation := 1 ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_INT 1
 842: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 843: LD_ADDR_EXP 15
 847: PUSH
 848: LD_STRING JMM
 850: PPUSH
 851: LD_EXP 1
 855: NOT
 856: PPUSH
 857: LD_STRING 12a_
 859: PPUSH
 860: CALL 14292 0 3
 864: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 865: LD_EXP 15
 869: PPUSH
 870: LD_INT 71
 872: PPUSH
 873: LD_INT 23
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 883: LD_EXP 15
 887: PPUSH
 888: LD_INT 2
 890: PPUSH
 891: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 895: LD_ADDR_EXP 16
 899: PUSH
 900: LD_STRING Roth
 902: PPUSH
 903: LD_EXP 1
 907: NOT
 908: PPUSH
 909: LD_STRING 12a_
 911: PPUSH
 912: CALL 14292 0 3
 916: ST_TO_ADDR
// if Roth then
 917: LD_EXP 16
 921: IFFALSE 941
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 923: LD_EXP 16
 927: PPUSH
 928: LD_INT 71
 930: PPUSH
 931: LD_INT 21
 933: PPUSH
 934: LD_INT 0
 936: PPUSH
 937: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING Lisa
 948: PPUSH
 949: LD_EXP 1
 953: NOT
 954: PPUSH
 955: LD_STRING 12a_
 957: PPUSH
 958: CALL 14292 0 3
 962: ST_TO_ADDR
// if Lisa then
 963: LD_EXP 17
 967: IFFALSE 984
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 969: LD_EXP 17
 973: PPUSH
 974: LD_INT 13
 976: PPUSH
 977: LD_INT 0
 979: PPUSH
 980: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 984: LD_ADDR_EXP 18
 988: PUSH
 989: LD_STRING Donaldson
 991: PPUSH
 992: LD_EXP 1
 996: NOT
 997: PPUSH
 998: LD_STRING 12a_
1000: PPUSH
1001: CALL 14292 0 3
1005: ST_TO_ADDR
// if Donaldson then
1006: LD_EXP 18
1010: IFFALSE 1027
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1012: LD_EXP 18
1016: PPUSH
1017: LD_INT 13
1019: PPUSH
1020: LD_INT 0
1022: PPUSH
1023: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1027: LD_ADDR_EXP 19
1031: PUSH
1032: LD_STRING Bobby
1034: PPUSH
1035: LD_EXP 1
1039: NOT
1040: PPUSH
1041: LD_STRING 12a_
1043: PPUSH
1044: CALL 14292 0 3
1048: ST_TO_ADDR
// if Bobby then
1049: LD_EXP 19
1053: IFFALSE 1070
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1055: LD_EXP 19
1059: PPUSH
1060: LD_INT 13
1062: PPUSH
1063: LD_INT 0
1065: PPUSH
1066: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1070: LD_ADDR_EXP 20
1074: PUSH
1075: LD_STRING Cyrus
1077: PPUSH
1078: LD_EXP 1
1082: NOT
1083: PPUSH
1084: LD_STRING 12a_
1086: PPUSH
1087: CALL 14292 0 3
1091: ST_TO_ADDR
// if Cyrus then
1092: LD_EXP 20
1096: IFFALSE 1113
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1098: LD_EXP 20
1102: PPUSH
1103: LD_INT 13
1105: PPUSH
1106: LD_INT 0
1108: PPUSH
1109: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1113: LD_ADDR_EXP 21
1117: PUSH
1118: LD_STRING Denis
1120: PPUSH
1121: LD_EXP 1
1125: NOT
1126: PPUSH
1127: LD_STRING 12a_
1129: PPUSH
1130: CALL 14292 0 3
1134: ST_TO_ADDR
// if Denis then
1135: LD_EXP 21
1139: IFFALSE 1156
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1141: LD_EXP 21
1145: PPUSH
1146: LD_INT 13
1148: PPUSH
1149: LD_INT 0
1151: PPUSH
1152: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1156: LD_ADDR_EXP 22
1160: PUSH
1161: LD_STRING Brown
1163: PPUSH
1164: LD_EXP 1
1168: NOT
1169: PPUSH
1170: LD_STRING 12a_
1172: PPUSH
1173: CALL 14292 0 3
1177: ST_TO_ADDR
// if Brown then
1178: LD_EXP 22
1182: IFFALSE 1199
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1184: LD_EXP 22
1188: PPUSH
1189: LD_INT 13
1191: PPUSH
1192: LD_INT 0
1194: PPUSH
1195: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1199: LD_ADDR_EXP 23
1203: PUSH
1204: LD_STRING Gladstone
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_STRING 12a_
1215: PPUSH
1216: CALL 14292 0 3
1220: ST_TO_ADDR
// if Gladstone then
1221: LD_EXP 23
1225: IFFALSE 1242
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1227: LD_EXP 23
1231: PPUSH
1232: LD_INT 13
1234: PPUSH
1235: LD_INT 0
1237: PPUSH
1238: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1242: LD_ADDR_EXP 24
1246: PUSH
1247: LD_STRING Houten
1249: PPUSH
1250: LD_EXP 1
1254: NOT
1255: PPUSH
1256: LD_STRING 12a_
1258: PPUSH
1259: CALL 14292 0 3
1263: ST_TO_ADDR
// if Houten then
1264: LD_EXP 24
1268: IFFALSE 1285
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1270: LD_EXP 24
1274: PPUSH
1275: LD_INT 13
1277: PPUSH
1278: LD_INT 0
1280: PPUSH
1281: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1285: LD_ADDR_EXP 25
1289: PUSH
1290: LD_STRING Cornell
1292: PPUSH
1293: LD_EXP 1
1297: NOT
1298: PPUSH
1299: LD_STRING 12a_
1301: PPUSH
1302: CALL 14292 0 3
1306: ST_TO_ADDR
// if Cornel then
1307: LD_EXP 25
1311: IFFALSE 1328
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1313: LD_EXP 25
1317: PPUSH
1318: LD_INT 13
1320: PPUSH
1321: LD_INT 0
1323: PPUSH
1324: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1328: LD_ADDR_EXP 26
1332: PUSH
1333: LD_STRING Gary
1335: PPUSH
1336: LD_EXP 1
1340: NOT
1341: PPUSH
1342: LD_STRING 12a_
1344: PPUSH
1345: CALL 14292 0 3
1349: ST_TO_ADDR
// if Gary then
1350: LD_EXP 26
1354: IFFALSE 1371
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1356: LD_EXP 26
1360: PPUSH
1361: LD_INT 13
1363: PPUSH
1364: LD_INT 0
1366: PPUSH
1367: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1371: LD_ADDR_EXP 27
1375: PUSH
1376: LD_STRING Frank
1378: PPUSH
1379: LD_EXP 1
1383: NOT
1384: PPUSH
1385: LD_STRING 12a_
1387: PPUSH
1388: CALL 14292 0 3
1392: ST_TO_ADDR
// if Frank then
1393: LD_EXP 27
1397: IFFALSE 1414
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1399: LD_EXP 27
1403: PPUSH
1404: LD_INT 13
1406: PPUSH
1407: LD_INT 0
1409: PPUSH
1410: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1414: LD_ADDR_EXP 28
1418: PUSH
1419: LD_STRING Kikuchi
1421: PPUSH
1422: LD_EXP 1
1426: NOT
1427: PPUSH
1428: LD_STRING 12a_
1430: PPUSH
1431: CALL 14292 0 3
1435: ST_TO_ADDR
// if Kikuchi then
1436: LD_EXP 28
1440: IFFALSE 1457
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1442: LD_EXP 28
1446: PPUSH
1447: LD_INT 13
1449: PPUSH
1450: LD_INT 0
1452: PPUSH
1453: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1457: LD_ADDR_EXP 29
1461: PUSH
1462: LD_STRING Simms
1464: PPUSH
1465: LD_EXP 1
1469: NOT
1470: PPUSH
1471: LD_STRING 12a_
1473: PPUSH
1474: CALL 14292 0 3
1478: ST_TO_ADDR
// if Simms then
1479: LD_EXP 29
1483: IFFALSE 1500
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1485: LD_EXP 29
1489: PPUSH
1490: LD_INT 13
1492: PPUSH
1493: LD_INT 0
1495: PPUSH
1496: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1500: LD_ADDR_EXP 30
1504: PUSH
1505: LD_STRING Joan
1507: PPUSH
1508: LD_EXP 1
1512: NOT
1513: PPUSH
1514: LD_STRING 12a_
1516: PPUSH
1517: CALL 14292 0 3
1521: ST_TO_ADDR
// if Joan then
1522: LD_EXP 30
1526: IFFALSE 1543
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1528: LD_EXP 30
1532: PPUSH
1533: LD_INT 13
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1543: LD_ADDR_EXP 31
1547: PUSH
1548: LD_STRING DeltaDoctor
1550: PPUSH
1551: LD_EXP 1
1555: NOT
1556: PPUSH
1557: LD_STRING 12a_
1559: PPUSH
1560: CALL 14292 0 3
1564: ST_TO_ADDR
// if DeltaDoctor then
1565: LD_EXP 31
1569: IFFALSE 1586
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1571: LD_EXP 31
1575: PPUSH
1576: LD_INT 13
1578: PPUSH
1579: LD_INT 0
1581: PPUSH
1582: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1586: LD_ADDR_VAR 0 4
1590: PUSH
1591: LD_STRING 12a_others
1593: PPUSH
1594: CALL_OW 31
1598: ST_TO_ADDR
// if tmp then
1599: LD_VAR 0 4
1603: IFFALSE 1637
// for i in tmp do
1605: LD_ADDR_VAR 0 3
1609: PUSH
1610: LD_VAR 0 4
1614: PUSH
1615: FOR_IN
1616: IFFALSE 1635
// PlaceUnitArea ( i , alliance_start , false ) ;
1618: LD_VAR 0 3
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
1633: GO 1615
1635: POP
1636: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 3
1642: PPUSH
1643: LD_INT 3
1645: PPUSH
1646: LD_INT 12
1648: PPUSH
1649: LD_INT 100
1651: PPUSH
1652: CALL 21467 0 5
// veh := CreateVehicle ;
1656: LD_ADDR_VAR 0 2
1660: PUSH
1661: CALL_OW 45
1665: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1666: LD_VAR 0 2
1670: PPUSH
1671: LD_INT 2
1673: PPUSH
1674: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1678: LD_VAR 0 2
1682: PPUSH
1683: LD_INT 60
1685: PPUSH
1686: LD_INT 6
1688: PPUSH
1689: LD_INT 0
1691: PPUSH
1692: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1696: LD_VAR 0 2
1700: PPUSH
1701: LD_INT 4
1703: PPUSH
1704: LD_INT 30
1706: PPUSH
1707: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1711: LD_STRING 11_artifact_captured
1713: PPUSH
1714: LD_INT 0
1716: PPUSH
1717: CALL_OW 30
1721: IFFALSE 1797
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1723: LD_INT 3
1725: PPUSH
1726: LD_INT 3
1728: PPUSH
1729: LD_INT 3
1731: PPUSH
1732: LD_INT 12
1734: PPUSH
1735: LD_INT 100
1737: PPUSH
1738: CALL 21467 0 5
// veh := CreateVehicle ;
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: CALL_OW 45
1751: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1752: LD_VAR 0 2
1756: PPUSH
1757: LD_INT 3
1759: PPUSH
1760: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1764: LD_VAR 0 2
1768: PPUSH
1769: LD_INT 75
1771: PPUSH
1772: LD_INT 6
1774: PPUSH
1775: LD_INT 0
1777: PPUSH
1778: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1782: LD_VAR 0 2
1786: PPUSH
1787: LD_INT 4
1789: PPUSH
1790: LD_INT 50
1792: PPUSH
1793: CALL_OW 290
// end ; end ;
1797: LD_VAR 0 1
1801: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1802: LD_INT 0
1804: PPUSH
1805: PPUSH
1806: PPUSH
1807: PPUSH
// uc_side := 6 ;
1808: LD_ADDR_OWVAR 20
1812: PUSH
1813: LD_INT 6
1815: ST_TO_ADDR
// uc_nation := 3 ;
1816: LD_ADDR_OWVAR 21
1820: PUSH
1821: LD_INT 3
1823: ST_TO_ADDR
// InitHc ;
1824: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1828: LD_ADDR_EXP 32
1832: PUSH
1833: LD_STRING Gossudarov
1835: PPUSH
1836: CALL_OW 25
1840: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1841: LD_ADDR_EXP 33
1845: PUSH
1846: LD_STRING Kirilenkova
1848: PPUSH
1849: CALL_OW 25
1853: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1854: LD_ADDR_EXP 34
1858: PUSH
1859: LD_STRING Titov
1861: PPUSH
1862: CALL_OW 25
1866: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1867: LD_ADDR_EXP 39
1871: PUSH
1872: LD_STRING Oblukov
1874: PPUSH
1875: CALL_OW 25
1879: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1880: LD_ADDR_EXP 36
1884: PUSH
1885: LD_STRING Dolgov
1887: PPUSH
1888: CALL_OW 25
1892: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1893: LD_ADDR_EXP 37
1897: PUSH
1898: LD_STRING Petrosyan
1900: PPUSH
1901: CALL_OW 25
1905: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1906: LD_ADDR_EXP 38
1910: PUSH
1911: LD_STRING Scholtze
1913: PPUSH
1914: CALL_OW 25
1918: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1919: LD_ADDR_EXP 40
1923: PUSH
1924: LD_STRING Kapitsova
1926: PPUSH
1927: CALL_OW 25
1931: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1932: LD_ADDR_VAR 0 2
1936: PUSH
1937: LD_EXP 32
1941: PUSH
1942: LD_EXP 33
1946: PUSH
1947: LD_EXP 34
1951: PUSH
1952: LD_EXP 39
1956: PUSH
1957: LD_EXP 36
1961: PUSH
1962: LD_EXP 37
1966: PUSH
1967: LD_EXP 38
1971: PUSH
1972: LD_EXP 40
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: LIST
1986: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1987: LD_INT 1
1989: PPUSH
1990: LD_INT 4
1992: PPUSH
1993: LD_INT 8
1995: PPUSH
1996: CALL_OW 380
// un := CreateHuman ;
2000: LD_ADDR_VAR 0 4
2004: PUSH
2005: CALL_OW 44
2009: ST_TO_ADDR
// tmp := tmp ^ un ;
2010: LD_ADDR_VAR 0 2
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_VAR 0 4
2024: ADD
2025: ST_TO_ADDR
// for i in tmp do
2026: LD_ADDR_VAR 0 3
2030: PUSH
2031: LD_VAR 0 2
2035: PUSH
2036: FOR_IN
2037: IFFALSE 2056
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2039: LD_VAR 0 3
2043: PPUSH
2044: LD_INT 14
2046: PPUSH
2047: LD_INT 0
2049: PPUSH
2050: CALL_OW 49
2054: GO 2036
2056: POP
2057: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_EXP 3
2067: PPUSH
2068: CALL_OW 250
2072: PPUSH
2073: LD_EXP 3
2077: PPUSH
2078: CALL_OW 251
2082: PPUSH
2083: CALL_OW 111
// end ;
2087: LD_VAR 0 1
2091: RET
// export function PrepareBelkov ; begin
2092: LD_INT 0
2094: PPUSH
// uc_side := 4 ;
2095: LD_ADDR_OWVAR 20
2099: PUSH
2100: LD_INT 4
2102: ST_TO_ADDR
// uc_nation := 3 ;
2103: LD_ADDR_OWVAR 21
2107: PUSH
2108: LD_INT 3
2110: ST_TO_ADDR
// InitHc ;
2111: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2115: LD_ADDR_EXP 47
2119: PUSH
2120: LD_STRING Belkov
2122: PPUSH
2123: CALL_OW 25
2127: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2128: LD_EXP 47
2132: PPUSH
2133: LD_INT 14
2135: PPUSH
2136: LD_INT 0
2138: PPUSH
2139: CALL_OW 49
// end ;
2143: LD_VAR 0 1
2147: RET
// export function PrepareGnyevko ; begin
2148: LD_INT 0
2150: PPUSH
// uc_side := 4 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 4
2158: ST_TO_ADDR
// uc_nation := 3 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 3
2166: ST_TO_ADDR
// InitHc ;
2167: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2171: LD_ADDR_EXP 48
2175: PUSH
2176: LD_STRING Gnyevko
2178: PPUSH
2179: CALL_OW 25
2183: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2184: LD_EXP 48
2188: PPUSH
2189: LD_INT 14
2191: PPUSH
2192: LD_INT 0
2194: PPUSH
2195: CALL_OW 49
// end ;
2199: LD_VAR 0 1
2203: RET
// export function PrepareBurlak ; var i , tmp ; begin
2204: LD_INT 0
2206: PPUSH
2207: PPUSH
2208: PPUSH
// uc_side := 4 ;
2209: LD_ADDR_OWVAR 20
2213: PUSH
2214: LD_INT 4
2216: ST_TO_ADDR
// uc_nation := 3 ;
2217: LD_ADDR_OWVAR 21
2221: PUSH
2222: LD_INT 3
2224: ST_TO_ADDR
// InitHc ;
2225: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2229: LD_ADDR_EXP 46
2233: PUSH
2234: LD_STRING Burlak
2236: PPUSH
2237: CALL_OW 25
2241: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2242: LD_INT 24
2244: PUSH
2245: LD_INT 23
2247: PUSH
2248: LD_INT 22
2250: PUSH
2251: EMPTY
2252: LIST
2253: LIST
2254: LIST
2255: PUSH
2256: LD_OWVAR 67
2260: ARRAY
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: LD_INT 1
2267: PPUSH
2268: LD_INT 45
2270: PUSH
2271: LD_INT 44
2273: PUSH
2274: LD_INT 43
2276: PUSH
2277: EMPTY
2278: LIST
2279: LIST
2280: LIST
2281: PUSH
2282: LD_OWVAR 67
2286: ARRAY
2287: PPUSH
2288: LD_INT 0
2290: PPUSH
2291: CALL 21467 0 5
// Masha := CreateVehicle ;
2295: LD_ADDR_EXP 49
2299: PUSH
2300: CALL_OW 45
2304: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2305: LD_EXP 49
2309: PUSH
2310: LD_EXP 46
2314: PUSH
2315: EMPTY
2316: LIST
2317: LIST
2318: PPUSH
2319: LD_INT 499
2321: PPUSH
2322: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2326: LD_EXP 49
2330: PPUSH
2331: LD_INT 3
2333: PPUSH
2334: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2338: LD_EXP 49
2342: PPUSH
2343: LD_INT 1
2345: PPUSH
2346: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2350: LD_INT 1
2352: PPUSH
2353: LD_INT 18
2355: PPUSH
2356: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2360: LD_INT 35
2362: PPUSH
2363: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 18
2374: PPUSH
2375: EMPTY
2376: PPUSH
2377: CALL_OW 70
2381: ST_TO_ADDR
// if tmp then
2382: LD_VAR 0 3
2386: IFFALSE 2420
// for i in tmp do
2388: LD_ADDR_VAR 0 2
2392: PUSH
2393: LD_VAR 0 3
2397: PUSH
2398: FOR_IN
2399: IFFALSE 2418
// ComMoveXY ( i , 114 , 9 ) ;
2401: LD_VAR 0 2
2405: PPUSH
2406: LD_INT 114
2408: PPUSH
2409: LD_INT 9
2411: PPUSH
2412: CALL_OW 111
2416: GO 2398
2418: POP
2419: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2420: LD_INT 18
2422: PPUSH
2423: EMPTY
2424: PPUSH
2425: CALL_OW 70
2429: NOT
2430: PUSH
2431: LD_INT 123
2433: PPUSH
2434: LD_INT 3
2436: PPUSH
2437: CALL_OW 428
2441: PUSH
2442: LD_INT 0
2444: EQUAL
2445: AND
2446: IFFALSE 2360
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2448: LD_EXP 49
2452: PPUSH
2453: LD_INT 123
2455: PPUSH
2456: LD_INT 3
2458: PPUSH
2459: LD_INT 0
2461: PPUSH
2462: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2466: LD_EXP 46
2470: PPUSH
2471: LD_INT 125
2473: PPUSH
2474: LD_INT 1
2476: PPUSH
2477: LD_INT 0
2479: PPUSH
2480: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2484: LD_EXP 46
2488: PPUSH
2489: LD_EXP 49
2493: PPUSH
2494: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2498: LD_INT 10
2500: PPUSH
2501: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2505: LD_EXP 49
2509: PPUSH
2510: LD_INT 110
2512: PPUSH
2513: LD_INT 10
2515: PPUSH
2516: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2520: LD_ADDR_EXP 42
2524: PUSH
2525: LD_STRING Petrovova
2527: PPUSH
2528: CALL_OW 25
2532: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2533: LD_ADDR_EXP 44
2537: PUSH
2538: LD_STRING Kuzmov
2540: PPUSH
2541: CALL_OW 25
2545: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2546: LD_ADDR_EXP 43
2550: PUSH
2551: LD_STRING Kovalyuk
2553: PPUSH
2554: CALL_OW 25
2558: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2559: LD_ADDR_EXP 41
2563: PUSH
2564: LD_STRING Lipshchin
2566: PPUSH
2567: CALL_OW 25
2571: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2572: LD_ADDR_EXP 45
2576: PUSH
2577: LD_STRING Karamazov
2579: PPUSH
2580: CALL_OW 25
2584: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2585: LD_ADDR_VAR 0 3
2589: PUSH
2590: LD_EXP 42
2594: PUSH
2595: LD_EXP 44
2599: PUSH
2600: LD_EXP 43
2604: PUSH
2605: LD_EXP 41
2609: PUSH
2610: LD_EXP 45
2614: PUSH
2615: EMPTY
2616: LIST
2617: LIST
2618: LIST
2619: LIST
2620: LIST
2621: ST_TO_ADDR
// for i in tmp do
2622: LD_ADDR_VAR 0 2
2626: PUSH
2627: LD_VAR 0 3
2631: PUSH
2632: FOR_IN
2633: IFFALSE 2672
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2635: LD_VAR 0 2
2639: PPUSH
2640: LD_INT 399
2642: PPUSH
2643: LD_INT 799
2645: PPUSH
2646: CALL_OW 12
2650: PPUSH
2651: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2655: LD_VAR 0 2
2659: PPUSH
2660: LD_INT 19
2662: PPUSH
2663: LD_INT 0
2665: PPUSH
2666: CALL_OW 49
// end ;
2670: GO 2632
2672: POP
2673: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2674: LD_VAR 0 3
2678: PPUSH
2679: LD_INT 116
2681: PPUSH
2682: LD_INT 8
2684: PPUSH
2685: CALL_OW 111
// AddComHold ( tmp ) ;
2689: LD_VAR 0 3
2693: PPUSH
2694: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2698: LD_ADDR_VAR 0 2
2702: PUSH
2703: LD_VAR 0 3
2707: PPUSH
2708: LD_INT 25
2710: PUSH
2711: LD_INT 1
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PPUSH
2718: CALL_OW 72
2722: PUSH
2723: FOR_IN
2724: IFFALSE 2764
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2726: LD_VAR 0 2
2730: PPUSH
2731: LD_INT 20
2733: PPUSH
2734: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2738: LD_VAR 0 2
2742: PPUSH
2743: LD_INT 147
2745: PPUSH
2746: LD_INT 45
2748: PPUSH
2749: CALL_OW 178
// AddComCrawl ( i ) ;
2753: LD_VAR 0 2
2757: PPUSH
2758: CALL_OW 197
// end ;
2762: GO 2723
2764: POP
2765: POP
// repeat wait ( 0 0$1 ) ;
2766: LD_INT 35
2768: PPUSH
2769: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2773: LD_EXP 49
2777: PPUSH
2778: LD_INT 110
2780: PPUSH
2781: LD_INT 10
2783: PPUSH
2784: CALL_OW 307
2788: PUSH
2789: LD_EXP 49
2793: PPUSH
2794: CALL_OW 305
2798: NOT
2799: OR
2800: IFFALSE 2766
// ComStop ( Burlak ) ;
2802: LD_EXP 46
2806: PPUSH
2807: CALL_OW 141
// AddComHold ( Burlak ) ;
2811: LD_EXP 46
2815: PPUSH
2816: CALL_OW 200
// end ; end_of_file
2820: LD_VAR 0 1
2824: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2825: LD_INT 0
2827: PPUSH
2828: PPUSH
2829: PPUSH
2830: PPUSH
// uc_side := 3 ;
2831: LD_ADDR_OWVAR 20
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// uc_nation := 3 ;
2839: LD_ADDR_OWVAR 21
2843: PUSH
2844: LD_INT 3
2846: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2847: LD_ADDR_EXP 50
2851: PUSH
2852: LD_INT 47
2854: PPUSH
2855: LD_INT 4
2857: PPUSH
2858: LD_STRING 
2860: PPUSH
2861: LD_INT 7
2863: PUSH
2864: LD_INT 8
2866: PUSH
2867: LD_INT 9
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: LIST
2874: PUSH
2875: LD_OWVAR 67
2879: ARRAY
2880: PPUSH
2881: LD_INT 10000
2883: PUSH
2884: LD_INT 3000
2886: PUSH
2887: LD_INT 300
2889: PUSH
2890: EMPTY
2891: LIST
2892: LIST
2893: LIST
2894: PPUSH
2895: LD_INT 9
2897: PUSH
2898: LD_INT 5
2900: PUSH
2901: LD_INT 6
2903: PUSH
2904: LD_INT 6
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: PPUSH
2913: CALL 24876 0 6
2917: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2918: LD_ADDR_EXP 59
2922: PUSH
2923: LD_EXP 59
2927: PPUSH
2928: LD_INT 2
2930: PPUSH
2931: LD_EXP 50
2935: PPUSH
2936: CALL_OW 1
2940: ST_TO_ADDR
// tmp := [ ] ;
2941: LD_ADDR_VAR 0 4
2945: PUSH
2946: EMPTY
2947: ST_TO_ADDR
// for i = 1 to 4 do
2948: LD_ADDR_VAR 0 2
2952: PUSH
2953: DOUBLE
2954: LD_INT 1
2956: DEC
2957: ST_TO_ADDR
2958: LD_INT 4
2960: PUSH
2961: FOR_TO
2962: IFFALSE 3055
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2964: LD_INT 22
2966: PPUSH
2967: LD_INT 3
2969: PPUSH
2970: LD_INT 3
2972: PPUSH
2973: LD_INT 43
2975: PUSH
2976: LD_INT 45
2978: PUSH
2979: LD_INT 45
2981: PUSH
2982: LD_INT 44
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: PUSH
2991: LD_VAR 0 2
2995: PUSH
2996: LD_INT 4
2998: MOD
2999: PUSH
3000: LD_INT 1
3002: PLUS
3003: ARRAY
3004: PPUSH
3005: LD_INT 100
3007: PPUSH
3008: CALL 21467 0 5
// veh := CreateVehicle ;
3012: LD_ADDR_VAR 0 3
3016: PUSH
3017: CALL_OW 45
3021: ST_TO_ADDR
// tmp := tmp ^ veh ;
3022: LD_ADDR_VAR 0 4
3026: PUSH
3027: LD_VAR 0 4
3031: PUSH
3032: LD_VAR 0 3
3036: ADD
3037: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3038: LD_VAR 0 3
3042: PPUSH
3043: LD_INT 2
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 49
// end ;
3053: GO 2961
3055: POP
3056: POP
// russian_guard := tmp ;
3057: LD_ADDR_EXP 51
3061: PUSH
3062: LD_VAR 0 4
3066: ST_TO_ADDR
// end ;
3067: LD_VAR 0 1
3071: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
3072: LD_INT 47
3074: PPUSH
3075: CALL_OW 302
3079: PUSH
3080: LD_EXP 6
3084: AND
3085: IFFALSE 3687
3087: GO 3089
3089: DISABLE
3090: LD_INT 0
3092: PPUSH
3093: PPUSH
3094: PPUSH
3095: PPUSH
3096: PPUSH
3097: PPUSH
// begin enable ;
3098: ENABLE
// base := 2 ;
3099: LD_ADDR_VAR 0 2
3103: PUSH
3104: LD_INT 2
3106: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3107: LD_ADDR_VAR 0 4
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: LD_INT 0
3117: PUSH
3118: LD_INT 0
3120: PUSH
3121: LD_INT 0
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 0
3129: PUSH
3130: LD_INT 0
3132: PUSH
3133: LD_INT 0
3135: PUSH
3136: LD_INT 1
3138: PUSH
3139: LD_INT 0
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3154: LD_ADDR_VAR 0 3
3158: PUSH
3159: LD_INT 22
3161: PUSH
3162: LD_INT 1
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: LD_INT 45
3170: PUSH
3171: EMPTY
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: PUSH
3177: LD_INT 21
3179: PUSH
3180: LD_INT 1
3182: PUSH
3183: LD_INT 3
3185: PUSH
3186: LD_INT 45
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 22
3197: PUSH
3198: LD_INT 1
3200: PUSH
3201: LD_INT 3
3203: PUSH
3204: LD_INT 45
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 23
3215: PUSH
3216: LD_INT 1
3218: PUSH
3219: LD_INT 3
3221: PUSH
3222: LD_INT 46
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: LIST
3229: LIST
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: LIST
3235: LIST
3236: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3237: LD_ADDR_VAR 0 1
3241: PUSH
3242: DOUBLE
3243: LD_INT 1
3245: DEC
3246: ST_TO_ADDR
3247: LD_OWVAR 67
3251: PUSH
3252: LD_OWVAR 1
3256: PUSH
3257: LD_INT 21000
3259: DIV
3260: PLUS
3261: PUSH
3262: FOR_TO
3263: IFFALSE 3351
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3265: LD_ADDR_VAR 0 3
3269: PUSH
3270: LD_VAR 0 3
3274: PPUSH
3275: LD_VAR 0 3
3279: PUSH
3280: LD_INT 1
3282: PLUS
3283: PPUSH
3284: LD_INT 23
3286: PUSH
3287: LD_INT 24
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: LD_INT 1
3296: PPUSH
3297: LD_INT 2
3299: PPUSH
3300: CALL_OW 12
3304: ARRAY
3305: PUSH
3306: LD_INT 1
3308: PUSH
3309: LD_INT 3
3311: PUSH
3312: LD_INT 46
3314: PUSH
3315: LD_INT 47
3317: PUSH
3318: LD_INT 45
3320: PUSH
3321: EMPTY
3322: LIST
3323: LIST
3324: LIST
3325: PUSH
3326: LD_INT 1
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: CALL_OW 12
3336: ARRAY
3337: PUSH
3338: EMPTY
3339: LIST
3340: LIST
3341: LIST
3342: LIST
3343: PPUSH
3344: CALL_OW 2
3348: ST_TO_ADDR
3349: GO 3262
3351: POP
3352: POP
// MC_InsertProduceList ( base , tmp ) ;
3353: LD_VAR 0 2
3357: PPUSH
3358: LD_VAR 0 3
3362: PPUSH
3363: CALL 81219 0 2
// repeat wait ( 0 0$1 ) ;
3367: LD_INT 35
3369: PPUSH
3370: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3374: LD_EXP 78
3378: PUSH
3379: LD_VAR 0 2
3383: ARRAY
3384: PUSH
3385: LD_INT 6
3387: GREATER
3388: IFFALSE 3367
// wait ( 0 0$20 ) ;
3390: LD_INT 700
3392: PPUSH
3393: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3397: LD_ADDR_VAR 0 5
3401: PUSH
3402: LD_INT 71
3404: PUSH
3405: LD_INT 19
3407: PUSH
3408: EMPTY
3409: LIST
3410: LIST
3411: PUSH
3412: LD_INT 91
3414: PUSH
3415: LD_INT 67
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: PUSH
3422: LD_INT 52
3424: PUSH
3425: LD_INT 44
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PUSH
3432: LD_INT 68
3434: PUSH
3435: LD_INT 48
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3448: LD_ADDR_VAR 0 6
3452: PUSH
3453: LD_EXP 78
3457: PUSH
3458: LD_VAR 0 2
3462: ARRAY
3463: PUSH
3464: LD_EXP 78
3468: PUSH
3469: LD_VAR 0 2
3473: ARRAY
3474: PPUSH
3475: LD_INT 2
3477: PUSH
3478: LD_INT 34
3480: PUSH
3481: LD_INT 51
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: PUSH
3488: LD_INT 34
3490: PUSH
3491: LD_INT 52
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: LIST
3502: PPUSH
3503: CALL_OW 72
3507: DIFF
3508: ST_TO_ADDR
// if not attackers then
3509: LD_VAR 0 6
3513: NOT
3514: IFFALSE 3518
// exit ;
3516: GO 3687
// ru_attackers := attackers ;
3518: LD_ADDR_EXP 52
3522: PUSH
3523: LD_VAR 0 6
3527: ST_TO_ADDR
// for i = 1 to attackers do
3528: LD_ADDR_VAR 0 1
3532: PUSH
3533: DOUBLE
3534: LD_INT 1
3536: DEC
3537: ST_TO_ADDR
3538: LD_VAR 0 6
3542: PUSH
3543: FOR_TO
3544: IFFALSE 3621
// begin case i mod 3 of 0 :
3546: LD_VAR 0 1
3550: PUSH
3551: LD_INT 3
3553: MOD
3554: PUSH
3555: LD_INT 0
3557: DOUBLE
3558: EQUAL
3559: IFTRUE 3563
3561: GO 3566
3563: POP
// ; 1 :
3564: GO 3619
3566: LD_INT 1
3568: DOUBLE
3569: EQUAL
3570: IFTRUE 3574
3572: GO 3592
3574: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3575: LD_VAR 0 1
3579: PPUSH
3580: LD_INT 32
3582: PPUSH
3583: LD_INT 49
3585: PPUSH
3586: CALL_OW 114
3590: GO 3619
3592: LD_INT 2
3594: DOUBLE
3595: EQUAL
3596: IFTRUE 3600
3598: GO 3618
3600: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3601: LD_VAR 0 1
3605: PPUSH
3606: LD_INT 117
3608: PPUSH
3609: LD_INT 107
3611: PPUSH
3612: CALL_OW 114
3616: GO 3619
3618: POP
// end ;
3619: GO 3543
3621: POP
3622: POP
// repeat wait ( 0 0$1 ) ;
3623: LD_INT 35
3625: PPUSH
3626: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3630: LD_VAR 0 6
3634: PPUSH
3635: LD_INT 60
3637: PUSH
3638: EMPTY
3639: LIST
3640: PPUSH
3641: CALL_OW 72
3645: NOT
3646: IFFALSE 3623
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3648: LD_VAR 0 2
3652: PPUSH
3653: LD_VAR 0 6
3657: PPUSH
3658: LD_VAR 0 5
3662: PPUSH
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL 81404 0 4
// if not first_attack then
3672: LD_EXP 7
3676: NOT
3677: IFFALSE 3687
// first_attack := true ;
3679: LD_ADDR_EXP 7
3683: PUSH
3684: LD_INT 1
3686: ST_TO_ADDR
// end ; end_of_file
3687: PPOPN 6
3689: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3690: LD_INT 0
3692: PPUSH
3693: PPUSH
3694: PPUSH
3695: PPUSH
3696: PPUSH
3697: PPUSH
3698: PPUSH
// uc_side := 2 ;
3699: LD_ADDR_OWVAR 20
3703: PUSH
3704: LD_INT 2
3706: ST_TO_ADDR
// uc_nation := 2 ;
3707: LD_ADDR_OWVAR 21
3711: PUSH
3712: LD_INT 2
3714: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3715: LD_ADDR_EXP 55
3719: PUSH
3720: LD_STRING Abdul
3722: PPUSH
3723: CALL_OW 25
3727: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3728: LD_EXP 55
3732: PPUSH
3733: LD_INT 11
3735: PPUSH
3736: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3740: LD_EXP 55
3744: PPUSH
3745: LD_INT 1
3747: PPUSH
3748: CALL_OW 52
// vc_chassis := 31 ;
3752: LD_ADDR_OWVAR 37
3756: PUSH
3757: LD_INT 31
3759: ST_TO_ADDR
// vc_control := control_rider ;
3760: LD_ADDR_OWVAR 38
3764: PUSH
3765: LD_INT 4
3767: ST_TO_ADDR
// mastodont := CreateVehicle ;
3768: LD_ADDR_EXP 56
3772: PUSH
3773: CALL_OW 45
3777: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3778: LD_EXP 56
3782: PPUSH
3783: LD_INT 153
3785: PPUSH
3786: LD_INT 71
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// InitVc ;
3796: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3800: LD_ADDR_EXP 53
3804: PUSH
3805: LD_INT 1
3807: PPUSH
3808: LD_INT 3
3810: PPUSH
3811: LD_STRING 
3813: PPUSH
3814: LD_INT 7
3816: PUSH
3817: LD_INT 8
3819: PUSH
3820: LD_INT 9
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: PUSH
3828: LD_OWVAR 67
3832: ARRAY
3833: PPUSH
3834: LD_INT 5000
3836: PUSH
3837: LD_INT 1000
3839: PUSH
3840: LD_INT 300
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: PPUSH
3848: LD_INT 22
3850: PUSH
3851: LD_INT 5
3853: PUSH
3854: LD_INT 6
3856: PUSH
3857: LD_INT 9
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: LIST
3864: LIST
3865: PPUSH
3866: CALL 24876 0 6
3870: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3871: LD_ADDR_EXP 59
3875: PUSH
3876: LD_EXP 59
3880: PPUSH
3881: LD_INT 1
3883: PPUSH
3884: LD_EXP 53
3888: PPUSH
3889: CALL_OW 1
3893: ST_TO_ADDR
// tmp := [ ] ;
3894: LD_ADDR_VAR 0 4
3898: PUSH
3899: EMPTY
3900: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3901: LD_ADDR_OWVAR 37
3905: PUSH
3906: LD_INT 14
3908: ST_TO_ADDR
// vc_engine := engine_siberite ;
3909: LD_ADDR_OWVAR 39
3913: PUSH
3914: LD_INT 3
3916: ST_TO_ADDR
// vc_control := control_manual ;
3917: LD_ADDR_OWVAR 38
3921: PUSH
3922: LD_INT 1
3924: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3925: LD_ADDR_OWVAR 40
3929: PUSH
3930: LD_INT 31
3932: ST_TO_ADDR
// for i = 1 to 3 do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: DOUBLE
3939: LD_INT 1
3941: DEC
3942: ST_TO_ADDR
3943: LD_INT 3
3945: PUSH
3946: FOR_TO
3947: IFFALSE 4191
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3949: LD_ADDR_VAR 0 5
3953: PUSH
3954: LD_INT 153
3956: PUSH
3957: LD_INT 71
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PUSH
3964: LD_INT 155
3966: PUSH
3967: LD_INT 81
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PUSH
3978: LD_VAR 0 2
3982: PUSH
3983: LD_INT 2
3985: MOD
3986: PUSH
3987: LD_INT 1
3989: PLUS
3990: ARRAY
3991: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3992: LD_INT 0
3994: PPUSH
3995: LD_INT 3
3997: PPUSH
3998: LD_INT 7
4000: PUSH
4001: LD_INT 8
4003: PUSH
4004: LD_INT 9
4006: PUSH
4007: EMPTY
4008: LIST
4009: LIST
4010: LIST
4011: PUSH
4012: LD_OWVAR 67
4016: ARRAY
4017: PPUSH
4018: CALL_OW 380
// un := CreateVehicle ;
4022: LD_ADDR_VAR 0 6
4026: PUSH
4027: CALL_OW 45
4031: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4032: LD_VAR 0 6
4036: PPUSH
4037: LD_INT 0
4039: PPUSH
4040: LD_INT 5
4042: PPUSH
4043: CALL_OW 12
4047: PPUSH
4048: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4052: LD_VAR 0 6
4056: PPUSH
4057: LD_VAR 0 5
4061: PUSH
4062: LD_INT 1
4064: ARRAY
4065: PPUSH
4066: LD_VAR 0 5
4070: PUSH
4071: LD_INT 2
4073: ARRAY
4074: PPUSH
4075: LD_INT 6
4077: PPUSH
4078: LD_INT 0
4080: PPUSH
4081: CALL_OW 50
// un2 := CreateHuman ;
4085: LD_ADDR_VAR 0 7
4089: PUSH
4090: CALL_OW 44
4094: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4095: LD_VAR 0 7
4099: PPUSH
4100: LD_VAR 0 6
4104: PPUSH
4105: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4109: LD_ADDR_EXP 59
4113: PUSH
4114: LD_EXP 59
4118: PPUSH
4119: LD_INT 1
4121: PUSH
4122: LD_EXP 59
4126: PUSH
4127: LD_INT 1
4129: ARRAY
4130: PUSH
4131: LD_INT 1
4133: PLUS
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: PPUSH
4139: LD_VAR 0 6
4143: PPUSH
4144: CALL 21589 0 3
4148: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4149: LD_ADDR_EXP 59
4153: PUSH
4154: LD_EXP 59
4158: PPUSH
4159: LD_INT 1
4161: PUSH
4162: LD_EXP 59
4166: PUSH
4167: LD_INT 1
4169: ARRAY
4170: PUSH
4171: LD_INT 1
4173: PLUS
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: PPUSH
4179: LD_VAR 0 7
4183: PPUSH
4184: CALL 21589 0 3
4188: ST_TO_ADDR
// end ;
4189: GO 3946
4191: POP
4192: POP
// for i = 1 to 5 do
4193: LD_ADDR_VAR 0 2
4197: PUSH
4198: DOUBLE
4199: LD_INT 1
4201: DEC
4202: ST_TO_ADDR
4203: LD_INT 5
4205: PUSH
4206: FOR_TO
4207: IFFALSE 4300
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4209: LD_INT 14
4211: PPUSH
4212: LD_INT 3
4214: PPUSH
4215: LD_INT 1
4217: PPUSH
4218: LD_INT 25
4220: PUSH
4221: LD_INT 28
4223: PUSH
4224: LD_INT 28
4226: PUSH
4227: LD_INT 26
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: LIST
4235: PUSH
4236: LD_VAR 0 2
4240: PUSH
4241: LD_INT 4
4243: MOD
4244: PUSH
4245: LD_INT 1
4247: PLUS
4248: ARRAY
4249: PPUSH
4250: LD_INT 100
4252: PPUSH
4253: CALL 21467 0 5
// veh := CreateVehicle ;
4257: LD_ADDR_VAR 0 3
4261: PUSH
4262: CALL_OW 45
4266: ST_TO_ADDR
// tmp := tmp ^ veh ;
4267: LD_ADDR_VAR 0 4
4271: PUSH
4272: LD_VAR 0 4
4276: PUSH
4277: LD_VAR 0 3
4281: ADD
4282: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4283: LD_VAR 0 3
4287: PPUSH
4288: LD_INT 1
4290: PPUSH
4291: LD_INT 0
4293: PPUSH
4294: CALL_OW 49
// end ;
4298: GO 4206
4300: POP
4301: POP
// arabian_guard := tmp ;
4302: LD_ADDR_EXP 54
4306: PUSH
4307: LD_VAR 0 4
4311: ST_TO_ADDR
// end ;
4312: LD_VAR 0 1
4316: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4317: LD_INT 22
4319: PUSH
4320: LD_INT 7
4322: PUSH
4323: EMPTY
4324: LIST
4325: LIST
4326: PUSH
4327: LD_INT 91
4329: PUSH
4330: LD_INT 1
4332: PUSH
4333: LD_INT 12
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: PPUSH
4345: CALL_OW 69
4349: PUSH
4350: LD_EXP 56
4354: PPUSH
4355: CALL_OW 256
4359: PUSH
4360: LD_INT 990
4362: LESS
4363: OR
4364: PUSH
4365: LD_EXP 55
4369: PPUSH
4370: CALL_OW 256
4374: PUSH
4375: LD_INT 990
4377: LESS
4378: OR
4379: IFFALSE 4522
4381: GO 4383
4383: DISABLE
// begin if IsInUnit ( Abdul ) then
4384: LD_EXP 55
4388: PPUSH
4389: CALL_OW 310
4393: IFFALSE 4404
// ComExitBuilding ( Abdul ) ;
4395: LD_EXP 55
4399: PPUSH
4400: CALL_OW 122
// if Mastodont then
4404: LD_EXP 56
4408: IFFALSE 4425
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4410: LD_EXP 56
4414: PPUSH
4415: LD_INT 205
4417: PPUSH
4418: LD_INT 132
4420: PPUSH
4421: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4425: LD_EXP 55
4429: PPUSH
4430: LD_INT 205
4432: PPUSH
4433: LD_INT 132
4435: PPUSH
4436: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4440: LD_INT 35
4442: PPUSH
4443: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4447: LD_EXP 55
4451: PPUSH
4452: LD_INT 21
4454: PPUSH
4455: CALL_OW 308
4459: IFFALSE 4440
// RemoveUnit ( Abdul ) ;
4461: LD_EXP 55
4465: PPUSH
4466: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4470: LD_INT 35
4472: PPUSH
4473: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4477: LD_EXP 56
4481: PPUSH
4482: LD_INT 21
4484: PPUSH
4485: CALL_OW 308
4489: PUSH
4490: LD_EXP 56
4494: PPUSH
4495: CALL_OW 301
4499: OR
4500: IFFALSE 4470
// if IsOk ( Mastodont ) then
4502: LD_EXP 56
4506: PPUSH
4507: CALL_OW 302
4511: IFFALSE 4522
// RemoveUnit ( Mastodont ) ;
4513: LD_EXP 56
4517: PPUSH
4518: CALL_OW 64
// end ;
4522: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4523: LD_EXP 55
4527: PPUSH
4528: CALL_OW 301
4532: PUSH
4533: LD_INT 22
4535: PUSH
4536: LD_INT 2
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: PUSH
4543: LD_INT 2
4545: PUSH
4546: LD_INT 25
4548: PUSH
4549: LD_INT 1
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 25
4558: PUSH
4559: LD_INT 2
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 25
4568: PUSH
4569: LD_INT 3
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: LD_INT 25
4578: PUSH
4579: LD_INT 4
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PUSH
4586: LD_INT 25
4588: PUSH
4589: LD_INT 8
4591: PUSH
4592: EMPTY
4593: LIST
4594: LIST
4595: PUSH
4596: EMPTY
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: PPUSH
4608: CALL_OW 69
4612: PUSH
4613: LD_INT 16
4615: PUSH
4616: LD_INT 19
4618: PUSH
4619: LD_INT 22
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: LIST
4626: PUSH
4627: LD_OWVAR 67
4631: ARRAY
4632: LESS
4633: OR
4634: IFFALSE 5307
4636: GO 4638
4638: DISABLE
4639: LD_INT 0
4641: PPUSH
4642: PPUSH
4643: PPUSH
4644: PPUSH
4645: PPUSH
4646: PPUSH
// begin MC_Kill ( 1 ) ;
4647: LD_INT 1
4649: PPUSH
4650: CALL 57759 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4654: LD_ADDR_VAR 0 2
4658: PUSH
4659: LD_INT 22
4661: PUSH
4662: LD_INT 2
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: LD_INT 25
4674: PUSH
4675: LD_INT 1
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: LD_INT 25
4684: PUSH
4685: LD_INT 2
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: PUSH
4692: LD_INT 25
4694: PUSH
4695: LD_INT 3
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PUSH
4702: LD_INT 25
4704: PUSH
4705: LD_INT 4
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: LD_INT 25
4714: PUSH
4715: LD_INT 8
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PPUSH
4734: CALL_OW 69
4738: ST_TO_ADDR
// for i in tmp do
4739: LD_ADDR_VAR 0 5
4743: PUSH
4744: LD_VAR 0 2
4748: PUSH
4749: FOR_IN
4750: IFFALSE 4766
// SetTag ( i , 10 ) ;
4752: LD_VAR 0 5
4756: PPUSH
4757: LD_INT 10
4759: PPUSH
4760: CALL_OW 109
4764: GO 4749
4766: POP
4767: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4768: LD_ADDR_VAR 0 3
4772: PUSH
4773: LD_INT 22
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: LD_INT 21
4785: PUSH
4786: LD_INT 1
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: PPUSH
4797: CALL_OW 69
4801: PUSH
4802: LD_VAR 0 2
4806: DIFF
4807: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4808: LD_ADDR_VAR 0 1
4812: PUSH
4813: LD_INT 22
4815: PUSH
4816: LD_INT 2
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: LD_INT 21
4825: PUSH
4826: LD_INT 2
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: PUSH
4833: LD_INT 24
4835: PUSH
4836: LD_INT 300
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: LIST
4847: PPUSH
4848: CALL_OW 69
4852: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4853: LD_ADDR_VAR 0 4
4857: PUSH
4858: LD_VAR 0 1
4862: PPUSH
4863: LD_INT 33
4865: PUSH
4866: LD_INT 1
4868: PUSH
4869: EMPTY
4870: LIST
4871: LIST
4872: PUSH
4873: LD_INT 58
4875: PUSH
4876: EMPTY
4877: LIST
4878: PUSH
4879: EMPTY
4880: LIST
4881: LIST
4882: PPUSH
4883: CALL_OW 72
4887: ST_TO_ADDR
// for i in tmp do
4888: LD_ADDR_VAR 0 5
4892: PUSH
4893: LD_VAR 0 2
4897: PUSH
4898: FOR_IN
4899: IFFALSE 5083
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4901: LD_VAR 0 5
4905: PUSH
4906: LD_INT 55
4908: PUSH
4909: EMPTY
4910: LIST
4911: PPUSH
4912: CALL_OW 69
4916: IN
4917: IFFALSE 4936
// begin AddComMoveXY ( i , 209 , 132 ) ;
4919: LD_VAR 0 5
4923: PPUSH
4924: LD_INT 209
4926: PPUSH
4927: LD_INT 132
4929: PPUSH
4930: CALL_OW 171
// continue ;
4934: GO 4898
// end ; if IsInUnit ( i ) then
4936: LD_VAR 0 5
4940: PPUSH
4941: CALL_OW 310
4945: IFFALSE 4963
// begin ComExitBuilding ( i ) ;
4947: LD_VAR 0 5
4951: PPUSH
4952: CALL_OW 122
// wait ( 3 ) ;
4956: LD_INT 3
4958: PPUSH
4959: CALL_OW 67
// end ; if tmp_empty then
4963: LD_VAR 0 4
4967: IFFALSE 5066
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4969: LD_VAR 0 5
4973: PPUSH
4974: LD_VAR 0 4
4978: PPUSH
4979: LD_VAR 0 5
4983: PPUSH
4984: CALL_OW 74
4988: PPUSH
4989: CALL_OW 296
4993: PUSH
4994: LD_INT 25
4996: LESS
4997: IFFALSE 5066
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4999: LD_ADDR_VAR 0 6
5003: PUSH
5004: LD_VAR 0 4
5008: PPUSH
5009: LD_VAR 0 5
5013: PPUSH
5014: CALL_OW 74
5018: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5019: LD_VAR 0 5
5023: PPUSH
5024: LD_VAR 0 6
5028: PPUSH
5029: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5033: LD_VAR 0 5
5037: PPUSH
5038: LD_INT 209
5040: PPUSH
5041: LD_INT 132
5043: PPUSH
5044: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5048: LD_ADDR_VAR 0 4
5052: PUSH
5053: LD_VAR 0 4
5057: PUSH
5058: LD_VAR 0 6
5062: DIFF
5063: ST_TO_ADDR
// continue ;
5064: GO 4898
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5066: LD_VAR 0 5
5070: PPUSH
5071: LD_INT 201
5073: PPUSH
5074: LD_INT 132
5076: PPUSH
5077: CALL_OW 171
// end ;
5081: GO 4898
5083: POP
5084: POP
// for i in tmp_ape do
5085: LD_ADDR_VAR 0 5
5089: PUSH
5090: LD_VAR 0 3
5094: PUSH
5095: FOR_IN
5096: IFFALSE 5135
// begin if IsInUnit ( i ) then
5098: LD_VAR 0 5
5102: PPUSH
5103: CALL_OW 310
5107: IFFALSE 5118
// ComExitBuilding ( i ) ;
5109: LD_VAR 0 5
5113: PPUSH
5114: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5118: LD_VAR 0 5
5122: PPUSH
5123: LD_INT 201
5125: PPUSH
5126: LD_INT 132
5128: PPUSH
5129: CALL_OW 171
// end ;
5133: GO 5095
5135: POP
5136: POP
// repeat wait ( 0 0$1 ) ;
5137: LD_INT 35
5139: PPUSH
5140: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5144: LD_ADDR_VAR 0 5
5148: PUSH
5149: LD_VAR 0 2
5153: PUSH
5154: LD_VAR 0 3
5158: UNION
5159: PUSH
5160: LD_VAR 0 1
5164: UNION
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5198
// if not HasTask ( i ) then
5169: LD_VAR 0 5
5173: PPUSH
5174: CALL_OW 314
5178: NOT
5179: IFFALSE 5196
// ComMoveXY ( i , 201 , 132 ) ;
5181: LD_VAR 0 5
5185: PPUSH
5186: LD_INT 201
5188: PPUSH
5189: LD_INT 132
5191: PPUSH
5192: CALL_OW 111
5196: GO 5166
5198: POP
5199: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5200: LD_INT 21
5202: PPUSH
5203: LD_INT 22
5205: PUSH
5206: LD_INT 2
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL_OW 70
5217: IFFALSE 5258
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5219: LD_ADDR_VAR 0 5
5223: PUSH
5224: LD_INT 21
5226: PPUSH
5227: LD_INT 22
5229: PUSH
5230: LD_INT 2
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: PPUSH
5237: CALL_OW 70
5241: PUSH
5242: FOR_IN
5243: IFFALSE 5256
// RemoveUnit ( i ) ;
5245: LD_VAR 0 5
5249: PPUSH
5250: CALL_OW 64
5254: GO 5242
5256: POP
5257: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5258: LD_INT 22
5260: PUSH
5261: LD_INT 2
5263: PUSH
5264: EMPTY
5265: LIST
5266: LIST
5267: PUSH
5268: LD_INT 2
5270: PUSH
5271: LD_INT 21
5273: PUSH
5274: LD_INT 1
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PUSH
5281: LD_INT 21
5283: PUSH
5284: LD_INT 2
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: LIST
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 69
5304: NOT
5305: IFFALSE 5137
// end ;
5307: PPOPN 6
5309: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5310: LD_EXP 9
5314: PUSH
5315: LD_INT 92
5317: PPUSH
5318: LD_INT 40
5320: PPUSH
5321: CALL_OW 428
5325: PPUSH
5326: CALL_OW 266
5330: PUSH
5331: LD_INT 30
5333: EQUAL
5334: AND
5335: IFFALSE 5531
5337: GO 5339
5339: DISABLE
5340: LD_INT 0
5342: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5343: LD_ADDR_VAR 0 1
5347: PUSH
5348: LD_EXP 59
5352: PUSH
5353: LD_INT 1
5355: ARRAY
5356: PPUSH
5357: LD_INT 25
5359: PUSH
5360: LD_INT 4
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PPUSH
5367: CALL_OW 72
5371: ST_TO_ADDR
// if not sci then
5372: LD_VAR 0 1
5376: NOT
5377: IFFALSE 5381
// exit ;
5379: GO 5531
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5381: LD_ADDR_EXP 59
5385: PUSH
5386: LD_EXP 59
5390: PPUSH
5391: LD_INT 1
5393: PPUSH
5394: LD_EXP 59
5398: PUSH
5399: LD_INT 1
5401: ARRAY
5402: PUSH
5403: LD_VAR 0 1
5407: PUSH
5408: LD_INT 1
5410: ARRAY
5411: DIFF
5412: PPUSH
5413: CALL_OW 1
5417: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5418: LD_VAR 0 1
5422: PUSH
5423: LD_INT 1
5425: ARRAY
5426: PPUSH
5427: CALL_OW 310
5431: IFFALSE 5446
// ComExitBuilding ( sci [ 1 ] ) ;
5433: LD_VAR 0 1
5437: PUSH
5438: LD_INT 1
5440: ARRAY
5441: PPUSH
5442: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5446: LD_INT 2
5448: PPUSH
5449: LD_INT 105
5451: PPUSH
5452: LD_INT 14
5454: PPUSH
5455: LD_INT 20
5457: PPUSH
5458: CALL 22485 0 4
5462: PUSH
5463: LD_INT 4
5465: ARRAY
5466: PUSH
5467: LD_INT 10
5469: LESS
5470: IFFALSE 5493
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5472: LD_VAR 0 1
5476: PUSH
5477: LD_INT 1
5479: ARRAY
5480: PPUSH
5481: LD_INT 105
5483: PPUSH
5484: LD_INT 14
5486: PPUSH
5487: CALL_OW 171
5491: GO 5512
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5493: LD_VAR 0 1
5497: PUSH
5498: LD_INT 1
5500: ARRAY
5501: PPUSH
5502: LD_INT 118
5504: PPUSH
5505: LD_INT 77
5507: PPUSH
5508: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5512: LD_VAR 0 1
5516: PUSH
5517: LD_INT 1
5519: ARRAY
5520: PPUSH
5521: LD_INT 92
5523: PPUSH
5524: LD_INT 40
5526: PPUSH
5527: CALL_OW 218
// end ;
5531: PPOPN 1
5533: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5534: LD_INT 1
5536: PPUSH
5537: CALL_OW 302
5541: PUSH
5542: LD_EXP 9
5546: AND
5547: IFFALSE 6006
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
5557: PPUSH
5558: PPUSH
5559: PPUSH
// begin enable ;
5560: ENABLE
// base := 1 ;
5561: LD_ADDR_VAR 0 2
5565: PUSH
5566: LD_INT 1
5568: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5569: LD_ADDR_VAR 0 4
5573: PUSH
5574: LD_INT 0
5576: PUSH
5577: LD_INT 0
5579: PUSH
5580: LD_INT 0
5582: PUSH
5583: LD_INT 0
5585: PUSH
5586: LD_INT 0
5588: PUSH
5589: LD_INT 0
5591: PUSH
5592: LD_INT 0
5594: PUSH
5595: LD_INT 0
5597: PUSH
5598: LD_INT 1
5600: PUSH
5601: LD_INT 0
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: LIST
5614: LIST
5615: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5616: LD_ADDR_VAR 0 3
5620: PUSH
5621: LD_INT 14
5623: PUSH
5624: LD_INT 1
5626: PUSH
5627: LD_INT 2
5629: PUSH
5630: LD_INT 26
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: PUSH
5639: LD_INT 14
5641: PUSH
5642: LD_INT 1
5644: PUSH
5645: LD_INT 2
5647: PUSH
5648: LD_INT 28
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: LD_INT 13
5659: PUSH
5660: LD_INT 1
5662: PUSH
5663: LD_INT 2
5665: PUSH
5666: LD_INT 29
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: LIST
5679: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5680: LD_ADDR_VAR 0 1
5684: PUSH
5685: DOUBLE
5686: LD_INT 1
5688: DEC
5689: ST_TO_ADDR
5690: LD_OWVAR 67
5694: PUSH
5695: LD_OWVAR 1
5699: PUSH
5700: LD_INT 21000
5702: DIV
5703: PLUS
5704: PUSH
5705: FOR_TO
5706: IFFALSE 5798
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5708: LD_ADDR_VAR 0 3
5712: PUSH
5713: LD_VAR 0 3
5717: PPUSH
5718: LD_VAR 0 3
5722: PUSH
5723: LD_INT 1
5725: PLUS
5726: PPUSH
5727: LD_INT 13
5729: PUSH
5730: LD_INT 14
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: PUSH
5737: LD_INT 1
5739: PPUSH
5740: LD_INT 2
5742: PPUSH
5743: CALL_OW 12
5747: ARRAY
5748: PUSH
5749: LD_INT 1
5751: PUSH
5752: LD_INT 2
5754: PUSH
5755: LD_INT 28
5757: PUSH
5758: LD_INT 29
5760: PUSH
5761: LD_INT 25
5763: PUSH
5764: LD_INT 26
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_INT 1
5775: PPUSH
5776: LD_INT 4
5778: PPUSH
5779: CALL_OW 12
5783: ARRAY
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PPUSH
5791: CALL_OW 2
5795: ST_TO_ADDR
5796: GO 5705
5798: POP
5799: POP
// MC_InsertProduceList ( base , tmp ) ;
5800: LD_VAR 0 2
5804: PPUSH
5805: LD_VAR 0 3
5809: PPUSH
5810: CALL 81219 0 2
// repeat wait ( 0 0$1 ) ;
5814: LD_INT 35
5816: PPUSH
5817: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5821: LD_EXP 78
5825: PUSH
5826: LD_VAR 0 2
5830: ARRAY
5831: PUSH
5832: LD_INT 6
5834: GREATER
5835: IFFALSE 5814
// wait ( 0 0$20 ) ;
5837: LD_INT 700
5839: PPUSH
5840: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5844: LD_ADDR_VAR 0 5
5848: PUSH
5849: LD_INT 124
5851: PUSH
5852: LD_INT 85
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: LD_INT 90
5861: PUSH
5862: LD_INT 61
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: PUSH
5869: LD_INT 69
5871: PUSH
5872: LD_INT 48
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: PUSH
5879: LD_INT 68
5881: PUSH
5882: LD_INT 48
5884: PUSH
5885: EMPTY
5886: LIST
5887: LIST
5888: PUSH
5889: EMPTY
5890: LIST
5891: LIST
5892: LIST
5893: LIST
5894: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5895: LD_ADDR_VAR 0 6
5899: PUSH
5900: LD_EXP 78
5904: PUSH
5905: LD_VAR 0 2
5909: ARRAY
5910: PUSH
5911: LD_EXP 78
5915: PUSH
5916: LD_VAR 0 2
5920: ARRAY
5921: PPUSH
5922: LD_INT 34
5924: PUSH
5925: LD_INT 32
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL_OW 72
5936: DIFF
5937: ST_TO_ADDR
// if not attackers then
5938: LD_VAR 0 6
5942: NOT
5943: IFFALSE 5947
// exit ;
5945: GO 6006
// ar_attackers := attackers ;
5947: LD_ADDR_EXP 10
5951: PUSH
5952: LD_VAR 0 6
5956: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5957: LD_INT 35
5959: PPUSH
5960: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5964: LD_VAR 0 6
5968: PPUSH
5969: LD_INT 60
5971: PUSH
5972: EMPTY
5973: LIST
5974: PPUSH
5975: CALL_OW 72
5979: NOT
5980: IFFALSE 5957
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5982: LD_VAR 0 2
5986: PPUSH
5987: LD_VAR 0 6
5991: PPUSH
5992: LD_VAR 0 5
5996: PPUSH
5997: LD_VAR 0 4
6001: PPUSH
6002: CALL 81404 0 4
// end ;
6006: PPOPN 6
6008: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6009: LD_INT 1
6011: PPUSH
6012: CALL_OW 302
6016: PUSH
6017: LD_EXP 9
6021: AND
6022: PUSH
6023: LD_EXP 49
6027: PPUSH
6028: LD_INT 22
6030: PPUSH
6031: CALL_OW 308
6035: AND
6036: PUSH
6037: LD_INT 1
6039: PPUSH
6040: CALL 81567 0 1
6044: PUSH
6045: LD_INT 0
6047: EQUAL
6048: AND
6049: PUSH
6050: LD_EXP 10
6054: NOT
6055: AND
6056: IFFALSE 6520
6058: GO 6060
6060: DISABLE
6061: LD_INT 0
6063: PPUSH
6064: PPUSH
6065: PPUSH
6066: PPUSH
6067: PPUSH
6068: PPUSH
6069: PPUSH
// begin base := 1 ;
6070: LD_ADDR_VAR 0 2
6074: PUSH
6075: LD_INT 1
6077: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6078: LD_ADDR_VAR 0 4
6082: PUSH
6083: LD_INT 0
6085: PUSH
6086: LD_INT 0
6088: PUSH
6089: LD_INT 0
6091: PUSH
6092: LD_INT 0
6094: PUSH
6095: LD_INT 0
6097: PUSH
6098: LD_INT 0
6100: PUSH
6101: LD_INT 0
6103: PUSH
6104: LD_INT 0
6106: PUSH
6107: LD_INT 1
6109: PUSH
6110: LD_INT 0
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6125: LD_ADDR_VAR 0 3
6129: PUSH
6130: LD_INT 13
6132: PUSH
6133: LD_INT 1
6135: PUSH
6136: LD_INT 2
6138: PUSH
6139: LD_INT 28
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 13
6150: PUSH
6151: LD_INT 1
6153: PUSH
6154: LD_INT 2
6156: PUSH
6157: LD_INT 27
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: PUSH
6166: LD_INT 13
6168: PUSH
6169: LD_INT 1
6171: PUSH
6172: LD_INT 2
6174: PUSH
6175: LD_INT 25
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 11
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 2
6192: PUSH
6193: LD_INT 24
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: PUSH
6202: LD_INT 11
6204: PUSH
6205: LD_INT 2
6207: PUSH
6208: LD_INT 2
6210: PUSH
6211: LD_INT 24
6213: PUSH
6214: EMPTY
6215: LIST
6216: LIST
6217: LIST
6218: LIST
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6227: LD_VAR 0 2
6231: PPUSH
6232: LD_VAR 0 3
6236: PPUSH
6237: CALL 81219 0 2
// repeat wait ( 0 0$1 ) ;
6241: LD_INT 35
6243: PPUSH
6244: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6248: LD_EXP 78
6252: PUSH
6253: LD_VAR 0 2
6257: ARRAY
6258: PUSH
6259: LD_INT 6
6261: GREATEREQUAL
6262: IFFALSE 6241
// wait ( 0 0$20 ) ;
6264: LD_INT 700
6266: PPUSH
6267: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6271: LD_ADDR_VAR 0 5
6275: PUSH
6276: LD_INT 119
6278: PUSH
6279: LD_INT 9
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: PUSH
6286: EMPTY
6287: LIST
6288: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6289: LD_ADDR_VAR 0 6
6293: PUSH
6294: LD_EXP 78
6298: PUSH
6299: LD_VAR 0 2
6303: ARRAY
6304: PUSH
6305: LD_EXP 78
6309: PUSH
6310: LD_VAR 0 2
6314: ARRAY
6315: PPUSH
6316: LD_INT 34
6318: PUSH
6319: LD_INT 32
6321: PUSH
6322: EMPTY
6323: LIST
6324: LIST
6325: PPUSH
6326: CALL_OW 72
6330: DIFF
6331: ST_TO_ADDR
// if not attackers then
6332: LD_VAR 0 6
6336: NOT
6337: IFFALSE 6341
// exit ;
6339: GO 6520
// uc_side := 2 ;
6341: LD_ADDR_OWVAR 20
6345: PUSH
6346: LD_INT 2
6348: ST_TO_ADDR
// uc_nation := 2 ;
6349: LD_ADDR_OWVAR 21
6353: PUSH
6354: LD_INT 2
6356: ST_TO_ADDR
// InitHc ;
6357: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6361: LD_ADDR_VAR 0 1
6365: PUSH
6366: DOUBLE
6367: LD_INT 1
6369: DEC
6370: ST_TO_ADDR
6371: LD_INT 4
6373: PUSH
6374: LD_INT 5
6376: PUSH
6377: LD_INT 6
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: LD_OWVAR 67
6389: ARRAY
6390: PUSH
6391: FOR_TO
6392: IFFALSE 6469
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6394: LD_INT 0
6396: PPUSH
6397: LD_INT 15
6399: PUSH
6400: LD_INT 17
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: CALL_OW 12
6417: ARRAY
6418: PPUSH
6419: LD_INT 8
6421: PPUSH
6422: CALL_OW 380
// un := CreateHuman ;
6426: LD_ADDR_VAR 0 7
6430: PUSH
6431: CALL_OW 44
6435: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6436: LD_VAR 0 7
6440: PPUSH
6441: LD_INT 23
6443: PPUSH
6444: LD_INT 0
6446: PPUSH
6447: CALL_OW 49
// attackers := attackers union un ;
6451: LD_ADDR_VAR 0 6
6455: PUSH
6456: LD_VAR 0 6
6460: PUSH
6461: LD_VAR 0 7
6465: UNION
6466: ST_TO_ADDR
// end ;
6467: GO 6391
6469: POP
6470: POP
// repeat wait ( 0 0$1 ) ;
6471: LD_INT 35
6473: PPUSH
6474: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6478: LD_VAR 0 6
6482: PPUSH
6483: LD_INT 60
6485: PUSH
6486: EMPTY
6487: LIST
6488: PPUSH
6489: CALL_OW 72
6493: NOT
6494: IFFALSE 6471
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6496: LD_VAR 0 2
6500: PPUSH
6501: LD_VAR 0 6
6505: PPUSH
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 4
6515: PPUSH
6516: CALL 81404 0 4
// end ; end_of_file
6520: PPOPN 7
6522: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6523: LD_INT 0
6525: PPUSH
6526: PPUSH
6527: PPUSH
6528: PPUSH
// uc_side := 1 ;
6529: LD_ADDR_OWVAR 20
6533: PUSH
6534: LD_INT 1
6536: ST_TO_ADDR
// uc_nation := 1 ;
6537: LD_ADDR_OWVAR 21
6541: PUSH
6542: LD_INT 1
6544: ST_TO_ADDR
// InitHc ;
6545: CALL_OW 19
// InitVc ;
6549: CALL_OW 20
// tmp := [ ] ;
6553: LD_ADDR_VAR 0 3
6557: PUSH
6558: EMPTY
6559: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6560: LD_ADDR_VAR 0 2
6564: PUSH
6565: DOUBLE
6566: LD_INT 1
6568: DEC
6569: ST_TO_ADDR
6570: LD_INT 5
6572: PUSH
6573: LD_INT 6
6575: PUSH
6576: LD_INT 6
6578: PUSH
6579: EMPTY
6580: LIST
6581: LIST
6582: LIST
6583: PUSH
6584: LD_OWVAR 67
6588: ARRAY
6589: PUSH
6590: FOR_TO
6591: IFFALSE 6728
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6593: LD_INT 2
6595: PUSH
6596: LD_INT 4
6598: PUSH
6599: LD_INT 5
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: LIST
6606: PUSH
6607: LD_INT 1
6609: PPUSH
6610: LD_INT 3
6612: PPUSH
6613: CALL_OW 12
6617: ARRAY
6618: PPUSH
6619: LD_INT 1
6621: PUSH
6622: LD_INT 3
6624: PUSH
6625: EMPTY
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 1
6631: PPUSH
6632: LD_INT 2
6634: PPUSH
6635: CALL_OW 12
6639: ARRAY
6640: PPUSH
6641: LD_INT 3
6643: PPUSH
6644: LD_INT 9
6646: PUSH
6647: LD_INT 7
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 1
6656: PPUSH
6657: LD_INT 2
6659: PPUSH
6660: CALL_OW 12
6664: ARRAY
6665: PPUSH
6666: LD_INT 78
6668: PPUSH
6669: CALL 21467 0 5
// veh := CreateVehicle ;
6673: LD_ADDR_VAR 0 4
6677: PUSH
6678: CALL_OW 45
6682: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6683: LD_VAR 0 4
6687: PPUSH
6688: LD_INT 2
6690: PPUSH
6691: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6695: LD_VAR 0 4
6699: PPUSH
6700: LD_INT 17
6702: PPUSH
6703: LD_INT 0
6705: PPUSH
6706: CALL_OW 49
// tmp := tmp ^ veh ;
6710: LD_ADDR_VAR 0 3
6714: PUSH
6715: LD_VAR 0 3
6719: PUSH
6720: LD_VAR 0 4
6724: ADD
6725: ST_TO_ADDR
// end ;
6726: GO 6590
6728: POP
6729: POP
// if not tmp then
6730: LD_VAR 0 3
6734: NOT
6735: IFFALSE 6739
// exit ;
6737: GO 6848
// if not first_powell_attack then
6739: LD_EXP 11
6743: NOT
6744: IFFALSE 6754
// first_powell_attack := true ;
6746: LD_ADDR_EXP 11
6750: PUSH
6751: LD_INT 1
6753: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6754: LD_INT 70
6756: PPUSH
6757: CALL_OW 67
// for i in tmp do
6761: LD_ADDR_VAR 0 2
6765: PUSH
6766: LD_VAR 0 3
6770: PUSH
6771: FOR_IN
6772: IFFALSE 6839
// if IsOk ( i ) then
6774: LD_VAR 0 2
6778: PPUSH
6779: CALL_OW 302
6783: IFFALSE 6821
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6785: LD_VAR 0 2
6789: PPUSH
6790: LD_INT 81
6792: PUSH
6793: LD_INT 1
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: PPUSH
6800: CALL_OW 69
6804: PPUSH
6805: LD_VAR 0 2
6809: PPUSH
6810: CALL_OW 74
6814: PPUSH
6815: CALL_OW 115
6819: GO 6837
// tmp := tmp diff i ;
6821: LD_ADDR_VAR 0 3
6825: PUSH
6826: LD_VAR 0 3
6830: PUSH
6831: LD_VAR 0 2
6835: DIFF
6836: ST_TO_ADDR
6837: GO 6771
6839: POP
6840: POP
// until not tmp ;
6841: LD_VAR 0 3
6845: NOT
6846: IFFALSE 6754
// end ; end_of_file
6848: LD_VAR 0 1
6852: RET
// export function Action ; var tmp , i , un ; begin
6853: LD_INT 0
6855: PPUSH
6856: PPUSH
6857: PPUSH
6858: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6859: LD_INT 68
6861: PPUSH
6862: LD_INT 39
6864: PPUSH
6865: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6869: LD_ADDR_VAR 0 2
6873: PUSH
6874: LD_INT 22
6876: PUSH
6877: LD_INT 7
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: PPUSH
6884: CALL_OW 69
6888: ST_TO_ADDR
// InGameOn ;
6889: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6893: LD_VAR 0 2
6897: PPUSH
6898: LD_INT 71
6900: PPUSH
6901: LD_INT 49
6903: PPUSH
6904: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6908: LD_INT 35
6910: PPUSH
6911: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6915: LD_INT 7
6917: PPUSH
6918: LD_INT 71
6920: PPUSH
6921: LD_INT 51
6923: PPUSH
6924: CALL_OW 293
6928: IFFALSE 6908
// DialogueOn ;
6930: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6934: LD_EXP 15
6938: PPUSH
6939: LD_STRING D1-JMM-1
6941: PPUSH
6942: CALL_OW 88
// if Joan then
6946: LD_EXP 30
6950: IFFALSE 6964
// Say ( Joan , D1-Joan-1 ) ;
6952: LD_EXP 30
6956: PPUSH
6957: LD_STRING D1-Joan-1
6959: PPUSH
6960: CALL_OW 88
// if Lisa then
6964: LD_EXP 17
6968: IFFALSE 6982
// Say ( Lisa , D1-Lisa-1 ) ;
6970: LD_EXP 17
6974: PPUSH
6975: LD_STRING D1-Lisa-1
6977: PPUSH
6978: CALL_OW 88
// if Joan or Lisa then
6982: LD_EXP 30
6986: PUSH
6987: LD_EXP 17
6991: OR
6992: IFFALSE 7006
// Say ( JMM , D1-JMM-2 ) ;
6994: LD_EXP 15
6998: PPUSH
6999: LD_STRING D1-JMM-2
7001: PPUSH
7002: CALL_OW 88
// DialogueOff ;
7006: CALL_OW 7
// InGameOff ;
7010: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7014: LD_INT 71
7016: PPUSH
7017: LD_INT 50
7019: PPUSH
7020: LD_INT 7
7022: PPUSH
7023: LD_INT 30
7025: NEG
7026: PPUSH
7027: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7031: LD_INT 71
7033: PPUSH
7034: LD_INT 50
7036: PPUSH
7037: LD_INT 7
7039: PPUSH
7040: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7044: LD_STRING M1
7046: PPUSH
7047: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7051: LD_INT 35
7053: PPUSH
7054: CALL_OW 67
// until freedom ;
7058: LD_EXP 3
7062: IFFALSE 7051
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7064: LD_INT 350
7066: PPUSH
7067: LD_INT 700
7069: PPUSH
7070: CALL_OW 12
7074: PPUSH
7075: CALL_OW 67
// PrepareGossudarov ;
7079: CALL 1802 0 0
// repeat wait ( 0 0$1 ) ;
7083: LD_INT 35
7085: PPUSH
7086: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7090: LD_INT 22
7092: PUSH
7093: LD_INT 6
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 24
7105: PUSH
7106: LD_INT 1000
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: PPUSH
7121: CALL_OW 69
7125: PUSH
7126: LD_INT 7
7128: PPUSH
7129: LD_EXP 32
7133: PPUSH
7134: CALL_OW 292
7138: OR
7139: IFFALSE 7083
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7141: LD_ADDR_VAR 0 2
7145: PUSH
7146: LD_INT 22
7148: PUSH
7149: LD_INT 6
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PPUSH
7156: CALL_OW 69
7160: ST_TO_ADDR
// for i in tmp do
7161: LD_ADDR_VAR 0 3
7165: PUSH
7166: LD_VAR 0 2
7170: PUSH
7171: FOR_IN
7172: IFFALSE 7188
// SetSide ( i , 7 ) ;
7174: LD_VAR 0 3
7178: PPUSH
7179: LD_INT 7
7181: PPUSH
7182: CALL_OW 235
7186: GO 7171
7188: POP
7189: POP
// DialogueOn ;
7190: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7194: LD_EXP 15
7198: PUSH
7199: LD_EXP 16
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: PPUSH
7208: LD_EXP 32
7212: PPUSH
7213: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7217: LD_EXP 32
7221: PPUSH
7222: CALL_OW 87
// if not Roth then
7226: LD_EXP 16
7230: NOT
7231: IFFALSE 7323
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7233: LD_VAR 0 2
7237: PPUSH
7238: LD_INT 3
7240: PUSH
7241: LD_INT 24
7243: PUSH
7244: LD_INT 1000
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PPUSH
7255: CALL_OW 72
7259: IFFALSE 7273
// Say ( JMM , D2-JMM-1 ) ;
7261: LD_EXP 15
7265: PPUSH
7266: LD_STRING D2-JMM-1
7268: PPUSH
7269: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7273: LD_EXP 15
7277: PPUSH
7278: LD_STRING D2-JMM-1b
7280: PPUSH
7281: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7285: LD_EXP 32
7289: PPUSH
7290: LD_STRING D2-Gos-1
7292: PPUSH
7293: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7297: LD_EXP 15
7301: PPUSH
7302: LD_STRING D2-JMM-2
7304: PPUSH
7305: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7309: LD_EXP 32
7313: PPUSH
7314: LD_STRING D2-Gos-2
7316: PPUSH
7317: CALL_OW 88
// end else
7321: GO 7475
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7323: LD_VAR 0 2
7327: PPUSH
7328: LD_INT 3
7330: PUSH
7331: LD_INT 24
7333: PUSH
7334: LD_INT 1000
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL_OW 72
7349: IFFALSE 7375
// begin Say ( Roth , D2-Roth-2 ) ;
7351: LD_EXP 16
7355: PPUSH
7356: LD_STRING D2-Roth-2
7358: PPUSH
7359: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7363: LD_EXP 15
7367: PPUSH
7368: LD_STRING D2-JMM-1a
7370: PPUSH
7371: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7375: LD_EXP 16
7379: PPUSH
7380: LD_STRING D2-Roth-2a
7382: PPUSH
7383: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7387: LD_EXP 16
7391: PPUSH
7392: LD_STRING D2-Roth-2b
7394: PPUSH
7395: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7399: LD_EXP 15
7403: PPUSH
7404: LD_STRING D2-JMM-3
7406: PPUSH
7407: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7411: LD_VAR 0 2
7415: PPUSH
7416: LD_INT 3
7418: PUSH
7419: LD_INT 24
7421: PUSH
7422: LD_INT 1000
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: PPUSH
7433: CALL_OW 72
7437: IFFALSE 7475
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7439: LD_EXP 32
7443: PPUSH
7444: LD_STRING D2-Gos-3
7446: PPUSH
7447: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7451: LD_EXP 15
7455: PPUSH
7456: LD_STRING D2-JMM-4
7458: PPUSH
7459: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7463: LD_EXP 32
7467: PPUSH
7468: LD_STRING D2-Gos-4
7470: PPUSH
7471: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7475: LD_EXP 15
7479: PPUSH
7480: LD_STRING D2-JMM-5
7482: PPUSH
7483: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7487: LD_EXP 32
7491: PPUSH
7492: LD_STRING D2-Gos-5
7494: PPUSH
7495: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7499: LD_EXP 15
7503: PPUSH
7504: LD_STRING D2-JMM-6
7506: PPUSH
7507: CALL_OW 88
// DialogueOff ;
7511: CALL_OW 7
// wait ( 0 0$2 ) ;
7515: LD_INT 70
7517: PPUSH
7518: CALL_OW 67
// if Kirilenkova then
7522: LD_EXP 33
7526: IFFALSE 7540
// Say ( Kirilenkova , D3-Kir-1 ) ;
7528: LD_EXP 33
7532: PPUSH
7533: LD_STRING D3-Kir-1
7535: PPUSH
7536: CALL_OW 88
// gossudarov_arrive := true ;
7540: LD_ADDR_EXP 4
7544: PUSH
7545: LD_INT 1
7547: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7548: LD_INT 35
7550: PPUSH
7551: CALL_OW 67
// until ru_lab_builded ;
7555: LD_EXP 5
7559: IFFALSE 7548
// DialogueOn ;
7561: CALL_OW 6
// if Kirilenkova then
7565: LD_EXP 33
7569: IFFALSE 7585
// Say ( Kirilenkova , D3a-Kir-1 ) else
7571: LD_EXP 33
7575: PPUSH
7576: LD_STRING D3a-Kir-1
7578: PPUSH
7579: CALL_OW 88
7583: GO 7607
// begin un := SciRu ;
7585: LD_ADDR_VAR 0 4
7589: PUSH
7590: CALL 12719 0 0
7594: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7595: LD_VAR 0 4
7599: PPUSH
7600: LD_STRING D3a-Sci1-1
7602: PPUSH
7603: CALL_OW 88
// end ; if Kirilenkova or un then
7607: LD_EXP 33
7611: PUSH
7612: LD_VAR 0 4
7616: OR
7617: IFFALSE 7631
// Say ( JMM , D3a-JMM-1 ) ;
7619: LD_EXP 15
7623: PPUSH
7624: LD_STRING D3a-JMM-1
7626: PPUSH
7627: CALL_OW 88
// DialogueOff ;
7631: CALL_OW 7
// end ;
7635: LD_VAR 0 1
7639: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7640: LD_EXP 4
7644: PUSH
7645: LD_INT 22
7647: PUSH
7648: LD_INT 7
7650: PUSH
7651: EMPTY
7652: LIST
7653: LIST
7654: PUSH
7655: LD_INT 2
7657: PUSH
7658: LD_INT 25
7660: PUSH
7661: LD_INT 1
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: LD_INT 25
7670: PUSH
7671: LD_INT 2
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: PUSH
7678: LD_INT 25
7680: PUSH
7681: LD_INT 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: LD_INT 25
7690: PUSH
7691: LD_INT 4
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: LD_INT 5
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: PUSH
7708: LD_INT 25
7710: PUSH
7711: LD_INT 8
7713: PUSH
7714: EMPTY
7715: LIST
7716: LIST
7717: PUSH
7718: LD_INT 25
7720: PUSH
7721: LD_INT 9
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: LIST
7736: LIST
7737: PUSH
7738: EMPTY
7739: LIST
7740: LIST
7741: PPUSH
7742: CALL_OW 69
7746: PUSH
7747: LD_INT 7
7749: LESS
7750: AND
7751: IFFALSE 7763
7753: GO 7755
7755: DISABLE
// YouLost ( TooMany ) ;
7756: LD_STRING TooMany
7758: PPUSH
7759: CALL_OW 104
7763: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7764: LD_EXP 32
7768: PPUSH
7769: CALL_OW 255
7773: PUSH
7774: LD_INT 7
7776: EQUAL
7777: IFFALSE 7977
7779: GO 7781
7781: DISABLE
7782: LD_INT 0
7784: PPUSH
7785: PPUSH
7786: PPUSH
// begin uc_side := 3 ;
7787: LD_ADDR_OWVAR 20
7791: PUSH
7792: LD_INT 3
7794: ST_TO_ADDR
// uc_nation := 3 ;
7795: LD_ADDR_OWVAR 21
7799: PUSH
7800: LD_INT 3
7802: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7803: LD_INT 21
7805: PPUSH
7806: LD_INT 3
7808: PPUSH
7809: LD_INT 3
7811: PPUSH
7812: LD_INT 42
7814: PPUSH
7815: LD_INT 100
7817: PPUSH
7818: CALL 21467 0 5
// un := CreateVehicle ;
7822: LD_ADDR_VAR 0 3
7826: PUSH
7827: CALL_OW 45
7831: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7832: LD_VAR 0 3
7836: PPUSH
7837: LD_INT 15
7839: PPUSH
7840: LD_INT 0
7842: PPUSH
7843: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7847: LD_VAR 0 3
7851: PPUSH
7852: LD_INT 67
7854: PPUSH
7855: LD_INT 45
7857: PPUSH
7858: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7862: LD_VAR 0 3
7866: PPUSH
7867: LD_INT 70
7869: PPUSH
7870: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7874: LD_VAR 0 3
7878: PPUSH
7879: LD_INT 69
7881: PPUSH
7882: LD_INT 18
7884: PPUSH
7885: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7889: LD_VAR 0 3
7893: PPUSH
7894: LD_INT 60
7896: PPUSH
7897: LD_INT 2
7899: PPUSH
7900: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7904: LD_INT 35
7906: PPUSH
7907: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7911: LD_VAR 0 3
7915: PPUSH
7916: CALL_OW 302
7920: NOT
7921: PUSH
7922: LD_VAR 0 3
7926: PPUSH
7927: LD_INT 17
7929: PPUSH
7930: CALL_OW 308
7934: OR
7935: IFFALSE 7904
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7937: LD_VAR 0 3
7941: PPUSH
7942: LD_INT 17
7944: PPUSH
7945: CALL_OW 308
7949: PUSH
7950: LD_VAR 0 3
7954: PPUSH
7955: LD_INT 60
7957: PPUSH
7958: LD_INT 2
7960: PPUSH
7961: CALL_OW 307
7965: OR
7966: IFFALSE 7977
// RemoveUnit ( un ) ;
7968: LD_VAR 0 3
7972: PPUSH
7973: CALL_OW 64
// end ;
7977: PPOPN 3
7979: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
7980: LD_EXP 4
7984: IFFALSE 8226
7986: GO 7988
7988: DISABLE
7989: LD_INT 0
7991: PPUSH
7992: PPUSH
7993: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7994: LD_INT 70
7996: PPUSH
7997: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8001: LD_ADDR_VAR 0 3
8005: PUSH
8006: LD_INT 22
8008: PUSH
8009: LD_INT 7
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: LD_INT 101
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: PPUSH
8030: CALL_OW 69
8034: ST_TO_ADDR
// until tmp ;
8035: LD_VAR 0 3
8039: IFFALSE 7994
// un := NearestUnitToUnit ( tmp , JMM ) ;
8041: LD_ADDR_VAR 0 2
8045: PUSH
8046: LD_VAR 0 3
8050: PPUSH
8051: LD_EXP 15
8055: PPUSH
8056: CALL_OW 74
8060: ST_TO_ADDR
// player_spotted := true ;
8061: LD_ADDR_EXP 6
8065: PUSH
8066: LD_INT 1
8068: ST_TO_ADDR
// tmp := SciRu ;
8069: LD_ADDR_VAR 0 3
8073: PUSH
8074: CALL 12719 0 0
8078: ST_TO_ADDR
// if not tmp then
8079: LD_VAR 0 3
8083: NOT
8084: IFFALSE 8096
// tmp := SolRu ;
8086: LD_ADDR_VAR 0 3
8090: PUSH
8091: CALL 12866 0 0
8095: ST_TO_ADDR
// DialogueOn ;
8096: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8100: LD_VAR 0 2
8104: PPUSH
8105: CALL_OW 250
8109: PPUSH
8110: LD_VAR 0 2
8114: PPUSH
8115: CALL_OW 251
8119: PPUSH
8120: LD_INT 7
8122: PPUSH
8123: LD_INT 8
8125: NEG
8126: PPUSH
8127: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8131: LD_VAR 0 2
8135: PPUSH
8136: CALL_OW 87
// if tmp then
8140: LD_VAR 0 3
8144: IFFALSE 8158
// Say ( tmp , D4-RSci1-1 ) ;
8146: LD_VAR 0 3
8150: PPUSH
8151: LD_STRING D4-RSci1-1
8153: PPUSH
8154: CALL_OW 88
// if Gossudarov then
8158: LD_EXP 32
8162: IFFALSE 8188
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8164: LD_EXP 32
8168: PPUSH
8169: LD_STRING D4-Gos-1
8171: PPUSH
8172: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8176: LD_EXP 15
8180: PPUSH
8181: LD_STRING D4-JMM-1
8183: PPUSH
8184: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8188: LD_VAR 0 2
8192: PPUSH
8193: CALL_OW 250
8197: PPUSH
8198: LD_VAR 0 2
8202: PPUSH
8203: CALL_OW 251
8207: PPUSH
8208: LD_INT 7
8210: PPUSH
8211: CALL_OW 331
// DialogueOff ;
8215: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8219: LD_STRING M5
8221: PPUSH
8222: CALL_OW 337
// end ;
8226: PPOPN 3
8228: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8229: LD_EXP 6
8233: IFFALSE 8822
8235: GO 8237
8237: DISABLE
8238: LD_INT 0
8240: PPUSH
8241: PPUSH
8242: PPUSH
// begin PrepareBelkov ;
8243: CALL 2092 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8247: LD_EXP 47
8251: PPUSH
8252: LD_INT 118
8254: PPUSH
8255: LD_INT 106
8257: PPUSH
8258: CALL_OW 111
// AddComHold ( Belkov ) ;
8262: LD_EXP 47
8266: PPUSH
8267: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8271: LD_INT 35
8273: PPUSH
8274: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8278: LD_EXP 47
8282: PPUSH
8283: LD_INT 118
8285: PPUSH
8286: LD_INT 106
8288: PPUSH
8289: CALL_OW 307
8293: IFFALSE 8271
// ChangeSideFog ( 4 , 7 ) ;
8295: LD_INT 4
8297: PPUSH
8298: LD_INT 7
8300: PPUSH
8301: CALL_OW 343
// if IsOk ( Belkov ) then
8305: LD_EXP 47
8309: PPUSH
8310: CALL_OW 302
8314: IFFALSE 8398
// begin InGameOn ;
8316: CALL_OW 8
// DialogueOn ;
8320: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8324: LD_EXP 47
8328: PPUSH
8329: LD_STRING D5-Bel-1
8331: PPUSH
8332: CALL_OW 94
// if Gossudarov then
8336: LD_EXP 32
8340: IFFALSE 8390
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8342: LD_EXP 32
8346: PPUSH
8347: LD_STRING D5-Gos-1
8349: PPUSH
8350: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8354: LD_EXP 15
8358: PPUSH
8359: LD_STRING D5-JMM-1
8361: PPUSH
8362: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8366: LD_EXP 32
8370: PPUSH
8371: LD_STRING D5-Gos-2
8373: PPUSH
8374: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8378: LD_EXP 15
8382: PPUSH
8383: LD_STRING D5-JMM-2
8385: PPUSH
8386: CALL_OW 88
// end ; DialogueOff ;
8390: CALL_OW 7
// InGameOff ;
8394: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8398: LD_STRING QSaveBelkov
8400: PPUSH
8401: CALL_OW 97
8405: PUSH
8406: LD_INT 1
8408: DOUBLE
8409: EQUAL
8410: IFTRUE 8414
8412: GO 8464
8414: POP
// begin DialogueOn ;
8415: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8419: LD_EXP 15
8423: PPUSH
8424: LD_STRING D5a-JMM-1
8426: PPUSH
8427: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8431: LD_EXP 47
8435: PPUSH
8436: LD_STRING D5a-Bel-1
8438: PPUSH
8439: CALL_OW 94
// DialogueOff ;
8443: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8447: LD_EXP 47
8451: PPUSH
8452: LD_INT 83
8454: PPUSH
8455: LD_INT 49
8457: PPUSH
8458: CALL_OW 111
// end ; 2 :
8462: GO 8497
8464: LD_INT 2
8466: DOUBLE
8467: EQUAL
8468: IFTRUE 8472
8470: GO 8496
8472: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8473: LD_EXP 15
8477: PPUSH
8478: LD_STRING D5a-JMM-2
8480: PPUSH
8481: CALL_OW 88
// ComHold ( Belkov ) ;
8485: LD_EXP 47
8489: PPUSH
8490: CALL_OW 140
// end ; end ;
8494: GO 8497
8496: POP
// time := 0 0$00 ;
8497: LD_ADDR_VAR 0 1
8501: PUSH
8502: LD_INT 0
8504: ST_TO_ADDR
// vehSpawned := false ;
8505: LD_ADDR_VAR 0 3
8509: PUSH
8510: LD_INT 0
8512: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8513: LD_INT 35
8515: PPUSH
8516: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8520: LD_VAR 0 1
8524: PUSH
8525: LD_INT 350
8527: PUSH
8528: LD_INT 175
8530: PUSH
8531: LD_INT 70
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: LIST
8538: PUSH
8539: LD_OWVAR 67
8543: ARRAY
8544: GREATEREQUAL
8545: PUSH
8546: LD_VAR 0 3
8550: NOT
8551: AND
8552: IFFALSE 8642
// begin vehSpawned := true ;
8554: LD_ADDR_VAR 0 3
8558: PUSH
8559: LD_INT 1
8561: ST_TO_ADDR
// uc_side := 3 ;
8562: LD_ADDR_OWVAR 20
8566: PUSH
8567: LD_INT 3
8569: ST_TO_ADDR
// uc_nation := 3 ;
8570: LD_ADDR_OWVAR 21
8574: PUSH
8575: LD_INT 3
8577: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8578: LD_INT 22
8580: PPUSH
8581: LD_INT 3
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: LD_INT 43
8589: PPUSH
8590: LD_INT 100
8592: PPUSH
8593: CALL 21467 0 5
// veh := CreateVehicle ;
8597: LD_ADDR_VAR 0 2
8601: PUSH
8602: CALL_OW 45
8606: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8607: LD_VAR 0 2
8611: PPUSH
8612: LD_INT 130
8614: PPUSH
8615: LD_INT 131
8617: PPUSH
8618: LD_INT 0
8620: PPUSH
8621: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8625: LD_VAR 0 2
8629: PPUSH
8630: LD_INT 100
8632: PPUSH
8633: LD_INT 82
8635: PPUSH
8636: CALL_OW 114
// end else
8640: GO 8656
// time := time + 0 0$1 ;
8642: LD_ADDR_VAR 0 1
8646: PUSH
8647: LD_VAR 0 1
8651: PUSH
8652: LD_INT 35
8654: PLUS
8655: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8656: LD_EXP 47
8660: PPUSH
8661: CALL_OW 301
8665: PUSH
8666: LD_EXP 47
8670: PPUSH
8671: CALL_OW 255
8675: PUSH
8676: LD_INT 4
8678: EQUAL
8679: AND
8680: PUSH
8681: LD_INT 22
8683: PUSH
8684: LD_INT 7
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: PPUSH
8691: CALL_OW 69
8695: PPUSH
8696: LD_EXP 47
8700: PPUSH
8701: CALL_OW 74
8705: PPUSH
8706: LD_EXP 47
8710: PPUSH
8711: CALL_OW 296
8715: PUSH
8716: LD_INT 10
8718: LESS
8719: OR
8720: IFFALSE 8513
// if IsDead ( Belkov ) then
8722: LD_EXP 47
8726: PPUSH
8727: CALL_OW 301
8731: IFFALSE 8756
// begin CenterNowOnUnits ( Belkov ) ;
8733: LD_EXP 47
8737: PPUSH
8738: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8742: LD_EXP 15
8746: PPUSH
8747: LD_STRING D5a-JMM-2a
8749: PPUSH
8750: CALL_OW 88
// exit ;
8754: GO 8822
// end ; if See ( 7 , Belkov ) then
8756: LD_INT 7
8758: PPUSH
8759: LD_EXP 47
8763: PPUSH
8764: CALL_OW 292
8768: IFFALSE 8782
// SetSide ( Belkov , 7 ) ;
8770: LD_EXP 47
8774: PPUSH
8775: LD_INT 7
8777: PPUSH
8778: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8782: LD_INT 35
8784: PPUSH
8785: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8789: LD_EXP 47
8793: PPUSH
8794: LD_INT 66
8796: PPUSH
8797: LD_INT 45
8799: PPUSH
8800: CALL_OW 297
8804: PUSH
8805: LD_INT 30
8807: LESS
8808: IFFALSE 8782
// Say ( Belkov , D6-Bel-1 ) ;
8810: LD_EXP 47
8814: PPUSH
8815: LD_STRING D6-Bel-1
8817: PPUSH
8818: CALL_OW 88
// end ;
8822: PPOPN 3
8824: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8825: LD_EXP 47
8829: PPUSH
8830: CALL_OW 302
8834: PUSH
8835: LD_EXP 47
8839: PPUSH
8840: CALL_OW 504
8844: PUSH
8845: LD_INT 2
8847: PUSH
8848: LD_INT 34
8850: PUSH
8851: LD_INT 47
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PUSH
8858: LD_INT 34
8860: PUSH
8861: LD_INT 45
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: LIST
8872: PPUSH
8873: CALL_OW 69
8877: IN
8878: AND
8879: IFFALSE 8896
8881: GO 8883
8883: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8884: LD_EXP 47
8888: PPUSH
8889: LD_STRING D7-Bel-1
8891: PPUSH
8892: CALL_OW 88
8896: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8897: LD_INT 22
8899: PUSH
8900: LD_INT 7
8902: PUSH
8903: EMPTY
8904: LIST
8905: LIST
8906: PUSH
8907: LD_INT 101
8909: PUSH
8910: LD_INT 2
8912: PUSH
8913: EMPTY
8914: LIST
8915: LIST
8916: PUSH
8917: EMPTY
8918: LIST
8919: LIST
8920: PPUSH
8921: CALL_OW 69
8925: PUSH
8926: LD_EXP 8
8930: NOT
8931: AND
8932: PUSH
8933: LD_EXP 46
8937: PPUSH
8938: CALL_OW 305
8942: NOT
8943: AND
8944: IFFALSE 9414
8946: GO 8948
8948: DISABLE
8949: LD_INT 0
8951: PPUSH
// begin ar_base_spotted := true ;
8952: LD_ADDR_EXP 8
8956: PUSH
8957: LD_INT 1
8959: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8960: LD_ADDR_VAR 0 1
8964: PUSH
8965: LD_INT 22
8967: PUSH
8968: LD_INT 2
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PUSH
8975: LD_INT 21
8977: PUSH
8978: LD_INT 3
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: PPUSH
8989: CALL_OW 69
8993: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8994: LD_ADDR_VAR 0 1
8998: PUSH
8999: LD_VAR 0 1
9003: PPUSH
9004: LD_EXP 15
9008: PPUSH
9009: CALL_OW 74
9013: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9014: LD_INT 7
9016: PPUSH
9017: LD_INT 3
9019: PPUSH
9020: CALL_OW 332
// DialogueOn ;
9024: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9028: LD_VAR 0 1
9032: PPUSH
9033: CALL_OW 250
9037: PPUSH
9038: LD_VAR 0 1
9042: PPUSH
9043: CALL_OW 251
9047: PPUSH
9048: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9052: LD_ADDR_VAR 0 1
9056: PUSH
9057: LD_INT 22
9059: PUSH
9060: LD_INT 7
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: PUSH
9067: LD_INT 23
9069: PUSH
9070: LD_INT 1
9072: PUSH
9073: EMPTY
9074: LIST
9075: LIST
9076: PUSH
9077: LD_INT 26
9079: PUSH
9080: LD_INT 1
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: LIST
9091: PPUSH
9092: CALL_OW 69
9096: PUSH
9097: LD_EXP 15
9101: PUSH
9102: LD_EXP 19
9106: PUSH
9107: LD_EXP 20
9111: PUSH
9112: LD_EXP 27
9116: PUSH
9117: LD_EXP 16
9121: PUSH
9122: LD_EXP 25
9126: PUSH
9127: LD_EXP 21
9131: PUSH
9132: LD_EXP 23
9136: PUSH
9137: EMPTY
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: DIFF
9147: ST_TO_ADDR
// if not tmp then
9148: LD_VAR 0 1
9152: NOT
9153: IFFALSE 9227
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9155: LD_ADDR_VAR 0 1
9159: PUSH
9160: LD_INT 22
9162: PUSH
9163: LD_INT 7
9165: PUSH
9166: EMPTY
9167: LIST
9168: LIST
9169: PUSH
9170: LD_INT 23
9172: PUSH
9173: LD_INT 1
9175: PUSH
9176: EMPTY
9177: LIST
9178: LIST
9179: PUSH
9180: LD_INT 26
9182: PUSH
9183: LD_INT 2
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: LIST
9194: PPUSH
9195: CALL_OW 69
9199: PUSH
9200: LD_EXP 30
9204: PUSH
9205: LD_EXP 17
9209: PUSH
9210: LD_EXP 28
9214: PUSH
9215: LD_EXP 29
9219: PUSH
9220: EMPTY
9221: LIST
9222: LIST
9223: LIST
9224: LIST
9225: DIFF
9226: ST_TO_ADDR
// if tmp then
9227: LD_VAR 0 1
9231: IFFALSE 9302
// case GetSex ( tmp [ 1 ] ) of sex_male :
9233: LD_VAR 0 1
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: CALL_OW 258
9246: PUSH
9247: LD_INT 1
9249: DOUBLE
9250: EQUAL
9251: IFTRUE 9255
9253: GO 9274
9255: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9256: LD_VAR 0 1
9260: PUSH
9261: LD_INT 1
9263: ARRAY
9264: PPUSH
9265: LD_STRING D9-Sol1-1
9267: PPUSH
9268: CALL_OW 88
9272: GO 9302
9274: LD_INT 2
9276: DOUBLE
9277: EQUAL
9278: IFTRUE 9282
9280: GO 9301
9282: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9283: LD_VAR 0 1
9287: PUSH
9288: LD_INT 1
9290: ARRAY
9291: PPUSH
9292: LD_STRING D9-FSol1-1
9294: PPUSH
9295: CALL_OW 88
9299: GO 9302
9301: POP
// if Frank then
9302: LD_EXP 27
9306: IFFALSE 9410
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9308: LD_EXP 56
9312: PPUSH
9313: CALL_OW 250
9317: PPUSH
9318: LD_EXP 56
9322: PPUSH
9323: CALL_OW 251
9327: PPUSH
9328: LD_INT 7
9330: PPUSH
9331: LD_INT 8
9333: PPUSH
9334: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9338: LD_EXP 56
9342: PPUSH
9343: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9347: LD_EXP 27
9351: PPUSH
9352: LD_STRING D9-Frank-1
9354: PPUSH
9355: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9359: LD_EXP 15
9363: PPUSH
9364: LD_STRING D9-JMM-1
9366: PPUSH
9367: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9371: LD_EXP 27
9375: PPUSH
9376: LD_STRING D9-Frank-2
9378: PPUSH
9379: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9383: LD_EXP 56
9387: PPUSH
9388: CALL_OW 250
9392: PPUSH
9393: LD_EXP 56
9397: PPUSH
9398: CALL_OW 251
9402: PPUSH
9403: LD_INT 7
9405: PPUSH
9406: CALL_OW 331
// end ; DialogueOff ;
9410: CALL_OW 7
// end ;
9414: PPOPN 1
9416: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9417: LD_EXP 7
9421: PUSH
9422: LD_OWVAR 1
9426: PUSH
9427: LD_INT 42000
9429: GREATEREQUAL
9430: OR
9431: IFFALSE 10458
9433: GO 9435
9435: DISABLE
9436: LD_INT 0
9438: PPUSH
9439: PPUSH
// begin selected_option := 1 ;
9440: LD_ADDR_VAR 0 2
9444: PUSH
9445: LD_INT 1
9447: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9448: LD_INT 10500
9450: PPUSH
9451: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9455: LD_INT 35
9457: PPUSH
9458: CALL_OW 67
// until not ru_attackers ;
9462: LD_EXP 52
9466: NOT
9467: IFFALSE 9455
// PrepareBurlak ;
9469: CALL 2204 0 0
// repeat wait ( 0 0$2 ) ;
9473: LD_INT 70
9475: PPUSH
9476: CALL_OW 67
// until not HasTask ( Burlak ) ;
9480: LD_EXP 46
9484: PPUSH
9485: CALL_OW 314
9489: NOT
9490: IFFALSE 9473
// InGameOn ;
9492: CALL_OW 8
// DialogueOn ;
9496: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9500: LD_EXP 49
9504: PPUSH
9505: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9509: LD_EXP 46
9513: PPUSH
9514: LD_STRING D10-Bur-1
9516: PPUSH
9517: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9521: LD_EXP 47
9525: PUSH
9526: LD_EXP 47
9530: PPUSH
9531: CALL_OW 255
9535: PUSH
9536: LD_INT 7
9538: EQUAL
9539: AND
9540: IFFALSE 9554
// Say ( Belkov , D10-Bel-1 ) ;
9542: LD_EXP 47
9546: PPUSH
9547: LD_STRING D10-Bel-1
9549: PPUSH
9550: CALL_OW 88
// if Gossudarov then
9554: LD_EXP 32
9558: IFFALSE 9572
// Say ( Gossudarov , D10-Gos-1 ) ;
9560: LD_EXP 32
9564: PPUSH
9565: LD_STRING D10-Gos-1
9567: PPUSH
9568: CALL_OW 88
// if Kirilenkova then
9572: LD_EXP 33
9576: IFFALSE 9590
// Say ( Kirilenkova , D10-Kir-1 ) ;
9578: LD_EXP 33
9582: PPUSH
9583: LD_STRING D10-Kir-1
9585: PPUSH
9586: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9590: CALL 12866 0 0
9594: PPUSH
9595: LD_STRING D10-RSol1-1
9597: PPUSH
9598: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9602: LD_EXP 46
9606: PPUSH
9607: LD_STRING D10-Bur-2
9609: PPUSH
9610: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9614: LD_EXP 15
9618: PPUSH
9619: LD_STRING D10-JMM-2
9621: PPUSH
9622: CALL_OW 88
// if Kirilenkova then
9626: LD_EXP 33
9630: IFFALSE 9646
// Say ( Kirilenkova , D10-Kir-2 ) else
9632: LD_EXP 33
9636: PPUSH
9637: LD_STRING D10-Kir-2
9639: PPUSH
9640: CALL_OW 88
9644: GO 9658
// Say ( SolRu , D10-RSol1-2 ) ;
9646: CALL 12866 0 0
9650: PPUSH
9651: LD_STRING D10-RSol1-2
9653: PPUSH
9654: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9658: LD_EXP 15
9662: PPUSH
9663: LD_STRING D10-JMM-3
9665: PPUSH
9666: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9670: LD_EXP 46
9674: PPUSH
9675: LD_STRING D10-Bur-3
9677: PPUSH
9678: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9682: LD_EXP 15
9686: PPUSH
9687: LD_STRING D10-JMM-4
9689: PPUSH
9690: CALL_OW 88
// DialogueOff ;
9694: CALL_OW 7
// InGameOff ;
9698: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9702: LD_STRING M2
9704: PPUSH
9705: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9709: LD_INT 35
9711: PPUSH
9712: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9716: LD_INT 22
9718: PUSH
9719: LD_INT 7
9721: PUSH
9722: EMPTY
9723: LIST
9724: LIST
9725: PUSH
9726: LD_INT 91
9728: PUSH
9729: LD_EXP 46
9733: PUSH
9734: LD_INT 8
9736: PUSH
9737: EMPTY
9738: LIST
9739: LIST
9740: LIST
9741: PUSH
9742: EMPTY
9743: LIST
9744: LIST
9745: PPUSH
9746: CALL_OW 69
9750: IFFALSE 9709
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9752: LD_ADDR_VAR 0 1
9756: PUSH
9757: LD_INT 22
9759: PUSH
9760: LD_INT 4
9762: PUSH
9763: EMPTY
9764: LIST
9765: LIST
9766: PPUSH
9767: CALL_OW 69
9771: PUSH
9772: FOR_IN
9773: IFFALSE 9789
// SetSide ( i , 7 ) ;
9775: LD_VAR 0 1
9779: PPUSH
9780: LD_INT 7
9782: PPUSH
9783: CALL_OW 235
9787: GO 9772
9789: POP
9790: POP
// ChangeMissionObjectives ( M3 ) ;
9791: LD_STRING M3
9793: PPUSH
9794: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9798: LD_INT 35
9800: PPUSH
9801: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9805: LD_EXP 15
9809: PPUSH
9810: LD_EXP 46
9814: PPUSH
9815: CALL_OW 296
9819: PUSH
9820: LD_INT 8
9822: LESS
9823: IFFALSE 9798
// ComTurnUnit ( JMM , Burlak ) ;
9825: LD_EXP 15
9829: PPUSH
9830: LD_EXP 46
9834: PPUSH
9835: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9839: LD_EXP 46
9843: PPUSH
9844: LD_EXP 15
9848: PPUSH
9849: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9853: LD_INT 10
9855: PPUSH
9856: CALL_OW 67
// DialogueOn ;
9860: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9864: LD_EXP 15
9868: PPUSH
9869: LD_STRING D11-JMM-1
9871: PPUSH
9872: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9876: LD_EXP 46
9880: PPUSH
9881: LD_STRING D11-Bur-1
9883: PPUSH
9884: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9888: LD_EXP 15
9892: PPUSH
9893: LD_STRING D11-JMM-2
9895: PPUSH
9896: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9900: LD_EXP 46
9904: PPUSH
9905: LD_STRING D11-Bur-2
9907: PPUSH
9908: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9912: LD_EXP 15
9916: PPUSH
9917: LD_STRING D11-JMM-3
9919: PPUSH
9920: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9924: LD_EXP 46
9928: PPUSH
9929: LD_STRING D11-Bur-3
9931: PPUSH
9932: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9936: LD_EXP 15
9940: PPUSH
9941: LD_STRING D11-JMM-4
9943: PPUSH
9944: CALL_OW 88
// if ar_base_spotted then
9948: LD_EXP 8
9952: IFFALSE 9968
// Say ( Burlak , D12-Bur-1 ) else
9954: LD_EXP 46
9958: PPUSH
9959: LD_STRING D12-Bur-1
9961: PPUSH
9962: CALL_OW 88
9966: GO 10007
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9968: LD_INT 7
9970: PPUSH
9971: LD_INT 3
9973: PPUSH
9974: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9978: LD_INT 127
9980: PPUSH
9981: LD_INT 45
9983: PPUSH
9984: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9988: LD_EXP 46
9992: PPUSH
9993: LD_STRING D12-Bur-1a
9995: PPUSH
9996: CALL_OW 88
// dwait ( 0 0$2 ) ;
10000: LD_INT 70
10002: PPUSH
10003: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10007: LD_EXP 46
10011: PPUSH
10012: LD_STRING D12-Bur-1b
10014: PPUSH
10015: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10019: LD_EXP 15
10023: PPUSH
10024: LD_STRING D12-JMM-1
10026: PPUSH
10027: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10031: LD_EXP 46
10035: PPUSH
10036: LD_STRING D12-Bur-2
10038: PPUSH
10039: CALL_OW 88
// if Roth then
10043: LD_EXP 16
10047: IFFALSE 10063
// Say ( Roth , D12-Roth-2 ) else
10049: LD_EXP 16
10053: PPUSH
10054: LD_STRING D12-Roth-2
10056: PPUSH
10057: CALL_OW 88
10061: GO 10075
// Say ( SciRu , D12-RSci1-2 ) ;
10063: CALL 12719 0 0
10067: PPUSH
10068: LD_STRING D12-RSci1-2
10070: PPUSH
10071: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10075: LD_EXP 15
10079: PPUSH
10080: LD_STRING D12-JMM-2
10082: PPUSH
10083: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10087: LD_EXP 46
10091: PPUSH
10092: LD_STRING D12-Bur-3
10094: PPUSH
10095: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10099: LD_EXP 15
10103: PPUSH
10104: LD_STRING D12-JMM-3
10106: PPUSH
10107: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10111: LD_EXP 46
10115: PPUSH
10116: LD_STRING D12-Bur-4
10118: PPUSH
10119: CALL_OW 88
// case Query ( QBase ) of 1 :
10123: LD_STRING QBase
10125: PPUSH
10126: CALL_OW 97
10130: PUSH
10131: LD_INT 1
10133: DOUBLE
10134: EQUAL
10135: IFTRUE 10139
10137: GO 10257
10139: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10140: LD_EXP 15
10144: PPUSH
10145: LD_STRING D13a-JMM-1
10147: PPUSH
10148: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10152: LD_EXP 46
10156: PPUSH
10157: LD_STRING D13a-Bur-1
10159: PPUSH
10160: CALL_OW 88
// if Roth then
10164: LD_EXP 16
10168: IFFALSE 10184
// Say ( Roth , D13a-Roth-1 ) else
10170: LD_EXP 16
10174: PPUSH
10175: LD_STRING D13a-Roth-1
10177: PPUSH
10178: CALL_OW 88
10182: GO 10196
// Say ( SciRu , D13a-RSci1-1 ) ;
10184: CALL 12719 0 0
10188: PPUSH
10189: LD_STRING D13a-RSci1-1
10191: PPUSH
10192: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10196: LD_EXP 15
10200: PPUSH
10201: LD_STRING D13a-JMM-2
10203: PPUSH
10204: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10208: LD_STRING QBaseAgain
10210: PPUSH
10211: CALL_OW 97
10215: PUSH
10216: LD_INT 1
10218: DOUBLE
10219: EQUAL
10220: IFTRUE 10224
10222: GO 10235
10224: POP
// selected_option := 2 ; 2 :
10225: LD_ADDR_VAR 0 2
10229: PUSH
10230: LD_INT 2
10232: ST_TO_ADDR
10233: GO 10255
10235: LD_INT 2
10237: DOUBLE
10238: EQUAL
10239: IFTRUE 10243
10241: GO 10254
10243: POP
// selected_option := 3 ; end ;
10244: LD_ADDR_VAR 0 2
10248: PUSH
10249: LD_INT 3
10251: ST_TO_ADDR
10252: GO 10255
10254: POP
// end ; 2 :
10255: GO 10296
10257: LD_INT 2
10259: DOUBLE
10260: EQUAL
10261: IFTRUE 10265
10263: GO 10276
10265: POP
// selected_option := 2 ; 3 :
10266: LD_ADDR_VAR 0 2
10270: PUSH
10271: LD_INT 2
10273: ST_TO_ADDR
10274: GO 10296
10276: LD_INT 3
10278: DOUBLE
10279: EQUAL
10280: IFTRUE 10284
10282: GO 10295
10284: POP
// selected_option := 3 ; end ;
10285: LD_ADDR_VAR 0 2
10289: PUSH
10290: LD_INT 3
10292: ST_TO_ADDR
10293: GO 10296
10295: POP
// if selected_option = 2 then
10296: LD_VAR 0 2
10300: PUSH
10301: LD_INT 2
10303: EQUAL
10304: IFFALSE 10398
// begin Say ( JMM , D13b-JMM-1 ) ;
10306: LD_EXP 15
10310: PPUSH
10311: LD_STRING D13b-JMM-1
10313: PPUSH
10314: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10318: LD_EXP 46
10322: PPUSH
10323: LD_STRING D13b-Bur-1
10325: PPUSH
10326: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10330: LD_EXP 15
10334: PPUSH
10335: LD_STRING D13b-JMM-2
10337: PPUSH
10338: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10342: LD_EXP 55
10346: PPUSH
10347: LD_STRING D13b-Abd-2
10349: PPUSH
10350: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10354: LD_EXP 15
10358: PPUSH
10359: LD_STRING D13b-JMM-3
10361: PPUSH
10362: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10366: LD_EXP 55
10370: PPUSH
10371: LD_STRING D13b-Abd-3
10373: PPUSH
10374: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10378: LD_EXP 15
10382: PPUSH
10383: LD_STRING D13b-JMM-4
10385: PPUSH
10386: CALL_OW 88
// ar_active_attack := true ;
10390: LD_ADDR_EXP 9
10394: PUSH
10395: LD_INT 1
10397: ST_TO_ADDR
// end ; if selected_option = 3 then
10398: LD_VAR 0 2
10402: PUSH
10403: LD_INT 3
10405: EQUAL
10406: IFFALSE 10432
// begin Say ( JMM , D13c-JMM-1 ) ;
10408: LD_EXP 15
10412: PPUSH
10413: LD_STRING D13c-JMM-1
10415: PPUSH
10416: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10420: LD_EXP 46
10424: PPUSH
10425: LD_STRING D13c-Bur-1
10427: PPUSH
10428: CALL_OW 88
// end ; DialogueOff ;
10432: CALL_OW 7
// if not ar_active_attack then
10436: LD_EXP 9
10440: NOT
10441: IFFALSE 10458
// begin wait ( 6 6$00 ) ;
10443: LD_INT 12600
10445: PPUSH
10446: CALL_OW 67
// ar_active_attack := true ;
10450: LD_ADDR_EXP 9
10454: PUSH
10455: LD_INT 1
10457: ST_TO_ADDR
// end ; end ;
10458: PPOPN 2
10460: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10461: LD_EXP 46
10465: PPUSH
10466: CALL_OW 305
10470: PUSH
10471: LD_EXP 46
10475: PPUSH
10476: CALL_OW 255
10480: PUSH
10481: LD_INT 7
10483: EQUAL
10484: AND
10485: IFFALSE 10681
10487: GO 10489
10489: DISABLE
10490: LD_INT 0
10492: PPUSH
// begin wait ( 4 4$40 ) ;
10493: LD_INT 9800
10495: PPUSH
10496: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10500: LD_INT 35
10502: PPUSH
10503: CALL_OW 67
// until not ru_attackers ;
10507: LD_EXP 52
10511: NOT
10512: IFFALSE 10500
// PrepareGnyevko ;
10514: CALL 2148 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10518: LD_EXP 48
10522: PPUSH
10523: LD_INT 124
10525: PPUSH
10526: LD_INT 118
10528: PPUSH
10529: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10533: LD_EXP 48
10537: PPUSH
10538: CALL_OW 200
// time := 0 0$00 ;
10542: LD_ADDR_VAR 0 1
10546: PUSH
10547: LD_INT 0
10549: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10550: LD_INT 35
10552: PPUSH
10553: CALL_OW 67
// time := time + 0 0$1 ;
10557: LD_ADDR_VAR 0 1
10561: PUSH
10562: LD_VAR 0 1
10566: PUSH
10567: LD_INT 35
10569: PLUS
10570: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10571: LD_EXP 48
10575: PPUSH
10576: LD_INT 124
10578: PPUSH
10579: LD_INT 118
10581: PPUSH
10582: CALL_OW 307
10586: PUSH
10587: LD_VAR 0 1
10591: PUSH
10592: LD_INT 1050
10594: GREATEREQUAL
10595: OR
10596: IFFALSE 10550
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10598: LD_EXP 48
10602: PPUSH
10603: LD_STRING DBelkov-Gny-1
10605: PPUSH
10606: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10610: LD_EXP 46
10614: PPUSH
10615: LD_STRING DBelkov-Bur-1a
10617: PPUSH
10618: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10622: LD_INT 35
10624: PPUSH
10625: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10629: LD_EXP 48
10633: PPUSH
10634: LD_INT 22
10636: PUSH
10637: LD_INT 7
10639: PUSH
10640: EMPTY
10641: LIST
10642: LIST
10643: PPUSH
10644: CALL_OW 69
10648: PPUSH
10649: LD_EXP 48
10653: PPUSH
10654: CALL_OW 74
10658: PPUSH
10659: CALL_OW 296
10663: PUSH
10664: LD_INT 8
10666: LESS
10667: IFFALSE 10622
// SetSide ( Gnyevko , 7 ) ;
10669: LD_EXP 48
10673: PPUSH
10674: LD_INT 7
10676: PPUSH
10677: CALL_OW 235
// end ;
10681: PPOPN 1
10683: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10684: LD_EXP 46
10688: PPUSH
10689: CALL_OW 255
10693: PUSH
10694: LD_INT 7
10696: EQUAL
10697: IFFALSE 10707
10699: GO 10701
10701: DISABLE
// begin enable ;
10702: ENABLE
// PrepareAmericanAttack ;
10703: CALL 6523 0 0
// end ;
10707: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10708: LD_INT 22
10710: PUSH
10711: LD_INT 1
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: PPUSH
10718: CALL_OW 69
10722: IFFALSE 10906
10724: GO 10726
10726: DISABLE
10727: LD_INT 0
10729: PPUSH
10730: PPUSH
// begin while true do
10731: LD_INT 1
10733: IFFALSE 10790
// begin wait ( 0 0$1 ) ;
10735: LD_INT 35
10737: PPUSH
10738: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10742: LD_ADDR_VAR 0 2
10746: PUSH
10747: LD_INT 22
10749: PUSH
10750: LD_INT 1
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: PPUSH
10757: CALL_OW 69
10761: PPUSH
10762: LD_EXP 15
10766: PPUSH
10767: CALL_OW 74
10771: ST_TO_ADDR
// if See ( 7 , tmp ) then
10772: LD_INT 7
10774: PPUSH
10775: LD_VAR 0 2
10779: PPUSH
10780: CALL_OW 292
10784: IFFALSE 10788
// break ;
10786: GO 10790
// end ;
10788: GO 10731
// DialogueOn ;
10790: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10794: LD_VAR 0 2
10798: PPUSH
10799: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10803: LD_VAR 0 2
10807: PPUSH
10808: CALL_OW 250
10812: PPUSH
10813: LD_VAR 0 2
10817: PPUSH
10818: CALL_OW 251
10822: PPUSH
10823: LD_INT 7
10825: PPUSH
10826: LD_INT 8
10828: PPUSH
10829: CALL_OW 330
// if Denis then
10833: LD_EXP 21
10837: IFFALSE 10851
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10839: LD_EXP 21
10843: PPUSH
10844: LD_STRING DAmerAttack-Pet-1
10846: PPUSH
10847: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10851: LD_EXP 15
10855: PPUSH
10856: LD_STRING DAmerAttack-JMM-1
10858: PPUSH
10859: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10863: LD_EXP 46
10867: PPUSH
10868: LD_STRING DStop-Bur-1
10870: PPUSH
10871: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10875: LD_VAR 0 2
10879: PPUSH
10880: CALL_OW 250
10884: PPUSH
10885: LD_VAR 0 2
10889: PPUSH
10890: CALL_OW 251
10894: PPUSH
10895: LD_INT 7
10897: PPUSH
10898: CALL_OW 331
// DialogueOff ;
10902: CALL_OW 7
// end ;
10906: PPOPN 2
10908: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10909: LD_INT 22
10911: PUSH
10912: LD_INT 3
10914: PUSH
10915: EMPTY
10916: LIST
10917: LIST
10918: PUSH
10919: LD_INT 21
10921: PUSH
10922: LD_INT 1
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: PUSH
10929: EMPTY
10930: LIST
10931: LIST
10932: PPUSH
10933: CALL_OW 69
10937: PUSH
10938: LD_INT 0
10940: EQUAL
10941: IFFALSE 10983
10943: GO 10945
10945: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10946: LD_STRING M5a
10948: PPUSH
10949: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10953: LD_EXP 15
10957: PPUSH
10958: LD_STRING D8-JMM-1
10960: PPUSH
10961: CALL_OW 88
// if Gossudarov then
10965: LD_EXP 32
10969: IFFALSE 10983
// Say ( Gossudarov , D8-Gos-1 ) ;
10971: LD_EXP 32
10975: PPUSH
10976: LD_STRING D8-Gos-1
10978: PPUSH
10979: CALL_OW 88
// end ;
10983: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10984: LD_INT 22
10986: PUSH
10987: LD_INT 2
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: PUSH
10994: LD_INT 21
10996: PUSH
10997: LD_INT 1
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: PPUSH
11008: CALL_OW 69
11012: PUSH
11013: LD_INT 0
11015: EQUAL
11016: IFFALSE 11066
11018: GO 11020
11020: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11021: LD_STRING M4c
11023: PPUSH
11024: CALL_OW 337
// if Roth then
11028: LD_EXP 16
11032: IFFALSE 11048
// Say ( Roth , DStop-Roth-1 ) else
11034: LD_EXP 16
11038: PPUSH
11039: LD_STRING DStop-Roth-1
11041: PPUSH
11042: CALL_OW 88
11046: GO 11066
// if Gossudarov then
11048: LD_EXP 32
11052: IFFALSE 11066
// Say ( Gossudarov , D8-Gos-1a ) ;
11054: LD_EXP 32
11058: PPUSH
11059: LD_STRING D8-Gos-1a
11061: PPUSH
11062: CALL_OW 88
// end ;
11066: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11067: LD_INT 7
11069: PPUSH
11070: LD_INT 1
11072: PPUSH
11073: LD_INT 1
11075: PPUSH
11076: CALL 14355 0 3
11080: PUSH
11081: LD_INT 0
11083: EQUAL
11084: PUSH
11085: LD_INT 7
11087: PPUSH
11088: LD_INT 3
11090: PPUSH
11091: LD_INT 1
11093: PPUSH
11094: CALL 14355 0 3
11098: PUSH
11099: LD_INT 0
11101: EQUAL
11102: AND
11103: IFFALSE 11115
11105: GO 11107
11107: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11108: LD_STRING M1a
11110: PPUSH
11111: CALL_OW 337
// end ;
11115: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11116: LD_INT 22
11118: PUSH
11119: LD_INT 2
11121: PUSH
11122: EMPTY
11123: LIST
11124: LIST
11125: PUSH
11126: LD_INT 21
11128: PUSH
11129: LD_INT 1
11131: PUSH
11132: EMPTY
11133: LIST
11134: LIST
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: PPUSH
11140: CALL_OW 69
11144: PUSH
11145: LD_INT 0
11147: EQUAL
11148: PUSH
11149: LD_INT 22
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: EMPTY
11156: LIST
11157: LIST
11158: PUSH
11159: LD_INT 21
11161: PUSH
11162: LD_INT 1
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: PPUSH
11173: CALL_OW 69
11177: PUSH
11178: LD_INT 0
11180: EQUAL
11181: AND
11182: PUSH
11183: LD_INT 22
11185: PUSH
11186: LD_INT 1
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: PPUSH
11193: CALL_OW 69
11197: PUSH
11198: LD_INT 0
11200: EQUAL
11201: AND
11202: PUSH
11203: LD_INT 7
11205: PPUSH
11206: LD_INT 1
11208: PPUSH
11209: LD_INT 1
11211: PPUSH
11212: CALL 14355 0 3
11216: PUSH
11217: LD_INT 0
11219: EQUAL
11220: AND
11221: PUSH
11222: LD_INT 7
11224: PPUSH
11225: LD_INT 3
11227: PPUSH
11228: LD_INT 1
11230: PPUSH
11231: CALL 14355 0 3
11235: PUSH
11236: LD_INT 0
11238: EQUAL
11239: AND
11240: IFFALSE 12716
11242: GO 11244
11244: DISABLE
11245: LD_INT 0
11247: PPUSH
11248: PPUSH
11249: PPUSH
11250: PPUSH
11251: PPUSH
11252: PPUSH
// begin m1 := false ;
11253: LD_ADDR_VAR 0 4
11257: PUSH
11258: LD_INT 0
11260: ST_TO_ADDR
// m2 := false ;
11261: LD_ADDR_VAR 0 5
11265: PUSH
11266: LD_INT 0
11268: ST_TO_ADDR
// m3 := false ;
11269: LD_ADDR_VAR 0 6
11273: PUSH
11274: LD_INT 0
11276: ST_TO_ADDR
// if tick < 40 40$00 then
11277: LD_OWVAR 1
11281: PUSH
11282: LD_INT 84000
11284: LESS
11285: IFFALSE 11294
// SetAchievement ( ACH_ASPEED_17 ) ;
11287: LD_STRING ACH_ASPEED_17
11289: PPUSH
11290: CALL_OW 543
// wait ( 0 0$1 ) ;
11294: LD_INT 35
11296: PPUSH
11297: CALL_OW 67
// if not IsDead ( Masha ) then
11301: LD_EXP 49
11305: PPUSH
11306: CALL_OW 301
11310: NOT
11311: IFFALSE 11333
// begin m1 := true ;
11313: LD_ADDR_VAR 0 4
11317: PUSH
11318: LD_INT 1
11320: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11321: LD_STRING Masha
11323: PPUSH
11324: LD_INT 1
11326: PPUSH
11327: CALL_OW 101
// end else
11331: GO 11344
// AddMedal ( Masha , - 1 ) ;
11333: LD_STRING Masha
11335: PPUSH
11336: LD_INT 1
11338: NEG
11339: PPUSH
11340: CALL_OW 101
// if abdul_escaped then
11344: LD_EXP 12
11348: IFFALSE 11363
// AddMedal ( Abdul , - 1 ) else
11350: LD_STRING Abdul
11352: PPUSH
11353: LD_INT 1
11355: NEG
11356: PPUSH
11357: CALL_OW 101
11361: GO 11381
// begin m2 := true ;
11363: LD_ADDR_VAR 0 5
11367: PUSH
11368: LD_INT 1
11370: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11371: LD_STRING Abdul
11373: PPUSH
11374: LD_INT 1
11376: PPUSH
11377: CALL_OW 101
// end ; if loss_counter = 0 then
11381: LD_EXP 13
11385: PUSH
11386: LD_INT 0
11388: EQUAL
11389: IFFALSE 11411
// begin m3 := true ;
11391: LD_ADDR_VAR 0 6
11395: PUSH
11396: LD_INT 1
11398: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11399: LD_STRING People
11401: PPUSH
11402: LD_INT 2
11404: PPUSH
11405: CALL_OW 101
// end else
11409: GO 11469
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11411: LD_EXP 13
11415: PUSH
11416: LD_INT 3
11418: PUSH
11419: LD_INT 2
11421: PUSH
11422: LD_INT 2
11424: PUSH
11425: EMPTY
11426: LIST
11427: LIST
11428: LIST
11429: PUSH
11430: LD_OWVAR 67
11434: ARRAY
11435: LESSEQUAL
11436: IFFALSE 11458
// begin AddMedal ( People , 1 ) ;
11438: LD_STRING People
11440: PPUSH
11441: LD_INT 1
11443: PPUSH
11444: CALL_OW 101
// m3 := true ;
11448: LD_ADDR_VAR 0 6
11452: PUSH
11453: LD_INT 1
11455: ST_TO_ADDR
// end else
11456: GO 11469
// AddMedal ( People , - 1 ) ;
11458: LD_STRING People
11460: PPUSH
11461: LD_INT 1
11463: NEG
11464: PPUSH
11465: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11469: LD_OWVAR 67
11473: PUSH
11474: LD_INT 3
11476: EQUAL
11477: PUSH
11478: LD_VAR 0 4
11482: AND
11483: PUSH
11484: LD_VAR 0 5
11488: AND
11489: PUSH
11490: LD_VAR 0 6
11494: AND
11495: IFFALSE 11507
// SetAchievementEX ( ACH_AMER , 17 ) ;
11497: LD_STRING ACH_AMER
11499: PPUSH
11500: LD_INT 17
11502: PPUSH
11503: CALL_OW 564
// GiveMedals ( MAIN ) ;
11507: LD_STRING MAIN
11509: PPUSH
11510: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11514: LD_ADDR_VAR 0 2
11518: PUSH
11519: LD_INT 22
11521: PUSH
11522: LD_INT 7
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: PUSH
11529: LD_INT 2
11531: PUSH
11532: LD_INT 25
11534: PUSH
11535: LD_INT 1
11537: PUSH
11538: EMPTY
11539: LIST
11540: LIST
11541: PUSH
11542: LD_INT 25
11544: PUSH
11545: LD_INT 2
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 25
11554: PUSH
11555: LD_INT 3
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 25
11564: PUSH
11565: LD_INT 4
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: LD_INT 25
11574: PUSH
11575: LD_INT 5
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: PUSH
11582: LD_INT 25
11584: PUSH
11585: LD_INT 8
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: PUSH
11592: LD_INT 25
11594: PUSH
11595: LD_INT 9
11597: PUSH
11598: EMPTY
11599: LIST
11600: LIST
11601: PUSH
11602: EMPTY
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PPUSH
11616: CALL_OW 69
11620: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11621: LD_VAR 0 2
11625: PPUSH
11626: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11630: LD_ADDR_VAR 0 3
11634: PUSH
11635: LD_EXP 15
11639: PUSH
11640: LD_EXP 16
11644: PUSH
11645: LD_EXP 17
11649: PUSH
11650: LD_EXP 18
11654: PUSH
11655: LD_EXP 19
11659: PUSH
11660: LD_EXP 20
11664: PUSH
11665: LD_EXP 21
11669: PUSH
11670: LD_EXP 22
11674: PUSH
11675: LD_EXP 23
11679: PUSH
11680: LD_EXP 24
11684: PUSH
11685: LD_EXP 25
11689: PUSH
11690: LD_EXP 26
11694: PUSH
11695: LD_EXP 27
11699: PUSH
11700: LD_EXP 28
11704: PUSH
11705: LD_EXP 29
11709: PUSH
11710: LD_EXP 30
11714: PUSH
11715: LD_EXP 31
11719: PUSH
11720: LD_EXP 32
11724: PUSH
11725: LD_EXP 33
11729: PUSH
11730: LD_EXP 34
11734: PUSH
11735: LD_EXP 36
11739: PUSH
11740: LD_EXP 37
11744: PUSH
11745: LD_EXP 38
11749: PUSH
11750: LD_EXP 39
11754: PUSH
11755: LD_EXP 40
11759: PUSH
11760: LD_EXP 41
11764: PUSH
11765: LD_EXP 42
11769: PUSH
11770: LD_EXP 43
11774: PUSH
11775: LD_EXP 44
11779: PUSH
11780: LD_EXP 45
11784: PUSH
11785: LD_EXP 46
11789: PUSH
11790: LD_EXP 47
11794: PUSH
11795: LD_EXP 48
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: LIST
11809: LIST
11810: LIST
11811: LIST
11812: LIST
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: LIST
11831: LIST
11832: LIST
11833: LIST
11834: ST_TO_ADDR
// if tmp diff tmp2 then
11835: LD_VAR 0 2
11839: PUSH
11840: LD_VAR 0 3
11844: DIFF
11845: IFFALSE 11865
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11847: LD_VAR 0 2
11851: PUSH
11852: LD_VAR 0 3
11856: DIFF
11857: PPUSH
11858: LD_STRING 13a_others
11860: PPUSH
11861: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11865: LD_EXP 15
11869: PPUSH
11870: LD_STRING 13a_JMM
11872: PPUSH
11873: CALL_OW 38
// if Titov then
11877: LD_EXP 34
11881: IFFALSE 11895
// SaveCharacters ( Titov , 13a_Titov ) ;
11883: LD_EXP 34
11887: PPUSH
11888: LD_STRING 13a_Titov
11890: PPUSH
11891: CALL_OW 38
// if Dolgov then
11895: LD_EXP 36
11899: IFFALSE 11913
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11901: LD_EXP 36
11905: PPUSH
11906: LD_STRING 13a_Dolgov
11908: PPUSH
11909: CALL_OW 38
// if Petrosyan then
11913: LD_EXP 37
11917: IFFALSE 11931
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11919: LD_EXP 37
11923: PPUSH
11924: LD_STRING 13a_Petrosyan
11926: PPUSH
11927: CALL_OW 38
// if Scholtze then
11931: LD_EXP 38
11935: IFFALSE 11949
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11937: LD_EXP 38
11941: PPUSH
11942: LD_STRING 13a_Scholtze
11944: PPUSH
11945: CALL_OW 38
// if Oblukov then
11949: LD_EXP 39
11953: IFFALSE 11967
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11955: LD_EXP 39
11959: PPUSH
11960: LD_STRING 13a_Oblukov
11962: PPUSH
11963: CALL_OW 38
// if Kapitsova then
11967: LD_EXP 40
11971: IFFALSE 11985
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11973: LD_EXP 40
11977: PPUSH
11978: LD_STRING 13a_Kapitsova
11980: PPUSH
11981: CALL_OW 38
// if Lipshchin then
11985: LD_EXP 41
11989: IFFALSE 12003
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11991: LD_EXP 41
11995: PPUSH
11996: LD_STRING 13a_Lipshchin
11998: PPUSH
11999: CALL_OW 38
// if Petrovova then
12003: LD_EXP 42
12007: IFFALSE 12021
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12009: LD_EXP 42
12013: PPUSH
12014: LD_STRING 13a_Petrovova
12016: PPUSH
12017: CALL_OW 38
// if Kovalyuk then
12021: LD_EXP 43
12025: IFFALSE 12039
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12027: LD_EXP 43
12031: PPUSH
12032: LD_STRING 13a_Kovalyuk
12034: PPUSH
12035: CALL_OW 38
// if Kuzmov then
12039: LD_EXP 44
12043: IFFALSE 12057
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12045: LD_EXP 44
12049: PPUSH
12050: LD_STRING 13a_Kuzmov
12052: PPUSH
12053: CALL_OW 38
// if Karamazov then
12057: LD_EXP 45
12061: IFFALSE 12075
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12063: LD_EXP 45
12067: PPUSH
12068: LD_STRING 13a_Karamazov
12070: PPUSH
12071: CALL_OW 38
// if Burlak then
12075: LD_EXP 46
12079: IFFALSE 12093
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12081: LD_EXP 46
12085: PPUSH
12086: LD_STRING 13a_Burlak
12088: PPUSH
12089: CALL_OW 38
// if Belkov then
12093: LD_EXP 47
12097: IFFALSE 12111
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12099: LD_EXP 47
12103: PPUSH
12104: LD_STRING 13a_Belkov
12106: PPUSH
12107: CALL_OW 38
// if Gnyevko then
12111: LD_EXP 48
12115: IFFALSE 12129
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12117: LD_EXP 48
12121: PPUSH
12122: LD_STRING 13a_Gnyevko
12124: PPUSH
12125: CALL_OW 38
// if Lisa then
12129: LD_EXP 17
12133: IFFALSE 12147
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12135: LD_EXP 17
12139: PPUSH
12140: LD_STRING 13a_Lisa
12142: PPUSH
12143: CALL_OW 38
// if Donaldson then
12147: LD_EXP 18
12151: IFFALSE 12165
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12153: LD_EXP 18
12157: PPUSH
12158: LD_STRING 13a_Donaldson
12160: PPUSH
12161: CALL_OW 38
// if Bobby then
12165: LD_EXP 19
12169: IFFALSE 12183
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12171: LD_EXP 19
12175: PPUSH
12176: LD_STRING 13a_Bobby
12178: PPUSH
12179: CALL_OW 38
// if Cyrus then
12183: LD_EXP 20
12187: IFFALSE 12201
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12189: LD_EXP 20
12193: PPUSH
12194: LD_STRING 13a_Cyrus
12196: PPUSH
12197: CALL_OW 38
// if Denis then
12201: LD_EXP 21
12205: IFFALSE 12219
// SaveCharacters ( Denis , 13a_Denis ) ;
12207: LD_EXP 21
12211: PPUSH
12212: LD_STRING 13a_Denis
12214: PPUSH
12215: CALL_OW 38
// if Brown then
12219: LD_EXP 22
12223: IFFALSE 12237
// SaveCharacters ( Brown , 13a_Brown ) ;
12225: LD_EXP 22
12229: PPUSH
12230: LD_STRING 13a_Brown
12232: PPUSH
12233: CALL_OW 38
// if Gladstone then
12237: LD_EXP 23
12241: IFFALSE 12255
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12243: LD_EXP 23
12247: PPUSH
12248: LD_STRING 13a_Gladstone
12250: PPUSH
12251: CALL_OW 38
// if Houten then
12255: LD_EXP 24
12259: IFFALSE 12273
// SaveCharacters ( Houten , 13a_Houten ) ;
12261: LD_EXP 24
12265: PPUSH
12266: LD_STRING 13a_Houten
12268: PPUSH
12269: CALL_OW 38
// if Cornel then
12273: LD_EXP 25
12277: IFFALSE 12291
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12279: LD_EXP 25
12283: PPUSH
12284: LD_STRING 13a_Cornel
12286: PPUSH
12287: CALL_OW 38
// if Gary then
12291: LD_EXP 26
12295: IFFALSE 12309
// SaveCharacters ( Gary , 13a_Gary ) ;
12297: LD_EXP 26
12301: PPUSH
12302: LD_STRING 13a_Gary
12304: PPUSH
12305: CALL_OW 38
// if Frank then
12309: LD_EXP 27
12313: IFFALSE 12327
// SaveCharacters ( Frank , 13a_Frank ) ;
12315: LD_EXP 27
12319: PPUSH
12320: LD_STRING 13a_Frank
12322: PPUSH
12323: CALL_OW 38
// if Kikuchi then
12327: LD_EXP 28
12331: IFFALSE 12345
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12333: LD_EXP 28
12337: PPUSH
12338: LD_STRING 13a_Kikuchi
12340: PPUSH
12341: CALL_OW 38
// if Simms then
12345: LD_EXP 29
12349: IFFALSE 12363
// SaveCharacters ( Simms , 13a_Simms ) ;
12351: LD_EXP 29
12355: PPUSH
12356: LD_STRING 13a_Simms
12358: PPUSH
12359: CALL_OW 38
// if Joan then
12363: LD_EXP 30
12367: IFFALSE 12381
// SaveCharacters ( Joan , 13a_Joan ) ;
12369: LD_EXP 30
12373: PPUSH
12374: LD_STRING 13a_Joan
12376: PPUSH
12377: CALL_OW 38
// if DeltaDoctor then
12381: LD_EXP 31
12385: IFFALSE 12399
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12387: LD_EXP 31
12391: PPUSH
12392: LD_STRING 13a_DeltaDoctor
12394: PPUSH
12395: CALL_OW 38
// if Gossudarov then
12399: LD_EXP 32
12403: IFFALSE 12417
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12405: LD_EXP 32
12409: PPUSH
12410: LD_STRING 13a_Gossudarov
12412: PPUSH
12413: CALL_OW 38
// if Kirilenkova then
12417: LD_EXP 33
12421: IFFALSE 12435
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12423: LD_EXP 33
12427: PPUSH
12428: LD_STRING 13a_Kirilenkova
12430: PPUSH
12431: CALL_OW 38
// if Roth then
12435: LD_EXP 16
12439: IFFALSE 12453
// SaveCharacters ( Roth , 13a_Roth ) ;
12441: LD_EXP 16
12445: PPUSH
12446: LD_STRING 13a_Roth
12448: PPUSH
12449: CALL_OW 38
// if Masha then
12453: LD_EXP 49
12457: IFFALSE 12512
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12459: LD_EXP 49
12463: PPUSH
12464: CALL_OW 265
12468: PUSH
12469: LD_EXP 49
12473: PPUSH
12474: CALL_OW 262
12478: PUSH
12479: LD_EXP 49
12483: PPUSH
12484: CALL_OW 263
12488: PUSH
12489: LD_EXP 49
12493: PPUSH
12494: CALL_OW 264
12498: PUSH
12499: EMPTY
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: PPUSH
12505: LD_STRING 13a_Masha
12507: PPUSH
12508: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12512: LD_ADDR_VAR 0 2
12516: PUSH
12517: LD_INT 21
12519: PUSH
12520: LD_INT 3
12522: PUSH
12523: EMPTY
12524: LIST
12525: LIST
12526: PPUSH
12527: CALL_OW 69
12531: ST_TO_ADDR
// tmp2 := [ ] ;
12532: LD_ADDR_VAR 0 3
12536: PUSH
12537: EMPTY
12538: ST_TO_ADDR
// if tmp then
12539: LD_VAR 0 2
12543: IFFALSE 12694
// for i in tmp do
12545: LD_ADDR_VAR 0 1
12549: PUSH
12550: LD_VAR 0 2
12554: PUSH
12555: FOR_IN
12556: IFFALSE 12692
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12558: LD_ADDR_VAR 0 3
12562: PUSH
12563: LD_VAR 0 3
12567: PUSH
12568: LD_VAR 0 1
12572: PPUSH
12573: CALL_OW 255
12577: PUSH
12578: LD_VAR 0 1
12582: PPUSH
12583: CALL_OW 248
12587: PUSH
12588: LD_VAR 0 1
12592: PPUSH
12593: CALL_OW 266
12597: PUSH
12598: LD_VAR 0 1
12602: PPUSH
12603: CALL_OW 250
12607: PUSH
12608: LD_VAR 0 1
12612: PPUSH
12613: CALL_OW 251
12617: PUSH
12618: LD_VAR 0 1
12622: PPUSH
12623: CALL_OW 254
12627: PUSH
12628: LD_VAR 0 1
12632: PPUSH
12633: CALL_OW 267
12637: PUSH
12638: LD_VAR 0 1
12642: PPUSH
12643: LD_INT 1
12645: PPUSH
12646: CALL_OW 268
12650: PUSH
12651: LD_VAR 0 1
12655: PPUSH
12656: LD_INT 2
12658: PPUSH
12659: CALL_OW 268
12663: PUSH
12664: LD_VAR 0 1
12668: PPUSH
12669: CALL_OW 269
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: PUSH
12686: EMPTY
12687: LIST
12688: ADD
12689: ST_TO_ADDR
12690: GO 12555
12692: POP
12693: POP
// if tmp2 then
12694: LD_VAR 0 3
12698: IFFALSE 12712
// SaveVariable ( tmp2 , 13a_buildings ) ;
12700: LD_VAR 0 3
12704: PPUSH
12705: LD_STRING 13a_buildings
12707: PPUSH
12708: CALL_OW 39
// YouWin ;
12712: CALL_OW 103
// end ;
12716: PPOPN 6
12718: END
// export function SciRu ; var tmp , t ; begin
12719: LD_INT 0
12721: PPUSH
12722: PPUSH
12723: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12724: LD_ADDR_VAR 0 3
12728: PUSH
12729: LD_EXP 32
12733: PUSH
12734: LD_EXP 46
12738: PUSH
12739: LD_EXP 34
12743: PUSH
12744: LD_EXP 47
12748: PUSH
12749: LD_EXP 48
12753: PUSH
12754: LD_EXP 37
12758: PUSH
12759: LD_EXP 38
12763: PUSH
12764: LD_EXP 36
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: LIST
12773: LIST
12774: LIST
12775: LIST
12776: LIST
12777: LIST
12778: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12779: LD_ADDR_VAR 0 2
12783: PUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 7
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 23
12796: PUSH
12797: LD_INT 3
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 25
12806: PUSH
12807: LD_INT 4
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: LD_INT 26
12816: PUSH
12817: LD_INT 1
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: PUSH
12824: EMPTY
12825: LIST
12826: LIST
12827: LIST
12828: LIST
12829: PPUSH
12830: CALL_OW 69
12834: PUSH
12835: LD_VAR 0 3
12839: DIFF
12840: ST_TO_ADDR
// if tmp then
12841: LD_VAR 0 2
12845: IFFALSE 12861
// result := tmp [ 1 ] ;
12847: LD_ADDR_VAR 0 1
12851: PUSH
12852: LD_VAR 0 2
12856: PUSH
12857: LD_INT 1
12859: ARRAY
12860: ST_TO_ADDR
// end ;
12861: LD_VAR 0 1
12865: RET
// export function SolRu ; var tmp , t ; begin
12866: LD_INT 0
12868: PPUSH
12869: PPUSH
12870: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12871: LD_ADDR_VAR 0 3
12875: PUSH
12876: LD_EXP 32
12880: PUSH
12881: LD_EXP 46
12885: PUSH
12886: LD_EXP 34
12890: PUSH
12891: LD_EXP 47
12895: PUSH
12896: LD_EXP 48
12900: PUSH
12901: LD_EXP 37
12905: PUSH
12906: LD_EXP 38
12910: PUSH
12911: LD_EXP 36
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: LIST
12924: LIST
12925: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12926: LD_ADDR_VAR 0 2
12930: PUSH
12931: LD_INT 22
12933: PUSH
12934: LD_INT 7
12936: PUSH
12937: EMPTY
12938: LIST
12939: LIST
12940: PUSH
12941: LD_INT 23
12943: PUSH
12944: LD_INT 3
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: PUSH
12951: LD_INT 25
12953: PUSH
12954: LD_INT 1
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: PUSH
12961: LD_INT 26
12963: PUSH
12964: LD_INT 1
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: LIST
12975: LIST
12976: PPUSH
12977: CALL_OW 69
12981: PUSH
12982: LD_VAR 0 3
12986: DIFF
12987: ST_TO_ADDR
// if tmp then
12988: LD_VAR 0 2
12992: IFFALSE 13008
// result := tmp [ 1 ] ;
12994: LD_ADDR_VAR 0 1
12998: PUSH
12999: LD_VAR 0 2
13003: PUSH
13004: LD_INT 1
13006: ARRAY
13007: ST_TO_ADDR
// end ; end_of_file
13008: LD_VAR 0 1
13012: RET
// export function CustomEvent ( event ) ; begin
13013: LD_INT 0
13015: PPUSH
// end ;
13016: LD_VAR 0 2
13020: RET
// on UnitDestroyed ( un ) do var i , side ;
13021: LD_INT 0
13023: PPUSH
13024: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13025: LD_VAR 0 1
13029: PUSH
13030: LD_INT 22
13032: PUSH
13033: LD_INT 7
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PUSH
13040: LD_INT 2
13042: PUSH
13043: LD_INT 25
13045: PUSH
13046: LD_INT 1
13048: PUSH
13049: EMPTY
13050: LIST
13051: LIST
13052: PUSH
13053: LD_INT 25
13055: PUSH
13056: LD_INT 2
13058: PUSH
13059: EMPTY
13060: LIST
13061: LIST
13062: PUSH
13063: LD_INT 25
13065: PUSH
13066: LD_INT 3
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: PUSH
13073: LD_INT 25
13075: PUSH
13076: LD_INT 4
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: PUSH
13083: LD_INT 25
13085: PUSH
13086: LD_INT 5
13088: PUSH
13089: EMPTY
13090: LIST
13091: LIST
13092: PUSH
13093: LD_INT 25
13095: PUSH
13096: LD_INT 8
13098: PUSH
13099: EMPTY
13100: LIST
13101: LIST
13102: PUSH
13103: LD_INT 25
13105: PUSH
13106: LD_INT 9
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: PUSH
13113: EMPTY
13114: LIST
13115: LIST
13116: LIST
13117: LIST
13118: LIST
13119: LIST
13120: LIST
13121: LIST
13122: PUSH
13123: EMPTY
13124: LIST
13125: LIST
13126: PPUSH
13127: CALL_OW 69
13131: IN
13132: IFFALSE 13148
// loss_counter := loss_counter + 1 ;
13134: LD_ADDR_EXP 13
13138: PUSH
13139: LD_EXP 13
13143: PUSH
13144: LD_INT 1
13146: PLUS
13147: ST_TO_ADDR
// if un = Abdul then
13148: LD_VAR 0 1
13152: PUSH
13153: LD_EXP 55
13157: EQUAL
13158: IFFALSE 13168
// abdul_escaped := false ;
13160: LD_ADDR_EXP 12
13164: PUSH
13165: LD_INT 0
13167: ST_TO_ADDR
// if un in ru_attackers then
13168: LD_VAR 0 1
13172: PUSH
13173: LD_EXP 52
13177: IN
13178: IFFALSE 13196
// ru_attackers := ru_attackers diff un ;
13180: LD_ADDR_EXP 52
13184: PUSH
13185: LD_EXP 52
13189: PUSH
13190: LD_VAR 0 1
13194: DIFF
13195: ST_TO_ADDR
// if un in ar_attackers then
13196: LD_VAR 0 1
13200: PUSH
13201: LD_EXP 10
13205: IN
13206: IFFALSE 13224
// ar_attackers := ar_attackers diff un ;
13208: LD_ADDR_EXP 10
13212: PUSH
13213: LD_EXP 10
13217: PUSH
13218: LD_VAR 0 1
13222: DIFF
13223: ST_TO_ADDR
// if un = JMM then
13224: LD_VAR 0 1
13228: PUSH
13229: LD_EXP 15
13233: EQUAL
13234: IFFALSE 13245
// begin YouLost ( JMM ) ;
13236: LD_STRING JMM
13238: PPUSH
13239: CALL_OW 104
// exit ;
13243: GO 13334
// end ; if un = Burlak then
13245: LD_VAR 0 1
13249: PUSH
13250: LD_EXP 46
13254: EQUAL
13255: IFFALSE 13266
// begin YouLost ( Burlak ) ;
13257: LD_STRING Burlak
13259: PPUSH
13260: CALL_OW 104
// exit ;
13264: GO 13334
// end ; if un = freedom then
13266: LD_VAR 0 1
13270: PUSH
13271: LD_EXP 3
13275: EQUAL
13276: IFFALSE 13287
// begin YouLost ( Destroyed ) ;
13278: LD_STRING Destroyed
13280: PPUSH
13281: CALL_OW 104
// exit ;
13285: GO 13334
// end ; if un = Masha then
13287: LD_VAR 0 1
13291: PUSH
13292: LD_EXP 49
13296: EQUAL
13297: IFFALSE 13306
// ChangeMissionObjectives ( M4b ) ;
13299: LD_STRING M4b
13301: PPUSH
13302: CALL_OW 337
// if un = Mastodont then
13306: LD_VAR 0 1
13310: PUSH
13311: LD_EXP 56
13315: EQUAL
13316: IFFALSE 13325
// ChangeMissionObjectives ( M4a ) ;
13318: LD_STRING M4a
13320: PPUSH
13321: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13325: LD_VAR 0 1
13329: PPUSH
13330: CALL 84611 0 1
// end ;
13334: PPOPN 3
13336: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13337: LD_VAR 0 1
13341: PPUSH
13342: LD_VAR 0 2
13346: PPUSH
13347: CALL 86945 0 2
// end ;
13351: PPOPN 2
13353: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13354: LD_VAR 0 1
13358: PPUSH
13359: CALL 86013 0 1
// end ;
13363: PPOPN 1
13365: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13366: LD_VAR 0 1
13370: PUSH
13371: LD_INT 22
13373: PUSH
13374: LD_INT 7
13376: PUSH
13377: EMPTY
13378: LIST
13379: LIST
13380: PUSH
13381: LD_INT 30
13383: PUSH
13384: LD_INT 0
13386: PUSH
13387: EMPTY
13388: LIST
13389: LIST
13390: PUSH
13391: EMPTY
13392: LIST
13393: LIST
13394: PPUSH
13395: CALL_OW 69
13399: IN
13400: IFFALSE 13439
// begin SetBName ( building , freedom ) ;
13402: LD_VAR 0 1
13406: PPUSH
13407: LD_STRING freedom
13409: PPUSH
13410: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13414: LD_INT 0
13416: PPUSH
13417: LD_INT 7
13419: PPUSH
13420: LD_INT 0
13422: PPUSH
13423: CALL_OW 324
// freedom := building ;
13427: LD_ADDR_EXP 3
13431: PUSH
13432: LD_VAR 0 1
13436: ST_TO_ADDR
// exit ;
13437: GO 13505
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13439: LD_VAR 0 1
13443: PUSH
13444: LD_INT 22
13446: PUSH
13447: LD_INT 7
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PUSH
13454: LD_INT 23
13456: PUSH
13457: LD_INT 3
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 30
13466: PUSH
13467: LD_INT 6
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: LIST
13478: PPUSH
13479: CALL_OW 69
13483: IN
13484: IFFALSE 13496
// begin ru_lab_builded := true ;
13486: LD_ADDR_EXP 5
13490: PUSH
13491: LD_INT 1
13493: ST_TO_ADDR
// exit ;
13494: GO 13505
// end ; MCE_BuildingComplete ( building ) ;
13496: LD_VAR 0 1
13500: PPUSH
13501: CALL 86254 0 1
// end ;
13505: PPOPN 1
13507: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13508: LD_VAR 0 1
13512: PPUSH
13513: LD_VAR 0 2
13517: PPUSH
13518: CALL 84307 0 2
// end ;
13522: PPOPN 2
13524: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13525: LD_VAR 0 1
13529: PPUSH
13530: LD_VAR 0 2
13534: PPUSH
13535: LD_VAR 0 3
13539: PPUSH
13540: LD_VAR 0 4
13544: PPUSH
13545: LD_VAR 0 5
13549: PPUSH
13550: CALL 83927 0 5
// end ;
13554: PPOPN 5
13556: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13557: LD_VAR 0 1
13561: PPUSH
13562: LD_VAR 0 2
13566: PPUSH
13567: CALL 83523 0 2
// end ;
13571: PPOPN 2
13573: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
13574: LD_VAR 0 1
13578: PPUSH
13579: CALL_OW 263
13583: PUSH
13584: LD_INT 3
13586: EQUAL
13587: PUSH
13588: LD_VAR 0 2
13592: PPUSH
13593: CALL_OW 263
13597: PUSH
13598: LD_INT 3
13600: EQUAL
13601: OR
13602: IFFALSE 13618
// hack_counter := hack_counter + 1 ;
13604: LD_ADDR_EXP 14
13608: PUSH
13609: LD_EXP 14
13613: PUSH
13614: LD_INT 1
13616: PLUS
13617: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13618: LD_VAR 0 1
13622: PPUSH
13623: LD_VAR 0 2
13627: PPUSH
13628: LD_VAR 0 3
13632: PPUSH
13633: LD_VAR 0 4
13637: PPUSH
13638: CALL 83361 0 4
// end ;
13642: PPOPN 4
13644: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13645: LD_VAR 0 1
13649: PPUSH
13650: LD_VAR 0 2
13654: PPUSH
13655: LD_VAR 0 3
13659: PPUSH
13660: CALL 83136 0 3
// end ;
13664: PPOPN 3
13666: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13667: LD_VAR 0 1
13671: PPUSH
13672: LD_VAR 0 2
13676: PPUSH
13677: CALL 83021 0 2
// end ;
13681: PPOPN 2
13683: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13684: LD_VAR 0 1
13688: PPUSH
13689: LD_VAR 0 2
13693: PPUSH
13694: CALL 87206 0 2
// end ;
13698: PPOPN 2
13700: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13701: LD_VAR 0 1
13705: PPUSH
13706: LD_VAR 0 2
13710: PPUSH
13711: LD_VAR 0 3
13715: PPUSH
13716: LD_VAR 0 4
13720: PPUSH
13721: CALL 87422 0 4
// end ;
13725: PPOPN 4
13727: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13728: LD_VAR 0 1
13732: PPUSH
13733: LD_VAR 0 2
13737: PPUSH
13738: CALL 82830 0 2
// end ;
13742: PPOPN 2
13744: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13745: LD_VAR 0 1
13749: PPUSH
13750: CALL 98544 0 1
// end ; end_of_file
13754: PPOPN 1
13756: END
// every 0 0$30 do var cr , time ;
13757: GO 13759
13759: DISABLE
13760: LD_INT 0
13762: PPUSH
13763: PPUSH
// begin time := 0 0$30 ;
13764: LD_ADDR_VAR 0 2
13768: PUSH
13769: LD_INT 1050
13771: ST_TO_ADDR
// while game do
13772: LD_EXP 2
13776: IFFALSE 13875
// begin wait ( time ) ;
13778: LD_VAR 0 2
13782: PPUSH
13783: CALL_OW 67
// if tick > 2 2$00 then
13787: LD_OWVAR 1
13791: PUSH
13792: LD_INT 4200
13794: GREATER
13795: IFFALSE 13828
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13797: LD_ADDR_VAR 0 2
13801: PUSH
13802: LD_VAR 0 2
13806: PUSH
13807: LD_INT 280
13809: PUSH
13810: LD_INT 420
13812: PUSH
13813: LD_INT 630
13815: PUSH
13816: EMPTY
13817: LIST
13818: LIST
13819: LIST
13820: PUSH
13821: LD_OWVAR 67
13825: ARRAY
13826: PLUS
13827: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13828: LD_INT 1
13830: PPUSH
13831: LD_INT 5
13833: PPUSH
13834: CALL_OW 12
13838: PPUSH
13839: LD_INT 70
13841: PPUSH
13842: LD_INT 49
13844: PPUSH
13845: LD_INT 25
13847: PPUSH
13848: LD_INT 1
13850: PPUSH
13851: CALL_OW 56
// if time > 5 5$00 then
13855: LD_VAR 0 2
13859: PUSH
13860: LD_INT 10500
13862: GREATER
13863: IFFALSE 13873
// time := 0 0$30 ;
13865: LD_ADDR_VAR 0 2
13869: PUSH
13870: LD_INT 1050
13872: ST_TO_ADDR
// end ;
13873: GO 13772
// end ;
13875: PPOPN 2
13877: END
// every 0 0$30 do var cr , time ;
13878: GO 13880
13880: DISABLE
13881: LD_INT 0
13883: PPUSH
13884: PPUSH
// begin time := 0 0$20 ;
13885: LD_ADDR_VAR 0 2
13889: PUSH
13890: LD_INT 700
13892: ST_TO_ADDR
// while game do
13893: LD_EXP 2
13897: IFFALSE 13986
// begin wait ( time ) ;
13899: LD_VAR 0 2
13903: PPUSH
13904: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13908: LD_ADDR_VAR 0 2
13912: PUSH
13913: LD_VAR 0 2
13917: PUSH
13918: LD_INT 490
13920: PUSH
13921: LD_INT 525
13923: PUSH
13924: LD_INT 560
13926: PUSH
13927: EMPTY
13928: LIST
13929: LIST
13930: LIST
13931: PUSH
13932: LD_OWVAR 67
13936: ARRAY
13937: PLUS
13938: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13939: LD_INT 3
13941: PPUSH
13942: LD_INT 5
13944: PPUSH
13945: CALL_OW 12
13949: PPUSH
13950: LD_INT 26
13952: PPUSH
13953: LD_INT 9
13955: PPUSH
13956: LD_INT 30
13958: PPUSH
13959: LD_INT 1
13961: PPUSH
13962: CALL_OW 56
// if time > 3 3$00 then
13966: LD_VAR 0 2
13970: PUSH
13971: LD_INT 6300
13973: GREATER
13974: IFFALSE 13984
// time := 0 0$20 ;
13976: LD_ADDR_VAR 0 2
13980: PUSH
13981: LD_INT 700
13983: ST_TO_ADDR
// end ;
13984: GO 13893
// end ;
13986: PPOPN 2
13988: END
// every 0 0$30 do var cr , time ;
13989: GO 13991
13991: DISABLE
13992: LD_INT 0
13994: PPUSH
13995: PPUSH
// begin time := 0 0$20 ;
13996: LD_ADDR_VAR 0 2
14000: PUSH
14001: LD_INT 700
14003: ST_TO_ADDR
// while game do
14004: LD_EXP 2
14008: IFFALSE 14133
// begin wait ( time ) ;
14010: LD_VAR 0 2
14014: PPUSH
14015: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14019: LD_ADDR_VAR 0 2
14023: PUSH
14024: LD_VAR 0 2
14028: PUSH
14029: LD_INT 175
14031: PUSH
14032: LD_INT 210
14034: PUSH
14035: LD_INT 280
14037: PUSH
14038: EMPTY
14039: LIST
14040: LIST
14041: LIST
14042: PUSH
14043: LD_OWVAR 67
14047: ARRAY
14048: PLUS
14049: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14050: LD_INT 1
14052: PPUSH
14053: LD_INT 5
14055: PPUSH
14056: CALL_OW 12
14060: PPUSH
14061: LD_INT 179
14063: PPUSH
14064: LD_INT 101
14066: PPUSH
14067: LD_INT 20
14069: PPUSH
14070: LD_INT 1
14072: PPUSH
14073: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14077: LD_INT 350
14079: PPUSH
14080: LD_INT 525
14082: PPUSH
14083: CALL_OW 12
14087: PPUSH
14088: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14092: LD_INT 1
14094: PPUSH
14095: LD_INT 5
14097: PPUSH
14098: CALL_OW 12
14102: PPUSH
14103: LD_INT 9
14105: PPUSH
14106: LD_INT 1
14108: PPUSH
14109: CALL_OW 55
// if time > 4 4$00 then
14113: LD_VAR 0 2
14117: PUSH
14118: LD_INT 8400
14120: GREATER
14121: IFFALSE 14131
// time := 0 0$30 ;
14123: LD_ADDR_VAR 0 2
14127: PUSH
14128: LD_INT 1050
14130: ST_TO_ADDR
// end ;
14131: GO 14004
// end ;
14133: PPOPN 2
14135: END
// every 0 0$30 do var cr , time ;
14136: GO 14138
14138: DISABLE
14139: LD_INT 0
14141: PPUSH
14142: PPUSH
// begin time := 0 0$10 ;
14143: LD_ADDR_VAR 0 2
14147: PUSH
14148: LD_INT 350
14150: ST_TO_ADDR
// while game do
14151: LD_EXP 2
14155: IFFALSE 14289
// begin wait ( time ) ;
14157: LD_VAR 0 2
14161: PPUSH
14162: CALL_OW 67
// time := time + 0 0$10 ;
14166: LD_ADDR_VAR 0 2
14170: PUSH
14171: LD_VAR 0 2
14175: PUSH
14176: LD_INT 350
14178: PLUS
14179: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14180: LD_INT 1
14182: PPUSH
14183: LD_INT 5
14185: PPUSH
14186: CALL_OW 12
14190: PPUSH
14191: LD_INT 11
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14201: LD_ADDR_VAR 0 1
14205: PUSH
14206: LD_INT 1
14208: PPUSH
14209: LD_INT 3
14211: PPUSH
14212: CALL_OW 12
14216: ST_TO_ADDR
// if cr = 1 then
14217: LD_VAR 0 1
14221: PUSH
14222: LD_INT 1
14224: EQUAL
14225: IFFALSE 14269
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14227: LD_INT 700
14229: PPUSH
14230: LD_INT 1575
14232: PPUSH
14233: CALL_OW 12
14237: PPUSH
14238: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14242: LD_INT 1
14244: PPUSH
14245: LD_INT 5
14247: PPUSH
14248: CALL_OW 12
14252: PPUSH
14253: LD_INT 34
14255: PPUSH
14256: LD_INT 50
14258: PPUSH
14259: LD_INT 7
14261: PPUSH
14262: LD_INT 1
14264: PPUSH
14265: CALL_OW 56
// end ; if time > 8 8$00 then
14269: LD_VAR 0 2
14273: PUSH
14274: LD_INT 16800
14276: GREATER
14277: IFFALSE 14287
// time := 0 0$40 ;
14279: LD_ADDR_VAR 0 2
14283: PUSH
14284: LD_INT 1400
14286: ST_TO_ADDR
// end ;
14287: GO 14151
// end ; end_of_file
14289: PPOPN 2
14291: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14292: LD_INT 0
14294: PPUSH
14295: PPUSH
// if exist_mode then
14296: LD_VAR 0 2
14300: IFFALSE 14325
// unit := CreateCharacter ( prefix & ident ) else
14302: LD_ADDR_VAR 0 5
14306: PUSH
14307: LD_VAR 0 3
14311: PUSH
14312: LD_VAR 0 1
14316: STR
14317: PPUSH
14318: CALL_OW 34
14322: ST_TO_ADDR
14323: GO 14340
// unit := NewCharacter ( ident ) ;
14325: LD_ADDR_VAR 0 5
14329: PUSH
14330: LD_VAR 0 1
14334: PPUSH
14335: CALL_OW 25
14339: ST_TO_ADDR
// result := unit ;
14340: LD_ADDR_VAR 0 4
14344: PUSH
14345: LD_VAR 0 5
14349: ST_TO_ADDR
// end ;
14350: LD_VAR 0 4
14354: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14355: LD_INT 0
14357: PPUSH
14358: PPUSH
// if not side or not nation then
14359: LD_VAR 0 1
14363: NOT
14364: PUSH
14365: LD_VAR 0 2
14369: NOT
14370: OR
14371: IFFALSE 14375
// exit ;
14373: GO 15079
// case nation of nation_american :
14375: LD_VAR 0 2
14379: PUSH
14380: LD_INT 1
14382: DOUBLE
14383: EQUAL
14384: IFTRUE 14388
14386: GO 14582
14388: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
14389: LD_ADDR_VAR 0 4
14393: PUSH
14394: LD_INT 35
14396: PUSH
14397: LD_INT 45
14399: PUSH
14400: LD_INT 46
14402: PUSH
14403: LD_INT 47
14405: PUSH
14406: LD_INT 82
14408: PUSH
14409: LD_INT 83
14411: PUSH
14412: LD_INT 84
14414: PUSH
14415: LD_INT 85
14417: PUSH
14418: LD_INT 86
14420: PUSH
14421: LD_INT 1
14423: PUSH
14424: LD_INT 2
14426: PUSH
14427: LD_INT 6
14429: PUSH
14430: LD_INT 15
14432: PUSH
14433: LD_INT 16
14435: PUSH
14436: LD_INT 7
14438: PUSH
14439: LD_INT 12
14441: PUSH
14442: LD_INT 13
14444: PUSH
14445: LD_INT 10
14447: PUSH
14448: LD_INT 14
14450: PUSH
14451: LD_INT 20
14453: PUSH
14454: LD_INT 21
14456: PUSH
14457: LD_INT 22
14459: PUSH
14460: LD_INT 25
14462: PUSH
14463: LD_INT 32
14465: PUSH
14466: LD_INT 27
14468: PUSH
14469: LD_INT 36
14471: PUSH
14472: LD_INT 69
14474: PUSH
14475: LD_INT 39
14477: PUSH
14478: LD_INT 34
14480: PUSH
14481: LD_INT 40
14483: PUSH
14484: LD_INT 48
14486: PUSH
14487: LD_INT 49
14489: PUSH
14490: LD_INT 50
14492: PUSH
14493: LD_INT 51
14495: PUSH
14496: LD_INT 52
14498: PUSH
14499: LD_INT 53
14501: PUSH
14502: LD_INT 54
14504: PUSH
14505: LD_INT 55
14507: PUSH
14508: LD_INT 56
14510: PUSH
14511: LD_INT 57
14513: PUSH
14514: LD_INT 58
14516: PUSH
14517: LD_INT 59
14519: PUSH
14520: LD_INT 60
14522: PUSH
14523: LD_INT 61
14525: PUSH
14526: LD_INT 62
14528: PUSH
14529: LD_INT 80
14531: PUSH
14532: EMPTY
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: ST_TO_ADDR
14580: GO 15003
14582: LD_INT 2
14584: DOUBLE
14585: EQUAL
14586: IFTRUE 14590
14588: GO 14792
14590: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
14591: LD_ADDR_VAR 0 4
14595: PUSH
14596: LD_INT 35
14598: PUSH
14599: LD_INT 45
14601: PUSH
14602: LD_INT 46
14604: PUSH
14605: LD_INT 47
14607: PUSH
14608: LD_INT 82
14610: PUSH
14611: LD_INT 83
14613: PUSH
14614: LD_INT 84
14616: PUSH
14617: LD_INT 85
14619: PUSH
14620: LD_INT 87
14622: PUSH
14623: LD_INT 70
14625: PUSH
14626: LD_INT 1
14628: PUSH
14629: LD_INT 11
14631: PUSH
14632: LD_INT 3
14634: PUSH
14635: LD_INT 4
14637: PUSH
14638: LD_INT 5
14640: PUSH
14641: LD_INT 6
14643: PUSH
14644: LD_INT 15
14646: PUSH
14647: LD_INT 18
14649: PUSH
14650: LD_INT 7
14652: PUSH
14653: LD_INT 17
14655: PUSH
14656: LD_INT 8
14658: PUSH
14659: LD_INT 20
14661: PUSH
14662: LD_INT 21
14664: PUSH
14665: LD_INT 22
14667: PUSH
14668: LD_INT 72
14670: PUSH
14671: LD_INT 26
14673: PUSH
14674: LD_INT 69
14676: PUSH
14677: LD_INT 39
14679: PUSH
14680: LD_INT 40
14682: PUSH
14683: LD_INT 41
14685: PUSH
14686: LD_INT 42
14688: PUSH
14689: LD_INT 43
14691: PUSH
14692: LD_INT 48
14694: PUSH
14695: LD_INT 49
14697: PUSH
14698: LD_INT 50
14700: PUSH
14701: LD_INT 51
14703: PUSH
14704: LD_INT 52
14706: PUSH
14707: LD_INT 53
14709: PUSH
14710: LD_INT 54
14712: PUSH
14713: LD_INT 55
14715: PUSH
14716: LD_INT 56
14718: PUSH
14719: LD_INT 60
14721: PUSH
14722: LD_INT 61
14724: PUSH
14725: LD_INT 62
14727: PUSH
14728: LD_INT 66
14730: PUSH
14731: LD_INT 67
14733: PUSH
14734: LD_INT 68
14736: PUSH
14737: LD_INT 81
14739: PUSH
14740: EMPTY
14741: LIST
14742: LIST
14743: LIST
14744: LIST
14745: LIST
14746: LIST
14747: LIST
14748: LIST
14749: LIST
14750: LIST
14751: LIST
14752: LIST
14753: LIST
14754: LIST
14755: LIST
14756: LIST
14757: LIST
14758: LIST
14759: LIST
14760: LIST
14761: LIST
14762: LIST
14763: LIST
14764: LIST
14765: LIST
14766: LIST
14767: LIST
14768: LIST
14769: LIST
14770: LIST
14771: LIST
14772: LIST
14773: LIST
14774: LIST
14775: LIST
14776: LIST
14777: LIST
14778: LIST
14779: LIST
14780: LIST
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: ST_TO_ADDR
14790: GO 15003
14792: LD_INT 3
14794: DOUBLE
14795: EQUAL
14796: IFTRUE 14800
14798: GO 15002
14800: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14801: LD_ADDR_VAR 0 4
14805: PUSH
14806: LD_INT 46
14808: PUSH
14809: LD_INT 47
14811: PUSH
14812: LD_INT 1
14814: PUSH
14815: LD_INT 2
14817: PUSH
14818: LD_INT 82
14820: PUSH
14821: LD_INT 83
14823: PUSH
14824: LD_INT 84
14826: PUSH
14827: LD_INT 85
14829: PUSH
14830: LD_INT 86
14832: PUSH
14833: LD_INT 11
14835: PUSH
14836: LD_INT 9
14838: PUSH
14839: LD_INT 20
14841: PUSH
14842: LD_INT 19
14844: PUSH
14845: LD_INT 21
14847: PUSH
14848: LD_INT 24
14850: PUSH
14851: LD_INT 22
14853: PUSH
14854: LD_INT 25
14856: PUSH
14857: LD_INT 28
14859: PUSH
14860: LD_INT 29
14862: PUSH
14863: LD_INT 30
14865: PUSH
14866: LD_INT 31
14868: PUSH
14869: LD_INT 37
14871: PUSH
14872: LD_INT 38
14874: PUSH
14875: LD_INT 32
14877: PUSH
14878: LD_INT 27
14880: PUSH
14881: LD_INT 33
14883: PUSH
14884: LD_INT 69
14886: PUSH
14887: LD_INT 39
14889: PUSH
14890: LD_INT 34
14892: PUSH
14893: LD_INT 40
14895: PUSH
14896: LD_INT 71
14898: PUSH
14899: LD_INT 23
14901: PUSH
14902: LD_INT 44
14904: PUSH
14905: LD_INT 48
14907: PUSH
14908: LD_INT 49
14910: PUSH
14911: LD_INT 50
14913: PUSH
14914: LD_INT 51
14916: PUSH
14917: LD_INT 52
14919: PUSH
14920: LD_INT 53
14922: PUSH
14923: LD_INT 54
14925: PUSH
14926: LD_INT 55
14928: PUSH
14929: LD_INT 56
14931: PUSH
14932: LD_INT 57
14934: PUSH
14935: LD_INT 58
14937: PUSH
14938: LD_INT 59
14940: PUSH
14941: LD_INT 63
14943: PUSH
14944: LD_INT 64
14946: PUSH
14947: LD_INT 65
14949: PUSH
14950: EMPTY
14951: LIST
14952: LIST
14953: LIST
14954: LIST
14955: LIST
14956: LIST
14957: LIST
14958: LIST
14959: LIST
14960: LIST
14961: LIST
14962: LIST
14963: LIST
14964: LIST
14965: LIST
14966: LIST
14967: LIST
14968: LIST
14969: LIST
14970: LIST
14971: LIST
14972: LIST
14973: LIST
14974: LIST
14975: LIST
14976: LIST
14977: LIST
14978: LIST
14979: LIST
14980: LIST
14981: LIST
14982: LIST
14983: LIST
14984: LIST
14985: LIST
14986: LIST
14987: LIST
14988: LIST
14989: LIST
14990: LIST
14991: LIST
14992: LIST
14993: LIST
14994: LIST
14995: LIST
14996: LIST
14997: LIST
14998: LIST
14999: ST_TO_ADDR
15000: GO 15003
15002: POP
// if state > - 1 and state < 3 then
15003: LD_VAR 0 3
15007: PUSH
15008: LD_INT 1
15010: NEG
15011: GREATER
15012: PUSH
15013: LD_VAR 0 3
15017: PUSH
15018: LD_INT 3
15020: LESS
15021: AND
15022: IFFALSE 15079
// for i in result do
15024: LD_ADDR_VAR 0 5
15028: PUSH
15029: LD_VAR 0 4
15033: PUSH
15034: FOR_IN
15035: IFFALSE 15077
// if GetTech ( i , side ) <> state then
15037: LD_VAR 0 5
15041: PPUSH
15042: LD_VAR 0 1
15046: PPUSH
15047: CALL_OW 321
15051: PUSH
15052: LD_VAR 0 3
15056: NONEQUAL
15057: IFFALSE 15075
// result := result diff i ;
15059: LD_ADDR_VAR 0 4
15063: PUSH
15064: LD_VAR 0 4
15068: PUSH
15069: LD_VAR 0 5
15073: DIFF
15074: ST_TO_ADDR
15075: GO 15034
15077: POP
15078: POP
// end ;
15079: LD_VAR 0 4
15083: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15084: LD_INT 0
15086: PPUSH
15087: PPUSH
15088: PPUSH
// result := true ;
15089: LD_ADDR_VAR 0 3
15093: PUSH
15094: LD_INT 1
15096: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15097: LD_ADDR_VAR 0 5
15101: PUSH
15102: LD_VAR 0 2
15106: PPUSH
15107: CALL_OW 480
15111: ST_TO_ADDR
// if not tmp then
15112: LD_VAR 0 5
15116: NOT
15117: IFFALSE 15121
// exit ;
15119: GO 15170
// for i in tmp do
15121: LD_ADDR_VAR 0 4
15125: PUSH
15126: LD_VAR 0 5
15130: PUSH
15131: FOR_IN
15132: IFFALSE 15168
// if GetTech ( i , side ) <> state_researched then
15134: LD_VAR 0 4
15138: PPUSH
15139: LD_VAR 0 1
15143: PPUSH
15144: CALL_OW 321
15148: PUSH
15149: LD_INT 2
15151: NONEQUAL
15152: IFFALSE 15166
// begin result := false ;
15154: LD_ADDR_VAR 0 3
15158: PUSH
15159: LD_INT 0
15161: ST_TO_ADDR
// exit ;
15162: POP
15163: POP
15164: GO 15170
// end ;
15166: GO 15131
15168: POP
15169: POP
// end ;
15170: LD_VAR 0 3
15174: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15175: LD_INT 0
15177: PPUSH
15178: PPUSH
15179: PPUSH
15180: PPUSH
15181: PPUSH
15182: PPUSH
15183: PPUSH
15184: PPUSH
15185: PPUSH
15186: PPUSH
15187: PPUSH
15188: PPUSH
15189: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15190: LD_VAR 0 1
15194: NOT
15195: PUSH
15196: LD_VAR 0 1
15200: PPUSH
15201: CALL_OW 257
15205: PUSH
15206: LD_INT 9
15208: NONEQUAL
15209: OR
15210: IFFALSE 15214
// exit ;
15212: GO 15787
// side := GetSide ( unit ) ;
15214: LD_ADDR_VAR 0 9
15218: PUSH
15219: LD_VAR 0 1
15223: PPUSH
15224: CALL_OW 255
15228: ST_TO_ADDR
// tech_space := tech_spacanom ;
15229: LD_ADDR_VAR 0 12
15233: PUSH
15234: LD_INT 29
15236: ST_TO_ADDR
// tech_time := tech_taurad ;
15237: LD_ADDR_VAR 0 13
15241: PUSH
15242: LD_INT 28
15244: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15245: LD_ADDR_VAR 0 11
15249: PUSH
15250: LD_VAR 0 1
15254: PPUSH
15255: CALL_OW 310
15259: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15260: LD_VAR 0 11
15264: PPUSH
15265: CALL_OW 247
15269: PUSH
15270: LD_INT 2
15272: EQUAL
15273: IFFALSE 15277
// exit ;
15275: GO 15787
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15277: LD_ADDR_VAR 0 8
15281: PUSH
15282: LD_INT 81
15284: PUSH
15285: LD_VAR 0 9
15289: PUSH
15290: EMPTY
15291: LIST
15292: LIST
15293: PUSH
15294: LD_INT 3
15296: PUSH
15297: LD_INT 21
15299: PUSH
15300: LD_INT 3
15302: PUSH
15303: EMPTY
15304: LIST
15305: LIST
15306: PUSH
15307: EMPTY
15308: LIST
15309: LIST
15310: PUSH
15311: EMPTY
15312: LIST
15313: LIST
15314: PPUSH
15315: CALL_OW 69
15319: ST_TO_ADDR
// if not tmp then
15320: LD_VAR 0 8
15324: NOT
15325: IFFALSE 15329
// exit ;
15327: GO 15787
// if in_unit then
15329: LD_VAR 0 11
15333: IFFALSE 15357
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15335: LD_ADDR_VAR 0 10
15339: PUSH
15340: LD_VAR 0 8
15344: PPUSH
15345: LD_VAR 0 11
15349: PPUSH
15350: CALL_OW 74
15354: ST_TO_ADDR
15355: GO 15377
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15357: LD_ADDR_VAR 0 10
15361: PUSH
15362: LD_VAR 0 8
15366: PPUSH
15367: LD_VAR 0 1
15371: PPUSH
15372: CALL_OW 74
15376: ST_TO_ADDR
// if not enemy then
15377: LD_VAR 0 10
15381: NOT
15382: IFFALSE 15386
// exit ;
15384: GO 15787
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15386: LD_VAR 0 11
15390: PUSH
15391: LD_VAR 0 11
15395: PPUSH
15396: LD_VAR 0 10
15400: PPUSH
15401: CALL_OW 296
15405: PUSH
15406: LD_INT 13
15408: GREATER
15409: AND
15410: PUSH
15411: LD_VAR 0 1
15415: PPUSH
15416: LD_VAR 0 10
15420: PPUSH
15421: CALL_OW 296
15425: PUSH
15426: LD_INT 12
15428: GREATER
15429: OR
15430: IFFALSE 15434
// exit ;
15432: GO 15787
// missile := [ 1 ] ;
15434: LD_ADDR_VAR 0 14
15438: PUSH
15439: LD_INT 1
15441: PUSH
15442: EMPTY
15443: LIST
15444: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15445: LD_VAR 0 9
15449: PPUSH
15450: LD_VAR 0 12
15454: PPUSH
15455: CALL_OW 325
15459: IFFALSE 15488
// missile := Insert ( missile , missile + 1 , 2 ) ;
15461: LD_ADDR_VAR 0 14
15465: PUSH
15466: LD_VAR 0 14
15470: PPUSH
15471: LD_VAR 0 14
15475: PUSH
15476: LD_INT 1
15478: PLUS
15479: PPUSH
15480: LD_INT 2
15482: PPUSH
15483: CALL_OW 2
15487: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15488: LD_VAR 0 9
15492: PPUSH
15493: LD_VAR 0 13
15497: PPUSH
15498: CALL_OW 325
15502: PUSH
15503: LD_VAR 0 10
15507: PPUSH
15508: CALL_OW 255
15512: PPUSH
15513: LD_VAR 0 13
15517: PPUSH
15518: CALL_OW 325
15522: NOT
15523: AND
15524: IFFALSE 15553
// missile := Insert ( missile , missile + 1 , 3 ) ;
15526: LD_ADDR_VAR 0 14
15530: PUSH
15531: LD_VAR 0 14
15535: PPUSH
15536: LD_VAR 0 14
15540: PUSH
15541: LD_INT 1
15543: PLUS
15544: PPUSH
15545: LD_INT 3
15547: PPUSH
15548: CALL_OW 2
15552: ST_TO_ADDR
// if missile < 2 then
15553: LD_VAR 0 14
15557: PUSH
15558: LD_INT 2
15560: LESS
15561: IFFALSE 15565
// exit ;
15563: GO 15787
// x := GetX ( enemy ) ;
15565: LD_ADDR_VAR 0 4
15569: PUSH
15570: LD_VAR 0 10
15574: PPUSH
15575: CALL_OW 250
15579: ST_TO_ADDR
// y := GetY ( enemy ) ;
15580: LD_ADDR_VAR 0 5
15584: PUSH
15585: LD_VAR 0 10
15589: PPUSH
15590: CALL_OW 251
15594: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15595: LD_ADDR_VAR 0 6
15599: PUSH
15600: LD_VAR 0 4
15604: PUSH
15605: LD_INT 1
15607: NEG
15608: PPUSH
15609: LD_INT 1
15611: PPUSH
15612: CALL_OW 12
15616: PLUS
15617: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15618: LD_ADDR_VAR 0 7
15622: PUSH
15623: LD_VAR 0 5
15627: PUSH
15628: LD_INT 1
15630: NEG
15631: PPUSH
15632: LD_INT 1
15634: PPUSH
15635: CALL_OW 12
15639: PLUS
15640: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15641: LD_VAR 0 6
15645: PPUSH
15646: LD_VAR 0 7
15650: PPUSH
15651: CALL_OW 488
15655: NOT
15656: IFFALSE 15678
// begin _x := x ;
15658: LD_ADDR_VAR 0 6
15662: PUSH
15663: LD_VAR 0 4
15667: ST_TO_ADDR
// _y := y ;
15668: LD_ADDR_VAR 0 7
15672: PUSH
15673: LD_VAR 0 5
15677: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15678: LD_ADDR_VAR 0 3
15682: PUSH
15683: LD_INT 1
15685: PPUSH
15686: LD_VAR 0 14
15690: PPUSH
15691: CALL_OW 12
15695: ST_TO_ADDR
// case i of 1 :
15696: LD_VAR 0 3
15700: PUSH
15701: LD_INT 1
15703: DOUBLE
15704: EQUAL
15705: IFTRUE 15709
15707: GO 15726
15709: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15710: LD_VAR 0 1
15714: PPUSH
15715: LD_VAR 0 10
15719: PPUSH
15720: CALL_OW 115
15724: GO 15787
15726: LD_INT 2
15728: DOUBLE
15729: EQUAL
15730: IFTRUE 15734
15732: GO 15756
15734: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15735: LD_VAR 0 1
15739: PPUSH
15740: LD_VAR 0 6
15744: PPUSH
15745: LD_VAR 0 7
15749: PPUSH
15750: CALL_OW 153
15754: GO 15787
15756: LD_INT 3
15758: DOUBLE
15759: EQUAL
15760: IFTRUE 15764
15762: GO 15786
15764: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15765: LD_VAR 0 1
15769: PPUSH
15770: LD_VAR 0 6
15774: PPUSH
15775: LD_VAR 0 7
15779: PPUSH
15780: CALL_OW 154
15784: GO 15787
15786: POP
// end ;
15787: LD_VAR 0 2
15791: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15792: LD_INT 0
15794: PPUSH
15795: PPUSH
15796: PPUSH
15797: PPUSH
15798: PPUSH
15799: PPUSH
// if not unit or not building then
15800: LD_VAR 0 1
15804: NOT
15805: PUSH
15806: LD_VAR 0 2
15810: NOT
15811: OR
15812: IFFALSE 15816
// exit ;
15814: GO 15974
// x := GetX ( building ) ;
15816: LD_ADDR_VAR 0 5
15820: PUSH
15821: LD_VAR 0 2
15825: PPUSH
15826: CALL_OW 250
15830: ST_TO_ADDR
// y := GetY ( building ) ;
15831: LD_ADDR_VAR 0 6
15835: PUSH
15836: LD_VAR 0 2
15840: PPUSH
15841: CALL_OW 251
15845: ST_TO_ADDR
// for i = 0 to 5 do
15846: LD_ADDR_VAR 0 4
15850: PUSH
15851: DOUBLE
15852: LD_INT 0
15854: DEC
15855: ST_TO_ADDR
15856: LD_INT 5
15858: PUSH
15859: FOR_TO
15860: IFFALSE 15972
// begin _x := ShiftX ( x , i , 3 ) ;
15862: LD_ADDR_VAR 0 7
15866: PUSH
15867: LD_VAR 0 5
15871: PPUSH
15872: LD_VAR 0 4
15876: PPUSH
15877: LD_INT 3
15879: PPUSH
15880: CALL_OW 272
15884: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15885: LD_ADDR_VAR 0 8
15889: PUSH
15890: LD_VAR 0 6
15894: PPUSH
15895: LD_VAR 0 4
15899: PPUSH
15900: LD_INT 3
15902: PPUSH
15903: CALL_OW 273
15907: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15908: LD_VAR 0 7
15912: PPUSH
15913: LD_VAR 0 8
15917: PPUSH
15918: CALL_OW 488
15922: NOT
15923: IFFALSE 15927
// continue ;
15925: GO 15859
// if HexInfo ( _x , _y ) = 0 then
15927: LD_VAR 0 7
15931: PPUSH
15932: LD_VAR 0 8
15936: PPUSH
15937: CALL_OW 428
15941: PUSH
15942: LD_INT 0
15944: EQUAL
15945: IFFALSE 15970
// begin ComMoveXY ( unit , _x , _y ) ;
15947: LD_VAR 0 1
15951: PPUSH
15952: LD_VAR 0 7
15956: PPUSH
15957: LD_VAR 0 8
15961: PPUSH
15962: CALL_OW 111
// exit ;
15966: POP
15967: POP
15968: GO 15974
// end ; end ;
15970: GO 15859
15972: POP
15973: POP
// end ;
15974: LD_VAR 0 3
15978: RET
// export function ScanBase ( side , base_area ) ; begin
15979: LD_INT 0
15981: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15982: LD_ADDR_VAR 0 3
15986: PUSH
15987: LD_VAR 0 2
15991: PPUSH
15992: LD_INT 81
15994: PUSH
15995: LD_VAR 0 1
15999: PUSH
16000: EMPTY
16001: LIST
16002: LIST
16003: PPUSH
16004: CALL_OW 70
16008: ST_TO_ADDR
// end ;
16009: LD_VAR 0 3
16013: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
16014: LD_INT 0
16016: PPUSH
16017: PPUSH
16018: PPUSH
16019: PPUSH
16020: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
16021: LD_VAR 0 1
16025: NOT
16026: PUSH
16027: LD_EXP 59
16031: PUSH
16032: LD_VAR 0 1
16036: ARRAY
16037: NOT
16038: OR
16039: PUSH
16040: LD_VAR 0 2
16044: NOT
16045: OR
16046: PUSH
16047: LD_VAR 0 3
16051: NOT
16052: OR
16053: IFFALSE 16057
// exit ;
16055: GO 16570
// side := mc_sides [ base ] ;
16057: LD_ADDR_VAR 0 6
16061: PUSH
16062: LD_EXP 85
16066: PUSH
16067: LD_VAR 0 1
16071: ARRAY
16072: ST_TO_ADDR
// if not side then
16073: LD_VAR 0 6
16077: NOT
16078: IFFALSE 16082
// exit ;
16080: GO 16570
// for i in solds do
16082: LD_ADDR_VAR 0 7
16086: PUSH
16087: LD_VAR 0 2
16091: PUSH
16092: FOR_IN
16093: IFFALSE 16154
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
16095: LD_VAR 0 7
16099: PPUSH
16100: CALL_OW 310
16104: PPUSH
16105: CALL_OW 266
16109: PUSH
16110: LD_INT 32
16112: PUSH
16113: LD_INT 31
16115: PUSH
16116: EMPTY
16117: LIST
16118: LIST
16119: IN
16120: IFFALSE 16140
// solds := solds diff i else
16122: LD_ADDR_VAR 0 2
16126: PUSH
16127: LD_VAR 0 2
16131: PUSH
16132: LD_VAR 0 7
16136: DIFF
16137: ST_TO_ADDR
16138: GO 16152
// SetTag ( i , 18 ) ;
16140: LD_VAR 0 7
16144: PPUSH
16145: LD_INT 18
16147: PPUSH
16148: CALL_OW 109
16152: GO 16092
16154: POP
16155: POP
// if not solds then
16156: LD_VAR 0 2
16160: NOT
16161: IFFALSE 16165
// exit ;
16163: GO 16570
// repeat wait ( 0 0$1 ) ;
16165: LD_INT 35
16167: PPUSH
16168: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
16172: LD_ADDR_VAR 0 5
16176: PUSH
16177: LD_VAR 0 6
16181: PPUSH
16182: LD_VAR 0 3
16186: PPUSH
16187: CALL 15979 0 2
16191: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16192: LD_EXP 59
16196: PUSH
16197: LD_VAR 0 1
16201: ARRAY
16202: NOT
16203: PUSH
16204: LD_EXP 59
16208: PUSH
16209: LD_VAR 0 1
16213: ARRAY
16214: PUSH
16215: EMPTY
16216: EQUAL
16217: OR
16218: IFFALSE 16255
// begin for i in solds do
16220: LD_ADDR_VAR 0 7
16224: PUSH
16225: LD_VAR 0 2
16229: PUSH
16230: FOR_IN
16231: IFFALSE 16244
// ComStop ( i ) ;
16233: LD_VAR 0 7
16237: PPUSH
16238: CALL_OW 141
16242: GO 16230
16244: POP
16245: POP
// solds := [ ] ;
16246: LD_ADDR_VAR 0 2
16250: PUSH
16251: EMPTY
16252: ST_TO_ADDR
// exit ;
16253: GO 16570
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
16255: LD_VAR 0 5
16259: NOT
16260: PUSH
16261: LD_VAR 0 5
16265: PUSH
16266: LD_INT 3
16268: GREATER
16269: OR
16270: PUSH
16271: LD_EXP 81
16275: PUSH
16276: LD_VAR 0 1
16280: ARRAY
16281: OR
16282: IFFALSE 16323
// begin for i in solds do
16284: LD_ADDR_VAR 0 7
16288: PUSH
16289: LD_VAR 0 2
16293: PUSH
16294: FOR_IN
16295: IFFALSE 16319
// if HasTask ( i ) then
16297: LD_VAR 0 7
16301: PPUSH
16302: CALL_OW 314
16306: IFFALSE 16317
// ComStop ( i ) ;
16308: LD_VAR 0 7
16312: PPUSH
16313: CALL_OW 141
16317: GO 16294
16319: POP
16320: POP
// break ;
16321: GO 16558
// end ; for i in solds do
16323: LD_ADDR_VAR 0 7
16327: PUSH
16328: LD_VAR 0 2
16332: PUSH
16333: FOR_IN
16334: IFFALSE 16550
// begin if IsInUnit ( i ) then
16336: LD_VAR 0 7
16340: PPUSH
16341: CALL_OW 310
16345: IFFALSE 16356
// ComExitBuilding ( i ) ;
16347: LD_VAR 0 7
16351: PPUSH
16352: CALL_OW 122
// if GetLives ( i ) > 333 then
16356: LD_VAR 0 7
16360: PPUSH
16361: CALL_OW 256
16365: PUSH
16366: LD_INT 333
16368: GREATER
16369: IFFALSE 16397
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
16371: LD_VAR 0 7
16375: PPUSH
16376: LD_VAR 0 5
16380: PPUSH
16381: LD_VAR 0 7
16385: PPUSH
16386: CALL_OW 74
16390: PPUSH
16391: CALL_OW 115
16395: GO 16548
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
16397: LD_ADDR_VAR 0 8
16401: PUSH
16402: LD_EXP 59
16406: PUSH
16407: LD_VAR 0 1
16411: ARRAY
16412: PPUSH
16413: LD_INT 2
16415: PUSH
16416: LD_INT 30
16418: PUSH
16419: LD_INT 0
16421: PUSH
16422: EMPTY
16423: LIST
16424: LIST
16425: PUSH
16426: LD_INT 30
16428: PUSH
16429: LD_INT 1
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: PUSH
16436: LD_INT 30
16438: PUSH
16439: LD_INT 6
16441: PUSH
16442: EMPTY
16443: LIST
16444: LIST
16445: PUSH
16446: EMPTY
16447: LIST
16448: LIST
16449: LIST
16450: LIST
16451: PPUSH
16452: CALL_OW 72
16456: PPUSH
16457: LD_VAR 0 7
16461: PPUSH
16462: CALL_OW 74
16466: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
16467: LD_VAR 0 7
16471: PPUSH
16472: LD_VAR 0 8
16476: PPUSH
16477: CALL_OW 250
16481: PPUSH
16482: LD_INT 3
16484: PPUSH
16485: LD_INT 5
16487: PPUSH
16488: CALL_OW 272
16492: PPUSH
16493: LD_VAR 0 8
16497: PPUSH
16498: CALL_OW 251
16502: PPUSH
16503: LD_INT 3
16505: PPUSH
16506: LD_INT 5
16508: PPUSH
16509: CALL_OW 273
16513: PPUSH
16514: CALL_OW 111
// SetTag ( i , 0 ) ;
16518: LD_VAR 0 7
16522: PPUSH
16523: LD_INT 0
16525: PPUSH
16526: CALL_OW 109
// solds := solds diff i ;
16530: LD_ADDR_VAR 0 2
16534: PUSH
16535: LD_VAR 0 2
16539: PUSH
16540: LD_VAR 0 7
16544: DIFF
16545: ST_TO_ADDR
// continue ;
16546: GO 16333
// end ; end ;
16548: GO 16333
16550: POP
16551: POP
// until solds ;
16552: LD_VAR 0 2
16556: IFFALSE 16165
// MC_Reset ( base , 18 ) ;
16558: LD_VAR 0 1
16562: PPUSH
16563: LD_INT 18
16565: PPUSH
16566: CALL 61602 0 2
// end ;
16570: LD_VAR 0 4
16574: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16575: LD_INT 0
16577: PPUSH
16578: PPUSH
16579: PPUSH
16580: PPUSH
16581: PPUSH
16582: PPUSH
16583: PPUSH
16584: PPUSH
16585: PPUSH
16586: PPUSH
16587: PPUSH
16588: PPUSH
16589: PPUSH
16590: PPUSH
16591: PPUSH
16592: PPUSH
16593: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16594: LD_ADDR_VAR 0 13
16598: PUSH
16599: LD_EXP 59
16603: PUSH
16604: LD_VAR 0 1
16608: ARRAY
16609: PPUSH
16610: LD_INT 25
16612: PUSH
16613: LD_INT 3
16615: PUSH
16616: EMPTY
16617: LIST
16618: LIST
16619: PPUSH
16620: CALL_OW 72
16624: ST_TO_ADDR
// if mc_remote_driver [ base ] then
16625: LD_EXP 99
16629: PUSH
16630: LD_VAR 0 1
16634: ARRAY
16635: IFFALSE 16659
// mechs := mechs diff mc_remote_driver [ base ] ;
16637: LD_ADDR_VAR 0 13
16641: PUSH
16642: LD_VAR 0 13
16646: PUSH
16647: LD_EXP 99
16651: PUSH
16652: LD_VAR 0 1
16656: ARRAY
16657: DIFF
16658: ST_TO_ADDR
// for i in mechs do
16659: LD_ADDR_VAR 0 5
16663: PUSH
16664: LD_VAR 0 13
16668: PUSH
16669: FOR_IN
16670: IFFALSE 16705
// if GetTag ( i ) > 0 then
16672: LD_VAR 0 5
16676: PPUSH
16677: CALL_OW 110
16681: PUSH
16682: LD_INT 0
16684: GREATER
16685: IFFALSE 16703
// mechs := mechs diff i ;
16687: LD_ADDR_VAR 0 13
16691: PUSH
16692: LD_VAR 0 13
16696: PUSH
16697: LD_VAR 0 5
16701: DIFF
16702: ST_TO_ADDR
16703: GO 16669
16705: POP
16706: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16707: LD_ADDR_VAR 0 9
16711: PUSH
16712: LD_EXP 59
16716: PUSH
16717: LD_VAR 0 1
16721: ARRAY
16722: PPUSH
16723: LD_INT 2
16725: PUSH
16726: LD_INT 25
16728: PUSH
16729: LD_INT 1
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: PUSH
16736: LD_INT 25
16738: PUSH
16739: LD_INT 5
16741: PUSH
16742: EMPTY
16743: LIST
16744: LIST
16745: PUSH
16746: LD_INT 25
16748: PUSH
16749: LD_INT 8
16751: PUSH
16752: EMPTY
16753: LIST
16754: LIST
16755: PUSH
16756: LD_INT 25
16758: PUSH
16759: LD_INT 9
16761: PUSH
16762: EMPTY
16763: LIST
16764: LIST
16765: PUSH
16766: EMPTY
16767: LIST
16768: LIST
16769: LIST
16770: LIST
16771: LIST
16772: PPUSH
16773: CALL_OW 72
16777: ST_TO_ADDR
// if not defenders and not solds then
16778: LD_VAR 0 2
16782: NOT
16783: PUSH
16784: LD_VAR 0 9
16788: NOT
16789: AND
16790: IFFALSE 16794
// exit ;
16792: GO 18420
// depot_under_attack := false ;
16794: LD_ADDR_VAR 0 17
16798: PUSH
16799: LD_INT 0
16801: ST_TO_ADDR
// sold_defenders := [ ] ;
16802: LD_ADDR_VAR 0 18
16806: PUSH
16807: EMPTY
16808: ST_TO_ADDR
// if mechs then
16809: LD_VAR 0 13
16813: IFFALSE 16942
// for i in defenders do
16815: LD_ADDR_VAR 0 5
16819: PUSH
16820: LD_VAR 0 2
16824: PUSH
16825: FOR_IN
16826: IFFALSE 16940
// begin SetTag ( i , 20 ) ;
16828: LD_VAR 0 5
16832: PPUSH
16833: LD_INT 20
16835: PPUSH
16836: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16840: LD_VAR 0 5
16844: PPUSH
16845: CALL_OW 263
16849: PUSH
16850: LD_INT 1
16852: EQUAL
16853: PUSH
16854: LD_VAR 0 5
16858: PPUSH
16859: CALL_OW 311
16863: NOT
16864: AND
16865: PUSH
16866: LD_VAR 0 13
16870: AND
16871: IFFALSE 16938
// begin un := mechs [ 1 ] ;
16873: LD_ADDR_VAR 0 11
16877: PUSH
16878: LD_VAR 0 13
16882: PUSH
16883: LD_INT 1
16885: ARRAY
16886: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16887: LD_VAR 0 11
16891: PPUSH
16892: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16896: LD_VAR 0 11
16900: PPUSH
16901: LD_VAR 0 5
16905: PPUSH
16906: CALL_OW 180
// SetTag ( un , 19 ) ;
16910: LD_VAR 0 11
16914: PPUSH
16915: LD_INT 19
16917: PPUSH
16918: CALL_OW 109
// mechs := mechs diff un ;
16922: LD_ADDR_VAR 0 13
16926: PUSH
16927: LD_VAR 0 13
16931: PUSH
16932: LD_VAR 0 11
16936: DIFF
16937: ST_TO_ADDR
// end ; end ;
16938: GO 16825
16940: POP
16941: POP
// if solds then
16942: LD_VAR 0 9
16946: IFFALSE 17005
// for i in solds do
16948: LD_ADDR_VAR 0 5
16952: PUSH
16953: LD_VAR 0 9
16957: PUSH
16958: FOR_IN
16959: IFFALSE 17003
// if not GetTag ( i ) then
16961: LD_VAR 0 5
16965: PPUSH
16966: CALL_OW 110
16970: NOT
16971: IFFALSE 17001
// begin defenders := defenders union i ;
16973: LD_ADDR_VAR 0 2
16977: PUSH
16978: LD_VAR 0 2
16982: PUSH
16983: LD_VAR 0 5
16987: UNION
16988: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16989: LD_VAR 0 5
16993: PPUSH
16994: LD_INT 18
16996: PPUSH
16997: CALL_OW 109
// end ;
17001: GO 16958
17003: POP
17004: POP
// repeat wait ( 0 0$1 ) ;
17005: LD_INT 35
17007: PPUSH
17008: CALL_OW 67
// enemy := mc_scan [ base ] ;
17012: LD_ADDR_VAR 0 3
17016: PUSH
17017: LD_EXP 82
17021: PUSH
17022: LD_VAR 0 1
17026: ARRAY
17027: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
17028: LD_EXP 59
17032: PUSH
17033: LD_VAR 0 1
17037: ARRAY
17038: NOT
17039: PUSH
17040: LD_EXP 59
17044: PUSH
17045: LD_VAR 0 1
17049: ARRAY
17050: PUSH
17051: EMPTY
17052: EQUAL
17053: OR
17054: IFFALSE 17091
// begin for i in defenders do
17056: LD_ADDR_VAR 0 5
17060: PUSH
17061: LD_VAR 0 2
17065: PUSH
17066: FOR_IN
17067: IFFALSE 17080
// ComStop ( i ) ;
17069: LD_VAR 0 5
17073: PPUSH
17074: CALL_OW 141
17078: GO 17066
17080: POP
17081: POP
// defenders := [ ] ;
17082: LD_ADDR_VAR 0 2
17086: PUSH
17087: EMPTY
17088: ST_TO_ADDR
// exit ;
17089: GO 18420
// end ; for i in defenders do
17091: LD_ADDR_VAR 0 5
17095: PUSH
17096: LD_VAR 0 2
17100: PUSH
17101: FOR_IN
17102: IFFALSE 17920
// begin e := NearestUnitToUnit ( enemy , i ) ;
17104: LD_ADDR_VAR 0 14
17108: PUSH
17109: LD_VAR 0 3
17113: PPUSH
17114: LD_VAR 0 5
17118: PPUSH
17119: CALL_OW 74
17123: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
17124: LD_ADDR_VAR 0 8
17128: PUSH
17129: LD_EXP 59
17133: PUSH
17134: LD_VAR 0 1
17138: ARRAY
17139: PPUSH
17140: LD_INT 2
17142: PUSH
17143: LD_INT 30
17145: PUSH
17146: LD_INT 0
17148: PUSH
17149: EMPTY
17150: LIST
17151: LIST
17152: PUSH
17153: LD_INT 30
17155: PUSH
17156: LD_INT 1
17158: PUSH
17159: EMPTY
17160: LIST
17161: LIST
17162: PUSH
17163: EMPTY
17164: LIST
17165: LIST
17166: LIST
17167: PPUSH
17168: CALL_OW 72
17172: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
17173: LD_ADDR_VAR 0 17
17177: PUSH
17178: LD_VAR 0 8
17182: NOT
17183: PUSH
17184: LD_VAR 0 8
17188: PPUSH
17189: LD_INT 3
17191: PUSH
17192: LD_INT 24
17194: PUSH
17195: LD_INT 600
17197: PUSH
17198: EMPTY
17199: LIST
17200: LIST
17201: PUSH
17202: EMPTY
17203: LIST
17204: LIST
17205: PPUSH
17206: CALL_OW 72
17210: OR
17211: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
17212: LD_VAR 0 5
17216: PPUSH
17217: CALL_OW 247
17221: PUSH
17222: LD_INT 2
17224: DOUBLE
17225: EQUAL
17226: IFTRUE 17230
17228: GO 17626
17230: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
17231: LD_VAR 0 5
17235: PPUSH
17236: CALL_OW 256
17240: PUSH
17241: LD_INT 650
17243: GREATER
17244: PUSH
17245: LD_VAR 0 5
17249: PPUSH
17250: LD_VAR 0 14
17254: PPUSH
17255: CALL_OW 296
17259: PUSH
17260: LD_INT 40
17262: LESS
17263: PUSH
17264: LD_VAR 0 14
17268: PPUSH
17269: LD_EXP 84
17273: PUSH
17274: LD_VAR 0 1
17278: ARRAY
17279: PPUSH
17280: CALL_OW 308
17284: OR
17285: AND
17286: IFFALSE 17408
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
17288: LD_VAR 0 5
17292: PPUSH
17293: CALL_OW 262
17297: PUSH
17298: LD_INT 1
17300: EQUAL
17301: PUSH
17302: LD_VAR 0 5
17306: PPUSH
17307: CALL_OW 261
17311: PUSH
17312: LD_INT 30
17314: LESS
17315: AND
17316: PUSH
17317: LD_VAR 0 8
17321: AND
17322: IFFALSE 17392
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
17324: LD_VAR 0 5
17328: PPUSH
17329: LD_VAR 0 8
17333: PPUSH
17334: LD_VAR 0 5
17338: PPUSH
17339: CALL_OW 74
17343: PPUSH
17344: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
17348: LD_VAR 0 5
17352: PPUSH
17353: LD_VAR 0 8
17357: PPUSH
17358: LD_VAR 0 5
17362: PPUSH
17363: CALL_OW 74
17367: PPUSH
17368: CALL_OW 296
17372: PUSH
17373: LD_INT 6
17375: LESS
17376: IFFALSE 17390
// SetFuel ( i , 100 ) ;
17378: LD_VAR 0 5
17382: PPUSH
17383: LD_INT 100
17385: PPUSH
17386: CALL_OW 240
// end else
17390: GO 17406
// ComAttackUnit ( i , e ) ;
17392: LD_VAR 0 5
17396: PPUSH
17397: LD_VAR 0 14
17401: PPUSH
17402: CALL_OW 115
// end else
17406: GO 17509
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
17408: LD_VAR 0 14
17412: PPUSH
17413: LD_EXP 84
17417: PUSH
17418: LD_VAR 0 1
17422: ARRAY
17423: PPUSH
17424: CALL_OW 308
17428: NOT
17429: PUSH
17430: LD_VAR 0 5
17434: PPUSH
17435: LD_VAR 0 14
17439: PPUSH
17440: CALL_OW 296
17444: PUSH
17445: LD_INT 40
17447: GREATEREQUAL
17448: AND
17449: PUSH
17450: LD_VAR 0 5
17454: PPUSH
17455: CALL_OW 256
17459: PUSH
17460: LD_INT 650
17462: LESSEQUAL
17463: OR
17464: PUSH
17465: LD_VAR 0 5
17469: PPUSH
17470: LD_EXP 83
17474: PUSH
17475: LD_VAR 0 1
17479: ARRAY
17480: PPUSH
17481: CALL_OW 308
17485: NOT
17486: AND
17487: IFFALSE 17509
// ComMoveToArea ( i , mc_parking [ base ] ) ;
17489: LD_VAR 0 5
17493: PPUSH
17494: LD_EXP 83
17498: PUSH
17499: LD_VAR 0 1
17503: ARRAY
17504: PPUSH
17505: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
17509: LD_VAR 0 5
17513: PPUSH
17514: CALL_OW 256
17518: PUSH
17519: LD_INT 998
17521: LESS
17522: PUSH
17523: LD_VAR 0 5
17527: PPUSH
17528: CALL_OW 263
17532: PUSH
17533: LD_INT 1
17535: EQUAL
17536: AND
17537: PUSH
17538: LD_VAR 0 5
17542: PPUSH
17543: CALL_OW 311
17547: AND
17548: PUSH
17549: LD_VAR 0 5
17553: PPUSH
17554: LD_EXP 83
17558: PUSH
17559: LD_VAR 0 1
17563: ARRAY
17564: PPUSH
17565: CALL_OW 308
17569: AND
17570: IFFALSE 17624
// begin mech := IsDrivenBy ( i ) ;
17572: LD_ADDR_VAR 0 10
17576: PUSH
17577: LD_VAR 0 5
17581: PPUSH
17582: CALL_OW 311
17586: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
17587: LD_VAR 0 10
17591: PPUSH
17592: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
17596: LD_VAR 0 10
17600: PPUSH
17601: LD_VAR 0 5
17605: PPUSH
17606: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
17610: LD_VAR 0 10
17614: PPUSH
17615: LD_VAR 0 5
17619: PPUSH
17620: CALL_OW 180
// end ; end ; unit_human :
17624: GO 17891
17626: LD_INT 1
17628: DOUBLE
17629: EQUAL
17630: IFTRUE 17634
17632: GO 17890
17634: POP
// begin b := IsInUnit ( i ) ;
17635: LD_ADDR_VAR 0 19
17639: PUSH
17640: LD_VAR 0 5
17644: PPUSH
17645: CALL_OW 310
17649: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
17650: LD_ADDR_VAR 0 20
17654: PUSH
17655: LD_VAR 0 19
17659: NOT
17660: PUSH
17661: LD_VAR 0 19
17665: PPUSH
17666: CALL_OW 266
17670: PUSH
17671: LD_INT 32
17673: PUSH
17674: LD_INT 31
17676: PUSH
17677: EMPTY
17678: LIST
17679: LIST
17680: IN
17681: OR
17682: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
17683: LD_VAR 0 17
17687: PUSH
17688: LD_VAR 0 2
17692: PPUSH
17693: LD_INT 21
17695: PUSH
17696: LD_INT 2
17698: PUSH
17699: EMPTY
17700: LIST
17701: LIST
17702: PPUSH
17703: CALL_OW 72
17707: PUSH
17708: LD_INT 1
17710: LESSEQUAL
17711: OR
17712: PUSH
17713: LD_VAR 0 20
17717: AND
17718: PUSH
17719: LD_VAR 0 5
17723: PUSH
17724: LD_VAR 0 18
17728: IN
17729: NOT
17730: AND
17731: IFFALSE 17824
// begin if b then
17733: LD_VAR 0 19
17737: IFFALSE 17786
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
17739: LD_VAR 0 19
17743: PPUSH
17744: LD_VAR 0 3
17748: PPUSH
17749: LD_VAR 0 19
17753: PPUSH
17754: CALL_OW 74
17758: PPUSH
17759: CALL_OW 296
17763: PUSH
17764: LD_INT 10
17766: LESS
17767: PUSH
17768: LD_VAR 0 19
17772: PPUSH
17773: CALL_OW 461
17777: PUSH
17778: LD_INT 7
17780: NONEQUAL
17781: AND
17782: IFFALSE 17786
// continue ;
17784: GO 17101
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17786: LD_ADDR_VAR 0 18
17790: PUSH
17791: LD_VAR 0 18
17795: PPUSH
17796: LD_VAR 0 18
17800: PUSH
17801: LD_INT 1
17803: PLUS
17804: PPUSH
17805: LD_VAR 0 5
17809: PPUSH
17810: CALL_OW 1
17814: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17815: LD_VAR 0 5
17819: PPUSH
17820: CALL_OW 122
// end ; if sold_defenders then
17824: LD_VAR 0 18
17828: IFFALSE 17888
// if i in sold_defenders then
17830: LD_VAR 0 5
17834: PUSH
17835: LD_VAR 0 18
17839: IN
17840: IFFALSE 17888
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17842: LD_VAR 0 5
17846: PPUSH
17847: CALL_OW 314
17851: NOT
17852: PUSH
17853: LD_VAR 0 5
17857: PPUSH
17858: LD_VAR 0 14
17862: PPUSH
17863: CALL_OW 296
17867: PUSH
17868: LD_INT 30
17870: LESS
17871: AND
17872: IFFALSE 17888
// ComAttackUnit ( i , e ) ;
17874: LD_VAR 0 5
17878: PPUSH
17879: LD_VAR 0 14
17883: PPUSH
17884: CALL_OW 115
// end ; end ; end ;
17888: GO 17891
17890: POP
// if IsDead ( i ) then
17891: LD_VAR 0 5
17895: PPUSH
17896: CALL_OW 301
17900: IFFALSE 17918
// defenders := defenders diff i ;
17902: LD_ADDR_VAR 0 2
17906: PUSH
17907: LD_VAR 0 2
17911: PUSH
17912: LD_VAR 0 5
17916: DIFF
17917: ST_TO_ADDR
// end ;
17918: GO 17101
17920: POP
17921: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
17922: LD_VAR 0 3
17926: NOT
17927: PUSH
17928: LD_VAR 0 2
17932: NOT
17933: OR
17934: PUSH
17935: LD_EXP 59
17939: PUSH
17940: LD_VAR 0 1
17944: ARRAY
17945: NOT
17946: OR
17947: IFFALSE 17005
// MC_Reset ( base , 18 ) ;
17949: LD_VAR 0 1
17953: PPUSH
17954: LD_INT 18
17956: PPUSH
17957: CALL 61602 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17961: LD_ADDR_VAR 0 2
17965: PUSH
17966: LD_VAR 0 2
17970: PUSH
17971: LD_VAR 0 2
17975: PPUSH
17976: LD_INT 2
17978: PUSH
17979: LD_INT 25
17981: PUSH
17982: LD_INT 1
17984: PUSH
17985: EMPTY
17986: LIST
17987: LIST
17988: PUSH
17989: LD_INT 25
17991: PUSH
17992: LD_INT 5
17994: PUSH
17995: EMPTY
17996: LIST
17997: LIST
17998: PUSH
17999: LD_INT 25
18001: PUSH
18002: LD_INT 8
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: PUSH
18009: LD_INT 25
18011: PUSH
18012: LD_INT 9
18014: PUSH
18015: EMPTY
18016: LIST
18017: LIST
18018: PUSH
18019: EMPTY
18020: LIST
18021: LIST
18022: LIST
18023: LIST
18024: LIST
18025: PPUSH
18026: CALL_OW 72
18030: DIFF
18031: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
18032: LD_VAR 0 3
18036: NOT
18037: PUSH
18038: LD_VAR 0 2
18042: PPUSH
18043: LD_INT 21
18045: PUSH
18046: LD_INT 2
18048: PUSH
18049: EMPTY
18050: LIST
18051: LIST
18052: PPUSH
18053: CALL_OW 72
18057: AND
18058: IFFALSE 18396
// begin tmp := FilterByTag ( defenders , 19 ) ;
18060: LD_ADDR_VAR 0 12
18064: PUSH
18065: LD_VAR 0 2
18069: PPUSH
18070: LD_INT 19
18072: PPUSH
18073: CALL 54859 0 2
18077: ST_TO_ADDR
// if tmp then
18078: LD_VAR 0 12
18082: IFFALSE 18152
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
18084: LD_ADDR_VAR 0 12
18088: PUSH
18089: LD_VAR 0 12
18093: PPUSH
18094: LD_INT 25
18096: PUSH
18097: LD_INT 3
18099: PUSH
18100: EMPTY
18101: LIST
18102: LIST
18103: PPUSH
18104: CALL_OW 72
18108: ST_TO_ADDR
// if tmp then
18109: LD_VAR 0 12
18113: IFFALSE 18152
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
18115: LD_ADDR_EXP 71
18119: PUSH
18120: LD_EXP 71
18124: PPUSH
18125: LD_VAR 0 1
18129: PPUSH
18130: LD_EXP 71
18134: PUSH
18135: LD_VAR 0 1
18139: ARRAY
18140: PUSH
18141: LD_VAR 0 12
18145: UNION
18146: PPUSH
18147: CALL_OW 1
18151: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
18152: LD_VAR 0 1
18156: PPUSH
18157: LD_INT 19
18159: PPUSH
18160: CALL 61602 0 2
// repeat wait ( 0 0$1 ) ;
18164: LD_INT 35
18166: PPUSH
18167: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
18171: LD_EXP 59
18175: PUSH
18176: LD_VAR 0 1
18180: ARRAY
18181: NOT
18182: PUSH
18183: LD_EXP 59
18187: PUSH
18188: LD_VAR 0 1
18192: ARRAY
18193: PUSH
18194: EMPTY
18195: EQUAL
18196: OR
18197: IFFALSE 18234
// begin for i in defenders do
18199: LD_ADDR_VAR 0 5
18203: PUSH
18204: LD_VAR 0 2
18208: PUSH
18209: FOR_IN
18210: IFFALSE 18223
// ComStop ( i ) ;
18212: LD_VAR 0 5
18216: PPUSH
18217: CALL_OW 141
18221: GO 18209
18223: POP
18224: POP
// defenders := [ ] ;
18225: LD_ADDR_VAR 0 2
18229: PUSH
18230: EMPTY
18231: ST_TO_ADDR
// exit ;
18232: GO 18420
// end ; for i in defenders do
18234: LD_ADDR_VAR 0 5
18238: PUSH
18239: LD_VAR 0 2
18243: PUSH
18244: FOR_IN
18245: IFFALSE 18334
// begin if not IsInArea ( i , mc_parking [ base ] ) then
18247: LD_VAR 0 5
18251: PPUSH
18252: LD_EXP 83
18256: PUSH
18257: LD_VAR 0 1
18261: ARRAY
18262: PPUSH
18263: CALL_OW 308
18267: NOT
18268: IFFALSE 18292
// ComMoveToArea ( i , mc_parking [ base ] ) else
18270: LD_VAR 0 5
18274: PPUSH
18275: LD_EXP 83
18279: PUSH
18280: LD_VAR 0 1
18284: ARRAY
18285: PPUSH
18286: CALL_OW 113
18290: GO 18332
// if GetControl ( i ) = control_manual then
18292: LD_VAR 0 5
18296: PPUSH
18297: CALL_OW 263
18301: PUSH
18302: LD_INT 1
18304: EQUAL
18305: IFFALSE 18332
// if IsDrivenBy ( i ) then
18307: LD_VAR 0 5
18311: PPUSH
18312: CALL_OW 311
18316: IFFALSE 18332
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
18318: LD_VAR 0 5
18322: PPUSH
18323: CALL_OW 311
18327: PPUSH
18328: CALL_OW 121
// end ;
18332: GO 18244
18334: POP
18335: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
18336: LD_VAR 0 2
18340: PPUSH
18341: LD_INT 95
18343: PUSH
18344: LD_EXP 83
18348: PUSH
18349: LD_VAR 0 1
18353: ARRAY
18354: PUSH
18355: EMPTY
18356: LIST
18357: LIST
18358: PPUSH
18359: CALL_OW 72
18363: PUSH
18364: LD_VAR 0 2
18368: EQUAL
18369: PUSH
18370: LD_EXP 82
18374: PUSH
18375: LD_VAR 0 1
18379: ARRAY
18380: OR
18381: PUSH
18382: LD_EXP 59
18386: PUSH
18387: LD_VAR 0 1
18391: ARRAY
18392: NOT
18393: OR
18394: IFFALSE 18164
// end ; MC_Reset ( base , 19 ) ;
18396: LD_VAR 0 1
18400: PPUSH
18401: LD_INT 19
18403: PPUSH
18404: CALL 61602 0 2
// MC_Reset ( base , 20 ) ;
18408: LD_VAR 0 1
18412: PPUSH
18413: LD_INT 20
18415: PPUSH
18416: CALL 61602 0 2
// end ;
18420: LD_VAR 0 4
18424: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
18425: LD_INT 0
18427: PPUSH
18428: PPUSH
18429: PPUSH
18430: PPUSH
// result := false ;
18431: LD_ADDR_VAR 0 2
18435: PUSH
18436: LD_INT 0
18438: ST_TO_ADDR
// side := GetSide ( unit ) ;
18439: LD_ADDR_VAR 0 3
18443: PUSH
18444: LD_VAR 0 1
18448: PPUSH
18449: CALL_OW 255
18453: ST_TO_ADDR
// nat := GetNation ( unit ) ;
18454: LD_ADDR_VAR 0 4
18458: PUSH
18459: LD_VAR 0 1
18463: PPUSH
18464: CALL_OW 248
18468: ST_TO_ADDR
// case nat of 1 :
18469: LD_VAR 0 4
18473: PUSH
18474: LD_INT 1
18476: DOUBLE
18477: EQUAL
18478: IFTRUE 18482
18480: GO 18493
18482: POP
// tech := tech_lassight ; 2 :
18483: LD_ADDR_VAR 0 5
18487: PUSH
18488: LD_INT 12
18490: ST_TO_ADDR
18491: GO 18532
18493: LD_INT 2
18495: DOUBLE
18496: EQUAL
18497: IFTRUE 18501
18499: GO 18512
18501: POP
// tech := tech_mortar ; 3 :
18502: LD_ADDR_VAR 0 5
18506: PUSH
18507: LD_INT 41
18509: ST_TO_ADDR
18510: GO 18532
18512: LD_INT 3
18514: DOUBLE
18515: EQUAL
18516: IFTRUE 18520
18518: GO 18531
18520: POP
// tech := tech_bazooka ; end ;
18521: LD_ADDR_VAR 0 5
18525: PUSH
18526: LD_INT 44
18528: ST_TO_ADDR
18529: GO 18532
18531: POP
// if Researched ( side , tech ) then
18532: LD_VAR 0 3
18536: PPUSH
18537: LD_VAR 0 5
18541: PPUSH
18542: CALL_OW 325
18546: IFFALSE 18573
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18548: LD_ADDR_VAR 0 2
18552: PUSH
18553: LD_INT 5
18555: PUSH
18556: LD_INT 8
18558: PUSH
18559: LD_INT 9
18561: PUSH
18562: EMPTY
18563: LIST
18564: LIST
18565: LIST
18566: PUSH
18567: LD_VAR 0 4
18571: ARRAY
18572: ST_TO_ADDR
// end ;
18573: LD_VAR 0 2
18577: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18578: LD_INT 0
18580: PPUSH
18581: PPUSH
18582: PPUSH
// if not mines then
18583: LD_VAR 0 2
18587: NOT
18588: IFFALSE 18592
// exit ;
18590: GO 18736
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18592: LD_ADDR_VAR 0 5
18596: PUSH
18597: LD_INT 81
18599: PUSH
18600: LD_VAR 0 1
18604: PUSH
18605: EMPTY
18606: LIST
18607: LIST
18608: PUSH
18609: LD_INT 3
18611: PUSH
18612: LD_INT 21
18614: PUSH
18615: LD_INT 3
18617: PUSH
18618: EMPTY
18619: LIST
18620: LIST
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: PUSH
18626: EMPTY
18627: LIST
18628: LIST
18629: PPUSH
18630: CALL_OW 69
18634: ST_TO_ADDR
// for i in mines do
18635: LD_ADDR_VAR 0 4
18639: PUSH
18640: LD_VAR 0 2
18644: PUSH
18645: FOR_IN
18646: IFFALSE 18734
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18648: LD_VAR 0 4
18652: PUSH
18653: LD_INT 1
18655: ARRAY
18656: PPUSH
18657: LD_VAR 0 4
18661: PUSH
18662: LD_INT 2
18664: ARRAY
18665: PPUSH
18666: CALL_OW 458
18670: NOT
18671: IFFALSE 18675
// continue ;
18673: GO 18645
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18675: LD_VAR 0 4
18679: PUSH
18680: LD_INT 1
18682: ARRAY
18683: PPUSH
18684: LD_VAR 0 4
18688: PUSH
18689: LD_INT 2
18691: ARRAY
18692: PPUSH
18693: CALL_OW 428
18697: PUSH
18698: LD_VAR 0 5
18702: IN
18703: IFFALSE 18732
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18705: LD_VAR 0 4
18709: PUSH
18710: LD_INT 1
18712: ARRAY
18713: PPUSH
18714: LD_VAR 0 4
18718: PUSH
18719: LD_INT 2
18721: ARRAY
18722: PPUSH
18723: LD_VAR 0 1
18727: PPUSH
18728: CALL_OW 456
// end ;
18732: GO 18645
18734: POP
18735: POP
// end ;
18736: LD_VAR 0 3
18740: RET
// export function Count ( array ) ; var i ; begin
18741: LD_INT 0
18743: PPUSH
18744: PPUSH
// result := 0 ;
18745: LD_ADDR_VAR 0 2
18749: PUSH
18750: LD_INT 0
18752: ST_TO_ADDR
// for i in array do
18753: LD_ADDR_VAR 0 3
18757: PUSH
18758: LD_VAR 0 1
18762: PUSH
18763: FOR_IN
18764: IFFALSE 18788
// if i then
18766: LD_VAR 0 3
18770: IFFALSE 18786
// result := result + 1 ;
18772: LD_ADDR_VAR 0 2
18776: PUSH
18777: LD_VAR 0 2
18781: PUSH
18782: LD_INT 1
18784: PLUS
18785: ST_TO_ADDR
18786: GO 18763
18788: POP
18789: POP
// end ;
18790: LD_VAR 0 2
18794: RET
// export function IsEmpty ( building ) ; begin
18795: LD_INT 0
18797: PPUSH
// if not building then
18798: LD_VAR 0 1
18802: NOT
18803: IFFALSE 18807
// exit ;
18805: GO 18850
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18807: LD_ADDR_VAR 0 2
18811: PUSH
18812: LD_VAR 0 1
18816: PUSH
18817: LD_INT 22
18819: PUSH
18820: LD_VAR 0 1
18824: PPUSH
18825: CALL_OW 255
18829: PUSH
18830: EMPTY
18831: LIST
18832: LIST
18833: PUSH
18834: LD_INT 58
18836: PUSH
18837: EMPTY
18838: LIST
18839: PUSH
18840: EMPTY
18841: LIST
18842: LIST
18843: PPUSH
18844: CALL_OW 69
18848: IN
18849: ST_TO_ADDR
// end ;
18850: LD_VAR 0 2
18854: RET
// export function IsNotFull ( building ) ; begin
18855: LD_INT 0
18857: PPUSH
// if not building then
18858: LD_VAR 0 1
18862: NOT
18863: IFFALSE 18867
// exit ;
18865: GO 18886
// result := UnitsInside ( building ) < 6 ;
18867: LD_ADDR_VAR 0 2
18871: PUSH
18872: LD_VAR 0 1
18876: PPUSH
18877: CALL_OW 313
18881: PUSH
18882: LD_INT 6
18884: LESS
18885: ST_TO_ADDR
// end ;
18886: LD_VAR 0 2
18890: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18891: LD_INT 0
18893: PPUSH
18894: PPUSH
18895: PPUSH
18896: PPUSH
// tmp := [ ] ;
18897: LD_ADDR_VAR 0 3
18901: PUSH
18902: EMPTY
18903: ST_TO_ADDR
// list := [ ] ;
18904: LD_ADDR_VAR 0 5
18908: PUSH
18909: EMPTY
18910: ST_TO_ADDR
// for i = 16 to 25 do
18911: LD_ADDR_VAR 0 4
18915: PUSH
18916: DOUBLE
18917: LD_INT 16
18919: DEC
18920: ST_TO_ADDR
18921: LD_INT 25
18923: PUSH
18924: FOR_TO
18925: IFFALSE 18998
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18927: LD_ADDR_VAR 0 3
18931: PUSH
18932: LD_VAR 0 3
18936: PUSH
18937: LD_INT 22
18939: PUSH
18940: LD_VAR 0 1
18944: PPUSH
18945: CALL_OW 255
18949: PUSH
18950: EMPTY
18951: LIST
18952: LIST
18953: PUSH
18954: LD_INT 91
18956: PUSH
18957: LD_VAR 0 1
18961: PUSH
18962: LD_INT 6
18964: PUSH
18965: EMPTY
18966: LIST
18967: LIST
18968: LIST
18969: PUSH
18970: LD_INT 30
18972: PUSH
18973: LD_VAR 0 4
18977: PUSH
18978: EMPTY
18979: LIST
18980: LIST
18981: PUSH
18982: EMPTY
18983: LIST
18984: LIST
18985: LIST
18986: PUSH
18987: EMPTY
18988: LIST
18989: PPUSH
18990: CALL_OW 69
18994: ADD
18995: ST_TO_ADDR
18996: GO 18924
18998: POP
18999: POP
// for i = 1 to tmp do
19000: LD_ADDR_VAR 0 4
19004: PUSH
19005: DOUBLE
19006: LD_INT 1
19008: DEC
19009: ST_TO_ADDR
19010: LD_VAR 0 3
19014: PUSH
19015: FOR_TO
19016: IFFALSE 19104
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
19018: LD_ADDR_VAR 0 5
19022: PUSH
19023: LD_VAR 0 5
19027: PUSH
19028: LD_VAR 0 3
19032: PUSH
19033: LD_VAR 0 4
19037: ARRAY
19038: PPUSH
19039: CALL_OW 266
19043: PUSH
19044: LD_VAR 0 3
19048: PUSH
19049: LD_VAR 0 4
19053: ARRAY
19054: PPUSH
19055: CALL_OW 250
19059: PUSH
19060: LD_VAR 0 3
19064: PUSH
19065: LD_VAR 0 4
19069: ARRAY
19070: PPUSH
19071: CALL_OW 251
19075: PUSH
19076: LD_VAR 0 3
19080: PUSH
19081: LD_VAR 0 4
19085: ARRAY
19086: PPUSH
19087: CALL_OW 254
19091: PUSH
19092: EMPTY
19093: LIST
19094: LIST
19095: LIST
19096: LIST
19097: PUSH
19098: EMPTY
19099: LIST
19100: ADD
19101: ST_TO_ADDR
19102: GO 19015
19104: POP
19105: POP
// result := list ;
19106: LD_ADDR_VAR 0 2
19110: PUSH
19111: LD_VAR 0 5
19115: ST_TO_ADDR
// end ;
19116: LD_VAR 0 2
19120: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
19121: LD_INT 0
19123: PPUSH
19124: PPUSH
19125: PPUSH
19126: PPUSH
19127: PPUSH
19128: PPUSH
19129: PPUSH
// if not factory then
19130: LD_VAR 0 1
19134: NOT
19135: IFFALSE 19139
// exit ;
19137: GO 19732
// if control = control_apeman then
19139: LD_VAR 0 4
19143: PUSH
19144: LD_INT 5
19146: EQUAL
19147: IFFALSE 19256
// begin tmp := UnitsInside ( factory ) ;
19149: LD_ADDR_VAR 0 8
19153: PUSH
19154: LD_VAR 0 1
19158: PPUSH
19159: CALL_OW 313
19163: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
19164: LD_VAR 0 8
19168: PPUSH
19169: LD_INT 25
19171: PUSH
19172: LD_INT 12
19174: PUSH
19175: EMPTY
19176: LIST
19177: LIST
19178: PPUSH
19179: CALL_OW 72
19183: NOT
19184: IFFALSE 19194
// control := control_manual ;
19186: LD_ADDR_VAR 0 4
19190: PUSH
19191: LD_INT 1
19193: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
19194: LD_ADDR_VAR 0 8
19198: PUSH
19199: LD_VAR 0 1
19203: PPUSH
19204: CALL 18891 0 1
19208: ST_TO_ADDR
// if tmp then
19209: LD_VAR 0 8
19213: IFFALSE 19256
// begin for i in tmp do
19215: LD_ADDR_VAR 0 7
19219: PUSH
19220: LD_VAR 0 8
19224: PUSH
19225: FOR_IN
19226: IFFALSE 19254
// if i [ 1 ] = b_ext_radio then
19228: LD_VAR 0 7
19232: PUSH
19233: LD_INT 1
19235: ARRAY
19236: PUSH
19237: LD_INT 22
19239: EQUAL
19240: IFFALSE 19252
// begin control := control_remote ;
19242: LD_ADDR_VAR 0 4
19246: PUSH
19247: LD_INT 2
19249: ST_TO_ADDR
// break ;
19250: GO 19254
// end ;
19252: GO 19225
19254: POP
19255: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19256: LD_VAR 0 1
19260: PPUSH
19261: LD_VAR 0 2
19265: PPUSH
19266: LD_VAR 0 3
19270: PPUSH
19271: LD_VAR 0 4
19275: PPUSH
19276: LD_VAR 0 5
19280: PPUSH
19281: CALL_OW 448
19285: IFFALSE 19320
// begin result := [ chassis , engine , control , weapon ] ;
19287: LD_ADDR_VAR 0 6
19291: PUSH
19292: LD_VAR 0 2
19296: PUSH
19297: LD_VAR 0 3
19301: PUSH
19302: LD_VAR 0 4
19306: PUSH
19307: LD_VAR 0 5
19311: PUSH
19312: EMPTY
19313: LIST
19314: LIST
19315: LIST
19316: LIST
19317: ST_TO_ADDR
// exit ;
19318: GO 19732
// end ; _chassis := AvailableChassisList ( factory ) ;
19320: LD_ADDR_VAR 0 9
19324: PUSH
19325: LD_VAR 0 1
19329: PPUSH
19330: CALL_OW 475
19334: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
19335: LD_ADDR_VAR 0 11
19339: PUSH
19340: LD_VAR 0 1
19344: PPUSH
19345: CALL_OW 476
19349: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
19350: LD_ADDR_VAR 0 12
19354: PUSH
19355: LD_VAR 0 1
19359: PPUSH
19360: CALL_OW 477
19364: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
19365: LD_ADDR_VAR 0 10
19369: PUSH
19370: LD_VAR 0 1
19374: PPUSH
19375: CALL_OW 478
19379: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
19380: LD_VAR 0 9
19384: NOT
19385: PUSH
19386: LD_VAR 0 11
19390: NOT
19391: OR
19392: PUSH
19393: LD_VAR 0 12
19397: NOT
19398: OR
19399: PUSH
19400: LD_VAR 0 10
19404: NOT
19405: OR
19406: IFFALSE 19441
// begin result := [ chassis , engine , control , weapon ] ;
19408: LD_ADDR_VAR 0 6
19412: PUSH
19413: LD_VAR 0 2
19417: PUSH
19418: LD_VAR 0 3
19422: PUSH
19423: LD_VAR 0 4
19427: PUSH
19428: LD_VAR 0 5
19432: PUSH
19433: EMPTY
19434: LIST
19435: LIST
19436: LIST
19437: LIST
19438: ST_TO_ADDR
// exit ;
19439: GO 19732
// end ; if not chassis in _chassis then
19441: LD_VAR 0 2
19445: PUSH
19446: LD_VAR 0 9
19450: IN
19451: NOT
19452: IFFALSE 19478
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
19454: LD_ADDR_VAR 0 2
19458: PUSH
19459: LD_VAR 0 9
19463: PUSH
19464: LD_INT 1
19466: PPUSH
19467: LD_VAR 0 9
19471: PPUSH
19472: CALL_OW 12
19476: ARRAY
19477: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
19478: LD_VAR 0 2
19482: PPUSH
19483: LD_VAR 0 3
19487: PPUSH
19488: CALL 19737 0 2
19492: NOT
19493: IFFALSE 19552
// repeat engine := _engine [ 1 ] ;
19495: LD_ADDR_VAR 0 3
19499: PUSH
19500: LD_VAR 0 11
19504: PUSH
19505: LD_INT 1
19507: ARRAY
19508: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
19509: LD_ADDR_VAR 0 11
19513: PUSH
19514: LD_VAR 0 11
19518: PPUSH
19519: LD_INT 1
19521: PPUSH
19522: CALL_OW 3
19526: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
19527: LD_VAR 0 2
19531: PPUSH
19532: LD_VAR 0 3
19536: PPUSH
19537: CALL 19737 0 2
19541: PUSH
19542: LD_VAR 0 11
19546: PUSH
19547: EMPTY
19548: EQUAL
19549: OR
19550: IFFALSE 19495
// if not control in _control then
19552: LD_VAR 0 4
19556: PUSH
19557: LD_VAR 0 12
19561: IN
19562: NOT
19563: IFFALSE 19589
// control := _control [ rand ( 1 , _control ) ] ;
19565: LD_ADDR_VAR 0 4
19569: PUSH
19570: LD_VAR 0 12
19574: PUSH
19575: LD_INT 1
19577: PPUSH
19578: LD_VAR 0 12
19582: PPUSH
19583: CALL_OW 12
19587: ARRAY
19588: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19589: LD_VAR 0 2
19593: PPUSH
19594: LD_VAR 0 5
19598: PPUSH
19599: CALL 19957 0 2
19603: NOT
19604: IFFALSE 19663
// repeat weapon := _weapon [ 1 ] ;
19606: LD_ADDR_VAR 0 5
19610: PUSH
19611: LD_VAR 0 10
19615: PUSH
19616: LD_INT 1
19618: ARRAY
19619: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19620: LD_ADDR_VAR 0 10
19624: PUSH
19625: LD_VAR 0 10
19629: PPUSH
19630: LD_INT 1
19632: PPUSH
19633: CALL_OW 3
19637: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19638: LD_VAR 0 2
19642: PPUSH
19643: LD_VAR 0 5
19647: PPUSH
19648: CALL 19957 0 2
19652: PUSH
19653: LD_VAR 0 10
19657: PUSH
19658: EMPTY
19659: EQUAL
19660: OR
19661: IFFALSE 19606
// result := [ ] ;
19663: LD_ADDR_VAR 0 6
19667: PUSH
19668: EMPTY
19669: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19670: LD_VAR 0 1
19674: PPUSH
19675: LD_VAR 0 2
19679: PPUSH
19680: LD_VAR 0 3
19684: PPUSH
19685: LD_VAR 0 4
19689: PPUSH
19690: LD_VAR 0 5
19694: PPUSH
19695: CALL_OW 448
19699: IFFALSE 19732
// result := [ chassis , engine , control , weapon ] ;
19701: LD_ADDR_VAR 0 6
19705: PUSH
19706: LD_VAR 0 2
19710: PUSH
19711: LD_VAR 0 3
19715: PUSH
19716: LD_VAR 0 4
19720: PUSH
19721: LD_VAR 0 5
19725: PUSH
19726: EMPTY
19727: LIST
19728: LIST
19729: LIST
19730: LIST
19731: ST_TO_ADDR
// end ;
19732: LD_VAR 0 6
19736: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19737: LD_INT 0
19739: PPUSH
// if not chassis or not engine then
19740: LD_VAR 0 1
19744: NOT
19745: PUSH
19746: LD_VAR 0 2
19750: NOT
19751: OR
19752: IFFALSE 19756
// exit ;
19754: GO 19952
// case engine of engine_solar :
19756: LD_VAR 0 2
19760: PUSH
19761: LD_INT 2
19763: DOUBLE
19764: EQUAL
19765: IFTRUE 19769
19767: GO 19807
19769: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19770: LD_ADDR_VAR 0 3
19774: PUSH
19775: LD_INT 11
19777: PUSH
19778: LD_INT 12
19780: PUSH
19781: LD_INT 13
19783: PUSH
19784: LD_INT 14
19786: PUSH
19787: LD_INT 1
19789: PUSH
19790: LD_INT 2
19792: PUSH
19793: LD_INT 3
19795: PUSH
19796: EMPTY
19797: LIST
19798: LIST
19799: LIST
19800: LIST
19801: LIST
19802: LIST
19803: LIST
19804: ST_TO_ADDR
19805: GO 19936
19807: LD_INT 1
19809: DOUBLE
19810: EQUAL
19811: IFTRUE 19815
19813: GO 19877
19815: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19816: LD_ADDR_VAR 0 3
19820: PUSH
19821: LD_INT 11
19823: PUSH
19824: LD_INT 12
19826: PUSH
19827: LD_INT 13
19829: PUSH
19830: LD_INT 14
19832: PUSH
19833: LD_INT 1
19835: PUSH
19836: LD_INT 2
19838: PUSH
19839: LD_INT 3
19841: PUSH
19842: LD_INT 4
19844: PUSH
19845: LD_INT 5
19847: PUSH
19848: LD_INT 21
19850: PUSH
19851: LD_INT 23
19853: PUSH
19854: LD_INT 22
19856: PUSH
19857: LD_INT 24
19859: PUSH
19860: EMPTY
19861: LIST
19862: LIST
19863: LIST
19864: LIST
19865: LIST
19866: LIST
19867: LIST
19868: LIST
19869: LIST
19870: LIST
19871: LIST
19872: LIST
19873: LIST
19874: ST_TO_ADDR
19875: GO 19936
19877: LD_INT 3
19879: DOUBLE
19880: EQUAL
19881: IFTRUE 19885
19883: GO 19935
19885: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19886: LD_ADDR_VAR 0 3
19890: PUSH
19891: LD_INT 13
19893: PUSH
19894: LD_INT 14
19896: PUSH
19897: LD_INT 2
19899: PUSH
19900: LD_INT 3
19902: PUSH
19903: LD_INT 4
19905: PUSH
19906: LD_INT 5
19908: PUSH
19909: LD_INT 21
19911: PUSH
19912: LD_INT 22
19914: PUSH
19915: LD_INT 23
19917: PUSH
19918: LD_INT 24
19920: PUSH
19921: EMPTY
19922: LIST
19923: LIST
19924: LIST
19925: LIST
19926: LIST
19927: LIST
19928: LIST
19929: LIST
19930: LIST
19931: LIST
19932: ST_TO_ADDR
19933: GO 19936
19935: POP
// result := ( chassis in result ) ;
19936: LD_ADDR_VAR 0 3
19940: PUSH
19941: LD_VAR 0 1
19945: PUSH
19946: LD_VAR 0 3
19950: IN
19951: ST_TO_ADDR
// end ;
19952: LD_VAR 0 3
19956: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19957: LD_INT 0
19959: PPUSH
// if not chassis or not weapon then
19960: LD_VAR 0 1
19964: NOT
19965: PUSH
19966: LD_VAR 0 2
19970: NOT
19971: OR
19972: IFFALSE 19976
// exit ;
19974: GO 21002
// case weapon of us_machine_gun :
19976: LD_VAR 0 2
19980: PUSH
19981: LD_INT 2
19983: DOUBLE
19984: EQUAL
19985: IFTRUE 19989
19987: GO 20019
19989: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19990: LD_ADDR_VAR 0 3
19994: PUSH
19995: LD_INT 1
19997: PUSH
19998: LD_INT 2
20000: PUSH
20001: LD_INT 3
20003: PUSH
20004: LD_INT 4
20006: PUSH
20007: LD_INT 5
20009: PUSH
20010: EMPTY
20011: LIST
20012: LIST
20013: LIST
20014: LIST
20015: LIST
20016: ST_TO_ADDR
20017: GO 20986
20019: LD_INT 3
20021: DOUBLE
20022: EQUAL
20023: IFTRUE 20027
20025: GO 20057
20027: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
20028: LD_ADDR_VAR 0 3
20032: PUSH
20033: LD_INT 1
20035: PUSH
20036: LD_INT 2
20038: PUSH
20039: LD_INT 3
20041: PUSH
20042: LD_INT 4
20044: PUSH
20045: LD_INT 5
20047: PUSH
20048: EMPTY
20049: LIST
20050: LIST
20051: LIST
20052: LIST
20053: LIST
20054: ST_TO_ADDR
20055: GO 20986
20057: LD_INT 11
20059: DOUBLE
20060: EQUAL
20061: IFTRUE 20065
20063: GO 20095
20065: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
20066: LD_ADDR_VAR 0 3
20070: PUSH
20071: LD_INT 1
20073: PUSH
20074: LD_INT 2
20076: PUSH
20077: LD_INT 3
20079: PUSH
20080: LD_INT 4
20082: PUSH
20083: LD_INT 5
20085: PUSH
20086: EMPTY
20087: LIST
20088: LIST
20089: LIST
20090: LIST
20091: LIST
20092: ST_TO_ADDR
20093: GO 20986
20095: LD_INT 4
20097: DOUBLE
20098: EQUAL
20099: IFTRUE 20103
20101: GO 20129
20103: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
20104: LD_ADDR_VAR 0 3
20108: PUSH
20109: LD_INT 2
20111: PUSH
20112: LD_INT 3
20114: PUSH
20115: LD_INT 4
20117: PUSH
20118: LD_INT 5
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: LIST
20125: LIST
20126: ST_TO_ADDR
20127: GO 20986
20129: LD_INT 5
20131: DOUBLE
20132: EQUAL
20133: IFTRUE 20137
20135: GO 20163
20137: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
20138: LD_ADDR_VAR 0 3
20142: PUSH
20143: LD_INT 2
20145: PUSH
20146: LD_INT 3
20148: PUSH
20149: LD_INT 4
20151: PUSH
20152: LD_INT 5
20154: PUSH
20155: EMPTY
20156: LIST
20157: LIST
20158: LIST
20159: LIST
20160: ST_TO_ADDR
20161: GO 20986
20163: LD_INT 9
20165: DOUBLE
20166: EQUAL
20167: IFTRUE 20171
20169: GO 20197
20171: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
20172: LD_ADDR_VAR 0 3
20176: PUSH
20177: LD_INT 2
20179: PUSH
20180: LD_INT 3
20182: PUSH
20183: LD_INT 4
20185: PUSH
20186: LD_INT 5
20188: PUSH
20189: EMPTY
20190: LIST
20191: LIST
20192: LIST
20193: LIST
20194: ST_TO_ADDR
20195: GO 20986
20197: LD_INT 7
20199: DOUBLE
20200: EQUAL
20201: IFTRUE 20205
20203: GO 20231
20205: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
20206: LD_ADDR_VAR 0 3
20210: PUSH
20211: LD_INT 2
20213: PUSH
20214: LD_INT 3
20216: PUSH
20217: LD_INT 4
20219: PUSH
20220: LD_INT 5
20222: PUSH
20223: EMPTY
20224: LIST
20225: LIST
20226: LIST
20227: LIST
20228: ST_TO_ADDR
20229: GO 20986
20231: LD_INT 12
20233: DOUBLE
20234: EQUAL
20235: IFTRUE 20239
20237: GO 20265
20239: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
20240: LD_ADDR_VAR 0 3
20244: PUSH
20245: LD_INT 2
20247: PUSH
20248: LD_INT 3
20250: PUSH
20251: LD_INT 4
20253: PUSH
20254: LD_INT 5
20256: PUSH
20257: EMPTY
20258: LIST
20259: LIST
20260: LIST
20261: LIST
20262: ST_TO_ADDR
20263: GO 20986
20265: LD_INT 13
20267: DOUBLE
20268: EQUAL
20269: IFTRUE 20273
20271: GO 20299
20273: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
20274: LD_ADDR_VAR 0 3
20278: PUSH
20279: LD_INT 2
20281: PUSH
20282: LD_INT 3
20284: PUSH
20285: LD_INT 4
20287: PUSH
20288: LD_INT 5
20290: PUSH
20291: EMPTY
20292: LIST
20293: LIST
20294: LIST
20295: LIST
20296: ST_TO_ADDR
20297: GO 20986
20299: LD_INT 14
20301: DOUBLE
20302: EQUAL
20303: IFTRUE 20307
20305: GO 20325
20307: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
20308: LD_ADDR_VAR 0 3
20312: PUSH
20313: LD_INT 4
20315: PUSH
20316: LD_INT 5
20318: PUSH
20319: EMPTY
20320: LIST
20321: LIST
20322: ST_TO_ADDR
20323: GO 20986
20325: LD_INT 6
20327: DOUBLE
20328: EQUAL
20329: IFTRUE 20333
20331: GO 20351
20333: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
20334: LD_ADDR_VAR 0 3
20338: PUSH
20339: LD_INT 4
20341: PUSH
20342: LD_INT 5
20344: PUSH
20345: EMPTY
20346: LIST
20347: LIST
20348: ST_TO_ADDR
20349: GO 20986
20351: LD_INT 10
20353: DOUBLE
20354: EQUAL
20355: IFTRUE 20359
20357: GO 20377
20359: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
20360: LD_ADDR_VAR 0 3
20364: PUSH
20365: LD_INT 4
20367: PUSH
20368: LD_INT 5
20370: PUSH
20371: EMPTY
20372: LIST
20373: LIST
20374: ST_TO_ADDR
20375: GO 20986
20377: LD_INT 22
20379: DOUBLE
20380: EQUAL
20381: IFTRUE 20385
20383: GO 20411
20385: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
20386: LD_ADDR_VAR 0 3
20390: PUSH
20391: LD_INT 11
20393: PUSH
20394: LD_INT 12
20396: PUSH
20397: LD_INT 13
20399: PUSH
20400: LD_INT 14
20402: PUSH
20403: EMPTY
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: ST_TO_ADDR
20409: GO 20986
20411: LD_INT 23
20413: DOUBLE
20414: EQUAL
20415: IFTRUE 20419
20417: GO 20445
20419: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
20420: LD_ADDR_VAR 0 3
20424: PUSH
20425: LD_INT 11
20427: PUSH
20428: LD_INT 12
20430: PUSH
20431: LD_INT 13
20433: PUSH
20434: LD_INT 14
20436: PUSH
20437: EMPTY
20438: LIST
20439: LIST
20440: LIST
20441: LIST
20442: ST_TO_ADDR
20443: GO 20986
20445: LD_INT 24
20447: DOUBLE
20448: EQUAL
20449: IFTRUE 20453
20451: GO 20479
20453: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
20454: LD_ADDR_VAR 0 3
20458: PUSH
20459: LD_INT 11
20461: PUSH
20462: LD_INT 12
20464: PUSH
20465: LD_INT 13
20467: PUSH
20468: LD_INT 14
20470: PUSH
20471: EMPTY
20472: LIST
20473: LIST
20474: LIST
20475: LIST
20476: ST_TO_ADDR
20477: GO 20986
20479: LD_INT 30
20481: DOUBLE
20482: EQUAL
20483: IFTRUE 20487
20485: GO 20513
20487: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
20488: LD_ADDR_VAR 0 3
20492: PUSH
20493: LD_INT 11
20495: PUSH
20496: LD_INT 12
20498: PUSH
20499: LD_INT 13
20501: PUSH
20502: LD_INT 14
20504: PUSH
20505: EMPTY
20506: LIST
20507: LIST
20508: LIST
20509: LIST
20510: ST_TO_ADDR
20511: GO 20986
20513: LD_INT 25
20515: DOUBLE
20516: EQUAL
20517: IFTRUE 20521
20519: GO 20539
20521: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
20522: LD_ADDR_VAR 0 3
20526: PUSH
20527: LD_INT 13
20529: PUSH
20530: LD_INT 14
20532: PUSH
20533: EMPTY
20534: LIST
20535: LIST
20536: ST_TO_ADDR
20537: GO 20986
20539: LD_INT 27
20541: DOUBLE
20542: EQUAL
20543: IFTRUE 20547
20545: GO 20565
20547: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20548: LD_ADDR_VAR 0 3
20552: PUSH
20553: LD_INT 13
20555: PUSH
20556: LD_INT 14
20558: PUSH
20559: EMPTY
20560: LIST
20561: LIST
20562: ST_TO_ADDR
20563: GO 20986
20565: LD_INT 28
20567: DOUBLE
20568: EQUAL
20569: IFTRUE 20573
20571: GO 20591
20573: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20574: LD_ADDR_VAR 0 3
20578: PUSH
20579: LD_INT 13
20581: PUSH
20582: LD_INT 14
20584: PUSH
20585: EMPTY
20586: LIST
20587: LIST
20588: ST_TO_ADDR
20589: GO 20986
20591: LD_INT 29
20593: DOUBLE
20594: EQUAL
20595: IFTRUE 20599
20597: GO 20617
20599: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20600: LD_ADDR_VAR 0 3
20604: PUSH
20605: LD_INT 13
20607: PUSH
20608: LD_INT 14
20610: PUSH
20611: EMPTY
20612: LIST
20613: LIST
20614: ST_TO_ADDR
20615: GO 20986
20617: LD_INT 31
20619: DOUBLE
20620: EQUAL
20621: IFTRUE 20625
20623: GO 20643
20625: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20626: LD_ADDR_VAR 0 3
20630: PUSH
20631: LD_INT 13
20633: PUSH
20634: LD_INT 14
20636: PUSH
20637: EMPTY
20638: LIST
20639: LIST
20640: ST_TO_ADDR
20641: GO 20986
20643: LD_INT 26
20645: DOUBLE
20646: EQUAL
20647: IFTRUE 20651
20649: GO 20669
20651: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20652: LD_ADDR_VAR 0 3
20656: PUSH
20657: LD_INT 13
20659: PUSH
20660: LD_INT 14
20662: PUSH
20663: EMPTY
20664: LIST
20665: LIST
20666: ST_TO_ADDR
20667: GO 20986
20669: LD_INT 42
20671: DOUBLE
20672: EQUAL
20673: IFTRUE 20677
20675: GO 20703
20677: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20678: LD_ADDR_VAR 0 3
20682: PUSH
20683: LD_INT 21
20685: PUSH
20686: LD_INT 22
20688: PUSH
20689: LD_INT 23
20691: PUSH
20692: LD_INT 24
20694: PUSH
20695: EMPTY
20696: LIST
20697: LIST
20698: LIST
20699: LIST
20700: ST_TO_ADDR
20701: GO 20986
20703: LD_INT 43
20705: DOUBLE
20706: EQUAL
20707: IFTRUE 20711
20709: GO 20737
20711: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20712: LD_ADDR_VAR 0 3
20716: PUSH
20717: LD_INT 21
20719: PUSH
20720: LD_INT 22
20722: PUSH
20723: LD_INT 23
20725: PUSH
20726: LD_INT 24
20728: PUSH
20729: EMPTY
20730: LIST
20731: LIST
20732: LIST
20733: LIST
20734: ST_TO_ADDR
20735: GO 20986
20737: LD_INT 44
20739: DOUBLE
20740: EQUAL
20741: IFTRUE 20745
20743: GO 20771
20745: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20746: LD_ADDR_VAR 0 3
20750: PUSH
20751: LD_INT 21
20753: PUSH
20754: LD_INT 22
20756: PUSH
20757: LD_INT 23
20759: PUSH
20760: LD_INT 24
20762: PUSH
20763: EMPTY
20764: LIST
20765: LIST
20766: LIST
20767: LIST
20768: ST_TO_ADDR
20769: GO 20986
20771: LD_INT 45
20773: DOUBLE
20774: EQUAL
20775: IFTRUE 20779
20777: GO 20805
20779: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20780: LD_ADDR_VAR 0 3
20784: PUSH
20785: LD_INT 21
20787: PUSH
20788: LD_INT 22
20790: PUSH
20791: LD_INT 23
20793: PUSH
20794: LD_INT 24
20796: PUSH
20797: EMPTY
20798: LIST
20799: LIST
20800: LIST
20801: LIST
20802: ST_TO_ADDR
20803: GO 20986
20805: LD_INT 49
20807: DOUBLE
20808: EQUAL
20809: IFTRUE 20813
20811: GO 20839
20813: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20814: LD_ADDR_VAR 0 3
20818: PUSH
20819: LD_INT 21
20821: PUSH
20822: LD_INT 22
20824: PUSH
20825: LD_INT 23
20827: PUSH
20828: LD_INT 24
20830: PUSH
20831: EMPTY
20832: LIST
20833: LIST
20834: LIST
20835: LIST
20836: ST_TO_ADDR
20837: GO 20986
20839: LD_INT 51
20841: DOUBLE
20842: EQUAL
20843: IFTRUE 20847
20845: GO 20873
20847: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20848: LD_ADDR_VAR 0 3
20852: PUSH
20853: LD_INT 21
20855: PUSH
20856: LD_INT 22
20858: PUSH
20859: LD_INT 23
20861: PUSH
20862: LD_INT 24
20864: PUSH
20865: EMPTY
20866: LIST
20867: LIST
20868: LIST
20869: LIST
20870: ST_TO_ADDR
20871: GO 20986
20873: LD_INT 52
20875: DOUBLE
20876: EQUAL
20877: IFTRUE 20881
20879: GO 20907
20881: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20882: LD_ADDR_VAR 0 3
20886: PUSH
20887: LD_INT 21
20889: PUSH
20890: LD_INT 22
20892: PUSH
20893: LD_INT 23
20895: PUSH
20896: LD_INT 24
20898: PUSH
20899: EMPTY
20900: LIST
20901: LIST
20902: LIST
20903: LIST
20904: ST_TO_ADDR
20905: GO 20986
20907: LD_INT 53
20909: DOUBLE
20910: EQUAL
20911: IFTRUE 20915
20913: GO 20933
20915: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20916: LD_ADDR_VAR 0 3
20920: PUSH
20921: LD_INT 23
20923: PUSH
20924: LD_INT 24
20926: PUSH
20927: EMPTY
20928: LIST
20929: LIST
20930: ST_TO_ADDR
20931: GO 20986
20933: LD_INT 46
20935: DOUBLE
20936: EQUAL
20937: IFTRUE 20941
20939: GO 20959
20941: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20942: LD_ADDR_VAR 0 3
20946: PUSH
20947: LD_INT 23
20949: PUSH
20950: LD_INT 24
20952: PUSH
20953: EMPTY
20954: LIST
20955: LIST
20956: ST_TO_ADDR
20957: GO 20986
20959: LD_INT 47
20961: DOUBLE
20962: EQUAL
20963: IFTRUE 20967
20965: GO 20985
20967: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20968: LD_ADDR_VAR 0 3
20972: PUSH
20973: LD_INT 23
20975: PUSH
20976: LD_INT 24
20978: PUSH
20979: EMPTY
20980: LIST
20981: LIST
20982: ST_TO_ADDR
20983: GO 20986
20985: POP
// result := ( chassis in result ) ;
20986: LD_ADDR_VAR 0 3
20990: PUSH
20991: LD_VAR 0 1
20995: PUSH
20996: LD_VAR 0 3
21000: IN
21001: ST_TO_ADDR
// end ;
21002: LD_VAR 0 3
21006: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
21007: LD_INT 0
21009: PPUSH
21010: PPUSH
21011: PPUSH
21012: PPUSH
21013: PPUSH
21014: PPUSH
21015: PPUSH
// result := array ;
21016: LD_ADDR_VAR 0 5
21020: PUSH
21021: LD_VAR 0 1
21025: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
21026: LD_VAR 0 1
21030: NOT
21031: PUSH
21032: LD_VAR 0 2
21036: NOT
21037: OR
21038: PUSH
21039: LD_VAR 0 3
21043: NOT
21044: OR
21045: PUSH
21046: LD_VAR 0 2
21050: PUSH
21051: LD_VAR 0 1
21055: GREATER
21056: OR
21057: PUSH
21058: LD_VAR 0 3
21062: PUSH
21063: LD_VAR 0 1
21067: GREATER
21068: OR
21069: IFFALSE 21073
// exit ;
21071: GO 21369
// if direction then
21073: LD_VAR 0 4
21077: IFFALSE 21141
// begin d := 1 ;
21079: LD_ADDR_VAR 0 9
21083: PUSH
21084: LD_INT 1
21086: ST_TO_ADDR
// if i_from > i_to then
21087: LD_VAR 0 2
21091: PUSH
21092: LD_VAR 0 3
21096: GREATER
21097: IFFALSE 21123
// length := ( array - i_from ) + i_to else
21099: LD_ADDR_VAR 0 11
21103: PUSH
21104: LD_VAR 0 1
21108: PUSH
21109: LD_VAR 0 2
21113: MINUS
21114: PUSH
21115: LD_VAR 0 3
21119: PLUS
21120: ST_TO_ADDR
21121: GO 21139
// length := i_to - i_from ;
21123: LD_ADDR_VAR 0 11
21127: PUSH
21128: LD_VAR 0 3
21132: PUSH
21133: LD_VAR 0 2
21137: MINUS
21138: ST_TO_ADDR
// end else
21139: GO 21202
// begin d := - 1 ;
21141: LD_ADDR_VAR 0 9
21145: PUSH
21146: LD_INT 1
21148: NEG
21149: ST_TO_ADDR
// if i_from > i_to then
21150: LD_VAR 0 2
21154: PUSH
21155: LD_VAR 0 3
21159: GREATER
21160: IFFALSE 21180
// length := i_from - i_to else
21162: LD_ADDR_VAR 0 11
21166: PUSH
21167: LD_VAR 0 2
21171: PUSH
21172: LD_VAR 0 3
21176: MINUS
21177: ST_TO_ADDR
21178: GO 21202
// length := ( array - i_to ) + i_from ;
21180: LD_ADDR_VAR 0 11
21184: PUSH
21185: LD_VAR 0 1
21189: PUSH
21190: LD_VAR 0 3
21194: MINUS
21195: PUSH
21196: LD_VAR 0 2
21200: PLUS
21201: ST_TO_ADDR
// end ; if not length then
21202: LD_VAR 0 11
21206: NOT
21207: IFFALSE 21211
// exit ;
21209: GO 21369
// tmp := array ;
21211: LD_ADDR_VAR 0 10
21215: PUSH
21216: LD_VAR 0 1
21220: ST_TO_ADDR
// for i = 1 to length do
21221: LD_ADDR_VAR 0 6
21225: PUSH
21226: DOUBLE
21227: LD_INT 1
21229: DEC
21230: ST_TO_ADDR
21231: LD_VAR 0 11
21235: PUSH
21236: FOR_TO
21237: IFFALSE 21357
// begin for j = 1 to array do
21239: LD_ADDR_VAR 0 7
21243: PUSH
21244: DOUBLE
21245: LD_INT 1
21247: DEC
21248: ST_TO_ADDR
21249: LD_VAR 0 1
21253: PUSH
21254: FOR_TO
21255: IFFALSE 21343
// begin k := j + d ;
21257: LD_ADDR_VAR 0 8
21261: PUSH
21262: LD_VAR 0 7
21266: PUSH
21267: LD_VAR 0 9
21271: PLUS
21272: ST_TO_ADDR
// if k > array then
21273: LD_VAR 0 8
21277: PUSH
21278: LD_VAR 0 1
21282: GREATER
21283: IFFALSE 21293
// k := 1 ;
21285: LD_ADDR_VAR 0 8
21289: PUSH
21290: LD_INT 1
21292: ST_TO_ADDR
// if not k then
21293: LD_VAR 0 8
21297: NOT
21298: IFFALSE 21310
// k := array ;
21300: LD_ADDR_VAR 0 8
21304: PUSH
21305: LD_VAR 0 1
21309: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
21310: LD_ADDR_VAR 0 10
21314: PUSH
21315: LD_VAR 0 10
21319: PPUSH
21320: LD_VAR 0 8
21324: PPUSH
21325: LD_VAR 0 1
21329: PUSH
21330: LD_VAR 0 7
21334: ARRAY
21335: PPUSH
21336: CALL_OW 1
21340: ST_TO_ADDR
// end ;
21341: GO 21254
21343: POP
21344: POP
// array := tmp ;
21345: LD_ADDR_VAR 0 1
21349: PUSH
21350: LD_VAR 0 10
21354: ST_TO_ADDR
// end ;
21355: GO 21236
21357: POP
21358: POP
// result := array ;
21359: LD_ADDR_VAR 0 5
21363: PUSH
21364: LD_VAR 0 1
21368: ST_TO_ADDR
// end ;
21369: LD_VAR 0 5
21373: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
21374: LD_INT 0
21376: PPUSH
21377: PPUSH
// result := 0 ;
21378: LD_ADDR_VAR 0 3
21382: PUSH
21383: LD_INT 0
21385: ST_TO_ADDR
// if not array or not value in array then
21386: LD_VAR 0 1
21390: NOT
21391: PUSH
21392: LD_VAR 0 2
21396: PUSH
21397: LD_VAR 0 1
21401: IN
21402: NOT
21403: OR
21404: IFFALSE 21408
// exit ;
21406: GO 21462
// for i = 1 to array do
21408: LD_ADDR_VAR 0 4
21412: PUSH
21413: DOUBLE
21414: LD_INT 1
21416: DEC
21417: ST_TO_ADDR
21418: LD_VAR 0 1
21422: PUSH
21423: FOR_TO
21424: IFFALSE 21460
// if value = array [ i ] then
21426: LD_VAR 0 2
21430: PUSH
21431: LD_VAR 0 1
21435: PUSH
21436: LD_VAR 0 4
21440: ARRAY
21441: EQUAL
21442: IFFALSE 21458
// begin result := i ;
21444: LD_ADDR_VAR 0 3
21448: PUSH
21449: LD_VAR 0 4
21453: ST_TO_ADDR
// exit ;
21454: POP
21455: POP
21456: GO 21462
// end ;
21458: GO 21423
21460: POP
21461: POP
// end ;
21462: LD_VAR 0 3
21466: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
21467: LD_INT 0
21469: PPUSH
// vc_chassis := chassis ;
21470: LD_ADDR_OWVAR 37
21474: PUSH
21475: LD_VAR 0 1
21479: ST_TO_ADDR
// vc_engine := engine ;
21480: LD_ADDR_OWVAR 39
21484: PUSH
21485: LD_VAR 0 2
21489: ST_TO_ADDR
// vc_control := control ;
21490: LD_ADDR_OWVAR 38
21494: PUSH
21495: LD_VAR 0 3
21499: ST_TO_ADDR
// vc_weapon := weapon ;
21500: LD_ADDR_OWVAR 40
21504: PUSH
21505: LD_VAR 0 4
21509: ST_TO_ADDR
// vc_fuel_battery := fuel ;
21510: LD_ADDR_OWVAR 41
21514: PUSH
21515: LD_VAR 0 5
21519: ST_TO_ADDR
// end ;
21520: LD_VAR 0 6
21524: RET
// export function WantPlant ( unit ) ; var task ; begin
21525: LD_INT 0
21527: PPUSH
21528: PPUSH
// result := false ;
21529: LD_ADDR_VAR 0 2
21533: PUSH
21534: LD_INT 0
21536: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21537: LD_ADDR_VAR 0 3
21541: PUSH
21542: LD_VAR 0 1
21546: PPUSH
21547: CALL_OW 437
21551: ST_TO_ADDR
// if task then
21552: LD_VAR 0 3
21556: IFFALSE 21584
// if task [ 1 ] [ 1 ] = p then
21558: LD_VAR 0 3
21562: PUSH
21563: LD_INT 1
21565: ARRAY
21566: PUSH
21567: LD_INT 1
21569: ARRAY
21570: PUSH
21571: LD_STRING p
21573: EQUAL
21574: IFFALSE 21584
// result := true ;
21576: LD_ADDR_VAR 0 2
21580: PUSH
21581: LD_INT 1
21583: ST_TO_ADDR
// end ;
21584: LD_VAR 0 2
21588: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21589: LD_INT 0
21591: PPUSH
21592: PPUSH
21593: PPUSH
21594: PPUSH
// if pos < 1 then
21595: LD_VAR 0 2
21599: PUSH
21600: LD_INT 1
21602: LESS
21603: IFFALSE 21607
// exit ;
21605: GO 21910
// if pos = 1 then
21607: LD_VAR 0 2
21611: PUSH
21612: LD_INT 1
21614: EQUAL
21615: IFFALSE 21648
// result := Replace ( arr , pos [ 1 ] , value ) else
21617: LD_ADDR_VAR 0 4
21621: PUSH
21622: LD_VAR 0 1
21626: PPUSH
21627: LD_VAR 0 2
21631: PUSH
21632: LD_INT 1
21634: ARRAY
21635: PPUSH
21636: LD_VAR 0 3
21640: PPUSH
21641: CALL_OW 1
21645: ST_TO_ADDR
21646: GO 21910
// begin tmp := arr ;
21648: LD_ADDR_VAR 0 6
21652: PUSH
21653: LD_VAR 0 1
21657: ST_TO_ADDR
// s_arr := [ tmp ] ;
21658: LD_ADDR_VAR 0 7
21662: PUSH
21663: LD_VAR 0 6
21667: PUSH
21668: EMPTY
21669: LIST
21670: ST_TO_ADDR
// for i = 1 to pos - 1 do
21671: LD_ADDR_VAR 0 5
21675: PUSH
21676: DOUBLE
21677: LD_INT 1
21679: DEC
21680: ST_TO_ADDR
21681: LD_VAR 0 2
21685: PUSH
21686: LD_INT 1
21688: MINUS
21689: PUSH
21690: FOR_TO
21691: IFFALSE 21736
// begin tmp := tmp [ pos [ i ] ] ;
21693: LD_ADDR_VAR 0 6
21697: PUSH
21698: LD_VAR 0 6
21702: PUSH
21703: LD_VAR 0 2
21707: PUSH
21708: LD_VAR 0 5
21712: ARRAY
21713: ARRAY
21714: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21715: LD_ADDR_VAR 0 7
21719: PUSH
21720: LD_VAR 0 7
21724: PUSH
21725: LD_VAR 0 6
21729: PUSH
21730: EMPTY
21731: LIST
21732: ADD
21733: ST_TO_ADDR
// end ;
21734: GO 21690
21736: POP
21737: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21738: LD_ADDR_VAR 0 6
21742: PUSH
21743: LD_VAR 0 6
21747: PPUSH
21748: LD_VAR 0 2
21752: PUSH
21753: LD_VAR 0 2
21757: ARRAY
21758: PPUSH
21759: LD_VAR 0 3
21763: PPUSH
21764: CALL_OW 1
21768: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21769: LD_ADDR_VAR 0 7
21773: PUSH
21774: LD_VAR 0 7
21778: PPUSH
21779: LD_VAR 0 7
21783: PPUSH
21784: LD_VAR 0 6
21788: PPUSH
21789: CALL_OW 1
21793: ST_TO_ADDR
// for i = s_arr downto 2 do
21794: LD_ADDR_VAR 0 5
21798: PUSH
21799: DOUBLE
21800: LD_VAR 0 7
21804: INC
21805: ST_TO_ADDR
21806: LD_INT 2
21808: PUSH
21809: FOR_DOWNTO
21810: IFFALSE 21894
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21812: LD_ADDR_VAR 0 6
21816: PUSH
21817: LD_VAR 0 7
21821: PUSH
21822: LD_VAR 0 5
21826: PUSH
21827: LD_INT 1
21829: MINUS
21830: ARRAY
21831: PPUSH
21832: LD_VAR 0 2
21836: PUSH
21837: LD_VAR 0 5
21841: PUSH
21842: LD_INT 1
21844: MINUS
21845: ARRAY
21846: PPUSH
21847: LD_VAR 0 7
21851: PUSH
21852: LD_VAR 0 5
21856: ARRAY
21857: PPUSH
21858: CALL_OW 1
21862: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21863: LD_ADDR_VAR 0 7
21867: PUSH
21868: LD_VAR 0 7
21872: PPUSH
21873: LD_VAR 0 5
21877: PUSH
21878: LD_INT 1
21880: MINUS
21881: PPUSH
21882: LD_VAR 0 6
21886: PPUSH
21887: CALL_OW 1
21891: ST_TO_ADDR
// end ;
21892: GO 21809
21894: POP
21895: POP
// result := s_arr [ 1 ] ;
21896: LD_ADDR_VAR 0 4
21900: PUSH
21901: LD_VAR 0 7
21905: PUSH
21906: LD_INT 1
21908: ARRAY
21909: ST_TO_ADDR
// end ; end ;
21910: LD_VAR 0 4
21914: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21915: LD_INT 0
21917: PPUSH
21918: PPUSH
// if not list then
21919: LD_VAR 0 1
21923: NOT
21924: IFFALSE 21928
// exit ;
21926: GO 22019
// i := list [ pos1 ] ;
21928: LD_ADDR_VAR 0 5
21932: PUSH
21933: LD_VAR 0 1
21937: PUSH
21938: LD_VAR 0 2
21942: ARRAY
21943: ST_TO_ADDR
// if not i then
21944: LD_VAR 0 5
21948: NOT
21949: IFFALSE 21953
// exit ;
21951: GO 22019
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21953: LD_ADDR_VAR 0 1
21957: PUSH
21958: LD_VAR 0 1
21962: PPUSH
21963: LD_VAR 0 2
21967: PPUSH
21968: LD_VAR 0 1
21972: PUSH
21973: LD_VAR 0 3
21977: ARRAY
21978: PPUSH
21979: CALL_OW 1
21983: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21984: LD_ADDR_VAR 0 1
21988: PUSH
21989: LD_VAR 0 1
21993: PPUSH
21994: LD_VAR 0 3
21998: PPUSH
21999: LD_VAR 0 5
22003: PPUSH
22004: CALL_OW 1
22008: ST_TO_ADDR
// result := list ;
22009: LD_ADDR_VAR 0 4
22013: PUSH
22014: LD_VAR 0 1
22018: ST_TO_ADDR
// end ;
22019: LD_VAR 0 4
22023: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
22024: LD_INT 0
22026: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
22027: LD_ADDR_VAR 0 5
22031: PUSH
22032: LD_VAR 0 1
22036: PPUSH
22037: CALL_OW 250
22041: PPUSH
22042: LD_VAR 0 1
22046: PPUSH
22047: CALL_OW 251
22051: PPUSH
22052: LD_VAR 0 2
22056: PPUSH
22057: LD_VAR 0 3
22061: PPUSH
22062: LD_VAR 0 4
22066: PPUSH
22067: CALL 22077 0 5
22071: ST_TO_ADDR
// end ;
22072: LD_VAR 0 5
22076: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
22077: LD_INT 0
22079: PPUSH
22080: PPUSH
22081: PPUSH
22082: PPUSH
// if not list then
22083: LD_VAR 0 3
22087: NOT
22088: IFFALSE 22092
// exit ;
22090: GO 22480
// result := [ ] ;
22092: LD_ADDR_VAR 0 6
22096: PUSH
22097: EMPTY
22098: ST_TO_ADDR
// for i in list do
22099: LD_ADDR_VAR 0 7
22103: PUSH
22104: LD_VAR 0 3
22108: PUSH
22109: FOR_IN
22110: IFFALSE 22312
// begin tmp := GetDistUnitXY ( i , x , y ) ;
22112: LD_ADDR_VAR 0 9
22116: PUSH
22117: LD_VAR 0 7
22121: PPUSH
22122: LD_VAR 0 1
22126: PPUSH
22127: LD_VAR 0 2
22131: PPUSH
22132: CALL_OW 297
22136: ST_TO_ADDR
// if not result then
22137: LD_VAR 0 6
22141: NOT
22142: IFFALSE 22168
// result := [ [ i , tmp ] ] else
22144: LD_ADDR_VAR 0 6
22148: PUSH
22149: LD_VAR 0 7
22153: PUSH
22154: LD_VAR 0 9
22158: PUSH
22159: EMPTY
22160: LIST
22161: LIST
22162: PUSH
22163: EMPTY
22164: LIST
22165: ST_TO_ADDR
22166: GO 22310
// begin if result [ result ] [ 2 ] < tmp then
22168: LD_VAR 0 6
22172: PUSH
22173: LD_VAR 0 6
22177: ARRAY
22178: PUSH
22179: LD_INT 2
22181: ARRAY
22182: PUSH
22183: LD_VAR 0 9
22187: LESS
22188: IFFALSE 22230
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
22190: LD_ADDR_VAR 0 6
22194: PUSH
22195: LD_VAR 0 6
22199: PPUSH
22200: LD_VAR 0 6
22204: PUSH
22205: LD_INT 1
22207: PLUS
22208: PPUSH
22209: LD_VAR 0 7
22213: PUSH
22214: LD_VAR 0 9
22218: PUSH
22219: EMPTY
22220: LIST
22221: LIST
22222: PPUSH
22223: CALL_OW 2
22227: ST_TO_ADDR
22228: GO 22310
// for j = 1 to result do
22230: LD_ADDR_VAR 0 8
22234: PUSH
22235: DOUBLE
22236: LD_INT 1
22238: DEC
22239: ST_TO_ADDR
22240: LD_VAR 0 6
22244: PUSH
22245: FOR_TO
22246: IFFALSE 22308
// begin if tmp < result [ j ] [ 2 ] then
22248: LD_VAR 0 9
22252: PUSH
22253: LD_VAR 0 6
22257: PUSH
22258: LD_VAR 0 8
22262: ARRAY
22263: PUSH
22264: LD_INT 2
22266: ARRAY
22267: LESS
22268: IFFALSE 22306
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22270: LD_ADDR_VAR 0 6
22274: PUSH
22275: LD_VAR 0 6
22279: PPUSH
22280: LD_VAR 0 8
22284: PPUSH
22285: LD_VAR 0 7
22289: PUSH
22290: LD_VAR 0 9
22294: PUSH
22295: EMPTY
22296: LIST
22297: LIST
22298: PPUSH
22299: CALL_OW 2
22303: ST_TO_ADDR
// break ;
22304: GO 22308
// end ; end ;
22306: GO 22245
22308: POP
22309: POP
// end ; end ;
22310: GO 22109
22312: POP
22313: POP
// if result and not asc then
22314: LD_VAR 0 6
22318: PUSH
22319: LD_VAR 0 4
22323: NOT
22324: AND
22325: IFFALSE 22400
// begin tmp := result ;
22327: LD_ADDR_VAR 0 9
22331: PUSH
22332: LD_VAR 0 6
22336: ST_TO_ADDR
// for i = tmp downto 1 do
22337: LD_ADDR_VAR 0 7
22341: PUSH
22342: DOUBLE
22343: LD_VAR 0 9
22347: INC
22348: ST_TO_ADDR
22349: LD_INT 1
22351: PUSH
22352: FOR_DOWNTO
22353: IFFALSE 22398
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
22355: LD_ADDR_VAR 0 6
22359: PUSH
22360: LD_VAR 0 6
22364: PPUSH
22365: LD_VAR 0 9
22369: PUSH
22370: LD_VAR 0 7
22374: MINUS
22375: PUSH
22376: LD_INT 1
22378: PLUS
22379: PPUSH
22380: LD_VAR 0 9
22384: PUSH
22385: LD_VAR 0 7
22389: ARRAY
22390: PPUSH
22391: CALL_OW 1
22395: ST_TO_ADDR
22396: GO 22352
22398: POP
22399: POP
// end ; tmp := [ ] ;
22400: LD_ADDR_VAR 0 9
22404: PUSH
22405: EMPTY
22406: ST_TO_ADDR
// if mode then
22407: LD_VAR 0 5
22411: IFFALSE 22480
// begin for i = 1 to result do
22413: LD_ADDR_VAR 0 7
22417: PUSH
22418: DOUBLE
22419: LD_INT 1
22421: DEC
22422: ST_TO_ADDR
22423: LD_VAR 0 6
22427: PUSH
22428: FOR_TO
22429: IFFALSE 22468
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
22431: LD_ADDR_VAR 0 9
22435: PUSH
22436: LD_VAR 0 9
22440: PPUSH
22441: LD_VAR 0 7
22445: PPUSH
22446: LD_VAR 0 6
22450: PUSH
22451: LD_VAR 0 7
22455: ARRAY
22456: PUSH
22457: LD_INT 1
22459: ARRAY
22460: PPUSH
22461: CALL_OW 1
22465: ST_TO_ADDR
22466: GO 22428
22468: POP
22469: POP
// result := tmp ;
22470: LD_ADDR_VAR 0 6
22474: PUSH
22475: LD_VAR 0 9
22479: ST_TO_ADDR
// end ; end ;
22480: LD_VAR 0 6
22484: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22485: LD_INT 0
22487: PPUSH
22488: PPUSH
22489: PPUSH
22490: PPUSH
22491: PPUSH
22492: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22493: LD_ADDR_VAR 0 5
22497: PUSH
22498: LD_INT 0
22500: PUSH
22501: LD_INT 0
22503: PUSH
22504: LD_INT 0
22506: PUSH
22507: EMPTY
22508: PUSH
22509: EMPTY
22510: LIST
22511: LIST
22512: LIST
22513: LIST
22514: ST_TO_ADDR
// if not x or not y then
22515: LD_VAR 0 2
22519: NOT
22520: PUSH
22521: LD_VAR 0 3
22525: NOT
22526: OR
22527: IFFALSE 22531
// exit ;
22529: GO 24177
// if not range then
22531: LD_VAR 0 4
22535: NOT
22536: IFFALSE 22546
// range := 10 ;
22538: LD_ADDR_VAR 0 4
22542: PUSH
22543: LD_INT 10
22545: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22546: LD_ADDR_VAR 0 8
22550: PUSH
22551: LD_INT 81
22553: PUSH
22554: LD_VAR 0 1
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PUSH
22563: LD_INT 92
22565: PUSH
22566: LD_VAR 0 2
22570: PUSH
22571: LD_VAR 0 3
22575: PUSH
22576: LD_VAR 0 4
22580: PUSH
22581: EMPTY
22582: LIST
22583: LIST
22584: LIST
22585: LIST
22586: PUSH
22587: LD_INT 3
22589: PUSH
22590: LD_INT 21
22592: PUSH
22593: LD_INT 3
22595: PUSH
22596: EMPTY
22597: LIST
22598: LIST
22599: PUSH
22600: EMPTY
22601: LIST
22602: LIST
22603: PUSH
22604: EMPTY
22605: LIST
22606: LIST
22607: LIST
22608: PPUSH
22609: CALL_OW 69
22613: ST_TO_ADDR
// if not tmp then
22614: LD_VAR 0 8
22618: NOT
22619: IFFALSE 22623
// exit ;
22621: GO 24177
// for i in tmp do
22623: LD_ADDR_VAR 0 6
22627: PUSH
22628: LD_VAR 0 8
22632: PUSH
22633: FOR_IN
22634: IFFALSE 24152
// begin points := [ 0 , 0 , 0 ] ;
22636: LD_ADDR_VAR 0 9
22640: PUSH
22641: LD_INT 0
22643: PUSH
22644: LD_INT 0
22646: PUSH
22647: LD_INT 0
22649: PUSH
22650: EMPTY
22651: LIST
22652: LIST
22653: LIST
22654: ST_TO_ADDR
// bpoints := 1 ;
22655: LD_ADDR_VAR 0 10
22659: PUSH
22660: LD_INT 1
22662: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22663: LD_VAR 0 6
22667: PPUSH
22668: CALL_OW 247
22672: PUSH
22673: LD_INT 1
22675: DOUBLE
22676: EQUAL
22677: IFTRUE 22681
22679: GO 23259
22681: POP
// begin if GetClass ( i ) = 1 then
22682: LD_VAR 0 6
22686: PPUSH
22687: CALL_OW 257
22691: PUSH
22692: LD_INT 1
22694: EQUAL
22695: IFFALSE 22716
// points := [ 10 , 5 , 3 ] ;
22697: LD_ADDR_VAR 0 9
22701: PUSH
22702: LD_INT 10
22704: PUSH
22705: LD_INT 5
22707: PUSH
22708: LD_INT 3
22710: PUSH
22711: EMPTY
22712: LIST
22713: LIST
22714: LIST
22715: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22716: LD_VAR 0 6
22720: PPUSH
22721: CALL_OW 257
22725: PUSH
22726: LD_INT 2
22728: PUSH
22729: LD_INT 3
22731: PUSH
22732: LD_INT 4
22734: PUSH
22735: EMPTY
22736: LIST
22737: LIST
22738: LIST
22739: IN
22740: IFFALSE 22761
// points := [ 3 , 2 , 1 ] ;
22742: LD_ADDR_VAR 0 9
22746: PUSH
22747: LD_INT 3
22749: PUSH
22750: LD_INT 2
22752: PUSH
22753: LD_INT 1
22755: PUSH
22756: EMPTY
22757: LIST
22758: LIST
22759: LIST
22760: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22761: LD_VAR 0 6
22765: PPUSH
22766: CALL_OW 257
22770: PUSH
22771: LD_INT 5
22773: EQUAL
22774: IFFALSE 22795
// points := [ 130 , 5 , 2 ] ;
22776: LD_ADDR_VAR 0 9
22780: PUSH
22781: LD_INT 130
22783: PUSH
22784: LD_INT 5
22786: PUSH
22787: LD_INT 2
22789: PUSH
22790: EMPTY
22791: LIST
22792: LIST
22793: LIST
22794: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22795: LD_VAR 0 6
22799: PPUSH
22800: CALL_OW 257
22804: PUSH
22805: LD_INT 8
22807: EQUAL
22808: IFFALSE 22829
// points := [ 35 , 35 , 30 ] ;
22810: LD_ADDR_VAR 0 9
22814: PUSH
22815: LD_INT 35
22817: PUSH
22818: LD_INT 35
22820: PUSH
22821: LD_INT 30
22823: PUSH
22824: EMPTY
22825: LIST
22826: LIST
22827: LIST
22828: ST_TO_ADDR
// if GetClass ( i ) = 9 then
22829: LD_VAR 0 6
22833: PPUSH
22834: CALL_OW 257
22838: PUSH
22839: LD_INT 9
22841: EQUAL
22842: IFFALSE 22863
// points := [ 20 , 55 , 40 ] ;
22844: LD_ADDR_VAR 0 9
22848: PUSH
22849: LD_INT 20
22851: PUSH
22852: LD_INT 55
22854: PUSH
22855: LD_INT 40
22857: PUSH
22858: EMPTY
22859: LIST
22860: LIST
22861: LIST
22862: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
22863: LD_VAR 0 6
22867: PPUSH
22868: CALL_OW 257
22872: PUSH
22873: LD_INT 12
22875: PUSH
22876: LD_INT 16
22878: PUSH
22879: EMPTY
22880: LIST
22881: LIST
22882: IN
22883: IFFALSE 22904
// points := [ 5 , 3 , 2 ] ;
22885: LD_ADDR_VAR 0 9
22889: PUSH
22890: LD_INT 5
22892: PUSH
22893: LD_INT 3
22895: PUSH
22896: LD_INT 2
22898: PUSH
22899: EMPTY
22900: LIST
22901: LIST
22902: LIST
22903: ST_TO_ADDR
// if GetClass ( i ) = 17 then
22904: LD_VAR 0 6
22908: PPUSH
22909: CALL_OW 257
22913: PUSH
22914: LD_INT 17
22916: EQUAL
22917: IFFALSE 22938
// points := [ 100 , 50 , 75 ] ;
22919: LD_ADDR_VAR 0 9
22923: PUSH
22924: LD_INT 100
22926: PUSH
22927: LD_INT 50
22929: PUSH
22930: LD_INT 75
22932: PUSH
22933: EMPTY
22934: LIST
22935: LIST
22936: LIST
22937: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22938: LD_VAR 0 6
22942: PPUSH
22943: CALL_OW 257
22947: PUSH
22948: LD_INT 15
22950: EQUAL
22951: IFFALSE 22972
// points := [ 10 , 5 , 3 ] ;
22953: LD_ADDR_VAR 0 9
22957: PUSH
22958: LD_INT 10
22960: PUSH
22961: LD_INT 5
22963: PUSH
22964: LD_INT 3
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: LIST
22971: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22972: LD_VAR 0 6
22976: PPUSH
22977: CALL_OW 257
22981: PUSH
22982: LD_INT 14
22984: EQUAL
22985: IFFALSE 23006
// points := [ 10 , 0 , 0 ] ;
22987: LD_ADDR_VAR 0 9
22991: PUSH
22992: LD_INT 10
22994: PUSH
22995: LD_INT 0
22997: PUSH
22998: LD_INT 0
23000: PUSH
23001: EMPTY
23002: LIST
23003: LIST
23004: LIST
23005: ST_TO_ADDR
// if GetClass ( i ) = 11 then
23006: LD_VAR 0 6
23010: PPUSH
23011: CALL_OW 257
23015: PUSH
23016: LD_INT 11
23018: EQUAL
23019: IFFALSE 23040
// points := [ 30 , 10 , 5 ] ;
23021: LD_ADDR_VAR 0 9
23025: PUSH
23026: LD_INT 30
23028: PUSH
23029: LD_INT 10
23031: PUSH
23032: LD_INT 5
23034: PUSH
23035: EMPTY
23036: LIST
23037: LIST
23038: LIST
23039: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
23040: LD_VAR 0 1
23044: PPUSH
23045: LD_INT 5
23047: PPUSH
23048: CALL_OW 321
23052: PUSH
23053: LD_INT 2
23055: EQUAL
23056: IFFALSE 23073
// bpoints := bpoints * 1.8 ;
23058: LD_ADDR_VAR 0 10
23062: PUSH
23063: LD_VAR 0 10
23067: PUSH
23068: LD_REAL  1.80000000000000E+0000
23071: MUL
23072: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
23073: LD_VAR 0 6
23077: PPUSH
23078: CALL_OW 257
23082: PUSH
23083: LD_INT 1
23085: PUSH
23086: LD_INT 2
23088: PUSH
23089: LD_INT 3
23091: PUSH
23092: LD_INT 4
23094: PUSH
23095: EMPTY
23096: LIST
23097: LIST
23098: LIST
23099: LIST
23100: IN
23101: PUSH
23102: LD_VAR 0 1
23106: PPUSH
23107: LD_INT 51
23109: PPUSH
23110: CALL_OW 321
23114: PUSH
23115: LD_INT 2
23117: EQUAL
23118: AND
23119: IFFALSE 23136
// bpoints := bpoints * 1.2 ;
23121: LD_ADDR_VAR 0 10
23125: PUSH
23126: LD_VAR 0 10
23130: PUSH
23131: LD_REAL  1.20000000000000E+0000
23134: MUL
23135: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
23136: LD_VAR 0 6
23140: PPUSH
23141: CALL_OW 257
23145: PUSH
23146: LD_INT 5
23148: PUSH
23149: LD_INT 7
23151: PUSH
23152: LD_INT 9
23154: PUSH
23155: EMPTY
23156: LIST
23157: LIST
23158: LIST
23159: IN
23160: PUSH
23161: LD_VAR 0 1
23165: PPUSH
23166: LD_INT 52
23168: PPUSH
23169: CALL_OW 321
23173: PUSH
23174: LD_INT 2
23176: EQUAL
23177: AND
23178: IFFALSE 23195
// bpoints := bpoints * 1.5 ;
23180: LD_ADDR_VAR 0 10
23184: PUSH
23185: LD_VAR 0 10
23189: PUSH
23190: LD_REAL  1.50000000000000E+0000
23193: MUL
23194: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
23195: LD_VAR 0 1
23199: PPUSH
23200: LD_INT 66
23202: PPUSH
23203: CALL_OW 321
23207: PUSH
23208: LD_INT 2
23210: EQUAL
23211: IFFALSE 23228
// bpoints := bpoints * 1.1 ;
23213: LD_ADDR_VAR 0 10
23217: PUSH
23218: LD_VAR 0 10
23222: PUSH
23223: LD_REAL  1.10000000000000E+0000
23226: MUL
23227: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
23228: LD_ADDR_VAR 0 10
23232: PUSH
23233: LD_VAR 0 10
23237: PUSH
23238: LD_VAR 0 6
23242: PPUSH
23243: LD_INT 1
23245: PPUSH
23246: CALL_OW 259
23250: PUSH
23251: LD_REAL  1.15000000000000E+0000
23254: MUL
23255: MUL
23256: ST_TO_ADDR
// end ; unit_vehicle :
23257: GO 24081
23259: LD_INT 2
23261: DOUBLE
23262: EQUAL
23263: IFTRUE 23267
23265: GO 24069
23267: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
23268: LD_VAR 0 6
23272: PPUSH
23273: CALL_OW 264
23277: PUSH
23278: LD_INT 2
23280: PUSH
23281: LD_INT 42
23283: PUSH
23284: LD_INT 24
23286: PUSH
23287: EMPTY
23288: LIST
23289: LIST
23290: LIST
23291: IN
23292: IFFALSE 23313
// points := [ 25 , 5 , 3 ] ;
23294: LD_ADDR_VAR 0 9
23298: PUSH
23299: LD_INT 25
23301: PUSH
23302: LD_INT 5
23304: PUSH
23305: LD_INT 3
23307: PUSH
23308: EMPTY
23309: LIST
23310: LIST
23311: LIST
23312: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
23313: LD_VAR 0 6
23317: PPUSH
23318: CALL_OW 264
23322: PUSH
23323: LD_INT 4
23325: PUSH
23326: LD_INT 43
23328: PUSH
23329: LD_INT 25
23331: PUSH
23332: EMPTY
23333: LIST
23334: LIST
23335: LIST
23336: IN
23337: IFFALSE 23358
// points := [ 40 , 15 , 5 ] ;
23339: LD_ADDR_VAR 0 9
23343: PUSH
23344: LD_INT 40
23346: PUSH
23347: LD_INT 15
23349: PUSH
23350: LD_INT 5
23352: PUSH
23353: EMPTY
23354: LIST
23355: LIST
23356: LIST
23357: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
23358: LD_VAR 0 6
23362: PPUSH
23363: CALL_OW 264
23367: PUSH
23368: LD_INT 3
23370: PUSH
23371: LD_INT 23
23373: PUSH
23374: EMPTY
23375: LIST
23376: LIST
23377: IN
23378: IFFALSE 23399
// points := [ 7 , 25 , 8 ] ;
23380: LD_ADDR_VAR 0 9
23384: PUSH
23385: LD_INT 7
23387: PUSH
23388: LD_INT 25
23390: PUSH
23391: LD_INT 8
23393: PUSH
23394: EMPTY
23395: LIST
23396: LIST
23397: LIST
23398: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
23399: LD_VAR 0 6
23403: PPUSH
23404: CALL_OW 264
23408: PUSH
23409: LD_INT 5
23411: PUSH
23412: LD_INT 27
23414: PUSH
23415: LD_INT 44
23417: PUSH
23418: EMPTY
23419: LIST
23420: LIST
23421: LIST
23422: IN
23423: IFFALSE 23444
// points := [ 14 , 50 , 16 ] ;
23425: LD_ADDR_VAR 0 9
23429: PUSH
23430: LD_INT 14
23432: PUSH
23433: LD_INT 50
23435: PUSH
23436: LD_INT 16
23438: PUSH
23439: EMPTY
23440: LIST
23441: LIST
23442: LIST
23443: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23444: LD_VAR 0 6
23448: PPUSH
23449: CALL_OW 264
23453: PUSH
23454: LD_INT 6
23456: PUSH
23457: LD_INT 46
23459: PUSH
23460: EMPTY
23461: LIST
23462: LIST
23463: IN
23464: IFFALSE 23485
// points := [ 32 , 120 , 70 ] ;
23466: LD_ADDR_VAR 0 9
23470: PUSH
23471: LD_INT 32
23473: PUSH
23474: LD_INT 120
23476: PUSH
23477: LD_INT 70
23479: PUSH
23480: EMPTY
23481: LIST
23482: LIST
23483: LIST
23484: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
23485: LD_VAR 0 6
23489: PPUSH
23490: CALL_OW 264
23494: PUSH
23495: LD_INT 7
23497: PUSH
23498: LD_INT 28
23500: PUSH
23501: LD_INT 45
23503: PUSH
23504: EMPTY
23505: LIST
23506: LIST
23507: LIST
23508: IN
23509: IFFALSE 23530
// points := [ 35 , 20 , 45 ] ;
23511: LD_ADDR_VAR 0 9
23515: PUSH
23516: LD_INT 35
23518: PUSH
23519: LD_INT 20
23521: PUSH
23522: LD_INT 45
23524: PUSH
23525: EMPTY
23526: LIST
23527: LIST
23528: LIST
23529: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23530: LD_VAR 0 6
23534: PPUSH
23535: CALL_OW 264
23539: PUSH
23540: LD_INT 47
23542: PUSH
23543: EMPTY
23544: LIST
23545: IN
23546: IFFALSE 23567
// points := [ 67 , 45 , 75 ] ;
23548: LD_ADDR_VAR 0 9
23552: PUSH
23553: LD_INT 67
23555: PUSH
23556: LD_INT 45
23558: PUSH
23559: LD_INT 75
23561: PUSH
23562: EMPTY
23563: LIST
23564: LIST
23565: LIST
23566: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23567: LD_VAR 0 6
23571: PPUSH
23572: CALL_OW 264
23576: PUSH
23577: LD_INT 26
23579: PUSH
23580: EMPTY
23581: LIST
23582: IN
23583: IFFALSE 23604
// points := [ 120 , 30 , 80 ] ;
23585: LD_ADDR_VAR 0 9
23589: PUSH
23590: LD_INT 120
23592: PUSH
23593: LD_INT 30
23595: PUSH
23596: LD_INT 80
23598: PUSH
23599: EMPTY
23600: LIST
23601: LIST
23602: LIST
23603: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23604: LD_VAR 0 6
23608: PPUSH
23609: CALL_OW 264
23613: PUSH
23614: LD_INT 22
23616: PUSH
23617: EMPTY
23618: LIST
23619: IN
23620: IFFALSE 23641
// points := [ 40 , 1 , 1 ] ;
23622: LD_ADDR_VAR 0 9
23626: PUSH
23627: LD_INT 40
23629: PUSH
23630: LD_INT 1
23632: PUSH
23633: LD_INT 1
23635: PUSH
23636: EMPTY
23637: LIST
23638: LIST
23639: LIST
23640: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23641: LD_VAR 0 6
23645: PPUSH
23646: CALL_OW 264
23650: PUSH
23651: LD_INT 29
23653: PUSH
23654: EMPTY
23655: LIST
23656: IN
23657: IFFALSE 23678
// points := [ 70 , 200 , 400 ] ;
23659: LD_ADDR_VAR 0 9
23663: PUSH
23664: LD_INT 70
23666: PUSH
23667: LD_INT 200
23669: PUSH
23670: LD_INT 400
23672: PUSH
23673: EMPTY
23674: LIST
23675: LIST
23676: LIST
23677: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23678: LD_VAR 0 6
23682: PPUSH
23683: CALL_OW 264
23687: PUSH
23688: LD_INT 14
23690: PUSH
23691: LD_INT 53
23693: PUSH
23694: EMPTY
23695: LIST
23696: LIST
23697: IN
23698: IFFALSE 23719
// points := [ 40 , 10 , 20 ] ;
23700: LD_ADDR_VAR 0 9
23704: PUSH
23705: LD_INT 40
23707: PUSH
23708: LD_INT 10
23710: PUSH
23711: LD_INT 20
23713: PUSH
23714: EMPTY
23715: LIST
23716: LIST
23717: LIST
23718: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23719: LD_VAR 0 6
23723: PPUSH
23724: CALL_OW 264
23728: PUSH
23729: LD_INT 9
23731: PUSH
23732: EMPTY
23733: LIST
23734: IN
23735: IFFALSE 23756
// points := [ 5 , 70 , 20 ] ;
23737: LD_ADDR_VAR 0 9
23741: PUSH
23742: LD_INT 5
23744: PUSH
23745: LD_INT 70
23747: PUSH
23748: LD_INT 20
23750: PUSH
23751: EMPTY
23752: LIST
23753: LIST
23754: LIST
23755: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23756: LD_VAR 0 6
23760: PPUSH
23761: CALL_OW 264
23765: PUSH
23766: LD_INT 10
23768: PUSH
23769: EMPTY
23770: LIST
23771: IN
23772: IFFALSE 23793
// points := [ 35 , 110 , 70 ] ;
23774: LD_ADDR_VAR 0 9
23778: PUSH
23779: LD_INT 35
23781: PUSH
23782: LD_INT 110
23784: PUSH
23785: LD_INT 70
23787: PUSH
23788: EMPTY
23789: LIST
23790: LIST
23791: LIST
23792: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23793: LD_VAR 0 6
23797: PPUSH
23798: CALL_OW 265
23802: PUSH
23803: LD_INT 25
23805: EQUAL
23806: IFFALSE 23827
// points := [ 80 , 65 , 100 ] ;
23808: LD_ADDR_VAR 0 9
23812: PUSH
23813: LD_INT 80
23815: PUSH
23816: LD_INT 65
23818: PUSH
23819: LD_INT 100
23821: PUSH
23822: EMPTY
23823: LIST
23824: LIST
23825: LIST
23826: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
23827: LD_VAR 0 6
23831: PPUSH
23832: CALL_OW 263
23836: PUSH
23837: LD_INT 1
23839: EQUAL
23840: IFFALSE 23875
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
23842: LD_ADDR_VAR 0 10
23846: PUSH
23847: LD_VAR 0 10
23851: PUSH
23852: LD_VAR 0 6
23856: PPUSH
23857: CALL_OW 311
23861: PPUSH
23862: LD_INT 3
23864: PPUSH
23865: CALL_OW 259
23869: PUSH
23870: LD_INT 4
23872: MUL
23873: MUL
23874: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
23875: LD_VAR 0 6
23879: PPUSH
23880: CALL_OW 263
23884: PUSH
23885: LD_INT 2
23887: EQUAL
23888: IFFALSE 23939
// begin j := IsControledBy ( i ) ;
23890: LD_ADDR_VAR 0 7
23894: PUSH
23895: LD_VAR 0 6
23899: PPUSH
23900: CALL_OW 312
23904: ST_TO_ADDR
// if j then
23905: LD_VAR 0 7
23909: IFFALSE 23939
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
23911: LD_ADDR_VAR 0 10
23915: PUSH
23916: LD_VAR 0 10
23920: PUSH
23921: LD_VAR 0 7
23925: PPUSH
23926: LD_INT 3
23928: PPUSH
23929: CALL_OW 259
23933: PUSH
23934: LD_INT 3
23936: MUL
23937: MUL
23938: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23939: LD_VAR 0 6
23943: PPUSH
23944: CALL_OW 264
23948: PUSH
23949: LD_INT 5
23951: PUSH
23952: LD_INT 6
23954: PUSH
23955: LD_INT 46
23957: PUSH
23958: LD_INT 44
23960: PUSH
23961: LD_INT 47
23963: PUSH
23964: LD_INT 45
23966: PUSH
23967: LD_INT 28
23969: PUSH
23970: LD_INT 7
23972: PUSH
23973: LD_INT 27
23975: PUSH
23976: LD_INT 29
23978: PUSH
23979: EMPTY
23980: LIST
23981: LIST
23982: LIST
23983: LIST
23984: LIST
23985: LIST
23986: LIST
23987: LIST
23988: LIST
23989: LIST
23990: IN
23991: PUSH
23992: LD_VAR 0 1
23996: PPUSH
23997: LD_INT 52
23999: PPUSH
24000: CALL_OW 321
24004: PUSH
24005: LD_INT 2
24007: EQUAL
24008: AND
24009: IFFALSE 24026
// bpoints := bpoints * 1.2 ;
24011: LD_ADDR_VAR 0 10
24015: PUSH
24016: LD_VAR 0 10
24020: PUSH
24021: LD_REAL  1.20000000000000E+0000
24024: MUL
24025: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
24026: LD_VAR 0 6
24030: PPUSH
24031: CALL_OW 264
24035: PUSH
24036: LD_INT 6
24038: PUSH
24039: LD_INT 46
24041: PUSH
24042: LD_INT 47
24044: PUSH
24045: EMPTY
24046: LIST
24047: LIST
24048: LIST
24049: IN
24050: IFFALSE 24067
// bpoints := bpoints * 1.2 ;
24052: LD_ADDR_VAR 0 10
24056: PUSH
24057: LD_VAR 0 10
24061: PUSH
24062: LD_REAL  1.20000000000000E+0000
24065: MUL
24066: ST_TO_ADDR
// end ; unit_building :
24067: GO 24081
24069: LD_INT 3
24071: DOUBLE
24072: EQUAL
24073: IFTRUE 24077
24075: GO 24080
24077: POP
// ; end ;
24078: GO 24081
24080: POP
// for j = 1 to 3 do
24081: LD_ADDR_VAR 0 7
24085: PUSH
24086: DOUBLE
24087: LD_INT 1
24089: DEC
24090: ST_TO_ADDR
24091: LD_INT 3
24093: PUSH
24094: FOR_TO
24095: IFFALSE 24148
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
24097: LD_ADDR_VAR 0 5
24101: PUSH
24102: LD_VAR 0 5
24106: PPUSH
24107: LD_VAR 0 7
24111: PPUSH
24112: LD_VAR 0 5
24116: PUSH
24117: LD_VAR 0 7
24121: ARRAY
24122: PUSH
24123: LD_VAR 0 9
24127: PUSH
24128: LD_VAR 0 7
24132: ARRAY
24133: PUSH
24134: LD_VAR 0 10
24138: MUL
24139: PLUS
24140: PPUSH
24141: CALL_OW 1
24145: ST_TO_ADDR
24146: GO 24094
24148: POP
24149: POP
// end ;
24150: GO 22633
24152: POP
24153: POP
// result := Replace ( result , 4 , tmp ) ;
24154: LD_ADDR_VAR 0 5
24158: PUSH
24159: LD_VAR 0 5
24163: PPUSH
24164: LD_INT 4
24166: PPUSH
24167: LD_VAR 0 8
24171: PPUSH
24172: CALL_OW 1
24176: ST_TO_ADDR
// end ;
24177: LD_VAR 0 5
24181: RET
// export function DangerAtRange ( unit , range ) ; begin
24182: LD_INT 0
24184: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
24185: LD_ADDR_VAR 0 3
24189: PUSH
24190: LD_VAR 0 1
24194: PPUSH
24195: CALL_OW 255
24199: PPUSH
24200: LD_VAR 0 1
24204: PPUSH
24205: CALL_OW 250
24209: PPUSH
24210: LD_VAR 0 1
24214: PPUSH
24215: CALL_OW 251
24219: PPUSH
24220: LD_VAR 0 2
24224: PPUSH
24225: CALL 22485 0 4
24229: ST_TO_ADDR
// end ;
24230: LD_VAR 0 3
24234: RET
// export function DangerInArea ( side , area ) ; begin
24235: LD_INT 0
24237: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
24238: LD_ADDR_VAR 0 3
24242: PUSH
24243: LD_VAR 0 2
24247: PPUSH
24248: LD_INT 81
24250: PUSH
24251: LD_VAR 0 1
24255: PUSH
24256: EMPTY
24257: LIST
24258: LIST
24259: PPUSH
24260: CALL_OW 70
24264: ST_TO_ADDR
// end ;
24265: LD_VAR 0 3
24269: RET
// export function IsExtension ( b ) ; begin
24270: LD_INT 0
24272: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
24273: LD_ADDR_VAR 0 2
24277: PUSH
24278: LD_VAR 0 1
24282: PUSH
24283: LD_INT 23
24285: PUSH
24286: LD_INT 20
24288: PUSH
24289: LD_INT 22
24291: PUSH
24292: LD_INT 17
24294: PUSH
24295: LD_INT 24
24297: PUSH
24298: LD_INT 21
24300: PUSH
24301: LD_INT 19
24303: PUSH
24304: LD_INT 16
24306: PUSH
24307: LD_INT 25
24309: PUSH
24310: LD_INT 18
24312: PUSH
24313: EMPTY
24314: LIST
24315: LIST
24316: LIST
24317: LIST
24318: LIST
24319: LIST
24320: LIST
24321: LIST
24322: LIST
24323: LIST
24324: IN
24325: ST_TO_ADDR
// end ;
24326: LD_VAR 0 2
24330: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
24331: LD_INT 0
24333: PPUSH
24334: PPUSH
24335: PPUSH
// result := [ ] ;
24336: LD_ADDR_VAR 0 3
24340: PUSH
24341: EMPTY
24342: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
24343: LD_ADDR_VAR 0 4
24347: PUSH
24348: LD_VAR 0 2
24352: PPUSH
24353: LD_INT 21
24355: PUSH
24356: LD_INT 3
24358: PUSH
24359: EMPTY
24360: LIST
24361: LIST
24362: PPUSH
24363: CALL_OW 70
24367: ST_TO_ADDR
// if not tmp then
24368: LD_VAR 0 4
24372: NOT
24373: IFFALSE 24377
// exit ;
24375: GO 24435
// for i in tmp do
24377: LD_ADDR_VAR 0 5
24381: PUSH
24382: LD_VAR 0 4
24386: PUSH
24387: FOR_IN
24388: IFFALSE 24423
// if GetBase ( i ) <> base then
24390: LD_VAR 0 5
24394: PPUSH
24395: CALL_OW 274
24399: PUSH
24400: LD_VAR 0 1
24404: NONEQUAL
24405: IFFALSE 24421
// ComLinkToBase ( base , i ) ;
24407: LD_VAR 0 1
24411: PPUSH
24412: LD_VAR 0 5
24416: PPUSH
24417: CALL_OW 169
24421: GO 24387
24423: POP
24424: POP
// result := tmp ;
24425: LD_ADDR_VAR 0 3
24429: PUSH
24430: LD_VAR 0 4
24434: ST_TO_ADDR
// end ;
24435: LD_VAR 0 3
24439: RET
// export function ComComplete ( unit , b ) ; var i ; begin
24440: LD_INT 0
24442: PPUSH
24443: PPUSH
// if BuildingStatus ( b ) = bs_build then
24444: LD_VAR 0 2
24448: PPUSH
24449: CALL_OW 461
24453: PUSH
24454: LD_INT 1
24456: EQUAL
24457: IFFALSE 24517
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24459: LD_VAR 0 1
24463: PPUSH
24464: LD_STRING h
24466: PUSH
24467: LD_VAR 0 2
24471: PPUSH
24472: CALL_OW 250
24476: PUSH
24477: LD_VAR 0 2
24481: PPUSH
24482: CALL_OW 251
24486: PUSH
24487: LD_VAR 0 2
24491: PUSH
24492: LD_INT 0
24494: PUSH
24495: LD_INT 0
24497: PUSH
24498: LD_INT 0
24500: PUSH
24501: EMPTY
24502: LIST
24503: LIST
24504: LIST
24505: LIST
24506: LIST
24507: LIST
24508: LIST
24509: PUSH
24510: EMPTY
24511: LIST
24512: PPUSH
24513: CALL_OW 446
// end ;
24517: LD_VAR 0 3
24521: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24522: LD_INT 0
24524: PPUSH
24525: PPUSH
24526: PPUSH
24527: PPUSH
24528: PPUSH
24529: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
24530: LD_VAR 0 1
24534: NOT
24535: PUSH
24536: LD_VAR 0 1
24540: PPUSH
24541: CALL_OW 263
24545: PUSH
24546: LD_INT 2
24548: EQUAL
24549: NOT
24550: OR
24551: IFFALSE 24555
// exit ;
24553: GO 24871
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24555: LD_ADDR_VAR 0 6
24559: PUSH
24560: LD_INT 22
24562: PUSH
24563: LD_VAR 0 1
24567: PPUSH
24568: CALL_OW 255
24572: PUSH
24573: EMPTY
24574: LIST
24575: LIST
24576: PUSH
24577: LD_INT 2
24579: PUSH
24580: LD_INT 30
24582: PUSH
24583: LD_INT 36
24585: PUSH
24586: EMPTY
24587: LIST
24588: LIST
24589: PUSH
24590: LD_INT 34
24592: PUSH
24593: LD_INT 31
24595: PUSH
24596: EMPTY
24597: LIST
24598: LIST
24599: PUSH
24600: EMPTY
24601: LIST
24602: LIST
24603: LIST
24604: PUSH
24605: EMPTY
24606: LIST
24607: LIST
24608: PPUSH
24609: CALL_OW 69
24613: ST_TO_ADDR
// if not tmp then
24614: LD_VAR 0 6
24618: NOT
24619: IFFALSE 24623
// exit ;
24621: GO 24871
// result := [ ] ;
24623: LD_ADDR_VAR 0 2
24627: PUSH
24628: EMPTY
24629: ST_TO_ADDR
// for i in tmp do
24630: LD_ADDR_VAR 0 3
24634: PUSH
24635: LD_VAR 0 6
24639: PUSH
24640: FOR_IN
24641: IFFALSE 24712
// begin t := UnitsInside ( i ) ;
24643: LD_ADDR_VAR 0 4
24647: PUSH
24648: LD_VAR 0 3
24652: PPUSH
24653: CALL_OW 313
24657: ST_TO_ADDR
// if t then
24658: LD_VAR 0 4
24662: IFFALSE 24710
// for j in t do
24664: LD_ADDR_VAR 0 7
24668: PUSH
24669: LD_VAR 0 4
24673: PUSH
24674: FOR_IN
24675: IFFALSE 24708
// result := Insert ( result , result + 1 , j ) ;
24677: LD_ADDR_VAR 0 2
24681: PUSH
24682: LD_VAR 0 2
24686: PPUSH
24687: LD_VAR 0 2
24691: PUSH
24692: LD_INT 1
24694: PLUS
24695: PPUSH
24696: LD_VAR 0 7
24700: PPUSH
24701: CALL_OW 2
24705: ST_TO_ADDR
24706: GO 24674
24708: POP
24709: POP
// end ;
24710: GO 24640
24712: POP
24713: POP
// if not result then
24714: LD_VAR 0 2
24718: NOT
24719: IFFALSE 24723
// exit ;
24721: GO 24871
// mech := result [ 1 ] ;
24723: LD_ADDR_VAR 0 5
24727: PUSH
24728: LD_VAR 0 2
24732: PUSH
24733: LD_INT 1
24735: ARRAY
24736: ST_TO_ADDR
// if result > 1 then
24737: LD_VAR 0 2
24741: PUSH
24742: LD_INT 1
24744: GREATER
24745: IFFALSE 24857
// for i = 2 to result do
24747: LD_ADDR_VAR 0 3
24751: PUSH
24752: DOUBLE
24753: LD_INT 2
24755: DEC
24756: ST_TO_ADDR
24757: LD_VAR 0 2
24761: PUSH
24762: FOR_TO
24763: IFFALSE 24855
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24765: LD_ADDR_VAR 0 4
24769: PUSH
24770: LD_VAR 0 2
24774: PUSH
24775: LD_VAR 0 3
24779: ARRAY
24780: PPUSH
24781: LD_INT 3
24783: PPUSH
24784: CALL_OW 259
24788: PUSH
24789: LD_VAR 0 2
24793: PUSH
24794: LD_VAR 0 3
24798: ARRAY
24799: PPUSH
24800: CALL_OW 432
24804: MINUS
24805: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
24806: LD_VAR 0 4
24810: PUSH
24811: LD_VAR 0 5
24815: PPUSH
24816: LD_INT 3
24818: PPUSH
24819: CALL_OW 259
24823: PUSH
24824: LD_VAR 0 5
24828: PPUSH
24829: CALL_OW 432
24833: MINUS
24834: GREATEREQUAL
24835: IFFALSE 24853
// mech := result [ i ] ;
24837: LD_ADDR_VAR 0 5
24841: PUSH
24842: LD_VAR 0 2
24846: PUSH
24847: LD_VAR 0 3
24851: ARRAY
24852: ST_TO_ADDR
// end ;
24853: GO 24762
24855: POP
24856: POP
// ComLinkTo ( vehicle , mech ) ;
24857: LD_VAR 0 1
24861: PPUSH
24862: LD_VAR 0 5
24866: PPUSH
24867: CALL_OW 135
// end ;
24871: LD_VAR 0 2
24875: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
24876: LD_INT 0
24878: PPUSH
24879: PPUSH
24880: PPUSH
24881: PPUSH
24882: PPUSH
24883: PPUSH
24884: PPUSH
24885: PPUSH
24886: PPUSH
24887: PPUSH
24888: PPUSH
24889: PPUSH
24890: PPUSH
// result := [ ] ;
24891: LD_ADDR_VAR 0 7
24895: PUSH
24896: EMPTY
24897: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
24898: LD_VAR 0 1
24902: PPUSH
24903: CALL_OW 266
24907: PUSH
24908: LD_INT 0
24910: PUSH
24911: LD_INT 1
24913: PUSH
24914: EMPTY
24915: LIST
24916: LIST
24917: IN
24918: NOT
24919: IFFALSE 24923
// exit ;
24921: GO 26554
// if name then
24923: LD_VAR 0 3
24927: IFFALSE 24943
// SetBName ( base_dep , name ) ;
24929: LD_VAR 0 1
24933: PPUSH
24934: LD_VAR 0 3
24938: PPUSH
24939: CALL_OW 500
// base := GetBase ( base_dep ) ;
24943: LD_ADDR_VAR 0 15
24947: PUSH
24948: LD_VAR 0 1
24952: PPUSH
24953: CALL_OW 274
24957: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24958: LD_ADDR_VAR 0 16
24962: PUSH
24963: LD_VAR 0 1
24967: PPUSH
24968: CALL_OW 255
24972: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24973: LD_ADDR_VAR 0 17
24977: PUSH
24978: LD_VAR 0 1
24982: PPUSH
24983: CALL_OW 248
24987: ST_TO_ADDR
// if sources then
24988: LD_VAR 0 5
24992: IFFALSE 25039
// for i = 1 to 3 do
24994: LD_ADDR_VAR 0 8
24998: PUSH
24999: DOUBLE
25000: LD_INT 1
25002: DEC
25003: ST_TO_ADDR
25004: LD_INT 3
25006: PUSH
25007: FOR_TO
25008: IFFALSE 25037
// AddResourceType ( base , i , sources [ i ] ) ;
25010: LD_VAR 0 15
25014: PPUSH
25015: LD_VAR 0 8
25019: PPUSH
25020: LD_VAR 0 5
25024: PUSH
25025: LD_VAR 0 8
25029: ARRAY
25030: PPUSH
25031: CALL_OW 276
25035: GO 25007
25037: POP
25038: POP
// buildings := GetBaseBuildings ( base , area ) ;
25039: LD_ADDR_VAR 0 18
25043: PUSH
25044: LD_VAR 0 15
25048: PPUSH
25049: LD_VAR 0 2
25053: PPUSH
25054: CALL 24331 0 2
25058: ST_TO_ADDR
// InitHc ;
25059: CALL_OW 19
// InitUc ;
25063: CALL_OW 18
// uc_side := side ;
25067: LD_ADDR_OWVAR 20
25071: PUSH
25072: LD_VAR 0 16
25076: ST_TO_ADDR
// uc_nation := nation ;
25077: LD_ADDR_OWVAR 21
25081: PUSH
25082: LD_VAR 0 17
25086: ST_TO_ADDR
// if buildings then
25087: LD_VAR 0 18
25091: IFFALSE 26413
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
25093: LD_ADDR_VAR 0 19
25097: PUSH
25098: LD_VAR 0 18
25102: PPUSH
25103: LD_INT 2
25105: PUSH
25106: LD_INT 30
25108: PUSH
25109: LD_INT 29
25111: PUSH
25112: EMPTY
25113: LIST
25114: LIST
25115: PUSH
25116: LD_INT 30
25118: PUSH
25119: LD_INT 30
25121: PUSH
25122: EMPTY
25123: LIST
25124: LIST
25125: PUSH
25126: EMPTY
25127: LIST
25128: LIST
25129: LIST
25130: PPUSH
25131: CALL_OW 72
25135: ST_TO_ADDR
// if tmp then
25136: LD_VAR 0 19
25140: IFFALSE 25188
// for i in tmp do
25142: LD_ADDR_VAR 0 8
25146: PUSH
25147: LD_VAR 0 19
25151: PUSH
25152: FOR_IN
25153: IFFALSE 25186
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
25155: LD_VAR 0 8
25159: PPUSH
25160: CALL_OW 250
25164: PPUSH
25165: LD_VAR 0 8
25169: PPUSH
25170: CALL_OW 251
25174: PPUSH
25175: LD_VAR 0 16
25179: PPUSH
25180: CALL_OW 441
25184: GO 25152
25186: POP
25187: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
25188: LD_VAR 0 18
25192: PPUSH
25193: LD_INT 2
25195: PUSH
25196: LD_INT 30
25198: PUSH
25199: LD_INT 32
25201: PUSH
25202: EMPTY
25203: LIST
25204: LIST
25205: PUSH
25206: LD_INT 30
25208: PUSH
25209: LD_INT 33
25211: PUSH
25212: EMPTY
25213: LIST
25214: LIST
25215: PUSH
25216: EMPTY
25217: LIST
25218: LIST
25219: LIST
25220: PPUSH
25221: CALL_OW 72
25225: IFFALSE 25313
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
25227: LD_ADDR_VAR 0 8
25231: PUSH
25232: LD_VAR 0 18
25236: PPUSH
25237: LD_INT 2
25239: PUSH
25240: LD_INT 30
25242: PUSH
25243: LD_INT 32
25245: PUSH
25246: EMPTY
25247: LIST
25248: LIST
25249: PUSH
25250: LD_INT 30
25252: PUSH
25253: LD_INT 33
25255: PUSH
25256: EMPTY
25257: LIST
25258: LIST
25259: PUSH
25260: EMPTY
25261: LIST
25262: LIST
25263: LIST
25264: PPUSH
25265: CALL_OW 72
25269: PUSH
25270: FOR_IN
25271: IFFALSE 25311
// begin if not GetBWeapon ( i ) then
25273: LD_VAR 0 8
25277: PPUSH
25278: CALL_OW 269
25282: NOT
25283: IFFALSE 25309
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
25285: LD_VAR 0 8
25289: PPUSH
25290: LD_VAR 0 8
25294: PPUSH
25295: LD_VAR 0 2
25299: PPUSH
25300: CALL 26559 0 2
25304: PPUSH
25305: CALL_OW 431
// end ;
25309: GO 25270
25311: POP
25312: POP
// end ; for i = 1 to personel do
25313: LD_ADDR_VAR 0 8
25317: PUSH
25318: DOUBLE
25319: LD_INT 1
25321: DEC
25322: ST_TO_ADDR
25323: LD_VAR 0 6
25327: PUSH
25328: FOR_TO
25329: IFFALSE 26393
// begin if i > 4 then
25331: LD_VAR 0 8
25335: PUSH
25336: LD_INT 4
25338: GREATER
25339: IFFALSE 25343
// break ;
25341: GO 26393
// case i of 1 :
25343: LD_VAR 0 8
25347: PUSH
25348: LD_INT 1
25350: DOUBLE
25351: EQUAL
25352: IFTRUE 25356
25354: GO 25436
25356: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
25357: LD_ADDR_VAR 0 12
25361: PUSH
25362: LD_VAR 0 18
25366: PPUSH
25367: LD_INT 22
25369: PUSH
25370: LD_VAR 0 16
25374: PUSH
25375: EMPTY
25376: LIST
25377: LIST
25378: PUSH
25379: LD_INT 58
25381: PUSH
25382: EMPTY
25383: LIST
25384: PUSH
25385: LD_INT 2
25387: PUSH
25388: LD_INT 30
25390: PUSH
25391: LD_INT 32
25393: PUSH
25394: EMPTY
25395: LIST
25396: LIST
25397: PUSH
25398: LD_INT 30
25400: PUSH
25401: LD_INT 4
25403: PUSH
25404: EMPTY
25405: LIST
25406: LIST
25407: PUSH
25408: LD_INT 30
25410: PUSH
25411: LD_INT 5
25413: PUSH
25414: EMPTY
25415: LIST
25416: LIST
25417: PUSH
25418: EMPTY
25419: LIST
25420: LIST
25421: LIST
25422: LIST
25423: PUSH
25424: EMPTY
25425: LIST
25426: LIST
25427: LIST
25428: PPUSH
25429: CALL_OW 72
25433: ST_TO_ADDR
25434: GO 25658
25436: LD_INT 2
25438: DOUBLE
25439: EQUAL
25440: IFTRUE 25444
25442: GO 25506
25444: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25445: LD_ADDR_VAR 0 12
25449: PUSH
25450: LD_VAR 0 18
25454: PPUSH
25455: LD_INT 22
25457: PUSH
25458: LD_VAR 0 16
25462: PUSH
25463: EMPTY
25464: LIST
25465: LIST
25466: PUSH
25467: LD_INT 2
25469: PUSH
25470: LD_INT 30
25472: PUSH
25473: LD_INT 0
25475: PUSH
25476: EMPTY
25477: LIST
25478: LIST
25479: PUSH
25480: LD_INT 30
25482: PUSH
25483: LD_INT 1
25485: PUSH
25486: EMPTY
25487: LIST
25488: LIST
25489: PUSH
25490: EMPTY
25491: LIST
25492: LIST
25493: LIST
25494: PUSH
25495: EMPTY
25496: LIST
25497: LIST
25498: PPUSH
25499: CALL_OW 72
25503: ST_TO_ADDR
25504: GO 25658
25506: LD_INT 3
25508: DOUBLE
25509: EQUAL
25510: IFTRUE 25514
25512: GO 25576
25514: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25515: LD_ADDR_VAR 0 12
25519: PUSH
25520: LD_VAR 0 18
25524: PPUSH
25525: LD_INT 22
25527: PUSH
25528: LD_VAR 0 16
25532: PUSH
25533: EMPTY
25534: LIST
25535: LIST
25536: PUSH
25537: LD_INT 2
25539: PUSH
25540: LD_INT 30
25542: PUSH
25543: LD_INT 2
25545: PUSH
25546: EMPTY
25547: LIST
25548: LIST
25549: PUSH
25550: LD_INT 30
25552: PUSH
25553: LD_INT 3
25555: PUSH
25556: EMPTY
25557: LIST
25558: LIST
25559: PUSH
25560: EMPTY
25561: LIST
25562: LIST
25563: LIST
25564: PUSH
25565: EMPTY
25566: LIST
25567: LIST
25568: PPUSH
25569: CALL_OW 72
25573: ST_TO_ADDR
25574: GO 25658
25576: LD_INT 4
25578: DOUBLE
25579: EQUAL
25580: IFTRUE 25584
25582: GO 25657
25584: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25585: LD_ADDR_VAR 0 12
25589: PUSH
25590: LD_VAR 0 18
25594: PPUSH
25595: LD_INT 22
25597: PUSH
25598: LD_VAR 0 16
25602: PUSH
25603: EMPTY
25604: LIST
25605: LIST
25606: PUSH
25607: LD_INT 2
25609: PUSH
25610: LD_INT 30
25612: PUSH
25613: LD_INT 6
25615: PUSH
25616: EMPTY
25617: LIST
25618: LIST
25619: PUSH
25620: LD_INT 30
25622: PUSH
25623: LD_INT 7
25625: PUSH
25626: EMPTY
25627: LIST
25628: LIST
25629: PUSH
25630: LD_INT 30
25632: PUSH
25633: LD_INT 8
25635: PUSH
25636: EMPTY
25637: LIST
25638: LIST
25639: PUSH
25640: EMPTY
25641: LIST
25642: LIST
25643: LIST
25644: LIST
25645: PUSH
25646: EMPTY
25647: LIST
25648: LIST
25649: PPUSH
25650: CALL_OW 72
25654: ST_TO_ADDR
25655: GO 25658
25657: POP
// if i = 1 then
25658: LD_VAR 0 8
25662: PUSH
25663: LD_INT 1
25665: EQUAL
25666: IFFALSE 25777
// begin tmp := [ ] ;
25668: LD_ADDR_VAR 0 19
25672: PUSH
25673: EMPTY
25674: ST_TO_ADDR
// for j in f do
25675: LD_ADDR_VAR 0 9
25679: PUSH
25680: LD_VAR 0 12
25684: PUSH
25685: FOR_IN
25686: IFFALSE 25759
// if GetBType ( j ) = b_bunker then
25688: LD_VAR 0 9
25692: PPUSH
25693: CALL_OW 266
25697: PUSH
25698: LD_INT 32
25700: EQUAL
25701: IFFALSE 25728
// tmp := Insert ( tmp , 1 , j ) else
25703: LD_ADDR_VAR 0 19
25707: PUSH
25708: LD_VAR 0 19
25712: PPUSH
25713: LD_INT 1
25715: PPUSH
25716: LD_VAR 0 9
25720: PPUSH
25721: CALL_OW 2
25725: ST_TO_ADDR
25726: GO 25757
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25728: LD_ADDR_VAR 0 19
25732: PUSH
25733: LD_VAR 0 19
25737: PPUSH
25738: LD_VAR 0 19
25742: PUSH
25743: LD_INT 1
25745: PLUS
25746: PPUSH
25747: LD_VAR 0 9
25751: PPUSH
25752: CALL_OW 2
25756: ST_TO_ADDR
25757: GO 25685
25759: POP
25760: POP
// if tmp then
25761: LD_VAR 0 19
25765: IFFALSE 25777
// f := tmp ;
25767: LD_ADDR_VAR 0 12
25771: PUSH
25772: LD_VAR 0 19
25776: ST_TO_ADDR
// end ; x := personel [ i ] ;
25777: LD_ADDR_VAR 0 13
25781: PUSH
25782: LD_VAR 0 6
25786: PUSH
25787: LD_VAR 0 8
25791: ARRAY
25792: ST_TO_ADDR
// if x = - 1 then
25793: LD_VAR 0 13
25797: PUSH
25798: LD_INT 1
25800: NEG
25801: EQUAL
25802: IFFALSE 26011
// begin for j in f do
25804: LD_ADDR_VAR 0 9
25808: PUSH
25809: LD_VAR 0 12
25813: PUSH
25814: FOR_IN
25815: IFFALSE 26007
// repeat InitHc ;
25817: CALL_OW 19
// if GetBType ( j ) = b_barracks then
25821: LD_VAR 0 9
25825: PPUSH
25826: CALL_OW 266
25830: PUSH
25831: LD_INT 5
25833: EQUAL
25834: IFFALSE 25904
// begin if UnitsInside ( j ) < 3 then
25836: LD_VAR 0 9
25840: PPUSH
25841: CALL_OW 313
25845: PUSH
25846: LD_INT 3
25848: LESS
25849: IFFALSE 25885
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25851: LD_INT 0
25853: PPUSH
25854: LD_INT 5
25856: PUSH
25857: LD_INT 8
25859: PUSH
25860: LD_INT 9
25862: PUSH
25863: EMPTY
25864: LIST
25865: LIST
25866: LIST
25867: PUSH
25868: LD_VAR 0 17
25872: ARRAY
25873: PPUSH
25874: LD_VAR 0 4
25878: PPUSH
25879: CALL_OW 380
25883: GO 25902
// PrepareHuman ( false , i , skill ) ;
25885: LD_INT 0
25887: PPUSH
25888: LD_VAR 0 8
25892: PPUSH
25893: LD_VAR 0 4
25897: PPUSH
25898: CALL_OW 380
// end else
25902: GO 25921
// PrepareHuman ( false , i , skill ) ;
25904: LD_INT 0
25906: PPUSH
25907: LD_VAR 0 8
25911: PPUSH
25912: LD_VAR 0 4
25916: PPUSH
25917: CALL_OW 380
// un := CreateHuman ;
25921: LD_ADDR_VAR 0 14
25925: PUSH
25926: CALL_OW 44
25930: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25931: LD_ADDR_VAR 0 7
25935: PUSH
25936: LD_VAR 0 7
25940: PPUSH
25941: LD_INT 1
25943: PPUSH
25944: LD_VAR 0 14
25948: PPUSH
25949: CALL_OW 2
25953: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25954: LD_VAR 0 14
25958: PPUSH
25959: LD_VAR 0 9
25963: PPUSH
25964: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25968: LD_VAR 0 9
25972: PPUSH
25973: CALL_OW 313
25977: PUSH
25978: LD_INT 6
25980: EQUAL
25981: PUSH
25982: LD_VAR 0 9
25986: PPUSH
25987: CALL_OW 266
25991: PUSH
25992: LD_INT 32
25994: PUSH
25995: LD_INT 31
25997: PUSH
25998: EMPTY
25999: LIST
26000: LIST
26001: IN
26002: OR
26003: IFFALSE 25817
26005: GO 25814
26007: POP
26008: POP
// end else
26009: GO 26391
// for j = 1 to x do
26011: LD_ADDR_VAR 0 9
26015: PUSH
26016: DOUBLE
26017: LD_INT 1
26019: DEC
26020: ST_TO_ADDR
26021: LD_VAR 0 13
26025: PUSH
26026: FOR_TO
26027: IFFALSE 26389
// begin InitHc ;
26029: CALL_OW 19
// if not f then
26033: LD_VAR 0 12
26037: NOT
26038: IFFALSE 26127
// begin PrepareHuman ( false , i , skill ) ;
26040: LD_INT 0
26042: PPUSH
26043: LD_VAR 0 8
26047: PPUSH
26048: LD_VAR 0 4
26052: PPUSH
26053: CALL_OW 380
// un := CreateHuman ;
26057: LD_ADDR_VAR 0 14
26061: PUSH
26062: CALL_OW 44
26066: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26067: LD_ADDR_VAR 0 7
26071: PUSH
26072: LD_VAR 0 7
26076: PPUSH
26077: LD_INT 1
26079: PPUSH
26080: LD_VAR 0 14
26084: PPUSH
26085: CALL_OW 2
26089: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26090: LD_VAR 0 14
26094: PPUSH
26095: LD_VAR 0 1
26099: PPUSH
26100: CALL_OW 250
26104: PPUSH
26105: LD_VAR 0 1
26109: PPUSH
26110: CALL_OW 251
26114: PPUSH
26115: LD_INT 10
26117: PPUSH
26118: LD_INT 0
26120: PPUSH
26121: CALL_OW 50
// continue ;
26125: GO 26026
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
26127: LD_VAR 0 12
26131: PUSH
26132: LD_INT 1
26134: ARRAY
26135: PPUSH
26136: CALL_OW 313
26140: PUSH
26141: LD_VAR 0 12
26145: PUSH
26146: LD_INT 1
26148: ARRAY
26149: PPUSH
26150: CALL_OW 266
26154: PUSH
26155: LD_INT 32
26157: PUSH
26158: LD_INT 31
26160: PUSH
26161: EMPTY
26162: LIST
26163: LIST
26164: IN
26165: AND
26166: PUSH
26167: LD_VAR 0 12
26171: PUSH
26172: LD_INT 1
26174: ARRAY
26175: PPUSH
26176: CALL_OW 313
26180: PUSH
26181: LD_INT 6
26183: EQUAL
26184: OR
26185: IFFALSE 26205
// f := Delete ( f , 1 ) ;
26187: LD_ADDR_VAR 0 12
26191: PUSH
26192: LD_VAR 0 12
26196: PPUSH
26197: LD_INT 1
26199: PPUSH
26200: CALL_OW 3
26204: ST_TO_ADDR
// if not f then
26205: LD_VAR 0 12
26209: NOT
26210: IFFALSE 26228
// begin x := x + 2 ;
26212: LD_ADDR_VAR 0 13
26216: PUSH
26217: LD_VAR 0 13
26221: PUSH
26222: LD_INT 2
26224: PLUS
26225: ST_TO_ADDR
// continue ;
26226: GO 26026
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
26228: LD_VAR 0 12
26232: PUSH
26233: LD_INT 1
26235: ARRAY
26236: PPUSH
26237: CALL_OW 266
26241: PUSH
26242: LD_INT 5
26244: EQUAL
26245: IFFALSE 26319
// begin if UnitsInside ( f [ 1 ] ) < 3 then
26247: LD_VAR 0 12
26251: PUSH
26252: LD_INT 1
26254: ARRAY
26255: PPUSH
26256: CALL_OW 313
26260: PUSH
26261: LD_INT 3
26263: LESS
26264: IFFALSE 26300
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26266: LD_INT 0
26268: PPUSH
26269: LD_INT 5
26271: PUSH
26272: LD_INT 8
26274: PUSH
26275: LD_INT 9
26277: PUSH
26278: EMPTY
26279: LIST
26280: LIST
26281: LIST
26282: PUSH
26283: LD_VAR 0 17
26287: ARRAY
26288: PPUSH
26289: LD_VAR 0 4
26293: PPUSH
26294: CALL_OW 380
26298: GO 26317
// PrepareHuman ( false , i , skill ) ;
26300: LD_INT 0
26302: PPUSH
26303: LD_VAR 0 8
26307: PPUSH
26308: LD_VAR 0 4
26312: PPUSH
26313: CALL_OW 380
// end else
26317: GO 26336
// PrepareHuman ( false , i , skill ) ;
26319: LD_INT 0
26321: PPUSH
26322: LD_VAR 0 8
26326: PPUSH
26327: LD_VAR 0 4
26331: PPUSH
26332: CALL_OW 380
// un := CreateHuman ;
26336: LD_ADDR_VAR 0 14
26340: PUSH
26341: CALL_OW 44
26345: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26346: LD_ADDR_VAR 0 7
26350: PUSH
26351: LD_VAR 0 7
26355: PPUSH
26356: LD_INT 1
26358: PPUSH
26359: LD_VAR 0 14
26363: PPUSH
26364: CALL_OW 2
26368: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
26369: LD_VAR 0 14
26373: PPUSH
26374: LD_VAR 0 12
26378: PUSH
26379: LD_INT 1
26381: ARRAY
26382: PPUSH
26383: CALL_OW 52
// end ;
26387: GO 26026
26389: POP
26390: POP
// end ;
26391: GO 25328
26393: POP
26394: POP
// result := result ^ buildings ;
26395: LD_ADDR_VAR 0 7
26399: PUSH
26400: LD_VAR 0 7
26404: PUSH
26405: LD_VAR 0 18
26409: ADD
26410: ST_TO_ADDR
// end else
26411: GO 26554
// begin for i = 1 to personel do
26413: LD_ADDR_VAR 0 8
26417: PUSH
26418: DOUBLE
26419: LD_INT 1
26421: DEC
26422: ST_TO_ADDR
26423: LD_VAR 0 6
26427: PUSH
26428: FOR_TO
26429: IFFALSE 26552
// begin if i > 4 then
26431: LD_VAR 0 8
26435: PUSH
26436: LD_INT 4
26438: GREATER
26439: IFFALSE 26443
// break ;
26441: GO 26552
// x := personel [ i ] ;
26443: LD_ADDR_VAR 0 13
26447: PUSH
26448: LD_VAR 0 6
26452: PUSH
26453: LD_VAR 0 8
26457: ARRAY
26458: ST_TO_ADDR
// if x = - 1 then
26459: LD_VAR 0 13
26463: PUSH
26464: LD_INT 1
26466: NEG
26467: EQUAL
26468: IFFALSE 26472
// continue ;
26470: GO 26428
// PrepareHuman ( false , i , skill ) ;
26472: LD_INT 0
26474: PPUSH
26475: LD_VAR 0 8
26479: PPUSH
26480: LD_VAR 0 4
26484: PPUSH
26485: CALL_OW 380
// un := CreateHuman ;
26489: LD_ADDR_VAR 0 14
26493: PUSH
26494: CALL_OW 44
26498: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26499: LD_VAR 0 14
26503: PPUSH
26504: LD_VAR 0 1
26508: PPUSH
26509: CALL_OW 250
26513: PPUSH
26514: LD_VAR 0 1
26518: PPUSH
26519: CALL_OW 251
26523: PPUSH
26524: LD_INT 10
26526: PPUSH
26527: LD_INT 0
26529: PPUSH
26530: CALL_OW 50
// result := result ^ un ;
26534: LD_ADDR_VAR 0 7
26538: PUSH
26539: LD_VAR 0 7
26543: PUSH
26544: LD_VAR 0 14
26548: ADD
26549: ST_TO_ADDR
// end ;
26550: GO 26428
26552: POP
26553: POP
// end ; end ;
26554: LD_VAR 0 7
26558: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26559: LD_INT 0
26561: PPUSH
26562: PPUSH
26563: PPUSH
26564: PPUSH
26565: PPUSH
26566: PPUSH
26567: PPUSH
26568: PPUSH
26569: PPUSH
26570: PPUSH
26571: PPUSH
26572: PPUSH
26573: PPUSH
26574: PPUSH
26575: PPUSH
26576: PPUSH
// result := false ;
26577: LD_ADDR_VAR 0 3
26581: PUSH
26582: LD_INT 0
26584: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26585: LD_VAR 0 1
26589: NOT
26590: PUSH
26591: LD_VAR 0 1
26595: PPUSH
26596: CALL_OW 266
26600: PUSH
26601: LD_INT 32
26603: PUSH
26604: LD_INT 33
26606: PUSH
26607: EMPTY
26608: LIST
26609: LIST
26610: IN
26611: NOT
26612: OR
26613: IFFALSE 26617
// exit ;
26615: GO 27753
// nat := GetNation ( tower ) ;
26617: LD_ADDR_VAR 0 12
26621: PUSH
26622: LD_VAR 0 1
26626: PPUSH
26627: CALL_OW 248
26631: ST_TO_ADDR
// side := GetSide ( tower ) ;
26632: LD_ADDR_VAR 0 16
26636: PUSH
26637: LD_VAR 0 1
26641: PPUSH
26642: CALL_OW 255
26646: ST_TO_ADDR
// x := GetX ( tower ) ;
26647: LD_ADDR_VAR 0 10
26651: PUSH
26652: LD_VAR 0 1
26656: PPUSH
26657: CALL_OW 250
26661: ST_TO_ADDR
// y := GetY ( tower ) ;
26662: LD_ADDR_VAR 0 11
26666: PUSH
26667: LD_VAR 0 1
26671: PPUSH
26672: CALL_OW 251
26676: ST_TO_ADDR
// if not x or not y then
26677: LD_VAR 0 10
26681: NOT
26682: PUSH
26683: LD_VAR 0 11
26687: NOT
26688: OR
26689: IFFALSE 26693
// exit ;
26691: GO 27753
// weapon := 0 ;
26693: LD_ADDR_VAR 0 18
26697: PUSH
26698: LD_INT 0
26700: ST_TO_ADDR
// fac_list := [ ] ;
26701: LD_ADDR_VAR 0 17
26705: PUSH
26706: EMPTY
26707: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
26708: LD_ADDR_VAR 0 6
26712: PUSH
26713: LD_VAR 0 1
26717: PPUSH
26718: CALL_OW 274
26722: PPUSH
26723: LD_VAR 0 2
26727: PPUSH
26728: CALL 24331 0 2
26732: PPUSH
26733: LD_INT 30
26735: PUSH
26736: LD_INT 3
26738: PUSH
26739: EMPTY
26740: LIST
26741: LIST
26742: PPUSH
26743: CALL_OW 72
26747: ST_TO_ADDR
// if not factories then
26748: LD_VAR 0 6
26752: NOT
26753: IFFALSE 26757
// exit ;
26755: GO 27753
// for i in factories do
26757: LD_ADDR_VAR 0 8
26761: PUSH
26762: LD_VAR 0 6
26766: PUSH
26767: FOR_IN
26768: IFFALSE 26793
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26770: LD_ADDR_VAR 0 17
26774: PUSH
26775: LD_VAR 0 17
26779: PUSH
26780: LD_VAR 0 8
26784: PPUSH
26785: CALL_OW 478
26789: UNION
26790: ST_TO_ADDR
26791: GO 26767
26793: POP
26794: POP
// if not fac_list then
26795: LD_VAR 0 17
26799: NOT
26800: IFFALSE 26804
// exit ;
26802: GO 27753
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
26804: LD_ADDR_VAR 0 5
26808: PUSH
26809: LD_INT 4
26811: PUSH
26812: LD_INT 5
26814: PUSH
26815: LD_INT 9
26817: PUSH
26818: LD_INT 10
26820: PUSH
26821: LD_INT 6
26823: PUSH
26824: LD_INT 7
26826: PUSH
26827: LD_INT 11
26829: PUSH
26830: EMPTY
26831: LIST
26832: LIST
26833: LIST
26834: LIST
26835: LIST
26836: LIST
26837: LIST
26838: PUSH
26839: LD_INT 27
26841: PUSH
26842: LD_INT 28
26844: PUSH
26845: LD_INT 26
26847: PUSH
26848: LD_INT 30
26850: PUSH
26851: EMPTY
26852: LIST
26853: LIST
26854: LIST
26855: LIST
26856: PUSH
26857: LD_INT 43
26859: PUSH
26860: LD_INT 44
26862: PUSH
26863: LD_INT 46
26865: PUSH
26866: LD_INT 45
26868: PUSH
26869: LD_INT 47
26871: PUSH
26872: LD_INT 49
26874: PUSH
26875: EMPTY
26876: LIST
26877: LIST
26878: LIST
26879: LIST
26880: LIST
26881: LIST
26882: PUSH
26883: EMPTY
26884: LIST
26885: LIST
26886: LIST
26887: PUSH
26888: LD_VAR 0 12
26892: ARRAY
26893: ST_TO_ADDR
// for i in list do
26894: LD_ADDR_VAR 0 8
26898: PUSH
26899: LD_VAR 0 5
26903: PUSH
26904: FOR_IN
26905: IFFALSE 26938
// if not i in fac_list then
26907: LD_VAR 0 8
26911: PUSH
26912: LD_VAR 0 17
26916: IN
26917: NOT
26918: IFFALSE 26936
// list := list diff i ;
26920: LD_ADDR_VAR 0 5
26924: PUSH
26925: LD_VAR 0 5
26929: PUSH
26930: LD_VAR 0 8
26934: DIFF
26935: ST_TO_ADDR
26936: GO 26904
26938: POP
26939: POP
// if not list then
26940: LD_VAR 0 5
26944: NOT
26945: IFFALSE 26949
// exit ;
26947: GO 27753
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26949: LD_VAR 0 12
26953: PUSH
26954: LD_INT 3
26956: EQUAL
26957: PUSH
26958: LD_INT 49
26960: PUSH
26961: LD_VAR 0 5
26965: IN
26966: AND
26967: PUSH
26968: LD_INT 31
26970: PPUSH
26971: LD_VAR 0 16
26975: PPUSH
26976: CALL_OW 321
26980: PUSH
26981: LD_INT 2
26983: EQUAL
26984: AND
26985: IFFALSE 27045
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26987: LD_INT 22
26989: PUSH
26990: LD_VAR 0 16
26994: PUSH
26995: EMPTY
26996: LIST
26997: LIST
26998: PUSH
26999: LD_INT 35
27001: PUSH
27002: LD_INT 49
27004: PUSH
27005: EMPTY
27006: LIST
27007: LIST
27008: PUSH
27009: LD_INT 91
27011: PUSH
27012: LD_VAR 0 1
27016: PUSH
27017: LD_INT 10
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: LIST
27024: PUSH
27025: EMPTY
27026: LIST
27027: LIST
27028: LIST
27029: PPUSH
27030: CALL_OW 69
27034: NOT
27035: IFFALSE 27045
// weapon := ru_time_lapser ;
27037: LD_ADDR_VAR 0 18
27041: PUSH
27042: LD_INT 49
27044: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
27045: LD_VAR 0 12
27049: PUSH
27050: LD_INT 1
27052: PUSH
27053: LD_INT 2
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: IN
27060: PUSH
27061: LD_INT 11
27063: PUSH
27064: LD_VAR 0 5
27068: IN
27069: PUSH
27070: LD_INT 30
27072: PUSH
27073: LD_VAR 0 5
27077: IN
27078: OR
27079: AND
27080: PUSH
27081: LD_INT 6
27083: PPUSH
27084: LD_VAR 0 16
27088: PPUSH
27089: CALL_OW 321
27093: PUSH
27094: LD_INT 2
27096: EQUAL
27097: AND
27098: IFFALSE 27263
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
27100: LD_INT 22
27102: PUSH
27103: LD_VAR 0 16
27107: PUSH
27108: EMPTY
27109: LIST
27110: LIST
27111: PUSH
27112: LD_INT 2
27114: PUSH
27115: LD_INT 35
27117: PUSH
27118: LD_INT 11
27120: PUSH
27121: EMPTY
27122: LIST
27123: LIST
27124: PUSH
27125: LD_INT 35
27127: PUSH
27128: LD_INT 30
27130: PUSH
27131: EMPTY
27132: LIST
27133: LIST
27134: PUSH
27135: EMPTY
27136: LIST
27137: LIST
27138: LIST
27139: PUSH
27140: LD_INT 91
27142: PUSH
27143: LD_VAR 0 1
27147: PUSH
27148: LD_INT 18
27150: PUSH
27151: EMPTY
27152: LIST
27153: LIST
27154: LIST
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: LIST
27160: PPUSH
27161: CALL_OW 69
27165: NOT
27166: PUSH
27167: LD_INT 22
27169: PUSH
27170: LD_VAR 0 16
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: PUSH
27179: LD_INT 2
27181: PUSH
27182: LD_INT 30
27184: PUSH
27185: LD_INT 32
27187: PUSH
27188: EMPTY
27189: LIST
27190: LIST
27191: PUSH
27192: LD_INT 30
27194: PUSH
27195: LD_INT 33
27197: PUSH
27198: EMPTY
27199: LIST
27200: LIST
27201: PUSH
27202: EMPTY
27203: LIST
27204: LIST
27205: LIST
27206: PUSH
27207: LD_INT 91
27209: PUSH
27210: LD_VAR 0 1
27214: PUSH
27215: LD_INT 12
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: LIST
27222: PUSH
27223: EMPTY
27224: LIST
27225: LIST
27226: LIST
27227: PUSH
27228: EMPTY
27229: LIST
27230: PPUSH
27231: CALL_OW 69
27235: PUSH
27236: LD_INT 2
27238: GREATER
27239: AND
27240: IFFALSE 27263
// weapon := [ us_radar , ar_radar ] [ nat ] ;
27242: LD_ADDR_VAR 0 18
27246: PUSH
27247: LD_INT 11
27249: PUSH
27250: LD_INT 30
27252: PUSH
27253: EMPTY
27254: LIST
27255: LIST
27256: PUSH
27257: LD_VAR 0 12
27261: ARRAY
27262: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
27263: LD_VAR 0 18
27267: NOT
27268: PUSH
27269: LD_INT 40
27271: PPUSH
27272: LD_VAR 0 16
27276: PPUSH
27277: CALL_OW 321
27281: PUSH
27282: LD_INT 2
27284: EQUAL
27285: AND
27286: PUSH
27287: LD_INT 7
27289: PUSH
27290: LD_VAR 0 5
27294: IN
27295: PUSH
27296: LD_INT 28
27298: PUSH
27299: LD_VAR 0 5
27303: IN
27304: OR
27305: PUSH
27306: LD_INT 45
27308: PUSH
27309: LD_VAR 0 5
27313: IN
27314: OR
27315: AND
27316: IFFALSE 27570
// begin hex := GetHexInfo ( x , y ) ;
27318: LD_ADDR_VAR 0 4
27322: PUSH
27323: LD_VAR 0 10
27327: PPUSH
27328: LD_VAR 0 11
27332: PPUSH
27333: CALL_OW 546
27337: ST_TO_ADDR
// if hex [ 1 ] then
27338: LD_VAR 0 4
27342: PUSH
27343: LD_INT 1
27345: ARRAY
27346: IFFALSE 27350
// exit ;
27348: GO 27753
// height := hex [ 2 ] ;
27350: LD_ADDR_VAR 0 15
27354: PUSH
27355: LD_VAR 0 4
27359: PUSH
27360: LD_INT 2
27362: ARRAY
27363: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
27364: LD_ADDR_VAR 0 14
27368: PUSH
27369: LD_INT 0
27371: PUSH
27372: LD_INT 2
27374: PUSH
27375: LD_INT 3
27377: PUSH
27378: LD_INT 5
27380: PUSH
27381: EMPTY
27382: LIST
27383: LIST
27384: LIST
27385: LIST
27386: ST_TO_ADDR
// for i in tmp do
27387: LD_ADDR_VAR 0 8
27391: PUSH
27392: LD_VAR 0 14
27396: PUSH
27397: FOR_IN
27398: IFFALSE 27568
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
27400: LD_ADDR_VAR 0 9
27404: PUSH
27405: LD_VAR 0 10
27409: PPUSH
27410: LD_VAR 0 8
27414: PPUSH
27415: LD_INT 5
27417: PPUSH
27418: CALL_OW 272
27422: PUSH
27423: LD_VAR 0 11
27427: PPUSH
27428: LD_VAR 0 8
27432: PPUSH
27433: LD_INT 5
27435: PPUSH
27436: CALL_OW 273
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27445: LD_VAR 0 9
27449: PUSH
27450: LD_INT 1
27452: ARRAY
27453: PPUSH
27454: LD_VAR 0 9
27458: PUSH
27459: LD_INT 2
27461: ARRAY
27462: PPUSH
27463: CALL_OW 488
27467: IFFALSE 27566
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27469: LD_ADDR_VAR 0 4
27473: PUSH
27474: LD_VAR 0 9
27478: PUSH
27479: LD_INT 1
27481: ARRAY
27482: PPUSH
27483: LD_VAR 0 9
27487: PUSH
27488: LD_INT 2
27490: ARRAY
27491: PPUSH
27492: CALL_OW 546
27496: ST_TO_ADDR
// if hex [ 1 ] then
27497: LD_VAR 0 4
27501: PUSH
27502: LD_INT 1
27504: ARRAY
27505: IFFALSE 27509
// continue ;
27507: GO 27397
// h := hex [ 2 ] ;
27509: LD_ADDR_VAR 0 13
27513: PUSH
27514: LD_VAR 0 4
27518: PUSH
27519: LD_INT 2
27521: ARRAY
27522: ST_TO_ADDR
// if h + 7 < height then
27523: LD_VAR 0 13
27527: PUSH
27528: LD_INT 7
27530: PLUS
27531: PUSH
27532: LD_VAR 0 15
27536: LESS
27537: IFFALSE 27566
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27539: LD_ADDR_VAR 0 18
27543: PUSH
27544: LD_INT 7
27546: PUSH
27547: LD_INT 28
27549: PUSH
27550: LD_INT 45
27552: PUSH
27553: EMPTY
27554: LIST
27555: LIST
27556: LIST
27557: PUSH
27558: LD_VAR 0 12
27562: ARRAY
27563: ST_TO_ADDR
// break ;
27564: GO 27568
// end ; end ; end ;
27566: GO 27397
27568: POP
27569: POP
// end ; if not weapon then
27570: LD_VAR 0 18
27574: NOT
27575: IFFALSE 27635
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27577: LD_ADDR_VAR 0 5
27581: PUSH
27582: LD_VAR 0 5
27586: PUSH
27587: LD_INT 11
27589: PUSH
27590: LD_INT 30
27592: PUSH
27593: LD_INT 49
27595: PUSH
27596: EMPTY
27597: LIST
27598: LIST
27599: LIST
27600: DIFF
27601: ST_TO_ADDR
// if not list then
27602: LD_VAR 0 5
27606: NOT
27607: IFFALSE 27611
// exit ;
27609: GO 27753
// weapon := list [ rand ( 1 , list ) ] ;
27611: LD_ADDR_VAR 0 18
27615: PUSH
27616: LD_VAR 0 5
27620: PUSH
27621: LD_INT 1
27623: PPUSH
27624: LD_VAR 0 5
27628: PPUSH
27629: CALL_OW 12
27633: ARRAY
27634: ST_TO_ADDR
// end ; if weapon then
27635: LD_VAR 0 18
27639: IFFALSE 27753
// begin tmp := CostOfWeapon ( weapon ) ;
27641: LD_ADDR_VAR 0 14
27645: PUSH
27646: LD_VAR 0 18
27650: PPUSH
27651: CALL_OW 451
27655: ST_TO_ADDR
// j := GetBase ( tower ) ;
27656: LD_ADDR_VAR 0 9
27660: PUSH
27661: LD_VAR 0 1
27665: PPUSH
27666: CALL_OW 274
27670: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27671: LD_VAR 0 9
27675: PPUSH
27676: LD_INT 1
27678: PPUSH
27679: CALL_OW 275
27683: PUSH
27684: LD_VAR 0 14
27688: PUSH
27689: LD_INT 1
27691: ARRAY
27692: GREATEREQUAL
27693: PUSH
27694: LD_VAR 0 9
27698: PPUSH
27699: LD_INT 2
27701: PPUSH
27702: CALL_OW 275
27706: PUSH
27707: LD_VAR 0 14
27711: PUSH
27712: LD_INT 2
27714: ARRAY
27715: GREATEREQUAL
27716: AND
27717: PUSH
27718: LD_VAR 0 9
27722: PPUSH
27723: LD_INT 3
27725: PPUSH
27726: CALL_OW 275
27730: PUSH
27731: LD_VAR 0 14
27735: PUSH
27736: LD_INT 3
27738: ARRAY
27739: GREATEREQUAL
27740: AND
27741: IFFALSE 27753
// result := weapon ;
27743: LD_ADDR_VAR 0 3
27747: PUSH
27748: LD_VAR 0 18
27752: ST_TO_ADDR
// end ; end ;
27753: LD_VAR 0 3
27757: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27758: LD_INT 0
27760: PPUSH
27761: PPUSH
// result := true ;
27762: LD_ADDR_VAR 0 3
27766: PUSH
27767: LD_INT 1
27769: ST_TO_ADDR
// if array1 = array2 then
27770: LD_VAR 0 1
27774: PUSH
27775: LD_VAR 0 2
27779: EQUAL
27780: IFFALSE 27840
// begin for i = 1 to array1 do
27782: LD_ADDR_VAR 0 4
27786: PUSH
27787: DOUBLE
27788: LD_INT 1
27790: DEC
27791: ST_TO_ADDR
27792: LD_VAR 0 1
27796: PUSH
27797: FOR_TO
27798: IFFALSE 27836
// if array1 [ i ] <> array2 [ i ] then
27800: LD_VAR 0 1
27804: PUSH
27805: LD_VAR 0 4
27809: ARRAY
27810: PUSH
27811: LD_VAR 0 2
27815: PUSH
27816: LD_VAR 0 4
27820: ARRAY
27821: NONEQUAL
27822: IFFALSE 27834
// begin result := false ;
27824: LD_ADDR_VAR 0 3
27828: PUSH
27829: LD_INT 0
27831: ST_TO_ADDR
// break ;
27832: GO 27836
// end ;
27834: GO 27797
27836: POP
27837: POP
// end else
27838: GO 27848
// result := false ;
27840: LD_ADDR_VAR 0 3
27844: PUSH
27845: LD_INT 0
27847: ST_TO_ADDR
// end ;
27848: LD_VAR 0 3
27852: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
27853: LD_INT 0
27855: PPUSH
27856: PPUSH
27857: PPUSH
// pom := GetBase ( fac ) ;
27858: LD_ADDR_VAR 0 5
27862: PUSH
27863: LD_VAR 0 1
27867: PPUSH
27868: CALL_OW 274
27872: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
27873: LD_ADDR_VAR 0 4
27877: PUSH
27878: LD_VAR 0 2
27882: PUSH
27883: LD_INT 1
27885: ARRAY
27886: PPUSH
27887: LD_VAR 0 2
27891: PUSH
27892: LD_INT 2
27894: ARRAY
27895: PPUSH
27896: LD_VAR 0 2
27900: PUSH
27901: LD_INT 3
27903: ARRAY
27904: PPUSH
27905: LD_VAR 0 2
27909: PUSH
27910: LD_INT 4
27912: ARRAY
27913: PPUSH
27914: CALL_OW 449
27918: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27919: LD_ADDR_VAR 0 3
27923: PUSH
27924: LD_VAR 0 5
27928: PPUSH
27929: LD_INT 1
27931: PPUSH
27932: CALL_OW 275
27936: PUSH
27937: LD_VAR 0 4
27941: PUSH
27942: LD_INT 1
27944: ARRAY
27945: GREATEREQUAL
27946: PUSH
27947: LD_VAR 0 5
27951: PPUSH
27952: LD_INT 2
27954: PPUSH
27955: CALL_OW 275
27959: PUSH
27960: LD_VAR 0 4
27964: PUSH
27965: LD_INT 2
27967: ARRAY
27968: GREATEREQUAL
27969: AND
27970: PUSH
27971: LD_VAR 0 5
27975: PPUSH
27976: LD_INT 3
27978: PPUSH
27979: CALL_OW 275
27983: PUSH
27984: LD_VAR 0 4
27988: PUSH
27989: LD_INT 3
27991: ARRAY
27992: GREATEREQUAL
27993: AND
27994: ST_TO_ADDR
// end ;
27995: LD_VAR 0 3
27999: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
28000: LD_INT 0
28002: PPUSH
28003: PPUSH
28004: PPUSH
28005: PPUSH
// pom := GetBase ( building ) ;
28006: LD_ADDR_VAR 0 3
28010: PUSH
28011: LD_VAR 0 1
28015: PPUSH
28016: CALL_OW 274
28020: ST_TO_ADDR
// if not pom then
28021: LD_VAR 0 3
28025: NOT
28026: IFFALSE 28030
// exit ;
28028: GO 28200
// btype := GetBType ( building ) ;
28030: LD_ADDR_VAR 0 5
28034: PUSH
28035: LD_VAR 0 1
28039: PPUSH
28040: CALL_OW 266
28044: ST_TO_ADDR
// if btype = b_armoury then
28045: LD_VAR 0 5
28049: PUSH
28050: LD_INT 4
28052: EQUAL
28053: IFFALSE 28063
// btype := b_barracks ;
28055: LD_ADDR_VAR 0 5
28059: PUSH
28060: LD_INT 5
28062: ST_TO_ADDR
// if btype = b_depot then
28063: LD_VAR 0 5
28067: PUSH
28068: LD_INT 0
28070: EQUAL
28071: IFFALSE 28081
// btype := b_warehouse ;
28073: LD_ADDR_VAR 0 5
28077: PUSH
28078: LD_INT 1
28080: ST_TO_ADDR
// if btype = b_workshop then
28081: LD_VAR 0 5
28085: PUSH
28086: LD_INT 2
28088: EQUAL
28089: IFFALSE 28099
// btype := b_factory ;
28091: LD_ADDR_VAR 0 5
28095: PUSH
28096: LD_INT 3
28098: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28099: LD_ADDR_VAR 0 4
28103: PUSH
28104: LD_VAR 0 5
28108: PPUSH
28109: LD_VAR 0 1
28113: PPUSH
28114: CALL_OW 248
28118: PPUSH
28119: CALL_OW 450
28123: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28124: LD_ADDR_VAR 0 2
28128: PUSH
28129: LD_VAR 0 3
28133: PPUSH
28134: LD_INT 1
28136: PPUSH
28137: CALL_OW 275
28141: PUSH
28142: LD_VAR 0 4
28146: PUSH
28147: LD_INT 1
28149: ARRAY
28150: GREATEREQUAL
28151: PUSH
28152: LD_VAR 0 3
28156: PPUSH
28157: LD_INT 2
28159: PPUSH
28160: CALL_OW 275
28164: PUSH
28165: LD_VAR 0 4
28169: PUSH
28170: LD_INT 2
28172: ARRAY
28173: GREATEREQUAL
28174: AND
28175: PUSH
28176: LD_VAR 0 3
28180: PPUSH
28181: LD_INT 3
28183: PPUSH
28184: CALL_OW 275
28188: PUSH
28189: LD_VAR 0 4
28193: PUSH
28194: LD_INT 3
28196: ARRAY
28197: GREATEREQUAL
28198: AND
28199: ST_TO_ADDR
// end ;
28200: LD_VAR 0 2
28204: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
28205: LD_INT 0
28207: PPUSH
28208: PPUSH
28209: PPUSH
// pom := GetBase ( building ) ;
28210: LD_ADDR_VAR 0 4
28214: PUSH
28215: LD_VAR 0 1
28219: PPUSH
28220: CALL_OW 274
28224: ST_TO_ADDR
// if not pom then
28225: LD_VAR 0 4
28229: NOT
28230: IFFALSE 28234
// exit ;
28232: GO 28335
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28234: LD_ADDR_VAR 0 5
28238: PUSH
28239: LD_VAR 0 2
28243: PPUSH
28244: LD_VAR 0 1
28248: PPUSH
28249: CALL_OW 248
28253: PPUSH
28254: CALL_OW 450
28258: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28259: LD_ADDR_VAR 0 3
28263: PUSH
28264: LD_VAR 0 4
28268: PPUSH
28269: LD_INT 1
28271: PPUSH
28272: CALL_OW 275
28276: PUSH
28277: LD_VAR 0 5
28281: PUSH
28282: LD_INT 1
28284: ARRAY
28285: GREATEREQUAL
28286: PUSH
28287: LD_VAR 0 4
28291: PPUSH
28292: LD_INT 2
28294: PPUSH
28295: CALL_OW 275
28299: PUSH
28300: LD_VAR 0 5
28304: PUSH
28305: LD_INT 2
28307: ARRAY
28308: GREATEREQUAL
28309: AND
28310: PUSH
28311: LD_VAR 0 4
28315: PPUSH
28316: LD_INT 3
28318: PPUSH
28319: CALL_OW 275
28323: PUSH
28324: LD_VAR 0 5
28328: PUSH
28329: LD_INT 3
28331: ARRAY
28332: GREATEREQUAL
28333: AND
28334: ST_TO_ADDR
// end ;
28335: LD_VAR 0 3
28339: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
28340: LD_INT 0
28342: PPUSH
28343: PPUSH
28344: PPUSH
28345: PPUSH
28346: PPUSH
28347: PPUSH
28348: PPUSH
28349: PPUSH
28350: PPUSH
28351: PPUSH
// result := false ;
28352: LD_ADDR_VAR 0 6
28356: PUSH
28357: LD_INT 0
28359: ST_TO_ADDR
// if not base or not btype or not x or not y then
28360: LD_VAR 0 1
28364: NOT
28365: PUSH
28366: LD_VAR 0 2
28370: NOT
28371: OR
28372: PUSH
28373: LD_VAR 0 3
28377: NOT
28378: OR
28379: PUSH
28380: LD_VAR 0 4
28384: NOT
28385: OR
28386: IFFALSE 28390
// exit ;
28388: GO 28999
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
28390: LD_ADDR_VAR 0 12
28394: PUSH
28395: LD_VAR 0 2
28399: PPUSH
28400: LD_VAR 0 3
28404: PPUSH
28405: LD_VAR 0 4
28409: PPUSH
28410: LD_VAR 0 5
28414: PPUSH
28415: LD_VAR 0 1
28419: PUSH
28420: LD_INT 1
28422: ARRAY
28423: PPUSH
28424: CALL_OW 248
28428: PPUSH
28429: LD_INT 0
28431: PPUSH
28432: CALL 29836 0 6
28436: ST_TO_ADDR
// if not hexes then
28437: LD_VAR 0 12
28441: NOT
28442: IFFALSE 28446
// exit ;
28444: GO 28999
// for i = 1 to hexes do
28446: LD_ADDR_VAR 0 7
28450: PUSH
28451: DOUBLE
28452: LD_INT 1
28454: DEC
28455: ST_TO_ADDR
28456: LD_VAR 0 12
28460: PUSH
28461: FOR_TO
28462: IFFALSE 28997
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28464: LD_ADDR_VAR 0 11
28468: PUSH
28469: LD_VAR 0 12
28473: PUSH
28474: LD_VAR 0 7
28478: ARRAY
28479: PUSH
28480: LD_INT 1
28482: ARRAY
28483: PPUSH
28484: LD_VAR 0 12
28488: PUSH
28489: LD_VAR 0 7
28493: ARRAY
28494: PUSH
28495: LD_INT 2
28497: ARRAY
28498: PPUSH
28499: CALL_OW 428
28503: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28504: LD_VAR 0 12
28508: PUSH
28509: LD_VAR 0 7
28513: ARRAY
28514: PUSH
28515: LD_INT 1
28517: ARRAY
28518: PPUSH
28519: LD_VAR 0 12
28523: PUSH
28524: LD_VAR 0 7
28528: ARRAY
28529: PUSH
28530: LD_INT 2
28532: ARRAY
28533: PPUSH
28534: CALL_OW 351
28538: PUSH
28539: LD_VAR 0 12
28543: PUSH
28544: LD_VAR 0 7
28548: ARRAY
28549: PUSH
28550: LD_INT 1
28552: ARRAY
28553: PPUSH
28554: LD_VAR 0 12
28558: PUSH
28559: LD_VAR 0 7
28563: ARRAY
28564: PUSH
28565: LD_INT 2
28567: ARRAY
28568: PPUSH
28569: CALL_OW 488
28573: NOT
28574: OR
28575: PUSH
28576: LD_VAR 0 11
28580: PPUSH
28581: CALL_OW 247
28585: PUSH
28586: LD_INT 3
28588: EQUAL
28589: OR
28590: IFFALSE 28596
// exit ;
28592: POP
28593: POP
28594: GO 28999
// if not tmp or not tmp in base then
28596: LD_VAR 0 11
28600: NOT
28601: PUSH
28602: LD_VAR 0 11
28606: PUSH
28607: LD_VAR 0 1
28611: IN
28612: NOT
28613: OR
28614: IFFALSE 28618
// continue ;
28616: GO 28461
// result := true ;
28618: LD_ADDR_VAR 0 6
28622: PUSH
28623: LD_INT 1
28625: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28626: LD_ADDR_VAR 0 15
28630: PUSH
28631: LD_VAR 0 1
28635: PPUSH
28636: LD_INT 22
28638: PUSH
28639: LD_VAR 0 11
28643: PPUSH
28644: CALL_OW 255
28648: PUSH
28649: EMPTY
28650: LIST
28651: LIST
28652: PUSH
28653: LD_INT 2
28655: PUSH
28656: LD_INT 30
28658: PUSH
28659: LD_INT 0
28661: PUSH
28662: EMPTY
28663: LIST
28664: LIST
28665: PUSH
28666: LD_INT 30
28668: PUSH
28669: LD_INT 1
28671: PUSH
28672: EMPTY
28673: LIST
28674: LIST
28675: PUSH
28676: EMPTY
28677: LIST
28678: LIST
28679: LIST
28680: PUSH
28681: EMPTY
28682: LIST
28683: LIST
28684: PPUSH
28685: CALL_OW 72
28689: ST_TO_ADDR
// if dep then
28690: LD_VAR 0 15
28694: IFFALSE 28830
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
28696: LD_ADDR_VAR 0 14
28700: PUSH
28701: LD_VAR 0 15
28705: PUSH
28706: LD_INT 1
28708: ARRAY
28709: PPUSH
28710: CALL_OW 250
28714: PPUSH
28715: LD_VAR 0 15
28719: PUSH
28720: LD_INT 1
28722: ARRAY
28723: PPUSH
28724: CALL_OW 254
28728: PPUSH
28729: LD_INT 5
28731: PPUSH
28732: CALL_OW 272
28736: PUSH
28737: LD_VAR 0 15
28741: PUSH
28742: LD_INT 1
28744: ARRAY
28745: PPUSH
28746: CALL_OW 251
28750: PPUSH
28751: LD_VAR 0 15
28755: PUSH
28756: LD_INT 1
28758: ARRAY
28759: PPUSH
28760: CALL_OW 254
28764: PPUSH
28765: LD_INT 5
28767: PPUSH
28768: CALL_OW 273
28772: PUSH
28773: EMPTY
28774: LIST
28775: LIST
28776: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
28777: LD_VAR 0 14
28781: PUSH
28782: LD_INT 1
28784: ARRAY
28785: PPUSH
28786: LD_VAR 0 14
28790: PUSH
28791: LD_INT 2
28793: ARRAY
28794: PPUSH
28795: CALL_OW 488
28799: IFFALSE 28830
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
28801: LD_VAR 0 11
28805: PPUSH
28806: LD_VAR 0 14
28810: PUSH
28811: LD_INT 1
28813: ARRAY
28814: PPUSH
28815: LD_VAR 0 14
28819: PUSH
28820: LD_INT 2
28822: ARRAY
28823: PPUSH
28824: CALL_OW 111
// continue ;
28828: GO 28461
// end ; end ; r := GetDir ( tmp ) ;
28830: LD_ADDR_VAR 0 13
28834: PUSH
28835: LD_VAR 0 11
28839: PPUSH
28840: CALL_OW 254
28844: ST_TO_ADDR
// if r = 5 then
28845: LD_VAR 0 13
28849: PUSH
28850: LD_INT 5
28852: EQUAL
28853: IFFALSE 28863
// r := 0 ;
28855: LD_ADDR_VAR 0 13
28859: PUSH
28860: LD_INT 0
28862: ST_TO_ADDR
// for j = r to 5 do
28863: LD_ADDR_VAR 0 8
28867: PUSH
28868: DOUBLE
28869: LD_VAR 0 13
28873: DEC
28874: ST_TO_ADDR
28875: LD_INT 5
28877: PUSH
28878: FOR_TO
28879: IFFALSE 28993
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28881: LD_ADDR_VAR 0 9
28885: PUSH
28886: LD_VAR 0 11
28890: PPUSH
28891: CALL_OW 250
28895: PPUSH
28896: LD_VAR 0 8
28900: PPUSH
28901: LD_INT 2
28903: PPUSH
28904: CALL_OW 272
28908: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28909: LD_ADDR_VAR 0 10
28913: PUSH
28914: LD_VAR 0 11
28918: PPUSH
28919: CALL_OW 251
28923: PPUSH
28924: LD_VAR 0 8
28928: PPUSH
28929: LD_INT 2
28931: PPUSH
28932: CALL_OW 273
28936: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28937: LD_VAR 0 9
28941: PPUSH
28942: LD_VAR 0 10
28946: PPUSH
28947: CALL_OW 488
28951: PUSH
28952: LD_VAR 0 9
28956: PPUSH
28957: LD_VAR 0 10
28961: PPUSH
28962: CALL_OW 428
28966: NOT
28967: AND
28968: IFFALSE 28991
// begin ComMoveXY ( tmp , _x , _y ) ;
28970: LD_VAR 0 11
28974: PPUSH
28975: LD_VAR 0 9
28979: PPUSH
28980: LD_VAR 0 10
28984: PPUSH
28985: CALL_OW 111
// break ;
28989: GO 28993
// end ; end ;
28991: GO 28878
28993: POP
28994: POP
// end ;
28995: GO 28461
28997: POP
28998: POP
// end ;
28999: LD_VAR 0 6
29003: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
29004: LD_INT 0
29006: PPUSH
29007: PPUSH
29008: PPUSH
29009: PPUSH
29010: PPUSH
29011: PPUSH
29012: PPUSH
29013: PPUSH
29014: PPUSH
29015: PPUSH
// result := false ;
29016: LD_ADDR_VAR 0 6
29020: PUSH
29021: LD_INT 0
29023: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
29024: LD_VAR 0 1
29028: NOT
29029: PUSH
29030: LD_VAR 0 1
29034: PPUSH
29035: CALL_OW 266
29039: PUSH
29040: LD_INT 0
29042: PUSH
29043: LD_INT 1
29045: PUSH
29046: EMPTY
29047: LIST
29048: LIST
29049: IN
29050: NOT
29051: OR
29052: PUSH
29053: LD_VAR 0 2
29057: NOT
29058: OR
29059: PUSH
29060: LD_VAR 0 5
29064: PUSH
29065: LD_INT 0
29067: PUSH
29068: LD_INT 1
29070: PUSH
29071: LD_INT 2
29073: PUSH
29074: LD_INT 3
29076: PUSH
29077: LD_INT 4
29079: PUSH
29080: LD_INT 5
29082: PUSH
29083: EMPTY
29084: LIST
29085: LIST
29086: LIST
29087: LIST
29088: LIST
29089: LIST
29090: IN
29091: NOT
29092: OR
29093: PUSH
29094: LD_VAR 0 3
29098: PPUSH
29099: LD_VAR 0 4
29103: PPUSH
29104: CALL_OW 488
29108: NOT
29109: OR
29110: IFFALSE 29114
// exit ;
29112: GO 29831
// pom := GetBase ( depot ) ;
29114: LD_ADDR_VAR 0 10
29118: PUSH
29119: LD_VAR 0 1
29123: PPUSH
29124: CALL_OW 274
29128: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
29129: LD_ADDR_VAR 0 11
29133: PUSH
29134: LD_VAR 0 2
29138: PPUSH
29139: LD_VAR 0 1
29143: PPUSH
29144: CALL_OW 248
29148: PPUSH
29149: CALL_OW 450
29153: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
29154: LD_VAR 0 10
29158: PPUSH
29159: LD_INT 1
29161: PPUSH
29162: CALL_OW 275
29166: PUSH
29167: LD_VAR 0 11
29171: PUSH
29172: LD_INT 1
29174: ARRAY
29175: GREATEREQUAL
29176: PUSH
29177: LD_VAR 0 10
29181: PPUSH
29182: LD_INT 2
29184: PPUSH
29185: CALL_OW 275
29189: PUSH
29190: LD_VAR 0 11
29194: PUSH
29195: LD_INT 2
29197: ARRAY
29198: GREATEREQUAL
29199: AND
29200: PUSH
29201: LD_VAR 0 10
29205: PPUSH
29206: LD_INT 3
29208: PPUSH
29209: CALL_OW 275
29213: PUSH
29214: LD_VAR 0 11
29218: PUSH
29219: LD_INT 3
29221: ARRAY
29222: GREATEREQUAL
29223: AND
29224: NOT
29225: IFFALSE 29229
// exit ;
29227: GO 29831
// if GetBType ( depot ) = b_depot then
29229: LD_VAR 0 1
29233: PPUSH
29234: CALL_OW 266
29238: PUSH
29239: LD_INT 0
29241: EQUAL
29242: IFFALSE 29254
// dist := 28 else
29244: LD_ADDR_VAR 0 14
29248: PUSH
29249: LD_INT 28
29251: ST_TO_ADDR
29252: GO 29262
// dist := 36 ;
29254: LD_ADDR_VAR 0 14
29258: PUSH
29259: LD_INT 36
29261: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
29262: LD_VAR 0 1
29266: PPUSH
29267: LD_VAR 0 3
29271: PPUSH
29272: LD_VAR 0 4
29276: PPUSH
29277: CALL_OW 297
29281: PUSH
29282: LD_VAR 0 14
29286: GREATER
29287: IFFALSE 29291
// exit ;
29289: GO 29831
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
29291: LD_ADDR_VAR 0 12
29295: PUSH
29296: LD_VAR 0 2
29300: PPUSH
29301: LD_VAR 0 3
29305: PPUSH
29306: LD_VAR 0 4
29310: PPUSH
29311: LD_VAR 0 5
29315: PPUSH
29316: LD_VAR 0 1
29320: PPUSH
29321: CALL_OW 248
29325: PPUSH
29326: LD_INT 0
29328: PPUSH
29329: CALL 29836 0 6
29333: ST_TO_ADDR
// if not hexes then
29334: LD_VAR 0 12
29338: NOT
29339: IFFALSE 29343
// exit ;
29341: GO 29831
// hex := GetHexInfo ( x , y ) ;
29343: LD_ADDR_VAR 0 15
29347: PUSH
29348: LD_VAR 0 3
29352: PPUSH
29353: LD_VAR 0 4
29357: PPUSH
29358: CALL_OW 546
29362: ST_TO_ADDR
// if hex [ 1 ] then
29363: LD_VAR 0 15
29367: PUSH
29368: LD_INT 1
29370: ARRAY
29371: IFFALSE 29375
// exit ;
29373: GO 29831
// height := hex [ 2 ] ;
29375: LD_ADDR_VAR 0 13
29379: PUSH
29380: LD_VAR 0 15
29384: PUSH
29385: LD_INT 2
29387: ARRAY
29388: ST_TO_ADDR
// for i = 1 to hexes do
29389: LD_ADDR_VAR 0 7
29393: PUSH
29394: DOUBLE
29395: LD_INT 1
29397: DEC
29398: ST_TO_ADDR
29399: LD_VAR 0 12
29403: PUSH
29404: FOR_TO
29405: IFFALSE 29735
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
29407: LD_VAR 0 12
29411: PUSH
29412: LD_VAR 0 7
29416: ARRAY
29417: PUSH
29418: LD_INT 1
29420: ARRAY
29421: PPUSH
29422: LD_VAR 0 12
29426: PUSH
29427: LD_VAR 0 7
29431: ARRAY
29432: PUSH
29433: LD_INT 2
29435: ARRAY
29436: PPUSH
29437: CALL_OW 488
29441: NOT
29442: PUSH
29443: LD_VAR 0 12
29447: PUSH
29448: LD_VAR 0 7
29452: ARRAY
29453: PUSH
29454: LD_INT 1
29456: ARRAY
29457: PPUSH
29458: LD_VAR 0 12
29462: PUSH
29463: LD_VAR 0 7
29467: ARRAY
29468: PUSH
29469: LD_INT 2
29471: ARRAY
29472: PPUSH
29473: CALL_OW 428
29477: PUSH
29478: LD_INT 0
29480: GREATER
29481: OR
29482: PUSH
29483: LD_VAR 0 12
29487: PUSH
29488: LD_VAR 0 7
29492: ARRAY
29493: PUSH
29494: LD_INT 1
29496: ARRAY
29497: PPUSH
29498: LD_VAR 0 12
29502: PUSH
29503: LD_VAR 0 7
29507: ARRAY
29508: PUSH
29509: LD_INT 2
29511: ARRAY
29512: PPUSH
29513: CALL_OW 351
29517: OR
29518: IFFALSE 29524
// exit ;
29520: POP
29521: POP
29522: GO 29831
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29524: LD_ADDR_VAR 0 8
29528: PUSH
29529: LD_VAR 0 12
29533: PUSH
29534: LD_VAR 0 7
29538: ARRAY
29539: PUSH
29540: LD_INT 1
29542: ARRAY
29543: PPUSH
29544: LD_VAR 0 12
29548: PUSH
29549: LD_VAR 0 7
29553: ARRAY
29554: PUSH
29555: LD_INT 2
29557: ARRAY
29558: PPUSH
29559: CALL_OW 546
29563: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
29564: LD_VAR 0 8
29568: PUSH
29569: LD_INT 1
29571: ARRAY
29572: PUSH
29573: LD_VAR 0 8
29577: PUSH
29578: LD_INT 2
29580: ARRAY
29581: PUSH
29582: LD_VAR 0 13
29586: PUSH
29587: LD_INT 2
29589: PLUS
29590: GREATER
29591: OR
29592: PUSH
29593: LD_VAR 0 8
29597: PUSH
29598: LD_INT 2
29600: ARRAY
29601: PUSH
29602: LD_VAR 0 13
29606: PUSH
29607: LD_INT 2
29609: MINUS
29610: LESS
29611: OR
29612: PUSH
29613: LD_VAR 0 8
29617: PUSH
29618: LD_INT 3
29620: ARRAY
29621: PUSH
29622: LD_INT 0
29624: PUSH
29625: LD_INT 8
29627: PUSH
29628: LD_INT 9
29630: PUSH
29631: LD_INT 10
29633: PUSH
29634: LD_INT 11
29636: PUSH
29637: LD_INT 12
29639: PUSH
29640: LD_INT 13
29642: PUSH
29643: LD_INT 16
29645: PUSH
29646: LD_INT 17
29648: PUSH
29649: LD_INT 18
29651: PUSH
29652: LD_INT 19
29654: PUSH
29655: LD_INT 20
29657: PUSH
29658: LD_INT 21
29660: PUSH
29661: EMPTY
29662: LIST
29663: LIST
29664: LIST
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: LIST
29670: LIST
29671: LIST
29672: LIST
29673: LIST
29674: LIST
29675: IN
29676: NOT
29677: OR
29678: PUSH
29679: LD_VAR 0 8
29683: PUSH
29684: LD_INT 5
29686: ARRAY
29687: NOT
29688: OR
29689: PUSH
29690: LD_VAR 0 8
29694: PUSH
29695: LD_INT 6
29697: ARRAY
29698: PUSH
29699: LD_INT 1
29701: PUSH
29702: LD_INT 2
29704: PUSH
29705: LD_INT 7
29707: PUSH
29708: LD_INT 9
29710: PUSH
29711: LD_INT 10
29713: PUSH
29714: LD_INT 11
29716: PUSH
29717: EMPTY
29718: LIST
29719: LIST
29720: LIST
29721: LIST
29722: LIST
29723: LIST
29724: IN
29725: NOT
29726: OR
29727: IFFALSE 29733
// exit ;
29729: POP
29730: POP
29731: GO 29831
// end ;
29733: GO 29404
29735: POP
29736: POP
// side := GetSide ( depot ) ;
29737: LD_ADDR_VAR 0 9
29741: PUSH
29742: LD_VAR 0 1
29746: PPUSH
29747: CALL_OW 255
29751: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29752: LD_VAR 0 9
29756: PPUSH
29757: LD_VAR 0 3
29761: PPUSH
29762: LD_VAR 0 4
29766: PPUSH
29767: LD_INT 20
29769: PPUSH
29770: CALL 22485 0 4
29774: PUSH
29775: LD_INT 4
29777: ARRAY
29778: IFFALSE 29782
// exit ;
29780: GO 29831
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29782: LD_VAR 0 2
29786: PUSH
29787: LD_INT 29
29789: PUSH
29790: LD_INT 30
29792: PUSH
29793: EMPTY
29794: LIST
29795: LIST
29796: IN
29797: PUSH
29798: LD_VAR 0 3
29802: PPUSH
29803: LD_VAR 0 4
29807: PPUSH
29808: LD_VAR 0 9
29812: PPUSH
29813: CALL_OW 440
29817: NOT
29818: AND
29819: IFFALSE 29823
// exit ;
29821: GO 29831
// result := true ;
29823: LD_ADDR_VAR 0 6
29827: PUSH
29828: LD_INT 1
29830: ST_TO_ADDR
// end ;
29831: LD_VAR 0 6
29835: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
29836: LD_INT 0
29838: PPUSH
29839: PPUSH
29840: PPUSH
29841: PPUSH
29842: PPUSH
29843: PPUSH
29844: PPUSH
29845: PPUSH
29846: PPUSH
29847: PPUSH
29848: PPUSH
29849: PPUSH
29850: PPUSH
29851: PPUSH
29852: PPUSH
29853: PPUSH
29854: PPUSH
29855: PPUSH
29856: PPUSH
29857: PPUSH
29858: PPUSH
29859: PPUSH
29860: PPUSH
29861: PPUSH
29862: PPUSH
29863: PPUSH
29864: PPUSH
29865: PPUSH
29866: PPUSH
29867: PPUSH
29868: PPUSH
29869: PPUSH
29870: PPUSH
29871: PPUSH
29872: PPUSH
29873: PPUSH
29874: PPUSH
29875: PPUSH
29876: PPUSH
29877: PPUSH
29878: PPUSH
29879: PPUSH
29880: PPUSH
29881: PPUSH
29882: PPUSH
29883: PPUSH
29884: PPUSH
29885: PPUSH
29886: PPUSH
29887: PPUSH
29888: PPUSH
29889: PPUSH
29890: PPUSH
29891: PPUSH
29892: PPUSH
29893: PPUSH
29894: PPUSH
29895: PPUSH
// result = [ ] ;
29896: LD_ADDR_VAR 0 7
29900: PUSH
29901: EMPTY
29902: ST_TO_ADDR
// temp_list = [ ] ;
29903: LD_ADDR_VAR 0 9
29907: PUSH
29908: EMPTY
29909: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29910: LD_VAR 0 4
29914: PUSH
29915: LD_INT 0
29917: PUSH
29918: LD_INT 1
29920: PUSH
29921: LD_INT 2
29923: PUSH
29924: LD_INT 3
29926: PUSH
29927: LD_INT 4
29929: PUSH
29930: LD_INT 5
29932: PUSH
29933: EMPTY
29934: LIST
29935: LIST
29936: LIST
29937: LIST
29938: LIST
29939: LIST
29940: IN
29941: NOT
29942: PUSH
29943: LD_VAR 0 1
29947: PUSH
29948: LD_INT 0
29950: PUSH
29951: LD_INT 1
29953: PUSH
29954: EMPTY
29955: LIST
29956: LIST
29957: IN
29958: PUSH
29959: LD_VAR 0 5
29963: PUSH
29964: LD_INT 1
29966: PUSH
29967: LD_INT 2
29969: PUSH
29970: LD_INT 3
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: LIST
29977: IN
29978: NOT
29979: AND
29980: OR
29981: IFFALSE 29985
// exit ;
29983: GO 48376
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29985: LD_VAR 0 1
29989: PUSH
29990: LD_INT 6
29992: PUSH
29993: LD_INT 7
29995: PUSH
29996: LD_INT 8
29998: PUSH
29999: LD_INT 13
30001: PUSH
30002: LD_INT 12
30004: PUSH
30005: LD_INT 15
30007: PUSH
30008: LD_INT 11
30010: PUSH
30011: LD_INT 14
30013: PUSH
30014: LD_INT 10
30016: PUSH
30017: EMPTY
30018: LIST
30019: LIST
30020: LIST
30021: LIST
30022: LIST
30023: LIST
30024: LIST
30025: LIST
30026: LIST
30027: IN
30028: IFFALSE 30038
// btype = b_lab ;
30030: LD_ADDR_VAR 0 1
30034: PUSH
30035: LD_INT 6
30037: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
30038: LD_VAR 0 6
30042: PUSH
30043: LD_INT 0
30045: PUSH
30046: LD_INT 1
30048: PUSH
30049: LD_INT 2
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: LIST
30056: IN
30057: NOT
30058: PUSH
30059: LD_VAR 0 1
30063: PUSH
30064: LD_INT 0
30066: PUSH
30067: LD_INT 1
30069: PUSH
30070: LD_INT 2
30072: PUSH
30073: LD_INT 3
30075: PUSH
30076: LD_INT 6
30078: PUSH
30079: LD_INT 36
30081: PUSH
30082: LD_INT 4
30084: PUSH
30085: LD_INT 5
30087: PUSH
30088: LD_INT 31
30090: PUSH
30091: LD_INT 32
30093: PUSH
30094: LD_INT 33
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: LIST
30101: LIST
30102: LIST
30103: LIST
30104: LIST
30105: LIST
30106: LIST
30107: LIST
30108: LIST
30109: IN
30110: NOT
30111: PUSH
30112: LD_VAR 0 6
30116: PUSH
30117: LD_INT 1
30119: EQUAL
30120: AND
30121: OR
30122: PUSH
30123: LD_VAR 0 1
30127: PUSH
30128: LD_INT 2
30130: PUSH
30131: LD_INT 3
30133: PUSH
30134: EMPTY
30135: LIST
30136: LIST
30137: IN
30138: NOT
30139: PUSH
30140: LD_VAR 0 6
30144: PUSH
30145: LD_INT 2
30147: EQUAL
30148: AND
30149: OR
30150: IFFALSE 30160
// mode = 0 ;
30152: LD_ADDR_VAR 0 6
30156: PUSH
30157: LD_INT 0
30159: ST_TO_ADDR
// case mode of 0 :
30160: LD_VAR 0 6
30164: PUSH
30165: LD_INT 0
30167: DOUBLE
30168: EQUAL
30169: IFTRUE 30173
30171: GO 41626
30173: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
30174: LD_ADDR_VAR 0 11
30178: PUSH
30179: LD_INT 0
30181: PUSH
30182: LD_INT 0
30184: PUSH
30185: EMPTY
30186: LIST
30187: LIST
30188: PUSH
30189: LD_INT 0
30191: PUSH
30192: LD_INT 1
30194: NEG
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 1
30202: PUSH
30203: LD_INT 0
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 1
30212: PUSH
30213: LD_INT 1
30215: PUSH
30216: EMPTY
30217: LIST
30218: LIST
30219: PUSH
30220: LD_INT 0
30222: PUSH
30223: LD_INT 1
30225: PUSH
30226: EMPTY
30227: LIST
30228: LIST
30229: PUSH
30230: LD_INT 1
30232: NEG
30233: PUSH
30234: LD_INT 0
30236: PUSH
30237: EMPTY
30238: LIST
30239: LIST
30240: PUSH
30241: LD_INT 1
30243: NEG
30244: PUSH
30245: LD_INT 1
30247: NEG
30248: PUSH
30249: EMPTY
30250: LIST
30251: LIST
30252: PUSH
30253: LD_INT 1
30255: NEG
30256: PUSH
30257: LD_INT 2
30259: NEG
30260: PUSH
30261: EMPTY
30262: LIST
30263: LIST
30264: PUSH
30265: LD_INT 0
30267: PUSH
30268: LD_INT 2
30270: NEG
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 1
30278: PUSH
30279: LD_INT 1
30281: NEG
30282: PUSH
30283: EMPTY
30284: LIST
30285: LIST
30286: PUSH
30287: LD_INT 1
30289: PUSH
30290: LD_INT 2
30292: PUSH
30293: EMPTY
30294: LIST
30295: LIST
30296: PUSH
30297: LD_INT 0
30299: PUSH
30300: LD_INT 2
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: PUSH
30307: LD_INT 1
30309: NEG
30310: PUSH
30311: LD_INT 1
30313: PUSH
30314: EMPTY
30315: LIST
30316: LIST
30317: PUSH
30318: LD_INT 1
30320: PUSH
30321: LD_INT 3
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: PUSH
30328: LD_INT 0
30330: PUSH
30331: LD_INT 3
30333: PUSH
30334: EMPTY
30335: LIST
30336: LIST
30337: PUSH
30338: LD_INT 1
30340: NEG
30341: PUSH
30342: LD_INT 2
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30367: LD_ADDR_VAR 0 12
30371: PUSH
30372: LD_INT 0
30374: PUSH
30375: LD_INT 0
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: LD_INT 0
30384: PUSH
30385: LD_INT 1
30387: NEG
30388: PUSH
30389: EMPTY
30390: LIST
30391: LIST
30392: PUSH
30393: LD_INT 1
30395: PUSH
30396: LD_INT 0
30398: PUSH
30399: EMPTY
30400: LIST
30401: LIST
30402: PUSH
30403: LD_INT 1
30405: PUSH
30406: LD_INT 1
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: LD_INT 0
30415: PUSH
30416: LD_INT 1
30418: PUSH
30419: EMPTY
30420: LIST
30421: LIST
30422: PUSH
30423: LD_INT 1
30425: NEG
30426: PUSH
30427: LD_INT 0
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: LD_INT 1
30436: NEG
30437: PUSH
30438: LD_INT 1
30440: NEG
30441: PUSH
30442: EMPTY
30443: LIST
30444: LIST
30445: PUSH
30446: LD_INT 1
30448: PUSH
30449: LD_INT 1
30451: NEG
30452: PUSH
30453: EMPTY
30454: LIST
30455: LIST
30456: PUSH
30457: LD_INT 2
30459: PUSH
30460: LD_INT 0
30462: PUSH
30463: EMPTY
30464: LIST
30465: LIST
30466: PUSH
30467: LD_INT 2
30469: PUSH
30470: LD_INT 1
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: PUSH
30477: LD_INT 1
30479: NEG
30480: PUSH
30481: LD_INT 1
30483: PUSH
30484: EMPTY
30485: LIST
30486: LIST
30487: PUSH
30488: LD_INT 2
30490: NEG
30491: PUSH
30492: LD_INT 0
30494: PUSH
30495: EMPTY
30496: LIST
30497: LIST
30498: PUSH
30499: LD_INT 2
30501: NEG
30502: PUSH
30503: LD_INT 1
30505: NEG
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: LD_INT 2
30513: NEG
30514: PUSH
30515: LD_INT 1
30517: PUSH
30518: EMPTY
30519: LIST
30520: LIST
30521: PUSH
30522: LD_INT 3
30524: NEG
30525: PUSH
30526: LD_INT 0
30528: PUSH
30529: EMPTY
30530: LIST
30531: LIST
30532: PUSH
30533: LD_INT 3
30535: NEG
30536: PUSH
30537: LD_INT 1
30539: NEG
30540: PUSH
30541: EMPTY
30542: LIST
30543: LIST
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: LIST
30549: LIST
30550: LIST
30551: LIST
30552: LIST
30553: LIST
30554: LIST
30555: LIST
30556: LIST
30557: LIST
30558: LIST
30559: LIST
30560: LIST
30561: LIST
30562: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30563: LD_ADDR_VAR 0 13
30567: PUSH
30568: LD_INT 0
30570: PUSH
30571: LD_INT 0
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: LD_INT 0
30580: PUSH
30581: LD_INT 1
30583: NEG
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: PUSH
30589: LD_INT 1
30591: PUSH
30592: LD_INT 0
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PUSH
30599: LD_INT 1
30601: PUSH
30602: LD_INT 1
30604: PUSH
30605: EMPTY
30606: LIST
30607: LIST
30608: PUSH
30609: LD_INT 0
30611: PUSH
30612: LD_INT 1
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: LD_INT 1
30621: NEG
30622: PUSH
30623: LD_INT 0
30625: PUSH
30626: EMPTY
30627: LIST
30628: LIST
30629: PUSH
30630: LD_INT 1
30632: NEG
30633: PUSH
30634: LD_INT 1
30636: NEG
30637: PUSH
30638: EMPTY
30639: LIST
30640: LIST
30641: PUSH
30642: LD_INT 1
30644: NEG
30645: PUSH
30646: LD_INT 2
30648: NEG
30649: PUSH
30650: EMPTY
30651: LIST
30652: LIST
30653: PUSH
30654: LD_INT 2
30656: PUSH
30657: LD_INT 1
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: LD_INT 2
30666: PUSH
30667: LD_INT 2
30669: PUSH
30670: EMPTY
30671: LIST
30672: LIST
30673: PUSH
30674: LD_INT 1
30676: PUSH
30677: LD_INT 2
30679: PUSH
30680: EMPTY
30681: LIST
30682: LIST
30683: PUSH
30684: LD_INT 2
30686: NEG
30687: PUSH
30688: LD_INT 1
30690: NEG
30691: PUSH
30692: EMPTY
30693: LIST
30694: LIST
30695: PUSH
30696: LD_INT 2
30698: NEG
30699: PUSH
30700: LD_INT 2
30702: NEG
30703: PUSH
30704: EMPTY
30705: LIST
30706: LIST
30707: PUSH
30708: LD_INT 2
30710: NEG
30711: PUSH
30712: LD_INT 3
30714: NEG
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: PUSH
30720: LD_INT 3
30722: NEG
30723: PUSH
30724: LD_INT 2
30726: NEG
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 3
30734: NEG
30735: PUSH
30736: LD_INT 3
30738: NEG
30739: PUSH
30740: EMPTY
30741: LIST
30742: LIST
30743: PUSH
30744: EMPTY
30745: LIST
30746: LIST
30747: LIST
30748: LIST
30749: LIST
30750: LIST
30751: LIST
30752: LIST
30753: LIST
30754: LIST
30755: LIST
30756: LIST
30757: LIST
30758: LIST
30759: LIST
30760: LIST
30761: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30762: LD_ADDR_VAR 0 14
30766: PUSH
30767: LD_INT 0
30769: PUSH
30770: LD_INT 0
30772: PUSH
30773: EMPTY
30774: LIST
30775: LIST
30776: PUSH
30777: LD_INT 0
30779: PUSH
30780: LD_INT 1
30782: NEG
30783: PUSH
30784: EMPTY
30785: LIST
30786: LIST
30787: PUSH
30788: LD_INT 1
30790: PUSH
30791: LD_INT 0
30793: PUSH
30794: EMPTY
30795: LIST
30796: LIST
30797: PUSH
30798: LD_INT 1
30800: PUSH
30801: LD_INT 1
30803: PUSH
30804: EMPTY
30805: LIST
30806: LIST
30807: PUSH
30808: LD_INT 0
30810: PUSH
30811: LD_INT 1
30813: PUSH
30814: EMPTY
30815: LIST
30816: LIST
30817: PUSH
30818: LD_INT 1
30820: NEG
30821: PUSH
30822: LD_INT 0
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: PUSH
30829: LD_INT 1
30831: NEG
30832: PUSH
30833: LD_INT 1
30835: NEG
30836: PUSH
30837: EMPTY
30838: LIST
30839: LIST
30840: PUSH
30841: LD_INT 1
30843: NEG
30844: PUSH
30845: LD_INT 2
30847: NEG
30848: PUSH
30849: EMPTY
30850: LIST
30851: LIST
30852: PUSH
30853: LD_INT 0
30855: PUSH
30856: LD_INT 2
30858: NEG
30859: PUSH
30860: EMPTY
30861: LIST
30862: LIST
30863: PUSH
30864: LD_INT 1
30866: PUSH
30867: LD_INT 1
30869: NEG
30870: PUSH
30871: EMPTY
30872: LIST
30873: LIST
30874: PUSH
30875: LD_INT 1
30877: PUSH
30878: LD_INT 2
30880: PUSH
30881: EMPTY
30882: LIST
30883: LIST
30884: PUSH
30885: LD_INT 0
30887: PUSH
30888: LD_INT 2
30890: PUSH
30891: EMPTY
30892: LIST
30893: LIST
30894: PUSH
30895: LD_INT 1
30897: NEG
30898: PUSH
30899: LD_INT 1
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: LD_INT 1
30908: NEG
30909: PUSH
30910: LD_INT 3
30912: NEG
30913: PUSH
30914: EMPTY
30915: LIST
30916: LIST
30917: PUSH
30918: LD_INT 0
30920: PUSH
30921: LD_INT 3
30923: NEG
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PUSH
30929: LD_INT 1
30931: PUSH
30932: LD_INT 2
30934: NEG
30935: PUSH
30936: EMPTY
30937: LIST
30938: LIST
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: LIST
30944: LIST
30945: LIST
30946: LIST
30947: LIST
30948: LIST
30949: LIST
30950: LIST
30951: LIST
30952: LIST
30953: LIST
30954: LIST
30955: LIST
30956: LIST
30957: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30958: LD_ADDR_VAR 0 15
30962: PUSH
30963: LD_INT 0
30965: PUSH
30966: LD_INT 0
30968: PUSH
30969: EMPTY
30970: LIST
30971: LIST
30972: PUSH
30973: LD_INT 0
30975: PUSH
30976: LD_INT 1
30978: NEG
30979: PUSH
30980: EMPTY
30981: LIST
30982: LIST
30983: PUSH
30984: LD_INT 1
30986: PUSH
30987: LD_INT 0
30989: PUSH
30990: EMPTY
30991: LIST
30992: LIST
30993: PUSH
30994: LD_INT 1
30996: PUSH
30997: LD_INT 1
30999: PUSH
31000: EMPTY
31001: LIST
31002: LIST
31003: PUSH
31004: LD_INT 0
31006: PUSH
31007: LD_INT 1
31009: PUSH
31010: EMPTY
31011: LIST
31012: LIST
31013: PUSH
31014: LD_INT 1
31016: NEG
31017: PUSH
31018: LD_INT 0
31020: PUSH
31021: EMPTY
31022: LIST
31023: LIST
31024: PUSH
31025: LD_INT 1
31027: NEG
31028: PUSH
31029: LD_INT 1
31031: NEG
31032: PUSH
31033: EMPTY
31034: LIST
31035: LIST
31036: PUSH
31037: LD_INT 1
31039: PUSH
31040: LD_INT 1
31042: NEG
31043: PUSH
31044: EMPTY
31045: LIST
31046: LIST
31047: PUSH
31048: LD_INT 2
31050: PUSH
31051: LD_INT 0
31053: PUSH
31054: EMPTY
31055: LIST
31056: LIST
31057: PUSH
31058: LD_INT 2
31060: PUSH
31061: LD_INT 1
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PUSH
31068: LD_INT 1
31070: NEG
31071: PUSH
31072: LD_INT 1
31074: PUSH
31075: EMPTY
31076: LIST
31077: LIST
31078: PUSH
31079: LD_INT 2
31081: NEG
31082: PUSH
31083: LD_INT 0
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PUSH
31090: LD_INT 2
31092: NEG
31093: PUSH
31094: LD_INT 1
31096: NEG
31097: PUSH
31098: EMPTY
31099: LIST
31100: LIST
31101: PUSH
31102: LD_INT 2
31104: PUSH
31105: LD_INT 1
31107: NEG
31108: PUSH
31109: EMPTY
31110: LIST
31111: LIST
31112: PUSH
31113: LD_INT 3
31115: PUSH
31116: LD_INT 0
31118: PUSH
31119: EMPTY
31120: LIST
31121: LIST
31122: PUSH
31123: LD_INT 3
31125: PUSH
31126: LD_INT 1
31128: PUSH
31129: EMPTY
31130: LIST
31131: LIST
31132: PUSH
31133: EMPTY
31134: LIST
31135: LIST
31136: LIST
31137: LIST
31138: LIST
31139: LIST
31140: LIST
31141: LIST
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: LIST
31148: LIST
31149: LIST
31150: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
31151: LD_ADDR_VAR 0 16
31155: PUSH
31156: LD_INT 0
31158: PUSH
31159: LD_INT 0
31161: PUSH
31162: EMPTY
31163: LIST
31164: LIST
31165: PUSH
31166: LD_INT 0
31168: PUSH
31169: LD_INT 1
31171: NEG
31172: PUSH
31173: EMPTY
31174: LIST
31175: LIST
31176: PUSH
31177: LD_INT 1
31179: PUSH
31180: LD_INT 0
31182: PUSH
31183: EMPTY
31184: LIST
31185: LIST
31186: PUSH
31187: LD_INT 1
31189: PUSH
31190: LD_INT 1
31192: PUSH
31193: EMPTY
31194: LIST
31195: LIST
31196: PUSH
31197: LD_INT 0
31199: PUSH
31200: LD_INT 1
31202: PUSH
31203: EMPTY
31204: LIST
31205: LIST
31206: PUSH
31207: LD_INT 1
31209: NEG
31210: PUSH
31211: LD_INT 0
31213: PUSH
31214: EMPTY
31215: LIST
31216: LIST
31217: PUSH
31218: LD_INT 1
31220: NEG
31221: PUSH
31222: LD_INT 1
31224: NEG
31225: PUSH
31226: EMPTY
31227: LIST
31228: LIST
31229: PUSH
31230: LD_INT 1
31232: NEG
31233: PUSH
31234: LD_INT 2
31236: NEG
31237: PUSH
31238: EMPTY
31239: LIST
31240: LIST
31241: PUSH
31242: LD_INT 2
31244: PUSH
31245: LD_INT 1
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: PUSH
31252: LD_INT 2
31254: PUSH
31255: LD_INT 2
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: LD_INT 1
31264: PUSH
31265: LD_INT 2
31267: PUSH
31268: EMPTY
31269: LIST
31270: LIST
31271: PUSH
31272: LD_INT 2
31274: NEG
31275: PUSH
31276: LD_INT 1
31278: NEG
31279: PUSH
31280: EMPTY
31281: LIST
31282: LIST
31283: PUSH
31284: LD_INT 2
31286: NEG
31287: PUSH
31288: LD_INT 2
31290: NEG
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 3
31298: PUSH
31299: LD_INT 2
31301: PUSH
31302: EMPTY
31303: LIST
31304: LIST
31305: PUSH
31306: LD_INT 3
31308: PUSH
31309: LD_INT 3
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: PUSH
31316: LD_INT 2
31318: PUSH
31319: LD_INT 3
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: LIST
31330: LIST
31331: LIST
31332: LIST
31333: LIST
31334: LIST
31335: LIST
31336: LIST
31337: LIST
31338: LIST
31339: LIST
31340: LIST
31341: LIST
31342: LIST
31343: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31344: LD_ADDR_VAR 0 17
31348: PUSH
31349: LD_INT 0
31351: PUSH
31352: LD_INT 0
31354: PUSH
31355: EMPTY
31356: LIST
31357: LIST
31358: PUSH
31359: LD_INT 0
31361: PUSH
31362: LD_INT 1
31364: NEG
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: PUSH
31370: LD_INT 1
31372: PUSH
31373: LD_INT 0
31375: PUSH
31376: EMPTY
31377: LIST
31378: LIST
31379: PUSH
31380: LD_INT 1
31382: PUSH
31383: LD_INT 1
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: PUSH
31390: LD_INT 0
31392: PUSH
31393: LD_INT 1
31395: PUSH
31396: EMPTY
31397: LIST
31398: LIST
31399: PUSH
31400: LD_INT 1
31402: NEG
31403: PUSH
31404: LD_INT 0
31406: PUSH
31407: EMPTY
31408: LIST
31409: LIST
31410: PUSH
31411: LD_INT 1
31413: NEG
31414: PUSH
31415: LD_INT 1
31417: NEG
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: PUSH
31423: LD_INT 1
31425: NEG
31426: PUSH
31427: LD_INT 2
31429: NEG
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: PUSH
31435: LD_INT 0
31437: PUSH
31438: LD_INT 2
31440: NEG
31441: PUSH
31442: EMPTY
31443: LIST
31444: LIST
31445: PUSH
31446: LD_INT 1
31448: PUSH
31449: LD_INT 1
31451: NEG
31452: PUSH
31453: EMPTY
31454: LIST
31455: LIST
31456: PUSH
31457: LD_INT 2
31459: PUSH
31460: LD_INT 0
31462: PUSH
31463: EMPTY
31464: LIST
31465: LIST
31466: PUSH
31467: LD_INT 2
31469: PUSH
31470: LD_INT 1
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: PUSH
31477: LD_INT 2
31479: PUSH
31480: LD_INT 2
31482: PUSH
31483: EMPTY
31484: LIST
31485: LIST
31486: PUSH
31487: LD_INT 1
31489: PUSH
31490: LD_INT 2
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: PUSH
31497: LD_INT 0
31499: PUSH
31500: LD_INT 2
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 1
31509: NEG
31510: PUSH
31511: LD_INT 1
31513: PUSH
31514: EMPTY
31515: LIST
31516: LIST
31517: PUSH
31518: LD_INT 2
31520: NEG
31521: PUSH
31522: LD_INT 0
31524: PUSH
31525: EMPTY
31526: LIST
31527: LIST
31528: PUSH
31529: LD_INT 2
31531: NEG
31532: PUSH
31533: LD_INT 1
31535: NEG
31536: PUSH
31537: EMPTY
31538: LIST
31539: LIST
31540: PUSH
31541: LD_INT 2
31543: NEG
31544: PUSH
31545: LD_INT 2
31547: NEG
31548: PUSH
31549: EMPTY
31550: LIST
31551: LIST
31552: PUSH
31553: EMPTY
31554: LIST
31555: LIST
31556: LIST
31557: LIST
31558: LIST
31559: LIST
31560: LIST
31561: LIST
31562: LIST
31563: LIST
31564: LIST
31565: LIST
31566: LIST
31567: LIST
31568: LIST
31569: LIST
31570: LIST
31571: LIST
31572: LIST
31573: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31574: LD_ADDR_VAR 0 18
31578: PUSH
31579: LD_INT 0
31581: PUSH
31582: LD_INT 0
31584: PUSH
31585: EMPTY
31586: LIST
31587: LIST
31588: PUSH
31589: LD_INT 0
31591: PUSH
31592: LD_INT 1
31594: NEG
31595: PUSH
31596: EMPTY
31597: LIST
31598: LIST
31599: PUSH
31600: LD_INT 1
31602: PUSH
31603: LD_INT 0
31605: PUSH
31606: EMPTY
31607: LIST
31608: LIST
31609: PUSH
31610: LD_INT 1
31612: PUSH
31613: LD_INT 1
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: LD_INT 0
31622: PUSH
31623: LD_INT 1
31625: PUSH
31626: EMPTY
31627: LIST
31628: LIST
31629: PUSH
31630: LD_INT 1
31632: NEG
31633: PUSH
31634: LD_INT 0
31636: PUSH
31637: EMPTY
31638: LIST
31639: LIST
31640: PUSH
31641: LD_INT 1
31643: NEG
31644: PUSH
31645: LD_INT 1
31647: NEG
31648: PUSH
31649: EMPTY
31650: LIST
31651: LIST
31652: PUSH
31653: LD_INT 1
31655: NEG
31656: PUSH
31657: LD_INT 2
31659: NEG
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PUSH
31665: LD_INT 0
31667: PUSH
31668: LD_INT 2
31670: NEG
31671: PUSH
31672: EMPTY
31673: LIST
31674: LIST
31675: PUSH
31676: LD_INT 1
31678: PUSH
31679: LD_INT 1
31681: NEG
31682: PUSH
31683: EMPTY
31684: LIST
31685: LIST
31686: PUSH
31687: LD_INT 2
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PUSH
31697: LD_INT 2
31699: PUSH
31700: LD_INT 1
31702: PUSH
31703: EMPTY
31704: LIST
31705: LIST
31706: PUSH
31707: LD_INT 2
31709: PUSH
31710: LD_INT 2
31712: PUSH
31713: EMPTY
31714: LIST
31715: LIST
31716: PUSH
31717: LD_INT 1
31719: PUSH
31720: LD_INT 2
31722: PUSH
31723: EMPTY
31724: LIST
31725: LIST
31726: PUSH
31727: LD_INT 0
31729: PUSH
31730: LD_INT 2
31732: PUSH
31733: EMPTY
31734: LIST
31735: LIST
31736: PUSH
31737: LD_INT 1
31739: NEG
31740: PUSH
31741: LD_INT 1
31743: PUSH
31744: EMPTY
31745: LIST
31746: LIST
31747: PUSH
31748: LD_INT 2
31750: NEG
31751: PUSH
31752: LD_INT 0
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: LD_INT 2
31761: NEG
31762: PUSH
31763: LD_INT 1
31765: NEG
31766: PUSH
31767: EMPTY
31768: LIST
31769: LIST
31770: PUSH
31771: LD_INT 2
31773: NEG
31774: PUSH
31775: LD_INT 2
31777: NEG
31778: PUSH
31779: EMPTY
31780: LIST
31781: LIST
31782: PUSH
31783: EMPTY
31784: LIST
31785: LIST
31786: LIST
31787: LIST
31788: LIST
31789: LIST
31790: LIST
31791: LIST
31792: LIST
31793: LIST
31794: LIST
31795: LIST
31796: LIST
31797: LIST
31798: LIST
31799: LIST
31800: LIST
31801: LIST
31802: LIST
31803: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31804: LD_ADDR_VAR 0 19
31808: PUSH
31809: LD_INT 0
31811: PUSH
31812: LD_INT 0
31814: PUSH
31815: EMPTY
31816: LIST
31817: LIST
31818: PUSH
31819: LD_INT 0
31821: PUSH
31822: LD_INT 1
31824: NEG
31825: PUSH
31826: EMPTY
31827: LIST
31828: LIST
31829: PUSH
31830: LD_INT 1
31832: PUSH
31833: LD_INT 0
31835: PUSH
31836: EMPTY
31837: LIST
31838: LIST
31839: PUSH
31840: LD_INT 1
31842: PUSH
31843: LD_INT 1
31845: PUSH
31846: EMPTY
31847: LIST
31848: LIST
31849: PUSH
31850: LD_INT 0
31852: PUSH
31853: LD_INT 1
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: PUSH
31860: LD_INT 1
31862: NEG
31863: PUSH
31864: LD_INT 0
31866: PUSH
31867: EMPTY
31868: LIST
31869: LIST
31870: PUSH
31871: LD_INT 1
31873: NEG
31874: PUSH
31875: LD_INT 1
31877: NEG
31878: PUSH
31879: EMPTY
31880: LIST
31881: LIST
31882: PUSH
31883: LD_INT 1
31885: NEG
31886: PUSH
31887: LD_INT 2
31889: NEG
31890: PUSH
31891: EMPTY
31892: LIST
31893: LIST
31894: PUSH
31895: LD_INT 0
31897: PUSH
31898: LD_INT 2
31900: NEG
31901: PUSH
31902: EMPTY
31903: LIST
31904: LIST
31905: PUSH
31906: LD_INT 1
31908: PUSH
31909: LD_INT 1
31911: NEG
31912: PUSH
31913: EMPTY
31914: LIST
31915: LIST
31916: PUSH
31917: LD_INT 2
31919: PUSH
31920: LD_INT 0
31922: PUSH
31923: EMPTY
31924: LIST
31925: LIST
31926: PUSH
31927: LD_INT 2
31929: PUSH
31930: LD_INT 1
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PUSH
31937: LD_INT 2
31939: PUSH
31940: LD_INT 2
31942: PUSH
31943: EMPTY
31944: LIST
31945: LIST
31946: PUSH
31947: LD_INT 1
31949: PUSH
31950: LD_INT 2
31952: PUSH
31953: EMPTY
31954: LIST
31955: LIST
31956: PUSH
31957: LD_INT 0
31959: PUSH
31960: LD_INT 2
31962: PUSH
31963: EMPTY
31964: LIST
31965: LIST
31966: PUSH
31967: LD_INT 1
31969: NEG
31970: PUSH
31971: LD_INT 1
31973: PUSH
31974: EMPTY
31975: LIST
31976: LIST
31977: PUSH
31978: LD_INT 2
31980: NEG
31981: PUSH
31982: LD_INT 0
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 2
31991: NEG
31992: PUSH
31993: LD_INT 1
31995: NEG
31996: PUSH
31997: EMPTY
31998: LIST
31999: LIST
32000: PUSH
32001: LD_INT 2
32003: NEG
32004: PUSH
32005: LD_INT 2
32007: NEG
32008: PUSH
32009: EMPTY
32010: LIST
32011: LIST
32012: PUSH
32013: EMPTY
32014: LIST
32015: LIST
32016: LIST
32017: LIST
32018: LIST
32019: LIST
32020: LIST
32021: LIST
32022: LIST
32023: LIST
32024: LIST
32025: LIST
32026: LIST
32027: LIST
32028: LIST
32029: LIST
32030: LIST
32031: LIST
32032: LIST
32033: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32034: LD_ADDR_VAR 0 20
32038: PUSH
32039: LD_INT 0
32041: PUSH
32042: LD_INT 0
32044: PUSH
32045: EMPTY
32046: LIST
32047: LIST
32048: PUSH
32049: LD_INT 0
32051: PUSH
32052: LD_INT 1
32054: NEG
32055: PUSH
32056: EMPTY
32057: LIST
32058: LIST
32059: PUSH
32060: LD_INT 1
32062: PUSH
32063: LD_INT 0
32065: PUSH
32066: EMPTY
32067: LIST
32068: LIST
32069: PUSH
32070: LD_INT 1
32072: PUSH
32073: LD_INT 1
32075: PUSH
32076: EMPTY
32077: LIST
32078: LIST
32079: PUSH
32080: LD_INT 0
32082: PUSH
32083: LD_INT 1
32085: PUSH
32086: EMPTY
32087: LIST
32088: LIST
32089: PUSH
32090: LD_INT 1
32092: NEG
32093: PUSH
32094: LD_INT 0
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: PUSH
32101: LD_INT 1
32103: NEG
32104: PUSH
32105: LD_INT 1
32107: NEG
32108: PUSH
32109: EMPTY
32110: LIST
32111: LIST
32112: PUSH
32113: LD_INT 1
32115: NEG
32116: PUSH
32117: LD_INT 2
32119: NEG
32120: PUSH
32121: EMPTY
32122: LIST
32123: LIST
32124: PUSH
32125: LD_INT 0
32127: PUSH
32128: LD_INT 2
32130: NEG
32131: PUSH
32132: EMPTY
32133: LIST
32134: LIST
32135: PUSH
32136: LD_INT 1
32138: PUSH
32139: LD_INT 1
32141: NEG
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: PUSH
32147: LD_INT 2
32149: PUSH
32150: LD_INT 0
32152: PUSH
32153: EMPTY
32154: LIST
32155: LIST
32156: PUSH
32157: LD_INT 2
32159: PUSH
32160: LD_INT 1
32162: PUSH
32163: EMPTY
32164: LIST
32165: LIST
32166: PUSH
32167: LD_INT 2
32169: PUSH
32170: LD_INT 2
32172: PUSH
32173: EMPTY
32174: LIST
32175: LIST
32176: PUSH
32177: LD_INT 1
32179: PUSH
32180: LD_INT 2
32182: PUSH
32183: EMPTY
32184: LIST
32185: LIST
32186: PUSH
32187: LD_INT 0
32189: PUSH
32190: LD_INT 2
32192: PUSH
32193: EMPTY
32194: LIST
32195: LIST
32196: PUSH
32197: LD_INT 1
32199: NEG
32200: PUSH
32201: LD_INT 1
32203: PUSH
32204: EMPTY
32205: LIST
32206: LIST
32207: PUSH
32208: LD_INT 2
32210: NEG
32211: PUSH
32212: LD_INT 0
32214: PUSH
32215: EMPTY
32216: LIST
32217: LIST
32218: PUSH
32219: LD_INT 2
32221: NEG
32222: PUSH
32223: LD_INT 1
32225: NEG
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 2
32233: NEG
32234: PUSH
32235: LD_INT 2
32237: NEG
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: LIST
32247: LIST
32248: LIST
32249: LIST
32250: LIST
32251: LIST
32252: LIST
32253: LIST
32254: LIST
32255: LIST
32256: LIST
32257: LIST
32258: LIST
32259: LIST
32260: LIST
32261: LIST
32262: LIST
32263: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32264: LD_ADDR_VAR 0 21
32268: PUSH
32269: LD_INT 0
32271: PUSH
32272: LD_INT 0
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PUSH
32279: LD_INT 0
32281: PUSH
32282: LD_INT 1
32284: NEG
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: LD_INT 1
32292: PUSH
32293: LD_INT 0
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PUSH
32300: LD_INT 1
32302: PUSH
32303: LD_INT 1
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: LD_INT 0
32312: PUSH
32313: LD_INT 1
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: LD_INT 1
32322: NEG
32323: PUSH
32324: LD_INT 0
32326: PUSH
32327: EMPTY
32328: LIST
32329: LIST
32330: PUSH
32331: LD_INT 1
32333: NEG
32334: PUSH
32335: LD_INT 1
32337: NEG
32338: PUSH
32339: EMPTY
32340: LIST
32341: LIST
32342: PUSH
32343: LD_INT 1
32345: NEG
32346: PUSH
32347: LD_INT 2
32349: NEG
32350: PUSH
32351: EMPTY
32352: LIST
32353: LIST
32354: PUSH
32355: LD_INT 0
32357: PUSH
32358: LD_INT 2
32360: NEG
32361: PUSH
32362: EMPTY
32363: LIST
32364: LIST
32365: PUSH
32366: LD_INT 1
32368: PUSH
32369: LD_INT 1
32371: NEG
32372: PUSH
32373: EMPTY
32374: LIST
32375: LIST
32376: PUSH
32377: LD_INT 2
32379: PUSH
32380: LD_INT 0
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: LD_INT 2
32389: PUSH
32390: LD_INT 1
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: LD_INT 2
32399: PUSH
32400: LD_INT 2
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PUSH
32407: LD_INT 1
32409: PUSH
32410: LD_INT 2
32412: PUSH
32413: EMPTY
32414: LIST
32415: LIST
32416: PUSH
32417: LD_INT 0
32419: PUSH
32420: LD_INT 2
32422: PUSH
32423: EMPTY
32424: LIST
32425: LIST
32426: PUSH
32427: LD_INT 1
32429: NEG
32430: PUSH
32431: LD_INT 1
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: PUSH
32438: LD_INT 2
32440: NEG
32441: PUSH
32442: LD_INT 0
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: LD_INT 2
32451: NEG
32452: PUSH
32453: LD_INT 1
32455: NEG
32456: PUSH
32457: EMPTY
32458: LIST
32459: LIST
32460: PUSH
32461: LD_INT 2
32463: NEG
32464: PUSH
32465: LD_INT 2
32467: NEG
32468: PUSH
32469: EMPTY
32470: LIST
32471: LIST
32472: PUSH
32473: EMPTY
32474: LIST
32475: LIST
32476: LIST
32477: LIST
32478: LIST
32479: LIST
32480: LIST
32481: LIST
32482: LIST
32483: LIST
32484: LIST
32485: LIST
32486: LIST
32487: LIST
32488: LIST
32489: LIST
32490: LIST
32491: LIST
32492: LIST
32493: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32494: LD_ADDR_VAR 0 22
32498: PUSH
32499: LD_INT 0
32501: PUSH
32502: LD_INT 0
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 0
32511: PUSH
32512: LD_INT 1
32514: NEG
32515: PUSH
32516: EMPTY
32517: LIST
32518: LIST
32519: PUSH
32520: LD_INT 1
32522: PUSH
32523: LD_INT 0
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 1
32532: PUSH
32533: LD_INT 1
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: LD_INT 0
32542: PUSH
32543: LD_INT 1
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: LD_INT 1
32552: NEG
32553: PUSH
32554: LD_INT 0
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PUSH
32561: LD_INT 1
32563: NEG
32564: PUSH
32565: LD_INT 1
32567: NEG
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: LD_INT 1
32575: NEG
32576: PUSH
32577: LD_INT 2
32579: NEG
32580: PUSH
32581: EMPTY
32582: LIST
32583: LIST
32584: PUSH
32585: LD_INT 0
32587: PUSH
32588: LD_INT 2
32590: NEG
32591: PUSH
32592: EMPTY
32593: LIST
32594: LIST
32595: PUSH
32596: LD_INT 1
32598: PUSH
32599: LD_INT 1
32601: NEG
32602: PUSH
32603: EMPTY
32604: LIST
32605: LIST
32606: PUSH
32607: LD_INT 2
32609: PUSH
32610: LD_INT 0
32612: PUSH
32613: EMPTY
32614: LIST
32615: LIST
32616: PUSH
32617: LD_INT 2
32619: PUSH
32620: LD_INT 1
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 2
32629: PUSH
32630: LD_INT 2
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: PUSH
32637: LD_INT 1
32639: PUSH
32640: LD_INT 2
32642: PUSH
32643: EMPTY
32644: LIST
32645: LIST
32646: PUSH
32647: LD_INT 0
32649: PUSH
32650: LD_INT 2
32652: PUSH
32653: EMPTY
32654: LIST
32655: LIST
32656: PUSH
32657: LD_INT 1
32659: NEG
32660: PUSH
32661: LD_INT 1
32663: PUSH
32664: EMPTY
32665: LIST
32666: LIST
32667: PUSH
32668: LD_INT 2
32670: NEG
32671: PUSH
32672: LD_INT 0
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: PUSH
32679: LD_INT 2
32681: NEG
32682: PUSH
32683: LD_INT 1
32685: NEG
32686: PUSH
32687: EMPTY
32688: LIST
32689: LIST
32690: PUSH
32691: LD_INT 2
32693: NEG
32694: PUSH
32695: LD_INT 2
32697: NEG
32698: PUSH
32699: EMPTY
32700: LIST
32701: LIST
32702: PUSH
32703: EMPTY
32704: LIST
32705: LIST
32706: LIST
32707: LIST
32708: LIST
32709: LIST
32710: LIST
32711: LIST
32712: LIST
32713: LIST
32714: LIST
32715: LIST
32716: LIST
32717: LIST
32718: LIST
32719: LIST
32720: LIST
32721: LIST
32722: LIST
32723: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
32724: LD_ADDR_VAR 0 23
32728: PUSH
32729: LD_INT 0
32731: PUSH
32732: LD_INT 0
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: PUSH
32739: LD_INT 0
32741: PUSH
32742: LD_INT 1
32744: NEG
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: PUSH
32750: LD_INT 1
32752: PUSH
32753: LD_INT 0
32755: PUSH
32756: EMPTY
32757: LIST
32758: LIST
32759: PUSH
32760: LD_INT 1
32762: PUSH
32763: LD_INT 1
32765: PUSH
32766: EMPTY
32767: LIST
32768: LIST
32769: PUSH
32770: LD_INT 0
32772: PUSH
32773: LD_INT 1
32775: PUSH
32776: EMPTY
32777: LIST
32778: LIST
32779: PUSH
32780: LD_INT 1
32782: NEG
32783: PUSH
32784: LD_INT 0
32786: PUSH
32787: EMPTY
32788: LIST
32789: LIST
32790: PUSH
32791: LD_INT 1
32793: NEG
32794: PUSH
32795: LD_INT 1
32797: NEG
32798: PUSH
32799: EMPTY
32800: LIST
32801: LIST
32802: PUSH
32803: LD_INT 1
32805: NEG
32806: PUSH
32807: LD_INT 2
32809: NEG
32810: PUSH
32811: EMPTY
32812: LIST
32813: LIST
32814: PUSH
32815: LD_INT 0
32817: PUSH
32818: LD_INT 2
32820: NEG
32821: PUSH
32822: EMPTY
32823: LIST
32824: LIST
32825: PUSH
32826: LD_INT 1
32828: PUSH
32829: LD_INT 1
32831: NEG
32832: PUSH
32833: EMPTY
32834: LIST
32835: LIST
32836: PUSH
32837: LD_INT 2
32839: PUSH
32840: LD_INT 0
32842: PUSH
32843: EMPTY
32844: LIST
32845: LIST
32846: PUSH
32847: LD_INT 2
32849: PUSH
32850: LD_INT 1
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 2
32859: PUSH
32860: LD_INT 2
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PUSH
32867: LD_INT 1
32869: PUSH
32870: LD_INT 2
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PUSH
32877: LD_INT 0
32879: PUSH
32880: LD_INT 2
32882: PUSH
32883: EMPTY
32884: LIST
32885: LIST
32886: PUSH
32887: LD_INT 1
32889: NEG
32890: PUSH
32891: LD_INT 1
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: PUSH
32898: LD_INT 2
32900: NEG
32901: PUSH
32902: LD_INT 0
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: LD_INT 2
32911: NEG
32912: PUSH
32913: LD_INT 1
32915: NEG
32916: PUSH
32917: EMPTY
32918: LIST
32919: LIST
32920: PUSH
32921: LD_INT 2
32923: NEG
32924: PUSH
32925: LD_INT 2
32927: NEG
32928: PUSH
32929: EMPTY
32930: LIST
32931: LIST
32932: PUSH
32933: LD_INT 2
32935: NEG
32936: PUSH
32937: LD_INT 3
32939: NEG
32940: PUSH
32941: EMPTY
32942: LIST
32943: LIST
32944: PUSH
32945: LD_INT 1
32947: NEG
32948: PUSH
32949: LD_INT 3
32951: NEG
32952: PUSH
32953: EMPTY
32954: LIST
32955: LIST
32956: PUSH
32957: LD_INT 1
32959: PUSH
32960: LD_INT 2
32962: NEG
32963: PUSH
32964: EMPTY
32965: LIST
32966: LIST
32967: PUSH
32968: LD_INT 2
32970: PUSH
32971: LD_INT 1
32973: NEG
32974: PUSH
32975: EMPTY
32976: LIST
32977: LIST
32978: PUSH
32979: EMPTY
32980: LIST
32981: LIST
32982: LIST
32983: LIST
32984: LIST
32985: LIST
32986: LIST
32987: LIST
32988: LIST
32989: LIST
32990: LIST
32991: LIST
32992: LIST
32993: LIST
32994: LIST
32995: LIST
32996: LIST
32997: LIST
32998: LIST
32999: LIST
33000: LIST
33001: LIST
33002: LIST
33003: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
33004: LD_ADDR_VAR 0 24
33008: PUSH
33009: LD_INT 0
33011: PUSH
33012: LD_INT 0
33014: PUSH
33015: EMPTY
33016: LIST
33017: LIST
33018: PUSH
33019: LD_INT 0
33021: PUSH
33022: LD_INT 1
33024: NEG
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: LD_INT 1
33032: PUSH
33033: LD_INT 0
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: LD_INT 1
33042: PUSH
33043: LD_INT 1
33045: PUSH
33046: EMPTY
33047: LIST
33048: LIST
33049: PUSH
33050: LD_INT 0
33052: PUSH
33053: LD_INT 1
33055: PUSH
33056: EMPTY
33057: LIST
33058: LIST
33059: PUSH
33060: LD_INT 1
33062: NEG
33063: PUSH
33064: LD_INT 0
33066: PUSH
33067: EMPTY
33068: LIST
33069: LIST
33070: PUSH
33071: LD_INT 1
33073: NEG
33074: PUSH
33075: LD_INT 1
33077: NEG
33078: PUSH
33079: EMPTY
33080: LIST
33081: LIST
33082: PUSH
33083: LD_INT 1
33085: NEG
33086: PUSH
33087: LD_INT 2
33089: NEG
33090: PUSH
33091: EMPTY
33092: LIST
33093: LIST
33094: PUSH
33095: LD_INT 0
33097: PUSH
33098: LD_INT 2
33100: NEG
33101: PUSH
33102: EMPTY
33103: LIST
33104: LIST
33105: PUSH
33106: LD_INT 1
33108: PUSH
33109: LD_INT 1
33111: NEG
33112: PUSH
33113: EMPTY
33114: LIST
33115: LIST
33116: PUSH
33117: LD_INT 2
33119: PUSH
33120: LD_INT 0
33122: PUSH
33123: EMPTY
33124: LIST
33125: LIST
33126: PUSH
33127: LD_INT 2
33129: PUSH
33130: LD_INT 1
33132: PUSH
33133: EMPTY
33134: LIST
33135: LIST
33136: PUSH
33137: LD_INT 2
33139: PUSH
33140: LD_INT 2
33142: PUSH
33143: EMPTY
33144: LIST
33145: LIST
33146: PUSH
33147: LD_INT 1
33149: PUSH
33150: LD_INT 2
33152: PUSH
33153: EMPTY
33154: LIST
33155: LIST
33156: PUSH
33157: LD_INT 0
33159: PUSH
33160: LD_INT 2
33162: PUSH
33163: EMPTY
33164: LIST
33165: LIST
33166: PUSH
33167: LD_INT 1
33169: NEG
33170: PUSH
33171: LD_INT 1
33173: PUSH
33174: EMPTY
33175: LIST
33176: LIST
33177: PUSH
33178: LD_INT 2
33180: NEG
33181: PUSH
33182: LD_INT 0
33184: PUSH
33185: EMPTY
33186: LIST
33187: LIST
33188: PUSH
33189: LD_INT 2
33191: NEG
33192: PUSH
33193: LD_INT 1
33195: NEG
33196: PUSH
33197: EMPTY
33198: LIST
33199: LIST
33200: PUSH
33201: LD_INT 2
33203: NEG
33204: PUSH
33205: LD_INT 2
33207: NEG
33208: PUSH
33209: EMPTY
33210: LIST
33211: LIST
33212: PUSH
33213: LD_INT 1
33215: PUSH
33216: LD_INT 2
33218: NEG
33219: PUSH
33220: EMPTY
33221: LIST
33222: LIST
33223: PUSH
33224: LD_INT 2
33226: PUSH
33227: LD_INT 1
33229: NEG
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: PUSH
33235: LD_INT 3
33237: PUSH
33238: LD_INT 1
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 3
33247: PUSH
33248: LD_INT 2
33250: PUSH
33251: EMPTY
33252: LIST
33253: LIST
33254: PUSH
33255: EMPTY
33256: LIST
33257: LIST
33258: LIST
33259: LIST
33260: LIST
33261: LIST
33262: LIST
33263: LIST
33264: LIST
33265: LIST
33266: LIST
33267: LIST
33268: LIST
33269: LIST
33270: LIST
33271: LIST
33272: LIST
33273: LIST
33274: LIST
33275: LIST
33276: LIST
33277: LIST
33278: LIST
33279: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
33280: LD_ADDR_VAR 0 25
33284: PUSH
33285: LD_INT 0
33287: PUSH
33288: LD_INT 0
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PUSH
33295: LD_INT 0
33297: PUSH
33298: LD_INT 1
33300: NEG
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: PUSH
33306: LD_INT 1
33308: PUSH
33309: LD_INT 0
33311: PUSH
33312: EMPTY
33313: LIST
33314: LIST
33315: PUSH
33316: LD_INT 1
33318: PUSH
33319: LD_INT 1
33321: PUSH
33322: EMPTY
33323: LIST
33324: LIST
33325: PUSH
33326: LD_INT 0
33328: PUSH
33329: LD_INT 1
33331: PUSH
33332: EMPTY
33333: LIST
33334: LIST
33335: PUSH
33336: LD_INT 1
33338: NEG
33339: PUSH
33340: LD_INT 0
33342: PUSH
33343: EMPTY
33344: LIST
33345: LIST
33346: PUSH
33347: LD_INT 1
33349: NEG
33350: PUSH
33351: LD_INT 1
33353: NEG
33354: PUSH
33355: EMPTY
33356: LIST
33357: LIST
33358: PUSH
33359: LD_INT 1
33361: NEG
33362: PUSH
33363: LD_INT 2
33365: NEG
33366: PUSH
33367: EMPTY
33368: LIST
33369: LIST
33370: PUSH
33371: LD_INT 0
33373: PUSH
33374: LD_INT 2
33376: NEG
33377: PUSH
33378: EMPTY
33379: LIST
33380: LIST
33381: PUSH
33382: LD_INT 1
33384: PUSH
33385: LD_INT 1
33387: NEG
33388: PUSH
33389: EMPTY
33390: LIST
33391: LIST
33392: PUSH
33393: LD_INT 2
33395: PUSH
33396: LD_INT 0
33398: PUSH
33399: EMPTY
33400: LIST
33401: LIST
33402: PUSH
33403: LD_INT 2
33405: PUSH
33406: LD_INT 1
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 2
33415: PUSH
33416: LD_INT 2
33418: PUSH
33419: EMPTY
33420: LIST
33421: LIST
33422: PUSH
33423: LD_INT 1
33425: PUSH
33426: LD_INT 2
33428: PUSH
33429: EMPTY
33430: LIST
33431: LIST
33432: PUSH
33433: LD_INT 0
33435: PUSH
33436: LD_INT 2
33438: PUSH
33439: EMPTY
33440: LIST
33441: LIST
33442: PUSH
33443: LD_INT 1
33445: NEG
33446: PUSH
33447: LD_INT 1
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: LD_INT 2
33456: NEG
33457: PUSH
33458: LD_INT 0
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 2
33467: NEG
33468: PUSH
33469: LD_INT 1
33471: NEG
33472: PUSH
33473: EMPTY
33474: LIST
33475: LIST
33476: PUSH
33477: LD_INT 2
33479: NEG
33480: PUSH
33481: LD_INT 2
33483: NEG
33484: PUSH
33485: EMPTY
33486: LIST
33487: LIST
33488: PUSH
33489: LD_INT 3
33491: PUSH
33492: LD_INT 1
33494: PUSH
33495: EMPTY
33496: LIST
33497: LIST
33498: PUSH
33499: LD_INT 3
33501: PUSH
33502: LD_INT 2
33504: PUSH
33505: EMPTY
33506: LIST
33507: LIST
33508: PUSH
33509: LD_INT 2
33511: PUSH
33512: LD_INT 3
33514: PUSH
33515: EMPTY
33516: LIST
33517: LIST
33518: PUSH
33519: LD_INT 1
33521: PUSH
33522: LD_INT 3
33524: PUSH
33525: EMPTY
33526: LIST
33527: LIST
33528: PUSH
33529: EMPTY
33530: LIST
33531: LIST
33532: LIST
33533: LIST
33534: LIST
33535: LIST
33536: LIST
33537: LIST
33538: LIST
33539: LIST
33540: LIST
33541: LIST
33542: LIST
33543: LIST
33544: LIST
33545: LIST
33546: LIST
33547: LIST
33548: LIST
33549: LIST
33550: LIST
33551: LIST
33552: LIST
33553: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
33554: LD_ADDR_VAR 0 26
33558: PUSH
33559: LD_INT 0
33561: PUSH
33562: LD_INT 0
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: LD_INT 0
33571: PUSH
33572: LD_INT 1
33574: NEG
33575: PUSH
33576: EMPTY
33577: LIST
33578: LIST
33579: PUSH
33580: LD_INT 1
33582: PUSH
33583: LD_INT 0
33585: PUSH
33586: EMPTY
33587: LIST
33588: LIST
33589: PUSH
33590: LD_INT 1
33592: PUSH
33593: LD_INT 1
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: PUSH
33600: LD_INT 0
33602: PUSH
33603: LD_INT 1
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: PUSH
33610: LD_INT 1
33612: NEG
33613: PUSH
33614: LD_INT 0
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: PUSH
33621: LD_INT 1
33623: NEG
33624: PUSH
33625: LD_INT 1
33627: NEG
33628: PUSH
33629: EMPTY
33630: LIST
33631: LIST
33632: PUSH
33633: LD_INT 1
33635: NEG
33636: PUSH
33637: LD_INT 2
33639: NEG
33640: PUSH
33641: EMPTY
33642: LIST
33643: LIST
33644: PUSH
33645: LD_INT 0
33647: PUSH
33648: LD_INT 2
33650: NEG
33651: PUSH
33652: EMPTY
33653: LIST
33654: LIST
33655: PUSH
33656: LD_INT 1
33658: PUSH
33659: LD_INT 1
33661: NEG
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_INT 2
33669: PUSH
33670: LD_INT 0
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: LD_INT 2
33679: PUSH
33680: LD_INT 1
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PUSH
33687: LD_INT 2
33689: PUSH
33690: LD_INT 2
33692: PUSH
33693: EMPTY
33694: LIST
33695: LIST
33696: PUSH
33697: LD_INT 1
33699: PUSH
33700: LD_INT 2
33702: PUSH
33703: EMPTY
33704: LIST
33705: LIST
33706: PUSH
33707: LD_INT 0
33709: PUSH
33710: LD_INT 2
33712: PUSH
33713: EMPTY
33714: LIST
33715: LIST
33716: PUSH
33717: LD_INT 1
33719: NEG
33720: PUSH
33721: LD_INT 1
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 2
33730: NEG
33731: PUSH
33732: LD_INT 0
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 2
33741: NEG
33742: PUSH
33743: LD_INT 1
33745: NEG
33746: PUSH
33747: EMPTY
33748: LIST
33749: LIST
33750: PUSH
33751: LD_INT 2
33753: NEG
33754: PUSH
33755: LD_INT 2
33757: NEG
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 2
33765: PUSH
33766: LD_INT 3
33768: PUSH
33769: EMPTY
33770: LIST
33771: LIST
33772: PUSH
33773: LD_INT 1
33775: PUSH
33776: LD_INT 3
33778: PUSH
33779: EMPTY
33780: LIST
33781: LIST
33782: PUSH
33783: LD_INT 1
33785: NEG
33786: PUSH
33787: LD_INT 2
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: LD_INT 2
33796: NEG
33797: PUSH
33798: LD_INT 1
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: LIST
33809: LIST
33810: LIST
33811: LIST
33812: LIST
33813: LIST
33814: LIST
33815: LIST
33816: LIST
33817: LIST
33818: LIST
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: LIST
33825: LIST
33826: LIST
33827: LIST
33828: LIST
33829: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33830: LD_ADDR_VAR 0 27
33834: PUSH
33835: LD_INT 0
33837: PUSH
33838: LD_INT 0
33840: PUSH
33841: EMPTY
33842: LIST
33843: LIST
33844: PUSH
33845: LD_INT 0
33847: PUSH
33848: LD_INT 1
33850: NEG
33851: PUSH
33852: EMPTY
33853: LIST
33854: LIST
33855: PUSH
33856: LD_INT 1
33858: PUSH
33859: LD_INT 0
33861: PUSH
33862: EMPTY
33863: LIST
33864: LIST
33865: PUSH
33866: LD_INT 1
33868: PUSH
33869: LD_INT 1
33871: PUSH
33872: EMPTY
33873: LIST
33874: LIST
33875: PUSH
33876: LD_INT 0
33878: PUSH
33879: LD_INT 1
33881: PUSH
33882: EMPTY
33883: LIST
33884: LIST
33885: PUSH
33886: LD_INT 1
33888: NEG
33889: PUSH
33890: LD_INT 0
33892: PUSH
33893: EMPTY
33894: LIST
33895: LIST
33896: PUSH
33897: LD_INT 1
33899: NEG
33900: PUSH
33901: LD_INT 1
33903: NEG
33904: PUSH
33905: EMPTY
33906: LIST
33907: LIST
33908: PUSH
33909: LD_INT 1
33911: NEG
33912: PUSH
33913: LD_INT 2
33915: NEG
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: PUSH
33921: LD_INT 0
33923: PUSH
33924: LD_INT 2
33926: NEG
33927: PUSH
33928: EMPTY
33929: LIST
33930: LIST
33931: PUSH
33932: LD_INT 1
33934: PUSH
33935: LD_INT 1
33937: NEG
33938: PUSH
33939: EMPTY
33940: LIST
33941: LIST
33942: PUSH
33943: LD_INT 2
33945: PUSH
33946: LD_INT 0
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: PUSH
33953: LD_INT 2
33955: PUSH
33956: LD_INT 1
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: LD_INT 2
33965: PUSH
33966: LD_INT 2
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: LD_INT 1
33975: PUSH
33976: LD_INT 2
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 0
33985: PUSH
33986: LD_INT 2
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 1
33995: NEG
33996: PUSH
33997: LD_INT 1
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 2
34006: NEG
34007: PUSH
34008: LD_INT 0
34010: PUSH
34011: EMPTY
34012: LIST
34013: LIST
34014: PUSH
34015: LD_INT 2
34017: NEG
34018: PUSH
34019: LD_INT 1
34021: NEG
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: LD_INT 2
34029: NEG
34030: PUSH
34031: LD_INT 2
34033: NEG
34034: PUSH
34035: EMPTY
34036: LIST
34037: LIST
34038: PUSH
34039: LD_INT 1
34041: NEG
34042: PUSH
34043: LD_INT 2
34045: PUSH
34046: EMPTY
34047: LIST
34048: LIST
34049: PUSH
34050: LD_INT 2
34052: NEG
34053: PUSH
34054: LD_INT 1
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PUSH
34061: LD_INT 3
34063: NEG
34064: PUSH
34065: LD_INT 1
34067: NEG
34068: PUSH
34069: EMPTY
34070: LIST
34071: LIST
34072: PUSH
34073: LD_INT 3
34075: NEG
34076: PUSH
34077: LD_INT 2
34079: NEG
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: LIST
34091: LIST
34092: LIST
34093: LIST
34094: LIST
34095: LIST
34096: LIST
34097: LIST
34098: LIST
34099: LIST
34100: LIST
34101: LIST
34102: LIST
34103: LIST
34104: LIST
34105: LIST
34106: LIST
34107: LIST
34108: LIST
34109: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34110: LD_ADDR_VAR 0 28
34114: PUSH
34115: LD_INT 0
34117: PUSH
34118: LD_INT 0
34120: PUSH
34121: EMPTY
34122: LIST
34123: LIST
34124: PUSH
34125: LD_INT 0
34127: PUSH
34128: LD_INT 1
34130: NEG
34131: PUSH
34132: EMPTY
34133: LIST
34134: LIST
34135: PUSH
34136: LD_INT 1
34138: PUSH
34139: LD_INT 0
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: LD_INT 1
34148: PUSH
34149: LD_INT 1
34151: PUSH
34152: EMPTY
34153: LIST
34154: LIST
34155: PUSH
34156: LD_INT 0
34158: PUSH
34159: LD_INT 1
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: PUSH
34166: LD_INT 1
34168: NEG
34169: PUSH
34170: LD_INT 0
34172: PUSH
34173: EMPTY
34174: LIST
34175: LIST
34176: PUSH
34177: LD_INT 1
34179: NEG
34180: PUSH
34181: LD_INT 1
34183: NEG
34184: PUSH
34185: EMPTY
34186: LIST
34187: LIST
34188: PUSH
34189: LD_INT 1
34191: NEG
34192: PUSH
34193: LD_INT 2
34195: NEG
34196: PUSH
34197: EMPTY
34198: LIST
34199: LIST
34200: PUSH
34201: LD_INT 0
34203: PUSH
34204: LD_INT 2
34206: NEG
34207: PUSH
34208: EMPTY
34209: LIST
34210: LIST
34211: PUSH
34212: LD_INT 1
34214: PUSH
34215: LD_INT 1
34217: NEG
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 2
34225: PUSH
34226: LD_INT 0
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: LD_INT 2
34235: PUSH
34236: LD_INT 1
34238: PUSH
34239: EMPTY
34240: LIST
34241: LIST
34242: PUSH
34243: LD_INT 2
34245: PUSH
34246: LD_INT 2
34248: PUSH
34249: EMPTY
34250: LIST
34251: LIST
34252: PUSH
34253: LD_INT 1
34255: PUSH
34256: LD_INT 2
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: PUSH
34263: LD_INT 0
34265: PUSH
34266: LD_INT 2
34268: PUSH
34269: EMPTY
34270: LIST
34271: LIST
34272: PUSH
34273: LD_INT 1
34275: NEG
34276: PUSH
34277: LD_INT 1
34279: PUSH
34280: EMPTY
34281: LIST
34282: LIST
34283: PUSH
34284: LD_INT 2
34286: NEG
34287: PUSH
34288: LD_INT 0
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 2
34297: NEG
34298: PUSH
34299: LD_INT 1
34301: NEG
34302: PUSH
34303: EMPTY
34304: LIST
34305: LIST
34306: PUSH
34307: LD_INT 2
34309: NEG
34310: PUSH
34311: LD_INT 2
34313: NEG
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 2
34321: NEG
34322: PUSH
34323: LD_INT 3
34325: NEG
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 1
34333: NEG
34334: PUSH
34335: LD_INT 3
34337: NEG
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: PUSH
34343: LD_INT 3
34345: NEG
34346: PUSH
34347: LD_INT 1
34349: NEG
34350: PUSH
34351: EMPTY
34352: LIST
34353: LIST
34354: PUSH
34355: LD_INT 3
34357: NEG
34358: PUSH
34359: LD_INT 2
34361: NEG
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: EMPTY
34368: LIST
34369: LIST
34370: LIST
34371: LIST
34372: LIST
34373: LIST
34374: LIST
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: LIST
34381: LIST
34382: LIST
34383: LIST
34384: LIST
34385: LIST
34386: LIST
34387: LIST
34388: LIST
34389: LIST
34390: LIST
34391: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34392: LD_ADDR_VAR 0 29
34396: PUSH
34397: LD_INT 0
34399: PUSH
34400: LD_INT 0
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PUSH
34407: LD_INT 0
34409: PUSH
34410: LD_INT 1
34412: NEG
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: PUSH
34418: LD_INT 1
34420: PUSH
34421: LD_INT 0
34423: PUSH
34424: EMPTY
34425: LIST
34426: LIST
34427: PUSH
34428: LD_INT 1
34430: PUSH
34431: LD_INT 1
34433: PUSH
34434: EMPTY
34435: LIST
34436: LIST
34437: PUSH
34438: LD_INT 0
34440: PUSH
34441: LD_INT 1
34443: PUSH
34444: EMPTY
34445: LIST
34446: LIST
34447: PUSH
34448: LD_INT 1
34450: NEG
34451: PUSH
34452: LD_INT 0
34454: PUSH
34455: EMPTY
34456: LIST
34457: LIST
34458: PUSH
34459: LD_INT 1
34461: NEG
34462: PUSH
34463: LD_INT 1
34465: NEG
34466: PUSH
34467: EMPTY
34468: LIST
34469: LIST
34470: PUSH
34471: LD_INT 1
34473: NEG
34474: PUSH
34475: LD_INT 2
34477: NEG
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PUSH
34483: LD_INT 0
34485: PUSH
34486: LD_INT 2
34488: NEG
34489: PUSH
34490: EMPTY
34491: LIST
34492: LIST
34493: PUSH
34494: LD_INT 1
34496: PUSH
34497: LD_INT 1
34499: NEG
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 2
34507: PUSH
34508: LD_INT 0
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 2
34517: PUSH
34518: LD_INT 1
34520: PUSH
34521: EMPTY
34522: LIST
34523: LIST
34524: PUSH
34525: LD_INT 1
34527: PUSH
34528: LD_INT 2
34530: PUSH
34531: EMPTY
34532: LIST
34533: LIST
34534: PUSH
34535: LD_INT 0
34537: PUSH
34538: LD_INT 2
34540: PUSH
34541: EMPTY
34542: LIST
34543: LIST
34544: PUSH
34545: LD_INT 1
34547: NEG
34548: PUSH
34549: LD_INT 1
34551: PUSH
34552: EMPTY
34553: LIST
34554: LIST
34555: PUSH
34556: LD_INT 2
34558: NEG
34559: PUSH
34560: LD_INT 1
34562: NEG
34563: PUSH
34564: EMPTY
34565: LIST
34566: LIST
34567: PUSH
34568: LD_INT 2
34570: NEG
34571: PUSH
34572: LD_INT 2
34574: NEG
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: LD_INT 2
34582: NEG
34583: PUSH
34584: LD_INT 3
34586: NEG
34587: PUSH
34588: EMPTY
34589: LIST
34590: LIST
34591: PUSH
34592: LD_INT 2
34594: PUSH
34595: LD_INT 1
34597: NEG
34598: PUSH
34599: EMPTY
34600: LIST
34601: LIST
34602: PUSH
34603: LD_INT 3
34605: PUSH
34606: LD_INT 1
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 1
34615: PUSH
34616: LD_INT 3
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: PUSH
34623: LD_INT 1
34625: NEG
34626: PUSH
34627: LD_INT 2
34629: PUSH
34630: EMPTY
34631: LIST
34632: LIST
34633: PUSH
34634: LD_INT 3
34636: NEG
34637: PUSH
34638: LD_INT 2
34640: NEG
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: EMPTY
34647: LIST
34648: LIST
34649: LIST
34650: LIST
34651: LIST
34652: LIST
34653: LIST
34654: LIST
34655: LIST
34656: LIST
34657: LIST
34658: LIST
34659: LIST
34660: LIST
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34671: LD_ADDR_VAR 0 30
34675: PUSH
34676: LD_INT 0
34678: PUSH
34679: LD_INT 0
34681: PUSH
34682: EMPTY
34683: LIST
34684: LIST
34685: PUSH
34686: LD_INT 0
34688: PUSH
34689: LD_INT 1
34691: NEG
34692: PUSH
34693: EMPTY
34694: LIST
34695: LIST
34696: PUSH
34697: LD_INT 1
34699: PUSH
34700: LD_INT 0
34702: PUSH
34703: EMPTY
34704: LIST
34705: LIST
34706: PUSH
34707: LD_INT 1
34709: PUSH
34710: LD_INT 1
34712: PUSH
34713: EMPTY
34714: LIST
34715: LIST
34716: PUSH
34717: LD_INT 0
34719: PUSH
34720: LD_INT 1
34722: PUSH
34723: EMPTY
34724: LIST
34725: LIST
34726: PUSH
34727: LD_INT 1
34729: NEG
34730: PUSH
34731: LD_INT 0
34733: PUSH
34734: EMPTY
34735: LIST
34736: LIST
34737: PUSH
34738: LD_INT 1
34740: NEG
34741: PUSH
34742: LD_INT 1
34744: NEG
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 1
34752: NEG
34753: PUSH
34754: LD_INT 2
34756: NEG
34757: PUSH
34758: EMPTY
34759: LIST
34760: LIST
34761: PUSH
34762: LD_INT 0
34764: PUSH
34765: LD_INT 2
34767: NEG
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 1
34775: PUSH
34776: LD_INT 1
34778: NEG
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 2
34786: PUSH
34787: LD_INT 0
34789: PUSH
34790: EMPTY
34791: LIST
34792: LIST
34793: PUSH
34794: LD_INT 2
34796: PUSH
34797: LD_INT 1
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: PUSH
34804: LD_INT 2
34806: PUSH
34807: LD_INT 2
34809: PUSH
34810: EMPTY
34811: LIST
34812: LIST
34813: PUSH
34814: LD_INT 1
34816: PUSH
34817: LD_INT 2
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: PUSH
34824: LD_INT 1
34826: NEG
34827: PUSH
34828: LD_INT 1
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PUSH
34835: LD_INT 2
34837: NEG
34838: PUSH
34839: LD_INT 0
34841: PUSH
34842: EMPTY
34843: LIST
34844: LIST
34845: PUSH
34846: LD_INT 2
34848: NEG
34849: PUSH
34850: LD_INT 1
34852: NEG
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 1
34860: NEG
34861: PUSH
34862: LD_INT 3
34864: NEG
34865: PUSH
34866: EMPTY
34867: LIST
34868: LIST
34869: PUSH
34870: LD_INT 1
34872: PUSH
34873: LD_INT 2
34875: NEG
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: LD_INT 3
34883: PUSH
34884: LD_INT 2
34886: PUSH
34887: EMPTY
34888: LIST
34889: LIST
34890: PUSH
34891: LD_INT 2
34893: PUSH
34894: LD_INT 3
34896: PUSH
34897: EMPTY
34898: LIST
34899: LIST
34900: PUSH
34901: LD_INT 2
34903: NEG
34904: PUSH
34905: LD_INT 1
34907: PUSH
34908: EMPTY
34909: LIST
34910: LIST
34911: PUSH
34912: LD_INT 3
34914: NEG
34915: PUSH
34916: LD_INT 1
34918: NEG
34919: PUSH
34920: EMPTY
34921: LIST
34922: LIST
34923: PUSH
34924: EMPTY
34925: LIST
34926: LIST
34927: LIST
34928: LIST
34929: LIST
34930: LIST
34931: LIST
34932: LIST
34933: LIST
34934: LIST
34935: LIST
34936: LIST
34937: LIST
34938: LIST
34939: LIST
34940: LIST
34941: LIST
34942: LIST
34943: LIST
34944: LIST
34945: LIST
34946: LIST
34947: LIST
34948: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34949: LD_ADDR_VAR 0 31
34953: PUSH
34954: LD_INT 0
34956: PUSH
34957: LD_INT 0
34959: PUSH
34960: EMPTY
34961: LIST
34962: LIST
34963: PUSH
34964: LD_INT 0
34966: PUSH
34967: LD_INT 1
34969: NEG
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 1
34977: PUSH
34978: LD_INT 0
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 1
34987: PUSH
34988: LD_INT 1
34990: PUSH
34991: EMPTY
34992: LIST
34993: LIST
34994: PUSH
34995: LD_INT 0
34997: PUSH
34998: LD_INT 1
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PUSH
35005: LD_INT 1
35007: NEG
35008: PUSH
35009: LD_INT 0
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: LD_INT 1
35018: NEG
35019: PUSH
35020: LD_INT 1
35022: NEG
35023: PUSH
35024: EMPTY
35025: LIST
35026: LIST
35027: PUSH
35028: LD_INT 1
35030: NEG
35031: PUSH
35032: LD_INT 2
35034: NEG
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: PUSH
35040: LD_INT 1
35042: PUSH
35043: LD_INT 1
35045: NEG
35046: PUSH
35047: EMPTY
35048: LIST
35049: LIST
35050: PUSH
35051: LD_INT 2
35053: PUSH
35054: LD_INT 0
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: PUSH
35061: LD_INT 2
35063: PUSH
35064: LD_INT 1
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PUSH
35071: LD_INT 2
35073: PUSH
35074: LD_INT 2
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PUSH
35081: LD_INT 1
35083: PUSH
35084: LD_INT 2
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: PUSH
35091: LD_INT 0
35093: PUSH
35094: LD_INT 2
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: PUSH
35101: LD_INT 1
35103: NEG
35104: PUSH
35105: LD_INT 1
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: LD_INT 2
35114: NEG
35115: PUSH
35116: LD_INT 1
35118: NEG
35119: PUSH
35120: EMPTY
35121: LIST
35122: LIST
35123: PUSH
35124: LD_INT 2
35126: NEG
35127: PUSH
35128: LD_INT 2
35130: NEG
35131: PUSH
35132: EMPTY
35133: LIST
35134: LIST
35135: PUSH
35136: LD_INT 2
35138: NEG
35139: PUSH
35140: LD_INT 3
35142: NEG
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 2
35150: PUSH
35151: LD_INT 1
35153: NEG
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 3
35161: PUSH
35162: LD_INT 1
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 1
35171: PUSH
35172: LD_INT 3
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: LD_INT 1
35181: NEG
35182: PUSH
35183: LD_INT 2
35185: PUSH
35186: EMPTY
35187: LIST
35188: LIST
35189: PUSH
35190: LD_INT 3
35192: NEG
35193: PUSH
35194: LD_INT 2
35196: NEG
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: LIST
35206: LIST
35207: LIST
35208: LIST
35209: LIST
35210: LIST
35211: LIST
35212: LIST
35213: LIST
35214: LIST
35215: LIST
35216: LIST
35217: LIST
35218: LIST
35219: LIST
35220: LIST
35221: LIST
35222: LIST
35223: LIST
35224: LIST
35225: LIST
35226: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35227: LD_ADDR_VAR 0 32
35231: PUSH
35232: LD_INT 0
35234: PUSH
35235: LD_INT 0
35237: PUSH
35238: EMPTY
35239: LIST
35240: LIST
35241: PUSH
35242: LD_INT 0
35244: PUSH
35245: LD_INT 1
35247: NEG
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PUSH
35253: LD_INT 1
35255: PUSH
35256: LD_INT 0
35258: PUSH
35259: EMPTY
35260: LIST
35261: LIST
35262: PUSH
35263: LD_INT 1
35265: PUSH
35266: LD_INT 1
35268: PUSH
35269: EMPTY
35270: LIST
35271: LIST
35272: PUSH
35273: LD_INT 0
35275: PUSH
35276: LD_INT 1
35278: PUSH
35279: EMPTY
35280: LIST
35281: LIST
35282: PUSH
35283: LD_INT 1
35285: NEG
35286: PUSH
35287: LD_INT 0
35289: PUSH
35290: EMPTY
35291: LIST
35292: LIST
35293: PUSH
35294: LD_INT 1
35296: NEG
35297: PUSH
35298: LD_INT 1
35300: NEG
35301: PUSH
35302: EMPTY
35303: LIST
35304: LIST
35305: PUSH
35306: LD_INT 1
35308: NEG
35309: PUSH
35310: LD_INT 2
35312: NEG
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: PUSH
35318: LD_INT 0
35320: PUSH
35321: LD_INT 2
35323: NEG
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: PUSH
35329: LD_INT 1
35331: PUSH
35332: LD_INT 1
35334: NEG
35335: PUSH
35336: EMPTY
35337: LIST
35338: LIST
35339: PUSH
35340: LD_INT 2
35342: PUSH
35343: LD_INT 1
35345: PUSH
35346: EMPTY
35347: LIST
35348: LIST
35349: PUSH
35350: LD_INT 2
35352: PUSH
35353: LD_INT 2
35355: PUSH
35356: EMPTY
35357: LIST
35358: LIST
35359: PUSH
35360: LD_INT 1
35362: PUSH
35363: LD_INT 2
35365: PUSH
35366: EMPTY
35367: LIST
35368: LIST
35369: PUSH
35370: LD_INT 0
35372: PUSH
35373: LD_INT 2
35375: PUSH
35376: EMPTY
35377: LIST
35378: LIST
35379: PUSH
35380: LD_INT 1
35382: NEG
35383: PUSH
35384: LD_INT 1
35386: PUSH
35387: EMPTY
35388: LIST
35389: LIST
35390: PUSH
35391: LD_INT 2
35393: NEG
35394: PUSH
35395: LD_INT 0
35397: PUSH
35398: EMPTY
35399: LIST
35400: LIST
35401: PUSH
35402: LD_INT 2
35404: NEG
35405: PUSH
35406: LD_INT 1
35408: NEG
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 1
35416: NEG
35417: PUSH
35418: LD_INT 3
35420: NEG
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 1
35428: PUSH
35429: LD_INT 2
35431: NEG
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: LD_INT 3
35439: PUSH
35440: LD_INT 2
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: LD_INT 2
35449: PUSH
35450: LD_INT 3
35452: PUSH
35453: EMPTY
35454: LIST
35455: LIST
35456: PUSH
35457: LD_INT 2
35459: NEG
35460: PUSH
35461: LD_INT 1
35463: PUSH
35464: EMPTY
35465: LIST
35466: LIST
35467: PUSH
35468: LD_INT 3
35470: NEG
35471: PUSH
35472: LD_INT 1
35474: NEG
35475: PUSH
35476: EMPTY
35477: LIST
35478: LIST
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: LIST
35484: LIST
35485: LIST
35486: LIST
35487: LIST
35488: LIST
35489: LIST
35490: LIST
35491: LIST
35492: LIST
35493: LIST
35494: LIST
35495: LIST
35496: LIST
35497: LIST
35498: LIST
35499: LIST
35500: LIST
35501: LIST
35502: LIST
35503: LIST
35504: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35505: LD_ADDR_VAR 0 33
35509: PUSH
35510: LD_INT 0
35512: PUSH
35513: LD_INT 0
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: PUSH
35520: LD_INT 0
35522: PUSH
35523: LD_INT 1
35525: NEG
35526: PUSH
35527: EMPTY
35528: LIST
35529: LIST
35530: PUSH
35531: LD_INT 1
35533: PUSH
35534: LD_INT 0
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: PUSH
35541: LD_INT 1
35543: PUSH
35544: LD_INT 1
35546: PUSH
35547: EMPTY
35548: LIST
35549: LIST
35550: PUSH
35551: LD_INT 0
35553: PUSH
35554: LD_INT 1
35556: PUSH
35557: EMPTY
35558: LIST
35559: LIST
35560: PUSH
35561: LD_INT 1
35563: NEG
35564: PUSH
35565: LD_INT 0
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PUSH
35572: LD_INT 1
35574: NEG
35575: PUSH
35576: LD_INT 1
35578: NEG
35579: PUSH
35580: EMPTY
35581: LIST
35582: LIST
35583: PUSH
35584: LD_INT 1
35586: NEG
35587: PUSH
35588: LD_INT 2
35590: NEG
35591: PUSH
35592: EMPTY
35593: LIST
35594: LIST
35595: PUSH
35596: LD_INT 1
35598: PUSH
35599: LD_INT 1
35601: NEG
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: PUSH
35607: LD_INT 2
35609: PUSH
35610: LD_INT 0
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PUSH
35617: LD_INT 2
35619: PUSH
35620: LD_INT 1
35622: PUSH
35623: EMPTY
35624: LIST
35625: LIST
35626: PUSH
35627: LD_INT 1
35629: PUSH
35630: LD_INT 2
35632: PUSH
35633: EMPTY
35634: LIST
35635: LIST
35636: PUSH
35637: LD_INT 0
35639: PUSH
35640: LD_INT 2
35642: PUSH
35643: EMPTY
35644: LIST
35645: LIST
35646: PUSH
35647: LD_INT 1
35649: NEG
35650: PUSH
35651: LD_INT 1
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PUSH
35658: LD_INT 2
35660: NEG
35661: PUSH
35662: LD_INT 0
35664: PUSH
35665: EMPTY
35666: LIST
35667: LIST
35668: PUSH
35669: LD_INT 2
35671: NEG
35672: PUSH
35673: LD_INT 1
35675: NEG
35676: PUSH
35677: EMPTY
35678: LIST
35679: LIST
35680: PUSH
35681: LD_INT 2
35683: NEG
35684: PUSH
35685: LD_INT 2
35687: NEG
35688: PUSH
35689: EMPTY
35690: LIST
35691: LIST
35692: PUSH
35693: LD_INT 2
35695: NEG
35696: PUSH
35697: LD_INT 3
35699: NEG
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 2
35707: PUSH
35708: LD_INT 1
35710: NEG
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 3
35718: PUSH
35719: LD_INT 1
35721: PUSH
35722: EMPTY
35723: LIST
35724: LIST
35725: PUSH
35726: LD_INT 1
35728: PUSH
35729: LD_INT 3
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: LD_INT 1
35738: NEG
35739: PUSH
35740: LD_INT 2
35742: PUSH
35743: EMPTY
35744: LIST
35745: LIST
35746: PUSH
35747: LD_INT 3
35749: NEG
35750: PUSH
35751: LD_INT 2
35753: NEG
35754: PUSH
35755: EMPTY
35756: LIST
35757: LIST
35758: PUSH
35759: EMPTY
35760: LIST
35761: LIST
35762: LIST
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: LIST
35768: LIST
35769: LIST
35770: LIST
35771: LIST
35772: LIST
35773: LIST
35774: LIST
35775: LIST
35776: LIST
35777: LIST
35778: LIST
35779: LIST
35780: LIST
35781: LIST
35782: LIST
35783: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35784: LD_ADDR_VAR 0 34
35788: PUSH
35789: LD_INT 0
35791: PUSH
35792: LD_INT 0
35794: PUSH
35795: EMPTY
35796: LIST
35797: LIST
35798: PUSH
35799: LD_INT 0
35801: PUSH
35802: LD_INT 1
35804: NEG
35805: PUSH
35806: EMPTY
35807: LIST
35808: LIST
35809: PUSH
35810: LD_INT 1
35812: PUSH
35813: LD_INT 0
35815: PUSH
35816: EMPTY
35817: LIST
35818: LIST
35819: PUSH
35820: LD_INT 1
35822: PUSH
35823: LD_INT 1
35825: PUSH
35826: EMPTY
35827: LIST
35828: LIST
35829: PUSH
35830: LD_INT 0
35832: PUSH
35833: LD_INT 1
35835: PUSH
35836: EMPTY
35837: LIST
35838: LIST
35839: PUSH
35840: LD_INT 1
35842: NEG
35843: PUSH
35844: LD_INT 0
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: LD_INT 1
35853: NEG
35854: PUSH
35855: LD_INT 1
35857: NEG
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: PUSH
35863: LD_INT 1
35865: NEG
35866: PUSH
35867: LD_INT 2
35869: NEG
35870: PUSH
35871: EMPTY
35872: LIST
35873: LIST
35874: PUSH
35875: LD_INT 0
35877: PUSH
35878: LD_INT 2
35880: NEG
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: LD_INT 1
35888: PUSH
35889: LD_INT 1
35891: NEG
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: LD_INT 2
35899: PUSH
35900: LD_INT 1
35902: PUSH
35903: EMPTY
35904: LIST
35905: LIST
35906: PUSH
35907: LD_INT 2
35909: PUSH
35910: LD_INT 2
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 1
35919: PUSH
35920: LD_INT 2
35922: PUSH
35923: EMPTY
35924: LIST
35925: LIST
35926: PUSH
35927: LD_INT 1
35929: NEG
35930: PUSH
35931: LD_INT 1
35933: PUSH
35934: EMPTY
35935: LIST
35936: LIST
35937: PUSH
35938: LD_INT 2
35940: NEG
35941: PUSH
35942: LD_INT 0
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: LD_INT 2
35951: NEG
35952: PUSH
35953: LD_INT 1
35955: NEG
35956: PUSH
35957: EMPTY
35958: LIST
35959: LIST
35960: PUSH
35961: LD_INT 2
35963: NEG
35964: PUSH
35965: LD_INT 2
35967: NEG
35968: PUSH
35969: EMPTY
35970: LIST
35971: LIST
35972: PUSH
35973: LD_INT 1
35975: NEG
35976: PUSH
35977: LD_INT 3
35979: NEG
35980: PUSH
35981: EMPTY
35982: LIST
35983: LIST
35984: PUSH
35985: LD_INT 1
35987: PUSH
35988: LD_INT 2
35990: NEG
35991: PUSH
35992: EMPTY
35993: LIST
35994: LIST
35995: PUSH
35996: LD_INT 3
35998: PUSH
35999: LD_INT 2
36001: PUSH
36002: EMPTY
36003: LIST
36004: LIST
36005: PUSH
36006: LD_INT 2
36008: PUSH
36009: LD_INT 3
36011: PUSH
36012: EMPTY
36013: LIST
36014: LIST
36015: PUSH
36016: LD_INT 2
36018: NEG
36019: PUSH
36020: LD_INT 1
36022: PUSH
36023: EMPTY
36024: LIST
36025: LIST
36026: PUSH
36027: LD_INT 3
36029: NEG
36030: PUSH
36031: LD_INT 1
36033: NEG
36034: PUSH
36035: EMPTY
36036: LIST
36037: LIST
36038: PUSH
36039: EMPTY
36040: LIST
36041: LIST
36042: LIST
36043: LIST
36044: LIST
36045: LIST
36046: LIST
36047: LIST
36048: LIST
36049: LIST
36050: LIST
36051: LIST
36052: LIST
36053: LIST
36054: LIST
36055: LIST
36056: LIST
36057: LIST
36058: LIST
36059: LIST
36060: LIST
36061: LIST
36062: LIST
36063: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36064: LD_ADDR_VAR 0 35
36068: PUSH
36069: LD_INT 0
36071: PUSH
36072: LD_INT 0
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: PUSH
36079: LD_INT 0
36081: PUSH
36082: LD_INT 1
36084: NEG
36085: PUSH
36086: EMPTY
36087: LIST
36088: LIST
36089: PUSH
36090: LD_INT 1
36092: PUSH
36093: LD_INT 0
36095: PUSH
36096: EMPTY
36097: LIST
36098: LIST
36099: PUSH
36100: LD_INT 1
36102: PUSH
36103: LD_INT 1
36105: PUSH
36106: EMPTY
36107: LIST
36108: LIST
36109: PUSH
36110: LD_INT 0
36112: PUSH
36113: LD_INT 1
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: PUSH
36120: LD_INT 1
36122: NEG
36123: PUSH
36124: LD_INT 0
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 1
36133: NEG
36134: PUSH
36135: LD_INT 1
36137: NEG
36138: PUSH
36139: EMPTY
36140: LIST
36141: LIST
36142: PUSH
36143: LD_INT 2
36145: PUSH
36146: LD_INT 1
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: LD_INT 2
36155: NEG
36156: PUSH
36157: LD_INT 1
36159: NEG
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: PUSH
36165: EMPTY
36166: LIST
36167: LIST
36168: LIST
36169: LIST
36170: LIST
36171: LIST
36172: LIST
36173: LIST
36174: LIST
36175: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36176: LD_ADDR_VAR 0 36
36180: PUSH
36181: LD_INT 0
36183: PUSH
36184: LD_INT 0
36186: PUSH
36187: EMPTY
36188: LIST
36189: LIST
36190: PUSH
36191: LD_INT 0
36193: PUSH
36194: LD_INT 1
36196: NEG
36197: PUSH
36198: EMPTY
36199: LIST
36200: LIST
36201: PUSH
36202: LD_INT 1
36204: PUSH
36205: LD_INT 0
36207: PUSH
36208: EMPTY
36209: LIST
36210: LIST
36211: PUSH
36212: LD_INT 1
36214: PUSH
36215: LD_INT 1
36217: PUSH
36218: EMPTY
36219: LIST
36220: LIST
36221: PUSH
36222: LD_INT 0
36224: PUSH
36225: LD_INT 1
36227: PUSH
36228: EMPTY
36229: LIST
36230: LIST
36231: PUSH
36232: LD_INT 1
36234: NEG
36235: PUSH
36236: LD_INT 0
36238: PUSH
36239: EMPTY
36240: LIST
36241: LIST
36242: PUSH
36243: LD_INT 1
36245: NEG
36246: PUSH
36247: LD_INT 1
36249: NEG
36250: PUSH
36251: EMPTY
36252: LIST
36253: LIST
36254: PUSH
36255: LD_INT 1
36257: NEG
36258: PUSH
36259: LD_INT 2
36261: NEG
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 1
36269: PUSH
36270: LD_INT 2
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: EMPTY
36278: LIST
36279: LIST
36280: LIST
36281: LIST
36282: LIST
36283: LIST
36284: LIST
36285: LIST
36286: LIST
36287: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36288: LD_ADDR_VAR 0 37
36292: PUSH
36293: LD_INT 0
36295: PUSH
36296: LD_INT 0
36298: PUSH
36299: EMPTY
36300: LIST
36301: LIST
36302: PUSH
36303: LD_INT 0
36305: PUSH
36306: LD_INT 1
36308: NEG
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: LD_INT 1
36316: PUSH
36317: LD_INT 0
36319: PUSH
36320: EMPTY
36321: LIST
36322: LIST
36323: PUSH
36324: LD_INT 1
36326: PUSH
36327: LD_INT 1
36329: PUSH
36330: EMPTY
36331: LIST
36332: LIST
36333: PUSH
36334: LD_INT 0
36336: PUSH
36337: LD_INT 1
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: PUSH
36344: LD_INT 1
36346: NEG
36347: PUSH
36348: LD_INT 0
36350: PUSH
36351: EMPTY
36352: LIST
36353: LIST
36354: PUSH
36355: LD_INT 1
36357: NEG
36358: PUSH
36359: LD_INT 1
36361: NEG
36362: PUSH
36363: EMPTY
36364: LIST
36365: LIST
36366: PUSH
36367: LD_INT 1
36369: PUSH
36370: LD_INT 1
36372: NEG
36373: PUSH
36374: EMPTY
36375: LIST
36376: LIST
36377: PUSH
36378: LD_INT 1
36380: NEG
36381: PUSH
36382: LD_INT 1
36384: PUSH
36385: EMPTY
36386: LIST
36387: LIST
36388: PUSH
36389: EMPTY
36390: LIST
36391: LIST
36392: LIST
36393: LIST
36394: LIST
36395: LIST
36396: LIST
36397: LIST
36398: LIST
36399: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36400: LD_ADDR_VAR 0 38
36404: PUSH
36405: LD_INT 0
36407: PUSH
36408: LD_INT 0
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 0
36417: PUSH
36418: LD_INT 1
36420: NEG
36421: PUSH
36422: EMPTY
36423: LIST
36424: LIST
36425: PUSH
36426: LD_INT 1
36428: PUSH
36429: LD_INT 0
36431: PUSH
36432: EMPTY
36433: LIST
36434: LIST
36435: PUSH
36436: LD_INT 1
36438: PUSH
36439: LD_INT 1
36441: PUSH
36442: EMPTY
36443: LIST
36444: LIST
36445: PUSH
36446: LD_INT 0
36448: PUSH
36449: LD_INT 1
36451: PUSH
36452: EMPTY
36453: LIST
36454: LIST
36455: PUSH
36456: LD_INT 1
36458: NEG
36459: PUSH
36460: LD_INT 0
36462: PUSH
36463: EMPTY
36464: LIST
36465: LIST
36466: PUSH
36467: LD_INT 1
36469: NEG
36470: PUSH
36471: LD_INT 1
36473: NEG
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: LD_INT 2
36481: PUSH
36482: LD_INT 1
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 2
36491: NEG
36492: PUSH
36493: LD_INT 1
36495: NEG
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: LIST
36505: LIST
36506: LIST
36507: LIST
36508: LIST
36509: LIST
36510: LIST
36511: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36512: LD_ADDR_VAR 0 39
36516: PUSH
36517: LD_INT 0
36519: PUSH
36520: LD_INT 0
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: LD_INT 0
36529: PUSH
36530: LD_INT 1
36532: NEG
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: PUSH
36538: LD_INT 1
36540: PUSH
36541: LD_INT 0
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: LD_INT 1
36550: PUSH
36551: LD_INT 1
36553: PUSH
36554: EMPTY
36555: LIST
36556: LIST
36557: PUSH
36558: LD_INT 0
36560: PUSH
36561: LD_INT 1
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: PUSH
36568: LD_INT 1
36570: NEG
36571: PUSH
36572: LD_INT 0
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PUSH
36579: LD_INT 1
36581: NEG
36582: PUSH
36583: LD_INT 1
36585: NEG
36586: PUSH
36587: EMPTY
36588: LIST
36589: LIST
36590: PUSH
36591: LD_INT 1
36593: NEG
36594: PUSH
36595: LD_INT 2
36597: NEG
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: LD_INT 1
36605: PUSH
36606: LD_INT 2
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: EMPTY
36614: LIST
36615: LIST
36616: LIST
36617: LIST
36618: LIST
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36624: LD_ADDR_VAR 0 40
36628: PUSH
36629: LD_INT 0
36631: PUSH
36632: LD_INT 0
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PUSH
36639: LD_INT 0
36641: PUSH
36642: LD_INT 1
36644: NEG
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 1
36652: PUSH
36653: LD_INT 0
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 1
36662: PUSH
36663: LD_INT 1
36665: PUSH
36666: EMPTY
36667: LIST
36668: LIST
36669: PUSH
36670: LD_INT 0
36672: PUSH
36673: LD_INT 1
36675: PUSH
36676: EMPTY
36677: LIST
36678: LIST
36679: PUSH
36680: LD_INT 1
36682: NEG
36683: PUSH
36684: LD_INT 0
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: PUSH
36691: LD_INT 1
36693: NEG
36694: PUSH
36695: LD_INT 1
36697: NEG
36698: PUSH
36699: EMPTY
36700: LIST
36701: LIST
36702: PUSH
36703: LD_INT 1
36705: PUSH
36706: LD_INT 1
36708: NEG
36709: PUSH
36710: EMPTY
36711: LIST
36712: LIST
36713: PUSH
36714: LD_INT 1
36716: NEG
36717: PUSH
36718: LD_INT 1
36720: PUSH
36721: EMPTY
36722: LIST
36723: LIST
36724: PUSH
36725: EMPTY
36726: LIST
36727: LIST
36728: LIST
36729: LIST
36730: LIST
36731: LIST
36732: LIST
36733: LIST
36734: LIST
36735: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36736: LD_ADDR_VAR 0 41
36740: PUSH
36741: LD_INT 0
36743: PUSH
36744: LD_INT 0
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 0
36753: PUSH
36754: LD_INT 1
36756: NEG
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: LD_INT 1
36764: PUSH
36765: LD_INT 0
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 1
36774: PUSH
36775: LD_INT 1
36777: PUSH
36778: EMPTY
36779: LIST
36780: LIST
36781: PUSH
36782: LD_INT 0
36784: PUSH
36785: LD_INT 1
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 1
36794: NEG
36795: PUSH
36796: LD_INT 0
36798: PUSH
36799: EMPTY
36800: LIST
36801: LIST
36802: PUSH
36803: LD_INT 1
36805: NEG
36806: PUSH
36807: LD_INT 1
36809: NEG
36810: PUSH
36811: EMPTY
36812: LIST
36813: LIST
36814: PUSH
36815: LD_INT 1
36817: NEG
36818: PUSH
36819: LD_INT 2
36821: NEG
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: PUSH
36827: LD_INT 1
36829: PUSH
36830: LD_INT 1
36832: NEG
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: LD_INT 2
36840: PUSH
36841: LD_INT 0
36843: PUSH
36844: EMPTY
36845: LIST
36846: LIST
36847: PUSH
36848: LD_INT 2
36850: PUSH
36851: LD_INT 1
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: LD_INT 2
36860: PUSH
36861: LD_INT 2
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 1
36870: PUSH
36871: LD_INT 2
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: PUSH
36878: LD_INT 1
36880: NEG
36881: PUSH
36882: LD_INT 1
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 2
36891: NEG
36892: PUSH
36893: LD_INT 0
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PUSH
36900: LD_INT 2
36902: NEG
36903: PUSH
36904: LD_INT 1
36906: NEG
36907: PUSH
36908: EMPTY
36909: LIST
36910: LIST
36911: PUSH
36912: LD_INT 2
36914: NEG
36915: PUSH
36916: LD_INT 2
36918: NEG
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: PUSH
36924: LD_INT 2
36926: NEG
36927: PUSH
36928: LD_INT 3
36930: NEG
36931: PUSH
36932: EMPTY
36933: LIST
36934: LIST
36935: PUSH
36936: LD_INT 2
36938: PUSH
36939: LD_INT 1
36941: NEG
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 3
36949: PUSH
36950: LD_INT 0
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: PUSH
36957: LD_INT 3
36959: PUSH
36960: LD_INT 1
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: LD_INT 3
36969: PUSH
36970: LD_INT 2
36972: PUSH
36973: EMPTY
36974: LIST
36975: LIST
36976: PUSH
36977: LD_INT 3
36979: PUSH
36980: LD_INT 3
36982: PUSH
36983: EMPTY
36984: LIST
36985: LIST
36986: PUSH
36987: LD_INT 2
36989: PUSH
36990: LD_INT 3
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PUSH
36997: LD_INT 2
36999: NEG
37000: PUSH
37001: LD_INT 1
37003: PUSH
37004: EMPTY
37005: LIST
37006: LIST
37007: PUSH
37008: LD_INT 3
37010: NEG
37011: PUSH
37012: LD_INT 0
37014: PUSH
37015: EMPTY
37016: LIST
37017: LIST
37018: PUSH
37019: LD_INT 3
37021: NEG
37022: PUSH
37023: LD_INT 1
37025: NEG
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PUSH
37031: LD_INT 3
37033: NEG
37034: PUSH
37035: LD_INT 2
37037: NEG
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: PUSH
37043: LD_INT 3
37045: NEG
37046: PUSH
37047: LD_INT 3
37049: NEG
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PUSH
37055: EMPTY
37056: LIST
37057: LIST
37058: LIST
37059: LIST
37060: LIST
37061: LIST
37062: LIST
37063: LIST
37064: LIST
37065: LIST
37066: LIST
37067: LIST
37068: LIST
37069: LIST
37070: LIST
37071: LIST
37072: LIST
37073: LIST
37074: LIST
37075: LIST
37076: LIST
37077: LIST
37078: LIST
37079: LIST
37080: LIST
37081: LIST
37082: LIST
37083: LIST
37084: LIST
37085: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37086: LD_ADDR_VAR 0 42
37090: PUSH
37091: LD_INT 0
37093: PUSH
37094: LD_INT 0
37096: PUSH
37097: EMPTY
37098: LIST
37099: LIST
37100: PUSH
37101: LD_INT 0
37103: PUSH
37104: LD_INT 1
37106: NEG
37107: PUSH
37108: EMPTY
37109: LIST
37110: LIST
37111: PUSH
37112: LD_INT 1
37114: PUSH
37115: LD_INT 0
37117: PUSH
37118: EMPTY
37119: LIST
37120: LIST
37121: PUSH
37122: LD_INT 1
37124: PUSH
37125: LD_INT 1
37127: PUSH
37128: EMPTY
37129: LIST
37130: LIST
37131: PUSH
37132: LD_INT 0
37134: PUSH
37135: LD_INT 1
37137: PUSH
37138: EMPTY
37139: LIST
37140: LIST
37141: PUSH
37142: LD_INT 1
37144: NEG
37145: PUSH
37146: LD_INT 0
37148: PUSH
37149: EMPTY
37150: LIST
37151: LIST
37152: PUSH
37153: LD_INT 1
37155: NEG
37156: PUSH
37157: LD_INT 1
37159: NEG
37160: PUSH
37161: EMPTY
37162: LIST
37163: LIST
37164: PUSH
37165: LD_INT 1
37167: NEG
37168: PUSH
37169: LD_INT 2
37171: NEG
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PUSH
37177: LD_INT 0
37179: PUSH
37180: LD_INT 2
37182: NEG
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: PUSH
37188: LD_INT 1
37190: PUSH
37191: LD_INT 1
37193: NEG
37194: PUSH
37195: EMPTY
37196: LIST
37197: LIST
37198: PUSH
37199: LD_INT 2
37201: PUSH
37202: LD_INT 1
37204: PUSH
37205: EMPTY
37206: LIST
37207: LIST
37208: PUSH
37209: LD_INT 2
37211: PUSH
37212: LD_INT 2
37214: PUSH
37215: EMPTY
37216: LIST
37217: LIST
37218: PUSH
37219: LD_INT 1
37221: PUSH
37222: LD_INT 2
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: PUSH
37229: LD_INT 0
37231: PUSH
37232: LD_INT 2
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 1
37241: NEG
37242: PUSH
37243: LD_INT 1
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 2
37252: NEG
37253: PUSH
37254: LD_INT 1
37256: NEG
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 2
37264: NEG
37265: PUSH
37266: LD_INT 2
37268: NEG
37269: PUSH
37270: EMPTY
37271: LIST
37272: LIST
37273: PUSH
37274: LD_INT 2
37276: NEG
37277: PUSH
37278: LD_INT 3
37280: NEG
37281: PUSH
37282: EMPTY
37283: LIST
37284: LIST
37285: PUSH
37286: LD_INT 1
37288: NEG
37289: PUSH
37290: LD_INT 3
37292: NEG
37293: PUSH
37294: EMPTY
37295: LIST
37296: LIST
37297: PUSH
37298: LD_INT 0
37300: PUSH
37301: LD_INT 3
37303: NEG
37304: PUSH
37305: EMPTY
37306: LIST
37307: LIST
37308: PUSH
37309: LD_INT 1
37311: PUSH
37312: LD_INT 2
37314: NEG
37315: PUSH
37316: EMPTY
37317: LIST
37318: LIST
37319: PUSH
37320: LD_INT 3
37322: PUSH
37323: LD_INT 2
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: PUSH
37330: LD_INT 3
37332: PUSH
37333: LD_INT 3
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: LD_INT 2
37342: PUSH
37343: LD_INT 3
37345: PUSH
37346: EMPTY
37347: LIST
37348: LIST
37349: PUSH
37350: LD_INT 1
37352: PUSH
37353: LD_INT 3
37355: PUSH
37356: EMPTY
37357: LIST
37358: LIST
37359: PUSH
37360: LD_INT 0
37362: PUSH
37363: LD_INT 3
37365: PUSH
37366: EMPTY
37367: LIST
37368: LIST
37369: PUSH
37370: LD_INT 1
37372: NEG
37373: PUSH
37374: LD_INT 2
37376: PUSH
37377: EMPTY
37378: LIST
37379: LIST
37380: PUSH
37381: LD_INT 3
37383: NEG
37384: PUSH
37385: LD_INT 2
37387: NEG
37388: PUSH
37389: EMPTY
37390: LIST
37391: LIST
37392: PUSH
37393: LD_INT 3
37395: NEG
37396: PUSH
37397: LD_INT 3
37399: NEG
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: LIST
37409: LIST
37410: LIST
37411: LIST
37412: LIST
37413: LIST
37414: LIST
37415: LIST
37416: LIST
37417: LIST
37418: LIST
37419: LIST
37420: LIST
37421: LIST
37422: LIST
37423: LIST
37424: LIST
37425: LIST
37426: LIST
37427: LIST
37428: LIST
37429: LIST
37430: LIST
37431: LIST
37432: LIST
37433: LIST
37434: LIST
37435: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37436: LD_ADDR_VAR 0 43
37440: PUSH
37441: LD_INT 0
37443: PUSH
37444: LD_INT 0
37446: PUSH
37447: EMPTY
37448: LIST
37449: LIST
37450: PUSH
37451: LD_INT 0
37453: PUSH
37454: LD_INT 1
37456: NEG
37457: PUSH
37458: EMPTY
37459: LIST
37460: LIST
37461: PUSH
37462: LD_INT 1
37464: PUSH
37465: LD_INT 0
37467: PUSH
37468: EMPTY
37469: LIST
37470: LIST
37471: PUSH
37472: LD_INT 1
37474: PUSH
37475: LD_INT 1
37477: PUSH
37478: EMPTY
37479: LIST
37480: LIST
37481: PUSH
37482: LD_INT 0
37484: PUSH
37485: LD_INT 1
37487: PUSH
37488: EMPTY
37489: LIST
37490: LIST
37491: PUSH
37492: LD_INT 1
37494: NEG
37495: PUSH
37496: LD_INT 0
37498: PUSH
37499: EMPTY
37500: LIST
37501: LIST
37502: PUSH
37503: LD_INT 1
37505: NEG
37506: PUSH
37507: LD_INT 1
37509: NEG
37510: PUSH
37511: EMPTY
37512: LIST
37513: LIST
37514: PUSH
37515: LD_INT 1
37517: NEG
37518: PUSH
37519: LD_INT 2
37521: NEG
37522: PUSH
37523: EMPTY
37524: LIST
37525: LIST
37526: PUSH
37527: LD_INT 0
37529: PUSH
37530: LD_INT 2
37532: NEG
37533: PUSH
37534: EMPTY
37535: LIST
37536: LIST
37537: PUSH
37538: LD_INT 1
37540: PUSH
37541: LD_INT 1
37543: NEG
37544: PUSH
37545: EMPTY
37546: LIST
37547: LIST
37548: PUSH
37549: LD_INT 2
37551: PUSH
37552: LD_INT 0
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: LD_INT 2
37561: PUSH
37562: LD_INT 1
37564: PUSH
37565: EMPTY
37566: LIST
37567: LIST
37568: PUSH
37569: LD_INT 1
37571: PUSH
37572: LD_INT 2
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: PUSH
37579: LD_INT 0
37581: PUSH
37582: LD_INT 2
37584: PUSH
37585: EMPTY
37586: LIST
37587: LIST
37588: PUSH
37589: LD_INT 1
37591: NEG
37592: PUSH
37593: LD_INT 1
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PUSH
37600: LD_INT 2
37602: NEG
37603: PUSH
37604: LD_INT 0
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: PUSH
37611: LD_INT 2
37613: NEG
37614: PUSH
37615: LD_INT 1
37617: NEG
37618: PUSH
37619: EMPTY
37620: LIST
37621: LIST
37622: PUSH
37623: LD_INT 1
37625: NEG
37626: PUSH
37627: LD_INT 3
37629: NEG
37630: PUSH
37631: EMPTY
37632: LIST
37633: LIST
37634: PUSH
37635: LD_INT 0
37637: PUSH
37638: LD_INT 3
37640: NEG
37641: PUSH
37642: EMPTY
37643: LIST
37644: LIST
37645: PUSH
37646: LD_INT 1
37648: PUSH
37649: LD_INT 2
37651: NEG
37652: PUSH
37653: EMPTY
37654: LIST
37655: LIST
37656: PUSH
37657: LD_INT 2
37659: PUSH
37660: LD_INT 1
37662: NEG
37663: PUSH
37664: EMPTY
37665: LIST
37666: LIST
37667: PUSH
37668: LD_INT 3
37670: PUSH
37671: LD_INT 0
37673: PUSH
37674: EMPTY
37675: LIST
37676: LIST
37677: PUSH
37678: LD_INT 3
37680: PUSH
37681: LD_INT 1
37683: PUSH
37684: EMPTY
37685: LIST
37686: LIST
37687: PUSH
37688: LD_INT 1
37690: PUSH
37691: LD_INT 3
37693: PUSH
37694: EMPTY
37695: LIST
37696: LIST
37697: PUSH
37698: LD_INT 0
37700: PUSH
37701: LD_INT 3
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: LD_INT 1
37710: NEG
37711: PUSH
37712: LD_INT 2
37714: PUSH
37715: EMPTY
37716: LIST
37717: LIST
37718: PUSH
37719: LD_INT 2
37721: NEG
37722: PUSH
37723: LD_INT 1
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: PUSH
37730: LD_INT 3
37732: NEG
37733: PUSH
37734: LD_INT 0
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 3
37743: NEG
37744: PUSH
37745: LD_INT 1
37747: NEG
37748: PUSH
37749: EMPTY
37750: LIST
37751: LIST
37752: PUSH
37753: EMPTY
37754: LIST
37755: LIST
37756: LIST
37757: LIST
37758: LIST
37759: LIST
37760: LIST
37761: LIST
37762: LIST
37763: LIST
37764: LIST
37765: LIST
37766: LIST
37767: LIST
37768: LIST
37769: LIST
37770: LIST
37771: LIST
37772: LIST
37773: LIST
37774: LIST
37775: LIST
37776: LIST
37777: LIST
37778: LIST
37779: LIST
37780: LIST
37781: LIST
37782: LIST
37783: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37784: LD_ADDR_VAR 0 44
37788: PUSH
37789: LD_INT 0
37791: PUSH
37792: LD_INT 0
37794: PUSH
37795: EMPTY
37796: LIST
37797: LIST
37798: PUSH
37799: LD_INT 0
37801: PUSH
37802: LD_INT 1
37804: NEG
37805: PUSH
37806: EMPTY
37807: LIST
37808: LIST
37809: PUSH
37810: LD_INT 1
37812: PUSH
37813: LD_INT 0
37815: PUSH
37816: EMPTY
37817: LIST
37818: LIST
37819: PUSH
37820: LD_INT 1
37822: PUSH
37823: LD_INT 1
37825: PUSH
37826: EMPTY
37827: LIST
37828: LIST
37829: PUSH
37830: LD_INT 0
37832: PUSH
37833: LD_INT 1
37835: PUSH
37836: EMPTY
37837: LIST
37838: LIST
37839: PUSH
37840: LD_INT 1
37842: NEG
37843: PUSH
37844: LD_INT 0
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 1
37853: NEG
37854: PUSH
37855: LD_INT 1
37857: NEG
37858: PUSH
37859: EMPTY
37860: LIST
37861: LIST
37862: PUSH
37863: LD_INT 1
37865: NEG
37866: PUSH
37867: LD_INT 2
37869: NEG
37870: PUSH
37871: EMPTY
37872: LIST
37873: LIST
37874: PUSH
37875: LD_INT 1
37877: PUSH
37878: LD_INT 1
37880: NEG
37881: PUSH
37882: EMPTY
37883: LIST
37884: LIST
37885: PUSH
37886: LD_INT 2
37888: PUSH
37889: LD_INT 0
37891: PUSH
37892: EMPTY
37893: LIST
37894: LIST
37895: PUSH
37896: LD_INT 2
37898: PUSH
37899: LD_INT 1
37901: PUSH
37902: EMPTY
37903: LIST
37904: LIST
37905: PUSH
37906: LD_INT 2
37908: PUSH
37909: LD_INT 2
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: PUSH
37916: LD_INT 1
37918: PUSH
37919: LD_INT 2
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: PUSH
37926: LD_INT 1
37928: NEG
37929: PUSH
37930: LD_INT 1
37932: PUSH
37933: EMPTY
37934: LIST
37935: LIST
37936: PUSH
37937: LD_INT 2
37939: NEG
37940: PUSH
37941: LD_INT 0
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 2
37950: NEG
37951: PUSH
37952: LD_INT 1
37954: NEG
37955: PUSH
37956: EMPTY
37957: LIST
37958: LIST
37959: PUSH
37960: LD_INT 2
37962: NEG
37963: PUSH
37964: LD_INT 2
37966: NEG
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: LD_INT 2
37974: NEG
37975: PUSH
37976: LD_INT 3
37978: NEG
37979: PUSH
37980: EMPTY
37981: LIST
37982: LIST
37983: PUSH
37984: LD_INT 2
37986: PUSH
37987: LD_INT 1
37989: NEG
37990: PUSH
37991: EMPTY
37992: LIST
37993: LIST
37994: PUSH
37995: LD_INT 3
37997: PUSH
37998: LD_INT 0
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 3
38007: PUSH
38008: LD_INT 1
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 3
38017: PUSH
38018: LD_INT 2
38020: PUSH
38021: EMPTY
38022: LIST
38023: LIST
38024: PUSH
38025: LD_INT 3
38027: PUSH
38028: LD_INT 3
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: LD_INT 2
38037: PUSH
38038: LD_INT 3
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: LD_INT 2
38047: NEG
38048: PUSH
38049: LD_INT 1
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 3
38058: NEG
38059: PUSH
38060: LD_INT 0
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 3
38069: NEG
38070: PUSH
38071: LD_INT 1
38073: NEG
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: PUSH
38079: LD_INT 3
38081: NEG
38082: PUSH
38083: LD_INT 2
38085: NEG
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 3
38093: NEG
38094: PUSH
38095: LD_INT 3
38097: NEG
38098: PUSH
38099: EMPTY
38100: LIST
38101: LIST
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: LIST
38107: LIST
38108: LIST
38109: LIST
38110: LIST
38111: LIST
38112: LIST
38113: LIST
38114: LIST
38115: LIST
38116: LIST
38117: LIST
38118: LIST
38119: LIST
38120: LIST
38121: LIST
38122: LIST
38123: LIST
38124: LIST
38125: LIST
38126: LIST
38127: LIST
38128: LIST
38129: LIST
38130: LIST
38131: LIST
38132: LIST
38133: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38134: LD_ADDR_VAR 0 45
38138: PUSH
38139: LD_INT 0
38141: PUSH
38142: LD_INT 0
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: LD_INT 0
38151: PUSH
38152: LD_INT 1
38154: NEG
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 1
38162: PUSH
38163: LD_INT 0
38165: PUSH
38166: EMPTY
38167: LIST
38168: LIST
38169: PUSH
38170: LD_INT 1
38172: PUSH
38173: LD_INT 1
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: LD_INT 0
38182: PUSH
38183: LD_INT 1
38185: PUSH
38186: EMPTY
38187: LIST
38188: LIST
38189: PUSH
38190: LD_INT 1
38192: NEG
38193: PUSH
38194: LD_INT 0
38196: PUSH
38197: EMPTY
38198: LIST
38199: LIST
38200: PUSH
38201: LD_INT 1
38203: NEG
38204: PUSH
38205: LD_INT 1
38207: NEG
38208: PUSH
38209: EMPTY
38210: LIST
38211: LIST
38212: PUSH
38213: LD_INT 1
38215: NEG
38216: PUSH
38217: LD_INT 2
38219: NEG
38220: PUSH
38221: EMPTY
38222: LIST
38223: LIST
38224: PUSH
38225: LD_INT 0
38227: PUSH
38228: LD_INT 2
38230: NEG
38231: PUSH
38232: EMPTY
38233: LIST
38234: LIST
38235: PUSH
38236: LD_INT 1
38238: PUSH
38239: LD_INT 1
38241: NEG
38242: PUSH
38243: EMPTY
38244: LIST
38245: LIST
38246: PUSH
38247: LD_INT 2
38249: PUSH
38250: LD_INT 1
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: PUSH
38257: LD_INT 2
38259: PUSH
38260: LD_INT 2
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 1
38269: PUSH
38270: LD_INT 2
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: PUSH
38277: LD_INT 0
38279: PUSH
38280: LD_INT 2
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: LD_INT 1
38289: NEG
38290: PUSH
38291: LD_INT 1
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 2
38300: NEG
38301: PUSH
38302: LD_INT 1
38304: NEG
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 2
38312: NEG
38313: PUSH
38314: LD_INT 2
38316: NEG
38317: PUSH
38318: EMPTY
38319: LIST
38320: LIST
38321: PUSH
38322: LD_INT 2
38324: NEG
38325: PUSH
38326: LD_INT 3
38328: NEG
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: PUSH
38334: LD_INT 1
38336: NEG
38337: PUSH
38338: LD_INT 3
38340: NEG
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: PUSH
38346: LD_INT 0
38348: PUSH
38349: LD_INT 3
38351: NEG
38352: PUSH
38353: EMPTY
38354: LIST
38355: LIST
38356: PUSH
38357: LD_INT 1
38359: PUSH
38360: LD_INT 2
38362: NEG
38363: PUSH
38364: EMPTY
38365: LIST
38366: LIST
38367: PUSH
38368: LD_INT 3
38370: PUSH
38371: LD_INT 2
38373: PUSH
38374: EMPTY
38375: LIST
38376: LIST
38377: PUSH
38378: LD_INT 3
38380: PUSH
38381: LD_INT 3
38383: PUSH
38384: EMPTY
38385: LIST
38386: LIST
38387: PUSH
38388: LD_INT 2
38390: PUSH
38391: LD_INT 3
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 1
38400: PUSH
38401: LD_INT 3
38403: PUSH
38404: EMPTY
38405: LIST
38406: LIST
38407: PUSH
38408: LD_INT 0
38410: PUSH
38411: LD_INT 3
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 1
38420: NEG
38421: PUSH
38422: LD_INT 2
38424: PUSH
38425: EMPTY
38426: LIST
38427: LIST
38428: PUSH
38429: LD_INT 3
38431: NEG
38432: PUSH
38433: LD_INT 2
38435: NEG
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 3
38443: NEG
38444: PUSH
38445: LD_INT 3
38447: NEG
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: EMPTY
38454: LIST
38455: LIST
38456: LIST
38457: LIST
38458: LIST
38459: LIST
38460: LIST
38461: LIST
38462: LIST
38463: LIST
38464: LIST
38465: LIST
38466: LIST
38467: LIST
38468: LIST
38469: LIST
38470: LIST
38471: LIST
38472: LIST
38473: LIST
38474: LIST
38475: LIST
38476: LIST
38477: LIST
38478: LIST
38479: LIST
38480: LIST
38481: LIST
38482: LIST
38483: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38484: LD_ADDR_VAR 0 46
38488: PUSH
38489: LD_INT 0
38491: PUSH
38492: LD_INT 0
38494: PUSH
38495: EMPTY
38496: LIST
38497: LIST
38498: PUSH
38499: LD_INT 0
38501: PUSH
38502: LD_INT 1
38504: NEG
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 1
38512: PUSH
38513: LD_INT 0
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: LD_INT 1
38522: PUSH
38523: LD_INT 1
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: LD_INT 0
38532: PUSH
38533: LD_INT 1
38535: PUSH
38536: EMPTY
38537: LIST
38538: LIST
38539: PUSH
38540: LD_INT 1
38542: NEG
38543: PUSH
38544: LD_INT 0
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 1
38553: NEG
38554: PUSH
38555: LD_INT 1
38557: NEG
38558: PUSH
38559: EMPTY
38560: LIST
38561: LIST
38562: PUSH
38563: LD_INT 1
38565: NEG
38566: PUSH
38567: LD_INT 2
38569: NEG
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: PUSH
38575: LD_INT 0
38577: PUSH
38578: LD_INT 2
38580: NEG
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 1
38588: PUSH
38589: LD_INT 1
38591: NEG
38592: PUSH
38593: EMPTY
38594: LIST
38595: LIST
38596: PUSH
38597: LD_INT 2
38599: PUSH
38600: LD_INT 0
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 2
38609: PUSH
38610: LD_INT 1
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 1
38619: PUSH
38620: LD_INT 2
38622: PUSH
38623: EMPTY
38624: LIST
38625: LIST
38626: PUSH
38627: LD_INT 0
38629: PUSH
38630: LD_INT 2
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 1
38639: NEG
38640: PUSH
38641: LD_INT 1
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 2
38650: NEG
38651: PUSH
38652: LD_INT 0
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 2
38661: NEG
38662: PUSH
38663: LD_INT 1
38665: NEG
38666: PUSH
38667: EMPTY
38668: LIST
38669: LIST
38670: PUSH
38671: LD_INT 1
38673: NEG
38674: PUSH
38675: LD_INT 3
38677: NEG
38678: PUSH
38679: EMPTY
38680: LIST
38681: LIST
38682: PUSH
38683: LD_INT 0
38685: PUSH
38686: LD_INT 3
38688: NEG
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: PUSH
38694: LD_INT 1
38696: PUSH
38697: LD_INT 2
38699: NEG
38700: PUSH
38701: EMPTY
38702: LIST
38703: LIST
38704: PUSH
38705: LD_INT 2
38707: PUSH
38708: LD_INT 1
38710: NEG
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: LD_INT 3
38718: PUSH
38719: LD_INT 0
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: LD_INT 3
38728: PUSH
38729: LD_INT 1
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 1
38738: PUSH
38739: LD_INT 3
38741: PUSH
38742: EMPTY
38743: LIST
38744: LIST
38745: PUSH
38746: LD_INT 0
38748: PUSH
38749: LD_INT 3
38751: PUSH
38752: EMPTY
38753: LIST
38754: LIST
38755: PUSH
38756: LD_INT 1
38758: NEG
38759: PUSH
38760: LD_INT 2
38762: PUSH
38763: EMPTY
38764: LIST
38765: LIST
38766: PUSH
38767: LD_INT 2
38769: NEG
38770: PUSH
38771: LD_INT 1
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: LD_INT 3
38780: NEG
38781: PUSH
38782: LD_INT 0
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: PUSH
38789: LD_INT 3
38791: NEG
38792: PUSH
38793: LD_INT 1
38795: NEG
38796: PUSH
38797: EMPTY
38798: LIST
38799: LIST
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: LIST
38805: LIST
38806: LIST
38807: LIST
38808: LIST
38809: LIST
38810: LIST
38811: LIST
38812: LIST
38813: LIST
38814: LIST
38815: LIST
38816: LIST
38817: LIST
38818: LIST
38819: LIST
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38832: LD_ADDR_VAR 0 47
38836: PUSH
38837: LD_INT 0
38839: PUSH
38840: LD_INT 0
38842: PUSH
38843: EMPTY
38844: LIST
38845: LIST
38846: PUSH
38847: LD_INT 0
38849: PUSH
38850: LD_INT 1
38852: NEG
38853: PUSH
38854: EMPTY
38855: LIST
38856: LIST
38857: PUSH
38858: LD_INT 1
38860: PUSH
38861: LD_INT 0
38863: PUSH
38864: EMPTY
38865: LIST
38866: LIST
38867: PUSH
38868: LD_INT 1
38870: PUSH
38871: LD_INT 1
38873: PUSH
38874: EMPTY
38875: LIST
38876: LIST
38877: PUSH
38878: LD_INT 0
38880: PUSH
38881: LD_INT 1
38883: PUSH
38884: EMPTY
38885: LIST
38886: LIST
38887: PUSH
38888: LD_INT 1
38890: NEG
38891: PUSH
38892: LD_INT 0
38894: PUSH
38895: EMPTY
38896: LIST
38897: LIST
38898: PUSH
38899: LD_INT 1
38901: NEG
38902: PUSH
38903: LD_INT 1
38905: NEG
38906: PUSH
38907: EMPTY
38908: LIST
38909: LIST
38910: PUSH
38911: LD_INT 1
38913: NEG
38914: PUSH
38915: LD_INT 2
38917: NEG
38918: PUSH
38919: EMPTY
38920: LIST
38921: LIST
38922: PUSH
38923: LD_INT 0
38925: PUSH
38926: LD_INT 2
38928: NEG
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 1
38936: PUSH
38937: LD_INT 1
38939: NEG
38940: PUSH
38941: EMPTY
38942: LIST
38943: LIST
38944: PUSH
38945: LD_INT 2
38947: NEG
38948: PUSH
38949: LD_INT 1
38951: NEG
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: PUSH
38957: LD_INT 2
38959: NEG
38960: PUSH
38961: LD_INT 2
38963: NEG
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: EMPTY
38970: LIST
38971: LIST
38972: LIST
38973: LIST
38974: LIST
38975: LIST
38976: LIST
38977: LIST
38978: LIST
38979: LIST
38980: LIST
38981: LIST
38982: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38983: LD_ADDR_VAR 0 48
38987: PUSH
38988: LD_INT 0
38990: PUSH
38991: LD_INT 0
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 0
39000: PUSH
39001: LD_INT 1
39003: NEG
39004: PUSH
39005: EMPTY
39006: LIST
39007: LIST
39008: PUSH
39009: LD_INT 1
39011: PUSH
39012: LD_INT 0
39014: PUSH
39015: EMPTY
39016: LIST
39017: LIST
39018: PUSH
39019: LD_INT 1
39021: PUSH
39022: LD_INT 1
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: PUSH
39029: LD_INT 0
39031: PUSH
39032: LD_INT 1
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: PUSH
39039: LD_INT 1
39041: NEG
39042: PUSH
39043: LD_INT 0
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 1
39052: NEG
39053: PUSH
39054: LD_INT 1
39056: NEG
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: PUSH
39062: LD_INT 1
39064: NEG
39065: PUSH
39066: LD_INT 2
39068: NEG
39069: PUSH
39070: EMPTY
39071: LIST
39072: LIST
39073: PUSH
39074: LD_INT 0
39076: PUSH
39077: LD_INT 2
39079: NEG
39080: PUSH
39081: EMPTY
39082: LIST
39083: LIST
39084: PUSH
39085: LD_INT 1
39087: PUSH
39088: LD_INT 1
39090: NEG
39091: PUSH
39092: EMPTY
39093: LIST
39094: LIST
39095: PUSH
39096: LD_INT 2
39098: PUSH
39099: LD_INT 0
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: LD_INT 2
39108: PUSH
39109: LD_INT 1
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: LIST
39120: LIST
39121: LIST
39122: LIST
39123: LIST
39124: LIST
39125: LIST
39126: LIST
39127: LIST
39128: LIST
39129: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39130: LD_ADDR_VAR 0 49
39134: PUSH
39135: LD_INT 0
39137: PUSH
39138: LD_INT 0
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: LD_INT 0
39147: PUSH
39148: LD_INT 1
39150: NEG
39151: PUSH
39152: EMPTY
39153: LIST
39154: LIST
39155: PUSH
39156: LD_INT 1
39158: PUSH
39159: LD_INT 0
39161: PUSH
39162: EMPTY
39163: LIST
39164: LIST
39165: PUSH
39166: LD_INT 1
39168: PUSH
39169: LD_INT 1
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: LD_INT 0
39178: PUSH
39179: LD_INT 1
39181: PUSH
39182: EMPTY
39183: LIST
39184: LIST
39185: PUSH
39186: LD_INT 1
39188: NEG
39189: PUSH
39190: LD_INT 0
39192: PUSH
39193: EMPTY
39194: LIST
39195: LIST
39196: PUSH
39197: LD_INT 1
39199: NEG
39200: PUSH
39201: LD_INT 1
39203: NEG
39204: PUSH
39205: EMPTY
39206: LIST
39207: LIST
39208: PUSH
39209: LD_INT 1
39211: PUSH
39212: LD_INT 1
39214: NEG
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: LD_INT 2
39222: PUSH
39223: LD_INT 0
39225: PUSH
39226: EMPTY
39227: LIST
39228: LIST
39229: PUSH
39230: LD_INT 2
39232: PUSH
39233: LD_INT 1
39235: PUSH
39236: EMPTY
39237: LIST
39238: LIST
39239: PUSH
39240: LD_INT 2
39242: PUSH
39243: LD_INT 2
39245: PUSH
39246: EMPTY
39247: LIST
39248: LIST
39249: PUSH
39250: LD_INT 1
39252: PUSH
39253: LD_INT 2
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: LIST
39264: LIST
39265: LIST
39266: LIST
39267: LIST
39268: LIST
39269: LIST
39270: LIST
39271: LIST
39272: LIST
39273: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39274: LD_ADDR_VAR 0 50
39278: PUSH
39279: LD_INT 0
39281: PUSH
39282: LD_INT 0
39284: PUSH
39285: EMPTY
39286: LIST
39287: LIST
39288: PUSH
39289: LD_INT 0
39291: PUSH
39292: LD_INT 1
39294: NEG
39295: PUSH
39296: EMPTY
39297: LIST
39298: LIST
39299: PUSH
39300: LD_INT 1
39302: PUSH
39303: LD_INT 0
39305: PUSH
39306: EMPTY
39307: LIST
39308: LIST
39309: PUSH
39310: LD_INT 1
39312: PUSH
39313: LD_INT 1
39315: PUSH
39316: EMPTY
39317: LIST
39318: LIST
39319: PUSH
39320: LD_INT 0
39322: PUSH
39323: LD_INT 1
39325: PUSH
39326: EMPTY
39327: LIST
39328: LIST
39329: PUSH
39330: LD_INT 1
39332: NEG
39333: PUSH
39334: LD_INT 0
39336: PUSH
39337: EMPTY
39338: LIST
39339: LIST
39340: PUSH
39341: LD_INT 1
39343: NEG
39344: PUSH
39345: LD_INT 1
39347: NEG
39348: PUSH
39349: EMPTY
39350: LIST
39351: LIST
39352: PUSH
39353: LD_INT 2
39355: PUSH
39356: LD_INT 1
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: PUSH
39363: LD_INT 2
39365: PUSH
39366: LD_INT 2
39368: PUSH
39369: EMPTY
39370: LIST
39371: LIST
39372: PUSH
39373: LD_INT 1
39375: PUSH
39376: LD_INT 2
39378: PUSH
39379: EMPTY
39380: LIST
39381: LIST
39382: PUSH
39383: LD_INT 0
39385: PUSH
39386: LD_INT 2
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: PUSH
39393: LD_INT 1
39395: NEG
39396: PUSH
39397: LD_INT 1
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: LIST
39408: LIST
39409: LIST
39410: LIST
39411: LIST
39412: LIST
39413: LIST
39414: LIST
39415: LIST
39416: LIST
39417: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39418: LD_ADDR_VAR 0 51
39422: PUSH
39423: LD_INT 0
39425: PUSH
39426: LD_INT 0
39428: PUSH
39429: EMPTY
39430: LIST
39431: LIST
39432: PUSH
39433: LD_INT 0
39435: PUSH
39436: LD_INT 1
39438: NEG
39439: PUSH
39440: EMPTY
39441: LIST
39442: LIST
39443: PUSH
39444: LD_INT 1
39446: PUSH
39447: LD_INT 0
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: PUSH
39454: LD_INT 1
39456: PUSH
39457: LD_INT 1
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: PUSH
39464: LD_INT 0
39466: PUSH
39467: LD_INT 1
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: LD_INT 1
39476: NEG
39477: PUSH
39478: LD_INT 0
39480: PUSH
39481: EMPTY
39482: LIST
39483: LIST
39484: PUSH
39485: LD_INT 1
39487: NEG
39488: PUSH
39489: LD_INT 1
39491: NEG
39492: PUSH
39493: EMPTY
39494: LIST
39495: LIST
39496: PUSH
39497: LD_INT 1
39499: PUSH
39500: LD_INT 2
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: LD_INT 0
39509: PUSH
39510: LD_INT 2
39512: PUSH
39513: EMPTY
39514: LIST
39515: LIST
39516: PUSH
39517: LD_INT 1
39519: NEG
39520: PUSH
39521: LD_INT 1
39523: PUSH
39524: EMPTY
39525: LIST
39526: LIST
39527: PUSH
39528: LD_INT 2
39530: NEG
39531: PUSH
39532: LD_INT 0
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: PUSH
39539: LD_INT 2
39541: NEG
39542: PUSH
39543: LD_INT 1
39545: NEG
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: LIST
39555: LIST
39556: LIST
39557: LIST
39558: LIST
39559: LIST
39560: LIST
39561: LIST
39562: LIST
39563: LIST
39564: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39565: LD_ADDR_VAR 0 52
39569: PUSH
39570: LD_INT 0
39572: PUSH
39573: LD_INT 0
39575: PUSH
39576: EMPTY
39577: LIST
39578: LIST
39579: PUSH
39580: LD_INT 0
39582: PUSH
39583: LD_INT 1
39585: NEG
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: LD_INT 1
39593: PUSH
39594: LD_INT 0
39596: PUSH
39597: EMPTY
39598: LIST
39599: LIST
39600: PUSH
39601: LD_INT 1
39603: PUSH
39604: LD_INT 1
39606: PUSH
39607: EMPTY
39608: LIST
39609: LIST
39610: PUSH
39611: LD_INT 0
39613: PUSH
39614: LD_INT 1
39616: PUSH
39617: EMPTY
39618: LIST
39619: LIST
39620: PUSH
39621: LD_INT 1
39623: NEG
39624: PUSH
39625: LD_INT 0
39627: PUSH
39628: EMPTY
39629: LIST
39630: LIST
39631: PUSH
39632: LD_INT 1
39634: NEG
39635: PUSH
39636: LD_INT 1
39638: NEG
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: PUSH
39644: LD_INT 1
39646: NEG
39647: PUSH
39648: LD_INT 2
39650: NEG
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 1
39658: NEG
39659: PUSH
39660: LD_INT 1
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 2
39669: NEG
39670: PUSH
39671: LD_INT 0
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: LD_INT 2
39680: NEG
39681: PUSH
39682: LD_INT 1
39684: NEG
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 2
39692: NEG
39693: PUSH
39694: LD_INT 2
39696: NEG
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: LIST
39706: LIST
39707: LIST
39708: LIST
39709: LIST
39710: LIST
39711: LIST
39712: LIST
39713: LIST
39714: LIST
39715: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39716: LD_ADDR_VAR 0 53
39720: PUSH
39721: LD_INT 0
39723: PUSH
39724: LD_INT 0
39726: PUSH
39727: EMPTY
39728: LIST
39729: LIST
39730: PUSH
39731: LD_INT 0
39733: PUSH
39734: LD_INT 1
39736: NEG
39737: PUSH
39738: EMPTY
39739: LIST
39740: LIST
39741: PUSH
39742: LD_INT 1
39744: PUSH
39745: LD_INT 0
39747: PUSH
39748: EMPTY
39749: LIST
39750: LIST
39751: PUSH
39752: LD_INT 1
39754: PUSH
39755: LD_INT 1
39757: PUSH
39758: EMPTY
39759: LIST
39760: LIST
39761: PUSH
39762: LD_INT 0
39764: PUSH
39765: LD_INT 1
39767: PUSH
39768: EMPTY
39769: LIST
39770: LIST
39771: PUSH
39772: LD_INT 1
39774: NEG
39775: PUSH
39776: LD_INT 0
39778: PUSH
39779: EMPTY
39780: LIST
39781: LIST
39782: PUSH
39783: LD_INT 1
39785: NEG
39786: PUSH
39787: LD_INT 1
39789: NEG
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: PUSH
39795: LD_INT 1
39797: NEG
39798: PUSH
39799: LD_INT 2
39801: NEG
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: PUSH
39807: LD_INT 0
39809: PUSH
39810: LD_INT 2
39812: NEG
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 1
39820: PUSH
39821: LD_INT 1
39823: NEG
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 2
39831: PUSH
39832: LD_INT 0
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: PUSH
39839: LD_INT 2
39841: PUSH
39842: LD_INT 1
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: LD_INT 2
39851: PUSH
39852: LD_INT 2
39854: PUSH
39855: EMPTY
39856: LIST
39857: LIST
39858: PUSH
39859: LD_INT 1
39861: PUSH
39862: LD_INT 2
39864: PUSH
39865: EMPTY
39866: LIST
39867: LIST
39868: PUSH
39869: LD_INT 0
39871: PUSH
39872: LD_INT 2
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: PUSH
39879: LD_INT 1
39881: NEG
39882: PUSH
39883: LD_INT 1
39885: PUSH
39886: EMPTY
39887: LIST
39888: LIST
39889: PUSH
39890: LD_INT 2
39892: NEG
39893: PUSH
39894: LD_INT 0
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: PUSH
39901: LD_INT 2
39903: NEG
39904: PUSH
39905: LD_INT 1
39907: NEG
39908: PUSH
39909: EMPTY
39910: LIST
39911: LIST
39912: PUSH
39913: LD_INT 2
39915: NEG
39916: PUSH
39917: LD_INT 2
39919: NEG
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: PUSH
39925: EMPTY
39926: LIST
39927: LIST
39928: LIST
39929: LIST
39930: LIST
39931: LIST
39932: LIST
39933: LIST
39934: LIST
39935: LIST
39936: LIST
39937: LIST
39938: LIST
39939: LIST
39940: LIST
39941: LIST
39942: LIST
39943: LIST
39944: LIST
39945: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39946: LD_ADDR_VAR 0 54
39950: PUSH
39951: LD_INT 0
39953: PUSH
39954: LD_INT 0
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 0
39963: PUSH
39964: LD_INT 1
39966: NEG
39967: PUSH
39968: EMPTY
39969: LIST
39970: LIST
39971: PUSH
39972: LD_INT 1
39974: PUSH
39975: LD_INT 0
39977: PUSH
39978: EMPTY
39979: LIST
39980: LIST
39981: PUSH
39982: LD_INT 1
39984: PUSH
39985: LD_INT 1
39987: PUSH
39988: EMPTY
39989: LIST
39990: LIST
39991: PUSH
39992: LD_INT 0
39994: PUSH
39995: LD_INT 1
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: PUSH
40002: LD_INT 1
40004: NEG
40005: PUSH
40006: LD_INT 0
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: LD_INT 1
40015: NEG
40016: PUSH
40017: LD_INT 1
40019: NEG
40020: PUSH
40021: EMPTY
40022: LIST
40023: LIST
40024: PUSH
40025: LD_INT 1
40027: NEG
40028: PUSH
40029: LD_INT 2
40031: NEG
40032: PUSH
40033: EMPTY
40034: LIST
40035: LIST
40036: PUSH
40037: LD_INT 0
40039: PUSH
40040: LD_INT 2
40042: NEG
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: PUSH
40048: LD_INT 1
40050: PUSH
40051: LD_INT 1
40053: NEG
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PUSH
40059: LD_INT 2
40061: PUSH
40062: LD_INT 0
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 2
40071: PUSH
40072: LD_INT 1
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: LD_INT 2
40081: PUSH
40082: LD_INT 2
40084: PUSH
40085: EMPTY
40086: LIST
40087: LIST
40088: PUSH
40089: LD_INT 1
40091: PUSH
40092: LD_INT 2
40094: PUSH
40095: EMPTY
40096: LIST
40097: LIST
40098: PUSH
40099: LD_INT 0
40101: PUSH
40102: LD_INT 2
40104: PUSH
40105: EMPTY
40106: LIST
40107: LIST
40108: PUSH
40109: LD_INT 1
40111: NEG
40112: PUSH
40113: LD_INT 1
40115: PUSH
40116: EMPTY
40117: LIST
40118: LIST
40119: PUSH
40120: LD_INT 2
40122: NEG
40123: PUSH
40124: LD_INT 0
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PUSH
40131: LD_INT 2
40133: NEG
40134: PUSH
40135: LD_INT 1
40137: NEG
40138: PUSH
40139: EMPTY
40140: LIST
40141: LIST
40142: PUSH
40143: LD_INT 2
40145: NEG
40146: PUSH
40147: LD_INT 2
40149: NEG
40150: PUSH
40151: EMPTY
40152: LIST
40153: LIST
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: LIST
40159: LIST
40160: LIST
40161: LIST
40162: LIST
40163: LIST
40164: LIST
40165: LIST
40166: LIST
40167: LIST
40168: LIST
40169: LIST
40170: LIST
40171: LIST
40172: LIST
40173: LIST
40174: LIST
40175: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40176: LD_ADDR_VAR 0 55
40180: PUSH
40181: LD_INT 0
40183: PUSH
40184: LD_INT 0
40186: PUSH
40187: EMPTY
40188: LIST
40189: LIST
40190: PUSH
40191: LD_INT 0
40193: PUSH
40194: LD_INT 1
40196: NEG
40197: PUSH
40198: EMPTY
40199: LIST
40200: LIST
40201: PUSH
40202: LD_INT 1
40204: PUSH
40205: LD_INT 0
40207: PUSH
40208: EMPTY
40209: LIST
40210: LIST
40211: PUSH
40212: LD_INT 1
40214: PUSH
40215: LD_INT 1
40217: PUSH
40218: EMPTY
40219: LIST
40220: LIST
40221: PUSH
40222: LD_INT 0
40224: PUSH
40225: LD_INT 1
40227: PUSH
40228: EMPTY
40229: LIST
40230: LIST
40231: PUSH
40232: LD_INT 1
40234: NEG
40235: PUSH
40236: LD_INT 0
40238: PUSH
40239: EMPTY
40240: LIST
40241: LIST
40242: PUSH
40243: LD_INT 1
40245: NEG
40246: PUSH
40247: LD_INT 1
40249: NEG
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: PUSH
40255: LD_INT 1
40257: NEG
40258: PUSH
40259: LD_INT 2
40261: NEG
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: PUSH
40267: LD_INT 0
40269: PUSH
40270: LD_INT 2
40272: NEG
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: PUSH
40278: LD_INT 1
40280: PUSH
40281: LD_INT 1
40283: NEG
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: PUSH
40289: LD_INT 2
40291: PUSH
40292: LD_INT 0
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: LD_INT 2
40301: PUSH
40302: LD_INT 1
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: PUSH
40309: LD_INT 2
40311: PUSH
40312: LD_INT 2
40314: PUSH
40315: EMPTY
40316: LIST
40317: LIST
40318: PUSH
40319: LD_INT 1
40321: PUSH
40322: LD_INT 2
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PUSH
40329: LD_INT 0
40331: PUSH
40332: LD_INT 2
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: PUSH
40339: LD_INT 1
40341: NEG
40342: PUSH
40343: LD_INT 1
40345: PUSH
40346: EMPTY
40347: LIST
40348: LIST
40349: PUSH
40350: LD_INT 2
40352: NEG
40353: PUSH
40354: LD_INT 0
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 2
40363: NEG
40364: PUSH
40365: LD_INT 1
40367: NEG
40368: PUSH
40369: EMPTY
40370: LIST
40371: LIST
40372: PUSH
40373: LD_INT 2
40375: NEG
40376: PUSH
40377: LD_INT 2
40379: NEG
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: EMPTY
40386: LIST
40387: LIST
40388: LIST
40389: LIST
40390: LIST
40391: LIST
40392: LIST
40393: LIST
40394: LIST
40395: LIST
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: LIST
40403: LIST
40404: LIST
40405: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40406: LD_ADDR_VAR 0 56
40410: PUSH
40411: LD_INT 0
40413: PUSH
40414: LD_INT 0
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: LD_INT 0
40423: PUSH
40424: LD_INT 1
40426: NEG
40427: PUSH
40428: EMPTY
40429: LIST
40430: LIST
40431: PUSH
40432: LD_INT 1
40434: PUSH
40435: LD_INT 0
40437: PUSH
40438: EMPTY
40439: LIST
40440: LIST
40441: PUSH
40442: LD_INT 1
40444: PUSH
40445: LD_INT 1
40447: PUSH
40448: EMPTY
40449: LIST
40450: LIST
40451: PUSH
40452: LD_INT 0
40454: PUSH
40455: LD_INT 1
40457: PUSH
40458: EMPTY
40459: LIST
40460: LIST
40461: PUSH
40462: LD_INT 1
40464: NEG
40465: PUSH
40466: LD_INT 0
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: PUSH
40473: LD_INT 1
40475: NEG
40476: PUSH
40477: LD_INT 1
40479: NEG
40480: PUSH
40481: EMPTY
40482: LIST
40483: LIST
40484: PUSH
40485: LD_INT 1
40487: NEG
40488: PUSH
40489: LD_INT 2
40491: NEG
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: PUSH
40497: LD_INT 0
40499: PUSH
40500: LD_INT 2
40502: NEG
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: PUSH
40508: LD_INT 1
40510: PUSH
40511: LD_INT 1
40513: NEG
40514: PUSH
40515: EMPTY
40516: LIST
40517: LIST
40518: PUSH
40519: LD_INT 2
40521: PUSH
40522: LD_INT 0
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: PUSH
40529: LD_INT 2
40531: PUSH
40532: LD_INT 1
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 2
40541: PUSH
40542: LD_INT 2
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 1
40551: PUSH
40552: LD_INT 2
40554: PUSH
40555: EMPTY
40556: LIST
40557: LIST
40558: PUSH
40559: LD_INT 0
40561: PUSH
40562: LD_INT 2
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: LD_INT 1
40571: NEG
40572: PUSH
40573: LD_INT 1
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: LD_INT 2
40582: NEG
40583: PUSH
40584: LD_INT 0
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: LD_INT 2
40593: NEG
40594: PUSH
40595: LD_INT 1
40597: NEG
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PUSH
40603: LD_INT 2
40605: NEG
40606: PUSH
40607: LD_INT 2
40609: NEG
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PUSH
40615: EMPTY
40616: LIST
40617: LIST
40618: LIST
40619: LIST
40620: LIST
40621: LIST
40622: LIST
40623: LIST
40624: LIST
40625: LIST
40626: LIST
40627: LIST
40628: LIST
40629: LIST
40630: LIST
40631: LIST
40632: LIST
40633: LIST
40634: LIST
40635: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40636: LD_ADDR_VAR 0 57
40640: PUSH
40641: LD_INT 0
40643: PUSH
40644: LD_INT 0
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 0
40653: PUSH
40654: LD_INT 1
40656: NEG
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: PUSH
40662: LD_INT 1
40664: PUSH
40665: LD_INT 0
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: PUSH
40672: LD_INT 1
40674: PUSH
40675: LD_INT 1
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PUSH
40682: LD_INT 0
40684: PUSH
40685: LD_INT 1
40687: PUSH
40688: EMPTY
40689: LIST
40690: LIST
40691: PUSH
40692: LD_INT 1
40694: NEG
40695: PUSH
40696: LD_INT 0
40698: PUSH
40699: EMPTY
40700: LIST
40701: LIST
40702: PUSH
40703: LD_INT 1
40705: NEG
40706: PUSH
40707: LD_INT 1
40709: NEG
40710: PUSH
40711: EMPTY
40712: LIST
40713: LIST
40714: PUSH
40715: LD_INT 1
40717: NEG
40718: PUSH
40719: LD_INT 2
40721: NEG
40722: PUSH
40723: EMPTY
40724: LIST
40725: LIST
40726: PUSH
40727: LD_INT 0
40729: PUSH
40730: LD_INT 2
40732: NEG
40733: PUSH
40734: EMPTY
40735: LIST
40736: LIST
40737: PUSH
40738: LD_INT 1
40740: PUSH
40741: LD_INT 1
40743: NEG
40744: PUSH
40745: EMPTY
40746: LIST
40747: LIST
40748: PUSH
40749: LD_INT 2
40751: PUSH
40752: LD_INT 0
40754: PUSH
40755: EMPTY
40756: LIST
40757: LIST
40758: PUSH
40759: LD_INT 2
40761: PUSH
40762: LD_INT 1
40764: PUSH
40765: EMPTY
40766: LIST
40767: LIST
40768: PUSH
40769: LD_INT 2
40771: PUSH
40772: LD_INT 2
40774: PUSH
40775: EMPTY
40776: LIST
40777: LIST
40778: PUSH
40779: LD_INT 1
40781: PUSH
40782: LD_INT 2
40784: PUSH
40785: EMPTY
40786: LIST
40787: LIST
40788: PUSH
40789: LD_INT 0
40791: PUSH
40792: LD_INT 2
40794: PUSH
40795: EMPTY
40796: LIST
40797: LIST
40798: PUSH
40799: LD_INT 1
40801: NEG
40802: PUSH
40803: LD_INT 1
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: PUSH
40810: LD_INT 2
40812: NEG
40813: PUSH
40814: LD_INT 0
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PUSH
40821: LD_INT 2
40823: NEG
40824: PUSH
40825: LD_INT 1
40827: NEG
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: PUSH
40833: LD_INT 2
40835: NEG
40836: PUSH
40837: LD_INT 2
40839: NEG
40840: PUSH
40841: EMPTY
40842: LIST
40843: LIST
40844: PUSH
40845: EMPTY
40846: LIST
40847: LIST
40848: LIST
40849: LIST
40850: LIST
40851: LIST
40852: LIST
40853: LIST
40854: LIST
40855: LIST
40856: LIST
40857: LIST
40858: LIST
40859: LIST
40860: LIST
40861: LIST
40862: LIST
40863: LIST
40864: LIST
40865: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40866: LD_ADDR_VAR 0 58
40870: PUSH
40871: LD_INT 0
40873: PUSH
40874: LD_INT 0
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: PUSH
40881: LD_INT 0
40883: PUSH
40884: LD_INT 1
40886: NEG
40887: PUSH
40888: EMPTY
40889: LIST
40890: LIST
40891: PUSH
40892: LD_INT 1
40894: PUSH
40895: LD_INT 0
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: PUSH
40902: LD_INT 1
40904: PUSH
40905: LD_INT 1
40907: PUSH
40908: EMPTY
40909: LIST
40910: LIST
40911: PUSH
40912: LD_INT 0
40914: PUSH
40915: LD_INT 1
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: PUSH
40922: LD_INT 1
40924: NEG
40925: PUSH
40926: LD_INT 0
40928: PUSH
40929: EMPTY
40930: LIST
40931: LIST
40932: PUSH
40933: LD_INT 1
40935: NEG
40936: PUSH
40937: LD_INT 1
40939: NEG
40940: PUSH
40941: EMPTY
40942: LIST
40943: LIST
40944: PUSH
40945: LD_INT 1
40947: NEG
40948: PUSH
40949: LD_INT 2
40951: NEG
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: LD_INT 0
40959: PUSH
40960: LD_INT 2
40962: NEG
40963: PUSH
40964: EMPTY
40965: LIST
40966: LIST
40967: PUSH
40968: LD_INT 1
40970: PUSH
40971: LD_INT 1
40973: NEG
40974: PUSH
40975: EMPTY
40976: LIST
40977: LIST
40978: PUSH
40979: LD_INT 2
40981: PUSH
40982: LD_INT 0
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: PUSH
40989: LD_INT 2
40991: PUSH
40992: LD_INT 1
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: PUSH
40999: LD_INT 2
41001: PUSH
41002: LD_INT 2
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 1
41011: PUSH
41012: LD_INT 2
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 0
41021: PUSH
41022: LD_INT 2
41024: PUSH
41025: EMPTY
41026: LIST
41027: LIST
41028: PUSH
41029: LD_INT 1
41031: NEG
41032: PUSH
41033: LD_INT 1
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: PUSH
41040: LD_INT 2
41042: NEG
41043: PUSH
41044: LD_INT 0
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: PUSH
41051: LD_INT 2
41053: NEG
41054: PUSH
41055: LD_INT 1
41057: NEG
41058: PUSH
41059: EMPTY
41060: LIST
41061: LIST
41062: PUSH
41063: LD_INT 2
41065: NEG
41066: PUSH
41067: LD_INT 2
41069: NEG
41070: PUSH
41071: EMPTY
41072: LIST
41073: LIST
41074: PUSH
41075: EMPTY
41076: LIST
41077: LIST
41078: LIST
41079: LIST
41080: LIST
41081: LIST
41082: LIST
41083: LIST
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: LIST
41089: LIST
41090: LIST
41091: LIST
41092: LIST
41093: LIST
41094: LIST
41095: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41096: LD_ADDR_VAR 0 59
41100: PUSH
41101: LD_INT 0
41103: PUSH
41104: LD_INT 0
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: LD_INT 0
41113: PUSH
41114: LD_INT 1
41116: NEG
41117: PUSH
41118: EMPTY
41119: LIST
41120: LIST
41121: PUSH
41122: LD_INT 1
41124: PUSH
41125: LD_INT 0
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: LD_INT 1
41134: PUSH
41135: LD_INT 1
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 0
41144: PUSH
41145: LD_INT 1
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 1
41154: NEG
41155: PUSH
41156: LD_INT 0
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PUSH
41163: LD_INT 1
41165: NEG
41166: PUSH
41167: LD_INT 1
41169: NEG
41170: PUSH
41171: EMPTY
41172: LIST
41173: LIST
41174: PUSH
41175: EMPTY
41176: LIST
41177: LIST
41178: LIST
41179: LIST
41180: LIST
41181: LIST
41182: LIST
41183: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41184: LD_ADDR_VAR 0 60
41188: PUSH
41189: LD_INT 0
41191: PUSH
41192: LD_INT 0
41194: PUSH
41195: EMPTY
41196: LIST
41197: LIST
41198: PUSH
41199: LD_INT 0
41201: PUSH
41202: LD_INT 1
41204: NEG
41205: PUSH
41206: EMPTY
41207: LIST
41208: LIST
41209: PUSH
41210: LD_INT 1
41212: PUSH
41213: LD_INT 0
41215: PUSH
41216: EMPTY
41217: LIST
41218: LIST
41219: PUSH
41220: LD_INT 1
41222: PUSH
41223: LD_INT 1
41225: PUSH
41226: EMPTY
41227: LIST
41228: LIST
41229: PUSH
41230: LD_INT 0
41232: PUSH
41233: LD_INT 1
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: LD_INT 1
41242: NEG
41243: PUSH
41244: LD_INT 0
41246: PUSH
41247: EMPTY
41248: LIST
41249: LIST
41250: PUSH
41251: LD_INT 1
41253: NEG
41254: PUSH
41255: LD_INT 1
41257: NEG
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: PUSH
41263: EMPTY
41264: LIST
41265: LIST
41266: LIST
41267: LIST
41268: LIST
41269: LIST
41270: LIST
41271: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41272: LD_ADDR_VAR 0 61
41276: PUSH
41277: LD_INT 0
41279: PUSH
41280: LD_INT 0
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: LD_INT 0
41289: PUSH
41290: LD_INT 1
41292: NEG
41293: PUSH
41294: EMPTY
41295: LIST
41296: LIST
41297: PUSH
41298: LD_INT 1
41300: PUSH
41301: LD_INT 0
41303: PUSH
41304: EMPTY
41305: LIST
41306: LIST
41307: PUSH
41308: LD_INT 1
41310: PUSH
41311: LD_INT 1
41313: PUSH
41314: EMPTY
41315: LIST
41316: LIST
41317: PUSH
41318: LD_INT 0
41320: PUSH
41321: LD_INT 1
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: PUSH
41328: LD_INT 1
41330: NEG
41331: PUSH
41332: LD_INT 0
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 1
41341: NEG
41342: PUSH
41343: LD_INT 1
41345: NEG
41346: PUSH
41347: EMPTY
41348: LIST
41349: LIST
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: LIST
41355: LIST
41356: LIST
41357: LIST
41358: LIST
41359: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41360: LD_ADDR_VAR 0 62
41364: PUSH
41365: LD_INT 0
41367: PUSH
41368: LD_INT 0
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: PUSH
41375: LD_INT 0
41377: PUSH
41378: LD_INT 1
41380: NEG
41381: PUSH
41382: EMPTY
41383: LIST
41384: LIST
41385: PUSH
41386: LD_INT 1
41388: PUSH
41389: LD_INT 0
41391: PUSH
41392: EMPTY
41393: LIST
41394: LIST
41395: PUSH
41396: LD_INT 1
41398: PUSH
41399: LD_INT 1
41401: PUSH
41402: EMPTY
41403: LIST
41404: LIST
41405: PUSH
41406: LD_INT 0
41408: PUSH
41409: LD_INT 1
41411: PUSH
41412: EMPTY
41413: LIST
41414: LIST
41415: PUSH
41416: LD_INT 1
41418: NEG
41419: PUSH
41420: LD_INT 0
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: PUSH
41427: LD_INT 1
41429: NEG
41430: PUSH
41431: LD_INT 1
41433: NEG
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: LIST
41443: LIST
41444: LIST
41445: LIST
41446: LIST
41447: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41448: LD_ADDR_VAR 0 63
41452: PUSH
41453: LD_INT 0
41455: PUSH
41456: LD_INT 0
41458: PUSH
41459: EMPTY
41460: LIST
41461: LIST
41462: PUSH
41463: LD_INT 0
41465: PUSH
41466: LD_INT 1
41468: NEG
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: PUSH
41474: LD_INT 1
41476: PUSH
41477: LD_INT 0
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 1
41486: PUSH
41487: LD_INT 1
41489: PUSH
41490: EMPTY
41491: LIST
41492: LIST
41493: PUSH
41494: LD_INT 0
41496: PUSH
41497: LD_INT 1
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 1
41506: NEG
41507: PUSH
41508: LD_INT 0
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: LD_INT 1
41517: NEG
41518: PUSH
41519: LD_INT 1
41521: NEG
41522: PUSH
41523: EMPTY
41524: LIST
41525: LIST
41526: PUSH
41527: EMPTY
41528: LIST
41529: LIST
41530: LIST
41531: LIST
41532: LIST
41533: LIST
41534: LIST
41535: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41536: LD_ADDR_VAR 0 64
41540: PUSH
41541: LD_INT 0
41543: PUSH
41544: LD_INT 0
41546: PUSH
41547: EMPTY
41548: LIST
41549: LIST
41550: PUSH
41551: LD_INT 0
41553: PUSH
41554: LD_INT 1
41556: NEG
41557: PUSH
41558: EMPTY
41559: LIST
41560: LIST
41561: PUSH
41562: LD_INT 1
41564: PUSH
41565: LD_INT 0
41567: PUSH
41568: EMPTY
41569: LIST
41570: LIST
41571: PUSH
41572: LD_INT 1
41574: PUSH
41575: LD_INT 1
41577: PUSH
41578: EMPTY
41579: LIST
41580: LIST
41581: PUSH
41582: LD_INT 0
41584: PUSH
41585: LD_INT 1
41587: PUSH
41588: EMPTY
41589: LIST
41590: LIST
41591: PUSH
41592: LD_INT 1
41594: NEG
41595: PUSH
41596: LD_INT 0
41598: PUSH
41599: EMPTY
41600: LIST
41601: LIST
41602: PUSH
41603: LD_INT 1
41605: NEG
41606: PUSH
41607: LD_INT 1
41609: NEG
41610: PUSH
41611: EMPTY
41612: LIST
41613: LIST
41614: PUSH
41615: EMPTY
41616: LIST
41617: LIST
41618: LIST
41619: LIST
41620: LIST
41621: LIST
41622: LIST
41623: ST_TO_ADDR
// end ; 1 :
41624: GO 47521
41626: LD_INT 1
41628: DOUBLE
41629: EQUAL
41630: IFTRUE 41634
41632: GO 44257
41634: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41635: LD_ADDR_VAR 0 11
41639: PUSH
41640: LD_INT 1
41642: NEG
41643: PUSH
41644: LD_INT 3
41646: NEG
41647: PUSH
41648: EMPTY
41649: LIST
41650: LIST
41651: PUSH
41652: LD_INT 0
41654: PUSH
41655: LD_INT 3
41657: NEG
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: LD_INT 1
41665: PUSH
41666: LD_INT 2
41668: NEG
41669: PUSH
41670: EMPTY
41671: LIST
41672: LIST
41673: PUSH
41674: EMPTY
41675: LIST
41676: LIST
41677: LIST
41678: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41679: LD_ADDR_VAR 0 12
41683: PUSH
41684: LD_INT 2
41686: PUSH
41687: LD_INT 1
41689: NEG
41690: PUSH
41691: EMPTY
41692: LIST
41693: LIST
41694: PUSH
41695: LD_INT 3
41697: PUSH
41698: LD_INT 0
41700: PUSH
41701: EMPTY
41702: LIST
41703: LIST
41704: PUSH
41705: LD_INT 3
41707: PUSH
41708: LD_INT 1
41710: PUSH
41711: EMPTY
41712: LIST
41713: LIST
41714: PUSH
41715: EMPTY
41716: LIST
41717: LIST
41718: LIST
41719: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41720: LD_ADDR_VAR 0 13
41724: PUSH
41725: LD_INT 3
41727: PUSH
41728: LD_INT 2
41730: PUSH
41731: EMPTY
41732: LIST
41733: LIST
41734: PUSH
41735: LD_INT 3
41737: PUSH
41738: LD_INT 3
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: PUSH
41745: LD_INT 2
41747: PUSH
41748: LD_INT 3
41750: PUSH
41751: EMPTY
41752: LIST
41753: LIST
41754: PUSH
41755: EMPTY
41756: LIST
41757: LIST
41758: LIST
41759: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41760: LD_ADDR_VAR 0 14
41764: PUSH
41765: LD_INT 1
41767: PUSH
41768: LD_INT 3
41770: PUSH
41771: EMPTY
41772: LIST
41773: LIST
41774: PUSH
41775: LD_INT 0
41777: PUSH
41778: LD_INT 3
41780: PUSH
41781: EMPTY
41782: LIST
41783: LIST
41784: PUSH
41785: LD_INT 1
41787: NEG
41788: PUSH
41789: LD_INT 2
41791: PUSH
41792: EMPTY
41793: LIST
41794: LIST
41795: PUSH
41796: EMPTY
41797: LIST
41798: LIST
41799: LIST
41800: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41801: LD_ADDR_VAR 0 15
41805: PUSH
41806: LD_INT 2
41808: NEG
41809: PUSH
41810: LD_INT 1
41812: PUSH
41813: EMPTY
41814: LIST
41815: LIST
41816: PUSH
41817: LD_INT 3
41819: NEG
41820: PUSH
41821: LD_INT 0
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 3
41830: NEG
41831: PUSH
41832: LD_INT 1
41834: NEG
41835: PUSH
41836: EMPTY
41837: LIST
41838: LIST
41839: PUSH
41840: EMPTY
41841: LIST
41842: LIST
41843: LIST
41844: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41845: LD_ADDR_VAR 0 16
41849: PUSH
41850: LD_INT 2
41852: NEG
41853: PUSH
41854: LD_INT 3
41856: NEG
41857: PUSH
41858: EMPTY
41859: LIST
41860: LIST
41861: PUSH
41862: LD_INT 3
41864: NEG
41865: PUSH
41866: LD_INT 2
41868: NEG
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: PUSH
41874: LD_INT 3
41876: NEG
41877: PUSH
41878: LD_INT 3
41880: NEG
41881: PUSH
41882: EMPTY
41883: LIST
41884: LIST
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: LIST
41890: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41891: LD_ADDR_VAR 0 17
41895: PUSH
41896: LD_INT 1
41898: NEG
41899: PUSH
41900: LD_INT 3
41902: NEG
41903: PUSH
41904: EMPTY
41905: LIST
41906: LIST
41907: PUSH
41908: LD_INT 0
41910: PUSH
41911: LD_INT 3
41913: NEG
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: LD_INT 1
41921: PUSH
41922: LD_INT 2
41924: NEG
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: LIST
41934: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41935: LD_ADDR_VAR 0 18
41939: PUSH
41940: LD_INT 2
41942: PUSH
41943: LD_INT 1
41945: NEG
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PUSH
41951: LD_INT 3
41953: PUSH
41954: LD_INT 0
41956: PUSH
41957: EMPTY
41958: LIST
41959: LIST
41960: PUSH
41961: LD_INT 3
41963: PUSH
41964: LD_INT 1
41966: PUSH
41967: EMPTY
41968: LIST
41969: LIST
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: LIST
41975: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41976: LD_ADDR_VAR 0 19
41980: PUSH
41981: LD_INT 3
41983: PUSH
41984: LD_INT 2
41986: PUSH
41987: EMPTY
41988: LIST
41989: LIST
41990: PUSH
41991: LD_INT 3
41993: PUSH
41994: LD_INT 3
41996: PUSH
41997: EMPTY
41998: LIST
41999: LIST
42000: PUSH
42001: LD_INT 2
42003: PUSH
42004: LD_INT 3
42006: PUSH
42007: EMPTY
42008: LIST
42009: LIST
42010: PUSH
42011: EMPTY
42012: LIST
42013: LIST
42014: LIST
42015: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42016: LD_ADDR_VAR 0 20
42020: PUSH
42021: LD_INT 1
42023: PUSH
42024: LD_INT 3
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: PUSH
42031: LD_INT 0
42033: PUSH
42034: LD_INT 3
42036: PUSH
42037: EMPTY
42038: LIST
42039: LIST
42040: PUSH
42041: LD_INT 1
42043: NEG
42044: PUSH
42045: LD_INT 2
42047: PUSH
42048: EMPTY
42049: LIST
42050: LIST
42051: PUSH
42052: EMPTY
42053: LIST
42054: LIST
42055: LIST
42056: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42057: LD_ADDR_VAR 0 21
42061: PUSH
42062: LD_INT 2
42064: NEG
42065: PUSH
42066: LD_INT 1
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: PUSH
42073: LD_INT 3
42075: NEG
42076: PUSH
42077: LD_INT 0
42079: PUSH
42080: EMPTY
42081: LIST
42082: LIST
42083: PUSH
42084: LD_INT 3
42086: NEG
42087: PUSH
42088: LD_INT 1
42090: NEG
42091: PUSH
42092: EMPTY
42093: LIST
42094: LIST
42095: PUSH
42096: EMPTY
42097: LIST
42098: LIST
42099: LIST
42100: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42101: LD_ADDR_VAR 0 22
42105: PUSH
42106: LD_INT 2
42108: NEG
42109: PUSH
42110: LD_INT 3
42112: NEG
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: LD_INT 3
42120: NEG
42121: PUSH
42122: LD_INT 2
42124: NEG
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: PUSH
42130: LD_INT 3
42132: NEG
42133: PUSH
42134: LD_INT 3
42136: NEG
42137: PUSH
42138: EMPTY
42139: LIST
42140: LIST
42141: PUSH
42142: EMPTY
42143: LIST
42144: LIST
42145: LIST
42146: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
42147: LD_ADDR_VAR 0 23
42151: PUSH
42152: LD_INT 0
42154: PUSH
42155: LD_INT 3
42157: NEG
42158: PUSH
42159: EMPTY
42160: LIST
42161: LIST
42162: PUSH
42163: LD_INT 1
42165: NEG
42166: PUSH
42167: LD_INT 4
42169: NEG
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: PUSH
42175: LD_INT 1
42177: PUSH
42178: LD_INT 3
42180: NEG
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: LIST
42190: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
42191: LD_ADDR_VAR 0 24
42195: PUSH
42196: LD_INT 3
42198: PUSH
42199: LD_INT 0
42201: PUSH
42202: EMPTY
42203: LIST
42204: LIST
42205: PUSH
42206: LD_INT 3
42208: PUSH
42209: LD_INT 1
42211: NEG
42212: PUSH
42213: EMPTY
42214: LIST
42215: LIST
42216: PUSH
42217: LD_INT 4
42219: PUSH
42220: LD_INT 1
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: LIST
42231: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
42232: LD_ADDR_VAR 0 25
42236: PUSH
42237: LD_INT 3
42239: PUSH
42240: LD_INT 3
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: LD_INT 4
42249: PUSH
42250: LD_INT 3
42252: PUSH
42253: EMPTY
42254: LIST
42255: LIST
42256: PUSH
42257: LD_INT 3
42259: PUSH
42260: LD_INT 4
42262: PUSH
42263: EMPTY
42264: LIST
42265: LIST
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: LIST
42271: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
42272: LD_ADDR_VAR 0 26
42276: PUSH
42277: LD_INT 0
42279: PUSH
42280: LD_INT 3
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: PUSH
42287: LD_INT 1
42289: PUSH
42290: LD_INT 4
42292: PUSH
42293: EMPTY
42294: LIST
42295: LIST
42296: PUSH
42297: LD_INT 1
42299: NEG
42300: PUSH
42301: LD_INT 3
42303: PUSH
42304: EMPTY
42305: LIST
42306: LIST
42307: PUSH
42308: EMPTY
42309: LIST
42310: LIST
42311: LIST
42312: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
42313: LD_ADDR_VAR 0 27
42317: PUSH
42318: LD_INT 3
42320: NEG
42321: PUSH
42322: LD_INT 0
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: PUSH
42329: LD_INT 3
42331: NEG
42332: PUSH
42333: LD_INT 1
42335: PUSH
42336: EMPTY
42337: LIST
42338: LIST
42339: PUSH
42340: LD_INT 4
42342: NEG
42343: PUSH
42344: LD_INT 1
42346: NEG
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: LIST
42356: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
42357: LD_ADDR_VAR 0 28
42361: PUSH
42362: LD_INT 3
42364: NEG
42365: PUSH
42366: LD_INT 3
42368: NEG
42369: PUSH
42370: EMPTY
42371: LIST
42372: LIST
42373: PUSH
42374: LD_INT 3
42376: NEG
42377: PUSH
42378: LD_INT 4
42380: NEG
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: PUSH
42386: LD_INT 4
42388: NEG
42389: PUSH
42390: LD_INT 3
42392: NEG
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: EMPTY
42399: LIST
42400: LIST
42401: LIST
42402: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
42403: LD_ADDR_VAR 0 29
42407: PUSH
42408: LD_INT 1
42410: NEG
42411: PUSH
42412: LD_INT 3
42414: NEG
42415: PUSH
42416: EMPTY
42417: LIST
42418: LIST
42419: PUSH
42420: LD_INT 0
42422: PUSH
42423: LD_INT 3
42425: NEG
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: LD_INT 1
42433: PUSH
42434: LD_INT 2
42436: NEG
42437: PUSH
42438: EMPTY
42439: LIST
42440: LIST
42441: PUSH
42442: LD_INT 1
42444: NEG
42445: PUSH
42446: LD_INT 4
42448: NEG
42449: PUSH
42450: EMPTY
42451: LIST
42452: LIST
42453: PUSH
42454: LD_INT 0
42456: PUSH
42457: LD_INT 4
42459: NEG
42460: PUSH
42461: EMPTY
42462: LIST
42463: LIST
42464: PUSH
42465: LD_INT 1
42467: PUSH
42468: LD_INT 3
42470: NEG
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: LD_INT 1
42478: NEG
42479: PUSH
42480: LD_INT 5
42482: NEG
42483: PUSH
42484: EMPTY
42485: LIST
42486: LIST
42487: PUSH
42488: LD_INT 0
42490: PUSH
42491: LD_INT 5
42493: NEG
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 1
42501: PUSH
42502: LD_INT 4
42504: NEG
42505: PUSH
42506: EMPTY
42507: LIST
42508: LIST
42509: PUSH
42510: LD_INT 1
42512: NEG
42513: PUSH
42514: LD_INT 6
42516: NEG
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 0
42524: PUSH
42525: LD_INT 6
42527: NEG
42528: PUSH
42529: EMPTY
42530: LIST
42531: LIST
42532: PUSH
42533: LD_INT 1
42535: PUSH
42536: LD_INT 5
42538: NEG
42539: PUSH
42540: EMPTY
42541: LIST
42542: LIST
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: LIST
42548: LIST
42549: LIST
42550: LIST
42551: LIST
42552: LIST
42553: LIST
42554: LIST
42555: LIST
42556: LIST
42557: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
42558: LD_ADDR_VAR 0 30
42562: PUSH
42563: LD_INT 2
42565: PUSH
42566: LD_INT 1
42568: NEG
42569: PUSH
42570: EMPTY
42571: LIST
42572: LIST
42573: PUSH
42574: LD_INT 3
42576: PUSH
42577: LD_INT 0
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: LD_INT 3
42586: PUSH
42587: LD_INT 1
42589: PUSH
42590: EMPTY
42591: LIST
42592: LIST
42593: PUSH
42594: LD_INT 3
42596: PUSH
42597: LD_INT 1
42599: NEG
42600: PUSH
42601: EMPTY
42602: LIST
42603: LIST
42604: PUSH
42605: LD_INT 4
42607: PUSH
42608: LD_INT 0
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: PUSH
42615: LD_INT 4
42617: PUSH
42618: LD_INT 1
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: PUSH
42625: LD_INT 4
42627: PUSH
42628: LD_INT 1
42630: NEG
42631: PUSH
42632: EMPTY
42633: LIST
42634: LIST
42635: PUSH
42636: LD_INT 5
42638: PUSH
42639: LD_INT 0
42641: PUSH
42642: EMPTY
42643: LIST
42644: LIST
42645: PUSH
42646: LD_INT 5
42648: PUSH
42649: LD_INT 1
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: PUSH
42656: LD_INT 5
42658: PUSH
42659: LD_INT 1
42661: NEG
42662: PUSH
42663: EMPTY
42664: LIST
42665: LIST
42666: PUSH
42667: LD_INT 6
42669: PUSH
42670: LD_INT 0
42672: PUSH
42673: EMPTY
42674: LIST
42675: LIST
42676: PUSH
42677: LD_INT 6
42679: PUSH
42680: LD_INT 1
42682: PUSH
42683: EMPTY
42684: LIST
42685: LIST
42686: PUSH
42687: EMPTY
42688: LIST
42689: LIST
42690: LIST
42691: LIST
42692: LIST
42693: LIST
42694: LIST
42695: LIST
42696: LIST
42697: LIST
42698: LIST
42699: LIST
42700: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
42701: LD_ADDR_VAR 0 31
42705: PUSH
42706: LD_INT 3
42708: PUSH
42709: LD_INT 2
42711: PUSH
42712: EMPTY
42713: LIST
42714: LIST
42715: PUSH
42716: LD_INT 3
42718: PUSH
42719: LD_INT 3
42721: PUSH
42722: EMPTY
42723: LIST
42724: LIST
42725: PUSH
42726: LD_INT 2
42728: PUSH
42729: LD_INT 3
42731: PUSH
42732: EMPTY
42733: LIST
42734: LIST
42735: PUSH
42736: LD_INT 4
42738: PUSH
42739: LD_INT 3
42741: PUSH
42742: EMPTY
42743: LIST
42744: LIST
42745: PUSH
42746: LD_INT 4
42748: PUSH
42749: LD_INT 4
42751: PUSH
42752: EMPTY
42753: LIST
42754: LIST
42755: PUSH
42756: LD_INT 3
42758: PUSH
42759: LD_INT 4
42761: PUSH
42762: EMPTY
42763: LIST
42764: LIST
42765: PUSH
42766: LD_INT 5
42768: PUSH
42769: LD_INT 4
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: PUSH
42776: LD_INT 5
42778: PUSH
42779: LD_INT 5
42781: PUSH
42782: EMPTY
42783: LIST
42784: LIST
42785: PUSH
42786: LD_INT 4
42788: PUSH
42789: LD_INT 5
42791: PUSH
42792: EMPTY
42793: LIST
42794: LIST
42795: PUSH
42796: LD_INT 6
42798: PUSH
42799: LD_INT 5
42801: PUSH
42802: EMPTY
42803: LIST
42804: LIST
42805: PUSH
42806: LD_INT 6
42808: PUSH
42809: LD_INT 6
42811: PUSH
42812: EMPTY
42813: LIST
42814: LIST
42815: PUSH
42816: LD_INT 5
42818: PUSH
42819: LD_INT 6
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: EMPTY
42827: LIST
42828: LIST
42829: LIST
42830: LIST
42831: LIST
42832: LIST
42833: LIST
42834: LIST
42835: LIST
42836: LIST
42837: LIST
42838: LIST
42839: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42840: LD_ADDR_VAR 0 32
42844: PUSH
42845: LD_INT 1
42847: PUSH
42848: LD_INT 3
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 0
42857: PUSH
42858: LD_INT 3
42860: PUSH
42861: EMPTY
42862: LIST
42863: LIST
42864: PUSH
42865: LD_INT 1
42867: NEG
42868: PUSH
42869: LD_INT 2
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PUSH
42876: LD_INT 1
42878: PUSH
42879: LD_INT 4
42881: PUSH
42882: EMPTY
42883: LIST
42884: LIST
42885: PUSH
42886: LD_INT 0
42888: PUSH
42889: LD_INT 4
42891: PUSH
42892: EMPTY
42893: LIST
42894: LIST
42895: PUSH
42896: LD_INT 1
42898: NEG
42899: PUSH
42900: LD_INT 3
42902: PUSH
42903: EMPTY
42904: LIST
42905: LIST
42906: PUSH
42907: LD_INT 1
42909: PUSH
42910: LD_INT 5
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PUSH
42917: LD_INT 0
42919: PUSH
42920: LD_INT 5
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: LD_INT 1
42929: NEG
42930: PUSH
42931: LD_INT 4
42933: PUSH
42934: EMPTY
42935: LIST
42936: LIST
42937: PUSH
42938: LD_INT 1
42940: PUSH
42941: LD_INT 6
42943: PUSH
42944: EMPTY
42945: LIST
42946: LIST
42947: PUSH
42948: LD_INT 0
42950: PUSH
42951: LD_INT 6
42953: PUSH
42954: EMPTY
42955: LIST
42956: LIST
42957: PUSH
42958: LD_INT 1
42960: NEG
42961: PUSH
42962: LD_INT 5
42964: PUSH
42965: EMPTY
42966: LIST
42967: LIST
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: LIST
42973: LIST
42974: LIST
42975: LIST
42976: LIST
42977: LIST
42978: LIST
42979: LIST
42980: LIST
42981: LIST
42982: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42983: LD_ADDR_VAR 0 33
42987: PUSH
42988: LD_INT 2
42990: NEG
42991: PUSH
42992: LD_INT 1
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: LD_INT 3
43001: NEG
43002: PUSH
43003: LD_INT 0
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: PUSH
43010: LD_INT 3
43012: NEG
43013: PUSH
43014: LD_INT 1
43016: NEG
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: PUSH
43022: LD_INT 3
43024: NEG
43025: PUSH
43026: LD_INT 1
43028: PUSH
43029: EMPTY
43030: LIST
43031: LIST
43032: PUSH
43033: LD_INT 4
43035: NEG
43036: PUSH
43037: LD_INT 0
43039: PUSH
43040: EMPTY
43041: LIST
43042: LIST
43043: PUSH
43044: LD_INT 4
43046: NEG
43047: PUSH
43048: LD_INT 1
43050: NEG
43051: PUSH
43052: EMPTY
43053: LIST
43054: LIST
43055: PUSH
43056: LD_INT 4
43058: NEG
43059: PUSH
43060: LD_INT 1
43062: PUSH
43063: EMPTY
43064: LIST
43065: LIST
43066: PUSH
43067: LD_INT 5
43069: NEG
43070: PUSH
43071: LD_INT 0
43073: PUSH
43074: EMPTY
43075: LIST
43076: LIST
43077: PUSH
43078: LD_INT 5
43080: NEG
43081: PUSH
43082: LD_INT 1
43084: NEG
43085: PUSH
43086: EMPTY
43087: LIST
43088: LIST
43089: PUSH
43090: LD_INT 5
43092: NEG
43093: PUSH
43094: LD_INT 1
43096: PUSH
43097: EMPTY
43098: LIST
43099: LIST
43100: PUSH
43101: LD_INT 6
43103: NEG
43104: PUSH
43105: LD_INT 0
43107: PUSH
43108: EMPTY
43109: LIST
43110: LIST
43111: PUSH
43112: LD_INT 6
43114: NEG
43115: PUSH
43116: LD_INT 1
43118: NEG
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: EMPTY
43125: LIST
43126: LIST
43127: LIST
43128: LIST
43129: LIST
43130: LIST
43131: LIST
43132: LIST
43133: LIST
43134: LIST
43135: LIST
43136: LIST
43137: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
43138: LD_ADDR_VAR 0 34
43142: PUSH
43143: LD_INT 2
43145: NEG
43146: PUSH
43147: LD_INT 3
43149: NEG
43150: PUSH
43151: EMPTY
43152: LIST
43153: LIST
43154: PUSH
43155: LD_INT 3
43157: NEG
43158: PUSH
43159: LD_INT 2
43161: NEG
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 3
43169: NEG
43170: PUSH
43171: LD_INT 3
43173: NEG
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: LD_INT 3
43181: NEG
43182: PUSH
43183: LD_INT 4
43185: NEG
43186: PUSH
43187: EMPTY
43188: LIST
43189: LIST
43190: PUSH
43191: LD_INT 4
43193: NEG
43194: PUSH
43195: LD_INT 3
43197: NEG
43198: PUSH
43199: EMPTY
43200: LIST
43201: LIST
43202: PUSH
43203: LD_INT 4
43205: NEG
43206: PUSH
43207: LD_INT 4
43209: NEG
43210: PUSH
43211: EMPTY
43212: LIST
43213: LIST
43214: PUSH
43215: LD_INT 4
43217: NEG
43218: PUSH
43219: LD_INT 5
43221: NEG
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: PUSH
43227: LD_INT 5
43229: NEG
43230: PUSH
43231: LD_INT 4
43233: NEG
43234: PUSH
43235: EMPTY
43236: LIST
43237: LIST
43238: PUSH
43239: LD_INT 5
43241: NEG
43242: PUSH
43243: LD_INT 5
43245: NEG
43246: PUSH
43247: EMPTY
43248: LIST
43249: LIST
43250: PUSH
43251: LD_INT 5
43253: NEG
43254: PUSH
43255: LD_INT 6
43257: NEG
43258: PUSH
43259: EMPTY
43260: LIST
43261: LIST
43262: PUSH
43263: LD_INT 6
43265: NEG
43266: PUSH
43267: LD_INT 5
43269: NEG
43270: PUSH
43271: EMPTY
43272: LIST
43273: LIST
43274: PUSH
43275: LD_INT 6
43277: NEG
43278: PUSH
43279: LD_INT 6
43281: NEG
43282: PUSH
43283: EMPTY
43284: LIST
43285: LIST
43286: PUSH
43287: EMPTY
43288: LIST
43289: LIST
43290: LIST
43291: LIST
43292: LIST
43293: LIST
43294: LIST
43295: LIST
43296: LIST
43297: LIST
43298: LIST
43299: LIST
43300: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
43301: LD_ADDR_VAR 0 41
43305: PUSH
43306: LD_INT 0
43308: PUSH
43309: LD_INT 2
43311: NEG
43312: PUSH
43313: EMPTY
43314: LIST
43315: LIST
43316: PUSH
43317: LD_INT 1
43319: NEG
43320: PUSH
43321: LD_INT 3
43323: NEG
43324: PUSH
43325: EMPTY
43326: LIST
43327: LIST
43328: PUSH
43329: LD_INT 1
43331: PUSH
43332: LD_INT 2
43334: NEG
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: PUSH
43340: EMPTY
43341: LIST
43342: LIST
43343: LIST
43344: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
43345: LD_ADDR_VAR 0 42
43349: PUSH
43350: LD_INT 2
43352: PUSH
43353: LD_INT 0
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 2
43362: PUSH
43363: LD_INT 1
43365: NEG
43366: PUSH
43367: EMPTY
43368: LIST
43369: LIST
43370: PUSH
43371: LD_INT 3
43373: PUSH
43374: LD_INT 1
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: LIST
43385: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
43386: LD_ADDR_VAR 0 43
43390: PUSH
43391: LD_INT 2
43393: PUSH
43394: LD_INT 2
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: PUSH
43401: LD_INT 3
43403: PUSH
43404: LD_INT 2
43406: PUSH
43407: EMPTY
43408: LIST
43409: LIST
43410: PUSH
43411: LD_INT 2
43413: PUSH
43414: LD_INT 3
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: PUSH
43421: EMPTY
43422: LIST
43423: LIST
43424: LIST
43425: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
43426: LD_ADDR_VAR 0 44
43430: PUSH
43431: LD_INT 0
43433: PUSH
43434: LD_INT 2
43436: PUSH
43437: EMPTY
43438: LIST
43439: LIST
43440: PUSH
43441: LD_INT 1
43443: PUSH
43444: LD_INT 3
43446: PUSH
43447: EMPTY
43448: LIST
43449: LIST
43450: PUSH
43451: LD_INT 1
43453: NEG
43454: PUSH
43455: LD_INT 2
43457: PUSH
43458: EMPTY
43459: LIST
43460: LIST
43461: PUSH
43462: EMPTY
43463: LIST
43464: LIST
43465: LIST
43466: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
43467: LD_ADDR_VAR 0 45
43471: PUSH
43472: LD_INT 2
43474: NEG
43475: PUSH
43476: LD_INT 0
43478: PUSH
43479: EMPTY
43480: LIST
43481: LIST
43482: PUSH
43483: LD_INT 2
43485: NEG
43486: PUSH
43487: LD_INT 1
43489: PUSH
43490: EMPTY
43491: LIST
43492: LIST
43493: PUSH
43494: LD_INT 3
43496: NEG
43497: PUSH
43498: LD_INT 1
43500: NEG
43501: PUSH
43502: EMPTY
43503: LIST
43504: LIST
43505: PUSH
43506: EMPTY
43507: LIST
43508: LIST
43509: LIST
43510: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
43511: LD_ADDR_VAR 0 46
43515: PUSH
43516: LD_INT 2
43518: NEG
43519: PUSH
43520: LD_INT 2
43522: NEG
43523: PUSH
43524: EMPTY
43525: LIST
43526: LIST
43527: PUSH
43528: LD_INT 2
43530: NEG
43531: PUSH
43532: LD_INT 3
43534: NEG
43535: PUSH
43536: EMPTY
43537: LIST
43538: LIST
43539: PUSH
43540: LD_INT 3
43542: NEG
43543: PUSH
43544: LD_INT 2
43546: NEG
43547: PUSH
43548: EMPTY
43549: LIST
43550: LIST
43551: PUSH
43552: EMPTY
43553: LIST
43554: LIST
43555: LIST
43556: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
43557: LD_ADDR_VAR 0 47
43561: PUSH
43562: LD_INT 2
43564: NEG
43565: PUSH
43566: LD_INT 3
43568: NEG
43569: PUSH
43570: EMPTY
43571: LIST
43572: LIST
43573: PUSH
43574: LD_INT 1
43576: NEG
43577: PUSH
43578: LD_INT 3
43580: NEG
43581: PUSH
43582: EMPTY
43583: LIST
43584: LIST
43585: PUSH
43586: EMPTY
43587: LIST
43588: LIST
43589: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
43590: LD_ADDR_VAR 0 48
43594: PUSH
43595: LD_INT 1
43597: PUSH
43598: LD_INT 2
43600: NEG
43601: PUSH
43602: EMPTY
43603: LIST
43604: LIST
43605: PUSH
43606: LD_INT 2
43608: PUSH
43609: LD_INT 1
43611: NEG
43612: PUSH
43613: EMPTY
43614: LIST
43615: LIST
43616: PUSH
43617: EMPTY
43618: LIST
43619: LIST
43620: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
43621: LD_ADDR_VAR 0 49
43625: PUSH
43626: LD_INT 3
43628: PUSH
43629: LD_INT 1
43631: PUSH
43632: EMPTY
43633: LIST
43634: LIST
43635: PUSH
43636: LD_INT 3
43638: PUSH
43639: LD_INT 2
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: EMPTY
43647: LIST
43648: LIST
43649: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
43650: LD_ADDR_VAR 0 50
43654: PUSH
43655: LD_INT 2
43657: PUSH
43658: LD_INT 3
43660: PUSH
43661: EMPTY
43662: LIST
43663: LIST
43664: PUSH
43665: LD_INT 1
43667: PUSH
43668: LD_INT 3
43670: PUSH
43671: EMPTY
43672: LIST
43673: LIST
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
43679: LD_ADDR_VAR 0 51
43683: PUSH
43684: LD_INT 1
43686: NEG
43687: PUSH
43688: LD_INT 2
43690: PUSH
43691: EMPTY
43692: LIST
43693: LIST
43694: PUSH
43695: LD_INT 2
43697: NEG
43698: PUSH
43699: LD_INT 1
43701: PUSH
43702: EMPTY
43703: LIST
43704: LIST
43705: PUSH
43706: EMPTY
43707: LIST
43708: LIST
43709: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
43710: LD_ADDR_VAR 0 52
43714: PUSH
43715: LD_INT 3
43717: NEG
43718: PUSH
43719: LD_INT 1
43721: NEG
43722: PUSH
43723: EMPTY
43724: LIST
43725: LIST
43726: PUSH
43727: LD_INT 3
43729: NEG
43730: PUSH
43731: LD_INT 2
43733: NEG
43734: PUSH
43735: EMPTY
43736: LIST
43737: LIST
43738: PUSH
43739: EMPTY
43740: LIST
43741: LIST
43742: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43743: LD_ADDR_VAR 0 53
43747: PUSH
43748: LD_INT 1
43750: NEG
43751: PUSH
43752: LD_INT 3
43754: NEG
43755: PUSH
43756: EMPTY
43757: LIST
43758: LIST
43759: PUSH
43760: LD_INT 0
43762: PUSH
43763: LD_INT 3
43765: NEG
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: LD_INT 1
43773: PUSH
43774: LD_INT 2
43776: NEG
43777: PUSH
43778: EMPTY
43779: LIST
43780: LIST
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: LIST
43786: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43787: LD_ADDR_VAR 0 54
43791: PUSH
43792: LD_INT 2
43794: PUSH
43795: LD_INT 1
43797: NEG
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: LD_INT 3
43805: PUSH
43806: LD_INT 0
43808: PUSH
43809: EMPTY
43810: LIST
43811: LIST
43812: PUSH
43813: LD_INT 3
43815: PUSH
43816: LD_INT 1
43818: PUSH
43819: EMPTY
43820: LIST
43821: LIST
43822: PUSH
43823: EMPTY
43824: LIST
43825: LIST
43826: LIST
43827: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43828: LD_ADDR_VAR 0 55
43832: PUSH
43833: LD_INT 3
43835: PUSH
43836: LD_INT 2
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: PUSH
43843: LD_INT 3
43845: PUSH
43846: LD_INT 3
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PUSH
43853: LD_INT 2
43855: PUSH
43856: LD_INT 3
43858: PUSH
43859: EMPTY
43860: LIST
43861: LIST
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: LIST
43867: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43868: LD_ADDR_VAR 0 56
43872: PUSH
43873: LD_INT 1
43875: PUSH
43876: LD_INT 3
43878: PUSH
43879: EMPTY
43880: LIST
43881: LIST
43882: PUSH
43883: LD_INT 0
43885: PUSH
43886: LD_INT 3
43888: PUSH
43889: EMPTY
43890: LIST
43891: LIST
43892: PUSH
43893: LD_INT 1
43895: NEG
43896: PUSH
43897: LD_INT 2
43899: PUSH
43900: EMPTY
43901: LIST
43902: LIST
43903: PUSH
43904: EMPTY
43905: LIST
43906: LIST
43907: LIST
43908: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43909: LD_ADDR_VAR 0 57
43913: PUSH
43914: LD_INT 2
43916: NEG
43917: PUSH
43918: LD_INT 1
43920: PUSH
43921: EMPTY
43922: LIST
43923: LIST
43924: PUSH
43925: LD_INT 3
43927: NEG
43928: PUSH
43929: LD_INT 0
43931: PUSH
43932: EMPTY
43933: LIST
43934: LIST
43935: PUSH
43936: LD_INT 3
43938: NEG
43939: PUSH
43940: LD_INT 1
43942: NEG
43943: PUSH
43944: EMPTY
43945: LIST
43946: LIST
43947: PUSH
43948: EMPTY
43949: LIST
43950: LIST
43951: LIST
43952: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43953: LD_ADDR_VAR 0 58
43957: PUSH
43958: LD_INT 2
43960: NEG
43961: PUSH
43962: LD_INT 3
43964: NEG
43965: PUSH
43966: EMPTY
43967: LIST
43968: LIST
43969: PUSH
43970: LD_INT 3
43972: NEG
43973: PUSH
43974: LD_INT 2
43976: NEG
43977: PUSH
43978: EMPTY
43979: LIST
43980: LIST
43981: PUSH
43982: LD_INT 3
43984: NEG
43985: PUSH
43986: LD_INT 3
43988: NEG
43989: PUSH
43990: EMPTY
43991: LIST
43992: LIST
43993: PUSH
43994: EMPTY
43995: LIST
43996: LIST
43997: LIST
43998: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43999: LD_ADDR_VAR 0 59
44003: PUSH
44004: LD_INT 1
44006: NEG
44007: PUSH
44008: LD_INT 2
44010: NEG
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: PUSH
44016: LD_INT 0
44018: PUSH
44019: LD_INT 2
44021: NEG
44022: PUSH
44023: EMPTY
44024: LIST
44025: LIST
44026: PUSH
44027: LD_INT 1
44029: PUSH
44030: LD_INT 1
44032: NEG
44033: PUSH
44034: EMPTY
44035: LIST
44036: LIST
44037: PUSH
44038: EMPTY
44039: LIST
44040: LIST
44041: LIST
44042: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
44043: LD_ADDR_VAR 0 60
44047: PUSH
44048: LD_INT 1
44050: PUSH
44051: LD_INT 1
44053: NEG
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: LD_INT 2
44061: PUSH
44062: LD_INT 0
44064: PUSH
44065: EMPTY
44066: LIST
44067: LIST
44068: PUSH
44069: LD_INT 2
44071: PUSH
44072: LD_INT 1
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: PUSH
44079: EMPTY
44080: LIST
44081: LIST
44082: LIST
44083: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
44084: LD_ADDR_VAR 0 61
44088: PUSH
44089: LD_INT 2
44091: PUSH
44092: LD_INT 1
44094: PUSH
44095: EMPTY
44096: LIST
44097: LIST
44098: PUSH
44099: LD_INT 2
44101: PUSH
44102: LD_INT 2
44104: PUSH
44105: EMPTY
44106: LIST
44107: LIST
44108: PUSH
44109: LD_INT 1
44111: PUSH
44112: LD_INT 2
44114: PUSH
44115: EMPTY
44116: LIST
44117: LIST
44118: PUSH
44119: EMPTY
44120: LIST
44121: LIST
44122: LIST
44123: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
44124: LD_ADDR_VAR 0 62
44128: PUSH
44129: LD_INT 1
44131: PUSH
44132: LD_INT 2
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: LD_INT 0
44141: PUSH
44142: LD_INT 2
44144: PUSH
44145: EMPTY
44146: LIST
44147: LIST
44148: PUSH
44149: LD_INT 1
44151: NEG
44152: PUSH
44153: LD_INT 1
44155: PUSH
44156: EMPTY
44157: LIST
44158: LIST
44159: PUSH
44160: EMPTY
44161: LIST
44162: LIST
44163: LIST
44164: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
44165: LD_ADDR_VAR 0 63
44169: PUSH
44170: LD_INT 1
44172: NEG
44173: PUSH
44174: LD_INT 1
44176: PUSH
44177: EMPTY
44178: LIST
44179: LIST
44180: PUSH
44181: LD_INT 2
44183: NEG
44184: PUSH
44185: LD_INT 0
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: PUSH
44192: LD_INT 2
44194: NEG
44195: PUSH
44196: LD_INT 1
44198: NEG
44199: PUSH
44200: EMPTY
44201: LIST
44202: LIST
44203: PUSH
44204: EMPTY
44205: LIST
44206: LIST
44207: LIST
44208: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44209: LD_ADDR_VAR 0 64
44213: PUSH
44214: LD_INT 1
44216: NEG
44217: PUSH
44218: LD_INT 2
44220: NEG
44221: PUSH
44222: EMPTY
44223: LIST
44224: LIST
44225: PUSH
44226: LD_INT 2
44228: NEG
44229: PUSH
44230: LD_INT 1
44232: NEG
44233: PUSH
44234: EMPTY
44235: LIST
44236: LIST
44237: PUSH
44238: LD_INT 2
44240: NEG
44241: PUSH
44242: LD_INT 2
44244: NEG
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: LIST
44254: ST_TO_ADDR
// end ; 2 :
44255: GO 47521
44257: LD_INT 2
44259: DOUBLE
44260: EQUAL
44261: IFTRUE 44265
44263: GO 47520
44265: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
44266: LD_ADDR_VAR 0 29
44270: PUSH
44271: LD_INT 4
44273: PUSH
44274: LD_INT 0
44276: PUSH
44277: EMPTY
44278: LIST
44279: LIST
44280: PUSH
44281: LD_INT 4
44283: PUSH
44284: LD_INT 1
44286: NEG
44287: PUSH
44288: EMPTY
44289: LIST
44290: LIST
44291: PUSH
44292: LD_INT 5
44294: PUSH
44295: LD_INT 0
44297: PUSH
44298: EMPTY
44299: LIST
44300: LIST
44301: PUSH
44302: LD_INT 5
44304: PUSH
44305: LD_INT 1
44307: PUSH
44308: EMPTY
44309: LIST
44310: LIST
44311: PUSH
44312: LD_INT 4
44314: PUSH
44315: LD_INT 1
44317: PUSH
44318: EMPTY
44319: LIST
44320: LIST
44321: PUSH
44322: LD_INT 3
44324: PUSH
44325: LD_INT 0
44327: PUSH
44328: EMPTY
44329: LIST
44330: LIST
44331: PUSH
44332: LD_INT 3
44334: PUSH
44335: LD_INT 1
44337: NEG
44338: PUSH
44339: EMPTY
44340: LIST
44341: LIST
44342: PUSH
44343: LD_INT 3
44345: PUSH
44346: LD_INT 2
44348: NEG
44349: PUSH
44350: EMPTY
44351: LIST
44352: LIST
44353: PUSH
44354: LD_INT 5
44356: PUSH
44357: LD_INT 2
44359: PUSH
44360: EMPTY
44361: LIST
44362: LIST
44363: PUSH
44364: LD_INT 3
44366: PUSH
44367: LD_INT 3
44369: PUSH
44370: EMPTY
44371: LIST
44372: LIST
44373: PUSH
44374: LD_INT 3
44376: PUSH
44377: LD_INT 2
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 4
44386: PUSH
44387: LD_INT 3
44389: PUSH
44390: EMPTY
44391: LIST
44392: LIST
44393: PUSH
44394: LD_INT 4
44396: PUSH
44397: LD_INT 4
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: LD_INT 3
44406: PUSH
44407: LD_INT 4
44409: PUSH
44410: EMPTY
44411: LIST
44412: LIST
44413: PUSH
44414: LD_INT 2
44416: PUSH
44417: LD_INT 3
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: PUSH
44424: LD_INT 2
44426: PUSH
44427: LD_INT 2
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: LD_INT 4
44436: PUSH
44437: LD_INT 2
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: LD_INT 2
44446: PUSH
44447: LD_INT 4
44449: PUSH
44450: EMPTY
44451: LIST
44452: LIST
44453: PUSH
44454: LD_INT 0
44456: PUSH
44457: LD_INT 4
44459: PUSH
44460: EMPTY
44461: LIST
44462: LIST
44463: PUSH
44464: LD_INT 0
44466: PUSH
44467: LD_INT 3
44469: PUSH
44470: EMPTY
44471: LIST
44472: LIST
44473: PUSH
44474: LD_INT 1
44476: PUSH
44477: LD_INT 4
44479: PUSH
44480: EMPTY
44481: LIST
44482: LIST
44483: PUSH
44484: LD_INT 1
44486: PUSH
44487: LD_INT 5
44489: PUSH
44490: EMPTY
44491: LIST
44492: LIST
44493: PUSH
44494: LD_INT 0
44496: PUSH
44497: LD_INT 5
44499: PUSH
44500: EMPTY
44501: LIST
44502: LIST
44503: PUSH
44504: LD_INT 1
44506: NEG
44507: PUSH
44508: LD_INT 4
44510: PUSH
44511: EMPTY
44512: LIST
44513: LIST
44514: PUSH
44515: LD_INT 1
44517: NEG
44518: PUSH
44519: LD_INT 3
44521: PUSH
44522: EMPTY
44523: LIST
44524: LIST
44525: PUSH
44526: LD_INT 2
44528: PUSH
44529: LD_INT 5
44531: PUSH
44532: EMPTY
44533: LIST
44534: LIST
44535: PUSH
44536: LD_INT 2
44538: NEG
44539: PUSH
44540: LD_INT 3
44542: PUSH
44543: EMPTY
44544: LIST
44545: LIST
44546: PUSH
44547: LD_INT 3
44549: NEG
44550: PUSH
44551: LD_INT 0
44553: PUSH
44554: EMPTY
44555: LIST
44556: LIST
44557: PUSH
44558: LD_INT 3
44560: NEG
44561: PUSH
44562: LD_INT 1
44564: NEG
44565: PUSH
44566: EMPTY
44567: LIST
44568: LIST
44569: PUSH
44570: LD_INT 2
44572: NEG
44573: PUSH
44574: LD_INT 0
44576: PUSH
44577: EMPTY
44578: LIST
44579: LIST
44580: PUSH
44581: LD_INT 2
44583: NEG
44584: PUSH
44585: LD_INT 1
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: LD_INT 3
44594: NEG
44595: PUSH
44596: LD_INT 1
44598: PUSH
44599: EMPTY
44600: LIST
44601: LIST
44602: PUSH
44603: LD_INT 4
44605: NEG
44606: PUSH
44607: LD_INT 0
44609: PUSH
44610: EMPTY
44611: LIST
44612: LIST
44613: PUSH
44614: LD_INT 4
44616: NEG
44617: PUSH
44618: LD_INT 1
44620: NEG
44621: PUSH
44622: EMPTY
44623: LIST
44624: LIST
44625: PUSH
44626: LD_INT 4
44628: NEG
44629: PUSH
44630: LD_INT 2
44632: NEG
44633: PUSH
44634: EMPTY
44635: LIST
44636: LIST
44637: PUSH
44638: LD_INT 2
44640: NEG
44641: PUSH
44642: LD_INT 2
44644: PUSH
44645: EMPTY
44646: LIST
44647: LIST
44648: PUSH
44649: LD_INT 4
44651: NEG
44652: PUSH
44653: LD_INT 4
44655: NEG
44656: PUSH
44657: EMPTY
44658: LIST
44659: LIST
44660: PUSH
44661: LD_INT 4
44663: NEG
44664: PUSH
44665: LD_INT 5
44667: NEG
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 3
44675: NEG
44676: PUSH
44677: LD_INT 4
44679: NEG
44680: PUSH
44681: EMPTY
44682: LIST
44683: LIST
44684: PUSH
44685: LD_INT 3
44687: NEG
44688: PUSH
44689: LD_INT 3
44691: NEG
44692: PUSH
44693: EMPTY
44694: LIST
44695: LIST
44696: PUSH
44697: LD_INT 4
44699: NEG
44700: PUSH
44701: LD_INT 3
44703: NEG
44704: PUSH
44705: EMPTY
44706: LIST
44707: LIST
44708: PUSH
44709: LD_INT 5
44711: NEG
44712: PUSH
44713: LD_INT 4
44715: NEG
44716: PUSH
44717: EMPTY
44718: LIST
44719: LIST
44720: PUSH
44721: LD_INT 5
44723: NEG
44724: PUSH
44725: LD_INT 5
44727: NEG
44728: PUSH
44729: EMPTY
44730: LIST
44731: LIST
44732: PUSH
44733: LD_INT 3
44735: NEG
44736: PUSH
44737: LD_INT 5
44739: NEG
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PUSH
44745: LD_INT 5
44747: NEG
44748: PUSH
44749: LD_INT 3
44751: NEG
44752: PUSH
44753: EMPTY
44754: LIST
44755: LIST
44756: PUSH
44757: EMPTY
44758: LIST
44759: LIST
44760: LIST
44761: LIST
44762: LIST
44763: LIST
44764: LIST
44765: LIST
44766: LIST
44767: LIST
44768: LIST
44769: LIST
44770: LIST
44771: LIST
44772: LIST
44773: LIST
44774: LIST
44775: LIST
44776: LIST
44777: LIST
44778: LIST
44779: LIST
44780: LIST
44781: LIST
44782: LIST
44783: LIST
44784: LIST
44785: LIST
44786: LIST
44787: LIST
44788: LIST
44789: LIST
44790: LIST
44791: LIST
44792: LIST
44793: LIST
44794: LIST
44795: LIST
44796: LIST
44797: LIST
44798: LIST
44799: LIST
44800: LIST
44801: LIST
44802: LIST
44803: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44804: LD_ADDR_VAR 0 30
44808: PUSH
44809: LD_INT 4
44811: PUSH
44812: LD_INT 4
44814: PUSH
44815: EMPTY
44816: LIST
44817: LIST
44818: PUSH
44819: LD_INT 4
44821: PUSH
44822: LD_INT 3
44824: PUSH
44825: EMPTY
44826: LIST
44827: LIST
44828: PUSH
44829: LD_INT 5
44831: PUSH
44832: LD_INT 4
44834: PUSH
44835: EMPTY
44836: LIST
44837: LIST
44838: PUSH
44839: LD_INT 5
44841: PUSH
44842: LD_INT 5
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 4
44851: PUSH
44852: LD_INT 5
44854: PUSH
44855: EMPTY
44856: LIST
44857: LIST
44858: PUSH
44859: LD_INT 3
44861: PUSH
44862: LD_INT 4
44864: PUSH
44865: EMPTY
44866: LIST
44867: LIST
44868: PUSH
44869: LD_INT 3
44871: PUSH
44872: LD_INT 3
44874: PUSH
44875: EMPTY
44876: LIST
44877: LIST
44878: PUSH
44879: LD_INT 5
44881: PUSH
44882: LD_INT 3
44884: PUSH
44885: EMPTY
44886: LIST
44887: LIST
44888: PUSH
44889: LD_INT 3
44891: PUSH
44892: LD_INT 5
44894: PUSH
44895: EMPTY
44896: LIST
44897: LIST
44898: PUSH
44899: LD_INT 0
44901: PUSH
44902: LD_INT 3
44904: PUSH
44905: EMPTY
44906: LIST
44907: LIST
44908: PUSH
44909: LD_INT 0
44911: PUSH
44912: LD_INT 2
44914: PUSH
44915: EMPTY
44916: LIST
44917: LIST
44918: PUSH
44919: LD_INT 1
44921: PUSH
44922: LD_INT 3
44924: PUSH
44925: EMPTY
44926: LIST
44927: LIST
44928: PUSH
44929: LD_INT 1
44931: PUSH
44932: LD_INT 4
44934: PUSH
44935: EMPTY
44936: LIST
44937: LIST
44938: PUSH
44939: LD_INT 0
44941: PUSH
44942: LD_INT 4
44944: PUSH
44945: EMPTY
44946: LIST
44947: LIST
44948: PUSH
44949: LD_INT 1
44951: NEG
44952: PUSH
44953: LD_INT 3
44955: PUSH
44956: EMPTY
44957: LIST
44958: LIST
44959: PUSH
44960: LD_INT 1
44962: NEG
44963: PUSH
44964: LD_INT 2
44966: PUSH
44967: EMPTY
44968: LIST
44969: LIST
44970: PUSH
44971: LD_INT 2
44973: PUSH
44974: LD_INT 4
44976: PUSH
44977: EMPTY
44978: LIST
44979: LIST
44980: PUSH
44981: LD_INT 2
44983: NEG
44984: PUSH
44985: LD_INT 2
44987: PUSH
44988: EMPTY
44989: LIST
44990: LIST
44991: PUSH
44992: LD_INT 4
44994: NEG
44995: PUSH
44996: LD_INT 0
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: LD_INT 4
45005: NEG
45006: PUSH
45007: LD_INT 1
45009: NEG
45010: PUSH
45011: EMPTY
45012: LIST
45013: LIST
45014: PUSH
45015: LD_INT 3
45017: NEG
45018: PUSH
45019: LD_INT 0
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: LD_INT 3
45028: NEG
45029: PUSH
45030: LD_INT 1
45032: PUSH
45033: EMPTY
45034: LIST
45035: LIST
45036: PUSH
45037: LD_INT 4
45039: NEG
45040: PUSH
45041: LD_INT 1
45043: PUSH
45044: EMPTY
45045: LIST
45046: LIST
45047: PUSH
45048: LD_INT 5
45050: NEG
45051: PUSH
45052: LD_INT 0
45054: PUSH
45055: EMPTY
45056: LIST
45057: LIST
45058: PUSH
45059: LD_INT 5
45061: NEG
45062: PUSH
45063: LD_INT 1
45065: NEG
45066: PUSH
45067: EMPTY
45068: LIST
45069: LIST
45070: PUSH
45071: LD_INT 5
45073: NEG
45074: PUSH
45075: LD_INT 2
45077: NEG
45078: PUSH
45079: EMPTY
45080: LIST
45081: LIST
45082: PUSH
45083: LD_INT 3
45085: NEG
45086: PUSH
45087: LD_INT 2
45089: PUSH
45090: EMPTY
45091: LIST
45092: LIST
45093: PUSH
45094: LD_INT 3
45096: NEG
45097: PUSH
45098: LD_INT 3
45100: NEG
45101: PUSH
45102: EMPTY
45103: LIST
45104: LIST
45105: PUSH
45106: LD_INT 3
45108: NEG
45109: PUSH
45110: LD_INT 4
45112: NEG
45113: PUSH
45114: EMPTY
45115: LIST
45116: LIST
45117: PUSH
45118: LD_INT 2
45120: NEG
45121: PUSH
45122: LD_INT 3
45124: NEG
45125: PUSH
45126: EMPTY
45127: LIST
45128: LIST
45129: PUSH
45130: LD_INT 2
45132: NEG
45133: PUSH
45134: LD_INT 2
45136: NEG
45137: PUSH
45138: EMPTY
45139: LIST
45140: LIST
45141: PUSH
45142: LD_INT 3
45144: NEG
45145: PUSH
45146: LD_INT 2
45148: NEG
45149: PUSH
45150: EMPTY
45151: LIST
45152: LIST
45153: PUSH
45154: LD_INT 4
45156: NEG
45157: PUSH
45158: LD_INT 3
45160: NEG
45161: PUSH
45162: EMPTY
45163: LIST
45164: LIST
45165: PUSH
45166: LD_INT 4
45168: NEG
45169: PUSH
45170: LD_INT 4
45172: NEG
45173: PUSH
45174: EMPTY
45175: LIST
45176: LIST
45177: PUSH
45178: LD_INT 2
45180: NEG
45181: PUSH
45182: LD_INT 4
45184: NEG
45185: PUSH
45186: EMPTY
45187: LIST
45188: LIST
45189: PUSH
45190: LD_INT 4
45192: NEG
45193: PUSH
45194: LD_INT 2
45196: NEG
45197: PUSH
45198: EMPTY
45199: LIST
45200: LIST
45201: PUSH
45202: LD_INT 0
45204: PUSH
45205: LD_INT 4
45207: NEG
45208: PUSH
45209: EMPTY
45210: LIST
45211: LIST
45212: PUSH
45213: LD_INT 0
45215: PUSH
45216: LD_INT 5
45218: NEG
45219: PUSH
45220: EMPTY
45221: LIST
45222: LIST
45223: PUSH
45224: LD_INT 1
45226: PUSH
45227: LD_INT 4
45229: NEG
45230: PUSH
45231: EMPTY
45232: LIST
45233: LIST
45234: PUSH
45235: LD_INT 1
45237: PUSH
45238: LD_INT 3
45240: NEG
45241: PUSH
45242: EMPTY
45243: LIST
45244: LIST
45245: PUSH
45246: LD_INT 0
45248: PUSH
45249: LD_INT 3
45251: NEG
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: LD_INT 1
45259: NEG
45260: PUSH
45261: LD_INT 4
45263: NEG
45264: PUSH
45265: EMPTY
45266: LIST
45267: LIST
45268: PUSH
45269: LD_INT 1
45271: NEG
45272: PUSH
45273: LD_INT 5
45275: NEG
45276: PUSH
45277: EMPTY
45278: LIST
45279: LIST
45280: PUSH
45281: LD_INT 2
45283: PUSH
45284: LD_INT 3
45286: NEG
45287: PUSH
45288: EMPTY
45289: LIST
45290: LIST
45291: PUSH
45292: LD_INT 2
45294: NEG
45295: PUSH
45296: LD_INT 5
45298: NEG
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: PUSH
45304: EMPTY
45305: LIST
45306: LIST
45307: LIST
45308: LIST
45309: LIST
45310: LIST
45311: LIST
45312: LIST
45313: LIST
45314: LIST
45315: LIST
45316: LIST
45317: LIST
45318: LIST
45319: LIST
45320: LIST
45321: LIST
45322: LIST
45323: LIST
45324: LIST
45325: LIST
45326: LIST
45327: LIST
45328: LIST
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: LIST
45336: LIST
45337: LIST
45338: LIST
45339: LIST
45340: LIST
45341: LIST
45342: LIST
45343: LIST
45344: LIST
45345: LIST
45346: LIST
45347: LIST
45348: LIST
45349: LIST
45350: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
45351: LD_ADDR_VAR 0 31
45355: PUSH
45356: LD_INT 0
45358: PUSH
45359: LD_INT 4
45361: PUSH
45362: EMPTY
45363: LIST
45364: LIST
45365: PUSH
45366: LD_INT 0
45368: PUSH
45369: LD_INT 3
45371: PUSH
45372: EMPTY
45373: LIST
45374: LIST
45375: PUSH
45376: LD_INT 1
45378: PUSH
45379: LD_INT 4
45381: PUSH
45382: EMPTY
45383: LIST
45384: LIST
45385: PUSH
45386: LD_INT 1
45388: PUSH
45389: LD_INT 5
45391: PUSH
45392: EMPTY
45393: LIST
45394: LIST
45395: PUSH
45396: LD_INT 0
45398: PUSH
45399: LD_INT 5
45401: PUSH
45402: EMPTY
45403: LIST
45404: LIST
45405: PUSH
45406: LD_INT 1
45408: NEG
45409: PUSH
45410: LD_INT 4
45412: PUSH
45413: EMPTY
45414: LIST
45415: LIST
45416: PUSH
45417: LD_INT 1
45419: NEG
45420: PUSH
45421: LD_INT 3
45423: PUSH
45424: EMPTY
45425: LIST
45426: LIST
45427: PUSH
45428: LD_INT 2
45430: PUSH
45431: LD_INT 5
45433: PUSH
45434: EMPTY
45435: LIST
45436: LIST
45437: PUSH
45438: LD_INT 2
45440: NEG
45441: PUSH
45442: LD_INT 3
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PUSH
45449: LD_INT 3
45451: NEG
45452: PUSH
45453: LD_INT 0
45455: PUSH
45456: EMPTY
45457: LIST
45458: LIST
45459: PUSH
45460: LD_INT 3
45462: NEG
45463: PUSH
45464: LD_INT 1
45466: NEG
45467: PUSH
45468: EMPTY
45469: LIST
45470: LIST
45471: PUSH
45472: LD_INT 2
45474: NEG
45475: PUSH
45476: LD_INT 0
45478: PUSH
45479: EMPTY
45480: LIST
45481: LIST
45482: PUSH
45483: LD_INT 2
45485: NEG
45486: PUSH
45487: LD_INT 1
45489: PUSH
45490: EMPTY
45491: LIST
45492: LIST
45493: PUSH
45494: LD_INT 3
45496: NEG
45497: PUSH
45498: LD_INT 1
45500: PUSH
45501: EMPTY
45502: LIST
45503: LIST
45504: PUSH
45505: LD_INT 4
45507: NEG
45508: PUSH
45509: LD_INT 0
45511: PUSH
45512: EMPTY
45513: LIST
45514: LIST
45515: PUSH
45516: LD_INT 4
45518: NEG
45519: PUSH
45520: LD_INT 1
45522: NEG
45523: PUSH
45524: EMPTY
45525: LIST
45526: LIST
45527: PUSH
45528: LD_INT 4
45530: NEG
45531: PUSH
45532: LD_INT 2
45534: NEG
45535: PUSH
45536: EMPTY
45537: LIST
45538: LIST
45539: PUSH
45540: LD_INT 2
45542: NEG
45543: PUSH
45544: LD_INT 2
45546: PUSH
45547: EMPTY
45548: LIST
45549: LIST
45550: PUSH
45551: LD_INT 4
45553: NEG
45554: PUSH
45555: LD_INT 4
45557: NEG
45558: PUSH
45559: EMPTY
45560: LIST
45561: LIST
45562: PUSH
45563: LD_INT 4
45565: NEG
45566: PUSH
45567: LD_INT 5
45569: NEG
45570: PUSH
45571: EMPTY
45572: LIST
45573: LIST
45574: PUSH
45575: LD_INT 3
45577: NEG
45578: PUSH
45579: LD_INT 4
45581: NEG
45582: PUSH
45583: EMPTY
45584: LIST
45585: LIST
45586: PUSH
45587: LD_INT 3
45589: NEG
45590: PUSH
45591: LD_INT 3
45593: NEG
45594: PUSH
45595: EMPTY
45596: LIST
45597: LIST
45598: PUSH
45599: LD_INT 4
45601: NEG
45602: PUSH
45603: LD_INT 3
45605: NEG
45606: PUSH
45607: EMPTY
45608: LIST
45609: LIST
45610: PUSH
45611: LD_INT 5
45613: NEG
45614: PUSH
45615: LD_INT 4
45617: NEG
45618: PUSH
45619: EMPTY
45620: LIST
45621: LIST
45622: PUSH
45623: LD_INT 5
45625: NEG
45626: PUSH
45627: LD_INT 5
45629: NEG
45630: PUSH
45631: EMPTY
45632: LIST
45633: LIST
45634: PUSH
45635: LD_INT 3
45637: NEG
45638: PUSH
45639: LD_INT 5
45641: NEG
45642: PUSH
45643: EMPTY
45644: LIST
45645: LIST
45646: PUSH
45647: LD_INT 5
45649: NEG
45650: PUSH
45651: LD_INT 3
45653: NEG
45654: PUSH
45655: EMPTY
45656: LIST
45657: LIST
45658: PUSH
45659: LD_INT 0
45661: PUSH
45662: LD_INT 3
45664: NEG
45665: PUSH
45666: EMPTY
45667: LIST
45668: LIST
45669: PUSH
45670: LD_INT 0
45672: PUSH
45673: LD_INT 4
45675: NEG
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: LD_INT 1
45683: PUSH
45684: LD_INT 3
45686: NEG
45687: PUSH
45688: EMPTY
45689: LIST
45690: LIST
45691: PUSH
45692: LD_INT 1
45694: PUSH
45695: LD_INT 2
45697: NEG
45698: PUSH
45699: EMPTY
45700: LIST
45701: LIST
45702: PUSH
45703: LD_INT 0
45705: PUSH
45706: LD_INT 2
45708: NEG
45709: PUSH
45710: EMPTY
45711: LIST
45712: LIST
45713: PUSH
45714: LD_INT 1
45716: NEG
45717: PUSH
45718: LD_INT 3
45720: NEG
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 1
45728: NEG
45729: PUSH
45730: LD_INT 4
45732: NEG
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: PUSH
45738: LD_INT 2
45740: PUSH
45741: LD_INT 2
45743: NEG
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: LD_INT 2
45751: NEG
45752: PUSH
45753: LD_INT 4
45755: NEG
45756: PUSH
45757: EMPTY
45758: LIST
45759: LIST
45760: PUSH
45761: LD_INT 4
45763: PUSH
45764: LD_INT 0
45766: PUSH
45767: EMPTY
45768: LIST
45769: LIST
45770: PUSH
45771: LD_INT 4
45773: PUSH
45774: LD_INT 1
45776: NEG
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: PUSH
45782: LD_INT 5
45784: PUSH
45785: LD_INT 0
45787: PUSH
45788: EMPTY
45789: LIST
45790: LIST
45791: PUSH
45792: LD_INT 5
45794: PUSH
45795: LD_INT 1
45797: PUSH
45798: EMPTY
45799: LIST
45800: LIST
45801: PUSH
45802: LD_INT 4
45804: PUSH
45805: LD_INT 1
45807: PUSH
45808: EMPTY
45809: LIST
45810: LIST
45811: PUSH
45812: LD_INT 3
45814: PUSH
45815: LD_INT 0
45817: PUSH
45818: EMPTY
45819: LIST
45820: LIST
45821: PUSH
45822: LD_INT 3
45824: PUSH
45825: LD_INT 1
45827: NEG
45828: PUSH
45829: EMPTY
45830: LIST
45831: LIST
45832: PUSH
45833: LD_INT 3
45835: PUSH
45836: LD_INT 2
45838: NEG
45839: PUSH
45840: EMPTY
45841: LIST
45842: LIST
45843: PUSH
45844: LD_INT 5
45846: PUSH
45847: LD_INT 2
45849: PUSH
45850: EMPTY
45851: LIST
45852: LIST
45853: PUSH
45854: EMPTY
45855: LIST
45856: LIST
45857: LIST
45858: LIST
45859: LIST
45860: LIST
45861: LIST
45862: LIST
45863: LIST
45864: LIST
45865: LIST
45866: LIST
45867: LIST
45868: LIST
45869: LIST
45870: LIST
45871: LIST
45872: LIST
45873: LIST
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: LIST
45882: LIST
45883: LIST
45884: LIST
45885: LIST
45886: LIST
45887: LIST
45888: LIST
45889: LIST
45890: LIST
45891: LIST
45892: LIST
45893: LIST
45894: LIST
45895: LIST
45896: LIST
45897: LIST
45898: LIST
45899: LIST
45900: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45901: LD_ADDR_VAR 0 32
45905: PUSH
45906: LD_INT 4
45908: NEG
45909: PUSH
45910: LD_INT 0
45912: PUSH
45913: EMPTY
45914: LIST
45915: LIST
45916: PUSH
45917: LD_INT 4
45919: NEG
45920: PUSH
45921: LD_INT 1
45923: NEG
45924: PUSH
45925: EMPTY
45926: LIST
45927: LIST
45928: PUSH
45929: LD_INT 3
45931: NEG
45932: PUSH
45933: LD_INT 0
45935: PUSH
45936: EMPTY
45937: LIST
45938: LIST
45939: PUSH
45940: LD_INT 3
45942: NEG
45943: PUSH
45944: LD_INT 1
45946: PUSH
45947: EMPTY
45948: LIST
45949: LIST
45950: PUSH
45951: LD_INT 4
45953: NEG
45954: PUSH
45955: LD_INT 1
45957: PUSH
45958: EMPTY
45959: LIST
45960: LIST
45961: PUSH
45962: LD_INT 5
45964: NEG
45965: PUSH
45966: LD_INT 0
45968: PUSH
45969: EMPTY
45970: LIST
45971: LIST
45972: PUSH
45973: LD_INT 5
45975: NEG
45976: PUSH
45977: LD_INT 1
45979: NEG
45980: PUSH
45981: EMPTY
45982: LIST
45983: LIST
45984: PUSH
45985: LD_INT 5
45987: NEG
45988: PUSH
45989: LD_INT 2
45991: NEG
45992: PUSH
45993: EMPTY
45994: LIST
45995: LIST
45996: PUSH
45997: LD_INT 3
45999: NEG
46000: PUSH
46001: LD_INT 2
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: PUSH
46008: LD_INT 3
46010: NEG
46011: PUSH
46012: LD_INT 3
46014: NEG
46015: PUSH
46016: EMPTY
46017: LIST
46018: LIST
46019: PUSH
46020: LD_INT 3
46022: NEG
46023: PUSH
46024: LD_INT 4
46026: NEG
46027: PUSH
46028: EMPTY
46029: LIST
46030: LIST
46031: PUSH
46032: LD_INT 2
46034: NEG
46035: PUSH
46036: LD_INT 3
46038: NEG
46039: PUSH
46040: EMPTY
46041: LIST
46042: LIST
46043: PUSH
46044: LD_INT 2
46046: NEG
46047: PUSH
46048: LD_INT 2
46050: NEG
46051: PUSH
46052: EMPTY
46053: LIST
46054: LIST
46055: PUSH
46056: LD_INT 3
46058: NEG
46059: PUSH
46060: LD_INT 2
46062: NEG
46063: PUSH
46064: EMPTY
46065: LIST
46066: LIST
46067: PUSH
46068: LD_INT 4
46070: NEG
46071: PUSH
46072: LD_INT 3
46074: NEG
46075: PUSH
46076: EMPTY
46077: LIST
46078: LIST
46079: PUSH
46080: LD_INT 4
46082: NEG
46083: PUSH
46084: LD_INT 4
46086: NEG
46087: PUSH
46088: EMPTY
46089: LIST
46090: LIST
46091: PUSH
46092: LD_INT 2
46094: NEG
46095: PUSH
46096: LD_INT 4
46098: NEG
46099: PUSH
46100: EMPTY
46101: LIST
46102: LIST
46103: PUSH
46104: LD_INT 4
46106: NEG
46107: PUSH
46108: LD_INT 2
46110: NEG
46111: PUSH
46112: EMPTY
46113: LIST
46114: LIST
46115: PUSH
46116: LD_INT 0
46118: PUSH
46119: LD_INT 4
46121: NEG
46122: PUSH
46123: EMPTY
46124: LIST
46125: LIST
46126: PUSH
46127: LD_INT 0
46129: PUSH
46130: LD_INT 5
46132: NEG
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: PUSH
46138: LD_INT 1
46140: PUSH
46141: LD_INT 4
46143: NEG
46144: PUSH
46145: EMPTY
46146: LIST
46147: LIST
46148: PUSH
46149: LD_INT 1
46151: PUSH
46152: LD_INT 3
46154: NEG
46155: PUSH
46156: EMPTY
46157: LIST
46158: LIST
46159: PUSH
46160: LD_INT 0
46162: PUSH
46163: LD_INT 3
46165: NEG
46166: PUSH
46167: EMPTY
46168: LIST
46169: LIST
46170: PUSH
46171: LD_INT 1
46173: NEG
46174: PUSH
46175: LD_INT 4
46177: NEG
46178: PUSH
46179: EMPTY
46180: LIST
46181: LIST
46182: PUSH
46183: LD_INT 1
46185: NEG
46186: PUSH
46187: LD_INT 5
46189: NEG
46190: PUSH
46191: EMPTY
46192: LIST
46193: LIST
46194: PUSH
46195: LD_INT 2
46197: PUSH
46198: LD_INT 3
46200: NEG
46201: PUSH
46202: EMPTY
46203: LIST
46204: LIST
46205: PUSH
46206: LD_INT 2
46208: NEG
46209: PUSH
46210: LD_INT 5
46212: NEG
46213: PUSH
46214: EMPTY
46215: LIST
46216: LIST
46217: PUSH
46218: LD_INT 3
46220: PUSH
46221: LD_INT 0
46223: PUSH
46224: EMPTY
46225: LIST
46226: LIST
46227: PUSH
46228: LD_INT 3
46230: PUSH
46231: LD_INT 1
46233: NEG
46234: PUSH
46235: EMPTY
46236: LIST
46237: LIST
46238: PUSH
46239: LD_INT 4
46241: PUSH
46242: LD_INT 0
46244: PUSH
46245: EMPTY
46246: LIST
46247: LIST
46248: PUSH
46249: LD_INT 4
46251: PUSH
46252: LD_INT 1
46254: PUSH
46255: EMPTY
46256: LIST
46257: LIST
46258: PUSH
46259: LD_INT 3
46261: PUSH
46262: LD_INT 1
46264: PUSH
46265: EMPTY
46266: LIST
46267: LIST
46268: PUSH
46269: LD_INT 2
46271: PUSH
46272: LD_INT 0
46274: PUSH
46275: EMPTY
46276: LIST
46277: LIST
46278: PUSH
46279: LD_INT 2
46281: PUSH
46282: LD_INT 1
46284: NEG
46285: PUSH
46286: EMPTY
46287: LIST
46288: LIST
46289: PUSH
46290: LD_INT 2
46292: PUSH
46293: LD_INT 2
46295: NEG
46296: PUSH
46297: EMPTY
46298: LIST
46299: LIST
46300: PUSH
46301: LD_INT 4
46303: PUSH
46304: LD_INT 2
46306: PUSH
46307: EMPTY
46308: LIST
46309: LIST
46310: PUSH
46311: LD_INT 4
46313: PUSH
46314: LD_INT 4
46316: PUSH
46317: EMPTY
46318: LIST
46319: LIST
46320: PUSH
46321: LD_INT 4
46323: PUSH
46324: LD_INT 3
46326: PUSH
46327: EMPTY
46328: LIST
46329: LIST
46330: PUSH
46331: LD_INT 5
46333: PUSH
46334: LD_INT 4
46336: PUSH
46337: EMPTY
46338: LIST
46339: LIST
46340: PUSH
46341: LD_INT 5
46343: PUSH
46344: LD_INT 5
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 4
46353: PUSH
46354: LD_INT 5
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: LD_INT 3
46363: PUSH
46364: LD_INT 4
46366: PUSH
46367: EMPTY
46368: LIST
46369: LIST
46370: PUSH
46371: LD_INT 3
46373: PUSH
46374: LD_INT 3
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PUSH
46381: LD_INT 5
46383: PUSH
46384: LD_INT 3
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PUSH
46391: LD_INT 3
46393: PUSH
46394: LD_INT 5
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: EMPTY
46402: LIST
46403: LIST
46404: LIST
46405: LIST
46406: LIST
46407: LIST
46408: LIST
46409: LIST
46410: LIST
46411: LIST
46412: LIST
46413: LIST
46414: LIST
46415: LIST
46416: LIST
46417: LIST
46418: LIST
46419: LIST
46420: LIST
46421: LIST
46422: LIST
46423: LIST
46424: LIST
46425: LIST
46426: LIST
46427: LIST
46428: LIST
46429: LIST
46430: LIST
46431: LIST
46432: LIST
46433: LIST
46434: LIST
46435: LIST
46436: LIST
46437: LIST
46438: LIST
46439: LIST
46440: LIST
46441: LIST
46442: LIST
46443: LIST
46444: LIST
46445: LIST
46446: LIST
46447: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
46448: LD_ADDR_VAR 0 33
46452: PUSH
46453: LD_INT 4
46455: NEG
46456: PUSH
46457: LD_INT 4
46459: NEG
46460: PUSH
46461: EMPTY
46462: LIST
46463: LIST
46464: PUSH
46465: LD_INT 4
46467: NEG
46468: PUSH
46469: LD_INT 5
46471: NEG
46472: PUSH
46473: EMPTY
46474: LIST
46475: LIST
46476: PUSH
46477: LD_INT 3
46479: NEG
46480: PUSH
46481: LD_INT 4
46483: NEG
46484: PUSH
46485: EMPTY
46486: LIST
46487: LIST
46488: PUSH
46489: LD_INT 3
46491: NEG
46492: PUSH
46493: LD_INT 3
46495: NEG
46496: PUSH
46497: EMPTY
46498: LIST
46499: LIST
46500: PUSH
46501: LD_INT 4
46503: NEG
46504: PUSH
46505: LD_INT 3
46507: NEG
46508: PUSH
46509: EMPTY
46510: LIST
46511: LIST
46512: PUSH
46513: LD_INT 5
46515: NEG
46516: PUSH
46517: LD_INT 4
46519: NEG
46520: PUSH
46521: EMPTY
46522: LIST
46523: LIST
46524: PUSH
46525: LD_INT 5
46527: NEG
46528: PUSH
46529: LD_INT 5
46531: NEG
46532: PUSH
46533: EMPTY
46534: LIST
46535: LIST
46536: PUSH
46537: LD_INT 3
46539: NEG
46540: PUSH
46541: LD_INT 5
46543: NEG
46544: PUSH
46545: EMPTY
46546: LIST
46547: LIST
46548: PUSH
46549: LD_INT 5
46551: NEG
46552: PUSH
46553: LD_INT 3
46555: NEG
46556: PUSH
46557: EMPTY
46558: LIST
46559: LIST
46560: PUSH
46561: LD_INT 0
46563: PUSH
46564: LD_INT 3
46566: NEG
46567: PUSH
46568: EMPTY
46569: LIST
46570: LIST
46571: PUSH
46572: LD_INT 0
46574: PUSH
46575: LD_INT 4
46577: NEG
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: PUSH
46583: LD_INT 1
46585: PUSH
46586: LD_INT 3
46588: NEG
46589: PUSH
46590: EMPTY
46591: LIST
46592: LIST
46593: PUSH
46594: LD_INT 1
46596: PUSH
46597: LD_INT 2
46599: NEG
46600: PUSH
46601: EMPTY
46602: LIST
46603: LIST
46604: PUSH
46605: LD_INT 0
46607: PUSH
46608: LD_INT 2
46610: NEG
46611: PUSH
46612: EMPTY
46613: LIST
46614: LIST
46615: PUSH
46616: LD_INT 1
46618: NEG
46619: PUSH
46620: LD_INT 3
46622: NEG
46623: PUSH
46624: EMPTY
46625: LIST
46626: LIST
46627: PUSH
46628: LD_INT 1
46630: NEG
46631: PUSH
46632: LD_INT 4
46634: NEG
46635: PUSH
46636: EMPTY
46637: LIST
46638: LIST
46639: PUSH
46640: LD_INT 2
46642: PUSH
46643: LD_INT 2
46645: NEG
46646: PUSH
46647: EMPTY
46648: LIST
46649: LIST
46650: PUSH
46651: LD_INT 2
46653: NEG
46654: PUSH
46655: LD_INT 4
46657: NEG
46658: PUSH
46659: EMPTY
46660: LIST
46661: LIST
46662: PUSH
46663: LD_INT 4
46665: PUSH
46666: LD_INT 0
46668: PUSH
46669: EMPTY
46670: LIST
46671: LIST
46672: PUSH
46673: LD_INT 4
46675: PUSH
46676: LD_INT 1
46678: NEG
46679: PUSH
46680: EMPTY
46681: LIST
46682: LIST
46683: PUSH
46684: LD_INT 5
46686: PUSH
46687: LD_INT 0
46689: PUSH
46690: EMPTY
46691: LIST
46692: LIST
46693: PUSH
46694: LD_INT 5
46696: PUSH
46697: LD_INT 1
46699: PUSH
46700: EMPTY
46701: LIST
46702: LIST
46703: PUSH
46704: LD_INT 4
46706: PUSH
46707: LD_INT 1
46709: PUSH
46710: EMPTY
46711: LIST
46712: LIST
46713: PUSH
46714: LD_INT 3
46716: PUSH
46717: LD_INT 0
46719: PUSH
46720: EMPTY
46721: LIST
46722: LIST
46723: PUSH
46724: LD_INT 3
46726: PUSH
46727: LD_INT 1
46729: NEG
46730: PUSH
46731: EMPTY
46732: LIST
46733: LIST
46734: PUSH
46735: LD_INT 3
46737: PUSH
46738: LD_INT 2
46740: NEG
46741: PUSH
46742: EMPTY
46743: LIST
46744: LIST
46745: PUSH
46746: LD_INT 5
46748: PUSH
46749: LD_INT 2
46751: PUSH
46752: EMPTY
46753: LIST
46754: LIST
46755: PUSH
46756: LD_INT 3
46758: PUSH
46759: LD_INT 3
46761: PUSH
46762: EMPTY
46763: LIST
46764: LIST
46765: PUSH
46766: LD_INT 3
46768: PUSH
46769: LD_INT 2
46771: PUSH
46772: EMPTY
46773: LIST
46774: LIST
46775: PUSH
46776: LD_INT 4
46778: PUSH
46779: LD_INT 3
46781: PUSH
46782: EMPTY
46783: LIST
46784: LIST
46785: PUSH
46786: LD_INT 4
46788: PUSH
46789: LD_INT 4
46791: PUSH
46792: EMPTY
46793: LIST
46794: LIST
46795: PUSH
46796: LD_INT 3
46798: PUSH
46799: LD_INT 4
46801: PUSH
46802: EMPTY
46803: LIST
46804: LIST
46805: PUSH
46806: LD_INT 2
46808: PUSH
46809: LD_INT 3
46811: PUSH
46812: EMPTY
46813: LIST
46814: LIST
46815: PUSH
46816: LD_INT 2
46818: PUSH
46819: LD_INT 2
46821: PUSH
46822: EMPTY
46823: LIST
46824: LIST
46825: PUSH
46826: LD_INT 4
46828: PUSH
46829: LD_INT 2
46831: PUSH
46832: EMPTY
46833: LIST
46834: LIST
46835: PUSH
46836: LD_INT 2
46838: PUSH
46839: LD_INT 4
46841: PUSH
46842: EMPTY
46843: LIST
46844: LIST
46845: PUSH
46846: LD_INT 0
46848: PUSH
46849: LD_INT 4
46851: PUSH
46852: EMPTY
46853: LIST
46854: LIST
46855: PUSH
46856: LD_INT 0
46858: PUSH
46859: LD_INT 3
46861: PUSH
46862: EMPTY
46863: LIST
46864: LIST
46865: PUSH
46866: LD_INT 1
46868: PUSH
46869: LD_INT 4
46871: PUSH
46872: EMPTY
46873: LIST
46874: LIST
46875: PUSH
46876: LD_INT 1
46878: PUSH
46879: LD_INT 5
46881: PUSH
46882: EMPTY
46883: LIST
46884: LIST
46885: PUSH
46886: LD_INT 0
46888: PUSH
46889: LD_INT 5
46891: PUSH
46892: EMPTY
46893: LIST
46894: LIST
46895: PUSH
46896: LD_INT 1
46898: NEG
46899: PUSH
46900: LD_INT 4
46902: PUSH
46903: EMPTY
46904: LIST
46905: LIST
46906: PUSH
46907: LD_INT 1
46909: NEG
46910: PUSH
46911: LD_INT 3
46913: PUSH
46914: EMPTY
46915: LIST
46916: LIST
46917: PUSH
46918: LD_INT 2
46920: PUSH
46921: LD_INT 5
46923: PUSH
46924: EMPTY
46925: LIST
46926: LIST
46927: PUSH
46928: LD_INT 2
46930: NEG
46931: PUSH
46932: LD_INT 3
46934: PUSH
46935: EMPTY
46936: LIST
46937: LIST
46938: PUSH
46939: EMPTY
46940: LIST
46941: LIST
46942: LIST
46943: LIST
46944: LIST
46945: LIST
46946: LIST
46947: LIST
46948: LIST
46949: LIST
46950: LIST
46951: LIST
46952: LIST
46953: LIST
46954: LIST
46955: LIST
46956: LIST
46957: LIST
46958: LIST
46959: LIST
46960: LIST
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: LIST
46976: LIST
46977: LIST
46978: LIST
46979: LIST
46980: LIST
46981: LIST
46982: LIST
46983: LIST
46984: LIST
46985: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46986: LD_ADDR_VAR 0 34
46990: PUSH
46991: LD_INT 0
46993: PUSH
46994: LD_INT 4
46996: NEG
46997: PUSH
46998: EMPTY
46999: LIST
47000: LIST
47001: PUSH
47002: LD_INT 0
47004: PUSH
47005: LD_INT 5
47007: NEG
47008: PUSH
47009: EMPTY
47010: LIST
47011: LIST
47012: PUSH
47013: LD_INT 1
47015: PUSH
47016: LD_INT 4
47018: NEG
47019: PUSH
47020: EMPTY
47021: LIST
47022: LIST
47023: PUSH
47024: LD_INT 1
47026: PUSH
47027: LD_INT 3
47029: NEG
47030: PUSH
47031: EMPTY
47032: LIST
47033: LIST
47034: PUSH
47035: LD_INT 0
47037: PUSH
47038: LD_INT 3
47040: NEG
47041: PUSH
47042: EMPTY
47043: LIST
47044: LIST
47045: PUSH
47046: LD_INT 1
47048: NEG
47049: PUSH
47050: LD_INT 4
47052: NEG
47053: PUSH
47054: EMPTY
47055: LIST
47056: LIST
47057: PUSH
47058: LD_INT 1
47060: NEG
47061: PUSH
47062: LD_INT 5
47064: NEG
47065: PUSH
47066: EMPTY
47067: LIST
47068: LIST
47069: PUSH
47070: LD_INT 2
47072: PUSH
47073: LD_INT 3
47075: NEG
47076: PUSH
47077: EMPTY
47078: LIST
47079: LIST
47080: PUSH
47081: LD_INT 2
47083: NEG
47084: PUSH
47085: LD_INT 5
47087: NEG
47088: PUSH
47089: EMPTY
47090: LIST
47091: LIST
47092: PUSH
47093: LD_INT 3
47095: PUSH
47096: LD_INT 0
47098: PUSH
47099: EMPTY
47100: LIST
47101: LIST
47102: PUSH
47103: LD_INT 3
47105: PUSH
47106: LD_INT 1
47108: NEG
47109: PUSH
47110: EMPTY
47111: LIST
47112: LIST
47113: PUSH
47114: LD_INT 4
47116: PUSH
47117: LD_INT 0
47119: PUSH
47120: EMPTY
47121: LIST
47122: LIST
47123: PUSH
47124: LD_INT 4
47126: PUSH
47127: LD_INT 1
47129: PUSH
47130: EMPTY
47131: LIST
47132: LIST
47133: PUSH
47134: LD_INT 3
47136: PUSH
47137: LD_INT 1
47139: PUSH
47140: EMPTY
47141: LIST
47142: LIST
47143: PUSH
47144: LD_INT 2
47146: PUSH
47147: LD_INT 0
47149: PUSH
47150: EMPTY
47151: LIST
47152: LIST
47153: PUSH
47154: LD_INT 2
47156: PUSH
47157: LD_INT 1
47159: NEG
47160: PUSH
47161: EMPTY
47162: LIST
47163: LIST
47164: PUSH
47165: LD_INT 2
47167: PUSH
47168: LD_INT 2
47170: NEG
47171: PUSH
47172: EMPTY
47173: LIST
47174: LIST
47175: PUSH
47176: LD_INT 4
47178: PUSH
47179: LD_INT 2
47181: PUSH
47182: EMPTY
47183: LIST
47184: LIST
47185: PUSH
47186: LD_INT 4
47188: PUSH
47189: LD_INT 4
47191: PUSH
47192: EMPTY
47193: LIST
47194: LIST
47195: PUSH
47196: LD_INT 4
47198: PUSH
47199: LD_INT 3
47201: PUSH
47202: EMPTY
47203: LIST
47204: LIST
47205: PUSH
47206: LD_INT 5
47208: PUSH
47209: LD_INT 4
47211: PUSH
47212: EMPTY
47213: LIST
47214: LIST
47215: PUSH
47216: LD_INT 5
47218: PUSH
47219: LD_INT 5
47221: PUSH
47222: EMPTY
47223: LIST
47224: LIST
47225: PUSH
47226: LD_INT 4
47228: PUSH
47229: LD_INT 5
47231: PUSH
47232: EMPTY
47233: LIST
47234: LIST
47235: PUSH
47236: LD_INT 3
47238: PUSH
47239: LD_INT 4
47241: PUSH
47242: EMPTY
47243: LIST
47244: LIST
47245: PUSH
47246: LD_INT 3
47248: PUSH
47249: LD_INT 3
47251: PUSH
47252: EMPTY
47253: LIST
47254: LIST
47255: PUSH
47256: LD_INT 5
47258: PUSH
47259: LD_INT 3
47261: PUSH
47262: EMPTY
47263: LIST
47264: LIST
47265: PUSH
47266: LD_INT 3
47268: PUSH
47269: LD_INT 5
47271: PUSH
47272: EMPTY
47273: LIST
47274: LIST
47275: PUSH
47276: LD_INT 0
47278: PUSH
47279: LD_INT 3
47281: PUSH
47282: EMPTY
47283: LIST
47284: LIST
47285: PUSH
47286: LD_INT 0
47288: PUSH
47289: LD_INT 2
47291: PUSH
47292: EMPTY
47293: LIST
47294: LIST
47295: PUSH
47296: LD_INT 1
47298: PUSH
47299: LD_INT 3
47301: PUSH
47302: EMPTY
47303: LIST
47304: LIST
47305: PUSH
47306: LD_INT 1
47308: PUSH
47309: LD_INT 4
47311: PUSH
47312: EMPTY
47313: LIST
47314: LIST
47315: PUSH
47316: LD_INT 0
47318: PUSH
47319: LD_INT 4
47321: PUSH
47322: EMPTY
47323: LIST
47324: LIST
47325: PUSH
47326: LD_INT 1
47328: NEG
47329: PUSH
47330: LD_INT 3
47332: PUSH
47333: EMPTY
47334: LIST
47335: LIST
47336: PUSH
47337: LD_INT 1
47339: NEG
47340: PUSH
47341: LD_INT 2
47343: PUSH
47344: EMPTY
47345: LIST
47346: LIST
47347: PUSH
47348: LD_INT 2
47350: PUSH
47351: LD_INT 4
47353: PUSH
47354: EMPTY
47355: LIST
47356: LIST
47357: PUSH
47358: LD_INT 2
47360: NEG
47361: PUSH
47362: LD_INT 2
47364: PUSH
47365: EMPTY
47366: LIST
47367: LIST
47368: PUSH
47369: LD_INT 4
47371: NEG
47372: PUSH
47373: LD_INT 0
47375: PUSH
47376: EMPTY
47377: LIST
47378: LIST
47379: PUSH
47380: LD_INT 4
47382: NEG
47383: PUSH
47384: LD_INT 1
47386: NEG
47387: PUSH
47388: EMPTY
47389: LIST
47390: LIST
47391: PUSH
47392: LD_INT 3
47394: NEG
47395: PUSH
47396: LD_INT 0
47398: PUSH
47399: EMPTY
47400: LIST
47401: LIST
47402: PUSH
47403: LD_INT 3
47405: NEG
47406: PUSH
47407: LD_INT 1
47409: PUSH
47410: EMPTY
47411: LIST
47412: LIST
47413: PUSH
47414: LD_INT 4
47416: NEG
47417: PUSH
47418: LD_INT 1
47420: PUSH
47421: EMPTY
47422: LIST
47423: LIST
47424: PUSH
47425: LD_INT 5
47427: NEG
47428: PUSH
47429: LD_INT 0
47431: PUSH
47432: EMPTY
47433: LIST
47434: LIST
47435: PUSH
47436: LD_INT 5
47438: NEG
47439: PUSH
47440: LD_INT 1
47442: NEG
47443: PUSH
47444: EMPTY
47445: LIST
47446: LIST
47447: PUSH
47448: LD_INT 5
47450: NEG
47451: PUSH
47452: LD_INT 2
47454: NEG
47455: PUSH
47456: EMPTY
47457: LIST
47458: LIST
47459: PUSH
47460: LD_INT 3
47462: NEG
47463: PUSH
47464: LD_INT 2
47466: PUSH
47467: EMPTY
47468: LIST
47469: LIST
47470: PUSH
47471: EMPTY
47472: LIST
47473: LIST
47474: LIST
47475: LIST
47476: LIST
47477: LIST
47478: LIST
47479: LIST
47480: LIST
47481: LIST
47482: LIST
47483: LIST
47484: LIST
47485: LIST
47486: LIST
47487: LIST
47488: LIST
47489: LIST
47490: LIST
47491: LIST
47492: LIST
47493: LIST
47494: LIST
47495: LIST
47496: LIST
47497: LIST
47498: LIST
47499: LIST
47500: LIST
47501: LIST
47502: LIST
47503: LIST
47504: LIST
47505: LIST
47506: LIST
47507: LIST
47508: LIST
47509: LIST
47510: LIST
47511: LIST
47512: LIST
47513: LIST
47514: LIST
47515: LIST
47516: LIST
47517: ST_TO_ADDR
// end ; end ;
47518: GO 47521
47520: POP
// case btype of b_depot , b_warehouse :
47521: LD_VAR 0 1
47525: PUSH
47526: LD_INT 0
47528: DOUBLE
47529: EQUAL
47530: IFTRUE 47540
47532: LD_INT 1
47534: DOUBLE
47535: EQUAL
47536: IFTRUE 47540
47538: GO 47741
47540: POP
// case nation of nation_american :
47541: LD_VAR 0 5
47545: PUSH
47546: LD_INT 1
47548: DOUBLE
47549: EQUAL
47550: IFTRUE 47554
47552: GO 47610
47554: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
47555: LD_ADDR_VAR 0 9
47559: PUSH
47560: LD_VAR 0 11
47564: PUSH
47565: LD_VAR 0 12
47569: PUSH
47570: LD_VAR 0 13
47574: PUSH
47575: LD_VAR 0 14
47579: PUSH
47580: LD_VAR 0 15
47584: PUSH
47585: LD_VAR 0 16
47589: PUSH
47590: EMPTY
47591: LIST
47592: LIST
47593: LIST
47594: LIST
47595: LIST
47596: LIST
47597: PUSH
47598: LD_VAR 0 4
47602: PUSH
47603: LD_INT 1
47605: PLUS
47606: ARRAY
47607: ST_TO_ADDR
47608: GO 47739
47610: LD_INT 2
47612: DOUBLE
47613: EQUAL
47614: IFTRUE 47618
47616: GO 47674
47618: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
47619: LD_ADDR_VAR 0 9
47623: PUSH
47624: LD_VAR 0 17
47628: PUSH
47629: LD_VAR 0 18
47633: PUSH
47634: LD_VAR 0 19
47638: PUSH
47639: LD_VAR 0 20
47643: PUSH
47644: LD_VAR 0 21
47648: PUSH
47649: LD_VAR 0 22
47653: PUSH
47654: EMPTY
47655: LIST
47656: LIST
47657: LIST
47658: LIST
47659: LIST
47660: LIST
47661: PUSH
47662: LD_VAR 0 4
47666: PUSH
47667: LD_INT 1
47669: PLUS
47670: ARRAY
47671: ST_TO_ADDR
47672: GO 47739
47674: LD_INT 3
47676: DOUBLE
47677: EQUAL
47678: IFTRUE 47682
47680: GO 47738
47682: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
47683: LD_ADDR_VAR 0 9
47687: PUSH
47688: LD_VAR 0 23
47692: PUSH
47693: LD_VAR 0 24
47697: PUSH
47698: LD_VAR 0 25
47702: PUSH
47703: LD_VAR 0 26
47707: PUSH
47708: LD_VAR 0 27
47712: PUSH
47713: LD_VAR 0 28
47717: PUSH
47718: EMPTY
47719: LIST
47720: LIST
47721: LIST
47722: LIST
47723: LIST
47724: LIST
47725: PUSH
47726: LD_VAR 0 4
47730: PUSH
47731: LD_INT 1
47733: PLUS
47734: ARRAY
47735: ST_TO_ADDR
47736: GO 47739
47738: POP
47739: GO 48294
47741: LD_INT 2
47743: DOUBLE
47744: EQUAL
47745: IFTRUE 47755
47747: LD_INT 3
47749: DOUBLE
47750: EQUAL
47751: IFTRUE 47755
47753: GO 47811
47755: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47756: LD_ADDR_VAR 0 9
47760: PUSH
47761: LD_VAR 0 29
47765: PUSH
47766: LD_VAR 0 30
47770: PUSH
47771: LD_VAR 0 31
47775: PUSH
47776: LD_VAR 0 32
47780: PUSH
47781: LD_VAR 0 33
47785: PUSH
47786: LD_VAR 0 34
47790: PUSH
47791: EMPTY
47792: LIST
47793: LIST
47794: LIST
47795: LIST
47796: LIST
47797: LIST
47798: PUSH
47799: LD_VAR 0 4
47803: PUSH
47804: LD_INT 1
47806: PLUS
47807: ARRAY
47808: ST_TO_ADDR
47809: GO 48294
47811: LD_INT 16
47813: DOUBLE
47814: EQUAL
47815: IFTRUE 47873
47817: LD_INT 17
47819: DOUBLE
47820: EQUAL
47821: IFTRUE 47873
47823: LD_INT 18
47825: DOUBLE
47826: EQUAL
47827: IFTRUE 47873
47829: LD_INT 19
47831: DOUBLE
47832: EQUAL
47833: IFTRUE 47873
47835: LD_INT 22
47837: DOUBLE
47838: EQUAL
47839: IFTRUE 47873
47841: LD_INT 20
47843: DOUBLE
47844: EQUAL
47845: IFTRUE 47873
47847: LD_INT 21
47849: DOUBLE
47850: EQUAL
47851: IFTRUE 47873
47853: LD_INT 23
47855: DOUBLE
47856: EQUAL
47857: IFTRUE 47873
47859: LD_INT 24
47861: DOUBLE
47862: EQUAL
47863: IFTRUE 47873
47865: LD_INT 25
47867: DOUBLE
47868: EQUAL
47869: IFTRUE 47873
47871: GO 47929
47873: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47874: LD_ADDR_VAR 0 9
47878: PUSH
47879: LD_VAR 0 35
47883: PUSH
47884: LD_VAR 0 36
47888: PUSH
47889: LD_VAR 0 37
47893: PUSH
47894: LD_VAR 0 38
47898: PUSH
47899: LD_VAR 0 39
47903: PUSH
47904: LD_VAR 0 40
47908: PUSH
47909: EMPTY
47910: LIST
47911: LIST
47912: LIST
47913: LIST
47914: LIST
47915: LIST
47916: PUSH
47917: LD_VAR 0 4
47921: PUSH
47922: LD_INT 1
47924: PLUS
47925: ARRAY
47926: ST_TO_ADDR
47927: GO 48294
47929: LD_INT 6
47931: DOUBLE
47932: EQUAL
47933: IFTRUE 47985
47935: LD_INT 7
47937: DOUBLE
47938: EQUAL
47939: IFTRUE 47985
47941: LD_INT 8
47943: DOUBLE
47944: EQUAL
47945: IFTRUE 47985
47947: LD_INT 13
47949: DOUBLE
47950: EQUAL
47951: IFTRUE 47985
47953: LD_INT 12
47955: DOUBLE
47956: EQUAL
47957: IFTRUE 47985
47959: LD_INT 15
47961: DOUBLE
47962: EQUAL
47963: IFTRUE 47985
47965: LD_INT 11
47967: DOUBLE
47968: EQUAL
47969: IFTRUE 47985
47971: LD_INT 14
47973: DOUBLE
47974: EQUAL
47975: IFTRUE 47985
47977: LD_INT 10
47979: DOUBLE
47980: EQUAL
47981: IFTRUE 47985
47983: GO 48041
47985: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47986: LD_ADDR_VAR 0 9
47990: PUSH
47991: LD_VAR 0 41
47995: PUSH
47996: LD_VAR 0 42
48000: PUSH
48001: LD_VAR 0 43
48005: PUSH
48006: LD_VAR 0 44
48010: PUSH
48011: LD_VAR 0 45
48015: PUSH
48016: LD_VAR 0 46
48020: PUSH
48021: EMPTY
48022: LIST
48023: LIST
48024: LIST
48025: LIST
48026: LIST
48027: LIST
48028: PUSH
48029: LD_VAR 0 4
48033: PUSH
48034: LD_INT 1
48036: PLUS
48037: ARRAY
48038: ST_TO_ADDR
48039: GO 48294
48041: LD_INT 36
48043: DOUBLE
48044: EQUAL
48045: IFTRUE 48049
48047: GO 48105
48049: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
48050: LD_ADDR_VAR 0 9
48054: PUSH
48055: LD_VAR 0 47
48059: PUSH
48060: LD_VAR 0 48
48064: PUSH
48065: LD_VAR 0 49
48069: PUSH
48070: LD_VAR 0 50
48074: PUSH
48075: LD_VAR 0 51
48079: PUSH
48080: LD_VAR 0 52
48084: PUSH
48085: EMPTY
48086: LIST
48087: LIST
48088: LIST
48089: LIST
48090: LIST
48091: LIST
48092: PUSH
48093: LD_VAR 0 4
48097: PUSH
48098: LD_INT 1
48100: PLUS
48101: ARRAY
48102: ST_TO_ADDR
48103: GO 48294
48105: LD_INT 4
48107: DOUBLE
48108: EQUAL
48109: IFTRUE 48131
48111: LD_INT 5
48113: DOUBLE
48114: EQUAL
48115: IFTRUE 48131
48117: LD_INT 34
48119: DOUBLE
48120: EQUAL
48121: IFTRUE 48131
48123: LD_INT 37
48125: DOUBLE
48126: EQUAL
48127: IFTRUE 48131
48129: GO 48187
48131: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
48132: LD_ADDR_VAR 0 9
48136: PUSH
48137: LD_VAR 0 53
48141: PUSH
48142: LD_VAR 0 54
48146: PUSH
48147: LD_VAR 0 55
48151: PUSH
48152: LD_VAR 0 56
48156: PUSH
48157: LD_VAR 0 57
48161: PUSH
48162: LD_VAR 0 58
48166: PUSH
48167: EMPTY
48168: LIST
48169: LIST
48170: LIST
48171: LIST
48172: LIST
48173: LIST
48174: PUSH
48175: LD_VAR 0 4
48179: PUSH
48180: LD_INT 1
48182: PLUS
48183: ARRAY
48184: ST_TO_ADDR
48185: GO 48294
48187: LD_INT 31
48189: DOUBLE
48190: EQUAL
48191: IFTRUE 48237
48193: LD_INT 32
48195: DOUBLE
48196: EQUAL
48197: IFTRUE 48237
48199: LD_INT 33
48201: DOUBLE
48202: EQUAL
48203: IFTRUE 48237
48205: LD_INT 27
48207: DOUBLE
48208: EQUAL
48209: IFTRUE 48237
48211: LD_INT 26
48213: DOUBLE
48214: EQUAL
48215: IFTRUE 48237
48217: LD_INT 28
48219: DOUBLE
48220: EQUAL
48221: IFTRUE 48237
48223: LD_INT 29
48225: DOUBLE
48226: EQUAL
48227: IFTRUE 48237
48229: LD_INT 30
48231: DOUBLE
48232: EQUAL
48233: IFTRUE 48237
48235: GO 48293
48237: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
48238: LD_ADDR_VAR 0 9
48242: PUSH
48243: LD_VAR 0 59
48247: PUSH
48248: LD_VAR 0 60
48252: PUSH
48253: LD_VAR 0 61
48257: PUSH
48258: LD_VAR 0 62
48262: PUSH
48263: LD_VAR 0 63
48267: PUSH
48268: LD_VAR 0 64
48272: PUSH
48273: EMPTY
48274: LIST
48275: LIST
48276: LIST
48277: LIST
48278: LIST
48279: LIST
48280: PUSH
48281: LD_VAR 0 4
48285: PUSH
48286: LD_INT 1
48288: PLUS
48289: ARRAY
48290: ST_TO_ADDR
48291: GO 48294
48293: POP
// temp_list2 = [ ] ;
48294: LD_ADDR_VAR 0 10
48298: PUSH
48299: EMPTY
48300: ST_TO_ADDR
// for i in temp_list do
48301: LD_ADDR_VAR 0 8
48305: PUSH
48306: LD_VAR 0 9
48310: PUSH
48311: FOR_IN
48312: IFFALSE 48364
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
48314: LD_ADDR_VAR 0 10
48318: PUSH
48319: LD_VAR 0 10
48323: PUSH
48324: LD_VAR 0 8
48328: PUSH
48329: LD_INT 1
48331: ARRAY
48332: PUSH
48333: LD_VAR 0 2
48337: PLUS
48338: PUSH
48339: LD_VAR 0 8
48343: PUSH
48344: LD_INT 2
48346: ARRAY
48347: PUSH
48348: LD_VAR 0 3
48352: PLUS
48353: PUSH
48354: EMPTY
48355: LIST
48356: LIST
48357: PUSH
48358: EMPTY
48359: LIST
48360: ADD
48361: ST_TO_ADDR
48362: GO 48311
48364: POP
48365: POP
// result = temp_list2 ;
48366: LD_ADDR_VAR 0 7
48370: PUSH
48371: LD_VAR 0 10
48375: ST_TO_ADDR
// end ;
48376: LD_VAR 0 7
48380: RET
// export function EnemyInRange ( unit , dist ) ; begin
48381: LD_INT 0
48383: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
48384: LD_ADDR_VAR 0 3
48388: PUSH
48389: LD_VAR 0 1
48393: PPUSH
48394: CALL_OW 255
48398: PPUSH
48399: LD_VAR 0 1
48403: PPUSH
48404: CALL_OW 250
48408: PPUSH
48409: LD_VAR 0 1
48413: PPUSH
48414: CALL_OW 251
48418: PPUSH
48419: LD_VAR 0 2
48423: PPUSH
48424: CALL 22485 0 4
48428: PUSH
48429: LD_INT 4
48431: ARRAY
48432: ST_TO_ADDR
// end ;
48433: LD_VAR 0 3
48437: RET
// export function PlayerSeeMe ( unit ) ; begin
48438: LD_INT 0
48440: PPUSH
// result := See ( your_side , unit ) ;
48441: LD_ADDR_VAR 0 2
48445: PUSH
48446: LD_OWVAR 2
48450: PPUSH
48451: LD_VAR 0 1
48455: PPUSH
48456: CALL_OW 292
48460: ST_TO_ADDR
// end ;
48461: LD_VAR 0 2
48465: RET
// export function ReverseDir ( unit ) ; begin
48466: LD_INT 0
48468: PPUSH
// if not unit then
48469: LD_VAR 0 1
48473: NOT
48474: IFFALSE 48478
// exit ;
48476: GO 48501
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
48478: LD_ADDR_VAR 0 2
48482: PUSH
48483: LD_VAR 0 1
48487: PPUSH
48488: CALL_OW 254
48492: PUSH
48493: LD_INT 3
48495: PLUS
48496: PUSH
48497: LD_INT 6
48499: MOD
48500: ST_TO_ADDR
// end ;
48501: LD_VAR 0 2
48505: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
48506: LD_INT 0
48508: PPUSH
48509: PPUSH
48510: PPUSH
48511: PPUSH
48512: PPUSH
// if not hexes then
48513: LD_VAR 0 2
48517: NOT
48518: IFFALSE 48522
// exit ;
48520: GO 48670
// dist := 9999 ;
48522: LD_ADDR_VAR 0 5
48526: PUSH
48527: LD_INT 9999
48529: ST_TO_ADDR
// for i = 1 to hexes do
48530: LD_ADDR_VAR 0 4
48534: PUSH
48535: DOUBLE
48536: LD_INT 1
48538: DEC
48539: ST_TO_ADDR
48540: LD_VAR 0 2
48544: PUSH
48545: FOR_TO
48546: IFFALSE 48658
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
48548: LD_VAR 0 1
48552: PPUSH
48553: LD_VAR 0 2
48557: PUSH
48558: LD_VAR 0 4
48562: ARRAY
48563: PUSH
48564: LD_INT 1
48566: ARRAY
48567: PPUSH
48568: LD_VAR 0 2
48572: PUSH
48573: LD_VAR 0 4
48577: ARRAY
48578: PUSH
48579: LD_INT 2
48581: ARRAY
48582: PPUSH
48583: CALL_OW 297
48587: PUSH
48588: LD_VAR 0 5
48592: LESS
48593: IFFALSE 48656
// begin hex := hexes [ i ] ;
48595: LD_ADDR_VAR 0 7
48599: PUSH
48600: LD_VAR 0 2
48604: PUSH
48605: LD_VAR 0 4
48609: ARRAY
48610: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
48611: LD_ADDR_VAR 0 5
48615: PUSH
48616: LD_VAR 0 1
48620: PPUSH
48621: LD_VAR 0 2
48625: PUSH
48626: LD_VAR 0 4
48630: ARRAY
48631: PUSH
48632: LD_INT 1
48634: ARRAY
48635: PPUSH
48636: LD_VAR 0 2
48640: PUSH
48641: LD_VAR 0 4
48645: ARRAY
48646: PUSH
48647: LD_INT 2
48649: ARRAY
48650: PPUSH
48651: CALL_OW 297
48655: ST_TO_ADDR
// end ; end ;
48656: GO 48545
48658: POP
48659: POP
// result := hex ;
48660: LD_ADDR_VAR 0 3
48664: PUSH
48665: LD_VAR 0 7
48669: ST_TO_ADDR
// end ;
48670: LD_VAR 0 3
48674: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
48675: LD_INT 0
48677: PPUSH
48678: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
48679: LD_VAR 0 1
48683: NOT
48684: PUSH
48685: LD_VAR 0 1
48689: PUSH
48690: LD_INT 21
48692: PUSH
48693: LD_INT 2
48695: PUSH
48696: EMPTY
48697: LIST
48698: LIST
48699: PUSH
48700: LD_INT 23
48702: PUSH
48703: LD_INT 2
48705: PUSH
48706: EMPTY
48707: LIST
48708: LIST
48709: PUSH
48710: EMPTY
48711: LIST
48712: LIST
48713: PPUSH
48714: CALL_OW 69
48718: IN
48719: NOT
48720: OR
48721: IFFALSE 48725
// exit ;
48723: GO 48772
// for i = 1 to 3 do
48725: LD_ADDR_VAR 0 3
48729: PUSH
48730: DOUBLE
48731: LD_INT 1
48733: DEC
48734: ST_TO_ADDR
48735: LD_INT 3
48737: PUSH
48738: FOR_TO
48739: IFFALSE 48770
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48741: LD_VAR 0 1
48745: PPUSH
48746: CALL_OW 250
48750: PPUSH
48751: LD_VAR 0 1
48755: PPUSH
48756: CALL_OW 251
48760: PPUSH
48761: LD_INT 1
48763: PPUSH
48764: CALL_OW 453
48768: GO 48738
48770: POP
48771: POP
// end ;
48772: LD_VAR 0 2
48776: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48777: LD_INT 0
48779: PPUSH
48780: PPUSH
48781: PPUSH
48782: PPUSH
48783: PPUSH
48784: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48785: LD_VAR 0 1
48789: NOT
48790: PUSH
48791: LD_VAR 0 2
48795: NOT
48796: OR
48797: PUSH
48798: LD_VAR 0 1
48802: PPUSH
48803: CALL_OW 314
48807: OR
48808: IFFALSE 48812
// exit ;
48810: GO 49253
// x := GetX ( enemy_unit ) ;
48812: LD_ADDR_VAR 0 7
48816: PUSH
48817: LD_VAR 0 2
48821: PPUSH
48822: CALL_OW 250
48826: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48827: LD_ADDR_VAR 0 8
48831: PUSH
48832: LD_VAR 0 2
48836: PPUSH
48837: CALL_OW 251
48841: ST_TO_ADDR
// if not x or not y then
48842: LD_VAR 0 7
48846: NOT
48847: PUSH
48848: LD_VAR 0 8
48852: NOT
48853: OR
48854: IFFALSE 48858
// exit ;
48856: GO 49253
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48858: LD_ADDR_VAR 0 6
48862: PUSH
48863: LD_VAR 0 7
48867: PPUSH
48868: LD_INT 0
48870: PPUSH
48871: LD_INT 4
48873: PPUSH
48874: CALL_OW 272
48878: PUSH
48879: LD_VAR 0 8
48883: PPUSH
48884: LD_INT 0
48886: PPUSH
48887: LD_INT 4
48889: PPUSH
48890: CALL_OW 273
48894: PUSH
48895: EMPTY
48896: LIST
48897: LIST
48898: PUSH
48899: LD_VAR 0 7
48903: PPUSH
48904: LD_INT 1
48906: PPUSH
48907: LD_INT 4
48909: PPUSH
48910: CALL_OW 272
48914: PUSH
48915: LD_VAR 0 8
48919: PPUSH
48920: LD_INT 1
48922: PPUSH
48923: LD_INT 4
48925: PPUSH
48926: CALL_OW 273
48930: PUSH
48931: EMPTY
48932: LIST
48933: LIST
48934: PUSH
48935: LD_VAR 0 7
48939: PPUSH
48940: LD_INT 2
48942: PPUSH
48943: LD_INT 4
48945: PPUSH
48946: CALL_OW 272
48950: PUSH
48951: LD_VAR 0 8
48955: PPUSH
48956: LD_INT 2
48958: PPUSH
48959: LD_INT 4
48961: PPUSH
48962: CALL_OW 273
48966: PUSH
48967: EMPTY
48968: LIST
48969: LIST
48970: PUSH
48971: LD_VAR 0 7
48975: PPUSH
48976: LD_INT 3
48978: PPUSH
48979: LD_INT 4
48981: PPUSH
48982: CALL_OW 272
48986: PUSH
48987: LD_VAR 0 8
48991: PPUSH
48992: LD_INT 3
48994: PPUSH
48995: LD_INT 4
48997: PPUSH
48998: CALL_OW 273
49002: PUSH
49003: EMPTY
49004: LIST
49005: LIST
49006: PUSH
49007: LD_VAR 0 7
49011: PPUSH
49012: LD_INT 4
49014: PPUSH
49015: LD_INT 4
49017: PPUSH
49018: CALL_OW 272
49022: PUSH
49023: LD_VAR 0 8
49027: PPUSH
49028: LD_INT 4
49030: PPUSH
49031: LD_INT 4
49033: PPUSH
49034: CALL_OW 273
49038: PUSH
49039: EMPTY
49040: LIST
49041: LIST
49042: PUSH
49043: LD_VAR 0 7
49047: PPUSH
49048: LD_INT 5
49050: PPUSH
49051: LD_INT 4
49053: PPUSH
49054: CALL_OW 272
49058: PUSH
49059: LD_VAR 0 8
49063: PPUSH
49064: LD_INT 5
49066: PPUSH
49067: LD_INT 4
49069: PPUSH
49070: CALL_OW 273
49074: PUSH
49075: EMPTY
49076: LIST
49077: LIST
49078: PUSH
49079: EMPTY
49080: LIST
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: ST_TO_ADDR
// for i = tmp downto 1 do
49087: LD_ADDR_VAR 0 4
49091: PUSH
49092: DOUBLE
49093: LD_VAR 0 6
49097: INC
49098: ST_TO_ADDR
49099: LD_INT 1
49101: PUSH
49102: FOR_DOWNTO
49103: IFFALSE 49204
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
49105: LD_VAR 0 6
49109: PUSH
49110: LD_VAR 0 4
49114: ARRAY
49115: PUSH
49116: LD_INT 1
49118: ARRAY
49119: PPUSH
49120: LD_VAR 0 6
49124: PUSH
49125: LD_VAR 0 4
49129: ARRAY
49130: PUSH
49131: LD_INT 2
49133: ARRAY
49134: PPUSH
49135: CALL_OW 488
49139: NOT
49140: PUSH
49141: LD_VAR 0 6
49145: PUSH
49146: LD_VAR 0 4
49150: ARRAY
49151: PUSH
49152: LD_INT 1
49154: ARRAY
49155: PPUSH
49156: LD_VAR 0 6
49160: PUSH
49161: LD_VAR 0 4
49165: ARRAY
49166: PUSH
49167: LD_INT 2
49169: ARRAY
49170: PPUSH
49171: CALL_OW 428
49175: PUSH
49176: LD_INT 0
49178: NONEQUAL
49179: OR
49180: IFFALSE 49202
// tmp := Delete ( tmp , i ) ;
49182: LD_ADDR_VAR 0 6
49186: PUSH
49187: LD_VAR 0 6
49191: PPUSH
49192: LD_VAR 0 4
49196: PPUSH
49197: CALL_OW 3
49201: ST_TO_ADDR
49202: GO 49102
49204: POP
49205: POP
// j := GetClosestHex ( unit , tmp ) ;
49206: LD_ADDR_VAR 0 5
49210: PUSH
49211: LD_VAR 0 1
49215: PPUSH
49216: LD_VAR 0 6
49220: PPUSH
49221: CALL 48506 0 2
49225: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
49226: LD_VAR 0 1
49230: PPUSH
49231: LD_VAR 0 5
49235: PUSH
49236: LD_INT 1
49238: ARRAY
49239: PPUSH
49240: LD_VAR 0 5
49244: PUSH
49245: LD_INT 2
49247: ARRAY
49248: PPUSH
49249: CALL_OW 111
// end ;
49253: LD_VAR 0 3
49257: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
49258: LD_INT 0
49260: PPUSH
49261: PPUSH
49262: PPUSH
// uc_side = 0 ;
49263: LD_ADDR_OWVAR 20
49267: PUSH
49268: LD_INT 0
49270: ST_TO_ADDR
// uc_nation = 0 ;
49271: LD_ADDR_OWVAR 21
49275: PUSH
49276: LD_INT 0
49278: ST_TO_ADDR
// InitHc ;
49279: CALL_OW 19
// InitVc ;
49283: CALL_OW 20
// if mastodonts then
49287: LD_VAR 0 6
49291: IFFALSE 49358
// for i = 1 to mastodonts do
49293: LD_ADDR_VAR 0 11
49297: PUSH
49298: DOUBLE
49299: LD_INT 1
49301: DEC
49302: ST_TO_ADDR
49303: LD_VAR 0 6
49307: PUSH
49308: FOR_TO
49309: IFFALSE 49356
// begin vc_chassis := 31 ;
49311: LD_ADDR_OWVAR 37
49315: PUSH
49316: LD_INT 31
49318: ST_TO_ADDR
// vc_control := control_rider ;
49319: LD_ADDR_OWVAR 38
49323: PUSH
49324: LD_INT 4
49326: ST_TO_ADDR
// animal := CreateVehicle ;
49327: LD_ADDR_VAR 0 12
49331: PUSH
49332: CALL_OW 45
49336: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49337: LD_VAR 0 12
49341: PPUSH
49342: LD_VAR 0 8
49346: PPUSH
49347: LD_INT 0
49349: PPUSH
49350: CALL 56136 0 3
// end ;
49354: GO 49308
49356: POP
49357: POP
// if horses then
49358: LD_VAR 0 5
49362: IFFALSE 49429
// for i = 1 to horses do
49364: LD_ADDR_VAR 0 11
49368: PUSH
49369: DOUBLE
49370: LD_INT 1
49372: DEC
49373: ST_TO_ADDR
49374: LD_VAR 0 5
49378: PUSH
49379: FOR_TO
49380: IFFALSE 49427
// begin hc_class := 21 ;
49382: LD_ADDR_OWVAR 28
49386: PUSH
49387: LD_INT 21
49389: ST_TO_ADDR
// hc_gallery :=  ;
49390: LD_ADDR_OWVAR 33
49394: PUSH
49395: LD_STRING 
49397: ST_TO_ADDR
// animal := CreateHuman ;
49398: LD_ADDR_VAR 0 12
49402: PUSH
49403: CALL_OW 44
49407: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49408: LD_VAR 0 12
49412: PPUSH
49413: LD_VAR 0 8
49417: PPUSH
49418: LD_INT 0
49420: PPUSH
49421: CALL 56136 0 3
// end ;
49425: GO 49379
49427: POP
49428: POP
// if birds then
49429: LD_VAR 0 1
49433: IFFALSE 49500
// for i = 1 to birds do
49435: LD_ADDR_VAR 0 11
49439: PUSH
49440: DOUBLE
49441: LD_INT 1
49443: DEC
49444: ST_TO_ADDR
49445: LD_VAR 0 1
49449: PUSH
49450: FOR_TO
49451: IFFALSE 49498
// begin hc_class = 18 ;
49453: LD_ADDR_OWVAR 28
49457: PUSH
49458: LD_INT 18
49460: ST_TO_ADDR
// hc_gallery =  ;
49461: LD_ADDR_OWVAR 33
49465: PUSH
49466: LD_STRING 
49468: ST_TO_ADDR
// animal := CreateHuman ;
49469: LD_ADDR_VAR 0 12
49473: PUSH
49474: CALL_OW 44
49478: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49479: LD_VAR 0 12
49483: PPUSH
49484: LD_VAR 0 8
49488: PPUSH
49489: LD_INT 0
49491: PPUSH
49492: CALL 56136 0 3
// end ;
49496: GO 49450
49498: POP
49499: POP
// if tigers then
49500: LD_VAR 0 2
49504: IFFALSE 49588
// for i = 1 to tigers do
49506: LD_ADDR_VAR 0 11
49510: PUSH
49511: DOUBLE
49512: LD_INT 1
49514: DEC
49515: ST_TO_ADDR
49516: LD_VAR 0 2
49520: PUSH
49521: FOR_TO
49522: IFFALSE 49586
// begin hc_class = class_tiger ;
49524: LD_ADDR_OWVAR 28
49528: PUSH
49529: LD_INT 14
49531: ST_TO_ADDR
// hc_gallery =  ;
49532: LD_ADDR_OWVAR 33
49536: PUSH
49537: LD_STRING 
49539: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49540: LD_ADDR_OWVAR 35
49544: PUSH
49545: LD_INT 7
49547: NEG
49548: PPUSH
49549: LD_INT 7
49551: PPUSH
49552: CALL_OW 12
49556: ST_TO_ADDR
// animal := CreateHuman ;
49557: LD_ADDR_VAR 0 12
49561: PUSH
49562: CALL_OW 44
49566: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49567: LD_VAR 0 12
49571: PPUSH
49572: LD_VAR 0 8
49576: PPUSH
49577: LD_INT 0
49579: PPUSH
49580: CALL 56136 0 3
// end ;
49584: GO 49521
49586: POP
49587: POP
// if apemans then
49588: LD_VAR 0 3
49592: IFFALSE 49715
// for i = 1 to apemans do
49594: LD_ADDR_VAR 0 11
49598: PUSH
49599: DOUBLE
49600: LD_INT 1
49602: DEC
49603: ST_TO_ADDR
49604: LD_VAR 0 3
49608: PUSH
49609: FOR_TO
49610: IFFALSE 49713
// begin hc_class = class_apeman ;
49612: LD_ADDR_OWVAR 28
49616: PUSH
49617: LD_INT 12
49619: ST_TO_ADDR
// hc_gallery =  ;
49620: LD_ADDR_OWVAR 33
49624: PUSH
49625: LD_STRING 
49627: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
49628: LD_ADDR_OWVAR 35
49632: PUSH
49633: LD_INT 5
49635: NEG
49636: PPUSH
49637: LD_INT 5
49639: PPUSH
49640: CALL_OW 12
49644: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49645: LD_ADDR_OWVAR 31
49649: PUSH
49650: LD_INT 1
49652: PPUSH
49653: LD_INT 3
49655: PPUSH
49656: CALL_OW 12
49660: PUSH
49661: LD_INT 1
49663: PPUSH
49664: LD_INT 3
49666: PPUSH
49667: CALL_OW 12
49671: PUSH
49672: LD_INT 0
49674: PUSH
49675: LD_INT 0
49677: PUSH
49678: EMPTY
49679: LIST
49680: LIST
49681: LIST
49682: LIST
49683: ST_TO_ADDR
// animal := CreateHuman ;
49684: LD_ADDR_VAR 0 12
49688: PUSH
49689: CALL_OW 44
49693: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49694: LD_VAR 0 12
49698: PPUSH
49699: LD_VAR 0 8
49703: PPUSH
49704: LD_INT 0
49706: PPUSH
49707: CALL 56136 0 3
// end ;
49711: GO 49609
49713: POP
49714: POP
// if enchidnas then
49715: LD_VAR 0 4
49719: IFFALSE 49786
// for i = 1 to enchidnas do
49721: LD_ADDR_VAR 0 11
49725: PUSH
49726: DOUBLE
49727: LD_INT 1
49729: DEC
49730: ST_TO_ADDR
49731: LD_VAR 0 4
49735: PUSH
49736: FOR_TO
49737: IFFALSE 49784
// begin hc_class = 13 ;
49739: LD_ADDR_OWVAR 28
49743: PUSH
49744: LD_INT 13
49746: ST_TO_ADDR
// hc_gallery =  ;
49747: LD_ADDR_OWVAR 33
49751: PUSH
49752: LD_STRING 
49754: ST_TO_ADDR
// animal := CreateHuman ;
49755: LD_ADDR_VAR 0 12
49759: PUSH
49760: CALL_OW 44
49764: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49765: LD_VAR 0 12
49769: PPUSH
49770: LD_VAR 0 8
49774: PPUSH
49775: LD_INT 0
49777: PPUSH
49778: CALL 56136 0 3
// end ;
49782: GO 49736
49784: POP
49785: POP
// if fishes then
49786: LD_VAR 0 7
49790: IFFALSE 49857
// for i = 1 to fishes do
49792: LD_ADDR_VAR 0 11
49796: PUSH
49797: DOUBLE
49798: LD_INT 1
49800: DEC
49801: ST_TO_ADDR
49802: LD_VAR 0 7
49806: PUSH
49807: FOR_TO
49808: IFFALSE 49855
// begin hc_class = 20 ;
49810: LD_ADDR_OWVAR 28
49814: PUSH
49815: LD_INT 20
49817: ST_TO_ADDR
// hc_gallery =  ;
49818: LD_ADDR_OWVAR 33
49822: PUSH
49823: LD_STRING 
49825: ST_TO_ADDR
// animal := CreateHuman ;
49826: LD_ADDR_VAR 0 12
49830: PUSH
49831: CALL_OW 44
49835: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49836: LD_VAR 0 12
49840: PPUSH
49841: LD_VAR 0 9
49845: PPUSH
49846: LD_INT 0
49848: PPUSH
49849: CALL 56136 0 3
// end ;
49853: GO 49807
49855: POP
49856: POP
// end ;
49857: LD_VAR 0 10
49861: RET
// export function WantHeal ( sci , unit ) ; begin
49862: LD_INT 0
49864: PPUSH
// if GetTaskList ( sci ) > 0 then
49865: LD_VAR 0 1
49869: PPUSH
49870: CALL_OW 437
49874: PUSH
49875: LD_INT 0
49877: GREATER
49878: IFFALSE 49948
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49880: LD_VAR 0 1
49884: PPUSH
49885: CALL_OW 437
49889: PUSH
49890: LD_INT 1
49892: ARRAY
49893: PUSH
49894: LD_INT 1
49896: ARRAY
49897: PUSH
49898: LD_STRING l
49900: EQUAL
49901: PUSH
49902: LD_VAR 0 1
49906: PPUSH
49907: CALL_OW 437
49911: PUSH
49912: LD_INT 1
49914: ARRAY
49915: PUSH
49916: LD_INT 4
49918: ARRAY
49919: PUSH
49920: LD_VAR 0 2
49924: EQUAL
49925: AND
49926: IFFALSE 49938
// result := true else
49928: LD_ADDR_VAR 0 3
49932: PUSH
49933: LD_INT 1
49935: ST_TO_ADDR
49936: GO 49946
// result := false ;
49938: LD_ADDR_VAR 0 3
49942: PUSH
49943: LD_INT 0
49945: ST_TO_ADDR
// end else
49946: GO 49956
// result := false ;
49948: LD_ADDR_VAR 0 3
49952: PUSH
49953: LD_INT 0
49955: ST_TO_ADDR
// end ;
49956: LD_VAR 0 3
49960: RET
// export function HealTarget ( sci ) ; begin
49961: LD_INT 0
49963: PPUSH
// if not sci then
49964: LD_VAR 0 1
49968: NOT
49969: IFFALSE 49973
// exit ;
49971: GO 50038
// result := 0 ;
49973: LD_ADDR_VAR 0 2
49977: PUSH
49978: LD_INT 0
49980: ST_TO_ADDR
// if GetTaskList ( sci ) then
49981: LD_VAR 0 1
49985: PPUSH
49986: CALL_OW 437
49990: IFFALSE 50038
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49992: LD_VAR 0 1
49996: PPUSH
49997: CALL_OW 437
50001: PUSH
50002: LD_INT 1
50004: ARRAY
50005: PUSH
50006: LD_INT 1
50008: ARRAY
50009: PUSH
50010: LD_STRING l
50012: EQUAL
50013: IFFALSE 50038
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
50015: LD_ADDR_VAR 0 2
50019: PUSH
50020: LD_VAR 0 1
50024: PPUSH
50025: CALL_OW 437
50029: PUSH
50030: LD_INT 1
50032: ARRAY
50033: PUSH
50034: LD_INT 4
50036: ARRAY
50037: ST_TO_ADDR
// end ;
50038: LD_VAR 0 2
50042: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
50043: LD_INT 0
50045: PPUSH
50046: PPUSH
50047: PPUSH
50048: PPUSH
50049: PPUSH
50050: PPUSH
50051: PPUSH
50052: PPUSH
50053: PPUSH
50054: PPUSH
50055: PPUSH
50056: PPUSH
50057: PPUSH
50058: PPUSH
50059: PPUSH
50060: PPUSH
50061: PPUSH
50062: PPUSH
50063: PPUSH
50064: PPUSH
50065: PPUSH
50066: PPUSH
50067: PPUSH
50068: PPUSH
50069: PPUSH
50070: PPUSH
50071: PPUSH
50072: PPUSH
50073: PPUSH
50074: PPUSH
50075: PPUSH
50076: PPUSH
50077: PPUSH
50078: PPUSH
// if not list then
50079: LD_VAR 0 1
50083: NOT
50084: IFFALSE 50088
// exit ;
50086: GO 54747
// base := list [ 1 ] ;
50088: LD_ADDR_VAR 0 3
50092: PUSH
50093: LD_VAR 0 1
50097: PUSH
50098: LD_INT 1
50100: ARRAY
50101: ST_TO_ADDR
// group := list [ 2 ] ;
50102: LD_ADDR_VAR 0 4
50106: PUSH
50107: LD_VAR 0 1
50111: PUSH
50112: LD_INT 2
50114: ARRAY
50115: ST_TO_ADDR
// path := list [ 3 ] ;
50116: LD_ADDR_VAR 0 5
50120: PUSH
50121: LD_VAR 0 1
50125: PUSH
50126: LD_INT 3
50128: ARRAY
50129: ST_TO_ADDR
// flags := list [ 4 ] ;
50130: LD_ADDR_VAR 0 6
50134: PUSH
50135: LD_VAR 0 1
50139: PUSH
50140: LD_INT 4
50142: ARRAY
50143: ST_TO_ADDR
// mined := [ ] ;
50144: LD_ADDR_VAR 0 27
50148: PUSH
50149: EMPTY
50150: ST_TO_ADDR
// bombed := [ ] ;
50151: LD_ADDR_VAR 0 28
50155: PUSH
50156: EMPTY
50157: ST_TO_ADDR
// healers := [ ] ;
50158: LD_ADDR_VAR 0 31
50162: PUSH
50163: EMPTY
50164: ST_TO_ADDR
// to_heal := [ ] ;
50165: LD_ADDR_VAR 0 30
50169: PUSH
50170: EMPTY
50171: ST_TO_ADDR
// repairs := [ ] ;
50172: LD_ADDR_VAR 0 33
50176: PUSH
50177: EMPTY
50178: ST_TO_ADDR
// to_repair := [ ] ;
50179: LD_ADDR_VAR 0 32
50183: PUSH
50184: EMPTY
50185: ST_TO_ADDR
// if not group or not path then
50186: LD_VAR 0 4
50190: NOT
50191: PUSH
50192: LD_VAR 0 5
50196: NOT
50197: OR
50198: IFFALSE 50202
// exit ;
50200: GO 54747
// side := GetSide ( group [ 1 ] ) ;
50202: LD_ADDR_VAR 0 35
50206: PUSH
50207: LD_VAR 0 4
50211: PUSH
50212: LD_INT 1
50214: ARRAY
50215: PPUSH
50216: CALL_OW 255
50220: ST_TO_ADDR
// if flags then
50221: LD_VAR 0 6
50225: IFFALSE 50369
// begin f_ignore_area := flags [ 1 ] ;
50227: LD_ADDR_VAR 0 17
50231: PUSH
50232: LD_VAR 0 6
50236: PUSH
50237: LD_INT 1
50239: ARRAY
50240: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
50241: LD_ADDR_VAR 0 18
50245: PUSH
50246: LD_VAR 0 6
50250: PUSH
50251: LD_INT 2
50253: ARRAY
50254: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
50255: LD_ADDR_VAR 0 19
50259: PUSH
50260: LD_VAR 0 6
50264: PUSH
50265: LD_INT 3
50267: ARRAY
50268: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
50269: LD_ADDR_VAR 0 20
50273: PUSH
50274: LD_VAR 0 6
50278: PUSH
50279: LD_INT 4
50281: ARRAY
50282: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
50283: LD_ADDR_VAR 0 21
50287: PUSH
50288: LD_VAR 0 6
50292: PUSH
50293: LD_INT 5
50295: ARRAY
50296: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
50297: LD_ADDR_VAR 0 22
50301: PUSH
50302: LD_VAR 0 6
50306: PUSH
50307: LD_INT 6
50309: ARRAY
50310: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
50311: LD_ADDR_VAR 0 23
50315: PUSH
50316: LD_VAR 0 6
50320: PUSH
50321: LD_INT 7
50323: ARRAY
50324: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
50325: LD_ADDR_VAR 0 24
50329: PUSH
50330: LD_VAR 0 6
50334: PUSH
50335: LD_INT 8
50337: ARRAY
50338: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
50339: LD_ADDR_VAR 0 25
50343: PUSH
50344: LD_VAR 0 6
50348: PUSH
50349: LD_INT 9
50351: ARRAY
50352: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
50353: LD_ADDR_VAR 0 26
50357: PUSH
50358: LD_VAR 0 6
50362: PUSH
50363: LD_INT 10
50365: ARRAY
50366: ST_TO_ADDR
// end else
50367: GO 50449
// begin f_ignore_area := false ;
50369: LD_ADDR_VAR 0 17
50373: PUSH
50374: LD_INT 0
50376: ST_TO_ADDR
// f_capture := false ;
50377: LD_ADDR_VAR 0 18
50381: PUSH
50382: LD_INT 0
50384: ST_TO_ADDR
// f_ignore_civ := false ;
50385: LD_ADDR_VAR 0 19
50389: PUSH
50390: LD_INT 0
50392: ST_TO_ADDR
// f_murder := false ;
50393: LD_ADDR_VAR 0 20
50397: PUSH
50398: LD_INT 0
50400: ST_TO_ADDR
// f_mines := false ;
50401: LD_ADDR_VAR 0 21
50405: PUSH
50406: LD_INT 0
50408: ST_TO_ADDR
// f_repair := false ;
50409: LD_ADDR_VAR 0 22
50413: PUSH
50414: LD_INT 0
50416: ST_TO_ADDR
// f_heal := false ;
50417: LD_ADDR_VAR 0 23
50421: PUSH
50422: LD_INT 0
50424: ST_TO_ADDR
// f_spacetime := false ;
50425: LD_ADDR_VAR 0 24
50429: PUSH
50430: LD_INT 0
50432: ST_TO_ADDR
// f_attack_depot := false ;
50433: LD_ADDR_VAR 0 25
50437: PUSH
50438: LD_INT 0
50440: ST_TO_ADDR
// f_crawl := false ;
50441: LD_ADDR_VAR 0 26
50445: PUSH
50446: LD_INT 0
50448: ST_TO_ADDR
// end ; if f_heal then
50449: LD_VAR 0 23
50453: IFFALSE 50480
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
50455: LD_ADDR_VAR 0 31
50459: PUSH
50460: LD_VAR 0 4
50464: PPUSH
50465: LD_INT 25
50467: PUSH
50468: LD_INT 4
50470: PUSH
50471: EMPTY
50472: LIST
50473: LIST
50474: PPUSH
50475: CALL_OW 72
50479: ST_TO_ADDR
// if f_repair then
50480: LD_VAR 0 22
50484: IFFALSE 50511
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
50486: LD_ADDR_VAR 0 33
50490: PUSH
50491: LD_VAR 0 4
50495: PPUSH
50496: LD_INT 25
50498: PUSH
50499: LD_INT 3
50501: PUSH
50502: EMPTY
50503: LIST
50504: LIST
50505: PPUSH
50506: CALL_OW 72
50510: ST_TO_ADDR
// units_path := [ ] ;
50511: LD_ADDR_VAR 0 16
50515: PUSH
50516: EMPTY
50517: ST_TO_ADDR
// for i = 1 to group do
50518: LD_ADDR_VAR 0 7
50522: PUSH
50523: DOUBLE
50524: LD_INT 1
50526: DEC
50527: ST_TO_ADDR
50528: LD_VAR 0 4
50532: PUSH
50533: FOR_TO
50534: IFFALSE 50563
// units_path := Replace ( units_path , i , path ) ;
50536: LD_ADDR_VAR 0 16
50540: PUSH
50541: LD_VAR 0 16
50545: PPUSH
50546: LD_VAR 0 7
50550: PPUSH
50551: LD_VAR 0 5
50555: PPUSH
50556: CALL_OW 1
50560: ST_TO_ADDR
50561: GO 50533
50563: POP
50564: POP
// repeat for i = group downto 1 do
50565: LD_ADDR_VAR 0 7
50569: PUSH
50570: DOUBLE
50571: LD_VAR 0 4
50575: INC
50576: ST_TO_ADDR
50577: LD_INT 1
50579: PUSH
50580: FOR_DOWNTO
50581: IFFALSE 54703
// begin wait ( 5 ) ;
50583: LD_INT 5
50585: PPUSH
50586: CALL_OW 67
// tmp := [ ] ;
50590: LD_ADDR_VAR 0 14
50594: PUSH
50595: EMPTY
50596: ST_TO_ADDR
// attacking := false ;
50597: LD_ADDR_VAR 0 29
50601: PUSH
50602: LD_INT 0
50604: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
50605: LD_VAR 0 4
50609: PUSH
50610: LD_VAR 0 7
50614: ARRAY
50615: PPUSH
50616: CALL_OW 301
50620: PUSH
50621: LD_VAR 0 4
50625: PUSH
50626: LD_VAR 0 7
50630: ARRAY
50631: NOT
50632: OR
50633: IFFALSE 50742
// begin if GetType ( group [ i ] ) = unit_human then
50635: LD_VAR 0 4
50639: PUSH
50640: LD_VAR 0 7
50644: ARRAY
50645: PPUSH
50646: CALL_OW 247
50650: PUSH
50651: LD_INT 1
50653: EQUAL
50654: IFFALSE 50700
// begin to_heal := to_heal diff group [ i ] ;
50656: LD_ADDR_VAR 0 30
50660: PUSH
50661: LD_VAR 0 30
50665: PUSH
50666: LD_VAR 0 4
50670: PUSH
50671: LD_VAR 0 7
50675: ARRAY
50676: DIFF
50677: ST_TO_ADDR
// healers := healers diff group [ i ] ;
50678: LD_ADDR_VAR 0 31
50682: PUSH
50683: LD_VAR 0 31
50687: PUSH
50688: LD_VAR 0 4
50692: PUSH
50693: LD_VAR 0 7
50697: ARRAY
50698: DIFF
50699: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
50700: LD_ADDR_VAR 0 4
50704: PUSH
50705: LD_VAR 0 4
50709: PPUSH
50710: LD_VAR 0 7
50714: PPUSH
50715: CALL_OW 3
50719: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
50720: LD_ADDR_VAR 0 16
50724: PUSH
50725: LD_VAR 0 16
50729: PPUSH
50730: LD_VAR 0 7
50734: PPUSH
50735: CALL_OW 3
50739: ST_TO_ADDR
// continue ;
50740: GO 50580
// end ; if f_repair then
50742: LD_VAR 0 22
50746: IFFALSE 51235
// begin if GetType ( group [ i ] ) = unit_vehicle then
50748: LD_VAR 0 4
50752: PUSH
50753: LD_VAR 0 7
50757: ARRAY
50758: PPUSH
50759: CALL_OW 247
50763: PUSH
50764: LD_INT 2
50766: EQUAL
50767: IFFALSE 50957
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
50769: LD_VAR 0 4
50773: PUSH
50774: LD_VAR 0 7
50778: ARRAY
50779: PPUSH
50780: CALL_OW 256
50784: PUSH
50785: LD_INT 700
50787: LESS
50788: PUSH
50789: LD_VAR 0 4
50793: PUSH
50794: LD_VAR 0 7
50798: ARRAY
50799: PUSH
50800: LD_VAR 0 32
50804: IN
50805: NOT
50806: AND
50807: IFFALSE 50831
// to_repair := to_repair union group [ i ] ;
50809: LD_ADDR_VAR 0 32
50813: PUSH
50814: LD_VAR 0 32
50818: PUSH
50819: LD_VAR 0 4
50823: PUSH
50824: LD_VAR 0 7
50828: ARRAY
50829: UNION
50830: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
50831: LD_VAR 0 4
50835: PUSH
50836: LD_VAR 0 7
50840: ARRAY
50841: PPUSH
50842: CALL_OW 256
50846: PUSH
50847: LD_INT 1000
50849: EQUAL
50850: PUSH
50851: LD_VAR 0 4
50855: PUSH
50856: LD_VAR 0 7
50860: ARRAY
50861: PUSH
50862: LD_VAR 0 32
50866: IN
50867: AND
50868: IFFALSE 50892
// to_repair := to_repair diff group [ i ] ;
50870: LD_ADDR_VAR 0 32
50874: PUSH
50875: LD_VAR 0 32
50879: PUSH
50880: LD_VAR 0 4
50884: PUSH
50885: LD_VAR 0 7
50889: ARRAY
50890: DIFF
50891: ST_TO_ADDR
// if group [ i ] in to_repair then
50892: LD_VAR 0 4
50896: PUSH
50897: LD_VAR 0 7
50901: ARRAY
50902: PUSH
50903: LD_VAR 0 32
50907: IN
50908: IFFALSE 50955
// begin if not IsInArea ( group [ i ] , f_repair ) then
50910: LD_VAR 0 4
50914: PUSH
50915: LD_VAR 0 7
50919: ARRAY
50920: PPUSH
50921: LD_VAR 0 22
50925: PPUSH
50926: CALL_OW 308
50930: NOT
50931: IFFALSE 50953
// ComMoveToArea ( group [ i ] , f_repair ) ;
50933: LD_VAR 0 4
50937: PUSH
50938: LD_VAR 0 7
50942: ARRAY
50943: PPUSH
50944: LD_VAR 0 22
50948: PPUSH
50949: CALL_OW 113
// continue ;
50953: GO 50580
// end ; end else
50955: GO 51235
// if group [ i ] in repairs then
50957: LD_VAR 0 4
50961: PUSH
50962: LD_VAR 0 7
50966: ARRAY
50967: PUSH
50968: LD_VAR 0 33
50972: IN
50973: IFFALSE 51235
// begin if IsInUnit ( group [ i ] ) then
50975: LD_VAR 0 4
50979: PUSH
50980: LD_VAR 0 7
50984: ARRAY
50985: PPUSH
50986: CALL_OW 310
50990: IFFALSE 51058
// begin z := IsInUnit ( group [ i ] ) ;
50992: LD_ADDR_VAR 0 13
50996: PUSH
50997: LD_VAR 0 4
51001: PUSH
51002: LD_VAR 0 7
51006: ARRAY
51007: PPUSH
51008: CALL_OW 310
51012: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
51013: LD_VAR 0 13
51017: PUSH
51018: LD_VAR 0 32
51022: IN
51023: PUSH
51024: LD_VAR 0 13
51028: PPUSH
51029: LD_VAR 0 22
51033: PPUSH
51034: CALL_OW 308
51038: AND
51039: IFFALSE 51056
// ComExitVehicle ( group [ i ] ) ;
51041: LD_VAR 0 4
51045: PUSH
51046: LD_VAR 0 7
51050: ARRAY
51051: PPUSH
51052: CALL_OW 121
// end else
51056: GO 51235
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
51058: LD_ADDR_VAR 0 13
51062: PUSH
51063: LD_VAR 0 4
51067: PPUSH
51068: LD_INT 95
51070: PUSH
51071: LD_VAR 0 22
51075: PUSH
51076: EMPTY
51077: LIST
51078: LIST
51079: PUSH
51080: LD_INT 58
51082: PUSH
51083: EMPTY
51084: LIST
51085: PUSH
51086: EMPTY
51087: LIST
51088: LIST
51089: PPUSH
51090: CALL_OW 72
51094: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
51095: LD_VAR 0 4
51099: PUSH
51100: LD_VAR 0 7
51104: ARRAY
51105: PPUSH
51106: CALL_OW 314
51110: NOT
51111: IFFALSE 51233
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
51113: LD_ADDR_VAR 0 10
51117: PUSH
51118: LD_VAR 0 13
51122: PPUSH
51123: LD_VAR 0 4
51127: PUSH
51128: LD_VAR 0 7
51132: ARRAY
51133: PPUSH
51134: CALL_OW 74
51138: ST_TO_ADDR
// if not x then
51139: LD_VAR 0 10
51143: NOT
51144: IFFALSE 51148
// continue ;
51146: GO 50580
// if GetLives ( x ) < 1000 then
51148: LD_VAR 0 10
51152: PPUSH
51153: CALL_OW 256
51157: PUSH
51158: LD_INT 1000
51160: LESS
51161: IFFALSE 51185
// ComRepairVehicle ( group [ i ] , x ) else
51163: LD_VAR 0 4
51167: PUSH
51168: LD_VAR 0 7
51172: ARRAY
51173: PPUSH
51174: LD_VAR 0 10
51178: PPUSH
51179: CALL_OW 129
51183: GO 51233
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
51185: LD_VAR 0 23
51189: PUSH
51190: LD_VAR 0 4
51194: PUSH
51195: LD_VAR 0 7
51199: ARRAY
51200: PPUSH
51201: CALL_OW 256
51205: PUSH
51206: LD_INT 1000
51208: LESS
51209: AND
51210: NOT
51211: IFFALSE 51233
// ComEnterUnit ( group [ i ] , x ) ;
51213: LD_VAR 0 4
51217: PUSH
51218: LD_VAR 0 7
51222: ARRAY
51223: PPUSH
51224: LD_VAR 0 10
51228: PPUSH
51229: CALL_OW 120
// end ; continue ;
51233: GO 50580
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
51235: LD_VAR 0 23
51239: PUSH
51240: LD_VAR 0 4
51244: PUSH
51245: LD_VAR 0 7
51249: ARRAY
51250: PPUSH
51251: CALL_OW 247
51255: PUSH
51256: LD_INT 1
51258: EQUAL
51259: AND
51260: IFFALSE 51738
// begin if group [ i ] in healers then
51262: LD_VAR 0 4
51266: PUSH
51267: LD_VAR 0 7
51271: ARRAY
51272: PUSH
51273: LD_VAR 0 31
51277: IN
51278: IFFALSE 51551
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
51280: LD_VAR 0 4
51284: PUSH
51285: LD_VAR 0 7
51289: ARRAY
51290: PPUSH
51291: LD_VAR 0 23
51295: PPUSH
51296: CALL_OW 308
51300: NOT
51301: PUSH
51302: LD_VAR 0 4
51306: PUSH
51307: LD_VAR 0 7
51311: ARRAY
51312: PPUSH
51313: CALL_OW 314
51317: NOT
51318: AND
51319: IFFALSE 51343
// ComMoveToArea ( group [ i ] , f_heal ) else
51321: LD_VAR 0 4
51325: PUSH
51326: LD_VAR 0 7
51330: ARRAY
51331: PPUSH
51332: LD_VAR 0 23
51336: PPUSH
51337: CALL_OW 113
51341: GO 51549
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
51343: LD_VAR 0 4
51347: PUSH
51348: LD_VAR 0 7
51352: ARRAY
51353: PPUSH
51354: CALL 49961 0 1
51358: PPUSH
51359: CALL_OW 256
51363: PUSH
51364: LD_INT 1000
51366: EQUAL
51367: IFFALSE 51386
// ComStop ( group [ i ] ) else
51369: LD_VAR 0 4
51373: PUSH
51374: LD_VAR 0 7
51378: ARRAY
51379: PPUSH
51380: CALL_OW 141
51384: GO 51549
// if not HasTask ( group [ i ] ) and to_heal then
51386: LD_VAR 0 4
51390: PUSH
51391: LD_VAR 0 7
51395: ARRAY
51396: PPUSH
51397: CALL_OW 314
51401: NOT
51402: PUSH
51403: LD_VAR 0 30
51407: AND
51408: IFFALSE 51549
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
51410: LD_ADDR_VAR 0 13
51414: PUSH
51415: LD_VAR 0 30
51419: PPUSH
51420: LD_INT 3
51422: PUSH
51423: LD_INT 54
51425: PUSH
51426: EMPTY
51427: LIST
51428: PUSH
51429: EMPTY
51430: LIST
51431: LIST
51432: PPUSH
51433: CALL_OW 72
51437: PPUSH
51438: LD_VAR 0 4
51442: PUSH
51443: LD_VAR 0 7
51447: ARRAY
51448: PPUSH
51449: CALL_OW 74
51453: ST_TO_ADDR
// if z then
51454: LD_VAR 0 13
51458: IFFALSE 51549
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
51460: LD_INT 91
51462: PUSH
51463: LD_VAR 0 13
51467: PUSH
51468: LD_INT 10
51470: PUSH
51471: EMPTY
51472: LIST
51473: LIST
51474: LIST
51475: PUSH
51476: LD_INT 81
51478: PUSH
51479: LD_VAR 0 13
51483: PPUSH
51484: CALL_OW 255
51488: PUSH
51489: EMPTY
51490: LIST
51491: LIST
51492: PUSH
51493: EMPTY
51494: LIST
51495: LIST
51496: PPUSH
51497: CALL_OW 69
51501: PUSH
51502: LD_INT 0
51504: EQUAL
51505: IFFALSE 51529
// ComHeal ( group [ i ] , z ) else
51507: LD_VAR 0 4
51511: PUSH
51512: LD_VAR 0 7
51516: ARRAY
51517: PPUSH
51518: LD_VAR 0 13
51522: PPUSH
51523: CALL_OW 128
51527: GO 51549
// ComMoveToArea ( group [ i ] , f_heal ) ;
51529: LD_VAR 0 4
51533: PUSH
51534: LD_VAR 0 7
51538: ARRAY
51539: PPUSH
51540: LD_VAR 0 23
51544: PPUSH
51545: CALL_OW 113
// end ; continue ;
51549: GO 50580
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
51551: LD_VAR 0 4
51555: PUSH
51556: LD_VAR 0 7
51560: ARRAY
51561: PPUSH
51562: CALL_OW 256
51566: PUSH
51567: LD_INT 700
51569: LESS
51570: PUSH
51571: LD_VAR 0 4
51575: PUSH
51576: LD_VAR 0 7
51580: ARRAY
51581: PUSH
51582: LD_VAR 0 30
51586: IN
51587: NOT
51588: AND
51589: IFFALSE 51613
// to_heal := to_heal union group [ i ] ;
51591: LD_ADDR_VAR 0 30
51595: PUSH
51596: LD_VAR 0 30
51600: PUSH
51601: LD_VAR 0 4
51605: PUSH
51606: LD_VAR 0 7
51610: ARRAY
51611: UNION
51612: ST_TO_ADDR
// if group [ i ] in to_heal then
51613: LD_VAR 0 4
51617: PUSH
51618: LD_VAR 0 7
51622: ARRAY
51623: PUSH
51624: LD_VAR 0 30
51628: IN
51629: IFFALSE 51738
// begin if GetLives ( group [ i ] ) = 1000 then
51631: LD_VAR 0 4
51635: PUSH
51636: LD_VAR 0 7
51640: ARRAY
51641: PPUSH
51642: CALL_OW 256
51646: PUSH
51647: LD_INT 1000
51649: EQUAL
51650: IFFALSE 51676
// to_heal := to_heal diff group [ i ] else
51652: LD_ADDR_VAR 0 30
51656: PUSH
51657: LD_VAR 0 30
51661: PUSH
51662: LD_VAR 0 4
51666: PUSH
51667: LD_VAR 0 7
51671: ARRAY
51672: DIFF
51673: ST_TO_ADDR
51674: GO 51738
// begin if not IsInArea ( group [ i ] , to_heal ) then
51676: LD_VAR 0 4
51680: PUSH
51681: LD_VAR 0 7
51685: ARRAY
51686: PPUSH
51687: LD_VAR 0 30
51691: PPUSH
51692: CALL_OW 308
51696: NOT
51697: IFFALSE 51721
// ComMoveToArea ( group [ i ] , f_heal ) else
51699: LD_VAR 0 4
51703: PUSH
51704: LD_VAR 0 7
51708: ARRAY
51709: PPUSH
51710: LD_VAR 0 23
51714: PPUSH
51715: CALL_OW 113
51719: GO 51736
// ComHold ( group [ i ] ) ;
51721: LD_VAR 0 4
51725: PUSH
51726: LD_VAR 0 7
51730: ARRAY
51731: PPUSH
51732: CALL_OW 140
// continue ;
51736: GO 50580
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
51738: LD_VAR 0 4
51742: PUSH
51743: LD_VAR 0 7
51747: ARRAY
51748: PPUSH
51749: LD_INT 10
51751: PPUSH
51752: CALL 48381 0 2
51756: NOT
51757: PUSH
51758: LD_VAR 0 16
51762: PUSH
51763: LD_VAR 0 7
51767: ARRAY
51768: PUSH
51769: EMPTY
51770: EQUAL
51771: NOT
51772: AND
51773: IFFALSE 52039
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
51775: LD_VAR 0 4
51779: PUSH
51780: LD_VAR 0 7
51784: ARRAY
51785: PPUSH
51786: CALL_OW 262
51790: PUSH
51791: LD_INT 1
51793: PUSH
51794: LD_INT 2
51796: PUSH
51797: EMPTY
51798: LIST
51799: LIST
51800: IN
51801: IFFALSE 51842
// if GetFuel ( group [ i ] ) < 10 then
51803: LD_VAR 0 4
51807: PUSH
51808: LD_VAR 0 7
51812: ARRAY
51813: PPUSH
51814: CALL_OW 261
51818: PUSH
51819: LD_INT 10
51821: LESS
51822: IFFALSE 51842
// SetFuel ( group [ i ] , 12 ) ;
51824: LD_VAR 0 4
51828: PUSH
51829: LD_VAR 0 7
51833: ARRAY
51834: PPUSH
51835: LD_INT 12
51837: PPUSH
51838: CALL_OW 240
// if units_path [ i ] then
51842: LD_VAR 0 16
51846: PUSH
51847: LD_VAR 0 7
51851: ARRAY
51852: IFFALSE 52037
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
51854: LD_VAR 0 4
51858: PUSH
51859: LD_VAR 0 7
51863: ARRAY
51864: PPUSH
51865: LD_VAR 0 16
51869: PUSH
51870: LD_VAR 0 7
51874: ARRAY
51875: PUSH
51876: LD_INT 1
51878: ARRAY
51879: PUSH
51880: LD_INT 1
51882: ARRAY
51883: PPUSH
51884: LD_VAR 0 16
51888: PUSH
51889: LD_VAR 0 7
51893: ARRAY
51894: PUSH
51895: LD_INT 1
51897: ARRAY
51898: PUSH
51899: LD_INT 2
51901: ARRAY
51902: PPUSH
51903: CALL_OW 297
51907: PUSH
51908: LD_INT 6
51910: GREATER
51911: IFFALSE 51986
// begin if not HasTask ( group [ i ] ) then
51913: LD_VAR 0 4
51917: PUSH
51918: LD_VAR 0 7
51922: ARRAY
51923: PPUSH
51924: CALL_OW 314
51928: NOT
51929: IFFALSE 51984
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51931: LD_VAR 0 4
51935: PUSH
51936: LD_VAR 0 7
51940: ARRAY
51941: PPUSH
51942: LD_VAR 0 16
51946: PUSH
51947: LD_VAR 0 7
51951: ARRAY
51952: PUSH
51953: LD_INT 1
51955: ARRAY
51956: PUSH
51957: LD_INT 1
51959: ARRAY
51960: PPUSH
51961: LD_VAR 0 16
51965: PUSH
51966: LD_VAR 0 7
51970: ARRAY
51971: PUSH
51972: LD_INT 1
51974: ARRAY
51975: PUSH
51976: LD_INT 2
51978: ARRAY
51979: PPUSH
51980: CALL_OW 114
// end else
51984: GO 52037
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51986: LD_ADDR_VAR 0 15
51990: PUSH
51991: LD_VAR 0 16
51995: PUSH
51996: LD_VAR 0 7
52000: ARRAY
52001: PPUSH
52002: LD_INT 1
52004: PPUSH
52005: CALL_OW 3
52009: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
52010: LD_ADDR_VAR 0 16
52014: PUSH
52015: LD_VAR 0 16
52019: PPUSH
52020: LD_VAR 0 7
52024: PPUSH
52025: LD_VAR 0 15
52029: PPUSH
52030: CALL_OW 1
52034: ST_TO_ADDR
// continue ;
52035: GO 50580
// end ; end ; end else
52037: GO 54701
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
52039: LD_ADDR_VAR 0 14
52043: PUSH
52044: LD_INT 81
52046: PUSH
52047: LD_VAR 0 4
52051: PUSH
52052: LD_VAR 0 7
52056: ARRAY
52057: PPUSH
52058: CALL_OW 255
52062: PUSH
52063: EMPTY
52064: LIST
52065: LIST
52066: PPUSH
52067: CALL_OW 69
52071: ST_TO_ADDR
// if not tmp then
52072: LD_VAR 0 14
52076: NOT
52077: IFFALSE 52081
// continue ;
52079: GO 50580
// if f_ignore_area then
52081: LD_VAR 0 17
52085: IFFALSE 52173
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
52087: LD_ADDR_VAR 0 15
52091: PUSH
52092: LD_VAR 0 14
52096: PPUSH
52097: LD_INT 3
52099: PUSH
52100: LD_INT 92
52102: PUSH
52103: LD_VAR 0 17
52107: PUSH
52108: LD_INT 1
52110: ARRAY
52111: PUSH
52112: LD_VAR 0 17
52116: PUSH
52117: LD_INT 2
52119: ARRAY
52120: PUSH
52121: LD_VAR 0 17
52125: PUSH
52126: LD_INT 3
52128: ARRAY
52129: PUSH
52130: EMPTY
52131: LIST
52132: LIST
52133: LIST
52134: LIST
52135: PUSH
52136: EMPTY
52137: LIST
52138: LIST
52139: PPUSH
52140: CALL_OW 72
52144: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
52145: LD_VAR 0 14
52149: PUSH
52150: LD_VAR 0 15
52154: DIFF
52155: IFFALSE 52173
// tmp := tmp diff tmp2 ;
52157: LD_ADDR_VAR 0 14
52161: PUSH
52162: LD_VAR 0 14
52166: PUSH
52167: LD_VAR 0 15
52171: DIFF
52172: ST_TO_ADDR
// end ; if not f_murder then
52173: LD_VAR 0 20
52177: NOT
52178: IFFALSE 52236
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
52180: LD_ADDR_VAR 0 15
52184: PUSH
52185: LD_VAR 0 14
52189: PPUSH
52190: LD_INT 3
52192: PUSH
52193: LD_INT 50
52195: PUSH
52196: EMPTY
52197: LIST
52198: PUSH
52199: EMPTY
52200: LIST
52201: LIST
52202: PPUSH
52203: CALL_OW 72
52207: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
52208: LD_VAR 0 14
52212: PUSH
52213: LD_VAR 0 15
52217: DIFF
52218: IFFALSE 52236
// tmp := tmp diff tmp2 ;
52220: LD_ADDR_VAR 0 14
52224: PUSH
52225: LD_VAR 0 14
52229: PUSH
52230: LD_VAR 0 15
52234: DIFF
52235: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
52236: LD_ADDR_VAR 0 14
52240: PUSH
52241: LD_VAR 0 4
52245: PUSH
52246: LD_VAR 0 7
52250: ARRAY
52251: PPUSH
52252: LD_VAR 0 14
52256: PPUSH
52257: LD_INT 1
52259: PPUSH
52260: LD_INT 1
52262: PPUSH
52263: CALL 22024 0 4
52267: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
52268: LD_VAR 0 4
52272: PUSH
52273: LD_VAR 0 7
52277: ARRAY
52278: PPUSH
52279: CALL_OW 257
52283: PUSH
52284: LD_INT 1
52286: EQUAL
52287: IFFALSE 52735
// begin if WantPlant ( group [ i ] ) then
52289: LD_VAR 0 4
52293: PUSH
52294: LD_VAR 0 7
52298: ARRAY
52299: PPUSH
52300: CALL 21525 0 1
52304: IFFALSE 52308
// continue ;
52306: GO 50580
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
52308: LD_VAR 0 18
52312: PUSH
52313: LD_VAR 0 4
52317: PUSH
52318: LD_VAR 0 7
52322: ARRAY
52323: PPUSH
52324: CALL_OW 310
52328: NOT
52329: AND
52330: PUSH
52331: LD_VAR 0 14
52335: PUSH
52336: LD_INT 1
52338: ARRAY
52339: PUSH
52340: LD_VAR 0 14
52344: PPUSH
52345: LD_INT 21
52347: PUSH
52348: LD_INT 2
52350: PUSH
52351: EMPTY
52352: LIST
52353: LIST
52354: PUSH
52355: LD_INT 58
52357: PUSH
52358: EMPTY
52359: LIST
52360: PUSH
52361: EMPTY
52362: LIST
52363: LIST
52364: PPUSH
52365: CALL_OW 72
52369: IN
52370: AND
52371: IFFALSE 52407
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
52373: LD_VAR 0 4
52377: PUSH
52378: LD_VAR 0 7
52382: ARRAY
52383: PPUSH
52384: LD_VAR 0 14
52388: PUSH
52389: LD_INT 1
52391: ARRAY
52392: PPUSH
52393: CALL_OW 120
// attacking := true ;
52397: LD_ADDR_VAR 0 29
52401: PUSH
52402: LD_INT 1
52404: ST_TO_ADDR
// continue ;
52405: GO 50580
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
52407: LD_VAR 0 26
52411: PUSH
52412: LD_VAR 0 4
52416: PUSH
52417: LD_VAR 0 7
52421: ARRAY
52422: PPUSH
52423: CALL_OW 257
52427: PUSH
52428: LD_INT 1
52430: EQUAL
52431: AND
52432: PUSH
52433: LD_VAR 0 4
52437: PUSH
52438: LD_VAR 0 7
52442: ARRAY
52443: PPUSH
52444: CALL_OW 256
52448: PUSH
52449: LD_INT 800
52451: LESS
52452: AND
52453: PUSH
52454: LD_VAR 0 4
52458: PUSH
52459: LD_VAR 0 7
52463: ARRAY
52464: PPUSH
52465: CALL_OW 318
52469: NOT
52470: AND
52471: IFFALSE 52488
// ComCrawl ( group [ i ] ) ;
52473: LD_VAR 0 4
52477: PUSH
52478: LD_VAR 0 7
52482: ARRAY
52483: PPUSH
52484: CALL_OW 137
// if f_mines then
52488: LD_VAR 0 21
52492: IFFALSE 52735
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
52494: LD_VAR 0 14
52498: PUSH
52499: LD_INT 1
52501: ARRAY
52502: PPUSH
52503: CALL_OW 247
52507: PUSH
52508: LD_INT 3
52510: EQUAL
52511: PUSH
52512: LD_VAR 0 14
52516: PUSH
52517: LD_INT 1
52519: ARRAY
52520: PUSH
52521: LD_VAR 0 27
52525: IN
52526: NOT
52527: AND
52528: IFFALSE 52735
// begin x := GetX ( tmp [ 1 ] ) ;
52530: LD_ADDR_VAR 0 10
52534: PUSH
52535: LD_VAR 0 14
52539: PUSH
52540: LD_INT 1
52542: ARRAY
52543: PPUSH
52544: CALL_OW 250
52548: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
52549: LD_ADDR_VAR 0 11
52553: PUSH
52554: LD_VAR 0 14
52558: PUSH
52559: LD_INT 1
52561: ARRAY
52562: PPUSH
52563: CALL_OW 251
52567: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
52568: LD_ADDR_VAR 0 12
52572: PUSH
52573: LD_VAR 0 4
52577: PUSH
52578: LD_VAR 0 7
52582: ARRAY
52583: PPUSH
52584: CALL 48466 0 1
52588: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
52589: LD_VAR 0 4
52593: PUSH
52594: LD_VAR 0 7
52598: ARRAY
52599: PPUSH
52600: LD_VAR 0 10
52604: PPUSH
52605: LD_VAR 0 11
52609: PPUSH
52610: LD_VAR 0 14
52614: PUSH
52615: LD_INT 1
52617: ARRAY
52618: PPUSH
52619: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
52623: LD_VAR 0 4
52627: PUSH
52628: LD_VAR 0 7
52632: ARRAY
52633: PPUSH
52634: LD_VAR 0 10
52638: PPUSH
52639: LD_VAR 0 12
52643: PPUSH
52644: LD_INT 7
52646: PPUSH
52647: CALL_OW 272
52651: PPUSH
52652: LD_VAR 0 11
52656: PPUSH
52657: LD_VAR 0 12
52661: PPUSH
52662: LD_INT 7
52664: PPUSH
52665: CALL_OW 273
52669: PPUSH
52670: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
52674: LD_VAR 0 4
52678: PUSH
52679: LD_VAR 0 7
52683: ARRAY
52684: PPUSH
52685: LD_INT 71
52687: PPUSH
52688: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
52692: LD_ADDR_VAR 0 27
52696: PUSH
52697: LD_VAR 0 27
52701: PPUSH
52702: LD_VAR 0 27
52706: PUSH
52707: LD_INT 1
52709: PLUS
52710: PPUSH
52711: LD_VAR 0 14
52715: PUSH
52716: LD_INT 1
52718: ARRAY
52719: PPUSH
52720: CALL_OW 1
52724: ST_TO_ADDR
// attacking := true ;
52725: LD_ADDR_VAR 0 29
52729: PUSH
52730: LD_INT 1
52732: ST_TO_ADDR
// continue ;
52733: GO 50580
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
52735: LD_VAR 0 4
52739: PUSH
52740: LD_VAR 0 7
52744: ARRAY
52745: PPUSH
52746: CALL_OW 257
52750: PUSH
52751: LD_INT 17
52753: EQUAL
52754: PUSH
52755: LD_VAR 0 4
52759: PUSH
52760: LD_VAR 0 7
52764: ARRAY
52765: PPUSH
52766: CALL_OW 110
52770: PUSH
52771: LD_INT 71
52773: EQUAL
52774: NOT
52775: AND
52776: IFFALSE 52922
// begin attacking := false ;
52778: LD_ADDR_VAR 0 29
52782: PUSH
52783: LD_INT 0
52785: ST_TO_ADDR
// k := 5 ;
52786: LD_ADDR_VAR 0 9
52790: PUSH
52791: LD_INT 5
52793: ST_TO_ADDR
// if tmp < k then
52794: LD_VAR 0 14
52798: PUSH
52799: LD_VAR 0 9
52803: LESS
52804: IFFALSE 52816
// k := tmp ;
52806: LD_ADDR_VAR 0 9
52810: PUSH
52811: LD_VAR 0 14
52815: ST_TO_ADDR
// for j = 1 to k do
52816: LD_ADDR_VAR 0 8
52820: PUSH
52821: DOUBLE
52822: LD_INT 1
52824: DEC
52825: ST_TO_ADDR
52826: LD_VAR 0 9
52830: PUSH
52831: FOR_TO
52832: IFFALSE 52920
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
52834: LD_VAR 0 14
52838: PUSH
52839: LD_VAR 0 8
52843: ARRAY
52844: PUSH
52845: LD_VAR 0 14
52849: PPUSH
52850: LD_INT 58
52852: PUSH
52853: EMPTY
52854: LIST
52855: PPUSH
52856: CALL_OW 72
52860: IN
52861: NOT
52862: IFFALSE 52918
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52864: LD_VAR 0 4
52868: PUSH
52869: LD_VAR 0 7
52873: ARRAY
52874: PPUSH
52875: LD_VAR 0 14
52879: PUSH
52880: LD_VAR 0 8
52884: ARRAY
52885: PPUSH
52886: CALL_OW 115
// attacking := true ;
52890: LD_ADDR_VAR 0 29
52894: PUSH
52895: LD_INT 1
52897: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
52898: LD_VAR 0 4
52902: PUSH
52903: LD_VAR 0 7
52907: ARRAY
52908: PPUSH
52909: LD_INT 71
52911: PPUSH
52912: CALL_OW 109
// continue ;
52916: GO 52831
// end ; end ;
52918: GO 52831
52920: POP
52921: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
52922: LD_VAR 0 4
52926: PUSH
52927: LD_VAR 0 7
52931: ARRAY
52932: PPUSH
52933: CALL_OW 257
52937: PUSH
52938: LD_INT 8
52940: EQUAL
52941: PUSH
52942: LD_VAR 0 4
52946: PUSH
52947: LD_VAR 0 7
52951: ARRAY
52952: PPUSH
52953: CALL_OW 264
52957: PUSH
52958: LD_INT 28
52960: PUSH
52961: LD_INT 45
52963: PUSH
52964: LD_INT 7
52966: PUSH
52967: LD_INT 47
52969: PUSH
52970: EMPTY
52971: LIST
52972: LIST
52973: LIST
52974: LIST
52975: IN
52976: OR
52977: IFFALSE 53233
// begin attacking := false ;
52979: LD_ADDR_VAR 0 29
52983: PUSH
52984: LD_INT 0
52986: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52987: LD_VAR 0 14
52991: PUSH
52992: LD_INT 1
52994: ARRAY
52995: PPUSH
52996: CALL_OW 266
53000: PUSH
53001: LD_INT 32
53003: PUSH
53004: LD_INT 31
53006: PUSH
53007: LD_INT 33
53009: PUSH
53010: LD_INT 4
53012: PUSH
53013: LD_INT 5
53015: PUSH
53016: EMPTY
53017: LIST
53018: LIST
53019: LIST
53020: LIST
53021: LIST
53022: IN
53023: IFFALSE 53209
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
53025: LD_ADDR_VAR 0 9
53029: PUSH
53030: LD_VAR 0 14
53034: PUSH
53035: LD_INT 1
53037: ARRAY
53038: PPUSH
53039: CALL_OW 266
53043: PPUSH
53044: LD_VAR 0 14
53048: PUSH
53049: LD_INT 1
53051: ARRAY
53052: PPUSH
53053: CALL_OW 250
53057: PPUSH
53058: LD_VAR 0 14
53062: PUSH
53063: LD_INT 1
53065: ARRAY
53066: PPUSH
53067: CALL_OW 251
53071: PPUSH
53072: LD_VAR 0 14
53076: PUSH
53077: LD_INT 1
53079: ARRAY
53080: PPUSH
53081: CALL_OW 254
53085: PPUSH
53086: LD_VAR 0 14
53090: PUSH
53091: LD_INT 1
53093: ARRAY
53094: PPUSH
53095: CALL_OW 248
53099: PPUSH
53100: LD_INT 0
53102: PPUSH
53103: CALL 29836 0 6
53107: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
53108: LD_ADDR_VAR 0 8
53112: PUSH
53113: LD_VAR 0 4
53117: PUSH
53118: LD_VAR 0 7
53122: ARRAY
53123: PPUSH
53124: LD_VAR 0 9
53128: PPUSH
53129: CALL 48506 0 2
53133: ST_TO_ADDR
// if j then
53134: LD_VAR 0 8
53138: IFFALSE 53207
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
53140: LD_VAR 0 8
53144: PUSH
53145: LD_INT 1
53147: ARRAY
53148: PPUSH
53149: LD_VAR 0 8
53153: PUSH
53154: LD_INT 2
53156: ARRAY
53157: PPUSH
53158: CALL_OW 488
53162: IFFALSE 53207
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
53164: LD_VAR 0 4
53168: PUSH
53169: LD_VAR 0 7
53173: ARRAY
53174: PPUSH
53175: LD_VAR 0 8
53179: PUSH
53180: LD_INT 1
53182: ARRAY
53183: PPUSH
53184: LD_VAR 0 8
53188: PUSH
53189: LD_INT 2
53191: ARRAY
53192: PPUSH
53193: CALL_OW 116
// attacking := true ;
53197: LD_ADDR_VAR 0 29
53201: PUSH
53202: LD_INT 1
53204: ST_TO_ADDR
// continue ;
53205: GO 50580
// end ; end else
53207: GO 53233
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53209: LD_VAR 0 4
53213: PUSH
53214: LD_VAR 0 7
53218: ARRAY
53219: PPUSH
53220: LD_VAR 0 14
53224: PUSH
53225: LD_INT 1
53227: ARRAY
53228: PPUSH
53229: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
53233: LD_VAR 0 4
53237: PUSH
53238: LD_VAR 0 7
53242: ARRAY
53243: PPUSH
53244: CALL_OW 265
53248: PUSH
53249: LD_INT 11
53251: EQUAL
53252: IFFALSE 53530
// begin k := 10 ;
53254: LD_ADDR_VAR 0 9
53258: PUSH
53259: LD_INT 10
53261: ST_TO_ADDR
// x := 0 ;
53262: LD_ADDR_VAR 0 10
53266: PUSH
53267: LD_INT 0
53269: ST_TO_ADDR
// if tmp < k then
53270: LD_VAR 0 14
53274: PUSH
53275: LD_VAR 0 9
53279: LESS
53280: IFFALSE 53292
// k := tmp ;
53282: LD_ADDR_VAR 0 9
53286: PUSH
53287: LD_VAR 0 14
53291: ST_TO_ADDR
// for j = k downto 1 do
53292: LD_ADDR_VAR 0 8
53296: PUSH
53297: DOUBLE
53298: LD_VAR 0 9
53302: INC
53303: ST_TO_ADDR
53304: LD_INT 1
53306: PUSH
53307: FOR_DOWNTO
53308: IFFALSE 53383
// begin if GetType ( tmp [ j ] ) = unit_human then
53310: LD_VAR 0 14
53314: PUSH
53315: LD_VAR 0 8
53319: ARRAY
53320: PPUSH
53321: CALL_OW 247
53325: PUSH
53326: LD_INT 1
53328: EQUAL
53329: IFFALSE 53381
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
53331: LD_VAR 0 4
53335: PUSH
53336: LD_VAR 0 7
53340: ARRAY
53341: PPUSH
53342: LD_VAR 0 14
53346: PUSH
53347: LD_VAR 0 8
53351: ARRAY
53352: PPUSH
53353: CALL 48777 0 2
// x := tmp [ j ] ;
53357: LD_ADDR_VAR 0 10
53361: PUSH
53362: LD_VAR 0 14
53366: PUSH
53367: LD_VAR 0 8
53371: ARRAY
53372: ST_TO_ADDR
// attacking := true ;
53373: LD_ADDR_VAR 0 29
53377: PUSH
53378: LD_INT 1
53380: ST_TO_ADDR
// end ; end ;
53381: GO 53307
53383: POP
53384: POP
// if not x then
53385: LD_VAR 0 10
53389: NOT
53390: IFFALSE 53530
// begin attacking := true ;
53392: LD_ADDR_VAR 0 29
53396: PUSH
53397: LD_INT 1
53399: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
53400: LD_VAR 0 4
53404: PUSH
53405: LD_VAR 0 7
53409: ARRAY
53410: PPUSH
53411: CALL_OW 250
53415: PPUSH
53416: LD_VAR 0 4
53420: PUSH
53421: LD_VAR 0 7
53425: ARRAY
53426: PPUSH
53427: CALL_OW 251
53431: PPUSH
53432: CALL_OW 546
53436: PUSH
53437: LD_INT 2
53439: ARRAY
53440: PUSH
53441: LD_VAR 0 14
53445: PUSH
53446: LD_INT 1
53448: ARRAY
53449: PPUSH
53450: CALL_OW 250
53454: PPUSH
53455: LD_VAR 0 14
53459: PUSH
53460: LD_INT 1
53462: ARRAY
53463: PPUSH
53464: CALL_OW 251
53468: PPUSH
53469: CALL_OW 546
53473: PUSH
53474: LD_INT 2
53476: ARRAY
53477: EQUAL
53478: IFFALSE 53506
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
53480: LD_VAR 0 4
53484: PUSH
53485: LD_VAR 0 7
53489: ARRAY
53490: PPUSH
53491: LD_VAR 0 14
53495: PUSH
53496: LD_INT 1
53498: ARRAY
53499: PPUSH
53500: CALL 48777 0 2
53504: GO 53530
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53506: LD_VAR 0 4
53510: PUSH
53511: LD_VAR 0 7
53515: ARRAY
53516: PPUSH
53517: LD_VAR 0 14
53521: PUSH
53522: LD_INT 1
53524: ARRAY
53525: PPUSH
53526: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
53530: LD_VAR 0 4
53534: PUSH
53535: LD_VAR 0 7
53539: ARRAY
53540: PPUSH
53541: CALL_OW 264
53545: PUSH
53546: LD_INT 29
53548: EQUAL
53549: IFFALSE 53915
// begin if WantsToAttack ( group [ i ] ) in bombed then
53551: LD_VAR 0 4
53555: PUSH
53556: LD_VAR 0 7
53560: ARRAY
53561: PPUSH
53562: CALL_OW 319
53566: PUSH
53567: LD_VAR 0 28
53571: IN
53572: IFFALSE 53576
// continue ;
53574: GO 50580
// k := 8 ;
53576: LD_ADDR_VAR 0 9
53580: PUSH
53581: LD_INT 8
53583: ST_TO_ADDR
// x := 0 ;
53584: LD_ADDR_VAR 0 10
53588: PUSH
53589: LD_INT 0
53591: ST_TO_ADDR
// if tmp < k then
53592: LD_VAR 0 14
53596: PUSH
53597: LD_VAR 0 9
53601: LESS
53602: IFFALSE 53614
// k := tmp ;
53604: LD_ADDR_VAR 0 9
53608: PUSH
53609: LD_VAR 0 14
53613: ST_TO_ADDR
// for j = 1 to k do
53614: LD_ADDR_VAR 0 8
53618: PUSH
53619: DOUBLE
53620: LD_INT 1
53622: DEC
53623: ST_TO_ADDR
53624: LD_VAR 0 9
53628: PUSH
53629: FOR_TO
53630: IFFALSE 53762
// begin if GetType ( tmp [ j ] ) = unit_building then
53632: LD_VAR 0 14
53636: PUSH
53637: LD_VAR 0 8
53641: ARRAY
53642: PPUSH
53643: CALL_OW 247
53647: PUSH
53648: LD_INT 3
53650: EQUAL
53651: IFFALSE 53760
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
53653: LD_VAR 0 14
53657: PUSH
53658: LD_VAR 0 8
53662: ARRAY
53663: PUSH
53664: LD_VAR 0 28
53668: IN
53669: NOT
53670: PUSH
53671: LD_VAR 0 14
53675: PUSH
53676: LD_VAR 0 8
53680: ARRAY
53681: PPUSH
53682: CALL_OW 313
53686: AND
53687: IFFALSE 53760
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53689: LD_VAR 0 4
53693: PUSH
53694: LD_VAR 0 7
53698: ARRAY
53699: PPUSH
53700: LD_VAR 0 14
53704: PUSH
53705: LD_VAR 0 8
53709: ARRAY
53710: PPUSH
53711: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
53715: LD_ADDR_VAR 0 28
53719: PUSH
53720: LD_VAR 0 28
53724: PPUSH
53725: LD_VAR 0 28
53729: PUSH
53730: LD_INT 1
53732: PLUS
53733: PPUSH
53734: LD_VAR 0 14
53738: PUSH
53739: LD_VAR 0 8
53743: ARRAY
53744: PPUSH
53745: CALL_OW 1
53749: ST_TO_ADDR
// attacking := true ;
53750: LD_ADDR_VAR 0 29
53754: PUSH
53755: LD_INT 1
53757: ST_TO_ADDR
// break ;
53758: GO 53762
// end ; end ;
53760: GO 53629
53762: POP
53763: POP
// if not attacking and f_attack_depot then
53764: LD_VAR 0 29
53768: NOT
53769: PUSH
53770: LD_VAR 0 25
53774: AND
53775: IFFALSE 53870
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53777: LD_ADDR_VAR 0 13
53781: PUSH
53782: LD_VAR 0 14
53786: PPUSH
53787: LD_INT 2
53789: PUSH
53790: LD_INT 30
53792: PUSH
53793: LD_INT 0
53795: PUSH
53796: EMPTY
53797: LIST
53798: LIST
53799: PUSH
53800: LD_INT 30
53802: PUSH
53803: LD_INT 1
53805: PUSH
53806: EMPTY
53807: LIST
53808: LIST
53809: PUSH
53810: EMPTY
53811: LIST
53812: LIST
53813: LIST
53814: PPUSH
53815: CALL_OW 72
53819: ST_TO_ADDR
// if z then
53820: LD_VAR 0 13
53824: IFFALSE 53870
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
53826: LD_VAR 0 4
53830: PUSH
53831: LD_VAR 0 7
53835: ARRAY
53836: PPUSH
53837: LD_VAR 0 13
53841: PPUSH
53842: LD_VAR 0 4
53846: PUSH
53847: LD_VAR 0 7
53851: ARRAY
53852: PPUSH
53853: CALL_OW 74
53857: PPUSH
53858: CALL_OW 115
// attacking := true ;
53862: LD_ADDR_VAR 0 29
53866: PUSH
53867: LD_INT 1
53869: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
53870: LD_VAR 0 4
53874: PUSH
53875: LD_VAR 0 7
53879: ARRAY
53880: PPUSH
53881: CALL_OW 256
53885: PUSH
53886: LD_INT 500
53888: LESS
53889: IFFALSE 53915
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53891: LD_VAR 0 4
53895: PUSH
53896: LD_VAR 0 7
53900: ARRAY
53901: PPUSH
53902: LD_VAR 0 14
53906: PUSH
53907: LD_INT 1
53909: ARRAY
53910: PPUSH
53911: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
53915: LD_VAR 0 4
53919: PUSH
53920: LD_VAR 0 7
53924: ARRAY
53925: PPUSH
53926: CALL_OW 264
53930: PUSH
53931: LD_INT 49
53933: EQUAL
53934: IFFALSE 54055
// begin if not HasTask ( group [ i ] ) then
53936: LD_VAR 0 4
53940: PUSH
53941: LD_VAR 0 7
53945: ARRAY
53946: PPUSH
53947: CALL_OW 314
53951: NOT
53952: IFFALSE 54055
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53954: LD_ADDR_VAR 0 9
53958: PUSH
53959: LD_INT 81
53961: PUSH
53962: LD_VAR 0 4
53966: PUSH
53967: LD_VAR 0 7
53971: ARRAY
53972: PPUSH
53973: CALL_OW 255
53977: PUSH
53978: EMPTY
53979: LIST
53980: LIST
53981: PPUSH
53982: CALL_OW 69
53986: PPUSH
53987: LD_VAR 0 4
53991: PUSH
53992: LD_VAR 0 7
53996: ARRAY
53997: PPUSH
53998: CALL_OW 74
54002: ST_TO_ADDR
// if k then
54003: LD_VAR 0 9
54007: IFFALSE 54055
// if GetDistUnits ( group [ i ] , k ) > 10 then
54009: LD_VAR 0 4
54013: PUSH
54014: LD_VAR 0 7
54018: ARRAY
54019: PPUSH
54020: LD_VAR 0 9
54024: PPUSH
54025: CALL_OW 296
54029: PUSH
54030: LD_INT 10
54032: GREATER
54033: IFFALSE 54055
// ComMoveUnit ( group [ i ] , k ) ;
54035: LD_VAR 0 4
54039: PUSH
54040: LD_VAR 0 7
54044: ARRAY
54045: PPUSH
54046: LD_VAR 0 9
54050: PPUSH
54051: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
54055: LD_VAR 0 4
54059: PUSH
54060: LD_VAR 0 7
54064: ARRAY
54065: PPUSH
54066: CALL_OW 256
54070: PUSH
54071: LD_INT 250
54073: LESS
54074: PUSH
54075: LD_VAR 0 4
54079: PUSH
54080: LD_VAR 0 7
54084: ARRAY
54085: PUSH
54086: LD_INT 21
54088: PUSH
54089: LD_INT 2
54091: PUSH
54092: EMPTY
54093: LIST
54094: LIST
54095: PUSH
54096: LD_INT 23
54098: PUSH
54099: LD_INT 2
54101: PUSH
54102: EMPTY
54103: LIST
54104: LIST
54105: PUSH
54106: EMPTY
54107: LIST
54108: LIST
54109: PPUSH
54110: CALL_OW 69
54114: IN
54115: AND
54116: IFFALSE 54241
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
54118: LD_ADDR_VAR 0 9
54122: PUSH
54123: LD_OWVAR 3
54127: PUSH
54128: LD_VAR 0 4
54132: PUSH
54133: LD_VAR 0 7
54137: ARRAY
54138: DIFF
54139: PPUSH
54140: LD_VAR 0 4
54144: PUSH
54145: LD_VAR 0 7
54149: ARRAY
54150: PPUSH
54151: CALL_OW 74
54155: ST_TO_ADDR
// if not k then
54156: LD_VAR 0 9
54160: NOT
54161: IFFALSE 54165
// continue ;
54163: GO 50580
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
54165: LD_VAR 0 9
54169: PUSH
54170: LD_INT 81
54172: PUSH
54173: LD_VAR 0 4
54177: PUSH
54178: LD_VAR 0 7
54182: ARRAY
54183: PPUSH
54184: CALL_OW 255
54188: PUSH
54189: EMPTY
54190: LIST
54191: LIST
54192: PPUSH
54193: CALL_OW 69
54197: IN
54198: PUSH
54199: LD_VAR 0 9
54203: PPUSH
54204: LD_VAR 0 4
54208: PUSH
54209: LD_VAR 0 7
54213: ARRAY
54214: PPUSH
54215: CALL_OW 296
54219: PUSH
54220: LD_INT 5
54222: LESS
54223: AND
54224: IFFALSE 54241
// ComAutodestruct ( group [ i ] ) ;
54226: LD_VAR 0 4
54230: PUSH
54231: LD_VAR 0 7
54235: ARRAY
54236: PPUSH
54237: CALL 48675 0 1
// end ; if f_attack_depot then
54241: LD_VAR 0 25
54245: IFFALSE 54357
// begin k := 6 ;
54247: LD_ADDR_VAR 0 9
54251: PUSH
54252: LD_INT 6
54254: ST_TO_ADDR
// if tmp < k then
54255: LD_VAR 0 14
54259: PUSH
54260: LD_VAR 0 9
54264: LESS
54265: IFFALSE 54277
// k := tmp ;
54267: LD_ADDR_VAR 0 9
54271: PUSH
54272: LD_VAR 0 14
54276: ST_TO_ADDR
// for j = 1 to k do
54277: LD_ADDR_VAR 0 8
54281: PUSH
54282: DOUBLE
54283: LD_INT 1
54285: DEC
54286: ST_TO_ADDR
54287: LD_VAR 0 9
54291: PUSH
54292: FOR_TO
54293: IFFALSE 54355
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
54295: LD_VAR 0 8
54299: PPUSH
54300: CALL_OW 266
54304: PUSH
54305: LD_INT 0
54307: PUSH
54308: LD_INT 1
54310: PUSH
54311: EMPTY
54312: LIST
54313: LIST
54314: IN
54315: IFFALSE 54353
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
54317: LD_VAR 0 4
54321: PUSH
54322: LD_VAR 0 7
54326: ARRAY
54327: PPUSH
54328: LD_VAR 0 14
54332: PUSH
54333: LD_VAR 0 8
54337: ARRAY
54338: PPUSH
54339: CALL_OW 115
// attacking := true ;
54343: LD_ADDR_VAR 0 29
54347: PUSH
54348: LD_INT 1
54350: ST_TO_ADDR
// break ;
54351: GO 54355
// end ;
54353: GO 54292
54355: POP
54356: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
54357: LD_VAR 0 4
54361: PUSH
54362: LD_VAR 0 7
54366: ARRAY
54367: PPUSH
54368: CALL_OW 302
54372: PUSH
54373: LD_VAR 0 29
54377: NOT
54378: AND
54379: IFFALSE 54701
// begin if GetTag ( group [ i ] ) = 71 then
54381: LD_VAR 0 4
54385: PUSH
54386: LD_VAR 0 7
54390: ARRAY
54391: PPUSH
54392: CALL_OW 110
54396: PUSH
54397: LD_INT 71
54399: EQUAL
54400: IFFALSE 54441
// begin if HasTask ( group [ i ] ) then
54402: LD_VAR 0 4
54406: PUSH
54407: LD_VAR 0 7
54411: ARRAY
54412: PPUSH
54413: CALL_OW 314
54417: IFFALSE 54423
// continue else
54419: GO 50580
54421: GO 54441
// SetTag ( group [ i ] , 0 ) ;
54423: LD_VAR 0 4
54427: PUSH
54428: LD_VAR 0 7
54432: ARRAY
54433: PPUSH
54434: LD_INT 0
54436: PPUSH
54437: CALL_OW 109
// end ; k := 8 ;
54441: LD_ADDR_VAR 0 9
54445: PUSH
54446: LD_INT 8
54448: ST_TO_ADDR
// x := 0 ;
54449: LD_ADDR_VAR 0 10
54453: PUSH
54454: LD_INT 0
54456: ST_TO_ADDR
// if tmp < k then
54457: LD_VAR 0 14
54461: PUSH
54462: LD_VAR 0 9
54466: LESS
54467: IFFALSE 54479
// k := tmp ;
54469: LD_ADDR_VAR 0 9
54473: PUSH
54474: LD_VAR 0 14
54478: ST_TO_ADDR
// for j = 1 to k do
54479: LD_ADDR_VAR 0 8
54483: PUSH
54484: DOUBLE
54485: LD_INT 1
54487: DEC
54488: ST_TO_ADDR
54489: LD_VAR 0 9
54493: PUSH
54494: FOR_TO
54495: IFFALSE 54593
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
54497: LD_VAR 0 14
54501: PUSH
54502: LD_VAR 0 8
54506: ARRAY
54507: PPUSH
54508: CALL_OW 247
54512: PUSH
54513: LD_INT 1
54515: EQUAL
54516: PUSH
54517: LD_VAR 0 14
54521: PUSH
54522: LD_VAR 0 8
54526: ARRAY
54527: PPUSH
54528: CALL_OW 256
54532: PUSH
54533: LD_INT 250
54535: LESS
54536: PUSH
54537: LD_VAR 0 20
54541: AND
54542: PUSH
54543: LD_VAR 0 20
54547: NOT
54548: PUSH
54549: LD_VAR 0 14
54553: PUSH
54554: LD_VAR 0 8
54558: ARRAY
54559: PPUSH
54560: CALL_OW 256
54564: PUSH
54565: LD_INT 250
54567: GREATEREQUAL
54568: AND
54569: OR
54570: AND
54571: IFFALSE 54591
// begin x := tmp [ j ] ;
54573: LD_ADDR_VAR 0 10
54577: PUSH
54578: LD_VAR 0 14
54582: PUSH
54583: LD_VAR 0 8
54587: ARRAY
54588: ST_TO_ADDR
// break ;
54589: GO 54593
// end ;
54591: GO 54494
54593: POP
54594: POP
// if x then
54595: LD_VAR 0 10
54599: IFFALSE 54623
// ComAttackUnit ( group [ i ] , x ) else
54601: LD_VAR 0 4
54605: PUSH
54606: LD_VAR 0 7
54610: ARRAY
54611: PPUSH
54612: LD_VAR 0 10
54616: PPUSH
54617: CALL_OW 115
54621: GO 54647
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
54623: LD_VAR 0 4
54627: PUSH
54628: LD_VAR 0 7
54632: ARRAY
54633: PPUSH
54634: LD_VAR 0 14
54638: PUSH
54639: LD_INT 1
54641: ARRAY
54642: PPUSH
54643: CALL_OW 115
// if not HasTask ( group [ i ] ) then
54647: LD_VAR 0 4
54651: PUSH
54652: LD_VAR 0 7
54656: ARRAY
54657: PPUSH
54658: CALL_OW 314
54662: NOT
54663: IFFALSE 54701
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
54665: LD_VAR 0 4
54669: PUSH
54670: LD_VAR 0 7
54674: ARRAY
54675: PPUSH
54676: LD_VAR 0 14
54680: PPUSH
54681: LD_VAR 0 4
54685: PUSH
54686: LD_VAR 0 7
54690: ARRAY
54691: PPUSH
54692: CALL_OW 74
54696: PPUSH
54697: CALL_OW 115
// end ; end ; end ;
54701: GO 50580
54703: POP
54704: POP
// wait ( 0 0$2 ) ;
54705: LD_INT 70
54707: PPUSH
54708: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
54712: LD_VAR 0 4
54716: NOT
54717: PUSH
54718: LD_VAR 0 4
54722: PUSH
54723: EMPTY
54724: EQUAL
54725: OR
54726: PUSH
54727: LD_INT 81
54729: PUSH
54730: LD_VAR 0 35
54734: PUSH
54735: EMPTY
54736: LIST
54737: LIST
54738: PPUSH
54739: CALL_OW 69
54743: NOT
54744: OR
54745: IFFALSE 50565
// end ;
54747: LD_VAR 0 2
54751: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54752: LD_INT 0
54754: PPUSH
54755: PPUSH
54756: PPUSH
54757: PPUSH
// if not base_units then
54758: LD_VAR 0 1
54762: NOT
54763: IFFALSE 54767
// exit ;
54765: GO 54854
// result := false ;
54767: LD_ADDR_VAR 0 2
54771: PUSH
54772: LD_INT 0
54774: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54775: LD_ADDR_VAR 0 5
54779: PUSH
54780: LD_VAR 0 1
54784: PPUSH
54785: LD_INT 21
54787: PUSH
54788: LD_INT 3
54790: PUSH
54791: EMPTY
54792: LIST
54793: LIST
54794: PPUSH
54795: CALL_OW 72
54799: ST_TO_ADDR
// if not tmp then
54800: LD_VAR 0 5
54804: NOT
54805: IFFALSE 54809
// exit ;
54807: GO 54854
// for i in tmp do
54809: LD_ADDR_VAR 0 3
54813: PUSH
54814: LD_VAR 0 5
54818: PUSH
54819: FOR_IN
54820: IFFALSE 54852
// begin result := EnemyInRange ( i , 22 ) ;
54822: LD_ADDR_VAR 0 2
54826: PUSH
54827: LD_VAR 0 3
54831: PPUSH
54832: LD_INT 22
54834: PPUSH
54835: CALL 48381 0 2
54839: ST_TO_ADDR
// if result then
54840: LD_VAR 0 2
54844: IFFALSE 54850
// exit ;
54846: POP
54847: POP
54848: GO 54854
// end ;
54850: GO 54819
54852: POP
54853: POP
// end ;
54854: LD_VAR 0 2
54858: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
54859: LD_INT 0
54861: PPUSH
54862: PPUSH
// if not units then
54863: LD_VAR 0 1
54867: NOT
54868: IFFALSE 54872
// exit ;
54870: GO 54942
// result := [ ] ;
54872: LD_ADDR_VAR 0 3
54876: PUSH
54877: EMPTY
54878: ST_TO_ADDR
// for i in units do
54879: LD_ADDR_VAR 0 4
54883: PUSH
54884: LD_VAR 0 1
54888: PUSH
54889: FOR_IN
54890: IFFALSE 54940
// if GetTag ( i ) = tag then
54892: LD_VAR 0 4
54896: PPUSH
54897: CALL_OW 110
54901: PUSH
54902: LD_VAR 0 2
54906: EQUAL
54907: IFFALSE 54938
// result := Insert ( result , result + 1 , i ) ;
54909: LD_ADDR_VAR 0 3
54913: PUSH
54914: LD_VAR 0 3
54918: PPUSH
54919: LD_VAR 0 3
54923: PUSH
54924: LD_INT 1
54926: PLUS
54927: PPUSH
54928: LD_VAR 0 4
54932: PPUSH
54933: CALL_OW 2
54937: ST_TO_ADDR
54938: GO 54889
54940: POP
54941: POP
// end ;
54942: LD_VAR 0 3
54946: RET
// export function IsDriver ( un ) ; begin
54947: LD_INT 0
54949: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54950: LD_ADDR_VAR 0 2
54954: PUSH
54955: LD_VAR 0 1
54959: PUSH
54960: LD_INT 55
54962: PUSH
54963: EMPTY
54964: LIST
54965: PPUSH
54966: CALL_OW 69
54970: IN
54971: ST_TO_ADDR
// end ;
54972: LD_VAR 0 2
54976: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54977: LD_INT 0
54979: PPUSH
54980: PPUSH
// list := [ ] ;
54981: LD_ADDR_VAR 0 5
54985: PUSH
54986: EMPTY
54987: ST_TO_ADDR
// case d of 0 :
54988: LD_VAR 0 3
54992: PUSH
54993: LD_INT 0
54995: DOUBLE
54996: EQUAL
54997: IFTRUE 55001
54999: GO 55134
55001: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
55002: LD_ADDR_VAR 0 5
55006: PUSH
55007: LD_VAR 0 1
55011: PUSH
55012: LD_INT 4
55014: MINUS
55015: PUSH
55016: LD_VAR 0 2
55020: PUSH
55021: LD_INT 4
55023: MINUS
55024: PUSH
55025: LD_INT 2
55027: PUSH
55028: EMPTY
55029: LIST
55030: LIST
55031: LIST
55032: PUSH
55033: LD_VAR 0 1
55037: PUSH
55038: LD_INT 3
55040: MINUS
55041: PUSH
55042: LD_VAR 0 2
55046: PUSH
55047: LD_INT 1
55049: PUSH
55050: EMPTY
55051: LIST
55052: LIST
55053: LIST
55054: PUSH
55055: LD_VAR 0 1
55059: PUSH
55060: LD_INT 4
55062: PLUS
55063: PUSH
55064: LD_VAR 0 2
55068: PUSH
55069: LD_INT 4
55071: PUSH
55072: EMPTY
55073: LIST
55074: LIST
55075: LIST
55076: PUSH
55077: LD_VAR 0 1
55081: PUSH
55082: LD_INT 3
55084: PLUS
55085: PUSH
55086: LD_VAR 0 2
55090: PUSH
55091: LD_INT 3
55093: PLUS
55094: PUSH
55095: LD_INT 5
55097: PUSH
55098: EMPTY
55099: LIST
55100: LIST
55101: LIST
55102: PUSH
55103: LD_VAR 0 1
55107: PUSH
55108: LD_VAR 0 2
55112: PUSH
55113: LD_INT 4
55115: PLUS
55116: PUSH
55117: LD_INT 0
55119: PUSH
55120: EMPTY
55121: LIST
55122: LIST
55123: LIST
55124: PUSH
55125: EMPTY
55126: LIST
55127: LIST
55128: LIST
55129: LIST
55130: LIST
55131: ST_TO_ADDR
// end ; 1 :
55132: GO 55832
55134: LD_INT 1
55136: DOUBLE
55137: EQUAL
55138: IFTRUE 55142
55140: GO 55275
55142: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55143: LD_ADDR_VAR 0 5
55147: PUSH
55148: LD_VAR 0 1
55152: PUSH
55153: LD_VAR 0 2
55157: PUSH
55158: LD_INT 4
55160: MINUS
55161: PUSH
55162: LD_INT 3
55164: PUSH
55165: EMPTY
55166: LIST
55167: LIST
55168: LIST
55169: PUSH
55170: LD_VAR 0 1
55174: PUSH
55175: LD_INT 3
55177: MINUS
55178: PUSH
55179: LD_VAR 0 2
55183: PUSH
55184: LD_INT 3
55186: MINUS
55187: PUSH
55188: LD_INT 2
55190: PUSH
55191: EMPTY
55192: LIST
55193: LIST
55194: LIST
55195: PUSH
55196: LD_VAR 0 1
55200: PUSH
55201: LD_INT 4
55203: MINUS
55204: PUSH
55205: LD_VAR 0 2
55209: PUSH
55210: LD_INT 1
55212: PUSH
55213: EMPTY
55214: LIST
55215: LIST
55216: LIST
55217: PUSH
55218: LD_VAR 0 1
55222: PUSH
55223: LD_VAR 0 2
55227: PUSH
55228: LD_INT 3
55230: PLUS
55231: PUSH
55232: LD_INT 0
55234: PUSH
55235: EMPTY
55236: LIST
55237: LIST
55238: LIST
55239: PUSH
55240: LD_VAR 0 1
55244: PUSH
55245: LD_INT 4
55247: PLUS
55248: PUSH
55249: LD_VAR 0 2
55253: PUSH
55254: LD_INT 4
55256: PLUS
55257: PUSH
55258: LD_INT 5
55260: PUSH
55261: EMPTY
55262: LIST
55263: LIST
55264: LIST
55265: PUSH
55266: EMPTY
55267: LIST
55268: LIST
55269: LIST
55270: LIST
55271: LIST
55272: ST_TO_ADDR
// end ; 2 :
55273: GO 55832
55275: LD_INT 2
55277: DOUBLE
55278: EQUAL
55279: IFTRUE 55283
55281: GO 55412
55283: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55284: LD_ADDR_VAR 0 5
55288: PUSH
55289: LD_VAR 0 1
55293: PUSH
55294: LD_VAR 0 2
55298: PUSH
55299: LD_INT 3
55301: MINUS
55302: PUSH
55303: LD_INT 3
55305: PUSH
55306: EMPTY
55307: LIST
55308: LIST
55309: LIST
55310: PUSH
55311: LD_VAR 0 1
55315: PUSH
55316: LD_INT 4
55318: PLUS
55319: PUSH
55320: LD_VAR 0 2
55324: PUSH
55325: LD_INT 4
55327: PUSH
55328: EMPTY
55329: LIST
55330: LIST
55331: LIST
55332: PUSH
55333: LD_VAR 0 1
55337: PUSH
55338: LD_VAR 0 2
55342: PUSH
55343: LD_INT 4
55345: PLUS
55346: PUSH
55347: LD_INT 0
55349: PUSH
55350: EMPTY
55351: LIST
55352: LIST
55353: LIST
55354: PUSH
55355: LD_VAR 0 1
55359: PUSH
55360: LD_INT 3
55362: MINUS
55363: PUSH
55364: LD_VAR 0 2
55368: PUSH
55369: LD_INT 1
55371: PUSH
55372: EMPTY
55373: LIST
55374: LIST
55375: LIST
55376: PUSH
55377: LD_VAR 0 1
55381: PUSH
55382: LD_INT 4
55384: MINUS
55385: PUSH
55386: LD_VAR 0 2
55390: PUSH
55391: LD_INT 4
55393: MINUS
55394: PUSH
55395: LD_INT 2
55397: PUSH
55398: EMPTY
55399: LIST
55400: LIST
55401: LIST
55402: PUSH
55403: EMPTY
55404: LIST
55405: LIST
55406: LIST
55407: LIST
55408: LIST
55409: ST_TO_ADDR
// end ; 3 :
55410: GO 55832
55412: LD_INT 3
55414: DOUBLE
55415: EQUAL
55416: IFTRUE 55420
55418: GO 55553
55420: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55421: LD_ADDR_VAR 0 5
55425: PUSH
55426: LD_VAR 0 1
55430: PUSH
55431: LD_INT 3
55433: PLUS
55434: PUSH
55435: LD_VAR 0 2
55439: PUSH
55440: LD_INT 4
55442: PUSH
55443: EMPTY
55444: LIST
55445: LIST
55446: LIST
55447: PUSH
55448: LD_VAR 0 1
55452: PUSH
55453: LD_INT 4
55455: PLUS
55456: PUSH
55457: LD_VAR 0 2
55461: PUSH
55462: LD_INT 4
55464: PLUS
55465: PUSH
55466: LD_INT 5
55468: PUSH
55469: EMPTY
55470: LIST
55471: LIST
55472: LIST
55473: PUSH
55474: LD_VAR 0 1
55478: PUSH
55479: LD_INT 4
55481: MINUS
55482: PUSH
55483: LD_VAR 0 2
55487: PUSH
55488: LD_INT 1
55490: PUSH
55491: EMPTY
55492: LIST
55493: LIST
55494: LIST
55495: PUSH
55496: LD_VAR 0 1
55500: PUSH
55501: LD_VAR 0 2
55505: PUSH
55506: LD_INT 4
55508: MINUS
55509: PUSH
55510: LD_INT 3
55512: PUSH
55513: EMPTY
55514: LIST
55515: LIST
55516: LIST
55517: PUSH
55518: LD_VAR 0 1
55522: PUSH
55523: LD_INT 3
55525: MINUS
55526: PUSH
55527: LD_VAR 0 2
55531: PUSH
55532: LD_INT 3
55534: MINUS
55535: PUSH
55536: LD_INT 2
55538: PUSH
55539: EMPTY
55540: LIST
55541: LIST
55542: LIST
55543: PUSH
55544: EMPTY
55545: LIST
55546: LIST
55547: LIST
55548: LIST
55549: LIST
55550: ST_TO_ADDR
// end ; 4 :
55551: GO 55832
55553: LD_INT 4
55555: DOUBLE
55556: EQUAL
55557: IFTRUE 55561
55559: GO 55694
55561: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55562: LD_ADDR_VAR 0 5
55566: PUSH
55567: LD_VAR 0 1
55571: PUSH
55572: LD_VAR 0 2
55576: PUSH
55577: LD_INT 4
55579: PLUS
55580: PUSH
55581: LD_INT 0
55583: PUSH
55584: EMPTY
55585: LIST
55586: LIST
55587: LIST
55588: PUSH
55589: LD_VAR 0 1
55593: PUSH
55594: LD_INT 3
55596: PLUS
55597: PUSH
55598: LD_VAR 0 2
55602: PUSH
55603: LD_INT 3
55605: PLUS
55606: PUSH
55607: LD_INT 5
55609: PUSH
55610: EMPTY
55611: LIST
55612: LIST
55613: LIST
55614: PUSH
55615: LD_VAR 0 1
55619: PUSH
55620: LD_INT 4
55622: PLUS
55623: PUSH
55624: LD_VAR 0 2
55628: PUSH
55629: LD_INT 4
55631: PUSH
55632: EMPTY
55633: LIST
55634: LIST
55635: LIST
55636: PUSH
55637: LD_VAR 0 1
55641: PUSH
55642: LD_VAR 0 2
55646: PUSH
55647: LD_INT 3
55649: MINUS
55650: PUSH
55651: LD_INT 3
55653: PUSH
55654: EMPTY
55655: LIST
55656: LIST
55657: LIST
55658: PUSH
55659: LD_VAR 0 1
55663: PUSH
55664: LD_INT 4
55666: MINUS
55667: PUSH
55668: LD_VAR 0 2
55672: PUSH
55673: LD_INT 4
55675: MINUS
55676: PUSH
55677: LD_INT 2
55679: PUSH
55680: EMPTY
55681: LIST
55682: LIST
55683: LIST
55684: PUSH
55685: EMPTY
55686: LIST
55687: LIST
55688: LIST
55689: LIST
55690: LIST
55691: ST_TO_ADDR
// end ; 5 :
55692: GO 55832
55694: LD_INT 5
55696: DOUBLE
55697: EQUAL
55698: IFTRUE 55702
55700: GO 55831
55702: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55703: LD_ADDR_VAR 0 5
55707: PUSH
55708: LD_VAR 0 1
55712: PUSH
55713: LD_INT 4
55715: MINUS
55716: PUSH
55717: LD_VAR 0 2
55721: PUSH
55722: LD_INT 1
55724: PUSH
55725: EMPTY
55726: LIST
55727: LIST
55728: LIST
55729: PUSH
55730: LD_VAR 0 1
55734: PUSH
55735: LD_VAR 0 2
55739: PUSH
55740: LD_INT 4
55742: MINUS
55743: PUSH
55744: LD_INT 3
55746: PUSH
55747: EMPTY
55748: LIST
55749: LIST
55750: LIST
55751: PUSH
55752: LD_VAR 0 1
55756: PUSH
55757: LD_INT 4
55759: PLUS
55760: PUSH
55761: LD_VAR 0 2
55765: PUSH
55766: LD_INT 4
55768: PLUS
55769: PUSH
55770: LD_INT 5
55772: PUSH
55773: EMPTY
55774: LIST
55775: LIST
55776: LIST
55777: PUSH
55778: LD_VAR 0 1
55782: PUSH
55783: LD_INT 3
55785: PLUS
55786: PUSH
55787: LD_VAR 0 2
55791: PUSH
55792: LD_INT 4
55794: PUSH
55795: EMPTY
55796: LIST
55797: LIST
55798: LIST
55799: PUSH
55800: LD_VAR 0 1
55804: PUSH
55805: LD_VAR 0 2
55809: PUSH
55810: LD_INT 3
55812: PLUS
55813: PUSH
55814: LD_INT 0
55816: PUSH
55817: EMPTY
55818: LIST
55819: LIST
55820: LIST
55821: PUSH
55822: EMPTY
55823: LIST
55824: LIST
55825: LIST
55826: LIST
55827: LIST
55828: ST_TO_ADDR
// end ; end ;
55829: GO 55832
55831: POP
// result := list ;
55832: LD_ADDR_VAR 0 4
55836: PUSH
55837: LD_VAR 0 5
55841: ST_TO_ADDR
// end ;
55842: LD_VAR 0 4
55846: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55847: LD_INT 0
55849: PPUSH
55850: PPUSH
55851: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55852: LD_VAR 0 1
55856: NOT
55857: PUSH
55858: LD_VAR 0 2
55862: PUSH
55863: LD_INT 1
55865: PUSH
55866: LD_INT 2
55868: PUSH
55869: LD_INT 3
55871: PUSH
55872: LD_INT 4
55874: PUSH
55875: EMPTY
55876: LIST
55877: LIST
55878: LIST
55879: LIST
55880: IN
55881: NOT
55882: OR
55883: IFFALSE 55887
// exit ;
55885: GO 55979
// tmp := [ ] ;
55887: LD_ADDR_VAR 0 5
55891: PUSH
55892: EMPTY
55893: ST_TO_ADDR
// for i in units do
55894: LD_ADDR_VAR 0 4
55898: PUSH
55899: LD_VAR 0 1
55903: PUSH
55904: FOR_IN
55905: IFFALSE 55948
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55907: LD_ADDR_VAR 0 5
55911: PUSH
55912: LD_VAR 0 5
55916: PPUSH
55917: LD_VAR 0 5
55921: PUSH
55922: LD_INT 1
55924: PLUS
55925: PPUSH
55926: LD_VAR 0 4
55930: PPUSH
55931: LD_VAR 0 2
55935: PPUSH
55936: CALL_OW 259
55940: PPUSH
55941: CALL_OW 2
55945: ST_TO_ADDR
55946: GO 55904
55948: POP
55949: POP
// if not tmp then
55950: LD_VAR 0 5
55954: NOT
55955: IFFALSE 55959
// exit ;
55957: GO 55979
// result := SortListByListDesc ( units , tmp ) ;
55959: LD_ADDR_VAR 0 3
55963: PUSH
55964: LD_VAR 0 1
55968: PPUSH
55969: LD_VAR 0 5
55973: PPUSH
55974: CALL_OW 77
55978: ST_TO_ADDR
// end ;
55979: LD_VAR 0 3
55983: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55984: LD_INT 0
55986: PPUSH
55987: PPUSH
55988: PPUSH
// x := GetX ( building ) ;
55989: LD_ADDR_VAR 0 4
55993: PUSH
55994: LD_VAR 0 2
55998: PPUSH
55999: CALL_OW 250
56003: ST_TO_ADDR
// y := GetY ( building ) ;
56004: LD_ADDR_VAR 0 5
56008: PUSH
56009: LD_VAR 0 2
56013: PPUSH
56014: CALL_OW 251
56018: ST_TO_ADDR
// if GetTaskList ( unit ) then
56019: LD_VAR 0 1
56023: PPUSH
56024: CALL_OW 437
56028: IFFALSE 56123
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56030: LD_STRING e
56032: PUSH
56033: LD_VAR 0 1
56037: PPUSH
56038: CALL_OW 437
56042: PUSH
56043: LD_INT 1
56045: ARRAY
56046: PUSH
56047: LD_INT 1
56049: ARRAY
56050: EQUAL
56051: PUSH
56052: LD_VAR 0 4
56056: PUSH
56057: LD_VAR 0 1
56061: PPUSH
56062: CALL_OW 437
56066: PUSH
56067: LD_INT 1
56069: ARRAY
56070: PUSH
56071: LD_INT 2
56073: ARRAY
56074: EQUAL
56075: AND
56076: PUSH
56077: LD_VAR 0 5
56081: PUSH
56082: LD_VAR 0 1
56086: PPUSH
56087: CALL_OW 437
56091: PUSH
56092: LD_INT 1
56094: ARRAY
56095: PUSH
56096: LD_INT 3
56098: ARRAY
56099: EQUAL
56100: AND
56101: IFFALSE 56113
// result := true else
56103: LD_ADDR_VAR 0 3
56107: PUSH
56108: LD_INT 1
56110: ST_TO_ADDR
56111: GO 56121
// result := false ;
56113: LD_ADDR_VAR 0 3
56117: PUSH
56118: LD_INT 0
56120: ST_TO_ADDR
// end else
56121: GO 56131
// result := false ;
56123: LD_ADDR_VAR 0 3
56127: PUSH
56128: LD_INT 0
56130: ST_TO_ADDR
// end ;
56131: LD_VAR 0 3
56135: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
56136: LD_INT 0
56138: PPUSH
56139: PPUSH
56140: PPUSH
56141: PPUSH
// if not unit or not area then
56142: LD_VAR 0 1
56146: NOT
56147: PUSH
56148: LD_VAR 0 2
56152: NOT
56153: OR
56154: IFFALSE 56158
// exit ;
56156: GO 56322
// tmp := AreaToList ( area , i ) ;
56158: LD_ADDR_VAR 0 6
56162: PUSH
56163: LD_VAR 0 2
56167: PPUSH
56168: LD_VAR 0 5
56172: PPUSH
56173: CALL_OW 517
56177: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
56178: LD_ADDR_VAR 0 5
56182: PUSH
56183: DOUBLE
56184: LD_INT 1
56186: DEC
56187: ST_TO_ADDR
56188: LD_VAR 0 6
56192: PUSH
56193: LD_INT 1
56195: ARRAY
56196: PUSH
56197: FOR_TO
56198: IFFALSE 56320
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
56200: LD_ADDR_VAR 0 7
56204: PUSH
56205: LD_VAR 0 6
56209: PUSH
56210: LD_INT 1
56212: ARRAY
56213: PUSH
56214: LD_VAR 0 5
56218: ARRAY
56219: PUSH
56220: LD_VAR 0 6
56224: PUSH
56225: LD_INT 2
56227: ARRAY
56228: PUSH
56229: LD_VAR 0 5
56233: ARRAY
56234: PUSH
56235: EMPTY
56236: LIST
56237: LIST
56238: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
56239: LD_VAR 0 7
56243: PUSH
56244: LD_INT 1
56246: ARRAY
56247: PPUSH
56248: LD_VAR 0 7
56252: PUSH
56253: LD_INT 2
56255: ARRAY
56256: PPUSH
56257: CALL_OW 428
56261: PUSH
56262: LD_INT 0
56264: EQUAL
56265: IFFALSE 56318
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
56267: LD_VAR 0 1
56271: PPUSH
56272: LD_VAR 0 7
56276: PUSH
56277: LD_INT 1
56279: ARRAY
56280: PPUSH
56281: LD_VAR 0 7
56285: PUSH
56286: LD_INT 2
56288: ARRAY
56289: PPUSH
56290: LD_VAR 0 3
56294: PPUSH
56295: CALL_OW 48
// result := IsPlaced ( unit ) ;
56299: LD_ADDR_VAR 0 4
56303: PUSH
56304: LD_VAR 0 1
56308: PPUSH
56309: CALL_OW 305
56313: ST_TO_ADDR
// exit ;
56314: POP
56315: POP
56316: GO 56322
// end ; end ;
56318: GO 56197
56320: POP
56321: POP
// end ;
56322: LD_VAR 0 4
56326: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56327: LD_INT 0
56329: PPUSH
56330: PPUSH
56331: PPUSH
// if not side or side > 8 then
56332: LD_VAR 0 1
56336: NOT
56337: PUSH
56338: LD_VAR 0 1
56342: PUSH
56343: LD_INT 8
56345: GREATER
56346: OR
56347: IFFALSE 56351
// exit ;
56349: GO 56538
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56351: LD_ADDR_VAR 0 4
56355: PUSH
56356: LD_INT 22
56358: PUSH
56359: LD_VAR 0 1
56363: PUSH
56364: EMPTY
56365: LIST
56366: LIST
56367: PUSH
56368: LD_INT 21
56370: PUSH
56371: LD_INT 3
56373: PUSH
56374: EMPTY
56375: LIST
56376: LIST
56377: PUSH
56378: EMPTY
56379: LIST
56380: LIST
56381: PPUSH
56382: CALL_OW 69
56386: ST_TO_ADDR
// if not tmp then
56387: LD_VAR 0 4
56391: NOT
56392: IFFALSE 56396
// exit ;
56394: GO 56538
// enable_addtolog := true ;
56396: LD_ADDR_OWVAR 81
56400: PUSH
56401: LD_INT 1
56403: ST_TO_ADDR
// AddToLog ( [ ) ;
56404: LD_STRING [
56406: PPUSH
56407: CALL_OW 561
// for i in tmp do
56411: LD_ADDR_VAR 0 3
56415: PUSH
56416: LD_VAR 0 4
56420: PUSH
56421: FOR_IN
56422: IFFALSE 56529
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56424: LD_STRING [
56426: PUSH
56427: LD_VAR 0 3
56431: PPUSH
56432: CALL_OW 266
56436: STR
56437: PUSH
56438: LD_STRING , 
56440: STR
56441: PUSH
56442: LD_VAR 0 3
56446: PPUSH
56447: CALL_OW 250
56451: STR
56452: PUSH
56453: LD_STRING , 
56455: STR
56456: PUSH
56457: LD_VAR 0 3
56461: PPUSH
56462: CALL_OW 251
56466: STR
56467: PUSH
56468: LD_STRING , 
56470: STR
56471: PUSH
56472: LD_VAR 0 3
56476: PPUSH
56477: CALL_OW 254
56481: STR
56482: PUSH
56483: LD_STRING , 
56485: STR
56486: PUSH
56487: LD_VAR 0 3
56491: PPUSH
56492: LD_INT 1
56494: PPUSH
56495: CALL_OW 268
56499: STR
56500: PUSH
56501: LD_STRING , 
56503: STR
56504: PUSH
56505: LD_VAR 0 3
56509: PPUSH
56510: LD_INT 2
56512: PPUSH
56513: CALL_OW 268
56517: STR
56518: PUSH
56519: LD_STRING ],
56521: STR
56522: PPUSH
56523: CALL_OW 561
// end ;
56527: GO 56421
56529: POP
56530: POP
// AddToLog ( ]; ) ;
56531: LD_STRING ];
56533: PPUSH
56534: CALL_OW 561
// end ;
56538: LD_VAR 0 2
56542: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56543: LD_INT 0
56545: PPUSH
56546: PPUSH
56547: PPUSH
56548: PPUSH
56549: PPUSH
// if not area or not rate or not max then
56550: LD_VAR 0 1
56554: NOT
56555: PUSH
56556: LD_VAR 0 2
56560: NOT
56561: OR
56562: PUSH
56563: LD_VAR 0 4
56567: NOT
56568: OR
56569: IFFALSE 56573
// exit ;
56571: GO 56765
// while 1 do
56573: LD_INT 1
56575: IFFALSE 56765
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56577: LD_ADDR_VAR 0 9
56581: PUSH
56582: LD_VAR 0 1
56586: PPUSH
56587: LD_INT 1
56589: PPUSH
56590: CALL_OW 287
56594: PUSH
56595: LD_INT 10
56597: MUL
56598: ST_TO_ADDR
// r := rate / 10 ;
56599: LD_ADDR_VAR 0 7
56603: PUSH
56604: LD_VAR 0 2
56608: PUSH
56609: LD_INT 10
56611: DIVREAL
56612: ST_TO_ADDR
// time := 1 1$00 ;
56613: LD_ADDR_VAR 0 8
56617: PUSH
56618: LD_INT 2100
56620: ST_TO_ADDR
// if amount < min then
56621: LD_VAR 0 9
56625: PUSH
56626: LD_VAR 0 3
56630: LESS
56631: IFFALSE 56649
// r := r * 2 else
56633: LD_ADDR_VAR 0 7
56637: PUSH
56638: LD_VAR 0 7
56642: PUSH
56643: LD_INT 2
56645: MUL
56646: ST_TO_ADDR
56647: GO 56675
// if amount > max then
56649: LD_VAR 0 9
56653: PUSH
56654: LD_VAR 0 4
56658: GREATER
56659: IFFALSE 56675
// r := r / 2 ;
56661: LD_ADDR_VAR 0 7
56665: PUSH
56666: LD_VAR 0 7
56670: PUSH
56671: LD_INT 2
56673: DIVREAL
56674: ST_TO_ADDR
// time := time / r ;
56675: LD_ADDR_VAR 0 8
56679: PUSH
56680: LD_VAR 0 8
56684: PUSH
56685: LD_VAR 0 7
56689: DIVREAL
56690: ST_TO_ADDR
// if time < 0 then
56691: LD_VAR 0 8
56695: PUSH
56696: LD_INT 0
56698: LESS
56699: IFFALSE 56716
// time := time * - 1 ;
56701: LD_ADDR_VAR 0 8
56705: PUSH
56706: LD_VAR 0 8
56710: PUSH
56711: LD_INT 1
56713: NEG
56714: MUL
56715: ST_TO_ADDR
// wait ( time ) ;
56716: LD_VAR 0 8
56720: PPUSH
56721: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
56725: LD_INT 35
56727: PPUSH
56728: LD_INT 875
56730: PPUSH
56731: CALL_OW 12
56735: PPUSH
56736: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56740: LD_INT 1
56742: PPUSH
56743: LD_INT 5
56745: PPUSH
56746: CALL_OW 12
56750: PPUSH
56751: LD_VAR 0 1
56755: PPUSH
56756: LD_INT 1
56758: PPUSH
56759: CALL_OW 55
// end ;
56763: GO 56573
// end ;
56765: LD_VAR 0 5
56769: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56770: LD_INT 0
56772: PPUSH
56773: PPUSH
56774: PPUSH
56775: PPUSH
56776: PPUSH
56777: PPUSH
56778: PPUSH
56779: PPUSH
// if not turrets or not factories then
56780: LD_VAR 0 1
56784: NOT
56785: PUSH
56786: LD_VAR 0 2
56790: NOT
56791: OR
56792: IFFALSE 56796
// exit ;
56794: GO 57103
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56796: LD_ADDR_VAR 0 10
56800: PUSH
56801: LD_INT 5
56803: PUSH
56804: LD_INT 6
56806: PUSH
56807: EMPTY
56808: LIST
56809: LIST
56810: PUSH
56811: LD_INT 2
56813: PUSH
56814: LD_INT 4
56816: PUSH
56817: EMPTY
56818: LIST
56819: LIST
56820: PUSH
56821: LD_INT 3
56823: PUSH
56824: LD_INT 5
56826: PUSH
56827: EMPTY
56828: LIST
56829: LIST
56830: PUSH
56831: EMPTY
56832: LIST
56833: LIST
56834: LIST
56835: PUSH
56836: LD_INT 24
56838: PUSH
56839: LD_INT 25
56841: PUSH
56842: EMPTY
56843: LIST
56844: LIST
56845: PUSH
56846: LD_INT 23
56848: PUSH
56849: LD_INT 27
56851: PUSH
56852: EMPTY
56853: LIST
56854: LIST
56855: PUSH
56856: EMPTY
56857: LIST
56858: LIST
56859: PUSH
56860: LD_INT 42
56862: PUSH
56863: LD_INT 43
56865: PUSH
56866: EMPTY
56867: LIST
56868: LIST
56869: PUSH
56870: LD_INT 44
56872: PUSH
56873: LD_INT 46
56875: PUSH
56876: EMPTY
56877: LIST
56878: LIST
56879: PUSH
56880: LD_INT 45
56882: PUSH
56883: LD_INT 47
56885: PUSH
56886: EMPTY
56887: LIST
56888: LIST
56889: PUSH
56890: EMPTY
56891: LIST
56892: LIST
56893: LIST
56894: PUSH
56895: EMPTY
56896: LIST
56897: LIST
56898: LIST
56899: ST_TO_ADDR
// result := [ ] ;
56900: LD_ADDR_VAR 0 3
56904: PUSH
56905: EMPTY
56906: ST_TO_ADDR
// for i in turrets do
56907: LD_ADDR_VAR 0 4
56911: PUSH
56912: LD_VAR 0 1
56916: PUSH
56917: FOR_IN
56918: IFFALSE 57101
// begin nat := GetNation ( i ) ;
56920: LD_ADDR_VAR 0 7
56924: PUSH
56925: LD_VAR 0 4
56929: PPUSH
56930: CALL_OW 248
56934: ST_TO_ADDR
// weapon := 0 ;
56935: LD_ADDR_VAR 0 8
56939: PUSH
56940: LD_INT 0
56942: ST_TO_ADDR
// if not nat then
56943: LD_VAR 0 7
56947: NOT
56948: IFFALSE 56952
// continue ;
56950: GO 56917
// for j in list [ nat ] do
56952: LD_ADDR_VAR 0 5
56956: PUSH
56957: LD_VAR 0 10
56961: PUSH
56962: LD_VAR 0 7
56966: ARRAY
56967: PUSH
56968: FOR_IN
56969: IFFALSE 57010
// if GetBWeapon ( i ) = j [ 1 ] then
56971: LD_VAR 0 4
56975: PPUSH
56976: CALL_OW 269
56980: PUSH
56981: LD_VAR 0 5
56985: PUSH
56986: LD_INT 1
56988: ARRAY
56989: EQUAL
56990: IFFALSE 57008
// begin weapon := j [ 2 ] ;
56992: LD_ADDR_VAR 0 8
56996: PUSH
56997: LD_VAR 0 5
57001: PUSH
57002: LD_INT 2
57004: ARRAY
57005: ST_TO_ADDR
// break ;
57006: GO 57010
// end ;
57008: GO 56968
57010: POP
57011: POP
// if not weapon then
57012: LD_VAR 0 8
57016: NOT
57017: IFFALSE 57021
// continue ;
57019: GO 56917
// for k in factories do
57021: LD_ADDR_VAR 0 6
57025: PUSH
57026: LD_VAR 0 2
57030: PUSH
57031: FOR_IN
57032: IFFALSE 57097
// begin weapons := AvailableWeaponList ( k ) ;
57034: LD_ADDR_VAR 0 9
57038: PUSH
57039: LD_VAR 0 6
57043: PPUSH
57044: CALL_OW 478
57048: ST_TO_ADDR
// if not weapons then
57049: LD_VAR 0 9
57053: NOT
57054: IFFALSE 57058
// continue ;
57056: GO 57031
// if weapon in weapons then
57058: LD_VAR 0 8
57062: PUSH
57063: LD_VAR 0 9
57067: IN
57068: IFFALSE 57095
// begin result := [ i , weapon ] ;
57070: LD_ADDR_VAR 0 3
57074: PUSH
57075: LD_VAR 0 4
57079: PUSH
57080: LD_VAR 0 8
57084: PUSH
57085: EMPTY
57086: LIST
57087: LIST
57088: ST_TO_ADDR
// exit ;
57089: POP
57090: POP
57091: POP
57092: POP
57093: GO 57103
// end ; end ;
57095: GO 57031
57097: POP
57098: POP
// end ;
57099: GO 56917
57101: POP
57102: POP
// end ;
57103: LD_VAR 0 3
57107: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57108: LD_INT 0
57110: PPUSH
// if not side or side > 8 then
57111: LD_VAR 0 3
57115: NOT
57116: PUSH
57117: LD_VAR 0 3
57121: PUSH
57122: LD_INT 8
57124: GREATER
57125: OR
57126: IFFALSE 57130
// exit ;
57128: GO 57189
// if not range then
57130: LD_VAR 0 4
57134: NOT
57135: IFFALSE 57146
// range := - 12 ;
57137: LD_ADDR_VAR 0 4
57141: PUSH
57142: LD_INT 12
57144: NEG
57145: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
57146: LD_VAR 0 1
57150: PPUSH
57151: LD_VAR 0 2
57155: PPUSH
57156: LD_VAR 0 3
57160: PPUSH
57161: LD_VAR 0 4
57165: PPUSH
57166: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
57170: LD_VAR 0 1
57174: PPUSH
57175: LD_VAR 0 2
57179: PPUSH
57180: LD_VAR 0 3
57184: PPUSH
57185: CALL_OW 331
// end ;
57189: LD_VAR 0 5
57193: RET
// export function Video ( mode ) ; begin
57194: LD_INT 0
57196: PPUSH
// ingame_video = mode ;
57197: LD_ADDR_OWVAR 52
57201: PUSH
57202: LD_VAR 0 1
57206: ST_TO_ADDR
// interface_hidden = mode ;
57207: LD_ADDR_OWVAR 54
57211: PUSH
57212: LD_VAR 0 1
57216: ST_TO_ADDR
// end ;
57217: LD_VAR 0 2
57221: RET
// export function Join ( array , element ) ; begin
57222: LD_INT 0
57224: PPUSH
// result := array ^ element ;
57225: LD_ADDR_VAR 0 3
57229: PUSH
57230: LD_VAR 0 1
57234: PUSH
57235: LD_VAR 0 2
57239: ADD
57240: ST_TO_ADDR
// end ;
57241: LD_VAR 0 3
57245: RET
// export function JoinUnion ( array , element ) ; begin
57246: LD_INT 0
57248: PPUSH
// result := array union element ;
57249: LD_ADDR_VAR 0 3
57253: PUSH
57254: LD_VAR 0 1
57258: PUSH
57259: LD_VAR 0 2
57263: UNION
57264: ST_TO_ADDR
// end ;
57265: LD_VAR 0 3
57269: RET
// export function GetBehemoths ( side ) ; begin
57270: LD_INT 0
57272: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
57273: LD_ADDR_VAR 0 2
57277: PUSH
57278: LD_INT 22
57280: PUSH
57281: LD_VAR 0 1
57285: PUSH
57286: EMPTY
57287: LIST
57288: LIST
57289: PUSH
57290: LD_INT 31
57292: PUSH
57293: LD_INT 25
57295: PUSH
57296: EMPTY
57297: LIST
57298: LIST
57299: PUSH
57300: EMPTY
57301: LIST
57302: LIST
57303: PPUSH
57304: CALL_OW 69
57308: ST_TO_ADDR
// end ;
57309: LD_VAR 0 2
57313: RET
// export function Shuffle ( array ) ; var i , index ; begin
57314: LD_INT 0
57316: PPUSH
57317: PPUSH
57318: PPUSH
// result := [ ] ;
57319: LD_ADDR_VAR 0 2
57323: PUSH
57324: EMPTY
57325: ST_TO_ADDR
// if not array then
57326: LD_VAR 0 1
57330: NOT
57331: IFFALSE 57335
// exit ;
57333: GO 57434
// Randomize ;
57335: CALL_OW 10
// for i = array downto 1 do
57339: LD_ADDR_VAR 0 3
57343: PUSH
57344: DOUBLE
57345: LD_VAR 0 1
57349: INC
57350: ST_TO_ADDR
57351: LD_INT 1
57353: PUSH
57354: FOR_DOWNTO
57355: IFFALSE 57432
// begin index := rand ( 1 , array ) ;
57357: LD_ADDR_VAR 0 4
57361: PUSH
57362: LD_INT 1
57364: PPUSH
57365: LD_VAR 0 1
57369: PPUSH
57370: CALL_OW 12
57374: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57375: LD_ADDR_VAR 0 2
57379: PUSH
57380: LD_VAR 0 2
57384: PPUSH
57385: LD_VAR 0 2
57389: PUSH
57390: LD_INT 1
57392: PLUS
57393: PPUSH
57394: LD_VAR 0 1
57398: PUSH
57399: LD_VAR 0 4
57403: ARRAY
57404: PPUSH
57405: CALL_OW 2
57409: ST_TO_ADDR
// array := Delete ( array , index ) ;
57410: LD_ADDR_VAR 0 1
57414: PUSH
57415: LD_VAR 0 1
57419: PPUSH
57420: LD_VAR 0 4
57424: PPUSH
57425: CALL_OW 3
57429: ST_TO_ADDR
// end ;
57430: GO 57354
57432: POP
57433: POP
// end ;
57434: LD_VAR 0 2
57438: RET
// export function GetBaseMaterials ( base ) ; begin
57439: LD_INT 0
57441: PPUSH
// result := [ 0 , 0 , 0 ] ;
57442: LD_ADDR_VAR 0 2
57446: PUSH
57447: LD_INT 0
57449: PUSH
57450: LD_INT 0
57452: PUSH
57453: LD_INT 0
57455: PUSH
57456: EMPTY
57457: LIST
57458: LIST
57459: LIST
57460: ST_TO_ADDR
// if not base then
57461: LD_VAR 0 1
57465: NOT
57466: IFFALSE 57470
// exit ;
57468: GO 57519
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57470: LD_ADDR_VAR 0 2
57474: PUSH
57475: LD_VAR 0 1
57479: PPUSH
57480: LD_INT 1
57482: PPUSH
57483: CALL_OW 275
57487: PUSH
57488: LD_VAR 0 1
57492: PPUSH
57493: LD_INT 2
57495: PPUSH
57496: CALL_OW 275
57500: PUSH
57501: LD_VAR 0 1
57505: PPUSH
57506: LD_INT 3
57508: PPUSH
57509: CALL_OW 275
57513: PUSH
57514: EMPTY
57515: LIST
57516: LIST
57517: LIST
57518: ST_TO_ADDR
// end ; end_of_file
57519: LD_VAR 0 2
57523: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
57524: LD_INT 0
57526: PPUSH
57527: PPUSH
// skirmish := false ;
57528: LD_ADDR_EXP 57
57532: PUSH
57533: LD_INT 0
57535: ST_TO_ADDR
// debug_mc := false ;
57536: LD_ADDR_EXP 58
57540: PUSH
57541: LD_INT 0
57543: ST_TO_ADDR
// mc_bases := [ ] ;
57544: LD_ADDR_EXP 59
57548: PUSH
57549: EMPTY
57550: ST_TO_ADDR
// mc_sides := [ ] ;
57551: LD_ADDR_EXP 85
57555: PUSH
57556: EMPTY
57557: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
57558: LD_ADDR_EXP 60
57562: PUSH
57563: EMPTY
57564: ST_TO_ADDR
// mc_building_repairs := [ ] ;
57565: LD_ADDR_EXP 61
57569: PUSH
57570: EMPTY
57571: ST_TO_ADDR
// mc_need_heal := [ ] ;
57572: LD_ADDR_EXP 62
57576: PUSH
57577: EMPTY
57578: ST_TO_ADDR
// mc_healers := [ ] ;
57579: LD_ADDR_EXP 63
57583: PUSH
57584: EMPTY
57585: ST_TO_ADDR
// mc_build_list := [ ] ;
57586: LD_ADDR_EXP 64
57590: PUSH
57591: EMPTY
57592: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
57593: LD_ADDR_EXP 91
57597: PUSH
57598: EMPTY
57599: ST_TO_ADDR
// mc_builders := [ ] ;
57600: LD_ADDR_EXP 65
57604: PUSH
57605: EMPTY
57606: ST_TO_ADDR
// mc_construct_list := [ ] ;
57607: LD_ADDR_EXP 66
57611: PUSH
57612: EMPTY
57613: ST_TO_ADDR
// mc_turret_list := [ ] ;
57614: LD_ADDR_EXP 67
57618: PUSH
57619: EMPTY
57620: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
57621: LD_ADDR_EXP 68
57625: PUSH
57626: EMPTY
57627: ST_TO_ADDR
// mc_miners := [ ] ;
57628: LD_ADDR_EXP 73
57632: PUSH
57633: EMPTY
57634: ST_TO_ADDR
// mc_mines := [ ] ;
57635: LD_ADDR_EXP 72
57639: PUSH
57640: EMPTY
57641: ST_TO_ADDR
// mc_minefields := [ ] ;
57642: LD_ADDR_EXP 74
57646: PUSH
57647: EMPTY
57648: ST_TO_ADDR
// mc_crates := [ ] ;
57649: LD_ADDR_EXP 75
57653: PUSH
57654: EMPTY
57655: ST_TO_ADDR
// mc_crates_collector := [ ] ;
57656: LD_ADDR_EXP 76
57660: PUSH
57661: EMPTY
57662: ST_TO_ADDR
// mc_crates_area := [ ] ;
57663: LD_ADDR_EXP 77
57667: PUSH
57668: EMPTY
57669: ST_TO_ADDR
// mc_vehicles := [ ] ;
57670: LD_ADDR_EXP 78
57674: PUSH
57675: EMPTY
57676: ST_TO_ADDR
// mc_attack := [ ] ;
57677: LD_ADDR_EXP 79
57681: PUSH
57682: EMPTY
57683: ST_TO_ADDR
// mc_produce := [ ] ;
57684: LD_ADDR_EXP 80
57688: PUSH
57689: EMPTY
57690: ST_TO_ADDR
// mc_defender := [ ] ;
57691: LD_ADDR_EXP 81
57695: PUSH
57696: EMPTY
57697: ST_TO_ADDR
// mc_parking := [ ] ;
57698: LD_ADDR_EXP 83
57702: PUSH
57703: EMPTY
57704: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
57705: LD_ADDR_EXP 69
57709: PUSH
57710: EMPTY
57711: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
57712: LD_ADDR_EXP 71
57716: PUSH
57717: EMPTY
57718: ST_TO_ADDR
// mc_scan := [ ] ;
57719: LD_ADDR_EXP 82
57723: PUSH
57724: EMPTY
57725: ST_TO_ADDR
// mc_scan_area := [ ] ;
57726: LD_ADDR_EXP 84
57730: PUSH
57731: EMPTY
57732: ST_TO_ADDR
// mc_tech := [ ] ;
57733: LD_ADDR_EXP 86
57737: PUSH
57738: EMPTY
57739: ST_TO_ADDR
// mc_class := [ ] ;
57740: LD_ADDR_EXP 100
57744: PUSH
57745: EMPTY
57746: ST_TO_ADDR
// mc_class_case_use := [ ] ;
57747: LD_ADDR_EXP 101
57751: PUSH
57752: EMPTY
57753: ST_TO_ADDR
// end ;
57754: LD_VAR 0 1
57758: RET
// export function MC_Kill ( base ) ; begin
57759: LD_INT 0
57761: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57762: LD_ADDR_EXP 59
57766: PUSH
57767: LD_EXP 59
57771: PPUSH
57772: LD_VAR 0 1
57776: PPUSH
57777: EMPTY
57778: PPUSH
57779: CALL_OW 1
57783: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57784: LD_ADDR_EXP 60
57788: PUSH
57789: LD_EXP 60
57793: PPUSH
57794: LD_VAR 0 1
57798: PPUSH
57799: EMPTY
57800: PPUSH
57801: CALL_OW 1
57805: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57806: LD_ADDR_EXP 61
57810: PUSH
57811: LD_EXP 61
57815: PPUSH
57816: LD_VAR 0 1
57820: PPUSH
57821: EMPTY
57822: PPUSH
57823: CALL_OW 1
57827: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57828: LD_ADDR_EXP 62
57832: PUSH
57833: LD_EXP 62
57837: PPUSH
57838: LD_VAR 0 1
57842: PPUSH
57843: EMPTY
57844: PPUSH
57845: CALL_OW 1
57849: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57850: LD_ADDR_EXP 63
57854: PUSH
57855: LD_EXP 63
57859: PPUSH
57860: LD_VAR 0 1
57864: PPUSH
57865: EMPTY
57866: PPUSH
57867: CALL_OW 1
57871: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57872: LD_ADDR_EXP 64
57876: PUSH
57877: LD_EXP 64
57881: PPUSH
57882: LD_VAR 0 1
57886: PPUSH
57887: EMPTY
57888: PPUSH
57889: CALL_OW 1
57893: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57894: LD_ADDR_EXP 65
57898: PUSH
57899: LD_EXP 65
57903: PPUSH
57904: LD_VAR 0 1
57908: PPUSH
57909: EMPTY
57910: PPUSH
57911: CALL_OW 1
57915: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57916: LD_ADDR_EXP 66
57920: PUSH
57921: LD_EXP 66
57925: PPUSH
57926: LD_VAR 0 1
57930: PPUSH
57931: EMPTY
57932: PPUSH
57933: CALL_OW 1
57937: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57938: LD_ADDR_EXP 67
57942: PUSH
57943: LD_EXP 67
57947: PPUSH
57948: LD_VAR 0 1
57952: PPUSH
57953: EMPTY
57954: PPUSH
57955: CALL_OW 1
57959: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57960: LD_ADDR_EXP 68
57964: PUSH
57965: LD_EXP 68
57969: PPUSH
57970: LD_VAR 0 1
57974: PPUSH
57975: EMPTY
57976: PPUSH
57977: CALL_OW 1
57981: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57982: LD_ADDR_EXP 69
57986: PUSH
57987: LD_EXP 69
57991: PPUSH
57992: LD_VAR 0 1
57996: PPUSH
57997: EMPTY
57998: PPUSH
57999: CALL_OW 1
58003: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58004: LD_ADDR_EXP 70
58008: PUSH
58009: LD_EXP 70
58013: PPUSH
58014: LD_VAR 0 1
58018: PPUSH
58019: LD_INT 0
58021: PPUSH
58022: CALL_OW 1
58026: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58027: LD_ADDR_EXP 71
58031: PUSH
58032: LD_EXP 71
58036: PPUSH
58037: LD_VAR 0 1
58041: PPUSH
58042: EMPTY
58043: PPUSH
58044: CALL_OW 1
58048: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58049: LD_ADDR_EXP 72
58053: PUSH
58054: LD_EXP 72
58058: PPUSH
58059: LD_VAR 0 1
58063: PPUSH
58064: EMPTY
58065: PPUSH
58066: CALL_OW 1
58070: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58071: LD_ADDR_EXP 73
58075: PUSH
58076: LD_EXP 73
58080: PPUSH
58081: LD_VAR 0 1
58085: PPUSH
58086: EMPTY
58087: PPUSH
58088: CALL_OW 1
58092: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58093: LD_ADDR_EXP 74
58097: PUSH
58098: LD_EXP 74
58102: PPUSH
58103: LD_VAR 0 1
58107: PPUSH
58108: EMPTY
58109: PPUSH
58110: CALL_OW 1
58114: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58115: LD_ADDR_EXP 75
58119: PUSH
58120: LD_EXP 75
58124: PPUSH
58125: LD_VAR 0 1
58129: PPUSH
58130: EMPTY
58131: PPUSH
58132: CALL_OW 1
58136: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58137: LD_ADDR_EXP 76
58141: PUSH
58142: LD_EXP 76
58146: PPUSH
58147: LD_VAR 0 1
58151: PPUSH
58152: EMPTY
58153: PPUSH
58154: CALL_OW 1
58158: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58159: LD_ADDR_EXP 77
58163: PUSH
58164: LD_EXP 77
58168: PPUSH
58169: LD_VAR 0 1
58173: PPUSH
58174: EMPTY
58175: PPUSH
58176: CALL_OW 1
58180: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58181: LD_ADDR_EXP 78
58185: PUSH
58186: LD_EXP 78
58190: PPUSH
58191: LD_VAR 0 1
58195: PPUSH
58196: EMPTY
58197: PPUSH
58198: CALL_OW 1
58202: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58203: LD_ADDR_EXP 79
58207: PUSH
58208: LD_EXP 79
58212: PPUSH
58213: LD_VAR 0 1
58217: PPUSH
58218: EMPTY
58219: PPUSH
58220: CALL_OW 1
58224: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58225: LD_ADDR_EXP 80
58229: PUSH
58230: LD_EXP 80
58234: PPUSH
58235: LD_VAR 0 1
58239: PPUSH
58240: EMPTY
58241: PPUSH
58242: CALL_OW 1
58246: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58247: LD_ADDR_EXP 81
58251: PUSH
58252: LD_EXP 81
58256: PPUSH
58257: LD_VAR 0 1
58261: PPUSH
58262: EMPTY
58263: PPUSH
58264: CALL_OW 1
58268: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58269: LD_ADDR_EXP 82
58273: PUSH
58274: LD_EXP 82
58278: PPUSH
58279: LD_VAR 0 1
58283: PPUSH
58284: EMPTY
58285: PPUSH
58286: CALL_OW 1
58290: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58291: LD_ADDR_EXP 83
58295: PUSH
58296: LD_EXP 83
58300: PPUSH
58301: LD_VAR 0 1
58305: PPUSH
58306: EMPTY
58307: PPUSH
58308: CALL_OW 1
58312: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58313: LD_ADDR_EXP 84
58317: PUSH
58318: LD_EXP 84
58322: PPUSH
58323: LD_VAR 0 1
58327: PPUSH
58328: EMPTY
58329: PPUSH
58330: CALL_OW 1
58334: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58335: LD_ADDR_EXP 86
58339: PUSH
58340: LD_EXP 86
58344: PPUSH
58345: LD_VAR 0 1
58349: PPUSH
58350: EMPTY
58351: PPUSH
58352: CALL_OW 1
58356: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58357: LD_ADDR_EXP 88
58361: PUSH
58362: LD_EXP 88
58366: PPUSH
58367: LD_VAR 0 1
58371: PPUSH
58372: EMPTY
58373: PPUSH
58374: CALL_OW 1
58378: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58379: LD_ADDR_EXP 89
58383: PUSH
58384: LD_EXP 89
58388: PPUSH
58389: LD_VAR 0 1
58393: PPUSH
58394: EMPTY
58395: PPUSH
58396: CALL_OW 1
58400: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58401: LD_ADDR_EXP 90
58405: PUSH
58406: LD_EXP 90
58410: PPUSH
58411: LD_VAR 0 1
58415: PPUSH
58416: EMPTY
58417: PPUSH
58418: CALL_OW 1
58422: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58423: LD_ADDR_EXP 91
58427: PUSH
58428: LD_EXP 91
58432: PPUSH
58433: LD_VAR 0 1
58437: PPUSH
58438: EMPTY
58439: PPUSH
58440: CALL_OW 1
58444: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58445: LD_ADDR_EXP 92
58449: PUSH
58450: LD_EXP 92
58454: PPUSH
58455: LD_VAR 0 1
58459: PPUSH
58460: EMPTY
58461: PPUSH
58462: CALL_OW 1
58466: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58467: LD_ADDR_EXP 93
58471: PUSH
58472: LD_EXP 93
58476: PPUSH
58477: LD_VAR 0 1
58481: PPUSH
58482: EMPTY
58483: PPUSH
58484: CALL_OW 1
58488: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58489: LD_ADDR_EXP 94
58493: PUSH
58494: LD_EXP 94
58498: PPUSH
58499: LD_VAR 0 1
58503: PPUSH
58504: EMPTY
58505: PPUSH
58506: CALL_OW 1
58510: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58511: LD_ADDR_EXP 95
58515: PUSH
58516: LD_EXP 95
58520: PPUSH
58521: LD_VAR 0 1
58525: PPUSH
58526: EMPTY
58527: PPUSH
58528: CALL_OW 1
58532: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58533: LD_ADDR_EXP 96
58537: PUSH
58538: LD_EXP 96
58542: PPUSH
58543: LD_VAR 0 1
58547: PPUSH
58548: EMPTY
58549: PPUSH
58550: CALL_OW 1
58554: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58555: LD_ADDR_EXP 97
58559: PUSH
58560: LD_EXP 97
58564: PPUSH
58565: LD_VAR 0 1
58569: PPUSH
58570: EMPTY
58571: PPUSH
58572: CALL_OW 1
58576: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58577: LD_ADDR_EXP 98
58581: PUSH
58582: LD_EXP 98
58586: PPUSH
58587: LD_VAR 0 1
58591: PPUSH
58592: EMPTY
58593: PPUSH
58594: CALL_OW 1
58598: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58599: LD_ADDR_EXP 99
58603: PUSH
58604: LD_EXP 99
58608: PPUSH
58609: LD_VAR 0 1
58613: PPUSH
58614: EMPTY
58615: PPUSH
58616: CALL_OW 1
58620: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58621: LD_ADDR_EXP 100
58625: PUSH
58626: LD_EXP 100
58630: PPUSH
58631: LD_VAR 0 1
58635: PPUSH
58636: EMPTY
58637: PPUSH
58638: CALL_OW 1
58642: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58643: LD_ADDR_EXP 101
58647: PUSH
58648: LD_EXP 101
58652: PPUSH
58653: LD_VAR 0 1
58657: PPUSH
58658: LD_INT 0
58660: PPUSH
58661: CALL_OW 1
58665: ST_TO_ADDR
// end ;
58666: LD_VAR 0 2
58670: RET
// export function MC_Add ( side , units ) ; var base ; begin
58671: LD_INT 0
58673: PPUSH
58674: PPUSH
// base := mc_bases + 1 ;
58675: LD_ADDR_VAR 0 4
58679: PUSH
58680: LD_EXP 59
58684: PUSH
58685: LD_INT 1
58687: PLUS
58688: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
58689: LD_ADDR_EXP 85
58693: PUSH
58694: LD_EXP 85
58698: PPUSH
58699: LD_VAR 0 4
58703: PPUSH
58704: LD_VAR 0 1
58708: PPUSH
58709: CALL_OW 1
58713: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
58714: LD_ADDR_EXP 59
58718: PUSH
58719: LD_EXP 59
58723: PPUSH
58724: LD_VAR 0 4
58728: PPUSH
58729: LD_VAR 0 2
58733: PPUSH
58734: CALL_OW 1
58738: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58739: LD_ADDR_EXP 60
58743: PUSH
58744: LD_EXP 60
58748: PPUSH
58749: LD_VAR 0 4
58753: PPUSH
58754: EMPTY
58755: PPUSH
58756: CALL_OW 1
58760: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58761: LD_ADDR_EXP 61
58765: PUSH
58766: LD_EXP 61
58770: PPUSH
58771: LD_VAR 0 4
58775: PPUSH
58776: EMPTY
58777: PPUSH
58778: CALL_OW 1
58782: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58783: LD_ADDR_EXP 62
58787: PUSH
58788: LD_EXP 62
58792: PPUSH
58793: LD_VAR 0 4
58797: PPUSH
58798: EMPTY
58799: PPUSH
58800: CALL_OW 1
58804: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58805: LD_ADDR_EXP 63
58809: PUSH
58810: LD_EXP 63
58814: PPUSH
58815: LD_VAR 0 4
58819: PPUSH
58820: EMPTY
58821: PPUSH
58822: CALL_OW 1
58826: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58827: LD_ADDR_EXP 64
58831: PUSH
58832: LD_EXP 64
58836: PPUSH
58837: LD_VAR 0 4
58841: PPUSH
58842: EMPTY
58843: PPUSH
58844: CALL_OW 1
58848: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58849: LD_ADDR_EXP 65
58853: PUSH
58854: LD_EXP 65
58858: PPUSH
58859: LD_VAR 0 4
58863: PPUSH
58864: EMPTY
58865: PPUSH
58866: CALL_OW 1
58870: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58871: LD_ADDR_EXP 66
58875: PUSH
58876: LD_EXP 66
58880: PPUSH
58881: LD_VAR 0 4
58885: PPUSH
58886: EMPTY
58887: PPUSH
58888: CALL_OW 1
58892: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58893: LD_ADDR_EXP 67
58897: PUSH
58898: LD_EXP 67
58902: PPUSH
58903: LD_VAR 0 4
58907: PPUSH
58908: EMPTY
58909: PPUSH
58910: CALL_OW 1
58914: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58915: LD_ADDR_EXP 68
58919: PUSH
58920: LD_EXP 68
58924: PPUSH
58925: LD_VAR 0 4
58929: PPUSH
58930: EMPTY
58931: PPUSH
58932: CALL_OW 1
58936: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58937: LD_ADDR_EXP 69
58941: PUSH
58942: LD_EXP 69
58946: PPUSH
58947: LD_VAR 0 4
58951: PPUSH
58952: EMPTY
58953: PPUSH
58954: CALL_OW 1
58958: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58959: LD_ADDR_EXP 70
58963: PUSH
58964: LD_EXP 70
58968: PPUSH
58969: LD_VAR 0 4
58973: PPUSH
58974: LD_INT 0
58976: PPUSH
58977: CALL_OW 1
58981: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58982: LD_ADDR_EXP 71
58986: PUSH
58987: LD_EXP 71
58991: PPUSH
58992: LD_VAR 0 4
58996: PPUSH
58997: EMPTY
58998: PPUSH
58999: CALL_OW 1
59003: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
59004: LD_ADDR_EXP 72
59008: PUSH
59009: LD_EXP 72
59013: PPUSH
59014: LD_VAR 0 4
59018: PPUSH
59019: EMPTY
59020: PPUSH
59021: CALL_OW 1
59025: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
59026: LD_ADDR_EXP 73
59030: PUSH
59031: LD_EXP 73
59035: PPUSH
59036: LD_VAR 0 4
59040: PPUSH
59041: EMPTY
59042: PPUSH
59043: CALL_OW 1
59047: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
59048: LD_ADDR_EXP 74
59052: PUSH
59053: LD_EXP 74
59057: PPUSH
59058: LD_VAR 0 4
59062: PPUSH
59063: EMPTY
59064: PPUSH
59065: CALL_OW 1
59069: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
59070: LD_ADDR_EXP 75
59074: PUSH
59075: LD_EXP 75
59079: PPUSH
59080: LD_VAR 0 4
59084: PPUSH
59085: EMPTY
59086: PPUSH
59087: CALL_OW 1
59091: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
59092: LD_ADDR_EXP 76
59096: PUSH
59097: LD_EXP 76
59101: PPUSH
59102: LD_VAR 0 4
59106: PPUSH
59107: EMPTY
59108: PPUSH
59109: CALL_OW 1
59113: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
59114: LD_ADDR_EXP 77
59118: PUSH
59119: LD_EXP 77
59123: PPUSH
59124: LD_VAR 0 4
59128: PPUSH
59129: EMPTY
59130: PPUSH
59131: CALL_OW 1
59135: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
59136: LD_ADDR_EXP 78
59140: PUSH
59141: LD_EXP 78
59145: PPUSH
59146: LD_VAR 0 4
59150: PPUSH
59151: EMPTY
59152: PPUSH
59153: CALL_OW 1
59157: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
59158: LD_ADDR_EXP 79
59162: PUSH
59163: LD_EXP 79
59167: PPUSH
59168: LD_VAR 0 4
59172: PPUSH
59173: EMPTY
59174: PPUSH
59175: CALL_OW 1
59179: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
59180: LD_ADDR_EXP 80
59184: PUSH
59185: LD_EXP 80
59189: PPUSH
59190: LD_VAR 0 4
59194: PPUSH
59195: EMPTY
59196: PPUSH
59197: CALL_OW 1
59201: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
59202: LD_ADDR_EXP 81
59206: PUSH
59207: LD_EXP 81
59211: PPUSH
59212: LD_VAR 0 4
59216: PPUSH
59217: EMPTY
59218: PPUSH
59219: CALL_OW 1
59223: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
59224: LD_ADDR_EXP 82
59228: PUSH
59229: LD_EXP 82
59233: PPUSH
59234: LD_VAR 0 4
59238: PPUSH
59239: EMPTY
59240: PPUSH
59241: CALL_OW 1
59245: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
59246: LD_ADDR_EXP 83
59250: PUSH
59251: LD_EXP 83
59255: PPUSH
59256: LD_VAR 0 4
59260: PPUSH
59261: EMPTY
59262: PPUSH
59263: CALL_OW 1
59267: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
59268: LD_ADDR_EXP 84
59272: PUSH
59273: LD_EXP 84
59277: PPUSH
59278: LD_VAR 0 4
59282: PPUSH
59283: EMPTY
59284: PPUSH
59285: CALL_OW 1
59289: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
59290: LD_ADDR_EXP 86
59294: PUSH
59295: LD_EXP 86
59299: PPUSH
59300: LD_VAR 0 4
59304: PPUSH
59305: EMPTY
59306: PPUSH
59307: CALL_OW 1
59311: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
59312: LD_ADDR_EXP 88
59316: PUSH
59317: LD_EXP 88
59321: PPUSH
59322: LD_VAR 0 4
59326: PPUSH
59327: EMPTY
59328: PPUSH
59329: CALL_OW 1
59333: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
59334: LD_ADDR_EXP 89
59338: PUSH
59339: LD_EXP 89
59343: PPUSH
59344: LD_VAR 0 4
59348: PPUSH
59349: EMPTY
59350: PPUSH
59351: CALL_OW 1
59355: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
59356: LD_ADDR_EXP 90
59360: PUSH
59361: LD_EXP 90
59365: PPUSH
59366: LD_VAR 0 4
59370: PPUSH
59371: EMPTY
59372: PPUSH
59373: CALL_OW 1
59377: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
59378: LD_ADDR_EXP 91
59382: PUSH
59383: LD_EXP 91
59387: PPUSH
59388: LD_VAR 0 4
59392: PPUSH
59393: EMPTY
59394: PPUSH
59395: CALL_OW 1
59399: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
59400: LD_ADDR_EXP 92
59404: PUSH
59405: LD_EXP 92
59409: PPUSH
59410: LD_VAR 0 4
59414: PPUSH
59415: EMPTY
59416: PPUSH
59417: CALL_OW 1
59421: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
59422: LD_ADDR_EXP 93
59426: PUSH
59427: LD_EXP 93
59431: PPUSH
59432: LD_VAR 0 4
59436: PPUSH
59437: EMPTY
59438: PPUSH
59439: CALL_OW 1
59443: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
59444: LD_ADDR_EXP 94
59448: PUSH
59449: LD_EXP 94
59453: PPUSH
59454: LD_VAR 0 4
59458: PPUSH
59459: EMPTY
59460: PPUSH
59461: CALL_OW 1
59465: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
59466: LD_ADDR_EXP 95
59470: PUSH
59471: LD_EXP 95
59475: PPUSH
59476: LD_VAR 0 4
59480: PPUSH
59481: EMPTY
59482: PPUSH
59483: CALL_OW 1
59487: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
59488: LD_ADDR_EXP 96
59492: PUSH
59493: LD_EXP 96
59497: PPUSH
59498: LD_VAR 0 4
59502: PPUSH
59503: EMPTY
59504: PPUSH
59505: CALL_OW 1
59509: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
59510: LD_ADDR_EXP 97
59514: PUSH
59515: LD_EXP 97
59519: PPUSH
59520: LD_VAR 0 4
59524: PPUSH
59525: EMPTY
59526: PPUSH
59527: CALL_OW 1
59531: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
59532: LD_ADDR_EXP 98
59536: PUSH
59537: LD_EXP 98
59541: PPUSH
59542: LD_VAR 0 4
59546: PPUSH
59547: EMPTY
59548: PPUSH
59549: CALL_OW 1
59553: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59554: LD_ADDR_EXP 99
59558: PUSH
59559: LD_EXP 99
59563: PPUSH
59564: LD_VAR 0 4
59568: PPUSH
59569: EMPTY
59570: PPUSH
59571: CALL_OW 1
59575: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59576: LD_ADDR_EXP 100
59580: PUSH
59581: LD_EXP 100
59585: PPUSH
59586: LD_VAR 0 4
59590: PPUSH
59591: EMPTY
59592: PPUSH
59593: CALL_OW 1
59597: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59598: LD_ADDR_EXP 101
59602: PUSH
59603: LD_EXP 101
59607: PPUSH
59608: LD_VAR 0 4
59612: PPUSH
59613: LD_INT 0
59615: PPUSH
59616: CALL_OW 1
59620: ST_TO_ADDR
// result := base ;
59621: LD_ADDR_VAR 0 3
59625: PUSH
59626: LD_VAR 0 4
59630: ST_TO_ADDR
// end ;
59631: LD_VAR 0 3
59635: RET
// export function MC_Start ( ) ; var i ; begin
59636: LD_INT 0
59638: PPUSH
59639: PPUSH
// for i = 1 to mc_bases do
59640: LD_ADDR_VAR 0 2
59644: PUSH
59645: DOUBLE
59646: LD_INT 1
59648: DEC
59649: ST_TO_ADDR
59650: LD_EXP 59
59654: PUSH
59655: FOR_TO
59656: IFFALSE 60733
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
59658: LD_ADDR_EXP 59
59662: PUSH
59663: LD_EXP 59
59667: PPUSH
59668: LD_VAR 0 2
59672: PPUSH
59673: LD_EXP 59
59677: PUSH
59678: LD_VAR 0 2
59682: ARRAY
59683: PUSH
59684: LD_INT 0
59686: DIFF
59687: PPUSH
59688: CALL_OW 1
59692: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
59693: LD_ADDR_EXP 60
59697: PUSH
59698: LD_EXP 60
59702: PPUSH
59703: LD_VAR 0 2
59707: PPUSH
59708: EMPTY
59709: PPUSH
59710: CALL_OW 1
59714: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59715: LD_ADDR_EXP 61
59719: PUSH
59720: LD_EXP 61
59724: PPUSH
59725: LD_VAR 0 2
59729: PPUSH
59730: EMPTY
59731: PPUSH
59732: CALL_OW 1
59736: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
59737: LD_ADDR_EXP 62
59741: PUSH
59742: LD_EXP 62
59746: PPUSH
59747: LD_VAR 0 2
59751: PPUSH
59752: EMPTY
59753: PPUSH
59754: CALL_OW 1
59758: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
59759: LD_ADDR_EXP 63
59763: PUSH
59764: LD_EXP 63
59768: PPUSH
59769: LD_VAR 0 2
59773: PPUSH
59774: EMPTY
59775: PUSH
59776: EMPTY
59777: PUSH
59778: EMPTY
59779: LIST
59780: LIST
59781: PPUSH
59782: CALL_OW 1
59786: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59787: LD_ADDR_EXP 64
59791: PUSH
59792: LD_EXP 64
59796: PPUSH
59797: LD_VAR 0 2
59801: PPUSH
59802: EMPTY
59803: PPUSH
59804: CALL_OW 1
59808: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59809: LD_ADDR_EXP 91
59813: PUSH
59814: LD_EXP 91
59818: PPUSH
59819: LD_VAR 0 2
59823: PPUSH
59824: EMPTY
59825: PPUSH
59826: CALL_OW 1
59830: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59831: LD_ADDR_EXP 65
59835: PUSH
59836: LD_EXP 65
59840: PPUSH
59841: LD_VAR 0 2
59845: PPUSH
59846: EMPTY
59847: PPUSH
59848: CALL_OW 1
59852: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59853: LD_ADDR_EXP 66
59857: PUSH
59858: LD_EXP 66
59862: PPUSH
59863: LD_VAR 0 2
59867: PPUSH
59868: EMPTY
59869: PPUSH
59870: CALL_OW 1
59874: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59875: LD_ADDR_EXP 67
59879: PUSH
59880: LD_EXP 67
59884: PPUSH
59885: LD_VAR 0 2
59889: PPUSH
59890: LD_EXP 59
59894: PUSH
59895: LD_VAR 0 2
59899: ARRAY
59900: PPUSH
59901: LD_INT 2
59903: PUSH
59904: LD_INT 30
59906: PUSH
59907: LD_INT 32
59909: PUSH
59910: EMPTY
59911: LIST
59912: LIST
59913: PUSH
59914: LD_INT 30
59916: PUSH
59917: LD_INT 33
59919: PUSH
59920: EMPTY
59921: LIST
59922: LIST
59923: PUSH
59924: EMPTY
59925: LIST
59926: LIST
59927: LIST
59928: PPUSH
59929: CALL_OW 72
59933: PPUSH
59934: CALL_OW 1
59938: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59939: LD_ADDR_EXP 68
59943: PUSH
59944: LD_EXP 68
59948: PPUSH
59949: LD_VAR 0 2
59953: PPUSH
59954: LD_EXP 59
59958: PUSH
59959: LD_VAR 0 2
59963: ARRAY
59964: PPUSH
59965: LD_INT 2
59967: PUSH
59968: LD_INT 30
59970: PUSH
59971: LD_INT 32
59973: PUSH
59974: EMPTY
59975: LIST
59976: LIST
59977: PUSH
59978: LD_INT 30
59980: PUSH
59981: LD_INT 31
59983: PUSH
59984: EMPTY
59985: LIST
59986: LIST
59987: PUSH
59988: EMPTY
59989: LIST
59990: LIST
59991: LIST
59992: PUSH
59993: LD_INT 58
59995: PUSH
59996: EMPTY
59997: LIST
59998: PUSH
59999: EMPTY
60000: LIST
60001: LIST
60002: PPUSH
60003: CALL_OW 72
60007: PPUSH
60008: CALL_OW 1
60012: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
60013: LD_ADDR_EXP 69
60017: PUSH
60018: LD_EXP 69
60022: PPUSH
60023: LD_VAR 0 2
60027: PPUSH
60028: EMPTY
60029: PPUSH
60030: CALL_OW 1
60034: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
60035: LD_ADDR_EXP 73
60039: PUSH
60040: LD_EXP 73
60044: PPUSH
60045: LD_VAR 0 2
60049: PPUSH
60050: EMPTY
60051: PPUSH
60052: CALL_OW 1
60056: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
60057: LD_ADDR_EXP 72
60061: PUSH
60062: LD_EXP 72
60066: PPUSH
60067: LD_VAR 0 2
60071: PPUSH
60072: EMPTY
60073: PPUSH
60074: CALL_OW 1
60078: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
60079: LD_ADDR_EXP 74
60083: PUSH
60084: LD_EXP 74
60088: PPUSH
60089: LD_VAR 0 2
60093: PPUSH
60094: EMPTY
60095: PPUSH
60096: CALL_OW 1
60100: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
60101: LD_ADDR_EXP 75
60105: PUSH
60106: LD_EXP 75
60110: PPUSH
60111: LD_VAR 0 2
60115: PPUSH
60116: EMPTY
60117: PPUSH
60118: CALL_OW 1
60122: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60123: LD_ADDR_EXP 76
60127: PUSH
60128: LD_EXP 76
60132: PPUSH
60133: LD_VAR 0 2
60137: PPUSH
60138: EMPTY
60139: PPUSH
60140: CALL_OW 1
60144: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
60145: LD_ADDR_EXP 77
60149: PUSH
60150: LD_EXP 77
60154: PPUSH
60155: LD_VAR 0 2
60159: PPUSH
60160: EMPTY
60161: PPUSH
60162: CALL_OW 1
60166: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
60167: LD_ADDR_EXP 78
60171: PUSH
60172: LD_EXP 78
60176: PPUSH
60177: LD_VAR 0 2
60181: PPUSH
60182: EMPTY
60183: PPUSH
60184: CALL_OW 1
60188: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
60189: LD_ADDR_EXP 79
60193: PUSH
60194: LD_EXP 79
60198: PPUSH
60199: LD_VAR 0 2
60203: PPUSH
60204: EMPTY
60205: PPUSH
60206: CALL_OW 1
60210: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
60211: LD_ADDR_EXP 80
60215: PUSH
60216: LD_EXP 80
60220: PPUSH
60221: LD_VAR 0 2
60225: PPUSH
60226: EMPTY
60227: PPUSH
60228: CALL_OW 1
60232: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
60233: LD_ADDR_EXP 81
60237: PUSH
60238: LD_EXP 81
60242: PPUSH
60243: LD_VAR 0 2
60247: PPUSH
60248: EMPTY
60249: PPUSH
60250: CALL_OW 1
60254: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
60255: LD_ADDR_EXP 70
60259: PUSH
60260: LD_EXP 70
60264: PPUSH
60265: LD_VAR 0 2
60269: PPUSH
60270: LD_INT 0
60272: PPUSH
60273: CALL_OW 1
60277: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
60278: LD_ADDR_EXP 83
60282: PUSH
60283: LD_EXP 83
60287: PPUSH
60288: LD_VAR 0 2
60292: PPUSH
60293: LD_INT 0
60295: PPUSH
60296: CALL_OW 1
60300: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
60301: LD_ADDR_EXP 71
60305: PUSH
60306: LD_EXP 71
60310: PPUSH
60311: LD_VAR 0 2
60315: PPUSH
60316: EMPTY
60317: PPUSH
60318: CALL_OW 1
60322: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
60323: LD_ADDR_EXP 82
60327: PUSH
60328: LD_EXP 82
60332: PPUSH
60333: LD_VAR 0 2
60337: PPUSH
60338: LD_INT 0
60340: PPUSH
60341: CALL_OW 1
60345: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
60346: LD_ADDR_EXP 84
60350: PUSH
60351: LD_EXP 84
60355: PPUSH
60356: LD_VAR 0 2
60360: PPUSH
60361: EMPTY
60362: PPUSH
60363: CALL_OW 1
60367: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
60368: LD_ADDR_EXP 87
60372: PUSH
60373: LD_EXP 87
60377: PPUSH
60378: LD_VAR 0 2
60382: PPUSH
60383: LD_INT 0
60385: PPUSH
60386: CALL_OW 1
60390: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
60391: LD_ADDR_EXP 88
60395: PUSH
60396: LD_EXP 88
60400: PPUSH
60401: LD_VAR 0 2
60405: PPUSH
60406: EMPTY
60407: PPUSH
60408: CALL_OW 1
60412: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60413: LD_ADDR_EXP 89
60417: PUSH
60418: LD_EXP 89
60422: PPUSH
60423: LD_VAR 0 2
60427: PPUSH
60428: EMPTY
60429: PPUSH
60430: CALL_OW 1
60434: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60435: LD_ADDR_EXP 90
60439: PUSH
60440: LD_EXP 90
60444: PPUSH
60445: LD_VAR 0 2
60449: PPUSH
60450: EMPTY
60451: PPUSH
60452: CALL_OW 1
60456: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
60457: LD_ADDR_EXP 92
60461: PUSH
60462: LD_EXP 92
60466: PPUSH
60467: LD_VAR 0 2
60471: PPUSH
60472: LD_EXP 59
60476: PUSH
60477: LD_VAR 0 2
60481: ARRAY
60482: PPUSH
60483: LD_INT 2
60485: PUSH
60486: LD_INT 30
60488: PUSH
60489: LD_INT 6
60491: PUSH
60492: EMPTY
60493: LIST
60494: LIST
60495: PUSH
60496: LD_INT 30
60498: PUSH
60499: LD_INT 7
60501: PUSH
60502: EMPTY
60503: LIST
60504: LIST
60505: PUSH
60506: LD_INT 30
60508: PUSH
60509: LD_INT 8
60511: PUSH
60512: EMPTY
60513: LIST
60514: LIST
60515: PUSH
60516: EMPTY
60517: LIST
60518: LIST
60519: LIST
60520: LIST
60521: PPUSH
60522: CALL_OW 72
60526: PPUSH
60527: CALL_OW 1
60531: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
60532: LD_ADDR_EXP 93
60536: PUSH
60537: LD_EXP 93
60541: PPUSH
60542: LD_VAR 0 2
60546: PPUSH
60547: EMPTY
60548: PPUSH
60549: CALL_OW 1
60553: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
60554: LD_ADDR_EXP 94
60558: PUSH
60559: LD_EXP 94
60563: PPUSH
60564: LD_VAR 0 2
60568: PPUSH
60569: EMPTY
60570: PPUSH
60571: CALL_OW 1
60575: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
60576: LD_ADDR_EXP 95
60580: PUSH
60581: LD_EXP 95
60585: PPUSH
60586: LD_VAR 0 2
60590: PPUSH
60591: EMPTY
60592: PPUSH
60593: CALL_OW 1
60597: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
60598: LD_ADDR_EXP 96
60602: PUSH
60603: LD_EXP 96
60607: PPUSH
60608: LD_VAR 0 2
60612: PPUSH
60613: EMPTY
60614: PPUSH
60615: CALL_OW 1
60619: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60620: LD_ADDR_EXP 97
60624: PUSH
60625: LD_EXP 97
60629: PPUSH
60630: LD_VAR 0 2
60634: PPUSH
60635: EMPTY
60636: PPUSH
60637: CALL_OW 1
60641: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
60642: LD_ADDR_EXP 98
60646: PUSH
60647: LD_EXP 98
60651: PPUSH
60652: LD_VAR 0 2
60656: PPUSH
60657: EMPTY
60658: PPUSH
60659: CALL_OW 1
60663: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
60664: LD_ADDR_EXP 99
60668: PUSH
60669: LD_EXP 99
60673: PPUSH
60674: LD_VAR 0 2
60678: PPUSH
60679: EMPTY
60680: PPUSH
60681: CALL_OW 1
60685: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
60686: LD_ADDR_EXP 100
60690: PUSH
60691: LD_EXP 100
60695: PPUSH
60696: LD_VAR 0 2
60700: PPUSH
60701: EMPTY
60702: PPUSH
60703: CALL_OW 1
60707: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
60708: LD_ADDR_EXP 101
60712: PUSH
60713: LD_EXP 101
60717: PPUSH
60718: LD_VAR 0 2
60722: PPUSH
60723: LD_INT 0
60725: PPUSH
60726: CALL_OW 1
60730: ST_TO_ADDR
// end ;
60731: GO 59655
60733: POP
60734: POP
// MC_InitSides ( ) ;
60735: CALL 61021 0 0
// MC_InitResearch ( ) ;
60739: CALL 60760 0 0
// CustomInitMacro ( ) ;
60743: CALL 181 0 0
// skirmish := true ;
60747: LD_ADDR_EXP 57
60751: PUSH
60752: LD_INT 1
60754: ST_TO_ADDR
// end ;
60755: LD_VAR 0 1
60759: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60760: LD_INT 0
60762: PPUSH
60763: PPUSH
60764: PPUSH
60765: PPUSH
60766: PPUSH
60767: PPUSH
// if not mc_bases then
60768: LD_EXP 59
60772: NOT
60773: IFFALSE 60777
// exit ;
60775: GO 61016
// for i = 1 to 8 do
60777: LD_ADDR_VAR 0 2
60781: PUSH
60782: DOUBLE
60783: LD_INT 1
60785: DEC
60786: ST_TO_ADDR
60787: LD_INT 8
60789: PUSH
60790: FOR_TO
60791: IFFALSE 60817
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60793: LD_ADDR_EXP 86
60797: PUSH
60798: LD_EXP 86
60802: PPUSH
60803: LD_VAR 0 2
60807: PPUSH
60808: EMPTY
60809: PPUSH
60810: CALL_OW 1
60814: ST_TO_ADDR
60815: GO 60790
60817: POP
60818: POP
// tmp := [ ] ;
60819: LD_ADDR_VAR 0 5
60823: PUSH
60824: EMPTY
60825: ST_TO_ADDR
// for i = 1 to mc_sides do
60826: LD_ADDR_VAR 0 2
60830: PUSH
60831: DOUBLE
60832: LD_INT 1
60834: DEC
60835: ST_TO_ADDR
60836: LD_EXP 85
60840: PUSH
60841: FOR_TO
60842: IFFALSE 60900
// if not mc_sides [ i ] in tmp then
60844: LD_EXP 85
60848: PUSH
60849: LD_VAR 0 2
60853: ARRAY
60854: PUSH
60855: LD_VAR 0 5
60859: IN
60860: NOT
60861: IFFALSE 60898
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60863: LD_ADDR_VAR 0 5
60867: PUSH
60868: LD_VAR 0 5
60872: PPUSH
60873: LD_VAR 0 5
60877: PUSH
60878: LD_INT 1
60880: PLUS
60881: PPUSH
60882: LD_EXP 85
60886: PUSH
60887: LD_VAR 0 2
60891: ARRAY
60892: PPUSH
60893: CALL_OW 2
60897: ST_TO_ADDR
60898: GO 60841
60900: POP
60901: POP
// if not tmp then
60902: LD_VAR 0 5
60906: NOT
60907: IFFALSE 60911
// exit ;
60909: GO 61016
// for j in tmp do
60911: LD_ADDR_VAR 0 3
60915: PUSH
60916: LD_VAR 0 5
60920: PUSH
60921: FOR_IN
60922: IFFALSE 61014
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60924: LD_ADDR_VAR 0 6
60928: PUSH
60929: LD_INT 22
60931: PUSH
60932: LD_VAR 0 3
60936: PUSH
60937: EMPTY
60938: LIST
60939: LIST
60940: PPUSH
60941: CALL_OW 69
60945: ST_TO_ADDR
// if not un then
60946: LD_VAR 0 6
60950: NOT
60951: IFFALSE 60955
// continue ;
60953: GO 60921
// nation := GetNation ( un [ 1 ] ) ;
60955: LD_ADDR_VAR 0 4
60959: PUSH
60960: LD_VAR 0 6
60964: PUSH
60965: LD_INT 1
60967: ARRAY
60968: PPUSH
60969: CALL_OW 248
60973: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60974: LD_ADDR_EXP 86
60978: PUSH
60979: LD_EXP 86
60983: PPUSH
60984: LD_VAR 0 3
60988: PPUSH
60989: LD_VAR 0 3
60993: PPUSH
60994: LD_VAR 0 4
60998: PPUSH
60999: LD_INT 1
61001: PPUSH
61002: CALL 14355 0 3
61006: PPUSH
61007: CALL_OW 1
61011: ST_TO_ADDR
// end ;
61012: GO 60921
61014: POP
61015: POP
// end ;
61016: LD_VAR 0 1
61020: RET
// export function MC_InitSides ( ) ; var i ; begin
61021: LD_INT 0
61023: PPUSH
61024: PPUSH
// if not mc_bases then
61025: LD_EXP 59
61029: NOT
61030: IFFALSE 61034
// exit ;
61032: GO 61108
// for i = 1 to mc_bases do
61034: LD_ADDR_VAR 0 2
61038: PUSH
61039: DOUBLE
61040: LD_INT 1
61042: DEC
61043: ST_TO_ADDR
61044: LD_EXP 59
61048: PUSH
61049: FOR_TO
61050: IFFALSE 61106
// if mc_bases [ i ] then
61052: LD_EXP 59
61056: PUSH
61057: LD_VAR 0 2
61061: ARRAY
61062: IFFALSE 61104
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
61064: LD_ADDR_EXP 85
61068: PUSH
61069: LD_EXP 85
61073: PPUSH
61074: LD_VAR 0 2
61078: PPUSH
61079: LD_EXP 59
61083: PUSH
61084: LD_VAR 0 2
61088: ARRAY
61089: PUSH
61090: LD_INT 1
61092: ARRAY
61093: PPUSH
61094: CALL_OW 255
61098: PPUSH
61099: CALL_OW 1
61103: ST_TO_ADDR
61104: GO 61049
61106: POP
61107: POP
// end ;
61108: LD_VAR 0 1
61112: RET
// every 0 0$01 trigger skirmish do
61113: LD_EXP 57
61117: IFFALSE 61271
61119: GO 61121
61121: DISABLE
// begin enable ;
61122: ENABLE
// MC_CheckBuildings ( ) ;
61123: CALL 65769 0 0
// MC_CheckPeopleLife ( ) ;
61127: CALL 65894 0 0
// RaiseSailEvent ( 100 ) ;
61131: LD_INT 100
61133: PPUSH
61134: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
61138: LD_INT 103
61140: PPUSH
61141: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
61145: LD_INT 104
61147: PPUSH
61148: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
61152: LD_INT 105
61154: PPUSH
61155: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
61159: LD_INT 106
61161: PPUSH
61162: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
61166: LD_INT 107
61168: PPUSH
61169: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
61173: LD_INT 108
61175: PPUSH
61176: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
61180: LD_INT 109
61182: PPUSH
61183: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
61187: LD_INT 110
61189: PPUSH
61190: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
61194: LD_INT 111
61196: PPUSH
61197: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
61201: LD_INT 112
61203: PPUSH
61204: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
61208: LD_INT 113
61210: PPUSH
61211: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
61215: LD_INT 120
61217: PPUSH
61218: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
61222: LD_INT 121
61224: PPUSH
61225: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
61229: LD_INT 122
61231: PPUSH
61232: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
61236: LD_INT 123
61238: PPUSH
61239: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
61243: LD_INT 124
61245: PPUSH
61246: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
61250: LD_INT 125
61252: PPUSH
61253: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
61257: LD_INT 126
61259: PPUSH
61260: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
61264: LD_INT 200
61266: PPUSH
61267: CALL_OW 427
// end ;
61271: END
// on SailEvent ( event ) do begin if event < 100 then
61272: LD_VAR 0 1
61276: PUSH
61277: LD_INT 100
61279: LESS
61280: IFFALSE 61291
// CustomEvent ( event ) ;
61282: LD_VAR 0 1
61286: PPUSH
61287: CALL 13013 0 1
// if event = 100 then
61291: LD_VAR 0 1
61295: PUSH
61296: LD_INT 100
61298: EQUAL
61299: IFFALSE 61305
// MC_ClassManager ( ) ;
61301: CALL 61697 0 0
// if event = 101 then
61305: LD_VAR 0 1
61309: PUSH
61310: LD_INT 101
61312: EQUAL
61313: IFFALSE 61319
// MC_RepairBuildings ( ) ;
61315: CALL 66490 0 0
// if event = 102 then
61319: LD_VAR 0 1
61323: PUSH
61324: LD_INT 102
61326: EQUAL
61327: IFFALSE 61333
// MC_Heal ( ) ;
61329: CALL 67354 0 0
// if event = 103 then
61333: LD_VAR 0 1
61337: PUSH
61338: LD_INT 103
61340: EQUAL
61341: IFFALSE 61347
// MC_Build ( ) ;
61343: CALL 67776 0 0
// if event = 104 then
61347: LD_VAR 0 1
61351: PUSH
61352: LD_INT 104
61354: EQUAL
61355: IFFALSE 61361
// MC_TurretWeapon ( ) ;
61357: CALL 69389 0 0
// if event = 105 then
61361: LD_VAR 0 1
61365: PUSH
61366: LD_INT 105
61368: EQUAL
61369: IFFALSE 61375
// MC_BuildUpgrade ( ) ;
61371: CALL 68940 0 0
// if event = 106 then
61375: LD_VAR 0 1
61379: PUSH
61380: LD_INT 106
61382: EQUAL
61383: IFFALSE 61389
// MC_PlantMines ( ) ;
61385: CALL 69819 0 0
// if event = 107 then
61389: LD_VAR 0 1
61393: PUSH
61394: LD_INT 107
61396: EQUAL
61397: IFFALSE 61403
// MC_CollectCrates ( ) ;
61399: CALL 70617 0 0
// if event = 108 then
61403: LD_VAR 0 1
61407: PUSH
61408: LD_INT 108
61410: EQUAL
61411: IFFALSE 61417
// MC_LinkRemoteControl ( ) ;
61413: CALL 72393 0 0
// if event = 109 then
61417: LD_VAR 0 1
61421: PUSH
61422: LD_INT 109
61424: EQUAL
61425: IFFALSE 61431
// MC_ProduceVehicle ( ) ;
61427: CALL 72574 0 0
// if event = 110 then
61431: LD_VAR 0 1
61435: PUSH
61436: LD_INT 110
61438: EQUAL
61439: IFFALSE 61445
// MC_SendAttack ( ) ;
61441: CALL 73040 0 0
// if event = 111 then
61445: LD_VAR 0 1
61449: PUSH
61450: LD_INT 111
61452: EQUAL
61453: IFFALSE 61459
// MC_Defend ( ) ;
61455: CALL 73148 0 0
// if event = 112 then
61459: LD_VAR 0 1
61463: PUSH
61464: LD_INT 112
61466: EQUAL
61467: IFFALSE 61473
// MC_Research ( ) ;
61469: CALL 73753 0 0
// if event = 113 then
61473: LD_VAR 0 1
61477: PUSH
61478: LD_INT 113
61480: EQUAL
61481: IFFALSE 61487
// MC_MinesTrigger ( ) ;
61483: CALL 74867 0 0
// if event = 120 then
61487: LD_VAR 0 1
61491: PUSH
61492: LD_INT 120
61494: EQUAL
61495: IFFALSE 61501
// MC_RepairVehicle ( ) ;
61497: CALL 74966 0 0
// if event = 121 then
61501: LD_VAR 0 1
61505: PUSH
61506: LD_INT 121
61508: EQUAL
61509: IFFALSE 61515
// MC_TameApe ( ) ;
61511: CALL 75696 0 0
// if event = 122 then
61515: LD_VAR 0 1
61519: PUSH
61520: LD_INT 122
61522: EQUAL
61523: IFFALSE 61529
// MC_ChangeApeClass ( ) ;
61525: CALL 76525 0 0
// if event = 123 then
61529: LD_VAR 0 1
61533: PUSH
61534: LD_INT 123
61536: EQUAL
61537: IFFALSE 61543
// MC_Bazooka ( ) ;
61539: CALL 77175 0 0
// if event = 124 then
61543: LD_VAR 0 1
61547: PUSH
61548: LD_INT 124
61550: EQUAL
61551: IFFALSE 61557
// MC_TeleportExit ( ) ;
61553: CALL 77373 0 0
// if event = 125 then
61557: LD_VAR 0 1
61561: PUSH
61562: LD_INT 125
61564: EQUAL
61565: IFFALSE 61571
// MC_Deposits ( ) ;
61567: CALL 78020 0 0
// if event = 126 then
61571: LD_VAR 0 1
61575: PUSH
61576: LD_INT 126
61578: EQUAL
61579: IFFALSE 61585
// MC_RemoteDriver ( ) ;
61581: CALL 78645 0 0
// if event = 200 then
61585: LD_VAR 0 1
61589: PUSH
61590: LD_INT 200
61592: EQUAL
61593: IFFALSE 61599
// MC_Idle ( ) ;
61595: CALL 80594 0 0
// end ;
61599: PPOPN 1
61601: END
// export function MC_Reset ( base , tag ) ; var i ; begin
61602: LD_INT 0
61604: PPUSH
61605: PPUSH
// if not mc_bases [ base ] or not tag then
61606: LD_EXP 59
61610: PUSH
61611: LD_VAR 0 1
61615: ARRAY
61616: NOT
61617: PUSH
61618: LD_VAR 0 2
61622: NOT
61623: OR
61624: IFFALSE 61628
// exit ;
61626: GO 61692
// for i in mc_bases [ base ] union mc_ape [ base ] do
61628: LD_ADDR_VAR 0 4
61632: PUSH
61633: LD_EXP 59
61637: PUSH
61638: LD_VAR 0 1
61642: ARRAY
61643: PUSH
61644: LD_EXP 88
61648: PUSH
61649: LD_VAR 0 1
61653: ARRAY
61654: UNION
61655: PUSH
61656: FOR_IN
61657: IFFALSE 61690
// if GetTag ( i ) = tag then
61659: LD_VAR 0 4
61663: PPUSH
61664: CALL_OW 110
61668: PUSH
61669: LD_VAR 0 2
61673: EQUAL
61674: IFFALSE 61688
// SetTag ( i , 0 ) ;
61676: LD_VAR 0 4
61680: PPUSH
61681: LD_INT 0
61683: PPUSH
61684: CALL_OW 109
61688: GO 61656
61690: POP
61691: POP
// end ;
61692: LD_VAR 0 3
61696: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
61697: LD_INT 0
61699: PPUSH
61700: PPUSH
61701: PPUSH
61702: PPUSH
61703: PPUSH
61704: PPUSH
61705: PPUSH
61706: PPUSH
// if not mc_bases then
61707: LD_EXP 59
61711: NOT
61712: IFFALSE 61716
// exit ;
61714: GO 62174
// for i = 1 to mc_bases do
61716: LD_ADDR_VAR 0 2
61720: PUSH
61721: DOUBLE
61722: LD_INT 1
61724: DEC
61725: ST_TO_ADDR
61726: LD_EXP 59
61730: PUSH
61731: FOR_TO
61732: IFFALSE 62172
// begin tmp := MC_ClassCheckReq ( i ) ;
61734: LD_ADDR_VAR 0 4
61738: PUSH
61739: LD_VAR 0 2
61743: PPUSH
61744: CALL 62179 0 1
61748: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
61749: LD_ADDR_EXP 100
61753: PUSH
61754: LD_EXP 100
61758: PPUSH
61759: LD_VAR 0 2
61763: PPUSH
61764: LD_VAR 0 4
61768: PPUSH
61769: CALL_OW 1
61773: ST_TO_ADDR
// if not tmp then
61774: LD_VAR 0 4
61778: NOT
61779: IFFALSE 61783
// continue ;
61781: GO 61731
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61783: LD_ADDR_VAR 0 6
61787: PUSH
61788: LD_EXP 59
61792: PUSH
61793: LD_VAR 0 2
61797: ARRAY
61798: PPUSH
61799: LD_INT 2
61801: PUSH
61802: LD_INT 30
61804: PUSH
61805: LD_INT 4
61807: PUSH
61808: EMPTY
61809: LIST
61810: LIST
61811: PUSH
61812: LD_INT 30
61814: PUSH
61815: LD_INT 5
61817: PUSH
61818: EMPTY
61819: LIST
61820: LIST
61821: PUSH
61822: EMPTY
61823: LIST
61824: LIST
61825: LIST
61826: PPUSH
61827: CALL_OW 72
61831: PUSH
61832: LD_EXP 59
61836: PUSH
61837: LD_VAR 0 2
61841: ARRAY
61842: PPUSH
61843: LD_INT 2
61845: PUSH
61846: LD_INT 30
61848: PUSH
61849: LD_INT 0
61851: PUSH
61852: EMPTY
61853: LIST
61854: LIST
61855: PUSH
61856: LD_INT 30
61858: PUSH
61859: LD_INT 1
61861: PUSH
61862: EMPTY
61863: LIST
61864: LIST
61865: PUSH
61866: EMPTY
61867: LIST
61868: LIST
61869: LIST
61870: PPUSH
61871: CALL_OW 72
61875: PUSH
61876: LD_EXP 59
61880: PUSH
61881: LD_VAR 0 2
61885: ARRAY
61886: PPUSH
61887: LD_INT 30
61889: PUSH
61890: LD_INT 3
61892: PUSH
61893: EMPTY
61894: LIST
61895: LIST
61896: PPUSH
61897: CALL_OW 72
61901: PUSH
61902: LD_EXP 59
61906: PUSH
61907: LD_VAR 0 2
61911: ARRAY
61912: PPUSH
61913: LD_INT 2
61915: PUSH
61916: LD_INT 30
61918: PUSH
61919: LD_INT 6
61921: PUSH
61922: EMPTY
61923: LIST
61924: LIST
61925: PUSH
61926: LD_INT 30
61928: PUSH
61929: LD_INT 7
61931: PUSH
61932: EMPTY
61933: LIST
61934: LIST
61935: PUSH
61936: LD_INT 30
61938: PUSH
61939: LD_INT 8
61941: PUSH
61942: EMPTY
61943: LIST
61944: LIST
61945: PUSH
61946: EMPTY
61947: LIST
61948: LIST
61949: LIST
61950: LIST
61951: PPUSH
61952: CALL_OW 72
61956: PUSH
61957: EMPTY
61958: LIST
61959: LIST
61960: LIST
61961: LIST
61962: ST_TO_ADDR
// for j = 1 to 4 do
61963: LD_ADDR_VAR 0 3
61967: PUSH
61968: DOUBLE
61969: LD_INT 1
61971: DEC
61972: ST_TO_ADDR
61973: LD_INT 4
61975: PUSH
61976: FOR_TO
61977: IFFALSE 62168
// begin if not tmp [ j ] then
61979: LD_VAR 0 4
61983: PUSH
61984: LD_VAR 0 3
61988: ARRAY
61989: NOT
61990: IFFALSE 61994
// continue ;
61992: GO 61976
// for p in tmp [ j ] do
61994: LD_ADDR_VAR 0 5
61998: PUSH
61999: LD_VAR 0 4
62003: PUSH
62004: LD_VAR 0 3
62008: ARRAY
62009: PUSH
62010: FOR_IN
62011: IFFALSE 62164
// begin if not b [ j ] then
62013: LD_VAR 0 6
62017: PUSH
62018: LD_VAR 0 3
62022: ARRAY
62023: NOT
62024: IFFALSE 62028
// break ;
62026: GO 62164
// e := 0 ;
62028: LD_ADDR_VAR 0 7
62032: PUSH
62033: LD_INT 0
62035: ST_TO_ADDR
// for k in b [ j ] do
62036: LD_ADDR_VAR 0 8
62040: PUSH
62041: LD_VAR 0 6
62045: PUSH
62046: LD_VAR 0 3
62050: ARRAY
62051: PUSH
62052: FOR_IN
62053: IFFALSE 62080
// if IsNotFull ( k ) then
62055: LD_VAR 0 8
62059: PPUSH
62060: CALL 18855 0 1
62064: IFFALSE 62078
// begin e := k ;
62066: LD_ADDR_VAR 0 7
62070: PUSH
62071: LD_VAR 0 8
62075: ST_TO_ADDR
// break ;
62076: GO 62080
// end ;
62078: GO 62052
62080: POP
62081: POP
// if e and not UnitGoingToBuilding ( p , e ) then
62082: LD_VAR 0 7
62086: PUSH
62087: LD_VAR 0 5
62091: PPUSH
62092: LD_VAR 0 7
62096: PPUSH
62097: CALL 55984 0 2
62101: NOT
62102: AND
62103: IFFALSE 62162
// begin if IsInUnit ( p ) then
62105: LD_VAR 0 5
62109: PPUSH
62110: CALL_OW 310
62114: IFFALSE 62125
// ComExitBuilding ( p ) ;
62116: LD_VAR 0 5
62120: PPUSH
62121: CALL_OW 122
// ComEnterUnit ( p , e ) ;
62125: LD_VAR 0 5
62129: PPUSH
62130: LD_VAR 0 7
62134: PPUSH
62135: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
62139: LD_VAR 0 5
62143: PPUSH
62144: LD_VAR 0 3
62148: PPUSH
62149: CALL_OW 183
// AddComExitBuilding ( p ) ;
62153: LD_VAR 0 5
62157: PPUSH
62158: CALL_OW 182
// end ; end ;
62162: GO 62010
62164: POP
62165: POP
// end ;
62166: GO 61976
62168: POP
62169: POP
// end ;
62170: GO 61731
62172: POP
62173: POP
// end ;
62174: LD_VAR 0 1
62178: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
62179: LD_INT 0
62181: PPUSH
62182: PPUSH
62183: PPUSH
62184: PPUSH
62185: PPUSH
62186: PPUSH
62187: PPUSH
62188: PPUSH
62189: PPUSH
62190: PPUSH
62191: PPUSH
62192: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62193: LD_VAR 0 1
62197: NOT
62198: PUSH
62199: LD_EXP 59
62203: PUSH
62204: LD_VAR 0 1
62208: ARRAY
62209: NOT
62210: OR
62211: PUSH
62212: LD_EXP 59
62216: PUSH
62217: LD_VAR 0 1
62221: ARRAY
62222: PPUSH
62223: LD_INT 2
62225: PUSH
62226: LD_INT 30
62228: PUSH
62229: LD_INT 0
62231: PUSH
62232: EMPTY
62233: LIST
62234: LIST
62235: PUSH
62236: LD_INT 30
62238: PUSH
62239: LD_INT 1
62241: PUSH
62242: EMPTY
62243: LIST
62244: LIST
62245: PUSH
62246: EMPTY
62247: LIST
62248: LIST
62249: LIST
62250: PPUSH
62251: CALL_OW 72
62255: NOT
62256: OR
62257: IFFALSE 62261
// exit ;
62259: GO 65764
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62261: LD_ADDR_VAR 0 4
62265: PUSH
62266: LD_EXP 59
62270: PUSH
62271: LD_VAR 0 1
62275: ARRAY
62276: PPUSH
62277: LD_INT 2
62279: PUSH
62280: LD_INT 25
62282: PUSH
62283: LD_INT 1
62285: PUSH
62286: EMPTY
62287: LIST
62288: LIST
62289: PUSH
62290: LD_INT 25
62292: PUSH
62293: LD_INT 2
62295: PUSH
62296: EMPTY
62297: LIST
62298: LIST
62299: PUSH
62300: LD_INT 25
62302: PUSH
62303: LD_INT 3
62305: PUSH
62306: EMPTY
62307: LIST
62308: LIST
62309: PUSH
62310: LD_INT 25
62312: PUSH
62313: LD_INT 4
62315: PUSH
62316: EMPTY
62317: LIST
62318: LIST
62319: PUSH
62320: LD_INT 25
62322: PUSH
62323: LD_INT 5
62325: PUSH
62326: EMPTY
62327: LIST
62328: LIST
62329: PUSH
62330: LD_INT 25
62332: PUSH
62333: LD_INT 8
62335: PUSH
62336: EMPTY
62337: LIST
62338: LIST
62339: PUSH
62340: LD_INT 25
62342: PUSH
62343: LD_INT 9
62345: PUSH
62346: EMPTY
62347: LIST
62348: LIST
62349: PUSH
62350: EMPTY
62351: LIST
62352: LIST
62353: LIST
62354: LIST
62355: LIST
62356: LIST
62357: LIST
62358: LIST
62359: PPUSH
62360: CALL_OW 72
62364: ST_TO_ADDR
// if not tmp then
62365: LD_VAR 0 4
62369: NOT
62370: IFFALSE 62374
// exit ;
62372: GO 65764
// for i in tmp do
62374: LD_ADDR_VAR 0 3
62378: PUSH
62379: LD_VAR 0 4
62383: PUSH
62384: FOR_IN
62385: IFFALSE 62416
// if GetTag ( i ) then
62387: LD_VAR 0 3
62391: PPUSH
62392: CALL_OW 110
62396: IFFALSE 62414
// tmp := tmp diff i ;
62398: LD_ADDR_VAR 0 4
62402: PUSH
62403: LD_VAR 0 4
62407: PUSH
62408: LD_VAR 0 3
62412: DIFF
62413: ST_TO_ADDR
62414: GO 62384
62416: POP
62417: POP
// if not tmp then
62418: LD_VAR 0 4
62422: NOT
62423: IFFALSE 62427
// exit ;
62425: GO 65764
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62427: LD_ADDR_VAR 0 5
62431: PUSH
62432: LD_EXP 59
62436: PUSH
62437: LD_VAR 0 1
62441: ARRAY
62442: PPUSH
62443: LD_INT 2
62445: PUSH
62446: LD_INT 25
62448: PUSH
62449: LD_INT 1
62451: PUSH
62452: EMPTY
62453: LIST
62454: LIST
62455: PUSH
62456: LD_INT 25
62458: PUSH
62459: LD_INT 5
62461: PUSH
62462: EMPTY
62463: LIST
62464: LIST
62465: PUSH
62466: LD_INT 25
62468: PUSH
62469: LD_INT 8
62471: PUSH
62472: EMPTY
62473: LIST
62474: LIST
62475: PUSH
62476: LD_INT 25
62478: PUSH
62479: LD_INT 9
62481: PUSH
62482: EMPTY
62483: LIST
62484: LIST
62485: PUSH
62486: EMPTY
62487: LIST
62488: LIST
62489: LIST
62490: LIST
62491: LIST
62492: PPUSH
62493: CALL_OW 72
62497: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
62498: LD_ADDR_VAR 0 6
62502: PUSH
62503: LD_EXP 59
62507: PUSH
62508: LD_VAR 0 1
62512: ARRAY
62513: PPUSH
62514: LD_INT 25
62516: PUSH
62517: LD_INT 2
62519: PUSH
62520: EMPTY
62521: LIST
62522: LIST
62523: PPUSH
62524: CALL_OW 72
62528: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
62529: LD_ADDR_VAR 0 7
62533: PUSH
62534: LD_EXP 59
62538: PUSH
62539: LD_VAR 0 1
62543: ARRAY
62544: PPUSH
62545: LD_INT 25
62547: PUSH
62548: LD_INT 3
62550: PUSH
62551: EMPTY
62552: LIST
62553: LIST
62554: PPUSH
62555: CALL_OW 72
62559: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
62560: LD_ADDR_VAR 0 8
62564: PUSH
62565: LD_EXP 59
62569: PUSH
62570: LD_VAR 0 1
62574: ARRAY
62575: PPUSH
62576: LD_INT 25
62578: PUSH
62579: LD_INT 4
62581: PUSH
62582: EMPTY
62583: LIST
62584: LIST
62585: PUSH
62586: LD_INT 24
62588: PUSH
62589: LD_INT 251
62591: PUSH
62592: EMPTY
62593: LIST
62594: LIST
62595: PUSH
62596: EMPTY
62597: LIST
62598: LIST
62599: PPUSH
62600: CALL_OW 72
62604: ST_TO_ADDR
// if mc_scan [ base ] then
62605: LD_EXP 82
62609: PUSH
62610: LD_VAR 0 1
62614: ARRAY
62615: IFFALSE 63076
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
62617: LD_ADDR_EXP 101
62621: PUSH
62622: LD_EXP 101
62626: PPUSH
62627: LD_VAR 0 1
62631: PPUSH
62632: LD_INT 4
62634: PPUSH
62635: CALL_OW 1
62639: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62640: LD_ADDR_VAR 0 12
62644: PUSH
62645: LD_EXP 59
62649: PUSH
62650: LD_VAR 0 1
62654: ARRAY
62655: PPUSH
62656: LD_INT 2
62658: PUSH
62659: LD_INT 30
62661: PUSH
62662: LD_INT 4
62664: PUSH
62665: EMPTY
62666: LIST
62667: LIST
62668: PUSH
62669: LD_INT 30
62671: PUSH
62672: LD_INT 5
62674: PUSH
62675: EMPTY
62676: LIST
62677: LIST
62678: PUSH
62679: EMPTY
62680: LIST
62681: LIST
62682: LIST
62683: PPUSH
62684: CALL_OW 72
62688: ST_TO_ADDR
// if not b then
62689: LD_VAR 0 12
62693: NOT
62694: IFFALSE 62698
// exit ;
62696: GO 65764
// p := [ ] ;
62698: LD_ADDR_VAR 0 11
62702: PUSH
62703: EMPTY
62704: ST_TO_ADDR
// if sci >= 2 then
62705: LD_VAR 0 8
62709: PUSH
62710: LD_INT 2
62712: GREATEREQUAL
62713: IFFALSE 62744
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
62715: LD_ADDR_VAR 0 8
62719: PUSH
62720: LD_VAR 0 8
62724: PUSH
62725: LD_INT 1
62727: ARRAY
62728: PUSH
62729: LD_VAR 0 8
62733: PUSH
62734: LD_INT 2
62736: ARRAY
62737: PUSH
62738: EMPTY
62739: LIST
62740: LIST
62741: ST_TO_ADDR
62742: GO 62805
// if sci = 1 then
62744: LD_VAR 0 8
62748: PUSH
62749: LD_INT 1
62751: EQUAL
62752: IFFALSE 62773
// sci := [ sci [ 1 ] ] else
62754: LD_ADDR_VAR 0 8
62758: PUSH
62759: LD_VAR 0 8
62763: PUSH
62764: LD_INT 1
62766: ARRAY
62767: PUSH
62768: EMPTY
62769: LIST
62770: ST_TO_ADDR
62771: GO 62805
// if sci = 0 then
62773: LD_VAR 0 8
62777: PUSH
62778: LD_INT 0
62780: EQUAL
62781: IFFALSE 62805
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62783: LD_ADDR_VAR 0 11
62787: PUSH
62788: LD_VAR 0 4
62792: PPUSH
62793: LD_INT 4
62795: PPUSH
62796: CALL 55847 0 2
62800: PUSH
62801: LD_INT 1
62803: ARRAY
62804: ST_TO_ADDR
// if eng > 4 then
62805: LD_VAR 0 6
62809: PUSH
62810: LD_INT 4
62812: GREATER
62813: IFFALSE 62859
// for i = eng downto 4 do
62815: LD_ADDR_VAR 0 3
62819: PUSH
62820: DOUBLE
62821: LD_VAR 0 6
62825: INC
62826: ST_TO_ADDR
62827: LD_INT 4
62829: PUSH
62830: FOR_DOWNTO
62831: IFFALSE 62857
// eng := eng diff eng [ i ] ;
62833: LD_ADDR_VAR 0 6
62837: PUSH
62838: LD_VAR 0 6
62842: PUSH
62843: LD_VAR 0 6
62847: PUSH
62848: LD_VAR 0 3
62852: ARRAY
62853: DIFF
62854: ST_TO_ADDR
62855: GO 62830
62857: POP
62858: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62859: LD_ADDR_VAR 0 4
62863: PUSH
62864: LD_VAR 0 4
62868: PUSH
62869: LD_VAR 0 5
62873: PUSH
62874: LD_VAR 0 6
62878: UNION
62879: PUSH
62880: LD_VAR 0 7
62884: UNION
62885: PUSH
62886: LD_VAR 0 8
62890: UNION
62891: DIFF
62892: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62893: LD_ADDR_VAR 0 13
62897: PUSH
62898: LD_EXP 59
62902: PUSH
62903: LD_VAR 0 1
62907: ARRAY
62908: PPUSH
62909: LD_INT 2
62911: PUSH
62912: LD_INT 30
62914: PUSH
62915: LD_INT 32
62917: PUSH
62918: EMPTY
62919: LIST
62920: LIST
62921: PUSH
62922: LD_INT 30
62924: PUSH
62925: LD_INT 31
62927: PUSH
62928: EMPTY
62929: LIST
62930: LIST
62931: PUSH
62932: EMPTY
62933: LIST
62934: LIST
62935: LIST
62936: PPUSH
62937: CALL_OW 72
62941: PUSH
62942: LD_EXP 59
62946: PUSH
62947: LD_VAR 0 1
62951: ARRAY
62952: PPUSH
62953: LD_INT 2
62955: PUSH
62956: LD_INT 30
62958: PUSH
62959: LD_INT 4
62961: PUSH
62962: EMPTY
62963: LIST
62964: LIST
62965: PUSH
62966: LD_INT 30
62968: PUSH
62969: LD_INT 5
62971: PUSH
62972: EMPTY
62973: LIST
62974: LIST
62975: PUSH
62976: EMPTY
62977: LIST
62978: LIST
62979: LIST
62980: PPUSH
62981: CALL_OW 72
62985: PUSH
62986: LD_INT 6
62988: MUL
62989: PLUS
62990: ST_TO_ADDR
// if bcount < tmp then
62991: LD_VAR 0 13
62995: PUSH
62996: LD_VAR 0 4
63000: LESS
63001: IFFALSE 63047
// for i = tmp downto bcount do
63003: LD_ADDR_VAR 0 3
63007: PUSH
63008: DOUBLE
63009: LD_VAR 0 4
63013: INC
63014: ST_TO_ADDR
63015: LD_VAR 0 13
63019: PUSH
63020: FOR_DOWNTO
63021: IFFALSE 63045
// tmp := Delete ( tmp , tmp ) ;
63023: LD_ADDR_VAR 0 4
63027: PUSH
63028: LD_VAR 0 4
63032: PPUSH
63033: LD_VAR 0 4
63037: PPUSH
63038: CALL_OW 3
63042: ST_TO_ADDR
63043: GO 63020
63045: POP
63046: POP
// result := [ tmp , 0 , 0 , p ] ;
63047: LD_ADDR_VAR 0 2
63051: PUSH
63052: LD_VAR 0 4
63056: PUSH
63057: LD_INT 0
63059: PUSH
63060: LD_INT 0
63062: PUSH
63063: LD_VAR 0 11
63067: PUSH
63068: EMPTY
63069: LIST
63070: LIST
63071: LIST
63072: LIST
63073: ST_TO_ADDR
// exit ;
63074: GO 65764
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63076: LD_EXP 59
63080: PUSH
63081: LD_VAR 0 1
63085: ARRAY
63086: PPUSH
63087: LD_INT 2
63089: PUSH
63090: LD_INT 30
63092: PUSH
63093: LD_INT 6
63095: PUSH
63096: EMPTY
63097: LIST
63098: LIST
63099: PUSH
63100: LD_INT 30
63102: PUSH
63103: LD_INT 7
63105: PUSH
63106: EMPTY
63107: LIST
63108: LIST
63109: PUSH
63110: LD_INT 30
63112: PUSH
63113: LD_INT 8
63115: PUSH
63116: EMPTY
63117: LIST
63118: LIST
63119: PUSH
63120: EMPTY
63121: LIST
63122: LIST
63123: LIST
63124: LIST
63125: PPUSH
63126: CALL_OW 72
63130: NOT
63131: PUSH
63132: LD_EXP 59
63136: PUSH
63137: LD_VAR 0 1
63141: ARRAY
63142: PPUSH
63143: LD_INT 30
63145: PUSH
63146: LD_INT 3
63148: PUSH
63149: EMPTY
63150: LIST
63151: LIST
63152: PPUSH
63153: CALL_OW 72
63157: NOT
63158: AND
63159: IFFALSE 63231
// begin if eng = tmp then
63161: LD_VAR 0 6
63165: PUSH
63166: LD_VAR 0 4
63170: EQUAL
63171: IFFALSE 63175
// exit ;
63173: GO 65764
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
63175: LD_ADDR_EXP 101
63179: PUSH
63180: LD_EXP 101
63184: PPUSH
63185: LD_VAR 0 1
63189: PPUSH
63190: LD_INT 1
63192: PPUSH
63193: CALL_OW 1
63197: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
63198: LD_ADDR_VAR 0 2
63202: PUSH
63203: LD_INT 0
63205: PUSH
63206: LD_VAR 0 4
63210: PUSH
63211: LD_VAR 0 6
63215: DIFF
63216: PUSH
63217: LD_INT 0
63219: PUSH
63220: LD_INT 0
63222: PUSH
63223: EMPTY
63224: LIST
63225: LIST
63226: LIST
63227: LIST
63228: ST_TO_ADDR
// exit ;
63229: GO 65764
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63231: LD_EXP 86
63235: PUSH
63236: LD_EXP 85
63240: PUSH
63241: LD_VAR 0 1
63245: ARRAY
63246: ARRAY
63247: PUSH
63248: LD_EXP 59
63252: PUSH
63253: LD_VAR 0 1
63257: ARRAY
63258: PPUSH
63259: LD_INT 2
63261: PUSH
63262: LD_INT 30
63264: PUSH
63265: LD_INT 6
63267: PUSH
63268: EMPTY
63269: LIST
63270: LIST
63271: PUSH
63272: LD_INT 30
63274: PUSH
63275: LD_INT 7
63277: PUSH
63278: EMPTY
63279: LIST
63280: LIST
63281: PUSH
63282: LD_INT 30
63284: PUSH
63285: LD_INT 8
63287: PUSH
63288: EMPTY
63289: LIST
63290: LIST
63291: PUSH
63292: EMPTY
63293: LIST
63294: LIST
63295: LIST
63296: LIST
63297: PPUSH
63298: CALL_OW 72
63302: AND
63303: PUSH
63304: LD_EXP 59
63308: PUSH
63309: LD_VAR 0 1
63313: ARRAY
63314: PPUSH
63315: LD_INT 30
63317: PUSH
63318: LD_INT 3
63320: PUSH
63321: EMPTY
63322: LIST
63323: LIST
63324: PPUSH
63325: CALL_OW 72
63329: NOT
63330: AND
63331: IFFALSE 63545
// begin if sci >= 6 then
63333: LD_VAR 0 8
63337: PUSH
63338: LD_INT 6
63340: GREATEREQUAL
63341: IFFALSE 63345
// exit ;
63343: GO 65764
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
63345: LD_ADDR_EXP 101
63349: PUSH
63350: LD_EXP 101
63354: PPUSH
63355: LD_VAR 0 1
63359: PPUSH
63360: LD_INT 2
63362: PPUSH
63363: CALL_OW 1
63367: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
63368: LD_ADDR_VAR 0 9
63372: PUSH
63373: LD_VAR 0 4
63377: PUSH
63378: LD_VAR 0 8
63382: DIFF
63383: PPUSH
63384: LD_INT 4
63386: PPUSH
63387: CALL 55847 0 2
63391: ST_TO_ADDR
// p := [ ] ;
63392: LD_ADDR_VAR 0 11
63396: PUSH
63397: EMPTY
63398: ST_TO_ADDR
// if sci < 6 and sort > 6 then
63399: LD_VAR 0 8
63403: PUSH
63404: LD_INT 6
63406: LESS
63407: PUSH
63408: LD_VAR 0 9
63412: PUSH
63413: LD_INT 6
63415: GREATER
63416: AND
63417: IFFALSE 63498
// begin for i = 1 to 6 - sci do
63419: LD_ADDR_VAR 0 3
63423: PUSH
63424: DOUBLE
63425: LD_INT 1
63427: DEC
63428: ST_TO_ADDR
63429: LD_INT 6
63431: PUSH
63432: LD_VAR 0 8
63436: MINUS
63437: PUSH
63438: FOR_TO
63439: IFFALSE 63494
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
63441: LD_ADDR_VAR 0 11
63445: PUSH
63446: LD_VAR 0 11
63450: PPUSH
63451: LD_VAR 0 11
63455: PUSH
63456: LD_INT 1
63458: PLUS
63459: PPUSH
63460: LD_VAR 0 9
63464: PUSH
63465: LD_INT 1
63467: ARRAY
63468: PPUSH
63469: CALL_OW 2
63473: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
63474: LD_ADDR_VAR 0 9
63478: PUSH
63479: LD_VAR 0 9
63483: PPUSH
63484: LD_INT 1
63486: PPUSH
63487: CALL_OW 3
63491: ST_TO_ADDR
// end ;
63492: GO 63438
63494: POP
63495: POP
// end else
63496: GO 63518
// if sort then
63498: LD_VAR 0 9
63502: IFFALSE 63518
// p := sort [ 1 ] ;
63504: LD_ADDR_VAR 0 11
63508: PUSH
63509: LD_VAR 0 9
63513: PUSH
63514: LD_INT 1
63516: ARRAY
63517: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
63518: LD_ADDR_VAR 0 2
63522: PUSH
63523: LD_INT 0
63525: PUSH
63526: LD_INT 0
63528: PUSH
63529: LD_INT 0
63531: PUSH
63532: LD_VAR 0 11
63536: PUSH
63537: EMPTY
63538: LIST
63539: LIST
63540: LIST
63541: LIST
63542: ST_TO_ADDR
// exit ;
63543: GO 65764
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63545: LD_EXP 86
63549: PUSH
63550: LD_EXP 85
63554: PUSH
63555: LD_VAR 0 1
63559: ARRAY
63560: ARRAY
63561: PUSH
63562: LD_EXP 59
63566: PUSH
63567: LD_VAR 0 1
63571: ARRAY
63572: PPUSH
63573: LD_INT 2
63575: PUSH
63576: LD_INT 30
63578: PUSH
63579: LD_INT 6
63581: PUSH
63582: EMPTY
63583: LIST
63584: LIST
63585: PUSH
63586: LD_INT 30
63588: PUSH
63589: LD_INT 7
63591: PUSH
63592: EMPTY
63593: LIST
63594: LIST
63595: PUSH
63596: LD_INT 30
63598: PUSH
63599: LD_INT 8
63601: PUSH
63602: EMPTY
63603: LIST
63604: LIST
63605: PUSH
63606: EMPTY
63607: LIST
63608: LIST
63609: LIST
63610: LIST
63611: PPUSH
63612: CALL_OW 72
63616: AND
63617: PUSH
63618: LD_EXP 59
63622: PUSH
63623: LD_VAR 0 1
63627: ARRAY
63628: PPUSH
63629: LD_INT 30
63631: PUSH
63632: LD_INT 3
63634: PUSH
63635: EMPTY
63636: LIST
63637: LIST
63638: PPUSH
63639: CALL_OW 72
63643: AND
63644: IFFALSE 64378
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
63646: LD_ADDR_EXP 101
63650: PUSH
63651: LD_EXP 101
63655: PPUSH
63656: LD_VAR 0 1
63660: PPUSH
63661: LD_INT 3
63663: PPUSH
63664: CALL_OW 1
63668: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63669: LD_ADDR_VAR 0 2
63673: PUSH
63674: LD_INT 0
63676: PUSH
63677: LD_INT 0
63679: PUSH
63680: LD_INT 0
63682: PUSH
63683: LD_INT 0
63685: PUSH
63686: EMPTY
63687: LIST
63688: LIST
63689: LIST
63690: LIST
63691: ST_TO_ADDR
// if not eng then
63692: LD_VAR 0 6
63696: NOT
63697: IFFALSE 63760
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
63699: LD_ADDR_VAR 0 11
63703: PUSH
63704: LD_VAR 0 4
63708: PPUSH
63709: LD_INT 2
63711: PPUSH
63712: CALL 55847 0 2
63716: PUSH
63717: LD_INT 1
63719: ARRAY
63720: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
63721: LD_ADDR_VAR 0 2
63725: PUSH
63726: LD_VAR 0 2
63730: PPUSH
63731: LD_INT 2
63733: PPUSH
63734: LD_VAR 0 11
63738: PPUSH
63739: CALL_OW 1
63743: ST_TO_ADDR
// tmp := tmp diff p ;
63744: LD_ADDR_VAR 0 4
63748: PUSH
63749: LD_VAR 0 4
63753: PUSH
63754: LD_VAR 0 11
63758: DIFF
63759: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63760: LD_VAR 0 4
63764: PUSH
63765: LD_VAR 0 8
63769: PUSH
63770: LD_INT 6
63772: LESS
63773: AND
63774: IFFALSE 63962
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63776: LD_ADDR_VAR 0 9
63780: PUSH
63781: LD_VAR 0 4
63785: PUSH
63786: LD_VAR 0 8
63790: PUSH
63791: LD_VAR 0 7
63795: UNION
63796: DIFF
63797: PPUSH
63798: LD_INT 4
63800: PPUSH
63801: CALL 55847 0 2
63805: ST_TO_ADDR
// p := [ ] ;
63806: LD_ADDR_VAR 0 11
63810: PUSH
63811: EMPTY
63812: ST_TO_ADDR
// if sort then
63813: LD_VAR 0 9
63817: IFFALSE 63933
// for i = 1 to 6 - sci do
63819: LD_ADDR_VAR 0 3
63823: PUSH
63824: DOUBLE
63825: LD_INT 1
63827: DEC
63828: ST_TO_ADDR
63829: LD_INT 6
63831: PUSH
63832: LD_VAR 0 8
63836: MINUS
63837: PUSH
63838: FOR_TO
63839: IFFALSE 63931
// begin if i = sort then
63841: LD_VAR 0 3
63845: PUSH
63846: LD_VAR 0 9
63850: EQUAL
63851: IFFALSE 63855
// break ;
63853: GO 63931
// if GetClass ( i ) = 4 then
63855: LD_VAR 0 3
63859: PPUSH
63860: CALL_OW 257
63864: PUSH
63865: LD_INT 4
63867: EQUAL
63868: IFFALSE 63872
// continue ;
63870: GO 63838
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63872: LD_ADDR_VAR 0 11
63876: PUSH
63877: LD_VAR 0 11
63881: PPUSH
63882: LD_VAR 0 11
63886: PUSH
63887: LD_INT 1
63889: PLUS
63890: PPUSH
63891: LD_VAR 0 9
63895: PUSH
63896: LD_VAR 0 3
63900: ARRAY
63901: PPUSH
63902: CALL_OW 2
63906: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63907: LD_ADDR_VAR 0 4
63911: PUSH
63912: LD_VAR 0 4
63916: PUSH
63917: LD_VAR 0 9
63921: PUSH
63922: LD_VAR 0 3
63926: ARRAY
63927: DIFF
63928: ST_TO_ADDR
// end ;
63929: GO 63838
63931: POP
63932: POP
// if p then
63933: LD_VAR 0 11
63937: IFFALSE 63962
// result := Replace ( result , 4 , p ) ;
63939: LD_ADDR_VAR 0 2
63943: PUSH
63944: LD_VAR 0 2
63948: PPUSH
63949: LD_INT 4
63951: PPUSH
63952: LD_VAR 0 11
63956: PPUSH
63957: CALL_OW 1
63961: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63962: LD_VAR 0 4
63966: PUSH
63967: LD_VAR 0 7
63971: PUSH
63972: LD_INT 6
63974: LESS
63975: AND
63976: IFFALSE 64164
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63978: LD_ADDR_VAR 0 9
63982: PUSH
63983: LD_VAR 0 4
63987: PUSH
63988: LD_VAR 0 8
63992: PUSH
63993: LD_VAR 0 7
63997: UNION
63998: DIFF
63999: PPUSH
64000: LD_INT 3
64002: PPUSH
64003: CALL 55847 0 2
64007: ST_TO_ADDR
// p := [ ] ;
64008: LD_ADDR_VAR 0 11
64012: PUSH
64013: EMPTY
64014: ST_TO_ADDR
// if sort then
64015: LD_VAR 0 9
64019: IFFALSE 64135
// for i = 1 to 6 - mech do
64021: LD_ADDR_VAR 0 3
64025: PUSH
64026: DOUBLE
64027: LD_INT 1
64029: DEC
64030: ST_TO_ADDR
64031: LD_INT 6
64033: PUSH
64034: LD_VAR 0 7
64038: MINUS
64039: PUSH
64040: FOR_TO
64041: IFFALSE 64133
// begin if i = sort then
64043: LD_VAR 0 3
64047: PUSH
64048: LD_VAR 0 9
64052: EQUAL
64053: IFFALSE 64057
// break ;
64055: GO 64133
// if GetClass ( i ) = 3 then
64057: LD_VAR 0 3
64061: PPUSH
64062: CALL_OW 257
64066: PUSH
64067: LD_INT 3
64069: EQUAL
64070: IFFALSE 64074
// continue ;
64072: GO 64040
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64074: LD_ADDR_VAR 0 11
64078: PUSH
64079: LD_VAR 0 11
64083: PPUSH
64084: LD_VAR 0 11
64088: PUSH
64089: LD_INT 1
64091: PLUS
64092: PPUSH
64093: LD_VAR 0 9
64097: PUSH
64098: LD_VAR 0 3
64102: ARRAY
64103: PPUSH
64104: CALL_OW 2
64108: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64109: LD_ADDR_VAR 0 4
64113: PUSH
64114: LD_VAR 0 4
64118: PUSH
64119: LD_VAR 0 9
64123: PUSH
64124: LD_VAR 0 3
64128: ARRAY
64129: DIFF
64130: ST_TO_ADDR
// end ;
64131: GO 64040
64133: POP
64134: POP
// if p then
64135: LD_VAR 0 11
64139: IFFALSE 64164
// result := Replace ( result , 3 , p ) ;
64141: LD_ADDR_VAR 0 2
64145: PUSH
64146: LD_VAR 0 2
64150: PPUSH
64151: LD_INT 3
64153: PPUSH
64154: LD_VAR 0 11
64158: PPUSH
64159: CALL_OW 1
64163: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
64164: LD_VAR 0 4
64168: PUSH
64169: LD_INT 6
64171: GREATER
64172: PUSH
64173: LD_VAR 0 6
64177: PUSH
64178: LD_INT 6
64180: LESS
64181: AND
64182: IFFALSE 64376
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64184: LD_ADDR_VAR 0 9
64188: PUSH
64189: LD_VAR 0 4
64193: PUSH
64194: LD_VAR 0 8
64198: PUSH
64199: LD_VAR 0 7
64203: UNION
64204: PUSH
64205: LD_VAR 0 6
64209: UNION
64210: DIFF
64211: PPUSH
64212: LD_INT 2
64214: PPUSH
64215: CALL 55847 0 2
64219: ST_TO_ADDR
// p := [ ] ;
64220: LD_ADDR_VAR 0 11
64224: PUSH
64225: EMPTY
64226: ST_TO_ADDR
// if sort then
64227: LD_VAR 0 9
64231: IFFALSE 64347
// for i = 1 to 6 - eng do
64233: LD_ADDR_VAR 0 3
64237: PUSH
64238: DOUBLE
64239: LD_INT 1
64241: DEC
64242: ST_TO_ADDR
64243: LD_INT 6
64245: PUSH
64246: LD_VAR 0 6
64250: MINUS
64251: PUSH
64252: FOR_TO
64253: IFFALSE 64345
// begin if i = sort then
64255: LD_VAR 0 3
64259: PUSH
64260: LD_VAR 0 9
64264: EQUAL
64265: IFFALSE 64269
// break ;
64267: GO 64345
// if GetClass ( i ) = 2 then
64269: LD_VAR 0 3
64273: PPUSH
64274: CALL_OW 257
64278: PUSH
64279: LD_INT 2
64281: EQUAL
64282: IFFALSE 64286
// continue ;
64284: GO 64252
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64286: LD_ADDR_VAR 0 11
64290: PUSH
64291: LD_VAR 0 11
64295: PPUSH
64296: LD_VAR 0 11
64300: PUSH
64301: LD_INT 1
64303: PLUS
64304: PPUSH
64305: LD_VAR 0 9
64309: PUSH
64310: LD_VAR 0 3
64314: ARRAY
64315: PPUSH
64316: CALL_OW 2
64320: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64321: LD_ADDR_VAR 0 4
64325: PUSH
64326: LD_VAR 0 4
64330: PUSH
64331: LD_VAR 0 9
64335: PUSH
64336: LD_VAR 0 3
64340: ARRAY
64341: DIFF
64342: ST_TO_ADDR
// end ;
64343: GO 64252
64345: POP
64346: POP
// if p then
64347: LD_VAR 0 11
64351: IFFALSE 64376
// result := Replace ( result , 2 , p ) ;
64353: LD_ADDR_VAR 0 2
64357: PUSH
64358: LD_VAR 0 2
64362: PPUSH
64363: LD_INT 2
64365: PPUSH
64366: LD_VAR 0 11
64370: PPUSH
64371: CALL_OW 1
64375: ST_TO_ADDR
// end ; exit ;
64376: GO 65764
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
64378: LD_EXP 86
64382: PUSH
64383: LD_EXP 85
64387: PUSH
64388: LD_VAR 0 1
64392: ARRAY
64393: ARRAY
64394: NOT
64395: PUSH
64396: LD_EXP 59
64400: PUSH
64401: LD_VAR 0 1
64405: ARRAY
64406: PPUSH
64407: LD_INT 30
64409: PUSH
64410: LD_INT 3
64412: PUSH
64413: EMPTY
64414: LIST
64415: LIST
64416: PPUSH
64417: CALL_OW 72
64421: AND
64422: PUSH
64423: LD_EXP 64
64427: PUSH
64428: LD_VAR 0 1
64432: ARRAY
64433: AND
64434: IFFALSE 65042
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
64436: LD_ADDR_EXP 101
64440: PUSH
64441: LD_EXP 101
64445: PPUSH
64446: LD_VAR 0 1
64450: PPUSH
64451: LD_INT 5
64453: PPUSH
64454: CALL_OW 1
64458: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64459: LD_ADDR_VAR 0 2
64463: PUSH
64464: LD_INT 0
64466: PUSH
64467: LD_INT 0
64469: PUSH
64470: LD_INT 0
64472: PUSH
64473: LD_INT 0
64475: PUSH
64476: EMPTY
64477: LIST
64478: LIST
64479: LIST
64480: LIST
64481: ST_TO_ADDR
// if sci > 1 then
64482: LD_VAR 0 8
64486: PUSH
64487: LD_INT 1
64489: GREATER
64490: IFFALSE 64518
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
64492: LD_ADDR_VAR 0 4
64496: PUSH
64497: LD_VAR 0 4
64501: PUSH
64502: LD_VAR 0 8
64506: PUSH
64507: LD_VAR 0 8
64511: PUSH
64512: LD_INT 1
64514: ARRAY
64515: DIFF
64516: DIFF
64517: ST_TO_ADDR
// if tmp and not sci then
64518: LD_VAR 0 4
64522: PUSH
64523: LD_VAR 0 8
64527: NOT
64528: AND
64529: IFFALSE 64598
// begin sort := SortBySkill ( tmp , 4 ) ;
64531: LD_ADDR_VAR 0 9
64535: PUSH
64536: LD_VAR 0 4
64540: PPUSH
64541: LD_INT 4
64543: PPUSH
64544: CALL 55847 0 2
64548: ST_TO_ADDR
// if sort then
64549: LD_VAR 0 9
64553: IFFALSE 64569
// p := sort [ 1 ] ;
64555: LD_ADDR_VAR 0 11
64559: PUSH
64560: LD_VAR 0 9
64564: PUSH
64565: LD_INT 1
64567: ARRAY
64568: ST_TO_ADDR
// if p then
64569: LD_VAR 0 11
64573: IFFALSE 64598
// result := Replace ( result , 4 , p ) ;
64575: LD_ADDR_VAR 0 2
64579: PUSH
64580: LD_VAR 0 2
64584: PPUSH
64585: LD_INT 4
64587: PPUSH
64588: LD_VAR 0 11
64592: PPUSH
64593: CALL_OW 1
64597: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64598: LD_ADDR_VAR 0 4
64602: PUSH
64603: LD_VAR 0 4
64607: PUSH
64608: LD_VAR 0 7
64612: DIFF
64613: ST_TO_ADDR
// if tmp and mech < 6 then
64614: LD_VAR 0 4
64618: PUSH
64619: LD_VAR 0 7
64623: PUSH
64624: LD_INT 6
64626: LESS
64627: AND
64628: IFFALSE 64816
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64630: LD_ADDR_VAR 0 9
64634: PUSH
64635: LD_VAR 0 4
64639: PUSH
64640: LD_VAR 0 8
64644: PUSH
64645: LD_VAR 0 7
64649: UNION
64650: DIFF
64651: PPUSH
64652: LD_INT 3
64654: PPUSH
64655: CALL 55847 0 2
64659: ST_TO_ADDR
// p := [ ] ;
64660: LD_ADDR_VAR 0 11
64664: PUSH
64665: EMPTY
64666: ST_TO_ADDR
// if sort then
64667: LD_VAR 0 9
64671: IFFALSE 64787
// for i = 1 to 6 - mech do
64673: LD_ADDR_VAR 0 3
64677: PUSH
64678: DOUBLE
64679: LD_INT 1
64681: DEC
64682: ST_TO_ADDR
64683: LD_INT 6
64685: PUSH
64686: LD_VAR 0 7
64690: MINUS
64691: PUSH
64692: FOR_TO
64693: IFFALSE 64785
// begin if i = sort then
64695: LD_VAR 0 3
64699: PUSH
64700: LD_VAR 0 9
64704: EQUAL
64705: IFFALSE 64709
// break ;
64707: GO 64785
// if GetClass ( i ) = 3 then
64709: LD_VAR 0 3
64713: PPUSH
64714: CALL_OW 257
64718: PUSH
64719: LD_INT 3
64721: EQUAL
64722: IFFALSE 64726
// continue ;
64724: GO 64692
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64726: LD_ADDR_VAR 0 11
64730: PUSH
64731: LD_VAR 0 11
64735: PPUSH
64736: LD_VAR 0 11
64740: PUSH
64741: LD_INT 1
64743: PLUS
64744: PPUSH
64745: LD_VAR 0 9
64749: PUSH
64750: LD_VAR 0 3
64754: ARRAY
64755: PPUSH
64756: CALL_OW 2
64760: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64761: LD_ADDR_VAR 0 4
64765: PUSH
64766: LD_VAR 0 4
64770: PUSH
64771: LD_VAR 0 9
64775: PUSH
64776: LD_VAR 0 3
64780: ARRAY
64781: DIFF
64782: ST_TO_ADDR
// end ;
64783: GO 64692
64785: POP
64786: POP
// if p then
64787: LD_VAR 0 11
64791: IFFALSE 64816
// result := Replace ( result , 3 , p ) ;
64793: LD_ADDR_VAR 0 2
64797: PUSH
64798: LD_VAR 0 2
64802: PPUSH
64803: LD_INT 3
64805: PPUSH
64806: LD_VAR 0 11
64810: PPUSH
64811: CALL_OW 1
64815: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64816: LD_ADDR_VAR 0 4
64820: PUSH
64821: LD_VAR 0 4
64825: PUSH
64826: LD_VAR 0 6
64830: DIFF
64831: ST_TO_ADDR
// if tmp and eng < 6 then
64832: LD_VAR 0 4
64836: PUSH
64837: LD_VAR 0 6
64841: PUSH
64842: LD_INT 6
64844: LESS
64845: AND
64846: IFFALSE 65040
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64848: LD_ADDR_VAR 0 9
64852: PUSH
64853: LD_VAR 0 4
64857: PUSH
64858: LD_VAR 0 8
64862: PUSH
64863: LD_VAR 0 7
64867: UNION
64868: PUSH
64869: LD_VAR 0 6
64873: UNION
64874: DIFF
64875: PPUSH
64876: LD_INT 2
64878: PPUSH
64879: CALL 55847 0 2
64883: ST_TO_ADDR
// p := [ ] ;
64884: LD_ADDR_VAR 0 11
64888: PUSH
64889: EMPTY
64890: ST_TO_ADDR
// if sort then
64891: LD_VAR 0 9
64895: IFFALSE 65011
// for i = 1 to 6 - eng do
64897: LD_ADDR_VAR 0 3
64901: PUSH
64902: DOUBLE
64903: LD_INT 1
64905: DEC
64906: ST_TO_ADDR
64907: LD_INT 6
64909: PUSH
64910: LD_VAR 0 6
64914: MINUS
64915: PUSH
64916: FOR_TO
64917: IFFALSE 65009
// begin if i = sort then
64919: LD_VAR 0 3
64923: PUSH
64924: LD_VAR 0 9
64928: EQUAL
64929: IFFALSE 64933
// break ;
64931: GO 65009
// if GetClass ( i ) = 2 then
64933: LD_VAR 0 3
64937: PPUSH
64938: CALL_OW 257
64942: PUSH
64943: LD_INT 2
64945: EQUAL
64946: IFFALSE 64950
// continue ;
64948: GO 64916
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64950: LD_ADDR_VAR 0 11
64954: PUSH
64955: LD_VAR 0 11
64959: PPUSH
64960: LD_VAR 0 11
64964: PUSH
64965: LD_INT 1
64967: PLUS
64968: PPUSH
64969: LD_VAR 0 9
64973: PUSH
64974: LD_VAR 0 3
64978: ARRAY
64979: PPUSH
64980: CALL_OW 2
64984: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64985: LD_ADDR_VAR 0 4
64989: PUSH
64990: LD_VAR 0 4
64994: PUSH
64995: LD_VAR 0 9
64999: PUSH
65000: LD_VAR 0 3
65004: ARRAY
65005: DIFF
65006: ST_TO_ADDR
// end ;
65007: GO 64916
65009: POP
65010: POP
// if p then
65011: LD_VAR 0 11
65015: IFFALSE 65040
// result := Replace ( result , 2 , p ) ;
65017: LD_ADDR_VAR 0 2
65021: PUSH
65022: LD_VAR 0 2
65026: PPUSH
65027: LD_INT 2
65029: PPUSH
65030: LD_VAR 0 11
65034: PPUSH
65035: CALL_OW 1
65039: ST_TO_ADDR
// end ; exit ;
65040: GO 65764
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
65042: LD_EXP 86
65046: PUSH
65047: LD_EXP 85
65051: PUSH
65052: LD_VAR 0 1
65056: ARRAY
65057: ARRAY
65058: NOT
65059: PUSH
65060: LD_EXP 59
65064: PUSH
65065: LD_VAR 0 1
65069: ARRAY
65070: PPUSH
65071: LD_INT 30
65073: PUSH
65074: LD_INT 3
65076: PUSH
65077: EMPTY
65078: LIST
65079: LIST
65080: PPUSH
65081: CALL_OW 72
65085: AND
65086: PUSH
65087: LD_EXP 64
65091: PUSH
65092: LD_VAR 0 1
65096: ARRAY
65097: NOT
65098: AND
65099: IFFALSE 65764
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
65101: LD_ADDR_EXP 101
65105: PUSH
65106: LD_EXP 101
65110: PPUSH
65111: LD_VAR 0 1
65115: PPUSH
65116: LD_INT 6
65118: PPUSH
65119: CALL_OW 1
65123: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
65124: LD_ADDR_VAR 0 2
65128: PUSH
65129: LD_INT 0
65131: PUSH
65132: LD_INT 0
65134: PUSH
65135: LD_INT 0
65137: PUSH
65138: LD_INT 0
65140: PUSH
65141: EMPTY
65142: LIST
65143: LIST
65144: LIST
65145: LIST
65146: ST_TO_ADDR
// if sci >= 1 then
65147: LD_VAR 0 8
65151: PUSH
65152: LD_INT 1
65154: GREATEREQUAL
65155: IFFALSE 65177
// tmp := tmp diff sci [ 1 ] ;
65157: LD_ADDR_VAR 0 4
65161: PUSH
65162: LD_VAR 0 4
65166: PUSH
65167: LD_VAR 0 8
65171: PUSH
65172: LD_INT 1
65174: ARRAY
65175: DIFF
65176: ST_TO_ADDR
// if tmp and not sci then
65177: LD_VAR 0 4
65181: PUSH
65182: LD_VAR 0 8
65186: NOT
65187: AND
65188: IFFALSE 65257
// begin sort := SortBySkill ( tmp , 4 ) ;
65190: LD_ADDR_VAR 0 9
65194: PUSH
65195: LD_VAR 0 4
65199: PPUSH
65200: LD_INT 4
65202: PPUSH
65203: CALL 55847 0 2
65207: ST_TO_ADDR
// if sort then
65208: LD_VAR 0 9
65212: IFFALSE 65228
// p := sort [ 1 ] ;
65214: LD_ADDR_VAR 0 11
65218: PUSH
65219: LD_VAR 0 9
65223: PUSH
65224: LD_INT 1
65226: ARRAY
65227: ST_TO_ADDR
// if p then
65228: LD_VAR 0 11
65232: IFFALSE 65257
// result := Replace ( result , 4 , p ) ;
65234: LD_ADDR_VAR 0 2
65238: PUSH
65239: LD_VAR 0 2
65243: PPUSH
65244: LD_INT 4
65246: PPUSH
65247: LD_VAR 0 11
65251: PPUSH
65252: CALL_OW 1
65256: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
65257: LD_ADDR_VAR 0 4
65261: PUSH
65262: LD_VAR 0 4
65266: PUSH
65267: LD_VAR 0 7
65271: DIFF
65272: ST_TO_ADDR
// if tmp and mech < 6 then
65273: LD_VAR 0 4
65277: PUSH
65278: LD_VAR 0 7
65282: PUSH
65283: LD_INT 6
65285: LESS
65286: AND
65287: IFFALSE 65469
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
65289: LD_ADDR_VAR 0 9
65293: PUSH
65294: LD_VAR 0 4
65298: PUSH
65299: LD_VAR 0 7
65303: DIFF
65304: PPUSH
65305: LD_INT 3
65307: PPUSH
65308: CALL 55847 0 2
65312: ST_TO_ADDR
// p := [ ] ;
65313: LD_ADDR_VAR 0 11
65317: PUSH
65318: EMPTY
65319: ST_TO_ADDR
// if sort then
65320: LD_VAR 0 9
65324: IFFALSE 65440
// for i = 1 to 6 - mech do
65326: LD_ADDR_VAR 0 3
65330: PUSH
65331: DOUBLE
65332: LD_INT 1
65334: DEC
65335: ST_TO_ADDR
65336: LD_INT 6
65338: PUSH
65339: LD_VAR 0 7
65343: MINUS
65344: PUSH
65345: FOR_TO
65346: IFFALSE 65438
// begin if i = sort then
65348: LD_VAR 0 3
65352: PUSH
65353: LD_VAR 0 9
65357: EQUAL
65358: IFFALSE 65362
// break ;
65360: GO 65438
// if GetClass ( i ) = 3 then
65362: LD_VAR 0 3
65366: PPUSH
65367: CALL_OW 257
65371: PUSH
65372: LD_INT 3
65374: EQUAL
65375: IFFALSE 65379
// continue ;
65377: GO 65345
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65379: LD_ADDR_VAR 0 11
65383: PUSH
65384: LD_VAR 0 11
65388: PPUSH
65389: LD_VAR 0 11
65393: PUSH
65394: LD_INT 1
65396: PLUS
65397: PPUSH
65398: LD_VAR 0 9
65402: PUSH
65403: LD_VAR 0 3
65407: ARRAY
65408: PPUSH
65409: CALL_OW 2
65413: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65414: LD_ADDR_VAR 0 4
65418: PUSH
65419: LD_VAR 0 4
65423: PUSH
65424: LD_VAR 0 9
65428: PUSH
65429: LD_VAR 0 3
65433: ARRAY
65434: DIFF
65435: ST_TO_ADDR
// end ;
65436: GO 65345
65438: POP
65439: POP
// if p then
65440: LD_VAR 0 11
65444: IFFALSE 65469
// result := Replace ( result , 3 , p ) ;
65446: LD_ADDR_VAR 0 2
65450: PUSH
65451: LD_VAR 0 2
65455: PPUSH
65456: LD_INT 3
65458: PPUSH
65459: LD_VAR 0 11
65463: PPUSH
65464: CALL_OW 1
65468: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
65469: LD_ADDR_VAR 0 4
65473: PUSH
65474: LD_VAR 0 4
65478: PUSH
65479: LD_VAR 0 6
65483: DIFF
65484: ST_TO_ADDR
// if tmp and eng < 4 then
65485: LD_VAR 0 4
65489: PUSH
65490: LD_VAR 0 6
65494: PUSH
65495: LD_INT 4
65497: LESS
65498: AND
65499: IFFALSE 65689
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
65501: LD_ADDR_VAR 0 9
65505: PUSH
65506: LD_VAR 0 4
65510: PUSH
65511: LD_VAR 0 7
65515: PUSH
65516: LD_VAR 0 6
65520: UNION
65521: DIFF
65522: PPUSH
65523: LD_INT 2
65525: PPUSH
65526: CALL 55847 0 2
65530: ST_TO_ADDR
// p := [ ] ;
65531: LD_ADDR_VAR 0 11
65535: PUSH
65536: EMPTY
65537: ST_TO_ADDR
// if sort then
65538: LD_VAR 0 9
65542: IFFALSE 65658
// for i = 1 to 4 - eng do
65544: LD_ADDR_VAR 0 3
65548: PUSH
65549: DOUBLE
65550: LD_INT 1
65552: DEC
65553: ST_TO_ADDR
65554: LD_INT 4
65556: PUSH
65557: LD_VAR 0 6
65561: MINUS
65562: PUSH
65563: FOR_TO
65564: IFFALSE 65656
// begin if i = sort then
65566: LD_VAR 0 3
65570: PUSH
65571: LD_VAR 0 9
65575: EQUAL
65576: IFFALSE 65580
// break ;
65578: GO 65656
// if GetClass ( i ) = 2 then
65580: LD_VAR 0 3
65584: PPUSH
65585: CALL_OW 257
65589: PUSH
65590: LD_INT 2
65592: EQUAL
65593: IFFALSE 65597
// continue ;
65595: GO 65563
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65597: LD_ADDR_VAR 0 11
65601: PUSH
65602: LD_VAR 0 11
65606: PPUSH
65607: LD_VAR 0 11
65611: PUSH
65612: LD_INT 1
65614: PLUS
65615: PPUSH
65616: LD_VAR 0 9
65620: PUSH
65621: LD_VAR 0 3
65625: ARRAY
65626: PPUSH
65627: CALL_OW 2
65631: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65632: LD_ADDR_VAR 0 4
65636: PUSH
65637: LD_VAR 0 4
65641: PUSH
65642: LD_VAR 0 9
65646: PUSH
65647: LD_VAR 0 3
65651: ARRAY
65652: DIFF
65653: ST_TO_ADDR
// end ;
65654: GO 65563
65656: POP
65657: POP
// if p then
65658: LD_VAR 0 11
65662: IFFALSE 65687
// result := Replace ( result , 2 , p ) ;
65664: LD_ADDR_VAR 0 2
65668: PUSH
65669: LD_VAR 0 2
65673: PPUSH
65674: LD_INT 2
65676: PPUSH
65677: LD_VAR 0 11
65681: PPUSH
65682: CALL_OW 1
65686: ST_TO_ADDR
// end else
65687: GO 65733
// for i = eng downto 5 do
65689: LD_ADDR_VAR 0 3
65693: PUSH
65694: DOUBLE
65695: LD_VAR 0 6
65699: INC
65700: ST_TO_ADDR
65701: LD_INT 5
65703: PUSH
65704: FOR_DOWNTO
65705: IFFALSE 65731
// tmp := tmp union eng [ i ] ;
65707: LD_ADDR_VAR 0 4
65711: PUSH
65712: LD_VAR 0 4
65716: PUSH
65717: LD_VAR 0 6
65721: PUSH
65722: LD_VAR 0 3
65726: ARRAY
65727: UNION
65728: ST_TO_ADDR
65729: GO 65704
65731: POP
65732: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
65733: LD_ADDR_VAR 0 2
65737: PUSH
65738: LD_VAR 0 2
65742: PPUSH
65743: LD_INT 1
65745: PPUSH
65746: LD_VAR 0 4
65750: PUSH
65751: LD_VAR 0 5
65755: DIFF
65756: PPUSH
65757: CALL_OW 1
65761: ST_TO_ADDR
// exit ;
65762: GO 65764
// end ; end ;
65764: LD_VAR 0 2
65768: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65769: LD_INT 0
65771: PPUSH
65772: PPUSH
65773: PPUSH
// if not mc_bases then
65774: LD_EXP 59
65778: NOT
65779: IFFALSE 65783
// exit ;
65781: GO 65889
// for i = 1 to mc_bases do
65783: LD_ADDR_VAR 0 2
65787: PUSH
65788: DOUBLE
65789: LD_INT 1
65791: DEC
65792: ST_TO_ADDR
65793: LD_EXP 59
65797: PUSH
65798: FOR_TO
65799: IFFALSE 65880
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65801: LD_ADDR_VAR 0 3
65805: PUSH
65806: LD_EXP 59
65810: PUSH
65811: LD_VAR 0 2
65815: ARRAY
65816: PPUSH
65817: LD_INT 21
65819: PUSH
65820: LD_INT 3
65822: PUSH
65823: EMPTY
65824: LIST
65825: LIST
65826: PUSH
65827: LD_INT 3
65829: PUSH
65830: LD_INT 24
65832: PUSH
65833: LD_INT 1000
65835: PUSH
65836: EMPTY
65837: LIST
65838: LIST
65839: PUSH
65840: EMPTY
65841: LIST
65842: LIST
65843: PUSH
65844: EMPTY
65845: LIST
65846: LIST
65847: PPUSH
65848: CALL_OW 72
65852: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65853: LD_ADDR_EXP 60
65857: PUSH
65858: LD_EXP 60
65862: PPUSH
65863: LD_VAR 0 2
65867: PPUSH
65868: LD_VAR 0 3
65872: PPUSH
65873: CALL_OW 1
65877: ST_TO_ADDR
// end ;
65878: GO 65798
65880: POP
65881: POP
// RaiseSailEvent ( 101 ) ;
65882: LD_INT 101
65884: PPUSH
65885: CALL_OW 427
// end ;
65889: LD_VAR 0 1
65893: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65894: LD_INT 0
65896: PPUSH
65897: PPUSH
65898: PPUSH
65899: PPUSH
65900: PPUSH
65901: PPUSH
65902: PPUSH
// if not mc_bases then
65903: LD_EXP 59
65907: NOT
65908: IFFALSE 65912
// exit ;
65910: GO 66485
// for i = 1 to mc_bases do
65912: LD_ADDR_VAR 0 2
65916: PUSH
65917: DOUBLE
65918: LD_INT 1
65920: DEC
65921: ST_TO_ADDR
65922: LD_EXP 59
65926: PUSH
65927: FOR_TO
65928: IFFALSE 66476
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
65930: LD_ADDR_VAR 0 5
65934: PUSH
65935: LD_EXP 59
65939: PUSH
65940: LD_VAR 0 2
65944: ARRAY
65945: PUSH
65946: LD_EXP 88
65950: PUSH
65951: LD_VAR 0 2
65955: ARRAY
65956: UNION
65957: PPUSH
65958: LD_INT 21
65960: PUSH
65961: LD_INT 1
65963: PUSH
65964: EMPTY
65965: LIST
65966: LIST
65967: PUSH
65968: LD_INT 1
65970: PUSH
65971: LD_INT 3
65973: PUSH
65974: LD_INT 54
65976: PUSH
65977: EMPTY
65978: LIST
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PUSH
65984: LD_INT 3
65986: PUSH
65987: LD_INT 24
65989: PUSH
65990: LD_INT 800
65992: PUSH
65993: EMPTY
65994: LIST
65995: LIST
65996: PUSH
65997: EMPTY
65998: LIST
65999: LIST
66000: PUSH
66001: EMPTY
66002: LIST
66003: LIST
66004: LIST
66005: PUSH
66006: EMPTY
66007: LIST
66008: LIST
66009: PPUSH
66010: CALL_OW 72
66014: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
66015: LD_ADDR_VAR 0 6
66019: PUSH
66020: LD_EXP 59
66024: PUSH
66025: LD_VAR 0 2
66029: ARRAY
66030: PPUSH
66031: LD_INT 21
66033: PUSH
66034: LD_INT 1
66036: PUSH
66037: EMPTY
66038: LIST
66039: LIST
66040: PUSH
66041: LD_INT 1
66043: PUSH
66044: LD_INT 3
66046: PUSH
66047: LD_INT 54
66049: PUSH
66050: EMPTY
66051: LIST
66052: PUSH
66053: EMPTY
66054: LIST
66055: LIST
66056: PUSH
66057: LD_INT 3
66059: PUSH
66060: LD_INT 24
66062: PUSH
66063: LD_INT 250
66065: PUSH
66066: EMPTY
66067: LIST
66068: LIST
66069: PUSH
66070: EMPTY
66071: LIST
66072: LIST
66073: PUSH
66074: EMPTY
66075: LIST
66076: LIST
66077: LIST
66078: PUSH
66079: EMPTY
66080: LIST
66081: LIST
66082: PPUSH
66083: CALL_OW 72
66087: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
66088: LD_ADDR_VAR 0 7
66092: PUSH
66093: LD_VAR 0 5
66097: PUSH
66098: LD_VAR 0 6
66102: DIFF
66103: ST_TO_ADDR
// if not need_heal_1 then
66104: LD_VAR 0 6
66108: NOT
66109: IFFALSE 66142
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
66111: LD_ADDR_EXP 62
66115: PUSH
66116: LD_EXP 62
66120: PPUSH
66121: LD_VAR 0 2
66125: PUSH
66126: LD_INT 1
66128: PUSH
66129: EMPTY
66130: LIST
66131: LIST
66132: PPUSH
66133: EMPTY
66134: PPUSH
66135: CALL 21589 0 3
66139: ST_TO_ADDR
66140: GO 66212
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
66142: LD_ADDR_EXP 62
66146: PUSH
66147: LD_EXP 62
66151: PPUSH
66152: LD_VAR 0 2
66156: PUSH
66157: LD_INT 1
66159: PUSH
66160: EMPTY
66161: LIST
66162: LIST
66163: PPUSH
66164: LD_EXP 62
66168: PUSH
66169: LD_VAR 0 2
66173: ARRAY
66174: PUSH
66175: LD_INT 1
66177: ARRAY
66178: PPUSH
66179: LD_INT 3
66181: PUSH
66182: LD_INT 24
66184: PUSH
66185: LD_INT 1000
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: PUSH
66192: EMPTY
66193: LIST
66194: LIST
66195: PPUSH
66196: CALL_OW 72
66200: PUSH
66201: LD_VAR 0 6
66205: UNION
66206: PPUSH
66207: CALL 21589 0 3
66211: ST_TO_ADDR
// if not need_heal_2 then
66212: LD_VAR 0 7
66216: NOT
66217: IFFALSE 66250
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
66219: LD_ADDR_EXP 62
66223: PUSH
66224: LD_EXP 62
66228: PPUSH
66229: LD_VAR 0 2
66233: PUSH
66234: LD_INT 2
66236: PUSH
66237: EMPTY
66238: LIST
66239: LIST
66240: PPUSH
66241: EMPTY
66242: PPUSH
66243: CALL 21589 0 3
66247: ST_TO_ADDR
66248: GO 66282
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
66250: LD_ADDR_EXP 62
66254: PUSH
66255: LD_EXP 62
66259: PPUSH
66260: LD_VAR 0 2
66264: PUSH
66265: LD_INT 2
66267: PUSH
66268: EMPTY
66269: LIST
66270: LIST
66271: PPUSH
66272: LD_VAR 0 7
66276: PPUSH
66277: CALL 21589 0 3
66281: ST_TO_ADDR
// if need_heal_2 then
66282: LD_VAR 0 7
66286: IFFALSE 66458
// for j in need_heal_2 do
66288: LD_ADDR_VAR 0 3
66292: PUSH
66293: LD_VAR 0 7
66297: PUSH
66298: FOR_IN
66299: IFFALSE 66456
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
66301: LD_ADDR_VAR 0 5
66305: PUSH
66306: LD_EXP 59
66310: PUSH
66311: LD_VAR 0 2
66315: ARRAY
66316: PPUSH
66317: LD_INT 2
66319: PUSH
66320: LD_INT 30
66322: PUSH
66323: LD_INT 6
66325: PUSH
66326: EMPTY
66327: LIST
66328: LIST
66329: PUSH
66330: LD_INT 30
66332: PUSH
66333: LD_INT 7
66335: PUSH
66336: EMPTY
66337: LIST
66338: LIST
66339: PUSH
66340: LD_INT 30
66342: PUSH
66343: LD_INT 8
66345: PUSH
66346: EMPTY
66347: LIST
66348: LIST
66349: PUSH
66350: LD_INT 30
66352: PUSH
66353: LD_INT 0
66355: PUSH
66356: EMPTY
66357: LIST
66358: LIST
66359: PUSH
66360: LD_INT 30
66362: PUSH
66363: LD_INT 1
66365: PUSH
66366: EMPTY
66367: LIST
66368: LIST
66369: PUSH
66370: LD_INT 25
66372: PUSH
66373: LD_INT 4
66375: PUSH
66376: EMPTY
66377: LIST
66378: LIST
66379: PUSH
66380: EMPTY
66381: LIST
66382: LIST
66383: LIST
66384: LIST
66385: LIST
66386: LIST
66387: LIST
66388: PPUSH
66389: CALL_OW 72
66393: ST_TO_ADDR
// if tmp then
66394: LD_VAR 0 5
66398: IFFALSE 66454
// begin k := NearestUnitToUnit ( tmp , j ) ;
66400: LD_ADDR_VAR 0 4
66404: PUSH
66405: LD_VAR 0 5
66409: PPUSH
66410: LD_VAR 0 3
66414: PPUSH
66415: CALL_OW 74
66419: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
66420: LD_VAR 0 3
66424: PPUSH
66425: LD_VAR 0 4
66429: PPUSH
66430: CALL_OW 296
66434: PUSH
66435: LD_INT 7
66437: GREATER
66438: IFFALSE 66454
// ComMoveUnit ( j , k ) ;
66440: LD_VAR 0 3
66444: PPUSH
66445: LD_VAR 0 4
66449: PPUSH
66450: CALL_OW 112
// end ; end ;
66454: GO 66298
66456: POP
66457: POP
// if not need_heal_1 and not need_heal_2 then
66458: LD_VAR 0 6
66462: NOT
66463: PUSH
66464: LD_VAR 0 7
66468: NOT
66469: AND
66470: IFFALSE 66474
// continue ;
66472: GO 65927
// end ;
66474: GO 65927
66476: POP
66477: POP
// RaiseSailEvent ( 102 ) ;
66478: LD_INT 102
66480: PPUSH
66481: CALL_OW 427
// end ;
66485: LD_VAR 0 1
66489: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
66490: LD_INT 0
66492: PPUSH
66493: PPUSH
66494: PPUSH
66495: PPUSH
66496: PPUSH
66497: PPUSH
66498: PPUSH
66499: PPUSH
// if not mc_bases then
66500: LD_EXP 59
66504: NOT
66505: IFFALSE 66509
// exit ;
66507: GO 67349
// for i = 1 to mc_bases do
66509: LD_ADDR_VAR 0 2
66513: PUSH
66514: DOUBLE
66515: LD_INT 1
66517: DEC
66518: ST_TO_ADDR
66519: LD_EXP 59
66523: PUSH
66524: FOR_TO
66525: IFFALSE 67347
// begin if not mc_building_need_repair [ i ] then
66527: LD_EXP 60
66531: PUSH
66532: LD_VAR 0 2
66536: ARRAY
66537: NOT
66538: IFFALSE 66712
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
66540: LD_ADDR_VAR 0 6
66544: PUSH
66545: LD_EXP 78
66549: PUSH
66550: LD_VAR 0 2
66554: ARRAY
66555: PPUSH
66556: LD_INT 3
66558: PUSH
66559: LD_INT 24
66561: PUSH
66562: LD_INT 1000
66564: PUSH
66565: EMPTY
66566: LIST
66567: LIST
66568: PUSH
66569: EMPTY
66570: LIST
66571: LIST
66572: PUSH
66573: LD_INT 2
66575: PUSH
66576: LD_INT 34
66578: PUSH
66579: LD_INT 13
66581: PUSH
66582: EMPTY
66583: LIST
66584: LIST
66585: PUSH
66586: LD_INT 34
66588: PUSH
66589: LD_INT 52
66591: PUSH
66592: EMPTY
66593: LIST
66594: LIST
66595: PUSH
66596: EMPTY
66597: LIST
66598: LIST
66599: LIST
66600: PUSH
66601: EMPTY
66602: LIST
66603: LIST
66604: PPUSH
66605: CALL_OW 72
66609: ST_TO_ADDR
// if cranes then
66610: LD_VAR 0 6
66614: IFFALSE 66676
// for j in cranes do
66616: LD_ADDR_VAR 0 3
66620: PUSH
66621: LD_VAR 0 6
66625: PUSH
66626: FOR_IN
66627: IFFALSE 66674
// if not IsInArea ( j , mc_parking [ i ] ) then
66629: LD_VAR 0 3
66633: PPUSH
66634: LD_EXP 83
66638: PUSH
66639: LD_VAR 0 2
66643: ARRAY
66644: PPUSH
66645: CALL_OW 308
66649: NOT
66650: IFFALSE 66672
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66652: LD_VAR 0 3
66656: PPUSH
66657: LD_EXP 83
66661: PUSH
66662: LD_VAR 0 2
66666: ARRAY
66667: PPUSH
66668: CALL_OW 113
66672: GO 66626
66674: POP
66675: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
66676: LD_ADDR_EXP 61
66680: PUSH
66681: LD_EXP 61
66685: PPUSH
66686: LD_VAR 0 2
66690: PPUSH
66691: EMPTY
66692: PPUSH
66693: CALL_OW 1
66697: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
66698: LD_VAR 0 2
66702: PPUSH
66703: LD_INT 101
66705: PPUSH
66706: CALL 61602 0 2
// continue ;
66710: GO 66524
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
66712: LD_ADDR_EXP 65
66716: PUSH
66717: LD_EXP 65
66721: PPUSH
66722: LD_VAR 0 2
66726: PPUSH
66727: EMPTY
66728: PPUSH
66729: CALL_OW 1
66733: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66734: LD_VAR 0 2
66738: PPUSH
66739: LD_INT 103
66741: PPUSH
66742: CALL 61602 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
66746: LD_ADDR_VAR 0 5
66750: PUSH
66751: LD_EXP 59
66755: PUSH
66756: LD_VAR 0 2
66760: ARRAY
66761: PUSH
66762: LD_EXP 88
66766: PUSH
66767: LD_VAR 0 2
66771: ARRAY
66772: UNION
66773: PPUSH
66774: LD_INT 2
66776: PUSH
66777: LD_INT 25
66779: PUSH
66780: LD_INT 2
66782: PUSH
66783: EMPTY
66784: LIST
66785: LIST
66786: PUSH
66787: LD_INT 25
66789: PUSH
66790: LD_INT 16
66792: PUSH
66793: EMPTY
66794: LIST
66795: LIST
66796: PUSH
66797: EMPTY
66798: LIST
66799: LIST
66800: LIST
66801: PUSH
66802: EMPTY
66803: LIST
66804: PPUSH
66805: CALL_OW 72
66809: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
66810: LD_ADDR_VAR 0 6
66814: PUSH
66815: LD_EXP 78
66819: PUSH
66820: LD_VAR 0 2
66824: ARRAY
66825: PPUSH
66826: LD_INT 2
66828: PUSH
66829: LD_INT 34
66831: PUSH
66832: LD_INT 13
66834: PUSH
66835: EMPTY
66836: LIST
66837: LIST
66838: PUSH
66839: LD_INT 34
66841: PUSH
66842: LD_INT 52
66844: PUSH
66845: EMPTY
66846: LIST
66847: LIST
66848: PUSH
66849: EMPTY
66850: LIST
66851: LIST
66852: LIST
66853: PPUSH
66854: CALL_OW 72
66858: ST_TO_ADDR
// if cranes then
66859: LD_VAR 0 6
66863: IFFALSE 66999
// begin for j in cranes do
66865: LD_ADDR_VAR 0 3
66869: PUSH
66870: LD_VAR 0 6
66874: PUSH
66875: FOR_IN
66876: IFFALSE 66997
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
66878: LD_VAR 0 3
66882: PPUSH
66883: CALL_OW 256
66887: PUSH
66888: LD_INT 500
66890: GREATEREQUAL
66891: PUSH
66892: LD_VAR 0 3
66896: PPUSH
66897: CALL_OW 314
66901: NOT
66902: AND
66903: IFFALSE 66937
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
66905: LD_VAR 0 3
66909: PPUSH
66910: LD_EXP 60
66914: PUSH
66915: LD_VAR 0 2
66919: ARRAY
66920: PPUSH
66921: LD_VAR 0 3
66925: PPUSH
66926: CALL_OW 74
66930: PPUSH
66931: CALL_OW 130
66935: GO 66995
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66937: LD_VAR 0 3
66941: PPUSH
66942: CALL_OW 256
66946: PUSH
66947: LD_INT 500
66949: LESS
66950: PUSH
66951: LD_VAR 0 3
66955: PPUSH
66956: LD_EXP 83
66960: PUSH
66961: LD_VAR 0 2
66965: ARRAY
66966: PPUSH
66967: CALL_OW 308
66971: NOT
66972: AND
66973: IFFALSE 66995
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66975: LD_VAR 0 3
66979: PPUSH
66980: LD_EXP 83
66984: PUSH
66985: LD_VAR 0 2
66989: ARRAY
66990: PPUSH
66991: CALL_OW 113
66995: GO 66875
66997: POP
66998: POP
// end ; if not tmp then
66999: LD_VAR 0 5
67003: NOT
67004: IFFALSE 67008
// continue ;
67006: GO 66524
// for j in tmp do
67008: LD_ADDR_VAR 0 3
67012: PUSH
67013: LD_VAR 0 5
67017: PUSH
67018: FOR_IN
67019: IFFALSE 67343
// begin if mc_need_heal [ i ] then
67021: LD_EXP 62
67025: PUSH
67026: LD_VAR 0 2
67030: ARRAY
67031: IFFALSE 67079
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
67033: LD_VAR 0 3
67037: PUSH
67038: LD_EXP 62
67042: PUSH
67043: LD_VAR 0 2
67047: ARRAY
67048: PUSH
67049: LD_INT 1
67051: ARRAY
67052: IN
67053: PUSH
67054: LD_VAR 0 3
67058: PUSH
67059: LD_EXP 62
67063: PUSH
67064: LD_VAR 0 2
67068: ARRAY
67069: PUSH
67070: LD_INT 2
67072: ARRAY
67073: IN
67074: OR
67075: IFFALSE 67079
// continue ;
67077: GO 67018
// if IsInUnit ( j ) then
67079: LD_VAR 0 3
67083: PPUSH
67084: CALL_OW 310
67088: IFFALSE 67099
// ComExitBuilding ( j ) ;
67090: LD_VAR 0 3
67094: PPUSH
67095: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
67099: LD_VAR 0 3
67103: PUSH
67104: LD_EXP 61
67108: PUSH
67109: LD_VAR 0 2
67113: ARRAY
67114: IN
67115: NOT
67116: IFFALSE 67174
// begin SetTag ( j , 101 ) ;
67118: LD_VAR 0 3
67122: PPUSH
67123: LD_INT 101
67125: PPUSH
67126: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
67130: LD_ADDR_EXP 61
67134: PUSH
67135: LD_EXP 61
67139: PPUSH
67140: LD_VAR 0 2
67144: PUSH
67145: LD_EXP 61
67149: PUSH
67150: LD_VAR 0 2
67154: ARRAY
67155: PUSH
67156: LD_INT 1
67158: PLUS
67159: PUSH
67160: EMPTY
67161: LIST
67162: LIST
67163: PPUSH
67164: LD_VAR 0 3
67168: PPUSH
67169: CALL 21589 0 3
67173: ST_TO_ADDR
// end ; wait ( 1 ) ;
67174: LD_INT 1
67176: PPUSH
67177: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
67181: LD_ADDR_VAR 0 7
67185: PUSH
67186: LD_EXP 60
67190: PUSH
67191: LD_VAR 0 2
67195: ARRAY
67196: ST_TO_ADDR
// if mc_scan [ i ] then
67197: LD_EXP 82
67201: PUSH
67202: LD_VAR 0 2
67206: ARRAY
67207: IFFALSE 67276
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
67209: LD_ADDR_VAR 0 7
67213: PUSH
67214: LD_EXP 60
67218: PUSH
67219: LD_VAR 0 2
67223: ARRAY
67224: PPUSH
67225: LD_INT 3
67227: PUSH
67228: LD_INT 2
67230: PUSH
67231: LD_INT 30
67233: PUSH
67234: LD_INT 32
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: PUSH
67241: LD_INT 30
67243: PUSH
67244: LD_INT 33
67246: PUSH
67247: EMPTY
67248: LIST
67249: LIST
67250: PUSH
67251: LD_INT 30
67253: PUSH
67254: LD_INT 31
67256: PUSH
67257: EMPTY
67258: LIST
67259: LIST
67260: PUSH
67261: EMPTY
67262: LIST
67263: LIST
67264: LIST
67265: LIST
67266: PUSH
67267: EMPTY
67268: LIST
67269: LIST
67270: PPUSH
67271: CALL_OW 72
67275: ST_TO_ADDR
// if not to_repair_tmp then
67276: LD_VAR 0 7
67280: NOT
67281: IFFALSE 67285
// continue ;
67283: GO 67018
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
67285: LD_ADDR_VAR 0 8
67289: PUSH
67290: LD_VAR 0 7
67294: PPUSH
67295: LD_VAR 0 3
67299: PPUSH
67300: CALL_OW 74
67304: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
67305: LD_VAR 0 8
67309: PPUSH
67310: LD_INT 14
67312: PPUSH
67313: CALL 24182 0 2
67317: PUSH
67318: LD_INT 4
67320: ARRAY
67321: PUSH
67322: LD_INT 5
67324: LESS
67325: IFFALSE 67341
// ComRepairBuilding ( j , to_repair ) ;
67327: LD_VAR 0 3
67331: PPUSH
67332: LD_VAR 0 8
67336: PPUSH
67337: CALL_OW 130
// end ;
67341: GO 67018
67343: POP
67344: POP
// end ;
67345: GO 66524
67347: POP
67348: POP
// end ;
67349: LD_VAR 0 1
67353: RET
// export function MC_Heal ; var i , j , tmp ; begin
67354: LD_INT 0
67356: PPUSH
67357: PPUSH
67358: PPUSH
67359: PPUSH
// if not mc_bases then
67360: LD_EXP 59
67364: NOT
67365: IFFALSE 67369
// exit ;
67367: GO 67771
// for i = 1 to mc_bases do
67369: LD_ADDR_VAR 0 2
67373: PUSH
67374: DOUBLE
67375: LD_INT 1
67377: DEC
67378: ST_TO_ADDR
67379: LD_EXP 59
67383: PUSH
67384: FOR_TO
67385: IFFALSE 67769
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
67387: LD_EXP 62
67391: PUSH
67392: LD_VAR 0 2
67396: ARRAY
67397: PUSH
67398: LD_INT 1
67400: ARRAY
67401: NOT
67402: PUSH
67403: LD_EXP 62
67407: PUSH
67408: LD_VAR 0 2
67412: ARRAY
67413: PUSH
67414: LD_INT 2
67416: ARRAY
67417: NOT
67418: AND
67419: IFFALSE 67457
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
67421: LD_ADDR_EXP 63
67425: PUSH
67426: LD_EXP 63
67430: PPUSH
67431: LD_VAR 0 2
67435: PPUSH
67436: EMPTY
67437: PPUSH
67438: CALL_OW 1
67442: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
67443: LD_VAR 0 2
67447: PPUSH
67448: LD_INT 102
67450: PPUSH
67451: CALL 61602 0 2
// continue ;
67455: GO 67384
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67457: LD_ADDR_VAR 0 4
67461: PUSH
67462: LD_EXP 59
67466: PUSH
67467: LD_VAR 0 2
67471: ARRAY
67472: PPUSH
67473: LD_INT 25
67475: PUSH
67476: LD_INT 4
67478: PUSH
67479: EMPTY
67480: LIST
67481: LIST
67482: PPUSH
67483: CALL_OW 72
67487: ST_TO_ADDR
// if not tmp then
67488: LD_VAR 0 4
67492: NOT
67493: IFFALSE 67497
// continue ;
67495: GO 67384
// if mc_taming [ i ] then
67497: LD_EXP 90
67501: PUSH
67502: LD_VAR 0 2
67506: ARRAY
67507: IFFALSE 67531
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
67509: LD_ADDR_EXP 90
67513: PUSH
67514: LD_EXP 90
67518: PPUSH
67519: LD_VAR 0 2
67523: PPUSH
67524: EMPTY
67525: PPUSH
67526: CALL_OW 1
67530: ST_TO_ADDR
// for j in tmp do
67531: LD_ADDR_VAR 0 3
67535: PUSH
67536: LD_VAR 0 4
67540: PUSH
67541: FOR_IN
67542: IFFALSE 67765
// begin if IsInUnit ( j ) then
67544: LD_VAR 0 3
67548: PPUSH
67549: CALL_OW 310
67553: IFFALSE 67564
// ComExitBuilding ( j ) ;
67555: LD_VAR 0 3
67559: PPUSH
67560: CALL_OW 122
// if not j in mc_healers [ i ] then
67564: LD_VAR 0 3
67568: PUSH
67569: LD_EXP 63
67573: PUSH
67574: LD_VAR 0 2
67578: ARRAY
67579: IN
67580: NOT
67581: IFFALSE 67627
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
67583: LD_ADDR_EXP 63
67587: PUSH
67588: LD_EXP 63
67592: PPUSH
67593: LD_VAR 0 2
67597: PUSH
67598: LD_EXP 63
67602: PUSH
67603: LD_VAR 0 2
67607: ARRAY
67608: PUSH
67609: LD_INT 1
67611: PLUS
67612: PUSH
67613: EMPTY
67614: LIST
67615: LIST
67616: PPUSH
67617: LD_VAR 0 3
67621: PPUSH
67622: CALL 21589 0 3
67626: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
67627: LD_VAR 0 3
67631: PPUSH
67632: CALL_OW 110
67636: PUSH
67637: LD_INT 102
67639: NONEQUAL
67640: IFFALSE 67654
// SetTag ( j , 102 ) ;
67642: LD_VAR 0 3
67646: PPUSH
67647: LD_INT 102
67649: PPUSH
67650: CALL_OW 109
// Wait ( 3 ) ;
67654: LD_INT 3
67656: PPUSH
67657: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
67661: LD_EXP 62
67665: PUSH
67666: LD_VAR 0 2
67670: ARRAY
67671: PUSH
67672: LD_INT 1
67674: ARRAY
67675: IFFALSE 67707
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
67677: LD_VAR 0 3
67681: PPUSH
67682: LD_EXP 62
67686: PUSH
67687: LD_VAR 0 2
67691: ARRAY
67692: PUSH
67693: LD_INT 1
67695: ARRAY
67696: PUSH
67697: LD_INT 1
67699: ARRAY
67700: PPUSH
67701: CALL_OW 128
67705: GO 67763
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
67707: LD_VAR 0 3
67711: PPUSH
67712: CALL_OW 314
67716: NOT
67717: PUSH
67718: LD_EXP 62
67722: PUSH
67723: LD_VAR 0 2
67727: ARRAY
67728: PUSH
67729: LD_INT 2
67731: ARRAY
67732: AND
67733: IFFALSE 67763
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
67735: LD_VAR 0 3
67739: PPUSH
67740: LD_EXP 62
67744: PUSH
67745: LD_VAR 0 2
67749: ARRAY
67750: PUSH
67751: LD_INT 2
67753: ARRAY
67754: PUSH
67755: LD_INT 1
67757: ARRAY
67758: PPUSH
67759: CALL_OW 128
// end ;
67763: GO 67541
67765: POP
67766: POP
// end ;
67767: GO 67384
67769: POP
67770: POP
// end ;
67771: LD_VAR 0 1
67775: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
67776: LD_INT 0
67778: PPUSH
67779: PPUSH
67780: PPUSH
67781: PPUSH
67782: PPUSH
// if not mc_bases then
67783: LD_EXP 59
67787: NOT
67788: IFFALSE 67792
// exit ;
67790: GO 68935
// for i = 1 to mc_bases do
67792: LD_ADDR_VAR 0 2
67796: PUSH
67797: DOUBLE
67798: LD_INT 1
67800: DEC
67801: ST_TO_ADDR
67802: LD_EXP 59
67806: PUSH
67807: FOR_TO
67808: IFFALSE 68933
// begin if mc_scan [ i ] then
67810: LD_EXP 82
67814: PUSH
67815: LD_VAR 0 2
67819: ARRAY
67820: IFFALSE 67824
// continue ;
67822: GO 67807
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
67824: LD_EXP 64
67828: PUSH
67829: LD_VAR 0 2
67833: ARRAY
67834: NOT
67835: PUSH
67836: LD_EXP 66
67840: PUSH
67841: LD_VAR 0 2
67845: ARRAY
67846: NOT
67847: AND
67848: PUSH
67849: LD_EXP 65
67853: PUSH
67854: LD_VAR 0 2
67858: ARRAY
67859: AND
67860: IFFALSE 67898
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
67862: LD_ADDR_EXP 65
67866: PUSH
67867: LD_EXP 65
67871: PPUSH
67872: LD_VAR 0 2
67876: PPUSH
67877: EMPTY
67878: PPUSH
67879: CALL_OW 1
67883: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67884: LD_VAR 0 2
67888: PPUSH
67889: LD_INT 103
67891: PPUSH
67892: CALL 61602 0 2
// continue ;
67896: GO 67807
// end ; if mc_construct_list [ i ] then
67898: LD_EXP 66
67902: PUSH
67903: LD_VAR 0 2
67907: ARRAY
67908: IFFALSE 68128
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67910: LD_ADDR_VAR 0 4
67914: PUSH
67915: LD_EXP 59
67919: PUSH
67920: LD_VAR 0 2
67924: ARRAY
67925: PPUSH
67926: LD_INT 25
67928: PUSH
67929: LD_INT 2
67931: PUSH
67932: EMPTY
67933: LIST
67934: LIST
67935: PPUSH
67936: CALL_OW 72
67940: PUSH
67941: LD_EXP 61
67945: PUSH
67946: LD_VAR 0 2
67950: ARRAY
67951: DIFF
67952: ST_TO_ADDR
// if not tmp then
67953: LD_VAR 0 4
67957: NOT
67958: IFFALSE 67962
// continue ;
67960: GO 67807
// for j in tmp do
67962: LD_ADDR_VAR 0 3
67966: PUSH
67967: LD_VAR 0 4
67971: PUSH
67972: FOR_IN
67973: IFFALSE 68124
// begin if not mc_builders [ i ] then
67975: LD_EXP 65
67979: PUSH
67980: LD_VAR 0 2
67984: ARRAY
67985: NOT
67986: IFFALSE 68044
// begin SetTag ( j , 103 ) ;
67988: LD_VAR 0 3
67992: PPUSH
67993: LD_INT 103
67995: PPUSH
67996: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68000: LD_ADDR_EXP 65
68004: PUSH
68005: LD_EXP 65
68009: PPUSH
68010: LD_VAR 0 2
68014: PUSH
68015: LD_EXP 65
68019: PUSH
68020: LD_VAR 0 2
68024: ARRAY
68025: PUSH
68026: LD_INT 1
68028: PLUS
68029: PUSH
68030: EMPTY
68031: LIST
68032: LIST
68033: PPUSH
68034: LD_VAR 0 3
68038: PPUSH
68039: CALL 21589 0 3
68043: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68044: LD_VAR 0 3
68048: PPUSH
68049: CALL_OW 310
68053: IFFALSE 68064
// ComExitBuilding ( j ) ;
68055: LD_VAR 0 3
68059: PPUSH
68060: CALL_OW 122
// wait ( 3 ) ;
68064: LD_INT 3
68066: PPUSH
68067: CALL_OW 67
// if not mc_construct_list [ i ] then
68071: LD_EXP 66
68075: PUSH
68076: LD_VAR 0 2
68080: ARRAY
68081: NOT
68082: IFFALSE 68086
// break ;
68084: GO 68124
// if not HasTask ( j ) then
68086: LD_VAR 0 3
68090: PPUSH
68091: CALL_OW 314
68095: NOT
68096: IFFALSE 68122
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
68098: LD_VAR 0 3
68102: PPUSH
68103: LD_EXP 66
68107: PUSH
68108: LD_VAR 0 2
68112: ARRAY
68113: PUSH
68114: LD_INT 1
68116: ARRAY
68117: PPUSH
68118: CALL 24440 0 2
// end ;
68122: GO 67972
68124: POP
68125: POP
// end else
68126: GO 68931
// if mc_build_list [ i ] then
68128: LD_EXP 64
68132: PUSH
68133: LD_VAR 0 2
68137: ARRAY
68138: IFFALSE 68931
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68140: LD_ADDR_VAR 0 5
68144: PUSH
68145: LD_EXP 59
68149: PUSH
68150: LD_VAR 0 2
68154: ARRAY
68155: PPUSH
68156: LD_INT 2
68158: PUSH
68159: LD_INT 30
68161: PUSH
68162: LD_INT 0
68164: PUSH
68165: EMPTY
68166: LIST
68167: LIST
68168: PUSH
68169: LD_INT 30
68171: PUSH
68172: LD_INT 1
68174: PUSH
68175: EMPTY
68176: LIST
68177: LIST
68178: PUSH
68179: EMPTY
68180: LIST
68181: LIST
68182: LIST
68183: PPUSH
68184: CALL_OW 72
68188: ST_TO_ADDR
// if depot then
68189: LD_VAR 0 5
68193: IFFALSE 68211
// depot := depot [ 1 ] else
68195: LD_ADDR_VAR 0 5
68199: PUSH
68200: LD_VAR 0 5
68204: PUSH
68205: LD_INT 1
68207: ARRAY
68208: ST_TO_ADDR
68209: GO 68219
// depot := 0 ;
68211: LD_ADDR_VAR 0 5
68215: PUSH
68216: LD_INT 0
68218: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
68219: LD_EXP 64
68223: PUSH
68224: LD_VAR 0 2
68228: ARRAY
68229: PUSH
68230: LD_INT 1
68232: ARRAY
68233: PUSH
68234: LD_INT 1
68236: ARRAY
68237: PPUSH
68238: CALL 24270 0 1
68242: PUSH
68243: LD_EXP 59
68247: PUSH
68248: LD_VAR 0 2
68252: ARRAY
68253: PPUSH
68254: LD_INT 2
68256: PUSH
68257: LD_INT 30
68259: PUSH
68260: LD_INT 2
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: PUSH
68267: LD_INT 30
68269: PUSH
68270: LD_INT 3
68272: PUSH
68273: EMPTY
68274: LIST
68275: LIST
68276: PUSH
68277: EMPTY
68278: LIST
68279: LIST
68280: LIST
68281: PPUSH
68282: CALL_OW 72
68286: NOT
68287: AND
68288: IFFALSE 68393
// begin for j = 1 to mc_build_list [ i ] do
68290: LD_ADDR_VAR 0 3
68294: PUSH
68295: DOUBLE
68296: LD_INT 1
68298: DEC
68299: ST_TO_ADDR
68300: LD_EXP 64
68304: PUSH
68305: LD_VAR 0 2
68309: ARRAY
68310: PUSH
68311: FOR_TO
68312: IFFALSE 68391
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
68314: LD_EXP 64
68318: PUSH
68319: LD_VAR 0 2
68323: ARRAY
68324: PUSH
68325: LD_VAR 0 3
68329: ARRAY
68330: PUSH
68331: LD_INT 1
68333: ARRAY
68334: PUSH
68335: LD_INT 2
68337: EQUAL
68338: IFFALSE 68389
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
68340: LD_ADDR_EXP 64
68344: PUSH
68345: LD_EXP 64
68349: PPUSH
68350: LD_VAR 0 2
68354: PPUSH
68355: LD_EXP 64
68359: PUSH
68360: LD_VAR 0 2
68364: ARRAY
68365: PPUSH
68366: LD_VAR 0 3
68370: PPUSH
68371: LD_INT 1
68373: PPUSH
68374: LD_INT 0
68376: PPUSH
68377: CALL 21007 0 4
68381: PPUSH
68382: CALL_OW 1
68386: ST_TO_ADDR
// break ;
68387: GO 68391
// end ;
68389: GO 68311
68391: POP
68392: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
68393: LD_EXP 64
68397: PUSH
68398: LD_VAR 0 2
68402: ARRAY
68403: PUSH
68404: LD_INT 1
68406: ARRAY
68407: PUSH
68408: LD_INT 1
68410: ARRAY
68411: PUSH
68412: LD_INT 0
68414: EQUAL
68415: PUSH
68416: LD_VAR 0 5
68420: PUSH
68421: LD_VAR 0 5
68425: PPUSH
68426: LD_EXP 64
68430: PUSH
68431: LD_VAR 0 2
68435: ARRAY
68436: PUSH
68437: LD_INT 1
68439: ARRAY
68440: PUSH
68441: LD_INT 1
68443: ARRAY
68444: PPUSH
68445: LD_EXP 64
68449: PUSH
68450: LD_VAR 0 2
68454: ARRAY
68455: PUSH
68456: LD_INT 1
68458: ARRAY
68459: PUSH
68460: LD_INT 2
68462: ARRAY
68463: PPUSH
68464: LD_EXP 64
68468: PUSH
68469: LD_VAR 0 2
68473: ARRAY
68474: PUSH
68475: LD_INT 1
68477: ARRAY
68478: PUSH
68479: LD_INT 3
68481: ARRAY
68482: PPUSH
68483: LD_EXP 64
68487: PUSH
68488: LD_VAR 0 2
68492: ARRAY
68493: PUSH
68494: LD_INT 1
68496: ARRAY
68497: PUSH
68498: LD_INT 4
68500: ARRAY
68501: PPUSH
68502: CALL 29004 0 5
68506: AND
68507: OR
68508: IFFALSE 68789
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
68510: LD_ADDR_VAR 0 4
68514: PUSH
68515: LD_EXP 59
68519: PUSH
68520: LD_VAR 0 2
68524: ARRAY
68525: PPUSH
68526: LD_INT 25
68528: PUSH
68529: LD_INT 2
68531: PUSH
68532: EMPTY
68533: LIST
68534: LIST
68535: PPUSH
68536: CALL_OW 72
68540: PUSH
68541: LD_EXP 61
68545: PUSH
68546: LD_VAR 0 2
68550: ARRAY
68551: DIFF
68552: ST_TO_ADDR
// if not tmp then
68553: LD_VAR 0 4
68557: NOT
68558: IFFALSE 68562
// continue ;
68560: GO 67807
// for j in tmp do
68562: LD_ADDR_VAR 0 3
68566: PUSH
68567: LD_VAR 0 4
68571: PUSH
68572: FOR_IN
68573: IFFALSE 68785
// begin if not mc_builders [ i ] then
68575: LD_EXP 65
68579: PUSH
68580: LD_VAR 0 2
68584: ARRAY
68585: NOT
68586: IFFALSE 68644
// begin SetTag ( j , 103 ) ;
68588: LD_VAR 0 3
68592: PPUSH
68593: LD_INT 103
68595: PPUSH
68596: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68600: LD_ADDR_EXP 65
68604: PUSH
68605: LD_EXP 65
68609: PPUSH
68610: LD_VAR 0 2
68614: PUSH
68615: LD_EXP 65
68619: PUSH
68620: LD_VAR 0 2
68624: ARRAY
68625: PUSH
68626: LD_INT 1
68628: PLUS
68629: PUSH
68630: EMPTY
68631: LIST
68632: LIST
68633: PPUSH
68634: LD_VAR 0 3
68638: PPUSH
68639: CALL 21589 0 3
68643: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68644: LD_VAR 0 3
68648: PPUSH
68649: CALL_OW 310
68653: IFFALSE 68664
// ComExitBuilding ( j ) ;
68655: LD_VAR 0 3
68659: PPUSH
68660: CALL_OW 122
// wait ( 3 ) ;
68664: LD_INT 3
68666: PPUSH
68667: CALL_OW 67
// if not mc_build_list [ i ] then
68671: LD_EXP 64
68675: PUSH
68676: LD_VAR 0 2
68680: ARRAY
68681: NOT
68682: IFFALSE 68686
// break ;
68684: GO 68785
// if not HasTask ( j ) then
68686: LD_VAR 0 3
68690: PPUSH
68691: CALL_OW 314
68695: NOT
68696: IFFALSE 68783
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
68698: LD_VAR 0 3
68702: PPUSH
68703: LD_EXP 64
68707: PUSH
68708: LD_VAR 0 2
68712: ARRAY
68713: PUSH
68714: LD_INT 1
68716: ARRAY
68717: PUSH
68718: LD_INT 1
68720: ARRAY
68721: PPUSH
68722: LD_EXP 64
68726: PUSH
68727: LD_VAR 0 2
68731: ARRAY
68732: PUSH
68733: LD_INT 1
68735: ARRAY
68736: PUSH
68737: LD_INT 2
68739: ARRAY
68740: PPUSH
68741: LD_EXP 64
68745: PUSH
68746: LD_VAR 0 2
68750: ARRAY
68751: PUSH
68752: LD_INT 1
68754: ARRAY
68755: PUSH
68756: LD_INT 3
68758: ARRAY
68759: PPUSH
68760: LD_EXP 64
68764: PUSH
68765: LD_VAR 0 2
68769: ARRAY
68770: PUSH
68771: LD_INT 1
68773: ARRAY
68774: PUSH
68775: LD_INT 4
68777: ARRAY
68778: PPUSH
68779: CALL_OW 145
// end ;
68783: GO 68572
68785: POP
68786: POP
// end else
68787: GO 68931
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
68789: LD_EXP 59
68793: PUSH
68794: LD_VAR 0 2
68798: ARRAY
68799: PPUSH
68800: LD_EXP 64
68804: PUSH
68805: LD_VAR 0 2
68809: ARRAY
68810: PUSH
68811: LD_INT 1
68813: ARRAY
68814: PUSH
68815: LD_INT 1
68817: ARRAY
68818: PPUSH
68819: LD_EXP 64
68823: PUSH
68824: LD_VAR 0 2
68828: ARRAY
68829: PUSH
68830: LD_INT 1
68832: ARRAY
68833: PUSH
68834: LD_INT 2
68836: ARRAY
68837: PPUSH
68838: LD_EXP 64
68842: PUSH
68843: LD_VAR 0 2
68847: ARRAY
68848: PUSH
68849: LD_INT 1
68851: ARRAY
68852: PUSH
68853: LD_INT 3
68855: ARRAY
68856: PPUSH
68857: LD_EXP 64
68861: PUSH
68862: LD_VAR 0 2
68866: ARRAY
68867: PUSH
68868: LD_INT 1
68870: ARRAY
68871: PUSH
68872: LD_INT 4
68874: ARRAY
68875: PPUSH
68876: CALL 28340 0 5
68880: NOT
68881: IFFALSE 68931
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
68883: LD_ADDR_EXP 64
68887: PUSH
68888: LD_EXP 64
68892: PPUSH
68893: LD_VAR 0 2
68897: PPUSH
68898: LD_EXP 64
68902: PUSH
68903: LD_VAR 0 2
68907: ARRAY
68908: PPUSH
68909: LD_INT 1
68911: PPUSH
68912: LD_INT 1
68914: NEG
68915: PPUSH
68916: LD_INT 0
68918: PPUSH
68919: CALL 21007 0 4
68923: PPUSH
68924: CALL_OW 1
68928: ST_TO_ADDR
// continue ;
68929: GO 67807
// end ; end ; end ;
68931: GO 67807
68933: POP
68934: POP
// end ;
68935: LD_VAR 0 1
68939: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
68940: LD_INT 0
68942: PPUSH
68943: PPUSH
68944: PPUSH
68945: PPUSH
68946: PPUSH
68947: PPUSH
// if not mc_bases then
68948: LD_EXP 59
68952: NOT
68953: IFFALSE 68957
// exit ;
68955: GO 69384
// for i = 1 to mc_bases do
68957: LD_ADDR_VAR 0 2
68961: PUSH
68962: DOUBLE
68963: LD_INT 1
68965: DEC
68966: ST_TO_ADDR
68967: LD_EXP 59
68971: PUSH
68972: FOR_TO
68973: IFFALSE 69382
// begin tmp := mc_build_upgrade [ i ] ;
68975: LD_ADDR_VAR 0 4
68979: PUSH
68980: LD_EXP 91
68984: PUSH
68985: LD_VAR 0 2
68989: ARRAY
68990: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68991: LD_ADDR_VAR 0 6
68995: PUSH
68996: LD_EXP 92
69000: PUSH
69001: LD_VAR 0 2
69005: ARRAY
69006: PPUSH
69007: LD_INT 2
69009: PUSH
69010: LD_INT 30
69012: PUSH
69013: LD_INT 6
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: PUSH
69020: LD_INT 30
69022: PUSH
69023: LD_INT 7
69025: PUSH
69026: EMPTY
69027: LIST
69028: LIST
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: LIST
69034: PPUSH
69035: CALL_OW 72
69039: ST_TO_ADDR
// if not tmp and not lab then
69040: LD_VAR 0 4
69044: NOT
69045: PUSH
69046: LD_VAR 0 6
69050: NOT
69051: AND
69052: IFFALSE 69056
// continue ;
69054: GO 68972
// if tmp then
69056: LD_VAR 0 4
69060: IFFALSE 69180
// for j in tmp do
69062: LD_ADDR_VAR 0 3
69066: PUSH
69067: LD_VAR 0 4
69071: PUSH
69072: FOR_IN
69073: IFFALSE 69178
// begin if UpgradeCost ( j ) then
69075: LD_VAR 0 3
69079: PPUSH
69080: CALL 28000 0 1
69084: IFFALSE 69176
// begin ComUpgrade ( j ) ;
69086: LD_VAR 0 3
69090: PPUSH
69091: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
69095: LD_ADDR_EXP 91
69099: PUSH
69100: LD_EXP 91
69104: PPUSH
69105: LD_VAR 0 2
69109: PPUSH
69110: LD_EXP 91
69114: PUSH
69115: LD_VAR 0 2
69119: ARRAY
69120: PUSH
69121: LD_VAR 0 3
69125: DIFF
69126: PPUSH
69127: CALL_OW 1
69131: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69132: LD_ADDR_EXP 66
69136: PUSH
69137: LD_EXP 66
69141: PPUSH
69142: LD_VAR 0 2
69146: PUSH
69147: LD_EXP 66
69151: PUSH
69152: LD_VAR 0 2
69156: ARRAY
69157: PUSH
69158: LD_INT 1
69160: PLUS
69161: PUSH
69162: EMPTY
69163: LIST
69164: LIST
69165: PPUSH
69166: LD_VAR 0 3
69170: PPUSH
69171: CALL 21589 0 3
69175: ST_TO_ADDR
// end ; end ;
69176: GO 69072
69178: POP
69179: POP
// if not lab or not mc_lab_upgrade [ i ] then
69180: LD_VAR 0 6
69184: NOT
69185: PUSH
69186: LD_EXP 93
69190: PUSH
69191: LD_VAR 0 2
69195: ARRAY
69196: NOT
69197: OR
69198: IFFALSE 69202
// continue ;
69200: GO 68972
// for j in lab do
69202: LD_ADDR_VAR 0 3
69206: PUSH
69207: LD_VAR 0 6
69211: PUSH
69212: FOR_IN
69213: IFFALSE 69378
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
69215: LD_VAR 0 3
69219: PPUSH
69220: CALL_OW 266
69224: PUSH
69225: LD_INT 6
69227: PUSH
69228: LD_INT 7
69230: PUSH
69231: EMPTY
69232: LIST
69233: LIST
69234: IN
69235: PUSH
69236: LD_VAR 0 3
69240: PPUSH
69241: CALL_OW 461
69245: PUSH
69246: LD_INT 1
69248: NONEQUAL
69249: AND
69250: IFFALSE 69376
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
69252: LD_VAR 0 3
69256: PPUSH
69257: LD_EXP 93
69261: PUSH
69262: LD_VAR 0 2
69266: ARRAY
69267: PUSH
69268: LD_INT 1
69270: ARRAY
69271: PPUSH
69272: CALL 28205 0 2
69276: IFFALSE 69376
// begin ComCancel ( j ) ;
69278: LD_VAR 0 3
69282: PPUSH
69283: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
69287: LD_VAR 0 3
69291: PPUSH
69292: LD_EXP 93
69296: PUSH
69297: LD_VAR 0 2
69301: ARRAY
69302: PUSH
69303: LD_INT 1
69305: ARRAY
69306: PPUSH
69307: CALL_OW 207
// if not j in mc_construct_list [ i ] then
69311: LD_VAR 0 3
69315: PUSH
69316: LD_EXP 66
69320: PUSH
69321: LD_VAR 0 2
69325: ARRAY
69326: IN
69327: NOT
69328: IFFALSE 69374
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69330: LD_ADDR_EXP 66
69334: PUSH
69335: LD_EXP 66
69339: PPUSH
69340: LD_VAR 0 2
69344: PUSH
69345: LD_EXP 66
69349: PUSH
69350: LD_VAR 0 2
69354: ARRAY
69355: PUSH
69356: LD_INT 1
69358: PLUS
69359: PUSH
69360: EMPTY
69361: LIST
69362: LIST
69363: PPUSH
69364: LD_VAR 0 3
69368: PPUSH
69369: CALL 21589 0 3
69373: ST_TO_ADDR
// break ;
69374: GO 69378
// end ; end ; end ;
69376: GO 69212
69378: POP
69379: POP
// end ;
69380: GO 68972
69382: POP
69383: POP
// end ;
69384: LD_VAR 0 1
69388: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
69389: LD_INT 0
69391: PPUSH
69392: PPUSH
69393: PPUSH
69394: PPUSH
69395: PPUSH
69396: PPUSH
69397: PPUSH
69398: PPUSH
69399: PPUSH
// if not mc_bases then
69400: LD_EXP 59
69404: NOT
69405: IFFALSE 69409
// exit ;
69407: GO 69814
// for i = 1 to mc_bases do
69409: LD_ADDR_VAR 0 2
69413: PUSH
69414: DOUBLE
69415: LD_INT 1
69417: DEC
69418: ST_TO_ADDR
69419: LD_EXP 59
69423: PUSH
69424: FOR_TO
69425: IFFALSE 69812
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
69427: LD_EXP 67
69431: PUSH
69432: LD_VAR 0 2
69436: ARRAY
69437: NOT
69438: PUSH
69439: LD_EXP 59
69443: PUSH
69444: LD_VAR 0 2
69448: ARRAY
69449: PPUSH
69450: LD_INT 30
69452: PUSH
69453: LD_INT 3
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PPUSH
69460: CALL_OW 72
69464: NOT
69465: OR
69466: IFFALSE 69470
// continue ;
69468: GO 69424
// busy := false ;
69470: LD_ADDR_VAR 0 8
69474: PUSH
69475: LD_INT 0
69477: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69478: LD_ADDR_VAR 0 4
69482: PUSH
69483: LD_EXP 59
69487: PUSH
69488: LD_VAR 0 2
69492: ARRAY
69493: PPUSH
69494: LD_INT 30
69496: PUSH
69497: LD_INT 3
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: PPUSH
69504: CALL_OW 72
69508: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
69509: LD_ADDR_VAR 0 6
69513: PUSH
69514: LD_EXP 67
69518: PUSH
69519: LD_VAR 0 2
69523: ARRAY
69524: PPUSH
69525: LD_INT 2
69527: PUSH
69528: LD_INT 30
69530: PUSH
69531: LD_INT 32
69533: PUSH
69534: EMPTY
69535: LIST
69536: LIST
69537: PUSH
69538: LD_INT 30
69540: PUSH
69541: LD_INT 33
69543: PUSH
69544: EMPTY
69545: LIST
69546: LIST
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: LIST
69552: PPUSH
69553: CALL_OW 72
69557: ST_TO_ADDR
// if not t then
69558: LD_VAR 0 6
69562: NOT
69563: IFFALSE 69567
// continue ;
69565: GO 69424
// for j in tmp do
69567: LD_ADDR_VAR 0 3
69571: PUSH
69572: LD_VAR 0 4
69576: PUSH
69577: FOR_IN
69578: IFFALSE 69608
// if not BuildingStatus ( j ) = bs_idle then
69580: LD_VAR 0 3
69584: PPUSH
69585: CALL_OW 461
69589: PUSH
69590: LD_INT 2
69592: EQUAL
69593: NOT
69594: IFFALSE 69606
// begin busy := true ;
69596: LD_ADDR_VAR 0 8
69600: PUSH
69601: LD_INT 1
69603: ST_TO_ADDR
// break ;
69604: GO 69608
// end ;
69606: GO 69577
69608: POP
69609: POP
// if busy then
69610: LD_VAR 0 8
69614: IFFALSE 69618
// continue ;
69616: GO 69424
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
69618: LD_ADDR_VAR 0 7
69622: PUSH
69623: LD_VAR 0 6
69627: PPUSH
69628: LD_INT 35
69630: PUSH
69631: LD_INT 0
69633: PUSH
69634: EMPTY
69635: LIST
69636: LIST
69637: PPUSH
69638: CALL_OW 72
69642: ST_TO_ADDR
// if tw then
69643: LD_VAR 0 7
69647: IFFALSE 69724
// begin tw := tw [ 1 ] ;
69649: LD_ADDR_VAR 0 7
69653: PUSH
69654: LD_VAR 0 7
69658: PUSH
69659: LD_INT 1
69661: ARRAY
69662: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
69663: LD_ADDR_VAR 0 9
69667: PUSH
69668: LD_VAR 0 7
69672: PPUSH
69673: LD_EXP 84
69677: PUSH
69678: LD_VAR 0 2
69682: ARRAY
69683: PPUSH
69684: CALL 26559 0 2
69688: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
69689: LD_EXP 98
69693: PUSH
69694: LD_VAR 0 2
69698: ARRAY
69699: IFFALSE 69722
// if not weapon in mc_allowed_tower_weapons [ i ] then
69701: LD_VAR 0 9
69705: PUSH
69706: LD_EXP 98
69710: PUSH
69711: LD_VAR 0 2
69715: ARRAY
69716: IN
69717: NOT
69718: IFFALSE 69722
// continue ;
69720: GO 69424
// end else
69722: GO 69787
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
69724: LD_ADDR_VAR 0 5
69728: PUSH
69729: LD_EXP 67
69733: PUSH
69734: LD_VAR 0 2
69738: ARRAY
69739: PPUSH
69740: LD_VAR 0 4
69744: PPUSH
69745: CALL 56770 0 2
69749: ST_TO_ADDR
// if not tmp2 then
69750: LD_VAR 0 5
69754: NOT
69755: IFFALSE 69759
// continue ;
69757: GO 69424
// tw := tmp2 [ 1 ] ;
69759: LD_ADDR_VAR 0 7
69763: PUSH
69764: LD_VAR 0 5
69768: PUSH
69769: LD_INT 1
69771: ARRAY
69772: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
69773: LD_ADDR_VAR 0 9
69777: PUSH
69778: LD_VAR 0 5
69782: PUSH
69783: LD_INT 2
69785: ARRAY
69786: ST_TO_ADDR
// end ; if not weapon then
69787: LD_VAR 0 9
69791: NOT
69792: IFFALSE 69796
// continue ;
69794: GO 69424
// ComPlaceWeapon ( tw , weapon ) ;
69796: LD_VAR 0 7
69800: PPUSH
69801: LD_VAR 0 9
69805: PPUSH
69806: CALL_OW 148
// end ;
69810: GO 69424
69812: POP
69813: POP
// end ;
69814: LD_VAR 0 1
69818: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
69819: LD_INT 0
69821: PPUSH
69822: PPUSH
69823: PPUSH
69824: PPUSH
69825: PPUSH
69826: PPUSH
// if not mc_bases then
69827: LD_EXP 59
69831: NOT
69832: IFFALSE 69836
// exit ;
69834: GO 70612
// for i = 1 to mc_bases do
69836: LD_ADDR_VAR 0 2
69840: PUSH
69841: DOUBLE
69842: LD_INT 1
69844: DEC
69845: ST_TO_ADDR
69846: LD_EXP 59
69850: PUSH
69851: FOR_TO
69852: IFFALSE 70610
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
69854: LD_EXP 72
69858: PUSH
69859: LD_VAR 0 2
69863: ARRAY
69864: NOT
69865: PUSH
69866: LD_EXP 72
69870: PUSH
69871: LD_VAR 0 2
69875: ARRAY
69876: PUSH
69877: LD_EXP 73
69881: PUSH
69882: LD_VAR 0 2
69886: ARRAY
69887: EQUAL
69888: OR
69889: PUSH
69890: LD_EXP 82
69894: PUSH
69895: LD_VAR 0 2
69899: ARRAY
69900: OR
69901: IFFALSE 69905
// continue ;
69903: GO 69851
// if mc_miners [ i ] then
69905: LD_EXP 73
69909: PUSH
69910: LD_VAR 0 2
69914: ARRAY
69915: IFFALSE 70297
// begin for j = mc_miners [ i ] downto 1 do
69917: LD_ADDR_VAR 0 3
69921: PUSH
69922: DOUBLE
69923: LD_EXP 73
69927: PUSH
69928: LD_VAR 0 2
69932: ARRAY
69933: INC
69934: ST_TO_ADDR
69935: LD_INT 1
69937: PUSH
69938: FOR_DOWNTO
69939: IFFALSE 70295
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
69941: LD_EXP 73
69945: PUSH
69946: LD_VAR 0 2
69950: ARRAY
69951: PUSH
69952: LD_VAR 0 3
69956: ARRAY
69957: PPUSH
69958: CALL_OW 301
69962: PUSH
69963: LD_EXP 73
69967: PUSH
69968: LD_VAR 0 2
69972: ARRAY
69973: PUSH
69974: LD_VAR 0 3
69978: ARRAY
69979: PPUSH
69980: CALL_OW 257
69984: PUSH
69985: LD_INT 1
69987: NONEQUAL
69988: OR
69989: IFFALSE 70052
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69991: LD_ADDR_VAR 0 5
69995: PUSH
69996: LD_EXP 73
70000: PUSH
70001: LD_VAR 0 2
70005: ARRAY
70006: PUSH
70007: LD_EXP 73
70011: PUSH
70012: LD_VAR 0 2
70016: ARRAY
70017: PUSH
70018: LD_VAR 0 3
70022: ARRAY
70023: DIFF
70024: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
70025: LD_ADDR_EXP 73
70029: PUSH
70030: LD_EXP 73
70034: PPUSH
70035: LD_VAR 0 2
70039: PPUSH
70040: LD_VAR 0 5
70044: PPUSH
70045: CALL_OW 1
70049: ST_TO_ADDR
// continue ;
70050: GO 69938
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
70052: LD_EXP 73
70056: PUSH
70057: LD_VAR 0 2
70061: ARRAY
70062: PUSH
70063: LD_VAR 0 3
70067: ARRAY
70068: PPUSH
70069: CALL_OW 257
70073: PUSH
70074: LD_INT 1
70076: EQUAL
70077: PUSH
70078: LD_EXP 73
70082: PUSH
70083: LD_VAR 0 2
70087: ARRAY
70088: PUSH
70089: LD_VAR 0 3
70093: ARRAY
70094: PPUSH
70095: CALL_OW 459
70099: NOT
70100: AND
70101: PUSH
70102: LD_EXP 73
70106: PUSH
70107: LD_VAR 0 2
70111: ARRAY
70112: PUSH
70113: LD_VAR 0 3
70117: ARRAY
70118: PPUSH
70119: CALL_OW 314
70123: NOT
70124: AND
70125: IFFALSE 70293
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
70127: LD_EXP 73
70131: PUSH
70132: LD_VAR 0 2
70136: ARRAY
70137: PUSH
70138: LD_VAR 0 3
70142: ARRAY
70143: PPUSH
70144: CALL_OW 310
70148: IFFALSE 70171
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
70150: LD_EXP 73
70154: PUSH
70155: LD_VAR 0 2
70159: ARRAY
70160: PUSH
70161: LD_VAR 0 3
70165: ARRAY
70166: PPUSH
70167: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
70171: LD_EXP 73
70175: PUSH
70176: LD_VAR 0 2
70180: ARRAY
70181: PUSH
70182: LD_VAR 0 3
70186: ARRAY
70187: PPUSH
70188: CALL_OW 314
70192: NOT
70193: IFFALSE 70293
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
70195: LD_EXP 73
70199: PUSH
70200: LD_VAR 0 2
70204: ARRAY
70205: PUSH
70206: LD_VAR 0 3
70210: ARRAY
70211: PPUSH
70212: LD_EXP 72
70216: PUSH
70217: LD_VAR 0 2
70221: ARRAY
70222: PUSH
70223: LD_VAR 0 3
70227: PUSH
70228: LD_EXP 72
70232: PUSH
70233: LD_VAR 0 2
70237: ARRAY
70238: MOD
70239: PUSH
70240: LD_INT 1
70242: PLUS
70243: ARRAY
70244: PUSH
70245: LD_INT 1
70247: ARRAY
70248: PPUSH
70249: LD_EXP 72
70253: PUSH
70254: LD_VAR 0 2
70258: ARRAY
70259: PUSH
70260: LD_VAR 0 3
70264: PUSH
70265: LD_EXP 72
70269: PUSH
70270: LD_VAR 0 2
70274: ARRAY
70275: MOD
70276: PUSH
70277: LD_INT 1
70279: PLUS
70280: ARRAY
70281: PUSH
70282: LD_INT 2
70284: ARRAY
70285: PPUSH
70286: LD_INT 0
70288: PPUSH
70289: CALL_OW 193
// end ; end ;
70293: GO 69938
70295: POP
70296: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
70297: LD_ADDR_VAR 0 5
70301: PUSH
70302: LD_EXP 59
70306: PUSH
70307: LD_VAR 0 2
70311: ARRAY
70312: PPUSH
70313: LD_INT 2
70315: PUSH
70316: LD_INT 30
70318: PUSH
70319: LD_INT 4
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: PUSH
70326: LD_INT 30
70328: PUSH
70329: LD_INT 5
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: PUSH
70336: LD_INT 30
70338: PUSH
70339: LD_INT 32
70341: PUSH
70342: EMPTY
70343: LIST
70344: LIST
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: LIST
70350: LIST
70351: PPUSH
70352: CALL_OW 72
70356: ST_TO_ADDR
// if not tmp then
70357: LD_VAR 0 5
70361: NOT
70362: IFFALSE 70366
// continue ;
70364: GO 69851
// list := [ ] ;
70366: LD_ADDR_VAR 0 6
70370: PUSH
70371: EMPTY
70372: ST_TO_ADDR
// for j in tmp do
70373: LD_ADDR_VAR 0 3
70377: PUSH
70378: LD_VAR 0 5
70382: PUSH
70383: FOR_IN
70384: IFFALSE 70453
// begin for k in UnitsInside ( j ) do
70386: LD_ADDR_VAR 0 4
70390: PUSH
70391: LD_VAR 0 3
70395: PPUSH
70396: CALL_OW 313
70400: PUSH
70401: FOR_IN
70402: IFFALSE 70449
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
70404: LD_VAR 0 4
70408: PPUSH
70409: CALL_OW 257
70413: PUSH
70414: LD_INT 1
70416: EQUAL
70417: PUSH
70418: LD_VAR 0 4
70422: PPUSH
70423: CALL_OW 459
70427: NOT
70428: AND
70429: IFFALSE 70447
// list := list ^ k ;
70431: LD_ADDR_VAR 0 6
70435: PUSH
70436: LD_VAR 0 6
70440: PUSH
70441: LD_VAR 0 4
70445: ADD
70446: ST_TO_ADDR
70447: GO 70401
70449: POP
70450: POP
// end ;
70451: GO 70383
70453: POP
70454: POP
// list := list diff mc_miners [ i ] ;
70455: LD_ADDR_VAR 0 6
70459: PUSH
70460: LD_VAR 0 6
70464: PUSH
70465: LD_EXP 73
70469: PUSH
70470: LD_VAR 0 2
70474: ARRAY
70475: DIFF
70476: ST_TO_ADDR
// if not list then
70477: LD_VAR 0 6
70481: NOT
70482: IFFALSE 70486
// continue ;
70484: GO 69851
// k := mc_mines [ i ] - mc_miners [ i ] ;
70486: LD_ADDR_VAR 0 4
70490: PUSH
70491: LD_EXP 72
70495: PUSH
70496: LD_VAR 0 2
70500: ARRAY
70501: PUSH
70502: LD_EXP 73
70506: PUSH
70507: LD_VAR 0 2
70511: ARRAY
70512: MINUS
70513: ST_TO_ADDR
// if k > list then
70514: LD_VAR 0 4
70518: PUSH
70519: LD_VAR 0 6
70523: GREATER
70524: IFFALSE 70536
// k := list ;
70526: LD_ADDR_VAR 0 4
70530: PUSH
70531: LD_VAR 0 6
70535: ST_TO_ADDR
// for j = 1 to k do
70536: LD_ADDR_VAR 0 3
70540: PUSH
70541: DOUBLE
70542: LD_INT 1
70544: DEC
70545: ST_TO_ADDR
70546: LD_VAR 0 4
70550: PUSH
70551: FOR_TO
70552: IFFALSE 70606
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
70554: LD_ADDR_EXP 73
70558: PUSH
70559: LD_EXP 73
70563: PPUSH
70564: LD_VAR 0 2
70568: PUSH
70569: LD_EXP 73
70573: PUSH
70574: LD_VAR 0 2
70578: ARRAY
70579: PUSH
70580: LD_INT 1
70582: PLUS
70583: PUSH
70584: EMPTY
70585: LIST
70586: LIST
70587: PPUSH
70588: LD_VAR 0 6
70592: PUSH
70593: LD_VAR 0 3
70597: ARRAY
70598: PPUSH
70599: CALL 21589 0 3
70603: ST_TO_ADDR
70604: GO 70551
70606: POP
70607: POP
// end ;
70608: GO 69851
70610: POP
70611: POP
// end ;
70612: LD_VAR 0 1
70616: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
70617: LD_INT 0
70619: PPUSH
70620: PPUSH
70621: PPUSH
70622: PPUSH
70623: PPUSH
70624: PPUSH
70625: PPUSH
70626: PPUSH
70627: PPUSH
70628: PPUSH
// if not mc_bases then
70629: LD_EXP 59
70633: NOT
70634: IFFALSE 70638
// exit ;
70636: GO 72388
// for i = 1 to mc_bases do
70638: LD_ADDR_VAR 0 2
70642: PUSH
70643: DOUBLE
70644: LD_INT 1
70646: DEC
70647: ST_TO_ADDR
70648: LD_EXP 59
70652: PUSH
70653: FOR_TO
70654: IFFALSE 72386
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70656: LD_EXP 59
70660: PUSH
70661: LD_VAR 0 2
70665: ARRAY
70666: NOT
70667: PUSH
70668: LD_EXP 66
70672: PUSH
70673: LD_VAR 0 2
70677: ARRAY
70678: OR
70679: IFFALSE 70683
// continue ;
70681: GO 70653
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70683: LD_EXP 75
70687: PUSH
70688: LD_VAR 0 2
70692: ARRAY
70693: NOT
70694: PUSH
70695: LD_EXP 76
70699: PUSH
70700: LD_VAR 0 2
70704: ARRAY
70705: AND
70706: IFFALSE 70744
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70708: LD_ADDR_EXP 76
70712: PUSH
70713: LD_EXP 76
70717: PPUSH
70718: LD_VAR 0 2
70722: PPUSH
70723: EMPTY
70724: PPUSH
70725: CALL_OW 1
70729: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70730: LD_VAR 0 2
70734: PPUSH
70735: LD_INT 107
70737: PPUSH
70738: CALL 61602 0 2
// continue ;
70742: GO 70653
// end ; target := [ ] ;
70744: LD_ADDR_VAR 0 6
70748: PUSH
70749: EMPTY
70750: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70751: LD_ADDR_VAR 0 3
70755: PUSH
70756: DOUBLE
70757: LD_EXP 75
70761: PUSH
70762: LD_VAR 0 2
70766: ARRAY
70767: INC
70768: ST_TO_ADDR
70769: LD_INT 1
70771: PUSH
70772: FOR_DOWNTO
70773: IFFALSE 71033
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70775: LD_EXP 75
70779: PUSH
70780: LD_VAR 0 2
70784: ARRAY
70785: PUSH
70786: LD_VAR 0 3
70790: ARRAY
70791: PUSH
70792: LD_INT 2
70794: ARRAY
70795: PPUSH
70796: LD_EXP 75
70800: PUSH
70801: LD_VAR 0 2
70805: ARRAY
70806: PUSH
70807: LD_VAR 0 3
70811: ARRAY
70812: PUSH
70813: LD_INT 3
70815: ARRAY
70816: PPUSH
70817: CALL_OW 488
70821: PUSH
70822: LD_EXP 75
70826: PUSH
70827: LD_VAR 0 2
70831: ARRAY
70832: PUSH
70833: LD_VAR 0 3
70837: ARRAY
70838: PUSH
70839: LD_INT 2
70841: ARRAY
70842: PPUSH
70843: LD_EXP 75
70847: PUSH
70848: LD_VAR 0 2
70852: ARRAY
70853: PUSH
70854: LD_VAR 0 3
70858: ARRAY
70859: PUSH
70860: LD_INT 3
70862: ARRAY
70863: PPUSH
70864: CALL_OW 284
70868: PUSH
70869: LD_INT 0
70871: EQUAL
70872: AND
70873: IFFALSE 70928
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70875: LD_ADDR_VAR 0 5
70879: PUSH
70880: LD_EXP 75
70884: PUSH
70885: LD_VAR 0 2
70889: ARRAY
70890: PPUSH
70891: LD_VAR 0 3
70895: PPUSH
70896: CALL_OW 3
70900: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70901: LD_ADDR_EXP 75
70905: PUSH
70906: LD_EXP 75
70910: PPUSH
70911: LD_VAR 0 2
70915: PPUSH
70916: LD_VAR 0 5
70920: PPUSH
70921: CALL_OW 1
70925: ST_TO_ADDR
// continue ;
70926: GO 70772
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70928: LD_EXP 59
70932: PUSH
70933: LD_VAR 0 2
70937: ARRAY
70938: PUSH
70939: LD_INT 1
70941: ARRAY
70942: PPUSH
70943: CALL_OW 255
70947: PPUSH
70948: LD_EXP 75
70952: PUSH
70953: LD_VAR 0 2
70957: ARRAY
70958: PUSH
70959: LD_VAR 0 3
70963: ARRAY
70964: PUSH
70965: LD_INT 2
70967: ARRAY
70968: PPUSH
70969: LD_EXP 75
70973: PUSH
70974: LD_VAR 0 2
70978: ARRAY
70979: PUSH
70980: LD_VAR 0 3
70984: ARRAY
70985: PUSH
70986: LD_INT 3
70988: ARRAY
70989: PPUSH
70990: LD_INT 30
70992: PPUSH
70993: CALL 22485 0 4
70997: PUSH
70998: LD_INT 4
71000: ARRAY
71001: PUSH
71002: LD_INT 0
71004: EQUAL
71005: IFFALSE 71031
// begin target := mc_crates [ i ] [ j ] ;
71007: LD_ADDR_VAR 0 6
71011: PUSH
71012: LD_EXP 75
71016: PUSH
71017: LD_VAR 0 2
71021: ARRAY
71022: PUSH
71023: LD_VAR 0 3
71027: ARRAY
71028: ST_TO_ADDR
// break ;
71029: GO 71033
// end ; end ;
71031: GO 70772
71033: POP
71034: POP
// if not target then
71035: LD_VAR 0 6
71039: NOT
71040: IFFALSE 71044
// continue ;
71042: GO 70653
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
71044: LD_ADDR_VAR 0 7
71048: PUSH
71049: LD_EXP 78
71053: PUSH
71054: LD_VAR 0 2
71058: ARRAY
71059: PPUSH
71060: LD_INT 2
71062: PUSH
71063: LD_INT 3
71065: PUSH
71066: LD_INT 58
71068: PUSH
71069: EMPTY
71070: LIST
71071: PUSH
71072: EMPTY
71073: LIST
71074: LIST
71075: PUSH
71076: LD_INT 61
71078: PUSH
71079: EMPTY
71080: LIST
71081: PUSH
71082: LD_INT 33
71084: PUSH
71085: LD_INT 5
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: PUSH
71092: LD_INT 33
71094: PUSH
71095: LD_INT 3
71097: PUSH
71098: EMPTY
71099: LIST
71100: LIST
71101: PUSH
71102: EMPTY
71103: LIST
71104: LIST
71105: LIST
71106: LIST
71107: LIST
71108: PUSH
71109: LD_INT 2
71111: PUSH
71112: LD_INT 34
71114: PUSH
71115: LD_INT 32
71117: PUSH
71118: EMPTY
71119: LIST
71120: LIST
71121: PUSH
71122: LD_INT 34
71124: PUSH
71125: LD_INT 51
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: PUSH
71132: LD_INT 34
71134: PUSH
71135: LD_INT 12
71137: PUSH
71138: EMPTY
71139: LIST
71140: LIST
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: LIST
71146: LIST
71147: PUSH
71148: EMPTY
71149: LIST
71150: LIST
71151: PPUSH
71152: CALL_OW 72
71156: ST_TO_ADDR
// if not cargo then
71157: LD_VAR 0 7
71161: NOT
71162: IFFALSE 71805
// begin if mc_crates_collector [ i ] < 5 then
71164: LD_EXP 76
71168: PUSH
71169: LD_VAR 0 2
71173: ARRAY
71174: PUSH
71175: LD_INT 5
71177: LESS
71178: IFFALSE 71544
// begin if mc_ape [ i ] then
71180: LD_EXP 88
71184: PUSH
71185: LD_VAR 0 2
71189: ARRAY
71190: IFFALSE 71237
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
71192: LD_ADDR_VAR 0 5
71196: PUSH
71197: LD_EXP 88
71201: PUSH
71202: LD_VAR 0 2
71206: ARRAY
71207: PPUSH
71208: LD_INT 25
71210: PUSH
71211: LD_INT 16
71213: PUSH
71214: EMPTY
71215: LIST
71216: LIST
71217: PUSH
71218: LD_INT 24
71220: PUSH
71221: LD_INT 750
71223: PUSH
71224: EMPTY
71225: LIST
71226: LIST
71227: PUSH
71228: EMPTY
71229: LIST
71230: LIST
71231: PPUSH
71232: CALL_OW 72
71236: ST_TO_ADDR
// if not tmp then
71237: LD_VAR 0 5
71241: NOT
71242: IFFALSE 71289
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
71244: LD_ADDR_VAR 0 5
71248: PUSH
71249: LD_EXP 59
71253: PUSH
71254: LD_VAR 0 2
71258: ARRAY
71259: PPUSH
71260: LD_INT 25
71262: PUSH
71263: LD_INT 2
71265: PUSH
71266: EMPTY
71267: LIST
71268: LIST
71269: PUSH
71270: LD_INT 24
71272: PUSH
71273: LD_INT 750
71275: PUSH
71276: EMPTY
71277: LIST
71278: LIST
71279: PUSH
71280: EMPTY
71281: LIST
71282: LIST
71283: PPUSH
71284: CALL_OW 72
71288: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
71289: LD_EXP 88
71293: PUSH
71294: LD_VAR 0 2
71298: ARRAY
71299: PUSH
71300: LD_EXP 59
71304: PUSH
71305: LD_VAR 0 2
71309: ARRAY
71310: PPUSH
71311: LD_INT 25
71313: PUSH
71314: LD_INT 2
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 24
71323: PUSH
71324: LD_INT 750
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: PUSH
71331: EMPTY
71332: LIST
71333: LIST
71334: PPUSH
71335: CALL_OW 72
71339: AND
71340: PUSH
71341: LD_VAR 0 5
71345: PUSH
71346: LD_INT 5
71348: LESS
71349: AND
71350: IFFALSE 71432
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
71352: LD_ADDR_VAR 0 3
71356: PUSH
71357: LD_EXP 59
71361: PUSH
71362: LD_VAR 0 2
71366: ARRAY
71367: PPUSH
71368: LD_INT 25
71370: PUSH
71371: LD_INT 2
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: PUSH
71378: LD_INT 24
71380: PUSH
71381: LD_INT 750
71383: PUSH
71384: EMPTY
71385: LIST
71386: LIST
71387: PUSH
71388: EMPTY
71389: LIST
71390: LIST
71391: PPUSH
71392: CALL_OW 72
71396: PUSH
71397: FOR_IN
71398: IFFALSE 71430
// begin tmp := tmp union j ;
71400: LD_ADDR_VAR 0 5
71404: PUSH
71405: LD_VAR 0 5
71409: PUSH
71410: LD_VAR 0 3
71414: UNION
71415: ST_TO_ADDR
// if tmp >= 5 then
71416: LD_VAR 0 5
71420: PUSH
71421: LD_INT 5
71423: GREATEREQUAL
71424: IFFALSE 71428
// break ;
71426: GO 71430
// end ;
71428: GO 71397
71430: POP
71431: POP
// end ; if not tmp then
71432: LD_VAR 0 5
71436: NOT
71437: IFFALSE 71441
// continue ;
71439: GO 70653
// for j in tmp do
71441: LD_ADDR_VAR 0 3
71445: PUSH
71446: LD_VAR 0 5
71450: PUSH
71451: FOR_IN
71452: IFFALSE 71542
// if not GetTag ( j ) then
71454: LD_VAR 0 3
71458: PPUSH
71459: CALL_OW 110
71463: NOT
71464: IFFALSE 71540
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
71466: LD_ADDR_EXP 76
71470: PUSH
71471: LD_EXP 76
71475: PPUSH
71476: LD_VAR 0 2
71480: PUSH
71481: LD_EXP 76
71485: PUSH
71486: LD_VAR 0 2
71490: ARRAY
71491: PUSH
71492: LD_INT 1
71494: PLUS
71495: PUSH
71496: EMPTY
71497: LIST
71498: LIST
71499: PPUSH
71500: LD_VAR 0 3
71504: PPUSH
71505: CALL 21589 0 3
71509: ST_TO_ADDR
// SetTag ( j , 107 ) ;
71510: LD_VAR 0 3
71514: PPUSH
71515: LD_INT 107
71517: PPUSH
71518: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
71522: LD_EXP 76
71526: PUSH
71527: LD_VAR 0 2
71531: ARRAY
71532: PUSH
71533: LD_INT 5
71535: GREATEREQUAL
71536: IFFALSE 71540
// break ;
71538: GO 71542
// end ;
71540: GO 71451
71542: POP
71543: POP
// end ; if mc_crates_collector [ i ] and target then
71544: LD_EXP 76
71548: PUSH
71549: LD_VAR 0 2
71553: ARRAY
71554: PUSH
71555: LD_VAR 0 6
71559: AND
71560: IFFALSE 71803
// begin if mc_crates_collector [ i ] < target [ 1 ] then
71562: LD_EXP 76
71566: PUSH
71567: LD_VAR 0 2
71571: ARRAY
71572: PUSH
71573: LD_VAR 0 6
71577: PUSH
71578: LD_INT 1
71580: ARRAY
71581: LESS
71582: IFFALSE 71602
// tmp := mc_crates_collector [ i ] else
71584: LD_ADDR_VAR 0 5
71588: PUSH
71589: LD_EXP 76
71593: PUSH
71594: LD_VAR 0 2
71598: ARRAY
71599: ST_TO_ADDR
71600: GO 71616
// tmp := target [ 1 ] ;
71602: LD_ADDR_VAR 0 5
71606: PUSH
71607: LD_VAR 0 6
71611: PUSH
71612: LD_INT 1
71614: ARRAY
71615: ST_TO_ADDR
// k := 0 ;
71616: LD_ADDR_VAR 0 4
71620: PUSH
71621: LD_INT 0
71623: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
71624: LD_ADDR_VAR 0 3
71628: PUSH
71629: LD_EXP 76
71633: PUSH
71634: LD_VAR 0 2
71638: ARRAY
71639: PUSH
71640: FOR_IN
71641: IFFALSE 71801
// begin k := k + 1 ;
71643: LD_ADDR_VAR 0 4
71647: PUSH
71648: LD_VAR 0 4
71652: PUSH
71653: LD_INT 1
71655: PLUS
71656: ST_TO_ADDR
// if k > tmp then
71657: LD_VAR 0 4
71661: PUSH
71662: LD_VAR 0 5
71666: GREATER
71667: IFFALSE 71671
// break ;
71669: GO 71801
// if not GetClass ( j ) in [ 2 , 16 ] then
71671: LD_VAR 0 3
71675: PPUSH
71676: CALL_OW 257
71680: PUSH
71681: LD_INT 2
71683: PUSH
71684: LD_INT 16
71686: PUSH
71687: EMPTY
71688: LIST
71689: LIST
71690: IN
71691: NOT
71692: IFFALSE 71745
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71694: LD_ADDR_EXP 76
71698: PUSH
71699: LD_EXP 76
71703: PPUSH
71704: LD_VAR 0 2
71708: PPUSH
71709: LD_EXP 76
71713: PUSH
71714: LD_VAR 0 2
71718: ARRAY
71719: PUSH
71720: LD_VAR 0 3
71724: DIFF
71725: PPUSH
71726: CALL_OW 1
71730: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71731: LD_VAR 0 3
71735: PPUSH
71736: LD_INT 0
71738: PPUSH
71739: CALL_OW 109
// continue ;
71743: GO 71640
// end ; if IsInUnit ( j ) then
71745: LD_VAR 0 3
71749: PPUSH
71750: CALL_OW 310
71754: IFFALSE 71765
// ComExitBuilding ( j ) ;
71756: LD_VAR 0 3
71760: PPUSH
71761: CALL_OW 122
// wait ( 3 ) ;
71765: LD_INT 3
71767: PPUSH
71768: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71772: LD_VAR 0 3
71776: PPUSH
71777: LD_VAR 0 6
71781: PUSH
71782: LD_INT 2
71784: ARRAY
71785: PPUSH
71786: LD_VAR 0 6
71790: PUSH
71791: LD_INT 3
71793: ARRAY
71794: PPUSH
71795: CALL_OW 117
// end ;
71799: GO 71640
71801: POP
71802: POP
// end ; end else
71803: GO 72384
// begin for j in cargo do
71805: LD_ADDR_VAR 0 3
71809: PUSH
71810: LD_VAR 0 7
71814: PUSH
71815: FOR_IN
71816: IFFALSE 72382
// begin if GetTag ( j ) <> 0 then
71818: LD_VAR 0 3
71822: PPUSH
71823: CALL_OW 110
71827: PUSH
71828: LD_INT 0
71830: NONEQUAL
71831: IFFALSE 71835
// continue ;
71833: GO 71815
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71835: LD_VAR 0 3
71839: PPUSH
71840: CALL_OW 256
71844: PUSH
71845: LD_INT 1000
71847: LESS
71848: PUSH
71849: LD_VAR 0 3
71853: PPUSH
71854: LD_EXP 83
71858: PUSH
71859: LD_VAR 0 2
71863: ARRAY
71864: PPUSH
71865: CALL_OW 308
71869: NOT
71870: AND
71871: IFFALSE 71893
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71873: LD_VAR 0 3
71877: PPUSH
71878: LD_EXP 83
71882: PUSH
71883: LD_VAR 0 2
71887: ARRAY
71888: PPUSH
71889: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71893: LD_VAR 0 3
71897: PPUSH
71898: CALL_OW 256
71902: PUSH
71903: LD_INT 1000
71905: LESS
71906: PUSH
71907: LD_VAR 0 3
71911: PPUSH
71912: LD_EXP 83
71916: PUSH
71917: LD_VAR 0 2
71921: ARRAY
71922: PPUSH
71923: CALL_OW 308
71927: AND
71928: IFFALSE 71932
// continue ;
71930: GO 71815
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71932: LD_VAR 0 3
71936: PPUSH
71937: CALL_OW 262
71941: PUSH
71942: LD_INT 2
71944: EQUAL
71945: PUSH
71946: LD_VAR 0 3
71950: PPUSH
71951: CALL_OW 261
71955: PUSH
71956: LD_INT 15
71958: LESS
71959: AND
71960: IFFALSE 71964
// continue ;
71962: GO 71815
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71964: LD_VAR 0 3
71968: PPUSH
71969: CALL_OW 262
71973: PUSH
71974: LD_INT 1
71976: EQUAL
71977: PUSH
71978: LD_VAR 0 3
71982: PPUSH
71983: CALL_OW 261
71987: PUSH
71988: LD_INT 10
71990: LESS
71991: AND
71992: IFFALSE 72321
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71994: LD_ADDR_VAR 0 8
71998: PUSH
71999: LD_EXP 59
72003: PUSH
72004: LD_VAR 0 2
72008: ARRAY
72009: PPUSH
72010: LD_INT 2
72012: PUSH
72013: LD_INT 30
72015: PUSH
72016: LD_INT 0
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PUSH
72023: LD_INT 30
72025: PUSH
72026: LD_INT 1
72028: PUSH
72029: EMPTY
72030: LIST
72031: LIST
72032: PUSH
72033: EMPTY
72034: LIST
72035: LIST
72036: LIST
72037: PPUSH
72038: CALL_OW 72
72042: ST_TO_ADDR
// if not depot then
72043: LD_VAR 0 8
72047: NOT
72048: IFFALSE 72052
// continue ;
72050: GO 71815
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
72052: LD_VAR 0 3
72056: PPUSH
72057: LD_VAR 0 8
72061: PPUSH
72062: LD_VAR 0 3
72066: PPUSH
72067: CALL_OW 74
72071: PPUSH
72072: CALL_OW 296
72076: PUSH
72077: LD_INT 6
72079: LESS
72080: IFFALSE 72096
// SetFuel ( j , 100 ) else
72082: LD_VAR 0 3
72086: PPUSH
72087: LD_INT 100
72089: PPUSH
72090: CALL_OW 240
72094: GO 72321
// if GetFuel ( j ) = 0 then
72096: LD_VAR 0 3
72100: PPUSH
72101: CALL_OW 261
72105: PUSH
72106: LD_INT 0
72108: EQUAL
72109: IFFALSE 72321
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
72111: LD_ADDR_EXP 78
72115: PUSH
72116: LD_EXP 78
72120: PPUSH
72121: LD_VAR 0 2
72125: PPUSH
72126: LD_EXP 78
72130: PUSH
72131: LD_VAR 0 2
72135: ARRAY
72136: PUSH
72137: LD_VAR 0 3
72141: DIFF
72142: PPUSH
72143: CALL_OW 1
72147: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
72148: LD_VAR 0 3
72152: PPUSH
72153: CALL_OW 263
72157: PUSH
72158: LD_INT 1
72160: EQUAL
72161: IFFALSE 72177
// ComExitVehicle ( IsInUnit ( j ) ) ;
72163: LD_VAR 0 3
72167: PPUSH
72168: CALL_OW 310
72172: PPUSH
72173: CALL_OW 121
// if GetControl ( j ) = control_remote then
72177: LD_VAR 0 3
72181: PPUSH
72182: CALL_OW 263
72186: PUSH
72187: LD_INT 2
72189: EQUAL
72190: IFFALSE 72201
// ComUnlink ( j ) ;
72192: LD_VAR 0 3
72196: PPUSH
72197: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
72201: LD_ADDR_VAR 0 9
72205: PUSH
72206: LD_VAR 0 2
72210: PPUSH
72211: LD_INT 3
72213: PPUSH
72214: CALL 81674 0 2
72218: ST_TO_ADDR
// if fac then
72219: LD_VAR 0 9
72223: IFFALSE 72319
// begin for k in fac do
72225: LD_ADDR_VAR 0 4
72229: PUSH
72230: LD_VAR 0 9
72234: PUSH
72235: FOR_IN
72236: IFFALSE 72317
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
72238: LD_ADDR_VAR 0 10
72242: PUSH
72243: LD_VAR 0 9
72247: PPUSH
72248: LD_VAR 0 3
72252: PPUSH
72253: CALL_OW 265
72257: PPUSH
72258: LD_VAR 0 3
72262: PPUSH
72263: CALL_OW 262
72267: PPUSH
72268: LD_VAR 0 3
72272: PPUSH
72273: CALL_OW 263
72277: PPUSH
72278: LD_VAR 0 3
72282: PPUSH
72283: CALL_OW 264
72287: PPUSH
72288: CALL 19121 0 5
72292: ST_TO_ADDR
// if components then
72293: LD_VAR 0 10
72297: IFFALSE 72315
// begin MC_InsertProduceList ( i , components ) ;
72299: LD_VAR 0 2
72303: PPUSH
72304: LD_VAR 0 10
72308: PPUSH
72309: CALL 81219 0 2
// break ;
72313: GO 72317
// end ; end ;
72315: GO 72235
72317: POP
72318: POP
// end ; continue ;
72319: GO 71815
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
72321: LD_VAR 0 3
72325: PPUSH
72326: LD_INT 1
72328: PPUSH
72329: CALL_OW 289
72333: PUSH
72334: LD_INT 100
72336: LESS
72337: PUSH
72338: LD_VAR 0 3
72342: PPUSH
72343: CALL_OW 314
72347: NOT
72348: AND
72349: IFFALSE 72378
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
72351: LD_VAR 0 3
72355: PPUSH
72356: LD_VAR 0 6
72360: PUSH
72361: LD_INT 2
72363: ARRAY
72364: PPUSH
72365: LD_VAR 0 6
72369: PUSH
72370: LD_INT 3
72372: ARRAY
72373: PPUSH
72374: CALL_OW 117
// break ;
72378: GO 72382
// end ;
72380: GO 71815
72382: POP
72383: POP
// end ; end ;
72384: GO 70653
72386: POP
72387: POP
// end ;
72388: LD_VAR 0 1
72392: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
72393: LD_INT 0
72395: PPUSH
72396: PPUSH
72397: PPUSH
72398: PPUSH
// if not mc_bases then
72399: LD_EXP 59
72403: NOT
72404: IFFALSE 72408
// exit ;
72406: GO 72569
// for i = 1 to mc_bases do
72408: LD_ADDR_VAR 0 2
72412: PUSH
72413: DOUBLE
72414: LD_INT 1
72416: DEC
72417: ST_TO_ADDR
72418: LD_EXP 59
72422: PUSH
72423: FOR_TO
72424: IFFALSE 72567
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
72426: LD_ADDR_VAR 0 4
72430: PUSH
72431: LD_EXP 78
72435: PUSH
72436: LD_VAR 0 2
72440: ARRAY
72441: PUSH
72442: LD_EXP 81
72446: PUSH
72447: LD_VAR 0 2
72451: ARRAY
72452: UNION
72453: PPUSH
72454: LD_INT 33
72456: PUSH
72457: LD_INT 2
72459: PUSH
72460: EMPTY
72461: LIST
72462: LIST
72463: PPUSH
72464: CALL_OW 72
72468: ST_TO_ADDR
// if tmp then
72469: LD_VAR 0 4
72473: IFFALSE 72565
// for j in tmp do
72475: LD_ADDR_VAR 0 3
72479: PUSH
72480: LD_VAR 0 4
72484: PUSH
72485: FOR_IN
72486: IFFALSE 72563
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
72488: LD_VAR 0 3
72492: PPUSH
72493: CALL_OW 312
72497: NOT
72498: PUSH
72499: LD_VAR 0 3
72503: PPUSH
72504: CALL_OW 256
72508: PUSH
72509: LD_INT 250
72511: GREATEREQUAL
72512: AND
72513: IFFALSE 72526
// Connect ( j ) else
72515: LD_VAR 0 3
72519: PPUSH
72520: CALL 24522 0 1
72524: GO 72561
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
72526: LD_VAR 0 3
72530: PPUSH
72531: CALL_OW 256
72535: PUSH
72536: LD_INT 250
72538: LESS
72539: PUSH
72540: LD_VAR 0 3
72544: PPUSH
72545: CALL_OW 312
72549: AND
72550: IFFALSE 72561
// ComUnlink ( j ) ;
72552: LD_VAR 0 3
72556: PPUSH
72557: CALL_OW 136
72561: GO 72485
72563: POP
72564: POP
// end ;
72565: GO 72423
72567: POP
72568: POP
// end ;
72569: LD_VAR 0 1
72573: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
72574: LD_INT 0
72576: PPUSH
72577: PPUSH
72578: PPUSH
72579: PPUSH
72580: PPUSH
// if not mc_bases then
72581: LD_EXP 59
72585: NOT
72586: IFFALSE 72590
// exit ;
72588: GO 73035
// for i = 1 to mc_bases do
72590: LD_ADDR_VAR 0 2
72594: PUSH
72595: DOUBLE
72596: LD_INT 1
72598: DEC
72599: ST_TO_ADDR
72600: LD_EXP 59
72604: PUSH
72605: FOR_TO
72606: IFFALSE 73033
// begin if not mc_produce [ i ] then
72608: LD_EXP 80
72612: PUSH
72613: LD_VAR 0 2
72617: ARRAY
72618: NOT
72619: IFFALSE 72623
// continue ;
72621: GO 72605
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72623: LD_ADDR_VAR 0 5
72627: PUSH
72628: LD_EXP 59
72632: PUSH
72633: LD_VAR 0 2
72637: ARRAY
72638: PPUSH
72639: LD_INT 30
72641: PUSH
72642: LD_INT 3
72644: PUSH
72645: EMPTY
72646: LIST
72647: LIST
72648: PPUSH
72649: CALL_OW 72
72653: ST_TO_ADDR
// if not fac then
72654: LD_VAR 0 5
72658: NOT
72659: IFFALSE 72663
// continue ;
72661: GO 72605
// for j in fac do
72663: LD_ADDR_VAR 0 3
72667: PUSH
72668: LD_VAR 0 5
72672: PUSH
72673: FOR_IN
72674: IFFALSE 73029
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72676: LD_VAR 0 3
72680: PPUSH
72681: CALL_OW 461
72685: PUSH
72686: LD_INT 2
72688: NONEQUAL
72689: PUSH
72690: LD_VAR 0 3
72694: PPUSH
72695: LD_INT 15
72697: PPUSH
72698: CALL 24182 0 2
72702: PUSH
72703: LD_INT 4
72705: ARRAY
72706: OR
72707: IFFALSE 72711
// continue ;
72709: GO 72673
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72711: LD_VAR 0 3
72715: PPUSH
72716: LD_EXP 80
72720: PUSH
72721: LD_VAR 0 2
72725: ARRAY
72726: PUSH
72727: LD_INT 1
72729: ARRAY
72730: PUSH
72731: LD_INT 1
72733: ARRAY
72734: PPUSH
72735: LD_EXP 80
72739: PUSH
72740: LD_VAR 0 2
72744: ARRAY
72745: PUSH
72746: LD_INT 1
72748: ARRAY
72749: PUSH
72750: LD_INT 2
72752: ARRAY
72753: PPUSH
72754: LD_EXP 80
72758: PUSH
72759: LD_VAR 0 2
72763: ARRAY
72764: PUSH
72765: LD_INT 1
72767: ARRAY
72768: PUSH
72769: LD_INT 3
72771: ARRAY
72772: PPUSH
72773: LD_EXP 80
72777: PUSH
72778: LD_VAR 0 2
72782: ARRAY
72783: PUSH
72784: LD_INT 1
72786: ARRAY
72787: PUSH
72788: LD_INT 4
72790: ARRAY
72791: PPUSH
72792: CALL_OW 448
72796: PUSH
72797: LD_VAR 0 3
72801: PPUSH
72802: LD_EXP 80
72806: PUSH
72807: LD_VAR 0 2
72811: ARRAY
72812: PUSH
72813: LD_INT 1
72815: ARRAY
72816: PUSH
72817: LD_INT 1
72819: ARRAY
72820: PUSH
72821: LD_EXP 80
72825: PUSH
72826: LD_VAR 0 2
72830: ARRAY
72831: PUSH
72832: LD_INT 1
72834: ARRAY
72835: PUSH
72836: LD_INT 2
72838: ARRAY
72839: PUSH
72840: LD_EXP 80
72844: PUSH
72845: LD_VAR 0 2
72849: ARRAY
72850: PUSH
72851: LD_INT 1
72853: ARRAY
72854: PUSH
72855: LD_INT 3
72857: ARRAY
72858: PUSH
72859: LD_EXP 80
72863: PUSH
72864: LD_VAR 0 2
72868: ARRAY
72869: PUSH
72870: LD_INT 1
72872: ARRAY
72873: PUSH
72874: LD_INT 4
72876: ARRAY
72877: PUSH
72878: EMPTY
72879: LIST
72880: LIST
72881: LIST
72882: LIST
72883: PPUSH
72884: CALL 27853 0 2
72888: AND
72889: IFFALSE 73027
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72891: LD_VAR 0 3
72895: PPUSH
72896: LD_EXP 80
72900: PUSH
72901: LD_VAR 0 2
72905: ARRAY
72906: PUSH
72907: LD_INT 1
72909: ARRAY
72910: PUSH
72911: LD_INT 1
72913: ARRAY
72914: PPUSH
72915: LD_EXP 80
72919: PUSH
72920: LD_VAR 0 2
72924: ARRAY
72925: PUSH
72926: LD_INT 1
72928: ARRAY
72929: PUSH
72930: LD_INT 2
72932: ARRAY
72933: PPUSH
72934: LD_EXP 80
72938: PUSH
72939: LD_VAR 0 2
72943: ARRAY
72944: PUSH
72945: LD_INT 1
72947: ARRAY
72948: PUSH
72949: LD_INT 3
72951: ARRAY
72952: PPUSH
72953: LD_EXP 80
72957: PUSH
72958: LD_VAR 0 2
72962: ARRAY
72963: PUSH
72964: LD_INT 1
72966: ARRAY
72967: PUSH
72968: LD_INT 4
72970: ARRAY
72971: PPUSH
72972: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72976: LD_ADDR_VAR 0 4
72980: PUSH
72981: LD_EXP 80
72985: PUSH
72986: LD_VAR 0 2
72990: ARRAY
72991: PPUSH
72992: LD_INT 1
72994: PPUSH
72995: CALL_OW 3
72999: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
73000: LD_ADDR_EXP 80
73004: PUSH
73005: LD_EXP 80
73009: PPUSH
73010: LD_VAR 0 2
73014: PPUSH
73015: LD_VAR 0 4
73019: PPUSH
73020: CALL_OW 1
73024: ST_TO_ADDR
// break ;
73025: GO 73029
// end ; end ;
73027: GO 72673
73029: POP
73030: POP
// end ;
73031: GO 72605
73033: POP
73034: POP
// end ;
73035: LD_VAR 0 1
73039: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
73040: LD_INT 0
73042: PPUSH
73043: PPUSH
73044: PPUSH
// if not mc_bases then
73045: LD_EXP 59
73049: NOT
73050: IFFALSE 73054
// exit ;
73052: GO 73143
// for i = 1 to mc_bases do
73054: LD_ADDR_VAR 0 2
73058: PUSH
73059: DOUBLE
73060: LD_INT 1
73062: DEC
73063: ST_TO_ADDR
73064: LD_EXP 59
73068: PUSH
73069: FOR_TO
73070: IFFALSE 73141
// begin if mc_attack [ i ] then
73072: LD_EXP 79
73076: PUSH
73077: LD_VAR 0 2
73081: ARRAY
73082: IFFALSE 73139
// begin tmp := mc_attack [ i ] [ 1 ] ;
73084: LD_ADDR_VAR 0 3
73088: PUSH
73089: LD_EXP 79
73093: PUSH
73094: LD_VAR 0 2
73098: ARRAY
73099: PUSH
73100: LD_INT 1
73102: ARRAY
73103: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
73104: LD_ADDR_EXP 79
73108: PUSH
73109: LD_EXP 79
73113: PPUSH
73114: LD_VAR 0 2
73118: PPUSH
73119: EMPTY
73120: PPUSH
73121: CALL_OW 1
73125: ST_TO_ADDR
// Attack ( tmp ) ;
73126: LD_VAR 0 3
73130: PPUSH
73131: CALL 50043 0 1
// exit ;
73135: POP
73136: POP
73137: GO 73143
// end ; end ;
73139: GO 73069
73141: POP
73142: POP
// end ;
73143: LD_VAR 0 1
73147: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
73148: LD_INT 0
73150: PPUSH
73151: PPUSH
73152: PPUSH
73153: PPUSH
73154: PPUSH
73155: PPUSH
73156: PPUSH
// if not mc_bases then
73157: LD_EXP 59
73161: NOT
73162: IFFALSE 73166
// exit ;
73164: GO 73748
// for i = 1 to mc_bases do
73166: LD_ADDR_VAR 0 2
73170: PUSH
73171: DOUBLE
73172: LD_INT 1
73174: DEC
73175: ST_TO_ADDR
73176: LD_EXP 59
73180: PUSH
73181: FOR_TO
73182: IFFALSE 73746
// begin if not mc_bases [ i ] then
73184: LD_EXP 59
73188: PUSH
73189: LD_VAR 0 2
73193: ARRAY
73194: NOT
73195: IFFALSE 73199
// continue ;
73197: GO 73181
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
73199: LD_ADDR_VAR 0 7
73203: PUSH
73204: LD_EXP 59
73208: PUSH
73209: LD_VAR 0 2
73213: ARRAY
73214: PUSH
73215: LD_INT 1
73217: ARRAY
73218: PPUSH
73219: CALL 18425 0 1
73223: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
73224: LD_ADDR_EXP 82
73228: PUSH
73229: LD_EXP 82
73233: PPUSH
73234: LD_VAR 0 2
73238: PPUSH
73239: LD_EXP 59
73243: PUSH
73244: LD_VAR 0 2
73248: ARRAY
73249: PUSH
73250: LD_INT 1
73252: ARRAY
73253: PPUSH
73254: CALL_OW 255
73258: PPUSH
73259: LD_EXP 84
73263: PUSH
73264: LD_VAR 0 2
73268: ARRAY
73269: PPUSH
73270: CALL 15979 0 2
73274: PPUSH
73275: CALL_OW 1
73279: ST_TO_ADDR
// if not mc_scan [ i ] then
73280: LD_EXP 82
73284: PUSH
73285: LD_VAR 0 2
73289: ARRAY
73290: NOT
73291: IFFALSE 73446
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73293: LD_ADDR_VAR 0 4
73297: PUSH
73298: LD_EXP 59
73302: PUSH
73303: LD_VAR 0 2
73307: ARRAY
73308: PPUSH
73309: LD_INT 2
73311: PUSH
73312: LD_INT 25
73314: PUSH
73315: LD_INT 5
73317: PUSH
73318: EMPTY
73319: LIST
73320: LIST
73321: PUSH
73322: LD_INT 25
73324: PUSH
73325: LD_INT 8
73327: PUSH
73328: EMPTY
73329: LIST
73330: LIST
73331: PUSH
73332: LD_INT 25
73334: PUSH
73335: LD_INT 9
73337: PUSH
73338: EMPTY
73339: LIST
73340: LIST
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: LIST
73346: LIST
73347: PPUSH
73348: CALL_OW 72
73352: ST_TO_ADDR
// if not tmp then
73353: LD_VAR 0 4
73357: NOT
73358: IFFALSE 73362
// continue ;
73360: GO 73181
// for j in tmp do
73362: LD_ADDR_VAR 0 3
73366: PUSH
73367: LD_VAR 0 4
73371: PUSH
73372: FOR_IN
73373: IFFALSE 73444
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
73375: LD_VAR 0 3
73379: PPUSH
73380: CALL_OW 310
73384: PPUSH
73385: CALL_OW 266
73389: PUSH
73390: LD_INT 5
73392: EQUAL
73393: PUSH
73394: LD_VAR 0 3
73398: PPUSH
73399: CALL_OW 257
73403: PUSH
73404: LD_INT 1
73406: EQUAL
73407: AND
73408: PUSH
73409: LD_VAR 0 3
73413: PPUSH
73414: CALL_OW 459
73418: NOT
73419: AND
73420: PUSH
73421: LD_VAR 0 7
73425: AND
73426: IFFALSE 73442
// ComChangeProfession ( j , class ) ;
73428: LD_VAR 0 3
73432: PPUSH
73433: LD_VAR 0 7
73437: PPUSH
73438: CALL_OW 123
73442: GO 73372
73444: POP
73445: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
73446: LD_EXP 82
73450: PUSH
73451: LD_VAR 0 2
73455: ARRAY
73456: PUSH
73457: LD_EXP 81
73461: PUSH
73462: LD_VAR 0 2
73466: ARRAY
73467: NOT
73468: AND
73469: PUSH
73470: LD_EXP 59
73474: PUSH
73475: LD_VAR 0 2
73479: ARRAY
73480: PPUSH
73481: LD_INT 30
73483: PUSH
73484: LD_INT 32
73486: PUSH
73487: EMPTY
73488: LIST
73489: LIST
73490: PPUSH
73491: CALL_OW 72
73495: NOT
73496: AND
73497: PUSH
73498: LD_EXP 59
73502: PUSH
73503: LD_VAR 0 2
73507: ARRAY
73508: PPUSH
73509: LD_INT 2
73511: PUSH
73512: LD_INT 30
73514: PUSH
73515: LD_INT 4
73517: PUSH
73518: EMPTY
73519: LIST
73520: LIST
73521: PUSH
73522: LD_INT 30
73524: PUSH
73525: LD_INT 5
73527: PUSH
73528: EMPTY
73529: LIST
73530: LIST
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: LIST
73536: PPUSH
73537: CALL_OW 72
73541: NOT
73542: AND
73543: IFFALSE 73675
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73545: LD_ADDR_VAR 0 4
73549: PUSH
73550: LD_EXP 59
73554: PUSH
73555: LD_VAR 0 2
73559: ARRAY
73560: PPUSH
73561: LD_INT 2
73563: PUSH
73564: LD_INT 25
73566: PUSH
73567: LD_INT 1
73569: PUSH
73570: EMPTY
73571: LIST
73572: LIST
73573: PUSH
73574: LD_INT 25
73576: PUSH
73577: LD_INT 5
73579: PUSH
73580: EMPTY
73581: LIST
73582: LIST
73583: PUSH
73584: LD_INT 25
73586: PUSH
73587: LD_INT 8
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: LD_INT 25
73596: PUSH
73597: LD_INT 9
73599: PUSH
73600: EMPTY
73601: LIST
73602: LIST
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: LIST
73608: LIST
73609: LIST
73610: PPUSH
73611: CALL_OW 72
73615: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
73616: LD_ADDR_VAR 0 4
73620: PUSH
73621: LD_VAR 0 4
73625: PUSH
73626: LD_VAR 0 4
73630: PPUSH
73631: LD_INT 18
73633: PPUSH
73634: CALL 54859 0 2
73638: DIFF
73639: ST_TO_ADDR
// if tmp then
73640: LD_VAR 0 4
73644: IFFALSE 73675
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
73646: LD_VAR 0 2
73650: PPUSH
73651: LD_VAR 0 4
73655: PPUSH
73656: LD_EXP 84
73660: PUSH
73661: LD_VAR 0 2
73665: ARRAY
73666: PPUSH
73667: CALL 16014 0 3
// exit ;
73671: POP
73672: POP
73673: GO 73748
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
73675: LD_EXP 82
73679: PUSH
73680: LD_VAR 0 2
73684: ARRAY
73685: PUSH
73686: LD_EXP 81
73690: PUSH
73691: LD_VAR 0 2
73695: ARRAY
73696: AND
73697: IFFALSE 73744
// begin tmp := mc_defender [ i ] ;
73699: LD_ADDR_VAR 0 4
73703: PUSH
73704: LD_EXP 81
73708: PUSH
73709: LD_VAR 0 2
73713: ARRAY
73714: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
73715: LD_VAR 0 2
73719: PPUSH
73720: LD_VAR 0 4
73724: PPUSH
73725: LD_EXP 82
73729: PUSH
73730: LD_VAR 0 2
73734: ARRAY
73735: PPUSH
73736: CALL 16575 0 3
// exit ;
73740: POP
73741: POP
73742: GO 73748
// end ; end ;
73744: GO 73181
73746: POP
73747: POP
// end ;
73748: LD_VAR 0 1
73752: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73753: LD_INT 0
73755: PPUSH
73756: PPUSH
73757: PPUSH
73758: PPUSH
73759: PPUSH
73760: PPUSH
73761: PPUSH
73762: PPUSH
73763: PPUSH
73764: PPUSH
73765: PPUSH
// if not mc_bases then
73766: LD_EXP 59
73770: NOT
73771: IFFALSE 73775
// exit ;
73773: GO 74862
// for i = 1 to mc_bases do
73775: LD_ADDR_VAR 0 2
73779: PUSH
73780: DOUBLE
73781: LD_INT 1
73783: DEC
73784: ST_TO_ADDR
73785: LD_EXP 59
73789: PUSH
73790: FOR_TO
73791: IFFALSE 74860
// begin tmp := mc_lab [ i ] ;
73793: LD_ADDR_VAR 0 6
73797: PUSH
73798: LD_EXP 92
73802: PUSH
73803: LD_VAR 0 2
73807: ARRAY
73808: ST_TO_ADDR
// if not tmp then
73809: LD_VAR 0 6
73813: NOT
73814: IFFALSE 73818
// continue ;
73816: GO 73790
// idle_lab := 0 ;
73818: LD_ADDR_VAR 0 11
73822: PUSH
73823: LD_INT 0
73825: ST_TO_ADDR
// for j in tmp do
73826: LD_ADDR_VAR 0 3
73830: PUSH
73831: LD_VAR 0 6
73835: PUSH
73836: FOR_IN
73837: IFFALSE 74856
// begin researching := false ;
73839: LD_ADDR_VAR 0 10
73843: PUSH
73844: LD_INT 0
73846: ST_TO_ADDR
// side := GetSide ( j ) ;
73847: LD_ADDR_VAR 0 4
73851: PUSH
73852: LD_VAR 0 3
73856: PPUSH
73857: CALL_OW 255
73861: ST_TO_ADDR
// if not mc_tech [ side ] then
73862: LD_EXP 86
73866: PUSH
73867: LD_VAR 0 4
73871: ARRAY
73872: NOT
73873: IFFALSE 73877
// continue ;
73875: GO 73836
// if BuildingStatus ( j ) = bs_idle then
73877: LD_VAR 0 3
73881: PPUSH
73882: CALL_OW 461
73886: PUSH
73887: LD_INT 2
73889: EQUAL
73890: IFFALSE 74078
// begin if idle_lab and UnitsInside ( j ) < 6 then
73892: LD_VAR 0 11
73896: PUSH
73897: LD_VAR 0 3
73901: PPUSH
73902: CALL_OW 313
73906: PUSH
73907: LD_INT 6
73909: LESS
73910: AND
73911: IFFALSE 73982
// begin tmp2 := UnitsInside ( idle_lab ) ;
73913: LD_ADDR_VAR 0 9
73917: PUSH
73918: LD_VAR 0 11
73922: PPUSH
73923: CALL_OW 313
73927: ST_TO_ADDR
// if tmp2 then
73928: LD_VAR 0 9
73932: IFFALSE 73974
// for x in tmp2 do
73934: LD_ADDR_VAR 0 7
73938: PUSH
73939: LD_VAR 0 9
73943: PUSH
73944: FOR_IN
73945: IFFALSE 73972
// begin ComExitBuilding ( x ) ;
73947: LD_VAR 0 7
73951: PPUSH
73952: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73956: LD_VAR 0 7
73960: PPUSH
73961: LD_VAR 0 3
73965: PPUSH
73966: CALL_OW 180
// end ;
73970: GO 73944
73972: POP
73973: POP
// idle_lab := 0 ;
73974: LD_ADDR_VAR 0 11
73978: PUSH
73979: LD_INT 0
73981: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73982: LD_ADDR_VAR 0 5
73986: PUSH
73987: LD_EXP 86
73991: PUSH
73992: LD_VAR 0 4
73996: ARRAY
73997: PUSH
73998: FOR_IN
73999: IFFALSE 74059
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
74001: LD_VAR 0 3
74005: PPUSH
74006: LD_VAR 0 5
74010: PPUSH
74011: CALL_OW 430
74015: PUSH
74016: LD_VAR 0 4
74020: PPUSH
74021: LD_VAR 0 5
74025: PPUSH
74026: CALL 15084 0 2
74030: AND
74031: IFFALSE 74057
// begin researching := true ;
74033: LD_ADDR_VAR 0 10
74037: PUSH
74038: LD_INT 1
74040: ST_TO_ADDR
// ComResearch ( j , t ) ;
74041: LD_VAR 0 3
74045: PPUSH
74046: LD_VAR 0 5
74050: PPUSH
74051: CALL_OW 124
// break ;
74055: GO 74059
// end ;
74057: GO 73998
74059: POP
74060: POP
// if not researching then
74061: LD_VAR 0 10
74065: NOT
74066: IFFALSE 74078
// idle_lab := j ;
74068: LD_ADDR_VAR 0 11
74072: PUSH
74073: LD_VAR 0 3
74077: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
74078: LD_VAR 0 3
74082: PPUSH
74083: CALL_OW 461
74087: PUSH
74088: LD_INT 10
74090: EQUAL
74091: IFFALSE 74679
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
74093: LD_EXP 88
74097: PUSH
74098: LD_VAR 0 2
74102: ARRAY
74103: NOT
74104: PUSH
74105: LD_EXP 89
74109: PUSH
74110: LD_VAR 0 2
74114: ARRAY
74115: NOT
74116: AND
74117: PUSH
74118: LD_EXP 86
74122: PUSH
74123: LD_VAR 0 4
74127: ARRAY
74128: PUSH
74129: LD_INT 1
74131: GREATER
74132: AND
74133: IFFALSE 74264
// begin ComCancel ( j ) ;
74135: LD_VAR 0 3
74139: PPUSH
74140: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
74144: LD_ADDR_EXP 86
74148: PUSH
74149: LD_EXP 86
74153: PPUSH
74154: LD_VAR 0 4
74158: PPUSH
74159: LD_EXP 86
74163: PUSH
74164: LD_VAR 0 4
74168: ARRAY
74169: PPUSH
74170: LD_EXP 86
74174: PUSH
74175: LD_VAR 0 4
74179: ARRAY
74180: PUSH
74181: LD_INT 1
74183: MINUS
74184: PPUSH
74185: LD_EXP 86
74189: PUSH
74190: LD_VAR 0 4
74194: ARRAY
74195: PPUSH
74196: LD_INT 0
74198: PPUSH
74199: CALL 21007 0 4
74203: PPUSH
74204: CALL_OW 1
74208: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
74209: LD_ADDR_EXP 86
74213: PUSH
74214: LD_EXP 86
74218: PPUSH
74219: LD_VAR 0 4
74223: PPUSH
74224: LD_EXP 86
74228: PUSH
74229: LD_VAR 0 4
74233: ARRAY
74234: PPUSH
74235: LD_EXP 86
74239: PUSH
74240: LD_VAR 0 4
74244: ARRAY
74245: PPUSH
74246: LD_INT 1
74248: PPUSH
74249: LD_INT 0
74251: PPUSH
74252: CALL 21007 0 4
74256: PPUSH
74257: CALL_OW 1
74261: ST_TO_ADDR
// continue ;
74262: GO 73836
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
74264: LD_EXP 88
74268: PUSH
74269: LD_VAR 0 2
74273: ARRAY
74274: PUSH
74275: LD_EXP 89
74279: PUSH
74280: LD_VAR 0 2
74284: ARRAY
74285: NOT
74286: AND
74287: IFFALSE 74414
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
74289: LD_ADDR_EXP 89
74293: PUSH
74294: LD_EXP 89
74298: PPUSH
74299: LD_VAR 0 2
74303: PUSH
74304: LD_EXP 89
74308: PUSH
74309: LD_VAR 0 2
74313: ARRAY
74314: PUSH
74315: LD_INT 1
74317: PLUS
74318: PUSH
74319: EMPTY
74320: LIST
74321: LIST
74322: PPUSH
74323: LD_EXP 88
74327: PUSH
74328: LD_VAR 0 2
74332: ARRAY
74333: PUSH
74334: LD_INT 1
74336: ARRAY
74337: PPUSH
74338: CALL 21589 0 3
74342: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
74343: LD_EXP 88
74347: PUSH
74348: LD_VAR 0 2
74352: ARRAY
74353: PUSH
74354: LD_INT 1
74356: ARRAY
74357: PPUSH
74358: LD_INT 112
74360: PPUSH
74361: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
74365: LD_ADDR_VAR 0 9
74369: PUSH
74370: LD_EXP 88
74374: PUSH
74375: LD_VAR 0 2
74379: ARRAY
74380: PPUSH
74381: LD_INT 1
74383: PPUSH
74384: CALL_OW 3
74388: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
74389: LD_ADDR_EXP 88
74393: PUSH
74394: LD_EXP 88
74398: PPUSH
74399: LD_VAR 0 2
74403: PPUSH
74404: LD_VAR 0 9
74408: PPUSH
74409: CALL_OW 1
74413: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
74414: LD_EXP 88
74418: PUSH
74419: LD_VAR 0 2
74423: ARRAY
74424: PUSH
74425: LD_EXP 89
74429: PUSH
74430: LD_VAR 0 2
74434: ARRAY
74435: AND
74436: PUSH
74437: LD_EXP 89
74441: PUSH
74442: LD_VAR 0 2
74446: ARRAY
74447: PUSH
74448: LD_INT 1
74450: ARRAY
74451: PPUSH
74452: CALL_OW 310
74456: NOT
74457: AND
74458: PUSH
74459: LD_VAR 0 3
74463: PPUSH
74464: CALL_OW 313
74468: PUSH
74469: LD_INT 6
74471: EQUAL
74472: AND
74473: IFFALSE 74529
// begin tmp2 := UnitsInside ( j ) ;
74475: LD_ADDR_VAR 0 9
74479: PUSH
74480: LD_VAR 0 3
74484: PPUSH
74485: CALL_OW 313
74489: ST_TO_ADDR
// if tmp2 = 6 then
74490: LD_VAR 0 9
74494: PUSH
74495: LD_INT 6
74497: EQUAL
74498: IFFALSE 74529
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
74500: LD_VAR 0 9
74504: PUSH
74505: LD_INT 1
74507: ARRAY
74508: PPUSH
74509: LD_INT 112
74511: PPUSH
74512: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
74516: LD_VAR 0 9
74520: PUSH
74521: LD_INT 1
74523: ARRAY
74524: PPUSH
74525: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
74529: LD_EXP 89
74533: PUSH
74534: LD_VAR 0 2
74538: ARRAY
74539: PUSH
74540: LD_EXP 89
74544: PUSH
74545: LD_VAR 0 2
74549: ARRAY
74550: PUSH
74551: LD_INT 1
74553: ARRAY
74554: PPUSH
74555: CALL_OW 314
74559: NOT
74560: AND
74561: PUSH
74562: LD_EXP 89
74566: PUSH
74567: LD_VAR 0 2
74571: ARRAY
74572: PUSH
74573: LD_INT 1
74575: ARRAY
74576: PPUSH
74577: CALL_OW 310
74581: NOT
74582: AND
74583: IFFALSE 74609
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
74585: LD_EXP 89
74589: PUSH
74590: LD_VAR 0 2
74594: ARRAY
74595: PUSH
74596: LD_INT 1
74598: ARRAY
74599: PPUSH
74600: LD_VAR 0 3
74604: PPUSH
74605: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
74609: LD_EXP 89
74613: PUSH
74614: LD_VAR 0 2
74618: ARRAY
74619: PUSH
74620: LD_INT 1
74622: ARRAY
74623: PPUSH
74624: CALL_OW 310
74628: PUSH
74629: LD_EXP 89
74633: PUSH
74634: LD_VAR 0 2
74638: ARRAY
74639: PUSH
74640: LD_INT 1
74642: ARRAY
74643: PPUSH
74644: CALL_OW 310
74648: PPUSH
74649: CALL_OW 461
74653: PUSH
74654: LD_INT 3
74656: NONEQUAL
74657: AND
74658: IFFALSE 74679
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74660: LD_EXP 89
74664: PUSH
74665: LD_VAR 0 2
74669: ARRAY
74670: PUSH
74671: LD_INT 1
74673: ARRAY
74674: PPUSH
74675: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74679: LD_VAR 0 3
74683: PPUSH
74684: CALL_OW 461
74688: PUSH
74689: LD_INT 6
74691: EQUAL
74692: PUSH
74693: LD_VAR 0 6
74697: PUSH
74698: LD_INT 1
74700: GREATER
74701: AND
74702: IFFALSE 74854
// begin sci := [ ] ;
74704: LD_ADDR_VAR 0 8
74708: PUSH
74709: EMPTY
74710: ST_TO_ADDR
// for x in ( tmp diff j ) do
74711: LD_ADDR_VAR 0 7
74715: PUSH
74716: LD_VAR 0 6
74720: PUSH
74721: LD_VAR 0 3
74725: DIFF
74726: PUSH
74727: FOR_IN
74728: IFFALSE 74780
// begin if sci = 6 then
74730: LD_VAR 0 8
74734: PUSH
74735: LD_INT 6
74737: EQUAL
74738: IFFALSE 74742
// break ;
74740: GO 74780
// if BuildingStatus ( x ) = bs_idle then
74742: LD_VAR 0 7
74746: PPUSH
74747: CALL_OW 461
74751: PUSH
74752: LD_INT 2
74754: EQUAL
74755: IFFALSE 74778
// sci := sci ^ UnitsInside ( x ) ;
74757: LD_ADDR_VAR 0 8
74761: PUSH
74762: LD_VAR 0 8
74766: PUSH
74767: LD_VAR 0 7
74771: PPUSH
74772: CALL_OW 313
74776: ADD
74777: ST_TO_ADDR
// end ;
74778: GO 74727
74780: POP
74781: POP
// if not sci then
74782: LD_VAR 0 8
74786: NOT
74787: IFFALSE 74791
// continue ;
74789: GO 73836
// for x in sci do
74791: LD_ADDR_VAR 0 7
74795: PUSH
74796: LD_VAR 0 8
74800: PUSH
74801: FOR_IN
74802: IFFALSE 74852
// if IsInUnit ( x ) and not HasTask ( x ) then
74804: LD_VAR 0 7
74808: PPUSH
74809: CALL_OW 310
74813: PUSH
74814: LD_VAR 0 7
74818: PPUSH
74819: CALL_OW 314
74823: NOT
74824: AND
74825: IFFALSE 74850
// begin ComExitBuilding ( x ) ;
74827: LD_VAR 0 7
74831: PPUSH
74832: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74836: LD_VAR 0 7
74840: PPUSH
74841: LD_VAR 0 3
74845: PPUSH
74846: CALL_OW 180
// end ;
74850: GO 74801
74852: POP
74853: POP
// end ; end ;
74854: GO 73836
74856: POP
74857: POP
// end ;
74858: GO 73790
74860: POP
74861: POP
// end ;
74862: LD_VAR 0 1
74866: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74867: LD_INT 0
74869: PPUSH
74870: PPUSH
// if not mc_bases then
74871: LD_EXP 59
74875: NOT
74876: IFFALSE 74880
// exit ;
74878: GO 74961
// for i = 1 to mc_bases do
74880: LD_ADDR_VAR 0 2
74884: PUSH
74885: DOUBLE
74886: LD_INT 1
74888: DEC
74889: ST_TO_ADDR
74890: LD_EXP 59
74894: PUSH
74895: FOR_TO
74896: IFFALSE 74959
// if mc_mines [ i ] and mc_miners [ i ] then
74898: LD_EXP 72
74902: PUSH
74903: LD_VAR 0 2
74907: ARRAY
74908: PUSH
74909: LD_EXP 73
74913: PUSH
74914: LD_VAR 0 2
74918: ARRAY
74919: AND
74920: IFFALSE 74957
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74922: LD_EXP 73
74926: PUSH
74927: LD_VAR 0 2
74931: ARRAY
74932: PUSH
74933: LD_INT 1
74935: ARRAY
74936: PPUSH
74937: CALL_OW 255
74941: PPUSH
74942: LD_EXP 72
74946: PUSH
74947: LD_VAR 0 2
74951: ARRAY
74952: PPUSH
74953: CALL 18578 0 2
74957: GO 74895
74959: POP
74960: POP
// end ;
74961: LD_VAR 0 1
74965: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74966: LD_INT 0
74968: PPUSH
74969: PPUSH
74970: PPUSH
74971: PPUSH
74972: PPUSH
74973: PPUSH
74974: PPUSH
74975: PPUSH
// if not mc_bases or not mc_parking then
74976: LD_EXP 59
74980: NOT
74981: PUSH
74982: LD_EXP 83
74986: NOT
74987: OR
74988: IFFALSE 74992
// exit ;
74990: GO 75691
// for i = 1 to mc_bases do
74992: LD_ADDR_VAR 0 2
74996: PUSH
74997: DOUBLE
74998: LD_INT 1
75000: DEC
75001: ST_TO_ADDR
75002: LD_EXP 59
75006: PUSH
75007: FOR_TO
75008: IFFALSE 75689
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
75010: LD_EXP 59
75014: PUSH
75015: LD_VAR 0 2
75019: ARRAY
75020: NOT
75021: PUSH
75022: LD_EXP 83
75026: PUSH
75027: LD_VAR 0 2
75031: ARRAY
75032: NOT
75033: OR
75034: IFFALSE 75038
// continue ;
75036: GO 75007
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
75038: LD_ADDR_VAR 0 5
75042: PUSH
75043: LD_EXP 59
75047: PUSH
75048: LD_VAR 0 2
75052: ARRAY
75053: PUSH
75054: LD_INT 1
75056: ARRAY
75057: PPUSH
75058: CALL_OW 255
75062: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75063: LD_ADDR_VAR 0 6
75067: PUSH
75068: LD_EXP 59
75072: PUSH
75073: LD_VAR 0 2
75077: ARRAY
75078: PPUSH
75079: LD_INT 30
75081: PUSH
75082: LD_INT 3
75084: PUSH
75085: EMPTY
75086: LIST
75087: LIST
75088: PPUSH
75089: CALL_OW 72
75093: ST_TO_ADDR
// if not fac then
75094: LD_VAR 0 6
75098: NOT
75099: IFFALSE 75150
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75101: LD_ADDR_VAR 0 6
75105: PUSH
75106: LD_EXP 59
75110: PUSH
75111: LD_VAR 0 2
75115: ARRAY
75116: PPUSH
75117: LD_INT 2
75119: PUSH
75120: LD_INT 30
75122: PUSH
75123: LD_INT 0
75125: PUSH
75126: EMPTY
75127: LIST
75128: LIST
75129: PUSH
75130: LD_INT 30
75132: PUSH
75133: LD_INT 1
75135: PUSH
75136: EMPTY
75137: LIST
75138: LIST
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: LIST
75144: PPUSH
75145: CALL_OW 72
75149: ST_TO_ADDR
// if not fac then
75150: LD_VAR 0 6
75154: NOT
75155: IFFALSE 75159
// continue ;
75157: GO 75007
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75159: LD_ADDR_VAR 0 7
75163: PUSH
75164: LD_EXP 83
75168: PUSH
75169: LD_VAR 0 2
75173: ARRAY
75174: PPUSH
75175: LD_INT 22
75177: PUSH
75178: LD_VAR 0 5
75182: PUSH
75183: EMPTY
75184: LIST
75185: LIST
75186: PUSH
75187: LD_INT 21
75189: PUSH
75190: LD_INT 2
75192: PUSH
75193: EMPTY
75194: LIST
75195: LIST
75196: PUSH
75197: LD_INT 3
75199: PUSH
75200: LD_INT 24
75202: PUSH
75203: LD_INT 1000
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: PUSH
75210: EMPTY
75211: LIST
75212: LIST
75213: PUSH
75214: EMPTY
75215: LIST
75216: LIST
75217: LIST
75218: PPUSH
75219: CALL_OW 70
75223: ST_TO_ADDR
// for j in fac do
75224: LD_ADDR_VAR 0 3
75228: PUSH
75229: LD_VAR 0 6
75233: PUSH
75234: FOR_IN
75235: IFFALSE 75316
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75237: LD_ADDR_VAR 0 7
75241: PUSH
75242: LD_VAR 0 7
75246: PUSH
75247: LD_INT 22
75249: PUSH
75250: LD_VAR 0 5
75254: PUSH
75255: EMPTY
75256: LIST
75257: LIST
75258: PUSH
75259: LD_INT 91
75261: PUSH
75262: LD_VAR 0 3
75266: PUSH
75267: LD_INT 15
75269: PUSH
75270: EMPTY
75271: LIST
75272: LIST
75273: LIST
75274: PUSH
75275: LD_INT 21
75277: PUSH
75278: LD_INT 2
75280: PUSH
75281: EMPTY
75282: LIST
75283: LIST
75284: PUSH
75285: LD_INT 3
75287: PUSH
75288: LD_INT 24
75290: PUSH
75291: LD_INT 1000
75293: PUSH
75294: EMPTY
75295: LIST
75296: LIST
75297: PUSH
75298: EMPTY
75299: LIST
75300: LIST
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: LIST
75306: LIST
75307: PPUSH
75308: CALL_OW 69
75312: UNION
75313: ST_TO_ADDR
75314: GO 75234
75316: POP
75317: POP
// if not vehs then
75318: LD_VAR 0 7
75322: NOT
75323: IFFALSE 75349
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
75325: LD_ADDR_EXP 71
75329: PUSH
75330: LD_EXP 71
75334: PPUSH
75335: LD_VAR 0 2
75339: PPUSH
75340: EMPTY
75341: PPUSH
75342: CALL_OW 1
75346: ST_TO_ADDR
// continue ;
75347: GO 75007
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75349: LD_ADDR_VAR 0 8
75353: PUSH
75354: LD_EXP 59
75358: PUSH
75359: LD_VAR 0 2
75363: ARRAY
75364: PPUSH
75365: LD_INT 30
75367: PUSH
75368: LD_INT 3
75370: PUSH
75371: EMPTY
75372: LIST
75373: LIST
75374: PPUSH
75375: CALL_OW 72
75379: ST_TO_ADDR
// if tmp then
75380: LD_VAR 0 8
75384: IFFALSE 75487
// begin for j in tmp do
75386: LD_ADDR_VAR 0 3
75390: PUSH
75391: LD_VAR 0 8
75395: PUSH
75396: FOR_IN
75397: IFFALSE 75485
// for k in UnitsInside ( j ) do
75399: LD_ADDR_VAR 0 4
75403: PUSH
75404: LD_VAR 0 3
75408: PPUSH
75409: CALL_OW 313
75413: PUSH
75414: FOR_IN
75415: IFFALSE 75481
// if k then
75417: LD_VAR 0 4
75421: IFFALSE 75479
// if not k in mc_repair_vehicle [ i ] then
75423: LD_VAR 0 4
75427: PUSH
75428: LD_EXP 71
75432: PUSH
75433: LD_VAR 0 2
75437: ARRAY
75438: IN
75439: NOT
75440: IFFALSE 75479
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
75442: LD_ADDR_EXP 71
75446: PUSH
75447: LD_EXP 71
75451: PPUSH
75452: LD_VAR 0 2
75456: PPUSH
75457: LD_EXP 71
75461: PUSH
75462: LD_VAR 0 2
75466: ARRAY
75467: PUSH
75468: LD_VAR 0 4
75472: UNION
75473: PPUSH
75474: CALL_OW 1
75478: ST_TO_ADDR
75479: GO 75414
75481: POP
75482: POP
75483: GO 75396
75485: POP
75486: POP
// end ; if not mc_repair_vehicle [ i ] then
75487: LD_EXP 71
75491: PUSH
75492: LD_VAR 0 2
75496: ARRAY
75497: NOT
75498: IFFALSE 75502
// continue ;
75500: GO 75007
// for j in mc_repair_vehicle [ i ] do
75502: LD_ADDR_VAR 0 3
75506: PUSH
75507: LD_EXP 71
75511: PUSH
75512: LD_VAR 0 2
75516: ARRAY
75517: PUSH
75518: FOR_IN
75519: IFFALSE 75685
// begin if GetClass ( j ) <> 3 then
75521: LD_VAR 0 3
75525: PPUSH
75526: CALL_OW 257
75530: PUSH
75531: LD_INT 3
75533: NONEQUAL
75534: IFFALSE 75575
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
75536: LD_ADDR_EXP 71
75540: PUSH
75541: LD_EXP 71
75545: PPUSH
75546: LD_VAR 0 2
75550: PPUSH
75551: LD_EXP 71
75555: PUSH
75556: LD_VAR 0 2
75560: ARRAY
75561: PUSH
75562: LD_VAR 0 3
75566: DIFF
75567: PPUSH
75568: CALL_OW 1
75572: ST_TO_ADDR
// continue ;
75573: GO 75518
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75575: LD_VAR 0 3
75579: PPUSH
75580: CALL_OW 311
75584: NOT
75585: PUSH
75586: LD_VAR 0 3
75590: PUSH
75591: LD_EXP 62
75595: PUSH
75596: LD_VAR 0 2
75600: ARRAY
75601: PUSH
75602: LD_INT 1
75604: ARRAY
75605: IN
75606: NOT
75607: AND
75608: PUSH
75609: LD_VAR 0 3
75613: PUSH
75614: LD_EXP 62
75618: PUSH
75619: LD_VAR 0 2
75623: ARRAY
75624: PUSH
75625: LD_INT 2
75627: ARRAY
75628: IN
75629: NOT
75630: AND
75631: IFFALSE 75683
// begin if IsInUnit ( j ) then
75633: LD_VAR 0 3
75637: PPUSH
75638: CALL_OW 310
75642: IFFALSE 75653
// ComExitBuilding ( j ) ;
75644: LD_VAR 0 3
75648: PPUSH
75649: CALL_OW 122
// if not HasTask ( j ) then
75653: LD_VAR 0 3
75657: PPUSH
75658: CALL_OW 314
75662: NOT
75663: IFFALSE 75683
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
75665: LD_VAR 0 3
75669: PPUSH
75670: LD_VAR 0 7
75674: PUSH
75675: LD_INT 1
75677: ARRAY
75678: PPUSH
75679: CALL_OW 189
// end ; end ;
75683: GO 75518
75685: POP
75686: POP
// end ;
75687: GO 75007
75689: POP
75690: POP
// end ;
75691: LD_VAR 0 1
75695: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75696: LD_INT 0
75698: PPUSH
75699: PPUSH
75700: PPUSH
75701: PPUSH
75702: PPUSH
75703: PPUSH
75704: PPUSH
75705: PPUSH
75706: PPUSH
75707: PPUSH
75708: PPUSH
// if not mc_bases then
75709: LD_EXP 59
75713: NOT
75714: IFFALSE 75718
// exit ;
75716: GO 76520
// for i = 1 to mc_bases do
75718: LD_ADDR_VAR 0 2
75722: PUSH
75723: DOUBLE
75724: LD_INT 1
75726: DEC
75727: ST_TO_ADDR
75728: LD_EXP 59
75732: PUSH
75733: FOR_TO
75734: IFFALSE 76518
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75736: LD_EXP 87
75740: PUSH
75741: LD_VAR 0 2
75745: ARRAY
75746: NOT
75747: PUSH
75748: LD_EXP 62
75752: PUSH
75753: LD_VAR 0 2
75757: ARRAY
75758: PUSH
75759: LD_INT 1
75761: ARRAY
75762: OR
75763: PUSH
75764: LD_EXP 62
75768: PUSH
75769: LD_VAR 0 2
75773: ARRAY
75774: PUSH
75775: LD_INT 2
75777: ARRAY
75778: OR
75779: PUSH
75780: LD_EXP 85
75784: PUSH
75785: LD_VAR 0 2
75789: ARRAY
75790: PPUSH
75791: LD_INT 1
75793: PPUSH
75794: CALL_OW 325
75798: NOT
75799: OR
75800: PUSH
75801: LD_EXP 82
75805: PUSH
75806: LD_VAR 0 2
75810: ARRAY
75811: OR
75812: IFFALSE 75816
// continue ;
75814: GO 75733
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75816: LD_ADDR_VAR 0 8
75820: PUSH
75821: LD_EXP 59
75825: PUSH
75826: LD_VAR 0 2
75830: ARRAY
75831: PPUSH
75832: LD_INT 25
75834: PUSH
75835: LD_INT 4
75837: PUSH
75838: EMPTY
75839: LIST
75840: LIST
75841: PUSH
75842: LD_INT 50
75844: PUSH
75845: EMPTY
75846: LIST
75847: PUSH
75848: LD_INT 3
75850: PUSH
75851: LD_INT 60
75853: PUSH
75854: EMPTY
75855: LIST
75856: PUSH
75857: EMPTY
75858: LIST
75859: LIST
75860: PUSH
75861: EMPTY
75862: LIST
75863: LIST
75864: LIST
75865: PPUSH
75866: CALL_OW 72
75870: PUSH
75871: LD_EXP 63
75875: PUSH
75876: LD_VAR 0 2
75880: ARRAY
75881: DIFF
75882: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75883: LD_ADDR_VAR 0 9
75887: PUSH
75888: LD_EXP 59
75892: PUSH
75893: LD_VAR 0 2
75897: ARRAY
75898: PPUSH
75899: LD_INT 2
75901: PUSH
75902: LD_INT 30
75904: PUSH
75905: LD_INT 0
75907: PUSH
75908: EMPTY
75909: LIST
75910: LIST
75911: PUSH
75912: LD_INT 30
75914: PUSH
75915: LD_INT 1
75917: PUSH
75918: EMPTY
75919: LIST
75920: LIST
75921: PUSH
75922: EMPTY
75923: LIST
75924: LIST
75925: LIST
75926: PPUSH
75927: CALL_OW 72
75931: ST_TO_ADDR
// if not tmp or not dep then
75932: LD_VAR 0 8
75936: NOT
75937: PUSH
75938: LD_VAR 0 9
75942: NOT
75943: OR
75944: IFFALSE 75948
// continue ;
75946: GO 75733
// side := GetSide ( tmp [ 1 ] ) ;
75948: LD_ADDR_VAR 0 11
75952: PUSH
75953: LD_VAR 0 8
75957: PUSH
75958: LD_INT 1
75960: ARRAY
75961: PPUSH
75962: CALL_OW 255
75966: ST_TO_ADDR
// dep := dep [ 1 ] ;
75967: LD_ADDR_VAR 0 9
75971: PUSH
75972: LD_VAR 0 9
75976: PUSH
75977: LD_INT 1
75979: ARRAY
75980: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75981: LD_ADDR_VAR 0 7
75985: PUSH
75986: LD_EXP 87
75990: PUSH
75991: LD_VAR 0 2
75995: ARRAY
75996: PPUSH
75997: LD_INT 22
75999: PUSH
76000: LD_INT 0
76002: PUSH
76003: EMPTY
76004: LIST
76005: LIST
76006: PUSH
76007: LD_INT 25
76009: PUSH
76010: LD_INT 12
76012: PUSH
76013: EMPTY
76014: LIST
76015: LIST
76016: PUSH
76017: EMPTY
76018: LIST
76019: LIST
76020: PPUSH
76021: CALL_OW 70
76025: PUSH
76026: LD_INT 22
76028: PUSH
76029: LD_INT 0
76031: PUSH
76032: EMPTY
76033: LIST
76034: LIST
76035: PUSH
76036: LD_INT 25
76038: PUSH
76039: LD_INT 12
76041: PUSH
76042: EMPTY
76043: LIST
76044: LIST
76045: PUSH
76046: LD_INT 91
76048: PUSH
76049: LD_VAR 0 9
76053: PUSH
76054: LD_INT 20
76056: PUSH
76057: EMPTY
76058: LIST
76059: LIST
76060: LIST
76061: PUSH
76062: EMPTY
76063: LIST
76064: LIST
76065: LIST
76066: PPUSH
76067: CALL_OW 69
76071: UNION
76072: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
76073: LD_ADDR_VAR 0 10
76077: PUSH
76078: LD_EXP 87
76082: PUSH
76083: LD_VAR 0 2
76087: ARRAY
76088: PPUSH
76089: LD_INT 81
76091: PUSH
76092: LD_VAR 0 11
76096: PUSH
76097: EMPTY
76098: LIST
76099: LIST
76100: PPUSH
76101: CALL_OW 70
76105: ST_TO_ADDR
// if not apes or danger_at_area then
76106: LD_VAR 0 7
76110: NOT
76111: PUSH
76112: LD_VAR 0 10
76116: OR
76117: IFFALSE 76167
// begin if mc_taming [ i ] then
76119: LD_EXP 90
76123: PUSH
76124: LD_VAR 0 2
76128: ARRAY
76129: IFFALSE 76165
// begin MC_Reset ( i , 121 ) ;
76131: LD_VAR 0 2
76135: PPUSH
76136: LD_INT 121
76138: PPUSH
76139: CALL 61602 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
76143: LD_ADDR_EXP 90
76147: PUSH
76148: LD_EXP 90
76152: PPUSH
76153: LD_VAR 0 2
76157: PPUSH
76158: EMPTY
76159: PPUSH
76160: CALL_OW 1
76164: ST_TO_ADDR
// end ; continue ;
76165: GO 75733
// end ; for j in tmp do
76167: LD_ADDR_VAR 0 3
76171: PUSH
76172: LD_VAR 0 8
76176: PUSH
76177: FOR_IN
76178: IFFALSE 76514
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
76180: LD_VAR 0 3
76184: PUSH
76185: LD_EXP 90
76189: PUSH
76190: LD_VAR 0 2
76194: ARRAY
76195: IN
76196: NOT
76197: PUSH
76198: LD_EXP 90
76202: PUSH
76203: LD_VAR 0 2
76207: ARRAY
76208: PUSH
76209: LD_INT 3
76211: LESS
76212: AND
76213: IFFALSE 76271
// begin SetTag ( j , 121 ) ;
76215: LD_VAR 0 3
76219: PPUSH
76220: LD_INT 121
76222: PPUSH
76223: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
76227: LD_ADDR_EXP 90
76231: PUSH
76232: LD_EXP 90
76236: PPUSH
76237: LD_VAR 0 2
76241: PUSH
76242: LD_EXP 90
76246: PUSH
76247: LD_VAR 0 2
76251: ARRAY
76252: PUSH
76253: LD_INT 1
76255: PLUS
76256: PUSH
76257: EMPTY
76258: LIST
76259: LIST
76260: PPUSH
76261: LD_VAR 0 3
76265: PPUSH
76266: CALL 21589 0 3
76270: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
76271: LD_VAR 0 3
76275: PUSH
76276: LD_EXP 90
76280: PUSH
76281: LD_VAR 0 2
76285: ARRAY
76286: IN
76287: IFFALSE 76512
// begin if GetClass ( j ) <> 4 then
76289: LD_VAR 0 3
76293: PPUSH
76294: CALL_OW 257
76298: PUSH
76299: LD_INT 4
76301: NONEQUAL
76302: IFFALSE 76355
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
76304: LD_ADDR_EXP 90
76308: PUSH
76309: LD_EXP 90
76313: PPUSH
76314: LD_VAR 0 2
76318: PPUSH
76319: LD_EXP 90
76323: PUSH
76324: LD_VAR 0 2
76328: ARRAY
76329: PUSH
76330: LD_VAR 0 3
76334: DIFF
76335: PPUSH
76336: CALL_OW 1
76340: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76341: LD_VAR 0 3
76345: PPUSH
76346: LD_INT 0
76348: PPUSH
76349: CALL_OW 109
// continue ;
76353: GO 76177
// end ; if IsInUnit ( j ) then
76355: LD_VAR 0 3
76359: PPUSH
76360: CALL_OW 310
76364: IFFALSE 76375
// ComExitBuilding ( j ) ;
76366: LD_VAR 0 3
76370: PPUSH
76371: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
76375: LD_ADDR_VAR 0 6
76379: PUSH
76380: LD_VAR 0 7
76384: PPUSH
76385: LD_VAR 0 3
76389: PPUSH
76390: CALL_OW 74
76394: ST_TO_ADDR
// if not ape then
76395: LD_VAR 0 6
76399: NOT
76400: IFFALSE 76404
// break ;
76402: GO 76514
// x := GetX ( ape ) ;
76404: LD_ADDR_VAR 0 4
76408: PUSH
76409: LD_VAR 0 6
76413: PPUSH
76414: CALL_OW 250
76418: ST_TO_ADDR
// y := GetY ( ape ) ;
76419: LD_ADDR_VAR 0 5
76423: PUSH
76424: LD_VAR 0 6
76428: PPUSH
76429: CALL_OW 251
76433: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76434: LD_VAR 0 4
76438: PPUSH
76439: LD_VAR 0 5
76443: PPUSH
76444: CALL_OW 488
76448: NOT
76449: PUSH
76450: LD_VAR 0 11
76454: PPUSH
76455: LD_VAR 0 4
76459: PPUSH
76460: LD_VAR 0 5
76464: PPUSH
76465: LD_INT 20
76467: PPUSH
76468: CALL 22485 0 4
76472: PUSH
76473: LD_INT 4
76475: ARRAY
76476: OR
76477: IFFALSE 76481
// break ;
76479: GO 76514
// if not HasTask ( j ) then
76481: LD_VAR 0 3
76485: PPUSH
76486: CALL_OW 314
76490: NOT
76491: IFFALSE 76512
// ComTameXY ( j , x , y ) ;
76493: LD_VAR 0 3
76497: PPUSH
76498: LD_VAR 0 4
76502: PPUSH
76503: LD_VAR 0 5
76507: PPUSH
76508: CALL_OW 131
// end ; end ;
76512: GO 76177
76514: POP
76515: POP
// end ;
76516: GO 75733
76518: POP
76519: POP
// end ;
76520: LD_VAR 0 1
76524: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
76525: LD_INT 0
76527: PPUSH
76528: PPUSH
76529: PPUSH
76530: PPUSH
76531: PPUSH
76532: PPUSH
76533: PPUSH
76534: PPUSH
// if not mc_bases then
76535: LD_EXP 59
76539: NOT
76540: IFFALSE 76544
// exit ;
76542: GO 77170
// for i = 1 to mc_bases do
76544: LD_ADDR_VAR 0 2
76548: PUSH
76549: DOUBLE
76550: LD_INT 1
76552: DEC
76553: ST_TO_ADDR
76554: LD_EXP 59
76558: PUSH
76559: FOR_TO
76560: IFFALSE 77168
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
76562: LD_EXP 88
76566: PUSH
76567: LD_VAR 0 2
76571: ARRAY
76572: NOT
76573: PUSH
76574: LD_EXP 88
76578: PUSH
76579: LD_VAR 0 2
76583: ARRAY
76584: PPUSH
76585: LD_INT 25
76587: PUSH
76588: LD_INT 12
76590: PUSH
76591: EMPTY
76592: LIST
76593: LIST
76594: PPUSH
76595: CALL_OW 72
76599: NOT
76600: OR
76601: IFFALSE 76605
// continue ;
76603: GO 76559
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76605: LD_ADDR_VAR 0 5
76609: PUSH
76610: LD_EXP 88
76614: PUSH
76615: LD_VAR 0 2
76619: ARRAY
76620: PUSH
76621: LD_INT 1
76623: ARRAY
76624: PPUSH
76625: CALL_OW 255
76629: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76630: LD_VAR 0 5
76634: PPUSH
76635: LD_INT 2
76637: PPUSH
76638: CALL_OW 325
76642: IFFALSE 76895
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76644: LD_ADDR_VAR 0 4
76648: PUSH
76649: LD_EXP 88
76653: PUSH
76654: LD_VAR 0 2
76658: ARRAY
76659: PPUSH
76660: LD_INT 25
76662: PUSH
76663: LD_INT 16
76665: PUSH
76666: EMPTY
76667: LIST
76668: LIST
76669: PPUSH
76670: CALL_OW 72
76674: ST_TO_ADDR
// if tmp < 6 then
76675: LD_VAR 0 4
76679: PUSH
76680: LD_INT 6
76682: LESS
76683: IFFALSE 76895
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76685: LD_ADDR_VAR 0 6
76689: PUSH
76690: LD_EXP 59
76694: PUSH
76695: LD_VAR 0 2
76699: ARRAY
76700: PPUSH
76701: LD_INT 2
76703: PUSH
76704: LD_INT 30
76706: PUSH
76707: LD_INT 0
76709: PUSH
76710: EMPTY
76711: LIST
76712: LIST
76713: PUSH
76714: LD_INT 30
76716: PUSH
76717: LD_INT 1
76719: PUSH
76720: EMPTY
76721: LIST
76722: LIST
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: LIST
76728: PPUSH
76729: CALL_OW 72
76733: ST_TO_ADDR
// if depot then
76734: LD_VAR 0 6
76738: IFFALSE 76895
// begin selected := 0 ;
76740: LD_ADDR_VAR 0 7
76744: PUSH
76745: LD_INT 0
76747: ST_TO_ADDR
// for j in depot do
76748: LD_ADDR_VAR 0 3
76752: PUSH
76753: LD_VAR 0 6
76757: PUSH
76758: FOR_IN
76759: IFFALSE 76790
// begin if UnitsInside ( j ) < 6 then
76761: LD_VAR 0 3
76765: PPUSH
76766: CALL_OW 313
76770: PUSH
76771: LD_INT 6
76773: LESS
76774: IFFALSE 76788
// begin selected := j ;
76776: LD_ADDR_VAR 0 7
76780: PUSH
76781: LD_VAR 0 3
76785: ST_TO_ADDR
// break ;
76786: GO 76790
// end ; end ;
76788: GO 76758
76790: POP
76791: POP
// if selected then
76792: LD_VAR 0 7
76796: IFFALSE 76895
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76798: LD_ADDR_VAR 0 3
76802: PUSH
76803: LD_EXP 88
76807: PUSH
76808: LD_VAR 0 2
76812: ARRAY
76813: PPUSH
76814: LD_INT 25
76816: PUSH
76817: LD_INT 12
76819: PUSH
76820: EMPTY
76821: LIST
76822: LIST
76823: PPUSH
76824: CALL_OW 72
76828: PUSH
76829: FOR_IN
76830: IFFALSE 76893
// if not HasTask ( j ) then
76832: LD_VAR 0 3
76836: PPUSH
76837: CALL_OW 314
76841: NOT
76842: IFFALSE 76891
// begin if not IsInUnit ( j ) then
76844: LD_VAR 0 3
76848: PPUSH
76849: CALL_OW 310
76853: NOT
76854: IFFALSE 76870
// ComEnterUnit ( j , selected ) ;
76856: LD_VAR 0 3
76860: PPUSH
76861: LD_VAR 0 7
76865: PPUSH
76866: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76870: LD_VAR 0 3
76874: PPUSH
76875: LD_INT 16
76877: PPUSH
76878: CALL_OW 183
// AddComExitBuilding ( j ) ;
76882: LD_VAR 0 3
76886: PPUSH
76887: CALL_OW 182
// end ;
76891: GO 76829
76893: POP
76894: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76895: LD_VAR 0 5
76899: PPUSH
76900: LD_INT 11
76902: PPUSH
76903: CALL_OW 325
76907: IFFALSE 77166
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76909: LD_ADDR_VAR 0 4
76913: PUSH
76914: LD_EXP 88
76918: PUSH
76919: LD_VAR 0 2
76923: ARRAY
76924: PPUSH
76925: LD_INT 25
76927: PUSH
76928: LD_INT 16
76930: PUSH
76931: EMPTY
76932: LIST
76933: LIST
76934: PPUSH
76935: CALL_OW 72
76939: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76940: LD_VAR 0 4
76944: PUSH
76945: LD_INT 6
76947: GREATEREQUAL
76948: PUSH
76949: LD_VAR 0 5
76953: PPUSH
76954: LD_INT 2
76956: PPUSH
76957: CALL_OW 325
76961: NOT
76962: OR
76963: IFFALSE 77166
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76965: LD_ADDR_VAR 0 8
76969: PUSH
76970: LD_EXP 59
76974: PUSH
76975: LD_VAR 0 2
76979: ARRAY
76980: PPUSH
76981: LD_INT 2
76983: PUSH
76984: LD_INT 30
76986: PUSH
76987: LD_INT 4
76989: PUSH
76990: EMPTY
76991: LIST
76992: LIST
76993: PUSH
76994: LD_INT 30
76996: PUSH
76997: LD_INT 5
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: PUSH
77004: EMPTY
77005: LIST
77006: LIST
77007: LIST
77008: PPUSH
77009: CALL_OW 72
77013: ST_TO_ADDR
// if barracks then
77014: LD_VAR 0 8
77018: IFFALSE 77166
// begin selected := 0 ;
77020: LD_ADDR_VAR 0 7
77024: PUSH
77025: LD_INT 0
77027: ST_TO_ADDR
// for j in barracks do
77028: LD_ADDR_VAR 0 3
77032: PUSH
77033: LD_VAR 0 8
77037: PUSH
77038: FOR_IN
77039: IFFALSE 77070
// begin if UnitsInside ( j ) < 6 then
77041: LD_VAR 0 3
77045: PPUSH
77046: CALL_OW 313
77050: PUSH
77051: LD_INT 6
77053: LESS
77054: IFFALSE 77068
// begin selected := j ;
77056: LD_ADDR_VAR 0 7
77060: PUSH
77061: LD_VAR 0 3
77065: ST_TO_ADDR
// break ;
77066: GO 77070
// end ; end ;
77068: GO 77038
77070: POP
77071: POP
// if selected then
77072: LD_VAR 0 7
77076: IFFALSE 77166
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
77078: LD_ADDR_VAR 0 3
77082: PUSH
77083: LD_EXP 88
77087: PUSH
77088: LD_VAR 0 2
77092: ARRAY
77093: PPUSH
77094: LD_INT 25
77096: PUSH
77097: LD_INT 12
77099: PUSH
77100: EMPTY
77101: LIST
77102: LIST
77103: PPUSH
77104: CALL_OW 72
77108: PUSH
77109: FOR_IN
77110: IFFALSE 77164
// if not IsInUnit ( j ) and not HasTask ( j ) then
77112: LD_VAR 0 3
77116: PPUSH
77117: CALL_OW 310
77121: NOT
77122: PUSH
77123: LD_VAR 0 3
77127: PPUSH
77128: CALL_OW 314
77132: NOT
77133: AND
77134: IFFALSE 77162
// begin ComEnterUnit ( j , selected ) ;
77136: LD_VAR 0 3
77140: PPUSH
77141: LD_VAR 0 7
77145: PPUSH
77146: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
77150: LD_VAR 0 3
77154: PPUSH
77155: LD_INT 15
77157: PPUSH
77158: CALL_OW 183
// end ;
77162: GO 77109
77164: POP
77165: POP
// end ; end ; end ; end ; end ;
77166: GO 76559
77168: POP
77169: POP
// end ;
77170: LD_VAR 0 1
77174: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
77175: LD_INT 0
77177: PPUSH
77178: PPUSH
77179: PPUSH
77180: PPUSH
// if not mc_bases then
77181: LD_EXP 59
77185: NOT
77186: IFFALSE 77190
// exit ;
77188: GO 77368
// for i = 1 to mc_bases do
77190: LD_ADDR_VAR 0 2
77194: PUSH
77195: DOUBLE
77196: LD_INT 1
77198: DEC
77199: ST_TO_ADDR
77200: LD_EXP 59
77204: PUSH
77205: FOR_TO
77206: IFFALSE 77366
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
77208: LD_ADDR_VAR 0 4
77212: PUSH
77213: LD_EXP 59
77217: PUSH
77218: LD_VAR 0 2
77222: ARRAY
77223: PPUSH
77224: LD_INT 25
77226: PUSH
77227: LD_INT 9
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: PPUSH
77234: CALL_OW 72
77238: ST_TO_ADDR
// if not tmp then
77239: LD_VAR 0 4
77243: NOT
77244: IFFALSE 77248
// continue ;
77246: GO 77205
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
77248: LD_EXP 85
77252: PUSH
77253: LD_VAR 0 2
77257: ARRAY
77258: PPUSH
77259: LD_INT 29
77261: PPUSH
77262: CALL_OW 325
77266: NOT
77267: PUSH
77268: LD_EXP 85
77272: PUSH
77273: LD_VAR 0 2
77277: ARRAY
77278: PPUSH
77279: LD_INT 28
77281: PPUSH
77282: CALL_OW 325
77286: NOT
77287: AND
77288: IFFALSE 77292
// continue ;
77290: GO 77205
// for j in tmp do
77292: LD_ADDR_VAR 0 3
77296: PUSH
77297: LD_VAR 0 4
77301: PUSH
77302: FOR_IN
77303: IFFALSE 77362
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77305: LD_VAR 0 3
77309: PUSH
77310: LD_EXP 62
77314: PUSH
77315: LD_VAR 0 2
77319: ARRAY
77320: PUSH
77321: LD_INT 1
77323: ARRAY
77324: IN
77325: NOT
77326: PUSH
77327: LD_VAR 0 3
77331: PUSH
77332: LD_EXP 62
77336: PUSH
77337: LD_VAR 0 2
77341: ARRAY
77342: PUSH
77343: LD_INT 2
77345: ARRAY
77346: IN
77347: NOT
77348: AND
77349: IFFALSE 77360
// ComSpaceTimeShoot ( j ) ;
77351: LD_VAR 0 3
77355: PPUSH
77356: CALL 15175 0 1
77360: GO 77302
77362: POP
77363: POP
// end ;
77364: GO 77205
77366: POP
77367: POP
// end ;
77368: LD_VAR 0 1
77372: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
77373: LD_INT 0
77375: PPUSH
77376: PPUSH
77377: PPUSH
77378: PPUSH
77379: PPUSH
77380: PPUSH
77381: PPUSH
77382: PPUSH
77383: PPUSH
// if not mc_bases then
77384: LD_EXP 59
77388: NOT
77389: IFFALSE 77393
// exit ;
77391: GO 78015
// for i = 1 to mc_bases do
77393: LD_ADDR_VAR 0 2
77397: PUSH
77398: DOUBLE
77399: LD_INT 1
77401: DEC
77402: ST_TO_ADDR
77403: LD_EXP 59
77407: PUSH
77408: FOR_TO
77409: IFFALSE 78013
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
77411: LD_EXP 94
77415: PUSH
77416: LD_VAR 0 2
77420: ARRAY
77421: NOT
77422: PUSH
77423: LD_INT 38
77425: PPUSH
77426: LD_EXP 85
77430: PUSH
77431: LD_VAR 0 2
77435: ARRAY
77436: PPUSH
77437: CALL_OW 321
77441: PUSH
77442: LD_INT 2
77444: NONEQUAL
77445: OR
77446: IFFALSE 77450
// continue ;
77448: GO 77408
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
77450: LD_ADDR_VAR 0 8
77454: PUSH
77455: LD_EXP 59
77459: PUSH
77460: LD_VAR 0 2
77464: ARRAY
77465: PPUSH
77466: LD_INT 30
77468: PUSH
77469: LD_INT 34
77471: PUSH
77472: EMPTY
77473: LIST
77474: LIST
77475: PPUSH
77476: CALL_OW 72
77480: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
77481: LD_ADDR_VAR 0 9
77485: PUSH
77486: LD_EXP 59
77490: PUSH
77491: LD_VAR 0 2
77495: ARRAY
77496: PPUSH
77497: LD_INT 25
77499: PUSH
77500: LD_INT 4
77502: PUSH
77503: EMPTY
77504: LIST
77505: LIST
77506: PPUSH
77507: CALL_OW 72
77511: PPUSH
77512: LD_INT 0
77514: PPUSH
77515: CALL 54859 0 2
77519: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
77520: LD_VAR 0 9
77524: NOT
77525: PUSH
77526: LD_VAR 0 8
77530: NOT
77531: OR
77532: PUSH
77533: LD_EXP 59
77537: PUSH
77538: LD_VAR 0 2
77542: ARRAY
77543: PPUSH
77544: LD_INT 124
77546: PPUSH
77547: CALL 54859 0 2
77551: OR
77552: IFFALSE 77556
// continue ;
77554: GO 77408
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
77556: LD_EXP 95
77560: PUSH
77561: LD_VAR 0 2
77565: ARRAY
77566: PUSH
77567: LD_EXP 94
77571: PUSH
77572: LD_VAR 0 2
77576: ARRAY
77577: LESS
77578: PUSH
77579: LD_EXP 95
77583: PUSH
77584: LD_VAR 0 2
77588: ARRAY
77589: PUSH
77590: LD_VAR 0 8
77594: LESS
77595: AND
77596: IFFALSE 78011
// begin tmp := sci [ 1 ] ;
77598: LD_ADDR_VAR 0 7
77602: PUSH
77603: LD_VAR 0 9
77607: PUSH
77608: LD_INT 1
77610: ARRAY
77611: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77612: LD_VAR 0 7
77616: PPUSH
77617: LD_INT 124
77619: PPUSH
77620: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77624: LD_ADDR_VAR 0 3
77628: PUSH
77629: DOUBLE
77630: LD_EXP 94
77634: PUSH
77635: LD_VAR 0 2
77639: ARRAY
77640: INC
77641: ST_TO_ADDR
77642: LD_EXP 94
77646: PUSH
77647: LD_VAR 0 2
77651: ARRAY
77652: PUSH
77653: FOR_DOWNTO
77654: IFFALSE 77997
// begin if IsInUnit ( tmp ) then
77656: LD_VAR 0 7
77660: PPUSH
77661: CALL_OW 310
77665: IFFALSE 77676
// ComExitBuilding ( tmp ) ;
77667: LD_VAR 0 7
77671: PPUSH
77672: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77676: LD_INT 35
77678: PPUSH
77679: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77683: LD_VAR 0 7
77687: PPUSH
77688: CALL_OW 310
77692: NOT
77693: PUSH
77694: LD_VAR 0 7
77698: PPUSH
77699: CALL_OW 314
77703: NOT
77704: AND
77705: IFFALSE 77676
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77707: LD_ADDR_VAR 0 6
77711: PUSH
77712: LD_VAR 0 7
77716: PPUSH
77717: CALL_OW 250
77721: PUSH
77722: LD_VAR 0 7
77726: PPUSH
77727: CALL_OW 251
77731: PUSH
77732: EMPTY
77733: LIST
77734: LIST
77735: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77736: LD_INT 35
77738: PPUSH
77739: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77743: LD_ADDR_VAR 0 4
77747: PUSH
77748: LD_EXP 94
77752: PUSH
77753: LD_VAR 0 2
77757: ARRAY
77758: PUSH
77759: LD_VAR 0 3
77763: ARRAY
77764: PUSH
77765: LD_INT 1
77767: ARRAY
77768: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77769: LD_ADDR_VAR 0 5
77773: PUSH
77774: LD_EXP 94
77778: PUSH
77779: LD_VAR 0 2
77783: ARRAY
77784: PUSH
77785: LD_VAR 0 3
77789: ARRAY
77790: PUSH
77791: LD_INT 2
77793: ARRAY
77794: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77795: LD_VAR 0 7
77799: PPUSH
77800: LD_INT 10
77802: PPUSH
77803: CALL 24182 0 2
77807: PUSH
77808: LD_INT 4
77810: ARRAY
77811: IFFALSE 77849
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77813: LD_VAR 0 7
77817: PPUSH
77818: LD_VAR 0 6
77822: PUSH
77823: LD_INT 1
77825: ARRAY
77826: PPUSH
77827: LD_VAR 0 6
77831: PUSH
77832: LD_INT 2
77834: ARRAY
77835: PPUSH
77836: CALL_OW 111
// wait ( 0 0$10 ) ;
77840: LD_INT 350
77842: PPUSH
77843: CALL_OW 67
// end else
77847: GO 77875
// begin ComMoveXY ( tmp , x , y ) ;
77849: LD_VAR 0 7
77853: PPUSH
77854: LD_VAR 0 4
77858: PPUSH
77859: LD_VAR 0 5
77863: PPUSH
77864: CALL_OW 111
// wait ( 0 0$3 ) ;
77868: LD_INT 105
77870: PPUSH
77871: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77875: LD_VAR 0 7
77879: PPUSH
77880: LD_VAR 0 4
77884: PPUSH
77885: LD_VAR 0 5
77889: PPUSH
77890: CALL_OW 307
77894: IFFALSE 77736
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77896: LD_VAR 0 7
77900: PPUSH
77901: LD_VAR 0 4
77905: PPUSH
77906: LD_VAR 0 5
77910: PPUSH
77911: LD_VAR 0 8
77915: PUSH
77916: LD_VAR 0 3
77920: ARRAY
77921: PPUSH
77922: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77926: LD_INT 35
77928: PPUSH
77929: CALL_OW 67
// until not HasTask ( tmp ) ;
77933: LD_VAR 0 7
77937: PPUSH
77938: CALL_OW 314
77942: NOT
77943: IFFALSE 77926
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77945: LD_ADDR_EXP 95
77949: PUSH
77950: LD_EXP 95
77954: PPUSH
77955: LD_VAR 0 2
77959: PUSH
77960: LD_EXP 95
77964: PUSH
77965: LD_VAR 0 2
77969: ARRAY
77970: PUSH
77971: LD_INT 1
77973: PLUS
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: PPUSH
77979: LD_VAR 0 8
77983: PUSH
77984: LD_VAR 0 3
77988: ARRAY
77989: PPUSH
77990: CALL 21589 0 3
77994: ST_TO_ADDR
// end ;
77995: GO 77653
77997: POP
77998: POP
// MC_Reset ( i , 124 ) ;
77999: LD_VAR 0 2
78003: PPUSH
78004: LD_INT 124
78006: PPUSH
78007: CALL 61602 0 2
// end ; end ;
78011: GO 77408
78013: POP
78014: POP
// end ;
78015: LD_VAR 0 1
78019: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
78020: LD_INT 0
78022: PPUSH
78023: PPUSH
78024: PPUSH
// if not mc_bases then
78025: LD_EXP 59
78029: NOT
78030: IFFALSE 78034
// exit ;
78032: GO 78640
// for i = 1 to mc_bases do
78034: LD_ADDR_VAR 0 2
78038: PUSH
78039: DOUBLE
78040: LD_INT 1
78042: DEC
78043: ST_TO_ADDR
78044: LD_EXP 59
78048: PUSH
78049: FOR_TO
78050: IFFALSE 78638
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
78052: LD_ADDR_VAR 0 3
78056: PUSH
78057: LD_EXP 59
78061: PUSH
78062: LD_VAR 0 2
78066: ARRAY
78067: PPUSH
78068: LD_INT 25
78070: PUSH
78071: LD_INT 4
78073: PUSH
78074: EMPTY
78075: LIST
78076: LIST
78077: PPUSH
78078: CALL_OW 72
78082: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78083: LD_VAR 0 3
78087: NOT
78088: PUSH
78089: LD_EXP 96
78093: PUSH
78094: LD_VAR 0 2
78098: ARRAY
78099: NOT
78100: OR
78101: PUSH
78102: LD_EXP 59
78106: PUSH
78107: LD_VAR 0 2
78111: ARRAY
78112: PPUSH
78113: LD_INT 2
78115: PUSH
78116: LD_INT 30
78118: PUSH
78119: LD_INT 0
78121: PUSH
78122: EMPTY
78123: LIST
78124: LIST
78125: PUSH
78126: LD_INT 30
78128: PUSH
78129: LD_INT 1
78131: PUSH
78132: EMPTY
78133: LIST
78134: LIST
78135: PUSH
78136: EMPTY
78137: LIST
78138: LIST
78139: LIST
78140: PPUSH
78141: CALL_OW 72
78145: NOT
78146: OR
78147: IFFALSE 78197
// begin if mc_deposits_finder [ i ] then
78149: LD_EXP 97
78153: PUSH
78154: LD_VAR 0 2
78158: ARRAY
78159: IFFALSE 78195
// begin MC_Reset ( i , 125 ) ;
78161: LD_VAR 0 2
78165: PPUSH
78166: LD_INT 125
78168: PPUSH
78169: CALL 61602 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78173: LD_ADDR_EXP 97
78177: PUSH
78178: LD_EXP 97
78182: PPUSH
78183: LD_VAR 0 2
78187: PPUSH
78188: EMPTY
78189: PPUSH
78190: CALL_OW 1
78194: ST_TO_ADDR
// end ; continue ;
78195: GO 78049
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
78197: LD_EXP 96
78201: PUSH
78202: LD_VAR 0 2
78206: ARRAY
78207: PUSH
78208: LD_INT 1
78210: ARRAY
78211: PUSH
78212: LD_INT 3
78214: ARRAY
78215: PUSH
78216: LD_INT 1
78218: EQUAL
78219: PUSH
78220: LD_INT 20
78222: PPUSH
78223: LD_EXP 85
78227: PUSH
78228: LD_VAR 0 2
78232: ARRAY
78233: PPUSH
78234: CALL_OW 321
78238: PUSH
78239: LD_INT 2
78241: NONEQUAL
78242: AND
78243: IFFALSE 78293
// begin if mc_deposits_finder [ i ] then
78245: LD_EXP 97
78249: PUSH
78250: LD_VAR 0 2
78254: ARRAY
78255: IFFALSE 78291
// begin MC_Reset ( i , 125 ) ;
78257: LD_VAR 0 2
78261: PPUSH
78262: LD_INT 125
78264: PPUSH
78265: CALL 61602 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78269: LD_ADDR_EXP 97
78273: PUSH
78274: LD_EXP 97
78278: PPUSH
78279: LD_VAR 0 2
78283: PPUSH
78284: EMPTY
78285: PPUSH
78286: CALL_OW 1
78290: ST_TO_ADDR
// end ; continue ;
78291: GO 78049
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
78293: LD_EXP 96
78297: PUSH
78298: LD_VAR 0 2
78302: ARRAY
78303: PUSH
78304: LD_INT 1
78306: ARRAY
78307: PUSH
78308: LD_INT 1
78310: ARRAY
78311: PPUSH
78312: LD_EXP 96
78316: PUSH
78317: LD_VAR 0 2
78321: ARRAY
78322: PUSH
78323: LD_INT 1
78325: ARRAY
78326: PUSH
78327: LD_INT 2
78329: ARRAY
78330: PPUSH
78331: LD_EXP 85
78335: PUSH
78336: LD_VAR 0 2
78340: ARRAY
78341: PPUSH
78342: CALL_OW 440
78346: IFFALSE 78389
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
78348: LD_ADDR_EXP 96
78352: PUSH
78353: LD_EXP 96
78357: PPUSH
78358: LD_VAR 0 2
78362: PPUSH
78363: LD_EXP 96
78367: PUSH
78368: LD_VAR 0 2
78372: ARRAY
78373: PPUSH
78374: LD_INT 1
78376: PPUSH
78377: CALL_OW 3
78381: PPUSH
78382: CALL_OW 1
78386: ST_TO_ADDR
78387: GO 78636
// begin if not mc_deposits_finder [ i ] then
78389: LD_EXP 97
78393: PUSH
78394: LD_VAR 0 2
78398: ARRAY
78399: NOT
78400: IFFALSE 78452
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
78402: LD_ADDR_EXP 97
78406: PUSH
78407: LD_EXP 97
78411: PPUSH
78412: LD_VAR 0 2
78416: PPUSH
78417: LD_VAR 0 3
78421: PUSH
78422: LD_INT 1
78424: ARRAY
78425: PUSH
78426: EMPTY
78427: LIST
78428: PPUSH
78429: CALL_OW 1
78433: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
78434: LD_VAR 0 3
78438: PUSH
78439: LD_INT 1
78441: ARRAY
78442: PPUSH
78443: LD_INT 125
78445: PPUSH
78446: CALL_OW 109
// end else
78450: GO 78636
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
78452: LD_EXP 97
78456: PUSH
78457: LD_VAR 0 2
78461: ARRAY
78462: PUSH
78463: LD_INT 1
78465: ARRAY
78466: PPUSH
78467: CALL_OW 310
78471: IFFALSE 78494
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
78473: LD_EXP 97
78477: PUSH
78478: LD_VAR 0 2
78482: ARRAY
78483: PUSH
78484: LD_INT 1
78486: ARRAY
78487: PPUSH
78488: CALL_OW 122
78492: GO 78636
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
78494: LD_EXP 97
78498: PUSH
78499: LD_VAR 0 2
78503: ARRAY
78504: PUSH
78505: LD_INT 1
78507: ARRAY
78508: PPUSH
78509: CALL_OW 314
78513: NOT
78514: PUSH
78515: LD_EXP 97
78519: PUSH
78520: LD_VAR 0 2
78524: ARRAY
78525: PUSH
78526: LD_INT 1
78528: ARRAY
78529: PPUSH
78530: LD_EXP 96
78534: PUSH
78535: LD_VAR 0 2
78539: ARRAY
78540: PUSH
78541: LD_INT 1
78543: ARRAY
78544: PUSH
78545: LD_INT 1
78547: ARRAY
78548: PPUSH
78549: LD_EXP 96
78553: PUSH
78554: LD_VAR 0 2
78558: ARRAY
78559: PUSH
78560: LD_INT 1
78562: ARRAY
78563: PUSH
78564: LD_INT 2
78566: ARRAY
78567: PPUSH
78568: CALL_OW 297
78572: PUSH
78573: LD_INT 6
78575: GREATER
78576: AND
78577: IFFALSE 78636
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
78579: LD_EXP 97
78583: PUSH
78584: LD_VAR 0 2
78588: ARRAY
78589: PUSH
78590: LD_INT 1
78592: ARRAY
78593: PPUSH
78594: LD_EXP 96
78598: PUSH
78599: LD_VAR 0 2
78603: ARRAY
78604: PUSH
78605: LD_INT 1
78607: ARRAY
78608: PUSH
78609: LD_INT 1
78611: ARRAY
78612: PPUSH
78613: LD_EXP 96
78617: PUSH
78618: LD_VAR 0 2
78622: ARRAY
78623: PUSH
78624: LD_INT 1
78626: ARRAY
78627: PUSH
78628: LD_INT 2
78630: ARRAY
78631: PPUSH
78632: CALL_OW 111
// end ; end ; end ;
78636: GO 78049
78638: POP
78639: POP
// end ;
78640: LD_VAR 0 1
78644: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78645: LD_INT 0
78647: PPUSH
78648: PPUSH
78649: PPUSH
78650: PPUSH
78651: PPUSH
78652: PPUSH
78653: PPUSH
78654: PPUSH
78655: PPUSH
78656: PPUSH
78657: PPUSH
// if not mc_bases then
78658: LD_EXP 59
78662: NOT
78663: IFFALSE 78667
// exit ;
78665: GO 79607
// for i = 1 to mc_bases do
78667: LD_ADDR_VAR 0 2
78671: PUSH
78672: DOUBLE
78673: LD_INT 1
78675: DEC
78676: ST_TO_ADDR
78677: LD_EXP 59
78681: PUSH
78682: FOR_TO
78683: IFFALSE 79605
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78685: LD_EXP 59
78689: PUSH
78690: LD_VAR 0 2
78694: ARRAY
78695: NOT
78696: PUSH
78697: LD_EXP 82
78701: PUSH
78702: LD_VAR 0 2
78706: ARRAY
78707: OR
78708: IFFALSE 78712
// continue ;
78710: GO 78682
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78712: LD_ADDR_VAR 0 7
78716: PUSH
78717: LD_EXP 59
78721: PUSH
78722: LD_VAR 0 2
78726: ARRAY
78727: PUSH
78728: LD_INT 1
78730: ARRAY
78731: PPUSH
78732: CALL_OW 248
78736: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78737: LD_VAR 0 7
78741: PUSH
78742: LD_INT 3
78744: EQUAL
78745: PUSH
78746: LD_EXP 78
78750: PUSH
78751: LD_VAR 0 2
78755: ARRAY
78756: PUSH
78757: LD_EXP 81
78761: PUSH
78762: LD_VAR 0 2
78766: ARRAY
78767: UNION
78768: PPUSH
78769: LD_INT 33
78771: PUSH
78772: LD_INT 2
78774: PUSH
78775: EMPTY
78776: LIST
78777: LIST
78778: PPUSH
78779: CALL_OW 72
78783: NOT
78784: OR
78785: IFFALSE 78789
// continue ;
78787: GO 78682
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78789: LD_ADDR_VAR 0 9
78793: PUSH
78794: LD_EXP 59
78798: PUSH
78799: LD_VAR 0 2
78803: ARRAY
78804: PPUSH
78805: LD_INT 30
78807: PUSH
78808: LD_INT 36
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: PPUSH
78815: CALL_OW 72
78819: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78820: LD_ADDR_VAR 0 10
78824: PUSH
78825: LD_EXP 78
78829: PUSH
78830: LD_VAR 0 2
78834: ARRAY
78835: PPUSH
78836: LD_INT 34
78838: PUSH
78839: LD_INT 31
78841: PUSH
78842: EMPTY
78843: LIST
78844: LIST
78845: PPUSH
78846: CALL_OW 72
78850: ST_TO_ADDR
// if not cts and not mcts then
78851: LD_VAR 0 9
78855: NOT
78856: PUSH
78857: LD_VAR 0 10
78861: NOT
78862: AND
78863: IFFALSE 78867
// continue ;
78865: GO 78682
// x := cts ;
78867: LD_ADDR_VAR 0 11
78871: PUSH
78872: LD_VAR 0 9
78876: ST_TO_ADDR
// if not x then
78877: LD_VAR 0 11
78881: NOT
78882: IFFALSE 78894
// x := mcts ;
78884: LD_ADDR_VAR 0 11
78888: PUSH
78889: LD_VAR 0 10
78893: ST_TO_ADDR
// if not x then
78894: LD_VAR 0 11
78898: NOT
78899: IFFALSE 78903
// continue ;
78901: GO 78682
// if mc_remote_driver [ i ] then
78903: LD_EXP 99
78907: PUSH
78908: LD_VAR 0 2
78912: ARRAY
78913: IFFALSE 79300
// for j in mc_remote_driver [ i ] do
78915: LD_ADDR_VAR 0 3
78919: PUSH
78920: LD_EXP 99
78924: PUSH
78925: LD_VAR 0 2
78929: ARRAY
78930: PUSH
78931: FOR_IN
78932: IFFALSE 79298
// begin if GetClass ( j ) <> 3 then
78934: LD_VAR 0 3
78938: PPUSH
78939: CALL_OW 257
78943: PUSH
78944: LD_INT 3
78946: NONEQUAL
78947: IFFALSE 79000
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78949: LD_ADDR_EXP 99
78953: PUSH
78954: LD_EXP 99
78958: PPUSH
78959: LD_VAR 0 2
78963: PPUSH
78964: LD_EXP 99
78968: PUSH
78969: LD_VAR 0 2
78973: ARRAY
78974: PUSH
78975: LD_VAR 0 3
78979: DIFF
78980: PPUSH
78981: CALL_OW 1
78985: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78986: LD_VAR 0 3
78990: PPUSH
78991: LD_INT 0
78993: PPUSH
78994: CALL_OW 109
// continue ;
78998: GO 78931
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
79000: LD_EXP 78
79004: PUSH
79005: LD_VAR 0 2
79009: ARRAY
79010: PPUSH
79011: LD_INT 34
79013: PUSH
79014: LD_INT 31
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: LD_INT 58
79023: PUSH
79024: EMPTY
79025: LIST
79026: PUSH
79027: EMPTY
79028: LIST
79029: LIST
79030: PPUSH
79031: CALL_OW 72
79035: PUSH
79036: LD_VAR 0 3
79040: PPUSH
79041: CALL 54947 0 1
79045: NOT
79046: AND
79047: IFFALSE 79118
// begin if IsInUnit ( j ) then
79049: LD_VAR 0 3
79053: PPUSH
79054: CALL_OW 310
79058: IFFALSE 79069
// ComExitBuilding ( j ) ;
79060: LD_VAR 0 3
79064: PPUSH
79065: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
79069: LD_VAR 0 3
79073: PPUSH
79074: LD_EXP 78
79078: PUSH
79079: LD_VAR 0 2
79083: ARRAY
79084: PPUSH
79085: LD_INT 34
79087: PUSH
79088: LD_INT 31
79090: PUSH
79091: EMPTY
79092: LIST
79093: LIST
79094: PUSH
79095: LD_INT 58
79097: PUSH
79098: EMPTY
79099: LIST
79100: PUSH
79101: EMPTY
79102: LIST
79103: LIST
79104: PPUSH
79105: CALL_OW 72
79109: PUSH
79110: LD_INT 1
79112: ARRAY
79113: PPUSH
79114: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
79118: LD_VAR 0 3
79122: PPUSH
79123: CALL_OW 310
79127: NOT
79128: PUSH
79129: LD_VAR 0 3
79133: PPUSH
79134: CALL_OW 310
79138: PPUSH
79139: CALL_OW 266
79143: PUSH
79144: LD_INT 36
79146: NONEQUAL
79147: PUSH
79148: LD_VAR 0 3
79152: PPUSH
79153: CALL 54947 0 1
79157: NOT
79158: AND
79159: OR
79160: IFFALSE 79296
// begin if IsInUnit ( j ) then
79162: LD_VAR 0 3
79166: PPUSH
79167: CALL_OW 310
79171: IFFALSE 79182
// ComExitBuilding ( j ) ;
79173: LD_VAR 0 3
79177: PPUSH
79178: CALL_OW 122
// ct := 0 ;
79182: LD_ADDR_VAR 0 8
79186: PUSH
79187: LD_INT 0
79189: ST_TO_ADDR
// for k in x do
79190: LD_ADDR_VAR 0 4
79194: PUSH
79195: LD_VAR 0 11
79199: PUSH
79200: FOR_IN
79201: IFFALSE 79274
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
79203: LD_VAR 0 4
79207: PPUSH
79208: CALL_OW 264
79212: PUSH
79213: LD_INT 31
79215: EQUAL
79216: PUSH
79217: LD_VAR 0 4
79221: PPUSH
79222: CALL_OW 311
79226: NOT
79227: AND
79228: PUSH
79229: LD_VAR 0 4
79233: PPUSH
79234: CALL_OW 266
79238: PUSH
79239: LD_INT 36
79241: EQUAL
79242: PUSH
79243: LD_VAR 0 4
79247: PPUSH
79248: CALL_OW 313
79252: PUSH
79253: LD_INT 3
79255: LESS
79256: AND
79257: OR
79258: IFFALSE 79272
// begin ct := k ;
79260: LD_ADDR_VAR 0 8
79264: PUSH
79265: LD_VAR 0 4
79269: ST_TO_ADDR
// break ;
79270: GO 79274
// end ;
79272: GO 79200
79274: POP
79275: POP
// if ct then
79276: LD_VAR 0 8
79280: IFFALSE 79296
// ComEnterUnit ( j , ct ) ;
79282: LD_VAR 0 3
79286: PPUSH
79287: LD_VAR 0 8
79291: PPUSH
79292: CALL_OW 120
// end ; end ;
79296: GO 78931
79298: POP
79299: POP
// places := 0 ;
79300: LD_ADDR_VAR 0 5
79304: PUSH
79305: LD_INT 0
79307: ST_TO_ADDR
// for j = 1 to x do
79308: LD_ADDR_VAR 0 3
79312: PUSH
79313: DOUBLE
79314: LD_INT 1
79316: DEC
79317: ST_TO_ADDR
79318: LD_VAR 0 11
79322: PUSH
79323: FOR_TO
79324: IFFALSE 79400
// if GetWeapon ( x [ j ] ) = ar_control_tower then
79326: LD_VAR 0 11
79330: PUSH
79331: LD_VAR 0 3
79335: ARRAY
79336: PPUSH
79337: CALL_OW 264
79341: PUSH
79342: LD_INT 31
79344: EQUAL
79345: IFFALSE 79363
// places := places + 1 else
79347: LD_ADDR_VAR 0 5
79351: PUSH
79352: LD_VAR 0 5
79356: PUSH
79357: LD_INT 1
79359: PLUS
79360: ST_TO_ADDR
79361: GO 79398
// if GetBType ( x [ j ] ) = b_control_tower then
79363: LD_VAR 0 11
79367: PUSH
79368: LD_VAR 0 3
79372: ARRAY
79373: PPUSH
79374: CALL_OW 266
79378: PUSH
79379: LD_INT 36
79381: EQUAL
79382: IFFALSE 79398
// places := places + 3 ;
79384: LD_ADDR_VAR 0 5
79388: PUSH
79389: LD_VAR 0 5
79393: PUSH
79394: LD_INT 3
79396: PLUS
79397: ST_TO_ADDR
79398: GO 79323
79400: POP
79401: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
79402: LD_VAR 0 5
79406: PUSH
79407: LD_INT 0
79409: EQUAL
79410: PUSH
79411: LD_VAR 0 5
79415: PUSH
79416: LD_EXP 99
79420: PUSH
79421: LD_VAR 0 2
79425: ARRAY
79426: LESSEQUAL
79427: OR
79428: IFFALSE 79432
// continue ;
79430: GO 78682
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
79432: LD_ADDR_VAR 0 6
79436: PUSH
79437: LD_EXP 59
79441: PUSH
79442: LD_VAR 0 2
79446: ARRAY
79447: PPUSH
79448: LD_INT 25
79450: PUSH
79451: LD_INT 3
79453: PUSH
79454: EMPTY
79455: LIST
79456: LIST
79457: PPUSH
79458: CALL_OW 72
79462: PUSH
79463: LD_EXP 99
79467: PUSH
79468: LD_VAR 0 2
79472: ARRAY
79473: DIFF
79474: PPUSH
79475: LD_INT 3
79477: PPUSH
79478: CALL 55847 0 2
79482: ST_TO_ADDR
// for j in tmp do
79483: LD_ADDR_VAR 0 3
79487: PUSH
79488: LD_VAR 0 6
79492: PUSH
79493: FOR_IN
79494: IFFALSE 79529
// if GetTag ( j ) > 0 then
79496: LD_VAR 0 3
79500: PPUSH
79501: CALL_OW 110
79505: PUSH
79506: LD_INT 0
79508: GREATER
79509: IFFALSE 79527
// tmp := tmp diff j ;
79511: LD_ADDR_VAR 0 6
79515: PUSH
79516: LD_VAR 0 6
79520: PUSH
79521: LD_VAR 0 3
79525: DIFF
79526: ST_TO_ADDR
79527: GO 79493
79529: POP
79530: POP
// if not tmp then
79531: LD_VAR 0 6
79535: NOT
79536: IFFALSE 79540
// continue ;
79538: GO 78682
// if places then
79540: LD_VAR 0 5
79544: IFFALSE 79603
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
79546: LD_ADDR_EXP 99
79550: PUSH
79551: LD_EXP 99
79555: PPUSH
79556: LD_VAR 0 2
79560: PPUSH
79561: LD_EXP 99
79565: PUSH
79566: LD_VAR 0 2
79570: ARRAY
79571: PUSH
79572: LD_VAR 0 6
79576: PUSH
79577: LD_INT 1
79579: ARRAY
79580: UNION
79581: PPUSH
79582: CALL_OW 1
79586: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
79587: LD_VAR 0 6
79591: PUSH
79592: LD_INT 1
79594: ARRAY
79595: PPUSH
79596: LD_INT 126
79598: PPUSH
79599: CALL_OW 109
// end ; end ;
79603: GO 78682
79605: POP
79606: POP
// end ;
79607: LD_VAR 0 1
79611: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79612: LD_INT 0
79614: PPUSH
79615: PPUSH
79616: PPUSH
79617: PPUSH
79618: PPUSH
79619: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79620: LD_VAR 0 1
79624: NOT
79625: PUSH
79626: LD_VAR 0 2
79630: NOT
79631: OR
79632: PUSH
79633: LD_VAR 0 3
79637: NOT
79638: OR
79639: PUSH
79640: LD_VAR 0 4
79644: PUSH
79645: LD_INT 1
79647: PUSH
79648: LD_INT 2
79650: PUSH
79651: LD_INT 3
79653: PUSH
79654: LD_INT 4
79656: PUSH
79657: LD_INT 5
79659: PUSH
79660: LD_INT 8
79662: PUSH
79663: LD_INT 9
79665: PUSH
79666: LD_INT 15
79668: PUSH
79669: LD_INT 16
79671: PUSH
79672: EMPTY
79673: LIST
79674: LIST
79675: LIST
79676: LIST
79677: LIST
79678: LIST
79679: LIST
79680: LIST
79681: LIST
79682: IN
79683: NOT
79684: OR
79685: IFFALSE 79689
// exit ;
79687: GO 80589
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79689: LD_ADDR_VAR 0 2
79693: PUSH
79694: LD_VAR 0 2
79698: PPUSH
79699: LD_INT 21
79701: PUSH
79702: LD_INT 3
79704: PUSH
79705: EMPTY
79706: LIST
79707: LIST
79708: PUSH
79709: LD_INT 24
79711: PUSH
79712: LD_INT 250
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: PUSH
79719: EMPTY
79720: LIST
79721: LIST
79722: PPUSH
79723: CALL_OW 72
79727: ST_TO_ADDR
// case class of 1 , 15 :
79728: LD_VAR 0 4
79732: PUSH
79733: LD_INT 1
79735: DOUBLE
79736: EQUAL
79737: IFTRUE 79747
79739: LD_INT 15
79741: DOUBLE
79742: EQUAL
79743: IFTRUE 79747
79745: GO 79832
79747: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79748: LD_ADDR_VAR 0 8
79752: PUSH
79753: LD_VAR 0 2
79757: PPUSH
79758: LD_INT 2
79760: PUSH
79761: LD_INT 30
79763: PUSH
79764: LD_INT 32
79766: PUSH
79767: EMPTY
79768: LIST
79769: LIST
79770: PUSH
79771: LD_INT 30
79773: PUSH
79774: LD_INT 31
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: LIST
79785: PPUSH
79786: CALL_OW 72
79790: PUSH
79791: LD_VAR 0 2
79795: PPUSH
79796: LD_INT 2
79798: PUSH
79799: LD_INT 30
79801: PUSH
79802: LD_INT 4
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: PUSH
79809: LD_INT 30
79811: PUSH
79812: LD_INT 5
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: EMPTY
79820: LIST
79821: LIST
79822: LIST
79823: PPUSH
79824: CALL_OW 72
79828: ADD
79829: ST_TO_ADDR
79830: GO 80078
79832: LD_INT 2
79834: DOUBLE
79835: EQUAL
79836: IFTRUE 79846
79838: LD_INT 16
79840: DOUBLE
79841: EQUAL
79842: IFTRUE 79846
79844: GO 79892
79846: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79847: LD_ADDR_VAR 0 8
79851: PUSH
79852: LD_VAR 0 2
79856: PPUSH
79857: LD_INT 2
79859: PUSH
79860: LD_INT 30
79862: PUSH
79863: LD_INT 0
79865: PUSH
79866: EMPTY
79867: LIST
79868: LIST
79869: PUSH
79870: LD_INT 30
79872: PUSH
79873: LD_INT 1
79875: PUSH
79876: EMPTY
79877: LIST
79878: LIST
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: LIST
79884: PPUSH
79885: CALL_OW 72
79889: ST_TO_ADDR
79890: GO 80078
79892: LD_INT 3
79894: DOUBLE
79895: EQUAL
79896: IFTRUE 79900
79898: GO 79946
79900: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79901: LD_ADDR_VAR 0 8
79905: PUSH
79906: LD_VAR 0 2
79910: PPUSH
79911: LD_INT 2
79913: PUSH
79914: LD_INT 30
79916: PUSH
79917: LD_INT 2
79919: PUSH
79920: EMPTY
79921: LIST
79922: LIST
79923: PUSH
79924: LD_INT 30
79926: PUSH
79927: LD_INT 3
79929: PUSH
79930: EMPTY
79931: LIST
79932: LIST
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: LIST
79938: PPUSH
79939: CALL_OW 72
79943: ST_TO_ADDR
79944: GO 80078
79946: LD_INT 4
79948: DOUBLE
79949: EQUAL
79950: IFTRUE 79954
79952: GO 80011
79954: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79955: LD_ADDR_VAR 0 8
79959: PUSH
79960: LD_VAR 0 2
79964: PPUSH
79965: LD_INT 2
79967: PUSH
79968: LD_INT 30
79970: PUSH
79971: LD_INT 6
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: PUSH
79978: LD_INT 30
79980: PUSH
79981: LD_INT 7
79983: PUSH
79984: EMPTY
79985: LIST
79986: LIST
79987: PUSH
79988: LD_INT 30
79990: PUSH
79991: LD_INT 8
79993: PUSH
79994: EMPTY
79995: LIST
79996: LIST
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: LIST
80002: LIST
80003: PPUSH
80004: CALL_OW 72
80008: ST_TO_ADDR
80009: GO 80078
80011: LD_INT 5
80013: DOUBLE
80014: EQUAL
80015: IFTRUE 80031
80017: LD_INT 8
80019: DOUBLE
80020: EQUAL
80021: IFTRUE 80031
80023: LD_INT 9
80025: DOUBLE
80026: EQUAL
80027: IFTRUE 80031
80029: GO 80077
80031: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
80032: LD_ADDR_VAR 0 8
80036: PUSH
80037: LD_VAR 0 2
80041: PPUSH
80042: LD_INT 2
80044: PUSH
80045: LD_INT 30
80047: PUSH
80048: LD_INT 4
80050: PUSH
80051: EMPTY
80052: LIST
80053: LIST
80054: PUSH
80055: LD_INT 30
80057: PUSH
80058: LD_INT 5
80060: PUSH
80061: EMPTY
80062: LIST
80063: LIST
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: LIST
80069: PPUSH
80070: CALL_OW 72
80074: ST_TO_ADDR
80075: GO 80078
80077: POP
// if not tmp then
80078: LD_VAR 0 8
80082: NOT
80083: IFFALSE 80087
// exit ;
80085: GO 80589
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
80087: LD_VAR 0 4
80091: PUSH
80092: LD_INT 1
80094: PUSH
80095: LD_INT 15
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: IN
80102: PUSH
80103: LD_EXP 68
80107: PUSH
80108: LD_VAR 0 1
80112: ARRAY
80113: AND
80114: IFFALSE 80270
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
80116: LD_ADDR_VAR 0 9
80120: PUSH
80121: LD_EXP 68
80125: PUSH
80126: LD_VAR 0 1
80130: ARRAY
80131: PUSH
80132: LD_INT 1
80134: ARRAY
80135: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
80136: LD_VAR 0 9
80140: PUSH
80141: LD_EXP 69
80145: PUSH
80146: LD_VAR 0 1
80150: ARRAY
80151: IN
80152: NOT
80153: IFFALSE 80268
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
80155: LD_ADDR_EXP 69
80159: PUSH
80160: LD_EXP 69
80164: PPUSH
80165: LD_VAR 0 1
80169: PUSH
80170: LD_EXP 69
80174: PUSH
80175: LD_VAR 0 1
80179: ARRAY
80180: PUSH
80181: LD_INT 1
80183: PLUS
80184: PUSH
80185: EMPTY
80186: LIST
80187: LIST
80188: PPUSH
80189: LD_VAR 0 9
80193: PPUSH
80194: CALL 21589 0 3
80198: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
80199: LD_ADDR_EXP 68
80203: PUSH
80204: LD_EXP 68
80208: PPUSH
80209: LD_VAR 0 1
80213: PPUSH
80214: LD_EXP 68
80218: PUSH
80219: LD_VAR 0 1
80223: ARRAY
80224: PUSH
80225: LD_VAR 0 9
80229: DIFF
80230: PPUSH
80231: CALL_OW 1
80235: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
80236: LD_VAR 0 3
80240: PPUSH
80241: LD_EXP 69
80245: PUSH
80246: LD_VAR 0 1
80250: ARRAY
80251: PUSH
80252: LD_EXP 69
80256: PUSH
80257: LD_VAR 0 1
80261: ARRAY
80262: ARRAY
80263: PPUSH
80264: CALL_OW 120
// end ; exit ;
80268: GO 80589
// end ; if tmp > 1 then
80270: LD_VAR 0 8
80274: PUSH
80275: LD_INT 1
80277: GREATER
80278: IFFALSE 80382
// for i = 2 to tmp do
80280: LD_ADDR_VAR 0 6
80284: PUSH
80285: DOUBLE
80286: LD_INT 2
80288: DEC
80289: ST_TO_ADDR
80290: LD_VAR 0 8
80294: PUSH
80295: FOR_TO
80296: IFFALSE 80380
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
80298: LD_VAR 0 8
80302: PUSH
80303: LD_VAR 0 6
80307: ARRAY
80308: PPUSH
80309: CALL_OW 461
80313: PUSH
80314: LD_INT 6
80316: EQUAL
80317: IFFALSE 80378
// begin x := tmp [ i ] ;
80319: LD_ADDR_VAR 0 9
80323: PUSH
80324: LD_VAR 0 8
80328: PUSH
80329: LD_VAR 0 6
80333: ARRAY
80334: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
80335: LD_ADDR_VAR 0 8
80339: PUSH
80340: LD_VAR 0 8
80344: PPUSH
80345: LD_VAR 0 6
80349: PPUSH
80350: CALL_OW 3
80354: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
80355: LD_ADDR_VAR 0 8
80359: PUSH
80360: LD_VAR 0 8
80364: PPUSH
80365: LD_INT 1
80367: PPUSH
80368: LD_VAR 0 9
80372: PPUSH
80373: CALL_OW 2
80377: ST_TO_ADDR
// end ;
80378: GO 80295
80380: POP
80381: POP
// for i in tmp do
80382: LD_ADDR_VAR 0 6
80386: PUSH
80387: LD_VAR 0 8
80391: PUSH
80392: FOR_IN
80393: IFFALSE 80462
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
80395: LD_VAR 0 6
80399: PPUSH
80400: CALL_OW 313
80404: PUSH
80405: LD_INT 6
80407: LESS
80408: PUSH
80409: LD_VAR 0 6
80413: PPUSH
80414: CALL_OW 266
80418: PUSH
80419: LD_INT 31
80421: PUSH
80422: LD_INT 32
80424: PUSH
80425: EMPTY
80426: LIST
80427: LIST
80428: IN
80429: NOT
80430: AND
80431: PUSH
80432: LD_VAR 0 6
80436: PPUSH
80437: CALL_OW 313
80441: PUSH
80442: LD_INT 0
80444: EQUAL
80445: OR
80446: IFFALSE 80460
// begin j := i ;
80448: LD_ADDR_VAR 0 7
80452: PUSH
80453: LD_VAR 0 6
80457: ST_TO_ADDR
// break ;
80458: GO 80462
// end ; end ;
80460: GO 80392
80462: POP
80463: POP
// if j then
80464: LD_VAR 0 7
80468: IFFALSE 80486
// ComEnterUnit ( unit , j ) else
80470: LD_VAR 0 3
80474: PPUSH
80475: LD_VAR 0 7
80479: PPUSH
80480: CALL_OW 120
80484: GO 80589
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80486: LD_ADDR_VAR 0 10
80490: PUSH
80491: LD_VAR 0 2
80495: PPUSH
80496: LD_INT 2
80498: PUSH
80499: LD_INT 30
80501: PUSH
80502: LD_INT 0
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: LD_INT 30
80511: PUSH
80512: LD_INT 1
80514: PUSH
80515: EMPTY
80516: LIST
80517: LIST
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: LIST
80523: PPUSH
80524: CALL_OW 72
80528: ST_TO_ADDR
// if depot then
80529: LD_VAR 0 10
80533: IFFALSE 80589
// begin depot := NearestUnitToUnit ( depot , unit ) ;
80535: LD_ADDR_VAR 0 10
80539: PUSH
80540: LD_VAR 0 10
80544: PPUSH
80545: LD_VAR 0 3
80549: PPUSH
80550: CALL_OW 74
80554: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
80555: LD_VAR 0 3
80559: PPUSH
80560: LD_VAR 0 10
80564: PPUSH
80565: CALL_OW 296
80569: PUSH
80570: LD_INT 10
80572: GREATER
80573: IFFALSE 80589
// ComStandNearbyBuilding ( unit , depot ) ;
80575: LD_VAR 0 3
80579: PPUSH
80580: LD_VAR 0 10
80584: PPUSH
80585: CALL 15792 0 2
// end ; end ; end ;
80589: LD_VAR 0 5
80593: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
80594: LD_INT 0
80596: PPUSH
80597: PPUSH
80598: PPUSH
80599: PPUSH
// if not mc_bases then
80600: LD_EXP 59
80604: NOT
80605: IFFALSE 80609
// exit ;
80607: GO 80848
// for i = 1 to mc_bases do
80609: LD_ADDR_VAR 0 2
80613: PUSH
80614: DOUBLE
80615: LD_INT 1
80617: DEC
80618: ST_TO_ADDR
80619: LD_EXP 59
80623: PUSH
80624: FOR_TO
80625: IFFALSE 80846
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80627: LD_ADDR_VAR 0 4
80631: PUSH
80632: LD_EXP 59
80636: PUSH
80637: LD_VAR 0 2
80641: ARRAY
80642: PPUSH
80643: LD_INT 21
80645: PUSH
80646: LD_INT 1
80648: PUSH
80649: EMPTY
80650: LIST
80651: LIST
80652: PPUSH
80653: CALL_OW 72
80657: PUSH
80658: LD_EXP 88
80662: PUSH
80663: LD_VAR 0 2
80667: ARRAY
80668: UNION
80669: ST_TO_ADDR
// if not tmp then
80670: LD_VAR 0 4
80674: NOT
80675: IFFALSE 80679
// continue ;
80677: GO 80624
// for j in tmp do
80679: LD_ADDR_VAR 0 3
80683: PUSH
80684: LD_VAR 0 4
80688: PUSH
80689: FOR_IN
80690: IFFALSE 80842
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80692: LD_VAR 0 3
80696: PPUSH
80697: CALL_OW 110
80701: NOT
80702: PUSH
80703: LD_VAR 0 3
80707: PPUSH
80708: CALL_OW 314
80712: NOT
80713: AND
80714: PUSH
80715: LD_VAR 0 3
80719: PPUSH
80720: CALL_OW 311
80724: NOT
80725: AND
80726: PUSH
80727: LD_VAR 0 3
80731: PPUSH
80732: CALL_OW 310
80736: NOT
80737: AND
80738: PUSH
80739: LD_VAR 0 3
80743: PUSH
80744: LD_EXP 62
80748: PUSH
80749: LD_VAR 0 2
80753: ARRAY
80754: PUSH
80755: LD_INT 1
80757: ARRAY
80758: IN
80759: NOT
80760: AND
80761: PUSH
80762: LD_VAR 0 3
80766: PUSH
80767: LD_EXP 62
80771: PUSH
80772: LD_VAR 0 2
80776: ARRAY
80777: PUSH
80778: LD_INT 2
80780: ARRAY
80781: IN
80782: NOT
80783: AND
80784: PUSH
80785: LD_VAR 0 3
80789: PUSH
80790: LD_EXP 71
80794: PUSH
80795: LD_VAR 0 2
80799: ARRAY
80800: IN
80801: NOT
80802: AND
80803: IFFALSE 80840
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80805: LD_VAR 0 2
80809: PPUSH
80810: LD_EXP 59
80814: PUSH
80815: LD_VAR 0 2
80819: ARRAY
80820: PPUSH
80821: LD_VAR 0 3
80825: PPUSH
80826: LD_VAR 0 3
80830: PPUSH
80831: CALL_OW 257
80835: PPUSH
80836: CALL 79612 0 4
// end ;
80840: GO 80689
80842: POP
80843: POP
// end ;
80844: GO 80624
80846: POP
80847: POP
// end ;
80848: LD_VAR 0 1
80852: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
80853: LD_INT 0
80855: PPUSH
80856: PPUSH
80857: PPUSH
80858: PPUSH
80859: PPUSH
80860: PPUSH
// if not mc_bases [ base ] then
80861: LD_EXP 59
80865: PUSH
80866: LD_VAR 0 1
80870: ARRAY
80871: NOT
80872: IFFALSE 80876
// exit ;
80874: GO 81058
// tmp := [ ] ;
80876: LD_ADDR_VAR 0 6
80880: PUSH
80881: EMPTY
80882: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80883: LD_ADDR_VAR 0 7
80887: PUSH
80888: LD_VAR 0 3
80892: PPUSH
80893: LD_INT 0
80895: PPUSH
80896: CALL_OW 517
80900: ST_TO_ADDR
// if not list then
80901: LD_VAR 0 7
80905: NOT
80906: IFFALSE 80910
// exit ;
80908: GO 81058
// for i = 1 to amount do
80910: LD_ADDR_VAR 0 5
80914: PUSH
80915: DOUBLE
80916: LD_INT 1
80918: DEC
80919: ST_TO_ADDR
80920: LD_VAR 0 2
80924: PUSH
80925: FOR_TO
80926: IFFALSE 81006
// begin x := rand ( 1 , list [ 1 ] ) ;
80928: LD_ADDR_VAR 0 8
80932: PUSH
80933: LD_INT 1
80935: PPUSH
80936: LD_VAR 0 7
80940: PUSH
80941: LD_INT 1
80943: ARRAY
80944: PPUSH
80945: CALL_OW 12
80949: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
80950: LD_ADDR_VAR 0 6
80954: PUSH
80955: LD_VAR 0 6
80959: PPUSH
80960: LD_VAR 0 5
80964: PPUSH
80965: LD_VAR 0 7
80969: PUSH
80970: LD_INT 1
80972: ARRAY
80973: PUSH
80974: LD_VAR 0 8
80978: ARRAY
80979: PUSH
80980: LD_VAR 0 7
80984: PUSH
80985: LD_INT 2
80987: ARRAY
80988: PUSH
80989: LD_VAR 0 8
80993: ARRAY
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PPUSH
80999: CALL_OW 1
81003: ST_TO_ADDR
// end ;
81004: GO 80925
81006: POP
81007: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
81008: LD_ADDR_EXP 72
81012: PUSH
81013: LD_EXP 72
81017: PPUSH
81018: LD_VAR 0 1
81022: PPUSH
81023: LD_VAR 0 6
81027: PPUSH
81028: CALL_OW 1
81032: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
81033: LD_ADDR_EXP 74
81037: PUSH
81038: LD_EXP 74
81042: PPUSH
81043: LD_VAR 0 1
81047: PPUSH
81048: LD_VAR 0 3
81052: PPUSH
81053: CALL_OW 1
81057: ST_TO_ADDR
// end ;
81058: LD_VAR 0 4
81062: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
81063: LD_INT 0
81065: PPUSH
// if not mc_bases [ base ] then
81066: LD_EXP 59
81070: PUSH
81071: LD_VAR 0 1
81075: ARRAY
81076: NOT
81077: IFFALSE 81081
// exit ;
81079: GO 81106
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
81081: LD_ADDR_EXP 64
81085: PUSH
81086: LD_EXP 64
81090: PPUSH
81091: LD_VAR 0 1
81095: PPUSH
81096: LD_VAR 0 2
81100: PPUSH
81101: CALL_OW 1
81105: ST_TO_ADDR
// end ;
81106: LD_VAR 0 3
81110: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
81111: LD_INT 0
81113: PPUSH
// if not mc_bases [ base ] then
81114: LD_EXP 59
81118: PUSH
81119: LD_VAR 0 1
81123: ARRAY
81124: NOT
81125: IFFALSE 81129
// exit ;
81127: GO 81166
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
81129: LD_ADDR_EXP 64
81133: PUSH
81134: LD_EXP 64
81138: PPUSH
81139: LD_VAR 0 1
81143: PPUSH
81144: LD_EXP 64
81148: PUSH
81149: LD_VAR 0 1
81153: ARRAY
81154: PUSH
81155: LD_VAR 0 2
81159: UNION
81160: PPUSH
81161: CALL_OW 1
81165: ST_TO_ADDR
// end ;
81166: LD_VAR 0 3
81170: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
81171: LD_INT 0
81173: PPUSH
// if not mc_bases [ base ] then
81174: LD_EXP 59
81178: PUSH
81179: LD_VAR 0 1
81183: ARRAY
81184: NOT
81185: IFFALSE 81189
// exit ;
81187: GO 81214
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
81189: LD_ADDR_EXP 80
81193: PUSH
81194: LD_EXP 80
81198: PPUSH
81199: LD_VAR 0 1
81203: PPUSH
81204: LD_VAR 0 2
81208: PPUSH
81209: CALL_OW 1
81213: ST_TO_ADDR
// end ;
81214: LD_VAR 0 3
81218: RET
// export function MC_InsertProduceList ( base , components ) ; begin
81219: LD_INT 0
81221: PPUSH
// if not mc_bases [ base ] then
81222: LD_EXP 59
81226: PUSH
81227: LD_VAR 0 1
81231: ARRAY
81232: NOT
81233: IFFALSE 81237
// exit ;
81235: GO 81274
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
81237: LD_ADDR_EXP 80
81241: PUSH
81242: LD_EXP 80
81246: PPUSH
81247: LD_VAR 0 1
81251: PPUSH
81252: LD_EXP 80
81256: PUSH
81257: LD_VAR 0 1
81261: ARRAY
81262: PUSH
81263: LD_VAR 0 2
81267: ADD
81268: PPUSH
81269: CALL_OW 1
81273: ST_TO_ADDR
// end ;
81274: LD_VAR 0 3
81278: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
81279: LD_INT 0
81281: PPUSH
// if not mc_bases [ base ] then
81282: LD_EXP 59
81286: PUSH
81287: LD_VAR 0 1
81291: ARRAY
81292: NOT
81293: IFFALSE 81297
// exit ;
81295: GO 81351
// mc_defender := Replace ( mc_defender , base , deflist ) ;
81297: LD_ADDR_EXP 81
81301: PUSH
81302: LD_EXP 81
81306: PPUSH
81307: LD_VAR 0 1
81311: PPUSH
81312: LD_VAR 0 2
81316: PPUSH
81317: CALL_OW 1
81321: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
81322: LD_ADDR_EXP 70
81326: PUSH
81327: LD_EXP 70
81331: PPUSH
81332: LD_VAR 0 1
81336: PPUSH
81337: LD_VAR 0 2
81341: PUSH
81342: LD_INT 0
81344: PLUS
81345: PPUSH
81346: CALL_OW 1
81350: ST_TO_ADDR
// end ;
81351: LD_VAR 0 3
81355: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
81356: LD_INT 0
81358: PPUSH
// if not mc_bases [ base ] then
81359: LD_EXP 59
81363: PUSH
81364: LD_VAR 0 1
81368: ARRAY
81369: NOT
81370: IFFALSE 81374
// exit ;
81372: GO 81399
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
81374: LD_ADDR_EXP 70
81378: PUSH
81379: LD_EXP 70
81383: PPUSH
81384: LD_VAR 0 1
81388: PPUSH
81389: LD_VAR 0 2
81393: PPUSH
81394: CALL_OW 1
81398: ST_TO_ADDR
// end ;
81399: LD_VAR 0 3
81403: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
81404: LD_INT 0
81406: PPUSH
81407: PPUSH
81408: PPUSH
81409: PPUSH
// if not mc_bases [ base ] then
81410: LD_EXP 59
81414: PUSH
81415: LD_VAR 0 1
81419: ARRAY
81420: NOT
81421: IFFALSE 81425
// exit ;
81423: GO 81490
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
81425: LD_ADDR_EXP 79
81429: PUSH
81430: LD_EXP 79
81434: PPUSH
81435: LD_VAR 0 1
81439: PUSH
81440: LD_EXP 79
81444: PUSH
81445: LD_VAR 0 1
81449: ARRAY
81450: PUSH
81451: LD_INT 1
81453: PLUS
81454: PUSH
81455: EMPTY
81456: LIST
81457: LIST
81458: PPUSH
81459: LD_VAR 0 1
81463: PUSH
81464: LD_VAR 0 2
81468: PUSH
81469: LD_VAR 0 3
81473: PUSH
81474: LD_VAR 0 4
81478: PUSH
81479: EMPTY
81480: LIST
81481: LIST
81482: LIST
81483: LIST
81484: PPUSH
81485: CALL 21589 0 3
81489: ST_TO_ADDR
// end ;
81490: LD_VAR 0 5
81494: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
81495: LD_INT 0
81497: PPUSH
// if not mc_bases [ base ] then
81498: LD_EXP 59
81502: PUSH
81503: LD_VAR 0 1
81507: ARRAY
81508: NOT
81509: IFFALSE 81513
// exit ;
81511: GO 81538
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
81513: LD_ADDR_EXP 96
81517: PUSH
81518: LD_EXP 96
81522: PPUSH
81523: LD_VAR 0 1
81527: PPUSH
81528: LD_VAR 0 2
81532: PPUSH
81533: CALL_OW 1
81537: ST_TO_ADDR
// end ;
81538: LD_VAR 0 3
81542: RET
// export function MC_GetMinesField ( base ) ; begin
81543: LD_INT 0
81545: PPUSH
// result := mc_mines [ base ] ;
81546: LD_ADDR_VAR 0 2
81550: PUSH
81551: LD_EXP 72
81555: PUSH
81556: LD_VAR 0 1
81560: ARRAY
81561: ST_TO_ADDR
// end ;
81562: LD_VAR 0 2
81566: RET
// export function MC_GetProduceList ( base ) ; begin
81567: LD_INT 0
81569: PPUSH
// result := mc_produce [ base ] ;
81570: LD_ADDR_VAR 0 2
81574: PUSH
81575: LD_EXP 80
81579: PUSH
81580: LD_VAR 0 1
81584: ARRAY
81585: ST_TO_ADDR
// end ;
81586: LD_VAR 0 2
81590: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
81591: LD_INT 0
81593: PPUSH
81594: PPUSH
// if not mc_bases then
81595: LD_EXP 59
81599: NOT
81600: IFFALSE 81604
// exit ;
81602: GO 81669
// if mc_bases [ base ] then
81604: LD_EXP 59
81608: PUSH
81609: LD_VAR 0 1
81613: ARRAY
81614: IFFALSE 81669
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81616: LD_ADDR_VAR 0 3
81620: PUSH
81621: LD_EXP 59
81625: PUSH
81626: LD_VAR 0 1
81630: ARRAY
81631: PPUSH
81632: LD_INT 30
81634: PUSH
81635: LD_VAR 0 2
81639: PUSH
81640: EMPTY
81641: LIST
81642: LIST
81643: PPUSH
81644: CALL_OW 72
81648: ST_TO_ADDR
// if result then
81649: LD_VAR 0 3
81653: IFFALSE 81669
// result := result [ 1 ] ;
81655: LD_ADDR_VAR 0 3
81659: PUSH
81660: LD_VAR 0 3
81664: PUSH
81665: LD_INT 1
81667: ARRAY
81668: ST_TO_ADDR
// end ; end ;
81669: LD_VAR 0 3
81673: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81674: LD_INT 0
81676: PPUSH
81677: PPUSH
// if not mc_bases then
81678: LD_EXP 59
81682: NOT
81683: IFFALSE 81687
// exit ;
81685: GO 81732
// if mc_bases [ base ] then
81687: LD_EXP 59
81691: PUSH
81692: LD_VAR 0 1
81696: ARRAY
81697: IFFALSE 81732
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81699: LD_ADDR_VAR 0 3
81703: PUSH
81704: LD_EXP 59
81708: PUSH
81709: LD_VAR 0 1
81713: ARRAY
81714: PPUSH
81715: LD_INT 30
81717: PUSH
81718: LD_VAR 0 2
81722: PUSH
81723: EMPTY
81724: LIST
81725: LIST
81726: PPUSH
81727: CALL_OW 72
81731: ST_TO_ADDR
// end ;
81732: LD_VAR 0 3
81736: RET
// export function MC_SetTame ( base , area ) ; begin
81737: LD_INT 0
81739: PPUSH
// if not mc_bases or not base then
81740: LD_EXP 59
81744: NOT
81745: PUSH
81746: LD_VAR 0 1
81750: NOT
81751: OR
81752: IFFALSE 81756
// exit ;
81754: GO 81781
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81756: LD_ADDR_EXP 87
81760: PUSH
81761: LD_EXP 87
81765: PPUSH
81766: LD_VAR 0 1
81770: PPUSH
81771: LD_VAR 0 2
81775: PPUSH
81776: CALL_OW 1
81780: ST_TO_ADDR
// end ;
81781: LD_VAR 0 3
81785: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81786: LD_INT 0
81788: PPUSH
81789: PPUSH
// if not mc_bases or not base then
81790: LD_EXP 59
81794: NOT
81795: PUSH
81796: LD_VAR 0 1
81800: NOT
81801: OR
81802: IFFALSE 81806
// exit ;
81804: GO 81908
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81806: LD_ADDR_VAR 0 4
81810: PUSH
81811: LD_EXP 59
81815: PUSH
81816: LD_VAR 0 1
81820: ARRAY
81821: PPUSH
81822: LD_INT 30
81824: PUSH
81825: LD_VAR 0 2
81829: PUSH
81830: EMPTY
81831: LIST
81832: LIST
81833: PPUSH
81834: CALL_OW 72
81838: ST_TO_ADDR
// if not tmp then
81839: LD_VAR 0 4
81843: NOT
81844: IFFALSE 81848
// exit ;
81846: GO 81908
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81848: LD_ADDR_EXP 91
81852: PUSH
81853: LD_EXP 91
81857: PPUSH
81858: LD_VAR 0 1
81862: PPUSH
81863: LD_EXP 91
81867: PUSH
81868: LD_VAR 0 1
81872: ARRAY
81873: PPUSH
81874: LD_EXP 91
81878: PUSH
81879: LD_VAR 0 1
81883: ARRAY
81884: PUSH
81885: LD_INT 1
81887: PLUS
81888: PPUSH
81889: LD_VAR 0 4
81893: PUSH
81894: LD_INT 1
81896: ARRAY
81897: PPUSH
81898: CALL_OW 2
81902: PPUSH
81903: CALL_OW 1
81907: ST_TO_ADDR
// end ;
81908: LD_VAR 0 3
81912: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81913: LD_INT 0
81915: PPUSH
81916: PPUSH
// if not mc_bases or not base or not kinds then
81917: LD_EXP 59
81921: NOT
81922: PUSH
81923: LD_VAR 0 1
81927: NOT
81928: OR
81929: PUSH
81930: LD_VAR 0 2
81934: NOT
81935: OR
81936: IFFALSE 81940
// exit ;
81938: GO 82001
// for i in kinds do
81940: LD_ADDR_VAR 0 4
81944: PUSH
81945: LD_VAR 0 2
81949: PUSH
81950: FOR_IN
81951: IFFALSE 81999
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81953: LD_ADDR_EXP 93
81957: PUSH
81958: LD_EXP 93
81962: PPUSH
81963: LD_VAR 0 1
81967: PUSH
81968: LD_EXP 93
81972: PUSH
81973: LD_VAR 0 1
81977: ARRAY
81978: PUSH
81979: LD_INT 1
81981: PLUS
81982: PUSH
81983: EMPTY
81984: LIST
81985: LIST
81986: PPUSH
81987: LD_VAR 0 4
81991: PPUSH
81992: CALL 21589 0 3
81996: ST_TO_ADDR
81997: GO 81950
81999: POP
82000: POP
// end ;
82001: LD_VAR 0 3
82005: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
82006: LD_INT 0
82008: PPUSH
// if not mc_bases or not base or not areas then
82009: LD_EXP 59
82013: NOT
82014: PUSH
82015: LD_VAR 0 1
82019: NOT
82020: OR
82021: PUSH
82022: LD_VAR 0 2
82026: NOT
82027: OR
82028: IFFALSE 82032
// exit ;
82030: GO 82057
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
82032: LD_ADDR_EXP 77
82036: PUSH
82037: LD_EXP 77
82041: PPUSH
82042: LD_VAR 0 1
82046: PPUSH
82047: LD_VAR 0 2
82051: PPUSH
82052: CALL_OW 1
82056: ST_TO_ADDR
// end ;
82057: LD_VAR 0 3
82061: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
82062: LD_INT 0
82064: PPUSH
// if not mc_bases or not base or not teleports_exit then
82065: LD_EXP 59
82069: NOT
82070: PUSH
82071: LD_VAR 0 1
82075: NOT
82076: OR
82077: PUSH
82078: LD_VAR 0 2
82082: NOT
82083: OR
82084: IFFALSE 82088
// exit ;
82086: GO 82113
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
82088: LD_ADDR_EXP 94
82092: PUSH
82093: LD_EXP 94
82097: PPUSH
82098: LD_VAR 0 1
82102: PPUSH
82103: LD_VAR 0 2
82107: PPUSH
82108: CALL_OW 1
82112: ST_TO_ADDR
// end ;
82113: LD_VAR 0 3
82117: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
82118: LD_INT 0
82120: PPUSH
82121: PPUSH
82122: PPUSH
// if not mc_bases or not base or not ext_list then
82123: LD_EXP 59
82127: NOT
82128: PUSH
82129: LD_VAR 0 1
82133: NOT
82134: OR
82135: PUSH
82136: LD_VAR 0 5
82140: NOT
82141: OR
82142: IFFALSE 82146
// exit ;
82144: GO 82319
// tmp := GetFacExtXYD ( x , y , d ) ;
82146: LD_ADDR_VAR 0 8
82150: PUSH
82151: LD_VAR 0 2
82155: PPUSH
82156: LD_VAR 0 3
82160: PPUSH
82161: LD_VAR 0 4
82165: PPUSH
82166: CALL 54977 0 3
82170: ST_TO_ADDR
// if not tmp then
82171: LD_VAR 0 8
82175: NOT
82176: IFFALSE 82180
// exit ;
82178: GO 82319
// for i in tmp do
82180: LD_ADDR_VAR 0 7
82184: PUSH
82185: LD_VAR 0 8
82189: PUSH
82190: FOR_IN
82191: IFFALSE 82317
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
82193: LD_ADDR_EXP 64
82197: PUSH
82198: LD_EXP 64
82202: PPUSH
82203: LD_VAR 0 1
82207: PPUSH
82208: LD_EXP 64
82212: PUSH
82213: LD_VAR 0 1
82217: ARRAY
82218: PPUSH
82219: LD_EXP 64
82223: PUSH
82224: LD_VAR 0 1
82228: ARRAY
82229: PUSH
82230: LD_INT 1
82232: PLUS
82233: PPUSH
82234: LD_VAR 0 5
82238: PUSH
82239: LD_INT 1
82241: ARRAY
82242: PUSH
82243: LD_VAR 0 7
82247: PUSH
82248: LD_INT 1
82250: ARRAY
82251: PUSH
82252: LD_VAR 0 7
82256: PUSH
82257: LD_INT 2
82259: ARRAY
82260: PUSH
82261: LD_VAR 0 7
82265: PUSH
82266: LD_INT 3
82268: ARRAY
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: LIST
82274: LIST
82275: PPUSH
82276: CALL_OW 2
82280: PPUSH
82281: CALL_OW 1
82285: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
82286: LD_ADDR_VAR 0 5
82290: PUSH
82291: LD_VAR 0 5
82295: PPUSH
82296: LD_INT 1
82298: PPUSH
82299: CALL_OW 3
82303: ST_TO_ADDR
// if not ext_list then
82304: LD_VAR 0 5
82308: NOT
82309: IFFALSE 82315
// exit ;
82311: POP
82312: POP
82313: GO 82319
// end ;
82315: GO 82190
82317: POP
82318: POP
// end ;
82319: LD_VAR 0 6
82323: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
82324: LD_INT 0
82326: PPUSH
// if not mc_bases or not base or not weapon_list then
82327: LD_EXP 59
82331: NOT
82332: PUSH
82333: LD_VAR 0 1
82337: NOT
82338: OR
82339: PUSH
82340: LD_VAR 0 2
82344: NOT
82345: OR
82346: IFFALSE 82350
// exit ;
82348: GO 82375
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
82350: LD_ADDR_EXP 98
82354: PUSH
82355: LD_EXP 98
82359: PPUSH
82360: LD_VAR 0 1
82364: PPUSH
82365: LD_VAR 0 2
82369: PPUSH
82370: CALL_OW 1
82374: ST_TO_ADDR
// end ;
82375: LD_VAR 0 3
82379: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
82380: LD_INT 0
82382: PPUSH
// if not mc_bases or not base or not tech_list then
82383: LD_EXP 59
82387: NOT
82388: PUSH
82389: LD_VAR 0 1
82393: NOT
82394: OR
82395: PUSH
82396: LD_VAR 0 2
82400: NOT
82401: OR
82402: IFFALSE 82406
// exit ;
82404: GO 82431
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
82406: LD_ADDR_EXP 86
82410: PUSH
82411: LD_EXP 86
82415: PPUSH
82416: LD_VAR 0 1
82420: PPUSH
82421: LD_VAR 0 2
82425: PPUSH
82426: CALL_OW 1
82430: ST_TO_ADDR
// end ;
82431: LD_VAR 0 3
82435: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
82436: LD_INT 0
82438: PPUSH
// if not mc_bases or not parking_area or not base then
82439: LD_EXP 59
82443: NOT
82444: PUSH
82445: LD_VAR 0 2
82449: NOT
82450: OR
82451: PUSH
82452: LD_VAR 0 1
82456: NOT
82457: OR
82458: IFFALSE 82462
// exit ;
82460: GO 82487
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
82462: LD_ADDR_EXP 83
82466: PUSH
82467: LD_EXP 83
82471: PPUSH
82472: LD_VAR 0 1
82476: PPUSH
82477: LD_VAR 0 2
82481: PPUSH
82482: CALL_OW 1
82486: ST_TO_ADDR
// end ;
82487: LD_VAR 0 3
82491: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
82492: LD_INT 0
82494: PPUSH
// if not mc_bases or not base or not scan_area then
82495: LD_EXP 59
82499: NOT
82500: PUSH
82501: LD_VAR 0 1
82505: NOT
82506: OR
82507: PUSH
82508: LD_VAR 0 2
82512: NOT
82513: OR
82514: IFFALSE 82518
// exit ;
82516: GO 82543
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
82518: LD_ADDR_EXP 84
82522: PUSH
82523: LD_EXP 84
82527: PPUSH
82528: LD_VAR 0 1
82532: PPUSH
82533: LD_VAR 0 2
82537: PPUSH
82538: CALL_OW 1
82542: ST_TO_ADDR
// end ;
82543: LD_VAR 0 3
82547: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
82548: LD_INT 0
82550: PPUSH
82551: PPUSH
// if not mc_bases or not base then
82552: LD_EXP 59
82556: NOT
82557: PUSH
82558: LD_VAR 0 1
82562: NOT
82563: OR
82564: IFFALSE 82568
// exit ;
82566: GO 82632
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
82568: LD_ADDR_VAR 0 3
82572: PUSH
82573: LD_INT 1
82575: PUSH
82576: LD_INT 2
82578: PUSH
82579: LD_INT 3
82581: PUSH
82582: LD_INT 4
82584: PUSH
82585: LD_INT 11
82587: PUSH
82588: EMPTY
82589: LIST
82590: LIST
82591: LIST
82592: LIST
82593: LIST
82594: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
82595: LD_ADDR_EXP 86
82599: PUSH
82600: LD_EXP 86
82604: PPUSH
82605: LD_VAR 0 1
82609: PPUSH
82610: LD_EXP 86
82614: PUSH
82615: LD_VAR 0 1
82619: ARRAY
82620: PUSH
82621: LD_VAR 0 3
82625: DIFF
82626: PPUSH
82627: CALL_OW 1
82631: ST_TO_ADDR
// end ;
82632: LD_VAR 0 2
82636: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82637: LD_INT 0
82639: PPUSH
// result := mc_vehicles [ base ] ;
82640: LD_ADDR_VAR 0 3
82644: PUSH
82645: LD_EXP 78
82649: PUSH
82650: LD_VAR 0 1
82654: ARRAY
82655: ST_TO_ADDR
// if onlyCombat then
82656: LD_VAR 0 2
82660: IFFALSE 82825
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82662: LD_ADDR_VAR 0 3
82666: PUSH
82667: LD_VAR 0 3
82671: PUSH
82672: LD_VAR 0 3
82676: PPUSH
82677: LD_INT 2
82679: PUSH
82680: LD_INT 34
82682: PUSH
82683: LD_INT 12
82685: PUSH
82686: EMPTY
82687: LIST
82688: LIST
82689: PUSH
82690: LD_INT 34
82692: PUSH
82693: LD_INT 51
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: PUSH
82700: LD_INT 34
82702: PUSH
82703: LD_EXP 103
82707: PUSH
82708: EMPTY
82709: LIST
82710: LIST
82711: PUSH
82712: LD_INT 34
82714: PUSH
82715: LD_INT 32
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 34
82724: PUSH
82725: LD_INT 13
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PUSH
82732: LD_INT 34
82734: PUSH
82735: LD_INT 52
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 34
82744: PUSH
82745: LD_INT 14
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: LD_INT 34
82754: PUSH
82755: LD_INT 53
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 34
82764: PUSH
82765: LD_EXP 102
82769: PUSH
82770: EMPTY
82771: LIST
82772: LIST
82773: PUSH
82774: LD_INT 34
82776: PUSH
82777: LD_INT 31
82779: PUSH
82780: EMPTY
82781: LIST
82782: LIST
82783: PUSH
82784: LD_INT 34
82786: PUSH
82787: LD_INT 48
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: PUSH
82794: LD_INT 34
82796: PUSH
82797: LD_INT 8
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: LIST
82810: LIST
82811: LIST
82812: LIST
82813: LIST
82814: LIST
82815: LIST
82816: LIST
82817: LIST
82818: PPUSH
82819: CALL_OW 72
82823: DIFF
82824: ST_TO_ADDR
// end ; end_of_file
82825: LD_VAR 0 3
82829: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82830: LD_INT 0
82832: PPUSH
82833: PPUSH
82834: PPUSH
// if not mc_bases or not skirmish then
82835: LD_EXP 59
82839: NOT
82840: PUSH
82841: LD_EXP 57
82845: NOT
82846: OR
82847: IFFALSE 82851
// exit ;
82849: GO 83016
// for i = 1 to mc_bases do
82851: LD_ADDR_VAR 0 4
82855: PUSH
82856: DOUBLE
82857: LD_INT 1
82859: DEC
82860: ST_TO_ADDR
82861: LD_EXP 59
82865: PUSH
82866: FOR_TO
82867: IFFALSE 83014
// begin if sci in mc_bases [ i ] then
82869: LD_VAR 0 2
82873: PUSH
82874: LD_EXP 59
82878: PUSH
82879: LD_VAR 0 4
82883: ARRAY
82884: IN
82885: IFFALSE 83012
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82887: LD_ADDR_EXP 88
82891: PUSH
82892: LD_EXP 88
82896: PPUSH
82897: LD_VAR 0 4
82901: PUSH
82902: LD_EXP 88
82906: PUSH
82907: LD_VAR 0 4
82911: ARRAY
82912: PUSH
82913: LD_INT 1
82915: PLUS
82916: PUSH
82917: EMPTY
82918: LIST
82919: LIST
82920: PPUSH
82921: LD_VAR 0 1
82925: PPUSH
82926: CALL 21589 0 3
82930: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82931: LD_ADDR_VAR 0 5
82935: PUSH
82936: LD_EXP 59
82940: PUSH
82941: LD_VAR 0 4
82945: ARRAY
82946: PPUSH
82947: LD_INT 2
82949: PUSH
82950: LD_INT 30
82952: PUSH
82953: LD_INT 0
82955: PUSH
82956: EMPTY
82957: LIST
82958: LIST
82959: PUSH
82960: LD_INT 30
82962: PUSH
82963: LD_INT 1
82965: PUSH
82966: EMPTY
82967: LIST
82968: LIST
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: LIST
82974: PPUSH
82975: CALL_OW 72
82979: PPUSH
82980: LD_VAR 0 1
82984: PPUSH
82985: CALL_OW 74
82989: ST_TO_ADDR
// if tmp then
82990: LD_VAR 0 5
82994: IFFALSE 83010
// ComStandNearbyBuilding ( ape , tmp ) ;
82996: LD_VAR 0 1
83000: PPUSH
83001: LD_VAR 0 5
83005: PPUSH
83006: CALL 15792 0 2
// break ;
83010: GO 83014
// end ; end ;
83012: GO 82866
83014: POP
83015: POP
// end ;
83016: LD_VAR 0 3
83020: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
83021: LD_INT 0
83023: PPUSH
83024: PPUSH
83025: PPUSH
// if not mc_bases or not skirmish then
83026: LD_EXP 59
83030: NOT
83031: PUSH
83032: LD_EXP 57
83036: NOT
83037: OR
83038: IFFALSE 83042
// exit ;
83040: GO 83131
// for i = 1 to mc_bases do
83042: LD_ADDR_VAR 0 4
83046: PUSH
83047: DOUBLE
83048: LD_INT 1
83050: DEC
83051: ST_TO_ADDR
83052: LD_EXP 59
83056: PUSH
83057: FOR_TO
83058: IFFALSE 83129
// begin if building in mc_busy_turret_list [ i ] then
83060: LD_VAR 0 1
83064: PUSH
83065: LD_EXP 69
83069: PUSH
83070: LD_VAR 0 4
83074: ARRAY
83075: IN
83076: IFFALSE 83127
// begin tmp := mc_busy_turret_list [ i ] diff building ;
83078: LD_ADDR_VAR 0 5
83082: PUSH
83083: LD_EXP 69
83087: PUSH
83088: LD_VAR 0 4
83092: ARRAY
83093: PUSH
83094: LD_VAR 0 1
83098: DIFF
83099: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
83100: LD_ADDR_EXP 69
83104: PUSH
83105: LD_EXP 69
83109: PPUSH
83110: LD_VAR 0 4
83114: PPUSH
83115: LD_VAR 0 5
83119: PPUSH
83120: CALL_OW 1
83124: ST_TO_ADDR
// break ;
83125: GO 83129
// end ; end ;
83127: GO 83057
83129: POP
83130: POP
// end ;
83131: LD_VAR 0 3
83135: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
83136: LD_INT 0
83138: PPUSH
83139: PPUSH
83140: PPUSH
// if not mc_bases or not skirmish then
83141: LD_EXP 59
83145: NOT
83146: PUSH
83147: LD_EXP 57
83151: NOT
83152: OR
83153: IFFALSE 83157
// exit ;
83155: GO 83356
// for i = 1 to mc_bases do
83157: LD_ADDR_VAR 0 5
83161: PUSH
83162: DOUBLE
83163: LD_INT 1
83165: DEC
83166: ST_TO_ADDR
83167: LD_EXP 59
83171: PUSH
83172: FOR_TO
83173: IFFALSE 83354
// if building in mc_bases [ i ] then
83175: LD_VAR 0 1
83179: PUSH
83180: LD_EXP 59
83184: PUSH
83185: LD_VAR 0 5
83189: ARRAY
83190: IN
83191: IFFALSE 83352
// begin tmp := mc_bases [ i ] diff building ;
83193: LD_ADDR_VAR 0 6
83197: PUSH
83198: LD_EXP 59
83202: PUSH
83203: LD_VAR 0 5
83207: ARRAY
83208: PUSH
83209: LD_VAR 0 1
83213: DIFF
83214: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
83215: LD_ADDR_EXP 59
83219: PUSH
83220: LD_EXP 59
83224: PPUSH
83225: LD_VAR 0 5
83229: PPUSH
83230: LD_VAR 0 6
83234: PPUSH
83235: CALL_OW 1
83239: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
83240: LD_VAR 0 1
83244: PUSH
83245: LD_EXP 67
83249: PUSH
83250: LD_VAR 0 5
83254: ARRAY
83255: IN
83256: IFFALSE 83295
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
83258: LD_ADDR_EXP 67
83262: PUSH
83263: LD_EXP 67
83267: PPUSH
83268: LD_VAR 0 5
83272: PPUSH
83273: LD_EXP 67
83277: PUSH
83278: LD_VAR 0 5
83282: ARRAY
83283: PUSH
83284: LD_VAR 0 1
83288: DIFF
83289: PPUSH
83290: CALL_OW 1
83294: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
83295: LD_VAR 0 1
83299: PUSH
83300: LD_EXP 68
83304: PUSH
83305: LD_VAR 0 5
83309: ARRAY
83310: IN
83311: IFFALSE 83350
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
83313: LD_ADDR_EXP 68
83317: PUSH
83318: LD_EXP 68
83322: PPUSH
83323: LD_VAR 0 5
83327: PPUSH
83328: LD_EXP 68
83332: PUSH
83333: LD_VAR 0 5
83337: ARRAY
83338: PUSH
83339: LD_VAR 0 1
83343: DIFF
83344: PPUSH
83345: CALL_OW 1
83349: ST_TO_ADDR
// break ;
83350: GO 83354
// end ;
83352: GO 83172
83354: POP
83355: POP
// end ;
83356: LD_VAR 0 4
83360: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
83361: LD_INT 0
83363: PPUSH
83364: PPUSH
83365: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
83366: LD_EXP 59
83370: NOT
83371: PUSH
83372: LD_EXP 57
83376: NOT
83377: OR
83378: PUSH
83379: LD_VAR 0 3
83383: PUSH
83384: LD_EXP 85
83388: IN
83389: NOT
83390: OR
83391: IFFALSE 83395
// exit ;
83393: GO 83518
// for i = 1 to mc_vehicles do
83395: LD_ADDR_VAR 0 6
83399: PUSH
83400: DOUBLE
83401: LD_INT 1
83403: DEC
83404: ST_TO_ADDR
83405: LD_EXP 78
83409: PUSH
83410: FOR_TO
83411: IFFALSE 83516
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
83413: LD_VAR 0 2
83417: PUSH
83418: LD_EXP 78
83422: PUSH
83423: LD_VAR 0 6
83427: ARRAY
83428: IN
83429: PUSH
83430: LD_VAR 0 1
83434: PUSH
83435: LD_EXP 78
83439: PUSH
83440: LD_VAR 0 6
83444: ARRAY
83445: IN
83446: OR
83447: IFFALSE 83514
// begin tmp := mc_vehicles [ i ] diff old ;
83449: LD_ADDR_VAR 0 7
83453: PUSH
83454: LD_EXP 78
83458: PUSH
83459: LD_VAR 0 6
83463: ARRAY
83464: PUSH
83465: LD_VAR 0 2
83469: DIFF
83470: ST_TO_ADDR
// tmp := tmp diff new ;
83471: LD_ADDR_VAR 0 7
83475: PUSH
83476: LD_VAR 0 7
83480: PUSH
83481: LD_VAR 0 1
83485: DIFF
83486: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
83487: LD_ADDR_EXP 78
83491: PUSH
83492: LD_EXP 78
83496: PPUSH
83497: LD_VAR 0 6
83501: PPUSH
83502: LD_VAR 0 7
83506: PPUSH
83507: CALL_OW 1
83511: ST_TO_ADDR
// break ;
83512: GO 83516
// end ;
83514: GO 83410
83516: POP
83517: POP
// end ;
83518: LD_VAR 0 5
83522: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
83523: LD_INT 0
83525: PPUSH
83526: PPUSH
83527: PPUSH
83528: PPUSH
// if not mc_bases or not skirmish then
83529: LD_EXP 59
83533: NOT
83534: PUSH
83535: LD_EXP 57
83539: NOT
83540: OR
83541: IFFALSE 83545
// exit ;
83543: GO 83922
// side := GetSide ( vehicle ) ;
83545: LD_ADDR_VAR 0 5
83549: PUSH
83550: LD_VAR 0 1
83554: PPUSH
83555: CALL_OW 255
83559: ST_TO_ADDR
// for i = 1 to mc_bases do
83560: LD_ADDR_VAR 0 4
83564: PUSH
83565: DOUBLE
83566: LD_INT 1
83568: DEC
83569: ST_TO_ADDR
83570: LD_EXP 59
83574: PUSH
83575: FOR_TO
83576: IFFALSE 83920
// begin if factory in mc_bases [ i ] then
83578: LD_VAR 0 2
83582: PUSH
83583: LD_EXP 59
83587: PUSH
83588: LD_VAR 0 4
83592: ARRAY
83593: IN
83594: IFFALSE 83918
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
83596: LD_EXP 81
83600: PUSH
83601: LD_VAR 0 4
83605: ARRAY
83606: PUSH
83607: LD_EXP 70
83611: PUSH
83612: LD_VAR 0 4
83616: ARRAY
83617: LESS
83618: PUSH
83619: LD_VAR 0 1
83623: PPUSH
83624: CALL_OW 264
83628: PUSH
83629: LD_INT 31
83631: PUSH
83632: LD_INT 32
83634: PUSH
83635: LD_INT 51
83637: PUSH
83638: LD_EXP 103
83642: PUSH
83643: LD_INT 12
83645: PUSH
83646: LD_INT 30
83648: PUSH
83649: LD_EXP 102
83653: PUSH
83654: LD_INT 11
83656: PUSH
83657: LD_INT 53
83659: PUSH
83660: LD_INT 14
83662: PUSH
83663: LD_EXP 106
83667: PUSH
83668: LD_INT 29
83670: PUSH
83671: LD_EXP 104
83675: PUSH
83676: LD_INT 13
83678: PUSH
83679: LD_INT 52
83681: PUSH
83682: LD_INT 48
83684: PUSH
83685: LD_INT 8
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: LIST
83692: LIST
83693: LIST
83694: LIST
83695: LIST
83696: LIST
83697: LIST
83698: LIST
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: LIST
83705: LIST
83706: IN
83707: NOT
83708: AND
83709: IFFALSE 83757
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83711: LD_ADDR_EXP 81
83715: PUSH
83716: LD_EXP 81
83720: PPUSH
83721: LD_VAR 0 4
83725: PUSH
83726: LD_EXP 81
83730: PUSH
83731: LD_VAR 0 4
83735: ARRAY
83736: PUSH
83737: LD_INT 1
83739: PLUS
83740: PUSH
83741: EMPTY
83742: LIST
83743: LIST
83744: PPUSH
83745: LD_VAR 0 1
83749: PPUSH
83750: CALL 21589 0 3
83754: ST_TO_ADDR
83755: GO 83801
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83757: LD_ADDR_EXP 78
83761: PUSH
83762: LD_EXP 78
83766: PPUSH
83767: LD_VAR 0 4
83771: PUSH
83772: LD_EXP 78
83776: PUSH
83777: LD_VAR 0 4
83781: ARRAY
83782: PUSH
83783: LD_INT 1
83785: PLUS
83786: PUSH
83787: EMPTY
83788: LIST
83789: LIST
83790: PPUSH
83791: LD_VAR 0 1
83795: PPUSH
83796: CALL 21589 0 3
83800: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83801: LD_VAR 0 1
83805: PPUSH
83806: CALL_OW 263
83810: PUSH
83811: LD_INT 2
83813: EQUAL
83814: IFFALSE 83834
// begin repeat wait ( 0 0$1 ) ;
83816: LD_INT 35
83818: PPUSH
83819: CALL_OW 67
// until IsControledBy ( vehicle ) ;
83823: LD_VAR 0 1
83827: PPUSH
83828: CALL_OW 312
83832: IFFALSE 83816
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83834: LD_VAR 0 1
83838: PPUSH
83839: LD_EXP 83
83843: PUSH
83844: LD_VAR 0 4
83848: ARRAY
83849: PPUSH
83850: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83854: LD_VAR 0 1
83858: PPUSH
83859: CALL_OW 263
83863: PUSH
83864: LD_INT 1
83866: NONEQUAL
83867: IFFALSE 83871
// break ;
83869: GO 83920
// repeat wait ( 0 0$1 ) ;
83871: LD_INT 35
83873: PPUSH
83874: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83878: LD_VAR 0 1
83882: PPUSH
83883: LD_EXP 83
83887: PUSH
83888: LD_VAR 0 4
83892: ARRAY
83893: PPUSH
83894: CALL_OW 308
83898: IFFALSE 83871
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83900: LD_VAR 0 1
83904: PPUSH
83905: CALL_OW 311
83909: PPUSH
83910: CALL_OW 121
// exit ;
83914: POP
83915: POP
83916: GO 83922
// end ; end ;
83918: GO 83575
83920: POP
83921: POP
// end ;
83922: LD_VAR 0 3
83926: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83927: LD_INT 0
83929: PPUSH
83930: PPUSH
83931: PPUSH
83932: PPUSH
// if not mc_bases or not skirmish then
83933: LD_EXP 59
83937: NOT
83938: PUSH
83939: LD_EXP 57
83943: NOT
83944: OR
83945: IFFALSE 83949
// exit ;
83947: GO 84302
// repeat wait ( 0 0$1 ) ;
83949: LD_INT 35
83951: PPUSH
83952: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83956: LD_VAR 0 2
83960: PPUSH
83961: LD_VAR 0 3
83965: PPUSH
83966: CALL_OW 284
83970: IFFALSE 83949
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83972: LD_VAR 0 2
83976: PPUSH
83977: LD_VAR 0 3
83981: PPUSH
83982: CALL_OW 283
83986: PUSH
83987: LD_INT 4
83989: EQUAL
83990: IFFALSE 83994
// exit ;
83992: GO 84302
// for i = 1 to mc_bases do
83994: LD_ADDR_VAR 0 7
83998: PUSH
83999: DOUBLE
84000: LD_INT 1
84002: DEC
84003: ST_TO_ADDR
84004: LD_EXP 59
84008: PUSH
84009: FOR_TO
84010: IFFALSE 84300
// begin if mc_crates_area [ i ] then
84012: LD_EXP 77
84016: PUSH
84017: LD_VAR 0 7
84021: ARRAY
84022: IFFALSE 84133
// for j in mc_crates_area [ i ] do
84024: LD_ADDR_VAR 0 8
84028: PUSH
84029: LD_EXP 77
84033: PUSH
84034: LD_VAR 0 7
84038: ARRAY
84039: PUSH
84040: FOR_IN
84041: IFFALSE 84131
// if InArea ( x , y , j ) then
84043: LD_VAR 0 2
84047: PPUSH
84048: LD_VAR 0 3
84052: PPUSH
84053: LD_VAR 0 8
84057: PPUSH
84058: CALL_OW 309
84062: IFFALSE 84129
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84064: LD_ADDR_EXP 75
84068: PUSH
84069: LD_EXP 75
84073: PPUSH
84074: LD_VAR 0 7
84078: PUSH
84079: LD_EXP 75
84083: PUSH
84084: LD_VAR 0 7
84088: ARRAY
84089: PUSH
84090: LD_INT 1
84092: PLUS
84093: PUSH
84094: EMPTY
84095: LIST
84096: LIST
84097: PPUSH
84098: LD_VAR 0 4
84102: PUSH
84103: LD_VAR 0 2
84107: PUSH
84108: LD_VAR 0 3
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: LIST
84117: PPUSH
84118: CALL 21589 0 3
84122: ST_TO_ADDR
// exit ;
84123: POP
84124: POP
84125: POP
84126: POP
84127: GO 84302
// end ;
84129: GO 84040
84131: POP
84132: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84133: LD_ADDR_VAR 0 9
84137: PUSH
84138: LD_EXP 59
84142: PUSH
84143: LD_VAR 0 7
84147: ARRAY
84148: PPUSH
84149: LD_INT 2
84151: PUSH
84152: LD_INT 30
84154: PUSH
84155: LD_INT 0
84157: PUSH
84158: EMPTY
84159: LIST
84160: LIST
84161: PUSH
84162: LD_INT 30
84164: PUSH
84165: LD_INT 1
84167: PUSH
84168: EMPTY
84169: LIST
84170: LIST
84171: PUSH
84172: EMPTY
84173: LIST
84174: LIST
84175: LIST
84176: PPUSH
84177: CALL_OW 72
84181: ST_TO_ADDR
// if not depot then
84182: LD_VAR 0 9
84186: NOT
84187: IFFALSE 84191
// continue ;
84189: GO 84009
// for j in depot do
84191: LD_ADDR_VAR 0 8
84195: PUSH
84196: LD_VAR 0 9
84200: PUSH
84201: FOR_IN
84202: IFFALSE 84296
// if GetDistUnitXY ( j , x , y ) < 30 then
84204: LD_VAR 0 8
84208: PPUSH
84209: LD_VAR 0 2
84213: PPUSH
84214: LD_VAR 0 3
84218: PPUSH
84219: CALL_OW 297
84223: PUSH
84224: LD_INT 30
84226: LESS
84227: IFFALSE 84294
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84229: LD_ADDR_EXP 75
84233: PUSH
84234: LD_EXP 75
84238: PPUSH
84239: LD_VAR 0 7
84243: PUSH
84244: LD_EXP 75
84248: PUSH
84249: LD_VAR 0 7
84253: ARRAY
84254: PUSH
84255: LD_INT 1
84257: PLUS
84258: PUSH
84259: EMPTY
84260: LIST
84261: LIST
84262: PPUSH
84263: LD_VAR 0 4
84267: PUSH
84268: LD_VAR 0 2
84272: PUSH
84273: LD_VAR 0 3
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: LIST
84282: PPUSH
84283: CALL 21589 0 3
84287: ST_TO_ADDR
// exit ;
84288: POP
84289: POP
84290: POP
84291: POP
84292: GO 84302
// end ;
84294: GO 84201
84296: POP
84297: POP
// end ;
84298: GO 84009
84300: POP
84301: POP
// end ;
84302: LD_VAR 0 6
84306: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
84307: LD_INT 0
84309: PPUSH
84310: PPUSH
84311: PPUSH
84312: PPUSH
// if not mc_bases or not skirmish then
84313: LD_EXP 59
84317: NOT
84318: PUSH
84319: LD_EXP 57
84323: NOT
84324: OR
84325: IFFALSE 84329
// exit ;
84327: GO 84606
// side := GetSide ( lab ) ;
84329: LD_ADDR_VAR 0 4
84333: PUSH
84334: LD_VAR 0 2
84338: PPUSH
84339: CALL_OW 255
84343: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
84344: LD_VAR 0 4
84348: PUSH
84349: LD_EXP 85
84353: IN
84354: NOT
84355: PUSH
84356: LD_EXP 86
84360: NOT
84361: OR
84362: PUSH
84363: LD_EXP 59
84367: NOT
84368: OR
84369: IFFALSE 84373
// exit ;
84371: GO 84606
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
84373: LD_ADDR_EXP 86
84377: PUSH
84378: LD_EXP 86
84382: PPUSH
84383: LD_VAR 0 4
84387: PPUSH
84388: LD_EXP 86
84392: PUSH
84393: LD_VAR 0 4
84397: ARRAY
84398: PUSH
84399: LD_VAR 0 1
84403: DIFF
84404: PPUSH
84405: CALL_OW 1
84409: ST_TO_ADDR
// for i = 1 to mc_bases do
84410: LD_ADDR_VAR 0 5
84414: PUSH
84415: DOUBLE
84416: LD_INT 1
84418: DEC
84419: ST_TO_ADDR
84420: LD_EXP 59
84424: PUSH
84425: FOR_TO
84426: IFFALSE 84604
// begin if lab in mc_bases [ i ] then
84428: LD_VAR 0 2
84432: PUSH
84433: LD_EXP 59
84437: PUSH
84438: LD_VAR 0 5
84442: ARRAY
84443: IN
84444: IFFALSE 84602
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
84446: LD_VAR 0 1
84450: PUSH
84451: LD_INT 11
84453: PUSH
84454: LD_INT 4
84456: PUSH
84457: LD_INT 3
84459: PUSH
84460: LD_INT 2
84462: PUSH
84463: EMPTY
84464: LIST
84465: LIST
84466: LIST
84467: LIST
84468: IN
84469: PUSH
84470: LD_EXP 89
84474: PUSH
84475: LD_VAR 0 5
84479: ARRAY
84480: AND
84481: IFFALSE 84602
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
84483: LD_ADDR_VAR 0 6
84487: PUSH
84488: LD_EXP 89
84492: PUSH
84493: LD_VAR 0 5
84497: ARRAY
84498: PUSH
84499: LD_INT 1
84501: ARRAY
84502: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84503: LD_ADDR_EXP 89
84507: PUSH
84508: LD_EXP 89
84512: PPUSH
84513: LD_VAR 0 5
84517: PPUSH
84518: EMPTY
84519: PPUSH
84520: CALL_OW 1
84524: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
84525: LD_VAR 0 6
84529: PPUSH
84530: LD_INT 0
84532: PPUSH
84533: CALL_OW 109
// ComExitBuilding ( tmp ) ;
84537: LD_VAR 0 6
84541: PPUSH
84542: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
84546: LD_ADDR_EXP 88
84550: PUSH
84551: LD_EXP 88
84555: PPUSH
84556: LD_VAR 0 5
84560: PPUSH
84561: LD_EXP 88
84565: PUSH
84566: LD_VAR 0 5
84570: ARRAY
84571: PPUSH
84572: LD_INT 1
84574: PPUSH
84575: LD_VAR 0 6
84579: PPUSH
84580: CALL_OW 2
84584: PPUSH
84585: CALL_OW 1
84589: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84590: LD_VAR 0 5
84594: PPUSH
84595: LD_INT 112
84597: PPUSH
84598: CALL 61602 0 2
// end ; end ; end ;
84602: GO 84425
84604: POP
84605: POP
// end ;
84606: LD_VAR 0 3
84610: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84611: LD_INT 0
84613: PPUSH
84614: PPUSH
84615: PPUSH
84616: PPUSH
84617: PPUSH
84618: PPUSH
84619: PPUSH
84620: PPUSH
// if not mc_bases or not skirmish then
84621: LD_EXP 59
84625: NOT
84626: PUSH
84627: LD_EXP 57
84631: NOT
84632: OR
84633: IFFALSE 84637
// exit ;
84635: GO 86008
// for i = 1 to mc_bases do
84637: LD_ADDR_VAR 0 3
84641: PUSH
84642: DOUBLE
84643: LD_INT 1
84645: DEC
84646: ST_TO_ADDR
84647: LD_EXP 59
84651: PUSH
84652: FOR_TO
84653: IFFALSE 86006
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84655: LD_VAR 0 1
84659: PUSH
84660: LD_EXP 59
84664: PUSH
84665: LD_VAR 0 3
84669: ARRAY
84670: IN
84671: PUSH
84672: LD_VAR 0 1
84676: PUSH
84677: LD_EXP 66
84681: PUSH
84682: LD_VAR 0 3
84686: ARRAY
84687: IN
84688: OR
84689: PUSH
84690: LD_VAR 0 1
84694: PUSH
84695: LD_EXP 81
84699: PUSH
84700: LD_VAR 0 3
84704: ARRAY
84705: IN
84706: OR
84707: PUSH
84708: LD_VAR 0 1
84712: PUSH
84713: LD_EXP 78
84717: PUSH
84718: LD_VAR 0 3
84722: ARRAY
84723: IN
84724: OR
84725: PUSH
84726: LD_VAR 0 1
84730: PUSH
84731: LD_EXP 88
84735: PUSH
84736: LD_VAR 0 3
84740: ARRAY
84741: IN
84742: OR
84743: PUSH
84744: LD_VAR 0 1
84748: PUSH
84749: LD_EXP 89
84753: PUSH
84754: LD_VAR 0 3
84758: ARRAY
84759: IN
84760: OR
84761: IFFALSE 86004
// begin if un in mc_ape [ i ] then
84763: LD_VAR 0 1
84767: PUSH
84768: LD_EXP 88
84772: PUSH
84773: LD_VAR 0 3
84777: ARRAY
84778: IN
84779: IFFALSE 84818
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84781: LD_ADDR_EXP 88
84785: PUSH
84786: LD_EXP 88
84790: PPUSH
84791: LD_VAR 0 3
84795: PPUSH
84796: LD_EXP 88
84800: PUSH
84801: LD_VAR 0 3
84805: ARRAY
84806: PUSH
84807: LD_VAR 0 1
84811: DIFF
84812: PPUSH
84813: CALL_OW 1
84817: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84818: LD_VAR 0 1
84822: PUSH
84823: LD_EXP 89
84827: PUSH
84828: LD_VAR 0 3
84832: ARRAY
84833: IN
84834: IFFALSE 84858
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84836: LD_ADDR_EXP 89
84840: PUSH
84841: LD_EXP 89
84845: PPUSH
84846: LD_VAR 0 3
84850: PPUSH
84851: EMPTY
84852: PPUSH
84853: CALL_OW 1
84857: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
84858: LD_VAR 0 1
84862: PPUSH
84863: CALL_OW 247
84867: PUSH
84868: LD_INT 2
84870: EQUAL
84871: PUSH
84872: LD_VAR 0 1
84876: PPUSH
84877: CALL_OW 110
84881: PUSH
84882: LD_INT 20
84884: EQUAL
84885: PUSH
84886: LD_VAR 0 1
84890: PUSH
84891: LD_EXP 81
84895: PUSH
84896: LD_VAR 0 3
84900: ARRAY
84901: IN
84902: OR
84903: PUSH
84904: LD_VAR 0 1
84908: PPUSH
84909: CALL_OW 264
84913: PUSH
84914: LD_INT 12
84916: PUSH
84917: LD_INT 51
84919: PUSH
84920: LD_EXP 103
84924: PUSH
84925: LD_INT 32
84927: PUSH
84928: LD_INT 13
84930: PUSH
84931: LD_INT 52
84933: PUSH
84934: LD_INT 31
84936: PUSH
84937: EMPTY
84938: LIST
84939: LIST
84940: LIST
84941: LIST
84942: LIST
84943: LIST
84944: LIST
84945: IN
84946: OR
84947: AND
84948: IFFALSE 85256
// begin if un in mc_defender [ i ] then
84950: LD_VAR 0 1
84954: PUSH
84955: LD_EXP 81
84959: PUSH
84960: LD_VAR 0 3
84964: ARRAY
84965: IN
84966: IFFALSE 85005
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84968: LD_ADDR_EXP 81
84972: PUSH
84973: LD_EXP 81
84977: PPUSH
84978: LD_VAR 0 3
84982: PPUSH
84983: LD_EXP 81
84987: PUSH
84988: LD_VAR 0 3
84992: ARRAY
84993: PUSH
84994: LD_VAR 0 1
84998: DIFF
84999: PPUSH
85000: CALL_OW 1
85004: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
85005: LD_ADDR_VAR 0 8
85009: PUSH
85010: LD_VAR 0 3
85014: PPUSH
85015: LD_INT 3
85017: PPUSH
85018: CALL 81674 0 2
85022: ST_TO_ADDR
// if fac then
85023: LD_VAR 0 8
85027: IFFALSE 85256
// begin for j in fac do
85029: LD_ADDR_VAR 0 4
85033: PUSH
85034: LD_VAR 0 8
85038: PUSH
85039: FOR_IN
85040: IFFALSE 85254
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
85042: LD_ADDR_VAR 0 9
85046: PUSH
85047: LD_VAR 0 8
85051: PPUSH
85052: LD_VAR 0 1
85056: PPUSH
85057: CALL_OW 265
85061: PPUSH
85062: LD_VAR 0 1
85066: PPUSH
85067: CALL_OW 262
85071: PPUSH
85072: LD_VAR 0 1
85076: PPUSH
85077: CALL_OW 263
85081: PPUSH
85082: LD_VAR 0 1
85086: PPUSH
85087: CALL_OW 264
85091: PPUSH
85092: CALL 19121 0 5
85096: ST_TO_ADDR
// if components then
85097: LD_VAR 0 9
85101: IFFALSE 85252
// begin if GetWeapon ( un ) = ar_control_tower then
85103: LD_VAR 0 1
85107: PPUSH
85108: CALL_OW 264
85112: PUSH
85113: LD_INT 31
85115: EQUAL
85116: IFFALSE 85233
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
85118: LD_VAR 0 1
85122: PPUSH
85123: CALL_OW 311
85127: PPUSH
85128: LD_INT 0
85130: PPUSH
85131: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
85135: LD_ADDR_EXP 99
85139: PUSH
85140: LD_EXP 99
85144: PPUSH
85145: LD_VAR 0 3
85149: PPUSH
85150: LD_EXP 99
85154: PUSH
85155: LD_VAR 0 3
85159: ARRAY
85160: PUSH
85161: LD_VAR 0 1
85165: PPUSH
85166: CALL_OW 311
85170: DIFF
85171: PPUSH
85172: CALL_OW 1
85176: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
85177: LD_ADDR_VAR 0 7
85181: PUSH
85182: LD_EXP 80
85186: PUSH
85187: LD_VAR 0 3
85191: ARRAY
85192: PPUSH
85193: LD_INT 1
85195: PPUSH
85196: LD_VAR 0 9
85200: PPUSH
85201: CALL_OW 2
85205: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
85206: LD_ADDR_EXP 80
85210: PUSH
85211: LD_EXP 80
85215: PPUSH
85216: LD_VAR 0 3
85220: PPUSH
85221: LD_VAR 0 7
85225: PPUSH
85226: CALL_OW 1
85230: ST_TO_ADDR
// end else
85231: GO 85250
// MC_InsertProduceList ( i , [ components ] ) ;
85233: LD_VAR 0 3
85237: PPUSH
85238: LD_VAR 0 9
85242: PUSH
85243: EMPTY
85244: LIST
85245: PPUSH
85246: CALL 81219 0 2
// break ;
85250: GO 85254
// end ; end ;
85252: GO 85039
85254: POP
85255: POP
// end ; end ; if GetType ( un ) = unit_building then
85256: LD_VAR 0 1
85260: PPUSH
85261: CALL_OW 247
85265: PUSH
85266: LD_INT 3
85268: EQUAL
85269: IFFALSE 85672
// begin btype := GetBType ( un ) ;
85271: LD_ADDR_VAR 0 5
85275: PUSH
85276: LD_VAR 0 1
85280: PPUSH
85281: CALL_OW 266
85285: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
85286: LD_VAR 0 5
85290: PUSH
85291: LD_INT 29
85293: PUSH
85294: LD_INT 30
85296: PUSH
85297: EMPTY
85298: LIST
85299: LIST
85300: IN
85301: IFFALSE 85374
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
85303: LD_VAR 0 1
85307: PPUSH
85308: CALL_OW 250
85312: PPUSH
85313: LD_VAR 0 1
85317: PPUSH
85318: CALL_OW 251
85322: PPUSH
85323: LD_VAR 0 1
85327: PPUSH
85328: CALL_OW 255
85332: PPUSH
85333: CALL_OW 440
85337: NOT
85338: IFFALSE 85374
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
85340: LD_VAR 0 1
85344: PPUSH
85345: CALL_OW 250
85349: PPUSH
85350: LD_VAR 0 1
85354: PPUSH
85355: CALL_OW 251
85359: PPUSH
85360: LD_VAR 0 1
85364: PPUSH
85365: CALL_OW 255
85369: PPUSH
85370: CALL_OW 441
// end ; if btype = b_warehouse then
85374: LD_VAR 0 5
85378: PUSH
85379: LD_INT 1
85381: EQUAL
85382: IFFALSE 85400
// begin btype := b_depot ;
85384: LD_ADDR_VAR 0 5
85388: PUSH
85389: LD_INT 0
85391: ST_TO_ADDR
// pos := 1 ;
85392: LD_ADDR_VAR 0 6
85396: PUSH
85397: LD_INT 1
85399: ST_TO_ADDR
// end ; if btype = b_factory then
85400: LD_VAR 0 5
85404: PUSH
85405: LD_INT 3
85407: EQUAL
85408: IFFALSE 85426
// begin btype := b_workshop ;
85410: LD_ADDR_VAR 0 5
85414: PUSH
85415: LD_INT 2
85417: ST_TO_ADDR
// pos := 1 ;
85418: LD_ADDR_VAR 0 6
85422: PUSH
85423: LD_INT 1
85425: ST_TO_ADDR
// end ; if btype = b_barracks then
85426: LD_VAR 0 5
85430: PUSH
85431: LD_INT 5
85433: EQUAL
85434: IFFALSE 85444
// btype := b_armoury ;
85436: LD_ADDR_VAR 0 5
85440: PUSH
85441: LD_INT 4
85443: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
85444: LD_VAR 0 5
85448: PUSH
85449: LD_INT 7
85451: PUSH
85452: LD_INT 8
85454: PUSH
85455: EMPTY
85456: LIST
85457: LIST
85458: IN
85459: IFFALSE 85469
// btype := b_lab ;
85461: LD_ADDR_VAR 0 5
85465: PUSH
85466: LD_INT 6
85468: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
85469: LD_ADDR_EXP 64
85473: PUSH
85474: LD_EXP 64
85478: PPUSH
85479: LD_VAR 0 3
85483: PUSH
85484: LD_EXP 64
85488: PUSH
85489: LD_VAR 0 3
85493: ARRAY
85494: PUSH
85495: LD_INT 1
85497: PLUS
85498: PUSH
85499: EMPTY
85500: LIST
85501: LIST
85502: PPUSH
85503: LD_VAR 0 5
85507: PUSH
85508: LD_VAR 0 1
85512: PPUSH
85513: CALL_OW 250
85517: PUSH
85518: LD_VAR 0 1
85522: PPUSH
85523: CALL_OW 251
85527: PUSH
85528: LD_VAR 0 1
85532: PPUSH
85533: CALL_OW 254
85537: PUSH
85538: EMPTY
85539: LIST
85540: LIST
85541: LIST
85542: LIST
85543: PPUSH
85544: CALL 21589 0 3
85548: ST_TO_ADDR
// if pos = 1 then
85549: LD_VAR 0 6
85553: PUSH
85554: LD_INT 1
85556: EQUAL
85557: IFFALSE 85672
// begin tmp := mc_build_list [ i ] ;
85559: LD_ADDR_VAR 0 7
85563: PUSH
85564: LD_EXP 64
85568: PUSH
85569: LD_VAR 0 3
85573: ARRAY
85574: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
85575: LD_VAR 0 7
85579: PPUSH
85580: LD_INT 2
85582: PUSH
85583: LD_INT 30
85585: PUSH
85586: LD_INT 0
85588: PUSH
85589: EMPTY
85590: LIST
85591: LIST
85592: PUSH
85593: LD_INT 30
85595: PUSH
85596: LD_INT 1
85598: PUSH
85599: EMPTY
85600: LIST
85601: LIST
85602: PUSH
85603: EMPTY
85604: LIST
85605: LIST
85606: LIST
85607: PPUSH
85608: CALL_OW 72
85612: IFFALSE 85622
// pos := 2 ;
85614: LD_ADDR_VAR 0 6
85618: PUSH
85619: LD_INT 2
85621: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85622: LD_ADDR_VAR 0 7
85626: PUSH
85627: LD_VAR 0 7
85631: PPUSH
85632: LD_VAR 0 6
85636: PPUSH
85637: LD_VAR 0 7
85641: PPUSH
85642: CALL 21915 0 3
85646: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85647: LD_ADDR_EXP 64
85651: PUSH
85652: LD_EXP 64
85656: PPUSH
85657: LD_VAR 0 3
85661: PPUSH
85662: LD_VAR 0 7
85666: PPUSH
85667: CALL_OW 1
85671: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85672: LD_VAR 0 1
85676: PUSH
85677: LD_EXP 59
85681: PUSH
85682: LD_VAR 0 3
85686: ARRAY
85687: IN
85688: IFFALSE 85727
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85690: LD_ADDR_EXP 59
85694: PUSH
85695: LD_EXP 59
85699: PPUSH
85700: LD_VAR 0 3
85704: PPUSH
85705: LD_EXP 59
85709: PUSH
85710: LD_VAR 0 3
85714: ARRAY
85715: PUSH
85716: LD_VAR 0 1
85720: DIFF
85721: PPUSH
85722: CALL_OW 1
85726: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85727: LD_VAR 0 1
85731: PUSH
85732: LD_EXP 66
85736: PUSH
85737: LD_VAR 0 3
85741: ARRAY
85742: IN
85743: IFFALSE 85782
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85745: LD_ADDR_EXP 66
85749: PUSH
85750: LD_EXP 66
85754: PPUSH
85755: LD_VAR 0 3
85759: PPUSH
85760: LD_EXP 66
85764: PUSH
85765: LD_VAR 0 3
85769: ARRAY
85770: PUSH
85771: LD_VAR 0 1
85775: DIFF
85776: PPUSH
85777: CALL_OW 1
85781: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85782: LD_VAR 0 1
85786: PUSH
85787: LD_EXP 78
85791: PUSH
85792: LD_VAR 0 3
85796: ARRAY
85797: IN
85798: IFFALSE 85837
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85800: LD_ADDR_EXP 78
85804: PUSH
85805: LD_EXP 78
85809: PPUSH
85810: LD_VAR 0 3
85814: PPUSH
85815: LD_EXP 78
85819: PUSH
85820: LD_VAR 0 3
85824: ARRAY
85825: PUSH
85826: LD_VAR 0 1
85830: DIFF
85831: PPUSH
85832: CALL_OW 1
85836: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85837: LD_VAR 0 1
85841: PUSH
85842: LD_EXP 81
85846: PUSH
85847: LD_VAR 0 3
85851: ARRAY
85852: IN
85853: IFFALSE 85892
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85855: LD_ADDR_EXP 81
85859: PUSH
85860: LD_EXP 81
85864: PPUSH
85865: LD_VAR 0 3
85869: PPUSH
85870: LD_EXP 81
85874: PUSH
85875: LD_VAR 0 3
85879: ARRAY
85880: PUSH
85881: LD_VAR 0 1
85885: DIFF
85886: PPUSH
85887: CALL_OW 1
85891: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85892: LD_VAR 0 1
85896: PUSH
85897: LD_EXP 68
85901: PUSH
85902: LD_VAR 0 3
85906: ARRAY
85907: IN
85908: IFFALSE 85947
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85910: LD_ADDR_EXP 68
85914: PUSH
85915: LD_EXP 68
85919: PPUSH
85920: LD_VAR 0 3
85924: PPUSH
85925: LD_EXP 68
85929: PUSH
85930: LD_VAR 0 3
85934: ARRAY
85935: PUSH
85936: LD_VAR 0 1
85940: DIFF
85941: PPUSH
85942: CALL_OW 1
85946: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85947: LD_VAR 0 1
85951: PUSH
85952: LD_EXP 67
85956: PUSH
85957: LD_VAR 0 3
85961: ARRAY
85962: IN
85963: IFFALSE 86002
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85965: LD_ADDR_EXP 67
85969: PUSH
85970: LD_EXP 67
85974: PPUSH
85975: LD_VAR 0 3
85979: PPUSH
85980: LD_EXP 67
85984: PUSH
85985: LD_VAR 0 3
85989: ARRAY
85990: PUSH
85991: LD_VAR 0 1
85995: DIFF
85996: PPUSH
85997: CALL_OW 1
86001: ST_TO_ADDR
// end ; break ;
86002: GO 86006
// end ;
86004: GO 84652
86006: POP
86007: POP
// end ;
86008: LD_VAR 0 2
86012: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
86013: LD_INT 0
86015: PPUSH
86016: PPUSH
86017: PPUSH
// if not mc_bases or not skirmish then
86018: LD_EXP 59
86022: NOT
86023: PUSH
86024: LD_EXP 57
86028: NOT
86029: OR
86030: IFFALSE 86034
// exit ;
86032: GO 86249
// for i = 1 to mc_bases do
86034: LD_ADDR_VAR 0 3
86038: PUSH
86039: DOUBLE
86040: LD_INT 1
86042: DEC
86043: ST_TO_ADDR
86044: LD_EXP 59
86048: PUSH
86049: FOR_TO
86050: IFFALSE 86247
// begin if building in mc_construct_list [ i ] then
86052: LD_VAR 0 1
86056: PUSH
86057: LD_EXP 66
86061: PUSH
86062: LD_VAR 0 3
86066: ARRAY
86067: IN
86068: IFFALSE 86245
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86070: LD_ADDR_EXP 66
86074: PUSH
86075: LD_EXP 66
86079: PPUSH
86080: LD_VAR 0 3
86084: PPUSH
86085: LD_EXP 66
86089: PUSH
86090: LD_VAR 0 3
86094: ARRAY
86095: PUSH
86096: LD_VAR 0 1
86100: DIFF
86101: PPUSH
86102: CALL_OW 1
86106: ST_TO_ADDR
// if building in mc_lab [ i ] then
86107: LD_VAR 0 1
86111: PUSH
86112: LD_EXP 92
86116: PUSH
86117: LD_VAR 0 3
86121: ARRAY
86122: IN
86123: IFFALSE 86178
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
86125: LD_ADDR_EXP 93
86129: PUSH
86130: LD_EXP 93
86134: PPUSH
86135: LD_VAR 0 3
86139: PPUSH
86140: LD_EXP 93
86144: PUSH
86145: LD_VAR 0 3
86149: ARRAY
86150: PPUSH
86151: LD_INT 1
86153: PPUSH
86154: LD_EXP 93
86158: PUSH
86159: LD_VAR 0 3
86163: ARRAY
86164: PPUSH
86165: LD_INT 0
86167: PPUSH
86168: CALL 21007 0 4
86172: PPUSH
86173: CALL_OW 1
86177: ST_TO_ADDR
// if not building in mc_bases [ i ] then
86178: LD_VAR 0 1
86182: PUSH
86183: LD_EXP 59
86187: PUSH
86188: LD_VAR 0 3
86192: ARRAY
86193: IN
86194: NOT
86195: IFFALSE 86241
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86197: LD_ADDR_EXP 59
86201: PUSH
86202: LD_EXP 59
86206: PPUSH
86207: LD_VAR 0 3
86211: PUSH
86212: LD_EXP 59
86216: PUSH
86217: LD_VAR 0 3
86221: ARRAY
86222: PUSH
86223: LD_INT 1
86225: PLUS
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: PPUSH
86231: LD_VAR 0 1
86235: PPUSH
86236: CALL 21589 0 3
86240: ST_TO_ADDR
// exit ;
86241: POP
86242: POP
86243: GO 86249
// end ; end ;
86245: GO 86049
86247: POP
86248: POP
// end ;
86249: LD_VAR 0 2
86253: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
86254: LD_INT 0
86256: PPUSH
86257: PPUSH
86258: PPUSH
86259: PPUSH
86260: PPUSH
86261: PPUSH
86262: PPUSH
// if not mc_bases or not skirmish then
86263: LD_EXP 59
86267: NOT
86268: PUSH
86269: LD_EXP 57
86273: NOT
86274: OR
86275: IFFALSE 86279
// exit ;
86277: GO 86940
// for i = 1 to mc_bases do
86279: LD_ADDR_VAR 0 3
86283: PUSH
86284: DOUBLE
86285: LD_INT 1
86287: DEC
86288: ST_TO_ADDR
86289: LD_EXP 59
86293: PUSH
86294: FOR_TO
86295: IFFALSE 86938
// begin if building in mc_construct_list [ i ] then
86297: LD_VAR 0 1
86301: PUSH
86302: LD_EXP 66
86306: PUSH
86307: LD_VAR 0 3
86311: ARRAY
86312: IN
86313: IFFALSE 86936
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86315: LD_ADDR_EXP 66
86319: PUSH
86320: LD_EXP 66
86324: PPUSH
86325: LD_VAR 0 3
86329: PPUSH
86330: LD_EXP 66
86334: PUSH
86335: LD_VAR 0 3
86339: ARRAY
86340: PUSH
86341: LD_VAR 0 1
86345: DIFF
86346: PPUSH
86347: CALL_OW 1
86351: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86352: LD_ADDR_EXP 59
86356: PUSH
86357: LD_EXP 59
86361: PPUSH
86362: LD_VAR 0 3
86366: PUSH
86367: LD_EXP 59
86371: PUSH
86372: LD_VAR 0 3
86376: ARRAY
86377: PUSH
86378: LD_INT 1
86380: PLUS
86381: PUSH
86382: EMPTY
86383: LIST
86384: LIST
86385: PPUSH
86386: LD_VAR 0 1
86390: PPUSH
86391: CALL 21589 0 3
86395: ST_TO_ADDR
// btype := GetBType ( building ) ;
86396: LD_ADDR_VAR 0 5
86400: PUSH
86401: LD_VAR 0 1
86405: PPUSH
86406: CALL_OW 266
86410: ST_TO_ADDR
// side := GetSide ( building ) ;
86411: LD_ADDR_VAR 0 8
86415: PUSH
86416: LD_VAR 0 1
86420: PPUSH
86421: CALL_OW 255
86425: ST_TO_ADDR
// if btype = b_lab then
86426: LD_VAR 0 5
86430: PUSH
86431: LD_INT 6
86433: EQUAL
86434: IFFALSE 86484
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
86436: LD_ADDR_EXP 92
86440: PUSH
86441: LD_EXP 92
86445: PPUSH
86446: LD_VAR 0 3
86450: PUSH
86451: LD_EXP 92
86455: PUSH
86456: LD_VAR 0 3
86460: ARRAY
86461: PUSH
86462: LD_INT 1
86464: PLUS
86465: PUSH
86466: EMPTY
86467: LIST
86468: LIST
86469: PPUSH
86470: LD_VAR 0 1
86474: PPUSH
86475: CALL 21589 0 3
86479: ST_TO_ADDR
// exit ;
86480: POP
86481: POP
86482: GO 86940
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
86484: LD_VAR 0 5
86488: PUSH
86489: LD_INT 0
86491: PUSH
86492: LD_INT 2
86494: PUSH
86495: LD_INT 4
86497: PUSH
86498: EMPTY
86499: LIST
86500: LIST
86501: LIST
86502: IN
86503: IFFALSE 86627
// begin if btype = b_armoury then
86505: LD_VAR 0 5
86509: PUSH
86510: LD_INT 4
86512: EQUAL
86513: IFFALSE 86523
// btype := b_barracks ;
86515: LD_ADDR_VAR 0 5
86519: PUSH
86520: LD_INT 5
86522: ST_TO_ADDR
// if btype = b_depot then
86523: LD_VAR 0 5
86527: PUSH
86528: LD_INT 0
86530: EQUAL
86531: IFFALSE 86541
// btype := b_warehouse ;
86533: LD_ADDR_VAR 0 5
86537: PUSH
86538: LD_INT 1
86540: ST_TO_ADDR
// if btype = b_workshop then
86541: LD_VAR 0 5
86545: PUSH
86546: LD_INT 2
86548: EQUAL
86549: IFFALSE 86559
// btype := b_factory ;
86551: LD_ADDR_VAR 0 5
86555: PUSH
86556: LD_INT 3
86558: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
86559: LD_VAR 0 5
86563: PPUSH
86564: LD_VAR 0 8
86568: PPUSH
86569: CALL_OW 323
86573: PUSH
86574: LD_INT 1
86576: EQUAL
86577: IFFALSE 86623
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
86579: LD_ADDR_EXP 91
86583: PUSH
86584: LD_EXP 91
86588: PPUSH
86589: LD_VAR 0 3
86593: PUSH
86594: LD_EXP 91
86598: PUSH
86599: LD_VAR 0 3
86603: ARRAY
86604: PUSH
86605: LD_INT 1
86607: PLUS
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: PPUSH
86613: LD_VAR 0 1
86617: PPUSH
86618: CALL 21589 0 3
86622: ST_TO_ADDR
// exit ;
86623: POP
86624: POP
86625: GO 86940
// end ; if btype in [ b_bunker , b_turret ] then
86627: LD_VAR 0 5
86631: PUSH
86632: LD_INT 32
86634: PUSH
86635: LD_INT 33
86637: PUSH
86638: EMPTY
86639: LIST
86640: LIST
86641: IN
86642: IFFALSE 86932
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86644: LD_ADDR_EXP 67
86648: PUSH
86649: LD_EXP 67
86653: PPUSH
86654: LD_VAR 0 3
86658: PUSH
86659: LD_EXP 67
86663: PUSH
86664: LD_VAR 0 3
86668: ARRAY
86669: PUSH
86670: LD_INT 1
86672: PLUS
86673: PUSH
86674: EMPTY
86675: LIST
86676: LIST
86677: PPUSH
86678: LD_VAR 0 1
86682: PPUSH
86683: CALL 21589 0 3
86687: ST_TO_ADDR
// if btype = b_bunker then
86688: LD_VAR 0 5
86692: PUSH
86693: LD_INT 32
86695: EQUAL
86696: IFFALSE 86932
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86698: LD_ADDR_EXP 68
86702: PUSH
86703: LD_EXP 68
86707: PPUSH
86708: LD_VAR 0 3
86712: PUSH
86713: LD_EXP 68
86717: PUSH
86718: LD_VAR 0 3
86722: ARRAY
86723: PUSH
86724: LD_INT 1
86726: PLUS
86727: PUSH
86728: EMPTY
86729: LIST
86730: LIST
86731: PPUSH
86732: LD_VAR 0 1
86736: PPUSH
86737: CALL 21589 0 3
86741: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86742: LD_ADDR_VAR 0 6
86746: PUSH
86747: LD_EXP 59
86751: PUSH
86752: LD_VAR 0 3
86756: ARRAY
86757: PPUSH
86758: LD_INT 25
86760: PUSH
86761: LD_INT 1
86763: PUSH
86764: EMPTY
86765: LIST
86766: LIST
86767: PUSH
86768: LD_INT 3
86770: PUSH
86771: LD_INT 54
86773: PUSH
86774: EMPTY
86775: LIST
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: EMPTY
86782: LIST
86783: LIST
86784: PPUSH
86785: CALL_OW 72
86789: ST_TO_ADDR
// if tmp then
86790: LD_VAR 0 6
86794: IFFALSE 86800
// exit ;
86796: POP
86797: POP
86798: GO 86940
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86800: LD_ADDR_VAR 0 6
86804: PUSH
86805: LD_EXP 59
86809: PUSH
86810: LD_VAR 0 3
86814: ARRAY
86815: PPUSH
86816: LD_INT 2
86818: PUSH
86819: LD_INT 30
86821: PUSH
86822: LD_INT 4
86824: PUSH
86825: EMPTY
86826: LIST
86827: LIST
86828: PUSH
86829: LD_INT 30
86831: PUSH
86832: LD_INT 5
86834: PUSH
86835: EMPTY
86836: LIST
86837: LIST
86838: PUSH
86839: EMPTY
86840: LIST
86841: LIST
86842: LIST
86843: PPUSH
86844: CALL_OW 72
86848: ST_TO_ADDR
// if not tmp then
86849: LD_VAR 0 6
86853: NOT
86854: IFFALSE 86860
// exit ;
86856: POP
86857: POP
86858: GO 86940
// for j in tmp do
86860: LD_ADDR_VAR 0 4
86864: PUSH
86865: LD_VAR 0 6
86869: PUSH
86870: FOR_IN
86871: IFFALSE 86930
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86873: LD_ADDR_VAR 0 7
86877: PUSH
86878: LD_VAR 0 4
86882: PPUSH
86883: CALL_OW 313
86887: PPUSH
86888: LD_INT 25
86890: PUSH
86891: LD_INT 1
86893: PUSH
86894: EMPTY
86895: LIST
86896: LIST
86897: PPUSH
86898: CALL_OW 72
86902: ST_TO_ADDR
// if units then
86903: LD_VAR 0 7
86907: IFFALSE 86928
// begin ComExitBuilding ( units [ 1 ] ) ;
86909: LD_VAR 0 7
86913: PUSH
86914: LD_INT 1
86916: ARRAY
86917: PPUSH
86918: CALL_OW 122
// exit ;
86922: POP
86923: POP
86924: POP
86925: POP
86926: GO 86940
// end ; end ;
86928: GO 86870
86930: POP
86931: POP
// end ; end ; exit ;
86932: POP
86933: POP
86934: GO 86940
// end ; end ;
86936: GO 86294
86938: POP
86939: POP
// end ;
86940: LD_VAR 0 2
86944: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86945: LD_INT 0
86947: PPUSH
86948: PPUSH
86949: PPUSH
86950: PPUSH
86951: PPUSH
86952: PPUSH
86953: PPUSH
// if not mc_bases or not skirmish then
86954: LD_EXP 59
86958: NOT
86959: PUSH
86960: LD_EXP 57
86964: NOT
86965: OR
86966: IFFALSE 86970
// exit ;
86968: GO 87201
// btype := GetBType ( building ) ;
86970: LD_ADDR_VAR 0 6
86974: PUSH
86975: LD_VAR 0 1
86979: PPUSH
86980: CALL_OW 266
86984: ST_TO_ADDR
// x := GetX ( building ) ;
86985: LD_ADDR_VAR 0 7
86989: PUSH
86990: LD_VAR 0 1
86994: PPUSH
86995: CALL_OW 250
86999: ST_TO_ADDR
// y := GetY ( building ) ;
87000: LD_ADDR_VAR 0 8
87004: PUSH
87005: LD_VAR 0 1
87009: PPUSH
87010: CALL_OW 251
87014: ST_TO_ADDR
// d := GetDir ( building ) ;
87015: LD_ADDR_VAR 0 9
87019: PUSH
87020: LD_VAR 0 1
87024: PPUSH
87025: CALL_OW 254
87029: ST_TO_ADDR
// for i = 1 to mc_bases do
87030: LD_ADDR_VAR 0 4
87034: PUSH
87035: DOUBLE
87036: LD_INT 1
87038: DEC
87039: ST_TO_ADDR
87040: LD_EXP 59
87044: PUSH
87045: FOR_TO
87046: IFFALSE 87199
// begin if not mc_build_list [ i ] then
87048: LD_EXP 64
87052: PUSH
87053: LD_VAR 0 4
87057: ARRAY
87058: NOT
87059: IFFALSE 87063
// continue ;
87061: GO 87045
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
87063: LD_VAR 0 6
87067: PUSH
87068: LD_VAR 0 7
87072: PUSH
87073: LD_VAR 0 8
87077: PUSH
87078: LD_VAR 0 9
87082: PUSH
87083: EMPTY
87084: LIST
87085: LIST
87086: LIST
87087: LIST
87088: PPUSH
87089: LD_EXP 64
87093: PUSH
87094: LD_VAR 0 4
87098: ARRAY
87099: PUSH
87100: LD_INT 1
87102: ARRAY
87103: PPUSH
87104: CALL 27758 0 2
87108: IFFALSE 87197
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
87110: LD_ADDR_EXP 64
87114: PUSH
87115: LD_EXP 64
87119: PPUSH
87120: LD_VAR 0 4
87124: PPUSH
87125: LD_EXP 64
87129: PUSH
87130: LD_VAR 0 4
87134: ARRAY
87135: PPUSH
87136: LD_INT 1
87138: PPUSH
87139: CALL_OW 3
87143: PPUSH
87144: CALL_OW 1
87148: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
87149: LD_ADDR_EXP 66
87153: PUSH
87154: LD_EXP 66
87158: PPUSH
87159: LD_VAR 0 4
87163: PUSH
87164: LD_EXP 66
87168: PUSH
87169: LD_VAR 0 4
87173: ARRAY
87174: PUSH
87175: LD_INT 1
87177: PLUS
87178: PUSH
87179: EMPTY
87180: LIST
87181: LIST
87182: PPUSH
87183: LD_VAR 0 1
87187: PPUSH
87188: CALL 21589 0 3
87192: ST_TO_ADDR
// exit ;
87193: POP
87194: POP
87195: GO 87201
// end ; end ;
87197: GO 87045
87199: POP
87200: POP
// end ;
87201: LD_VAR 0 3
87205: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
87206: LD_INT 0
87208: PPUSH
87209: PPUSH
87210: PPUSH
// if not mc_bases or not skirmish then
87211: LD_EXP 59
87215: NOT
87216: PUSH
87217: LD_EXP 57
87221: NOT
87222: OR
87223: IFFALSE 87227
// exit ;
87225: GO 87417
// for i = 1 to mc_bases do
87227: LD_ADDR_VAR 0 4
87231: PUSH
87232: DOUBLE
87233: LD_INT 1
87235: DEC
87236: ST_TO_ADDR
87237: LD_EXP 59
87241: PUSH
87242: FOR_TO
87243: IFFALSE 87330
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
87245: LD_VAR 0 1
87249: PUSH
87250: LD_EXP 67
87254: PUSH
87255: LD_VAR 0 4
87259: ARRAY
87260: IN
87261: PUSH
87262: LD_VAR 0 1
87266: PUSH
87267: LD_EXP 68
87271: PUSH
87272: LD_VAR 0 4
87276: ARRAY
87277: IN
87278: NOT
87279: AND
87280: IFFALSE 87328
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
87282: LD_ADDR_EXP 68
87286: PUSH
87287: LD_EXP 68
87291: PPUSH
87292: LD_VAR 0 4
87296: PUSH
87297: LD_EXP 68
87301: PUSH
87302: LD_VAR 0 4
87306: ARRAY
87307: PUSH
87308: LD_INT 1
87310: PLUS
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: PPUSH
87316: LD_VAR 0 1
87320: PPUSH
87321: CALL 21589 0 3
87325: ST_TO_ADDR
// break ;
87326: GO 87330
// end ; end ;
87328: GO 87242
87330: POP
87331: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
87332: LD_VAR 0 1
87336: PPUSH
87337: CALL_OW 257
87341: PUSH
87342: LD_EXP 85
87346: IN
87347: PUSH
87348: LD_VAR 0 1
87352: PPUSH
87353: CALL_OW 266
87357: PUSH
87358: LD_INT 5
87360: EQUAL
87361: AND
87362: PUSH
87363: LD_VAR 0 2
87367: PPUSH
87368: CALL_OW 110
87372: PUSH
87373: LD_INT 18
87375: NONEQUAL
87376: AND
87377: IFFALSE 87417
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
87379: LD_VAR 0 2
87383: PPUSH
87384: CALL_OW 257
87388: PUSH
87389: LD_INT 5
87391: PUSH
87392: LD_INT 8
87394: PUSH
87395: LD_INT 9
87397: PUSH
87398: EMPTY
87399: LIST
87400: LIST
87401: LIST
87402: IN
87403: IFFALSE 87417
// SetClass ( unit , 1 ) ;
87405: LD_VAR 0 2
87409: PPUSH
87410: LD_INT 1
87412: PPUSH
87413: CALL_OW 336
// end ;
87417: LD_VAR 0 3
87421: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
87422: LD_INT 0
87424: PPUSH
87425: PPUSH
// if not mc_bases or not skirmish then
87426: LD_EXP 59
87430: NOT
87431: PUSH
87432: LD_EXP 57
87436: NOT
87437: OR
87438: IFFALSE 87442
// exit ;
87440: GO 87558
// if GetLives ( abandoned_vehicle ) > 250 then
87442: LD_VAR 0 2
87446: PPUSH
87447: CALL_OW 256
87451: PUSH
87452: LD_INT 250
87454: GREATER
87455: IFFALSE 87459
// exit ;
87457: GO 87558
// for i = 1 to mc_bases do
87459: LD_ADDR_VAR 0 6
87463: PUSH
87464: DOUBLE
87465: LD_INT 1
87467: DEC
87468: ST_TO_ADDR
87469: LD_EXP 59
87473: PUSH
87474: FOR_TO
87475: IFFALSE 87556
// begin if driver in mc_bases [ i ] then
87477: LD_VAR 0 1
87481: PUSH
87482: LD_EXP 59
87486: PUSH
87487: LD_VAR 0 6
87491: ARRAY
87492: IN
87493: IFFALSE 87554
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
87495: LD_VAR 0 1
87499: PPUSH
87500: LD_EXP 59
87504: PUSH
87505: LD_VAR 0 6
87509: ARRAY
87510: PPUSH
87511: LD_INT 2
87513: PUSH
87514: LD_INT 30
87516: PUSH
87517: LD_INT 0
87519: PUSH
87520: EMPTY
87521: LIST
87522: LIST
87523: PUSH
87524: LD_INT 30
87526: PUSH
87527: LD_INT 1
87529: PUSH
87530: EMPTY
87531: LIST
87532: LIST
87533: PUSH
87534: EMPTY
87535: LIST
87536: LIST
87537: LIST
87538: PPUSH
87539: CALL_OW 72
87543: PUSH
87544: LD_INT 1
87546: ARRAY
87547: PPUSH
87548: CALL_OW 112
// break ;
87552: GO 87556
// end ; end ;
87554: GO 87474
87556: POP
87557: POP
// end ; end_of_file
87558: LD_VAR 0 5
87562: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
87563: GO 87565
87565: DISABLE
// begin ru_radar := 98 ;
87566: LD_ADDR_EXP 102
87570: PUSH
87571: LD_INT 98
87573: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
87574: LD_ADDR_EXP 103
87578: PUSH
87579: LD_INT 89
87581: ST_TO_ADDR
// us_hack := 99 ;
87582: LD_ADDR_EXP 104
87586: PUSH
87587: LD_INT 99
87589: ST_TO_ADDR
// us_artillery := 97 ;
87590: LD_ADDR_EXP 105
87594: PUSH
87595: LD_INT 97
87597: ST_TO_ADDR
// ar_bio_bomb := 91 ;
87598: LD_ADDR_EXP 106
87602: PUSH
87603: LD_INT 91
87605: ST_TO_ADDR
// end ; end_of_file end_of_file
87606: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
87607: GO 87609
87609: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
87610: LD_STRING initStreamRollete();
87612: PPUSH
87613: CALL_OW 559
// InitStreamMode ;
87617: CALL 87626 0 0
// DefineStreamItems ( ) ;
87621: CALL 88066 0 0
// end ;
87625: END
// function InitStreamMode ; begin
87626: LD_INT 0
87628: PPUSH
// streamModeActive := false ;
87629: LD_ADDR_EXP 107
87633: PUSH
87634: LD_INT 0
87636: ST_TO_ADDR
// normalCounter := 36 ;
87637: LD_ADDR_EXP 108
87641: PUSH
87642: LD_INT 36
87644: ST_TO_ADDR
// hardcoreCounter := 16 ;
87645: LD_ADDR_EXP 109
87649: PUSH
87650: LD_INT 16
87652: ST_TO_ADDR
// sRocket := false ;
87653: LD_ADDR_EXP 112
87657: PUSH
87658: LD_INT 0
87660: ST_TO_ADDR
// sSpeed := false ;
87661: LD_ADDR_EXP 111
87665: PUSH
87666: LD_INT 0
87668: ST_TO_ADDR
// sEngine := false ;
87669: LD_ADDR_EXP 113
87673: PUSH
87674: LD_INT 0
87676: ST_TO_ADDR
// sSpec := false ;
87677: LD_ADDR_EXP 110
87681: PUSH
87682: LD_INT 0
87684: ST_TO_ADDR
// sLevel := false ;
87685: LD_ADDR_EXP 114
87689: PUSH
87690: LD_INT 0
87692: ST_TO_ADDR
// sArmoury := false ;
87693: LD_ADDR_EXP 115
87697: PUSH
87698: LD_INT 0
87700: ST_TO_ADDR
// sRadar := false ;
87701: LD_ADDR_EXP 116
87705: PUSH
87706: LD_INT 0
87708: ST_TO_ADDR
// sBunker := false ;
87709: LD_ADDR_EXP 117
87713: PUSH
87714: LD_INT 0
87716: ST_TO_ADDR
// sHack := false ;
87717: LD_ADDR_EXP 118
87721: PUSH
87722: LD_INT 0
87724: ST_TO_ADDR
// sFire := false ;
87725: LD_ADDR_EXP 119
87729: PUSH
87730: LD_INT 0
87732: ST_TO_ADDR
// sRefresh := false ;
87733: LD_ADDR_EXP 120
87737: PUSH
87738: LD_INT 0
87740: ST_TO_ADDR
// sExp := false ;
87741: LD_ADDR_EXP 121
87745: PUSH
87746: LD_INT 0
87748: ST_TO_ADDR
// sDepot := false ;
87749: LD_ADDR_EXP 122
87753: PUSH
87754: LD_INT 0
87756: ST_TO_ADDR
// sFlag := false ;
87757: LD_ADDR_EXP 123
87761: PUSH
87762: LD_INT 0
87764: ST_TO_ADDR
// sKamikadze := false ;
87765: LD_ADDR_EXP 131
87769: PUSH
87770: LD_INT 0
87772: ST_TO_ADDR
// sTroll := false ;
87773: LD_ADDR_EXP 132
87777: PUSH
87778: LD_INT 0
87780: ST_TO_ADDR
// sSlow := false ;
87781: LD_ADDR_EXP 133
87785: PUSH
87786: LD_INT 0
87788: ST_TO_ADDR
// sLack := false ;
87789: LD_ADDR_EXP 134
87793: PUSH
87794: LD_INT 0
87796: ST_TO_ADDR
// sTank := false ;
87797: LD_ADDR_EXP 136
87801: PUSH
87802: LD_INT 0
87804: ST_TO_ADDR
// sRemote := false ;
87805: LD_ADDR_EXP 137
87809: PUSH
87810: LD_INT 0
87812: ST_TO_ADDR
// sPowell := false ;
87813: LD_ADDR_EXP 138
87817: PUSH
87818: LD_INT 0
87820: ST_TO_ADDR
// sTeleport := false ;
87821: LD_ADDR_EXP 141
87825: PUSH
87826: LD_INT 0
87828: ST_TO_ADDR
// sOilTower := false ;
87829: LD_ADDR_EXP 143
87833: PUSH
87834: LD_INT 0
87836: ST_TO_ADDR
// sShovel := false ;
87837: LD_ADDR_EXP 144
87841: PUSH
87842: LD_INT 0
87844: ST_TO_ADDR
// sSheik := false ;
87845: LD_ADDR_EXP 145
87849: PUSH
87850: LD_INT 0
87852: ST_TO_ADDR
// sEarthquake := false ;
87853: LD_ADDR_EXP 147
87857: PUSH
87858: LD_INT 0
87860: ST_TO_ADDR
// sAI := false ;
87861: LD_ADDR_EXP 148
87865: PUSH
87866: LD_INT 0
87868: ST_TO_ADDR
// sCargo := false ;
87869: LD_ADDR_EXP 151
87873: PUSH
87874: LD_INT 0
87876: ST_TO_ADDR
// sDLaser := false ;
87877: LD_ADDR_EXP 152
87881: PUSH
87882: LD_INT 0
87884: ST_TO_ADDR
// sExchange := false ;
87885: LD_ADDR_EXP 153
87889: PUSH
87890: LD_INT 0
87892: ST_TO_ADDR
// sFac := false ;
87893: LD_ADDR_EXP 154
87897: PUSH
87898: LD_INT 0
87900: ST_TO_ADDR
// sPower := false ;
87901: LD_ADDR_EXP 155
87905: PUSH
87906: LD_INT 0
87908: ST_TO_ADDR
// sRandom := false ;
87909: LD_ADDR_EXP 156
87913: PUSH
87914: LD_INT 0
87916: ST_TO_ADDR
// sShield := false ;
87917: LD_ADDR_EXP 157
87921: PUSH
87922: LD_INT 0
87924: ST_TO_ADDR
// sTime := false ;
87925: LD_ADDR_EXP 158
87929: PUSH
87930: LD_INT 0
87932: ST_TO_ADDR
// sTools := false ;
87933: LD_ADDR_EXP 159
87937: PUSH
87938: LD_INT 0
87940: ST_TO_ADDR
// sSold := false ;
87941: LD_ADDR_EXP 124
87945: PUSH
87946: LD_INT 0
87948: ST_TO_ADDR
// sDiff := false ;
87949: LD_ADDR_EXP 125
87953: PUSH
87954: LD_INT 0
87956: ST_TO_ADDR
// sFog := false ;
87957: LD_ADDR_EXP 128
87961: PUSH
87962: LD_INT 0
87964: ST_TO_ADDR
// sReset := false ;
87965: LD_ADDR_EXP 129
87969: PUSH
87970: LD_INT 0
87972: ST_TO_ADDR
// sSun := false ;
87973: LD_ADDR_EXP 130
87977: PUSH
87978: LD_INT 0
87980: ST_TO_ADDR
// sTiger := false ;
87981: LD_ADDR_EXP 126
87985: PUSH
87986: LD_INT 0
87988: ST_TO_ADDR
// sBomb := false ;
87989: LD_ADDR_EXP 127
87993: PUSH
87994: LD_INT 0
87996: ST_TO_ADDR
// sWound := false ;
87997: LD_ADDR_EXP 135
88001: PUSH
88002: LD_INT 0
88004: ST_TO_ADDR
// sBetray := false ;
88005: LD_ADDR_EXP 139
88009: PUSH
88010: LD_INT 0
88012: ST_TO_ADDR
// sContamin := false ;
88013: LD_ADDR_EXP 140
88017: PUSH
88018: LD_INT 0
88020: ST_TO_ADDR
// sOil := false ;
88021: LD_ADDR_EXP 142
88025: PUSH
88026: LD_INT 0
88028: ST_TO_ADDR
// sStu := false ;
88029: LD_ADDR_EXP 146
88033: PUSH
88034: LD_INT 0
88036: ST_TO_ADDR
// sBazooka := false ;
88037: LD_ADDR_EXP 149
88041: PUSH
88042: LD_INT 0
88044: ST_TO_ADDR
// sMortar := false ;
88045: LD_ADDR_EXP 150
88049: PUSH
88050: LD_INT 0
88052: ST_TO_ADDR
// sRanger := false ;
88053: LD_ADDR_EXP 160
88057: PUSH
88058: LD_INT 0
88060: ST_TO_ADDR
// end ;
88061: LD_VAR 0 1
88065: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
88066: LD_INT 0
88068: PPUSH
88069: PPUSH
88070: PPUSH
88071: PPUSH
88072: PPUSH
// result := [ ] ;
88073: LD_ADDR_VAR 0 1
88077: PUSH
88078: EMPTY
88079: ST_TO_ADDR
// if campaign_id = 1 then
88080: LD_OWVAR 69
88084: PUSH
88085: LD_INT 1
88087: EQUAL
88088: IFFALSE 91026
// begin case mission_number of 1 :
88090: LD_OWVAR 70
88094: PUSH
88095: LD_INT 1
88097: DOUBLE
88098: EQUAL
88099: IFTRUE 88103
88101: GO 88167
88103: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
88104: LD_ADDR_VAR 0 1
88108: PUSH
88109: LD_INT 2
88111: PUSH
88112: LD_INT 4
88114: PUSH
88115: LD_INT 11
88117: PUSH
88118: LD_INT 12
88120: PUSH
88121: LD_INT 15
88123: PUSH
88124: LD_INT 16
88126: PUSH
88127: LD_INT 22
88129: PUSH
88130: LD_INT 23
88132: PUSH
88133: LD_INT 26
88135: PUSH
88136: EMPTY
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: LIST
88146: PUSH
88147: LD_INT 101
88149: PUSH
88150: LD_INT 102
88152: PUSH
88153: LD_INT 106
88155: PUSH
88156: EMPTY
88157: LIST
88158: LIST
88159: LIST
88160: PUSH
88161: EMPTY
88162: LIST
88163: LIST
88164: ST_TO_ADDR
88165: GO 91024
88167: LD_INT 2
88169: DOUBLE
88170: EQUAL
88171: IFTRUE 88175
88173: GO 88247
88175: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
88176: LD_ADDR_VAR 0 1
88180: PUSH
88181: LD_INT 2
88183: PUSH
88184: LD_INT 4
88186: PUSH
88187: LD_INT 11
88189: PUSH
88190: LD_INT 12
88192: PUSH
88193: LD_INT 15
88195: PUSH
88196: LD_INT 16
88198: PUSH
88199: LD_INT 22
88201: PUSH
88202: LD_INT 23
88204: PUSH
88205: LD_INT 26
88207: PUSH
88208: EMPTY
88209: LIST
88210: LIST
88211: LIST
88212: LIST
88213: LIST
88214: LIST
88215: LIST
88216: LIST
88217: LIST
88218: PUSH
88219: LD_INT 101
88221: PUSH
88222: LD_INT 102
88224: PUSH
88225: LD_INT 105
88227: PUSH
88228: LD_INT 106
88230: PUSH
88231: LD_INT 108
88233: PUSH
88234: EMPTY
88235: LIST
88236: LIST
88237: LIST
88238: LIST
88239: LIST
88240: PUSH
88241: EMPTY
88242: LIST
88243: LIST
88244: ST_TO_ADDR
88245: GO 91024
88247: LD_INT 3
88249: DOUBLE
88250: EQUAL
88251: IFTRUE 88255
88253: GO 88331
88255: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
88256: LD_ADDR_VAR 0 1
88260: PUSH
88261: LD_INT 2
88263: PUSH
88264: LD_INT 4
88266: PUSH
88267: LD_INT 5
88269: PUSH
88270: LD_INT 11
88272: PUSH
88273: LD_INT 12
88275: PUSH
88276: LD_INT 15
88278: PUSH
88279: LD_INT 16
88281: PUSH
88282: LD_INT 22
88284: PUSH
88285: LD_INT 26
88287: PUSH
88288: LD_INT 36
88290: PUSH
88291: EMPTY
88292: LIST
88293: LIST
88294: LIST
88295: LIST
88296: LIST
88297: LIST
88298: LIST
88299: LIST
88300: LIST
88301: LIST
88302: PUSH
88303: LD_INT 101
88305: PUSH
88306: LD_INT 102
88308: PUSH
88309: LD_INT 105
88311: PUSH
88312: LD_INT 106
88314: PUSH
88315: LD_INT 108
88317: PUSH
88318: EMPTY
88319: LIST
88320: LIST
88321: LIST
88322: LIST
88323: LIST
88324: PUSH
88325: EMPTY
88326: LIST
88327: LIST
88328: ST_TO_ADDR
88329: GO 91024
88331: LD_INT 4
88333: DOUBLE
88334: EQUAL
88335: IFTRUE 88339
88337: GO 88423
88339: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
88340: LD_ADDR_VAR 0 1
88344: PUSH
88345: LD_INT 2
88347: PUSH
88348: LD_INT 4
88350: PUSH
88351: LD_INT 5
88353: PUSH
88354: LD_INT 8
88356: PUSH
88357: LD_INT 11
88359: PUSH
88360: LD_INT 12
88362: PUSH
88363: LD_INT 15
88365: PUSH
88366: LD_INT 16
88368: PUSH
88369: LD_INT 22
88371: PUSH
88372: LD_INT 23
88374: PUSH
88375: LD_INT 26
88377: PUSH
88378: LD_INT 36
88380: PUSH
88381: EMPTY
88382: LIST
88383: LIST
88384: LIST
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: LIST
88394: PUSH
88395: LD_INT 101
88397: PUSH
88398: LD_INT 102
88400: PUSH
88401: LD_INT 105
88403: PUSH
88404: LD_INT 106
88406: PUSH
88407: LD_INT 108
88409: PUSH
88410: EMPTY
88411: LIST
88412: LIST
88413: LIST
88414: LIST
88415: LIST
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: ST_TO_ADDR
88421: GO 91024
88423: LD_INT 5
88425: DOUBLE
88426: EQUAL
88427: IFTRUE 88431
88429: GO 88531
88431: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
88432: LD_ADDR_VAR 0 1
88436: PUSH
88437: LD_INT 2
88439: PUSH
88440: LD_INT 4
88442: PUSH
88443: LD_INT 5
88445: PUSH
88446: LD_INT 6
88448: PUSH
88449: LD_INT 8
88451: PUSH
88452: LD_INT 11
88454: PUSH
88455: LD_INT 12
88457: PUSH
88458: LD_INT 15
88460: PUSH
88461: LD_INT 16
88463: PUSH
88464: LD_INT 22
88466: PUSH
88467: LD_INT 23
88469: PUSH
88470: LD_INT 25
88472: PUSH
88473: LD_INT 26
88475: PUSH
88476: LD_INT 36
88478: PUSH
88479: EMPTY
88480: LIST
88481: LIST
88482: LIST
88483: LIST
88484: LIST
88485: LIST
88486: LIST
88487: LIST
88488: LIST
88489: LIST
88490: LIST
88491: LIST
88492: LIST
88493: LIST
88494: PUSH
88495: LD_INT 101
88497: PUSH
88498: LD_INT 102
88500: PUSH
88501: LD_INT 105
88503: PUSH
88504: LD_INT 106
88506: PUSH
88507: LD_INT 108
88509: PUSH
88510: LD_INT 109
88512: PUSH
88513: LD_INT 112
88515: PUSH
88516: EMPTY
88517: LIST
88518: LIST
88519: LIST
88520: LIST
88521: LIST
88522: LIST
88523: LIST
88524: PUSH
88525: EMPTY
88526: LIST
88527: LIST
88528: ST_TO_ADDR
88529: GO 91024
88531: LD_INT 6
88533: DOUBLE
88534: EQUAL
88535: IFTRUE 88539
88537: GO 88659
88539: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
88540: LD_ADDR_VAR 0 1
88544: PUSH
88545: LD_INT 2
88547: PUSH
88548: LD_INT 4
88550: PUSH
88551: LD_INT 5
88553: PUSH
88554: LD_INT 6
88556: PUSH
88557: LD_INT 8
88559: PUSH
88560: LD_INT 11
88562: PUSH
88563: LD_INT 12
88565: PUSH
88566: LD_INT 15
88568: PUSH
88569: LD_INT 16
88571: PUSH
88572: LD_INT 20
88574: PUSH
88575: LD_INT 21
88577: PUSH
88578: LD_INT 22
88580: PUSH
88581: LD_INT 23
88583: PUSH
88584: LD_INT 25
88586: PUSH
88587: LD_INT 26
88589: PUSH
88590: LD_INT 30
88592: PUSH
88593: LD_INT 31
88595: PUSH
88596: LD_INT 32
88598: PUSH
88599: LD_INT 36
88601: PUSH
88602: EMPTY
88603: LIST
88604: LIST
88605: LIST
88606: LIST
88607: LIST
88608: LIST
88609: LIST
88610: LIST
88611: LIST
88612: LIST
88613: LIST
88614: LIST
88615: LIST
88616: LIST
88617: LIST
88618: LIST
88619: LIST
88620: LIST
88621: LIST
88622: PUSH
88623: LD_INT 101
88625: PUSH
88626: LD_INT 102
88628: PUSH
88629: LD_INT 105
88631: PUSH
88632: LD_INT 106
88634: PUSH
88635: LD_INT 108
88637: PUSH
88638: LD_INT 109
88640: PUSH
88641: LD_INT 112
88643: PUSH
88644: EMPTY
88645: LIST
88646: LIST
88647: LIST
88648: LIST
88649: LIST
88650: LIST
88651: LIST
88652: PUSH
88653: EMPTY
88654: LIST
88655: LIST
88656: ST_TO_ADDR
88657: GO 91024
88659: LD_INT 7
88661: DOUBLE
88662: EQUAL
88663: IFTRUE 88667
88665: GO 88767
88667: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
88668: LD_ADDR_VAR 0 1
88672: PUSH
88673: LD_INT 2
88675: PUSH
88676: LD_INT 4
88678: PUSH
88679: LD_INT 5
88681: PUSH
88682: LD_INT 7
88684: PUSH
88685: LD_INT 11
88687: PUSH
88688: LD_INT 12
88690: PUSH
88691: LD_INT 15
88693: PUSH
88694: LD_INT 16
88696: PUSH
88697: LD_INT 20
88699: PUSH
88700: LD_INT 21
88702: PUSH
88703: LD_INT 22
88705: PUSH
88706: LD_INT 23
88708: PUSH
88709: LD_INT 25
88711: PUSH
88712: LD_INT 26
88714: PUSH
88715: EMPTY
88716: LIST
88717: LIST
88718: LIST
88719: LIST
88720: LIST
88721: LIST
88722: LIST
88723: LIST
88724: LIST
88725: LIST
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: PUSH
88731: LD_INT 101
88733: PUSH
88734: LD_INT 102
88736: PUSH
88737: LD_INT 103
88739: PUSH
88740: LD_INT 105
88742: PUSH
88743: LD_INT 106
88745: PUSH
88746: LD_INT 108
88748: PUSH
88749: LD_INT 112
88751: PUSH
88752: EMPTY
88753: LIST
88754: LIST
88755: LIST
88756: LIST
88757: LIST
88758: LIST
88759: LIST
88760: PUSH
88761: EMPTY
88762: LIST
88763: LIST
88764: ST_TO_ADDR
88765: GO 91024
88767: LD_INT 8
88769: DOUBLE
88770: EQUAL
88771: IFTRUE 88775
88773: GO 88903
88775: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
88776: LD_ADDR_VAR 0 1
88780: PUSH
88781: LD_INT 2
88783: PUSH
88784: LD_INT 4
88786: PUSH
88787: LD_INT 5
88789: PUSH
88790: LD_INT 6
88792: PUSH
88793: LD_INT 7
88795: PUSH
88796: LD_INT 8
88798: PUSH
88799: LD_INT 11
88801: PUSH
88802: LD_INT 12
88804: PUSH
88805: LD_INT 15
88807: PUSH
88808: LD_INT 16
88810: PUSH
88811: LD_INT 20
88813: PUSH
88814: LD_INT 21
88816: PUSH
88817: LD_INT 22
88819: PUSH
88820: LD_INT 23
88822: PUSH
88823: LD_INT 25
88825: PUSH
88826: LD_INT 26
88828: PUSH
88829: LD_INT 30
88831: PUSH
88832: LD_INT 31
88834: PUSH
88835: LD_INT 32
88837: PUSH
88838: LD_INT 36
88840: PUSH
88841: EMPTY
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: LIST
88861: LIST
88862: PUSH
88863: LD_INT 101
88865: PUSH
88866: LD_INT 102
88868: PUSH
88869: LD_INT 103
88871: PUSH
88872: LD_INT 105
88874: PUSH
88875: LD_INT 106
88877: PUSH
88878: LD_INT 108
88880: PUSH
88881: LD_INT 109
88883: PUSH
88884: LD_INT 112
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: LIST
88891: LIST
88892: LIST
88893: LIST
88894: LIST
88895: LIST
88896: PUSH
88897: EMPTY
88898: LIST
88899: LIST
88900: ST_TO_ADDR
88901: GO 91024
88903: LD_INT 9
88905: DOUBLE
88906: EQUAL
88907: IFTRUE 88911
88909: GO 89047
88911: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
88912: LD_ADDR_VAR 0 1
88916: PUSH
88917: LD_INT 2
88919: PUSH
88920: LD_INT 4
88922: PUSH
88923: LD_INT 5
88925: PUSH
88926: LD_INT 6
88928: PUSH
88929: LD_INT 7
88931: PUSH
88932: LD_INT 8
88934: PUSH
88935: LD_INT 11
88937: PUSH
88938: LD_INT 12
88940: PUSH
88941: LD_INT 15
88943: PUSH
88944: LD_INT 16
88946: PUSH
88947: LD_INT 20
88949: PUSH
88950: LD_INT 21
88952: PUSH
88953: LD_INT 22
88955: PUSH
88956: LD_INT 23
88958: PUSH
88959: LD_INT 25
88961: PUSH
88962: LD_INT 26
88964: PUSH
88965: LD_INT 28
88967: PUSH
88968: LD_INT 30
88970: PUSH
88971: LD_INT 31
88973: PUSH
88974: LD_INT 32
88976: PUSH
88977: LD_INT 36
88979: PUSH
88980: EMPTY
88981: LIST
88982: LIST
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: PUSH
89003: LD_INT 101
89005: PUSH
89006: LD_INT 102
89008: PUSH
89009: LD_INT 103
89011: PUSH
89012: LD_INT 105
89014: PUSH
89015: LD_INT 106
89017: PUSH
89018: LD_INT 108
89020: PUSH
89021: LD_INT 109
89023: PUSH
89024: LD_INT 112
89026: PUSH
89027: LD_INT 114
89029: PUSH
89030: EMPTY
89031: LIST
89032: LIST
89033: LIST
89034: LIST
89035: LIST
89036: LIST
89037: LIST
89038: LIST
89039: LIST
89040: PUSH
89041: EMPTY
89042: LIST
89043: LIST
89044: ST_TO_ADDR
89045: GO 91024
89047: LD_INT 10
89049: DOUBLE
89050: EQUAL
89051: IFTRUE 89055
89053: GO 89239
89055: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
89056: LD_ADDR_VAR 0 1
89060: PUSH
89061: LD_INT 2
89063: PUSH
89064: LD_INT 4
89066: PUSH
89067: LD_INT 5
89069: PUSH
89070: LD_INT 6
89072: PUSH
89073: LD_INT 7
89075: PUSH
89076: LD_INT 8
89078: PUSH
89079: LD_INT 9
89081: PUSH
89082: LD_INT 10
89084: PUSH
89085: LD_INT 11
89087: PUSH
89088: LD_INT 12
89090: PUSH
89091: LD_INT 13
89093: PUSH
89094: LD_INT 14
89096: PUSH
89097: LD_INT 15
89099: PUSH
89100: LD_INT 16
89102: PUSH
89103: LD_INT 17
89105: PUSH
89106: LD_INT 18
89108: PUSH
89109: LD_INT 19
89111: PUSH
89112: LD_INT 20
89114: PUSH
89115: LD_INT 21
89117: PUSH
89118: LD_INT 22
89120: PUSH
89121: LD_INT 23
89123: PUSH
89124: LD_INT 24
89126: PUSH
89127: LD_INT 25
89129: PUSH
89130: LD_INT 26
89132: PUSH
89133: LD_INT 28
89135: PUSH
89136: LD_INT 30
89138: PUSH
89139: LD_INT 31
89141: PUSH
89142: LD_INT 32
89144: PUSH
89145: LD_INT 36
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: LIST
89152: LIST
89153: LIST
89154: LIST
89155: LIST
89156: LIST
89157: LIST
89158: LIST
89159: LIST
89160: LIST
89161: LIST
89162: LIST
89163: LIST
89164: LIST
89165: LIST
89166: LIST
89167: LIST
89168: LIST
89169: LIST
89170: LIST
89171: LIST
89172: LIST
89173: LIST
89174: LIST
89175: LIST
89176: LIST
89177: LIST
89178: PUSH
89179: LD_INT 101
89181: PUSH
89182: LD_INT 102
89184: PUSH
89185: LD_INT 103
89187: PUSH
89188: LD_INT 104
89190: PUSH
89191: LD_INT 105
89193: PUSH
89194: LD_INT 106
89196: PUSH
89197: LD_INT 107
89199: PUSH
89200: LD_INT 108
89202: PUSH
89203: LD_INT 109
89205: PUSH
89206: LD_INT 110
89208: PUSH
89209: LD_INT 111
89211: PUSH
89212: LD_INT 112
89214: PUSH
89215: LD_INT 114
89217: PUSH
89218: EMPTY
89219: LIST
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: LIST
89226: LIST
89227: LIST
89228: LIST
89229: LIST
89230: LIST
89231: LIST
89232: PUSH
89233: EMPTY
89234: LIST
89235: LIST
89236: ST_TO_ADDR
89237: GO 91024
89239: LD_INT 11
89241: DOUBLE
89242: EQUAL
89243: IFTRUE 89247
89245: GO 89439
89247: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
89248: LD_ADDR_VAR 0 1
89252: PUSH
89253: LD_INT 2
89255: PUSH
89256: LD_INT 3
89258: PUSH
89259: LD_INT 4
89261: PUSH
89262: LD_INT 5
89264: PUSH
89265: LD_INT 6
89267: PUSH
89268: LD_INT 7
89270: PUSH
89271: LD_INT 8
89273: PUSH
89274: LD_INT 9
89276: PUSH
89277: LD_INT 10
89279: PUSH
89280: LD_INT 11
89282: PUSH
89283: LD_INT 12
89285: PUSH
89286: LD_INT 13
89288: PUSH
89289: LD_INT 14
89291: PUSH
89292: LD_INT 15
89294: PUSH
89295: LD_INT 16
89297: PUSH
89298: LD_INT 17
89300: PUSH
89301: LD_INT 18
89303: PUSH
89304: LD_INT 19
89306: PUSH
89307: LD_INT 20
89309: PUSH
89310: LD_INT 21
89312: PUSH
89313: LD_INT 22
89315: PUSH
89316: LD_INT 23
89318: PUSH
89319: LD_INT 24
89321: PUSH
89322: LD_INT 25
89324: PUSH
89325: LD_INT 26
89327: PUSH
89328: LD_INT 28
89330: PUSH
89331: LD_INT 30
89333: PUSH
89334: LD_INT 31
89336: PUSH
89337: LD_INT 32
89339: PUSH
89340: LD_INT 34
89342: PUSH
89343: LD_INT 36
89345: PUSH
89346: EMPTY
89347: LIST
89348: LIST
89349: LIST
89350: LIST
89351: LIST
89352: LIST
89353: LIST
89354: LIST
89355: LIST
89356: LIST
89357: LIST
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: LIST
89369: LIST
89370: LIST
89371: LIST
89372: LIST
89373: LIST
89374: LIST
89375: LIST
89376: LIST
89377: LIST
89378: PUSH
89379: LD_INT 101
89381: PUSH
89382: LD_INT 102
89384: PUSH
89385: LD_INT 103
89387: PUSH
89388: LD_INT 104
89390: PUSH
89391: LD_INT 105
89393: PUSH
89394: LD_INT 106
89396: PUSH
89397: LD_INT 107
89399: PUSH
89400: LD_INT 108
89402: PUSH
89403: LD_INT 109
89405: PUSH
89406: LD_INT 110
89408: PUSH
89409: LD_INT 111
89411: PUSH
89412: LD_INT 112
89414: PUSH
89415: LD_INT 114
89417: PUSH
89418: EMPTY
89419: LIST
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: LIST
89425: LIST
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: LIST
89431: LIST
89432: PUSH
89433: EMPTY
89434: LIST
89435: LIST
89436: ST_TO_ADDR
89437: GO 91024
89439: LD_INT 12
89441: DOUBLE
89442: EQUAL
89443: IFTRUE 89447
89445: GO 89655
89447: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
89448: LD_ADDR_VAR 0 1
89452: PUSH
89453: LD_INT 1
89455: PUSH
89456: LD_INT 2
89458: PUSH
89459: LD_INT 3
89461: PUSH
89462: LD_INT 4
89464: PUSH
89465: LD_INT 5
89467: PUSH
89468: LD_INT 6
89470: PUSH
89471: LD_INT 7
89473: PUSH
89474: LD_INT 8
89476: PUSH
89477: LD_INT 9
89479: PUSH
89480: LD_INT 10
89482: PUSH
89483: LD_INT 11
89485: PUSH
89486: LD_INT 12
89488: PUSH
89489: LD_INT 13
89491: PUSH
89492: LD_INT 14
89494: PUSH
89495: LD_INT 15
89497: PUSH
89498: LD_INT 16
89500: PUSH
89501: LD_INT 17
89503: PUSH
89504: LD_INT 18
89506: PUSH
89507: LD_INT 19
89509: PUSH
89510: LD_INT 20
89512: PUSH
89513: LD_INT 21
89515: PUSH
89516: LD_INT 22
89518: PUSH
89519: LD_INT 23
89521: PUSH
89522: LD_INT 24
89524: PUSH
89525: LD_INT 25
89527: PUSH
89528: LD_INT 26
89530: PUSH
89531: LD_INT 27
89533: PUSH
89534: LD_INT 28
89536: PUSH
89537: LD_INT 30
89539: PUSH
89540: LD_INT 31
89542: PUSH
89543: LD_INT 32
89545: PUSH
89546: LD_INT 33
89548: PUSH
89549: LD_INT 34
89551: PUSH
89552: LD_INT 36
89554: PUSH
89555: EMPTY
89556: LIST
89557: LIST
89558: LIST
89559: LIST
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: LIST
89565: LIST
89566: LIST
89567: LIST
89568: LIST
89569: LIST
89570: LIST
89571: LIST
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: LIST
89584: LIST
89585: LIST
89586: LIST
89587: LIST
89588: LIST
89589: LIST
89590: PUSH
89591: LD_INT 101
89593: PUSH
89594: LD_INT 102
89596: PUSH
89597: LD_INT 103
89599: PUSH
89600: LD_INT 104
89602: PUSH
89603: LD_INT 105
89605: PUSH
89606: LD_INT 106
89608: PUSH
89609: LD_INT 107
89611: PUSH
89612: LD_INT 108
89614: PUSH
89615: LD_INT 109
89617: PUSH
89618: LD_INT 110
89620: PUSH
89621: LD_INT 111
89623: PUSH
89624: LD_INT 112
89626: PUSH
89627: LD_INT 113
89629: PUSH
89630: LD_INT 114
89632: PUSH
89633: EMPTY
89634: LIST
89635: LIST
89636: LIST
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: LIST
89645: LIST
89646: LIST
89647: LIST
89648: PUSH
89649: EMPTY
89650: LIST
89651: LIST
89652: ST_TO_ADDR
89653: GO 91024
89655: LD_INT 13
89657: DOUBLE
89658: EQUAL
89659: IFTRUE 89663
89661: GO 89859
89663: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
89664: LD_ADDR_VAR 0 1
89668: PUSH
89669: LD_INT 1
89671: PUSH
89672: LD_INT 2
89674: PUSH
89675: LD_INT 3
89677: PUSH
89678: LD_INT 4
89680: PUSH
89681: LD_INT 5
89683: PUSH
89684: LD_INT 8
89686: PUSH
89687: LD_INT 9
89689: PUSH
89690: LD_INT 10
89692: PUSH
89693: LD_INT 11
89695: PUSH
89696: LD_INT 12
89698: PUSH
89699: LD_INT 14
89701: PUSH
89702: LD_INT 15
89704: PUSH
89705: LD_INT 16
89707: PUSH
89708: LD_INT 17
89710: PUSH
89711: LD_INT 18
89713: PUSH
89714: LD_INT 19
89716: PUSH
89717: LD_INT 20
89719: PUSH
89720: LD_INT 21
89722: PUSH
89723: LD_INT 22
89725: PUSH
89726: LD_INT 23
89728: PUSH
89729: LD_INT 24
89731: PUSH
89732: LD_INT 25
89734: PUSH
89735: LD_INT 26
89737: PUSH
89738: LD_INT 27
89740: PUSH
89741: LD_INT 28
89743: PUSH
89744: LD_INT 30
89746: PUSH
89747: LD_INT 31
89749: PUSH
89750: LD_INT 32
89752: PUSH
89753: LD_INT 33
89755: PUSH
89756: LD_INT 34
89758: PUSH
89759: LD_INT 36
89761: PUSH
89762: EMPTY
89763: LIST
89764: LIST
89765: LIST
89766: LIST
89767: LIST
89768: LIST
89769: LIST
89770: LIST
89771: LIST
89772: LIST
89773: LIST
89774: LIST
89775: LIST
89776: LIST
89777: LIST
89778: LIST
89779: LIST
89780: LIST
89781: LIST
89782: LIST
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: PUSH
89795: LD_INT 101
89797: PUSH
89798: LD_INT 102
89800: PUSH
89801: LD_INT 103
89803: PUSH
89804: LD_INT 104
89806: PUSH
89807: LD_INT 105
89809: PUSH
89810: LD_INT 106
89812: PUSH
89813: LD_INT 107
89815: PUSH
89816: LD_INT 108
89818: PUSH
89819: LD_INT 109
89821: PUSH
89822: LD_INT 110
89824: PUSH
89825: LD_INT 111
89827: PUSH
89828: LD_INT 112
89830: PUSH
89831: LD_INT 113
89833: PUSH
89834: LD_INT 114
89836: PUSH
89837: EMPTY
89838: LIST
89839: LIST
89840: LIST
89841: LIST
89842: LIST
89843: LIST
89844: LIST
89845: LIST
89846: LIST
89847: LIST
89848: LIST
89849: LIST
89850: LIST
89851: LIST
89852: PUSH
89853: EMPTY
89854: LIST
89855: LIST
89856: ST_TO_ADDR
89857: GO 91024
89859: LD_INT 14
89861: DOUBLE
89862: EQUAL
89863: IFTRUE 89867
89865: GO 90079
89867: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
89868: LD_ADDR_VAR 0 1
89872: PUSH
89873: LD_INT 1
89875: PUSH
89876: LD_INT 2
89878: PUSH
89879: LD_INT 3
89881: PUSH
89882: LD_INT 4
89884: PUSH
89885: LD_INT 5
89887: PUSH
89888: LD_INT 6
89890: PUSH
89891: LD_INT 7
89893: PUSH
89894: LD_INT 8
89896: PUSH
89897: LD_INT 9
89899: PUSH
89900: LD_INT 10
89902: PUSH
89903: LD_INT 11
89905: PUSH
89906: LD_INT 12
89908: PUSH
89909: LD_INT 13
89911: PUSH
89912: LD_INT 14
89914: PUSH
89915: LD_INT 15
89917: PUSH
89918: LD_INT 16
89920: PUSH
89921: LD_INT 17
89923: PUSH
89924: LD_INT 18
89926: PUSH
89927: LD_INT 19
89929: PUSH
89930: LD_INT 20
89932: PUSH
89933: LD_INT 21
89935: PUSH
89936: LD_INT 22
89938: PUSH
89939: LD_INT 23
89941: PUSH
89942: LD_INT 24
89944: PUSH
89945: LD_INT 25
89947: PUSH
89948: LD_INT 26
89950: PUSH
89951: LD_INT 27
89953: PUSH
89954: LD_INT 28
89956: PUSH
89957: LD_INT 29
89959: PUSH
89960: LD_INT 30
89962: PUSH
89963: LD_INT 31
89965: PUSH
89966: LD_INT 32
89968: PUSH
89969: LD_INT 33
89971: PUSH
89972: LD_INT 34
89974: PUSH
89975: LD_INT 36
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: LIST
89987: LIST
89988: LIST
89989: LIST
89990: LIST
89991: LIST
89992: LIST
89993: LIST
89994: LIST
89995: LIST
89996: LIST
89997: LIST
89998: LIST
89999: LIST
90000: LIST
90001: LIST
90002: LIST
90003: LIST
90004: LIST
90005: LIST
90006: LIST
90007: LIST
90008: LIST
90009: LIST
90010: LIST
90011: LIST
90012: LIST
90013: LIST
90014: PUSH
90015: LD_INT 101
90017: PUSH
90018: LD_INT 102
90020: PUSH
90021: LD_INT 103
90023: PUSH
90024: LD_INT 104
90026: PUSH
90027: LD_INT 105
90029: PUSH
90030: LD_INT 106
90032: PUSH
90033: LD_INT 107
90035: PUSH
90036: LD_INT 108
90038: PUSH
90039: LD_INT 109
90041: PUSH
90042: LD_INT 110
90044: PUSH
90045: LD_INT 111
90047: PUSH
90048: LD_INT 112
90050: PUSH
90051: LD_INT 113
90053: PUSH
90054: LD_INT 114
90056: PUSH
90057: EMPTY
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: LIST
90065: LIST
90066: LIST
90067: LIST
90068: LIST
90069: LIST
90070: LIST
90071: LIST
90072: PUSH
90073: EMPTY
90074: LIST
90075: LIST
90076: ST_TO_ADDR
90077: GO 91024
90079: LD_INT 15
90081: DOUBLE
90082: EQUAL
90083: IFTRUE 90087
90085: GO 90299
90087: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
90088: LD_ADDR_VAR 0 1
90092: PUSH
90093: LD_INT 1
90095: PUSH
90096: LD_INT 2
90098: PUSH
90099: LD_INT 3
90101: PUSH
90102: LD_INT 4
90104: PUSH
90105: LD_INT 5
90107: PUSH
90108: LD_INT 6
90110: PUSH
90111: LD_INT 7
90113: PUSH
90114: LD_INT 8
90116: PUSH
90117: LD_INT 9
90119: PUSH
90120: LD_INT 10
90122: PUSH
90123: LD_INT 11
90125: PUSH
90126: LD_INT 12
90128: PUSH
90129: LD_INT 13
90131: PUSH
90132: LD_INT 14
90134: PUSH
90135: LD_INT 15
90137: PUSH
90138: LD_INT 16
90140: PUSH
90141: LD_INT 17
90143: PUSH
90144: LD_INT 18
90146: PUSH
90147: LD_INT 19
90149: PUSH
90150: LD_INT 20
90152: PUSH
90153: LD_INT 21
90155: PUSH
90156: LD_INT 22
90158: PUSH
90159: LD_INT 23
90161: PUSH
90162: LD_INT 24
90164: PUSH
90165: LD_INT 25
90167: PUSH
90168: LD_INT 26
90170: PUSH
90171: LD_INT 27
90173: PUSH
90174: LD_INT 28
90176: PUSH
90177: LD_INT 29
90179: PUSH
90180: LD_INT 30
90182: PUSH
90183: LD_INT 31
90185: PUSH
90186: LD_INT 32
90188: PUSH
90189: LD_INT 33
90191: PUSH
90192: LD_INT 34
90194: PUSH
90195: LD_INT 36
90197: PUSH
90198: EMPTY
90199: LIST
90200: LIST
90201: LIST
90202: LIST
90203: LIST
90204: LIST
90205: LIST
90206: LIST
90207: LIST
90208: LIST
90209: LIST
90210: LIST
90211: LIST
90212: LIST
90213: LIST
90214: LIST
90215: LIST
90216: LIST
90217: LIST
90218: LIST
90219: LIST
90220: LIST
90221: LIST
90222: LIST
90223: LIST
90224: LIST
90225: LIST
90226: LIST
90227: LIST
90228: LIST
90229: LIST
90230: LIST
90231: LIST
90232: LIST
90233: LIST
90234: PUSH
90235: LD_INT 101
90237: PUSH
90238: LD_INT 102
90240: PUSH
90241: LD_INT 103
90243: PUSH
90244: LD_INT 104
90246: PUSH
90247: LD_INT 105
90249: PUSH
90250: LD_INT 106
90252: PUSH
90253: LD_INT 107
90255: PUSH
90256: LD_INT 108
90258: PUSH
90259: LD_INT 109
90261: PUSH
90262: LD_INT 110
90264: PUSH
90265: LD_INT 111
90267: PUSH
90268: LD_INT 112
90270: PUSH
90271: LD_INT 113
90273: PUSH
90274: LD_INT 114
90276: PUSH
90277: EMPTY
90278: LIST
90279: LIST
90280: LIST
90281: LIST
90282: LIST
90283: LIST
90284: LIST
90285: LIST
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: LIST
90291: LIST
90292: PUSH
90293: EMPTY
90294: LIST
90295: LIST
90296: ST_TO_ADDR
90297: GO 91024
90299: LD_INT 16
90301: DOUBLE
90302: EQUAL
90303: IFTRUE 90307
90305: GO 90431
90307: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
90308: LD_ADDR_VAR 0 1
90312: PUSH
90313: LD_INT 2
90315: PUSH
90316: LD_INT 4
90318: PUSH
90319: LD_INT 5
90321: PUSH
90322: LD_INT 7
90324: PUSH
90325: LD_INT 11
90327: PUSH
90328: LD_INT 12
90330: PUSH
90331: LD_INT 15
90333: PUSH
90334: LD_INT 16
90336: PUSH
90337: LD_INT 20
90339: PUSH
90340: LD_INT 21
90342: PUSH
90343: LD_INT 22
90345: PUSH
90346: LD_INT 23
90348: PUSH
90349: LD_INT 25
90351: PUSH
90352: LD_INT 26
90354: PUSH
90355: LD_INT 30
90357: PUSH
90358: LD_INT 31
90360: PUSH
90361: LD_INT 32
90363: PUSH
90364: LD_INT 33
90366: PUSH
90367: LD_INT 34
90369: PUSH
90370: EMPTY
90371: LIST
90372: LIST
90373: LIST
90374: LIST
90375: LIST
90376: LIST
90377: LIST
90378: LIST
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: LIST
90385: LIST
90386: LIST
90387: LIST
90388: LIST
90389: LIST
90390: PUSH
90391: LD_INT 101
90393: PUSH
90394: LD_INT 102
90396: PUSH
90397: LD_INT 103
90399: PUSH
90400: LD_INT 106
90402: PUSH
90403: LD_INT 108
90405: PUSH
90406: LD_INT 112
90408: PUSH
90409: LD_INT 113
90411: PUSH
90412: LD_INT 114
90414: PUSH
90415: EMPTY
90416: LIST
90417: LIST
90418: LIST
90419: LIST
90420: LIST
90421: LIST
90422: LIST
90423: LIST
90424: PUSH
90425: EMPTY
90426: LIST
90427: LIST
90428: ST_TO_ADDR
90429: GO 91024
90431: LD_INT 17
90433: DOUBLE
90434: EQUAL
90435: IFTRUE 90439
90437: GO 90651
90439: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
90440: LD_ADDR_VAR 0 1
90444: PUSH
90445: LD_INT 1
90447: PUSH
90448: LD_INT 2
90450: PUSH
90451: LD_INT 3
90453: PUSH
90454: LD_INT 4
90456: PUSH
90457: LD_INT 5
90459: PUSH
90460: LD_INT 6
90462: PUSH
90463: LD_INT 7
90465: PUSH
90466: LD_INT 8
90468: PUSH
90469: LD_INT 9
90471: PUSH
90472: LD_INT 10
90474: PUSH
90475: LD_INT 11
90477: PUSH
90478: LD_INT 12
90480: PUSH
90481: LD_INT 13
90483: PUSH
90484: LD_INT 14
90486: PUSH
90487: LD_INT 15
90489: PUSH
90490: LD_INT 16
90492: PUSH
90493: LD_INT 17
90495: PUSH
90496: LD_INT 18
90498: PUSH
90499: LD_INT 19
90501: PUSH
90502: LD_INT 20
90504: PUSH
90505: LD_INT 21
90507: PUSH
90508: LD_INT 22
90510: PUSH
90511: LD_INT 23
90513: PUSH
90514: LD_INT 24
90516: PUSH
90517: LD_INT 25
90519: PUSH
90520: LD_INT 26
90522: PUSH
90523: LD_INT 27
90525: PUSH
90526: LD_INT 28
90528: PUSH
90529: LD_INT 29
90531: PUSH
90532: LD_INT 30
90534: PUSH
90535: LD_INT 31
90537: PUSH
90538: LD_INT 32
90540: PUSH
90541: LD_INT 33
90543: PUSH
90544: LD_INT 34
90546: PUSH
90547: LD_INT 36
90549: PUSH
90550: EMPTY
90551: LIST
90552: LIST
90553: LIST
90554: LIST
90555: LIST
90556: LIST
90557: LIST
90558: LIST
90559: LIST
90560: LIST
90561: LIST
90562: LIST
90563: LIST
90564: LIST
90565: LIST
90566: LIST
90567: LIST
90568: LIST
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: PUSH
90587: LD_INT 101
90589: PUSH
90590: LD_INT 102
90592: PUSH
90593: LD_INT 103
90595: PUSH
90596: LD_INT 104
90598: PUSH
90599: LD_INT 105
90601: PUSH
90602: LD_INT 106
90604: PUSH
90605: LD_INT 107
90607: PUSH
90608: LD_INT 108
90610: PUSH
90611: LD_INT 109
90613: PUSH
90614: LD_INT 110
90616: PUSH
90617: LD_INT 111
90619: PUSH
90620: LD_INT 112
90622: PUSH
90623: LD_INT 113
90625: PUSH
90626: LD_INT 114
90628: PUSH
90629: EMPTY
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: PUSH
90645: EMPTY
90646: LIST
90647: LIST
90648: ST_TO_ADDR
90649: GO 91024
90651: LD_INT 18
90653: DOUBLE
90654: EQUAL
90655: IFTRUE 90659
90657: GO 90795
90659: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
90660: LD_ADDR_VAR 0 1
90664: PUSH
90665: LD_INT 2
90667: PUSH
90668: LD_INT 4
90670: PUSH
90671: LD_INT 5
90673: PUSH
90674: LD_INT 7
90676: PUSH
90677: LD_INT 11
90679: PUSH
90680: LD_INT 12
90682: PUSH
90683: LD_INT 15
90685: PUSH
90686: LD_INT 16
90688: PUSH
90689: LD_INT 20
90691: PUSH
90692: LD_INT 21
90694: PUSH
90695: LD_INT 22
90697: PUSH
90698: LD_INT 23
90700: PUSH
90701: LD_INT 25
90703: PUSH
90704: LD_INT 26
90706: PUSH
90707: LD_INT 30
90709: PUSH
90710: LD_INT 31
90712: PUSH
90713: LD_INT 32
90715: PUSH
90716: LD_INT 33
90718: PUSH
90719: LD_INT 34
90721: PUSH
90722: LD_INT 35
90724: PUSH
90725: LD_INT 36
90727: PUSH
90728: EMPTY
90729: LIST
90730: LIST
90731: LIST
90732: LIST
90733: LIST
90734: LIST
90735: LIST
90736: LIST
90737: LIST
90738: LIST
90739: LIST
90740: LIST
90741: LIST
90742: LIST
90743: LIST
90744: LIST
90745: LIST
90746: LIST
90747: LIST
90748: LIST
90749: LIST
90750: PUSH
90751: LD_INT 101
90753: PUSH
90754: LD_INT 102
90756: PUSH
90757: LD_INT 103
90759: PUSH
90760: LD_INT 106
90762: PUSH
90763: LD_INT 108
90765: PUSH
90766: LD_INT 112
90768: PUSH
90769: LD_INT 113
90771: PUSH
90772: LD_INT 114
90774: PUSH
90775: LD_INT 115
90777: PUSH
90778: EMPTY
90779: LIST
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: PUSH
90789: EMPTY
90790: LIST
90791: LIST
90792: ST_TO_ADDR
90793: GO 91024
90795: LD_INT 19
90797: DOUBLE
90798: EQUAL
90799: IFTRUE 90803
90801: GO 91023
90803: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
90804: LD_ADDR_VAR 0 1
90808: PUSH
90809: LD_INT 1
90811: PUSH
90812: LD_INT 2
90814: PUSH
90815: LD_INT 3
90817: PUSH
90818: LD_INT 4
90820: PUSH
90821: LD_INT 5
90823: PUSH
90824: LD_INT 6
90826: PUSH
90827: LD_INT 7
90829: PUSH
90830: LD_INT 8
90832: PUSH
90833: LD_INT 9
90835: PUSH
90836: LD_INT 10
90838: PUSH
90839: LD_INT 11
90841: PUSH
90842: LD_INT 12
90844: PUSH
90845: LD_INT 13
90847: PUSH
90848: LD_INT 14
90850: PUSH
90851: LD_INT 15
90853: PUSH
90854: LD_INT 16
90856: PUSH
90857: LD_INT 17
90859: PUSH
90860: LD_INT 18
90862: PUSH
90863: LD_INT 19
90865: PUSH
90866: LD_INT 20
90868: PUSH
90869: LD_INT 21
90871: PUSH
90872: LD_INT 22
90874: PUSH
90875: LD_INT 23
90877: PUSH
90878: LD_INT 24
90880: PUSH
90881: LD_INT 25
90883: PUSH
90884: LD_INT 26
90886: PUSH
90887: LD_INT 27
90889: PUSH
90890: LD_INT 28
90892: PUSH
90893: LD_INT 29
90895: PUSH
90896: LD_INT 30
90898: PUSH
90899: LD_INT 31
90901: PUSH
90902: LD_INT 32
90904: PUSH
90905: LD_INT 33
90907: PUSH
90908: LD_INT 34
90910: PUSH
90911: LD_INT 35
90913: PUSH
90914: LD_INT 36
90916: PUSH
90917: EMPTY
90918: LIST
90919: LIST
90920: LIST
90921: LIST
90922: LIST
90923: LIST
90924: LIST
90925: LIST
90926: LIST
90927: LIST
90928: LIST
90929: LIST
90930: LIST
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: LIST
90936: LIST
90937: LIST
90938: LIST
90939: LIST
90940: LIST
90941: LIST
90942: LIST
90943: LIST
90944: LIST
90945: LIST
90946: LIST
90947: LIST
90948: LIST
90949: LIST
90950: LIST
90951: LIST
90952: LIST
90953: LIST
90954: PUSH
90955: LD_INT 101
90957: PUSH
90958: LD_INT 102
90960: PUSH
90961: LD_INT 103
90963: PUSH
90964: LD_INT 104
90966: PUSH
90967: LD_INT 105
90969: PUSH
90970: LD_INT 106
90972: PUSH
90973: LD_INT 107
90975: PUSH
90976: LD_INT 108
90978: PUSH
90979: LD_INT 109
90981: PUSH
90982: LD_INT 110
90984: PUSH
90985: LD_INT 111
90987: PUSH
90988: LD_INT 112
90990: PUSH
90991: LD_INT 113
90993: PUSH
90994: LD_INT 114
90996: PUSH
90997: LD_INT 115
90999: PUSH
91000: EMPTY
91001: LIST
91002: LIST
91003: LIST
91004: LIST
91005: LIST
91006: LIST
91007: LIST
91008: LIST
91009: LIST
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: PUSH
91017: EMPTY
91018: LIST
91019: LIST
91020: ST_TO_ADDR
91021: GO 91024
91023: POP
// end else
91024: GO 91061
// if campaign_id = 5 then
91026: LD_OWVAR 69
91030: PUSH
91031: LD_INT 5
91033: EQUAL
91034: IFFALSE 91061
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
91036: LD_ADDR_VAR 0 1
91040: PUSH
91041: LD_INT 1
91043: PUSH
91044: LD_INT 2
91046: PUSH
91047: EMPTY
91048: LIST
91049: LIST
91050: PUSH
91051: LD_INT 100
91053: PUSH
91054: EMPTY
91055: LIST
91056: PUSH
91057: EMPTY
91058: LIST
91059: LIST
91060: ST_TO_ADDR
// end ; if result then
91061: LD_VAR 0 1
91065: IFFALSE 91354
// begin normal :=  ;
91067: LD_ADDR_VAR 0 3
91071: PUSH
91072: LD_STRING 
91074: ST_TO_ADDR
// hardcore :=  ;
91075: LD_ADDR_VAR 0 4
91079: PUSH
91080: LD_STRING 
91082: ST_TO_ADDR
// for i = 1 to normalCounter do
91083: LD_ADDR_VAR 0 5
91087: PUSH
91088: DOUBLE
91089: LD_INT 1
91091: DEC
91092: ST_TO_ADDR
91093: LD_EXP 108
91097: PUSH
91098: FOR_TO
91099: IFFALSE 91200
// begin tmp := 0 ;
91101: LD_ADDR_VAR 0 2
91105: PUSH
91106: LD_STRING 0
91108: ST_TO_ADDR
// if result [ 1 ] then
91109: LD_VAR 0 1
91113: PUSH
91114: LD_INT 1
91116: ARRAY
91117: IFFALSE 91182
// if result [ 1 ] [ 1 ] = i then
91119: LD_VAR 0 1
91123: PUSH
91124: LD_INT 1
91126: ARRAY
91127: PUSH
91128: LD_INT 1
91130: ARRAY
91131: PUSH
91132: LD_VAR 0 5
91136: EQUAL
91137: IFFALSE 91182
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
91139: LD_ADDR_VAR 0 1
91143: PUSH
91144: LD_VAR 0 1
91148: PPUSH
91149: LD_INT 1
91151: PPUSH
91152: LD_VAR 0 1
91156: PUSH
91157: LD_INT 1
91159: ARRAY
91160: PPUSH
91161: LD_INT 1
91163: PPUSH
91164: CALL_OW 3
91168: PPUSH
91169: CALL_OW 1
91173: ST_TO_ADDR
// tmp := 1 ;
91174: LD_ADDR_VAR 0 2
91178: PUSH
91179: LD_STRING 1
91181: ST_TO_ADDR
// end ; normal := normal & tmp ;
91182: LD_ADDR_VAR 0 3
91186: PUSH
91187: LD_VAR 0 3
91191: PUSH
91192: LD_VAR 0 2
91196: STR
91197: ST_TO_ADDR
// end ;
91198: GO 91098
91200: POP
91201: POP
// for i = 1 to hardcoreCounter do
91202: LD_ADDR_VAR 0 5
91206: PUSH
91207: DOUBLE
91208: LD_INT 1
91210: DEC
91211: ST_TO_ADDR
91212: LD_EXP 109
91216: PUSH
91217: FOR_TO
91218: IFFALSE 91323
// begin tmp := 0 ;
91220: LD_ADDR_VAR 0 2
91224: PUSH
91225: LD_STRING 0
91227: ST_TO_ADDR
// if result [ 2 ] then
91228: LD_VAR 0 1
91232: PUSH
91233: LD_INT 2
91235: ARRAY
91236: IFFALSE 91305
// if result [ 2 ] [ 1 ] = 100 + i then
91238: LD_VAR 0 1
91242: PUSH
91243: LD_INT 2
91245: ARRAY
91246: PUSH
91247: LD_INT 1
91249: ARRAY
91250: PUSH
91251: LD_INT 100
91253: PUSH
91254: LD_VAR 0 5
91258: PLUS
91259: EQUAL
91260: IFFALSE 91305
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
91262: LD_ADDR_VAR 0 1
91266: PUSH
91267: LD_VAR 0 1
91271: PPUSH
91272: LD_INT 2
91274: PPUSH
91275: LD_VAR 0 1
91279: PUSH
91280: LD_INT 2
91282: ARRAY
91283: PPUSH
91284: LD_INT 1
91286: PPUSH
91287: CALL_OW 3
91291: PPUSH
91292: CALL_OW 1
91296: ST_TO_ADDR
// tmp := 1 ;
91297: LD_ADDR_VAR 0 2
91301: PUSH
91302: LD_STRING 1
91304: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
91305: LD_ADDR_VAR 0 4
91309: PUSH
91310: LD_VAR 0 4
91314: PUSH
91315: LD_VAR 0 2
91319: STR
91320: ST_TO_ADDR
// end ;
91321: GO 91217
91323: POP
91324: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
91325: LD_STRING getStreamItemsFromMission("
91327: PUSH
91328: LD_VAR 0 3
91332: STR
91333: PUSH
91334: LD_STRING ","
91336: STR
91337: PUSH
91338: LD_VAR 0 4
91342: STR
91343: PUSH
91344: LD_STRING ")
91346: STR
91347: PPUSH
91348: CALL_OW 559
// end else
91352: GO 91361
// ToLua ( getStreamItemsFromMission("","") ) ;
91354: LD_STRING getStreamItemsFromMission("","")
91356: PPUSH
91357: CALL_OW 559
// end ;
91361: LD_VAR 0 1
91365: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
91366: LD_VAR 0 2
91370: PUSH
91371: LD_INT 100
91373: EQUAL
91374: IFFALSE 92323
// begin if not StreamModeActive then
91376: LD_EXP 107
91380: NOT
91381: IFFALSE 91391
// StreamModeActive := true ;
91383: LD_ADDR_EXP 107
91387: PUSH
91388: LD_INT 1
91390: ST_TO_ADDR
// if p3 = 0 then
91391: LD_VAR 0 3
91395: PUSH
91396: LD_INT 0
91398: EQUAL
91399: IFFALSE 91405
// InitStreamMode ;
91401: CALL 87626 0 0
// if p3 = 1 then
91405: LD_VAR 0 3
91409: PUSH
91410: LD_INT 1
91412: EQUAL
91413: IFFALSE 91423
// sRocket := true ;
91415: LD_ADDR_EXP 112
91419: PUSH
91420: LD_INT 1
91422: ST_TO_ADDR
// if p3 = 2 then
91423: LD_VAR 0 3
91427: PUSH
91428: LD_INT 2
91430: EQUAL
91431: IFFALSE 91441
// sSpeed := true ;
91433: LD_ADDR_EXP 111
91437: PUSH
91438: LD_INT 1
91440: ST_TO_ADDR
// if p3 = 3 then
91441: LD_VAR 0 3
91445: PUSH
91446: LD_INT 3
91448: EQUAL
91449: IFFALSE 91459
// sEngine := true ;
91451: LD_ADDR_EXP 113
91455: PUSH
91456: LD_INT 1
91458: ST_TO_ADDR
// if p3 = 4 then
91459: LD_VAR 0 3
91463: PUSH
91464: LD_INT 4
91466: EQUAL
91467: IFFALSE 91477
// sSpec := true ;
91469: LD_ADDR_EXP 110
91473: PUSH
91474: LD_INT 1
91476: ST_TO_ADDR
// if p3 = 5 then
91477: LD_VAR 0 3
91481: PUSH
91482: LD_INT 5
91484: EQUAL
91485: IFFALSE 91495
// sLevel := true ;
91487: LD_ADDR_EXP 114
91491: PUSH
91492: LD_INT 1
91494: ST_TO_ADDR
// if p3 = 6 then
91495: LD_VAR 0 3
91499: PUSH
91500: LD_INT 6
91502: EQUAL
91503: IFFALSE 91513
// sArmoury := true ;
91505: LD_ADDR_EXP 115
91509: PUSH
91510: LD_INT 1
91512: ST_TO_ADDR
// if p3 = 7 then
91513: LD_VAR 0 3
91517: PUSH
91518: LD_INT 7
91520: EQUAL
91521: IFFALSE 91531
// sRadar := true ;
91523: LD_ADDR_EXP 116
91527: PUSH
91528: LD_INT 1
91530: ST_TO_ADDR
// if p3 = 8 then
91531: LD_VAR 0 3
91535: PUSH
91536: LD_INT 8
91538: EQUAL
91539: IFFALSE 91549
// sBunker := true ;
91541: LD_ADDR_EXP 117
91545: PUSH
91546: LD_INT 1
91548: ST_TO_ADDR
// if p3 = 9 then
91549: LD_VAR 0 3
91553: PUSH
91554: LD_INT 9
91556: EQUAL
91557: IFFALSE 91567
// sHack := true ;
91559: LD_ADDR_EXP 118
91563: PUSH
91564: LD_INT 1
91566: ST_TO_ADDR
// if p3 = 10 then
91567: LD_VAR 0 3
91571: PUSH
91572: LD_INT 10
91574: EQUAL
91575: IFFALSE 91585
// sFire := true ;
91577: LD_ADDR_EXP 119
91581: PUSH
91582: LD_INT 1
91584: ST_TO_ADDR
// if p3 = 11 then
91585: LD_VAR 0 3
91589: PUSH
91590: LD_INT 11
91592: EQUAL
91593: IFFALSE 91603
// sRefresh := true ;
91595: LD_ADDR_EXP 120
91599: PUSH
91600: LD_INT 1
91602: ST_TO_ADDR
// if p3 = 12 then
91603: LD_VAR 0 3
91607: PUSH
91608: LD_INT 12
91610: EQUAL
91611: IFFALSE 91621
// sExp := true ;
91613: LD_ADDR_EXP 121
91617: PUSH
91618: LD_INT 1
91620: ST_TO_ADDR
// if p3 = 13 then
91621: LD_VAR 0 3
91625: PUSH
91626: LD_INT 13
91628: EQUAL
91629: IFFALSE 91639
// sDepot := true ;
91631: LD_ADDR_EXP 122
91635: PUSH
91636: LD_INT 1
91638: ST_TO_ADDR
// if p3 = 14 then
91639: LD_VAR 0 3
91643: PUSH
91644: LD_INT 14
91646: EQUAL
91647: IFFALSE 91657
// sFlag := true ;
91649: LD_ADDR_EXP 123
91653: PUSH
91654: LD_INT 1
91656: ST_TO_ADDR
// if p3 = 15 then
91657: LD_VAR 0 3
91661: PUSH
91662: LD_INT 15
91664: EQUAL
91665: IFFALSE 91675
// sKamikadze := true ;
91667: LD_ADDR_EXP 131
91671: PUSH
91672: LD_INT 1
91674: ST_TO_ADDR
// if p3 = 16 then
91675: LD_VAR 0 3
91679: PUSH
91680: LD_INT 16
91682: EQUAL
91683: IFFALSE 91693
// sTroll := true ;
91685: LD_ADDR_EXP 132
91689: PUSH
91690: LD_INT 1
91692: ST_TO_ADDR
// if p3 = 17 then
91693: LD_VAR 0 3
91697: PUSH
91698: LD_INT 17
91700: EQUAL
91701: IFFALSE 91711
// sSlow := true ;
91703: LD_ADDR_EXP 133
91707: PUSH
91708: LD_INT 1
91710: ST_TO_ADDR
// if p3 = 18 then
91711: LD_VAR 0 3
91715: PUSH
91716: LD_INT 18
91718: EQUAL
91719: IFFALSE 91729
// sLack := true ;
91721: LD_ADDR_EXP 134
91725: PUSH
91726: LD_INT 1
91728: ST_TO_ADDR
// if p3 = 19 then
91729: LD_VAR 0 3
91733: PUSH
91734: LD_INT 19
91736: EQUAL
91737: IFFALSE 91747
// sTank := true ;
91739: LD_ADDR_EXP 136
91743: PUSH
91744: LD_INT 1
91746: ST_TO_ADDR
// if p3 = 20 then
91747: LD_VAR 0 3
91751: PUSH
91752: LD_INT 20
91754: EQUAL
91755: IFFALSE 91765
// sRemote := true ;
91757: LD_ADDR_EXP 137
91761: PUSH
91762: LD_INT 1
91764: ST_TO_ADDR
// if p3 = 21 then
91765: LD_VAR 0 3
91769: PUSH
91770: LD_INT 21
91772: EQUAL
91773: IFFALSE 91783
// sPowell := true ;
91775: LD_ADDR_EXP 138
91779: PUSH
91780: LD_INT 1
91782: ST_TO_ADDR
// if p3 = 22 then
91783: LD_VAR 0 3
91787: PUSH
91788: LD_INT 22
91790: EQUAL
91791: IFFALSE 91801
// sTeleport := true ;
91793: LD_ADDR_EXP 141
91797: PUSH
91798: LD_INT 1
91800: ST_TO_ADDR
// if p3 = 23 then
91801: LD_VAR 0 3
91805: PUSH
91806: LD_INT 23
91808: EQUAL
91809: IFFALSE 91819
// sOilTower := true ;
91811: LD_ADDR_EXP 143
91815: PUSH
91816: LD_INT 1
91818: ST_TO_ADDR
// if p3 = 24 then
91819: LD_VAR 0 3
91823: PUSH
91824: LD_INT 24
91826: EQUAL
91827: IFFALSE 91837
// sShovel := true ;
91829: LD_ADDR_EXP 144
91833: PUSH
91834: LD_INT 1
91836: ST_TO_ADDR
// if p3 = 25 then
91837: LD_VAR 0 3
91841: PUSH
91842: LD_INT 25
91844: EQUAL
91845: IFFALSE 91855
// sSheik := true ;
91847: LD_ADDR_EXP 145
91851: PUSH
91852: LD_INT 1
91854: ST_TO_ADDR
// if p3 = 26 then
91855: LD_VAR 0 3
91859: PUSH
91860: LD_INT 26
91862: EQUAL
91863: IFFALSE 91873
// sEarthquake := true ;
91865: LD_ADDR_EXP 147
91869: PUSH
91870: LD_INT 1
91872: ST_TO_ADDR
// if p3 = 27 then
91873: LD_VAR 0 3
91877: PUSH
91878: LD_INT 27
91880: EQUAL
91881: IFFALSE 91891
// sAI := true ;
91883: LD_ADDR_EXP 148
91887: PUSH
91888: LD_INT 1
91890: ST_TO_ADDR
// if p3 = 28 then
91891: LD_VAR 0 3
91895: PUSH
91896: LD_INT 28
91898: EQUAL
91899: IFFALSE 91909
// sCargo := true ;
91901: LD_ADDR_EXP 151
91905: PUSH
91906: LD_INT 1
91908: ST_TO_ADDR
// if p3 = 29 then
91909: LD_VAR 0 3
91913: PUSH
91914: LD_INT 29
91916: EQUAL
91917: IFFALSE 91927
// sDLaser := true ;
91919: LD_ADDR_EXP 152
91923: PUSH
91924: LD_INT 1
91926: ST_TO_ADDR
// if p3 = 30 then
91927: LD_VAR 0 3
91931: PUSH
91932: LD_INT 30
91934: EQUAL
91935: IFFALSE 91945
// sExchange := true ;
91937: LD_ADDR_EXP 153
91941: PUSH
91942: LD_INT 1
91944: ST_TO_ADDR
// if p3 = 31 then
91945: LD_VAR 0 3
91949: PUSH
91950: LD_INT 31
91952: EQUAL
91953: IFFALSE 91963
// sFac := true ;
91955: LD_ADDR_EXP 154
91959: PUSH
91960: LD_INT 1
91962: ST_TO_ADDR
// if p3 = 32 then
91963: LD_VAR 0 3
91967: PUSH
91968: LD_INT 32
91970: EQUAL
91971: IFFALSE 91981
// sPower := true ;
91973: LD_ADDR_EXP 155
91977: PUSH
91978: LD_INT 1
91980: ST_TO_ADDR
// if p3 = 33 then
91981: LD_VAR 0 3
91985: PUSH
91986: LD_INT 33
91988: EQUAL
91989: IFFALSE 91999
// sRandom := true ;
91991: LD_ADDR_EXP 156
91995: PUSH
91996: LD_INT 1
91998: ST_TO_ADDR
// if p3 = 34 then
91999: LD_VAR 0 3
92003: PUSH
92004: LD_INT 34
92006: EQUAL
92007: IFFALSE 92017
// sShield := true ;
92009: LD_ADDR_EXP 157
92013: PUSH
92014: LD_INT 1
92016: ST_TO_ADDR
// if p3 = 35 then
92017: LD_VAR 0 3
92021: PUSH
92022: LD_INT 35
92024: EQUAL
92025: IFFALSE 92035
// sTime := true ;
92027: LD_ADDR_EXP 158
92031: PUSH
92032: LD_INT 1
92034: ST_TO_ADDR
// if p3 = 36 then
92035: LD_VAR 0 3
92039: PUSH
92040: LD_INT 36
92042: EQUAL
92043: IFFALSE 92053
// sTools := true ;
92045: LD_ADDR_EXP 159
92049: PUSH
92050: LD_INT 1
92052: ST_TO_ADDR
// if p3 = 101 then
92053: LD_VAR 0 3
92057: PUSH
92058: LD_INT 101
92060: EQUAL
92061: IFFALSE 92071
// sSold := true ;
92063: LD_ADDR_EXP 124
92067: PUSH
92068: LD_INT 1
92070: ST_TO_ADDR
// if p3 = 102 then
92071: LD_VAR 0 3
92075: PUSH
92076: LD_INT 102
92078: EQUAL
92079: IFFALSE 92089
// sDiff := true ;
92081: LD_ADDR_EXP 125
92085: PUSH
92086: LD_INT 1
92088: ST_TO_ADDR
// if p3 = 103 then
92089: LD_VAR 0 3
92093: PUSH
92094: LD_INT 103
92096: EQUAL
92097: IFFALSE 92107
// sFog := true ;
92099: LD_ADDR_EXP 128
92103: PUSH
92104: LD_INT 1
92106: ST_TO_ADDR
// if p3 = 104 then
92107: LD_VAR 0 3
92111: PUSH
92112: LD_INT 104
92114: EQUAL
92115: IFFALSE 92125
// sReset := true ;
92117: LD_ADDR_EXP 129
92121: PUSH
92122: LD_INT 1
92124: ST_TO_ADDR
// if p3 = 105 then
92125: LD_VAR 0 3
92129: PUSH
92130: LD_INT 105
92132: EQUAL
92133: IFFALSE 92143
// sSun := true ;
92135: LD_ADDR_EXP 130
92139: PUSH
92140: LD_INT 1
92142: ST_TO_ADDR
// if p3 = 106 then
92143: LD_VAR 0 3
92147: PUSH
92148: LD_INT 106
92150: EQUAL
92151: IFFALSE 92161
// sTiger := true ;
92153: LD_ADDR_EXP 126
92157: PUSH
92158: LD_INT 1
92160: ST_TO_ADDR
// if p3 = 107 then
92161: LD_VAR 0 3
92165: PUSH
92166: LD_INT 107
92168: EQUAL
92169: IFFALSE 92179
// sBomb := true ;
92171: LD_ADDR_EXP 127
92175: PUSH
92176: LD_INT 1
92178: ST_TO_ADDR
// if p3 = 108 then
92179: LD_VAR 0 3
92183: PUSH
92184: LD_INT 108
92186: EQUAL
92187: IFFALSE 92197
// sWound := true ;
92189: LD_ADDR_EXP 135
92193: PUSH
92194: LD_INT 1
92196: ST_TO_ADDR
// if p3 = 109 then
92197: LD_VAR 0 3
92201: PUSH
92202: LD_INT 109
92204: EQUAL
92205: IFFALSE 92215
// sBetray := true ;
92207: LD_ADDR_EXP 139
92211: PUSH
92212: LD_INT 1
92214: ST_TO_ADDR
// if p3 = 110 then
92215: LD_VAR 0 3
92219: PUSH
92220: LD_INT 110
92222: EQUAL
92223: IFFALSE 92233
// sContamin := true ;
92225: LD_ADDR_EXP 140
92229: PUSH
92230: LD_INT 1
92232: ST_TO_ADDR
// if p3 = 111 then
92233: LD_VAR 0 3
92237: PUSH
92238: LD_INT 111
92240: EQUAL
92241: IFFALSE 92251
// sOil := true ;
92243: LD_ADDR_EXP 142
92247: PUSH
92248: LD_INT 1
92250: ST_TO_ADDR
// if p3 = 112 then
92251: LD_VAR 0 3
92255: PUSH
92256: LD_INT 112
92258: EQUAL
92259: IFFALSE 92269
// sStu := true ;
92261: LD_ADDR_EXP 146
92265: PUSH
92266: LD_INT 1
92268: ST_TO_ADDR
// if p3 = 113 then
92269: LD_VAR 0 3
92273: PUSH
92274: LD_INT 113
92276: EQUAL
92277: IFFALSE 92287
// sBazooka := true ;
92279: LD_ADDR_EXP 149
92283: PUSH
92284: LD_INT 1
92286: ST_TO_ADDR
// if p3 = 114 then
92287: LD_VAR 0 3
92291: PUSH
92292: LD_INT 114
92294: EQUAL
92295: IFFALSE 92305
// sMortar := true ;
92297: LD_ADDR_EXP 150
92301: PUSH
92302: LD_INT 1
92304: ST_TO_ADDR
// if p3 = 115 then
92305: LD_VAR 0 3
92309: PUSH
92310: LD_INT 115
92312: EQUAL
92313: IFFALSE 92323
// sRanger := true ;
92315: LD_ADDR_EXP 160
92319: PUSH
92320: LD_INT 1
92322: ST_TO_ADDR
// end ; end ;
92323: PPOPN 6
92325: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
92326: LD_EXP 107
92330: PUSH
92331: LD_EXP 112
92335: AND
92336: IFFALSE 92460
92338: GO 92340
92340: DISABLE
92341: LD_INT 0
92343: PPUSH
92344: PPUSH
// begin enable ;
92345: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
92346: LD_ADDR_VAR 0 2
92350: PUSH
92351: LD_INT 22
92353: PUSH
92354: LD_OWVAR 2
92358: PUSH
92359: EMPTY
92360: LIST
92361: LIST
92362: PUSH
92363: LD_INT 2
92365: PUSH
92366: LD_INT 34
92368: PUSH
92369: LD_INT 7
92371: PUSH
92372: EMPTY
92373: LIST
92374: LIST
92375: PUSH
92376: LD_INT 34
92378: PUSH
92379: LD_INT 45
92381: PUSH
92382: EMPTY
92383: LIST
92384: LIST
92385: PUSH
92386: LD_INT 34
92388: PUSH
92389: LD_INT 28
92391: PUSH
92392: EMPTY
92393: LIST
92394: LIST
92395: PUSH
92396: LD_INT 34
92398: PUSH
92399: LD_INT 47
92401: PUSH
92402: EMPTY
92403: LIST
92404: LIST
92405: PUSH
92406: EMPTY
92407: LIST
92408: LIST
92409: LIST
92410: LIST
92411: LIST
92412: PUSH
92413: EMPTY
92414: LIST
92415: LIST
92416: PPUSH
92417: CALL_OW 69
92421: ST_TO_ADDR
// if not tmp then
92422: LD_VAR 0 2
92426: NOT
92427: IFFALSE 92431
// exit ;
92429: GO 92460
// for i in tmp do
92431: LD_ADDR_VAR 0 1
92435: PUSH
92436: LD_VAR 0 2
92440: PUSH
92441: FOR_IN
92442: IFFALSE 92458
// begin SetLives ( i , 0 ) ;
92444: LD_VAR 0 1
92448: PPUSH
92449: LD_INT 0
92451: PPUSH
92452: CALL_OW 234
// end ;
92456: GO 92441
92458: POP
92459: POP
// end ;
92460: PPOPN 2
92462: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
92463: LD_EXP 107
92467: PUSH
92468: LD_EXP 113
92472: AND
92473: IFFALSE 92557
92475: GO 92477
92477: DISABLE
92478: LD_INT 0
92480: PPUSH
92481: PPUSH
// begin enable ;
92482: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
92483: LD_ADDR_VAR 0 2
92487: PUSH
92488: LD_INT 22
92490: PUSH
92491: LD_OWVAR 2
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: PUSH
92500: LD_INT 32
92502: PUSH
92503: LD_INT 3
92505: PUSH
92506: EMPTY
92507: LIST
92508: LIST
92509: PUSH
92510: EMPTY
92511: LIST
92512: LIST
92513: PPUSH
92514: CALL_OW 69
92518: ST_TO_ADDR
// if not tmp then
92519: LD_VAR 0 2
92523: NOT
92524: IFFALSE 92528
// exit ;
92526: GO 92557
// for i in tmp do
92528: LD_ADDR_VAR 0 1
92532: PUSH
92533: LD_VAR 0 2
92537: PUSH
92538: FOR_IN
92539: IFFALSE 92555
// begin SetLives ( i , 0 ) ;
92541: LD_VAR 0 1
92545: PPUSH
92546: LD_INT 0
92548: PPUSH
92549: CALL_OW 234
// end ;
92553: GO 92538
92555: POP
92556: POP
// end ;
92557: PPOPN 2
92559: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
92560: LD_EXP 107
92564: PUSH
92565: LD_EXP 110
92569: AND
92570: IFFALSE 92663
92572: GO 92574
92574: DISABLE
92575: LD_INT 0
92577: PPUSH
// begin enable ;
92578: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
92579: LD_ADDR_VAR 0 1
92583: PUSH
92584: LD_INT 22
92586: PUSH
92587: LD_OWVAR 2
92591: PUSH
92592: EMPTY
92593: LIST
92594: LIST
92595: PUSH
92596: LD_INT 2
92598: PUSH
92599: LD_INT 25
92601: PUSH
92602: LD_INT 5
92604: PUSH
92605: EMPTY
92606: LIST
92607: LIST
92608: PUSH
92609: LD_INT 25
92611: PUSH
92612: LD_INT 9
92614: PUSH
92615: EMPTY
92616: LIST
92617: LIST
92618: PUSH
92619: LD_INT 25
92621: PUSH
92622: LD_INT 8
92624: PUSH
92625: EMPTY
92626: LIST
92627: LIST
92628: PUSH
92629: EMPTY
92630: LIST
92631: LIST
92632: LIST
92633: LIST
92634: PUSH
92635: EMPTY
92636: LIST
92637: LIST
92638: PPUSH
92639: CALL_OW 69
92643: PUSH
92644: FOR_IN
92645: IFFALSE 92661
// begin SetClass ( i , 1 ) ;
92647: LD_VAR 0 1
92651: PPUSH
92652: LD_INT 1
92654: PPUSH
92655: CALL_OW 336
// end ;
92659: GO 92644
92661: POP
92662: POP
// end ;
92663: PPOPN 1
92665: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
92666: LD_EXP 107
92670: PUSH
92671: LD_EXP 111
92675: AND
92676: PUSH
92677: LD_OWVAR 65
92681: PUSH
92682: LD_INT 7
92684: LESS
92685: AND
92686: IFFALSE 92700
92688: GO 92690
92690: DISABLE
// begin enable ;
92691: ENABLE
// game_speed := 7 ;
92692: LD_ADDR_OWVAR 65
92696: PUSH
92697: LD_INT 7
92699: ST_TO_ADDR
// end ;
92700: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
92701: LD_EXP 107
92705: PUSH
92706: LD_EXP 114
92710: AND
92711: IFFALSE 92913
92713: GO 92715
92715: DISABLE
92716: LD_INT 0
92718: PPUSH
92719: PPUSH
92720: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
92721: LD_ADDR_VAR 0 3
92725: PUSH
92726: LD_INT 81
92728: PUSH
92729: LD_OWVAR 2
92733: PUSH
92734: EMPTY
92735: LIST
92736: LIST
92737: PUSH
92738: LD_INT 21
92740: PUSH
92741: LD_INT 1
92743: PUSH
92744: EMPTY
92745: LIST
92746: LIST
92747: PUSH
92748: EMPTY
92749: LIST
92750: LIST
92751: PPUSH
92752: CALL_OW 69
92756: ST_TO_ADDR
// if not tmp then
92757: LD_VAR 0 3
92761: NOT
92762: IFFALSE 92766
// exit ;
92764: GO 92913
// if tmp > 5 then
92766: LD_VAR 0 3
92770: PUSH
92771: LD_INT 5
92773: GREATER
92774: IFFALSE 92786
// k := 5 else
92776: LD_ADDR_VAR 0 2
92780: PUSH
92781: LD_INT 5
92783: ST_TO_ADDR
92784: GO 92796
// k := tmp ;
92786: LD_ADDR_VAR 0 2
92790: PUSH
92791: LD_VAR 0 3
92795: ST_TO_ADDR
// for i := 1 to k do
92796: LD_ADDR_VAR 0 1
92800: PUSH
92801: DOUBLE
92802: LD_INT 1
92804: DEC
92805: ST_TO_ADDR
92806: LD_VAR 0 2
92810: PUSH
92811: FOR_TO
92812: IFFALSE 92911
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
92814: LD_VAR 0 3
92818: PUSH
92819: LD_VAR 0 1
92823: ARRAY
92824: PPUSH
92825: LD_VAR 0 1
92829: PUSH
92830: LD_INT 4
92832: MOD
92833: PUSH
92834: LD_INT 1
92836: PLUS
92837: PPUSH
92838: CALL_OW 259
92842: PUSH
92843: LD_INT 10
92845: LESS
92846: IFFALSE 92909
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
92848: LD_VAR 0 3
92852: PUSH
92853: LD_VAR 0 1
92857: ARRAY
92858: PPUSH
92859: LD_VAR 0 1
92863: PUSH
92864: LD_INT 4
92866: MOD
92867: PUSH
92868: LD_INT 1
92870: PLUS
92871: PPUSH
92872: LD_VAR 0 3
92876: PUSH
92877: LD_VAR 0 1
92881: ARRAY
92882: PPUSH
92883: LD_VAR 0 1
92887: PUSH
92888: LD_INT 4
92890: MOD
92891: PUSH
92892: LD_INT 1
92894: PLUS
92895: PPUSH
92896: CALL_OW 259
92900: PUSH
92901: LD_INT 1
92903: PLUS
92904: PPUSH
92905: CALL_OW 237
92909: GO 92811
92911: POP
92912: POP
// end ;
92913: PPOPN 3
92915: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
92916: LD_EXP 107
92920: PUSH
92921: LD_EXP 115
92925: AND
92926: IFFALSE 92946
92928: GO 92930
92930: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
92931: LD_INT 4
92933: PPUSH
92934: LD_OWVAR 2
92938: PPUSH
92939: LD_INT 0
92941: PPUSH
92942: CALL_OW 324
92946: END
// every 0 0$1 trigger StreamModeActive and sShovel do
92947: LD_EXP 107
92951: PUSH
92952: LD_EXP 144
92956: AND
92957: IFFALSE 92977
92959: GO 92961
92961: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
92962: LD_INT 19
92964: PPUSH
92965: LD_OWVAR 2
92969: PPUSH
92970: LD_INT 0
92972: PPUSH
92973: CALL_OW 324
92977: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
92978: LD_EXP 107
92982: PUSH
92983: LD_EXP 116
92987: AND
92988: IFFALSE 93090
92990: GO 92992
92992: DISABLE
92993: LD_INT 0
92995: PPUSH
92996: PPUSH
// begin enable ;
92997: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
92998: LD_ADDR_VAR 0 2
93002: PUSH
93003: LD_INT 22
93005: PUSH
93006: LD_OWVAR 2
93010: PUSH
93011: EMPTY
93012: LIST
93013: LIST
93014: PUSH
93015: LD_INT 2
93017: PUSH
93018: LD_INT 34
93020: PUSH
93021: LD_INT 11
93023: PUSH
93024: EMPTY
93025: LIST
93026: LIST
93027: PUSH
93028: LD_INT 34
93030: PUSH
93031: LD_INT 30
93033: PUSH
93034: EMPTY
93035: LIST
93036: LIST
93037: PUSH
93038: EMPTY
93039: LIST
93040: LIST
93041: LIST
93042: PUSH
93043: EMPTY
93044: LIST
93045: LIST
93046: PPUSH
93047: CALL_OW 69
93051: ST_TO_ADDR
// if not tmp then
93052: LD_VAR 0 2
93056: NOT
93057: IFFALSE 93061
// exit ;
93059: GO 93090
// for i in tmp do
93061: LD_ADDR_VAR 0 1
93065: PUSH
93066: LD_VAR 0 2
93070: PUSH
93071: FOR_IN
93072: IFFALSE 93088
// begin SetLives ( i , 0 ) ;
93074: LD_VAR 0 1
93078: PPUSH
93079: LD_INT 0
93081: PPUSH
93082: CALL_OW 234
// end ;
93086: GO 93071
93088: POP
93089: POP
// end ;
93090: PPOPN 2
93092: END
// every 0 0$1 trigger StreamModeActive and sBunker do
93093: LD_EXP 107
93097: PUSH
93098: LD_EXP 117
93102: AND
93103: IFFALSE 93123
93105: GO 93107
93107: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
93108: LD_INT 32
93110: PPUSH
93111: LD_OWVAR 2
93115: PPUSH
93116: LD_INT 0
93118: PPUSH
93119: CALL_OW 324
93123: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
93124: LD_EXP 107
93128: PUSH
93129: LD_EXP 118
93133: AND
93134: IFFALSE 93315
93136: GO 93138
93138: DISABLE
93139: LD_INT 0
93141: PPUSH
93142: PPUSH
93143: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
93144: LD_ADDR_VAR 0 2
93148: PUSH
93149: LD_INT 22
93151: PUSH
93152: LD_OWVAR 2
93156: PUSH
93157: EMPTY
93158: LIST
93159: LIST
93160: PUSH
93161: LD_INT 33
93163: PUSH
93164: LD_INT 3
93166: PUSH
93167: EMPTY
93168: LIST
93169: LIST
93170: PUSH
93171: EMPTY
93172: LIST
93173: LIST
93174: PPUSH
93175: CALL_OW 69
93179: ST_TO_ADDR
// if not tmp then
93180: LD_VAR 0 2
93184: NOT
93185: IFFALSE 93189
// exit ;
93187: GO 93315
// side := 0 ;
93189: LD_ADDR_VAR 0 3
93193: PUSH
93194: LD_INT 0
93196: ST_TO_ADDR
// for i := 1 to 8 do
93197: LD_ADDR_VAR 0 1
93201: PUSH
93202: DOUBLE
93203: LD_INT 1
93205: DEC
93206: ST_TO_ADDR
93207: LD_INT 8
93209: PUSH
93210: FOR_TO
93211: IFFALSE 93259
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
93213: LD_OWVAR 2
93217: PUSH
93218: LD_VAR 0 1
93222: NONEQUAL
93223: PUSH
93224: LD_OWVAR 2
93228: PPUSH
93229: LD_VAR 0 1
93233: PPUSH
93234: CALL_OW 81
93238: PUSH
93239: LD_INT 2
93241: EQUAL
93242: AND
93243: IFFALSE 93257
// begin side := i ;
93245: LD_ADDR_VAR 0 3
93249: PUSH
93250: LD_VAR 0 1
93254: ST_TO_ADDR
// break ;
93255: GO 93259
// end ;
93257: GO 93210
93259: POP
93260: POP
// if not side then
93261: LD_VAR 0 3
93265: NOT
93266: IFFALSE 93270
// exit ;
93268: GO 93315
// for i := 1 to tmp do
93270: LD_ADDR_VAR 0 1
93274: PUSH
93275: DOUBLE
93276: LD_INT 1
93278: DEC
93279: ST_TO_ADDR
93280: LD_VAR 0 2
93284: PUSH
93285: FOR_TO
93286: IFFALSE 93313
// if Prob ( 60 ) then
93288: LD_INT 60
93290: PPUSH
93291: CALL_OW 13
93295: IFFALSE 93311
// SetSide ( i , side ) ;
93297: LD_VAR 0 1
93301: PPUSH
93302: LD_VAR 0 3
93306: PPUSH
93307: CALL_OW 235
93311: GO 93285
93313: POP
93314: POP
// end ;
93315: PPOPN 3
93317: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
93318: LD_EXP 107
93322: PUSH
93323: LD_EXP 120
93327: AND
93328: IFFALSE 93447
93330: GO 93332
93332: DISABLE
93333: LD_INT 0
93335: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
93336: LD_ADDR_VAR 0 1
93340: PUSH
93341: LD_INT 22
93343: PUSH
93344: LD_OWVAR 2
93348: PUSH
93349: EMPTY
93350: LIST
93351: LIST
93352: PUSH
93353: LD_INT 21
93355: PUSH
93356: LD_INT 1
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: PUSH
93363: LD_INT 3
93365: PUSH
93366: LD_INT 23
93368: PUSH
93369: LD_INT 0
93371: PUSH
93372: EMPTY
93373: LIST
93374: LIST
93375: PUSH
93376: EMPTY
93377: LIST
93378: LIST
93379: PUSH
93380: EMPTY
93381: LIST
93382: LIST
93383: LIST
93384: PPUSH
93385: CALL_OW 69
93389: PUSH
93390: FOR_IN
93391: IFFALSE 93445
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
93393: LD_VAR 0 1
93397: PPUSH
93398: CALL_OW 257
93402: PUSH
93403: LD_INT 1
93405: PUSH
93406: LD_INT 2
93408: PUSH
93409: LD_INT 3
93411: PUSH
93412: LD_INT 4
93414: PUSH
93415: EMPTY
93416: LIST
93417: LIST
93418: LIST
93419: LIST
93420: IN
93421: IFFALSE 93443
// SetClass ( un , rand ( 1 , 4 ) ) ;
93423: LD_VAR 0 1
93427: PPUSH
93428: LD_INT 1
93430: PPUSH
93431: LD_INT 4
93433: PPUSH
93434: CALL_OW 12
93438: PPUSH
93439: CALL_OW 336
93443: GO 93390
93445: POP
93446: POP
// end ;
93447: PPOPN 1
93449: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
93450: LD_EXP 107
93454: PUSH
93455: LD_EXP 119
93459: AND
93460: IFFALSE 93539
93462: GO 93464
93464: DISABLE
93465: LD_INT 0
93467: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93468: LD_ADDR_VAR 0 1
93472: PUSH
93473: LD_INT 22
93475: PUSH
93476: LD_OWVAR 2
93480: PUSH
93481: EMPTY
93482: LIST
93483: LIST
93484: PUSH
93485: LD_INT 21
93487: PUSH
93488: LD_INT 3
93490: PUSH
93491: EMPTY
93492: LIST
93493: LIST
93494: PUSH
93495: EMPTY
93496: LIST
93497: LIST
93498: PPUSH
93499: CALL_OW 69
93503: ST_TO_ADDR
// if not tmp then
93504: LD_VAR 0 1
93508: NOT
93509: IFFALSE 93513
// exit ;
93511: GO 93539
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
93513: LD_VAR 0 1
93517: PUSH
93518: LD_INT 1
93520: PPUSH
93521: LD_VAR 0 1
93525: PPUSH
93526: CALL_OW 12
93530: ARRAY
93531: PPUSH
93532: LD_INT 100
93534: PPUSH
93535: CALL_OW 234
// end ;
93539: PPOPN 1
93541: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
93542: LD_EXP 107
93546: PUSH
93547: LD_EXP 121
93551: AND
93552: IFFALSE 93650
93554: GO 93556
93556: DISABLE
93557: LD_INT 0
93559: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93560: LD_ADDR_VAR 0 1
93564: PUSH
93565: LD_INT 22
93567: PUSH
93568: LD_OWVAR 2
93572: PUSH
93573: EMPTY
93574: LIST
93575: LIST
93576: PUSH
93577: LD_INT 21
93579: PUSH
93580: LD_INT 1
93582: PUSH
93583: EMPTY
93584: LIST
93585: LIST
93586: PUSH
93587: EMPTY
93588: LIST
93589: LIST
93590: PPUSH
93591: CALL_OW 69
93595: ST_TO_ADDR
// if not tmp then
93596: LD_VAR 0 1
93600: NOT
93601: IFFALSE 93605
// exit ;
93603: GO 93650
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
93605: LD_VAR 0 1
93609: PUSH
93610: LD_INT 1
93612: PPUSH
93613: LD_VAR 0 1
93617: PPUSH
93618: CALL_OW 12
93622: ARRAY
93623: PPUSH
93624: LD_INT 1
93626: PPUSH
93627: LD_INT 4
93629: PPUSH
93630: CALL_OW 12
93634: PPUSH
93635: LD_INT 3000
93637: PPUSH
93638: LD_INT 9000
93640: PPUSH
93641: CALL_OW 12
93645: PPUSH
93646: CALL_OW 492
// end ;
93650: PPOPN 1
93652: END
// every 0 0$1 trigger StreamModeActive and sDepot do
93653: LD_EXP 107
93657: PUSH
93658: LD_EXP 122
93662: AND
93663: IFFALSE 93683
93665: GO 93667
93667: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
93668: LD_INT 1
93670: PPUSH
93671: LD_OWVAR 2
93675: PPUSH
93676: LD_INT 0
93678: PPUSH
93679: CALL_OW 324
93683: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
93684: LD_EXP 107
93688: PUSH
93689: LD_EXP 123
93693: AND
93694: IFFALSE 93777
93696: GO 93698
93698: DISABLE
93699: LD_INT 0
93701: PPUSH
93702: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93703: LD_ADDR_VAR 0 2
93707: PUSH
93708: LD_INT 22
93710: PUSH
93711: LD_OWVAR 2
93715: PUSH
93716: EMPTY
93717: LIST
93718: LIST
93719: PUSH
93720: LD_INT 21
93722: PUSH
93723: LD_INT 3
93725: PUSH
93726: EMPTY
93727: LIST
93728: LIST
93729: PUSH
93730: EMPTY
93731: LIST
93732: LIST
93733: PPUSH
93734: CALL_OW 69
93738: ST_TO_ADDR
// if not tmp then
93739: LD_VAR 0 2
93743: NOT
93744: IFFALSE 93748
// exit ;
93746: GO 93777
// for i in tmp do
93748: LD_ADDR_VAR 0 1
93752: PUSH
93753: LD_VAR 0 2
93757: PUSH
93758: FOR_IN
93759: IFFALSE 93775
// SetBLevel ( i , 10 ) ;
93761: LD_VAR 0 1
93765: PPUSH
93766: LD_INT 10
93768: PPUSH
93769: CALL_OW 241
93773: GO 93758
93775: POP
93776: POP
// end ;
93777: PPOPN 2
93779: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
93780: LD_EXP 107
93784: PUSH
93785: LD_EXP 124
93789: AND
93790: IFFALSE 93901
93792: GO 93794
93794: DISABLE
93795: LD_INT 0
93797: PPUSH
93798: PPUSH
93799: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93800: LD_ADDR_VAR 0 3
93804: PUSH
93805: LD_INT 22
93807: PUSH
93808: LD_OWVAR 2
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: PUSH
93817: LD_INT 25
93819: PUSH
93820: LD_INT 1
93822: PUSH
93823: EMPTY
93824: LIST
93825: LIST
93826: PUSH
93827: EMPTY
93828: LIST
93829: LIST
93830: PPUSH
93831: CALL_OW 69
93835: ST_TO_ADDR
// if not tmp then
93836: LD_VAR 0 3
93840: NOT
93841: IFFALSE 93845
// exit ;
93843: GO 93901
// un := tmp [ rand ( 1 , tmp ) ] ;
93845: LD_ADDR_VAR 0 2
93849: PUSH
93850: LD_VAR 0 3
93854: PUSH
93855: LD_INT 1
93857: PPUSH
93858: LD_VAR 0 3
93862: PPUSH
93863: CALL_OW 12
93867: ARRAY
93868: ST_TO_ADDR
// if Crawls ( un ) then
93869: LD_VAR 0 2
93873: PPUSH
93874: CALL_OW 318
93878: IFFALSE 93889
// ComWalk ( un ) ;
93880: LD_VAR 0 2
93884: PPUSH
93885: CALL_OW 138
// SetClass ( un , class_sniper ) ;
93889: LD_VAR 0 2
93893: PPUSH
93894: LD_INT 5
93896: PPUSH
93897: CALL_OW 336
// end ;
93901: PPOPN 3
93903: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
93904: LD_EXP 107
93908: PUSH
93909: LD_EXP 125
93913: AND
93914: PUSH
93915: LD_OWVAR 67
93919: PUSH
93920: LD_INT 3
93922: LESS
93923: AND
93924: IFFALSE 93943
93926: GO 93928
93928: DISABLE
// Difficulty := Difficulty + 1 ;
93929: LD_ADDR_OWVAR 67
93933: PUSH
93934: LD_OWVAR 67
93938: PUSH
93939: LD_INT 1
93941: PLUS
93942: ST_TO_ADDR
93943: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
93944: LD_EXP 107
93948: PUSH
93949: LD_EXP 126
93953: AND
93954: IFFALSE 94057
93956: GO 93958
93958: DISABLE
93959: LD_INT 0
93961: PPUSH
// begin for i := 1 to 5 do
93962: LD_ADDR_VAR 0 1
93966: PUSH
93967: DOUBLE
93968: LD_INT 1
93970: DEC
93971: ST_TO_ADDR
93972: LD_INT 5
93974: PUSH
93975: FOR_TO
93976: IFFALSE 94055
// begin uc_nation := nation_nature ;
93978: LD_ADDR_OWVAR 21
93982: PUSH
93983: LD_INT 0
93985: ST_TO_ADDR
// uc_side := 0 ;
93986: LD_ADDR_OWVAR 20
93990: PUSH
93991: LD_INT 0
93993: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93994: LD_ADDR_OWVAR 29
93998: PUSH
93999: LD_INT 12
94001: PUSH
94002: LD_INT 12
94004: PUSH
94005: EMPTY
94006: LIST
94007: LIST
94008: ST_TO_ADDR
// hc_agressivity := 20 ;
94009: LD_ADDR_OWVAR 35
94013: PUSH
94014: LD_INT 20
94016: ST_TO_ADDR
// hc_class := class_tiger ;
94017: LD_ADDR_OWVAR 28
94021: PUSH
94022: LD_INT 14
94024: ST_TO_ADDR
// hc_gallery :=  ;
94025: LD_ADDR_OWVAR 33
94029: PUSH
94030: LD_STRING 
94032: ST_TO_ADDR
// hc_name :=  ;
94033: LD_ADDR_OWVAR 26
94037: PUSH
94038: LD_STRING 
94040: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
94041: CALL_OW 44
94045: PPUSH
94046: LD_INT 0
94048: PPUSH
94049: CALL_OW 51
// end ;
94053: GO 93975
94055: POP
94056: POP
// end ;
94057: PPOPN 1
94059: END
// every 0 0$1 trigger StreamModeActive and sBomb do
94060: LD_EXP 107
94064: PUSH
94065: LD_EXP 127
94069: AND
94070: IFFALSE 94079
94072: GO 94074
94074: DISABLE
// StreamSibBomb ;
94075: CALL 94080 0 0
94079: END
// export function StreamSibBomb ; var i , x , y ; begin
94080: LD_INT 0
94082: PPUSH
94083: PPUSH
94084: PPUSH
94085: PPUSH
// result := false ;
94086: LD_ADDR_VAR 0 1
94090: PUSH
94091: LD_INT 0
94093: ST_TO_ADDR
// for i := 1 to 16 do
94094: LD_ADDR_VAR 0 2
94098: PUSH
94099: DOUBLE
94100: LD_INT 1
94102: DEC
94103: ST_TO_ADDR
94104: LD_INT 16
94106: PUSH
94107: FOR_TO
94108: IFFALSE 94307
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94110: LD_ADDR_VAR 0 3
94114: PUSH
94115: LD_INT 10
94117: PUSH
94118: LD_INT 20
94120: PUSH
94121: LD_INT 30
94123: PUSH
94124: LD_INT 40
94126: PUSH
94127: LD_INT 50
94129: PUSH
94130: LD_INT 60
94132: PUSH
94133: LD_INT 70
94135: PUSH
94136: LD_INT 80
94138: PUSH
94139: LD_INT 90
94141: PUSH
94142: LD_INT 100
94144: PUSH
94145: LD_INT 110
94147: PUSH
94148: LD_INT 120
94150: PUSH
94151: LD_INT 130
94153: PUSH
94154: LD_INT 140
94156: PUSH
94157: LD_INT 150
94159: PUSH
94160: EMPTY
94161: LIST
94162: LIST
94163: LIST
94164: LIST
94165: LIST
94166: LIST
94167: LIST
94168: LIST
94169: LIST
94170: LIST
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: PUSH
94177: LD_INT 1
94179: PPUSH
94180: LD_INT 15
94182: PPUSH
94183: CALL_OW 12
94187: ARRAY
94188: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94189: LD_ADDR_VAR 0 4
94193: PUSH
94194: LD_INT 10
94196: PUSH
94197: LD_INT 20
94199: PUSH
94200: LD_INT 30
94202: PUSH
94203: LD_INT 40
94205: PUSH
94206: LD_INT 50
94208: PUSH
94209: LD_INT 60
94211: PUSH
94212: LD_INT 70
94214: PUSH
94215: LD_INT 80
94217: PUSH
94218: LD_INT 90
94220: PUSH
94221: LD_INT 100
94223: PUSH
94224: LD_INT 110
94226: PUSH
94227: LD_INT 120
94229: PUSH
94230: LD_INT 130
94232: PUSH
94233: LD_INT 140
94235: PUSH
94236: LD_INT 150
94238: PUSH
94239: EMPTY
94240: LIST
94241: LIST
94242: LIST
94243: LIST
94244: LIST
94245: LIST
94246: LIST
94247: LIST
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: LIST
94253: LIST
94254: LIST
94255: PUSH
94256: LD_INT 1
94258: PPUSH
94259: LD_INT 15
94261: PPUSH
94262: CALL_OW 12
94266: ARRAY
94267: ST_TO_ADDR
// if ValidHex ( x , y ) then
94268: LD_VAR 0 3
94272: PPUSH
94273: LD_VAR 0 4
94277: PPUSH
94278: CALL_OW 488
94282: IFFALSE 94305
// begin result := [ x , y ] ;
94284: LD_ADDR_VAR 0 1
94288: PUSH
94289: LD_VAR 0 3
94293: PUSH
94294: LD_VAR 0 4
94298: PUSH
94299: EMPTY
94300: LIST
94301: LIST
94302: ST_TO_ADDR
// break ;
94303: GO 94307
// end ; end ;
94305: GO 94107
94307: POP
94308: POP
// if result then
94309: LD_VAR 0 1
94313: IFFALSE 94373
// begin ToLua ( playSibBomb() ) ;
94315: LD_STRING playSibBomb()
94317: PPUSH
94318: CALL_OW 559
// wait ( 0 0$14 ) ;
94322: LD_INT 490
94324: PPUSH
94325: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
94329: LD_VAR 0 1
94333: PUSH
94334: LD_INT 1
94336: ARRAY
94337: PPUSH
94338: LD_VAR 0 1
94342: PUSH
94343: LD_INT 2
94345: ARRAY
94346: PPUSH
94347: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
94351: LD_VAR 0 1
94355: PUSH
94356: LD_INT 1
94358: ARRAY
94359: PPUSH
94360: LD_VAR 0 1
94364: PUSH
94365: LD_INT 2
94367: ARRAY
94368: PPUSH
94369: CALL_OW 429
// end ; end ;
94373: LD_VAR 0 1
94377: RET
// every 0 0$1 trigger StreamModeActive and sReset do
94378: LD_EXP 107
94382: PUSH
94383: LD_EXP 129
94387: AND
94388: IFFALSE 94400
94390: GO 94392
94392: DISABLE
// YouLost (  ) ;
94393: LD_STRING 
94395: PPUSH
94396: CALL_OW 104
94400: END
// every 0 0$1 trigger StreamModeActive and sFog do
94401: LD_EXP 107
94405: PUSH
94406: LD_EXP 128
94410: AND
94411: IFFALSE 94425
94413: GO 94415
94415: DISABLE
// FogOff ( your_side ) ;
94416: LD_OWVAR 2
94420: PPUSH
94421: CALL_OW 344
94425: END
// every 0 0$1 trigger StreamModeActive and sSun do
94426: LD_EXP 107
94430: PUSH
94431: LD_EXP 130
94435: AND
94436: IFFALSE 94464
94438: GO 94440
94440: DISABLE
// begin solar_recharge_percent := 0 ;
94441: LD_ADDR_OWVAR 79
94445: PUSH
94446: LD_INT 0
94448: ST_TO_ADDR
// wait ( 5 5$00 ) ;
94449: LD_INT 10500
94451: PPUSH
94452: CALL_OW 67
// solar_recharge_percent := 100 ;
94456: LD_ADDR_OWVAR 79
94460: PUSH
94461: LD_INT 100
94463: ST_TO_ADDR
// end ;
94464: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
94465: LD_EXP 107
94469: PUSH
94470: LD_EXP 131
94474: AND
94475: IFFALSE 94714
94477: GO 94479
94479: DISABLE
94480: LD_INT 0
94482: PPUSH
94483: PPUSH
94484: PPUSH
// begin tmp := [ ] ;
94485: LD_ADDR_VAR 0 3
94489: PUSH
94490: EMPTY
94491: ST_TO_ADDR
// for i := 1 to 6 do
94492: LD_ADDR_VAR 0 1
94496: PUSH
94497: DOUBLE
94498: LD_INT 1
94500: DEC
94501: ST_TO_ADDR
94502: LD_INT 6
94504: PUSH
94505: FOR_TO
94506: IFFALSE 94611
// begin uc_nation := nation_nature ;
94508: LD_ADDR_OWVAR 21
94512: PUSH
94513: LD_INT 0
94515: ST_TO_ADDR
// uc_side := 0 ;
94516: LD_ADDR_OWVAR 20
94520: PUSH
94521: LD_INT 0
94523: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94524: LD_ADDR_OWVAR 29
94528: PUSH
94529: LD_INT 12
94531: PUSH
94532: LD_INT 12
94534: PUSH
94535: EMPTY
94536: LIST
94537: LIST
94538: ST_TO_ADDR
// hc_agressivity := 20 ;
94539: LD_ADDR_OWVAR 35
94543: PUSH
94544: LD_INT 20
94546: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
94547: LD_ADDR_OWVAR 28
94551: PUSH
94552: LD_INT 17
94554: ST_TO_ADDR
// hc_gallery :=  ;
94555: LD_ADDR_OWVAR 33
94559: PUSH
94560: LD_STRING 
94562: ST_TO_ADDR
// hc_name :=  ;
94563: LD_ADDR_OWVAR 26
94567: PUSH
94568: LD_STRING 
94570: ST_TO_ADDR
// un := CreateHuman ;
94571: LD_ADDR_VAR 0 2
94575: PUSH
94576: CALL_OW 44
94580: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
94581: LD_VAR 0 2
94585: PPUSH
94586: LD_INT 1
94588: PPUSH
94589: CALL_OW 51
// tmp := tmp ^ un ;
94593: LD_ADDR_VAR 0 3
94597: PUSH
94598: LD_VAR 0 3
94602: PUSH
94603: LD_VAR 0 2
94607: ADD
94608: ST_TO_ADDR
// end ;
94609: GO 94505
94611: POP
94612: POP
// repeat wait ( 0 0$1 ) ;
94613: LD_INT 35
94615: PPUSH
94616: CALL_OW 67
// for un in tmp do
94620: LD_ADDR_VAR 0 2
94624: PUSH
94625: LD_VAR 0 3
94629: PUSH
94630: FOR_IN
94631: IFFALSE 94705
// begin if IsDead ( un ) then
94633: LD_VAR 0 2
94637: PPUSH
94638: CALL_OW 301
94642: IFFALSE 94662
// begin tmp := tmp diff un ;
94644: LD_ADDR_VAR 0 3
94648: PUSH
94649: LD_VAR 0 3
94653: PUSH
94654: LD_VAR 0 2
94658: DIFF
94659: ST_TO_ADDR
// continue ;
94660: GO 94630
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
94662: LD_VAR 0 2
94666: PPUSH
94667: LD_INT 3
94669: PUSH
94670: LD_INT 22
94672: PUSH
94673: LD_INT 0
94675: PUSH
94676: EMPTY
94677: LIST
94678: LIST
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: PPUSH
94684: CALL_OW 69
94688: PPUSH
94689: LD_VAR 0 2
94693: PPUSH
94694: CALL_OW 74
94698: PPUSH
94699: CALL_OW 115
// end ;
94703: GO 94630
94705: POP
94706: POP
// until not tmp ;
94707: LD_VAR 0 3
94711: NOT
94712: IFFALSE 94613
// end ;
94714: PPOPN 3
94716: END
// every 0 0$1 trigger StreamModeActive and sTroll do
94717: LD_EXP 107
94721: PUSH
94722: LD_EXP 132
94726: AND
94727: IFFALSE 94781
94729: GO 94731
94731: DISABLE
// begin ToLua ( displayTroll(); ) ;
94732: LD_STRING displayTroll();
94734: PPUSH
94735: CALL_OW 559
// wait ( 3 3$00 ) ;
94739: LD_INT 6300
94741: PPUSH
94742: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94746: LD_STRING hideTroll();
94748: PPUSH
94749: CALL_OW 559
// wait ( 1 1$00 ) ;
94753: LD_INT 2100
94755: PPUSH
94756: CALL_OW 67
// ToLua ( displayTroll(); ) ;
94760: LD_STRING displayTroll();
94762: PPUSH
94763: CALL_OW 559
// wait ( 1 1$00 ) ;
94767: LD_INT 2100
94769: PPUSH
94770: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94774: LD_STRING hideTroll();
94776: PPUSH
94777: CALL_OW 559
// end ;
94781: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
94782: LD_EXP 107
94786: PUSH
94787: LD_EXP 133
94791: AND
94792: IFFALSE 94855
94794: GO 94796
94796: DISABLE
94797: LD_INT 0
94799: PPUSH
// begin p := 0 ;
94800: LD_ADDR_VAR 0 1
94804: PUSH
94805: LD_INT 0
94807: ST_TO_ADDR
// repeat game_speed := 1 ;
94808: LD_ADDR_OWVAR 65
94812: PUSH
94813: LD_INT 1
94815: ST_TO_ADDR
// wait ( 0 0$1 ) ;
94816: LD_INT 35
94818: PPUSH
94819: CALL_OW 67
// p := p + 1 ;
94823: LD_ADDR_VAR 0 1
94827: PUSH
94828: LD_VAR 0 1
94832: PUSH
94833: LD_INT 1
94835: PLUS
94836: ST_TO_ADDR
// until p >= 60 ;
94837: LD_VAR 0 1
94841: PUSH
94842: LD_INT 60
94844: GREATEREQUAL
94845: IFFALSE 94808
// game_speed := 4 ;
94847: LD_ADDR_OWVAR 65
94851: PUSH
94852: LD_INT 4
94854: ST_TO_ADDR
// end ;
94855: PPOPN 1
94857: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
94858: LD_EXP 107
94862: PUSH
94863: LD_EXP 134
94867: AND
94868: IFFALSE 95014
94870: GO 94872
94872: DISABLE
94873: LD_INT 0
94875: PPUSH
94876: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94877: LD_ADDR_VAR 0 1
94881: PUSH
94882: LD_INT 22
94884: PUSH
94885: LD_OWVAR 2
94889: PUSH
94890: EMPTY
94891: LIST
94892: LIST
94893: PUSH
94894: LD_INT 2
94896: PUSH
94897: LD_INT 30
94899: PUSH
94900: LD_INT 0
94902: PUSH
94903: EMPTY
94904: LIST
94905: LIST
94906: PUSH
94907: LD_INT 30
94909: PUSH
94910: LD_INT 1
94912: PUSH
94913: EMPTY
94914: LIST
94915: LIST
94916: PUSH
94917: EMPTY
94918: LIST
94919: LIST
94920: LIST
94921: PUSH
94922: EMPTY
94923: LIST
94924: LIST
94925: PPUSH
94926: CALL_OW 69
94930: ST_TO_ADDR
// if not depot then
94931: LD_VAR 0 1
94935: NOT
94936: IFFALSE 94940
// exit ;
94938: GO 95014
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
94940: LD_ADDR_VAR 0 2
94944: PUSH
94945: LD_VAR 0 1
94949: PUSH
94950: LD_INT 1
94952: PPUSH
94953: LD_VAR 0 1
94957: PPUSH
94958: CALL_OW 12
94962: ARRAY
94963: PPUSH
94964: CALL_OW 274
94968: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
94969: LD_VAR 0 2
94973: PPUSH
94974: LD_INT 1
94976: PPUSH
94977: LD_INT 0
94979: PPUSH
94980: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
94984: LD_VAR 0 2
94988: PPUSH
94989: LD_INT 2
94991: PPUSH
94992: LD_INT 0
94994: PPUSH
94995: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
94999: LD_VAR 0 2
95003: PPUSH
95004: LD_INT 3
95006: PPUSH
95007: LD_INT 0
95009: PPUSH
95010: CALL_OW 277
// end ;
95014: PPOPN 2
95016: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
95017: LD_EXP 107
95021: PUSH
95022: LD_EXP 135
95026: AND
95027: IFFALSE 95124
95029: GO 95031
95031: DISABLE
95032: LD_INT 0
95034: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95035: LD_ADDR_VAR 0 1
95039: PUSH
95040: LD_INT 22
95042: PUSH
95043: LD_OWVAR 2
95047: PUSH
95048: EMPTY
95049: LIST
95050: LIST
95051: PUSH
95052: LD_INT 21
95054: PUSH
95055: LD_INT 1
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: PUSH
95062: LD_INT 3
95064: PUSH
95065: LD_INT 23
95067: PUSH
95068: LD_INT 0
95070: PUSH
95071: EMPTY
95072: LIST
95073: LIST
95074: PUSH
95075: EMPTY
95076: LIST
95077: LIST
95078: PUSH
95079: EMPTY
95080: LIST
95081: LIST
95082: LIST
95083: PPUSH
95084: CALL_OW 69
95088: ST_TO_ADDR
// if not tmp then
95089: LD_VAR 0 1
95093: NOT
95094: IFFALSE 95098
// exit ;
95096: GO 95124
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
95098: LD_VAR 0 1
95102: PUSH
95103: LD_INT 1
95105: PPUSH
95106: LD_VAR 0 1
95110: PPUSH
95111: CALL_OW 12
95115: ARRAY
95116: PPUSH
95117: LD_INT 200
95119: PPUSH
95120: CALL_OW 234
// end ;
95124: PPOPN 1
95126: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
95127: LD_EXP 107
95131: PUSH
95132: LD_EXP 136
95136: AND
95137: IFFALSE 95216
95139: GO 95141
95141: DISABLE
95142: LD_INT 0
95144: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
95145: LD_ADDR_VAR 0 1
95149: PUSH
95150: LD_INT 22
95152: PUSH
95153: LD_OWVAR 2
95157: PUSH
95158: EMPTY
95159: LIST
95160: LIST
95161: PUSH
95162: LD_INT 21
95164: PUSH
95165: LD_INT 2
95167: PUSH
95168: EMPTY
95169: LIST
95170: LIST
95171: PUSH
95172: EMPTY
95173: LIST
95174: LIST
95175: PPUSH
95176: CALL_OW 69
95180: ST_TO_ADDR
// if not tmp then
95181: LD_VAR 0 1
95185: NOT
95186: IFFALSE 95190
// exit ;
95188: GO 95216
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
95190: LD_VAR 0 1
95194: PUSH
95195: LD_INT 1
95197: PPUSH
95198: LD_VAR 0 1
95202: PPUSH
95203: CALL_OW 12
95207: ARRAY
95208: PPUSH
95209: LD_INT 60
95211: PPUSH
95212: CALL_OW 234
// end ;
95216: PPOPN 1
95218: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
95219: LD_EXP 107
95223: PUSH
95224: LD_EXP 137
95228: AND
95229: IFFALSE 95328
95231: GO 95233
95233: DISABLE
95234: LD_INT 0
95236: PPUSH
95237: PPUSH
// begin enable ;
95238: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
95239: LD_ADDR_VAR 0 1
95243: PUSH
95244: LD_INT 22
95246: PUSH
95247: LD_OWVAR 2
95251: PUSH
95252: EMPTY
95253: LIST
95254: LIST
95255: PUSH
95256: LD_INT 61
95258: PUSH
95259: EMPTY
95260: LIST
95261: PUSH
95262: LD_INT 33
95264: PUSH
95265: LD_INT 2
95267: PUSH
95268: EMPTY
95269: LIST
95270: LIST
95271: PUSH
95272: EMPTY
95273: LIST
95274: LIST
95275: LIST
95276: PPUSH
95277: CALL_OW 69
95281: ST_TO_ADDR
// if not tmp then
95282: LD_VAR 0 1
95286: NOT
95287: IFFALSE 95291
// exit ;
95289: GO 95328
// for i in tmp do
95291: LD_ADDR_VAR 0 2
95295: PUSH
95296: LD_VAR 0 1
95300: PUSH
95301: FOR_IN
95302: IFFALSE 95326
// if IsControledBy ( i ) then
95304: LD_VAR 0 2
95308: PPUSH
95309: CALL_OW 312
95313: IFFALSE 95324
// ComUnlink ( i ) ;
95315: LD_VAR 0 2
95319: PPUSH
95320: CALL_OW 136
95324: GO 95301
95326: POP
95327: POP
// end ;
95328: PPOPN 2
95330: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
95331: LD_EXP 107
95335: PUSH
95336: LD_EXP 138
95340: AND
95341: IFFALSE 95481
95343: GO 95345
95345: DISABLE
95346: LD_INT 0
95348: PPUSH
95349: PPUSH
// begin ToLua ( displayPowell(); ) ;
95350: LD_STRING displayPowell();
95352: PPUSH
95353: CALL_OW 559
// uc_side := 0 ;
95357: LD_ADDR_OWVAR 20
95361: PUSH
95362: LD_INT 0
95364: ST_TO_ADDR
// uc_nation := 2 ;
95365: LD_ADDR_OWVAR 21
95369: PUSH
95370: LD_INT 2
95372: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
95373: LD_ADDR_OWVAR 37
95377: PUSH
95378: LD_INT 14
95380: ST_TO_ADDR
// vc_engine := engine_siberite ;
95381: LD_ADDR_OWVAR 39
95385: PUSH
95386: LD_INT 3
95388: ST_TO_ADDR
// vc_control := control_apeman ;
95389: LD_ADDR_OWVAR 38
95393: PUSH
95394: LD_INT 5
95396: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
95397: LD_ADDR_OWVAR 40
95401: PUSH
95402: LD_INT 29
95404: ST_TO_ADDR
// un := CreateVehicle ;
95405: LD_ADDR_VAR 0 2
95409: PUSH
95410: CALL_OW 45
95414: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95415: LD_VAR 0 2
95419: PPUSH
95420: LD_INT 1
95422: PPUSH
95423: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95427: LD_INT 35
95429: PPUSH
95430: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95434: LD_VAR 0 2
95438: PPUSH
95439: LD_INT 22
95441: PUSH
95442: LD_OWVAR 2
95446: PUSH
95447: EMPTY
95448: LIST
95449: LIST
95450: PPUSH
95451: CALL_OW 69
95455: PPUSH
95456: LD_VAR 0 2
95460: PPUSH
95461: CALL_OW 74
95465: PPUSH
95466: CALL_OW 115
// until IsDead ( un ) ;
95470: LD_VAR 0 2
95474: PPUSH
95475: CALL_OW 301
95479: IFFALSE 95427
// end ;
95481: PPOPN 2
95483: END
// every 0 0$1 trigger StreamModeActive and sStu do
95484: LD_EXP 107
95488: PUSH
95489: LD_EXP 146
95493: AND
95494: IFFALSE 95510
95496: GO 95498
95498: DISABLE
// begin ToLua ( displayStucuk(); ) ;
95499: LD_STRING displayStucuk();
95501: PPUSH
95502: CALL_OW 559
// ResetFog ;
95506: CALL_OW 335
// end ;
95510: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
95511: LD_EXP 107
95515: PUSH
95516: LD_EXP 139
95520: AND
95521: IFFALSE 95662
95523: GO 95525
95525: DISABLE
95526: LD_INT 0
95528: PPUSH
95529: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95530: LD_ADDR_VAR 0 2
95534: PUSH
95535: LD_INT 22
95537: PUSH
95538: LD_OWVAR 2
95542: PUSH
95543: EMPTY
95544: LIST
95545: LIST
95546: PUSH
95547: LD_INT 21
95549: PUSH
95550: LD_INT 1
95552: PUSH
95553: EMPTY
95554: LIST
95555: LIST
95556: PUSH
95557: EMPTY
95558: LIST
95559: LIST
95560: PPUSH
95561: CALL_OW 69
95565: ST_TO_ADDR
// if not tmp then
95566: LD_VAR 0 2
95570: NOT
95571: IFFALSE 95575
// exit ;
95573: GO 95662
// un := tmp [ rand ( 1 , tmp ) ] ;
95575: LD_ADDR_VAR 0 1
95579: PUSH
95580: LD_VAR 0 2
95584: PUSH
95585: LD_INT 1
95587: PPUSH
95588: LD_VAR 0 2
95592: PPUSH
95593: CALL_OW 12
95597: ARRAY
95598: ST_TO_ADDR
// SetSide ( un , 0 ) ;
95599: LD_VAR 0 1
95603: PPUSH
95604: LD_INT 0
95606: PPUSH
95607: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
95611: LD_VAR 0 1
95615: PPUSH
95616: LD_OWVAR 3
95620: PUSH
95621: LD_VAR 0 1
95625: DIFF
95626: PPUSH
95627: LD_VAR 0 1
95631: PPUSH
95632: CALL_OW 74
95636: PPUSH
95637: CALL_OW 115
// wait ( 0 0$20 ) ;
95641: LD_INT 700
95643: PPUSH
95644: CALL_OW 67
// SetSide ( un , your_side ) ;
95648: LD_VAR 0 1
95652: PPUSH
95653: LD_OWVAR 2
95657: PPUSH
95658: CALL_OW 235
// end ;
95662: PPOPN 2
95664: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
95665: LD_EXP 107
95669: PUSH
95670: LD_EXP 140
95674: AND
95675: IFFALSE 95781
95677: GO 95679
95679: DISABLE
95680: LD_INT 0
95682: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95683: LD_ADDR_VAR 0 1
95687: PUSH
95688: LD_INT 22
95690: PUSH
95691: LD_OWVAR 2
95695: PUSH
95696: EMPTY
95697: LIST
95698: LIST
95699: PUSH
95700: LD_INT 2
95702: PUSH
95703: LD_INT 30
95705: PUSH
95706: LD_INT 0
95708: PUSH
95709: EMPTY
95710: LIST
95711: LIST
95712: PUSH
95713: LD_INT 30
95715: PUSH
95716: LD_INT 1
95718: PUSH
95719: EMPTY
95720: LIST
95721: LIST
95722: PUSH
95723: EMPTY
95724: LIST
95725: LIST
95726: LIST
95727: PUSH
95728: EMPTY
95729: LIST
95730: LIST
95731: PPUSH
95732: CALL_OW 69
95736: ST_TO_ADDR
// if not depot then
95737: LD_VAR 0 1
95741: NOT
95742: IFFALSE 95746
// exit ;
95744: GO 95781
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
95746: LD_VAR 0 1
95750: PUSH
95751: LD_INT 1
95753: ARRAY
95754: PPUSH
95755: CALL_OW 250
95759: PPUSH
95760: LD_VAR 0 1
95764: PUSH
95765: LD_INT 1
95767: ARRAY
95768: PPUSH
95769: CALL_OW 251
95773: PPUSH
95774: LD_INT 70
95776: PPUSH
95777: CALL_OW 495
// end ;
95781: PPOPN 1
95783: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
95784: LD_EXP 107
95788: PUSH
95789: LD_EXP 141
95793: AND
95794: IFFALSE 96005
95796: GO 95798
95798: DISABLE
95799: LD_INT 0
95801: PPUSH
95802: PPUSH
95803: PPUSH
95804: PPUSH
95805: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95806: LD_ADDR_VAR 0 5
95810: PUSH
95811: LD_INT 22
95813: PUSH
95814: LD_OWVAR 2
95818: PUSH
95819: EMPTY
95820: LIST
95821: LIST
95822: PUSH
95823: LD_INT 21
95825: PUSH
95826: LD_INT 1
95828: PUSH
95829: EMPTY
95830: LIST
95831: LIST
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: PPUSH
95837: CALL_OW 69
95841: ST_TO_ADDR
// if not tmp then
95842: LD_VAR 0 5
95846: NOT
95847: IFFALSE 95851
// exit ;
95849: GO 96005
// for i in tmp do
95851: LD_ADDR_VAR 0 1
95855: PUSH
95856: LD_VAR 0 5
95860: PUSH
95861: FOR_IN
95862: IFFALSE 96003
// begin d := rand ( 0 , 5 ) ;
95864: LD_ADDR_VAR 0 4
95868: PUSH
95869: LD_INT 0
95871: PPUSH
95872: LD_INT 5
95874: PPUSH
95875: CALL_OW 12
95879: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
95880: LD_ADDR_VAR 0 2
95884: PUSH
95885: LD_VAR 0 1
95889: PPUSH
95890: CALL_OW 250
95894: PPUSH
95895: LD_VAR 0 4
95899: PPUSH
95900: LD_INT 3
95902: PPUSH
95903: LD_INT 12
95905: PPUSH
95906: CALL_OW 12
95910: PPUSH
95911: CALL_OW 272
95915: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
95916: LD_ADDR_VAR 0 3
95920: PUSH
95921: LD_VAR 0 1
95925: PPUSH
95926: CALL_OW 251
95930: PPUSH
95931: LD_VAR 0 4
95935: PPUSH
95936: LD_INT 3
95938: PPUSH
95939: LD_INT 12
95941: PPUSH
95942: CALL_OW 12
95946: PPUSH
95947: CALL_OW 273
95951: ST_TO_ADDR
// if ValidHex ( x , y ) then
95952: LD_VAR 0 2
95956: PPUSH
95957: LD_VAR 0 3
95961: PPUSH
95962: CALL_OW 488
95966: IFFALSE 96001
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
95968: LD_VAR 0 1
95972: PPUSH
95973: LD_VAR 0 2
95977: PPUSH
95978: LD_VAR 0 3
95982: PPUSH
95983: LD_INT 3
95985: PPUSH
95986: LD_INT 6
95988: PPUSH
95989: CALL_OW 12
95993: PPUSH
95994: LD_INT 1
95996: PPUSH
95997: CALL_OW 483
// end ;
96001: GO 95861
96003: POP
96004: POP
// end ;
96005: PPOPN 5
96007: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
96008: LD_EXP 107
96012: PUSH
96013: LD_EXP 142
96017: AND
96018: IFFALSE 96112
96020: GO 96022
96022: DISABLE
96023: LD_INT 0
96025: PPUSH
96026: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
96027: LD_ADDR_VAR 0 2
96031: PUSH
96032: LD_INT 22
96034: PUSH
96035: LD_OWVAR 2
96039: PUSH
96040: EMPTY
96041: LIST
96042: LIST
96043: PUSH
96044: LD_INT 32
96046: PUSH
96047: LD_INT 1
96049: PUSH
96050: EMPTY
96051: LIST
96052: LIST
96053: PUSH
96054: LD_INT 21
96056: PUSH
96057: LD_INT 2
96059: PUSH
96060: EMPTY
96061: LIST
96062: LIST
96063: PUSH
96064: EMPTY
96065: LIST
96066: LIST
96067: LIST
96068: PPUSH
96069: CALL_OW 69
96073: ST_TO_ADDR
// if not tmp then
96074: LD_VAR 0 2
96078: NOT
96079: IFFALSE 96083
// exit ;
96081: GO 96112
// for i in tmp do
96083: LD_ADDR_VAR 0 1
96087: PUSH
96088: LD_VAR 0 2
96092: PUSH
96093: FOR_IN
96094: IFFALSE 96110
// SetFuel ( i , 0 ) ;
96096: LD_VAR 0 1
96100: PPUSH
96101: LD_INT 0
96103: PPUSH
96104: CALL_OW 240
96108: GO 96093
96110: POP
96111: POP
// end ;
96112: PPOPN 2
96114: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
96115: LD_EXP 107
96119: PUSH
96120: LD_EXP 143
96124: AND
96125: IFFALSE 96191
96127: GO 96129
96129: DISABLE
96130: LD_INT 0
96132: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96133: LD_ADDR_VAR 0 1
96137: PUSH
96138: LD_INT 22
96140: PUSH
96141: LD_OWVAR 2
96145: PUSH
96146: EMPTY
96147: LIST
96148: LIST
96149: PUSH
96150: LD_INT 30
96152: PUSH
96153: LD_INT 29
96155: PUSH
96156: EMPTY
96157: LIST
96158: LIST
96159: PUSH
96160: EMPTY
96161: LIST
96162: LIST
96163: PPUSH
96164: CALL_OW 69
96168: ST_TO_ADDR
// if not tmp then
96169: LD_VAR 0 1
96173: NOT
96174: IFFALSE 96178
// exit ;
96176: GO 96191
// DestroyUnit ( tmp [ 1 ] ) ;
96178: LD_VAR 0 1
96182: PUSH
96183: LD_INT 1
96185: ARRAY
96186: PPUSH
96187: CALL_OW 65
// end ;
96191: PPOPN 1
96193: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
96194: LD_EXP 107
96198: PUSH
96199: LD_EXP 145
96203: AND
96204: IFFALSE 96333
96206: GO 96208
96208: DISABLE
96209: LD_INT 0
96211: PPUSH
// begin uc_side := 0 ;
96212: LD_ADDR_OWVAR 20
96216: PUSH
96217: LD_INT 0
96219: ST_TO_ADDR
// uc_nation := nation_arabian ;
96220: LD_ADDR_OWVAR 21
96224: PUSH
96225: LD_INT 2
96227: ST_TO_ADDR
// hc_gallery :=  ;
96228: LD_ADDR_OWVAR 33
96232: PUSH
96233: LD_STRING 
96235: ST_TO_ADDR
// hc_name :=  ;
96236: LD_ADDR_OWVAR 26
96240: PUSH
96241: LD_STRING 
96243: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
96244: LD_INT 1
96246: PPUSH
96247: LD_INT 11
96249: PPUSH
96250: LD_INT 10
96252: PPUSH
96253: CALL_OW 380
// un := CreateHuman ;
96257: LD_ADDR_VAR 0 1
96261: PUSH
96262: CALL_OW 44
96266: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96267: LD_VAR 0 1
96271: PPUSH
96272: LD_INT 1
96274: PPUSH
96275: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96279: LD_INT 35
96281: PPUSH
96282: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96286: LD_VAR 0 1
96290: PPUSH
96291: LD_INT 22
96293: PUSH
96294: LD_OWVAR 2
96298: PUSH
96299: EMPTY
96300: LIST
96301: LIST
96302: PPUSH
96303: CALL_OW 69
96307: PPUSH
96308: LD_VAR 0 1
96312: PPUSH
96313: CALL_OW 74
96317: PPUSH
96318: CALL_OW 115
// until IsDead ( un ) ;
96322: LD_VAR 0 1
96326: PPUSH
96327: CALL_OW 301
96331: IFFALSE 96279
// end ;
96333: PPOPN 1
96335: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
96336: LD_EXP 107
96340: PUSH
96341: LD_EXP 147
96345: AND
96346: IFFALSE 96358
96348: GO 96350
96350: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
96351: LD_STRING earthquake(getX(game), 0, 32)
96353: PPUSH
96354: CALL_OW 559
96358: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
96359: LD_EXP 107
96363: PUSH
96364: LD_EXP 148
96368: AND
96369: IFFALSE 96460
96371: GO 96373
96373: DISABLE
96374: LD_INT 0
96376: PPUSH
// begin enable ;
96377: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
96378: LD_ADDR_VAR 0 1
96382: PUSH
96383: LD_INT 22
96385: PUSH
96386: LD_OWVAR 2
96390: PUSH
96391: EMPTY
96392: LIST
96393: LIST
96394: PUSH
96395: LD_INT 21
96397: PUSH
96398: LD_INT 2
96400: PUSH
96401: EMPTY
96402: LIST
96403: LIST
96404: PUSH
96405: LD_INT 33
96407: PUSH
96408: LD_INT 3
96410: PUSH
96411: EMPTY
96412: LIST
96413: LIST
96414: PUSH
96415: EMPTY
96416: LIST
96417: LIST
96418: LIST
96419: PPUSH
96420: CALL_OW 69
96424: ST_TO_ADDR
// if not tmp then
96425: LD_VAR 0 1
96429: NOT
96430: IFFALSE 96434
// exit ;
96432: GO 96460
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96434: LD_VAR 0 1
96438: PUSH
96439: LD_INT 1
96441: PPUSH
96442: LD_VAR 0 1
96446: PPUSH
96447: CALL_OW 12
96451: ARRAY
96452: PPUSH
96453: LD_INT 1
96455: PPUSH
96456: CALL_OW 234
// end ;
96460: PPOPN 1
96462: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
96463: LD_EXP 107
96467: PUSH
96468: LD_EXP 149
96472: AND
96473: IFFALSE 96614
96475: GO 96477
96477: DISABLE
96478: LD_INT 0
96480: PPUSH
96481: PPUSH
96482: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96483: LD_ADDR_VAR 0 3
96487: PUSH
96488: LD_INT 22
96490: PUSH
96491: LD_OWVAR 2
96495: PUSH
96496: EMPTY
96497: LIST
96498: LIST
96499: PUSH
96500: LD_INT 25
96502: PUSH
96503: LD_INT 1
96505: PUSH
96506: EMPTY
96507: LIST
96508: LIST
96509: PUSH
96510: EMPTY
96511: LIST
96512: LIST
96513: PPUSH
96514: CALL_OW 69
96518: ST_TO_ADDR
// if not tmp then
96519: LD_VAR 0 3
96523: NOT
96524: IFFALSE 96528
// exit ;
96526: GO 96614
// un := tmp [ rand ( 1 , tmp ) ] ;
96528: LD_ADDR_VAR 0 2
96532: PUSH
96533: LD_VAR 0 3
96537: PUSH
96538: LD_INT 1
96540: PPUSH
96541: LD_VAR 0 3
96545: PPUSH
96546: CALL_OW 12
96550: ARRAY
96551: ST_TO_ADDR
// if Crawls ( un ) then
96552: LD_VAR 0 2
96556: PPUSH
96557: CALL_OW 318
96561: IFFALSE 96572
// ComWalk ( un ) ;
96563: LD_VAR 0 2
96567: PPUSH
96568: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
96572: LD_VAR 0 2
96576: PPUSH
96577: LD_INT 9
96579: PPUSH
96580: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
96584: LD_INT 28
96586: PPUSH
96587: LD_OWVAR 2
96591: PPUSH
96592: LD_INT 2
96594: PPUSH
96595: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
96599: LD_INT 29
96601: PPUSH
96602: LD_OWVAR 2
96606: PPUSH
96607: LD_INT 2
96609: PPUSH
96610: CALL_OW 322
// end ;
96614: PPOPN 3
96616: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
96617: LD_EXP 107
96621: PUSH
96622: LD_EXP 150
96626: AND
96627: IFFALSE 96738
96629: GO 96631
96631: DISABLE
96632: LD_INT 0
96634: PPUSH
96635: PPUSH
96636: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96637: LD_ADDR_VAR 0 3
96641: PUSH
96642: LD_INT 22
96644: PUSH
96645: LD_OWVAR 2
96649: PUSH
96650: EMPTY
96651: LIST
96652: LIST
96653: PUSH
96654: LD_INT 25
96656: PUSH
96657: LD_INT 1
96659: PUSH
96660: EMPTY
96661: LIST
96662: LIST
96663: PUSH
96664: EMPTY
96665: LIST
96666: LIST
96667: PPUSH
96668: CALL_OW 69
96672: ST_TO_ADDR
// if not tmp then
96673: LD_VAR 0 3
96677: NOT
96678: IFFALSE 96682
// exit ;
96680: GO 96738
// un := tmp [ rand ( 1 , tmp ) ] ;
96682: LD_ADDR_VAR 0 2
96686: PUSH
96687: LD_VAR 0 3
96691: PUSH
96692: LD_INT 1
96694: PPUSH
96695: LD_VAR 0 3
96699: PPUSH
96700: CALL_OW 12
96704: ARRAY
96705: ST_TO_ADDR
// if Crawls ( un ) then
96706: LD_VAR 0 2
96710: PPUSH
96711: CALL_OW 318
96715: IFFALSE 96726
// ComWalk ( un ) ;
96717: LD_VAR 0 2
96721: PPUSH
96722: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96726: LD_VAR 0 2
96730: PPUSH
96731: LD_INT 8
96733: PPUSH
96734: CALL_OW 336
// end ;
96738: PPOPN 3
96740: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
96741: LD_EXP 107
96745: PUSH
96746: LD_EXP 151
96750: AND
96751: IFFALSE 96895
96753: GO 96755
96755: DISABLE
96756: LD_INT 0
96758: PPUSH
96759: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
96760: LD_ADDR_VAR 0 2
96764: PUSH
96765: LD_INT 22
96767: PUSH
96768: LD_OWVAR 2
96772: PUSH
96773: EMPTY
96774: LIST
96775: LIST
96776: PUSH
96777: LD_INT 21
96779: PUSH
96780: LD_INT 2
96782: PUSH
96783: EMPTY
96784: LIST
96785: LIST
96786: PUSH
96787: LD_INT 2
96789: PUSH
96790: LD_INT 34
96792: PUSH
96793: LD_INT 12
96795: PUSH
96796: EMPTY
96797: LIST
96798: LIST
96799: PUSH
96800: LD_INT 34
96802: PUSH
96803: LD_INT 51
96805: PUSH
96806: EMPTY
96807: LIST
96808: LIST
96809: PUSH
96810: LD_INT 34
96812: PUSH
96813: LD_INT 32
96815: PUSH
96816: EMPTY
96817: LIST
96818: LIST
96819: PUSH
96820: EMPTY
96821: LIST
96822: LIST
96823: LIST
96824: LIST
96825: PUSH
96826: EMPTY
96827: LIST
96828: LIST
96829: LIST
96830: PPUSH
96831: CALL_OW 69
96835: ST_TO_ADDR
// if not tmp then
96836: LD_VAR 0 2
96840: NOT
96841: IFFALSE 96845
// exit ;
96843: GO 96895
// for i in tmp do
96845: LD_ADDR_VAR 0 1
96849: PUSH
96850: LD_VAR 0 2
96854: PUSH
96855: FOR_IN
96856: IFFALSE 96893
// if GetCargo ( i , mat_artifact ) = 0 then
96858: LD_VAR 0 1
96862: PPUSH
96863: LD_INT 4
96865: PPUSH
96866: CALL_OW 289
96870: PUSH
96871: LD_INT 0
96873: EQUAL
96874: IFFALSE 96891
// SetCargo ( i , mat_siberit , 100 ) ;
96876: LD_VAR 0 1
96880: PPUSH
96881: LD_INT 3
96883: PPUSH
96884: LD_INT 100
96886: PPUSH
96887: CALL_OW 290
96891: GO 96855
96893: POP
96894: POP
// end ;
96895: PPOPN 2
96897: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
96898: LD_EXP 107
96902: PUSH
96903: LD_EXP 152
96907: AND
96908: IFFALSE 97061
96910: GO 96912
96912: DISABLE
96913: LD_INT 0
96915: PPUSH
96916: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96917: LD_ADDR_VAR 0 2
96921: PUSH
96922: LD_INT 22
96924: PUSH
96925: LD_OWVAR 2
96929: PUSH
96930: EMPTY
96931: LIST
96932: LIST
96933: PPUSH
96934: CALL_OW 69
96938: ST_TO_ADDR
// if not tmp then
96939: LD_VAR 0 2
96943: NOT
96944: IFFALSE 96948
// exit ;
96946: GO 97061
// for i := 1 to 2 do
96948: LD_ADDR_VAR 0 1
96952: PUSH
96953: DOUBLE
96954: LD_INT 1
96956: DEC
96957: ST_TO_ADDR
96958: LD_INT 2
96960: PUSH
96961: FOR_TO
96962: IFFALSE 97059
// begin uc_side := your_side ;
96964: LD_ADDR_OWVAR 20
96968: PUSH
96969: LD_OWVAR 2
96973: ST_TO_ADDR
// uc_nation := nation_american ;
96974: LD_ADDR_OWVAR 21
96978: PUSH
96979: LD_INT 1
96981: ST_TO_ADDR
// vc_chassis := us_morphling ;
96982: LD_ADDR_OWVAR 37
96986: PUSH
96987: LD_INT 5
96989: ST_TO_ADDR
// vc_engine := engine_siberite ;
96990: LD_ADDR_OWVAR 39
96994: PUSH
96995: LD_INT 3
96997: ST_TO_ADDR
// vc_control := control_computer ;
96998: LD_ADDR_OWVAR 38
97002: PUSH
97003: LD_INT 3
97005: ST_TO_ADDR
// vc_weapon := us_double_laser ;
97006: LD_ADDR_OWVAR 40
97010: PUSH
97011: LD_INT 10
97013: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
97014: CALL_OW 45
97018: PPUSH
97019: LD_VAR 0 2
97023: PUSH
97024: LD_INT 1
97026: ARRAY
97027: PPUSH
97028: CALL_OW 250
97032: PPUSH
97033: LD_VAR 0 2
97037: PUSH
97038: LD_INT 1
97040: ARRAY
97041: PPUSH
97042: CALL_OW 251
97046: PPUSH
97047: LD_INT 12
97049: PPUSH
97050: LD_INT 1
97052: PPUSH
97053: CALL_OW 50
// end ;
97057: GO 96961
97059: POP
97060: POP
// end ;
97061: PPOPN 2
97063: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
97064: LD_EXP 107
97068: PUSH
97069: LD_EXP 153
97073: AND
97074: IFFALSE 97296
97076: GO 97078
97078: DISABLE
97079: LD_INT 0
97081: PPUSH
97082: PPUSH
97083: PPUSH
97084: PPUSH
97085: PPUSH
97086: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97087: LD_ADDR_VAR 0 6
97091: PUSH
97092: LD_INT 22
97094: PUSH
97095: LD_OWVAR 2
97099: PUSH
97100: EMPTY
97101: LIST
97102: LIST
97103: PUSH
97104: LD_INT 21
97106: PUSH
97107: LD_INT 1
97109: PUSH
97110: EMPTY
97111: LIST
97112: LIST
97113: PUSH
97114: LD_INT 3
97116: PUSH
97117: LD_INT 23
97119: PUSH
97120: LD_INT 0
97122: PUSH
97123: EMPTY
97124: LIST
97125: LIST
97126: PUSH
97127: EMPTY
97128: LIST
97129: LIST
97130: PUSH
97131: EMPTY
97132: LIST
97133: LIST
97134: LIST
97135: PPUSH
97136: CALL_OW 69
97140: ST_TO_ADDR
// if not tmp then
97141: LD_VAR 0 6
97145: NOT
97146: IFFALSE 97150
// exit ;
97148: GO 97296
// s1 := rand ( 1 , 4 ) ;
97150: LD_ADDR_VAR 0 2
97154: PUSH
97155: LD_INT 1
97157: PPUSH
97158: LD_INT 4
97160: PPUSH
97161: CALL_OW 12
97165: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
97166: LD_ADDR_VAR 0 4
97170: PUSH
97171: LD_VAR 0 6
97175: PUSH
97176: LD_INT 1
97178: ARRAY
97179: PPUSH
97180: LD_VAR 0 2
97184: PPUSH
97185: CALL_OW 259
97189: ST_TO_ADDR
// if s1 = 1 then
97190: LD_VAR 0 2
97194: PUSH
97195: LD_INT 1
97197: EQUAL
97198: IFFALSE 97218
// s2 := rand ( 2 , 4 ) else
97200: LD_ADDR_VAR 0 3
97204: PUSH
97205: LD_INT 2
97207: PPUSH
97208: LD_INT 4
97210: PPUSH
97211: CALL_OW 12
97215: ST_TO_ADDR
97216: GO 97226
// s2 := 1 ;
97218: LD_ADDR_VAR 0 3
97222: PUSH
97223: LD_INT 1
97225: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
97226: LD_ADDR_VAR 0 5
97230: PUSH
97231: LD_VAR 0 6
97235: PUSH
97236: LD_INT 1
97238: ARRAY
97239: PPUSH
97240: LD_VAR 0 3
97244: PPUSH
97245: CALL_OW 259
97249: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
97250: LD_VAR 0 6
97254: PUSH
97255: LD_INT 1
97257: ARRAY
97258: PPUSH
97259: LD_VAR 0 2
97263: PPUSH
97264: LD_VAR 0 5
97268: PPUSH
97269: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
97273: LD_VAR 0 6
97277: PUSH
97278: LD_INT 1
97280: ARRAY
97281: PPUSH
97282: LD_VAR 0 3
97286: PPUSH
97287: LD_VAR 0 4
97291: PPUSH
97292: CALL_OW 237
// end ;
97296: PPOPN 6
97298: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
97299: LD_EXP 107
97303: PUSH
97304: LD_EXP 154
97308: AND
97309: IFFALSE 97388
97311: GO 97313
97313: DISABLE
97314: LD_INT 0
97316: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
97317: LD_ADDR_VAR 0 1
97321: PUSH
97322: LD_INT 22
97324: PUSH
97325: LD_OWVAR 2
97329: PUSH
97330: EMPTY
97331: LIST
97332: LIST
97333: PUSH
97334: LD_INT 30
97336: PUSH
97337: LD_INT 3
97339: PUSH
97340: EMPTY
97341: LIST
97342: LIST
97343: PUSH
97344: EMPTY
97345: LIST
97346: LIST
97347: PPUSH
97348: CALL_OW 69
97352: ST_TO_ADDR
// if not tmp then
97353: LD_VAR 0 1
97357: NOT
97358: IFFALSE 97362
// exit ;
97360: GO 97388
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97362: LD_VAR 0 1
97366: PUSH
97367: LD_INT 1
97369: PPUSH
97370: LD_VAR 0 1
97374: PPUSH
97375: CALL_OW 12
97379: ARRAY
97380: PPUSH
97381: LD_INT 1
97383: PPUSH
97384: CALL_OW 234
// end ;
97388: PPOPN 1
97390: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
97391: LD_EXP 107
97395: PUSH
97396: LD_EXP 155
97400: AND
97401: IFFALSE 97513
97403: GO 97405
97405: DISABLE
97406: LD_INT 0
97408: PPUSH
97409: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
97410: LD_ADDR_VAR 0 2
97414: PUSH
97415: LD_INT 22
97417: PUSH
97418: LD_OWVAR 2
97422: PUSH
97423: EMPTY
97424: LIST
97425: LIST
97426: PUSH
97427: LD_INT 2
97429: PUSH
97430: LD_INT 30
97432: PUSH
97433: LD_INT 27
97435: PUSH
97436: EMPTY
97437: LIST
97438: LIST
97439: PUSH
97440: LD_INT 30
97442: PUSH
97443: LD_INT 26
97445: PUSH
97446: EMPTY
97447: LIST
97448: LIST
97449: PUSH
97450: LD_INT 30
97452: PUSH
97453: LD_INT 28
97455: PUSH
97456: EMPTY
97457: LIST
97458: LIST
97459: PUSH
97460: EMPTY
97461: LIST
97462: LIST
97463: LIST
97464: LIST
97465: PUSH
97466: EMPTY
97467: LIST
97468: LIST
97469: PPUSH
97470: CALL_OW 69
97474: ST_TO_ADDR
// if not tmp then
97475: LD_VAR 0 2
97479: NOT
97480: IFFALSE 97484
// exit ;
97482: GO 97513
// for i in tmp do
97484: LD_ADDR_VAR 0 1
97488: PUSH
97489: LD_VAR 0 2
97493: PUSH
97494: FOR_IN
97495: IFFALSE 97511
// SetLives ( i , 1 ) ;
97497: LD_VAR 0 1
97501: PPUSH
97502: LD_INT 1
97504: PPUSH
97505: CALL_OW 234
97509: GO 97494
97511: POP
97512: POP
// end ;
97513: PPOPN 2
97515: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
97516: LD_EXP 107
97520: PUSH
97521: LD_EXP 156
97525: AND
97526: IFFALSE 97800
97528: GO 97530
97530: DISABLE
97531: LD_INT 0
97533: PPUSH
97534: PPUSH
97535: PPUSH
// begin i := rand ( 1 , 7 ) ;
97536: LD_ADDR_VAR 0 1
97540: PUSH
97541: LD_INT 1
97543: PPUSH
97544: LD_INT 7
97546: PPUSH
97547: CALL_OW 12
97551: ST_TO_ADDR
// case i of 1 :
97552: LD_VAR 0 1
97556: PUSH
97557: LD_INT 1
97559: DOUBLE
97560: EQUAL
97561: IFTRUE 97565
97563: GO 97575
97565: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
97566: LD_STRING earthquake(getX(game), 0, 32)
97568: PPUSH
97569: CALL_OW 559
97573: GO 97800
97575: LD_INT 2
97577: DOUBLE
97578: EQUAL
97579: IFTRUE 97583
97581: GO 97597
97583: POP
// begin ToLua ( displayStucuk(); ) ;
97584: LD_STRING displayStucuk();
97586: PPUSH
97587: CALL_OW 559
// ResetFog ;
97591: CALL_OW 335
// end ; 3 :
97595: GO 97800
97597: LD_INT 3
97599: DOUBLE
97600: EQUAL
97601: IFTRUE 97605
97603: GO 97709
97605: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97606: LD_ADDR_VAR 0 2
97610: PUSH
97611: LD_INT 22
97613: PUSH
97614: LD_OWVAR 2
97618: PUSH
97619: EMPTY
97620: LIST
97621: LIST
97622: PUSH
97623: LD_INT 25
97625: PUSH
97626: LD_INT 1
97628: PUSH
97629: EMPTY
97630: LIST
97631: LIST
97632: PUSH
97633: EMPTY
97634: LIST
97635: LIST
97636: PPUSH
97637: CALL_OW 69
97641: ST_TO_ADDR
// if not tmp then
97642: LD_VAR 0 2
97646: NOT
97647: IFFALSE 97651
// exit ;
97649: GO 97800
// un := tmp [ rand ( 1 , tmp ) ] ;
97651: LD_ADDR_VAR 0 3
97655: PUSH
97656: LD_VAR 0 2
97660: PUSH
97661: LD_INT 1
97663: PPUSH
97664: LD_VAR 0 2
97668: PPUSH
97669: CALL_OW 12
97673: ARRAY
97674: ST_TO_ADDR
// if Crawls ( un ) then
97675: LD_VAR 0 3
97679: PPUSH
97680: CALL_OW 318
97684: IFFALSE 97695
// ComWalk ( un ) ;
97686: LD_VAR 0 3
97690: PPUSH
97691: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97695: LD_VAR 0 3
97699: PPUSH
97700: LD_INT 8
97702: PPUSH
97703: CALL_OW 336
// end ; 4 :
97707: GO 97800
97709: LD_INT 4
97711: DOUBLE
97712: EQUAL
97713: IFTRUE 97717
97715: GO 97778
97717: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97718: LD_ADDR_VAR 0 2
97722: PUSH
97723: LD_INT 22
97725: PUSH
97726: LD_OWVAR 2
97730: PUSH
97731: EMPTY
97732: LIST
97733: LIST
97734: PUSH
97735: LD_INT 30
97737: PUSH
97738: LD_INT 29
97740: PUSH
97741: EMPTY
97742: LIST
97743: LIST
97744: PUSH
97745: EMPTY
97746: LIST
97747: LIST
97748: PPUSH
97749: CALL_OW 69
97753: ST_TO_ADDR
// if not tmp then
97754: LD_VAR 0 2
97758: NOT
97759: IFFALSE 97763
// exit ;
97761: GO 97800
// DestroyUnit ( tmp [ 1 ] ) ;
97763: LD_VAR 0 2
97767: PUSH
97768: LD_INT 1
97770: ARRAY
97771: PPUSH
97772: CALL_OW 65
// end ; 5 .. 7 :
97776: GO 97800
97778: LD_INT 5
97780: DOUBLE
97781: GREATEREQUAL
97782: IFFALSE 97790
97784: LD_INT 7
97786: DOUBLE
97787: LESSEQUAL
97788: IFTRUE 97792
97790: GO 97799
97792: POP
// StreamSibBomb ; end ;
97793: CALL 94080 0 0
97797: GO 97800
97799: POP
// end ;
97800: PPOPN 3
97802: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
97803: LD_EXP 107
97807: PUSH
97808: LD_EXP 157
97812: AND
97813: IFFALSE 97969
97815: GO 97817
97817: DISABLE
97818: LD_INT 0
97820: PPUSH
97821: PPUSH
97822: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
97823: LD_ADDR_VAR 0 2
97827: PUSH
97828: LD_INT 81
97830: PUSH
97831: LD_OWVAR 2
97835: PUSH
97836: EMPTY
97837: LIST
97838: LIST
97839: PUSH
97840: LD_INT 2
97842: PUSH
97843: LD_INT 21
97845: PUSH
97846: LD_INT 1
97848: PUSH
97849: EMPTY
97850: LIST
97851: LIST
97852: PUSH
97853: LD_INT 21
97855: PUSH
97856: LD_INT 2
97858: PUSH
97859: EMPTY
97860: LIST
97861: LIST
97862: PUSH
97863: EMPTY
97864: LIST
97865: LIST
97866: LIST
97867: PUSH
97868: EMPTY
97869: LIST
97870: LIST
97871: PPUSH
97872: CALL_OW 69
97876: ST_TO_ADDR
// if not tmp then
97877: LD_VAR 0 2
97881: NOT
97882: IFFALSE 97886
// exit ;
97884: GO 97969
// p := 0 ;
97886: LD_ADDR_VAR 0 3
97890: PUSH
97891: LD_INT 0
97893: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97894: LD_INT 35
97896: PPUSH
97897: CALL_OW 67
// p := p + 1 ;
97901: LD_ADDR_VAR 0 3
97905: PUSH
97906: LD_VAR 0 3
97910: PUSH
97911: LD_INT 1
97913: PLUS
97914: ST_TO_ADDR
// for i in tmp do
97915: LD_ADDR_VAR 0 1
97919: PUSH
97920: LD_VAR 0 2
97924: PUSH
97925: FOR_IN
97926: IFFALSE 97957
// if GetLives ( i ) < 1000 then
97928: LD_VAR 0 1
97932: PPUSH
97933: CALL_OW 256
97937: PUSH
97938: LD_INT 1000
97940: LESS
97941: IFFALSE 97955
// SetLives ( i , 1000 ) ;
97943: LD_VAR 0 1
97947: PPUSH
97948: LD_INT 1000
97950: PPUSH
97951: CALL_OW 234
97955: GO 97925
97957: POP
97958: POP
// until p > 20 ;
97959: LD_VAR 0 3
97963: PUSH
97964: LD_INT 20
97966: GREATER
97967: IFFALSE 97894
// end ;
97969: PPOPN 3
97971: END
// every 0 0$1 trigger StreamModeActive and sTime do
97972: LD_EXP 107
97976: PUSH
97977: LD_EXP 158
97981: AND
97982: IFFALSE 98017
97984: GO 97986
97986: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
97987: LD_INT 28
97989: PPUSH
97990: LD_OWVAR 2
97994: PPUSH
97995: LD_INT 2
97997: PPUSH
97998: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
98002: LD_INT 30
98004: PPUSH
98005: LD_OWVAR 2
98009: PPUSH
98010: LD_INT 2
98012: PPUSH
98013: CALL_OW 322
// end ;
98017: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
98018: LD_EXP 107
98022: PUSH
98023: LD_EXP 159
98027: AND
98028: IFFALSE 98149
98030: GO 98032
98032: DISABLE
98033: LD_INT 0
98035: PPUSH
98036: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98037: LD_ADDR_VAR 0 2
98041: PUSH
98042: LD_INT 22
98044: PUSH
98045: LD_OWVAR 2
98049: PUSH
98050: EMPTY
98051: LIST
98052: LIST
98053: PUSH
98054: LD_INT 21
98056: PUSH
98057: LD_INT 1
98059: PUSH
98060: EMPTY
98061: LIST
98062: LIST
98063: PUSH
98064: LD_INT 3
98066: PUSH
98067: LD_INT 23
98069: PUSH
98070: LD_INT 0
98072: PUSH
98073: EMPTY
98074: LIST
98075: LIST
98076: PUSH
98077: EMPTY
98078: LIST
98079: LIST
98080: PUSH
98081: EMPTY
98082: LIST
98083: LIST
98084: LIST
98085: PPUSH
98086: CALL_OW 69
98090: ST_TO_ADDR
// if not tmp then
98091: LD_VAR 0 2
98095: NOT
98096: IFFALSE 98100
// exit ;
98098: GO 98149
// for i in tmp do
98100: LD_ADDR_VAR 0 1
98104: PUSH
98105: LD_VAR 0 2
98109: PUSH
98110: FOR_IN
98111: IFFALSE 98147
// begin if Crawls ( i ) then
98113: LD_VAR 0 1
98117: PPUSH
98118: CALL_OW 318
98122: IFFALSE 98133
// ComWalk ( i ) ;
98124: LD_VAR 0 1
98128: PPUSH
98129: CALL_OW 138
// SetClass ( i , 2 ) ;
98133: LD_VAR 0 1
98137: PPUSH
98138: LD_INT 2
98140: PPUSH
98141: CALL_OW 336
// end ;
98145: GO 98110
98147: POP
98148: POP
// end ;
98149: PPOPN 2
98151: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
98152: LD_EXP 107
98156: PUSH
98157: LD_EXP 160
98161: AND
98162: IFFALSE 98443
98164: GO 98166
98166: DISABLE
98167: LD_INT 0
98169: PPUSH
98170: PPUSH
98171: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
98172: LD_OWVAR 2
98176: PPUSH
98177: LD_INT 9
98179: PPUSH
98180: LD_INT 1
98182: PPUSH
98183: LD_INT 1
98185: PPUSH
98186: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
98190: LD_INT 9
98192: PPUSH
98193: LD_OWVAR 2
98197: PPUSH
98198: CALL_OW 343
// uc_side := 9 ;
98202: LD_ADDR_OWVAR 20
98206: PUSH
98207: LD_INT 9
98209: ST_TO_ADDR
// uc_nation := 2 ;
98210: LD_ADDR_OWVAR 21
98214: PUSH
98215: LD_INT 2
98217: ST_TO_ADDR
// hc_name := Dark Warrior ;
98218: LD_ADDR_OWVAR 26
98222: PUSH
98223: LD_STRING Dark Warrior
98225: ST_TO_ADDR
// hc_gallery :=  ;
98226: LD_ADDR_OWVAR 33
98230: PUSH
98231: LD_STRING 
98233: ST_TO_ADDR
// hc_noskilllimit := true ;
98234: LD_ADDR_OWVAR 76
98238: PUSH
98239: LD_INT 1
98241: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
98242: LD_ADDR_OWVAR 31
98246: PUSH
98247: LD_INT 30
98249: PUSH
98250: LD_INT 30
98252: PUSH
98253: LD_INT 30
98255: PUSH
98256: LD_INT 30
98258: PUSH
98259: EMPTY
98260: LIST
98261: LIST
98262: LIST
98263: LIST
98264: ST_TO_ADDR
// un := CreateHuman ;
98265: LD_ADDR_VAR 0 3
98269: PUSH
98270: CALL_OW 44
98274: ST_TO_ADDR
// hc_noskilllimit := false ;
98275: LD_ADDR_OWVAR 76
98279: PUSH
98280: LD_INT 0
98282: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98283: LD_VAR 0 3
98287: PPUSH
98288: LD_INT 1
98290: PPUSH
98291: CALL_OW 51
// p := 0 ;
98295: LD_ADDR_VAR 0 2
98299: PUSH
98300: LD_INT 0
98302: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98303: LD_INT 35
98305: PPUSH
98306: CALL_OW 67
// p := p + 1 ;
98310: LD_ADDR_VAR 0 2
98314: PUSH
98315: LD_VAR 0 2
98319: PUSH
98320: LD_INT 1
98322: PLUS
98323: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
98324: LD_VAR 0 3
98328: PPUSH
98329: CALL_OW 256
98333: PUSH
98334: LD_INT 1000
98336: LESS
98337: IFFALSE 98351
// SetLives ( un , 1000 ) ;
98339: LD_VAR 0 3
98343: PPUSH
98344: LD_INT 1000
98346: PPUSH
98347: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
98351: LD_VAR 0 3
98355: PPUSH
98356: LD_INT 81
98358: PUSH
98359: LD_OWVAR 2
98363: PUSH
98364: EMPTY
98365: LIST
98366: LIST
98367: PUSH
98368: LD_INT 91
98370: PUSH
98371: LD_VAR 0 3
98375: PUSH
98376: LD_INT 30
98378: PUSH
98379: EMPTY
98380: LIST
98381: LIST
98382: LIST
98383: PUSH
98384: EMPTY
98385: LIST
98386: LIST
98387: PPUSH
98388: CALL_OW 69
98392: PPUSH
98393: LD_VAR 0 3
98397: PPUSH
98398: CALL_OW 74
98402: PPUSH
98403: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
98407: LD_VAR 0 2
98411: PUSH
98412: LD_INT 60
98414: GREATER
98415: PUSH
98416: LD_VAR 0 3
98420: PPUSH
98421: CALL_OW 301
98425: OR
98426: IFFALSE 98303
// if un then
98428: LD_VAR 0 3
98432: IFFALSE 98443
// RemoveUnit ( un ) ;
98434: LD_VAR 0 3
98438: PPUSH
98439: CALL_OW 64
// end ; end_of_file
98443: PPOPN 3
98445: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
98446: LD_INT 0
98448: PPUSH
98449: PPUSH
98450: PPUSH
98451: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
98452: LD_VAR 0 1
98456: PPUSH
98457: CALL_OW 264
98461: PUSH
98462: LD_EXP 106
98466: EQUAL
98467: IFFALSE 98539
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
98469: LD_INT 68
98471: PPUSH
98472: LD_VAR 0 1
98476: PPUSH
98477: CALL_OW 255
98481: PPUSH
98482: CALL_OW 321
98486: PUSH
98487: LD_INT 2
98489: EQUAL
98490: IFFALSE 98502
// eff := 70 else
98492: LD_ADDR_VAR 0 6
98496: PUSH
98497: LD_INT 70
98499: ST_TO_ADDR
98500: GO 98510
// eff := 30 ;
98502: LD_ADDR_VAR 0 6
98506: PUSH
98507: LD_INT 30
98509: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
98510: LD_VAR 0 1
98514: PPUSH
98515: CALL_OW 250
98519: PPUSH
98520: LD_VAR 0 1
98524: PPUSH
98525: CALL_OW 251
98529: PPUSH
98530: LD_VAR 0 6
98534: PPUSH
98535: CALL_OW 495
// end ; end ;
98539: LD_VAR 0 4
98543: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
98544: LD_INT 0
98546: PPUSH
98547: PPUSH
98548: PPUSH
98549: PPUSH
98550: PPUSH
98551: PPUSH
// if cmd = 124 then
98552: LD_VAR 0 1
98556: PUSH
98557: LD_INT 124
98559: EQUAL
98560: IFFALSE 98766
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
98562: LD_ADDR_VAR 0 5
98566: PUSH
98567: LD_INT 2
98569: PUSH
98570: LD_INT 34
98572: PUSH
98573: LD_INT 53
98575: PUSH
98576: EMPTY
98577: LIST
98578: LIST
98579: PUSH
98580: LD_INT 34
98582: PUSH
98583: LD_INT 14
98585: PUSH
98586: EMPTY
98587: LIST
98588: LIST
98589: PUSH
98590: EMPTY
98591: LIST
98592: LIST
98593: LIST
98594: PPUSH
98595: CALL_OW 69
98599: ST_TO_ADDR
// if not tmp then
98600: LD_VAR 0 5
98604: NOT
98605: IFFALSE 98609
// exit ;
98607: GO 98766
// for i in tmp do
98609: LD_ADDR_VAR 0 3
98613: PUSH
98614: LD_VAR 0 5
98618: PUSH
98619: FOR_IN
98620: IFFALSE 98764
// begin taskList := GetTaskList ( i ) ;
98622: LD_ADDR_VAR 0 6
98626: PUSH
98627: LD_VAR 0 3
98631: PPUSH
98632: CALL_OW 437
98636: ST_TO_ADDR
// if not taskList then
98637: LD_VAR 0 6
98641: NOT
98642: IFFALSE 98646
// continue ;
98644: GO 98619
// for j = 1 to taskList do
98646: LD_ADDR_VAR 0 4
98650: PUSH
98651: DOUBLE
98652: LD_INT 1
98654: DEC
98655: ST_TO_ADDR
98656: LD_VAR 0 6
98660: PUSH
98661: FOR_TO
98662: IFFALSE 98760
// if taskList [ j ] [ 1 ] = | then
98664: LD_VAR 0 6
98668: PUSH
98669: LD_VAR 0 4
98673: ARRAY
98674: PUSH
98675: LD_INT 1
98677: ARRAY
98678: PUSH
98679: LD_STRING |
98681: EQUAL
98682: IFFALSE 98758
// begin _taskList := Delete ( taskList , 1 ) ;
98684: LD_ADDR_VAR 0 7
98688: PUSH
98689: LD_VAR 0 6
98693: PPUSH
98694: LD_INT 1
98696: PPUSH
98697: CALL_OW 3
98701: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
98702: LD_VAR 0 3
98706: PPUSH
98707: LD_VAR 0 7
98711: PPUSH
98712: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
98716: LD_VAR 0 3
98720: PPUSH
98721: LD_VAR 0 6
98725: PUSH
98726: LD_VAR 0 4
98730: ARRAY
98731: PUSH
98732: LD_INT 2
98734: ARRAY
98735: PPUSH
98736: LD_VAR 0 6
98740: PUSH
98741: LD_VAR 0 4
98745: ARRAY
98746: PUSH
98747: LD_INT 3
98749: ARRAY
98750: PPUSH
98751: LD_INT 8
98753: PPUSH
98754: CALL 98771 0 4
// end ;
98758: GO 98661
98760: POP
98761: POP
// end ;
98762: GO 98619
98764: POP
98765: POP
// end ; end ;
98766: LD_VAR 0 2
98770: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
98771: LD_INT 0
98773: PPUSH
98774: PPUSH
98775: PPUSH
98776: PPUSH
98777: PPUSH
98778: PPUSH
98779: PPUSH
98780: PPUSH
98781: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
98782: LD_VAR 0 1
98786: NOT
98787: PUSH
98788: LD_VAR 0 2
98792: PPUSH
98793: LD_VAR 0 3
98797: PPUSH
98798: CALL_OW 488
98802: NOT
98803: OR
98804: PUSH
98805: LD_VAR 0 4
98809: NOT
98810: OR
98811: IFFALSE 98815
// exit ;
98813: GO 99155
// list := [ ] ;
98815: LD_ADDR_VAR 0 13
98819: PUSH
98820: EMPTY
98821: ST_TO_ADDR
// if x - r < 0 then
98822: LD_VAR 0 2
98826: PUSH
98827: LD_VAR 0 4
98831: MINUS
98832: PUSH
98833: LD_INT 0
98835: LESS
98836: IFFALSE 98848
// min_x := 0 else
98838: LD_ADDR_VAR 0 7
98842: PUSH
98843: LD_INT 0
98845: ST_TO_ADDR
98846: GO 98864
// min_x := x - r ;
98848: LD_ADDR_VAR 0 7
98852: PUSH
98853: LD_VAR 0 2
98857: PUSH
98858: LD_VAR 0 4
98862: MINUS
98863: ST_TO_ADDR
// if y - r < 0 then
98864: LD_VAR 0 3
98868: PUSH
98869: LD_VAR 0 4
98873: MINUS
98874: PUSH
98875: LD_INT 0
98877: LESS
98878: IFFALSE 98890
// min_y := 0 else
98880: LD_ADDR_VAR 0 8
98884: PUSH
98885: LD_INT 0
98887: ST_TO_ADDR
98888: GO 98906
// min_y := y - r ;
98890: LD_ADDR_VAR 0 8
98894: PUSH
98895: LD_VAR 0 3
98899: PUSH
98900: LD_VAR 0 4
98904: MINUS
98905: ST_TO_ADDR
// max_x := x + r ;
98906: LD_ADDR_VAR 0 9
98910: PUSH
98911: LD_VAR 0 2
98915: PUSH
98916: LD_VAR 0 4
98920: PLUS
98921: ST_TO_ADDR
// max_y := y + r ;
98922: LD_ADDR_VAR 0 10
98926: PUSH
98927: LD_VAR 0 3
98931: PUSH
98932: LD_VAR 0 4
98936: PLUS
98937: ST_TO_ADDR
// for _x = min_x to max_x do
98938: LD_ADDR_VAR 0 11
98942: PUSH
98943: DOUBLE
98944: LD_VAR 0 7
98948: DEC
98949: ST_TO_ADDR
98950: LD_VAR 0 9
98954: PUSH
98955: FOR_TO
98956: IFFALSE 99073
// for _y = min_y to max_y do
98958: LD_ADDR_VAR 0 12
98962: PUSH
98963: DOUBLE
98964: LD_VAR 0 8
98968: DEC
98969: ST_TO_ADDR
98970: LD_VAR 0 10
98974: PUSH
98975: FOR_TO
98976: IFFALSE 99069
// begin if not ValidHex ( _x , _y ) then
98978: LD_VAR 0 11
98982: PPUSH
98983: LD_VAR 0 12
98987: PPUSH
98988: CALL_OW 488
98992: NOT
98993: IFFALSE 98997
// continue ;
98995: GO 98975
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
98997: LD_VAR 0 11
99001: PPUSH
99002: LD_VAR 0 12
99006: PPUSH
99007: CALL_OW 351
99011: PUSH
99012: LD_VAR 0 11
99016: PPUSH
99017: LD_VAR 0 12
99021: PPUSH
99022: CALL_OW 554
99026: AND
99027: IFFALSE 99067
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
99029: LD_ADDR_VAR 0 13
99033: PUSH
99034: LD_VAR 0 13
99038: PPUSH
99039: LD_VAR 0 13
99043: PUSH
99044: LD_INT 1
99046: PLUS
99047: PPUSH
99048: LD_VAR 0 11
99052: PUSH
99053: LD_VAR 0 12
99057: PUSH
99058: EMPTY
99059: LIST
99060: LIST
99061: PPUSH
99062: CALL_OW 2
99066: ST_TO_ADDR
// end ;
99067: GO 98975
99069: POP
99070: POP
99071: GO 98955
99073: POP
99074: POP
// if not list then
99075: LD_VAR 0 13
99079: NOT
99080: IFFALSE 99084
// exit ;
99082: GO 99155
// for i in list do
99084: LD_ADDR_VAR 0 6
99088: PUSH
99089: LD_VAR 0 13
99093: PUSH
99094: FOR_IN
99095: IFFALSE 99153
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
99097: LD_VAR 0 1
99101: PPUSH
99102: LD_STRING M
99104: PUSH
99105: LD_VAR 0 6
99109: PUSH
99110: LD_INT 1
99112: ARRAY
99113: PUSH
99114: LD_VAR 0 6
99118: PUSH
99119: LD_INT 2
99121: ARRAY
99122: PUSH
99123: LD_INT 0
99125: PUSH
99126: LD_INT 0
99128: PUSH
99129: LD_INT 0
99131: PUSH
99132: LD_INT 0
99134: PUSH
99135: EMPTY
99136: LIST
99137: LIST
99138: LIST
99139: LIST
99140: LIST
99141: LIST
99142: LIST
99143: PUSH
99144: EMPTY
99145: LIST
99146: PPUSH
99147: CALL_OW 447
99151: GO 99094
99153: POP
99154: POP
// end ;
99155: LD_VAR 0 5
99159: RET
