// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 58667 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 50814 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 50814 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 50814 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 50814 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4551 0 0
// PrepareRussian ;
 189: CALL 2989 0 0
// PrepareAlliance ;
 193: CALL 911 0 0
// MC_Start ( ) ;
 197: CALL 60847 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 8507 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 85
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 86
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 82564 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 56
 294: PPUSH
 295: CALL 83009 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 83467 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 83736 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 82949 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 83643 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 53
 401: PPUSH
 402: CALL 83009 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 83467 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 83736 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 82793 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 84054 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 82949 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 6
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 7
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 54
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 8
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 9
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ar_attackers := [ ] ;
 775: LD_ADDR_EXP 11
 779: PUSH
 780: EMPTY
 781: ST_TO_ADDR
// first_powell_attack := false ;
 782: LD_ADDR_EXP 12
 786: PUSH
 787: LD_INT 0
 789: ST_TO_ADDR
// masha_killed := false ;
 790: LD_ADDR_EXP 10
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// abdul_escaped := true ;
 798: LD_ADDR_EXP 13
 802: PUSH
 803: LD_INT 1
 805: ST_TO_ADDR
// loss_counter := 0 ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 0
 813: ST_TO_ADDR
// hack_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// end ;
 822: LD_VAR 0 1
 826: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 827: LD_EXP 50
 831: PPUSH
 832: CALL_OW 255
 836: PUSH
 837: LD_INT 7
 839: EQUAL
 840: PUSH
 841: LD_EXP 49
 845: PPUSH
 846: CALL_OW 255
 850: PUSH
 851: LD_INT 7
 853: EQUAL
 854: AND
 855: PUSH
 856: LD_EXP 50
 860: PPUSH
 861: CALL_OW 302
 865: AND
 866: PUSH
 867: LD_EXP 49
 871: PPUSH
 872: CALL_OW 302
 876: AND
 877: IFFALSE 889
 879: GO 881
 881: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 882: LD_STRING ACH_COMRADE
 884: PPUSH
 885: CALL_OW 543
 889: END
// every 0 0$1 trigger hack_counter >= 10 do
 890: LD_EXP 15
 894: PUSH
 895: LD_INT 10
 897: GREATEREQUAL
 898: IFFALSE 910
 900: GO 902
 902: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 903: LD_STRING ACH_HACK
 905: PPUSH
 906: CALL_OW 543
 910: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 911: LD_INT 0
 913: PPUSH
 914: PPUSH
 915: PPUSH
 916: PPUSH
// uc_side := 7 ;
 917: LD_ADDR_OWVAR 20
 921: PUSH
 922: LD_INT 7
 924: ST_TO_ADDR
// uc_nation := 1 ;
 925: LD_ADDR_OWVAR 21
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 933: LD_ADDR_EXP 16
 937: PUSH
 938: LD_STRING JMM
 940: PPUSH
 941: LD_EXP 1
 945: NOT
 946: PPUSH
 947: LD_STRING 12a_
 949: PPUSH
 950: CALL 16435 0 3
 954: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 955: LD_EXP 16
 959: PPUSH
 960: LD_INT 71
 962: PPUSH
 963: LD_INT 23
 965: PPUSH
 966: LD_INT 0
 968: PPUSH
 969: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 973: LD_EXP 16
 977: PPUSH
 978: LD_INT 2
 980: PPUSH
 981: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 985: LD_ADDR_EXP 17
 989: PUSH
 990: LD_STRING Roth
 992: PPUSH
 993: LD_EXP 1
 997: NOT
 998: PPUSH
 999: LD_STRING 12a_
1001: PPUSH
1002: CALL 16435 0 3
1006: ST_TO_ADDR
// if Roth then
1007: LD_EXP 17
1011: IFFALSE 1031
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1013: LD_EXP 17
1017: PPUSH
1018: LD_INT 71
1020: PPUSH
1021: LD_INT 21
1023: PPUSH
1024: LD_INT 0
1026: PPUSH
1027: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1031: LD_ADDR_EXP 33
1035: PUSH
1036: LD_STRING Mike
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_STRING 12a_
1047: PPUSH
1048: CALL 16435 0 3
1052: ST_TO_ADDR
// if Mike then
1053: LD_EXP 33
1057: IFFALSE 1074
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1059: LD_EXP 33
1063: PPUSH
1064: LD_INT 13
1066: PPUSH
1067: LD_INT 0
1069: PPUSH
1070: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1074: LD_ADDR_EXP 18
1078: PUSH
1079: LD_STRING Lisa
1081: PPUSH
1082: LD_EXP 1
1086: NOT
1087: PPUSH
1088: LD_STRING 12a_
1090: PPUSH
1091: CALL 16435 0 3
1095: ST_TO_ADDR
// if Lisa then
1096: LD_EXP 18
1100: IFFALSE 1117
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1102: LD_EXP 18
1106: PPUSH
1107: LD_INT 13
1109: PPUSH
1110: LD_INT 0
1112: PPUSH
1113: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1117: LD_ADDR_EXP 19
1121: PUSH
1122: LD_STRING Donaldson
1124: PPUSH
1125: LD_EXP 1
1129: NOT
1130: PPUSH
1131: LD_STRING 12a_
1133: PPUSH
1134: CALL 16435 0 3
1138: ST_TO_ADDR
// if Donaldson then
1139: LD_EXP 19
1143: IFFALSE 1160
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1145: LD_EXP 19
1149: PPUSH
1150: LD_INT 13
1152: PPUSH
1153: LD_INT 0
1155: PPUSH
1156: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1160: LD_ADDR_EXP 20
1164: PUSH
1165: LD_STRING Bobby
1167: PPUSH
1168: LD_EXP 1
1172: NOT
1173: PPUSH
1174: LD_STRING 12a_
1176: PPUSH
1177: CALL 16435 0 3
1181: ST_TO_ADDR
// if Bobby then
1182: LD_EXP 20
1186: IFFALSE 1203
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1188: LD_EXP 20
1192: PPUSH
1193: LD_INT 13
1195: PPUSH
1196: LD_INT 0
1198: PPUSH
1199: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1203: LD_ADDR_EXP 21
1207: PUSH
1208: LD_STRING Cyrus
1210: PPUSH
1211: LD_EXP 1
1215: NOT
1216: PPUSH
1217: LD_STRING 12a_
1219: PPUSH
1220: CALL 16435 0 3
1224: ST_TO_ADDR
// if Cyrus then
1225: LD_EXP 21
1229: IFFALSE 1246
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1231: LD_EXP 21
1235: PPUSH
1236: LD_INT 13
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1246: LD_ADDR_EXP 22
1250: PUSH
1251: LD_STRING Denis
1253: PPUSH
1254: LD_EXP 1
1258: NOT
1259: PPUSH
1260: LD_STRING 12a_
1262: PPUSH
1263: CALL 16435 0 3
1267: ST_TO_ADDR
// if Denis then
1268: LD_EXP 22
1272: IFFALSE 1289
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1274: LD_EXP 22
1278: PPUSH
1279: LD_INT 13
1281: PPUSH
1282: LD_INT 0
1284: PPUSH
1285: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1289: LD_ADDR_EXP 23
1293: PUSH
1294: LD_STRING Brown
1296: PPUSH
1297: LD_EXP 1
1301: NOT
1302: PPUSH
1303: LD_STRING 12a_
1305: PPUSH
1306: CALL 16435 0 3
1310: ST_TO_ADDR
// if Brown then
1311: LD_EXP 23
1315: IFFALSE 1332
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1317: LD_EXP 23
1321: PPUSH
1322: LD_INT 13
1324: PPUSH
1325: LD_INT 0
1327: PPUSH
1328: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1332: LD_ADDR_EXP 24
1336: PUSH
1337: LD_STRING Gladstone
1339: PPUSH
1340: LD_EXP 1
1344: NOT
1345: PPUSH
1346: LD_STRING 12a_
1348: PPUSH
1349: CALL 16435 0 3
1353: ST_TO_ADDR
// if Gladstone then
1354: LD_EXP 24
1358: IFFALSE 1375
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1360: LD_EXP 24
1364: PPUSH
1365: LD_INT 13
1367: PPUSH
1368: LD_INT 0
1370: PPUSH
1371: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1375: LD_ADDR_EXP 25
1379: PUSH
1380: LD_STRING Houten
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_STRING 12a_
1391: PPUSH
1392: CALL 16435 0 3
1396: ST_TO_ADDR
// if Houten then
1397: LD_EXP 25
1401: IFFALSE 1418
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1403: LD_EXP 25
1407: PPUSH
1408: LD_INT 13
1410: PPUSH
1411: LD_INT 0
1413: PPUSH
1414: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1418: LD_ADDR_EXP 26
1422: PUSH
1423: LD_STRING Cornell
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: LD_STRING 12a_
1434: PPUSH
1435: CALL 16435 0 3
1439: ST_TO_ADDR
// if Cornel then
1440: LD_EXP 26
1444: IFFALSE 1461
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1446: LD_EXP 26
1450: PPUSH
1451: LD_INT 13
1453: PPUSH
1454: LD_INT 0
1456: PPUSH
1457: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1461: LD_ADDR_EXP 27
1465: PUSH
1466: LD_STRING Gary
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: LD_STRING 12a_
1477: PPUSH
1478: CALL 16435 0 3
1482: ST_TO_ADDR
// if Gary then
1483: LD_EXP 27
1487: IFFALSE 1504
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1489: LD_EXP 27
1493: PPUSH
1494: LD_INT 13
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1504: LD_ADDR_EXP 28
1508: PUSH
1509: LD_STRING Frank
1511: PPUSH
1512: LD_EXP 1
1516: NOT
1517: PPUSH
1518: LD_STRING 12a_
1520: PPUSH
1521: CALL 16435 0 3
1525: ST_TO_ADDR
// if Frank then
1526: LD_EXP 28
1530: IFFALSE 1547
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1532: LD_EXP 28
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: LD_INT 0
1542: PPUSH
1543: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1547: LD_ADDR_EXP 29
1551: PUSH
1552: LD_STRING Kikuchi
1554: PPUSH
1555: LD_EXP 1
1559: NOT
1560: PPUSH
1561: LD_STRING 12a_
1563: PPUSH
1564: CALL 16435 0 3
1568: ST_TO_ADDR
// if Kikuchi then
1569: LD_EXP 29
1573: IFFALSE 1590
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1575: LD_EXP 29
1579: PPUSH
1580: LD_INT 13
1582: PPUSH
1583: LD_INT 0
1585: PPUSH
1586: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1590: LD_ADDR_EXP 30
1594: PUSH
1595: LD_STRING Simms
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 12a_
1606: PPUSH
1607: CALL 16435 0 3
1611: ST_TO_ADDR
// if Simms then
1612: LD_EXP 30
1616: IFFALSE 1633
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1618: LD_EXP 30
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1633: LD_ADDR_EXP 31
1637: PUSH
1638: LD_STRING Joan
1640: PPUSH
1641: LD_EXP 1
1645: NOT
1646: PPUSH
1647: LD_STRING 12a_
1649: PPUSH
1650: CALL 16435 0 3
1654: ST_TO_ADDR
// if Joan then
1655: LD_EXP 31
1659: IFFALSE 1676
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1661: LD_EXP 31
1665: PPUSH
1666: LD_INT 13
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1676: LD_ADDR_EXP 32
1680: PUSH
1681: LD_STRING DeltaDoctor
1683: PPUSH
1684: LD_EXP 1
1688: NOT
1689: PPUSH
1690: LD_STRING 12a_
1692: PPUSH
1693: CALL 16435 0 3
1697: ST_TO_ADDR
// if DeltaDoctor then
1698: LD_EXP 32
1702: IFFALSE 1719
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1704: LD_EXP 32
1708: PPUSH
1709: LD_INT 13
1711: PPUSH
1712: LD_INT 0
1714: PPUSH
1715: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: LD_STRING 12a_others
1726: PPUSH
1727: CALL_OW 31
1731: ST_TO_ADDR
// if tmp then
1732: LD_VAR 0 4
1736: IFFALSE 1770
// for i in tmp do
1738: LD_ADDR_VAR 0 3
1742: PUSH
1743: LD_VAR 0 4
1747: PUSH
1748: FOR_IN
1749: IFFALSE 1768
// PlaceUnitArea ( i , alliance_start , false ) ;
1751: LD_VAR 0 3
1755: PPUSH
1756: LD_INT 13
1758: PPUSH
1759: LD_INT 0
1761: PPUSH
1762: CALL_OW 49
1766: GO 1748
1768: POP
1769: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1770: LD_INT 3
1772: PPUSH
1773: LD_INT 3
1775: PPUSH
1776: LD_INT 3
1778: PPUSH
1779: LD_INT 12
1781: PPUSH
1782: LD_INT 100
1784: PPUSH
1785: CALL 21275 0 5
// veh := CreateVehicle ;
1789: LD_ADDR_VAR 0 2
1793: PUSH
1794: CALL_OW 45
1798: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1799: LD_VAR 0 2
1803: PPUSH
1804: LD_INT 2
1806: PPUSH
1807: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1811: LD_VAR 0 2
1815: PPUSH
1816: LD_INT 60
1818: PPUSH
1819: LD_INT 6
1821: PPUSH
1822: LD_INT 0
1824: PPUSH
1825: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1829: LD_VAR 0 2
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: LD_INT 30
1839: PPUSH
1840: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1844: LD_STRING 11_artifact_captured
1846: PPUSH
1847: LD_INT 0
1849: PPUSH
1850: CALL_OW 30
1854: IFFALSE 1930
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1856: LD_INT 3
1858: PPUSH
1859: LD_INT 3
1861: PPUSH
1862: LD_INT 3
1864: PPUSH
1865: LD_INT 12
1867: PPUSH
1868: LD_INT 100
1870: PPUSH
1871: CALL 21275 0 5
// veh := CreateVehicle ;
1875: LD_ADDR_VAR 0 2
1879: PUSH
1880: CALL_OW 45
1884: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1885: LD_VAR 0 2
1889: PPUSH
1890: LD_INT 3
1892: PPUSH
1893: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1897: LD_VAR 0 2
1901: PPUSH
1902: LD_INT 75
1904: PPUSH
1905: LD_INT 6
1907: PPUSH
1908: LD_INT 0
1910: PPUSH
1911: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1915: LD_VAR 0 2
1919: PPUSH
1920: LD_INT 4
1922: PPUSH
1923: LD_INT 50
1925: PPUSH
1926: CALL_OW 290
// end ; end ;
1930: LD_VAR 0 1
1934: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1935: LD_INT 0
1937: PPUSH
1938: PPUSH
1939: PPUSH
1940: PPUSH
// uc_side := 6 ;
1941: LD_ADDR_OWVAR 20
1945: PUSH
1946: LD_INT 6
1948: ST_TO_ADDR
// uc_nation := 3 ;
1949: LD_ADDR_OWVAR 21
1953: PUSH
1954: LD_INT 3
1956: ST_TO_ADDR
// InitHc ;
1957: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1961: LD_ADDR_EXP 34
1965: PUSH
1966: LD_STRING Gossudarov
1968: PPUSH
1969: CALL_OW 25
1973: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1974: LD_ADDR_EXP 35
1978: PUSH
1979: LD_STRING Kirilenkova
1981: PPUSH
1982: CALL_OW 25
1986: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1987: LD_ADDR_EXP 36
1991: PUSH
1992: LD_STRING Titov
1994: PPUSH
1995: CALL_OW 25
1999: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2000: LD_ADDR_EXP 41
2004: PUSH
2005: LD_STRING Oblukov
2007: PPUSH
2008: CALL_OW 25
2012: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2013: LD_ADDR_EXP 38
2017: PUSH
2018: LD_STRING Dolgov
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2026: LD_ADDR_EXP 39
2030: PUSH
2031: LD_STRING Petrosyan
2033: PPUSH
2034: CALL_OW 25
2038: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2039: LD_ADDR_EXP 40
2043: PUSH
2044: LD_STRING Scholtze
2046: PPUSH
2047: CALL_OW 25
2051: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2052: LD_ADDR_EXP 42
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: CALL_OW 25
2064: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2065: LD_ADDR_VAR 0 2
2069: PUSH
2070: LD_EXP 34
2074: PUSH
2075: LD_EXP 35
2079: PUSH
2080: LD_EXP 36
2084: PUSH
2085: LD_EXP 41
2089: PUSH
2090: LD_EXP 38
2094: PUSH
2095: LD_EXP 39
2099: PUSH
2100: LD_EXP 40
2104: PUSH
2105: LD_EXP 42
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: LIST
2116: LIST
2117: LIST
2118: LIST
2119: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2120: LD_INT 1
2122: PPUSH
2123: LD_INT 4
2125: PPUSH
2126: LD_INT 8
2128: PPUSH
2129: CALL_OW 380
// un := CreateHuman ;
2133: LD_ADDR_VAR 0 4
2137: PUSH
2138: CALL_OW 44
2142: ST_TO_ADDR
// tmp := tmp ^ un ;
2143: LD_ADDR_VAR 0 2
2147: PUSH
2148: LD_VAR 0 2
2152: PUSH
2153: LD_VAR 0 4
2157: ADD
2158: ST_TO_ADDR
// for i in tmp do
2159: LD_ADDR_VAR 0 3
2163: PUSH
2164: LD_VAR 0 2
2168: PUSH
2169: FOR_IN
2170: IFFALSE 2189
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2172: LD_VAR 0 3
2176: PPUSH
2177: LD_INT 14
2179: PPUSH
2180: LD_INT 0
2182: PPUSH
2183: CALL_OW 49
2187: GO 2169
2189: POP
2190: POP
// if freedom then
2191: LD_EXP 3
2195: IFFALSE 2228
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2197: LD_VAR 0 2
2201: PPUSH
2202: LD_EXP 3
2206: PPUSH
2207: CALL_OW 250
2211: PPUSH
2212: LD_EXP 3
2216: PPUSH
2217: CALL_OW 251
2221: PPUSH
2222: CALL_OW 111
2226: GO 2243
// ComMoveXY ( tmp , 70 , 48 ) ;
2228: LD_VAR 0 2
2232: PPUSH
2233: LD_INT 70
2235: PPUSH
2236: LD_INT 48
2238: PPUSH
2239: CALL_OW 111
// end ;
2243: LD_VAR 0 1
2247: RET
// export function PrepareBelkov ; begin
2248: LD_INT 0
2250: PPUSH
// uc_side := 4 ;
2251: LD_ADDR_OWVAR 20
2255: PUSH
2256: LD_INT 4
2258: ST_TO_ADDR
// uc_nation := 3 ;
2259: LD_ADDR_OWVAR 21
2263: PUSH
2264: LD_INT 3
2266: ST_TO_ADDR
// InitHc ;
2267: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2271: LD_ADDR_EXP 49
2275: PUSH
2276: LD_STRING Belkov
2278: PPUSH
2279: CALL_OW 25
2283: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2284: LD_EXP 49
2288: PPUSH
2289: LD_INT 14
2291: PPUSH
2292: LD_INT 0
2294: PPUSH
2295: CALL_OW 49
// end ;
2299: LD_VAR 0 1
2303: RET
// export function PrepareGnyevko ; begin
2304: LD_INT 0
2306: PPUSH
// uc_side := 4 ;
2307: LD_ADDR_OWVAR 20
2311: PUSH
2312: LD_INT 4
2314: ST_TO_ADDR
// uc_nation := 3 ;
2315: LD_ADDR_OWVAR 21
2319: PUSH
2320: LD_INT 3
2322: ST_TO_ADDR
// InitHc ;
2323: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2327: LD_ADDR_EXP 50
2331: PUSH
2332: LD_STRING Gnyevko
2334: PPUSH
2335: CALL_OW 25
2339: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2340: LD_EXP 50
2344: PPUSH
2345: LD_INT 14
2347: PPUSH
2348: LD_INT 0
2350: PPUSH
2351: CALL_OW 49
// end ;
2355: LD_VAR 0 1
2359: RET
// export function PrepareBurlak ; var i , tmp ; begin
2360: LD_INT 0
2362: PPUSH
2363: PPUSH
2364: PPUSH
// uc_side := 4 ;
2365: LD_ADDR_OWVAR 20
2369: PUSH
2370: LD_INT 4
2372: ST_TO_ADDR
// uc_nation := 3 ;
2373: LD_ADDR_OWVAR 21
2377: PUSH
2378: LD_INT 3
2380: ST_TO_ADDR
// InitHc ;
2381: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2385: LD_ADDR_EXP 48
2389: PUSH
2390: LD_STRING Burlak
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2398: LD_INT 24
2400: PUSH
2401: LD_INT 23
2403: PUSH
2404: LD_INT 22
2406: PUSH
2407: LD_INT 22
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: LIST
2415: PUSH
2416: LD_OWVAR 67
2420: ARRAY
2421: PPUSH
2422: LD_INT 1
2424: PPUSH
2425: LD_INT 1
2427: PPUSH
2428: LD_INT 45
2430: PUSH
2431: LD_INT 44
2433: PUSH
2434: LD_INT 43
2436: PUSH
2437: LD_INT 42
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: LIST
2444: LIST
2445: PUSH
2446: LD_OWVAR 67
2450: ARRAY
2451: PPUSH
2452: LD_INT 0
2454: PPUSH
2455: CALL 21275 0 5
// Masha := CreateVehicle ;
2459: LD_ADDR_EXP 51
2463: PUSH
2464: CALL_OW 45
2468: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2469: LD_EXP 51
2473: PUSH
2474: LD_EXP 48
2478: PUSH
2479: EMPTY
2480: LIST
2481: LIST
2482: PPUSH
2483: LD_INT 499
2485: PPUSH
2486: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2490: LD_EXP 51
2494: PPUSH
2495: LD_INT 3
2497: PPUSH
2498: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2502: LD_EXP 51
2506: PPUSH
2507: LD_INT 1
2509: PPUSH
2510: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2514: LD_INT 1
2516: PPUSH
2517: LD_INT 18
2519: PPUSH
2520: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2524: LD_INT 35
2526: PPUSH
2527: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2531: LD_ADDR_VAR 0 3
2535: PUSH
2536: LD_INT 18
2538: PPUSH
2539: EMPTY
2540: PPUSH
2541: CALL_OW 70
2545: ST_TO_ADDR
// if tmp then
2546: LD_VAR 0 3
2550: IFFALSE 2584
// for i in tmp do
2552: LD_ADDR_VAR 0 2
2556: PUSH
2557: LD_VAR 0 3
2561: PUSH
2562: FOR_IN
2563: IFFALSE 2582
// ComMoveXY ( i , 114 , 9 ) ;
2565: LD_VAR 0 2
2569: PPUSH
2570: LD_INT 114
2572: PPUSH
2573: LD_INT 9
2575: PPUSH
2576: CALL_OW 111
2580: GO 2562
2582: POP
2583: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2584: LD_INT 18
2586: PPUSH
2587: EMPTY
2588: PPUSH
2589: CALL_OW 70
2593: NOT
2594: PUSH
2595: LD_INT 123
2597: PPUSH
2598: LD_INT 3
2600: PPUSH
2601: CALL_OW 428
2605: PUSH
2606: LD_INT 0
2608: EQUAL
2609: AND
2610: IFFALSE 2524
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2612: LD_EXP 51
2616: PPUSH
2617: LD_INT 123
2619: PPUSH
2620: LD_INT 3
2622: PPUSH
2623: LD_INT 0
2625: PPUSH
2626: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2630: LD_EXP 48
2634: PPUSH
2635: LD_INT 125
2637: PPUSH
2638: LD_INT 1
2640: PPUSH
2641: LD_INT 0
2643: PPUSH
2644: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2648: LD_EXP 48
2652: PPUSH
2653: LD_EXP 51
2657: PPUSH
2658: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2662: LD_INT 10
2664: PPUSH
2665: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2669: LD_EXP 51
2673: PPUSH
2674: LD_INT 110
2676: PPUSH
2677: LD_INT 10
2679: PPUSH
2680: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2684: LD_ADDR_EXP 44
2688: PUSH
2689: LD_STRING Petrovova
2691: PPUSH
2692: CALL_OW 25
2696: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2697: LD_ADDR_EXP 46
2701: PUSH
2702: LD_STRING Kuzmov
2704: PPUSH
2705: CALL_OW 25
2709: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2710: LD_ADDR_EXP 45
2714: PUSH
2715: LD_STRING Kovalyuk
2717: PPUSH
2718: CALL_OW 25
2722: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2723: LD_ADDR_EXP 43
2727: PUSH
2728: LD_STRING Lipshchin
2730: PPUSH
2731: CALL_OW 25
2735: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2736: LD_ADDR_EXP 47
2740: PUSH
2741: LD_STRING Karamazov
2743: PPUSH
2744: CALL_OW 25
2748: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2749: LD_ADDR_VAR 0 3
2753: PUSH
2754: LD_EXP 44
2758: PUSH
2759: LD_EXP 46
2763: PUSH
2764: LD_EXP 45
2768: PUSH
2769: LD_EXP 43
2773: PUSH
2774: LD_EXP 47
2778: PUSH
2779: EMPTY
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: LIST
2785: ST_TO_ADDR
// for i in tmp do
2786: LD_ADDR_VAR 0 2
2790: PUSH
2791: LD_VAR 0 3
2795: PUSH
2796: FOR_IN
2797: IFFALSE 2836
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2799: LD_VAR 0 2
2803: PPUSH
2804: LD_INT 399
2806: PPUSH
2807: LD_INT 799
2809: PPUSH
2810: CALL_OW 12
2814: PPUSH
2815: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2819: LD_VAR 0 2
2823: PPUSH
2824: LD_INT 19
2826: PPUSH
2827: LD_INT 0
2829: PPUSH
2830: CALL_OW 49
// end ;
2834: GO 2796
2836: POP
2837: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2838: LD_VAR 0 3
2842: PPUSH
2843: LD_INT 112
2845: PPUSH
2846: LD_INT 5
2848: PPUSH
2849: CALL_OW 111
// AddComHold ( tmp ) ;
2853: LD_VAR 0 3
2857: PPUSH
2858: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2862: LD_ADDR_VAR 0 2
2866: PUSH
2867: LD_VAR 0 3
2871: PPUSH
2872: LD_INT 25
2874: PUSH
2875: LD_INT 1
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: PPUSH
2882: CALL_OW 72
2886: PUSH
2887: FOR_IN
2888: IFFALSE 2928
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2890: LD_VAR 0 2
2894: PPUSH
2895: LD_INT 20
2897: PPUSH
2898: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2902: LD_VAR 0 2
2906: PPUSH
2907: LD_INT 147
2909: PPUSH
2910: LD_INT 45
2912: PPUSH
2913: CALL_OW 178
// AddComCrawl ( i ) ;
2917: LD_VAR 0 2
2921: PPUSH
2922: CALL_OW 197
// end ;
2926: GO 2887
2928: POP
2929: POP
// repeat wait ( 0 0$1 ) ;
2930: LD_INT 35
2932: PPUSH
2933: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2937: LD_EXP 51
2941: PPUSH
2942: LD_INT 110
2944: PPUSH
2945: LD_INT 10
2947: PPUSH
2948: CALL_OW 307
2952: PUSH
2953: LD_EXP 51
2957: PPUSH
2958: CALL_OW 305
2962: NOT
2963: OR
2964: IFFALSE 2930
// ComStop ( Burlak ) ;
2966: LD_EXP 48
2970: PPUSH
2971: CALL_OW 141
// AddComHold ( Burlak ) ;
2975: LD_EXP 48
2979: PPUSH
2980: CALL_OW 200
// end ; end_of_file
2984: LD_VAR 0 1
2988: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2989: LD_INT 0
2991: PPUSH
2992: PPUSH
2993: PPUSH
2994: PPUSH
2995: PPUSH
// uc_side := 3 ;
2996: LD_ADDR_OWVAR 20
3000: PUSH
3001: LD_INT 3
3003: ST_TO_ADDR
// uc_nation := 3 ;
3004: LD_ADDR_OWVAR 21
3008: PUSH
3009: LD_INT 3
3011: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3012: LD_ADDR_EXP 52
3016: PUSH
3017: LD_INT 47
3019: PPUSH
3020: LD_INT 4
3022: PPUSH
3023: LD_STRING 
3025: PPUSH
3026: LD_INT 7
3028: PUSH
3029: LD_INT 8
3031: PUSH
3032: LD_INT 9
3034: PUSH
3035: LD_INT 10
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: PUSH
3044: LD_OWVAR 67
3048: ARRAY
3049: PPUSH
3050: LD_INT 10000
3052: PUSH
3053: LD_INT 3000
3055: PUSH
3056: LD_INT 300
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: PPUSH
3064: LD_INT 9
3066: PUSH
3067: LD_INT 5
3069: PUSH
3070: LD_INT 6
3072: PUSH
3073: LD_INT 6
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PPUSH
3082: CALL 25096 0 6
3086: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3087: LD_ADDR_EXP 61
3091: PUSH
3092: LD_EXP 61
3096: PPUSH
3097: LD_INT 2
3099: PPUSH
3100: LD_EXP 52
3104: PPUSH
3105: CALL_OW 1
3109: ST_TO_ADDR
// tmp := [ ] ;
3110: LD_ADDR_VAR 0 4
3114: PUSH
3115: EMPTY
3116: ST_TO_ADDR
// for i = 1 to 4 do
3117: LD_ADDR_VAR 0 2
3121: PUSH
3122: DOUBLE
3123: LD_INT 1
3125: DEC
3126: ST_TO_ADDR
3127: LD_INT 4
3129: PUSH
3130: FOR_TO
3131: IFFALSE 3224
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3133: LD_INT 22
3135: PPUSH
3136: LD_INT 3
3138: PPUSH
3139: LD_INT 3
3141: PPUSH
3142: LD_INT 43
3144: PUSH
3145: LD_INT 45
3147: PUSH
3148: LD_INT 45
3150: PUSH
3151: LD_INT 44
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: LIST
3158: LIST
3159: PUSH
3160: LD_VAR 0 2
3164: PUSH
3165: LD_INT 4
3167: MOD
3168: PUSH
3169: LD_INT 1
3171: PLUS
3172: ARRAY
3173: PPUSH
3174: LD_INT 100
3176: PPUSH
3177: CALL 21275 0 5
// veh := CreateVehicle ;
3181: LD_ADDR_VAR 0 3
3185: PUSH
3186: CALL_OW 45
3190: ST_TO_ADDR
// tmp := tmp ^ veh ;
3191: LD_ADDR_VAR 0 4
3195: PUSH
3196: LD_VAR 0 4
3200: PUSH
3201: LD_VAR 0 3
3205: ADD
3206: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3207: LD_VAR 0 3
3211: PPUSH
3212: LD_INT 2
3214: PPUSH
3215: LD_INT 0
3217: PPUSH
3218: CALL_OW 49
// end ;
3222: GO 3130
3224: POP
3225: POP
// russian_guard := tmp ;
3226: LD_ADDR_EXP 53
3230: PUSH
3231: LD_VAR 0 4
3235: ST_TO_ADDR
// if Difficulty >= 3 then
3236: LD_OWVAR 67
3240: PUSH
3241: LD_INT 3
3243: GREATEREQUAL
3244: IFFALSE 3308
// begin bc_type := b_breastwork ;
3246: LD_ADDR_OWVAR 42
3250: PUSH
3251: LD_INT 31
3253: ST_TO_ADDR
// bc_level := 10 ;
3254: LD_ADDR_OWVAR 43
3258: PUSH
3259: LD_INT 10
3261: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3262: LD_ADDR_VAR 0 5
3266: PUSH
3267: LD_INT 96
3269: PPUSH
3270: LD_INT 105
3272: PPUSH
3273: LD_INT 3
3275: PPUSH
3276: CALL_OW 47
3280: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3281: LD_INT 0
3283: PPUSH
3284: LD_INT 9
3286: PPUSH
3287: LD_INT 10
3289: PPUSH
3290: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3294: CALL_OW 44
3298: PPUSH
3299: LD_VAR 0 5
3303: PPUSH
3304: CALL_OW 52
// end ; end ;
3308: LD_VAR 0 1
3312: RET
// every 5 5$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , p , base , tmp , _target , attackers , amount ;
3313: LD_INT 47
3315: PPUSH
3316: CALL_OW 302
3320: PUSH
3321: LD_EXP 6
3325: AND
3326: IFFALSE 4073
3328: GO 3330
3330: DISABLE
3331: LD_INT 0
3333: PPUSH
3334: PPUSH
3335: PPUSH
3336: PPUSH
3337: PPUSH
3338: PPUSH
3339: PPUSH
// begin enable ;
3340: ENABLE
// base := 2 ;
3341: LD_ADDR_VAR 0 3
3345: PUSH
3346: LD_INT 2
3348: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3349: LD_ADDR_VAR 0 4
3353: PUSH
3354: LD_INT 22
3356: PUSH
3357: LD_INT 1
3359: PUSH
3360: LD_INT 3
3362: PUSH
3363: LD_INT 45
3365: PUSH
3366: EMPTY
3367: LIST
3368: LIST
3369: LIST
3370: LIST
3371: PUSH
3372: LD_INT 21
3374: PUSH
3375: LD_INT 1
3377: PUSH
3378: LD_INT 3
3380: PUSH
3381: LD_INT 45
3383: PUSH
3384: EMPTY
3385: LIST
3386: LIST
3387: LIST
3388: LIST
3389: PUSH
3390: LD_INT 22
3392: PUSH
3393: LD_INT 1
3395: PUSH
3396: LD_INT 3
3398: PUSH
3399: LD_INT 45
3401: PUSH
3402: EMPTY
3403: LIST
3404: LIST
3405: LIST
3406: LIST
3407: PUSH
3408: LD_INT 23
3410: PUSH
3411: LD_INT 1
3413: PUSH
3414: LD_INT 3
3416: PUSH
3417: LD_INT 46
3419: PUSH
3420: EMPTY
3421: LIST
3422: LIST
3423: LIST
3424: LIST
3425: PUSH
3426: EMPTY
3427: LIST
3428: LIST
3429: LIST
3430: LIST
3431: ST_TO_ADDR
// amount := Difficulty ;
3432: LD_ADDR_VAR 0 7
3436: PUSH
3437: LD_OWVAR 67
3441: ST_TO_ADDR
// if tick > 30 30$00 then
3442: LD_OWVAR 1
3446: PUSH
3447: LD_INT 63000
3449: GREATER
3450: IFFALSE 3487
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3452: LD_ADDR_VAR 0 7
3456: PUSH
3457: LD_VAR 0 7
3461: PUSH
3462: LD_INT 2
3464: PUSH
3465: LD_INT 3
3467: PUSH
3468: LD_INT 4
3470: PUSH
3471: LD_INT 4
3473: PUSH
3474: EMPTY
3475: LIST
3476: LIST
3477: LIST
3478: LIST
3479: PUSH
3480: LD_OWVAR 67
3484: ARRAY
3485: PLUS
3486: ST_TO_ADDR
// for i = 1 to amount do
3487: LD_ADDR_VAR 0 1
3491: PUSH
3492: DOUBLE
3493: LD_INT 1
3495: DEC
3496: ST_TO_ADDR
3497: LD_VAR 0 7
3501: PUSH
3502: FOR_TO
3503: IFFALSE 3591
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3505: LD_ADDR_VAR 0 4
3509: PUSH
3510: LD_VAR 0 4
3514: PPUSH
3515: LD_VAR 0 4
3519: PUSH
3520: LD_INT 1
3522: PLUS
3523: PPUSH
3524: LD_INT 23
3526: PUSH
3527: LD_INT 24
3529: PUSH
3530: EMPTY
3531: LIST
3532: LIST
3533: PUSH
3534: LD_INT 1
3536: PPUSH
3537: LD_INT 2
3539: PPUSH
3540: CALL_OW 12
3544: ARRAY
3545: PUSH
3546: LD_INT 1
3548: PUSH
3549: LD_INT 3
3551: PUSH
3552: LD_INT 46
3554: PUSH
3555: LD_INT 47
3557: PUSH
3558: LD_INT 45
3560: PUSH
3561: EMPTY
3562: LIST
3563: LIST
3564: LIST
3565: PUSH
3566: LD_INT 1
3568: PPUSH
3569: LD_INT 3
3571: PPUSH
3572: CALL_OW 12
3576: ARRAY
3577: PUSH
3578: EMPTY
3579: LIST
3580: LIST
3581: LIST
3582: LIST
3583: PPUSH
3584: CALL_OW 2
3588: ST_TO_ADDR
3589: GO 3502
3591: POP
3592: POP
// p := 1 ;
3593: LD_ADDR_VAR 0 2
3597: PUSH
3598: LD_INT 1
3600: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
3601: LD_VAR 0 3
3605: PPUSH
3606: LD_VAR 0 4
3610: PPUSH
3611: CALL 82949 0 2
// repeat wait ( 0 0$1 ) ;
3615: LD_INT 35
3617: PPUSH
3618: CALL_OW 67
// p := Inc ( p ) ;
3622: LD_ADDR_VAR 0 2
3626: PUSH
3627: LD_VAR 0 2
3631: PPUSH
3632: CALL 55498 0 1
3636: ST_TO_ADDR
// until MC_GetVehicles ( base , true ) >= amount or p >= 60 ;
3637: LD_VAR 0 3
3641: PPUSH
3642: LD_INT 1
3644: PPUSH
3645: CALL 84367 0 2
3649: PUSH
3650: LD_VAR 0 7
3654: GREATEREQUAL
3655: PUSH
3656: LD_VAR 0 2
3660: PUSH
3661: LD_INT 60
3663: GREATEREQUAL
3664: OR
3665: IFFALSE 3615
// wait ( 0 0$30 ) ;
3667: LD_INT 1050
3669: PPUSH
3670: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3674: LD_ADDR_VAR 0 5
3678: PUSH
3679: LD_INT 71
3681: PUSH
3682: LD_INT 19
3684: PUSH
3685: EMPTY
3686: LIST
3687: LIST
3688: PUSH
3689: LD_INT 91
3691: PUSH
3692: LD_INT 67
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: LD_INT 52
3701: PUSH
3702: LD_INT 44
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: PUSH
3709: LD_INT 68
3711: PUSH
3712: LD_INT 48
3714: PUSH
3715: EMPTY
3716: LIST
3717: LIST
3718: PUSH
3719: EMPTY
3720: LIST
3721: LIST
3722: LIST
3723: LIST
3724: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] ] ] ) diff mc_defender [ base ] ;
3725: LD_ADDR_VAR 0 6
3729: PUSH
3730: LD_INT 22
3732: PUSH
3733: LD_INT 3
3735: PUSH
3736: EMPTY
3737: LIST
3738: LIST
3739: PUSH
3740: LD_INT 21
3742: PUSH
3743: LD_INT 2
3745: PUSH
3746: EMPTY
3747: LIST
3748: LIST
3749: PUSH
3750: LD_INT 3
3752: PUSH
3753: LD_INT 34
3755: PUSH
3756: LD_INT 52
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 34
3765: PUSH
3766: LD_INT 51
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: LIST
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: LIST
3782: PPUSH
3783: CALL_OW 69
3787: PUSH
3788: LD_EXP 83
3792: PUSH
3793: LD_VAR 0 3
3797: ARRAY
3798: DIFF
3799: ST_TO_ADDR
// if not attackers then
3800: LD_VAR 0 6
3804: NOT
3805: IFFALSE 3809
// exit ;
3807: GO 4073
// ru_attackers := attackers ;
3809: LD_ADDR_EXP 54
3813: PUSH
3814: LD_VAR 0 6
3818: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3819: LD_ADDR_EXP 80
3823: PUSH
3824: LD_EXP 80
3828: PPUSH
3829: LD_VAR 0 3
3833: PPUSH
3834: LD_EXP 80
3838: PUSH
3839: LD_VAR 0 3
3843: ARRAY
3844: PUSH
3845: LD_VAR 0 6
3849: DIFF
3850: PPUSH
3851: CALL_OW 1
3855: ST_TO_ADDR
// for i = 1 to attackers do
3856: LD_ADDR_VAR 0 1
3860: PUSH
3861: DOUBLE
3862: LD_INT 1
3864: DEC
3865: ST_TO_ADDR
3866: LD_VAR 0 6
3870: PUSH
3871: FOR_TO
3872: IFFALSE 3949
// begin case i mod 3 of 0 :
3874: LD_VAR 0 1
3878: PUSH
3879: LD_INT 3
3881: MOD
3882: PUSH
3883: LD_INT 0
3885: DOUBLE
3886: EQUAL
3887: IFTRUE 3891
3889: GO 3894
3891: POP
// ; 1 :
3892: GO 3947
3894: LD_INT 1
3896: DOUBLE
3897: EQUAL
3898: IFTRUE 3902
3900: GO 3920
3902: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3903: LD_VAR 0 1
3907: PPUSH
3908: LD_INT 32
3910: PPUSH
3911: LD_INT 49
3913: PPUSH
3914: CALL_OW 114
3918: GO 3947
3920: LD_INT 2
3922: DOUBLE
3923: EQUAL
3924: IFTRUE 3928
3926: GO 3946
3928: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3929: LD_VAR 0 1
3933: PPUSH
3934: LD_INT 117
3936: PPUSH
3937: LD_INT 107
3939: PPUSH
3940: CALL_OW 114
3944: GO 3947
3946: POP
// end ;
3947: GO 3871
3949: POP
3950: POP
// p := 0 ;
3951: LD_ADDR_VAR 0 2
3955: PUSH
3956: LD_INT 0
3958: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3959: LD_INT 35
3961: PPUSH
3962: CALL_OW 67
// p := Inc ( p ) ;
3966: LD_ADDR_VAR 0 2
3970: PUSH
3971: LD_VAR 0 2
3975: PPUSH
3976: CALL 55498 0 1
3980: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
3981: LD_VAR 0 6
3985: PPUSH
3986: LD_INT 60
3988: PUSH
3989: EMPTY
3990: LIST
3991: PPUSH
3992: CALL_OW 72
3996: NOT
3997: PUSH
3998: LD_VAR 0 2
4002: PUSH
4003: LD_INT 30
4005: GREATER
4006: OR
4007: IFFALSE 3959
// if not first_attack then
4009: LD_EXP 7
4013: NOT
4014: IFFALSE 4024
// first_attack := true ;
4016: LD_ADDR_EXP 7
4020: PUSH
4021: LD_INT 1
4023: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4024: LD_INT 35
4026: PPUSH
4027: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
4031: LD_ADDR_VAR 0 6
4035: PUSH
4036: LD_VAR 0 6
4040: PPUSH
4041: LD_INT 50
4043: PUSH
4044: EMPTY
4045: LIST
4046: PPUSH
4047: CALL_OW 72
4051: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
4052: LD_VAR 0 6
4056: PPUSH
4057: LD_VAR 0 5
4061: PPUSH
4062: CALL 56741 0 2
// until not attackers ;
4066: LD_VAR 0 6
4070: NOT
4071: IFFALSE 4024
// end ;
4073: PPOPN 7
4075: END
// export function PrepareRussianAttack ; var i , tmp , veh , chassis , weapon ; begin
4076: LD_INT 0
4078: PPUSH
4079: PPUSH
4080: PPUSH
4081: PPUSH
4082: PPUSH
4083: PPUSH
// uc_side := 6 ;
4084: LD_ADDR_OWVAR 20
4088: PUSH
4089: LD_INT 6
4091: ST_TO_ADDR
// uc_nation := 3 ;
4092: LD_ADDR_OWVAR 21
4096: PUSH
4097: LD_INT 3
4099: ST_TO_ADDR
// InitHc ;
4100: CALL_OW 19
// InitVc ;
4104: CALL_OW 20
// tmp := [ ] ;
4108: LD_ADDR_VAR 0 3
4112: PUSH
4113: EMPTY
4114: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
4115: LD_ADDR_VAR 0 2
4119: PUSH
4120: DOUBLE
4121: LD_INT 1
4123: DEC
4124: ST_TO_ADDR
4125: LD_INT 4
4127: PUSH
4128: LD_INT 5
4130: PUSH
4131: LD_INT 6
4133: PUSH
4134: LD_INT 7
4136: PUSH
4137: EMPTY
4138: LIST
4139: LIST
4140: LIST
4141: LIST
4142: PUSH
4143: LD_OWVAR 67
4147: ARRAY
4148: PUSH
4149: FOR_TO
4150: IFFALSE 4404
// begin chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 3 ) ] ;
4152: LD_ADDR_VAR 0 5
4156: PUSH
4157: LD_INT 21
4159: PUSH
4160: LD_INT 22
4162: PUSH
4163: LD_INT 24
4165: PUSH
4166: EMPTY
4167: LIST
4168: LIST
4169: LIST
4170: PUSH
4171: LD_INT 1
4173: PPUSH
4174: LD_INT 3
4176: PPUSH
4177: CALL_OW 12
4181: ARRAY
4182: ST_TO_ADDR
// case chassis of ru_medium_wheeled , ru_medium_tracked :
4183: LD_VAR 0 5
4187: PUSH
4188: LD_INT 21
4190: DOUBLE
4191: EQUAL
4192: IFTRUE 4202
4194: LD_INT 22
4196: DOUBLE
4197: EQUAL
4198: IFTRUE 4202
4200: GO 4236
4202: POP
// weapon := [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ; ru_heavy_tracked :
4203: LD_ADDR_VAR 0 6
4207: PUSH
4208: LD_INT 45
4210: PUSH
4211: LD_INT 44
4213: PUSH
4214: LD_INT 43
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: LIST
4221: PUSH
4222: LD_INT 1
4224: PPUSH
4225: LD_INT 3
4227: PPUSH
4228: CALL_OW 12
4232: ARRAY
4233: ST_TO_ADDR
4234: GO 4283
4236: LD_INT 24
4238: DOUBLE
4239: EQUAL
4240: IFTRUE 4244
4242: GO 4282
4244: POP
// weapon := [ ru_heavy_gun , ru_rocket , ru_rocket_launcher , ru_heavy_gun ] [ rand ( 1 , 4 ) ] ; end ;
4245: LD_ADDR_VAR 0 6
4249: PUSH
4250: LD_INT 46
4252: PUSH
4253: LD_INT 47
4255: PUSH
4256: LD_INT 45
4258: PUSH
4259: LD_INT 46
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: LIST
4266: LIST
4267: PUSH
4268: LD_INT 1
4270: PPUSH
4271: LD_INT 4
4273: PPUSH
4274: CALL_OW 12
4278: ARRAY
4279: ST_TO_ADDR
4280: GO 4283
4282: POP
// uc_side := 6 ;
4283: LD_ADDR_OWVAR 20
4287: PUSH
4288: LD_INT 6
4290: ST_TO_ADDR
// uc_nation := 3 ;
4291: LD_ADDR_OWVAR 21
4295: PUSH
4296: LD_INT 3
4298: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
4299: LD_VAR 0 5
4303: PPUSH
4304: LD_INT 1
4306: PUSH
4307: LD_INT 3
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: PUSH
4314: LD_INT 1
4316: PPUSH
4317: LD_INT 2
4319: PPUSH
4320: CALL_OW 12
4324: ARRAY
4325: PPUSH
4326: LD_INT 3
4328: PPUSH
4329: LD_VAR 0 6
4333: PPUSH
4334: LD_INT 70
4336: PPUSH
4337: LD_INT 90
4339: PPUSH
4340: CALL_OW 12
4344: PPUSH
4345: CALL 21275 0 5
// veh := CreateVehicle ;
4349: LD_ADDR_VAR 0 4
4353: PUSH
4354: CALL_OW 45
4358: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
4359: LD_VAR 0 4
4363: PPUSH
4364: LD_INT 5
4366: PPUSH
4367: CALL_OW 233
// PlaceUnitArea ( veh , south_spawn , false ) ;
4371: LD_VAR 0 4
4375: PPUSH
4376: LD_INT 16
4378: PPUSH
4379: LD_INT 0
4381: PPUSH
4382: CALL_OW 49
// tmp := tmp ^ veh ;
4386: LD_ADDR_VAR 0 3
4390: PUSH
4391: LD_VAR 0 3
4395: PUSH
4396: LD_VAR 0 4
4400: ADD
4401: ST_TO_ADDR
// end ;
4402: GO 4149
4404: POP
4405: POP
// if not tmp then
4406: LD_VAR 0 3
4410: NOT
4411: IFFALSE 4415
// exit ;
4413: GO 4509
// repeat wait ( 0 0$2 ) ;
4415: LD_INT 70
4417: PPUSH
4418: CALL_OW 67
// for i in tmp do
4422: LD_ADDR_VAR 0 2
4426: PUSH
4427: LD_VAR 0 3
4431: PUSH
4432: FOR_IN
4433: IFFALSE 4500
// if IsOk ( i ) then
4435: LD_VAR 0 2
4439: PPUSH
4440: CALL_OW 302
4444: IFFALSE 4482
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) else
4446: LD_VAR 0 2
4450: PPUSH
4451: LD_INT 22
4453: PUSH
4454: LD_INT 7
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: PPUSH
4461: CALL_OW 69
4465: PPUSH
4466: LD_VAR 0 2
4470: PPUSH
4471: CALL_OW 74
4475: PPUSH
4476: CALL_OW 115
4480: GO 4498
// tmp := tmp diff i ;
4482: LD_ADDR_VAR 0 3
4486: PUSH
4487: LD_VAR 0 3
4491: PUSH
4492: LD_VAR 0 2
4496: DIFF
4497: ST_TO_ADDR
4498: GO 4432
4500: POP
4501: POP
// until not tmp ;
4502: LD_VAR 0 3
4506: NOT
4507: IFFALSE 4415
// end ;
4509: LD_VAR 0 1
4513: RET
// every 10 10$00 + 3 3$00 trigger first_attack and IsOk ( ru_depot ) and GetSide ( ru_depot ) = 3 do
4514: LD_EXP 7
4518: PUSH
4519: LD_INT 47
4521: PPUSH
4522: CALL_OW 302
4526: AND
4527: PUSH
4528: LD_INT 47
4530: PPUSH
4531: CALL_OW 255
4535: PUSH
4536: LD_INT 3
4538: EQUAL
4539: AND
4540: IFFALSE 4550
4542: GO 4544
4544: DISABLE
// begin enable ;
4545: ENABLE
// PrepareRussianAttack ;
4546: CALL 4076 0 0
// end ; end_of_file
4550: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
4551: LD_INT 0
4553: PPUSH
4554: PPUSH
4555: PPUSH
4556: PPUSH
4557: PPUSH
4558: PPUSH
4559: PPUSH
// uc_side := 2 ;
4560: LD_ADDR_OWVAR 20
4564: PUSH
4565: LD_INT 2
4567: ST_TO_ADDR
// uc_nation := 2 ;
4568: LD_ADDR_OWVAR 21
4572: PUSH
4573: LD_INT 2
4575: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
4576: LD_ADDR_EXP 57
4580: PUSH
4581: LD_STRING Abdul
4583: PPUSH
4584: CALL_OW 25
4588: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4589: LD_EXP 57
4593: PPUSH
4594: LD_INT 11
4596: PPUSH
4597: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4601: LD_EXP 57
4605: PPUSH
4606: LD_INT 1
4608: PPUSH
4609: CALL_OW 52
// vc_chassis := 31 ;
4613: LD_ADDR_OWVAR 37
4617: PUSH
4618: LD_INT 31
4620: ST_TO_ADDR
// vc_control := control_rider ;
4621: LD_ADDR_OWVAR 38
4625: PUSH
4626: LD_INT 4
4628: ST_TO_ADDR
// mastodont := CreateVehicle ;
4629: LD_ADDR_EXP 58
4633: PUSH
4634: CALL_OW 45
4638: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4639: LD_EXP 58
4643: PPUSH
4644: LD_INT 153
4646: PPUSH
4647: LD_INT 71
4649: PPUSH
4650: LD_INT 0
4652: PPUSH
4653: CALL_OW 48
// InitVc ;
4657: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian , kaba , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 11 , 5 , 6 , 7 ] ) ;
4661: LD_ADDR_EXP 55
4665: PUSH
4666: LD_INT 1
4668: PPUSH
4669: LD_INT 3
4671: PPUSH
4672: LD_STRING kaba
4674: PPUSH
4675: LD_INT 7
4677: PUSH
4678: LD_INT 8
4680: PUSH
4681: LD_INT 9
4683: PUSH
4684: LD_INT 10
4686: PUSH
4687: EMPTY
4688: LIST
4689: LIST
4690: LIST
4691: LIST
4692: PUSH
4693: LD_OWVAR 67
4697: ARRAY
4698: PPUSH
4699: LD_INT 5000
4701: PUSH
4702: LD_INT 1000
4704: PUSH
4705: LD_INT 300
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: LIST
4712: PPUSH
4713: LD_INT 11
4715: PUSH
4716: LD_INT 5
4718: PUSH
4719: LD_INT 6
4721: PUSH
4722: LD_INT 7
4724: PUSH
4725: EMPTY
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: PPUSH
4731: CALL 25096 0 6
4735: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4736: LD_ADDR_EXP 61
4740: PUSH
4741: LD_EXP 61
4745: PPUSH
4746: LD_INT 1
4748: PPUSH
4749: LD_EXP 55
4753: PPUSH
4754: CALL_OW 1
4758: ST_TO_ADDR
// tmp := [ ] ;
4759: LD_ADDR_VAR 0 4
4763: PUSH
4764: EMPTY
4765: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
4766: LD_ADDR_OWVAR 37
4770: PUSH
4771: LD_INT 13
4773: ST_TO_ADDR
// vc_engine := engine_siberite ;
4774: LD_ADDR_OWVAR 39
4778: PUSH
4779: LD_INT 3
4781: ST_TO_ADDR
// vc_control := control_manual ;
4782: LD_ADDR_OWVAR 38
4786: PUSH
4787: LD_INT 1
4789: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4790: LD_ADDR_OWVAR 40
4794: PUSH
4795: LD_INT 31
4797: ST_TO_ADDR
// for i = 1 to 3 do
4798: LD_ADDR_VAR 0 2
4802: PUSH
4803: DOUBLE
4804: LD_INT 1
4806: DEC
4807: ST_TO_ADDR
4808: LD_INT 3
4810: PUSH
4811: FOR_TO
4812: IFFALSE 5060
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4814: LD_ADDR_VAR 0 5
4818: PUSH
4819: LD_INT 153
4821: PUSH
4822: LD_INT 71
4824: PUSH
4825: EMPTY
4826: LIST
4827: LIST
4828: PUSH
4829: LD_INT 155
4831: PUSH
4832: LD_INT 81
4834: PUSH
4835: EMPTY
4836: LIST
4837: LIST
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: LD_VAR 0 2
4847: PUSH
4848: LD_INT 2
4850: MOD
4851: PUSH
4852: LD_INT 1
4854: PLUS
4855: ARRAY
4856: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4857: LD_INT 0
4859: PPUSH
4860: LD_INT 3
4862: PPUSH
4863: LD_INT 7
4865: PUSH
4866: LD_INT 8
4868: PUSH
4869: LD_INT 10
4871: PUSH
4872: LD_INT 10
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: PUSH
4881: LD_OWVAR 67
4885: ARRAY
4886: PPUSH
4887: CALL_OW 380
// un := CreateVehicle ;
4891: LD_ADDR_VAR 0 6
4895: PUSH
4896: CALL_OW 45
4900: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4901: LD_VAR 0 6
4905: PPUSH
4906: LD_INT 0
4908: PPUSH
4909: LD_INT 5
4911: PPUSH
4912: CALL_OW 12
4916: PPUSH
4917: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4921: LD_VAR 0 6
4925: PPUSH
4926: LD_VAR 0 5
4930: PUSH
4931: LD_INT 1
4933: ARRAY
4934: PPUSH
4935: LD_VAR 0 5
4939: PUSH
4940: LD_INT 2
4942: ARRAY
4943: PPUSH
4944: LD_INT 6
4946: PPUSH
4947: LD_INT 0
4949: PPUSH
4950: CALL_OW 50
// un2 := CreateHuman ;
4954: LD_ADDR_VAR 0 7
4958: PUSH
4959: CALL_OW 44
4963: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4964: LD_VAR 0 7
4968: PPUSH
4969: LD_VAR 0 6
4973: PPUSH
4974: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4978: LD_ADDR_EXP 61
4982: PUSH
4983: LD_EXP 61
4987: PPUSH
4988: LD_INT 1
4990: PUSH
4991: LD_EXP 61
4995: PUSH
4996: LD_INT 1
4998: ARRAY
4999: PUSH
5000: LD_INT 1
5002: PLUS
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PPUSH
5008: LD_VAR 0 6
5012: PPUSH
5013: CALL 21397 0 3
5017: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
5018: LD_ADDR_EXP 61
5022: PUSH
5023: LD_EXP 61
5027: PPUSH
5028: LD_INT 1
5030: PUSH
5031: LD_EXP 61
5035: PUSH
5036: LD_INT 1
5038: ARRAY
5039: PUSH
5040: LD_INT 1
5042: PLUS
5043: PUSH
5044: EMPTY
5045: LIST
5046: LIST
5047: PPUSH
5048: LD_VAR 0 7
5052: PPUSH
5053: CALL 21397 0 3
5057: ST_TO_ADDR
// end ;
5058: GO 4811
5060: POP
5061: POP
// for i = 1 to 5 do
5062: LD_ADDR_VAR 0 2
5066: PUSH
5067: DOUBLE
5068: LD_INT 1
5070: DEC
5071: ST_TO_ADDR
5072: LD_INT 5
5074: PUSH
5075: FOR_TO
5076: IFFALSE 5169
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
5078: LD_INT 13
5080: PPUSH
5081: LD_INT 3
5083: PPUSH
5084: LD_INT 1
5086: PPUSH
5087: LD_INT 25
5089: PUSH
5090: LD_INT 28
5092: PUSH
5093: LD_INT 28
5095: PUSH
5096: LD_INT 26
5098: PUSH
5099: EMPTY
5100: LIST
5101: LIST
5102: LIST
5103: LIST
5104: PUSH
5105: LD_VAR 0 2
5109: PUSH
5110: LD_INT 4
5112: MOD
5113: PUSH
5114: LD_INT 1
5116: PLUS
5117: ARRAY
5118: PPUSH
5119: LD_INT 100
5121: PPUSH
5122: CALL 21275 0 5
// veh := CreateVehicle ;
5126: LD_ADDR_VAR 0 3
5130: PUSH
5131: CALL_OW 45
5135: ST_TO_ADDR
// tmp := tmp ^ veh ;
5136: LD_ADDR_VAR 0 4
5140: PUSH
5141: LD_VAR 0 4
5145: PUSH
5146: LD_VAR 0 3
5150: ADD
5151: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
5152: LD_VAR 0 3
5156: PPUSH
5157: LD_INT 1
5159: PPUSH
5160: LD_INT 0
5162: PPUSH
5163: CALL_OW 49
// end ;
5167: GO 5075
5169: POP
5170: POP
// arabian_guard := tmp ;
5171: LD_ADDR_EXP 56
5175: PUSH
5176: LD_VAR 0 4
5180: ST_TO_ADDR
// end ;
5181: LD_VAR 0 1
5185: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
5186: LD_INT 22
5188: PUSH
5189: LD_INT 7
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: PUSH
5196: LD_INT 91
5198: PUSH
5199: LD_INT 1
5201: PUSH
5202: LD_INT 12
5204: PUSH
5205: EMPTY
5206: LIST
5207: LIST
5208: LIST
5209: PUSH
5210: EMPTY
5211: LIST
5212: LIST
5213: PPUSH
5214: CALL_OW 69
5218: PUSH
5219: LD_EXP 58
5223: PPUSH
5224: CALL_OW 256
5228: PUSH
5229: LD_INT 990
5231: LESS
5232: OR
5233: PUSH
5234: LD_EXP 57
5238: PPUSH
5239: CALL_OW 256
5243: PUSH
5244: LD_INT 990
5246: LESS
5247: OR
5248: IFFALSE 5391
5250: GO 5252
5252: DISABLE
// begin if IsInUnit ( Abdul ) then
5253: LD_EXP 57
5257: PPUSH
5258: CALL_OW 310
5262: IFFALSE 5273
// ComExitBuilding ( Abdul ) ;
5264: LD_EXP 57
5268: PPUSH
5269: CALL_OW 122
// if Mastodont then
5273: LD_EXP 58
5277: IFFALSE 5294
// ComMoveXY ( Mastodont , 205 , 132 ) ;
5279: LD_EXP 58
5283: PPUSH
5284: LD_INT 205
5286: PPUSH
5287: LD_INT 132
5289: PPUSH
5290: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
5294: LD_EXP 57
5298: PPUSH
5299: LD_INT 205
5301: PPUSH
5302: LD_INT 132
5304: PPUSH
5305: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
5309: LD_INT 35
5311: PPUSH
5312: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
5316: LD_EXP 57
5320: PPUSH
5321: LD_INT 21
5323: PPUSH
5324: CALL_OW 308
5328: IFFALSE 5309
// RemoveUnit ( Abdul ) ;
5330: LD_EXP 57
5334: PPUSH
5335: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
5339: LD_INT 35
5341: PPUSH
5342: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
5346: LD_EXP 58
5350: PPUSH
5351: LD_INT 21
5353: PPUSH
5354: CALL_OW 308
5358: PUSH
5359: LD_EXP 58
5363: PPUSH
5364: CALL_OW 301
5368: OR
5369: IFFALSE 5339
// if IsOk ( Mastodont ) then
5371: LD_EXP 58
5375: PPUSH
5376: CALL_OW 302
5380: IFFALSE 5391
// RemoveUnit ( Mastodont ) ;
5382: LD_EXP 58
5386: PPUSH
5387: CALL_OW 64
// end ;
5391: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
5392: LD_EXP 57
5396: PPUSH
5397: CALL_OW 301
5401: PUSH
5402: LD_INT 22
5404: PUSH
5405: LD_INT 2
5407: PUSH
5408: EMPTY
5409: LIST
5410: LIST
5411: PUSH
5412: LD_INT 2
5414: PUSH
5415: LD_INT 25
5417: PUSH
5418: LD_INT 1
5420: PUSH
5421: EMPTY
5422: LIST
5423: LIST
5424: PUSH
5425: LD_INT 25
5427: PUSH
5428: LD_INT 2
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: PUSH
5435: LD_INT 25
5437: PUSH
5438: LD_INT 3
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PUSH
5445: LD_INT 25
5447: PUSH
5448: LD_INT 4
5450: PUSH
5451: EMPTY
5452: LIST
5453: LIST
5454: PUSH
5455: LD_INT 25
5457: PUSH
5458: LD_INT 8
5460: PUSH
5461: EMPTY
5462: LIST
5463: LIST
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: LIST
5469: LIST
5470: LIST
5471: LIST
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: PPUSH
5477: CALL_OW 69
5481: PUSH
5482: LD_INT 16
5484: PUSH
5485: LD_INT 19
5487: PUSH
5488: LD_INT 22
5490: PUSH
5491: LD_INT 22
5493: PUSH
5494: EMPTY
5495: LIST
5496: LIST
5497: LIST
5498: LIST
5499: PUSH
5500: LD_OWVAR 67
5504: ARRAY
5505: LESS
5506: OR
5507: IFFALSE 6180
5509: GO 5511
5511: DISABLE
5512: LD_INT 0
5514: PPUSH
5515: PPUSH
5516: PPUSH
5517: PPUSH
5518: PPUSH
5519: PPUSH
// begin MC_Kill ( 1 ) ;
5520: LD_INT 1
5522: PPUSH
5523: CALL 58924 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
5527: LD_ADDR_VAR 0 2
5531: PUSH
5532: LD_INT 22
5534: PUSH
5535: LD_INT 2
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PUSH
5542: LD_INT 2
5544: PUSH
5545: LD_INT 25
5547: PUSH
5548: LD_INT 1
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: PUSH
5555: LD_INT 25
5557: PUSH
5558: LD_INT 2
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: PUSH
5565: LD_INT 25
5567: PUSH
5568: LD_INT 3
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: PUSH
5575: LD_INT 25
5577: PUSH
5578: LD_INT 4
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: PUSH
5585: LD_INT 25
5587: PUSH
5588: LD_INT 8
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: EMPTY
5596: LIST
5597: LIST
5598: LIST
5599: LIST
5600: LIST
5601: LIST
5602: PUSH
5603: EMPTY
5604: LIST
5605: LIST
5606: PPUSH
5607: CALL_OW 69
5611: ST_TO_ADDR
// for i in tmp do
5612: LD_ADDR_VAR 0 5
5616: PUSH
5617: LD_VAR 0 2
5621: PUSH
5622: FOR_IN
5623: IFFALSE 5639
// SetTag ( i , 10 ) ;
5625: LD_VAR 0 5
5629: PPUSH
5630: LD_INT 10
5632: PPUSH
5633: CALL_OW 109
5637: GO 5622
5639: POP
5640: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5641: LD_ADDR_VAR 0 3
5645: PUSH
5646: LD_INT 22
5648: PUSH
5649: LD_INT 2
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 21
5658: PUSH
5659: LD_INT 1
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: PUSH
5666: EMPTY
5667: LIST
5668: LIST
5669: PPUSH
5670: CALL_OW 69
5674: PUSH
5675: LD_VAR 0 2
5679: DIFF
5680: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5681: LD_ADDR_VAR 0 1
5685: PUSH
5686: LD_INT 22
5688: PUSH
5689: LD_INT 2
5691: PUSH
5692: EMPTY
5693: LIST
5694: LIST
5695: PUSH
5696: LD_INT 21
5698: PUSH
5699: LD_INT 2
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: PUSH
5706: LD_INT 24
5708: PUSH
5709: LD_INT 300
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: LIST
5720: PPUSH
5721: CALL_OW 69
5725: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5726: LD_ADDR_VAR 0 4
5730: PUSH
5731: LD_VAR 0 1
5735: PPUSH
5736: LD_INT 33
5738: PUSH
5739: LD_INT 1
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: PUSH
5746: LD_INT 58
5748: PUSH
5749: EMPTY
5750: LIST
5751: PUSH
5752: EMPTY
5753: LIST
5754: LIST
5755: PPUSH
5756: CALL_OW 72
5760: ST_TO_ADDR
// for i in tmp do
5761: LD_ADDR_VAR 0 5
5765: PUSH
5766: LD_VAR 0 2
5770: PUSH
5771: FOR_IN
5772: IFFALSE 5956
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5774: LD_VAR 0 5
5778: PUSH
5779: LD_INT 55
5781: PUSH
5782: EMPTY
5783: LIST
5784: PPUSH
5785: CALL_OW 69
5789: IN
5790: IFFALSE 5809
// begin AddComMoveXY ( i , 209 , 132 ) ;
5792: LD_VAR 0 5
5796: PPUSH
5797: LD_INT 209
5799: PPUSH
5800: LD_INT 132
5802: PPUSH
5803: CALL_OW 171
// continue ;
5807: GO 5771
// end ; if IsInUnit ( i ) then
5809: LD_VAR 0 5
5813: PPUSH
5814: CALL_OW 310
5818: IFFALSE 5836
// begin ComExitBuilding ( i ) ;
5820: LD_VAR 0 5
5824: PPUSH
5825: CALL_OW 122
// wait ( 3 ) ;
5829: LD_INT 3
5831: PPUSH
5832: CALL_OW 67
// end ; if tmp_empty then
5836: LD_VAR 0 4
5840: IFFALSE 5939
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5842: LD_VAR 0 5
5846: PPUSH
5847: LD_VAR 0 4
5851: PPUSH
5852: LD_VAR 0 5
5856: PPUSH
5857: CALL_OW 74
5861: PPUSH
5862: CALL_OW 296
5866: PUSH
5867: LD_INT 25
5869: LESS
5870: IFFALSE 5939
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5872: LD_ADDR_VAR 0 6
5876: PUSH
5877: LD_VAR 0 4
5881: PPUSH
5882: LD_VAR 0 5
5886: PPUSH
5887: CALL_OW 74
5891: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5892: LD_VAR 0 5
5896: PPUSH
5897: LD_VAR 0 6
5901: PPUSH
5902: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5906: LD_VAR 0 5
5910: PPUSH
5911: LD_INT 209
5913: PPUSH
5914: LD_INT 132
5916: PPUSH
5917: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5921: LD_ADDR_VAR 0 4
5925: PUSH
5926: LD_VAR 0 4
5930: PUSH
5931: LD_VAR 0 6
5935: DIFF
5936: ST_TO_ADDR
// continue ;
5937: GO 5771
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5939: LD_VAR 0 5
5943: PPUSH
5944: LD_INT 201
5946: PPUSH
5947: LD_INT 132
5949: PPUSH
5950: CALL_OW 171
// end ;
5954: GO 5771
5956: POP
5957: POP
// for i in tmp_ape do
5958: LD_ADDR_VAR 0 5
5962: PUSH
5963: LD_VAR 0 3
5967: PUSH
5968: FOR_IN
5969: IFFALSE 6008
// begin if IsInUnit ( i ) then
5971: LD_VAR 0 5
5975: PPUSH
5976: CALL_OW 310
5980: IFFALSE 5991
// ComExitBuilding ( i ) ;
5982: LD_VAR 0 5
5986: PPUSH
5987: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5991: LD_VAR 0 5
5995: PPUSH
5996: LD_INT 201
5998: PPUSH
5999: LD_INT 132
6001: PPUSH
6002: CALL_OW 171
// end ;
6006: GO 5968
6008: POP
6009: POP
// repeat wait ( 0 0$1 ) ;
6010: LD_INT 35
6012: PPUSH
6013: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
6017: LD_ADDR_VAR 0 5
6021: PUSH
6022: LD_VAR 0 2
6026: PUSH
6027: LD_VAR 0 3
6031: UNION
6032: PUSH
6033: LD_VAR 0 1
6037: UNION
6038: PUSH
6039: FOR_IN
6040: IFFALSE 6071
// if not HasTask ( i ) then
6042: LD_VAR 0 5
6046: PPUSH
6047: CALL_OW 314
6051: NOT
6052: IFFALSE 6069
// ComMoveXY ( i , 201 , 132 ) ;
6054: LD_VAR 0 5
6058: PPUSH
6059: LD_INT 201
6061: PPUSH
6062: LD_INT 132
6064: PPUSH
6065: CALL_OW 111
6069: GO 6039
6071: POP
6072: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
6073: LD_INT 21
6075: PPUSH
6076: LD_INT 22
6078: PUSH
6079: LD_INT 2
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PPUSH
6086: CALL_OW 70
6090: IFFALSE 6131
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
6092: LD_ADDR_VAR 0 5
6096: PUSH
6097: LD_INT 21
6099: PPUSH
6100: LD_INT 22
6102: PUSH
6103: LD_INT 2
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: PPUSH
6110: CALL_OW 70
6114: PUSH
6115: FOR_IN
6116: IFFALSE 6129
// RemoveUnit ( i ) ;
6118: LD_VAR 0 5
6122: PPUSH
6123: CALL_OW 64
6127: GO 6115
6129: POP
6130: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
6131: LD_INT 22
6133: PUSH
6134: LD_INT 2
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: PUSH
6141: LD_INT 2
6143: PUSH
6144: LD_INT 21
6146: PUSH
6147: LD_INT 1
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: PUSH
6154: LD_INT 21
6156: PUSH
6157: LD_INT 2
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: LIST
6168: PUSH
6169: EMPTY
6170: LIST
6171: LIST
6172: PPUSH
6173: CALL_OW 69
6177: NOT
6178: IFFALSE 6010
// end ;
6180: PPOPN 6
6182: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
6183: LD_EXP 9
6187: PUSH
6188: LD_INT 92
6190: PPUSH
6191: LD_INT 40
6193: PPUSH
6194: CALL_OW 428
6198: PPUSH
6199: CALL_OW 266
6203: PUSH
6204: LD_INT 30
6206: EQUAL
6207: AND
6208: IFFALSE 6404
6210: GO 6212
6212: DISABLE
6213: LD_INT 0
6215: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
6216: LD_ADDR_VAR 0 1
6220: PUSH
6221: LD_EXP 61
6225: PUSH
6226: LD_INT 1
6228: ARRAY
6229: PPUSH
6230: LD_INT 25
6232: PUSH
6233: LD_INT 4
6235: PUSH
6236: EMPTY
6237: LIST
6238: LIST
6239: PPUSH
6240: CALL_OW 72
6244: ST_TO_ADDR
// if not sci then
6245: LD_VAR 0 1
6249: NOT
6250: IFFALSE 6254
// exit ;
6252: GO 6404
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
6254: LD_ADDR_EXP 61
6258: PUSH
6259: LD_EXP 61
6263: PPUSH
6264: LD_INT 1
6266: PPUSH
6267: LD_EXP 61
6271: PUSH
6272: LD_INT 1
6274: ARRAY
6275: PUSH
6276: LD_VAR 0 1
6280: PUSH
6281: LD_INT 1
6283: ARRAY
6284: DIFF
6285: PPUSH
6286: CALL_OW 1
6290: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
6291: LD_VAR 0 1
6295: PUSH
6296: LD_INT 1
6298: ARRAY
6299: PPUSH
6300: CALL_OW 310
6304: IFFALSE 6319
// ComExitBuilding ( sci [ 1 ] ) ;
6306: LD_VAR 0 1
6310: PUSH
6311: LD_INT 1
6313: ARRAY
6314: PPUSH
6315: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
6319: LD_INT 2
6321: PPUSH
6322: LD_INT 105
6324: PPUSH
6325: LD_INT 14
6327: PPUSH
6328: LD_INT 20
6330: PPUSH
6331: CALL 22661 0 4
6335: PUSH
6336: LD_INT 4
6338: ARRAY
6339: PUSH
6340: LD_INT 10
6342: LESS
6343: IFFALSE 6366
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
6345: LD_VAR 0 1
6349: PUSH
6350: LD_INT 1
6352: ARRAY
6353: PPUSH
6354: LD_INT 105
6356: PPUSH
6357: LD_INT 14
6359: PPUSH
6360: CALL_OW 171
6364: GO 6385
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
6366: LD_VAR 0 1
6370: PUSH
6371: LD_INT 1
6373: ARRAY
6374: PPUSH
6375: LD_INT 118
6377: PPUSH
6378: LD_INT 77
6380: PPUSH
6381: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
6385: LD_VAR 0 1
6389: PUSH
6390: LD_INT 1
6392: ARRAY
6393: PPUSH
6394: LD_INT 92
6396: PPUSH
6397: LD_INT 40
6399: PPUSH
6400: CALL_OW 218
// end ;
6404: PPOPN 1
6406: END
// every 6 6$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , un , base , tmp , flags , _target , attackers , p ;
6407: LD_INT 1
6409: PPUSH
6410: CALL_OW 302
6414: PUSH
6415: LD_EXP 9
6419: AND
6420: IFFALSE 7291
6422: GO 6424
6424: DISABLE
6425: LD_INT 0
6427: PPUSH
6428: PPUSH
6429: PPUSH
6430: PPUSH
6431: PPUSH
6432: PPUSH
6433: PPUSH
6434: PPUSH
// begin enable ;
6435: ENABLE
// base := 1 ;
6436: LD_ADDR_VAR 0 3
6440: PUSH
6441: LD_INT 1
6443: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6444: LD_ADDR_VAR 0 5
6448: PUSH
6449: LD_INT 0
6451: PUSH
6452: LD_INT 0
6454: PUSH
6455: LD_INT 0
6457: PUSH
6458: LD_INT 0
6460: PUSH
6461: LD_INT 0
6463: PUSH
6464: LD_INT 0
6466: PUSH
6467: LD_INT 0
6469: PUSH
6470: LD_INT 0
6472: PUSH
6473: LD_INT 1
6475: PUSH
6476: LD_INT 0
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: LIST
6490: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
6491: LD_ADDR_VAR 0 4
6495: PUSH
6496: LD_INT 13
6498: PUSH
6499: LD_INT 1
6501: PUSH
6502: LD_INT 2
6504: PUSH
6505: LD_INT 26
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: LIST
6512: LIST
6513: PUSH
6514: LD_INT 13
6516: PUSH
6517: LD_INT 1
6519: PUSH
6520: LD_INT 2
6522: PUSH
6523: LD_INT 28
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: LIST
6530: LIST
6531: PUSH
6532: LD_INT 13
6534: PUSH
6535: LD_INT 1
6537: PUSH
6538: LD_INT 2
6540: PUSH
6541: LD_INT 29
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: LIST
6548: LIST
6549: PUSH
6550: EMPTY
6551: LIST
6552: LIST
6553: LIST
6554: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6555: LD_ADDR_VAR 0 1
6559: PUSH
6560: DOUBLE
6561: LD_INT 1
6563: DEC
6564: ST_TO_ADDR
6565: LD_OWVAR 67
6569: PUSH
6570: LD_OWVAR 1
6574: PUSH
6575: LD_INT 21000
6577: DIV
6578: PLUS
6579: PUSH
6580: FOR_TO
6581: IFFALSE 6654
// tmp := Insert ( tmp , tmp + 1 , [ ar_medium_trike , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6583: LD_ADDR_VAR 0 4
6587: PUSH
6588: LD_VAR 0 4
6592: PPUSH
6593: LD_VAR 0 4
6597: PUSH
6598: LD_INT 1
6600: PLUS
6601: PPUSH
6602: LD_INT 13
6604: PUSH
6605: LD_INT 1
6607: PUSH
6608: LD_INT 2
6610: PUSH
6611: LD_INT 28
6613: PUSH
6614: LD_INT 29
6616: PUSH
6617: LD_INT 25
6619: PUSH
6620: LD_INT 26
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 1
6631: PPUSH
6632: LD_INT 4
6634: PPUSH
6635: CALL_OW 12
6639: ARRAY
6640: PUSH
6641: EMPTY
6642: LIST
6643: LIST
6644: LIST
6645: LIST
6646: PPUSH
6647: CALL_OW 2
6651: ST_TO_ADDR
6652: GO 6580
6654: POP
6655: POP
// MC_InsertProduceList ( base , tmp ) ;
6656: LD_VAR 0 3
6660: PPUSH
6661: LD_VAR 0 4
6665: PPUSH
6666: CALL 82949 0 2
// wait ( 3 3$20 ) ;
6670: LD_INT 7000
6672: PPUSH
6673: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6677: LD_ADDR_VAR 0 6
6681: PUSH
6682: LD_INT 124
6684: PUSH
6685: LD_INT 85
6687: PUSH
6688: EMPTY
6689: LIST
6690: LIST
6691: PUSH
6692: LD_INT 90
6694: PUSH
6695: LD_INT 61
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PUSH
6702: LD_INT 69
6704: PUSH
6705: LD_INT 48
6707: PUSH
6708: EMPTY
6709: LIST
6710: LIST
6711: PUSH
6712: LD_INT 68
6714: PUSH
6715: LD_INT 48
6717: PUSH
6718: EMPTY
6719: LIST
6720: LIST
6721: PUSH
6722: EMPTY
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ] ) diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6728: LD_ADDR_VAR 0 7
6732: PUSH
6733: LD_INT 22
6735: PUSH
6736: LD_INT 2
6738: PUSH
6739: EMPTY
6740: LIST
6741: LIST
6742: PUSH
6743: LD_INT 21
6745: PUSH
6746: LD_INT 2
6748: PUSH
6749: EMPTY
6750: LIST
6751: LIST
6752: PUSH
6753: LD_INT 3
6755: PUSH
6756: LD_INT 34
6758: PUSH
6759: LD_INT 31
6761: PUSH
6762: EMPTY
6763: LIST
6764: LIST
6765: PUSH
6766: LD_INT 34
6768: PUSH
6769: LD_INT 88
6771: PUSH
6772: EMPTY
6773: LIST
6774: LIST
6775: PUSH
6776: LD_INT 34
6778: PUSH
6779: LD_INT 32
6781: PUSH
6782: EMPTY
6783: LIST
6784: LIST
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: LIST
6790: LIST
6791: PUSH
6792: EMPTY
6793: LIST
6794: LIST
6795: LIST
6796: PPUSH
6797: CALL_OW 69
6801: PUSH
6802: LD_EXP 80
6806: PUSH
6807: LD_VAR 0 3
6811: ARRAY
6812: PPUSH
6813: LD_INT 2
6815: PUSH
6816: LD_INT 34
6818: PUSH
6819: LD_INT 32
6821: PUSH
6822: EMPTY
6823: LIST
6824: LIST
6825: PUSH
6826: LD_INT 34
6828: PUSH
6829: LD_INT 88
6831: PUSH
6832: EMPTY
6833: LIST
6834: LIST
6835: PUSH
6836: EMPTY
6837: LIST
6838: LIST
6839: LIST
6840: PPUSH
6841: CALL_OW 72
6845: DIFF
6846: ST_TO_ADDR
// if rand ( 0 , 1 ) then
6847: LD_INT 0
6849: PPUSH
6850: LD_INT 1
6852: PPUSH
6853: CALL_OW 12
6857: IFFALSE 7007
// begin for i := 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
6859: LD_ADDR_VAR 0 1
6863: PUSH
6864: DOUBLE
6865: LD_INT 1
6867: DEC
6868: ST_TO_ADDR
6869: LD_INT 3
6871: PUSH
6872: LD_INT 4
6874: PUSH
6875: LD_INT 5
6877: PUSH
6878: LD_INT 6
6880: PUSH
6881: EMPTY
6882: LIST
6883: LIST
6884: LIST
6885: LIST
6886: PUSH
6887: LD_OWVAR 67
6891: ARRAY
6892: PUSH
6893: FOR_TO
6894: IFFALSE 7003
// begin uc_side := 2 ;
6896: LD_ADDR_OWVAR 20
6900: PUSH
6901: LD_INT 2
6903: ST_TO_ADDR
// uc_nation := 2 ;
6904: LD_ADDR_OWVAR 21
6908: PUSH
6909: LD_INT 2
6911: ST_TO_ADDR
// InitHc ;
6912: CALL_OW 19
// PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6916: LD_INT 0
6918: PPUSH
6919: LD_INT 15
6921: PUSH
6922: LD_INT 17
6924: PUSH
6925: EMPTY
6926: LIST
6927: LIST
6928: PUSH
6929: LD_INT 1
6931: PPUSH
6932: LD_INT 2
6934: PPUSH
6935: CALL_OW 12
6939: ARRAY
6940: PPUSH
6941: LD_INT 8
6943: PPUSH
6944: CALL_OW 380
// un := CreateHuman ;
6948: LD_ADDR_VAR 0 2
6952: PUSH
6953: CALL_OW 44
6957: ST_TO_ADDR
// SetDir ( un , 4 ) ;
6958: LD_VAR 0 2
6962: PPUSH
6963: LD_INT 4
6965: PPUSH
6966: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
6970: LD_VAR 0 2
6974: PPUSH
6975: LD_INT 23
6977: PPUSH
6978: LD_INT 0
6980: PPUSH
6981: CALL_OW 49
// attackers := attackers union un ;
6985: LD_ADDR_VAR 0 7
6989: PUSH
6990: LD_VAR 0 7
6994: PUSH
6995: LD_VAR 0 2
6999: UNION
7000: ST_TO_ADDR
// end ;
7001: GO 6893
7003: POP
7004: POP
// end else
7005: GO 7165
// begin for i := 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
7007: LD_ADDR_VAR 0 1
7011: PUSH
7012: DOUBLE
7013: LD_INT 1
7015: DEC
7016: ST_TO_ADDR
7017: LD_INT 2
7019: PUSH
7020: LD_INT 3
7022: PUSH
7023: LD_INT 4
7025: PUSH
7026: LD_INT 5
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: PUSH
7035: LD_OWVAR 67
7039: ARRAY
7040: PUSH
7041: FOR_TO
7042: IFFALSE 7163
// begin uc_side := 2 ;
7044: LD_ADDR_OWVAR 20
7048: PUSH
7049: LD_INT 2
7051: ST_TO_ADDR
// uc_nation := 2 ;
7052: LD_ADDR_OWVAR 21
7056: PUSH
7057: LD_INT 2
7059: ST_TO_ADDR
// InitHc ;
7060: CALL_OW 19
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_flame_thrower ] [ i mod 3 + 1 ] , 100 ) ;
7064: LD_INT 14
7066: PPUSH
7067: LD_INT 3
7069: PPUSH
7070: LD_INT 5
7072: PPUSH
7073: LD_INT 29
7075: PUSH
7076: LD_INT 29
7078: PUSH
7079: LD_INT 26
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: LD_VAR 0 1
7091: PUSH
7092: LD_INT 3
7094: MOD
7095: PUSH
7096: LD_INT 1
7098: PLUS
7099: ARRAY
7100: PPUSH
7101: LD_INT 100
7103: PPUSH
7104: CALL 21275 0 5
// un := CreateVehicle ;
7108: LD_ADDR_VAR 0 2
7112: PUSH
7113: CALL_OW 45
7117: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7118: LD_VAR 0 2
7122: PPUSH
7123: LD_INT 4
7125: PPUSH
7126: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7130: LD_VAR 0 2
7134: PPUSH
7135: LD_INT 23
7137: PPUSH
7138: LD_INT 0
7140: PPUSH
7141: CALL_OW 49
// attackers := attackers union un ;
7145: LD_ADDR_VAR 0 7
7149: PUSH
7150: LD_VAR 0 7
7154: PUSH
7155: LD_VAR 0 2
7159: UNION
7160: ST_TO_ADDR
// end ;
7161: GO 7041
7163: POP
7164: POP
// end ; if not attackers then
7165: LD_VAR 0 7
7169: NOT
7170: IFFALSE 7174
// exit ;
7172: GO 7291
// ar_attackers := attackers ;
7174: LD_ADDR_EXP 11
7178: PUSH
7179: LD_VAR 0 7
7183: ST_TO_ADDR
// p := 0 ;
7184: LD_ADDR_VAR 0 8
7188: PUSH
7189: LD_INT 0
7191: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7192: LD_INT 35
7194: PPUSH
7195: CALL_OW 67
// p := Inc ( p ) ;
7199: LD_ADDR_VAR 0 8
7203: PUSH
7204: LD_VAR 0 8
7208: PPUSH
7209: CALL 55498 0 1
7213: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7214: LD_VAR 0 7
7218: PPUSH
7219: LD_INT 60
7221: PUSH
7222: EMPTY
7223: LIST
7224: PPUSH
7225: CALL_OW 72
7229: NOT
7230: PUSH
7231: LD_VAR 0 8
7235: PUSH
7236: LD_INT 30
7238: GREATER
7239: OR
7240: IFFALSE 7192
// repeat wait ( 0 0$1 ) ;
7242: LD_INT 35
7244: PPUSH
7245: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
7249: LD_ADDR_VAR 0 7
7253: PUSH
7254: LD_VAR 0 7
7258: PPUSH
7259: LD_INT 50
7261: PUSH
7262: EMPTY
7263: LIST
7264: PPUSH
7265: CALL_OW 72
7269: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
7270: LD_VAR 0 7
7274: PPUSH
7275: LD_VAR 0 6
7279: PPUSH
7280: CALL 56741 0 2
// until not attackers ;
7284: LD_VAR 0 7
7288: NOT
7289: IFFALSE 7242
// end ;
7291: PPOPN 8
7293: END
// every 5 5$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) do var i , base , tmp , flags , _target , attackers , un , p ;
7294: LD_INT 1
7296: PPUSH
7297: CALL_OW 302
7301: PUSH
7302: LD_EXP 9
7306: AND
7307: PUSH
7308: LD_EXP 51
7312: PPUSH
7313: LD_INT 22
7315: PPUSH
7316: CALL_OW 308
7320: AND
7321: IFFALSE 7809
7323: GO 7325
7325: DISABLE
7326: LD_INT 0
7328: PPUSH
7329: PPUSH
7330: PPUSH
7331: PPUSH
7332: PPUSH
7333: PPUSH
7334: PPUSH
7335: PPUSH
// begin base := 1 ;
7336: LD_ADDR_VAR 0 2
7340: PUSH
7341: LD_INT 1
7343: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7344: LD_ADDR_VAR 0 4
7348: PUSH
7349: LD_INT 0
7351: PUSH
7352: LD_INT 0
7354: PUSH
7355: LD_INT 0
7357: PUSH
7358: LD_INT 0
7360: PUSH
7361: LD_INT 0
7363: PUSH
7364: LD_INT 0
7366: PUSH
7367: LD_INT 0
7369: PUSH
7370: LD_INT 0
7372: PUSH
7373: LD_INT 1
7375: PUSH
7376: LD_INT 0
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: LIST
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: LIST
7388: LIST
7389: LIST
7390: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
7391: LD_ADDR_VAR 0 3
7395: PUSH
7396: LD_INT 13
7398: PUSH
7399: LD_INT 1
7401: PUSH
7402: LD_INT 2
7404: PUSH
7405: LD_INT 28
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: LIST
7412: LIST
7413: PUSH
7414: LD_INT 13
7416: PUSH
7417: LD_INT 1
7419: PUSH
7420: LD_INT 2
7422: PUSH
7423: LD_INT 27
7425: PUSH
7426: EMPTY
7427: LIST
7428: LIST
7429: LIST
7430: LIST
7431: PUSH
7432: LD_INT 13
7434: PUSH
7435: LD_INT 1
7437: PUSH
7438: LD_INT 2
7440: PUSH
7441: LD_INT 25
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: LIST
7448: LIST
7449: PUSH
7450: LD_INT 11
7452: PUSH
7453: LD_INT 2
7455: PUSH
7456: LD_INT 2
7458: PUSH
7459: LD_INT 24
7461: PUSH
7462: EMPTY
7463: LIST
7464: LIST
7465: LIST
7466: LIST
7467: PUSH
7468: LD_INT 11
7470: PUSH
7471: LD_INT 2
7473: PUSH
7474: LD_INT 2
7476: PUSH
7477: LD_INT 24
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: LIST
7484: LIST
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: LIST
7490: LIST
7491: LIST
7492: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7493: LD_VAR 0 2
7497: PPUSH
7498: LD_VAR 0 3
7502: PPUSH
7503: CALL 82949 0 2
// wait ( 4 4$20 ) ;
7507: LD_INT 9100
7509: PPUSH
7510: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
7514: LD_ADDR_VAR 0 5
7518: PUSH
7519: LD_INT 119
7521: PUSH
7522: LD_INT 9
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: PUSH
7529: EMPTY
7530: LIST
7531: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7532: LD_ADDR_VAR 0 6
7536: PUSH
7537: LD_EXP 80
7541: PUSH
7542: LD_VAR 0 2
7546: ARRAY
7547: PUSH
7548: LD_EXP 80
7552: PUSH
7553: LD_VAR 0 2
7557: ARRAY
7558: PPUSH
7559: LD_INT 2
7561: PUSH
7562: LD_INT 34
7564: PUSH
7565: LD_INT 32
7567: PUSH
7568: EMPTY
7569: LIST
7570: LIST
7571: PUSH
7572: LD_INT 34
7574: PUSH
7575: LD_INT 88
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: LIST
7586: PPUSH
7587: CALL_OW 72
7591: DIFF
7592: ST_TO_ADDR
// uc_side := 2 ;
7593: LD_ADDR_OWVAR 20
7597: PUSH
7598: LD_INT 2
7600: ST_TO_ADDR
// uc_nation := 2 ;
7601: LD_ADDR_OWVAR 21
7605: PUSH
7606: LD_INT 2
7608: ST_TO_ADDR
// InitHc ;
7609: CALL_OW 19
// for i := 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
7613: LD_ADDR_VAR 0 1
7617: PUSH
7618: DOUBLE
7619: LD_INT 1
7621: DEC
7622: ST_TO_ADDR
7623: LD_INT 4
7625: PUSH
7626: LD_INT 5
7628: PUSH
7629: LD_INT 6
7631: PUSH
7632: LD_INT 6
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: LIST
7639: LIST
7640: PUSH
7641: LD_OWVAR 67
7645: ARRAY
7646: PUSH
7647: FOR_TO
7648: IFFALSE 7725
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7650: LD_INT 0
7652: PPUSH
7653: LD_INT 15
7655: PUSH
7656: LD_INT 17
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: LD_INT 1
7665: PPUSH
7666: LD_INT 2
7668: PPUSH
7669: CALL_OW 12
7673: ARRAY
7674: PPUSH
7675: LD_INT 8
7677: PPUSH
7678: CALL_OW 380
// un := CreateHuman ;
7682: LD_ADDR_VAR 0 7
7686: PUSH
7687: CALL_OW 44
7691: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
7692: LD_VAR 0 7
7696: PPUSH
7697: LD_INT 23
7699: PPUSH
7700: LD_INT 0
7702: PPUSH
7703: CALL_OW 49
// attackers := attackers union un ;
7707: LD_ADDR_VAR 0 6
7711: PUSH
7712: LD_VAR 0 6
7716: PUSH
7717: LD_VAR 0 7
7721: UNION
7722: ST_TO_ADDR
// end ;
7723: GO 7647
7725: POP
7726: POP
// p := 0 ;
7727: LD_ADDR_VAR 0 8
7731: PUSH
7732: LD_INT 0
7734: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7735: LD_INT 35
7737: PPUSH
7738: CALL_OW 67
// p := Inc ( p ) ;
7742: LD_ADDR_VAR 0 8
7746: PUSH
7747: LD_VAR 0 8
7751: PPUSH
7752: CALL 55498 0 1
7756: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7757: LD_VAR 0 6
7761: PPUSH
7762: LD_INT 60
7764: PUSH
7765: EMPTY
7766: LIST
7767: PPUSH
7768: CALL_OW 72
7772: NOT
7773: PUSH
7774: LD_VAR 0 8
7778: PUSH
7779: LD_INT 30
7781: GREATER
7782: OR
7783: IFFALSE 7735
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
7785: LD_VAR 0 2
7789: PPUSH
7790: LD_VAR 0 6
7794: PPUSH
7795: LD_VAR 0 5
7799: PPUSH
7800: LD_VAR 0 4
7804: PPUSH
7805: CALL 83134 0 4
// end ; end_of_file
7809: PPOPN 8
7811: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
7812: LD_INT 0
7814: PPUSH
7815: PPUSH
7816: PPUSH
7817: PPUSH
7818: PPUSH
7819: PPUSH
// uc_side := 1 ;
7820: LD_ADDR_OWVAR 20
7824: PUSH
7825: LD_INT 1
7827: ST_TO_ADDR
// uc_nation := 1 ;
7828: LD_ADDR_OWVAR 21
7832: PUSH
7833: LD_INT 1
7835: ST_TO_ADDR
// InitHc ;
7836: CALL_OW 19
// InitVc ;
7840: CALL_OW 20
// tmp := [ ] ;
7844: LD_ADDR_VAR 0 3
7848: PUSH
7849: EMPTY
7850: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
7851: LD_ADDR_VAR 0 2
7855: PUSH
7856: DOUBLE
7857: LD_INT 1
7859: DEC
7860: ST_TO_ADDR
7861: LD_INT 6
7863: PUSH
7864: LD_INT 8
7866: PUSH
7867: LD_INT 10
7869: PUSH
7870: LD_INT 10
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: LIST
7877: LIST
7878: PUSH
7879: LD_OWVAR 67
7883: ARRAY
7884: PUSH
7885: FOR_TO
7886: IFFALSE 8176
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
7888: LD_ADDR_VAR 0 5
7892: PUSH
7893: LD_INT 2
7895: PUSH
7896: LD_INT 4
7898: PUSH
7899: LD_INT 5
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: LIST
7906: PUSH
7907: LD_INT 1
7909: PPUSH
7910: LD_INT 3
7912: PPUSH
7913: CALL_OW 12
7917: ARRAY
7918: ST_TO_ADDR
// case chassis of us_medium_wheeled :
7919: LD_VAR 0 5
7923: PUSH
7924: LD_INT 2
7926: DOUBLE
7927: EQUAL
7928: IFTRUE 7932
7930: GO 7966
7932: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
7933: LD_ADDR_VAR 0 6
7937: PUSH
7938: LD_INT 9
7940: PUSH
7941: LD_INT 5
7943: PUSH
7944: LD_INT 7
7946: PUSH
7947: EMPTY
7948: LIST
7949: LIST
7950: LIST
7951: PUSH
7952: LD_INT 1
7954: PPUSH
7955: LD_INT 3
7957: PPUSH
7958: CALL_OW 12
7962: ARRAY
7963: ST_TO_ADDR
7964: GO 8055
7966: LD_INT 4
7968: DOUBLE
7969: EQUAL
7970: IFTRUE 7974
7972: GO 8012
7974: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7975: LD_ADDR_VAR 0 6
7979: PUSH
7980: LD_INT 9
7982: PUSH
7983: LD_INT 6
7985: PUSH
7986: LD_INT 6
7988: PUSH
7989: LD_INT 7
7991: PUSH
7992: EMPTY
7993: LIST
7994: LIST
7995: LIST
7996: LIST
7997: PUSH
7998: LD_INT 1
8000: PPUSH
8001: LD_INT 4
8003: PPUSH
8004: CALL_OW 12
8008: ARRAY
8009: ST_TO_ADDR
8010: GO 8055
8012: LD_INT 5
8014: DOUBLE
8015: EQUAL
8016: IFTRUE 8020
8018: GO 8054
8020: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
8021: LD_ADDR_VAR 0 6
8025: PUSH
8026: LD_INT 9
8028: PUSH
8029: LD_INT 6
8031: PUSH
8032: LD_INT 7
8034: PUSH
8035: EMPTY
8036: LIST
8037: LIST
8038: LIST
8039: PUSH
8040: LD_INT 1
8042: PPUSH
8043: LD_INT 3
8045: PPUSH
8046: CALL_OW 12
8050: ARRAY
8051: ST_TO_ADDR
8052: GO 8055
8054: POP
// uc_side := 1 ;
8055: LD_ADDR_OWVAR 20
8059: PUSH
8060: LD_INT 1
8062: ST_TO_ADDR
// uc_nation := 1 ;
8063: LD_ADDR_OWVAR 21
8067: PUSH
8068: LD_INT 1
8070: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
8071: LD_VAR 0 5
8075: PPUSH
8076: LD_INT 1
8078: PUSH
8079: LD_INT 3
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: PUSH
8086: LD_INT 1
8088: PPUSH
8089: LD_INT 2
8091: PPUSH
8092: CALL_OW 12
8096: ARRAY
8097: PPUSH
8098: LD_INT 3
8100: PPUSH
8101: LD_VAR 0 6
8105: PPUSH
8106: LD_INT 70
8108: PPUSH
8109: LD_INT 90
8111: PPUSH
8112: CALL_OW 12
8116: PPUSH
8117: CALL 21275 0 5
// veh := CreateVehicle ;
8121: LD_ADDR_VAR 0 4
8125: PUSH
8126: CALL_OW 45
8130: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
8131: LD_VAR 0 4
8135: PPUSH
8136: LD_INT 2
8138: PPUSH
8139: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
8143: LD_VAR 0 4
8147: PPUSH
8148: LD_INT 17
8150: PPUSH
8151: LD_INT 0
8153: PPUSH
8154: CALL_OW 49
// tmp := tmp ^ veh ;
8158: LD_ADDR_VAR 0 3
8162: PUSH
8163: LD_VAR 0 3
8167: PUSH
8168: LD_VAR 0 4
8172: ADD
8173: ST_TO_ADDR
// end ;
8174: GO 7885
8176: POP
8177: POP
// if not tmp then
8178: LD_VAR 0 3
8182: NOT
8183: IFFALSE 8187
// exit ;
8185: GO 8296
// if not first_powell_attack then
8187: LD_EXP 12
8191: NOT
8192: IFFALSE 8202
// first_powell_attack := true ;
8194: LD_ADDR_EXP 12
8198: PUSH
8199: LD_INT 1
8201: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
8202: LD_INT 70
8204: PPUSH
8205: CALL_OW 67
// for i in tmp do
8209: LD_ADDR_VAR 0 2
8213: PUSH
8214: LD_VAR 0 3
8218: PUSH
8219: FOR_IN
8220: IFFALSE 8287
// if IsOk ( i ) then
8222: LD_VAR 0 2
8226: PPUSH
8227: CALL_OW 302
8231: IFFALSE 8269
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
8233: LD_VAR 0 2
8237: PPUSH
8238: LD_INT 81
8240: PUSH
8241: LD_INT 1
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: PPUSH
8248: CALL_OW 69
8252: PPUSH
8253: LD_VAR 0 2
8257: PPUSH
8258: CALL_OW 74
8262: PPUSH
8263: CALL_OW 115
8267: GO 8285
// tmp := tmp diff i ;
8269: LD_ADDR_VAR 0 3
8273: PUSH
8274: LD_VAR 0 3
8278: PUSH
8279: LD_VAR 0 2
8283: DIFF
8284: ST_TO_ADDR
8285: GO 8219
8287: POP
8288: POP
// until not tmp ;
8289: LD_VAR 0 3
8293: NOT
8294: IFFALSE 8202
// end ;
8296: LD_VAR 0 1
8300: RET
// export function TryToStoleArtifact ( artifact ) ; var veh ; begin
8301: LD_INT 0
8303: PPUSH
8304: PPUSH
// uc_side := 1 ;
8305: LD_ADDR_OWVAR 20
8309: PUSH
8310: LD_INT 1
8312: ST_TO_ADDR
// uc_nation := 1 ;
8313: LD_ADDR_OWVAR 21
8317: PUSH
8318: LD_INT 1
8320: ST_TO_ADDR
// InitHc ;
8321: CALL_OW 19
// InitVc ;
8325: CALL_OW 20
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
8329: LD_INT 5
8331: PPUSH
8332: LD_INT 3
8334: PPUSH
8335: LD_INT 3
8337: PPUSH
8338: LD_INT 12
8340: PPUSH
8341: LD_INT 100
8343: PPUSH
8344: CALL 21275 0 5
// veh := CreateVehicle ;
8348: LD_ADDR_VAR 0 3
8352: PUSH
8353: CALL_OW 45
8357: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
8358: LD_VAR 0 3
8362: PPUSH
8363: LD_INT 2
8365: PPUSH
8366: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
8370: LD_VAR 0 3
8374: PPUSH
8375: LD_INT 17
8377: PPUSH
8378: LD_INT 0
8380: PPUSH
8381: CALL_OW 49
// ComGet ( veh , artifact [ 1 ] , artifact [ 2 ] ) ;
8385: LD_VAR 0 3
8389: PPUSH
8390: LD_VAR 0 1
8394: PUSH
8395: LD_INT 1
8397: ARRAY
8398: PPUSH
8399: LD_VAR 0 1
8403: PUSH
8404: LD_INT 2
8406: ARRAY
8407: PPUSH
8408: CALL_OW 160
// AddComMoveXY ( veh , 59 , 2 ) ;
8412: LD_VAR 0 3
8416: PPUSH
8417: LD_INT 59
8419: PPUSH
8420: LD_INT 2
8422: PPUSH
8423: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8427: LD_INT 35
8429: PPUSH
8430: CALL_OW 67
// if not IsOk ( veh ) then
8434: LD_VAR 0 3
8438: PPUSH
8439: CALL_OW 302
8443: NOT
8444: IFFALSE 8448
// exit ;
8446: GO 8502
// until IsAt ( veh , 59 , 2 ) ;
8448: LD_VAR 0 3
8452: PPUSH
8453: LD_INT 59
8455: PPUSH
8456: LD_INT 2
8458: PPUSH
8459: CALL_OW 307
8463: IFFALSE 8427
// RemoveUnit ( veh ) ;
8465: LD_VAR 0 3
8469: PPUSH
8470: CALL_OW 64
// if GetCargo ( veh , mat_artifact ) then
8474: LD_VAR 0 3
8478: PPUSH
8479: LD_INT 4
8481: PPUSH
8482: CALL_OW 289
8486: IFFALSE 8502
// begin wait ( 0 0$2 ) ;
8488: LD_INT 70
8490: PPUSH
8491: CALL_OW 67
// YouLost ( Artifact ) ;
8495: LD_STRING Artifact
8497: PPUSH
8498: CALL_OW 104
// end ; end ; end_of_file
8502: LD_VAR 0 2
8506: RET
// export function Action ; var tmp , i , un ; begin
8507: LD_INT 0
8509: PPUSH
8510: PPUSH
8511: PPUSH
8512: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
8513: LD_INT 68
8515: PPUSH
8516: LD_INT 39
8518: PPUSH
8519: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
8523: LD_ADDR_VAR 0 2
8527: PUSH
8528: LD_INT 22
8530: PUSH
8531: LD_INT 7
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: PPUSH
8538: CALL_OW 69
8542: ST_TO_ADDR
// InGameOn ;
8543: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
8547: LD_VAR 0 2
8551: PPUSH
8552: LD_INT 71
8554: PPUSH
8555: LD_INT 49
8557: PPUSH
8558: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8562: LD_INT 35
8564: PPUSH
8565: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
8569: LD_INT 7
8571: PPUSH
8572: LD_INT 71
8574: PPUSH
8575: LD_INT 51
8577: PPUSH
8578: CALL_OW 293
8582: IFFALSE 8562
// DialogueOn ;
8584: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
8588: LD_EXP 16
8592: PPUSH
8593: LD_STRING D1-JMM-1
8595: PPUSH
8596: CALL_OW 88
// if Joan then
8600: LD_EXP 31
8604: IFFALSE 8618
// Say ( Joan , D1-Joan-1 ) ;
8606: LD_EXP 31
8610: PPUSH
8611: LD_STRING D1-Joan-1
8613: PPUSH
8614: CALL_OW 88
// if Lisa then
8618: LD_EXP 18
8622: IFFALSE 8636
// Say ( Lisa , D1-Lisa-1 ) ;
8624: LD_EXP 18
8628: PPUSH
8629: LD_STRING D1-Lisa-1
8631: PPUSH
8632: CALL_OW 88
// if Joan or Lisa then
8636: LD_EXP 31
8640: PUSH
8641: LD_EXP 18
8645: OR
8646: IFFALSE 8660
// Say ( JMM , D1-JMM-2 ) ;
8648: LD_EXP 16
8652: PPUSH
8653: LD_STRING D1-JMM-2
8655: PPUSH
8656: CALL_OW 88
// DialogueOff ;
8660: CALL_OW 7
// InGameOff ;
8664: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
8668: LD_INT 71
8670: PPUSH
8671: LD_INT 50
8673: PPUSH
8674: LD_INT 7
8676: PPUSH
8677: LD_INT 30
8679: NEG
8680: PPUSH
8681: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
8685: LD_INT 71
8687: PPUSH
8688: LD_INT 50
8690: PPUSH
8691: LD_INT 7
8693: PPUSH
8694: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
8698: LD_STRING M1
8700: PPUSH
8701: CALL_OW 337
// SaveForQuickRestart ;
8705: CALL_OW 22
// repeat wait ( 0 0$1 ) ;
8709: LD_INT 35
8711: PPUSH
8712: CALL_OW 67
// until freedom or tick > 1 1$00 ;
8716: LD_EXP 3
8720: PUSH
8721: LD_OWVAR 1
8725: PUSH
8726: LD_INT 2100
8728: GREATER
8729: OR
8730: IFFALSE 8709
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
8732: LD_INT 350
8734: PPUSH
8735: LD_INT 700
8737: PPUSH
8738: CALL_OW 12
8742: PPUSH
8743: CALL_OW 67
// PrepareGossudarov ;
8747: CALL 1935 0 0
// repeat wait ( 0 0$1 ) ;
8751: LD_INT 35
8753: PPUSH
8754: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
8758: LD_INT 22
8760: PUSH
8761: LD_INT 6
8763: PUSH
8764: EMPTY
8765: LIST
8766: LIST
8767: PUSH
8768: LD_INT 3
8770: PUSH
8771: LD_INT 24
8773: PUSH
8774: LD_INT 1000
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: PUSH
8785: EMPTY
8786: LIST
8787: LIST
8788: PPUSH
8789: CALL_OW 69
8793: PUSH
8794: LD_INT 7
8796: PPUSH
8797: LD_EXP 34
8801: PPUSH
8802: CALL_OW 292
8806: OR
8807: IFFALSE 8751
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
8809: LD_ADDR_VAR 0 2
8813: PUSH
8814: LD_INT 22
8816: PUSH
8817: LD_INT 6
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: PPUSH
8824: CALL_OW 69
8828: ST_TO_ADDR
// for i in tmp do
8829: LD_ADDR_VAR 0 3
8833: PUSH
8834: LD_VAR 0 2
8838: PUSH
8839: FOR_IN
8840: IFFALSE 8856
// SetSide ( i , 7 ) ;
8842: LD_VAR 0 3
8846: PPUSH
8847: LD_INT 7
8849: PPUSH
8850: CALL_OW 235
8854: GO 8839
8856: POP
8857: POP
// DialogueOn ;
8858: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
8862: LD_EXP 16
8866: PUSH
8867: LD_EXP 17
8871: PUSH
8872: EMPTY
8873: LIST
8874: LIST
8875: PPUSH
8876: LD_EXP 34
8880: PPUSH
8881: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
8885: LD_EXP 34
8889: PPUSH
8890: CALL_OW 87
// if not Roth then
8894: LD_EXP 17
8898: NOT
8899: IFFALSE 8991
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8901: LD_VAR 0 2
8905: PPUSH
8906: LD_INT 3
8908: PUSH
8909: LD_INT 24
8911: PUSH
8912: LD_INT 1000
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: PPUSH
8923: CALL_OW 72
8927: IFFALSE 8941
// Say ( JMM , D2-JMM-1 ) ;
8929: LD_EXP 16
8933: PPUSH
8934: LD_STRING D2-JMM-1
8936: PPUSH
8937: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
8941: LD_EXP 16
8945: PPUSH
8946: LD_STRING D2-JMM-1b
8948: PPUSH
8949: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
8953: LD_EXP 34
8957: PPUSH
8958: LD_STRING D2-Gos-1
8960: PPUSH
8961: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
8965: LD_EXP 16
8969: PPUSH
8970: LD_STRING D2-JMM-2
8972: PPUSH
8973: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
8977: LD_EXP 34
8981: PPUSH
8982: LD_STRING D2-Gos-2
8984: PPUSH
8985: CALL_OW 88
// end else
8989: GO 9143
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8991: LD_VAR 0 2
8995: PPUSH
8996: LD_INT 3
8998: PUSH
8999: LD_INT 24
9001: PUSH
9002: LD_INT 1000
9004: PUSH
9005: EMPTY
9006: LIST
9007: LIST
9008: PUSH
9009: EMPTY
9010: LIST
9011: LIST
9012: PPUSH
9013: CALL_OW 72
9017: IFFALSE 9043
// begin Say ( Roth , D2-Roth-2 ) ;
9019: LD_EXP 17
9023: PPUSH
9024: LD_STRING D2-Roth-2
9026: PPUSH
9027: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
9031: LD_EXP 16
9035: PPUSH
9036: LD_STRING D2-JMM-1a
9038: PPUSH
9039: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
9043: LD_EXP 17
9047: PPUSH
9048: LD_STRING D2-Roth-2a
9050: PPUSH
9051: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
9055: LD_EXP 17
9059: PPUSH
9060: LD_STRING D2-Roth-2b
9062: PPUSH
9063: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
9067: LD_EXP 16
9071: PPUSH
9072: LD_STRING D2-JMM-3
9074: PPUSH
9075: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9079: LD_VAR 0 2
9083: PPUSH
9084: LD_INT 3
9086: PUSH
9087: LD_INT 24
9089: PUSH
9090: LD_INT 1000
9092: PUSH
9093: EMPTY
9094: LIST
9095: LIST
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: PPUSH
9101: CALL_OW 72
9105: IFFALSE 9143
// begin Say ( Gossudarov , D2-Gos-3 ) ;
9107: LD_EXP 34
9111: PPUSH
9112: LD_STRING D2-Gos-3
9114: PPUSH
9115: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
9119: LD_EXP 16
9123: PPUSH
9124: LD_STRING D2-JMM-4
9126: PPUSH
9127: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
9131: LD_EXP 34
9135: PPUSH
9136: LD_STRING D2-Gos-4
9138: PPUSH
9139: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
9143: LD_EXP 16
9147: PPUSH
9148: LD_STRING D2-JMM-5
9150: PPUSH
9151: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
9155: LD_EXP 34
9159: PPUSH
9160: LD_STRING D2-Gos-5
9162: PPUSH
9163: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
9167: LD_EXP 16
9171: PPUSH
9172: LD_STRING D2-JMM-6
9174: PPUSH
9175: CALL_OW 88
// DialogueOff ;
9179: CALL_OW 7
// wait ( 0 0$2 ) ;
9183: LD_INT 70
9185: PPUSH
9186: CALL_OW 67
// if Kirilenkova then
9190: LD_EXP 35
9194: IFFALSE 9208
// Say ( Kirilenkova , D3-Kir-1 ) ;
9196: LD_EXP 35
9200: PPUSH
9201: LD_STRING D3-Kir-1
9203: PPUSH
9204: CALL_OW 88
// gossudarov_arrive := true ;
9208: LD_ADDR_EXP 4
9212: PUSH
9213: LD_INT 1
9215: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9216: LD_INT 35
9218: PPUSH
9219: CALL_OW 67
// until ru_lab_builded ;
9223: LD_EXP 5
9227: IFFALSE 9216
// DialogueOn ;
9229: CALL_OW 6
// if Kirilenkova then
9233: LD_EXP 35
9237: IFFALSE 9253
// Say ( Kirilenkova , D3a-Kir-1 ) else
9239: LD_EXP 35
9243: PPUSH
9244: LD_STRING D3a-Kir-1
9246: PPUSH
9247: CALL_OW 88
9251: GO 9275
// begin un := SciRu ;
9253: LD_ADDR_VAR 0 4
9257: PUSH
9258: CALL 14789 0 0
9262: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
9263: LD_VAR 0 4
9267: PPUSH
9268: LD_STRING D3a-Sci1-1
9270: PPUSH
9271: CALL_OW 88
// end ; if Kirilenkova or un then
9275: LD_EXP 35
9279: PUSH
9280: LD_VAR 0 4
9284: OR
9285: IFFALSE 9299
// Say ( JMM , D3a-JMM-1 ) ;
9287: LD_EXP 16
9291: PPUSH
9292: LD_STRING D3a-JMM-1
9294: PPUSH
9295: CALL_OW 88
// DialogueOff ;
9299: CALL_OW 7
// end ;
9303: LD_VAR 0 1
9307: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
9308: LD_EXP 4
9312: PUSH
9313: LD_INT 22
9315: PUSH
9316: LD_INT 7
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: PUSH
9323: LD_INT 2
9325: PUSH
9326: LD_INT 25
9328: PUSH
9329: LD_INT 1
9331: PUSH
9332: EMPTY
9333: LIST
9334: LIST
9335: PUSH
9336: LD_INT 25
9338: PUSH
9339: LD_INT 2
9341: PUSH
9342: EMPTY
9343: LIST
9344: LIST
9345: PUSH
9346: LD_INT 25
9348: PUSH
9349: LD_INT 3
9351: PUSH
9352: EMPTY
9353: LIST
9354: LIST
9355: PUSH
9356: LD_INT 25
9358: PUSH
9359: LD_INT 4
9361: PUSH
9362: EMPTY
9363: LIST
9364: LIST
9365: PUSH
9366: LD_INT 25
9368: PUSH
9369: LD_INT 5
9371: PUSH
9372: EMPTY
9373: LIST
9374: LIST
9375: PUSH
9376: LD_INT 25
9378: PUSH
9379: LD_INT 8
9381: PUSH
9382: EMPTY
9383: LIST
9384: LIST
9385: PUSH
9386: LD_INT 25
9388: PUSH
9389: LD_INT 9
9391: PUSH
9392: EMPTY
9393: LIST
9394: LIST
9395: PUSH
9396: EMPTY
9397: LIST
9398: LIST
9399: LIST
9400: LIST
9401: LIST
9402: LIST
9403: LIST
9404: LIST
9405: PUSH
9406: EMPTY
9407: LIST
9408: LIST
9409: PPUSH
9410: CALL_OW 69
9414: PUSH
9415: LD_INT 7
9417: LESS
9418: AND
9419: IFFALSE 9431
9421: GO 9423
9423: DISABLE
// YouLost ( TooMany ) ;
9424: LD_STRING TooMany
9426: PPUSH
9427: CALL_OW 104
9431: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
9432: LD_EXP 34
9436: PPUSH
9437: CALL_OW 255
9441: PUSH
9442: LD_INT 7
9444: EQUAL
9445: IFFALSE 9662
9447: GO 9449
9449: DISABLE
9450: LD_INT 0
9452: PPUSH
9453: PPUSH
9454: PPUSH
// begin uc_side := 3 ;
9455: LD_ADDR_OWVAR 20
9459: PUSH
9460: LD_INT 3
9462: ST_TO_ADDR
// uc_nation := 3 ;
9463: LD_ADDR_OWVAR 21
9467: PUSH
9468: LD_INT 3
9470: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
9471: LD_INT 21
9473: PPUSH
9474: LD_INT 3
9476: PPUSH
9477: LD_INT 3
9479: PPUSH
9480: LD_INT 42
9482: PPUSH
9483: LD_INT 100
9485: PPUSH
9486: CALL 21275 0 5
// un := CreateVehicle ;
9490: LD_ADDR_VAR 0 3
9494: PUSH
9495: CALL_OW 45
9499: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
9500: LD_VAR 0 3
9504: PPUSH
9505: LD_INT 15
9507: PPUSH
9508: LD_INT 0
9510: PPUSH
9511: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
9515: LD_VAR 0 3
9519: PPUSH
9520: LD_INT 67
9522: PPUSH
9523: LD_INT 45
9525: PPUSH
9526: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
9530: LD_VAR 0 3
9534: PPUSH
9535: LD_INT 70
9537: PPUSH
9538: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
9542: LD_VAR 0 3
9546: PPUSH
9547: LD_INT 69
9549: PPUSH
9550: LD_INT 18
9552: PPUSH
9553: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
9557: LD_VAR 0 3
9561: PPUSH
9562: LD_INT 60
9564: PPUSH
9565: LD_INT 3
9567: PPUSH
9568: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
9572: LD_INT 35
9574: PPUSH
9575: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
9579: LD_VAR 0 3
9583: PPUSH
9584: CALL_OW 302
9588: NOT
9589: PUSH
9590: LD_VAR 0 3
9594: PPUSH
9595: LD_INT 17
9597: PPUSH
9598: CALL_OW 308
9602: OR
9603: PUSH
9604: LD_VAR 0 3
9608: PPUSH
9609: LD_INT 60
9611: PPUSH
9612: LD_INT 3
9614: PPUSH
9615: CALL_OW 307
9619: OR
9620: IFFALSE 9572
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
9622: LD_VAR 0 3
9626: PPUSH
9627: LD_INT 17
9629: PPUSH
9630: CALL_OW 308
9634: PUSH
9635: LD_VAR 0 3
9639: PPUSH
9640: LD_INT 60
9642: PPUSH
9643: LD_INT 3
9645: PPUSH
9646: CALL_OW 307
9650: OR
9651: IFFALSE 9662
// RemoveUnit ( un ) ;
9653: LD_VAR 0 3
9657: PPUSH
9658: CALL_OW 64
// end ;
9662: PPOPN 3
9664: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
9665: LD_EXP 4
9669: IFFALSE 9911
9671: GO 9673
9673: DISABLE
9674: LD_INT 0
9676: PPUSH
9677: PPUSH
9678: PPUSH
// begin repeat wait ( 0 0$2 ) ;
9679: LD_INT 70
9681: PPUSH
9682: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
9686: LD_ADDR_VAR 0 3
9690: PUSH
9691: LD_INT 22
9693: PUSH
9694: LD_INT 7
9696: PUSH
9697: EMPTY
9698: LIST
9699: LIST
9700: PUSH
9701: LD_INT 101
9703: PUSH
9704: LD_INT 3
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: PUSH
9711: EMPTY
9712: LIST
9713: LIST
9714: PPUSH
9715: CALL_OW 69
9719: ST_TO_ADDR
// until tmp ;
9720: LD_VAR 0 3
9724: IFFALSE 9679
// un := NearestUnitToUnit ( tmp , JMM ) ;
9726: LD_ADDR_VAR 0 2
9730: PUSH
9731: LD_VAR 0 3
9735: PPUSH
9736: LD_EXP 16
9740: PPUSH
9741: CALL_OW 74
9745: ST_TO_ADDR
// player_spotted := true ;
9746: LD_ADDR_EXP 6
9750: PUSH
9751: LD_INT 1
9753: ST_TO_ADDR
// tmp := SciRu ;
9754: LD_ADDR_VAR 0 3
9758: PUSH
9759: CALL 14789 0 0
9763: ST_TO_ADDR
// if not tmp then
9764: LD_VAR 0 3
9768: NOT
9769: IFFALSE 9781
// tmp := SolRu ;
9771: LD_ADDR_VAR 0 3
9775: PUSH
9776: CALL 14936 0 0
9780: ST_TO_ADDR
// DialogueOn ;
9781: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
9785: LD_VAR 0 2
9789: PPUSH
9790: CALL_OW 250
9794: PPUSH
9795: LD_VAR 0 2
9799: PPUSH
9800: CALL_OW 251
9804: PPUSH
9805: LD_INT 7
9807: PPUSH
9808: LD_INT 8
9810: NEG
9811: PPUSH
9812: CALL_OW 330
// CenterNowOnUnits ( un ) ;
9816: LD_VAR 0 2
9820: PPUSH
9821: CALL_OW 87
// if tmp then
9825: LD_VAR 0 3
9829: IFFALSE 9843
// Say ( tmp , D4-RSci1-1 ) ;
9831: LD_VAR 0 3
9835: PPUSH
9836: LD_STRING D4-RSci1-1
9838: PPUSH
9839: CALL_OW 88
// if Gossudarov then
9843: LD_EXP 34
9847: IFFALSE 9873
// begin Say ( Gossudarov , D4-Gos-1 ) ;
9849: LD_EXP 34
9853: PPUSH
9854: LD_STRING D4-Gos-1
9856: PPUSH
9857: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
9861: LD_EXP 16
9865: PPUSH
9866: LD_STRING D4-JMM-1
9868: PPUSH
9869: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
9873: LD_VAR 0 2
9877: PPUSH
9878: CALL_OW 250
9882: PPUSH
9883: LD_VAR 0 2
9887: PPUSH
9888: CALL_OW 251
9892: PPUSH
9893: LD_INT 7
9895: PPUSH
9896: CALL_OW 331
// DialogueOff ;
9900: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
9904: LD_STRING M5
9906: PPUSH
9907: CALL_OW 337
// end ;
9911: PPOPN 3
9913: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
9914: LD_EXP 6
9918: IFFALSE 10511
9920: GO 9922
9922: DISABLE
9923: LD_INT 0
9925: PPUSH
9926: PPUSH
9927: PPUSH
// begin PrepareBelkov ;
9928: CALL 2248 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
9932: LD_EXP 49
9936: PPUSH
9937: LD_INT 118
9939: PPUSH
9940: LD_INT 106
9942: PPUSH
9943: CALL_OW 111
// AddComHold ( Belkov ) ;
9947: LD_EXP 49
9951: PPUSH
9952: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
9956: LD_INT 35
9958: PPUSH
9959: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
9963: LD_EXP 49
9967: PPUSH
9968: LD_INT 118
9970: PPUSH
9971: LD_INT 106
9973: PPUSH
9974: CALL_OW 307
9978: IFFALSE 9956
// ChangeSideFog ( 4 , 7 ) ;
9980: LD_INT 4
9982: PPUSH
9983: LD_INT 7
9985: PPUSH
9986: CALL_OW 343
// if IsOk ( Belkov ) then
9990: LD_EXP 49
9994: PPUSH
9995: CALL_OW 302
9999: IFFALSE 10083
// begin InGameOn ;
10001: CALL_OW 8
// DialogueOn ;
10005: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
10009: LD_EXP 49
10013: PPUSH
10014: LD_STRING D5-Bel-1
10016: PPUSH
10017: CALL_OW 94
// if Gossudarov then
10021: LD_EXP 34
10025: IFFALSE 10075
// begin Say ( Gossudarov , D5-Gos-1 ) ;
10027: LD_EXP 34
10031: PPUSH
10032: LD_STRING D5-Gos-1
10034: PPUSH
10035: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
10039: LD_EXP 16
10043: PPUSH
10044: LD_STRING D5-JMM-1
10046: PPUSH
10047: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
10051: LD_EXP 34
10055: PPUSH
10056: LD_STRING D5-Gos-2
10058: PPUSH
10059: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
10063: LD_EXP 16
10067: PPUSH
10068: LD_STRING D5-JMM-2
10070: PPUSH
10071: CALL_OW 88
// end ; DialogueOff ;
10075: CALL_OW 7
// InGameOff ;
10079: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
10083: LD_STRING QSaveBelkov
10085: PPUSH
10086: CALL_OW 97
10090: PUSH
10091: LD_INT 1
10093: DOUBLE
10094: EQUAL
10095: IFTRUE 10099
10097: GO 10149
10099: POP
// begin DialogueOn ;
10100: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
10104: LD_EXP 16
10108: PPUSH
10109: LD_STRING D5a-JMM-1
10111: PPUSH
10112: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
10116: LD_EXP 49
10120: PPUSH
10121: LD_STRING D5a-Bel-1
10123: PPUSH
10124: CALL_OW 94
// DialogueOff ;
10128: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
10132: LD_EXP 49
10136: PPUSH
10137: LD_INT 83
10139: PPUSH
10140: LD_INT 49
10142: PPUSH
10143: CALL_OW 111
// end ; 2 :
10147: GO 10182
10149: LD_INT 2
10151: DOUBLE
10152: EQUAL
10153: IFTRUE 10157
10155: GO 10181
10157: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
10158: LD_EXP 16
10162: PPUSH
10163: LD_STRING D5a-JMM-2
10165: PPUSH
10166: CALL_OW 88
// ComHold ( Belkov ) ;
10170: LD_EXP 49
10174: PPUSH
10175: CALL_OW 140
// end ; end ;
10179: GO 10182
10181: POP
// time := 0 0$00 ;
10182: LD_ADDR_VAR 0 1
10186: PUSH
10187: LD_INT 0
10189: ST_TO_ADDR
// vehSpawned := false ;
10190: LD_ADDR_VAR 0 3
10194: PUSH
10195: LD_INT 0
10197: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10198: LD_INT 35
10200: PPUSH
10201: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
10205: LD_VAR 0 1
10209: PUSH
10210: LD_INT 350
10212: PUSH
10213: LD_INT 175
10215: PUSH
10216: LD_INT 105
10218: PUSH
10219: LD_INT 70
10221: PUSH
10222: EMPTY
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: PUSH
10228: LD_OWVAR 67
10232: ARRAY
10233: GREATEREQUAL
10234: PUSH
10235: LD_VAR 0 3
10239: NOT
10240: AND
10241: IFFALSE 10331
// begin vehSpawned := true ;
10243: LD_ADDR_VAR 0 3
10247: PUSH
10248: LD_INT 1
10250: ST_TO_ADDR
// uc_side := 3 ;
10251: LD_ADDR_OWVAR 20
10255: PUSH
10256: LD_INT 3
10258: ST_TO_ADDR
// uc_nation := 3 ;
10259: LD_ADDR_OWVAR 21
10263: PUSH
10264: LD_INT 3
10266: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
10267: LD_INT 22
10269: PPUSH
10270: LD_INT 3
10272: PPUSH
10273: LD_INT 3
10275: PPUSH
10276: LD_INT 43
10278: PPUSH
10279: LD_INT 100
10281: PPUSH
10282: CALL 21275 0 5
// veh := CreateVehicle ;
10286: LD_ADDR_VAR 0 2
10290: PUSH
10291: CALL_OW 45
10295: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
10296: LD_VAR 0 2
10300: PPUSH
10301: LD_INT 130
10303: PPUSH
10304: LD_INT 131
10306: PPUSH
10307: LD_INT 0
10309: PPUSH
10310: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
10314: LD_VAR 0 2
10318: PPUSH
10319: LD_INT 100
10321: PPUSH
10322: LD_INT 82
10324: PPUSH
10325: CALL_OW 114
// end else
10329: GO 10345
// time := time + 0 0$1 ;
10331: LD_ADDR_VAR 0 1
10335: PUSH
10336: LD_VAR 0 1
10340: PUSH
10341: LD_INT 35
10343: PLUS
10344: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
10345: LD_EXP 49
10349: PPUSH
10350: CALL_OW 301
10354: PUSH
10355: LD_EXP 49
10359: PPUSH
10360: CALL_OW 255
10364: PUSH
10365: LD_INT 4
10367: EQUAL
10368: AND
10369: PUSH
10370: LD_INT 22
10372: PUSH
10373: LD_INT 7
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PPUSH
10380: CALL_OW 69
10384: PPUSH
10385: LD_EXP 49
10389: PPUSH
10390: CALL_OW 74
10394: PPUSH
10395: LD_EXP 49
10399: PPUSH
10400: CALL_OW 296
10404: PUSH
10405: LD_INT 10
10407: LESS
10408: OR
10409: IFFALSE 10198
// if IsDead ( Belkov ) then
10411: LD_EXP 49
10415: PPUSH
10416: CALL_OW 301
10420: IFFALSE 10445
// begin CenterNowOnUnits ( Belkov ) ;
10422: LD_EXP 49
10426: PPUSH
10427: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
10431: LD_EXP 16
10435: PPUSH
10436: LD_STRING D5a-JMM-2a
10438: PPUSH
10439: CALL_OW 88
// exit ;
10443: GO 10511
// end ; if See ( 7 , Belkov ) then
10445: LD_INT 7
10447: PPUSH
10448: LD_EXP 49
10452: PPUSH
10453: CALL_OW 292
10457: IFFALSE 10471
// SetSide ( Belkov , 7 ) ;
10459: LD_EXP 49
10463: PPUSH
10464: LD_INT 7
10466: PPUSH
10467: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
10471: LD_INT 35
10473: PPUSH
10474: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
10478: LD_EXP 49
10482: PPUSH
10483: LD_INT 66
10485: PPUSH
10486: LD_INT 45
10488: PPUSH
10489: CALL_OW 297
10493: PUSH
10494: LD_INT 30
10496: LESS
10497: IFFALSE 10471
// Say ( Belkov , D6-Bel-1 ) ;
10499: LD_EXP 49
10503: PPUSH
10504: LD_STRING D6-Bel-1
10506: PPUSH
10507: CALL_OW 88
// end ;
10511: PPOPN 3
10513: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
10514: LD_EXP 49
10518: PPUSH
10519: CALL_OW 302
10523: PUSH
10524: LD_EXP 49
10528: PPUSH
10529: CALL_OW 504
10533: PUSH
10534: LD_INT 2
10536: PUSH
10537: LD_INT 34
10539: PUSH
10540: LD_INT 47
10542: PUSH
10543: EMPTY
10544: LIST
10545: LIST
10546: PUSH
10547: LD_INT 34
10549: PUSH
10550: LD_INT 45
10552: PUSH
10553: EMPTY
10554: LIST
10555: LIST
10556: PUSH
10557: EMPTY
10558: LIST
10559: LIST
10560: LIST
10561: PPUSH
10562: CALL_OW 69
10566: IN
10567: AND
10568: IFFALSE 10585
10570: GO 10572
10572: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
10573: LD_EXP 49
10577: PPUSH
10578: LD_STRING D7-Bel-1
10580: PPUSH
10581: CALL_OW 88
10585: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
10586: LD_INT 22
10588: PUSH
10589: LD_INT 7
10591: PUSH
10592: EMPTY
10593: LIST
10594: LIST
10595: PUSH
10596: LD_INT 101
10598: PUSH
10599: LD_INT 2
10601: PUSH
10602: EMPTY
10603: LIST
10604: LIST
10605: PUSH
10606: EMPTY
10607: LIST
10608: LIST
10609: PPUSH
10610: CALL_OW 69
10614: PUSH
10615: LD_EXP 8
10619: NOT
10620: AND
10621: PUSH
10622: LD_EXP 48
10626: PPUSH
10627: CALL_OW 305
10631: NOT
10632: AND
10633: IFFALSE 11118
10635: GO 10637
10637: DISABLE
10638: LD_INT 0
10640: PPUSH
// begin ar_base_spotted := true ;
10641: LD_ADDR_EXP 8
10645: PUSH
10646: LD_INT 1
10648: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
10649: LD_ADDR_VAR 0 1
10653: PUSH
10654: LD_INT 22
10656: PUSH
10657: LD_INT 2
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: PUSH
10664: LD_INT 21
10666: PUSH
10667: LD_INT 3
10669: PUSH
10670: EMPTY
10671: LIST
10672: LIST
10673: PUSH
10674: EMPTY
10675: LIST
10676: LIST
10677: PPUSH
10678: CALL_OW 69
10682: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
10683: LD_ADDR_VAR 0 1
10687: PUSH
10688: LD_VAR 0 1
10692: PPUSH
10693: LD_EXP 16
10697: PPUSH
10698: CALL_OW 74
10702: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
10703: LD_INT 7
10705: PPUSH
10706: LD_INT 3
10708: PPUSH
10709: CALL_OW 332
// DialogueOn ;
10713: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
10717: LD_VAR 0 1
10721: PPUSH
10722: CALL_OW 250
10726: PPUSH
10727: LD_VAR 0 1
10731: PPUSH
10732: CALL_OW 251
10736: PPUSH
10737: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
10741: LD_ADDR_VAR 0 1
10745: PUSH
10746: LD_INT 22
10748: PUSH
10749: LD_INT 7
10751: PUSH
10752: EMPTY
10753: LIST
10754: LIST
10755: PUSH
10756: LD_INT 23
10758: PUSH
10759: LD_INT 1
10761: PUSH
10762: EMPTY
10763: LIST
10764: LIST
10765: PUSH
10766: LD_INT 26
10768: PUSH
10769: LD_INT 1
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: PUSH
10776: EMPTY
10777: LIST
10778: LIST
10779: LIST
10780: PPUSH
10781: CALL_OW 69
10785: PUSH
10786: LD_EXP 16
10790: PUSH
10791: LD_EXP 20
10795: PUSH
10796: LD_EXP 21
10800: PUSH
10801: LD_EXP 28
10805: PUSH
10806: LD_EXP 17
10810: PUSH
10811: LD_EXP 26
10815: PUSH
10816: LD_EXP 22
10820: PUSH
10821: LD_EXP 24
10825: PUSH
10826: EMPTY
10827: LIST
10828: LIST
10829: LIST
10830: LIST
10831: LIST
10832: LIST
10833: LIST
10834: LIST
10835: DIFF
10836: ST_TO_ADDR
// if not tmp then
10837: LD_VAR 0 1
10841: NOT
10842: IFFALSE 10916
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
10844: LD_ADDR_VAR 0 1
10848: PUSH
10849: LD_INT 22
10851: PUSH
10852: LD_INT 7
10854: PUSH
10855: EMPTY
10856: LIST
10857: LIST
10858: PUSH
10859: LD_INT 23
10861: PUSH
10862: LD_INT 1
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: PUSH
10869: LD_INT 26
10871: PUSH
10872: LD_INT 2
10874: PUSH
10875: EMPTY
10876: LIST
10877: LIST
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: LIST
10883: PPUSH
10884: CALL_OW 69
10888: PUSH
10889: LD_EXP 31
10893: PUSH
10894: LD_EXP 18
10898: PUSH
10899: LD_EXP 29
10903: PUSH
10904: LD_EXP 30
10908: PUSH
10909: EMPTY
10910: LIST
10911: LIST
10912: LIST
10913: LIST
10914: DIFF
10915: ST_TO_ADDR
// if tmp then
10916: LD_VAR 0 1
10920: IFFALSE 10991
// case GetSex ( tmp [ 1 ] ) of sex_male :
10922: LD_VAR 0 1
10926: PUSH
10927: LD_INT 1
10929: ARRAY
10930: PPUSH
10931: CALL_OW 258
10935: PUSH
10936: LD_INT 1
10938: DOUBLE
10939: EQUAL
10940: IFTRUE 10944
10942: GO 10963
10944: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
10945: LD_VAR 0 1
10949: PUSH
10950: LD_INT 1
10952: ARRAY
10953: PPUSH
10954: LD_STRING D9-Sol1-1
10956: PPUSH
10957: CALL_OW 88
10961: GO 10991
10963: LD_INT 2
10965: DOUBLE
10966: EQUAL
10967: IFTRUE 10971
10969: GO 10990
10971: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
10972: LD_VAR 0 1
10976: PUSH
10977: LD_INT 1
10979: ARRAY
10980: PPUSH
10981: LD_STRING D9-FSol1-1
10983: PPUSH
10984: CALL_OW 88
10988: GO 10991
10990: POP
// if Frank then
10991: LD_EXP 28
10995: IFFALSE 11099
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
10997: LD_EXP 58
11001: PPUSH
11002: CALL_OW 250
11006: PPUSH
11007: LD_EXP 58
11011: PPUSH
11012: CALL_OW 251
11016: PPUSH
11017: LD_INT 7
11019: PPUSH
11020: LD_INT 8
11022: PPUSH
11023: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
11027: LD_EXP 58
11031: PPUSH
11032: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
11036: LD_EXP 28
11040: PPUSH
11041: LD_STRING D9-Frank-1
11043: PPUSH
11044: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
11048: LD_EXP 16
11052: PPUSH
11053: LD_STRING D9-JMM-1
11055: PPUSH
11056: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
11060: LD_EXP 28
11064: PPUSH
11065: LD_STRING D9-Frank-2
11067: PPUSH
11068: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
11072: LD_EXP 58
11076: PPUSH
11077: CALL_OW 250
11081: PPUSH
11082: LD_EXP 58
11086: PPUSH
11087: CALL_OW 251
11091: PPUSH
11092: LD_INT 7
11094: PPUSH
11095: CALL_OW 331
// end ; DialogueOff ;
11099: CALL_OW 7
// wait ( 1 1$00 ) ;
11103: LD_INT 2100
11105: PPUSH
11106: CALL_OW 67
// ar_active_attack := true ;
11110: LD_ADDR_EXP 9
11114: PUSH
11115: LD_INT 1
11117: ST_TO_ADDR
// end ;
11118: PPOPN 1
11120: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
11121: LD_EXP 7
11125: PUSH
11126: LD_OWVAR 1
11130: PUSH
11131: LD_INT 42000
11133: GREATEREQUAL
11134: OR
11135: IFFALSE 12187
11137: GO 11139
11139: DISABLE
11140: LD_INT 0
11142: PPUSH
11143: PPUSH
// begin selected_option := 1 ;
11144: LD_ADDR_VAR 0 2
11148: PUSH
11149: LD_INT 1
11151: ST_TO_ADDR
// wait ( 5 5$00 ) ;
11152: LD_INT 10500
11154: PPUSH
11155: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// until not ru_attackers ;
11166: LD_EXP 54
11170: NOT
11171: IFFALSE 11159
// PrepareBurlak ;
11173: CALL 2360 0 0
// repeat wait ( 0 0$2 ) ;
11177: LD_INT 70
11179: PPUSH
11180: CALL_OW 67
// until not HasTask ( Burlak ) ;
11184: LD_EXP 48
11188: PPUSH
11189: CALL_OW 314
11193: NOT
11194: IFFALSE 11177
// InGameOn ;
11196: CALL_OW 8
// DialogueOn ;
11200: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
11204: LD_EXP 51
11208: PPUSH
11209: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
11213: LD_EXP 48
11217: PPUSH
11218: LD_STRING D10-Bur-1
11220: PPUSH
11221: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
11225: LD_EXP 49
11229: PUSH
11230: LD_EXP 49
11234: PPUSH
11235: CALL_OW 255
11239: PUSH
11240: LD_INT 7
11242: EQUAL
11243: AND
11244: IFFALSE 11258
// Say ( Belkov , D10-Bel-1 ) ;
11246: LD_EXP 49
11250: PPUSH
11251: LD_STRING D10-Bel-1
11253: PPUSH
11254: CALL_OW 88
// if Gossudarov then
11258: LD_EXP 34
11262: IFFALSE 11276
// Say ( Gossudarov , D10-Gos-1 ) ;
11264: LD_EXP 34
11268: PPUSH
11269: LD_STRING D10-Gos-1
11271: PPUSH
11272: CALL_OW 88
// if Kirilenkova then
11276: LD_EXP 35
11280: IFFALSE 11294
// Say ( Kirilenkova , D10-Kir-1 ) ;
11282: LD_EXP 35
11286: PPUSH
11287: LD_STRING D10-Kir-1
11289: PPUSH
11290: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
11294: CALL 14936 0 0
11298: PPUSH
11299: LD_STRING D10-RSol1-1
11301: PPUSH
11302: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
11306: LD_EXP 48
11310: PPUSH
11311: LD_STRING D10-Bur-2
11313: PPUSH
11314: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
11318: LD_EXP 16
11322: PPUSH
11323: LD_STRING D10-JMM-2
11325: PPUSH
11326: CALL_OW 88
// if Kirilenkova then
11330: LD_EXP 35
11334: IFFALSE 11350
// Say ( Kirilenkova , D10-Kir-2 ) else
11336: LD_EXP 35
11340: PPUSH
11341: LD_STRING D10-Kir-2
11343: PPUSH
11344: CALL_OW 88
11348: GO 11362
// Say ( SolRu , D10-RSol1-2 ) ;
11350: CALL 14936 0 0
11354: PPUSH
11355: LD_STRING D10-RSol1-2
11357: PPUSH
11358: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
11362: LD_EXP 16
11366: PPUSH
11367: LD_STRING D10-JMM-3
11369: PPUSH
11370: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
11374: LD_EXP 48
11378: PPUSH
11379: LD_STRING D10-Bur-3
11381: PPUSH
11382: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
11386: LD_EXP 16
11390: PPUSH
11391: LD_STRING D10-JMM-4
11393: PPUSH
11394: CALL_OW 88
// DialogueOff ;
11398: CALL_OW 7
// InGameOff ;
11402: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
11406: LD_STRING M2
11408: PPUSH
11409: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
11413: LD_INT 35
11415: PPUSH
11416: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
11420: LD_INT 22
11422: PUSH
11423: LD_INT 7
11425: PUSH
11426: EMPTY
11427: LIST
11428: LIST
11429: PUSH
11430: LD_INT 91
11432: PUSH
11433: LD_EXP 48
11437: PUSH
11438: LD_INT 8
11440: PUSH
11441: EMPTY
11442: LIST
11443: LIST
11444: LIST
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: PPUSH
11450: CALL_OW 69
11454: IFFALSE 11413
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
11456: LD_ADDR_VAR 0 1
11460: PUSH
11461: LD_INT 22
11463: PUSH
11464: LD_INT 4
11466: PUSH
11467: EMPTY
11468: LIST
11469: LIST
11470: PPUSH
11471: CALL_OW 69
11475: PUSH
11476: FOR_IN
11477: IFFALSE 11493
// SetSide ( i , 7 ) ;
11479: LD_VAR 0 1
11483: PPUSH
11484: LD_INT 7
11486: PPUSH
11487: CALL_OW 235
11491: GO 11476
11493: POP
11494: POP
// ChangeMissionObjectives ( M3 ) ;
11495: LD_STRING M3
11497: PPUSH
11498: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
11502: LD_INT 35
11504: PPUSH
11505: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
11509: LD_EXP 16
11513: PPUSH
11514: LD_EXP 48
11518: PPUSH
11519: CALL_OW 296
11523: PUSH
11524: LD_INT 8
11526: LESS
11527: IFFALSE 11502
// ComTurnUnit ( JMM , Burlak ) ;
11529: LD_EXP 16
11533: PPUSH
11534: LD_EXP 48
11538: PPUSH
11539: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
11543: LD_EXP 48
11547: PPUSH
11548: LD_EXP 16
11552: PPUSH
11553: CALL_OW 119
// wait ( 0 0$0.3 ) ;
11557: LD_INT 10
11559: PPUSH
11560: CALL_OW 67
// DialogueOn ;
11564: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
11568: LD_EXP 16
11572: PPUSH
11573: LD_STRING D11-JMM-1
11575: PPUSH
11576: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
11580: LD_EXP 48
11584: PPUSH
11585: LD_STRING D11-Bur-1
11587: PPUSH
11588: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
11592: LD_EXP 16
11596: PPUSH
11597: LD_STRING D11-JMM-2
11599: PPUSH
11600: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
11604: LD_EXP 48
11608: PPUSH
11609: LD_STRING D11-Bur-2
11611: PPUSH
11612: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
11616: LD_EXP 16
11620: PPUSH
11621: LD_STRING D11-JMM-3
11623: PPUSH
11624: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
11628: LD_EXP 48
11632: PPUSH
11633: LD_STRING D11-Bur-3
11635: PPUSH
11636: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
11640: LD_EXP 16
11644: PPUSH
11645: LD_STRING D11-JMM-4
11647: PPUSH
11648: CALL_OW 88
// if ar_base_spotted then
11652: LD_EXP 8
11656: IFFALSE 11672
// Say ( Burlak , D12-Bur-1 ) else
11658: LD_EXP 48
11662: PPUSH
11663: LD_STRING D12-Bur-1
11665: PPUSH
11666: CALL_OW 88
11670: GO 11711
// begin RevealFogArea ( 7 , area_base_arabian ) ;
11672: LD_INT 7
11674: PPUSH
11675: LD_INT 3
11677: PPUSH
11678: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
11682: LD_INT 127
11684: PPUSH
11685: LD_INT 45
11687: PPUSH
11688: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
11692: LD_EXP 48
11696: PPUSH
11697: LD_STRING D12-Bur-1a
11699: PPUSH
11700: CALL_OW 88
// dwait ( 0 0$2 ) ;
11704: LD_INT 70
11706: PPUSH
11707: CALL_OW 68
// end ; if not IsOk ( Abdul ) then
11711: LD_EXP 57
11715: PPUSH
11716: CALL_OW 302
11720: NOT
11721: IFFALSE 11729
// begin DialogueOff ;
11723: CALL_OW 7
// exit ;
11727: GO 12187
// end ; Say ( Burlak , D12-Bur-1b ) ;
11729: LD_EXP 48
11733: PPUSH
11734: LD_STRING D12-Bur-1b
11736: PPUSH
11737: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
11741: LD_EXP 16
11745: PPUSH
11746: LD_STRING D12-JMM-1
11748: PPUSH
11749: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
11753: LD_EXP 48
11757: PPUSH
11758: LD_STRING D12-Bur-2
11760: PPUSH
11761: CALL_OW 88
// if Roth then
11765: LD_EXP 17
11769: IFFALSE 11785
// Say ( Roth , D12-Roth-2 ) else
11771: LD_EXP 17
11775: PPUSH
11776: LD_STRING D12-Roth-2
11778: PPUSH
11779: CALL_OW 88
11783: GO 11797
// Say ( SciRu , D12-RSci1-2 ) ;
11785: CALL 14789 0 0
11789: PPUSH
11790: LD_STRING D12-RSci1-2
11792: PPUSH
11793: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
11797: LD_EXP 16
11801: PPUSH
11802: LD_STRING D12-JMM-2
11804: PPUSH
11805: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
11809: LD_EXP 48
11813: PPUSH
11814: LD_STRING D12-Bur-3
11816: PPUSH
11817: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
11821: LD_EXP 16
11825: PPUSH
11826: LD_STRING D12-JMM-3
11828: PPUSH
11829: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
11833: LD_EXP 48
11837: PPUSH
11838: LD_STRING D12-Bur-4
11840: PPUSH
11841: CALL_OW 88
// case Query ( QBase ) of 1 :
11845: LD_STRING QBase
11847: PPUSH
11848: CALL_OW 97
11852: PUSH
11853: LD_INT 1
11855: DOUBLE
11856: EQUAL
11857: IFTRUE 11861
11859: GO 11979
11861: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
11862: LD_EXP 16
11866: PPUSH
11867: LD_STRING D13a-JMM-1
11869: PPUSH
11870: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
11874: LD_EXP 48
11878: PPUSH
11879: LD_STRING D13a-Bur-1
11881: PPUSH
11882: CALL_OW 88
// if Roth then
11886: LD_EXP 17
11890: IFFALSE 11906
// Say ( Roth , D13a-Roth-1 ) else
11892: LD_EXP 17
11896: PPUSH
11897: LD_STRING D13a-Roth-1
11899: PPUSH
11900: CALL_OW 88
11904: GO 11918
// Say ( SciRu , D13a-RSci1-1 ) ;
11906: CALL 14789 0 0
11910: PPUSH
11911: LD_STRING D13a-RSci1-1
11913: PPUSH
11914: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
11918: LD_EXP 16
11922: PPUSH
11923: LD_STRING D13a-JMM-2
11925: PPUSH
11926: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
11930: LD_STRING QBaseAgain
11932: PPUSH
11933: CALL_OW 97
11937: PUSH
11938: LD_INT 1
11940: DOUBLE
11941: EQUAL
11942: IFTRUE 11946
11944: GO 11957
11946: POP
// selected_option := 2 ; 2 :
11947: LD_ADDR_VAR 0 2
11951: PUSH
11952: LD_INT 2
11954: ST_TO_ADDR
11955: GO 11977
11957: LD_INT 2
11959: DOUBLE
11960: EQUAL
11961: IFTRUE 11965
11963: GO 11976
11965: POP
// selected_option := 3 ; end ;
11966: LD_ADDR_VAR 0 2
11970: PUSH
11971: LD_INT 3
11973: ST_TO_ADDR
11974: GO 11977
11976: POP
// end ; 2 :
11977: GO 12018
11979: LD_INT 2
11981: DOUBLE
11982: EQUAL
11983: IFTRUE 11987
11985: GO 11998
11987: POP
// selected_option := 2 ; 3 :
11988: LD_ADDR_VAR 0 2
11992: PUSH
11993: LD_INT 2
11995: ST_TO_ADDR
11996: GO 12018
11998: LD_INT 3
12000: DOUBLE
12001: EQUAL
12002: IFTRUE 12006
12004: GO 12017
12006: POP
// selected_option := 3 ; end ;
12007: LD_ADDR_VAR 0 2
12011: PUSH
12012: LD_INT 3
12014: ST_TO_ADDR
12015: GO 12018
12017: POP
// if selected_option = 2 then
12018: LD_VAR 0 2
12022: PUSH
12023: LD_INT 2
12025: EQUAL
12026: IFFALSE 12120
// begin Say ( JMM , D13b-JMM-1 ) ;
12028: LD_EXP 16
12032: PPUSH
12033: LD_STRING D13b-JMM-1
12035: PPUSH
12036: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
12040: LD_EXP 48
12044: PPUSH
12045: LD_STRING D13b-Bur-1
12047: PPUSH
12048: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
12052: LD_EXP 16
12056: PPUSH
12057: LD_STRING D13b-JMM-2
12059: PPUSH
12060: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
12064: LD_EXP 57
12068: PPUSH
12069: LD_STRING D13b-Abd-2
12071: PPUSH
12072: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
12076: LD_EXP 16
12080: PPUSH
12081: LD_STRING D13b-JMM-3
12083: PPUSH
12084: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
12088: LD_EXP 57
12092: PPUSH
12093: LD_STRING D13b-Abd-3
12095: PPUSH
12096: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
12100: LD_EXP 16
12104: PPUSH
12105: LD_STRING D13b-JMM-4
12107: PPUSH
12108: CALL_OW 88
// ar_active_attack := true ;
12112: LD_ADDR_EXP 9
12116: PUSH
12117: LD_INT 1
12119: ST_TO_ADDR
// end ; if selected_option = 3 then
12120: LD_VAR 0 2
12124: PUSH
12125: LD_INT 3
12127: EQUAL
12128: IFFALSE 12154
// begin Say ( JMM , D13c-JMM-1 ) ;
12130: LD_EXP 16
12134: PPUSH
12135: LD_STRING D13c-JMM-1
12137: PPUSH
12138: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
12142: LD_EXP 48
12146: PPUSH
12147: LD_STRING D13c-Bur-1
12149: PPUSH
12150: CALL_OW 88
// end ; DialogueOff ;
12154: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
12158: LD_STRING M4
12160: PPUSH
12161: CALL_OW 337
// if not ar_active_attack then
12165: LD_EXP 9
12169: NOT
12170: IFFALSE 12187
// begin wait ( 6 6$00 ) ;
12172: LD_INT 12600
12174: PPUSH
12175: CALL_OW 67
// ar_active_attack := true ;
12179: LD_ADDR_EXP 9
12183: PUSH
12184: LD_INT 1
12186: ST_TO_ADDR
// end ; end ;
12187: PPOPN 2
12189: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
12190: LD_EXP 48
12194: PPUSH
12195: CALL_OW 305
12199: PUSH
12200: LD_EXP 48
12204: PPUSH
12205: CALL_OW 255
12209: PUSH
12210: LD_INT 7
12212: EQUAL
12213: AND
12214: IFFALSE 12437
12216: GO 12218
12218: DISABLE
12219: LD_INT 0
12221: PPUSH
// begin wait ( 4 4$40 ) ;
12222: LD_INT 9800
12224: PPUSH
12225: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
12229: LD_INT 35
12231: PPUSH
12232: CALL_OW 67
// until not ru_attackers and not FilterAllUnits ( [ [ f_side , 6 ] , [ f_ok ] ] ) ;
12236: LD_EXP 54
12240: NOT
12241: PUSH
12242: LD_INT 22
12244: PUSH
12245: LD_INT 6
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: PUSH
12252: LD_INT 50
12254: PUSH
12255: EMPTY
12256: LIST
12257: PUSH
12258: EMPTY
12259: LIST
12260: LIST
12261: PPUSH
12262: CALL_OW 69
12266: NOT
12267: AND
12268: IFFALSE 12229
// PrepareGnyevko ;
12270: CALL 2304 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
12274: LD_EXP 50
12278: PPUSH
12279: LD_INT 124
12281: PPUSH
12282: LD_INT 118
12284: PPUSH
12285: CALL_OW 111
// AddComHold ( Gnyevko ) ;
12289: LD_EXP 50
12293: PPUSH
12294: CALL_OW 200
// time := 0 0$00 ;
12298: LD_ADDR_VAR 0 1
12302: PUSH
12303: LD_INT 0
12305: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
12306: LD_INT 35
12308: PPUSH
12309: CALL_OW 67
// time := time + 0 0$1 ;
12313: LD_ADDR_VAR 0 1
12317: PUSH
12318: LD_VAR 0 1
12322: PUSH
12323: LD_INT 35
12325: PLUS
12326: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
12327: LD_EXP 50
12331: PPUSH
12332: LD_INT 124
12334: PPUSH
12335: LD_INT 118
12337: PPUSH
12338: CALL_OW 307
12342: PUSH
12343: LD_VAR 0 1
12347: PUSH
12348: LD_INT 1050
12350: GREATEREQUAL
12351: OR
12352: IFFALSE 12306
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
12354: LD_EXP 50
12358: PPUSH
12359: LD_STRING DBelkov-Gny-1
12361: PPUSH
12362: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
12366: LD_EXP 48
12370: PPUSH
12371: LD_STRING DBelkov-Bur-1a
12373: PPUSH
12374: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
12378: LD_INT 35
12380: PPUSH
12381: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
12385: LD_EXP 50
12389: PPUSH
12390: LD_INT 22
12392: PUSH
12393: LD_INT 7
12395: PUSH
12396: EMPTY
12397: LIST
12398: LIST
12399: PPUSH
12400: CALL_OW 69
12404: PPUSH
12405: LD_EXP 50
12409: PPUSH
12410: CALL_OW 74
12414: PPUSH
12415: CALL_OW 296
12419: PUSH
12420: LD_INT 8
12422: LESS
12423: IFFALSE 12378
// SetSide ( Gnyevko , 7 ) ;
12425: LD_EXP 50
12429: PPUSH
12430: LD_INT 7
12432: PPUSH
12433: CALL_OW 235
// end ;
12437: PPOPN 1
12439: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
12440: LD_EXP 48
12444: PPUSH
12445: CALL_OW 255
12449: PUSH
12450: LD_INT 7
12452: EQUAL
12453: IFFALSE 12463
12455: GO 12457
12457: DISABLE
// begin enable ;
12458: ENABLE
// PrepareAmericanAttack ;
12459: CALL 7812 0 0
// end ;
12463: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
12464: LD_INT 22
12466: PUSH
12467: LD_INT 1
12469: PUSH
12470: EMPTY
12471: LIST
12472: LIST
12473: PPUSH
12474: CALL_OW 69
12478: IFFALSE 12662
12480: GO 12482
12482: DISABLE
12483: LD_INT 0
12485: PPUSH
12486: PPUSH
// begin while true do
12487: LD_INT 1
12489: IFFALSE 12546
// begin wait ( 0 0$1 ) ;
12491: LD_INT 35
12493: PPUSH
12494: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
12498: LD_ADDR_VAR 0 2
12502: PUSH
12503: LD_INT 22
12505: PUSH
12506: LD_INT 1
12508: PUSH
12509: EMPTY
12510: LIST
12511: LIST
12512: PPUSH
12513: CALL_OW 69
12517: PPUSH
12518: LD_EXP 16
12522: PPUSH
12523: CALL_OW 74
12527: ST_TO_ADDR
// if See ( 7 , tmp ) then
12528: LD_INT 7
12530: PPUSH
12531: LD_VAR 0 2
12535: PPUSH
12536: CALL_OW 292
12540: IFFALSE 12544
// break ;
12542: GO 12546
// end ;
12544: GO 12487
// DialogueOn ;
12546: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
12550: LD_VAR 0 2
12554: PPUSH
12555: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
12559: LD_VAR 0 2
12563: PPUSH
12564: CALL_OW 250
12568: PPUSH
12569: LD_VAR 0 2
12573: PPUSH
12574: CALL_OW 251
12578: PPUSH
12579: LD_INT 7
12581: PPUSH
12582: LD_INT 8
12584: PPUSH
12585: CALL_OW 330
// if Denis then
12589: LD_EXP 22
12593: IFFALSE 12607
// Say ( Denis , DAmerAttack-Pet-1 ) ;
12595: LD_EXP 22
12599: PPUSH
12600: LD_STRING DAmerAttack-Pet-1
12602: PPUSH
12603: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
12607: LD_EXP 16
12611: PPUSH
12612: LD_STRING DAmerAttack-JMM-1
12614: PPUSH
12615: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
12619: LD_EXP 48
12623: PPUSH
12624: LD_STRING DStop-Bur-1
12626: PPUSH
12627: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
12631: LD_VAR 0 2
12635: PPUSH
12636: CALL_OW 250
12640: PPUSH
12641: LD_VAR 0 2
12645: PPUSH
12646: CALL_OW 251
12650: PPUSH
12651: LD_INT 7
12653: PPUSH
12654: CALL_OW 331
// DialogueOff ;
12658: CALL_OW 7
// end ;
12662: PPOPN 2
12664: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
12665: LD_INT 22
12667: PUSH
12668: LD_INT 3
12670: PUSH
12671: EMPTY
12672: LIST
12673: LIST
12674: PUSH
12675: LD_INT 21
12677: PUSH
12678: LD_INT 1
12680: PUSH
12681: EMPTY
12682: LIST
12683: LIST
12684: PUSH
12685: EMPTY
12686: LIST
12687: LIST
12688: PPUSH
12689: CALL_OW 69
12693: PUSH
12694: LD_INT 0
12696: EQUAL
12697: IFFALSE 12739
12699: GO 12701
12701: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
12702: LD_STRING M5a
12704: PPUSH
12705: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
12709: LD_EXP 16
12713: PPUSH
12714: LD_STRING D8-JMM-1
12716: PPUSH
12717: CALL_OW 88
// if Gossudarov then
12721: LD_EXP 34
12725: IFFALSE 12739
// Say ( Gossudarov , D8-Gos-1 ) ;
12727: LD_EXP 34
12731: PPUSH
12732: LD_STRING D8-Gos-1
12734: PPUSH
12735: CALL_OW 88
// end ;
12739: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
12740: LD_INT 22
12742: PUSH
12743: LD_INT 2
12745: PUSH
12746: EMPTY
12747: LIST
12748: LIST
12749: PUSH
12750: LD_INT 21
12752: PUSH
12753: LD_INT 1
12755: PUSH
12756: EMPTY
12757: LIST
12758: LIST
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PPUSH
12764: CALL_OW 69
12768: PUSH
12769: LD_INT 0
12771: EQUAL
12772: IFFALSE 12822
12774: GO 12776
12776: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
12777: LD_STRING M4c
12779: PPUSH
12780: CALL_OW 337
// if Roth then
12784: LD_EXP 17
12788: IFFALSE 12804
// Say ( Roth , DStop-Roth-1 ) else
12790: LD_EXP 17
12794: PPUSH
12795: LD_STRING DStop-Roth-1
12797: PPUSH
12798: CALL_OW 88
12802: GO 12822
// if Gossudarov then
12804: LD_EXP 34
12808: IFFALSE 12822
// Say ( Gossudarov , D8-Gos-1a ) ;
12810: LD_EXP 34
12814: PPUSH
12815: LD_STRING D8-Gos-1a
12817: PPUSH
12818: CALL_OW 88
// end ;
12822: END
// every 1 1$00 trigger FindArtifact ( 3 ) and first_powell_attack do
12823: LD_INT 3
12825: PPUSH
12826: CALL_OW 469
12830: PUSH
12831: LD_EXP 12
12835: AND
12836: IFFALSE 12891
12838: GO 12840
12840: DISABLE
// begin TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
12841: LD_INT 3
12843: PPUSH
12844: CALL_OW 469
12848: PPUSH
12849: CALL 8301 0 1
// if Difficulty > 2 then
12853: LD_OWVAR 67
12857: PUSH
12858: LD_INT 2
12860: GREATER
12861: IFFALSE 12891
// begin wait ( 5 5$00 ) ;
12863: LD_INT 10500
12865: PPUSH
12866: CALL_OW 67
// if FindArtifact ( 3 ) then
12870: LD_INT 3
12872: PPUSH
12873: CALL_OW 469
12877: IFFALSE 12891
// TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
12879: LD_INT 3
12881: PPUSH
12882: CALL_OW 469
12886: PPUSH
12887: CALL 8301 0 1
// end ; end ;
12891: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
12892: LD_INT 7
12894: PPUSH
12895: LD_INT 1
12897: PPUSH
12898: LD_INT 1
12900: PPUSH
12901: CALL 16498 0 3
12905: PUSH
12906: LD_INT 0
12908: EQUAL
12909: PUSH
12910: LD_INT 7
12912: PPUSH
12913: LD_INT 3
12915: PPUSH
12916: LD_INT 1
12918: PPUSH
12919: CALL 16498 0 3
12923: PUSH
12924: LD_INT 0
12926: EQUAL
12927: AND
12928: IFFALSE 12940
12930: GO 12932
12932: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
12933: LD_STRING M1a
12935: PPUSH
12936: CALL_OW 337
// end ;
12940: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , nation_arabian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
12941: LD_INT 22
12943: PUSH
12944: LD_INT 2
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: PUSH
12951: LD_INT 23
12953: PUSH
12954: LD_INT 2
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: PUSH
12961: LD_INT 21
12963: PUSH
12964: LD_INT 1
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: LIST
12975: PPUSH
12976: CALL_OW 69
12980: PUSH
12981: LD_INT 0
12983: EQUAL
12984: PUSH
12985: LD_INT 22
12987: PUSH
12988: LD_INT 3
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: PUSH
12995: LD_INT 23
12997: PUSH
12998: LD_INT 3
13000: PUSH
13001: EMPTY
13002: LIST
13003: LIST
13004: PUSH
13005: LD_INT 21
13007: PUSH
13008: LD_INT 1
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PUSH
13015: EMPTY
13016: LIST
13017: LIST
13018: LIST
13019: PPUSH
13020: CALL_OW 69
13024: PUSH
13025: LD_INT 0
13027: EQUAL
13028: AND
13029: PUSH
13030: LD_INT 22
13032: PUSH
13033: LD_INT 1
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PPUSH
13040: CALL_OW 69
13044: PUSH
13045: LD_INT 0
13047: EQUAL
13048: AND
13049: PUSH
13050: LD_INT 7
13052: PPUSH
13053: LD_INT 1
13055: PPUSH
13056: LD_INT 1
13058: PPUSH
13059: CALL 16498 0 3
13063: PUSH
13064: LD_INT 0
13066: EQUAL
13067: AND
13068: PUSH
13069: LD_INT 7
13071: PPUSH
13072: LD_INT 3
13074: PPUSH
13075: LD_INT 1
13077: PPUSH
13078: CALL 16498 0 3
13082: PUSH
13083: LD_INT 0
13085: EQUAL
13086: AND
13087: PUSH
13088: LD_EXP 48
13092: PPUSH
13093: CALL_OW 255
13097: PUSH
13098: LD_INT 7
13100: EQUAL
13101: AND
13102: PUSH
13103: LD_EXP 48
13107: PPUSH
13108: CALL_OW 302
13112: AND
13113: IFFALSE 14786
13115: GO 13117
13117: DISABLE
13118: LD_INT 0
13120: PPUSH
13121: PPUSH
13122: PPUSH
13123: PPUSH
13124: PPUSH
13125: PPUSH
// begin m1 := false ;
13126: LD_ADDR_VAR 0 4
13130: PUSH
13131: LD_INT 0
13133: ST_TO_ADDR
// m2 := false ;
13134: LD_ADDR_VAR 0 5
13138: PUSH
13139: LD_INT 0
13141: ST_TO_ADDR
// m3 := false ;
13142: LD_ADDR_VAR 0 6
13146: PUSH
13147: LD_INT 0
13149: ST_TO_ADDR
// if tick < 40 40$00 then
13150: LD_OWVAR 1
13154: PUSH
13155: LD_INT 84000
13157: LESS
13158: IFFALSE 13167
// SetAchievement ( ACH_ASPEED_17 ) ;
13160: LD_STRING ACH_ASPEED_17
13162: PPUSH
13163: CALL_OW 543
// wait ( 0 0$5 ) ;
13167: LD_INT 175
13169: PPUSH
13170: CALL_OW 67
// if not masha_killed then
13174: LD_EXP 10
13178: NOT
13179: IFFALSE 13201
// begin m1 := true ;
13181: LD_ADDR_VAR 0 4
13185: PUSH
13186: LD_INT 1
13188: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
13189: LD_STRING Masha
13191: PPUSH
13192: LD_INT 1
13194: PPUSH
13195: CALL_OW 101
// end else
13199: GO 13212
// AddMedal ( Masha , - 1 ) ;
13201: LD_STRING Masha
13203: PPUSH
13204: LD_INT 1
13206: NEG
13207: PPUSH
13208: CALL_OW 101
// if abdul_escaped then
13212: LD_EXP 13
13216: IFFALSE 13231
// AddMedal ( Abdul , - 1 ) else
13218: LD_STRING Abdul
13220: PPUSH
13221: LD_INT 1
13223: NEG
13224: PPUSH
13225: CALL_OW 101
13229: GO 13249
// begin m2 := true ;
13231: LD_ADDR_VAR 0 5
13235: PUSH
13236: LD_INT 1
13238: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
13239: LD_STRING Abdul
13241: PPUSH
13242: LD_INT 1
13244: PPUSH
13245: CALL_OW 101
// end ; if loss_counter = 0 then
13249: LD_EXP 14
13253: PUSH
13254: LD_INT 0
13256: EQUAL
13257: IFFALSE 13279
// begin m3 := true ;
13259: LD_ADDR_VAR 0 6
13263: PUSH
13264: LD_INT 1
13266: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
13267: LD_STRING People
13269: PPUSH
13270: LD_INT 2
13272: PPUSH
13273: CALL_OW 101
// end else
13277: GO 13341
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
13279: LD_EXP 14
13283: PUSH
13284: LD_INT 3
13286: PUSH
13287: LD_INT 2
13289: PUSH
13290: LD_INT 2
13292: PUSH
13293: LD_INT 1
13295: PUSH
13296: EMPTY
13297: LIST
13298: LIST
13299: LIST
13300: LIST
13301: PUSH
13302: LD_OWVAR 67
13306: ARRAY
13307: LESSEQUAL
13308: IFFALSE 13330
// begin AddMedal ( People , 1 ) ;
13310: LD_STRING People
13312: PPUSH
13313: LD_INT 1
13315: PPUSH
13316: CALL_OW 101
// m3 := true ;
13320: LD_ADDR_VAR 0 6
13324: PUSH
13325: LD_INT 1
13327: ST_TO_ADDR
// end else
13328: GO 13341
// AddMedal ( People , - 1 ) ;
13330: LD_STRING People
13332: PPUSH
13333: LD_INT 1
13335: NEG
13336: PPUSH
13337: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
13341: LD_OWVAR 67
13345: PUSH
13346: LD_INT 3
13348: GREATEREQUAL
13349: PUSH
13350: LD_VAR 0 4
13354: AND
13355: PUSH
13356: LD_VAR 0 5
13360: AND
13361: PUSH
13362: LD_VAR 0 6
13366: AND
13367: IFFALSE 13379
// SetAchievementEX ( ACH_AMER , 17 ) ;
13369: LD_STRING ACH_AMER
13371: PPUSH
13372: LD_INT 17
13374: PPUSH
13375: CALL_OW 564
// GiveMedals ( MAIN ) ;
13379: LD_STRING MAIN
13381: PPUSH
13382: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
13386: LD_ADDR_VAR 0 2
13390: PUSH
13391: LD_INT 22
13393: PUSH
13394: LD_INT 7
13396: PUSH
13397: EMPTY
13398: LIST
13399: LIST
13400: PUSH
13401: LD_INT 50
13403: PUSH
13404: EMPTY
13405: LIST
13406: PUSH
13407: LD_INT 2
13409: PUSH
13410: LD_INT 25
13412: PUSH
13413: LD_INT 1
13415: PUSH
13416: EMPTY
13417: LIST
13418: LIST
13419: PUSH
13420: LD_INT 25
13422: PUSH
13423: LD_INT 2
13425: PUSH
13426: EMPTY
13427: LIST
13428: LIST
13429: PUSH
13430: LD_INT 25
13432: PUSH
13433: LD_INT 3
13435: PUSH
13436: EMPTY
13437: LIST
13438: LIST
13439: PUSH
13440: LD_INT 25
13442: PUSH
13443: LD_INT 4
13445: PUSH
13446: EMPTY
13447: LIST
13448: LIST
13449: PUSH
13450: LD_INT 25
13452: PUSH
13453: LD_INT 5
13455: PUSH
13456: EMPTY
13457: LIST
13458: LIST
13459: PUSH
13460: LD_INT 25
13462: PUSH
13463: LD_INT 8
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: PUSH
13470: LD_INT 25
13472: PUSH
13473: LD_INT 9
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: PUSH
13480: EMPTY
13481: LIST
13482: LIST
13483: LIST
13484: LIST
13485: LIST
13486: LIST
13487: LIST
13488: LIST
13489: PUSH
13490: EMPTY
13491: LIST
13492: LIST
13493: LIST
13494: PPUSH
13495: CALL_OW 69
13499: ST_TO_ADDR
// RewardPeople ( tmp ) ;
13500: LD_VAR 0 2
13504: PPUSH
13505: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
13509: LD_ADDR_VAR 0 3
13513: PUSH
13514: LD_EXP 16
13518: PUSH
13519: LD_EXP 17
13523: PUSH
13524: LD_EXP 18
13528: PUSH
13529: LD_EXP 19
13533: PUSH
13534: LD_EXP 20
13538: PUSH
13539: LD_EXP 21
13543: PUSH
13544: LD_EXP 22
13548: PUSH
13549: LD_EXP 23
13553: PUSH
13554: LD_EXP 24
13558: PUSH
13559: LD_EXP 25
13563: PUSH
13564: LD_EXP 26
13568: PUSH
13569: LD_EXP 27
13573: PUSH
13574: LD_EXP 28
13578: PUSH
13579: LD_EXP 29
13583: PUSH
13584: LD_EXP 30
13588: PUSH
13589: LD_EXP 31
13593: PUSH
13594: LD_EXP 32
13598: PUSH
13599: LD_EXP 34
13603: PUSH
13604: LD_EXP 35
13608: PUSH
13609: LD_EXP 36
13613: PUSH
13614: LD_EXP 38
13618: PUSH
13619: LD_EXP 39
13623: PUSH
13624: LD_EXP 40
13628: PUSH
13629: LD_EXP 41
13633: PUSH
13634: LD_EXP 42
13638: PUSH
13639: LD_EXP 43
13643: PUSH
13644: LD_EXP 44
13648: PUSH
13649: LD_EXP 45
13653: PUSH
13654: LD_EXP 46
13658: PUSH
13659: LD_EXP 47
13663: PUSH
13664: LD_EXP 48
13668: PUSH
13669: LD_EXP 49
13673: PUSH
13674: LD_EXP 50
13678: PUSH
13679: LD_EXP 33
13683: PUSH
13684: EMPTY
13685: LIST
13686: LIST
13687: LIST
13688: LIST
13689: LIST
13690: LIST
13691: LIST
13692: LIST
13693: LIST
13694: LIST
13695: LIST
13696: LIST
13697: LIST
13698: LIST
13699: LIST
13700: LIST
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: LIST
13706: LIST
13707: LIST
13708: LIST
13709: LIST
13710: LIST
13711: LIST
13712: LIST
13713: LIST
13714: LIST
13715: LIST
13716: LIST
13717: LIST
13718: LIST
13719: ST_TO_ADDR
// if tmp diff tmp2 then
13720: LD_VAR 0 2
13724: PUSH
13725: LD_VAR 0 3
13729: DIFF
13730: IFFALSE 13750
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
13732: LD_VAR 0 2
13736: PUSH
13737: LD_VAR 0 3
13741: DIFF
13742: PPUSH
13743: LD_STRING 13a_others
13745: PPUSH
13746: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
13750: LD_EXP 16
13754: PPUSH
13755: LD_STRING 13a_JMM
13757: PPUSH
13758: CALL_OW 38
// if IsOk ( Mike ) then
13762: LD_EXP 33
13766: PPUSH
13767: CALL_OW 302
13771: IFFALSE 13785
// SaveCharacters ( Mike , 13a_Mike ) ;
13773: LD_EXP 33
13777: PPUSH
13778: LD_STRING 13a_Mike
13780: PPUSH
13781: CALL_OW 38
// if IsOk ( Titov ) then
13785: LD_EXP 36
13789: PPUSH
13790: CALL_OW 302
13794: IFFALSE 13808
// SaveCharacters ( Titov , 13a_Titov ) ;
13796: LD_EXP 36
13800: PPUSH
13801: LD_STRING 13a_Titov
13803: PPUSH
13804: CALL_OW 38
// if IsOk ( Dolgov ) then
13808: LD_EXP 38
13812: PPUSH
13813: CALL_OW 302
13817: IFFALSE 13831
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
13819: LD_EXP 38
13823: PPUSH
13824: LD_STRING 13a_Dolgov
13826: PPUSH
13827: CALL_OW 38
// if IsOk ( Petrosyan ) then
13831: LD_EXP 39
13835: PPUSH
13836: CALL_OW 302
13840: IFFALSE 13854
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
13842: LD_EXP 39
13846: PPUSH
13847: LD_STRING 13a_Petrosyan
13849: PPUSH
13850: CALL_OW 38
// if IsOk ( Scholtze ) then
13854: LD_EXP 40
13858: PPUSH
13859: CALL_OW 302
13863: IFFALSE 13877
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
13865: LD_EXP 40
13869: PPUSH
13870: LD_STRING 13a_Scholtze
13872: PPUSH
13873: CALL_OW 38
// if IsOk ( Oblukov ) then
13877: LD_EXP 41
13881: PPUSH
13882: CALL_OW 302
13886: IFFALSE 13900
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
13888: LD_EXP 41
13892: PPUSH
13893: LD_STRING 13a_Oblukov
13895: PPUSH
13896: CALL_OW 38
// if IsOk ( Kapitsova ) then
13900: LD_EXP 42
13904: PPUSH
13905: CALL_OW 302
13909: IFFALSE 13923
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
13911: LD_EXP 42
13915: PPUSH
13916: LD_STRING 13a_Kapitsova
13918: PPUSH
13919: CALL_OW 38
// if IsOk ( Lipshchin ) then
13923: LD_EXP 43
13927: PPUSH
13928: CALL_OW 302
13932: IFFALSE 13946
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
13934: LD_EXP 43
13938: PPUSH
13939: LD_STRING 13a_Lipshchin
13941: PPUSH
13942: CALL_OW 38
// if IsOk ( Petrovova ) then
13946: LD_EXP 44
13950: PPUSH
13951: CALL_OW 302
13955: IFFALSE 13969
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
13957: LD_EXP 44
13961: PPUSH
13962: LD_STRING 13a_Petrovova
13964: PPUSH
13965: CALL_OW 38
// if IsOk ( Kovalyuk ) then
13969: LD_EXP 45
13973: PPUSH
13974: CALL_OW 302
13978: IFFALSE 13992
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
13980: LD_EXP 45
13984: PPUSH
13985: LD_STRING 13a_Kovalyuk
13987: PPUSH
13988: CALL_OW 38
// if IsOk ( Kuzmov ) then
13992: LD_EXP 46
13996: PPUSH
13997: CALL_OW 302
14001: IFFALSE 14015
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
14003: LD_EXP 46
14007: PPUSH
14008: LD_STRING 13a_Kuzmov
14010: PPUSH
14011: CALL_OW 38
// if IsOk ( Karamazov ) then
14015: LD_EXP 47
14019: PPUSH
14020: CALL_OW 302
14024: IFFALSE 14038
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
14026: LD_EXP 47
14030: PPUSH
14031: LD_STRING 13a_Karamazov
14033: PPUSH
14034: CALL_OW 38
// if Burlak then
14038: LD_EXP 48
14042: IFFALSE 14063
// begin ToLua ( enableBioCharacter(BIO_GORKI) ) ;
14044: LD_STRING enableBioCharacter(BIO_GORKI)
14046: PPUSH
14047: CALL_OW 559
// SaveCharacters ( Burlak , 13a_Burlak ) ;
14051: LD_EXP 48
14055: PPUSH
14056: LD_STRING 13a_Burlak
14058: PPUSH
14059: CALL_OW 38
// end ; if IsOk ( Belkov ) then
14063: LD_EXP 49
14067: PPUSH
14068: CALL_OW 302
14072: IFFALSE 14086
// SaveCharacters ( Belkov , 13a_Belkov ) ;
14074: LD_EXP 49
14078: PPUSH
14079: LD_STRING 13a_Belkov
14081: PPUSH
14082: CALL_OW 38
// if IsOk ( Gnyevko ) then
14086: LD_EXP 50
14090: PPUSH
14091: CALL_OW 302
14095: IFFALSE 14109
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
14097: LD_EXP 50
14101: PPUSH
14102: LD_STRING 13a_Gnyevko
14104: PPUSH
14105: CALL_OW 38
// if IsOk ( Lisa ) then
14109: LD_EXP 18
14113: PPUSH
14114: CALL_OW 302
14118: IFFALSE 14132
// SaveCharacters ( Lisa , 13a_Lisa ) ;
14120: LD_EXP 18
14124: PPUSH
14125: LD_STRING 13a_Lisa
14127: PPUSH
14128: CALL_OW 38
// if IsOk ( Donaldson ) then
14132: LD_EXP 19
14136: PPUSH
14137: CALL_OW 302
14141: IFFALSE 14155
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
14143: LD_EXP 19
14147: PPUSH
14148: LD_STRING 13a_Donaldson
14150: PPUSH
14151: CALL_OW 38
// if IsOk ( Bobby ) then
14155: LD_EXP 20
14159: PPUSH
14160: CALL_OW 302
14164: IFFALSE 14178
// SaveCharacters ( Bobby , 13a_Bobby ) ;
14166: LD_EXP 20
14170: PPUSH
14171: LD_STRING 13a_Bobby
14173: PPUSH
14174: CALL_OW 38
// if IsOk ( Cyrus ) then
14178: LD_EXP 21
14182: PPUSH
14183: CALL_OW 302
14187: IFFALSE 14201
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
14189: LD_EXP 21
14193: PPUSH
14194: LD_STRING 13a_Cyrus
14196: PPUSH
14197: CALL_OW 38
// if IsOk ( Denis ) then
14201: LD_EXP 22
14205: PPUSH
14206: CALL_OW 302
14210: IFFALSE 14224
// SaveCharacters ( Denis , 13a_Denis ) ;
14212: LD_EXP 22
14216: PPUSH
14217: LD_STRING 13a_Denis
14219: PPUSH
14220: CALL_OW 38
// if IsOk ( Brown ) then
14224: LD_EXP 23
14228: PPUSH
14229: CALL_OW 302
14233: IFFALSE 14247
// SaveCharacters ( Brown , 13a_Brown ) ;
14235: LD_EXP 23
14239: PPUSH
14240: LD_STRING 13a_Brown
14242: PPUSH
14243: CALL_OW 38
// if IsOk ( Gladstone ) then
14247: LD_EXP 24
14251: PPUSH
14252: CALL_OW 302
14256: IFFALSE 14270
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
14258: LD_EXP 24
14262: PPUSH
14263: LD_STRING 13a_Gladstone
14265: PPUSH
14266: CALL_OW 38
// if IsOk ( Houten ) then
14270: LD_EXP 25
14274: PPUSH
14275: CALL_OW 302
14279: IFFALSE 14293
// SaveCharacters ( Houten , 13a_Houten ) ;
14281: LD_EXP 25
14285: PPUSH
14286: LD_STRING 13a_Houten
14288: PPUSH
14289: CALL_OW 38
// if IsOk ( Cornel ) then
14293: LD_EXP 26
14297: PPUSH
14298: CALL_OW 302
14302: IFFALSE 14316
// SaveCharacters ( Cornel , 13a_Cornel ) ;
14304: LD_EXP 26
14308: PPUSH
14309: LD_STRING 13a_Cornel
14311: PPUSH
14312: CALL_OW 38
// if IsOk ( Gary ) then
14316: LD_EXP 27
14320: PPUSH
14321: CALL_OW 302
14325: IFFALSE 14339
// SaveCharacters ( Gary , 13a_Gary ) ;
14327: LD_EXP 27
14331: PPUSH
14332: LD_STRING 13a_Gary
14334: PPUSH
14335: CALL_OW 38
// if IsOk ( Frank ) then
14339: LD_EXP 28
14343: PPUSH
14344: CALL_OW 302
14348: IFFALSE 14362
// SaveCharacters ( Frank , 13a_Frank ) ;
14350: LD_EXP 28
14354: PPUSH
14355: LD_STRING 13a_Frank
14357: PPUSH
14358: CALL_OW 38
// if IsOk ( Kikuchi ) then
14362: LD_EXP 29
14366: PPUSH
14367: CALL_OW 302
14371: IFFALSE 14385
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
14373: LD_EXP 29
14377: PPUSH
14378: LD_STRING 13a_Kikuchi
14380: PPUSH
14381: CALL_OW 38
// if IsOk ( Simms ) then
14385: LD_EXP 30
14389: PPUSH
14390: CALL_OW 302
14394: IFFALSE 14408
// SaveCharacters ( Simms , 13a_Simms ) ;
14396: LD_EXP 30
14400: PPUSH
14401: LD_STRING 13a_Simms
14403: PPUSH
14404: CALL_OW 38
// if IsOk ( Joan ) then
14408: LD_EXP 31
14412: PPUSH
14413: CALL_OW 302
14417: IFFALSE 14431
// SaveCharacters ( Joan , 13a_Joan ) ;
14419: LD_EXP 31
14423: PPUSH
14424: LD_STRING 13a_Joan
14426: PPUSH
14427: CALL_OW 38
// if IsOk ( DeltaDoctor ) then
14431: LD_EXP 32
14435: PPUSH
14436: CALL_OW 302
14440: IFFALSE 14454
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
14442: LD_EXP 32
14446: PPUSH
14447: LD_STRING 13a_DeltaDoctor
14449: PPUSH
14450: CALL_OW 38
// if IsOk ( Gossudarov ) then
14454: LD_EXP 34
14458: PPUSH
14459: CALL_OW 302
14463: IFFALSE 14477
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
14465: LD_EXP 34
14469: PPUSH
14470: LD_STRING 13a_Gossudarov
14472: PPUSH
14473: CALL_OW 38
// if IsOk ( Kirilenkova ) then
14477: LD_EXP 35
14481: PPUSH
14482: CALL_OW 302
14486: IFFALSE 14500
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
14488: LD_EXP 35
14492: PPUSH
14493: LD_STRING 13a_Kirilenkova
14495: PPUSH
14496: CALL_OW 38
// if IsOk ( Roth ) then
14500: LD_EXP 17
14504: PPUSH
14505: CALL_OW 302
14509: IFFALSE 14523
// SaveCharacters ( Roth , 13a_Roth ) ;
14511: LD_EXP 17
14515: PPUSH
14516: LD_STRING 13a_Roth
14518: PPUSH
14519: CALL_OW 38
// if Masha then
14523: LD_EXP 51
14527: IFFALSE 14582
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
14529: LD_EXP 51
14533: PPUSH
14534: CALL_OW 265
14538: PUSH
14539: LD_EXP 51
14543: PPUSH
14544: CALL_OW 262
14548: PUSH
14549: LD_EXP 51
14553: PPUSH
14554: CALL_OW 263
14558: PUSH
14559: LD_EXP 51
14563: PPUSH
14564: CALL_OW 264
14568: PUSH
14569: EMPTY
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: PPUSH
14575: LD_STRING 13a_Masha
14577: PPUSH
14578: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
14582: LD_ADDR_VAR 0 2
14586: PUSH
14587: LD_INT 21
14589: PUSH
14590: LD_INT 3
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PPUSH
14597: CALL_OW 69
14601: ST_TO_ADDR
// tmp2 := [ ] ;
14602: LD_ADDR_VAR 0 3
14606: PUSH
14607: EMPTY
14608: ST_TO_ADDR
// if tmp then
14609: LD_VAR 0 2
14613: IFFALSE 14764
// for i in tmp do
14615: LD_ADDR_VAR 0 1
14619: PUSH
14620: LD_VAR 0 2
14624: PUSH
14625: FOR_IN
14626: IFFALSE 14762
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
14628: LD_ADDR_VAR 0 3
14632: PUSH
14633: LD_VAR 0 3
14637: PUSH
14638: LD_VAR 0 1
14642: PPUSH
14643: CALL_OW 255
14647: PUSH
14648: LD_VAR 0 1
14652: PPUSH
14653: CALL_OW 248
14657: PUSH
14658: LD_VAR 0 1
14662: PPUSH
14663: CALL_OW 266
14667: PUSH
14668: LD_VAR 0 1
14672: PPUSH
14673: CALL_OW 250
14677: PUSH
14678: LD_VAR 0 1
14682: PPUSH
14683: CALL_OW 251
14687: PUSH
14688: LD_VAR 0 1
14692: PPUSH
14693: CALL_OW 254
14697: PUSH
14698: LD_VAR 0 1
14702: PPUSH
14703: CALL_OW 267
14707: PUSH
14708: LD_VAR 0 1
14712: PPUSH
14713: LD_INT 1
14715: PPUSH
14716: CALL_OW 268
14720: PUSH
14721: LD_VAR 0 1
14725: PPUSH
14726: LD_INT 2
14728: PPUSH
14729: CALL_OW 268
14733: PUSH
14734: LD_VAR 0 1
14738: PPUSH
14739: CALL_OW 269
14743: PUSH
14744: EMPTY
14745: LIST
14746: LIST
14747: LIST
14748: LIST
14749: LIST
14750: LIST
14751: LIST
14752: LIST
14753: LIST
14754: LIST
14755: PUSH
14756: EMPTY
14757: LIST
14758: ADD
14759: ST_TO_ADDR
14760: GO 14625
14762: POP
14763: POP
// if tmp2 then
14764: LD_VAR 0 3
14768: IFFALSE 14782
// SaveVariable ( tmp2 , 13a_buildings ) ;
14770: LD_VAR 0 3
14774: PPUSH
14775: LD_STRING 13a_buildings
14777: PPUSH
14778: CALL_OW 39
// YouWin ;
14782: CALL_OW 103
// end ;
14786: PPOPN 6
14788: END
// export function SciRu ; var tmp , t ; begin
14789: LD_INT 0
14791: PPUSH
14792: PPUSH
14793: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
14794: LD_ADDR_VAR 0 3
14798: PUSH
14799: LD_EXP 34
14803: PUSH
14804: LD_EXP 48
14808: PUSH
14809: LD_EXP 36
14813: PUSH
14814: LD_EXP 49
14818: PUSH
14819: LD_EXP 50
14823: PUSH
14824: LD_EXP 39
14828: PUSH
14829: LD_EXP 40
14833: PUSH
14834: LD_EXP 38
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: LIST
14843: LIST
14844: LIST
14845: LIST
14846: LIST
14847: LIST
14848: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
14849: LD_ADDR_VAR 0 2
14853: PUSH
14854: LD_INT 22
14856: PUSH
14857: LD_INT 7
14859: PUSH
14860: EMPTY
14861: LIST
14862: LIST
14863: PUSH
14864: LD_INT 23
14866: PUSH
14867: LD_INT 3
14869: PUSH
14870: EMPTY
14871: LIST
14872: LIST
14873: PUSH
14874: LD_INT 25
14876: PUSH
14877: LD_INT 4
14879: PUSH
14880: EMPTY
14881: LIST
14882: LIST
14883: PUSH
14884: LD_INT 26
14886: PUSH
14887: LD_INT 1
14889: PUSH
14890: EMPTY
14891: LIST
14892: LIST
14893: PUSH
14894: EMPTY
14895: LIST
14896: LIST
14897: LIST
14898: LIST
14899: PPUSH
14900: CALL_OW 69
14904: PUSH
14905: LD_VAR 0 3
14909: DIFF
14910: ST_TO_ADDR
// if tmp then
14911: LD_VAR 0 2
14915: IFFALSE 14931
// result := tmp [ 1 ] ;
14917: LD_ADDR_VAR 0 1
14921: PUSH
14922: LD_VAR 0 2
14926: PUSH
14927: LD_INT 1
14929: ARRAY
14930: ST_TO_ADDR
// end ;
14931: LD_VAR 0 1
14935: RET
// export function SolRu ; var tmp , t ; begin
14936: LD_INT 0
14938: PPUSH
14939: PPUSH
14940: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
14941: LD_ADDR_VAR 0 3
14945: PUSH
14946: LD_EXP 34
14950: PUSH
14951: LD_EXP 48
14955: PUSH
14956: LD_EXP 36
14960: PUSH
14961: LD_EXP 49
14965: PUSH
14966: LD_EXP 50
14970: PUSH
14971: LD_EXP 39
14975: PUSH
14976: LD_EXP 40
14980: PUSH
14981: LD_EXP 38
14985: PUSH
14986: EMPTY
14987: LIST
14988: LIST
14989: LIST
14990: LIST
14991: LIST
14992: LIST
14993: LIST
14994: LIST
14995: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
14996: LD_ADDR_VAR 0 2
15000: PUSH
15001: LD_INT 22
15003: PUSH
15004: LD_INT 7
15006: PUSH
15007: EMPTY
15008: LIST
15009: LIST
15010: PUSH
15011: LD_INT 23
15013: PUSH
15014: LD_INT 3
15016: PUSH
15017: EMPTY
15018: LIST
15019: LIST
15020: PUSH
15021: LD_INT 25
15023: PUSH
15024: LD_INT 1
15026: PUSH
15027: EMPTY
15028: LIST
15029: LIST
15030: PUSH
15031: LD_INT 26
15033: PUSH
15034: LD_INT 1
15036: PUSH
15037: EMPTY
15038: LIST
15039: LIST
15040: PUSH
15041: EMPTY
15042: LIST
15043: LIST
15044: LIST
15045: LIST
15046: PPUSH
15047: CALL_OW 69
15051: PUSH
15052: LD_VAR 0 3
15056: DIFF
15057: ST_TO_ADDR
// if tmp then
15058: LD_VAR 0 2
15062: IFFALSE 15078
// result := tmp [ 1 ] ;
15064: LD_ADDR_VAR 0 1
15068: PUSH
15069: LD_VAR 0 2
15073: PUSH
15074: LD_INT 1
15076: ARRAY
15077: ST_TO_ADDR
// end ; end_of_file
15078: LD_VAR 0 1
15082: RET
// export function CustomEvent ( event ) ; begin
15083: LD_INT 0
15085: PPUSH
// end ;
15086: LD_VAR 0 2
15090: RET
// on UnitDestroyed ( un ) do var i , side ;
15091: LD_INT 0
15093: PPUSH
15094: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
15095: LD_VAR 0 1
15099: PPUSH
15100: CALL 105177 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
15104: LD_VAR 0 1
15108: PUSH
15109: LD_INT 22
15111: PUSH
15112: LD_INT 7
15114: PUSH
15115: EMPTY
15116: LIST
15117: LIST
15118: PUSH
15119: LD_INT 2
15121: PUSH
15122: LD_INT 25
15124: PUSH
15125: LD_INT 1
15127: PUSH
15128: EMPTY
15129: LIST
15130: LIST
15131: PUSH
15132: LD_INT 25
15134: PUSH
15135: LD_INT 2
15137: PUSH
15138: EMPTY
15139: LIST
15140: LIST
15141: PUSH
15142: LD_INT 25
15144: PUSH
15145: LD_INT 3
15147: PUSH
15148: EMPTY
15149: LIST
15150: LIST
15151: PUSH
15152: LD_INT 25
15154: PUSH
15155: LD_INT 4
15157: PUSH
15158: EMPTY
15159: LIST
15160: LIST
15161: PUSH
15162: LD_INT 25
15164: PUSH
15165: LD_INT 5
15167: PUSH
15168: EMPTY
15169: LIST
15170: LIST
15171: PUSH
15172: LD_INT 25
15174: PUSH
15175: LD_INT 8
15177: PUSH
15178: EMPTY
15179: LIST
15180: LIST
15181: PUSH
15182: LD_INT 25
15184: PUSH
15185: LD_INT 9
15187: PUSH
15188: EMPTY
15189: LIST
15190: LIST
15191: PUSH
15192: EMPTY
15193: LIST
15194: LIST
15195: LIST
15196: LIST
15197: LIST
15198: LIST
15199: LIST
15200: LIST
15201: PUSH
15202: EMPTY
15203: LIST
15204: LIST
15205: PPUSH
15206: CALL_OW 69
15210: IN
15211: IFFALSE 15227
// loss_counter := loss_counter + 1 ;
15213: LD_ADDR_EXP 14
15217: PUSH
15218: LD_EXP 14
15222: PUSH
15223: LD_INT 1
15225: PLUS
15226: ST_TO_ADDR
// if un = Abdul then
15227: LD_VAR 0 1
15231: PUSH
15232: LD_EXP 57
15236: EQUAL
15237: IFFALSE 15247
// abdul_escaped := false ;
15239: LD_ADDR_EXP 13
15243: PUSH
15244: LD_INT 0
15246: ST_TO_ADDR
// if un in ru_attackers then
15247: LD_VAR 0 1
15251: PUSH
15252: LD_EXP 54
15256: IN
15257: IFFALSE 15275
// ru_attackers := ru_attackers diff un ;
15259: LD_ADDR_EXP 54
15263: PUSH
15264: LD_EXP 54
15268: PUSH
15269: LD_VAR 0 1
15273: DIFF
15274: ST_TO_ADDR
// if un in ar_attackers then
15275: LD_VAR 0 1
15279: PUSH
15280: LD_EXP 11
15284: IN
15285: IFFALSE 15303
// ar_attackers := ar_attackers diff un ;
15287: LD_ADDR_EXP 11
15291: PUSH
15292: LD_EXP 11
15296: PUSH
15297: LD_VAR 0 1
15301: DIFF
15302: ST_TO_ADDR
// if un = JMM then
15303: LD_VAR 0 1
15307: PUSH
15308: LD_EXP 16
15312: EQUAL
15313: IFFALSE 15324
// begin YouLost ( JMM ) ;
15315: LD_STRING JMM
15317: PPUSH
15318: CALL_OW 104
// exit ;
15322: GO 15421
// end ; if un = Burlak then
15324: LD_VAR 0 1
15328: PUSH
15329: LD_EXP 48
15333: EQUAL
15334: IFFALSE 15345
// begin YouLost ( Burlak ) ;
15336: LD_STRING Burlak
15338: PPUSH
15339: CALL_OW 104
// exit ;
15343: GO 15421
// end ; if un = freedom then
15345: LD_VAR 0 1
15349: PUSH
15350: LD_EXP 3
15354: EQUAL
15355: IFFALSE 15366
// begin YouLost ( Destroyed ) ;
15357: LD_STRING Destroyed
15359: PPUSH
15360: CALL_OW 104
// exit ;
15364: GO 15421
// end ; if un = Masha then
15366: LD_VAR 0 1
15370: PUSH
15371: LD_EXP 51
15375: EQUAL
15376: IFFALSE 15393
// begin ChangeMissionObjectives ( M4b ) ;
15378: LD_STRING M4b
15380: PPUSH
15381: CALL_OW 337
// masha_killed := true ;
15385: LD_ADDR_EXP 10
15389: PUSH
15390: LD_INT 1
15392: ST_TO_ADDR
// end ; if un = Mastodont then
15393: LD_VAR 0 1
15397: PUSH
15398: LD_EXP 58
15402: EQUAL
15403: IFFALSE 15412
// ChangeMissionObjectives ( M4a ) ;
15405: LD_STRING M4a
15407: PPUSH
15408: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
15412: LD_VAR 0 1
15416: PPUSH
15417: CALL 86391 0 1
// end ;
15421: PPOPN 3
15423: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
15424: LD_VAR 0 1
15428: PPUSH
15429: LD_VAR 0 2
15433: PPUSH
15434: CALL 88723 0 2
// end ;
15438: PPOPN 2
15440: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
15441: LD_VAR 0 1
15445: PPUSH
15446: CALL 87791 0 1
// end ;
15450: PPOPN 1
15452: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
15453: LD_VAR 0 1
15457: PUSH
15458: LD_INT 22
15460: PUSH
15461: LD_INT 7
15463: PUSH
15464: EMPTY
15465: LIST
15466: LIST
15467: PUSH
15468: LD_INT 30
15470: PUSH
15471: LD_INT 0
15473: PUSH
15474: EMPTY
15475: LIST
15476: LIST
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PPUSH
15482: CALL_OW 69
15486: IN
15487: IFFALSE 15526
// begin SetBName ( building , freedom ) ;
15489: LD_VAR 0 1
15493: PPUSH
15494: LD_STRING freedom
15496: PPUSH
15497: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
15501: LD_INT 0
15503: PPUSH
15504: LD_INT 7
15506: PPUSH
15507: LD_INT 0
15509: PPUSH
15510: CALL_OW 324
// freedom := building ;
15514: LD_ADDR_EXP 3
15518: PUSH
15519: LD_VAR 0 1
15523: ST_TO_ADDR
// exit ;
15524: GO 15592
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
15526: LD_VAR 0 1
15530: PUSH
15531: LD_INT 22
15533: PUSH
15534: LD_INT 7
15536: PUSH
15537: EMPTY
15538: LIST
15539: LIST
15540: PUSH
15541: LD_INT 23
15543: PUSH
15544: LD_INT 3
15546: PUSH
15547: EMPTY
15548: LIST
15549: LIST
15550: PUSH
15551: LD_INT 30
15553: PUSH
15554: LD_INT 6
15556: PUSH
15557: EMPTY
15558: LIST
15559: LIST
15560: PUSH
15561: EMPTY
15562: LIST
15563: LIST
15564: LIST
15565: PPUSH
15566: CALL_OW 69
15570: IN
15571: IFFALSE 15583
// begin ru_lab_builded := true ;
15573: LD_ADDR_EXP 5
15577: PUSH
15578: LD_INT 1
15580: ST_TO_ADDR
// exit ;
15581: GO 15592
// end ; MCE_BuildingComplete ( building ) ;
15583: LD_VAR 0 1
15587: PPUSH
15588: CALL 88032 0 1
// end ;
15592: PPOPN 1
15594: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
15595: LD_VAR 0 1
15599: PPUSH
15600: LD_VAR 0 2
15604: PPUSH
15605: CALL 86087 0 2
// end ;
15609: PPOPN 2
15611: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
15612: LD_VAR 0 1
15616: PPUSH
15617: LD_VAR 0 2
15621: PPUSH
15622: LD_VAR 0 3
15626: PPUSH
15627: LD_VAR 0 4
15631: PPUSH
15632: LD_VAR 0 5
15636: PPUSH
15637: CALL 85707 0 5
// end ;
15641: PPOPN 5
15643: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
15644: LD_VAR 0 1
15648: PPUSH
15649: LD_VAR 0 2
15653: PPUSH
15654: CALL 105297 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
15658: LD_VAR 0 1
15662: PPUSH
15663: LD_VAR 0 2
15667: PPUSH
15668: CALL 85260 0 2
// end ;
15672: PPOPN 2
15674: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
15675: LD_VAR 0 1
15679: PPUSH
15680: CALL_OW 263
15684: PUSH
15685: LD_INT 3
15687: EQUAL
15688: PUSH
15689: LD_VAR 0 2
15693: PPUSH
15694: CALL_OW 263
15698: PUSH
15699: LD_INT 3
15701: EQUAL
15702: OR
15703: IFFALSE 15719
// hack_counter := hack_counter + 1 ;
15705: LD_ADDR_EXP 15
15709: PUSH
15710: LD_EXP 15
15714: PUSH
15715: LD_INT 1
15717: PLUS
15718: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
15719: LD_VAR 0 1
15723: PPUSH
15724: LD_VAR 0 2
15728: PPUSH
15729: LD_VAR 0 3
15733: PPUSH
15734: LD_VAR 0 4
15738: PPUSH
15739: CALL 85098 0 4
// end ;
15743: PPOPN 4
15745: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin if building = ru_depot then
15746: LD_VAR 0 1
15750: PUSH
15751: LD_INT 47
15753: EQUAL
15754: IFFALSE 15776
// SetResourceType ( GetBase ( building ) , mat_cans , 600 ) ;
15756: LD_VAR 0 1
15760: PPUSH
15761: CALL_OW 274
15765: PPUSH
15766: LD_INT 1
15768: PPUSH
15769: LD_INT 600
15771: PPUSH
15772: CALL_OW 277
// MCE_BuildingCaptured ( building , side , capturning_unit ) ;
15776: LD_VAR 0 1
15780: PPUSH
15781: LD_VAR 0 2
15785: PPUSH
15786: LD_VAR 0 3
15790: PPUSH
15791: CALL 84873 0 3
// end ;
15795: PPOPN 3
15797: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
15798: LD_VAR 0 1
15802: PPUSH
15803: LD_VAR 0 2
15807: PPUSH
15808: CALL 84758 0 2
// end ;
15812: PPOPN 2
15814: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
15815: LD_VAR 0 1
15819: PPUSH
15820: LD_VAR 0 2
15824: PPUSH
15825: CALL 89018 0 2
// end ;
15829: PPOPN 2
15831: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
15832: LD_VAR 0 1
15836: PPUSH
15837: LD_VAR 0 2
15841: PPUSH
15842: LD_VAR 0 3
15846: PPUSH
15847: LD_VAR 0 4
15851: PPUSH
15852: CALL 89234 0 4
// end ;
15856: PPOPN 4
15858: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
15859: LD_VAR 0 1
15863: PPUSH
15864: LD_VAR 0 2
15868: PPUSH
15869: CALL 84567 0 2
// end ;
15873: PPOPN 2
15875: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
15876: LD_VAR 0 1
15880: PPUSH
15881: CALL 105281 0 1
// end ; end_of_file
15885: PPOPN 1
15887: END
// every 0 0$30 do var cr , time ;
15888: GO 15890
15890: DISABLE
15891: LD_INT 0
15893: PPUSH
15894: PPUSH
// begin time := 0 0$20 ;
15895: LD_ADDR_VAR 0 2
15899: PUSH
15900: LD_INT 700
15902: ST_TO_ADDR
// while game do
15903: LD_EXP 2
15907: IFFALSE 16010
// begin wait ( time ) ;
15909: LD_VAR 0 2
15913: PPUSH
15914: CALL_OW 67
// if tick > 2 2$00 then
15918: LD_OWVAR 1
15922: PUSH
15923: LD_INT 4200
15925: GREATER
15926: IFFALSE 15963
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
15928: LD_ADDR_VAR 0 2
15932: PUSH
15933: LD_VAR 0 2
15937: PUSH
15938: LD_INT 140
15940: PUSH
15941: LD_INT 140
15943: PUSH
15944: LD_INT 210
15946: PUSH
15947: LD_INT 280
15949: PUSH
15950: EMPTY
15951: LIST
15952: LIST
15953: LIST
15954: LIST
15955: PUSH
15956: LD_OWVAR 67
15960: ARRAY
15961: PLUS
15962: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
15963: LD_INT 1
15965: PPUSH
15966: LD_INT 5
15968: PPUSH
15969: CALL_OW 12
15973: PPUSH
15974: LD_INT 70
15976: PPUSH
15977: LD_INT 49
15979: PPUSH
15980: LD_INT 25
15982: PPUSH
15983: LD_INT 1
15985: PPUSH
15986: CALL_OW 56
// if time > 3 3$00 then
15990: LD_VAR 0 2
15994: PUSH
15995: LD_INT 6300
15997: GREATER
15998: IFFALSE 16008
// time := 0 0$30 ;
16000: LD_ADDR_VAR 0 2
16004: PUSH
16005: LD_INT 1050
16007: ST_TO_ADDR
// end ;
16008: GO 15903
// end ;
16010: PPOPN 2
16012: END
// every 0 0$30 do var cr , time ;
16013: GO 16015
16015: DISABLE
16016: LD_INT 0
16018: PPUSH
16019: PPUSH
// begin time := 0 0$20 ;
16020: LD_ADDR_VAR 0 2
16024: PUSH
16025: LD_INT 700
16027: ST_TO_ADDR
// while game do
16028: LD_EXP 2
16032: IFFALSE 16125
// begin wait ( time ) ;
16034: LD_VAR 0 2
16038: PPUSH
16039: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
16043: LD_ADDR_VAR 0 2
16047: PUSH
16048: LD_VAR 0 2
16052: PUSH
16053: LD_INT 140
16055: PUSH
16056: LD_INT 175
16058: PUSH
16059: LD_INT 210
16061: PUSH
16062: LD_INT 280
16064: PUSH
16065: EMPTY
16066: LIST
16067: LIST
16068: LIST
16069: LIST
16070: PUSH
16071: LD_OWVAR 67
16075: ARRAY
16076: PLUS
16077: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
16078: LD_INT 3
16080: PPUSH
16081: LD_INT 5
16083: PPUSH
16084: CALL_OW 12
16088: PPUSH
16089: LD_INT 26
16091: PPUSH
16092: LD_INT 9
16094: PPUSH
16095: LD_INT 30
16097: PPUSH
16098: LD_INT 1
16100: PPUSH
16101: CALL_OW 56
// if time > 3 3$00 then
16105: LD_VAR 0 2
16109: PUSH
16110: LD_INT 6300
16112: GREATER
16113: IFFALSE 16123
// time := 0 0$20 ;
16115: LD_ADDR_VAR 0 2
16119: PUSH
16120: LD_INT 700
16122: ST_TO_ADDR
// end ;
16123: GO 16028
// end ;
16125: PPOPN 2
16127: END
// every 0 0$30 do var cr , time ;
16128: GO 16130
16130: DISABLE
16131: LD_INT 0
16133: PPUSH
16134: PPUSH
// begin time := 0 0$20 ;
16135: LD_ADDR_VAR 0 2
16139: PUSH
16140: LD_INT 700
16142: ST_TO_ADDR
// while game do
16143: LD_EXP 2
16147: IFFALSE 16276
// begin wait ( time ) ;
16149: LD_VAR 0 2
16153: PPUSH
16154: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
16158: LD_ADDR_VAR 0 2
16162: PUSH
16163: LD_VAR 0 2
16167: PUSH
16168: LD_INT 175
16170: PUSH
16171: LD_INT 210
16173: PUSH
16174: LD_INT 280
16176: PUSH
16177: LD_INT 350
16179: PUSH
16180: EMPTY
16181: LIST
16182: LIST
16183: LIST
16184: LIST
16185: PUSH
16186: LD_OWVAR 67
16190: ARRAY
16191: PLUS
16192: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
16193: LD_INT 1
16195: PPUSH
16196: LD_INT 5
16198: PPUSH
16199: CALL_OW 12
16203: PPUSH
16204: LD_INT 179
16206: PPUSH
16207: LD_INT 101
16209: PPUSH
16210: LD_INT 20
16212: PPUSH
16213: LD_INT 1
16215: PPUSH
16216: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
16220: LD_INT 350
16222: PPUSH
16223: LD_INT 525
16225: PPUSH
16226: CALL_OW 12
16230: PPUSH
16231: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
16235: LD_INT 1
16237: PPUSH
16238: LD_INT 5
16240: PPUSH
16241: CALL_OW 12
16245: PPUSH
16246: LD_INT 9
16248: PPUSH
16249: LD_INT 1
16251: PPUSH
16252: CALL_OW 55
// if time > 4 4$00 then
16256: LD_VAR 0 2
16260: PUSH
16261: LD_INT 8400
16263: GREATER
16264: IFFALSE 16274
// time := 0 0$30 ;
16266: LD_ADDR_VAR 0 2
16270: PUSH
16271: LD_INT 1050
16273: ST_TO_ADDR
// end ;
16274: GO 16143
// end ;
16276: PPOPN 2
16278: END
// every 0 0$30 do var cr , time ;
16279: GO 16281
16281: DISABLE
16282: LD_INT 0
16284: PPUSH
16285: PPUSH
// begin time := 0 0$10 ;
16286: LD_ADDR_VAR 0 2
16290: PUSH
16291: LD_INT 350
16293: ST_TO_ADDR
// while game do
16294: LD_EXP 2
16298: IFFALSE 16432
// begin wait ( time ) ;
16300: LD_VAR 0 2
16304: PPUSH
16305: CALL_OW 67
// time := time + 0 0$10 ;
16309: LD_ADDR_VAR 0 2
16313: PUSH
16314: LD_VAR 0 2
16318: PUSH
16319: LD_INT 350
16321: PLUS
16322: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
16323: LD_INT 1
16325: PPUSH
16326: LD_INT 5
16328: PPUSH
16329: CALL_OW 12
16333: PPUSH
16334: LD_INT 11
16336: PPUSH
16337: LD_INT 1
16339: PPUSH
16340: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
16344: LD_ADDR_VAR 0 1
16348: PUSH
16349: LD_INT 1
16351: PPUSH
16352: LD_INT 3
16354: PPUSH
16355: CALL_OW 12
16359: ST_TO_ADDR
// if cr = 1 then
16360: LD_VAR 0 1
16364: PUSH
16365: LD_INT 1
16367: EQUAL
16368: IFFALSE 16412
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
16370: LD_INT 700
16372: PPUSH
16373: LD_INT 1575
16375: PPUSH
16376: CALL_OW 12
16380: PPUSH
16381: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
16385: LD_INT 1
16387: PPUSH
16388: LD_INT 5
16390: PPUSH
16391: CALL_OW 12
16395: PPUSH
16396: LD_INT 34
16398: PPUSH
16399: LD_INT 50
16401: PPUSH
16402: LD_INT 7
16404: PPUSH
16405: LD_INT 1
16407: PPUSH
16408: CALL_OW 56
// end ; if time > 4 4$00 then
16412: LD_VAR 0 2
16416: PUSH
16417: LD_INT 8400
16419: GREATER
16420: IFFALSE 16430
// time := 0 0$40 ;
16422: LD_ADDR_VAR 0 2
16426: PUSH
16427: LD_INT 1400
16429: ST_TO_ADDR
// end ;
16430: GO 16294
// end ; end_of_file
16432: PPOPN 2
16434: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
16435: LD_INT 0
16437: PPUSH
16438: PPUSH
// if exist_mode then
16439: LD_VAR 0 2
16443: IFFALSE 16468
// unit := CreateCharacter ( prefix & ident ) else
16445: LD_ADDR_VAR 0 5
16449: PUSH
16450: LD_VAR 0 3
16454: PUSH
16455: LD_VAR 0 1
16459: STR
16460: PPUSH
16461: CALL_OW 34
16465: ST_TO_ADDR
16466: GO 16483
// unit := NewCharacter ( ident ) ;
16468: LD_ADDR_VAR 0 5
16472: PUSH
16473: LD_VAR 0 1
16477: PPUSH
16478: CALL_OW 25
16482: ST_TO_ADDR
// result := unit ;
16483: LD_ADDR_VAR 0 4
16487: PUSH
16488: LD_VAR 0 5
16492: ST_TO_ADDR
// end ;
16493: LD_VAR 0 4
16497: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
16498: LD_INT 0
16500: PPUSH
16501: PPUSH
// if not side or not nation then
16502: LD_VAR 0 1
16506: NOT
16507: PUSH
16508: LD_VAR 0 2
16512: NOT
16513: OR
16514: IFFALSE 16518
// exit ;
16516: GO 17286
// case nation of nation_american :
16518: LD_VAR 0 2
16522: PUSH
16523: LD_INT 1
16525: DOUBLE
16526: EQUAL
16527: IFTRUE 16531
16529: GO 16745
16531: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
16532: LD_ADDR_VAR 0 4
16536: PUSH
16537: LD_INT 35
16539: PUSH
16540: LD_INT 45
16542: PUSH
16543: LD_INT 46
16545: PUSH
16546: LD_INT 47
16548: PUSH
16549: LD_INT 82
16551: PUSH
16552: LD_INT 83
16554: PUSH
16555: LD_INT 84
16557: PUSH
16558: LD_INT 85
16560: PUSH
16561: LD_INT 86
16563: PUSH
16564: LD_INT 1
16566: PUSH
16567: LD_INT 2
16569: PUSH
16570: LD_INT 6
16572: PUSH
16573: LD_INT 15
16575: PUSH
16576: LD_INT 16
16578: PUSH
16579: LD_INT 7
16581: PUSH
16582: LD_INT 12
16584: PUSH
16585: LD_INT 13
16587: PUSH
16588: LD_INT 10
16590: PUSH
16591: LD_INT 14
16593: PUSH
16594: LD_INT 20
16596: PUSH
16597: LD_INT 21
16599: PUSH
16600: LD_INT 22
16602: PUSH
16603: LD_INT 25
16605: PUSH
16606: LD_INT 32
16608: PUSH
16609: LD_INT 27
16611: PUSH
16612: LD_INT 36
16614: PUSH
16615: LD_INT 69
16617: PUSH
16618: LD_INT 39
16620: PUSH
16621: LD_INT 34
16623: PUSH
16624: LD_INT 40
16626: PUSH
16627: LD_INT 48
16629: PUSH
16630: LD_INT 49
16632: PUSH
16633: LD_INT 50
16635: PUSH
16636: LD_INT 51
16638: PUSH
16639: LD_INT 52
16641: PUSH
16642: LD_INT 53
16644: PUSH
16645: LD_INT 54
16647: PUSH
16648: LD_INT 55
16650: PUSH
16651: LD_INT 56
16653: PUSH
16654: LD_INT 57
16656: PUSH
16657: LD_INT 58
16659: PUSH
16660: LD_INT 59
16662: PUSH
16663: LD_INT 60
16665: PUSH
16666: LD_INT 61
16668: PUSH
16669: LD_INT 62
16671: PUSH
16672: LD_INT 80
16674: PUSH
16675: LD_INT 82
16677: PUSH
16678: LD_INT 83
16680: PUSH
16681: LD_INT 84
16683: PUSH
16684: LD_INT 85
16686: PUSH
16687: LD_INT 86
16689: PUSH
16690: EMPTY
16691: LIST
16692: LIST
16693: LIST
16694: LIST
16695: LIST
16696: LIST
16697: LIST
16698: LIST
16699: LIST
16700: LIST
16701: LIST
16702: LIST
16703: LIST
16704: LIST
16705: LIST
16706: LIST
16707: LIST
16708: LIST
16709: LIST
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: LIST
16715: LIST
16716: LIST
16717: LIST
16718: LIST
16719: LIST
16720: LIST
16721: LIST
16722: LIST
16723: LIST
16724: LIST
16725: LIST
16726: LIST
16727: LIST
16728: LIST
16729: LIST
16730: LIST
16731: LIST
16732: LIST
16733: LIST
16734: LIST
16735: LIST
16736: LIST
16737: LIST
16738: LIST
16739: LIST
16740: LIST
16741: LIST
16742: ST_TO_ADDR
16743: GO 17210
16745: LD_INT 2
16747: DOUBLE
16748: EQUAL
16749: IFTRUE 16753
16751: GO 16979
16753: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
16754: LD_ADDR_VAR 0 4
16758: PUSH
16759: LD_INT 35
16761: PUSH
16762: LD_INT 45
16764: PUSH
16765: LD_INT 46
16767: PUSH
16768: LD_INT 47
16770: PUSH
16771: LD_INT 82
16773: PUSH
16774: LD_INT 83
16776: PUSH
16777: LD_INT 84
16779: PUSH
16780: LD_INT 85
16782: PUSH
16783: LD_INT 87
16785: PUSH
16786: LD_INT 70
16788: PUSH
16789: LD_INT 1
16791: PUSH
16792: LD_INT 11
16794: PUSH
16795: LD_INT 3
16797: PUSH
16798: LD_INT 4
16800: PUSH
16801: LD_INT 5
16803: PUSH
16804: LD_INT 6
16806: PUSH
16807: LD_INT 15
16809: PUSH
16810: LD_INT 18
16812: PUSH
16813: LD_INT 7
16815: PUSH
16816: LD_INT 17
16818: PUSH
16819: LD_INT 8
16821: PUSH
16822: LD_INT 20
16824: PUSH
16825: LD_INT 21
16827: PUSH
16828: LD_INT 22
16830: PUSH
16831: LD_INT 72
16833: PUSH
16834: LD_INT 26
16836: PUSH
16837: LD_INT 69
16839: PUSH
16840: LD_INT 39
16842: PUSH
16843: LD_INT 40
16845: PUSH
16846: LD_INT 41
16848: PUSH
16849: LD_INT 42
16851: PUSH
16852: LD_INT 43
16854: PUSH
16855: LD_INT 48
16857: PUSH
16858: LD_INT 49
16860: PUSH
16861: LD_INT 50
16863: PUSH
16864: LD_INT 51
16866: PUSH
16867: LD_INT 52
16869: PUSH
16870: LD_INT 53
16872: PUSH
16873: LD_INT 54
16875: PUSH
16876: LD_INT 55
16878: PUSH
16879: LD_INT 56
16881: PUSH
16882: LD_INT 60
16884: PUSH
16885: LD_INT 61
16887: PUSH
16888: LD_INT 62
16890: PUSH
16891: LD_INT 66
16893: PUSH
16894: LD_INT 67
16896: PUSH
16897: LD_INT 68
16899: PUSH
16900: LD_INT 81
16902: PUSH
16903: LD_INT 82
16905: PUSH
16906: LD_INT 83
16908: PUSH
16909: LD_INT 84
16911: PUSH
16912: LD_INT 85
16914: PUSH
16915: LD_INT 87
16917: PUSH
16918: LD_INT 88
16920: PUSH
16921: EMPTY
16922: LIST
16923: LIST
16924: LIST
16925: LIST
16926: LIST
16927: LIST
16928: LIST
16929: LIST
16930: LIST
16931: LIST
16932: LIST
16933: LIST
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: LIST
16939: LIST
16940: LIST
16941: LIST
16942: LIST
16943: LIST
16944: LIST
16945: LIST
16946: LIST
16947: LIST
16948: LIST
16949: LIST
16950: LIST
16951: LIST
16952: LIST
16953: LIST
16954: LIST
16955: LIST
16956: LIST
16957: LIST
16958: LIST
16959: LIST
16960: LIST
16961: LIST
16962: LIST
16963: LIST
16964: LIST
16965: LIST
16966: LIST
16967: LIST
16968: LIST
16969: LIST
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: LIST
16975: LIST
16976: ST_TO_ADDR
16977: GO 17210
16979: LD_INT 3
16981: DOUBLE
16982: EQUAL
16983: IFTRUE 16987
16985: GO 17209
16987: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
16988: LD_ADDR_VAR 0 4
16992: PUSH
16993: LD_INT 46
16995: PUSH
16996: LD_INT 47
16998: PUSH
16999: LD_INT 1
17001: PUSH
17002: LD_INT 2
17004: PUSH
17005: LD_INT 82
17007: PUSH
17008: LD_INT 83
17010: PUSH
17011: LD_INT 84
17013: PUSH
17014: LD_INT 85
17016: PUSH
17017: LD_INT 86
17019: PUSH
17020: LD_INT 11
17022: PUSH
17023: LD_INT 9
17025: PUSH
17026: LD_INT 20
17028: PUSH
17029: LD_INT 19
17031: PUSH
17032: LD_INT 21
17034: PUSH
17035: LD_INT 24
17037: PUSH
17038: LD_INT 22
17040: PUSH
17041: LD_INT 25
17043: PUSH
17044: LD_INT 28
17046: PUSH
17047: LD_INT 29
17049: PUSH
17050: LD_INT 30
17052: PUSH
17053: LD_INT 31
17055: PUSH
17056: LD_INT 37
17058: PUSH
17059: LD_INT 38
17061: PUSH
17062: LD_INT 32
17064: PUSH
17065: LD_INT 27
17067: PUSH
17068: LD_INT 33
17070: PUSH
17071: LD_INT 69
17073: PUSH
17074: LD_INT 39
17076: PUSH
17077: LD_INT 34
17079: PUSH
17080: LD_INT 40
17082: PUSH
17083: LD_INT 71
17085: PUSH
17086: LD_INT 23
17088: PUSH
17089: LD_INT 44
17091: PUSH
17092: LD_INT 48
17094: PUSH
17095: LD_INT 49
17097: PUSH
17098: LD_INT 50
17100: PUSH
17101: LD_INT 51
17103: PUSH
17104: LD_INT 52
17106: PUSH
17107: LD_INT 53
17109: PUSH
17110: LD_INT 54
17112: PUSH
17113: LD_INT 55
17115: PUSH
17116: LD_INT 56
17118: PUSH
17119: LD_INT 57
17121: PUSH
17122: LD_INT 58
17124: PUSH
17125: LD_INT 59
17127: PUSH
17128: LD_INT 63
17130: PUSH
17131: LD_INT 64
17133: PUSH
17134: LD_INT 65
17136: PUSH
17137: LD_INT 82
17139: PUSH
17140: LD_INT 83
17142: PUSH
17143: LD_INT 84
17145: PUSH
17146: LD_INT 85
17148: PUSH
17149: LD_INT 86
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: LIST
17156: LIST
17157: LIST
17158: LIST
17159: LIST
17160: LIST
17161: LIST
17162: LIST
17163: LIST
17164: LIST
17165: LIST
17166: LIST
17167: LIST
17168: LIST
17169: LIST
17170: LIST
17171: LIST
17172: LIST
17173: LIST
17174: LIST
17175: LIST
17176: LIST
17177: LIST
17178: LIST
17179: LIST
17180: LIST
17181: LIST
17182: LIST
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: LIST
17188: LIST
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: LIST
17194: LIST
17195: LIST
17196: LIST
17197: LIST
17198: LIST
17199: LIST
17200: LIST
17201: LIST
17202: LIST
17203: LIST
17204: LIST
17205: LIST
17206: ST_TO_ADDR
17207: GO 17210
17209: POP
// if state > - 1 and state < 3 then
17210: LD_VAR 0 3
17214: PUSH
17215: LD_INT 1
17217: NEG
17218: GREATER
17219: PUSH
17220: LD_VAR 0 3
17224: PUSH
17225: LD_INT 3
17227: LESS
17228: AND
17229: IFFALSE 17286
// for i in result do
17231: LD_ADDR_VAR 0 5
17235: PUSH
17236: LD_VAR 0 4
17240: PUSH
17241: FOR_IN
17242: IFFALSE 17284
// if GetTech ( i , side ) <> state then
17244: LD_VAR 0 5
17248: PPUSH
17249: LD_VAR 0 1
17253: PPUSH
17254: CALL_OW 321
17258: PUSH
17259: LD_VAR 0 3
17263: NONEQUAL
17264: IFFALSE 17282
// result := result diff i ;
17266: LD_ADDR_VAR 0 4
17270: PUSH
17271: LD_VAR 0 4
17275: PUSH
17276: LD_VAR 0 5
17280: DIFF
17281: ST_TO_ADDR
17282: GO 17241
17284: POP
17285: POP
// end ;
17286: LD_VAR 0 4
17290: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
17291: LD_INT 0
17293: PPUSH
17294: PPUSH
17295: PPUSH
// result := true ;
17296: LD_ADDR_VAR 0 3
17300: PUSH
17301: LD_INT 1
17303: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
17304: LD_ADDR_VAR 0 5
17308: PUSH
17309: LD_VAR 0 2
17313: PPUSH
17314: CALL_OW 480
17318: ST_TO_ADDR
// if not tmp then
17319: LD_VAR 0 5
17323: NOT
17324: IFFALSE 17328
// exit ;
17326: GO 17377
// for i in tmp do
17328: LD_ADDR_VAR 0 4
17332: PUSH
17333: LD_VAR 0 5
17337: PUSH
17338: FOR_IN
17339: IFFALSE 17375
// if GetTech ( i , side ) <> state_researched then
17341: LD_VAR 0 4
17345: PPUSH
17346: LD_VAR 0 1
17350: PPUSH
17351: CALL_OW 321
17355: PUSH
17356: LD_INT 2
17358: NONEQUAL
17359: IFFALSE 17373
// begin result := false ;
17361: LD_ADDR_VAR 0 3
17365: PUSH
17366: LD_INT 0
17368: ST_TO_ADDR
// exit ;
17369: POP
17370: POP
17371: GO 17377
// end ;
17373: GO 17338
17375: POP
17376: POP
// end ;
17377: LD_VAR 0 3
17381: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
17382: LD_INT 0
17384: PPUSH
17385: PPUSH
17386: PPUSH
17387: PPUSH
17388: PPUSH
17389: PPUSH
17390: PPUSH
17391: PPUSH
17392: PPUSH
17393: PPUSH
17394: PPUSH
17395: PPUSH
17396: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
17397: LD_VAR 0 1
17401: NOT
17402: PUSH
17403: LD_VAR 0 1
17407: PPUSH
17408: CALL_OW 257
17412: PUSH
17413: LD_INT 9
17415: NONEQUAL
17416: OR
17417: IFFALSE 17421
// exit ;
17419: GO 17994
// side := GetSide ( unit ) ;
17421: LD_ADDR_VAR 0 9
17425: PUSH
17426: LD_VAR 0 1
17430: PPUSH
17431: CALL_OW 255
17435: ST_TO_ADDR
// tech_space := tech_spacanom ;
17436: LD_ADDR_VAR 0 12
17440: PUSH
17441: LD_INT 29
17443: ST_TO_ADDR
// tech_time := tech_taurad ;
17444: LD_ADDR_VAR 0 13
17448: PUSH
17449: LD_INT 28
17451: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
17452: LD_ADDR_VAR 0 11
17456: PUSH
17457: LD_VAR 0 1
17461: PPUSH
17462: CALL_OW 310
17466: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
17467: LD_VAR 0 11
17471: PPUSH
17472: CALL_OW 247
17476: PUSH
17477: LD_INT 2
17479: EQUAL
17480: IFFALSE 17484
// exit ;
17482: GO 17994
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17484: LD_ADDR_VAR 0 8
17488: PUSH
17489: LD_INT 81
17491: PUSH
17492: LD_VAR 0 9
17496: PUSH
17497: EMPTY
17498: LIST
17499: LIST
17500: PUSH
17501: LD_INT 3
17503: PUSH
17504: LD_INT 21
17506: PUSH
17507: LD_INT 3
17509: PUSH
17510: EMPTY
17511: LIST
17512: LIST
17513: PUSH
17514: EMPTY
17515: LIST
17516: LIST
17517: PUSH
17518: EMPTY
17519: LIST
17520: LIST
17521: PPUSH
17522: CALL_OW 69
17526: ST_TO_ADDR
// if not tmp then
17527: LD_VAR 0 8
17531: NOT
17532: IFFALSE 17536
// exit ;
17534: GO 17994
// if in_unit then
17536: LD_VAR 0 11
17540: IFFALSE 17564
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
17542: LD_ADDR_VAR 0 10
17546: PUSH
17547: LD_VAR 0 8
17551: PPUSH
17552: LD_VAR 0 11
17556: PPUSH
17557: CALL_OW 74
17561: ST_TO_ADDR
17562: GO 17584
// enemy := NearestUnitToUnit ( tmp , unit ) ;
17564: LD_ADDR_VAR 0 10
17568: PUSH
17569: LD_VAR 0 8
17573: PPUSH
17574: LD_VAR 0 1
17578: PPUSH
17579: CALL_OW 74
17583: ST_TO_ADDR
// if not enemy then
17584: LD_VAR 0 10
17588: NOT
17589: IFFALSE 17593
// exit ;
17591: GO 17994
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
17593: LD_VAR 0 11
17597: PUSH
17598: LD_VAR 0 11
17602: PPUSH
17603: LD_VAR 0 10
17607: PPUSH
17608: CALL_OW 296
17612: PUSH
17613: LD_INT 13
17615: GREATER
17616: AND
17617: PUSH
17618: LD_VAR 0 1
17622: PPUSH
17623: LD_VAR 0 10
17627: PPUSH
17628: CALL_OW 296
17632: PUSH
17633: LD_INT 12
17635: GREATER
17636: OR
17637: IFFALSE 17641
// exit ;
17639: GO 17994
// missile := [ 1 ] ;
17641: LD_ADDR_VAR 0 14
17645: PUSH
17646: LD_INT 1
17648: PUSH
17649: EMPTY
17650: LIST
17651: ST_TO_ADDR
// if Researched ( side , tech_space ) then
17652: LD_VAR 0 9
17656: PPUSH
17657: LD_VAR 0 12
17661: PPUSH
17662: CALL_OW 325
17666: IFFALSE 17695
// missile := Replace ( missile , missile + 1 , 2 ) ;
17668: LD_ADDR_VAR 0 14
17672: PUSH
17673: LD_VAR 0 14
17677: PPUSH
17678: LD_VAR 0 14
17682: PUSH
17683: LD_INT 1
17685: PLUS
17686: PPUSH
17687: LD_INT 2
17689: PPUSH
17690: CALL_OW 1
17694: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
17695: LD_VAR 0 9
17699: PPUSH
17700: LD_VAR 0 13
17704: PPUSH
17705: CALL_OW 325
17709: PUSH
17710: LD_VAR 0 10
17714: PPUSH
17715: CALL_OW 255
17719: PPUSH
17720: LD_VAR 0 13
17724: PPUSH
17725: CALL_OW 325
17729: NOT
17730: AND
17731: IFFALSE 17760
// missile := Replace ( missile , missile + 1 , 3 ) ;
17733: LD_ADDR_VAR 0 14
17737: PUSH
17738: LD_VAR 0 14
17742: PPUSH
17743: LD_VAR 0 14
17747: PUSH
17748: LD_INT 1
17750: PLUS
17751: PPUSH
17752: LD_INT 3
17754: PPUSH
17755: CALL_OW 1
17759: ST_TO_ADDR
// if missile < 2 then
17760: LD_VAR 0 14
17764: PUSH
17765: LD_INT 2
17767: LESS
17768: IFFALSE 17772
// exit ;
17770: GO 17994
// x := GetX ( enemy ) ;
17772: LD_ADDR_VAR 0 4
17776: PUSH
17777: LD_VAR 0 10
17781: PPUSH
17782: CALL_OW 250
17786: ST_TO_ADDR
// y := GetY ( enemy ) ;
17787: LD_ADDR_VAR 0 5
17791: PUSH
17792: LD_VAR 0 10
17796: PPUSH
17797: CALL_OW 251
17801: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
17802: LD_ADDR_VAR 0 6
17806: PUSH
17807: LD_VAR 0 4
17811: PUSH
17812: LD_INT 1
17814: NEG
17815: PPUSH
17816: LD_INT 1
17818: PPUSH
17819: CALL_OW 12
17823: PLUS
17824: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
17825: LD_ADDR_VAR 0 7
17829: PUSH
17830: LD_VAR 0 5
17834: PUSH
17835: LD_INT 1
17837: NEG
17838: PPUSH
17839: LD_INT 1
17841: PPUSH
17842: CALL_OW 12
17846: PLUS
17847: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
17848: LD_VAR 0 6
17852: PPUSH
17853: LD_VAR 0 7
17857: PPUSH
17858: CALL_OW 488
17862: NOT
17863: IFFALSE 17885
// begin _x := x ;
17865: LD_ADDR_VAR 0 6
17869: PUSH
17870: LD_VAR 0 4
17874: ST_TO_ADDR
// _y := y ;
17875: LD_ADDR_VAR 0 7
17879: PUSH
17880: LD_VAR 0 5
17884: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
17885: LD_ADDR_VAR 0 3
17889: PUSH
17890: LD_INT 1
17892: PPUSH
17893: LD_VAR 0 14
17897: PPUSH
17898: CALL_OW 12
17902: ST_TO_ADDR
// case i of 1 :
17903: LD_VAR 0 3
17907: PUSH
17908: LD_INT 1
17910: DOUBLE
17911: EQUAL
17912: IFTRUE 17916
17914: GO 17933
17916: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
17917: LD_VAR 0 1
17921: PPUSH
17922: LD_VAR 0 10
17926: PPUSH
17927: CALL_OW 115
17931: GO 17994
17933: LD_INT 2
17935: DOUBLE
17936: EQUAL
17937: IFTRUE 17941
17939: GO 17963
17941: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
17942: LD_VAR 0 1
17946: PPUSH
17947: LD_VAR 0 6
17951: PPUSH
17952: LD_VAR 0 7
17956: PPUSH
17957: CALL_OW 153
17961: GO 17994
17963: LD_INT 3
17965: DOUBLE
17966: EQUAL
17967: IFTRUE 17971
17969: GO 17993
17971: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
17972: LD_VAR 0 1
17976: PPUSH
17977: LD_VAR 0 6
17981: PPUSH
17982: LD_VAR 0 7
17986: PPUSH
17987: CALL_OW 154
17991: GO 17994
17993: POP
// end ;
17994: LD_VAR 0 2
17998: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
17999: LD_INT 0
18001: PPUSH
18002: PPUSH
18003: PPUSH
18004: PPUSH
18005: PPUSH
18006: PPUSH
// if not unit or not building then
18007: LD_VAR 0 1
18011: NOT
18012: PUSH
18013: LD_VAR 0 2
18017: NOT
18018: OR
18019: IFFALSE 18023
// exit ;
18021: GO 18181
// x := GetX ( building ) ;
18023: LD_ADDR_VAR 0 5
18027: PUSH
18028: LD_VAR 0 2
18032: PPUSH
18033: CALL_OW 250
18037: ST_TO_ADDR
// y := GetY ( building ) ;
18038: LD_ADDR_VAR 0 6
18042: PUSH
18043: LD_VAR 0 2
18047: PPUSH
18048: CALL_OW 251
18052: ST_TO_ADDR
// for i = 0 to 5 do
18053: LD_ADDR_VAR 0 4
18057: PUSH
18058: DOUBLE
18059: LD_INT 0
18061: DEC
18062: ST_TO_ADDR
18063: LD_INT 5
18065: PUSH
18066: FOR_TO
18067: IFFALSE 18179
// begin _x := ShiftX ( x , i , 3 ) ;
18069: LD_ADDR_VAR 0 7
18073: PUSH
18074: LD_VAR 0 5
18078: PPUSH
18079: LD_VAR 0 4
18083: PPUSH
18084: LD_INT 3
18086: PPUSH
18087: CALL_OW 272
18091: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
18092: LD_ADDR_VAR 0 8
18096: PUSH
18097: LD_VAR 0 6
18101: PPUSH
18102: LD_VAR 0 4
18106: PPUSH
18107: LD_INT 3
18109: PPUSH
18110: CALL_OW 273
18114: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
18115: LD_VAR 0 7
18119: PPUSH
18120: LD_VAR 0 8
18124: PPUSH
18125: CALL_OW 488
18129: NOT
18130: IFFALSE 18134
// continue ;
18132: GO 18066
// if HexInfo ( _x , _y ) = 0 then
18134: LD_VAR 0 7
18138: PPUSH
18139: LD_VAR 0 8
18143: PPUSH
18144: CALL_OW 428
18148: PUSH
18149: LD_INT 0
18151: EQUAL
18152: IFFALSE 18177
// begin ComMoveXY ( unit , _x , _y ) ;
18154: LD_VAR 0 1
18158: PPUSH
18159: LD_VAR 0 7
18163: PPUSH
18164: LD_VAR 0 8
18168: PPUSH
18169: CALL_OW 111
// exit ;
18173: POP
18174: POP
18175: GO 18181
// end ; end ;
18177: GO 18066
18179: POP
18180: POP
// end ;
18181: LD_VAR 0 3
18185: RET
// export function ScanBase ( side , base_area ) ; begin
18186: LD_INT 0
18188: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
18189: LD_ADDR_VAR 0 3
18193: PUSH
18194: LD_VAR 0 2
18198: PPUSH
18199: LD_INT 81
18201: PUSH
18202: LD_VAR 0 1
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: PPUSH
18211: CALL_OW 70
18215: ST_TO_ADDR
// end ;
18216: LD_VAR 0 3
18220: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
18221: LD_INT 0
18223: PPUSH
18224: PPUSH
18225: PPUSH
18226: PPUSH
// result := false ;
18227: LD_ADDR_VAR 0 2
18231: PUSH
18232: LD_INT 0
18234: ST_TO_ADDR
// side := GetSide ( unit ) ;
18235: LD_ADDR_VAR 0 3
18239: PUSH
18240: LD_VAR 0 1
18244: PPUSH
18245: CALL_OW 255
18249: ST_TO_ADDR
// nat := GetNation ( unit ) ;
18250: LD_ADDR_VAR 0 4
18254: PUSH
18255: LD_VAR 0 1
18259: PPUSH
18260: CALL_OW 248
18264: ST_TO_ADDR
// case nat of 1 :
18265: LD_VAR 0 4
18269: PUSH
18270: LD_INT 1
18272: DOUBLE
18273: EQUAL
18274: IFTRUE 18278
18276: GO 18289
18278: POP
// tech := tech_lassight ; 2 :
18279: LD_ADDR_VAR 0 5
18283: PUSH
18284: LD_INT 12
18286: ST_TO_ADDR
18287: GO 18328
18289: LD_INT 2
18291: DOUBLE
18292: EQUAL
18293: IFTRUE 18297
18295: GO 18308
18297: POP
// tech := tech_mortar ; 3 :
18298: LD_ADDR_VAR 0 5
18302: PUSH
18303: LD_INT 41
18305: ST_TO_ADDR
18306: GO 18328
18308: LD_INT 3
18310: DOUBLE
18311: EQUAL
18312: IFTRUE 18316
18314: GO 18327
18316: POP
// tech := tech_bazooka ; end ;
18317: LD_ADDR_VAR 0 5
18321: PUSH
18322: LD_INT 44
18324: ST_TO_ADDR
18325: GO 18328
18327: POP
// if Researched ( side , tech ) then
18328: LD_VAR 0 3
18332: PPUSH
18333: LD_VAR 0 5
18337: PPUSH
18338: CALL_OW 325
18342: IFFALSE 18369
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18344: LD_ADDR_VAR 0 2
18348: PUSH
18349: LD_INT 5
18351: PUSH
18352: LD_INT 8
18354: PUSH
18355: LD_INT 9
18357: PUSH
18358: EMPTY
18359: LIST
18360: LIST
18361: LIST
18362: PUSH
18363: LD_VAR 0 4
18367: ARRAY
18368: ST_TO_ADDR
// end ;
18369: LD_VAR 0 2
18373: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18374: LD_INT 0
18376: PPUSH
18377: PPUSH
18378: PPUSH
// if not mines then
18379: LD_VAR 0 2
18383: NOT
18384: IFFALSE 18388
// exit ;
18386: GO 18532
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18388: LD_ADDR_VAR 0 5
18392: PUSH
18393: LD_INT 81
18395: PUSH
18396: LD_VAR 0 1
18400: PUSH
18401: EMPTY
18402: LIST
18403: LIST
18404: PUSH
18405: LD_INT 3
18407: PUSH
18408: LD_INT 21
18410: PUSH
18411: LD_INT 3
18413: PUSH
18414: EMPTY
18415: LIST
18416: LIST
18417: PUSH
18418: EMPTY
18419: LIST
18420: LIST
18421: PUSH
18422: EMPTY
18423: LIST
18424: LIST
18425: PPUSH
18426: CALL_OW 69
18430: ST_TO_ADDR
// for i in mines do
18431: LD_ADDR_VAR 0 4
18435: PUSH
18436: LD_VAR 0 2
18440: PUSH
18441: FOR_IN
18442: IFFALSE 18530
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18444: LD_VAR 0 4
18448: PUSH
18449: LD_INT 1
18451: ARRAY
18452: PPUSH
18453: LD_VAR 0 4
18457: PUSH
18458: LD_INT 2
18460: ARRAY
18461: PPUSH
18462: CALL_OW 458
18466: NOT
18467: IFFALSE 18471
// continue ;
18469: GO 18441
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18471: LD_VAR 0 4
18475: PUSH
18476: LD_INT 1
18478: ARRAY
18479: PPUSH
18480: LD_VAR 0 4
18484: PUSH
18485: LD_INT 2
18487: ARRAY
18488: PPUSH
18489: CALL_OW 428
18493: PUSH
18494: LD_VAR 0 5
18498: IN
18499: IFFALSE 18528
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18501: LD_VAR 0 4
18505: PUSH
18506: LD_INT 1
18508: ARRAY
18509: PPUSH
18510: LD_VAR 0 4
18514: PUSH
18515: LD_INT 2
18517: ARRAY
18518: PPUSH
18519: LD_VAR 0 1
18523: PPUSH
18524: CALL_OW 456
// end ;
18528: GO 18441
18530: POP
18531: POP
// end ;
18532: LD_VAR 0 3
18536: RET
// export function Count ( array ) ; begin
18537: LD_INT 0
18539: PPUSH
// result := array + 0 ;
18540: LD_ADDR_VAR 0 2
18544: PUSH
18545: LD_VAR 0 1
18549: PUSH
18550: LD_INT 0
18552: PLUS
18553: ST_TO_ADDR
// end ;
18554: LD_VAR 0 2
18558: RET
// export function IsEmpty ( building ) ; begin
18559: LD_INT 0
18561: PPUSH
// if not building then
18562: LD_VAR 0 1
18566: NOT
18567: IFFALSE 18571
// exit ;
18569: GO 18614
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18571: LD_ADDR_VAR 0 2
18575: PUSH
18576: LD_VAR 0 1
18580: PUSH
18581: LD_INT 22
18583: PUSH
18584: LD_VAR 0 1
18588: PPUSH
18589: CALL_OW 255
18593: PUSH
18594: EMPTY
18595: LIST
18596: LIST
18597: PUSH
18598: LD_INT 58
18600: PUSH
18601: EMPTY
18602: LIST
18603: PUSH
18604: EMPTY
18605: LIST
18606: LIST
18607: PPUSH
18608: CALL_OW 69
18612: IN
18613: ST_TO_ADDR
// end ;
18614: LD_VAR 0 2
18618: RET
// export function IsNotFull ( building ) ; var places ; begin
18619: LD_INT 0
18621: PPUSH
18622: PPUSH
// if not building then
18623: LD_VAR 0 1
18627: NOT
18628: IFFALSE 18632
// exit ;
18630: GO 18660
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
18632: LD_ADDR_VAR 0 2
18636: PUSH
18637: LD_VAR 0 1
18641: PPUSH
18642: LD_INT 3
18644: PUSH
18645: LD_INT 62
18647: PUSH
18648: EMPTY
18649: LIST
18650: PUSH
18651: EMPTY
18652: LIST
18653: LIST
18654: PPUSH
18655: CALL_OW 72
18659: ST_TO_ADDR
// end ;
18660: LD_VAR 0 2
18664: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18665: LD_INT 0
18667: PPUSH
18668: PPUSH
18669: PPUSH
18670: PPUSH
// tmp := [ ] ;
18671: LD_ADDR_VAR 0 3
18675: PUSH
18676: EMPTY
18677: ST_TO_ADDR
// list := [ ] ;
18678: LD_ADDR_VAR 0 5
18682: PUSH
18683: EMPTY
18684: ST_TO_ADDR
// for i = 16 to 25 do
18685: LD_ADDR_VAR 0 4
18689: PUSH
18690: DOUBLE
18691: LD_INT 16
18693: DEC
18694: ST_TO_ADDR
18695: LD_INT 25
18697: PUSH
18698: FOR_TO
18699: IFFALSE 18772
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18701: LD_ADDR_VAR 0 3
18705: PUSH
18706: LD_VAR 0 3
18710: PUSH
18711: LD_INT 22
18713: PUSH
18714: LD_VAR 0 1
18718: PPUSH
18719: CALL_OW 255
18723: PUSH
18724: EMPTY
18725: LIST
18726: LIST
18727: PUSH
18728: LD_INT 91
18730: PUSH
18731: LD_VAR 0 1
18735: PUSH
18736: LD_INT 6
18738: PUSH
18739: EMPTY
18740: LIST
18741: LIST
18742: LIST
18743: PUSH
18744: LD_INT 30
18746: PUSH
18747: LD_VAR 0 4
18751: PUSH
18752: EMPTY
18753: LIST
18754: LIST
18755: PUSH
18756: EMPTY
18757: LIST
18758: LIST
18759: LIST
18760: PUSH
18761: EMPTY
18762: LIST
18763: PPUSH
18764: CALL_OW 69
18768: ADD
18769: ST_TO_ADDR
18770: GO 18698
18772: POP
18773: POP
// for i = 1 to tmp do
18774: LD_ADDR_VAR 0 4
18778: PUSH
18779: DOUBLE
18780: LD_INT 1
18782: DEC
18783: ST_TO_ADDR
18784: LD_VAR 0 3
18788: PUSH
18789: FOR_TO
18790: IFFALSE 18878
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18792: LD_ADDR_VAR 0 5
18796: PUSH
18797: LD_VAR 0 5
18801: PUSH
18802: LD_VAR 0 3
18806: PUSH
18807: LD_VAR 0 4
18811: ARRAY
18812: PPUSH
18813: CALL_OW 266
18817: PUSH
18818: LD_VAR 0 3
18822: PUSH
18823: LD_VAR 0 4
18827: ARRAY
18828: PPUSH
18829: CALL_OW 250
18833: PUSH
18834: LD_VAR 0 3
18838: PUSH
18839: LD_VAR 0 4
18843: ARRAY
18844: PPUSH
18845: CALL_OW 251
18849: PUSH
18850: LD_VAR 0 3
18854: PUSH
18855: LD_VAR 0 4
18859: ARRAY
18860: PPUSH
18861: CALL_OW 254
18865: PUSH
18866: EMPTY
18867: LIST
18868: LIST
18869: LIST
18870: LIST
18871: PUSH
18872: EMPTY
18873: LIST
18874: ADD
18875: ST_TO_ADDR
18876: GO 18789
18878: POP
18879: POP
// result := list ;
18880: LD_ADDR_VAR 0 2
18884: PUSH
18885: LD_VAR 0 5
18889: ST_TO_ADDR
// end ;
18890: LD_VAR 0 2
18894: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18895: LD_INT 0
18897: PPUSH
18898: PPUSH
18899: PPUSH
18900: PPUSH
18901: PPUSH
18902: PPUSH
18903: PPUSH
// if not factory then
18904: LD_VAR 0 1
18908: NOT
18909: IFFALSE 18913
// exit ;
18911: GO 19506
// if control = control_apeman then
18913: LD_VAR 0 4
18917: PUSH
18918: LD_INT 5
18920: EQUAL
18921: IFFALSE 19030
// begin tmp := UnitsInside ( factory ) ;
18923: LD_ADDR_VAR 0 8
18927: PUSH
18928: LD_VAR 0 1
18932: PPUSH
18933: CALL_OW 313
18937: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18938: LD_VAR 0 8
18942: PPUSH
18943: LD_INT 25
18945: PUSH
18946: LD_INT 12
18948: PUSH
18949: EMPTY
18950: LIST
18951: LIST
18952: PPUSH
18953: CALL_OW 72
18957: NOT
18958: IFFALSE 18968
// control := control_manual ;
18960: LD_ADDR_VAR 0 4
18964: PUSH
18965: LD_INT 1
18967: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18968: LD_ADDR_VAR 0 8
18972: PUSH
18973: LD_VAR 0 1
18977: PPUSH
18978: CALL 18665 0 1
18982: ST_TO_ADDR
// if tmp then
18983: LD_VAR 0 8
18987: IFFALSE 19030
// begin for i in tmp do
18989: LD_ADDR_VAR 0 7
18993: PUSH
18994: LD_VAR 0 8
18998: PUSH
18999: FOR_IN
19000: IFFALSE 19028
// if i [ 1 ] = b_ext_radio then
19002: LD_VAR 0 7
19006: PUSH
19007: LD_INT 1
19009: ARRAY
19010: PUSH
19011: LD_INT 22
19013: EQUAL
19014: IFFALSE 19026
// begin control := control_remote ;
19016: LD_ADDR_VAR 0 4
19020: PUSH
19021: LD_INT 2
19023: ST_TO_ADDR
// break ;
19024: GO 19028
// end ;
19026: GO 18999
19028: POP
19029: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19030: LD_VAR 0 1
19034: PPUSH
19035: LD_VAR 0 2
19039: PPUSH
19040: LD_VAR 0 3
19044: PPUSH
19045: LD_VAR 0 4
19049: PPUSH
19050: LD_VAR 0 5
19054: PPUSH
19055: CALL_OW 448
19059: IFFALSE 19094
// begin result := [ chassis , engine , control , weapon ] ;
19061: LD_ADDR_VAR 0 6
19065: PUSH
19066: LD_VAR 0 2
19070: PUSH
19071: LD_VAR 0 3
19075: PUSH
19076: LD_VAR 0 4
19080: PUSH
19081: LD_VAR 0 5
19085: PUSH
19086: EMPTY
19087: LIST
19088: LIST
19089: LIST
19090: LIST
19091: ST_TO_ADDR
// exit ;
19092: GO 19506
// end ; _chassis := AvailableChassisList ( factory ) ;
19094: LD_ADDR_VAR 0 9
19098: PUSH
19099: LD_VAR 0 1
19103: PPUSH
19104: CALL_OW 475
19108: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
19109: LD_ADDR_VAR 0 11
19113: PUSH
19114: LD_VAR 0 1
19118: PPUSH
19119: CALL_OW 476
19123: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
19124: LD_ADDR_VAR 0 12
19128: PUSH
19129: LD_VAR 0 1
19133: PPUSH
19134: CALL_OW 477
19138: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
19139: LD_ADDR_VAR 0 10
19143: PUSH
19144: LD_VAR 0 1
19148: PPUSH
19149: CALL_OW 478
19153: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
19154: LD_VAR 0 9
19158: NOT
19159: PUSH
19160: LD_VAR 0 11
19164: NOT
19165: OR
19166: PUSH
19167: LD_VAR 0 12
19171: NOT
19172: OR
19173: PUSH
19174: LD_VAR 0 10
19178: NOT
19179: OR
19180: IFFALSE 19215
// begin result := [ chassis , engine , control , weapon ] ;
19182: LD_ADDR_VAR 0 6
19186: PUSH
19187: LD_VAR 0 2
19191: PUSH
19192: LD_VAR 0 3
19196: PUSH
19197: LD_VAR 0 4
19201: PUSH
19202: LD_VAR 0 5
19206: PUSH
19207: EMPTY
19208: LIST
19209: LIST
19210: LIST
19211: LIST
19212: ST_TO_ADDR
// exit ;
19213: GO 19506
// end ; if not chassis in _chassis then
19215: LD_VAR 0 2
19219: PUSH
19220: LD_VAR 0 9
19224: IN
19225: NOT
19226: IFFALSE 19252
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
19228: LD_ADDR_VAR 0 2
19232: PUSH
19233: LD_VAR 0 9
19237: PUSH
19238: LD_INT 1
19240: PPUSH
19241: LD_VAR 0 9
19245: PPUSH
19246: CALL_OW 12
19250: ARRAY
19251: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
19252: LD_VAR 0 2
19256: PPUSH
19257: LD_VAR 0 3
19261: PPUSH
19262: CALL 19511 0 2
19266: NOT
19267: IFFALSE 19326
// repeat engine := _engine [ 1 ] ;
19269: LD_ADDR_VAR 0 3
19273: PUSH
19274: LD_VAR 0 11
19278: PUSH
19279: LD_INT 1
19281: ARRAY
19282: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
19283: LD_ADDR_VAR 0 11
19287: PUSH
19288: LD_VAR 0 11
19292: PPUSH
19293: LD_INT 1
19295: PPUSH
19296: CALL_OW 3
19300: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
19301: LD_VAR 0 2
19305: PPUSH
19306: LD_VAR 0 3
19310: PPUSH
19311: CALL 19511 0 2
19315: PUSH
19316: LD_VAR 0 11
19320: PUSH
19321: EMPTY
19322: EQUAL
19323: OR
19324: IFFALSE 19269
// if not control in _control then
19326: LD_VAR 0 4
19330: PUSH
19331: LD_VAR 0 12
19335: IN
19336: NOT
19337: IFFALSE 19363
// control := _control [ rand ( 1 , _control ) ] ;
19339: LD_ADDR_VAR 0 4
19343: PUSH
19344: LD_VAR 0 12
19348: PUSH
19349: LD_INT 1
19351: PPUSH
19352: LD_VAR 0 12
19356: PPUSH
19357: CALL_OW 12
19361: ARRAY
19362: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19363: LD_VAR 0 2
19367: PPUSH
19368: LD_VAR 0 5
19372: PPUSH
19373: CALL 19731 0 2
19377: NOT
19378: IFFALSE 19437
// repeat weapon := _weapon [ 1 ] ;
19380: LD_ADDR_VAR 0 5
19384: PUSH
19385: LD_VAR 0 10
19389: PUSH
19390: LD_INT 1
19392: ARRAY
19393: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19394: LD_ADDR_VAR 0 10
19398: PUSH
19399: LD_VAR 0 10
19403: PPUSH
19404: LD_INT 1
19406: PPUSH
19407: CALL_OW 3
19411: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19412: LD_VAR 0 2
19416: PPUSH
19417: LD_VAR 0 5
19421: PPUSH
19422: CALL 19731 0 2
19426: PUSH
19427: LD_VAR 0 10
19431: PUSH
19432: EMPTY
19433: EQUAL
19434: OR
19435: IFFALSE 19380
// result := [ ] ;
19437: LD_ADDR_VAR 0 6
19441: PUSH
19442: EMPTY
19443: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19444: LD_VAR 0 1
19448: PPUSH
19449: LD_VAR 0 2
19453: PPUSH
19454: LD_VAR 0 3
19458: PPUSH
19459: LD_VAR 0 4
19463: PPUSH
19464: LD_VAR 0 5
19468: PPUSH
19469: CALL_OW 448
19473: IFFALSE 19506
// result := [ chassis , engine , control , weapon ] ;
19475: LD_ADDR_VAR 0 6
19479: PUSH
19480: LD_VAR 0 2
19484: PUSH
19485: LD_VAR 0 3
19489: PUSH
19490: LD_VAR 0 4
19494: PUSH
19495: LD_VAR 0 5
19499: PUSH
19500: EMPTY
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: ST_TO_ADDR
// end ;
19506: LD_VAR 0 6
19510: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19511: LD_INT 0
19513: PPUSH
// if not chassis or not engine then
19514: LD_VAR 0 1
19518: NOT
19519: PUSH
19520: LD_VAR 0 2
19524: NOT
19525: OR
19526: IFFALSE 19530
// exit ;
19528: GO 19726
// case engine of engine_solar :
19530: LD_VAR 0 2
19534: PUSH
19535: LD_INT 2
19537: DOUBLE
19538: EQUAL
19539: IFTRUE 19543
19541: GO 19581
19543: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19544: LD_ADDR_VAR 0 3
19548: PUSH
19549: LD_INT 11
19551: PUSH
19552: LD_INT 12
19554: PUSH
19555: LD_INT 13
19557: PUSH
19558: LD_INT 14
19560: PUSH
19561: LD_INT 1
19563: PUSH
19564: LD_INT 2
19566: PUSH
19567: LD_INT 3
19569: PUSH
19570: EMPTY
19571: LIST
19572: LIST
19573: LIST
19574: LIST
19575: LIST
19576: LIST
19577: LIST
19578: ST_TO_ADDR
19579: GO 19710
19581: LD_INT 1
19583: DOUBLE
19584: EQUAL
19585: IFTRUE 19589
19587: GO 19651
19589: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19590: LD_ADDR_VAR 0 3
19594: PUSH
19595: LD_INT 11
19597: PUSH
19598: LD_INT 12
19600: PUSH
19601: LD_INT 13
19603: PUSH
19604: LD_INT 14
19606: PUSH
19607: LD_INT 1
19609: PUSH
19610: LD_INT 2
19612: PUSH
19613: LD_INT 3
19615: PUSH
19616: LD_INT 4
19618: PUSH
19619: LD_INT 5
19621: PUSH
19622: LD_INT 21
19624: PUSH
19625: LD_INT 23
19627: PUSH
19628: LD_INT 22
19630: PUSH
19631: LD_INT 24
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: LIST
19638: LIST
19639: LIST
19640: LIST
19641: LIST
19642: LIST
19643: LIST
19644: LIST
19645: LIST
19646: LIST
19647: LIST
19648: ST_TO_ADDR
19649: GO 19710
19651: LD_INT 3
19653: DOUBLE
19654: EQUAL
19655: IFTRUE 19659
19657: GO 19709
19659: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19660: LD_ADDR_VAR 0 3
19664: PUSH
19665: LD_INT 13
19667: PUSH
19668: LD_INT 14
19670: PUSH
19671: LD_INT 2
19673: PUSH
19674: LD_INT 3
19676: PUSH
19677: LD_INT 4
19679: PUSH
19680: LD_INT 5
19682: PUSH
19683: LD_INT 21
19685: PUSH
19686: LD_INT 22
19688: PUSH
19689: LD_INT 23
19691: PUSH
19692: LD_INT 24
19694: PUSH
19695: EMPTY
19696: LIST
19697: LIST
19698: LIST
19699: LIST
19700: LIST
19701: LIST
19702: LIST
19703: LIST
19704: LIST
19705: LIST
19706: ST_TO_ADDR
19707: GO 19710
19709: POP
// result := ( chassis in result ) ;
19710: LD_ADDR_VAR 0 3
19714: PUSH
19715: LD_VAR 0 1
19719: PUSH
19720: LD_VAR 0 3
19724: IN
19725: ST_TO_ADDR
// end ;
19726: LD_VAR 0 3
19730: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19731: LD_INT 0
19733: PPUSH
// if not chassis or not weapon then
19734: LD_VAR 0 1
19738: NOT
19739: PUSH
19740: LD_VAR 0 2
19744: NOT
19745: OR
19746: IFFALSE 19750
// exit ;
19748: GO 20810
// case weapon of us_machine_gun :
19750: LD_VAR 0 2
19754: PUSH
19755: LD_INT 2
19757: DOUBLE
19758: EQUAL
19759: IFTRUE 19763
19761: GO 19793
19763: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19764: LD_ADDR_VAR 0 3
19768: PUSH
19769: LD_INT 1
19771: PUSH
19772: LD_INT 2
19774: PUSH
19775: LD_INT 3
19777: PUSH
19778: LD_INT 4
19780: PUSH
19781: LD_INT 5
19783: PUSH
19784: EMPTY
19785: LIST
19786: LIST
19787: LIST
19788: LIST
19789: LIST
19790: ST_TO_ADDR
19791: GO 20794
19793: LD_INT 3
19795: DOUBLE
19796: EQUAL
19797: IFTRUE 19801
19799: GO 19831
19801: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19802: LD_ADDR_VAR 0 3
19806: PUSH
19807: LD_INT 1
19809: PUSH
19810: LD_INT 2
19812: PUSH
19813: LD_INT 3
19815: PUSH
19816: LD_INT 4
19818: PUSH
19819: LD_INT 5
19821: PUSH
19822: EMPTY
19823: LIST
19824: LIST
19825: LIST
19826: LIST
19827: LIST
19828: ST_TO_ADDR
19829: GO 20794
19831: LD_INT 11
19833: DOUBLE
19834: EQUAL
19835: IFTRUE 19839
19837: GO 19869
19839: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19840: LD_ADDR_VAR 0 3
19844: PUSH
19845: LD_INT 1
19847: PUSH
19848: LD_INT 2
19850: PUSH
19851: LD_INT 3
19853: PUSH
19854: LD_INT 4
19856: PUSH
19857: LD_INT 5
19859: PUSH
19860: EMPTY
19861: LIST
19862: LIST
19863: LIST
19864: LIST
19865: LIST
19866: ST_TO_ADDR
19867: GO 20794
19869: LD_INT 4
19871: DOUBLE
19872: EQUAL
19873: IFTRUE 19877
19875: GO 19903
19877: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19878: LD_ADDR_VAR 0 3
19882: PUSH
19883: LD_INT 2
19885: PUSH
19886: LD_INT 3
19888: PUSH
19889: LD_INT 4
19891: PUSH
19892: LD_INT 5
19894: PUSH
19895: EMPTY
19896: LIST
19897: LIST
19898: LIST
19899: LIST
19900: ST_TO_ADDR
19901: GO 20794
19903: LD_INT 5
19905: DOUBLE
19906: EQUAL
19907: IFTRUE 19911
19909: GO 19937
19911: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19912: LD_ADDR_VAR 0 3
19916: PUSH
19917: LD_INT 2
19919: PUSH
19920: LD_INT 3
19922: PUSH
19923: LD_INT 4
19925: PUSH
19926: LD_INT 5
19928: PUSH
19929: EMPTY
19930: LIST
19931: LIST
19932: LIST
19933: LIST
19934: ST_TO_ADDR
19935: GO 20794
19937: LD_INT 9
19939: DOUBLE
19940: EQUAL
19941: IFTRUE 19945
19943: GO 19971
19945: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19946: LD_ADDR_VAR 0 3
19950: PUSH
19951: LD_INT 2
19953: PUSH
19954: LD_INT 3
19956: PUSH
19957: LD_INT 4
19959: PUSH
19960: LD_INT 5
19962: PUSH
19963: EMPTY
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: ST_TO_ADDR
19969: GO 20794
19971: LD_INT 7
19973: DOUBLE
19974: EQUAL
19975: IFTRUE 19979
19977: GO 20005
19979: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19980: LD_ADDR_VAR 0 3
19984: PUSH
19985: LD_INT 2
19987: PUSH
19988: LD_INT 3
19990: PUSH
19991: LD_INT 4
19993: PUSH
19994: LD_INT 5
19996: PUSH
19997: EMPTY
19998: LIST
19999: LIST
20000: LIST
20001: LIST
20002: ST_TO_ADDR
20003: GO 20794
20005: LD_INT 12
20007: DOUBLE
20008: EQUAL
20009: IFTRUE 20013
20011: GO 20039
20013: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
20014: LD_ADDR_VAR 0 3
20018: PUSH
20019: LD_INT 2
20021: PUSH
20022: LD_INT 3
20024: PUSH
20025: LD_INT 4
20027: PUSH
20028: LD_INT 5
20030: PUSH
20031: EMPTY
20032: LIST
20033: LIST
20034: LIST
20035: LIST
20036: ST_TO_ADDR
20037: GO 20794
20039: LD_INT 13
20041: DOUBLE
20042: EQUAL
20043: IFTRUE 20047
20045: GO 20073
20047: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
20048: LD_ADDR_VAR 0 3
20052: PUSH
20053: LD_INT 2
20055: PUSH
20056: LD_INT 3
20058: PUSH
20059: LD_INT 4
20061: PUSH
20062: LD_INT 5
20064: PUSH
20065: EMPTY
20066: LIST
20067: LIST
20068: LIST
20069: LIST
20070: ST_TO_ADDR
20071: GO 20794
20073: LD_INT 14
20075: DOUBLE
20076: EQUAL
20077: IFTRUE 20081
20079: GO 20099
20081: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
20082: LD_ADDR_VAR 0 3
20086: PUSH
20087: LD_INT 4
20089: PUSH
20090: LD_INT 5
20092: PUSH
20093: EMPTY
20094: LIST
20095: LIST
20096: ST_TO_ADDR
20097: GO 20794
20099: LD_INT 6
20101: DOUBLE
20102: EQUAL
20103: IFTRUE 20107
20105: GO 20125
20107: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
20108: LD_ADDR_VAR 0 3
20112: PUSH
20113: LD_INT 4
20115: PUSH
20116: LD_INT 5
20118: PUSH
20119: EMPTY
20120: LIST
20121: LIST
20122: ST_TO_ADDR
20123: GO 20794
20125: LD_INT 10
20127: DOUBLE
20128: EQUAL
20129: IFTRUE 20133
20131: GO 20151
20133: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
20134: LD_ADDR_VAR 0 3
20138: PUSH
20139: LD_INT 4
20141: PUSH
20142: LD_INT 5
20144: PUSH
20145: EMPTY
20146: LIST
20147: LIST
20148: ST_TO_ADDR
20149: GO 20794
20151: LD_INT 22
20153: DOUBLE
20154: EQUAL
20155: IFTRUE 20159
20157: GO 20185
20159: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
20160: LD_ADDR_VAR 0 3
20164: PUSH
20165: LD_INT 11
20167: PUSH
20168: LD_INT 12
20170: PUSH
20171: LD_INT 13
20173: PUSH
20174: LD_INT 14
20176: PUSH
20177: EMPTY
20178: LIST
20179: LIST
20180: LIST
20181: LIST
20182: ST_TO_ADDR
20183: GO 20794
20185: LD_INT 23
20187: DOUBLE
20188: EQUAL
20189: IFTRUE 20193
20191: GO 20219
20193: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
20194: LD_ADDR_VAR 0 3
20198: PUSH
20199: LD_INT 11
20201: PUSH
20202: LD_INT 12
20204: PUSH
20205: LD_INT 13
20207: PUSH
20208: LD_INT 14
20210: PUSH
20211: EMPTY
20212: LIST
20213: LIST
20214: LIST
20215: LIST
20216: ST_TO_ADDR
20217: GO 20794
20219: LD_INT 24
20221: DOUBLE
20222: EQUAL
20223: IFTRUE 20227
20225: GO 20253
20227: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
20228: LD_ADDR_VAR 0 3
20232: PUSH
20233: LD_INT 11
20235: PUSH
20236: LD_INT 12
20238: PUSH
20239: LD_INT 13
20241: PUSH
20242: LD_INT 14
20244: PUSH
20245: EMPTY
20246: LIST
20247: LIST
20248: LIST
20249: LIST
20250: ST_TO_ADDR
20251: GO 20794
20253: LD_INT 30
20255: DOUBLE
20256: EQUAL
20257: IFTRUE 20261
20259: GO 20287
20261: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
20262: LD_ADDR_VAR 0 3
20266: PUSH
20267: LD_INT 11
20269: PUSH
20270: LD_INT 12
20272: PUSH
20273: LD_INT 13
20275: PUSH
20276: LD_INT 14
20278: PUSH
20279: EMPTY
20280: LIST
20281: LIST
20282: LIST
20283: LIST
20284: ST_TO_ADDR
20285: GO 20794
20287: LD_INT 25
20289: DOUBLE
20290: EQUAL
20291: IFTRUE 20295
20293: GO 20313
20295: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
20296: LD_ADDR_VAR 0 3
20300: PUSH
20301: LD_INT 13
20303: PUSH
20304: LD_INT 14
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: ST_TO_ADDR
20311: GO 20794
20313: LD_INT 27
20315: DOUBLE
20316: EQUAL
20317: IFTRUE 20321
20319: GO 20339
20321: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
20322: LD_ADDR_VAR 0 3
20326: PUSH
20327: LD_INT 13
20329: PUSH
20330: LD_INT 14
20332: PUSH
20333: EMPTY
20334: LIST
20335: LIST
20336: ST_TO_ADDR
20337: GO 20794
20339: LD_INT 92
20341: DOUBLE
20342: EQUAL
20343: IFTRUE 20347
20345: GO 20373
20347: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20348: LD_ADDR_VAR 0 3
20352: PUSH
20353: LD_INT 11
20355: PUSH
20356: LD_INT 12
20358: PUSH
20359: LD_INT 13
20361: PUSH
20362: LD_INT 14
20364: PUSH
20365: EMPTY
20366: LIST
20367: LIST
20368: LIST
20369: LIST
20370: ST_TO_ADDR
20371: GO 20794
20373: LD_INT 28
20375: DOUBLE
20376: EQUAL
20377: IFTRUE 20381
20379: GO 20399
20381: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20382: LD_ADDR_VAR 0 3
20386: PUSH
20387: LD_INT 13
20389: PUSH
20390: LD_INT 14
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: ST_TO_ADDR
20397: GO 20794
20399: LD_INT 29
20401: DOUBLE
20402: EQUAL
20403: IFTRUE 20407
20405: GO 20425
20407: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20408: LD_ADDR_VAR 0 3
20412: PUSH
20413: LD_INT 13
20415: PUSH
20416: LD_INT 14
20418: PUSH
20419: EMPTY
20420: LIST
20421: LIST
20422: ST_TO_ADDR
20423: GO 20794
20425: LD_INT 31
20427: DOUBLE
20428: EQUAL
20429: IFTRUE 20433
20431: GO 20451
20433: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20434: LD_ADDR_VAR 0 3
20438: PUSH
20439: LD_INT 13
20441: PUSH
20442: LD_INT 14
20444: PUSH
20445: EMPTY
20446: LIST
20447: LIST
20448: ST_TO_ADDR
20449: GO 20794
20451: LD_INT 26
20453: DOUBLE
20454: EQUAL
20455: IFTRUE 20459
20457: GO 20477
20459: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20460: LD_ADDR_VAR 0 3
20464: PUSH
20465: LD_INT 13
20467: PUSH
20468: LD_INT 14
20470: PUSH
20471: EMPTY
20472: LIST
20473: LIST
20474: ST_TO_ADDR
20475: GO 20794
20477: LD_INT 42
20479: DOUBLE
20480: EQUAL
20481: IFTRUE 20485
20483: GO 20511
20485: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20486: LD_ADDR_VAR 0 3
20490: PUSH
20491: LD_INT 21
20493: PUSH
20494: LD_INT 22
20496: PUSH
20497: LD_INT 23
20499: PUSH
20500: LD_INT 24
20502: PUSH
20503: EMPTY
20504: LIST
20505: LIST
20506: LIST
20507: LIST
20508: ST_TO_ADDR
20509: GO 20794
20511: LD_INT 43
20513: DOUBLE
20514: EQUAL
20515: IFTRUE 20519
20517: GO 20545
20519: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20520: LD_ADDR_VAR 0 3
20524: PUSH
20525: LD_INT 21
20527: PUSH
20528: LD_INT 22
20530: PUSH
20531: LD_INT 23
20533: PUSH
20534: LD_INT 24
20536: PUSH
20537: EMPTY
20538: LIST
20539: LIST
20540: LIST
20541: LIST
20542: ST_TO_ADDR
20543: GO 20794
20545: LD_INT 44
20547: DOUBLE
20548: EQUAL
20549: IFTRUE 20553
20551: GO 20579
20553: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20554: LD_ADDR_VAR 0 3
20558: PUSH
20559: LD_INT 21
20561: PUSH
20562: LD_INT 22
20564: PUSH
20565: LD_INT 23
20567: PUSH
20568: LD_INT 24
20570: PUSH
20571: EMPTY
20572: LIST
20573: LIST
20574: LIST
20575: LIST
20576: ST_TO_ADDR
20577: GO 20794
20579: LD_INT 45
20581: DOUBLE
20582: EQUAL
20583: IFTRUE 20587
20585: GO 20613
20587: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20588: LD_ADDR_VAR 0 3
20592: PUSH
20593: LD_INT 21
20595: PUSH
20596: LD_INT 22
20598: PUSH
20599: LD_INT 23
20601: PUSH
20602: LD_INT 24
20604: PUSH
20605: EMPTY
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: ST_TO_ADDR
20611: GO 20794
20613: LD_INT 49
20615: DOUBLE
20616: EQUAL
20617: IFTRUE 20621
20619: GO 20647
20621: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20622: LD_ADDR_VAR 0 3
20626: PUSH
20627: LD_INT 21
20629: PUSH
20630: LD_INT 22
20632: PUSH
20633: LD_INT 23
20635: PUSH
20636: LD_INT 24
20638: PUSH
20639: EMPTY
20640: LIST
20641: LIST
20642: LIST
20643: LIST
20644: ST_TO_ADDR
20645: GO 20794
20647: LD_INT 51
20649: DOUBLE
20650: EQUAL
20651: IFTRUE 20655
20653: GO 20681
20655: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20656: LD_ADDR_VAR 0 3
20660: PUSH
20661: LD_INT 21
20663: PUSH
20664: LD_INT 22
20666: PUSH
20667: LD_INT 23
20669: PUSH
20670: LD_INT 24
20672: PUSH
20673: EMPTY
20674: LIST
20675: LIST
20676: LIST
20677: LIST
20678: ST_TO_ADDR
20679: GO 20794
20681: LD_INT 52
20683: DOUBLE
20684: EQUAL
20685: IFTRUE 20689
20687: GO 20715
20689: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20690: LD_ADDR_VAR 0 3
20694: PUSH
20695: LD_INT 21
20697: PUSH
20698: LD_INT 22
20700: PUSH
20701: LD_INT 23
20703: PUSH
20704: LD_INT 24
20706: PUSH
20707: EMPTY
20708: LIST
20709: LIST
20710: LIST
20711: LIST
20712: ST_TO_ADDR
20713: GO 20794
20715: LD_INT 53
20717: DOUBLE
20718: EQUAL
20719: IFTRUE 20723
20721: GO 20741
20723: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20724: LD_ADDR_VAR 0 3
20728: PUSH
20729: LD_INT 23
20731: PUSH
20732: LD_INT 24
20734: PUSH
20735: EMPTY
20736: LIST
20737: LIST
20738: ST_TO_ADDR
20739: GO 20794
20741: LD_INT 46
20743: DOUBLE
20744: EQUAL
20745: IFTRUE 20749
20747: GO 20767
20749: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20750: LD_ADDR_VAR 0 3
20754: PUSH
20755: LD_INT 23
20757: PUSH
20758: LD_INT 24
20760: PUSH
20761: EMPTY
20762: LIST
20763: LIST
20764: ST_TO_ADDR
20765: GO 20794
20767: LD_INT 47
20769: DOUBLE
20770: EQUAL
20771: IFTRUE 20775
20773: GO 20793
20775: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20776: LD_ADDR_VAR 0 3
20780: PUSH
20781: LD_INT 23
20783: PUSH
20784: LD_INT 24
20786: PUSH
20787: EMPTY
20788: LIST
20789: LIST
20790: ST_TO_ADDR
20791: GO 20794
20793: POP
// result := ( chassis in result ) ;
20794: LD_ADDR_VAR 0 3
20798: PUSH
20799: LD_VAR 0 1
20803: PUSH
20804: LD_VAR 0 3
20808: IN
20809: ST_TO_ADDR
// end ;
20810: LD_VAR 0 3
20814: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20815: LD_INT 0
20817: PPUSH
20818: PPUSH
20819: PPUSH
20820: PPUSH
20821: PPUSH
20822: PPUSH
20823: PPUSH
// result := array ;
20824: LD_ADDR_VAR 0 5
20828: PUSH
20829: LD_VAR 0 1
20833: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20834: LD_VAR 0 1
20838: NOT
20839: PUSH
20840: LD_VAR 0 2
20844: NOT
20845: OR
20846: PUSH
20847: LD_VAR 0 3
20851: NOT
20852: OR
20853: PUSH
20854: LD_VAR 0 2
20858: PUSH
20859: LD_VAR 0 1
20863: GREATER
20864: OR
20865: PUSH
20866: LD_VAR 0 3
20870: PUSH
20871: LD_VAR 0 1
20875: GREATER
20876: OR
20877: IFFALSE 20881
// exit ;
20879: GO 21177
// if direction then
20881: LD_VAR 0 4
20885: IFFALSE 20949
// begin d := 1 ;
20887: LD_ADDR_VAR 0 9
20891: PUSH
20892: LD_INT 1
20894: ST_TO_ADDR
// if i_from > i_to then
20895: LD_VAR 0 2
20899: PUSH
20900: LD_VAR 0 3
20904: GREATER
20905: IFFALSE 20931
// length := ( array - i_from ) + i_to else
20907: LD_ADDR_VAR 0 11
20911: PUSH
20912: LD_VAR 0 1
20916: PUSH
20917: LD_VAR 0 2
20921: MINUS
20922: PUSH
20923: LD_VAR 0 3
20927: PLUS
20928: ST_TO_ADDR
20929: GO 20947
// length := i_to - i_from ;
20931: LD_ADDR_VAR 0 11
20935: PUSH
20936: LD_VAR 0 3
20940: PUSH
20941: LD_VAR 0 2
20945: MINUS
20946: ST_TO_ADDR
// end else
20947: GO 21010
// begin d := - 1 ;
20949: LD_ADDR_VAR 0 9
20953: PUSH
20954: LD_INT 1
20956: NEG
20957: ST_TO_ADDR
// if i_from > i_to then
20958: LD_VAR 0 2
20962: PUSH
20963: LD_VAR 0 3
20967: GREATER
20968: IFFALSE 20988
// length := i_from - i_to else
20970: LD_ADDR_VAR 0 11
20974: PUSH
20975: LD_VAR 0 2
20979: PUSH
20980: LD_VAR 0 3
20984: MINUS
20985: ST_TO_ADDR
20986: GO 21010
// length := ( array - i_to ) + i_from ;
20988: LD_ADDR_VAR 0 11
20992: PUSH
20993: LD_VAR 0 1
20997: PUSH
20998: LD_VAR 0 3
21002: MINUS
21003: PUSH
21004: LD_VAR 0 2
21008: PLUS
21009: ST_TO_ADDR
// end ; if not length then
21010: LD_VAR 0 11
21014: NOT
21015: IFFALSE 21019
// exit ;
21017: GO 21177
// tmp := array ;
21019: LD_ADDR_VAR 0 10
21023: PUSH
21024: LD_VAR 0 1
21028: ST_TO_ADDR
// for i = 1 to length do
21029: LD_ADDR_VAR 0 6
21033: PUSH
21034: DOUBLE
21035: LD_INT 1
21037: DEC
21038: ST_TO_ADDR
21039: LD_VAR 0 11
21043: PUSH
21044: FOR_TO
21045: IFFALSE 21165
// begin for j = 1 to array do
21047: LD_ADDR_VAR 0 7
21051: PUSH
21052: DOUBLE
21053: LD_INT 1
21055: DEC
21056: ST_TO_ADDR
21057: LD_VAR 0 1
21061: PUSH
21062: FOR_TO
21063: IFFALSE 21151
// begin k := j + d ;
21065: LD_ADDR_VAR 0 8
21069: PUSH
21070: LD_VAR 0 7
21074: PUSH
21075: LD_VAR 0 9
21079: PLUS
21080: ST_TO_ADDR
// if k > array then
21081: LD_VAR 0 8
21085: PUSH
21086: LD_VAR 0 1
21090: GREATER
21091: IFFALSE 21101
// k := 1 ;
21093: LD_ADDR_VAR 0 8
21097: PUSH
21098: LD_INT 1
21100: ST_TO_ADDR
// if not k then
21101: LD_VAR 0 8
21105: NOT
21106: IFFALSE 21118
// k := array ;
21108: LD_ADDR_VAR 0 8
21112: PUSH
21113: LD_VAR 0 1
21117: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
21118: LD_ADDR_VAR 0 10
21122: PUSH
21123: LD_VAR 0 10
21127: PPUSH
21128: LD_VAR 0 8
21132: PPUSH
21133: LD_VAR 0 1
21137: PUSH
21138: LD_VAR 0 7
21142: ARRAY
21143: PPUSH
21144: CALL_OW 1
21148: ST_TO_ADDR
// end ;
21149: GO 21062
21151: POP
21152: POP
// array := tmp ;
21153: LD_ADDR_VAR 0 1
21157: PUSH
21158: LD_VAR 0 10
21162: ST_TO_ADDR
// end ;
21163: GO 21044
21165: POP
21166: POP
// result := array ;
21167: LD_ADDR_VAR 0 5
21171: PUSH
21172: LD_VAR 0 1
21176: ST_TO_ADDR
// end ;
21177: LD_VAR 0 5
21181: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
21182: LD_INT 0
21184: PPUSH
21185: PPUSH
// result := 0 ;
21186: LD_ADDR_VAR 0 3
21190: PUSH
21191: LD_INT 0
21193: ST_TO_ADDR
// if not array or not value in array then
21194: LD_VAR 0 1
21198: NOT
21199: PUSH
21200: LD_VAR 0 2
21204: PUSH
21205: LD_VAR 0 1
21209: IN
21210: NOT
21211: OR
21212: IFFALSE 21216
// exit ;
21214: GO 21270
// for i = 1 to array do
21216: LD_ADDR_VAR 0 4
21220: PUSH
21221: DOUBLE
21222: LD_INT 1
21224: DEC
21225: ST_TO_ADDR
21226: LD_VAR 0 1
21230: PUSH
21231: FOR_TO
21232: IFFALSE 21268
// if value = array [ i ] then
21234: LD_VAR 0 2
21238: PUSH
21239: LD_VAR 0 1
21243: PUSH
21244: LD_VAR 0 4
21248: ARRAY
21249: EQUAL
21250: IFFALSE 21266
// begin result := i ;
21252: LD_ADDR_VAR 0 3
21256: PUSH
21257: LD_VAR 0 4
21261: ST_TO_ADDR
// exit ;
21262: POP
21263: POP
21264: GO 21270
// end ;
21266: GO 21231
21268: POP
21269: POP
// end ;
21270: LD_VAR 0 3
21274: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
21275: LD_INT 0
21277: PPUSH
// vc_chassis := chassis ;
21278: LD_ADDR_OWVAR 37
21282: PUSH
21283: LD_VAR 0 1
21287: ST_TO_ADDR
// vc_engine := engine ;
21288: LD_ADDR_OWVAR 39
21292: PUSH
21293: LD_VAR 0 2
21297: ST_TO_ADDR
// vc_control := control ;
21298: LD_ADDR_OWVAR 38
21302: PUSH
21303: LD_VAR 0 3
21307: ST_TO_ADDR
// vc_weapon := weapon ;
21308: LD_ADDR_OWVAR 40
21312: PUSH
21313: LD_VAR 0 4
21317: ST_TO_ADDR
// vc_fuel_battery := fuel ;
21318: LD_ADDR_OWVAR 41
21322: PUSH
21323: LD_VAR 0 5
21327: ST_TO_ADDR
// end ;
21328: LD_VAR 0 6
21332: RET
// export function WantPlant ( unit ) ; var task ; begin
21333: LD_INT 0
21335: PPUSH
21336: PPUSH
// result := false ;
21337: LD_ADDR_VAR 0 2
21341: PUSH
21342: LD_INT 0
21344: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21345: LD_ADDR_VAR 0 3
21349: PUSH
21350: LD_VAR 0 1
21354: PPUSH
21355: CALL_OW 437
21359: ST_TO_ADDR
// if task then
21360: LD_VAR 0 3
21364: IFFALSE 21392
// if task [ 1 ] [ 1 ] = p then
21366: LD_VAR 0 3
21370: PUSH
21371: LD_INT 1
21373: ARRAY
21374: PUSH
21375: LD_INT 1
21377: ARRAY
21378: PUSH
21379: LD_STRING p
21381: EQUAL
21382: IFFALSE 21392
// result := true ;
21384: LD_ADDR_VAR 0 2
21388: PUSH
21389: LD_INT 1
21391: ST_TO_ADDR
// end ;
21392: LD_VAR 0 2
21396: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21397: LD_INT 0
21399: PPUSH
21400: PPUSH
21401: PPUSH
21402: PPUSH
// if pos < 1 then
21403: LD_VAR 0 2
21407: PUSH
21408: LD_INT 1
21410: LESS
21411: IFFALSE 21415
// exit ;
21413: GO 21718
// if pos = 1 then
21415: LD_VAR 0 2
21419: PUSH
21420: LD_INT 1
21422: EQUAL
21423: IFFALSE 21456
// result := Replace ( arr , pos [ 1 ] , value ) else
21425: LD_ADDR_VAR 0 4
21429: PUSH
21430: LD_VAR 0 1
21434: PPUSH
21435: LD_VAR 0 2
21439: PUSH
21440: LD_INT 1
21442: ARRAY
21443: PPUSH
21444: LD_VAR 0 3
21448: PPUSH
21449: CALL_OW 1
21453: ST_TO_ADDR
21454: GO 21718
// begin tmp := arr ;
21456: LD_ADDR_VAR 0 6
21460: PUSH
21461: LD_VAR 0 1
21465: ST_TO_ADDR
// s_arr := [ tmp ] ;
21466: LD_ADDR_VAR 0 7
21470: PUSH
21471: LD_VAR 0 6
21475: PUSH
21476: EMPTY
21477: LIST
21478: ST_TO_ADDR
// for i = 1 to pos - 1 do
21479: LD_ADDR_VAR 0 5
21483: PUSH
21484: DOUBLE
21485: LD_INT 1
21487: DEC
21488: ST_TO_ADDR
21489: LD_VAR 0 2
21493: PUSH
21494: LD_INT 1
21496: MINUS
21497: PUSH
21498: FOR_TO
21499: IFFALSE 21544
// begin tmp := tmp [ pos [ i ] ] ;
21501: LD_ADDR_VAR 0 6
21505: PUSH
21506: LD_VAR 0 6
21510: PUSH
21511: LD_VAR 0 2
21515: PUSH
21516: LD_VAR 0 5
21520: ARRAY
21521: ARRAY
21522: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21523: LD_ADDR_VAR 0 7
21527: PUSH
21528: LD_VAR 0 7
21532: PUSH
21533: LD_VAR 0 6
21537: PUSH
21538: EMPTY
21539: LIST
21540: ADD
21541: ST_TO_ADDR
// end ;
21542: GO 21498
21544: POP
21545: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21546: LD_ADDR_VAR 0 6
21550: PUSH
21551: LD_VAR 0 6
21555: PPUSH
21556: LD_VAR 0 2
21560: PUSH
21561: LD_VAR 0 2
21565: ARRAY
21566: PPUSH
21567: LD_VAR 0 3
21571: PPUSH
21572: CALL_OW 1
21576: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21577: LD_ADDR_VAR 0 7
21581: PUSH
21582: LD_VAR 0 7
21586: PPUSH
21587: LD_VAR 0 7
21591: PPUSH
21592: LD_VAR 0 6
21596: PPUSH
21597: CALL_OW 1
21601: ST_TO_ADDR
// for i = s_arr downto 2 do
21602: LD_ADDR_VAR 0 5
21606: PUSH
21607: DOUBLE
21608: LD_VAR 0 7
21612: INC
21613: ST_TO_ADDR
21614: LD_INT 2
21616: PUSH
21617: FOR_DOWNTO
21618: IFFALSE 21702
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21620: LD_ADDR_VAR 0 6
21624: PUSH
21625: LD_VAR 0 7
21629: PUSH
21630: LD_VAR 0 5
21634: PUSH
21635: LD_INT 1
21637: MINUS
21638: ARRAY
21639: PPUSH
21640: LD_VAR 0 2
21644: PUSH
21645: LD_VAR 0 5
21649: PUSH
21650: LD_INT 1
21652: MINUS
21653: ARRAY
21654: PPUSH
21655: LD_VAR 0 7
21659: PUSH
21660: LD_VAR 0 5
21664: ARRAY
21665: PPUSH
21666: CALL_OW 1
21670: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21671: LD_ADDR_VAR 0 7
21675: PUSH
21676: LD_VAR 0 7
21680: PPUSH
21681: LD_VAR 0 5
21685: PUSH
21686: LD_INT 1
21688: MINUS
21689: PPUSH
21690: LD_VAR 0 6
21694: PPUSH
21695: CALL_OW 1
21699: ST_TO_ADDR
// end ;
21700: GO 21617
21702: POP
21703: POP
// result := s_arr [ 1 ] ;
21704: LD_ADDR_VAR 0 4
21708: PUSH
21709: LD_VAR 0 7
21713: PUSH
21714: LD_INT 1
21716: ARRAY
21717: ST_TO_ADDR
// end ; end ;
21718: LD_VAR 0 4
21722: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21723: LD_INT 0
21725: PPUSH
21726: PPUSH
// if not list then
21727: LD_VAR 0 1
21731: NOT
21732: IFFALSE 21736
// exit ;
21734: GO 21827
// i := list [ pos1 ] ;
21736: LD_ADDR_VAR 0 5
21740: PUSH
21741: LD_VAR 0 1
21745: PUSH
21746: LD_VAR 0 2
21750: ARRAY
21751: ST_TO_ADDR
// if not i then
21752: LD_VAR 0 5
21756: NOT
21757: IFFALSE 21761
// exit ;
21759: GO 21827
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21761: LD_ADDR_VAR 0 1
21765: PUSH
21766: LD_VAR 0 1
21770: PPUSH
21771: LD_VAR 0 2
21775: PPUSH
21776: LD_VAR 0 1
21780: PUSH
21781: LD_VAR 0 3
21785: ARRAY
21786: PPUSH
21787: CALL_OW 1
21791: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21792: LD_ADDR_VAR 0 1
21796: PUSH
21797: LD_VAR 0 1
21801: PPUSH
21802: LD_VAR 0 3
21806: PPUSH
21807: LD_VAR 0 5
21811: PPUSH
21812: CALL_OW 1
21816: ST_TO_ADDR
// result := list ;
21817: LD_ADDR_VAR 0 4
21821: PUSH
21822: LD_VAR 0 1
21826: ST_TO_ADDR
// end ;
21827: LD_VAR 0 4
21831: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21832: LD_INT 0
21834: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21835: LD_ADDR_VAR 0 5
21839: PUSH
21840: LD_VAR 0 1
21844: PPUSH
21845: CALL_OW 250
21849: PPUSH
21850: LD_VAR 0 1
21854: PPUSH
21855: CALL_OW 251
21859: PPUSH
21860: LD_VAR 0 2
21864: PPUSH
21865: LD_VAR 0 3
21869: PPUSH
21870: LD_VAR 0 4
21874: PPUSH
21875: CALL 22253 0 5
21879: ST_TO_ADDR
// end ;
21880: LD_VAR 0 5
21884: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
21885: LD_INT 0
21887: PPUSH
21888: PPUSH
21889: PPUSH
21890: PPUSH
// if not list or not unit then
21891: LD_VAR 0 2
21895: NOT
21896: PUSH
21897: LD_VAR 0 1
21901: NOT
21902: OR
21903: IFFALSE 21907
// exit ;
21905: GO 22248
// result := [ ] ;
21907: LD_ADDR_VAR 0 5
21911: PUSH
21912: EMPTY
21913: ST_TO_ADDR
// for i in list do
21914: LD_ADDR_VAR 0 6
21918: PUSH
21919: LD_VAR 0 2
21923: PUSH
21924: FOR_IN
21925: IFFALSE 22143
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
21927: LD_ADDR_VAR 0 8
21931: PUSH
21932: LD_VAR 0 1
21936: PPUSH
21937: LD_VAR 0 6
21941: PUSH
21942: LD_INT 1
21944: ARRAY
21945: PPUSH
21946: LD_VAR 0 6
21950: PUSH
21951: LD_INT 2
21953: ARRAY
21954: PPUSH
21955: CALL_OW 297
21959: ST_TO_ADDR
// if not Count ( result ) then
21960: LD_VAR 0 5
21964: PPUSH
21965: CALL 18537 0 1
21969: NOT
21970: IFFALSE 22003
// begin result := Join ( result , [ i , tmp ] ) ;
21972: LD_ADDR_VAR 0 5
21976: PUSH
21977: LD_VAR 0 5
21981: PPUSH
21982: LD_VAR 0 6
21986: PUSH
21987: LD_VAR 0 8
21991: PUSH
21992: EMPTY
21993: LIST
21994: LIST
21995: PPUSH
21996: CALL 54137 0 2
22000: ST_TO_ADDR
// continue ;
22001: GO 21924
// end ; if result [ result ] [ 2 ] <= tmp then
22003: LD_VAR 0 5
22007: PUSH
22008: LD_VAR 0 5
22012: ARRAY
22013: PUSH
22014: LD_INT 2
22016: ARRAY
22017: PUSH
22018: LD_VAR 0 8
22022: LESSEQUAL
22023: IFFALSE 22056
// result := Join ( result , [ i , tmp ] ) else
22025: LD_ADDR_VAR 0 5
22029: PUSH
22030: LD_VAR 0 5
22034: PPUSH
22035: LD_VAR 0 6
22039: PUSH
22040: LD_VAR 0 8
22044: PUSH
22045: EMPTY
22046: LIST
22047: LIST
22048: PPUSH
22049: CALL 54137 0 2
22053: ST_TO_ADDR
22054: GO 22141
// begin for j := 1 to Count ( result ) do
22056: LD_ADDR_VAR 0 7
22060: PUSH
22061: DOUBLE
22062: LD_INT 1
22064: DEC
22065: ST_TO_ADDR
22066: LD_VAR 0 5
22070: PPUSH
22071: CALL 18537 0 1
22075: PUSH
22076: FOR_TO
22077: IFFALSE 22139
// begin if tmp < result [ j ] [ 2 ] then
22079: LD_VAR 0 8
22083: PUSH
22084: LD_VAR 0 5
22088: PUSH
22089: LD_VAR 0 7
22093: ARRAY
22094: PUSH
22095: LD_INT 2
22097: ARRAY
22098: LESS
22099: IFFALSE 22137
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22101: LD_ADDR_VAR 0 5
22105: PUSH
22106: LD_VAR 0 5
22110: PPUSH
22111: LD_VAR 0 7
22115: PPUSH
22116: LD_VAR 0 6
22120: PUSH
22121: LD_VAR 0 8
22125: PUSH
22126: EMPTY
22127: LIST
22128: LIST
22129: PPUSH
22130: CALL_OW 2
22134: ST_TO_ADDR
// break ;
22135: GO 22139
// end ; end ;
22137: GO 22076
22139: POP
22140: POP
// end ; end ;
22141: GO 21924
22143: POP
22144: POP
// if result and not asc then
22145: LD_VAR 0 5
22149: PUSH
22150: LD_VAR 0 3
22154: NOT
22155: AND
22156: IFFALSE 22173
// result := ReverseArray ( result ) ;
22158: LD_ADDR_VAR 0 5
22162: PUSH
22163: LD_VAR 0 5
22167: PPUSH
22168: CALL 49413 0 1
22172: ST_TO_ADDR
// tmp := [ ] ;
22173: LD_ADDR_VAR 0 8
22177: PUSH
22178: EMPTY
22179: ST_TO_ADDR
// if mode then
22180: LD_VAR 0 4
22184: IFFALSE 22248
// begin for i := 1 to result do
22186: LD_ADDR_VAR 0 6
22190: PUSH
22191: DOUBLE
22192: LD_INT 1
22194: DEC
22195: ST_TO_ADDR
22196: LD_VAR 0 5
22200: PUSH
22201: FOR_TO
22202: IFFALSE 22236
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
22204: LD_ADDR_VAR 0 8
22208: PUSH
22209: LD_VAR 0 8
22213: PPUSH
22214: LD_VAR 0 5
22218: PUSH
22219: LD_VAR 0 6
22223: ARRAY
22224: PUSH
22225: LD_INT 1
22227: ARRAY
22228: PPUSH
22229: CALL 54137 0 2
22233: ST_TO_ADDR
22234: GO 22201
22236: POP
22237: POP
// result := tmp ;
22238: LD_ADDR_VAR 0 5
22242: PUSH
22243: LD_VAR 0 8
22247: ST_TO_ADDR
// end ; end ;
22248: LD_VAR 0 5
22252: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
22253: LD_INT 0
22255: PPUSH
22256: PPUSH
22257: PPUSH
22258: PPUSH
// if not list then
22259: LD_VAR 0 3
22263: NOT
22264: IFFALSE 22268
// exit ;
22266: GO 22656
// result := [ ] ;
22268: LD_ADDR_VAR 0 6
22272: PUSH
22273: EMPTY
22274: ST_TO_ADDR
// for i in list do
22275: LD_ADDR_VAR 0 7
22279: PUSH
22280: LD_VAR 0 3
22284: PUSH
22285: FOR_IN
22286: IFFALSE 22488
// begin tmp := GetDistUnitXY ( i , x , y ) ;
22288: LD_ADDR_VAR 0 9
22292: PUSH
22293: LD_VAR 0 7
22297: PPUSH
22298: LD_VAR 0 1
22302: PPUSH
22303: LD_VAR 0 2
22307: PPUSH
22308: CALL_OW 297
22312: ST_TO_ADDR
// if not result then
22313: LD_VAR 0 6
22317: NOT
22318: IFFALSE 22344
// result := [ [ i , tmp ] ] else
22320: LD_ADDR_VAR 0 6
22324: PUSH
22325: LD_VAR 0 7
22329: PUSH
22330: LD_VAR 0 9
22334: PUSH
22335: EMPTY
22336: LIST
22337: LIST
22338: PUSH
22339: EMPTY
22340: LIST
22341: ST_TO_ADDR
22342: GO 22486
// begin if result [ result ] [ 2 ] < tmp then
22344: LD_VAR 0 6
22348: PUSH
22349: LD_VAR 0 6
22353: ARRAY
22354: PUSH
22355: LD_INT 2
22357: ARRAY
22358: PUSH
22359: LD_VAR 0 9
22363: LESS
22364: IFFALSE 22406
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
22366: LD_ADDR_VAR 0 6
22370: PUSH
22371: LD_VAR 0 6
22375: PPUSH
22376: LD_VAR 0 6
22380: PUSH
22381: LD_INT 1
22383: PLUS
22384: PPUSH
22385: LD_VAR 0 7
22389: PUSH
22390: LD_VAR 0 9
22394: PUSH
22395: EMPTY
22396: LIST
22397: LIST
22398: PPUSH
22399: CALL_OW 2
22403: ST_TO_ADDR
22404: GO 22486
// for j = 1 to result do
22406: LD_ADDR_VAR 0 8
22410: PUSH
22411: DOUBLE
22412: LD_INT 1
22414: DEC
22415: ST_TO_ADDR
22416: LD_VAR 0 6
22420: PUSH
22421: FOR_TO
22422: IFFALSE 22484
// begin if tmp < result [ j ] [ 2 ] then
22424: LD_VAR 0 9
22428: PUSH
22429: LD_VAR 0 6
22433: PUSH
22434: LD_VAR 0 8
22438: ARRAY
22439: PUSH
22440: LD_INT 2
22442: ARRAY
22443: LESS
22444: IFFALSE 22482
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22446: LD_ADDR_VAR 0 6
22450: PUSH
22451: LD_VAR 0 6
22455: PPUSH
22456: LD_VAR 0 8
22460: PPUSH
22461: LD_VAR 0 7
22465: PUSH
22466: LD_VAR 0 9
22470: PUSH
22471: EMPTY
22472: LIST
22473: LIST
22474: PPUSH
22475: CALL_OW 2
22479: ST_TO_ADDR
// break ;
22480: GO 22484
// end ; end ;
22482: GO 22421
22484: POP
22485: POP
// end ; end ;
22486: GO 22285
22488: POP
22489: POP
// if result and not asc then
22490: LD_VAR 0 6
22494: PUSH
22495: LD_VAR 0 4
22499: NOT
22500: AND
22501: IFFALSE 22576
// begin tmp := result ;
22503: LD_ADDR_VAR 0 9
22507: PUSH
22508: LD_VAR 0 6
22512: ST_TO_ADDR
// for i = tmp downto 1 do
22513: LD_ADDR_VAR 0 7
22517: PUSH
22518: DOUBLE
22519: LD_VAR 0 9
22523: INC
22524: ST_TO_ADDR
22525: LD_INT 1
22527: PUSH
22528: FOR_DOWNTO
22529: IFFALSE 22574
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
22531: LD_ADDR_VAR 0 6
22535: PUSH
22536: LD_VAR 0 6
22540: PPUSH
22541: LD_VAR 0 9
22545: PUSH
22546: LD_VAR 0 7
22550: MINUS
22551: PUSH
22552: LD_INT 1
22554: PLUS
22555: PPUSH
22556: LD_VAR 0 9
22560: PUSH
22561: LD_VAR 0 7
22565: ARRAY
22566: PPUSH
22567: CALL_OW 1
22571: ST_TO_ADDR
22572: GO 22528
22574: POP
22575: POP
// end ; tmp := [ ] ;
22576: LD_ADDR_VAR 0 9
22580: PUSH
22581: EMPTY
22582: ST_TO_ADDR
// if mode then
22583: LD_VAR 0 5
22587: IFFALSE 22656
// begin for i = 1 to result do
22589: LD_ADDR_VAR 0 7
22593: PUSH
22594: DOUBLE
22595: LD_INT 1
22597: DEC
22598: ST_TO_ADDR
22599: LD_VAR 0 6
22603: PUSH
22604: FOR_TO
22605: IFFALSE 22644
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
22607: LD_ADDR_VAR 0 9
22611: PUSH
22612: LD_VAR 0 9
22616: PPUSH
22617: LD_VAR 0 7
22621: PPUSH
22622: LD_VAR 0 6
22626: PUSH
22627: LD_VAR 0 7
22631: ARRAY
22632: PUSH
22633: LD_INT 1
22635: ARRAY
22636: PPUSH
22637: CALL_OW 1
22641: ST_TO_ADDR
22642: GO 22604
22644: POP
22645: POP
// result := tmp ;
22646: LD_ADDR_VAR 0 6
22650: PUSH
22651: LD_VAR 0 9
22655: ST_TO_ADDR
// end ; end ;
22656: LD_VAR 0 6
22660: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22661: LD_INT 0
22663: PPUSH
22664: PPUSH
22665: PPUSH
22666: PPUSH
22667: PPUSH
22668: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22669: LD_ADDR_VAR 0 5
22673: PUSH
22674: LD_INT 0
22676: PUSH
22677: LD_INT 0
22679: PUSH
22680: LD_INT 0
22682: PUSH
22683: EMPTY
22684: PUSH
22685: EMPTY
22686: LIST
22687: LIST
22688: LIST
22689: LIST
22690: ST_TO_ADDR
// if not x or not y then
22691: LD_VAR 0 2
22695: NOT
22696: PUSH
22697: LD_VAR 0 3
22701: NOT
22702: OR
22703: IFFALSE 22707
// exit ;
22705: GO 24357
// if not range then
22707: LD_VAR 0 4
22711: NOT
22712: IFFALSE 22722
// range := 10 ;
22714: LD_ADDR_VAR 0 4
22718: PUSH
22719: LD_INT 10
22721: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22722: LD_ADDR_VAR 0 8
22726: PUSH
22727: LD_INT 81
22729: PUSH
22730: LD_VAR 0 1
22734: PUSH
22735: EMPTY
22736: LIST
22737: LIST
22738: PUSH
22739: LD_INT 92
22741: PUSH
22742: LD_VAR 0 2
22746: PUSH
22747: LD_VAR 0 3
22751: PUSH
22752: LD_VAR 0 4
22756: PUSH
22757: EMPTY
22758: LIST
22759: LIST
22760: LIST
22761: LIST
22762: PUSH
22763: LD_INT 3
22765: PUSH
22766: LD_INT 21
22768: PUSH
22769: LD_INT 3
22771: PUSH
22772: EMPTY
22773: LIST
22774: LIST
22775: PUSH
22776: EMPTY
22777: LIST
22778: LIST
22779: PUSH
22780: EMPTY
22781: LIST
22782: LIST
22783: LIST
22784: PPUSH
22785: CALL_OW 69
22789: ST_TO_ADDR
// if not tmp then
22790: LD_VAR 0 8
22794: NOT
22795: IFFALSE 22799
// exit ;
22797: GO 24357
// for i in tmp do
22799: LD_ADDR_VAR 0 6
22803: PUSH
22804: LD_VAR 0 8
22808: PUSH
22809: FOR_IN
22810: IFFALSE 24332
// begin points := [ 0 , 0 , 0 ] ;
22812: LD_ADDR_VAR 0 9
22816: PUSH
22817: LD_INT 0
22819: PUSH
22820: LD_INT 0
22822: PUSH
22823: LD_INT 0
22825: PUSH
22826: EMPTY
22827: LIST
22828: LIST
22829: LIST
22830: ST_TO_ADDR
// bpoints := 1 ;
22831: LD_ADDR_VAR 0 10
22835: PUSH
22836: LD_INT 1
22838: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22839: LD_VAR 0 6
22843: PPUSH
22844: CALL_OW 247
22848: PUSH
22849: LD_INT 1
22851: DOUBLE
22852: EQUAL
22853: IFTRUE 22857
22855: GO 23435
22857: POP
// begin if GetClass ( i ) = 1 then
22858: LD_VAR 0 6
22862: PPUSH
22863: CALL_OW 257
22867: PUSH
22868: LD_INT 1
22870: EQUAL
22871: IFFALSE 22892
// points := [ 10 , 5 , 3 ] ;
22873: LD_ADDR_VAR 0 9
22877: PUSH
22878: LD_INT 10
22880: PUSH
22881: LD_INT 5
22883: PUSH
22884: LD_INT 3
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: LIST
22891: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22892: LD_VAR 0 6
22896: PPUSH
22897: CALL_OW 257
22901: PUSH
22902: LD_INT 2
22904: PUSH
22905: LD_INT 3
22907: PUSH
22908: LD_INT 4
22910: PUSH
22911: EMPTY
22912: LIST
22913: LIST
22914: LIST
22915: IN
22916: IFFALSE 22937
// points := [ 3 , 2 , 1 ] ;
22918: LD_ADDR_VAR 0 9
22922: PUSH
22923: LD_INT 3
22925: PUSH
22926: LD_INT 2
22928: PUSH
22929: LD_INT 1
22931: PUSH
22932: EMPTY
22933: LIST
22934: LIST
22935: LIST
22936: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22937: LD_VAR 0 6
22941: PPUSH
22942: CALL_OW 257
22946: PUSH
22947: LD_INT 5
22949: EQUAL
22950: IFFALSE 22971
// points := [ 130 , 5 , 2 ] ;
22952: LD_ADDR_VAR 0 9
22956: PUSH
22957: LD_INT 130
22959: PUSH
22960: LD_INT 5
22962: PUSH
22963: LD_INT 2
22965: PUSH
22966: EMPTY
22967: LIST
22968: LIST
22969: LIST
22970: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22971: LD_VAR 0 6
22975: PPUSH
22976: CALL_OW 257
22980: PUSH
22981: LD_INT 8
22983: EQUAL
22984: IFFALSE 23005
// points := [ 35 , 35 , 30 ] ;
22986: LD_ADDR_VAR 0 9
22990: PUSH
22991: LD_INT 35
22993: PUSH
22994: LD_INT 35
22996: PUSH
22997: LD_INT 30
22999: PUSH
23000: EMPTY
23001: LIST
23002: LIST
23003: LIST
23004: ST_TO_ADDR
// if GetClass ( i ) = 9 then
23005: LD_VAR 0 6
23009: PPUSH
23010: CALL_OW 257
23014: PUSH
23015: LD_INT 9
23017: EQUAL
23018: IFFALSE 23039
// points := [ 20 , 55 , 40 ] ;
23020: LD_ADDR_VAR 0 9
23024: PUSH
23025: LD_INT 20
23027: PUSH
23028: LD_INT 55
23030: PUSH
23031: LD_INT 40
23033: PUSH
23034: EMPTY
23035: LIST
23036: LIST
23037: LIST
23038: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
23039: LD_VAR 0 6
23043: PPUSH
23044: CALL_OW 257
23048: PUSH
23049: LD_INT 12
23051: PUSH
23052: LD_INT 16
23054: PUSH
23055: EMPTY
23056: LIST
23057: LIST
23058: IN
23059: IFFALSE 23080
// points := [ 5 , 3 , 2 ] ;
23061: LD_ADDR_VAR 0 9
23065: PUSH
23066: LD_INT 5
23068: PUSH
23069: LD_INT 3
23071: PUSH
23072: LD_INT 2
23074: PUSH
23075: EMPTY
23076: LIST
23077: LIST
23078: LIST
23079: ST_TO_ADDR
// if GetClass ( i ) = 17 then
23080: LD_VAR 0 6
23084: PPUSH
23085: CALL_OW 257
23089: PUSH
23090: LD_INT 17
23092: EQUAL
23093: IFFALSE 23114
// points := [ 100 , 50 , 75 ] ;
23095: LD_ADDR_VAR 0 9
23099: PUSH
23100: LD_INT 100
23102: PUSH
23103: LD_INT 50
23105: PUSH
23106: LD_INT 75
23108: PUSH
23109: EMPTY
23110: LIST
23111: LIST
23112: LIST
23113: ST_TO_ADDR
// if GetClass ( i ) = 15 then
23114: LD_VAR 0 6
23118: PPUSH
23119: CALL_OW 257
23123: PUSH
23124: LD_INT 15
23126: EQUAL
23127: IFFALSE 23148
// points := [ 10 , 5 , 3 ] ;
23129: LD_ADDR_VAR 0 9
23133: PUSH
23134: LD_INT 10
23136: PUSH
23137: LD_INT 5
23139: PUSH
23140: LD_INT 3
23142: PUSH
23143: EMPTY
23144: LIST
23145: LIST
23146: LIST
23147: ST_TO_ADDR
// if GetClass ( i ) = 14 then
23148: LD_VAR 0 6
23152: PPUSH
23153: CALL_OW 257
23157: PUSH
23158: LD_INT 14
23160: EQUAL
23161: IFFALSE 23182
// points := [ 10 , 0 , 0 ] ;
23163: LD_ADDR_VAR 0 9
23167: PUSH
23168: LD_INT 10
23170: PUSH
23171: LD_INT 0
23173: PUSH
23174: LD_INT 0
23176: PUSH
23177: EMPTY
23178: LIST
23179: LIST
23180: LIST
23181: ST_TO_ADDR
// if GetClass ( i ) = 11 then
23182: LD_VAR 0 6
23186: PPUSH
23187: CALL_OW 257
23191: PUSH
23192: LD_INT 11
23194: EQUAL
23195: IFFALSE 23216
// points := [ 30 , 10 , 5 ] ;
23197: LD_ADDR_VAR 0 9
23201: PUSH
23202: LD_INT 30
23204: PUSH
23205: LD_INT 10
23207: PUSH
23208: LD_INT 5
23210: PUSH
23211: EMPTY
23212: LIST
23213: LIST
23214: LIST
23215: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
23216: LD_VAR 0 1
23220: PPUSH
23221: LD_INT 5
23223: PPUSH
23224: CALL_OW 321
23228: PUSH
23229: LD_INT 2
23231: EQUAL
23232: IFFALSE 23249
// bpoints := bpoints * 1.8 ;
23234: LD_ADDR_VAR 0 10
23238: PUSH
23239: LD_VAR 0 10
23243: PUSH
23244: LD_REAL  1.80000000000000E+0000
23247: MUL
23248: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
23249: LD_VAR 0 6
23253: PPUSH
23254: CALL_OW 257
23258: PUSH
23259: LD_INT 1
23261: PUSH
23262: LD_INT 2
23264: PUSH
23265: LD_INT 3
23267: PUSH
23268: LD_INT 4
23270: PUSH
23271: EMPTY
23272: LIST
23273: LIST
23274: LIST
23275: LIST
23276: IN
23277: PUSH
23278: LD_VAR 0 1
23282: PPUSH
23283: LD_INT 51
23285: PPUSH
23286: CALL_OW 321
23290: PUSH
23291: LD_INT 2
23293: EQUAL
23294: AND
23295: IFFALSE 23312
// bpoints := bpoints * 1.2 ;
23297: LD_ADDR_VAR 0 10
23301: PUSH
23302: LD_VAR 0 10
23306: PUSH
23307: LD_REAL  1.20000000000000E+0000
23310: MUL
23311: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
23312: LD_VAR 0 6
23316: PPUSH
23317: CALL_OW 257
23321: PUSH
23322: LD_INT 5
23324: PUSH
23325: LD_INT 7
23327: PUSH
23328: LD_INT 9
23330: PUSH
23331: EMPTY
23332: LIST
23333: LIST
23334: LIST
23335: IN
23336: PUSH
23337: LD_VAR 0 1
23341: PPUSH
23342: LD_INT 52
23344: PPUSH
23345: CALL_OW 321
23349: PUSH
23350: LD_INT 2
23352: EQUAL
23353: AND
23354: IFFALSE 23371
// bpoints := bpoints * 1.5 ;
23356: LD_ADDR_VAR 0 10
23360: PUSH
23361: LD_VAR 0 10
23365: PUSH
23366: LD_REAL  1.50000000000000E+0000
23369: MUL
23370: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
23371: LD_VAR 0 1
23375: PPUSH
23376: LD_INT 66
23378: PPUSH
23379: CALL_OW 321
23383: PUSH
23384: LD_INT 2
23386: EQUAL
23387: IFFALSE 23404
// bpoints := bpoints * 1.1 ;
23389: LD_ADDR_VAR 0 10
23393: PUSH
23394: LD_VAR 0 10
23398: PUSH
23399: LD_REAL  1.10000000000000E+0000
23402: MUL
23403: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
23404: LD_ADDR_VAR 0 10
23408: PUSH
23409: LD_VAR 0 10
23413: PUSH
23414: LD_VAR 0 6
23418: PPUSH
23419: LD_INT 1
23421: PPUSH
23422: CALL_OW 259
23426: PUSH
23427: LD_REAL  1.15000000000000E+0000
23430: MUL
23431: MUL
23432: ST_TO_ADDR
// end ; unit_vehicle :
23433: GO 24261
23435: LD_INT 2
23437: DOUBLE
23438: EQUAL
23439: IFTRUE 23443
23441: GO 24249
23443: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
23444: LD_VAR 0 6
23448: PPUSH
23449: CALL_OW 264
23453: PUSH
23454: LD_INT 2
23456: PUSH
23457: LD_INT 42
23459: PUSH
23460: LD_INT 24
23462: PUSH
23463: EMPTY
23464: LIST
23465: LIST
23466: LIST
23467: IN
23468: IFFALSE 23489
// points := [ 25 , 5 , 3 ] ;
23470: LD_ADDR_VAR 0 9
23474: PUSH
23475: LD_INT 25
23477: PUSH
23478: LD_INT 5
23480: PUSH
23481: LD_INT 3
23483: PUSH
23484: EMPTY
23485: LIST
23486: LIST
23487: LIST
23488: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
23489: LD_VAR 0 6
23493: PPUSH
23494: CALL_OW 264
23498: PUSH
23499: LD_INT 4
23501: PUSH
23502: LD_INT 43
23504: PUSH
23505: LD_INT 25
23507: PUSH
23508: EMPTY
23509: LIST
23510: LIST
23511: LIST
23512: IN
23513: IFFALSE 23534
// points := [ 40 , 15 , 5 ] ;
23515: LD_ADDR_VAR 0 9
23519: PUSH
23520: LD_INT 40
23522: PUSH
23523: LD_INT 15
23525: PUSH
23526: LD_INT 5
23528: PUSH
23529: EMPTY
23530: LIST
23531: LIST
23532: LIST
23533: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
23534: LD_VAR 0 6
23538: PPUSH
23539: CALL_OW 264
23543: PUSH
23544: LD_INT 3
23546: PUSH
23547: LD_INT 23
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: IN
23554: IFFALSE 23575
// points := [ 7 , 25 , 8 ] ;
23556: LD_ADDR_VAR 0 9
23560: PUSH
23561: LD_INT 7
23563: PUSH
23564: LD_INT 25
23566: PUSH
23567: LD_INT 8
23569: PUSH
23570: EMPTY
23571: LIST
23572: LIST
23573: LIST
23574: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
23575: LD_VAR 0 6
23579: PPUSH
23580: CALL_OW 264
23584: PUSH
23585: LD_INT 5
23587: PUSH
23588: LD_INT 27
23590: PUSH
23591: LD_INT 44
23593: PUSH
23594: EMPTY
23595: LIST
23596: LIST
23597: LIST
23598: IN
23599: IFFALSE 23620
// points := [ 14 , 50 , 16 ] ;
23601: LD_ADDR_VAR 0 9
23605: PUSH
23606: LD_INT 14
23608: PUSH
23609: LD_INT 50
23611: PUSH
23612: LD_INT 16
23614: PUSH
23615: EMPTY
23616: LIST
23617: LIST
23618: LIST
23619: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23620: LD_VAR 0 6
23624: PPUSH
23625: CALL_OW 264
23629: PUSH
23630: LD_INT 6
23632: PUSH
23633: LD_INT 46
23635: PUSH
23636: EMPTY
23637: LIST
23638: LIST
23639: IN
23640: IFFALSE 23661
// points := [ 32 , 120 , 70 ] ;
23642: LD_ADDR_VAR 0 9
23646: PUSH
23647: LD_INT 32
23649: PUSH
23650: LD_INT 120
23652: PUSH
23653: LD_INT 70
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: LIST
23660: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
23661: LD_VAR 0 6
23665: PPUSH
23666: CALL_OW 264
23670: PUSH
23671: LD_INT 7
23673: PUSH
23674: LD_INT 28
23676: PUSH
23677: LD_INT 45
23679: PUSH
23680: LD_INT 92
23682: PUSH
23683: EMPTY
23684: LIST
23685: LIST
23686: LIST
23687: LIST
23688: IN
23689: IFFALSE 23710
// points := [ 35 , 20 , 45 ] ;
23691: LD_ADDR_VAR 0 9
23695: PUSH
23696: LD_INT 35
23698: PUSH
23699: LD_INT 20
23701: PUSH
23702: LD_INT 45
23704: PUSH
23705: EMPTY
23706: LIST
23707: LIST
23708: LIST
23709: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23710: LD_VAR 0 6
23714: PPUSH
23715: CALL_OW 264
23719: PUSH
23720: LD_INT 47
23722: PUSH
23723: EMPTY
23724: LIST
23725: IN
23726: IFFALSE 23747
// points := [ 67 , 45 , 75 ] ;
23728: LD_ADDR_VAR 0 9
23732: PUSH
23733: LD_INT 67
23735: PUSH
23736: LD_INT 45
23738: PUSH
23739: LD_INT 75
23741: PUSH
23742: EMPTY
23743: LIST
23744: LIST
23745: LIST
23746: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23747: LD_VAR 0 6
23751: PPUSH
23752: CALL_OW 264
23756: PUSH
23757: LD_INT 26
23759: PUSH
23760: EMPTY
23761: LIST
23762: IN
23763: IFFALSE 23784
// points := [ 120 , 30 , 80 ] ;
23765: LD_ADDR_VAR 0 9
23769: PUSH
23770: LD_INT 120
23772: PUSH
23773: LD_INT 30
23775: PUSH
23776: LD_INT 80
23778: PUSH
23779: EMPTY
23780: LIST
23781: LIST
23782: LIST
23783: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23784: LD_VAR 0 6
23788: PPUSH
23789: CALL_OW 264
23793: PUSH
23794: LD_INT 22
23796: PUSH
23797: EMPTY
23798: LIST
23799: IN
23800: IFFALSE 23821
// points := [ 40 , 1 , 1 ] ;
23802: LD_ADDR_VAR 0 9
23806: PUSH
23807: LD_INT 40
23809: PUSH
23810: LD_INT 1
23812: PUSH
23813: LD_INT 1
23815: PUSH
23816: EMPTY
23817: LIST
23818: LIST
23819: LIST
23820: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23821: LD_VAR 0 6
23825: PPUSH
23826: CALL_OW 264
23830: PUSH
23831: LD_INT 29
23833: PUSH
23834: EMPTY
23835: LIST
23836: IN
23837: IFFALSE 23858
// points := [ 70 , 200 , 400 ] ;
23839: LD_ADDR_VAR 0 9
23843: PUSH
23844: LD_INT 70
23846: PUSH
23847: LD_INT 200
23849: PUSH
23850: LD_INT 400
23852: PUSH
23853: EMPTY
23854: LIST
23855: LIST
23856: LIST
23857: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23858: LD_VAR 0 6
23862: PPUSH
23863: CALL_OW 264
23867: PUSH
23868: LD_INT 14
23870: PUSH
23871: LD_INT 53
23873: PUSH
23874: EMPTY
23875: LIST
23876: LIST
23877: IN
23878: IFFALSE 23899
// points := [ 40 , 10 , 20 ] ;
23880: LD_ADDR_VAR 0 9
23884: PUSH
23885: LD_INT 40
23887: PUSH
23888: LD_INT 10
23890: PUSH
23891: LD_INT 20
23893: PUSH
23894: EMPTY
23895: LIST
23896: LIST
23897: LIST
23898: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23899: LD_VAR 0 6
23903: PPUSH
23904: CALL_OW 264
23908: PUSH
23909: LD_INT 9
23911: PUSH
23912: EMPTY
23913: LIST
23914: IN
23915: IFFALSE 23936
// points := [ 5 , 70 , 20 ] ;
23917: LD_ADDR_VAR 0 9
23921: PUSH
23922: LD_INT 5
23924: PUSH
23925: LD_INT 70
23927: PUSH
23928: LD_INT 20
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: LIST
23935: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23936: LD_VAR 0 6
23940: PPUSH
23941: CALL_OW 264
23945: PUSH
23946: LD_INT 10
23948: PUSH
23949: EMPTY
23950: LIST
23951: IN
23952: IFFALSE 23973
// points := [ 35 , 110 , 70 ] ;
23954: LD_ADDR_VAR 0 9
23958: PUSH
23959: LD_INT 35
23961: PUSH
23962: LD_INT 110
23964: PUSH
23965: LD_INT 70
23967: PUSH
23968: EMPTY
23969: LIST
23970: LIST
23971: LIST
23972: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23973: LD_VAR 0 6
23977: PPUSH
23978: CALL_OW 265
23982: PUSH
23983: LD_INT 25
23985: EQUAL
23986: IFFALSE 24007
// points := [ 80 , 65 , 100 ] ;
23988: LD_ADDR_VAR 0 9
23992: PUSH
23993: LD_INT 80
23995: PUSH
23996: LD_INT 65
23998: PUSH
23999: LD_INT 100
24001: PUSH
24002: EMPTY
24003: LIST
24004: LIST
24005: LIST
24006: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
24007: LD_VAR 0 6
24011: PPUSH
24012: CALL_OW 263
24016: PUSH
24017: LD_INT 1
24019: EQUAL
24020: IFFALSE 24055
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
24022: LD_ADDR_VAR 0 10
24026: PUSH
24027: LD_VAR 0 10
24031: PUSH
24032: LD_VAR 0 6
24036: PPUSH
24037: CALL_OW 311
24041: PPUSH
24042: LD_INT 3
24044: PPUSH
24045: CALL_OW 259
24049: PUSH
24050: LD_INT 4
24052: MUL
24053: MUL
24054: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
24055: LD_VAR 0 6
24059: PPUSH
24060: CALL_OW 263
24064: PUSH
24065: LD_INT 2
24067: EQUAL
24068: IFFALSE 24119
// begin j := IsControledBy ( i ) ;
24070: LD_ADDR_VAR 0 7
24074: PUSH
24075: LD_VAR 0 6
24079: PPUSH
24080: CALL_OW 312
24084: ST_TO_ADDR
// if j then
24085: LD_VAR 0 7
24089: IFFALSE 24119
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
24091: LD_ADDR_VAR 0 10
24095: PUSH
24096: LD_VAR 0 10
24100: PUSH
24101: LD_VAR 0 7
24105: PPUSH
24106: LD_INT 3
24108: PPUSH
24109: CALL_OW 259
24113: PUSH
24114: LD_INT 3
24116: MUL
24117: MUL
24118: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
24119: LD_VAR 0 6
24123: PPUSH
24124: CALL_OW 264
24128: PUSH
24129: LD_INT 5
24131: PUSH
24132: LD_INT 6
24134: PUSH
24135: LD_INT 46
24137: PUSH
24138: LD_INT 44
24140: PUSH
24141: LD_INT 47
24143: PUSH
24144: LD_INT 45
24146: PUSH
24147: LD_INT 28
24149: PUSH
24150: LD_INT 7
24152: PUSH
24153: LD_INT 27
24155: PUSH
24156: LD_INT 29
24158: PUSH
24159: EMPTY
24160: LIST
24161: LIST
24162: LIST
24163: LIST
24164: LIST
24165: LIST
24166: LIST
24167: LIST
24168: LIST
24169: LIST
24170: IN
24171: PUSH
24172: LD_VAR 0 1
24176: PPUSH
24177: LD_INT 52
24179: PPUSH
24180: CALL_OW 321
24184: PUSH
24185: LD_INT 2
24187: EQUAL
24188: AND
24189: IFFALSE 24206
// bpoints := bpoints * 1.2 ;
24191: LD_ADDR_VAR 0 10
24195: PUSH
24196: LD_VAR 0 10
24200: PUSH
24201: LD_REAL  1.20000000000000E+0000
24204: MUL
24205: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
24206: LD_VAR 0 6
24210: PPUSH
24211: CALL_OW 264
24215: PUSH
24216: LD_INT 6
24218: PUSH
24219: LD_INT 46
24221: PUSH
24222: LD_INT 47
24224: PUSH
24225: EMPTY
24226: LIST
24227: LIST
24228: LIST
24229: IN
24230: IFFALSE 24247
// bpoints := bpoints * 1.2 ;
24232: LD_ADDR_VAR 0 10
24236: PUSH
24237: LD_VAR 0 10
24241: PUSH
24242: LD_REAL  1.20000000000000E+0000
24245: MUL
24246: ST_TO_ADDR
// end ; unit_building :
24247: GO 24261
24249: LD_INT 3
24251: DOUBLE
24252: EQUAL
24253: IFTRUE 24257
24255: GO 24260
24257: POP
// ; end ;
24258: GO 24261
24260: POP
// for j = 1 to 3 do
24261: LD_ADDR_VAR 0 7
24265: PUSH
24266: DOUBLE
24267: LD_INT 1
24269: DEC
24270: ST_TO_ADDR
24271: LD_INT 3
24273: PUSH
24274: FOR_TO
24275: IFFALSE 24328
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
24277: LD_ADDR_VAR 0 5
24281: PUSH
24282: LD_VAR 0 5
24286: PPUSH
24287: LD_VAR 0 7
24291: PPUSH
24292: LD_VAR 0 5
24296: PUSH
24297: LD_VAR 0 7
24301: ARRAY
24302: PUSH
24303: LD_VAR 0 9
24307: PUSH
24308: LD_VAR 0 7
24312: ARRAY
24313: PUSH
24314: LD_VAR 0 10
24318: MUL
24319: PLUS
24320: PPUSH
24321: CALL_OW 1
24325: ST_TO_ADDR
24326: GO 24274
24328: POP
24329: POP
// end ;
24330: GO 22809
24332: POP
24333: POP
// result := Replace ( result , 4 , tmp ) ;
24334: LD_ADDR_VAR 0 5
24338: PUSH
24339: LD_VAR 0 5
24343: PPUSH
24344: LD_INT 4
24346: PPUSH
24347: LD_VAR 0 8
24351: PPUSH
24352: CALL_OW 1
24356: ST_TO_ADDR
// end ;
24357: LD_VAR 0 5
24361: RET
// export function DangerAtRange ( unit , range ) ; begin
24362: LD_INT 0
24364: PPUSH
// if not unit then
24365: LD_VAR 0 1
24369: NOT
24370: IFFALSE 24374
// exit ;
24372: GO 24419
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
24374: LD_ADDR_VAR 0 3
24378: PUSH
24379: LD_VAR 0 1
24383: PPUSH
24384: CALL_OW 255
24388: PPUSH
24389: LD_VAR 0 1
24393: PPUSH
24394: CALL_OW 250
24398: PPUSH
24399: LD_VAR 0 1
24403: PPUSH
24404: CALL_OW 251
24408: PPUSH
24409: LD_VAR 0 2
24413: PPUSH
24414: CALL 22661 0 4
24418: ST_TO_ADDR
// end ;
24419: LD_VAR 0 3
24423: RET
// export function DangerInArea ( side , area ) ; begin
24424: LD_INT 0
24426: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
24427: LD_ADDR_VAR 0 3
24431: PUSH
24432: LD_VAR 0 2
24436: PPUSH
24437: LD_INT 81
24439: PUSH
24440: LD_VAR 0 1
24444: PUSH
24445: EMPTY
24446: LIST
24447: LIST
24448: PPUSH
24449: CALL_OW 70
24453: ST_TO_ADDR
// end ;
24454: LD_VAR 0 3
24458: RET
// export function IsExtension ( b ) ; begin
24459: LD_INT 0
24461: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
24462: LD_ADDR_VAR 0 2
24466: PUSH
24467: LD_VAR 0 1
24471: PUSH
24472: LD_INT 23
24474: PUSH
24475: LD_INT 20
24477: PUSH
24478: LD_INT 22
24480: PUSH
24481: LD_INT 17
24483: PUSH
24484: LD_INT 24
24486: PUSH
24487: LD_INT 21
24489: PUSH
24490: LD_INT 19
24492: PUSH
24493: LD_INT 16
24495: PUSH
24496: LD_INT 25
24498: PUSH
24499: LD_INT 18
24501: PUSH
24502: EMPTY
24503: LIST
24504: LIST
24505: LIST
24506: LIST
24507: LIST
24508: LIST
24509: LIST
24510: LIST
24511: LIST
24512: LIST
24513: IN
24514: ST_TO_ADDR
// end ;
24515: LD_VAR 0 2
24519: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
24520: LD_INT 0
24522: PPUSH
24523: PPUSH
24524: PPUSH
// result := [ ] ;
24525: LD_ADDR_VAR 0 4
24529: PUSH
24530: EMPTY
24531: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
24532: LD_ADDR_VAR 0 5
24536: PUSH
24537: LD_VAR 0 2
24541: PPUSH
24542: LD_INT 21
24544: PUSH
24545: LD_INT 3
24547: PUSH
24548: EMPTY
24549: LIST
24550: LIST
24551: PPUSH
24552: CALL_OW 70
24556: ST_TO_ADDR
// if not tmp then
24557: LD_VAR 0 5
24561: NOT
24562: IFFALSE 24566
// exit ;
24564: GO 24630
// if checkLink then
24566: LD_VAR 0 3
24570: IFFALSE 24620
// begin for i in tmp do
24572: LD_ADDR_VAR 0 6
24576: PUSH
24577: LD_VAR 0 5
24581: PUSH
24582: FOR_IN
24583: IFFALSE 24618
// if GetBase ( i ) <> base then
24585: LD_VAR 0 6
24589: PPUSH
24590: CALL_OW 274
24594: PUSH
24595: LD_VAR 0 1
24599: NONEQUAL
24600: IFFALSE 24616
// ComLinkToBase ( base , i ) ;
24602: LD_VAR 0 1
24606: PPUSH
24607: LD_VAR 0 6
24611: PPUSH
24612: CALL_OW 169
24616: GO 24582
24618: POP
24619: POP
// end ; result := tmp ;
24620: LD_ADDR_VAR 0 4
24624: PUSH
24625: LD_VAR 0 5
24629: ST_TO_ADDR
// end ;
24630: LD_VAR 0 4
24634: RET
// export function ComComplete ( units , b ) ; var i ; begin
24635: LD_INT 0
24637: PPUSH
24638: PPUSH
// if not units then
24639: LD_VAR 0 1
24643: NOT
24644: IFFALSE 24648
// exit ;
24646: GO 24738
// for i in units do
24648: LD_ADDR_VAR 0 4
24652: PUSH
24653: LD_VAR 0 1
24657: PUSH
24658: FOR_IN
24659: IFFALSE 24736
// if BuildingStatus ( b ) = bs_build then
24661: LD_VAR 0 2
24665: PPUSH
24666: CALL_OW 461
24670: PUSH
24671: LD_INT 1
24673: EQUAL
24674: IFFALSE 24734
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24676: LD_VAR 0 4
24680: PPUSH
24681: LD_STRING h
24683: PUSH
24684: LD_VAR 0 2
24688: PPUSH
24689: CALL_OW 250
24693: PUSH
24694: LD_VAR 0 2
24698: PPUSH
24699: CALL_OW 251
24703: PUSH
24704: LD_VAR 0 2
24708: PUSH
24709: LD_INT 0
24711: PUSH
24712: LD_INT 0
24714: PUSH
24715: LD_INT 0
24717: PUSH
24718: EMPTY
24719: LIST
24720: LIST
24721: LIST
24722: LIST
24723: LIST
24724: LIST
24725: LIST
24726: PUSH
24727: EMPTY
24728: LIST
24729: PPUSH
24730: CALL_OW 446
24734: GO 24658
24736: POP
24737: POP
// end ;
24738: LD_VAR 0 3
24742: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24743: LD_INT 0
24745: PPUSH
24746: PPUSH
24747: PPUSH
24748: PPUSH
24749: PPUSH
24750: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
24751: LD_VAR 0 1
24755: NOT
24756: PUSH
24757: LD_VAR 0 1
24761: PPUSH
24762: CALL_OW 263
24766: PUSH
24767: LD_INT 2
24769: NONEQUAL
24770: OR
24771: IFFALSE 24775
// exit ;
24773: GO 25091
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24775: LD_ADDR_VAR 0 6
24779: PUSH
24780: LD_INT 22
24782: PUSH
24783: LD_VAR 0 1
24787: PPUSH
24788: CALL_OW 255
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: PUSH
24797: LD_INT 2
24799: PUSH
24800: LD_INT 30
24802: PUSH
24803: LD_INT 36
24805: PUSH
24806: EMPTY
24807: LIST
24808: LIST
24809: PUSH
24810: LD_INT 34
24812: PUSH
24813: LD_INT 31
24815: PUSH
24816: EMPTY
24817: LIST
24818: LIST
24819: PUSH
24820: EMPTY
24821: LIST
24822: LIST
24823: LIST
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: PPUSH
24829: CALL_OW 69
24833: ST_TO_ADDR
// if not tmp then
24834: LD_VAR 0 6
24838: NOT
24839: IFFALSE 24843
// exit ;
24841: GO 25091
// result := [ ] ;
24843: LD_ADDR_VAR 0 2
24847: PUSH
24848: EMPTY
24849: ST_TO_ADDR
// for i in tmp do
24850: LD_ADDR_VAR 0 3
24854: PUSH
24855: LD_VAR 0 6
24859: PUSH
24860: FOR_IN
24861: IFFALSE 24932
// begin t := UnitsInside ( i ) ;
24863: LD_ADDR_VAR 0 4
24867: PUSH
24868: LD_VAR 0 3
24872: PPUSH
24873: CALL_OW 313
24877: ST_TO_ADDR
// if t then
24878: LD_VAR 0 4
24882: IFFALSE 24930
// for j in t do
24884: LD_ADDR_VAR 0 7
24888: PUSH
24889: LD_VAR 0 4
24893: PUSH
24894: FOR_IN
24895: IFFALSE 24928
// result := Replace ( result , result + 1 , j ) ;
24897: LD_ADDR_VAR 0 2
24901: PUSH
24902: LD_VAR 0 2
24906: PPUSH
24907: LD_VAR 0 2
24911: PUSH
24912: LD_INT 1
24914: PLUS
24915: PPUSH
24916: LD_VAR 0 7
24920: PPUSH
24921: CALL_OW 1
24925: ST_TO_ADDR
24926: GO 24894
24928: POP
24929: POP
// end ;
24930: GO 24860
24932: POP
24933: POP
// if not result then
24934: LD_VAR 0 2
24938: NOT
24939: IFFALSE 24943
// exit ;
24941: GO 25091
// mech := result [ 1 ] ;
24943: LD_ADDR_VAR 0 5
24947: PUSH
24948: LD_VAR 0 2
24952: PUSH
24953: LD_INT 1
24955: ARRAY
24956: ST_TO_ADDR
// if result > 1 then
24957: LD_VAR 0 2
24961: PUSH
24962: LD_INT 1
24964: GREATER
24965: IFFALSE 25077
// begin for i = 2 to result do
24967: LD_ADDR_VAR 0 3
24971: PUSH
24972: DOUBLE
24973: LD_INT 2
24975: DEC
24976: ST_TO_ADDR
24977: LD_VAR 0 2
24981: PUSH
24982: FOR_TO
24983: IFFALSE 25075
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24985: LD_ADDR_VAR 0 4
24989: PUSH
24990: LD_VAR 0 2
24994: PUSH
24995: LD_VAR 0 3
24999: ARRAY
25000: PPUSH
25001: LD_INT 3
25003: PPUSH
25004: CALL_OW 259
25008: PUSH
25009: LD_VAR 0 2
25013: PUSH
25014: LD_VAR 0 3
25018: ARRAY
25019: PPUSH
25020: CALL_OW 432
25024: MINUS
25025: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
25026: LD_VAR 0 4
25030: PUSH
25031: LD_VAR 0 5
25035: PPUSH
25036: LD_INT 3
25038: PPUSH
25039: CALL_OW 259
25043: PUSH
25044: LD_VAR 0 5
25048: PPUSH
25049: CALL_OW 432
25053: MINUS
25054: GREATEREQUAL
25055: IFFALSE 25073
// mech := result [ i ] ;
25057: LD_ADDR_VAR 0 5
25061: PUSH
25062: LD_VAR 0 2
25066: PUSH
25067: LD_VAR 0 3
25071: ARRAY
25072: ST_TO_ADDR
// end ;
25073: GO 24982
25075: POP
25076: POP
// end ; ComLinkTo ( vehicle , mech ) ;
25077: LD_VAR 0 1
25081: PPUSH
25082: LD_VAR 0 5
25086: PPUSH
25087: CALL_OW 135
// end ;
25091: LD_VAR 0 2
25095: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
25096: LD_INT 0
25098: PPUSH
25099: PPUSH
25100: PPUSH
25101: PPUSH
25102: PPUSH
25103: PPUSH
25104: PPUSH
25105: PPUSH
25106: PPUSH
25107: PPUSH
25108: PPUSH
25109: PPUSH
25110: PPUSH
// result := [ ] ;
25111: LD_ADDR_VAR 0 7
25115: PUSH
25116: EMPTY
25117: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
25118: LD_VAR 0 1
25122: PPUSH
25123: CALL_OW 266
25127: PUSH
25128: LD_INT 0
25130: PUSH
25131: LD_INT 1
25133: PUSH
25134: EMPTY
25135: LIST
25136: LIST
25137: IN
25138: NOT
25139: IFFALSE 25143
// exit ;
25141: GO 26777
// if name then
25143: LD_VAR 0 3
25147: IFFALSE 25163
// SetBName ( base_dep , name ) ;
25149: LD_VAR 0 1
25153: PPUSH
25154: LD_VAR 0 3
25158: PPUSH
25159: CALL_OW 500
// base := GetBase ( base_dep ) ;
25163: LD_ADDR_VAR 0 15
25167: PUSH
25168: LD_VAR 0 1
25172: PPUSH
25173: CALL_OW 274
25177: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
25178: LD_ADDR_VAR 0 16
25182: PUSH
25183: LD_VAR 0 1
25187: PPUSH
25188: CALL_OW 255
25192: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
25193: LD_ADDR_VAR 0 17
25197: PUSH
25198: LD_VAR 0 1
25202: PPUSH
25203: CALL_OW 248
25207: ST_TO_ADDR
// if sources then
25208: LD_VAR 0 5
25212: IFFALSE 25259
// for i = 1 to 3 do
25214: LD_ADDR_VAR 0 8
25218: PUSH
25219: DOUBLE
25220: LD_INT 1
25222: DEC
25223: ST_TO_ADDR
25224: LD_INT 3
25226: PUSH
25227: FOR_TO
25228: IFFALSE 25257
// AddResourceType ( base , i , sources [ i ] ) ;
25230: LD_VAR 0 15
25234: PPUSH
25235: LD_VAR 0 8
25239: PPUSH
25240: LD_VAR 0 5
25244: PUSH
25245: LD_VAR 0 8
25249: ARRAY
25250: PPUSH
25251: CALL_OW 276
25255: GO 25227
25257: POP
25258: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
25259: LD_ADDR_VAR 0 18
25263: PUSH
25264: LD_VAR 0 15
25268: PPUSH
25269: LD_VAR 0 2
25273: PPUSH
25274: LD_INT 1
25276: PPUSH
25277: CALL 24520 0 3
25281: ST_TO_ADDR
// InitHc ;
25282: CALL_OW 19
// InitUc ;
25286: CALL_OW 18
// uc_side := side ;
25290: LD_ADDR_OWVAR 20
25294: PUSH
25295: LD_VAR 0 16
25299: ST_TO_ADDR
// uc_nation := nation ;
25300: LD_ADDR_OWVAR 21
25304: PUSH
25305: LD_VAR 0 17
25309: ST_TO_ADDR
// if buildings then
25310: LD_VAR 0 18
25314: IFFALSE 26636
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
25316: LD_ADDR_VAR 0 19
25320: PUSH
25321: LD_VAR 0 18
25325: PPUSH
25326: LD_INT 2
25328: PUSH
25329: LD_INT 30
25331: PUSH
25332: LD_INT 29
25334: PUSH
25335: EMPTY
25336: LIST
25337: LIST
25338: PUSH
25339: LD_INT 30
25341: PUSH
25342: LD_INT 30
25344: PUSH
25345: EMPTY
25346: LIST
25347: LIST
25348: PUSH
25349: EMPTY
25350: LIST
25351: LIST
25352: LIST
25353: PPUSH
25354: CALL_OW 72
25358: ST_TO_ADDR
// if tmp then
25359: LD_VAR 0 19
25363: IFFALSE 25411
// for i in tmp do
25365: LD_ADDR_VAR 0 8
25369: PUSH
25370: LD_VAR 0 19
25374: PUSH
25375: FOR_IN
25376: IFFALSE 25409
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
25378: LD_VAR 0 8
25382: PPUSH
25383: CALL_OW 250
25387: PPUSH
25388: LD_VAR 0 8
25392: PPUSH
25393: CALL_OW 251
25397: PPUSH
25398: LD_VAR 0 16
25402: PPUSH
25403: CALL_OW 441
25407: GO 25375
25409: POP
25410: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
25411: LD_VAR 0 18
25415: PPUSH
25416: LD_INT 2
25418: PUSH
25419: LD_INT 30
25421: PUSH
25422: LD_INT 32
25424: PUSH
25425: EMPTY
25426: LIST
25427: LIST
25428: PUSH
25429: LD_INT 30
25431: PUSH
25432: LD_INT 33
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: PUSH
25439: EMPTY
25440: LIST
25441: LIST
25442: LIST
25443: PPUSH
25444: CALL_OW 72
25448: IFFALSE 25536
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
25450: LD_ADDR_VAR 0 8
25454: PUSH
25455: LD_VAR 0 18
25459: PPUSH
25460: LD_INT 2
25462: PUSH
25463: LD_INT 30
25465: PUSH
25466: LD_INT 32
25468: PUSH
25469: EMPTY
25470: LIST
25471: LIST
25472: PUSH
25473: LD_INT 30
25475: PUSH
25476: LD_INT 33
25478: PUSH
25479: EMPTY
25480: LIST
25481: LIST
25482: PUSH
25483: EMPTY
25484: LIST
25485: LIST
25486: LIST
25487: PPUSH
25488: CALL_OW 72
25492: PUSH
25493: FOR_IN
25494: IFFALSE 25534
// begin if not GetBWeapon ( i ) then
25496: LD_VAR 0 8
25500: PPUSH
25501: CALL_OW 269
25505: NOT
25506: IFFALSE 25532
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
25508: LD_VAR 0 8
25512: PPUSH
25513: LD_VAR 0 8
25517: PPUSH
25518: LD_VAR 0 2
25522: PPUSH
25523: CALL 26782 0 2
25527: PPUSH
25528: CALL_OW 431
// end ;
25532: GO 25493
25534: POP
25535: POP
// end ; for i = 1 to personel do
25536: LD_ADDR_VAR 0 8
25540: PUSH
25541: DOUBLE
25542: LD_INT 1
25544: DEC
25545: ST_TO_ADDR
25546: LD_VAR 0 6
25550: PUSH
25551: FOR_TO
25552: IFFALSE 26616
// begin if i > 4 then
25554: LD_VAR 0 8
25558: PUSH
25559: LD_INT 4
25561: GREATER
25562: IFFALSE 25566
// break ;
25564: GO 26616
// case i of 1 :
25566: LD_VAR 0 8
25570: PUSH
25571: LD_INT 1
25573: DOUBLE
25574: EQUAL
25575: IFTRUE 25579
25577: GO 25659
25579: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
25580: LD_ADDR_VAR 0 12
25584: PUSH
25585: LD_VAR 0 18
25589: PPUSH
25590: LD_INT 22
25592: PUSH
25593: LD_VAR 0 16
25597: PUSH
25598: EMPTY
25599: LIST
25600: LIST
25601: PUSH
25602: LD_INT 58
25604: PUSH
25605: EMPTY
25606: LIST
25607: PUSH
25608: LD_INT 2
25610: PUSH
25611: LD_INT 30
25613: PUSH
25614: LD_INT 32
25616: PUSH
25617: EMPTY
25618: LIST
25619: LIST
25620: PUSH
25621: LD_INT 30
25623: PUSH
25624: LD_INT 4
25626: PUSH
25627: EMPTY
25628: LIST
25629: LIST
25630: PUSH
25631: LD_INT 30
25633: PUSH
25634: LD_INT 5
25636: PUSH
25637: EMPTY
25638: LIST
25639: LIST
25640: PUSH
25641: EMPTY
25642: LIST
25643: LIST
25644: LIST
25645: LIST
25646: PUSH
25647: EMPTY
25648: LIST
25649: LIST
25650: LIST
25651: PPUSH
25652: CALL_OW 72
25656: ST_TO_ADDR
25657: GO 25881
25659: LD_INT 2
25661: DOUBLE
25662: EQUAL
25663: IFTRUE 25667
25665: GO 25729
25667: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25668: LD_ADDR_VAR 0 12
25672: PUSH
25673: LD_VAR 0 18
25677: PPUSH
25678: LD_INT 22
25680: PUSH
25681: LD_VAR 0 16
25685: PUSH
25686: EMPTY
25687: LIST
25688: LIST
25689: PUSH
25690: LD_INT 2
25692: PUSH
25693: LD_INT 30
25695: PUSH
25696: LD_INT 0
25698: PUSH
25699: EMPTY
25700: LIST
25701: LIST
25702: PUSH
25703: LD_INT 30
25705: PUSH
25706: LD_INT 1
25708: PUSH
25709: EMPTY
25710: LIST
25711: LIST
25712: PUSH
25713: EMPTY
25714: LIST
25715: LIST
25716: LIST
25717: PUSH
25718: EMPTY
25719: LIST
25720: LIST
25721: PPUSH
25722: CALL_OW 72
25726: ST_TO_ADDR
25727: GO 25881
25729: LD_INT 3
25731: DOUBLE
25732: EQUAL
25733: IFTRUE 25737
25735: GO 25799
25737: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25738: LD_ADDR_VAR 0 12
25742: PUSH
25743: LD_VAR 0 18
25747: PPUSH
25748: LD_INT 22
25750: PUSH
25751: LD_VAR 0 16
25755: PUSH
25756: EMPTY
25757: LIST
25758: LIST
25759: PUSH
25760: LD_INT 2
25762: PUSH
25763: LD_INT 30
25765: PUSH
25766: LD_INT 2
25768: PUSH
25769: EMPTY
25770: LIST
25771: LIST
25772: PUSH
25773: LD_INT 30
25775: PUSH
25776: LD_INT 3
25778: PUSH
25779: EMPTY
25780: LIST
25781: LIST
25782: PUSH
25783: EMPTY
25784: LIST
25785: LIST
25786: LIST
25787: PUSH
25788: EMPTY
25789: LIST
25790: LIST
25791: PPUSH
25792: CALL_OW 72
25796: ST_TO_ADDR
25797: GO 25881
25799: LD_INT 4
25801: DOUBLE
25802: EQUAL
25803: IFTRUE 25807
25805: GO 25880
25807: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25808: LD_ADDR_VAR 0 12
25812: PUSH
25813: LD_VAR 0 18
25817: PPUSH
25818: LD_INT 22
25820: PUSH
25821: LD_VAR 0 16
25825: PUSH
25826: EMPTY
25827: LIST
25828: LIST
25829: PUSH
25830: LD_INT 2
25832: PUSH
25833: LD_INT 30
25835: PUSH
25836: LD_INT 6
25838: PUSH
25839: EMPTY
25840: LIST
25841: LIST
25842: PUSH
25843: LD_INT 30
25845: PUSH
25846: LD_INT 7
25848: PUSH
25849: EMPTY
25850: LIST
25851: LIST
25852: PUSH
25853: LD_INT 30
25855: PUSH
25856: LD_INT 8
25858: PUSH
25859: EMPTY
25860: LIST
25861: LIST
25862: PUSH
25863: EMPTY
25864: LIST
25865: LIST
25866: LIST
25867: LIST
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PPUSH
25873: CALL_OW 72
25877: ST_TO_ADDR
25878: GO 25881
25880: POP
// if i = 1 then
25881: LD_VAR 0 8
25885: PUSH
25886: LD_INT 1
25888: EQUAL
25889: IFFALSE 26000
// begin tmp := [ ] ;
25891: LD_ADDR_VAR 0 19
25895: PUSH
25896: EMPTY
25897: ST_TO_ADDR
// for j in f do
25898: LD_ADDR_VAR 0 9
25902: PUSH
25903: LD_VAR 0 12
25907: PUSH
25908: FOR_IN
25909: IFFALSE 25982
// if GetBType ( j ) = b_bunker then
25911: LD_VAR 0 9
25915: PPUSH
25916: CALL_OW 266
25920: PUSH
25921: LD_INT 32
25923: EQUAL
25924: IFFALSE 25951
// tmp := Insert ( tmp , 1 , j ) else
25926: LD_ADDR_VAR 0 19
25930: PUSH
25931: LD_VAR 0 19
25935: PPUSH
25936: LD_INT 1
25938: PPUSH
25939: LD_VAR 0 9
25943: PPUSH
25944: CALL_OW 2
25948: ST_TO_ADDR
25949: GO 25980
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25951: LD_ADDR_VAR 0 19
25955: PUSH
25956: LD_VAR 0 19
25960: PPUSH
25961: LD_VAR 0 19
25965: PUSH
25966: LD_INT 1
25968: PLUS
25969: PPUSH
25970: LD_VAR 0 9
25974: PPUSH
25975: CALL_OW 2
25979: ST_TO_ADDR
25980: GO 25908
25982: POP
25983: POP
// if tmp then
25984: LD_VAR 0 19
25988: IFFALSE 26000
// f := tmp ;
25990: LD_ADDR_VAR 0 12
25994: PUSH
25995: LD_VAR 0 19
25999: ST_TO_ADDR
// end ; x := personel [ i ] ;
26000: LD_ADDR_VAR 0 13
26004: PUSH
26005: LD_VAR 0 6
26009: PUSH
26010: LD_VAR 0 8
26014: ARRAY
26015: ST_TO_ADDR
// if x = - 1 then
26016: LD_VAR 0 13
26020: PUSH
26021: LD_INT 1
26023: NEG
26024: EQUAL
26025: IFFALSE 26234
// begin for j in f do
26027: LD_ADDR_VAR 0 9
26031: PUSH
26032: LD_VAR 0 12
26036: PUSH
26037: FOR_IN
26038: IFFALSE 26230
// repeat InitHc ;
26040: CALL_OW 19
// if GetBType ( j ) = b_barracks then
26044: LD_VAR 0 9
26048: PPUSH
26049: CALL_OW 266
26053: PUSH
26054: LD_INT 5
26056: EQUAL
26057: IFFALSE 26127
// begin if UnitsInside ( j ) < 3 then
26059: LD_VAR 0 9
26063: PPUSH
26064: CALL_OW 313
26068: PUSH
26069: LD_INT 3
26071: LESS
26072: IFFALSE 26108
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26074: LD_INT 0
26076: PPUSH
26077: LD_INT 5
26079: PUSH
26080: LD_INT 8
26082: PUSH
26083: LD_INT 9
26085: PUSH
26086: EMPTY
26087: LIST
26088: LIST
26089: LIST
26090: PUSH
26091: LD_VAR 0 17
26095: ARRAY
26096: PPUSH
26097: LD_VAR 0 4
26101: PPUSH
26102: CALL_OW 380
26106: GO 26125
// PrepareHuman ( false , i , skill ) ;
26108: LD_INT 0
26110: PPUSH
26111: LD_VAR 0 8
26115: PPUSH
26116: LD_VAR 0 4
26120: PPUSH
26121: CALL_OW 380
// end else
26125: GO 26144
// PrepareHuman ( false , i , skill ) ;
26127: LD_INT 0
26129: PPUSH
26130: LD_VAR 0 8
26134: PPUSH
26135: LD_VAR 0 4
26139: PPUSH
26140: CALL_OW 380
// un := CreateHuman ;
26144: LD_ADDR_VAR 0 14
26148: PUSH
26149: CALL_OW 44
26153: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26154: LD_ADDR_VAR 0 7
26158: PUSH
26159: LD_VAR 0 7
26163: PPUSH
26164: LD_INT 1
26166: PPUSH
26167: LD_VAR 0 14
26171: PPUSH
26172: CALL_OW 2
26176: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
26177: LD_VAR 0 14
26181: PPUSH
26182: LD_VAR 0 9
26186: PPUSH
26187: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
26191: LD_VAR 0 9
26195: PPUSH
26196: CALL_OW 313
26200: PUSH
26201: LD_INT 6
26203: EQUAL
26204: PUSH
26205: LD_VAR 0 9
26209: PPUSH
26210: CALL_OW 266
26214: PUSH
26215: LD_INT 32
26217: PUSH
26218: LD_INT 31
26220: PUSH
26221: EMPTY
26222: LIST
26223: LIST
26224: IN
26225: OR
26226: IFFALSE 26040
26228: GO 26037
26230: POP
26231: POP
// end else
26232: GO 26614
// for j = 1 to x do
26234: LD_ADDR_VAR 0 9
26238: PUSH
26239: DOUBLE
26240: LD_INT 1
26242: DEC
26243: ST_TO_ADDR
26244: LD_VAR 0 13
26248: PUSH
26249: FOR_TO
26250: IFFALSE 26612
// begin InitHc ;
26252: CALL_OW 19
// if not f then
26256: LD_VAR 0 12
26260: NOT
26261: IFFALSE 26350
// begin PrepareHuman ( false , i , skill ) ;
26263: LD_INT 0
26265: PPUSH
26266: LD_VAR 0 8
26270: PPUSH
26271: LD_VAR 0 4
26275: PPUSH
26276: CALL_OW 380
// un := CreateHuman ;
26280: LD_ADDR_VAR 0 14
26284: PUSH
26285: CALL_OW 44
26289: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26290: LD_ADDR_VAR 0 7
26294: PUSH
26295: LD_VAR 0 7
26299: PPUSH
26300: LD_INT 1
26302: PPUSH
26303: LD_VAR 0 14
26307: PPUSH
26308: CALL_OW 2
26312: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26313: LD_VAR 0 14
26317: PPUSH
26318: LD_VAR 0 1
26322: PPUSH
26323: CALL_OW 250
26327: PPUSH
26328: LD_VAR 0 1
26332: PPUSH
26333: CALL_OW 251
26337: PPUSH
26338: LD_INT 10
26340: PPUSH
26341: LD_INT 0
26343: PPUSH
26344: CALL_OW 50
// continue ;
26348: GO 26249
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
26350: LD_VAR 0 12
26354: PUSH
26355: LD_INT 1
26357: ARRAY
26358: PPUSH
26359: CALL_OW 313
26363: PUSH
26364: LD_VAR 0 12
26368: PUSH
26369: LD_INT 1
26371: ARRAY
26372: PPUSH
26373: CALL_OW 266
26377: PUSH
26378: LD_INT 32
26380: PUSH
26381: LD_INT 31
26383: PUSH
26384: EMPTY
26385: LIST
26386: LIST
26387: IN
26388: AND
26389: PUSH
26390: LD_VAR 0 12
26394: PUSH
26395: LD_INT 1
26397: ARRAY
26398: PPUSH
26399: CALL_OW 313
26403: PUSH
26404: LD_INT 6
26406: EQUAL
26407: OR
26408: IFFALSE 26428
// f := Delete ( f , 1 ) ;
26410: LD_ADDR_VAR 0 12
26414: PUSH
26415: LD_VAR 0 12
26419: PPUSH
26420: LD_INT 1
26422: PPUSH
26423: CALL_OW 3
26427: ST_TO_ADDR
// if not f then
26428: LD_VAR 0 12
26432: NOT
26433: IFFALSE 26451
// begin x := x + 2 ;
26435: LD_ADDR_VAR 0 13
26439: PUSH
26440: LD_VAR 0 13
26444: PUSH
26445: LD_INT 2
26447: PLUS
26448: ST_TO_ADDR
// continue ;
26449: GO 26249
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
26451: LD_VAR 0 12
26455: PUSH
26456: LD_INT 1
26458: ARRAY
26459: PPUSH
26460: CALL_OW 266
26464: PUSH
26465: LD_INT 5
26467: EQUAL
26468: IFFALSE 26542
// begin if UnitsInside ( f [ 1 ] ) < 3 then
26470: LD_VAR 0 12
26474: PUSH
26475: LD_INT 1
26477: ARRAY
26478: PPUSH
26479: CALL_OW 313
26483: PUSH
26484: LD_INT 3
26486: LESS
26487: IFFALSE 26523
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26489: LD_INT 0
26491: PPUSH
26492: LD_INT 5
26494: PUSH
26495: LD_INT 8
26497: PUSH
26498: LD_INT 9
26500: PUSH
26501: EMPTY
26502: LIST
26503: LIST
26504: LIST
26505: PUSH
26506: LD_VAR 0 17
26510: ARRAY
26511: PPUSH
26512: LD_VAR 0 4
26516: PPUSH
26517: CALL_OW 380
26521: GO 26540
// PrepareHuman ( false , i , skill ) ;
26523: LD_INT 0
26525: PPUSH
26526: LD_VAR 0 8
26530: PPUSH
26531: LD_VAR 0 4
26535: PPUSH
26536: CALL_OW 380
// end else
26540: GO 26559
// PrepareHuman ( false , i , skill ) ;
26542: LD_INT 0
26544: PPUSH
26545: LD_VAR 0 8
26549: PPUSH
26550: LD_VAR 0 4
26554: PPUSH
26555: CALL_OW 380
// un := CreateHuman ;
26559: LD_ADDR_VAR 0 14
26563: PUSH
26564: CALL_OW 44
26568: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26569: LD_ADDR_VAR 0 7
26573: PUSH
26574: LD_VAR 0 7
26578: PPUSH
26579: LD_INT 1
26581: PPUSH
26582: LD_VAR 0 14
26586: PPUSH
26587: CALL_OW 2
26591: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
26592: LD_VAR 0 14
26596: PPUSH
26597: LD_VAR 0 12
26601: PUSH
26602: LD_INT 1
26604: ARRAY
26605: PPUSH
26606: CALL_OW 52
// end ;
26610: GO 26249
26612: POP
26613: POP
// end ;
26614: GO 25551
26616: POP
26617: POP
// result := result ^ buildings ;
26618: LD_ADDR_VAR 0 7
26622: PUSH
26623: LD_VAR 0 7
26627: PUSH
26628: LD_VAR 0 18
26632: ADD
26633: ST_TO_ADDR
// end else
26634: GO 26777
// begin for i = 1 to personel do
26636: LD_ADDR_VAR 0 8
26640: PUSH
26641: DOUBLE
26642: LD_INT 1
26644: DEC
26645: ST_TO_ADDR
26646: LD_VAR 0 6
26650: PUSH
26651: FOR_TO
26652: IFFALSE 26775
// begin if i > 4 then
26654: LD_VAR 0 8
26658: PUSH
26659: LD_INT 4
26661: GREATER
26662: IFFALSE 26666
// break ;
26664: GO 26775
// x := personel [ i ] ;
26666: LD_ADDR_VAR 0 13
26670: PUSH
26671: LD_VAR 0 6
26675: PUSH
26676: LD_VAR 0 8
26680: ARRAY
26681: ST_TO_ADDR
// if x = - 1 then
26682: LD_VAR 0 13
26686: PUSH
26687: LD_INT 1
26689: NEG
26690: EQUAL
26691: IFFALSE 26695
// continue ;
26693: GO 26651
// PrepareHuman ( false , i , skill ) ;
26695: LD_INT 0
26697: PPUSH
26698: LD_VAR 0 8
26702: PPUSH
26703: LD_VAR 0 4
26707: PPUSH
26708: CALL_OW 380
// un := CreateHuman ;
26712: LD_ADDR_VAR 0 14
26716: PUSH
26717: CALL_OW 44
26721: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26722: LD_VAR 0 14
26726: PPUSH
26727: LD_VAR 0 1
26731: PPUSH
26732: CALL_OW 250
26736: PPUSH
26737: LD_VAR 0 1
26741: PPUSH
26742: CALL_OW 251
26746: PPUSH
26747: LD_INT 10
26749: PPUSH
26750: LD_INT 0
26752: PPUSH
26753: CALL_OW 50
// result := result ^ un ;
26757: LD_ADDR_VAR 0 7
26761: PUSH
26762: LD_VAR 0 7
26766: PUSH
26767: LD_VAR 0 14
26771: ADD
26772: ST_TO_ADDR
// end ;
26773: GO 26651
26775: POP
26776: POP
// end ; end ;
26777: LD_VAR 0 7
26781: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26782: LD_INT 0
26784: PPUSH
26785: PPUSH
26786: PPUSH
26787: PPUSH
26788: PPUSH
26789: PPUSH
26790: PPUSH
26791: PPUSH
26792: PPUSH
26793: PPUSH
26794: PPUSH
26795: PPUSH
26796: PPUSH
26797: PPUSH
26798: PPUSH
26799: PPUSH
// result := false ;
26800: LD_ADDR_VAR 0 3
26804: PUSH
26805: LD_INT 0
26807: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26808: LD_VAR 0 1
26812: NOT
26813: PUSH
26814: LD_VAR 0 1
26818: PPUSH
26819: CALL_OW 266
26823: PUSH
26824: LD_INT 32
26826: PUSH
26827: LD_INT 33
26829: PUSH
26830: EMPTY
26831: LIST
26832: LIST
26833: IN
26834: NOT
26835: OR
26836: IFFALSE 26840
// exit ;
26838: GO 27949
// nat := GetNation ( tower ) ;
26840: LD_ADDR_VAR 0 12
26844: PUSH
26845: LD_VAR 0 1
26849: PPUSH
26850: CALL_OW 248
26854: ST_TO_ADDR
// side := GetSide ( tower ) ;
26855: LD_ADDR_VAR 0 16
26859: PUSH
26860: LD_VAR 0 1
26864: PPUSH
26865: CALL_OW 255
26869: ST_TO_ADDR
// x := GetX ( tower ) ;
26870: LD_ADDR_VAR 0 10
26874: PUSH
26875: LD_VAR 0 1
26879: PPUSH
26880: CALL_OW 250
26884: ST_TO_ADDR
// y := GetY ( tower ) ;
26885: LD_ADDR_VAR 0 11
26889: PUSH
26890: LD_VAR 0 1
26894: PPUSH
26895: CALL_OW 251
26899: ST_TO_ADDR
// if not x or not y then
26900: LD_VAR 0 10
26904: NOT
26905: PUSH
26906: LD_VAR 0 11
26910: NOT
26911: OR
26912: IFFALSE 26916
// exit ;
26914: GO 27949
// weapon := 0 ;
26916: LD_ADDR_VAR 0 18
26920: PUSH
26921: LD_INT 0
26923: ST_TO_ADDR
// fac_list := [ ] ;
26924: LD_ADDR_VAR 0 17
26928: PUSH
26929: EMPTY
26930: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
26931: LD_ADDR_VAR 0 6
26935: PUSH
26936: LD_VAR 0 1
26940: PPUSH
26941: CALL_OW 274
26945: PPUSH
26946: LD_VAR 0 2
26950: PPUSH
26951: LD_INT 0
26953: PPUSH
26954: CALL 24520 0 3
26958: PPUSH
26959: LD_INT 30
26961: PUSH
26962: LD_INT 3
26964: PUSH
26965: EMPTY
26966: LIST
26967: LIST
26968: PPUSH
26969: CALL_OW 72
26973: ST_TO_ADDR
// if not factories then
26974: LD_VAR 0 6
26978: NOT
26979: IFFALSE 26983
// exit ;
26981: GO 27949
// for i in factories do
26983: LD_ADDR_VAR 0 8
26987: PUSH
26988: LD_VAR 0 6
26992: PUSH
26993: FOR_IN
26994: IFFALSE 27019
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26996: LD_ADDR_VAR 0 17
27000: PUSH
27001: LD_VAR 0 17
27005: PUSH
27006: LD_VAR 0 8
27010: PPUSH
27011: CALL_OW 478
27015: UNION
27016: ST_TO_ADDR
27017: GO 26993
27019: POP
27020: POP
// if not fac_list then
27021: LD_VAR 0 17
27025: NOT
27026: IFFALSE 27030
// exit ;
27028: GO 27949
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
27030: LD_ADDR_VAR 0 5
27034: PUSH
27035: LD_INT 4
27037: PUSH
27038: LD_INT 5
27040: PUSH
27041: LD_INT 9
27043: PUSH
27044: LD_INT 10
27046: PUSH
27047: LD_INT 6
27049: PUSH
27050: LD_INT 7
27052: PUSH
27053: LD_INT 11
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: LIST
27060: LIST
27061: LIST
27062: LIST
27063: LIST
27064: PUSH
27065: LD_INT 27
27067: PUSH
27068: LD_INT 28
27070: PUSH
27071: LD_INT 26
27073: PUSH
27074: LD_INT 30
27076: PUSH
27077: EMPTY
27078: LIST
27079: LIST
27080: LIST
27081: LIST
27082: PUSH
27083: LD_INT 43
27085: PUSH
27086: LD_INT 44
27088: PUSH
27089: LD_INT 46
27091: PUSH
27092: LD_INT 45
27094: PUSH
27095: LD_INT 47
27097: PUSH
27098: LD_INT 49
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: LIST
27105: LIST
27106: LIST
27107: LIST
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: LIST
27113: PUSH
27114: LD_VAR 0 12
27118: ARRAY
27119: ST_TO_ADDR
// list := list isect fac_list ;
27120: LD_ADDR_VAR 0 5
27124: PUSH
27125: LD_VAR 0 5
27129: PUSH
27130: LD_VAR 0 17
27134: ISECT
27135: ST_TO_ADDR
// if not list then
27136: LD_VAR 0 5
27140: NOT
27141: IFFALSE 27145
// exit ;
27143: GO 27949
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
27145: LD_VAR 0 12
27149: PUSH
27150: LD_INT 3
27152: EQUAL
27153: PUSH
27154: LD_INT 49
27156: PUSH
27157: LD_VAR 0 5
27161: IN
27162: AND
27163: PUSH
27164: LD_INT 31
27166: PPUSH
27167: LD_VAR 0 16
27171: PPUSH
27172: CALL_OW 321
27176: PUSH
27177: LD_INT 2
27179: EQUAL
27180: AND
27181: IFFALSE 27241
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
27183: LD_INT 22
27185: PUSH
27186: LD_VAR 0 16
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PUSH
27195: LD_INT 35
27197: PUSH
27198: LD_INT 49
27200: PUSH
27201: EMPTY
27202: LIST
27203: LIST
27204: PUSH
27205: LD_INT 91
27207: PUSH
27208: LD_VAR 0 1
27212: PUSH
27213: LD_INT 10
27215: PUSH
27216: EMPTY
27217: LIST
27218: LIST
27219: LIST
27220: PUSH
27221: EMPTY
27222: LIST
27223: LIST
27224: LIST
27225: PPUSH
27226: CALL_OW 69
27230: NOT
27231: IFFALSE 27241
// weapon := ru_time_lapser ;
27233: LD_ADDR_VAR 0 18
27237: PUSH
27238: LD_INT 49
27240: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
27241: LD_VAR 0 12
27245: PUSH
27246: LD_INT 1
27248: PUSH
27249: LD_INT 2
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: IN
27256: PUSH
27257: LD_INT 11
27259: PUSH
27260: LD_VAR 0 5
27264: IN
27265: PUSH
27266: LD_INT 30
27268: PUSH
27269: LD_VAR 0 5
27273: IN
27274: OR
27275: AND
27276: PUSH
27277: LD_INT 6
27279: PPUSH
27280: LD_VAR 0 16
27284: PPUSH
27285: CALL_OW 321
27289: PUSH
27290: LD_INT 2
27292: EQUAL
27293: AND
27294: IFFALSE 27459
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
27296: LD_INT 22
27298: PUSH
27299: LD_VAR 0 16
27303: PUSH
27304: EMPTY
27305: LIST
27306: LIST
27307: PUSH
27308: LD_INT 2
27310: PUSH
27311: LD_INT 35
27313: PUSH
27314: LD_INT 11
27316: PUSH
27317: EMPTY
27318: LIST
27319: LIST
27320: PUSH
27321: LD_INT 35
27323: PUSH
27324: LD_INT 30
27326: PUSH
27327: EMPTY
27328: LIST
27329: LIST
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: LIST
27335: PUSH
27336: LD_INT 91
27338: PUSH
27339: LD_VAR 0 1
27343: PUSH
27344: LD_INT 18
27346: PUSH
27347: EMPTY
27348: LIST
27349: LIST
27350: LIST
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: LIST
27356: PPUSH
27357: CALL_OW 69
27361: NOT
27362: PUSH
27363: LD_INT 22
27365: PUSH
27366: LD_VAR 0 16
27370: PUSH
27371: EMPTY
27372: LIST
27373: LIST
27374: PUSH
27375: LD_INT 2
27377: PUSH
27378: LD_INT 30
27380: PUSH
27381: LD_INT 32
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: PUSH
27388: LD_INT 30
27390: PUSH
27391: LD_INT 33
27393: PUSH
27394: EMPTY
27395: LIST
27396: LIST
27397: PUSH
27398: EMPTY
27399: LIST
27400: LIST
27401: LIST
27402: PUSH
27403: LD_INT 91
27405: PUSH
27406: LD_VAR 0 1
27410: PUSH
27411: LD_INT 12
27413: PUSH
27414: EMPTY
27415: LIST
27416: LIST
27417: LIST
27418: PUSH
27419: EMPTY
27420: LIST
27421: LIST
27422: LIST
27423: PUSH
27424: EMPTY
27425: LIST
27426: PPUSH
27427: CALL_OW 69
27431: PUSH
27432: LD_INT 2
27434: GREATER
27435: AND
27436: IFFALSE 27459
// weapon := [ us_radar , ar_radar ] [ nat ] ;
27438: LD_ADDR_VAR 0 18
27442: PUSH
27443: LD_INT 11
27445: PUSH
27446: LD_INT 30
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: PUSH
27453: LD_VAR 0 12
27457: ARRAY
27458: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
27459: LD_VAR 0 18
27463: NOT
27464: PUSH
27465: LD_INT 40
27467: PPUSH
27468: LD_VAR 0 16
27472: PPUSH
27473: CALL_OW 321
27477: PUSH
27478: LD_INT 2
27480: EQUAL
27481: AND
27482: PUSH
27483: LD_INT 7
27485: PUSH
27486: LD_VAR 0 5
27490: IN
27491: PUSH
27492: LD_INT 28
27494: PUSH
27495: LD_VAR 0 5
27499: IN
27500: OR
27501: PUSH
27502: LD_INT 45
27504: PUSH
27505: LD_VAR 0 5
27509: IN
27510: OR
27511: AND
27512: IFFALSE 27766
// begin hex := GetHexInfo ( x , y ) ;
27514: LD_ADDR_VAR 0 4
27518: PUSH
27519: LD_VAR 0 10
27523: PPUSH
27524: LD_VAR 0 11
27528: PPUSH
27529: CALL_OW 546
27533: ST_TO_ADDR
// if hex [ 1 ] then
27534: LD_VAR 0 4
27538: PUSH
27539: LD_INT 1
27541: ARRAY
27542: IFFALSE 27546
// exit ;
27544: GO 27949
// height := hex [ 2 ] ;
27546: LD_ADDR_VAR 0 15
27550: PUSH
27551: LD_VAR 0 4
27555: PUSH
27556: LD_INT 2
27558: ARRAY
27559: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
27560: LD_ADDR_VAR 0 14
27564: PUSH
27565: LD_INT 0
27567: PUSH
27568: LD_INT 2
27570: PUSH
27571: LD_INT 3
27573: PUSH
27574: LD_INT 5
27576: PUSH
27577: EMPTY
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: ST_TO_ADDR
// for i in tmp do
27583: LD_ADDR_VAR 0 8
27587: PUSH
27588: LD_VAR 0 14
27592: PUSH
27593: FOR_IN
27594: IFFALSE 27764
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
27596: LD_ADDR_VAR 0 9
27600: PUSH
27601: LD_VAR 0 10
27605: PPUSH
27606: LD_VAR 0 8
27610: PPUSH
27611: LD_INT 5
27613: PPUSH
27614: CALL_OW 272
27618: PUSH
27619: LD_VAR 0 11
27623: PPUSH
27624: LD_VAR 0 8
27628: PPUSH
27629: LD_INT 5
27631: PPUSH
27632: CALL_OW 273
27636: PUSH
27637: EMPTY
27638: LIST
27639: LIST
27640: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27641: LD_VAR 0 9
27645: PUSH
27646: LD_INT 1
27648: ARRAY
27649: PPUSH
27650: LD_VAR 0 9
27654: PUSH
27655: LD_INT 2
27657: ARRAY
27658: PPUSH
27659: CALL_OW 488
27663: IFFALSE 27762
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27665: LD_ADDR_VAR 0 4
27669: PUSH
27670: LD_VAR 0 9
27674: PUSH
27675: LD_INT 1
27677: ARRAY
27678: PPUSH
27679: LD_VAR 0 9
27683: PUSH
27684: LD_INT 2
27686: ARRAY
27687: PPUSH
27688: CALL_OW 546
27692: ST_TO_ADDR
// if hex [ 1 ] then
27693: LD_VAR 0 4
27697: PUSH
27698: LD_INT 1
27700: ARRAY
27701: IFFALSE 27705
// continue ;
27703: GO 27593
// h := hex [ 2 ] ;
27705: LD_ADDR_VAR 0 13
27709: PUSH
27710: LD_VAR 0 4
27714: PUSH
27715: LD_INT 2
27717: ARRAY
27718: ST_TO_ADDR
// if h + 7 < height then
27719: LD_VAR 0 13
27723: PUSH
27724: LD_INT 7
27726: PLUS
27727: PUSH
27728: LD_VAR 0 15
27732: LESS
27733: IFFALSE 27762
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27735: LD_ADDR_VAR 0 18
27739: PUSH
27740: LD_INT 7
27742: PUSH
27743: LD_INT 28
27745: PUSH
27746: LD_INT 45
27748: PUSH
27749: EMPTY
27750: LIST
27751: LIST
27752: LIST
27753: PUSH
27754: LD_VAR 0 12
27758: ARRAY
27759: ST_TO_ADDR
// break ;
27760: GO 27764
// end ; end ; end ;
27762: GO 27593
27764: POP
27765: POP
// end ; if not weapon then
27766: LD_VAR 0 18
27770: NOT
27771: IFFALSE 27831
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27773: LD_ADDR_VAR 0 5
27777: PUSH
27778: LD_VAR 0 5
27782: PUSH
27783: LD_INT 11
27785: PUSH
27786: LD_INT 30
27788: PUSH
27789: LD_INT 49
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: LIST
27796: DIFF
27797: ST_TO_ADDR
// if not list then
27798: LD_VAR 0 5
27802: NOT
27803: IFFALSE 27807
// exit ;
27805: GO 27949
// weapon := list [ rand ( 1 , list ) ] ;
27807: LD_ADDR_VAR 0 18
27811: PUSH
27812: LD_VAR 0 5
27816: PUSH
27817: LD_INT 1
27819: PPUSH
27820: LD_VAR 0 5
27824: PPUSH
27825: CALL_OW 12
27829: ARRAY
27830: ST_TO_ADDR
// end ; if weapon then
27831: LD_VAR 0 18
27835: IFFALSE 27949
// begin tmp := CostOfWeapon ( weapon ) ;
27837: LD_ADDR_VAR 0 14
27841: PUSH
27842: LD_VAR 0 18
27846: PPUSH
27847: CALL_OW 451
27851: ST_TO_ADDR
// j := GetBase ( tower ) ;
27852: LD_ADDR_VAR 0 9
27856: PUSH
27857: LD_VAR 0 1
27861: PPUSH
27862: CALL_OW 274
27866: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27867: LD_VAR 0 9
27871: PPUSH
27872: LD_INT 1
27874: PPUSH
27875: CALL_OW 275
27879: PUSH
27880: LD_VAR 0 14
27884: PUSH
27885: LD_INT 1
27887: ARRAY
27888: GREATEREQUAL
27889: PUSH
27890: LD_VAR 0 9
27894: PPUSH
27895: LD_INT 2
27897: PPUSH
27898: CALL_OW 275
27902: PUSH
27903: LD_VAR 0 14
27907: PUSH
27908: LD_INT 2
27910: ARRAY
27911: GREATEREQUAL
27912: AND
27913: PUSH
27914: LD_VAR 0 9
27918: PPUSH
27919: LD_INT 3
27921: PPUSH
27922: CALL_OW 275
27926: PUSH
27927: LD_VAR 0 14
27931: PUSH
27932: LD_INT 3
27934: ARRAY
27935: GREATEREQUAL
27936: AND
27937: IFFALSE 27949
// result := weapon ;
27939: LD_ADDR_VAR 0 3
27943: PUSH
27944: LD_VAR 0 18
27948: ST_TO_ADDR
// end ; end ;
27949: LD_VAR 0 3
27953: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27954: LD_INT 0
27956: PPUSH
27957: PPUSH
// result := true ;
27958: LD_ADDR_VAR 0 3
27962: PUSH
27963: LD_INT 1
27965: ST_TO_ADDR
// if array1 = array2 then
27966: LD_VAR 0 1
27970: PUSH
27971: LD_VAR 0 2
27975: EQUAL
27976: IFFALSE 28036
// begin for i = 1 to array1 do
27978: LD_ADDR_VAR 0 4
27982: PUSH
27983: DOUBLE
27984: LD_INT 1
27986: DEC
27987: ST_TO_ADDR
27988: LD_VAR 0 1
27992: PUSH
27993: FOR_TO
27994: IFFALSE 28032
// if array1 [ i ] <> array2 [ i ] then
27996: LD_VAR 0 1
28000: PUSH
28001: LD_VAR 0 4
28005: ARRAY
28006: PUSH
28007: LD_VAR 0 2
28011: PUSH
28012: LD_VAR 0 4
28016: ARRAY
28017: NONEQUAL
28018: IFFALSE 28030
// begin result := false ;
28020: LD_ADDR_VAR 0 3
28024: PUSH
28025: LD_INT 0
28027: ST_TO_ADDR
// break ;
28028: GO 28032
// end ;
28030: GO 27993
28032: POP
28033: POP
// end else
28034: GO 28044
// result := false ;
28036: LD_ADDR_VAR 0 3
28040: PUSH
28041: LD_INT 0
28043: ST_TO_ADDR
// end ;
28044: LD_VAR 0 3
28048: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
28049: LD_INT 0
28051: PPUSH
28052: PPUSH
// if not array1 or not array2 then
28053: LD_VAR 0 1
28057: NOT
28058: PUSH
28059: LD_VAR 0 2
28063: NOT
28064: OR
28065: IFFALSE 28069
// exit ;
28067: GO 28133
// result := true ;
28069: LD_ADDR_VAR 0 3
28073: PUSH
28074: LD_INT 1
28076: ST_TO_ADDR
// for i = 1 to array1 do
28077: LD_ADDR_VAR 0 4
28081: PUSH
28082: DOUBLE
28083: LD_INT 1
28085: DEC
28086: ST_TO_ADDR
28087: LD_VAR 0 1
28091: PUSH
28092: FOR_TO
28093: IFFALSE 28131
// if array1 [ i ] <> array2 [ i ] then
28095: LD_VAR 0 1
28099: PUSH
28100: LD_VAR 0 4
28104: ARRAY
28105: PUSH
28106: LD_VAR 0 2
28110: PUSH
28111: LD_VAR 0 4
28115: ARRAY
28116: NONEQUAL
28117: IFFALSE 28129
// begin result := false ;
28119: LD_ADDR_VAR 0 3
28123: PUSH
28124: LD_INT 0
28126: ST_TO_ADDR
// break ;
28127: GO 28131
// end ;
28129: GO 28092
28131: POP
28132: POP
// end ;
28133: LD_VAR 0 3
28137: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
28138: LD_INT 0
28140: PPUSH
28141: PPUSH
28142: PPUSH
// pom := GetBase ( fac ) ;
28143: LD_ADDR_VAR 0 5
28147: PUSH
28148: LD_VAR 0 1
28152: PPUSH
28153: CALL_OW 274
28157: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
28158: LD_ADDR_VAR 0 4
28162: PUSH
28163: LD_VAR 0 2
28167: PUSH
28168: LD_INT 1
28170: ARRAY
28171: PPUSH
28172: LD_VAR 0 2
28176: PUSH
28177: LD_INT 2
28179: ARRAY
28180: PPUSH
28181: LD_VAR 0 2
28185: PUSH
28186: LD_INT 3
28188: ARRAY
28189: PPUSH
28190: LD_VAR 0 2
28194: PUSH
28195: LD_INT 4
28197: ARRAY
28198: PPUSH
28199: CALL_OW 449
28203: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28204: LD_ADDR_VAR 0 3
28208: PUSH
28209: LD_VAR 0 5
28213: PPUSH
28214: LD_INT 1
28216: PPUSH
28217: CALL_OW 275
28221: PUSH
28222: LD_VAR 0 4
28226: PUSH
28227: LD_INT 1
28229: ARRAY
28230: GREATEREQUAL
28231: PUSH
28232: LD_VAR 0 5
28236: PPUSH
28237: LD_INT 2
28239: PPUSH
28240: CALL_OW 275
28244: PUSH
28245: LD_VAR 0 4
28249: PUSH
28250: LD_INT 2
28252: ARRAY
28253: GREATEREQUAL
28254: AND
28255: PUSH
28256: LD_VAR 0 5
28260: PPUSH
28261: LD_INT 3
28263: PPUSH
28264: CALL_OW 275
28268: PUSH
28269: LD_VAR 0 4
28273: PUSH
28274: LD_INT 3
28276: ARRAY
28277: GREATEREQUAL
28278: AND
28279: ST_TO_ADDR
// end ;
28280: LD_VAR 0 3
28284: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
28285: LD_INT 0
28287: PPUSH
28288: PPUSH
28289: PPUSH
28290: PPUSH
// pom := GetBase ( building ) ;
28291: LD_ADDR_VAR 0 3
28295: PUSH
28296: LD_VAR 0 1
28300: PPUSH
28301: CALL_OW 274
28305: ST_TO_ADDR
// if not pom then
28306: LD_VAR 0 3
28310: NOT
28311: IFFALSE 28315
// exit ;
28313: GO 28485
// btype := GetBType ( building ) ;
28315: LD_ADDR_VAR 0 5
28319: PUSH
28320: LD_VAR 0 1
28324: PPUSH
28325: CALL_OW 266
28329: ST_TO_ADDR
// if btype = b_armoury then
28330: LD_VAR 0 5
28334: PUSH
28335: LD_INT 4
28337: EQUAL
28338: IFFALSE 28348
// btype := b_barracks ;
28340: LD_ADDR_VAR 0 5
28344: PUSH
28345: LD_INT 5
28347: ST_TO_ADDR
// if btype = b_depot then
28348: LD_VAR 0 5
28352: PUSH
28353: LD_INT 0
28355: EQUAL
28356: IFFALSE 28366
// btype := b_warehouse ;
28358: LD_ADDR_VAR 0 5
28362: PUSH
28363: LD_INT 1
28365: ST_TO_ADDR
// if btype = b_workshop then
28366: LD_VAR 0 5
28370: PUSH
28371: LD_INT 2
28373: EQUAL
28374: IFFALSE 28384
// btype := b_factory ;
28376: LD_ADDR_VAR 0 5
28380: PUSH
28381: LD_INT 3
28383: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28384: LD_ADDR_VAR 0 4
28388: PUSH
28389: LD_VAR 0 5
28393: PPUSH
28394: LD_VAR 0 1
28398: PPUSH
28399: CALL_OW 248
28403: PPUSH
28404: CALL_OW 450
28408: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28409: LD_ADDR_VAR 0 2
28413: PUSH
28414: LD_VAR 0 3
28418: PPUSH
28419: LD_INT 1
28421: PPUSH
28422: CALL_OW 275
28426: PUSH
28427: LD_VAR 0 4
28431: PUSH
28432: LD_INT 1
28434: ARRAY
28435: GREATEREQUAL
28436: PUSH
28437: LD_VAR 0 3
28441: PPUSH
28442: LD_INT 2
28444: PPUSH
28445: CALL_OW 275
28449: PUSH
28450: LD_VAR 0 4
28454: PUSH
28455: LD_INT 2
28457: ARRAY
28458: GREATEREQUAL
28459: AND
28460: PUSH
28461: LD_VAR 0 3
28465: PPUSH
28466: LD_INT 3
28468: PPUSH
28469: CALL_OW 275
28473: PUSH
28474: LD_VAR 0 4
28478: PUSH
28479: LD_INT 3
28481: ARRAY
28482: GREATEREQUAL
28483: AND
28484: ST_TO_ADDR
// end ;
28485: LD_VAR 0 2
28489: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
28490: LD_INT 0
28492: PPUSH
28493: PPUSH
28494: PPUSH
// pom := GetBase ( building ) ;
28495: LD_ADDR_VAR 0 4
28499: PUSH
28500: LD_VAR 0 1
28504: PPUSH
28505: CALL_OW 274
28509: ST_TO_ADDR
// if not pom then
28510: LD_VAR 0 4
28514: NOT
28515: IFFALSE 28519
// exit ;
28517: GO 28620
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28519: LD_ADDR_VAR 0 5
28523: PUSH
28524: LD_VAR 0 2
28528: PPUSH
28529: LD_VAR 0 1
28533: PPUSH
28534: CALL_OW 248
28538: PPUSH
28539: CALL_OW 450
28543: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28544: LD_ADDR_VAR 0 3
28548: PUSH
28549: LD_VAR 0 4
28553: PPUSH
28554: LD_INT 1
28556: PPUSH
28557: CALL_OW 275
28561: PUSH
28562: LD_VAR 0 5
28566: PUSH
28567: LD_INT 1
28569: ARRAY
28570: GREATEREQUAL
28571: PUSH
28572: LD_VAR 0 4
28576: PPUSH
28577: LD_INT 2
28579: PPUSH
28580: CALL_OW 275
28584: PUSH
28585: LD_VAR 0 5
28589: PUSH
28590: LD_INT 2
28592: ARRAY
28593: GREATEREQUAL
28594: AND
28595: PUSH
28596: LD_VAR 0 4
28600: PPUSH
28601: LD_INT 3
28603: PPUSH
28604: CALL_OW 275
28608: PUSH
28609: LD_VAR 0 5
28613: PUSH
28614: LD_INT 3
28616: ARRAY
28617: GREATEREQUAL
28618: AND
28619: ST_TO_ADDR
// end ;
28620: LD_VAR 0 3
28624: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
28625: LD_INT 0
28627: PPUSH
28628: PPUSH
28629: PPUSH
28630: PPUSH
28631: PPUSH
28632: PPUSH
28633: PPUSH
28634: PPUSH
28635: PPUSH
28636: PPUSH
28637: PPUSH
// result := false ;
28638: LD_ADDR_VAR 0 8
28642: PUSH
28643: LD_INT 0
28645: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
28646: LD_VAR 0 5
28650: NOT
28651: PUSH
28652: LD_VAR 0 1
28656: NOT
28657: OR
28658: PUSH
28659: LD_VAR 0 2
28663: NOT
28664: OR
28665: PUSH
28666: LD_VAR 0 3
28670: NOT
28671: OR
28672: IFFALSE 28676
// exit ;
28674: GO 29490
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
28676: LD_ADDR_VAR 0 14
28680: PUSH
28681: LD_VAR 0 1
28685: PPUSH
28686: LD_VAR 0 2
28690: PPUSH
28691: LD_VAR 0 3
28695: PPUSH
28696: LD_VAR 0 4
28700: PPUSH
28701: LD_VAR 0 5
28705: PUSH
28706: LD_INT 1
28708: ARRAY
28709: PPUSH
28710: CALL_OW 248
28714: PPUSH
28715: LD_INT 0
28717: PPUSH
28718: CALL 30743 0 6
28722: ST_TO_ADDR
// if not hexes then
28723: LD_VAR 0 14
28727: NOT
28728: IFFALSE 28732
// exit ;
28730: GO 29490
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28732: LD_ADDR_VAR 0 17
28736: PUSH
28737: LD_VAR 0 5
28741: PPUSH
28742: LD_INT 22
28744: PUSH
28745: LD_VAR 0 13
28749: PPUSH
28750: CALL_OW 255
28754: PUSH
28755: EMPTY
28756: LIST
28757: LIST
28758: PUSH
28759: LD_INT 2
28761: PUSH
28762: LD_INT 30
28764: PUSH
28765: LD_INT 0
28767: PUSH
28768: EMPTY
28769: LIST
28770: LIST
28771: PUSH
28772: LD_INT 30
28774: PUSH
28775: LD_INT 1
28777: PUSH
28778: EMPTY
28779: LIST
28780: LIST
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: LIST
28786: PUSH
28787: EMPTY
28788: LIST
28789: LIST
28790: PPUSH
28791: CALL_OW 72
28795: ST_TO_ADDR
// for i = 1 to hexes do
28796: LD_ADDR_VAR 0 9
28800: PUSH
28801: DOUBLE
28802: LD_INT 1
28804: DEC
28805: ST_TO_ADDR
28806: LD_VAR 0 14
28810: PUSH
28811: FOR_TO
28812: IFFALSE 29488
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28814: LD_ADDR_VAR 0 13
28818: PUSH
28819: LD_VAR 0 14
28823: PUSH
28824: LD_VAR 0 9
28828: ARRAY
28829: PUSH
28830: LD_INT 1
28832: ARRAY
28833: PPUSH
28834: LD_VAR 0 14
28838: PUSH
28839: LD_VAR 0 9
28843: ARRAY
28844: PUSH
28845: LD_INT 2
28847: ARRAY
28848: PPUSH
28849: CALL_OW 428
28853: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28854: LD_VAR 0 14
28858: PUSH
28859: LD_VAR 0 9
28863: ARRAY
28864: PUSH
28865: LD_INT 1
28867: ARRAY
28868: PPUSH
28869: LD_VAR 0 14
28873: PUSH
28874: LD_VAR 0 9
28878: ARRAY
28879: PUSH
28880: LD_INT 2
28882: ARRAY
28883: PPUSH
28884: CALL_OW 351
28888: PUSH
28889: LD_VAR 0 14
28893: PUSH
28894: LD_VAR 0 9
28898: ARRAY
28899: PUSH
28900: LD_INT 1
28902: ARRAY
28903: PPUSH
28904: LD_VAR 0 14
28908: PUSH
28909: LD_VAR 0 9
28913: ARRAY
28914: PUSH
28915: LD_INT 2
28917: ARRAY
28918: PPUSH
28919: CALL_OW 488
28923: NOT
28924: OR
28925: PUSH
28926: LD_VAR 0 13
28930: PPUSH
28931: CALL_OW 247
28935: PUSH
28936: LD_INT 3
28938: EQUAL
28939: OR
28940: IFFALSE 28946
// exit ;
28942: POP
28943: POP
28944: GO 29490
// if not tmp then
28946: LD_VAR 0 13
28950: NOT
28951: IFFALSE 28955
// continue ;
28953: GO 28811
// result := true ;
28955: LD_ADDR_VAR 0 8
28959: PUSH
28960: LD_INT 1
28962: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
28963: LD_VAR 0 6
28967: PUSH
28968: LD_VAR 0 13
28972: PPUSH
28973: CALL_OW 247
28977: PUSH
28978: LD_INT 2
28980: EQUAL
28981: AND
28982: PUSH
28983: LD_VAR 0 13
28987: PPUSH
28988: CALL_OW 263
28992: PUSH
28993: LD_INT 1
28995: EQUAL
28996: AND
28997: IFFALSE 29161
// begin if IsDrivenBy ( tmp ) then
28999: LD_VAR 0 13
29003: PPUSH
29004: CALL_OW 311
29008: IFFALSE 29012
// continue ;
29010: GO 28811
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
29012: LD_VAR 0 6
29016: PPUSH
29017: LD_INT 3
29019: PUSH
29020: LD_INT 60
29022: PUSH
29023: EMPTY
29024: LIST
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: LD_INT 3
29032: PUSH
29033: LD_INT 55
29035: PUSH
29036: EMPTY
29037: LIST
29038: PUSH
29039: EMPTY
29040: LIST
29041: LIST
29042: PUSH
29043: EMPTY
29044: LIST
29045: LIST
29046: PPUSH
29047: CALL_OW 72
29051: IFFALSE 29159
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
29053: LD_ADDR_VAR 0 18
29057: PUSH
29058: LD_VAR 0 6
29062: PPUSH
29063: LD_INT 3
29065: PUSH
29066: LD_INT 60
29068: PUSH
29069: EMPTY
29070: LIST
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 3
29078: PUSH
29079: LD_INT 55
29081: PUSH
29082: EMPTY
29083: LIST
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PUSH
29089: EMPTY
29090: LIST
29091: LIST
29092: PPUSH
29093: CALL_OW 72
29097: PUSH
29098: LD_INT 1
29100: ARRAY
29101: ST_TO_ADDR
// if IsInUnit ( driver ) then
29102: LD_VAR 0 18
29106: PPUSH
29107: CALL_OW 310
29111: IFFALSE 29122
// ComExit ( driver ) ;
29113: LD_VAR 0 18
29117: PPUSH
29118: CALL 54535 0 1
// AddComEnterUnit ( driver , tmp ) ;
29122: LD_VAR 0 18
29126: PPUSH
29127: LD_VAR 0 13
29131: PPUSH
29132: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
29136: LD_VAR 0 18
29140: PPUSH
29141: LD_VAR 0 7
29145: PPUSH
29146: CALL_OW 173
// AddComExitVehicle ( driver ) ;
29150: LD_VAR 0 18
29154: PPUSH
29155: CALL_OW 181
// end ; continue ;
29159: GO 28811
// end ; if not cleaners or not tmp in cleaners then
29161: LD_VAR 0 6
29165: NOT
29166: PUSH
29167: LD_VAR 0 13
29171: PUSH
29172: LD_VAR 0 6
29176: IN
29177: NOT
29178: OR
29179: IFFALSE 29486
// begin if dep then
29181: LD_VAR 0 17
29185: IFFALSE 29321
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
29187: LD_ADDR_VAR 0 16
29191: PUSH
29192: LD_VAR 0 17
29196: PUSH
29197: LD_INT 1
29199: ARRAY
29200: PPUSH
29201: CALL_OW 250
29205: PPUSH
29206: LD_VAR 0 17
29210: PUSH
29211: LD_INT 1
29213: ARRAY
29214: PPUSH
29215: CALL_OW 254
29219: PPUSH
29220: LD_INT 5
29222: PPUSH
29223: CALL_OW 272
29227: PUSH
29228: LD_VAR 0 17
29232: PUSH
29233: LD_INT 1
29235: ARRAY
29236: PPUSH
29237: CALL_OW 251
29241: PPUSH
29242: LD_VAR 0 17
29246: PUSH
29247: LD_INT 1
29249: ARRAY
29250: PPUSH
29251: CALL_OW 254
29255: PPUSH
29256: LD_INT 5
29258: PPUSH
29259: CALL_OW 273
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
29268: LD_VAR 0 16
29272: PUSH
29273: LD_INT 1
29275: ARRAY
29276: PPUSH
29277: LD_VAR 0 16
29281: PUSH
29282: LD_INT 2
29284: ARRAY
29285: PPUSH
29286: CALL_OW 488
29290: IFFALSE 29321
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
29292: LD_VAR 0 13
29296: PPUSH
29297: LD_VAR 0 16
29301: PUSH
29302: LD_INT 1
29304: ARRAY
29305: PPUSH
29306: LD_VAR 0 16
29310: PUSH
29311: LD_INT 2
29313: ARRAY
29314: PPUSH
29315: CALL_OW 111
// continue ;
29319: GO 28811
// end ; end ; r := GetDir ( tmp ) ;
29321: LD_ADDR_VAR 0 15
29325: PUSH
29326: LD_VAR 0 13
29330: PPUSH
29331: CALL_OW 254
29335: ST_TO_ADDR
// if r = 5 then
29336: LD_VAR 0 15
29340: PUSH
29341: LD_INT 5
29343: EQUAL
29344: IFFALSE 29354
// r := 0 ;
29346: LD_ADDR_VAR 0 15
29350: PUSH
29351: LD_INT 0
29353: ST_TO_ADDR
// for j = r to 5 do
29354: LD_ADDR_VAR 0 10
29358: PUSH
29359: DOUBLE
29360: LD_VAR 0 15
29364: DEC
29365: ST_TO_ADDR
29366: LD_INT 5
29368: PUSH
29369: FOR_TO
29370: IFFALSE 29484
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
29372: LD_ADDR_VAR 0 11
29376: PUSH
29377: LD_VAR 0 13
29381: PPUSH
29382: CALL_OW 250
29386: PPUSH
29387: LD_VAR 0 10
29391: PPUSH
29392: LD_INT 2
29394: PPUSH
29395: CALL_OW 272
29399: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
29400: LD_ADDR_VAR 0 12
29404: PUSH
29405: LD_VAR 0 13
29409: PPUSH
29410: CALL_OW 251
29414: PPUSH
29415: LD_VAR 0 10
29419: PPUSH
29420: LD_INT 2
29422: PPUSH
29423: CALL_OW 273
29427: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
29428: LD_VAR 0 11
29432: PPUSH
29433: LD_VAR 0 12
29437: PPUSH
29438: CALL_OW 488
29442: PUSH
29443: LD_VAR 0 11
29447: PPUSH
29448: LD_VAR 0 12
29452: PPUSH
29453: CALL_OW 428
29457: NOT
29458: AND
29459: IFFALSE 29482
// begin ComMoveXY ( tmp , _x , _y ) ;
29461: LD_VAR 0 13
29465: PPUSH
29466: LD_VAR 0 11
29470: PPUSH
29471: LD_VAR 0 12
29475: PPUSH
29476: CALL_OW 111
// break ;
29480: GO 29484
// end ; end ;
29482: GO 29369
29484: POP
29485: POP
// end ; end ;
29486: GO 28811
29488: POP
29489: POP
// end ;
29490: LD_VAR 0 8
29494: RET
// export function BuildingTechInvented ( side , btype ) ; begin
29495: LD_INT 0
29497: PPUSH
// result := true ;
29498: LD_ADDR_VAR 0 3
29502: PUSH
29503: LD_INT 1
29505: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
29506: LD_VAR 0 2
29510: PUSH
29511: LD_INT 24
29513: DOUBLE
29514: EQUAL
29515: IFTRUE 29525
29517: LD_INT 33
29519: DOUBLE
29520: EQUAL
29521: IFTRUE 29525
29523: GO 29550
29525: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
29526: LD_ADDR_VAR 0 3
29530: PUSH
29531: LD_INT 32
29533: PPUSH
29534: LD_VAR 0 1
29538: PPUSH
29539: CALL_OW 321
29543: PUSH
29544: LD_INT 2
29546: EQUAL
29547: ST_TO_ADDR
29548: GO 29866
29550: LD_INT 20
29552: DOUBLE
29553: EQUAL
29554: IFTRUE 29558
29556: GO 29583
29558: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
29559: LD_ADDR_VAR 0 3
29563: PUSH
29564: LD_INT 6
29566: PPUSH
29567: LD_VAR 0 1
29571: PPUSH
29572: CALL_OW 321
29576: PUSH
29577: LD_INT 2
29579: EQUAL
29580: ST_TO_ADDR
29581: GO 29866
29583: LD_INT 22
29585: DOUBLE
29586: EQUAL
29587: IFTRUE 29597
29589: LD_INT 36
29591: DOUBLE
29592: EQUAL
29593: IFTRUE 29597
29595: GO 29622
29597: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
29598: LD_ADDR_VAR 0 3
29602: PUSH
29603: LD_INT 15
29605: PPUSH
29606: LD_VAR 0 1
29610: PPUSH
29611: CALL_OW 321
29615: PUSH
29616: LD_INT 2
29618: EQUAL
29619: ST_TO_ADDR
29620: GO 29866
29622: LD_INT 30
29624: DOUBLE
29625: EQUAL
29626: IFTRUE 29630
29628: GO 29655
29630: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
29631: LD_ADDR_VAR 0 3
29635: PUSH
29636: LD_INT 20
29638: PPUSH
29639: LD_VAR 0 1
29643: PPUSH
29644: CALL_OW 321
29648: PUSH
29649: LD_INT 2
29651: EQUAL
29652: ST_TO_ADDR
29653: GO 29866
29655: LD_INT 28
29657: DOUBLE
29658: EQUAL
29659: IFTRUE 29669
29661: LD_INT 21
29663: DOUBLE
29664: EQUAL
29665: IFTRUE 29669
29667: GO 29694
29669: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
29670: LD_ADDR_VAR 0 3
29674: PUSH
29675: LD_INT 21
29677: PPUSH
29678: LD_VAR 0 1
29682: PPUSH
29683: CALL_OW 321
29687: PUSH
29688: LD_INT 2
29690: EQUAL
29691: ST_TO_ADDR
29692: GO 29866
29694: LD_INT 16
29696: DOUBLE
29697: EQUAL
29698: IFTRUE 29702
29700: GO 29727
29702: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
29703: LD_ADDR_VAR 0 3
29707: PUSH
29708: LD_INT 84
29710: PPUSH
29711: LD_VAR 0 1
29715: PPUSH
29716: CALL_OW 321
29720: PUSH
29721: LD_INT 2
29723: EQUAL
29724: ST_TO_ADDR
29725: GO 29866
29727: LD_INT 19
29729: DOUBLE
29730: EQUAL
29731: IFTRUE 29741
29733: LD_INT 23
29735: DOUBLE
29736: EQUAL
29737: IFTRUE 29741
29739: GO 29766
29741: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
29742: LD_ADDR_VAR 0 3
29746: PUSH
29747: LD_INT 83
29749: PPUSH
29750: LD_VAR 0 1
29754: PPUSH
29755: CALL_OW 321
29759: PUSH
29760: LD_INT 2
29762: EQUAL
29763: ST_TO_ADDR
29764: GO 29866
29766: LD_INT 17
29768: DOUBLE
29769: EQUAL
29770: IFTRUE 29774
29772: GO 29799
29774: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
29775: LD_ADDR_VAR 0 3
29779: PUSH
29780: LD_INT 39
29782: PPUSH
29783: LD_VAR 0 1
29787: PPUSH
29788: CALL_OW 321
29792: PUSH
29793: LD_INT 2
29795: EQUAL
29796: ST_TO_ADDR
29797: GO 29866
29799: LD_INT 18
29801: DOUBLE
29802: EQUAL
29803: IFTRUE 29807
29805: GO 29832
29807: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
29808: LD_ADDR_VAR 0 3
29812: PUSH
29813: LD_INT 40
29815: PPUSH
29816: LD_VAR 0 1
29820: PPUSH
29821: CALL_OW 321
29825: PUSH
29826: LD_INT 2
29828: EQUAL
29829: ST_TO_ADDR
29830: GO 29866
29832: LD_INT 27
29834: DOUBLE
29835: EQUAL
29836: IFTRUE 29840
29838: GO 29865
29840: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
29841: LD_ADDR_VAR 0 3
29845: PUSH
29846: LD_INT 35
29848: PPUSH
29849: LD_VAR 0 1
29853: PPUSH
29854: CALL_OW 321
29858: PUSH
29859: LD_INT 2
29861: EQUAL
29862: ST_TO_ADDR
29863: GO 29866
29865: POP
// end ;
29866: LD_VAR 0 3
29870: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
29871: LD_INT 0
29873: PPUSH
29874: PPUSH
29875: PPUSH
29876: PPUSH
29877: PPUSH
29878: PPUSH
29879: PPUSH
29880: PPUSH
29881: PPUSH
29882: PPUSH
29883: PPUSH
// result := false ;
29884: LD_ADDR_VAR 0 6
29888: PUSH
29889: LD_INT 0
29891: ST_TO_ADDR
// if btype = b_depot then
29892: LD_VAR 0 2
29896: PUSH
29897: LD_INT 0
29899: EQUAL
29900: IFFALSE 29912
// begin result := true ;
29902: LD_ADDR_VAR 0 6
29906: PUSH
29907: LD_INT 1
29909: ST_TO_ADDR
// exit ;
29910: GO 30738
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
29912: LD_VAR 0 1
29916: NOT
29917: PUSH
29918: LD_VAR 0 1
29922: PPUSH
29923: CALL_OW 266
29927: PUSH
29928: LD_INT 0
29930: PUSH
29931: LD_INT 1
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: IN
29938: NOT
29939: OR
29940: PUSH
29941: LD_VAR 0 2
29945: NOT
29946: OR
29947: PUSH
29948: LD_VAR 0 5
29952: PUSH
29953: LD_INT 0
29955: PUSH
29956: LD_INT 1
29958: PUSH
29959: LD_INT 2
29961: PUSH
29962: LD_INT 3
29964: PUSH
29965: LD_INT 4
29967: PUSH
29968: LD_INT 5
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: LIST
29975: LIST
29976: LIST
29977: LIST
29978: IN
29979: NOT
29980: OR
29981: PUSH
29982: LD_VAR 0 3
29986: PPUSH
29987: LD_VAR 0 4
29991: PPUSH
29992: CALL_OW 488
29996: NOT
29997: OR
29998: IFFALSE 30002
// exit ;
30000: GO 30738
// side := GetSide ( depot ) ;
30002: LD_ADDR_VAR 0 9
30006: PUSH
30007: LD_VAR 0 1
30011: PPUSH
30012: CALL_OW 255
30016: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
30017: LD_VAR 0 9
30021: PPUSH
30022: LD_VAR 0 2
30026: PPUSH
30027: CALL 29495 0 2
30031: NOT
30032: IFFALSE 30036
// exit ;
30034: GO 30738
// pom := GetBase ( depot ) ;
30036: LD_ADDR_VAR 0 10
30040: PUSH
30041: LD_VAR 0 1
30045: PPUSH
30046: CALL_OW 274
30050: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
30051: LD_ADDR_VAR 0 11
30055: PUSH
30056: LD_VAR 0 2
30060: PPUSH
30061: LD_VAR 0 1
30065: PPUSH
30066: CALL_OW 248
30070: PPUSH
30071: CALL_OW 450
30075: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
30076: LD_VAR 0 10
30080: PPUSH
30081: LD_INT 1
30083: PPUSH
30084: CALL_OW 275
30088: PUSH
30089: LD_VAR 0 11
30093: PUSH
30094: LD_INT 1
30096: ARRAY
30097: GREATEREQUAL
30098: PUSH
30099: LD_VAR 0 10
30103: PPUSH
30104: LD_INT 2
30106: PPUSH
30107: CALL_OW 275
30111: PUSH
30112: LD_VAR 0 11
30116: PUSH
30117: LD_INT 2
30119: ARRAY
30120: GREATEREQUAL
30121: AND
30122: PUSH
30123: LD_VAR 0 10
30127: PPUSH
30128: LD_INT 3
30130: PPUSH
30131: CALL_OW 275
30135: PUSH
30136: LD_VAR 0 11
30140: PUSH
30141: LD_INT 3
30143: ARRAY
30144: GREATEREQUAL
30145: AND
30146: NOT
30147: IFFALSE 30151
// exit ;
30149: GO 30738
// if GetBType ( depot ) = b_depot then
30151: LD_VAR 0 1
30155: PPUSH
30156: CALL_OW 266
30160: PUSH
30161: LD_INT 0
30163: EQUAL
30164: IFFALSE 30176
// dist := 28 else
30166: LD_ADDR_VAR 0 14
30170: PUSH
30171: LD_INT 28
30173: ST_TO_ADDR
30174: GO 30184
// dist := 36 ;
30176: LD_ADDR_VAR 0 14
30180: PUSH
30181: LD_INT 36
30183: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
30184: LD_VAR 0 1
30188: PPUSH
30189: LD_VAR 0 3
30193: PPUSH
30194: LD_VAR 0 4
30198: PPUSH
30199: CALL_OW 297
30203: PUSH
30204: LD_VAR 0 14
30208: GREATER
30209: IFFALSE 30213
// exit ;
30211: GO 30738
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
30213: LD_ADDR_VAR 0 12
30217: PUSH
30218: LD_VAR 0 2
30222: PPUSH
30223: LD_VAR 0 3
30227: PPUSH
30228: LD_VAR 0 4
30232: PPUSH
30233: LD_VAR 0 5
30237: PPUSH
30238: LD_VAR 0 1
30242: PPUSH
30243: CALL_OW 248
30247: PPUSH
30248: LD_INT 0
30250: PPUSH
30251: CALL 30743 0 6
30255: ST_TO_ADDR
// if not hexes then
30256: LD_VAR 0 12
30260: NOT
30261: IFFALSE 30265
// exit ;
30263: GO 30738
// hex := GetHexInfo ( x , y ) ;
30265: LD_ADDR_VAR 0 15
30269: PUSH
30270: LD_VAR 0 3
30274: PPUSH
30275: LD_VAR 0 4
30279: PPUSH
30280: CALL_OW 546
30284: ST_TO_ADDR
// if hex [ 1 ] then
30285: LD_VAR 0 15
30289: PUSH
30290: LD_INT 1
30292: ARRAY
30293: IFFALSE 30297
// exit ;
30295: GO 30738
// height := hex [ 2 ] ;
30297: LD_ADDR_VAR 0 13
30301: PUSH
30302: LD_VAR 0 15
30306: PUSH
30307: LD_INT 2
30309: ARRAY
30310: ST_TO_ADDR
// for i = 1 to hexes do
30311: LD_ADDR_VAR 0 7
30315: PUSH
30316: DOUBLE
30317: LD_INT 1
30319: DEC
30320: ST_TO_ADDR
30321: LD_VAR 0 12
30325: PUSH
30326: FOR_TO
30327: IFFALSE 30657
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
30329: LD_VAR 0 12
30333: PUSH
30334: LD_VAR 0 7
30338: ARRAY
30339: PUSH
30340: LD_INT 1
30342: ARRAY
30343: PPUSH
30344: LD_VAR 0 12
30348: PUSH
30349: LD_VAR 0 7
30353: ARRAY
30354: PUSH
30355: LD_INT 2
30357: ARRAY
30358: PPUSH
30359: CALL_OW 488
30363: NOT
30364: PUSH
30365: LD_VAR 0 12
30369: PUSH
30370: LD_VAR 0 7
30374: ARRAY
30375: PUSH
30376: LD_INT 1
30378: ARRAY
30379: PPUSH
30380: LD_VAR 0 12
30384: PUSH
30385: LD_VAR 0 7
30389: ARRAY
30390: PUSH
30391: LD_INT 2
30393: ARRAY
30394: PPUSH
30395: CALL_OW 428
30399: PUSH
30400: LD_INT 0
30402: GREATER
30403: OR
30404: PUSH
30405: LD_VAR 0 12
30409: PUSH
30410: LD_VAR 0 7
30414: ARRAY
30415: PUSH
30416: LD_INT 1
30418: ARRAY
30419: PPUSH
30420: LD_VAR 0 12
30424: PUSH
30425: LD_VAR 0 7
30429: ARRAY
30430: PUSH
30431: LD_INT 2
30433: ARRAY
30434: PPUSH
30435: CALL_OW 351
30439: OR
30440: IFFALSE 30446
// exit ;
30442: POP
30443: POP
30444: GO 30738
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
30446: LD_ADDR_VAR 0 8
30450: PUSH
30451: LD_VAR 0 12
30455: PUSH
30456: LD_VAR 0 7
30460: ARRAY
30461: PUSH
30462: LD_INT 1
30464: ARRAY
30465: PPUSH
30466: LD_VAR 0 12
30470: PUSH
30471: LD_VAR 0 7
30475: ARRAY
30476: PUSH
30477: LD_INT 2
30479: ARRAY
30480: PPUSH
30481: CALL_OW 546
30485: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
30486: LD_VAR 0 8
30490: PUSH
30491: LD_INT 1
30493: ARRAY
30494: PUSH
30495: LD_VAR 0 8
30499: PUSH
30500: LD_INT 2
30502: ARRAY
30503: PUSH
30504: LD_VAR 0 13
30508: PUSH
30509: LD_INT 2
30511: PLUS
30512: GREATER
30513: OR
30514: PUSH
30515: LD_VAR 0 8
30519: PUSH
30520: LD_INT 2
30522: ARRAY
30523: PUSH
30524: LD_VAR 0 13
30528: PUSH
30529: LD_INT 2
30531: MINUS
30532: LESS
30533: OR
30534: PUSH
30535: LD_VAR 0 8
30539: PUSH
30540: LD_INT 3
30542: ARRAY
30543: PUSH
30544: LD_INT 0
30546: PUSH
30547: LD_INT 8
30549: PUSH
30550: LD_INT 9
30552: PUSH
30553: LD_INT 10
30555: PUSH
30556: LD_INT 11
30558: PUSH
30559: LD_INT 12
30561: PUSH
30562: LD_INT 13
30564: PUSH
30565: LD_INT 16
30567: PUSH
30568: LD_INT 17
30570: PUSH
30571: LD_INT 18
30573: PUSH
30574: LD_INT 19
30576: PUSH
30577: LD_INT 20
30579: PUSH
30580: LD_INT 21
30582: PUSH
30583: EMPTY
30584: LIST
30585: LIST
30586: LIST
30587: LIST
30588: LIST
30589: LIST
30590: LIST
30591: LIST
30592: LIST
30593: LIST
30594: LIST
30595: LIST
30596: LIST
30597: IN
30598: NOT
30599: OR
30600: PUSH
30601: LD_VAR 0 8
30605: PUSH
30606: LD_INT 5
30608: ARRAY
30609: NOT
30610: OR
30611: PUSH
30612: LD_VAR 0 8
30616: PUSH
30617: LD_INT 6
30619: ARRAY
30620: PUSH
30621: LD_INT 1
30623: PUSH
30624: LD_INT 2
30626: PUSH
30627: LD_INT 7
30629: PUSH
30630: LD_INT 9
30632: PUSH
30633: LD_INT 10
30635: PUSH
30636: LD_INT 11
30638: PUSH
30639: EMPTY
30640: LIST
30641: LIST
30642: LIST
30643: LIST
30644: LIST
30645: LIST
30646: IN
30647: NOT
30648: OR
30649: IFFALSE 30655
// exit ;
30651: POP
30652: POP
30653: GO 30738
// end ;
30655: GO 30326
30657: POP
30658: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
30659: LD_VAR 0 9
30663: PPUSH
30664: LD_VAR 0 3
30668: PPUSH
30669: LD_VAR 0 4
30673: PPUSH
30674: LD_INT 20
30676: PPUSH
30677: CALL 22661 0 4
30681: PUSH
30682: LD_INT 4
30684: ARRAY
30685: IFFALSE 30689
// exit ;
30687: GO 30738
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
30689: LD_VAR 0 2
30693: PUSH
30694: LD_INT 29
30696: PUSH
30697: LD_INT 30
30699: PUSH
30700: EMPTY
30701: LIST
30702: LIST
30703: IN
30704: PUSH
30705: LD_VAR 0 3
30709: PPUSH
30710: LD_VAR 0 4
30714: PPUSH
30715: LD_VAR 0 9
30719: PPUSH
30720: CALL_OW 440
30724: NOT
30725: AND
30726: IFFALSE 30730
// exit ;
30728: GO 30738
// result := true ;
30730: LD_ADDR_VAR 0 6
30734: PUSH
30735: LD_INT 1
30737: ST_TO_ADDR
// end ;
30738: LD_VAR 0 6
30742: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
30743: LD_INT 0
30745: PPUSH
30746: PPUSH
30747: PPUSH
30748: PPUSH
30749: PPUSH
30750: PPUSH
30751: PPUSH
30752: PPUSH
30753: PPUSH
30754: PPUSH
30755: PPUSH
30756: PPUSH
30757: PPUSH
30758: PPUSH
30759: PPUSH
30760: PPUSH
30761: PPUSH
30762: PPUSH
30763: PPUSH
30764: PPUSH
30765: PPUSH
30766: PPUSH
30767: PPUSH
30768: PPUSH
30769: PPUSH
30770: PPUSH
30771: PPUSH
30772: PPUSH
30773: PPUSH
30774: PPUSH
30775: PPUSH
30776: PPUSH
30777: PPUSH
30778: PPUSH
30779: PPUSH
30780: PPUSH
30781: PPUSH
30782: PPUSH
30783: PPUSH
30784: PPUSH
30785: PPUSH
30786: PPUSH
30787: PPUSH
30788: PPUSH
30789: PPUSH
30790: PPUSH
30791: PPUSH
30792: PPUSH
30793: PPUSH
30794: PPUSH
30795: PPUSH
30796: PPUSH
30797: PPUSH
30798: PPUSH
30799: PPUSH
30800: PPUSH
30801: PPUSH
30802: PPUSH
// result = [ ] ;
30803: LD_ADDR_VAR 0 7
30807: PUSH
30808: EMPTY
30809: ST_TO_ADDR
// temp_list = [ ] ;
30810: LD_ADDR_VAR 0 9
30814: PUSH
30815: EMPTY
30816: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
30817: LD_VAR 0 4
30821: PUSH
30822: LD_INT 0
30824: PUSH
30825: LD_INT 1
30827: PUSH
30828: LD_INT 2
30830: PUSH
30831: LD_INT 3
30833: PUSH
30834: LD_INT 4
30836: PUSH
30837: LD_INT 5
30839: PUSH
30840: EMPTY
30841: LIST
30842: LIST
30843: LIST
30844: LIST
30845: LIST
30846: LIST
30847: IN
30848: NOT
30849: PUSH
30850: LD_VAR 0 1
30854: PUSH
30855: LD_INT 0
30857: PUSH
30858: LD_INT 1
30860: PUSH
30861: EMPTY
30862: LIST
30863: LIST
30864: IN
30865: PUSH
30866: LD_VAR 0 5
30870: PUSH
30871: LD_INT 1
30873: PUSH
30874: LD_INT 2
30876: PUSH
30877: LD_INT 3
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: LIST
30884: IN
30885: NOT
30886: AND
30887: OR
30888: IFFALSE 30892
// exit ;
30890: GO 49283
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
30892: LD_VAR 0 1
30896: PUSH
30897: LD_INT 6
30899: PUSH
30900: LD_INT 7
30902: PUSH
30903: LD_INT 8
30905: PUSH
30906: LD_INT 13
30908: PUSH
30909: LD_INT 12
30911: PUSH
30912: LD_INT 15
30914: PUSH
30915: LD_INT 11
30917: PUSH
30918: LD_INT 14
30920: PUSH
30921: LD_INT 10
30923: PUSH
30924: EMPTY
30925: LIST
30926: LIST
30927: LIST
30928: LIST
30929: LIST
30930: LIST
30931: LIST
30932: LIST
30933: LIST
30934: IN
30935: IFFALSE 30945
// btype = b_lab ;
30937: LD_ADDR_VAR 0 1
30941: PUSH
30942: LD_INT 6
30944: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
30945: LD_VAR 0 6
30949: PUSH
30950: LD_INT 0
30952: PUSH
30953: LD_INT 1
30955: PUSH
30956: LD_INT 2
30958: PUSH
30959: EMPTY
30960: LIST
30961: LIST
30962: LIST
30963: IN
30964: NOT
30965: PUSH
30966: LD_VAR 0 1
30970: PUSH
30971: LD_INT 0
30973: PUSH
30974: LD_INT 1
30976: PUSH
30977: LD_INT 2
30979: PUSH
30980: LD_INT 3
30982: PUSH
30983: LD_INT 6
30985: PUSH
30986: LD_INT 36
30988: PUSH
30989: LD_INT 4
30991: PUSH
30992: LD_INT 5
30994: PUSH
30995: LD_INT 31
30997: PUSH
30998: LD_INT 32
31000: PUSH
31001: LD_INT 33
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: LIST
31008: LIST
31009: LIST
31010: LIST
31011: LIST
31012: LIST
31013: LIST
31014: LIST
31015: LIST
31016: IN
31017: NOT
31018: PUSH
31019: LD_VAR 0 6
31023: PUSH
31024: LD_INT 1
31026: EQUAL
31027: AND
31028: OR
31029: PUSH
31030: LD_VAR 0 1
31034: PUSH
31035: LD_INT 2
31037: PUSH
31038: LD_INT 3
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: IN
31045: NOT
31046: PUSH
31047: LD_VAR 0 6
31051: PUSH
31052: LD_INT 2
31054: EQUAL
31055: AND
31056: OR
31057: IFFALSE 31067
// mode = 0 ;
31059: LD_ADDR_VAR 0 6
31063: PUSH
31064: LD_INT 0
31066: ST_TO_ADDR
// case mode of 0 :
31067: LD_VAR 0 6
31071: PUSH
31072: LD_INT 0
31074: DOUBLE
31075: EQUAL
31076: IFTRUE 31080
31078: GO 42533
31080: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
31081: LD_ADDR_VAR 0 11
31085: PUSH
31086: LD_INT 0
31088: PUSH
31089: LD_INT 0
31091: PUSH
31092: EMPTY
31093: LIST
31094: LIST
31095: PUSH
31096: LD_INT 0
31098: PUSH
31099: LD_INT 1
31101: NEG
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 1
31109: PUSH
31110: LD_INT 0
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 1
31119: PUSH
31120: LD_INT 1
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: LD_INT 0
31129: PUSH
31130: LD_INT 1
31132: PUSH
31133: EMPTY
31134: LIST
31135: LIST
31136: PUSH
31137: LD_INT 1
31139: NEG
31140: PUSH
31141: LD_INT 0
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 1
31150: NEG
31151: PUSH
31152: LD_INT 1
31154: NEG
31155: PUSH
31156: EMPTY
31157: LIST
31158: LIST
31159: PUSH
31160: LD_INT 1
31162: NEG
31163: PUSH
31164: LD_INT 2
31166: NEG
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 0
31174: PUSH
31175: LD_INT 2
31177: NEG
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: LD_INT 1
31185: PUSH
31186: LD_INT 1
31188: NEG
31189: PUSH
31190: EMPTY
31191: LIST
31192: LIST
31193: PUSH
31194: LD_INT 1
31196: PUSH
31197: LD_INT 2
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: LD_INT 0
31206: PUSH
31207: LD_INT 2
31209: PUSH
31210: EMPTY
31211: LIST
31212: LIST
31213: PUSH
31214: LD_INT 1
31216: NEG
31217: PUSH
31218: LD_INT 1
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 1
31227: PUSH
31228: LD_INT 3
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 0
31237: PUSH
31238: LD_INT 3
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: LD_INT 1
31247: NEG
31248: PUSH
31249: LD_INT 2
31251: PUSH
31252: EMPTY
31253: LIST
31254: LIST
31255: PUSH
31256: EMPTY
31257: LIST
31258: LIST
31259: LIST
31260: LIST
31261: LIST
31262: LIST
31263: LIST
31264: LIST
31265: LIST
31266: LIST
31267: LIST
31268: LIST
31269: LIST
31270: LIST
31271: LIST
31272: LIST
31273: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31274: LD_ADDR_VAR 0 12
31278: PUSH
31279: LD_INT 0
31281: PUSH
31282: LD_INT 0
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 0
31291: PUSH
31292: LD_INT 1
31294: NEG
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PUSH
31300: LD_INT 1
31302: PUSH
31303: LD_INT 0
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: PUSH
31310: LD_INT 1
31312: PUSH
31313: LD_INT 1
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: LD_INT 0
31322: PUSH
31323: LD_INT 1
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 1
31332: NEG
31333: PUSH
31334: LD_INT 0
31336: PUSH
31337: EMPTY
31338: LIST
31339: LIST
31340: PUSH
31341: LD_INT 1
31343: NEG
31344: PUSH
31345: LD_INT 1
31347: NEG
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: PUSH
31353: LD_INT 1
31355: PUSH
31356: LD_INT 1
31358: NEG
31359: PUSH
31360: EMPTY
31361: LIST
31362: LIST
31363: PUSH
31364: LD_INT 2
31366: PUSH
31367: LD_INT 0
31369: PUSH
31370: EMPTY
31371: LIST
31372: LIST
31373: PUSH
31374: LD_INT 2
31376: PUSH
31377: LD_INT 1
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 1
31386: NEG
31387: PUSH
31388: LD_INT 1
31390: PUSH
31391: EMPTY
31392: LIST
31393: LIST
31394: PUSH
31395: LD_INT 2
31397: NEG
31398: PUSH
31399: LD_INT 0
31401: PUSH
31402: EMPTY
31403: LIST
31404: LIST
31405: PUSH
31406: LD_INT 2
31408: NEG
31409: PUSH
31410: LD_INT 1
31412: NEG
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 2
31420: NEG
31421: PUSH
31422: LD_INT 1
31424: PUSH
31425: EMPTY
31426: LIST
31427: LIST
31428: PUSH
31429: LD_INT 3
31431: NEG
31432: PUSH
31433: LD_INT 0
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PUSH
31440: LD_INT 3
31442: NEG
31443: PUSH
31444: LD_INT 1
31446: NEG
31447: PUSH
31448: EMPTY
31449: LIST
31450: LIST
31451: PUSH
31452: EMPTY
31453: LIST
31454: LIST
31455: LIST
31456: LIST
31457: LIST
31458: LIST
31459: LIST
31460: LIST
31461: LIST
31462: LIST
31463: LIST
31464: LIST
31465: LIST
31466: LIST
31467: LIST
31468: LIST
31469: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31470: LD_ADDR_VAR 0 13
31474: PUSH
31475: LD_INT 0
31477: PUSH
31478: LD_INT 0
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PUSH
31485: LD_INT 0
31487: PUSH
31488: LD_INT 1
31490: NEG
31491: PUSH
31492: EMPTY
31493: LIST
31494: LIST
31495: PUSH
31496: LD_INT 1
31498: PUSH
31499: LD_INT 0
31501: PUSH
31502: EMPTY
31503: LIST
31504: LIST
31505: PUSH
31506: LD_INT 1
31508: PUSH
31509: LD_INT 1
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PUSH
31516: LD_INT 0
31518: PUSH
31519: LD_INT 1
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PUSH
31526: LD_INT 1
31528: NEG
31529: PUSH
31530: LD_INT 0
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: PUSH
31537: LD_INT 1
31539: NEG
31540: PUSH
31541: LD_INT 1
31543: NEG
31544: PUSH
31545: EMPTY
31546: LIST
31547: LIST
31548: PUSH
31549: LD_INT 1
31551: NEG
31552: PUSH
31553: LD_INT 2
31555: NEG
31556: PUSH
31557: EMPTY
31558: LIST
31559: LIST
31560: PUSH
31561: LD_INT 2
31563: PUSH
31564: LD_INT 1
31566: PUSH
31567: EMPTY
31568: LIST
31569: LIST
31570: PUSH
31571: LD_INT 2
31573: PUSH
31574: LD_INT 2
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 1
31583: PUSH
31584: LD_INT 2
31586: PUSH
31587: EMPTY
31588: LIST
31589: LIST
31590: PUSH
31591: LD_INT 2
31593: NEG
31594: PUSH
31595: LD_INT 1
31597: NEG
31598: PUSH
31599: EMPTY
31600: LIST
31601: LIST
31602: PUSH
31603: LD_INT 2
31605: NEG
31606: PUSH
31607: LD_INT 2
31609: NEG
31610: PUSH
31611: EMPTY
31612: LIST
31613: LIST
31614: PUSH
31615: LD_INT 2
31617: NEG
31618: PUSH
31619: LD_INT 3
31621: NEG
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: PUSH
31627: LD_INT 3
31629: NEG
31630: PUSH
31631: LD_INT 2
31633: NEG
31634: PUSH
31635: EMPTY
31636: LIST
31637: LIST
31638: PUSH
31639: LD_INT 3
31641: NEG
31642: PUSH
31643: LD_INT 3
31645: NEG
31646: PUSH
31647: EMPTY
31648: LIST
31649: LIST
31650: PUSH
31651: EMPTY
31652: LIST
31653: LIST
31654: LIST
31655: LIST
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: LIST
31667: LIST
31668: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
31669: LD_ADDR_VAR 0 14
31673: PUSH
31674: LD_INT 0
31676: PUSH
31677: LD_INT 0
31679: PUSH
31680: EMPTY
31681: LIST
31682: LIST
31683: PUSH
31684: LD_INT 0
31686: PUSH
31687: LD_INT 1
31689: NEG
31690: PUSH
31691: EMPTY
31692: LIST
31693: LIST
31694: PUSH
31695: LD_INT 1
31697: PUSH
31698: LD_INT 0
31700: PUSH
31701: EMPTY
31702: LIST
31703: LIST
31704: PUSH
31705: LD_INT 1
31707: PUSH
31708: LD_INT 1
31710: PUSH
31711: EMPTY
31712: LIST
31713: LIST
31714: PUSH
31715: LD_INT 0
31717: PUSH
31718: LD_INT 1
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: PUSH
31725: LD_INT 1
31727: NEG
31728: PUSH
31729: LD_INT 0
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: PUSH
31736: LD_INT 1
31738: NEG
31739: PUSH
31740: LD_INT 1
31742: NEG
31743: PUSH
31744: EMPTY
31745: LIST
31746: LIST
31747: PUSH
31748: LD_INT 1
31750: NEG
31751: PUSH
31752: LD_INT 2
31754: NEG
31755: PUSH
31756: EMPTY
31757: LIST
31758: LIST
31759: PUSH
31760: LD_INT 0
31762: PUSH
31763: LD_INT 2
31765: NEG
31766: PUSH
31767: EMPTY
31768: LIST
31769: LIST
31770: PUSH
31771: LD_INT 1
31773: PUSH
31774: LD_INT 1
31776: NEG
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: PUSH
31782: LD_INT 1
31784: PUSH
31785: LD_INT 2
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: LD_INT 0
31794: PUSH
31795: LD_INT 2
31797: PUSH
31798: EMPTY
31799: LIST
31800: LIST
31801: PUSH
31802: LD_INT 1
31804: NEG
31805: PUSH
31806: LD_INT 1
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 1
31815: NEG
31816: PUSH
31817: LD_INT 3
31819: NEG
31820: PUSH
31821: EMPTY
31822: LIST
31823: LIST
31824: PUSH
31825: LD_INT 0
31827: PUSH
31828: LD_INT 3
31830: NEG
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: PUSH
31836: LD_INT 1
31838: PUSH
31839: LD_INT 2
31841: NEG
31842: PUSH
31843: EMPTY
31844: LIST
31845: LIST
31846: PUSH
31847: EMPTY
31848: LIST
31849: LIST
31850: LIST
31851: LIST
31852: LIST
31853: LIST
31854: LIST
31855: LIST
31856: LIST
31857: LIST
31858: LIST
31859: LIST
31860: LIST
31861: LIST
31862: LIST
31863: LIST
31864: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
31865: LD_ADDR_VAR 0 15
31869: PUSH
31870: LD_INT 0
31872: PUSH
31873: LD_INT 0
31875: PUSH
31876: EMPTY
31877: LIST
31878: LIST
31879: PUSH
31880: LD_INT 0
31882: PUSH
31883: LD_INT 1
31885: NEG
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 1
31893: PUSH
31894: LD_INT 0
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 1
31903: PUSH
31904: LD_INT 1
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 0
31913: PUSH
31914: LD_INT 1
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 1
31923: NEG
31924: PUSH
31925: LD_INT 0
31927: PUSH
31928: EMPTY
31929: LIST
31930: LIST
31931: PUSH
31932: LD_INT 1
31934: NEG
31935: PUSH
31936: LD_INT 1
31938: NEG
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: PUSH
31944: LD_INT 1
31946: PUSH
31947: LD_INT 1
31949: NEG
31950: PUSH
31951: EMPTY
31952: LIST
31953: LIST
31954: PUSH
31955: LD_INT 2
31957: PUSH
31958: LD_INT 0
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PUSH
31965: LD_INT 2
31967: PUSH
31968: LD_INT 1
31970: PUSH
31971: EMPTY
31972: LIST
31973: LIST
31974: PUSH
31975: LD_INT 1
31977: NEG
31978: PUSH
31979: LD_INT 1
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: PUSH
31986: LD_INT 2
31988: NEG
31989: PUSH
31990: LD_INT 0
31992: PUSH
31993: EMPTY
31994: LIST
31995: LIST
31996: PUSH
31997: LD_INT 2
31999: NEG
32000: PUSH
32001: LD_INT 1
32003: NEG
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 2
32011: PUSH
32012: LD_INT 1
32014: NEG
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 3
32022: PUSH
32023: LD_INT 0
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 3
32032: PUSH
32033: LD_INT 1
32035: PUSH
32036: EMPTY
32037: LIST
32038: LIST
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
32058: LD_ADDR_VAR 0 16
32062: PUSH
32063: LD_INT 0
32065: PUSH
32066: LD_INT 0
32068: PUSH
32069: EMPTY
32070: LIST
32071: LIST
32072: PUSH
32073: LD_INT 0
32075: PUSH
32076: LD_INT 1
32078: NEG
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: PUSH
32084: LD_INT 1
32086: PUSH
32087: LD_INT 0
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: PUSH
32094: LD_INT 1
32096: PUSH
32097: LD_INT 1
32099: PUSH
32100: EMPTY
32101: LIST
32102: LIST
32103: PUSH
32104: LD_INT 0
32106: PUSH
32107: LD_INT 1
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 1
32116: NEG
32117: PUSH
32118: LD_INT 0
32120: PUSH
32121: EMPTY
32122: LIST
32123: LIST
32124: PUSH
32125: LD_INT 1
32127: NEG
32128: PUSH
32129: LD_INT 1
32131: NEG
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: PUSH
32137: LD_INT 1
32139: NEG
32140: PUSH
32141: LD_INT 2
32143: NEG
32144: PUSH
32145: EMPTY
32146: LIST
32147: LIST
32148: PUSH
32149: LD_INT 2
32151: PUSH
32152: LD_INT 1
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 2
32161: PUSH
32162: LD_INT 2
32164: PUSH
32165: EMPTY
32166: LIST
32167: LIST
32168: PUSH
32169: LD_INT 1
32171: PUSH
32172: LD_INT 2
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: PUSH
32179: LD_INT 2
32181: NEG
32182: PUSH
32183: LD_INT 1
32185: NEG
32186: PUSH
32187: EMPTY
32188: LIST
32189: LIST
32190: PUSH
32191: LD_INT 2
32193: NEG
32194: PUSH
32195: LD_INT 2
32197: NEG
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: PUSH
32203: LD_INT 3
32205: PUSH
32206: LD_INT 2
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: PUSH
32213: LD_INT 3
32215: PUSH
32216: LD_INT 3
32218: PUSH
32219: EMPTY
32220: LIST
32221: LIST
32222: PUSH
32223: LD_INT 2
32225: PUSH
32226: LD_INT 3
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: PUSH
32233: EMPTY
32234: LIST
32235: LIST
32236: LIST
32237: LIST
32238: LIST
32239: LIST
32240: LIST
32241: LIST
32242: LIST
32243: LIST
32244: LIST
32245: LIST
32246: LIST
32247: LIST
32248: LIST
32249: LIST
32250: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32251: LD_ADDR_VAR 0 17
32255: PUSH
32256: LD_INT 0
32258: PUSH
32259: LD_INT 0
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 0
32268: PUSH
32269: LD_INT 1
32271: NEG
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 1
32279: PUSH
32280: LD_INT 0
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 1
32289: PUSH
32290: LD_INT 1
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 0
32299: PUSH
32300: LD_INT 1
32302: PUSH
32303: EMPTY
32304: LIST
32305: LIST
32306: PUSH
32307: LD_INT 1
32309: NEG
32310: PUSH
32311: LD_INT 0
32313: PUSH
32314: EMPTY
32315: LIST
32316: LIST
32317: PUSH
32318: LD_INT 1
32320: NEG
32321: PUSH
32322: LD_INT 1
32324: NEG
32325: PUSH
32326: EMPTY
32327: LIST
32328: LIST
32329: PUSH
32330: LD_INT 1
32332: NEG
32333: PUSH
32334: LD_INT 2
32336: NEG
32337: PUSH
32338: EMPTY
32339: LIST
32340: LIST
32341: PUSH
32342: LD_INT 0
32344: PUSH
32345: LD_INT 2
32347: NEG
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: LD_INT 1
32355: PUSH
32356: LD_INT 1
32358: NEG
32359: PUSH
32360: EMPTY
32361: LIST
32362: LIST
32363: PUSH
32364: LD_INT 2
32366: PUSH
32367: LD_INT 0
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 2
32376: PUSH
32377: LD_INT 1
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 2
32386: PUSH
32387: LD_INT 2
32389: PUSH
32390: EMPTY
32391: LIST
32392: LIST
32393: PUSH
32394: LD_INT 1
32396: PUSH
32397: LD_INT 2
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PUSH
32404: LD_INT 0
32406: PUSH
32407: LD_INT 2
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 1
32416: NEG
32417: PUSH
32418: LD_INT 1
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 2
32427: NEG
32428: PUSH
32429: LD_INT 0
32431: PUSH
32432: EMPTY
32433: LIST
32434: LIST
32435: PUSH
32436: LD_INT 2
32438: NEG
32439: PUSH
32440: LD_INT 1
32442: NEG
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PUSH
32448: LD_INT 2
32450: NEG
32451: PUSH
32452: LD_INT 2
32454: NEG
32455: PUSH
32456: EMPTY
32457: LIST
32458: LIST
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: LIST
32464: LIST
32465: LIST
32466: LIST
32467: LIST
32468: LIST
32469: LIST
32470: LIST
32471: LIST
32472: LIST
32473: LIST
32474: LIST
32475: LIST
32476: LIST
32477: LIST
32478: LIST
32479: LIST
32480: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32481: LD_ADDR_VAR 0 18
32485: PUSH
32486: LD_INT 0
32488: PUSH
32489: LD_INT 0
32491: PUSH
32492: EMPTY
32493: LIST
32494: LIST
32495: PUSH
32496: LD_INT 0
32498: PUSH
32499: LD_INT 1
32501: NEG
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 1
32509: PUSH
32510: LD_INT 0
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: PUSH
32517: LD_INT 1
32519: PUSH
32520: LD_INT 1
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PUSH
32527: LD_INT 0
32529: PUSH
32530: LD_INT 1
32532: PUSH
32533: EMPTY
32534: LIST
32535: LIST
32536: PUSH
32537: LD_INT 1
32539: NEG
32540: PUSH
32541: LD_INT 0
32543: PUSH
32544: EMPTY
32545: LIST
32546: LIST
32547: PUSH
32548: LD_INT 1
32550: NEG
32551: PUSH
32552: LD_INT 1
32554: NEG
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 1
32562: NEG
32563: PUSH
32564: LD_INT 2
32566: NEG
32567: PUSH
32568: EMPTY
32569: LIST
32570: LIST
32571: PUSH
32572: LD_INT 0
32574: PUSH
32575: LD_INT 2
32577: NEG
32578: PUSH
32579: EMPTY
32580: LIST
32581: LIST
32582: PUSH
32583: LD_INT 1
32585: PUSH
32586: LD_INT 1
32588: NEG
32589: PUSH
32590: EMPTY
32591: LIST
32592: LIST
32593: PUSH
32594: LD_INT 2
32596: PUSH
32597: LD_INT 0
32599: PUSH
32600: EMPTY
32601: LIST
32602: LIST
32603: PUSH
32604: LD_INT 2
32606: PUSH
32607: LD_INT 1
32609: PUSH
32610: EMPTY
32611: LIST
32612: LIST
32613: PUSH
32614: LD_INT 2
32616: PUSH
32617: LD_INT 2
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 1
32626: PUSH
32627: LD_INT 2
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: PUSH
32634: LD_INT 0
32636: PUSH
32637: LD_INT 2
32639: PUSH
32640: EMPTY
32641: LIST
32642: LIST
32643: PUSH
32644: LD_INT 1
32646: NEG
32647: PUSH
32648: LD_INT 1
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PUSH
32655: LD_INT 2
32657: NEG
32658: PUSH
32659: LD_INT 0
32661: PUSH
32662: EMPTY
32663: LIST
32664: LIST
32665: PUSH
32666: LD_INT 2
32668: NEG
32669: PUSH
32670: LD_INT 1
32672: NEG
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 2
32680: NEG
32681: PUSH
32682: LD_INT 2
32684: NEG
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PUSH
32690: EMPTY
32691: LIST
32692: LIST
32693: LIST
32694: LIST
32695: LIST
32696: LIST
32697: LIST
32698: LIST
32699: LIST
32700: LIST
32701: LIST
32702: LIST
32703: LIST
32704: LIST
32705: LIST
32706: LIST
32707: LIST
32708: LIST
32709: LIST
32710: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32711: LD_ADDR_VAR 0 19
32715: PUSH
32716: LD_INT 0
32718: PUSH
32719: LD_INT 0
32721: PUSH
32722: EMPTY
32723: LIST
32724: LIST
32725: PUSH
32726: LD_INT 0
32728: PUSH
32729: LD_INT 1
32731: NEG
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: LD_INT 1
32739: PUSH
32740: LD_INT 0
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 1
32749: PUSH
32750: LD_INT 1
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: LD_INT 0
32759: PUSH
32760: LD_INT 1
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: PUSH
32767: LD_INT 1
32769: NEG
32770: PUSH
32771: LD_INT 0
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 1
32780: NEG
32781: PUSH
32782: LD_INT 1
32784: NEG
32785: PUSH
32786: EMPTY
32787: LIST
32788: LIST
32789: PUSH
32790: LD_INT 1
32792: NEG
32793: PUSH
32794: LD_INT 2
32796: NEG
32797: PUSH
32798: EMPTY
32799: LIST
32800: LIST
32801: PUSH
32802: LD_INT 0
32804: PUSH
32805: LD_INT 2
32807: NEG
32808: PUSH
32809: EMPTY
32810: LIST
32811: LIST
32812: PUSH
32813: LD_INT 1
32815: PUSH
32816: LD_INT 1
32818: NEG
32819: PUSH
32820: EMPTY
32821: LIST
32822: LIST
32823: PUSH
32824: LD_INT 2
32826: PUSH
32827: LD_INT 0
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 2
32836: PUSH
32837: LD_INT 1
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: LD_INT 2
32846: PUSH
32847: LD_INT 2
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PUSH
32854: LD_INT 1
32856: PUSH
32857: LD_INT 2
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 0
32866: PUSH
32867: LD_INT 2
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: PUSH
32874: LD_INT 1
32876: NEG
32877: PUSH
32878: LD_INT 1
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: LD_INT 2
32887: NEG
32888: PUSH
32889: LD_INT 0
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: PUSH
32896: LD_INT 2
32898: NEG
32899: PUSH
32900: LD_INT 1
32902: NEG
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 2
32910: NEG
32911: PUSH
32912: LD_INT 2
32914: NEG
32915: PUSH
32916: EMPTY
32917: LIST
32918: LIST
32919: PUSH
32920: EMPTY
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32941: LD_ADDR_VAR 0 20
32945: PUSH
32946: LD_INT 0
32948: PUSH
32949: LD_INT 0
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: PUSH
32956: LD_INT 0
32958: PUSH
32959: LD_INT 1
32961: NEG
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 1
32969: PUSH
32970: LD_INT 0
32972: PUSH
32973: EMPTY
32974: LIST
32975: LIST
32976: PUSH
32977: LD_INT 1
32979: PUSH
32980: LD_INT 1
32982: PUSH
32983: EMPTY
32984: LIST
32985: LIST
32986: PUSH
32987: LD_INT 0
32989: PUSH
32990: LD_INT 1
32992: PUSH
32993: EMPTY
32994: LIST
32995: LIST
32996: PUSH
32997: LD_INT 1
32999: NEG
33000: PUSH
33001: LD_INT 0
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 1
33010: NEG
33011: PUSH
33012: LD_INT 1
33014: NEG
33015: PUSH
33016: EMPTY
33017: LIST
33018: LIST
33019: PUSH
33020: LD_INT 1
33022: NEG
33023: PUSH
33024: LD_INT 2
33026: NEG
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PUSH
33032: LD_INT 0
33034: PUSH
33035: LD_INT 2
33037: NEG
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: PUSH
33043: LD_INT 1
33045: PUSH
33046: LD_INT 1
33048: NEG
33049: PUSH
33050: EMPTY
33051: LIST
33052: LIST
33053: PUSH
33054: LD_INT 2
33056: PUSH
33057: LD_INT 0
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: PUSH
33064: LD_INT 2
33066: PUSH
33067: LD_INT 1
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: PUSH
33074: LD_INT 2
33076: PUSH
33077: LD_INT 2
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: PUSH
33084: LD_INT 1
33086: PUSH
33087: LD_INT 2
33089: PUSH
33090: EMPTY
33091: LIST
33092: LIST
33093: PUSH
33094: LD_INT 0
33096: PUSH
33097: LD_INT 2
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 1
33106: NEG
33107: PUSH
33108: LD_INT 1
33110: PUSH
33111: EMPTY
33112: LIST
33113: LIST
33114: PUSH
33115: LD_INT 2
33117: NEG
33118: PUSH
33119: LD_INT 0
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: PUSH
33126: LD_INT 2
33128: NEG
33129: PUSH
33130: LD_INT 1
33132: NEG
33133: PUSH
33134: EMPTY
33135: LIST
33136: LIST
33137: PUSH
33138: LD_INT 2
33140: NEG
33141: PUSH
33142: LD_INT 2
33144: NEG
33145: PUSH
33146: EMPTY
33147: LIST
33148: LIST
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33171: LD_ADDR_VAR 0 21
33175: PUSH
33176: LD_INT 0
33178: PUSH
33179: LD_INT 0
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 0
33188: PUSH
33189: LD_INT 1
33191: NEG
33192: PUSH
33193: EMPTY
33194: LIST
33195: LIST
33196: PUSH
33197: LD_INT 1
33199: PUSH
33200: LD_INT 0
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 1
33209: PUSH
33210: LD_INT 1
33212: PUSH
33213: EMPTY
33214: LIST
33215: LIST
33216: PUSH
33217: LD_INT 0
33219: PUSH
33220: LD_INT 1
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 1
33229: NEG
33230: PUSH
33231: LD_INT 0
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: PUSH
33238: LD_INT 1
33240: NEG
33241: PUSH
33242: LD_INT 1
33244: NEG
33245: PUSH
33246: EMPTY
33247: LIST
33248: LIST
33249: PUSH
33250: LD_INT 1
33252: NEG
33253: PUSH
33254: LD_INT 2
33256: NEG
33257: PUSH
33258: EMPTY
33259: LIST
33260: LIST
33261: PUSH
33262: LD_INT 0
33264: PUSH
33265: LD_INT 2
33267: NEG
33268: PUSH
33269: EMPTY
33270: LIST
33271: LIST
33272: PUSH
33273: LD_INT 1
33275: PUSH
33276: LD_INT 1
33278: NEG
33279: PUSH
33280: EMPTY
33281: LIST
33282: LIST
33283: PUSH
33284: LD_INT 2
33286: PUSH
33287: LD_INT 0
33289: PUSH
33290: EMPTY
33291: LIST
33292: LIST
33293: PUSH
33294: LD_INT 2
33296: PUSH
33297: LD_INT 1
33299: PUSH
33300: EMPTY
33301: LIST
33302: LIST
33303: PUSH
33304: LD_INT 2
33306: PUSH
33307: LD_INT 2
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 1
33316: PUSH
33317: LD_INT 2
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: PUSH
33324: LD_INT 0
33326: PUSH
33327: LD_INT 2
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 1
33336: NEG
33337: PUSH
33338: LD_INT 1
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 2
33347: NEG
33348: PUSH
33349: LD_INT 0
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PUSH
33356: LD_INT 2
33358: NEG
33359: PUSH
33360: LD_INT 1
33362: NEG
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 2
33370: NEG
33371: PUSH
33372: LD_INT 2
33374: NEG
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: LIST
33384: LIST
33385: LIST
33386: LIST
33387: LIST
33388: LIST
33389: LIST
33390: LIST
33391: LIST
33392: LIST
33393: LIST
33394: LIST
33395: LIST
33396: LIST
33397: LIST
33398: LIST
33399: LIST
33400: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33401: LD_ADDR_VAR 0 22
33405: PUSH
33406: LD_INT 0
33408: PUSH
33409: LD_INT 0
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: LD_INT 0
33418: PUSH
33419: LD_INT 1
33421: NEG
33422: PUSH
33423: EMPTY
33424: LIST
33425: LIST
33426: PUSH
33427: LD_INT 1
33429: PUSH
33430: LD_INT 0
33432: PUSH
33433: EMPTY
33434: LIST
33435: LIST
33436: PUSH
33437: LD_INT 1
33439: PUSH
33440: LD_INT 1
33442: PUSH
33443: EMPTY
33444: LIST
33445: LIST
33446: PUSH
33447: LD_INT 0
33449: PUSH
33450: LD_INT 1
33452: PUSH
33453: EMPTY
33454: LIST
33455: LIST
33456: PUSH
33457: LD_INT 1
33459: NEG
33460: PUSH
33461: LD_INT 0
33463: PUSH
33464: EMPTY
33465: LIST
33466: LIST
33467: PUSH
33468: LD_INT 1
33470: NEG
33471: PUSH
33472: LD_INT 1
33474: NEG
33475: PUSH
33476: EMPTY
33477: LIST
33478: LIST
33479: PUSH
33480: LD_INT 1
33482: NEG
33483: PUSH
33484: LD_INT 2
33486: NEG
33487: PUSH
33488: EMPTY
33489: LIST
33490: LIST
33491: PUSH
33492: LD_INT 0
33494: PUSH
33495: LD_INT 2
33497: NEG
33498: PUSH
33499: EMPTY
33500: LIST
33501: LIST
33502: PUSH
33503: LD_INT 1
33505: PUSH
33506: LD_INT 1
33508: NEG
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 2
33516: PUSH
33517: LD_INT 0
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 2
33526: PUSH
33527: LD_INT 1
33529: PUSH
33530: EMPTY
33531: LIST
33532: LIST
33533: PUSH
33534: LD_INT 2
33536: PUSH
33537: LD_INT 2
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: PUSH
33544: LD_INT 1
33546: PUSH
33547: LD_INT 2
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 0
33556: PUSH
33557: LD_INT 2
33559: PUSH
33560: EMPTY
33561: LIST
33562: LIST
33563: PUSH
33564: LD_INT 1
33566: NEG
33567: PUSH
33568: LD_INT 1
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: LD_INT 2
33577: NEG
33578: PUSH
33579: LD_INT 0
33581: PUSH
33582: EMPTY
33583: LIST
33584: LIST
33585: PUSH
33586: LD_INT 2
33588: NEG
33589: PUSH
33590: LD_INT 1
33592: NEG
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 2
33600: NEG
33601: PUSH
33602: LD_INT 2
33604: NEG
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: PUSH
33610: EMPTY
33611: LIST
33612: LIST
33613: LIST
33614: LIST
33615: LIST
33616: LIST
33617: LIST
33618: LIST
33619: LIST
33620: LIST
33621: LIST
33622: LIST
33623: LIST
33624: LIST
33625: LIST
33626: LIST
33627: LIST
33628: LIST
33629: LIST
33630: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
33631: LD_ADDR_VAR 0 23
33635: PUSH
33636: LD_INT 0
33638: PUSH
33639: LD_INT 0
33641: PUSH
33642: EMPTY
33643: LIST
33644: LIST
33645: PUSH
33646: LD_INT 0
33648: PUSH
33649: LD_INT 1
33651: NEG
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 1
33659: PUSH
33660: LD_INT 0
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_INT 1
33669: PUSH
33670: LD_INT 1
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: LD_INT 0
33679: PUSH
33680: LD_INT 1
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PUSH
33687: LD_INT 1
33689: NEG
33690: PUSH
33691: LD_INT 0
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 1
33700: NEG
33701: PUSH
33702: LD_INT 1
33704: NEG
33705: PUSH
33706: EMPTY
33707: LIST
33708: LIST
33709: PUSH
33710: LD_INT 1
33712: NEG
33713: PUSH
33714: LD_INT 2
33716: NEG
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 0
33724: PUSH
33725: LD_INT 2
33727: NEG
33728: PUSH
33729: EMPTY
33730: LIST
33731: LIST
33732: PUSH
33733: LD_INT 1
33735: PUSH
33736: LD_INT 1
33738: NEG
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 2
33746: PUSH
33747: LD_INT 0
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: LD_INT 2
33756: PUSH
33757: LD_INT 1
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 2
33766: PUSH
33767: LD_INT 2
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 1
33776: PUSH
33777: LD_INT 2
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 0
33786: PUSH
33787: LD_INT 2
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: LD_INT 1
33796: NEG
33797: PUSH
33798: LD_INT 1
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 2
33807: NEG
33808: PUSH
33809: LD_INT 0
33811: PUSH
33812: EMPTY
33813: LIST
33814: LIST
33815: PUSH
33816: LD_INT 2
33818: NEG
33819: PUSH
33820: LD_INT 1
33822: NEG
33823: PUSH
33824: EMPTY
33825: LIST
33826: LIST
33827: PUSH
33828: LD_INT 2
33830: NEG
33831: PUSH
33832: LD_INT 2
33834: NEG
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 2
33842: NEG
33843: PUSH
33844: LD_INT 3
33846: NEG
33847: PUSH
33848: EMPTY
33849: LIST
33850: LIST
33851: PUSH
33852: LD_INT 1
33854: NEG
33855: PUSH
33856: LD_INT 3
33858: NEG
33859: PUSH
33860: EMPTY
33861: LIST
33862: LIST
33863: PUSH
33864: LD_INT 1
33866: PUSH
33867: LD_INT 2
33869: NEG
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 2
33877: PUSH
33878: LD_INT 1
33880: NEG
33881: PUSH
33882: EMPTY
33883: LIST
33884: LIST
33885: PUSH
33886: EMPTY
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: LIST
33892: LIST
33893: LIST
33894: LIST
33895: LIST
33896: LIST
33897: LIST
33898: LIST
33899: LIST
33900: LIST
33901: LIST
33902: LIST
33903: LIST
33904: LIST
33905: LIST
33906: LIST
33907: LIST
33908: LIST
33909: LIST
33910: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
33911: LD_ADDR_VAR 0 24
33915: PUSH
33916: LD_INT 0
33918: PUSH
33919: LD_INT 0
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 0
33928: PUSH
33929: LD_INT 1
33931: NEG
33932: PUSH
33933: EMPTY
33934: LIST
33935: LIST
33936: PUSH
33937: LD_INT 1
33939: PUSH
33940: LD_INT 0
33942: PUSH
33943: EMPTY
33944: LIST
33945: LIST
33946: PUSH
33947: LD_INT 1
33949: PUSH
33950: LD_INT 1
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 0
33959: PUSH
33960: LD_INT 1
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 1
33969: NEG
33970: PUSH
33971: LD_INT 0
33973: PUSH
33974: EMPTY
33975: LIST
33976: LIST
33977: PUSH
33978: LD_INT 1
33980: NEG
33981: PUSH
33982: LD_INT 1
33984: NEG
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 1
33992: NEG
33993: PUSH
33994: LD_INT 2
33996: NEG
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: LD_INT 0
34004: PUSH
34005: LD_INT 2
34007: NEG
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 1
34015: PUSH
34016: LD_INT 1
34018: NEG
34019: PUSH
34020: EMPTY
34021: LIST
34022: LIST
34023: PUSH
34024: LD_INT 2
34026: PUSH
34027: LD_INT 0
34029: PUSH
34030: EMPTY
34031: LIST
34032: LIST
34033: PUSH
34034: LD_INT 2
34036: PUSH
34037: LD_INT 1
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: PUSH
34044: LD_INT 2
34046: PUSH
34047: LD_INT 2
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 1
34056: PUSH
34057: LD_INT 2
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 0
34066: PUSH
34067: LD_INT 2
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 1
34076: NEG
34077: PUSH
34078: LD_INT 1
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 2
34087: NEG
34088: PUSH
34089: LD_INT 0
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: PUSH
34096: LD_INT 2
34098: NEG
34099: PUSH
34100: LD_INT 1
34102: NEG
34103: PUSH
34104: EMPTY
34105: LIST
34106: LIST
34107: PUSH
34108: LD_INT 2
34110: NEG
34111: PUSH
34112: LD_INT 2
34114: NEG
34115: PUSH
34116: EMPTY
34117: LIST
34118: LIST
34119: PUSH
34120: LD_INT 1
34122: PUSH
34123: LD_INT 2
34125: NEG
34126: PUSH
34127: EMPTY
34128: LIST
34129: LIST
34130: PUSH
34131: LD_INT 2
34133: PUSH
34134: LD_INT 1
34136: NEG
34137: PUSH
34138: EMPTY
34139: LIST
34140: LIST
34141: PUSH
34142: LD_INT 3
34144: PUSH
34145: LD_INT 1
34147: PUSH
34148: EMPTY
34149: LIST
34150: LIST
34151: PUSH
34152: LD_INT 3
34154: PUSH
34155: LD_INT 2
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: LIST
34168: LIST
34169: LIST
34170: LIST
34171: LIST
34172: LIST
34173: LIST
34174: LIST
34175: LIST
34176: LIST
34177: LIST
34178: LIST
34179: LIST
34180: LIST
34181: LIST
34182: LIST
34183: LIST
34184: LIST
34185: LIST
34186: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
34187: LD_ADDR_VAR 0 25
34191: PUSH
34192: LD_INT 0
34194: PUSH
34195: LD_INT 0
34197: PUSH
34198: EMPTY
34199: LIST
34200: LIST
34201: PUSH
34202: LD_INT 0
34204: PUSH
34205: LD_INT 1
34207: NEG
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 1
34215: PUSH
34216: LD_INT 0
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 1
34225: PUSH
34226: LD_INT 1
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: LD_INT 0
34235: PUSH
34236: LD_INT 1
34238: PUSH
34239: EMPTY
34240: LIST
34241: LIST
34242: PUSH
34243: LD_INT 1
34245: NEG
34246: PUSH
34247: LD_INT 0
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: PUSH
34254: LD_INT 1
34256: NEG
34257: PUSH
34258: LD_INT 1
34260: NEG
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: PUSH
34266: LD_INT 1
34268: NEG
34269: PUSH
34270: LD_INT 2
34272: NEG
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: LD_INT 0
34280: PUSH
34281: LD_INT 2
34283: NEG
34284: PUSH
34285: EMPTY
34286: LIST
34287: LIST
34288: PUSH
34289: LD_INT 1
34291: PUSH
34292: LD_INT 1
34294: NEG
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 2
34302: PUSH
34303: LD_INT 0
34305: PUSH
34306: EMPTY
34307: LIST
34308: LIST
34309: PUSH
34310: LD_INT 2
34312: PUSH
34313: LD_INT 1
34315: PUSH
34316: EMPTY
34317: LIST
34318: LIST
34319: PUSH
34320: LD_INT 2
34322: PUSH
34323: LD_INT 2
34325: PUSH
34326: EMPTY
34327: LIST
34328: LIST
34329: PUSH
34330: LD_INT 1
34332: PUSH
34333: LD_INT 2
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 0
34342: PUSH
34343: LD_INT 2
34345: PUSH
34346: EMPTY
34347: LIST
34348: LIST
34349: PUSH
34350: LD_INT 1
34352: NEG
34353: PUSH
34354: LD_INT 1
34356: PUSH
34357: EMPTY
34358: LIST
34359: LIST
34360: PUSH
34361: LD_INT 2
34363: NEG
34364: PUSH
34365: LD_INT 0
34367: PUSH
34368: EMPTY
34369: LIST
34370: LIST
34371: PUSH
34372: LD_INT 2
34374: NEG
34375: PUSH
34376: LD_INT 1
34378: NEG
34379: PUSH
34380: EMPTY
34381: LIST
34382: LIST
34383: PUSH
34384: LD_INT 2
34386: NEG
34387: PUSH
34388: LD_INT 2
34390: NEG
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: PUSH
34396: LD_INT 3
34398: PUSH
34399: LD_INT 1
34401: PUSH
34402: EMPTY
34403: LIST
34404: LIST
34405: PUSH
34406: LD_INT 3
34408: PUSH
34409: LD_INT 2
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PUSH
34416: LD_INT 2
34418: PUSH
34419: LD_INT 3
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: PUSH
34426: LD_INT 1
34428: PUSH
34429: LD_INT 3
34431: PUSH
34432: EMPTY
34433: LIST
34434: LIST
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: LIST
34447: LIST
34448: LIST
34449: LIST
34450: LIST
34451: LIST
34452: LIST
34453: LIST
34454: LIST
34455: LIST
34456: LIST
34457: LIST
34458: LIST
34459: LIST
34460: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
34461: LD_ADDR_VAR 0 26
34465: PUSH
34466: LD_INT 0
34468: PUSH
34469: LD_INT 0
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PUSH
34476: LD_INT 0
34478: PUSH
34479: LD_INT 1
34481: NEG
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: PUSH
34487: LD_INT 1
34489: PUSH
34490: LD_INT 0
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 1
34499: PUSH
34500: LD_INT 1
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 0
34509: PUSH
34510: LD_INT 1
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: PUSH
34517: LD_INT 1
34519: NEG
34520: PUSH
34521: LD_INT 0
34523: PUSH
34524: EMPTY
34525: LIST
34526: LIST
34527: PUSH
34528: LD_INT 1
34530: NEG
34531: PUSH
34532: LD_INT 1
34534: NEG
34535: PUSH
34536: EMPTY
34537: LIST
34538: LIST
34539: PUSH
34540: LD_INT 1
34542: NEG
34543: PUSH
34544: LD_INT 2
34546: NEG
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: PUSH
34552: LD_INT 0
34554: PUSH
34555: LD_INT 2
34557: NEG
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 1
34565: PUSH
34566: LD_INT 1
34568: NEG
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 2
34576: PUSH
34577: LD_INT 0
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: LD_INT 2
34586: PUSH
34587: LD_INT 1
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 2
34596: PUSH
34597: LD_INT 2
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 1
34606: PUSH
34607: LD_INT 2
34609: PUSH
34610: EMPTY
34611: LIST
34612: LIST
34613: PUSH
34614: LD_INT 0
34616: PUSH
34617: LD_INT 2
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 1
34626: NEG
34627: PUSH
34628: LD_INT 1
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 2
34637: NEG
34638: PUSH
34639: LD_INT 0
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: LD_INT 2
34648: NEG
34649: PUSH
34650: LD_INT 1
34652: NEG
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: PUSH
34658: LD_INT 2
34660: NEG
34661: PUSH
34662: LD_INT 2
34664: NEG
34665: PUSH
34666: EMPTY
34667: LIST
34668: LIST
34669: PUSH
34670: LD_INT 2
34672: PUSH
34673: LD_INT 3
34675: PUSH
34676: EMPTY
34677: LIST
34678: LIST
34679: PUSH
34680: LD_INT 1
34682: PUSH
34683: LD_INT 3
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 1
34692: NEG
34693: PUSH
34694: LD_INT 2
34696: PUSH
34697: EMPTY
34698: LIST
34699: LIST
34700: PUSH
34701: LD_INT 2
34703: NEG
34704: PUSH
34705: LD_INT 1
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34737: LD_ADDR_VAR 0 27
34741: PUSH
34742: LD_INT 0
34744: PUSH
34745: LD_INT 0
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PUSH
34752: LD_INT 0
34754: PUSH
34755: LD_INT 1
34757: NEG
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 1
34765: PUSH
34766: LD_INT 0
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 1
34775: PUSH
34776: LD_INT 1
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 0
34785: PUSH
34786: LD_INT 1
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: PUSH
34793: LD_INT 1
34795: NEG
34796: PUSH
34797: LD_INT 0
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: PUSH
34804: LD_INT 1
34806: NEG
34807: PUSH
34808: LD_INT 1
34810: NEG
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 1
34818: NEG
34819: PUSH
34820: LD_INT 2
34822: NEG
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 0
34830: PUSH
34831: LD_INT 2
34833: NEG
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 1
34841: PUSH
34842: LD_INT 1
34844: NEG
34845: PUSH
34846: EMPTY
34847: LIST
34848: LIST
34849: PUSH
34850: LD_INT 2
34852: PUSH
34853: LD_INT 0
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: LD_INT 2
34862: PUSH
34863: LD_INT 1
34865: PUSH
34866: EMPTY
34867: LIST
34868: LIST
34869: PUSH
34870: LD_INT 2
34872: PUSH
34873: LD_INT 2
34875: PUSH
34876: EMPTY
34877: LIST
34878: LIST
34879: PUSH
34880: LD_INT 1
34882: PUSH
34883: LD_INT 2
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: PUSH
34890: LD_INT 0
34892: PUSH
34893: LD_INT 2
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 1
34902: NEG
34903: PUSH
34904: LD_INT 1
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 2
34913: NEG
34914: PUSH
34915: LD_INT 0
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: PUSH
34922: LD_INT 2
34924: NEG
34925: PUSH
34926: LD_INT 1
34928: NEG
34929: PUSH
34930: EMPTY
34931: LIST
34932: LIST
34933: PUSH
34934: LD_INT 2
34936: NEG
34937: PUSH
34938: LD_INT 2
34940: NEG
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: PUSH
34946: LD_INT 1
34948: NEG
34949: PUSH
34950: LD_INT 2
34952: PUSH
34953: EMPTY
34954: LIST
34955: LIST
34956: PUSH
34957: LD_INT 2
34959: NEG
34960: PUSH
34961: LD_INT 1
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 3
34970: NEG
34971: PUSH
34972: LD_INT 1
34974: NEG
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: LD_INT 3
34982: NEG
34983: PUSH
34984: LD_INT 2
34986: NEG
34987: PUSH
34988: EMPTY
34989: LIST
34990: LIST
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: LIST
34996: LIST
34997: LIST
34998: LIST
34999: LIST
35000: LIST
35001: LIST
35002: LIST
35003: LIST
35004: LIST
35005: LIST
35006: LIST
35007: LIST
35008: LIST
35009: LIST
35010: LIST
35011: LIST
35012: LIST
35013: LIST
35014: LIST
35015: LIST
35016: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
35017: LD_ADDR_VAR 0 28
35021: PUSH
35022: LD_INT 0
35024: PUSH
35025: LD_INT 0
35027: PUSH
35028: EMPTY
35029: LIST
35030: LIST
35031: PUSH
35032: LD_INT 0
35034: PUSH
35035: LD_INT 1
35037: NEG
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 1
35045: PUSH
35046: LD_INT 0
35048: PUSH
35049: EMPTY
35050: LIST
35051: LIST
35052: PUSH
35053: LD_INT 1
35055: PUSH
35056: LD_INT 1
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 0
35065: PUSH
35066: LD_INT 1
35068: PUSH
35069: EMPTY
35070: LIST
35071: LIST
35072: PUSH
35073: LD_INT 1
35075: NEG
35076: PUSH
35077: LD_INT 0
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: PUSH
35084: LD_INT 1
35086: NEG
35087: PUSH
35088: LD_INT 1
35090: NEG
35091: PUSH
35092: EMPTY
35093: LIST
35094: LIST
35095: PUSH
35096: LD_INT 1
35098: NEG
35099: PUSH
35100: LD_INT 2
35102: NEG
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 0
35110: PUSH
35111: LD_INT 2
35113: NEG
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 1
35121: PUSH
35122: LD_INT 1
35124: NEG
35125: PUSH
35126: EMPTY
35127: LIST
35128: LIST
35129: PUSH
35130: LD_INT 2
35132: PUSH
35133: LD_INT 0
35135: PUSH
35136: EMPTY
35137: LIST
35138: LIST
35139: PUSH
35140: LD_INT 2
35142: PUSH
35143: LD_INT 1
35145: PUSH
35146: EMPTY
35147: LIST
35148: LIST
35149: PUSH
35150: LD_INT 2
35152: PUSH
35153: LD_INT 2
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PUSH
35160: LD_INT 1
35162: PUSH
35163: LD_INT 2
35165: PUSH
35166: EMPTY
35167: LIST
35168: LIST
35169: PUSH
35170: LD_INT 0
35172: PUSH
35173: LD_INT 2
35175: PUSH
35176: EMPTY
35177: LIST
35178: LIST
35179: PUSH
35180: LD_INT 1
35182: NEG
35183: PUSH
35184: LD_INT 1
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: LD_INT 2
35193: NEG
35194: PUSH
35195: LD_INT 0
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: PUSH
35202: LD_INT 2
35204: NEG
35205: PUSH
35206: LD_INT 1
35208: NEG
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: PUSH
35214: LD_INT 2
35216: NEG
35217: PUSH
35218: LD_INT 2
35220: NEG
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: PUSH
35226: LD_INT 2
35228: NEG
35229: PUSH
35230: LD_INT 3
35232: NEG
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: LD_INT 3
35244: NEG
35245: PUSH
35246: EMPTY
35247: LIST
35248: LIST
35249: PUSH
35250: LD_INT 3
35252: NEG
35253: PUSH
35254: LD_INT 1
35256: NEG
35257: PUSH
35258: EMPTY
35259: LIST
35260: LIST
35261: PUSH
35262: LD_INT 3
35264: NEG
35265: PUSH
35266: LD_INT 2
35268: NEG
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: EMPTY
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35299: LD_ADDR_VAR 0 29
35303: PUSH
35304: LD_INT 0
35306: PUSH
35307: LD_INT 0
35309: PUSH
35310: EMPTY
35311: LIST
35312: LIST
35313: PUSH
35314: LD_INT 0
35316: PUSH
35317: LD_INT 1
35319: NEG
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: LD_INT 1
35327: PUSH
35328: LD_INT 0
35330: PUSH
35331: EMPTY
35332: LIST
35333: LIST
35334: PUSH
35335: LD_INT 1
35337: PUSH
35338: LD_INT 1
35340: PUSH
35341: EMPTY
35342: LIST
35343: LIST
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: LD_INT 1
35350: PUSH
35351: EMPTY
35352: LIST
35353: LIST
35354: PUSH
35355: LD_INT 1
35357: NEG
35358: PUSH
35359: LD_INT 0
35361: PUSH
35362: EMPTY
35363: LIST
35364: LIST
35365: PUSH
35366: LD_INT 1
35368: NEG
35369: PUSH
35370: LD_INT 1
35372: NEG
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: LD_INT 1
35380: NEG
35381: PUSH
35382: LD_INT 2
35384: NEG
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 0
35392: PUSH
35393: LD_INT 2
35395: NEG
35396: PUSH
35397: EMPTY
35398: LIST
35399: LIST
35400: PUSH
35401: LD_INT 1
35403: PUSH
35404: LD_INT 1
35406: NEG
35407: PUSH
35408: EMPTY
35409: LIST
35410: LIST
35411: PUSH
35412: LD_INT 2
35414: PUSH
35415: LD_INT 0
35417: PUSH
35418: EMPTY
35419: LIST
35420: LIST
35421: PUSH
35422: LD_INT 2
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: PUSH
35432: LD_INT 1
35434: PUSH
35435: LD_INT 2
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: PUSH
35442: LD_INT 0
35444: PUSH
35445: LD_INT 2
35447: PUSH
35448: EMPTY
35449: LIST
35450: LIST
35451: PUSH
35452: LD_INT 1
35454: NEG
35455: PUSH
35456: LD_INT 1
35458: PUSH
35459: EMPTY
35460: LIST
35461: LIST
35462: PUSH
35463: LD_INT 2
35465: NEG
35466: PUSH
35467: LD_INT 1
35469: NEG
35470: PUSH
35471: EMPTY
35472: LIST
35473: LIST
35474: PUSH
35475: LD_INT 2
35477: NEG
35478: PUSH
35479: LD_INT 2
35481: NEG
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 2
35489: NEG
35490: PUSH
35491: LD_INT 3
35493: NEG
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: LD_INT 2
35501: PUSH
35502: LD_INT 1
35504: NEG
35505: PUSH
35506: EMPTY
35507: LIST
35508: LIST
35509: PUSH
35510: LD_INT 3
35512: PUSH
35513: LD_INT 1
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: PUSH
35520: LD_INT 1
35522: PUSH
35523: LD_INT 3
35525: PUSH
35526: EMPTY
35527: LIST
35528: LIST
35529: PUSH
35530: LD_INT 1
35532: NEG
35533: PUSH
35534: LD_INT 2
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: PUSH
35541: LD_INT 3
35543: NEG
35544: PUSH
35545: LD_INT 2
35547: NEG
35548: PUSH
35549: EMPTY
35550: LIST
35551: LIST
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: LIST
35557: LIST
35558: LIST
35559: LIST
35560: LIST
35561: LIST
35562: LIST
35563: LIST
35564: LIST
35565: LIST
35566: LIST
35567: LIST
35568: LIST
35569: LIST
35570: LIST
35571: LIST
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35578: LD_ADDR_VAR 0 30
35582: PUSH
35583: LD_INT 0
35585: PUSH
35586: LD_INT 0
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: LD_INT 0
35595: PUSH
35596: LD_INT 1
35598: NEG
35599: PUSH
35600: EMPTY
35601: LIST
35602: LIST
35603: PUSH
35604: LD_INT 1
35606: PUSH
35607: LD_INT 0
35609: PUSH
35610: EMPTY
35611: LIST
35612: LIST
35613: PUSH
35614: LD_INT 1
35616: PUSH
35617: LD_INT 1
35619: PUSH
35620: EMPTY
35621: LIST
35622: LIST
35623: PUSH
35624: LD_INT 0
35626: PUSH
35627: LD_INT 1
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: PUSH
35634: LD_INT 1
35636: NEG
35637: PUSH
35638: LD_INT 0
35640: PUSH
35641: EMPTY
35642: LIST
35643: LIST
35644: PUSH
35645: LD_INT 1
35647: NEG
35648: PUSH
35649: LD_INT 1
35651: NEG
35652: PUSH
35653: EMPTY
35654: LIST
35655: LIST
35656: PUSH
35657: LD_INT 1
35659: NEG
35660: PUSH
35661: LD_INT 2
35663: NEG
35664: PUSH
35665: EMPTY
35666: LIST
35667: LIST
35668: PUSH
35669: LD_INT 0
35671: PUSH
35672: LD_INT 2
35674: NEG
35675: PUSH
35676: EMPTY
35677: LIST
35678: LIST
35679: PUSH
35680: LD_INT 1
35682: PUSH
35683: LD_INT 1
35685: NEG
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 2
35693: PUSH
35694: LD_INT 0
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 2
35703: PUSH
35704: LD_INT 1
35706: PUSH
35707: EMPTY
35708: LIST
35709: LIST
35710: PUSH
35711: LD_INT 2
35713: PUSH
35714: LD_INT 2
35716: PUSH
35717: EMPTY
35718: LIST
35719: LIST
35720: PUSH
35721: LD_INT 1
35723: PUSH
35724: LD_INT 2
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 1
35733: NEG
35734: PUSH
35735: LD_INT 1
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 2
35744: NEG
35745: PUSH
35746: LD_INT 0
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 2
35755: NEG
35756: PUSH
35757: LD_INT 1
35759: NEG
35760: PUSH
35761: EMPTY
35762: LIST
35763: LIST
35764: PUSH
35765: LD_INT 1
35767: NEG
35768: PUSH
35769: LD_INT 3
35771: NEG
35772: PUSH
35773: EMPTY
35774: LIST
35775: LIST
35776: PUSH
35777: LD_INT 1
35779: PUSH
35780: LD_INT 2
35782: NEG
35783: PUSH
35784: EMPTY
35785: LIST
35786: LIST
35787: PUSH
35788: LD_INT 3
35790: PUSH
35791: LD_INT 2
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 2
35800: PUSH
35801: LD_INT 3
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: LD_INT 2
35810: NEG
35811: PUSH
35812: LD_INT 1
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: LD_INT 3
35821: NEG
35822: PUSH
35823: LD_INT 1
35825: NEG
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: EMPTY
35832: LIST
35833: LIST
35834: LIST
35835: LIST
35836: LIST
35837: LIST
35838: LIST
35839: LIST
35840: LIST
35841: LIST
35842: LIST
35843: LIST
35844: LIST
35845: LIST
35846: LIST
35847: LIST
35848: LIST
35849: LIST
35850: LIST
35851: LIST
35852: LIST
35853: LIST
35854: LIST
35855: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35856: LD_ADDR_VAR 0 31
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: LD_INT 0
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 0
35873: PUSH
35874: LD_INT 1
35876: NEG
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 1
35884: PUSH
35885: LD_INT 0
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 1
35894: PUSH
35895: LD_INT 1
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 0
35904: PUSH
35905: LD_INT 1
35907: PUSH
35908: EMPTY
35909: LIST
35910: LIST
35911: PUSH
35912: LD_INT 1
35914: NEG
35915: PUSH
35916: LD_INT 0
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: PUSH
35923: LD_INT 1
35925: NEG
35926: PUSH
35927: LD_INT 1
35929: NEG
35930: PUSH
35931: EMPTY
35932: LIST
35933: LIST
35934: PUSH
35935: LD_INT 1
35937: NEG
35938: PUSH
35939: LD_INT 2
35941: NEG
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 1
35949: PUSH
35950: LD_INT 1
35952: NEG
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: PUSH
35958: LD_INT 2
35960: PUSH
35961: LD_INT 0
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: PUSH
35968: LD_INT 2
35970: PUSH
35971: LD_INT 1
35973: PUSH
35974: EMPTY
35975: LIST
35976: LIST
35977: PUSH
35978: LD_INT 2
35980: PUSH
35981: LD_INT 2
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 1
35990: PUSH
35991: LD_INT 2
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: PUSH
35998: LD_INT 0
36000: PUSH
36001: LD_INT 2
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 1
36010: NEG
36011: PUSH
36012: LD_INT 1
36014: PUSH
36015: EMPTY
36016: LIST
36017: LIST
36018: PUSH
36019: LD_INT 2
36021: NEG
36022: PUSH
36023: LD_INT 1
36025: NEG
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 2
36033: NEG
36034: PUSH
36035: LD_INT 2
36037: NEG
36038: PUSH
36039: EMPTY
36040: LIST
36041: LIST
36042: PUSH
36043: LD_INT 2
36045: NEG
36046: PUSH
36047: LD_INT 3
36049: NEG
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: LD_INT 2
36057: PUSH
36058: LD_INT 1
36060: NEG
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: PUSH
36066: LD_INT 3
36068: PUSH
36069: LD_INT 1
36071: PUSH
36072: EMPTY
36073: LIST
36074: LIST
36075: PUSH
36076: LD_INT 1
36078: PUSH
36079: LD_INT 3
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: LD_INT 1
36088: NEG
36089: PUSH
36090: LD_INT 2
36092: PUSH
36093: EMPTY
36094: LIST
36095: LIST
36096: PUSH
36097: LD_INT 3
36099: NEG
36100: PUSH
36101: LD_INT 2
36103: NEG
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: PUSH
36109: EMPTY
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36134: LD_ADDR_VAR 0 32
36138: PUSH
36139: LD_INT 0
36141: PUSH
36142: LD_INT 0
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: LD_INT 1
36154: NEG
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 1
36162: PUSH
36163: LD_INT 0
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 1
36172: PUSH
36173: LD_INT 1
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 0
36182: PUSH
36183: LD_INT 1
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 1
36192: NEG
36193: PUSH
36194: LD_INT 0
36196: PUSH
36197: EMPTY
36198: LIST
36199: LIST
36200: PUSH
36201: LD_INT 1
36203: NEG
36204: PUSH
36205: LD_INT 1
36207: NEG
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 1
36215: NEG
36216: PUSH
36217: LD_INT 2
36219: NEG
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: LD_INT 0
36227: PUSH
36228: LD_INT 2
36230: NEG
36231: PUSH
36232: EMPTY
36233: LIST
36234: LIST
36235: PUSH
36236: LD_INT 1
36238: PUSH
36239: LD_INT 1
36241: NEG
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 2
36249: PUSH
36250: LD_INT 1
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: LD_INT 2
36259: PUSH
36260: LD_INT 2
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 1
36269: PUSH
36270: LD_INT 2
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: LD_INT 0
36279: PUSH
36280: LD_INT 2
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 1
36289: NEG
36290: PUSH
36291: LD_INT 1
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 2
36300: NEG
36301: PUSH
36302: LD_INT 0
36304: PUSH
36305: EMPTY
36306: LIST
36307: LIST
36308: PUSH
36309: LD_INT 2
36311: NEG
36312: PUSH
36313: LD_INT 1
36315: NEG
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 1
36323: NEG
36324: PUSH
36325: LD_INT 3
36327: NEG
36328: PUSH
36329: EMPTY
36330: LIST
36331: LIST
36332: PUSH
36333: LD_INT 1
36335: PUSH
36336: LD_INT 2
36338: NEG
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: PUSH
36344: LD_INT 3
36346: PUSH
36347: LD_INT 2
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 2
36356: PUSH
36357: LD_INT 3
36359: PUSH
36360: EMPTY
36361: LIST
36362: LIST
36363: PUSH
36364: LD_INT 2
36366: NEG
36367: PUSH
36368: LD_INT 1
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 3
36377: NEG
36378: PUSH
36379: LD_INT 1
36381: NEG
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: LIST
36391: LIST
36392: LIST
36393: LIST
36394: LIST
36395: LIST
36396: LIST
36397: LIST
36398: LIST
36399: LIST
36400: LIST
36401: LIST
36402: LIST
36403: LIST
36404: LIST
36405: LIST
36406: LIST
36407: LIST
36408: LIST
36409: LIST
36410: LIST
36411: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36412: LD_ADDR_VAR 0 33
36416: PUSH
36417: LD_INT 0
36419: PUSH
36420: LD_INT 0
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: LD_INT 1
36432: NEG
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 1
36440: PUSH
36441: LD_INT 0
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: LD_INT 1
36450: PUSH
36451: LD_INT 1
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 0
36460: PUSH
36461: LD_INT 1
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 1
36470: NEG
36471: PUSH
36472: LD_INT 0
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: LD_INT 1
36481: NEG
36482: PUSH
36483: LD_INT 1
36485: NEG
36486: PUSH
36487: EMPTY
36488: LIST
36489: LIST
36490: PUSH
36491: LD_INT 1
36493: NEG
36494: PUSH
36495: LD_INT 2
36497: NEG
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: PUSH
36503: LD_INT 1
36505: PUSH
36506: LD_INT 1
36508: NEG
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: PUSH
36514: LD_INT 2
36516: PUSH
36517: LD_INT 0
36519: PUSH
36520: EMPTY
36521: LIST
36522: LIST
36523: PUSH
36524: LD_INT 2
36526: PUSH
36527: LD_INT 1
36529: PUSH
36530: EMPTY
36531: LIST
36532: LIST
36533: PUSH
36534: LD_INT 1
36536: PUSH
36537: LD_INT 2
36539: PUSH
36540: EMPTY
36541: LIST
36542: LIST
36543: PUSH
36544: LD_INT 0
36546: PUSH
36547: LD_INT 2
36549: PUSH
36550: EMPTY
36551: LIST
36552: LIST
36553: PUSH
36554: LD_INT 1
36556: NEG
36557: PUSH
36558: LD_INT 1
36560: PUSH
36561: EMPTY
36562: LIST
36563: LIST
36564: PUSH
36565: LD_INT 2
36567: NEG
36568: PUSH
36569: LD_INT 0
36571: PUSH
36572: EMPTY
36573: LIST
36574: LIST
36575: PUSH
36576: LD_INT 2
36578: NEG
36579: PUSH
36580: LD_INT 1
36582: NEG
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: PUSH
36588: LD_INT 2
36590: NEG
36591: PUSH
36592: LD_INT 2
36594: NEG
36595: PUSH
36596: EMPTY
36597: LIST
36598: LIST
36599: PUSH
36600: LD_INT 2
36602: NEG
36603: PUSH
36604: LD_INT 3
36606: NEG
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 2
36614: PUSH
36615: LD_INT 1
36617: NEG
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: LD_INT 3
36625: PUSH
36626: LD_INT 1
36628: PUSH
36629: EMPTY
36630: LIST
36631: LIST
36632: PUSH
36633: LD_INT 1
36635: PUSH
36636: LD_INT 3
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: LD_INT 1
36645: NEG
36646: PUSH
36647: LD_INT 2
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 3
36656: NEG
36657: PUSH
36658: LD_INT 2
36660: NEG
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: PUSH
36666: EMPTY
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36691: LD_ADDR_VAR 0 34
36695: PUSH
36696: LD_INT 0
36698: PUSH
36699: LD_INT 0
36701: PUSH
36702: EMPTY
36703: LIST
36704: LIST
36705: PUSH
36706: LD_INT 0
36708: PUSH
36709: LD_INT 1
36711: NEG
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 1
36719: PUSH
36720: LD_INT 0
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 1
36729: PUSH
36730: LD_INT 1
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: LD_INT 0
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: LD_INT 1
36749: NEG
36750: PUSH
36751: LD_INT 0
36753: PUSH
36754: EMPTY
36755: LIST
36756: LIST
36757: PUSH
36758: LD_INT 1
36760: NEG
36761: PUSH
36762: LD_INT 1
36764: NEG
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: PUSH
36770: LD_INT 1
36772: NEG
36773: PUSH
36774: LD_INT 2
36776: NEG
36777: PUSH
36778: EMPTY
36779: LIST
36780: LIST
36781: PUSH
36782: LD_INT 0
36784: PUSH
36785: LD_INT 2
36787: NEG
36788: PUSH
36789: EMPTY
36790: LIST
36791: LIST
36792: PUSH
36793: LD_INT 1
36795: PUSH
36796: LD_INT 1
36798: NEG
36799: PUSH
36800: EMPTY
36801: LIST
36802: LIST
36803: PUSH
36804: LD_INT 2
36806: PUSH
36807: LD_INT 1
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 2
36816: PUSH
36817: LD_INT 2
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: LD_INT 1
36826: PUSH
36827: LD_INT 2
36829: PUSH
36830: EMPTY
36831: LIST
36832: LIST
36833: PUSH
36834: LD_INT 1
36836: NEG
36837: PUSH
36838: LD_INT 1
36840: PUSH
36841: EMPTY
36842: LIST
36843: LIST
36844: PUSH
36845: LD_INT 2
36847: NEG
36848: PUSH
36849: LD_INT 0
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: PUSH
36856: LD_INT 2
36858: NEG
36859: PUSH
36860: LD_INT 1
36862: NEG
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 2
36870: NEG
36871: PUSH
36872: LD_INT 2
36874: NEG
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: LD_INT 1
36882: NEG
36883: PUSH
36884: LD_INT 3
36886: NEG
36887: PUSH
36888: EMPTY
36889: LIST
36890: LIST
36891: PUSH
36892: LD_INT 1
36894: PUSH
36895: LD_INT 2
36897: NEG
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PUSH
36903: LD_INT 3
36905: PUSH
36906: LD_INT 2
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 2
36915: PUSH
36916: LD_INT 3
36918: PUSH
36919: EMPTY
36920: LIST
36921: LIST
36922: PUSH
36923: LD_INT 2
36925: NEG
36926: PUSH
36927: LD_INT 1
36929: PUSH
36930: EMPTY
36931: LIST
36932: LIST
36933: PUSH
36934: LD_INT 3
36936: NEG
36937: PUSH
36938: LD_INT 1
36940: NEG
36941: PUSH
36942: EMPTY
36943: LIST
36944: LIST
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: LIST
36950: LIST
36951: LIST
36952: LIST
36953: LIST
36954: LIST
36955: LIST
36956: LIST
36957: LIST
36958: LIST
36959: LIST
36960: LIST
36961: LIST
36962: LIST
36963: LIST
36964: LIST
36965: LIST
36966: LIST
36967: LIST
36968: LIST
36969: LIST
36970: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36971: LD_ADDR_VAR 0 35
36975: PUSH
36976: LD_INT 0
36978: PUSH
36979: LD_INT 0
36981: PUSH
36982: EMPTY
36983: LIST
36984: LIST
36985: PUSH
36986: LD_INT 0
36988: PUSH
36989: LD_INT 1
36991: NEG
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PUSH
36997: LD_INT 1
36999: PUSH
37000: LD_INT 0
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: PUSH
37007: LD_INT 1
37009: PUSH
37010: LD_INT 1
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 0
37019: PUSH
37020: LD_INT 1
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: LD_INT 1
37029: NEG
37030: PUSH
37031: LD_INT 0
37033: PUSH
37034: EMPTY
37035: LIST
37036: LIST
37037: PUSH
37038: LD_INT 1
37040: NEG
37041: PUSH
37042: LD_INT 1
37044: NEG
37045: PUSH
37046: EMPTY
37047: LIST
37048: LIST
37049: PUSH
37050: LD_INT 2
37052: PUSH
37053: LD_INT 1
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 2
37062: NEG
37063: PUSH
37064: LD_INT 1
37066: NEG
37067: PUSH
37068: EMPTY
37069: LIST
37070: LIST
37071: PUSH
37072: EMPTY
37073: LIST
37074: LIST
37075: LIST
37076: LIST
37077: LIST
37078: LIST
37079: LIST
37080: LIST
37081: LIST
37082: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37083: LD_ADDR_VAR 0 36
37087: PUSH
37088: LD_INT 0
37090: PUSH
37091: LD_INT 0
37093: PUSH
37094: EMPTY
37095: LIST
37096: LIST
37097: PUSH
37098: LD_INT 0
37100: PUSH
37101: LD_INT 1
37103: NEG
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: LD_INT 1
37111: PUSH
37112: LD_INT 0
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 1
37121: PUSH
37122: LD_INT 1
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: PUSH
37129: LD_INT 0
37131: PUSH
37132: LD_INT 1
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 1
37141: NEG
37142: PUSH
37143: LD_INT 0
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 1
37152: NEG
37153: PUSH
37154: LD_INT 1
37156: NEG
37157: PUSH
37158: EMPTY
37159: LIST
37160: LIST
37161: PUSH
37162: LD_INT 1
37164: NEG
37165: PUSH
37166: LD_INT 2
37168: NEG
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: LD_INT 2
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: LIST
37188: LIST
37189: LIST
37190: LIST
37191: LIST
37192: LIST
37193: LIST
37194: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37195: LD_ADDR_VAR 0 37
37199: PUSH
37200: LD_INT 0
37202: PUSH
37203: LD_INT 0
37205: PUSH
37206: EMPTY
37207: LIST
37208: LIST
37209: PUSH
37210: LD_INT 0
37212: PUSH
37213: LD_INT 1
37215: NEG
37216: PUSH
37217: EMPTY
37218: LIST
37219: LIST
37220: PUSH
37221: LD_INT 1
37223: PUSH
37224: LD_INT 0
37226: PUSH
37227: EMPTY
37228: LIST
37229: LIST
37230: PUSH
37231: LD_INT 1
37233: PUSH
37234: LD_INT 1
37236: PUSH
37237: EMPTY
37238: LIST
37239: LIST
37240: PUSH
37241: LD_INT 0
37243: PUSH
37244: LD_INT 1
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: PUSH
37251: LD_INT 1
37253: NEG
37254: PUSH
37255: LD_INT 0
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 1
37264: NEG
37265: PUSH
37266: LD_INT 1
37268: NEG
37269: PUSH
37270: EMPTY
37271: LIST
37272: LIST
37273: PUSH
37274: LD_INT 1
37276: PUSH
37277: LD_INT 1
37279: NEG
37280: PUSH
37281: EMPTY
37282: LIST
37283: LIST
37284: PUSH
37285: LD_INT 1
37287: NEG
37288: PUSH
37289: LD_INT 1
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: LIST
37300: LIST
37301: LIST
37302: LIST
37303: LIST
37304: LIST
37305: LIST
37306: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
37307: LD_ADDR_VAR 0 38
37311: PUSH
37312: LD_INT 0
37314: PUSH
37315: LD_INT 0
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 0
37324: PUSH
37325: LD_INT 1
37327: NEG
37328: PUSH
37329: EMPTY
37330: LIST
37331: LIST
37332: PUSH
37333: LD_INT 1
37335: PUSH
37336: LD_INT 0
37338: PUSH
37339: EMPTY
37340: LIST
37341: LIST
37342: PUSH
37343: LD_INT 1
37345: PUSH
37346: LD_INT 1
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: PUSH
37353: LD_INT 0
37355: PUSH
37356: LD_INT 1
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: PUSH
37363: LD_INT 1
37365: NEG
37366: PUSH
37367: LD_INT 0
37369: PUSH
37370: EMPTY
37371: LIST
37372: LIST
37373: PUSH
37374: LD_INT 1
37376: NEG
37377: PUSH
37378: LD_INT 1
37380: NEG
37381: PUSH
37382: EMPTY
37383: LIST
37384: LIST
37385: PUSH
37386: LD_INT 2
37388: PUSH
37389: LD_INT 1
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 2
37398: NEG
37399: PUSH
37400: LD_INT 1
37402: NEG
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: LIST
37412: LIST
37413: LIST
37414: LIST
37415: LIST
37416: LIST
37417: LIST
37418: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37419: LD_ADDR_VAR 0 39
37423: PUSH
37424: LD_INT 0
37426: PUSH
37427: LD_INT 0
37429: PUSH
37430: EMPTY
37431: LIST
37432: LIST
37433: PUSH
37434: LD_INT 0
37436: PUSH
37437: LD_INT 1
37439: NEG
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PUSH
37445: LD_INT 1
37447: PUSH
37448: LD_INT 0
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: PUSH
37455: LD_INT 1
37457: PUSH
37458: LD_INT 1
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: LD_INT 0
37467: PUSH
37468: LD_INT 1
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 1
37477: NEG
37478: PUSH
37479: LD_INT 0
37481: PUSH
37482: EMPTY
37483: LIST
37484: LIST
37485: PUSH
37486: LD_INT 1
37488: NEG
37489: PUSH
37490: LD_INT 1
37492: NEG
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 1
37500: NEG
37501: PUSH
37502: LD_INT 2
37504: NEG
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 1
37512: PUSH
37513: LD_INT 2
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: EMPTY
37521: LIST
37522: LIST
37523: LIST
37524: LIST
37525: LIST
37526: LIST
37527: LIST
37528: LIST
37529: LIST
37530: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37531: LD_ADDR_VAR 0 40
37535: PUSH
37536: LD_INT 0
37538: PUSH
37539: LD_INT 0
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: PUSH
37546: LD_INT 0
37548: PUSH
37549: LD_INT 1
37551: NEG
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 1
37559: PUSH
37560: LD_INT 0
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: LD_INT 1
37569: PUSH
37570: LD_INT 1
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: PUSH
37577: LD_INT 0
37579: PUSH
37580: LD_INT 1
37582: PUSH
37583: EMPTY
37584: LIST
37585: LIST
37586: PUSH
37587: LD_INT 1
37589: NEG
37590: PUSH
37591: LD_INT 0
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: LD_INT 1
37600: NEG
37601: PUSH
37602: LD_INT 1
37604: NEG
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 1
37612: PUSH
37613: LD_INT 1
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: NEG
37624: PUSH
37625: LD_INT 1
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: LIST
37636: LIST
37637: LIST
37638: LIST
37639: LIST
37640: LIST
37641: LIST
37642: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37643: LD_ADDR_VAR 0 41
37647: PUSH
37648: LD_INT 0
37650: PUSH
37651: LD_INT 0
37653: PUSH
37654: EMPTY
37655: LIST
37656: LIST
37657: PUSH
37658: LD_INT 0
37660: PUSH
37661: LD_INT 1
37663: NEG
37664: PUSH
37665: EMPTY
37666: LIST
37667: LIST
37668: PUSH
37669: LD_INT 1
37671: PUSH
37672: LD_INT 0
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 1
37681: PUSH
37682: LD_INT 1
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: LD_INT 0
37691: PUSH
37692: LD_INT 1
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 1
37701: NEG
37702: PUSH
37703: LD_INT 0
37705: PUSH
37706: EMPTY
37707: LIST
37708: LIST
37709: PUSH
37710: LD_INT 1
37712: NEG
37713: PUSH
37714: LD_INT 1
37716: NEG
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: PUSH
37722: LD_INT 1
37724: NEG
37725: PUSH
37726: LD_INT 2
37728: NEG
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 1
37736: PUSH
37737: LD_INT 1
37739: NEG
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 2
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 2
37757: PUSH
37758: LD_INT 1
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 2
37767: PUSH
37768: LD_INT 2
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 1
37777: PUSH
37778: LD_INT 2
37780: PUSH
37781: EMPTY
37782: LIST
37783: LIST
37784: PUSH
37785: LD_INT 1
37787: NEG
37788: PUSH
37789: LD_INT 1
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: LD_INT 2
37798: NEG
37799: PUSH
37800: LD_INT 0
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: LD_INT 2
37809: NEG
37810: PUSH
37811: LD_INT 1
37813: NEG
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: LD_INT 2
37821: NEG
37822: PUSH
37823: LD_INT 2
37825: NEG
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 2
37833: NEG
37834: PUSH
37835: LD_INT 3
37837: NEG
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 2
37845: PUSH
37846: LD_INT 1
37848: NEG
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 3
37856: PUSH
37857: LD_INT 0
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: LD_INT 3
37866: PUSH
37867: LD_INT 1
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 3
37876: PUSH
37877: LD_INT 2
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 3
37886: PUSH
37887: LD_INT 3
37889: PUSH
37890: EMPTY
37891: LIST
37892: LIST
37893: PUSH
37894: LD_INT 2
37896: PUSH
37897: LD_INT 3
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: LD_INT 2
37906: NEG
37907: PUSH
37908: LD_INT 1
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: LD_INT 3
37917: NEG
37918: PUSH
37919: LD_INT 0
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: PUSH
37926: LD_INT 3
37928: NEG
37929: PUSH
37930: LD_INT 1
37932: NEG
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 3
37940: NEG
37941: PUSH
37942: LD_INT 2
37944: NEG
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: LD_INT 3
37952: NEG
37953: PUSH
37954: LD_INT 3
37956: NEG
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: EMPTY
37963: LIST
37964: LIST
37965: LIST
37966: LIST
37967: LIST
37968: LIST
37969: LIST
37970: LIST
37971: LIST
37972: LIST
37973: LIST
37974: LIST
37975: LIST
37976: LIST
37977: LIST
37978: LIST
37979: LIST
37980: LIST
37981: LIST
37982: LIST
37983: LIST
37984: LIST
37985: LIST
37986: LIST
37987: LIST
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37993: LD_ADDR_VAR 0 42
37997: PUSH
37998: LD_INT 0
38000: PUSH
38001: LD_INT 0
38003: PUSH
38004: EMPTY
38005: LIST
38006: LIST
38007: PUSH
38008: LD_INT 0
38010: PUSH
38011: LD_INT 1
38013: NEG
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: PUSH
38019: LD_INT 1
38021: PUSH
38022: LD_INT 0
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: PUSH
38029: LD_INT 1
38031: PUSH
38032: LD_INT 1
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 0
38041: PUSH
38042: LD_INT 1
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: LD_INT 1
38051: NEG
38052: PUSH
38053: LD_INT 0
38055: PUSH
38056: EMPTY
38057: LIST
38058: LIST
38059: PUSH
38060: LD_INT 1
38062: NEG
38063: PUSH
38064: LD_INT 1
38066: NEG
38067: PUSH
38068: EMPTY
38069: LIST
38070: LIST
38071: PUSH
38072: LD_INT 1
38074: NEG
38075: PUSH
38076: LD_INT 2
38078: NEG
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PUSH
38084: LD_INT 0
38086: PUSH
38087: LD_INT 2
38089: NEG
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 1
38097: PUSH
38098: LD_INT 1
38100: NEG
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: LD_INT 2
38108: PUSH
38109: LD_INT 1
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: LD_INT 2
38118: PUSH
38119: LD_INT 2
38121: PUSH
38122: EMPTY
38123: LIST
38124: LIST
38125: PUSH
38126: LD_INT 1
38128: PUSH
38129: LD_INT 2
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 0
38138: PUSH
38139: LD_INT 2
38141: PUSH
38142: EMPTY
38143: LIST
38144: LIST
38145: PUSH
38146: LD_INT 1
38148: NEG
38149: PUSH
38150: LD_INT 1
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: LD_INT 2
38159: NEG
38160: PUSH
38161: LD_INT 1
38163: NEG
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: LD_INT 2
38171: NEG
38172: PUSH
38173: LD_INT 2
38175: NEG
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 2
38183: NEG
38184: PUSH
38185: LD_INT 3
38187: NEG
38188: PUSH
38189: EMPTY
38190: LIST
38191: LIST
38192: PUSH
38193: LD_INT 1
38195: NEG
38196: PUSH
38197: LD_INT 3
38199: NEG
38200: PUSH
38201: EMPTY
38202: LIST
38203: LIST
38204: PUSH
38205: LD_INT 0
38207: PUSH
38208: LD_INT 3
38210: NEG
38211: PUSH
38212: EMPTY
38213: LIST
38214: LIST
38215: PUSH
38216: LD_INT 1
38218: PUSH
38219: LD_INT 2
38221: NEG
38222: PUSH
38223: EMPTY
38224: LIST
38225: LIST
38226: PUSH
38227: LD_INT 3
38229: PUSH
38230: LD_INT 2
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: PUSH
38237: LD_INT 3
38239: PUSH
38240: LD_INT 3
38242: PUSH
38243: EMPTY
38244: LIST
38245: LIST
38246: PUSH
38247: LD_INT 2
38249: PUSH
38250: LD_INT 3
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: PUSH
38257: LD_INT 1
38259: PUSH
38260: LD_INT 3
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 0
38269: PUSH
38270: LD_INT 3
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: PUSH
38277: LD_INT 1
38279: NEG
38280: PUSH
38281: LD_INT 2
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 3
38290: NEG
38291: PUSH
38292: LD_INT 2
38294: NEG
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 3
38302: NEG
38303: PUSH
38304: LD_INT 3
38306: NEG
38307: PUSH
38308: EMPTY
38309: LIST
38310: LIST
38311: PUSH
38312: EMPTY
38313: LIST
38314: LIST
38315: LIST
38316: LIST
38317: LIST
38318: LIST
38319: LIST
38320: LIST
38321: LIST
38322: LIST
38323: LIST
38324: LIST
38325: LIST
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: LIST
38341: LIST
38342: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38343: LD_ADDR_VAR 0 43
38347: PUSH
38348: LD_INT 0
38350: PUSH
38351: LD_INT 0
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: LD_INT 0
38360: PUSH
38361: LD_INT 1
38363: NEG
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 1
38371: PUSH
38372: LD_INT 0
38374: PUSH
38375: EMPTY
38376: LIST
38377: LIST
38378: PUSH
38379: LD_INT 1
38381: PUSH
38382: LD_INT 1
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: LD_INT 0
38391: PUSH
38392: LD_INT 1
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: PUSH
38399: LD_INT 1
38401: NEG
38402: PUSH
38403: LD_INT 0
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 1
38412: NEG
38413: PUSH
38414: LD_INT 1
38416: NEG
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 1
38424: NEG
38425: PUSH
38426: LD_INT 2
38428: NEG
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: LD_INT 0
38436: PUSH
38437: LD_INT 2
38439: NEG
38440: PUSH
38441: EMPTY
38442: LIST
38443: LIST
38444: PUSH
38445: LD_INT 1
38447: PUSH
38448: LD_INT 1
38450: NEG
38451: PUSH
38452: EMPTY
38453: LIST
38454: LIST
38455: PUSH
38456: LD_INT 2
38458: PUSH
38459: LD_INT 0
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: PUSH
38466: LD_INT 2
38468: PUSH
38469: LD_INT 1
38471: PUSH
38472: EMPTY
38473: LIST
38474: LIST
38475: PUSH
38476: LD_INT 1
38478: PUSH
38479: LD_INT 2
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: LD_INT 0
38488: PUSH
38489: LD_INT 2
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: PUSH
38496: LD_INT 1
38498: NEG
38499: PUSH
38500: LD_INT 1
38502: PUSH
38503: EMPTY
38504: LIST
38505: LIST
38506: PUSH
38507: LD_INT 2
38509: NEG
38510: PUSH
38511: LD_INT 0
38513: PUSH
38514: EMPTY
38515: LIST
38516: LIST
38517: PUSH
38518: LD_INT 2
38520: NEG
38521: PUSH
38522: LD_INT 1
38524: NEG
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: LD_INT 1
38532: NEG
38533: PUSH
38534: LD_INT 3
38536: NEG
38537: PUSH
38538: EMPTY
38539: LIST
38540: LIST
38541: PUSH
38542: LD_INT 0
38544: PUSH
38545: LD_INT 3
38547: NEG
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 1
38555: PUSH
38556: LD_INT 2
38558: NEG
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 2
38566: PUSH
38567: LD_INT 1
38569: NEG
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: PUSH
38575: LD_INT 3
38577: PUSH
38578: LD_INT 0
38580: PUSH
38581: EMPTY
38582: LIST
38583: LIST
38584: PUSH
38585: LD_INT 3
38587: PUSH
38588: LD_INT 1
38590: PUSH
38591: EMPTY
38592: LIST
38593: LIST
38594: PUSH
38595: LD_INT 1
38597: PUSH
38598: LD_INT 3
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 0
38607: PUSH
38608: LD_INT 3
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: LD_INT 1
38617: NEG
38618: PUSH
38619: LD_INT 2
38621: PUSH
38622: EMPTY
38623: LIST
38624: LIST
38625: PUSH
38626: LD_INT 2
38628: NEG
38629: PUSH
38630: LD_INT 1
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 3
38639: NEG
38640: PUSH
38641: LD_INT 0
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 3
38650: NEG
38651: PUSH
38652: LD_INT 1
38654: NEG
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: LIST
38664: LIST
38665: LIST
38666: LIST
38667: LIST
38668: LIST
38669: LIST
38670: LIST
38671: LIST
38672: LIST
38673: LIST
38674: LIST
38675: LIST
38676: LIST
38677: LIST
38678: LIST
38679: LIST
38680: LIST
38681: LIST
38682: LIST
38683: LIST
38684: LIST
38685: LIST
38686: LIST
38687: LIST
38688: LIST
38689: LIST
38690: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38691: LD_ADDR_VAR 0 44
38695: PUSH
38696: LD_INT 0
38698: PUSH
38699: LD_INT 0
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 0
38708: PUSH
38709: LD_INT 1
38711: NEG
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PUSH
38717: LD_INT 1
38719: PUSH
38720: LD_INT 0
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: LD_INT 1
38729: PUSH
38730: LD_INT 1
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: PUSH
38737: LD_INT 0
38739: PUSH
38740: LD_INT 1
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 1
38749: NEG
38750: PUSH
38751: LD_INT 0
38753: PUSH
38754: EMPTY
38755: LIST
38756: LIST
38757: PUSH
38758: LD_INT 1
38760: NEG
38761: PUSH
38762: LD_INT 1
38764: NEG
38765: PUSH
38766: EMPTY
38767: LIST
38768: LIST
38769: PUSH
38770: LD_INT 1
38772: NEG
38773: PUSH
38774: LD_INT 2
38776: NEG
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: LD_INT 1
38784: PUSH
38785: LD_INT 1
38787: NEG
38788: PUSH
38789: EMPTY
38790: LIST
38791: LIST
38792: PUSH
38793: LD_INT 2
38795: PUSH
38796: LD_INT 0
38798: PUSH
38799: EMPTY
38800: LIST
38801: LIST
38802: PUSH
38803: LD_INT 2
38805: PUSH
38806: LD_INT 1
38808: PUSH
38809: EMPTY
38810: LIST
38811: LIST
38812: PUSH
38813: LD_INT 2
38815: PUSH
38816: LD_INT 2
38818: PUSH
38819: EMPTY
38820: LIST
38821: LIST
38822: PUSH
38823: LD_INT 1
38825: PUSH
38826: LD_INT 2
38828: PUSH
38829: EMPTY
38830: LIST
38831: LIST
38832: PUSH
38833: LD_INT 1
38835: NEG
38836: PUSH
38837: LD_INT 1
38839: PUSH
38840: EMPTY
38841: LIST
38842: LIST
38843: PUSH
38844: LD_INT 2
38846: NEG
38847: PUSH
38848: LD_INT 0
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: LD_INT 2
38857: NEG
38858: PUSH
38859: LD_INT 1
38861: NEG
38862: PUSH
38863: EMPTY
38864: LIST
38865: LIST
38866: PUSH
38867: LD_INT 2
38869: NEG
38870: PUSH
38871: LD_INT 2
38873: NEG
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: LD_INT 2
38881: NEG
38882: PUSH
38883: LD_INT 3
38885: NEG
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PUSH
38891: LD_INT 2
38893: PUSH
38894: LD_INT 1
38896: NEG
38897: PUSH
38898: EMPTY
38899: LIST
38900: LIST
38901: PUSH
38902: LD_INT 3
38904: PUSH
38905: LD_INT 0
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: LD_INT 3
38914: PUSH
38915: LD_INT 1
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 3
38924: PUSH
38925: LD_INT 2
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: LD_INT 3
38934: PUSH
38935: LD_INT 3
38937: PUSH
38938: EMPTY
38939: LIST
38940: LIST
38941: PUSH
38942: LD_INT 2
38944: PUSH
38945: LD_INT 3
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 2
38954: NEG
38955: PUSH
38956: LD_INT 1
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: PUSH
38963: LD_INT 3
38965: NEG
38966: PUSH
38967: LD_INT 0
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: PUSH
38974: LD_INT 3
38976: NEG
38977: PUSH
38978: LD_INT 1
38980: NEG
38981: PUSH
38982: EMPTY
38983: LIST
38984: LIST
38985: PUSH
38986: LD_INT 3
38988: NEG
38989: PUSH
38990: LD_INT 2
38992: NEG
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 3
39000: NEG
39001: PUSH
39002: LD_INT 3
39004: NEG
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: EMPTY
39011: LIST
39012: LIST
39013: LIST
39014: LIST
39015: LIST
39016: LIST
39017: LIST
39018: LIST
39019: LIST
39020: LIST
39021: LIST
39022: LIST
39023: LIST
39024: LIST
39025: LIST
39026: LIST
39027: LIST
39028: LIST
39029: LIST
39030: LIST
39031: LIST
39032: LIST
39033: LIST
39034: LIST
39035: LIST
39036: LIST
39037: LIST
39038: LIST
39039: LIST
39040: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39041: LD_ADDR_VAR 0 45
39045: PUSH
39046: LD_INT 0
39048: PUSH
39049: LD_INT 0
39051: PUSH
39052: EMPTY
39053: LIST
39054: LIST
39055: PUSH
39056: LD_INT 0
39058: PUSH
39059: LD_INT 1
39061: NEG
39062: PUSH
39063: EMPTY
39064: LIST
39065: LIST
39066: PUSH
39067: LD_INT 1
39069: PUSH
39070: LD_INT 0
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PUSH
39077: LD_INT 1
39079: PUSH
39080: LD_INT 1
39082: PUSH
39083: EMPTY
39084: LIST
39085: LIST
39086: PUSH
39087: LD_INT 0
39089: PUSH
39090: LD_INT 1
39092: PUSH
39093: EMPTY
39094: LIST
39095: LIST
39096: PUSH
39097: LD_INT 1
39099: NEG
39100: PUSH
39101: LD_INT 0
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: PUSH
39108: LD_INT 1
39110: NEG
39111: PUSH
39112: LD_INT 1
39114: NEG
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: PUSH
39120: LD_INT 1
39122: NEG
39123: PUSH
39124: LD_INT 2
39126: NEG
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: LD_INT 0
39134: PUSH
39135: LD_INT 2
39137: NEG
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 1
39145: PUSH
39146: LD_INT 1
39148: NEG
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: LD_INT 2
39156: PUSH
39157: LD_INT 1
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 2
39166: PUSH
39167: LD_INT 2
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 1
39176: PUSH
39177: LD_INT 2
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: PUSH
39184: LD_INT 0
39186: PUSH
39187: LD_INT 2
39189: PUSH
39190: EMPTY
39191: LIST
39192: LIST
39193: PUSH
39194: LD_INT 1
39196: NEG
39197: PUSH
39198: LD_INT 1
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 2
39207: NEG
39208: PUSH
39209: LD_INT 1
39211: NEG
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: PUSH
39217: LD_INT 2
39219: NEG
39220: PUSH
39221: LD_INT 2
39223: NEG
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 2
39231: NEG
39232: PUSH
39233: LD_INT 3
39235: NEG
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: PUSH
39241: LD_INT 1
39243: NEG
39244: PUSH
39245: LD_INT 3
39247: NEG
39248: PUSH
39249: EMPTY
39250: LIST
39251: LIST
39252: PUSH
39253: LD_INT 0
39255: PUSH
39256: LD_INT 3
39258: NEG
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: PUSH
39264: LD_INT 1
39266: PUSH
39267: LD_INT 2
39269: NEG
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: LD_INT 3
39277: PUSH
39278: LD_INT 2
39280: PUSH
39281: EMPTY
39282: LIST
39283: LIST
39284: PUSH
39285: LD_INT 3
39287: PUSH
39288: LD_INT 3
39290: PUSH
39291: EMPTY
39292: LIST
39293: LIST
39294: PUSH
39295: LD_INT 2
39297: PUSH
39298: LD_INT 3
39300: PUSH
39301: EMPTY
39302: LIST
39303: LIST
39304: PUSH
39305: LD_INT 1
39307: PUSH
39308: LD_INT 3
39310: PUSH
39311: EMPTY
39312: LIST
39313: LIST
39314: PUSH
39315: LD_INT 0
39317: PUSH
39318: LD_INT 3
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 1
39327: NEG
39328: PUSH
39329: LD_INT 2
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: LD_INT 3
39338: NEG
39339: PUSH
39340: LD_INT 2
39342: NEG
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: PUSH
39348: LD_INT 3
39350: NEG
39351: PUSH
39352: LD_INT 3
39354: NEG
39355: PUSH
39356: EMPTY
39357: LIST
39358: LIST
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: LIST
39364: LIST
39365: LIST
39366: LIST
39367: LIST
39368: LIST
39369: LIST
39370: LIST
39371: LIST
39372: LIST
39373: LIST
39374: LIST
39375: LIST
39376: LIST
39377: LIST
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: LIST
39385: LIST
39386: LIST
39387: LIST
39388: LIST
39389: LIST
39390: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39391: LD_ADDR_VAR 0 46
39395: PUSH
39396: LD_INT 0
39398: PUSH
39399: LD_INT 0
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: PUSH
39406: LD_INT 0
39408: PUSH
39409: LD_INT 1
39411: NEG
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 1
39419: PUSH
39420: LD_INT 0
39422: PUSH
39423: EMPTY
39424: LIST
39425: LIST
39426: PUSH
39427: LD_INT 1
39429: PUSH
39430: LD_INT 1
39432: PUSH
39433: EMPTY
39434: LIST
39435: LIST
39436: PUSH
39437: LD_INT 0
39439: PUSH
39440: LD_INT 1
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 1
39449: NEG
39450: PUSH
39451: LD_INT 0
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PUSH
39458: LD_INT 1
39460: NEG
39461: PUSH
39462: LD_INT 1
39464: NEG
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: LD_INT 1
39472: NEG
39473: PUSH
39474: LD_INT 2
39476: NEG
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 0
39484: PUSH
39485: LD_INT 2
39487: NEG
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PUSH
39493: LD_INT 1
39495: PUSH
39496: LD_INT 1
39498: NEG
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: LD_INT 2
39506: PUSH
39507: LD_INT 0
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: LD_INT 2
39516: PUSH
39517: LD_INT 1
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PUSH
39524: LD_INT 1
39526: PUSH
39527: LD_INT 2
39529: PUSH
39530: EMPTY
39531: LIST
39532: LIST
39533: PUSH
39534: LD_INT 0
39536: PUSH
39537: LD_INT 2
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PUSH
39544: LD_INT 1
39546: NEG
39547: PUSH
39548: LD_INT 1
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 2
39557: NEG
39558: PUSH
39559: LD_INT 0
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 2
39568: NEG
39569: PUSH
39570: LD_INT 1
39572: NEG
39573: PUSH
39574: EMPTY
39575: LIST
39576: LIST
39577: PUSH
39578: LD_INT 1
39580: NEG
39581: PUSH
39582: LD_INT 3
39584: NEG
39585: PUSH
39586: EMPTY
39587: LIST
39588: LIST
39589: PUSH
39590: LD_INT 0
39592: PUSH
39593: LD_INT 3
39595: NEG
39596: PUSH
39597: EMPTY
39598: LIST
39599: LIST
39600: PUSH
39601: LD_INT 1
39603: PUSH
39604: LD_INT 2
39606: NEG
39607: PUSH
39608: EMPTY
39609: LIST
39610: LIST
39611: PUSH
39612: LD_INT 2
39614: PUSH
39615: LD_INT 1
39617: NEG
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 3
39625: PUSH
39626: LD_INT 0
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: LD_INT 3
39635: PUSH
39636: LD_INT 1
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 1
39645: PUSH
39646: LD_INT 3
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 0
39655: PUSH
39656: LD_INT 3
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 1
39665: NEG
39666: PUSH
39667: LD_INT 2
39669: PUSH
39670: EMPTY
39671: LIST
39672: LIST
39673: PUSH
39674: LD_INT 2
39676: NEG
39677: PUSH
39678: LD_INT 1
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 3
39687: NEG
39688: PUSH
39689: LD_INT 0
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: LD_INT 3
39698: NEG
39699: PUSH
39700: LD_INT 1
39702: NEG
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: LIST
39712: LIST
39713: LIST
39714: LIST
39715: LIST
39716: LIST
39717: LIST
39718: LIST
39719: LIST
39720: LIST
39721: LIST
39722: LIST
39723: LIST
39724: LIST
39725: LIST
39726: LIST
39727: LIST
39728: LIST
39729: LIST
39730: LIST
39731: LIST
39732: LIST
39733: LIST
39734: LIST
39735: LIST
39736: LIST
39737: LIST
39738: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39739: LD_ADDR_VAR 0 47
39743: PUSH
39744: LD_INT 0
39746: PUSH
39747: LD_INT 0
39749: PUSH
39750: EMPTY
39751: LIST
39752: LIST
39753: PUSH
39754: LD_INT 0
39756: PUSH
39757: LD_INT 1
39759: NEG
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PUSH
39765: LD_INT 1
39767: PUSH
39768: LD_INT 0
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: PUSH
39775: LD_INT 1
39777: PUSH
39778: LD_INT 1
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 0
39787: PUSH
39788: LD_INT 1
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: PUSH
39795: LD_INT 1
39797: NEG
39798: PUSH
39799: LD_INT 0
39801: PUSH
39802: EMPTY
39803: LIST
39804: LIST
39805: PUSH
39806: LD_INT 1
39808: NEG
39809: PUSH
39810: LD_INT 1
39812: NEG
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 1
39820: NEG
39821: PUSH
39822: LD_INT 2
39824: NEG
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: LD_INT 0
39832: PUSH
39833: LD_INT 2
39835: NEG
39836: PUSH
39837: EMPTY
39838: LIST
39839: LIST
39840: PUSH
39841: LD_INT 1
39843: PUSH
39844: LD_INT 1
39846: NEG
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 2
39854: NEG
39855: PUSH
39856: LD_INT 1
39858: NEG
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: PUSH
39864: LD_INT 2
39866: NEG
39867: PUSH
39868: LD_INT 2
39870: NEG
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: LIST
39882: LIST
39883: LIST
39884: LIST
39885: LIST
39886: LIST
39887: LIST
39888: LIST
39889: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39890: LD_ADDR_VAR 0 48
39894: PUSH
39895: LD_INT 0
39897: PUSH
39898: LD_INT 0
39900: PUSH
39901: EMPTY
39902: LIST
39903: LIST
39904: PUSH
39905: LD_INT 0
39907: PUSH
39908: LD_INT 1
39910: NEG
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PUSH
39916: LD_INT 1
39918: PUSH
39919: LD_INT 0
39921: PUSH
39922: EMPTY
39923: LIST
39924: LIST
39925: PUSH
39926: LD_INT 1
39928: PUSH
39929: LD_INT 1
39931: PUSH
39932: EMPTY
39933: LIST
39934: LIST
39935: PUSH
39936: LD_INT 0
39938: PUSH
39939: LD_INT 1
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PUSH
39946: LD_INT 1
39948: NEG
39949: PUSH
39950: LD_INT 0
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: LD_INT 1
39959: NEG
39960: PUSH
39961: LD_INT 1
39963: NEG
39964: PUSH
39965: EMPTY
39966: LIST
39967: LIST
39968: PUSH
39969: LD_INT 1
39971: NEG
39972: PUSH
39973: LD_INT 2
39975: NEG
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: LD_INT 0
39983: PUSH
39984: LD_INT 2
39986: NEG
39987: PUSH
39988: EMPTY
39989: LIST
39990: LIST
39991: PUSH
39992: LD_INT 1
39994: PUSH
39995: LD_INT 1
39997: NEG
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 2
40005: PUSH
40006: LD_INT 0
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: LD_INT 2
40015: PUSH
40016: LD_INT 1
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PUSH
40023: EMPTY
40024: LIST
40025: LIST
40026: LIST
40027: LIST
40028: LIST
40029: LIST
40030: LIST
40031: LIST
40032: LIST
40033: LIST
40034: LIST
40035: LIST
40036: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
40037: LD_ADDR_VAR 0 49
40041: PUSH
40042: LD_INT 0
40044: PUSH
40045: LD_INT 0
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 0
40054: PUSH
40055: LD_INT 1
40057: NEG
40058: PUSH
40059: EMPTY
40060: LIST
40061: LIST
40062: PUSH
40063: LD_INT 1
40065: PUSH
40066: LD_INT 0
40068: PUSH
40069: EMPTY
40070: LIST
40071: LIST
40072: PUSH
40073: LD_INT 1
40075: PUSH
40076: LD_INT 1
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 0
40085: PUSH
40086: LD_INT 1
40088: PUSH
40089: EMPTY
40090: LIST
40091: LIST
40092: PUSH
40093: LD_INT 1
40095: NEG
40096: PUSH
40097: LD_INT 0
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: LD_INT 1
40106: NEG
40107: PUSH
40108: LD_INT 1
40110: NEG
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 1
40118: PUSH
40119: LD_INT 1
40121: NEG
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: LD_INT 2
40129: PUSH
40130: LD_INT 0
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PUSH
40137: LD_INT 2
40139: PUSH
40140: LD_INT 1
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 2
40149: PUSH
40150: LD_INT 2
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 1
40159: PUSH
40160: LD_INT 2
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: LIST
40171: LIST
40172: LIST
40173: LIST
40174: LIST
40175: LIST
40176: LIST
40177: LIST
40178: LIST
40179: LIST
40180: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
40181: LD_ADDR_VAR 0 50
40185: PUSH
40186: LD_INT 0
40188: PUSH
40189: LD_INT 0
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: LD_INT 0
40198: PUSH
40199: LD_INT 1
40201: NEG
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 1
40209: PUSH
40210: LD_INT 0
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 1
40219: PUSH
40220: LD_INT 1
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: PUSH
40227: LD_INT 0
40229: PUSH
40230: LD_INT 1
40232: PUSH
40233: EMPTY
40234: LIST
40235: LIST
40236: PUSH
40237: LD_INT 1
40239: NEG
40240: PUSH
40241: LD_INT 0
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 1
40250: NEG
40251: PUSH
40252: LD_INT 1
40254: NEG
40255: PUSH
40256: EMPTY
40257: LIST
40258: LIST
40259: PUSH
40260: LD_INT 2
40262: PUSH
40263: LD_INT 1
40265: PUSH
40266: EMPTY
40267: LIST
40268: LIST
40269: PUSH
40270: LD_INT 2
40272: PUSH
40273: LD_INT 2
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: PUSH
40280: LD_INT 1
40282: PUSH
40283: LD_INT 2
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: PUSH
40290: LD_INT 0
40292: PUSH
40293: LD_INT 2
40295: PUSH
40296: EMPTY
40297: LIST
40298: LIST
40299: PUSH
40300: LD_INT 1
40302: NEG
40303: PUSH
40304: LD_INT 1
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: LIST
40315: LIST
40316: LIST
40317: LIST
40318: LIST
40319: LIST
40320: LIST
40321: LIST
40322: LIST
40323: LIST
40324: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
40325: LD_ADDR_VAR 0 51
40329: PUSH
40330: LD_INT 0
40332: PUSH
40333: LD_INT 0
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: LD_INT 0
40342: PUSH
40343: LD_INT 1
40345: NEG
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: LD_INT 1
40353: PUSH
40354: LD_INT 0
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 1
40363: PUSH
40364: LD_INT 1
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 0
40373: PUSH
40374: LD_INT 1
40376: PUSH
40377: EMPTY
40378: LIST
40379: LIST
40380: PUSH
40381: LD_INT 1
40383: NEG
40384: PUSH
40385: LD_INT 0
40387: PUSH
40388: EMPTY
40389: LIST
40390: LIST
40391: PUSH
40392: LD_INT 1
40394: NEG
40395: PUSH
40396: LD_INT 1
40398: NEG
40399: PUSH
40400: EMPTY
40401: LIST
40402: LIST
40403: PUSH
40404: LD_INT 1
40406: PUSH
40407: LD_INT 2
40409: PUSH
40410: EMPTY
40411: LIST
40412: LIST
40413: PUSH
40414: LD_INT 0
40416: PUSH
40417: LD_INT 2
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 1
40426: NEG
40427: PUSH
40428: LD_INT 1
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: PUSH
40435: LD_INT 2
40437: NEG
40438: PUSH
40439: LD_INT 0
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PUSH
40446: LD_INT 2
40448: NEG
40449: PUSH
40450: LD_INT 1
40452: NEG
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PUSH
40458: EMPTY
40459: LIST
40460: LIST
40461: LIST
40462: LIST
40463: LIST
40464: LIST
40465: LIST
40466: LIST
40467: LIST
40468: LIST
40469: LIST
40470: LIST
40471: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40472: LD_ADDR_VAR 0 52
40476: PUSH
40477: LD_INT 0
40479: PUSH
40480: LD_INT 0
40482: PUSH
40483: EMPTY
40484: LIST
40485: LIST
40486: PUSH
40487: LD_INT 0
40489: PUSH
40490: LD_INT 1
40492: NEG
40493: PUSH
40494: EMPTY
40495: LIST
40496: LIST
40497: PUSH
40498: LD_INT 1
40500: PUSH
40501: LD_INT 0
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: PUSH
40508: LD_INT 1
40510: PUSH
40511: LD_INT 1
40513: PUSH
40514: EMPTY
40515: LIST
40516: LIST
40517: PUSH
40518: LD_INT 0
40520: PUSH
40521: LD_INT 1
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 1
40530: NEG
40531: PUSH
40532: LD_INT 0
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 1
40541: NEG
40542: PUSH
40543: LD_INT 1
40545: NEG
40546: PUSH
40547: EMPTY
40548: LIST
40549: LIST
40550: PUSH
40551: LD_INT 1
40553: NEG
40554: PUSH
40555: LD_INT 2
40557: NEG
40558: PUSH
40559: EMPTY
40560: LIST
40561: LIST
40562: PUSH
40563: LD_INT 1
40565: NEG
40566: PUSH
40567: LD_INT 1
40569: PUSH
40570: EMPTY
40571: LIST
40572: LIST
40573: PUSH
40574: LD_INT 2
40576: NEG
40577: PUSH
40578: LD_INT 0
40580: PUSH
40581: EMPTY
40582: LIST
40583: LIST
40584: PUSH
40585: LD_INT 2
40587: NEG
40588: PUSH
40589: LD_INT 1
40591: NEG
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: PUSH
40597: LD_INT 2
40599: NEG
40600: PUSH
40601: LD_INT 2
40603: NEG
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: PUSH
40609: EMPTY
40610: LIST
40611: LIST
40612: LIST
40613: LIST
40614: LIST
40615: LIST
40616: LIST
40617: LIST
40618: LIST
40619: LIST
40620: LIST
40621: LIST
40622: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40623: LD_ADDR_VAR 0 53
40627: PUSH
40628: LD_INT 0
40630: PUSH
40631: LD_INT 0
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: PUSH
40638: LD_INT 0
40640: PUSH
40641: LD_INT 1
40643: NEG
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: LD_INT 1
40651: PUSH
40652: LD_INT 0
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 1
40661: PUSH
40662: LD_INT 1
40664: PUSH
40665: EMPTY
40666: LIST
40667: LIST
40668: PUSH
40669: LD_INT 0
40671: PUSH
40672: LD_INT 1
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: PUSH
40679: LD_INT 1
40681: NEG
40682: PUSH
40683: LD_INT 0
40685: PUSH
40686: EMPTY
40687: LIST
40688: LIST
40689: PUSH
40690: LD_INT 1
40692: NEG
40693: PUSH
40694: LD_INT 1
40696: NEG
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 1
40704: NEG
40705: PUSH
40706: LD_INT 2
40708: NEG
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: PUSH
40714: LD_INT 0
40716: PUSH
40717: LD_INT 2
40719: NEG
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 1
40727: PUSH
40728: LD_INT 1
40730: NEG
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: PUSH
40736: LD_INT 2
40738: PUSH
40739: LD_INT 0
40741: PUSH
40742: EMPTY
40743: LIST
40744: LIST
40745: PUSH
40746: LD_INT 2
40748: PUSH
40749: LD_INT 1
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: PUSH
40756: LD_INT 2
40758: PUSH
40759: LD_INT 2
40761: PUSH
40762: EMPTY
40763: LIST
40764: LIST
40765: PUSH
40766: LD_INT 1
40768: PUSH
40769: LD_INT 2
40771: PUSH
40772: EMPTY
40773: LIST
40774: LIST
40775: PUSH
40776: LD_INT 0
40778: PUSH
40779: LD_INT 2
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 1
40788: NEG
40789: PUSH
40790: LD_INT 1
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 2
40799: NEG
40800: PUSH
40801: LD_INT 0
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 2
40810: NEG
40811: PUSH
40812: LD_INT 1
40814: NEG
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: LD_INT 2
40822: NEG
40823: PUSH
40824: LD_INT 2
40826: NEG
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: EMPTY
40833: LIST
40834: LIST
40835: LIST
40836: LIST
40837: LIST
40838: LIST
40839: LIST
40840: LIST
40841: LIST
40842: LIST
40843: LIST
40844: LIST
40845: LIST
40846: LIST
40847: LIST
40848: LIST
40849: LIST
40850: LIST
40851: LIST
40852: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40853: LD_ADDR_VAR 0 54
40857: PUSH
40858: LD_INT 0
40860: PUSH
40861: LD_INT 0
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: PUSH
40868: LD_INT 0
40870: PUSH
40871: LD_INT 1
40873: NEG
40874: PUSH
40875: EMPTY
40876: LIST
40877: LIST
40878: PUSH
40879: LD_INT 1
40881: PUSH
40882: LD_INT 0
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 1
40891: PUSH
40892: LD_INT 1
40894: PUSH
40895: EMPTY
40896: LIST
40897: LIST
40898: PUSH
40899: LD_INT 0
40901: PUSH
40902: LD_INT 1
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: PUSH
40909: LD_INT 1
40911: NEG
40912: PUSH
40913: LD_INT 0
40915: PUSH
40916: EMPTY
40917: LIST
40918: LIST
40919: PUSH
40920: LD_INT 1
40922: NEG
40923: PUSH
40924: LD_INT 1
40926: NEG
40927: PUSH
40928: EMPTY
40929: LIST
40930: LIST
40931: PUSH
40932: LD_INT 1
40934: NEG
40935: PUSH
40936: LD_INT 2
40938: NEG
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: LD_INT 0
40946: PUSH
40947: LD_INT 2
40949: NEG
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: LD_INT 1
40957: PUSH
40958: LD_INT 1
40960: NEG
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 2
40968: PUSH
40969: LD_INT 0
40971: PUSH
40972: EMPTY
40973: LIST
40974: LIST
40975: PUSH
40976: LD_INT 2
40978: PUSH
40979: LD_INT 1
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PUSH
40986: LD_INT 2
40988: PUSH
40989: LD_INT 2
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PUSH
40996: LD_INT 1
40998: PUSH
40999: LD_INT 2
41001: PUSH
41002: EMPTY
41003: LIST
41004: LIST
41005: PUSH
41006: LD_INT 0
41008: PUSH
41009: LD_INT 2
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 1
41018: NEG
41019: PUSH
41020: LD_INT 1
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 2
41029: NEG
41030: PUSH
41031: LD_INT 0
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: PUSH
41038: LD_INT 2
41040: NEG
41041: PUSH
41042: LD_INT 1
41044: NEG
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: PUSH
41050: LD_INT 2
41052: NEG
41053: PUSH
41054: LD_INT 2
41056: NEG
41057: PUSH
41058: EMPTY
41059: LIST
41060: LIST
41061: PUSH
41062: EMPTY
41063: LIST
41064: LIST
41065: LIST
41066: LIST
41067: LIST
41068: LIST
41069: LIST
41070: LIST
41071: LIST
41072: LIST
41073: LIST
41074: LIST
41075: LIST
41076: LIST
41077: LIST
41078: LIST
41079: LIST
41080: LIST
41081: LIST
41082: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41083: LD_ADDR_VAR 0 55
41087: PUSH
41088: LD_INT 0
41090: PUSH
41091: LD_INT 0
41093: PUSH
41094: EMPTY
41095: LIST
41096: LIST
41097: PUSH
41098: LD_INT 0
41100: PUSH
41101: LD_INT 1
41103: NEG
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PUSH
41109: LD_INT 1
41111: PUSH
41112: LD_INT 0
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: PUSH
41119: LD_INT 1
41121: PUSH
41122: LD_INT 1
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: PUSH
41129: LD_INT 0
41131: PUSH
41132: LD_INT 1
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 1
41141: NEG
41142: PUSH
41143: LD_INT 0
41145: PUSH
41146: EMPTY
41147: LIST
41148: LIST
41149: PUSH
41150: LD_INT 1
41152: NEG
41153: PUSH
41154: LD_INT 1
41156: NEG
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 1
41164: NEG
41165: PUSH
41166: LD_INT 2
41168: NEG
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: LD_INT 0
41176: PUSH
41177: LD_INT 2
41179: NEG
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: LD_INT 1
41187: PUSH
41188: LD_INT 1
41190: NEG
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: LD_INT 2
41198: PUSH
41199: LD_INT 0
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 2
41208: PUSH
41209: LD_INT 1
41211: PUSH
41212: EMPTY
41213: LIST
41214: LIST
41215: PUSH
41216: LD_INT 2
41218: PUSH
41219: LD_INT 2
41221: PUSH
41222: EMPTY
41223: LIST
41224: LIST
41225: PUSH
41226: LD_INT 1
41228: PUSH
41229: LD_INT 2
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: LD_INT 0
41238: PUSH
41239: LD_INT 2
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: PUSH
41246: LD_INT 1
41248: NEG
41249: PUSH
41250: LD_INT 1
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: LD_INT 2
41259: NEG
41260: PUSH
41261: LD_INT 0
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 2
41270: NEG
41271: PUSH
41272: LD_INT 1
41274: NEG
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 2
41282: NEG
41283: PUSH
41284: LD_INT 2
41286: NEG
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: EMPTY
41293: LIST
41294: LIST
41295: LIST
41296: LIST
41297: LIST
41298: LIST
41299: LIST
41300: LIST
41301: LIST
41302: LIST
41303: LIST
41304: LIST
41305: LIST
41306: LIST
41307: LIST
41308: LIST
41309: LIST
41310: LIST
41311: LIST
41312: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41313: LD_ADDR_VAR 0 56
41317: PUSH
41318: LD_INT 0
41320: PUSH
41321: LD_INT 0
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: PUSH
41328: LD_INT 0
41330: PUSH
41331: LD_INT 1
41333: NEG
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 1
41341: PUSH
41342: LD_INT 0
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: LD_INT 1
41351: PUSH
41352: LD_INT 1
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 0
41361: PUSH
41362: LD_INT 1
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 1
41371: NEG
41372: PUSH
41373: LD_INT 0
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: LD_INT 1
41382: NEG
41383: PUSH
41384: LD_INT 1
41386: NEG
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: PUSH
41392: LD_INT 1
41394: NEG
41395: PUSH
41396: LD_INT 2
41398: NEG
41399: PUSH
41400: EMPTY
41401: LIST
41402: LIST
41403: PUSH
41404: LD_INT 0
41406: PUSH
41407: LD_INT 2
41409: NEG
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: PUSH
41415: LD_INT 1
41417: PUSH
41418: LD_INT 1
41420: NEG
41421: PUSH
41422: EMPTY
41423: LIST
41424: LIST
41425: PUSH
41426: LD_INT 2
41428: PUSH
41429: LD_INT 0
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: PUSH
41436: LD_INT 2
41438: PUSH
41439: LD_INT 1
41441: PUSH
41442: EMPTY
41443: LIST
41444: LIST
41445: PUSH
41446: LD_INT 2
41448: PUSH
41449: LD_INT 2
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: LD_INT 1
41458: PUSH
41459: LD_INT 2
41461: PUSH
41462: EMPTY
41463: LIST
41464: LIST
41465: PUSH
41466: LD_INT 0
41468: PUSH
41469: LD_INT 2
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: PUSH
41476: LD_INT 1
41478: NEG
41479: PUSH
41480: LD_INT 1
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 2
41489: NEG
41490: PUSH
41491: LD_INT 0
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: PUSH
41498: LD_INT 2
41500: NEG
41501: PUSH
41502: LD_INT 1
41504: NEG
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: LD_INT 2
41512: NEG
41513: PUSH
41514: LD_INT 2
41516: NEG
41517: PUSH
41518: EMPTY
41519: LIST
41520: LIST
41521: PUSH
41522: EMPTY
41523: LIST
41524: LIST
41525: LIST
41526: LIST
41527: LIST
41528: LIST
41529: LIST
41530: LIST
41531: LIST
41532: LIST
41533: LIST
41534: LIST
41535: LIST
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: LIST
41541: LIST
41542: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41543: LD_ADDR_VAR 0 57
41547: PUSH
41548: LD_INT 0
41550: PUSH
41551: LD_INT 0
41553: PUSH
41554: EMPTY
41555: LIST
41556: LIST
41557: PUSH
41558: LD_INT 0
41560: PUSH
41561: LD_INT 1
41563: NEG
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PUSH
41569: LD_INT 1
41571: PUSH
41572: LD_INT 0
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: PUSH
41579: LD_INT 1
41581: PUSH
41582: LD_INT 1
41584: PUSH
41585: EMPTY
41586: LIST
41587: LIST
41588: PUSH
41589: LD_INT 0
41591: PUSH
41592: LD_INT 1
41594: PUSH
41595: EMPTY
41596: LIST
41597: LIST
41598: PUSH
41599: LD_INT 1
41601: NEG
41602: PUSH
41603: LD_INT 0
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 1
41612: NEG
41613: PUSH
41614: LD_INT 1
41616: NEG
41617: PUSH
41618: EMPTY
41619: LIST
41620: LIST
41621: PUSH
41622: LD_INT 1
41624: NEG
41625: PUSH
41626: LD_INT 2
41628: NEG
41629: PUSH
41630: EMPTY
41631: LIST
41632: LIST
41633: PUSH
41634: LD_INT 0
41636: PUSH
41637: LD_INT 2
41639: NEG
41640: PUSH
41641: EMPTY
41642: LIST
41643: LIST
41644: PUSH
41645: LD_INT 1
41647: PUSH
41648: LD_INT 1
41650: NEG
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 2
41658: PUSH
41659: LD_INT 0
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: LD_INT 2
41668: PUSH
41669: LD_INT 1
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 2
41678: PUSH
41679: LD_INT 2
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 1
41688: PUSH
41689: LD_INT 2
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 0
41698: PUSH
41699: LD_INT 2
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 1
41708: NEG
41709: PUSH
41710: LD_INT 1
41712: PUSH
41713: EMPTY
41714: LIST
41715: LIST
41716: PUSH
41717: LD_INT 2
41719: NEG
41720: PUSH
41721: LD_INT 0
41723: PUSH
41724: EMPTY
41725: LIST
41726: LIST
41727: PUSH
41728: LD_INT 2
41730: NEG
41731: PUSH
41732: LD_INT 1
41734: NEG
41735: PUSH
41736: EMPTY
41737: LIST
41738: LIST
41739: PUSH
41740: LD_INT 2
41742: NEG
41743: PUSH
41744: LD_INT 2
41746: NEG
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: PUSH
41752: EMPTY
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: LIST
41763: LIST
41764: LIST
41765: LIST
41766: LIST
41767: LIST
41768: LIST
41769: LIST
41770: LIST
41771: LIST
41772: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41773: LD_ADDR_VAR 0 58
41777: PUSH
41778: LD_INT 0
41780: PUSH
41781: LD_INT 0
41783: PUSH
41784: EMPTY
41785: LIST
41786: LIST
41787: PUSH
41788: LD_INT 0
41790: PUSH
41791: LD_INT 1
41793: NEG
41794: PUSH
41795: EMPTY
41796: LIST
41797: LIST
41798: PUSH
41799: LD_INT 1
41801: PUSH
41802: LD_INT 0
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: LD_INT 1
41811: PUSH
41812: LD_INT 1
41814: PUSH
41815: EMPTY
41816: LIST
41817: LIST
41818: PUSH
41819: LD_INT 0
41821: PUSH
41822: LD_INT 1
41824: PUSH
41825: EMPTY
41826: LIST
41827: LIST
41828: PUSH
41829: LD_INT 1
41831: NEG
41832: PUSH
41833: LD_INT 0
41835: PUSH
41836: EMPTY
41837: LIST
41838: LIST
41839: PUSH
41840: LD_INT 1
41842: NEG
41843: PUSH
41844: LD_INT 1
41846: NEG
41847: PUSH
41848: EMPTY
41849: LIST
41850: LIST
41851: PUSH
41852: LD_INT 1
41854: NEG
41855: PUSH
41856: LD_INT 2
41858: NEG
41859: PUSH
41860: EMPTY
41861: LIST
41862: LIST
41863: PUSH
41864: LD_INT 0
41866: PUSH
41867: LD_INT 2
41869: NEG
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 1
41877: PUSH
41878: LD_INT 1
41880: NEG
41881: PUSH
41882: EMPTY
41883: LIST
41884: LIST
41885: PUSH
41886: LD_INT 2
41888: PUSH
41889: LD_INT 0
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: PUSH
41896: LD_INT 2
41898: PUSH
41899: LD_INT 1
41901: PUSH
41902: EMPTY
41903: LIST
41904: LIST
41905: PUSH
41906: LD_INT 2
41908: PUSH
41909: LD_INT 2
41911: PUSH
41912: EMPTY
41913: LIST
41914: LIST
41915: PUSH
41916: LD_INT 1
41918: PUSH
41919: LD_INT 2
41921: PUSH
41922: EMPTY
41923: LIST
41924: LIST
41925: PUSH
41926: LD_INT 0
41928: PUSH
41929: LD_INT 2
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PUSH
41936: LD_INT 1
41938: NEG
41939: PUSH
41940: LD_INT 1
41942: PUSH
41943: EMPTY
41944: LIST
41945: LIST
41946: PUSH
41947: LD_INT 2
41949: NEG
41950: PUSH
41951: LD_INT 0
41953: PUSH
41954: EMPTY
41955: LIST
41956: LIST
41957: PUSH
41958: LD_INT 2
41960: NEG
41961: PUSH
41962: LD_INT 1
41964: NEG
41965: PUSH
41966: EMPTY
41967: LIST
41968: LIST
41969: PUSH
41970: LD_INT 2
41972: NEG
41973: PUSH
41974: LD_INT 2
41976: NEG
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: PUSH
41982: EMPTY
41983: LIST
41984: LIST
41985: LIST
41986: LIST
41987: LIST
41988: LIST
41989: LIST
41990: LIST
41991: LIST
41992: LIST
41993: LIST
41994: LIST
41995: LIST
41996: LIST
41997: LIST
41998: LIST
41999: LIST
42000: LIST
42001: LIST
42002: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42003: LD_ADDR_VAR 0 59
42007: PUSH
42008: LD_INT 0
42010: PUSH
42011: LD_INT 0
42013: PUSH
42014: EMPTY
42015: LIST
42016: LIST
42017: PUSH
42018: LD_INT 0
42020: PUSH
42021: LD_INT 1
42023: NEG
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PUSH
42029: LD_INT 1
42031: PUSH
42032: LD_INT 0
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 1
42041: PUSH
42042: LD_INT 1
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 0
42051: PUSH
42052: LD_INT 1
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 1
42061: NEG
42062: PUSH
42063: LD_INT 0
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: LD_INT 1
42072: NEG
42073: PUSH
42074: LD_INT 1
42076: NEG
42077: PUSH
42078: EMPTY
42079: LIST
42080: LIST
42081: PUSH
42082: EMPTY
42083: LIST
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: LIST
42090: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42091: LD_ADDR_VAR 0 60
42095: PUSH
42096: LD_INT 0
42098: PUSH
42099: LD_INT 0
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: PUSH
42106: LD_INT 0
42108: PUSH
42109: LD_INT 1
42111: NEG
42112: PUSH
42113: EMPTY
42114: LIST
42115: LIST
42116: PUSH
42117: LD_INT 1
42119: PUSH
42120: LD_INT 0
42122: PUSH
42123: EMPTY
42124: LIST
42125: LIST
42126: PUSH
42127: LD_INT 1
42129: PUSH
42130: LD_INT 1
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: PUSH
42137: LD_INT 0
42139: PUSH
42140: LD_INT 1
42142: PUSH
42143: EMPTY
42144: LIST
42145: LIST
42146: PUSH
42147: LD_INT 1
42149: NEG
42150: PUSH
42151: LD_INT 0
42153: PUSH
42154: EMPTY
42155: LIST
42156: LIST
42157: PUSH
42158: LD_INT 1
42160: NEG
42161: PUSH
42162: LD_INT 1
42164: NEG
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: PUSH
42170: EMPTY
42171: LIST
42172: LIST
42173: LIST
42174: LIST
42175: LIST
42176: LIST
42177: LIST
42178: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42179: LD_ADDR_VAR 0 61
42183: PUSH
42184: LD_INT 0
42186: PUSH
42187: LD_INT 0
42189: PUSH
42190: EMPTY
42191: LIST
42192: LIST
42193: PUSH
42194: LD_INT 0
42196: PUSH
42197: LD_INT 1
42199: NEG
42200: PUSH
42201: EMPTY
42202: LIST
42203: LIST
42204: PUSH
42205: LD_INT 1
42207: PUSH
42208: LD_INT 0
42210: PUSH
42211: EMPTY
42212: LIST
42213: LIST
42214: PUSH
42215: LD_INT 1
42217: PUSH
42218: LD_INT 1
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 0
42227: PUSH
42228: LD_INT 1
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: PUSH
42235: LD_INT 1
42237: NEG
42238: PUSH
42239: LD_INT 0
42241: PUSH
42242: EMPTY
42243: LIST
42244: LIST
42245: PUSH
42246: LD_INT 1
42248: NEG
42249: PUSH
42250: LD_INT 1
42252: NEG
42253: PUSH
42254: EMPTY
42255: LIST
42256: LIST
42257: PUSH
42258: EMPTY
42259: LIST
42260: LIST
42261: LIST
42262: LIST
42263: LIST
42264: LIST
42265: LIST
42266: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42267: LD_ADDR_VAR 0 62
42271: PUSH
42272: LD_INT 0
42274: PUSH
42275: LD_INT 0
42277: PUSH
42278: EMPTY
42279: LIST
42280: LIST
42281: PUSH
42282: LD_INT 0
42284: PUSH
42285: LD_INT 1
42287: NEG
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: LD_INT 1
42295: PUSH
42296: LD_INT 0
42298: PUSH
42299: EMPTY
42300: LIST
42301: LIST
42302: PUSH
42303: LD_INT 1
42305: PUSH
42306: LD_INT 1
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: PUSH
42313: LD_INT 0
42315: PUSH
42316: LD_INT 1
42318: PUSH
42319: EMPTY
42320: LIST
42321: LIST
42322: PUSH
42323: LD_INT 1
42325: NEG
42326: PUSH
42327: LD_INT 0
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: PUSH
42334: LD_INT 1
42336: NEG
42337: PUSH
42338: LD_INT 1
42340: NEG
42341: PUSH
42342: EMPTY
42343: LIST
42344: LIST
42345: PUSH
42346: EMPTY
42347: LIST
42348: LIST
42349: LIST
42350: LIST
42351: LIST
42352: LIST
42353: LIST
42354: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42355: LD_ADDR_VAR 0 63
42359: PUSH
42360: LD_INT 0
42362: PUSH
42363: LD_INT 0
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 0
42372: PUSH
42373: LD_INT 1
42375: NEG
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 1
42383: PUSH
42384: LD_INT 0
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 1
42393: PUSH
42394: LD_INT 1
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 0
42403: PUSH
42404: LD_INT 1
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: LD_INT 1
42413: NEG
42414: PUSH
42415: LD_INT 0
42417: PUSH
42418: EMPTY
42419: LIST
42420: LIST
42421: PUSH
42422: LD_INT 1
42424: NEG
42425: PUSH
42426: LD_INT 1
42428: NEG
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: EMPTY
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42443: LD_ADDR_VAR 0 64
42447: PUSH
42448: LD_INT 0
42450: PUSH
42451: LD_INT 0
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: LD_INT 0
42460: PUSH
42461: LD_INT 1
42463: NEG
42464: PUSH
42465: EMPTY
42466: LIST
42467: LIST
42468: PUSH
42469: LD_INT 1
42471: PUSH
42472: LD_INT 0
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PUSH
42479: LD_INT 1
42481: PUSH
42482: LD_INT 1
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 0
42491: PUSH
42492: LD_INT 1
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 1
42501: NEG
42502: PUSH
42503: LD_INT 0
42505: PUSH
42506: EMPTY
42507: LIST
42508: LIST
42509: PUSH
42510: LD_INT 1
42512: NEG
42513: PUSH
42514: LD_INT 1
42516: NEG
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: LIST
42526: LIST
42527: LIST
42528: LIST
42529: LIST
42530: ST_TO_ADDR
// end ; 1 :
42531: GO 48428
42533: LD_INT 1
42535: DOUBLE
42536: EQUAL
42537: IFTRUE 42541
42539: GO 45164
42541: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42542: LD_ADDR_VAR 0 11
42546: PUSH
42547: LD_INT 1
42549: NEG
42550: PUSH
42551: LD_INT 3
42553: NEG
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 0
42561: PUSH
42562: LD_INT 3
42564: NEG
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 1
42572: PUSH
42573: LD_INT 2
42575: NEG
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: EMPTY
42582: LIST
42583: LIST
42584: LIST
42585: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42586: LD_ADDR_VAR 0 12
42590: PUSH
42591: LD_INT 2
42593: PUSH
42594: LD_INT 1
42596: NEG
42597: PUSH
42598: EMPTY
42599: LIST
42600: LIST
42601: PUSH
42602: LD_INT 3
42604: PUSH
42605: LD_INT 0
42607: PUSH
42608: EMPTY
42609: LIST
42610: LIST
42611: PUSH
42612: LD_INT 3
42614: PUSH
42615: LD_INT 1
42617: PUSH
42618: EMPTY
42619: LIST
42620: LIST
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: LIST
42626: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42627: LD_ADDR_VAR 0 13
42631: PUSH
42632: LD_INT 3
42634: PUSH
42635: LD_INT 2
42637: PUSH
42638: EMPTY
42639: LIST
42640: LIST
42641: PUSH
42642: LD_INT 3
42644: PUSH
42645: LD_INT 3
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: PUSH
42652: LD_INT 2
42654: PUSH
42655: LD_INT 3
42657: PUSH
42658: EMPTY
42659: LIST
42660: LIST
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: LIST
42666: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42667: LD_ADDR_VAR 0 14
42671: PUSH
42672: LD_INT 1
42674: PUSH
42675: LD_INT 3
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: LD_INT 0
42684: PUSH
42685: LD_INT 3
42687: PUSH
42688: EMPTY
42689: LIST
42690: LIST
42691: PUSH
42692: LD_INT 1
42694: NEG
42695: PUSH
42696: LD_INT 2
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: PUSH
42703: EMPTY
42704: LIST
42705: LIST
42706: LIST
42707: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42708: LD_ADDR_VAR 0 15
42712: PUSH
42713: LD_INT 2
42715: NEG
42716: PUSH
42717: LD_INT 1
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: LD_INT 3
42726: NEG
42727: PUSH
42728: LD_INT 0
42730: PUSH
42731: EMPTY
42732: LIST
42733: LIST
42734: PUSH
42735: LD_INT 3
42737: NEG
42738: PUSH
42739: LD_INT 1
42741: NEG
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: LIST
42751: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42752: LD_ADDR_VAR 0 16
42756: PUSH
42757: LD_INT 2
42759: NEG
42760: PUSH
42761: LD_INT 3
42763: NEG
42764: PUSH
42765: EMPTY
42766: LIST
42767: LIST
42768: PUSH
42769: LD_INT 3
42771: NEG
42772: PUSH
42773: LD_INT 2
42775: NEG
42776: PUSH
42777: EMPTY
42778: LIST
42779: LIST
42780: PUSH
42781: LD_INT 3
42783: NEG
42784: PUSH
42785: LD_INT 3
42787: NEG
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: LIST
42797: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42798: LD_ADDR_VAR 0 17
42802: PUSH
42803: LD_INT 1
42805: NEG
42806: PUSH
42807: LD_INT 3
42809: NEG
42810: PUSH
42811: EMPTY
42812: LIST
42813: LIST
42814: PUSH
42815: LD_INT 0
42817: PUSH
42818: LD_INT 3
42820: NEG
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: LD_INT 1
42828: PUSH
42829: LD_INT 2
42831: NEG
42832: PUSH
42833: EMPTY
42834: LIST
42835: LIST
42836: PUSH
42837: EMPTY
42838: LIST
42839: LIST
42840: LIST
42841: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42842: LD_ADDR_VAR 0 18
42846: PUSH
42847: LD_INT 2
42849: PUSH
42850: LD_INT 1
42852: NEG
42853: PUSH
42854: EMPTY
42855: LIST
42856: LIST
42857: PUSH
42858: LD_INT 3
42860: PUSH
42861: LD_INT 0
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: LD_INT 3
42870: PUSH
42871: LD_INT 1
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: EMPTY
42879: LIST
42880: LIST
42881: LIST
42882: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42883: LD_ADDR_VAR 0 19
42887: PUSH
42888: LD_INT 3
42890: PUSH
42891: LD_INT 2
42893: PUSH
42894: EMPTY
42895: LIST
42896: LIST
42897: PUSH
42898: LD_INT 3
42900: PUSH
42901: LD_INT 3
42903: PUSH
42904: EMPTY
42905: LIST
42906: LIST
42907: PUSH
42908: LD_INT 2
42910: PUSH
42911: LD_INT 3
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: EMPTY
42919: LIST
42920: LIST
42921: LIST
42922: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42923: LD_ADDR_VAR 0 20
42927: PUSH
42928: LD_INT 1
42930: PUSH
42931: LD_INT 3
42933: PUSH
42934: EMPTY
42935: LIST
42936: LIST
42937: PUSH
42938: LD_INT 0
42940: PUSH
42941: LD_INT 3
42943: PUSH
42944: EMPTY
42945: LIST
42946: LIST
42947: PUSH
42948: LD_INT 1
42950: NEG
42951: PUSH
42952: LD_INT 2
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: LIST
42963: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42964: LD_ADDR_VAR 0 21
42968: PUSH
42969: LD_INT 2
42971: NEG
42972: PUSH
42973: LD_INT 1
42975: PUSH
42976: EMPTY
42977: LIST
42978: LIST
42979: PUSH
42980: LD_INT 3
42982: NEG
42983: PUSH
42984: LD_INT 0
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: PUSH
42991: LD_INT 3
42993: NEG
42994: PUSH
42995: LD_INT 1
42997: NEG
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: LIST
43007: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43008: LD_ADDR_VAR 0 22
43012: PUSH
43013: LD_INT 2
43015: NEG
43016: PUSH
43017: LD_INT 3
43019: NEG
43020: PUSH
43021: EMPTY
43022: LIST
43023: LIST
43024: PUSH
43025: LD_INT 3
43027: NEG
43028: PUSH
43029: LD_INT 2
43031: NEG
43032: PUSH
43033: EMPTY
43034: LIST
43035: LIST
43036: PUSH
43037: LD_INT 3
43039: NEG
43040: PUSH
43041: LD_INT 3
43043: NEG
43044: PUSH
43045: EMPTY
43046: LIST
43047: LIST
43048: PUSH
43049: EMPTY
43050: LIST
43051: LIST
43052: LIST
43053: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
43054: LD_ADDR_VAR 0 23
43058: PUSH
43059: LD_INT 0
43061: PUSH
43062: LD_INT 3
43064: NEG
43065: PUSH
43066: EMPTY
43067: LIST
43068: LIST
43069: PUSH
43070: LD_INT 1
43072: NEG
43073: PUSH
43074: LD_INT 4
43076: NEG
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: LD_INT 1
43084: PUSH
43085: LD_INT 3
43087: NEG
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: EMPTY
43094: LIST
43095: LIST
43096: LIST
43097: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
43098: LD_ADDR_VAR 0 24
43102: PUSH
43103: LD_INT 3
43105: PUSH
43106: LD_INT 0
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: PUSH
43113: LD_INT 3
43115: PUSH
43116: LD_INT 1
43118: NEG
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: LD_INT 4
43126: PUSH
43127: LD_INT 1
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: PUSH
43134: EMPTY
43135: LIST
43136: LIST
43137: LIST
43138: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
43139: LD_ADDR_VAR 0 25
43143: PUSH
43144: LD_INT 3
43146: PUSH
43147: LD_INT 3
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_INT 4
43156: PUSH
43157: LD_INT 3
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: PUSH
43164: LD_INT 3
43166: PUSH
43167: LD_INT 4
43169: PUSH
43170: EMPTY
43171: LIST
43172: LIST
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: LIST
43178: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
43179: LD_ADDR_VAR 0 26
43183: PUSH
43184: LD_INT 0
43186: PUSH
43187: LD_INT 3
43189: PUSH
43190: EMPTY
43191: LIST
43192: LIST
43193: PUSH
43194: LD_INT 1
43196: PUSH
43197: LD_INT 4
43199: PUSH
43200: EMPTY
43201: LIST
43202: LIST
43203: PUSH
43204: LD_INT 1
43206: NEG
43207: PUSH
43208: LD_INT 3
43210: PUSH
43211: EMPTY
43212: LIST
43213: LIST
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: LIST
43219: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
43220: LD_ADDR_VAR 0 27
43224: PUSH
43225: LD_INT 3
43227: NEG
43228: PUSH
43229: LD_INT 0
43231: PUSH
43232: EMPTY
43233: LIST
43234: LIST
43235: PUSH
43236: LD_INT 3
43238: NEG
43239: PUSH
43240: LD_INT 1
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PUSH
43247: LD_INT 4
43249: NEG
43250: PUSH
43251: LD_INT 1
43253: NEG
43254: PUSH
43255: EMPTY
43256: LIST
43257: LIST
43258: PUSH
43259: EMPTY
43260: LIST
43261: LIST
43262: LIST
43263: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
43264: LD_ADDR_VAR 0 28
43268: PUSH
43269: LD_INT 3
43271: NEG
43272: PUSH
43273: LD_INT 3
43275: NEG
43276: PUSH
43277: EMPTY
43278: LIST
43279: LIST
43280: PUSH
43281: LD_INT 3
43283: NEG
43284: PUSH
43285: LD_INT 4
43287: NEG
43288: PUSH
43289: EMPTY
43290: LIST
43291: LIST
43292: PUSH
43293: LD_INT 4
43295: NEG
43296: PUSH
43297: LD_INT 3
43299: NEG
43300: PUSH
43301: EMPTY
43302: LIST
43303: LIST
43304: PUSH
43305: EMPTY
43306: LIST
43307: LIST
43308: LIST
43309: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
43310: LD_ADDR_VAR 0 29
43314: PUSH
43315: LD_INT 1
43317: NEG
43318: PUSH
43319: LD_INT 3
43321: NEG
43322: PUSH
43323: EMPTY
43324: LIST
43325: LIST
43326: PUSH
43327: LD_INT 0
43329: PUSH
43330: LD_INT 3
43332: NEG
43333: PUSH
43334: EMPTY
43335: LIST
43336: LIST
43337: PUSH
43338: LD_INT 1
43340: PUSH
43341: LD_INT 2
43343: NEG
43344: PUSH
43345: EMPTY
43346: LIST
43347: LIST
43348: PUSH
43349: LD_INT 1
43351: NEG
43352: PUSH
43353: LD_INT 4
43355: NEG
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: LD_INT 0
43363: PUSH
43364: LD_INT 4
43366: NEG
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: LD_INT 1
43374: PUSH
43375: LD_INT 3
43377: NEG
43378: PUSH
43379: EMPTY
43380: LIST
43381: LIST
43382: PUSH
43383: LD_INT 1
43385: NEG
43386: PUSH
43387: LD_INT 5
43389: NEG
43390: PUSH
43391: EMPTY
43392: LIST
43393: LIST
43394: PUSH
43395: LD_INT 0
43397: PUSH
43398: LD_INT 5
43400: NEG
43401: PUSH
43402: EMPTY
43403: LIST
43404: LIST
43405: PUSH
43406: LD_INT 1
43408: PUSH
43409: LD_INT 4
43411: NEG
43412: PUSH
43413: EMPTY
43414: LIST
43415: LIST
43416: PUSH
43417: LD_INT 1
43419: NEG
43420: PUSH
43421: LD_INT 6
43423: NEG
43424: PUSH
43425: EMPTY
43426: LIST
43427: LIST
43428: PUSH
43429: LD_INT 0
43431: PUSH
43432: LD_INT 6
43434: NEG
43435: PUSH
43436: EMPTY
43437: LIST
43438: LIST
43439: PUSH
43440: LD_INT 1
43442: PUSH
43443: LD_INT 5
43445: NEG
43446: PUSH
43447: EMPTY
43448: LIST
43449: LIST
43450: PUSH
43451: EMPTY
43452: LIST
43453: LIST
43454: LIST
43455: LIST
43456: LIST
43457: LIST
43458: LIST
43459: LIST
43460: LIST
43461: LIST
43462: LIST
43463: LIST
43464: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
43465: LD_ADDR_VAR 0 30
43469: PUSH
43470: LD_INT 2
43472: PUSH
43473: LD_INT 1
43475: NEG
43476: PUSH
43477: EMPTY
43478: LIST
43479: LIST
43480: PUSH
43481: LD_INT 3
43483: PUSH
43484: LD_INT 0
43486: PUSH
43487: EMPTY
43488: LIST
43489: LIST
43490: PUSH
43491: LD_INT 3
43493: PUSH
43494: LD_INT 1
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: PUSH
43501: LD_INT 3
43503: PUSH
43504: LD_INT 1
43506: NEG
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: LD_INT 4
43514: PUSH
43515: LD_INT 0
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 4
43524: PUSH
43525: LD_INT 1
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: LD_INT 4
43534: PUSH
43535: LD_INT 1
43537: NEG
43538: PUSH
43539: EMPTY
43540: LIST
43541: LIST
43542: PUSH
43543: LD_INT 5
43545: PUSH
43546: LD_INT 0
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: LD_INT 5
43555: PUSH
43556: LD_INT 1
43558: PUSH
43559: EMPTY
43560: LIST
43561: LIST
43562: PUSH
43563: LD_INT 5
43565: PUSH
43566: LD_INT 1
43568: NEG
43569: PUSH
43570: EMPTY
43571: LIST
43572: LIST
43573: PUSH
43574: LD_INT 6
43576: PUSH
43577: LD_INT 0
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: LD_INT 6
43586: PUSH
43587: LD_INT 1
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PUSH
43594: EMPTY
43595: LIST
43596: LIST
43597: LIST
43598: LIST
43599: LIST
43600: LIST
43601: LIST
43602: LIST
43603: LIST
43604: LIST
43605: LIST
43606: LIST
43607: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
43608: LD_ADDR_VAR 0 31
43612: PUSH
43613: LD_INT 3
43615: PUSH
43616: LD_INT 2
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: PUSH
43623: LD_INT 3
43625: PUSH
43626: LD_INT 3
43628: PUSH
43629: EMPTY
43630: LIST
43631: LIST
43632: PUSH
43633: LD_INT 2
43635: PUSH
43636: LD_INT 3
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: PUSH
43643: LD_INT 4
43645: PUSH
43646: LD_INT 3
43648: PUSH
43649: EMPTY
43650: LIST
43651: LIST
43652: PUSH
43653: LD_INT 4
43655: PUSH
43656: LD_INT 4
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 3
43665: PUSH
43666: LD_INT 4
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 5
43675: PUSH
43676: LD_INT 4
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: PUSH
43683: LD_INT 5
43685: PUSH
43686: LD_INT 5
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: LD_INT 4
43695: PUSH
43696: LD_INT 5
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: LD_INT 6
43705: PUSH
43706: LD_INT 5
43708: PUSH
43709: EMPTY
43710: LIST
43711: LIST
43712: PUSH
43713: LD_INT 6
43715: PUSH
43716: LD_INT 6
43718: PUSH
43719: EMPTY
43720: LIST
43721: LIST
43722: PUSH
43723: LD_INT 5
43725: PUSH
43726: LD_INT 6
43728: PUSH
43729: EMPTY
43730: LIST
43731: LIST
43732: PUSH
43733: EMPTY
43734: LIST
43735: LIST
43736: LIST
43737: LIST
43738: LIST
43739: LIST
43740: LIST
43741: LIST
43742: LIST
43743: LIST
43744: LIST
43745: LIST
43746: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
43747: LD_ADDR_VAR 0 32
43751: PUSH
43752: LD_INT 1
43754: PUSH
43755: LD_INT 3
43757: PUSH
43758: EMPTY
43759: LIST
43760: LIST
43761: PUSH
43762: LD_INT 0
43764: PUSH
43765: LD_INT 3
43767: PUSH
43768: EMPTY
43769: LIST
43770: LIST
43771: PUSH
43772: LD_INT 1
43774: NEG
43775: PUSH
43776: LD_INT 2
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: PUSH
43783: LD_INT 1
43785: PUSH
43786: LD_INT 4
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 0
43795: PUSH
43796: LD_INT 4
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: LD_INT 1
43805: NEG
43806: PUSH
43807: LD_INT 3
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: PUSH
43814: LD_INT 1
43816: PUSH
43817: LD_INT 5
43819: PUSH
43820: EMPTY
43821: LIST
43822: LIST
43823: PUSH
43824: LD_INT 0
43826: PUSH
43827: LD_INT 5
43829: PUSH
43830: EMPTY
43831: LIST
43832: LIST
43833: PUSH
43834: LD_INT 1
43836: NEG
43837: PUSH
43838: LD_INT 4
43840: PUSH
43841: EMPTY
43842: LIST
43843: LIST
43844: PUSH
43845: LD_INT 1
43847: PUSH
43848: LD_INT 6
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: LD_INT 0
43857: PUSH
43858: LD_INT 6
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 1
43867: NEG
43868: PUSH
43869: LD_INT 5
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: LIST
43880: LIST
43881: LIST
43882: LIST
43883: LIST
43884: LIST
43885: LIST
43886: LIST
43887: LIST
43888: LIST
43889: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
43890: LD_ADDR_VAR 0 33
43894: PUSH
43895: LD_INT 2
43897: NEG
43898: PUSH
43899: LD_INT 1
43901: PUSH
43902: EMPTY
43903: LIST
43904: LIST
43905: PUSH
43906: LD_INT 3
43908: NEG
43909: PUSH
43910: LD_INT 0
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 3
43919: NEG
43920: PUSH
43921: LD_INT 1
43923: NEG
43924: PUSH
43925: EMPTY
43926: LIST
43927: LIST
43928: PUSH
43929: LD_INT 3
43931: NEG
43932: PUSH
43933: LD_INT 1
43935: PUSH
43936: EMPTY
43937: LIST
43938: LIST
43939: PUSH
43940: LD_INT 4
43942: NEG
43943: PUSH
43944: LD_INT 0
43946: PUSH
43947: EMPTY
43948: LIST
43949: LIST
43950: PUSH
43951: LD_INT 4
43953: NEG
43954: PUSH
43955: LD_INT 1
43957: NEG
43958: PUSH
43959: EMPTY
43960: LIST
43961: LIST
43962: PUSH
43963: LD_INT 4
43965: NEG
43966: PUSH
43967: LD_INT 1
43969: PUSH
43970: EMPTY
43971: LIST
43972: LIST
43973: PUSH
43974: LD_INT 5
43976: NEG
43977: PUSH
43978: LD_INT 0
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: PUSH
43985: LD_INT 5
43987: NEG
43988: PUSH
43989: LD_INT 1
43991: NEG
43992: PUSH
43993: EMPTY
43994: LIST
43995: LIST
43996: PUSH
43997: LD_INT 5
43999: NEG
44000: PUSH
44001: LD_INT 1
44003: PUSH
44004: EMPTY
44005: LIST
44006: LIST
44007: PUSH
44008: LD_INT 6
44010: NEG
44011: PUSH
44012: LD_INT 0
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: PUSH
44019: LD_INT 6
44021: NEG
44022: PUSH
44023: LD_INT 1
44025: NEG
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: LIST
44035: LIST
44036: LIST
44037: LIST
44038: LIST
44039: LIST
44040: LIST
44041: LIST
44042: LIST
44043: LIST
44044: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
44045: LD_ADDR_VAR 0 34
44049: PUSH
44050: LD_INT 2
44052: NEG
44053: PUSH
44054: LD_INT 3
44056: NEG
44057: PUSH
44058: EMPTY
44059: LIST
44060: LIST
44061: PUSH
44062: LD_INT 3
44064: NEG
44065: PUSH
44066: LD_INT 2
44068: NEG
44069: PUSH
44070: EMPTY
44071: LIST
44072: LIST
44073: PUSH
44074: LD_INT 3
44076: NEG
44077: PUSH
44078: LD_INT 3
44080: NEG
44081: PUSH
44082: EMPTY
44083: LIST
44084: LIST
44085: PUSH
44086: LD_INT 3
44088: NEG
44089: PUSH
44090: LD_INT 4
44092: NEG
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 4
44100: NEG
44101: PUSH
44102: LD_INT 3
44104: NEG
44105: PUSH
44106: EMPTY
44107: LIST
44108: LIST
44109: PUSH
44110: LD_INT 4
44112: NEG
44113: PUSH
44114: LD_INT 4
44116: NEG
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: PUSH
44122: LD_INT 4
44124: NEG
44125: PUSH
44126: LD_INT 5
44128: NEG
44129: PUSH
44130: EMPTY
44131: LIST
44132: LIST
44133: PUSH
44134: LD_INT 5
44136: NEG
44137: PUSH
44138: LD_INT 4
44140: NEG
44141: PUSH
44142: EMPTY
44143: LIST
44144: LIST
44145: PUSH
44146: LD_INT 5
44148: NEG
44149: PUSH
44150: LD_INT 5
44152: NEG
44153: PUSH
44154: EMPTY
44155: LIST
44156: LIST
44157: PUSH
44158: LD_INT 5
44160: NEG
44161: PUSH
44162: LD_INT 6
44164: NEG
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 6
44172: NEG
44173: PUSH
44174: LD_INT 5
44176: NEG
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: LD_INT 6
44184: NEG
44185: PUSH
44186: LD_INT 6
44188: NEG
44189: PUSH
44190: EMPTY
44191: LIST
44192: LIST
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: LIST
44198: LIST
44199: LIST
44200: LIST
44201: LIST
44202: LIST
44203: LIST
44204: LIST
44205: LIST
44206: LIST
44207: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
44208: LD_ADDR_VAR 0 41
44212: PUSH
44213: LD_INT 0
44215: PUSH
44216: LD_INT 2
44218: NEG
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: LD_INT 1
44226: NEG
44227: PUSH
44228: LD_INT 3
44230: NEG
44231: PUSH
44232: EMPTY
44233: LIST
44234: LIST
44235: PUSH
44236: LD_INT 1
44238: PUSH
44239: LD_INT 2
44241: NEG
44242: PUSH
44243: EMPTY
44244: LIST
44245: LIST
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: LIST
44251: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
44252: LD_ADDR_VAR 0 42
44256: PUSH
44257: LD_INT 2
44259: PUSH
44260: LD_INT 0
44262: PUSH
44263: EMPTY
44264: LIST
44265: LIST
44266: PUSH
44267: LD_INT 2
44269: PUSH
44270: LD_INT 1
44272: NEG
44273: PUSH
44274: EMPTY
44275: LIST
44276: LIST
44277: PUSH
44278: LD_INT 3
44280: PUSH
44281: LD_INT 1
44283: PUSH
44284: EMPTY
44285: LIST
44286: LIST
44287: PUSH
44288: EMPTY
44289: LIST
44290: LIST
44291: LIST
44292: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
44293: LD_ADDR_VAR 0 43
44297: PUSH
44298: LD_INT 2
44300: PUSH
44301: LD_INT 2
44303: PUSH
44304: EMPTY
44305: LIST
44306: LIST
44307: PUSH
44308: LD_INT 3
44310: PUSH
44311: LD_INT 2
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: PUSH
44318: LD_INT 2
44320: PUSH
44321: LD_INT 3
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: EMPTY
44329: LIST
44330: LIST
44331: LIST
44332: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
44333: LD_ADDR_VAR 0 44
44337: PUSH
44338: LD_INT 0
44340: PUSH
44341: LD_INT 2
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: PUSH
44348: LD_INT 1
44350: PUSH
44351: LD_INT 3
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 1
44360: NEG
44361: PUSH
44362: LD_INT 2
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: LIST
44373: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
44374: LD_ADDR_VAR 0 45
44378: PUSH
44379: LD_INT 2
44381: NEG
44382: PUSH
44383: LD_INT 0
44385: PUSH
44386: EMPTY
44387: LIST
44388: LIST
44389: PUSH
44390: LD_INT 2
44392: NEG
44393: PUSH
44394: LD_INT 1
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 3
44403: NEG
44404: PUSH
44405: LD_INT 1
44407: NEG
44408: PUSH
44409: EMPTY
44410: LIST
44411: LIST
44412: PUSH
44413: EMPTY
44414: LIST
44415: LIST
44416: LIST
44417: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
44418: LD_ADDR_VAR 0 46
44422: PUSH
44423: LD_INT 2
44425: NEG
44426: PUSH
44427: LD_INT 2
44429: NEG
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: PUSH
44435: LD_INT 2
44437: NEG
44438: PUSH
44439: LD_INT 3
44441: NEG
44442: PUSH
44443: EMPTY
44444: LIST
44445: LIST
44446: PUSH
44447: LD_INT 3
44449: NEG
44450: PUSH
44451: LD_INT 2
44453: NEG
44454: PUSH
44455: EMPTY
44456: LIST
44457: LIST
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: LIST
44463: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
44464: LD_ADDR_VAR 0 47
44468: PUSH
44469: LD_INT 2
44471: NEG
44472: PUSH
44473: LD_INT 3
44475: NEG
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 1
44483: NEG
44484: PUSH
44485: LD_INT 3
44487: NEG
44488: PUSH
44489: EMPTY
44490: LIST
44491: LIST
44492: PUSH
44493: EMPTY
44494: LIST
44495: LIST
44496: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
44497: LD_ADDR_VAR 0 48
44501: PUSH
44502: LD_INT 1
44504: PUSH
44505: LD_INT 2
44507: NEG
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: LD_INT 2
44515: PUSH
44516: LD_INT 1
44518: NEG
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
44528: LD_ADDR_VAR 0 49
44532: PUSH
44533: LD_INT 3
44535: PUSH
44536: LD_INT 1
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: PUSH
44543: LD_INT 3
44545: PUSH
44546: LD_INT 2
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: PUSH
44553: EMPTY
44554: LIST
44555: LIST
44556: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
44557: LD_ADDR_VAR 0 50
44561: PUSH
44562: LD_INT 2
44564: PUSH
44565: LD_INT 3
44567: PUSH
44568: EMPTY
44569: LIST
44570: LIST
44571: PUSH
44572: LD_INT 1
44574: PUSH
44575: LD_INT 3
44577: PUSH
44578: EMPTY
44579: LIST
44580: LIST
44581: PUSH
44582: EMPTY
44583: LIST
44584: LIST
44585: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
44586: LD_ADDR_VAR 0 51
44590: PUSH
44591: LD_INT 1
44593: NEG
44594: PUSH
44595: LD_INT 2
44597: PUSH
44598: EMPTY
44599: LIST
44600: LIST
44601: PUSH
44602: LD_INT 2
44604: NEG
44605: PUSH
44606: LD_INT 1
44608: PUSH
44609: EMPTY
44610: LIST
44611: LIST
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
44617: LD_ADDR_VAR 0 52
44621: PUSH
44622: LD_INT 3
44624: NEG
44625: PUSH
44626: LD_INT 1
44628: NEG
44629: PUSH
44630: EMPTY
44631: LIST
44632: LIST
44633: PUSH
44634: LD_INT 3
44636: NEG
44637: PUSH
44638: LD_INT 2
44640: NEG
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44650: LD_ADDR_VAR 0 53
44654: PUSH
44655: LD_INT 1
44657: NEG
44658: PUSH
44659: LD_INT 3
44661: NEG
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: PUSH
44667: LD_INT 0
44669: PUSH
44670: LD_INT 3
44672: NEG
44673: PUSH
44674: EMPTY
44675: LIST
44676: LIST
44677: PUSH
44678: LD_INT 1
44680: PUSH
44681: LD_INT 2
44683: NEG
44684: PUSH
44685: EMPTY
44686: LIST
44687: LIST
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: LIST
44693: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
44694: LD_ADDR_VAR 0 54
44698: PUSH
44699: LD_INT 2
44701: PUSH
44702: LD_INT 1
44704: NEG
44705: PUSH
44706: EMPTY
44707: LIST
44708: LIST
44709: PUSH
44710: LD_INT 3
44712: PUSH
44713: LD_INT 0
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: PUSH
44720: LD_INT 3
44722: PUSH
44723: LD_INT 1
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: PUSH
44730: EMPTY
44731: LIST
44732: LIST
44733: LIST
44734: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
44735: LD_ADDR_VAR 0 55
44739: PUSH
44740: LD_INT 3
44742: PUSH
44743: LD_INT 2
44745: PUSH
44746: EMPTY
44747: LIST
44748: LIST
44749: PUSH
44750: LD_INT 3
44752: PUSH
44753: LD_INT 3
44755: PUSH
44756: EMPTY
44757: LIST
44758: LIST
44759: PUSH
44760: LD_INT 2
44762: PUSH
44763: LD_INT 3
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: PUSH
44770: EMPTY
44771: LIST
44772: LIST
44773: LIST
44774: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
44775: LD_ADDR_VAR 0 56
44779: PUSH
44780: LD_INT 1
44782: PUSH
44783: LD_INT 3
44785: PUSH
44786: EMPTY
44787: LIST
44788: LIST
44789: PUSH
44790: LD_INT 0
44792: PUSH
44793: LD_INT 3
44795: PUSH
44796: EMPTY
44797: LIST
44798: LIST
44799: PUSH
44800: LD_INT 1
44802: NEG
44803: PUSH
44804: LD_INT 2
44806: PUSH
44807: EMPTY
44808: LIST
44809: LIST
44810: PUSH
44811: EMPTY
44812: LIST
44813: LIST
44814: LIST
44815: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
44816: LD_ADDR_VAR 0 57
44820: PUSH
44821: LD_INT 2
44823: NEG
44824: PUSH
44825: LD_INT 1
44827: PUSH
44828: EMPTY
44829: LIST
44830: LIST
44831: PUSH
44832: LD_INT 3
44834: NEG
44835: PUSH
44836: LD_INT 0
44838: PUSH
44839: EMPTY
44840: LIST
44841: LIST
44842: PUSH
44843: LD_INT 3
44845: NEG
44846: PUSH
44847: LD_INT 1
44849: NEG
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: PUSH
44855: EMPTY
44856: LIST
44857: LIST
44858: LIST
44859: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44860: LD_ADDR_VAR 0 58
44864: PUSH
44865: LD_INT 2
44867: NEG
44868: PUSH
44869: LD_INT 3
44871: NEG
44872: PUSH
44873: EMPTY
44874: LIST
44875: LIST
44876: PUSH
44877: LD_INT 3
44879: NEG
44880: PUSH
44881: LD_INT 2
44883: NEG
44884: PUSH
44885: EMPTY
44886: LIST
44887: LIST
44888: PUSH
44889: LD_INT 3
44891: NEG
44892: PUSH
44893: LD_INT 3
44895: NEG
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: LIST
44905: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
44906: LD_ADDR_VAR 0 59
44910: PUSH
44911: LD_INT 1
44913: NEG
44914: PUSH
44915: LD_INT 2
44917: NEG
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: PUSH
44923: LD_INT 0
44925: PUSH
44926: LD_INT 2
44928: NEG
44929: PUSH
44930: EMPTY
44931: LIST
44932: LIST
44933: PUSH
44934: LD_INT 1
44936: PUSH
44937: LD_INT 1
44939: NEG
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: PUSH
44945: EMPTY
44946: LIST
44947: LIST
44948: LIST
44949: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
44950: LD_ADDR_VAR 0 60
44954: PUSH
44955: LD_INT 1
44957: PUSH
44958: LD_INT 1
44960: NEG
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: PUSH
44966: LD_INT 2
44968: PUSH
44969: LD_INT 0
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: PUSH
44976: LD_INT 2
44978: PUSH
44979: LD_INT 1
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: LIST
44990: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
44991: LD_ADDR_VAR 0 61
44995: PUSH
44996: LD_INT 2
44998: PUSH
44999: LD_INT 1
45001: PUSH
45002: EMPTY
45003: LIST
45004: LIST
45005: PUSH
45006: LD_INT 2
45008: PUSH
45009: LD_INT 2
45011: PUSH
45012: EMPTY
45013: LIST
45014: LIST
45015: PUSH
45016: LD_INT 1
45018: PUSH
45019: LD_INT 2
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: EMPTY
45027: LIST
45028: LIST
45029: LIST
45030: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
45031: LD_ADDR_VAR 0 62
45035: PUSH
45036: LD_INT 1
45038: PUSH
45039: LD_INT 2
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PUSH
45046: LD_INT 0
45048: PUSH
45049: LD_INT 2
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: LD_INT 1
45058: NEG
45059: PUSH
45060: LD_INT 1
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: PUSH
45067: EMPTY
45068: LIST
45069: LIST
45070: LIST
45071: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
45072: LD_ADDR_VAR 0 63
45076: PUSH
45077: LD_INT 1
45079: NEG
45080: PUSH
45081: LD_INT 1
45083: PUSH
45084: EMPTY
45085: LIST
45086: LIST
45087: PUSH
45088: LD_INT 2
45090: NEG
45091: PUSH
45092: LD_INT 0
45094: PUSH
45095: EMPTY
45096: LIST
45097: LIST
45098: PUSH
45099: LD_INT 2
45101: NEG
45102: PUSH
45103: LD_INT 1
45105: NEG
45106: PUSH
45107: EMPTY
45108: LIST
45109: LIST
45110: PUSH
45111: EMPTY
45112: LIST
45113: LIST
45114: LIST
45115: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45116: LD_ADDR_VAR 0 64
45120: PUSH
45121: LD_INT 1
45123: NEG
45124: PUSH
45125: LD_INT 2
45127: NEG
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: PUSH
45133: LD_INT 2
45135: NEG
45136: PUSH
45137: LD_INT 1
45139: NEG
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 2
45147: NEG
45148: PUSH
45149: LD_INT 2
45151: NEG
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: PUSH
45157: EMPTY
45158: LIST
45159: LIST
45160: LIST
45161: ST_TO_ADDR
// end ; 2 :
45162: GO 48428
45164: LD_INT 2
45166: DOUBLE
45167: EQUAL
45168: IFTRUE 45172
45170: GO 48427
45172: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
45173: LD_ADDR_VAR 0 29
45177: PUSH
45178: LD_INT 4
45180: PUSH
45181: LD_INT 0
45183: PUSH
45184: EMPTY
45185: LIST
45186: LIST
45187: PUSH
45188: LD_INT 4
45190: PUSH
45191: LD_INT 1
45193: NEG
45194: PUSH
45195: EMPTY
45196: LIST
45197: LIST
45198: PUSH
45199: LD_INT 5
45201: PUSH
45202: LD_INT 0
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: LD_INT 5
45211: PUSH
45212: LD_INT 1
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: PUSH
45219: LD_INT 4
45221: PUSH
45222: LD_INT 1
45224: PUSH
45225: EMPTY
45226: LIST
45227: LIST
45228: PUSH
45229: LD_INT 3
45231: PUSH
45232: LD_INT 0
45234: PUSH
45235: EMPTY
45236: LIST
45237: LIST
45238: PUSH
45239: LD_INT 3
45241: PUSH
45242: LD_INT 1
45244: NEG
45245: PUSH
45246: EMPTY
45247: LIST
45248: LIST
45249: PUSH
45250: LD_INT 3
45252: PUSH
45253: LD_INT 2
45255: NEG
45256: PUSH
45257: EMPTY
45258: LIST
45259: LIST
45260: PUSH
45261: LD_INT 5
45263: PUSH
45264: LD_INT 2
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: PUSH
45271: LD_INT 3
45273: PUSH
45274: LD_INT 3
45276: PUSH
45277: EMPTY
45278: LIST
45279: LIST
45280: PUSH
45281: LD_INT 3
45283: PUSH
45284: LD_INT 2
45286: PUSH
45287: EMPTY
45288: LIST
45289: LIST
45290: PUSH
45291: LD_INT 4
45293: PUSH
45294: LD_INT 3
45296: PUSH
45297: EMPTY
45298: LIST
45299: LIST
45300: PUSH
45301: LD_INT 4
45303: PUSH
45304: LD_INT 4
45306: PUSH
45307: EMPTY
45308: LIST
45309: LIST
45310: PUSH
45311: LD_INT 3
45313: PUSH
45314: LD_INT 4
45316: PUSH
45317: EMPTY
45318: LIST
45319: LIST
45320: PUSH
45321: LD_INT 2
45323: PUSH
45324: LD_INT 3
45326: PUSH
45327: EMPTY
45328: LIST
45329: LIST
45330: PUSH
45331: LD_INT 2
45333: PUSH
45334: LD_INT 2
45336: PUSH
45337: EMPTY
45338: LIST
45339: LIST
45340: PUSH
45341: LD_INT 4
45343: PUSH
45344: LD_INT 2
45346: PUSH
45347: EMPTY
45348: LIST
45349: LIST
45350: PUSH
45351: LD_INT 2
45353: PUSH
45354: LD_INT 4
45356: PUSH
45357: EMPTY
45358: LIST
45359: LIST
45360: PUSH
45361: LD_INT 0
45363: PUSH
45364: LD_INT 4
45366: PUSH
45367: EMPTY
45368: LIST
45369: LIST
45370: PUSH
45371: LD_INT 0
45373: PUSH
45374: LD_INT 3
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: PUSH
45381: LD_INT 1
45383: PUSH
45384: LD_INT 4
45386: PUSH
45387: EMPTY
45388: LIST
45389: LIST
45390: PUSH
45391: LD_INT 1
45393: PUSH
45394: LD_INT 5
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: LD_INT 0
45403: PUSH
45404: LD_INT 5
45406: PUSH
45407: EMPTY
45408: LIST
45409: LIST
45410: PUSH
45411: LD_INT 1
45413: NEG
45414: PUSH
45415: LD_INT 4
45417: PUSH
45418: EMPTY
45419: LIST
45420: LIST
45421: PUSH
45422: LD_INT 1
45424: NEG
45425: PUSH
45426: LD_INT 3
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: PUSH
45433: LD_INT 2
45435: PUSH
45436: LD_INT 5
45438: PUSH
45439: EMPTY
45440: LIST
45441: LIST
45442: PUSH
45443: LD_INT 2
45445: NEG
45446: PUSH
45447: LD_INT 3
45449: PUSH
45450: EMPTY
45451: LIST
45452: LIST
45453: PUSH
45454: LD_INT 3
45456: NEG
45457: PUSH
45458: LD_INT 0
45460: PUSH
45461: EMPTY
45462: LIST
45463: LIST
45464: PUSH
45465: LD_INT 3
45467: NEG
45468: PUSH
45469: LD_INT 1
45471: NEG
45472: PUSH
45473: EMPTY
45474: LIST
45475: LIST
45476: PUSH
45477: LD_INT 2
45479: NEG
45480: PUSH
45481: LD_INT 0
45483: PUSH
45484: EMPTY
45485: LIST
45486: LIST
45487: PUSH
45488: LD_INT 2
45490: NEG
45491: PUSH
45492: LD_INT 1
45494: PUSH
45495: EMPTY
45496: LIST
45497: LIST
45498: PUSH
45499: LD_INT 3
45501: NEG
45502: PUSH
45503: LD_INT 1
45505: PUSH
45506: EMPTY
45507: LIST
45508: LIST
45509: PUSH
45510: LD_INT 4
45512: NEG
45513: PUSH
45514: LD_INT 0
45516: PUSH
45517: EMPTY
45518: LIST
45519: LIST
45520: PUSH
45521: LD_INT 4
45523: NEG
45524: PUSH
45525: LD_INT 1
45527: NEG
45528: PUSH
45529: EMPTY
45530: LIST
45531: LIST
45532: PUSH
45533: LD_INT 4
45535: NEG
45536: PUSH
45537: LD_INT 2
45539: NEG
45540: PUSH
45541: EMPTY
45542: LIST
45543: LIST
45544: PUSH
45545: LD_INT 2
45547: NEG
45548: PUSH
45549: LD_INT 2
45551: PUSH
45552: EMPTY
45553: LIST
45554: LIST
45555: PUSH
45556: LD_INT 4
45558: NEG
45559: PUSH
45560: LD_INT 4
45562: NEG
45563: PUSH
45564: EMPTY
45565: LIST
45566: LIST
45567: PUSH
45568: LD_INT 4
45570: NEG
45571: PUSH
45572: LD_INT 5
45574: NEG
45575: PUSH
45576: EMPTY
45577: LIST
45578: LIST
45579: PUSH
45580: LD_INT 3
45582: NEG
45583: PUSH
45584: LD_INT 4
45586: NEG
45587: PUSH
45588: EMPTY
45589: LIST
45590: LIST
45591: PUSH
45592: LD_INT 3
45594: NEG
45595: PUSH
45596: LD_INT 3
45598: NEG
45599: PUSH
45600: EMPTY
45601: LIST
45602: LIST
45603: PUSH
45604: LD_INT 4
45606: NEG
45607: PUSH
45608: LD_INT 3
45610: NEG
45611: PUSH
45612: EMPTY
45613: LIST
45614: LIST
45615: PUSH
45616: LD_INT 5
45618: NEG
45619: PUSH
45620: LD_INT 4
45622: NEG
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: PUSH
45628: LD_INT 5
45630: NEG
45631: PUSH
45632: LD_INT 5
45634: NEG
45635: PUSH
45636: EMPTY
45637: LIST
45638: LIST
45639: PUSH
45640: LD_INT 3
45642: NEG
45643: PUSH
45644: LD_INT 5
45646: NEG
45647: PUSH
45648: EMPTY
45649: LIST
45650: LIST
45651: PUSH
45652: LD_INT 5
45654: NEG
45655: PUSH
45656: LD_INT 3
45658: NEG
45659: PUSH
45660: EMPTY
45661: LIST
45662: LIST
45663: PUSH
45664: EMPTY
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: LIST
45670: LIST
45671: LIST
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: LIST
45677: LIST
45678: LIST
45679: LIST
45680: LIST
45681: LIST
45682: LIST
45683: LIST
45684: LIST
45685: LIST
45686: LIST
45687: LIST
45688: LIST
45689: LIST
45690: LIST
45691: LIST
45692: LIST
45693: LIST
45694: LIST
45695: LIST
45696: LIST
45697: LIST
45698: LIST
45699: LIST
45700: LIST
45701: LIST
45702: LIST
45703: LIST
45704: LIST
45705: LIST
45706: LIST
45707: LIST
45708: LIST
45709: LIST
45710: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
45711: LD_ADDR_VAR 0 30
45715: PUSH
45716: LD_INT 4
45718: PUSH
45719: LD_INT 4
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 4
45728: PUSH
45729: LD_INT 3
45731: PUSH
45732: EMPTY
45733: LIST
45734: LIST
45735: PUSH
45736: LD_INT 5
45738: PUSH
45739: LD_INT 4
45741: PUSH
45742: EMPTY
45743: LIST
45744: LIST
45745: PUSH
45746: LD_INT 5
45748: PUSH
45749: LD_INT 5
45751: PUSH
45752: EMPTY
45753: LIST
45754: LIST
45755: PUSH
45756: LD_INT 4
45758: PUSH
45759: LD_INT 5
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: PUSH
45766: LD_INT 3
45768: PUSH
45769: LD_INT 4
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: PUSH
45776: LD_INT 3
45778: PUSH
45779: LD_INT 3
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: LD_INT 5
45788: PUSH
45789: LD_INT 3
45791: PUSH
45792: EMPTY
45793: LIST
45794: LIST
45795: PUSH
45796: LD_INT 3
45798: PUSH
45799: LD_INT 5
45801: PUSH
45802: EMPTY
45803: LIST
45804: LIST
45805: PUSH
45806: LD_INT 0
45808: PUSH
45809: LD_INT 3
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: LD_INT 0
45818: PUSH
45819: LD_INT 2
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: PUSH
45826: LD_INT 1
45828: PUSH
45829: LD_INT 3
45831: PUSH
45832: EMPTY
45833: LIST
45834: LIST
45835: PUSH
45836: LD_INT 1
45838: PUSH
45839: LD_INT 4
45841: PUSH
45842: EMPTY
45843: LIST
45844: LIST
45845: PUSH
45846: LD_INT 0
45848: PUSH
45849: LD_INT 4
45851: PUSH
45852: EMPTY
45853: LIST
45854: LIST
45855: PUSH
45856: LD_INT 1
45858: NEG
45859: PUSH
45860: LD_INT 3
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: PUSH
45867: LD_INT 1
45869: NEG
45870: PUSH
45871: LD_INT 2
45873: PUSH
45874: EMPTY
45875: LIST
45876: LIST
45877: PUSH
45878: LD_INT 2
45880: PUSH
45881: LD_INT 4
45883: PUSH
45884: EMPTY
45885: LIST
45886: LIST
45887: PUSH
45888: LD_INT 2
45890: NEG
45891: PUSH
45892: LD_INT 2
45894: PUSH
45895: EMPTY
45896: LIST
45897: LIST
45898: PUSH
45899: LD_INT 4
45901: NEG
45902: PUSH
45903: LD_INT 0
45905: PUSH
45906: EMPTY
45907: LIST
45908: LIST
45909: PUSH
45910: LD_INT 4
45912: NEG
45913: PUSH
45914: LD_INT 1
45916: NEG
45917: PUSH
45918: EMPTY
45919: LIST
45920: LIST
45921: PUSH
45922: LD_INT 3
45924: NEG
45925: PUSH
45926: LD_INT 0
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: PUSH
45933: LD_INT 3
45935: NEG
45936: PUSH
45937: LD_INT 1
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PUSH
45944: LD_INT 4
45946: NEG
45947: PUSH
45948: LD_INT 1
45950: PUSH
45951: EMPTY
45952: LIST
45953: LIST
45954: PUSH
45955: LD_INT 5
45957: NEG
45958: PUSH
45959: LD_INT 0
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: PUSH
45966: LD_INT 5
45968: NEG
45969: PUSH
45970: LD_INT 1
45972: NEG
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: PUSH
45978: LD_INT 5
45980: NEG
45981: PUSH
45982: LD_INT 2
45984: NEG
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: PUSH
45990: LD_INT 3
45992: NEG
45993: PUSH
45994: LD_INT 2
45996: PUSH
45997: EMPTY
45998: LIST
45999: LIST
46000: PUSH
46001: LD_INT 3
46003: NEG
46004: PUSH
46005: LD_INT 3
46007: NEG
46008: PUSH
46009: EMPTY
46010: LIST
46011: LIST
46012: PUSH
46013: LD_INT 3
46015: NEG
46016: PUSH
46017: LD_INT 4
46019: NEG
46020: PUSH
46021: EMPTY
46022: LIST
46023: LIST
46024: PUSH
46025: LD_INT 2
46027: NEG
46028: PUSH
46029: LD_INT 3
46031: NEG
46032: PUSH
46033: EMPTY
46034: LIST
46035: LIST
46036: PUSH
46037: LD_INT 2
46039: NEG
46040: PUSH
46041: LD_INT 2
46043: NEG
46044: PUSH
46045: EMPTY
46046: LIST
46047: LIST
46048: PUSH
46049: LD_INT 3
46051: NEG
46052: PUSH
46053: LD_INT 2
46055: NEG
46056: PUSH
46057: EMPTY
46058: LIST
46059: LIST
46060: PUSH
46061: LD_INT 4
46063: NEG
46064: PUSH
46065: LD_INT 3
46067: NEG
46068: PUSH
46069: EMPTY
46070: LIST
46071: LIST
46072: PUSH
46073: LD_INT 4
46075: NEG
46076: PUSH
46077: LD_INT 4
46079: NEG
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PUSH
46085: LD_INT 2
46087: NEG
46088: PUSH
46089: LD_INT 4
46091: NEG
46092: PUSH
46093: EMPTY
46094: LIST
46095: LIST
46096: PUSH
46097: LD_INT 4
46099: NEG
46100: PUSH
46101: LD_INT 2
46103: NEG
46104: PUSH
46105: EMPTY
46106: LIST
46107: LIST
46108: PUSH
46109: LD_INT 0
46111: PUSH
46112: LD_INT 4
46114: NEG
46115: PUSH
46116: EMPTY
46117: LIST
46118: LIST
46119: PUSH
46120: LD_INT 0
46122: PUSH
46123: LD_INT 5
46125: NEG
46126: PUSH
46127: EMPTY
46128: LIST
46129: LIST
46130: PUSH
46131: LD_INT 1
46133: PUSH
46134: LD_INT 4
46136: NEG
46137: PUSH
46138: EMPTY
46139: LIST
46140: LIST
46141: PUSH
46142: LD_INT 1
46144: PUSH
46145: LD_INT 3
46147: NEG
46148: PUSH
46149: EMPTY
46150: LIST
46151: LIST
46152: PUSH
46153: LD_INT 0
46155: PUSH
46156: LD_INT 3
46158: NEG
46159: PUSH
46160: EMPTY
46161: LIST
46162: LIST
46163: PUSH
46164: LD_INT 1
46166: NEG
46167: PUSH
46168: LD_INT 4
46170: NEG
46171: PUSH
46172: EMPTY
46173: LIST
46174: LIST
46175: PUSH
46176: LD_INT 1
46178: NEG
46179: PUSH
46180: LD_INT 5
46182: NEG
46183: PUSH
46184: EMPTY
46185: LIST
46186: LIST
46187: PUSH
46188: LD_INT 2
46190: PUSH
46191: LD_INT 3
46193: NEG
46194: PUSH
46195: EMPTY
46196: LIST
46197: LIST
46198: PUSH
46199: LD_INT 2
46201: NEG
46202: PUSH
46203: LD_INT 5
46205: NEG
46206: PUSH
46207: EMPTY
46208: LIST
46209: LIST
46210: PUSH
46211: EMPTY
46212: LIST
46213: LIST
46214: LIST
46215: LIST
46216: LIST
46217: LIST
46218: LIST
46219: LIST
46220: LIST
46221: LIST
46222: LIST
46223: LIST
46224: LIST
46225: LIST
46226: LIST
46227: LIST
46228: LIST
46229: LIST
46230: LIST
46231: LIST
46232: LIST
46233: LIST
46234: LIST
46235: LIST
46236: LIST
46237: LIST
46238: LIST
46239: LIST
46240: LIST
46241: LIST
46242: LIST
46243: LIST
46244: LIST
46245: LIST
46246: LIST
46247: LIST
46248: LIST
46249: LIST
46250: LIST
46251: LIST
46252: LIST
46253: LIST
46254: LIST
46255: LIST
46256: LIST
46257: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
46258: LD_ADDR_VAR 0 31
46262: PUSH
46263: LD_INT 0
46265: PUSH
46266: LD_INT 4
46268: PUSH
46269: EMPTY
46270: LIST
46271: LIST
46272: PUSH
46273: LD_INT 0
46275: PUSH
46276: LD_INT 3
46278: PUSH
46279: EMPTY
46280: LIST
46281: LIST
46282: PUSH
46283: LD_INT 1
46285: PUSH
46286: LD_INT 4
46288: PUSH
46289: EMPTY
46290: LIST
46291: LIST
46292: PUSH
46293: LD_INT 1
46295: PUSH
46296: LD_INT 5
46298: PUSH
46299: EMPTY
46300: LIST
46301: LIST
46302: PUSH
46303: LD_INT 0
46305: PUSH
46306: LD_INT 5
46308: PUSH
46309: EMPTY
46310: LIST
46311: LIST
46312: PUSH
46313: LD_INT 1
46315: NEG
46316: PUSH
46317: LD_INT 4
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: PUSH
46324: LD_INT 1
46326: NEG
46327: PUSH
46328: LD_INT 3
46330: PUSH
46331: EMPTY
46332: LIST
46333: LIST
46334: PUSH
46335: LD_INT 2
46337: PUSH
46338: LD_INT 5
46340: PUSH
46341: EMPTY
46342: LIST
46343: LIST
46344: PUSH
46345: LD_INT 2
46347: NEG
46348: PUSH
46349: LD_INT 3
46351: PUSH
46352: EMPTY
46353: LIST
46354: LIST
46355: PUSH
46356: LD_INT 3
46358: NEG
46359: PUSH
46360: LD_INT 0
46362: PUSH
46363: EMPTY
46364: LIST
46365: LIST
46366: PUSH
46367: LD_INT 3
46369: NEG
46370: PUSH
46371: LD_INT 1
46373: NEG
46374: PUSH
46375: EMPTY
46376: LIST
46377: LIST
46378: PUSH
46379: LD_INT 2
46381: NEG
46382: PUSH
46383: LD_INT 0
46385: PUSH
46386: EMPTY
46387: LIST
46388: LIST
46389: PUSH
46390: LD_INT 2
46392: NEG
46393: PUSH
46394: LD_INT 1
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: LD_INT 3
46403: NEG
46404: PUSH
46405: LD_INT 1
46407: PUSH
46408: EMPTY
46409: LIST
46410: LIST
46411: PUSH
46412: LD_INT 4
46414: NEG
46415: PUSH
46416: LD_INT 0
46418: PUSH
46419: EMPTY
46420: LIST
46421: LIST
46422: PUSH
46423: LD_INT 4
46425: NEG
46426: PUSH
46427: LD_INT 1
46429: NEG
46430: PUSH
46431: EMPTY
46432: LIST
46433: LIST
46434: PUSH
46435: LD_INT 4
46437: NEG
46438: PUSH
46439: LD_INT 2
46441: NEG
46442: PUSH
46443: EMPTY
46444: LIST
46445: LIST
46446: PUSH
46447: LD_INT 2
46449: NEG
46450: PUSH
46451: LD_INT 2
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: PUSH
46458: LD_INT 4
46460: NEG
46461: PUSH
46462: LD_INT 4
46464: NEG
46465: PUSH
46466: EMPTY
46467: LIST
46468: LIST
46469: PUSH
46470: LD_INT 4
46472: NEG
46473: PUSH
46474: LD_INT 5
46476: NEG
46477: PUSH
46478: EMPTY
46479: LIST
46480: LIST
46481: PUSH
46482: LD_INT 3
46484: NEG
46485: PUSH
46486: LD_INT 4
46488: NEG
46489: PUSH
46490: EMPTY
46491: LIST
46492: LIST
46493: PUSH
46494: LD_INT 3
46496: NEG
46497: PUSH
46498: LD_INT 3
46500: NEG
46501: PUSH
46502: EMPTY
46503: LIST
46504: LIST
46505: PUSH
46506: LD_INT 4
46508: NEG
46509: PUSH
46510: LD_INT 3
46512: NEG
46513: PUSH
46514: EMPTY
46515: LIST
46516: LIST
46517: PUSH
46518: LD_INT 5
46520: NEG
46521: PUSH
46522: LD_INT 4
46524: NEG
46525: PUSH
46526: EMPTY
46527: LIST
46528: LIST
46529: PUSH
46530: LD_INT 5
46532: NEG
46533: PUSH
46534: LD_INT 5
46536: NEG
46537: PUSH
46538: EMPTY
46539: LIST
46540: LIST
46541: PUSH
46542: LD_INT 3
46544: NEG
46545: PUSH
46546: LD_INT 5
46548: NEG
46549: PUSH
46550: EMPTY
46551: LIST
46552: LIST
46553: PUSH
46554: LD_INT 5
46556: NEG
46557: PUSH
46558: LD_INT 3
46560: NEG
46561: PUSH
46562: EMPTY
46563: LIST
46564: LIST
46565: PUSH
46566: LD_INT 0
46568: PUSH
46569: LD_INT 3
46571: NEG
46572: PUSH
46573: EMPTY
46574: LIST
46575: LIST
46576: PUSH
46577: LD_INT 0
46579: PUSH
46580: LD_INT 4
46582: NEG
46583: PUSH
46584: EMPTY
46585: LIST
46586: LIST
46587: PUSH
46588: LD_INT 1
46590: PUSH
46591: LD_INT 3
46593: NEG
46594: PUSH
46595: EMPTY
46596: LIST
46597: LIST
46598: PUSH
46599: LD_INT 1
46601: PUSH
46602: LD_INT 2
46604: NEG
46605: PUSH
46606: EMPTY
46607: LIST
46608: LIST
46609: PUSH
46610: LD_INT 0
46612: PUSH
46613: LD_INT 2
46615: NEG
46616: PUSH
46617: EMPTY
46618: LIST
46619: LIST
46620: PUSH
46621: LD_INT 1
46623: NEG
46624: PUSH
46625: LD_INT 3
46627: NEG
46628: PUSH
46629: EMPTY
46630: LIST
46631: LIST
46632: PUSH
46633: LD_INT 1
46635: NEG
46636: PUSH
46637: LD_INT 4
46639: NEG
46640: PUSH
46641: EMPTY
46642: LIST
46643: LIST
46644: PUSH
46645: LD_INT 2
46647: PUSH
46648: LD_INT 2
46650: NEG
46651: PUSH
46652: EMPTY
46653: LIST
46654: LIST
46655: PUSH
46656: LD_INT 2
46658: NEG
46659: PUSH
46660: LD_INT 4
46662: NEG
46663: PUSH
46664: EMPTY
46665: LIST
46666: LIST
46667: PUSH
46668: LD_INT 4
46670: PUSH
46671: LD_INT 0
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: LD_INT 4
46680: PUSH
46681: LD_INT 1
46683: NEG
46684: PUSH
46685: EMPTY
46686: LIST
46687: LIST
46688: PUSH
46689: LD_INT 5
46691: PUSH
46692: LD_INT 0
46694: PUSH
46695: EMPTY
46696: LIST
46697: LIST
46698: PUSH
46699: LD_INT 5
46701: PUSH
46702: LD_INT 1
46704: PUSH
46705: EMPTY
46706: LIST
46707: LIST
46708: PUSH
46709: LD_INT 4
46711: PUSH
46712: LD_INT 1
46714: PUSH
46715: EMPTY
46716: LIST
46717: LIST
46718: PUSH
46719: LD_INT 3
46721: PUSH
46722: LD_INT 0
46724: PUSH
46725: EMPTY
46726: LIST
46727: LIST
46728: PUSH
46729: LD_INT 3
46731: PUSH
46732: LD_INT 1
46734: NEG
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: PUSH
46740: LD_INT 3
46742: PUSH
46743: LD_INT 2
46745: NEG
46746: PUSH
46747: EMPTY
46748: LIST
46749: LIST
46750: PUSH
46751: LD_INT 5
46753: PUSH
46754: LD_INT 2
46756: PUSH
46757: EMPTY
46758: LIST
46759: LIST
46760: PUSH
46761: EMPTY
46762: LIST
46763: LIST
46764: LIST
46765: LIST
46766: LIST
46767: LIST
46768: LIST
46769: LIST
46770: LIST
46771: LIST
46772: LIST
46773: LIST
46774: LIST
46775: LIST
46776: LIST
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: LIST
46782: LIST
46783: LIST
46784: LIST
46785: LIST
46786: LIST
46787: LIST
46788: LIST
46789: LIST
46790: LIST
46791: LIST
46792: LIST
46793: LIST
46794: LIST
46795: LIST
46796: LIST
46797: LIST
46798: LIST
46799: LIST
46800: LIST
46801: LIST
46802: LIST
46803: LIST
46804: LIST
46805: LIST
46806: LIST
46807: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
46808: LD_ADDR_VAR 0 32
46812: PUSH
46813: LD_INT 4
46815: NEG
46816: PUSH
46817: LD_INT 0
46819: PUSH
46820: EMPTY
46821: LIST
46822: LIST
46823: PUSH
46824: LD_INT 4
46826: NEG
46827: PUSH
46828: LD_INT 1
46830: NEG
46831: PUSH
46832: EMPTY
46833: LIST
46834: LIST
46835: PUSH
46836: LD_INT 3
46838: NEG
46839: PUSH
46840: LD_INT 0
46842: PUSH
46843: EMPTY
46844: LIST
46845: LIST
46846: PUSH
46847: LD_INT 3
46849: NEG
46850: PUSH
46851: LD_INT 1
46853: PUSH
46854: EMPTY
46855: LIST
46856: LIST
46857: PUSH
46858: LD_INT 4
46860: NEG
46861: PUSH
46862: LD_INT 1
46864: PUSH
46865: EMPTY
46866: LIST
46867: LIST
46868: PUSH
46869: LD_INT 5
46871: NEG
46872: PUSH
46873: LD_INT 0
46875: PUSH
46876: EMPTY
46877: LIST
46878: LIST
46879: PUSH
46880: LD_INT 5
46882: NEG
46883: PUSH
46884: LD_INT 1
46886: NEG
46887: PUSH
46888: EMPTY
46889: LIST
46890: LIST
46891: PUSH
46892: LD_INT 5
46894: NEG
46895: PUSH
46896: LD_INT 2
46898: NEG
46899: PUSH
46900: EMPTY
46901: LIST
46902: LIST
46903: PUSH
46904: LD_INT 3
46906: NEG
46907: PUSH
46908: LD_INT 2
46910: PUSH
46911: EMPTY
46912: LIST
46913: LIST
46914: PUSH
46915: LD_INT 3
46917: NEG
46918: PUSH
46919: LD_INT 3
46921: NEG
46922: PUSH
46923: EMPTY
46924: LIST
46925: LIST
46926: PUSH
46927: LD_INT 3
46929: NEG
46930: PUSH
46931: LD_INT 4
46933: NEG
46934: PUSH
46935: EMPTY
46936: LIST
46937: LIST
46938: PUSH
46939: LD_INT 2
46941: NEG
46942: PUSH
46943: LD_INT 3
46945: NEG
46946: PUSH
46947: EMPTY
46948: LIST
46949: LIST
46950: PUSH
46951: LD_INT 2
46953: NEG
46954: PUSH
46955: LD_INT 2
46957: NEG
46958: PUSH
46959: EMPTY
46960: LIST
46961: LIST
46962: PUSH
46963: LD_INT 3
46965: NEG
46966: PUSH
46967: LD_INT 2
46969: NEG
46970: PUSH
46971: EMPTY
46972: LIST
46973: LIST
46974: PUSH
46975: LD_INT 4
46977: NEG
46978: PUSH
46979: LD_INT 3
46981: NEG
46982: PUSH
46983: EMPTY
46984: LIST
46985: LIST
46986: PUSH
46987: LD_INT 4
46989: NEG
46990: PUSH
46991: LD_INT 4
46993: NEG
46994: PUSH
46995: EMPTY
46996: LIST
46997: LIST
46998: PUSH
46999: LD_INT 2
47001: NEG
47002: PUSH
47003: LD_INT 4
47005: NEG
47006: PUSH
47007: EMPTY
47008: LIST
47009: LIST
47010: PUSH
47011: LD_INT 4
47013: NEG
47014: PUSH
47015: LD_INT 2
47017: NEG
47018: PUSH
47019: EMPTY
47020: LIST
47021: LIST
47022: PUSH
47023: LD_INT 0
47025: PUSH
47026: LD_INT 4
47028: NEG
47029: PUSH
47030: EMPTY
47031: LIST
47032: LIST
47033: PUSH
47034: LD_INT 0
47036: PUSH
47037: LD_INT 5
47039: NEG
47040: PUSH
47041: EMPTY
47042: LIST
47043: LIST
47044: PUSH
47045: LD_INT 1
47047: PUSH
47048: LD_INT 4
47050: NEG
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PUSH
47056: LD_INT 1
47058: PUSH
47059: LD_INT 3
47061: NEG
47062: PUSH
47063: EMPTY
47064: LIST
47065: LIST
47066: PUSH
47067: LD_INT 0
47069: PUSH
47070: LD_INT 3
47072: NEG
47073: PUSH
47074: EMPTY
47075: LIST
47076: LIST
47077: PUSH
47078: LD_INT 1
47080: NEG
47081: PUSH
47082: LD_INT 4
47084: NEG
47085: PUSH
47086: EMPTY
47087: LIST
47088: LIST
47089: PUSH
47090: LD_INT 1
47092: NEG
47093: PUSH
47094: LD_INT 5
47096: NEG
47097: PUSH
47098: EMPTY
47099: LIST
47100: LIST
47101: PUSH
47102: LD_INT 2
47104: PUSH
47105: LD_INT 3
47107: NEG
47108: PUSH
47109: EMPTY
47110: LIST
47111: LIST
47112: PUSH
47113: LD_INT 2
47115: NEG
47116: PUSH
47117: LD_INT 5
47119: NEG
47120: PUSH
47121: EMPTY
47122: LIST
47123: LIST
47124: PUSH
47125: LD_INT 3
47127: PUSH
47128: LD_INT 0
47130: PUSH
47131: EMPTY
47132: LIST
47133: LIST
47134: PUSH
47135: LD_INT 3
47137: PUSH
47138: LD_INT 1
47140: NEG
47141: PUSH
47142: EMPTY
47143: LIST
47144: LIST
47145: PUSH
47146: LD_INT 4
47148: PUSH
47149: LD_INT 0
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: PUSH
47156: LD_INT 4
47158: PUSH
47159: LD_INT 1
47161: PUSH
47162: EMPTY
47163: LIST
47164: LIST
47165: PUSH
47166: LD_INT 3
47168: PUSH
47169: LD_INT 1
47171: PUSH
47172: EMPTY
47173: LIST
47174: LIST
47175: PUSH
47176: LD_INT 2
47178: PUSH
47179: LD_INT 0
47181: PUSH
47182: EMPTY
47183: LIST
47184: LIST
47185: PUSH
47186: LD_INT 2
47188: PUSH
47189: LD_INT 1
47191: NEG
47192: PUSH
47193: EMPTY
47194: LIST
47195: LIST
47196: PUSH
47197: LD_INT 2
47199: PUSH
47200: LD_INT 2
47202: NEG
47203: PUSH
47204: EMPTY
47205: LIST
47206: LIST
47207: PUSH
47208: LD_INT 4
47210: PUSH
47211: LD_INT 2
47213: PUSH
47214: EMPTY
47215: LIST
47216: LIST
47217: PUSH
47218: LD_INT 4
47220: PUSH
47221: LD_INT 4
47223: PUSH
47224: EMPTY
47225: LIST
47226: LIST
47227: PUSH
47228: LD_INT 4
47230: PUSH
47231: LD_INT 3
47233: PUSH
47234: EMPTY
47235: LIST
47236: LIST
47237: PUSH
47238: LD_INT 5
47240: PUSH
47241: LD_INT 4
47243: PUSH
47244: EMPTY
47245: LIST
47246: LIST
47247: PUSH
47248: LD_INT 5
47250: PUSH
47251: LD_INT 5
47253: PUSH
47254: EMPTY
47255: LIST
47256: LIST
47257: PUSH
47258: LD_INT 4
47260: PUSH
47261: LD_INT 5
47263: PUSH
47264: EMPTY
47265: LIST
47266: LIST
47267: PUSH
47268: LD_INT 3
47270: PUSH
47271: LD_INT 4
47273: PUSH
47274: EMPTY
47275: LIST
47276: LIST
47277: PUSH
47278: LD_INT 3
47280: PUSH
47281: LD_INT 3
47283: PUSH
47284: EMPTY
47285: LIST
47286: LIST
47287: PUSH
47288: LD_INT 5
47290: PUSH
47291: LD_INT 3
47293: PUSH
47294: EMPTY
47295: LIST
47296: LIST
47297: PUSH
47298: LD_INT 3
47300: PUSH
47301: LD_INT 5
47303: PUSH
47304: EMPTY
47305: LIST
47306: LIST
47307: PUSH
47308: EMPTY
47309: LIST
47310: LIST
47311: LIST
47312: LIST
47313: LIST
47314: LIST
47315: LIST
47316: LIST
47317: LIST
47318: LIST
47319: LIST
47320: LIST
47321: LIST
47322: LIST
47323: LIST
47324: LIST
47325: LIST
47326: LIST
47327: LIST
47328: LIST
47329: LIST
47330: LIST
47331: LIST
47332: LIST
47333: LIST
47334: LIST
47335: LIST
47336: LIST
47337: LIST
47338: LIST
47339: LIST
47340: LIST
47341: LIST
47342: LIST
47343: LIST
47344: LIST
47345: LIST
47346: LIST
47347: LIST
47348: LIST
47349: LIST
47350: LIST
47351: LIST
47352: LIST
47353: LIST
47354: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
47355: LD_ADDR_VAR 0 33
47359: PUSH
47360: LD_INT 4
47362: NEG
47363: PUSH
47364: LD_INT 4
47366: NEG
47367: PUSH
47368: EMPTY
47369: LIST
47370: LIST
47371: PUSH
47372: LD_INT 4
47374: NEG
47375: PUSH
47376: LD_INT 5
47378: NEG
47379: PUSH
47380: EMPTY
47381: LIST
47382: LIST
47383: PUSH
47384: LD_INT 3
47386: NEG
47387: PUSH
47388: LD_INT 4
47390: NEG
47391: PUSH
47392: EMPTY
47393: LIST
47394: LIST
47395: PUSH
47396: LD_INT 3
47398: NEG
47399: PUSH
47400: LD_INT 3
47402: NEG
47403: PUSH
47404: EMPTY
47405: LIST
47406: LIST
47407: PUSH
47408: LD_INT 4
47410: NEG
47411: PUSH
47412: LD_INT 3
47414: NEG
47415: PUSH
47416: EMPTY
47417: LIST
47418: LIST
47419: PUSH
47420: LD_INT 5
47422: NEG
47423: PUSH
47424: LD_INT 4
47426: NEG
47427: PUSH
47428: EMPTY
47429: LIST
47430: LIST
47431: PUSH
47432: LD_INT 5
47434: NEG
47435: PUSH
47436: LD_INT 5
47438: NEG
47439: PUSH
47440: EMPTY
47441: LIST
47442: LIST
47443: PUSH
47444: LD_INT 3
47446: NEG
47447: PUSH
47448: LD_INT 5
47450: NEG
47451: PUSH
47452: EMPTY
47453: LIST
47454: LIST
47455: PUSH
47456: LD_INT 5
47458: NEG
47459: PUSH
47460: LD_INT 3
47462: NEG
47463: PUSH
47464: EMPTY
47465: LIST
47466: LIST
47467: PUSH
47468: LD_INT 0
47470: PUSH
47471: LD_INT 3
47473: NEG
47474: PUSH
47475: EMPTY
47476: LIST
47477: LIST
47478: PUSH
47479: LD_INT 0
47481: PUSH
47482: LD_INT 4
47484: NEG
47485: PUSH
47486: EMPTY
47487: LIST
47488: LIST
47489: PUSH
47490: LD_INT 1
47492: PUSH
47493: LD_INT 3
47495: NEG
47496: PUSH
47497: EMPTY
47498: LIST
47499: LIST
47500: PUSH
47501: LD_INT 1
47503: PUSH
47504: LD_INT 2
47506: NEG
47507: PUSH
47508: EMPTY
47509: LIST
47510: LIST
47511: PUSH
47512: LD_INT 0
47514: PUSH
47515: LD_INT 2
47517: NEG
47518: PUSH
47519: EMPTY
47520: LIST
47521: LIST
47522: PUSH
47523: LD_INT 1
47525: NEG
47526: PUSH
47527: LD_INT 3
47529: NEG
47530: PUSH
47531: EMPTY
47532: LIST
47533: LIST
47534: PUSH
47535: LD_INT 1
47537: NEG
47538: PUSH
47539: LD_INT 4
47541: NEG
47542: PUSH
47543: EMPTY
47544: LIST
47545: LIST
47546: PUSH
47547: LD_INT 2
47549: PUSH
47550: LD_INT 2
47552: NEG
47553: PUSH
47554: EMPTY
47555: LIST
47556: LIST
47557: PUSH
47558: LD_INT 2
47560: NEG
47561: PUSH
47562: LD_INT 4
47564: NEG
47565: PUSH
47566: EMPTY
47567: LIST
47568: LIST
47569: PUSH
47570: LD_INT 4
47572: PUSH
47573: LD_INT 0
47575: PUSH
47576: EMPTY
47577: LIST
47578: LIST
47579: PUSH
47580: LD_INT 4
47582: PUSH
47583: LD_INT 1
47585: NEG
47586: PUSH
47587: EMPTY
47588: LIST
47589: LIST
47590: PUSH
47591: LD_INT 5
47593: PUSH
47594: LD_INT 0
47596: PUSH
47597: EMPTY
47598: LIST
47599: LIST
47600: PUSH
47601: LD_INT 5
47603: PUSH
47604: LD_INT 1
47606: PUSH
47607: EMPTY
47608: LIST
47609: LIST
47610: PUSH
47611: LD_INT 4
47613: PUSH
47614: LD_INT 1
47616: PUSH
47617: EMPTY
47618: LIST
47619: LIST
47620: PUSH
47621: LD_INT 3
47623: PUSH
47624: LD_INT 0
47626: PUSH
47627: EMPTY
47628: LIST
47629: LIST
47630: PUSH
47631: LD_INT 3
47633: PUSH
47634: LD_INT 1
47636: NEG
47637: PUSH
47638: EMPTY
47639: LIST
47640: LIST
47641: PUSH
47642: LD_INT 3
47644: PUSH
47645: LD_INT 2
47647: NEG
47648: PUSH
47649: EMPTY
47650: LIST
47651: LIST
47652: PUSH
47653: LD_INT 5
47655: PUSH
47656: LD_INT 2
47658: PUSH
47659: EMPTY
47660: LIST
47661: LIST
47662: PUSH
47663: LD_INT 3
47665: PUSH
47666: LD_INT 3
47668: PUSH
47669: EMPTY
47670: LIST
47671: LIST
47672: PUSH
47673: LD_INT 3
47675: PUSH
47676: LD_INT 2
47678: PUSH
47679: EMPTY
47680: LIST
47681: LIST
47682: PUSH
47683: LD_INT 4
47685: PUSH
47686: LD_INT 3
47688: PUSH
47689: EMPTY
47690: LIST
47691: LIST
47692: PUSH
47693: LD_INT 4
47695: PUSH
47696: LD_INT 4
47698: PUSH
47699: EMPTY
47700: LIST
47701: LIST
47702: PUSH
47703: LD_INT 3
47705: PUSH
47706: LD_INT 4
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: PUSH
47713: LD_INT 2
47715: PUSH
47716: LD_INT 3
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: PUSH
47723: LD_INT 2
47725: PUSH
47726: LD_INT 2
47728: PUSH
47729: EMPTY
47730: LIST
47731: LIST
47732: PUSH
47733: LD_INT 4
47735: PUSH
47736: LD_INT 2
47738: PUSH
47739: EMPTY
47740: LIST
47741: LIST
47742: PUSH
47743: LD_INT 2
47745: PUSH
47746: LD_INT 4
47748: PUSH
47749: EMPTY
47750: LIST
47751: LIST
47752: PUSH
47753: LD_INT 0
47755: PUSH
47756: LD_INT 4
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: PUSH
47763: LD_INT 0
47765: PUSH
47766: LD_INT 3
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: PUSH
47773: LD_INT 1
47775: PUSH
47776: LD_INT 4
47778: PUSH
47779: EMPTY
47780: LIST
47781: LIST
47782: PUSH
47783: LD_INT 1
47785: PUSH
47786: LD_INT 5
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: PUSH
47793: LD_INT 0
47795: PUSH
47796: LD_INT 5
47798: PUSH
47799: EMPTY
47800: LIST
47801: LIST
47802: PUSH
47803: LD_INT 1
47805: NEG
47806: PUSH
47807: LD_INT 4
47809: PUSH
47810: EMPTY
47811: LIST
47812: LIST
47813: PUSH
47814: LD_INT 1
47816: NEG
47817: PUSH
47818: LD_INT 3
47820: PUSH
47821: EMPTY
47822: LIST
47823: LIST
47824: PUSH
47825: LD_INT 2
47827: PUSH
47828: LD_INT 5
47830: PUSH
47831: EMPTY
47832: LIST
47833: LIST
47834: PUSH
47835: LD_INT 2
47837: NEG
47838: PUSH
47839: LD_INT 3
47841: PUSH
47842: EMPTY
47843: LIST
47844: LIST
47845: PUSH
47846: EMPTY
47847: LIST
47848: LIST
47849: LIST
47850: LIST
47851: LIST
47852: LIST
47853: LIST
47854: LIST
47855: LIST
47856: LIST
47857: LIST
47858: LIST
47859: LIST
47860: LIST
47861: LIST
47862: LIST
47863: LIST
47864: LIST
47865: LIST
47866: LIST
47867: LIST
47868: LIST
47869: LIST
47870: LIST
47871: LIST
47872: LIST
47873: LIST
47874: LIST
47875: LIST
47876: LIST
47877: LIST
47878: LIST
47879: LIST
47880: LIST
47881: LIST
47882: LIST
47883: LIST
47884: LIST
47885: LIST
47886: LIST
47887: LIST
47888: LIST
47889: LIST
47890: LIST
47891: LIST
47892: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
47893: LD_ADDR_VAR 0 34
47897: PUSH
47898: LD_INT 0
47900: PUSH
47901: LD_INT 4
47903: NEG
47904: PUSH
47905: EMPTY
47906: LIST
47907: LIST
47908: PUSH
47909: LD_INT 0
47911: PUSH
47912: LD_INT 5
47914: NEG
47915: PUSH
47916: EMPTY
47917: LIST
47918: LIST
47919: PUSH
47920: LD_INT 1
47922: PUSH
47923: LD_INT 4
47925: NEG
47926: PUSH
47927: EMPTY
47928: LIST
47929: LIST
47930: PUSH
47931: LD_INT 1
47933: PUSH
47934: LD_INT 3
47936: NEG
47937: PUSH
47938: EMPTY
47939: LIST
47940: LIST
47941: PUSH
47942: LD_INT 0
47944: PUSH
47945: LD_INT 3
47947: NEG
47948: PUSH
47949: EMPTY
47950: LIST
47951: LIST
47952: PUSH
47953: LD_INT 1
47955: NEG
47956: PUSH
47957: LD_INT 4
47959: NEG
47960: PUSH
47961: EMPTY
47962: LIST
47963: LIST
47964: PUSH
47965: LD_INT 1
47967: NEG
47968: PUSH
47969: LD_INT 5
47971: NEG
47972: PUSH
47973: EMPTY
47974: LIST
47975: LIST
47976: PUSH
47977: LD_INT 2
47979: PUSH
47980: LD_INT 3
47982: NEG
47983: PUSH
47984: EMPTY
47985: LIST
47986: LIST
47987: PUSH
47988: LD_INT 2
47990: NEG
47991: PUSH
47992: LD_INT 5
47994: NEG
47995: PUSH
47996: EMPTY
47997: LIST
47998: LIST
47999: PUSH
48000: LD_INT 3
48002: PUSH
48003: LD_INT 0
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: PUSH
48010: LD_INT 3
48012: PUSH
48013: LD_INT 1
48015: NEG
48016: PUSH
48017: EMPTY
48018: LIST
48019: LIST
48020: PUSH
48021: LD_INT 4
48023: PUSH
48024: LD_INT 0
48026: PUSH
48027: EMPTY
48028: LIST
48029: LIST
48030: PUSH
48031: LD_INT 4
48033: PUSH
48034: LD_INT 1
48036: PUSH
48037: EMPTY
48038: LIST
48039: LIST
48040: PUSH
48041: LD_INT 3
48043: PUSH
48044: LD_INT 1
48046: PUSH
48047: EMPTY
48048: LIST
48049: LIST
48050: PUSH
48051: LD_INT 2
48053: PUSH
48054: LD_INT 0
48056: PUSH
48057: EMPTY
48058: LIST
48059: LIST
48060: PUSH
48061: LD_INT 2
48063: PUSH
48064: LD_INT 1
48066: NEG
48067: PUSH
48068: EMPTY
48069: LIST
48070: LIST
48071: PUSH
48072: LD_INT 2
48074: PUSH
48075: LD_INT 2
48077: NEG
48078: PUSH
48079: EMPTY
48080: LIST
48081: LIST
48082: PUSH
48083: LD_INT 4
48085: PUSH
48086: LD_INT 2
48088: PUSH
48089: EMPTY
48090: LIST
48091: LIST
48092: PUSH
48093: LD_INT 4
48095: PUSH
48096: LD_INT 4
48098: PUSH
48099: EMPTY
48100: LIST
48101: LIST
48102: PUSH
48103: LD_INT 4
48105: PUSH
48106: LD_INT 3
48108: PUSH
48109: EMPTY
48110: LIST
48111: LIST
48112: PUSH
48113: LD_INT 5
48115: PUSH
48116: LD_INT 4
48118: PUSH
48119: EMPTY
48120: LIST
48121: LIST
48122: PUSH
48123: LD_INT 5
48125: PUSH
48126: LD_INT 5
48128: PUSH
48129: EMPTY
48130: LIST
48131: LIST
48132: PUSH
48133: LD_INT 4
48135: PUSH
48136: LD_INT 5
48138: PUSH
48139: EMPTY
48140: LIST
48141: LIST
48142: PUSH
48143: LD_INT 3
48145: PUSH
48146: LD_INT 4
48148: PUSH
48149: EMPTY
48150: LIST
48151: LIST
48152: PUSH
48153: LD_INT 3
48155: PUSH
48156: LD_INT 3
48158: PUSH
48159: EMPTY
48160: LIST
48161: LIST
48162: PUSH
48163: LD_INT 5
48165: PUSH
48166: LD_INT 3
48168: PUSH
48169: EMPTY
48170: LIST
48171: LIST
48172: PUSH
48173: LD_INT 3
48175: PUSH
48176: LD_INT 5
48178: PUSH
48179: EMPTY
48180: LIST
48181: LIST
48182: PUSH
48183: LD_INT 0
48185: PUSH
48186: LD_INT 3
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: PUSH
48193: LD_INT 0
48195: PUSH
48196: LD_INT 2
48198: PUSH
48199: EMPTY
48200: LIST
48201: LIST
48202: PUSH
48203: LD_INT 1
48205: PUSH
48206: LD_INT 3
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: PUSH
48213: LD_INT 1
48215: PUSH
48216: LD_INT 4
48218: PUSH
48219: EMPTY
48220: LIST
48221: LIST
48222: PUSH
48223: LD_INT 0
48225: PUSH
48226: LD_INT 4
48228: PUSH
48229: EMPTY
48230: LIST
48231: LIST
48232: PUSH
48233: LD_INT 1
48235: NEG
48236: PUSH
48237: LD_INT 3
48239: PUSH
48240: EMPTY
48241: LIST
48242: LIST
48243: PUSH
48244: LD_INT 1
48246: NEG
48247: PUSH
48248: LD_INT 2
48250: PUSH
48251: EMPTY
48252: LIST
48253: LIST
48254: PUSH
48255: LD_INT 2
48257: PUSH
48258: LD_INT 4
48260: PUSH
48261: EMPTY
48262: LIST
48263: LIST
48264: PUSH
48265: LD_INT 2
48267: NEG
48268: PUSH
48269: LD_INT 2
48271: PUSH
48272: EMPTY
48273: LIST
48274: LIST
48275: PUSH
48276: LD_INT 4
48278: NEG
48279: PUSH
48280: LD_INT 0
48282: PUSH
48283: EMPTY
48284: LIST
48285: LIST
48286: PUSH
48287: LD_INT 4
48289: NEG
48290: PUSH
48291: LD_INT 1
48293: NEG
48294: PUSH
48295: EMPTY
48296: LIST
48297: LIST
48298: PUSH
48299: LD_INT 3
48301: NEG
48302: PUSH
48303: LD_INT 0
48305: PUSH
48306: EMPTY
48307: LIST
48308: LIST
48309: PUSH
48310: LD_INT 3
48312: NEG
48313: PUSH
48314: LD_INT 1
48316: PUSH
48317: EMPTY
48318: LIST
48319: LIST
48320: PUSH
48321: LD_INT 4
48323: NEG
48324: PUSH
48325: LD_INT 1
48327: PUSH
48328: EMPTY
48329: LIST
48330: LIST
48331: PUSH
48332: LD_INT 5
48334: NEG
48335: PUSH
48336: LD_INT 0
48338: PUSH
48339: EMPTY
48340: LIST
48341: LIST
48342: PUSH
48343: LD_INT 5
48345: NEG
48346: PUSH
48347: LD_INT 1
48349: NEG
48350: PUSH
48351: EMPTY
48352: LIST
48353: LIST
48354: PUSH
48355: LD_INT 5
48357: NEG
48358: PUSH
48359: LD_INT 2
48361: NEG
48362: PUSH
48363: EMPTY
48364: LIST
48365: LIST
48366: PUSH
48367: LD_INT 3
48369: NEG
48370: PUSH
48371: LD_INT 2
48373: PUSH
48374: EMPTY
48375: LIST
48376: LIST
48377: PUSH
48378: EMPTY
48379: LIST
48380: LIST
48381: LIST
48382: LIST
48383: LIST
48384: LIST
48385: LIST
48386: LIST
48387: LIST
48388: LIST
48389: LIST
48390: LIST
48391: LIST
48392: LIST
48393: LIST
48394: LIST
48395: LIST
48396: LIST
48397: LIST
48398: LIST
48399: LIST
48400: LIST
48401: LIST
48402: LIST
48403: LIST
48404: LIST
48405: LIST
48406: LIST
48407: LIST
48408: LIST
48409: LIST
48410: LIST
48411: LIST
48412: LIST
48413: LIST
48414: LIST
48415: LIST
48416: LIST
48417: LIST
48418: LIST
48419: LIST
48420: LIST
48421: LIST
48422: LIST
48423: LIST
48424: ST_TO_ADDR
// end ; end ;
48425: GO 48428
48427: POP
// case btype of b_depot , b_warehouse :
48428: LD_VAR 0 1
48432: PUSH
48433: LD_INT 0
48435: DOUBLE
48436: EQUAL
48437: IFTRUE 48447
48439: LD_INT 1
48441: DOUBLE
48442: EQUAL
48443: IFTRUE 48447
48445: GO 48648
48447: POP
// case nation of nation_american :
48448: LD_VAR 0 5
48452: PUSH
48453: LD_INT 1
48455: DOUBLE
48456: EQUAL
48457: IFTRUE 48461
48459: GO 48517
48461: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
48462: LD_ADDR_VAR 0 9
48466: PUSH
48467: LD_VAR 0 11
48471: PUSH
48472: LD_VAR 0 12
48476: PUSH
48477: LD_VAR 0 13
48481: PUSH
48482: LD_VAR 0 14
48486: PUSH
48487: LD_VAR 0 15
48491: PUSH
48492: LD_VAR 0 16
48496: PUSH
48497: EMPTY
48498: LIST
48499: LIST
48500: LIST
48501: LIST
48502: LIST
48503: LIST
48504: PUSH
48505: LD_VAR 0 4
48509: PUSH
48510: LD_INT 1
48512: PLUS
48513: ARRAY
48514: ST_TO_ADDR
48515: GO 48646
48517: LD_INT 2
48519: DOUBLE
48520: EQUAL
48521: IFTRUE 48525
48523: GO 48581
48525: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
48526: LD_ADDR_VAR 0 9
48530: PUSH
48531: LD_VAR 0 17
48535: PUSH
48536: LD_VAR 0 18
48540: PUSH
48541: LD_VAR 0 19
48545: PUSH
48546: LD_VAR 0 20
48550: PUSH
48551: LD_VAR 0 21
48555: PUSH
48556: LD_VAR 0 22
48560: PUSH
48561: EMPTY
48562: LIST
48563: LIST
48564: LIST
48565: LIST
48566: LIST
48567: LIST
48568: PUSH
48569: LD_VAR 0 4
48573: PUSH
48574: LD_INT 1
48576: PLUS
48577: ARRAY
48578: ST_TO_ADDR
48579: GO 48646
48581: LD_INT 3
48583: DOUBLE
48584: EQUAL
48585: IFTRUE 48589
48587: GO 48645
48589: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
48590: LD_ADDR_VAR 0 9
48594: PUSH
48595: LD_VAR 0 23
48599: PUSH
48600: LD_VAR 0 24
48604: PUSH
48605: LD_VAR 0 25
48609: PUSH
48610: LD_VAR 0 26
48614: PUSH
48615: LD_VAR 0 27
48619: PUSH
48620: LD_VAR 0 28
48624: PUSH
48625: EMPTY
48626: LIST
48627: LIST
48628: LIST
48629: LIST
48630: LIST
48631: LIST
48632: PUSH
48633: LD_VAR 0 4
48637: PUSH
48638: LD_INT 1
48640: PLUS
48641: ARRAY
48642: ST_TO_ADDR
48643: GO 48646
48645: POP
48646: GO 49201
48648: LD_INT 2
48650: DOUBLE
48651: EQUAL
48652: IFTRUE 48662
48654: LD_INT 3
48656: DOUBLE
48657: EQUAL
48658: IFTRUE 48662
48660: GO 48718
48662: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
48663: LD_ADDR_VAR 0 9
48667: PUSH
48668: LD_VAR 0 29
48672: PUSH
48673: LD_VAR 0 30
48677: PUSH
48678: LD_VAR 0 31
48682: PUSH
48683: LD_VAR 0 32
48687: PUSH
48688: LD_VAR 0 33
48692: PUSH
48693: LD_VAR 0 34
48697: PUSH
48698: EMPTY
48699: LIST
48700: LIST
48701: LIST
48702: LIST
48703: LIST
48704: LIST
48705: PUSH
48706: LD_VAR 0 4
48710: PUSH
48711: LD_INT 1
48713: PLUS
48714: ARRAY
48715: ST_TO_ADDR
48716: GO 49201
48718: LD_INT 16
48720: DOUBLE
48721: EQUAL
48722: IFTRUE 48780
48724: LD_INT 17
48726: DOUBLE
48727: EQUAL
48728: IFTRUE 48780
48730: LD_INT 18
48732: DOUBLE
48733: EQUAL
48734: IFTRUE 48780
48736: LD_INT 19
48738: DOUBLE
48739: EQUAL
48740: IFTRUE 48780
48742: LD_INT 22
48744: DOUBLE
48745: EQUAL
48746: IFTRUE 48780
48748: LD_INT 20
48750: DOUBLE
48751: EQUAL
48752: IFTRUE 48780
48754: LD_INT 21
48756: DOUBLE
48757: EQUAL
48758: IFTRUE 48780
48760: LD_INT 23
48762: DOUBLE
48763: EQUAL
48764: IFTRUE 48780
48766: LD_INT 24
48768: DOUBLE
48769: EQUAL
48770: IFTRUE 48780
48772: LD_INT 25
48774: DOUBLE
48775: EQUAL
48776: IFTRUE 48780
48778: GO 48836
48780: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
48781: LD_ADDR_VAR 0 9
48785: PUSH
48786: LD_VAR 0 35
48790: PUSH
48791: LD_VAR 0 36
48795: PUSH
48796: LD_VAR 0 37
48800: PUSH
48801: LD_VAR 0 38
48805: PUSH
48806: LD_VAR 0 39
48810: PUSH
48811: LD_VAR 0 40
48815: PUSH
48816: EMPTY
48817: LIST
48818: LIST
48819: LIST
48820: LIST
48821: LIST
48822: LIST
48823: PUSH
48824: LD_VAR 0 4
48828: PUSH
48829: LD_INT 1
48831: PLUS
48832: ARRAY
48833: ST_TO_ADDR
48834: GO 49201
48836: LD_INT 6
48838: DOUBLE
48839: EQUAL
48840: IFTRUE 48892
48842: LD_INT 7
48844: DOUBLE
48845: EQUAL
48846: IFTRUE 48892
48848: LD_INT 8
48850: DOUBLE
48851: EQUAL
48852: IFTRUE 48892
48854: LD_INT 13
48856: DOUBLE
48857: EQUAL
48858: IFTRUE 48892
48860: LD_INT 12
48862: DOUBLE
48863: EQUAL
48864: IFTRUE 48892
48866: LD_INT 15
48868: DOUBLE
48869: EQUAL
48870: IFTRUE 48892
48872: LD_INT 11
48874: DOUBLE
48875: EQUAL
48876: IFTRUE 48892
48878: LD_INT 14
48880: DOUBLE
48881: EQUAL
48882: IFTRUE 48892
48884: LD_INT 10
48886: DOUBLE
48887: EQUAL
48888: IFTRUE 48892
48890: GO 48948
48892: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
48893: LD_ADDR_VAR 0 9
48897: PUSH
48898: LD_VAR 0 41
48902: PUSH
48903: LD_VAR 0 42
48907: PUSH
48908: LD_VAR 0 43
48912: PUSH
48913: LD_VAR 0 44
48917: PUSH
48918: LD_VAR 0 45
48922: PUSH
48923: LD_VAR 0 46
48927: PUSH
48928: EMPTY
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: PUSH
48936: LD_VAR 0 4
48940: PUSH
48941: LD_INT 1
48943: PLUS
48944: ARRAY
48945: ST_TO_ADDR
48946: GO 49201
48948: LD_INT 36
48950: DOUBLE
48951: EQUAL
48952: IFTRUE 48956
48954: GO 49012
48956: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
48957: LD_ADDR_VAR 0 9
48961: PUSH
48962: LD_VAR 0 47
48966: PUSH
48967: LD_VAR 0 48
48971: PUSH
48972: LD_VAR 0 49
48976: PUSH
48977: LD_VAR 0 50
48981: PUSH
48982: LD_VAR 0 51
48986: PUSH
48987: LD_VAR 0 52
48991: PUSH
48992: EMPTY
48993: LIST
48994: LIST
48995: LIST
48996: LIST
48997: LIST
48998: LIST
48999: PUSH
49000: LD_VAR 0 4
49004: PUSH
49005: LD_INT 1
49007: PLUS
49008: ARRAY
49009: ST_TO_ADDR
49010: GO 49201
49012: LD_INT 4
49014: DOUBLE
49015: EQUAL
49016: IFTRUE 49038
49018: LD_INT 5
49020: DOUBLE
49021: EQUAL
49022: IFTRUE 49038
49024: LD_INT 34
49026: DOUBLE
49027: EQUAL
49028: IFTRUE 49038
49030: LD_INT 37
49032: DOUBLE
49033: EQUAL
49034: IFTRUE 49038
49036: GO 49094
49038: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
49039: LD_ADDR_VAR 0 9
49043: PUSH
49044: LD_VAR 0 53
49048: PUSH
49049: LD_VAR 0 54
49053: PUSH
49054: LD_VAR 0 55
49058: PUSH
49059: LD_VAR 0 56
49063: PUSH
49064: LD_VAR 0 57
49068: PUSH
49069: LD_VAR 0 58
49073: PUSH
49074: EMPTY
49075: LIST
49076: LIST
49077: LIST
49078: LIST
49079: LIST
49080: LIST
49081: PUSH
49082: LD_VAR 0 4
49086: PUSH
49087: LD_INT 1
49089: PLUS
49090: ARRAY
49091: ST_TO_ADDR
49092: GO 49201
49094: LD_INT 31
49096: DOUBLE
49097: EQUAL
49098: IFTRUE 49144
49100: LD_INT 32
49102: DOUBLE
49103: EQUAL
49104: IFTRUE 49144
49106: LD_INT 33
49108: DOUBLE
49109: EQUAL
49110: IFTRUE 49144
49112: LD_INT 27
49114: DOUBLE
49115: EQUAL
49116: IFTRUE 49144
49118: LD_INT 26
49120: DOUBLE
49121: EQUAL
49122: IFTRUE 49144
49124: LD_INT 28
49126: DOUBLE
49127: EQUAL
49128: IFTRUE 49144
49130: LD_INT 29
49132: DOUBLE
49133: EQUAL
49134: IFTRUE 49144
49136: LD_INT 30
49138: DOUBLE
49139: EQUAL
49140: IFTRUE 49144
49142: GO 49200
49144: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
49145: LD_ADDR_VAR 0 9
49149: PUSH
49150: LD_VAR 0 59
49154: PUSH
49155: LD_VAR 0 60
49159: PUSH
49160: LD_VAR 0 61
49164: PUSH
49165: LD_VAR 0 62
49169: PUSH
49170: LD_VAR 0 63
49174: PUSH
49175: LD_VAR 0 64
49179: PUSH
49180: EMPTY
49181: LIST
49182: LIST
49183: LIST
49184: LIST
49185: LIST
49186: LIST
49187: PUSH
49188: LD_VAR 0 4
49192: PUSH
49193: LD_INT 1
49195: PLUS
49196: ARRAY
49197: ST_TO_ADDR
49198: GO 49201
49200: POP
// temp_list2 = [ ] ;
49201: LD_ADDR_VAR 0 10
49205: PUSH
49206: EMPTY
49207: ST_TO_ADDR
// for i in temp_list do
49208: LD_ADDR_VAR 0 8
49212: PUSH
49213: LD_VAR 0 9
49217: PUSH
49218: FOR_IN
49219: IFFALSE 49271
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
49221: LD_ADDR_VAR 0 10
49225: PUSH
49226: LD_VAR 0 10
49230: PUSH
49231: LD_VAR 0 8
49235: PUSH
49236: LD_INT 1
49238: ARRAY
49239: PUSH
49240: LD_VAR 0 2
49244: PLUS
49245: PUSH
49246: LD_VAR 0 8
49250: PUSH
49251: LD_INT 2
49253: ARRAY
49254: PUSH
49255: LD_VAR 0 3
49259: PLUS
49260: PUSH
49261: EMPTY
49262: LIST
49263: LIST
49264: PUSH
49265: EMPTY
49266: LIST
49267: ADD
49268: ST_TO_ADDR
49269: GO 49218
49271: POP
49272: POP
// result = temp_list2 ;
49273: LD_ADDR_VAR 0 7
49277: PUSH
49278: LD_VAR 0 10
49282: ST_TO_ADDR
// end ;
49283: LD_VAR 0 7
49287: RET
// export function EnemyInRange ( unit , dist ) ; begin
49288: LD_INT 0
49290: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
49291: LD_ADDR_VAR 0 3
49295: PUSH
49296: LD_VAR 0 1
49300: PPUSH
49301: CALL_OW 255
49305: PPUSH
49306: LD_VAR 0 1
49310: PPUSH
49311: CALL_OW 250
49315: PPUSH
49316: LD_VAR 0 1
49320: PPUSH
49321: CALL_OW 251
49325: PPUSH
49326: LD_VAR 0 2
49330: PPUSH
49331: CALL 22661 0 4
49335: PUSH
49336: LD_INT 4
49338: ARRAY
49339: ST_TO_ADDR
// end ;
49340: LD_VAR 0 3
49344: RET
// export function PlayerSeeMe ( unit ) ; begin
49345: LD_INT 0
49347: PPUSH
// result := See ( your_side , unit ) ;
49348: LD_ADDR_VAR 0 2
49352: PUSH
49353: LD_OWVAR 2
49357: PPUSH
49358: LD_VAR 0 1
49362: PPUSH
49363: CALL_OW 292
49367: ST_TO_ADDR
// end ;
49368: LD_VAR 0 2
49372: RET
// export function ReverseDir ( unit ) ; begin
49373: LD_INT 0
49375: PPUSH
// if not unit then
49376: LD_VAR 0 1
49380: NOT
49381: IFFALSE 49385
// exit ;
49383: GO 49408
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
49385: LD_ADDR_VAR 0 2
49389: PUSH
49390: LD_VAR 0 1
49394: PPUSH
49395: CALL_OW 254
49399: PUSH
49400: LD_INT 3
49402: PLUS
49403: PUSH
49404: LD_INT 6
49406: MOD
49407: ST_TO_ADDR
// end ;
49408: LD_VAR 0 2
49412: RET
// export function ReverseArray ( array ) ; var i ; begin
49413: LD_INT 0
49415: PPUSH
49416: PPUSH
// if not array then
49417: LD_VAR 0 1
49421: NOT
49422: IFFALSE 49426
// exit ;
49424: GO 49481
// result := [ ] ;
49426: LD_ADDR_VAR 0 2
49430: PUSH
49431: EMPTY
49432: ST_TO_ADDR
// for i := array downto 1 do
49433: LD_ADDR_VAR 0 3
49437: PUSH
49438: DOUBLE
49439: LD_VAR 0 1
49443: INC
49444: ST_TO_ADDR
49445: LD_INT 1
49447: PUSH
49448: FOR_DOWNTO
49449: IFFALSE 49479
// result := Join ( result , array [ i ] ) ;
49451: LD_ADDR_VAR 0 2
49455: PUSH
49456: LD_VAR 0 2
49460: PPUSH
49461: LD_VAR 0 1
49465: PUSH
49466: LD_VAR 0 3
49470: ARRAY
49471: PPUSH
49472: CALL 54137 0 2
49476: ST_TO_ADDR
49477: GO 49448
49479: POP
49480: POP
// end ;
49481: LD_VAR 0 2
49485: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
49486: LD_INT 0
49488: PPUSH
49489: PPUSH
49490: PPUSH
49491: PPUSH
49492: PPUSH
49493: PPUSH
// if not unit or not hexes then
49494: LD_VAR 0 1
49498: NOT
49499: PUSH
49500: LD_VAR 0 2
49504: NOT
49505: OR
49506: IFFALSE 49510
// exit ;
49508: GO 49633
// dist := 9999 ;
49510: LD_ADDR_VAR 0 5
49514: PUSH
49515: LD_INT 9999
49517: ST_TO_ADDR
// for i = 1 to hexes do
49518: LD_ADDR_VAR 0 4
49522: PUSH
49523: DOUBLE
49524: LD_INT 1
49526: DEC
49527: ST_TO_ADDR
49528: LD_VAR 0 2
49532: PUSH
49533: FOR_TO
49534: IFFALSE 49621
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
49536: LD_ADDR_VAR 0 6
49540: PUSH
49541: LD_VAR 0 1
49545: PPUSH
49546: LD_VAR 0 2
49550: PUSH
49551: LD_VAR 0 4
49555: ARRAY
49556: PUSH
49557: LD_INT 1
49559: ARRAY
49560: PPUSH
49561: LD_VAR 0 2
49565: PUSH
49566: LD_VAR 0 4
49570: ARRAY
49571: PUSH
49572: LD_INT 2
49574: ARRAY
49575: PPUSH
49576: CALL_OW 297
49580: ST_TO_ADDR
// if tdist < dist then
49581: LD_VAR 0 6
49585: PUSH
49586: LD_VAR 0 5
49590: LESS
49591: IFFALSE 49619
// begin hex := hexes [ i ] ;
49593: LD_ADDR_VAR 0 8
49597: PUSH
49598: LD_VAR 0 2
49602: PUSH
49603: LD_VAR 0 4
49607: ARRAY
49608: ST_TO_ADDR
// dist := tdist ;
49609: LD_ADDR_VAR 0 5
49613: PUSH
49614: LD_VAR 0 6
49618: ST_TO_ADDR
// end ; end ;
49619: GO 49533
49621: POP
49622: POP
// result := hex ;
49623: LD_ADDR_VAR 0 3
49627: PUSH
49628: LD_VAR 0 8
49632: ST_TO_ADDR
// end ;
49633: LD_VAR 0 3
49637: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
49638: LD_INT 0
49640: PPUSH
49641: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
49642: LD_VAR 0 1
49646: NOT
49647: PUSH
49648: LD_VAR 0 1
49652: PUSH
49653: LD_INT 21
49655: PUSH
49656: LD_INT 2
49658: PUSH
49659: EMPTY
49660: LIST
49661: LIST
49662: PUSH
49663: LD_INT 23
49665: PUSH
49666: LD_INT 2
49668: PUSH
49669: EMPTY
49670: LIST
49671: LIST
49672: PUSH
49673: EMPTY
49674: LIST
49675: LIST
49676: PPUSH
49677: CALL_OW 69
49681: IN
49682: NOT
49683: OR
49684: IFFALSE 49688
// exit ;
49686: GO 49735
// for i = 1 to 3 do
49688: LD_ADDR_VAR 0 3
49692: PUSH
49693: DOUBLE
49694: LD_INT 1
49696: DEC
49697: ST_TO_ADDR
49698: LD_INT 3
49700: PUSH
49701: FOR_TO
49702: IFFALSE 49733
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
49704: LD_VAR 0 1
49708: PPUSH
49709: CALL_OW 250
49713: PPUSH
49714: LD_VAR 0 1
49718: PPUSH
49719: CALL_OW 251
49723: PPUSH
49724: LD_INT 1
49726: PPUSH
49727: CALL_OW 453
49731: GO 49701
49733: POP
49734: POP
// end ;
49735: LD_VAR 0 2
49739: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
49740: LD_INT 0
49742: PPUSH
49743: PPUSH
49744: PPUSH
49745: PPUSH
49746: PPUSH
49747: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
49748: LD_VAR 0 1
49752: NOT
49753: PUSH
49754: LD_VAR 0 2
49758: NOT
49759: OR
49760: PUSH
49761: LD_VAR 0 1
49765: PPUSH
49766: CALL_OW 314
49770: OR
49771: IFFALSE 49775
// exit ;
49773: GO 50242
// if GetLives ( i ) < 250 then
49775: LD_VAR 0 4
49779: PPUSH
49780: CALL_OW 256
49784: PUSH
49785: LD_INT 250
49787: LESS
49788: IFFALSE 49801
// begin ComAutodestruct ( i ) ;
49790: LD_VAR 0 4
49794: PPUSH
49795: CALL 49638 0 1
// exit ;
49799: GO 50242
// end ; x := GetX ( enemy_unit ) ;
49801: LD_ADDR_VAR 0 7
49805: PUSH
49806: LD_VAR 0 2
49810: PPUSH
49811: CALL_OW 250
49815: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
49816: LD_ADDR_VAR 0 8
49820: PUSH
49821: LD_VAR 0 2
49825: PPUSH
49826: CALL_OW 251
49830: ST_TO_ADDR
// if not x or not y then
49831: LD_VAR 0 7
49835: NOT
49836: PUSH
49837: LD_VAR 0 8
49841: NOT
49842: OR
49843: IFFALSE 49847
// exit ;
49845: GO 50242
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
49847: LD_ADDR_VAR 0 6
49851: PUSH
49852: LD_VAR 0 7
49856: PPUSH
49857: LD_INT 0
49859: PPUSH
49860: LD_INT 4
49862: PPUSH
49863: CALL_OW 272
49867: PUSH
49868: LD_VAR 0 8
49872: PPUSH
49873: LD_INT 0
49875: PPUSH
49876: LD_INT 4
49878: PPUSH
49879: CALL_OW 273
49883: PUSH
49884: EMPTY
49885: LIST
49886: LIST
49887: PUSH
49888: LD_VAR 0 7
49892: PPUSH
49893: LD_INT 1
49895: PPUSH
49896: LD_INT 4
49898: PPUSH
49899: CALL_OW 272
49903: PUSH
49904: LD_VAR 0 8
49908: PPUSH
49909: LD_INT 1
49911: PPUSH
49912: LD_INT 4
49914: PPUSH
49915: CALL_OW 273
49919: PUSH
49920: EMPTY
49921: LIST
49922: LIST
49923: PUSH
49924: LD_VAR 0 7
49928: PPUSH
49929: LD_INT 2
49931: PPUSH
49932: LD_INT 4
49934: PPUSH
49935: CALL_OW 272
49939: PUSH
49940: LD_VAR 0 8
49944: PPUSH
49945: LD_INT 2
49947: PPUSH
49948: LD_INT 4
49950: PPUSH
49951: CALL_OW 273
49955: PUSH
49956: EMPTY
49957: LIST
49958: LIST
49959: PUSH
49960: LD_VAR 0 7
49964: PPUSH
49965: LD_INT 3
49967: PPUSH
49968: LD_INT 4
49970: PPUSH
49971: CALL_OW 272
49975: PUSH
49976: LD_VAR 0 8
49980: PPUSH
49981: LD_INT 3
49983: PPUSH
49984: LD_INT 4
49986: PPUSH
49987: CALL_OW 273
49991: PUSH
49992: EMPTY
49993: LIST
49994: LIST
49995: PUSH
49996: LD_VAR 0 7
50000: PPUSH
50001: LD_INT 4
50003: PPUSH
50004: LD_INT 4
50006: PPUSH
50007: CALL_OW 272
50011: PUSH
50012: LD_VAR 0 8
50016: PPUSH
50017: LD_INT 4
50019: PPUSH
50020: LD_INT 4
50022: PPUSH
50023: CALL_OW 273
50027: PUSH
50028: EMPTY
50029: LIST
50030: LIST
50031: PUSH
50032: LD_VAR 0 7
50036: PPUSH
50037: LD_INT 5
50039: PPUSH
50040: LD_INT 4
50042: PPUSH
50043: CALL_OW 272
50047: PUSH
50048: LD_VAR 0 8
50052: PPUSH
50053: LD_INT 5
50055: PPUSH
50056: LD_INT 4
50058: PPUSH
50059: CALL_OW 273
50063: PUSH
50064: EMPTY
50065: LIST
50066: LIST
50067: PUSH
50068: EMPTY
50069: LIST
50070: LIST
50071: LIST
50072: LIST
50073: LIST
50074: LIST
50075: ST_TO_ADDR
// for i = tmp downto 1 do
50076: LD_ADDR_VAR 0 4
50080: PUSH
50081: DOUBLE
50082: LD_VAR 0 6
50086: INC
50087: ST_TO_ADDR
50088: LD_INT 1
50090: PUSH
50091: FOR_DOWNTO
50092: IFFALSE 50193
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
50094: LD_VAR 0 6
50098: PUSH
50099: LD_VAR 0 4
50103: ARRAY
50104: PUSH
50105: LD_INT 1
50107: ARRAY
50108: PPUSH
50109: LD_VAR 0 6
50113: PUSH
50114: LD_VAR 0 4
50118: ARRAY
50119: PUSH
50120: LD_INT 2
50122: ARRAY
50123: PPUSH
50124: CALL_OW 488
50128: NOT
50129: PUSH
50130: LD_VAR 0 6
50134: PUSH
50135: LD_VAR 0 4
50139: ARRAY
50140: PUSH
50141: LD_INT 1
50143: ARRAY
50144: PPUSH
50145: LD_VAR 0 6
50149: PUSH
50150: LD_VAR 0 4
50154: ARRAY
50155: PUSH
50156: LD_INT 2
50158: ARRAY
50159: PPUSH
50160: CALL_OW 428
50164: PUSH
50165: LD_INT 0
50167: NONEQUAL
50168: OR
50169: IFFALSE 50191
// tmp := Delete ( tmp , i ) ;
50171: LD_ADDR_VAR 0 6
50175: PUSH
50176: LD_VAR 0 6
50180: PPUSH
50181: LD_VAR 0 4
50185: PPUSH
50186: CALL_OW 3
50190: ST_TO_ADDR
50191: GO 50091
50193: POP
50194: POP
// j := GetClosestHex ( unit , tmp ) ;
50195: LD_ADDR_VAR 0 5
50199: PUSH
50200: LD_VAR 0 1
50204: PPUSH
50205: LD_VAR 0 6
50209: PPUSH
50210: CALL 49486 0 2
50214: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
50215: LD_VAR 0 1
50219: PPUSH
50220: LD_VAR 0 5
50224: PUSH
50225: LD_INT 1
50227: ARRAY
50228: PPUSH
50229: LD_VAR 0 5
50233: PUSH
50234: LD_INT 2
50236: ARRAY
50237: PPUSH
50238: CALL_OW 111
// end ;
50242: LD_VAR 0 3
50246: RET
// export function PrepareApemanSoldier ( ) ; begin
50247: LD_INT 0
50249: PPUSH
// uc_nation := 0 ;
50250: LD_ADDR_OWVAR 21
50254: PUSH
50255: LD_INT 0
50257: ST_TO_ADDR
// hc_sex := sex_male ;
50258: LD_ADDR_OWVAR 27
50262: PUSH
50263: LD_INT 1
50265: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
50266: LD_ADDR_OWVAR 28
50270: PUSH
50271: LD_INT 15
50273: ST_TO_ADDR
// hc_gallery :=  ;
50274: LD_ADDR_OWVAR 33
50278: PUSH
50279: LD_STRING 
50281: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
50282: LD_ADDR_OWVAR 31
50286: PUSH
50287: LD_INT 0
50289: PPUSH
50290: LD_INT 3
50292: PPUSH
50293: CALL_OW 12
50297: PUSH
50298: LD_INT 0
50300: PPUSH
50301: LD_INT 3
50303: PPUSH
50304: CALL_OW 12
50308: PUSH
50309: LD_INT 0
50311: PUSH
50312: LD_INT 0
50314: PUSH
50315: EMPTY
50316: LIST
50317: LIST
50318: LIST
50319: LIST
50320: ST_TO_ADDR
// end ;
50321: LD_VAR 0 1
50325: RET
// export function PrepareApemanEngineer ( ) ; begin
50326: LD_INT 0
50328: PPUSH
// uc_nation := 0 ;
50329: LD_ADDR_OWVAR 21
50333: PUSH
50334: LD_INT 0
50336: ST_TO_ADDR
// hc_sex := sex_male ;
50337: LD_ADDR_OWVAR 27
50341: PUSH
50342: LD_INT 1
50344: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
50345: LD_ADDR_OWVAR 28
50349: PUSH
50350: LD_INT 16
50352: ST_TO_ADDR
// hc_gallery :=  ;
50353: LD_ADDR_OWVAR 33
50357: PUSH
50358: LD_STRING 
50360: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
50361: LD_ADDR_OWVAR 31
50365: PUSH
50366: LD_INT 0
50368: PPUSH
50369: LD_INT 3
50371: PPUSH
50372: CALL_OW 12
50376: PUSH
50377: LD_INT 0
50379: PPUSH
50380: LD_INT 3
50382: PPUSH
50383: CALL_OW 12
50387: PUSH
50388: LD_INT 0
50390: PUSH
50391: LD_INT 0
50393: PUSH
50394: EMPTY
50395: LIST
50396: LIST
50397: LIST
50398: LIST
50399: ST_TO_ADDR
// end ;
50400: LD_VAR 0 1
50404: RET
// export function PrepareApeman ( agressivity ) ; begin
50405: LD_INT 0
50407: PPUSH
// uc_side := 0 ;
50408: LD_ADDR_OWVAR 20
50412: PUSH
50413: LD_INT 0
50415: ST_TO_ADDR
// uc_nation := 0 ;
50416: LD_ADDR_OWVAR 21
50420: PUSH
50421: LD_INT 0
50423: ST_TO_ADDR
// hc_sex := sex_male ;
50424: LD_ADDR_OWVAR 27
50428: PUSH
50429: LD_INT 1
50431: ST_TO_ADDR
// hc_class := class_apeman ;
50432: LD_ADDR_OWVAR 28
50436: PUSH
50437: LD_INT 12
50439: ST_TO_ADDR
// hc_gallery :=  ;
50440: LD_ADDR_OWVAR 33
50444: PUSH
50445: LD_STRING 
50447: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
50448: LD_ADDR_OWVAR 35
50452: PUSH
50453: LD_VAR 0 1
50457: NEG
50458: PPUSH
50459: LD_VAR 0 1
50463: PPUSH
50464: CALL_OW 12
50468: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
50469: LD_ADDR_OWVAR 31
50473: PUSH
50474: LD_INT 0
50476: PPUSH
50477: LD_INT 3
50479: PPUSH
50480: CALL_OW 12
50484: PUSH
50485: LD_INT 0
50487: PPUSH
50488: LD_INT 3
50490: PPUSH
50491: CALL_OW 12
50495: PUSH
50496: LD_INT 0
50498: PUSH
50499: LD_INT 0
50501: PUSH
50502: EMPTY
50503: LIST
50504: LIST
50505: LIST
50506: LIST
50507: ST_TO_ADDR
// end ;
50508: LD_VAR 0 2
50512: RET
// export function PrepareTiger ( agressivity ) ; begin
50513: LD_INT 0
50515: PPUSH
// uc_side := 0 ;
50516: LD_ADDR_OWVAR 20
50520: PUSH
50521: LD_INT 0
50523: ST_TO_ADDR
// uc_nation := 0 ;
50524: LD_ADDR_OWVAR 21
50528: PUSH
50529: LD_INT 0
50531: ST_TO_ADDR
// hc_class := class_tiger ;
50532: LD_ADDR_OWVAR 28
50536: PUSH
50537: LD_INT 14
50539: ST_TO_ADDR
// hc_gallery :=  ;
50540: LD_ADDR_OWVAR 33
50544: PUSH
50545: LD_STRING 
50547: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
50548: LD_ADDR_OWVAR 35
50552: PUSH
50553: LD_VAR 0 1
50557: NEG
50558: PPUSH
50559: LD_VAR 0 1
50563: PPUSH
50564: CALL_OW 12
50568: ST_TO_ADDR
// end ;
50569: LD_VAR 0 2
50573: RET
// export function PrepareEnchidna ( ) ; begin
50574: LD_INT 0
50576: PPUSH
// uc_side := 0 ;
50577: LD_ADDR_OWVAR 20
50581: PUSH
50582: LD_INT 0
50584: ST_TO_ADDR
// uc_nation := 0 ;
50585: LD_ADDR_OWVAR 21
50589: PUSH
50590: LD_INT 0
50592: ST_TO_ADDR
// hc_class := class_baggie ;
50593: LD_ADDR_OWVAR 28
50597: PUSH
50598: LD_INT 13
50600: ST_TO_ADDR
// hc_gallery :=  ;
50601: LD_ADDR_OWVAR 33
50605: PUSH
50606: LD_STRING 
50608: ST_TO_ADDR
// end ;
50609: LD_VAR 0 1
50613: RET
// export function PrepareFrog ( ) ; begin
50614: LD_INT 0
50616: PPUSH
// uc_side := 0 ;
50617: LD_ADDR_OWVAR 20
50621: PUSH
50622: LD_INT 0
50624: ST_TO_ADDR
// uc_nation := 0 ;
50625: LD_ADDR_OWVAR 21
50629: PUSH
50630: LD_INT 0
50632: ST_TO_ADDR
// hc_class := class_frog ;
50633: LD_ADDR_OWVAR 28
50637: PUSH
50638: LD_INT 19
50640: ST_TO_ADDR
// hc_gallery :=  ;
50641: LD_ADDR_OWVAR 33
50645: PUSH
50646: LD_STRING 
50648: ST_TO_ADDR
// end ;
50649: LD_VAR 0 1
50653: RET
// export function PrepareFish ( ) ; begin
50654: LD_INT 0
50656: PPUSH
// uc_side := 0 ;
50657: LD_ADDR_OWVAR 20
50661: PUSH
50662: LD_INT 0
50664: ST_TO_ADDR
// uc_nation := 0 ;
50665: LD_ADDR_OWVAR 21
50669: PUSH
50670: LD_INT 0
50672: ST_TO_ADDR
// hc_class := class_fish ;
50673: LD_ADDR_OWVAR 28
50677: PUSH
50678: LD_INT 20
50680: ST_TO_ADDR
// hc_gallery :=  ;
50681: LD_ADDR_OWVAR 33
50685: PUSH
50686: LD_STRING 
50688: ST_TO_ADDR
// end ;
50689: LD_VAR 0 1
50693: RET
// export function PrepareBird ( ) ; begin
50694: LD_INT 0
50696: PPUSH
// uc_side := 0 ;
50697: LD_ADDR_OWVAR 20
50701: PUSH
50702: LD_INT 0
50704: ST_TO_ADDR
// uc_nation := 0 ;
50705: LD_ADDR_OWVAR 21
50709: PUSH
50710: LD_INT 0
50712: ST_TO_ADDR
// hc_class := class_phororhacos ;
50713: LD_ADDR_OWVAR 28
50717: PUSH
50718: LD_INT 18
50720: ST_TO_ADDR
// hc_gallery :=  ;
50721: LD_ADDR_OWVAR 33
50725: PUSH
50726: LD_STRING 
50728: ST_TO_ADDR
// end ;
50729: LD_VAR 0 1
50733: RET
// export function PrepareHorse ( ) ; begin
50734: LD_INT 0
50736: PPUSH
// uc_side := 0 ;
50737: LD_ADDR_OWVAR 20
50741: PUSH
50742: LD_INT 0
50744: ST_TO_ADDR
// uc_nation := 0 ;
50745: LD_ADDR_OWVAR 21
50749: PUSH
50750: LD_INT 0
50752: ST_TO_ADDR
// hc_class := class_horse ;
50753: LD_ADDR_OWVAR 28
50757: PUSH
50758: LD_INT 21
50760: ST_TO_ADDR
// hc_gallery :=  ;
50761: LD_ADDR_OWVAR 33
50765: PUSH
50766: LD_STRING 
50768: ST_TO_ADDR
// end ;
50769: LD_VAR 0 1
50773: RET
// export function PrepareMastodont ( ) ; begin
50774: LD_INT 0
50776: PPUSH
// uc_side := 0 ;
50777: LD_ADDR_OWVAR 20
50781: PUSH
50782: LD_INT 0
50784: ST_TO_ADDR
// uc_nation := 0 ;
50785: LD_ADDR_OWVAR 21
50789: PUSH
50790: LD_INT 0
50792: ST_TO_ADDR
// vc_chassis := class_mastodont ;
50793: LD_ADDR_OWVAR 37
50797: PUSH
50798: LD_INT 31
50800: ST_TO_ADDR
// vc_control := control_rider ;
50801: LD_ADDR_OWVAR 38
50805: PUSH
50806: LD_INT 4
50808: ST_TO_ADDR
// end ;
50809: LD_VAR 0 1
50813: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
50814: LD_INT 0
50816: PPUSH
50817: PPUSH
50818: PPUSH
// uc_side = 0 ;
50819: LD_ADDR_OWVAR 20
50823: PUSH
50824: LD_INT 0
50826: ST_TO_ADDR
// uc_nation = 0 ;
50827: LD_ADDR_OWVAR 21
50831: PUSH
50832: LD_INT 0
50834: ST_TO_ADDR
// InitHc_All ( ) ;
50835: CALL_OW 584
// InitVc ;
50839: CALL_OW 20
// if mastodonts then
50843: LD_VAR 0 6
50847: IFFALSE 50914
// for i = 1 to mastodonts do
50849: LD_ADDR_VAR 0 11
50853: PUSH
50854: DOUBLE
50855: LD_INT 1
50857: DEC
50858: ST_TO_ADDR
50859: LD_VAR 0 6
50863: PUSH
50864: FOR_TO
50865: IFFALSE 50912
// begin vc_chassis := 31 ;
50867: LD_ADDR_OWVAR 37
50871: PUSH
50872: LD_INT 31
50874: ST_TO_ADDR
// vc_control := control_rider ;
50875: LD_ADDR_OWVAR 38
50879: PUSH
50880: LD_INT 4
50882: ST_TO_ADDR
// animal := CreateVehicle ;
50883: LD_ADDR_VAR 0 12
50887: PUSH
50888: CALL_OW 45
50892: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50893: LD_VAR 0 12
50897: PPUSH
50898: LD_VAR 0 8
50902: PPUSH
50903: LD_INT 0
50905: PPUSH
50906: CALL 53042 0 3
// end ;
50910: GO 50864
50912: POP
50913: POP
// if horses then
50914: LD_VAR 0 5
50918: IFFALSE 50985
// for i = 1 to horses do
50920: LD_ADDR_VAR 0 11
50924: PUSH
50925: DOUBLE
50926: LD_INT 1
50928: DEC
50929: ST_TO_ADDR
50930: LD_VAR 0 5
50934: PUSH
50935: FOR_TO
50936: IFFALSE 50983
// begin hc_class := 21 ;
50938: LD_ADDR_OWVAR 28
50942: PUSH
50943: LD_INT 21
50945: ST_TO_ADDR
// hc_gallery :=  ;
50946: LD_ADDR_OWVAR 33
50950: PUSH
50951: LD_STRING 
50953: ST_TO_ADDR
// animal := CreateHuman ;
50954: LD_ADDR_VAR 0 12
50958: PUSH
50959: CALL_OW 44
50963: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50964: LD_VAR 0 12
50968: PPUSH
50969: LD_VAR 0 8
50973: PPUSH
50974: LD_INT 0
50976: PPUSH
50977: CALL 53042 0 3
// end ;
50981: GO 50935
50983: POP
50984: POP
// if birds then
50985: LD_VAR 0 1
50989: IFFALSE 51056
// for i = 1 to birds do
50991: LD_ADDR_VAR 0 11
50995: PUSH
50996: DOUBLE
50997: LD_INT 1
50999: DEC
51000: ST_TO_ADDR
51001: LD_VAR 0 1
51005: PUSH
51006: FOR_TO
51007: IFFALSE 51054
// begin hc_class := 18 ;
51009: LD_ADDR_OWVAR 28
51013: PUSH
51014: LD_INT 18
51016: ST_TO_ADDR
// hc_gallery =  ;
51017: LD_ADDR_OWVAR 33
51021: PUSH
51022: LD_STRING 
51024: ST_TO_ADDR
// animal := CreateHuman ;
51025: LD_ADDR_VAR 0 12
51029: PUSH
51030: CALL_OW 44
51034: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51035: LD_VAR 0 12
51039: PPUSH
51040: LD_VAR 0 8
51044: PPUSH
51045: LD_INT 0
51047: PPUSH
51048: CALL 53042 0 3
// end ;
51052: GO 51006
51054: POP
51055: POP
// if tigers then
51056: LD_VAR 0 2
51060: IFFALSE 51144
// for i = 1 to tigers do
51062: LD_ADDR_VAR 0 11
51066: PUSH
51067: DOUBLE
51068: LD_INT 1
51070: DEC
51071: ST_TO_ADDR
51072: LD_VAR 0 2
51076: PUSH
51077: FOR_TO
51078: IFFALSE 51142
// begin hc_class = class_tiger ;
51080: LD_ADDR_OWVAR 28
51084: PUSH
51085: LD_INT 14
51087: ST_TO_ADDR
// hc_gallery =  ;
51088: LD_ADDR_OWVAR 33
51092: PUSH
51093: LD_STRING 
51095: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
51096: LD_ADDR_OWVAR 35
51100: PUSH
51101: LD_INT 7
51103: NEG
51104: PPUSH
51105: LD_INT 7
51107: PPUSH
51108: CALL_OW 12
51112: ST_TO_ADDR
// animal := CreateHuman ;
51113: LD_ADDR_VAR 0 12
51117: PUSH
51118: CALL_OW 44
51122: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51123: LD_VAR 0 12
51127: PPUSH
51128: LD_VAR 0 8
51132: PPUSH
51133: LD_INT 0
51135: PPUSH
51136: CALL 53042 0 3
// end ;
51140: GO 51077
51142: POP
51143: POP
// if apemans then
51144: LD_VAR 0 3
51148: IFFALSE 51271
// for i = 1 to apemans do
51150: LD_ADDR_VAR 0 11
51154: PUSH
51155: DOUBLE
51156: LD_INT 1
51158: DEC
51159: ST_TO_ADDR
51160: LD_VAR 0 3
51164: PUSH
51165: FOR_TO
51166: IFFALSE 51269
// begin hc_class = class_apeman ;
51168: LD_ADDR_OWVAR 28
51172: PUSH
51173: LD_INT 12
51175: ST_TO_ADDR
// hc_gallery =  ;
51176: LD_ADDR_OWVAR 33
51180: PUSH
51181: LD_STRING 
51183: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
51184: LD_ADDR_OWVAR 35
51188: PUSH
51189: LD_INT 2
51191: NEG
51192: PPUSH
51193: LD_INT 2
51195: PPUSH
51196: CALL_OW 12
51200: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
51201: LD_ADDR_OWVAR 31
51205: PUSH
51206: LD_INT 1
51208: PPUSH
51209: LD_INT 3
51211: PPUSH
51212: CALL_OW 12
51216: PUSH
51217: LD_INT 1
51219: PPUSH
51220: LD_INT 3
51222: PPUSH
51223: CALL_OW 12
51227: PUSH
51228: LD_INT 0
51230: PUSH
51231: LD_INT 0
51233: PUSH
51234: EMPTY
51235: LIST
51236: LIST
51237: LIST
51238: LIST
51239: ST_TO_ADDR
// animal := CreateHuman ;
51240: LD_ADDR_VAR 0 12
51244: PUSH
51245: CALL_OW 44
51249: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51250: LD_VAR 0 12
51254: PPUSH
51255: LD_VAR 0 8
51259: PPUSH
51260: LD_INT 0
51262: PPUSH
51263: CALL 53042 0 3
// end ;
51267: GO 51165
51269: POP
51270: POP
// if enchidnas then
51271: LD_VAR 0 4
51275: IFFALSE 51342
// for i = 1 to enchidnas do
51277: LD_ADDR_VAR 0 11
51281: PUSH
51282: DOUBLE
51283: LD_INT 1
51285: DEC
51286: ST_TO_ADDR
51287: LD_VAR 0 4
51291: PUSH
51292: FOR_TO
51293: IFFALSE 51340
// begin hc_class = 13 ;
51295: LD_ADDR_OWVAR 28
51299: PUSH
51300: LD_INT 13
51302: ST_TO_ADDR
// hc_gallery =  ;
51303: LD_ADDR_OWVAR 33
51307: PUSH
51308: LD_STRING 
51310: ST_TO_ADDR
// animal := CreateHuman ;
51311: LD_ADDR_VAR 0 12
51315: PUSH
51316: CALL_OW 44
51320: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51321: LD_VAR 0 12
51325: PPUSH
51326: LD_VAR 0 8
51330: PPUSH
51331: LD_INT 0
51333: PPUSH
51334: CALL 53042 0 3
// end ;
51338: GO 51292
51340: POP
51341: POP
// if fishes then
51342: LD_VAR 0 7
51346: IFFALSE 51413
// for i = 1 to fishes do
51348: LD_ADDR_VAR 0 11
51352: PUSH
51353: DOUBLE
51354: LD_INT 1
51356: DEC
51357: ST_TO_ADDR
51358: LD_VAR 0 7
51362: PUSH
51363: FOR_TO
51364: IFFALSE 51411
// begin hc_class = 20 ;
51366: LD_ADDR_OWVAR 28
51370: PUSH
51371: LD_INT 20
51373: ST_TO_ADDR
// hc_gallery =  ;
51374: LD_ADDR_OWVAR 33
51378: PUSH
51379: LD_STRING 
51381: ST_TO_ADDR
// animal := CreateHuman ;
51382: LD_ADDR_VAR 0 12
51386: PUSH
51387: CALL_OW 44
51391: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
51392: LD_VAR 0 12
51396: PPUSH
51397: LD_VAR 0 9
51401: PPUSH
51402: LD_INT 0
51404: PPUSH
51405: CALL 53042 0 3
// end ;
51409: GO 51363
51411: POP
51412: POP
// end ;
51413: LD_VAR 0 10
51417: RET
// export function WantHeal ( sci , unit ) ; begin
51418: LD_INT 0
51420: PPUSH
// if GetTaskList ( sci ) > 0 then
51421: LD_VAR 0 1
51425: PPUSH
51426: CALL_OW 437
51430: PUSH
51431: LD_INT 0
51433: GREATER
51434: IFFALSE 51504
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
51436: LD_VAR 0 1
51440: PPUSH
51441: CALL_OW 437
51445: PUSH
51446: LD_INT 1
51448: ARRAY
51449: PUSH
51450: LD_INT 1
51452: ARRAY
51453: PUSH
51454: LD_STRING l
51456: EQUAL
51457: PUSH
51458: LD_VAR 0 1
51462: PPUSH
51463: CALL_OW 437
51467: PUSH
51468: LD_INT 1
51470: ARRAY
51471: PUSH
51472: LD_INT 4
51474: ARRAY
51475: PUSH
51476: LD_VAR 0 2
51480: EQUAL
51481: AND
51482: IFFALSE 51494
// result := true else
51484: LD_ADDR_VAR 0 3
51488: PUSH
51489: LD_INT 1
51491: ST_TO_ADDR
51492: GO 51502
// result := false ;
51494: LD_ADDR_VAR 0 3
51498: PUSH
51499: LD_INT 0
51501: ST_TO_ADDR
// end else
51502: GO 51512
// result := false ;
51504: LD_ADDR_VAR 0 3
51508: PUSH
51509: LD_INT 0
51511: ST_TO_ADDR
// end ;
51512: LD_VAR 0 3
51516: RET
// export function HealTarget ( sci ) ; begin
51517: LD_INT 0
51519: PPUSH
// if not sci then
51520: LD_VAR 0 1
51524: NOT
51525: IFFALSE 51529
// exit ;
51527: GO 51594
// result := 0 ;
51529: LD_ADDR_VAR 0 2
51533: PUSH
51534: LD_INT 0
51536: ST_TO_ADDR
// if GetTaskList ( sci ) then
51537: LD_VAR 0 1
51541: PPUSH
51542: CALL_OW 437
51546: IFFALSE 51594
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
51548: LD_VAR 0 1
51552: PPUSH
51553: CALL_OW 437
51557: PUSH
51558: LD_INT 1
51560: ARRAY
51561: PUSH
51562: LD_INT 1
51564: ARRAY
51565: PUSH
51566: LD_STRING l
51568: EQUAL
51569: IFFALSE 51594
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
51571: LD_ADDR_VAR 0 2
51575: PUSH
51576: LD_VAR 0 1
51580: PPUSH
51581: CALL_OW 437
51585: PUSH
51586: LD_INT 1
51588: ARRAY
51589: PUSH
51590: LD_INT 4
51592: ARRAY
51593: ST_TO_ADDR
// end ;
51594: LD_VAR 0 2
51598: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
51599: LD_INT 0
51601: PPUSH
51602: PPUSH
51603: PPUSH
51604: PPUSH
// if not base_units then
51605: LD_VAR 0 1
51609: NOT
51610: IFFALSE 51614
// exit ;
51612: GO 51701
// result := false ;
51614: LD_ADDR_VAR 0 2
51618: PUSH
51619: LD_INT 0
51621: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
51622: LD_ADDR_VAR 0 5
51626: PUSH
51627: LD_VAR 0 1
51631: PPUSH
51632: LD_INT 21
51634: PUSH
51635: LD_INT 3
51637: PUSH
51638: EMPTY
51639: LIST
51640: LIST
51641: PPUSH
51642: CALL_OW 72
51646: ST_TO_ADDR
// if not tmp then
51647: LD_VAR 0 5
51651: NOT
51652: IFFALSE 51656
// exit ;
51654: GO 51701
// for i in tmp do
51656: LD_ADDR_VAR 0 3
51660: PUSH
51661: LD_VAR 0 5
51665: PUSH
51666: FOR_IN
51667: IFFALSE 51699
// begin result := EnemyInRange ( i , 22 ) ;
51669: LD_ADDR_VAR 0 2
51673: PUSH
51674: LD_VAR 0 3
51678: PPUSH
51679: LD_INT 22
51681: PPUSH
51682: CALL 49288 0 2
51686: ST_TO_ADDR
// if result then
51687: LD_VAR 0 2
51691: IFFALSE 51697
// exit ;
51693: POP
51694: POP
51695: GO 51701
// end ;
51697: GO 51666
51699: POP
51700: POP
// end ;
51701: LD_VAR 0 2
51705: RET
// export function FilterByTag ( units , tag ) ; begin
51706: LD_INT 0
51708: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
51709: LD_ADDR_VAR 0 3
51713: PUSH
51714: LD_VAR 0 1
51718: PPUSH
51719: LD_INT 120
51721: PUSH
51722: LD_VAR 0 2
51726: PUSH
51727: EMPTY
51728: LIST
51729: LIST
51730: PPUSH
51731: CALL_OW 72
51735: ST_TO_ADDR
// end ;
51736: LD_VAR 0 3
51740: RET
// export function IsDriver ( un ) ; begin
51741: LD_INT 0
51743: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
51744: LD_ADDR_VAR 0 2
51748: PUSH
51749: LD_VAR 0 1
51753: PUSH
51754: LD_INT 55
51756: PUSH
51757: EMPTY
51758: LIST
51759: PPUSH
51760: CALL_OW 69
51764: IN
51765: ST_TO_ADDR
// end ;
51766: LD_VAR 0 2
51770: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
51771: LD_INT 0
51773: PPUSH
51774: PPUSH
// list := [ ] ;
51775: LD_ADDR_VAR 0 5
51779: PUSH
51780: EMPTY
51781: ST_TO_ADDR
// case d of 0 :
51782: LD_VAR 0 3
51786: PUSH
51787: LD_INT 0
51789: DOUBLE
51790: EQUAL
51791: IFTRUE 51795
51793: GO 51928
51795: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
51796: LD_ADDR_VAR 0 5
51800: PUSH
51801: LD_VAR 0 1
51805: PUSH
51806: LD_INT 4
51808: MINUS
51809: PUSH
51810: LD_VAR 0 2
51814: PUSH
51815: LD_INT 4
51817: MINUS
51818: PUSH
51819: LD_INT 2
51821: PUSH
51822: EMPTY
51823: LIST
51824: LIST
51825: LIST
51826: PUSH
51827: LD_VAR 0 1
51831: PUSH
51832: LD_INT 3
51834: MINUS
51835: PUSH
51836: LD_VAR 0 2
51840: PUSH
51841: LD_INT 1
51843: PUSH
51844: EMPTY
51845: LIST
51846: LIST
51847: LIST
51848: PUSH
51849: LD_VAR 0 1
51853: PUSH
51854: LD_INT 4
51856: PLUS
51857: PUSH
51858: LD_VAR 0 2
51862: PUSH
51863: LD_INT 4
51865: PUSH
51866: EMPTY
51867: LIST
51868: LIST
51869: LIST
51870: PUSH
51871: LD_VAR 0 1
51875: PUSH
51876: LD_INT 3
51878: PLUS
51879: PUSH
51880: LD_VAR 0 2
51884: PUSH
51885: LD_INT 3
51887: PLUS
51888: PUSH
51889: LD_INT 5
51891: PUSH
51892: EMPTY
51893: LIST
51894: LIST
51895: LIST
51896: PUSH
51897: LD_VAR 0 1
51901: PUSH
51902: LD_VAR 0 2
51906: PUSH
51907: LD_INT 4
51909: PLUS
51910: PUSH
51911: LD_INT 0
51913: PUSH
51914: EMPTY
51915: LIST
51916: LIST
51917: LIST
51918: PUSH
51919: EMPTY
51920: LIST
51921: LIST
51922: LIST
51923: LIST
51924: LIST
51925: ST_TO_ADDR
// end ; 1 :
51926: GO 52626
51928: LD_INT 1
51930: DOUBLE
51931: EQUAL
51932: IFTRUE 51936
51934: GO 52069
51936: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
51937: LD_ADDR_VAR 0 5
51941: PUSH
51942: LD_VAR 0 1
51946: PUSH
51947: LD_VAR 0 2
51951: PUSH
51952: LD_INT 4
51954: MINUS
51955: PUSH
51956: LD_INT 3
51958: PUSH
51959: EMPTY
51960: LIST
51961: LIST
51962: LIST
51963: PUSH
51964: LD_VAR 0 1
51968: PUSH
51969: LD_INT 3
51971: MINUS
51972: PUSH
51973: LD_VAR 0 2
51977: PUSH
51978: LD_INT 3
51980: MINUS
51981: PUSH
51982: LD_INT 2
51984: PUSH
51985: EMPTY
51986: LIST
51987: LIST
51988: LIST
51989: PUSH
51990: LD_VAR 0 1
51994: PUSH
51995: LD_INT 4
51997: MINUS
51998: PUSH
51999: LD_VAR 0 2
52003: PUSH
52004: LD_INT 1
52006: PUSH
52007: EMPTY
52008: LIST
52009: LIST
52010: LIST
52011: PUSH
52012: LD_VAR 0 1
52016: PUSH
52017: LD_VAR 0 2
52021: PUSH
52022: LD_INT 3
52024: PLUS
52025: PUSH
52026: LD_INT 0
52028: PUSH
52029: EMPTY
52030: LIST
52031: LIST
52032: LIST
52033: PUSH
52034: LD_VAR 0 1
52038: PUSH
52039: LD_INT 4
52041: PLUS
52042: PUSH
52043: LD_VAR 0 2
52047: PUSH
52048: LD_INT 4
52050: PLUS
52051: PUSH
52052: LD_INT 5
52054: PUSH
52055: EMPTY
52056: LIST
52057: LIST
52058: LIST
52059: PUSH
52060: EMPTY
52061: LIST
52062: LIST
52063: LIST
52064: LIST
52065: LIST
52066: ST_TO_ADDR
// end ; 2 :
52067: GO 52626
52069: LD_INT 2
52071: DOUBLE
52072: EQUAL
52073: IFTRUE 52077
52075: GO 52206
52077: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
52078: LD_ADDR_VAR 0 5
52082: PUSH
52083: LD_VAR 0 1
52087: PUSH
52088: LD_VAR 0 2
52092: PUSH
52093: LD_INT 3
52095: MINUS
52096: PUSH
52097: LD_INT 3
52099: PUSH
52100: EMPTY
52101: LIST
52102: LIST
52103: LIST
52104: PUSH
52105: LD_VAR 0 1
52109: PUSH
52110: LD_INT 4
52112: PLUS
52113: PUSH
52114: LD_VAR 0 2
52118: PUSH
52119: LD_INT 4
52121: PUSH
52122: EMPTY
52123: LIST
52124: LIST
52125: LIST
52126: PUSH
52127: LD_VAR 0 1
52131: PUSH
52132: LD_VAR 0 2
52136: PUSH
52137: LD_INT 4
52139: PLUS
52140: PUSH
52141: LD_INT 0
52143: PUSH
52144: EMPTY
52145: LIST
52146: LIST
52147: LIST
52148: PUSH
52149: LD_VAR 0 1
52153: PUSH
52154: LD_INT 3
52156: MINUS
52157: PUSH
52158: LD_VAR 0 2
52162: PUSH
52163: LD_INT 1
52165: PUSH
52166: EMPTY
52167: LIST
52168: LIST
52169: LIST
52170: PUSH
52171: LD_VAR 0 1
52175: PUSH
52176: LD_INT 4
52178: MINUS
52179: PUSH
52180: LD_VAR 0 2
52184: PUSH
52185: LD_INT 4
52187: MINUS
52188: PUSH
52189: LD_INT 2
52191: PUSH
52192: EMPTY
52193: LIST
52194: LIST
52195: LIST
52196: PUSH
52197: EMPTY
52198: LIST
52199: LIST
52200: LIST
52201: LIST
52202: LIST
52203: ST_TO_ADDR
// end ; 3 :
52204: GO 52626
52206: LD_INT 3
52208: DOUBLE
52209: EQUAL
52210: IFTRUE 52214
52212: GO 52347
52214: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
52215: LD_ADDR_VAR 0 5
52219: PUSH
52220: LD_VAR 0 1
52224: PUSH
52225: LD_INT 3
52227: PLUS
52228: PUSH
52229: LD_VAR 0 2
52233: PUSH
52234: LD_INT 4
52236: PUSH
52237: EMPTY
52238: LIST
52239: LIST
52240: LIST
52241: PUSH
52242: LD_VAR 0 1
52246: PUSH
52247: LD_INT 4
52249: PLUS
52250: PUSH
52251: LD_VAR 0 2
52255: PUSH
52256: LD_INT 4
52258: PLUS
52259: PUSH
52260: LD_INT 5
52262: PUSH
52263: EMPTY
52264: LIST
52265: LIST
52266: LIST
52267: PUSH
52268: LD_VAR 0 1
52272: PUSH
52273: LD_INT 4
52275: MINUS
52276: PUSH
52277: LD_VAR 0 2
52281: PUSH
52282: LD_INT 1
52284: PUSH
52285: EMPTY
52286: LIST
52287: LIST
52288: LIST
52289: PUSH
52290: LD_VAR 0 1
52294: PUSH
52295: LD_VAR 0 2
52299: PUSH
52300: LD_INT 4
52302: MINUS
52303: PUSH
52304: LD_INT 3
52306: PUSH
52307: EMPTY
52308: LIST
52309: LIST
52310: LIST
52311: PUSH
52312: LD_VAR 0 1
52316: PUSH
52317: LD_INT 3
52319: MINUS
52320: PUSH
52321: LD_VAR 0 2
52325: PUSH
52326: LD_INT 3
52328: MINUS
52329: PUSH
52330: LD_INT 2
52332: PUSH
52333: EMPTY
52334: LIST
52335: LIST
52336: LIST
52337: PUSH
52338: EMPTY
52339: LIST
52340: LIST
52341: LIST
52342: LIST
52343: LIST
52344: ST_TO_ADDR
// end ; 4 :
52345: GO 52626
52347: LD_INT 4
52349: DOUBLE
52350: EQUAL
52351: IFTRUE 52355
52353: GO 52488
52355: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
52356: LD_ADDR_VAR 0 5
52360: PUSH
52361: LD_VAR 0 1
52365: PUSH
52366: LD_VAR 0 2
52370: PUSH
52371: LD_INT 4
52373: PLUS
52374: PUSH
52375: LD_INT 0
52377: PUSH
52378: EMPTY
52379: LIST
52380: LIST
52381: LIST
52382: PUSH
52383: LD_VAR 0 1
52387: PUSH
52388: LD_INT 3
52390: PLUS
52391: PUSH
52392: LD_VAR 0 2
52396: PUSH
52397: LD_INT 3
52399: PLUS
52400: PUSH
52401: LD_INT 5
52403: PUSH
52404: EMPTY
52405: LIST
52406: LIST
52407: LIST
52408: PUSH
52409: LD_VAR 0 1
52413: PUSH
52414: LD_INT 4
52416: PLUS
52417: PUSH
52418: LD_VAR 0 2
52422: PUSH
52423: LD_INT 4
52425: PUSH
52426: EMPTY
52427: LIST
52428: LIST
52429: LIST
52430: PUSH
52431: LD_VAR 0 1
52435: PUSH
52436: LD_VAR 0 2
52440: PUSH
52441: LD_INT 3
52443: MINUS
52444: PUSH
52445: LD_INT 3
52447: PUSH
52448: EMPTY
52449: LIST
52450: LIST
52451: LIST
52452: PUSH
52453: LD_VAR 0 1
52457: PUSH
52458: LD_INT 4
52460: MINUS
52461: PUSH
52462: LD_VAR 0 2
52466: PUSH
52467: LD_INT 4
52469: MINUS
52470: PUSH
52471: LD_INT 2
52473: PUSH
52474: EMPTY
52475: LIST
52476: LIST
52477: LIST
52478: PUSH
52479: EMPTY
52480: LIST
52481: LIST
52482: LIST
52483: LIST
52484: LIST
52485: ST_TO_ADDR
// end ; 5 :
52486: GO 52626
52488: LD_INT 5
52490: DOUBLE
52491: EQUAL
52492: IFTRUE 52496
52494: GO 52625
52496: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
52497: LD_ADDR_VAR 0 5
52501: PUSH
52502: LD_VAR 0 1
52506: PUSH
52507: LD_INT 4
52509: MINUS
52510: PUSH
52511: LD_VAR 0 2
52515: PUSH
52516: LD_INT 1
52518: PUSH
52519: EMPTY
52520: LIST
52521: LIST
52522: LIST
52523: PUSH
52524: LD_VAR 0 1
52528: PUSH
52529: LD_VAR 0 2
52533: PUSH
52534: LD_INT 4
52536: MINUS
52537: PUSH
52538: LD_INT 3
52540: PUSH
52541: EMPTY
52542: LIST
52543: LIST
52544: LIST
52545: PUSH
52546: LD_VAR 0 1
52550: PUSH
52551: LD_INT 4
52553: PLUS
52554: PUSH
52555: LD_VAR 0 2
52559: PUSH
52560: LD_INT 4
52562: PLUS
52563: PUSH
52564: LD_INT 5
52566: PUSH
52567: EMPTY
52568: LIST
52569: LIST
52570: LIST
52571: PUSH
52572: LD_VAR 0 1
52576: PUSH
52577: LD_INT 3
52579: PLUS
52580: PUSH
52581: LD_VAR 0 2
52585: PUSH
52586: LD_INT 4
52588: PUSH
52589: EMPTY
52590: LIST
52591: LIST
52592: LIST
52593: PUSH
52594: LD_VAR 0 1
52598: PUSH
52599: LD_VAR 0 2
52603: PUSH
52604: LD_INT 3
52606: PLUS
52607: PUSH
52608: LD_INT 0
52610: PUSH
52611: EMPTY
52612: LIST
52613: LIST
52614: LIST
52615: PUSH
52616: EMPTY
52617: LIST
52618: LIST
52619: LIST
52620: LIST
52621: LIST
52622: ST_TO_ADDR
// end ; end ;
52623: GO 52626
52625: POP
// result := list ;
52626: LD_ADDR_VAR 0 4
52630: PUSH
52631: LD_VAR 0 5
52635: ST_TO_ADDR
// end ;
52636: LD_VAR 0 4
52640: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
52641: LD_INT 0
52643: PPUSH
52644: PPUSH
52645: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
52646: LD_VAR 0 1
52650: NOT
52651: PUSH
52652: LD_VAR 0 2
52656: PUSH
52657: LD_INT 1
52659: PUSH
52660: LD_INT 2
52662: PUSH
52663: LD_INT 3
52665: PUSH
52666: LD_INT 4
52668: PUSH
52669: EMPTY
52670: LIST
52671: LIST
52672: LIST
52673: LIST
52674: IN
52675: NOT
52676: OR
52677: IFFALSE 52681
// exit ;
52679: GO 52764
// tmp := [ ] ;
52681: LD_ADDR_VAR 0 5
52685: PUSH
52686: EMPTY
52687: ST_TO_ADDR
// for i in units do
52688: LD_ADDR_VAR 0 4
52692: PUSH
52693: LD_VAR 0 1
52697: PUSH
52698: FOR_IN
52699: IFFALSE 52733
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
52701: LD_ADDR_VAR 0 5
52705: PUSH
52706: LD_VAR 0 5
52710: PPUSH
52711: LD_VAR 0 4
52715: PPUSH
52716: LD_VAR 0 2
52720: PPUSH
52721: CALL_OW 259
52725: PPUSH
52726: CALL 54137 0 2
52730: ST_TO_ADDR
52731: GO 52698
52733: POP
52734: POP
// if not tmp then
52735: LD_VAR 0 5
52739: NOT
52740: IFFALSE 52744
// exit ;
52742: GO 52764
// result := SortListByListDesc ( units , tmp ) ;
52744: LD_ADDR_VAR 0 3
52748: PUSH
52749: LD_VAR 0 1
52753: PPUSH
52754: LD_VAR 0 5
52758: PPUSH
52759: CALL_OW 77
52763: ST_TO_ADDR
// end ;
52764: LD_VAR 0 3
52768: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
52769: LD_INT 0
52771: PPUSH
52772: PPUSH
52773: PPUSH
// result := false ;
52774: LD_ADDR_VAR 0 3
52778: PUSH
52779: LD_INT 0
52781: ST_TO_ADDR
// if not building then
52782: LD_VAR 0 2
52786: NOT
52787: IFFALSE 52791
// exit ;
52789: GO 52929
// x := GetX ( building ) ;
52791: LD_ADDR_VAR 0 4
52795: PUSH
52796: LD_VAR 0 2
52800: PPUSH
52801: CALL_OW 250
52805: ST_TO_ADDR
// y := GetY ( building ) ;
52806: LD_ADDR_VAR 0 5
52810: PUSH
52811: LD_VAR 0 2
52815: PPUSH
52816: CALL_OW 251
52820: ST_TO_ADDR
// if not x or not y then
52821: LD_VAR 0 4
52825: NOT
52826: PUSH
52827: LD_VAR 0 5
52831: NOT
52832: OR
52833: IFFALSE 52837
// exit ;
52835: GO 52929
// if GetTaskList ( unit ) then
52837: LD_VAR 0 1
52841: PPUSH
52842: CALL_OW 437
52846: IFFALSE 52929
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52848: LD_STRING e
52850: PUSH
52851: LD_VAR 0 1
52855: PPUSH
52856: CALL_OW 437
52860: PUSH
52861: LD_INT 1
52863: ARRAY
52864: PUSH
52865: LD_INT 1
52867: ARRAY
52868: EQUAL
52869: PUSH
52870: LD_VAR 0 4
52874: PUSH
52875: LD_VAR 0 1
52879: PPUSH
52880: CALL_OW 437
52884: PUSH
52885: LD_INT 1
52887: ARRAY
52888: PUSH
52889: LD_INT 2
52891: ARRAY
52892: EQUAL
52893: AND
52894: PUSH
52895: LD_VAR 0 5
52899: PUSH
52900: LD_VAR 0 1
52904: PPUSH
52905: CALL_OW 437
52909: PUSH
52910: LD_INT 1
52912: ARRAY
52913: PUSH
52914: LD_INT 3
52916: ARRAY
52917: EQUAL
52918: AND
52919: IFFALSE 52929
// result := true end ;
52921: LD_ADDR_VAR 0 3
52925: PUSH
52926: LD_INT 1
52928: ST_TO_ADDR
// end ;
52929: LD_VAR 0 3
52933: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
52934: LD_INT 0
52936: PPUSH
// result := false ;
52937: LD_ADDR_VAR 0 4
52941: PUSH
52942: LD_INT 0
52944: ST_TO_ADDR
// if GetTaskList ( unit ) then
52945: LD_VAR 0 1
52949: PPUSH
52950: CALL_OW 437
52954: IFFALSE 53037
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52956: LD_STRING M
52958: PUSH
52959: LD_VAR 0 1
52963: PPUSH
52964: CALL_OW 437
52968: PUSH
52969: LD_INT 1
52971: ARRAY
52972: PUSH
52973: LD_INT 1
52975: ARRAY
52976: EQUAL
52977: PUSH
52978: LD_VAR 0 2
52982: PUSH
52983: LD_VAR 0 1
52987: PPUSH
52988: CALL_OW 437
52992: PUSH
52993: LD_INT 1
52995: ARRAY
52996: PUSH
52997: LD_INT 2
52999: ARRAY
53000: EQUAL
53001: AND
53002: PUSH
53003: LD_VAR 0 3
53007: PUSH
53008: LD_VAR 0 1
53012: PPUSH
53013: CALL_OW 437
53017: PUSH
53018: LD_INT 1
53020: ARRAY
53021: PUSH
53022: LD_INT 3
53024: ARRAY
53025: EQUAL
53026: AND
53027: IFFALSE 53037
// result := true ;
53029: LD_ADDR_VAR 0 4
53033: PUSH
53034: LD_INT 1
53036: ST_TO_ADDR
// end ; end ;
53037: LD_VAR 0 4
53041: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
53042: LD_INT 0
53044: PPUSH
53045: PPUSH
53046: PPUSH
53047: PPUSH
// if not unit or not area then
53048: LD_VAR 0 1
53052: NOT
53053: PUSH
53054: LD_VAR 0 2
53058: NOT
53059: OR
53060: IFFALSE 53064
// exit ;
53062: GO 53240
// tmp := AreaToList ( area , i ) ;
53064: LD_ADDR_VAR 0 6
53068: PUSH
53069: LD_VAR 0 2
53073: PPUSH
53074: LD_VAR 0 5
53078: PPUSH
53079: CALL_OW 517
53083: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
53084: LD_ADDR_VAR 0 5
53088: PUSH
53089: DOUBLE
53090: LD_INT 1
53092: DEC
53093: ST_TO_ADDR
53094: LD_VAR 0 6
53098: PUSH
53099: LD_INT 1
53101: ARRAY
53102: PUSH
53103: FOR_TO
53104: IFFALSE 53238
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
53106: LD_ADDR_VAR 0 7
53110: PUSH
53111: LD_VAR 0 6
53115: PUSH
53116: LD_INT 1
53118: ARRAY
53119: PUSH
53120: LD_VAR 0 5
53124: ARRAY
53125: PUSH
53126: LD_VAR 0 6
53130: PUSH
53131: LD_INT 2
53133: ARRAY
53134: PUSH
53135: LD_VAR 0 5
53139: ARRAY
53140: PUSH
53141: EMPTY
53142: LIST
53143: LIST
53144: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
53145: LD_INT 92
53147: PUSH
53148: LD_VAR 0 7
53152: PUSH
53153: LD_INT 1
53155: ARRAY
53156: PUSH
53157: LD_VAR 0 7
53161: PUSH
53162: LD_INT 2
53164: ARRAY
53165: PUSH
53166: LD_INT 2
53168: PUSH
53169: EMPTY
53170: LIST
53171: LIST
53172: LIST
53173: LIST
53174: PPUSH
53175: CALL_OW 69
53179: PUSH
53180: LD_INT 0
53182: EQUAL
53183: IFFALSE 53236
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
53185: LD_VAR 0 1
53189: PPUSH
53190: LD_VAR 0 7
53194: PUSH
53195: LD_INT 1
53197: ARRAY
53198: PPUSH
53199: LD_VAR 0 7
53203: PUSH
53204: LD_INT 2
53206: ARRAY
53207: PPUSH
53208: LD_VAR 0 3
53212: PPUSH
53213: CALL_OW 48
// result := IsPlaced ( unit ) ;
53217: LD_ADDR_VAR 0 4
53221: PUSH
53222: LD_VAR 0 1
53226: PPUSH
53227: CALL_OW 305
53231: ST_TO_ADDR
// exit ;
53232: POP
53233: POP
53234: GO 53240
// end ; end ;
53236: GO 53103
53238: POP
53239: POP
// end ;
53240: LD_VAR 0 4
53244: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
53245: LD_INT 0
53247: PPUSH
53248: PPUSH
53249: PPUSH
// if not side or side > 8 then
53250: LD_VAR 0 1
53254: NOT
53255: PUSH
53256: LD_VAR 0 1
53260: PUSH
53261: LD_INT 8
53263: GREATER
53264: OR
53265: IFFALSE 53269
// exit ;
53267: GO 53456
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
53269: LD_ADDR_VAR 0 4
53273: PUSH
53274: LD_INT 22
53276: PUSH
53277: LD_VAR 0 1
53281: PUSH
53282: EMPTY
53283: LIST
53284: LIST
53285: PUSH
53286: LD_INT 21
53288: PUSH
53289: LD_INT 3
53291: PUSH
53292: EMPTY
53293: LIST
53294: LIST
53295: PUSH
53296: EMPTY
53297: LIST
53298: LIST
53299: PPUSH
53300: CALL_OW 69
53304: ST_TO_ADDR
// if not tmp then
53305: LD_VAR 0 4
53309: NOT
53310: IFFALSE 53314
// exit ;
53312: GO 53456
// enable_addtolog := true ;
53314: LD_ADDR_OWVAR 81
53318: PUSH
53319: LD_INT 1
53321: ST_TO_ADDR
// AddToLog ( [ ) ;
53322: LD_STRING [
53324: PPUSH
53325: CALL_OW 561
// for i in tmp do
53329: LD_ADDR_VAR 0 3
53333: PUSH
53334: LD_VAR 0 4
53338: PUSH
53339: FOR_IN
53340: IFFALSE 53447
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
53342: LD_STRING [
53344: PUSH
53345: LD_VAR 0 3
53349: PPUSH
53350: CALL_OW 266
53354: STR
53355: PUSH
53356: LD_STRING , 
53358: STR
53359: PUSH
53360: LD_VAR 0 3
53364: PPUSH
53365: CALL_OW 250
53369: STR
53370: PUSH
53371: LD_STRING , 
53373: STR
53374: PUSH
53375: LD_VAR 0 3
53379: PPUSH
53380: CALL_OW 251
53384: STR
53385: PUSH
53386: LD_STRING , 
53388: STR
53389: PUSH
53390: LD_VAR 0 3
53394: PPUSH
53395: CALL_OW 254
53399: STR
53400: PUSH
53401: LD_STRING , 
53403: STR
53404: PUSH
53405: LD_VAR 0 3
53409: PPUSH
53410: LD_INT 1
53412: PPUSH
53413: CALL_OW 268
53417: STR
53418: PUSH
53419: LD_STRING , 
53421: STR
53422: PUSH
53423: LD_VAR 0 3
53427: PPUSH
53428: LD_INT 2
53430: PPUSH
53431: CALL_OW 268
53435: STR
53436: PUSH
53437: LD_STRING ],
53439: STR
53440: PPUSH
53441: CALL_OW 561
// end ;
53445: GO 53339
53447: POP
53448: POP
// AddToLog ( ]; ) ;
53449: LD_STRING ];
53451: PPUSH
53452: CALL_OW 561
// end ;
53456: LD_VAR 0 2
53460: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
53461: LD_INT 0
53463: PPUSH
53464: PPUSH
53465: PPUSH
53466: PPUSH
53467: PPUSH
// if not area or not rate or not max then
53468: LD_VAR 0 1
53472: NOT
53473: PUSH
53474: LD_VAR 0 2
53478: NOT
53479: OR
53480: PUSH
53481: LD_VAR 0 4
53485: NOT
53486: OR
53487: IFFALSE 53491
// exit ;
53489: GO 53680
// while 1 do
53491: LD_INT 1
53493: IFFALSE 53680
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
53495: LD_ADDR_VAR 0 9
53499: PUSH
53500: LD_VAR 0 1
53504: PPUSH
53505: LD_INT 1
53507: PPUSH
53508: CALL_OW 287
53512: PUSH
53513: LD_INT 10
53515: MUL
53516: ST_TO_ADDR
// r := rate / 10 ;
53517: LD_ADDR_VAR 0 7
53521: PUSH
53522: LD_VAR 0 2
53526: PUSH
53527: LD_INT 10
53529: DIVREAL
53530: ST_TO_ADDR
// time := 1 1$00 ;
53531: LD_ADDR_VAR 0 8
53535: PUSH
53536: LD_INT 2100
53538: ST_TO_ADDR
// if amount < min then
53539: LD_VAR 0 9
53543: PUSH
53544: LD_VAR 0 3
53548: LESS
53549: IFFALSE 53567
// r := r * 2 else
53551: LD_ADDR_VAR 0 7
53555: PUSH
53556: LD_VAR 0 7
53560: PUSH
53561: LD_INT 2
53563: MUL
53564: ST_TO_ADDR
53565: GO 53593
// if amount > max then
53567: LD_VAR 0 9
53571: PUSH
53572: LD_VAR 0 4
53576: GREATER
53577: IFFALSE 53593
// r := r / 2 ;
53579: LD_ADDR_VAR 0 7
53583: PUSH
53584: LD_VAR 0 7
53588: PUSH
53589: LD_INT 2
53591: DIVREAL
53592: ST_TO_ADDR
// time := time / r ;
53593: LD_ADDR_VAR 0 8
53597: PUSH
53598: LD_VAR 0 8
53602: PUSH
53603: LD_VAR 0 7
53607: DIVREAL
53608: ST_TO_ADDR
// if time < 0 then
53609: LD_VAR 0 8
53613: PUSH
53614: LD_INT 0
53616: LESS
53617: IFFALSE 53634
// time := time * - 1 ;
53619: LD_ADDR_VAR 0 8
53623: PUSH
53624: LD_VAR 0 8
53628: PUSH
53629: LD_INT 1
53631: NEG
53632: MUL
53633: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
53634: LD_VAR 0 8
53638: PUSH
53639: LD_INT 35
53641: PPUSH
53642: LD_INT 875
53644: PPUSH
53645: CALL_OW 12
53649: PLUS
53650: PPUSH
53651: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
53655: LD_INT 1
53657: PPUSH
53658: LD_INT 5
53660: PPUSH
53661: CALL_OW 12
53665: PPUSH
53666: LD_VAR 0 1
53670: PPUSH
53671: LD_INT 1
53673: PPUSH
53674: CALL_OW 55
// end ;
53678: GO 53491
// end ;
53680: LD_VAR 0 5
53684: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
53685: LD_INT 0
53687: PPUSH
53688: PPUSH
53689: PPUSH
53690: PPUSH
53691: PPUSH
53692: PPUSH
53693: PPUSH
53694: PPUSH
// if not turrets or not factories then
53695: LD_VAR 0 1
53699: NOT
53700: PUSH
53701: LD_VAR 0 2
53705: NOT
53706: OR
53707: IFFALSE 53711
// exit ;
53709: GO 54018
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
53711: LD_ADDR_VAR 0 10
53715: PUSH
53716: LD_INT 5
53718: PUSH
53719: LD_INT 6
53721: PUSH
53722: EMPTY
53723: LIST
53724: LIST
53725: PUSH
53726: LD_INT 2
53728: PUSH
53729: LD_INT 4
53731: PUSH
53732: EMPTY
53733: LIST
53734: LIST
53735: PUSH
53736: LD_INT 3
53738: PUSH
53739: LD_INT 5
53741: PUSH
53742: EMPTY
53743: LIST
53744: LIST
53745: PUSH
53746: EMPTY
53747: LIST
53748: LIST
53749: LIST
53750: PUSH
53751: LD_INT 24
53753: PUSH
53754: LD_INT 25
53756: PUSH
53757: EMPTY
53758: LIST
53759: LIST
53760: PUSH
53761: LD_INT 23
53763: PUSH
53764: LD_INT 27
53766: PUSH
53767: EMPTY
53768: LIST
53769: LIST
53770: PUSH
53771: EMPTY
53772: LIST
53773: LIST
53774: PUSH
53775: LD_INT 42
53777: PUSH
53778: LD_INT 43
53780: PUSH
53781: EMPTY
53782: LIST
53783: LIST
53784: PUSH
53785: LD_INT 44
53787: PUSH
53788: LD_INT 46
53790: PUSH
53791: EMPTY
53792: LIST
53793: LIST
53794: PUSH
53795: LD_INT 45
53797: PUSH
53798: LD_INT 47
53800: PUSH
53801: EMPTY
53802: LIST
53803: LIST
53804: PUSH
53805: EMPTY
53806: LIST
53807: LIST
53808: LIST
53809: PUSH
53810: EMPTY
53811: LIST
53812: LIST
53813: LIST
53814: ST_TO_ADDR
// result := [ ] ;
53815: LD_ADDR_VAR 0 3
53819: PUSH
53820: EMPTY
53821: ST_TO_ADDR
// for i in turrets do
53822: LD_ADDR_VAR 0 4
53826: PUSH
53827: LD_VAR 0 1
53831: PUSH
53832: FOR_IN
53833: IFFALSE 54016
// begin nat := GetNation ( i ) ;
53835: LD_ADDR_VAR 0 7
53839: PUSH
53840: LD_VAR 0 4
53844: PPUSH
53845: CALL_OW 248
53849: ST_TO_ADDR
// weapon := 0 ;
53850: LD_ADDR_VAR 0 8
53854: PUSH
53855: LD_INT 0
53857: ST_TO_ADDR
// if not nat then
53858: LD_VAR 0 7
53862: NOT
53863: IFFALSE 53867
// continue ;
53865: GO 53832
// for j in list [ nat ] do
53867: LD_ADDR_VAR 0 5
53871: PUSH
53872: LD_VAR 0 10
53876: PUSH
53877: LD_VAR 0 7
53881: ARRAY
53882: PUSH
53883: FOR_IN
53884: IFFALSE 53925
// if GetBWeapon ( i ) = j [ 1 ] then
53886: LD_VAR 0 4
53890: PPUSH
53891: CALL_OW 269
53895: PUSH
53896: LD_VAR 0 5
53900: PUSH
53901: LD_INT 1
53903: ARRAY
53904: EQUAL
53905: IFFALSE 53923
// begin weapon := j [ 2 ] ;
53907: LD_ADDR_VAR 0 8
53911: PUSH
53912: LD_VAR 0 5
53916: PUSH
53917: LD_INT 2
53919: ARRAY
53920: ST_TO_ADDR
// break ;
53921: GO 53925
// end ;
53923: GO 53883
53925: POP
53926: POP
// if not weapon then
53927: LD_VAR 0 8
53931: NOT
53932: IFFALSE 53936
// continue ;
53934: GO 53832
// for k in factories do
53936: LD_ADDR_VAR 0 6
53940: PUSH
53941: LD_VAR 0 2
53945: PUSH
53946: FOR_IN
53947: IFFALSE 54012
// begin weapons := AvailableWeaponList ( k ) ;
53949: LD_ADDR_VAR 0 9
53953: PUSH
53954: LD_VAR 0 6
53958: PPUSH
53959: CALL_OW 478
53963: ST_TO_ADDR
// if not weapons then
53964: LD_VAR 0 9
53968: NOT
53969: IFFALSE 53973
// continue ;
53971: GO 53946
// if weapon in weapons then
53973: LD_VAR 0 8
53977: PUSH
53978: LD_VAR 0 9
53982: IN
53983: IFFALSE 54010
// begin result := [ i , weapon ] ;
53985: LD_ADDR_VAR 0 3
53989: PUSH
53990: LD_VAR 0 4
53994: PUSH
53995: LD_VAR 0 8
53999: PUSH
54000: EMPTY
54001: LIST
54002: LIST
54003: ST_TO_ADDR
// exit ;
54004: POP
54005: POP
54006: POP
54007: POP
54008: GO 54018
// end ; end ;
54010: GO 53946
54012: POP
54013: POP
// end ;
54014: GO 53832
54016: POP
54017: POP
// end ;
54018: LD_VAR 0 3
54022: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
54023: LD_INT 0
54025: PPUSH
// if not side or side > 8 then
54026: LD_VAR 0 3
54030: NOT
54031: PUSH
54032: LD_VAR 0 3
54036: PUSH
54037: LD_INT 8
54039: GREATER
54040: OR
54041: IFFALSE 54045
// exit ;
54043: GO 54104
// if not range then
54045: LD_VAR 0 4
54049: NOT
54050: IFFALSE 54061
// range := - 12 ;
54052: LD_ADDR_VAR 0 4
54056: PUSH
54057: LD_INT 12
54059: NEG
54060: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
54061: LD_VAR 0 1
54065: PPUSH
54066: LD_VAR 0 2
54070: PPUSH
54071: LD_VAR 0 3
54075: PPUSH
54076: LD_VAR 0 4
54080: PPUSH
54081: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
54085: LD_VAR 0 1
54089: PPUSH
54090: LD_VAR 0 2
54094: PPUSH
54095: LD_VAR 0 3
54099: PPUSH
54100: CALL_OW 331
// end ;
54104: LD_VAR 0 5
54108: RET
// export function Video ( mode ) ; begin
54109: LD_INT 0
54111: PPUSH
// ingame_video = mode ;
54112: LD_ADDR_OWVAR 52
54116: PUSH
54117: LD_VAR 0 1
54121: ST_TO_ADDR
// interface_hidden = mode ;
54122: LD_ADDR_OWVAR 54
54126: PUSH
54127: LD_VAR 0 1
54131: ST_TO_ADDR
// end ;
54132: LD_VAR 0 2
54136: RET
// export function Join ( array , element ) ; begin
54137: LD_INT 0
54139: PPUSH
// result := Replace ( array , array + 1 , element ) ;
54140: LD_ADDR_VAR 0 3
54144: PUSH
54145: LD_VAR 0 1
54149: PPUSH
54150: LD_VAR 0 1
54154: PUSH
54155: LD_INT 1
54157: PLUS
54158: PPUSH
54159: LD_VAR 0 2
54163: PPUSH
54164: CALL_OW 1
54168: ST_TO_ADDR
// end ;
54169: LD_VAR 0 3
54173: RET
// export function JoinUnion ( array , element ) ; begin
54174: LD_INT 0
54176: PPUSH
// result := array union element ;
54177: LD_ADDR_VAR 0 3
54181: PUSH
54182: LD_VAR 0 1
54186: PUSH
54187: LD_VAR 0 2
54191: UNION
54192: ST_TO_ADDR
// end ;
54193: LD_VAR 0 3
54197: RET
// export function GetBehemoths ( side ) ; begin
54198: LD_INT 0
54200: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
54201: LD_ADDR_VAR 0 2
54205: PUSH
54206: LD_INT 22
54208: PUSH
54209: LD_VAR 0 1
54213: PUSH
54214: EMPTY
54215: LIST
54216: LIST
54217: PUSH
54218: LD_INT 31
54220: PUSH
54221: LD_INT 25
54223: PUSH
54224: EMPTY
54225: LIST
54226: LIST
54227: PUSH
54228: EMPTY
54229: LIST
54230: LIST
54231: PPUSH
54232: CALL_OW 69
54236: ST_TO_ADDR
// end ;
54237: LD_VAR 0 2
54241: RET
// export function Shuffle ( array ) ; var i , index ; begin
54242: LD_INT 0
54244: PPUSH
54245: PPUSH
54246: PPUSH
// result := [ ] ;
54247: LD_ADDR_VAR 0 2
54251: PUSH
54252: EMPTY
54253: ST_TO_ADDR
// if not array then
54254: LD_VAR 0 1
54258: NOT
54259: IFFALSE 54263
// exit ;
54261: GO 54362
// Randomize ;
54263: CALL_OW 10
// for i = array downto 1 do
54267: LD_ADDR_VAR 0 3
54271: PUSH
54272: DOUBLE
54273: LD_VAR 0 1
54277: INC
54278: ST_TO_ADDR
54279: LD_INT 1
54281: PUSH
54282: FOR_DOWNTO
54283: IFFALSE 54360
// begin index := rand ( 1 , array ) ;
54285: LD_ADDR_VAR 0 4
54289: PUSH
54290: LD_INT 1
54292: PPUSH
54293: LD_VAR 0 1
54297: PPUSH
54298: CALL_OW 12
54302: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
54303: LD_ADDR_VAR 0 2
54307: PUSH
54308: LD_VAR 0 2
54312: PPUSH
54313: LD_VAR 0 2
54317: PUSH
54318: LD_INT 1
54320: PLUS
54321: PPUSH
54322: LD_VAR 0 1
54326: PUSH
54327: LD_VAR 0 4
54331: ARRAY
54332: PPUSH
54333: CALL_OW 2
54337: ST_TO_ADDR
// array := Delete ( array , index ) ;
54338: LD_ADDR_VAR 0 1
54342: PUSH
54343: LD_VAR 0 1
54347: PPUSH
54348: LD_VAR 0 4
54352: PPUSH
54353: CALL_OW 3
54357: ST_TO_ADDR
// end ;
54358: GO 54282
54360: POP
54361: POP
// end ;
54362: LD_VAR 0 2
54366: RET
// export function GetBaseMaterials ( base ) ; begin
54367: LD_INT 0
54369: PPUSH
// result := [ 0 , 0 , 0 ] ;
54370: LD_ADDR_VAR 0 2
54374: PUSH
54375: LD_INT 0
54377: PUSH
54378: LD_INT 0
54380: PUSH
54381: LD_INT 0
54383: PUSH
54384: EMPTY
54385: LIST
54386: LIST
54387: LIST
54388: ST_TO_ADDR
// if not base then
54389: LD_VAR 0 1
54393: NOT
54394: IFFALSE 54398
// exit ;
54396: GO 54447
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
54398: LD_ADDR_VAR 0 2
54402: PUSH
54403: LD_VAR 0 1
54407: PPUSH
54408: LD_INT 1
54410: PPUSH
54411: CALL_OW 275
54415: PUSH
54416: LD_VAR 0 1
54420: PPUSH
54421: LD_INT 2
54423: PPUSH
54424: CALL_OW 275
54428: PUSH
54429: LD_VAR 0 1
54433: PPUSH
54434: LD_INT 3
54436: PPUSH
54437: CALL_OW 275
54441: PUSH
54442: EMPTY
54443: LIST
54444: LIST
54445: LIST
54446: ST_TO_ADDR
// end ;
54447: LD_VAR 0 2
54451: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
54452: LD_INT 0
54454: PPUSH
54455: PPUSH
// result := array ;
54456: LD_ADDR_VAR 0 3
54460: PUSH
54461: LD_VAR 0 1
54465: ST_TO_ADDR
// if size >= result then
54466: LD_VAR 0 2
54470: PUSH
54471: LD_VAR 0 3
54475: GREATEREQUAL
54476: IFFALSE 54480
// exit ;
54478: GO 54530
// if size then
54480: LD_VAR 0 2
54484: IFFALSE 54530
// for i := array downto size do
54486: LD_ADDR_VAR 0 4
54490: PUSH
54491: DOUBLE
54492: LD_VAR 0 1
54496: INC
54497: ST_TO_ADDR
54498: LD_VAR 0 2
54502: PUSH
54503: FOR_DOWNTO
54504: IFFALSE 54528
// result := Delete ( result , result ) ;
54506: LD_ADDR_VAR 0 3
54510: PUSH
54511: LD_VAR 0 3
54515: PPUSH
54516: LD_VAR 0 3
54520: PPUSH
54521: CALL_OW 3
54525: ST_TO_ADDR
54526: GO 54503
54528: POP
54529: POP
// end ;
54530: LD_VAR 0 3
54534: RET
// export function ComExit ( unit ) ; var tmp ; begin
54535: LD_INT 0
54537: PPUSH
54538: PPUSH
// if not IsInUnit ( unit ) then
54539: LD_VAR 0 1
54543: PPUSH
54544: CALL_OW 310
54548: NOT
54549: IFFALSE 54553
// exit ;
54551: GO 54613
// tmp := IsInUnit ( unit ) ;
54553: LD_ADDR_VAR 0 3
54557: PUSH
54558: LD_VAR 0 1
54562: PPUSH
54563: CALL_OW 310
54567: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
54568: LD_VAR 0 3
54572: PPUSH
54573: CALL_OW 247
54577: PUSH
54578: LD_INT 2
54580: EQUAL
54581: IFFALSE 54594
// ComExitVehicle ( unit ) else
54583: LD_VAR 0 1
54587: PPUSH
54588: CALL_OW 121
54592: GO 54603
// ComExitBuilding ( unit ) ;
54594: LD_VAR 0 1
54598: PPUSH
54599: CALL_OW 122
// result := tmp ;
54603: LD_ADDR_VAR 0 2
54607: PUSH
54608: LD_VAR 0 3
54612: ST_TO_ADDR
// end ;
54613: LD_VAR 0 2
54617: RET
// export function ComExitAll ( units ) ; var i ; begin
54618: LD_INT 0
54620: PPUSH
54621: PPUSH
// if not units then
54622: LD_VAR 0 1
54626: NOT
54627: IFFALSE 54631
// exit ;
54629: GO 54657
// for i in units do
54631: LD_ADDR_VAR 0 3
54635: PUSH
54636: LD_VAR 0 1
54640: PUSH
54641: FOR_IN
54642: IFFALSE 54655
// ComExit ( i ) ;
54644: LD_VAR 0 3
54648: PPUSH
54649: CALL 54535 0 1
54653: GO 54641
54655: POP
54656: POP
// end ;
54657: LD_VAR 0 2
54661: RET
// export function ResetHc ; begin
54662: LD_INT 0
54664: PPUSH
// InitHc ;
54665: CALL_OW 19
// hc_importance := 0 ;
54669: LD_ADDR_OWVAR 32
54673: PUSH
54674: LD_INT 0
54676: ST_TO_ADDR
// end ;
54677: LD_VAR 0 1
54681: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
54682: LD_INT 0
54684: PPUSH
54685: PPUSH
54686: PPUSH
// _x := ( x1 + x2 ) div 2 ;
54687: LD_ADDR_VAR 0 6
54691: PUSH
54692: LD_VAR 0 1
54696: PUSH
54697: LD_VAR 0 3
54701: PLUS
54702: PUSH
54703: LD_INT 2
54705: DIV
54706: ST_TO_ADDR
// if _x < 0 then
54707: LD_VAR 0 6
54711: PUSH
54712: LD_INT 0
54714: LESS
54715: IFFALSE 54732
// _x := _x * - 1 ;
54717: LD_ADDR_VAR 0 6
54721: PUSH
54722: LD_VAR 0 6
54726: PUSH
54727: LD_INT 1
54729: NEG
54730: MUL
54731: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
54732: LD_ADDR_VAR 0 7
54736: PUSH
54737: LD_VAR 0 2
54741: PUSH
54742: LD_VAR 0 4
54746: PLUS
54747: PUSH
54748: LD_INT 2
54750: DIV
54751: ST_TO_ADDR
// if _y < 0 then
54752: LD_VAR 0 7
54756: PUSH
54757: LD_INT 0
54759: LESS
54760: IFFALSE 54777
// _y := _y * - 1 ;
54762: LD_ADDR_VAR 0 7
54766: PUSH
54767: LD_VAR 0 7
54771: PUSH
54772: LD_INT 1
54774: NEG
54775: MUL
54776: ST_TO_ADDR
// result := [ _x , _y ] ;
54777: LD_ADDR_VAR 0 5
54781: PUSH
54782: LD_VAR 0 6
54786: PUSH
54787: LD_VAR 0 7
54791: PUSH
54792: EMPTY
54793: LIST
54794: LIST
54795: ST_TO_ADDR
// end ;
54796: LD_VAR 0 5
54800: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
54801: LD_INT 0
54803: PPUSH
54804: PPUSH
54805: PPUSH
54806: PPUSH
// task := GetTaskList ( unit ) ;
54807: LD_ADDR_VAR 0 7
54811: PUSH
54812: LD_VAR 0 1
54816: PPUSH
54817: CALL_OW 437
54821: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
54822: LD_VAR 0 7
54826: NOT
54827: PUSH
54828: LD_VAR 0 1
54832: PPUSH
54833: LD_VAR 0 2
54837: PPUSH
54838: CALL_OW 308
54842: NOT
54843: AND
54844: IFFALSE 54848
// exit ;
54846: GO 54966
// if IsInArea ( unit , area ) then
54848: LD_VAR 0 1
54852: PPUSH
54853: LD_VAR 0 2
54857: PPUSH
54858: CALL_OW 308
54862: IFFALSE 54880
// begin ComMoveToArea ( unit , goAway ) ;
54864: LD_VAR 0 1
54868: PPUSH
54869: LD_VAR 0 3
54873: PPUSH
54874: CALL_OW 113
// exit ;
54878: GO 54966
// end ; if task [ 1 ] [ 1 ] <> M then
54880: LD_VAR 0 7
54884: PUSH
54885: LD_INT 1
54887: ARRAY
54888: PUSH
54889: LD_INT 1
54891: ARRAY
54892: PUSH
54893: LD_STRING M
54895: NONEQUAL
54896: IFFALSE 54900
// exit ;
54898: GO 54966
// x := task [ 1 ] [ 2 ] ;
54900: LD_ADDR_VAR 0 5
54904: PUSH
54905: LD_VAR 0 7
54909: PUSH
54910: LD_INT 1
54912: ARRAY
54913: PUSH
54914: LD_INT 2
54916: ARRAY
54917: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
54918: LD_ADDR_VAR 0 6
54922: PUSH
54923: LD_VAR 0 7
54927: PUSH
54928: LD_INT 1
54930: ARRAY
54931: PUSH
54932: LD_INT 3
54934: ARRAY
54935: ST_TO_ADDR
// if InArea ( x , y , area ) then
54936: LD_VAR 0 5
54940: PPUSH
54941: LD_VAR 0 6
54945: PPUSH
54946: LD_VAR 0 2
54950: PPUSH
54951: CALL_OW 309
54955: IFFALSE 54966
// ComStop ( unit ) ;
54957: LD_VAR 0 1
54961: PPUSH
54962: CALL_OW 141
// end ;
54966: LD_VAR 0 4
54970: RET
// export function Abs ( value ) ; begin
54971: LD_INT 0
54973: PPUSH
// result := value ;
54974: LD_ADDR_VAR 0 2
54978: PUSH
54979: LD_VAR 0 1
54983: ST_TO_ADDR
// if value < 0 then
54984: LD_VAR 0 1
54988: PUSH
54989: LD_INT 0
54991: LESS
54992: IFFALSE 55009
// result := value * - 1 ;
54994: LD_ADDR_VAR 0 2
54998: PUSH
54999: LD_VAR 0 1
55003: PUSH
55004: LD_INT 1
55006: NEG
55007: MUL
55008: ST_TO_ADDR
// end ;
55009: LD_VAR 0 2
55013: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
55014: LD_INT 0
55016: PPUSH
55017: PPUSH
55018: PPUSH
55019: PPUSH
55020: PPUSH
55021: PPUSH
55022: PPUSH
55023: PPUSH
// if not unit or not building then
55024: LD_VAR 0 1
55028: NOT
55029: PUSH
55030: LD_VAR 0 2
55034: NOT
55035: OR
55036: IFFALSE 55040
// exit ;
55038: GO 55266
// x := GetX ( building ) ;
55040: LD_ADDR_VAR 0 4
55044: PUSH
55045: LD_VAR 0 2
55049: PPUSH
55050: CALL_OW 250
55054: ST_TO_ADDR
// y := GetY ( building ) ;
55055: LD_ADDR_VAR 0 6
55059: PUSH
55060: LD_VAR 0 2
55064: PPUSH
55065: CALL_OW 251
55069: ST_TO_ADDR
// d := GetDir ( building ) ;
55070: LD_ADDR_VAR 0 8
55074: PUSH
55075: LD_VAR 0 2
55079: PPUSH
55080: CALL_OW 254
55084: ST_TO_ADDR
// r := 4 ;
55085: LD_ADDR_VAR 0 9
55089: PUSH
55090: LD_INT 4
55092: ST_TO_ADDR
// for i := 1 to 5 do
55093: LD_ADDR_VAR 0 10
55097: PUSH
55098: DOUBLE
55099: LD_INT 1
55101: DEC
55102: ST_TO_ADDR
55103: LD_INT 5
55105: PUSH
55106: FOR_TO
55107: IFFALSE 55264
// begin _x := ShiftX ( x , d , r + i ) ;
55109: LD_ADDR_VAR 0 5
55113: PUSH
55114: LD_VAR 0 4
55118: PPUSH
55119: LD_VAR 0 8
55123: PPUSH
55124: LD_VAR 0 9
55128: PUSH
55129: LD_VAR 0 10
55133: PLUS
55134: PPUSH
55135: CALL_OW 272
55139: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
55140: LD_ADDR_VAR 0 7
55144: PUSH
55145: LD_VAR 0 6
55149: PPUSH
55150: LD_VAR 0 8
55154: PPUSH
55155: LD_VAR 0 9
55159: PUSH
55160: LD_VAR 0 10
55164: PLUS
55165: PPUSH
55166: CALL_OW 273
55170: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
55171: LD_VAR 0 5
55175: PPUSH
55176: LD_VAR 0 7
55180: PPUSH
55181: CALL_OW 488
55185: PUSH
55186: LD_VAR 0 5
55190: PPUSH
55191: LD_VAR 0 7
55195: PPUSH
55196: CALL_OW 428
55200: PPUSH
55201: CALL_OW 247
55205: PUSH
55206: LD_INT 3
55208: PUSH
55209: LD_INT 2
55211: PUSH
55212: EMPTY
55213: LIST
55214: LIST
55215: IN
55216: NOT
55217: AND
55218: IFFALSE 55262
// begin ComMoveXY ( unit , _x , _y ) ;
55220: LD_VAR 0 1
55224: PPUSH
55225: LD_VAR 0 5
55229: PPUSH
55230: LD_VAR 0 7
55234: PPUSH
55235: CALL_OW 111
// result := [ _x , _y ] ;
55239: LD_ADDR_VAR 0 3
55243: PUSH
55244: LD_VAR 0 5
55248: PUSH
55249: LD_VAR 0 7
55253: PUSH
55254: EMPTY
55255: LIST
55256: LIST
55257: ST_TO_ADDR
// exit ;
55258: POP
55259: POP
55260: GO 55266
// end ; end ;
55262: GO 55106
55264: POP
55265: POP
// end ;
55266: LD_VAR 0 3
55270: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
55271: LD_INT 0
55273: PPUSH
55274: PPUSH
55275: PPUSH
// result := 0 ;
55276: LD_ADDR_VAR 0 3
55280: PUSH
55281: LD_INT 0
55283: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
55284: LD_VAR 0 1
55288: PUSH
55289: LD_INT 0
55291: LESS
55292: PUSH
55293: LD_VAR 0 1
55297: PUSH
55298: LD_INT 8
55300: GREATER
55301: OR
55302: PUSH
55303: LD_VAR 0 2
55307: PUSH
55308: LD_INT 0
55310: LESS
55311: OR
55312: PUSH
55313: LD_VAR 0 2
55317: PUSH
55318: LD_INT 8
55320: GREATER
55321: OR
55322: IFFALSE 55326
// exit ;
55324: GO 55401
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
55326: LD_ADDR_VAR 0 4
55330: PUSH
55331: LD_INT 22
55333: PUSH
55334: LD_VAR 0 2
55338: PUSH
55339: EMPTY
55340: LIST
55341: LIST
55342: PPUSH
55343: CALL_OW 69
55347: PUSH
55348: FOR_IN
55349: IFFALSE 55399
// begin un := UnitShoot ( i ) ;
55351: LD_ADDR_VAR 0 5
55355: PUSH
55356: LD_VAR 0 4
55360: PPUSH
55361: CALL_OW 504
55365: ST_TO_ADDR
// if GetSide ( un ) = side1 then
55366: LD_VAR 0 5
55370: PPUSH
55371: CALL_OW 255
55375: PUSH
55376: LD_VAR 0 1
55380: EQUAL
55381: IFFALSE 55397
// begin result := un ;
55383: LD_ADDR_VAR 0 3
55387: PUSH
55388: LD_VAR 0 5
55392: ST_TO_ADDR
// exit ;
55393: POP
55394: POP
55395: GO 55401
// end ; end ;
55397: GO 55348
55399: POP
55400: POP
// end ;
55401: LD_VAR 0 3
55405: RET
// export function GetCargoBay ( units ) ; begin
55406: LD_INT 0
55408: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
55409: LD_ADDR_VAR 0 2
55413: PUSH
55414: LD_VAR 0 1
55418: PPUSH
55419: LD_INT 2
55421: PUSH
55422: LD_INT 34
55424: PUSH
55425: LD_INT 12
55427: PUSH
55428: EMPTY
55429: LIST
55430: LIST
55431: PUSH
55432: LD_INT 34
55434: PUSH
55435: LD_INT 51
55437: PUSH
55438: EMPTY
55439: LIST
55440: LIST
55441: PUSH
55442: LD_INT 34
55444: PUSH
55445: LD_INT 32
55447: PUSH
55448: EMPTY
55449: LIST
55450: LIST
55451: PUSH
55452: LD_INT 34
55454: PUSH
55455: LD_INT 89
55457: PUSH
55458: EMPTY
55459: LIST
55460: LIST
55461: PUSH
55462: EMPTY
55463: LIST
55464: LIST
55465: LIST
55466: LIST
55467: LIST
55468: PPUSH
55469: CALL_OW 72
55473: ST_TO_ADDR
// end ;
55474: LD_VAR 0 2
55478: RET
// export function Negate ( value ) ; begin
55479: LD_INT 0
55481: PPUSH
// result := not value ;
55482: LD_ADDR_VAR 0 2
55486: PUSH
55487: LD_VAR 0 1
55491: NOT
55492: ST_TO_ADDR
// end ;
55493: LD_VAR 0 2
55497: RET
// export function Inc ( value ) ; begin
55498: LD_INT 0
55500: PPUSH
// result := value + 1 ;
55501: LD_ADDR_VAR 0 2
55505: PUSH
55506: LD_VAR 0 1
55510: PUSH
55511: LD_INT 1
55513: PLUS
55514: ST_TO_ADDR
// end ;
55515: LD_VAR 0 2
55519: RET
// export function Dec ( value ) ; begin
55520: LD_INT 0
55522: PPUSH
// result := value - 1 ;
55523: LD_ADDR_VAR 0 2
55527: PUSH
55528: LD_VAR 0 1
55532: PUSH
55533: LD_INT 1
55535: MINUS
55536: ST_TO_ADDR
// end ;
55537: LD_VAR 0 2
55541: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
55542: LD_INT 0
55544: PPUSH
55545: PPUSH
55546: PPUSH
55547: PPUSH
55548: PPUSH
55549: PPUSH
55550: PPUSH
55551: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
55552: LD_VAR 0 1
55556: PPUSH
55557: LD_VAR 0 2
55561: PPUSH
55562: CALL_OW 488
55566: NOT
55567: PUSH
55568: LD_VAR 0 3
55572: PPUSH
55573: LD_VAR 0 4
55577: PPUSH
55578: CALL_OW 488
55582: NOT
55583: OR
55584: IFFALSE 55597
// begin result := - 1 ;
55586: LD_ADDR_VAR 0 5
55590: PUSH
55591: LD_INT 1
55593: NEG
55594: ST_TO_ADDR
// exit ;
55595: GO 55832
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
55597: LD_ADDR_VAR 0 12
55601: PUSH
55602: LD_VAR 0 1
55606: PPUSH
55607: LD_VAR 0 2
55611: PPUSH
55612: LD_VAR 0 3
55616: PPUSH
55617: LD_VAR 0 4
55621: PPUSH
55622: CALL 54682 0 4
55626: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
55627: LD_ADDR_VAR 0 11
55631: PUSH
55632: LD_VAR 0 1
55636: PPUSH
55637: LD_VAR 0 2
55641: PPUSH
55642: LD_VAR 0 12
55646: PUSH
55647: LD_INT 1
55649: ARRAY
55650: PPUSH
55651: LD_VAR 0 12
55655: PUSH
55656: LD_INT 2
55658: ARRAY
55659: PPUSH
55660: CALL_OW 298
55664: ST_TO_ADDR
// distance := 9999 ;
55665: LD_ADDR_VAR 0 10
55669: PUSH
55670: LD_INT 9999
55672: ST_TO_ADDR
// for i := 0 to 5 do
55673: LD_ADDR_VAR 0 6
55677: PUSH
55678: DOUBLE
55679: LD_INT 0
55681: DEC
55682: ST_TO_ADDR
55683: LD_INT 5
55685: PUSH
55686: FOR_TO
55687: IFFALSE 55830
// begin _x := ShiftX ( x1 , i , centerDist ) ;
55689: LD_ADDR_VAR 0 7
55693: PUSH
55694: LD_VAR 0 1
55698: PPUSH
55699: LD_VAR 0 6
55703: PPUSH
55704: LD_VAR 0 11
55708: PPUSH
55709: CALL_OW 272
55713: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
55714: LD_ADDR_VAR 0 8
55718: PUSH
55719: LD_VAR 0 2
55723: PPUSH
55724: LD_VAR 0 6
55728: PPUSH
55729: LD_VAR 0 11
55733: PPUSH
55734: CALL_OW 273
55738: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
55739: LD_VAR 0 7
55743: PPUSH
55744: LD_VAR 0 8
55748: PPUSH
55749: CALL_OW 488
55753: NOT
55754: IFFALSE 55758
// continue ;
55756: GO 55686
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
55758: LD_ADDR_VAR 0 9
55762: PUSH
55763: LD_VAR 0 12
55767: PUSH
55768: LD_INT 1
55770: ARRAY
55771: PPUSH
55772: LD_VAR 0 12
55776: PUSH
55777: LD_INT 2
55779: ARRAY
55780: PPUSH
55781: LD_VAR 0 7
55785: PPUSH
55786: LD_VAR 0 8
55790: PPUSH
55791: CALL_OW 298
55795: ST_TO_ADDR
// if tmp < distance then
55796: LD_VAR 0 9
55800: PUSH
55801: LD_VAR 0 10
55805: LESS
55806: IFFALSE 55828
// begin result := i ;
55808: LD_ADDR_VAR 0 5
55812: PUSH
55813: LD_VAR 0 6
55817: ST_TO_ADDR
// distance := tmp ;
55818: LD_ADDR_VAR 0 10
55822: PUSH
55823: LD_VAR 0 9
55827: ST_TO_ADDR
// end ; end ;
55828: GO 55686
55830: POP
55831: POP
// end ;
55832: LD_VAR 0 5
55836: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
55837: LD_INT 0
55839: PPUSH
55840: PPUSH
// if not driver or not IsInUnit ( driver ) then
55841: LD_VAR 0 1
55845: NOT
55846: PUSH
55847: LD_VAR 0 1
55851: PPUSH
55852: CALL_OW 310
55856: NOT
55857: OR
55858: IFFALSE 55862
// exit ;
55860: GO 55952
// vehicle := IsInUnit ( driver ) ;
55862: LD_ADDR_VAR 0 3
55866: PUSH
55867: LD_VAR 0 1
55871: PPUSH
55872: CALL_OW 310
55876: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
55877: LD_VAR 0 1
55881: PPUSH
55882: LD_STRING \
55884: PUSH
55885: LD_INT 0
55887: PUSH
55888: LD_INT 0
55890: PUSH
55891: LD_INT 0
55893: PUSH
55894: LD_INT 0
55896: PUSH
55897: LD_INT 0
55899: PUSH
55900: LD_INT 0
55902: PUSH
55903: EMPTY
55904: LIST
55905: LIST
55906: LIST
55907: LIST
55908: LIST
55909: LIST
55910: LIST
55911: PUSH
55912: LD_STRING E
55914: PUSH
55915: LD_INT 0
55917: PUSH
55918: LD_INT 0
55920: PUSH
55921: LD_VAR 0 3
55925: PUSH
55926: LD_INT 0
55928: PUSH
55929: LD_INT 0
55931: PUSH
55932: LD_INT 0
55934: PUSH
55935: EMPTY
55936: LIST
55937: LIST
55938: LIST
55939: LIST
55940: LIST
55941: LIST
55942: LIST
55943: PUSH
55944: EMPTY
55945: LIST
55946: LIST
55947: PPUSH
55948: CALL_OW 446
// end ;
55952: LD_VAR 0 2
55956: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
55957: LD_INT 0
55959: PPUSH
55960: PPUSH
// if not driver or not IsInUnit ( driver ) then
55961: LD_VAR 0 1
55965: NOT
55966: PUSH
55967: LD_VAR 0 1
55971: PPUSH
55972: CALL_OW 310
55976: NOT
55977: OR
55978: IFFALSE 55982
// exit ;
55980: GO 56072
// vehicle := IsInUnit ( driver ) ;
55982: LD_ADDR_VAR 0 3
55986: PUSH
55987: LD_VAR 0 1
55991: PPUSH
55992: CALL_OW 310
55996: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
55997: LD_VAR 0 1
56001: PPUSH
56002: LD_STRING \
56004: PUSH
56005: LD_INT 0
56007: PUSH
56008: LD_INT 0
56010: PUSH
56011: LD_INT 0
56013: PUSH
56014: LD_INT 0
56016: PUSH
56017: LD_INT 0
56019: PUSH
56020: LD_INT 0
56022: PUSH
56023: EMPTY
56024: LIST
56025: LIST
56026: LIST
56027: LIST
56028: LIST
56029: LIST
56030: LIST
56031: PUSH
56032: LD_STRING E
56034: PUSH
56035: LD_INT 0
56037: PUSH
56038: LD_INT 0
56040: PUSH
56041: LD_VAR 0 3
56045: PUSH
56046: LD_INT 0
56048: PUSH
56049: LD_INT 0
56051: PUSH
56052: LD_INT 0
56054: PUSH
56055: EMPTY
56056: LIST
56057: LIST
56058: LIST
56059: LIST
56060: LIST
56061: LIST
56062: LIST
56063: PUSH
56064: EMPTY
56065: LIST
56066: LIST
56067: PPUSH
56068: CALL_OW 447
// end ;
56072: LD_VAR 0 2
56076: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
56077: LD_INT 0
56079: PPUSH
56080: PPUSH
56081: PPUSH
// tmp := [ ] ;
56082: LD_ADDR_VAR 0 5
56086: PUSH
56087: EMPTY
56088: ST_TO_ADDR
// for i in units do
56089: LD_ADDR_VAR 0 4
56093: PUSH
56094: LD_VAR 0 1
56098: PUSH
56099: FOR_IN
56100: IFFALSE 56138
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
56102: LD_ADDR_VAR 0 5
56106: PUSH
56107: LD_VAR 0 5
56111: PPUSH
56112: LD_VAR 0 5
56116: PUSH
56117: LD_INT 1
56119: PLUS
56120: PPUSH
56121: LD_VAR 0 4
56125: PPUSH
56126: CALL_OW 256
56130: PPUSH
56131: CALL_OW 2
56135: ST_TO_ADDR
56136: GO 56099
56138: POP
56139: POP
// if not tmp then
56140: LD_VAR 0 5
56144: NOT
56145: IFFALSE 56149
// exit ;
56147: GO 56197
// if asc then
56149: LD_VAR 0 2
56153: IFFALSE 56177
// result := SortListByListAsc ( units , tmp ) else
56155: LD_ADDR_VAR 0 3
56159: PUSH
56160: LD_VAR 0 1
56164: PPUSH
56165: LD_VAR 0 5
56169: PPUSH
56170: CALL_OW 76
56174: ST_TO_ADDR
56175: GO 56197
// result := SortListByListDesc ( units , tmp ) ;
56177: LD_ADDR_VAR 0 3
56181: PUSH
56182: LD_VAR 0 1
56186: PPUSH
56187: LD_VAR 0 5
56191: PPUSH
56192: CALL_OW 77
56196: ST_TO_ADDR
// end ;
56197: LD_VAR 0 3
56201: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
56202: LD_INT 0
56204: PPUSH
56205: PPUSH
// task := GetTaskList ( mech ) ;
56206: LD_ADDR_VAR 0 4
56210: PUSH
56211: LD_VAR 0 1
56215: PPUSH
56216: CALL_OW 437
56220: ST_TO_ADDR
// if not task then
56221: LD_VAR 0 4
56225: NOT
56226: IFFALSE 56230
// exit ;
56228: GO 56272
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
56230: LD_ADDR_VAR 0 3
56234: PUSH
56235: LD_VAR 0 4
56239: PUSH
56240: LD_INT 1
56242: ARRAY
56243: PUSH
56244: LD_INT 1
56246: ARRAY
56247: PUSH
56248: LD_STRING r
56250: EQUAL
56251: PUSH
56252: LD_VAR 0 4
56256: PUSH
56257: LD_INT 1
56259: ARRAY
56260: PUSH
56261: LD_INT 4
56263: ARRAY
56264: PUSH
56265: LD_VAR 0 2
56269: EQUAL
56270: AND
56271: ST_TO_ADDR
// end ;
56272: LD_VAR 0 3
56276: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
56277: LD_INT 0
56279: PPUSH
// SetDir ( unit , d ) ;
56280: LD_VAR 0 1
56284: PPUSH
56285: LD_VAR 0 4
56289: PPUSH
56290: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
56294: LD_VAR 0 1
56298: PPUSH
56299: LD_VAR 0 2
56303: PPUSH
56304: LD_VAR 0 3
56308: PPUSH
56309: LD_VAR 0 5
56313: PPUSH
56314: CALL_OW 48
// end ;
56318: LD_VAR 0 6
56322: RET
// export function ToNaturalNumber ( number ) ; begin
56323: LD_INT 0
56325: PPUSH
// result := number div 1 ;
56326: LD_ADDR_VAR 0 2
56330: PUSH
56331: LD_VAR 0 1
56335: PUSH
56336: LD_INT 1
56338: DIV
56339: ST_TO_ADDR
// if number < 0 then
56340: LD_VAR 0 1
56344: PUSH
56345: LD_INT 0
56347: LESS
56348: IFFALSE 56358
// result := 0 ;
56350: LD_ADDR_VAR 0 2
56354: PUSH
56355: LD_INT 0
56357: ST_TO_ADDR
// end ;
56358: LD_VAR 0 2
56362: RET
// export function SortByClass ( units , class ) ; var un ; begin
56363: LD_INT 0
56365: PPUSH
56366: PPUSH
// if not units or not class then
56367: LD_VAR 0 1
56371: NOT
56372: PUSH
56373: LD_VAR 0 2
56377: NOT
56378: OR
56379: IFFALSE 56383
// exit ;
56381: GO 56478
// result := [ ] ;
56383: LD_ADDR_VAR 0 3
56387: PUSH
56388: EMPTY
56389: ST_TO_ADDR
// for un in units do
56390: LD_ADDR_VAR 0 4
56394: PUSH
56395: LD_VAR 0 1
56399: PUSH
56400: FOR_IN
56401: IFFALSE 56476
// if GetClass ( un ) = class then
56403: LD_VAR 0 4
56407: PPUSH
56408: CALL_OW 257
56412: PUSH
56413: LD_VAR 0 2
56417: EQUAL
56418: IFFALSE 56445
// result := Insert ( result , 1 , un ) else
56420: LD_ADDR_VAR 0 3
56424: PUSH
56425: LD_VAR 0 3
56429: PPUSH
56430: LD_INT 1
56432: PPUSH
56433: LD_VAR 0 4
56437: PPUSH
56438: CALL_OW 2
56442: ST_TO_ADDR
56443: GO 56474
// result := Replace ( result , result + 1 , un ) ;
56445: LD_ADDR_VAR 0 3
56449: PUSH
56450: LD_VAR 0 3
56454: PPUSH
56455: LD_VAR 0 3
56459: PUSH
56460: LD_INT 1
56462: PLUS
56463: PPUSH
56464: LD_VAR 0 4
56468: PPUSH
56469: CALL_OW 1
56473: ST_TO_ADDR
56474: GO 56400
56476: POP
56477: POP
// end ;
56478: LD_VAR 0 3
56482: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
56483: LD_INT 0
56485: PPUSH
56486: PPUSH
56487: PPUSH
56488: PPUSH
56489: PPUSH
56490: PPUSH
56491: PPUSH
// result := [ ] ;
56492: LD_ADDR_VAR 0 4
56496: PUSH
56497: EMPTY
56498: ST_TO_ADDR
// if x - r < 0 then
56499: LD_VAR 0 1
56503: PUSH
56504: LD_VAR 0 3
56508: MINUS
56509: PUSH
56510: LD_INT 0
56512: LESS
56513: IFFALSE 56525
// min_x := 0 else
56515: LD_ADDR_VAR 0 8
56519: PUSH
56520: LD_INT 0
56522: ST_TO_ADDR
56523: GO 56541
// min_x := x - r ;
56525: LD_ADDR_VAR 0 8
56529: PUSH
56530: LD_VAR 0 1
56534: PUSH
56535: LD_VAR 0 3
56539: MINUS
56540: ST_TO_ADDR
// if y - r < 0 then
56541: LD_VAR 0 2
56545: PUSH
56546: LD_VAR 0 3
56550: MINUS
56551: PUSH
56552: LD_INT 0
56554: LESS
56555: IFFALSE 56567
// min_y := 0 else
56557: LD_ADDR_VAR 0 7
56561: PUSH
56562: LD_INT 0
56564: ST_TO_ADDR
56565: GO 56583
// min_y := y - r ;
56567: LD_ADDR_VAR 0 7
56571: PUSH
56572: LD_VAR 0 2
56576: PUSH
56577: LD_VAR 0 3
56581: MINUS
56582: ST_TO_ADDR
// max_x := x + r ;
56583: LD_ADDR_VAR 0 9
56587: PUSH
56588: LD_VAR 0 1
56592: PUSH
56593: LD_VAR 0 3
56597: PLUS
56598: ST_TO_ADDR
// max_y := y + r ;
56599: LD_ADDR_VAR 0 10
56603: PUSH
56604: LD_VAR 0 2
56608: PUSH
56609: LD_VAR 0 3
56613: PLUS
56614: ST_TO_ADDR
// for _x = min_x to max_x do
56615: LD_ADDR_VAR 0 5
56619: PUSH
56620: DOUBLE
56621: LD_VAR 0 8
56625: DEC
56626: ST_TO_ADDR
56627: LD_VAR 0 9
56631: PUSH
56632: FOR_TO
56633: IFFALSE 56734
// for _y = min_y to max_y do
56635: LD_ADDR_VAR 0 6
56639: PUSH
56640: DOUBLE
56641: LD_VAR 0 7
56645: DEC
56646: ST_TO_ADDR
56647: LD_VAR 0 10
56651: PUSH
56652: FOR_TO
56653: IFFALSE 56730
// begin if not ValidHex ( _x , _y ) then
56655: LD_VAR 0 5
56659: PPUSH
56660: LD_VAR 0 6
56664: PPUSH
56665: CALL_OW 488
56669: NOT
56670: IFFALSE 56674
// continue ;
56672: GO 56652
// if GetResourceTypeXY ( _x , _y ) then
56674: LD_VAR 0 5
56678: PPUSH
56679: LD_VAR 0 6
56683: PPUSH
56684: CALL_OW 283
56688: IFFALSE 56728
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
56690: LD_ADDR_VAR 0 4
56694: PUSH
56695: LD_VAR 0 4
56699: PPUSH
56700: LD_VAR 0 4
56704: PUSH
56705: LD_INT 1
56707: PLUS
56708: PPUSH
56709: LD_VAR 0 5
56713: PUSH
56714: LD_VAR 0 6
56718: PUSH
56719: EMPTY
56720: LIST
56721: LIST
56722: PPUSH
56723: CALL_OW 1
56727: ST_TO_ADDR
// end ;
56728: GO 56652
56730: POP
56731: POP
56732: GO 56632
56734: POP
56735: POP
// end ;
56736: LD_VAR 0 4
56740: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
56741: LD_INT 0
56743: PPUSH
56744: PPUSH
56745: PPUSH
56746: PPUSH
56747: PPUSH
56748: PPUSH
56749: PPUSH
56750: PPUSH
// if not units then
56751: LD_VAR 0 1
56755: NOT
56756: IFFALSE 56760
// exit ;
56758: GO 57284
// result := UnitFilter ( units , [ f_ok ] ) ;
56760: LD_ADDR_VAR 0 3
56764: PUSH
56765: LD_VAR 0 1
56769: PPUSH
56770: LD_INT 50
56772: PUSH
56773: EMPTY
56774: LIST
56775: PPUSH
56776: CALL_OW 72
56780: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
56781: LD_ADDR_VAR 0 8
56785: PUSH
56786: LD_VAR 0 1
56790: PUSH
56791: LD_INT 1
56793: ARRAY
56794: PPUSH
56795: CALL_OW 255
56799: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
56800: LD_ADDR_VAR 0 10
56804: PUSH
56805: LD_INT 29
56807: PUSH
56808: LD_INT 91
56810: PUSH
56811: LD_INT 49
56813: PUSH
56814: EMPTY
56815: LIST
56816: LIST
56817: LIST
56818: ST_TO_ADDR
// if not result then
56819: LD_VAR 0 3
56823: NOT
56824: IFFALSE 56828
// exit ;
56826: GO 57284
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
56828: LD_ADDR_VAR 0 5
56832: PUSH
56833: LD_INT 81
56835: PUSH
56836: LD_VAR 0 8
56840: PUSH
56841: EMPTY
56842: LIST
56843: LIST
56844: PPUSH
56845: CALL_OW 69
56849: ST_TO_ADDR
// for i in result do
56850: LD_ADDR_VAR 0 4
56854: PUSH
56855: LD_VAR 0 3
56859: PUSH
56860: FOR_IN
56861: IFFALSE 57282
// begin tag := GetTag ( i ) + 1 ;
56863: LD_ADDR_VAR 0 9
56867: PUSH
56868: LD_VAR 0 4
56872: PPUSH
56873: CALL_OW 110
56877: PUSH
56878: LD_INT 1
56880: PLUS
56881: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
56882: LD_ADDR_VAR 0 7
56886: PUSH
56887: LD_VAR 0 4
56891: PPUSH
56892: CALL_OW 250
56896: PPUSH
56897: LD_VAR 0 4
56901: PPUSH
56902: CALL_OW 251
56906: PPUSH
56907: LD_INT 6
56909: PPUSH
56910: CALL 56483 0 3
56914: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
56915: LD_VAR 0 4
56919: PPUSH
56920: CALL_OW 247
56924: PUSH
56925: LD_INT 2
56927: EQUAL
56928: PUSH
56929: LD_VAR 0 7
56933: AND
56934: PUSH
56935: LD_VAR 0 4
56939: PPUSH
56940: CALL_OW 264
56944: PUSH
56945: LD_VAR 0 10
56949: IN
56950: NOT
56951: AND
56952: IFFALSE 56991
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
56954: LD_VAR 0 4
56958: PPUSH
56959: LD_VAR 0 7
56963: PUSH
56964: LD_INT 1
56966: ARRAY
56967: PUSH
56968: LD_INT 1
56970: ARRAY
56971: PPUSH
56972: LD_VAR 0 7
56976: PUSH
56977: LD_INT 1
56979: ARRAY
56980: PUSH
56981: LD_INT 2
56983: ARRAY
56984: PPUSH
56985: CALL_OW 116
56989: GO 57280
// if path > tag then
56991: LD_VAR 0 2
56995: PUSH
56996: LD_VAR 0 9
57000: GREATER
57001: IFFALSE 57209
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
57003: LD_ADDR_VAR 0 6
57007: PUSH
57008: LD_VAR 0 5
57012: PPUSH
57013: LD_INT 91
57015: PUSH
57016: LD_VAR 0 4
57020: PUSH
57021: LD_INT 8
57023: PUSH
57024: EMPTY
57025: LIST
57026: LIST
57027: LIST
57028: PPUSH
57029: CALL_OW 72
57033: ST_TO_ADDR
// if nearEnemy then
57034: LD_VAR 0 6
57038: IFFALSE 57107
// begin if GetWeapon ( i ) = ru_time_lapser then
57040: LD_VAR 0 4
57044: PPUSH
57045: CALL_OW 264
57049: PUSH
57050: LD_INT 49
57052: EQUAL
57053: IFFALSE 57081
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
57055: LD_VAR 0 4
57059: PPUSH
57060: LD_VAR 0 6
57064: PPUSH
57065: LD_VAR 0 4
57069: PPUSH
57070: CALL_OW 74
57074: PPUSH
57075: CALL_OW 112
57079: GO 57105
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
57081: LD_VAR 0 4
57085: PPUSH
57086: LD_VAR 0 6
57090: PPUSH
57091: LD_VAR 0 4
57095: PPUSH
57096: CALL_OW 74
57100: PPUSH
57101: CALL 58209 0 2
// end else
57105: GO 57207
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
57107: LD_VAR 0 4
57111: PPUSH
57112: LD_VAR 0 2
57116: PUSH
57117: LD_VAR 0 9
57121: ARRAY
57122: PUSH
57123: LD_INT 1
57125: ARRAY
57126: PPUSH
57127: LD_VAR 0 2
57131: PUSH
57132: LD_VAR 0 9
57136: ARRAY
57137: PUSH
57138: LD_INT 2
57140: ARRAY
57141: PPUSH
57142: CALL_OW 297
57146: PUSH
57147: LD_INT 6
57149: GREATER
57150: IFFALSE 57193
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
57152: LD_VAR 0 4
57156: PPUSH
57157: LD_VAR 0 2
57161: PUSH
57162: LD_VAR 0 9
57166: ARRAY
57167: PUSH
57168: LD_INT 1
57170: ARRAY
57171: PPUSH
57172: LD_VAR 0 2
57176: PUSH
57177: LD_VAR 0 9
57181: ARRAY
57182: PUSH
57183: LD_INT 2
57185: ARRAY
57186: PPUSH
57187: CALL_OW 114
57191: GO 57207
// SetTag ( i , tag ) ;
57193: LD_VAR 0 4
57197: PPUSH
57198: LD_VAR 0 9
57202: PPUSH
57203: CALL_OW 109
// end else
57207: GO 57280
// if enemy then
57209: LD_VAR 0 5
57213: IFFALSE 57280
// begin if GetWeapon ( i ) = ru_time_lapser then
57215: LD_VAR 0 4
57219: PPUSH
57220: CALL_OW 264
57224: PUSH
57225: LD_INT 49
57227: EQUAL
57228: IFFALSE 57256
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
57230: LD_VAR 0 4
57234: PPUSH
57235: LD_VAR 0 5
57239: PPUSH
57240: LD_VAR 0 4
57244: PPUSH
57245: CALL_OW 74
57249: PPUSH
57250: CALL_OW 112
57254: GO 57280
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
57256: LD_VAR 0 4
57260: PPUSH
57261: LD_VAR 0 5
57265: PPUSH
57266: LD_VAR 0 4
57270: PPUSH
57271: CALL_OW 74
57275: PPUSH
57276: CALL 58209 0 2
// end ; end ;
57280: GO 56860
57282: POP
57283: POP
// end ;
57284: LD_VAR 0 3
57288: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
57289: LD_INT 0
57291: PPUSH
57292: PPUSH
57293: PPUSH
// if not unit or IsInUnit ( unit ) then
57294: LD_VAR 0 1
57298: NOT
57299: PUSH
57300: LD_VAR 0 1
57304: PPUSH
57305: CALL_OW 310
57309: OR
57310: IFFALSE 57314
// exit ;
57312: GO 57405
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
57314: LD_ADDR_VAR 0 4
57318: PUSH
57319: LD_VAR 0 1
57323: PPUSH
57324: CALL_OW 250
57328: PPUSH
57329: LD_VAR 0 2
57333: PPUSH
57334: LD_INT 1
57336: PPUSH
57337: CALL_OW 272
57341: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
57342: LD_ADDR_VAR 0 5
57346: PUSH
57347: LD_VAR 0 1
57351: PPUSH
57352: CALL_OW 251
57356: PPUSH
57357: LD_VAR 0 2
57361: PPUSH
57362: LD_INT 1
57364: PPUSH
57365: CALL_OW 273
57369: ST_TO_ADDR
// if ValidHex ( x , y ) then
57370: LD_VAR 0 4
57374: PPUSH
57375: LD_VAR 0 5
57379: PPUSH
57380: CALL_OW 488
57384: IFFALSE 57405
// ComTurnXY ( unit , x , y ) ;
57386: LD_VAR 0 1
57390: PPUSH
57391: LD_VAR 0 4
57395: PPUSH
57396: LD_VAR 0 5
57400: PPUSH
57401: CALL_OW 118
// end ;
57405: LD_VAR 0 3
57409: RET
// export function SeeUnits ( side , units ) ; var i ; begin
57410: LD_INT 0
57412: PPUSH
57413: PPUSH
// result := false ;
57414: LD_ADDR_VAR 0 3
57418: PUSH
57419: LD_INT 0
57421: ST_TO_ADDR
// if not units then
57422: LD_VAR 0 2
57426: NOT
57427: IFFALSE 57431
// exit ;
57429: GO 57476
// for i in units do
57431: LD_ADDR_VAR 0 4
57435: PUSH
57436: LD_VAR 0 2
57440: PUSH
57441: FOR_IN
57442: IFFALSE 57474
// if See ( side , i ) then
57444: LD_VAR 0 1
57448: PPUSH
57449: LD_VAR 0 4
57453: PPUSH
57454: CALL_OW 292
57458: IFFALSE 57472
// begin result := true ;
57460: LD_ADDR_VAR 0 3
57464: PUSH
57465: LD_INT 1
57467: ST_TO_ADDR
// exit ;
57468: POP
57469: POP
57470: GO 57476
// end ;
57472: GO 57441
57474: POP
57475: POP
// end ;
57476: LD_VAR 0 3
57480: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
57481: LD_INT 0
57483: PPUSH
57484: PPUSH
57485: PPUSH
57486: PPUSH
// if not unit or not points then
57487: LD_VAR 0 1
57491: NOT
57492: PUSH
57493: LD_VAR 0 2
57497: NOT
57498: OR
57499: IFFALSE 57503
// exit ;
57501: GO 57593
// dist := 99999 ;
57503: LD_ADDR_VAR 0 5
57507: PUSH
57508: LD_INT 99999
57510: ST_TO_ADDR
// for i in points do
57511: LD_ADDR_VAR 0 4
57515: PUSH
57516: LD_VAR 0 2
57520: PUSH
57521: FOR_IN
57522: IFFALSE 57591
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
57524: LD_ADDR_VAR 0 6
57528: PUSH
57529: LD_VAR 0 1
57533: PPUSH
57534: LD_VAR 0 4
57538: PUSH
57539: LD_INT 1
57541: ARRAY
57542: PPUSH
57543: LD_VAR 0 4
57547: PUSH
57548: LD_INT 2
57550: ARRAY
57551: PPUSH
57552: CALL_OW 297
57556: ST_TO_ADDR
// if tmpDist < dist then
57557: LD_VAR 0 6
57561: PUSH
57562: LD_VAR 0 5
57566: LESS
57567: IFFALSE 57589
// begin result := i ;
57569: LD_ADDR_VAR 0 3
57573: PUSH
57574: LD_VAR 0 4
57578: ST_TO_ADDR
// dist := tmpDist ;
57579: LD_ADDR_VAR 0 5
57583: PUSH
57584: LD_VAR 0 6
57588: ST_TO_ADDR
// end ; end ;
57589: GO 57521
57591: POP
57592: POP
// end ;
57593: LD_VAR 0 3
57597: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
57598: LD_INT 0
57600: PPUSH
// uc_side := side ;
57601: LD_ADDR_OWVAR 20
57605: PUSH
57606: LD_VAR 0 1
57610: ST_TO_ADDR
// uc_nation := 3 ;
57611: LD_ADDR_OWVAR 21
57615: PUSH
57616: LD_INT 3
57618: ST_TO_ADDR
// vc_chassis := 25 ;
57619: LD_ADDR_OWVAR 37
57623: PUSH
57624: LD_INT 25
57626: ST_TO_ADDR
// vc_engine := engine_siberite ;
57627: LD_ADDR_OWVAR 39
57631: PUSH
57632: LD_INT 3
57634: ST_TO_ADDR
// vc_control := control_computer ;
57635: LD_ADDR_OWVAR 38
57639: PUSH
57640: LD_INT 3
57642: ST_TO_ADDR
// vc_weapon := 59 ;
57643: LD_ADDR_OWVAR 40
57647: PUSH
57648: LD_INT 59
57650: ST_TO_ADDR
// result := CreateVehicle ;
57651: LD_ADDR_VAR 0 5
57655: PUSH
57656: CALL_OW 45
57660: ST_TO_ADDR
// SetDir ( result , d ) ;
57661: LD_VAR 0 5
57665: PPUSH
57666: LD_VAR 0 4
57670: PPUSH
57671: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
57675: LD_VAR 0 5
57679: PPUSH
57680: LD_VAR 0 2
57684: PPUSH
57685: LD_VAR 0 3
57689: PPUSH
57690: LD_INT 0
57692: PPUSH
57693: CALL_OW 48
// end ;
57697: LD_VAR 0 5
57701: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
57702: LD_INT 0
57704: PPUSH
57705: PPUSH
57706: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
57707: LD_ADDR_VAR 0 2
57711: PUSH
57712: LD_INT 0
57714: PUSH
57715: LD_INT 0
57717: PUSH
57718: LD_INT 0
57720: PUSH
57721: LD_INT 0
57723: PUSH
57724: EMPTY
57725: LIST
57726: LIST
57727: LIST
57728: LIST
57729: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
57730: LD_VAR 0 1
57734: NOT
57735: PUSH
57736: LD_VAR 0 1
57740: PPUSH
57741: CALL_OW 264
57745: PUSH
57746: LD_INT 12
57748: PUSH
57749: LD_INT 51
57751: PUSH
57752: LD_INT 32
57754: PUSH
57755: LD_INT 89
57757: PUSH
57758: EMPTY
57759: LIST
57760: LIST
57761: LIST
57762: LIST
57763: IN
57764: NOT
57765: OR
57766: IFFALSE 57770
// exit ;
57768: GO 57868
// for i := 1 to 3 do
57770: LD_ADDR_VAR 0 3
57774: PUSH
57775: DOUBLE
57776: LD_INT 1
57778: DEC
57779: ST_TO_ADDR
57780: LD_INT 3
57782: PUSH
57783: FOR_TO
57784: IFFALSE 57866
// begin tmp := GetCargo ( cargo , i ) ;
57786: LD_ADDR_VAR 0 4
57790: PUSH
57791: LD_VAR 0 1
57795: PPUSH
57796: LD_VAR 0 3
57800: PPUSH
57801: CALL_OW 289
57805: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
57806: LD_ADDR_VAR 0 2
57810: PUSH
57811: LD_VAR 0 2
57815: PPUSH
57816: LD_VAR 0 3
57820: PPUSH
57821: LD_VAR 0 4
57825: PPUSH
57826: CALL_OW 1
57830: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
57831: LD_ADDR_VAR 0 2
57835: PUSH
57836: LD_VAR 0 2
57840: PPUSH
57841: LD_INT 4
57843: PPUSH
57844: LD_VAR 0 2
57848: PUSH
57849: LD_INT 4
57851: ARRAY
57852: PUSH
57853: LD_VAR 0 4
57857: PLUS
57858: PPUSH
57859: CALL_OW 1
57863: ST_TO_ADDR
// end ;
57864: GO 57783
57866: POP
57867: POP
// end ;
57868: LD_VAR 0 2
57872: RET
// export function Length ( array ) ; begin
57873: LD_INT 0
57875: PPUSH
// result := array + 0 ;
57876: LD_ADDR_VAR 0 2
57880: PUSH
57881: LD_VAR 0 1
57885: PUSH
57886: LD_INT 0
57888: PLUS
57889: ST_TO_ADDR
// end ;
57890: LD_VAR 0 2
57894: RET
// export function PrepareArray ( array ) ; begin
57895: LD_INT 0
57897: PPUSH
// result := array diff 0 ;
57898: LD_ADDR_VAR 0 2
57902: PUSH
57903: LD_VAR 0 1
57907: PUSH
57908: LD_INT 0
57910: DIFF
57911: ST_TO_ADDR
// if not result [ 1 ] then
57912: LD_VAR 0 2
57916: PUSH
57917: LD_INT 1
57919: ARRAY
57920: NOT
57921: IFFALSE 57941
// result := Delete ( result , 1 ) ;
57923: LD_ADDR_VAR 0 2
57927: PUSH
57928: LD_VAR 0 2
57932: PPUSH
57933: LD_INT 1
57935: PPUSH
57936: CALL_OW 3
57940: ST_TO_ADDR
// end ;
57941: LD_VAR 0 2
57945: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
57946: LD_INT 0
57948: PPUSH
57949: PPUSH
57950: PPUSH
57951: PPUSH
// sibRocketRange := 25 ;
57952: LD_ADDR_VAR 0 6
57956: PUSH
57957: LD_INT 25
57959: ST_TO_ADDR
// result := false ;
57960: LD_ADDR_VAR 0 4
57964: PUSH
57965: LD_INT 0
57967: ST_TO_ADDR
// for i := 0 to 5 do
57968: LD_ADDR_VAR 0 5
57972: PUSH
57973: DOUBLE
57974: LD_INT 0
57976: DEC
57977: ST_TO_ADDR
57978: LD_INT 5
57980: PUSH
57981: FOR_TO
57982: IFFALSE 58049
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
57984: LD_VAR 0 1
57988: PPUSH
57989: LD_VAR 0 5
57993: PPUSH
57994: LD_VAR 0 6
57998: PPUSH
57999: CALL_OW 272
58003: PPUSH
58004: LD_VAR 0 2
58008: PPUSH
58009: LD_VAR 0 5
58013: PPUSH
58014: LD_VAR 0 6
58018: PPUSH
58019: CALL_OW 273
58023: PPUSH
58024: LD_VAR 0 3
58028: PPUSH
58029: CALL_OW 309
58033: IFFALSE 58047
// begin result := true ;
58035: LD_ADDR_VAR 0 4
58039: PUSH
58040: LD_INT 1
58042: ST_TO_ADDR
// exit ;
58043: POP
58044: POP
58045: GO 58051
// end ;
58047: GO 57981
58049: POP
58050: POP
// end ;
58051: LD_VAR 0 4
58055: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
58056: LD_INT 0
58058: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
58059: LD_VAR 0 1
58063: PPUSH
58064: LD_VAR 0 2
58068: PPUSH
58069: LD_INT 0
58071: PPUSH
58072: LD_INT 0
58074: PPUSH
58075: LD_INT 1
58077: PPUSH
58078: LD_INT 0
58080: PPUSH
58081: CALL_OW 587
// end ;
58085: LD_VAR 0 3
58089: RET
// export function CenterOnNow ( unit ) ; begin
58090: LD_INT 0
58092: PPUSH
// result := IsInUnit ( unit ) ;
58093: LD_ADDR_VAR 0 2
58097: PUSH
58098: LD_VAR 0 1
58102: PPUSH
58103: CALL_OW 310
58107: ST_TO_ADDR
// if not result then
58108: LD_VAR 0 2
58112: NOT
58113: IFFALSE 58125
// result := unit ;
58115: LD_ADDR_VAR 0 2
58119: PUSH
58120: LD_VAR 0 1
58124: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
58125: LD_VAR 0 1
58129: PPUSH
58130: CALL_OW 87
// end ;
58134: LD_VAR 0 2
58138: RET
// export function ComMoveHex ( unit , hex ) ; begin
58139: LD_INT 0
58141: PPUSH
// if not hex then
58142: LD_VAR 0 2
58146: NOT
58147: IFFALSE 58151
// exit ;
58149: GO 58204
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
58151: LD_VAR 0 2
58155: PUSH
58156: LD_INT 1
58158: ARRAY
58159: PPUSH
58160: LD_VAR 0 2
58164: PUSH
58165: LD_INT 2
58167: ARRAY
58168: PPUSH
58169: CALL_OW 428
58173: IFFALSE 58177
// exit ;
58175: GO 58204
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
58177: LD_VAR 0 1
58181: PPUSH
58182: LD_VAR 0 2
58186: PUSH
58187: LD_INT 1
58189: ARRAY
58190: PPUSH
58191: LD_VAR 0 2
58195: PUSH
58196: LD_INT 2
58198: ARRAY
58199: PPUSH
58200: CALL_OW 111
// end ;
58204: LD_VAR 0 3
58208: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
58209: LD_INT 0
58211: PPUSH
58212: PPUSH
58213: PPUSH
// if not unit or not enemy then
58214: LD_VAR 0 1
58218: NOT
58219: PUSH
58220: LD_VAR 0 2
58224: NOT
58225: OR
58226: IFFALSE 58230
// exit ;
58228: GO 58354
// x := GetX ( enemy ) ;
58230: LD_ADDR_VAR 0 4
58234: PUSH
58235: LD_VAR 0 2
58239: PPUSH
58240: CALL_OW 250
58244: ST_TO_ADDR
// y := GetY ( enemy ) ;
58245: LD_ADDR_VAR 0 5
58249: PUSH
58250: LD_VAR 0 2
58254: PPUSH
58255: CALL_OW 251
58259: ST_TO_ADDR
// if ValidHex ( x , y ) then
58260: LD_VAR 0 4
58264: PPUSH
58265: LD_VAR 0 5
58269: PPUSH
58270: CALL_OW 488
58274: IFFALSE 58354
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
58276: LD_VAR 0 2
58280: PPUSH
58281: CALL_OW 247
58285: PUSH
58286: LD_INT 3
58288: PUSH
58289: LD_INT 2
58291: PUSH
58292: EMPTY
58293: LIST
58294: LIST
58295: IN
58296: PUSH
58297: LD_VAR 0 1
58301: PPUSH
58302: CALL_OW 255
58306: PPUSH
58307: LD_VAR 0 2
58311: PPUSH
58312: CALL_OW 292
58316: AND
58317: IFFALSE 58335
// ComAttackUnit ( unit , enemy ) else
58319: LD_VAR 0 1
58323: PPUSH
58324: LD_VAR 0 2
58328: PPUSH
58329: CALL_OW 115
58333: GO 58354
// ComAgressiveMove ( unit , x , y ) ;
58335: LD_VAR 0 1
58339: PPUSH
58340: LD_VAR 0 4
58344: PPUSH
58345: LD_VAR 0 5
58349: PPUSH
58350: CALL_OW 114
// end ;
58354: LD_VAR 0 3
58358: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
58359: LD_INT 0
58361: PPUSH
58362: PPUSH
58363: PPUSH
// list := AreaToList ( area , 0 ) ;
58364: LD_ADDR_VAR 0 5
58368: PUSH
58369: LD_VAR 0 1
58373: PPUSH
58374: LD_INT 0
58376: PPUSH
58377: CALL_OW 517
58381: ST_TO_ADDR
// if not list then
58382: LD_VAR 0 5
58386: NOT
58387: IFFALSE 58391
// exit ;
58389: GO 58521
// if all then
58391: LD_VAR 0 2
58395: IFFALSE 58483
// begin for i := 1 to list [ 1 ] do
58397: LD_ADDR_VAR 0 4
58401: PUSH
58402: DOUBLE
58403: LD_INT 1
58405: DEC
58406: ST_TO_ADDR
58407: LD_VAR 0 5
58411: PUSH
58412: LD_INT 1
58414: ARRAY
58415: PUSH
58416: FOR_TO
58417: IFFALSE 58479
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
58419: LD_ADDR_VAR 0 3
58423: PUSH
58424: LD_VAR 0 3
58428: PPUSH
58429: LD_VAR 0 3
58433: PUSH
58434: LD_INT 1
58436: PLUS
58437: PPUSH
58438: LD_VAR 0 5
58442: PUSH
58443: LD_INT 1
58445: ARRAY
58446: PUSH
58447: LD_VAR 0 4
58451: ARRAY
58452: PUSH
58453: LD_VAR 0 5
58457: PUSH
58458: LD_INT 2
58460: ARRAY
58461: PUSH
58462: LD_VAR 0 4
58466: ARRAY
58467: PUSH
58468: EMPTY
58469: LIST
58470: LIST
58471: PPUSH
58472: CALL_OW 1
58476: ST_TO_ADDR
58477: GO 58416
58479: POP
58480: POP
// exit ;
58481: GO 58521
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
58483: LD_ADDR_VAR 0 3
58487: PUSH
58488: LD_VAR 0 5
58492: PUSH
58493: LD_INT 1
58495: ARRAY
58496: PUSH
58497: LD_INT 1
58499: ARRAY
58500: PUSH
58501: LD_VAR 0 5
58505: PUSH
58506: LD_INT 2
58508: ARRAY
58509: PUSH
58510: LD_INT 1
58512: ARRAY
58513: PUSH
58514: EMPTY
58515: LIST
58516: LIST
58517: PUSH
58518: EMPTY
58519: LIST
58520: ST_TO_ADDR
// end ;
58521: LD_VAR 0 3
58525: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
58526: LD_INT 0
58528: PPUSH
58529: PPUSH
// list := AreaToList ( area , 0 ) ;
58530: LD_ADDR_VAR 0 4
58534: PUSH
58535: LD_VAR 0 1
58539: PPUSH
58540: LD_INT 0
58542: PPUSH
58543: CALL_OW 517
58547: ST_TO_ADDR
// if not list then
58548: LD_VAR 0 4
58552: NOT
58553: IFFALSE 58557
// exit ;
58555: GO 58598
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
58557: LD_ADDR_VAR 0 3
58561: PUSH
58562: LD_VAR 0 4
58566: PUSH
58567: LD_INT 1
58569: ARRAY
58570: PUSH
58571: LD_INT 1
58573: ARRAY
58574: PUSH
58575: LD_VAR 0 4
58579: PUSH
58580: LD_INT 2
58582: ARRAY
58583: PUSH
58584: LD_INT 1
58586: ARRAY
58587: PUSH
58588: LD_VAR 0 2
58592: PUSH
58593: EMPTY
58594: LIST
58595: LIST
58596: LIST
58597: ST_TO_ADDR
// end ;
58598: LD_VAR 0 3
58602: RET
// export function First ( array ) ; begin
58603: LD_INT 0
58605: PPUSH
// if not array then
58606: LD_VAR 0 1
58610: NOT
58611: IFFALSE 58615
// exit ;
58613: GO 58629
// result := array [ 1 ] ;
58615: LD_ADDR_VAR 0 2
58619: PUSH
58620: LD_VAR 0 1
58624: PUSH
58625: LD_INT 1
58627: ARRAY
58628: ST_TO_ADDR
// end ;
58629: LD_VAR 0 2
58633: RET
// export function Last ( array ) ; begin
58634: LD_INT 0
58636: PPUSH
// if not array then
58637: LD_VAR 0 1
58641: NOT
58642: IFFALSE 58646
// exit ;
58644: GO 58662
// result := array [ array ] ;
58646: LD_ADDR_VAR 0 2
58650: PUSH
58651: LD_VAR 0 1
58655: PUSH
58656: LD_VAR 0 1
58660: ARRAY
58661: ST_TO_ADDR
// end ; end_of_file
58662: LD_VAR 0 2
58666: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
58667: LD_INT 0
58669: PPUSH
58670: PPUSH
// skirmish := false ;
58671: LD_ADDR_EXP 59
58675: PUSH
58676: LD_INT 0
58678: ST_TO_ADDR
// debug_mc := false ;
58679: LD_ADDR_EXP 60
58683: PUSH
58684: LD_INT 0
58686: ST_TO_ADDR
// mc_bases := [ ] ;
58687: LD_ADDR_EXP 61
58691: PUSH
58692: EMPTY
58693: ST_TO_ADDR
// mc_sides := [ ] ;
58694: LD_ADDR_EXP 87
58698: PUSH
58699: EMPTY
58700: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
58701: LD_ADDR_EXP 62
58705: PUSH
58706: EMPTY
58707: ST_TO_ADDR
// mc_building_repairs := [ ] ;
58708: LD_ADDR_EXP 63
58712: PUSH
58713: EMPTY
58714: ST_TO_ADDR
// mc_need_heal := [ ] ;
58715: LD_ADDR_EXP 64
58719: PUSH
58720: EMPTY
58721: ST_TO_ADDR
// mc_healers := [ ] ;
58722: LD_ADDR_EXP 65
58726: PUSH
58727: EMPTY
58728: ST_TO_ADDR
// mc_build_list := [ ] ;
58729: LD_ADDR_EXP 66
58733: PUSH
58734: EMPTY
58735: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
58736: LD_ADDR_EXP 93
58740: PUSH
58741: EMPTY
58742: ST_TO_ADDR
// mc_builders := [ ] ;
58743: LD_ADDR_EXP 67
58747: PUSH
58748: EMPTY
58749: ST_TO_ADDR
// mc_construct_list := [ ] ;
58750: LD_ADDR_EXP 68
58754: PUSH
58755: EMPTY
58756: ST_TO_ADDR
// mc_turret_list := [ ] ;
58757: LD_ADDR_EXP 69
58761: PUSH
58762: EMPTY
58763: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
58764: LD_ADDR_EXP 70
58768: PUSH
58769: EMPTY
58770: ST_TO_ADDR
// mc_miners := [ ] ;
58771: LD_ADDR_EXP 75
58775: PUSH
58776: EMPTY
58777: ST_TO_ADDR
// mc_mines := [ ] ;
58778: LD_ADDR_EXP 74
58782: PUSH
58783: EMPTY
58784: ST_TO_ADDR
// mc_minefields := [ ] ;
58785: LD_ADDR_EXP 76
58789: PUSH
58790: EMPTY
58791: ST_TO_ADDR
// mc_crates := [ ] ;
58792: LD_ADDR_EXP 77
58796: PUSH
58797: EMPTY
58798: ST_TO_ADDR
// mc_crates_collector := [ ] ;
58799: LD_ADDR_EXP 78
58803: PUSH
58804: EMPTY
58805: ST_TO_ADDR
// mc_crates_area := [ ] ;
58806: LD_ADDR_EXP 79
58810: PUSH
58811: EMPTY
58812: ST_TO_ADDR
// mc_vehicles := [ ] ;
58813: LD_ADDR_EXP 80
58817: PUSH
58818: EMPTY
58819: ST_TO_ADDR
// mc_attack := [ ] ;
58820: LD_ADDR_EXP 81
58824: PUSH
58825: EMPTY
58826: ST_TO_ADDR
// mc_produce := [ ] ;
58827: LD_ADDR_EXP 82
58831: PUSH
58832: EMPTY
58833: ST_TO_ADDR
// mc_defender := [ ] ;
58834: LD_ADDR_EXP 83
58838: PUSH
58839: EMPTY
58840: ST_TO_ADDR
// mc_parking := [ ] ;
58841: LD_ADDR_EXP 85
58845: PUSH
58846: EMPTY
58847: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
58848: LD_ADDR_EXP 71
58852: PUSH
58853: EMPTY
58854: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
58855: LD_ADDR_EXP 73
58859: PUSH
58860: EMPTY
58861: ST_TO_ADDR
// mc_scan := [ ] ;
58862: LD_ADDR_EXP 84
58866: PUSH
58867: EMPTY
58868: ST_TO_ADDR
// mc_scan_area := [ ] ;
58869: LD_ADDR_EXP 86
58873: PUSH
58874: EMPTY
58875: ST_TO_ADDR
// mc_tech := [ ] ;
58876: LD_ADDR_EXP 88
58880: PUSH
58881: EMPTY
58882: ST_TO_ADDR
// mc_class := [ ] ;
58883: LD_ADDR_EXP 102
58887: PUSH
58888: EMPTY
58889: ST_TO_ADDR
// mc_class_case_use := [ ] ;
58890: LD_ADDR_EXP 103
58894: PUSH
58895: EMPTY
58896: ST_TO_ADDR
// mc_is_defending := [ ] ;
58897: LD_ADDR_EXP 104
58901: PUSH
58902: EMPTY
58903: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
58904: LD_ADDR_EXP 95
58908: PUSH
58909: EMPTY
58910: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
58911: LD_ADDR_EXP 105
58915: PUSH
58916: LD_INT 0
58918: ST_TO_ADDR
// end ;
58919: LD_VAR 0 1
58923: RET
// export function MC_Kill ( base ) ; begin
58924: LD_INT 0
58926: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
58927: LD_ADDR_EXP 61
58931: PUSH
58932: LD_EXP 61
58936: PPUSH
58937: LD_VAR 0 1
58941: PPUSH
58942: EMPTY
58943: PPUSH
58944: CALL_OW 1
58948: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58949: LD_ADDR_EXP 62
58953: PUSH
58954: LD_EXP 62
58958: PPUSH
58959: LD_VAR 0 1
58963: PPUSH
58964: EMPTY
58965: PPUSH
58966: CALL_OW 1
58970: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58971: LD_ADDR_EXP 63
58975: PUSH
58976: LD_EXP 63
58980: PPUSH
58981: LD_VAR 0 1
58985: PPUSH
58986: EMPTY
58987: PPUSH
58988: CALL_OW 1
58992: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58993: LD_ADDR_EXP 64
58997: PUSH
58998: LD_EXP 64
59002: PPUSH
59003: LD_VAR 0 1
59007: PPUSH
59008: EMPTY
59009: PPUSH
59010: CALL_OW 1
59014: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
59015: LD_ADDR_EXP 65
59019: PUSH
59020: LD_EXP 65
59024: PPUSH
59025: LD_VAR 0 1
59029: PPUSH
59030: EMPTY
59031: PPUSH
59032: CALL_OW 1
59036: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
59037: LD_ADDR_EXP 66
59041: PUSH
59042: LD_EXP 66
59046: PPUSH
59047: LD_VAR 0 1
59051: PPUSH
59052: EMPTY
59053: PPUSH
59054: CALL_OW 1
59058: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
59059: LD_ADDR_EXP 67
59063: PUSH
59064: LD_EXP 67
59068: PPUSH
59069: LD_VAR 0 1
59073: PPUSH
59074: EMPTY
59075: PPUSH
59076: CALL_OW 1
59080: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
59081: LD_ADDR_EXP 68
59085: PUSH
59086: LD_EXP 68
59090: PPUSH
59091: LD_VAR 0 1
59095: PPUSH
59096: EMPTY
59097: PPUSH
59098: CALL_OW 1
59102: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
59103: LD_ADDR_EXP 69
59107: PUSH
59108: LD_EXP 69
59112: PPUSH
59113: LD_VAR 0 1
59117: PPUSH
59118: EMPTY
59119: PPUSH
59120: CALL_OW 1
59124: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
59125: LD_ADDR_EXP 70
59129: PUSH
59130: LD_EXP 70
59134: PPUSH
59135: LD_VAR 0 1
59139: PPUSH
59140: EMPTY
59141: PPUSH
59142: CALL_OW 1
59146: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
59147: LD_ADDR_EXP 71
59151: PUSH
59152: LD_EXP 71
59156: PPUSH
59157: LD_VAR 0 1
59161: PPUSH
59162: EMPTY
59163: PPUSH
59164: CALL_OW 1
59168: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
59169: LD_ADDR_EXP 72
59173: PUSH
59174: LD_EXP 72
59178: PPUSH
59179: LD_VAR 0 1
59183: PPUSH
59184: LD_INT 0
59186: PPUSH
59187: CALL_OW 1
59191: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
59192: LD_ADDR_EXP 73
59196: PUSH
59197: LD_EXP 73
59201: PPUSH
59202: LD_VAR 0 1
59206: PPUSH
59207: EMPTY
59208: PPUSH
59209: CALL_OW 1
59213: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
59214: LD_ADDR_EXP 74
59218: PUSH
59219: LD_EXP 74
59223: PPUSH
59224: LD_VAR 0 1
59228: PPUSH
59229: EMPTY
59230: PPUSH
59231: CALL_OW 1
59235: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
59236: LD_ADDR_EXP 75
59240: PUSH
59241: LD_EXP 75
59245: PPUSH
59246: LD_VAR 0 1
59250: PPUSH
59251: EMPTY
59252: PPUSH
59253: CALL_OW 1
59257: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
59258: LD_ADDR_EXP 76
59262: PUSH
59263: LD_EXP 76
59267: PPUSH
59268: LD_VAR 0 1
59272: PPUSH
59273: EMPTY
59274: PPUSH
59275: CALL_OW 1
59279: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
59280: LD_ADDR_EXP 77
59284: PUSH
59285: LD_EXP 77
59289: PPUSH
59290: LD_VAR 0 1
59294: PPUSH
59295: EMPTY
59296: PPUSH
59297: CALL_OW 1
59301: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
59302: LD_ADDR_EXP 78
59306: PUSH
59307: LD_EXP 78
59311: PPUSH
59312: LD_VAR 0 1
59316: PPUSH
59317: EMPTY
59318: PPUSH
59319: CALL_OW 1
59323: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
59324: LD_ADDR_EXP 79
59328: PUSH
59329: LD_EXP 79
59333: PPUSH
59334: LD_VAR 0 1
59338: PPUSH
59339: EMPTY
59340: PPUSH
59341: CALL_OW 1
59345: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
59346: LD_ADDR_EXP 80
59350: PUSH
59351: LD_EXP 80
59355: PPUSH
59356: LD_VAR 0 1
59360: PPUSH
59361: EMPTY
59362: PPUSH
59363: CALL_OW 1
59367: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
59368: LD_ADDR_EXP 81
59372: PUSH
59373: LD_EXP 81
59377: PPUSH
59378: LD_VAR 0 1
59382: PPUSH
59383: EMPTY
59384: PPUSH
59385: CALL_OW 1
59389: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
59390: LD_ADDR_EXP 82
59394: PUSH
59395: LD_EXP 82
59399: PPUSH
59400: LD_VAR 0 1
59404: PPUSH
59405: EMPTY
59406: PPUSH
59407: CALL_OW 1
59411: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
59412: LD_ADDR_EXP 83
59416: PUSH
59417: LD_EXP 83
59421: PPUSH
59422: LD_VAR 0 1
59426: PPUSH
59427: EMPTY
59428: PPUSH
59429: CALL_OW 1
59433: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
59434: LD_ADDR_EXP 84
59438: PUSH
59439: LD_EXP 84
59443: PPUSH
59444: LD_VAR 0 1
59448: PPUSH
59449: EMPTY
59450: PPUSH
59451: CALL_OW 1
59455: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
59456: LD_ADDR_EXP 85
59460: PUSH
59461: LD_EXP 85
59465: PPUSH
59466: LD_VAR 0 1
59470: PPUSH
59471: EMPTY
59472: PPUSH
59473: CALL_OW 1
59477: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
59478: LD_ADDR_EXP 86
59482: PUSH
59483: LD_EXP 86
59487: PPUSH
59488: LD_VAR 0 1
59492: PPUSH
59493: EMPTY
59494: PPUSH
59495: CALL_OW 1
59499: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
59500: LD_ADDR_EXP 88
59504: PUSH
59505: LD_EXP 88
59509: PPUSH
59510: LD_VAR 0 1
59514: PPUSH
59515: EMPTY
59516: PPUSH
59517: CALL_OW 1
59521: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
59522: LD_ADDR_EXP 90
59526: PUSH
59527: LD_EXP 90
59531: PPUSH
59532: LD_VAR 0 1
59536: PPUSH
59537: EMPTY
59538: PPUSH
59539: CALL_OW 1
59543: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
59544: LD_ADDR_EXP 91
59548: PUSH
59549: LD_EXP 91
59553: PPUSH
59554: LD_VAR 0 1
59558: PPUSH
59559: EMPTY
59560: PPUSH
59561: CALL_OW 1
59565: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
59566: LD_ADDR_EXP 92
59570: PUSH
59571: LD_EXP 92
59575: PPUSH
59576: LD_VAR 0 1
59580: PPUSH
59581: EMPTY
59582: PPUSH
59583: CALL_OW 1
59587: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
59588: LD_ADDR_EXP 93
59592: PUSH
59593: LD_EXP 93
59597: PPUSH
59598: LD_VAR 0 1
59602: PPUSH
59603: EMPTY
59604: PPUSH
59605: CALL_OW 1
59609: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
59610: LD_ADDR_EXP 94
59614: PUSH
59615: LD_EXP 94
59619: PPUSH
59620: LD_VAR 0 1
59624: PPUSH
59625: EMPTY
59626: PPUSH
59627: CALL_OW 1
59631: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
59632: LD_ADDR_EXP 95
59636: PUSH
59637: LD_EXP 95
59641: PPUSH
59642: LD_VAR 0 1
59646: PPUSH
59647: EMPTY
59648: PPUSH
59649: CALL_OW 1
59653: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
59654: LD_ADDR_EXP 96
59658: PUSH
59659: LD_EXP 96
59663: PPUSH
59664: LD_VAR 0 1
59668: PPUSH
59669: EMPTY
59670: PPUSH
59671: CALL_OW 1
59675: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
59676: LD_ADDR_EXP 97
59680: PUSH
59681: LD_EXP 97
59685: PPUSH
59686: LD_VAR 0 1
59690: PPUSH
59691: EMPTY
59692: PPUSH
59693: CALL_OW 1
59697: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
59698: LD_ADDR_EXP 98
59702: PUSH
59703: LD_EXP 98
59707: PPUSH
59708: LD_VAR 0 1
59712: PPUSH
59713: EMPTY
59714: PPUSH
59715: CALL_OW 1
59719: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
59720: LD_ADDR_EXP 99
59724: PUSH
59725: LD_EXP 99
59729: PPUSH
59730: LD_VAR 0 1
59734: PPUSH
59735: EMPTY
59736: PPUSH
59737: CALL_OW 1
59741: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
59742: LD_ADDR_EXP 100
59746: PUSH
59747: LD_EXP 100
59751: PPUSH
59752: LD_VAR 0 1
59756: PPUSH
59757: EMPTY
59758: PPUSH
59759: CALL_OW 1
59763: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59764: LD_ADDR_EXP 101
59768: PUSH
59769: LD_EXP 101
59773: PPUSH
59774: LD_VAR 0 1
59778: PPUSH
59779: EMPTY
59780: PPUSH
59781: CALL_OW 1
59785: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59786: LD_ADDR_EXP 102
59790: PUSH
59791: LD_EXP 102
59795: PPUSH
59796: LD_VAR 0 1
59800: PPUSH
59801: EMPTY
59802: PPUSH
59803: CALL_OW 1
59807: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59808: LD_ADDR_EXP 103
59812: PUSH
59813: LD_EXP 103
59817: PPUSH
59818: LD_VAR 0 1
59822: PPUSH
59823: LD_INT 0
59825: PPUSH
59826: CALL_OW 1
59830: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
59831: LD_ADDR_EXP 104
59835: PUSH
59836: LD_EXP 104
59840: PPUSH
59841: LD_VAR 0 1
59845: PPUSH
59846: LD_INT 0
59848: PPUSH
59849: CALL_OW 1
59853: ST_TO_ADDR
// end ;
59854: LD_VAR 0 2
59858: RET
// export function MC_Add ( side , units ) ; var base ; begin
59859: LD_INT 0
59861: PPUSH
59862: PPUSH
// base := mc_bases + 1 ;
59863: LD_ADDR_VAR 0 4
59867: PUSH
59868: LD_EXP 61
59872: PUSH
59873: LD_INT 1
59875: PLUS
59876: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
59877: LD_ADDR_EXP 87
59881: PUSH
59882: LD_EXP 87
59886: PPUSH
59887: LD_VAR 0 4
59891: PPUSH
59892: LD_VAR 0 1
59896: PPUSH
59897: CALL_OW 1
59901: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
59902: LD_ADDR_EXP 61
59906: PUSH
59907: LD_EXP 61
59911: PPUSH
59912: LD_VAR 0 4
59916: PPUSH
59917: LD_VAR 0 2
59921: PPUSH
59922: CALL_OW 1
59926: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
59927: LD_ADDR_EXP 62
59931: PUSH
59932: LD_EXP 62
59936: PPUSH
59937: LD_VAR 0 4
59941: PPUSH
59942: EMPTY
59943: PPUSH
59944: CALL_OW 1
59948: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
59949: LD_ADDR_EXP 63
59953: PUSH
59954: LD_EXP 63
59958: PPUSH
59959: LD_VAR 0 4
59963: PPUSH
59964: EMPTY
59965: PPUSH
59966: CALL_OW 1
59970: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
59971: LD_ADDR_EXP 64
59975: PUSH
59976: LD_EXP 64
59980: PPUSH
59981: LD_VAR 0 4
59985: PPUSH
59986: EMPTY
59987: PPUSH
59988: CALL_OW 1
59992: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
59993: LD_ADDR_EXP 65
59997: PUSH
59998: LD_EXP 65
60002: PPUSH
60003: LD_VAR 0 4
60007: PPUSH
60008: EMPTY
60009: PPUSH
60010: CALL_OW 1
60014: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
60015: LD_ADDR_EXP 66
60019: PUSH
60020: LD_EXP 66
60024: PPUSH
60025: LD_VAR 0 4
60029: PPUSH
60030: EMPTY
60031: PPUSH
60032: CALL_OW 1
60036: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
60037: LD_ADDR_EXP 67
60041: PUSH
60042: LD_EXP 67
60046: PPUSH
60047: LD_VAR 0 4
60051: PPUSH
60052: EMPTY
60053: PPUSH
60054: CALL_OW 1
60058: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
60059: LD_ADDR_EXP 68
60063: PUSH
60064: LD_EXP 68
60068: PPUSH
60069: LD_VAR 0 4
60073: PPUSH
60074: EMPTY
60075: PPUSH
60076: CALL_OW 1
60080: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
60081: LD_ADDR_EXP 69
60085: PUSH
60086: LD_EXP 69
60090: PPUSH
60091: LD_VAR 0 4
60095: PPUSH
60096: EMPTY
60097: PPUSH
60098: CALL_OW 1
60102: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
60103: LD_ADDR_EXP 70
60107: PUSH
60108: LD_EXP 70
60112: PPUSH
60113: LD_VAR 0 4
60117: PPUSH
60118: EMPTY
60119: PPUSH
60120: CALL_OW 1
60124: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
60125: LD_ADDR_EXP 71
60129: PUSH
60130: LD_EXP 71
60134: PPUSH
60135: LD_VAR 0 4
60139: PPUSH
60140: EMPTY
60141: PPUSH
60142: CALL_OW 1
60146: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
60147: LD_ADDR_EXP 72
60151: PUSH
60152: LD_EXP 72
60156: PPUSH
60157: LD_VAR 0 4
60161: PPUSH
60162: LD_INT 0
60164: PPUSH
60165: CALL_OW 1
60169: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
60170: LD_ADDR_EXP 73
60174: PUSH
60175: LD_EXP 73
60179: PPUSH
60180: LD_VAR 0 4
60184: PPUSH
60185: EMPTY
60186: PPUSH
60187: CALL_OW 1
60191: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
60192: LD_ADDR_EXP 74
60196: PUSH
60197: LD_EXP 74
60201: PPUSH
60202: LD_VAR 0 4
60206: PPUSH
60207: EMPTY
60208: PPUSH
60209: CALL_OW 1
60213: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
60214: LD_ADDR_EXP 75
60218: PUSH
60219: LD_EXP 75
60223: PPUSH
60224: LD_VAR 0 4
60228: PPUSH
60229: EMPTY
60230: PPUSH
60231: CALL_OW 1
60235: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
60236: LD_ADDR_EXP 76
60240: PUSH
60241: LD_EXP 76
60245: PPUSH
60246: LD_VAR 0 4
60250: PPUSH
60251: EMPTY
60252: PPUSH
60253: CALL_OW 1
60257: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
60258: LD_ADDR_EXP 77
60262: PUSH
60263: LD_EXP 77
60267: PPUSH
60268: LD_VAR 0 4
60272: PPUSH
60273: EMPTY
60274: PPUSH
60275: CALL_OW 1
60279: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
60280: LD_ADDR_EXP 78
60284: PUSH
60285: LD_EXP 78
60289: PPUSH
60290: LD_VAR 0 4
60294: PPUSH
60295: EMPTY
60296: PPUSH
60297: CALL_OW 1
60301: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
60302: LD_ADDR_EXP 79
60306: PUSH
60307: LD_EXP 79
60311: PPUSH
60312: LD_VAR 0 4
60316: PPUSH
60317: EMPTY
60318: PPUSH
60319: CALL_OW 1
60323: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
60324: LD_ADDR_EXP 80
60328: PUSH
60329: LD_EXP 80
60333: PPUSH
60334: LD_VAR 0 4
60338: PPUSH
60339: EMPTY
60340: PPUSH
60341: CALL_OW 1
60345: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
60346: LD_ADDR_EXP 81
60350: PUSH
60351: LD_EXP 81
60355: PPUSH
60356: LD_VAR 0 4
60360: PPUSH
60361: EMPTY
60362: PPUSH
60363: CALL_OW 1
60367: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
60368: LD_ADDR_EXP 82
60372: PUSH
60373: LD_EXP 82
60377: PPUSH
60378: LD_VAR 0 4
60382: PPUSH
60383: EMPTY
60384: PPUSH
60385: CALL_OW 1
60389: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
60390: LD_ADDR_EXP 83
60394: PUSH
60395: LD_EXP 83
60399: PPUSH
60400: LD_VAR 0 4
60404: PPUSH
60405: EMPTY
60406: PPUSH
60407: CALL_OW 1
60411: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
60412: LD_ADDR_EXP 84
60416: PUSH
60417: LD_EXP 84
60421: PPUSH
60422: LD_VAR 0 4
60426: PPUSH
60427: EMPTY
60428: PPUSH
60429: CALL_OW 1
60433: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
60434: LD_ADDR_EXP 85
60438: PUSH
60439: LD_EXP 85
60443: PPUSH
60444: LD_VAR 0 4
60448: PPUSH
60449: EMPTY
60450: PPUSH
60451: CALL_OW 1
60455: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
60456: LD_ADDR_EXP 86
60460: PUSH
60461: LD_EXP 86
60465: PPUSH
60466: LD_VAR 0 4
60470: PPUSH
60471: EMPTY
60472: PPUSH
60473: CALL_OW 1
60477: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
60478: LD_ADDR_EXP 88
60482: PUSH
60483: LD_EXP 88
60487: PPUSH
60488: LD_VAR 0 4
60492: PPUSH
60493: EMPTY
60494: PPUSH
60495: CALL_OW 1
60499: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
60500: LD_ADDR_EXP 90
60504: PUSH
60505: LD_EXP 90
60509: PPUSH
60510: LD_VAR 0 4
60514: PPUSH
60515: EMPTY
60516: PPUSH
60517: CALL_OW 1
60521: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
60522: LD_ADDR_EXP 91
60526: PUSH
60527: LD_EXP 91
60531: PPUSH
60532: LD_VAR 0 4
60536: PPUSH
60537: EMPTY
60538: PPUSH
60539: CALL_OW 1
60543: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
60544: LD_ADDR_EXP 92
60548: PUSH
60549: LD_EXP 92
60553: PPUSH
60554: LD_VAR 0 4
60558: PPUSH
60559: EMPTY
60560: PPUSH
60561: CALL_OW 1
60565: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
60566: LD_ADDR_EXP 93
60570: PUSH
60571: LD_EXP 93
60575: PPUSH
60576: LD_VAR 0 4
60580: PPUSH
60581: EMPTY
60582: PPUSH
60583: CALL_OW 1
60587: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
60588: LD_ADDR_EXP 94
60592: PUSH
60593: LD_EXP 94
60597: PPUSH
60598: LD_VAR 0 4
60602: PPUSH
60603: EMPTY
60604: PPUSH
60605: CALL_OW 1
60609: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
60610: LD_ADDR_EXP 95
60614: PUSH
60615: LD_EXP 95
60619: PPUSH
60620: LD_VAR 0 4
60624: PPUSH
60625: EMPTY
60626: PPUSH
60627: CALL_OW 1
60631: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
60632: LD_ADDR_EXP 96
60636: PUSH
60637: LD_EXP 96
60641: PPUSH
60642: LD_VAR 0 4
60646: PPUSH
60647: EMPTY
60648: PPUSH
60649: CALL_OW 1
60653: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
60654: LD_ADDR_EXP 97
60658: PUSH
60659: LD_EXP 97
60663: PPUSH
60664: LD_VAR 0 4
60668: PPUSH
60669: EMPTY
60670: PPUSH
60671: CALL_OW 1
60675: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
60676: LD_ADDR_EXP 98
60680: PUSH
60681: LD_EXP 98
60685: PPUSH
60686: LD_VAR 0 4
60690: PPUSH
60691: EMPTY
60692: PPUSH
60693: CALL_OW 1
60697: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
60698: LD_ADDR_EXP 99
60702: PUSH
60703: LD_EXP 99
60707: PPUSH
60708: LD_VAR 0 4
60712: PPUSH
60713: EMPTY
60714: PPUSH
60715: CALL_OW 1
60719: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
60720: LD_ADDR_EXP 100
60724: PUSH
60725: LD_EXP 100
60729: PPUSH
60730: LD_VAR 0 4
60734: PPUSH
60735: EMPTY
60736: PPUSH
60737: CALL_OW 1
60741: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
60742: LD_ADDR_EXP 101
60746: PUSH
60747: LD_EXP 101
60751: PPUSH
60752: LD_VAR 0 4
60756: PPUSH
60757: EMPTY
60758: PPUSH
60759: CALL_OW 1
60763: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
60764: LD_ADDR_EXP 102
60768: PUSH
60769: LD_EXP 102
60773: PPUSH
60774: LD_VAR 0 4
60778: PPUSH
60779: EMPTY
60780: PPUSH
60781: CALL_OW 1
60785: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
60786: LD_ADDR_EXP 103
60790: PUSH
60791: LD_EXP 103
60795: PPUSH
60796: LD_VAR 0 4
60800: PPUSH
60801: LD_INT 0
60803: PPUSH
60804: CALL_OW 1
60808: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
60809: LD_ADDR_EXP 104
60813: PUSH
60814: LD_EXP 104
60818: PPUSH
60819: LD_VAR 0 4
60823: PPUSH
60824: LD_INT 0
60826: PPUSH
60827: CALL_OW 1
60831: ST_TO_ADDR
// result := base ;
60832: LD_ADDR_VAR 0 3
60836: PUSH
60837: LD_VAR 0 4
60841: ST_TO_ADDR
// end ;
60842: LD_VAR 0 3
60846: RET
// export function MC_Start ( ) ; var i ; begin
60847: LD_INT 0
60849: PPUSH
60850: PPUSH
// for i = 1 to mc_bases do
60851: LD_ADDR_VAR 0 2
60855: PUSH
60856: DOUBLE
60857: LD_INT 1
60859: DEC
60860: ST_TO_ADDR
60861: LD_EXP 61
60865: PUSH
60866: FOR_TO
60867: IFFALSE 61967
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
60869: LD_ADDR_EXP 61
60873: PUSH
60874: LD_EXP 61
60878: PPUSH
60879: LD_VAR 0 2
60883: PPUSH
60884: LD_EXP 61
60888: PUSH
60889: LD_VAR 0 2
60893: ARRAY
60894: PUSH
60895: LD_INT 0
60897: DIFF
60898: PPUSH
60899: CALL_OW 1
60903: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
60904: LD_ADDR_EXP 62
60908: PUSH
60909: LD_EXP 62
60913: PPUSH
60914: LD_VAR 0 2
60918: PPUSH
60919: EMPTY
60920: PPUSH
60921: CALL_OW 1
60925: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60926: LD_ADDR_EXP 63
60930: PUSH
60931: LD_EXP 63
60935: PPUSH
60936: LD_VAR 0 2
60940: PPUSH
60941: EMPTY
60942: PPUSH
60943: CALL_OW 1
60947: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
60948: LD_ADDR_EXP 64
60952: PUSH
60953: LD_EXP 64
60957: PPUSH
60958: LD_VAR 0 2
60962: PPUSH
60963: EMPTY
60964: PPUSH
60965: CALL_OW 1
60969: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
60970: LD_ADDR_EXP 65
60974: PUSH
60975: LD_EXP 65
60979: PPUSH
60980: LD_VAR 0 2
60984: PPUSH
60985: EMPTY
60986: PUSH
60987: EMPTY
60988: PUSH
60989: EMPTY
60990: LIST
60991: LIST
60992: PPUSH
60993: CALL_OW 1
60997: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
60998: LD_ADDR_EXP 66
61002: PUSH
61003: LD_EXP 66
61007: PPUSH
61008: LD_VAR 0 2
61012: PPUSH
61013: EMPTY
61014: PPUSH
61015: CALL_OW 1
61019: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
61020: LD_ADDR_EXP 93
61024: PUSH
61025: LD_EXP 93
61029: PPUSH
61030: LD_VAR 0 2
61034: PPUSH
61035: EMPTY
61036: PPUSH
61037: CALL_OW 1
61041: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
61042: LD_ADDR_EXP 67
61046: PUSH
61047: LD_EXP 67
61051: PPUSH
61052: LD_VAR 0 2
61056: PPUSH
61057: EMPTY
61058: PPUSH
61059: CALL_OW 1
61063: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
61064: LD_ADDR_EXP 68
61068: PUSH
61069: LD_EXP 68
61073: PPUSH
61074: LD_VAR 0 2
61078: PPUSH
61079: EMPTY
61080: PPUSH
61081: CALL_OW 1
61085: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
61086: LD_ADDR_EXP 69
61090: PUSH
61091: LD_EXP 69
61095: PPUSH
61096: LD_VAR 0 2
61100: PPUSH
61101: LD_EXP 61
61105: PUSH
61106: LD_VAR 0 2
61110: ARRAY
61111: PPUSH
61112: LD_INT 2
61114: PUSH
61115: LD_INT 30
61117: PUSH
61118: LD_INT 32
61120: PUSH
61121: EMPTY
61122: LIST
61123: LIST
61124: PUSH
61125: LD_INT 30
61127: PUSH
61128: LD_INT 33
61130: PUSH
61131: EMPTY
61132: LIST
61133: LIST
61134: PUSH
61135: EMPTY
61136: LIST
61137: LIST
61138: LIST
61139: PPUSH
61140: CALL_OW 72
61144: PPUSH
61145: CALL_OW 1
61149: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
61150: LD_ADDR_EXP 70
61154: PUSH
61155: LD_EXP 70
61159: PPUSH
61160: LD_VAR 0 2
61164: PPUSH
61165: LD_EXP 61
61169: PUSH
61170: LD_VAR 0 2
61174: ARRAY
61175: PPUSH
61176: LD_INT 2
61178: PUSH
61179: LD_INT 30
61181: PUSH
61182: LD_INT 32
61184: PUSH
61185: EMPTY
61186: LIST
61187: LIST
61188: PUSH
61189: LD_INT 30
61191: PUSH
61192: LD_INT 31
61194: PUSH
61195: EMPTY
61196: LIST
61197: LIST
61198: PUSH
61199: EMPTY
61200: LIST
61201: LIST
61202: LIST
61203: PUSH
61204: LD_INT 58
61206: PUSH
61207: EMPTY
61208: LIST
61209: PUSH
61210: EMPTY
61211: LIST
61212: LIST
61213: PPUSH
61214: CALL_OW 72
61218: PPUSH
61219: CALL_OW 1
61223: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
61224: LD_ADDR_EXP 71
61228: PUSH
61229: LD_EXP 71
61233: PPUSH
61234: LD_VAR 0 2
61238: PPUSH
61239: EMPTY
61240: PPUSH
61241: CALL_OW 1
61245: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
61246: LD_ADDR_EXP 75
61250: PUSH
61251: LD_EXP 75
61255: PPUSH
61256: LD_VAR 0 2
61260: PPUSH
61261: EMPTY
61262: PPUSH
61263: CALL_OW 1
61267: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
61268: LD_ADDR_EXP 74
61272: PUSH
61273: LD_EXP 74
61277: PPUSH
61278: LD_VAR 0 2
61282: PPUSH
61283: EMPTY
61284: PPUSH
61285: CALL_OW 1
61289: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
61290: LD_ADDR_EXP 76
61294: PUSH
61295: LD_EXP 76
61299: PPUSH
61300: LD_VAR 0 2
61304: PPUSH
61305: EMPTY
61306: PPUSH
61307: CALL_OW 1
61311: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
61312: LD_ADDR_EXP 77
61316: PUSH
61317: LD_EXP 77
61321: PPUSH
61322: LD_VAR 0 2
61326: PPUSH
61327: EMPTY
61328: PPUSH
61329: CALL_OW 1
61333: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
61334: LD_ADDR_EXP 78
61338: PUSH
61339: LD_EXP 78
61343: PPUSH
61344: LD_VAR 0 2
61348: PPUSH
61349: EMPTY
61350: PPUSH
61351: CALL_OW 1
61355: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
61356: LD_ADDR_EXP 79
61360: PUSH
61361: LD_EXP 79
61365: PPUSH
61366: LD_VAR 0 2
61370: PPUSH
61371: EMPTY
61372: PPUSH
61373: CALL_OW 1
61377: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
61378: LD_ADDR_EXP 80
61382: PUSH
61383: LD_EXP 80
61387: PPUSH
61388: LD_VAR 0 2
61392: PPUSH
61393: EMPTY
61394: PPUSH
61395: CALL_OW 1
61399: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
61400: LD_ADDR_EXP 81
61404: PUSH
61405: LD_EXP 81
61409: PPUSH
61410: LD_VAR 0 2
61414: PPUSH
61415: EMPTY
61416: PPUSH
61417: CALL_OW 1
61421: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
61422: LD_ADDR_EXP 82
61426: PUSH
61427: LD_EXP 82
61431: PPUSH
61432: LD_VAR 0 2
61436: PPUSH
61437: EMPTY
61438: PPUSH
61439: CALL_OW 1
61443: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
61444: LD_ADDR_EXP 83
61448: PUSH
61449: LD_EXP 83
61453: PPUSH
61454: LD_VAR 0 2
61458: PPUSH
61459: EMPTY
61460: PPUSH
61461: CALL_OW 1
61465: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
61466: LD_ADDR_EXP 72
61470: PUSH
61471: LD_EXP 72
61475: PPUSH
61476: LD_VAR 0 2
61480: PPUSH
61481: LD_INT 0
61483: PPUSH
61484: CALL_OW 1
61488: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
61489: LD_ADDR_EXP 85
61493: PUSH
61494: LD_EXP 85
61498: PPUSH
61499: LD_VAR 0 2
61503: PPUSH
61504: LD_INT 0
61506: PPUSH
61507: CALL_OW 1
61511: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
61512: LD_ADDR_EXP 73
61516: PUSH
61517: LD_EXP 73
61521: PPUSH
61522: LD_VAR 0 2
61526: PPUSH
61527: EMPTY
61528: PPUSH
61529: CALL_OW 1
61533: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
61534: LD_ADDR_EXP 84
61538: PUSH
61539: LD_EXP 84
61543: PPUSH
61544: LD_VAR 0 2
61548: PPUSH
61549: LD_INT 0
61551: PPUSH
61552: CALL_OW 1
61556: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
61557: LD_ADDR_EXP 86
61561: PUSH
61562: LD_EXP 86
61566: PPUSH
61567: LD_VAR 0 2
61571: PPUSH
61572: EMPTY
61573: PPUSH
61574: CALL_OW 1
61578: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
61579: LD_ADDR_EXP 89
61583: PUSH
61584: LD_EXP 89
61588: PPUSH
61589: LD_VAR 0 2
61593: PPUSH
61594: LD_INT 0
61596: PPUSH
61597: CALL_OW 1
61601: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
61602: LD_ADDR_EXP 90
61606: PUSH
61607: LD_EXP 90
61611: PPUSH
61612: LD_VAR 0 2
61616: PPUSH
61617: EMPTY
61618: PPUSH
61619: CALL_OW 1
61623: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61624: LD_ADDR_EXP 91
61628: PUSH
61629: LD_EXP 91
61633: PPUSH
61634: LD_VAR 0 2
61638: PPUSH
61639: EMPTY
61640: PPUSH
61641: CALL_OW 1
61645: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61646: LD_ADDR_EXP 92
61650: PUSH
61651: LD_EXP 92
61655: PPUSH
61656: LD_VAR 0 2
61660: PPUSH
61661: EMPTY
61662: PPUSH
61663: CALL_OW 1
61667: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
61668: LD_ADDR_EXP 94
61672: PUSH
61673: LD_EXP 94
61677: PPUSH
61678: LD_VAR 0 2
61682: PPUSH
61683: LD_EXP 61
61687: PUSH
61688: LD_VAR 0 2
61692: ARRAY
61693: PPUSH
61694: LD_INT 2
61696: PUSH
61697: LD_INT 30
61699: PUSH
61700: LD_INT 6
61702: PUSH
61703: EMPTY
61704: LIST
61705: LIST
61706: PUSH
61707: LD_INT 30
61709: PUSH
61710: LD_INT 7
61712: PUSH
61713: EMPTY
61714: LIST
61715: LIST
61716: PUSH
61717: LD_INT 30
61719: PUSH
61720: LD_INT 8
61722: PUSH
61723: EMPTY
61724: LIST
61725: LIST
61726: PUSH
61727: EMPTY
61728: LIST
61729: LIST
61730: LIST
61731: LIST
61732: PPUSH
61733: CALL_OW 72
61737: PPUSH
61738: CALL_OW 1
61742: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
61743: LD_ADDR_EXP 95
61747: PUSH
61748: LD_EXP 95
61752: PPUSH
61753: LD_VAR 0 2
61757: PPUSH
61758: EMPTY
61759: PPUSH
61760: CALL_OW 1
61764: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
61765: LD_ADDR_EXP 96
61769: PUSH
61770: LD_EXP 96
61774: PPUSH
61775: LD_VAR 0 2
61779: PPUSH
61780: EMPTY
61781: PPUSH
61782: CALL_OW 1
61786: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
61787: LD_ADDR_EXP 97
61791: PUSH
61792: LD_EXP 97
61796: PPUSH
61797: LD_VAR 0 2
61801: PPUSH
61802: EMPTY
61803: PPUSH
61804: CALL_OW 1
61808: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
61809: LD_ADDR_EXP 98
61813: PUSH
61814: LD_EXP 98
61818: PPUSH
61819: LD_VAR 0 2
61823: PPUSH
61824: EMPTY
61825: PPUSH
61826: CALL_OW 1
61830: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
61831: LD_ADDR_EXP 99
61835: PUSH
61836: LD_EXP 99
61840: PPUSH
61841: LD_VAR 0 2
61845: PPUSH
61846: EMPTY
61847: PPUSH
61848: CALL_OW 1
61852: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
61853: LD_ADDR_EXP 100
61857: PUSH
61858: LD_EXP 100
61862: PPUSH
61863: LD_VAR 0 2
61867: PPUSH
61868: EMPTY
61869: PPUSH
61870: CALL_OW 1
61874: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
61875: LD_ADDR_EXP 101
61879: PUSH
61880: LD_EXP 101
61884: PPUSH
61885: LD_VAR 0 2
61889: PPUSH
61890: EMPTY
61891: PPUSH
61892: CALL_OW 1
61896: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
61897: LD_ADDR_EXP 102
61901: PUSH
61902: LD_EXP 102
61906: PPUSH
61907: LD_VAR 0 2
61911: PPUSH
61912: EMPTY
61913: PPUSH
61914: CALL_OW 1
61918: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
61919: LD_ADDR_EXP 103
61923: PUSH
61924: LD_EXP 103
61928: PPUSH
61929: LD_VAR 0 2
61933: PPUSH
61934: LD_INT 0
61936: PPUSH
61937: CALL_OW 1
61941: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
61942: LD_ADDR_EXP 104
61946: PUSH
61947: LD_EXP 104
61951: PPUSH
61952: LD_VAR 0 2
61956: PPUSH
61957: LD_INT 0
61959: PPUSH
61960: CALL_OW 1
61964: ST_TO_ADDR
// end ;
61965: GO 60866
61967: POP
61968: POP
// MC_InitSides ( ) ;
61969: CALL 62255 0 0
// MC_InitResearch ( ) ;
61973: CALL 61994 0 0
// CustomInitMacro ( ) ;
61977: CALL 219 0 0
// skirmish := true ;
61981: LD_ADDR_EXP 59
61985: PUSH
61986: LD_INT 1
61988: ST_TO_ADDR
// end ;
61989: LD_VAR 0 1
61993: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
61994: LD_INT 0
61996: PPUSH
61997: PPUSH
61998: PPUSH
61999: PPUSH
62000: PPUSH
62001: PPUSH
// if not mc_bases then
62002: LD_EXP 61
62006: NOT
62007: IFFALSE 62011
// exit ;
62009: GO 62250
// for i = 1 to 8 do
62011: LD_ADDR_VAR 0 2
62015: PUSH
62016: DOUBLE
62017: LD_INT 1
62019: DEC
62020: ST_TO_ADDR
62021: LD_INT 8
62023: PUSH
62024: FOR_TO
62025: IFFALSE 62051
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
62027: LD_ADDR_EXP 88
62031: PUSH
62032: LD_EXP 88
62036: PPUSH
62037: LD_VAR 0 2
62041: PPUSH
62042: EMPTY
62043: PPUSH
62044: CALL_OW 1
62048: ST_TO_ADDR
62049: GO 62024
62051: POP
62052: POP
// tmp := [ ] ;
62053: LD_ADDR_VAR 0 5
62057: PUSH
62058: EMPTY
62059: ST_TO_ADDR
// for i = 1 to mc_sides do
62060: LD_ADDR_VAR 0 2
62064: PUSH
62065: DOUBLE
62066: LD_INT 1
62068: DEC
62069: ST_TO_ADDR
62070: LD_EXP 87
62074: PUSH
62075: FOR_TO
62076: IFFALSE 62134
// if not mc_sides [ i ] in tmp then
62078: LD_EXP 87
62082: PUSH
62083: LD_VAR 0 2
62087: ARRAY
62088: PUSH
62089: LD_VAR 0 5
62093: IN
62094: NOT
62095: IFFALSE 62132
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
62097: LD_ADDR_VAR 0 5
62101: PUSH
62102: LD_VAR 0 5
62106: PPUSH
62107: LD_VAR 0 5
62111: PUSH
62112: LD_INT 1
62114: PLUS
62115: PPUSH
62116: LD_EXP 87
62120: PUSH
62121: LD_VAR 0 2
62125: ARRAY
62126: PPUSH
62127: CALL_OW 2
62131: ST_TO_ADDR
62132: GO 62075
62134: POP
62135: POP
// if not tmp then
62136: LD_VAR 0 5
62140: NOT
62141: IFFALSE 62145
// exit ;
62143: GO 62250
// for j in tmp do
62145: LD_ADDR_VAR 0 3
62149: PUSH
62150: LD_VAR 0 5
62154: PUSH
62155: FOR_IN
62156: IFFALSE 62248
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
62158: LD_ADDR_VAR 0 6
62162: PUSH
62163: LD_INT 22
62165: PUSH
62166: LD_VAR 0 3
62170: PUSH
62171: EMPTY
62172: LIST
62173: LIST
62174: PPUSH
62175: CALL_OW 69
62179: ST_TO_ADDR
// if not un then
62180: LD_VAR 0 6
62184: NOT
62185: IFFALSE 62189
// continue ;
62187: GO 62155
// nation := GetNation ( un [ 1 ] ) ;
62189: LD_ADDR_VAR 0 4
62193: PUSH
62194: LD_VAR 0 6
62198: PUSH
62199: LD_INT 1
62201: ARRAY
62202: PPUSH
62203: CALL_OW 248
62207: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
62208: LD_ADDR_EXP 88
62212: PUSH
62213: LD_EXP 88
62217: PPUSH
62218: LD_VAR 0 3
62222: PPUSH
62223: LD_VAR 0 3
62227: PPUSH
62228: LD_VAR 0 4
62232: PPUSH
62233: LD_INT 1
62235: PPUSH
62236: CALL 16498 0 3
62240: PPUSH
62241: CALL_OW 1
62245: ST_TO_ADDR
// end ;
62246: GO 62155
62248: POP
62249: POP
// end ;
62250: LD_VAR 0 1
62254: RET
// export function MC_InitSides ( ) ; var i ; begin
62255: LD_INT 0
62257: PPUSH
62258: PPUSH
// if not mc_bases then
62259: LD_EXP 61
62263: NOT
62264: IFFALSE 62268
// exit ;
62266: GO 62342
// for i = 1 to mc_bases do
62268: LD_ADDR_VAR 0 2
62272: PUSH
62273: DOUBLE
62274: LD_INT 1
62276: DEC
62277: ST_TO_ADDR
62278: LD_EXP 61
62282: PUSH
62283: FOR_TO
62284: IFFALSE 62340
// if mc_bases [ i ] then
62286: LD_EXP 61
62290: PUSH
62291: LD_VAR 0 2
62295: ARRAY
62296: IFFALSE 62338
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
62298: LD_ADDR_EXP 87
62302: PUSH
62303: LD_EXP 87
62307: PPUSH
62308: LD_VAR 0 2
62312: PPUSH
62313: LD_EXP 61
62317: PUSH
62318: LD_VAR 0 2
62322: ARRAY
62323: PUSH
62324: LD_INT 1
62326: ARRAY
62327: PPUSH
62328: CALL_OW 255
62332: PPUSH
62333: CALL_OW 1
62337: ST_TO_ADDR
62338: GO 62283
62340: POP
62341: POP
// end ;
62342: LD_VAR 0 1
62346: RET
// every 0 0$03 trigger skirmish do
62347: LD_EXP 59
62351: IFFALSE 62505
62353: GO 62355
62355: DISABLE
// begin enable ;
62356: ENABLE
// MC_CheckBuildings ( ) ;
62357: CALL 67017 0 0
// MC_CheckPeopleLife ( ) ;
62361: CALL 67178 0 0
// RaiseSailEvent ( 100 ) ;
62365: LD_INT 100
62367: PPUSH
62368: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
62372: LD_INT 103
62374: PPUSH
62375: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
62379: LD_INT 104
62381: PPUSH
62382: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
62386: LD_INT 105
62388: PPUSH
62389: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
62393: LD_INT 106
62395: PPUSH
62396: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
62400: LD_INT 107
62402: PPUSH
62403: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
62407: LD_INT 108
62409: PPUSH
62410: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
62414: LD_INT 109
62416: PPUSH
62417: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
62421: LD_INT 110
62423: PPUSH
62424: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
62428: LD_INT 111
62430: PPUSH
62431: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
62435: LD_INT 112
62437: PPUSH
62438: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
62442: LD_INT 113
62444: PPUSH
62445: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
62449: LD_INT 120
62451: PPUSH
62452: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
62456: LD_INT 121
62458: PPUSH
62459: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
62463: LD_INT 122
62465: PPUSH
62466: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
62470: LD_INT 123
62472: PPUSH
62473: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
62477: LD_INT 124
62479: PPUSH
62480: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
62484: LD_INT 125
62486: PPUSH
62487: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
62491: LD_INT 126
62493: PPUSH
62494: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
62498: LD_INT 200
62500: PPUSH
62501: CALL_OW 427
// end ;
62505: END
// on SailEvent ( event ) do begin if event < 100 then
62506: LD_VAR 0 1
62510: PUSH
62511: LD_INT 100
62513: LESS
62514: IFFALSE 62525
// CustomEvent ( event ) ;
62516: LD_VAR 0 1
62520: PPUSH
62521: CALL 15083 0 1
// if event = 100 then
62525: LD_VAR 0 1
62529: PUSH
62530: LD_INT 100
62532: EQUAL
62533: IFFALSE 62539
// MC_ClassManager ( ) ;
62535: CALL 62931 0 0
// if event = 101 then
62539: LD_VAR 0 1
62543: PUSH
62544: LD_INT 101
62546: EQUAL
62547: IFFALSE 62553
// MC_RepairBuildings ( ) ;
62549: CALL 67763 0 0
// if event = 102 then
62553: LD_VAR 0 1
62557: PUSH
62558: LD_INT 102
62560: EQUAL
62561: IFFALSE 62567
// MC_Heal ( ) ;
62563: CALL 68698 0 0
// if event = 103 then
62567: LD_VAR 0 1
62571: PUSH
62572: LD_INT 103
62574: EQUAL
62575: IFFALSE 62581
// MC_Build ( ) ;
62577: CALL 69120 0 0
// if event = 104 then
62581: LD_VAR 0 1
62585: PUSH
62586: LD_INT 104
62588: EQUAL
62589: IFFALSE 62595
// MC_TurretWeapon ( ) ;
62591: CALL 70754 0 0
// if event = 105 then
62595: LD_VAR 0 1
62599: PUSH
62600: LD_INT 105
62602: EQUAL
62603: IFFALSE 62609
// MC_BuildUpgrade ( ) ;
62605: CALL 70305 0 0
// if event = 106 then
62609: LD_VAR 0 1
62613: PUSH
62614: LD_INT 106
62616: EQUAL
62617: IFFALSE 62623
// MC_PlantMines ( ) ;
62619: CALL 71184 0 0
// if event = 107 then
62623: LD_VAR 0 1
62627: PUSH
62628: LD_INT 107
62630: EQUAL
62631: IFFALSE 62637
// MC_CollectCrates ( ) ;
62633: CALL 71982 0 0
// if event = 108 then
62637: LD_VAR 0 1
62641: PUSH
62642: LD_INT 108
62644: EQUAL
62645: IFFALSE 62651
// MC_LinkRemoteControl ( ) ;
62647: CALL 73832 0 0
// if event = 109 then
62651: LD_VAR 0 1
62655: PUSH
62656: LD_INT 109
62658: EQUAL
62659: IFFALSE 62665
// MC_ProduceVehicle ( ) ;
62661: CALL 74013 0 0
// if event = 110 then
62665: LD_VAR 0 1
62669: PUSH
62670: LD_INT 110
62672: EQUAL
62673: IFFALSE 62679
// MC_SendAttack ( ) ;
62675: CALL 74479 0 0
// if event = 111 then
62679: LD_VAR 0 1
62683: PUSH
62684: LD_INT 111
62686: EQUAL
62687: IFFALSE 62693
// MC_Defend ( ) ;
62689: CALL 74587 0 0
// if event = 112 then
62693: LD_VAR 0 1
62697: PUSH
62698: LD_INT 112
62700: EQUAL
62701: IFFALSE 62707
// MC_Research ( ) ;
62703: CALL 75467 0 0
// if event = 113 then
62707: LD_VAR 0 1
62711: PUSH
62712: LD_INT 113
62714: EQUAL
62715: IFFALSE 62721
// MC_MinesTrigger ( ) ;
62717: CALL 76581 0 0
// if event = 120 then
62721: LD_VAR 0 1
62725: PUSH
62726: LD_INT 120
62728: EQUAL
62729: IFFALSE 62735
// MC_RepairVehicle ( ) ;
62731: CALL 76680 0 0
// if event = 121 then
62735: LD_VAR 0 1
62739: PUSH
62740: LD_INT 121
62742: EQUAL
62743: IFFALSE 62749
// MC_TameApe ( ) ;
62745: CALL 77449 0 0
// if event = 122 then
62749: LD_VAR 0 1
62753: PUSH
62754: LD_INT 122
62756: EQUAL
62757: IFFALSE 62763
// MC_ChangeApeClass ( ) ;
62759: CALL 78278 0 0
// if event = 123 then
62763: LD_VAR 0 1
62767: PUSH
62768: LD_INT 123
62770: EQUAL
62771: IFFALSE 62777
// MC_Bazooka ( ) ;
62773: CALL 78928 0 0
// if event = 124 then
62777: LD_VAR 0 1
62781: PUSH
62782: LD_INT 124
62784: EQUAL
62785: IFFALSE 62791
// MC_TeleportExit ( ) ;
62787: CALL 79126 0 0
// if event = 125 then
62791: LD_VAR 0 1
62795: PUSH
62796: LD_INT 125
62798: EQUAL
62799: IFFALSE 62805
// MC_Deposits ( ) ;
62801: CALL 79773 0 0
// if event = 126 then
62805: LD_VAR 0 1
62809: PUSH
62810: LD_INT 126
62812: EQUAL
62813: IFFALSE 62819
// MC_RemoteDriver ( ) ;
62815: CALL 80398 0 0
// if event = 200 then
62819: LD_VAR 0 1
62823: PUSH
62824: LD_INT 200
62826: EQUAL
62827: IFFALSE 62833
// MC_Idle ( ) ;
62829: CALL 82305 0 0
// end ;
62833: PPOPN 1
62835: END
// export function MC_Reset ( base , tag ) ; var i ; begin
62836: LD_INT 0
62838: PPUSH
62839: PPUSH
// if not mc_bases [ base ] or not tag then
62840: LD_EXP 61
62844: PUSH
62845: LD_VAR 0 1
62849: ARRAY
62850: NOT
62851: PUSH
62852: LD_VAR 0 2
62856: NOT
62857: OR
62858: IFFALSE 62862
// exit ;
62860: GO 62926
// for i in mc_bases [ base ] union mc_ape [ base ] do
62862: LD_ADDR_VAR 0 4
62866: PUSH
62867: LD_EXP 61
62871: PUSH
62872: LD_VAR 0 1
62876: ARRAY
62877: PUSH
62878: LD_EXP 90
62882: PUSH
62883: LD_VAR 0 1
62887: ARRAY
62888: UNION
62889: PUSH
62890: FOR_IN
62891: IFFALSE 62924
// if GetTag ( i ) = tag then
62893: LD_VAR 0 4
62897: PPUSH
62898: CALL_OW 110
62902: PUSH
62903: LD_VAR 0 2
62907: EQUAL
62908: IFFALSE 62922
// SetTag ( i , 0 ) ;
62910: LD_VAR 0 4
62914: PPUSH
62915: LD_INT 0
62917: PPUSH
62918: CALL_OW 109
62922: GO 62890
62924: POP
62925: POP
// end ;
62926: LD_VAR 0 3
62930: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
62931: LD_INT 0
62933: PPUSH
62934: PPUSH
62935: PPUSH
62936: PPUSH
62937: PPUSH
62938: PPUSH
62939: PPUSH
62940: PPUSH
// if not mc_bases then
62941: LD_EXP 61
62945: NOT
62946: IFFALSE 62950
// exit ;
62948: GO 63399
// for i = 1 to mc_bases do
62950: LD_ADDR_VAR 0 2
62954: PUSH
62955: DOUBLE
62956: LD_INT 1
62958: DEC
62959: ST_TO_ADDR
62960: LD_EXP 61
62964: PUSH
62965: FOR_TO
62966: IFFALSE 63397
// begin tmp := MC_ClassCheckReq ( i ) ;
62968: LD_ADDR_VAR 0 4
62972: PUSH
62973: LD_VAR 0 2
62977: PPUSH
62978: CALL 63404 0 1
62982: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
62983: LD_ADDR_EXP 102
62987: PUSH
62988: LD_EXP 102
62992: PPUSH
62993: LD_VAR 0 2
62997: PPUSH
62998: LD_VAR 0 4
63002: PPUSH
63003: CALL_OW 1
63007: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
63008: LD_ADDR_VAR 0 6
63012: PUSH
63013: LD_EXP 61
63017: PUSH
63018: LD_VAR 0 2
63022: ARRAY
63023: PPUSH
63024: LD_INT 2
63026: PUSH
63027: LD_INT 30
63029: PUSH
63030: LD_INT 4
63032: PUSH
63033: EMPTY
63034: LIST
63035: LIST
63036: PUSH
63037: LD_INT 30
63039: PUSH
63040: LD_INT 5
63042: PUSH
63043: EMPTY
63044: LIST
63045: LIST
63046: PUSH
63047: EMPTY
63048: LIST
63049: LIST
63050: LIST
63051: PPUSH
63052: CALL_OW 72
63056: PUSH
63057: LD_EXP 61
63061: PUSH
63062: LD_VAR 0 2
63066: ARRAY
63067: PPUSH
63068: LD_INT 2
63070: PUSH
63071: LD_INT 30
63073: PUSH
63074: LD_INT 0
63076: PUSH
63077: EMPTY
63078: LIST
63079: LIST
63080: PUSH
63081: LD_INT 30
63083: PUSH
63084: LD_INT 1
63086: PUSH
63087: EMPTY
63088: LIST
63089: LIST
63090: PUSH
63091: EMPTY
63092: LIST
63093: LIST
63094: LIST
63095: PPUSH
63096: CALL_OW 72
63100: PUSH
63101: LD_EXP 61
63105: PUSH
63106: LD_VAR 0 2
63110: ARRAY
63111: PPUSH
63112: LD_INT 30
63114: PUSH
63115: LD_INT 3
63117: PUSH
63118: EMPTY
63119: LIST
63120: LIST
63121: PPUSH
63122: CALL_OW 72
63126: PUSH
63127: LD_EXP 61
63131: PUSH
63132: LD_VAR 0 2
63136: ARRAY
63137: PPUSH
63138: LD_INT 2
63140: PUSH
63141: LD_INT 30
63143: PUSH
63144: LD_INT 6
63146: PUSH
63147: EMPTY
63148: LIST
63149: LIST
63150: PUSH
63151: LD_INT 30
63153: PUSH
63154: LD_INT 7
63156: PUSH
63157: EMPTY
63158: LIST
63159: LIST
63160: PUSH
63161: LD_INT 30
63163: PUSH
63164: LD_INT 8
63166: PUSH
63167: EMPTY
63168: LIST
63169: LIST
63170: PUSH
63171: EMPTY
63172: LIST
63173: LIST
63174: LIST
63175: LIST
63176: PPUSH
63177: CALL_OW 72
63181: PUSH
63182: EMPTY
63183: LIST
63184: LIST
63185: LIST
63186: LIST
63187: ST_TO_ADDR
// for j := 1 to 4 do
63188: LD_ADDR_VAR 0 3
63192: PUSH
63193: DOUBLE
63194: LD_INT 1
63196: DEC
63197: ST_TO_ADDR
63198: LD_INT 4
63200: PUSH
63201: FOR_TO
63202: IFFALSE 63393
// begin if not tmp [ j ] then
63204: LD_VAR 0 4
63208: PUSH
63209: LD_VAR 0 3
63213: ARRAY
63214: NOT
63215: IFFALSE 63219
// continue ;
63217: GO 63201
// for p in tmp [ j ] do
63219: LD_ADDR_VAR 0 5
63223: PUSH
63224: LD_VAR 0 4
63228: PUSH
63229: LD_VAR 0 3
63233: ARRAY
63234: PUSH
63235: FOR_IN
63236: IFFALSE 63389
// begin if not b [ j ] then
63238: LD_VAR 0 6
63242: PUSH
63243: LD_VAR 0 3
63247: ARRAY
63248: NOT
63249: IFFALSE 63253
// break ;
63251: GO 63389
// e := 0 ;
63253: LD_ADDR_VAR 0 7
63257: PUSH
63258: LD_INT 0
63260: ST_TO_ADDR
// for k in b [ j ] do
63261: LD_ADDR_VAR 0 8
63265: PUSH
63266: LD_VAR 0 6
63270: PUSH
63271: LD_VAR 0 3
63275: ARRAY
63276: PUSH
63277: FOR_IN
63278: IFFALSE 63305
// if IsNotFull ( k ) then
63280: LD_VAR 0 8
63284: PPUSH
63285: CALL 18619 0 1
63289: IFFALSE 63303
// begin e := k ;
63291: LD_ADDR_VAR 0 7
63295: PUSH
63296: LD_VAR 0 8
63300: ST_TO_ADDR
// break ;
63301: GO 63305
// end ;
63303: GO 63277
63305: POP
63306: POP
// if e and not UnitGoingToBuilding ( p , e ) then
63307: LD_VAR 0 7
63311: PUSH
63312: LD_VAR 0 5
63316: PPUSH
63317: LD_VAR 0 7
63321: PPUSH
63322: CALL 52769 0 2
63326: NOT
63327: AND
63328: IFFALSE 63387
// begin if IsInUnit ( p ) then
63330: LD_VAR 0 5
63334: PPUSH
63335: CALL_OW 310
63339: IFFALSE 63350
// ComExitBuilding ( p ) ;
63341: LD_VAR 0 5
63345: PPUSH
63346: CALL_OW 122
// ComEnterUnit ( p , e ) ;
63350: LD_VAR 0 5
63354: PPUSH
63355: LD_VAR 0 7
63359: PPUSH
63360: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
63364: LD_VAR 0 5
63368: PPUSH
63369: LD_VAR 0 3
63373: PPUSH
63374: CALL_OW 183
// AddComExitBuilding ( p ) ;
63378: LD_VAR 0 5
63382: PPUSH
63383: CALL_OW 182
// end ; end ;
63387: GO 63235
63389: POP
63390: POP
// end ;
63391: GO 63201
63393: POP
63394: POP
// end ;
63395: GO 62965
63397: POP
63398: POP
// end ;
63399: LD_VAR 0 1
63403: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
63404: LD_INT 0
63406: PPUSH
63407: PPUSH
63408: PPUSH
63409: PPUSH
63410: PPUSH
63411: PPUSH
63412: PPUSH
63413: PPUSH
63414: PPUSH
63415: PPUSH
63416: PPUSH
63417: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
63418: LD_ADDR_VAR 0 2
63422: PUSH
63423: LD_INT 0
63425: PUSH
63426: LD_INT 0
63428: PUSH
63429: LD_INT 0
63431: PUSH
63432: LD_INT 0
63434: PUSH
63435: EMPTY
63436: LIST
63437: LIST
63438: LIST
63439: LIST
63440: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63441: LD_VAR 0 1
63445: NOT
63446: PUSH
63447: LD_EXP 61
63451: PUSH
63452: LD_VAR 0 1
63456: ARRAY
63457: NOT
63458: OR
63459: PUSH
63460: LD_EXP 61
63464: PUSH
63465: LD_VAR 0 1
63469: ARRAY
63470: PPUSH
63471: LD_INT 2
63473: PUSH
63474: LD_INT 30
63476: PUSH
63477: LD_INT 0
63479: PUSH
63480: EMPTY
63481: LIST
63482: LIST
63483: PUSH
63484: LD_INT 30
63486: PUSH
63487: LD_INT 1
63489: PUSH
63490: EMPTY
63491: LIST
63492: LIST
63493: PUSH
63494: EMPTY
63495: LIST
63496: LIST
63497: LIST
63498: PPUSH
63499: CALL_OW 72
63503: NOT
63504: OR
63505: IFFALSE 63509
// exit ;
63507: GO 67012
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63509: LD_ADDR_VAR 0 4
63513: PUSH
63514: LD_EXP 61
63518: PUSH
63519: LD_VAR 0 1
63523: ARRAY
63524: PPUSH
63525: LD_INT 2
63527: PUSH
63528: LD_INT 25
63530: PUSH
63531: LD_INT 1
63533: PUSH
63534: EMPTY
63535: LIST
63536: LIST
63537: PUSH
63538: LD_INT 25
63540: PUSH
63541: LD_INT 2
63543: PUSH
63544: EMPTY
63545: LIST
63546: LIST
63547: PUSH
63548: LD_INT 25
63550: PUSH
63551: LD_INT 3
63553: PUSH
63554: EMPTY
63555: LIST
63556: LIST
63557: PUSH
63558: LD_INT 25
63560: PUSH
63561: LD_INT 4
63563: PUSH
63564: EMPTY
63565: LIST
63566: LIST
63567: PUSH
63568: LD_INT 25
63570: PUSH
63571: LD_INT 5
63573: PUSH
63574: EMPTY
63575: LIST
63576: LIST
63577: PUSH
63578: LD_INT 25
63580: PUSH
63581: LD_INT 8
63583: PUSH
63584: EMPTY
63585: LIST
63586: LIST
63587: PUSH
63588: LD_INT 25
63590: PUSH
63591: LD_INT 9
63593: PUSH
63594: EMPTY
63595: LIST
63596: LIST
63597: PUSH
63598: EMPTY
63599: LIST
63600: LIST
63601: LIST
63602: LIST
63603: LIST
63604: LIST
63605: LIST
63606: LIST
63607: PPUSH
63608: CALL_OW 72
63612: ST_TO_ADDR
// if not tmp then
63613: LD_VAR 0 4
63617: NOT
63618: IFFALSE 63622
// exit ;
63620: GO 67012
// for i in tmp do
63622: LD_ADDR_VAR 0 3
63626: PUSH
63627: LD_VAR 0 4
63631: PUSH
63632: FOR_IN
63633: IFFALSE 63664
// if GetTag ( i ) then
63635: LD_VAR 0 3
63639: PPUSH
63640: CALL_OW 110
63644: IFFALSE 63662
// tmp := tmp diff i ;
63646: LD_ADDR_VAR 0 4
63650: PUSH
63651: LD_VAR 0 4
63655: PUSH
63656: LD_VAR 0 3
63660: DIFF
63661: ST_TO_ADDR
63662: GO 63632
63664: POP
63665: POP
// if not tmp then
63666: LD_VAR 0 4
63670: NOT
63671: IFFALSE 63675
// exit ;
63673: GO 67012
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63675: LD_ADDR_VAR 0 5
63679: PUSH
63680: LD_EXP 61
63684: PUSH
63685: LD_VAR 0 1
63689: ARRAY
63690: PPUSH
63691: LD_INT 2
63693: PUSH
63694: LD_INT 25
63696: PUSH
63697: LD_INT 1
63699: PUSH
63700: EMPTY
63701: LIST
63702: LIST
63703: PUSH
63704: LD_INT 25
63706: PUSH
63707: LD_INT 5
63709: PUSH
63710: EMPTY
63711: LIST
63712: LIST
63713: PUSH
63714: LD_INT 25
63716: PUSH
63717: LD_INT 8
63719: PUSH
63720: EMPTY
63721: LIST
63722: LIST
63723: PUSH
63724: LD_INT 25
63726: PUSH
63727: LD_INT 9
63729: PUSH
63730: EMPTY
63731: LIST
63732: LIST
63733: PUSH
63734: EMPTY
63735: LIST
63736: LIST
63737: LIST
63738: LIST
63739: LIST
63740: PPUSH
63741: CALL_OW 72
63745: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
63746: LD_ADDR_VAR 0 6
63750: PUSH
63751: LD_EXP 61
63755: PUSH
63756: LD_VAR 0 1
63760: ARRAY
63761: PPUSH
63762: LD_INT 25
63764: PUSH
63765: LD_INT 2
63767: PUSH
63768: EMPTY
63769: LIST
63770: LIST
63771: PPUSH
63772: CALL_OW 72
63776: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
63777: LD_ADDR_VAR 0 7
63781: PUSH
63782: LD_EXP 61
63786: PUSH
63787: LD_VAR 0 1
63791: ARRAY
63792: PPUSH
63793: LD_INT 25
63795: PUSH
63796: LD_INT 3
63798: PUSH
63799: EMPTY
63800: LIST
63801: LIST
63802: PPUSH
63803: CALL_OW 72
63807: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
63808: LD_ADDR_VAR 0 8
63812: PUSH
63813: LD_EXP 61
63817: PUSH
63818: LD_VAR 0 1
63822: ARRAY
63823: PPUSH
63824: LD_INT 25
63826: PUSH
63827: LD_INT 4
63829: PUSH
63830: EMPTY
63831: LIST
63832: LIST
63833: PUSH
63834: LD_INT 24
63836: PUSH
63837: LD_INT 251
63839: PUSH
63840: EMPTY
63841: LIST
63842: LIST
63843: PUSH
63844: EMPTY
63845: LIST
63846: LIST
63847: PPUSH
63848: CALL_OW 72
63852: ST_TO_ADDR
// if mc_is_defending [ base ] then
63853: LD_EXP 104
63857: PUSH
63858: LD_VAR 0 1
63862: ARRAY
63863: IFFALSE 64324
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
63865: LD_ADDR_EXP 103
63869: PUSH
63870: LD_EXP 103
63874: PPUSH
63875: LD_VAR 0 1
63879: PPUSH
63880: LD_INT 4
63882: PPUSH
63883: CALL_OW 1
63887: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
63888: LD_ADDR_VAR 0 12
63892: PUSH
63893: LD_EXP 61
63897: PUSH
63898: LD_VAR 0 1
63902: ARRAY
63903: PPUSH
63904: LD_INT 2
63906: PUSH
63907: LD_INT 30
63909: PUSH
63910: LD_INT 4
63912: PUSH
63913: EMPTY
63914: LIST
63915: LIST
63916: PUSH
63917: LD_INT 30
63919: PUSH
63920: LD_INT 5
63922: PUSH
63923: EMPTY
63924: LIST
63925: LIST
63926: PUSH
63927: EMPTY
63928: LIST
63929: LIST
63930: LIST
63931: PPUSH
63932: CALL_OW 72
63936: ST_TO_ADDR
// if not b then
63937: LD_VAR 0 12
63941: NOT
63942: IFFALSE 63946
// exit ;
63944: GO 67012
// p := [ ] ;
63946: LD_ADDR_VAR 0 11
63950: PUSH
63951: EMPTY
63952: ST_TO_ADDR
// if sci >= 2 then
63953: LD_VAR 0 8
63957: PUSH
63958: LD_INT 2
63960: GREATEREQUAL
63961: IFFALSE 63992
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
63963: LD_ADDR_VAR 0 8
63967: PUSH
63968: LD_VAR 0 8
63972: PUSH
63973: LD_INT 1
63975: ARRAY
63976: PUSH
63977: LD_VAR 0 8
63981: PUSH
63982: LD_INT 2
63984: ARRAY
63985: PUSH
63986: EMPTY
63987: LIST
63988: LIST
63989: ST_TO_ADDR
63990: GO 64053
// if sci = 1 then
63992: LD_VAR 0 8
63996: PUSH
63997: LD_INT 1
63999: EQUAL
64000: IFFALSE 64021
// sci := [ sci [ 1 ] ] else
64002: LD_ADDR_VAR 0 8
64006: PUSH
64007: LD_VAR 0 8
64011: PUSH
64012: LD_INT 1
64014: ARRAY
64015: PUSH
64016: EMPTY
64017: LIST
64018: ST_TO_ADDR
64019: GO 64053
// if sci = 0 then
64021: LD_VAR 0 8
64025: PUSH
64026: LD_INT 0
64028: EQUAL
64029: IFFALSE 64053
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
64031: LD_ADDR_VAR 0 11
64035: PUSH
64036: LD_VAR 0 4
64040: PPUSH
64041: LD_INT 4
64043: PPUSH
64044: CALL 52641 0 2
64048: PUSH
64049: LD_INT 1
64051: ARRAY
64052: ST_TO_ADDR
// if eng > 4 then
64053: LD_VAR 0 6
64057: PUSH
64058: LD_INT 4
64060: GREATER
64061: IFFALSE 64107
// for i = eng downto 4 do
64063: LD_ADDR_VAR 0 3
64067: PUSH
64068: DOUBLE
64069: LD_VAR 0 6
64073: INC
64074: ST_TO_ADDR
64075: LD_INT 4
64077: PUSH
64078: FOR_DOWNTO
64079: IFFALSE 64105
// eng := eng diff eng [ i ] ;
64081: LD_ADDR_VAR 0 6
64085: PUSH
64086: LD_VAR 0 6
64090: PUSH
64091: LD_VAR 0 6
64095: PUSH
64096: LD_VAR 0 3
64100: ARRAY
64101: DIFF
64102: ST_TO_ADDR
64103: GO 64078
64105: POP
64106: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
64107: LD_ADDR_VAR 0 4
64111: PUSH
64112: LD_VAR 0 4
64116: PUSH
64117: LD_VAR 0 5
64121: PUSH
64122: LD_VAR 0 6
64126: UNION
64127: PUSH
64128: LD_VAR 0 7
64132: UNION
64133: PUSH
64134: LD_VAR 0 8
64138: UNION
64139: DIFF
64140: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
64141: LD_ADDR_VAR 0 13
64145: PUSH
64146: LD_EXP 61
64150: PUSH
64151: LD_VAR 0 1
64155: ARRAY
64156: PPUSH
64157: LD_INT 2
64159: PUSH
64160: LD_INT 30
64162: PUSH
64163: LD_INT 32
64165: PUSH
64166: EMPTY
64167: LIST
64168: LIST
64169: PUSH
64170: LD_INT 30
64172: PUSH
64173: LD_INT 31
64175: PUSH
64176: EMPTY
64177: LIST
64178: LIST
64179: PUSH
64180: EMPTY
64181: LIST
64182: LIST
64183: LIST
64184: PPUSH
64185: CALL_OW 72
64189: PUSH
64190: LD_EXP 61
64194: PUSH
64195: LD_VAR 0 1
64199: ARRAY
64200: PPUSH
64201: LD_INT 2
64203: PUSH
64204: LD_INT 30
64206: PUSH
64207: LD_INT 4
64209: PUSH
64210: EMPTY
64211: LIST
64212: LIST
64213: PUSH
64214: LD_INT 30
64216: PUSH
64217: LD_INT 5
64219: PUSH
64220: EMPTY
64221: LIST
64222: LIST
64223: PUSH
64224: EMPTY
64225: LIST
64226: LIST
64227: LIST
64228: PPUSH
64229: CALL_OW 72
64233: PUSH
64234: LD_INT 6
64236: MUL
64237: PLUS
64238: ST_TO_ADDR
// if bcount < tmp then
64239: LD_VAR 0 13
64243: PUSH
64244: LD_VAR 0 4
64248: LESS
64249: IFFALSE 64295
// for i = tmp downto bcount do
64251: LD_ADDR_VAR 0 3
64255: PUSH
64256: DOUBLE
64257: LD_VAR 0 4
64261: INC
64262: ST_TO_ADDR
64263: LD_VAR 0 13
64267: PUSH
64268: FOR_DOWNTO
64269: IFFALSE 64293
// tmp := Delete ( tmp , tmp ) ;
64271: LD_ADDR_VAR 0 4
64275: PUSH
64276: LD_VAR 0 4
64280: PPUSH
64281: LD_VAR 0 4
64285: PPUSH
64286: CALL_OW 3
64290: ST_TO_ADDR
64291: GO 64268
64293: POP
64294: POP
// result := [ tmp , 0 , 0 , p ] ;
64295: LD_ADDR_VAR 0 2
64299: PUSH
64300: LD_VAR 0 4
64304: PUSH
64305: LD_INT 0
64307: PUSH
64308: LD_INT 0
64310: PUSH
64311: LD_VAR 0 11
64315: PUSH
64316: EMPTY
64317: LIST
64318: LIST
64319: LIST
64320: LIST
64321: ST_TO_ADDR
// exit ;
64322: GO 67012
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
64324: LD_EXP 61
64328: PUSH
64329: LD_VAR 0 1
64333: ARRAY
64334: PPUSH
64335: LD_INT 2
64337: PUSH
64338: LD_INT 30
64340: PUSH
64341: LD_INT 6
64343: PUSH
64344: EMPTY
64345: LIST
64346: LIST
64347: PUSH
64348: LD_INT 30
64350: PUSH
64351: LD_INT 7
64353: PUSH
64354: EMPTY
64355: LIST
64356: LIST
64357: PUSH
64358: LD_INT 30
64360: PUSH
64361: LD_INT 8
64363: PUSH
64364: EMPTY
64365: LIST
64366: LIST
64367: PUSH
64368: EMPTY
64369: LIST
64370: LIST
64371: LIST
64372: LIST
64373: PPUSH
64374: CALL_OW 72
64378: NOT
64379: PUSH
64380: LD_EXP 61
64384: PUSH
64385: LD_VAR 0 1
64389: ARRAY
64390: PPUSH
64391: LD_INT 30
64393: PUSH
64394: LD_INT 3
64396: PUSH
64397: EMPTY
64398: LIST
64399: LIST
64400: PPUSH
64401: CALL_OW 72
64405: NOT
64406: AND
64407: IFFALSE 64479
// begin if eng = tmp then
64409: LD_VAR 0 6
64413: PUSH
64414: LD_VAR 0 4
64418: EQUAL
64419: IFFALSE 64423
// exit ;
64421: GO 67012
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
64423: LD_ADDR_EXP 103
64427: PUSH
64428: LD_EXP 103
64432: PPUSH
64433: LD_VAR 0 1
64437: PPUSH
64438: LD_INT 1
64440: PPUSH
64441: CALL_OW 1
64445: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
64446: LD_ADDR_VAR 0 2
64450: PUSH
64451: LD_INT 0
64453: PUSH
64454: LD_VAR 0 4
64458: PUSH
64459: LD_VAR 0 6
64463: DIFF
64464: PUSH
64465: LD_INT 0
64467: PUSH
64468: LD_INT 0
64470: PUSH
64471: EMPTY
64472: LIST
64473: LIST
64474: LIST
64475: LIST
64476: ST_TO_ADDR
// exit ;
64477: GO 67012
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
64479: LD_EXP 88
64483: PUSH
64484: LD_EXP 87
64488: PUSH
64489: LD_VAR 0 1
64493: ARRAY
64494: ARRAY
64495: PUSH
64496: LD_EXP 61
64500: PUSH
64501: LD_VAR 0 1
64505: ARRAY
64506: PPUSH
64507: LD_INT 2
64509: PUSH
64510: LD_INT 30
64512: PUSH
64513: LD_INT 6
64515: PUSH
64516: EMPTY
64517: LIST
64518: LIST
64519: PUSH
64520: LD_INT 30
64522: PUSH
64523: LD_INT 7
64525: PUSH
64526: EMPTY
64527: LIST
64528: LIST
64529: PUSH
64530: LD_INT 30
64532: PUSH
64533: LD_INT 8
64535: PUSH
64536: EMPTY
64537: LIST
64538: LIST
64539: PUSH
64540: EMPTY
64541: LIST
64542: LIST
64543: LIST
64544: LIST
64545: PPUSH
64546: CALL_OW 72
64550: AND
64551: PUSH
64552: LD_EXP 61
64556: PUSH
64557: LD_VAR 0 1
64561: ARRAY
64562: PPUSH
64563: LD_INT 30
64565: PUSH
64566: LD_INT 3
64568: PUSH
64569: EMPTY
64570: LIST
64571: LIST
64572: PPUSH
64573: CALL_OW 72
64577: NOT
64578: AND
64579: IFFALSE 64793
// begin if sci >= 6 then
64581: LD_VAR 0 8
64585: PUSH
64586: LD_INT 6
64588: GREATEREQUAL
64589: IFFALSE 64593
// exit ;
64591: GO 67012
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
64593: LD_ADDR_EXP 103
64597: PUSH
64598: LD_EXP 103
64602: PPUSH
64603: LD_VAR 0 1
64607: PPUSH
64608: LD_INT 2
64610: PPUSH
64611: CALL_OW 1
64615: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
64616: LD_ADDR_VAR 0 9
64620: PUSH
64621: LD_VAR 0 4
64625: PUSH
64626: LD_VAR 0 8
64630: DIFF
64631: PPUSH
64632: LD_INT 4
64634: PPUSH
64635: CALL 52641 0 2
64639: ST_TO_ADDR
// p := [ ] ;
64640: LD_ADDR_VAR 0 11
64644: PUSH
64645: EMPTY
64646: ST_TO_ADDR
// if sci < 6 and sort > 6 then
64647: LD_VAR 0 8
64651: PUSH
64652: LD_INT 6
64654: LESS
64655: PUSH
64656: LD_VAR 0 9
64660: PUSH
64661: LD_INT 6
64663: GREATER
64664: AND
64665: IFFALSE 64746
// begin for i = 1 to 6 - sci do
64667: LD_ADDR_VAR 0 3
64671: PUSH
64672: DOUBLE
64673: LD_INT 1
64675: DEC
64676: ST_TO_ADDR
64677: LD_INT 6
64679: PUSH
64680: LD_VAR 0 8
64684: MINUS
64685: PUSH
64686: FOR_TO
64687: IFFALSE 64742
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
64689: LD_ADDR_VAR 0 11
64693: PUSH
64694: LD_VAR 0 11
64698: PPUSH
64699: LD_VAR 0 11
64703: PUSH
64704: LD_INT 1
64706: PLUS
64707: PPUSH
64708: LD_VAR 0 9
64712: PUSH
64713: LD_INT 1
64715: ARRAY
64716: PPUSH
64717: CALL_OW 2
64721: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
64722: LD_ADDR_VAR 0 9
64726: PUSH
64727: LD_VAR 0 9
64731: PPUSH
64732: LD_INT 1
64734: PPUSH
64735: CALL_OW 3
64739: ST_TO_ADDR
// end ;
64740: GO 64686
64742: POP
64743: POP
// end else
64744: GO 64766
// if sort then
64746: LD_VAR 0 9
64750: IFFALSE 64766
// p := sort [ 1 ] ;
64752: LD_ADDR_VAR 0 11
64756: PUSH
64757: LD_VAR 0 9
64761: PUSH
64762: LD_INT 1
64764: ARRAY
64765: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
64766: LD_ADDR_VAR 0 2
64770: PUSH
64771: LD_INT 0
64773: PUSH
64774: LD_INT 0
64776: PUSH
64777: LD_INT 0
64779: PUSH
64780: LD_VAR 0 11
64784: PUSH
64785: EMPTY
64786: LIST
64787: LIST
64788: LIST
64789: LIST
64790: ST_TO_ADDR
// exit ;
64791: GO 67012
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
64793: LD_EXP 88
64797: PUSH
64798: LD_EXP 87
64802: PUSH
64803: LD_VAR 0 1
64807: ARRAY
64808: ARRAY
64809: PUSH
64810: LD_EXP 61
64814: PUSH
64815: LD_VAR 0 1
64819: ARRAY
64820: PPUSH
64821: LD_INT 2
64823: PUSH
64824: LD_INT 30
64826: PUSH
64827: LD_INT 6
64829: PUSH
64830: EMPTY
64831: LIST
64832: LIST
64833: PUSH
64834: LD_INT 30
64836: PUSH
64837: LD_INT 7
64839: PUSH
64840: EMPTY
64841: LIST
64842: LIST
64843: PUSH
64844: LD_INT 30
64846: PUSH
64847: LD_INT 8
64849: PUSH
64850: EMPTY
64851: LIST
64852: LIST
64853: PUSH
64854: EMPTY
64855: LIST
64856: LIST
64857: LIST
64858: LIST
64859: PPUSH
64860: CALL_OW 72
64864: AND
64865: PUSH
64866: LD_EXP 61
64870: PUSH
64871: LD_VAR 0 1
64875: ARRAY
64876: PPUSH
64877: LD_INT 30
64879: PUSH
64880: LD_INT 3
64882: PUSH
64883: EMPTY
64884: LIST
64885: LIST
64886: PPUSH
64887: CALL_OW 72
64891: AND
64892: IFFALSE 65626
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
64894: LD_ADDR_EXP 103
64898: PUSH
64899: LD_EXP 103
64903: PPUSH
64904: LD_VAR 0 1
64908: PPUSH
64909: LD_INT 3
64911: PPUSH
64912: CALL_OW 1
64916: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64917: LD_ADDR_VAR 0 2
64921: PUSH
64922: LD_INT 0
64924: PUSH
64925: LD_INT 0
64927: PUSH
64928: LD_INT 0
64930: PUSH
64931: LD_INT 0
64933: PUSH
64934: EMPTY
64935: LIST
64936: LIST
64937: LIST
64938: LIST
64939: ST_TO_ADDR
// if not eng then
64940: LD_VAR 0 6
64944: NOT
64945: IFFALSE 65008
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
64947: LD_ADDR_VAR 0 11
64951: PUSH
64952: LD_VAR 0 4
64956: PPUSH
64957: LD_INT 2
64959: PPUSH
64960: CALL 52641 0 2
64964: PUSH
64965: LD_INT 1
64967: ARRAY
64968: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
64969: LD_ADDR_VAR 0 2
64973: PUSH
64974: LD_VAR 0 2
64978: PPUSH
64979: LD_INT 2
64981: PPUSH
64982: LD_VAR 0 11
64986: PPUSH
64987: CALL_OW 1
64991: ST_TO_ADDR
// tmp := tmp diff p ;
64992: LD_ADDR_VAR 0 4
64996: PUSH
64997: LD_VAR 0 4
65001: PUSH
65002: LD_VAR 0 11
65006: DIFF
65007: ST_TO_ADDR
// end ; if tmp and sci < 6 then
65008: LD_VAR 0 4
65012: PUSH
65013: LD_VAR 0 8
65017: PUSH
65018: LD_INT 6
65020: LESS
65021: AND
65022: IFFALSE 65210
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
65024: LD_ADDR_VAR 0 9
65028: PUSH
65029: LD_VAR 0 4
65033: PUSH
65034: LD_VAR 0 8
65038: PUSH
65039: LD_VAR 0 7
65043: UNION
65044: DIFF
65045: PPUSH
65046: LD_INT 4
65048: PPUSH
65049: CALL 52641 0 2
65053: ST_TO_ADDR
// p := [ ] ;
65054: LD_ADDR_VAR 0 11
65058: PUSH
65059: EMPTY
65060: ST_TO_ADDR
// if sort then
65061: LD_VAR 0 9
65065: IFFALSE 65181
// for i = 1 to 6 - sci do
65067: LD_ADDR_VAR 0 3
65071: PUSH
65072: DOUBLE
65073: LD_INT 1
65075: DEC
65076: ST_TO_ADDR
65077: LD_INT 6
65079: PUSH
65080: LD_VAR 0 8
65084: MINUS
65085: PUSH
65086: FOR_TO
65087: IFFALSE 65179
// begin if i = sort then
65089: LD_VAR 0 3
65093: PUSH
65094: LD_VAR 0 9
65098: EQUAL
65099: IFFALSE 65103
// break ;
65101: GO 65179
// if GetClass ( i ) = 4 then
65103: LD_VAR 0 3
65107: PPUSH
65108: CALL_OW 257
65112: PUSH
65113: LD_INT 4
65115: EQUAL
65116: IFFALSE 65120
// continue ;
65118: GO 65086
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65120: LD_ADDR_VAR 0 11
65124: PUSH
65125: LD_VAR 0 11
65129: PPUSH
65130: LD_VAR 0 11
65134: PUSH
65135: LD_INT 1
65137: PLUS
65138: PPUSH
65139: LD_VAR 0 9
65143: PUSH
65144: LD_VAR 0 3
65148: ARRAY
65149: PPUSH
65150: CALL_OW 2
65154: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65155: LD_ADDR_VAR 0 4
65159: PUSH
65160: LD_VAR 0 4
65164: PUSH
65165: LD_VAR 0 9
65169: PUSH
65170: LD_VAR 0 3
65174: ARRAY
65175: DIFF
65176: ST_TO_ADDR
// end ;
65177: GO 65086
65179: POP
65180: POP
// if p then
65181: LD_VAR 0 11
65185: IFFALSE 65210
// result := Replace ( result , 4 , p ) ;
65187: LD_ADDR_VAR 0 2
65191: PUSH
65192: LD_VAR 0 2
65196: PPUSH
65197: LD_INT 4
65199: PPUSH
65200: LD_VAR 0 11
65204: PPUSH
65205: CALL_OW 1
65209: ST_TO_ADDR
// end ; if tmp and mech < 6 then
65210: LD_VAR 0 4
65214: PUSH
65215: LD_VAR 0 7
65219: PUSH
65220: LD_INT 6
65222: LESS
65223: AND
65224: IFFALSE 65412
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
65226: LD_ADDR_VAR 0 9
65230: PUSH
65231: LD_VAR 0 4
65235: PUSH
65236: LD_VAR 0 8
65240: PUSH
65241: LD_VAR 0 7
65245: UNION
65246: DIFF
65247: PPUSH
65248: LD_INT 3
65250: PPUSH
65251: CALL 52641 0 2
65255: ST_TO_ADDR
// p := [ ] ;
65256: LD_ADDR_VAR 0 11
65260: PUSH
65261: EMPTY
65262: ST_TO_ADDR
// if sort then
65263: LD_VAR 0 9
65267: IFFALSE 65383
// for i = 1 to 6 - mech do
65269: LD_ADDR_VAR 0 3
65273: PUSH
65274: DOUBLE
65275: LD_INT 1
65277: DEC
65278: ST_TO_ADDR
65279: LD_INT 6
65281: PUSH
65282: LD_VAR 0 7
65286: MINUS
65287: PUSH
65288: FOR_TO
65289: IFFALSE 65381
// begin if i = sort then
65291: LD_VAR 0 3
65295: PUSH
65296: LD_VAR 0 9
65300: EQUAL
65301: IFFALSE 65305
// break ;
65303: GO 65381
// if GetClass ( i ) = 3 then
65305: LD_VAR 0 3
65309: PPUSH
65310: CALL_OW 257
65314: PUSH
65315: LD_INT 3
65317: EQUAL
65318: IFFALSE 65322
// continue ;
65320: GO 65288
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65322: LD_ADDR_VAR 0 11
65326: PUSH
65327: LD_VAR 0 11
65331: PPUSH
65332: LD_VAR 0 11
65336: PUSH
65337: LD_INT 1
65339: PLUS
65340: PPUSH
65341: LD_VAR 0 9
65345: PUSH
65346: LD_VAR 0 3
65350: ARRAY
65351: PPUSH
65352: CALL_OW 2
65356: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65357: LD_ADDR_VAR 0 4
65361: PUSH
65362: LD_VAR 0 4
65366: PUSH
65367: LD_VAR 0 9
65371: PUSH
65372: LD_VAR 0 3
65376: ARRAY
65377: DIFF
65378: ST_TO_ADDR
// end ;
65379: GO 65288
65381: POP
65382: POP
// if p then
65383: LD_VAR 0 11
65387: IFFALSE 65412
// result := Replace ( result , 3 , p ) ;
65389: LD_ADDR_VAR 0 2
65393: PUSH
65394: LD_VAR 0 2
65398: PPUSH
65399: LD_INT 3
65401: PPUSH
65402: LD_VAR 0 11
65406: PPUSH
65407: CALL_OW 1
65411: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
65412: LD_VAR 0 4
65416: PUSH
65417: LD_INT 6
65419: GREATER
65420: PUSH
65421: LD_VAR 0 6
65425: PUSH
65426: LD_INT 6
65428: LESS
65429: AND
65430: IFFALSE 65624
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
65432: LD_ADDR_VAR 0 9
65436: PUSH
65437: LD_VAR 0 4
65441: PUSH
65442: LD_VAR 0 8
65446: PUSH
65447: LD_VAR 0 7
65451: UNION
65452: PUSH
65453: LD_VAR 0 6
65457: UNION
65458: DIFF
65459: PPUSH
65460: LD_INT 2
65462: PPUSH
65463: CALL 52641 0 2
65467: ST_TO_ADDR
// p := [ ] ;
65468: LD_ADDR_VAR 0 11
65472: PUSH
65473: EMPTY
65474: ST_TO_ADDR
// if sort then
65475: LD_VAR 0 9
65479: IFFALSE 65595
// for i = 1 to 6 - eng do
65481: LD_ADDR_VAR 0 3
65485: PUSH
65486: DOUBLE
65487: LD_INT 1
65489: DEC
65490: ST_TO_ADDR
65491: LD_INT 6
65493: PUSH
65494: LD_VAR 0 6
65498: MINUS
65499: PUSH
65500: FOR_TO
65501: IFFALSE 65593
// begin if i = sort then
65503: LD_VAR 0 3
65507: PUSH
65508: LD_VAR 0 9
65512: EQUAL
65513: IFFALSE 65517
// break ;
65515: GO 65593
// if GetClass ( i ) = 2 then
65517: LD_VAR 0 3
65521: PPUSH
65522: CALL_OW 257
65526: PUSH
65527: LD_INT 2
65529: EQUAL
65530: IFFALSE 65534
// continue ;
65532: GO 65500
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65534: LD_ADDR_VAR 0 11
65538: PUSH
65539: LD_VAR 0 11
65543: PPUSH
65544: LD_VAR 0 11
65548: PUSH
65549: LD_INT 1
65551: PLUS
65552: PPUSH
65553: LD_VAR 0 9
65557: PUSH
65558: LD_VAR 0 3
65562: ARRAY
65563: PPUSH
65564: CALL_OW 2
65568: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65569: LD_ADDR_VAR 0 4
65573: PUSH
65574: LD_VAR 0 4
65578: PUSH
65579: LD_VAR 0 9
65583: PUSH
65584: LD_VAR 0 3
65588: ARRAY
65589: DIFF
65590: ST_TO_ADDR
// end ;
65591: GO 65500
65593: POP
65594: POP
// if p then
65595: LD_VAR 0 11
65599: IFFALSE 65624
// result := Replace ( result , 2 , p ) ;
65601: LD_ADDR_VAR 0 2
65605: PUSH
65606: LD_VAR 0 2
65610: PPUSH
65611: LD_INT 2
65613: PPUSH
65614: LD_VAR 0 11
65618: PPUSH
65619: CALL_OW 1
65623: ST_TO_ADDR
// end ; exit ;
65624: GO 67012
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
65626: LD_EXP 88
65630: PUSH
65631: LD_EXP 87
65635: PUSH
65636: LD_VAR 0 1
65640: ARRAY
65641: ARRAY
65642: NOT
65643: PUSH
65644: LD_EXP 61
65648: PUSH
65649: LD_VAR 0 1
65653: ARRAY
65654: PPUSH
65655: LD_INT 30
65657: PUSH
65658: LD_INT 3
65660: PUSH
65661: EMPTY
65662: LIST
65663: LIST
65664: PPUSH
65665: CALL_OW 72
65669: AND
65670: PUSH
65671: LD_EXP 66
65675: PUSH
65676: LD_VAR 0 1
65680: ARRAY
65681: AND
65682: IFFALSE 66290
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
65684: LD_ADDR_EXP 103
65688: PUSH
65689: LD_EXP 103
65693: PPUSH
65694: LD_VAR 0 1
65698: PPUSH
65699: LD_INT 5
65701: PPUSH
65702: CALL_OW 1
65706: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
65707: LD_ADDR_VAR 0 2
65711: PUSH
65712: LD_INT 0
65714: PUSH
65715: LD_INT 0
65717: PUSH
65718: LD_INT 0
65720: PUSH
65721: LD_INT 0
65723: PUSH
65724: EMPTY
65725: LIST
65726: LIST
65727: LIST
65728: LIST
65729: ST_TO_ADDR
// if sci > 1 then
65730: LD_VAR 0 8
65734: PUSH
65735: LD_INT 1
65737: GREATER
65738: IFFALSE 65766
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
65740: LD_ADDR_VAR 0 4
65744: PUSH
65745: LD_VAR 0 4
65749: PUSH
65750: LD_VAR 0 8
65754: PUSH
65755: LD_VAR 0 8
65759: PUSH
65760: LD_INT 1
65762: ARRAY
65763: DIFF
65764: DIFF
65765: ST_TO_ADDR
// if tmp and not sci then
65766: LD_VAR 0 4
65770: PUSH
65771: LD_VAR 0 8
65775: NOT
65776: AND
65777: IFFALSE 65846
// begin sort := SortBySkill ( tmp , 4 ) ;
65779: LD_ADDR_VAR 0 9
65783: PUSH
65784: LD_VAR 0 4
65788: PPUSH
65789: LD_INT 4
65791: PPUSH
65792: CALL 52641 0 2
65796: ST_TO_ADDR
// if sort then
65797: LD_VAR 0 9
65801: IFFALSE 65817
// p := sort [ 1 ] ;
65803: LD_ADDR_VAR 0 11
65807: PUSH
65808: LD_VAR 0 9
65812: PUSH
65813: LD_INT 1
65815: ARRAY
65816: ST_TO_ADDR
// if p then
65817: LD_VAR 0 11
65821: IFFALSE 65846
// result := Replace ( result , 4 , p ) ;
65823: LD_ADDR_VAR 0 2
65827: PUSH
65828: LD_VAR 0 2
65832: PPUSH
65833: LD_INT 4
65835: PPUSH
65836: LD_VAR 0 11
65840: PPUSH
65841: CALL_OW 1
65845: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
65846: LD_ADDR_VAR 0 4
65850: PUSH
65851: LD_VAR 0 4
65855: PUSH
65856: LD_VAR 0 7
65860: DIFF
65861: ST_TO_ADDR
// if tmp and mech < 6 then
65862: LD_VAR 0 4
65866: PUSH
65867: LD_VAR 0 7
65871: PUSH
65872: LD_INT 6
65874: LESS
65875: AND
65876: IFFALSE 66064
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
65878: LD_ADDR_VAR 0 9
65882: PUSH
65883: LD_VAR 0 4
65887: PUSH
65888: LD_VAR 0 8
65892: PUSH
65893: LD_VAR 0 7
65897: UNION
65898: DIFF
65899: PPUSH
65900: LD_INT 3
65902: PPUSH
65903: CALL 52641 0 2
65907: ST_TO_ADDR
// p := [ ] ;
65908: LD_ADDR_VAR 0 11
65912: PUSH
65913: EMPTY
65914: ST_TO_ADDR
// if sort then
65915: LD_VAR 0 9
65919: IFFALSE 66035
// for i = 1 to 6 - mech do
65921: LD_ADDR_VAR 0 3
65925: PUSH
65926: DOUBLE
65927: LD_INT 1
65929: DEC
65930: ST_TO_ADDR
65931: LD_INT 6
65933: PUSH
65934: LD_VAR 0 7
65938: MINUS
65939: PUSH
65940: FOR_TO
65941: IFFALSE 66033
// begin if i = sort then
65943: LD_VAR 0 3
65947: PUSH
65948: LD_VAR 0 9
65952: EQUAL
65953: IFFALSE 65957
// break ;
65955: GO 66033
// if GetClass ( i ) = 3 then
65957: LD_VAR 0 3
65961: PPUSH
65962: CALL_OW 257
65966: PUSH
65967: LD_INT 3
65969: EQUAL
65970: IFFALSE 65974
// continue ;
65972: GO 65940
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65974: LD_ADDR_VAR 0 11
65978: PUSH
65979: LD_VAR 0 11
65983: PPUSH
65984: LD_VAR 0 11
65988: PUSH
65989: LD_INT 1
65991: PLUS
65992: PPUSH
65993: LD_VAR 0 9
65997: PUSH
65998: LD_VAR 0 3
66002: ARRAY
66003: PPUSH
66004: CALL_OW 2
66008: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66009: LD_ADDR_VAR 0 4
66013: PUSH
66014: LD_VAR 0 4
66018: PUSH
66019: LD_VAR 0 9
66023: PUSH
66024: LD_VAR 0 3
66028: ARRAY
66029: DIFF
66030: ST_TO_ADDR
// end ;
66031: GO 65940
66033: POP
66034: POP
// if p then
66035: LD_VAR 0 11
66039: IFFALSE 66064
// result := Replace ( result , 3 , p ) ;
66041: LD_ADDR_VAR 0 2
66045: PUSH
66046: LD_VAR 0 2
66050: PPUSH
66051: LD_INT 3
66053: PPUSH
66054: LD_VAR 0 11
66058: PPUSH
66059: CALL_OW 1
66063: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
66064: LD_ADDR_VAR 0 4
66068: PUSH
66069: LD_VAR 0 4
66073: PUSH
66074: LD_VAR 0 6
66078: DIFF
66079: ST_TO_ADDR
// if tmp and eng < 6 then
66080: LD_VAR 0 4
66084: PUSH
66085: LD_VAR 0 6
66089: PUSH
66090: LD_INT 6
66092: LESS
66093: AND
66094: IFFALSE 66288
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
66096: LD_ADDR_VAR 0 9
66100: PUSH
66101: LD_VAR 0 4
66105: PUSH
66106: LD_VAR 0 8
66110: PUSH
66111: LD_VAR 0 7
66115: UNION
66116: PUSH
66117: LD_VAR 0 6
66121: UNION
66122: DIFF
66123: PPUSH
66124: LD_INT 2
66126: PPUSH
66127: CALL 52641 0 2
66131: ST_TO_ADDR
// p := [ ] ;
66132: LD_ADDR_VAR 0 11
66136: PUSH
66137: EMPTY
66138: ST_TO_ADDR
// if sort then
66139: LD_VAR 0 9
66143: IFFALSE 66259
// for i = 1 to 6 - eng do
66145: LD_ADDR_VAR 0 3
66149: PUSH
66150: DOUBLE
66151: LD_INT 1
66153: DEC
66154: ST_TO_ADDR
66155: LD_INT 6
66157: PUSH
66158: LD_VAR 0 6
66162: MINUS
66163: PUSH
66164: FOR_TO
66165: IFFALSE 66257
// begin if i = sort then
66167: LD_VAR 0 3
66171: PUSH
66172: LD_VAR 0 9
66176: EQUAL
66177: IFFALSE 66181
// break ;
66179: GO 66257
// if GetClass ( i ) = 2 then
66181: LD_VAR 0 3
66185: PPUSH
66186: CALL_OW 257
66190: PUSH
66191: LD_INT 2
66193: EQUAL
66194: IFFALSE 66198
// continue ;
66196: GO 66164
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66198: LD_ADDR_VAR 0 11
66202: PUSH
66203: LD_VAR 0 11
66207: PPUSH
66208: LD_VAR 0 11
66212: PUSH
66213: LD_INT 1
66215: PLUS
66216: PPUSH
66217: LD_VAR 0 9
66221: PUSH
66222: LD_VAR 0 3
66226: ARRAY
66227: PPUSH
66228: CALL_OW 2
66232: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66233: LD_ADDR_VAR 0 4
66237: PUSH
66238: LD_VAR 0 4
66242: PUSH
66243: LD_VAR 0 9
66247: PUSH
66248: LD_VAR 0 3
66252: ARRAY
66253: DIFF
66254: ST_TO_ADDR
// end ;
66255: GO 66164
66257: POP
66258: POP
// if p then
66259: LD_VAR 0 11
66263: IFFALSE 66288
// result := Replace ( result , 2 , p ) ;
66265: LD_ADDR_VAR 0 2
66269: PUSH
66270: LD_VAR 0 2
66274: PPUSH
66275: LD_INT 2
66277: PPUSH
66278: LD_VAR 0 11
66282: PPUSH
66283: CALL_OW 1
66287: ST_TO_ADDR
// end ; exit ;
66288: GO 67012
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
66290: LD_EXP 88
66294: PUSH
66295: LD_EXP 87
66299: PUSH
66300: LD_VAR 0 1
66304: ARRAY
66305: ARRAY
66306: NOT
66307: PUSH
66308: LD_EXP 61
66312: PUSH
66313: LD_VAR 0 1
66317: ARRAY
66318: PPUSH
66319: LD_INT 30
66321: PUSH
66322: LD_INT 3
66324: PUSH
66325: EMPTY
66326: LIST
66327: LIST
66328: PPUSH
66329: CALL_OW 72
66333: AND
66334: PUSH
66335: LD_EXP 66
66339: PUSH
66340: LD_VAR 0 1
66344: ARRAY
66345: NOT
66346: AND
66347: IFFALSE 67012
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
66349: LD_ADDR_EXP 103
66353: PUSH
66354: LD_EXP 103
66358: PPUSH
66359: LD_VAR 0 1
66363: PPUSH
66364: LD_INT 6
66366: PPUSH
66367: CALL_OW 1
66371: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
66372: LD_ADDR_VAR 0 2
66376: PUSH
66377: LD_INT 0
66379: PUSH
66380: LD_INT 0
66382: PUSH
66383: LD_INT 0
66385: PUSH
66386: LD_INT 0
66388: PUSH
66389: EMPTY
66390: LIST
66391: LIST
66392: LIST
66393: LIST
66394: ST_TO_ADDR
// if sci >= 1 then
66395: LD_VAR 0 8
66399: PUSH
66400: LD_INT 1
66402: GREATEREQUAL
66403: IFFALSE 66425
// tmp := tmp diff sci [ 1 ] ;
66405: LD_ADDR_VAR 0 4
66409: PUSH
66410: LD_VAR 0 4
66414: PUSH
66415: LD_VAR 0 8
66419: PUSH
66420: LD_INT 1
66422: ARRAY
66423: DIFF
66424: ST_TO_ADDR
// if tmp and not sci then
66425: LD_VAR 0 4
66429: PUSH
66430: LD_VAR 0 8
66434: NOT
66435: AND
66436: IFFALSE 66505
// begin sort := SortBySkill ( tmp , 4 ) ;
66438: LD_ADDR_VAR 0 9
66442: PUSH
66443: LD_VAR 0 4
66447: PPUSH
66448: LD_INT 4
66450: PPUSH
66451: CALL 52641 0 2
66455: ST_TO_ADDR
// if sort then
66456: LD_VAR 0 9
66460: IFFALSE 66476
// p := sort [ 1 ] ;
66462: LD_ADDR_VAR 0 11
66466: PUSH
66467: LD_VAR 0 9
66471: PUSH
66472: LD_INT 1
66474: ARRAY
66475: ST_TO_ADDR
// if p then
66476: LD_VAR 0 11
66480: IFFALSE 66505
// result := Replace ( result , 4 , p ) ;
66482: LD_ADDR_VAR 0 2
66486: PUSH
66487: LD_VAR 0 2
66491: PPUSH
66492: LD_INT 4
66494: PPUSH
66495: LD_VAR 0 11
66499: PPUSH
66500: CALL_OW 1
66504: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
66505: LD_ADDR_VAR 0 4
66509: PUSH
66510: LD_VAR 0 4
66514: PUSH
66515: LD_VAR 0 7
66519: DIFF
66520: ST_TO_ADDR
// if tmp and mech < 6 then
66521: LD_VAR 0 4
66525: PUSH
66526: LD_VAR 0 7
66530: PUSH
66531: LD_INT 6
66533: LESS
66534: AND
66535: IFFALSE 66717
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
66537: LD_ADDR_VAR 0 9
66541: PUSH
66542: LD_VAR 0 4
66546: PUSH
66547: LD_VAR 0 7
66551: DIFF
66552: PPUSH
66553: LD_INT 3
66555: PPUSH
66556: CALL 52641 0 2
66560: ST_TO_ADDR
// p := [ ] ;
66561: LD_ADDR_VAR 0 11
66565: PUSH
66566: EMPTY
66567: ST_TO_ADDR
// if sort then
66568: LD_VAR 0 9
66572: IFFALSE 66688
// for i = 1 to 6 - mech do
66574: LD_ADDR_VAR 0 3
66578: PUSH
66579: DOUBLE
66580: LD_INT 1
66582: DEC
66583: ST_TO_ADDR
66584: LD_INT 6
66586: PUSH
66587: LD_VAR 0 7
66591: MINUS
66592: PUSH
66593: FOR_TO
66594: IFFALSE 66686
// begin if i = sort then
66596: LD_VAR 0 3
66600: PUSH
66601: LD_VAR 0 9
66605: EQUAL
66606: IFFALSE 66610
// break ;
66608: GO 66686
// if GetClass ( i ) = 3 then
66610: LD_VAR 0 3
66614: PPUSH
66615: CALL_OW 257
66619: PUSH
66620: LD_INT 3
66622: EQUAL
66623: IFFALSE 66627
// continue ;
66625: GO 66593
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66627: LD_ADDR_VAR 0 11
66631: PUSH
66632: LD_VAR 0 11
66636: PPUSH
66637: LD_VAR 0 11
66641: PUSH
66642: LD_INT 1
66644: PLUS
66645: PPUSH
66646: LD_VAR 0 9
66650: PUSH
66651: LD_VAR 0 3
66655: ARRAY
66656: PPUSH
66657: CALL_OW 2
66661: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66662: LD_ADDR_VAR 0 4
66666: PUSH
66667: LD_VAR 0 4
66671: PUSH
66672: LD_VAR 0 9
66676: PUSH
66677: LD_VAR 0 3
66681: ARRAY
66682: DIFF
66683: ST_TO_ADDR
// end ;
66684: GO 66593
66686: POP
66687: POP
// if p then
66688: LD_VAR 0 11
66692: IFFALSE 66717
// result := Replace ( result , 3 , p ) ;
66694: LD_ADDR_VAR 0 2
66698: PUSH
66699: LD_VAR 0 2
66703: PPUSH
66704: LD_INT 3
66706: PPUSH
66707: LD_VAR 0 11
66711: PPUSH
66712: CALL_OW 1
66716: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
66717: LD_ADDR_VAR 0 4
66721: PUSH
66722: LD_VAR 0 4
66726: PUSH
66727: LD_VAR 0 6
66731: DIFF
66732: ST_TO_ADDR
// if tmp and eng < 4 then
66733: LD_VAR 0 4
66737: PUSH
66738: LD_VAR 0 6
66742: PUSH
66743: LD_INT 4
66745: LESS
66746: AND
66747: IFFALSE 66937
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
66749: LD_ADDR_VAR 0 9
66753: PUSH
66754: LD_VAR 0 4
66758: PUSH
66759: LD_VAR 0 7
66763: PUSH
66764: LD_VAR 0 6
66768: UNION
66769: DIFF
66770: PPUSH
66771: LD_INT 2
66773: PPUSH
66774: CALL 52641 0 2
66778: ST_TO_ADDR
// p := [ ] ;
66779: LD_ADDR_VAR 0 11
66783: PUSH
66784: EMPTY
66785: ST_TO_ADDR
// if sort then
66786: LD_VAR 0 9
66790: IFFALSE 66906
// for i = 1 to 4 - eng do
66792: LD_ADDR_VAR 0 3
66796: PUSH
66797: DOUBLE
66798: LD_INT 1
66800: DEC
66801: ST_TO_ADDR
66802: LD_INT 4
66804: PUSH
66805: LD_VAR 0 6
66809: MINUS
66810: PUSH
66811: FOR_TO
66812: IFFALSE 66904
// begin if i = sort then
66814: LD_VAR 0 3
66818: PUSH
66819: LD_VAR 0 9
66823: EQUAL
66824: IFFALSE 66828
// break ;
66826: GO 66904
// if GetClass ( i ) = 2 then
66828: LD_VAR 0 3
66832: PPUSH
66833: CALL_OW 257
66837: PUSH
66838: LD_INT 2
66840: EQUAL
66841: IFFALSE 66845
// continue ;
66843: GO 66811
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66845: LD_ADDR_VAR 0 11
66849: PUSH
66850: LD_VAR 0 11
66854: PPUSH
66855: LD_VAR 0 11
66859: PUSH
66860: LD_INT 1
66862: PLUS
66863: PPUSH
66864: LD_VAR 0 9
66868: PUSH
66869: LD_VAR 0 3
66873: ARRAY
66874: PPUSH
66875: CALL_OW 2
66879: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66880: LD_ADDR_VAR 0 4
66884: PUSH
66885: LD_VAR 0 4
66889: PUSH
66890: LD_VAR 0 9
66894: PUSH
66895: LD_VAR 0 3
66899: ARRAY
66900: DIFF
66901: ST_TO_ADDR
// end ;
66902: GO 66811
66904: POP
66905: POP
// if p then
66906: LD_VAR 0 11
66910: IFFALSE 66935
// result := Replace ( result , 2 , p ) ;
66912: LD_ADDR_VAR 0 2
66916: PUSH
66917: LD_VAR 0 2
66921: PPUSH
66922: LD_INT 2
66924: PPUSH
66925: LD_VAR 0 11
66929: PPUSH
66930: CALL_OW 1
66934: ST_TO_ADDR
// end else
66935: GO 66981
// for i = eng downto 5 do
66937: LD_ADDR_VAR 0 3
66941: PUSH
66942: DOUBLE
66943: LD_VAR 0 6
66947: INC
66948: ST_TO_ADDR
66949: LD_INT 5
66951: PUSH
66952: FOR_DOWNTO
66953: IFFALSE 66979
// tmp := tmp union eng [ i ] ;
66955: LD_ADDR_VAR 0 4
66959: PUSH
66960: LD_VAR 0 4
66964: PUSH
66965: LD_VAR 0 6
66969: PUSH
66970: LD_VAR 0 3
66974: ARRAY
66975: UNION
66976: ST_TO_ADDR
66977: GO 66952
66979: POP
66980: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
66981: LD_ADDR_VAR 0 2
66985: PUSH
66986: LD_VAR 0 2
66990: PPUSH
66991: LD_INT 1
66993: PPUSH
66994: LD_VAR 0 4
66998: PUSH
66999: LD_VAR 0 5
67003: DIFF
67004: PPUSH
67005: CALL_OW 1
67009: ST_TO_ADDR
// exit ;
67010: GO 67012
// end ; end ;
67012: LD_VAR 0 2
67016: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
67017: LD_INT 0
67019: PPUSH
67020: PPUSH
67021: PPUSH
// if not mc_bases then
67022: LD_EXP 61
67026: NOT
67027: IFFALSE 67031
// exit ;
67029: GO 67173
// for i = 1 to mc_bases do
67031: LD_ADDR_VAR 0 2
67035: PUSH
67036: DOUBLE
67037: LD_INT 1
67039: DEC
67040: ST_TO_ADDR
67041: LD_EXP 61
67045: PUSH
67046: FOR_TO
67047: IFFALSE 67164
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
67049: LD_ADDR_VAR 0 3
67053: PUSH
67054: LD_EXP 61
67058: PUSH
67059: LD_VAR 0 2
67063: ARRAY
67064: PPUSH
67065: LD_INT 21
67067: PUSH
67068: LD_INT 3
67070: PUSH
67071: EMPTY
67072: LIST
67073: LIST
67074: PUSH
67075: LD_INT 3
67077: PUSH
67078: LD_INT 2
67080: PUSH
67081: LD_INT 30
67083: PUSH
67084: LD_INT 29
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: PUSH
67091: LD_INT 30
67093: PUSH
67094: LD_INT 30
67096: PUSH
67097: EMPTY
67098: LIST
67099: LIST
67100: PUSH
67101: EMPTY
67102: LIST
67103: LIST
67104: LIST
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PUSH
67110: LD_INT 3
67112: PUSH
67113: LD_INT 24
67115: PUSH
67116: LD_INT 1000
67118: PUSH
67119: EMPTY
67120: LIST
67121: LIST
67122: PUSH
67123: EMPTY
67124: LIST
67125: LIST
67126: PUSH
67127: EMPTY
67128: LIST
67129: LIST
67130: LIST
67131: PPUSH
67132: CALL_OW 72
67136: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
67137: LD_ADDR_EXP 62
67141: PUSH
67142: LD_EXP 62
67146: PPUSH
67147: LD_VAR 0 2
67151: PPUSH
67152: LD_VAR 0 3
67156: PPUSH
67157: CALL_OW 1
67161: ST_TO_ADDR
// end ;
67162: GO 67046
67164: POP
67165: POP
// RaiseSailEvent ( 101 ) ;
67166: LD_INT 101
67168: PPUSH
67169: CALL_OW 427
// end ;
67173: LD_VAR 0 1
67177: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
67178: LD_INT 0
67180: PPUSH
67181: PPUSH
67182: PPUSH
67183: PPUSH
67184: PPUSH
67185: PPUSH
67186: PPUSH
// if not mc_bases then
67187: LD_EXP 61
67191: NOT
67192: IFFALSE 67196
// exit ;
67194: GO 67758
// for i = 1 to mc_bases do
67196: LD_ADDR_VAR 0 2
67200: PUSH
67201: DOUBLE
67202: LD_INT 1
67204: DEC
67205: ST_TO_ADDR
67206: LD_EXP 61
67210: PUSH
67211: FOR_TO
67212: IFFALSE 67749
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
67214: LD_ADDR_VAR 0 5
67218: PUSH
67219: LD_EXP 61
67223: PUSH
67224: LD_VAR 0 2
67228: ARRAY
67229: PUSH
67230: LD_EXP 90
67234: PUSH
67235: LD_VAR 0 2
67239: ARRAY
67240: UNION
67241: PPUSH
67242: LD_INT 21
67244: PUSH
67245: LD_INT 1
67247: PUSH
67248: EMPTY
67249: LIST
67250: LIST
67251: PUSH
67252: LD_INT 1
67254: PUSH
67255: LD_INT 3
67257: PUSH
67258: LD_INT 54
67260: PUSH
67261: EMPTY
67262: LIST
67263: PUSH
67264: EMPTY
67265: LIST
67266: LIST
67267: PUSH
67268: LD_INT 3
67270: PUSH
67271: LD_INT 24
67273: PUSH
67274: LD_INT 1000
67276: PUSH
67277: EMPTY
67278: LIST
67279: LIST
67280: PUSH
67281: EMPTY
67282: LIST
67283: LIST
67284: PUSH
67285: EMPTY
67286: LIST
67287: LIST
67288: LIST
67289: PUSH
67290: EMPTY
67291: LIST
67292: LIST
67293: PPUSH
67294: CALL_OW 72
67298: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
67299: LD_ADDR_VAR 0 6
67303: PUSH
67304: LD_EXP 61
67308: PUSH
67309: LD_VAR 0 2
67313: ARRAY
67314: PPUSH
67315: LD_INT 21
67317: PUSH
67318: LD_INT 1
67320: PUSH
67321: EMPTY
67322: LIST
67323: LIST
67324: PUSH
67325: LD_INT 1
67327: PUSH
67328: LD_INT 3
67330: PUSH
67331: LD_INT 54
67333: PUSH
67334: EMPTY
67335: LIST
67336: PUSH
67337: EMPTY
67338: LIST
67339: LIST
67340: PUSH
67341: LD_INT 3
67343: PUSH
67344: LD_INT 24
67346: PUSH
67347: LD_INT 250
67349: PUSH
67350: EMPTY
67351: LIST
67352: LIST
67353: PUSH
67354: EMPTY
67355: LIST
67356: LIST
67357: PUSH
67358: EMPTY
67359: LIST
67360: LIST
67361: LIST
67362: PUSH
67363: EMPTY
67364: LIST
67365: LIST
67366: PPUSH
67367: CALL_OW 72
67371: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
67372: LD_ADDR_VAR 0 7
67376: PUSH
67377: LD_VAR 0 5
67381: PUSH
67382: LD_VAR 0 6
67386: DIFF
67387: ST_TO_ADDR
// if not need_heal_1 then
67388: LD_VAR 0 6
67392: NOT
67393: IFFALSE 67426
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
67395: LD_ADDR_EXP 64
67399: PUSH
67400: LD_EXP 64
67404: PPUSH
67405: LD_VAR 0 2
67409: PUSH
67410: LD_INT 1
67412: PUSH
67413: EMPTY
67414: LIST
67415: LIST
67416: PPUSH
67417: EMPTY
67418: PPUSH
67419: CALL 21397 0 3
67423: ST_TO_ADDR
67424: GO 67496
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
67426: LD_ADDR_EXP 64
67430: PUSH
67431: LD_EXP 64
67435: PPUSH
67436: LD_VAR 0 2
67440: PUSH
67441: LD_INT 1
67443: PUSH
67444: EMPTY
67445: LIST
67446: LIST
67447: PPUSH
67448: LD_EXP 64
67452: PUSH
67453: LD_VAR 0 2
67457: ARRAY
67458: PUSH
67459: LD_INT 1
67461: ARRAY
67462: PPUSH
67463: LD_INT 3
67465: PUSH
67466: LD_INT 24
67468: PUSH
67469: LD_INT 1000
67471: PUSH
67472: EMPTY
67473: LIST
67474: LIST
67475: PUSH
67476: EMPTY
67477: LIST
67478: LIST
67479: PPUSH
67480: CALL_OW 72
67484: PUSH
67485: LD_VAR 0 6
67489: UNION
67490: PPUSH
67491: CALL 21397 0 3
67495: ST_TO_ADDR
// if not need_heal_2 then
67496: LD_VAR 0 7
67500: NOT
67501: IFFALSE 67534
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
67503: LD_ADDR_EXP 64
67507: PUSH
67508: LD_EXP 64
67512: PPUSH
67513: LD_VAR 0 2
67517: PUSH
67518: LD_INT 2
67520: PUSH
67521: EMPTY
67522: LIST
67523: LIST
67524: PPUSH
67525: EMPTY
67526: PPUSH
67527: CALL 21397 0 3
67531: ST_TO_ADDR
67532: GO 67566
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
67534: LD_ADDR_EXP 64
67538: PUSH
67539: LD_EXP 64
67543: PPUSH
67544: LD_VAR 0 2
67548: PUSH
67549: LD_INT 2
67551: PUSH
67552: EMPTY
67553: LIST
67554: LIST
67555: PPUSH
67556: LD_VAR 0 7
67560: PPUSH
67561: CALL 21397 0 3
67565: ST_TO_ADDR
// if need_heal_2 then
67566: LD_VAR 0 7
67570: IFFALSE 67731
// for j in need_heal_2 do
67572: LD_ADDR_VAR 0 3
67576: PUSH
67577: LD_VAR 0 7
67581: PUSH
67582: FOR_IN
67583: IFFALSE 67729
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67585: LD_ADDR_VAR 0 5
67589: PUSH
67590: LD_EXP 61
67594: PUSH
67595: LD_VAR 0 2
67599: ARRAY
67600: PPUSH
67601: LD_INT 2
67603: PUSH
67604: LD_INT 30
67606: PUSH
67607: LD_INT 6
67609: PUSH
67610: EMPTY
67611: LIST
67612: LIST
67613: PUSH
67614: LD_INT 30
67616: PUSH
67617: LD_INT 7
67619: PUSH
67620: EMPTY
67621: LIST
67622: LIST
67623: PUSH
67624: LD_INT 30
67626: PUSH
67627: LD_INT 8
67629: PUSH
67630: EMPTY
67631: LIST
67632: LIST
67633: PUSH
67634: LD_INT 30
67636: PUSH
67637: LD_INT 0
67639: PUSH
67640: EMPTY
67641: LIST
67642: LIST
67643: PUSH
67644: LD_INT 30
67646: PUSH
67647: LD_INT 1
67649: PUSH
67650: EMPTY
67651: LIST
67652: LIST
67653: PUSH
67654: EMPTY
67655: LIST
67656: LIST
67657: LIST
67658: LIST
67659: LIST
67660: LIST
67661: PPUSH
67662: CALL_OW 72
67666: ST_TO_ADDR
// if tmp then
67667: LD_VAR 0 5
67671: IFFALSE 67727
// begin k := NearestUnitToUnit ( tmp , j ) ;
67673: LD_ADDR_VAR 0 4
67677: PUSH
67678: LD_VAR 0 5
67682: PPUSH
67683: LD_VAR 0 3
67687: PPUSH
67688: CALL_OW 74
67692: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
67693: LD_VAR 0 3
67697: PPUSH
67698: LD_VAR 0 4
67702: PPUSH
67703: CALL_OW 296
67707: PUSH
67708: LD_INT 5
67710: GREATER
67711: IFFALSE 67727
// ComMoveToNearbyEntrance ( j , k ) ;
67713: LD_VAR 0 3
67717: PPUSH
67718: LD_VAR 0 4
67722: PPUSH
67723: CALL 55014 0 2
// end ; end ;
67727: GO 67582
67729: POP
67730: POP
// if not need_heal_1 and not need_heal_2 then
67731: LD_VAR 0 6
67735: NOT
67736: PUSH
67737: LD_VAR 0 7
67741: NOT
67742: AND
67743: IFFALSE 67747
// continue ;
67745: GO 67211
// end ;
67747: GO 67211
67749: POP
67750: POP
// RaiseSailEvent ( 102 ) ;
67751: LD_INT 102
67753: PPUSH
67754: CALL_OW 427
// end ;
67758: LD_VAR 0 1
67762: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
67763: LD_INT 0
67765: PPUSH
67766: PPUSH
67767: PPUSH
67768: PPUSH
67769: PPUSH
67770: PPUSH
67771: PPUSH
67772: PPUSH
// if not mc_bases then
67773: LD_EXP 61
67777: NOT
67778: IFFALSE 67782
// exit ;
67780: GO 68693
// for i = 1 to mc_bases do
67782: LD_ADDR_VAR 0 2
67786: PUSH
67787: DOUBLE
67788: LD_INT 1
67790: DEC
67791: ST_TO_ADDR
67792: LD_EXP 61
67796: PUSH
67797: FOR_TO
67798: IFFALSE 68691
// begin if not mc_building_need_repair [ i ] then
67800: LD_EXP 62
67804: PUSH
67805: LD_VAR 0 2
67809: ARRAY
67810: NOT
67811: IFFALSE 67996
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
67813: LD_ADDR_VAR 0 6
67817: PUSH
67818: LD_EXP 80
67822: PUSH
67823: LD_VAR 0 2
67827: ARRAY
67828: PPUSH
67829: LD_INT 3
67831: PUSH
67832: LD_INT 24
67834: PUSH
67835: LD_INT 1000
67837: PUSH
67838: EMPTY
67839: LIST
67840: LIST
67841: PUSH
67842: EMPTY
67843: LIST
67844: LIST
67845: PUSH
67846: LD_INT 2
67848: PUSH
67849: LD_INT 34
67851: PUSH
67852: LD_INT 13
67854: PUSH
67855: EMPTY
67856: LIST
67857: LIST
67858: PUSH
67859: LD_INT 34
67861: PUSH
67862: LD_INT 52
67864: PUSH
67865: EMPTY
67866: LIST
67867: LIST
67868: PUSH
67869: LD_INT 34
67871: PUSH
67872: LD_INT 88
67874: PUSH
67875: EMPTY
67876: LIST
67877: LIST
67878: PUSH
67879: EMPTY
67880: LIST
67881: LIST
67882: LIST
67883: LIST
67884: PUSH
67885: EMPTY
67886: LIST
67887: LIST
67888: PPUSH
67889: CALL_OW 72
67893: ST_TO_ADDR
// if cranes then
67894: LD_VAR 0 6
67898: IFFALSE 67960
// for j in cranes do
67900: LD_ADDR_VAR 0 3
67904: PUSH
67905: LD_VAR 0 6
67909: PUSH
67910: FOR_IN
67911: IFFALSE 67958
// if not IsInArea ( j , mc_parking [ i ] ) then
67913: LD_VAR 0 3
67917: PPUSH
67918: LD_EXP 85
67922: PUSH
67923: LD_VAR 0 2
67927: ARRAY
67928: PPUSH
67929: CALL_OW 308
67933: NOT
67934: IFFALSE 67956
// ComMoveToArea ( j , mc_parking [ i ] ) ;
67936: LD_VAR 0 3
67940: PPUSH
67941: LD_EXP 85
67945: PUSH
67946: LD_VAR 0 2
67950: ARRAY
67951: PPUSH
67952: CALL_OW 113
67956: GO 67910
67958: POP
67959: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
67960: LD_ADDR_EXP 63
67964: PUSH
67965: LD_EXP 63
67969: PPUSH
67970: LD_VAR 0 2
67974: PPUSH
67975: EMPTY
67976: PPUSH
67977: CALL_OW 1
67981: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
67982: LD_VAR 0 2
67986: PPUSH
67987: LD_INT 101
67989: PPUSH
67990: CALL 62836 0 2
// continue ;
67994: GO 67797
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
67996: LD_ADDR_EXP 67
68000: PUSH
68001: LD_EXP 67
68005: PPUSH
68006: LD_VAR 0 2
68010: PPUSH
68011: EMPTY
68012: PPUSH
68013: CALL_OW 1
68017: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
68018: LD_VAR 0 2
68022: PPUSH
68023: LD_INT 103
68025: PPUSH
68026: CALL 62836 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
68030: LD_ADDR_VAR 0 5
68034: PUSH
68035: LD_EXP 61
68039: PUSH
68040: LD_VAR 0 2
68044: ARRAY
68045: PUSH
68046: LD_EXP 90
68050: PUSH
68051: LD_VAR 0 2
68055: ARRAY
68056: UNION
68057: PPUSH
68058: LD_INT 2
68060: PUSH
68061: LD_INT 25
68063: PUSH
68064: LD_INT 2
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: PUSH
68071: LD_INT 25
68073: PUSH
68074: LD_INT 16
68076: PUSH
68077: EMPTY
68078: LIST
68079: LIST
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: LIST
68085: PUSH
68086: EMPTY
68087: LIST
68088: PPUSH
68089: CALL_OW 72
68093: ST_TO_ADDR
// if mc_need_heal [ i ] then
68094: LD_EXP 64
68098: PUSH
68099: LD_VAR 0 2
68103: ARRAY
68104: IFFALSE 68148
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
68106: LD_ADDR_VAR 0 5
68110: PUSH
68111: LD_VAR 0 5
68115: PUSH
68116: LD_EXP 64
68120: PUSH
68121: LD_VAR 0 2
68125: ARRAY
68126: PUSH
68127: LD_INT 1
68129: ARRAY
68130: PUSH
68131: LD_EXP 64
68135: PUSH
68136: LD_VAR 0 2
68140: ARRAY
68141: PUSH
68142: LD_INT 2
68144: ARRAY
68145: UNION
68146: DIFF
68147: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
68148: LD_ADDR_VAR 0 6
68152: PUSH
68153: LD_EXP 80
68157: PUSH
68158: LD_VAR 0 2
68162: ARRAY
68163: PPUSH
68164: LD_INT 2
68166: PUSH
68167: LD_INT 34
68169: PUSH
68170: LD_INT 13
68172: PUSH
68173: EMPTY
68174: LIST
68175: LIST
68176: PUSH
68177: LD_INT 34
68179: PUSH
68180: LD_INT 52
68182: PUSH
68183: EMPTY
68184: LIST
68185: LIST
68186: PUSH
68187: LD_INT 34
68189: PUSH
68190: LD_INT 88
68192: PUSH
68193: EMPTY
68194: LIST
68195: LIST
68196: PUSH
68197: EMPTY
68198: LIST
68199: LIST
68200: LIST
68201: LIST
68202: PPUSH
68203: CALL_OW 72
68207: ST_TO_ADDR
// if cranes then
68208: LD_VAR 0 6
68212: IFFALSE 68380
// begin for j in cranes do
68214: LD_ADDR_VAR 0 3
68218: PUSH
68219: LD_VAR 0 6
68223: PUSH
68224: FOR_IN
68225: IFFALSE 68378
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
68227: LD_VAR 0 3
68231: PPUSH
68232: CALL_OW 256
68236: PUSH
68237: LD_INT 1000
68239: EQUAL
68240: PUSH
68241: LD_VAR 0 3
68245: PPUSH
68246: CALL_OW 314
68250: NOT
68251: AND
68252: IFFALSE 68318
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
68254: LD_ADDR_VAR 0 8
68258: PUSH
68259: LD_EXP 62
68263: PUSH
68264: LD_VAR 0 2
68268: ARRAY
68269: PPUSH
68270: LD_VAR 0 3
68274: PPUSH
68275: CALL_OW 74
68279: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
68280: LD_VAR 0 8
68284: PPUSH
68285: LD_INT 16
68287: PPUSH
68288: CALL 24362 0 2
68292: PUSH
68293: LD_INT 4
68295: ARRAY
68296: PUSH
68297: LD_INT 10
68299: LESS
68300: IFFALSE 68316
// ComRepairBuilding ( j , to_repair ) ;
68302: LD_VAR 0 3
68306: PPUSH
68307: LD_VAR 0 8
68311: PPUSH
68312: CALL_OW 130
// end else
68316: GO 68376
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
68318: LD_VAR 0 3
68322: PPUSH
68323: CALL_OW 256
68327: PUSH
68328: LD_INT 500
68330: LESS
68331: PUSH
68332: LD_VAR 0 3
68336: PPUSH
68337: LD_EXP 85
68341: PUSH
68342: LD_VAR 0 2
68346: ARRAY
68347: PPUSH
68348: CALL_OW 308
68352: NOT
68353: AND
68354: IFFALSE 68376
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68356: LD_VAR 0 3
68360: PPUSH
68361: LD_EXP 85
68365: PUSH
68366: LD_VAR 0 2
68370: ARRAY
68371: PPUSH
68372: CALL_OW 113
// end ;
68376: GO 68224
68378: POP
68379: POP
// end ; if tmp > 3 then
68380: LD_VAR 0 5
68384: PUSH
68385: LD_INT 3
68387: GREATER
68388: IFFALSE 68408
// tmp := ShrinkArray ( tmp , 4 ) ;
68390: LD_ADDR_VAR 0 5
68394: PUSH
68395: LD_VAR 0 5
68399: PPUSH
68400: LD_INT 4
68402: PPUSH
68403: CALL 54452 0 2
68407: ST_TO_ADDR
// if not tmp then
68408: LD_VAR 0 5
68412: NOT
68413: IFFALSE 68417
// continue ;
68415: GO 67797
// for j in tmp do
68417: LD_ADDR_VAR 0 3
68421: PUSH
68422: LD_VAR 0 5
68426: PUSH
68427: FOR_IN
68428: IFFALSE 68687
// begin if IsInUnit ( j ) then
68430: LD_VAR 0 3
68434: PPUSH
68435: CALL_OW 310
68439: IFFALSE 68450
// ComExitBuilding ( j ) ;
68441: LD_VAR 0 3
68445: PPUSH
68446: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
68450: LD_VAR 0 3
68454: PUSH
68455: LD_EXP 63
68459: PUSH
68460: LD_VAR 0 2
68464: ARRAY
68465: IN
68466: NOT
68467: IFFALSE 68525
// begin SetTag ( j , 101 ) ;
68469: LD_VAR 0 3
68473: PPUSH
68474: LD_INT 101
68476: PPUSH
68477: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
68481: LD_ADDR_EXP 63
68485: PUSH
68486: LD_EXP 63
68490: PPUSH
68491: LD_VAR 0 2
68495: PUSH
68496: LD_EXP 63
68500: PUSH
68501: LD_VAR 0 2
68505: ARRAY
68506: PUSH
68507: LD_INT 1
68509: PLUS
68510: PUSH
68511: EMPTY
68512: LIST
68513: LIST
68514: PPUSH
68515: LD_VAR 0 3
68519: PPUSH
68520: CALL 21397 0 3
68524: ST_TO_ADDR
// end ; wait ( 1 ) ;
68525: LD_INT 1
68527: PPUSH
68528: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
68532: LD_ADDR_VAR 0 7
68536: PUSH
68537: LD_EXP 62
68541: PUSH
68542: LD_VAR 0 2
68546: ARRAY
68547: ST_TO_ADDR
// if mc_scan [ i ] then
68548: LD_EXP 84
68552: PUSH
68553: LD_VAR 0 2
68557: ARRAY
68558: IFFALSE 68620
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
68560: LD_ADDR_VAR 0 7
68564: PUSH
68565: LD_EXP 62
68569: PUSH
68570: LD_VAR 0 2
68574: ARRAY
68575: PPUSH
68576: LD_INT 3
68578: PUSH
68579: LD_INT 30
68581: PUSH
68582: LD_INT 32
68584: PUSH
68585: EMPTY
68586: LIST
68587: LIST
68588: PUSH
68589: LD_INT 30
68591: PUSH
68592: LD_INT 33
68594: PUSH
68595: EMPTY
68596: LIST
68597: LIST
68598: PUSH
68599: LD_INT 30
68601: PUSH
68602: LD_INT 31
68604: PUSH
68605: EMPTY
68606: LIST
68607: LIST
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: LIST
68613: LIST
68614: PPUSH
68615: CALL_OW 72
68619: ST_TO_ADDR
// if not to_repair_tmp then
68620: LD_VAR 0 7
68624: NOT
68625: IFFALSE 68629
// continue ;
68627: GO 68427
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
68629: LD_ADDR_VAR 0 8
68633: PUSH
68634: LD_VAR 0 7
68638: PPUSH
68639: LD_VAR 0 3
68643: PPUSH
68644: CALL_OW 74
68648: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
68649: LD_VAR 0 8
68653: PPUSH
68654: LD_INT 16
68656: PPUSH
68657: CALL 24362 0 2
68661: PUSH
68662: LD_INT 4
68664: ARRAY
68665: PUSH
68666: LD_INT 14
68668: LESS
68669: IFFALSE 68685
// ComRepairBuilding ( j , to_repair ) ;
68671: LD_VAR 0 3
68675: PPUSH
68676: LD_VAR 0 8
68680: PPUSH
68681: CALL_OW 130
// end ;
68685: GO 68427
68687: POP
68688: POP
// end ;
68689: GO 67797
68691: POP
68692: POP
// end ;
68693: LD_VAR 0 1
68697: RET
// export function MC_Heal ; var i , j , tmp ; begin
68698: LD_INT 0
68700: PPUSH
68701: PPUSH
68702: PPUSH
68703: PPUSH
// if not mc_bases then
68704: LD_EXP 61
68708: NOT
68709: IFFALSE 68713
// exit ;
68711: GO 69115
// for i = 1 to mc_bases do
68713: LD_ADDR_VAR 0 2
68717: PUSH
68718: DOUBLE
68719: LD_INT 1
68721: DEC
68722: ST_TO_ADDR
68723: LD_EXP 61
68727: PUSH
68728: FOR_TO
68729: IFFALSE 69113
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
68731: LD_EXP 64
68735: PUSH
68736: LD_VAR 0 2
68740: ARRAY
68741: PUSH
68742: LD_INT 1
68744: ARRAY
68745: NOT
68746: PUSH
68747: LD_EXP 64
68751: PUSH
68752: LD_VAR 0 2
68756: ARRAY
68757: PUSH
68758: LD_INT 2
68760: ARRAY
68761: NOT
68762: AND
68763: IFFALSE 68801
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
68765: LD_ADDR_EXP 65
68769: PUSH
68770: LD_EXP 65
68774: PPUSH
68775: LD_VAR 0 2
68779: PPUSH
68780: EMPTY
68781: PPUSH
68782: CALL_OW 1
68786: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
68787: LD_VAR 0 2
68791: PPUSH
68792: LD_INT 102
68794: PPUSH
68795: CALL 62836 0 2
// continue ;
68799: GO 68728
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
68801: LD_ADDR_VAR 0 4
68805: PUSH
68806: LD_EXP 61
68810: PUSH
68811: LD_VAR 0 2
68815: ARRAY
68816: PPUSH
68817: LD_INT 25
68819: PUSH
68820: LD_INT 4
68822: PUSH
68823: EMPTY
68824: LIST
68825: LIST
68826: PPUSH
68827: CALL_OW 72
68831: ST_TO_ADDR
// if not tmp then
68832: LD_VAR 0 4
68836: NOT
68837: IFFALSE 68841
// continue ;
68839: GO 68728
// if mc_taming [ i ] then
68841: LD_EXP 92
68845: PUSH
68846: LD_VAR 0 2
68850: ARRAY
68851: IFFALSE 68875
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
68853: LD_ADDR_EXP 92
68857: PUSH
68858: LD_EXP 92
68862: PPUSH
68863: LD_VAR 0 2
68867: PPUSH
68868: EMPTY
68869: PPUSH
68870: CALL_OW 1
68874: ST_TO_ADDR
// for j in tmp do
68875: LD_ADDR_VAR 0 3
68879: PUSH
68880: LD_VAR 0 4
68884: PUSH
68885: FOR_IN
68886: IFFALSE 69109
// begin if IsInUnit ( j ) then
68888: LD_VAR 0 3
68892: PPUSH
68893: CALL_OW 310
68897: IFFALSE 68908
// ComExitBuilding ( j ) ;
68899: LD_VAR 0 3
68903: PPUSH
68904: CALL_OW 122
// if not j in mc_healers [ i ] then
68908: LD_VAR 0 3
68912: PUSH
68913: LD_EXP 65
68917: PUSH
68918: LD_VAR 0 2
68922: ARRAY
68923: IN
68924: NOT
68925: IFFALSE 68971
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
68927: LD_ADDR_EXP 65
68931: PUSH
68932: LD_EXP 65
68936: PPUSH
68937: LD_VAR 0 2
68941: PUSH
68942: LD_EXP 65
68946: PUSH
68947: LD_VAR 0 2
68951: ARRAY
68952: PUSH
68953: LD_INT 1
68955: PLUS
68956: PUSH
68957: EMPTY
68958: LIST
68959: LIST
68960: PPUSH
68961: LD_VAR 0 3
68965: PPUSH
68966: CALL 21397 0 3
68970: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
68971: LD_VAR 0 3
68975: PPUSH
68976: CALL_OW 110
68980: PUSH
68981: LD_INT 102
68983: NONEQUAL
68984: IFFALSE 68998
// SetTag ( j , 102 ) ;
68986: LD_VAR 0 3
68990: PPUSH
68991: LD_INT 102
68993: PPUSH
68994: CALL_OW 109
// Wait ( 3 ) ;
68998: LD_INT 3
69000: PPUSH
69001: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
69005: LD_EXP 64
69009: PUSH
69010: LD_VAR 0 2
69014: ARRAY
69015: PUSH
69016: LD_INT 1
69018: ARRAY
69019: IFFALSE 69051
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
69021: LD_VAR 0 3
69025: PPUSH
69026: LD_EXP 64
69030: PUSH
69031: LD_VAR 0 2
69035: ARRAY
69036: PUSH
69037: LD_INT 1
69039: ARRAY
69040: PUSH
69041: LD_INT 1
69043: ARRAY
69044: PPUSH
69045: CALL_OW 128
69049: GO 69107
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
69051: LD_VAR 0 3
69055: PPUSH
69056: CALL_OW 314
69060: NOT
69061: PUSH
69062: LD_EXP 64
69066: PUSH
69067: LD_VAR 0 2
69071: ARRAY
69072: PUSH
69073: LD_INT 2
69075: ARRAY
69076: AND
69077: IFFALSE 69107
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
69079: LD_VAR 0 3
69083: PPUSH
69084: LD_EXP 64
69088: PUSH
69089: LD_VAR 0 2
69093: ARRAY
69094: PUSH
69095: LD_INT 2
69097: ARRAY
69098: PUSH
69099: LD_INT 1
69101: ARRAY
69102: PPUSH
69103: CALL_OW 128
// end ;
69107: GO 68885
69109: POP
69110: POP
// end ;
69111: GO 68728
69113: POP
69114: POP
// end ;
69115: LD_VAR 0 1
69119: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
69120: LD_INT 0
69122: PPUSH
69123: PPUSH
69124: PPUSH
69125: PPUSH
69126: PPUSH
69127: PPUSH
// if not mc_bases then
69128: LD_EXP 61
69132: NOT
69133: IFFALSE 69137
// exit ;
69135: GO 70300
// for i = 1 to mc_bases do
69137: LD_ADDR_VAR 0 2
69141: PUSH
69142: DOUBLE
69143: LD_INT 1
69145: DEC
69146: ST_TO_ADDR
69147: LD_EXP 61
69151: PUSH
69152: FOR_TO
69153: IFFALSE 70298
// begin if mc_scan [ i ] then
69155: LD_EXP 84
69159: PUSH
69160: LD_VAR 0 2
69164: ARRAY
69165: IFFALSE 69169
// continue ;
69167: GO 69152
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
69169: LD_EXP 66
69173: PUSH
69174: LD_VAR 0 2
69178: ARRAY
69179: NOT
69180: PUSH
69181: LD_EXP 68
69185: PUSH
69186: LD_VAR 0 2
69190: ARRAY
69191: NOT
69192: AND
69193: PUSH
69194: LD_EXP 67
69198: PUSH
69199: LD_VAR 0 2
69203: ARRAY
69204: AND
69205: IFFALSE 69243
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
69207: LD_ADDR_EXP 67
69211: PUSH
69212: LD_EXP 67
69216: PPUSH
69217: LD_VAR 0 2
69221: PPUSH
69222: EMPTY
69223: PPUSH
69224: CALL_OW 1
69228: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
69229: LD_VAR 0 2
69233: PPUSH
69234: LD_INT 103
69236: PPUSH
69237: CALL 62836 0 2
// continue ;
69241: GO 69152
// end ; if mc_construct_list [ i ] then
69243: LD_EXP 68
69247: PUSH
69248: LD_VAR 0 2
69252: ARRAY
69253: IFFALSE 69473
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
69255: LD_ADDR_VAR 0 5
69259: PUSH
69260: LD_EXP 61
69264: PUSH
69265: LD_VAR 0 2
69269: ARRAY
69270: PPUSH
69271: LD_INT 25
69273: PUSH
69274: LD_INT 2
69276: PUSH
69277: EMPTY
69278: LIST
69279: LIST
69280: PPUSH
69281: CALL_OW 72
69285: PUSH
69286: LD_EXP 63
69290: PUSH
69291: LD_VAR 0 2
69295: ARRAY
69296: DIFF
69297: ST_TO_ADDR
// if not tmp then
69298: LD_VAR 0 5
69302: NOT
69303: IFFALSE 69307
// continue ;
69305: GO 69152
// for j in tmp do
69307: LD_ADDR_VAR 0 3
69311: PUSH
69312: LD_VAR 0 5
69316: PUSH
69317: FOR_IN
69318: IFFALSE 69469
// begin if not mc_builders [ i ] then
69320: LD_EXP 67
69324: PUSH
69325: LD_VAR 0 2
69329: ARRAY
69330: NOT
69331: IFFALSE 69389
// begin SetTag ( j , 103 ) ;
69333: LD_VAR 0 3
69337: PPUSH
69338: LD_INT 103
69340: PPUSH
69341: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
69345: LD_ADDR_EXP 67
69349: PUSH
69350: LD_EXP 67
69354: PPUSH
69355: LD_VAR 0 2
69359: PUSH
69360: LD_EXP 67
69364: PUSH
69365: LD_VAR 0 2
69369: ARRAY
69370: PUSH
69371: LD_INT 1
69373: PLUS
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: PPUSH
69379: LD_VAR 0 3
69383: PPUSH
69384: CALL 21397 0 3
69388: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
69389: LD_VAR 0 3
69393: PPUSH
69394: CALL_OW 310
69398: IFFALSE 69409
// ComExitBuilding ( j ) ;
69400: LD_VAR 0 3
69404: PPUSH
69405: CALL_OW 122
// wait ( 3 ) ;
69409: LD_INT 3
69411: PPUSH
69412: CALL_OW 67
// if not mc_construct_list [ i ] then
69416: LD_EXP 68
69420: PUSH
69421: LD_VAR 0 2
69425: ARRAY
69426: NOT
69427: IFFALSE 69431
// break ;
69429: GO 69469
// if not HasTask ( j ) then
69431: LD_VAR 0 3
69435: PPUSH
69436: CALL_OW 314
69440: NOT
69441: IFFALSE 69467
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
69443: LD_VAR 0 3
69447: PPUSH
69448: LD_EXP 68
69452: PUSH
69453: LD_VAR 0 2
69457: ARRAY
69458: PUSH
69459: LD_INT 1
69461: ARRAY
69462: PPUSH
69463: CALL 24635 0 2
// end ;
69467: GO 69317
69469: POP
69470: POP
// end else
69471: GO 70296
// if mc_build_list [ i ] then
69473: LD_EXP 66
69477: PUSH
69478: LD_VAR 0 2
69482: ARRAY
69483: IFFALSE 70296
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
69485: LD_EXP 66
69489: PUSH
69490: LD_VAR 0 2
69494: ARRAY
69495: PUSH
69496: LD_INT 1
69498: ARRAY
69499: PUSH
69500: LD_INT 1
69502: ARRAY
69503: PPUSH
69504: CALL 24459 0 1
69508: PUSH
69509: LD_EXP 61
69513: PUSH
69514: LD_VAR 0 2
69518: ARRAY
69519: PPUSH
69520: LD_INT 2
69522: PUSH
69523: LD_INT 30
69525: PUSH
69526: LD_INT 2
69528: PUSH
69529: EMPTY
69530: LIST
69531: LIST
69532: PUSH
69533: LD_INT 30
69535: PUSH
69536: LD_INT 3
69538: PUSH
69539: EMPTY
69540: LIST
69541: LIST
69542: PUSH
69543: EMPTY
69544: LIST
69545: LIST
69546: LIST
69547: PPUSH
69548: CALL_OW 72
69552: NOT
69553: AND
69554: IFFALSE 69659
// begin for j = 1 to mc_build_list [ i ] do
69556: LD_ADDR_VAR 0 3
69560: PUSH
69561: DOUBLE
69562: LD_INT 1
69564: DEC
69565: ST_TO_ADDR
69566: LD_EXP 66
69570: PUSH
69571: LD_VAR 0 2
69575: ARRAY
69576: PUSH
69577: FOR_TO
69578: IFFALSE 69657
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
69580: LD_EXP 66
69584: PUSH
69585: LD_VAR 0 2
69589: ARRAY
69590: PUSH
69591: LD_VAR 0 3
69595: ARRAY
69596: PUSH
69597: LD_INT 1
69599: ARRAY
69600: PUSH
69601: LD_INT 2
69603: EQUAL
69604: IFFALSE 69655
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
69606: LD_ADDR_EXP 66
69610: PUSH
69611: LD_EXP 66
69615: PPUSH
69616: LD_VAR 0 2
69620: PPUSH
69621: LD_EXP 66
69625: PUSH
69626: LD_VAR 0 2
69630: ARRAY
69631: PPUSH
69632: LD_VAR 0 3
69636: PPUSH
69637: LD_INT 1
69639: PPUSH
69640: LD_INT 0
69642: PPUSH
69643: CALL 20815 0 4
69647: PPUSH
69648: CALL_OW 1
69652: ST_TO_ADDR
// break ;
69653: GO 69657
// end ;
69655: GO 69577
69657: POP
69658: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69659: LD_ADDR_VAR 0 6
69663: PUSH
69664: LD_EXP 61
69668: PUSH
69669: LD_VAR 0 2
69673: ARRAY
69674: PPUSH
69675: LD_INT 2
69677: PUSH
69678: LD_INT 30
69680: PUSH
69681: LD_INT 0
69683: PUSH
69684: EMPTY
69685: LIST
69686: LIST
69687: PUSH
69688: LD_INT 30
69690: PUSH
69691: LD_INT 1
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: PUSH
69698: EMPTY
69699: LIST
69700: LIST
69701: LIST
69702: PPUSH
69703: CALL_OW 72
69707: ST_TO_ADDR
// for k := 1 to depot do
69708: LD_ADDR_VAR 0 4
69712: PUSH
69713: DOUBLE
69714: LD_INT 1
69716: DEC
69717: ST_TO_ADDR
69718: LD_VAR 0 6
69722: PUSH
69723: FOR_TO
69724: IFFALSE 70294
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
69726: LD_EXP 66
69730: PUSH
69731: LD_VAR 0 2
69735: ARRAY
69736: PUSH
69737: LD_INT 1
69739: ARRAY
69740: PUSH
69741: LD_INT 1
69743: ARRAY
69744: PUSH
69745: LD_INT 0
69747: EQUAL
69748: PUSH
69749: LD_VAR 0 6
69753: PUSH
69754: LD_VAR 0 4
69758: ARRAY
69759: PPUSH
69760: LD_EXP 66
69764: PUSH
69765: LD_VAR 0 2
69769: ARRAY
69770: PUSH
69771: LD_INT 1
69773: ARRAY
69774: PUSH
69775: LD_INT 1
69777: ARRAY
69778: PPUSH
69779: LD_EXP 66
69783: PUSH
69784: LD_VAR 0 2
69788: ARRAY
69789: PUSH
69790: LD_INT 1
69792: ARRAY
69793: PUSH
69794: LD_INT 2
69796: ARRAY
69797: PPUSH
69798: LD_EXP 66
69802: PUSH
69803: LD_VAR 0 2
69807: ARRAY
69808: PUSH
69809: LD_INT 1
69811: ARRAY
69812: PUSH
69813: LD_INT 3
69815: ARRAY
69816: PPUSH
69817: LD_EXP 66
69821: PUSH
69822: LD_VAR 0 2
69826: ARRAY
69827: PUSH
69828: LD_INT 1
69830: ARRAY
69831: PUSH
69832: LD_INT 4
69834: ARRAY
69835: PPUSH
69836: CALL 29871 0 5
69840: OR
69841: IFFALSE 70122
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
69843: LD_ADDR_VAR 0 5
69847: PUSH
69848: LD_EXP 61
69852: PUSH
69853: LD_VAR 0 2
69857: ARRAY
69858: PPUSH
69859: LD_INT 25
69861: PUSH
69862: LD_INT 2
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PPUSH
69869: CALL_OW 72
69873: PUSH
69874: LD_EXP 63
69878: PUSH
69879: LD_VAR 0 2
69883: ARRAY
69884: DIFF
69885: ST_TO_ADDR
// if not tmp then
69886: LD_VAR 0 5
69890: NOT
69891: IFFALSE 69895
// continue ;
69893: GO 69723
// for j in tmp do
69895: LD_ADDR_VAR 0 3
69899: PUSH
69900: LD_VAR 0 5
69904: PUSH
69905: FOR_IN
69906: IFFALSE 70118
// begin if not mc_builders [ i ] then
69908: LD_EXP 67
69912: PUSH
69913: LD_VAR 0 2
69917: ARRAY
69918: NOT
69919: IFFALSE 69977
// begin SetTag ( j , 103 ) ;
69921: LD_VAR 0 3
69925: PPUSH
69926: LD_INT 103
69928: PPUSH
69929: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
69933: LD_ADDR_EXP 67
69937: PUSH
69938: LD_EXP 67
69942: PPUSH
69943: LD_VAR 0 2
69947: PUSH
69948: LD_EXP 67
69952: PUSH
69953: LD_VAR 0 2
69957: ARRAY
69958: PUSH
69959: LD_INT 1
69961: PLUS
69962: PUSH
69963: EMPTY
69964: LIST
69965: LIST
69966: PPUSH
69967: LD_VAR 0 3
69971: PPUSH
69972: CALL 21397 0 3
69976: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
69977: LD_VAR 0 3
69981: PPUSH
69982: CALL_OW 310
69986: IFFALSE 69997
// ComExitBuilding ( j ) ;
69988: LD_VAR 0 3
69992: PPUSH
69993: CALL_OW 122
// wait ( 3 ) ;
69997: LD_INT 3
69999: PPUSH
70000: CALL_OW 67
// if not mc_build_list [ i ] then
70004: LD_EXP 66
70008: PUSH
70009: LD_VAR 0 2
70013: ARRAY
70014: NOT
70015: IFFALSE 70019
// break ;
70017: GO 70118
// if not HasTask ( j ) then
70019: LD_VAR 0 3
70023: PPUSH
70024: CALL_OW 314
70028: NOT
70029: IFFALSE 70116
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
70031: LD_VAR 0 3
70035: PPUSH
70036: LD_EXP 66
70040: PUSH
70041: LD_VAR 0 2
70045: ARRAY
70046: PUSH
70047: LD_INT 1
70049: ARRAY
70050: PUSH
70051: LD_INT 1
70053: ARRAY
70054: PPUSH
70055: LD_EXP 66
70059: PUSH
70060: LD_VAR 0 2
70064: ARRAY
70065: PUSH
70066: LD_INT 1
70068: ARRAY
70069: PUSH
70070: LD_INT 2
70072: ARRAY
70073: PPUSH
70074: LD_EXP 66
70078: PUSH
70079: LD_VAR 0 2
70083: ARRAY
70084: PUSH
70085: LD_INT 1
70087: ARRAY
70088: PUSH
70089: LD_INT 3
70091: ARRAY
70092: PPUSH
70093: LD_EXP 66
70097: PUSH
70098: LD_VAR 0 2
70102: ARRAY
70103: PUSH
70104: LD_INT 1
70106: ARRAY
70107: PUSH
70108: LD_INT 4
70110: ARRAY
70111: PPUSH
70112: CALL_OW 145
// end ;
70116: GO 69905
70118: POP
70119: POP
// end else
70120: GO 70292
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
70122: LD_EXP 61
70126: PUSH
70127: LD_VAR 0 2
70131: ARRAY
70132: PPUSH
70133: LD_EXP 66
70137: PUSH
70138: LD_VAR 0 2
70142: ARRAY
70143: PUSH
70144: LD_INT 1
70146: ARRAY
70147: PUSH
70148: LD_INT 1
70150: ARRAY
70151: PPUSH
70152: LD_EXP 66
70156: PUSH
70157: LD_VAR 0 2
70161: ARRAY
70162: PUSH
70163: LD_INT 1
70165: ARRAY
70166: PUSH
70167: LD_INT 2
70169: ARRAY
70170: PPUSH
70171: LD_EXP 66
70175: PUSH
70176: LD_VAR 0 2
70180: ARRAY
70181: PUSH
70182: LD_INT 1
70184: ARRAY
70185: PUSH
70186: LD_INT 3
70188: ARRAY
70189: PPUSH
70190: LD_EXP 66
70194: PUSH
70195: LD_VAR 0 2
70199: ARRAY
70200: PUSH
70201: LD_INT 1
70203: ARRAY
70204: PUSH
70205: LD_INT 4
70207: ARRAY
70208: PPUSH
70209: LD_EXP 61
70213: PUSH
70214: LD_VAR 0 2
70218: ARRAY
70219: PPUSH
70220: LD_INT 21
70222: PUSH
70223: LD_INT 3
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: PPUSH
70230: CALL_OW 72
70234: PPUSH
70235: EMPTY
70236: PPUSH
70237: CALL 28625 0 7
70241: NOT
70242: IFFALSE 70292
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
70244: LD_ADDR_EXP 66
70248: PUSH
70249: LD_EXP 66
70253: PPUSH
70254: LD_VAR 0 2
70258: PPUSH
70259: LD_EXP 66
70263: PUSH
70264: LD_VAR 0 2
70268: ARRAY
70269: PPUSH
70270: LD_INT 1
70272: PPUSH
70273: LD_INT 1
70275: NEG
70276: PPUSH
70277: LD_INT 0
70279: PPUSH
70280: CALL 20815 0 4
70284: PPUSH
70285: CALL_OW 1
70289: ST_TO_ADDR
// continue ;
70290: GO 69723
// end ; end ;
70292: GO 69723
70294: POP
70295: POP
// end ; end ;
70296: GO 69152
70298: POP
70299: POP
// end ;
70300: LD_VAR 0 1
70304: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
70305: LD_INT 0
70307: PPUSH
70308: PPUSH
70309: PPUSH
70310: PPUSH
70311: PPUSH
70312: PPUSH
// if not mc_bases then
70313: LD_EXP 61
70317: NOT
70318: IFFALSE 70322
// exit ;
70320: GO 70749
// for i = 1 to mc_bases do
70322: LD_ADDR_VAR 0 2
70326: PUSH
70327: DOUBLE
70328: LD_INT 1
70330: DEC
70331: ST_TO_ADDR
70332: LD_EXP 61
70336: PUSH
70337: FOR_TO
70338: IFFALSE 70747
// begin tmp := mc_build_upgrade [ i ] ;
70340: LD_ADDR_VAR 0 4
70344: PUSH
70345: LD_EXP 93
70349: PUSH
70350: LD_VAR 0 2
70354: ARRAY
70355: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
70356: LD_ADDR_VAR 0 6
70360: PUSH
70361: LD_EXP 94
70365: PUSH
70366: LD_VAR 0 2
70370: ARRAY
70371: PPUSH
70372: LD_INT 2
70374: PUSH
70375: LD_INT 30
70377: PUSH
70378: LD_INT 6
70380: PUSH
70381: EMPTY
70382: LIST
70383: LIST
70384: PUSH
70385: LD_INT 30
70387: PUSH
70388: LD_INT 7
70390: PUSH
70391: EMPTY
70392: LIST
70393: LIST
70394: PUSH
70395: EMPTY
70396: LIST
70397: LIST
70398: LIST
70399: PPUSH
70400: CALL_OW 72
70404: ST_TO_ADDR
// if not tmp and not lab then
70405: LD_VAR 0 4
70409: NOT
70410: PUSH
70411: LD_VAR 0 6
70415: NOT
70416: AND
70417: IFFALSE 70421
// continue ;
70419: GO 70337
// if tmp then
70421: LD_VAR 0 4
70425: IFFALSE 70545
// for j in tmp do
70427: LD_ADDR_VAR 0 3
70431: PUSH
70432: LD_VAR 0 4
70436: PUSH
70437: FOR_IN
70438: IFFALSE 70543
// begin if UpgradeCost ( j ) then
70440: LD_VAR 0 3
70444: PPUSH
70445: CALL 28285 0 1
70449: IFFALSE 70541
// begin ComUpgrade ( j ) ;
70451: LD_VAR 0 3
70455: PPUSH
70456: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
70460: LD_ADDR_EXP 93
70464: PUSH
70465: LD_EXP 93
70469: PPUSH
70470: LD_VAR 0 2
70474: PPUSH
70475: LD_EXP 93
70479: PUSH
70480: LD_VAR 0 2
70484: ARRAY
70485: PUSH
70486: LD_VAR 0 3
70490: DIFF
70491: PPUSH
70492: CALL_OW 1
70496: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
70497: LD_ADDR_EXP 68
70501: PUSH
70502: LD_EXP 68
70506: PPUSH
70507: LD_VAR 0 2
70511: PUSH
70512: LD_EXP 68
70516: PUSH
70517: LD_VAR 0 2
70521: ARRAY
70522: PUSH
70523: LD_INT 1
70525: PLUS
70526: PUSH
70527: EMPTY
70528: LIST
70529: LIST
70530: PPUSH
70531: LD_VAR 0 3
70535: PPUSH
70536: CALL 21397 0 3
70540: ST_TO_ADDR
// end ; end ;
70541: GO 70437
70543: POP
70544: POP
// if not lab or not mc_lab_upgrade [ i ] then
70545: LD_VAR 0 6
70549: NOT
70550: PUSH
70551: LD_EXP 95
70555: PUSH
70556: LD_VAR 0 2
70560: ARRAY
70561: NOT
70562: OR
70563: IFFALSE 70567
// continue ;
70565: GO 70337
// for j in lab do
70567: LD_ADDR_VAR 0 3
70571: PUSH
70572: LD_VAR 0 6
70576: PUSH
70577: FOR_IN
70578: IFFALSE 70743
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
70580: LD_VAR 0 3
70584: PPUSH
70585: CALL_OW 266
70589: PUSH
70590: LD_INT 6
70592: PUSH
70593: LD_INT 7
70595: PUSH
70596: EMPTY
70597: LIST
70598: LIST
70599: IN
70600: PUSH
70601: LD_VAR 0 3
70605: PPUSH
70606: CALL_OW 461
70610: PUSH
70611: LD_INT 1
70613: NONEQUAL
70614: AND
70615: IFFALSE 70741
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
70617: LD_VAR 0 3
70621: PPUSH
70622: LD_EXP 95
70626: PUSH
70627: LD_VAR 0 2
70631: ARRAY
70632: PUSH
70633: LD_INT 1
70635: ARRAY
70636: PPUSH
70637: CALL 28490 0 2
70641: IFFALSE 70741
// begin ComCancel ( j ) ;
70643: LD_VAR 0 3
70647: PPUSH
70648: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
70652: LD_VAR 0 3
70656: PPUSH
70657: LD_EXP 95
70661: PUSH
70662: LD_VAR 0 2
70666: ARRAY
70667: PUSH
70668: LD_INT 1
70670: ARRAY
70671: PPUSH
70672: CALL_OW 207
// if not j in mc_construct_list [ i ] then
70676: LD_VAR 0 3
70680: PUSH
70681: LD_EXP 68
70685: PUSH
70686: LD_VAR 0 2
70690: ARRAY
70691: IN
70692: NOT
70693: IFFALSE 70739
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
70695: LD_ADDR_EXP 68
70699: PUSH
70700: LD_EXP 68
70704: PPUSH
70705: LD_VAR 0 2
70709: PUSH
70710: LD_EXP 68
70714: PUSH
70715: LD_VAR 0 2
70719: ARRAY
70720: PUSH
70721: LD_INT 1
70723: PLUS
70724: PUSH
70725: EMPTY
70726: LIST
70727: LIST
70728: PPUSH
70729: LD_VAR 0 3
70733: PPUSH
70734: CALL 21397 0 3
70738: ST_TO_ADDR
// break ;
70739: GO 70743
// end ; end ; end ;
70741: GO 70577
70743: POP
70744: POP
// end ;
70745: GO 70337
70747: POP
70748: POP
// end ;
70749: LD_VAR 0 1
70753: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
70754: LD_INT 0
70756: PPUSH
70757: PPUSH
70758: PPUSH
70759: PPUSH
70760: PPUSH
70761: PPUSH
70762: PPUSH
70763: PPUSH
70764: PPUSH
// if not mc_bases then
70765: LD_EXP 61
70769: NOT
70770: IFFALSE 70774
// exit ;
70772: GO 71179
// for i = 1 to mc_bases do
70774: LD_ADDR_VAR 0 2
70778: PUSH
70779: DOUBLE
70780: LD_INT 1
70782: DEC
70783: ST_TO_ADDR
70784: LD_EXP 61
70788: PUSH
70789: FOR_TO
70790: IFFALSE 71177
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
70792: LD_EXP 69
70796: PUSH
70797: LD_VAR 0 2
70801: ARRAY
70802: NOT
70803: PUSH
70804: LD_EXP 61
70808: PUSH
70809: LD_VAR 0 2
70813: ARRAY
70814: PPUSH
70815: LD_INT 30
70817: PUSH
70818: LD_INT 3
70820: PUSH
70821: EMPTY
70822: LIST
70823: LIST
70824: PPUSH
70825: CALL_OW 72
70829: NOT
70830: OR
70831: IFFALSE 70835
// continue ;
70833: GO 70789
// busy := false ;
70835: LD_ADDR_VAR 0 8
70839: PUSH
70840: LD_INT 0
70842: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70843: LD_ADDR_VAR 0 4
70847: PUSH
70848: LD_EXP 61
70852: PUSH
70853: LD_VAR 0 2
70857: ARRAY
70858: PPUSH
70859: LD_INT 30
70861: PUSH
70862: LD_INT 3
70864: PUSH
70865: EMPTY
70866: LIST
70867: LIST
70868: PPUSH
70869: CALL_OW 72
70873: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
70874: LD_ADDR_VAR 0 6
70878: PUSH
70879: LD_EXP 69
70883: PUSH
70884: LD_VAR 0 2
70888: ARRAY
70889: PPUSH
70890: LD_INT 2
70892: PUSH
70893: LD_INT 30
70895: PUSH
70896: LD_INT 32
70898: PUSH
70899: EMPTY
70900: LIST
70901: LIST
70902: PUSH
70903: LD_INT 30
70905: PUSH
70906: LD_INT 33
70908: PUSH
70909: EMPTY
70910: LIST
70911: LIST
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: LIST
70917: PPUSH
70918: CALL_OW 72
70922: ST_TO_ADDR
// if not t then
70923: LD_VAR 0 6
70927: NOT
70928: IFFALSE 70932
// continue ;
70930: GO 70789
// for j in tmp do
70932: LD_ADDR_VAR 0 3
70936: PUSH
70937: LD_VAR 0 4
70941: PUSH
70942: FOR_IN
70943: IFFALSE 70973
// if not BuildingStatus ( j ) = bs_idle then
70945: LD_VAR 0 3
70949: PPUSH
70950: CALL_OW 461
70954: PUSH
70955: LD_INT 2
70957: EQUAL
70958: NOT
70959: IFFALSE 70971
// begin busy := true ;
70961: LD_ADDR_VAR 0 8
70965: PUSH
70966: LD_INT 1
70968: ST_TO_ADDR
// break ;
70969: GO 70973
// end ;
70971: GO 70942
70973: POP
70974: POP
// if busy then
70975: LD_VAR 0 8
70979: IFFALSE 70983
// continue ;
70981: GO 70789
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
70983: LD_ADDR_VAR 0 7
70987: PUSH
70988: LD_VAR 0 6
70992: PPUSH
70993: LD_INT 35
70995: PUSH
70996: LD_INT 0
70998: PUSH
70999: EMPTY
71000: LIST
71001: LIST
71002: PPUSH
71003: CALL_OW 72
71007: ST_TO_ADDR
// if tw then
71008: LD_VAR 0 7
71012: IFFALSE 71089
// begin tw := tw [ 1 ] ;
71014: LD_ADDR_VAR 0 7
71018: PUSH
71019: LD_VAR 0 7
71023: PUSH
71024: LD_INT 1
71026: ARRAY
71027: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
71028: LD_ADDR_VAR 0 9
71032: PUSH
71033: LD_VAR 0 7
71037: PPUSH
71038: LD_EXP 86
71042: PUSH
71043: LD_VAR 0 2
71047: ARRAY
71048: PPUSH
71049: CALL 26782 0 2
71053: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
71054: LD_EXP 100
71058: PUSH
71059: LD_VAR 0 2
71063: ARRAY
71064: IFFALSE 71087
// if not weapon in mc_allowed_tower_weapons [ i ] then
71066: LD_VAR 0 9
71070: PUSH
71071: LD_EXP 100
71075: PUSH
71076: LD_VAR 0 2
71080: ARRAY
71081: IN
71082: NOT
71083: IFFALSE 71087
// continue ;
71085: GO 70789
// end else
71087: GO 71152
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
71089: LD_ADDR_VAR 0 5
71093: PUSH
71094: LD_EXP 69
71098: PUSH
71099: LD_VAR 0 2
71103: ARRAY
71104: PPUSH
71105: LD_VAR 0 4
71109: PPUSH
71110: CALL 53685 0 2
71114: ST_TO_ADDR
// if not tmp2 then
71115: LD_VAR 0 5
71119: NOT
71120: IFFALSE 71124
// continue ;
71122: GO 70789
// tw := tmp2 [ 1 ] ;
71124: LD_ADDR_VAR 0 7
71128: PUSH
71129: LD_VAR 0 5
71133: PUSH
71134: LD_INT 1
71136: ARRAY
71137: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
71138: LD_ADDR_VAR 0 9
71142: PUSH
71143: LD_VAR 0 5
71147: PUSH
71148: LD_INT 2
71150: ARRAY
71151: ST_TO_ADDR
// end ; if not weapon then
71152: LD_VAR 0 9
71156: NOT
71157: IFFALSE 71161
// continue ;
71159: GO 70789
// ComPlaceWeapon ( tw , weapon ) ;
71161: LD_VAR 0 7
71165: PPUSH
71166: LD_VAR 0 9
71170: PPUSH
71171: CALL_OW 148
// end ;
71175: GO 70789
71177: POP
71178: POP
// end ;
71179: LD_VAR 0 1
71183: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
71184: LD_INT 0
71186: PPUSH
71187: PPUSH
71188: PPUSH
71189: PPUSH
71190: PPUSH
71191: PPUSH
71192: PPUSH
// if not mc_bases then
71193: LD_EXP 61
71197: NOT
71198: IFFALSE 71202
// exit ;
71200: GO 71977
// for i = 1 to mc_bases do
71202: LD_ADDR_VAR 0 2
71206: PUSH
71207: DOUBLE
71208: LD_INT 1
71210: DEC
71211: ST_TO_ADDR
71212: LD_EXP 61
71216: PUSH
71217: FOR_TO
71218: IFFALSE 71975
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
71220: LD_EXP 74
71224: PUSH
71225: LD_VAR 0 2
71229: ARRAY
71230: NOT
71231: PUSH
71232: LD_EXP 74
71236: PUSH
71237: LD_VAR 0 2
71241: ARRAY
71242: PUSH
71243: LD_EXP 75
71247: PUSH
71248: LD_VAR 0 2
71252: ARRAY
71253: EQUAL
71254: OR
71255: PUSH
71256: LD_EXP 84
71260: PUSH
71261: LD_VAR 0 2
71265: ARRAY
71266: OR
71267: IFFALSE 71271
// continue ;
71269: GO 71217
// if mc_miners [ i ] then
71271: LD_EXP 75
71275: PUSH
71276: LD_VAR 0 2
71280: ARRAY
71281: IFFALSE 71662
// begin for j = mc_miners [ i ] downto 1 do
71283: LD_ADDR_VAR 0 3
71287: PUSH
71288: DOUBLE
71289: LD_EXP 75
71293: PUSH
71294: LD_VAR 0 2
71298: ARRAY
71299: INC
71300: ST_TO_ADDR
71301: LD_INT 1
71303: PUSH
71304: FOR_DOWNTO
71305: IFFALSE 71660
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
71307: LD_EXP 75
71311: PUSH
71312: LD_VAR 0 2
71316: ARRAY
71317: PUSH
71318: LD_VAR 0 3
71322: ARRAY
71323: PPUSH
71324: CALL_OW 301
71328: PUSH
71329: LD_EXP 75
71333: PUSH
71334: LD_VAR 0 2
71338: ARRAY
71339: PUSH
71340: LD_VAR 0 3
71344: ARRAY
71345: PPUSH
71346: CALL_OW 257
71350: PUSH
71351: LD_INT 1
71353: NONEQUAL
71354: OR
71355: IFFALSE 71418
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
71357: LD_ADDR_VAR 0 5
71361: PUSH
71362: LD_EXP 75
71366: PUSH
71367: LD_VAR 0 2
71371: ARRAY
71372: PUSH
71373: LD_EXP 75
71377: PUSH
71378: LD_VAR 0 2
71382: ARRAY
71383: PUSH
71384: LD_VAR 0 3
71388: ARRAY
71389: DIFF
71390: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
71391: LD_ADDR_EXP 75
71395: PUSH
71396: LD_EXP 75
71400: PPUSH
71401: LD_VAR 0 2
71405: PPUSH
71406: LD_VAR 0 5
71410: PPUSH
71411: CALL_OW 1
71415: ST_TO_ADDR
// continue ;
71416: GO 71304
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
71418: LD_EXP 75
71422: PUSH
71423: LD_VAR 0 2
71427: ARRAY
71428: PUSH
71429: LD_VAR 0 3
71433: ARRAY
71434: PPUSH
71435: CALL_OW 257
71439: PUSH
71440: LD_INT 1
71442: EQUAL
71443: PUSH
71444: LD_EXP 75
71448: PUSH
71449: LD_VAR 0 2
71453: ARRAY
71454: PUSH
71455: LD_VAR 0 3
71459: ARRAY
71460: PPUSH
71461: CALL_OW 459
71465: NOT
71466: AND
71467: PUSH
71468: LD_EXP 75
71472: PUSH
71473: LD_VAR 0 2
71477: ARRAY
71478: PUSH
71479: LD_VAR 0 3
71483: ARRAY
71484: PPUSH
71485: CALL_OW 314
71489: NOT
71490: AND
71491: IFFALSE 71658
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
71493: LD_EXP 75
71497: PUSH
71498: LD_VAR 0 2
71502: ARRAY
71503: PUSH
71504: LD_VAR 0 3
71508: ARRAY
71509: PPUSH
71510: CALL_OW 310
71514: IFFALSE 71537
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
71516: LD_EXP 75
71520: PUSH
71521: LD_VAR 0 2
71525: ARRAY
71526: PUSH
71527: LD_VAR 0 3
71531: ARRAY
71532: PPUSH
71533: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
71537: LD_EXP 75
71541: PUSH
71542: LD_VAR 0 2
71546: ARRAY
71547: PUSH
71548: LD_VAR 0 3
71552: ARRAY
71553: PPUSH
71554: CALL_OW 314
71558: NOT
71559: IFFALSE 71658
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
71561: LD_ADDR_VAR 0 7
71565: PUSH
71566: LD_VAR 0 3
71570: PUSH
71571: LD_EXP 74
71575: PUSH
71576: LD_VAR 0 2
71580: ARRAY
71581: PPUSH
71582: CALL 18537 0 1
71586: MOD
71587: PUSH
71588: LD_INT 1
71590: PLUS
71591: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
71592: LD_EXP 75
71596: PUSH
71597: LD_VAR 0 2
71601: ARRAY
71602: PUSH
71603: LD_VAR 0 3
71607: ARRAY
71608: PPUSH
71609: LD_EXP 74
71613: PUSH
71614: LD_VAR 0 2
71618: ARRAY
71619: PUSH
71620: LD_VAR 0 7
71624: ARRAY
71625: PUSH
71626: LD_INT 1
71628: ARRAY
71629: PPUSH
71630: LD_EXP 74
71634: PUSH
71635: LD_VAR 0 2
71639: ARRAY
71640: PUSH
71641: LD_VAR 0 7
71645: ARRAY
71646: PUSH
71647: LD_INT 2
71649: ARRAY
71650: PPUSH
71651: LD_INT 0
71653: PPUSH
71654: CALL_OW 193
// end ; end ; end ;
71658: GO 71304
71660: POP
71661: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
71662: LD_ADDR_VAR 0 5
71666: PUSH
71667: LD_EXP 61
71671: PUSH
71672: LD_VAR 0 2
71676: ARRAY
71677: PPUSH
71678: LD_INT 2
71680: PUSH
71681: LD_INT 30
71683: PUSH
71684: LD_INT 4
71686: PUSH
71687: EMPTY
71688: LIST
71689: LIST
71690: PUSH
71691: LD_INT 30
71693: PUSH
71694: LD_INT 5
71696: PUSH
71697: EMPTY
71698: LIST
71699: LIST
71700: PUSH
71701: LD_INT 30
71703: PUSH
71704: LD_INT 32
71706: PUSH
71707: EMPTY
71708: LIST
71709: LIST
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: LIST
71715: LIST
71716: PPUSH
71717: CALL_OW 72
71721: ST_TO_ADDR
// if not tmp then
71722: LD_VAR 0 5
71726: NOT
71727: IFFALSE 71731
// continue ;
71729: GO 71217
// list := [ ] ;
71731: LD_ADDR_VAR 0 6
71735: PUSH
71736: EMPTY
71737: ST_TO_ADDR
// for j in tmp do
71738: LD_ADDR_VAR 0 3
71742: PUSH
71743: LD_VAR 0 5
71747: PUSH
71748: FOR_IN
71749: IFFALSE 71818
// begin for k in UnitsInside ( j ) do
71751: LD_ADDR_VAR 0 4
71755: PUSH
71756: LD_VAR 0 3
71760: PPUSH
71761: CALL_OW 313
71765: PUSH
71766: FOR_IN
71767: IFFALSE 71814
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
71769: LD_VAR 0 4
71773: PPUSH
71774: CALL_OW 257
71778: PUSH
71779: LD_INT 1
71781: EQUAL
71782: PUSH
71783: LD_VAR 0 4
71787: PPUSH
71788: CALL_OW 459
71792: NOT
71793: AND
71794: IFFALSE 71812
// list := list ^ k ;
71796: LD_ADDR_VAR 0 6
71800: PUSH
71801: LD_VAR 0 6
71805: PUSH
71806: LD_VAR 0 4
71810: ADD
71811: ST_TO_ADDR
71812: GO 71766
71814: POP
71815: POP
// end ;
71816: GO 71748
71818: POP
71819: POP
// list := list diff mc_miners [ i ] ;
71820: LD_ADDR_VAR 0 6
71824: PUSH
71825: LD_VAR 0 6
71829: PUSH
71830: LD_EXP 75
71834: PUSH
71835: LD_VAR 0 2
71839: ARRAY
71840: DIFF
71841: ST_TO_ADDR
// if not list then
71842: LD_VAR 0 6
71846: NOT
71847: IFFALSE 71851
// continue ;
71849: GO 71217
// k := mc_mines [ i ] - mc_miners [ i ] ;
71851: LD_ADDR_VAR 0 4
71855: PUSH
71856: LD_EXP 74
71860: PUSH
71861: LD_VAR 0 2
71865: ARRAY
71866: PUSH
71867: LD_EXP 75
71871: PUSH
71872: LD_VAR 0 2
71876: ARRAY
71877: MINUS
71878: ST_TO_ADDR
// if k > list then
71879: LD_VAR 0 4
71883: PUSH
71884: LD_VAR 0 6
71888: GREATER
71889: IFFALSE 71901
// k := list ;
71891: LD_ADDR_VAR 0 4
71895: PUSH
71896: LD_VAR 0 6
71900: ST_TO_ADDR
// for j = 1 to k do
71901: LD_ADDR_VAR 0 3
71905: PUSH
71906: DOUBLE
71907: LD_INT 1
71909: DEC
71910: ST_TO_ADDR
71911: LD_VAR 0 4
71915: PUSH
71916: FOR_TO
71917: IFFALSE 71971
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
71919: LD_ADDR_EXP 75
71923: PUSH
71924: LD_EXP 75
71928: PPUSH
71929: LD_VAR 0 2
71933: PUSH
71934: LD_EXP 75
71938: PUSH
71939: LD_VAR 0 2
71943: ARRAY
71944: PUSH
71945: LD_INT 1
71947: PLUS
71948: PUSH
71949: EMPTY
71950: LIST
71951: LIST
71952: PPUSH
71953: LD_VAR 0 6
71957: PUSH
71958: LD_VAR 0 3
71962: ARRAY
71963: PPUSH
71964: CALL 21397 0 3
71968: ST_TO_ADDR
71969: GO 71916
71971: POP
71972: POP
// end ;
71973: GO 71217
71975: POP
71976: POP
// end ;
71977: LD_VAR 0 1
71981: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
71982: LD_INT 0
71984: PPUSH
71985: PPUSH
71986: PPUSH
71987: PPUSH
71988: PPUSH
71989: PPUSH
71990: PPUSH
71991: PPUSH
71992: PPUSH
71993: PPUSH
71994: PPUSH
// if not mc_bases then
71995: LD_EXP 61
71999: NOT
72000: IFFALSE 72004
// exit ;
72002: GO 73827
// for i = 1 to mc_bases do
72004: LD_ADDR_VAR 0 2
72008: PUSH
72009: DOUBLE
72010: LD_INT 1
72012: DEC
72013: ST_TO_ADDR
72014: LD_EXP 61
72018: PUSH
72019: FOR_TO
72020: IFFALSE 73825
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
72022: LD_EXP 61
72026: PUSH
72027: LD_VAR 0 2
72031: ARRAY
72032: NOT
72033: PUSH
72034: LD_EXP 68
72038: PUSH
72039: LD_VAR 0 2
72043: ARRAY
72044: OR
72045: IFFALSE 72049
// continue ;
72047: GO 72019
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
72049: LD_EXP 77
72053: PUSH
72054: LD_VAR 0 2
72058: ARRAY
72059: NOT
72060: PUSH
72061: LD_EXP 78
72065: PUSH
72066: LD_VAR 0 2
72070: ARRAY
72071: AND
72072: IFFALSE 72110
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
72074: LD_ADDR_EXP 78
72078: PUSH
72079: LD_EXP 78
72083: PPUSH
72084: LD_VAR 0 2
72088: PPUSH
72089: EMPTY
72090: PPUSH
72091: CALL_OW 1
72095: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
72096: LD_VAR 0 2
72100: PPUSH
72101: LD_INT 107
72103: PPUSH
72104: CALL 62836 0 2
// continue ;
72108: GO 72019
// end ; target := [ ] ;
72110: LD_ADDR_VAR 0 7
72114: PUSH
72115: EMPTY
72116: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72117: LD_ADDR_VAR 0 6
72121: PUSH
72122: LD_EXP 61
72126: PUSH
72127: LD_VAR 0 2
72131: ARRAY
72132: PUSH
72133: LD_INT 1
72135: ARRAY
72136: PPUSH
72137: CALL_OW 255
72141: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72142: LD_ADDR_VAR 0 9
72146: PUSH
72147: LD_EXP 61
72151: PUSH
72152: LD_VAR 0 2
72156: ARRAY
72157: PPUSH
72158: LD_INT 2
72160: PUSH
72161: LD_INT 30
72163: PUSH
72164: LD_INT 0
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: PUSH
72171: LD_INT 30
72173: PUSH
72174: LD_INT 1
72176: PUSH
72177: EMPTY
72178: LIST
72179: LIST
72180: PUSH
72181: EMPTY
72182: LIST
72183: LIST
72184: LIST
72185: PPUSH
72186: CALL_OW 72
72190: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
72191: LD_ADDR_VAR 0 3
72195: PUSH
72196: DOUBLE
72197: LD_EXP 77
72201: PUSH
72202: LD_VAR 0 2
72206: ARRAY
72207: INC
72208: ST_TO_ADDR
72209: LD_INT 1
72211: PUSH
72212: FOR_DOWNTO
72213: IFFALSE 72458
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
72215: LD_EXP 77
72219: PUSH
72220: LD_VAR 0 2
72224: ARRAY
72225: PUSH
72226: LD_VAR 0 3
72230: ARRAY
72231: PUSH
72232: LD_INT 2
72234: ARRAY
72235: PPUSH
72236: LD_EXP 77
72240: PUSH
72241: LD_VAR 0 2
72245: ARRAY
72246: PUSH
72247: LD_VAR 0 3
72251: ARRAY
72252: PUSH
72253: LD_INT 3
72255: ARRAY
72256: PPUSH
72257: CALL_OW 488
72261: PUSH
72262: LD_EXP 77
72266: PUSH
72267: LD_VAR 0 2
72271: ARRAY
72272: PUSH
72273: LD_VAR 0 3
72277: ARRAY
72278: PUSH
72279: LD_INT 2
72281: ARRAY
72282: PPUSH
72283: LD_EXP 77
72287: PUSH
72288: LD_VAR 0 2
72292: ARRAY
72293: PUSH
72294: LD_VAR 0 3
72298: ARRAY
72299: PUSH
72300: LD_INT 3
72302: ARRAY
72303: PPUSH
72304: CALL_OW 284
72308: PUSH
72309: LD_INT 0
72311: EQUAL
72312: AND
72313: IFFALSE 72368
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
72315: LD_ADDR_VAR 0 5
72319: PUSH
72320: LD_EXP 77
72324: PUSH
72325: LD_VAR 0 2
72329: ARRAY
72330: PPUSH
72331: LD_VAR 0 3
72335: PPUSH
72336: CALL_OW 3
72340: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
72341: LD_ADDR_EXP 77
72345: PUSH
72346: LD_EXP 77
72350: PPUSH
72351: LD_VAR 0 2
72355: PPUSH
72356: LD_VAR 0 5
72360: PPUSH
72361: CALL_OW 1
72365: ST_TO_ADDR
// continue ;
72366: GO 72212
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
72368: LD_VAR 0 6
72372: PPUSH
72373: LD_EXP 77
72377: PUSH
72378: LD_VAR 0 2
72382: ARRAY
72383: PUSH
72384: LD_VAR 0 3
72388: ARRAY
72389: PUSH
72390: LD_INT 2
72392: ARRAY
72393: PPUSH
72394: LD_EXP 77
72398: PUSH
72399: LD_VAR 0 2
72403: ARRAY
72404: PUSH
72405: LD_VAR 0 3
72409: ARRAY
72410: PUSH
72411: LD_INT 3
72413: ARRAY
72414: PPUSH
72415: LD_INT 30
72417: PPUSH
72418: CALL 22661 0 4
72422: PUSH
72423: LD_INT 4
72425: ARRAY
72426: PUSH
72427: LD_INT 0
72429: EQUAL
72430: IFFALSE 72456
// begin target := mc_crates [ i ] [ j ] ;
72432: LD_ADDR_VAR 0 7
72436: PUSH
72437: LD_EXP 77
72441: PUSH
72442: LD_VAR 0 2
72446: ARRAY
72447: PUSH
72448: LD_VAR 0 3
72452: ARRAY
72453: ST_TO_ADDR
// break ;
72454: GO 72458
// end ; end ;
72456: GO 72212
72458: POP
72459: POP
// if not target then
72460: LD_VAR 0 7
72464: NOT
72465: IFFALSE 72469
// continue ;
72467: GO 72019
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
72469: LD_ADDR_VAR 0 8
72473: PUSH
72474: LD_EXP 80
72478: PUSH
72479: LD_VAR 0 2
72483: ARRAY
72484: PPUSH
72485: LD_INT 2
72487: PUSH
72488: LD_INT 3
72490: PUSH
72491: LD_INT 58
72493: PUSH
72494: EMPTY
72495: LIST
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PUSH
72501: LD_INT 61
72503: PUSH
72504: EMPTY
72505: LIST
72506: PUSH
72507: LD_INT 33
72509: PUSH
72510: LD_INT 5
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: PUSH
72517: LD_INT 33
72519: PUSH
72520: LD_INT 3
72522: PUSH
72523: EMPTY
72524: LIST
72525: LIST
72526: PUSH
72527: EMPTY
72528: LIST
72529: LIST
72530: LIST
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 2
72536: PUSH
72537: LD_INT 34
72539: PUSH
72540: LD_INT 32
72542: PUSH
72543: EMPTY
72544: LIST
72545: LIST
72546: PUSH
72547: LD_INT 34
72549: PUSH
72550: LD_INT 51
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: PUSH
72557: LD_INT 34
72559: PUSH
72560: LD_INT 12
72562: PUSH
72563: EMPTY
72564: LIST
72565: LIST
72566: PUSH
72567: EMPTY
72568: LIST
72569: LIST
72570: LIST
72571: LIST
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: PPUSH
72577: CALL_OW 72
72581: ST_TO_ADDR
// if not cargo then
72582: LD_VAR 0 8
72586: NOT
72587: IFFALSE 73293
// begin if mc_crates_collector [ i ] < 5 then
72589: LD_EXP 78
72593: PUSH
72594: LD_VAR 0 2
72598: ARRAY
72599: PUSH
72600: LD_INT 5
72602: LESS
72603: IFFALSE 72969
// begin if mc_ape [ i ] then
72605: LD_EXP 90
72609: PUSH
72610: LD_VAR 0 2
72614: ARRAY
72615: IFFALSE 72662
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
72617: LD_ADDR_VAR 0 5
72621: PUSH
72622: LD_EXP 90
72626: PUSH
72627: LD_VAR 0 2
72631: ARRAY
72632: PPUSH
72633: LD_INT 25
72635: PUSH
72636: LD_INT 16
72638: PUSH
72639: EMPTY
72640: LIST
72641: LIST
72642: PUSH
72643: LD_INT 24
72645: PUSH
72646: LD_INT 750
72648: PUSH
72649: EMPTY
72650: LIST
72651: LIST
72652: PUSH
72653: EMPTY
72654: LIST
72655: LIST
72656: PPUSH
72657: CALL_OW 72
72661: ST_TO_ADDR
// if not tmp then
72662: LD_VAR 0 5
72666: NOT
72667: IFFALSE 72714
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
72669: LD_ADDR_VAR 0 5
72673: PUSH
72674: LD_EXP 61
72678: PUSH
72679: LD_VAR 0 2
72683: ARRAY
72684: PPUSH
72685: LD_INT 25
72687: PUSH
72688: LD_INT 2
72690: PUSH
72691: EMPTY
72692: LIST
72693: LIST
72694: PUSH
72695: LD_INT 24
72697: PUSH
72698: LD_INT 750
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: PUSH
72705: EMPTY
72706: LIST
72707: LIST
72708: PPUSH
72709: CALL_OW 72
72713: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
72714: LD_EXP 90
72718: PUSH
72719: LD_VAR 0 2
72723: ARRAY
72724: PUSH
72725: LD_EXP 61
72729: PUSH
72730: LD_VAR 0 2
72734: ARRAY
72735: PPUSH
72736: LD_INT 25
72738: PUSH
72739: LD_INT 2
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: PUSH
72746: LD_INT 24
72748: PUSH
72749: LD_INT 750
72751: PUSH
72752: EMPTY
72753: LIST
72754: LIST
72755: PUSH
72756: EMPTY
72757: LIST
72758: LIST
72759: PPUSH
72760: CALL_OW 72
72764: AND
72765: PUSH
72766: LD_VAR 0 5
72770: PUSH
72771: LD_INT 5
72773: LESS
72774: AND
72775: IFFALSE 72857
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
72777: LD_ADDR_VAR 0 3
72781: PUSH
72782: LD_EXP 61
72786: PUSH
72787: LD_VAR 0 2
72791: ARRAY
72792: PPUSH
72793: LD_INT 25
72795: PUSH
72796: LD_INT 2
72798: PUSH
72799: EMPTY
72800: LIST
72801: LIST
72802: PUSH
72803: LD_INT 24
72805: PUSH
72806: LD_INT 750
72808: PUSH
72809: EMPTY
72810: LIST
72811: LIST
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: PPUSH
72817: CALL_OW 72
72821: PUSH
72822: FOR_IN
72823: IFFALSE 72855
// begin tmp := tmp union j ;
72825: LD_ADDR_VAR 0 5
72829: PUSH
72830: LD_VAR 0 5
72834: PUSH
72835: LD_VAR 0 3
72839: UNION
72840: ST_TO_ADDR
// if tmp >= 5 then
72841: LD_VAR 0 5
72845: PUSH
72846: LD_INT 5
72848: GREATEREQUAL
72849: IFFALSE 72853
// break ;
72851: GO 72855
// end ;
72853: GO 72822
72855: POP
72856: POP
// end ; if not tmp then
72857: LD_VAR 0 5
72861: NOT
72862: IFFALSE 72866
// continue ;
72864: GO 72019
// for j in tmp do
72866: LD_ADDR_VAR 0 3
72870: PUSH
72871: LD_VAR 0 5
72875: PUSH
72876: FOR_IN
72877: IFFALSE 72967
// if not GetTag ( j ) then
72879: LD_VAR 0 3
72883: PPUSH
72884: CALL_OW 110
72888: NOT
72889: IFFALSE 72965
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
72891: LD_ADDR_EXP 78
72895: PUSH
72896: LD_EXP 78
72900: PPUSH
72901: LD_VAR 0 2
72905: PUSH
72906: LD_EXP 78
72910: PUSH
72911: LD_VAR 0 2
72915: ARRAY
72916: PUSH
72917: LD_INT 1
72919: PLUS
72920: PUSH
72921: EMPTY
72922: LIST
72923: LIST
72924: PPUSH
72925: LD_VAR 0 3
72929: PPUSH
72930: CALL 21397 0 3
72934: ST_TO_ADDR
// SetTag ( j , 107 ) ;
72935: LD_VAR 0 3
72939: PPUSH
72940: LD_INT 107
72942: PPUSH
72943: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
72947: LD_EXP 78
72951: PUSH
72952: LD_VAR 0 2
72956: ARRAY
72957: PUSH
72958: LD_INT 5
72960: GREATEREQUAL
72961: IFFALSE 72965
// break ;
72963: GO 72967
// end ;
72965: GO 72876
72967: POP
72968: POP
// end ; if mc_crates_collector [ i ] and target then
72969: LD_EXP 78
72973: PUSH
72974: LD_VAR 0 2
72978: ARRAY
72979: PUSH
72980: LD_VAR 0 7
72984: AND
72985: IFFALSE 73291
// begin if mc_crates_collector [ i ] < target [ 1 ] then
72987: LD_EXP 78
72991: PUSH
72992: LD_VAR 0 2
72996: ARRAY
72997: PUSH
72998: LD_VAR 0 7
73002: PUSH
73003: LD_INT 1
73005: ARRAY
73006: LESS
73007: IFFALSE 73027
// tmp := mc_crates_collector [ i ] else
73009: LD_ADDR_VAR 0 5
73013: PUSH
73014: LD_EXP 78
73018: PUSH
73019: LD_VAR 0 2
73023: ARRAY
73024: ST_TO_ADDR
73025: GO 73041
// tmp := target [ 1 ] ;
73027: LD_ADDR_VAR 0 5
73031: PUSH
73032: LD_VAR 0 7
73036: PUSH
73037: LD_INT 1
73039: ARRAY
73040: ST_TO_ADDR
// k := 0 ;
73041: LD_ADDR_VAR 0 4
73045: PUSH
73046: LD_INT 0
73048: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
73049: LD_ADDR_VAR 0 3
73053: PUSH
73054: LD_EXP 78
73058: PUSH
73059: LD_VAR 0 2
73063: ARRAY
73064: PUSH
73065: FOR_IN
73066: IFFALSE 73289
// begin k := k + 1 ;
73068: LD_ADDR_VAR 0 4
73072: PUSH
73073: LD_VAR 0 4
73077: PUSH
73078: LD_INT 1
73080: PLUS
73081: ST_TO_ADDR
// if k > tmp then
73082: LD_VAR 0 4
73086: PUSH
73087: LD_VAR 0 5
73091: GREATER
73092: IFFALSE 73096
// break ;
73094: GO 73289
// if not GetClass ( j ) in [ 2 , 16 ] then
73096: LD_VAR 0 3
73100: PPUSH
73101: CALL_OW 257
73105: PUSH
73106: LD_INT 2
73108: PUSH
73109: LD_INT 16
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: IN
73116: NOT
73117: IFFALSE 73170
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
73119: LD_ADDR_EXP 78
73123: PUSH
73124: LD_EXP 78
73128: PPUSH
73129: LD_VAR 0 2
73133: PPUSH
73134: LD_EXP 78
73138: PUSH
73139: LD_VAR 0 2
73143: ARRAY
73144: PUSH
73145: LD_VAR 0 3
73149: DIFF
73150: PPUSH
73151: CALL_OW 1
73155: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73156: LD_VAR 0 3
73160: PPUSH
73161: LD_INT 0
73163: PPUSH
73164: CALL_OW 109
// continue ;
73168: GO 73065
// end ; if IsInUnit ( j ) then
73170: LD_VAR 0 3
73174: PPUSH
73175: CALL_OW 310
73179: IFFALSE 73190
// ComExitBuilding ( j ) ;
73181: LD_VAR 0 3
73185: PPUSH
73186: CALL_OW 122
// wait ( 3 ) ;
73190: LD_INT 3
73192: PPUSH
73193: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
73197: LD_VAR 0 3
73201: PPUSH
73202: CALL_OW 314
73206: PUSH
73207: LD_VAR 0 6
73211: PPUSH
73212: LD_VAR 0 7
73216: PUSH
73217: LD_INT 2
73219: ARRAY
73220: PPUSH
73221: LD_VAR 0 7
73225: PUSH
73226: LD_INT 3
73228: ARRAY
73229: PPUSH
73230: LD_INT 30
73232: PPUSH
73233: CALL 22661 0 4
73237: PUSH
73238: LD_INT 4
73240: ARRAY
73241: AND
73242: IFFALSE 73260
// ComStandNearbyBuilding ( j , depot ) else
73244: LD_VAR 0 3
73248: PPUSH
73249: LD_VAR 0 9
73253: PPUSH
73254: CALL 17999 0 2
73258: GO 73287
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
73260: LD_VAR 0 3
73264: PPUSH
73265: LD_VAR 0 7
73269: PUSH
73270: LD_INT 2
73272: ARRAY
73273: PPUSH
73274: LD_VAR 0 7
73278: PUSH
73279: LD_INT 3
73281: ARRAY
73282: PPUSH
73283: CALL_OW 117
// end ;
73287: GO 73065
73289: POP
73290: POP
// end ; end else
73291: GO 73823
// begin for j in cargo do
73293: LD_ADDR_VAR 0 3
73297: PUSH
73298: LD_VAR 0 8
73302: PUSH
73303: FOR_IN
73304: IFFALSE 73821
// begin if GetTag ( j ) <> 0 then
73306: LD_VAR 0 3
73310: PPUSH
73311: CALL_OW 110
73315: PUSH
73316: LD_INT 0
73318: NONEQUAL
73319: IFFALSE 73323
// continue ;
73321: GO 73303
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
73323: LD_VAR 0 3
73327: PPUSH
73328: CALL_OW 256
73332: PUSH
73333: LD_INT 1000
73335: LESS
73336: PUSH
73337: LD_VAR 0 3
73341: PPUSH
73342: LD_EXP 85
73346: PUSH
73347: LD_VAR 0 2
73351: ARRAY
73352: PPUSH
73353: CALL_OW 308
73357: NOT
73358: AND
73359: IFFALSE 73381
// ComMoveToArea ( j , mc_parking [ i ] ) ;
73361: LD_VAR 0 3
73365: PPUSH
73366: LD_EXP 85
73370: PUSH
73371: LD_VAR 0 2
73375: ARRAY
73376: PPUSH
73377: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
73381: LD_VAR 0 3
73385: PPUSH
73386: CALL_OW 256
73390: PUSH
73391: LD_INT 1000
73393: LESS
73394: PUSH
73395: LD_VAR 0 3
73399: PPUSH
73400: LD_EXP 85
73404: PUSH
73405: LD_VAR 0 2
73409: ARRAY
73410: PPUSH
73411: CALL_OW 308
73415: AND
73416: IFFALSE 73420
// continue ;
73418: GO 73303
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
73420: LD_VAR 0 3
73424: PPUSH
73425: CALL_OW 262
73429: PUSH
73430: LD_INT 2
73432: EQUAL
73433: PUSH
73434: LD_VAR 0 3
73438: PPUSH
73439: CALL_OW 261
73443: PUSH
73444: LD_INT 15
73446: LESS
73447: AND
73448: IFFALSE 73452
// continue ;
73450: GO 73303
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
73452: LD_VAR 0 3
73456: PPUSH
73457: CALL_OW 262
73461: PUSH
73462: LD_INT 1
73464: EQUAL
73465: PUSH
73466: LD_VAR 0 3
73470: PPUSH
73471: CALL_OW 261
73475: PUSH
73476: LD_INT 10
73478: LESS
73479: AND
73480: IFFALSE 73760
// begin if not depot then
73482: LD_VAR 0 9
73486: NOT
73487: IFFALSE 73491
// continue ;
73489: GO 73303
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
73491: LD_VAR 0 3
73495: PPUSH
73496: LD_VAR 0 9
73500: PPUSH
73501: LD_VAR 0 3
73505: PPUSH
73506: CALL_OW 74
73510: PPUSH
73511: CALL_OW 296
73515: PUSH
73516: LD_INT 6
73518: LESS
73519: IFFALSE 73535
// SetFuel ( j , 100 ) else
73521: LD_VAR 0 3
73525: PPUSH
73526: LD_INT 100
73528: PPUSH
73529: CALL_OW 240
73533: GO 73760
// if GetFuel ( j ) = 0 then
73535: LD_VAR 0 3
73539: PPUSH
73540: CALL_OW 261
73544: PUSH
73545: LD_INT 0
73547: EQUAL
73548: IFFALSE 73760
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
73550: LD_ADDR_EXP 80
73554: PUSH
73555: LD_EXP 80
73559: PPUSH
73560: LD_VAR 0 2
73564: PPUSH
73565: LD_EXP 80
73569: PUSH
73570: LD_VAR 0 2
73574: ARRAY
73575: PUSH
73576: LD_VAR 0 3
73580: DIFF
73581: PPUSH
73582: CALL_OW 1
73586: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
73587: LD_VAR 0 3
73591: PPUSH
73592: CALL_OW 263
73596: PUSH
73597: LD_INT 1
73599: EQUAL
73600: IFFALSE 73616
// ComExitVehicle ( IsInUnit ( j ) ) ;
73602: LD_VAR 0 3
73606: PPUSH
73607: CALL_OW 310
73611: PPUSH
73612: CALL_OW 121
// if GetControl ( j ) = control_remote then
73616: LD_VAR 0 3
73620: PPUSH
73621: CALL_OW 263
73625: PUSH
73626: LD_INT 2
73628: EQUAL
73629: IFFALSE 73640
// ComUnlink ( j ) ;
73631: LD_VAR 0 3
73635: PPUSH
73636: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
73640: LD_ADDR_VAR 0 10
73644: PUSH
73645: LD_VAR 0 2
73649: PPUSH
73650: LD_INT 3
73652: PPUSH
73653: CALL 83404 0 2
73657: ST_TO_ADDR
// if fac then
73658: LD_VAR 0 10
73662: IFFALSE 73758
// begin for k in fac do
73664: LD_ADDR_VAR 0 4
73668: PUSH
73669: LD_VAR 0 10
73673: PUSH
73674: FOR_IN
73675: IFFALSE 73756
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
73677: LD_ADDR_VAR 0 11
73681: PUSH
73682: LD_VAR 0 10
73686: PPUSH
73687: LD_VAR 0 3
73691: PPUSH
73692: CALL_OW 265
73696: PPUSH
73697: LD_VAR 0 3
73701: PPUSH
73702: CALL_OW 262
73706: PPUSH
73707: LD_VAR 0 3
73711: PPUSH
73712: CALL_OW 263
73716: PPUSH
73717: LD_VAR 0 3
73721: PPUSH
73722: CALL_OW 264
73726: PPUSH
73727: CALL 18895 0 5
73731: ST_TO_ADDR
// if components then
73732: LD_VAR 0 11
73736: IFFALSE 73754
// begin MC_InsertProduceList ( i , components ) ;
73738: LD_VAR 0 2
73742: PPUSH
73743: LD_VAR 0 11
73747: PPUSH
73748: CALL 82949 0 2
// break ;
73752: GO 73756
// end ; end ;
73754: GO 73674
73756: POP
73757: POP
// end ; continue ;
73758: GO 73303
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
73760: LD_VAR 0 3
73764: PPUSH
73765: LD_INT 1
73767: PPUSH
73768: CALL_OW 289
73772: PUSH
73773: LD_INT 100
73775: LESS
73776: PUSH
73777: LD_VAR 0 3
73781: PPUSH
73782: CALL_OW 314
73786: NOT
73787: AND
73788: IFFALSE 73817
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
73790: LD_VAR 0 3
73794: PPUSH
73795: LD_VAR 0 7
73799: PUSH
73800: LD_INT 2
73802: ARRAY
73803: PPUSH
73804: LD_VAR 0 7
73808: PUSH
73809: LD_INT 3
73811: ARRAY
73812: PPUSH
73813: CALL_OW 117
// break ;
73817: GO 73821
// end ;
73819: GO 73303
73821: POP
73822: POP
// end ; end ;
73823: GO 72019
73825: POP
73826: POP
// end ;
73827: LD_VAR 0 1
73831: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
73832: LD_INT 0
73834: PPUSH
73835: PPUSH
73836: PPUSH
73837: PPUSH
// if not mc_bases then
73838: LD_EXP 61
73842: NOT
73843: IFFALSE 73847
// exit ;
73845: GO 74008
// for i = 1 to mc_bases do
73847: LD_ADDR_VAR 0 2
73851: PUSH
73852: DOUBLE
73853: LD_INT 1
73855: DEC
73856: ST_TO_ADDR
73857: LD_EXP 61
73861: PUSH
73862: FOR_TO
73863: IFFALSE 74006
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
73865: LD_ADDR_VAR 0 4
73869: PUSH
73870: LD_EXP 80
73874: PUSH
73875: LD_VAR 0 2
73879: ARRAY
73880: PUSH
73881: LD_EXP 83
73885: PUSH
73886: LD_VAR 0 2
73890: ARRAY
73891: UNION
73892: PPUSH
73893: LD_INT 33
73895: PUSH
73896: LD_INT 2
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: PPUSH
73903: CALL_OW 72
73907: ST_TO_ADDR
// if tmp then
73908: LD_VAR 0 4
73912: IFFALSE 74004
// for j in tmp do
73914: LD_ADDR_VAR 0 3
73918: PUSH
73919: LD_VAR 0 4
73923: PUSH
73924: FOR_IN
73925: IFFALSE 74002
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
73927: LD_VAR 0 3
73931: PPUSH
73932: CALL_OW 312
73936: NOT
73937: PUSH
73938: LD_VAR 0 3
73942: PPUSH
73943: CALL_OW 256
73947: PUSH
73948: LD_INT 250
73950: GREATEREQUAL
73951: AND
73952: IFFALSE 73965
// Connect ( j ) else
73954: LD_VAR 0 3
73958: PPUSH
73959: CALL 24743 0 1
73963: GO 74000
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
73965: LD_VAR 0 3
73969: PPUSH
73970: CALL_OW 256
73974: PUSH
73975: LD_INT 250
73977: LESS
73978: PUSH
73979: LD_VAR 0 3
73983: PPUSH
73984: CALL_OW 312
73988: AND
73989: IFFALSE 74000
// ComUnlink ( j ) ;
73991: LD_VAR 0 3
73995: PPUSH
73996: CALL_OW 136
74000: GO 73924
74002: POP
74003: POP
// end ;
74004: GO 73862
74006: POP
74007: POP
// end ;
74008: LD_VAR 0 1
74012: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
74013: LD_INT 0
74015: PPUSH
74016: PPUSH
74017: PPUSH
74018: PPUSH
74019: PPUSH
// if not mc_bases then
74020: LD_EXP 61
74024: NOT
74025: IFFALSE 74029
// exit ;
74027: GO 74474
// for i = 1 to mc_bases do
74029: LD_ADDR_VAR 0 2
74033: PUSH
74034: DOUBLE
74035: LD_INT 1
74037: DEC
74038: ST_TO_ADDR
74039: LD_EXP 61
74043: PUSH
74044: FOR_TO
74045: IFFALSE 74472
// begin if not mc_produce [ i ] then
74047: LD_EXP 82
74051: PUSH
74052: LD_VAR 0 2
74056: ARRAY
74057: NOT
74058: IFFALSE 74062
// continue ;
74060: GO 74044
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74062: LD_ADDR_VAR 0 5
74066: PUSH
74067: LD_EXP 61
74071: PUSH
74072: LD_VAR 0 2
74076: ARRAY
74077: PPUSH
74078: LD_INT 30
74080: PUSH
74081: LD_INT 3
74083: PUSH
74084: EMPTY
74085: LIST
74086: LIST
74087: PPUSH
74088: CALL_OW 72
74092: ST_TO_ADDR
// if not fac then
74093: LD_VAR 0 5
74097: NOT
74098: IFFALSE 74102
// continue ;
74100: GO 74044
// for j in fac do
74102: LD_ADDR_VAR 0 3
74106: PUSH
74107: LD_VAR 0 5
74111: PUSH
74112: FOR_IN
74113: IFFALSE 74468
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
74115: LD_VAR 0 3
74119: PPUSH
74120: CALL_OW 461
74124: PUSH
74125: LD_INT 2
74127: NONEQUAL
74128: PUSH
74129: LD_VAR 0 3
74133: PPUSH
74134: LD_INT 15
74136: PPUSH
74137: CALL 24362 0 2
74141: PUSH
74142: LD_INT 4
74144: ARRAY
74145: OR
74146: IFFALSE 74150
// continue ;
74148: GO 74112
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
74150: LD_VAR 0 3
74154: PPUSH
74155: LD_EXP 82
74159: PUSH
74160: LD_VAR 0 2
74164: ARRAY
74165: PUSH
74166: LD_INT 1
74168: ARRAY
74169: PUSH
74170: LD_INT 1
74172: ARRAY
74173: PPUSH
74174: LD_EXP 82
74178: PUSH
74179: LD_VAR 0 2
74183: ARRAY
74184: PUSH
74185: LD_INT 1
74187: ARRAY
74188: PUSH
74189: LD_INT 2
74191: ARRAY
74192: PPUSH
74193: LD_EXP 82
74197: PUSH
74198: LD_VAR 0 2
74202: ARRAY
74203: PUSH
74204: LD_INT 1
74206: ARRAY
74207: PUSH
74208: LD_INT 3
74210: ARRAY
74211: PPUSH
74212: LD_EXP 82
74216: PUSH
74217: LD_VAR 0 2
74221: ARRAY
74222: PUSH
74223: LD_INT 1
74225: ARRAY
74226: PUSH
74227: LD_INT 4
74229: ARRAY
74230: PPUSH
74231: CALL_OW 448
74235: PUSH
74236: LD_VAR 0 3
74240: PPUSH
74241: LD_EXP 82
74245: PUSH
74246: LD_VAR 0 2
74250: ARRAY
74251: PUSH
74252: LD_INT 1
74254: ARRAY
74255: PUSH
74256: LD_INT 1
74258: ARRAY
74259: PUSH
74260: LD_EXP 82
74264: PUSH
74265: LD_VAR 0 2
74269: ARRAY
74270: PUSH
74271: LD_INT 1
74273: ARRAY
74274: PUSH
74275: LD_INT 2
74277: ARRAY
74278: PUSH
74279: LD_EXP 82
74283: PUSH
74284: LD_VAR 0 2
74288: ARRAY
74289: PUSH
74290: LD_INT 1
74292: ARRAY
74293: PUSH
74294: LD_INT 3
74296: ARRAY
74297: PUSH
74298: LD_EXP 82
74302: PUSH
74303: LD_VAR 0 2
74307: ARRAY
74308: PUSH
74309: LD_INT 1
74311: ARRAY
74312: PUSH
74313: LD_INT 4
74315: ARRAY
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: LIST
74321: LIST
74322: PPUSH
74323: CALL 28138 0 2
74327: AND
74328: IFFALSE 74466
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
74330: LD_VAR 0 3
74334: PPUSH
74335: LD_EXP 82
74339: PUSH
74340: LD_VAR 0 2
74344: ARRAY
74345: PUSH
74346: LD_INT 1
74348: ARRAY
74349: PUSH
74350: LD_INT 1
74352: ARRAY
74353: PPUSH
74354: LD_EXP 82
74358: PUSH
74359: LD_VAR 0 2
74363: ARRAY
74364: PUSH
74365: LD_INT 1
74367: ARRAY
74368: PUSH
74369: LD_INT 2
74371: ARRAY
74372: PPUSH
74373: LD_EXP 82
74377: PUSH
74378: LD_VAR 0 2
74382: ARRAY
74383: PUSH
74384: LD_INT 1
74386: ARRAY
74387: PUSH
74388: LD_INT 3
74390: ARRAY
74391: PPUSH
74392: LD_EXP 82
74396: PUSH
74397: LD_VAR 0 2
74401: ARRAY
74402: PUSH
74403: LD_INT 1
74405: ARRAY
74406: PUSH
74407: LD_INT 4
74409: ARRAY
74410: PPUSH
74411: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
74415: LD_ADDR_VAR 0 4
74419: PUSH
74420: LD_EXP 82
74424: PUSH
74425: LD_VAR 0 2
74429: ARRAY
74430: PPUSH
74431: LD_INT 1
74433: PPUSH
74434: CALL_OW 3
74438: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
74439: LD_ADDR_EXP 82
74443: PUSH
74444: LD_EXP 82
74448: PPUSH
74449: LD_VAR 0 2
74453: PPUSH
74454: LD_VAR 0 4
74458: PPUSH
74459: CALL_OW 1
74463: ST_TO_ADDR
// break ;
74464: GO 74468
// end ; end ;
74466: GO 74112
74468: POP
74469: POP
// end ;
74470: GO 74044
74472: POP
74473: POP
// end ;
74474: LD_VAR 0 1
74478: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
74479: LD_INT 0
74481: PPUSH
74482: PPUSH
74483: PPUSH
// if not mc_bases then
74484: LD_EXP 61
74488: NOT
74489: IFFALSE 74493
// exit ;
74491: GO 74582
// for i = 1 to mc_bases do
74493: LD_ADDR_VAR 0 2
74497: PUSH
74498: DOUBLE
74499: LD_INT 1
74501: DEC
74502: ST_TO_ADDR
74503: LD_EXP 61
74507: PUSH
74508: FOR_TO
74509: IFFALSE 74580
// begin if mc_attack [ i ] then
74511: LD_EXP 81
74515: PUSH
74516: LD_VAR 0 2
74520: ARRAY
74521: IFFALSE 74578
// begin tmp := mc_attack [ i ] [ 1 ] ;
74523: LD_ADDR_VAR 0 3
74527: PUSH
74528: LD_EXP 81
74532: PUSH
74533: LD_VAR 0 2
74537: ARRAY
74538: PUSH
74539: LD_INT 1
74541: ARRAY
74542: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
74543: LD_ADDR_EXP 81
74547: PUSH
74548: LD_EXP 81
74552: PPUSH
74553: LD_VAR 0 2
74557: PPUSH
74558: EMPTY
74559: PPUSH
74560: CALL_OW 1
74564: ST_TO_ADDR
// Attack ( tmp ) ;
74565: LD_VAR 0 3
74569: PPUSH
74570: CALL 110071 0 1
// exit ;
74574: POP
74575: POP
74576: GO 74582
// end ; end ;
74578: GO 74508
74580: POP
74581: POP
// end ;
74582: LD_VAR 0 1
74586: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
74587: LD_INT 0
74589: PPUSH
74590: PPUSH
74591: PPUSH
74592: PPUSH
74593: PPUSH
74594: PPUSH
74595: PPUSH
// if not mc_bases then
74596: LD_EXP 61
74600: NOT
74601: IFFALSE 74605
// exit ;
74603: GO 75462
// for i = 1 to mc_bases do
74605: LD_ADDR_VAR 0 2
74609: PUSH
74610: DOUBLE
74611: LD_INT 1
74613: DEC
74614: ST_TO_ADDR
74615: LD_EXP 61
74619: PUSH
74620: FOR_TO
74621: IFFALSE 75460
// begin if not mc_bases [ i ] then
74623: LD_EXP 61
74627: PUSH
74628: LD_VAR 0 2
74632: ARRAY
74633: NOT
74634: IFFALSE 74638
// continue ;
74636: GO 74620
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
74638: LD_ADDR_VAR 0 7
74642: PUSH
74643: LD_EXP 61
74647: PUSH
74648: LD_VAR 0 2
74652: ARRAY
74653: PUSH
74654: LD_INT 1
74656: ARRAY
74657: PPUSH
74658: CALL 18221 0 1
74662: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
74663: LD_ADDR_EXP 84
74667: PUSH
74668: LD_EXP 84
74672: PPUSH
74673: LD_VAR 0 2
74677: PPUSH
74678: LD_EXP 61
74682: PUSH
74683: LD_VAR 0 2
74687: ARRAY
74688: PUSH
74689: LD_INT 1
74691: ARRAY
74692: PPUSH
74693: CALL_OW 255
74697: PPUSH
74698: LD_EXP 86
74702: PUSH
74703: LD_VAR 0 2
74707: ARRAY
74708: PPUSH
74709: CALL 18186 0 2
74713: PPUSH
74714: CALL_OW 1
74718: ST_TO_ADDR
// if not mc_scan [ i ] then
74719: LD_EXP 84
74723: PUSH
74724: LD_VAR 0 2
74728: ARRAY
74729: NOT
74730: IFFALSE 74908
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
74732: LD_ADDR_EXP 104
74736: PUSH
74737: LD_EXP 104
74741: PPUSH
74742: LD_VAR 0 2
74746: PPUSH
74747: LD_INT 0
74749: PPUSH
74750: CALL_OW 1
74754: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
74755: LD_ADDR_VAR 0 4
74759: PUSH
74760: LD_EXP 61
74764: PUSH
74765: LD_VAR 0 2
74769: ARRAY
74770: PPUSH
74771: LD_INT 2
74773: PUSH
74774: LD_INT 25
74776: PUSH
74777: LD_INT 5
74779: PUSH
74780: EMPTY
74781: LIST
74782: LIST
74783: PUSH
74784: LD_INT 25
74786: PUSH
74787: LD_INT 8
74789: PUSH
74790: EMPTY
74791: LIST
74792: LIST
74793: PUSH
74794: LD_INT 25
74796: PUSH
74797: LD_INT 9
74799: PUSH
74800: EMPTY
74801: LIST
74802: LIST
74803: PUSH
74804: EMPTY
74805: LIST
74806: LIST
74807: LIST
74808: LIST
74809: PPUSH
74810: CALL_OW 72
74814: ST_TO_ADDR
// if not tmp then
74815: LD_VAR 0 4
74819: NOT
74820: IFFALSE 74824
// continue ;
74822: GO 74620
// for j in tmp do
74824: LD_ADDR_VAR 0 3
74828: PUSH
74829: LD_VAR 0 4
74833: PUSH
74834: FOR_IN
74835: IFFALSE 74906
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
74837: LD_VAR 0 3
74841: PPUSH
74842: CALL_OW 310
74846: PPUSH
74847: CALL_OW 266
74851: PUSH
74852: LD_INT 5
74854: EQUAL
74855: PUSH
74856: LD_VAR 0 3
74860: PPUSH
74861: CALL_OW 257
74865: PUSH
74866: LD_INT 1
74868: EQUAL
74869: AND
74870: PUSH
74871: LD_VAR 0 3
74875: PPUSH
74876: CALL_OW 459
74880: NOT
74881: AND
74882: PUSH
74883: LD_VAR 0 7
74887: AND
74888: IFFALSE 74904
// ComChangeProfession ( j , class ) ;
74890: LD_VAR 0 3
74894: PPUSH
74895: LD_VAR 0 7
74899: PPUSH
74900: CALL_OW 123
74904: GO 74834
74906: POP
74907: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
74908: LD_EXP 84
74912: PUSH
74913: LD_VAR 0 2
74917: ARRAY
74918: PUSH
74919: LD_EXP 104
74923: PUSH
74924: LD_VAR 0 2
74928: ARRAY
74929: NOT
74930: AND
74931: PUSH
74932: LD_EXP 83
74936: PUSH
74937: LD_VAR 0 2
74941: ARRAY
74942: NOT
74943: AND
74944: PUSH
74945: LD_EXP 61
74949: PUSH
74950: LD_VAR 0 2
74954: ARRAY
74955: PPUSH
74956: LD_INT 50
74958: PUSH
74959: EMPTY
74960: LIST
74961: PUSH
74962: LD_INT 2
74964: PUSH
74965: LD_INT 30
74967: PUSH
74968: LD_INT 32
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: LD_INT 30
74977: PUSH
74978: LD_INT 33
74980: PUSH
74981: EMPTY
74982: LIST
74983: LIST
74984: PUSH
74985: LD_INT 30
74987: PUSH
74988: LD_INT 4
74990: PUSH
74991: EMPTY
74992: LIST
74993: LIST
74994: PUSH
74995: LD_INT 30
74997: PUSH
74998: LD_INT 5
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: LIST
75009: LIST
75010: LIST
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: PPUSH
75016: CALL_OW 72
75020: PUSH
75021: LD_INT 4
75023: LESS
75024: PUSH
75025: LD_EXP 61
75029: PUSH
75030: LD_VAR 0 2
75034: ARRAY
75035: PPUSH
75036: LD_INT 3
75038: PUSH
75039: LD_INT 24
75041: PUSH
75042: LD_INT 1000
75044: PUSH
75045: EMPTY
75046: LIST
75047: LIST
75048: PUSH
75049: EMPTY
75050: LIST
75051: LIST
75052: PUSH
75053: LD_INT 2
75055: PUSH
75056: LD_INT 30
75058: PUSH
75059: LD_INT 0
75061: PUSH
75062: EMPTY
75063: LIST
75064: LIST
75065: PUSH
75066: LD_INT 30
75068: PUSH
75069: LD_INT 1
75071: PUSH
75072: EMPTY
75073: LIST
75074: LIST
75075: PUSH
75076: EMPTY
75077: LIST
75078: LIST
75079: LIST
75080: PUSH
75081: EMPTY
75082: LIST
75083: LIST
75084: PPUSH
75085: CALL_OW 72
75089: OR
75090: AND
75091: IFFALSE 75342
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
75093: LD_ADDR_EXP 104
75097: PUSH
75098: LD_EXP 104
75102: PPUSH
75103: LD_VAR 0 2
75107: PPUSH
75108: LD_INT 1
75110: PPUSH
75111: CALL_OW 1
75115: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
75116: LD_ADDR_VAR 0 4
75120: PUSH
75121: LD_EXP 61
75125: PUSH
75126: LD_VAR 0 2
75130: ARRAY
75131: PPUSH
75132: LD_INT 2
75134: PUSH
75135: LD_INT 25
75137: PUSH
75138: LD_INT 1
75140: PUSH
75141: EMPTY
75142: LIST
75143: LIST
75144: PUSH
75145: LD_INT 25
75147: PUSH
75148: LD_INT 5
75150: PUSH
75151: EMPTY
75152: LIST
75153: LIST
75154: PUSH
75155: LD_INT 25
75157: PUSH
75158: LD_INT 8
75160: PUSH
75161: EMPTY
75162: LIST
75163: LIST
75164: PUSH
75165: LD_INT 25
75167: PUSH
75168: LD_INT 9
75170: PUSH
75171: EMPTY
75172: LIST
75173: LIST
75174: PUSH
75175: EMPTY
75176: LIST
75177: LIST
75178: LIST
75179: LIST
75180: LIST
75181: PPUSH
75182: CALL_OW 72
75186: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
75187: LD_ADDR_VAR 0 4
75191: PUSH
75192: LD_VAR 0 4
75196: PUSH
75197: LD_VAR 0 4
75201: PPUSH
75202: LD_INT 18
75204: PPUSH
75205: CALL 51706 0 2
75209: DIFF
75210: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
75211: LD_VAR 0 4
75215: NOT
75216: PUSH
75217: LD_EXP 61
75221: PUSH
75222: LD_VAR 0 2
75226: ARRAY
75227: PPUSH
75228: LD_INT 2
75230: PUSH
75231: LD_INT 30
75233: PUSH
75234: LD_INT 4
75236: PUSH
75237: EMPTY
75238: LIST
75239: LIST
75240: PUSH
75241: LD_INT 30
75243: PUSH
75244: LD_INT 5
75246: PUSH
75247: EMPTY
75248: LIST
75249: LIST
75250: PUSH
75251: EMPTY
75252: LIST
75253: LIST
75254: LIST
75255: PPUSH
75256: CALL_OW 72
75260: NOT
75261: AND
75262: IFFALSE 75324
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
75264: LD_ADDR_VAR 0 4
75268: PUSH
75269: LD_EXP 61
75273: PUSH
75274: LD_VAR 0 2
75278: ARRAY
75279: PPUSH
75280: LD_INT 2
75282: PUSH
75283: LD_INT 25
75285: PUSH
75286: LD_INT 2
75288: PUSH
75289: EMPTY
75290: LIST
75291: LIST
75292: PUSH
75293: LD_INT 25
75295: PUSH
75296: LD_INT 3
75298: PUSH
75299: EMPTY
75300: LIST
75301: LIST
75302: PUSH
75303: LD_INT 25
75305: PUSH
75306: LD_INT 4
75308: PUSH
75309: EMPTY
75310: LIST
75311: LIST
75312: PUSH
75313: EMPTY
75314: LIST
75315: LIST
75316: LIST
75317: LIST
75318: PPUSH
75319: CALL_OW 72
75323: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
75324: LD_VAR 0 2
75328: PPUSH
75329: LD_VAR 0 4
75333: PPUSH
75334: CALL 114780 0 2
// exit ;
75338: POP
75339: POP
75340: GO 75462
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
75342: LD_EXP 84
75346: PUSH
75347: LD_VAR 0 2
75351: ARRAY
75352: PUSH
75353: LD_EXP 104
75357: PUSH
75358: LD_VAR 0 2
75362: ARRAY
75363: NOT
75364: AND
75365: PUSH
75366: LD_EXP 83
75370: PUSH
75371: LD_VAR 0 2
75375: ARRAY
75376: AND
75377: IFFALSE 75458
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
75379: LD_ADDR_EXP 104
75383: PUSH
75384: LD_EXP 104
75388: PPUSH
75389: LD_VAR 0 2
75393: PPUSH
75394: LD_INT 1
75396: PPUSH
75397: CALL_OW 1
75401: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
75402: LD_ADDR_VAR 0 4
75406: PUSH
75407: LD_EXP 83
75411: PUSH
75412: LD_VAR 0 2
75416: ARRAY
75417: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
75418: LD_ADDR_EXP 83
75422: PUSH
75423: LD_EXP 83
75427: PPUSH
75428: LD_VAR 0 2
75432: PPUSH
75433: EMPTY
75434: PPUSH
75435: CALL_OW 1
75439: ST_TO_ADDR
// Defend ( i , tmp ) ;
75440: LD_VAR 0 2
75444: PPUSH
75445: LD_VAR 0 4
75449: PPUSH
75450: CALL 115376 0 2
// exit ;
75454: POP
75455: POP
75456: GO 75462
// end ; end ;
75458: GO 74620
75460: POP
75461: POP
// end ;
75462: LD_VAR 0 1
75466: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
75467: LD_INT 0
75469: PPUSH
75470: PPUSH
75471: PPUSH
75472: PPUSH
75473: PPUSH
75474: PPUSH
75475: PPUSH
75476: PPUSH
75477: PPUSH
75478: PPUSH
75479: PPUSH
// if not mc_bases then
75480: LD_EXP 61
75484: NOT
75485: IFFALSE 75489
// exit ;
75487: GO 76576
// for i = 1 to mc_bases do
75489: LD_ADDR_VAR 0 2
75493: PUSH
75494: DOUBLE
75495: LD_INT 1
75497: DEC
75498: ST_TO_ADDR
75499: LD_EXP 61
75503: PUSH
75504: FOR_TO
75505: IFFALSE 76574
// begin tmp := mc_lab [ i ] ;
75507: LD_ADDR_VAR 0 6
75511: PUSH
75512: LD_EXP 94
75516: PUSH
75517: LD_VAR 0 2
75521: ARRAY
75522: ST_TO_ADDR
// if not tmp then
75523: LD_VAR 0 6
75527: NOT
75528: IFFALSE 75532
// continue ;
75530: GO 75504
// idle_lab := 0 ;
75532: LD_ADDR_VAR 0 11
75536: PUSH
75537: LD_INT 0
75539: ST_TO_ADDR
// for j in tmp do
75540: LD_ADDR_VAR 0 3
75544: PUSH
75545: LD_VAR 0 6
75549: PUSH
75550: FOR_IN
75551: IFFALSE 76570
// begin researching := false ;
75553: LD_ADDR_VAR 0 10
75557: PUSH
75558: LD_INT 0
75560: ST_TO_ADDR
// side := GetSide ( j ) ;
75561: LD_ADDR_VAR 0 4
75565: PUSH
75566: LD_VAR 0 3
75570: PPUSH
75571: CALL_OW 255
75575: ST_TO_ADDR
// if not mc_tech [ side ] then
75576: LD_EXP 88
75580: PUSH
75581: LD_VAR 0 4
75585: ARRAY
75586: NOT
75587: IFFALSE 75591
// continue ;
75589: GO 75550
// if BuildingStatus ( j ) = bs_idle then
75591: LD_VAR 0 3
75595: PPUSH
75596: CALL_OW 461
75600: PUSH
75601: LD_INT 2
75603: EQUAL
75604: IFFALSE 75792
// begin if idle_lab and UnitsInside ( j ) < 6 then
75606: LD_VAR 0 11
75610: PUSH
75611: LD_VAR 0 3
75615: PPUSH
75616: CALL_OW 313
75620: PUSH
75621: LD_INT 6
75623: LESS
75624: AND
75625: IFFALSE 75696
// begin tmp2 := UnitsInside ( idle_lab ) ;
75627: LD_ADDR_VAR 0 9
75631: PUSH
75632: LD_VAR 0 11
75636: PPUSH
75637: CALL_OW 313
75641: ST_TO_ADDR
// if tmp2 then
75642: LD_VAR 0 9
75646: IFFALSE 75688
// for x in tmp2 do
75648: LD_ADDR_VAR 0 7
75652: PUSH
75653: LD_VAR 0 9
75657: PUSH
75658: FOR_IN
75659: IFFALSE 75686
// begin ComExitBuilding ( x ) ;
75661: LD_VAR 0 7
75665: PPUSH
75666: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
75670: LD_VAR 0 7
75674: PPUSH
75675: LD_VAR 0 3
75679: PPUSH
75680: CALL_OW 180
// end ;
75684: GO 75658
75686: POP
75687: POP
// idle_lab := 0 ;
75688: LD_ADDR_VAR 0 11
75692: PUSH
75693: LD_INT 0
75695: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
75696: LD_ADDR_VAR 0 5
75700: PUSH
75701: LD_EXP 88
75705: PUSH
75706: LD_VAR 0 4
75710: ARRAY
75711: PUSH
75712: FOR_IN
75713: IFFALSE 75773
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
75715: LD_VAR 0 3
75719: PPUSH
75720: LD_VAR 0 5
75724: PPUSH
75725: CALL_OW 430
75729: PUSH
75730: LD_VAR 0 4
75734: PPUSH
75735: LD_VAR 0 5
75739: PPUSH
75740: CALL 17291 0 2
75744: AND
75745: IFFALSE 75771
// begin researching := true ;
75747: LD_ADDR_VAR 0 10
75751: PUSH
75752: LD_INT 1
75754: ST_TO_ADDR
// ComResearch ( j , t ) ;
75755: LD_VAR 0 3
75759: PPUSH
75760: LD_VAR 0 5
75764: PPUSH
75765: CALL_OW 124
// break ;
75769: GO 75773
// end ;
75771: GO 75712
75773: POP
75774: POP
// if not researching then
75775: LD_VAR 0 10
75779: NOT
75780: IFFALSE 75792
// idle_lab := j ;
75782: LD_ADDR_VAR 0 11
75786: PUSH
75787: LD_VAR 0 3
75791: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
75792: LD_VAR 0 3
75796: PPUSH
75797: CALL_OW 461
75801: PUSH
75802: LD_INT 10
75804: EQUAL
75805: IFFALSE 76393
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
75807: LD_EXP 90
75811: PUSH
75812: LD_VAR 0 2
75816: ARRAY
75817: NOT
75818: PUSH
75819: LD_EXP 91
75823: PUSH
75824: LD_VAR 0 2
75828: ARRAY
75829: NOT
75830: AND
75831: PUSH
75832: LD_EXP 88
75836: PUSH
75837: LD_VAR 0 4
75841: ARRAY
75842: PUSH
75843: LD_INT 1
75845: GREATER
75846: AND
75847: IFFALSE 75978
// begin ComCancel ( j ) ;
75849: LD_VAR 0 3
75853: PPUSH
75854: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
75858: LD_ADDR_EXP 88
75862: PUSH
75863: LD_EXP 88
75867: PPUSH
75868: LD_VAR 0 4
75872: PPUSH
75873: LD_EXP 88
75877: PUSH
75878: LD_VAR 0 4
75882: ARRAY
75883: PPUSH
75884: LD_EXP 88
75888: PUSH
75889: LD_VAR 0 4
75893: ARRAY
75894: PUSH
75895: LD_INT 1
75897: MINUS
75898: PPUSH
75899: LD_EXP 88
75903: PUSH
75904: LD_VAR 0 4
75908: ARRAY
75909: PPUSH
75910: LD_INT 0
75912: PPUSH
75913: CALL 20815 0 4
75917: PPUSH
75918: CALL_OW 1
75922: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
75923: LD_ADDR_EXP 88
75927: PUSH
75928: LD_EXP 88
75932: PPUSH
75933: LD_VAR 0 4
75937: PPUSH
75938: LD_EXP 88
75942: PUSH
75943: LD_VAR 0 4
75947: ARRAY
75948: PPUSH
75949: LD_EXP 88
75953: PUSH
75954: LD_VAR 0 4
75958: ARRAY
75959: PPUSH
75960: LD_INT 1
75962: PPUSH
75963: LD_INT 0
75965: PPUSH
75966: CALL 20815 0 4
75970: PPUSH
75971: CALL_OW 1
75975: ST_TO_ADDR
// continue ;
75976: GO 75550
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
75978: LD_EXP 90
75982: PUSH
75983: LD_VAR 0 2
75987: ARRAY
75988: PUSH
75989: LD_EXP 91
75993: PUSH
75994: LD_VAR 0 2
75998: ARRAY
75999: NOT
76000: AND
76001: IFFALSE 76128
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
76003: LD_ADDR_EXP 91
76007: PUSH
76008: LD_EXP 91
76012: PPUSH
76013: LD_VAR 0 2
76017: PUSH
76018: LD_EXP 91
76022: PUSH
76023: LD_VAR 0 2
76027: ARRAY
76028: PUSH
76029: LD_INT 1
76031: PLUS
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: PPUSH
76037: LD_EXP 90
76041: PUSH
76042: LD_VAR 0 2
76046: ARRAY
76047: PUSH
76048: LD_INT 1
76050: ARRAY
76051: PPUSH
76052: CALL 21397 0 3
76056: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
76057: LD_EXP 90
76061: PUSH
76062: LD_VAR 0 2
76066: ARRAY
76067: PUSH
76068: LD_INT 1
76070: ARRAY
76071: PPUSH
76072: LD_INT 112
76074: PPUSH
76075: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
76079: LD_ADDR_VAR 0 9
76083: PUSH
76084: LD_EXP 90
76088: PUSH
76089: LD_VAR 0 2
76093: ARRAY
76094: PPUSH
76095: LD_INT 1
76097: PPUSH
76098: CALL_OW 3
76102: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
76103: LD_ADDR_EXP 90
76107: PUSH
76108: LD_EXP 90
76112: PPUSH
76113: LD_VAR 0 2
76117: PPUSH
76118: LD_VAR 0 9
76122: PPUSH
76123: CALL_OW 1
76127: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
76128: LD_EXP 90
76132: PUSH
76133: LD_VAR 0 2
76137: ARRAY
76138: PUSH
76139: LD_EXP 91
76143: PUSH
76144: LD_VAR 0 2
76148: ARRAY
76149: AND
76150: PUSH
76151: LD_EXP 91
76155: PUSH
76156: LD_VAR 0 2
76160: ARRAY
76161: PUSH
76162: LD_INT 1
76164: ARRAY
76165: PPUSH
76166: CALL_OW 310
76170: NOT
76171: AND
76172: PUSH
76173: LD_VAR 0 3
76177: PPUSH
76178: CALL_OW 313
76182: PUSH
76183: LD_INT 6
76185: EQUAL
76186: AND
76187: IFFALSE 76243
// begin tmp2 := UnitsInside ( j ) ;
76189: LD_ADDR_VAR 0 9
76193: PUSH
76194: LD_VAR 0 3
76198: PPUSH
76199: CALL_OW 313
76203: ST_TO_ADDR
// if tmp2 = 6 then
76204: LD_VAR 0 9
76208: PUSH
76209: LD_INT 6
76211: EQUAL
76212: IFFALSE 76243
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
76214: LD_VAR 0 9
76218: PUSH
76219: LD_INT 1
76221: ARRAY
76222: PPUSH
76223: LD_INT 112
76225: PPUSH
76226: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
76230: LD_VAR 0 9
76234: PUSH
76235: LD_INT 1
76237: ARRAY
76238: PPUSH
76239: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
76243: LD_EXP 91
76247: PUSH
76248: LD_VAR 0 2
76252: ARRAY
76253: PUSH
76254: LD_EXP 91
76258: PUSH
76259: LD_VAR 0 2
76263: ARRAY
76264: PUSH
76265: LD_INT 1
76267: ARRAY
76268: PPUSH
76269: CALL_OW 314
76273: NOT
76274: AND
76275: PUSH
76276: LD_EXP 91
76280: PUSH
76281: LD_VAR 0 2
76285: ARRAY
76286: PUSH
76287: LD_INT 1
76289: ARRAY
76290: PPUSH
76291: CALL_OW 310
76295: NOT
76296: AND
76297: IFFALSE 76323
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
76299: LD_EXP 91
76303: PUSH
76304: LD_VAR 0 2
76308: ARRAY
76309: PUSH
76310: LD_INT 1
76312: ARRAY
76313: PPUSH
76314: LD_VAR 0 3
76318: PPUSH
76319: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
76323: LD_EXP 91
76327: PUSH
76328: LD_VAR 0 2
76332: ARRAY
76333: PUSH
76334: LD_INT 1
76336: ARRAY
76337: PPUSH
76338: CALL_OW 310
76342: PUSH
76343: LD_EXP 91
76347: PUSH
76348: LD_VAR 0 2
76352: ARRAY
76353: PUSH
76354: LD_INT 1
76356: ARRAY
76357: PPUSH
76358: CALL_OW 310
76362: PPUSH
76363: CALL_OW 461
76367: PUSH
76368: LD_INT 3
76370: NONEQUAL
76371: AND
76372: IFFALSE 76393
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
76374: LD_EXP 91
76378: PUSH
76379: LD_VAR 0 2
76383: ARRAY
76384: PUSH
76385: LD_INT 1
76387: ARRAY
76388: PPUSH
76389: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
76393: LD_VAR 0 3
76397: PPUSH
76398: CALL_OW 461
76402: PUSH
76403: LD_INT 6
76405: EQUAL
76406: PUSH
76407: LD_VAR 0 6
76411: PUSH
76412: LD_INT 1
76414: GREATER
76415: AND
76416: IFFALSE 76568
// begin sci := [ ] ;
76418: LD_ADDR_VAR 0 8
76422: PUSH
76423: EMPTY
76424: ST_TO_ADDR
// for x in ( tmp diff j ) do
76425: LD_ADDR_VAR 0 7
76429: PUSH
76430: LD_VAR 0 6
76434: PUSH
76435: LD_VAR 0 3
76439: DIFF
76440: PUSH
76441: FOR_IN
76442: IFFALSE 76494
// begin if sci = 6 then
76444: LD_VAR 0 8
76448: PUSH
76449: LD_INT 6
76451: EQUAL
76452: IFFALSE 76456
// break ;
76454: GO 76494
// if BuildingStatus ( x ) = bs_idle then
76456: LD_VAR 0 7
76460: PPUSH
76461: CALL_OW 461
76465: PUSH
76466: LD_INT 2
76468: EQUAL
76469: IFFALSE 76492
// sci := sci ^ UnitsInside ( x ) ;
76471: LD_ADDR_VAR 0 8
76475: PUSH
76476: LD_VAR 0 8
76480: PUSH
76481: LD_VAR 0 7
76485: PPUSH
76486: CALL_OW 313
76490: ADD
76491: ST_TO_ADDR
// end ;
76492: GO 76441
76494: POP
76495: POP
// if not sci then
76496: LD_VAR 0 8
76500: NOT
76501: IFFALSE 76505
// continue ;
76503: GO 75550
// for x in sci do
76505: LD_ADDR_VAR 0 7
76509: PUSH
76510: LD_VAR 0 8
76514: PUSH
76515: FOR_IN
76516: IFFALSE 76566
// if IsInUnit ( x ) and not HasTask ( x ) then
76518: LD_VAR 0 7
76522: PPUSH
76523: CALL_OW 310
76527: PUSH
76528: LD_VAR 0 7
76532: PPUSH
76533: CALL_OW 314
76537: NOT
76538: AND
76539: IFFALSE 76564
// begin ComExitBuilding ( x ) ;
76541: LD_VAR 0 7
76545: PPUSH
76546: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
76550: LD_VAR 0 7
76554: PPUSH
76555: LD_VAR 0 3
76559: PPUSH
76560: CALL_OW 180
// end ;
76564: GO 76515
76566: POP
76567: POP
// end ; end ;
76568: GO 75550
76570: POP
76571: POP
// end ;
76572: GO 75504
76574: POP
76575: POP
// end ;
76576: LD_VAR 0 1
76580: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
76581: LD_INT 0
76583: PPUSH
76584: PPUSH
// if not mc_bases then
76585: LD_EXP 61
76589: NOT
76590: IFFALSE 76594
// exit ;
76592: GO 76675
// for i = 1 to mc_bases do
76594: LD_ADDR_VAR 0 2
76598: PUSH
76599: DOUBLE
76600: LD_INT 1
76602: DEC
76603: ST_TO_ADDR
76604: LD_EXP 61
76608: PUSH
76609: FOR_TO
76610: IFFALSE 76673
// if mc_mines [ i ] and mc_miners [ i ] then
76612: LD_EXP 74
76616: PUSH
76617: LD_VAR 0 2
76621: ARRAY
76622: PUSH
76623: LD_EXP 75
76627: PUSH
76628: LD_VAR 0 2
76632: ARRAY
76633: AND
76634: IFFALSE 76671
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
76636: LD_EXP 75
76640: PUSH
76641: LD_VAR 0 2
76645: ARRAY
76646: PUSH
76647: LD_INT 1
76649: ARRAY
76650: PPUSH
76651: CALL_OW 255
76655: PPUSH
76656: LD_EXP 74
76660: PUSH
76661: LD_VAR 0 2
76665: ARRAY
76666: PPUSH
76667: CALL 18374 0 2
76671: GO 76609
76673: POP
76674: POP
// end ;
76675: LD_VAR 0 1
76679: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
76680: LD_INT 0
76682: PPUSH
76683: PPUSH
76684: PPUSH
76685: PPUSH
76686: PPUSH
76687: PPUSH
76688: PPUSH
76689: PPUSH
// if not mc_bases or not mc_parking then
76690: LD_EXP 61
76694: NOT
76695: PUSH
76696: LD_EXP 85
76700: NOT
76701: OR
76702: IFFALSE 76706
// exit ;
76704: GO 77444
// for i = 1 to mc_bases do
76706: LD_ADDR_VAR 0 2
76710: PUSH
76711: DOUBLE
76712: LD_INT 1
76714: DEC
76715: ST_TO_ADDR
76716: LD_EXP 61
76720: PUSH
76721: FOR_TO
76722: IFFALSE 77442
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
76724: LD_EXP 61
76728: PUSH
76729: LD_VAR 0 2
76733: ARRAY
76734: NOT
76735: PUSH
76736: LD_EXP 85
76740: PUSH
76741: LD_VAR 0 2
76745: ARRAY
76746: NOT
76747: OR
76748: IFFALSE 76752
// continue ;
76750: GO 76721
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
76752: LD_ADDR_VAR 0 5
76756: PUSH
76757: LD_EXP 61
76761: PUSH
76762: LD_VAR 0 2
76766: ARRAY
76767: PUSH
76768: LD_INT 1
76770: ARRAY
76771: PPUSH
76772: CALL_OW 255
76776: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
76777: LD_ADDR_VAR 0 6
76781: PUSH
76782: LD_EXP 61
76786: PUSH
76787: LD_VAR 0 2
76791: ARRAY
76792: PPUSH
76793: LD_INT 30
76795: PUSH
76796: LD_INT 3
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PPUSH
76803: CALL_OW 72
76807: ST_TO_ADDR
// if not fac then
76808: LD_VAR 0 6
76812: NOT
76813: IFFALSE 76864
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76815: LD_ADDR_VAR 0 6
76819: PUSH
76820: LD_EXP 61
76824: PUSH
76825: LD_VAR 0 2
76829: ARRAY
76830: PPUSH
76831: LD_INT 2
76833: PUSH
76834: LD_INT 30
76836: PUSH
76837: LD_INT 0
76839: PUSH
76840: EMPTY
76841: LIST
76842: LIST
76843: PUSH
76844: LD_INT 30
76846: PUSH
76847: LD_INT 1
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: LIST
76858: PPUSH
76859: CALL_OW 72
76863: ST_TO_ADDR
// if not fac then
76864: LD_VAR 0 6
76868: NOT
76869: IFFALSE 76873
// continue ;
76871: GO 76721
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
76873: LD_ADDR_VAR 0 7
76877: PUSH
76878: LD_EXP 85
76882: PUSH
76883: LD_VAR 0 2
76887: ARRAY
76888: PPUSH
76889: LD_INT 22
76891: PUSH
76892: LD_VAR 0 5
76896: PUSH
76897: EMPTY
76898: LIST
76899: LIST
76900: PUSH
76901: LD_INT 21
76903: PUSH
76904: LD_INT 2
76906: PUSH
76907: EMPTY
76908: LIST
76909: LIST
76910: PUSH
76911: LD_INT 3
76913: PUSH
76914: LD_INT 60
76916: PUSH
76917: EMPTY
76918: LIST
76919: PUSH
76920: EMPTY
76921: LIST
76922: LIST
76923: PUSH
76924: LD_INT 3
76926: PUSH
76927: LD_INT 24
76929: PUSH
76930: LD_INT 1000
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: EMPTY
76938: LIST
76939: LIST
76940: PUSH
76941: EMPTY
76942: LIST
76943: LIST
76944: LIST
76945: LIST
76946: PPUSH
76947: CALL_OW 70
76951: ST_TO_ADDR
// for j in fac do
76952: LD_ADDR_VAR 0 3
76956: PUSH
76957: LD_VAR 0 6
76961: PUSH
76962: FOR_IN
76963: IFFALSE 77058
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
76965: LD_ADDR_VAR 0 7
76969: PUSH
76970: LD_VAR 0 7
76974: PUSH
76975: LD_INT 22
76977: PUSH
76978: LD_VAR 0 5
76982: PUSH
76983: EMPTY
76984: LIST
76985: LIST
76986: PUSH
76987: LD_INT 91
76989: PUSH
76990: LD_VAR 0 3
76994: PUSH
76995: LD_INT 15
76997: PUSH
76998: EMPTY
76999: LIST
77000: LIST
77001: LIST
77002: PUSH
77003: LD_INT 21
77005: PUSH
77006: LD_INT 2
77008: PUSH
77009: EMPTY
77010: LIST
77011: LIST
77012: PUSH
77013: LD_INT 3
77015: PUSH
77016: LD_INT 60
77018: PUSH
77019: EMPTY
77020: LIST
77021: PUSH
77022: EMPTY
77023: LIST
77024: LIST
77025: PUSH
77026: LD_INT 3
77028: PUSH
77029: LD_INT 24
77031: PUSH
77032: LD_INT 1000
77034: PUSH
77035: EMPTY
77036: LIST
77037: LIST
77038: PUSH
77039: EMPTY
77040: LIST
77041: LIST
77042: PUSH
77043: EMPTY
77044: LIST
77045: LIST
77046: LIST
77047: LIST
77048: LIST
77049: PPUSH
77050: CALL_OW 69
77054: UNION
77055: ST_TO_ADDR
77056: GO 76962
77058: POP
77059: POP
// if not vehs then
77060: LD_VAR 0 7
77064: NOT
77065: IFFALSE 77091
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
77067: LD_ADDR_EXP 73
77071: PUSH
77072: LD_EXP 73
77076: PPUSH
77077: LD_VAR 0 2
77081: PPUSH
77082: EMPTY
77083: PPUSH
77084: CALL_OW 1
77088: ST_TO_ADDR
// continue ;
77089: GO 76721
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
77091: LD_ADDR_VAR 0 8
77095: PUSH
77096: LD_EXP 61
77100: PUSH
77101: LD_VAR 0 2
77105: ARRAY
77106: PPUSH
77107: LD_INT 30
77109: PUSH
77110: LD_INT 3
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PPUSH
77117: CALL_OW 72
77121: ST_TO_ADDR
// if tmp then
77122: LD_VAR 0 8
77126: IFFALSE 77229
// begin for j in tmp do
77128: LD_ADDR_VAR 0 3
77132: PUSH
77133: LD_VAR 0 8
77137: PUSH
77138: FOR_IN
77139: IFFALSE 77227
// for k in UnitsInside ( j ) do
77141: LD_ADDR_VAR 0 4
77145: PUSH
77146: LD_VAR 0 3
77150: PPUSH
77151: CALL_OW 313
77155: PUSH
77156: FOR_IN
77157: IFFALSE 77223
// if k then
77159: LD_VAR 0 4
77163: IFFALSE 77221
// if not k in mc_repair_vehicle [ i ] then
77165: LD_VAR 0 4
77169: PUSH
77170: LD_EXP 73
77174: PUSH
77175: LD_VAR 0 2
77179: ARRAY
77180: IN
77181: NOT
77182: IFFALSE 77221
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
77184: LD_ADDR_EXP 73
77188: PUSH
77189: LD_EXP 73
77193: PPUSH
77194: LD_VAR 0 2
77198: PPUSH
77199: LD_EXP 73
77203: PUSH
77204: LD_VAR 0 2
77208: ARRAY
77209: PUSH
77210: LD_VAR 0 4
77214: UNION
77215: PPUSH
77216: CALL_OW 1
77220: ST_TO_ADDR
77221: GO 77156
77223: POP
77224: POP
77225: GO 77138
77227: POP
77228: POP
// end ; if not mc_repair_vehicle [ i ] then
77229: LD_EXP 73
77233: PUSH
77234: LD_VAR 0 2
77238: ARRAY
77239: NOT
77240: IFFALSE 77244
// continue ;
77242: GO 76721
// for j in mc_repair_vehicle [ i ] do
77244: LD_ADDR_VAR 0 3
77248: PUSH
77249: LD_EXP 73
77253: PUSH
77254: LD_VAR 0 2
77258: ARRAY
77259: PUSH
77260: FOR_IN
77261: IFFALSE 77438
// begin if GetClass ( j ) <> 3 then
77263: LD_VAR 0 3
77267: PPUSH
77268: CALL_OW 257
77272: PUSH
77273: LD_INT 3
77275: NONEQUAL
77276: IFFALSE 77317
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
77278: LD_ADDR_EXP 73
77282: PUSH
77283: LD_EXP 73
77287: PPUSH
77288: LD_VAR 0 2
77292: PPUSH
77293: LD_EXP 73
77297: PUSH
77298: LD_VAR 0 2
77302: ARRAY
77303: PUSH
77304: LD_VAR 0 3
77308: DIFF
77309: PPUSH
77310: CALL_OW 1
77314: ST_TO_ADDR
// continue ;
77315: GO 77260
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77317: LD_VAR 0 3
77321: PPUSH
77322: CALL_OW 311
77326: NOT
77327: PUSH
77328: LD_VAR 0 3
77332: PUSH
77333: LD_EXP 64
77337: PUSH
77338: LD_VAR 0 2
77342: ARRAY
77343: PUSH
77344: LD_INT 1
77346: ARRAY
77347: IN
77348: NOT
77349: AND
77350: PUSH
77351: LD_VAR 0 3
77355: PUSH
77356: LD_EXP 64
77360: PUSH
77361: LD_VAR 0 2
77365: ARRAY
77366: PUSH
77367: LD_INT 2
77369: ARRAY
77370: IN
77371: NOT
77372: AND
77373: IFFALSE 77436
// begin if IsInUnit ( j ) then
77375: LD_VAR 0 3
77379: PPUSH
77380: CALL_OW 310
77384: IFFALSE 77397
// ComExitBuilding ( j ) else
77386: LD_VAR 0 3
77390: PPUSH
77391: CALL_OW 122
77395: GO 77436
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
77397: LD_VAR 0 3
77401: PPUSH
77402: LD_VAR 0 7
77406: PUSH
77407: LD_INT 1
77409: ARRAY
77410: PPUSH
77411: CALL 56202 0 2
77415: NOT
77416: IFFALSE 77436
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
77418: LD_VAR 0 3
77422: PPUSH
77423: LD_VAR 0 7
77427: PUSH
77428: LD_INT 1
77430: ARRAY
77431: PPUSH
77432: CALL_OW 129
// end ; end ;
77436: GO 77260
77438: POP
77439: POP
// end ;
77440: GO 76721
77442: POP
77443: POP
// end ;
77444: LD_VAR 0 1
77448: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
77449: LD_INT 0
77451: PPUSH
77452: PPUSH
77453: PPUSH
77454: PPUSH
77455: PPUSH
77456: PPUSH
77457: PPUSH
77458: PPUSH
77459: PPUSH
77460: PPUSH
77461: PPUSH
// if not mc_bases then
77462: LD_EXP 61
77466: NOT
77467: IFFALSE 77471
// exit ;
77469: GO 78273
// for i = 1 to mc_bases do
77471: LD_ADDR_VAR 0 2
77475: PUSH
77476: DOUBLE
77477: LD_INT 1
77479: DEC
77480: ST_TO_ADDR
77481: LD_EXP 61
77485: PUSH
77486: FOR_TO
77487: IFFALSE 78271
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
77489: LD_EXP 89
77493: PUSH
77494: LD_VAR 0 2
77498: ARRAY
77499: NOT
77500: PUSH
77501: LD_EXP 64
77505: PUSH
77506: LD_VAR 0 2
77510: ARRAY
77511: PUSH
77512: LD_INT 1
77514: ARRAY
77515: OR
77516: PUSH
77517: LD_EXP 64
77521: PUSH
77522: LD_VAR 0 2
77526: ARRAY
77527: PUSH
77528: LD_INT 2
77530: ARRAY
77531: OR
77532: PUSH
77533: LD_EXP 87
77537: PUSH
77538: LD_VAR 0 2
77542: ARRAY
77543: PPUSH
77544: LD_INT 1
77546: PPUSH
77547: CALL_OW 325
77551: NOT
77552: OR
77553: PUSH
77554: LD_EXP 84
77558: PUSH
77559: LD_VAR 0 2
77563: ARRAY
77564: OR
77565: IFFALSE 77569
// continue ;
77567: GO 77486
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
77569: LD_ADDR_VAR 0 8
77573: PUSH
77574: LD_EXP 61
77578: PUSH
77579: LD_VAR 0 2
77583: ARRAY
77584: PPUSH
77585: LD_INT 25
77587: PUSH
77588: LD_INT 4
77590: PUSH
77591: EMPTY
77592: LIST
77593: LIST
77594: PUSH
77595: LD_INT 50
77597: PUSH
77598: EMPTY
77599: LIST
77600: PUSH
77601: LD_INT 3
77603: PUSH
77604: LD_INT 60
77606: PUSH
77607: EMPTY
77608: LIST
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: LIST
77618: PPUSH
77619: CALL_OW 72
77623: PUSH
77624: LD_EXP 65
77628: PUSH
77629: LD_VAR 0 2
77633: ARRAY
77634: DIFF
77635: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77636: LD_ADDR_VAR 0 9
77640: PUSH
77641: LD_EXP 61
77645: PUSH
77646: LD_VAR 0 2
77650: ARRAY
77651: PPUSH
77652: LD_INT 2
77654: PUSH
77655: LD_INT 30
77657: PUSH
77658: LD_INT 0
77660: PUSH
77661: EMPTY
77662: LIST
77663: LIST
77664: PUSH
77665: LD_INT 30
77667: PUSH
77668: LD_INT 1
77670: PUSH
77671: EMPTY
77672: LIST
77673: LIST
77674: PUSH
77675: EMPTY
77676: LIST
77677: LIST
77678: LIST
77679: PPUSH
77680: CALL_OW 72
77684: ST_TO_ADDR
// if not tmp or not dep then
77685: LD_VAR 0 8
77689: NOT
77690: PUSH
77691: LD_VAR 0 9
77695: NOT
77696: OR
77697: IFFALSE 77701
// continue ;
77699: GO 77486
// side := GetSide ( tmp [ 1 ] ) ;
77701: LD_ADDR_VAR 0 11
77705: PUSH
77706: LD_VAR 0 8
77710: PUSH
77711: LD_INT 1
77713: ARRAY
77714: PPUSH
77715: CALL_OW 255
77719: ST_TO_ADDR
// dep := dep [ 1 ] ;
77720: LD_ADDR_VAR 0 9
77724: PUSH
77725: LD_VAR 0 9
77729: PUSH
77730: LD_INT 1
77732: ARRAY
77733: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
77734: LD_ADDR_VAR 0 7
77738: PUSH
77739: LD_EXP 89
77743: PUSH
77744: LD_VAR 0 2
77748: ARRAY
77749: PPUSH
77750: LD_INT 22
77752: PUSH
77753: LD_INT 0
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PUSH
77760: LD_INT 25
77762: PUSH
77763: LD_INT 12
77765: PUSH
77766: EMPTY
77767: LIST
77768: LIST
77769: PUSH
77770: EMPTY
77771: LIST
77772: LIST
77773: PPUSH
77774: CALL_OW 70
77778: PUSH
77779: LD_INT 22
77781: PUSH
77782: LD_INT 0
77784: PUSH
77785: EMPTY
77786: LIST
77787: LIST
77788: PUSH
77789: LD_INT 25
77791: PUSH
77792: LD_INT 12
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 91
77801: PUSH
77802: LD_VAR 0 9
77806: PUSH
77807: LD_INT 20
77809: PUSH
77810: EMPTY
77811: LIST
77812: LIST
77813: LIST
77814: PUSH
77815: EMPTY
77816: LIST
77817: LIST
77818: LIST
77819: PPUSH
77820: CALL_OW 69
77824: UNION
77825: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
77826: LD_ADDR_VAR 0 10
77830: PUSH
77831: LD_EXP 89
77835: PUSH
77836: LD_VAR 0 2
77840: ARRAY
77841: PPUSH
77842: LD_INT 81
77844: PUSH
77845: LD_VAR 0 11
77849: PUSH
77850: EMPTY
77851: LIST
77852: LIST
77853: PPUSH
77854: CALL_OW 70
77858: ST_TO_ADDR
// if not apes or danger_at_area then
77859: LD_VAR 0 7
77863: NOT
77864: PUSH
77865: LD_VAR 0 10
77869: OR
77870: IFFALSE 77920
// begin if mc_taming [ i ] then
77872: LD_EXP 92
77876: PUSH
77877: LD_VAR 0 2
77881: ARRAY
77882: IFFALSE 77918
// begin MC_Reset ( i , 121 ) ;
77884: LD_VAR 0 2
77888: PPUSH
77889: LD_INT 121
77891: PPUSH
77892: CALL 62836 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
77896: LD_ADDR_EXP 92
77900: PUSH
77901: LD_EXP 92
77905: PPUSH
77906: LD_VAR 0 2
77910: PPUSH
77911: EMPTY
77912: PPUSH
77913: CALL_OW 1
77917: ST_TO_ADDR
// end ; continue ;
77918: GO 77486
// end ; for j in tmp do
77920: LD_ADDR_VAR 0 3
77924: PUSH
77925: LD_VAR 0 8
77929: PUSH
77930: FOR_IN
77931: IFFALSE 78267
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
77933: LD_VAR 0 3
77937: PUSH
77938: LD_EXP 92
77942: PUSH
77943: LD_VAR 0 2
77947: ARRAY
77948: IN
77949: NOT
77950: PUSH
77951: LD_EXP 92
77955: PUSH
77956: LD_VAR 0 2
77960: ARRAY
77961: PUSH
77962: LD_INT 3
77964: LESS
77965: AND
77966: IFFALSE 78024
// begin SetTag ( j , 121 ) ;
77968: LD_VAR 0 3
77972: PPUSH
77973: LD_INT 121
77975: PPUSH
77976: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
77980: LD_ADDR_EXP 92
77984: PUSH
77985: LD_EXP 92
77989: PPUSH
77990: LD_VAR 0 2
77994: PUSH
77995: LD_EXP 92
77999: PUSH
78000: LD_VAR 0 2
78004: ARRAY
78005: PUSH
78006: LD_INT 1
78008: PLUS
78009: PUSH
78010: EMPTY
78011: LIST
78012: LIST
78013: PPUSH
78014: LD_VAR 0 3
78018: PPUSH
78019: CALL 21397 0 3
78023: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
78024: LD_VAR 0 3
78028: PUSH
78029: LD_EXP 92
78033: PUSH
78034: LD_VAR 0 2
78038: ARRAY
78039: IN
78040: IFFALSE 78265
// begin if GetClass ( j ) <> 4 then
78042: LD_VAR 0 3
78046: PPUSH
78047: CALL_OW 257
78051: PUSH
78052: LD_INT 4
78054: NONEQUAL
78055: IFFALSE 78108
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
78057: LD_ADDR_EXP 92
78061: PUSH
78062: LD_EXP 92
78066: PPUSH
78067: LD_VAR 0 2
78071: PPUSH
78072: LD_EXP 92
78076: PUSH
78077: LD_VAR 0 2
78081: ARRAY
78082: PUSH
78083: LD_VAR 0 3
78087: DIFF
78088: PPUSH
78089: CALL_OW 1
78093: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78094: LD_VAR 0 3
78098: PPUSH
78099: LD_INT 0
78101: PPUSH
78102: CALL_OW 109
// continue ;
78106: GO 77930
// end ; if IsInUnit ( j ) then
78108: LD_VAR 0 3
78112: PPUSH
78113: CALL_OW 310
78117: IFFALSE 78128
// ComExitBuilding ( j ) ;
78119: LD_VAR 0 3
78123: PPUSH
78124: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
78128: LD_ADDR_VAR 0 6
78132: PUSH
78133: LD_VAR 0 7
78137: PPUSH
78138: LD_VAR 0 3
78142: PPUSH
78143: CALL_OW 74
78147: ST_TO_ADDR
// if not ape then
78148: LD_VAR 0 6
78152: NOT
78153: IFFALSE 78157
// break ;
78155: GO 78267
// x := GetX ( ape ) ;
78157: LD_ADDR_VAR 0 4
78161: PUSH
78162: LD_VAR 0 6
78166: PPUSH
78167: CALL_OW 250
78171: ST_TO_ADDR
// y := GetY ( ape ) ;
78172: LD_ADDR_VAR 0 5
78176: PUSH
78177: LD_VAR 0 6
78181: PPUSH
78182: CALL_OW 251
78186: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78187: LD_VAR 0 4
78191: PPUSH
78192: LD_VAR 0 5
78196: PPUSH
78197: CALL_OW 488
78201: NOT
78202: PUSH
78203: LD_VAR 0 11
78207: PPUSH
78208: LD_VAR 0 4
78212: PPUSH
78213: LD_VAR 0 5
78217: PPUSH
78218: LD_INT 20
78220: PPUSH
78221: CALL 22661 0 4
78225: PUSH
78226: LD_INT 4
78228: ARRAY
78229: OR
78230: IFFALSE 78234
// break ;
78232: GO 78267
// if not HasTask ( j ) then
78234: LD_VAR 0 3
78238: PPUSH
78239: CALL_OW 314
78243: NOT
78244: IFFALSE 78265
// ComTameXY ( j , x , y ) ;
78246: LD_VAR 0 3
78250: PPUSH
78251: LD_VAR 0 4
78255: PPUSH
78256: LD_VAR 0 5
78260: PPUSH
78261: CALL_OW 131
// end ; end ;
78265: GO 77930
78267: POP
78268: POP
// end ;
78269: GO 77486
78271: POP
78272: POP
// end ;
78273: LD_VAR 0 1
78277: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
78278: LD_INT 0
78280: PPUSH
78281: PPUSH
78282: PPUSH
78283: PPUSH
78284: PPUSH
78285: PPUSH
78286: PPUSH
78287: PPUSH
// if not mc_bases then
78288: LD_EXP 61
78292: NOT
78293: IFFALSE 78297
// exit ;
78295: GO 78923
// for i = 1 to mc_bases do
78297: LD_ADDR_VAR 0 2
78301: PUSH
78302: DOUBLE
78303: LD_INT 1
78305: DEC
78306: ST_TO_ADDR
78307: LD_EXP 61
78311: PUSH
78312: FOR_TO
78313: IFFALSE 78921
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
78315: LD_EXP 90
78319: PUSH
78320: LD_VAR 0 2
78324: ARRAY
78325: NOT
78326: PUSH
78327: LD_EXP 90
78331: PUSH
78332: LD_VAR 0 2
78336: ARRAY
78337: PPUSH
78338: LD_INT 25
78340: PUSH
78341: LD_INT 12
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PPUSH
78348: CALL_OW 72
78352: NOT
78353: OR
78354: IFFALSE 78358
// continue ;
78356: GO 78312
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
78358: LD_ADDR_VAR 0 5
78362: PUSH
78363: LD_EXP 90
78367: PUSH
78368: LD_VAR 0 2
78372: ARRAY
78373: PUSH
78374: LD_INT 1
78376: ARRAY
78377: PPUSH
78378: CALL_OW 255
78382: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
78383: LD_VAR 0 5
78387: PPUSH
78388: LD_INT 2
78390: PPUSH
78391: CALL_OW 325
78395: IFFALSE 78648
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
78397: LD_ADDR_VAR 0 4
78401: PUSH
78402: LD_EXP 90
78406: PUSH
78407: LD_VAR 0 2
78411: ARRAY
78412: PPUSH
78413: LD_INT 25
78415: PUSH
78416: LD_INT 16
78418: PUSH
78419: EMPTY
78420: LIST
78421: LIST
78422: PPUSH
78423: CALL_OW 72
78427: ST_TO_ADDR
// if tmp < 6 then
78428: LD_VAR 0 4
78432: PUSH
78433: LD_INT 6
78435: LESS
78436: IFFALSE 78648
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78438: LD_ADDR_VAR 0 6
78442: PUSH
78443: LD_EXP 61
78447: PUSH
78448: LD_VAR 0 2
78452: ARRAY
78453: PPUSH
78454: LD_INT 2
78456: PUSH
78457: LD_INT 30
78459: PUSH
78460: LD_INT 0
78462: PUSH
78463: EMPTY
78464: LIST
78465: LIST
78466: PUSH
78467: LD_INT 30
78469: PUSH
78470: LD_INT 1
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: PUSH
78477: EMPTY
78478: LIST
78479: LIST
78480: LIST
78481: PPUSH
78482: CALL_OW 72
78486: ST_TO_ADDR
// if depot then
78487: LD_VAR 0 6
78491: IFFALSE 78648
// begin selected := 0 ;
78493: LD_ADDR_VAR 0 7
78497: PUSH
78498: LD_INT 0
78500: ST_TO_ADDR
// for j in depot do
78501: LD_ADDR_VAR 0 3
78505: PUSH
78506: LD_VAR 0 6
78510: PUSH
78511: FOR_IN
78512: IFFALSE 78543
// begin if UnitsInside ( j ) < 6 then
78514: LD_VAR 0 3
78518: PPUSH
78519: CALL_OW 313
78523: PUSH
78524: LD_INT 6
78526: LESS
78527: IFFALSE 78541
// begin selected := j ;
78529: LD_ADDR_VAR 0 7
78533: PUSH
78534: LD_VAR 0 3
78538: ST_TO_ADDR
// break ;
78539: GO 78543
// end ; end ;
78541: GO 78511
78543: POP
78544: POP
// if selected then
78545: LD_VAR 0 7
78549: IFFALSE 78648
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
78551: LD_ADDR_VAR 0 3
78555: PUSH
78556: LD_EXP 90
78560: PUSH
78561: LD_VAR 0 2
78565: ARRAY
78566: PPUSH
78567: LD_INT 25
78569: PUSH
78570: LD_INT 12
78572: PUSH
78573: EMPTY
78574: LIST
78575: LIST
78576: PPUSH
78577: CALL_OW 72
78581: PUSH
78582: FOR_IN
78583: IFFALSE 78646
// if not HasTask ( j ) then
78585: LD_VAR 0 3
78589: PPUSH
78590: CALL_OW 314
78594: NOT
78595: IFFALSE 78644
// begin if not IsInUnit ( j ) then
78597: LD_VAR 0 3
78601: PPUSH
78602: CALL_OW 310
78606: NOT
78607: IFFALSE 78623
// ComEnterUnit ( j , selected ) ;
78609: LD_VAR 0 3
78613: PPUSH
78614: LD_VAR 0 7
78618: PPUSH
78619: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
78623: LD_VAR 0 3
78627: PPUSH
78628: LD_INT 16
78630: PPUSH
78631: CALL_OW 183
// AddComExitBuilding ( j ) ;
78635: LD_VAR 0 3
78639: PPUSH
78640: CALL_OW 182
// end ;
78644: GO 78582
78646: POP
78647: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
78648: LD_VAR 0 5
78652: PPUSH
78653: LD_INT 11
78655: PPUSH
78656: CALL_OW 325
78660: IFFALSE 78919
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
78662: LD_ADDR_VAR 0 4
78666: PUSH
78667: LD_EXP 90
78671: PUSH
78672: LD_VAR 0 2
78676: ARRAY
78677: PPUSH
78678: LD_INT 25
78680: PUSH
78681: LD_INT 16
78683: PUSH
78684: EMPTY
78685: LIST
78686: LIST
78687: PPUSH
78688: CALL_OW 72
78692: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
78693: LD_VAR 0 4
78697: PUSH
78698: LD_INT 6
78700: GREATEREQUAL
78701: PUSH
78702: LD_VAR 0 5
78706: PPUSH
78707: LD_INT 2
78709: PPUSH
78710: CALL_OW 325
78714: NOT
78715: OR
78716: IFFALSE 78919
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
78718: LD_ADDR_VAR 0 8
78722: PUSH
78723: LD_EXP 61
78727: PUSH
78728: LD_VAR 0 2
78732: ARRAY
78733: PPUSH
78734: LD_INT 2
78736: PUSH
78737: LD_INT 30
78739: PUSH
78740: LD_INT 4
78742: PUSH
78743: EMPTY
78744: LIST
78745: LIST
78746: PUSH
78747: LD_INT 30
78749: PUSH
78750: LD_INT 5
78752: PUSH
78753: EMPTY
78754: LIST
78755: LIST
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: LIST
78761: PPUSH
78762: CALL_OW 72
78766: ST_TO_ADDR
// if barracks then
78767: LD_VAR 0 8
78771: IFFALSE 78919
// begin selected := 0 ;
78773: LD_ADDR_VAR 0 7
78777: PUSH
78778: LD_INT 0
78780: ST_TO_ADDR
// for j in barracks do
78781: LD_ADDR_VAR 0 3
78785: PUSH
78786: LD_VAR 0 8
78790: PUSH
78791: FOR_IN
78792: IFFALSE 78823
// begin if UnitsInside ( j ) < 6 then
78794: LD_VAR 0 3
78798: PPUSH
78799: CALL_OW 313
78803: PUSH
78804: LD_INT 6
78806: LESS
78807: IFFALSE 78821
// begin selected := j ;
78809: LD_ADDR_VAR 0 7
78813: PUSH
78814: LD_VAR 0 3
78818: ST_TO_ADDR
// break ;
78819: GO 78823
// end ; end ;
78821: GO 78791
78823: POP
78824: POP
// if selected then
78825: LD_VAR 0 7
78829: IFFALSE 78919
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
78831: LD_ADDR_VAR 0 3
78835: PUSH
78836: LD_EXP 90
78840: PUSH
78841: LD_VAR 0 2
78845: ARRAY
78846: PPUSH
78847: LD_INT 25
78849: PUSH
78850: LD_INT 12
78852: PUSH
78853: EMPTY
78854: LIST
78855: LIST
78856: PPUSH
78857: CALL_OW 72
78861: PUSH
78862: FOR_IN
78863: IFFALSE 78917
// if not IsInUnit ( j ) and not HasTask ( j ) then
78865: LD_VAR 0 3
78869: PPUSH
78870: CALL_OW 310
78874: NOT
78875: PUSH
78876: LD_VAR 0 3
78880: PPUSH
78881: CALL_OW 314
78885: NOT
78886: AND
78887: IFFALSE 78915
// begin ComEnterUnit ( j , selected ) ;
78889: LD_VAR 0 3
78893: PPUSH
78894: LD_VAR 0 7
78898: PPUSH
78899: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
78903: LD_VAR 0 3
78907: PPUSH
78908: LD_INT 15
78910: PPUSH
78911: CALL_OW 183
// end ;
78915: GO 78862
78917: POP
78918: POP
// end ; end ; end ; end ; end ;
78919: GO 78312
78921: POP
78922: POP
// end ;
78923: LD_VAR 0 1
78927: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
78928: LD_INT 0
78930: PPUSH
78931: PPUSH
78932: PPUSH
78933: PPUSH
// if not mc_bases then
78934: LD_EXP 61
78938: NOT
78939: IFFALSE 78943
// exit ;
78941: GO 79121
// for i = 1 to mc_bases do
78943: LD_ADDR_VAR 0 2
78947: PUSH
78948: DOUBLE
78949: LD_INT 1
78951: DEC
78952: ST_TO_ADDR
78953: LD_EXP 61
78957: PUSH
78958: FOR_TO
78959: IFFALSE 79119
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
78961: LD_ADDR_VAR 0 4
78965: PUSH
78966: LD_EXP 61
78970: PUSH
78971: LD_VAR 0 2
78975: ARRAY
78976: PPUSH
78977: LD_INT 25
78979: PUSH
78980: LD_INT 9
78982: PUSH
78983: EMPTY
78984: LIST
78985: LIST
78986: PPUSH
78987: CALL_OW 72
78991: ST_TO_ADDR
// if not tmp then
78992: LD_VAR 0 4
78996: NOT
78997: IFFALSE 79001
// continue ;
78999: GO 78958
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
79001: LD_EXP 87
79005: PUSH
79006: LD_VAR 0 2
79010: ARRAY
79011: PPUSH
79012: LD_INT 29
79014: PPUSH
79015: CALL_OW 325
79019: NOT
79020: PUSH
79021: LD_EXP 87
79025: PUSH
79026: LD_VAR 0 2
79030: ARRAY
79031: PPUSH
79032: LD_INT 28
79034: PPUSH
79035: CALL_OW 325
79039: NOT
79040: AND
79041: IFFALSE 79045
// continue ;
79043: GO 78958
// for j in tmp do
79045: LD_ADDR_VAR 0 3
79049: PUSH
79050: LD_VAR 0 4
79054: PUSH
79055: FOR_IN
79056: IFFALSE 79115
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
79058: LD_VAR 0 3
79062: PUSH
79063: LD_EXP 64
79067: PUSH
79068: LD_VAR 0 2
79072: ARRAY
79073: PUSH
79074: LD_INT 1
79076: ARRAY
79077: IN
79078: NOT
79079: PUSH
79080: LD_VAR 0 3
79084: PUSH
79085: LD_EXP 64
79089: PUSH
79090: LD_VAR 0 2
79094: ARRAY
79095: PUSH
79096: LD_INT 2
79098: ARRAY
79099: IN
79100: NOT
79101: AND
79102: IFFALSE 79113
// ComSpaceTimeShoot ( j ) ;
79104: LD_VAR 0 3
79108: PPUSH
79109: CALL 17382 0 1
79113: GO 79055
79115: POP
79116: POP
// end ;
79117: GO 78958
79119: POP
79120: POP
// end ;
79121: LD_VAR 0 1
79125: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
79126: LD_INT 0
79128: PPUSH
79129: PPUSH
79130: PPUSH
79131: PPUSH
79132: PPUSH
79133: PPUSH
79134: PPUSH
79135: PPUSH
79136: PPUSH
// if not mc_bases then
79137: LD_EXP 61
79141: NOT
79142: IFFALSE 79146
// exit ;
79144: GO 79768
// for i = 1 to mc_bases do
79146: LD_ADDR_VAR 0 2
79150: PUSH
79151: DOUBLE
79152: LD_INT 1
79154: DEC
79155: ST_TO_ADDR
79156: LD_EXP 61
79160: PUSH
79161: FOR_TO
79162: IFFALSE 79766
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
79164: LD_EXP 96
79168: PUSH
79169: LD_VAR 0 2
79173: ARRAY
79174: NOT
79175: PUSH
79176: LD_INT 38
79178: PPUSH
79179: LD_EXP 87
79183: PUSH
79184: LD_VAR 0 2
79188: ARRAY
79189: PPUSH
79190: CALL_OW 321
79194: PUSH
79195: LD_INT 2
79197: NONEQUAL
79198: OR
79199: IFFALSE 79203
// continue ;
79201: GO 79161
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
79203: LD_ADDR_VAR 0 8
79207: PUSH
79208: LD_EXP 61
79212: PUSH
79213: LD_VAR 0 2
79217: ARRAY
79218: PPUSH
79219: LD_INT 30
79221: PUSH
79222: LD_INT 34
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PPUSH
79229: CALL_OW 72
79233: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
79234: LD_ADDR_VAR 0 9
79238: PUSH
79239: LD_EXP 61
79243: PUSH
79244: LD_VAR 0 2
79248: ARRAY
79249: PPUSH
79250: LD_INT 25
79252: PUSH
79253: LD_INT 4
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: PPUSH
79260: CALL_OW 72
79264: PPUSH
79265: LD_INT 0
79267: PPUSH
79268: CALL 51706 0 2
79272: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
79273: LD_VAR 0 9
79277: NOT
79278: PUSH
79279: LD_VAR 0 8
79283: NOT
79284: OR
79285: PUSH
79286: LD_EXP 61
79290: PUSH
79291: LD_VAR 0 2
79295: ARRAY
79296: PPUSH
79297: LD_INT 124
79299: PPUSH
79300: CALL 51706 0 2
79304: OR
79305: IFFALSE 79309
// continue ;
79307: GO 79161
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
79309: LD_EXP 97
79313: PUSH
79314: LD_VAR 0 2
79318: ARRAY
79319: PUSH
79320: LD_EXP 96
79324: PUSH
79325: LD_VAR 0 2
79329: ARRAY
79330: LESS
79331: PUSH
79332: LD_EXP 97
79336: PUSH
79337: LD_VAR 0 2
79341: ARRAY
79342: PUSH
79343: LD_VAR 0 8
79347: LESS
79348: AND
79349: IFFALSE 79764
// begin tmp := sci [ 1 ] ;
79351: LD_ADDR_VAR 0 7
79355: PUSH
79356: LD_VAR 0 9
79360: PUSH
79361: LD_INT 1
79363: ARRAY
79364: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
79365: LD_VAR 0 7
79369: PPUSH
79370: LD_INT 124
79372: PPUSH
79373: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
79377: LD_ADDR_VAR 0 3
79381: PUSH
79382: DOUBLE
79383: LD_EXP 96
79387: PUSH
79388: LD_VAR 0 2
79392: ARRAY
79393: INC
79394: ST_TO_ADDR
79395: LD_EXP 96
79399: PUSH
79400: LD_VAR 0 2
79404: ARRAY
79405: PUSH
79406: FOR_DOWNTO
79407: IFFALSE 79750
// begin if IsInUnit ( tmp ) then
79409: LD_VAR 0 7
79413: PPUSH
79414: CALL_OW 310
79418: IFFALSE 79429
// ComExitBuilding ( tmp ) ;
79420: LD_VAR 0 7
79424: PPUSH
79425: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
79429: LD_INT 35
79431: PPUSH
79432: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
79436: LD_VAR 0 7
79440: PPUSH
79441: CALL_OW 310
79445: NOT
79446: PUSH
79447: LD_VAR 0 7
79451: PPUSH
79452: CALL_OW 314
79456: NOT
79457: AND
79458: IFFALSE 79429
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
79460: LD_ADDR_VAR 0 6
79464: PUSH
79465: LD_VAR 0 7
79469: PPUSH
79470: CALL_OW 250
79474: PUSH
79475: LD_VAR 0 7
79479: PPUSH
79480: CALL_OW 251
79484: PUSH
79485: EMPTY
79486: LIST
79487: LIST
79488: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
79489: LD_INT 35
79491: PPUSH
79492: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
79496: LD_ADDR_VAR 0 4
79500: PUSH
79501: LD_EXP 96
79505: PUSH
79506: LD_VAR 0 2
79510: ARRAY
79511: PUSH
79512: LD_VAR 0 3
79516: ARRAY
79517: PUSH
79518: LD_INT 1
79520: ARRAY
79521: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
79522: LD_ADDR_VAR 0 5
79526: PUSH
79527: LD_EXP 96
79531: PUSH
79532: LD_VAR 0 2
79536: ARRAY
79537: PUSH
79538: LD_VAR 0 3
79542: ARRAY
79543: PUSH
79544: LD_INT 2
79546: ARRAY
79547: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
79548: LD_VAR 0 7
79552: PPUSH
79553: LD_INT 10
79555: PPUSH
79556: CALL 24362 0 2
79560: PUSH
79561: LD_INT 4
79563: ARRAY
79564: IFFALSE 79602
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
79566: LD_VAR 0 7
79570: PPUSH
79571: LD_VAR 0 6
79575: PUSH
79576: LD_INT 1
79578: ARRAY
79579: PPUSH
79580: LD_VAR 0 6
79584: PUSH
79585: LD_INT 2
79587: ARRAY
79588: PPUSH
79589: CALL_OW 111
// wait ( 0 0$10 ) ;
79593: LD_INT 350
79595: PPUSH
79596: CALL_OW 67
// end else
79600: GO 79628
// begin ComMoveXY ( tmp , x , y ) ;
79602: LD_VAR 0 7
79606: PPUSH
79607: LD_VAR 0 4
79611: PPUSH
79612: LD_VAR 0 5
79616: PPUSH
79617: CALL_OW 111
// wait ( 0 0$3 ) ;
79621: LD_INT 105
79623: PPUSH
79624: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
79628: LD_VAR 0 7
79632: PPUSH
79633: LD_VAR 0 4
79637: PPUSH
79638: LD_VAR 0 5
79642: PPUSH
79643: CALL_OW 307
79647: IFFALSE 79489
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
79649: LD_VAR 0 7
79653: PPUSH
79654: LD_VAR 0 4
79658: PPUSH
79659: LD_VAR 0 5
79663: PPUSH
79664: LD_VAR 0 8
79668: PUSH
79669: LD_VAR 0 3
79673: ARRAY
79674: PPUSH
79675: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
79679: LD_INT 35
79681: PPUSH
79682: CALL_OW 67
// until not HasTask ( tmp ) ;
79686: LD_VAR 0 7
79690: PPUSH
79691: CALL_OW 314
79695: NOT
79696: IFFALSE 79679
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
79698: LD_ADDR_EXP 97
79702: PUSH
79703: LD_EXP 97
79707: PPUSH
79708: LD_VAR 0 2
79712: PUSH
79713: LD_EXP 97
79717: PUSH
79718: LD_VAR 0 2
79722: ARRAY
79723: PUSH
79724: LD_INT 1
79726: PLUS
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: PPUSH
79732: LD_VAR 0 8
79736: PUSH
79737: LD_VAR 0 3
79741: ARRAY
79742: PPUSH
79743: CALL 21397 0 3
79747: ST_TO_ADDR
// end ;
79748: GO 79406
79750: POP
79751: POP
// MC_Reset ( i , 124 ) ;
79752: LD_VAR 0 2
79756: PPUSH
79757: LD_INT 124
79759: PPUSH
79760: CALL 62836 0 2
// end ; end ;
79764: GO 79161
79766: POP
79767: POP
// end ;
79768: LD_VAR 0 1
79772: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
79773: LD_INT 0
79775: PPUSH
79776: PPUSH
79777: PPUSH
// if not mc_bases then
79778: LD_EXP 61
79782: NOT
79783: IFFALSE 79787
// exit ;
79785: GO 80393
// for i = 1 to mc_bases do
79787: LD_ADDR_VAR 0 2
79791: PUSH
79792: DOUBLE
79793: LD_INT 1
79795: DEC
79796: ST_TO_ADDR
79797: LD_EXP 61
79801: PUSH
79802: FOR_TO
79803: IFFALSE 80391
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
79805: LD_ADDR_VAR 0 3
79809: PUSH
79810: LD_EXP 61
79814: PUSH
79815: LD_VAR 0 2
79819: ARRAY
79820: PPUSH
79821: LD_INT 25
79823: PUSH
79824: LD_INT 4
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: PPUSH
79831: CALL_OW 72
79835: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79836: LD_VAR 0 3
79840: NOT
79841: PUSH
79842: LD_EXP 98
79846: PUSH
79847: LD_VAR 0 2
79851: ARRAY
79852: NOT
79853: OR
79854: PUSH
79855: LD_EXP 61
79859: PUSH
79860: LD_VAR 0 2
79864: ARRAY
79865: PPUSH
79866: LD_INT 2
79868: PUSH
79869: LD_INT 30
79871: PUSH
79872: LD_INT 0
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: LD_INT 30
79881: PUSH
79882: LD_INT 1
79884: PUSH
79885: EMPTY
79886: LIST
79887: LIST
79888: PUSH
79889: EMPTY
79890: LIST
79891: LIST
79892: LIST
79893: PPUSH
79894: CALL_OW 72
79898: NOT
79899: OR
79900: IFFALSE 79950
// begin if mc_deposits_finder [ i ] then
79902: LD_EXP 99
79906: PUSH
79907: LD_VAR 0 2
79911: ARRAY
79912: IFFALSE 79948
// begin MC_Reset ( i , 125 ) ;
79914: LD_VAR 0 2
79918: PPUSH
79919: LD_INT 125
79921: PPUSH
79922: CALL 62836 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
79926: LD_ADDR_EXP 99
79930: PUSH
79931: LD_EXP 99
79935: PPUSH
79936: LD_VAR 0 2
79940: PPUSH
79941: EMPTY
79942: PPUSH
79943: CALL_OW 1
79947: ST_TO_ADDR
// end ; continue ;
79948: GO 79802
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
79950: LD_EXP 98
79954: PUSH
79955: LD_VAR 0 2
79959: ARRAY
79960: PUSH
79961: LD_INT 1
79963: ARRAY
79964: PUSH
79965: LD_INT 3
79967: ARRAY
79968: PUSH
79969: LD_INT 1
79971: EQUAL
79972: PUSH
79973: LD_INT 20
79975: PPUSH
79976: LD_EXP 87
79980: PUSH
79981: LD_VAR 0 2
79985: ARRAY
79986: PPUSH
79987: CALL_OW 321
79991: PUSH
79992: LD_INT 2
79994: NONEQUAL
79995: AND
79996: IFFALSE 80046
// begin if mc_deposits_finder [ i ] then
79998: LD_EXP 99
80002: PUSH
80003: LD_VAR 0 2
80007: ARRAY
80008: IFFALSE 80044
// begin MC_Reset ( i , 125 ) ;
80010: LD_VAR 0 2
80014: PPUSH
80015: LD_INT 125
80017: PPUSH
80018: CALL 62836 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
80022: LD_ADDR_EXP 99
80026: PUSH
80027: LD_EXP 99
80031: PPUSH
80032: LD_VAR 0 2
80036: PPUSH
80037: EMPTY
80038: PPUSH
80039: CALL_OW 1
80043: ST_TO_ADDR
// end ; continue ;
80044: GO 79802
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
80046: LD_EXP 98
80050: PUSH
80051: LD_VAR 0 2
80055: ARRAY
80056: PUSH
80057: LD_INT 1
80059: ARRAY
80060: PUSH
80061: LD_INT 1
80063: ARRAY
80064: PPUSH
80065: LD_EXP 98
80069: PUSH
80070: LD_VAR 0 2
80074: ARRAY
80075: PUSH
80076: LD_INT 1
80078: ARRAY
80079: PUSH
80080: LD_INT 2
80082: ARRAY
80083: PPUSH
80084: LD_EXP 87
80088: PUSH
80089: LD_VAR 0 2
80093: ARRAY
80094: PPUSH
80095: CALL_OW 440
80099: IFFALSE 80142
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
80101: LD_ADDR_EXP 98
80105: PUSH
80106: LD_EXP 98
80110: PPUSH
80111: LD_VAR 0 2
80115: PPUSH
80116: LD_EXP 98
80120: PUSH
80121: LD_VAR 0 2
80125: ARRAY
80126: PPUSH
80127: LD_INT 1
80129: PPUSH
80130: CALL_OW 3
80134: PPUSH
80135: CALL_OW 1
80139: ST_TO_ADDR
80140: GO 80389
// begin if not mc_deposits_finder [ i ] then
80142: LD_EXP 99
80146: PUSH
80147: LD_VAR 0 2
80151: ARRAY
80152: NOT
80153: IFFALSE 80205
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
80155: LD_ADDR_EXP 99
80159: PUSH
80160: LD_EXP 99
80164: PPUSH
80165: LD_VAR 0 2
80169: PPUSH
80170: LD_VAR 0 3
80174: PUSH
80175: LD_INT 1
80177: ARRAY
80178: PUSH
80179: EMPTY
80180: LIST
80181: PPUSH
80182: CALL_OW 1
80186: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
80187: LD_VAR 0 3
80191: PUSH
80192: LD_INT 1
80194: ARRAY
80195: PPUSH
80196: LD_INT 125
80198: PPUSH
80199: CALL_OW 109
// end else
80203: GO 80389
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
80205: LD_EXP 99
80209: PUSH
80210: LD_VAR 0 2
80214: ARRAY
80215: PUSH
80216: LD_INT 1
80218: ARRAY
80219: PPUSH
80220: CALL_OW 310
80224: IFFALSE 80247
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
80226: LD_EXP 99
80230: PUSH
80231: LD_VAR 0 2
80235: ARRAY
80236: PUSH
80237: LD_INT 1
80239: ARRAY
80240: PPUSH
80241: CALL_OW 122
80245: GO 80389
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
80247: LD_EXP 99
80251: PUSH
80252: LD_VAR 0 2
80256: ARRAY
80257: PUSH
80258: LD_INT 1
80260: ARRAY
80261: PPUSH
80262: CALL_OW 314
80266: NOT
80267: PUSH
80268: LD_EXP 99
80272: PUSH
80273: LD_VAR 0 2
80277: ARRAY
80278: PUSH
80279: LD_INT 1
80281: ARRAY
80282: PPUSH
80283: LD_EXP 98
80287: PUSH
80288: LD_VAR 0 2
80292: ARRAY
80293: PUSH
80294: LD_INT 1
80296: ARRAY
80297: PUSH
80298: LD_INT 1
80300: ARRAY
80301: PPUSH
80302: LD_EXP 98
80306: PUSH
80307: LD_VAR 0 2
80311: ARRAY
80312: PUSH
80313: LD_INT 1
80315: ARRAY
80316: PUSH
80317: LD_INT 2
80319: ARRAY
80320: PPUSH
80321: CALL_OW 297
80325: PUSH
80326: LD_INT 6
80328: GREATER
80329: AND
80330: IFFALSE 80389
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
80332: LD_EXP 99
80336: PUSH
80337: LD_VAR 0 2
80341: ARRAY
80342: PUSH
80343: LD_INT 1
80345: ARRAY
80346: PPUSH
80347: LD_EXP 98
80351: PUSH
80352: LD_VAR 0 2
80356: ARRAY
80357: PUSH
80358: LD_INT 1
80360: ARRAY
80361: PUSH
80362: LD_INT 1
80364: ARRAY
80365: PPUSH
80366: LD_EXP 98
80370: PUSH
80371: LD_VAR 0 2
80375: ARRAY
80376: PUSH
80377: LD_INT 1
80379: ARRAY
80380: PUSH
80381: LD_INT 2
80383: ARRAY
80384: PPUSH
80385: CALL_OW 111
// end ; end ; end ;
80389: GO 79802
80391: POP
80392: POP
// end ;
80393: LD_VAR 0 1
80397: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
80398: LD_INT 0
80400: PPUSH
80401: PPUSH
80402: PPUSH
80403: PPUSH
80404: PPUSH
80405: PPUSH
80406: PPUSH
80407: PPUSH
80408: PPUSH
80409: PPUSH
80410: PPUSH
// if not mc_bases then
80411: LD_EXP 61
80415: NOT
80416: IFFALSE 80420
// exit ;
80418: GO 81360
// for i = 1 to mc_bases do
80420: LD_ADDR_VAR 0 2
80424: PUSH
80425: DOUBLE
80426: LD_INT 1
80428: DEC
80429: ST_TO_ADDR
80430: LD_EXP 61
80434: PUSH
80435: FOR_TO
80436: IFFALSE 81358
// begin if not mc_bases [ i ] or mc_scan [ i ] then
80438: LD_EXP 61
80442: PUSH
80443: LD_VAR 0 2
80447: ARRAY
80448: NOT
80449: PUSH
80450: LD_EXP 84
80454: PUSH
80455: LD_VAR 0 2
80459: ARRAY
80460: OR
80461: IFFALSE 80465
// continue ;
80463: GO 80435
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
80465: LD_ADDR_VAR 0 7
80469: PUSH
80470: LD_EXP 61
80474: PUSH
80475: LD_VAR 0 2
80479: ARRAY
80480: PUSH
80481: LD_INT 1
80483: ARRAY
80484: PPUSH
80485: CALL_OW 248
80489: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
80490: LD_VAR 0 7
80494: PUSH
80495: LD_INT 3
80497: EQUAL
80498: PUSH
80499: LD_EXP 80
80503: PUSH
80504: LD_VAR 0 2
80508: ARRAY
80509: PUSH
80510: LD_EXP 83
80514: PUSH
80515: LD_VAR 0 2
80519: ARRAY
80520: UNION
80521: PPUSH
80522: LD_INT 33
80524: PUSH
80525: LD_INT 2
80527: PUSH
80528: EMPTY
80529: LIST
80530: LIST
80531: PPUSH
80532: CALL_OW 72
80536: NOT
80537: OR
80538: IFFALSE 80542
// continue ;
80540: GO 80435
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
80542: LD_ADDR_VAR 0 9
80546: PUSH
80547: LD_EXP 61
80551: PUSH
80552: LD_VAR 0 2
80556: ARRAY
80557: PPUSH
80558: LD_INT 30
80560: PUSH
80561: LD_INT 36
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: PPUSH
80568: CALL_OW 72
80572: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
80573: LD_ADDR_VAR 0 10
80577: PUSH
80578: LD_EXP 80
80582: PUSH
80583: LD_VAR 0 2
80587: ARRAY
80588: PPUSH
80589: LD_INT 34
80591: PUSH
80592: LD_INT 31
80594: PUSH
80595: EMPTY
80596: LIST
80597: LIST
80598: PPUSH
80599: CALL_OW 72
80603: ST_TO_ADDR
// if not cts and not mcts then
80604: LD_VAR 0 9
80608: NOT
80609: PUSH
80610: LD_VAR 0 10
80614: NOT
80615: AND
80616: IFFALSE 80620
// continue ;
80618: GO 80435
// x := cts ;
80620: LD_ADDR_VAR 0 11
80624: PUSH
80625: LD_VAR 0 9
80629: ST_TO_ADDR
// if not x then
80630: LD_VAR 0 11
80634: NOT
80635: IFFALSE 80647
// x := mcts ;
80637: LD_ADDR_VAR 0 11
80641: PUSH
80642: LD_VAR 0 10
80646: ST_TO_ADDR
// if not x then
80647: LD_VAR 0 11
80651: NOT
80652: IFFALSE 80656
// continue ;
80654: GO 80435
// if mc_remote_driver [ i ] then
80656: LD_EXP 101
80660: PUSH
80661: LD_VAR 0 2
80665: ARRAY
80666: IFFALSE 81053
// for j in mc_remote_driver [ i ] do
80668: LD_ADDR_VAR 0 3
80672: PUSH
80673: LD_EXP 101
80677: PUSH
80678: LD_VAR 0 2
80682: ARRAY
80683: PUSH
80684: FOR_IN
80685: IFFALSE 81051
// begin if GetClass ( j ) <> 3 then
80687: LD_VAR 0 3
80691: PPUSH
80692: CALL_OW 257
80696: PUSH
80697: LD_INT 3
80699: NONEQUAL
80700: IFFALSE 80753
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
80702: LD_ADDR_EXP 101
80706: PUSH
80707: LD_EXP 101
80711: PPUSH
80712: LD_VAR 0 2
80716: PPUSH
80717: LD_EXP 101
80721: PUSH
80722: LD_VAR 0 2
80726: ARRAY
80727: PUSH
80728: LD_VAR 0 3
80732: DIFF
80733: PPUSH
80734: CALL_OW 1
80738: ST_TO_ADDR
// SetTag ( j , 0 ) ;
80739: LD_VAR 0 3
80743: PPUSH
80744: LD_INT 0
80746: PPUSH
80747: CALL_OW 109
// continue ;
80751: GO 80684
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
80753: LD_EXP 80
80757: PUSH
80758: LD_VAR 0 2
80762: ARRAY
80763: PPUSH
80764: LD_INT 34
80766: PUSH
80767: LD_INT 31
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PUSH
80774: LD_INT 58
80776: PUSH
80777: EMPTY
80778: LIST
80779: PUSH
80780: EMPTY
80781: LIST
80782: LIST
80783: PPUSH
80784: CALL_OW 72
80788: PUSH
80789: LD_VAR 0 3
80793: PPUSH
80794: CALL 51741 0 1
80798: NOT
80799: AND
80800: IFFALSE 80871
// begin if IsInUnit ( j ) then
80802: LD_VAR 0 3
80806: PPUSH
80807: CALL_OW 310
80811: IFFALSE 80822
// ComExitBuilding ( j ) ;
80813: LD_VAR 0 3
80817: PPUSH
80818: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
80822: LD_VAR 0 3
80826: PPUSH
80827: LD_EXP 80
80831: PUSH
80832: LD_VAR 0 2
80836: ARRAY
80837: PPUSH
80838: LD_INT 34
80840: PUSH
80841: LD_INT 31
80843: PUSH
80844: EMPTY
80845: LIST
80846: LIST
80847: PUSH
80848: LD_INT 58
80850: PUSH
80851: EMPTY
80852: LIST
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PPUSH
80858: CALL_OW 72
80862: PUSH
80863: LD_INT 1
80865: ARRAY
80866: PPUSH
80867: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
80871: LD_VAR 0 3
80875: PPUSH
80876: CALL_OW 310
80880: NOT
80881: PUSH
80882: LD_VAR 0 3
80886: PPUSH
80887: CALL_OW 310
80891: PPUSH
80892: CALL_OW 266
80896: PUSH
80897: LD_INT 36
80899: NONEQUAL
80900: PUSH
80901: LD_VAR 0 3
80905: PPUSH
80906: CALL 51741 0 1
80910: NOT
80911: AND
80912: OR
80913: IFFALSE 81049
// begin if IsInUnit ( j ) then
80915: LD_VAR 0 3
80919: PPUSH
80920: CALL_OW 310
80924: IFFALSE 80935
// ComExitBuilding ( j ) ;
80926: LD_VAR 0 3
80930: PPUSH
80931: CALL_OW 122
// ct := 0 ;
80935: LD_ADDR_VAR 0 8
80939: PUSH
80940: LD_INT 0
80942: ST_TO_ADDR
// for k in x do
80943: LD_ADDR_VAR 0 4
80947: PUSH
80948: LD_VAR 0 11
80952: PUSH
80953: FOR_IN
80954: IFFALSE 81027
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
80956: LD_VAR 0 4
80960: PPUSH
80961: CALL_OW 264
80965: PUSH
80966: LD_INT 31
80968: EQUAL
80969: PUSH
80970: LD_VAR 0 4
80974: PPUSH
80975: CALL_OW 311
80979: NOT
80980: AND
80981: PUSH
80982: LD_VAR 0 4
80986: PPUSH
80987: CALL_OW 266
80991: PUSH
80992: LD_INT 36
80994: EQUAL
80995: PUSH
80996: LD_VAR 0 4
81000: PPUSH
81001: CALL_OW 313
81005: PUSH
81006: LD_INT 3
81008: LESS
81009: AND
81010: OR
81011: IFFALSE 81025
// begin ct := k ;
81013: LD_ADDR_VAR 0 8
81017: PUSH
81018: LD_VAR 0 4
81022: ST_TO_ADDR
// break ;
81023: GO 81027
// end ;
81025: GO 80953
81027: POP
81028: POP
// if ct then
81029: LD_VAR 0 8
81033: IFFALSE 81049
// ComEnterUnit ( j , ct ) ;
81035: LD_VAR 0 3
81039: PPUSH
81040: LD_VAR 0 8
81044: PPUSH
81045: CALL_OW 120
// end ; end ;
81049: GO 80684
81051: POP
81052: POP
// places := 0 ;
81053: LD_ADDR_VAR 0 5
81057: PUSH
81058: LD_INT 0
81060: ST_TO_ADDR
// for j = 1 to x do
81061: LD_ADDR_VAR 0 3
81065: PUSH
81066: DOUBLE
81067: LD_INT 1
81069: DEC
81070: ST_TO_ADDR
81071: LD_VAR 0 11
81075: PUSH
81076: FOR_TO
81077: IFFALSE 81153
// if GetWeapon ( x [ j ] ) = ar_control_tower then
81079: LD_VAR 0 11
81083: PUSH
81084: LD_VAR 0 3
81088: ARRAY
81089: PPUSH
81090: CALL_OW 264
81094: PUSH
81095: LD_INT 31
81097: EQUAL
81098: IFFALSE 81116
// places := places + 1 else
81100: LD_ADDR_VAR 0 5
81104: PUSH
81105: LD_VAR 0 5
81109: PUSH
81110: LD_INT 1
81112: PLUS
81113: ST_TO_ADDR
81114: GO 81151
// if GetBType ( x [ j ] ) = b_control_tower then
81116: LD_VAR 0 11
81120: PUSH
81121: LD_VAR 0 3
81125: ARRAY
81126: PPUSH
81127: CALL_OW 266
81131: PUSH
81132: LD_INT 36
81134: EQUAL
81135: IFFALSE 81151
// places := places + 3 ;
81137: LD_ADDR_VAR 0 5
81141: PUSH
81142: LD_VAR 0 5
81146: PUSH
81147: LD_INT 3
81149: PLUS
81150: ST_TO_ADDR
81151: GO 81076
81153: POP
81154: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
81155: LD_VAR 0 5
81159: PUSH
81160: LD_INT 0
81162: EQUAL
81163: PUSH
81164: LD_VAR 0 5
81168: PUSH
81169: LD_EXP 101
81173: PUSH
81174: LD_VAR 0 2
81178: ARRAY
81179: LESSEQUAL
81180: OR
81181: IFFALSE 81185
// continue ;
81183: GO 80435
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
81185: LD_ADDR_VAR 0 6
81189: PUSH
81190: LD_EXP 61
81194: PUSH
81195: LD_VAR 0 2
81199: ARRAY
81200: PPUSH
81201: LD_INT 25
81203: PUSH
81204: LD_INT 3
81206: PUSH
81207: EMPTY
81208: LIST
81209: LIST
81210: PPUSH
81211: CALL_OW 72
81215: PUSH
81216: LD_EXP 101
81220: PUSH
81221: LD_VAR 0 2
81225: ARRAY
81226: DIFF
81227: PPUSH
81228: LD_INT 3
81230: PPUSH
81231: CALL 52641 0 2
81235: ST_TO_ADDR
// for j in tmp do
81236: LD_ADDR_VAR 0 3
81240: PUSH
81241: LD_VAR 0 6
81245: PUSH
81246: FOR_IN
81247: IFFALSE 81282
// if GetTag ( j ) > 0 then
81249: LD_VAR 0 3
81253: PPUSH
81254: CALL_OW 110
81258: PUSH
81259: LD_INT 0
81261: GREATER
81262: IFFALSE 81280
// tmp := tmp diff j ;
81264: LD_ADDR_VAR 0 6
81268: PUSH
81269: LD_VAR 0 6
81273: PUSH
81274: LD_VAR 0 3
81278: DIFF
81279: ST_TO_ADDR
81280: GO 81246
81282: POP
81283: POP
// if not tmp then
81284: LD_VAR 0 6
81288: NOT
81289: IFFALSE 81293
// continue ;
81291: GO 80435
// if places then
81293: LD_VAR 0 5
81297: IFFALSE 81356
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
81299: LD_ADDR_EXP 101
81303: PUSH
81304: LD_EXP 101
81308: PPUSH
81309: LD_VAR 0 2
81313: PPUSH
81314: LD_EXP 101
81318: PUSH
81319: LD_VAR 0 2
81323: ARRAY
81324: PUSH
81325: LD_VAR 0 6
81329: PUSH
81330: LD_INT 1
81332: ARRAY
81333: UNION
81334: PPUSH
81335: CALL_OW 1
81339: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
81340: LD_VAR 0 6
81344: PUSH
81345: LD_INT 1
81347: ARRAY
81348: PPUSH
81349: LD_INT 126
81351: PPUSH
81352: CALL_OW 109
// end ; end ;
81356: GO 80435
81358: POP
81359: POP
// end ;
81360: LD_VAR 0 1
81364: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
81365: LD_INT 0
81367: PPUSH
81368: PPUSH
81369: PPUSH
81370: PPUSH
81371: PPUSH
81372: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
81373: LD_VAR 0 1
81377: NOT
81378: PUSH
81379: LD_VAR 0 2
81383: NOT
81384: OR
81385: PUSH
81386: LD_VAR 0 3
81390: NOT
81391: OR
81392: PUSH
81393: LD_VAR 0 4
81397: PUSH
81398: LD_INT 1
81400: PUSH
81401: LD_INT 2
81403: PUSH
81404: LD_INT 3
81406: PUSH
81407: LD_INT 4
81409: PUSH
81410: LD_INT 5
81412: PUSH
81413: LD_INT 8
81415: PUSH
81416: LD_INT 9
81418: PUSH
81419: LD_INT 15
81421: PUSH
81422: LD_INT 16
81424: PUSH
81425: EMPTY
81426: LIST
81427: LIST
81428: LIST
81429: LIST
81430: LIST
81431: LIST
81432: LIST
81433: LIST
81434: LIST
81435: IN
81436: NOT
81437: OR
81438: IFFALSE 81442
// exit ;
81440: GO 82300
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
81442: LD_ADDR_VAR 0 2
81446: PUSH
81447: LD_VAR 0 2
81451: PPUSH
81452: LD_INT 21
81454: PUSH
81455: LD_INT 3
81457: PUSH
81458: EMPTY
81459: LIST
81460: LIST
81461: PUSH
81462: LD_INT 24
81464: PUSH
81465: LD_INT 250
81467: PUSH
81468: EMPTY
81469: LIST
81470: LIST
81471: PUSH
81472: EMPTY
81473: LIST
81474: LIST
81475: PPUSH
81476: CALL_OW 72
81480: ST_TO_ADDR
// case class of 1 , 15 :
81481: LD_VAR 0 4
81485: PUSH
81486: LD_INT 1
81488: DOUBLE
81489: EQUAL
81490: IFTRUE 81500
81492: LD_INT 15
81494: DOUBLE
81495: EQUAL
81496: IFTRUE 81500
81498: GO 81585
81500: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
81501: LD_ADDR_VAR 0 8
81505: PUSH
81506: LD_VAR 0 2
81510: PPUSH
81511: LD_INT 2
81513: PUSH
81514: LD_INT 30
81516: PUSH
81517: LD_INT 32
81519: PUSH
81520: EMPTY
81521: LIST
81522: LIST
81523: PUSH
81524: LD_INT 30
81526: PUSH
81527: LD_INT 31
81529: PUSH
81530: EMPTY
81531: LIST
81532: LIST
81533: PUSH
81534: EMPTY
81535: LIST
81536: LIST
81537: LIST
81538: PPUSH
81539: CALL_OW 72
81543: PUSH
81544: LD_VAR 0 2
81548: PPUSH
81549: LD_INT 2
81551: PUSH
81552: LD_INT 30
81554: PUSH
81555: LD_INT 4
81557: PUSH
81558: EMPTY
81559: LIST
81560: LIST
81561: PUSH
81562: LD_INT 30
81564: PUSH
81565: LD_INT 5
81567: PUSH
81568: EMPTY
81569: LIST
81570: LIST
81571: PUSH
81572: EMPTY
81573: LIST
81574: LIST
81575: LIST
81576: PPUSH
81577: CALL_OW 72
81581: ADD
81582: ST_TO_ADDR
81583: GO 81831
81585: LD_INT 2
81587: DOUBLE
81588: EQUAL
81589: IFTRUE 81599
81591: LD_INT 16
81593: DOUBLE
81594: EQUAL
81595: IFTRUE 81599
81597: GO 81645
81599: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
81600: LD_ADDR_VAR 0 8
81604: PUSH
81605: LD_VAR 0 2
81609: PPUSH
81610: LD_INT 2
81612: PUSH
81613: LD_INT 30
81615: PUSH
81616: LD_INT 0
81618: PUSH
81619: EMPTY
81620: LIST
81621: LIST
81622: PUSH
81623: LD_INT 30
81625: PUSH
81626: LD_INT 1
81628: PUSH
81629: EMPTY
81630: LIST
81631: LIST
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: LIST
81637: PPUSH
81638: CALL_OW 72
81642: ST_TO_ADDR
81643: GO 81831
81645: LD_INT 3
81647: DOUBLE
81648: EQUAL
81649: IFTRUE 81653
81651: GO 81699
81653: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
81654: LD_ADDR_VAR 0 8
81658: PUSH
81659: LD_VAR 0 2
81663: PPUSH
81664: LD_INT 2
81666: PUSH
81667: LD_INT 30
81669: PUSH
81670: LD_INT 2
81672: PUSH
81673: EMPTY
81674: LIST
81675: LIST
81676: PUSH
81677: LD_INT 30
81679: PUSH
81680: LD_INT 3
81682: PUSH
81683: EMPTY
81684: LIST
81685: LIST
81686: PUSH
81687: EMPTY
81688: LIST
81689: LIST
81690: LIST
81691: PPUSH
81692: CALL_OW 72
81696: ST_TO_ADDR
81697: GO 81831
81699: LD_INT 4
81701: DOUBLE
81702: EQUAL
81703: IFTRUE 81707
81705: GO 81764
81707: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
81708: LD_ADDR_VAR 0 8
81712: PUSH
81713: LD_VAR 0 2
81717: PPUSH
81718: LD_INT 2
81720: PUSH
81721: LD_INT 30
81723: PUSH
81724: LD_INT 6
81726: PUSH
81727: EMPTY
81728: LIST
81729: LIST
81730: PUSH
81731: LD_INT 30
81733: PUSH
81734: LD_INT 7
81736: PUSH
81737: EMPTY
81738: LIST
81739: LIST
81740: PUSH
81741: LD_INT 30
81743: PUSH
81744: LD_INT 8
81746: PUSH
81747: EMPTY
81748: LIST
81749: LIST
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: LIST
81755: LIST
81756: PPUSH
81757: CALL_OW 72
81761: ST_TO_ADDR
81762: GO 81831
81764: LD_INT 5
81766: DOUBLE
81767: EQUAL
81768: IFTRUE 81784
81770: LD_INT 8
81772: DOUBLE
81773: EQUAL
81774: IFTRUE 81784
81776: LD_INT 9
81778: DOUBLE
81779: EQUAL
81780: IFTRUE 81784
81782: GO 81830
81784: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
81785: LD_ADDR_VAR 0 8
81789: PUSH
81790: LD_VAR 0 2
81794: PPUSH
81795: LD_INT 2
81797: PUSH
81798: LD_INT 30
81800: PUSH
81801: LD_INT 4
81803: PUSH
81804: EMPTY
81805: LIST
81806: LIST
81807: PUSH
81808: LD_INT 30
81810: PUSH
81811: LD_INT 5
81813: PUSH
81814: EMPTY
81815: LIST
81816: LIST
81817: PUSH
81818: EMPTY
81819: LIST
81820: LIST
81821: LIST
81822: PPUSH
81823: CALL_OW 72
81827: ST_TO_ADDR
81828: GO 81831
81830: POP
// if not tmp then
81831: LD_VAR 0 8
81835: NOT
81836: IFFALSE 81840
// exit ;
81838: GO 82300
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
81840: LD_VAR 0 4
81844: PUSH
81845: LD_INT 1
81847: PUSH
81848: LD_INT 15
81850: PUSH
81851: EMPTY
81852: LIST
81853: LIST
81854: IN
81855: PUSH
81856: LD_EXP 70
81860: PUSH
81861: LD_VAR 0 1
81865: ARRAY
81866: AND
81867: IFFALSE 82023
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
81869: LD_ADDR_VAR 0 9
81873: PUSH
81874: LD_EXP 70
81878: PUSH
81879: LD_VAR 0 1
81883: ARRAY
81884: PUSH
81885: LD_INT 1
81887: ARRAY
81888: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
81889: LD_VAR 0 9
81893: PUSH
81894: LD_EXP 71
81898: PUSH
81899: LD_VAR 0 1
81903: ARRAY
81904: IN
81905: NOT
81906: IFFALSE 82021
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
81908: LD_ADDR_EXP 71
81912: PUSH
81913: LD_EXP 71
81917: PPUSH
81918: LD_VAR 0 1
81922: PUSH
81923: LD_EXP 71
81927: PUSH
81928: LD_VAR 0 1
81932: ARRAY
81933: PUSH
81934: LD_INT 1
81936: PLUS
81937: PUSH
81938: EMPTY
81939: LIST
81940: LIST
81941: PPUSH
81942: LD_VAR 0 9
81946: PPUSH
81947: CALL 21397 0 3
81951: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
81952: LD_ADDR_EXP 70
81956: PUSH
81957: LD_EXP 70
81961: PPUSH
81962: LD_VAR 0 1
81966: PPUSH
81967: LD_EXP 70
81971: PUSH
81972: LD_VAR 0 1
81976: ARRAY
81977: PUSH
81978: LD_VAR 0 9
81982: DIFF
81983: PPUSH
81984: CALL_OW 1
81988: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
81989: LD_VAR 0 3
81993: PPUSH
81994: LD_EXP 71
81998: PUSH
81999: LD_VAR 0 1
82003: ARRAY
82004: PUSH
82005: LD_EXP 71
82009: PUSH
82010: LD_VAR 0 1
82014: ARRAY
82015: ARRAY
82016: PPUSH
82017: CALL_OW 120
// end ; exit ;
82021: GO 82300
// end ; if tmp > 1 then
82023: LD_VAR 0 8
82027: PUSH
82028: LD_INT 1
82030: GREATER
82031: IFFALSE 82135
// for i = 2 to tmp do
82033: LD_ADDR_VAR 0 6
82037: PUSH
82038: DOUBLE
82039: LD_INT 2
82041: DEC
82042: ST_TO_ADDR
82043: LD_VAR 0 8
82047: PUSH
82048: FOR_TO
82049: IFFALSE 82133
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
82051: LD_VAR 0 8
82055: PUSH
82056: LD_VAR 0 6
82060: ARRAY
82061: PPUSH
82062: CALL_OW 461
82066: PUSH
82067: LD_INT 6
82069: EQUAL
82070: IFFALSE 82131
// begin x := tmp [ i ] ;
82072: LD_ADDR_VAR 0 9
82076: PUSH
82077: LD_VAR 0 8
82081: PUSH
82082: LD_VAR 0 6
82086: ARRAY
82087: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
82088: LD_ADDR_VAR 0 8
82092: PUSH
82093: LD_VAR 0 8
82097: PPUSH
82098: LD_VAR 0 6
82102: PPUSH
82103: CALL_OW 3
82107: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
82108: LD_ADDR_VAR 0 8
82112: PUSH
82113: LD_VAR 0 8
82117: PPUSH
82118: LD_INT 1
82120: PPUSH
82121: LD_VAR 0 9
82125: PPUSH
82126: CALL_OW 2
82130: ST_TO_ADDR
// end ;
82131: GO 82048
82133: POP
82134: POP
// for i in tmp do
82135: LD_ADDR_VAR 0 6
82139: PUSH
82140: LD_VAR 0 8
82144: PUSH
82145: FOR_IN
82146: IFFALSE 82173
// begin if IsNotFull ( i ) then
82148: LD_VAR 0 6
82152: PPUSH
82153: CALL 18619 0 1
82157: IFFALSE 82171
// begin j := i ;
82159: LD_ADDR_VAR 0 7
82163: PUSH
82164: LD_VAR 0 6
82168: ST_TO_ADDR
// break ;
82169: GO 82173
// end ; end ;
82171: GO 82145
82173: POP
82174: POP
// if j then
82175: LD_VAR 0 7
82179: IFFALSE 82197
// ComEnterUnit ( unit , j ) else
82181: LD_VAR 0 3
82185: PPUSH
82186: LD_VAR 0 7
82190: PPUSH
82191: CALL_OW 120
82195: GO 82300
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82197: LD_ADDR_VAR 0 10
82201: PUSH
82202: LD_VAR 0 2
82206: PPUSH
82207: LD_INT 2
82209: PUSH
82210: LD_INT 30
82212: PUSH
82213: LD_INT 0
82215: PUSH
82216: EMPTY
82217: LIST
82218: LIST
82219: PUSH
82220: LD_INT 30
82222: PUSH
82223: LD_INT 1
82225: PUSH
82226: EMPTY
82227: LIST
82228: LIST
82229: PUSH
82230: EMPTY
82231: LIST
82232: LIST
82233: LIST
82234: PPUSH
82235: CALL_OW 72
82239: ST_TO_ADDR
// if depot then
82240: LD_VAR 0 10
82244: IFFALSE 82300
// begin depot := NearestUnitToUnit ( depot , unit ) ;
82246: LD_ADDR_VAR 0 10
82250: PUSH
82251: LD_VAR 0 10
82255: PPUSH
82256: LD_VAR 0 3
82260: PPUSH
82261: CALL_OW 74
82265: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
82266: LD_VAR 0 3
82270: PPUSH
82271: LD_VAR 0 10
82275: PPUSH
82276: CALL_OW 296
82280: PUSH
82281: LD_INT 10
82283: GREATER
82284: IFFALSE 82300
// ComStandNearbyBuilding ( unit , depot ) ;
82286: LD_VAR 0 3
82290: PPUSH
82291: LD_VAR 0 10
82295: PPUSH
82296: CALL 17999 0 2
// end ; end ; end ;
82300: LD_VAR 0 5
82304: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
82305: LD_INT 0
82307: PPUSH
82308: PPUSH
82309: PPUSH
82310: PPUSH
// if not mc_bases then
82311: LD_EXP 61
82315: NOT
82316: IFFALSE 82320
// exit ;
82318: GO 82559
// for i = 1 to mc_bases do
82320: LD_ADDR_VAR 0 2
82324: PUSH
82325: DOUBLE
82326: LD_INT 1
82328: DEC
82329: ST_TO_ADDR
82330: LD_EXP 61
82334: PUSH
82335: FOR_TO
82336: IFFALSE 82557
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
82338: LD_ADDR_VAR 0 4
82342: PUSH
82343: LD_EXP 61
82347: PUSH
82348: LD_VAR 0 2
82352: ARRAY
82353: PPUSH
82354: LD_INT 21
82356: PUSH
82357: LD_INT 1
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PPUSH
82364: CALL_OW 72
82368: PUSH
82369: LD_EXP 90
82373: PUSH
82374: LD_VAR 0 2
82378: ARRAY
82379: UNION
82380: ST_TO_ADDR
// if not tmp then
82381: LD_VAR 0 4
82385: NOT
82386: IFFALSE 82390
// continue ;
82388: GO 82335
// for j in tmp do
82390: LD_ADDR_VAR 0 3
82394: PUSH
82395: LD_VAR 0 4
82399: PUSH
82400: FOR_IN
82401: IFFALSE 82553
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
82403: LD_VAR 0 3
82407: PPUSH
82408: CALL_OW 110
82412: NOT
82413: PUSH
82414: LD_VAR 0 3
82418: PPUSH
82419: CALL_OW 314
82423: NOT
82424: AND
82425: PUSH
82426: LD_VAR 0 3
82430: PPUSH
82431: CALL_OW 311
82435: NOT
82436: AND
82437: PUSH
82438: LD_VAR 0 3
82442: PPUSH
82443: CALL_OW 310
82447: NOT
82448: AND
82449: PUSH
82450: LD_VAR 0 3
82454: PUSH
82455: LD_EXP 64
82459: PUSH
82460: LD_VAR 0 2
82464: ARRAY
82465: PUSH
82466: LD_INT 1
82468: ARRAY
82469: IN
82470: NOT
82471: AND
82472: PUSH
82473: LD_VAR 0 3
82477: PUSH
82478: LD_EXP 64
82482: PUSH
82483: LD_VAR 0 2
82487: ARRAY
82488: PUSH
82489: LD_INT 2
82491: ARRAY
82492: IN
82493: NOT
82494: AND
82495: PUSH
82496: LD_VAR 0 3
82500: PUSH
82501: LD_EXP 73
82505: PUSH
82506: LD_VAR 0 2
82510: ARRAY
82511: IN
82512: NOT
82513: AND
82514: IFFALSE 82551
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
82516: LD_VAR 0 2
82520: PPUSH
82521: LD_EXP 61
82525: PUSH
82526: LD_VAR 0 2
82530: ARRAY
82531: PPUSH
82532: LD_VAR 0 3
82536: PPUSH
82537: LD_VAR 0 3
82541: PPUSH
82542: CALL_OW 257
82546: PPUSH
82547: CALL 81365 0 4
// end ;
82551: GO 82400
82553: POP
82554: POP
// end ;
82555: GO 82335
82557: POP
82558: POP
// end ;
82559: LD_VAR 0 1
82563: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
82564: LD_INT 0
82566: PPUSH
82567: PPUSH
82568: PPUSH
82569: PPUSH
82570: PPUSH
82571: PPUSH
// if not mc_bases [ base ] then
82572: LD_EXP 61
82576: PUSH
82577: LD_VAR 0 1
82581: ARRAY
82582: NOT
82583: IFFALSE 82587
// exit ;
82585: GO 82788
// tmp := [ ] ;
82587: LD_ADDR_VAR 0 6
82591: PUSH
82592: EMPTY
82593: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
82594: LD_ADDR_VAR 0 7
82598: PUSH
82599: LD_VAR 0 3
82603: PPUSH
82604: LD_INT 0
82606: PPUSH
82607: CALL_OW 517
82611: ST_TO_ADDR
// if not list then
82612: LD_VAR 0 7
82616: NOT
82617: IFFALSE 82621
// exit ;
82619: GO 82788
// c := Count ( list [ 1 ] ) ;
82621: LD_ADDR_VAR 0 9
82625: PUSH
82626: LD_VAR 0 7
82630: PUSH
82631: LD_INT 1
82633: ARRAY
82634: PPUSH
82635: CALL 18537 0 1
82639: ST_TO_ADDR
// if amount > c then
82640: LD_VAR 0 2
82644: PUSH
82645: LD_VAR 0 9
82649: GREATER
82650: IFFALSE 82662
// amount := c ;
82652: LD_ADDR_VAR 0 2
82656: PUSH
82657: LD_VAR 0 9
82661: ST_TO_ADDR
// for i := 1 to amount do
82662: LD_ADDR_VAR 0 5
82666: PUSH
82667: DOUBLE
82668: LD_INT 1
82670: DEC
82671: ST_TO_ADDR
82672: LD_VAR 0 2
82676: PUSH
82677: FOR_TO
82678: IFFALSE 82736
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
82680: LD_ADDR_VAR 0 6
82684: PUSH
82685: LD_VAR 0 6
82689: PPUSH
82690: LD_VAR 0 5
82694: PPUSH
82695: LD_VAR 0 7
82699: PUSH
82700: LD_INT 1
82702: ARRAY
82703: PUSH
82704: LD_VAR 0 5
82708: ARRAY
82709: PUSH
82710: LD_VAR 0 7
82714: PUSH
82715: LD_INT 2
82717: ARRAY
82718: PUSH
82719: LD_VAR 0 5
82723: ARRAY
82724: PUSH
82725: EMPTY
82726: LIST
82727: LIST
82728: PPUSH
82729: CALL_OW 1
82733: ST_TO_ADDR
82734: GO 82677
82736: POP
82737: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
82738: LD_ADDR_EXP 74
82742: PUSH
82743: LD_EXP 74
82747: PPUSH
82748: LD_VAR 0 1
82752: PPUSH
82753: LD_VAR 0 6
82757: PPUSH
82758: CALL_OW 1
82762: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
82763: LD_ADDR_EXP 76
82767: PUSH
82768: LD_EXP 76
82772: PPUSH
82773: LD_VAR 0 1
82777: PPUSH
82778: LD_VAR 0 3
82782: PPUSH
82783: CALL_OW 1
82787: ST_TO_ADDR
// end ;
82788: LD_VAR 0 4
82792: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
82793: LD_INT 0
82795: PPUSH
// if not mc_bases [ base ] then
82796: LD_EXP 61
82800: PUSH
82801: LD_VAR 0 1
82805: ARRAY
82806: NOT
82807: IFFALSE 82811
// exit ;
82809: GO 82836
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
82811: LD_ADDR_EXP 66
82815: PUSH
82816: LD_EXP 66
82820: PPUSH
82821: LD_VAR 0 1
82825: PPUSH
82826: LD_VAR 0 2
82830: PPUSH
82831: CALL_OW 1
82835: ST_TO_ADDR
// end ;
82836: LD_VAR 0 3
82840: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
82841: LD_INT 0
82843: PPUSH
// if not mc_bases [ base ] then
82844: LD_EXP 61
82848: PUSH
82849: LD_VAR 0 1
82853: ARRAY
82854: NOT
82855: IFFALSE 82859
// exit ;
82857: GO 82896
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
82859: LD_ADDR_EXP 66
82863: PUSH
82864: LD_EXP 66
82868: PPUSH
82869: LD_VAR 0 1
82873: PPUSH
82874: LD_EXP 66
82878: PUSH
82879: LD_VAR 0 1
82883: ARRAY
82884: PUSH
82885: LD_VAR 0 2
82889: UNION
82890: PPUSH
82891: CALL_OW 1
82895: ST_TO_ADDR
// end ;
82896: LD_VAR 0 3
82900: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
82901: LD_INT 0
82903: PPUSH
// if not mc_bases [ base ] then
82904: LD_EXP 61
82908: PUSH
82909: LD_VAR 0 1
82913: ARRAY
82914: NOT
82915: IFFALSE 82919
// exit ;
82917: GO 82944
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
82919: LD_ADDR_EXP 82
82923: PUSH
82924: LD_EXP 82
82928: PPUSH
82929: LD_VAR 0 1
82933: PPUSH
82934: LD_VAR 0 2
82938: PPUSH
82939: CALL_OW 1
82943: ST_TO_ADDR
// end ;
82944: LD_VAR 0 3
82948: RET
// export function MC_InsertProduceList ( base , components ) ; begin
82949: LD_INT 0
82951: PPUSH
// if not mc_bases [ base ] then
82952: LD_EXP 61
82956: PUSH
82957: LD_VAR 0 1
82961: ARRAY
82962: NOT
82963: IFFALSE 82967
// exit ;
82965: GO 83004
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
82967: LD_ADDR_EXP 82
82971: PUSH
82972: LD_EXP 82
82976: PPUSH
82977: LD_VAR 0 1
82981: PPUSH
82982: LD_EXP 82
82986: PUSH
82987: LD_VAR 0 1
82991: ARRAY
82992: PUSH
82993: LD_VAR 0 2
82997: ADD
82998: PPUSH
82999: CALL_OW 1
83003: ST_TO_ADDR
// end ;
83004: LD_VAR 0 3
83008: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
83009: LD_INT 0
83011: PPUSH
// if not mc_bases [ base ] then
83012: LD_EXP 61
83016: PUSH
83017: LD_VAR 0 1
83021: ARRAY
83022: NOT
83023: IFFALSE 83027
// exit ;
83025: GO 83081
// mc_defender := Replace ( mc_defender , base , deflist ) ;
83027: LD_ADDR_EXP 83
83031: PUSH
83032: LD_EXP 83
83036: PPUSH
83037: LD_VAR 0 1
83041: PPUSH
83042: LD_VAR 0 2
83046: PPUSH
83047: CALL_OW 1
83051: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
83052: LD_ADDR_EXP 72
83056: PUSH
83057: LD_EXP 72
83061: PPUSH
83062: LD_VAR 0 1
83066: PPUSH
83067: LD_VAR 0 2
83071: PUSH
83072: LD_INT 0
83074: PLUS
83075: PPUSH
83076: CALL_OW 1
83080: ST_TO_ADDR
// end ;
83081: LD_VAR 0 3
83085: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
83086: LD_INT 0
83088: PPUSH
// if not mc_bases [ base ] then
83089: LD_EXP 61
83093: PUSH
83094: LD_VAR 0 1
83098: ARRAY
83099: NOT
83100: IFFALSE 83104
// exit ;
83102: GO 83129
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
83104: LD_ADDR_EXP 72
83108: PUSH
83109: LD_EXP 72
83113: PPUSH
83114: LD_VAR 0 1
83118: PPUSH
83119: LD_VAR 0 2
83123: PPUSH
83124: CALL_OW 1
83128: ST_TO_ADDR
// end ;
83129: LD_VAR 0 3
83133: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
83134: LD_INT 0
83136: PPUSH
83137: PPUSH
83138: PPUSH
83139: PPUSH
// if not mc_bases [ base ] then
83140: LD_EXP 61
83144: PUSH
83145: LD_VAR 0 1
83149: ARRAY
83150: NOT
83151: IFFALSE 83155
// exit ;
83153: GO 83220
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
83155: LD_ADDR_EXP 81
83159: PUSH
83160: LD_EXP 81
83164: PPUSH
83165: LD_VAR 0 1
83169: PUSH
83170: LD_EXP 81
83174: PUSH
83175: LD_VAR 0 1
83179: ARRAY
83180: PUSH
83181: LD_INT 1
83183: PLUS
83184: PUSH
83185: EMPTY
83186: LIST
83187: LIST
83188: PPUSH
83189: LD_VAR 0 1
83193: PUSH
83194: LD_VAR 0 2
83198: PUSH
83199: LD_VAR 0 3
83203: PUSH
83204: LD_VAR 0 4
83208: PUSH
83209: EMPTY
83210: LIST
83211: LIST
83212: LIST
83213: LIST
83214: PPUSH
83215: CALL 21397 0 3
83219: ST_TO_ADDR
// end ;
83220: LD_VAR 0 5
83224: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
83225: LD_INT 0
83227: PPUSH
// if not mc_bases [ base ] then
83228: LD_EXP 61
83232: PUSH
83233: LD_VAR 0 1
83237: ARRAY
83238: NOT
83239: IFFALSE 83243
// exit ;
83241: GO 83268
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
83243: LD_ADDR_EXP 98
83247: PUSH
83248: LD_EXP 98
83252: PPUSH
83253: LD_VAR 0 1
83257: PPUSH
83258: LD_VAR 0 2
83262: PPUSH
83263: CALL_OW 1
83267: ST_TO_ADDR
// end ;
83268: LD_VAR 0 3
83272: RET
// export function MC_GetMinesField ( base ) ; begin
83273: LD_INT 0
83275: PPUSH
// result := mc_mines [ base ] ;
83276: LD_ADDR_VAR 0 2
83280: PUSH
83281: LD_EXP 74
83285: PUSH
83286: LD_VAR 0 1
83290: ARRAY
83291: ST_TO_ADDR
// end ;
83292: LD_VAR 0 2
83296: RET
// export function MC_GetProduceList ( base ) ; begin
83297: LD_INT 0
83299: PPUSH
// result := mc_produce [ base ] ;
83300: LD_ADDR_VAR 0 2
83304: PUSH
83305: LD_EXP 82
83309: PUSH
83310: LD_VAR 0 1
83314: ARRAY
83315: ST_TO_ADDR
// end ;
83316: LD_VAR 0 2
83320: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
83321: LD_INT 0
83323: PPUSH
83324: PPUSH
// if not mc_bases then
83325: LD_EXP 61
83329: NOT
83330: IFFALSE 83334
// exit ;
83332: GO 83399
// if mc_bases [ base ] then
83334: LD_EXP 61
83338: PUSH
83339: LD_VAR 0 1
83343: ARRAY
83344: IFFALSE 83399
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
83346: LD_ADDR_VAR 0 3
83350: PUSH
83351: LD_EXP 61
83355: PUSH
83356: LD_VAR 0 1
83360: ARRAY
83361: PPUSH
83362: LD_INT 30
83364: PUSH
83365: LD_VAR 0 2
83369: PUSH
83370: EMPTY
83371: LIST
83372: LIST
83373: PPUSH
83374: CALL_OW 72
83378: ST_TO_ADDR
// if result then
83379: LD_VAR 0 3
83383: IFFALSE 83399
// result := result [ 1 ] ;
83385: LD_ADDR_VAR 0 3
83389: PUSH
83390: LD_VAR 0 3
83394: PUSH
83395: LD_INT 1
83397: ARRAY
83398: ST_TO_ADDR
// end ; end ;
83399: LD_VAR 0 3
83403: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
83404: LD_INT 0
83406: PPUSH
83407: PPUSH
// if not mc_bases then
83408: LD_EXP 61
83412: NOT
83413: IFFALSE 83417
// exit ;
83415: GO 83462
// if mc_bases [ base ] then
83417: LD_EXP 61
83421: PUSH
83422: LD_VAR 0 1
83426: ARRAY
83427: IFFALSE 83462
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
83429: LD_ADDR_VAR 0 3
83433: PUSH
83434: LD_EXP 61
83438: PUSH
83439: LD_VAR 0 1
83443: ARRAY
83444: PPUSH
83445: LD_INT 30
83447: PUSH
83448: LD_VAR 0 2
83452: PUSH
83453: EMPTY
83454: LIST
83455: LIST
83456: PPUSH
83457: CALL_OW 72
83461: ST_TO_ADDR
// end ;
83462: LD_VAR 0 3
83466: RET
// export function MC_SetTame ( base , area ) ; begin
83467: LD_INT 0
83469: PPUSH
// if not mc_bases or not base then
83470: LD_EXP 61
83474: NOT
83475: PUSH
83476: LD_VAR 0 1
83480: NOT
83481: OR
83482: IFFALSE 83486
// exit ;
83484: GO 83511
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
83486: LD_ADDR_EXP 89
83490: PUSH
83491: LD_EXP 89
83495: PPUSH
83496: LD_VAR 0 1
83500: PPUSH
83501: LD_VAR 0 2
83505: PPUSH
83506: CALL_OW 1
83510: ST_TO_ADDR
// end ;
83511: LD_VAR 0 3
83515: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
83516: LD_INT 0
83518: PPUSH
83519: PPUSH
// if not mc_bases or not base then
83520: LD_EXP 61
83524: NOT
83525: PUSH
83526: LD_VAR 0 1
83530: NOT
83531: OR
83532: IFFALSE 83536
// exit ;
83534: GO 83638
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
83536: LD_ADDR_VAR 0 4
83540: PUSH
83541: LD_EXP 61
83545: PUSH
83546: LD_VAR 0 1
83550: ARRAY
83551: PPUSH
83552: LD_INT 30
83554: PUSH
83555: LD_VAR 0 2
83559: PUSH
83560: EMPTY
83561: LIST
83562: LIST
83563: PPUSH
83564: CALL_OW 72
83568: ST_TO_ADDR
// if not tmp then
83569: LD_VAR 0 4
83573: NOT
83574: IFFALSE 83578
// exit ;
83576: GO 83638
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
83578: LD_ADDR_EXP 93
83582: PUSH
83583: LD_EXP 93
83587: PPUSH
83588: LD_VAR 0 1
83592: PPUSH
83593: LD_EXP 93
83597: PUSH
83598: LD_VAR 0 1
83602: ARRAY
83603: PPUSH
83604: LD_EXP 93
83608: PUSH
83609: LD_VAR 0 1
83613: ARRAY
83614: PUSH
83615: LD_INT 1
83617: PLUS
83618: PPUSH
83619: LD_VAR 0 4
83623: PUSH
83624: LD_INT 1
83626: ARRAY
83627: PPUSH
83628: CALL_OW 2
83632: PPUSH
83633: CALL_OW 1
83637: ST_TO_ADDR
// end ;
83638: LD_VAR 0 3
83642: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
83643: LD_INT 0
83645: PPUSH
83646: PPUSH
// if not mc_bases or not base or not kinds then
83647: LD_EXP 61
83651: NOT
83652: PUSH
83653: LD_VAR 0 1
83657: NOT
83658: OR
83659: PUSH
83660: LD_VAR 0 2
83664: NOT
83665: OR
83666: IFFALSE 83670
// exit ;
83668: GO 83731
// for i in kinds do
83670: LD_ADDR_VAR 0 4
83674: PUSH
83675: LD_VAR 0 2
83679: PUSH
83680: FOR_IN
83681: IFFALSE 83729
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
83683: LD_ADDR_EXP 95
83687: PUSH
83688: LD_EXP 95
83692: PPUSH
83693: LD_VAR 0 1
83697: PUSH
83698: LD_EXP 95
83702: PUSH
83703: LD_VAR 0 1
83707: ARRAY
83708: PUSH
83709: LD_INT 1
83711: PLUS
83712: PUSH
83713: EMPTY
83714: LIST
83715: LIST
83716: PPUSH
83717: LD_VAR 0 4
83721: PPUSH
83722: CALL 21397 0 3
83726: ST_TO_ADDR
83727: GO 83680
83729: POP
83730: POP
// end ;
83731: LD_VAR 0 3
83735: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
83736: LD_INT 0
83738: PPUSH
// if not mc_bases or not base or not areas then
83739: LD_EXP 61
83743: NOT
83744: PUSH
83745: LD_VAR 0 1
83749: NOT
83750: OR
83751: PUSH
83752: LD_VAR 0 2
83756: NOT
83757: OR
83758: IFFALSE 83762
// exit ;
83760: GO 83787
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
83762: LD_ADDR_EXP 79
83766: PUSH
83767: LD_EXP 79
83771: PPUSH
83772: LD_VAR 0 1
83776: PPUSH
83777: LD_VAR 0 2
83781: PPUSH
83782: CALL_OW 1
83786: ST_TO_ADDR
// end ;
83787: LD_VAR 0 3
83791: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
83792: LD_INT 0
83794: PPUSH
// if not mc_bases or not base or not teleports_exit then
83795: LD_EXP 61
83799: NOT
83800: PUSH
83801: LD_VAR 0 1
83805: NOT
83806: OR
83807: PUSH
83808: LD_VAR 0 2
83812: NOT
83813: OR
83814: IFFALSE 83818
// exit ;
83816: GO 83843
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
83818: LD_ADDR_EXP 96
83822: PUSH
83823: LD_EXP 96
83827: PPUSH
83828: LD_VAR 0 1
83832: PPUSH
83833: LD_VAR 0 2
83837: PPUSH
83838: CALL_OW 1
83842: ST_TO_ADDR
// end ;
83843: LD_VAR 0 3
83847: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
83848: LD_INT 0
83850: PPUSH
83851: PPUSH
83852: PPUSH
// if not mc_bases or not base or not ext_list then
83853: LD_EXP 61
83857: NOT
83858: PUSH
83859: LD_VAR 0 1
83863: NOT
83864: OR
83865: PUSH
83866: LD_VAR 0 5
83870: NOT
83871: OR
83872: IFFALSE 83876
// exit ;
83874: GO 84049
// tmp := GetFacExtXYD ( x , y , d ) ;
83876: LD_ADDR_VAR 0 8
83880: PUSH
83881: LD_VAR 0 2
83885: PPUSH
83886: LD_VAR 0 3
83890: PPUSH
83891: LD_VAR 0 4
83895: PPUSH
83896: CALL 51771 0 3
83900: ST_TO_ADDR
// if not tmp then
83901: LD_VAR 0 8
83905: NOT
83906: IFFALSE 83910
// exit ;
83908: GO 84049
// for i in tmp do
83910: LD_ADDR_VAR 0 7
83914: PUSH
83915: LD_VAR 0 8
83919: PUSH
83920: FOR_IN
83921: IFFALSE 84047
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
83923: LD_ADDR_EXP 66
83927: PUSH
83928: LD_EXP 66
83932: PPUSH
83933: LD_VAR 0 1
83937: PPUSH
83938: LD_EXP 66
83942: PUSH
83943: LD_VAR 0 1
83947: ARRAY
83948: PPUSH
83949: LD_EXP 66
83953: PUSH
83954: LD_VAR 0 1
83958: ARRAY
83959: PUSH
83960: LD_INT 1
83962: PLUS
83963: PPUSH
83964: LD_VAR 0 5
83968: PUSH
83969: LD_INT 1
83971: ARRAY
83972: PUSH
83973: LD_VAR 0 7
83977: PUSH
83978: LD_INT 1
83980: ARRAY
83981: PUSH
83982: LD_VAR 0 7
83986: PUSH
83987: LD_INT 2
83989: ARRAY
83990: PUSH
83991: LD_VAR 0 7
83995: PUSH
83996: LD_INT 3
83998: ARRAY
83999: PUSH
84000: EMPTY
84001: LIST
84002: LIST
84003: LIST
84004: LIST
84005: PPUSH
84006: CALL_OW 2
84010: PPUSH
84011: CALL_OW 1
84015: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
84016: LD_ADDR_VAR 0 5
84020: PUSH
84021: LD_VAR 0 5
84025: PPUSH
84026: LD_INT 1
84028: PPUSH
84029: CALL_OW 3
84033: ST_TO_ADDR
// if not ext_list then
84034: LD_VAR 0 5
84038: NOT
84039: IFFALSE 84045
// exit ;
84041: POP
84042: POP
84043: GO 84049
// end ;
84045: GO 83920
84047: POP
84048: POP
// end ;
84049: LD_VAR 0 6
84053: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
84054: LD_INT 0
84056: PPUSH
// if not mc_bases or not base or not weapon_list then
84057: LD_EXP 61
84061: NOT
84062: PUSH
84063: LD_VAR 0 1
84067: NOT
84068: OR
84069: PUSH
84070: LD_VAR 0 2
84074: NOT
84075: OR
84076: IFFALSE 84080
// exit ;
84078: GO 84105
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
84080: LD_ADDR_EXP 100
84084: PUSH
84085: LD_EXP 100
84089: PPUSH
84090: LD_VAR 0 1
84094: PPUSH
84095: LD_VAR 0 2
84099: PPUSH
84100: CALL_OW 1
84104: ST_TO_ADDR
// end ;
84105: LD_VAR 0 3
84109: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
84110: LD_INT 0
84112: PPUSH
// if not mc_bases or not base or not tech_list then
84113: LD_EXP 61
84117: NOT
84118: PUSH
84119: LD_VAR 0 1
84123: NOT
84124: OR
84125: PUSH
84126: LD_VAR 0 2
84130: NOT
84131: OR
84132: IFFALSE 84136
// exit ;
84134: GO 84161
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
84136: LD_ADDR_EXP 88
84140: PUSH
84141: LD_EXP 88
84145: PPUSH
84146: LD_VAR 0 1
84150: PPUSH
84151: LD_VAR 0 2
84155: PPUSH
84156: CALL_OW 1
84160: ST_TO_ADDR
// end ;
84161: LD_VAR 0 3
84165: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
84166: LD_INT 0
84168: PPUSH
// if not mc_bases or not parking_area or not base then
84169: LD_EXP 61
84173: NOT
84174: PUSH
84175: LD_VAR 0 2
84179: NOT
84180: OR
84181: PUSH
84182: LD_VAR 0 1
84186: NOT
84187: OR
84188: IFFALSE 84192
// exit ;
84190: GO 84217
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
84192: LD_ADDR_EXP 85
84196: PUSH
84197: LD_EXP 85
84201: PPUSH
84202: LD_VAR 0 1
84206: PPUSH
84207: LD_VAR 0 2
84211: PPUSH
84212: CALL_OW 1
84216: ST_TO_ADDR
// end ;
84217: LD_VAR 0 3
84221: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
84222: LD_INT 0
84224: PPUSH
// if not mc_bases or not base or not scan_area then
84225: LD_EXP 61
84229: NOT
84230: PUSH
84231: LD_VAR 0 1
84235: NOT
84236: OR
84237: PUSH
84238: LD_VAR 0 2
84242: NOT
84243: OR
84244: IFFALSE 84248
// exit ;
84246: GO 84273
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
84248: LD_ADDR_EXP 86
84252: PUSH
84253: LD_EXP 86
84257: PPUSH
84258: LD_VAR 0 1
84262: PPUSH
84263: LD_VAR 0 2
84267: PPUSH
84268: CALL_OW 1
84272: ST_TO_ADDR
// end ;
84273: LD_VAR 0 3
84277: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
84278: LD_INT 0
84280: PPUSH
84281: PPUSH
// if not mc_bases or not base then
84282: LD_EXP 61
84286: NOT
84287: PUSH
84288: LD_VAR 0 1
84292: NOT
84293: OR
84294: IFFALSE 84298
// exit ;
84296: GO 84362
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
84298: LD_ADDR_VAR 0 3
84302: PUSH
84303: LD_INT 1
84305: PUSH
84306: LD_INT 2
84308: PUSH
84309: LD_INT 3
84311: PUSH
84312: LD_INT 4
84314: PUSH
84315: LD_INT 11
84317: PUSH
84318: EMPTY
84319: LIST
84320: LIST
84321: LIST
84322: LIST
84323: LIST
84324: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
84325: LD_ADDR_EXP 88
84329: PUSH
84330: LD_EXP 88
84334: PPUSH
84335: LD_VAR 0 1
84339: PPUSH
84340: LD_EXP 88
84344: PUSH
84345: LD_VAR 0 1
84349: ARRAY
84350: PUSH
84351: LD_VAR 0 3
84355: DIFF
84356: PPUSH
84357: CALL_OW 1
84361: ST_TO_ADDR
// end ;
84362: LD_VAR 0 2
84366: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
84367: LD_INT 0
84369: PPUSH
// result := mc_vehicles [ base ] ;
84370: LD_ADDR_VAR 0 3
84374: PUSH
84375: LD_EXP 80
84379: PUSH
84380: LD_VAR 0 1
84384: ARRAY
84385: ST_TO_ADDR
// if onlyCombat then
84386: LD_VAR 0 2
84390: IFFALSE 84562
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
84392: LD_ADDR_VAR 0 3
84396: PUSH
84397: LD_VAR 0 3
84401: PUSH
84402: LD_VAR 0 3
84406: PPUSH
84407: LD_INT 2
84409: PUSH
84410: LD_INT 34
84412: PUSH
84413: LD_INT 12
84415: PUSH
84416: EMPTY
84417: LIST
84418: LIST
84419: PUSH
84420: LD_INT 34
84422: PUSH
84423: LD_INT 51
84425: PUSH
84426: EMPTY
84427: LIST
84428: LIST
84429: PUSH
84430: LD_INT 34
84432: PUSH
84433: LD_INT 89
84435: PUSH
84436: EMPTY
84437: LIST
84438: LIST
84439: PUSH
84440: LD_INT 34
84442: PUSH
84443: LD_INT 32
84445: PUSH
84446: EMPTY
84447: LIST
84448: LIST
84449: PUSH
84450: LD_INT 34
84452: PUSH
84453: LD_INT 13
84455: PUSH
84456: EMPTY
84457: LIST
84458: LIST
84459: PUSH
84460: LD_INT 34
84462: PUSH
84463: LD_INT 52
84465: PUSH
84466: EMPTY
84467: LIST
84468: LIST
84469: PUSH
84470: LD_INT 34
84472: PUSH
84473: LD_INT 88
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PUSH
84480: LD_INT 34
84482: PUSH
84483: LD_INT 14
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: PUSH
84490: LD_INT 34
84492: PUSH
84493: LD_INT 53
84495: PUSH
84496: EMPTY
84497: LIST
84498: LIST
84499: PUSH
84500: LD_INT 34
84502: PUSH
84503: LD_INT 98
84505: PUSH
84506: EMPTY
84507: LIST
84508: LIST
84509: PUSH
84510: LD_INT 34
84512: PUSH
84513: LD_INT 31
84515: PUSH
84516: EMPTY
84517: LIST
84518: LIST
84519: PUSH
84520: LD_INT 34
84522: PUSH
84523: LD_INT 48
84525: PUSH
84526: EMPTY
84527: LIST
84528: LIST
84529: PUSH
84530: LD_INT 34
84532: PUSH
84533: LD_INT 8
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: PUSH
84540: EMPTY
84541: LIST
84542: LIST
84543: LIST
84544: LIST
84545: LIST
84546: LIST
84547: LIST
84548: LIST
84549: LIST
84550: LIST
84551: LIST
84552: LIST
84553: LIST
84554: LIST
84555: PPUSH
84556: CALL_OW 72
84560: DIFF
84561: ST_TO_ADDR
// end ; end_of_file
84562: LD_VAR 0 3
84566: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
84567: LD_INT 0
84569: PPUSH
84570: PPUSH
84571: PPUSH
// if not mc_bases or not skirmish then
84572: LD_EXP 61
84576: NOT
84577: PUSH
84578: LD_EXP 59
84582: NOT
84583: OR
84584: IFFALSE 84588
// exit ;
84586: GO 84753
// for i = 1 to mc_bases do
84588: LD_ADDR_VAR 0 4
84592: PUSH
84593: DOUBLE
84594: LD_INT 1
84596: DEC
84597: ST_TO_ADDR
84598: LD_EXP 61
84602: PUSH
84603: FOR_TO
84604: IFFALSE 84751
// begin if sci in mc_bases [ i ] then
84606: LD_VAR 0 2
84610: PUSH
84611: LD_EXP 61
84615: PUSH
84616: LD_VAR 0 4
84620: ARRAY
84621: IN
84622: IFFALSE 84749
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
84624: LD_ADDR_EXP 90
84628: PUSH
84629: LD_EXP 90
84633: PPUSH
84634: LD_VAR 0 4
84638: PUSH
84639: LD_EXP 90
84643: PUSH
84644: LD_VAR 0 4
84648: ARRAY
84649: PUSH
84650: LD_INT 1
84652: PLUS
84653: PUSH
84654: EMPTY
84655: LIST
84656: LIST
84657: PPUSH
84658: LD_VAR 0 1
84662: PPUSH
84663: CALL 21397 0 3
84667: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
84668: LD_ADDR_VAR 0 5
84672: PUSH
84673: LD_EXP 61
84677: PUSH
84678: LD_VAR 0 4
84682: ARRAY
84683: PPUSH
84684: LD_INT 2
84686: PUSH
84687: LD_INT 30
84689: PUSH
84690: LD_INT 0
84692: PUSH
84693: EMPTY
84694: LIST
84695: LIST
84696: PUSH
84697: LD_INT 30
84699: PUSH
84700: LD_INT 1
84702: PUSH
84703: EMPTY
84704: LIST
84705: LIST
84706: PUSH
84707: EMPTY
84708: LIST
84709: LIST
84710: LIST
84711: PPUSH
84712: CALL_OW 72
84716: PPUSH
84717: LD_VAR 0 1
84721: PPUSH
84722: CALL_OW 74
84726: ST_TO_ADDR
// if tmp then
84727: LD_VAR 0 5
84731: IFFALSE 84747
// ComStandNearbyBuilding ( ape , tmp ) ;
84733: LD_VAR 0 1
84737: PPUSH
84738: LD_VAR 0 5
84742: PPUSH
84743: CALL 17999 0 2
// break ;
84747: GO 84751
// end ; end ;
84749: GO 84603
84751: POP
84752: POP
// end ;
84753: LD_VAR 0 3
84757: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
84758: LD_INT 0
84760: PPUSH
84761: PPUSH
84762: PPUSH
// if not mc_bases or not skirmish then
84763: LD_EXP 61
84767: NOT
84768: PUSH
84769: LD_EXP 59
84773: NOT
84774: OR
84775: IFFALSE 84779
// exit ;
84777: GO 84868
// for i = 1 to mc_bases do
84779: LD_ADDR_VAR 0 4
84783: PUSH
84784: DOUBLE
84785: LD_INT 1
84787: DEC
84788: ST_TO_ADDR
84789: LD_EXP 61
84793: PUSH
84794: FOR_TO
84795: IFFALSE 84866
// begin if building in mc_busy_turret_list [ i ] then
84797: LD_VAR 0 1
84801: PUSH
84802: LD_EXP 71
84806: PUSH
84807: LD_VAR 0 4
84811: ARRAY
84812: IN
84813: IFFALSE 84864
// begin tmp := mc_busy_turret_list [ i ] diff building ;
84815: LD_ADDR_VAR 0 5
84819: PUSH
84820: LD_EXP 71
84824: PUSH
84825: LD_VAR 0 4
84829: ARRAY
84830: PUSH
84831: LD_VAR 0 1
84835: DIFF
84836: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
84837: LD_ADDR_EXP 71
84841: PUSH
84842: LD_EXP 71
84846: PPUSH
84847: LD_VAR 0 4
84851: PPUSH
84852: LD_VAR 0 5
84856: PPUSH
84857: CALL_OW 1
84861: ST_TO_ADDR
// break ;
84862: GO 84866
// end ; end ;
84864: GO 84794
84866: POP
84867: POP
// end ;
84868: LD_VAR 0 3
84872: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
84873: LD_INT 0
84875: PPUSH
84876: PPUSH
84877: PPUSH
// if not mc_bases or not skirmish then
84878: LD_EXP 61
84882: NOT
84883: PUSH
84884: LD_EXP 59
84888: NOT
84889: OR
84890: IFFALSE 84894
// exit ;
84892: GO 85093
// for i = 1 to mc_bases do
84894: LD_ADDR_VAR 0 5
84898: PUSH
84899: DOUBLE
84900: LD_INT 1
84902: DEC
84903: ST_TO_ADDR
84904: LD_EXP 61
84908: PUSH
84909: FOR_TO
84910: IFFALSE 85091
// if building in mc_bases [ i ] then
84912: LD_VAR 0 1
84916: PUSH
84917: LD_EXP 61
84921: PUSH
84922: LD_VAR 0 5
84926: ARRAY
84927: IN
84928: IFFALSE 85089
// begin tmp := mc_bases [ i ] diff building ;
84930: LD_ADDR_VAR 0 6
84934: PUSH
84935: LD_EXP 61
84939: PUSH
84940: LD_VAR 0 5
84944: ARRAY
84945: PUSH
84946: LD_VAR 0 1
84950: DIFF
84951: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
84952: LD_ADDR_EXP 61
84956: PUSH
84957: LD_EXP 61
84961: PPUSH
84962: LD_VAR 0 5
84966: PPUSH
84967: LD_VAR 0 6
84971: PPUSH
84972: CALL_OW 1
84976: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
84977: LD_VAR 0 1
84981: PUSH
84982: LD_EXP 69
84986: PUSH
84987: LD_VAR 0 5
84991: ARRAY
84992: IN
84993: IFFALSE 85032
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
84995: LD_ADDR_EXP 69
84999: PUSH
85000: LD_EXP 69
85004: PPUSH
85005: LD_VAR 0 5
85009: PPUSH
85010: LD_EXP 69
85014: PUSH
85015: LD_VAR 0 5
85019: ARRAY
85020: PUSH
85021: LD_VAR 0 1
85025: DIFF
85026: PPUSH
85027: CALL_OW 1
85031: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
85032: LD_VAR 0 1
85036: PUSH
85037: LD_EXP 70
85041: PUSH
85042: LD_VAR 0 5
85046: ARRAY
85047: IN
85048: IFFALSE 85087
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
85050: LD_ADDR_EXP 70
85054: PUSH
85055: LD_EXP 70
85059: PPUSH
85060: LD_VAR 0 5
85064: PPUSH
85065: LD_EXP 70
85069: PUSH
85070: LD_VAR 0 5
85074: ARRAY
85075: PUSH
85076: LD_VAR 0 1
85080: DIFF
85081: PPUSH
85082: CALL_OW 1
85086: ST_TO_ADDR
// break ;
85087: GO 85091
// end ;
85089: GO 84909
85091: POP
85092: POP
// end ;
85093: LD_VAR 0 4
85097: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
85098: LD_INT 0
85100: PPUSH
85101: PPUSH
85102: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
85103: LD_EXP 61
85107: NOT
85108: PUSH
85109: LD_EXP 59
85113: NOT
85114: OR
85115: PUSH
85116: LD_VAR 0 3
85120: PUSH
85121: LD_EXP 87
85125: IN
85126: NOT
85127: OR
85128: IFFALSE 85132
// exit ;
85130: GO 85255
// for i = 1 to mc_vehicles do
85132: LD_ADDR_VAR 0 6
85136: PUSH
85137: DOUBLE
85138: LD_INT 1
85140: DEC
85141: ST_TO_ADDR
85142: LD_EXP 80
85146: PUSH
85147: FOR_TO
85148: IFFALSE 85253
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
85150: LD_VAR 0 2
85154: PUSH
85155: LD_EXP 80
85159: PUSH
85160: LD_VAR 0 6
85164: ARRAY
85165: IN
85166: PUSH
85167: LD_VAR 0 1
85171: PUSH
85172: LD_EXP 80
85176: PUSH
85177: LD_VAR 0 6
85181: ARRAY
85182: IN
85183: OR
85184: IFFALSE 85251
// begin tmp := mc_vehicles [ i ] diff old ;
85186: LD_ADDR_VAR 0 7
85190: PUSH
85191: LD_EXP 80
85195: PUSH
85196: LD_VAR 0 6
85200: ARRAY
85201: PUSH
85202: LD_VAR 0 2
85206: DIFF
85207: ST_TO_ADDR
// tmp := tmp diff new ;
85208: LD_ADDR_VAR 0 7
85212: PUSH
85213: LD_VAR 0 7
85217: PUSH
85218: LD_VAR 0 1
85222: DIFF
85223: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
85224: LD_ADDR_EXP 80
85228: PUSH
85229: LD_EXP 80
85233: PPUSH
85234: LD_VAR 0 6
85238: PPUSH
85239: LD_VAR 0 7
85243: PPUSH
85244: CALL_OW 1
85248: ST_TO_ADDR
// break ;
85249: GO 85253
// end ;
85251: GO 85147
85253: POP
85254: POP
// end ;
85255: LD_VAR 0 5
85259: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
85260: LD_INT 0
85262: PPUSH
85263: PPUSH
85264: PPUSH
85265: PPUSH
// if not mc_bases or not skirmish then
85266: LD_EXP 61
85270: NOT
85271: PUSH
85272: LD_EXP 59
85276: NOT
85277: OR
85278: IFFALSE 85282
// exit ;
85280: GO 85702
// repeat wait ( 0 0$1 ) ;
85282: LD_INT 35
85284: PPUSH
85285: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
85289: LD_EXP 105
85293: NOT
85294: IFFALSE 85282
// mc_block_vehicle_constructed_thread := true ;
85296: LD_ADDR_EXP 105
85300: PUSH
85301: LD_INT 1
85303: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
85304: LD_ADDR_VAR 0 5
85308: PUSH
85309: LD_VAR 0 1
85313: PPUSH
85314: CALL_OW 255
85318: ST_TO_ADDR
// for i = 1 to mc_bases do
85319: LD_ADDR_VAR 0 4
85323: PUSH
85324: DOUBLE
85325: LD_INT 1
85327: DEC
85328: ST_TO_ADDR
85329: LD_EXP 61
85333: PUSH
85334: FOR_TO
85335: IFFALSE 85692
// begin if factory in mc_bases [ i ] then
85337: LD_VAR 0 2
85341: PUSH
85342: LD_EXP 61
85346: PUSH
85347: LD_VAR 0 4
85351: ARRAY
85352: IN
85353: IFFALSE 85690
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
85355: LD_EXP 83
85359: PUSH
85360: LD_VAR 0 4
85364: ARRAY
85365: PUSH
85366: LD_EXP 72
85370: PUSH
85371: LD_VAR 0 4
85375: ARRAY
85376: LESS
85377: PUSH
85378: LD_VAR 0 1
85382: PPUSH
85383: CALL_OW 264
85387: PUSH
85388: LD_INT 31
85390: PUSH
85391: LD_INT 32
85393: PUSH
85394: LD_INT 51
85396: PUSH
85397: LD_INT 89
85399: PUSH
85400: LD_INT 12
85402: PUSH
85403: LD_INT 30
85405: PUSH
85406: LD_INT 98
85408: PUSH
85409: LD_INT 11
85411: PUSH
85412: LD_INT 53
85414: PUSH
85415: LD_INT 14
85417: PUSH
85418: LD_INT 91
85420: PUSH
85421: LD_INT 29
85423: PUSH
85424: LD_INT 99
85426: PUSH
85427: LD_INT 13
85429: PUSH
85430: LD_INT 52
85432: PUSH
85433: LD_INT 88
85435: PUSH
85436: LD_INT 48
85438: PUSH
85439: LD_INT 8
85441: PUSH
85442: EMPTY
85443: LIST
85444: LIST
85445: LIST
85446: LIST
85447: LIST
85448: LIST
85449: LIST
85450: LIST
85451: LIST
85452: LIST
85453: LIST
85454: LIST
85455: LIST
85456: LIST
85457: LIST
85458: LIST
85459: LIST
85460: LIST
85461: IN
85462: NOT
85463: AND
85464: IFFALSE 85512
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
85466: LD_ADDR_EXP 83
85470: PUSH
85471: LD_EXP 83
85475: PPUSH
85476: LD_VAR 0 4
85480: PUSH
85481: LD_EXP 83
85485: PUSH
85486: LD_VAR 0 4
85490: ARRAY
85491: PUSH
85492: LD_INT 1
85494: PLUS
85495: PUSH
85496: EMPTY
85497: LIST
85498: LIST
85499: PPUSH
85500: LD_VAR 0 1
85504: PPUSH
85505: CALL 21397 0 3
85509: ST_TO_ADDR
85510: GO 85556
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
85512: LD_ADDR_EXP 80
85516: PUSH
85517: LD_EXP 80
85521: PPUSH
85522: LD_VAR 0 4
85526: PUSH
85527: LD_EXP 80
85531: PUSH
85532: LD_VAR 0 4
85536: ARRAY
85537: PUSH
85538: LD_INT 1
85540: PLUS
85541: PUSH
85542: EMPTY
85543: LIST
85544: LIST
85545: PPUSH
85546: LD_VAR 0 1
85550: PPUSH
85551: CALL 21397 0 3
85555: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
85556: LD_ADDR_EXP 105
85560: PUSH
85561: LD_INT 0
85563: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
85564: LD_VAR 0 1
85568: PPUSH
85569: CALL_OW 263
85573: PUSH
85574: LD_INT 2
85576: EQUAL
85577: IFFALSE 85606
// begin repeat wait ( 0 0$3 ) ;
85579: LD_INT 105
85581: PPUSH
85582: CALL_OW 67
// Connect ( vehicle ) ;
85586: LD_VAR 0 1
85590: PPUSH
85591: CALL 24743 0 1
// until IsControledBy ( vehicle ) ;
85595: LD_VAR 0 1
85599: PPUSH
85600: CALL_OW 312
85604: IFFALSE 85579
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
85606: LD_VAR 0 1
85610: PPUSH
85611: LD_EXP 85
85615: PUSH
85616: LD_VAR 0 4
85620: ARRAY
85621: PPUSH
85622: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
85626: LD_VAR 0 1
85630: PPUSH
85631: CALL_OW 263
85635: PUSH
85636: LD_INT 1
85638: NONEQUAL
85639: IFFALSE 85643
// break ;
85641: GO 85692
// repeat wait ( 0 0$1 ) ;
85643: LD_INT 35
85645: PPUSH
85646: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
85650: LD_VAR 0 1
85654: PPUSH
85655: LD_EXP 85
85659: PUSH
85660: LD_VAR 0 4
85664: ARRAY
85665: PPUSH
85666: CALL_OW 308
85670: IFFALSE 85643
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
85672: LD_VAR 0 1
85676: PPUSH
85677: CALL_OW 311
85681: PPUSH
85682: CALL_OW 121
// exit ;
85686: POP
85687: POP
85688: GO 85702
// end ; end ;
85690: GO 85334
85692: POP
85693: POP
// mc_block_vehicle_constructed_thread := false ;
85694: LD_ADDR_EXP 105
85698: PUSH
85699: LD_INT 0
85701: ST_TO_ADDR
// end ;
85702: LD_VAR 0 3
85706: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
85707: LD_INT 0
85709: PPUSH
85710: PPUSH
85711: PPUSH
85712: PPUSH
// if not mc_bases or not skirmish then
85713: LD_EXP 61
85717: NOT
85718: PUSH
85719: LD_EXP 59
85723: NOT
85724: OR
85725: IFFALSE 85729
// exit ;
85727: GO 86082
// repeat wait ( 0 0$1 ) ;
85729: LD_INT 35
85731: PPUSH
85732: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
85736: LD_VAR 0 2
85740: PPUSH
85741: LD_VAR 0 3
85745: PPUSH
85746: CALL_OW 284
85750: IFFALSE 85729
// if GetResourceTypeXY ( x , y ) = mat_artefact then
85752: LD_VAR 0 2
85756: PPUSH
85757: LD_VAR 0 3
85761: PPUSH
85762: CALL_OW 283
85766: PUSH
85767: LD_INT 4
85769: EQUAL
85770: IFFALSE 85774
// exit ;
85772: GO 86082
// for i = 1 to mc_bases do
85774: LD_ADDR_VAR 0 7
85778: PUSH
85779: DOUBLE
85780: LD_INT 1
85782: DEC
85783: ST_TO_ADDR
85784: LD_EXP 61
85788: PUSH
85789: FOR_TO
85790: IFFALSE 86080
// begin if mc_crates_area [ i ] then
85792: LD_EXP 79
85796: PUSH
85797: LD_VAR 0 7
85801: ARRAY
85802: IFFALSE 85913
// for j in mc_crates_area [ i ] do
85804: LD_ADDR_VAR 0 8
85808: PUSH
85809: LD_EXP 79
85813: PUSH
85814: LD_VAR 0 7
85818: ARRAY
85819: PUSH
85820: FOR_IN
85821: IFFALSE 85911
// if InArea ( x , y , j ) then
85823: LD_VAR 0 2
85827: PPUSH
85828: LD_VAR 0 3
85832: PPUSH
85833: LD_VAR 0 8
85837: PPUSH
85838: CALL_OW 309
85842: IFFALSE 85909
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
85844: LD_ADDR_EXP 77
85848: PUSH
85849: LD_EXP 77
85853: PPUSH
85854: LD_VAR 0 7
85858: PUSH
85859: LD_EXP 77
85863: PUSH
85864: LD_VAR 0 7
85868: ARRAY
85869: PUSH
85870: LD_INT 1
85872: PLUS
85873: PUSH
85874: EMPTY
85875: LIST
85876: LIST
85877: PPUSH
85878: LD_VAR 0 4
85882: PUSH
85883: LD_VAR 0 2
85887: PUSH
85888: LD_VAR 0 3
85892: PUSH
85893: EMPTY
85894: LIST
85895: LIST
85896: LIST
85897: PPUSH
85898: CALL 21397 0 3
85902: ST_TO_ADDR
// exit ;
85903: POP
85904: POP
85905: POP
85906: POP
85907: GO 86082
// end ;
85909: GO 85820
85911: POP
85912: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85913: LD_ADDR_VAR 0 9
85917: PUSH
85918: LD_EXP 61
85922: PUSH
85923: LD_VAR 0 7
85927: ARRAY
85928: PPUSH
85929: LD_INT 2
85931: PUSH
85932: LD_INT 30
85934: PUSH
85935: LD_INT 0
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: PUSH
85942: LD_INT 30
85944: PUSH
85945: LD_INT 1
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: PUSH
85952: EMPTY
85953: LIST
85954: LIST
85955: LIST
85956: PPUSH
85957: CALL_OW 72
85961: ST_TO_ADDR
// if not depot then
85962: LD_VAR 0 9
85966: NOT
85967: IFFALSE 85971
// continue ;
85969: GO 85789
// for j in depot do
85971: LD_ADDR_VAR 0 8
85975: PUSH
85976: LD_VAR 0 9
85980: PUSH
85981: FOR_IN
85982: IFFALSE 86076
// if GetDistUnitXY ( j , x , y ) < 30 then
85984: LD_VAR 0 8
85988: PPUSH
85989: LD_VAR 0 2
85993: PPUSH
85994: LD_VAR 0 3
85998: PPUSH
85999: CALL_OW 297
86003: PUSH
86004: LD_INT 30
86006: LESS
86007: IFFALSE 86074
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
86009: LD_ADDR_EXP 77
86013: PUSH
86014: LD_EXP 77
86018: PPUSH
86019: LD_VAR 0 7
86023: PUSH
86024: LD_EXP 77
86028: PUSH
86029: LD_VAR 0 7
86033: ARRAY
86034: PUSH
86035: LD_INT 1
86037: PLUS
86038: PUSH
86039: EMPTY
86040: LIST
86041: LIST
86042: PPUSH
86043: LD_VAR 0 4
86047: PUSH
86048: LD_VAR 0 2
86052: PUSH
86053: LD_VAR 0 3
86057: PUSH
86058: EMPTY
86059: LIST
86060: LIST
86061: LIST
86062: PPUSH
86063: CALL 21397 0 3
86067: ST_TO_ADDR
// exit ;
86068: POP
86069: POP
86070: POP
86071: POP
86072: GO 86082
// end ;
86074: GO 85981
86076: POP
86077: POP
// end ;
86078: GO 85789
86080: POP
86081: POP
// end ;
86082: LD_VAR 0 6
86086: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
86087: LD_INT 0
86089: PPUSH
86090: PPUSH
86091: PPUSH
86092: PPUSH
// if not mc_bases or not skirmish then
86093: LD_EXP 61
86097: NOT
86098: PUSH
86099: LD_EXP 59
86103: NOT
86104: OR
86105: IFFALSE 86109
// exit ;
86107: GO 86386
// side := GetSide ( lab ) ;
86109: LD_ADDR_VAR 0 4
86113: PUSH
86114: LD_VAR 0 2
86118: PPUSH
86119: CALL_OW 255
86123: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
86124: LD_VAR 0 4
86128: PUSH
86129: LD_EXP 87
86133: IN
86134: NOT
86135: PUSH
86136: LD_EXP 88
86140: NOT
86141: OR
86142: PUSH
86143: LD_EXP 61
86147: NOT
86148: OR
86149: IFFALSE 86153
// exit ;
86151: GO 86386
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
86153: LD_ADDR_EXP 88
86157: PUSH
86158: LD_EXP 88
86162: PPUSH
86163: LD_VAR 0 4
86167: PPUSH
86168: LD_EXP 88
86172: PUSH
86173: LD_VAR 0 4
86177: ARRAY
86178: PUSH
86179: LD_VAR 0 1
86183: DIFF
86184: PPUSH
86185: CALL_OW 1
86189: ST_TO_ADDR
// for i = 1 to mc_bases do
86190: LD_ADDR_VAR 0 5
86194: PUSH
86195: DOUBLE
86196: LD_INT 1
86198: DEC
86199: ST_TO_ADDR
86200: LD_EXP 61
86204: PUSH
86205: FOR_TO
86206: IFFALSE 86384
// begin if lab in mc_bases [ i ] then
86208: LD_VAR 0 2
86212: PUSH
86213: LD_EXP 61
86217: PUSH
86218: LD_VAR 0 5
86222: ARRAY
86223: IN
86224: IFFALSE 86382
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
86226: LD_VAR 0 1
86230: PUSH
86231: LD_INT 11
86233: PUSH
86234: LD_INT 4
86236: PUSH
86237: LD_INT 3
86239: PUSH
86240: LD_INT 2
86242: PUSH
86243: EMPTY
86244: LIST
86245: LIST
86246: LIST
86247: LIST
86248: IN
86249: PUSH
86250: LD_EXP 91
86254: PUSH
86255: LD_VAR 0 5
86259: ARRAY
86260: AND
86261: IFFALSE 86382
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
86263: LD_ADDR_VAR 0 6
86267: PUSH
86268: LD_EXP 91
86272: PUSH
86273: LD_VAR 0 5
86277: ARRAY
86278: PUSH
86279: LD_INT 1
86281: ARRAY
86282: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
86283: LD_ADDR_EXP 91
86287: PUSH
86288: LD_EXP 91
86292: PPUSH
86293: LD_VAR 0 5
86297: PPUSH
86298: EMPTY
86299: PPUSH
86300: CALL_OW 1
86304: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
86305: LD_VAR 0 6
86309: PPUSH
86310: LD_INT 0
86312: PPUSH
86313: CALL_OW 109
// ComExitBuilding ( tmp ) ;
86317: LD_VAR 0 6
86321: PPUSH
86322: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
86326: LD_ADDR_EXP 90
86330: PUSH
86331: LD_EXP 90
86335: PPUSH
86336: LD_VAR 0 5
86340: PPUSH
86341: LD_EXP 90
86345: PUSH
86346: LD_VAR 0 5
86350: ARRAY
86351: PPUSH
86352: LD_INT 1
86354: PPUSH
86355: LD_VAR 0 6
86359: PPUSH
86360: CALL_OW 2
86364: PPUSH
86365: CALL_OW 1
86369: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
86370: LD_VAR 0 5
86374: PPUSH
86375: LD_INT 112
86377: PPUSH
86378: CALL 62836 0 2
// end ; end ; end ;
86382: GO 86205
86384: POP
86385: POP
// end ;
86386: LD_VAR 0 3
86390: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
86391: LD_INT 0
86393: PPUSH
86394: PPUSH
86395: PPUSH
86396: PPUSH
86397: PPUSH
86398: PPUSH
86399: PPUSH
86400: PPUSH
// if not mc_bases or not skirmish then
86401: LD_EXP 61
86405: NOT
86406: PUSH
86407: LD_EXP 59
86411: NOT
86412: OR
86413: IFFALSE 86417
// exit ;
86415: GO 87786
// for i = 1 to mc_bases do
86417: LD_ADDR_VAR 0 3
86421: PUSH
86422: DOUBLE
86423: LD_INT 1
86425: DEC
86426: ST_TO_ADDR
86427: LD_EXP 61
86431: PUSH
86432: FOR_TO
86433: IFFALSE 87784
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
86435: LD_VAR 0 1
86439: PUSH
86440: LD_EXP 61
86444: PUSH
86445: LD_VAR 0 3
86449: ARRAY
86450: IN
86451: PUSH
86452: LD_VAR 0 1
86456: PUSH
86457: LD_EXP 68
86461: PUSH
86462: LD_VAR 0 3
86466: ARRAY
86467: IN
86468: OR
86469: PUSH
86470: LD_VAR 0 1
86474: PUSH
86475: LD_EXP 83
86479: PUSH
86480: LD_VAR 0 3
86484: ARRAY
86485: IN
86486: OR
86487: PUSH
86488: LD_VAR 0 1
86492: PUSH
86493: LD_EXP 80
86497: PUSH
86498: LD_VAR 0 3
86502: ARRAY
86503: IN
86504: OR
86505: PUSH
86506: LD_VAR 0 1
86510: PUSH
86511: LD_EXP 90
86515: PUSH
86516: LD_VAR 0 3
86520: ARRAY
86521: IN
86522: OR
86523: PUSH
86524: LD_VAR 0 1
86528: PUSH
86529: LD_EXP 91
86533: PUSH
86534: LD_VAR 0 3
86538: ARRAY
86539: IN
86540: OR
86541: IFFALSE 87782
// begin if un in mc_ape [ i ] then
86543: LD_VAR 0 1
86547: PUSH
86548: LD_EXP 90
86552: PUSH
86553: LD_VAR 0 3
86557: ARRAY
86558: IN
86559: IFFALSE 86598
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
86561: LD_ADDR_EXP 90
86565: PUSH
86566: LD_EXP 90
86570: PPUSH
86571: LD_VAR 0 3
86575: PPUSH
86576: LD_EXP 90
86580: PUSH
86581: LD_VAR 0 3
86585: ARRAY
86586: PUSH
86587: LD_VAR 0 1
86591: DIFF
86592: PPUSH
86593: CALL_OW 1
86597: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
86598: LD_VAR 0 1
86602: PUSH
86603: LD_EXP 91
86607: PUSH
86608: LD_VAR 0 3
86612: ARRAY
86613: IN
86614: IFFALSE 86638
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
86616: LD_ADDR_EXP 91
86620: PUSH
86621: LD_EXP 91
86625: PPUSH
86626: LD_VAR 0 3
86630: PPUSH
86631: EMPTY
86632: PPUSH
86633: CALL_OW 1
86637: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
86638: LD_VAR 0 1
86642: PPUSH
86643: CALL_OW 247
86647: PUSH
86648: LD_INT 2
86650: EQUAL
86651: PUSH
86652: LD_VAR 0 1
86656: PPUSH
86657: CALL_OW 110
86661: PUSH
86662: LD_INT 20
86664: EQUAL
86665: PUSH
86666: LD_VAR 0 1
86670: PUSH
86671: LD_EXP 83
86675: PUSH
86676: LD_VAR 0 3
86680: ARRAY
86681: IN
86682: OR
86683: PUSH
86684: LD_VAR 0 1
86688: PPUSH
86689: CALL_OW 264
86693: PUSH
86694: LD_INT 12
86696: PUSH
86697: LD_INT 51
86699: PUSH
86700: LD_INT 89
86702: PUSH
86703: LD_INT 32
86705: PUSH
86706: LD_INT 13
86708: PUSH
86709: LD_INT 52
86711: PUSH
86712: LD_INT 31
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: LIST
86719: LIST
86720: LIST
86721: LIST
86722: LIST
86723: IN
86724: OR
86725: AND
86726: IFFALSE 87034
// begin if un in mc_defender [ i ] then
86728: LD_VAR 0 1
86732: PUSH
86733: LD_EXP 83
86737: PUSH
86738: LD_VAR 0 3
86742: ARRAY
86743: IN
86744: IFFALSE 86783
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
86746: LD_ADDR_EXP 83
86750: PUSH
86751: LD_EXP 83
86755: PPUSH
86756: LD_VAR 0 3
86760: PPUSH
86761: LD_EXP 83
86765: PUSH
86766: LD_VAR 0 3
86770: ARRAY
86771: PUSH
86772: LD_VAR 0 1
86776: DIFF
86777: PPUSH
86778: CALL_OW 1
86782: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
86783: LD_ADDR_VAR 0 8
86787: PUSH
86788: LD_VAR 0 3
86792: PPUSH
86793: LD_INT 3
86795: PPUSH
86796: CALL 83404 0 2
86800: ST_TO_ADDR
// if fac then
86801: LD_VAR 0 8
86805: IFFALSE 87034
// begin for j in fac do
86807: LD_ADDR_VAR 0 4
86811: PUSH
86812: LD_VAR 0 8
86816: PUSH
86817: FOR_IN
86818: IFFALSE 87032
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
86820: LD_ADDR_VAR 0 9
86824: PUSH
86825: LD_VAR 0 8
86829: PPUSH
86830: LD_VAR 0 1
86834: PPUSH
86835: CALL_OW 265
86839: PPUSH
86840: LD_VAR 0 1
86844: PPUSH
86845: CALL_OW 262
86849: PPUSH
86850: LD_VAR 0 1
86854: PPUSH
86855: CALL_OW 263
86859: PPUSH
86860: LD_VAR 0 1
86864: PPUSH
86865: CALL_OW 264
86869: PPUSH
86870: CALL 18895 0 5
86874: ST_TO_ADDR
// if components then
86875: LD_VAR 0 9
86879: IFFALSE 87030
// begin if GetWeapon ( un ) = ar_control_tower then
86881: LD_VAR 0 1
86885: PPUSH
86886: CALL_OW 264
86890: PUSH
86891: LD_INT 31
86893: EQUAL
86894: IFFALSE 87011
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
86896: LD_VAR 0 1
86900: PPUSH
86901: CALL_OW 311
86905: PPUSH
86906: LD_INT 0
86908: PPUSH
86909: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
86913: LD_ADDR_EXP 101
86917: PUSH
86918: LD_EXP 101
86922: PPUSH
86923: LD_VAR 0 3
86927: PPUSH
86928: LD_EXP 101
86932: PUSH
86933: LD_VAR 0 3
86937: ARRAY
86938: PUSH
86939: LD_VAR 0 1
86943: PPUSH
86944: CALL_OW 311
86948: DIFF
86949: PPUSH
86950: CALL_OW 1
86954: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
86955: LD_ADDR_VAR 0 7
86959: PUSH
86960: LD_EXP 82
86964: PUSH
86965: LD_VAR 0 3
86969: ARRAY
86970: PPUSH
86971: LD_INT 1
86973: PPUSH
86974: LD_VAR 0 9
86978: PPUSH
86979: CALL_OW 2
86983: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
86984: LD_ADDR_EXP 82
86988: PUSH
86989: LD_EXP 82
86993: PPUSH
86994: LD_VAR 0 3
86998: PPUSH
86999: LD_VAR 0 7
87003: PPUSH
87004: CALL_OW 1
87008: ST_TO_ADDR
// end else
87009: GO 87028
// MC_InsertProduceList ( i , [ components ] ) ;
87011: LD_VAR 0 3
87015: PPUSH
87016: LD_VAR 0 9
87020: PUSH
87021: EMPTY
87022: LIST
87023: PPUSH
87024: CALL 82949 0 2
// break ;
87028: GO 87032
// end ; end ;
87030: GO 86817
87032: POP
87033: POP
// end ; end ; if GetType ( un ) = unit_building then
87034: LD_VAR 0 1
87038: PPUSH
87039: CALL_OW 247
87043: PUSH
87044: LD_INT 3
87046: EQUAL
87047: IFFALSE 87450
// begin btype := GetBType ( un ) ;
87049: LD_ADDR_VAR 0 5
87053: PUSH
87054: LD_VAR 0 1
87058: PPUSH
87059: CALL_OW 266
87063: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
87064: LD_VAR 0 5
87068: PUSH
87069: LD_INT 29
87071: PUSH
87072: LD_INT 30
87074: PUSH
87075: EMPTY
87076: LIST
87077: LIST
87078: IN
87079: IFFALSE 87152
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
87081: LD_VAR 0 1
87085: PPUSH
87086: CALL_OW 250
87090: PPUSH
87091: LD_VAR 0 1
87095: PPUSH
87096: CALL_OW 251
87100: PPUSH
87101: LD_VAR 0 1
87105: PPUSH
87106: CALL_OW 255
87110: PPUSH
87111: CALL_OW 440
87115: NOT
87116: IFFALSE 87152
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
87118: LD_VAR 0 1
87122: PPUSH
87123: CALL_OW 250
87127: PPUSH
87128: LD_VAR 0 1
87132: PPUSH
87133: CALL_OW 251
87137: PPUSH
87138: LD_VAR 0 1
87142: PPUSH
87143: CALL_OW 255
87147: PPUSH
87148: CALL_OW 441
// end ; if btype = b_warehouse then
87152: LD_VAR 0 5
87156: PUSH
87157: LD_INT 1
87159: EQUAL
87160: IFFALSE 87178
// begin btype := b_depot ;
87162: LD_ADDR_VAR 0 5
87166: PUSH
87167: LD_INT 0
87169: ST_TO_ADDR
// pos := 1 ;
87170: LD_ADDR_VAR 0 6
87174: PUSH
87175: LD_INT 1
87177: ST_TO_ADDR
// end ; if btype = b_factory then
87178: LD_VAR 0 5
87182: PUSH
87183: LD_INT 3
87185: EQUAL
87186: IFFALSE 87204
// begin btype := b_workshop ;
87188: LD_ADDR_VAR 0 5
87192: PUSH
87193: LD_INT 2
87195: ST_TO_ADDR
// pos := 1 ;
87196: LD_ADDR_VAR 0 6
87200: PUSH
87201: LD_INT 1
87203: ST_TO_ADDR
// end ; if btype = b_barracks then
87204: LD_VAR 0 5
87208: PUSH
87209: LD_INT 5
87211: EQUAL
87212: IFFALSE 87222
// btype := b_armoury ;
87214: LD_ADDR_VAR 0 5
87218: PUSH
87219: LD_INT 4
87221: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
87222: LD_VAR 0 5
87226: PUSH
87227: LD_INT 7
87229: PUSH
87230: LD_INT 8
87232: PUSH
87233: EMPTY
87234: LIST
87235: LIST
87236: IN
87237: IFFALSE 87247
// btype := b_lab ;
87239: LD_ADDR_VAR 0 5
87243: PUSH
87244: LD_INT 6
87246: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
87247: LD_ADDR_EXP 66
87251: PUSH
87252: LD_EXP 66
87256: PPUSH
87257: LD_VAR 0 3
87261: PUSH
87262: LD_EXP 66
87266: PUSH
87267: LD_VAR 0 3
87271: ARRAY
87272: PUSH
87273: LD_INT 1
87275: PLUS
87276: PUSH
87277: EMPTY
87278: LIST
87279: LIST
87280: PPUSH
87281: LD_VAR 0 5
87285: PUSH
87286: LD_VAR 0 1
87290: PPUSH
87291: CALL_OW 250
87295: PUSH
87296: LD_VAR 0 1
87300: PPUSH
87301: CALL_OW 251
87305: PUSH
87306: LD_VAR 0 1
87310: PPUSH
87311: CALL_OW 254
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: LIST
87320: LIST
87321: PPUSH
87322: CALL 21397 0 3
87326: ST_TO_ADDR
// if pos = 1 then
87327: LD_VAR 0 6
87331: PUSH
87332: LD_INT 1
87334: EQUAL
87335: IFFALSE 87450
// begin tmp := mc_build_list [ i ] ;
87337: LD_ADDR_VAR 0 7
87341: PUSH
87342: LD_EXP 66
87346: PUSH
87347: LD_VAR 0 3
87351: ARRAY
87352: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
87353: LD_VAR 0 7
87357: PPUSH
87358: LD_INT 2
87360: PUSH
87361: LD_INT 30
87363: PUSH
87364: LD_INT 0
87366: PUSH
87367: EMPTY
87368: LIST
87369: LIST
87370: PUSH
87371: LD_INT 30
87373: PUSH
87374: LD_INT 1
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: PUSH
87381: EMPTY
87382: LIST
87383: LIST
87384: LIST
87385: PPUSH
87386: CALL_OW 72
87390: IFFALSE 87400
// pos := 2 ;
87392: LD_ADDR_VAR 0 6
87396: PUSH
87397: LD_INT 2
87399: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
87400: LD_ADDR_VAR 0 7
87404: PUSH
87405: LD_VAR 0 7
87409: PPUSH
87410: LD_VAR 0 6
87414: PPUSH
87415: LD_VAR 0 7
87419: PPUSH
87420: CALL 21723 0 3
87424: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
87425: LD_ADDR_EXP 66
87429: PUSH
87430: LD_EXP 66
87434: PPUSH
87435: LD_VAR 0 3
87439: PPUSH
87440: LD_VAR 0 7
87444: PPUSH
87445: CALL_OW 1
87449: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
87450: LD_VAR 0 1
87454: PUSH
87455: LD_EXP 61
87459: PUSH
87460: LD_VAR 0 3
87464: ARRAY
87465: IN
87466: IFFALSE 87505
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
87468: LD_ADDR_EXP 61
87472: PUSH
87473: LD_EXP 61
87477: PPUSH
87478: LD_VAR 0 3
87482: PPUSH
87483: LD_EXP 61
87487: PUSH
87488: LD_VAR 0 3
87492: ARRAY
87493: PUSH
87494: LD_VAR 0 1
87498: DIFF
87499: PPUSH
87500: CALL_OW 1
87504: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
87505: LD_VAR 0 1
87509: PUSH
87510: LD_EXP 68
87514: PUSH
87515: LD_VAR 0 3
87519: ARRAY
87520: IN
87521: IFFALSE 87560
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
87523: LD_ADDR_EXP 68
87527: PUSH
87528: LD_EXP 68
87532: PPUSH
87533: LD_VAR 0 3
87537: PPUSH
87538: LD_EXP 68
87542: PUSH
87543: LD_VAR 0 3
87547: ARRAY
87548: PUSH
87549: LD_VAR 0 1
87553: DIFF
87554: PPUSH
87555: CALL_OW 1
87559: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
87560: LD_VAR 0 1
87564: PUSH
87565: LD_EXP 80
87569: PUSH
87570: LD_VAR 0 3
87574: ARRAY
87575: IN
87576: IFFALSE 87615
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
87578: LD_ADDR_EXP 80
87582: PUSH
87583: LD_EXP 80
87587: PPUSH
87588: LD_VAR 0 3
87592: PPUSH
87593: LD_EXP 80
87597: PUSH
87598: LD_VAR 0 3
87602: ARRAY
87603: PUSH
87604: LD_VAR 0 1
87608: DIFF
87609: PPUSH
87610: CALL_OW 1
87614: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
87615: LD_VAR 0 1
87619: PUSH
87620: LD_EXP 83
87624: PUSH
87625: LD_VAR 0 3
87629: ARRAY
87630: IN
87631: IFFALSE 87670
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
87633: LD_ADDR_EXP 83
87637: PUSH
87638: LD_EXP 83
87642: PPUSH
87643: LD_VAR 0 3
87647: PPUSH
87648: LD_EXP 83
87652: PUSH
87653: LD_VAR 0 3
87657: ARRAY
87658: PUSH
87659: LD_VAR 0 1
87663: DIFF
87664: PPUSH
87665: CALL_OW 1
87669: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
87670: LD_VAR 0 1
87674: PUSH
87675: LD_EXP 70
87679: PUSH
87680: LD_VAR 0 3
87684: ARRAY
87685: IN
87686: IFFALSE 87725
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
87688: LD_ADDR_EXP 70
87692: PUSH
87693: LD_EXP 70
87697: PPUSH
87698: LD_VAR 0 3
87702: PPUSH
87703: LD_EXP 70
87707: PUSH
87708: LD_VAR 0 3
87712: ARRAY
87713: PUSH
87714: LD_VAR 0 1
87718: DIFF
87719: PPUSH
87720: CALL_OW 1
87724: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
87725: LD_VAR 0 1
87729: PUSH
87730: LD_EXP 69
87734: PUSH
87735: LD_VAR 0 3
87739: ARRAY
87740: IN
87741: IFFALSE 87780
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
87743: LD_ADDR_EXP 69
87747: PUSH
87748: LD_EXP 69
87752: PPUSH
87753: LD_VAR 0 3
87757: PPUSH
87758: LD_EXP 69
87762: PUSH
87763: LD_VAR 0 3
87767: ARRAY
87768: PUSH
87769: LD_VAR 0 1
87773: DIFF
87774: PPUSH
87775: CALL_OW 1
87779: ST_TO_ADDR
// end ; break ;
87780: GO 87784
// end ;
87782: GO 86432
87784: POP
87785: POP
// end ;
87786: LD_VAR 0 2
87790: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
87791: LD_INT 0
87793: PPUSH
87794: PPUSH
87795: PPUSH
// if not mc_bases or not skirmish then
87796: LD_EXP 61
87800: NOT
87801: PUSH
87802: LD_EXP 59
87806: NOT
87807: OR
87808: IFFALSE 87812
// exit ;
87810: GO 88027
// for i = 1 to mc_bases do
87812: LD_ADDR_VAR 0 3
87816: PUSH
87817: DOUBLE
87818: LD_INT 1
87820: DEC
87821: ST_TO_ADDR
87822: LD_EXP 61
87826: PUSH
87827: FOR_TO
87828: IFFALSE 88025
// begin if building in mc_construct_list [ i ] then
87830: LD_VAR 0 1
87834: PUSH
87835: LD_EXP 68
87839: PUSH
87840: LD_VAR 0 3
87844: ARRAY
87845: IN
87846: IFFALSE 88023
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
87848: LD_ADDR_EXP 68
87852: PUSH
87853: LD_EXP 68
87857: PPUSH
87858: LD_VAR 0 3
87862: PPUSH
87863: LD_EXP 68
87867: PUSH
87868: LD_VAR 0 3
87872: ARRAY
87873: PUSH
87874: LD_VAR 0 1
87878: DIFF
87879: PPUSH
87880: CALL_OW 1
87884: ST_TO_ADDR
// if building in mc_lab [ i ] then
87885: LD_VAR 0 1
87889: PUSH
87890: LD_EXP 94
87894: PUSH
87895: LD_VAR 0 3
87899: ARRAY
87900: IN
87901: IFFALSE 87956
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
87903: LD_ADDR_EXP 95
87907: PUSH
87908: LD_EXP 95
87912: PPUSH
87913: LD_VAR 0 3
87917: PPUSH
87918: LD_EXP 95
87922: PUSH
87923: LD_VAR 0 3
87927: ARRAY
87928: PPUSH
87929: LD_INT 1
87931: PPUSH
87932: LD_EXP 95
87936: PUSH
87937: LD_VAR 0 3
87941: ARRAY
87942: PPUSH
87943: LD_INT 0
87945: PPUSH
87946: CALL 20815 0 4
87950: PPUSH
87951: CALL_OW 1
87955: ST_TO_ADDR
// if not building in mc_bases [ i ] then
87956: LD_VAR 0 1
87960: PUSH
87961: LD_EXP 61
87965: PUSH
87966: LD_VAR 0 3
87970: ARRAY
87971: IN
87972: NOT
87973: IFFALSE 88019
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
87975: LD_ADDR_EXP 61
87979: PUSH
87980: LD_EXP 61
87984: PPUSH
87985: LD_VAR 0 3
87989: PUSH
87990: LD_EXP 61
87994: PUSH
87995: LD_VAR 0 3
87999: ARRAY
88000: PUSH
88001: LD_INT 1
88003: PLUS
88004: PUSH
88005: EMPTY
88006: LIST
88007: LIST
88008: PPUSH
88009: LD_VAR 0 1
88013: PPUSH
88014: CALL 21397 0 3
88018: ST_TO_ADDR
// exit ;
88019: POP
88020: POP
88021: GO 88027
// end ; end ;
88023: GO 87827
88025: POP
88026: POP
// end ;
88027: LD_VAR 0 2
88031: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
88032: LD_INT 0
88034: PPUSH
88035: PPUSH
88036: PPUSH
88037: PPUSH
88038: PPUSH
88039: PPUSH
88040: PPUSH
// if not mc_bases or not skirmish then
88041: LD_EXP 61
88045: NOT
88046: PUSH
88047: LD_EXP 59
88051: NOT
88052: OR
88053: IFFALSE 88057
// exit ;
88055: GO 88718
// for i = 1 to mc_bases do
88057: LD_ADDR_VAR 0 3
88061: PUSH
88062: DOUBLE
88063: LD_INT 1
88065: DEC
88066: ST_TO_ADDR
88067: LD_EXP 61
88071: PUSH
88072: FOR_TO
88073: IFFALSE 88716
// begin if building in mc_construct_list [ i ] then
88075: LD_VAR 0 1
88079: PUSH
88080: LD_EXP 68
88084: PUSH
88085: LD_VAR 0 3
88089: ARRAY
88090: IN
88091: IFFALSE 88714
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
88093: LD_ADDR_EXP 68
88097: PUSH
88098: LD_EXP 68
88102: PPUSH
88103: LD_VAR 0 3
88107: PPUSH
88108: LD_EXP 68
88112: PUSH
88113: LD_VAR 0 3
88117: ARRAY
88118: PUSH
88119: LD_VAR 0 1
88123: DIFF
88124: PPUSH
88125: CALL_OW 1
88129: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
88130: LD_ADDR_EXP 61
88134: PUSH
88135: LD_EXP 61
88139: PPUSH
88140: LD_VAR 0 3
88144: PUSH
88145: LD_EXP 61
88149: PUSH
88150: LD_VAR 0 3
88154: ARRAY
88155: PUSH
88156: LD_INT 1
88158: PLUS
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: PPUSH
88164: LD_VAR 0 1
88168: PPUSH
88169: CALL 21397 0 3
88173: ST_TO_ADDR
// btype := GetBType ( building ) ;
88174: LD_ADDR_VAR 0 5
88178: PUSH
88179: LD_VAR 0 1
88183: PPUSH
88184: CALL_OW 266
88188: ST_TO_ADDR
// side := GetSide ( building ) ;
88189: LD_ADDR_VAR 0 8
88193: PUSH
88194: LD_VAR 0 1
88198: PPUSH
88199: CALL_OW 255
88203: ST_TO_ADDR
// if btype = b_lab then
88204: LD_VAR 0 5
88208: PUSH
88209: LD_INT 6
88211: EQUAL
88212: IFFALSE 88262
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
88214: LD_ADDR_EXP 94
88218: PUSH
88219: LD_EXP 94
88223: PPUSH
88224: LD_VAR 0 3
88228: PUSH
88229: LD_EXP 94
88233: PUSH
88234: LD_VAR 0 3
88238: ARRAY
88239: PUSH
88240: LD_INT 1
88242: PLUS
88243: PUSH
88244: EMPTY
88245: LIST
88246: LIST
88247: PPUSH
88248: LD_VAR 0 1
88252: PPUSH
88253: CALL 21397 0 3
88257: ST_TO_ADDR
// exit ;
88258: POP
88259: POP
88260: GO 88718
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
88262: LD_VAR 0 5
88266: PUSH
88267: LD_INT 0
88269: PUSH
88270: LD_INT 2
88272: PUSH
88273: LD_INT 4
88275: PUSH
88276: EMPTY
88277: LIST
88278: LIST
88279: LIST
88280: IN
88281: IFFALSE 88405
// begin if btype = b_armoury then
88283: LD_VAR 0 5
88287: PUSH
88288: LD_INT 4
88290: EQUAL
88291: IFFALSE 88301
// btype := b_barracks ;
88293: LD_ADDR_VAR 0 5
88297: PUSH
88298: LD_INT 5
88300: ST_TO_ADDR
// if btype = b_depot then
88301: LD_VAR 0 5
88305: PUSH
88306: LD_INT 0
88308: EQUAL
88309: IFFALSE 88319
// btype := b_warehouse ;
88311: LD_ADDR_VAR 0 5
88315: PUSH
88316: LD_INT 1
88318: ST_TO_ADDR
// if btype = b_workshop then
88319: LD_VAR 0 5
88323: PUSH
88324: LD_INT 2
88326: EQUAL
88327: IFFALSE 88337
// btype := b_factory ;
88329: LD_ADDR_VAR 0 5
88333: PUSH
88334: LD_INT 3
88336: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
88337: LD_VAR 0 5
88341: PPUSH
88342: LD_VAR 0 8
88346: PPUSH
88347: CALL_OW 323
88351: PUSH
88352: LD_INT 1
88354: EQUAL
88355: IFFALSE 88401
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
88357: LD_ADDR_EXP 93
88361: PUSH
88362: LD_EXP 93
88366: PPUSH
88367: LD_VAR 0 3
88371: PUSH
88372: LD_EXP 93
88376: PUSH
88377: LD_VAR 0 3
88381: ARRAY
88382: PUSH
88383: LD_INT 1
88385: PLUS
88386: PUSH
88387: EMPTY
88388: LIST
88389: LIST
88390: PPUSH
88391: LD_VAR 0 1
88395: PPUSH
88396: CALL 21397 0 3
88400: ST_TO_ADDR
// exit ;
88401: POP
88402: POP
88403: GO 88718
// end ; if btype in [ b_bunker , b_turret ] then
88405: LD_VAR 0 5
88409: PUSH
88410: LD_INT 32
88412: PUSH
88413: LD_INT 33
88415: PUSH
88416: EMPTY
88417: LIST
88418: LIST
88419: IN
88420: IFFALSE 88710
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
88422: LD_ADDR_EXP 69
88426: PUSH
88427: LD_EXP 69
88431: PPUSH
88432: LD_VAR 0 3
88436: PUSH
88437: LD_EXP 69
88441: PUSH
88442: LD_VAR 0 3
88446: ARRAY
88447: PUSH
88448: LD_INT 1
88450: PLUS
88451: PUSH
88452: EMPTY
88453: LIST
88454: LIST
88455: PPUSH
88456: LD_VAR 0 1
88460: PPUSH
88461: CALL 21397 0 3
88465: ST_TO_ADDR
// if btype = b_bunker then
88466: LD_VAR 0 5
88470: PUSH
88471: LD_INT 32
88473: EQUAL
88474: IFFALSE 88710
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
88476: LD_ADDR_EXP 70
88480: PUSH
88481: LD_EXP 70
88485: PPUSH
88486: LD_VAR 0 3
88490: PUSH
88491: LD_EXP 70
88495: PUSH
88496: LD_VAR 0 3
88500: ARRAY
88501: PUSH
88502: LD_INT 1
88504: PLUS
88505: PUSH
88506: EMPTY
88507: LIST
88508: LIST
88509: PPUSH
88510: LD_VAR 0 1
88514: PPUSH
88515: CALL 21397 0 3
88519: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
88520: LD_ADDR_VAR 0 6
88524: PUSH
88525: LD_EXP 61
88529: PUSH
88530: LD_VAR 0 3
88534: ARRAY
88535: PPUSH
88536: LD_INT 25
88538: PUSH
88539: LD_INT 1
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: PUSH
88546: LD_INT 3
88548: PUSH
88549: LD_INT 54
88551: PUSH
88552: EMPTY
88553: LIST
88554: PUSH
88555: EMPTY
88556: LIST
88557: LIST
88558: PUSH
88559: EMPTY
88560: LIST
88561: LIST
88562: PPUSH
88563: CALL_OW 72
88567: ST_TO_ADDR
// if tmp then
88568: LD_VAR 0 6
88572: IFFALSE 88578
// exit ;
88574: POP
88575: POP
88576: GO 88718
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
88578: LD_ADDR_VAR 0 6
88582: PUSH
88583: LD_EXP 61
88587: PUSH
88588: LD_VAR 0 3
88592: ARRAY
88593: PPUSH
88594: LD_INT 2
88596: PUSH
88597: LD_INT 30
88599: PUSH
88600: LD_INT 4
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 30
88609: PUSH
88610: LD_INT 5
88612: PUSH
88613: EMPTY
88614: LIST
88615: LIST
88616: PUSH
88617: EMPTY
88618: LIST
88619: LIST
88620: LIST
88621: PPUSH
88622: CALL_OW 72
88626: ST_TO_ADDR
// if not tmp then
88627: LD_VAR 0 6
88631: NOT
88632: IFFALSE 88638
// exit ;
88634: POP
88635: POP
88636: GO 88718
// for j in tmp do
88638: LD_ADDR_VAR 0 4
88642: PUSH
88643: LD_VAR 0 6
88647: PUSH
88648: FOR_IN
88649: IFFALSE 88708
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
88651: LD_ADDR_VAR 0 7
88655: PUSH
88656: LD_VAR 0 4
88660: PPUSH
88661: CALL_OW 313
88665: PPUSH
88666: LD_INT 25
88668: PUSH
88669: LD_INT 1
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: PPUSH
88676: CALL_OW 72
88680: ST_TO_ADDR
// if units then
88681: LD_VAR 0 7
88685: IFFALSE 88706
// begin ComExitBuilding ( units [ 1 ] ) ;
88687: LD_VAR 0 7
88691: PUSH
88692: LD_INT 1
88694: ARRAY
88695: PPUSH
88696: CALL_OW 122
// exit ;
88700: POP
88701: POP
88702: POP
88703: POP
88704: GO 88718
// end ; end ;
88706: GO 88648
88708: POP
88709: POP
// end ; end ; exit ;
88710: POP
88711: POP
88712: GO 88718
// end ; end ;
88714: GO 88072
88716: POP
88717: POP
// end ;
88718: LD_VAR 0 2
88722: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
88723: LD_INT 0
88725: PPUSH
88726: PPUSH
88727: PPUSH
88728: PPUSH
88729: PPUSH
88730: PPUSH
88731: PPUSH
// if not mc_bases or not skirmish then
88732: LD_EXP 61
88736: NOT
88737: PUSH
88738: LD_EXP 59
88742: NOT
88743: OR
88744: IFFALSE 88748
// exit ;
88746: GO 89013
// btype := GetBType ( building ) ;
88748: LD_ADDR_VAR 0 6
88752: PUSH
88753: LD_VAR 0 1
88757: PPUSH
88758: CALL_OW 266
88762: ST_TO_ADDR
// x := GetX ( building ) ;
88763: LD_ADDR_VAR 0 7
88767: PUSH
88768: LD_VAR 0 1
88772: PPUSH
88773: CALL_OW 250
88777: ST_TO_ADDR
// y := GetY ( building ) ;
88778: LD_ADDR_VAR 0 8
88782: PUSH
88783: LD_VAR 0 1
88787: PPUSH
88788: CALL_OW 251
88792: ST_TO_ADDR
// d := GetDir ( building ) ;
88793: LD_ADDR_VAR 0 9
88797: PUSH
88798: LD_VAR 0 1
88802: PPUSH
88803: CALL_OW 254
88807: ST_TO_ADDR
// for i = 1 to mc_bases do
88808: LD_ADDR_VAR 0 4
88812: PUSH
88813: DOUBLE
88814: LD_INT 1
88816: DEC
88817: ST_TO_ADDR
88818: LD_EXP 61
88822: PUSH
88823: FOR_TO
88824: IFFALSE 89011
// begin if not mc_build_list [ i ] then
88826: LD_EXP 66
88830: PUSH
88831: LD_VAR 0 4
88835: ARRAY
88836: NOT
88837: IFFALSE 88841
// continue ;
88839: GO 88823
// for j := 1 to mc_build_list [ i ] do
88841: LD_ADDR_VAR 0 5
88845: PUSH
88846: DOUBLE
88847: LD_INT 1
88849: DEC
88850: ST_TO_ADDR
88851: LD_EXP 66
88855: PUSH
88856: LD_VAR 0 4
88860: ARRAY
88861: PUSH
88862: FOR_TO
88863: IFFALSE 89007
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
88865: LD_VAR 0 6
88869: PUSH
88870: LD_VAR 0 7
88874: PUSH
88875: LD_VAR 0 8
88879: PUSH
88880: LD_VAR 0 9
88884: PUSH
88885: EMPTY
88886: LIST
88887: LIST
88888: LIST
88889: LIST
88890: PPUSH
88891: LD_EXP 66
88895: PUSH
88896: LD_VAR 0 4
88900: ARRAY
88901: PUSH
88902: LD_VAR 0 5
88906: ARRAY
88907: PPUSH
88908: CALL 27954 0 2
88912: IFFALSE 89005
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
88914: LD_ADDR_EXP 66
88918: PUSH
88919: LD_EXP 66
88923: PPUSH
88924: LD_VAR 0 4
88928: PPUSH
88929: LD_EXP 66
88933: PUSH
88934: LD_VAR 0 4
88938: ARRAY
88939: PPUSH
88940: LD_VAR 0 5
88944: PPUSH
88945: CALL_OW 3
88949: PPUSH
88950: CALL_OW 1
88954: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
88955: LD_ADDR_EXP 68
88959: PUSH
88960: LD_EXP 68
88964: PPUSH
88965: LD_VAR 0 4
88969: PUSH
88970: LD_EXP 68
88974: PUSH
88975: LD_VAR 0 4
88979: ARRAY
88980: PUSH
88981: LD_INT 1
88983: PLUS
88984: PUSH
88985: EMPTY
88986: LIST
88987: LIST
88988: PPUSH
88989: LD_VAR 0 1
88993: PPUSH
88994: CALL 21397 0 3
88998: ST_TO_ADDR
// exit ;
88999: POP
89000: POP
89001: POP
89002: POP
89003: GO 89013
// end ;
89005: GO 88862
89007: POP
89008: POP
// end ;
89009: GO 88823
89011: POP
89012: POP
// end ;
89013: LD_VAR 0 3
89017: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
89018: LD_INT 0
89020: PPUSH
89021: PPUSH
89022: PPUSH
// if not mc_bases or not skirmish then
89023: LD_EXP 61
89027: NOT
89028: PUSH
89029: LD_EXP 59
89033: NOT
89034: OR
89035: IFFALSE 89039
// exit ;
89037: GO 89229
// for i = 1 to mc_bases do
89039: LD_ADDR_VAR 0 4
89043: PUSH
89044: DOUBLE
89045: LD_INT 1
89047: DEC
89048: ST_TO_ADDR
89049: LD_EXP 61
89053: PUSH
89054: FOR_TO
89055: IFFALSE 89142
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
89057: LD_VAR 0 1
89061: PUSH
89062: LD_EXP 69
89066: PUSH
89067: LD_VAR 0 4
89071: ARRAY
89072: IN
89073: PUSH
89074: LD_VAR 0 1
89078: PUSH
89079: LD_EXP 70
89083: PUSH
89084: LD_VAR 0 4
89088: ARRAY
89089: IN
89090: NOT
89091: AND
89092: IFFALSE 89140
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
89094: LD_ADDR_EXP 70
89098: PUSH
89099: LD_EXP 70
89103: PPUSH
89104: LD_VAR 0 4
89108: PUSH
89109: LD_EXP 70
89113: PUSH
89114: LD_VAR 0 4
89118: ARRAY
89119: PUSH
89120: LD_INT 1
89122: PLUS
89123: PUSH
89124: EMPTY
89125: LIST
89126: LIST
89127: PPUSH
89128: LD_VAR 0 1
89132: PPUSH
89133: CALL 21397 0 3
89137: ST_TO_ADDR
// break ;
89138: GO 89142
// end ; end ;
89140: GO 89054
89142: POP
89143: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
89144: LD_VAR 0 1
89148: PPUSH
89149: CALL_OW 257
89153: PUSH
89154: LD_EXP 87
89158: IN
89159: PUSH
89160: LD_VAR 0 1
89164: PPUSH
89165: CALL_OW 266
89169: PUSH
89170: LD_INT 5
89172: EQUAL
89173: AND
89174: PUSH
89175: LD_VAR 0 2
89179: PPUSH
89180: CALL_OW 110
89184: PUSH
89185: LD_INT 18
89187: NONEQUAL
89188: AND
89189: IFFALSE 89229
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
89191: LD_VAR 0 2
89195: PPUSH
89196: CALL_OW 257
89200: PUSH
89201: LD_INT 5
89203: PUSH
89204: LD_INT 8
89206: PUSH
89207: LD_INT 9
89209: PUSH
89210: EMPTY
89211: LIST
89212: LIST
89213: LIST
89214: IN
89215: IFFALSE 89229
// SetClass ( unit , 1 ) ;
89217: LD_VAR 0 2
89221: PPUSH
89222: LD_INT 1
89224: PPUSH
89225: CALL_OW 336
// end ;
89229: LD_VAR 0 3
89233: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
89234: LD_INT 0
89236: PPUSH
89237: PPUSH
// if not mc_bases or not skirmish then
89238: LD_EXP 61
89242: NOT
89243: PUSH
89244: LD_EXP 59
89248: NOT
89249: OR
89250: IFFALSE 89254
// exit ;
89252: GO 89370
// if GetLives ( abandoned_vehicle ) > 250 then
89254: LD_VAR 0 2
89258: PPUSH
89259: CALL_OW 256
89263: PUSH
89264: LD_INT 250
89266: GREATER
89267: IFFALSE 89271
// exit ;
89269: GO 89370
// for i = 1 to mc_bases do
89271: LD_ADDR_VAR 0 6
89275: PUSH
89276: DOUBLE
89277: LD_INT 1
89279: DEC
89280: ST_TO_ADDR
89281: LD_EXP 61
89285: PUSH
89286: FOR_TO
89287: IFFALSE 89368
// begin if driver in mc_bases [ i ] then
89289: LD_VAR 0 1
89293: PUSH
89294: LD_EXP 61
89298: PUSH
89299: LD_VAR 0 6
89303: ARRAY
89304: IN
89305: IFFALSE 89366
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
89307: LD_VAR 0 1
89311: PPUSH
89312: LD_EXP 61
89316: PUSH
89317: LD_VAR 0 6
89321: ARRAY
89322: PPUSH
89323: LD_INT 2
89325: PUSH
89326: LD_INT 30
89328: PUSH
89329: LD_INT 0
89331: PUSH
89332: EMPTY
89333: LIST
89334: LIST
89335: PUSH
89336: LD_INT 30
89338: PUSH
89339: LD_INT 1
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PUSH
89346: EMPTY
89347: LIST
89348: LIST
89349: LIST
89350: PPUSH
89351: CALL_OW 72
89355: PUSH
89356: LD_INT 1
89358: ARRAY
89359: PPUSH
89360: CALL 55014 0 2
// break ;
89364: GO 89368
// end ; end ;
89366: GO 89286
89368: POP
89369: POP
// end ; end_of_file end_of_file
89370: LD_VAR 0 5
89374: RET
// export globalGameSaveCounter ; every 0 0$1 do
89375: GO 89377
89377: DISABLE
// begin enable ;
89378: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
89379: LD_STRING updateTimer(
89381: PUSH
89382: LD_OWVAR 1
89386: STR
89387: PUSH
89388: LD_STRING );
89390: STR
89391: PPUSH
89392: CALL_OW 559
// end ;
89396: END
// every 0 0$1 do
89397: GO 89399
89399: DISABLE
// begin globalGameSaveCounter := 0 ;
89400: LD_ADDR_EXP 106
89404: PUSH
89405: LD_INT 0
89407: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
89408: LD_STRING setGameSaveCounter(0)
89410: PPUSH
89411: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
89415: LD_STRING initStreamRollete();
89417: PPUSH
89418: CALL_OW 559
// InitStreamMode ;
89422: CALL 90748 0 0
// DefineStreamItems ( false ) ;
89426: LD_INT 0
89428: PPUSH
89429: CALL 91212 0 1
// end ;
89433: END
// export function SOS_MapStart ( ) ; begin
89434: LD_INT 0
89436: PPUSH
// if streamModeActive then
89437: LD_EXP 107
89441: IFFALSE 89450
// DefineStreamItems ( true ) ;
89443: LD_INT 1
89445: PPUSH
89446: CALL 91212 0 1
// UpdateLuaVariables ( ) ;
89450: CALL 89467 0 0
// UpdateFactoryWaypoints ( ) ;
89454: CALL 104081 0 0
// UpdateWarehouseGatheringPoints ( ) ;
89458: CALL 104338 0 0
// end ;
89462: LD_VAR 0 1
89466: RET
// function UpdateLuaVariables ( ) ; begin
89467: LD_INT 0
89469: PPUSH
// if globalGameSaveCounter then
89470: LD_EXP 106
89474: IFFALSE 89508
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
89476: LD_ADDR_EXP 106
89480: PUSH
89481: LD_EXP 106
89485: PPUSH
89486: CALL 55498 0 1
89490: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
89491: LD_STRING setGameSaveCounter(
89493: PUSH
89494: LD_EXP 106
89498: STR
89499: PUSH
89500: LD_STRING )
89502: STR
89503: PPUSH
89504: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
89508: LD_STRING setGameDifficulty(
89510: PUSH
89511: LD_OWVAR 67
89515: STR
89516: PUSH
89517: LD_STRING )
89519: STR
89520: PPUSH
89521: CALL_OW 559
// end ;
89525: LD_VAR 0 1
89529: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
89530: LD_INT 0
89532: PPUSH
// if p2 = stream_mode then
89533: LD_VAR 0 2
89537: PUSH
89538: LD_INT 100
89540: EQUAL
89541: IFFALSE 90544
// begin if not StreamModeActive then
89543: LD_EXP 107
89547: NOT
89548: IFFALSE 89558
// StreamModeActive := true ;
89550: LD_ADDR_EXP 107
89554: PUSH
89555: LD_INT 1
89557: ST_TO_ADDR
// if p3 = 0 then
89558: LD_VAR 0 3
89562: PUSH
89563: LD_INT 0
89565: EQUAL
89566: IFFALSE 89572
// InitStreamMode ;
89568: CALL 90748 0 0
// if p3 = 1 then
89572: LD_VAR 0 3
89576: PUSH
89577: LD_INT 1
89579: EQUAL
89580: IFFALSE 89590
// sRocket := true ;
89582: LD_ADDR_EXP 112
89586: PUSH
89587: LD_INT 1
89589: ST_TO_ADDR
// if p3 = 2 then
89590: LD_VAR 0 3
89594: PUSH
89595: LD_INT 2
89597: EQUAL
89598: IFFALSE 89608
// sSpeed := true ;
89600: LD_ADDR_EXP 111
89604: PUSH
89605: LD_INT 1
89607: ST_TO_ADDR
// if p3 = 3 then
89608: LD_VAR 0 3
89612: PUSH
89613: LD_INT 3
89615: EQUAL
89616: IFFALSE 89626
// sEngine := true ;
89618: LD_ADDR_EXP 113
89622: PUSH
89623: LD_INT 1
89625: ST_TO_ADDR
// if p3 = 4 then
89626: LD_VAR 0 3
89630: PUSH
89631: LD_INT 4
89633: EQUAL
89634: IFFALSE 89644
// sSpec := true ;
89636: LD_ADDR_EXP 110
89640: PUSH
89641: LD_INT 1
89643: ST_TO_ADDR
// if p3 = 5 then
89644: LD_VAR 0 3
89648: PUSH
89649: LD_INT 5
89651: EQUAL
89652: IFFALSE 89662
// sLevel := true ;
89654: LD_ADDR_EXP 114
89658: PUSH
89659: LD_INT 1
89661: ST_TO_ADDR
// if p3 = 6 then
89662: LD_VAR 0 3
89666: PUSH
89667: LD_INT 6
89669: EQUAL
89670: IFFALSE 89680
// sArmoury := true ;
89672: LD_ADDR_EXP 115
89676: PUSH
89677: LD_INT 1
89679: ST_TO_ADDR
// if p3 = 7 then
89680: LD_VAR 0 3
89684: PUSH
89685: LD_INT 7
89687: EQUAL
89688: IFFALSE 89698
// sRadar := true ;
89690: LD_ADDR_EXP 116
89694: PUSH
89695: LD_INT 1
89697: ST_TO_ADDR
// if p3 = 8 then
89698: LD_VAR 0 3
89702: PUSH
89703: LD_INT 8
89705: EQUAL
89706: IFFALSE 89716
// sBunker := true ;
89708: LD_ADDR_EXP 117
89712: PUSH
89713: LD_INT 1
89715: ST_TO_ADDR
// if p3 = 9 then
89716: LD_VAR 0 3
89720: PUSH
89721: LD_INT 9
89723: EQUAL
89724: IFFALSE 89734
// sHack := true ;
89726: LD_ADDR_EXP 118
89730: PUSH
89731: LD_INT 1
89733: ST_TO_ADDR
// if p3 = 10 then
89734: LD_VAR 0 3
89738: PUSH
89739: LD_INT 10
89741: EQUAL
89742: IFFALSE 89752
// sFire := true ;
89744: LD_ADDR_EXP 119
89748: PUSH
89749: LD_INT 1
89751: ST_TO_ADDR
// if p3 = 11 then
89752: LD_VAR 0 3
89756: PUSH
89757: LD_INT 11
89759: EQUAL
89760: IFFALSE 89770
// sRefresh := true ;
89762: LD_ADDR_EXP 120
89766: PUSH
89767: LD_INT 1
89769: ST_TO_ADDR
// if p3 = 12 then
89770: LD_VAR 0 3
89774: PUSH
89775: LD_INT 12
89777: EQUAL
89778: IFFALSE 89788
// sExp := true ;
89780: LD_ADDR_EXP 121
89784: PUSH
89785: LD_INT 1
89787: ST_TO_ADDR
// if p3 = 13 then
89788: LD_VAR 0 3
89792: PUSH
89793: LD_INT 13
89795: EQUAL
89796: IFFALSE 89806
// sDepot := true ;
89798: LD_ADDR_EXP 122
89802: PUSH
89803: LD_INT 1
89805: ST_TO_ADDR
// if p3 = 14 then
89806: LD_VAR 0 3
89810: PUSH
89811: LD_INT 14
89813: EQUAL
89814: IFFALSE 89824
// sFlag := true ;
89816: LD_ADDR_EXP 123
89820: PUSH
89821: LD_INT 1
89823: ST_TO_ADDR
// if p3 = 15 then
89824: LD_VAR 0 3
89828: PUSH
89829: LD_INT 15
89831: EQUAL
89832: IFFALSE 89842
// sKamikadze := true ;
89834: LD_ADDR_EXP 131
89838: PUSH
89839: LD_INT 1
89841: ST_TO_ADDR
// if p3 = 16 then
89842: LD_VAR 0 3
89846: PUSH
89847: LD_INT 16
89849: EQUAL
89850: IFFALSE 89860
// sTroll := true ;
89852: LD_ADDR_EXP 132
89856: PUSH
89857: LD_INT 1
89859: ST_TO_ADDR
// if p3 = 17 then
89860: LD_VAR 0 3
89864: PUSH
89865: LD_INT 17
89867: EQUAL
89868: IFFALSE 89878
// sSlow := true ;
89870: LD_ADDR_EXP 133
89874: PUSH
89875: LD_INT 1
89877: ST_TO_ADDR
// if p3 = 18 then
89878: LD_VAR 0 3
89882: PUSH
89883: LD_INT 18
89885: EQUAL
89886: IFFALSE 89896
// sLack := true ;
89888: LD_ADDR_EXP 134
89892: PUSH
89893: LD_INT 1
89895: ST_TO_ADDR
// if p3 = 19 then
89896: LD_VAR 0 3
89900: PUSH
89901: LD_INT 19
89903: EQUAL
89904: IFFALSE 89914
// sTank := true ;
89906: LD_ADDR_EXP 136
89910: PUSH
89911: LD_INT 1
89913: ST_TO_ADDR
// if p3 = 20 then
89914: LD_VAR 0 3
89918: PUSH
89919: LD_INT 20
89921: EQUAL
89922: IFFALSE 89932
// sRemote := true ;
89924: LD_ADDR_EXP 137
89928: PUSH
89929: LD_INT 1
89931: ST_TO_ADDR
// if p3 = 21 then
89932: LD_VAR 0 3
89936: PUSH
89937: LD_INT 21
89939: EQUAL
89940: IFFALSE 89950
// sPowell := true ;
89942: LD_ADDR_EXP 138
89946: PUSH
89947: LD_INT 1
89949: ST_TO_ADDR
// if p3 = 22 then
89950: LD_VAR 0 3
89954: PUSH
89955: LD_INT 22
89957: EQUAL
89958: IFFALSE 89968
// sTeleport := true ;
89960: LD_ADDR_EXP 141
89964: PUSH
89965: LD_INT 1
89967: ST_TO_ADDR
// if p3 = 23 then
89968: LD_VAR 0 3
89972: PUSH
89973: LD_INT 23
89975: EQUAL
89976: IFFALSE 89986
// sOilTower := true ;
89978: LD_ADDR_EXP 143
89982: PUSH
89983: LD_INT 1
89985: ST_TO_ADDR
// if p3 = 24 then
89986: LD_VAR 0 3
89990: PUSH
89991: LD_INT 24
89993: EQUAL
89994: IFFALSE 90004
// sShovel := true ;
89996: LD_ADDR_EXP 144
90000: PUSH
90001: LD_INT 1
90003: ST_TO_ADDR
// if p3 = 25 then
90004: LD_VAR 0 3
90008: PUSH
90009: LD_INT 25
90011: EQUAL
90012: IFFALSE 90022
// sSheik := true ;
90014: LD_ADDR_EXP 145
90018: PUSH
90019: LD_INT 1
90021: ST_TO_ADDR
// if p3 = 26 then
90022: LD_VAR 0 3
90026: PUSH
90027: LD_INT 26
90029: EQUAL
90030: IFFALSE 90040
// sEarthquake := true ;
90032: LD_ADDR_EXP 147
90036: PUSH
90037: LD_INT 1
90039: ST_TO_ADDR
// if p3 = 27 then
90040: LD_VAR 0 3
90044: PUSH
90045: LD_INT 27
90047: EQUAL
90048: IFFALSE 90058
// sAI := true ;
90050: LD_ADDR_EXP 148
90054: PUSH
90055: LD_INT 1
90057: ST_TO_ADDR
// if p3 = 28 then
90058: LD_VAR 0 3
90062: PUSH
90063: LD_INT 28
90065: EQUAL
90066: IFFALSE 90076
// sCargo := true ;
90068: LD_ADDR_EXP 151
90072: PUSH
90073: LD_INT 1
90075: ST_TO_ADDR
// if p3 = 29 then
90076: LD_VAR 0 3
90080: PUSH
90081: LD_INT 29
90083: EQUAL
90084: IFFALSE 90094
// sDLaser := true ;
90086: LD_ADDR_EXP 152
90090: PUSH
90091: LD_INT 1
90093: ST_TO_ADDR
// if p3 = 30 then
90094: LD_VAR 0 3
90098: PUSH
90099: LD_INT 30
90101: EQUAL
90102: IFFALSE 90112
// sExchange := true ;
90104: LD_ADDR_EXP 153
90108: PUSH
90109: LD_INT 1
90111: ST_TO_ADDR
// if p3 = 31 then
90112: LD_VAR 0 3
90116: PUSH
90117: LD_INT 31
90119: EQUAL
90120: IFFALSE 90130
// sFac := true ;
90122: LD_ADDR_EXP 154
90126: PUSH
90127: LD_INT 1
90129: ST_TO_ADDR
// if p3 = 32 then
90130: LD_VAR 0 3
90134: PUSH
90135: LD_INT 32
90137: EQUAL
90138: IFFALSE 90148
// sPower := true ;
90140: LD_ADDR_EXP 155
90144: PUSH
90145: LD_INT 1
90147: ST_TO_ADDR
// if p3 = 33 then
90148: LD_VAR 0 3
90152: PUSH
90153: LD_INT 33
90155: EQUAL
90156: IFFALSE 90166
// sRandom := true ;
90158: LD_ADDR_EXP 156
90162: PUSH
90163: LD_INT 1
90165: ST_TO_ADDR
// if p3 = 34 then
90166: LD_VAR 0 3
90170: PUSH
90171: LD_INT 34
90173: EQUAL
90174: IFFALSE 90184
// sShield := true ;
90176: LD_ADDR_EXP 157
90180: PUSH
90181: LD_INT 1
90183: ST_TO_ADDR
// if p3 = 35 then
90184: LD_VAR 0 3
90188: PUSH
90189: LD_INT 35
90191: EQUAL
90192: IFFALSE 90202
// sTime := true ;
90194: LD_ADDR_EXP 158
90198: PUSH
90199: LD_INT 1
90201: ST_TO_ADDR
// if p3 = 36 then
90202: LD_VAR 0 3
90206: PUSH
90207: LD_INT 36
90209: EQUAL
90210: IFFALSE 90220
// sTools := true ;
90212: LD_ADDR_EXP 159
90216: PUSH
90217: LD_INT 1
90219: ST_TO_ADDR
// if p3 = 101 then
90220: LD_VAR 0 3
90224: PUSH
90225: LD_INT 101
90227: EQUAL
90228: IFFALSE 90238
// sSold := true ;
90230: LD_ADDR_EXP 124
90234: PUSH
90235: LD_INT 1
90237: ST_TO_ADDR
// if p3 = 102 then
90238: LD_VAR 0 3
90242: PUSH
90243: LD_INT 102
90245: EQUAL
90246: IFFALSE 90256
// sDiff := true ;
90248: LD_ADDR_EXP 125
90252: PUSH
90253: LD_INT 1
90255: ST_TO_ADDR
// if p3 = 103 then
90256: LD_VAR 0 3
90260: PUSH
90261: LD_INT 103
90263: EQUAL
90264: IFFALSE 90274
// sFog := true ;
90266: LD_ADDR_EXP 128
90270: PUSH
90271: LD_INT 1
90273: ST_TO_ADDR
// if p3 = 104 then
90274: LD_VAR 0 3
90278: PUSH
90279: LD_INT 104
90281: EQUAL
90282: IFFALSE 90292
// sReset := true ;
90284: LD_ADDR_EXP 129
90288: PUSH
90289: LD_INT 1
90291: ST_TO_ADDR
// if p3 = 105 then
90292: LD_VAR 0 3
90296: PUSH
90297: LD_INT 105
90299: EQUAL
90300: IFFALSE 90310
// sSun := true ;
90302: LD_ADDR_EXP 130
90306: PUSH
90307: LD_INT 1
90309: ST_TO_ADDR
// if p3 = 106 then
90310: LD_VAR 0 3
90314: PUSH
90315: LD_INT 106
90317: EQUAL
90318: IFFALSE 90328
// sTiger := true ;
90320: LD_ADDR_EXP 126
90324: PUSH
90325: LD_INT 1
90327: ST_TO_ADDR
// if p3 = 107 then
90328: LD_VAR 0 3
90332: PUSH
90333: LD_INT 107
90335: EQUAL
90336: IFFALSE 90346
// sBomb := true ;
90338: LD_ADDR_EXP 127
90342: PUSH
90343: LD_INT 1
90345: ST_TO_ADDR
// if p3 = 108 then
90346: LD_VAR 0 3
90350: PUSH
90351: LD_INT 108
90353: EQUAL
90354: IFFALSE 90364
// sWound := true ;
90356: LD_ADDR_EXP 135
90360: PUSH
90361: LD_INT 1
90363: ST_TO_ADDR
// if p3 = 109 then
90364: LD_VAR 0 3
90368: PUSH
90369: LD_INT 109
90371: EQUAL
90372: IFFALSE 90382
// sBetray := true ;
90374: LD_ADDR_EXP 139
90378: PUSH
90379: LD_INT 1
90381: ST_TO_ADDR
// if p3 = 110 then
90382: LD_VAR 0 3
90386: PUSH
90387: LD_INT 110
90389: EQUAL
90390: IFFALSE 90400
// sContamin := true ;
90392: LD_ADDR_EXP 140
90396: PUSH
90397: LD_INT 1
90399: ST_TO_ADDR
// if p3 = 111 then
90400: LD_VAR 0 3
90404: PUSH
90405: LD_INT 111
90407: EQUAL
90408: IFFALSE 90418
// sOil := true ;
90410: LD_ADDR_EXP 142
90414: PUSH
90415: LD_INT 1
90417: ST_TO_ADDR
// if p3 = 112 then
90418: LD_VAR 0 3
90422: PUSH
90423: LD_INT 112
90425: EQUAL
90426: IFFALSE 90436
// sStu := true ;
90428: LD_ADDR_EXP 146
90432: PUSH
90433: LD_INT 1
90435: ST_TO_ADDR
// if p3 = 113 then
90436: LD_VAR 0 3
90440: PUSH
90441: LD_INT 113
90443: EQUAL
90444: IFFALSE 90454
// sBazooka := true ;
90446: LD_ADDR_EXP 149
90450: PUSH
90451: LD_INT 1
90453: ST_TO_ADDR
// if p3 = 114 then
90454: LD_VAR 0 3
90458: PUSH
90459: LD_INT 114
90461: EQUAL
90462: IFFALSE 90472
// sMortar := true ;
90464: LD_ADDR_EXP 150
90468: PUSH
90469: LD_INT 1
90471: ST_TO_ADDR
// if p3 = 115 then
90472: LD_VAR 0 3
90476: PUSH
90477: LD_INT 115
90479: EQUAL
90480: IFFALSE 90490
// sRanger := true ;
90482: LD_ADDR_EXP 160
90486: PUSH
90487: LD_INT 1
90489: ST_TO_ADDR
// if p3 = 116 then
90490: LD_VAR 0 3
90494: PUSH
90495: LD_INT 116
90497: EQUAL
90498: IFFALSE 90508
// sComputer := true ;
90500: LD_ADDR_EXP 161
90504: PUSH
90505: LD_INT 1
90507: ST_TO_ADDR
// if p3 = 117 then
90508: LD_VAR 0 3
90512: PUSH
90513: LD_INT 117
90515: EQUAL
90516: IFFALSE 90526
// s30 := true ;
90518: LD_ADDR_EXP 162
90522: PUSH
90523: LD_INT 1
90525: ST_TO_ADDR
// if p3 = 118 then
90526: LD_VAR 0 3
90530: PUSH
90531: LD_INT 118
90533: EQUAL
90534: IFFALSE 90544
// s60 := true ;
90536: LD_ADDR_EXP 163
90540: PUSH
90541: LD_INT 1
90543: ST_TO_ADDR
// end ; if p2 = hack_mode then
90544: LD_VAR 0 2
90548: PUSH
90549: LD_INT 101
90551: EQUAL
90552: IFFALSE 90680
// begin case p3 of 1 :
90554: LD_VAR 0 3
90558: PUSH
90559: LD_INT 1
90561: DOUBLE
90562: EQUAL
90563: IFTRUE 90567
90565: GO 90574
90567: POP
// hHackUnlimitedResources ; 2 :
90568: CALL 102827 0 0
90572: GO 90680
90574: LD_INT 2
90576: DOUBLE
90577: EQUAL
90578: IFTRUE 90582
90580: GO 90589
90582: POP
// hHackSetLevel10 ; 3 :
90583: CALL 102960 0 0
90587: GO 90680
90589: LD_INT 3
90591: DOUBLE
90592: EQUAL
90593: IFTRUE 90597
90595: GO 90604
90597: POP
// hHackSetLevel10YourUnits ; 4 :
90598: CALL 103045 0 0
90602: GO 90680
90604: LD_INT 4
90606: DOUBLE
90607: EQUAL
90608: IFTRUE 90612
90610: GO 90619
90612: POP
// hHackInvincible ; 5 :
90613: CALL 103493 0 0
90617: GO 90680
90619: LD_INT 5
90621: DOUBLE
90622: EQUAL
90623: IFTRUE 90627
90625: GO 90634
90627: POP
// hHackInvisible ; 6 :
90628: CALL 103604 0 0
90632: GO 90680
90634: LD_INT 6
90636: DOUBLE
90637: EQUAL
90638: IFTRUE 90642
90640: GO 90649
90642: POP
// hHackChangeYourSide ; 7 :
90643: CALL 103661 0 0
90647: GO 90680
90649: LD_INT 7
90651: DOUBLE
90652: EQUAL
90653: IFTRUE 90657
90655: GO 90664
90657: POP
// hHackChangeUnitSide ; 8 :
90658: CALL 103703 0 0
90662: GO 90680
90664: LD_INT 8
90666: DOUBLE
90667: EQUAL
90668: IFTRUE 90672
90670: GO 90679
90672: POP
// hHackFog ; end ;
90673: CALL 103804 0 0
90677: GO 90680
90679: POP
// end ; if p2 = game_save_mode then
90680: LD_VAR 0 2
90684: PUSH
90685: LD_INT 102
90687: EQUAL
90688: IFFALSE 90743
// begin if p3 = 1 then
90690: LD_VAR 0 3
90694: PUSH
90695: LD_INT 1
90697: EQUAL
90698: IFFALSE 90710
// globalGameSaveCounter := p4 ;
90700: LD_ADDR_EXP 106
90704: PUSH
90705: LD_VAR 0 4
90709: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
90710: LD_VAR 0 3
90714: PUSH
90715: LD_INT 2
90717: EQUAL
90718: PUSH
90719: LD_EXP 106
90723: AND
90724: IFFALSE 90743
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
90726: LD_STRING setGameSaveCounter(
90728: PUSH
90729: LD_EXP 106
90733: STR
90734: PUSH
90735: LD_STRING )
90737: STR
90738: PPUSH
90739: CALL_OW 559
// end ; end ;
90743: LD_VAR 0 7
90747: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
90748: LD_INT 0
90750: PPUSH
// streamModeActive := false ;
90751: LD_ADDR_EXP 107
90755: PUSH
90756: LD_INT 0
90758: ST_TO_ADDR
// normalCounter := 36 ;
90759: LD_ADDR_EXP 108
90763: PUSH
90764: LD_INT 36
90766: ST_TO_ADDR
// hardcoreCounter := 18 ;
90767: LD_ADDR_EXP 109
90771: PUSH
90772: LD_INT 18
90774: ST_TO_ADDR
// sRocket := false ;
90775: LD_ADDR_EXP 112
90779: PUSH
90780: LD_INT 0
90782: ST_TO_ADDR
// sSpeed := false ;
90783: LD_ADDR_EXP 111
90787: PUSH
90788: LD_INT 0
90790: ST_TO_ADDR
// sEngine := false ;
90791: LD_ADDR_EXP 113
90795: PUSH
90796: LD_INT 0
90798: ST_TO_ADDR
// sSpec := false ;
90799: LD_ADDR_EXP 110
90803: PUSH
90804: LD_INT 0
90806: ST_TO_ADDR
// sLevel := false ;
90807: LD_ADDR_EXP 114
90811: PUSH
90812: LD_INT 0
90814: ST_TO_ADDR
// sArmoury := false ;
90815: LD_ADDR_EXP 115
90819: PUSH
90820: LD_INT 0
90822: ST_TO_ADDR
// sRadar := false ;
90823: LD_ADDR_EXP 116
90827: PUSH
90828: LD_INT 0
90830: ST_TO_ADDR
// sBunker := false ;
90831: LD_ADDR_EXP 117
90835: PUSH
90836: LD_INT 0
90838: ST_TO_ADDR
// sHack := false ;
90839: LD_ADDR_EXP 118
90843: PUSH
90844: LD_INT 0
90846: ST_TO_ADDR
// sFire := false ;
90847: LD_ADDR_EXP 119
90851: PUSH
90852: LD_INT 0
90854: ST_TO_ADDR
// sRefresh := false ;
90855: LD_ADDR_EXP 120
90859: PUSH
90860: LD_INT 0
90862: ST_TO_ADDR
// sExp := false ;
90863: LD_ADDR_EXP 121
90867: PUSH
90868: LD_INT 0
90870: ST_TO_ADDR
// sDepot := false ;
90871: LD_ADDR_EXP 122
90875: PUSH
90876: LD_INT 0
90878: ST_TO_ADDR
// sFlag := false ;
90879: LD_ADDR_EXP 123
90883: PUSH
90884: LD_INT 0
90886: ST_TO_ADDR
// sKamikadze := false ;
90887: LD_ADDR_EXP 131
90891: PUSH
90892: LD_INT 0
90894: ST_TO_ADDR
// sTroll := false ;
90895: LD_ADDR_EXP 132
90899: PUSH
90900: LD_INT 0
90902: ST_TO_ADDR
// sSlow := false ;
90903: LD_ADDR_EXP 133
90907: PUSH
90908: LD_INT 0
90910: ST_TO_ADDR
// sLack := false ;
90911: LD_ADDR_EXP 134
90915: PUSH
90916: LD_INT 0
90918: ST_TO_ADDR
// sTank := false ;
90919: LD_ADDR_EXP 136
90923: PUSH
90924: LD_INT 0
90926: ST_TO_ADDR
// sRemote := false ;
90927: LD_ADDR_EXP 137
90931: PUSH
90932: LD_INT 0
90934: ST_TO_ADDR
// sPowell := false ;
90935: LD_ADDR_EXP 138
90939: PUSH
90940: LD_INT 0
90942: ST_TO_ADDR
// sTeleport := false ;
90943: LD_ADDR_EXP 141
90947: PUSH
90948: LD_INT 0
90950: ST_TO_ADDR
// sOilTower := false ;
90951: LD_ADDR_EXP 143
90955: PUSH
90956: LD_INT 0
90958: ST_TO_ADDR
// sShovel := false ;
90959: LD_ADDR_EXP 144
90963: PUSH
90964: LD_INT 0
90966: ST_TO_ADDR
// sSheik := false ;
90967: LD_ADDR_EXP 145
90971: PUSH
90972: LD_INT 0
90974: ST_TO_ADDR
// sEarthquake := false ;
90975: LD_ADDR_EXP 147
90979: PUSH
90980: LD_INT 0
90982: ST_TO_ADDR
// sAI := false ;
90983: LD_ADDR_EXP 148
90987: PUSH
90988: LD_INT 0
90990: ST_TO_ADDR
// sCargo := false ;
90991: LD_ADDR_EXP 151
90995: PUSH
90996: LD_INT 0
90998: ST_TO_ADDR
// sDLaser := false ;
90999: LD_ADDR_EXP 152
91003: PUSH
91004: LD_INT 0
91006: ST_TO_ADDR
// sExchange := false ;
91007: LD_ADDR_EXP 153
91011: PUSH
91012: LD_INT 0
91014: ST_TO_ADDR
// sFac := false ;
91015: LD_ADDR_EXP 154
91019: PUSH
91020: LD_INT 0
91022: ST_TO_ADDR
// sPower := false ;
91023: LD_ADDR_EXP 155
91027: PUSH
91028: LD_INT 0
91030: ST_TO_ADDR
// sRandom := false ;
91031: LD_ADDR_EXP 156
91035: PUSH
91036: LD_INT 0
91038: ST_TO_ADDR
// sShield := false ;
91039: LD_ADDR_EXP 157
91043: PUSH
91044: LD_INT 0
91046: ST_TO_ADDR
// sTime := false ;
91047: LD_ADDR_EXP 158
91051: PUSH
91052: LD_INT 0
91054: ST_TO_ADDR
// sTools := false ;
91055: LD_ADDR_EXP 159
91059: PUSH
91060: LD_INT 0
91062: ST_TO_ADDR
// sSold := false ;
91063: LD_ADDR_EXP 124
91067: PUSH
91068: LD_INT 0
91070: ST_TO_ADDR
// sDiff := false ;
91071: LD_ADDR_EXP 125
91075: PUSH
91076: LD_INT 0
91078: ST_TO_ADDR
// sFog := false ;
91079: LD_ADDR_EXP 128
91083: PUSH
91084: LD_INT 0
91086: ST_TO_ADDR
// sReset := false ;
91087: LD_ADDR_EXP 129
91091: PUSH
91092: LD_INT 0
91094: ST_TO_ADDR
// sSun := false ;
91095: LD_ADDR_EXP 130
91099: PUSH
91100: LD_INT 0
91102: ST_TO_ADDR
// sTiger := false ;
91103: LD_ADDR_EXP 126
91107: PUSH
91108: LD_INT 0
91110: ST_TO_ADDR
// sBomb := false ;
91111: LD_ADDR_EXP 127
91115: PUSH
91116: LD_INT 0
91118: ST_TO_ADDR
// sWound := false ;
91119: LD_ADDR_EXP 135
91123: PUSH
91124: LD_INT 0
91126: ST_TO_ADDR
// sBetray := false ;
91127: LD_ADDR_EXP 139
91131: PUSH
91132: LD_INT 0
91134: ST_TO_ADDR
// sContamin := false ;
91135: LD_ADDR_EXP 140
91139: PUSH
91140: LD_INT 0
91142: ST_TO_ADDR
// sOil := false ;
91143: LD_ADDR_EXP 142
91147: PUSH
91148: LD_INT 0
91150: ST_TO_ADDR
// sStu := false ;
91151: LD_ADDR_EXP 146
91155: PUSH
91156: LD_INT 0
91158: ST_TO_ADDR
// sBazooka := false ;
91159: LD_ADDR_EXP 149
91163: PUSH
91164: LD_INT 0
91166: ST_TO_ADDR
// sMortar := false ;
91167: LD_ADDR_EXP 150
91171: PUSH
91172: LD_INT 0
91174: ST_TO_ADDR
// sRanger := false ;
91175: LD_ADDR_EXP 160
91179: PUSH
91180: LD_INT 0
91182: ST_TO_ADDR
// sComputer := false ;
91183: LD_ADDR_EXP 161
91187: PUSH
91188: LD_INT 0
91190: ST_TO_ADDR
// s30 := false ;
91191: LD_ADDR_EXP 162
91195: PUSH
91196: LD_INT 0
91198: ST_TO_ADDR
// s60 := false ;
91199: LD_ADDR_EXP 163
91203: PUSH
91204: LD_INT 0
91206: ST_TO_ADDR
// end ;
91207: LD_VAR 0 1
91211: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
91212: LD_INT 0
91214: PPUSH
91215: PPUSH
91216: PPUSH
91217: PPUSH
91218: PPUSH
91219: PPUSH
91220: PPUSH
// result := [ ] ;
91221: LD_ADDR_VAR 0 2
91225: PUSH
91226: EMPTY
91227: ST_TO_ADDR
// if campaign_id = 1 then
91228: LD_OWVAR 69
91232: PUSH
91233: LD_INT 1
91235: EQUAL
91236: IFFALSE 94402
// begin case mission_number of 1 :
91238: LD_OWVAR 70
91242: PUSH
91243: LD_INT 1
91245: DOUBLE
91246: EQUAL
91247: IFTRUE 91251
91249: GO 91327
91251: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
91252: LD_ADDR_VAR 0 2
91256: PUSH
91257: LD_INT 2
91259: PUSH
91260: LD_INT 4
91262: PUSH
91263: LD_INT 11
91265: PUSH
91266: LD_INT 12
91268: PUSH
91269: LD_INT 15
91271: PUSH
91272: LD_INT 16
91274: PUSH
91275: LD_INT 22
91277: PUSH
91278: LD_INT 23
91280: PUSH
91281: LD_INT 26
91283: PUSH
91284: EMPTY
91285: LIST
91286: LIST
91287: LIST
91288: LIST
91289: LIST
91290: LIST
91291: LIST
91292: LIST
91293: LIST
91294: PUSH
91295: LD_INT 101
91297: PUSH
91298: LD_INT 102
91300: PUSH
91301: LD_INT 106
91303: PUSH
91304: LD_INT 116
91306: PUSH
91307: LD_INT 117
91309: PUSH
91310: LD_INT 118
91312: PUSH
91313: EMPTY
91314: LIST
91315: LIST
91316: LIST
91317: LIST
91318: LIST
91319: LIST
91320: PUSH
91321: EMPTY
91322: LIST
91323: LIST
91324: ST_TO_ADDR
91325: GO 94400
91327: LD_INT 2
91329: DOUBLE
91330: EQUAL
91331: IFTRUE 91335
91333: GO 91419
91335: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
91336: LD_ADDR_VAR 0 2
91340: PUSH
91341: LD_INT 2
91343: PUSH
91344: LD_INT 4
91346: PUSH
91347: LD_INT 11
91349: PUSH
91350: LD_INT 12
91352: PUSH
91353: LD_INT 15
91355: PUSH
91356: LD_INT 16
91358: PUSH
91359: LD_INT 22
91361: PUSH
91362: LD_INT 23
91364: PUSH
91365: LD_INT 26
91367: PUSH
91368: EMPTY
91369: LIST
91370: LIST
91371: LIST
91372: LIST
91373: LIST
91374: LIST
91375: LIST
91376: LIST
91377: LIST
91378: PUSH
91379: LD_INT 101
91381: PUSH
91382: LD_INT 102
91384: PUSH
91385: LD_INT 105
91387: PUSH
91388: LD_INT 106
91390: PUSH
91391: LD_INT 108
91393: PUSH
91394: LD_INT 116
91396: PUSH
91397: LD_INT 117
91399: PUSH
91400: LD_INT 118
91402: PUSH
91403: EMPTY
91404: LIST
91405: LIST
91406: LIST
91407: LIST
91408: LIST
91409: LIST
91410: LIST
91411: LIST
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: ST_TO_ADDR
91417: GO 94400
91419: LD_INT 3
91421: DOUBLE
91422: EQUAL
91423: IFTRUE 91427
91425: GO 91515
91427: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
91428: LD_ADDR_VAR 0 2
91432: PUSH
91433: LD_INT 2
91435: PUSH
91436: LD_INT 4
91438: PUSH
91439: LD_INT 5
91441: PUSH
91442: LD_INT 11
91444: PUSH
91445: LD_INT 12
91447: PUSH
91448: LD_INT 15
91450: PUSH
91451: LD_INT 16
91453: PUSH
91454: LD_INT 22
91456: PUSH
91457: LD_INT 26
91459: PUSH
91460: LD_INT 36
91462: PUSH
91463: EMPTY
91464: LIST
91465: LIST
91466: LIST
91467: LIST
91468: LIST
91469: LIST
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: PUSH
91475: LD_INT 101
91477: PUSH
91478: LD_INT 102
91480: PUSH
91481: LD_INT 105
91483: PUSH
91484: LD_INT 106
91486: PUSH
91487: LD_INT 108
91489: PUSH
91490: LD_INT 116
91492: PUSH
91493: LD_INT 117
91495: PUSH
91496: LD_INT 118
91498: PUSH
91499: EMPTY
91500: LIST
91501: LIST
91502: LIST
91503: LIST
91504: LIST
91505: LIST
91506: LIST
91507: LIST
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: ST_TO_ADDR
91513: GO 94400
91515: LD_INT 4
91517: DOUBLE
91518: EQUAL
91519: IFTRUE 91523
91521: GO 91619
91523: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
91524: LD_ADDR_VAR 0 2
91528: PUSH
91529: LD_INT 2
91531: PUSH
91532: LD_INT 4
91534: PUSH
91535: LD_INT 5
91537: PUSH
91538: LD_INT 8
91540: PUSH
91541: LD_INT 11
91543: PUSH
91544: LD_INT 12
91546: PUSH
91547: LD_INT 15
91549: PUSH
91550: LD_INT 16
91552: PUSH
91553: LD_INT 22
91555: PUSH
91556: LD_INT 23
91558: PUSH
91559: LD_INT 26
91561: PUSH
91562: LD_INT 36
91564: PUSH
91565: EMPTY
91566: LIST
91567: LIST
91568: LIST
91569: LIST
91570: LIST
91571: LIST
91572: LIST
91573: LIST
91574: LIST
91575: LIST
91576: LIST
91577: LIST
91578: PUSH
91579: LD_INT 101
91581: PUSH
91582: LD_INT 102
91584: PUSH
91585: LD_INT 105
91587: PUSH
91588: LD_INT 106
91590: PUSH
91591: LD_INT 108
91593: PUSH
91594: LD_INT 116
91596: PUSH
91597: LD_INT 117
91599: PUSH
91600: LD_INT 118
91602: PUSH
91603: EMPTY
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: PUSH
91613: EMPTY
91614: LIST
91615: LIST
91616: ST_TO_ADDR
91617: GO 94400
91619: LD_INT 5
91621: DOUBLE
91622: EQUAL
91623: IFTRUE 91627
91625: GO 91739
91627: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
91628: LD_ADDR_VAR 0 2
91632: PUSH
91633: LD_INT 2
91635: PUSH
91636: LD_INT 4
91638: PUSH
91639: LD_INT 5
91641: PUSH
91642: LD_INT 6
91644: PUSH
91645: LD_INT 8
91647: PUSH
91648: LD_INT 11
91650: PUSH
91651: LD_INT 12
91653: PUSH
91654: LD_INT 15
91656: PUSH
91657: LD_INT 16
91659: PUSH
91660: LD_INT 22
91662: PUSH
91663: LD_INT 23
91665: PUSH
91666: LD_INT 25
91668: PUSH
91669: LD_INT 26
91671: PUSH
91672: LD_INT 36
91674: PUSH
91675: EMPTY
91676: LIST
91677: LIST
91678: LIST
91679: LIST
91680: LIST
91681: LIST
91682: LIST
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: PUSH
91691: LD_INT 101
91693: PUSH
91694: LD_INT 102
91696: PUSH
91697: LD_INT 105
91699: PUSH
91700: LD_INT 106
91702: PUSH
91703: LD_INT 108
91705: PUSH
91706: LD_INT 109
91708: PUSH
91709: LD_INT 112
91711: PUSH
91712: LD_INT 116
91714: PUSH
91715: LD_INT 117
91717: PUSH
91718: LD_INT 118
91720: PUSH
91721: EMPTY
91722: LIST
91723: LIST
91724: LIST
91725: LIST
91726: LIST
91727: LIST
91728: LIST
91729: LIST
91730: LIST
91731: LIST
91732: PUSH
91733: EMPTY
91734: LIST
91735: LIST
91736: ST_TO_ADDR
91737: GO 94400
91739: LD_INT 6
91741: DOUBLE
91742: EQUAL
91743: IFTRUE 91747
91745: GO 91879
91747: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
91748: LD_ADDR_VAR 0 2
91752: PUSH
91753: LD_INT 2
91755: PUSH
91756: LD_INT 4
91758: PUSH
91759: LD_INT 5
91761: PUSH
91762: LD_INT 6
91764: PUSH
91765: LD_INT 8
91767: PUSH
91768: LD_INT 11
91770: PUSH
91771: LD_INT 12
91773: PUSH
91774: LD_INT 15
91776: PUSH
91777: LD_INT 16
91779: PUSH
91780: LD_INT 20
91782: PUSH
91783: LD_INT 21
91785: PUSH
91786: LD_INT 22
91788: PUSH
91789: LD_INT 23
91791: PUSH
91792: LD_INT 25
91794: PUSH
91795: LD_INT 26
91797: PUSH
91798: LD_INT 30
91800: PUSH
91801: LD_INT 31
91803: PUSH
91804: LD_INT 32
91806: PUSH
91807: LD_INT 36
91809: PUSH
91810: EMPTY
91811: LIST
91812: LIST
91813: LIST
91814: LIST
91815: LIST
91816: LIST
91817: LIST
91818: LIST
91819: LIST
91820: LIST
91821: LIST
91822: LIST
91823: LIST
91824: LIST
91825: LIST
91826: LIST
91827: LIST
91828: LIST
91829: LIST
91830: PUSH
91831: LD_INT 101
91833: PUSH
91834: LD_INT 102
91836: PUSH
91837: LD_INT 105
91839: PUSH
91840: LD_INT 106
91842: PUSH
91843: LD_INT 108
91845: PUSH
91846: LD_INT 109
91848: PUSH
91849: LD_INT 112
91851: PUSH
91852: LD_INT 116
91854: PUSH
91855: LD_INT 117
91857: PUSH
91858: LD_INT 118
91860: PUSH
91861: EMPTY
91862: LIST
91863: LIST
91864: LIST
91865: LIST
91866: LIST
91867: LIST
91868: LIST
91869: LIST
91870: LIST
91871: LIST
91872: PUSH
91873: EMPTY
91874: LIST
91875: LIST
91876: ST_TO_ADDR
91877: GO 94400
91879: LD_INT 7
91881: DOUBLE
91882: EQUAL
91883: IFTRUE 91887
91885: GO 91999
91887: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
91888: LD_ADDR_VAR 0 2
91892: PUSH
91893: LD_INT 2
91895: PUSH
91896: LD_INT 4
91898: PUSH
91899: LD_INT 5
91901: PUSH
91902: LD_INT 7
91904: PUSH
91905: LD_INT 11
91907: PUSH
91908: LD_INT 12
91910: PUSH
91911: LD_INT 15
91913: PUSH
91914: LD_INT 16
91916: PUSH
91917: LD_INT 20
91919: PUSH
91920: LD_INT 21
91922: PUSH
91923: LD_INT 22
91925: PUSH
91926: LD_INT 23
91928: PUSH
91929: LD_INT 25
91931: PUSH
91932: LD_INT 26
91934: PUSH
91935: EMPTY
91936: LIST
91937: LIST
91938: LIST
91939: LIST
91940: LIST
91941: LIST
91942: LIST
91943: LIST
91944: LIST
91945: LIST
91946: LIST
91947: LIST
91948: LIST
91949: LIST
91950: PUSH
91951: LD_INT 101
91953: PUSH
91954: LD_INT 102
91956: PUSH
91957: LD_INT 103
91959: PUSH
91960: LD_INT 105
91962: PUSH
91963: LD_INT 106
91965: PUSH
91966: LD_INT 108
91968: PUSH
91969: LD_INT 112
91971: PUSH
91972: LD_INT 116
91974: PUSH
91975: LD_INT 117
91977: PUSH
91978: LD_INT 118
91980: PUSH
91981: EMPTY
91982: LIST
91983: LIST
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: LIST
91990: LIST
91991: LIST
91992: PUSH
91993: EMPTY
91994: LIST
91995: LIST
91996: ST_TO_ADDR
91997: GO 94400
91999: LD_INT 8
92001: DOUBLE
92002: EQUAL
92003: IFTRUE 92007
92005: GO 92147
92007: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
92008: LD_ADDR_VAR 0 2
92012: PUSH
92013: LD_INT 2
92015: PUSH
92016: LD_INT 4
92018: PUSH
92019: LD_INT 5
92021: PUSH
92022: LD_INT 6
92024: PUSH
92025: LD_INT 7
92027: PUSH
92028: LD_INT 8
92030: PUSH
92031: LD_INT 11
92033: PUSH
92034: LD_INT 12
92036: PUSH
92037: LD_INT 15
92039: PUSH
92040: LD_INT 16
92042: PUSH
92043: LD_INT 20
92045: PUSH
92046: LD_INT 21
92048: PUSH
92049: LD_INT 22
92051: PUSH
92052: LD_INT 23
92054: PUSH
92055: LD_INT 25
92057: PUSH
92058: LD_INT 26
92060: PUSH
92061: LD_INT 30
92063: PUSH
92064: LD_INT 31
92066: PUSH
92067: LD_INT 32
92069: PUSH
92070: LD_INT 36
92072: PUSH
92073: EMPTY
92074: LIST
92075: LIST
92076: LIST
92077: LIST
92078: LIST
92079: LIST
92080: LIST
92081: LIST
92082: LIST
92083: LIST
92084: LIST
92085: LIST
92086: LIST
92087: LIST
92088: LIST
92089: LIST
92090: LIST
92091: LIST
92092: LIST
92093: LIST
92094: PUSH
92095: LD_INT 101
92097: PUSH
92098: LD_INT 102
92100: PUSH
92101: LD_INT 103
92103: PUSH
92104: LD_INT 105
92106: PUSH
92107: LD_INT 106
92109: PUSH
92110: LD_INT 108
92112: PUSH
92113: LD_INT 109
92115: PUSH
92116: LD_INT 112
92118: PUSH
92119: LD_INT 116
92121: PUSH
92122: LD_INT 117
92124: PUSH
92125: LD_INT 118
92127: PUSH
92128: EMPTY
92129: LIST
92130: LIST
92131: LIST
92132: LIST
92133: LIST
92134: LIST
92135: LIST
92136: LIST
92137: LIST
92138: LIST
92139: LIST
92140: PUSH
92141: EMPTY
92142: LIST
92143: LIST
92144: ST_TO_ADDR
92145: GO 94400
92147: LD_INT 9
92149: DOUBLE
92150: EQUAL
92151: IFTRUE 92155
92153: GO 92303
92155: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
92156: LD_ADDR_VAR 0 2
92160: PUSH
92161: LD_INT 2
92163: PUSH
92164: LD_INT 4
92166: PUSH
92167: LD_INT 5
92169: PUSH
92170: LD_INT 6
92172: PUSH
92173: LD_INT 7
92175: PUSH
92176: LD_INT 8
92178: PUSH
92179: LD_INT 11
92181: PUSH
92182: LD_INT 12
92184: PUSH
92185: LD_INT 15
92187: PUSH
92188: LD_INT 16
92190: PUSH
92191: LD_INT 20
92193: PUSH
92194: LD_INT 21
92196: PUSH
92197: LD_INT 22
92199: PUSH
92200: LD_INT 23
92202: PUSH
92203: LD_INT 25
92205: PUSH
92206: LD_INT 26
92208: PUSH
92209: LD_INT 28
92211: PUSH
92212: LD_INT 30
92214: PUSH
92215: LD_INT 31
92217: PUSH
92218: LD_INT 32
92220: PUSH
92221: LD_INT 36
92223: PUSH
92224: EMPTY
92225: LIST
92226: LIST
92227: LIST
92228: LIST
92229: LIST
92230: LIST
92231: LIST
92232: LIST
92233: LIST
92234: LIST
92235: LIST
92236: LIST
92237: LIST
92238: LIST
92239: LIST
92240: LIST
92241: LIST
92242: LIST
92243: LIST
92244: LIST
92245: LIST
92246: PUSH
92247: LD_INT 101
92249: PUSH
92250: LD_INT 102
92252: PUSH
92253: LD_INT 103
92255: PUSH
92256: LD_INT 105
92258: PUSH
92259: LD_INT 106
92261: PUSH
92262: LD_INT 108
92264: PUSH
92265: LD_INT 109
92267: PUSH
92268: LD_INT 112
92270: PUSH
92271: LD_INT 114
92273: PUSH
92274: LD_INT 116
92276: PUSH
92277: LD_INT 117
92279: PUSH
92280: LD_INT 118
92282: PUSH
92283: EMPTY
92284: LIST
92285: LIST
92286: LIST
92287: LIST
92288: LIST
92289: LIST
92290: LIST
92291: LIST
92292: LIST
92293: LIST
92294: LIST
92295: LIST
92296: PUSH
92297: EMPTY
92298: LIST
92299: LIST
92300: ST_TO_ADDR
92301: GO 94400
92303: LD_INT 10
92305: DOUBLE
92306: EQUAL
92307: IFTRUE 92311
92309: GO 92507
92311: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
92312: LD_ADDR_VAR 0 2
92316: PUSH
92317: LD_INT 2
92319: PUSH
92320: LD_INT 4
92322: PUSH
92323: LD_INT 5
92325: PUSH
92326: LD_INT 6
92328: PUSH
92329: LD_INT 7
92331: PUSH
92332: LD_INT 8
92334: PUSH
92335: LD_INT 9
92337: PUSH
92338: LD_INT 10
92340: PUSH
92341: LD_INT 11
92343: PUSH
92344: LD_INT 12
92346: PUSH
92347: LD_INT 13
92349: PUSH
92350: LD_INT 14
92352: PUSH
92353: LD_INT 15
92355: PUSH
92356: LD_INT 16
92358: PUSH
92359: LD_INT 17
92361: PUSH
92362: LD_INT 18
92364: PUSH
92365: LD_INT 19
92367: PUSH
92368: LD_INT 20
92370: PUSH
92371: LD_INT 21
92373: PUSH
92374: LD_INT 22
92376: PUSH
92377: LD_INT 23
92379: PUSH
92380: LD_INT 24
92382: PUSH
92383: LD_INT 25
92385: PUSH
92386: LD_INT 26
92388: PUSH
92389: LD_INT 28
92391: PUSH
92392: LD_INT 30
92394: PUSH
92395: LD_INT 31
92397: PUSH
92398: LD_INT 32
92400: PUSH
92401: LD_INT 36
92403: PUSH
92404: EMPTY
92405: LIST
92406: LIST
92407: LIST
92408: LIST
92409: LIST
92410: LIST
92411: LIST
92412: LIST
92413: LIST
92414: LIST
92415: LIST
92416: LIST
92417: LIST
92418: LIST
92419: LIST
92420: LIST
92421: LIST
92422: LIST
92423: LIST
92424: LIST
92425: LIST
92426: LIST
92427: LIST
92428: LIST
92429: LIST
92430: LIST
92431: LIST
92432: LIST
92433: LIST
92434: PUSH
92435: LD_INT 101
92437: PUSH
92438: LD_INT 102
92440: PUSH
92441: LD_INT 103
92443: PUSH
92444: LD_INT 104
92446: PUSH
92447: LD_INT 105
92449: PUSH
92450: LD_INT 106
92452: PUSH
92453: LD_INT 107
92455: PUSH
92456: LD_INT 108
92458: PUSH
92459: LD_INT 109
92461: PUSH
92462: LD_INT 110
92464: PUSH
92465: LD_INT 111
92467: PUSH
92468: LD_INT 112
92470: PUSH
92471: LD_INT 114
92473: PUSH
92474: LD_INT 116
92476: PUSH
92477: LD_INT 117
92479: PUSH
92480: LD_INT 118
92482: PUSH
92483: EMPTY
92484: LIST
92485: LIST
92486: LIST
92487: LIST
92488: LIST
92489: LIST
92490: LIST
92491: LIST
92492: LIST
92493: LIST
92494: LIST
92495: LIST
92496: LIST
92497: LIST
92498: LIST
92499: LIST
92500: PUSH
92501: EMPTY
92502: LIST
92503: LIST
92504: ST_TO_ADDR
92505: GO 94400
92507: LD_INT 11
92509: DOUBLE
92510: EQUAL
92511: IFTRUE 92515
92513: GO 92719
92515: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
92516: LD_ADDR_VAR 0 2
92520: PUSH
92521: LD_INT 2
92523: PUSH
92524: LD_INT 3
92526: PUSH
92527: LD_INT 4
92529: PUSH
92530: LD_INT 5
92532: PUSH
92533: LD_INT 6
92535: PUSH
92536: LD_INT 7
92538: PUSH
92539: LD_INT 8
92541: PUSH
92542: LD_INT 9
92544: PUSH
92545: LD_INT 10
92547: PUSH
92548: LD_INT 11
92550: PUSH
92551: LD_INT 12
92553: PUSH
92554: LD_INT 13
92556: PUSH
92557: LD_INT 14
92559: PUSH
92560: LD_INT 15
92562: PUSH
92563: LD_INT 16
92565: PUSH
92566: LD_INT 17
92568: PUSH
92569: LD_INT 18
92571: PUSH
92572: LD_INT 19
92574: PUSH
92575: LD_INT 20
92577: PUSH
92578: LD_INT 21
92580: PUSH
92581: LD_INT 22
92583: PUSH
92584: LD_INT 23
92586: PUSH
92587: LD_INT 24
92589: PUSH
92590: LD_INT 25
92592: PUSH
92593: LD_INT 26
92595: PUSH
92596: LD_INT 28
92598: PUSH
92599: LD_INT 30
92601: PUSH
92602: LD_INT 31
92604: PUSH
92605: LD_INT 32
92607: PUSH
92608: LD_INT 34
92610: PUSH
92611: LD_INT 36
92613: PUSH
92614: EMPTY
92615: LIST
92616: LIST
92617: LIST
92618: LIST
92619: LIST
92620: LIST
92621: LIST
92622: LIST
92623: LIST
92624: LIST
92625: LIST
92626: LIST
92627: LIST
92628: LIST
92629: LIST
92630: LIST
92631: LIST
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: LIST
92643: LIST
92644: LIST
92645: LIST
92646: PUSH
92647: LD_INT 101
92649: PUSH
92650: LD_INT 102
92652: PUSH
92653: LD_INT 103
92655: PUSH
92656: LD_INT 104
92658: PUSH
92659: LD_INT 105
92661: PUSH
92662: LD_INT 106
92664: PUSH
92665: LD_INT 107
92667: PUSH
92668: LD_INT 108
92670: PUSH
92671: LD_INT 109
92673: PUSH
92674: LD_INT 110
92676: PUSH
92677: LD_INT 111
92679: PUSH
92680: LD_INT 112
92682: PUSH
92683: LD_INT 114
92685: PUSH
92686: LD_INT 116
92688: PUSH
92689: LD_INT 117
92691: PUSH
92692: LD_INT 118
92694: PUSH
92695: EMPTY
92696: LIST
92697: LIST
92698: LIST
92699: LIST
92700: LIST
92701: LIST
92702: LIST
92703: LIST
92704: LIST
92705: LIST
92706: LIST
92707: LIST
92708: LIST
92709: LIST
92710: LIST
92711: LIST
92712: PUSH
92713: EMPTY
92714: LIST
92715: LIST
92716: ST_TO_ADDR
92717: GO 94400
92719: LD_INT 12
92721: DOUBLE
92722: EQUAL
92723: IFTRUE 92727
92725: GO 92947
92727: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
92728: LD_ADDR_VAR 0 2
92732: PUSH
92733: LD_INT 1
92735: PUSH
92736: LD_INT 2
92738: PUSH
92739: LD_INT 3
92741: PUSH
92742: LD_INT 4
92744: PUSH
92745: LD_INT 5
92747: PUSH
92748: LD_INT 6
92750: PUSH
92751: LD_INT 7
92753: PUSH
92754: LD_INT 8
92756: PUSH
92757: LD_INT 9
92759: PUSH
92760: LD_INT 10
92762: PUSH
92763: LD_INT 11
92765: PUSH
92766: LD_INT 12
92768: PUSH
92769: LD_INT 13
92771: PUSH
92772: LD_INT 14
92774: PUSH
92775: LD_INT 15
92777: PUSH
92778: LD_INT 16
92780: PUSH
92781: LD_INT 17
92783: PUSH
92784: LD_INT 18
92786: PUSH
92787: LD_INT 19
92789: PUSH
92790: LD_INT 20
92792: PUSH
92793: LD_INT 21
92795: PUSH
92796: LD_INT 22
92798: PUSH
92799: LD_INT 23
92801: PUSH
92802: LD_INT 24
92804: PUSH
92805: LD_INT 25
92807: PUSH
92808: LD_INT 26
92810: PUSH
92811: LD_INT 27
92813: PUSH
92814: LD_INT 28
92816: PUSH
92817: LD_INT 30
92819: PUSH
92820: LD_INT 31
92822: PUSH
92823: LD_INT 32
92825: PUSH
92826: LD_INT 33
92828: PUSH
92829: LD_INT 34
92831: PUSH
92832: LD_INT 36
92834: PUSH
92835: EMPTY
92836: LIST
92837: LIST
92838: LIST
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: LIST
92860: LIST
92861: LIST
92862: LIST
92863: LIST
92864: LIST
92865: LIST
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: PUSH
92871: LD_INT 101
92873: PUSH
92874: LD_INT 102
92876: PUSH
92877: LD_INT 103
92879: PUSH
92880: LD_INT 104
92882: PUSH
92883: LD_INT 105
92885: PUSH
92886: LD_INT 106
92888: PUSH
92889: LD_INT 107
92891: PUSH
92892: LD_INT 108
92894: PUSH
92895: LD_INT 109
92897: PUSH
92898: LD_INT 110
92900: PUSH
92901: LD_INT 111
92903: PUSH
92904: LD_INT 112
92906: PUSH
92907: LD_INT 113
92909: PUSH
92910: LD_INT 114
92912: PUSH
92913: LD_INT 116
92915: PUSH
92916: LD_INT 117
92918: PUSH
92919: LD_INT 118
92921: PUSH
92922: EMPTY
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: LIST
92932: LIST
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: PUSH
92941: EMPTY
92942: LIST
92943: LIST
92944: ST_TO_ADDR
92945: GO 94400
92947: LD_INT 13
92949: DOUBLE
92950: EQUAL
92951: IFTRUE 92955
92953: GO 93163
92955: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
92956: LD_ADDR_VAR 0 2
92960: PUSH
92961: LD_INT 1
92963: PUSH
92964: LD_INT 2
92966: PUSH
92967: LD_INT 3
92969: PUSH
92970: LD_INT 4
92972: PUSH
92973: LD_INT 5
92975: PUSH
92976: LD_INT 8
92978: PUSH
92979: LD_INT 9
92981: PUSH
92982: LD_INT 10
92984: PUSH
92985: LD_INT 11
92987: PUSH
92988: LD_INT 12
92990: PUSH
92991: LD_INT 14
92993: PUSH
92994: LD_INT 15
92996: PUSH
92997: LD_INT 16
92999: PUSH
93000: LD_INT 17
93002: PUSH
93003: LD_INT 18
93005: PUSH
93006: LD_INT 19
93008: PUSH
93009: LD_INT 20
93011: PUSH
93012: LD_INT 21
93014: PUSH
93015: LD_INT 22
93017: PUSH
93018: LD_INT 23
93020: PUSH
93021: LD_INT 24
93023: PUSH
93024: LD_INT 25
93026: PUSH
93027: LD_INT 26
93029: PUSH
93030: LD_INT 27
93032: PUSH
93033: LD_INT 28
93035: PUSH
93036: LD_INT 30
93038: PUSH
93039: LD_INT 31
93041: PUSH
93042: LD_INT 32
93044: PUSH
93045: LD_INT 33
93047: PUSH
93048: LD_INT 34
93050: PUSH
93051: LD_INT 36
93053: PUSH
93054: EMPTY
93055: LIST
93056: LIST
93057: LIST
93058: LIST
93059: LIST
93060: LIST
93061: LIST
93062: LIST
93063: LIST
93064: LIST
93065: LIST
93066: LIST
93067: LIST
93068: LIST
93069: LIST
93070: LIST
93071: LIST
93072: LIST
93073: LIST
93074: LIST
93075: LIST
93076: LIST
93077: LIST
93078: LIST
93079: LIST
93080: LIST
93081: LIST
93082: LIST
93083: LIST
93084: LIST
93085: LIST
93086: PUSH
93087: LD_INT 101
93089: PUSH
93090: LD_INT 102
93092: PUSH
93093: LD_INT 103
93095: PUSH
93096: LD_INT 104
93098: PUSH
93099: LD_INT 105
93101: PUSH
93102: LD_INT 106
93104: PUSH
93105: LD_INT 107
93107: PUSH
93108: LD_INT 108
93110: PUSH
93111: LD_INT 109
93113: PUSH
93114: LD_INT 110
93116: PUSH
93117: LD_INT 111
93119: PUSH
93120: LD_INT 112
93122: PUSH
93123: LD_INT 113
93125: PUSH
93126: LD_INT 114
93128: PUSH
93129: LD_INT 116
93131: PUSH
93132: LD_INT 117
93134: PUSH
93135: LD_INT 118
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: PUSH
93157: EMPTY
93158: LIST
93159: LIST
93160: ST_TO_ADDR
93161: GO 94400
93163: LD_INT 14
93165: DOUBLE
93166: EQUAL
93167: IFTRUE 93171
93169: GO 93395
93171: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
93172: LD_ADDR_VAR 0 2
93176: PUSH
93177: LD_INT 1
93179: PUSH
93180: LD_INT 2
93182: PUSH
93183: LD_INT 3
93185: PUSH
93186: LD_INT 4
93188: PUSH
93189: LD_INT 5
93191: PUSH
93192: LD_INT 6
93194: PUSH
93195: LD_INT 7
93197: PUSH
93198: LD_INT 8
93200: PUSH
93201: LD_INT 9
93203: PUSH
93204: LD_INT 10
93206: PUSH
93207: LD_INT 11
93209: PUSH
93210: LD_INT 12
93212: PUSH
93213: LD_INT 13
93215: PUSH
93216: LD_INT 14
93218: PUSH
93219: LD_INT 15
93221: PUSH
93222: LD_INT 16
93224: PUSH
93225: LD_INT 17
93227: PUSH
93228: LD_INT 18
93230: PUSH
93231: LD_INT 19
93233: PUSH
93234: LD_INT 20
93236: PUSH
93237: LD_INT 21
93239: PUSH
93240: LD_INT 22
93242: PUSH
93243: LD_INT 23
93245: PUSH
93246: LD_INT 24
93248: PUSH
93249: LD_INT 25
93251: PUSH
93252: LD_INT 26
93254: PUSH
93255: LD_INT 27
93257: PUSH
93258: LD_INT 28
93260: PUSH
93261: LD_INT 29
93263: PUSH
93264: LD_INT 30
93266: PUSH
93267: LD_INT 31
93269: PUSH
93270: LD_INT 32
93272: PUSH
93273: LD_INT 33
93275: PUSH
93276: LD_INT 34
93278: PUSH
93279: LD_INT 36
93281: PUSH
93282: EMPTY
93283: LIST
93284: LIST
93285: LIST
93286: LIST
93287: LIST
93288: LIST
93289: LIST
93290: LIST
93291: LIST
93292: LIST
93293: LIST
93294: LIST
93295: LIST
93296: LIST
93297: LIST
93298: LIST
93299: LIST
93300: LIST
93301: LIST
93302: LIST
93303: LIST
93304: LIST
93305: LIST
93306: LIST
93307: LIST
93308: LIST
93309: LIST
93310: LIST
93311: LIST
93312: LIST
93313: LIST
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: PUSH
93319: LD_INT 101
93321: PUSH
93322: LD_INT 102
93324: PUSH
93325: LD_INT 103
93327: PUSH
93328: LD_INT 104
93330: PUSH
93331: LD_INT 105
93333: PUSH
93334: LD_INT 106
93336: PUSH
93337: LD_INT 107
93339: PUSH
93340: LD_INT 108
93342: PUSH
93343: LD_INT 109
93345: PUSH
93346: LD_INT 110
93348: PUSH
93349: LD_INT 111
93351: PUSH
93352: LD_INT 112
93354: PUSH
93355: LD_INT 113
93357: PUSH
93358: LD_INT 114
93360: PUSH
93361: LD_INT 116
93363: PUSH
93364: LD_INT 117
93366: PUSH
93367: LD_INT 118
93369: PUSH
93370: EMPTY
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: LIST
93380: LIST
93381: LIST
93382: LIST
93383: LIST
93384: LIST
93385: LIST
93386: LIST
93387: LIST
93388: PUSH
93389: EMPTY
93390: LIST
93391: LIST
93392: ST_TO_ADDR
93393: GO 94400
93395: LD_INT 15
93397: DOUBLE
93398: EQUAL
93399: IFTRUE 93403
93401: GO 93627
93403: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
93404: LD_ADDR_VAR 0 2
93408: PUSH
93409: LD_INT 1
93411: PUSH
93412: LD_INT 2
93414: PUSH
93415: LD_INT 3
93417: PUSH
93418: LD_INT 4
93420: PUSH
93421: LD_INT 5
93423: PUSH
93424: LD_INT 6
93426: PUSH
93427: LD_INT 7
93429: PUSH
93430: LD_INT 8
93432: PUSH
93433: LD_INT 9
93435: PUSH
93436: LD_INT 10
93438: PUSH
93439: LD_INT 11
93441: PUSH
93442: LD_INT 12
93444: PUSH
93445: LD_INT 13
93447: PUSH
93448: LD_INT 14
93450: PUSH
93451: LD_INT 15
93453: PUSH
93454: LD_INT 16
93456: PUSH
93457: LD_INT 17
93459: PUSH
93460: LD_INT 18
93462: PUSH
93463: LD_INT 19
93465: PUSH
93466: LD_INT 20
93468: PUSH
93469: LD_INT 21
93471: PUSH
93472: LD_INT 22
93474: PUSH
93475: LD_INT 23
93477: PUSH
93478: LD_INT 24
93480: PUSH
93481: LD_INT 25
93483: PUSH
93484: LD_INT 26
93486: PUSH
93487: LD_INT 27
93489: PUSH
93490: LD_INT 28
93492: PUSH
93493: LD_INT 29
93495: PUSH
93496: LD_INT 30
93498: PUSH
93499: LD_INT 31
93501: PUSH
93502: LD_INT 32
93504: PUSH
93505: LD_INT 33
93507: PUSH
93508: LD_INT 34
93510: PUSH
93511: LD_INT 36
93513: PUSH
93514: EMPTY
93515: LIST
93516: LIST
93517: LIST
93518: LIST
93519: LIST
93520: LIST
93521: LIST
93522: LIST
93523: LIST
93524: LIST
93525: LIST
93526: LIST
93527: LIST
93528: LIST
93529: LIST
93530: LIST
93531: LIST
93532: LIST
93533: LIST
93534: LIST
93535: LIST
93536: LIST
93537: LIST
93538: LIST
93539: LIST
93540: LIST
93541: LIST
93542: LIST
93543: LIST
93544: LIST
93545: LIST
93546: LIST
93547: LIST
93548: LIST
93549: LIST
93550: PUSH
93551: LD_INT 101
93553: PUSH
93554: LD_INT 102
93556: PUSH
93557: LD_INT 103
93559: PUSH
93560: LD_INT 104
93562: PUSH
93563: LD_INT 105
93565: PUSH
93566: LD_INT 106
93568: PUSH
93569: LD_INT 107
93571: PUSH
93572: LD_INT 108
93574: PUSH
93575: LD_INT 109
93577: PUSH
93578: LD_INT 110
93580: PUSH
93581: LD_INT 111
93583: PUSH
93584: LD_INT 112
93586: PUSH
93587: LD_INT 113
93589: PUSH
93590: LD_INT 114
93592: PUSH
93593: LD_INT 116
93595: PUSH
93596: LD_INT 117
93598: PUSH
93599: LD_INT 118
93601: PUSH
93602: EMPTY
93603: LIST
93604: LIST
93605: LIST
93606: LIST
93607: LIST
93608: LIST
93609: LIST
93610: LIST
93611: LIST
93612: LIST
93613: LIST
93614: LIST
93615: LIST
93616: LIST
93617: LIST
93618: LIST
93619: LIST
93620: PUSH
93621: EMPTY
93622: LIST
93623: LIST
93624: ST_TO_ADDR
93625: GO 94400
93627: LD_INT 16
93629: DOUBLE
93630: EQUAL
93631: IFTRUE 93635
93633: GO 93771
93635: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
93636: LD_ADDR_VAR 0 2
93640: PUSH
93641: LD_INT 2
93643: PUSH
93644: LD_INT 4
93646: PUSH
93647: LD_INT 5
93649: PUSH
93650: LD_INT 7
93652: PUSH
93653: LD_INT 11
93655: PUSH
93656: LD_INT 12
93658: PUSH
93659: LD_INT 15
93661: PUSH
93662: LD_INT 16
93664: PUSH
93665: LD_INT 20
93667: PUSH
93668: LD_INT 21
93670: PUSH
93671: LD_INT 22
93673: PUSH
93674: LD_INT 23
93676: PUSH
93677: LD_INT 25
93679: PUSH
93680: LD_INT 26
93682: PUSH
93683: LD_INT 30
93685: PUSH
93686: LD_INT 31
93688: PUSH
93689: LD_INT 32
93691: PUSH
93692: LD_INT 33
93694: PUSH
93695: LD_INT 34
93697: PUSH
93698: EMPTY
93699: LIST
93700: LIST
93701: LIST
93702: LIST
93703: LIST
93704: LIST
93705: LIST
93706: LIST
93707: LIST
93708: LIST
93709: LIST
93710: LIST
93711: LIST
93712: LIST
93713: LIST
93714: LIST
93715: LIST
93716: LIST
93717: LIST
93718: PUSH
93719: LD_INT 101
93721: PUSH
93722: LD_INT 102
93724: PUSH
93725: LD_INT 103
93727: PUSH
93728: LD_INT 106
93730: PUSH
93731: LD_INT 108
93733: PUSH
93734: LD_INT 112
93736: PUSH
93737: LD_INT 113
93739: PUSH
93740: LD_INT 114
93742: PUSH
93743: LD_INT 116
93745: PUSH
93746: LD_INT 117
93748: PUSH
93749: LD_INT 118
93751: PUSH
93752: EMPTY
93753: LIST
93754: LIST
93755: LIST
93756: LIST
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: PUSH
93765: EMPTY
93766: LIST
93767: LIST
93768: ST_TO_ADDR
93769: GO 94400
93771: LD_INT 17
93773: DOUBLE
93774: EQUAL
93775: IFTRUE 93779
93777: GO 94003
93779: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
93780: LD_ADDR_VAR 0 2
93784: PUSH
93785: LD_INT 1
93787: PUSH
93788: LD_INT 2
93790: PUSH
93791: LD_INT 3
93793: PUSH
93794: LD_INT 4
93796: PUSH
93797: LD_INT 5
93799: PUSH
93800: LD_INT 6
93802: PUSH
93803: LD_INT 7
93805: PUSH
93806: LD_INT 8
93808: PUSH
93809: LD_INT 9
93811: PUSH
93812: LD_INT 10
93814: PUSH
93815: LD_INT 11
93817: PUSH
93818: LD_INT 12
93820: PUSH
93821: LD_INT 13
93823: PUSH
93824: LD_INT 14
93826: PUSH
93827: LD_INT 15
93829: PUSH
93830: LD_INT 16
93832: PUSH
93833: LD_INT 17
93835: PUSH
93836: LD_INT 18
93838: PUSH
93839: LD_INT 19
93841: PUSH
93842: LD_INT 20
93844: PUSH
93845: LD_INT 21
93847: PUSH
93848: LD_INT 22
93850: PUSH
93851: LD_INT 23
93853: PUSH
93854: LD_INT 24
93856: PUSH
93857: LD_INT 25
93859: PUSH
93860: LD_INT 26
93862: PUSH
93863: LD_INT 27
93865: PUSH
93866: LD_INT 28
93868: PUSH
93869: LD_INT 29
93871: PUSH
93872: LD_INT 30
93874: PUSH
93875: LD_INT 31
93877: PUSH
93878: LD_INT 32
93880: PUSH
93881: LD_INT 33
93883: PUSH
93884: LD_INT 34
93886: PUSH
93887: LD_INT 36
93889: PUSH
93890: EMPTY
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: LIST
93921: LIST
93922: LIST
93923: LIST
93924: LIST
93925: LIST
93926: PUSH
93927: LD_INT 101
93929: PUSH
93930: LD_INT 102
93932: PUSH
93933: LD_INT 103
93935: PUSH
93936: LD_INT 104
93938: PUSH
93939: LD_INT 105
93941: PUSH
93942: LD_INT 106
93944: PUSH
93945: LD_INT 107
93947: PUSH
93948: LD_INT 108
93950: PUSH
93951: LD_INT 109
93953: PUSH
93954: LD_INT 110
93956: PUSH
93957: LD_INT 111
93959: PUSH
93960: LD_INT 112
93962: PUSH
93963: LD_INT 113
93965: PUSH
93966: LD_INT 114
93968: PUSH
93969: LD_INT 116
93971: PUSH
93972: LD_INT 117
93974: PUSH
93975: LD_INT 118
93977: PUSH
93978: EMPTY
93979: LIST
93980: LIST
93981: LIST
93982: LIST
93983: LIST
93984: LIST
93985: LIST
93986: LIST
93987: LIST
93988: LIST
93989: LIST
93990: LIST
93991: LIST
93992: LIST
93993: LIST
93994: LIST
93995: LIST
93996: PUSH
93997: EMPTY
93998: LIST
93999: LIST
94000: ST_TO_ADDR
94001: GO 94400
94003: LD_INT 18
94005: DOUBLE
94006: EQUAL
94007: IFTRUE 94011
94009: GO 94159
94011: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
94012: LD_ADDR_VAR 0 2
94016: PUSH
94017: LD_INT 2
94019: PUSH
94020: LD_INT 4
94022: PUSH
94023: LD_INT 5
94025: PUSH
94026: LD_INT 7
94028: PUSH
94029: LD_INT 11
94031: PUSH
94032: LD_INT 12
94034: PUSH
94035: LD_INT 15
94037: PUSH
94038: LD_INT 16
94040: PUSH
94041: LD_INT 20
94043: PUSH
94044: LD_INT 21
94046: PUSH
94047: LD_INT 22
94049: PUSH
94050: LD_INT 23
94052: PUSH
94053: LD_INT 25
94055: PUSH
94056: LD_INT 26
94058: PUSH
94059: LD_INT 30
94061: PUSH
94062: LD_INT 31
94064: PUSH
94065: LD_INT 32
94067: PUSH
94068: LD_INT 33
94070: PUSH
94071: LD_INT 34
94073: PUSH
94074: LD_INT 35
94076: PUSH
94077: LD_INT 36
94079: PUSH
94080: EMPTY
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: LIST
94089: LIST
94090: LIST
94091: LIST
94092: LIST
94093: LIST
94094: LIST
94095: LIST
94096: LIST
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: PUSH
94103: LD_INT 101
94105: PUSH
94106: LD_INT 102
94108: PUSH
94109: LD_INT 103
94111: PUSH
94112: LD_INT 106
94114: PUSH
94115: LD_INT 108
94117: PUSH
94118: LD_INT 112
94120: PUSH
94121: LD_INT 113
94123: PUSH
94124: LD_INT 114
94126: PUSH
94127: LD_INT 115
94129: PUSH
94130: LD_INT 116
94132: PUSH
94133: LD_INT 117
94135: PUSH
94136: LD_INT 118
94138: PUSH
94139: EMPTY
94140: LIST
94141: LIST
94142: LIST
94143: LIST
94144: LIST
94145: LIST
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: PUSH
94153: EMPTY
94154: LIST
94155: LIST
94156: ST_TO_ADDR
94157: GO 94400
94159: LD_INT 19
94161: DOUBLE
94162: EQUAL
94163: IFTRUE 94167
94165: GO 94399
94167: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
94168: LD_ADDR_VAR 0 2
94172: PUSH
94173: LD_INT 1
94175: PUSH
94176: LD_INT 2
94178: PUSH
94179: LD_INT 3
94181: PUSH
94182: LD_INT 4
94184: PUSH
94185: LD_INT 5
94187: PUSH
94188: LD_INT 6
94190: PUSH
94191: LD_INT 7
94193: PUSH
94194: LD_INT 8
94196: PUSH
94197: LD_INT 9
94199: PUSH
94200: LD_INT 10
94202: PUSH
94203: LD_INT 11
94205: PUSH
94206: LD_INT 12
94208: PUSH
94209: LD_INT 13
94211: PUSH
94212: LD_INT 14
94214: PUSH
94215: LD_INT 15
94217: PUSH
94218: LD_INT 16
94220: PUSH
94221: LD_INT 17
94223: PUSH
94224: LD_INT 18
94226: PUSH
94227: LD_INT 19
94229: PUSH
94230: LD_INT 20
94232: PUSH
94233: LD_INT 21
94235: PUSH
94236: LD_INT 22
94238: PUSH
94239: LD_INT 23
94241: PUSH
94242: LD_INT 24
94244: PUSH
94245: LD_INT 25
94247: PUSH
94248: LD_INT 26
94250: PUSH
94251: LD_INT 27
94253: PUSH
94254: LD_INT 28
94256: PUSH
94257: LD_INT 29
94259: PUSH
94260: LD_INT 30
94262: PUSH
94263: LD_INT 31
94265: PUSH
94266: LD_INT 32
94268: PUSH
94269: LD_INT 33
94271: PUSH
94272: LD_INT 34
94274: PUSH
94275: LD_INT 35
94277: PUSH
94278: LD_INT 36
94280: PUSH
94281: EMPTY
94282: LIST
94283: LIST
94284: LIST
94285: LIST
94286: LIST
94287: LIST
94288: LIST
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: LIST
94294: LIST
94295: LIST
94296: LIST
94297: LIST
94298: LIST
94299: LIST
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: PUSH
94319: LD_INT 101
94321: PUSH
94322: LD_INT 102
94324: PUSH
94325: LD_INT 103
94327: PUSH
94328: LD_INT 104
94330: PUSH
94331: LD_INT 105
94333: PUSH
94334: LD_INT 106
94336: PUSH
94337: LD_INT 107
94339: PUSH
94340: LD_INT 108
94342: PUSH
94343: LD_INT 109
94345: PUSH
94346: LD_INT 110
94348: PUSH
94349: LD_INT 111
94351: PUSH
94352: LD_INT 112
94354: PUSH
94355: LD_INT 113
94357: PUSH
94358: LD_INT 114
94360: PUSH
94361: LD_INT 115
94363: PUSH
94364: LD_INT 116
94366: PUSH
94367: LD_INT 117
94369: PUSH
94370: LD_INT 118
94372: PUSH
94373: EMPTY
94374: LIST
94375: LIST
94376: LIST
94377: LIST
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: LIST
94390: LIST
94391: LIST
94392: PUSH
94393: EMPTY
94394: LIST
94395: LIST
94396: ST_TO_ADDR
94397: GO 94400
94399: POP
// end else
94400: GO 94631
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
94402: LD_ADDR_VAR 0 2
94406: PUSH
94407: LD_INT 1
94409: PUSH
94410: LD_INT 2
94412: PUSH
94413: LD_INT 3
94415: PUSH
94416: LD_INT 4
94418: PUSH
94419: LD_INT 5
94421: PUSH
94422: LD_INT 6
94424: PUSH
94425: LD_INT 7
94427: PUSH
94428: LD_INT 8
94430: PUSH
94431: LD_INT 9
94433: PUSH
94434: LD_INT 10
94436: PUSH
94437: LD_INT 11
94439: PUSH
94440: LD_INT 12
94442: PUSH
94443: LD_INT 13
94445: PUSH
94446: LD_INT 14
94448: PUSH
94449: LD_INT 15
94451: PUSH
94452: LD_INT 16
94454: PUSH
94455: LD_INT 17
94457: PUSH
94458: LD_INT 18
94460: PUSH
94461: LD_INT 19
94463: PUSH
94464: LD_INT 20
94466: PUSH
94467: LD_INT 21
94469: PUSH
94470: LD_INT 22
94472: PUSH
94473: LD_INT 23
94475: PUSH
94476: LD_INT 24
94478: PUSH
94479: LD_INT 25
94481: PUSH
94482: LD_INT 26
94484: PUSH
94485: LD_INT 27
94487: PUSH
94488: LD_INT 28
94490: PUSH
94491: LD_INT 29
94493: PUSH
94494: LD_INT 30
94496: PUSH
94497: LD_INT 31
94499: PUSH
94500: LD_INT 32
94502: PUSH
94503: LD_INT 33
94505: PUSH
94506: LD_INT 34
94508: PUSH
94509: LD_INT 35
94511: PUSH
94512: LD_INT 36
94514: PUSH
94515: EMPTY
94516: LIST
94517: LIST
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: LIST
94551: LIST
94552: PUSH
94553: LD_INT 101
94555: PUSH
94556: LD_INT 102
94558: PUSH
94559: LD_INT 103
94561: PUSH
94562: LD_INT 104
94564: PUSH
94565: LD_INT 105
94567: PUSH
94568: LD_INT 106
94570: PUSH
94571: LD_INT 107
94573: PUSH
94574: LD_INT 108
94576: PUSH
94577: LD_INT 109
94579: PUSH
94580: LD_INT 110
94582: PUSH
94583: LD_INT 111
94585: PUSH
94586: LD_INT 112
94588: PUSH
94589: LD_INT 113
94591: PUSH
94592: LD_INT 114
94594: PUSH
94595: LD_INT 115
94597: PUSH
94598: LD_INT 116
94600: PUSH
94601: LD_INT 117
94603: PUSH
94604: LD_INT 118
94606: PUSH
94607: EMPTY
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: LIST
94624: LIST
94625: LIST
94626: PUSH
94627: EMPTY
94628: LIST
94629: LIST
94630: ST_TO_ADDR
// if result then
94631: LD_VAR 0 2
94635: IFFALSE 95421
// begin normal :=  ;
94637: LD_ADDR_VAR 0 5
94641: PUSH
94642: LD_STRING 
94644: ST_TO_ADDR
// hardcore :=  ;
94645: LD_ADDR_VAR 0 6
94649: PUSH
94650: LD_STRING 
94652: ST_TO_ADDR
// active :=  ;
94653: LD_ADDR_VAR 0 7
94657: PUSH
94658: LD_STRING 
94660: ST_TO_ADDR
// for i = 1 to normalCounter do
94661: LD_ADDR_VAR 0 8
94665: PUSH
94666: DOUBLE
94667: LD_INT 1
94669: DEC
94670: ST_TO_ADDR
94671: LD_EXP 108
94675: PUSH
94676: FOR_TO
94677: IFFALSE 94778
// begin tmp := 0 ;
94679: LD_ADDR_VAR 0 3
94683: PUSH
94684: LD_STRING 0
94686: ST_TO_ADDR
// if result [ 1 ] then
94687: LD_VAR 0 2
94691: PUSH
94692: LD_INT 1
94694: ARRAY
94695: IFFALSE 94760
// if result [ 1 ] [ 1 ] = i then
94697: LD_VAR 0 2
94701: PUSH
94702: LD_INT 1
94704: ARRAY
94705: PUSH
94706: LD_INT 1
94708: ARRAY
94709: PUSH
94710: LD_VAR 0 8
94714: EQUAL
94715: IFFALSE 94760
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
94717: LD_ADDR_VAR 0 2
94721: PUSH
94722: LD_VAR 0 2
94726: PPUSH
94727: LD_INT 1
94729: PPUSH
94730: LD_VAR 0 2
94734: PUSH
94735: LD_INT 1
94737: ARRAY
94738: PPUSH
94739: LD_INT 1
94741: PPUSH
94742: CALL_OW 3
94746: PPUSH
94747: CALL_OW 1
94751: ST_TO_ADDR
// tmp := 1 ;
94752: LD_ADDR_VAR 0 3
94756: PUSH
94757: LD_STRING 1
94759: ST_TO_ADDR
// end ; normal := normal & tmp ;
94760: LD_ADDR_VAR 0 5
94764: PUSH
94765: LD_VAR 0 5
94769: PUSH
94770: LD_VAR 0 3
94774: STR
94775: ST_TO_ADDR
// end ;
94776: GO 94676
94778: POP
94779: POP
// for i = 1 to hardcoreCounter do
94780: LD_ADDR_VAR 0 8
94784: PUSH
94785: DOUBLE
94786: LD_INT 1
94788: DEC
94789: ST_TO_ADDR
94790: LD_EXP 109
94794: PUSH
94795: FOR_TO
94796: IFFALSE 94901
// begin tmp := 0 ;
94798: LD_ADDR_VAR 0 3
94802: PUSH
94803: LD_STRING 0
94805: ST_TO_ADDR
// if result [ 2 ] then
94806: LD_VAR 0 2
94810: PUSH
94811: LD_INT 2
94813: ARRAY
94814: IFFALSE 94883
// if result [ 2 ] [ 1 ] = 100 + i then
94816: LD_VAR 0 2
94820: PUSH
94821: LD_INT 2
94823: ARRAY
94824: PUSH
94825: LD_INT 1
94827: ARRAY
94828: PUSH
94829: LD_INT 100
94831: PUSH
94832: LD_VAR 0 8
94836: PLUS
94837: EQUAL
94838: IFFALSE 94883
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
94840: LD_ADDR_VAR 0 2
94844: PUSH
94845: LD_VAR 0 2
94849: PPUSH
94850: LD_INT 2
94852: PPUSH
94853: LD_VAR 0 2
94857: PUSH
94858: LD_INT 2
94860: ARRAY
94861: PPUSH
94862: LD_INT 1
94864: PPUSH
94865: CALL_OW 3
94869: PPUSH
94870: CALL_OW 1
94874: ST_TO_ADDR
// tmp := 1 ;
94875: LD_ADDR_VAR 0 3
94879: PUSH
94880: LD_STRING 1
94882: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
94883: LD_ADDR_VAR 0 6
94887: PUSH
94888: LD_VAR 0 6
94892: PUSH
94893: LD_VAR 0 3
94897: STR
94898: ST_TO_ADDR
// end ;
94899: GO 94795
94901: POP
94902: POP
// if isGameLoad then
94903: LD_VAR 0 1
94907: IFFALSE 95382
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
94909: LD_ADDR_VAR 0 4
94913: PUSH
94914: LD_EXP 112
94918: PUSH
94919: LD_EXP 111
94923: PUSH
94924: LD_EXP 113
94928: PUSH
94929: LD_EXP 110
94933: PUSH
94934: LD_EXP 114
94938: PUSH
94939: LD_EXP 115
94943: PUSH
94944: LD_EXP 116
94948: PUSH
94949: LD_EXP 117
94953: PUSH
94954: LD_EXP 118
94958: PUSH
94959: LD_EXP 119
94963: PUSH
94964: LD_EXP 120
94968: PUSH
94969: LD_EXP 121
94973: PUSH
94974: LD_EXP 122
94978: PUSH
94979: LD_EXP 123
94983: PUSH
94984: LD_EXP 131
94988: PUSH
94989: LD_EXP 132
94993: PUSH
94994: LD_EXP 133
94998: PUSH
94999: LD_EXP 134
95003: PUSH
95004: LD_EXP 136
95008: PUSH
95009: LD_EXP 137
95013: PUSH
95014: LD_EXP 138
95018: PUSH
95019: LD_EXP 141
95023: PUSH
95024: LD_EXP 143
95028: PUSH
95029: LD_EXP 144
95033: PUSH
95034: LD_EXP 145
95038: PUSH
95039: LD_EXP 147
95043: PUSH
95044: LD_EXP 148
95048: PUSH
95049: LD_EXP 151
95053: PUSH
95054: LD_EXP 152
95058: PUSH
95059: LD_EXP 153
95063: PUSH
95064: LD_EXP 154
95068: PUSH
95069: LD_EXP 155
95073: PUSH
95074: LD_EXP 156
95078: PUSH
95079: LD_EXP 157
95083: PUSH
95084: LD_EXP 158
95088: PUSH
95089: LD_EXP 159
95093: PUSH
95094: LD_EXP 124
95098: PUSH
95099: LD_EXP 125
95103: PUSH
95104: LD_EXP 128
95108: PUSH
95109: LD_EXP 129
95113: PUSH
95114: LD_EXP 130
95118: PUSH
95119: LD_EXP 126
95123: PUSH
95124: LD_EXP 127
95128: PUSH
95129: LD_EXP 135
95133: PUSH
95134: LD_EXP 139
95138: PUSH
95139: LD_EXP 140
95143: PUSH
95144: LD_EXP 142
95148: PUSH
95149: LD_EXP 146
95153: PUSH
95154: LD_EXP 149
95158: PUSH
95159: LD_EXP 150
95163: PUSH
95164: LD_EXP 160
95168: PUSH
95169: LD_EXP 161
95173: PUSH
95174: LD_EXP 162
95178: PUSH
95179: LD_EXP 163
95183: PUSH
95184: EMPTY
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: LIST
95200: LIST
95201: LIST
95202: LIST
95203: LIST
95204: LIST
95205: LIST
95206: LIST
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: ST_TO_ADDR
// tmp :=  ;
95240: LD_ADDR_VAR 0 3
95244: PUSH
95245: LD_STRING 
95247: ST_TO_ADDR
// for i = 1 to normalCounter do
95248: LD_ADDR_VAR 0 8
95252: PUSH
95253: DOUBLE
95254: LD_INT 1
95256: DEC
95257: ST_TO_ADDR
95258: LD_EXP 108
95262: PUSH
95263: FOR_TO
95264: IFFALSE 95300
// begin if flags [ i ] then
95266: LD_VAR 0 4
95270: PUSH
95271: LD_VAR 0 8
95275: ARRAY
95276: IFFALSE 95298
// tmp := tmp & i & ; ;
95278: LD_ADDR_VAR 0 3
95282: PUSH
95283: LD_VAR 0 3
95287: PUSH
95288: LD_VAR 0 8
95292: STR
95293: PUSH
95294: LD_STRING ;
95296: STR
95297: ST_TO_ADDR
// end ;
95298: GO 95263
95300: POP
95301: POP
// for i = 1 to hardcoreCounter do
95302: LD_ADDR_VAR 0 8
95306: PUSH
95307: DOUBLE
95308: LD_INT 1
95310: DEC
95311: ST_TO_ADDR
95312: LD_EXP 109
95316: PUSH
95317: FOR_TO
95318: IFFALSE 95364
// begin if flags [ normalCounter + i ] then
95320: LD_VAR 0 4
95324: PUSH
95325: LD_EXP 108
95329: PUSH
95330: LD_VAR 0 8
95334: PLUS
95335: ARRAY
95336: IFFALSE 95362
// tmp := tmp & ( 100 + i ) & ; ;
95338: LD_ADDR_VAR 0 3
95342: PUSH
95343: LD_VAR 0 3
95347: PUSH
95348: LD_INT 100
95350: PUSH
95351: LD_VAR 0 8
95355: PLUS
95356: STR
95357: PUSH
95358: LD_STRING ;
95360: STR
95361: ST_TO_ADDR
// end ;
95362: GO 95317
95364: POP
95365: POP
// if tmp then
95366: LD_VAR 0 3
95370: IFFALSE 95382
// active := tmp ;
95372: LD_ADDR_VAR 0 7
95376: PUSH
95377: LD_VAR 0 3
95381: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
95382: LD_STRING getStreamItemsFromMission("
95384: PUSH
95385: LD_VAR 0 5
95389: STR
95390: PUSH
95391: LD_STRING ","
95393: STR
95394: PUSH
95395: LD_VAR 0 6
95399: STR
95400: PUSH
95401: LD_STRING ","
95403: STR
95404: PUSH
95405: LD_VAR 0 7
95409: STR
95410: PUSH
95411: LD_STRING ")
95413: STR
95414: PPUSH
95415: CALL_OW 559
// end else
95419: GO 95428
// ToLua ( getStreamItemsFromMission("","","") ) ;
95421: LD_STRING getStreamItemsFromMission("","","")
95423: PPUSH
95424: CALL_OW 559
// end ;
95428: LD_VAR 0 2
95432: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
95433: LD_EXP 107
95437: PUSH
95438: LD_EXP 112
95442: AND
95443: IFFALSE 95567
95445: GO 95447
95447: DISABLE
95448: LD_INT 0
95450: PPUSH
95451: PPUSH
// begin enable ;
95452: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
95453: LD_ADDR_VAR 0 2
95457: PUSH
95458: LD_INT 22
95460: PUSH
95461: LD_OWVAR 2
95465: PUSH
95466: EMPTY
95467: LIST
95468: LIST
95469: PUSH
95470: LD_INT 2
95472: PUSH
95473: LD_INT 34
95475: PUSH
95476: LD_INT 7
95478: PUSH
95479: EMPTY
95480: LIST
95481: LIST
95482: PUSH
95483: LD_INT 34
95485: PUSH
95486: LD_INT 45
95488: PUSH
95489: EMPTY
95490: LIST
95491: LIST
95492: PUSH
95493: LD_INT 34
95495: PUSH
95496: LD_INT 28
95498: PUSH
95499: EMPTY
95500: LIST
95501: LIST
95502: PUSH
95503: LD_INT 34
95505: PUSH
95506: LD_INT 47
95508: PUSH
95509: EMPTY
95510: LIST
95511: LIST
95512: PUSH
95513: EMPTY
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: PUSH
95520: EMPTY
95521: LIST
95522: LIST
95523: PPUSH
95524: CALL_OW 69
95528: ST_TO_ADDR
// if not tmp then
95529: LD_VAR 0 2
95533: NOT
95534: IFFALSE 95538
// exit ;
95536: GO 95567
// for i in tmp do
95538: LD_ADDR_VAR 0 1
95542: PUSH
95543: LD_VAR 0 2
95547: PUSH
95548: FOR_IN
95549: IFFALSE 95565
// begin SetLives ( i , 0 ) ;
95551: LD_VAR 0 1
95555: PPUSH
95556: LD_INT 0
95558: PPUSH
95559: CALL_OW 234
// end ;
95563: GO 95548
95565: POP
95566: POP
// end ;
95567: PPOPN 2
95569: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
95570: LD_EXP 107
95574: PUSH
95575: LD_EXP 113
95579: AND
95580: IFFALSE 95664
95582: GO 95584
95584: DISABLE
95585: LD_INT 0
95587: PPUSH
95588: PPUSH
// begin enable ;
95589: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
95590: LD_ADDR_VAR 0 2
95594: PUSH
95595: LD_INT 22
95597: PUSH
95598: LD_OWVAR 2
95602: PUSH
95603: EMPTY
95604: LIST
95605: LIST
95606: PUSH
95607: LD_INT 32
95609: PUSH
95610: LD_INT 3
95612: PUSH
95613: EMPTY
95614: LIST
95615: LIST
95616: PUSH
95617: EMPTY
95618: LIST
95619: LIST
95620: PPUSH
95621: CALL_OW 69
95625: ST_TO_ADDR
// if not tmp then
95626: LD_VAR 0 2
95630: NOT
95631: IFFALSE 95635
// exit ;
95633: GO 95664
// for i in tmp do
95635: LD_ADDR_VAR 0 1
95639: PUSH
95640: LD_VAR 0 2
95644: PUSH
95645: FOR_IN
95646: IFFALSE 95662
// begin SetLives ( i , 0 ) ;
95648: LD_VAR 0 1
95652: PPUSH
95653: LD_INT 0
95655: PPUSH
95656: CALL_OW 234
// end ;
95660: GO 95645
95662: POP
95663: POP
// end ;
95664: PPOPN 2
95666: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
95667: LD_EXP 107
95671: PUSH
95672: LD_EXP 110
95676: AND
95677: IFFALSE 95770
95679: GO 95681
95681: DISABLE
95682: LD_INT 0
95684: PPUSH
// begin enable ;
95685: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
95686: LD_ADDR_VAR 0 1
95690: PUSH
95691: LD_INT 22
95693: PUSH
95694: LD_OWVAR 2
95698: PUSH
95699: EMPTY
95700: LIST
95701: LIST
95702: PUSH
95703: LD_INT 2
95705: PUSH
95706: LD_INT 25
95708: PUSH
95709: LD_INT 5
95711: PUSH
95712: EMPTY
95713: LIST
95714: LIST
95715: PUSH
95716: LD_INT 25
95718: PUSH
95719: LD_INT 9
95721: PUSH
95722: EMPTY
95723: LIST
95724: LIST
95725: PUSH
95726: LD_INT 25
95728: PUSH
95729: LD_INT 8
95731: PUSH
95732: EMPTY
95733: LIST
95734: LIST
95735: PUSH
95736: EMPTY
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: PUSH
95742: EMPTY
95743: LIST
95744: LIST
95745: PPUSH
95746: CALL_OW 69
95750: PUSH
95751: FOR_IN
95752: IFFALSE 95768
// begin SetClass ( i , 1 ) ;
95754: LD_VAR 0 1
95758: PPUSH
95759: LD_INT 1
95761: PPUSH
95762: CALL_OW 336
// end ;
95766: GO 95751
95768: POP
95769: POP
// end ;
95770: PPOPN 1
95772: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
95773: LD_EXP 107
95777: PUSH
95778: LD_EXP 111
95782: AND
95783: PUSH
95784: LD_OWVAR 65
95788: PUSH
95789: LD_INT 7
95791: LESS
95792: AND
95793: IFFALSE 95807
95795: GO 95797
95797: DISABLE
// begin enable ;
95798: ENABLE
// game_speed := 7 ;
95799: LD_ADDR_OWVAR 65
95803: PUSH
95804: LD_INT 7
95806: ST_TO_ADDR
// end ;
95807: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
95808: LD_EXP 107
95812: PUSH
95813: LD_EXP 114
95817: AND
95818: IFFALSE 96020
95820: GO 95822
95822: DISABLE
95823: LD_INT 0
95825: PPUSH
95826: PPUSH
95827: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
95828: LD_ADDR_VAR 0 3
95832: PUSH
95833: LD_INT 81
95835: PUSH
95836: LD_OWVAR 2
95840: PUSH
95841: EMPTY
95842: LIST
95843: LIST
95844: PUSH
95845: LD_INT 21
95847: PUSH
95848: LD_INT 1
95850: PUSH
95851: EMPTY
95852: LIST
95853: LIST
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: PPUSH
95859: CALL_OW 69
95863: ST_TO_ADDR
// if not tmp then
95864: LD_VAR 0 3
95868: NOT
95869: IFFALSE 95873
// exit ;
95871: GO 96020
// if tmp > 5 then
95873: LD_VAR 0 3
95877: PUSH
95878: LD_INT 5
95880: GREATER
95881: IFFALSE 95893
// k := 5 else
95883: LD_ADDR_VAR 0 2
95887: PUSH
95888: LD_INT 5
95890: ST_TO_ADDR
95891: GO 95903
// k := tmp ;
95893: LD_ADDR_VAR 0 2
95897: PUSH
95898: LD_VAR 0 3
95902: ST_TO_ADDR
// for i := 1 to k do
95903: LD_ADDR_VAR 0 1
95907: PUSH
95908: DOUBLE
95909: LD_INT 1
95911: DEC
95912: ST_TO_ADDR
95913: LD_VAR 0 2
95917: PUSH
95918: FOR_TO
95919: IFFALSE 96018
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
95921: LD_VAR 0 3
95925: PUSH
95926: LD_VAR 0 1
95930: ARRAY
95931: PPUSH
95932: LD_VAR 0 1
95936: PUSH
95937: LD_INT 4
95939: MOD
95940: PUSH
95941: LD_INT 1
95943: PLUS
95944: PPUSH
95945: CALL_OW 259
95949: PUSH
95950: LD_INT 10
95952: LESS
95953: IFFALSE 96016
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
95955: LD_VAR 0 3
95959: PUSH
95960: LD_VAR 0 1
95964: ARRAY
95965: PPUSH
95966: LD_VAR 0 1
95970: PUSH
95971: LD_INT 4
95973: MOD
95974: PUSH
95975: LD_INT 1
95977: PLUS
95978: PPUSH
95979: LD_VAR 0 3
95983: PUSH
95984: LD_VAR 0 1
95988: ARRAY
95989: PPUSH
95990: LD_VAR 0 1
95994: PUSH
95995: LD_INT 4
95997: MOD
95998: PUSH
95999: LD_INT 1
96001: PLUS
96002: PPUSH
96003: CALL_OW 259
96007: PUSH
96008: LD_INT 1
96010: PLUS
96011: PPUSH
96012: CALL_OW 237
96016: GO 95918
96018: POP
96019: POP
// end ;
96020: PPOPN 3
96022: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96023: LD_EXP 107
96027: PUSH
96028: LD_EXP 115
96032: AND
96033: IFFALSE 96053
96035: GO 96037
96037: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
96038: LD_INT 4
96040: PPUSH
96041: LD_OWVAR 2
96045: PPUSH
96046: LD_INT 0
96048: PPUSH
96049: CALL_OW 324
96053: END
// every 0 0$1 trigger StreamModeActive and sShovel do
96054: LD_EXP 107
96058: PUSH
96059: LD_EXP 144
96063: AND
96064: IFFALSE 96084
96066: GO 96068
96068: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
96069: LD_INT 19
96071: PPUSH
96072: LD_OWVAR 2
96076: PPUSH
96077: LD_INT 0
96079: PPUSH
96080: CALL_OW 324
96084: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
96085: LD_EXP 107
96089: PUSH
96090: LD_EXP 116
96094: AND
96095: IFFALSE 96197
96097: GO 96099
96099: DISABLE
96100: LD_INT 0
96102: PPUSH
96103: PPUSH
// begin enable ;
96104: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
96105: LD_ADDR_VAR 0 2
96109: PUSH
96110: LD_INT 22
96112: PUSH
96113: LD_OWVAR 2
96117: PUSH
96118: EMPTY
96119: LIST
96120: LIST
96121: PUSH
96122: LD_INT 2
96124: PUSH
96125: LD_INT 34
96127: PUSH
96128: LD_INT 11
96130: PUSH
96131: EMPTY
96132: LIST
96133: LIST
96134: PUSH
96135: LD_INT 34
96137: PUSH
96138: LD_INT 30
96140: PUSH
96141: EMPTY
96142: LIST
96143: LIST
96144: PUSH
96145: EMPTY
96146: LIST
96147: LIST
96148: LIST
96149: PUSH
96150: EMPTY
96151: LIST
96152: LIST
96153: PPUSH
96154: CALL_OW 69
96158: ST_TO_ADDR
// if not tmp then
96159: LD_VAR 0 2
96163: NOT
96164: IFFALSE 96168
// exit ;
96166: GO 96197
// for i in tmp do
96168: LD_ADDR_VAR 0 1
96172: PUSH
96173: LD_VAR 0 2
96177: PUSH
96178: FOR_IN
96179: IFFALSE 96195
// begin SetLives ( i , 0 ) ;
96181: LD_VAR 0 1
96185: PPUSH
96186: LD_INT 0
96188: PPUSH
96189: CALL_OW 234
// end ;
96193: GO 96178
96195: POP
96196: POP
// end ;
96197: PPOPN 2
96199: END
// every 0 0$1 trigger StreamModeActive and sBunker do
96200: LD_EXP 107
96204: PUSH
96205: LD_EXP 117
96209: AND
96210: IFFALSE 96230
96212: GO 96214
96214: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
96215: LD_INT 32
96217: PPUSH
96218: LD_OWVAR 2
96222: PPUSH
96223: LD_INT 0
96225: PPUSH
96226: CALL_OW 324
96230: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
96231: LD_EXP 107
96235: PUSH
96236: LD_EXP 118
96240: AND
96241: IFFALSE 96422
96243: GO 96245
96245: DISABLE
96246: LD_INT 0
96248: PPUSH
96249: PPUSH
96250: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96251: LD_ADDR_VAR 0 2
96255: PUSH
96256: LD_INT 22
96258: PUSH
96259: LD_OWVAR 2
96263: PUSH
96264: EMPTY
96265: LIST
96266: LIST
96267: PUSH
96268: LD_INT 33
96270: PUSH
96271: LD_INT 3
96273: PUSH
96274: EMPTY
96275: LIST
96276: LIST
96277: PUSH
96278: EMPTY
96279: LIST
96280: LIST
96281: PPUSH
96282: CALL_OW 69
96286: ST_TO_ADDR
// if not tmp then
96287: LD_VAR 0 2
96291: NOT
96292: IFFALSE 96296
// exit ;
96294: GO 96422
// side := 0 ;
96296: LD_ADDR_VAR 0 3
96300: PUSH
96301: LD_INT 0
96303: ST_TO_ADDR
// for i := 1 to 8 do
96304: LD_ADDR_VAR 0 1
96308: PUSH
96309: DOUBLE
96310: LD_INT 1
96312: DEC
96313: ST_TO_ADDR
96314: LD_INT 8
96316: PUSH
96317: FOR_TO
96318: IFFALSE 96366
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
96320: LD_OWVAR 2
96324: PUSH
96325: LD_VAR 0 1
96329: NONEQUAL
96330: PUSH
96331: LD_OWVAR 2
96335: PPUSH
96336: LD_VAR 0 1
96340: PPUSH
96341: CALL_OW 81
96345: PUSH
96346: LD_INT 2
96348: EQUAL
96349: AND
96350: IFFALSE 96364
// begin side := i ;
96352: LD_ADDR_VAR 0 3
96356: PUSH
96357: LD_VAR 0 1
96361: ST_TO_ADDR
// break ;
96362: GO 96366
// end ;
96364: GO 96317
96366: POP
96367: POP
// if not side then
96368: LD_VAR 0 3
96372: NOT
96373: IFFALSE 96377
// exit ;
96375: GO 96422
// for i := 1 to tmp do
96377: LD_ADDR_VAR 0 1
96381: PUSH
96382: DOUBLE
96383: LD_INT 1
96385: DEC
96386: ST_TO_ADDR
96387: LD_VAR 0 2
96391: PUSH
96392: FOR_TO
96393: IFFALSE 96420
// if Prob ( 60 ) then
96395: LD_INT 60
96397: PPUSH
96398: CALL_OW 13
96402: IFFALSE 96418
// SetSide ( i , side ) ;
96404: LD_VAR 0 1
96408: PPUSH
96409: LD_VAR 0 3
96413: PPUSH
96414: CALL_OW 235
96418: GO 96392
96420: POP
96421: POP
// end ;
96422: PPOPN 3
96424: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
96425: LD_EXP 107
96429: PUSH
96430: LD_EXP 120
96434: AND
96435: IFFALSE 96554
96437: GO 96439
96439: DISABLE
96440: LD_INT 0
96442: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
96443: LD_ADDR_VAR 0 1
96447: PUSH
96448: LD_INT 22
96450: PUSH
96451: LD_OWVAR 2
96455: PUSH
96456: EMPTY
96457: LIST
96458: LIST
96459: PUSH
96460: LD_INT 21
96462: PUSH
96463: LD_INT 1
96465: PUSH
96466: EMPTY
96467: LIST
96468: LIST
96469: PUSH
96470: LD_INT 3
96472: PUSH
96473: LD_INT 23
96475: PUSH
96476: LD_INT 0
96478: PUSH
96479: EMPTY
96480: LIST
96481: LIST
96482: PUSH
96483: EMPTY
96484: LIST
96485: LIST
96486: PUSH
96487: EMPTY
96488: LIST
96489: LIST
96490: LIST
96491: PPUSH
96492: CALL_OW 69
96496: PUSH
96497: FOR_IN
96498: IFFALSE 96552
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
96500: LD_VAR 0 1
96504: PPUSH
96505: CALL_OW 257
96509: PUSH
96510: LD_INT 1
96512: PUSH
96513: LD_INT 2
96515: PUSH
96516: LD_INT 3
96518: PUSH
96519: LD_INT 4
96521: PUSH
96522: EMPTY
96523: LIST
96524: LIST
96525: LIST
96526: LIST
96527: IN
96528: IFFALSE 96550
// SetClass ( un , rand ( 1 , 4 ) ) ;
96530: LD_VAR 0 1
96534: PPUSH
96535: LD_INT 1
96537: PPUSH
96538: LD_INT 4
96540: PPUSH
96541: CALL_OW 12
96545: PPUSH
96546: CALL_OW 336
96550: GO 96497
96552: POP
96553: POP
// end ;
96554: PPOPN 1
96556: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
96557: LD_EXP 107
96561: PUSH
96562: LD_EXP 119
96566: AND
96567: IFFALSE 96646
96569: GO 96571
96571: DISABLE
96572: LD_INT 0
96574: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96575: LD_ADDR_VAR 0 1
96579: PUSH
96580: LD_INT 22
96582: PUSH
96583: LD_OWVAR 2
96587: PUSH
96588: EMPTY
96589: LIST
96590: LIST
96591: PUSH
96592: LD_INT 21
96594: PUSH
96595: LD_INT 3
96597: PUSH
96598: EMPTY
96599: LIST
96600: LIST
96601: PUSH
96602: EMPTY
96603: LIST
96604: LIST
96605: PPUSH
96606: CALL_OW 69
96610: ST_TO_ADDR
// if not tmp then
96611: LD_VAR 0 1
96615: NOT
96616: IFFALSE 96620
// exit ;
96618: GO 96646
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
96620: LD_VAR 0 1
96624: PUSH
96625: LD_INT 1
96627: PPUSH
96628: LD_VAR 0 1
96632: PPUSH
96633: CALL_OW 12
96637: ARRAY
96638: PPUSH
96639: LD_INT 100
96641: PPUSH
96642: CALL_OW 234
// end ;
96646: PPOPN 1
96648: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
96649: LD_EXP 107
96653: PUSH
96654: LD_EXP 121
96658: AND
96659: IFFALSE 96757
96661: GO 96663
96663: DISABLE
96664: LD_INT 0
96666: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96667: LD_ADDR_VAR 0 1
96671: PUSH
96672: LD_INT 22
96674: PUSH
96675: LD_OWVAR 2
96679: PUSH
96680: EMPTY
96681: LIST
96682: LIST
96683: PUSH
96684: LD_INT 21
96686: PUSH
96687: LD_INT 1
96689: PUSH
96690: EMPTY
96691: LIST
96692: LIST
96693: PUSH
96694: EMPTY
96695: LIST
96696: LIST
96697: PPUSH
96698: CALL_OW 69
96702: ST_TO_ADDR
// if not tmp then
96703: LD_VAR 0 1
96707: NOT
96708: IFFALSE 96712
// exit ;
96710: GO 96757
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
96712: LD_VAR 0 1
96716: PUSH
96717: LD_INT 1
96719: PPUSH
96720: LD_VAR 0 1
96724: PPUSH
96725: CALL_OW 12
96729: ARRAY
96730: PPUSH
96731: LD_INT 1
96733: PPUSH
96734: LD_INT 4
96736: PPUSH
96737: CALL_OW 12
96741: PPUSH
96742: LD_INT 3000
96744: PPUSH
96745: LD_INT 9000
96747: PPUSH
96748: CALL_OW 12
96752: PPUSH
96753: CALL_OW 492
// end ;
96757: PPOPN 1
96759: END
// every 0 0$1 trigger StreamModeActive and sDepot do
96760: LD_EXP 107
96764: PUSH
96765: LD_EXP 122
96769: AND
96770: IFFALSE 96790
96772: GO 96774
96774: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
96775: LD_INT 1
96777: PPUSH
96778: LD_OWVAR 2
96782: PPUSH
96783: LD_INT 0
96785: PPUSH
96786: CALL_OW 324
96790: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
96791: LD_EXP 107
96795: PUSH
96796: LD_EXP 123
96800: AND
96801: IFFALSE 96884
96803: GO 96805
96805: DISABLE
96806: LD_INT 0
96808: PPUSH
96809: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96810: LD_ADDR_VAR 0 2
96814: PUSH
96815: LD_INT 22
96817: PUSH
96818: LD_OWVAR 2
96822: PUSH
96823: EMPTY
96824: LIST
96825: LIST
96826: PUSH
96827: LD_INT 21
96829: PUSH
96830: LD_INT 3
96832: PUSH
96833: EMPTY
96834: LIST
96835: LIST
96836: PUSH
96837: EMPTY
96838: LIST
96839: LIST
96840: PPUSH
96841: CALL_OW 69
96845: ST_TO_ADDR
// if not tmp then
96846: LD_VAR 0 2
96850: NOT
96851: IFFALSE 96855
// exit ;
96853: GO 96884
// for i in tmp do
96855: LD_ADDR_VAR 0 1
96859: PUSH
96860: LD_VAR 0 2
96864: PUSH
96865: FOR_IN
96866: IFFALSE 96882
// SetBLevel ( i , 10 ) ;
96868: LD_VAR 0 1
96872: PPUSH
96873: LD_INT 10
96875: PPUSH
96876: CALL_OW 241
96880: GO 96865
96882: POP
96883: POP
// end ;
96884: PPOPN 2
96886: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
96887: LD_EXP 107
96891: PUSH
96892: LD_EXP 124
96896: AND
96897: IFFALSE 97008
96899: GO 96901
96901: DISABLE
96902: LD_INT 0
96904: PPUSH
96905: PPUSH
96906: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96907: LD_ADDR_VAR 0 3
96911: PUSH
96912: LD_INT 22
96914: PUSH
96915: LD_OWVAR 2
96919: PUSH
96920: EMPTY
96921: LIST
96922: LIST
96923: PUSH
96924: LD_INT 25
96926: PUSH
96927: LD_INT 1
96929: PUSH
96930: EMPTY
96931: LIST
96932: LIST
96933: PUSH
96934: EMPTY
96935: LIST
96936: LIST
96937: PPUSH
96938: CALL_OW 69
96942: ST_TO_ADDR
// if not tmp then
96943: LD_VAR 0 3
96947: NOT
96948: IFFALSE 96952
// exit ;
96950: GO 97008
// un := tmp [ rand ( 1 , tmp ) ] ;
96952: LD_ADDR_VAR 0 2
96956: PUSH
96957: LD_VAR 0 3
96961: PUSH
96962: LD_INT 1
96964: PPUSH
96965: LD_VAR 0 3
96969: PPUSH
96970: CALL_OW 12
96974: ARRAY
96975: ST_TO_ADDR
// if Crawls ( un ) then
96976: LD_VAR 0 2
96980: PPUSH
96981: CALL_OW 318
96985: IFFALSE 96996
// ComWalk ( un ) ;
96987: LD_VAR 0 2
96991: PPUSH
96992: CALL_OW 138
// SetClass ( un , class_sniper ) ;
96996: LD_VAR 0 2
97000: PPUSH
97001: LD_INT 5
97003: PPUSH
97004: CALL_OW 336
// end ;
97008: PPOPN 3
97010: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
97011: LD_EXP 107
97015: PUSH
97016: LD_EXP 125
97020: AND
97021: PUSH
97022: LD_OWVAR 67
97026: PUSH
97027: LD_INT 4
97029: LESS
97030: AND
97031: IFFALSE 97050
97033: GO 97035
97035: DISABLE
// begin Difficulty := Difficulty + 1 ;
97036: LD_ADDR_OWVAR 67
97040: PUSH
97041: LD_OWVAR 67
97045: PUSH
97046: LD_INT 1
97048: PLUS
97049: ST_TO_ADDR
// end ;
97050: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
97051: LD_EXP 107
97055: PUSH
97056: LD_EXP 126
97060: AND
97061: IFFALSE 97164
97063: GO 97065
97065: DISABLE
97066: LD_INT 0
97068: PPUSH
// begin for i := 1 to 5 do
97069: LD_ADDR_VAR 0 1
97073: PUSH
97074: DOUBLE
97075: LD_INT 1
97077: DEC
97078: ST_TO_ADDR
97079: LD_INT 5
97081: PUSH
97082: FOR_TO
97083: IFFALSE 97162
// begin uc_nation := nation_nature ;
97085: LD_ADDR_OWVAR 21
97089: PUSH
97090: LD_INT 0
97092: ST_TO_ADDR
// uc_side := 0 ;
97093: LD_ADDR_OWVAR 20
97097: PUSH
97098: LD_INT 0
97100: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97101: LD_ADDR_OWVAR 29
97105: PUSH
97106: LD_INT 12
97108: PUSH
97109: LD_INT 12
97111: PUSH
97112: EMPTY
97113: LIST
97114: LIST
97115: ST_TO_ADDR
// hc_agressivity := 20 ;
97116: LD_ADDR_OWVAR 35
97120: PUSH
97121: LD_INT 20
97123: ST_TO_ADDR
// hc_class := class_tiger ;
97124: LD_ADDR_OWVAR 28
97128: PUSH
97129: LD_INT 14
97131: ST_TO_ADDR
// hc_gallery :=  ;
97132: LD_ADDR_OWVAR 33
97136: PUSH
97137: LD_STRING 
97139: ST_TO_ADDR
// hc_name :=  ;
97140: LD_ADDR_OWVAR 26
97144: PUSH
97145: LD_STRING 
97147: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
97148: CALL_OW 44
97152: PPUSH
97153: LD_INT 0
97155: PPUSH
97156: CALL_OW 51
// end ;
97160: GO 97082
97162: POP
97163: POP
// end ;
97164: PPOPN 1
97166: END
// every 0 0$1 trigger StreamModeActive and sBomb do
97167: LD_EXP 107
97171: PUSH
97172: LD_EXP 127
97176: AND
97177: IFFALSE 97186
97179: GO 97181
97181: DISABLE
// StreamSibBomb ;
97182: CALL 97187 0 0
97186: END
// export function StreamSibBomb ; var i , x , y ; begin
97187: LD_INT 0
97189: PPUSH
97190: PPUSH
97191: PPUSH
97192: PPUSH
// result := false ;
97193: LD_ADDR_VAR 0 1
97197: PUSH
97198: LD_INT 0
97200: ST_TO_ADDR
// for i := 1 to 16 do
97201: LD_ADDR_VAR 0 2
97205: PUSH
97206: DOUBLE
97207: LD_INT 1
97209: DEC
97210: ST_TO_ADDR
97211: LD_INT 16
97213: PUSH
97214: FOR_TO
97215: IFFALSE 97414
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97217: LD_ADDR_VAR 0 3
97221: PUSH
97222: LD_INT 10
97224: PUSH
97225: LD_INT 20
97227: PUSH
97228: LD_INT 30
97230: PUSH
97231: LD_INT 40
97233: PUSH
97234: LD_INT 50
97236: PUSH
97237: LD_INT 60
97239: PUSH
97240: LD_INT 70
97242: PUSH
97243: LD_INT 80
97245: PUSH
97246: LD_INT 90
97248: PUSH
97249: LD_INT 100
97251: PUSH
97252: LD_INT 110
97254: PUSH
97255: LD_INT 120
97257: PUSH
97258: LD_INT 130
97260: PUSH
97261: LD_INT 140
97263: PUSH
97264: LD_INT 150
97266: PUSH
97267: EMPTY
97268: LIST
97269: LIST
97270: LIST
97271: LIST
97272: LIST
97273: LIST
97274: LIST
97275: LIST
97276: LIST
97277: LIST
97278: LIST
97279: LIST
97280: LIST
97281: LIST
97282: LIST
97283: PUSH
97284: LD_INT 1
97286: PPUSH
97287: LD_INT 15
97289: PPUSH
97290: CALL_OW 12
97294: ARRAY
97295: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97296: LD_ADDR_VAR 0 4
97300: PUSH
97301: LD_INT 10
97303: PUSH
97304: LD_INT 20
97306: PUSH
97307: LD_INT 30
97309: PUSH
97310: LD_INT 40
97312: PUSH
97313: LD_INT 50
97315: PUSH
97316: LD_INT 60
97318: PUSH
97319: LD_INT 70
97321: PUSH
97322: LD_INT 80
97324: PUSH
97325: LD_INT 90
97327: PUSH
97328: LD_INT 100
97330: PUSH
97331: LD_INT 110
97333: PUSH
97334: LD_INT 120
97336: PUSH
97337: LD_INT 130
97339: PUSH
97340: LD_INT 140
97342: PUSH
97343: LD_INT 150
97345: PUSH
97346: EMPTY
97347: LIST
97348: LIST
97349: LIST
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: LIST
97357: LIST
97358: LIST
97359: LIST
97360: LIST
97361: LIST
97362: PUSH
97363: LD_INT 1
97365: PPUSH
97366: LD_INT 15
97368: PPUSH
97369: CALL_OW 12
97373: ARRAY
97374: ST_TO_ADDR
// if ValidHex ( x , y ) then
97375: LD_VAR 0 3
97379: PPUSH
97380: LD_VAR 0 4
97384: PPUSH
97385: CALL_OW 488
97389: IFFALSE 97412
// begin result := [ x , y ] ;
97391: LD_ADDR_VAR 0 1
97395: PUSH
97396: LD_VAR 0 3
97400: PUSH
97401: LD_VAR 0 4
97405: PUSH
97406: EMPTY
97407: LIST
97408: LIST
97409: ST_TO_ADDR
// break ;
97410: GO 97414
// end ; end ;
97412: GO 97214
97414: POP
97415: POP
// if result then
97416: LD_VAR 0 1
97420: IFFALSE 97480
// begin ToLua ( playSibBomb() ) ;
97422: LD_STRING playSibBomb()
97424: PPUSH
97425: CALL_OW 559
// wait ( 0 0$14 ) ;
97429: LD_INT 490
97431: PPUSH
97432: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
97436: LD_VAR 0 1
97440: PUSH
97441: LD_INT 1
97443: ARRAY
97444: PPUSH
97445: LD_VAR 0 1
97449: PUSH
97450: LD_INT 2
97452: ARRAY
97453: PPUSH
97454: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
97458: LD_VAR 0 1
97462: PUSH
97463: LD_INT 1
97465: ARRAY
97466: PPUSH
97467: LD_VAR 0 1
97471: PUSH
97472: LD_INT 2
97474: ARRAY
97475: PPUSH
97476: CALL_OW 429
// end ; end ;
97480: LD_VAR 0 1
97484: RET
// every 0 0$1 trigger StreamModeActive and sReset do
97485: LD_EXP 107
97489: PUSH
97490: LD_EXP 129
97494: AND
97495: IFFALSE 97507
97497: GO 97499
97499: DISABLE
// YouLost (  ) ;
97500: LD_STRING 
97502: PPUSH
97503: CALL_OW 104
97507: END
// every 0 0$1 trigger StreamModeActive and sFog do
97508: LD_EXP 107
97512: PUSH
97513: LD_EXP 128
97517: AND
97518: IFFALSE 97532
97520: GO 97522
97522: DISABLE
// FogOff ( your_side ) ;
97523: LD_OWVAR 2
97527: PPUSH
97528: CALL_OW 344
97532: END
// every 0 0$1 trigger StreamModeActive and sSun do
97533: LD_EXP 107
97537: PUSH
97538: LD_EXP 130
97542: AND
97543: IFFALSE 97571
97545: GO 97547
97547: DISABLE
// begin solar_recharge_percent := 0 ;
97548: LD_ADDR_OWVAR 79
97552: PUSH
97553: LD_INT 0
97555: ST_TO_ADDR
// wait ( 5 5$00 ) ;
97556: LD_INT 10500
97558: PPUSH
97559: CALL_OW 67
// solar_recharge_percent := 100 ;
97563: LD_ADDR_OWVAR 79
97567: PUSH
97568: LD_INT 100
97570: ST_TO_ADDR
// end ;
97571: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
97572: LD_EXP 107
97576: PUSH
97577: LD_EXP 131
97581: AND
97582: IFFALSE 97821
97584: GO 97586
97586: DISABLE
97587: LD_INT 0
97589: PPUSH
97590: PPUSH
97591: PPUSH
// begin tmp := [ ] ;
97592: LD_ADDR_VAR 0 3
97596: PUSH
97597: EMPTY
97598: ST_TO_ADDR
// for i := 1 to 6 do
97599: LD_ADDR_VAR 0 1
97603: PUSH
97604: DOUBLE
97605: LD_INT 1
97607: DEC
97608: ST_TO_ADDR
97609: LD_INT 6
97611: PUSH
97612: FOR_TO
97613: IFFALSE 97718
// begin uc_nation := nation_nature ;
97615: LD_ADDR_OWVAR 21
97619: PUSH
97620: LD_INT 0
97622: ST_TO_ADDR
// uc_side := 0 ;
97623: LD_ADDR_OWVAR 20
97627: PUSH
97628: LD_INT 0
97630: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97631: LD_ADDR_OWVAR 29
97635: PUSH
97636: LD_INT 12
97638: PUSH
97639: LD_INT 12
97641: PUSH
97642: EMPTY
97643: LIST
97644: LIST
97645: ST_TO_ADDR
// hc_agressivity := 20 ;
97646: LD_ADDR_OWVAR 35
97650: PUSH
97651: LD_INT 20
97653: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
97654: LD_ADDR_OWVAR 28
97658: PUSH
97659: LD_INT 17
97661: ST_TO_ADDR
// hc_gallery :=  ;
97662: LD_ADDR_OWVAR 33
97666: PUSH
97667: LD_STRING 
97669: ST_TO_ADDR
// hc_name :=  ;
97670: LD_ADDR_OWVAR 26
97674: PUSH
97675: LD_STRING 
97677: ST_TO_ADDR
// un := CreateHuman ;
97678: LD_ADDR_VAR 0 2
97682: PUSH
97683: CALL_OW 44
97687: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
97688: LD_VAR 0 2
97692: PPUSH
97693: LD_INT 1
97695: PPUSH
97696: CALL_OW 51
// tmp := tmp ^ un ;
97700: LD_ADDR_VAR 0 3
97704: PUSH
97705: LD_VAR 0 3
97709: PUSH
97710: LD_VAR 0 2
97714: ADD
97715: ST_TO_ADDR
// end ;
97716: GO 97612
97718: POP
97719: POP
// repeat wait ( 0 0$1 ) ;
97720: LD_INT 35
97722: PPUSH
97723: CALL_OW 67
// for un in tmp do
97727: LD_ADDR_VAR 0 2
97731: PUSH
97732: LD_VAR 0 3
97736: PUSH
97737: FOR_IN
97738: IFFALSE 97812
// begin if IsDead ( un ) then
97740: LD_VAR 0 2
97744: PPUSH
97745: CALL_OW 301
97749: IFFALSE 97769
// begin tmp := tmp diff un ;
97751: LD_ADDR_VAR 0 3
97755: PUSH
97756: LD_VAR 0 3
97760: PUSH
97761: LD_VAR 0 2
97765: DIFF
97766: ST_TO_ADDR
// continue ;
97767: GO 97737
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
97769: LD_VAR 0 2
97773: PPUSH
97774: LD_INT 3
97776: PUSH
97777: LD_INT 22
97779: PUSH
97780: LD_INT 0
97782: PUSH
97783: EMPTY
97784: LIST
97785: LIST
97786: PUSH
97787: EMPTY
97788: LIST
97789: LIST
97790: PPUSH
97791: CALL_OW 69
97795: PPUSH
97796: LD_VAR 0 2
97800: PPUSH
97801: CALL_OW 74
97805: PPUSH
97806: CALL_OW 115
// end ;
97810: GO 97737
97812: POP
97813: POP
// until not tmp ;
97814: LD_VAR 0 3
97818: NOT
97819: IFFALSE 97720
// end ;
97821: PPOPN 3
97823: END
// every 0 0$1 trigger StreamModeActive and sTroll do
97824: LD_EXP 107
97828: PUSH
97829: LD_EXP 132
97833: AND
97834: IFFALSE 97888
97836: GO 97838
97838: DISABLE
// begin ToLua ( displayTroll(); ) ;
97839: LD_STRING displayTroll();
97841: PPUSH
97842: CALL_OW 559
// wait ( 3 3$00 ) ;
97846: LD_INT 6300
97848: PPUSH
97849: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97853: LD_STRING hideTroll();
97855: PPUSH
97856: CALL_OW 559
// wait ( 1 1$00 ) ;
97860: LD_INT 2100
97862: PPUSH
97863: CALL_OW 67
// ToLua ( displayTroll(); ) ;
97867: LD_STRING displayTroll();
97869: PPUSH
97870: CALL_OW 559
// wait ( 1 1$00 ) ;
97874: LD_INT 2100
97876: PPUSH
97877: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97881: LD_STRING hideTroll();
97883: PPUSH
97884: CALL_OW 559
// end ;
97888: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
97889: LD_EXP 107
97893: PUSH
97894: LD_EXP 133
97898: AND
97899: IFFALSE 97962
97901: GO 97903
97903: DISABLE
97904: LD_INT 0
97906: PPUSH
// begin p := 0 ;
97907: LD_ADDR_VAR 0 1
97911: PUSH
97912: LD_INT 0
97914: ST_TO_ADDR
// repeat game_speed := 1 ;
97915: LD_ADDR_OWVAR 65
97919: PUSH
97920: LD_INT 1
97922: ST_TO_ADDR
// wait ( 0 0$1 ) ;
97923: LD_INT 35
97925: PPUSH
97926: CALL_OW 67
// p := p + 1 ;
97930: LD_ADDR_VAR 0 1
97934: PUSH
97935: LD_VAR 0 1
97939: PUSH
97940: LD_INT 1
97942: PLUS
97943: ST_TO_ADDR
// until p >= 60 ;
97944: LD_VAR 0 1
97948: PUSH
97949: LD_INT 60
97951: GREATEREQUAL
97952: IFFALSE 97915
// game_speed := 4 ;
97954: LD_ADDR_OWVAR 65
97958: PUSH
97959: LD_INT 4
97961: ST_TO_ADDR
// end ;
97962: PPOPN 1
97964: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
97965: LD_EXP 107
97969: PUSH
97970: LD_EXP 134
97974: AND
97975: IFFALSE 98121
97977: GO 97979
97979: DISABLE
97980: LD_INT 0
97982: PPUSH
97983: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97984: LD_ADDR_VAR 0 1
97988: PUSH
97989: LD_INT 22
97991: PUSH
97992: LD_OWVAR 2
97996: PUSH
97997: EMPTY
97998: LIST
97999: LIST
98000: PUSH
98001: LD_INT 2
98003: PUSH
98004: LD_INT 30
98006: PUSH
98007: LD_INT 0
98009: PUSH
98010: EMPTY
98011: LIST
98012: LIST
98013: PUSH
98014: LD_INT 30
98016: PUSH
98017: LD_INT 1
98019: PUSH
98020: EMPTY
98021: LIST
98022: LIST
98023: PUSH
98024: EMPTY
98025: LIST
98026: LIST
98027: LIST
98028: PUSH
98029: EMPTY
98030: LIST
98031: LIST
98032: PPUSH
98033: CALL_OW 69
98037: ST_TO_ADDR
// if not depot then
98038: LD_VAR 0 1
98042: NOT
98043: IFFALSE 98047
// exit ;
98045: GO 98121
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
98047: LD_ADDR_VAR 0 2
98051: PUSH
98052: LD_VAR 0 1
98056: PUSH
98057: LD_INT 1
98059: PPUSH
98060: LD_VAR 0 1
98064: PPUSH
98065: CALL_OW 12
98069: ARRAY
98070: PPUSH
98071: CALL_OW 274
98075: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
98076: LD_VAR 0 2
98080: PPUSH
98081: LD_INT 1
98083: PPUSH
98084: LD_INT 0
98086: PPUSH
98087: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
98091: LD_VAR 0 2
98095: PPUSH
98096: LD_INT 2
98098: PPUSH
98099: LD_INT 0
98101: PPUSH
98102: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
98106: LD_VAR 0 2
98110: PPUSH
98111: LD_INT 3
98113: PPUSH
98114: LD_INT 0
98116: PPUSH
98117: CALL_OW 277
// end ;
98121: PPOPN 2
98123: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
98124: LD_EXP 107
98128: PUSH
98129: LD_EXP 135
98133: AND
98134: IFFALSE 98231
98136: GO 98138
98138: DISABLE
98139: LD_INT 0
98141: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98142: LD_ADDR_VAR 0 1
98146: PUSH
98147: LD_INT 22
98149: PUSH
98150: LD_OWVAR 2
98154: PUSH
98155: EMPTY
98156: LIST
98157: LIST
98158: PUSH
98159: LD_INT 21
98161: PUSH
98162: LD_INT 1
98164: PUSH
98165: EMPTY
98166: LIST
98167: LIST
98168: PUSH
98169: LD_INT 3
98171: PUSH
98172: LD_INT 23
98174: PUSH
98175: LD_INT 0
98177: PUSH
98178: EMPTY
98179: LIST
98180: LIST
98181: PUSH
98182: EMPTY
98183: LIST
98184: LIST
98185: PUSH
98186: EMPTY
98187: LIST
98188: LIST
98189: LIST
98190: PPUSH
98191: CALL_OW 69
98195: ST_TO_ADDR
// if not tmp then
98196: LD_VAR 0 1
98200: NOT
98201: IFFALSE 98205
// exit ;
98203: GO 98231
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
98205: LD_VAR 0 1
98209: PUSH
98210: LD_INT 1
98212: PPUSH
98213: LD_VAR 0 1
98217: PPUSH
98218: CALL_OW 12
98222: ARRAY
98223: PPUSH
98224: LD_INT 200
98226: PPUSH
98227: CALL_OW 234
// end ;
98231: PPOPN 1
98233: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
98234: LD_EXP 107
98238: PUSH
98239: LD_EXP 136
98243: AND
98244: IFFALSE 98323
98246: GO 98248
98248: DISABLE
98249: LD_INT 0
98251: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98252: LD_ADDR_VAR 0 1
98256: PUSH
98257: LD_INT 22
98259: PUSH
98260: LD_OWVAR 2
98264: PUSH
98265: EMPTY
98266: LIST
98267: LIST
98268: PUSH
98269: LD_INT 21
98271: PUSH
98272: LD_INT 2
98274: PUSH
98275: EMPTY
98276: LIST
98277: LIST
98278: PUSH
98279: EMPTY
98280: LIST
98281: LIST
98282: PPUSH
98283: CALL_OW 69
98287: ST_TO_ADDR
// if not tmp then
98288: LD_VAR 0 1
98292: NOT
98293: IFFALSE 98297
// exit ;
98295: GO 98323
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
98297: LD_VAR 0 1
98301: PUSH
98302: LD_INT 1
98304: PPUSH
98305: LD_VAR 0 1
98309: PPUSH
98310: CALL_OW 12
98314: ARRAY
98315: PPUSH
98316: LD_INT 60
98318: PPUSH
98319: CALL_OW 234
// end ;
98323: PPOPN 1
98325: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
98326: LD_EXP 107
98330: PUSH
98331: LD_EXP 137
98335: AND
98336: IFFALSE 98435
98338: GO 98340
98340: DISABLE
98341: LD_INT 0
98343: PPUSH
98344: PPUSH
// begin enable ;
98345: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
98346: LD_ADDR_VAR 0 1
98350: PUSH
98351: LD_INT 22
98353: PUSH
98354: LD_OWVAR 2
98358: PUSH
98359: EMPTY
98360: LIST
98361: LIST
98362: PUSH
98363: LD_INT 61
98365: PUSH
98366: EMPTY
98367: LIST
98368: PUSH
98369: LD_INT 33
98371: PUSH
98372: LD_INT 2
98374: PUSH
98375: EMPTY
98376: LIST
98377: LIST
98378: PUSH
98379: EMPTY
98380: LIST
98381: LIST
98382: LIST
98383: PPUSH
98384: CALL_OW 69
98388: ST_TO_ADDR
// if not tmp then
98389: LD_VAR 0 1
98393: NOT
98394: IFFALSE 98398
// exit ;
98396: GO 98435
// for i in tmp do
98398: LD_ADDR_VAR 0 2
98402: PUSH
98403: LD_VAR 0 1
98407: PUSH
98408: FOR_IN
98409: IFFALSE 98433
// if IsControledBy ( i ) then
98411: LD_VAR 0 2
98415: PPUSH
98416: CALL_OW 312
98420: IFFALSE 98431
// ComUnlink ( i ) ;
98422: LD_VAR 0 2
98426: PPUSH
98427: CALL_OW 136
98431: GO 98408
98433: POP
98434: POP
// end ;
98435: PPOPN 2
98437: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
98438: LD_EXP 107
98442: PUSH
98443: LD_EXP 138
98447: AND
98448: IFFALSE 98588
98450: GO 98452
98452: DISABLE
98453: LD_INT 0
98455: PPUSH
98456: PPUSH
// begin ToLua ( displayPowell(); ) ;
98457: LD_STRING displayPowell();
98459: PPUSH
98460: CALL_OW 559
// uc_side := 0 ;
98464: LD_ADDR_OWVAR 20
98468: PUSH
98469: LD_INT 0
98471: ST_TO_ADDR
// uc_nation := 2 ;
98472: LD_ADDR_OWVAR 21
98476: PUSH
98477: LD_INT 2
98479: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
98480: LD_ADDR_OWVAR 37
98484: PUSH
98485: LD_INT 14
98487: ST_TO_ADDR
// vc_engine := engine_siberite ;
98488: LD_ADDR_OWVAR 39
98492: PUSH
98493: LD_INT 3
98495: ST_TO_ADDR
// vc_control := control_apeman ;
98496: LD_ADDR_OWVAR 38
98500: PUSH
98501: LD_INT 5
98503: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
98504: LD_ADDR_OWVAR 40
98508: PUSH
98509: LD_INT 29
98511: ST_TO_ADDR
// un := CreateVehicle ;
98512: LD_ADDR_VAR 0 2
98516: PUSH
98517: CALL_OW 45
98521: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98522: LD_VAR 0 2
98526: PPUSH
98527: LD_INT 1
98529: PPUSH
98530: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
98534: LD_INT 35
98536: PPUSH
98537: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
98541: LD_VAR 0 2
98545: PPUSH
98546: LD_INT 22
98548: PUSH
98549: LD_OWVAR 2
98553: PUSH
98554: EMPTY
98555: LIST
98556: LIST
98557: PPUSH
98558: CALL_OW 69
98562: PPUSH
98563: LD_VAR 0 2
98567: PPUSH
98568: CALL_OW 74
98572: PPUSH
98573: CALL_OW 115
// until IsDead ( un ) ;
98577: LD_VAR 0 2
98581: PPUSH
98582: CALL_OW 301
98586: IFFALSE 98534
// end ;
98588: PPOPN 2
98590: END
// every 0 0$1 trigger StreamModeActive and sStu do
98591: LD_EXP 107
98595: PUSH
98596: LD_EXP 146
98600: AND
98601: IFFALSE 98617
98603: GO 98605
98605: DISABLE
// begin ToLua ( displayStucuk(); ) ;
98606: LD_STRING displayStucuk();
98608: PPUSH
98609: CALL_OW 559
// ResetFog ;
98613: CALL_OW 335
// end ;
98617: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
98618: LD_EXP 107
98622: PUSH
98623: LD_EXP 139
98627: AND
98628: IFFALSE 98769
98630: GO 98632
98632: DISABLE
98633: LD_INT 0
98635: PPUSH
98636: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98637: LD_ADDR_VAR 0 2
98641: PUSH
98642: LD_INT 22
98644: PUSH
98645: LD_OWVAR 2
98649: PUSH
98650: EMPTY
98651: LIST
98652: LIST
98653: PUSH
98654: LD_INT 21
98656: PUSH
98657: LD_INT 1
98659: PUSH
98660: EMPTY
98661: LIST
98662: LIST
98663: PUSH
98664: EMPTY
98665: LIST
98666: LIST
98667: PPUSH
98668: CALL_OW 69
98672: ST_TO_ADDR
// if not tmp then
98673: LD_VAR 0 2
98677: NOT
98678: IFFALSE 98682
// exit ;
98680: GO 98769
// un := tmp [ rand ( 1 , tmp ) ] ;
98682: LD_ADDR_VAR 0 1
98686: PUSH
98687: LD_VAR 0 2
98691: PUSH
98692: LD_INT 1
98694: PPUSH
98695: LD_VAR 0 2
98699: PPUSH
98700: CALL_OW 12
98704: ARRAY
98705: ST_TO_ADDR
// SetSide ( un , 0 ) ;
98706: LD_VAR 0 1
98710: PPUSH
98711: LD_INT 0
98713: PPUSH
98714: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
98718: LD_VAR 0 1
98722: PPUSH
98723: LD_OWVAR 3
98727: PUSH
98728: LD_VAR 0 1
98732: DIFF
98733: PPUSH
98734: LD_VAR 0 1
98738: PPUSH
98739: CALL_OW 74
98743: PPUSH
98744: CALL_OW 115
// wait ( 0 0$20 ) ;
98748: LD_INT 700
98750: PPUSH
98751: CALL_OW 67
// SetSide ( un , your_side ) ;
98755: LD_VAR 0 1
98759: PPUSH
98760: LD_OWVAR 2
98764: PPUSH
98765: CALL_OW 235
// end ;
98769: PPOPN 2
98771: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
98772: LD_EXP 107
98776: PUSH
98777: LD_EXP 140
98781: AND
98782: IFFALSE 98888
98784: GO 98786
98786: DISABLE
98787: LD_INT 0
98789: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98790: LD_ADDR_VAR 0 1
98794: PUSH
98795: LD_INT 22
98797: PUSH
98798: LD_OWVAR 2
98802: PUSH
98803: EMPTY
98804: LIST
98805: LIST
98806: PUSH
98807: LD_INT 2
98809: PUSH
98810: LD_INT 30
98812: PUSH
98813: LD_INT 0
98815: PUSH
98816: EMPTY
98817: LIST
98818: LIST
98819: PUSH
98820: LD_INT 30
98822: PUSH
98823: LD_INT 1
98825: PUSH
98826: EMPTY
98827: LIST
98828: LIST
98829: PUSH
98830: EMPTY
98831: LIST
98832: LIST
98833: LIST
98834: PUSH
98835: EMPTY
98836: LIST
98837: LIST
98838: PPUSH
98839: CALL_OW 69
98843: ST_TO_ADDR
// if not depot then
98844: LD_VAR 0 1
98848: NOT
98849: IFFALSE 98853
// exit ;
98851: GO 98888
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
98853: LD_VAR 0 1
98857: PUSH
98858: LD_INT 1
98860: ARRAY
98861: PPUSH
98862: CALL_OW 250
98866: PPUSH
98867: LD_VAR 0 1
98871: PUSH
98872: LD_INT 1
98874: ARRAY
98875: PPUSH
98876: CALL_OW 251
98880: PPUSH
98881: LD_INT 70
98883: PPUSH
98884: CALL_OW 495
// end ;
98888: PPOPN 1
98890: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
98891: LD_EXP 107
98895: PUSH
98896: LD_EXP 141
98900: AND
98901: IFFALSE 99112
98903: GO 98905
98905: DISABLE
98906: LD_INT 0
98908: PPUSH
98909: PPUSH
98910: PPUSH
98911: PPUSH
98912: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98913: LD_ADDR_VAR 0 5
98917: PUSH
98918: LD_INT 22
98920: PUSH
98921: LD_OWVAR 2
98925: PUSH
98926: EMPTY
98927: LIST
98928: LIST
98929: PUSH
98930: LD_INT 21
98932: PUSH
98933: LD_INT 1
98935: PUSH
98936: EMPTY
98937: LIST
98938: LIST
98939: PUSH
98940: EMPTY
98941: LIST
98942: LIST
98943: PPUSH
98944: CALL_OW 69
98948: ST_TO_ADDR
// if not tmp then
98949: LD_VAR 0 5
98953: NOT
98954: IFFALSE 98958
// exit ;
98956: GO 99112
// for i in tmp do
98958: LD_ADDR_VAR 0 1
98962: PUSH
98963: LD_VAR 0 5
98967: PUSH
98968: FOR_IN
98969: IFFALSE 99110
// begin d := rand ( 0 , 5 ) ;
98971: LD_ADDR_VAR 0 4
98975: PUSH
98976: LD_INT 0
98978: PPUSH
98979: LD_INT 5
98981: PPUSH
98982: CALL_OW 12
98986: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
98987: LD_ADDR_VAR 0 2
98991: PUSH
98992: LD_VAR 0 1
98996: PPUSH
98997: CALL_OW 250
99001: PPUSH
99002: LD_VAR 0 4
99006: PPUSH
99007: LD_INT 3
99009: PPUSH
99010: LD_INT 12
99012: PPUSH
99013: CALL_OW 12
99017: PPUSH
99018: CALL_OW 272
99022: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99023: LD_ADDR_VAR 0 3
99027: PUSH
99028: LD_VAR 0 1
99032: PPUSH
99033: CALL_OW 251
99037: PPUSH
99038: LD_VAR 0 4
99042: PPUSH
99043: LD_INT 3
99045: PPUSH
99046: LD_INT 12
99048: PPUSH
99049: CALL_OW 12
99053: PPUSH
99054: CALL_OW 273
99058: ST_TO_ADDR
// if ValidHex ( x , y ) then
99059: LD_VAR 0 2
99063: PPUSH
99064: LD_VAR 0 3
99068: PPUSH
99069: CALL_OW 488
99073: IFFALSE 99108
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
99075: LD_VAR 0 1
99079: PPUSH
99080: LD_VAR 0 2
99084: PPUSH
99085: LD_VAR 0 3
99089: PPUSH
99090: LD_INT 3
99092: PPUSH
99093: LD_INT 6
99095: PPUSH
99096: CALL_OW 12
99100: PPUSH
99101: LD_INT 1
99103: PPUSH
99104: CALL_OW 483
// end ;
99108: GO 98968
99110: POP
99111: POP
// end ;
99112: PPOPN 5
99114: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
99115: LD_EXP 107
99119: PUSH
99120: LD_EXP 142
99124: AND
99125: IFFALSE 99219
99127: GO 99129
99129: DISABLE
99130: LD_INT 0
99132: PPUSH
99133: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
99134: LD_ADDR_VAR 0 2
99138: PUSH
99139: LD_INT 22
99141: PUSH
99142: LD_OWVAR 2
99146: PUSH
99147: EMPTY
99148: LIST
99149: LIST
99150: PUSH
99151: LD_INT 32
99153: PUSH
99154: LD_INT 1
99156: PUSH
99157: EMPTY
99158: LIST
99159: LIST
99160: PUSH
99161: LD_INT 21
99163: PUSH
99164: LD_INT 2
99166: PUSH
99167: EMPTY
99168: LIST
99169: LIST
99170: PUSH
99171: EMPTY
99172: LIST
99173: LIST
99174: LIST
99175: PPUSH
99176: CALL_OW 69
99180: ST_TO_ADDR
// if not tmp then
99181: LD_VAR 0 2
99185: NOT
99186: IFFALSE 99190
// exit ;
99188: GO 99219
// for i in tmp do
99190: LD_ADDR_VAR 0 1
99194: PUSH
99195: LD_VAR 0 2
99199: PUSH
99200: FOR_IN
99201: IFFALSE 99217
// SetFuel ( i , 0 ) ;
99203: LD_VAR 0 1
99207: PPUSH
99208: LD_INT 0
99210: PPUSH
99211: CALL_OW 240
99215: GO 99200
99217: POP
99218: POP
// end ;
99219: PPOPN 2
99221: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
99222: LD_EXP 107
99226: PUSH
99227: LD_EXP 143
99231: AND
99232: IFFALSE 99298
99234: GO 99236
99236: DISABLE
99237: LD_INT 0
99239: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99240: LD_ADDR_VAR 0 1
99244: PUSH
99245: LD_INT 22
99247: PUSH
99248: LD_OWVAR 2
99252: PUSH
99253: EMPTY
99254: LIST
99255: LIST
99256: PUSH
99257: LD_INT 30
99259: PUSH
99260: LD_INT 29
99262: PUSH
99263: EMPTY
99264: LIST
99265: LIST
99266: PUSH
99267: EMPTY
99268: LIST
99269: LIST
99270: PPUSH
99271: CALL_OW 69
99275: ST_TO_ADDR
// if not tmp then
99276: LD_VAR 0 1
99280: NOT
99281: IFFALSE 99285
// exit ;
99283: GO 99298
// DestroyUnit ( tmp [ 1 ] ) ;
99285: LD_VAR 0 1
99289: PUSH
99290: LD_INT 1
99292: ARRAY
99293: PPUSH
99294: CALL_OW 65
// end ;
99298: PPOPN 1
99300: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
99301: LD_EXP 107
99305: PUSH
99306: LD_EXP 145
99310: AND
99311: IFFALSE 99440
99313: GO 99315
99315: DISABLE
99316: LD_INT 0
99318: PPUSH
// begin uc_side := 0 ;
99319: LD_ADDR_OWVAR 20
99323: PUSH
99324: LD_INT 0
99326: ST_TO_ADDR
// uc_nation := nation_arabian ;
99327: LD_ADDR_OWVAR 21
99331: PUSH
99332: LD_INT 2
99334: ST_TO_ADDR
// hc_gallery :=  ;
99335: LD_ADDR_OWVAR 33
99339: PUSH
99340: LD_STRING 
99342: ST_TO_ADDR
// hc_name :=  ;
99343: LD_ADDR_OWVAR 26
99347: PUSH
99348: LD_STRING 
99350: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
99351: LD_INT 1
99353: PPUSH
99354: LD_INT 11
99356: PPUSH
99357: LD_INT 10
99359: PPUSH
99360: CALL_OW 380
// un := CreateHuman ;
99364: LD_ADDR_VAR 0 1
99368: PUSH
99369: CALL_OW 44
99373: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99374: LD_VAR 0 1
99378: PPUSH
99379: LD_INT 1
99381: PPUSH
99382: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99386: LD_INT 35
99388: PPUSH
99389: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99393: LD_VAR 0 1
99397: PPUSH
99398: LD_INT 22
99400: PUSH
99401: LD_OWVAR 2
99405: PUSH
99406: EMPTY
99407: LIST
99408: LIST
99409: PPUSH
99410: CALL_OW 69
99414: PPUSH
99415: LD_VAR 0 1
99419: PPUSH
99420: CALL_OW 74
99424: PPUSH
99425: CALL_OW 115
// until IsDead ( un ) ;
99429: LD_VAR 0 1
99433: PPUSH
99434: CALL_OW 301
99438: IFFALSE 99386
// end ;
99440: PPOPN 1
99442: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
99443: LD_EXP 107
99447: PUSH
99448: LD_EXP 147
99452: AND
99453: IFFALSE 99465
99455: GO 99457
99457: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
99458: LD_STRING earthquake(getX(game), 0, 32)
99460: PPUSH
99461: CALL_OW 559
99465: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
99466: LD_EXP 107
99470: PUSH
99471: LD_EXP 148
99475: AND
99476: IFFALSE 99567
99478: GO 99480
99480: DISABLE
99481: LD_INT 0
99483: PPUSH
// begin enable ;
99484: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
99485: LD_ADDR_VAR 0 1
99489: PUSH
99490: LD_INT 22
99492: PUSH
99493: LD_OWVAR 2
99497: PUSH
99498: EMPTY
99499: LIST
99500: LIST
99501: PUSH
99502: LD_INT 21
99504: PUSH
99505: LD_INT 2
99507: PUSH
99508: EMPTY
99509: LIST
99510: LIST
99511: PUSH
99512: LD_INT 33
99514: PUSH
99515: LD_INT 3
99517: PUSH
99518: EMPTY
99519: LIST
99520: LIST
99521: PUSH
99522: EMPTY
99523: LIST
99524: LIST
99525: LIST
99526: PPUSH
99527: CALL_OW 69
99531: ST_TO_ADDR
// if not tmp then
99532: LD_VAR 0 1
99536: NOT
99537: IFFALSE 99541
// exit ;
99539: GO 99567
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
99541: LD_VAR 0 1
99545: PUSH
99546: LD_INT 1
99548: PPUSH
99549: LD_VAR 0 1
99553: PPUSH
99554: CALL_OW 12
99558: ARRAY
99559: PPUSH
99560: LD_INT 1
99562: PPUSH
99563: CALL_OW 234
// end ;
99567: PPOPN 1
99569: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
99570: LD_EXP 107
99574: PUSH
99575: LD_EXP 149
99579: AND
99580: IFFALSE 99721
99582: GO 99584
99584: DISABLE
99585: LD_INT 0
99587: PPUSH
99588: PPUSH
99589: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99590: LD_ADDR_VAR 0 3
99594: PUSH
99595: LD_INT 22
99597: PUSH
99598: LD_OWVAR 2
99602: PUSH
99603: EMPTY
99604: LIST
99605: LIST
99606: PUSH
99607: LD_INT 25
99609: PUSH
99610: LD_INT 1
99612: PUSH
99613: EMPTY
99614: LIST
99615: LIST
99616: PUSH
99617: EMPTY
99618: LIST
99619: LIST
99620: PPUSH
99621: CALL_OW 69
99625: ST_TO_ADDR
// if not tmp then
99626: LD_VAR 0 3
99630: NOT
99631: IFFALSE 99635
// exit ;
99633: GO 99721
// un := tmp [ rand ( 1 , tmp ) ] ;
99635: LD_ADDR_VAR 0 2
99639: PUSH
99640: LD_VAR 0 3
99644: PUSH
99645: LD_INT 1
99647: PPUSH
99648: LD_VAR 0 3
99652: PPUSH
99653: CALL_OW 12
99657: ARRAY
99658: ST_TO_ADDR
// if Crawls ( un ) then
99659: LD_VAR 0 2
99663: PPUSH
99664: CALL_OW 318
99668: IFFALSE 99679
// ComWalk ( un ) ;
99670: LD_VAR 0 2
99674: PPUSH
99675: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
99679: LD_VAR 0 2
99683: PPUSH
99684: LD_INT 9
99686: PPUSH
99687: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
99691: LD_INT 28
99693: PPUSH
99694: LD_OWVAR 2
99698: PPUSH
99699: LD_INT 2
99701: PPUSH
99702: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
99706: LD_INT 29
99708: PPUSH
99709: LD_OWVAR 2
99713: PPUSH
99714: LD_INT 2
99716: PPUSH
99717: CALL_OW 322
// end ;
99721: PPOPN 3
99723: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
99724: LD_EXP 107
99728: PUSH
99729: LD_EXP 150
99733: AND
99734: IFFALSE 99845
99736: GO 99738
99738: DISABLE
99739: LD_INT 0
99741: PPUSH
99742: PPUSH
99743: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99744: LD_ADDR_VAR 0 3
99748: PUSH
99749: LD_INT 22
99751: PUSH
99752: LD_OWVAR 2
99756: PUSH
99757: EMPTY
99758: LIST
99759: LIST
99760: PUSH
99761: LD_INT 25
99763: PUSH
99764: LD_INT 1
99766: PUSH
99767: EMPTY
99768: LIST
99769: LIST
99770: PUSH
99771: EMPTY
99772: LIST
99773: LIST
99774: PPUSH
99775: CALL_OW 69
99779: ST_TO_ADDR
// if not tmp then
99780: LD_VAR 0 3
99784: NOT
99785: IFFALSE 99789
// exit ;
99787: GO 99845
// un := tmp [ rand ( 1 , tmp ) ] ;
99789: LD_ADDR_VAR 0 2
99793: PUSH
99794: LD_VAR 0 3
99798: PUSH
99799: LD_INT 1
99801: PPUSH
99802: LD_VAR 0 3
99806: PPUSH
99807: CALL_OW 12
99811: ARRAY
99812: ST_TO_ADDR
// if Crawls ( un ) then
99813: LD_VAR 0 2
99817: PPUSH
99818: CALL_OW 318
99822: IFFALSE 99833
// ComWalk ( un ) ;
99824: LD_VAR 0 2
99828: PPUSH
99829: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99833: LD_VAR 0 2
99837: PPUSH
99838: LD_INT 8
99840: PPUSH
99841: CALL_OW 336
// end ;
99845: PPOPN 3
99847: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
99848: LD_EXP 107
99852: PUSH
99853: LD_EXP 151
99857: AND
99858: IFFALSE 100002
99860: GO 99862
99862: DISABLE
99863: LD_INT 0
99865: PPUSH
99866: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
99867: LD_ADDR_VAR 0 2
99871: PUSH
99872: LD_INT 22
99874: PUSH
99875: LD_OWVAR 2
99879: PUSH
99880: EMPTY
99881: LIST
99882: LIST
99883: PUSH
99884: LD_INT 21
99886: PUSH
99887: LD_INT 2
99889: PUSH
99890: EMPTY
99891: LIST
99892: LIST
99893: PUSH
99894: LD_INT 2
99896: PUSH
99897: LD_INT 34
99899: PUSH
99900: LD_INT 12
99902: PUSH
99903: EMPTY
99904: LIST
99905: LIST
99906: PUSH
99907: LD_INT 34
99909: PUSH
99910: LD_INT 51
99912: PUSH
99913: EMPTY
99914: LIST
99915: LIST
99916: PUSH
99917: LD_INT 34
99919: PUSH
99920: LD_INT 32
99922: PUSH
99923: EMPTY
99924: LIST
99925: LIST
99926: PUSH
99927: EMPTY
99928: LIST
99929: LIST
99930: LIST
99931: LIST
99932: PUSH
99933: EMPTY
99934: LIST
99935: LIST
99936: LIST
99937: PPUSH
99938: CALL_OW 69
99942: ST_TO_ADDR
// if not tmp then
99943: LD_VAR 0 2
99947: NOT
99948: IFFALSE 99952
// exit ;
99950: GO 100002
// for i in tmp do
99952: LD_ADDR_VAR 0 1
99956: PUSH
99957: LD_VAR 0 2
99961: PUSH
99962: FOR_IN
99963: IFFALSE 100000
// if GetCargo ( i , mat_artifact ) = 0 then
99965: LD_VAR 0 1
99969: PPUSH
99970: LD_INT 4
99972: PPUSH
99973: CALL_OW 289
99977: PUSH
99978: LD_INT 0
99980: EQUAL
99981: IFFALSE 99998
// SetCargo ( i , mat_siberit , 100 ) ;
99983: LD_VAR 0 1
99987: PPUSH
99988: LD_INT 3
99990: PPUSH
99991: LD_INT 100
99993: PPUSH
99994: CALL_OW 290
99998: GO 99962
100000: POP
100001: POP
// end ;
100002: PPOPN 2
100004: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100005: LD_EXP 107
100009: PUSH
100010: LD_EXP 152
100014: AND
100015: IFFALSE 100198
100017: GO 100019
100019: DISABLE
100020: LD_INT 0
100022: PPUSH
100023: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100024: LD_ADDR_VAR 0 2
100028: PUSH
100029: LD_INT 22
100031: PUSH
100032: LD_OWVAR 2
100036: PUSH
100037: EMPTY
100038: LIST
100039: LIST
100040: PPUSH
100041: CALL_OW 69
100045: ST_TO_ADDR
// if not tmp then
100046: LD_VAR 0 2
100050: NOT
100051: IFFALSE 100055
// exit ;
100053: GO 100198
// for i := 1 to 2 do
100055: LD_ADDR_VAR 0 1
100059: PUSH
100060: DOUBLE
100061: LD_INT 1
100063: DEC
100064: ST_TO_ADDR
100065: LD_INT 2
100067: PUSH
100068: FOR_TO
100069: IFFALSE 100196
// begin uc_side := your_side ;
100071: LD_ADDR_OWVAR 20
100075: PUSH
100076: LD_OWVAR 2
100080: ST_TO_ADDR
// uc_nation := nation_american ;
100081: LD_ADDR_OWVAR 21
100085: PUSH
100086: LD_INT 1
100088: ST_TO_ADDR
// vc_chassis := us_morphling ;
100089: LD_ADDR_OWVAR 37
100093: PUSH
100094: LD_INT 5
100096: ST_TO_ADDR
// vc_engine := engine_siberite ;
100097: LD_ADDR_OWVAR 39
100101: PUSH
100102: LD_INT 3
100104: ST_TO_ADDR
// vc_control := control_computer ;
100105: LD_ADDR_OWVAR 38
100109: PUSH
100110: LD_INT 3
100112: ST_TO_ADDR
// vc_weapon := us_double_laser ;
100113: LD_ADDR_OWVAR 40
100117: PUSH
100118: LD_INT 10
100120: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
100121: LD_VAR 0 2
100125: PUSH
100126: LD_INT 1
100128: ARRAY
100129: PPUSH
100130: CALL_OW 310
100134: NOT
100135: IFFALSE 100182
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
100137: CALL_OW 45
100141: PPUSH
100142: LD_VAR 0 2
100146: PUSH
100147: LD_INT 1
100149: ARRAY
100150: PPUSH
100151: CALL_OW 250
100155: PPUSH
100156: LD_VAR 0 2
100160: PUSH
100161: LD_INT 1
100163: ARRAY
100164: PPUSH
100165: CALL_OW 251
100169: PPUSH
100170: LD_INT 12
100172: PPUSH
100173: LD_INT 1
100175: PPUSH
100176: CALL_OW 50
100180: GO 100194
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
100182: CALL_OW 45
100186: PPUSH
100187: LD_INT 1
100189: PPUSH
100190: CALL_OW 51
// end ;
100194: GO 100068
100196: POP
100197: POP
// end ;
100198: PPOPN 2
100200: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
100201: LD_EXP 107
100205: PUSH
100206: LD_EXP 153
100210: AND
100211: IFFALSE 100433
100213: GO 100215
100215: DISABLE
100216: LD_INT 0
100218: PPUSH
100219: PPUSH
100220: PPUSH
100221: PPUSH
100222: PPUSH
100223: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100224: LD_ADDR_VAR 0 6
100228: PUSH
100229: LD_INT 22
100231: PUSH
100232: LD_OWVAR 2
100236: PUSH
100237: EMPTY
100238: LIST
100239: LIST
100240: PUSH
100241: LD_INT 21
100243: PUSH
100244: LD_INT 1
100246: PUSH
100247: EMPTY
100248: LIST
100249: LIST
100250: PUSH
100251: LD_INT 3
100253: PUSH
100254: LD_INT 23
100256: PUSH
100257: LD_INT 0
100259: PUSH
100260: EMPTY
100261: LIST
100262: LIST
100263: PUSH
100264: EMPTY
100265: LIST
100266: LIST
100267: PUSH
100268: EMPTY
100269: LIST
100270: LIST
100271: LIST
100272: PPUSH
100273: CALL_OW 69
100277: ST_TO_ADDR
// if not tmp then
100278: LD_VAR 0 6
100282: NOT
100283: IFFALSE 100287
// exit ;
100285: GO 100433
// s1 := rand ( 1 , 4 ) ;
100287: LD_ADDR_VAR 0 2
100291: PUSH
100292: LD_INT 1
100294: PPUSH
100295: LD_INT 4
100297: PPUSH
100298: CALL_OW 12
100302: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
100303: LD_ADDR_VAR 0 4
100307: PUSH
100308: LD_VAR 0 6
100312: PUSH
100313: LD_INT 1
100315: ARRAY
100316: PPUSH
100317: LD_VAR 0 2
100321: PPUSH
100322: CALL_OW 259
100326: ST_TO_ADDR
// if s1 = 1 then
100327: LD_VAR 0 2
100331: PUSH
100332: LD_INT 1
100334: EQUAL
100335: IFFALSE 100355
// s2 := rand ( 2 , 4 ) else
100337: LD_ADDR_VAR 0 3
100341: PUSH
100342: LD_INT 2
100344: PPUSH
100345: LD_INT 4
100347: PPUSH
100348: CALL_OW 12
100352: ST_TO_ADDR
100353: GO 100363
// s2 := 1 ;
100355: LD_ADDR_VAR 0 3
100359: PUSH
100360: LD_INT 1
100362: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
100363: LD_ADDR_VAR 0 5
100367: PUSH
100368: LD_VAR 0 6
100372: PUSH
100373: LD_INT 1
100375: ARRAY
100376: PPUSH
100377: LD_VAR 0 3
100381: PPUSH
100382: CALL_OW 259
100386: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
100387: LD_VAR 0 6
100391: PUSH
100392: LD_INT 1
100394: ARRAY
100395: PPUSH
100396: LD_VAR 0 2
100400: PPUSH
100401: LD_VAR 0 5
100405: PPUSH
100406: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
100410: LD_VAR 0 6
100414: PUSH
100415: LD_INT 1
100417: ARRAY
100418: PPUSH
100419: LD_VAR 0 3
100423: PPUSH
100424: LD_VAR 0 4
100428: PPUSH
100429: CALL_OW 237
// end ;
100433: PPOPN 6
100435: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
100436: LD_EXP 107
100440: PUSH
100441: LD_EXP 154
100445: AND
100446: IFFALSE 100525
100448: GO 100450
100450: DISABLE
100451: LD_INT 0
100453: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
100454: LD_ADDR_VAR 0 1
100458: PUSH
100459: LD_INT 22
100461: PUSH
100462: LD_OWVAR 2
100466: PUSH
100467: EMPTY
100468: LIST
100469: LIST
100470: PUSH
100471: LD_INT 30
100473: PUSH
100474: LD_INT 3
100476: PUSH
100477: EMPTY
100478: LIST
100479: LIST
100480: PUSH
100481: EMPTY
100482: LIST
100483: LIST
100484: PPUSH
100485: CALL_OW 69
100489: ST_TO_ADDR
// if not tmp then
100490: LD_VAR 0 1
100494: NOT
100495: IFFALSE 100499
// exit ;
100497: GO 100525
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100499: LD_VAR 0 1
100503: PUSH
100504: LD_INT 1
100506: PPUSH
100507: LD_VAR 0 1
100511: PPUSH
100512: CALL_OW 12
100516: ARRAY
100517: PPUSH
100518: LD_INT 1
100520: PPUSH
100521: CALL_OW 234
// end ;
100525: PPOPN 1
100527: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
100528: LD_EXP 107
100532: PUSH
100533: LD_EXP 155
100537: AND
100538: IFFALSE 100650
100540: GO 100542
100542: DISABLE
100543: LD_INT 0
100545: PPUSH
100546: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
100547: LD_ADDR_VAR 0 2
100551: PUSH
100552: LD_INT 22
100554: PUSH
100555: LD_OWVAR 2
100559: PUSH
100560: EMPTY
100561: LIST
100562: LIST
100563: PUSH
100564: LD_INT 2
100566: PUSH
100567: LD_INT 30
100569: PUSH
100570: LD_INT 27
100572: PUSH
100573: EMPTY
100574: LIST
100575: LIST
100576: PUSH
100577: LD_INT 30
100579: PUSH
100580: LD_INT 26
100582: PUSH
100583: EMPTY
100584: LIST
100585: LIST
100586: PUSH
100587: LD_INT 30
100589: PUSH
100590: LD_INT 28
100592: PUSH
100593: EMPTY
100594: LIST
100595: LIST
100596: PUSH
100597: EMPTY
100598: LIST
100599: LIST
100600: LIST
100601: LIST
100602: PUSH
100603: EMPTY
100604: LIST
100605: LIST
100606: PPUSH
100607: CALL_OW 69
100611: ST_TO_ADDR
// if not tmp then
100612: LD_VAR 0 2
100616: NOT
100617: IFFALSE 100621
// exit ;
100619: GO 100650
// for i in tmp do
100621: LD_ADDR_VAR 0 1
100625: PUSH
100626: LD_VAR 0 2
100630: PUSH
100631: FOR_IN
100632: IFFALSE 100648
// SetLives ( i , 1 ) ;
100634: LD_VAR 0 1
100638: PPUSH
100639: LD_INT 1
100641: PPUSH
100642: CALL_OW 234
100646: GO 100631
100648: POP
100649: POP
// end ;
100650: PPOPN 2
100652: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
100653: LD_EXP 107
100657: PUSH
100658: LD_EXP 156
100662: AND
100663: IFFALSE 100950
100665: GO 100667
100667: DISABLE
100668: LD_INT 0
100670: PPUSH
100671: PPUSH
100672: PPUSH
// begin i := rand ( 1 , 7 ) ;
100673: LD_ADDR_VAR 0 1
100677: PUSH
100678: LD_INT 1
100680: PPUSH
100681: LD_INT 7
100683: PPUSH
100684: CALL_OW 12
100688: ST_TO_ADDR
// case i of 1 :
100689: LD_VAR 0 1
100693: PUSH
100694: LD_INT 1
100696: DOUBLE
100697: EQUAL
100698: IFTRUE 100702
100700: GO 100712
100702: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
100703: LD_STRING earthquake(getX(game), 0, 32)
100705: PPUSH
100706: CALL_OW 559
100710: GO 100950
100712: LD_INT 2
100714: DOUBLE
100715: EQUAL
100716: IFTRUE 100720
100718: GO 100734
100720: POP
// begin ToLua ( displayStucuk(); ) ;
100721: LD_STRING displayStucuk();
100723: PPUSH
100724: CALL_OW 559
// ResetFog ;
100728: CALL_OW 335
// end ; 3 :
100732: GO 100950
100734: LD_INT 3
100736: DOUBLE
100737: EQUAL
100738: IFTRUE 100742
100740: GO 100846
100742: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100743: LD_ADDR_VAR 0 2
100747: PUSH
100748: LD_INT 22
100750: PUSH
100751: LD_OWVAR 2
100755: PUSH
100756: EMPTY
100757: LIST
100758: LIST
100759: PUSH
100760: LD_INT 25
100762: PUSH
100763: LD_INT 1
100765: PUSH
100766: EMPTY
100767: LIST
100768: LIST
100769: PUSH
100770: EMPTY
100771: LIST
100772: LIST
100773: PPUSH
100774: CALL_OW 69
100778: ST_TO_ADDR
// if not tmp then
100779: LD_VAR 0 2
100783: NOT
100784: IFFALSE 100788
// exit ;
100786: GO 100950
// un := tmp [ rand ( 1 , tmp ) ] ;
100788: LD_ADDR_VAR 0 3
100792: PUSH
100793: LD_VAR 0 2
100797: PUSH
100798: LD_INT 1
100800: PPUSH
100801: LD_VAR 0 2
100805: PPUSH
100806: CALL_OW 12
100810: ARRAY
100811: ST_TO_ADDR
// if Crawls ( un ) then
100812: LD_VAR 0 3
100816: PPUSH
100817: CALL_OW 318
100821: IFFALSE 100832
// ComWalk ( un ) ;
100823: LD_VAR 0 3
100827: PPUSH
100828: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100832: LD_VAR 0 3
100836: PPUSH
100837: LD_INT 8
100839: PPUSH
100840: CALL_OW 336
// end ; 4 :
100844: GO 100950
100846: LD_INT 4
100848: DOUBLE
100849: EQUAL
100850: IFTRUE 100854
100852: GO 100928
100854: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100855: LD_ADDR_VAR 0 2
100859: PUSH
100860: LD_INT 22
100862: PUSH
100863: LD_OWVAR 2
100867: PUSH
100868: EMPTY
100869: LIST
100870: LIST
100871: PUSH
100872: LD_INT 30
100874: PUSH
100875: LD_INT 29
100877: PUSH
100878: EMPTY
100879: LIST
100880: LIST
100881: PUSH
100882: EMPTY
100883: LIST
100884: LIST
100885: PPUSH
100886: CALL_OW 69
100890: ST_TO_ADDR
// if not tmp then
100891: LD_VAR 0 2
100895: NOT
100896: IFFALSE 100900
// exit ;
100898: GO 100950
// CenterNowOnUnits ( tmp [ 1 ] ) ;
100900: LD_VAR 0 2
100904: PUSH
100905: LD_INT 1
100907: ARRAY
100908: PPUSH
100909: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
100913: LD_VAR 0 2
100917: PUSH
100918: LD_INT 1
100920: ARRAY
100921: PPUSH
100922: CALL_OW 65
// end ; 5 .. 7 :
100926: GO 100950
100928: LD_INT 5
100930: DOUBLE
100931: GREATEREQUAL
100932: IFFALSE 100940
100934: LD_INT 7
100936: DOUBLE
100937: LESSEQUAL
100938: IFTRUE 100942
100940: GO 100949
100942: POP
// StreamSibBomb ; end ;
100943: CALL 97187 0 0
100947: GO 100950
100949: POP
// end ;
100950: PPOPN 3
100952: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
100953: LD_EXP 107
100957: PUSH
100958: LD_EXP 157
100962: AND
100963: IFFALSE 101119
100965: GO 100967
100967: DISABLE
100968: LD_INT 0
100970: PPUSH
100971: PPUSH
100972: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
100973: LD_ADDR_VAR 0 2
100977: PUSH
100978: LD_INT 81
100980: PUSH
100981: LD_OWVAR 2
100985: PUSH
100986: EMPTY
100987: LIST
100988: LIST
100989: PUSH
100990: LD_INT 2
100992: PUSH
100993: LD_INT 21
100995: PUSH
100996: LD_INT 1
100998: PUSH
100999: EMPTY
101000: LIST
101001: LIST
101002: PUSH
101003: LD_INT 21
101005: PUSH
101006: LD_INT 2
101008: PUSH
101009: EMPTY
101010: LIST
101011: LIST
101012: PUSH
101013: EMPTY
101014: LIST
101015: LIST
101016: LIST
101017: PUSH
101018: EMPTY
101019: LIST
101020: LIST
101021: PPUSH
101022: CALL_OW 69
101026: ST_TO_ADDR
// if not tmp then
101027: LD_VAR 0 2
101031: NOT
101032: IFFALSE 101036
// exit ;
101034: GO 101119
// p := 0 ;
101036: LD_ADDR_VAR 0 3
101040: PUSH
101041: LD_INT 0
101043: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101044: LD_INT 35
101046: PPUSH
101047: CALL_OW 67
// p := p + 1 ;
101051: LD_ADDR_VAR 0 3
101055: PUSH
101056: LD_VAR 0 3
101060: PUSH
101061: LD_INT 1
101063: PLUS
101064: ST_TO_ADDR
// for i in tmp do
101065: LD_ADDR_VAR 0 1
101069: PUSH
101070: LD_VAR 0 2
101074: PUSH
101075: FOR_IN
101076: IFFALSE 101107
// if GetLives ( i ) < 1000 then
101078: LD_VAR 0 1
101082: PPUSH
101083: CALL_OW 256
101087: PUSH
101088: LD_INT 1000
101090: LESS
101091: IFFALSE 101105
// SetLives ( i , 1000 ) ;
101093: LD_VAR 0 1
101097: PPUSH
101098: LD_INT 1000
101100: PPUSH
101101: CALL_OW 234
101105: GO 101075
101107: POP
101108: POP
// until p > 20 ;
101109: LD_VAR 0 3
101113: PUSH
101114: LD_INT 20
101116: GREATER
101117: IFFALSE 101044
// end ;
101119: PPOPN 3
101121: END
// every 0 0$1 trigger StreamModeActive and sTime do
101122: LD_EXP 107
101126: PUSH
101127: LD_EXP 158
101131: AND
101132: IFFALSE 101167
101134: GO 101136
101136: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
101137: LD_INT 28
101139: PPUSH
101140: LD_OWVAR 2
101144: PPUSH
101145: LD_INT 2
101147: PPUSH
101148: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
101152: LD_INT 30
101154: PPUSH
101155: LD_OWVAR 2
101159: PPUSH
101160: LD_INT 2
101162: PPUSH
101163: CALL_OW 322
// end ;
101167: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
101168: LD_EXP 107
101172: PUSH
101173: LD_EXP 159
101177: AND
101178: IFFALSE 101299
101180: GO 101182
101182: DISABLE
101183: LD_INT 0
101185: PPUSH
101186: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101187: LD_ADDR_VAR 0 2
101191: PUSH
101192: LD_INT 22
101194: PUSH
101195: LD_OWVAR 2
101199: PUSH
101200: EMPTY
101201: LIST
101202: LIST
101203: PUSH
101204: LD_INT 21
101206: PUSH
101207: LD_INT 1
101209: PUSH
101210: EMPTY
101211: LIST
101212: LIST
101213: PUSH
101214: LD_INT 3
101216: PUSH
101217: LD_INT 23
101219: PUSH
101220: LD_INT 0
101222: PUSH
101223: EMPTY
101224: LIST
101225: LIST
101226: PUSH
101227: EMPTY
101228: LIST
101229: LIST
101230: PUSH
101231: EMPTY
101232: LIST
101233: LIST
101234: LIST
101235: PPUSH
101236: CALL_OW 69
101240: ST_TO_ADDR
// if not tmp then
101241: LD_VAR 0 2
101245: NOT
101246: IFFALSE 101250
// exit ;
101248: GO 101299
// for i in tmp do
101250: LD_ADDR_VAR 0 1
101254: PUSH
101255: LD_VAR 0 2
101259: PUSH
101260: FOR_IN
101261: IFFALSE 101297
// begin if Crawls ( i ) then
101263: LD_VAR 0 1
101267: PPUSH
101268: CALL_OW 318
101272: IFFALSE 101283
// ComWalk ( i ) ;
101274: LD_VAR 0 1
101278: PPUSH
101279: CALL_OW 138
// SetClass ( i , 2 ) ;
101283: LD_VAR 0 1
101287: PPUSH
101288: LD_INT 2
101290: PPUSH
101291: CALL_OW 336
// end ;
101295: GO 101260
101297: POP
101298: POP
// end ;
101299: PPOPN 2
101301: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
101302: LD_EXP 107
101306: PUSH
101307: LD_EXP 160
101311: AND
101312: IFFALSE 101600
101314: GO 101316
101316: DISABLE
101317: LD_INT 0
101319: PPUSH
101320: PPUSH
101321: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
101322: LD_OWVAR 2
101326: PPUSH
101327: LD_INT 9
101329: PPUSH
101330: LD_INT 1
101332: PPUSH
101333: LD_INT 1
101335: PPUSH
101336: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
101340: LD_INT 9
101342: PPUSH
101343: LD_OWVAR 2
101347: PPUSH
101348: CALL_OW 343
// uc_side := 9 ;
101352: LD_ADDR_OWVAR 20
101356: PUSH
101357: LD_INT 9
101359: ST_TO_ADDR
// uc_nation := 2 ;
101360: LD_ADDR_OWVAR 21
101364: PUSH
101365: LD_INT 2
101367: ST_TO_ADDR
// hc_name := Dark Warrior ;
101368: LD_ADDR_OWVAR 26
101372: PUSH
101373: LD_STRING Dark Warrior
101375: ST_TO_ADDR
// hc_gallery :=  ;
101376: LD_ADDR_OWVAR 33
101380: PUSH
101381: LD_STRING 
101383: ST_TO_ADDR
// hc_noskilllimit := true ;
101384: LD_ADDR_OWVAR 76
101388: PUSH
101389: LD_INT 1
101391: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
101392: LD_ADDR_OWVAR 31
101396: PUSH
101397: LD_INT 30
101399: PUSH
101400: LD_INT 30
101402: PUSH
101403: LD_INT 30
101405: PUSH
101406: LD_INT 30
101408: PUSH
101409: EMPTY
101410: LIST
101411: LIST
101412: LIST
101413: LIST
101414: ST_TO_ADDR
// un := CreateHuman ;
101415: LD_ADDR_VAR 0 3
101419: PUSH
101420: CALL_OW 44
101424: ST_TO_ADDR
// hc_noskilllimit := false ;
101425: LD_ADDR_OWVAR 76
101429: PUSH
101430: LD_INT 0
101432: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101433: LD_VAR 0 3
101437: PPUSH
101438: LD_INT 1
101440: PPUSH
101441: CALL_OW 51
// ToLua ( playRanger() ) ;
101445: LD_STRING playRanger()
101447: PPUSH
101448: CALL_OW 559
// p := 0 ;
101452: LD_ADDR_VAR 0 2
101456: PUSH
101457: LD_INT 0
101459: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101460: LD_INT 35
101462: PPUSH
101463: CALL_OW 67
// p := p + 1 ;
101467: LD_ADDR_VAR 0 2
101471: PUSH
101472: LD_VAR 0 2
101476: PUSH
101477: LD_INT 1
101479: PLUS
101480: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
101481: LD_VAR 0 3
101485: PPUSH
101486: CALL_OW 256
101490: PUSH
101491: LD_INT 1000
101493: LESS
101494: IFFALSE 101508
// SetLives ( un , 1000 ) ;
101496: LD_VAR 0 3
101500: PPUSH
101501: LD_INT 1000
101503: PPUSH
101504: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
101508: LD_VAR 0 3
101512: PPUSH
101513: LD_INT 81
101515: PUSH
101516: LD_OWVAR 2
101520: PUSH
101521: EMPTY
101522: LIST
101523: LIST
101524: PUSH
101525: LD_INT 91
101527: PUSH
101528: LD_VAR 0 3
101532: PUSH
101533: LD_INT 30
101535: PUSH
101536: EMPTY
101537: LIST
101538: LIST
101539: LIST
101540: PUSH
101541: EMPTY
101542: LIST
101543: LIST
101544: PPUSH
101545: CALL_OW 69
101549: PPUSH
101550: LD_VAR 0 3
101554: PPUSH
101555: CALL_OW 74
101559: PPUSH
101560: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
101564: LD_VAR 0 2
101568: PUSH
101569: LD_INT 80
101571: GREATER
101572: PUSH
101573: LD_VAR 0 3
101577: PPUSH
101578: CALL_OW 301
101582: OR
101583: IFFALSE 101460
// if un then
101585: LD_VAR 0 3
101589: IFFALSE 101600
// RemoveUnit ( un ) ;
101591: LD_VAR 0 3
101595: PPUSH
101596: CALL_OW 64
// end ;
101600: PPOPN 3
101602: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
101603: LD_EXP 161
101607: IFFALSE 101723
101609: GO 101611
101611: DISABLE
101612: LD_INT 0
101614: PPUSH
101615: PPUSH
101616: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
101617: LD_ADDR_VAR 0 2
101621: PUSH
101622: LD_INT 81
101624: PUSH
101625: LD_OWVAR 2
101629: PUSH
101630: EMPTY
101631: LIST
101632: LIST
101633: PUSH
101634: LD_INT 21
101636: PUSH
101637: LD_INT 1
101639: PUSH
101640: EMPTY
101641: LIST
101642: LIST
101643: PUSH
101644: EMPTY
101645: LIST
101646: LIST
101647: PPUSH
101648: CALL_OW 69
101652: ST_TO_ADDR
// ToLua ( playComputer() ) ;
101653: LD_STRING playComputer()
101655: PPUSH
101656: CALL_OW 559
// if not tmp then
101660: LD_VAR 0 2
101664: NOT
101665: IFFALSE 101669
// exit ;
101667: GO 101723
// for i in tmp do
101669: LD_ADDR_VAR 0 1
101673: PUSH
101674: LD_VAR 0 2
101678: PUSH
101679: FOR_IN
101680: IFFALSE 101721
// for j := 1 to 4 do
101682: LD_ADDR_VAR 0 3
101686: PUSH
101687: DOUBLE
101688: LD_INT 1
101690: DEC
101691: ST_TO_ADDR
101692: LD_INT 4
101694: PUSH
101695: FOR_TO
101696: IFFALSE 101717
// SetSkill ( i , j , 10 ) ;
101698: LD_VAR 0 1
101702: PPUSH
101703: LD_VAR 0 3
101707: PPUSH
101708: LD_INT 10
101710: PPUSH
101711: CALL_OW 237
101715: GO 101695
101717: POP
101718: POP
101719: GO 101679
101721: POP
101722: POP
// end ;
101723: PPOPN 3
101725: END
// every 0 0$1 trigger s30 do var i , tmp ;
101726: LD_EXP 162
101730: IFFALSE 101799
101732: GO 101734
101734: DISABLE
101735: LD_INT 0
101737: PPUSH
101738: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101739: LD_ADDR_VAR 0 2
101743: PUSH
101744: LD_INT 22
101746: PUSH
101747: LD_OWVAR 2
101751: PUSH
101752: EMPTY
101753: LIST
101754: LIST
101755: PPUSH
101756: CALL_OW 69
101760: ST_TO_ADDR
// if not tmp then
101761: LD_VAR 0 2
101765: NOT
101766: IFFALSE 101770
// exit ;
101768: GO 101799
// for i in tmp do
101770: LD_ADDR_VAR 0 1
101774: PUSH
101775: LD_VAR 0 2
101779: PUSH
101780: FOR_IN
101781: IFFALSE 101797
// SetLives ( i , 300 ) ;
101783: LD_VAR 0 1
101787: PPUSH
101788: LD_INT 300
101790: PPUSH
101791: CALL_OW 234
101795: GO 101780
101797: POP
101798: POP
// end ;
101799: PPOPN 2
101801: END
// every 0 0$1 trigger s60 do var i , tmp ;
101802: LD_EXP 163
101806: IFFALSE 101875
101808: GO 101810
101810: DISABLE
101811: LD_INT 0
101813: PPUSH
101814: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101815: LD_ADDR_VAR 0 2
101819: PUSH
101820: LD_INT 22
101822: PUSH
101823: LD_OWVAR 2
101827: PUSH
101828: EMPTY
101829: LIST
101830: LIST
101831: PPUSH
101832: CALL_OW 69
101836: ST_TO_ADDR
// if not tmp then
101837: LD_VAR 0 2
101841: NOT
101842: IFFALSE 101846
// exit ;
101844: GO 101875
// for i in tmp do
101846: LD_ADDR_VAR 0 1
101850: PUSH
101851: LD_VAR 0 2
101855: PUSH
101856: FOR_IN
101857: IFFALSE 101873
// SetLives ( i , 600 ) ;
101859: LD_VAR 0 1
101863: PPUSH
101864: LD_INT 600
101866: PPUSH
101867: CALL_OW 234
101871: GO 101856
101873: POP
101874: POP
// end ;
101875: PPOPN 2
101877: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
101878: LD_INT 0
101880: PPUSH
// case cmd of 301 :
101881: LD_VAR 0 1
101885: PUSH
101886: LD_INT 301
101888: DOUBLE
101889: EQUAL
101890: IFTRUE 101894
101892: GO 101926
101894: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
101895: LD_VAR 0 6
101899: PPUSH
101900: LD_VAR 0 7
101904: PPUSH
101905: LD_VAR 0 8
101909: PPUSH
101910: LD_VAR 0 4
101914: PPUSH
101915: LD_VAR 0 5
101919: PPUSH
101920: CALL 103135 0 5
101924: GO 102047
101926: LD_INT 302
101928: DOUBLE
101929: EQUAL
101930: IFTRUE 101934
101932: GO 101971
101934: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
101935: LD_VAR 0 6
101939: PPUSH
101940: LD_VAR 0 7
101944: PPUSH
101945: LD_VAR 0 8
101949: PPUSH
101950: LD_VAR 0 9
101954: PPUSH
101955: LD_VAR 0 4
101959: PPUSH
101960: LD_VAR 0 5
101964: PPUSH
101965: CALL 103226 0 6
101969: GO 102047
101971: LD_INT 303
101973: DOUBLE
101974: EQUAL
101975: IFTRUE 101979
101977: GO 102016
101979: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
101980: LD_VAR 0 6
101984: PPUSH
101985: LD_VAR 0 7
101989: PPUSH
101990: LD_VAR 0 8
101994: PPUSH
101995: LD_VAR 0 9
101999: PPUSH
102000: LD_VAR 0 4
102004: PPUSH
102005: LD_VAR 0 5
102009: PPUSH
102010: CALL 102052 0 6
102014: GO 102047
102016: LD_INT 304
102018: DOUBLE
102019: EQUAL
102020: IFTRUE 102024
102022: GO 102046
102024: POP
// hHackTeleport ( unit , x , y ) ; end ;
102025: LD_VAR 0 2
102029: PPUSH
102030: LD_VAR 0 4
102034: PPUSH
102035: LD_VAR 0 5
102039: PPUSH
102040: CALL 103819 0 3
102044: GO 102047
102046: POP
// end ;
102047: LD_VAR 0 12
102051: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
102052: LD_INT 0
102054: PPUSH
102055: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
102056: LD_VAR 0 1
102060: PUSH
102061: LD_INT 1
102063: LESS
102064: PUSH
102065: LD_VAR 0 1
102069: PUSH
102070: LD_INT 3
102072: GREATER
102073: OR
102074: PUSH
102075: LD_VAR 0 5
102079: PPUSH
102080: LD_VAR 0 6
102084: PPUSH
102085: CALL_OW 428
102089: OR
102090: IFFALSE 102094
// exit ;
102092: GO 102822
// uc_side := your_side ;
102094: LD_ADDR_OWVAR 20
102098: PUSH
102099: LD_OWVAR 2
102103: ST_TO_ADDR
// uc_nation := nation ;
102104: LD_ADDR_OWVAR 21
102108: PUSH
102109: LD_VAR 0 1
102113: ST_TO_ADDR
// bc_level = 1 ;
102114: LD_ADDR_OWVAR 43
102118: PUSH
102119: LD_INT 1
102121: ST_TO_ADDR
// case btype of 1 :
102122: LD_VAR 0 2
102126: PUSH
102127: LD_INT 1
102129: DOUBLE
102130: EQUAL
102131: IFTRUE 102135
102133: GO 102146
102135: POP
// bc_type := b_depot ; 2 :
102136: LD_ADDR_OWVAR 42
102140: PUSH
102141: LD_INT 0
102143: ST_TO_ADDR
102144: GO 102766
102146: LD_INT 2
102148: DOUBLE
102149: EQUAL
102150: IFTRUE 102154
102152: GO 102165
102154: POP
// bc_type := b_warehouse ; 3 :
102155: LD_ADDR_OWVAR 42
102159: PUSH
102160: LD_INT 1
102162: ST_TO_ADDR
102163: GO 102766
102165: LD_INT 3
102167: DOUBLE
102168: EQUAL
102169: IFTRUE 102173
102171: GO 102184
102173: POP
// bc_type := b_lab ; 4 .. 9 :
102174: LD_ADDR_OWVAR 42
102178: PUSH
102179: LD_INT 6
102181: ST_TO_ADDR
102182: GO 102766
102184: LD_INT 4
102186: DOUBLE
102187: GREATEREQUAL
102188: IFFALSE 102196
102190: LD_INT 9
102192: DOUBLE
102193: LESSEQUAL
102194: IFTRUE 102198
102196: GO 102258
102198: POP
// begin bc_type := b_lab_half ;
102199: LD_ADDR_OWVAR 42
102203: PUSH
102204: LD_INT 7
102206: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
102207: LD_ADDR_OWVAR 44
102211: PUSH
102212: LD_INT 10
102214: PUSH
102215: LD_INT 11
102217: PUSH
102218: LD_INT 12
102220: PUSH
102221: LD_INT 15
102223: PUSH
102224: LD_INT 14
102226: PUSH
102227: LD_INT 13
102229: PUSH
102230: EMPTY
102231: LIST
102232: LIST
102233: LIST
102234: LIST
102235: LIST
102236: LIST
102237: PUSH
102238: LD_VAR 0 2
102242: PUSH
102243: LD_INT 3
102245: MINUS
102246: ARRAY
102247: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
102248: LD_ADDR_OWVAR 45
102252: PUSH
102253: LD_INT 9
102255: ST_TO_ADDR
// end ; 10 .. 13 :
102256: GO 102766
102258: LD_INT 10
102260: DOUBLE
102261: GREATEREQUAL
102262: IFFALSE 102270
102264: LD_INT 13
102266: DOUBLE
102267: LESSEQUAL
102268: IFTRUE 102272
102270: GO 102349
102272: POP
// begin bc_type := b_lab_full ;
102273: LD_ADDR_OWVAR 42
102277: PUSH
102278: LD_INT 8
102280: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
102281: LD_ADDR_OWVAR 44
102285: PUSH
102286: LD_INT 10
102288: PUSH
102289: LD_INT 12
102291: PUSH
102292: LD_INT 14
102294: PUSH
102295: LD_INT 13
102297: PUSH
102298: EMPTY
102299: LIST
102300: LIST
102301: LIST
102302: LIST
102303: PUSH
102304: LD_VAR 0 2
102308: PUSH
102309: LD_INT 9
102311: MINUS
102312: ARRAY
102313: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
102314: LD_ADDR_OWVAR 45
102318: PUSH
102319: LD_INT 11
102321: PUSH
102322: LD_INT 15
102324: PUSH
102325: LD_INT 12
102327: PUSH
102328: LD_INT 15
102330: PUSH
102331: EMPTY
102332: LIST
102333: LIST
102334: LIST
102335: LIST
102336: PUSH
102337: LD_VAR 0 2
102341: PUSH
102342: LD_INT 9
102344: MINUS
102345: ARRAY
102346: ST_TO_ADDR
// end ; 14 :
102347: GO 102766
102349: LD_INT 14
102351: DOUBLE
102352: EQUAL
102353: IFTRUE 102357
102355: GO 102368
102357: POP
// bc_type := b_workshop ; 15 :
102358: LD_ADDR_OWVAR 42
102362: PUSH
102363: LD_INT 2
102365: ST_TO_ADDR
102366: GO 102766
102368: LD_INT 15
102370: DOUBLE
102371: EQUAL
102372: IFTRUE 102376
102374: GO 102387
102376: POP
// bc_type := b_factory ; 16 :
102377: LD_ADDR_OWVAR 42
102381: PUSH
102382: LD_INT 3
102384: ST_TO_ADDR
102385: GO 102766
102387: LD_INT 16
102389: DOUBLE
102390: EQUAL
102391: IFTRUE 102395
102393: GO 102406
102395: POP
// bc_type := b_ext_gun ; 17 :
102396: LD_ADDR_OWVAR 42
102400: PUSH
102401: LD_INT 17
102403: ST_TO_ADDR
102404: GO 102766
102406: LD_INT 17
102408: DOUBLE
102409: EQUAL
102410: IFTRUE 102414
102412: GO 102442
102414: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
102415: LD_ADDR_OWVAR 42
102419: PUSH
102420: LD_INT 19
102422: PUSH
102423: LD_INT 23
102425: PUSH
102426: LD_INT 19
102428: PUSH
102429: EMPTY
102430: LIST
102431: LIST
102432: LIST
102433: PUSH
102434: LD_VAR 0 1
102438: ARRAY
102439: ST_TO_ADDR
102440: GO 102766
102442: LD_INT 18
102444: DOUBLE
102445: EQUAL
102446: IFTRUE 102450
102448: GO 102461
102450: POP
// bc_type := b_ext_radar ; 19 :
102451: LD_ADDR_OWVAR 42
102455: PUSH
102456: LD_INT 20
102458: ST_TO_ADDR
102459: GO 102766
102461: LD_INT 19
102463: DOUBLE
102464: EQUAL
102465: IFTRUE 102469
102467: GO 102480
102469: POP
// bc_type := b_ext_radio ; 20 :
102470: LD_ADDR_OWVAR 42
102474: PUSH
102475: LD_INT 22
102477: ST_TO_ADDR
102478: GO 102766
102480: LD_INT 20
102482: DOUBLE
102483: EQUAL
102484: IFTRUE 102488
102486: GO 102499
102488: POP
// bc_type := b_ext_siberium ; 21 :
102489: LD_ADDR_OWVAR 42
102493: PUSH
102494: LD_INT 21
102496: ST_TO_ADDR
102497: GO 102766
102499: LD_INT 21
102501: DOUBLE
102502: EQUAL
102503: IFTRUE 102507
102505: GO 102518
102507: POP
// bc_type := b_ext_computer ; 22 :
102508: LD_ADDR_OWVAR 42
102512: PUSH
102513: LD_INT 24
102515: ST_TO_ADDR
102516: GO 102766
102518: LD_INT 22
102520: DOUBLE
102521: EQUAL
102522: IFTRUE 102526
102524: GO 102537
102526: POP
// bc_type := b_ext_track ; 23 :
102527: LD_ADDR_OWVAR 42
102531: PUSH
102532: LD_INT 16
102534: ST_TO_ADDR
102535: GO 102766
102537: LD_INT 23
102539: DOUBLE
102540: EQUAL
102541: IFTRUE 102545
102543: GO 102556
102545: POP
// bc_type := b_ext_laser ; 24 :
102546: LD_ADDR_OWVAR 42
102550: PUSH
102551: LD_INT 25
102553: ST_TO_ADDR
102554: GO 102766
102556: LD_INT 24
102558: DOUBLE
102559: EQUAL
102560: IFTRUE 102564
102562: GO 102575
102564: POP
// bc_type := b_control_tower ; 25 :
102565: LD_ADDR_OWVAR 42
102569: PUSH
102570: LD_INT 36
102572: ST_TO_ADDR
102573: GO 102766
102575: LD_INT 25
102577: DOUBLE
102578: EQUAL
102579: IFTRUE 102583
102581: GO 102594
102583: POP
// bc_type := b_breastwork ; 26 :
102584: LD_ADDR_OWVAR 42
102588: PUSH
102589: LD_INT 31
102591: ST_TO_ADDR
102592: GO 102766
102594: LD_INT 26
102596: DOUBLE
102597: EQUAL
102598: IFTRUE 102602
102600: GO 102613
102602: POP
// bc_type := b_bunker ; 27 :
102603: LD_ADDR_OWVAR 42
102607: PUSH
102608: LD_INT 32
102610: ST_TO_ADDR
102611: GO 102766
102613: LD_INT 27
102615: DOUBLE
102616: EQUAL
102617: IFTRUE 102621
102619: GO 102632
102621: POP
// bc_type := b_turret ; 28 :
102622: LD_ADDR_OWVAR 42
102626: PUSH
102627: LD_INT 33
102629: ST_TO_ADDR
102630: GO 102766
102632: LD_INT 28
102634: DOUBLE
102635: EQUAL
102636: IFTRUE 102640
102638: GO 102651
102640: POP
// bc_type := b_armoury ; 29 :
102641: LD_ADDR_OWVAR 42
102645: PUSH
102646: LD_INT 4
102648: ST_TO_ADDR
102649: GO 102766
102651: LD_INT 29
102653: DOUBLE
102654: EQUAL
102655: IFTRUE 102659
102657: GO 102670
102659: POP
// bc_type := b_barracks ; 30 :
102660: LD_ADDR_OWVAR 42
102664: PUSH
102665: LD_INT 5
102667: ST_TO_ADDR
102668: GO 102766
102670: LD_INT 30
102672: DOUBLE
102673: EQUAL
102674: IFTRUE 102678
102676: GO 102689
102678: POP
// bc_type := b_solar_power ; 31 :
102679: LD_ADDR_OWVAR 42
102683: PUSH
102684: LD_INT 27
102686: ST_TO_ADDR
102687: GO 102766
102689: LD_INT 31
102691: DOUBLE
102692: EQUAL
102693: IFTRUE 102697
102695: GO 102708
102697: POP
// bc_type := b_oil_power ; 32 :
102698: LD_ADDR_OWVAR 42
102702: PUSH
102703: LD_INT 26
102705: ST_TO_ADDR
102706: GO 102766
102708: LD_INT 32
102710: DOUBLE
102711: EQUAL
102712: IFTRUE 102716
102714: GO 102727
102716: POP
// bc_type := b_siberite_power ; 33 :
102717: LD_ADDR_OWVAR 42
102721: PUSH
102722: LD_INT 28
102724: ST_TO_ADDR
102725: GO 102766
102727: LD_INT 33
102729: DOUBLE
102730: EQUAL
102731: IFTRUE 102735
102733: GO 102746
102735: POP
// bc_type := b_oil_mine ; 34 :
102736: LD_ADDR_OWVAR 42
102740: PUSH
102741: LD_INT 29
102743: ST_TO_ADDR
102744: GO 102766
102746: LD_INT 34
102748: DOUBLE
102749: EQUAL
102750: IFTRUE 102754
102752: GO 102765
102754: POP
// bc_type := b_siberite_mine ; end ;
102755: LD_ADDR_OWVAR 42
102759: PUSH
102760: LD_INT 30
102762: ST_TO_ADDR
102763: GO 102766
102765: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
102766: LD_ADDR_VAR 0 8
102770: PUSH
102771: LD_VAR 0 5
102775: PPUSH
102776: LD_VAR 0 6
102780: PPUSH
102781: LD_VAR 0 3
102785: PPUSH
102786: CALL_OW 47
102790: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
102791: LD_OWVAR 42
102795: PUSH
102796: LD_INT 32
102798: PUSH
102799: LD_INT 33
102801: PUSH
102802: EMPTY
102803: LIST
102804: LIST
102805: IN
102806: IFFALSE 102822
// PlaceWeaponTurret ( b , weapon ) ;
102808: LD_VAR 0 8
102812: PPUSH
102813: LD_VAR 0 4
102817: PPUSH
102818: CALL_OW 431
// end ;
102822: LD_VAR 0 7
102826: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
102827: LD_INT 0
102829: PPUSH
102830: PPUSH
102831: PPUSH
102832: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102833: LD_ADDR_VAR 0 4
102837: PUSH
102838: LD_INT 22
102840: PUSH
102841: LD_OWVAR 2
102845: PUSH
102846: EMPTY
102847: LIST
102848: LIST
102849: PUSH
102850: LD_INT 2
102852: PUSH
102853: LD_INT 30
102855: PUSH
102856: LD_INT 0
102858: PUSH
102859: EMPTY
102860: LIST
102861: LIST
102862: PUSH
102863: LD_INT 30
102865: PUSH
102866: LD_INT 1
102868: PUSH
102869: EMPTY
102870: LIST
102871: LIST
102872: PUSH
102873: EMPTY
102874: LIST
102875: LIST
102876: LIST
102877: PUSH
102878: EMPTY
102879: LIST
102880: LIST
102881: PPUSH
102882: CALL_OW 69
102886: ST_TO_ADDR
// if not tmp then
102887: LD_VAR 0 4
102891: NOT
102892: IFFALSE 102896
// exit ;
102894: GO 102955
// for i in tmp do
102896: LD_ADDR_VAR 0 2
102900: PUSH
102901: LD_VAR 0 4
102905: PUSH
102906: FOR_IN
102907: IFFALSE 102953
// for j = 1 to 3 do
102909: LD_ADDR_VAR 0 3
102913: PUSH
102914: DOUBLE
102915: LD_INT 1
102917: DEC
102918: ST_TO_ADDR
102919: LD_INT 3
102921: PUSH
102922: FOR_TO
102923: IFFALSE 102949
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
102925: LD_VAR 0 2
102929: PPUSH
102930: CALL_OW 274
102934: PPUSH
102935: LD_VAR 0 3
102939: PPUSH
102940: LD_INT 99999
102942: PPUSH
102943: CALL_OW 277
102947: GO 102922
102949: POP
102950: POP
102951: GO 102906
102953: POP
102954: POP
// end ;
102955: LD_VAR 0 1
102959: RET
// export function hHackSetLevel10 ; var i , j ; begin
102960: LD_INT 0
102962: PPUSH
102963: PPUSH
102964: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
102965: LD_ADDR_VAR 0 2
102969: PUSH
102970: LD_INT 21
102972: PUSH
102973: LD_INT 1
102975: PUSH
102976: EMPTY
102977: LIST
102978: LIST
102979: PPUSH
102980: CALL_OW 69
102984: PUSH
102985: FOR_IN
102986: IFFALSE 103038
// if IsSelected ( i ) then
102988: LD_VAR 0 2
102992: PPUSH
102993: CALL_OW 306
102997: IFFALSE 103036
// begin for j := 1 to 4 do
102999: LD_ADDR_VAR 0 3
103003: PUSH
103004: DOUBLE
103005: LD_INT 1
103007: DEC
103008: ST_TO_ADDR
103009: LD_INT 4
103011: PUSH
103012: FOR_TO
103013: IFFALSE 103034
// SetSkill ( i , j , 10 ) ;
103015: LD_VAR 0 2
103019: PPUSH
103020: LD_VAR 0 3
103024: PPUSH
103025: LD_INT 10
103027: PPUSH
103028: CALL_OW 237
103032: GO 103012
103034: POP
103035: POP
// end ;
103036: GO 102985
103038: POP
103039: POP
// end ;
103040: LD_VAR 0 1
103044: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
103045: LD_INT 0
103047: PPUSH
103048: PPUSH
103049: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
103050: LD_ADDR_VAR 0 2
103054: PUSH
103055: LD_INT 22
103057: PUSH
103058: LD_OWVAR 2
103062: PUSH
103063: EMPTY
103064: LIST
103065: LIST
103066: PUSH
103067: LD_INT 21
103069: PUSH
103070: LD_INT 1
103072: PUSH
103073: EMPTY
103074: LIST
103075: LIST
103076: PUSH
103077: EMPTY
103078: LIST
103079: LIST
103080: PPUSH
103081: CALL_OW 69
103085: PUSH
103086: FOR_IN
103087: IFFALSE 103128
// begin for j := 1 to 4 do
103089: LD_ADDR_VAR 0 3
103093: PUSH
103094: DOUBLE
103095: LD_INT 1
103097: DEC
103098: ST_TO_ADDR
103099: LD_INT 4
103101: PUSH
103102: FOR_TO
103103: IFFALSE 103124
// SetSkill ( i , j , 10 ) ;
103105: LD_VAR 0 2
103109: PPUSH
103110: LD_VAR 0 3
103114: PPUSH
103115: LD_INT 10
103117: PPUSH
103118: CALL_OW 237
103122: GO 103102
103124: POP
103125: POP
// end ;
103126: GO 103086
103128: POP
103129: POP
// end ;
103130: LD_VAR 0 1
103134: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
103135: LD_INT 0
103137: PPUSH
// uc_side := your_side ;
103138: LD_ADDR_OWVAR 20
103142: PUSH
103143: LD_OWVAR 2
103147: ST_TO_ADDR
// uc_nation := nation ;
103148: LD_ADDR_OWVAR 21
103152: PUSH
103153: LD_VAR 0 1
103157: ST_TO_ADDR
// InitHc ;
103158: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
103162: LD_INT 0
103164: PPUSH
103165: LD_VAR 0 2
103169: PPUSH
103170: LD_VAR 0 3
103174: PPUSH
103175: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
103179: LD_VAR 0 4
103183: PPUSH
103184: LD_VAR 0 5
103188: PPUSH
103189: CALL_OW 428
103193: PUSH
103194: LD_INT 0
103196: EQUAL
103197: IFFALSE 103221
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
103199: CALL_OW 44
103203: PPUSH
103204: LD_VAR 0 4
103208: PPUSH
103209: LD_VAR 0 5
103213: PPUSH
103214: LD_INT 1
103216: PPUSH
103217: CALL_OW 48
// end ;
103221: LD_VAR 0 6
103225: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
103226: LD_INT 0
103228: PPUSH
103229: PPUSH
// uc_side := your_side ;
103230: LD_ADDR_OWVAR 20
103234: PUSH
103235: LD_OWVAR 2
103239: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
103240: LD_VAR 0 1
103244: PUSH
103245: LD_INT 1
103247: PUSH
103248: LD_INT 2
103250: PUSH
103251: LD_INT 3
103253: PUSH
103254: LD_INT 4
103256: PUSH
103257: LD_INT 5
103259: PUSH
103260: EMPTY
103261: LIST
103262: LIST
103263: LIST
103264: LIST
103265: LIST
103266: IN
103267: IFFALSE 103279
// uc_nation := nation_american else
103269: LD_ADDR_OWVAR 21
103273: PUSH
103274: LD_INT 1
103276: ST_TO_ADDR
103277: GO 103322
// if chassis in [ 11 , 12 , 13 , 14 ] then
103279: LD_VAR 0 1
103283: PUSH
103284: LD_INT 11
103286: PUSH
103287: LD_INT 12
103289: PUSH
103290: LD_INT 13
103292: PUSH
103293: LD_INT 14
103295: PUSH
103296: EMPTY
103297: LIST
103298: LIST
103299: LIST
103300: LIST
103301: IN
103302: IFFALSE 103314
// uc_nation := nation_arabian else
103304: LD_ADDR_OWVAR 21
103308: PUSH
103309: LD_INT 2
103311: ST_TO_ADDR
103312: GO 103322
// uc_nation := nation_russian ;
103314: LD_ADDR_OWVAR 21
103318: PUSH
103319: LD_INT 3
103321: ST_TO_ADDR
// vc_chassis := chassis ;
103322: LD_ADDR_OWVAR 37
103326: PUSH
103327: LD_VAR 0 1
103331: ST_TO_ADDR
// vc_engine := engine ;
103332: LD_ADDR_OWVAR 39
103336: PUSH
103337: LD_VAR 0 2
103341: ST_TO_ADDR
// vc_control := control ;
103342: LD_ADDR_OWVAR 38
103346: PUSH
103347: LD_VAR 0 3
103351: ST_TO_ADDR
// vc_weapon := weapon ;
103352: LD_ADDR_OWVAR 40
103356: PUSH
103357: LD_VAR 0 4
103361: ST_TO_ADDR
// un := CreateVehicle ;
103362: LD_ADDR_VAR 0 8
103366: PUSH
103367: CALL_OW 45
103371: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
103372: LD_VAR 0 8
103376: PPUSH
103377: LD_INT 0
103379: PPUSH
103380: LD_INT 5
103382: PPUSH
103383: CALL_OW 12
103387: PPUSH
103388: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
103392: LD_VAR 0 8
103396: PPUSH
103397: LD_VAR 0 5
103401: PPUSH
103402: LD_VAR 0 6
103406: PPUSH
103407: LD_INT 1
103409: PPUSH
103410: CALL_OW 48
// end ;
103414: LD_VAR 0 7
103418: RET
// export hInvincible ; every 1 do
103419: GO 103421
103421: DISABLE
// hInvincible := [ ] ;
103422: LD_ADDR_EXP 164
103426: PUSH
103427: EMPTY
103428: ST_TO_ADDR
103429: END
// every 10 do var i ;
103430: GO 103432
103432: DISABLE
103433: LD_INT 0
103435: PPUSH
// begin enable ;
103436: ENABLE
// if not hInvincible then
103437: LD_EXP 164
103441: NOT
103442: IFFALSE 103446
// exit ;
103444: GO 103490
// for i in hInvincible do
103446: LD_ADDR_VAR 0 1
103450: PUSH
103451: LD_EXP 164
103455: PUSH
103456: FOR_IN
103457: IFFALSE 103488
// if GetLives ( i ) < 1000 then
103459: LD_VAR 0 1
103463: PPUSH
103464: CALL_OW 256
103468: PUSH
103469: LD_INT 1000
103471: LESS
103472: IFFALSE 103486
// SetLives ( i , 1000 ) ;
103474: LD_VAR 0 1
103478: PPUSH
103479: LD_INT 1000
103481: PPUSH
103482: CALL_OW 234
103486: GO 103456
103488: POP
103489: POP
// end ;
103490: PPOPN 1
103492: END
// export function hHackInvincible ; var i ; begin
103493: LD_INT 0
103495: PPUSH
103496: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
103497: LD_ADDR_VAR 0 2
103501: PUSH
103502: LD_INT 2
103504: PUSH
103505: LD_INT 21
103507: PUSH
103508: LD_INT 1
103510: PUSH
103511: EMPTY
103512: LIST
103513: LIST
103514: PUSH
103515: LD_INT 21
103517: PUSH
103518: LD_INT 2
103520: PUSH
103521: EMPTY
103522: LIST
103523: LIST
103524: PUSH
103525: EMPTY
103526: LIST
103527: LIST
103528: LIST
103529: PPUSH
103530: CALL_OW 69
103534: PUSH
103535: FOR_IN
103536: IFFALSE 103597
// if IsSelected ( i ) then
103538: LD_VAR 0 2
103542: PPUSH
103543: CALL_OW 306
103547: IFFALSE 103595
// begin if i in hInvincible then
103549: LD_VAR 0 2
103553: PUSH
103554: LD_EXP 164
103558: IN
103559: IFFALSE 103579
// hInvincible := hInvincible diff i else
103561: LD_ADDR_EXP 164
103565: PUSH
103566: LD_EXP 164
103570: PUSH
103571: LD_VAR 0 2
103575: DIFF
103576: ST_TO_ADDR
103577: GO 103595
// hInvincible := hInvincible union i ;
103579: LD_ADDR_EXP 164
103583: PUSH
103584: LD_EXP 164
103588: PUSH
103589: LD_VAR 0 2
103593: UNION
103594: ST_TO_ADDR
// end ;
103595: GO 103535
103597: POP
103598: POP
// end ;
103599: LD_VAR 0 1
103603: RET
// export function hHackInvisible ; var i , j ; begin
103604: LD_INT 0
103606: PPUSH
103607: PPUSH
103608: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103609: LD_ADDR_VAR 0 2
103613: PUSH
103614: LD_INT 21
103616: PUSH
103617: LD_INT 1
103619: PUSH
103620: EMPTY
103621: LIST
103622: LIST
103623: PPUSH
103624: CALL_OW 69
103628: PUSH
103629: FOR_IN
103630: IFFALSE 103654
// if IsSelected ( i ) then
103632: LD_VAR 0 2
103636: PPUSH
103637: CALL_OW 306
103641: IFFALSE 103652
// ComForceInvisible ( i ) ;
103643: LD_VAR 0 2
103647: PPUSH
103648: CALL_OW 496
103652: GO 103629
103654: POP
103655: POP
// end ;
103656: LD_VAR 0 1
103660: RET
// export function hHackChangeYourSide ; begin
103661: LD_INT 0
103663: PPUSH
// if your_side = 8 then
103664: LD_OWVAR 2
103668: PUSH
103669: LD_INT 8
103671: EQUAL
103672: IFFALSE 103684
// your_side := 0 else
103674: LD_ADDR_OWVAR 2
103678: PUSH
103679: LD_INT 0
103681: ST_TO_ADDR
103682: GO 103698
// your_side := your_side + 1 ;
103684: LD_ADDR_OWVAR 2
103688: PUSH
103689: LD_OWVAR 2
103693: PUSH
103694: LD_INT 1
103696: PLUS
103697: ST_TO_ADDR
// end ;
103698: LD_VAR 0 1
103702: RET
// export function hHackChangeUnitSide ; var i , j ; begin
103703: LD_INT 0
103705: PPUSH
103706: PPUSH
103707: PPUSH
// for i in all_units do
103708: LD_ADDR_VAR 0 2
103712: PUSH
103713: LD_OWVAR 3
103717: PUSH
103718: FOR_IN
103719: IFFALSE 103797
// if IsSelected ( i ) then
103721: LD_VAR 0 2
103725: PPUSH
103726: CALL_OW 306
103730: IFFALSE 103795
// begin j := GetSide ( i ) ;
103732: LD_ADDR_VAR 0 3
103736: PUSH
103737: LD_VAR 0 2
103741: PPUSH
103742: CALL_OW 255
103746: ST_TO_ADDR
// if j = 8 then
103747: LD_VAR 0 3
103751: PUSH
103752: LD_INT 8
103754: EQUAL
103755: IFFALSE 103767
// j := 0 else
103757: LD_ADDR_VAR 0 3
103761: PUSH
103762: LD_INT 0
103764: ST_TO_ADDR
103765: GO 103781
// j := j + 1 ;
103767: LD_ADDR_VAR 0 3
103771: PUSH
103772: LD_VAR 0 3
103776: PUSH
103777: LD_INT 1
103779: PLUS
103780: ST_TO_ADDR
// SetSide ( i , j ) ;
103781: LD_VAR 0 2
103785: PPUSH
103786: LD_VAR 0 3
103790: PPUSH
103791: CALL_OW 235
// end ;
103795: GO 103718
103797: POP
103798: POP
// end ;
103799: LD_VAR 0 1
103803: RET
// export function hHackFog ; begin
103804: LD_INT 0
103806: PPUSH
// FogOff ( true ) ;
103807: LD_INT 1
103809: PPUSH
103810: CALL_OW 344
// end ;
103814: LD_VAR 0 1
103818: RET
// export function hHackTeleport ( unit , x , y ) ; begin
103819: LD_INT 0
103821: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
103822: LD_VAR 0 1
103826: PPUSH
103827: LD_VAR 0 2
103831: PPUSH
103832: LD_VAR 0 3
103836: PPUSH
103837: LD_INT 1
103839: PPUSH
103840: LD_INT 1
103842: PPUSH
103843: CALL_OW 483
// CenterOnXY ( x , y ) ;
103847: LD_VAR 0 2
103851: PPUSH
103852: LD_VAR 0 3
103856: PPUSH
103857: CALL_OW 84
// end ;
103861: LD_VAR 0 4
103865: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
103866: LD_INT 0
103868: PPUSH
103869: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
103870: LD_VAR 0 1
103874: NOT
103875: PUSH
103876: LD_VAR 0 2
103880: PPUSH
103881: LD_VAR 0 3
103885: PPUSH
103886: CALL_OW 488
103890: NOT
103891: OR
103892: PUSH
103893: LD_VAR 0 1
103897: PPUSH
103898: CALL_OW 266
103902: PUSH
103903: LD_INT 3
103905: NONEQUAL
103906: PUSH
103907: LD_VAR 0 1
103911: PPUSH
103912: CALL_OW 247
103916: PUSH
103917: LD_INT 1
103919: EQUAL
103920: NOT
103921: AND
103922: OR
103923: IFFALSE 103927
// exit ;
103925: GO 104076
// if GetType ( factory ) = unit_human then
103927: LD_VAR 0 1
103931: PPUSH
103932: CALL_OW 247
103936: PUSH
103937: LD_INT 1
103939: EQUAL
103940: IFFALSE 103957
// factory := IsInUnit ( factory ) ;
103942: LD_ADDR_VAR 0 1
103946: PUSH
103947: LD_VAR 0 1
103951: PPUSH
103952: CALL_OW 310
103956: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
103957: LD_VAR 0 1
103961: PPUSH
103962: CALL_OW 266
103966: PUSH
103967: LD_INT 3
103969: NONEQUAL
103970: IFFALSE 103974
// exit ;
103972: GO 104076
// if HexInfo ( x , y ) = factory then
103974: LD_VAR 0 2
103978: PPUSH
103979: LD_VAR 0 3
103983: PPUSH
103984: CALL_OW 428
103988: PUSH
103989: LD_VAR 0 1
103993: EQUAL
103994: IFFALSE 104021
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
103996: LD_ADDR_EXP 165
104000: PUSH
104001: LD_EXP 165
104005: PPUSH
104006: LD_VAR 0 1
104010: PPUSH
104011: LD_INT 0
104013: PPUSH
104014: CALL_OW 1
104018: ST_TO_ADDR
104019: GO 104072
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
104021: LD_ADDR_EXP 165
104025: PUSH
104026: LD_EXP 165
104030: PPUSH
104031: LD_VAR 0 1
104035: PPUSH
104036: LD_VAR 0 1
104040: PPUSH
104041: CALL_OW 255
104045: PUSH
104046: LD_VAR 0 1
104050: PUSH
104051: LD_VAR 0 2
104055: PUSH
104056: LD_VAR 0 3
104060: PUSH
104061: EMPTY
104062: LIST
104063: LIST
104064: LIST
104065: LIST
104066: PPUSH
104067: CALL_OW 1
104071: ST_TO_ADDR
// UpdateFactoryWaypoints ;
104072: CALL 104081 0 0
// end ;
104076: LD_VAR 0 4
104080: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
104081: LD_INT 0
104083: PPUSH
104084: PPUSH
104085: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
104086: LD_STRING resetFactoryWaypoint();
104088: PPUSH
104089: CALL_OW 559
// if factoryWaypoints then
104093: LD_EXP 165
104097: IFFALSE 104223
// begin list := PrepareArray ( factoryWaypoints ) ;
104099: LD_ADDR_VAR 0 3
104103: PUSH
104104: LD_EXP 165
104108: PPUSH
104109: CALL 57895 0 1
104113: ST_TO_ADDR
// for i := 1 to list do
104114: LD_ADDR_VAR 0 2
104118: PUSH
104119: DOUBLE
104120: LD_INT 1
104122: DEC
104123: ST_TO_ADDR
104124: LD_VAR 0 3
104128: PUSH
104129: FOR_TO
104130: IFFALSE 104221
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104132: LD_STRING setFactoryWaypointXY(
104134: PUSH
104135: LD_VAR 0 3
104139: PUSH
104140: LD_VAR 0 2
104144: ARRAY
104145: PUSH
104146: LD_INT 1
104148: ARRAY
104149: STR
104150: PUSH
104151: LD_STRING ,
104153: STR
104154: PUSH
104155: LD_VAR 0 3
104159: PUSH
104160: LD_VAR 0 2
104164: ARRAY
104165: PUSH
104166: LD_INT 2
104168: ARRAY
104169: STR
104170: PUSH
104171: LD_STRING ,
104173: STR
104174: PUSH
104175: LD_VAR 0 3
104179: PUSH
104180: LD_VAR 0 2
104184: ARRAY
104185: PUSH
104186: LD_INT 3
104188: ARRAY
104189: STR
104190: PUSH
104191: LD_STRING ,
104193: STR
104194: PUSH
104195: LD_VAR 0 3
104199: PUSH
104200: LD_VAR 0 2
104204: ARRAY
104205: PUSH
104206: LD_INT 4
104208: ARRAY
104209: STR
104210: PUSH
104211: LD_STRING )
104213: STR
104214: PPUSH
104215: CALL_OW 559
104219: GO 104129
104221: POP
104222: POP
// end ; end ;
104223: LD_VAR 0 1
104227: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
104228: LD_INT 0
104230: PPUSH
// if HexInfo ( x , y ) = warehouse then
104231: LD_VAR 0 2
104235: PPUSH
104236: LD_VAR 0 3
104240: PPUSH
104241: CALL_OW 428
104245: PUSH
104246: LD_VAR 0 1
104250: EQUAL
104251: IFFALSE 104278
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
104253: LD_ADDR_EXP 166
104257: PUSH
104258: LD_EXP 166
104262: PPUSH
104263: LD_VAR 0 1
104267: PPUSH
104268: LD_INT 0
104270: PPUSH
104271: CALL_OW 1
104275: ST_TO_ADDR
104276: GO 104329
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
104278: LD_ADDR_EXP 166
104282: PUSH
104283: LD_EXP 166
104287: PPUSH
104288: LD_VAR 0 1
104292: PPUSH
104293: LD_VAR 0 1
104297: PPUSH
104298: CALL_OW 255
104302: PUSH
104303: LD_VAR 0 1
104307: PUSH
104308: LD_VAR 0 2
104312: PUSH
104313: LD_VAR 0 3
104317: PUSH
104318: EMPTY
104319: LIST
104320: LIST
104321: LIST
104322: LIST
104323: PPUSH
104324: CALL_OW 1
104328: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
104329: CALL 104338 0 0
// end ;
104333: LD_VAR 0 4
104337: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
104338: LD_INT 0
104340: PPUSH
104341: PPUSH
104342: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
104343: LD_STRING resetWarehouseGatheringPoints();
104345: PPUSH
104346: CALL_OW 559
// if warehouseGatheringPoints then
104350: LD_EXP 166
104354: IFFALSE 104480
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
104356: LD_ADDR_VAR 0 3
104360: PUSH
104361: LD_EXP 166
104365: PPUSH
104366: CALL 57895 0 1
104370: ST_TO_ADDR
// for i := 1 to list do
104371: LD_ADDR_VAR 0 2
104375: PUSH
104376: DOUBLE
104377: LD_INT 1
104379: DEC
104380: ST_TO_ADDR
104381: LD_VAR 0 3
104385: PUSH
104386: FOR_TO
104387: IFFALSE 104478
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104389: LD_STRING setWarehouseGatheringPointXY(
104391: PUSH
104392: LD_VAR 0 3
104396: PUSH
104397: LD_VAR 0 2
104401: ARRAY
104402: PUSH
104403: LD_INT 1
104405: ARRAY
104406: STR
104407: PUSH
104408: LD_STRING ,
104410: STR
104411: PUSH
104412: LD_VAR 0 3
104416: PUSH
104417: LD_VAR 0 2
104421: ARRAY
104422: PUSH
104423: LD_INT 2
104425: ARRAY
104426: STR
104427: PUSH
104428: LD_STRING ,
104430: STR
104431: PUSH
104432: LD_VAR 0 3
104436: PUSH
104437: LD_VAR 0 2
104441: ARRAY
104442: PUSH
104443: LD_INT 3
104445: ARRAY
104446: STR
104447: PUSH
104448: LD_STRING ,
104450: STR
104451: PUSH
104452: LD_VAR 0 3
104456: PUSH
104457: LD_VAR 0 2
104461: ARRAY
104462: PUSH
104463: LD_INT 4
104465: ARRAY
104466: STR
104467: PUSH
104468: LD_STRING )
104470: STR
104471: PPUSH
104472: CALL_OW 559
104476: GO 104386
104478: POP
104479: POP
// end ; end ;
104480: LD_VAR 0 1
104484: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
104485: LD_EXP 166
104489: IFFALSE 105174
104491: GO 104493
104493: DISABLE
104494: LD_INT 0
104496: PPUSH
104497: PPUSH
104498: PPUSH
104499: PPUSH
104500: PPUSH
104501: PPUSH
104502: PPUSH
104503: PPUSH
104504: PPUSH
// begin enable ;
104505: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
104506: LD_ADDR_VAR 0 3
104510: PUSH
104511: LD_EXP 166
104515: PPUSH
104516: CALL 57895 0 1
104520: ST_TO_ADDR
// if not list then
104521: LD_VAR 0 3
104525: NOT
104526: IFFALSE 104530
// exit ;
104528: GO 105174
// for i := 1 to list do
104530: LD_ADDR_VAR 0 1
104534: PUSH
104535: DOUBLE
104536: LD_INT 1
104538: DEC
104539: ST_TO_ADDR
104540: LD_VAR 0 3
104544: PUSH
104545: FOR_TO
104546: IFFALSE 105172
// begin depot := list [ i ] [ 2 ] ;
104548: LD_ADDR_VAR 0 8
104552: PUSH
104553: LD_VAR 0 3
104557: PUSH
104558: LD_VAR 0 1
104562: ARRAY
104563: PUSH
104564: LD_INT 2
104566: ARRAY
104567: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
104568: LD_ADDR_VAR 0 5
104572: PUSH
104573: LD_VAR 0 3
104577: PUSH
104578: LD_VAR 0 1
104582: ARRAY
104583: PUSH
104584: LD_INT 1
104586: ARRAY
104587: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
104588: LD_VAR 0 8
104592: PPUSH
104593: CALL_OW 301
104597: PUSH
104598: LD_VAR 0 5
104602: PUSH
104603: LD_VAR 0 8
104607: PPUSH
104608: CALL_OW 255
104612: NONEQUAL
104613: OR
104614: IFFALSE 104643
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
104616: LD_ADDR_EXP 166
104620: PUSH
104621: LD_EXP 166
104625: PPUSH
104626: LD_VAR 0 8
104630: PPUSH
104631: LD_INT 0
104633: PPUSH
104634: CALL_OW 1
104638: ST_TO_ADDR
// exit ;
104639: POP
104640: POP
104641: GO 105174
// end ; x := list [ i ] [ 3 ] ;
104643: LD_ADDR_VAR 0 6
104647: PUSH
104648: LD_VAR 0 3
104652: PUSH
104653: LD_VAR 0 1
104657: ARRAY
104658: PUSH
104659: LD_INT 3
104661: ARRAY
104662: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
104663: LD_ADDR_VAR 0 7
104667: PUSH
104668: LD_VAR 0 3
104672: PUSH
104673: LD_VAR 0 1
104677: ARRAY
104678: PUSH
104679: LD_INT 4
104681: ARRAY
104682: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
104683: LD_ADDR_VAR 0 9
104687: PUSH
104688: LD_VAR 0 6
104692: PPUSH
104693: LD_VAR 0 7
104697: PPUSH
104698: LD_INT 16
104700: PPUSH
104701: CALL 56483 0 3
104705: ST_TO_ADDR
// if not cratesNearbyPoint then
104706: LD_VAR 0 9
104710: NOT
104711: IFFALSE 104717
// exit ;
104713: POP
104714: POP
104715: GO 105174
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
104717: LD_ADDR_VAR 0 4
104721: PUSH
104722: LD_INT 22
104724: PUSH
104725: LD_VAR 0 5
104729: PUSH
104730: EMPTY
104731: LIST
104732: LIST
104733: PUSH
104734: LD_INT 3
104736: PUSH
104737: LD_INT 60
104739: PUSH
104740: EMPTY
104741: LIST
104742: PUSH
104743: EMPTY
104744: LIST
104745: LIST
104746: PUSH
104747: LD_INT 91
104749: PUSH
104750: LD_VAR 0 8
104754: PUSH
104755: LD_INT 6
104757: PUSH
104758: EMPTY
104759: LIST
104760: LIST
104761: LIST
104762: PUSH
104763: LD_INT 2
104765: PUSH
104766: LD_INT 25
104768: PUSH
104769: LD_INT 2
104771: PUSH
104772: EMPTY
104773: LIST
104774: LIST
104775: PUSH
104776: LD_INT 25
104778: PUSH
104779: LD_INT 16
104781: PUSH
104782: EMPTY
104783: LIST
104784: LIST
104785: PUSH
104786: EMPTY
104787: LIST
104788: LIST
104789: LIST
104790: PUSH
104791: EMPTY
104792: LIST
104793: LIST
104794: LIST
104795: LIST
104796: PPUSH
104797: CALL_OW 69
104801: PUSH
104802: LD_VAR 0 8
104806: PPUSH
104807: CALL_OW 313
104811: PPUSH
104812: LD_INT 3
104814: PUSH
104815: LD_INT 60
104817: PUSH
104818: EMPTY
104819: LIST
104820: PUSH
104821: EMPTY
104822: LIST
104823: LIST
104824: PUSH
104825: LD_INT 2
104827: PUSH
104828: LD_INT 25
104830: PUSH
104831: LD_INT 2
104833: PUSH
104834: EMPTY
104835: LIST
104836: LIST
104837: PUSH
104838: LD_INT 25
104840: PUSH
104841: LD_INT 16
104843: PUSH
104844: EMPTY
104845: LIST
104846: LIST
104847: PUSH
104848: EMPTY
104849: LIST
104850: LIST
104851: LIST
104852: PUSH
104853: EMPTY
104854: LIST
104855: LIST
104856: PPUSH
104857: CALL_OW 72
104861: UNION
104862: ST_TO_ADDR
// if tmp then
104863: LD_VAR 0 4
104867: IFFALSE 104947
// begin tmp := ShrinkArray ( tmp , 3 ) ;
104869: LD_ADDR_VAR 0 4
104873: PUSH
104874: LD_VAR 0 4
104878: PPUSH
104879: LD_INT 3
104881: PPUSH
104882: CALL 54452 0 2
104886: ST_TO_ADDR
// for j in tmp do
104887: LD_ADDR_VAR 0 2
104891: PUSH
104892: LD_VAR 0 4
104896: PUSH
104897: FOR_IN
104898: IFFALSE 104941
// begin if IsInUnit ( j ) then
104900: LD_VAR 0 2
104904: PPUSH
104905: CALL_OW 310
104909: IFFALSE 104920
// ComExit ( j ) ;
104911: LD_VAR 0 2
104915: PPUSH
104916: CALL 54535 0 1
// AddComCollect ( j , x , y ) ;
104920: LD_VAR 0 2
104924: PPUSH
104925: LD_VAR 0 6
104929: PPUSH
104930: LD_VAR 0 7
104934: PPUSH
104935: CALL_OW 177
// end ;
104939: GO 104897
104941: POP
104942: POP
// exit ;
104943: POP
104944: POP
104945: GO 105174
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
104947: LD_ADDR_VAR 0 4
104951: PUSH
104952: LD_INT 22
104954: PUSH
104955: LD_VAR 0 5
104959: PUSH
104960: EMPTY
104961: LIST
104962: LIST
104963: PUSH
104964: LD_INT 91
104966: PUSH
104967: LD_VAR 0 8
104971: PUSH
104972: LD_INT 8
104974: PUSH
104975: EMPTY
104976: LIST
104977: LIST
104978: LIST
104979: PUSH
104980: LD_INT 2
104982: PUSH
104983: LD_INT 34
104985: PUSH
104986: LD_INT 12
104988: PUSH
104989: EMPTY
104990: LIST
104991: LIST
104992: PUSH
104993: LD_INT 34
104995: PUSH
104996: LD_INT 51
104998: PUSH
104999: EMPTY
105000: LIST
105001: LIST
105002: PUSH
105003: LD_INT 34
105005: PUSH
105006: LD_INT 32
105008: PUSH
105009: EMPTY
105010: LIST
105011: LIST
105012: PUSH
105013: LD_INT 34
105015: PUSH
105016: LD_INT 89
105018: PUSH
105019: EMPTY
105020: LIST
105021: LIST
105022: PUSH
105023: EMPTY
105024: LIST
105025: LIST
105026: LIST
105027: LIST
105028: LIST
105029: PUSH
105030: EMPTY
105031: LIST
105032: LIST
105033: LIST
105034: PPUSH
105035: CALL_OW 69
105039: ST_TO_ADDR
// if tmp then
105040: LD_VAR 0 4
105044: IFFALSE 105170
// begin for j in tmp do
105046: LD_ADDR_VAR 0 2
105050: PUSH
105051: LD_VAR 0 4
105055: PUSH
105056: FOR_IN
105057: IFFALSE 105168
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
105059: LD_VAR 0 2
105063: PPUSH
105064: CALL_OW 262
105068: PUSH
105069: LD_INT 3
105071: EQUAL
105072: PUSH
105073: LD_VAR 0 2
105077: PPUSH
105078: CALL_OW 261
105082: PUSH
105083: LD_INT 20
105085: GREATER
105086: OR
105087: PUSH
105088: LD_VAR 0 2
105092: PPUSH
105093: CALL_OW 314
105097: NOT
105098: AND
105099: PUSH
105100: LD_VAR 0 2
105104: PPUSH
105105: CALL_OW 263
105109: PUSH
105110: LD_INT 1
105112: NONEQUAL
105113: PUSH
105114: LD_VAR 0 2
105118: PPUSH
105119: CALL_OW 311
105123: OR
105124: AND
105125: IFFALSE 105166
// begin ComCollect ( j , x , y ) ;
105127: LD_VAR 0 2
105131: PPUSH
105132: LD_VAR 0 6
105136: PPUSH
105137: LD_VAR 0 7
105141: PPUSH
105142: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
105146: LD_VAR 0 2
105150: PPUSH
105151: LD_VAR 0 8
105155: PPUSH
105156: CALL_OW 172
// exit ;
105160: POP
105161: POP
105162: POP
105163: POP
105164: GO 105174
// end ;
105166: GO 105056
105168: POP
105169: POP
// end ; end ;
105170: GO 104545
105172: POP
105173: POP
// end ; end_of_file
105174: PPOPN 9
105176: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
105177: LD_INT 0
105179: PPUSH
105180: PPUSH
105181: PPUSH
105182: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105183: LD_VAR 0 1
105187: PPUSH
105188: CALL_OW 264
105192: PUSH
105193: LD_INT 91
105195: EQUAL
105196: IFFALSE 105268
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105198: LD_INT 68
105200: PPUSH
105201: LD_VAR 0 1
105205: PPUSH
105206: CALL_OW 255
105210: PPUSH
105211: CALL_OW 321
105215: PUSH
105216: LD_INT 2
105218: EQUAL
105219: IFFALSE 105231
// eff := 70 else
105221: LD_ADDR_VAR 0 4
105225: PUSH
105226: LD_INT 70
105228: ST_TO_ADDR
105229: GO 105239
// eff := 30 ;
105231: LD_ADDR_VAR 0 4
105235: PUSH
105236: LD_INT 30
105238: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105239: LD_VAR 0 1
105243: PPUSH
105244: CALL_OW 250
105248: PPUSH
105249: LD_VAR 0 1
105253: PPUSH
105254: CALL_OW 251
105258: PPUSH
105259: LD_VAR 0 4
105263: PPUSH
105264: CALL_OW 495
// end ; end ;
105268: LD_VAR 0 2
105272: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
105273: LD_INT 0
105275: PPUSH
// end ;
105276: LD_VAR 0 4
105280: RET
// export function SOS_Command ( cmd ) ; begin
105281: LD_INT 0
105283: PPUSH
// end ;
105284: LD_VAR 0 2
105288: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
105289: LD_INT 0
105291: PPUSH
// end ;
105292: LD_VAR 0 6
105296: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
105297: LD_INT 0
105299: PPUSH
105300: PPUSH
// if not vehicle or not factory then
105301: LD_VAR 0 1
105305: NOT
105306: PUSH
105307: LD_VAR 0 2
105311: NOT
105312: OR
105313: IFFALSE 105317
// exit ;
105315: GO 105548
// if factoryWaypoints >= factory then
105317: LD_EXP 165
105321: PUSH
105322: LD_VAR 0 2
105326: GREATEREQUAL
105327: IFFALSE 105548
// if factoryWaypoints [ factory ] then
105329: LD_EXP 165
105333: PUSH
105334: LD_VAR 0 2
105338: ARRAY
105339: IFFALSE 105548
// begin if GetControl ( vehicle ) = control_manual then
105341: LD_VAR 0 1
105345: PPUSH
105346: CALL_OW 263
105350: PUSH
105351: LD_INT 1
105353: EQUAL
105354: IFFALSE 105435
// begin driver := IsDrivenBy ( vehicle ) ;
105356: LD_ADDR_VAR 0 4
105360: PUSH
105361: LD_VAR 0 1
105365: PPUSH
105366: CALL_OW 311
105370: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105371: LD_VAR 0 4
105375: PPUSH
105376: LD_EXP 165
105380: PUSH
105381: LD_VAR 0 2
105385: ARRAY
105386: PUSH
105387: LD_INT 3
105389: ARRAY
105390: PPUSH
105391: LD_EXP 165
105395: PUSH
105396: LD_VAR 0 2
105400: ARRAY
105401: PUSH
105402: LD_INT 4
105404: ARRAY
105405: PPUSH
105406: CALL_OW 171
// AddComExitVehicle ( driver ) ;
105410: LD_VAR 0 4
105414: PPUSH
105415: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
105419: LD_VAR 0 4
105423: PPUSH
105424: LD_VAR 0 2
105428: PPUSH
105429: CALL_OW 180
// end else
105433: GO 105548
// if GetControl ( vehicle ) = control_remote then
105435: LD_VAR 0 1
105439: PPUSH
105440: CALL_OW 263
105444: PUSH
105445: LD_INT 2
105447: EQUAL
105448: IFFALSE 105509
// begin wait ( 0 0$2 ) ;
105450: LD_INT 70
105452: PPUSH
105453: CALL_OW 67
// if Connect ( vehicle ) then
105457: LD_VAR 0 1
105461: PPUSH
105462: CALL 24743 0 1
105466: IFFALSE 105507
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105468: LD_VAR 0 1
105472: PPUSH
105473: LD_EXP 165
105477: PUSH
105478: LD_VAR 0 2
105482: ARRAY
105483: PUSH
105484: LD_INT 3
105486: ARRAY
105487: PPUSH
105488: LD_EXP 165
105492: PUSH
105493: LD_VAR 0 2
105497: ARRAY
105498: PUSH
105499: LD_INT 4
105501: ARRAY
105502: PPUSH
105503: CALL_OW 171
// end else
105507: GO 105548
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105509: LD_VAR 0 1
105513: PPUSH
105514: LD_EXP 165
105518: PUSH
105519: LD_VAR 0 2
105523: ARRAY
105524: PUSH
105525: LD_INT 3
105527: ARRAY
105528: PPUSH
105529: LD_EXP 165
105533: PUSH
105534: LD_VAR 0 2
105538: ARRAY
105539: PUSH
105540: LD_INT 4
105542: ARRAY
105543: PPUSH
105544: CALL_OW 171
// end ; end ;
105548: LD_VAR 0 3
105552: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
105553: LD_INT 0
105555: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
105556: LD_VAR 0 1
105560: PUSH
105561: LD_INT 250
105563: EQUAL
105564: PUSH
105565: LD_VAR 0 2
105569: PPUSH
105570: CALL_OW 264
105574: PUSH
105575: LD_INT 81
105577: EQUAL
105578: AND
105579: IFFALSE 105600
// MinerPlaceMine ( unit , x , y ) ;
105581: LD_VAR 0 2
105585: PPUSH
105586: LD_VAR 0 4
105590: PPUSH
105591: LD_VAR 0 5
105595: PPUSH
105596: CALL 108590 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
105600: LD_VAR 0 1
105604: PUSH
105605: LD_INT 251
105607: EQUAL
105608: PUSH
105609: LD_VAR 0 2
105613: PPUSH
105614: CALL_OW 264
105618: PUSH
105619: LD_INT 81
105621: EQUAL
105622: AND
105623: IFFALSE 105644
// MinerDetonateMine ( unit , x , y ) ;
105625: LD_VAR 0 2
105629: PPUSH
105630: LD_VAR 0 4
105634: PPUSH
105635: LD_VAR 0 5
105639: PPUSH
105640: CALL 108865 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
105644: LD_VAR 0 1
105648: PUSH
105649: LD_INT 252
105651: EQUAL
105652: PUSH
105653: LD_VAR 0 2
105657: PPUSH
105658: CALL_OW 264
105662: PUSH
105663: LD_INT 81
105665: EQUAL
105666: AND
105667: IFFALSE 105688
// MinerCreateMinefield ( unit , x , y ) ;
105669: LD_VAR 0 2
105673: PPUSH
105674: LD_VAR 0 4
105678: PPUSH
105679: LD_VAR 0 5
105683: PPUSH
105684: CALL 109282 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
105688: LD_VAR 0 1
105692: PUSH
105693: LD_INT 253
105695: EQUAL
105696: PUSH
105697: LD_VAR 0 2
105701: PPUSH
105702: CALL_OW 257
105706: PUSH
105707: LD_INT 5
105709: EQUAL
105710: AND
105711: IFFALSE 105732
// ComBinocular ( unit , x , y ) ;
105713: LD_VAR 0 2
105717: PPUSH
105718: LD_VAR 0 4
105722: PPUSH
105723: LD_VAR 0 5
105727: PPUSH
105728: CALL 109651 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
105732: LD_VAR 0 1
105736: PUSH
105737: LD_INT 254
105739: EQUAL
105740: PUSH
105741: LD_VAR 0 2
105745: PPUSH
105746: CALL_OW 264
105750: PUSH
105751: LD_INT 99
105753: EQUAL
105754: AND
105755: PUSH
105756: LD_VAR 0 3
105760: PPUSH
105761: CALL_OW 263
105765: PUSH
105766: LD_INT 3
105768: EQUAL
105769: AND
105770: IFFALSE 105786
// HackDestroyVehicle ( unit , selectedUnit ) ;
105772: LD_VAR 0 2
105776: PPUSH
105777: LD_VAR 0 3
105781: PPUSH
105782: CALL 107954 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
105786: LD_VAR 0 1
105790: PUSH
105791: LD_INT 255
105793: EQUAL
105794: PUSH
105795: LD_VAR 0 2
105799: PPUSH
105800: CALL_OW 264
105804: PUSH
105805: LD_INT 14
105807: PUSH
105808: LD_INT 53
105810: PUSH
105811: EMPTY
105812: LIST
105813: LIST
105814: IN
105815: AND
105816: PUSH
105817: LD_VAR 0 4
105821: PPUSH
105822: LD_VAR 0 5
105826: PPUSH
105827: CALL_OW 488
105831: AND
105832: IFFALSE 105856
// CutTreeXYR ( unit , x , y , 12 ) ;
105834: LD_VAR 0 2
105838: PPUSH
105839: LD_VAR 0 4
105843: PPUSH
105844: LD_VAR 0 5
105848: PPUSH
105849: LD_INT 12
105851: PPUSH
105852: CALL 105951 0 4
// if cmd = 256 then
105856: LD_VAR 0 1
105860: PUSH
105861: LD_INT 256
105863: EQUAL
105864: IFFALSE 105885
// SetFactoryWaypoint ( unit , x , y ) ;
105866: LD_VAR 0 2
105870: PPUSH
105871: LD_VAR 0 4
105875: PPUSH
105876: LD_VAR 0 5
105880: PPUSH
105881: CALL 103866 0 3
// if cmd = 257 then
105885: LD_VAR 0 1
105889: PUSH
105890: LD_INT 257
105892: EQUAL
105893: IFFALSE 105914
// SetWarehouseGatheringPoint ( unit , x , y ) ;
105895: LD_VAR 0 2
105899: PPUSH
105900: LD_VAR 0 4
105904: PPUSH
105905: LD_VAR 0 5
105909: PPUSH
105910: CALL 104228 0 3
// if cmd = 258 then
105914: LD_VAR 0 1
105918: PUSH
105919: LD_INT 258
105921: EQUAL
105922: IFFALSE 105946
// BurnTreeXYR ( unit , x , y , 8 ) ;
105924: LD_VAR 0 2
105928: PPUSH
105929: LD_VAR 0 4
105933: PPUSH
105934: LD_VAR 0 5
105938: PPUSH
105939: LD_INT 8
105941: PPUSH
105942: CALL 106345 0 4
// end ;
105946: LD_VAR 0 6
105950: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
105951: LD_INT 0
105953: PPUSH
105954: PPUSH
105955: PPUSH
105956: PPUSH
105957: PPUSH
105958: PPUSH
105959: PPUSH
105960: PPUSH
105961: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
105962: LD_VAR 0 1
105966: PPUSH
105967: CALL_OW 302
105971: NOT
105972: PUSH
105973: LD_VAR 0 2
105977: PPUSH
105978: LD_VAR 0 3
105982: PPUSH
105983: CALL_OW 488
105987: NOT
105988: OR
105989: PUSH
105990: LD_VAR 0 4
105994: NOT
105995: OR
105996: IFFALSE 106000
// exit ;
105998: GO 106340
// list := [ ] ;
106000: LD_ADDR_VAR 0 13
106004: PUSH
106005: EMPTY
106006: ST_TO_ADDR
// if x - r < 0 then
106007: LD_VAR 0 2
106011: PUSH
106012: LD_VAR 0 4
106016: MINUS
106017: PUSH
106018: LD_INT 0
106020: LESS
106021: IFFALSE 106033
// min_x := 0 else
106023: LD_ADDR_VAR 0 7
106027: PUSH
106028: LD_INT 0
106030: ST_TO_ADDR
106031: GO 106049
// min_x := x - r ;
106033: LD_ADDR_VAR 0 7
106037: PUSH
106038: LD_VAR 0 2
106042: PUSH
106043: LD_VAR 0 4
106047: MINUS
106048: ST_TO_ADDR
// if y - r < 0 then
106049: LD_VAR 0 3
106053: PUSH
106054: LD_VAR 0 4
106058: MINUS
106059: PUSH
106060: LD_INT 0
106062: LESS
106063: IFFALSE 106075
// min_y := 0 else
106065: LD_ADDR_VAR 0 8
106069: PUSH
106070: LD_INT 0
106072: ST_TO_ADDR
106073: GO 106091
// min_y := y - r ;
106075: LD_ADDR_VAR 0 8
106079: PUSH
106080: LD_VAR 0 3
106084: PUSH
106085: LD_VAR 0 4
106089: MINUS
106090: ST_TO_ADDR
// max_x := x + r ;
106091: LD_ADDR_VAR 0 9
106095: PUSH
106096: LD_VAR 0 2
106100: PUSH
106101: LD_VAR 0 4
106105: PLUS
106106: ST_TO_ADDR
// max_y := y + r ;
106107: LD_ADDR_VAR 0 10
106111: PUSH
106112: LD_VAR 0 3
106116: PUSH
106117: LD_VAR 0 4
106121: PLUS
106122: ST_TO_ADDR
// for _x = min_x to max_x do
106123: LD_ADDR_VAR 0 11
106127: PUSH
106128: DOUBLE
106129: LD_VAR 0 7
106133: DEC
106134: ST_TO_ADDR
106135: LD_VAR 0 9
106139: PUSH
106140: FOR_TO
106141: IFFALSE 106258
// for _y = min_y to max_y do
106143: LD_ADDR_VAR 0 12
106147: PUSH
106148: DOUBLE
106149: LD_VAR 0 8
106153: DEC
106154: ST_TO_ADDR
106155: LD_VAR 0 10
106159: PUSH
106160: FOR_TO
106161: IFFALSE 106254
// begin if not ValidHex ( _x , _y ) then
106163: LD_VAR 0 11
106167: PPUSH
106168: LD_VAR 0 12
106172: PPUSH
106173: CALL_OW 488
106177: NOT
106178: IFFALSE 106182
// continue ;
106180: GO 106160
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106182: LD_VAR 0 11
106186: PPUSH
106187: LD_VAR 0 12
106191: PPUSH
106192: CALL_OW 351
106196: PUSH
106197: LD_VAR 0 11
106201: PPUSH
106202: LD_VAR 0 12
106206: PPUSH
106207: CALL_OW 554
106211: AND
106212: IFFALSE 106252
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106214: LD_ADDR_VAR 0 13
106218: PUSH
106219: LD_VAR 0 13
106223: PPUSH
106224: LD_VAR 0 13
106228: PUSH
106229: LD_INT 1
106231: PLUS
106232: PPUSH
106233: LD_VAR 0 11
106237: PUSH
106238: LD_VAR 0 12
106242: PUSH
106243: EMPTY
106244: LIST
106245: LIST
106246: PPUSH
106247: CALL_OW 2
106251: ST_TO_ADDR
// end ;
106252: GO 106160
106254: POP
106255: POP
106256: GO 106140
106258: POP
106259: POP
// if not list then
106260: LD_VAR 0 13
106264: NOT
106265: IFFALSE 106269
// exit ;
106267: GO 106340
// for i in list do
106269: LD_ADDR_VAR 0 6
106273: PUSH
106274: LD_VAR 0 13
106278: PUSH
106279: FOR_IN
106280: IFFALSE 106338
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106282: LD_VAR 0 1
106286: PPUSH
106287: LD_STRING M
106289: PUSH
106290: LD_VAR 0 6
106294: PUSH
106295: LD_INT 1
106297: ARRAY
106298: PUSH
106299: LD_VAR 0 6
106303: PUSH
106304: LD_INT 2
106306: ARRAY
106307: PUSH
106308: LD_INT 0
106310: PUSH
106311: LD_INT 0
106313: PUSH
106314: LD_INT 0
106316: PUSH
106317: LD_INT 0
106319: PUSH
106320: EMPTY
106321: LIST
106322: LIST
106323: LIST
106324: LIST
106325: LIST
106326: LIST
106327: LIST
106328: PUSH
106329: EMPTY
106330: LIST
106331: PPUSH
106332: CALL_OW 447
106336: GO 106279
106338: POP
106339: POP
// end ;
106340: LD_VAR 0 5
106344: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
106345: LD_INT 0
106347: PPUSH
106348: PPUSH
106349: PPUSH
106350: PPUSH
106351: PPUSH
106352: PPUSH
106353: PPUSH
106354: PPUSH
106355: PPUSH
106356: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
106357: LD_VAR 0 1
106361: PPUSH
106362: CALL_OW 302
106366: NOT
106367: PUSH
106368: LD_VAR 0 2
106372: PPUSH
106373: LD_VAR 0 3
106377: PPUSH
106378: CALL_OW 488
106382: NOT
106383: OR
106384: PUSH
106385: LD_VAR 0 4
106389: NOT
106390: OR
106391: IFFALSE 106395
// exit ;
106393: GO 106908
// list := [ ] ;
106395: LD_ADDR_VAR 0 13
106399: PUSH
106400: EMPTY
106401: ST_TO_ADDR
// if x - r < 0 then
106402: LD_VAR 0 2
106406: PUSH
106407: LD_VAR 0 4
106411: MINUS
106412: PUSH
106413: LD_INT 0
106415: LESS
106416: IFFALSE 106428
// min_x := 0 else
106418: LD_ADDR_VAR 0 7
106422: PUSH
106423: LD_INT 0
106425: ST_TO_ADDR
106426: GO 106444
// min_x := x - r ;
106428: LD_ADDR_VAR 0 7
106432: PUSH
106433: LD_VAR 0 2
106437: PUSH
106438: LD_VAR 0 4
106442: MINUS
106443: ST_TO_ADDR
// if y - r < 0 then
106444: LD_VAR 0 3
106448: PUSH
106449: LD_VAR 0 4
106453: MINUS
106454: PUSH
106455: LD_INT 0
106457: LESS
106458: IFFALSE 106470
// min_y := 0 else
106460: LD_ADDR_VAR 0 8
106464: PUSH
106465: LD_INT 0
106467: ST_TO_ADDR
106468: GO 106486
// min_y := y - r ;
106470: LD_ADDR_VAR 0 8
106474: PUSH
106475: LD_VAR 0 3
106479: PUSH
106480: LD_VAR 0 4
106484: MINUS
106485: ST_TO_ADDR
// max_x := x + r ;
106486: LD_ADDR_VAR 0 9
106490: PUSH
106491: LD_VAR 0 2
106495: PUSH
106496: LD_VAR 0 4
106500: PLUS
106501: ST_TO_ADDR
// max_y := y + r ;
106502: LD_ADDR_VAR 0 10
106506: PUSH
106507: LD_VAR 0 3
106511: PUSH
106512: LD_VAR 0 4
106516: PLUS
106517: ST_TO_ADDR
// for _x = min_x to max_x do
106518: LD_ADDR_VAR 0 11
106522: PUSH
106523: DOUBLE
106524: LD_VAR 0 7
106528: DEC
106529: ST_TO_ADDR
106530: LD_VAR 0 9
106534: PUSH
106535: FOR_TO
106536: IFFALSE 106653
// for _y = min_y to max_y do
106538: LD_ADDR_VAR 0 12
106542: PUSH
106543: DOUBLE
106544: LD_VAR 0 8
106548: DEC
106549: ST_TO_ADDR
106550: LD_VAR 0 10
106554: PUSH
106555: FOR_TO
106556: IFFALSE 106649
// begin if not ValidHex ( _x , _y ) then
106558: LD_VAR 0 11
106562: PPUSH
106563: LD_VAR 0 12
106567: PPUSH
106568: CALL_OW 488
106572: NOT
106573: IFFALSE 106577
// continue ;
106575: GO 106555
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106577: LD_VAR 0 11
106581: PPUSH
106582: LD_VAR 0 12
106586: PPUSH
106587: CALL_OW 351
106591: PUSH
106592: LD_VAR 0 11
106596: PPUSH
106597: LD_VAR 0 12
106601: PPUSH
106602: CALL_OW 554
106606: AND
106607: IFFALSE 106647
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106609: LD_ADDR_VAR 0 13
106613: PUSH
106614: LD_VAR 0 13
106618: PPUSH
106619: LD_VAR 0 13
106623: PUSH
106624: LD_INT 1
106626: PLUS
106627: PPUSH
106628: LD_VAR 0 11
106632: PUSH
106633: LD_VAR 0 12
106637: PUSH
106638: EMPTY
106639: LIST
106640: LIST
106641: PPUSH
106642: CALL_OW 2
106646: ST_TO_ADDR
// end ;
106647: GO 106555
106649: POP
106650: POP
106651: GO 106535
106653: POP
106654: POP
// if not list then
106655: LD_VAR 0 13
106659: NOT
106660: IFFALSE 106664
// exit ;
106662: GO 106908
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
106664: LD_ADDR_VAR 0 13
106668: PUSH
106669: LD_VAR 0 1
106673: PPUSH
106674: LD_VAR 0 13
106678: PPUSH
106679: LD_INT 1
106681: PPUSH
106682: LD_INT 1
106684: PPUSH
106685: CALL 21885 0 4
106689: ST_TO_ADDR
// ComStop ( flame ) ;
106690: LD_VAR 0 1
106694: PPUSH
106695: CALL_OW 141
// for i in list do
106699: LD_ADDR_VAR 0 6
106703: PUSH
106704: LD_VAR 0 13
106708: PUSH
106709: FOR_IN
106710: IFFALSE 106741
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
106712: LD_VAR 0 1
106716: PPUSH
106717: LD_VAR 0 6
106721: PUSH
106722: LD_INT 1
106724: ARRAY
106725: PPUSH
106726: LD_VAR 0 6
106730: PUSH
106731: LD_INT 2
106733: ARRAY
106734: PPUSH
106735: CALL_OW 176
106739: GO 106709
106741: POP
106742: POP
// repeat wait ( 0 0$1 ) ;
106743: LD_INT 35
106745: PPUSH
106746: CALL_OW 67
// task := GetTaskList ( flame ) ;
106750: LD_ADDR_VAR 0 14
106754: PUSH
106755: LD_VAR 0 1
106759: PPUSH
106760: CALL_OW 437
106764: ST_TO_ADDR
// if not task then
106765: LD_VAR 0 14
106769: NOT
106770: IFFALSE 106774
// exit ;
106772: GO 106908
// if task [ 1 ] [ 1 ] <> | then
106774: LD_VAR 0 14
106778: PUSH
106779: LD_INT 1
106781: ARRAY
106782: PUSH
106783: LD_INT 1
106785: ARRAY
106786: PUSH
106787: LD_STRING |
106789: NONEQUAL
106790: IFFALSE 106794
// exit ;
106792: GO 106908
// _x := task [ 1 ] [ 2 ] ;
106794: LD_ADDR_VAR 0 11
106798: PUSH
106799: LD_VAR 0 14
106803: PUSH
106804: LD_INT 1
106806: ARRAY
106807: PUSH
106808: LD_INT 2
106810: ARRAY
106811: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
106812: LD_ADDR_VAR 0 12
106816: PUSH
106817: LD_VAR 0 14
106821: PUSH
106822: LD_INT 1
106824: ARRAY
106825: PUSH
106826: LD_INT 3
106828: ARRAY
106829: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
106830: LD_VAR 0 11
106834: PPUSH
106835: LD_VAR 0 12
106839: PPUSH
106840: CALL_OW 351
106844: NOT
106845: PUSH
106846: LD_VAR 0 11
106850: PPUSH
106851: LD_VAR 0 12
106855: PPUSH
106856: CALL_OW 554
106860: NOT
106861: OR
106862: IFFALSE 106896
// begin task := Delete ( task , 1 ) ;
106864: LD_ADDR_VAR 0 14
106868: PUSH
106869: LD_VAR 0 14
106873: PPUSH
106874: LD_INT 1
106876: PPUSH
106877: CALL_OW 3
106881: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
106882: LD_VAR 0 1
106886: PPUSH
106887: LD_VAR 0 14
106891: PPUSH
106892: CALL_OW 446
// end ; until not HasTask ( flame ) ;
106896: LD_VAR 0 1
106900: PPUSH
106901: CALL_OW 314
106905: NOT
106906: IFFALSE 106743
// end ;
106908: LD_VAR 0 5
106912: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
106913: LD_EXP 168
106917: NOT
106918: IFFALSE 106968
106920: GO 106922
106922: DISABLE
// begin initHack := true ;
106923: LD_ADDR_EXP 168
106927: PUSH
106928: LD_INT 1
106930: ST_TO_ADDR
// hackTanks := [ ] ;
106931: LD_ADDR_EXP 169
106935: PUSH
106936: EMPTY
106937: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
106938: LD_ADDR_EXP 170
106942: PUSH
106943: EMPTY
106944: ST_TO_ADDR
// hackLimit := 3 ;
106945: LD_ADDR_EXP 171
106949: PUSH
106950: LD_INT 3
106952: ST_TO_ADDR
// hackDist := 12 ;
106953: LD_ADDR_EXP 172
106957: PUSH
106958: LD_INT 12
106960: ST_TO_ADDR
// hackCounter := [ ] ;
106961: LD_ADDR_EXP 173
106965: PUSH
106966: EMPTY
106967: ST_TO_ADDR
// end ;
106968: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
106969: LD_EXP 168
106973: PUSH
106974: LD_INT 34
106976: PUSH
106977: LD_INT 99
106979: PUSH
106980: EMPTY
106981: LIST
106982: LIST
106983: PPUSH
106984: CALL_OW 69
106988: AND
106989: IFFALSE 107242
106991: GO 106993
106993: DISABLE
106994: LD_INT 0
106996: PPUSH
106997: PPUSH
// begin enable ;
106998: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
106999: LD_ADDR_VAR 0 1
107003: PUSH
107004: LD_INT 34
107006: PUSH
107007: LD_INT 99
107009: PUSH
107010: EMPTY
107011: LIST
107012: LIST
107013: PPUSH
107014: CALL_OW 69
107018: PUSH
107019: FOR_IN
107020: IFFALSE 107240
// begin if not i in hackTanks then
107022: LD_VAR 0 1
107026: PUSH
107027: LD_EXP 169
107031: IN
107032: NOT
107033: IFFALSE 107116
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
107035: LD_ADDR_EXP 169
107039: PUSH
107040: LD_EXP 169
107044: PPUSH
107045: LD_EXP 169
107049: PUSH
107050: LD_INT 1
107052: PLUS
107053: PPUSH
107054: LD_VAR 0 1
107058: PPUSH
107059: CALL_OW 1
107063: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
107064: LD_ADDR_EXP 170
107068: PUSH
107069: LD_EXP 170
107073: PPUSH
107074: LD_EXP 170
107078: PUSH
107079: LD_INT 1
107081: PLUS
107082: PPUSH
107083: EMPTY
107084: PPUSH
107085: CALL_OW 1
107089: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
107090: LD_ADDR_EXP 173
107094: PUSH
107095: LD_EXP 173
107099: PPUSH
107100: LD_EXP 173
107104: PUSH
107105: LD_INT 1
107107: PLUS
107108: PPUSH
107109: EMPTY
107110: PPUSH
107111: CALL_OW 1
107115: ST_TO_ADDR
// end ; if not IsOk ( i ) then
107116: LD_VAR 0 1
107120: PPUSH
107121: CALL_OW 302
107125: NOT
107126: IFFALSE 107139
// begin HackUnlinkAll ( i ) ;
107128: LD_VAR 0 1
107132: PPUSH
107133: CALL 107245 0 1
// continue ;
107137: GO 107019
// end ; HackCheckCapturedStatus ( i ) ;
107139: LD_VAR 0 1
107143: PPUSH
107144: CALL 107688 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
107148: LD_ADDR_VAR 0 2
107152: PUSH
107153: LD_INT 81
107155: PUSH
107156: LD_VAR 0 1
107160: PPUSH
107161: CALL_OW 255
107165: PUSH
107166: EMPTY
107167: LIST
107168: LIST
107169: PUSH
107170: LD_INT 33
107172: PUSH
107173: LD_INT 3
107175: PUSH
107176: EMPTY
107177: LIST
107178: LIST
107179: PUSH
107180: LD_INT 91
107182: PUSH
107183: LD_VAR 0 1
107187: PUSH
107188: LD_EXP 172
107192: PUSH
107193: EMPTY
107194: LIST
107195: LIST
107196: LIST
107197: PUSH
107198: LD_INT 50
107200: PUSH
107201: EMPTY
107202: LIST
107203: PUSH
107204: EMPTY
107205: LIST
107206: LIST
107207: LIST
107208: LIST
107209: PPUSH
107210: CALL_OW 69
107214: ST_TO_ADDR
// if not tmp then
107215: LD_VAR 0 2
107219: NOT
107220: IFFALSE 107224
// continue ;
107222: GO 107019
// HackLink ( i , tmp ) ;
107224: LD_VAR 0 1
107228: PPUSH
107229: LD_VAR 0 2
107233: PPUSH
107234: CALL 107381 0 2
// end ;
107238: GO 107019
107240: POP
107241: POP
// end ;
107242: PPOPN 2
107244: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
107245: LD_INT 0
107247: PPUSH
107248: PPUSH
107249: PPUSH
// if not hack in hackTanks then
107250: LD_VAR 0 1
107254: PUSH
107255: LD_EXP 169
107259: IN
107260: NOT
107261: IFFALSE 107265
// exit ;
107263: GO 107376
// index := GetElementIndex ( hackTanks , hack ) ;
107265: LD_ADDR_VAR 0 4
107269: PUSH
107270: LD_EXP 169
107274: PPUSH
107275: LD_VAR 0 1
107279: PPUSH
107280: CALL 21182 0 2
107284: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
107285: LD_EXP 170
107289: PUSH
107290: LD_VAR 0 4
107294: ARRAY
107295: IFFALSE 107376
// begin for i in hackTanksCaptured [ index ] do
107297: LD_ADDR_VAR 0 3
107301: PUSH
107302: LD_EXP 170
107306: PUSH
107307: LD_VAR 0 4
107311: ARRAY
107312: PUSH
107313: FOR_IN
107314: IFFALSE 107340
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
107316: LD_VAR 0 3
107320: PUSH
107321: LD_INT 1
107323: ARRAY
107324: PPUSH
107325: LD_VAR 0 3
107329: PUSH
107330: LD_INT 2
107332: ARRAY
107333: PPUSH
107334: CALL_OW 235
107338: GO 107313
107340: POP
107341: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
107342: LD_ADDR_EXP 170
107346: PUSH
107347: LD_EXP 170
107351: PPUSH
107352: LD_VAR 0 4
107356: PPUSH
107357: EMPTY
107358: PPUSH
107359: CALL_OW 1
107363: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
107364: LD_VAR 0 1
107368: PPUSH
107369: LD_INT 0
107371: PPUSH
107372: CALL_OW 505
// end ; end ;
107376: LD_VAR 0 2
107380: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
107381: LD_INT 0
107383: PPUSH
107384: PPUSH
107385: PPUSH
// if not hack in hackTanks or not vehicles then
107386: LD_VAR 0 1
107390: PUSH
107391: LD_EXP 169
107395: IN
107396: NOT
107397: PUSH
107398: LD_VAR 0 2
107402: NOT
107403: OR
107404: IFFALSE 107408
// exit ;
107406: GO 107683
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
107408: LD_ADDR_VAR 0 2
107412: PUSH
107413: LD_VAR 0 1
107417: PPUSH
107418: LD_VAR 0 2
107422: PPUSH
107423: LD_INT 1
107425: PPUSH
107426: LD_INT 1
107428: PPUSH
107429: CALL 21832 0 4
107433: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
107434: LD_ADDR_VAR 0 5
107438: PUSH
107439: LD_EXP 169
107443: PPUSH
107444: LD_VAR 0 1
107448: PPUSH
107449: CALL 21182 0 2
107453: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
107454: LD_EXP 170
107458: PUSH
107459: LD_VAR 0 5
107463: ARRAY
107464: PUSH
107465: LD_EXP 171
107469: LESS
107470: IFFALSE 107659
// begin for i := 1 to vehicles do
107472: LD_ADDR_VAR 0 4
107476: PUSH
107477: DOUBLE
107478: LD_INT 1
107480: DEC
107481: ST_TO_ADDR
107482: LD_VAR 0 2
107486: PUSH
107487: FOR_TO
107488: IFFALSE 107657
// begin if hackTanksCaptured [ index ] = hackLimit then
107490: LD_EXP 170
107494: PUSH
107495: LD_VAR 0 5
107499: ARRAY
107500: PUSH
107501: LD_EXP 171
107505: EQUAL
107506: IFFALSE 107510
// break ;
107508: GO 107657
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
107510: LD_ADDR_EXP 173
107514: PUSH
107515: LD_EXP 173
107519: PPUSH
107520: LD_VAR 0 5
107524: PPUSH
107525: LD_EXP 173
107529: PUSH
107530: LD_VAR 0 5
107534: ARRAY
107535: PUSH
107536: LD_INT 1
107538: PLUS
107539: PPUSH
107540: CALL_OW 1
107544: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
107545: LD_ADDR_EXP 170
107549: PUSH
107550: LD_EXP 170
107554: PPUSH
107555: LD_VAR 0 5
107559: PUSH
107560: LD_EXP 170
107564: PUSH
107565: LD_VAR 0 5
107569: ARRAY
107570: PUSH
107571: LD_INT 1
107573: PLUS
107574: PUSH
107575: EMPTY
107576: LIST
107577: LIST
107578: PPUSH
107579: LD_VAR 0 2
107583: PUSH
107584: LD_VAR 0 4
107588: ARRAY
107589: PUSH
107590: LD_VAR 0 2
107594: PUSH
107595: LD_VAR 0 4
107599: ARRAY
107600: PPUSH
107601: CALL_OW 255
107605: PUSH
107606: EMPTY
107607: LIST
107608: LIST
107609: PPUSH
107610: CALL 21397 0 3
107614: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
107615: LD_VAR 0 2
107619: PUSH
107620: LD_VAR 0 4
107624: ARRAY
107625: PPUSH
107626: LD_VAR 0 1
107630: PPUSH
107631: CALL_OW 255
107635: PPUSH
107636: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
107640: LD_VAR 0 2
107644: PUSH
107645: LD_VAR 0 4
107649: ARRAY
107650: PPUSH
107651: CALL_OW 141
// end ;
107655: GO 107487
107657: POP
107658: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107659: LD_VAR 0 1
107663: PPUSH
107664: LD_EXP 170
107668: PUSH
107669: LD_VAR 0 5
107673: ARRAY
107674: PUSH
107675: LD_INT 0
107677: PLUS
107678: PPUSH
107679: CALL_OW 505
// end ;
107683: LD_VAR 0 3
107687: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
107688: LD_INT 0
107690: PPUSH
107691: PPUSH
107692: PPUSH
107693: PPUSH
// if not hack in hackTanks then
107694: LD_VAR 0 1
107698: PUSH
107699: LD_EXP 169
107703: IN
107704: NOT
107705: IFFALSE 107709
// exit ;
107707: GO 107949
// index := GetElementIndex ( hackTanks , hack ) ;
107709: LD_ADDR_VAR 0 4
107713: PUSH
107714: LD_EXP 169
107718: PPUSH
107719: LD_VAR 0 1
107723: PPUSH
107724: CALL 21182 0 2
107728: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
107729: LD_ADDR_VAR 0 3
107733: PUSH
107734: DOUBLE
107735: LD_EXP 170
107739: PUSH
107740: LD_VAR 0 4
107744: ARRAY
107745: INC
107746: ST_TO_ADDR
107747: LD_INT 1
107749: PUSH
107750: FOR_DOWNTO
107751: IFFALSE 107923
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
107753: LD_ADDR_VAR 0 5
107757: PUSH
107758: LD_EXP 170
107762: PUSH
107763: LD_VAR 0 4
107767: ARRAY
107768: PUSH
107769: LD_VAR 0 3
107773: ARRAY
107774: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
107775: LD_VAR 0 5
107779: PUSH
107780: LD_INT 1
107782: ARRAY
107783: PPUSH
107784: CALL_OW 302
107788: NOT
107789: PUSH
107790: LD_VAR 0 5
107794: PUSH
107795: LD_INT 1
107797: ARRAY
107798: PPUSH
107799: CALL_OW 255
107803: PUSH
107804: LD_VAR 0 1
107808: PPUSH
107809: CALL_OW 255
107813: NONEQUAL
107814: OR
107815: IFFALSE 107921
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
107817: LD_VAR 0 5
107821: PUSH
107822: LD_INT 1
107824: ARRAY
107825: PPUSH
107826: CALL_OW 305
107830: PUSH
107831: LD_VAR 0 5
107835: PUSH
107836: LD_INT 1
107838: ARRAY
107839: PPUSH
107840: CALL_OW 255
107844: PUSH
107845: LD_VAR 0 1
107849: PPUSH
107850: CALL_OW 255
107854: EQUAL
107855: AND
107856: IFFALSE 107880
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
107858: LD_VAR 0 5
107862: PUSH
107863: LD_INT 1
107865: ARRAY
107866: PPUSH
107867: LD_VAR 0 5
107871: PUSH
107872: LD_INT 2
107874: ARRAY
107875: PPUSH
107876: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
107880: LD_ADDR_EXP 170
107884: PUSH
107885: LD_EXP 170
107889: PPUSH
107890: LD_VAR 0 4
107894: PPUSH
107895: LD_EXP 170
107899: PUSH
107900: LD_VAR 0 4
107904: ARRAY
107905: PPUSH
107906: LD_VAR 0 3
107910: PPUSH
107911: CALL_OW 3
107915: PPUSH
107916: CALL_OW 1
107920: ST_TO_ADDR
// end ; end ;
107921: GO 107750
107923: POP
107924: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107925: LD_VAR 0 1
107929: PPUSH
107930: LD_EXP 170
107934: PUSH
107935: LD_VAR 0 4
107939: ARRAY
107940: PUSH
107941: LD_INT 0
107943: PLUS
107944: PPUSH
107945: CALL_OW 505
// end ;
107949: LD_VAR 0 2
107953: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
107954: LD_INT 0
107956: PPUSH
107957: PPUSH
107958: PPUSH
107959: PPUSH
// if not hack in hackTanks then
107960: LD_VAR 0 1
107964: PUSH
107965: LD_EXP 169
107969: IN
107970: NOT
107971: IFFALSE 107975
// exit ;
107973: GO 108060
// index := GetElementIndex ( hackTanks , hack ) ;
107975: LD_ADDR_VAR 0 5
107979: PUSH
107980: LD_EXP 169
107984: PPUSH
107985: LD_VAR 0 1
107989: PPUSH
107990: CALL 21182 0 2
107994: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
107995: LD_ADDR_VAR 0 4
107999: PUSH
108000: DOUBLE
108001: LD_INT 1
108003: DEC
108004: ST_TO_ADDR
108005: LD_EXP 170
108009: PUSH
108010: LD_VAR 0 5
108014: ARRAY
108015: PUSH
108016: FOR_TO
108017: IFFALSE 108058
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
108019: LD_EXP 170
108023: PUSH
108024: LD_VAR 0 5
108028: ARRAY
108029: PUSH
108030: LD_VAR 0 4
108034: ARRAY
108035: PUSH
108036: LD_INT 1
108038: ARRAY
108039: PUSH
108040: LD_VAR 0 2
108044: EQUAL
108045: IFFALSE 108056
// KillUnit ( vehicle ) ;
108047: LD_VAR 0 2
108051: PPUSH
108052: CALL_OW 66
108056: GO 108016
108058: POP
108059: POP
// end ;
108060: LD_VAR 0 3
108064: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
108065: LD_EXP 174
108069: NOT
108070: IFFALSE 108105
108072: GO 108074
108074: DISABLE
// begin initMiner := true ;
108075: LD_ADDR_EXP 174
108079: PUSH
108080: LD_INT 1
108082: ST_TO_ADDR
// minersList := [ ] ;
108083: LD_ADDR_EXP 175
108087: PUSH
108088: EMPTY
108089: ST_TO_ADDR
// minerMinesList := [ ] ;
108090: LD_ADDR_EXP 176
108094: PUSH
108095: EMPTY
108096: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
108097: LD_ADDR_EXP 177
108101: PUSH
108102: LD_INT 5
108104: ST_TO_ADDR
// end ;
108105: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
108106: LD_EXP 174
108110: PUSH
108111: LD_INT 34
108113: PUSH
108114: LD_INT 81
108116: PUSH
108117: EMPTY
108118: LIST
108119: LIST
108120: PPUSH
108121: CALL_OW 69
108125: AND
108126: IFFALSE 108587
108128: GO 108130
108130: DISABLE
108131: LD_INT 0
108133: PPUSH
108134: PPUSH
108135: PPUSH
108136: PPUSH
// begin enable ;
108137: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
108138: LD_ADDR_VAR 0 1
108142: PUSH
108143: LD_INT 34
108145: PUSH
108146: LD_INT 81
108148: PUSH
108149: EMPTY
108150: LIST
108151: LIST
108152: PPUSH
108153: CALL_OW 69
108157: PUSH
108158: FOR_IN
108159: IFFALSE 108231
// begin if not i in minersList then
108161: LD_VAR 0 1
108165: PUSH
108166: LD_EXP 175
108170: IN
108171: NOT
108172: IFFALSE 108229
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
108174: LD_ADDR_EXP 175
108178: PUSH
108179: LD_EXP 175
108183: PPUSH
108184: LD_EXP 175
108188: PUSH
108189: LD_INT 1
108191: PLUS
108192: PPUSH
108193: LD_VAR 0 1
108197: PPUSH
108198: CALL_OW 1
108202: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
108203: LD_ADDR_EXP 176
108207: PUSH
108208: LD_EXP 176
108212: PPUSH
108213: LD_EXP 176
108217: PUSH
108218: LD_INT 1
108220: PLUS
108221: PPUSH
108222: EMPTY
108223: PPUSH
108224: CALL_OW 1
108228: ST_TO_ADDR
// end end ;
108229: GO 108158
108231: POP
108232: POP
// for i := minerMinesList downto 1 do
108233: LD_ADDR_VAR 0 1
108237: PUSH
108238: DOUBLE
108239: LD_EXP 176
108243: INC
108244: ST_TO_ADDR
108245: LD_INT 1
108247: PUSH
108248: FOR_DOWNTO
108249: IFFALSE 108585
// begin if IsLive ( minersList [ i ] ) then
108251: LD_EXP 175
108255: PUSH
108256: LD_VAR 0 1
108260: ARRAY
108261: PPUSH
108262: CALL_OW 300
108266: IFFALSE 108294
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
108268: LD_EXP 175
108272: PUSH
108273: LD_VAR 0 1
108277: ARRAY
108278: PPUSH
108279: LD_EXP 176
108283: PUSH
108284: LD_VAR 0 1
108288: ARRAY
108289: PPUSH
108290: CALL_OW 505
// if not minerMinesList [ i ] then
108294: LD_EXP 176
108298: PUSH
108299: LD_VAR 0 1
108303: ARRAY
108304: NOT
108305: IFFALSE 108309
// continue ;
108307: GO 108248
// for j := minerMinesList [ i ] downto 1 do
108309: LD_ADDR_VAR 0 2
108313: PUSH
108314: DOUBLE
108315: LD_EXP 176
108319: PUSH
108320: LD_VAR 0 1
108324: ARRAY
108325: INC
108326: ST_TO_ADDR
108327: LD_INT 1
108329: PUSH
108330: FOR_DOWNTO
108331: IFFALSE 108581
// begin side := GetSide ( minersList [ i ] ) ;
108333: LD_ADDR_VAR 0 3
108337: PUSH
108338: LD_EXP 175
108342: PUSH
108343: LD_VAR 0 1
108347: ARRAY
108348: PPUSH
108349: CALL_OW 255
108353: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
108354: LD_ADDR_VAR 0 4
108358: PUSH
108359: LD_EXP 176
108363: PUSH
108364: LD_VAR 0 1
108368: ARRAY
108369: PUSH
108370: LD_VAR 0 2
108374: ARRAY
108375: PUSH
108376: LD_INT 1
108378: ARRAY
108379: PPUSH
108380: LD_EXP 176
108384: PUSH
108385: LD_VAR 0 1
108389: ARRAY
108390: PUSH
108391: LD_VAR 0 2
108395: ARRAY
108396: PUSH
108397: LD_INT 2
108399: ARRAY
108400: PPUSH
108401: CALL_OW 428
108405: ST_TO_ADDR
// if not tmp then
108406: LD_VAR 0 4
108410: NOT
108411: IFFALSE 108415
// continue ;
108413: GO 108330
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
108415: LD_VAR 0 4
108419: PUSH
108420: LD_INT 81
108422: PUSH
108423: LD_VAR 0 3
108427: PUSH
108428: EMPTY
108429: LIST
108430: LIST
108431: PPUSH
108432: CALL_OW 69
108436: IN
108437: PUSH
108438: LD_EXP 176
108442: PUSH
108443: LD_VAR 0 1
108447: ARRAY
108448: PUSH
108449: LD_VAR 0 2
108453: ARRAY
108454: PUSH
108455: LD_INT 1
108457: ARRAY
108458: PPUSH
108459: LD_EXP 176
108463: PUSH
108464: LD_VAR 0 1
108468: ARRAY
108469: PUSH
108470: LD_VAR 0 2
108474: ARRAY
108475: PUSH
108476: LD_INT 2
108478: ARRAY
108479: PPUSH
108480: CALL_OW 458
108484: AND
108485: IFFALSE 108579
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
108487: LD_EXP 176
108491: PUSH
108492: LD_VAR 0 1
108496: ARRAY
108497: PUSH
108498: LD_VAR 0 2
108502: ARRAY
108503: PUSH
108504: LD_INT 1
108506: ARRAY
108507: PPUSH
108508: LD_EXP 176
108512: PUSH
108513: LD_VAR 0 1
108517: ARRAY
108518: PUSH
108519: LD_VAR 0 2
108523: ARRAY
108524: PUSH
108525: LD_INT 2
108527: ARRAY
108528: PPUSH
108529: LD_VAR 0 3
108533: PPUSH
108534: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
108538: LD_ADDR_EXP 176
108542: PUSH
108543: LD_EXP 176
108547: PPUSH
108548: LD_VAR 0 1
108552: PPUSH
108553: LD_EXP 176
108557: PUSH
108558: LD_VAR 0 1
108562: ARRAY
108563: PPUSH
108564: LD_VAR 0 2
108568: PPUSH
108569: CALL_OW 3
108573: PPUSH
108574: CALL_OW 1
108578: ST_TO_ADDR
// end ; end ;
108579: GO 108330
108581: POP
108582: POP
// end ;
108583: GO 108248
108585: POP
108586: POP
// end ;
108587: PPOPN 4
108589: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
108590: LD_INT 0
108592: PPUSH
108593: PPUSH
// result := false ;
108594: LD_ADDR_VAR 0 4
108598: PUSH
108599: LD_INT 0
108601: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
108602: LD_VAR 0 1
108606: PPUSH
108607: CALL_OW 264
108611: PUSH
108612: LD_INT 81
108614: EQUAL
108615: NOT
108616: IFFALSE 108620
// exit ;
108618: GO 108860
// index := GetElementIndex ( minersList , unit ) ;
108620: LD_ADDR_VAR 0 5
108624: PUSH
108625: LD_EXP 175
108629: PPUSH
108630: LD_VAR 0 1
108634: PPUSH
108635: CALL 21182 0 2
108639: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
108640: LD_EXP 176
108644: PUSH
108645: LD_VAR 0 5
108649: ARRAY
108650: PUSH
108651: LD_EXP 177
108655: GREATEREQUAL
108656: IFFALSE 108660
// exit ;
108658: GO 108860
// ComMoveXY ( unit , x , y ) ;
108660: LD_VAR 0 1
108664: PPUSH
108665: LD_VAR 0 2
108669: PPUSH
108670: LD_VAR 0 3
108674: PPUSH
108675: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
108679: LD_INT 35
108681: PPUSH
108682: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
108686: LD_VAR 0 1
108690: PPUSH
108691: LD_VAR 0 2
108695: PPUSH
108696: LD_VAR 0 3
108700: PPUSH
108701: CALL 52934 0 3
108705: NOT
108706: PUSH
108707: LD_VAR 0 1
108711: PPUSH
108712: CALL_OW 314
108716: AND
108717: IFFALSE 108721
// exit ;
108719: GO 108860
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
108721: LD_VAR 0 2
108725: PPUSH
108726: LD_VAR 0 3
108730: PPUSH
108731: CALL_OW 428
108735: PUSH
108736: LD_VAR 0 1
108740: EQUAL
108741: PUSH
108742: LD_VAR 0 1
108746: PPUSH
108747: CALL_OW 314
108751: NOT
108752: AND
108753: IFFALSE 108679
// PlaySoundXY ( x , y , PlantMine ) ;
108755: LD_VAR 0 2
108759: PPUSH
108760: LD_VAR 0 3
108764: PPUSH
108765: LD_STRING PlantMine
108767: PPUSH
108768: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
108772: LD_VAR 0 2
108776: PPUSH
108777: LD_VAR 0 3
108781: PPUSH
108782: LD_VAR 0 1
108786: PPUSH
108787: CALL_OW 255
108791: PPUSH
108792: LD_INT 0
108794: PPUSH
108795: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
108799: LD_ADDR_EXP 176
108803: PUSH
108804: LD_EXP 176
108808: PPUSH
108809: LD_VAR 0 5
108813: PUSH
108814: LD_EXP 176
108818: PUSH
108819: LD_VAR 0 5
108823: ARRAY
108824: PUSH
108825: LD_INT 1
108827: PLUS
108828: PUSH
108829: EMPTY
108830: LIST
108831: LIST
108832: PPUSH
108833: LD_VAR 0 2
108837: PUSH
108838: LD_VAR 0 3
108842: PUSH
108843: EMPTY
108844: LIST
108845: LIST
108846: PPUSH
108847: CALL 21397 0 3
108851: ST_TO_ADDR
// result := true ;
108852: LD_ADDR_VAR 0 4
108856: PUSH
108857: LD_INT 1
108859: ST_TO_ADDR
// end ;
108860: LD_VAR 0 4
108864: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
108865: LD_INT 0
108867: PPUSH
108868: PPUSH
108869: PPUSH
// if not unit in minersList then
108870: LD_VAR 0 1
108874: PUSH
108875: LD_EXP 175
108879: IN
108880: NOT
108881: IFFALSE 108885
// exit ;
108883: GO 109277
// index := GetElementIndex ( minersList , unit ) ;
108885: LD_ADDR_VAR 0 6
108889: PUSH
108890: LD_EXP 175
108894: PPUSH
108895: LD_VAR 0 1
108899: PPUSH
108900: CALL 21182 0 2
108904: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
108905: LD_ADDR_VAR 0 5
108909: PUSH
108910: DOUBLE
108911: LD_EXP 176
108915: PUSH
108916: LD_VAR 0 6
108920: ARRAY
108921: INC
108922: ST_TO_ADDR
108923: LD_INT 1
108925: PUSH
108926: FOR_DOWNTO
108927: IFFALSE 109088
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
108929: LD_EXP 176
108933: PUSH
108934: LD_VAR 0 6
108938: ARRAY
108939: PUSH
108940: LD_VAR 0 5
108944: ARRAY
108945: PUSH
108946: LD_INT 1
108948: ARRAY
108949: PUSH
108950: LD_VAR 0 2
108954: EQUAL
108955: PUSH
108956: LD_EXP 176
108960: PUSH
108961: LD_VAR 0 6
108965: ARRAY
108966: PUSH
108967: LD_VAR 0 5
108971: ARRAY
108972: PUSH
108973: LD_INT 2
108975: ARRAY
108976: PUSH
108977: LD_VAR 0 3
108981: EQUAL
108982: AND
108983: IFFALSE 109086
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
108985: LD_EXP 176
108989: PUSH
108990: LD_VAR 0 6
108994: ARRAY
108995: PUSH
108996: LD_VAR 0 5
109000: ARRAY
109001: PUSH
109002: LD_INT 1
109004: ARRAY
109005: PPUSH
109006: LD_EXP 176
109010: PUSH
109011: LD_VAR 0 6
109015: ARRAY
109016: PUSH
109017: LD_VAR 0 5
109021: ARRAY
109022: PUSH
109023: LD_INT 2
109025: ARRAY
109026: PPUSH
109027: LD_VAR 0 1
109031: PPUSH
109032: CALL_OW 255
109036: PPUSH
109037: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109041: LD_ADDR_EXP 176
109045: PUSH
109046: LD_EXP 176
109050: PPUSH
109051: LD_VAR 0 6
109055: PPUSH
109056: LD_EXP 176
109060: PUSH
109061: LD_VAR 0 6
109065: ARRAY
109066: PPUSH
109067: LD_VAR 0 5
109071: PPUSH
109072: CALL_OW 3
109076: PPUSH
109077: CALL_OW 1
109081: ST_TO_ADDR
// exit ;
109082: POP
109083: POP
109084: GO 109277
// end ; end ;
109086: GO 108926
109088: POP
109089: POP
// for i := minerMinesList [ index ] downto 1 do
109090: LD_ADDR_VAR 0 5
109094: PUSH
109095: DOUBLE
109096: LD_EXP 176
109100: PUSH
109101: LD_VAR 0 6
109105: ARRAY
109106: INC
109107: ST_TO_ADDR
109108: LD_INT 1
109110: PUSH
109111: FOR_DOWNTO
109112: IFFALSE 109275
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
109114: LD_EXP 176
109118: PUSH
109119: LD_VAR 0 6
109123: ARRAY
109124: PUSH
109125: LD_VAR 0 5
109129: ARRAY
109130: PUSH
109131: LD_INT 1
109133: ARRAY
109134: PPUSH
109135: LD_EXP 176
109139: PUSH
109140: LD_VAR 0 6
109144: ARRAY
109145: PUSH
109146: LD_VAR 0 5
109150: ARRAY
109151: PUSH
109152: LD_INT 2
109154: ARRAY
109155: PPUSH
109156: LD_VAR 0 2
109160: PPUSH
109161: LD_VAR 0 3
109165: PPUSH
109166: CALL_OW 298
109170: PUSH
109171: LD_INT 6
109173: LESS
109174: IFFALSE 109273
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109176: LD_EXP 176
109180: PUSH
109181: LD_VAR 0 6
109185: ARRAY
109186: PUSH
109187: LD_VAR 0 5
109191: ARRAY
109192: PUSH
109193: LD_INT 1
109195: ARRAY
109196: PPUSH
109197: LD_EXP 176
109201: PUSH
109202: LD_VAR 0 6
109206: ARRAY
109207: PUSH
109208: LD_VAR 0 5
109212: ARRAY
109213: PUSH
109214: LD_INT 2
109216: ARRAY
109217: PPUSH
109218: LD_VAR 0 1
109222: PPUSH
109223: CALL_OW 255
109227: PPUSH
109228: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109232: LD_ADDR_EXP 176
109236: PUSH
109237: LD_EXP 176
109241: PPUSH
109242: LD_VAR 0 6
109246: PPUSH
109247: LD_EXP 176
109251: PUSH
109252: LD_VAR 0 6
109256: ARRAY
109257: PPUSH
109258: LD_VAR 0 5
109262: PPUSH
109263: CALL_OW 3
109267: PPUSH
109268: CALL_OW 1
109272: ST_TO_ADDR
// end ; end ;
109273: GO 109111
109275: POP
109276: POP
// end ;
109277: LD_VAR 0 4
109281: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
109282: LD_INT 0
109284: PPUSH
109285: PPUSH
109286: PPUSH
109287: PPUSH
109288: PPUSH
109289: PPUSH
109290: PPUSH
109291: PPUSH
109292: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
109293: LD_VAR 0 1
109297: PPUSH
109298: CALL_OW 264
109302: PUSH
109303: LD_INT 81
109305: EQUAL
109306: NOT
109307: PUSH
109308: LD_VAR 0 1
109312: PUSH
109313: LD_EXP 175
109317: IN
109318: NOT
109319: OR
109320: IFFALSE 109324
// exit ;
109322: GO 109646
// index := GetElementIndex ( minersList , unit ) ;
109324: LD_ADDR_VAR 0 6
109328: PUSH
109329: LD_EXP 175
109333: PPUSH
109334: LD_VAR 0 1
109338: PPUSH
109339: CALL 21182 0 2
109343: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
109344: LD_ADDR_VAR 0 8
109348: PUSH
109349: LD_EXP 177
109353: PUSH
109354: LD_EXP 176
109358: PUSH
109359: LD_VAR 0 6
109363: ARRAY
109364: MINUS
109365: ST_TO_ADDR
// if not minesFreeAmount then
109366: LD_VAR 0 8
109370: NOT
109371: IFFALSE 109375
// exit ;
109373: GO 109646
// tmp := [ ] ;
109375: LD_ADDR_VAR 0 7
109379: PUSH
109380: EMPTY
109381: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
109382: LD_ADDR_VAR 0 5
109386: PUSH
109387: DOUBLE
109388: LD_INT 1
109390: DEC
109391: ST_TO_ADDR
109392: LD_VAR 0 8
109396: PUSH
109397: FOR_TO
109398: IFFALSE 109593
// begin _d := rand ( 0 , 5 ) ;
109400: LD_ADDR_VAR 0 11
109404: PUSH
109405: LD_INT 0
109407: PPUSH
109408: LD_INT 5
109410: PPUSH
109411: CALL_OW 12
109415: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
109416: LD_ADDR_VAR 0 12
109420: PUSH
109421: LD_INT 2
109423: PPUSH
109424: LD_INT 6
109426: PPUSH
109427: CALL_OW 12
109431: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
109432: LD_ADDR_VAR 0 9
109436: PUSH
109437: LD_VAR 0 2
109441: PPUSH
109442: LD_VAR 0 11
109446: PPUSH
109447: LD_VAR 0 12
109451: PPUSH
109452: CALL_OW 272
109456: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
109457: LD_ADDR_VAR 0 10
109461: PUSH
109462: LD_VAR 0 3
109466: PPUSH
109467: LD_VAR 0 11
109471: PPUSH
109472: LD_VAR 0 12
109476: PPUSH
109477: CALL_OW 273
109481: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
109482: LD_VAR 0 9
109486: PPUSH
109487: LD_VAR 0 10
109491: PPUSH
109492: CALL_OW 488
109496: PUSH
109497: LD_VAR 0 9
109501: PUSH
109502: LD_VAR 0 10
109506: PUSH
109507: EMPTY
109508: LIST
109509: LIST
109510: PUSH
109511: LD_VAR 0 7
109515: IN
109516: NOT
109517: AND
109518: PUSH
109519: LD_VAR 0 9
109523: PPUSH
109524: LD_VAR 0 10
109528: PPUSH
109529: CALL_OW 458
109533: NOT
109534: AND
109535: IFFALSE 109577
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
109537: LD_ADDR_VAR 0 7
109541: PUSH
109542: LD_VAR 0 7
109546: PPUSH
109547: LD_VAR 0 7
109551: PUSH
109552: LD_INT 1
109554: PLUS
109555: PPUSH
109556: LD_VAR 0 9
109560: PUSH
109561: LD_VAR 0 10
109565: PUSH
109566: EMPTY
109567: LIST
109568: LIST
109569: PPUSH
109570: CALL_OW 1
109574: ST_TO_ADDR
109575: GO 109591
// i := i - 1 ;
109577: LD_ADDR_VAR 0 5
109581: PUSH
109582: LD_VAR 0 5
109586: PUSH
109587: LD_INT 1
109589: MINUS
109590: ST_TO_ADDR
// end ;
109591: GO 109397
109593: POP
109594: POP
// for i in tmp do
109595: LD_ADDR_VAR 0 5
109599: PUSH
109600: LD_VAR 0 7
109604: PUSH
109605: FOR_IN
109606: IFFALSE 109644
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
109608: LD_VAR 0 1
109612: PPUSH
109613: LD_VAR 0 5
109617: PUSH
109618: LD_INT 1
109620: ARRAY
109621: PPUSH
109622: LD_VAR 0 5
109626: PUSH
109627: LD_INT 2
109629: ARRAY
109630: PPUSH
109631: CALL 108590 0 3
109635: NOT
109636: IFFALSE 109642
// exit ;
109638: POP
109639: POP
109640: GO 109646
109642: GO 109605
109644: POP
109645: POP
// end ;
109646: LD_VAR 0 4
109650: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
109651: LD_INT 0
109653: PPUSH
109654: PPUSH
109655: PPUSH
109656: PPUSH
109657: PPUSH
109658: PPUSH
109659: PPUSH
// if not GetClass ( unit ) = class_sniper then
109660: LD_VAR 0 1
109664: PPUSH
109665: CALL_OW 257
109669: PUSH
109670: LD_INT 5
109672: EQUAL
109673: NOT
109674: IFFALSE 109678
// exit ;
109676: GO 110066
// dist := 8 ;
109678: LD_ADDR_VAR 0 5
109682: PUSH
109683: LD_INT 8
109685: ST_TO_ADDR
// viewRange := 12 ;
109686: LD_ADDR_VAR 0 7
109690: PUSH
109691: LD_INT 12
109693: ST_TO_ADDR
// side := GetSide ( unit ) ;
109694: LD_ADDR_VAR 0 6
109698: PUSH
109699: LD_VAR 0 1
109703: PPUSH
109704: CALL_OW 255
109708: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
109709: LD_INT 61
109711: PPUSH
109712: LD_VAR 0 6
109716: PPUSH
109717: CALL_OW 321
109721: PUSH
109722: LD_INT 2
109724: EQUAL
109725: IFFALSE 109735
// viewRange := 16 ;
109727: LD_ADDR_VAR 0 7
109731: PUSH
109732: LD_INT 16
109734: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
109735: LD_VAR 0 1
109739: PPUSH
109740: LD_VAR 0 2
109744: PPUSH
109745: LD_VAR 0 3
109749: PPUSH
109750: CALL_OW 297
109754: PUSH
109755: LD_VAR 0 5
109759: GREATER
109760: IFFALSE 109839
// begin ComMoveXY ( unit , x , y ) ;
109762: LD_VAR 0 1
109766: PPUSH
109767: LD_VAR 0 2
109771: PPUSH
109772: LD_VAR 0 3
109776: PPUSH
109777: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109781: LD_INT 35
109783: PPUSH
109784: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
109788: LD_VAR 0 1
109792: PPUSH
109793: LD_VAR 0 2
109797: PPUSH
109798: LD_VAR 0 3
109802: PPUSH
109803: CALL 52934 0 3
109807: NOT
109808: IFFALSE 109812
// exit ;
109810: GO 110066
// until GetDistUnitXY ( unit , x , y ) < dist ;
109812: LD_VAR 0 1
109816: PPUSH
109817: LD_VAR 0 2
109821: PPUSH
109822: LD_VAR 0 3
109826: PPUSH
109827: CALL_OW 297
109831: PUSH
109832: LD_VAR 0 5
109836: LESS
109837: IFFALSE 109781
// end ; ComTurnXY ( unit , x , y ) ;
109839: LD_VAR 0 1
109843: PPUSH
109844: LD_VAR 0 2
109848: PPUSH
109849: LD_VAR 0 3
109853: PPUSH
109854: CALL_OW 118
// wait ( 5 ) ;
109858: LD_INT 5
109860: PPUSH
109861: CALL_OW 67
// _d := GetDir ( unit ) ;
109865: LD_ADDR_VAR 0 10
109869: PUSH
109870: LD_VAR 0 1
109874: PPUSH
109875: CALL_OW 254
109879: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
109880: LD_ADDR_VAR 0 8
109884: PUSH
109885: LD_VAR 0 1
109889: PPUSH
109890: CALL_OW 250
109894: PPUSH
109895: LD_VAR 0 10
109899: PPUSH
109900: LD_VAR 0 5
109904: PPUSH
109905: CALL_OW 272
109909: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
109910: LD_ADDR_VAR 0 9
109914: PUSH
109915: LD_VAR 0 1
109919: PPUSH
109920: CALL_OW 251
109924: PPUSH
109925: LD_VAR 0 10
109929: PPUSH
109930: LD_VAR 0 5
109934: PPUSH
109935: CALL_OW 273
109939: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
109940: LD_VAR 0 8
109944: PPUSH
109945: LD_VAR 0 9
109949: PPUSH
109950: CALL_OW 488
109954: NOT
109955: IFFALSE 109959
// exit ;
109957: GO 110066
// ComAnimCustom ( unit , 1 ) ;
109959: LD_VAR 0 1
109963: PPUSH
109964: LD_INT 1
109966: PPUSH
109967: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
109971: LD_VAR 0 8
109975: PPUSH
109976: LD_VAR 0 9
109980: PPUSH
109981: LD_VAR 0 6
109985: PPUSH
109986: LD_VAR 0 7
109990: PPUSH
109991: CALL_OW 330
// repeat wait ( 1 ) ;
109995: LD_INT 1
109997: PPUSH
109998: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
110002: LD_VAR 0 1
110006: PPUSH
110007: CALL_OW 316
110011: PUSH
110012: LD_VAR 0 1
110016: PPUSH
110017: CALL_OW 314
110021: OR
110022: PUSH
110023: LD_VAR 0 1
110027: PPUSH
110028: CALL_OW 302
110032: NOT
110033: OR
110034: PUSH
110035: LD_VAR 0 1
110039: PPUSH
110040: CALL_OW 301
110044: OR
110045: IFFALSE 109995
// RemoveSeeing ( _x , _y , side ) ;
110047: LD_VAR 0 8
110051: PPUSH
110052: LD_VAR 0 9
110056: PPUSH
110057: LD_VAR 0 6
110061: PPUSH
110062: CALL_OW 331
// end ; end_of_file
110066: LD_VAR 0 4
110070: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
110071: LD_INT 0
110073: PPUSH
110074: PPUSH
110075: PPUSH
110076: PPUSH
110077: PPUSH
110078: PPUSH
110079: PPUSH
110080: PPUSH
110081: PPUSH
110082: PPUSH
110083: PPUSH
110084: PPUSH
110085: PPUSH
110086: PPUSH
110087: PPUSH
110088: PPUSH
110089: PPUSH
110090: PPUSH
110091: PPUSH
110092: PPUSH
110093: PPUSH
110094: PPUSH
110095: PPUSH
110096: PPUSH
110097: PPUSH
110098: PPUSH
110099: PPUSH
110100: PPUSH
110101: PPUSH
110102: PPUSH
110103: PPUSH
110104: PPUSH
110105: PPUSH
110106: PPUSH
// if not list then
110107: LD_VAR 0 1
110111: NOT
110112: IFFALSE 110116
// exit ;
110114: GO 114775
// base := list [ 1 ] ;
110116: LD_ADDR_VAR 0 3
110120: PUSH
110121: LD_VAR 0 1
110125: PUSH
110126: LD_INT 1
110128: ARRAY
110129: ST_TO_ADDR
// group := list [ 2 ] ;
110130: LD_ADDR_VAR 0 4
110134: PUSH
110135: LD_VAR 0 1
110139: PUSH
110140: LD_INT 2
110142: ARRAY
110143: ST_TO_ADDR
// path := list [ 3 ] ;
110144: LD_ADDR_VAR 0 5
110148: PUSH
110149: LD_VAR 0 1
110153: PUSH
110154: LD_INT 3
110156: ARRAY
110157: ST_TO_ADDR
// flags := list [ 4 ] ;
110158: LD_ADDR_VAR 0 6
110162: PUSH
110163: LD_VAR 0 1
110167: PUSH
110168: LD_INT 4
110170: ARRAY
110171: ST_TO_ADDR
// mined := [ ] ;
110172: LD_ADDR_VAR 0 27
110176: PUSH
110177: EMPTY
110178: ST_TO_ADDR
// bombed := [ ] ;
110179: LD_ADDR_VAR 0 28
110183: PUSH
110184: EMPTY
110185: ST_TO_ADDR
// healers := [ ] ;
110186: LD_ADDR_VAR 0 31
110190: PUSH
110191: EMPTY
110192: ST_TO_ADDR
// to_heal := [ ] ;
110193: LD_ADDR_VAR 0 30
110197: PUSH
110198: EMPTY
110199: ST_TO_ADDR
// repairs := [ ] ;
110200: LD_ADDR_VAR 0 33
110204: PUSH
110205: EMPTY
110206: ST_TO_ADDR
// to_repair := [ ] ;
110207: LD_ADDR_VAR 0 32
110211: PUSH
110212: EMPTY
110213: ST_TO_ADDR
// if not group or not path then
110214: LD_VAR 0 4
110218: NOT
110219: PUSH
110220: LD_VAR 0 5
110224: NOT
110225: OR
110226: IFFALSE 110230
// exit ;
110228: GO 114775
// side := GetSide ( group [ 1 ] ) ;
110230: LD_ADDR_VAR 0 35
110234: PUSH
110235: LD_VAR 0 4
110239: PUSH
110240: LD_INT 1
110242: ARRAY
110243: PPUSH
110244: CALL_OW 255
110248: ST_TO_ADDR
// if flags then
110249: LD_VAR 0 6
110253: IFFALSE 110397
// begin f_ignore_area := flags [ 1 ] ;
110255: LD_ADDR_VAR 0 17
110259: PUSH
110260: LD_VAR 0 6
110264: PUSH
110265: LD_INT 1
110267: ARRAY
110268: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
110269: LD_ADDR_VAR 0 18
110273: PUSH
110274: LD_VAR 0 6
110278: PUSH
110279: LD_INT 2
110281: ARRAY
110282: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
110283: LD_ADDR_VAR 0 19
110287: PUSH
110288: LD_VAR 0 6
110292: PUSH
110293: LD_INT 3
110295: ARRAY
110296: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
110297: LD_ADDR_VAR 0 20
110301: PUSH
110302: LD_VAR 0 6
110306: PUSH
110307: LD_INT 4
110309: ARRAY
110310: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
110311: LD_ADDR_VAR 0 21
110315: PUSH
110316: LD_VAR 0 6
110320: PUSH
110321: LD_INT 5
110323: ARRAY
110324: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
110325: LD_ADDR_VAR 0 22
110329: PUSH
110330: LD_VAR 0 6
110334: PUSH
110335: LD_INT 6
110337: ARRAY
110338: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
110339: LD_ADDR_VAR 0 23
110343: PUSH
110344: LD_VAR 0 6
110348: PUSH
110349: LD_INT 7
110351: ARRAY
110352: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
110353: LD_ADDR_VAR 0 24
110357: PUSH
110358: LD_VAR 0 6
110362: PUSH
110363: LD_INT 8
110365: ARRAY
110366: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
110367: LD_ADDR_VAR 0 25
110371: PUSH
110372: LD_VAR 0 6
110376: PUSH
110377: LD_INT 9
110379: ARRAY
110380: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
110381: LD_ADDR_VAR 0 26
110385: PUSH
110386: LD_VAR 0 6
110390: PUSH
110391: LD_INT 10
110393: ARRAY
110394: ST_TO_ADDR
// end else
110395: GO 110477
// begin f_ignore_area := false ;
110397: LD_ADDR_VAR 0 17
110401: PUSH
110402: LD_INT 0
110404: ST_TO_ADDR
// f_capture := false ;
110405: LD_ADDR_VAR 0 18
110409: PUSH
110410: LD_INT 0
110412: ST_TO_ADDR
// f_ignore_civ := false ;
110413: LD_ADDR_VAR 0 19
110417: PUSH
110418: LD_INT 0
110420: ST_TO_ADDR
// f_murder := false ;
110421: LD_ADDR_VAR 0 20
110425: PUSH
110426: LD_INT 0
110428: ST_TO_ADDR
// f_mines := false ;
110429: LD_ADDR_VAR 0 21
110433: PUSH
110434: LD_INT 0
110436: ST_TO_ADDR
// f_repair := false ;
110437: LD_ADDR_VAR 0 22
110441: PUSH
110442: LD_INT 0
110444: ST_TO_ADDR
// f_heal := false ;
110445: LD_ADDR_VAR 0 23
110449: PUSH
110450: LD_INT 0
110452: ST_TO_ADDR
// f_spacetime := false ;
110453: LD_ADDR_VAR 0 24
110457: PUSH
110458: LD_INT 0
110460: ST_TO_ADDR
// f_attack_depot := false ;
110461: LD_ADDR_VAR 0 25
110465: PUSH
110466: LD_INT 0
110468: ST_TO_ADDR
// f_crawl := false ;
110469: LD_ADDR_VAR 0 26
110473: PUSH
110474: LD_INT 0
110476: ST_TO_ADDR
// end ; if f_heal then
110477: LD_VAR 0 23
110481: IFFALSE 110508
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
110483: LD_ADDR_VAR 0 31
110487: PUSH
110488: LD_VAR 0 4
110492: PPUSH
110493: LD_INT 25
110495: PUSH
110496: LD_INT 4
110498: PUSH
110499: EMPTY
110500: LIST
110501: LIST
110502: PPUSH
110503: CALL_OW 72
110507: ST_TO_ADDR
// if f_repair then
110508: LD_VAR 0 22
110512: IFFALSE 110539
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
110514: LD_ADDR_VAR 0 33
110518: PUSH
110519: LD_VAR 0 4
110523: PPUSH
110524: LD_INT 25
110526: PUSH
110527: LD_INT 3
110529: PUSH
110530: EMPTY
110531: LIST
110532: LIST
110533: PPUSH
110534: CALL_OW 72
110538: ST_TO_ADDR
// units_path := [ ] ;
110539: LD_ADDR_VAR 0 16
110543: PUSH
110544: EMPTY
110545: ST_TO_ADDR
// for i = 1 to group do
110546: LD_ADDR_VAR 0 7
110550: PUSH
110551: DOUBLE
110552: LD_INT 1
110554: DEC
110555: ST_TO_ADDR
110556: LD_VAR 0 4
110560: PUSH
110561: FOR_TO
110562: IFFALSE 110591
// units_path := Replace ( units_path , i , path ) ;
110564: LD_ADDR_VAR 0 16
110568: PUSH
110569: LD_VAR 0 16
110573: PPUSH
110574: LD_VAR 0 7
110578: PPUSH
110579: LD_VAR 0 5
110583: PPUSH
110584: CALL_OW 1
110588: ST_TO_ADDR
110589: GO 110561
110591: POP
110592: POP
// repeat for i = group downto 1 do
110593: LD_ADDR_VAR 0 7
110597: PUSH
110598: DOUBLE
110599: LD_VAR 0 4
110603: INC
110604: ST_TO_ADDR
110605: LD_INT 1
110607: PUSH
110608: FOR_DOWNTO
110609: IFFALSE 114731
// begin wait ( 5 ) ;
110611: LD_INT 5
110613: PPUSH
110614: CALL_OW 67
// tmp := [ ] ;
110618: LD_ADDR_VAR 0 14
110622: PUSH
110623: EMPTY
110624: ST_TO_ADDR
// attacking := false ;
110625: LD_ADDR_VAR 0 29
110629: PUSH
110630: LD_INT 0
110632: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
110633: LD_VAR 0 4
110637: PUSH
110638: LD_VAR 0 7
110642: ARRAY
110643: PPUSH
110644: CALL_OW 301
110648: PUSH
110649: LD_VAR 0 4
110653: PUSH
110654: LD_VAR 0 7
110658: ARRAY
110659: NOT
110660: OR
110661: IFFALSE 110770
// begin if GetType ( group [ i ] ) = unit_human then
110663: LD_VAR 0 4
110667: PUSH
110668: LD_VAR 0 7
110672: ARRAY
110673: PPUSH
110674: CALL_OW 247
110678: PUSH
110679: LD_INT 1
110681: EQUAL
110682: IFFALSE 110728
// begin to_heal := to_heal diff group [ i ] ;
110684: LD_ADDR_VAR 0 30
110688: PUSH
110689: LD_VAR 0 30
110693: PUSH
110694: LD_VAR 0 4
110698: PUSH
110699: LD_VAR 0 7
110703: ARRAY
110704: DIFF
110705: ST_TO_ADDR
// healers := healers diff group [ i ] ;
110706: LD_ADDR_VAR 0 31
110710: PUSH
110711: LD_VAR 0 31
110715: PUSH
110716: LD_VAR 0 4
110720: PUSH
110721: LD_VAR 0 7
110725: ARRAY
110726: DIFF
110727: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
110728: LD_ADDR_VAR 0 4
110732: PUSH
110733: LD_VAR 0 4
110737: PPUSH
110738: LD_VAR 0 7
110742: PPUSH
110743: CALL_OW 3
110747: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
110748: LD_ADDR_VAR 0 16
110752: PUSH
110753: LD_VAR 0 16
110757: PPUSH
110758: LD_VAR 0 7
110762: PPUSH
110763: CALL_OW 3
110767: ST_TO_ADDR
// continue ;
110768: GO 110608
// end ; if f_repair then
110770: LD_VAR 0 22
110774: IFFALSE 111263
// begin if GetType ( group [ i ] ) = unit_vehicle then
110776: LD_VAR 0 4
110780: PUSH
110781: LD_VAR 0 7
110785: ARRAY
110786: PPUSH
110787: CALL_OW 247
110791: PUSH
110792: LD_INT 2
110794: EQUAL
110795: IFFALSE 110985
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
110797: LD_VAR 0 4
110801: PUSH
110802: LD_VAR 0 7
110806: ARRAY
110807: PPUSH
110808: CALL_OW 256
110812: PUSH
110813: LD_INT 700
110815: LESS
110816: PUSH
110817: LD_VAR 0 4
110821: PUSH
110822: LD_VAR 0 7
110826: ARRAY
110827: PUSH
110828: LD_VAR 0 32
110832: IN
110833: NOT
110834: AND
110835: IFFALSE 110859
// to_repair := to_repair union group [ i ] ;
110837: LD_ADDR_VAR 0 32
110841: PUSH
110842: LD_VAR 0 32
110846: PUSH
110847: LD_VAR 0 4
110851: PUSH
110852: LD_VAR 0 7
110856: ARRAY
110857: UNION
110858: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
110859: LD_VAR 0 4
110863: PUSH
110864: LD_VAR 0 7
110868: ARRAY
110869: PPUSH
110870: CALL_OW 256
110874: PUSH
110875: LD_INT 1000
110877: EQUAL
110878: PUSH
110879: LD_VAR 0 4
110883: PUSH
110884: LD_VAR 0 7
110888: ARRAY
110889: PUSH
110890: LD_VAR 0 32
110894: IN
110895: AND
110896: IFFALSE 110920
// to_repair := to_repair diff group [ i ] ;
110898: LD_ADDR_VAR 0 32
110902: PUSH
110903: LD_VAR 0 32
110907: PUSH
110908: LD_VAR 0 4
110912: PUSH
110913: LD_VAR 0 7
110917: ARRAY
110918: DIFF
110919: ST_TO_ADDR
// if group [ i ] in to_repair then
110920: LD_VAR 0 4
110924: PUSH
110925: LD_VAR 0 7
110929: ARRAY
110930: PUSH
110931: LD_VAR 0 32
110935: IN
110936: IFFALSE 110983
// begin if not IsInArea ( group [ i ] , f_repair ) then
110938: LD_VAR 0 4
110942: PUSH
110943: LD_VAR 0 7
110947: ARRAY
110948: PPUSH
110949: LD_VAR 0 22
110953: PPUSH
110954: CALL_OW 308
110958: NOT
110959: IFFALSE 110981
// ComMoveToArea ( group [ i ] , f_repair ) ;
110961: LD_VAR 0 4
110965: PUSH
110966: LD_VAR 0 7
110970: ARRAY
110971: PPUSH
110972: LD_VAR 0 22
110976: PPUSH
110977: CALL_OW 113
// continue ;
110981: GO 110608
// end ; end else
110983: GO 111263
// if group [ i ] in repairs then
110985: LD_VAR 0 4
110989: PUSH
110990: LD_VAR 0 7
110994: ARRAY
110995: PUSH
110996: LD_VAR 0 33
111000: IN
111001: IFFALSE 111263
// begin if IsInUnit ( group [ i ] ) then
111003: LD_VAR 0 4
111007: PUSH
111008: LD_VAR 0 7
111012: ARRAY
111013: PPUSH
111014: CALL_OW 310
111018: IFFALSE 111086
// begin z := IsInUnit ( group [ i ] ) ;
111020: LD_ADDR_VAR 0 13
111024: PUSH
111025: LD_VAR 0 4
111029: PUSH
111030: LD_VAR 0 7
111034: ARRAY
111035: PPUSH
111036: CALL_OW 310
111040: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
111041: LD_VAR 0 13
111045: PUSH
111046: LD_VAR 0 32
111050: IN
111051: PUSH
111052: LD_VAR 0 13
111056: PPUSH
111057: LD_VAR 0 22
111061: PPUSH
111062: CALL_OW 308
111066: AND
111067: IFFALSE 111084
// ComExitVehicle ( group [ i ] ) ;
111069: LD_VAR 0 4
111073: PUSH
111074: LD_VAR 0 7
111078: ARRAY
111079: PPUSH
111080: CALL_OW 121
// end else
111084: GO 111263
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
111086: LD_ADDR_VAR 0 13
111090: PUSH
111091: LD_VAR 0 4
111095: PPUSH
111096: LD_INT 95
111098: PUSH
111099: LD_VAR 0 22
111103: PUSH
111104: EMPTY
111105: LIST
111106: LIST
111107: PUSH
111108: LD_INT 58
111110: PUSH
111111: EMPTY
111112: LIST
111113: PUSH
111114: EMPTY
111115: LIST
111116: LIST
111117: PPUSH
111118: CALL_OW 72
111122: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
111123: LD_VAR 0 4
111127: PUSH
111128: LD_VAR 0 7
111132: ARRAY
111133: PPUSH
111134: CALL_OW 314
111138: NOT
111139: IFFALSE 111261
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
111141: LD_ADDR_VAR 0 10
111145: PUSH
111146: LD_VAR 0 13
111150: PPUSH
111151: LD_VAR 0 4
111155: PUSH
111156: LD_VAR 0 7
111160: ARRAY
111161: PPUSH
111162: CALL_OW 74
111166: ST_TO_ADDR
// if not x then
111167: LD_VAR 0 10
111171: NOT
111172: IFFALSE 111176
// continue ;
111174: GO 110608
// if GetLives ( x ) < 1000 then
111176: LD_VAR 0 10
111180: PPUSH
111181: CALL_OW 256
111185: PUSH
111186: LD_INT 1000
111188: LESS
111189: IFFALSE 111213
// ComRepairVehicle ( group [ i ] , x ) else
111191: LD_VAR 0 4
111195: PUSH
111196: LD_VAR 0 7
111200: ARRAY
111201: PPUSH
111202: LD_VAR 0 10
111206: PPUSH
111207: CALL_OW 129
111211: GO 111261
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
111213: LD_VAR 0 23
111217: PUSH
111218: LD_VAR 0 4
111222: PUSH
111223: LD_VAR 0 7
111227: ARRAY
111228: PPUSH
111229: CALL_OW 256
111233: PUSH
111234: LD_INT 1000
111236: LESS
111237: AND
111238: NOT
111239: IFFALSE 111261
// ComEnterUnit ( group [ i ] , x ) ;
111241: LD_VAR 0 4
111245: PUSH
111246: LD_VAR 0 7
111250: ARRAY
111251: PPUSH
111252: LD_VAR 0 10
111256: PPUSH
111257: CALL_OW 120
// end ; continue ;
111261: GO 110608
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
111263: LD_VAR 0 23
111267: PUSH
111268: LD_VAR 0 4
111272: PUSH
111273: LD_VAR 0 7
111277: ARRAY
111278: PPUSH
111279: CALL_OW 247
111283: PUSH
111284: LD_INT 1
111286: EQUAL
111287: AND
111288: IFFALSE 111766
// begin if group [ i ] in healers then
111290: LD_VAR 0 4
111294: PUSH
111295: LD_VAR 0 7
111299: ARRAY
111300: PUSH
111301: LD_VAR 0 31
111305: IN
111306: IFFALSE 111579
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
111308: LD_VAR 0 4
111312: PUSH
111313: LD_VAR 0 7
111317: ARRAY
111318: PPUSH
111319: LD_VAR 0 23
111323: PPUSH
111324: CALL_OW 308
111328: NOT
111329: PUSH
111330: LD_VAR 0 4
111334: PUSH
111335: LD_VAR 0 7
111339: ARRAY
111340: PPUSH
111341: CALL_OW 314
111345: NOT
111346: AND
111347: IFFALSE 111371
// ComMoveToArea ( group [ i ] , f_heal ) else
111349: LD_VAR 0 4
111353: PUSH
111354: LD_VAR 0 7
111358: ARRAY
111359: PPUSH
111360: LD_VAR 0 23
111364: PPUSH
111365: CALL_OW 113
111369: GO 111577
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
111371: LD_VAR 0 4
111375: PUSH
111376: LD_VAR 0 7
111380: ARRAY
111381: PPUSH
111382: CALL 51517 0 1
111386: PPUSH
111387: CALL_OW 256
111391: PUSH
111392: LD_INT 1000
111394: EQUAL
111395: IFFALSE 111414
// ComStop ( group [ i ] ) else
111397: LD_VAR 0 4
111401: PUSH
111402: LD_VAR 0 7
111406: ARRAY
111407: PPUSH
111408: CALL_OW 141
111412: GO 111577
// if not HasTask ( group [ i ] ) and to_heal then
111414: LD_VAR 0 4
111418: PUSH
111419: LD_VAR 0 7
111423: ARRAY
111424: PPUSH
111425: CALL_OW 314
111429: NOT
111430: PUSH
111431: LD_VAR 0 30
111435: AND
111436: IFFALSE 111577
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
111438: LD_ADDR_VAR 0 13
111442: PUSH
111443: LD_VAR 0 30
111447: PPUSH
111448: LD_INT 3
111450: PUSH
111451: LD_INT 54
111453: PUSH
111454: EMPTY
111455: LIST
111456: PUSH
111457: EMPTY
111458: LIST
111459: LIST
111460: PPUSH
111461: CALL_OW 72
111465: PPUSH
111466: LD_VAR 0 4
111470: PUSH
111471: LD_VAR 0 7
111475: ARRAY
111476: PPUSH
111477: CALL_OW 74
111481: ST_TO_ADDR
// if z then
111482: LD_VAR 0 13
111486: IFFALSE 111577
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
111488: LD_INT 91
111490: PUSH
111491: LD_VAR 0 13
111495: PUSH
111496: LD_INT 10
111498: PUSH
111499: EMPTY
111500: LIST
111501: LIST
111502: LIST
111503: PUSH
111504: LD_INT 81
111506: PUSH
111507: LD_VAR 0 13
111511: PPUSH
111512: CALL_OW 255
111516: PUSH
111517: EMPTY
111518: LIST
111519: LIST
111520: PUSH
111521: EMPTY
111522: LIST
111523: LIST
111524: PPUSH
111525: CALL_OW 69
111529: PUSH
111530: LD_INT 0
111532: EQUAL
111533: IFFALSE 111557
// ComHeal ( group [ i ] , z ) else
111535: LD_VAR 0 4
111539: PUSH
111540: LD_VAR 0 7
111544: ARRAY
111545: PPUSH
111546: LD_VAR 0 13
111550: PPUSH
111551: CALL_OW 128
111555: GO 111577
// ComMoveToArea ( group [ i ] , f_heal ) ;
111557: LD_VAR 0 4
111561: PUSH
111562: LD_VAR 0 7
111566: ARRAY
111567: PPUSH
111568: LD_VAR 0 23
111572: PPUSH
111573: CALL_OW 113
// end ; continue ;
111577: GO 110608
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
111579: LD_VAR 0 4
111583: PUSH
111584: LD_VAR 0 7
111588: ARRAY
111589: PPUSH
111590: CALL_OW 256
111594: PUSH
111595: LD_INT 700
111597: LESS
111598: PUSH
111599: LD_VAR 0 4
111603: PUSH
111604: LD_VAR 0 7
111608: ARRAY
111609: PUSH
111610: LD_VAR 0 30
111614: IN
111615: NOT
111616: AND
111617: IFFALSE 111641
// to_heal := to_heal union group [ i ] ;
111619: LD_ADDR_VAR 0 30
111623: PUSH
111624: LD_VAR 0 30
111628: PUSH
111629: LD_VAR 0 4
111633: PUSH
111634: LD_VAR 0 7
111638: ARRAY
111639: UNION
111640: ST_TO_ADDR
// if group [ i ] in to_heal then
111641: LD_VAR 0 4
111645: PUSH
111646: LD_VAR 0 7
111650: ARRAY
111651: PUSH
111652: LD_VAR 0 30
111656: IN
111657: IFFALSE 111766
// begin if GetLives ( group [ i ] ) = 1000 then
111659: LD_VAR 0 4
111663: PUSH
111664: LD_VAR 0 7
111668: ARRAY
111669: PPUSH
111670: CALL_OW 256
111674: PUSH
111675: LD_INT 1000
111677: EQUAL
111678: IFFALSE 111704
// to_heal := to_heal diff group [ i ] else
111680: LD_ADDR_VAR 0 30
111684: PUSH
111685: LD_VAR 0 30
111689: PUSH
111690: LD_VAR 0 4
111694: PUSH
111695: LD_VAR 0 7
111699: ARRAY
111700: DIFF
111701: ST_TO_ADDR
111702: GO 111766
// begin if not IsInArea ( group [ i ] , to_heal ) then
111704: LD_VAR 0 4
111708: PUSH
111709: LD_VAR 0 7
111713: ARRAY
111714: PPUSH
111715: LD_VAR 0 30
111719: PPUSH
111720: CALL_OW 308
111724: NOT
111725: IFFALSE 111749
// ComMoveToArea ( group [ i ] , f_heal ) else
111727: LD_VAR 0 4
111731: PUSH
111732: LD_VAR 0 7
111736: ARRAY
111737: PPUSH
111738: LD_VAR 0 23
111742: PPUSH
111743: CALL_OW 113
111747: GO 111764
// ComHold ( group [ i ] ) ;
111749: LD_VAR 0 4
111753: PUSH
111754: LD_VAR 0 7
111758: ARRAY
111759: PPUSH
111760: CALL_OW 140
// continue ;
111764: GO 110608
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
111766: LD_VAR 0 4
111770: PUSH
111771: LD_VAR 0 7
111775: ARRAY
111776: PPUSH
111777: LD_INT 10
111779: PPUSH
111780: CALL 49288 0 2
111784: NOT
111785: PUSH
111786: LD_VAR 0 16
111790: PUSH
111791: LD_VAR 0 7
111795: ARRAY
111796: PUSH
111797: EMPTY
111798: EQUAL
111799: NOT
111800: AND
111801: IFFALSE 112067
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
111803: LD_VAR 0 4
111807: PUSH
111808: LD_VAR 0 7
111812: ARRAY
111813: PPUSH
111814: CALL_OW 262
111818: PUSH
111819: LD_INT 1
111821: PUSH
111822: LD_INT 2
111824: PUSH
111825: EMPTY
111826: LIST
111827: LIST
111828: IN
111829: IFFALSE 111870
// if GetFuel ( group [ i ] ) < 10 then
111831: LD_VAR 0 4
111835: PUSH
111836: LD_VAR 0 7
111840: ARRAY
111841: PPUSH
111842: CALL_OW 261
111846: PUSH
111847: LD_INT 10
111849: LESS
111850: IFFALSE 111870
// SetFuel ( group [ i ] , 12 ) ;
111852: LD_VAR 0 4
111856: PUSH
111857: LD_VAR 0 7
111861: ARRAY
111862: PPUSH
111863: LD_INT 12
111865: PPUSH
111866: CALL_OW 240
// if units_path [ i ] then
111870: LD_VAR 0 16
111874: PUSH
111875: LD_VAR 0 7
111879: ARRAY
111880: IFFALSE 112065
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
111882: LD_VAR 0 4
111886: PUSH
111887: LD_VAR 0 7
111891: ARRAY
111892: PPUSH
111893: LD_VAR 0 16
111897: PUSH
111898: LD_VAR 0 7
111902: ARRAY
111903: PUSH
111904: LD_INT 1
111906: ARRAY
111907: PUSH
111908: LD_INT 1
111910: ARRAY
111911: PPUSH
111912: LD_VAR 0 16
111916: PUSH
111917: LD_VAR 0 7
111921: ARRAY
111922: PUSH
111923: LD_INT 1
111925: ARRAY
111926: PUSH
111927: LD_INT 2
111929: ARRAY
111930: PPUSH
111931: CALL_OW 297
111935: PUSH
111936: LD_INT 6
111938: GREATER
111939: IFFALSE 112014
// begin if not HasTask ( group [ i ] ) then
111941: LD_VAR 0 4
111945: PUSH
111946: LD_VAR 0 7
111950: ARRAY
111951: PPUSH
111952: CALL_OW 314
111956: NOT
111957: IFFALSE 112012
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
111959: LD_VAR 0 4
111963: PUSH
111964: LD_VAR 0 7
111968: ARRAY
111969: PPUSH
111970: LD_VAR 0 16
111974: PUSH
111975: LD_VAR 0 7
111979: ARRAY
111980: PUSH
111981: LD_INT 1
111983: ARRAY
111984: PUSH
111985: LD_INT 1
111987: ARRAY
111988: PPUSH
111989: LD_VAR 0 16
111993: PUSH
111994: LD_VAR 0 7
111998: ARRAY
111999: PUSH
112000: LD_INT 1
112002: ARRAY
112003: PUSH
112004: LD_INT 2
112006: ARRAY
112007: PPUSH
112008: CALL_OW 114
// end else
112012: GO 112065
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
112014: LD_ADDR_VAR 0 15
112018: PUSH
112019: LD_VAR 0 16
112023: PUSH
112024: LD_VAR 0 7
112028: ARRAY
112029: PPUSH
112030: LD_INT 1
112032: PPUSH
112033: CALL_OW 3
112037: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
112038: LD_ADDR_VAR 0 16
112042: PUSH
112043: LD_VAR 0 16
112047: PPUSH
112048: LD_VAR 0 7
112052: PPUSH
112053: LD_VAR 0 15
112057: PPUSH
112058: CALL_OW 1
112062: ST_TO_ADDR
// continue ;
112063: GO 110608
// end ; end ; end else
112065: GO 114729
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
112067: LD_ADDR_VAR 0 14
112071: PUSH
112072: LD_INT 81
112074: PUSH
112075: LD_VAR 0 4
112079: PUSH
112080: LD_VAR 0 7
112084: ARRAY
112085: PPUSH
112086: CALL_OW 255
112090: PUSH
112091: EMPTY
112092: LIST
112093: LIST
112094: PPUSH
112095: CALL_OW 69
112099: ST_TO_ADDR
// if not tmp then
112100: LD_VAR 0 14
112104: NOT
112105: IFFALSE 112109
// continue ;
112107: GO 110608
// if f_ignore_area then
112109: LD_VAR 0 17
112113: IFFALSE 112201
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
112115: LD_ADDR_VAR 0 15
112119: PUSH
112120: LD_VAR 0 14
112124: PPUSH
112125: LD_INT 3
112127: PUSH
112128: LD_INT 92
112130: PUSH
112131: LD_VAR 0 17
112135: PUSH
112136: LD_INT 1
112138: ARRAY
112139: PUSH
112140: LD_VAR 0 17
112144: PUSH
112145: LD_INT 2
112147: ARRAY
112148: PUSH
112149: LD_VAR 0 17
112153: PUSH
112154: LD_INT 3
112156: ARRAY
112157: PUSH
112158: EMPTY
112159: LIST
112160: LIST
112161: LIST
112162: LIST
112163: PUSH
112164: EMPTY
112165: LIST
112166: LIST
112167: PPUSH
112168: CALL_OW 72
112172: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112173: LD_VAR 0 14
112177: PUSH
112178: LD_VAR 0 15
112182: DIFF
112183: IFFALSE 112201
// tmp := tmp diff tmp2 ;
112185: LD_ADDR_VAR 0 14
112189: PUSH
112190: LD_VAR 0 14
112194: PUSH
112195: LD_VAR 0 15
112199: DIFF
112200: ST_TO_ADDR
// end ; if not f_murder then
112201: LD_VAR 0 20
112205: NOT
112206: IFFALSE 112264
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
112208: LD_ADDR_VAR 0 15
112212: PUSH
112213: LD_VAR 0 14
112217: PPUSH
112218: LD_INT 3
112220: PUSH
112221: LD_INT 50
112223: PUSH
112224: EMPTY
112225: LIST
112226: PUSH
112227: EMPTY
112228: LIST
112229: LIST
112230: PPUSH
112231: CALL_OW 72
112235: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112236: LD_VAR 0 14
112240: PUSH
112241: LD_VAR 0 15
112245: DIFF
112246: IFFALSE 112264
// tmp := tmp diff tmp2 ;
112248: LD_ADDR_VAR 0 14
112252: PUSH
112253: LD_VAR 0 14
112257: PUSH
112258: LD_VAR 0 15
112262: DIFF
112263: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
112264: LD_ADDR_VAR 0 14
112268: PUSH
112269: LD_VAR 0 4
112273: PUSH
112274: LD_VAR 0 7
112278: ARRAY
112279: PPUSH
112280: LD_VAR 0 14
112284: PPUSH
112285: LD_INT 1
112287: PPUSH
112288: LD_INT 1
112290: PPUSH
112291: CALL 21832 0 4
112295: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
112296: LD_VAR 0 4
112300: PUSH
112301: LD_VAR 0 7
112305: ARRAY
112306: PPUSH
112307: CALL_OW 257
112311: PUSH
112312: LD_INT 1
112314: EQUAL
112315: IFFALSE 112763
// begin if WantPlant ( group [ i ] ) then
112317: LD_VAR 0 4
112321: PUSH
112322: LD_VAR 0 7
112326: ARRAY
112327: PPUSH
112328: CALL 21333 0 1
112332: IFFALSE 112336
// continue ;
112334: GO 110608
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
112336: LD_VAR 0 18
112340: PUSH
112341: LD_VAR 0 4
112345: PUSH
112346: LD_VAR 0 7
112350: ARRAY
112351: PPUSH
112352: CALL_OW 310
112356: NOT
112357: AND
112358: PUSH
112359: LD_VAR 0 14
112363: PUSH
112364: LD_INT 1
112366: ARRAY
112367: PUSH
112368: LD_VAR 0 14
112372: PPUSH
112373: LD_INT 21
112375: PUSH
112376: LD_INT 2
112378: PUSH
112379: EMPTY
112380: LIST
112381: LIST
112382: PUSH
112383: LD_INT 58
112385: PUSH
112386: EMPTY
112387: LIST
112388: PUSH
112389: EMPTY
112390: LIST
112391: LIST
112392: PPUSH
112393: CALL_OW 72
112397: IN
112398: AND
112399: IFFALSE 112435
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
112401: LD_VAR 0 4
112405: PUSH
112406: LD_VAR 0 7
112410: ARRAY
112411: PPUSH
112412: LD_VAR 0 14
112416: PUSH
112417: LD_INT 1
112419: ARRAY
112420: PPUSH
112421: CALL_OW 120
// attacking := true ;
112425: LD_ADDR_VAR 0 29
112429: PUSH
112430: LD_INT 1
112432: ST_TO_ADDR
// continue ;
112433: GO 110608
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
112435: LD_VAR 0 26
112439: PUSH
112440: LD_VAR 0 4
112444: PUSH
112445: LD_VAR 0 7
112449: ARRAY
112450: PPUSH
112451: CALL_OW 257
112455: PUSH
112456: LD_INT 1
112458: EQUAL
112459: AND
112460: PUSH
112461: LD_VAR 0 4
112465: PUSH
112466: LD_VAR 0 7
112470: ARRAY
112471: PPUSH
112472: CALL_OW 256
112476: PUSH
112477: LD_INT 800
112479: LESS
112480: AND
112481: PUSH
112482: LD_VAR 0 4
112486: PUSH
112487: LD_VAR 0 7
112491: ARRAY
112492: PPUSH
112493: CALL_OW 318
112497: NOT
112498: AND
112499: IFFALSE 112516
// ComCrawl ( group [ i ] ) ;
112501: LD_VAR 0 4
112505: PUSH
112506: LD_VAR 0 7
112510: ARRAY
112511: PPUSH
112512: CALL_OW 137
// if f_mines then
112516: LD_VAR 0 21
112520: IFFALSE 112763
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
112522: LD_VAR 0 14
112526: PUSH
112527: LD_INT 1
112529: ARRAY
112530: PPUSH
112531: CALL_OW 247
112535: PUSH
112536: LD_INT 3
112538: EQUAL
112539: PUSH
112540: LD_VAR 0 14
112544: PUSH
112545: LD_INT 1
112547: ARRAY
112548: PUSH
112549: LD_VAR 0 27
112553: IN
112554: NOT
112555: AND
112556: IFFALSE 112763
// begin x := GetX ( tmp [ 1 ] ) ;
112558: LD_ADDR_VAR 0 10
112562: PUSH
112563: LD_VAR 0 14
112567: PUSH
112568: LD_INT 1
112570: ARRAY
112571: PPUSH
112572: CALL_OW 250
112576: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
112577: LD_ADDR_VAR 0 11
112581: PUSH
112582: LD_VAR 0 14
112586: PUSH
112587: LD_INT 1
112589: ARRAY
112590: PPUSH
112591: CALL_OW 251
112595: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
112596: LD_ADDR_VAR 0 12
112600: PUSH
112601: LD_VAR 0 4
112605: PUSH
112606: LD_VAR 0 7
112610: ARRAY
112611: PPUSH
112612: CALL 49373 0 1
112616: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
112617: LD_VAR 0 4
112621: PUSH
112622: LD_VAR 0 7
112626: ARRAY
112627: PPUSH
112628: LD_VAR 0 10
112632: PPUSH
112633: LD_VAR 0 11
112637: PPUSH
112638: LD_VAR 0 14
112642: PUSH
112643: LD_INT 1
112645: ARRAY
112646: PPUSH
112647: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
112651: LD_VAR 0 4
112655: PUSH
112656: LD_VAR 0 7
112660: ARRAY
112661: PPUSH
112662: LD_VAR 0 10
112666: PPUSH
112667: LD_VAR 0 12
112671: PPUSH
112672: LD_INT 7
112674: PPUSH
112675: CALL_OW 272
112679: PPUSH
112680: LD_VAR 0 11
112684: PPUSH
112685: LD_VAR 0 12
112689: PPUSH
112690: LD_INT 7
112692: PPUSH
112693: CALL_OW 273
112697: PPUSH
112698: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
112702: LD_VAR 0 4
112706: PUSH
112707: LD_VAR 0 7
112711: ARRAY
112712: PPUSH
112713: LD_INT 71
112715: PPUSH
112716: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
112720: LD_ADDR_VAR 0 27
112724: PUSH
112725: LD_VAR 0 27
112729: PPUSH
112730: LD_VAR 0 27
112734: PUSH
112735: LD_INT 1
112737: PLUS
112738: PPUSH
112739: LD_VAR 0 14
112743: PUSH
112744: LD_INT 1
112746: ARRAY
112747: PPUSH
112748: CALL_OW 1
112752: ST_TO_ADDR
// attacking := true ;
112753: LD_ADDR_VAR 0 29
112757: PUSH
112758: LD_INT 1
112760: ST_TO_ADDR
// continue ;
112761: GO 110608
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
112763: LD_VAR 0 4
112767: PUSH
112768: LD_VAR 0 7
112772: ARRAY
112773: PPUSH
112774: CALL_OW 257
112778: PUSH
112779: LD_INT 17
112781: EQUAL
112782: PUSH
112783: LD_VAR 0 4
112787: PUSH
112788: LD_VAR 0 7
112792: ARRAY
112793: PPUSH
112794: CALL_OW 110
112798: PUSH
112799: LD_INT 71
112801: EQUAL
112802: NOT
112803: AND
112804: IFFALSE 112950
// begin attacking := false ;
112806: LD_ADDR_VAR 0 29
112810: PUSH
112811: LD_INT 0
112813: ST_TO_ADDR
// k := 5 ;
112814: LD_ADDR_VAR 0 9
112818: PUSH
112819: LD_INT 5
112821: ST_TO_ADDR
// if tmp < k then
112822: LD_VAR 0 14
112826: PUSH
112827: LD_VAR 0 9
112831: LESS
112832: IFFALSE 112844
// k := tmp ;
112834: LD_ADDR_VAR 0 9
112838: PUSH
112839: LD_VAR 0 14
112843: ST_TO_ADDR
// for j = 1 to k do
112844: LD_ADDR_VAR 0 8
112848: PUSH
112849: DOUBLE
112850: LD_INT 1
112852: DEC
112853: ST_TO_ADDR
112854: LD_VAR 0 9
112858: PUSH
112859: FOR_TO
112860: IFFALSE 112948
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
112862: LD_VAR 0 14
112866: PUSH
112867: LD_VAR 0 8
112871: ARRAY
112872: PUSH
112873: LD_VAR 0 14
112877: PPUSH
112878: LD_INT 58
112880: PUSH
112881: EMPTY
112882: LIST
112883: PPUSH
112884: CALL_OW 72
112888: IN
112889: NOT
112890: IFFALSE 112946
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112892: LD_VAR 0 4
112896: PUSH
112897: LD_VAR 0 7
112901: ARRAY
112902: PPUSH
112903: LD_VAR 0 14
112907: PUSH
112908: LD_VAR 0 8
112912: ARRAY
112913: PPUSH
112914: CALL_OW 115
// attacking := true ;
112918: LD_ADDR_VAR 0 29
112922: PUSH
112923: LD_INT 1
112925: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
112926: LD_VAR 0 4
112930: PUSH
112931: LD_VAR 0 7
112935: ARRAY
112936: PPUSH
112937: LD_INT 71
112939: PPUSH
112940: CALL_OW 109
// continue ;
112944: GO 112859
// end ; end ;
112946: GO 112859
112948: POP
112949: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
112950: LD_VAR 0 4
112954: PUSH
112955: LD_VAR 0 7
112959: ARRAY
112960: PPUSH
112961: CALL_OW 257
112965: PUSH
112966: LD_INT 8
112968: EQUAL
112969: PUSH
112970: LD_VAR 0 4
112974: PUSH
112975: LD_VAR 0 7
112979: ARRAY
112980: PPUSH
112981: CALL_OW 264
112985: PUSH
112986: LD_INT 28
112988: PUSH
112989: LD_INT 45
112991: PUSH
112992: LD_INT 7
112994: PUSH
112995: LD_INT 47
112997: PUSH
112998: EMPTY
112999: LIST
113000: LIST
113001: LIST
113002: LIST
113003: IN
113004: OR
113005: IFFALSE 113261
// begin attacking := false ;
113007: LD_ADDR_VAR 0 29
113011: PUSH
113012: LD_INT 0
113014: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
113015: LD_VAR 0 14
113019: PUSH
113020: LD_INT 1
113022: ARRAY
113023: PPUSH
113024: CALL_OW 266
113028: PUSH
113029: LD_INT 32
113031: PUSH
113032: LD_INT 31
113034: PUSH
113035: LD_INT 33
113037: PUSH
113038: LD_INT 4
113040: PUSH
113041: LD_INT 5
113043: PUSH
113044: EMPTY
113045: LIST
113046: LIST
113047: LIST
113048: LIST
113049: LIST
113050: IN
113051: IFFALSE 113237
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
113053: LD_ADDR_VAR 0 9
113057: PUSH
113058: LD_VAR 0 14
113062: PUSH
113063: LD_INT 1
113065: ARRAY
113066: PPUSH
113067: CALL_OW 266
113071: PPUSH
113072: LD_VAR 0 14
113076: PUSH
113077: LD_INT 1
113079: ARRAY
113080: PPUSH
113081: CALL_OW 250
113085: PPUSH
113086: LD_VAR 0 14
113090: PUSH
113091: LD_INT 1
113093: ARRAY
113094: PPUSH
113095: CALL_OW 251
113099: PPUSH
113100: LD_VAR 0 14
113104: PUSH
113105: LD_INT 1
113107: ARRAY
113108: PPUSH
113109: CALL_OW 254
113113: PPUSH
113114: LD_VAR 0 14
113118: PUSH
113119: LD_INT 1
113121: ARRAY
113122: PPUSH
113123: CALL_OW 248
113127: PPUSH
113128: LD_INT 0
113130: PPUSH
113131: CALL 30743 0 6
113135: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
113136: LD_ADDR_VAR 0 8
113140: PUSH
113141: LD_VAR 0 4
113145: PUSH
113146: LD_VAR 0 7
113150: ARRAY
113151: PPUSH
113152: LD_VAR 0 9
113156: PPUSH
113157: CALL 49486 0 2
113161: ST_TO_ADDR
// if j then
113162: LD_VAR 0 8
113166: IFFALSE 113235
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
113168: LD_VAR 0 8
113172: PUSH
113173: LD_INT 1
113175: ARRAY
113176: PPUSH
113177: LD_VAR 0 8
113181: PUSH
113182: LD_INT 2
113184: ARRAY
113185: PPUSH
113186: CALL_OW 488
113190: IFFALSE 113235
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
113192: LD_VAR 0 4
113196: PUSH
113197: LD_VAR 0 7
113201: ARRAY
113202: PPUSH
113203: LD_VAR 0 8
113207: PUSH
113208: LD_INT 1
113210: ARRAY
113211: PPUSH
113212: LD_VAR 0 8
113216: PUSH
113217: LD_INT 2
113219: ARRAY
113220: PPUSH
113221: CALL_OW 116
// attacking := true ;
113225: LD_ADDR_VAR 0 29
113229: PUSH
113230: LD_INT 1
113232: ST_TO_ADDR
// continue ;
113233: GO 110608
// end ; end else
113235: GO 113261
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113237: LD_VAR 0 4
113241: PUSH
113242: LD_VAR 0 7
113246: ARRAY
113247: PPUSH
113248: LD_VAR 0 14
113252: PUSH
113253: LD_INT 1
113255: ARRAY
113256: PPUSH
113257: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
113261: LD_VAR 0 4
113265: PUSH
113266: LD_VAR 0 7
113270: ARRAY
113271: PPUSH
113272: CALL_OW 265
113276: PUSH
113277: LD_INT 11
113279: EQUAL
113280: IFFALSE 113558
// begin k := 10 ;
113282: LD_ADDR_VAR 0 9
113286: PUSH
113287: LD_INT 10
113289: ST_TO_ADDR
// x := 0 ;
113290: LD_ADDR_VAR 0 10
113294: PUSH
113295: LD_INT 0
113297: ST_TO_ADDR
// if tmp < k then
113298: LD_VAR 0 14
113302: PUSH
113303: LD_VAR 0 9
113307: LESS
113308: IFFALSE 113320
// k := tmp ;
113310: LD_ADDR_VAR 0 9
113314: PUSH
113315: LD_VAR 0 14
113319: ST_TO_ADDR
// for j = k downto 1 do
113320: LD_ADDR_VAR 0 8
113324: PUSH
113325: DOUBLE
113326: LD_VAR 0 9
113330: INC
113331: ST_TO_ADDR
113332: LD_INT 1
113334: PUSH
113335: FOR_DOWNTO
113336: IFFALSE 113411
// begin if GetType ( tmp [ j ] ) = unit_human then
113338: LD_VAR 0 14
113342: PUSH
113343: LD_VAR 0 8
113347: ARRAY
113348: PPUSH
113349: CALL_OW 247
113353: PUSH
113354: LD_INT 1
113356: EQUAL
113357: IFFALSE 113409
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
113359: LD_VAR 0 4
113363: PUSH
113364: LD_VAR 0 7
113368: ARRAY
113369: PPUSH
113370: LD_VAR 0 14
113374: PUSH
113375: LD_VAR 0 8
113379: ARRAY
113380: PPUSH
113381: CALL 49740 0 2
// x := tmp [ j ] ;
113385: LD_ADDR_VAR 0 10
113389: PUSH
113390: LD_VAR 0 14
113394: PUSH
113395: LD_VAR 0 8
113399: ARRAY
113400: ST_TO_ADDR
// attacking := true ;
113401: LD_ADDR_VAR 0 29
113405: PUSH
113406: LD_INT 1
113408: ST_TO_ADDR
// end ; end ;
113409: GO 113335
113411: POP
113412: POP
// if not x then
113413: LD_VAR 0 10
113417: NOT
113418: IFFALSE 113558
// begin attacking := true ;
113420: LD_ADDR_VAR 0 29
113424: PUSH
113425: LD_INT 1
113427: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
113428: LD_VAR 0 4
113432: PUSH
113433: LD_VAR 0 7
113437: ARRAY
113438: PPUSH
113439: CALL_OW 250
113443: PPUSH
113444: LD_VAR 0 4
113448: PUSH
113449: LD_VAR 0 7
113453: ARRAY
113454: PPUSH
113455: CALL_OW 251
113459: PPUSH
113460: CALL_OW 546
113464: PUSH
113465: LD_INT 2
113467: ARRAY
113468: PUSH
113469: LD_VAR 0 14
113473: PUSH
113474: LD_INT 1
113476: ARRAY
113477: PPUSH
113478: CALL_OW 250
113482: PPUSH
113483: LD_VAR 0 14
113487: PUSH
113488: LD_INT 1
113490: ARRAY
113491: PPUSH
113492: CALL_OW 251
113496: PPUSH
113497: CALL_OW 546
113501: PUSH
113502: LD_INT 2
113504: ARRAY
113505: EQUAL
113506: IFFALSE 113534
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
113508: LD_VAR 0 4
113512: PUSH
113513: LD_VAR 0 7
113517: ARRAY
113518: PPUSH
113519: LD_VAR 0 14
113523: PUSH
113524: LD_INT 1
113526: ARRAY
113527: PPUSH
113528: CALL 49740 0 2
113532: GO 113558
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113534: LD_VAR 0 4
113538: PUSH
113539: LD_VAR 0 7
113543: ARRAY
113544: PPUSH
113545: LD_VAR 0 14
113549: PUSH
113550: LD_INT 1
113552: ARRAY
113553: PPUSH
113554: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
113558: LD_VAR 0 4
113562: PUSH
113563: LD_VAR 0 7
113567: ARRAY
113568: PPUSH
113569: CALL_OW 264
113573: PUSH
113574: LD_INT 29
113576: EQUAL
113577: IFFALSE 113943
// begin if WantsToAttack ( group [ i ] ) in bombed then
113579: LD_VAR 0 4
113583: PUSH
113584: LD_VAR 0 7
113588: ARRAY
113589: PPUSH
113590: CALL_OW 319
113594: PUSH
113595: LD_VAR 0 28
113599: IN
113600: IFFALSE 113604
// continue ;
113602: GO 110608
// k := 8 ;
113604: LD_ADDR_VAR 0 9
113608: PUSH
113609: LD_INT 8
113611: ST_TO_ADDR
// x := 0 ;
113612: LD_ADDR_VAR 0 10
113616: PUSH
113617: LD_INT 0
113619: ST_TO_ADDR
// if tmp < k then
113620: LD_VAR 0 14
113624: PUSH
113625: LD_VAR 0 9
113629: LESS
113630: IFFALSE 113642
// k := tmp ;
113632: LD_ADDR_VAR 0 9
113636: PUSH
113637: LD_VAR 0 14
113641: ST_TO_ADDR
// for j = 1 to k do
113642: LD_ADDR_VAR 0 8
113646: PUSH
113647: DOUBLE
113648: LD_INT 1
113650: DEC
113651: ST_TO_ADDR
113652: LD_VAR 0 9
113656: PUSH
113657: FOR_TO
113658: IFFALSE 113790
// begin if GetType ( tmp [ j ] ) = unit_building then
113660: LD_VAR 0 14
113664: PUSH
113665: LD_VAR 0 8
113669: ARRAY
113670: PPUSH
113671: CALL_OW 247
113675: PUSH
113676: LD_INT 3
113678: EQUAL
113679: IFFALSE 113788
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
113681: LD_VAR 0 14
113685: PUSH
113686: LD_VAR 0 8
113690: ARRAY
113691: PUSH
113692: LD_VAR 0 28
113696: IN
113697: NOT
113698: PUSH
113699: LD_VAR 0 14
113703: PUSH
113704: LD_VAR 0 8
113708: ARRAY
113709: PPUSH
113710: CALL_OW 313
113714: AND
113715: IFFALSE 113788
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113717: LD_VAR 0 4
113721: PUSH
113722: LD_VAR 0 7
113726: ARRAY
113727: PPUSH
113728: LD_VAR 0 14
113732: PUSH
113733: LD_VAR 0 8
113737: ARRAY
113738: PPUSH
113739: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
113743: LD_ADDR_VAR 0 28
113747: PUSH
113748: LD_VAR 0 28
113752: PPUSH
113753: LD_VAR 0 28
113757: PUSH
113758: LD_INT 1
113760: PLUS
113761: PPUSH
113762: LD_VAR 0 14
113766: PUSH
113767: LD_VAR 0 8
113771: ARRAY
113772: PPUSH
113773: CALL_OW 1
113777: ST_TO_ADDR
// attacking := true ;
113778: LD_ADDR_VAR 0 29
113782: PUSH
113783: LD_INT 1
113785: ST_TO_ADDR
// break ;
113786: GO 113790
// end ; end ;
113788: GO 113657
113790: POP
113791: POP
// if not attacking and f_attack_depot then
113792: LD_VAR 0 29
113796: NOT
113797: PUSH
113798: LD_VAR 0 25
113802: AND
113803: IFFALSE 113898
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113805: LD_ADDR_VAR 0 13
113809: PUSH
113810: LD_VAR 0 14
113814: PPUSH
113815: LD_INT 2
113817: PUSH
113818: LD_INT 30
113820: PUSH
113821: LD_INT 0
113823: PUSH
113824: EMPTY
113825: LIST
113826: LIST
113827: PUSH
113828: LD_INT 30
113830: PUSH
113831: LD_INT 1
113833: PUSH
113834: EMPTY
113835: LIST
113836: LIST
113837: PUSH
113838: EMPTY
113839: LIST
113840: LIST
113841: LIST
113842: PPUSH
113843: CALL_OW 72
113847: ST_TO_ADDR
// if z then
113848: LD_VAR 0 13
113852: IFFALSE 113898
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
113854: LD_VAR 0 4
113858: PUSH
113859: LD_VAR 0 7
113863: ARRAY
113864: PPUSH
113865: LD_VAR 0 13
113869: PPUSH
113870: LD_VAR 0 4
113874: PUSH
113875: LD_VAR 0 7
113879: ARRAY
113880: PPUSH
113881: CALL_OW 74
113885: PPUSH
113886: CALL_OW 115
// attacking := true ;
113890: LD_ADDR_VAR 0 29
113894: PUSH
113895: LD_INT 1
113897: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
113898: LD_VAR 0 4
113902: PUSH
113903: LD_VAR 0 7
113907: ARRAY
113908: PPUSH
113909: CALL_OW 256
113913: PUSH
113914: LD_INT 500
113916: LESS
113917: IFFALSE 113943
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113919: LD_VAR 0 4
113923: PUSH
113924: LD_VAR 0 7
113928: ARRAY
113929: PPUSH
113930: LD_VAR 0 14
113934: PUSH
113935: LD_INT 1
113937: ARRAY
113938: PPUSH
113939: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
113943: LD_VAR 0 4
113947: PUSH
113948: LD_VAR 0 7
113952: ARRAY
113953: PPUSH
113954: CALL_OW 264
113958: PUSH
113959: LD_INT 49
113961: EQUAL
113962: IFFALSE 114083
// begin if not HasTask ( group [ i ] ) then
113964: LD_VAR 0 4
113968: PUSH
113969: LD_VAR 0 7
113973: ARRAY
113974: PPUSH
113975: CALL_OW 314
113979: NOT
113980: IFFALSE 114083
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
113982: LD_ADDR_VAR 0 9
113986: PUSH
113987: LD_INT 81
113989: PUSH
113990: LD_VAR 0 4
113994: PUSH
113995: LD_VAR 0 7
113999: ARRAY
114000: PPUSH
114001: CALL_OW 255
114005: PUSH
114006: EMPTY
114007: LIST
114008: LIST
114009: PPUSH
114010: CALL_OW 69
114014: PPUSH
114015: LD_VAR 0 4
114019: PUSH
114020: LD_VAR 0 7
114024: ARRAY
114025: PPUSH
114026: CALL_OW 74
114030: ST_TO_ADDR
// if k then
114031: LD_VAR 0 9
114035: IFFALSE 114083
// if GetDistUnits ( group [ i ] , k ) > 10 then
114037: LD_VAR 0 4
114041: PUSH
114042: LD_VAR 0 7
114046: ARRAY
114047: PPUSH
114048: LD_VAR 0 9
114052: PPUSH
114053: CALL_OW 296
114057: PUSH
114058: LD_INT 10
114060: GREATER
114061: IFFALSE 114083
// ComMoveUnit ( group [ i ] , k ) ;
114063: LD_VAR 0 4
114067: PUSH
114068: LD_VAR 0 7
114072: ARRAY
114073: PPUSH
114074: LD_VAR 0 9
114078: PPUSH
114079: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
114083: LD_VAR 0 4
114087: PUSH
114088: LD_VAR 0 7
114092: ARRAY
114093: PPUSH
114094: CALL_OW 256
114098: PUSH
114099: LD_INT 250
114101: LESS
114102: PUSH
114103: LD_VAR 0 4
114107: PUSH
114108: LD_VAR 0 7
114112: ARRAY
114113: PUSH
114114: LD_INT 21
114116: PUSH
114117: LD_INT 2
114119: PUSH
114120: EMPTY
114121: LIST
114122: LIST
114123: PUSH
114124: LD_INT 23
114126: PUSH
114127: LD_INT 2
114129: PUSH
114130: EMPTY
114131: LIST
114132: LIST
114133: PUSH
114134: EMPTY
114135: LIST
114136: LIST
114137: PPUSH
114138: CALL_OW 69
114142: IN
114143: AND
114144: IFFALSE 114269
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
114146: LD_ADDR_VAR 0 9
114150: PUSH
114151: LD_OWVAR 3
114155: PUSH
114156: LD_VAR 0 4
114160: PUSH
114161: LD_VAR 0 7
114165: ARRAY
114166: DIFF
114167: PPUSH
114168: LD_VAR 0 4
114172: PUSH
114173: LD_VAR 0 7
114177: ARRAY
114178: PPUSH
114179: CALL_OW 74
114183: ST_TO_ADDR
// if not k then
114184: LD_VAR 0 9
114188: NOT
114189: IFFALSE 114193
// continue ;
114191: GO 110608
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
114193: LD_VAR 0 9
114197: PUSH
114198: LD_INT 81
114200: PUSH
114201: LD_VAR 0 4
114205: PUSH
114206: LD_VAR 0 7
114210: ARRAY
114211: PPUSH
114212: CALL_OW 255
114216: PUSH
114217: EMPTY
114218: LIST
114219: LIST
114220: PPUSH
114221: CALL_OW 69
114225: IN
114226: PUSH
114227: LD_VAR 0 9
114231: PPUSH
114232: LD_VAR 0 4
114236: PUSH
114237: LD_VAR 0 7
114241: ARRAY
114242: PPUSH
114243: CALL_OW 296
114247: PUSH
114248: LD_INT 5
114250: LESS
114251: AND
114252: IFFALSE 114269
// ComAutodestruct ( group [ i ] ) ;
114254: LD_VAR 0 4
114258: PUSH
114259: LD_VAR 0 7
114263: ARRAY
114264: PPUSH
114265: CALL 49638 0 1
// end ; if f_attack_depot then
114269: LD_VAR 0 25
114273: IFFALSE 114385
// begin k := 6 ;
114275: LD_ADDR_VAR 0 9
114279: PUSH
114280: LD_INT 6
114282: ST_TO_ADDR
// if tmp < k then
114283: LD_VAR 0 14
114287: PUSH
114288: LD_VAR 0 9
114292: LESS
114293: IFFALSE 114305
// k := tmp ;
114295: LD_ADDR_VAR 0 9
114299: PUSH
114300: LD_VAR 0 14
114304: ST_TO_ADDR
// for j = 1 to k do
114305: LD_ADDR_VAR 0 8
114309: PUSH
114310: DOUBLE
114311: LD_INT 1
114313: DEC
114314: ST_TO_ADDR
114315: LD_VAR 0 9
114319: PUSH
114320: FOR_TO
114321: IFFALSE 114383
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
114323: LD_VAR 0 8
114327: PPUSH
114328: CALL_OW 266
114332: PUSH
114333: LD_INT 0
114335: PUSH
114336: LD_INT 1
114338: PUSH
114339: EMPTY
114340: LIST
114341: LIST
114342: IN
114343: IFFALSE 114381
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114345: LD_VAR 0 4
114349: PUSH
114350: LD_VAR 0 7
114354: ARRAY
114355: PPUSH
114356: LD_VAR 0 14
114360: PUSH
114361: LD_VAR 0 8
114365: ARRAY
114366: PPUSH
114367: CALL_OW 115
// attacking := true ;
114371: LD_ADDR_VAR 0 29
114375: PUSH
114376: LD_INT 1
114378: ST_TO_ADDR
// break ;
114379: GO 114383
// end ;
114381: GO 114320
114383: POP
114384: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
114385: LD_VAR 0 4
114389: PUSH
114390: LD_VAR 0 7
114394: ARRAY
114395: PPUSH
114396: CALL_OW 302
114400: PUSH
114401: LD_VAR 0 29
114405: NOT
114406: AND
114407: IFFALSE 114729
// begin if GetTag ( group [ i ] ) = 71 then
114409: LD_VAR 0 4
114413: PUSH
114414: LD_VAR 0 7
114418: ARRAY
114419: PPUSH
114420: CALL_OW 110
114424: PUSH
114425: LD_INT 71
114427: EQUAL
114428: IFFALSE 114469
// begin if HasTask ( group [ i ] ) then
114430: LD_VAR 0 4
114434: PUSH
114435: LD_VAR 0 7
114439: ARRAY
114440: PPUSH
114441: CALL_OW 314
114445: IFFALSE 114451
// continue else
114447: GO 110608
114449: GO 114469
// SetTag ( group [ i ] , 0 ) ;
114451: LD_VAR 0 4
114455: PUSH
114456: LD_VAR 0 7
114460: ARRAY
114461: PPUSH
114462: LD_INT 0
114464: PPUSH
114465: CALL_OW 109
// end ; k := 8 ;
114469: LD_ADDR_VAR 0 9
114473: PUSH
114474: LD_INT 8
114476: ST_TO_ADDR
// x := 0 ;
114477: LD_ADDR_VAR 0 10
114481: PUSH
114482: LD_INT 0
114484: ST_TO_ADDR
// if tmp < k then
114485: LD_VAR 0 14
114489: PUSH
114490: LD_VAR 0 9
114494: LESS
114495: IFFALSE 114507
// k := tmp ;
114497: LD_ADDR_VAR 0 9
114501: PUSH
114502: LD_VAR 0 14
114506: ST_TO_ADDR
// for j = 1 to k do
114507: LD_ADDR_VAR 0 8
114511: PUSH
114512: DOUBLE
114513: LD_INT 1
114515: DEC
114516: ST_TO_ADDR
114517: LD_VAR 0 9
114521: PUSH
114522: FOR_TO
114523: IFFALSE 114621
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
114525: LD_VAR 0 14
114529: PUSH
114530: LD_VAR 0 8
114534: ARRAY
114535: PPUSH
114536: CALL_OW 247
114540: PUSH
114541: LD_INT 1
114543: EQUAL
114544: PUSH
114545: LD_VAR 0 14
114549: PUSH
114550: LD_VAR 0 8
114554: ARRAY
114555: PPUSH
114556: CALL_OW 256
114560: PUSH
114561: LD_INT 250
114563: LESS
114564: PUSH
114565: LD_VAR 0 20
114569: AND
114570: PUSH
114571: LD_VAR 0 20
114575: NOT
114576: PUSH
114577: LD_VAR 0 14
114581: PUSH
114582: LD_VAR 0 8
114586: ARRAY
114587: PPUSH
114588: CALL_OW 256
114592: PUSH
114593: LD_INT 250
114595: GREATEREQUAL
114596: AND
114597: OR
114598: AND
114599: IFFALSE 114619
// begin x := tmp [ j ] ;
114601: LD_ADDR_VAR 0 10
114605: PUSH
114606: LD_VAR 0 14
114610: PUSH
114611: LD_VAR 0 8
114615: ARRAY
114616: ST_TO_ADDR
// break ;
114617: GO 114621
// end ;
114619: GO 114522
114621: POP
114622: POP
// if x then
114623: LD_VAR 0 10
114627: IFFALSE 114651
// ComAttackUnit ( group [ i ] , x ) else
114629: LD_VAR 0 4
114633: PUSH
114634: LD_VAR 0 7
114638: ARRAY
114639: PPUSH
114640: LD_VAR 0 10
114644: PPUSH
114645: CALL_OW 115
114649: GO 114675
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114651: LD_VAR 0 4
114655: PUSH
114656: LD_VAR 0 7
114660: ARRAY
114661: PPUSH
114662: LD_VAR 0 14
114666: PUSH
114667: LD_INT 1
114669: ARRAY
114670: PPUSH
114671: CALL_OW 115
// if not HasTask ( group [ i ] ) then
114675: LD_VAR 0 4
114679: PUSH
114680: LD_VAR 0 7
114684: ARRAY
114685: PPUSH
114686: CALL_OW 314
114690: NOT
114691: IFFALSE 114729
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
114693: LD_VAR 0 4
114697: PUSH
114698: LD_VAR 0 7
114702: ARRAY
114703: PPUSH
114704: LD_VAR 0 14
114708: PPUSH
114709: LD_VAR 0 4
114713: PUSH
114714: LD_VAR 0 7
114718: ARRAY
114719: PPUSH
114720: CALL_OW 74
114724: PPUSH
114725: CALL_OW 115
// end ; end ; end ;
114729: GO 110608
114731: POP
114732: POP
// wait ( 0 0$2 ) ;
114733: LD_INT 70
114735: PPUSH
114736: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
114740: LD_VAR 0 4
114744: NOT
114745: PUSH
114746: LD_VAR 0 4
114750: PUSH
114751: EMPTY
114752: EQUAL
114753: OR
114754: PUSH
114755: LD_INT 81
114757: PUSH
114758: LD_VAR 0 35
114762: PUSH
114763: EMPTY
114764: LIST
114765: LIST
114766: PPUSH
114767: CALL_OW 69
114771: NOT
114772: OR
114773: IFFALSE 110593
// end ;
114775: LD_VAR 0 2
114779: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
114780: LD_INT 0
114782: PPUSH
114783: PPUSH
114784: PPUSH
114785: PPUSH
114786: PPUSH
114787: PPUSH
// if not base or not mc_bases [ base ] or not solds then
114788: LD_VAR 0 1
114792: NOT
114793: PUSH
114794: LD_EXP 61
114798: PUSH
114799: LD_VAR 0 1
114803: ARRAY
114804: NOT
114805: OR
114806: PUSH
114807: LD_VAR 0 2
114811: NOT
114812: OR
114813: IFFALSE 114817
// exit ;
114815: GO 115371
// side := mc_sides [ base ] ;
114817: LD_ADDR_VAR 0 6
114821: PUSH
114822: LD_EXP 87
114826: PUSH
114827: LD_VAR 0 1
114831: ARRAY
114832: ST_TO_ADDR
// if not side then
114833: LD_VAR 0 6
114837: NOT
114838: IFFALSE 114842
// exit ;
114840: GO 115371
// for i in solds do
114842: LD_ADDR_VAR 0 7
114846: PUSH
114847: LD_VAR 0 2
114851: PUSH
114852: FOR_IN
114853: IFFALSE 114914
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
114855: LD_VAR 0 7
114859: PPUSH
114860: CALL_OW 310
114864: PPUSH
114865: CALL_OW 266
114869: PUSH
114870: LD_INT 32
114872: PUSH
114873: LD_INT 31
114875: PUSH
114876: EMPTY
114877: LIST
114878: LIST
114879: IN
114880: IFFALSE 114900
// solds := solds diff i else
114882: LD_ADDR_VAR 0 2
114886: PUSH
114887: LD_VAR 0 2
114891: PUSH
114892: LD_VAR 0 7
114896: DIFF
114897: ST_TO_ADDR
114898: GO 114912
// SetTag ( i , 18 ) ;
114900: LD_VAR 0 7
114904: PPUSH
114905: LD_INT 18
114907: PPUSH
114908: CALL_OW 109
114912: GO 114852
114914: POP
114915: POP
// if not solds then
114916: LD_VAR 0 2
114920: NOT
114921: IFFALSE 114925
// exit ;
114923: GO 115371
// repeat wait ( 0 0$2 ) ;
114925: LD_INT 70
114927: PPUSH
114928: CALL_OW 67
// enemy := mc_scan [ base ] ;
114932: LD_ADDR_VAR 0 4
114936: PUSH
114937: LD_EXP 84
114941: PUSH
114942: LD_VAR 0 1
114946: ARRAY
114947: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114948: LD_EXP 61
114952: PUSH
114953: LD_VAR 0 1
114957: ARRAY
114958: NOT
114959: PUSH
114960: LD_EXP 61
114964: PUSH
114965: LD_VAR 0 1
114969: ARRAY
114970: PUSH
114971: EMPTY
114972: EQUAL
114973: OR
114974: IFFALSE 115011
// begin for i in solds do
114976: LD_ADDR_VAR 0 7
114980: PUSH
114981: LD_VAR 0 2
114985: PUSH
114986: FOR_IN
114987: IFFALSE 115000
// ComStop ( i ) ;
114989: LD_VAR 0 7
114993: PPUSH
114994: CALL_OW 141
114998: GO 114986
115000: POP
115001: POP
// solds := [ ] ;
115002: LD_ADDR_VAR 0 2
115006: PUSH
115007: EMPTY
115008: ST_TO_ADDR
// exit ;
115009: GO 115371
// end ; for i in solds do
115011: LD_ADDR_VAR 0 7
115015: PUSH
115016: LD_VAR 0 2
115020: PUSH
115021: FOR_IN
115022: IFFALSE 115343
// begin if IsInUnit ( i ) then
115024: LD_VAR 0 7
115028: PPUSH
115029: CALL_OW 310
115033: IFFALSE 115044
// ComExitBuilding ( i ) ;
115035: LD_VAR 0 7
115039: PPUSH
115040: CALL_OW 122
// if GetLives ( i ) > 500 then
115044: LD_VAR 0 7
115048: PPUSH
115049: CALL_OW 256
115053: PUSH
115054: LD_INT 500
115056: GREATER
115057: IFFALSE 115110
// begin e := NearestUnitToUnit ( enemy , i ) ;
115059: LD_ADDR_VAR 0 5
115063: PUSH
115064: LD_VAR 0 4
115068: PPUSH
115069: LD_VAR 0 7
115073: PPUSH
115074: CALL_OW 74
115078: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
115079: LD_VAR 0 7
115083: PPUSH
115084: LD_VAR 0 5
115088: PPUSH
115089: CALL_OW 250
115093: PPUSH
115094: LD_VAR 0 5
115098: PPUSH
115099: CALL_OW 251
115103: PPUSH
115104: CALL_OW 114
// end else
115108: GO 115341
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
115110: LD_VAR 0 7
115114: PPUSH
115115: LD_EXP 61
115119: PUSH
115120: LD_VAR 0 1
115124: ARRAY
115125: PPUSH
115126: LD_INT 2
115128: PUSH
115129: LD_INT 30
115131: PUSH
115132: LD_INT 0
115134: PUSH
115135: EMPTY
115136: LIST
115137: LIST
115138: PUSH
115139: LD_INT 30
115141: PUSH
115142: LD_INT 1
115144: PUSH
115145: EMPTY
115146: LIST
115147: LIST
115148: PUSH
115149: LD_INT 30
115151: PUSH
115152: LD_INT 6
115154: PUSH
115155: EMPTY
115156: LIST
115157: LIST
115158: PUSH
115159: EMPTY
115160: LIST
115161: LIST
115162: LIST
115163: LIST
115164: PPUSH
115165: CALL_OW 72
115169: PPUSH
115170: LD_VAR 0 7
115174: PPUSH
115175: CALL_OW 74
115179: PPUSH
115180: CALL_OW 296
115184: PUSH
115185: LD_INT 10
115187: GREATER
115188: IFFALSE 115341
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
115190: LD_ADDR_VAR 0 8
115194: PUSH
115195: LD_EXP 61
115199: PUSH
115200: LD_VAR 0 1
115204: ARRAY
115205: PPUSH
115206: LD_INT 2
115208: PUSH
115209: LD_INT 30
115211: PUSH
115212: LD_INT 0
115214: PUSH
115215: EMPTY
115216: LIST
115217: LIST
115218: PUSH
115219: LD_INT 30
115221: PUSH
115222: LD_INT 1
115224: PUSH
115225: EMPTY
115226: LIST
115227: LIST
115228: PUSH
115229: LD_INT 30
115231: PUSH
115232: LD_INT 6
115234: PUSH
115235: EMPTY
115236: LIST
115237: LIST
115238: PUSH
115239: EMPTY
115240: LIST
115241: LIST
115242: LIST
115243: LIST
115244: PPUSH
115245: CALL_OW 72
115249: PPUSH
115250: LD_VAR 0 7
115254: PPUSH
115255: CALL_OW 74
115259: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
115260: LD_VAR 0 7
115264: PPUSH
115265: LD_VAR 0 8
115269: PPUSH
115270: CALL_OW 250
115274: PPUSH
115275: LD_INT 3
115277: PPUSH
115278: LD_INT 5
115280: PPUSH
115281: CALL_OW 272
115285: PPUSH
115286: LD_VAR 0 8
115290: PPUSH
115291: CALL_OW 251
115295: PPUSH
115296: LD_INT 3
115298: PPUSH
115299: LD_INT 5
115301: PPUSH
115302: CALL_OW 273
115306: PPUSH
115307: CALL_OW 111
// SetTag ( i , 0 ) ;
115311: LD_VAR 0 7
115315: PPUSH
115316: LD_INT 0
115318: PPUSH
115319: CALL_OW 109
// solds := solds diff i ;
115323: LD_ADDR_VAR 0 2
115327: PUSH
115328: LD_VAR 0 2
115332: PUSH
115333: LD_VAR 0 7
115337: DIFF
115338: ST_TO_ADDR
// continue ;
115339: GO 115021
// end ; end ;
115341: GO 115021
115343: POP
115344: POP
// until not solds or not enemy ;
115345: LD_VAR 0 2
115349: NOT
115350: PUSH
115351: LD_VAR 0 4
115355: NOT
115356: OR
115357: IFFALSE 114925
// MC_Reset ( base , 18 ) ;
115359: LD_VAR 0 1
115363: PPUSH
115364: LD_INT 18
115366: PPUSH
115367: CALL 62836 0 2
// end ;
115371: LD_VAR 0 3
115375: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
115376: LD_INT 0
115378: PPUSH
115379: PPUSH
115380: PPUSH
115381: PPUSH
115382: PPUSH
115383: PPUSH
115384: PPUSH
115385: PPUSH
115386: PPUSH
115387: PPUSH
115388: PPUSH
115389: PPUSH
115390: PPUSH
115391: PPUSH
115392: PPUSH
115393: PPUSH
115394: PPUSH
115395: PPUSH
115396: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
115397: LD_ADDR_VAR 0 12
115401: PUSH
115402: LD_EXP 61
115406: PUSH
115407: LD_VAR 0 1
115411: ARRAY
115412: PPUSH
115413: LD_INT 25
115415: PUSH
115416: LD_INT 3
115418: PUSH
115419: EMPTY
115420: LIST
115421: LIST
115422: PPUSH
115423: CALL_OW 72
115427: ST_TO_ADDR
// if mc_remote_driver [ base ] then
115428: LD_EXP 101
115432: PUSH
115433: LD_VAR 0 1
115437: ARRAY
115438: IFFALSE 115462
// mechs := mechs diff mc_remote_driver [ base ] ;
115440: LD_ADDR_VAR 0 12
115444: PUSH
115445: LD_VAR 0 12
115449: PUSH
115450: LD_EXP 101
115454: PUSH
115455: LD_VAR 0 1
115459: ARRAY
115460: DIFF
115461: ST_TO_ADDR
// for i in mechs do
115462: LD_ADDR_VAR 0 4
115466: PUSH
115467: LD_VAR 0 12
115471: PUSH
115472: FOR_IN
115473: IFFALSE 115508
// if GetTag ( i ) > 0 then
115475: LD_VAR 0 4
115479: PPUSH
115480: CALL_OW 110
115484: PUSH
115485: LD_INT 0
115487: GREATER
115488: IFFALSE 115506
// mechs := mechs diff i ;
115490: LD_ADDR_VAR 0 12
115494: PUSH
115495: LD_VAR 0 12
115499: PUSH
115500: LD_VAR 0 4
115504: DIFF
115505: ST_TO_ADDR
115506: GO 115472
115508: POP
115509: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
115510: LD_ADDR_VAR 0 8
115514: PUSH
115515: LD_EXP 61
115519: PUSH
115520: LD_VAR 0 1
115524: ARRAY
115525: PPUSH
115526: LD_INT 2
115528: PUSH
115529: LD_INT 25
115531: PUSH
115532: LD_INT 1
115534: PUSH
115535: EMPTY
115536: LIST
115537: LIST
115538: PUSH
115539: LD_INT 25
115541: PUSH
115542: LD_INT 5
115544: PUSH
115545: EMPTY
115546: LIST
115547: LIST
115548: PUSH
115549: LD_INT 25
115551: PUSH
115552: LD_INT 8
115554: PUSH
115555: EMPTY
115556: LIST
115557: LIST
115558: PUSH
115559: LD_INT 25
115561: PUSH
115562: LD_INT 9
115564: PUSH
115565: EMPTY
115566: LIST
115567: LIST
115568: PUSH
115569: EMPTY
115570: LIST
115571: LIST
115572: LIST
115573: LIST
115574: LIST
115575: PPUSH
115576: CALL_OW 72
115580: ST_TO_ADDR
// if not defenders and not solds then
115581: LD_VAR 0 2
115585: NOT
115586: PUSH
115587: LD_VAR 0 8
115591: NOT
115592: AND
115593: IFFALSE 115597
// exit ;
115595: GO 117367
// depot_under_attack := false ;
115597: LD_ADDR_VAR 0 16
115601: PUSH
115602: LD_INT 0
115604: ST_TO_ADDR
// sold_defenders := [ ] ;
115605: LD_ADDR_VAR 0 17
115609: PUSH
115610: EMPTY
115611: ST_TO_ADDR
// if mechs then
115612: LD_VAR 0 12
115616: IFFALSE 115769
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
115618: LD_ADDR_VAR 0 4
115622: PUSH
115623: LD_VAR 0 2
115627: PPUSH
115628: LD_INT 21
115630: PUSH
115631: LD_INT 2
115633: PUSH
115634: EMPTY
115635: LIST
115636: LIST
115637: PPUSH
115638: CALL_OW 72
115642: PUSH
115643: FOR_IN
115644: IFFALSE 115767
// begin if GetTag ( i ) <> 20 then
115646: LD_VAR 0 4
115650: PPUSH
115651: CALL_OW 110
115655: PUSH
115656: LD_INT 20
115658: NONEQUAL
115659: IFFALSE 115673
// SetTag ( i , 20 ) ;
115661: LD_VAR 0 4
115665: PPUSH
115666: LD_INT 20
115668: PPUSH
115669: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
115673: LD_VAR 0 4
115677: PPUSH
115678: CALL_OW 263
115682: PUSH
115683: LD_INT 1
115685: EQUAL
115686: PUSH
115687: LD_VAR 0 4
115691: PPUSH
115692: CALL_OW 311
115696: NOT
115697: AND
115698: IFFALSE 115765
// begin un := mechs [ 1 ] ;
115700: LD_ADDR_VAR 0 10
115704: PUSH
115705: LD_VAR 0 12
115709: PUSH
115710: LD_INT 1
115712: ARRAY
115713: ST_TO_ADDR
// ComExit ( un ) ;
115714: LD_VAR 0 10
115718: PPUSH
115719: CALL 54535 0 1
// AddComEnterUnit ( un , i ) ;
115723: LD_VAR 0 10
115727: PPUSH
115728: LD_VAR 0 4
115732: PPUSH
115733: CALL_OW 180
// SetTag ( un , 19 ) ;
115737: LD_VAR 0 10
115741: PPUSH
115742: LD_INT 19
115744: PPUSH
115745: CALL_OW 109
// mechs := mechs diff un ;
115749: LD_ADDR_VAR 0 12
115753: PUSH
115754: LD_VAR 0 12
115758: PUSH
115759: LD_VAR 0 10
115763: DIFF
115764: ST_TO_ADDR
// end ; end ;
115765: GO 115643
115767: POP
115768: POP
// if solds then
115769: LD_VAR 0 8
115773: IFFALSE 115832
// for i in solds do
115775: LD_ADDR_VAR 0 4
115779: PUSH
115780: LD_VAR 0 8
115784: PUSH
115785: FOR_IN
115786: IFFALSE 115830
// if not GetTag ( i ) then
115788: LD_VAR 0 4
115792: PPUSH
115793: CALL_OW 110
115797: NOT
115798: IFFALSE 115828
// begin defenders := defenders union i ;
115800: LD_ADDR_VAR 0 2
115804: PUSH
115805: LD_VAR 0 2
115809: PUSH
115810: LD_VAR 0 4
115814: UNION
115815: ST_TO_ADDR
// SetTag ( i , 18 ) ;
115816: LD_VAR 0 4
115820: PPUSH
115821: LD_INT 18
115823: PPUSH
115824: CALL_OW 109
// end ;
115828: GO 115785
115830: POP
115831: POP
// repeat wait ( 0 0$2 ) ;
115832: LD_INT 70
115834: PPUSH
115835: CALL_OW 67
// enemy := mc_scan [ base ] ;
115839: LD_ADDR_VAR 0 21
115843: PUSH
115844: LD_EXP 84
115848: PUSH
115849: LD_VAR 0 1
115853: ARRAY
115854: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115855: LD_EXP 61
115859: PUSH
115860: LD_VAR 0 1
115864: ARRAY
115865: NOT
115866: PUSH
115867: LD_EXP 61
115871: PUSH
115872: LD_VAR 0 1
115876: ARRAY
115877: PUSH
115878: EMPTY
115879: EQUAL
115880: OR
115881: IFFALSE 115918
// begin for i in defenders do
115883: LD_ADDR_VAR 0 4
115887: PUSH
115888: LD_VAR 0 2
115892: PUSH
115893: FOR_IN
115894: IFFALSE 115907
// ComStop ( i ) ;
115896: LD_VAR 0 4
115900: PPUSH
115901: CALL_OW 141
115905: GO 115893
115907: POP
115908: POP
// defenders := [ ] ;
115909: LD_ADDR_VAR 0 2
115913: PUSH
115914: EMPTY
115915: ST_TO_ADDR
// exit ;
115916: GO 117367
// end ; for i in defenders do
115918: LD_ADDR_VAR 0 4
115922: PUSH
115923: LD_VAR 0 2
115927: PUSH
115928: FOR_IN
115929: IFFALSE 116827
// begin e := NearestUnitToUnit ( enemy , i ) ;
115931: LD_ADDR_VAR 0 13
115935: PUSH
115936: LD_VAR 0 21
115940: PPUSH
115941: LD_VAR 0 4
115945: PPUSH
115946: CALL_OW 74
115950: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115951: LD_ADDR_VAR 0 7
115955: PUSH
115956: LD_EXP 61
115960: PUSH
115961: LD_VAR 0 1
115965: ARRAY
115966: PPUSH
115967: LD_INT 2
115969: PUSH
115970: LD_INT 30
115972: PUSH
115973: LD_INT 0
115975: PUSH
115976: EMPTY
115977: LIST
115978: LIST
115979: PUSH
115980: LD_INT 30
115982: PUSH
115983: LD_INT 1
115985: PUSH
115986: EMPTY
115987: LIST
115988: LIST
115989: PUSH
115990: EMPTY
115991: LIST
115992: LIST
115993: LIST
115994: PPUSH
115995: CALL_OW 72
115999: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
116000: LD_ADDR_VAR 0 16
116004: PUSH
116005: LD_VAR 0 7
116009: NOT
116010: PUSH
116011: LD_VAR 0 7
116015: PPUSH
116016: LD_INT 3
116018: PUSH
116019: LD_INT 24
116021: PUSH
116022: LD_INT 600
116024: PUSH
116025: EMPTY
116026: LIST
116027: LIST
116028: PUSH
116029: EMPTY
116030: LIST
116031: LIST
116032: PPUSH
116033: CALL_OW 72
116037: OR
116038: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
116039: LD_VAR 0 4
116043: PPUSH
116044: CALL_OW 247
116048: PUSH
116049: LD_INT 2
116051: DOUBLE
116052: EQUAL
116053: IFTRUE 116057
116055: GO 116453
116057: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
116058: LD_VAR 0 4
116062: PPUSH
116063: CALL_OW 256
116067: PUSH
116068: LD_INT 1000
116070: EQUAL
116071: PUSH
116072: LD_VAR 0 4
116076: PPUSH
116077: LD_VAR 0 13
116081: PPUSH
116082: CALL_OW 296
116086: PUSH
116087: LD_INT 40
116089: LESS
116090: PUSH
116091: LD_VAR 0 13
116095: PPUSH
116096: LD_EXP 86
116100: PUSH
116101: LD_VAR 0 1
116105: ARRAY
116106: PPUSH
116107: CALL_OW 308
116111: OR
116112: AND
116113: IFFALSE 116235
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
116115: LD_VAR 0 4
116119: PPUSH
116120: CALL_OW 262
116124: PUSH
116125: LD_INT 1
116127: EQUAL
116128: PUSH
116129: LD_VAR 0 4
116133: PPUSH
116134: CALL_OW 261
116138: PUSH
116139: LD_INT 30
116141: LESS
116142: AND
116143: PUSH
116144: LD_VAR 0 7
116148: AND
116149: IFFALSE 116219
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
116151: LD_VAR 0 4
116155: PPUSH
116156: LD_VAR 0 7
116160: PPUSH
116161: LD_VAR 0 4
116165: PPUSH
116166: CALL_OW 74
116170: PPUSH
116171: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
116175: LD_VAR 0 4
116179: PPUSH
116180: LD_VAR 0 7
116184: PPUSH
116185: LD_VAR 0 4
116189: PPUSH
116190: CALL_OW 74
116194: PPUSH
116195: CALL_OW 296
116199: PUSH
116200: LD_INT 6
116202: LESS
116203: IFFALSE 116217
// SetFuel ( i , 100 ) ;
116205: LD_VAR 0 4
116209: PPUSH
116210: LD_INT 100
116212: PPUSH
116213: CALL_OW 240
// end else
116217: GO 116233
// ComAttackUnit ( i , e ) ;
116219: LD_VAR 0 4
116223: PPUSH
116224: LD_VAR 0 13
116228: PPUSH
116229: CALL_OW 115
// end else
116233: GO 116336
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
116235: LD_VAR 0 13
116239: PPUSH
116240: LD_EXP 86
116244: PUSH
116245: LD_VAR 0 1
116249: ARRAY
116250: PPUSH
116251: CALL_OW 308
116255: NOT
116256: PUSH
116257: LD_VAR 0 4
116261: PPUSH
116262: LD_VAR 0 13
116266: PPUSH
116267: CALL_OW 296
116271: PUSH
116272: LD_INT 40
116274: GREATEREQUAL
116275: AND
116276: PUSH
116277: LD_VAR 0 4
116281: PPUSH
116282: CALL_OW 256
116286: PUSH
116287: LD_INT 650
116289: LESSEQUAL
116290: OR
116291: PUSH
116292: LD_VAR 0 4
116296: PPUSH
116297: LD_EXP 85
116301: PUSH
116302: LD_VAR 0 1
116306: ARRAY
116307: PPUSH
116308: CALL_OW 308
116312: NOT
116313: AND
116314: IFFALSE 116336
// ComMoveToArea ( i , mc_parking [ base ] ) ;
116316: LD_VAR 0 4
116320: PPUSH
116321: LD_EXP 85
116325: PUSH
116326: LD_VAR 0 1
116330: ARRAY
116331: PPUSH
116332: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
116336: LD_VAR 0 4
116340: PPUSH
116341: CALL_OW 256
116345: PUSH
116346: LD_INT 1000
116348: LESS
116349: PUSH
116350: LD_VAR 0 4
116354: PPUSH
116355: CALL_OW 263
116359: PUSH
116360: LD_INT 1
116362: EQUAL
116363: AND
116364: PUSH
116365: LD_VAR 0 4
116369: PPUSH
116370: CALL_OW 311
116374: AND
116375: PUSH
116376: LD_VAR 0 4
116380: PPUSH
116381: LD_EXP 85
116385: PUSH
116386: LD_VAR 0 1
116390: ARRAY
116391: PPUSH
116392: CALL_OW 308
116396: AND
116397: IFFALSE 116451
// begin mech := IsDrivenBy ( i ) ;
116399: LD_ADDR_VAR 0 9
116403: PUSH
116404: LD_VAR 0 4
116408: PPUSH
116409: CALL_OW 311
116413: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
116414: LD_VAR 0 9
116418: PPUSH
116419: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
116423: LD_VAR 0 9
116427: PPUSH
116428: LD_VAR 0 4
116432: PPUSH
116433: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
116437: LD_VAR 0 9
116441: PPUSH
116442: LD_VAR 0 4
116446: PPUSH
116447: CALL_OW 180
// end ; end ; unit_human :
116451: GO 116798
116453: LD_INT 1
116455: DOUBLE
116456: EQUAL
116457: IFTRUE 116461
116459: GO 116797
116461: POP
// begin b := IsInUnit ( i ) ;
116462: LD_ADDR_VAR 0 18
116466: PUSH
116467: LD_VAR 0 4
116471: PPUSH
116472: CALL_OW 310
116476: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
116477: LD_ADDR_VAR 0 19
116481: PUSH
116482: LD_VAR 0 18
116486: NOT
116487: PUSH
116488: LD_VAR 0 18
116492: PPUSH
116493: CALL_OW 266
116497: PUSH
116498: LD_INT 32
116500: PUSH
116501: LD_INT 31
116503: PUSH
116504: EMPTY
116505: LIST
116506: LIST
116507: IN
116508: OR
116509: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
116510: LD_VAR 0 18
116514: PPUSH
116515: CALL_OW 266
116519: PUSH
116520: LD_INT 5
116522: EQUAL
116523: PUSH
116524: LD_VAR 0 4
116528: PPUSH
116529: CALL_OW 257
116533: PUSH
116534: LD_INT 1
116536: PUSH
116537: LD_INT 2
116539: PUSH
116540: LD_INT 3
116542: PUSH
116543: LD_INT 4
116545: PUSH
116546: EMPTY
116547: LIST
116548: LIST
116549: LIST
116550: LIST
116551: IN
116552: AND
116553: IFFALSE 116590
// begin class := AllowSpecClass ( i ) ;
116555: LD_ADDR_VAR 0 20
116559: PUSH
116560: LD_VAR 0 4
116564: PPUSH
116565: CALL 18221 0 1
116569: ST_TO_ADDR
// if class then
116570: LD_VAR 0 20
116574: IFFALSE 116590
// ComChangeProfession ( i , class ) ;
116576: LD_VAR 0 4
116580: PPUSH
116581: LD_VAR 0 20
116585: PPUSH
116586: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
116590: LD_VAR 0 16
116594: PUSH
116595: LD_VAR 0 2
116599: PPUSH
116600: LD_INT 21
116602: PUSH
116603: LD_INT 2
116605: PUSH
116606: EMPTY
116607: LIST
116608: LIST
116609: PPUSH
116610: CALL_OW 72
116614: PUSH
116615: LD_INT 1
116617: LESSEQUAL
116618: OR
116619: PUSH
116620: LD_VAR 0 19
116624: AND
116625: PUSH
116626: LD_VAR 0 4
116630: PUSH
116631: LD_VAR 0 17
116635: IN
116636: NOT
116637: AND
116638: IFFALSE 116731
// begin if b then
116640: LD_VAR 0 18
116644: IFFALSE 116693
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
116646: LD_VAR 0 18
116650: PPUSH
116651: LD_VAR 0 21
116655: PPUSH
116656: LD_VAR 0 18
116660: PPUSH
116661: CALL_OW 74
116665: PPUSH
116666: CALL_OW 296
116670: PUSH
116671: LD_INT 10
116673: LESS
116674: PUSH
116675: LD_VAR 0 18
116679: PPUSH
116680: CALL_OW 461
116684: PUSH
116685: LD_INT 7
116687: NONEQUAL
116688: AND
116689: IFFALSE 116693
// continue ;
116691: GO 115928
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
116693: LD_ADDR_VAR 0 17
116697: PUSH
116698: LD_VAR 0 17
116702: PPUSH
116703: LD_VAR 0 17
116707: PUSH
116708: LD_INT 1
116710: PLUS
116711: PPUSH
116712: LD_VAR 0 4
116716: PPUSH
116717: CALL_OW 1
116721: ST_TO_ADDR
// ComExitBuilding ( i ) ;
116722: LD_VAR 0 4
116726: PPUSH
116727: CALL_OW 122
// end ; if sold_defenders then
116731: LD_VAR 0 17
116735: IFFALSE 116795
// if i in sold_defenders then
116737: LD_VAR 0 4
116741: PUSH
116742: LD_VAR 0 17
116746: IN
116747: IFFALSE 116795
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
116749: LD_VAR 0 4
116753: PPUSH
116754: CALL_OW 314
116758: NOT
116759: PUSH
116760: LD_VAR 0 4
116764: PPUSH
116765: LD_VAR 0 13
116769: PPUSH
116770: CALL_OW 296
116774: PUSH
116775: LD_INT 30
116777: LESS
116778: AND
116779: IFFALSE 116795
// ComAttackUnit ( i , e ) ;
116781: LD_VAR 0 4
116785: PPUSH
116786: LD_VAR 0 13
116790: PPUSH
116791: CALL_OW 115
// end ; end ; end ;
116795: GO 116798
116797: POP
// if IsDead ( i ) then
116798: LD_VAR 0 4
116802: PPUSH
116803: CALL_OW 301
116807: IFFALSE 116825
// defenders := defenders diff i ;
116809: LD_ADDR_VAR 0 2
116813: PUSH
116814: LD_VAR 0 2
116818: PUSH
116819: LD_VAR 0 4
116823: DIFF
116824: ST_TO_ADDR
// end ;
116825: GO 115928
116827: POP
116828: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
116829: LD_VAR 0 21
116833: NOT
116834: PUSH
116835: LD_VAR 0 2
116839: NOT
116840: OR
116841: PUSH
116842: LD_EXP 61
116846: PUSH
116847: LD_VAR 0 1
116851: ARRAY
116852: NOT
116853: OR
116854: IFFALSE 115832
// MC_Reset ( base , 18 ) ;
116856: LD_VAR 0 1
116860: PPUSH
116861: LD_INT 18
116863: PPUSH
116864: CALL 62836 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116868: LD_ADDR_VAR 0 2
116872: PUSH
116873: LD_VAR 0 2
116877: PUSH
116878: LD_VAR 0 2
116882: PPUSH
116883: LD_INT 2
116885: PUSH
116886: LD_INT 25
116888: PUSH
116889: LD_INT 1
116891: PUSH
116892: EMPTY
116893: LIST
116894: LIST
116895: PUSH
116896: LD_INT 25
116898: PUSH
116899: LD_INT 5
116901: PUSH
116902: EMPTY
116903: LIST
116904: LIST
116905: PUSH
116906: LD_INT 25
116908: PUSH
116909: LD_INT 8
116911: PUSH
116912: EMPTY
116913: LIST
116914: LIST
116915: PUSH
116916: LD_INT 25
116918: PUSH
116919: LD_INT 9
116921: PUSH
116922: EMPTY
116923: LIST
116924: LIST
116925: PUSH
116926: EMPTY
116927: LIST
116928: LIST
116929: LIST
116930: LIST
116931: LIST
116932: PPUSH
116933: CALL_OW 72
116937: DIFF
116938: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
116939: LD_VAR 0 21
116943: NOT
116944: PUSH
116945: LD_VAR 0 2
116949: PPUSH
116950: LD_INT 21
116952: PUSH
116953: LD_INT 2
116955: PUSH
116956: EMPTY
116957: LIST
116958: LIST
116959: PPUSH
116960: CALL_OW 72
116964: AND
116965: IFFALSE 117303
// begin tmp := FilterByTag ( defenders , 19 ) ;
116967: LD_ADDR_VAR 0 11
116971: PUSH
116972: LD_VAR 0 2
116976: PPUSH
116977: LD_INT 19
116979: PPUSH
116980: CALL 51706 0 2
116984: ST_TO_ADDR
// if tmp then
116985: LD_VAR 0 11
116989: IFFALSE 117059
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
116991: LD_ADDR_VAR 0 11
116995: PUSH
116996: LD_VAR 0 11
117000: PPUSH
117001: LD_INT 25
117003: PUSH
117004: LD_INT 3
117006: PUSH
117007: EMPTY
117008: LIST
117009: LIST
117010: PPUSH
117011: CALL_OW 72
117015: ST_TO_ADDR
// if tmp then
117016: LD_VAR 0 11
117020: IFFALSE 117059
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
117022: LD_ADDR_EXP 73
117026: PUSH
117027: LD_EXP 73
117031: PPUSH
117032: LD_VAR 0 1
117036: PPUSH
117037: LD_EXP 73
117041: PUSH
117042: LD_VAR 0 1
117046: ARRAY
117047: PUSH
117048: LD_VAR 0 11
117052: UNION
117053: PPUSH
117054: CALL_OW 1
117058: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
117059: LD_VAR 0 1
117063: PPUSH
117064: LD_INT 19
117066: PPUSH
117067: CALL 62836 0 2
// repeat wait ( 0 0$1 ) ;
117071: LD_INT 35
117073: PPUSH
117074: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117078: LD_EXP 61
117082: PUSH
117083: LD_VAR 0 1
117087: ARRAY
117088: NOT
117089: PUSH
117090: LD_EXP 61
117094: PUSH
117095: LD_VAR 0 1
117099: ARRAY
117100: PUSH
117101: EMPTY
117102: EQUAL
117103: OR
117104: IFFALSE 117141
// begin for i in defenders do
117106: LD_ADDR_VAR 0 4
117110: PUSH
117111: LD_VAR 0 2
117115: PUSH
117116: FOR_IN
117117: IFFALSE 117130
// ComStop ( i ) ;
117119: LD_VAR 0 4
117123: PPUSH
117124: CALL_OW 141
117128: GO 117116
117130: POP
117131: POP
// defenders := [ ] ;
117132: LD_ADDR_VAR 0 2
117136: PUSH
117137: EMPTY
117138: ST_TO_ADDR
// exit ;
117139: GO 117367
// end ; for i in defenders do
117141: LD_ADDR_VAR 0 4
117145: PUSH
117146: LD_VAR 0 2
117150: PUSH
117151: FOR_IN
117152: IFFALSE 117241
// begin if not IsInArea ( i , mc_parking [ base ] ) then
117154: LD_VAR 0 4
117158: PPUSH
117159: LD_EXP 85
117163: PUSH
117164: LD_VAR 0 1
117168: ARRAY
117169: PPUSH
117170: CALL_OW 308
117174: NOT
117175: IFFALSE 117199
// ComMoveToArea ( i , mc_parking [ base ] ) else
117177: LD_VAR 0 4
117181: PPUSH
117182: LD_EXP 85
117186: PUSH
117187: LD_VAR 0 1
117191: ARRAY
117192: PPUSH
117193: CALL_OW 113
117197: GO 117239
// if GetControl ( i ) = control_manual then
117199: LD_VAR 0 4
117203: PPUSH
117204: CALL_OW 263
117208: PUSH
117209: LD_INT 1
117211: EQUAL
117212: IFFALSE 117239
// if IsDrivenBy ( i ) then
117214: LD_VAR 0 4
117218: PPUSH
117219: CALL_OW 311
117223: IFFALSE 117239
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
117225: LD_VAR 0 4
117229: PPUSH
117230: CALL_OW 311
117234: PPUSH
117235: CALL_OW 121
// end ;
117239: GO 117151
117241: POP
117242: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
117243: LD_VAR 0 2
117247: PPUSH
117248: LD_INT 95
117250: PUSH
117251: LD_EXP 85
117255: PUSH
117256: LD_VAR 0 1
117260: ARRAY
117261: PUSH
117262: EMPTY
117263: LIST
117264: LIST
117265: PPUSH
117266: CALL_OW 72
117270: PUSH
117271: LD_VAR 0 2
117275: EQUAL
117276: PUSH
117277: LD_EXP 84
117281: PUSH
117282: LD_VAR 0 1
117286: ARRAY
117287: OR
117288: PUSH
117289: LD_EXP 61
117293: PUSH
117294: LD_VAR 0 1
117298: ARRAY
117299: NOT
117300: OR
117301: IFFALSE 117071
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
117303: LD_ADDR_EXP 83
117307: PUSH
117308: LD_EXP 83
117312: PPUSH
117313: LD_VAR 0 1
117317: PPUSH
117318: LD_VAR 0 2
117322: PPUSH
117323: LD_INT 21
117325: PUSH
117326: LD_INT 2
117328: PUSH
117329: EMPTY
117330: LIST
117331: LIST
117332: PPUSH
117333: CALL_OW 72
117337: PPUSH
117338: CALL_OW 1
117342: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
117343: LD_VAR 0 1
117347: PPUSH
117348: LD_INT 19
117350: PPUSH
117351: CALL 62836 0 2
// MC_Reset ( base , 20 ) ;
117355: LD_VAR 0 1
117359: PPUSH
117360: LD_INT 20
117362: PPUSH
117363: CALL 62836 0 2
// end ; end_of_file
117367: LD_VAR 0 3
117371: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
117372: LD_VAR 0 1
117376: PUSH
117377: LD_INT 200
117379: DOUBLE
117380: GREATEREQUAL
117381: IFFALSE 117389
117383: LD_INT 299
117385: DOUBLE
117386: LESSEQUAL
117387: IFTRUE 117391
117389: GO 117423
117391: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
117392: LD_VAR 0 1
117396: PPUSH
117397: LD_VAR 0 2
117401: PPUSH
117402: LD_VAR 0 3
117406: PPUSH
117407: LD_VAR 0 4
117411: PPUSH
117412: LD_VAR 0 5
117416: PPUSH
117417: CALL 105553 0 5
117421: GO 117500
117423: LD_INT 300
117425: DOUBLE
117426: GREATEREQUAL
117427: IFFALSE 117435
117429: LD_INT 399
117431: DOUBLE
117432: LESSEQUAL
117433: IFTRUE 117437
117435: GO 117499
117437: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
117438: LD_VAR 0 1
117442: PPUSH
117443: LD_VAR 0 2
117447: PPUSH
117448: LD_VAR 0 3
117452: PPUSH
117453: LD_VAR 0 4
117457: PPUSH
117458: LD_VAR 0 5
117462: PPUSH
117463: LD_VAR 0 6
117467: PPUSH
117468: LD_VAR 0 7
117472: PPUSH
117473: LD_VAR 0 8
117477: PPUSH
117478: LD_VAR 0 9
117482: PPUSH
117483: LD_VAR 0 10
117487: PPUSH
117488: LD_VAR 0 11
117492: PPUSH
117493: CALL 101878 0 11
117497: GO 117500
117499: POP
// end ;
117500: PPOPN 11
117502: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
117503: LD_VAR 0 1
117507: PPUSH
117508: LD_VAR 0 2
117512: PPUSH
117513: LD_VAR 0 3
117517: PPUSH
117518: LD_VAR 0 4
117522: PPUSH
117523: LD_VAR 0 5
117527: PPUSH
117528: CALL 105289 0 5
// end ; end_of_file
117532: PPOPN 5
117534: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
117535: LD_VAR 0 1
117539: PPUSH
117540: LD_VAR 0 2
117544: PPUSH
117545: LD_VAR 0 3
117549: PPUSH
117550: LD_VAR 0 4
117554: PPUSH
117555: LD_VAR 0 5
117559: PPUSH
117560: LD_VAR 0 6
117564: PPUSH
117565: CALL 89530 0 6
// end ;
117569: PPOPN 6
117571: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
117572: LD_INT 0
117574: PPUSH
// begin if not units then
117575: LD_VAR 0 1
117579: NOT
117580: IFFALSE 117584
// exit ;
117582: GO 117584
// end ;
117584: PPOPN 7
117586: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
117587: CALL 89434 0 0
// end ;
117591: PPOPN 1
117593: END
