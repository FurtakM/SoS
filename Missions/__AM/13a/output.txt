// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 619 0 0
// InitMacro ;
  19: CALL 50464 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 46907 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 46907 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 46907 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 46907 0 9
// PrepareArabian ;
 147: CALL 3690 0 0
// PrepareRussian ;
 151: CALL 2825 0 0
// PrepareAlliance ;
 155: CALL 821 0 0
// MC_Start ( ) ;
 159: CALL 52576 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6853 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 83
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 84
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 73793 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 54
 252: PPUSH
 253: CALL 74219 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 74677 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 74946 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 74159 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 74853 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 51
 340: PPUSH
 341: CALL 74219 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 74677 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 74946 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 74003 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 22
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 3
 596: PUSH
 597: LD_INT 52
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL 74159 0 2
// end ;
 614: LD_VAR 0 1
 618: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 619: LD_INT 0
 621: PPUSH
// debug := 0 ;
 622: LD_ADDR_EXP 1
 626: PUSH
 627: LD_INT 0
 629: ST_TO_ADDR
// game := true ;
 630: LD_ADDR_EXP 2
 634: PUSH
 635: LD_INT 1
 637: ST_TO_ADDR
// gossudarov_arrive := false ;
 638: LD_ADDR_EXP 4
 642: PUSH
 643: LD_INT 0
 645: ST_TO_ADDR
// ru_lab_builded := false ;
 646: LD_ADDR_EXP 5
 650: PUSH
 651: LD_INT 0
 653: ST_TO_ADDR
// player_spotted := false ;
 654: LD_ADDR_EXP 6
 658: PUSH
 659: LD_INT 0
 661: ST_TO_ADDR
// first_attack := false ;
 662: LD_ADDR_EXP 7
 666: PUSH
 667: LD_INT 0
 669: ST_TO_ADDR
// ru_attackers := [ ] ;
 670: LD_ADDR_EXP 52
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// ar_base_spotted := false ;
 677: LD_ADDR_EXP 8
 681: PUSH
 682: LD_INT 0
 684: ST_TO_ADDR
// ar_active_attack := false ;
 685: LD_ADDR_EXP 9
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// ar_attackers := [ ] ;
 693: LD_ADDR_EXP 10
 697: PUSH
 698: EMPTY
 699: ST_TO_ADDR
// first_powell_attack := false ;
 700: LD_ADDR_EXP 11
 704: PUSH
 705: LD_INT 0
 707: ST_TO_ADDR
// abdul_escaped := true ;
 708: LD_ADDR_EXP 12
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// loss_counter := 0 ;
 716: LD_ADDR_EXP 13
 720: PUSH
 721: LD_INT 0
 723: ST_TO_ADDR
// hack_counter := 0 ;
 724: LD_ADDR_EXP 14
 728: PUSH
 729: LD_INT 0
 731: ST_TO_ADDR
// end ;
 732: LD_VAR 0 1
 736: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 737: LD_EXP 48
 741: PPUSH
 742: CALL_OW 255
 746: PUSH
 747: LD_INT 7
 749: EQUAL
 750: PUSH
 751: LD_EXP 47
 755: PPUSH
 756: CALL_OW 255
 760: PUSH
 761: LD_INT 7
 763: EQUAL
 764: AND
 765: PUSH
 766: LD_EXP 48
 770: PPUSH
 771: CALL_OW 302
 775: AND
 776: PUSH
 777: LD_EXP 47
 781: PPUSH
 782: CALL_OW 302
 786: AND
 787: IFFALSE 799
 789: GO 791
 791: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 792: LD_STRING ACH_COMRADE
 794: PPUSH
 795: CALL_OW 543
 799: END
// every 0 0$1 trigger hack_counter >= 10 do
 800: LD_EXP 14
 804: PUSH
 805: LD_INT 10
 807: GREATEREQUAL
 808: IFFALSE 820
 810: GO 812
 812: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 813: LD_STRING ACH_HACK
 815: PPUSH
 816: CALL_OW 543
 820: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 821: LD_INT 0
 823: PPUSH
 824: PPUSH
 825: PPUSH
 826: PPUSH
// uc_side := 7 ;
 827: LD_ADDR_OWVAR 20
 831: PUSH
 832: LD_INT 7
 834: ST_TO_ADDR
// uc_nation := 1 ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_INT 1
 842: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 843: LD_ADDR_EXP 15
 847: PUSH
 848: LD_STRING JMM
 850: PPUSH
 851: LD_EXP 1
 855: NOT
 856: PPUSH
 857: LD_STRING 12a_
 859: PPUSH
 860: CALL 14292 0 3
 864: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 865: LD_EXP 15
 869: PPUSH
 870: LD_INT 71
 872: PPUSH
 873: LD_INT 23
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 883: LD_EXP 15
 887: PPUSH
 888: LD_INT 2
 890: PPUSH
 891: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 895: LD_ADDR_EXP 16
 899: PUSH
 900: LD_STRING Roth
 902: PPUSH
 903: LD_EXP 1
 907: NOT
 908: PPUSH
 909: LD_STRING 12a_
 911: PPUSH
 912: CALL 14292 0 3
 916: ST_TO_ADDR
// if Roth then
 917: LD_EXP 16
 921: IFFALSE 941
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 923: LD_EXP 16
 927: PPUSH
 928: LD_INT 71
 930: PPUSH
 931: LD_INT 21
 933: PPUSH
 934: LD_INT 0
 936: PPUSH
 937: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING Lisa
 948: PPUSH
 949: LD_EXP 1
 953: NOT
 954: PPUSH
 955: LD_STRING 12a_
 957: PPUSH
 958: CALL 14292 0 3
 962: ST_TO_ADDR
// if Lisa then
 963: LD_EXP 17
 967: IFFALSE 984
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 969: LD_EXP 17
 973: PPUSH
 974: LD_INT 13
 976: PPUSH
 977: LD_INT 0
 979: PPUSH
 980: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 984: LD_ADDR_EXP 18
 988: PUSH
 989: LD_STRING Donaldson
 991: PPUSH
 992: LD_EXP 1
 996: NOT
 997: PPUSH
 998: LD_STRING 12a_
1000: PPUSH
1001: CALL 14292 0 3
1005: ST_TO_ADDR
// if Donaldson then
1006: LD_EXP 18
1010: IFFALSE 1027
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1012: LD_EXP 18
1016: PPUSH
1017: LD_INT 13
1019: PPUSH
1020: LD_INT 0
1022: PPUSH
1023: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1027: LD_ADDR_EXP 19
1031: PUSH
1032: LD_STRING Bobby
1034: PPUSH
1035: LD_EXP 1
1039: NOT
1040: PPUSH
1041: LD_STRING 12a_
1043: PPUSH
1044: CALL 14292 0 3
1048: ST_TO_ADDR
// if Bobby then
1049: LD_EXP 19
1053: IFFALSE 1070
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1055: LD_EXP 19
1059: PPUSH
1060: LD_INT 13
1062: PPUSH
1063: LD_INT 0
1065: PPUSH
1066: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1070: LD_ADDR_EXP 20
1074: PUSH
1075: LD_STRING Cyrus
1077: PPUSH
1078: LD_EXP 1
1082: NOT
1083: PPUSH
1084: LD_STRING 12a_
1086: PPUSH
1087: CALL 14292 0 3
1091: ST_TO_ADDR
// if Cyrus then
1092: LD_EXP 20
1096: IFFALSE 1113
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1098: LD_EXP 20
1102: PPUSH
1103: LD_INT 13
1105: PPUSH
1106: LD_INT 0
1108: PPUSH
1109: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1113: LD_ADDR_EXP 21
1117: PUSH
1118: LD_STRING Denis
1120: PPUSH
1121: LD_EXP 1
1125: NOT
1126: PPUSH
1127: LD_STRING 12a_
1129: PPUSH
1130: CALL 14292 0 3
1134: ST_TO_ADDR
// if Denis then
1135: LD_EXP 21
1139: IFFALSE 1156
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1141: LD_EXP 21
1145: PPUSH
1146: LD_INT 13
1148: PPUSH
1149: LD_INT 0
1151: PPUSH
1152: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1156: LD_ADDR_EXP 22
1160: PUSH
1161: LD_STRING Brown
1163: PPUSH
1164: LD_EXP 1
1168: NOT
1169: PPUSH
1170: LD_STRING 12a_
1172: PPUSH
1173: CALL 14292 0 3
1177: ST_TO_ADDR
// if Brown then
1178: LD_EXP 22
1182: IFFALSE 1199
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1184: LD_EXP 22
1188: PPUSH
1189: LD_INT 13
1191: PPUSH
1192: LD_INT 0
1194: PPUSH
1195: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1199: LD_ADDR_EXP 23
1203: PUSH
1204: LD_STRING Gladstone
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_STRING 12a_
1215: PPUSH
1216: CALL 14292 0 3
1220: ST_TO_ADDR
// if Gladstone then
1221: LD_EXP 23
1225: IFFALSE 1242
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1227: LD_EXP 23
1231: PPUSH
1232: LD_INT 13
1234: PPUSH
1235: LD_INT 0
1237: PPUSH
1238: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1242: LD_ADDR_EXP 24
1246: PUSH
1247: LD_STRING Houten
1249: PPUSH
1250: LD_EXP 1
1254: NOT
1255: PPUSH
1256: LD_STRING 12a_
1258: PPUSH
1259: CALL 14292 0 3
1263: ST_TO_ADDR
// if Houten then
1264: LD_EXP 24
1268: IFFALSE 1285
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1270: LD_EXP 24
1274: PPUSH
1275: LD_INT 13
1277: PPUSH
1278: LD_INT 0
1280: PPUSH
1281: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1285: LD_ADDR_EXP 25
1289: PUSH
1290: LD_STRING Cornell
1292: PPUSH
1293: LD_EXP 1
1297: NOT
1298: PPUSH
1299: LD_STRING 12a_
1301: PPUSH
1302: CALL 14292 0 3
1306: ST_TO_ADDR
// if Cornel then
1307: LD_EXP 25
1311: IFFALSE 1328
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1313: LD_EXP 25
1317: PPUSH
1318: LD_INT 13
1320: PPUSH
1321: LD_INT 0
1323: PPUSH
1324: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1328: LD_ADDR_EXP 26
1332: PUSH
1333: LD_STRING Gary
1335: PPUSH
1336: LD_EXP 1
1340: NOT
1341: PPUSH
1342: LD_STRING 12a_
1344: PPUSH
1345: CALL 14292 0 3
1349: ST_TO_ADDR
// if Gary then
1350: LD_EXP 26
1354: IFFALSE 1371
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1356: LD_EXP 26
1360: PPUSH
1361: LD_INT 13
1363: PPUSH
1364: LD_INT 0
1366: PPUSH
1367: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1371: LD_ADDR_EXP 27
1375: PUSH
1376: LD_STRING Frank
1378: PPUSH
1379: LD_EXP 1
1383: NOT
1384: PPUSH
1385: LD_STRING 12a_
1387: PPUSH
1388: CALL 14292 0 3
1392: ST_TO_ADDR
// if Frank then
1393: LD_EXP 27
1397: IFFALSE 1414
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1399: LD_EXP 27
1403: PPUSH
1404: LD_INT 13
1406: PPUSH
1407: LD_INT 0
1409: PPUSH
1410: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1414: LD_ADDR_EXP 28
1418: PUSH
1419: LD_STRING Kikuchi
1421: PPUSH
1422: LD_EXP 1
1426: NOT
1427: PPUSH
1428: LD_STRING 12a_
1430: PPUSH
1431: CALL 14292 0 3
1435: ST_TO_ADDR
// if Kikuchi then
1436: LD_EXP 28
1440: IFFALSE 1457
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1442: LD_EXP 28
1446: PPUSH
1447: LD_INT 13
1449: PPUSH
1450: LD_INT 0
1452: PPUSH
1453: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1457: LD_ADDR_EXP 29
1461: PUSH
1462: LD_STRING Simms
1464: PPUSH
1465: LD_EXP 1
1469: NOT
1470: PPUSH
1471: LD_STRING 12a_
1473: PPUSH
1474: CALL 14292 0 3
1478: ST_TO_ADDR
// if Simms then
1479: LD_EXP 29
1483: IFFALSE 1500
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1485: LD_EXP 29
1489: PPUSH
1490: LD_INT 13
1492: PPUSH
1493: LD_INT 0
1495: PPUSH
1496: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1500: LD_ADDR_EXP 30
1504: PUSH
1505: LD_STRING Joan
1507: PPUSH
1508: LD_EXP 1
1512: NOT
1513: PPUSH
1514: LD_STRING 12a_
1516: PPUSH
1517: CALL 14292 0 3
1521: ST_TO_ADDR
// if Joan then
1522: LD_EXP 30
1526: IFFALSE 1543
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1528: LD_EXP 30
1532: PPUSH
1533: LD_INT 13
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1543: LD_ADDR_EXP 31
1547: PUSH
1548: LD_STRING DeltaDoctor
1550: PPUSH
1551: LD_EXP 1
1555: NOT
1556: PPUSH
1557: LD_STRING 12a_
1559: PPUSH
1560: CALL 14292 0 3
1564: ST_TO_ADDR
// if DeltaDoctor then
1565: LD_EXP 31
1569: IFFALSE 1586
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1571: LD_EXP 31
1575: PPUSH
1576: LD_INT 13
1578: PPUSH
1579: LD_INT 0
1581: PPUSH
1582: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1586: LD_ADDR_VAR 0 4
1590: PUSH
1591: LD_STRING 12a_others
1593: PPUSH
1594: CALL_OW 31
1598: ST_TO_ADDR
// if tmp then
1599: LD_VAR 0 4
1603: IFFALSE 1637
// for i in tmp do
1605: LD_ADDR_VAR 0 3
1609: PUSH
1610: LD_VAR 0 4
1614: PUSH
1615: FOR_IN
1616: IFFALSE 1635
// PlaceUnitArea ( i , alliance_start , false ) ;
1618: LD_VAR 0 3
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
1633: GO 1615
1635: POP
1636: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 3
1642: PPUSH
1643: LD_INT 3
1645: PPUSH
1646: LD_INT 12
1648: PPUSH
1649: LD_INT 100
1651: PPUSH
1652: CALL 19116 0 5
// veh := CreateVehicle ;
1656: LD_ADDR_VAR 0 2
1660: PUSH
1661: CALL_OW 45
1665: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1666: LD_VAR 0 2
1670: PPUSH
1671: LD_INT 2
1673: PPUSH
1674: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1678: LD_VAR 0 2
1682: PPUSH
1683: LD_INT 60
1685: PPUSH
1686: LD_INT 6
1688: PPUSH
1689: LD_INT 0
1691: PPUSH
1692: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1696: LD_VAR 0 2
1700: PPUSH
1701: LD_INT 4
1703: PPUSH
1704: LD_INT 30
1706: PPUSH
1707: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1711: LD_STRING 11_artifact_captured
1713: PPUSH
1714: LD_INT 0
1716: PPUSH
1717: CALL_OW 30
1721: IFFALSE 1797
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1723: LD_INT 3
1725: PPUSH
1726: LD_INT 3
1728: PPUSH
1729: LD_INT 3
1731: PPUSH
1732: LD_INT 12
1734: PPUSH
1735: LD_INT 100
1737: PPUSH
1738: CALL 19116 0 5
// veh := CreateVehicle ;
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: CALL_OW 45
1751: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1752: LD_VAR 0 2
1756: PPUSH
1757: LD_INT 3
1759: PPUSH
1760: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1764: LD_VAR 0 2
1768: PPUSH
1769: LD_INT 75
1771: PPUSH
1772: LD_INT 6
1774: PPUSH
1775: LD_INT 0
1777: PPUSH
1778: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1782: LD_VAR 0 2
1786: PPUSH
1787: LD_INT 4
1789: PPUSH
1790: LD_INT 50
1792: PPUSH
1793: CALL_OW 290
// end ; end ;
1797: LD_VAR 0 1
1801: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1802: LD_INT 0
1804: PPUSH
1805: PPUSH
1806: PPUSH
1807: PPUSH
// uc_side := 6 ;
1808: LD_ADDR_OWVAR 20
1812: PUSH
1813: LD_INT 6
1815: ST_TO_ADDR
// uc_nation := 3 ;
1816: LD_ADDR_OWVAR 21
1820: PUSH
1821: LD_INT 3
1823: ST_TO_ADDR
// InitHc ;
1824: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1828: LD_ADDR_EXP 32
1832: PUSH
1833: LD_STRING Gossudarov
1835: PPUSH
1836: CALL_OW 25
1840: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1841: LD_ADDR_EXP 33
1845: PUSH
1846: LD_STRING Kirilenkova
1848: PPUSH
1849: CALL_OW 25
1853: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1854: LD_ADDR_EXP 34
1858: PUSH
1859: LD_STRING Titov
1861: PPUSH
1862: CALL_OW 25
1866: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1867: LD_ADDR_EXP 39
1871: PUSH
1872: LD_STRING Oblukov
1874: PPUSH
1875: CALL_OW 25
1879: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1880: LD_ADDR_EXP 36
1884: PUSH
1885: LD_STRING Dolgov
1887: PPUSH
1888: CALL_OW 25
1892: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1893: LD_ADDR_EXP 37
1897: PUSH
1898: LD_STRING Petrosyan
1900: PPUSH
1901: CALL_OW 25
1905: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1906: LD_ADDR_EXP 38
1910: PUSH
1911: LD_STRING Scholtze
1913: PPUSH
1914: CALL_OW 25
1918: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1919: LD_ADDR_EXP 40
1923: PUSH
1924: LD_STRING Kapitsova
1926: PPUSH
1927: CALL_OW 25
1931: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1932: LD_ADDR_VAR 0 2
1936: PUSH
1937: LD_EXP 32
1941: PUSH
1942: LD_EXP 33
1946: PUSH
1947: LD_EXP 34
1951: PUSH
1952: LD_EXP 39
1956: PUSH
1957: LD_EXP 36
1961: PUSH
1962: LD_EXP 37
1966: PUSH
1967: LD_EXP 38
1971: PUSH
1972: LD_EXP 40
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: LIST
1986: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1987: LD_INT 1
1989: PPUSH
1990: LD_INT 4
1992: PPUSH
1993: LD_INT 8
1995: PPUSH
1996: CALL_OW 380
// un := CreateHuman ;
2000: LD_ADDR_VAR 0 4
2004: PUSH
2005: CALL_OW 44
2009: ST_TO_ADDR
// tmp := tmp ^ un ;
2010: LD_ADDR_VAR 0 2
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_VAR 0 4
2024: ADD
2025: ST_TO_ADDR
// for i in tmp do
2026: LD_ADDR_VAR 0 3
2030: PUSH
2031: LD_VAR 0 2
2035: PUSH
2036: FOR_IN
2037: IFFALSE 2056
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2039: LD_VAR 0 3
2043: PPUSH
2044: LD_INT 14
2046: PPUSH
2047: LD_INT 0
2049: PPUSH
2050: CALL_OW 49
2054: GO 2036
2056: POP
2057: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_EXP 3
2067: PPUSH
2068: CALL_OW 250
2072: PPUSH
2073: LD_EXP 3
2077: PPUSH
2078: CALL_OW 251
2082: PPUSH
2083: CALL_OW 111
// end ;
2087: LD_VAR 0 1
2091: RET
// export function PrepareBelkov ; begin
2092: LD_INT 0
2094: PPUSH
// uc_side := 4 ;
2095: LD_ADDR_OWVAR 20
2099: PUSH
2100: LD_INT 4
2102: ST_TO_ADDR
// uc_nation := 3 ;
2103: LD_ADDR_OWVAR 21
2107: PUSH
2108: LD_INT 3
2110: ST_TO_ADDR
// InitHc ;
2111: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2115: LD_ADDR_EXP 47
2119: PUSH
2120: LD_STRING Belkov
2122: PPUSH
2123: CALL_OW 25
2127: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2128: LD_EXP 47
2132: PPUSH
2133: LD_INT 14
2135: PPUSH
2136: LD_INT 0
2138: PPUSH
2139: CALL_OW 49
// end ;
2143: LD_VAR 0 1
2147: RET
// export function PrepareGnyevko ; begin
2148: LD_INT 0
2150: PPUSH
// uc_side := 4 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 4
2158: ST_TO_ADDR
// uc_nation := 3 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 3
2166: ST_TO_ADDR
// InitHc ;
2167: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2171: LD_ADDR_EXP 48
2175: PUSH
2176: LD_STRING Gnyevko
2178: PPUSH
2179: CALL_OW 25
2183: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2184: LD_EXP 48
2188: PPUSH
2189: LD_INT 14
2191: PPUSH
2192: LD_INT 0
2194: PPUSH
2195: CALL_OW 49
// end ;
2199: LD_VAR 0 1
2203: RET
// export function PrepareBurlak ; var i , tmp ; begin
2204: LD_INT 0
2206: PPUSH
2207: PPUSH
2208: PPUSH
// uc_side := 4 ;
2209: LD_ADDR_OWVAR 20
2213: PUSH
2214: LD_INT 4
2216: ST_TO_ADDR
// uc_nation := 3 ;
2217: LD_ADDR_OWVAR 21
2221: PUSH
2222: LD_INT 3
2224: ST_TO_ADDR
// InitHc ;
2225: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2229: LD_ADDR_EXP 46
2233: PUSH
2234: LD_STRING Burlak
2236: PPUSH
2237: CALL_OW 25
2241: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2242: LD_INT 24
2244: PUSH
2245: LD_INT 23
2247: PUSH
2248: LD_INT 22
2250: PUSH
2251: EMPTY
2252: LIST
2253: LIST
2254: LIST
2255: PUSH
2256: LD_OWVAR 67
2260: ARRAY
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: LD_INT 1
2267: PPUSH
2268: LD_INT 45
2270: PUSH
2271: LD_INT 44
2273: PUSH
2274: LD_INT 43
2276: PUSH
2277: EMPTY
2278: LIST
2279: LIST
2280: LIST
2281: PUSH
2282: LD_OWVAR 67
2286: ARRAY
2287: PPUSH
2288: LD_INT 0
2290: PPUSH
2291: CALL 19116 0 5
// Masha := CreateVehicle ;
2295: LD_ADDR_EXP 49
2299: PUSH
2300: CALL_OW 45
2304: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2305: LD_EXP 49
2309: PUSH
2310: LD_EXP 46
2314: PUSH
2315: EMPTY
2316: LIST
2317: LIST
2318: PPUSH
2319: LD_INT 499
2321: PPUSH
2322: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2326: LD_EXP 49
2330: PPUSH
2331: LD_INT 3
2333: PPUSH
2334: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2338: LD_EXP 49
2342: PPUSH
2343: LD_INT 1
2345: PPUSH
2346: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2350: LD_INT 1
2352: PPUSH
2353: LD_INT 18
2355: PPUSH
2356: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2360: LD_INT 35
2362: PPUSH
2363: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 18
2374: PPUSH
2375: EMPTY
2376: PPUSH
2377: CALL_OW 70
2381: ST_TO_ADDR
// if tmp then
2382: LD_VAR 0 3
2386: IFFALSE 2420
// for i in tmp do
2388: LD_ADDR_VAR 0 2
2392: PUSH
2393: LD_VAR 0 3
2397: PUSH
2398: FOR_IN
2399: IFFALSE 2418
// ComMoveXY ( i , 114 , 9 ) ;
2401: LD_VAR 0 2
2405: PPUSH
2406: LD_INT 114
2408: PPUSH
2409: LD_INT 9
2411: PPUSH
2412: CALL_OW 111
2416: GO 2398
2418: POP
2419: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2420: LD_INT 18
2422: PPUSH
2423: EMPTY
2424: PPUSH
2425: CALL_OW 70
2429: NOT
2430: PUSH
2431: LD_INT 123
2433: PPUSH
2434: LD_INT 3
2436: PPUSH
2437: CALL_OW 428
2441: PUSH
2442: LD_INT 0
2444: EQUAL
2445: AND
2446: IFFALSE 2360
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2448: LD_EXP 49
2452: PPUSH
2453: LD_INT 123
2455: PPUSH
2456: LD_INT 3
2458: PPUSH
2459: LD_INT 0
2461: PPUSH
2462: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2466: LD_EXP 46
2470: PPUSH
2471: LD_INT 125
2473: PPUSH
2474: LD_INT 1
2476: PPUSH
2477: LD_INT 0
2479: PPUSH
2480: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2484: LD_EXP 46
2488: PPUSH
2489: LD_EXP 49
2493: PPUSH
2494: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2498: LD_INT 10
2500: PPUSH
2501: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2505: LD_EXP 49
2509: PPUSH
2510: LD_INT 110
2512: PPUSH
2513: LD_INT 10
2515: PPUSH
2516: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2520: LD_ADDR_EXP 42
2524: PUSH
2525: LD_STRING Petrovova
2527: PPUSH
2528: CALL_OW 25
2532: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2533: LD_ADDR_EXP 44
2537: PUSH
2538: LD_STRING Kuzmov
2540: PPUSH
2541: CALL_OW 25
2545: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2546: LD_ADDR_EXP 43
2550: PUSH
2551: LD_STRING Kovalyuk
2553: PPUSH
2554: CALL_OW 25
2558: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2559: LD_ADDR_EXP 41
2563: PUSH
2564: LD_STRING Lipshchin
2566: PPUSH
2567: CALL_OW 25
2571: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2572: LD_ADDR_EXP 45
2576: PUSH
2577: LD_STRING Karamazov
2579: PPUSH
2580: CALL_OW 25
2584: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2585: LD_ADDR_VAR 0 3
2589: PUSH
2590: LD_EXP 42
2594: PUSH
2595: LD_EXP 44
2599: PUSH
2600: LD_EXP 43
2604: PUSH
2605: LD_EXP 41
2609: PUSH
2610: LD_EXP 45
2614: PUSH
2615: EMPTY
2616: LIST
2617: LIST
2618: LIST
2619: LIST
2620: LIST
2621: ST_TO_ADDR
// for i in tmp do
2622: LD_ADDR_VAR 0 2
2626: PUSH
2627: LD_VAR 0 3
2631: PUSH
2632: FOR_IN
2633: IFFALSE 2672
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2635: LD_VAR 0 2
2639: PPUSH
2640: LD_INT 399
2642: PPUSH
2643: LD_INT 799
2645: PPUSH
2646: CALL_OW 12
2650: PPUSH
2651: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2655: LD_VAR 0 2
2659: PPUSH
2660: LD_INT 19
2662: PPUSH
2663: LD_INT 0
2665: PPUSH
2666: CALL_OW 49
// end ;
2670: GO 2632
2672: POP
2673: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2674: LD_VAR 0 3
2678: PPUSH
2679: LD_INT 116
2681: PPUSH
2682: LD_INT 8
2684: PPUSH
2685: CALL_OW 111
// AddComHold ( tmp ) ;
2689: LD_VAR 0 3
2693: PPUSH
2694: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2698: LD_ADDR_VAR 0 2
2702: PUSH
2703: LD_VAR 0 3
2707: PPUSH
2708: LD_INT 25
2710: PUSH
2711: LD_INT 1
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PPUSH
2718: CALL_OW 72
2722: PUSH
2723: FOR_IN
2724: IFFALSE 2764
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2726: LD_VAR 0 2
2730: PPUSH
2731: LD_INT 20
2733: PPUSH
2734: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2738: LD_VAR 0 2
2742: PPUSH
2743: LD_INT 147
2745: PPUSH
2746: LD_INT 45
2748: PPUSH
2749: CALL_OW 178
// AddComCrawl ( i ) ;
2753: LD_VAR 0 2
2757: PPUSH
2758: CALL_OW 197
// end ;
2762: GO 2723
2764: POP
2765: POP
// repeat wait ( 0 0$1 ) ;
2766: LD_INT 35
2768: PPUSH
2769: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2773: LD_EXP 49
2777: PPUSH
2778: LD_INT 110
2780: PPUSH
2781: LD_INT 10
2783: PPUSH
2784: CALL_OW 307
2788: PUSH
2789: LD_EXP 49
2793: PPUSH
2794: CALL_OW 305
2798: NOT
2799: OR
2800: IFFALSE 2766
// ComStop ( Burlak ) ;
2802: LD_EXP 46
2806: PPUSH
2807: CALL_OW 141
// AddComHold ( Burlak ) ;
2811: LD_EXP 46
2815: PPUSH
2816: CALL_OW 200
// end ; end_of_file
2820: LD_VAR 0 1
2824: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2825: LD_INT 0
2827: PPUSH
2828: PPUSH
2829: PPUSH
2830: PPUSH
// uc_side := 3 ;
2831: LD_ADDR_OWVAR 20
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// uc_nation := 3 ;
2839: LD_ADDR_OWVAR 21
2843: PUSH
2844: LD_INT 3
2846: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2847: LD_ADDR_EXP 50
2851: PUSH
2852: LD_INT 47
2854: PPUSH
2855: LD_INT 4
2857: PPUSH
2858: LD_STRING 
2860: PPUSH
2861: LD_INT 7
2863: PUSH
2864: LD_INT 8
2866: PUSH
2867: LD_INT 9
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: LIST
2874: PUSH
2875: LD_OWVAR 67
2879: ARRAY
2880: PPUSH
2881: LD_INT 10000
2883: PUSH
2884: LD_INT 3000
2886: PUSH
2887: LD_INT 300
2889: PUSH
2890: EMPTY
2891: LIST
2892: LIST
2893: LIST
2894: PPUSH
2895: LD_INT 9
2897: PUSH
2898: LD_INT 5
2900: PUSH
2901: LD_INT 6
2903: PUSH
2904: LD_INT 6
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: PPUSH
2913: CALL 22525 0 6
2917: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2918: LD_ADDR_EXP 59
2922: PUSH
2923: LD_EXP 59
2927: PPUSH
2928: LD_INT 2
2930: PPUSH
2931: LD_EXP 50
2935: PPUSH
2936: CALL_OW 1
2940: ST_TO_ADDR
// tmp := [ ] ;
2941: LD_ADDR_VAR 0 4
2945: PUSH
2946: EMPTY
2947: ST_TO_ADDR
// for i = 1 to 4 do
2948: LD_ADDR_VAR 0 2
2952: PUSH
2953: DOUBLE
2954: LD_INT 1
2956: DEC
2957: ST_TO_ADDR
2958: LD_INT 4
2960: PUSH
2961: FOR_TO
2962: IFFALSE 3055
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2964: LD_INT 22
2966: PPUSH
2967: LD_INT 3
2969: PPUSH
2970: LD_INT 3
2972: PPUSH
2973: LD_INT 43
2975: PUSH
2976: LD_INT 45
2978: PUSH
2979: LD_INT 45
2981: PUSH
2982: LD_INT 44
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: PUSH
2991: LD_VAR 0 2
2995: PUSH
2996: LD_INT 4
2998: MOD
2999: PUSH
3000: LD_INT 1
3002: PLUS
3003: ARRAY
3004: PPUSH
3005: LD_INT 100
3007: PPUSH
3008: CALL 19116 0 5
// veh := CreateVehicle ;
3012: LD_ADDR_VAR 0 3
3016: PUSH
3017: CALL_OW 45
3021: ST_TO_ADDR
// tmp := tmp ^ veh ;
3022: LD_ADDR_VAR 0 4
3026: PUSH
3027: LD_VAR 0 4
3031: PUSH
3032: LD_VAR 0 3
3036: ADD
3037: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3038: LD_VAR 0 3
3042: PPUSH
3043: LD_INT 2
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 49
// end ;
3053: GO 2961
3055: POP
3056: POP
// russian_guard := tmp ;
3057: LD_ADDR_EXP 51
3061: PUSH
3062: LD_VAR 0 4
3066: ST_TO_ADDR
// end ;
3067: LD_VAR 0 1
3071: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
3072: LD_INT 47
3074: PPUSH
3075: CALL_OW 302
3079: PUSH
3080: LD_EXP 6
3084: AND
3085: IFFALSE 3687
3087: GO 3089
3089: DISABLE
3090: LD_INT 0
3092: PPUSH
3093: PPUSH
3094: PPUSH
3095: PPUSH
3096: PPUSH
3097: PPUSH
// begin enable ;
3098: ENABLE
// base := 2 ;
3099: LD_ADDR_VAR 0 2
3103: PUSH
3104: LD_INT 2
3106: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3107: LD_ADDR_VAR 0 4
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: LD_INT 0
3117: PUSH
3118: LD_INT 0
3120: PUSH
3121: LD_INT 0
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 0
3129: PUSH
3130: LD_INT 0
3132: PUSH
3133: LD_INT 0
3135: PUSH
3136: LD_INT 1
3138: PUSH
3139: LD_INT 0
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3154: LD_ADDR_VAR 0 3
3158: PUSH
3159: LD_INT 22
3161: PUSH
3162: LD_INT 1
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: LD_INT 45
3170: PUSH
3171: EMPTY
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: PUSH
3177: LD_INT 21
3179: PUSH
3180: LD_INT 1
3182: PUSH
3183: LD_INT 3
3185: PUSH
3186: LD_INT 45
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 22
3197: PUSH
3198: LD_INT 1
3200: PUSH
3201: LD_INT 3
3203: PUSH
3204: LD_INT 45
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 23
3215: PUSH
3216: LD_INT 1
3218: PUSH
3219: LD_INT 3
3221: PUSH
3222: LD_INT 46
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: LIST
3229: LIST
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: LIST
3235: LIST
3236: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3237: LD_ADDR_VAR 0 1
3241: PUSH
3242: DOUBLE
3243: LD_INT 1
3245: DEC
3246: ST_TO_ADDR
3247: LD_OWVAR 67
3251: PUSH
3252: LD_OWVAR 1
3256: PUSH
3257: LD_INT 21000
3259: DIV
3260: PLUS
3261: PUSH
3262: FOR_TO
3263: IFFALSE 3351
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3265: LD_ADDR_VAR 0 3
3269: PUSH
3270: LD_VAR 0 3
3274: PPUSH
3275: LD_VAR 0 3
3279: PUSH
3280: LD_INT 1
3282: PLUS
3283: PPUSH
3284: LD_INT 23
3286: PUSH
3287: LD_INT 24
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: LD_INT 1
3296: PPUSH
3297: LD_INT 2
3299: PPUSH
3300: CALL_OW 12
3304: ARRAY
3305: PUSH
3306: LD_INT 1
3308: PUSH
3309: LD_INT 3
3311: PUSH
3312: LD_INT 46
3314: PUSH
3315: LD_INT 47
3317: PUSH
3318: LD_INT 45
3320: PUSH
3321: EMPTY
3322: LIST
3323: LIST
3324: LIST
3325: PUSH
3326: LD_INT 1
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: CALL_OW 12
3336: ARRAY
3337: PUSH
3338: EMPTY
3339: LIST
3340: LIST
3341: LIST
3342: LIST
3343: PPUSH
3344: CALL_OW 2
3348: ST_TO_ADDR
3349: GO 3262
3351: POP
3352: POP
// MC_InsertProduceList ( base , tmp ) ;
3353: LD_VAR 0 2
3357: PPUSH
3358: LD_VAR 0 3
3362: PPUSH
3363: CALL 74159 0 2
// repeat wait ( 0 0$1 ) ;
3367: LD_INT 35
3369: PPUSH
3370: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3374: LD_EXP 78
3378: PUSH
3379: LD_VAR 0 2
3383: ARRAY
3384: PUSH
3385: LD_INT 6
3387: GREATER
3388: IFFALSE 3367
// wait ( 0 0$20 ) ;
3390: LD_INT 700
3392: PPUSH
3393: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3397: LD_ADDR_VAR 0 5
3401: PUSH
3402: LD_INT 71
3404: PUSH
3405: LD_INT 19
3407: PUSH
3408: EMPTY
3409: LIST
3410: LIST
3411: PUSH
3412: LD_INT 91
3414: PUSH
3415: LD_INT 67
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: PUSH
3422: LD_INT 52
3424: PUSH
3425: LD_INT 44
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PUSH
3432: LD_INT 68
3434: PUSH
3435: LD_INT 48
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3448: LD_ADDR_VAR 0 6
3452: PUSH
3453: LD_EXP 78
3457: PUSH
3458: LD_VAR 0 2
3462: ARRAY
3463: PUSH
3464: LD_EXP 78
3468: PUSH
3469: LD_VAR 0 2
3473: ARRAY
3474: PPUSH
3475: LD_INT 2
3477: PUSH
3478: LD_INT 34
3480: PUSH
3481: LD_INT 51
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: PUSH
3488: LD_INT 34
3490: PUSH
3491: LD_INT 52
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: LIST
3502: PPUSH
3503: CALL_OW 72
3507: DIFF
3508: ST_TO_ADDR
// if not attackers then
3509: LD_VAR 0 6
3513: NOT
3514: IFFALSE 3518
// exit ;
3516: GO 3687
// ru_attackers := attackers ;
3518: LD_ADDR_EXP 52
3522: PUSH
3523: LD_VAR 0 6
3527: ST_TO_ADDR
// for i = 1 to attackers do
3528: LD_ADDR_VAR 0 1
3532: PUSH
3533: DOUBLE
3534: LD_INT 1
3536: DEC
3537: ST_TO_ADDR
3538: LD_VAR 0 6
3542: PUSH
3543: FOR_TO
3544: IFFALSE 3621
// begin case i mod 3 of 0 :
3546: LD_VAR 0 1
3550: PUSH
3551: LD_INT 3
3553: MOD
3554: PUSH
3555: LD_INT 0
3557: DOUBLE
3558: EQUAL
3559: IFTRUE 3563
3561: GO 3566
3563: POP
// ; 1 :
3564: GO 3619
3566: LD_INT 1
3568: DOUBLE
3569: EQUAL
3570: IFTRUE 3574
3572: GO 3592
3574: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3575: LD_VAR 0 1
3579: PPUSH
3580: LD_INT 32
3582: PPUSH
3583: LD_INT 49
3585: PPUSH
3586: CALL_OW 114
3590: GO 3619
3592: LD_INT 2
3594: DOUBLE
3595: EQUAL
3596: IFTRUE 3600
3598: GO 3618
3600: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3601: LD_VAR 0 1
3605: PPUSH
3606: LD_INT 117
3608: PPUSH
3609: LD_INT 107
3611: PPUSH
3612: CALL_OW 114
3616: GO 3619
3618: POP
// end ;
3619: GO 3543
3621: POP
3622: POP
// repeat wait ( 0 0$1 ) ;
3623: LD_INT 35
3625: PPUSH
3626: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3630: LD_VAR 0 6
3634: PPUSH
3635: LD_INT 60
3637: PUSH
3638: EMPTY
3639: LIST
3640: PPUSH
3641: CALL_OW 72
3645: NOT
3646: IFFALSE 3623
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3648: LD_VAR 0 2
3652: PPUSH
3653: LD_VAR 0 6
3657: PPUSH
3658: LD_VAR 0 5
3662: PPUSH
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL 74344 0 4
// if not first_attack then
3672: LD_EXP 7
3676: NOT
3677: IFFALSE 3687
// first_attack := true ;
3679: LD_ADDR_EXP 7
3683: PUSH
3684: LD_INT 1
3686: ST_TO_ADDR
// end ; end_of_file
3687: PPOPN 6
3689: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3690: LD_INT 0
3692: PPUSH
3693: PPUSH
3694: PPUSH
3695: PPUSH
3696: PPUSH
3697: PPUSH
3698: PPUSH
// uc_side := 2 ;
3699: LD_ADDR_OWVAR 20
3703: PUSH
3704: LD_INT 2
3706: ST_TO_ADDR
// uc_nation := 2 ;
3707: LD_ADDR_OWVAR 21
3711: PUSH
3712: LD_INT 2
3714: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3715: LD_ADDR_EXP 55
3719: PUSH
3720: LD_STRING Abdul
3722: PPUSH
3723: CALL_OW 25
3727: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3728: LD_EXP 55
3732: PPUSH
3733: LD_INT 11
3735: PPUSH
3736: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3740: LD_EXP 55
3744: PPUSH
3745: LD_INT 1
3747: PPUSH
3748: CALL_OW 52
// vc_chassis := 31 ;
3752: LD_ADDR_OWVAR 37
3756: PUSH
3757: LD_INT 31
3759: ST_TO_ADDR
// vc_control := control_rider ;
3760: LD_ADDR_OWVAR 38
3764: PUSH
3765: LD_INT 4
3767: ST_TO_ADDR
// mastodont := CreateVehicle ;
3768: LD_ADDR_EXP 56
3772: PUSH
3773: CALL_OW 45
3777: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3778: LD_EXP 56
3782: PPUSH
3783: LD_INT 153
3785: PPUSH
3786: LD_INT 71
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// InitVc ;
3796: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3800: LD_ADDR_EXP 53
3804: PUSH
3805: LD_INT 1
3807: PPUSH
3808: LD_INT 3
3810: PPUSH
3811: LD_STRING 
3813: PPUSH
3814: LD_INT 7
3816: PUSH
3817: LD_INT 8
3819: PUSH
3820: LD_INT 9
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: PUSH
3828: LD_OWVAR 67
3832: ARRAY
3833: PPUSH
3834: LD_INT 5000
3836: PUSH
3837: LD_INT 1000
3839: PUSH
3840: LD_INT 300
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: PPUSH
3848: LD_INT 22
3850: PUSH
3851: LD_INT 5
3853: PUSH
3854: LD_INT 6
3856: PUSH
3857: LD_INT 9
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: LIST
3864: LIST
3865: PPUSH
3866: CALL 22525 0 6
3870: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3871: LD_ADDR_EXP 59
3875: PUSH
3876: LD_EXP 59
3880: PPUSH
3881: LD_INT 1
3883: PPUSH
3884: LD_EXP 53
3888: PPUSH
3889: CALL_OW 1
3893: ST_TO_ADDR
// tmp := [ ] ;
3894: LD_ADDR_VAR 0 4
3898: PUSH
3899: EMPTY
3900: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3901: LD_ADDR_OWVAR 37
3905: PUSH
3906: LD_INT 14
3908: ST_TO_ADDR
// vc_engine := engine_siberite ;
3909: LD_ADDR_OWVAR 39
3913: PUSH
3914: LD_INT 3
3916: ST_TO_ADDR
// vc_control := control_manual ;
3917: LD_ADDR_OWVAR 38
3921: PUSH
3922: LD_INT 1
3924: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3925: LD_ADDR_OWVAR 40
3929: PUSH
3930: LD_INT 31
3932: ST_TO_ADDR
// for i = 1 to 3 do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: DOUBLE
3939: LD_INT 1
3941: DEC
3942: ST_TO_ADDR
3943: LD_INT 3
3945: PUSH
3946: FOR_TO
3947: IFFALSE 4191
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3949: LD_ADDR_VAR 0 5
3953: PUSH
3954: LD_INT 153
3956: PUSH
3957: LD_INT 71
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PUSH
3964: LD_INT 155
3966: PUSH
3967: LD_INT 81
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PUSH
3978: LD_VAR 0 2
3982: PUSH
3983: LD_INT 2
3985: MOD
3986: PUSH
3987: LD_INT 1
3989: PLUS
3990: ARRAY
3991: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3992: LD_INT 0
3994: PPUSH
3995: LD_INT 3
3997: PPUSH
3998: LD_INT 7
4000: PUSH
4001: LD_INT 8
4003: PUSH
4004: LD_INT 9
4006: PUSH
4007: EMPTY
4008: LIST
4009: LIST
4010: LIST
4011: PUSH
4012: LD_OWVAR 67
4016: ARRAY
4017: PPUSH
4018: CALL_OW 380
// un := CreateVehicle ;
4022: LD_ADDR_VAR 0 6
4026: PUSH
4027: CALL_OW 45
4031: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4032: LD_VAR 0 6
4036: PPUSH
4037: LD_INT 0
4039: PPUSH
4040: LD_INT 5
4042: PPUSH
4043: CALL_OW 12
4047: PPUSH
4048: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4052: LD_VAR 0 6
4056: PPUSH
4057: LD_VAR 0 5
4061: PUSH
4062: LD_INT 1
4064: ARRAY
4065: PPUSH
4066: LD_VAR 0 5
4070: PUSH
4071: LD_INT 2
4073: ARRAY
4074: PPUSH
4075: LD_INT 6
4077: PPUSH
4078: LD_INT 0
4080: PPUSH
4081: CALL_OW 50
// un2 := CreateHuman ;
4085: LD_ADDR_VAR 0 7
4089: PUSH
4090: CALL_OW 44
4094: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4095: LD_VAR 0 7
4099: PPUSH
4100: LD_VAR 0 6
4104: PPUSH
4105: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4109: LD_ADDR_EXP 59
4113: PUSH
4114: LD_EXP 59
4118: PPUSH
4119: LD_INT 1
4121: PUSH
4122: LD_EXP 59
4126: PUSH
4127: LD_INT 1
4129: ARRAY
4130: PUSH
4131: LD_INT 1
4133: PLUS
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: PPUSH
4139: LD_VAR 0 6
4143: PPUSH
4144: CALL 19238 0 3
4148: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4149: LD_ADDR_EXP 59
4153: PUSH
4154: LD_EXP 59
4158: PPUSH
4159: LD_INT 1
4161: PUSH
4162: LD_EXP 59
4166: PUSH
4167: LD_INT 1
4169: ARRAY
4170: PUSH
4171: LD_INT 1
4173: PLUS
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: PPUSH
4179: LD_VAR 0 7
4183: PPUSH
4184: CALL 19238 0 3
4188: ST_TO_ADDR
// end ;
4189: GO 3946
4191: POP
4192: POP
// for i = 1 to 5 do
4193: LD_ADDR_VAR 0 2
4197: PUSH
4198: DOUBLE
4199: LD_INT 1
4201: DEC
4202: ST_TO_ADDR
4203: LD_INT 5
4205: PUSH
4206: FOR_TO
4207: IFFALSE 4300
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4209: LD_INT 14
4211: PPUSH
4212: LD_INT 3
4214: PPUSH
4215: LD_INT 1
4217: PPUSH
4218: LD_INT 25
4220: PUSH
4221: LD_INT 28
4223: PUSH
4224: LD_INT 28
4226: PUSH
4227: LD_INT 26
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: LIST
4235: PUSH
4236: LD_VAR 0 2
4240: PUSH
4241: LD_INT 4
4243: MOD
4244: PUSH
4245: LD_INT 1
4247: PLUS
4248: ARRAY
4249: PPUSH
4250: LD_INT 100
4252: PPUSH
4253: CALL 19116 0 5
// veh := CreateVehicle ;
4257: LD_ADDR_VAR 0 3
4261: PUSH
4262: CALL_OW 45
4266: ST_TO_ADDR
// tmp := tmp ^ veh ;
4267: LD_ADDR_VAR 0 4
4271: PUSH
4272: LD_VAR 0 4
4276: PUSH
4277: LD_VAR 0 3
4281: ADD
4282: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4283: LD_VAR 0 3
4287: PPUSH
4288: LD_INT 1
4290: PPUSH
4291: LD_INT 0
4293: PPUSH
4294: CALL_OW 49
// end ;
4298: GO 4206
4300: POP
4301: POP
// arabian_guard := tmp ;
4302: LD_ADDR_EXP 54
4306: PUSH
4307: LD_VAR 0 4
4311: ST_TO_ADDR
// end ;
4312: LD_VAR 0 1
4316: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4317: LD_INT 22
4319: PUSH
4320: LD_INT 7
4322: PUSH
4323: EMPTY
4324: LIST
4325: LIST
4326: PUSH
4327: LD_INT 91
4329: PUSH
4330: LD_INT 1
4332: PUSH
4333: LD_INT 12
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: PPUSH
4345: CALL_OW 69
4349: PUSH
4350: LD_EXP 56
4354: PPUSH
4355: CALL_OW 256
4359: PUSH
4360: LD_INT 990
4362: LESS
4363: OR
4364: PUSH
4365: LD_EXP 55
4369: PPUSH
4370: CALL_OW 256
4374: PUSH
4375: LD_INT 990
4377: LESS
4378: OR
4379: IFFALSE 4522
4381: GO 4383
4383: DISABLE
// begin if IsInUnit ( Abdul ) then
4384: LD_EXP 55
4388: PPUSH
4389: CALL_OW 310
4393: IFFALSE 4404
// ComExitBuilding ( Abdul ) ;
4395: LD_EXP 55
4399: PPUSH
4400: CALL_OW 122
// if Mastodont then
4404: LD_EXP 56
4408: IFFALSE 4425
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4410: LD_EXP 56
4414: PPUSH
4415: LD_INT 205
4417: PPUSH
4418: LD_INT 132
4420: PPUSH
4421: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4425: LD_EXP 55
4429: PPUSH
4430: LD_INT 205
4432: PPUSH
4433: LD_INT 132
4435: PPUSH
4436: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4440: LD_INT 35
4442: PPUSH
4443: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4447: LD_EXP 55
4451: PPUSH
4452: LD_INT 21
4454: PPUSH
4455: CALL_OW 308
4459: IFFALSE 4440
// RemoveUnit ( Abdul ) ;
4461: LD_EXP 55
4465: PPUSH
4466: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4470: LD_INT 35
4472: PPUSH
4473: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4477: LD_EXP 56
4481: PPUSH
4482: LD_INT 21
4484: PPUSH
4485: CALL_OW 308
4489: PUSH
4490: LD_EXP 56
4494: PPUSH
4495: CALL_OW 301
4499: OR
4500: IFFALSE 4470
// if IsOk ( Mastodont ) then
4502: LD_EXP 56
4506: PPUSH
4507: CALL_OW 302
4511: IFFALSE 4522
// RemoveUnit ( Mastodont ) ;
4513: LD_EXP 56
4517: PPUSH
4518: CALL_OW 64
// end ;
4522: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4523: LD_EXP 55
4527: PPUSH
4528: CALL_OW 301
4532: PUSH
4533: LD_INT 22
4535: PUSH
4536: LD_INT 2
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: PUSH
4543: LD_INT 2
4545: PUSH
4546: LD_INT 25
4548: PUSH
4549: LD_INT 1
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 25
4558: PUSH
4559: LD_INT 2
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 25
4568: PUSH
4569: LD_INT 3
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: LD_INT 25
4578: PUSH
4579: LD_INT 4
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PUSH
4586: LD_INT 25
4588: PUSH
4589: LD_INT 8
4591: PUSH
4592: EMPTY
4593: LIST
4594: LIST
4595: PUSH
4596: EMPTY
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: PPUSH
4608: CALL_OW 69
4612: PUSH
4613: LD_INT 16
4615: PUSH
4616: LD_INT 19
4618: PUSH
4619: LD_INT 22
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: LIST
4626: PUSH
4627: LD_OWVAR 67
4631: ARRAY
4632: LESS
4633: OR
4634: IFFALSE 5307
4636: GO 4638
4638: DISABLE
4639: LD_INT 0
4641: PPUSH
4642: PPUSH
4643: PPUSH
4644: PPUSH
4645: PPUSH
4646: PPUSH
// begin MC_Kill ( 1 ) ;
4647: LD_INT 1
4649: PPUSH
4650: CALL 50699 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4654: LD_ADDR_VAR 0 2
4658: PUSH
4659: LD_INT 22
4661: PUSH
4662: LD_INT 2
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: LD_INT 25
4674: PUSH
4675: LD_INT 1
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: LD_INT 25
4684: PUSH
4685: LD_INT 2
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: PUSH
4692: LD_INT 25
4694: PUSH
4695: LD_INT 3
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PUSH
4702: LD_INT 25
4704: PUSH
4705: LD_INT 4
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: LD_INT 25
4714: PUSH
4715: LD_INT 8
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PPUSH
4734: CALL_OW 69
4738: ST_TO_ADDR
// for i in tmp do
4739: LD_ADDR_VAR 0 5
4743: PUSH
4744: LD_VAR 0 2
4748: PUSH
4749: FOR_IN
4750: IFFALSE 4766
// SetTag ( i , 10 ) ;
4752: LD_VAR 0 5
4756: PPUSH
4757: LD_INT 10
4759: PPUSH
4760: CALL_OW 109
4764: GO 4749
4766: POP
4767: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4768: LD_ADDR_VAR 0 3
4772: PUSH
4773: LD_INT 22
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: LD_INT 21
4785: PUSH
4786: LD_INT 1
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: PPUSH
4797: CALL_OW 69
4801: PUSH
4802: LD_VAR 0 2
4806: DIFF
4807: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4808: LD_ADDR_VAR 0 1
4812: PUSH
4813: LD_INT 22
4815: PUSH
4816: LD_INT 2
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: LD_INT 21
4825: PUSH
4826: LD_INT 2
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: PUSH
4833: LD_INT 24
4835: PUSH
4836: LD_INT 300
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: LIST
4847: PPUSH
4848: CALL_OW 69
4852: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4853: LD_ADDR_VAR 0 4
4857: PUSH
4858: LD_VAR 0 1
4862: PPUSH
4863: LD_INT 33
4865: PUSH
4866: LD_INT 1
4868: PUSH
4869: EMPTY
4870: LIST
4871: LIST
4872: PUSH
4873: LD_INT 58
4875: PUSH
4876: EMPTY
4877: LIST
4878: PUSH
4879: EMPTY
4880: LIST
4881: LIST
4882: PPUSH
4883: CALL_OW 72
4887: ST_TO_ADDR
// for i in tmp do
4888: LD_ADDR_VAR 0 5
4892: PUSH
4893: LD_VAR 0 2
4897: PUSH
4898: FOR_IN
4899: IFFALSE 5083
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4901: LD_VAR 0 5
4905: PUSH
4906: LD_INT 55
4908: PUSH
4909: EMPTY
4910: LIST
4911: PPUSH
4912: CALL_OW 69
4916: IN
4917: IFFALSE 4936
// begin AddComMoveXY ( i , 209 , 132 ) ;
4919: LD_VAR 0 5
4923: PPUSH
4924: LD_INT 209
4926: PPUSH
4927: LD_INT 132
4929: PPUSH
4930: CALL_OW 171
// continue ;
4934: GO 4898
// end ; if IsInUnit ( i ) then
4936: LD_VAR 0 5
4940: PPUSH
4941: CALL_OW 310
4945: IFFALSE 4963
// begin ComExitBuilding ( i ) ;
4947: LD_VAR 0 5
4951: PPUSH
4952: CALL_OW 122
// wait ( 3 ) ;
4956: LD_INT 3
4958: PPUSH
4959: CALL_OW 67
// end ; if tmp_empty then
4963: LD_VAR 0 4
4967: IFFALSE 5066
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4969: LD_VAR 0 5
4973: PPUSH
4974: LD_VAR 0 4
4978: PPUSH
4979: LD_VAR 0 5
4983: PPUSH
4984: CALL_OW 74
4988: PPUSH
4989: CALL_OW 296
4993: PUSH
4994: LD_INT 25
4996: LESS
4997: IFFALSE 5066
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4999: LD_ADDR_VAR 0 6
5003: PUSH
5004: LD_VAR 0 4
5008: PPUSH
5009: LD_VAR 0 5
5013: PPUSH
5014: CALL_OW 74
5018: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5019: LD_VAR 0 5
5023: PPUSH
5024: LD_VAR 0 6
5028: PPUSH
5029: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5033: LD_VAR 0 5
5037: PPUSH
5038: LD_INT 209
5040: PPUSH
5041: LD_INT 132
5043: PPUSH
5044: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5048: LD_ADDR_VAR 0 4
5052: PUSH
5053: LD_VAR 0 4
5057: PUSH
5058: LD_VAR 0 6
5062: DIFF
5063: ST_TO_ADDR
// continue ;
5064: GO 4898
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5066: LD_VAR 0 5
5070: PPUSH
5071: LD_INT 201
5073: PPUSH
5074: LD_INT 132
5076: PPUSH
5077: CALL_OW 171
// end ;
5081: GO 4898
5083: POP
5084: POP
// for i in tmp_ape do
5085: LD_ADDR_VAR 0 5
5089: PUSH
5090: LD_VAR 0 3
5094: PUSH
5095: FOR_IN
5096: IFFALSE 5135
// begin if IsInUnit ( i ) then
5098: LD_VAR 0 5
5102: PPUSH
5103: CALL_OW 310
5107: IFFALSE 5118
// ComExitBuilding ( i ) ;
5109: LD_VAR 0 5
5113: PPUSH
5114: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5118: LD_VAR 0 5
5122: PPUSH
5123: LD_INT 201
5125: PPUSH
5126: LD_INT 132
5128: PPUSH
5129: CALL_OW 171
// end ;
5133: GO 5095
5135: POP
5136: POP
// repeat wait ( 0 0$1 ) ;
5137: LD_INT 35
5139: PPUSH
5140: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5144: LD_ADDR_VAR 0 5
5148: PUSH
5149: LD_VAR 0 2
5153: PUSH
5154: LD_VAR 0 3
5158: UNION
5159: PUSH
5160: LD_VAR 0 1
5164: UNION
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5198
// if not HasTask ( i ) then
5169: LD_VAR 0 5
5173: PPUSH
5174: CALL_OW 314
5178: NOT
5179: IFFALSE 5196
// ComMoveXY ( i , 201 , 132 ) ;
5181: LD_VAR 0 5
5185: PPUSH
5186: LD_INT 201
5188: PPUSH
5189: LD_INT 132
5191: PPUSH
5192: CALL_OW 111
5196: GO 5166
5198: POP
5199: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5200: LD_INT 21
5202: PPUSH
5203: LD_INT 22
5205: PUSH
5206: LD_INT 2
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL_OW 70
5217: IFFALSE 5258
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5219: LD_ADDR_VAR 0 5
5223: PUSH
5224: LD_INT 21
5226: PPUSH
5227: LD_INT 22
5229: PUSH
5230: LD_INT 2
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: PPUSH
5237: CALL_OW 70
5241: PUSH
5242: FOR_IN
5243: IFFALSE 5256
// RemoveUnit ( i ) ;
5245: LD_VAR 0 5
5249: PPUSH
5250: CALL_OW 64
5254: GO 5242
5256: POP
5257: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5258: LD_INT 22
5260: PUSH
5261: LD_INT 2
5263: PUSH
5264: EMPTY
5265: LIST
5266: LIST
5267: PUSH
5268: LD_INT 2
5270: PUSH
5271: LD_INT 21
5273: PUSH
5274: LD_INT 1
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PUSH
5281: LD_INT 21
5283: PUSH
5284: LD_INT 2
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: LIST
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 69
5304: NOT
5305: IFFALSE 5137
// end ;
5307: PPOPN 6
5309: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5310: LD_EXP 9
5314: PUSH
5315: LD_INT 92
5317: PPUSH
5318: LD_INT 40
5320: PPUSH
5321: CALL_OW 428
5325: PPUSH
5326: CALL_OW 266
5330: PUSH
5331: LD_INT 30
5333: EQUAL
5334: AND
5335: IFFALSE 5531
5337: GO 5339
5339: DISABLE
5340: LD_INT 0
5342: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5343: LD_ADDR_VAR 0 1
5347: PUSH
5348: LD_EXP 59
5352: PUSH
5353: LD_INT 1
5355: ARRAY
5356: PPUSH
5357: LD_INT 25
5359: PUSH
5360: LD_INT 4
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PPUSH
5367: CALL_OW 72
5371: ST_TO_ADDR
// if not sci then
5372: LD_VAR 0 1
5376: NOT
5377: IFFALSE 5381
// exit ;
5379: GO 5531
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5381: LD_ADDR_EXP 59
5385: PUSH
5386: LD_EXP 59
5390: PPUSH
5391: LD_INT 1
5393: PPUSH
5394: LD_EXP 59
5398: PUSH
5399: LD_INT 1
5401: ARRAY
5402: PUSH
5403: LD_VAR 0 1
5407: PUSH
5408: LD_INT 1
5410: ARRAY
5411: DIFF
5412: PPUSH
5413: CALL_OW 1
5417: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5418: LD_VAR 0 1
5422: PUSH
5423: LD_INT 1
5425: ARRAY
5426: PPUSH
5427: CALL_OW 310
5431: IFFALSE 5446
// ComExitBuilding ( sci [ 1 ] ) ;
5433: LD_VAR 0 1
5437: PUSH
5438: LD_INT 1
5440: ARRAY
5441: PPUSH
5442: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5446: LD_INT 2
5448: PPUSH
5449: LD_INT 105
5451: PPUSH
5452: LD_INT 14
5454: PPUSH
5455: LD_INT 20
5457: PPUSH
5458: CALL 20134 0 4
5462: PUSH
5463: LD_INT 4
5465: ARRAY
5466: PUSH
5467: LD_INT 10
5469: LESS
5470: IFFALSE 5493
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5472: LD_VAR 0 1
5476: PUSH
5477: LD_INT 1
5479: ARRAY
5480: PPUSH
5481: LD_INT 105
5483: PPUSH
5484: LD_INT 14
5486: PPUSH
5487: CALL_OW 171
5491: GO 5512
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5493: LD_VAR 0 1
5497: PUSH
5498: LD_INT 1
5500: ARRAY
5501: PPUSH
5502: LD_INT 118
5504: PPUSH
5505: LD_INT 77
5507: PPUSH
5508: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5512: LD_VAR 0 1
5516: PUSH
5517: LD_INT 1
5519: ARRAY
5520: PPUSH
5521: LD_INT 92
5523: PPUSH
5524: LD_INT 40
5526: PPUSH
5527: CALL_OW 218
// end ;
5531: PPOPN 1
5533: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5534: LD_INT 1
5536: PPUSH
5537: CALL_OW 302
5541: PUSH
5542: LD_EXP 9
5546: AND
5547: IFFALSE 6006
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
5557: PPUSH
5558: PPUSH
5559: PPUSH
// begin enable ;
5560: ENABLE
// base := 1 ;
5561: LD_ADDR_VAR 0 2
5565: PUSH
5566: LD_INT 1
5568: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5569: LD_ADDR_VAR 0 4
5573: PUSH
5574: LD_INT 0
5576: PUSH
5577: LD_INT 0
5579: PUSH
5580: LD_INT 0
5582: PUSH
5583: LD_INT 0
5585: PUSH
5586: LD_INT 0
5588: PUSH
5589: LD_INT 0
5591: PUSH
5592: LD_INT 0
5594: PUSH
5595: LD_INT 0
5597: PUSH
5598: LD_INT 1
5600: PUSH
5601: LD_INT 0
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: LIST
5614: LIST
5615: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5616: LD_ADDR_VAR 0 3
5620: PUSH
5621: LD_INT 14
5623: PUSH
5624: LD_INT 1
5626: PUSH
5627: LD_INT 2
5629: PUSH
5630: LD_INT 26
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: PUSH
5639: LD_INT 14
5641: PUSH
5642: LD_INT 1
5644: PUSH
5645: LD_INT 2
5647: PUSH
5648: LD_INT 28
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: LD_INT 13
5659: PUSH
5660: LD_INT 1
5662: PUSH
5663: LD_INT 2
5665: PUSH
5666: LD_INT 29
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: LIST
5679: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5680: LD_ADDR_VAR 0 1
5684: PUSH
5685: DOUBLE
5686: LD_INT 1
5688: DEC
5689: ST_TO_ADDR
5690: LD_OWVAR 67
5694: PUSH
5695: LD_OWVAR 1
5699: PUSH
5700: LD_INT 21000
5702: DIV
5703: PLUS
5704: PUSH
5705: FOR_TO
5706: IFFALSE 5798
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5708: LD_ADDR_VAR 0 3
5712: PUSH
5713: LD_VAR 0 3
5717: PPUSH
5718: LD_VAR 0 3
5722: PUSH
5723: LD_INT 1
5725: PLUS
5726: PPUSH
5727: LD_INT 13
5729: PUSH
5730: LD_INT 14
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: PUSH
5737: LD_INT 1
5739: PPUSH
5740: LD_INT 2
5742: PPUSH
5743: CALL_OW 12
5747: ARRAY
5748: PUSH
5749: LD_INT 1
5751: PUSH
5752: LD_INT 2
5754: PUSH
5755: LD_INT 28
5757: PUSH
5758: LD_INT 29
5760: PUSH
5761: LD_INT 25
5763: PUSH
5764: LD_INT 26
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_INT 1
5775: PPUSH
5776: LD_INT 4
5778: PPUSH
5779: CALL_OW 12
5783: ARRAY
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PPUSH
5791: CALL_OW 2
5795: ST_TO_ADDR
5796: GO 5705
5798: POP
5799: POP
// MC_InsertProduceList ( base , tmp ) ;
5800: LD_VAR 0 2
5804: PPUSH
5805: LD_VAR 0 3
5809: PPUSH
5810: CALL 74159 0 2
// repeat wait ( 0 0$1 ) ;
5814: LD_INT 35
5816: PPUSH
5817: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5821: LD_EXP 78
5825: PUSH
5826: LD_VAR 0 2
5830: ARRAY
5831: PUSH
5832: LD_INT 6
5834: GREATER
5835: IFFALSE 5814
// wait ( 0 0$20 ) ;
5837: LD_INT 700
5839: PPUSH
5840: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5844: LD_ADDR_VAR 0 5
5848: PUSH
5849: LD_INT 124
5851: PUSH
5852: LD_INT 85
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: LD_INT 90
5861: PUSH
5862: LD_INT 61
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: PUSH
5869: LD_INT 69
5871: PUSH
5872: LD_INT 48
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: PUSH
5879: LD_INT 68
5881: PUSH
5882: LD_INT 48
5884: PUSH
5885: EMPTY
5886: LIST
5887: LIST
5888: PUSH
5889: EMPTY
5890: LIST
5891: LIST
5892: LIST
5893: LIST
5894: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5895: LD_ADDR_VAR 0 6
5899: PUSH
5900: LD_EXP 78
5904: PUSH
5905: LD_VAR 0 2
5909: ARRAY
5910: PUSH
5911: LD_EXP 78
5915: PUSH
5916: LD_VAR 0 2
5920: ARRAY
5921: PPUSH
5922: LD_INT 34
5924: PUSH
5925: LD_INT 32
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL_OW 72
5936: DIFF
5937: ST_TO_ADDR
// if not attackers then
5938: LD_VAR 0 6
5942: NOT
5943: IFFALSE 5947
// exit ;
5945: GO 6006
// ar_attackers := attackers ;
5947: LD_ADDR_EXP 10
5951: PUSH
5952: LD_VAR 0 6
5956: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5957: LD_INT 35
5959: PPUSH
5960: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5964: LD_VAR 0 6
5968: PPUSH
5969: LD_INT 60
5971: PUSH
5972: EMPTY
5973: LIST
5974: PPUSH
5975: CALL_OW 72
5979: NOT
5980: IFFALSE 5957
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5982: LD_VAR 0 2
5986: PPUSH
5987: LD_VAR 0 6
5991: PPUSH
5992: LD_VAR 0 5
5996: PPUSH
5997: LD_VAR 0 4
6001: PPUSH
6002: CALL 74344 0 4
// end ;
6006: PPOPN 6
6008: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6009: LD_INT 1
6011: PPUSH
6012: CALL_OW 302
6016: PUSH
6017: LD_EXP 9
6021: AND
6022: PUSH
6023: LD_EXP 49
6027: PPUSH
6028: LD_INT 22
6030: PPUSH
6031: CALL_OW 308
6035: AND
6036: PUSH
6037: LD_INT 1
6039: PPUSH
6040: CALL 74507 0 1
6044: PUSH
6045: LD_INT 0
6047: EQUAL
6048: AND
6049: PUSH
6050: LD_EXP 10
6054: NOT
6055: AND
6056: IFFALSE 6520
6058: GO 6060
6060: DISABLE
6061: LD_INT 0
6063: PPUSH
6064: PPUSH
6065: PPUSH
6066: PPUSH
6067: PPUSH
6068: PPUSH
6069: PPUSH
// begin base := 1 ;
6070: LD_ADDR_VAR 0 2
6074: PUSH
6075: LD_INT 1
6077: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6078: LD_ADDR_VAR 0 4
6082: PUSH
6083: LD_INT 0
6085: PUSH
6086: LD_INT 0
6088: PUSH
6089: LD_INT 0
6091: PUSH
6092: LD_INT 0
6094: PUSH
6095: LD_INT 0
6097: PUSH
6098: LD_INT 0
6100: PUSH
6101: LD_INT 0
6103: PUSH
6104: LD_INT 0
6106: PUSH
6107: LD_INT 1
6109: PUSH
6110: LD_INT 0
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6125: LD_ADDR_VAR 0 3
6129: PUSH
6130: LD_INT 13
6132: PUSH
6133: LD_INT 1
6135: PUSH
6136: LD_INT 2
6138: PUSH
6139: LD_INT 28
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 13
6150: PUSH
6151: LD_INT 1
6153: PUSH
6154: LD_INT 2
6156: PUSH
6157: LD_INT 27
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: PUSH
6166: LD_INT 13
6168: PUSH
6169: LD_INT 1
6171: PUSH
6172: LD_INT 2
6174: PUSH
6175: LD_INT 25
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 11
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 2
6192: PUSH
6193: LD_INT 24
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: PUSH
6202: LD_INT 11
6204: PUSH
6205: LD_INT 2
6207: PUSH
6208: LD_INT 2
6210: PUSH
6211: LD_INT 24
6213: PUSH
6214: EMPTY
6215: LIST
6216: LIST
6217: LIST
6218: LIST
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6227: LD_VAR 0 2
6231: PPUSH
6232: LD_VAR 0 3
6236: PPUSH
6237: CALL 74159 0 2
// repeat wait ( 0 0$1 ) ;
6241: LD_INT 35
6243: PPUSH
6244: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6248: LD_EXP 78
6252: PUSH
6253: LD_VAR 0 2
6257: ARRAY
6258: PUSH
6259: LD_INT 6
6261: GREATEREQUAL
6262: IFFALSE 6241
// wait ( 0 0$20 ) ;
6264: LD_INT 700
6266: PPUSH
6267: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6271: LD_ADDR_VAR 0 5
6275: PUSH
6276: LD_INT 119
6278: PUSH
6279: LD_INT 9
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: PUSH
6286: EMPTY
6287: LIST
6288: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6289: LD_ADDR_VAR 0 6
6293: PUSH
6294: LD_EXP 78
6298: PUSH
6299: LD_VAR 0 2
6303: ARRAY
6304: PUSH
6305: LD_EXP 78
6309: PUSH
6310: LD_VAR 0 2
6314: ARRAY
6315: PPUSH
6316: LD_INT 34
6318: PUSH
6319: LD_INT 32
6321: PUSH
6322: EMPTY
6323: LIST
6324: LIST
6325: PPUSH
6326: CALL_OW 72
6330: DIFF
6331: ST_TO_ADDR
// if not attackers then
6332: LD_VAR 0 6
6336: NOT
6337: IFFALSE 6341
// exit ;
6339: GO 6520
// uc_side := 2 ;
6341: LD_ADDR_OWVAR 20
6345: PUSH
6346: LD_INT 2
6348: ST_TO_ADDR
// uc_nation := 2 ;
6349: LD_ADDR_OWVAR 21
6353: PUSH
6354: LD_INT 2
6356: ST_TO_ADDR
// InitHc ;
6357: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6361: LD_ADDR_VAR 0 1
6365: PUSH
6366: DOUBLE
6367: LD_INT 1
6369: DEC
6370: ST_TO_ADDR
6371: LD_INT 4
6373: PUSH
6374: LD_INT 5
6376: PUSH
6377: LD_INT 6
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: LD_OWVAR 67
6389: ARRAY
6390: PUSH
6391: FOR_TO
6392: IFFALSE 6469
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6394: LD_INT 0
6396: PPUSH
6397: LD_INT 15
6399: PUSH
6400: LD_INT 17
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: CALL_OW 12
6417: ARRAY
6418: PPUSH
6419: LD_INT 8
6421: PPUSH
6422: CALL_OW 380
// un := CreateHuman ;
6426: LD_ADDR_VAR 0 7
6430: PUSH
6431: CALL_OW 44
6435: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6436: LD_VAR 0 7
6440: PPUSH
6441: LD_INT 23
6443: PPUSH
6444: LD_INT 0
6446: PPUSH
6447: CALL_OW 49
// attackers := attackers union un ;
6451: LD_ADDR_VAR 0 6
6455: PUSH
6456: LD_VAR 0 6
6460: PUSH
6461: LD_VAR 0 7
6465: UNION
6466: ST_TO_ADDR
// end ;
6467: GO 6391
6469: POP
6470: POP
// repeat wait ( 0 0$1 ) ;
6471: LD_INT 35
6473: PPUSH
6474: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6478: LD_VAR 0 6
6482: PPUSH
6483: LD_INT 60
6485: PUSH
6486: EMPTY
6487: LIST
6488: PPUSH
6489: CALL_OW 72
6493: NOT
6494: IFFALSE 6471
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6496: LD_VAR 0 2
6500: PPUSH
6501: LD_VAR 0 6
6505: PPUSH
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 4
6515: PPUSH
6516: CALL 74344 0 4
// end ; end_of_file
6520: PPOPN 7
6522: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6523: LD_INT 0
6525: PPUSH
6526: PPUSH
6527: PPUSH
6528: PPUSH
// uc_side := 1 ;
6529: LD_ADDR_OWVAR 20
6533: PUSH
6534: LD_INT 1
6536: ST_TO_ADDR
// uc_nation := 1 ;
6537: LD_ADDR_OWVAR 21
6541: PUSH
6542: LD_INT 1
6544: ST_TO_ADDR
// InitHc ;
6545: CALL_OW 19
// InitVc ;
6549: CALL_OW 20
// tmp := [ ] ;
6553: LD_ADDR_VAR 0 3
6557: PUSH
6558: EMPTY
6559: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6560: LD_ADDR_VAR 0 2
6564: PUSH
6565: DOUBLE
6566: LD_INT 1
6568: DEC
6569: ST_TO_ADDR
6570: LD_INT 5
6572: PUSH
6573: LD_INT 6
6575: PUSH
6576: LD_INT 6
6578: PUSH
6579: EMPTY
6580: LIST
6581: LIST
6582: LIST
6583: PUSH
6584: LD_OWVAR 67
6588: ARRAY
6589: PUSH
6590: FOR_TO
6591: IFFALSE 6728
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6593: LD_INT 2
6595: PUSH
6596: LD_INT 4
6598: PUSH
6599: LD_INT 5
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: LIST
6606: PUSH
6607: LD_INT 1
6609: PPUSH
6610: LD_INT 3
6612: PPUSH
6613: CALL_OW 12
6617: ARRAY
6618: PPUSH
6619: LD_INT 1
6621: PUSH
6622: LD_INT 3
6624: PUSH
6625: EMPTY
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 1
6631: PPUSH
6632: LD_INT 2
6634: PPUSH
6635: CALL_OW 12
6639: ARRAY
6640: PPUSH
6641: LD_INT 3
6643: PPUSH
6644: LD_INT 9
6646: PUSH
6647: LD_INT 7
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 1
6656: PPUSH
6657: LD_INT 2
6659: PPUSH
6660: CALL_OW 12
6664: ARRAY
6665: PPUSH
6666: LD_INT 78
6668: PPUSH
6669: CALL 19116 0 5
// veh := CreateVehicle ;
6673: LD_ADDR_VAR 0 4
6677: PUSH
6678: CALL_OW 45
6682: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6683: LD_VAR 0 4
6687: PPUSH
6688: LD_INT 2
6690: PPUSH
6691: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6695: LD_VAR 0 4
6699: PPUSH
6700: LD_INT 17
6702: PPUSH
6703: LD_INT 0
6705: PPUSH
6706: CALL_OW 49
// tmp := tmp ^ veh ;
6710: LD_ADDR_VAR 0 3
6714: PUSH
6715: LD_VAR 0 3
6719: PUSH
6720: LD_VAR 0 4
6724: ADD
6725: ST_TO_ADDR
// end ;
6726: GO 6590
6728: POP
6729: POP
// if not tmp then
6730: LD_VAR 0 3
6734: NOT
6735: IFFALSE 6739
// exit ;
6737: GO 6848
// if not first_powell_attack then
6739: LD_EXP 11
6743: NOT
6744: IFFALSE 6754
// first_powell_attack := true ;
6746: LD_ADDR_EXP 11
6750: PUSH
6751: LD_INT 1
6753: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6754: LD_INT 70
6756: PPUSH
6757: CALL_OW 67
// for i in tmp do
6761: LD_ADDR_VAR 0 2
6765: PUSH
6766: LD_VAR 0 3
6770: PUSH
6771: FOR_IN
6772: IFFALSE 6839
// if IsOk ( i ) then
6774: LD_VAR 0 2
6778: PPUSH
6779: CALL_OW 302
6783: IFFALSE 6821
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6785: LD_VAR 0 2
6789: PPUSH
6790: LD_INT 81
6792: PUSH
6793: LD_INT 1
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: PPUSH
6800: CALL_OW 69
6804: PPUSH
6805: LD_VAR 0 2
6809: PPUSH
6810: CALL_OW 74
6814: PPUSH
6815: CALL_OW 115
6819: GO 6837
// tmp := tmp diff i ;
6821: LD_ADDR_VAR 0 3
6825: PUSH
6826: LD_VAR 0 3
6830: PUSH
6831: LD_VAR 0 2
6835: DIFF
6836: ST_TO_ADDR
6837: GO 6771
6839: POP
6840: POP
// until not tmp ;
6841: LD_VAR 0 3
6845: NOT
6846: IFFALSE 6754
// end ; end_of_file
6848: LD_VAR 0 1
6852: RET
// export function Action ; var tmp , i , un ; begin
6853: LD_INT 0
6855: PPUSH
6856: PPUSH
6857: PPUSH
6858: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6859: LD_INT 68
6861: PPUSH
6862: LD_INT 39
6864: PPUSH
6865: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6869: LD_ADDR_VAR 0 2
6873: PUSH
6874: LD_INT 22
6876: PUSH
6877: LD_INT 7
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: PPUSH
6884: CALL_OW 69
6888: ST_TO_ADDR
// InGameOn ;
6889: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6893: LD_VAR 0 2
6897: PPUSH
6898: LD_INT 71
6900: PPUSH
6901: LD_INT 49
6903: PPUSH
6904: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6908: LD_INT 35
6910: PPUSH
6911: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6915: LD_INT 7
6917: PPUSH
6918: LD_INT 71
6920: PPUSH
6921: LD_INT 51
6923: PPUSH
6924: CALL_OW 293
6928: IFFALSE 6908
// DialogueOn ;
6930: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6934: LD_EXP 15
6938: PPUSH
6939: LD_STRING D1-JMM-1
6941: PPUSH
6942: CALL_OW 88
// if Joan then
6946: LD_EXP 30
6950: IFFALSE 6964
// Say ( Joan , D1-Joan-1 ) ;
6952: LD_EXP 30
6956: PPUSH
6957: LD_STRING D1-Joan-1
6959: PPUSH
6960: CALL_OW 88
// if Lisa then
6964: LD_EXP 17
6968: IFFALSE 6982
// Say ( Lisa , D1-Lisa-1 ) ;
6970: LD_EXP 17
6974: PPUSH
6975: LD_STRING D1-Lisa-1
6977: PPUSH
6978: CALL_OW 88
// if Joan or Lisa then
6982: LD_EXP 30
6986: PUSH
6987: LD_EXP 17
6991: OR
6992: IFFALSE 7006
// Say ( JMM , D1-JMM-2 ) ;
6994: LD_EXP 15
6998: PPUSH
6999: LD_STRING D1-JMM-2
7001: PPUSH
7002: CALL_OW 88
// DialogueOff ;
7006: CALL_OW 7
// InGameOff ;
7010: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7014: LD_INT 71
7016: PPUSH
7017: LD_INT 50
7019: PPUSH
7020: LD_INT 7
7022: PPUSH
7023: LD_INT 30
7025: NEG
7026: PPUSH
7027: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7031: LD_INT 71
7033: PPUSH
7034: LD_INT 50
7036: PPUSH
7037: LD_INT 7
7039: PPUSH
7040: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7044: LD_STRING M1
7046: PPUSH
7047: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7051: LD_INT 35
7053: PPUSH
7054: CALL_OW 67
// until freedom ;
7058: LD_EXP 3
7062: IFFALSE 7051
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7064: LD_INT 350
7066: PPUSH
7067: LD_INT 700
7069: PPUSH
7070: CALL_OW 12
7074: PPUSH
7075: CALL_OW 67
// PrepareGossudarov ;
7079: CALL 1802 0 0
// repeat wait ( 0 0$1 ) ;
7083: LD_INT 35
7085: PPUSH
7086: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7090: LD_INT 22
7092: PUSH
7093: LD_INT 6
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 24
7105: PUSH
7106: LD_INT 1000
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: PPUSH
7121: CALL_OW 69
7125: PUSH
7126: LD_INT 7
7128: PPUSH
7129: LD_EXP 32
7133: PPUSH
7134: CALL_OW 292
7138: OR
7139: IFFALSE 7083
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7141: LD_ADDR_VAR 0 2
7145: PUSH
7146: LD_INT 22
7148: PUSH
7149: LD_INT 6
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PPUSH
7156: CALL_OW 69
7160: ST_TO_ADDR
// for i in tmp do
7161: LD_ADDR_VAR 0 3
7165: PUSH
7166: LD_VAR 0 2
7170: PUSH
7171: FOR_IN
7172: IFFALSE 7188
// SetSide ( i , 7 ) ;
7174: LD_VAR 0 3
7178: PPUSH
7179: LD_INT 7
7181: PPUSH
7182: CALL_OW 235
7186: GO 7171
7188: POP
7189: POP
// DialogueOn ;
7190: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7194: LD_EXP 15
7198: PUSH
7199: LD_EXP 16
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: PPUSH
7208: LD_EXP 32
7212: PPUSH
7213: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7217: LD_EXP 32
7221: PPUSH
7222: CALL_OW 87
// if not Roth then
7226: LD_EXP 16
7230: NOT
7231: IFFALSE 7323
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7233: LD_VAR 0 2
7237: PPUSH
7238: LD_INT 3
7240: PUSH
7241: LD_INT 24
7243: PUSH
7244: LD_INT 1000
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PPUSH
7255: CALL_OW 72
7259: IFFALSE 7273
// Say ( JMM , D2-JMM-1 ) ;
7261: LD_EXP 15
7265: PPUSH
7266: LD_STRING D2-JMM-1
7268: PPUSH
7269: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7273: LD_EXP 15
7277: PPUSH
7278: LD_STRING D2-JMM-1b
7280: PPUSH
7281: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7285: LD_EXP 32
7289: PPUSH
7290: LD_STRING D2-Gos-1
7292: PPUSH
7293: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7297: LD_EXP 15
7301: PPUSH
7302: LD_STRING D2-JMM-2
7304: PPUSH
7305: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7309: LD_EXP 32
7313: PPUSH
7314: LD_STRING D2-Gos-2
7316: PPUSH
7317: CALL_OW 88
// end else
7321: GO 7475
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7323: LD_VAR 0 2
7327: PPUSH
7328: LD_INT 3
7330: PUSH
7331: LD_INT 24
7333: PUSH
7334: LD_INT 1000
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL_OW 72
7349: IFFALSE 7375
// begin Say ( Roth , D2-Roth-2 ) ;
7351: LD_EXP 16
7355: PPUSH
7356: LD_STRING D2-Roth-2
7358: PPUSH
7359: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7363: LD_EXP 15
7367: PPUSH
7368: LD_STRING D2-JMM-1a
7370: PPUSH
7371: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7375: LD_EXP 16
7379: PPUSH
7380: LD_STRING D2-Roth-2a
7382: PPUSH
7383: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7387: LD_EXP 16
7391: PPUSH
7392: LD_STRING D2-Roth-2b
7394: PPUSH
7395: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7399: LD_EXP 15
7403: PPUSH
7404: LD_STRING D2-JMM-3
7406: PPUSH
7407: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7411: LD_VAR 0 2
7415: PPUSH
7416: LD_INT 3
7418: PUSH
7419: LD_INT 24
7421: PUSH
7422: LD_INT 1000
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: PPUSH
7433: CALL_OW 72
7437: IFFALSE 7475
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7439: LD_EXP 32
7443: PPUSH
7444: LD_STRING D2-Gos-3
7446: PPUSH
7447: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7451: LD_EXP 15
7455: PPUSH
7456: LD_STRING D2-JMM-4
7458: PPUSH
7459: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7463: LD_EXP 32
7467: PPUSH
7468: LD_STRING D2-Gos-4
7470: PPUSH
7471: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7475: LD_EXP 15
7479: PPUSH
7480: LD_STRING D2-JMM-5
7482: PPUSH
7483: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7487: LD_EXP 32
7491: PPUSH
7492: LD_STRING D2-Gos-5
7494: PPUSH
7495: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7499: LD_EXP 15
7503: PPUSH
7504: LD_STRING D2-JMM-6
7506: PPUSH
7507: CALL_OW 88
// DialogueOff ;
7511: CALL_OW 7
// wait ( 0 0$2 ) ;
7515: LD_INT 70
7517: PPUSH
7518: CALL_OW 67
// if Kirilenkova then
7522: LD_EXP 33
7526: IFFALSE 7540
// Say ( Kirilenkova , D3-Kir-1 ) ;
7528: LD_EXP 33
7532: PPUSH
7533: LD_STRING D3-Kir-1
7535: PPUSH
7536: CALL_OW 88
// gossudarov_arrive := true ;
7540: LD_ADDR_EXP 4
7544: PUSH
7545: LD_INT 1
7547: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7548: LD_INT 35
7550: PPUSH
7551: CALL_OW 67
// until ru_lab_builded ;
7555: LD_EXP 5
7559: IFFALSE 7548
// DialogueOn ;
7561: CALL_OW 6
// if Kirilenkova then
7565: LD_EXP 33
7569: IFFALSE 7585
// Say ( Kirilenkova , D3a-Kir-1 ) else
7571: LD_EXP 33
7575: PPUSH
7576: LD_STRING D3a-Kir-1
7578: PPUSH
7579: CALL_OW 88
7583: GO 7607
// begin un := SciRu ;
7585: LD_ADDR_VAR 0 4
7589: PUSH
7590: CALL 12719 0 0
7594: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7595: LD_VAR 0 4
7599: PPUSH
7600: LD_STRING D3a-Sci1-1
7602: PPUSH
7603: CALL_OW 88
// end ; if Kirilenkova or un then
7607: LD_EXP 33
7611: PUSH
7612: LD_VAR 0 4
7616: OR
7617: IFFALSE 7631
// Say ( JMM , D3a-JMM-1 ) ;
7619: LD_EXP 15
7623: PPUSH
7624: LD_STRING D3a-JMM-1
7626: PPUSH
7627: CALL_OW 88
// DialogueOff ;
7631: CALL_OW 7
// end ;
7635: LD_VAR 0 1
7639: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7640: LD_EXP 4
7644: PUSH
7645: LD_INT 22
7647: PUSH
7648: LD_INT 7
7650: PUSH
7651: EMPTY
7652: LIST
7653: LIST
7654: PUSH
7655: LD_INT 2
7657: PUSH
7658: LD_INT 25
7660: PUSH
7661: LD_INT 1
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: LD_INT 25
7670: PUSH
7671: LD_INT 2
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: PUSH
7678: LD_INT 25
7680: PUSH
7681: LD_INT 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: LD_INT 25
7690: PUSH
7691: LD_INT 4
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: LD_INT 5
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: PUSH
7708: LD_INT 25
7710: PUSH
7711: LD_INT 8
7713: PUSH
7714: EMPTY
7715: LIST
7716: LIST
7717: PUSH
7718: LD_INT 25
7720: PUSH
7721: LD_INT 9
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: LIST
7736: LIST
7737: PUSH
7738: EMPTY
7739: LIST
7740: LIST
7741: PPUSH
7742: CALL_OW 69
7746: PUSH
7747: LD_INT 7
7749: LESS
7750: AND
7751: IFFALSE 7763
7753: GO 7755
7755: DISABLE
// YouLost ( TooMany ) ;
7756: LD_STRING TooMany
7758: PPUSH
7759: CALL_OW 104
7763: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7764: LD_EXP 32
7768: PPUSH
7769: CALL_OW 255
7773: PUSH
7774: LD_INT 7
7776: EQUAL
7777: IFFALSE 7977
7779: GO 7781
7781: DISABLE
7782: LD_INT 0
7784: PPUSH
7785: PPUSH
7786: PPUSH
// begin uc_side := 3 ;
7787: LD_ADDR_OWVAR 20
7791: PUSH
7792: LD_INT 3
7794: ST_TO_ADDR
// uc_nation := 3 ;
7795: LD_ADDR_OWVAR 21
7799: PUSH
7800: LD_INT 3
7802: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7803: LD_INT 21
7805: PPUSH
7806: LD_INT 3
7808: PPUSH
7809: LD_INT 3
7811: PPUSH
7812: LD_INT 42
7814: PPUSH
7815: LD_INT 100
7817: PPUSH
7818: CALL 19116 0 5
// un := CreateVehicle ;
7822: LD_ADDR_VAR 0 3
7826: PUSH
7827: CALL_OW 45
7831: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7832: LD_VAR 0 3
7836: PPUSH
7837: LD_INT 15
7839: PPUSH
7840: LD_INT 0
7842: PPUSH
7843: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7847: LD_VAR 0 3
7851: PPUSH
7852: LD_INT 67
7854: PPUSH
7855: LD_INT 45
7857: PPUSH
7858: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7862: LD_VAR 0 3
7866: PPUSH
7867: LD_INT 70
7869: PPUSH
7870: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7874: LD_VAR 0 3
7878: PPUSH
7879: LD_INT 69
7881: PPUSH
7882: LD_INT 18
7884: PPUSH
7885: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7889: LD_VAR 0 3
7893: PPUSH
7894: LD_INT 60
7896: PPUSH
7897: LD_INT 2
7899: PPUSH
7900: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7904: LD_INT 35
7906: PPUSH
7907: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7911: LD_VAR 0 3
7915: PPUSH
7916: CALL_OW 302
7920: NOT
7921: PUSH
7922: LD_VAR 0 3
7926: PPUSH
7927: LD_INT 17
7929: PPUSH
7930: CALL_OW 308
7934: OR
7935: IFFALSE 7904
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7937: LD_VAR 0 3
7941: PPUSH
7942: LD_INT 17
7944: PPUSH
7945: CALL_OW 308
7949: PUSH
7950: LD_VAR 0 3
7954: PPUSH
7955: LD_INT 60
7957: PPUSH
7958: LD_INT 2
7960: PPUSH
7961: CALL_OW 307
7965: OR
7966: IFFALSE 7977
// RemoveUnit ( un ) ;
7968: LD_VAR 0 3
7972: PPUSH
7973: CALL_OW 64
// end ;
7977: PPOPN 3
7979: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
7980: LD_EXP 4
7984: IFFALSE 8226
7986: GO 7988
7988: DISABLE
7989: LD_INT 0
7991: PPUSH
7992: PPUSH
7993: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7994: LD_INT 70
7996: PPUSH
7997: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8001: LD_ADDR_VAR 0 3
8005: PUSH
8006: LD_INT 22
8008: PUSH
8009: LD_INT 7
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: LD_INT 101
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: PPUSH
8030: CALL_OW 69
8034: ST_TO_ADDR
// until tmp ;
8035: LD_VAR 0 3
8039: IFFALSE 7994
// un := NearestUnitToUnit ( tmp , JMM ) ;
8041: LD_ADDR_VAR 0 2
8045: PUSH
8046: LD_VAR 0 3
8050: PPUSH
8051: LD_EXP 15
8055: PPUSH
8056: CALL_OW 74
8060: ST_TO_ADDR
// player_spotted := true ;
8061: LD_ADDR_EXP 6
8065: PUSH
8066: LD_INT 1
8068: ST_TO_ADDR
// tmp := SciRu ;
8069: LD_ADDR_VAR 0 3
8073: PUSH
8074: CALL 12719 0 0
8078: ST_TO_ADDR
// if not tmp then
8079: LD_VAR 0 3
8083: NOT
8084: IFFALSE 8096
// tmp := SolRu ;
8086: LD_ADDR_VAR 0 3
8090: PUSH
8091: CALL 12866 0 0
8095: ST_TO_ADDR
// DialogueOn ;
8096: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8100: LD_VAR 0 2
8104: PPUSH
8105: CALL_OW 250
8109: PPUSH
8110: LD_VAR 0 2
8114: PPUSH
8115: CALL_OW 251
8119: PPUSH
8120: LD_INT 7
8122: PPUSH
8123: LD_INT 8
8125: NEG
8126: PPUSH
8127: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8131: LD_VAR 0 2
8135: PPUSH
8136: CALL_OW 87
// if tmp then
8140: LD_VAR 0 3
8144: IFFALSE 8158
// Say ( tmp , D4-RSci1-1 ) ;
8146: LD_VAR 0 3
8150: PPUSH
8151: LD_STRING D4-RSci1-1
8153: PPUSH
8154: CALL_OW 88
// if Gossudarov then
8158: LD_EXP 32
8162: IFFALSE 8188
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8164: LD_EXP 32
8168: PPUSH
8169: LD_STRING D4-Gos-1
8171: PPUSH
8172: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8176: LD_EXP 15
8180: PPUSH
8181: LD_STRING D4-JMM-1
8183: PPUSH
8184: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8188: LD_VAR 0 2
8192: PPUSH
8193: CALL_OW 250
8197: PPUSH
8198: LD_VAR 0 2
8202: PPUSH
8203: CALL_OW 251
8207: PPUSH
8208: LD_INT 7
8210: PPUSH
8211: CALL_OW 331
// DialogueOff ;
8215: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8219: LD_STRING M5
8221: PPUSH
8222: CALL_OW 337
// end ;
8226: PPOPN 3
8228: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8229: LD_EXP 6
8233: IFFALSE 8822
8235: GO 8237
8237: DISABLE
8238: LD_INT 0
8240: PPUSH
8241: PPUSH
8242: PPUSH
// begin PrepareBelkov ;
8243: CALL 2092 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8247: LD_EXP 47
8251: PPUSH
8252: LD_INT 118
8254: PPUSH
8255: LD_INT 106
8257: PPUSH
8258: CALL_OW 111
// AddComHold ( Belkov ) ;
8262: LD_EXP 47
8266: PPUSH
8267: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8271: LD_INT 35
8273: PPUSH
8274: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8278: LD_EXP 47
8282: PPUSH
8283: LD_INT 118
8285: PPUSH
8286: LD_INT 106
8288: PPUSH
8289: CALL_OW 307
8293: IFFALSE 8271
// ChangeSideFog ( 4 , 7 ) ;
8295: LD_INT 4
8297: PPUSH
8298: LD_INT 7
8300: PPUSH
8301: CALL_OW 343
// if IsOk ( Belkov ) then
8305: LD_EXP 47
8309: PPUSH
8310: CALL_OW 302
8314: IFFALSE 8398
// begin InGameOn ;
8316: CALL_OW 8
// DialogueOn ;
8320: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8324: LD_EXP 47
8328: PPUSH
8329: LD_STRING D5-Bel-1
8331: PPUSH
8332: CALL_OW 94
// if Gossudarov then
8336: LD_EXP 32
8340: IFFALSE 8390
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8342: LD_EXP 32
8346: PPUSH
8347: LD_STRING D5-Gos-1
8349: PPUSH
8350: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8354: LD_EXP 15
8358: PPUSH
8359: LD_STRING D5-JMM-1
8361: PPUSH
8362: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8366: LD_EXP 32
8370: PPUSH
8371: LD_STRING D5-Gos-2
8373: PPUSH
8374: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8378: LD_EXP 15
8382: PPUSH
8383: LD_STRING D5-JMM-2
8385: PPUSH
8386: CALL_OW 88
// end ; DialogueOff ;
8390: CALL_OW 7
// InGameOff ;
8394: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8398: LD_STRING QSaveBelkov
8400: PPUSH
8401: CALL_OW 97
8405: PUSH
8406: LD_INT 1
8408: DOUBLE
8409: EQUAL
8410: IFTRUE 8414
8412: GO 8464
8414: POP
// begin DialogueOn ;
8415: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8419: LD_EXP 15
8423: PPUSH
8424: LD_STRING D5a-JMM-1
8426: PPUSH
8427: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8431: LD_EXP 47
8435: PPUSH
8436: LD_STRING D5a-Bel-1
8438: PPUSH
8439: CALL_OW 94
// DialogueOff ;
8443: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8447: LD_EXP 47
8451: PPUSH
8452: LD_INT 83
8454: PPUSH
8455: LD_INT 49
8457: PPUSH
8458: CALL_OW 111
// end ; 2 :
8462: GO 8497
8464: LD_INT 2
8466: DOUBLE
8467: EQUAL
8468: IFTRUE 8472
8470: GO 8496
8472: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8473: LD_EXP 15
8477: PPUSH
8478: LD_STRING D5a-JMM-2
8480: PPUSH
8481: CALL_OW 88
// ComHold ( Belkov ) ;
8485: LD_EXP 47
8489: PPUSH
8490: CALL_OW 140
// end ; end ;
8494: GO 8497
8496: POP
// time := 0 0$00 ;
8497: LD_ADDR_VAR 0 1
8501: PUSH
8502: LD_INT 0
8504: ST_TO_ADDR
// vehSpawned := false ;
8505: LD_ADDR_VAR 0 3
8509: PUSH
8510: LD_INT 0
8512: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8513: LD_INT 35
8515: PPUSH
8516: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8520: LD_VAR 0 1
8524: PUSH
8525: LD_INT 350
8527: PUSH
8528: LD_INT 175
8530: PUSH
8531: LD_INT 70
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: LIST
8538: PUSH
8539: LD_OWVAR 67
8543: ARRAY
8544: GREATEREQUAL
8545: PUSH
8546: LD_VAR 0 3
8550: NOT
8551: AND
8552: IFFALSE 8642
// begin vehSpawned := true ;
8554: LD_ADDR_VAR 0 3
8558: PUSH
8559: LD_INT 1
8561: ST_TO_ADDR
// uc_side := 3 ;
8562: LD_ADDR_OWVAR 20
8566: PUSH
8567: LD_INT 3
8569: ST_TO_ADDR
// uc_nation := 3 ;
8570: LD_ADDR_OWVAR 21
8574: PUSH
8575: LD_INT 3
8577: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8578: LD_INT 22
8580: PPUSH
8581: LD_INT 3
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: LD_INT 43
8589: PPUSH
8590: LD_INT 100
8592: PPUSH
8593: CALL 19116 0 5
// veh := CreateVehicle ;
8597: LD_ADDR_VAR 0 2
8601: PUSH
8602: CALL_OW 45
8606: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8607: LD_VAR 0 2
8611: PPUSH
8612: LD_INT 130
8614: PPUSH
8615: LD_INT 131
8617: PPUSH
8618: LD_INT 0
8620: PPUSH
8621: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8625: LD_VAR 0 2
8629: PPUSH
8630: LD_INT 100
8632: PPUSH
8633: LD_INT 82
8635: PPUSH
8636: CALL_OW 114
// end else
8640: GO 8656
// time := time + 0 0$1 ;
8642: LD_ADDR_VAR 0 1
8646: PUSH
8647: LD_VAR 0 1
8651: PUSH
8652: LD_INT 35
8654: PLUS
8655: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8656: LD_EXP 47
8660: PPUSH
8661: CALL_OW 301
8665: PUSH
8666: LD_EXP 47
8670: PPUSH
8671: CALL_OW 255
8675: PUSH
8676: LD_INT 4
8678: EQUAL
8679: AND
8680: PUSH
8681: LD_INT 22
8683: PUSH
8684: LD_INT 7
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: PPUSH
8691: CALL_OW 69
8695: PPUSH
8696: LD_EXP 47
8700: PPUSH
8701: CALL_OW 74
8705: PPUSH
8706: LD_EXP 47
8710: PPUSH
8711: CALL_OW 296
8715: PUSH
8716: LD_INT 10
8718: LESS
8719: OR
8720: IFFALSE 8513
// if IsDead ( Belkov ) then
8722: LD_EXP 47
8726: PPUSH
8727: CALL_OW 301
8731: IFFALSE 8756
// begin CenterNowOnUnits ( Belkov ) ;
8733: LD_EXP 47
8737: PPUSH
8738: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8742: LD_EXP 15
8746: PPUSH
8747: LD_STRING D5a-JMM-2a
8749: PPUSH
8750: CALL_OW 88
// exit ;
8754: GO 8822
// end ; if See ( 7 , Belkov ) then
8756: LD_INT 7
8758: PPUSH
8759: LD_EXP 47
8763: PPUSH
8764: CALL_OW 292
8768: IFFALSE 8782
// SetSide ( Belkov , 7 ) ;
8770: LD_EXP 47
8774: PPUSH
8775: LD_INT 7
8777: PPUSH
8778: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8782: LD_INT 35
8784: PPUSH
8785: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8789: LD_EXP 47
8793: PPUSH
8794: LD_INT 66
8796: PPUSH
8797: LD_INT 45
8799: PPUSH
8800: CALL_OW 297
8804: PUSH
8805: LD_INT 30
8807: LESS
8808: IFFALSE 8782
// Say ( Belkov , D6-Bel-1 ) ;
8810: LD_EXP 47
8814: PPUSH
8815: LD_STRING D6-Bel-1
8817: PPUSH
8818: CALL_OW 88
// end ;
8822: PPOPN 3
8824: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8825: LD_EXP 47
8829: PPUSH
8830: CALL_OW 302
8834: PUSH
8835: LD_EXP 47
8839: PPUSH
8840: CALL_OW 504
8844: PUSH
8845: LD_INT 2
8847: PUSH
8848: LD_INT 34
8850: PUSH
8851: LD_INT 47
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PUSH
8858: LD_INT 34
8860: PUSH
8861: LD_INT 45
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: LIST
8872: PPUSH
8873: CALL_OW 69
8877: IN
8878: AND
8879: IFFALSE 8896
8881: GO 8883
8883: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8884: LD_EXP 47
8888: PPUSH
8889: LD_STRING D7-Bel-1
8891: PPUSH
8892: CALL_OW 88
8896: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8897: LD_INT 22
8899: PUSH
8900: LD_INT 7
8902: PUSH
8903: EMPTY
8904: LIST
8905: LIST
8906: PUSH
8907: LD_INT 101
8909: PUSH
8910: LD_INT 2
8912: PUSH
8913: EMPTY
8914: LIST
8915: LIST
8916: PUSH
8917: EMPTY
8918: LIST
8919: LIST
8920: PPUSH
8921: CALL_OW 69
8925: PUSH
8926: LD_EXP 8
8930: NOT
8931: AND
8932: PUSH
8933: LD_EXP 46
8937: PPUSH
8938: CALL_OW 305
8942: NOT
8943: AND
8944: IFFALSE 9414
8946: GO 8948
8948: DISABLE
8949: LD_INT 0
8951: PPUSH
// begin ar_base_spotted := true ;
8952: LD_ADDR_EXP 8
8956: PUSH
8957: LD_INT 1
8959: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8960: LD_ADDR_VAR 0 1
8964: PUSH
8965: LD_INT 22
8967: PUSH
8968: LD_INT 2
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PUSH
8975: LD_INT 21
8977: PUSH
8978: LD_INT 3
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: PPUSH
8989: CALL_OW 69
8993: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8994: LD_ADDR_VAR 0 1
8998: PUSH
8999: LD_VAR 0 1
9003: PPUSH
9004: LD_EXP 15
9008: PPUSH
9009: CALL_OW 74
9013: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9014: LD_INT 7
9016: PPUSH
9017: LD_INT 3
9019: PPUSH
9020: CALL_OW 332
// DialogueOn ;
9024: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9028: LD_VAR 0 1
9032: PPUSH
9033: CALL_OW 250
9037: PPUSH
9038: LD_VAR 0 1
9042: PPUSH
9043: CALL_OW 251
9047: PPUSH
9048: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9052: LD_ADDR_VAR 0 1
9056: PUSH
9057: LD_INT 22
9059: PUSH
9060: LD_INT 7
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: PUSH
9067: LD_INT 23
9069: PUSH
9070: LD_INT 1
9072: PUSH
9073: EMPTY
9074: LIST
9075: LIST
9076: PUSH
9077: LD_INT 26
9079: PUSH
9080: LD_INT 1
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: LIST
9091: PPUSH
9092: CALL_OW 69
9096: PUSH
9097: LD_EXP 15
9101: PUSH
9102: LD_EXP 19
9106: PUSH
9107: LD_EXP 20
9111: PUSH
9112: LD_EXP 27
9116: PUSH
9117: LD_EXP 16
9121: PUSH
9122: LD_EXP 25
9126: PUSH
9127: LD_EXP 21
9131: PUSH
9132: LD_EXP 23
9136: PUSH
9137: EMPTY
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: DIFF
9147: ST_TO_ADDR
// if not tmp then
9148: LD_VAR 0 1
9152: NOT
9153: IFFALSE 9227
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9155: LD_ADDR_VAR 0 1
9159: PUSH
9160: LD_INT 22
9162: PUSH
9163: LD_INT 7
9165: PUSH
9166: EMPTY
9167: LIST
9168: LIST
9169: PUSH
9170: LD_INT 23
9172: PUSH
9173: LD_INT 1
9175: PUSH
9176: EMPTY
9177: LIST
9178: LIST
9179: PUSH
9180: LD_INT 26
9182: PUSH
9183: LD_INT 2
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: LIST
9194: PPUSH
9195: CALL_OW 69
9199: PUSH
9200: LD_EXP 30
9204: PUSH
9205: LD_EXP 17
9209: PUSH
9210: LD_EXP 28
9214: PUSH
9215: LD_EXP 29
9219: PUSH
9220: EMPTY
9221: LIST
9222: LIST
9223: LIST
9224: LIST
9225: DIFF
9226: ST_TO_ADDR
// if tmp then
9227: LD_VAR 0 1
9231: IFFALSE 9302
// case GetSex ( tmp [ 1 ] ) of sex_male :
9233: LD_VAR 0 1
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: CALL_OW 258
9246: PUSH
9247: LD_INT 1
9249: DOUBLE
9250: EQUAL
9251: IFTRUE 9255
9253: GO 9274
9255: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9256: LD_VAR 0 1
9260: PUSH
9261: LD_INT 1
9263: ARRAY
9264: PPUSH
9265: LD_STRING D9-Sol1-1
9267: PPUSH
9268: CALL_OW 88
9272: GO 9302
9274: LD_INT 2
9276: DOUBLE
9277: EQUAL
9278: IFTRUE 9282
9280: GO 9301
9282: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9283: LD_VAR 0 1
9287: PUSH
9288: LD_INT 1
9290: ARRAY
9291: PPUSH
9292: LD_STRING D9-FSol1-1
9294: PPUSH
9295: CALL_OW 88
9299: GO 9302
9301: POP
// if Frank then
9302: LD_EXP 27
9306: IFFALSE 9410
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9308: LD_EXP 56
9312: PPUSH
9313: CALL_OW 250
9317: PPUSH
9318: LD_EXP 56
9322: PPUSH
9323: CALL_OW 251
9327: PPUSH
9328: LD_INT 7
9330: PPUSH
9331: LD_INT 8
9333: PPUSH
9334: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9338: LD_EXP 56
9342: PPUSH
9343: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9347: LD_EXP 27
9351: PPUSH
9352: LD_STRING D9-Frank-1
9354: PPUSH
9355: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9359: LD_EXP 15
9363: PPUSH
9364: LD_STRING D9-JMM-1
9366: PPUSH
9367: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9371: LD_EXP 27
9375: PPUSH
9376: LD_STRING D9-Frank-2
9378: PPUSH
9379: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9383: LD_EXP 56
9387: PPUSH
9388: CALL_OW 250
9392: PPUSH
9393: LD_EXP 56
9397: PPUSH
9398: CALL_OW 251
9402: PPUSH
9403: LD_INT 7
9405: PPUSH
9406: CALL_OW 331
// end ; DialogueOff ;
9410: CALL_OW 7
// end ;
9414: PPOPN 1
9416: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9417: LD_EXP 7
9421: PUSH
9422: LD_OWVAR 1
9426: PUSH
9427: LD_INT 42000
9429: GREATEREQUAL
9430: OR
9431: IFFALSE 10458
9433: GO 9435
9435: DISABLE
9436: LD_INT 0
9438: PPUSH
9439: PPUSH
// begin selected_option := 1 ;
9440: LD_ADDR_VAR 0 2
9444: PUSH
9445: LD_INT 1
9447: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9448: LD_INT 10500
9450: PPUSH
9451: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9455: LD_INT 35
9457: PPUSH
9458: CALL_OW 67
// until not ru_attackers ;
9462: LD_EXP 52
9466: NOT
9467: IFFALSE 9455
// PrepareBurlak ;
9469: CALL 2204 0 0
// repeat wait ( 0 0$2 ) ;
9473: LD_INT 70
9475: PPUSH
9476: CALL_OW 67
// until not HasTask ( Burlak ) ;
9480: LD_EXP 46
9484: PPUSH
9485: CALL_OW 314
9489: NOT
9490: IFFALSE 9473
// InGameOn ;
9492: CALL_OW 8
// DialogueOn ;
9496: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9500: LD_EXP 49
9504: PPUSH
9505: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9509: LD_EXP 46
9513: PPUSH
9514: LD_STRING D10-Bur-1
9516: PPUSH
9517: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9521: LD_EXP 47
9525: PUSH
9526: LD_EXP 47
9530: PPUSH
9531: CALL_OW 255
9535: PUSH
9536: LD_INT 7
9538: EQUAL
9539: AND
9540: IFFALSE 9554
// Say ( Belkov , D10-Bel-1 ) ;
9542: LD_EXP 47
9546: PPUSH
9547: LD_STRING D10-Bel-1
9549: PPUSH
9550: CALL_OW 88
// if Gossudarov then
9554: LD_EXP 32
9558: IFFALSE 9572
// Say ( Gossudarov , D10-Gos-1 ) ;
9560: LD_EXP 32
9564: PPUSH
9565: LD_STRING D10-Gos-1
9567: PPUSH
9568: CALL_OW 88
// if Kirilenkova then
9572: LD_EXP 33
9576: IFFALSE 9590
// Say ( Kirilenkova , D10-Kir-1 ) ;
9578: LD_EXP 33
9582: PPUSH
9583: LD_STRING D10-Kir-1
9585: PPUSH
9586: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9590: CALL 12866 0 0
9594: PPUSH
9595: LD_STRING D10-RSol1-1
9597: PPUSH
9598: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9602: LD_EXP 46
9606: PPUSH
9607: LD_STRING D10-Bur-2
9609: PPUSH
9610: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9614: LD_EXP 15
9618: PPUSH
9619: LD_STRING D10-JMM-2
9621: PPUSH
9622: CALL_OW 88
// if Kirilenkova then
9626: LD_EXP 33
9630: IFFALSE 9646
// Say ( Kirilenkova , D10-Kir-2 ) else
9632: LD_EXP 33
9636: PPUSH
9637: LD_STRING D10-Kir-2
9639: PPUSH
9640: CALL_OW 88
9644: GO 9658
// Say ( SolRu , D10-RSol1-2 ) ;
9646: CALL 12866 0 0
9650: PPUSH
9651: LD_STRING D10-RSol1-2
9653: PPUSH
9654: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9658: LD_EXP 15
9662: PPUSH
9663: LD_STRING D10-JMM-3
9665: PPUSH
9666: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9670: LD_EXP 46
9674: PPUSH
9675: LD_STRING D10-Bur-3
9677: PPUSH
9678: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9682: LD_EXP 15
9686: PPUSH
9687: LD_STRING D10-JMM-4
9689: PPUSH
9690: CALL_OW 88
// DialogueOff ;
9694: CALL_OW 7
// InGameOff ;
9698: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9702: LD_STRING M2
9704: PPUSH
9705: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9709: LD_INT 35
9711: PPUSH
9712: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9716: LD_INT 22
9718: PUSH
9719: LD_INT 7
9721: PUSH
9722: EMPTY
9723: LIST
9724: LIST
9725: PUSH
9726: LD_INT 91
9728: PUSH
9729: LD_EXP 46
9733: PUSH
9734: LD_INT 8
9736: PUSH
9737: EMPTY
9738: LIST
9739: LIST
9740: LIST
9741: PUSH
9742: EMPTY
9743: LIST
9744: LIST
9745: PPUSH
9746: CALL_OW 69
9750: IFFALSE 9709
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9752: LD_ADDR_VAR 0 1
9756: PUSH
9757: LD_INT 22
9759: PUSH
9760: LD_INT 4
9762: PUSH
9763: EMPTY
9764: LIST
9765: LIST
9766: PPUSH
9767: CALL_OW 69
9771: PUSH
9772: FOR_IN
9773: IFFALSE 9789
// SetSide ( i , 7 ) ;
9775: LD_VAR 0 1
9779: PPUSH
9780: LD_INT 7
9782: PPUSH
9783: CALL_OW 235
9787: GO 9772
9789: POP
9790: POP
// ChangeMissionObjectives ( M3 ) ;
9791: LD_STRING M3
9793: PPUSH
9794: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9798: LD_INT 35
9800: PPUSH
9801: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9805: LD_EXP 15
9809: PPUSH
9810: LD_EXP 46
9814: PPUSH
9815: CALL_OW 296
9819: PUSH
9820: LD_INT 8
9822: LESS
9823: IFFALSE 9798
// ComTurnUnit ( JMM , Burlak ) ;
9825: LD_EXP 15
9829: PPUSH
9830: LD_EXP 46
9834: PPUSH
9835: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9839: LD_EXP 46
9843: PPUSH
9844: LD_EXP 15
9848: PPUSH
9849: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9853: LD_INT 10
9855: PPUSH
9856: CALL_OW 67
// DialogueOn ;
9860: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9864: LD_EXP 15
9868: PPUSH
9869: LD_STRING D11-JMM-1
9871: PPUSH
9872: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9876: LD_EXP 46
9880: PPUSH
9881: LD_STRING D11-Bur-1
9883: PPUSH
9884: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9888: LD_EXP 15
9892: PPUSH
9893: LD_STRING D11-JMM-2
9895: PPUSH
9896: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9900: LD_EXP 46
9904: PPUSH
9905: LD_STRING D11-Bur-2
9907: PPUSH
9908: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9912: LD_EXP 15
9916: PPUSH
9917: LD_STRING D11-JMM-3
9919: PPUSH
9920: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9924: LD_EXP 46
9928: PPUSH
9929: LD_STRING D11-Bur-3
9931: PPUSH
9932: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9936: LD_EXP 15
9940: PPUSH
9941: LD_STRING D11-JMM-4
9943: PPUSH
9944: CALL_OW 88
// if ar_base_spotted then
9948: LD_EXP 8
9952: IFFALSE 9968
// Say ( Burlak , D12-Bur-1 ) else
9954: LD_EXP 46
9958: PPUSH
9959: LD_STRING D12-Bur-1
9961: PPUSH
9962: CALL_OW 88
9966: GO 10007
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9968: LD_INT 7
9970: PPUSH
9971: LD_INT 3
9973: PPUSH
9974: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9978: LD_INT 127
9980: PPUSH
9981: LD_INT 45
9983: PPUSH
9984: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9988: LD_EXP 46
9992: PPUSH
9993: LD_STRING D12-Bur-1a
9995: PPUSH
9996: CALL_OW 88
// dwait ( 0 0$2 ) ;
10000: LD_INT 70
10002: PPUSH
10003: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10007: LD_EXP 46
10011: PPUSH
10012: LD_STRING D12-Bur-1b
10014: PPUSH
10015: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10019: LD_EXP 15
10023: PPUSH
10024: LD_STRING D12-JMM-1
10026: PPUSH
10027: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10031: LD_EXP 46
10035: PPUSH
10036: LD_STRING D12-Bur-2
10038: PPUSH
10039: CALL_OW 88
// if Roth then
10043: LD_EXP 16
10047: IFFALSE 10063
// Say ( Roth , D12-Roth-2 ) else
10049: LD_EXP 16
10053: PPUSH
10054: LD_STRING D12-Roth-2
10056: PPUSH
10057: CALL_OW 88
10061: GO 10075
// Say ( SciRu , D12-RSci1-2 ) ;
10063: CALL 12719 0 0
10067: PPUSH
10068: LD_STRING D12-RSci1-2
10070: PPUSH
10071: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10075: LD_EXP 15
10079: PPUSH
10080: LD_STRING D12-JMM-2
10082: PPUSH
10083: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10087: LD_EXP 46
10091: PPUSH
10092: LD_STRING D12-Bur-3
10094: PPUSH
10095: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10099: LD_EXP 15
10103: PPUSH
10104: LD_STRING D12-JMM-3
10106: PPUSH
10107: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10111: LD_EXP 46
10115: PPUSH
10116: LD_STRING D12-Bur-4
10118: PPUSH
10119: CALL_OW 88
// case Query ( QBase ) of 1 :
10123: LD_STRING QBase
10125: PPUSH
10126: CALL_OW 97
10130: PUSH
10131: LD_INT 1
10133: DOUBLE
10134: EQUAL
10135: IFTRUE 10139
10137: GO 10257
10139: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10140: LD_EXP 15
10144: PPUSH
10145: LD_STRING D13a-JMM-1
10147: PPUSH
10148: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10152: LD_EXP 46
10156: PPUSH
10157: LD_STRING D13a-Bur-1
10159: PPUSH
10160: CALL_OW 88
// if Roth then
10164: LD_EXP 16
10168: IFFALSE 10184
// Say ( Roth , D13a-Roth-1 ) else
10170: LD_EXP 16
10174: PPUSH
10175: LD_STRING D13a-Roth-1
10177: PPUSH
10178: CALL_OW 88
10182: GO 10196
// Say ( SciRu , D13a-RSci1-1 ) ;
10184: CALL 12719 0 0
10188: PPUSH
10189: LD_STRING D13a-RSci1-1
10191: PPUSH
10192: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10196: LD_EXP 15
10200: PPUSH
10201: LD_STRING D13a-JMM-2
10203: PPUSH
10204: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10208: LD_STRING QBaseAgain
10210: PPUSH
10211: CALL_OW 97
10215: PUSH
10216: LD_INT 1
10218: DOUBLE
10219: EQUAL
10220: IFTRUE 10224
10222: GO 10235
10224: POP
// selected_option := 2 ; 2 :
10225: LD_ADDR_VAR 0 2
10229: PUSH
10230: LD_INT 2
10232: ST_TO_ADDR
10233: GO 10255
10235: LD_INT 2
10237: DOUBLE
10238: EQUAL
10239: IFTRUE 10243
10241: GO 10254
10243: POP
// selected_option := 3 ; end ;
10244: LD_ADDR_VAR 0 2
10248: PUSH
10249: LD_INT 3
10251: ST_TO_ADDR
10252: GO 10255
10254: POP
// end ; 2 :
10255: GO 10296
10257: LD_INT 2
10259: DOUBLE
10260: EQUAL
10261: IFTRUE 10265
10263: GO 10276
10265: POP
// selected_option := 2 ; 3 :
10266: LD_ADDR_VAR 0 2
10270: PUSH
10271: LD_INT 2
10273: ST_TO_ADDR
10274: GO 10296
10276: LD_INT 3
10278: DOUBLE
10279: EQUAL
10280: IFTRUE 10284
10282: GO 10295
10284: POP
// selected_option := 3 ; end ;
10285: LD_ADDR_VAR 0 2
10289: PUSH
10290: LD_INT 3
10292: ST_TO_ADDR
10293: GO 10296
10295: POP
// if selected_option = 2 then
10296: LD_VAR 0 2
10300: PUSH
10301: LD_INT 2
10303: EQUAL
10304: IFFALSE 10398
// begin Say ( JMM , D13b-JMM-1 ) ;
10306: LD_EXP 15
10310: PPUSH
10311: LD_STRING D13b-JMM-1
10313: PPUSH
10314: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10318: LD_EXP 46
10322: PPUSH
10323: LD_STRING D13b-Bur-1
10325: PPUSH
10326: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10330: LD_EXP 15
10334: PPUSH
10335: LD_STRING D13b-JMM-2
10337: PPUSH
10338: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10342: LD_EXP 55
10346: PPUSH
10347: LD_STRING D13b-Abd-2
10349: PPUSH
10350: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10354: LD_EXP 15
10358: PPUSH
10359: LD_STRING D13b-JMM-3
10361: PPUSH
10362: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10366: LD_EXP 55
10370: PPUSH
10371: LD_STRING D13b-Abd-3
10373: PPUSH
10374: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10378: LD_EXP 15
10382: PPUSH
10383: LD_STRING D13b-JMM-4
10385: PPUSH
10386: CALL_OW 88
// ar_active_attack := true ;
10390: LD_ADDR_EXP 9
10394: PUSH
10395: LD_INT 1
10397: ST_TO_ADDR
// end ; if selected_option = 3 then
10398: LD_VAR 0 2
10402: PUSH
10403: LD_INT 3
10405: EQUAL
10406: IFFALSE 10432
// begin Say ( JMM , D13c-JMM-1 ) ;
10408: LD_EXP 15
10412: PPUSH
10413: LD_STRING D13c-JMM-1
10415: PPUSH
10416: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10420: LD_EXP 46
10424: PPUSH
10425: LD_STRING D13c-Bur-1
10427: PPUSH
10428: CALL_OW 88
// end ; DialogueOff ;
10432: CALL_OW 7
// if not ar_active_attack then
10436: LD_EXP 9
10440: NOT
10441: IFFALSE 10458
// begin wait ( 6 6$00 ) ;
10443: LD_INT 12600
10445: PPUSH
10446: CALL_OW 67
// ar_active_attack := true ;
10450: LD_ADDR_EXP 9
10454: PUSH
10455: LD_INT 1
10457: ST_TO_ADDR
// end ; end ;
10458: PPOPN 2
10460: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10461: LD_EXP 46
10465: PPUSH
10466: CALL_OW 305
10470: PUSH
10471: LD_EXP 46
10475: PPUSH
10476: CALL_OW 255
10480: PUSH
10481: LD_INT 7
10483: EQUAL
10484: AND
10485: IFFALSE 10681
10487: GO 10489
10489: DISABLE
10490: LD_INT 0
10492: PPUSH
// begin wait ( 4 4$40 ) ;
10493: LD_INT 9800
10495: PPUSH
10496: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10500: LD_INT 35
10502: PPUSH
10503: CALL_OW 67
// until not ru_attackers ;
10507: LD_EXP 52
10511: NOT
10512: IFFALSE 10500
// PrepareGnyevko ;
10514: CALL 2148 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10518: LD_EXP 48
10522: PPUSH
10523: LD_INT 124
10525: PPUSH
10526: LD_INT 118
10528: PPUSH
10529: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10533: LD_EXP 48
10537: PPUSH
10538: CALL_OW 200
// time := 0 0$00 ;
10542: LD_ADDR_VAR 0 1
10546: PUSH
10547: LD_INT 0
10549: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10550: LD_INT 35
10552: PPUSH
10553: CALL_OW 67
// time := time + 0 0$1 ;
10557: LD_ADDR_VAR 0 1
10561: PUSH
10562: LD_VAR 0 1
10566: PUSH
10567: LD_INT 35
10569: PLUS
10570: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10571: LD_EXP 48
10575: PPUSH
10576: LD_INT 124
10578: PPUSH
10579: LD_INT 118
10581: PPUSH
10582: CALL_OW 307
10586: PUSH
10587: LD_VAR 0 1
10591: PUSH
10592: LD_INT 1050
10594: GREATEREQUAL
10595: OR
10596: IFFALSE 10550
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10598: LD_EXP 48
10602: PPUSH
10603: LD_STRING DBelkov-Gny-1
10605: PPUSH
10606: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10610: LD_EXP 46
10614: PPUSH
10615: LD_STRING DBelkov-Bur-1a
10617: PPUSH
10618: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10622: LD_INT 35
10624: PPUSH
10625: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10629: LD_EXP 48
10633: PPUSH
10634: LD_INT 22
10636: PUSH
10637: LD_INT 7
10639: PUSH
10640: EMPTY
10641: LIST
10642: LIST
10643: PPUSH
10644: CALL_OW 69
10648: PPUSH
10649: LD_EXP 48
10653: PPUSH
10654: CALL_OW 74
10658: PPUSH
10659: CALL_OW 296
10663: PUSH
10664: LD_INT 8
10666: LESS
10667: IFFALSE 10622
// SetSide ( Gnyevko , 7 ) ;
10669: LD_EXP 48
10673: PPUSH
10674: LD_INT 7
10676: PPUSH
10677: CALL_OW 235
// end ;
10681: PPOPN 1
10683: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10684: LD_EXP 46
10688: PPUSH
10689: CALL_OW 255
10693: PUSH
10694: LD_INT 7
10696: EQUAL
10697: IFFALSE 10707
10699: GO 10701
10701: DISABLE
// begin enable ;
10702: ENABLE
// PrepareAmericanAttack ;
10703: CALL 6523 0 0
// end ;
10707: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10708: LD_INT 22
10710: PUSH
10711: LD_INT 1
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: PPUSH
10718: CALL_OW 69
10722: IFFALSE 10906
10724: GO 10726
10726: DISABLE
10727: LD_INT 0
10729: PPUSH
10730: PPUSH
// begin while true do
10731: LD_INT 1
10733: IFFALSE 10790
// begin wait ( 0 0$1 ) ;
10735: LD_INT 35
10737: PPUSH
10738: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10742: LD_ADDR_VAR 0 2
10746: PUSH
10747: LD_INT 22
10749: PUSH
10750: LD_INT 1
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: PPUSH
10757: CALL_OW 69
10761: PPUSH
10762: LD_EXP 15
10766: PPUSH
10767: CALL_OW 74
10771: ST_TO_ADDR
// if See ( 7 , tmp ) then
10772: LD_INT 7
10774: PPUSH
10775: LD_VAR 0 2
10779: PPUSH
10780: CALL_OW 292
10784: IFFALSE 10788
// break ;
10786: GO 10790
// end ;
10788: GO 10731
// DialogueOn ;
10790: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10794: LD_VAR 0 2
10798: PPUSH
10799: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10803: LD_VAR 0 2
10807: PPUSH
10808: CALL_OW 250
10812: PPUSH
10813: LD_VAR 0 2
10817: PPUSH
10818: CALL_OW 251
10822: PPUSH
10823: LD_INT 7
10825: PPUSH
10826: LD_INT 8
10828: PPUSH
10829: CALL_OW 330
// if Denis then
10833: LD_EXP 21
10837: IFFALSE 10851
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10839: LD_EXP 21
10843: PPUSH
10844: LD_STRING DAmerAttack-Pet-1
10846: PPUSH
10847: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10851: LD_EXP 15
10855: PPUSH
10856: LD_STRING DAmerAttack-JMM-1
10858: PPUSH
10859: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10863: LD_EXP 46
10867: PPUSH
10868: LD_STRING DStop-Bur-1
10870: PPUSH
10871: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10875: LD_VAR 0 2
10879: PPUSH
10880: CALL_OW 250
10884: PPUSH
10885: LD_VAR 0 2
10889: PPUSH
10890: CALL_OW 251
10894: PPUSH
10895: LD_INT 7
10897: PPUSH
10898: CALL_OW 331
// DialogueOff ;
10902: CALL_OW 7
// end ;
10906: PPOPN 2
10908: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10909: LD_INT 22
10911: PUSH
10912: LD_INT 3
10914: PUSH
10915: EMPTY
10916: LIST
10917: LIST
10918: PUSH
10919: LD_INT 21
10921: PUSH
10922: LD_INT 1
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: PUSH
10929: EMPTY
10930: LIST
10931: LIST
10932: PPUSH
10933: CALL_OW 69
10937: PUSH
10938: LD_INT 0
10940: EQUAL
10941: IFFALSE 10983
10943: GO 10945
10945: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10946: LD_STRING M5a
10948: PPUSH
10949: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10953: LD_EXP 15
10957: PPUSH
10958: LD_STRING D8-JMM-1
10960: PPUSH
10961: CALL_OW 88
// if Gossudarov then
10965: LD_EXP 32
10969: IFFALSE 10983
// Say ( Gossudarov , D8-Gos-1 ) ;
10971: LD_EXP 32
10975: PPUSH
10976: LD_STRING D8-Gos-1
10978: PPUSH
10979: CALL_OW 88
// end ;
10983: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10984: LD_INT 22
10986: PUSH
10987: LD_INT 2
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: PUSH
10994: LD_INT 21
10996: PUSH
10997: LD_INT 1
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: PPUSH
11008: CALL_OW 69
11012: PUSH
11013: LD_INT 0
11015: EQUAL
11016: IFFALSE 11066
11018: GO 11020
11020: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11021: LD_STRING M4c
11023: PPUSH
11024: CALL_OW 337
// if Roth then
11028: LD_EXP 16
11032: IFFALSE 11048
// Say ( Roth , DStop-Roth-1 ) else
11034: LD_EXP 16
11038: PPUSH
11039: LD_STRING DStop-Roth-1
11041: PPUSH
11042: CALL_OW 88
11046: GO 11066
// if Gossudarov then
11048: LD_EXP 32
11052: IFFALSE 11066
// Say ( Gossudarov , D8-Gos-1a ) ;
11054: LD_EXP 32
11058: PPUSH
11059: LD_STRING D8-Gos-1a
11061: PPUSH
11062: CALL_OW 88
// end ;
11066: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11067: LD_INT 7
11069: PPUSH
11070: LD_INT 1
11072: PPUSH
11073: LD_INT 1
11075: PPUSH
11076: CALL 14355 0 3
11080: PUSH
11081: LD_INT 0
11083: EQUAL
11084: PUSH
11085: LD_INT 7
11087: PPUSH
11088: LD_INT 3
11090: PPUSH
11091: LD_INT 1
11093: PPUSH
11094: CALL 14355 0 3
11098: PUSH
11099: LD_INT 0
11101: EQUAL
11102: AND
11103: IFFALSE 11115
11105: GO 11107
11107: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11108: LD_STRING M1a
11110: PPUSH
11111: CALL_OW 337
// end ;
11115: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11116: LD_INT 22
11118: PUSH
11119: LD_INT 2
11121: PUSH
11122: EMPTY
11123: LIST
11124: LIST
11125: PUSH
11126: LD_INT 21
11128: PUSH
11129: LD_INT 1
11131: PUSH
11132: EMPTY
11133: LIST
11134: LIST
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: PPUSH
11140: CALL_OW 69
11144: PUSH
11145: LD_INT 0
11147: EQUAL
11148: PUSH
11149: LD_INT 22
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: EMPTY
11156: LIST
11157: LIST
11158: PUSH
11159: LD_INT 21
11161: PUSH
11162: LD_INT 1
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: PPUSH
11173: CALL_OW 69
11177: PUSH
11178: LD_INT 0
11180: EQUAL
11181: AND
11182: PUSH
11183: LD_INT 22
11185: PUSH
11186: LD_INT 1
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: PPUSH
11193: CALL_OW 69
11197: PUSH
11198: LD_INT 0
11200: EQUAL
11201: AND
11202: PUSH
11203: LD_INT 7
11205: PPUSH
11206: LD_INT 1
11208: PPUSH
11209: LD_INT 1
11211: PPUSH
11212: CALL 14355 0 3
11216: PUSH
11217: LD_INT 0
11219: EQUAL
11220: AND
11221: PUSH
11222: LD_INT 7
11224: PPUSH
11225: LD_INT 3
11227: PPUSH
11228: LD_INT 1
11230: PPUSH
11231: CALL 14355 0 3
11235: PUSH
11236: LD_INT 0
11238: EQUAL
11239: AND
11240: IFFALSE 12716
11242: GO 11244
11244: DISABLE
11245: LD_INT 0
11247: PPUSH
11248: PPUSH
11249: PPUSH
11250: PPUSH
11251: PPUSH
11252: PPUSH
// begin m1 := false ;
11253: LD_ADDR_VAR 0 4
11257: PUSH
11258: LD_INT 0
11260: ST_TO_ADDR
// m2 := false ;
11261: LD_ADDR_VAR 0 5
11265: PUSH
11266: LD_INT 0
11268: ST_TO_ADDR
// m3 := false ;
11269: LD_ADDR_VAR 0 6
11273: PUSH
11274: LD_INT 0
11276: ST_TO_ADDR
// if tick < 40 40$00 then
11277: LD_OWVAR 1
11281: PUSH
11282: LD_INT 84000
11284: LESS
11285: IFFALSE 11294
// SetAchievement ( ACH_ASPEED_17 ) ;
11287: LD_STRING ACH_ASPEED_17
11289: PPUSH
11290: CALL_OW 543
// wait ( 0 0$1 ) ;
11294: LD_INT 35
11296: PPUSH
11297: CALL_OW 67
// if not IsDead ( Masha ) then
11301: LD_EXP 49
11305: PPUSH
11306: CALL_OW 301
11310: NOT
11311: IFFALSE 11333
// begin m1 := true ;
11313: LD_ADDR_VAR 0 4
11317: PUSH
11318: LD_INT 1
11320: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11321: LD_STRING Masha
11323: PPUSH
11324: LD_INT 1
11326: PPUSH
11327: CALL_OW 101
// end else
11331: GO 11344
// AddMedal ( Masha , - 1 ) ;
11333: LD_STRING Masha
11335: PPUSH
11336: LD_INT 1
11338: NEG
11339: PPUSH
11340: CALL_OW 101
// if abdul_escaped then
11344: LD_EXP 12
11348: IFFALSE 11363
// AddMedal ( Abdul , - 1 ) else
11350: LD_STRING Abdul
11352: PPUSH
11353: LD_INT 1
11355: NEG
11356: PPUSH
11357: CALL_OW 101
11361: GO 11381
// begin m2 := true ;
11363: LD_ADDR_VAR 0 5
11367: PUSH
11368: LD_INT 1
11370: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11371: LD_STRING Abdul
11373: PPUSH
11374: LD_INT 1
11376: PPUSH
11377: CALL_OW 101
// end ; if loss_counter = 0 then
11381: LD_EXP 13
11385: PUSH
11386: LD_INT 0
11388: EQUAL
11389: IFFALSE 11411
// begin m3 := true ;
11391: LD_ADDR_VAR 0 6
11395: PUSH
11396: LD_INT 1
11398: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11399: LD_STRING People
11401: PPUSH
11402: LD_INT 2
11404: PPUSH
11405: CALL_OW 101
// end else
11409: GO 11469
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11411: LD_EXP 13
11415: PUSH
11416: LD_INT 3
11418: PUSH
11419: LD_INT 2
11421: PUSH
11422: LD_INT 2
11424: PUSH
11425: EMPTY
11426: LIST
11427: LIST
11428: LIST
11429: PUSH
11430: LD_OWVAR 67
11434: ARRAY
11435: LESSEQUAL
11436: IFFALSE 11458
// begin AddMedal ( People , 1 ) ;
11438: LD_STRING People
11440: PPUSH
11441: LD_INT 1
11443: PPUSH
11444: CALL_OW 101
// m3 := true ;
11448: LD_ADDR_VAR 0 6
11452: PUSH
11453: LD_INT 1
11455: ST_TO_ADDR
// end else
11456: GO 11469
// AddMedal ( People , - 1 ) ;
11458: LD_STRING People
11460: PPUSH
11461: LD_INT 1
11463: NEG
11464: PPUSH
11465: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11469: LD_OWVAR 67
11473: PUSH
11474: LD_INT 3
11476: EQUAL
11477: PUSH
11478: LD_VAR 0 4
11482: AND
11483: PUSH
11484: LD_VAR 0 5
11488: AND
11489: PUSH
11490: LD_VAR 0 6
11494: AND
11495: IFFALSE 11507
// SetAchievementEX ( ACH_AMER , 17 ) ;
11497: LD_STRING ACH_AMER
11499: PPUSH
11500: LD_INT 17
11502: PPUSH
11503: CALL_OW 564
// GiveMedals ( MAIN ) ;
11507: LD_STRING MAIN
11509: PPUSH
11510: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11514: LD_ADDR_VAR 0 2
11518: PUSH
11519: LD_INT 22
11521: PUSH
11522: LD_INT 7
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: PUSH
11529: LD_INT 2
11531: PUSH
11532: LD_INT 25
11534: PUSH
11535: LD_INT 1
11537: PUSH
11538: EMPTY
11539: LIST
11540: LIST
11541: PUSH
11542: LD_INT 25
11544: PUSH
11545: LD_INT 2
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 25
11554: PUSH
11555: LD_INT 3
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 25
11564: PUSH
11565: LD_INT 4
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: LD_INT 25
11574: PUSH
11575: LD_INT 5
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: PUSH
11582: LD_INT 25
11584: PUSH
11585: LD_INT 8
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: PUSH
11592: LD_INT 25
11594: PUSH
11595: LD_INT 9
11597: PUSH
11598: EMPTY
11599: LIST
11600: LIST
11601: PUSH
11602: EMPTY
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PPUSH
11616: CALL_OW 69
11620: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11621: LD_VAR 0 2
11625: PPUSH
11626: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11630: LD_ADDR_VAR 0 3
11634: PUSH
11635: LD_EXP 15
11639: PUSH
11640: LD_EXP 16
11644: PUSH
11645: LD_EXP 17
11649: PUSH
11650: LD_EXP 18
11654: PUSH
11655: LD_EXP 19
11659: PUSH
11660: LD_EXP 20
11664: PUSH
11665: LD_EXP 21
11669: PUSH
11670: LD_EXP 22
11674: PUSH
11675: LD_EXP 23
11679: PUSH
11680: LD_EXP 24
11684: PUSH
11685: LD_EXP 25
11689: PUSH
11690: LD_EXP 26
11694: PUSH
11695: LD_EXP 27
11699: PUSH
11700: LD_EXP 28
11704: PUSH
11705: LD_EXP 29
11709: PUSH
11710: LD_EXP 30
11714: PUSH
11715: LD_EXP 31
11719: PUSH
11720: LD_EXP 32
11724: PUSH
11725: LD_EXP 33
11729: PUSH
11730: LD_EXP 34
11734: PUSH
11735: LD_EXP 36
11739: PUSH
11740: LD_EXP 37
11744: PUSH
11745: LD_EXP 38
11749: PUSH
11750: LD_EXP 39
11754: PUSH
11755: LD_EXP 40
11759: PUSH
11760: LD_EXP 41
11764: PUSH
11765: LD_EXP 42
11769: PUSH
11770: LD_EXP 43
11774: PUSH
11775: LD_EXP 44
11779: PUSH
11780: LD_EXP 45
11784: PUSH
11785: LD_EXP 46
11789: PUSH
11790: LD_EXP 47
11794: PUSH
11795: LD_EXP 48
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: LIST
11809: LIST
11810: LIST
11811: LIST
11812: LIST
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: LIST
11831: LIST
11832: LIST
11833: LIST
11834: ST_TO_ADDR
// if tmp diff tmp2 then
11835: LD_VAR 0 2
11839: PUSH
11840: LD_VAR 0 3
11844: DIFF
11845: IFFALSE 11865
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11847: LD_VAR 0 2
11851: PUSH
11852: LD_VAR 0 3
11856: DIFF
11857: PPUSH
11858: LD_STRING 13a_others
11860: PPUSH
11861: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11865: LD_EXP 15
11869: PPUSH
11870: LD_STRING 13a_JMM
11872: PPUSH
11873: CALL_OW 38
// if Titov then
11877: LD_EXP 34
11881: IFFALSE 11895
// SaveCharacters ( Titov , 13a_Titov ) ;
11883: LD_EXP 34
11887: PPUSH
11888: LD_STRING 13a_Titov
11890: PPUSH
11891: CALL_OW 38
// if Dolgov then
11895: LD_EXP 36
11899: IFFALSE 11913
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11901: LD_EXP 36
11905: PPUSH
11906: LD_STRING 13a_Dolgov
11908: PPUSH
11909: CALL_OW 38
// if Petrosyan then
11913: LD_EXP 37
11917: IFFALSE 11931
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11919: LD_EXP 37
11923: PPUSH
11924: LD_STRING 13a_Petrosyan
11926: PPUSH
11927: CALL_OW 38
// if Scholtze then
11931: LD_EXP 38
11935: IFFALSE 11949
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11937: LD_EXP 38
11941: PPUSH
11942: LD_STRING 13a_Scholtze
11944: PPUSH
11945: CALL_OW 38
// if Oblukov then
11949: LD_EXP 39
11953: IFFALSE 11967
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11955: LD_EXP 39
11959: PPUSH
11960: LD_STRING 13a_Oblukov
11962: PPUSH
11963: CALL_OW 38
// if Kapitsova then
11967: LD_EXP 40
11971: IFFALSE 11985
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11973: LD_EXP 40
11977: PPUSH
11978: LD_STRING 13a_Kapitsova
11980: PPUSH
11981: CALL_OW 38
// if Lipshchin then
11985: LD_EXP 41
11989: IFFALSE 12003
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11991: LD_EXP 41
11995: PPUSH
11996: LD_STRING 13a_Lipshchin
11998: PPUSH
11999: CALL_OW 38
// if Petrovova then
12003: LD_EXP 42
12007: IFFALSE 12021
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12009: LD_EXP 42
12013: PPUSH
12014: LD_STRING 13a_Petrovova
12016: PPUSH
12017: CALL_OW 38
// if Kovalyuk then
12021: LD_EXP 43
12025: IFFALSE 12039
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12027: LD_EXP 43
12031: PPUSH
12032: LD_STRING 13a_Kovalyuk
12034: PPUSH
12035: CALL_OW 38
// if Kuzmov then
12039: LD_EXP 44
12043: IFFALSE 12057
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12045: LD_EXP 44
12049: PPUSH
12050: LD_STRING 13a_Kuzmov
12052: PPUSH
12053: CALL_OW 38
// if Karamazov then
12057: LD_EXP 45
12061: IFFALSE 12075
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12063: LD_EXP 45
12067: PPUSH
12068: LD_STRING 13a_Karamazov
12070: PPUSH
12071: CALL_OW 38
// if Burlak then
12075: LD_EXP 46
12079: IFFALSE 12093
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12081: LD_EXP 46
12085: PPUSH
12086: LD_STRING 13a_Burlak
12088: PPUSH
12089: CALL_OW 38
// if Belkov then
12093: LD_EXP 47
12097: IFFALSE 12111
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12099: LD_EXP 47
12103: PPUSH
12104: LD_STRING 13a_Belkov
12106: PPUSH
12107: CALL_OW 38
// if Gnyevko then
12111: LD_EXP 48
12115: IFFALSE 12129
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12117: LD_EXP 48
12121: PPUSH
12122: LD_STRING 13a_Gnyevko
12124: PPUSH
12125: CALL_OW 38
// if Lisa then
12129: LD_EXP 17
12133: IFFALSE 12147
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12135: LD_EXP 17
12139: PPUSH
12140: LD_STRING 13a_Lisa
12142: PPUSH
12143: CALL_OW 38
// if Donaldson then
12147: LD_EXP 18
12151: IFFALSE 12165
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12153: LD_EXP 18
12157: PPUSH
12158: LD_STRING 13a_Donaldson
12160: PPUSH
12161: CALL_OW 38
// if Bobby then
12165: LD_EXP 19
12169: IFFALSE 12183
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12171: LD_EXP 19
12175: PPUSH
12176: LD_STRING 13a_Bobby
12178: PPUSH
12179: CALL_OW 38
// if Cyrus then
12183: LD_EXP 20
12187: IFFALSE 12201
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12189: LD_EXP 20
12193: PPUSH
12194: LD_STRING 13a_Cyrus
12196: PPUSH
12197: CALL_OW 38
// if Denis then
12201: LD_EXP 21
12205: IFFALSE 12219
// SaveCharacters ( Denis , 13a_Denis ) ;
12207: LD_EXP 21
12211: PPUSH
12212: LD_STRING 13a_Denis
12214: PPUSH
12215: CALL_OW 38
// if Brown then
12219: LD_EXP 22
12223: IFFALSE 12237
// SaveCharacters ( Brown , 13a_Brown ) ;
12225: LD_EXP 22
12229: PPUSH
12230: LD_STRING 13a_Brown
12232: PPUSH
12233: CALL_OW 38
// if Gladstone then
12237: LD_EXP 23
12241: IFFALSE 12255
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12243: LD_EXP 23
12247: PPUSH
12248: LD_STRING 13a_Gladstone
12250: PPUSH
12251: CALL_OW 38
// if Houten then
12255: LD_EXP 24
12259: IFFALSE 12273
// SaveCharacters ( Houten , 13a_Houten ) ;
12261: LD_EXP 24
12265: PPUSH
12266: LD_STRING 13a_Houten
12268: PPUSH
12269: CALL_OW 38
// if Cornel then
12273: LD_EXP 25
12277: IFFALSE 12291
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12279: LD_EXP 25
12283: PPUSH
12284: LD_STRING 13a_Cornel
12286: PPUSH
12287: CALL_OW 38
// if Gary then
12291: LD_EXP 26
12295: IFFALSE 12309
// SaveCharacters ( Gary , 13a_Gary ) ;
12297: LD_EXP 26
12301: PPUSH
12302: LD_STRING 13a_Gary
12304: PPUSH
12305: CALL_OW 38
// if Frank then
12309: LD_EXP 27
12313: IFFALSE 12327
// SaveCharacters ( Frank , 13a_Frank ) ;
12315: LD_EXP 27
12319: PPUSH
12320: LD_STRING 13a_Frank
12322: PPUSH
12323: CALL_OW 38
// if Kikuchi then
12327: LD_EXP 28
12331: IFFALSE 12345
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12333: LD_EXP 28
12337: PPUSH
12338: LD_STRING 13a_Kikuchi
12340: PPUSH
12341: CALL_OW 38
// if Simms then
12345: LD_EXP 29
12349: IFFALSE 12363
// SaveCharacters ( Simms , 13a_Simms ) ;
12351: LD_EXP 29
12355: PPUSH
12356: LD_STRING 13a_Simms
12358: PPUSH
12359: CALL_OW 38
// if Joan then
12363: LD_EXP 30
12367: IFFALSE 12381
// SaveCharacters ( Joan , 13a_Joan ) ;
12369: LD_EXP 30
12373: PPUSH
12374: LD_STRING 13a_Joan
12376: PPUSH
12377: CALL_OW 38
// if DeltaDoctor then
12381: LD_EXP 31
12385: IFFALSE 12399
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12387: LD_EXP 31
12391: PPUSH
12392: LD_STRING 13a_DeltaDoctor
12394: PPUSH
12395: CALL_OW 38
// if Gossudarov then
12399: LD_EXP 32
12403: IFFALSE 12417
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12405: LD_EXP 32
12409: PPUSH
12410: LD_STRING 13a_Gossudarov
12412: PPUSH
12413: CALL_OW 38
// if Kirilenkova then
12417: LD_EXP 33
12421: IFFALSE 12435
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12423: LD_EXP 33
12427: PPUSH
12428: LD_STRING 13a_Kirilenkova
12430: PPUSH
12431: CALL_OW 38
// if Roth then
12435: LD_EXP 16
12439: IFFALSE 12453
// SaveCharacters ( Roth , 13a_Roth ) ;
12441: LD_EXP 16
12445: PPUSH
12446: LD_STRING 13a_Roth
12448: PPUSH
12449: CALL_OW 38
// if Masha then
12453: LD_EXP 49
12457: IFFALSE 12512
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12459: LD_EXP 49
12463: PPUSH
12464: CALL_OW 265
12468: PUSH
12469: LD_EXP 49
12473: PPUSH
12474: CALL_OW 262
12478: PUSH
12479: LD_EXP 49
12483: PPUSH
12484: CALL_OW 263
12488: PUSH
12489: LD_EXP 49
12493: PPUSH
12494: CALL_OW 264
12498: PUSH
12499: EMPTY
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: PPUSH
12505: LD_STRING 13a_Masha
12507: PPUSH
12508: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12512: LD_ADDR_VAR 0 2
12516: PUSH
12517: LD_INT 21
12519: PUSH
12520: LD_INT 3
12522: PUSH
12523: EMPTY
12524: LIST
12525: LIST
12526: PPUSH
12527: CALL_OW 69
12531: ST_TO_ADDR
// tmp2 := [ ] ;
12532: LD_ADDR_VAR 0 3
12536: PUSH
12537: EMPTY
12538: ST_TO_ADDR
// if tmp then
12539: LD_VAR 0 2
12543: IFFALSE 12694
// for i in tmp do
12545: LD_ADDR_VAR 0 1
12549: PUSH
12550: LD_VAR 0 2
12554: PUSH
12555: FOR_IN
12556: IFFALSE 12692
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12558: LD_ADDR_VAR 0 3
12562: PUSH
12563: LD_VAR 0 3
12567: PUSH
12568: LD_VAR 0 1
12572: PPUSH
12573: CALL_OW 255
12577: PUSH
12578: LD_VAR 0 1
12582: PPUSH
12583: CALL_OW 248
12587: PUSH
12588: LD_VAR 0 1
12592: PPUSH
12593: CALL_OW 266
12597: PUSH
12598: LD_VAR 0 1
12602: PPUSH
12603: CALL_OW 250
12607: PUSH
12608: LD_VAR 0 1
12612: PPUSH
12613: CALL_OW 251
12617: PUSH
12618: LD_VAR 0 1
12622: PPUSH
12623: CALL_OW 254
12627: PUSH
12628: LD_VAR 0 1
12632: PPUSH
12633: CALL_OW 267
12637: PUSH
12638: LD_VAR 0 1
12642: PPUSH
12643: LD_INT 1
12645: PPUSH
12646: CALL_OW 268
12650: PUSH
12651: LD_VAR 0 1
12655: PPUSH
12656: LD_INT 2
12658: PPUSH
12659: CALL_OW 268
12663: PUSH
12664: LD_VAR 0 1
12668: PPUSH
12669: CALL_OW 269
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: PUSH
12686: EMPTY
12687: LIST
12688: ADD
12689: ST_TO_ADDR
12690: GO 12555
12692: POP
12693: POP
// if tmp2 then
12694: LD_VAR 0 3
12698: IFFALSE 12712
// SaveVariable ( tmp2 , 13a_buildings ) ;
12700: LD_VAR 0 3
12704: PPUSH
12705: LD_STRING 13a_buildings
12707: PPUSH
12708: CALL_OW 39
// YouWin ;
12712: CALL_OW 103
// end ;
12716: PPOPN 6
12718: END
// export function SciRu ; var tmp , t ; begin
12719: LD_INT 0
12721: PPUSH
12722: PPUSH
12723: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12724: LD_ADDR_VAR 0 3
12728: PUSH
12729: LD_EXP 32
12733: PUSH
12734: LD_EXP 46
12738: PUSH
12739: LD_EXP 34
12743: PUSH
12744: LD_EXP 47
12748: PUSH
12749: LD_EXP 48
12753: PUSH
12754: LD_EXP 37
12758: PUSH
12759: LD_EXP 38
12763: PUSH
12764: LD_EXP 36
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: LIST
12773: LIST
12774: LIST
12775: LIST
12776: LIST
12777: LIST
12778: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12779: LD_ADDR_VAR 0 2
12783: PUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 7
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 23
12796: PUSH
12797: LD_INT 3
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 25
12806: PUSH
12807: LD_INT 4
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: LD_INT 26
12816: PUSH
12817: LD_INT 1
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: PUSH
12824: EMPTY
12825: LIST
12826: LIST
12827: LIST
12828: LIST
12829: PPUSH
12830: CALL_OW 69
12834: PUSH
12835: LD_VAR 0 3
12839: DIFF
12840: ST_TO_ADDR
// if tmp then
12841: LD_VAR 0 2
12845: IFFALSE 12861
// result := tmp [ 1 ] ;
12847: LD_ADDR_VAR 0 1
12851: PUSH
12852: LD_VAR 0 2
12856: PUSH
12857: LD_INT 1
12859: ARRAY
12860: ST_TO_ADDR
// end ;
12861: LD_VAR 0 1
12865: RET
// export function SolRu ; var tmp , t ; begin
12866: LD_INT 0
12868: PPUSH
12869: PPUSH
12870: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12871: LD_ADDR_VAR 0 3
12875: PUSH
12876: LD_EXP 32
12880: PUSH
12881: LD_EXP 46
12885: PUSH
12886: LD_EXP 34
12890: PUSH
12891: LD_EXP 47
12895: PUSH
12896: LD_EXP 48
12900: PUSH
12901: LD_EXP 37
12905: PUSH
12906: LD_EXP 38
12910: PUSH
12911: LD_EXP 36
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: LIST
12924: LIST
12925: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12926: LD_ADDR_VAR 0 2
12930: PUSH
12931: LD_INT 22
12933: PUSH
12934: LD_INT 7
12936: PUSH
12937: EMPTY
12938: LIST
12939: LIST
12940: PUSH
12941: LD_INT 23
12943: PUSH
12944: LD_INT 3
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: PUSH
12951: LD_INT 25
12953: PUSH
12954: LD_INT 1
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: PUSH
12961: LD_INT 26
12963: PUSH
12964: LD_INT 1
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: LIST
12975: LIST
12976: PPUSH
12977: CALL_OW 69
12981: PUSH
12982: LD_VAR 0 3
12986: DIFF
12987: ST_TO_ADDR
// if tmp then
12988: LD_VAR 0 2
12992: IFFALSE 13008
// result := tmp [ 1 ] ;
12994: LD_ADDR_VAR 0 1
12998: PUSH
12999: LD_VAR 0 2
13003: PUSH
13004: LD_INT 1
13006: ARRAY
13007: ST_TO_ADDR
// end ; end_of_file
13008: LD_VAR 0 1
13012: RET
// export function CustomEvent ( event ) ; begin
13013: LD_INT 0
13015: PPUSH
// end ;
13016: LD_VAR 0 2
13020: RET
// on UnitDestroyed ( un ) do var i , side ;
13021: LD_INT 0
13023: PPUSH
13024: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13025: LD_VAR 0 1
13029: PUSH
13030: LD_INT 22
13032: PUSH
13033: LD_INT 7
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PUSH
13040: LD_INT 2
13042: PUSH
13043: LD_INT 25
13045: PUSH
13046: LD_INT 1
13048: PUSH
13049: EMPTY
13050: LIST
13051: LIST
13052: PUSH
13053: LD_INT 25
13055: PUSH
13056: LD_INT 2
13058: PUSH
13059: EMPTY
13060: LIST
13061: LIST
13062: PUSH
13063: LD_INT 25
13065: PUSH
13066: LD_INT 3
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: PUSH
13073: LD_INT 25
13075: PUSH
13076: LD_INT 4
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: PUSH
13083: LD_INT 25
13085: PUSH
13086: LD_INT 5
13088: PUSH
13089: EMPTY
13090: LIST
13091: LIST
13092: PUSH
13093: LD_INT 25
13095: PUSH
13096: LD_INT 8
13098: PUSH
13099: EMPTY
13100: LIST
13101: LIST
13102: PUSH
13103: LD_INT 25
13105: PUSH
13106: LD_INT 9
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: PUSH
13113: EMPTY
13114: LIST
13115: LIST
13116: LIST
13117: LIST
13118: LIST
13119: LIST
13120: LIST
13121: LIST
13122: PUSH
13123: EMPTY
13124: LIST
13125: LIST
13126: PPUSH
13127: CALL_OW 69
13131: IN
13132: IFFALSE 13148
// loss_counter := loss_counter + 1 ;
13134: LD_ADDR_EXP 13
13138: PUSH
13139: LD_EXP 13
13143: PUSH
13144: LD_INT 1
13146: PLUS
13147: ST_TO_ADDR
// if un = Abdul then
13148: LD_VAR 0 1
13152: PUSH
13153: LD_EXP 55
13157: EQUAL
13158: IFFALSE 13168
// abdul_escaped := false ;
13160: LD_ADDR_EXP 12
13164: PUSH
13165: LD_INT 0
13167: ST_TO_ADDR
// if un in ru_attackers then
13168: LD_VAR 0 1
13172: PUSH
13173: LD_EXP 52
13177: IN
13178: IFFALSE 13196
// ru_attackers := ru_attackers diff un ;
13180: LD_ADDR_EXP 52
13184: PUSH
13185: LD_EXP 52
13189: PUSH
13190: LD_VAR 0 1
13194: DIFF
13195: ST_TO_ADDR
// if un in ar_attackers then
13196: LD_VAR 0 1
13200: PUSH
13201: LD_EXP 10
13205: IN
13206: IFFALSE 13224
// ar_attackers := ar_attackers diff un ;
13208: LD_ADDR_EXP 10
13212: PUSH
13213: LD_EXP 10
13217: PUSH
13218: LD_VAR 0 1
13222: DIFF
13223: ST_TO_ADDR
// if un = JMM then
13224: LD_VAR 0 1
13228: PUSH
13229: LD_EXP 15
13233: EQUAL
13234: IFFALSE 13245
// begin YouLost ( JMM ) ;
13236: LD_STRING JMM
13238: PPUSH
13239: CALL_OW 104
// exit ;
13243: GO 13334
// end ; if un = Burlak then
13245: LD_VAR 0 1
13249: PUSH
13250: LD_EXP 46
13254: EQUAL
13255: IFFALSE 13266
// begin YouLost ( Burlak ) ;
13257: LD_STRING Burlak
13259: PPUSH
13260: CALL_OW 104
// exit ;
13264: GO 13334
// end ; if un = freedom then
13266: LD_VAR 0 1
13270: PUSH
13271: LD_EXP 3
13275: EQUAL
13276: IFFALSE 13287
// begin YouLost ( Destroyed ) ;
13278: LD_STRING Destroyed
13280: PPUSH
13281: CALL_OW 104
// exit ;
13285: GO 13334
// end ; if un = Masha then
13287: LD_VAR 0 1
13291: PUSH
13292: LD_EXP 49
13296: EQUAL
13297: IFFALSE 13306
// ChangeMissionObjectives ( M4b ) ;
13299: LD_STRING M4b
13301: PPUSH
13302: CALL_OW 337
// if un = Mastodont then
13306: LD_VAR 0 1
13310: PUSH
13311: LD_EXP 56
13315: EQUAL
13316: IFFALSE 13325
// ChangeMissionObjectives ( M4a ) ;
13318: LD_STRING M4a
13320: PPUSH
13321: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13325: LD_VAR 0 1
13329: PPUSH
13330: CALL 77551 0 1
// end ;
13334: PPOPN 3
13336: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13337: LD_VAR 0 1
13341: PPUSH
13342: LD_VAR 0 2
13346: PPUSH
13347: CALL 79885 0 2
// end ;
13351: PPOPN 2
13353: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13354: LD_VAR 0 1
13358: PPUSH
13359: CALL 78953 0 1
// end ;
13363: PPOPN 1
13365: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13366: LD_VAR 0 1
13370: PUSH
13371: LD_INT 22
13373: PUSH
13374: LD_INT 7
13376: PUSH
13377: EMPTY
13378: LIST
13379: LIST
13380: PUSH
13381: LD_INT 30
13383: PUSH
13384: LD_INT 0
13386: PUSH
13387: EMPTY
13388: LIST
13389: LIST
13390: PUSH
13391: EMPTY
13392: LIST
13393: LIST
13394: PPUSH
13395: CALL_OW 69
13399: IN
13400: IFFALSE 13439
// begin SetBName ( building , freedom ) ;
13402: LD_VAR 0 1
13406: PPUSH
13407: LD_STRING freedom
13409: PPUSH
13410: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13414: LD_INT 0
13416: PPUSH
13417: LD_INT 7
13419: PPUSH
13420: LD_INT 0
13422: PPUSH
13423: CALL_OW 324
// freedom := building ;
13427: LD_ADDR_EXP 3
13431: PUSH
13432: LD_VAR 0 1
13436: ST_TO_ADDR
// exit ;
13437: GO 13505
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13439: LD_VAR 0 1
13443: PUSH
13444: LD_INT 22
13446: PUSH
13447: LD_INT 7
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PUSH
13454: LD_INT 23
13456: PUSH
13457: LD_INT 3
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 30
13466: PUSH
13467: LD_INT 6
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: LIST
13478: PPUSH
13479: CALL_OW 69
13483: IN
13484: IFFALSE 13496
// begin ru_lab_builded := true ;
13486: LD_ADDR_EXP 5
13490: PUSH
13491: LD_INT 1
13493: ST_TO_ADDR
// exit ;
13494: GO 13505
// end ; MCE_BuildingComplete ( building ) ;
13496: LD_VAR 0 1
13500: PPUSH
13501: CALL 79194 0 1
// end ;
13505: PPOPN 1
13507: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13508: LD_VAR 0 1
13512: PPUSH
13513: LD_VAR 0 2
13517: PPUSH
13518: CALL 77247 0 2
// end ;
13522: PPOPN 2
13524: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13525: LD_VAR 0 1
13529: PPUSH
13530: LD_VAR 0 2
13534: PPUSH
13535: LD_VAR 0 3
13539: PPUSH
13540: LD_VAR 0 4
13544: PPUSH
13545: LD_VAR 0 5
13549: PPUSH
13550: CALL 76867 0 5
// end ;
13554: PPOPN 5
13556: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13557: LD_VAR 0 1
13561: PPUSH
13562: LD_VAR 0 2
13566: PPUSH
13567: CALL 76463 0 2
// end ;
13571: PPOPN 2
13573: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
13574: LD_VAR 0 1
13578: PPUSH
13579: CALL_OW 263
13583: PUSH
13584: LD_INT 3
13586: EQUAL
13587: PUSH
13588: LD_VAR 0 2
13592: PPUSH
13593: CALL_OW 263
13597: PUSH
13598: LD_INT 3
13600: EQUAL
13601: OR
13602: IFFALSE 13618
// hack_counter := hack_counter + 1 ;
13604: LD_ADDR_EXP 14
13608: PUSH
13609: LD_EXP 14
13613: PUSH
13614: LD_INT 1
13616: PLUS
13617: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13618: LD_VAR 0 1
13622: PPUSH
13623: LD_VAR 0 2
13627: PPUSH
13628: LD_VAR 0 3
13632: PPUSH
13633: LD_VAR 0 4
13637: PPUSH
13638: CALL 76301 0 4
// end ;
13642: PPOPN 4
13644: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13645: LD_VAR 0 1
13649: PPUSH
13650: LD_VAR 0 2
13654: PPUSH
13655: LD_VAR 0 3
13659: PPUSH
13660: CALL 76076 0 3
// end ;
13664: PPOPN 3
13666: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13667: LD_VAR 0 1
13671: PPUSH
13672: LD_VAR 0 2
13676: PPUSH
13677: CALL 75961 0 2
// end ;
13681: PPOPN 2
13683: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13684: LD_VAR 0 1
13688: PPUSH
13689: LD_VAR 0 2
13693: PPUSH
13694: CALL 80146 0 2
// end ;
13698: PPOPN 2
13700: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13701: LD_VAR 0 1
13705: PPUSH
13706: LD_VAR 0 2
13710: PPUSH
13711: LD_VAR 0 3
13715: PPUSH
13716: LD_VAR 0 4
13720: PPUSH
13721: CALL 80362 0 4
// end ;
13725: PPOPN 4
13727: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13728: LD_VAR 0 1
13732: PPUSH
13733: LD_VAR 0 2
13737: PPUSH
13738: CALL 75770 0 2
// end ;
13742: PPOPN 2
13744: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13745: LD_VAR 0 1
13749: PPUSH
13750: CALL 91738 0 1
// end ; end_of_file
13754: PPOPN 1
13756: END
// every 0 0$30 do var cr , time ;
13757: GO 13759
13759: DISABLE
13760: LD_INT 0
13762: PPUSH
13763: PPUSH
// begin time := 0 0$30 ;
13764: LD_ADDR_VAR 0 2
13768: PUSH
13769: LD_INT 1050
13771: ST_TO_ADDR
// while game do
13772: LD_EXP 2
13776: IFFALSE 13875
// begin wait ( time ) ;
13778: LD_VAR 0 2
13782: PPUSH
13783: CALL_OW 67
// if tick > 2 2$00 then
13787: LD_OWVAR 1
13791: PUSH
13792: LD_INT 4200
13794: GREATER
13795: IFFALSE 13828
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13797: LD_ADDR_VAR 0 2
13801: PUSH
13802: LD_VAR 0 2
13806: PUSH
13807: LD_INT 280
13809: PUSH
13810: LD_INT 420
13812: PUSH
13813: LD_INT 630
13815: PUSH
13816: EMPTY
13817: LIST
13818: LIST
13819: LIST
13820: PUSH
13821: LD_OWVAR 67
13825: ARRAY
13826: PLUS
13827: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13828: LD_INT 1
13830: PPUSH
13831: LD_INT 5
13833: PPUSH
13834: CALL_OW 12
13838: PPUSH
13839: LD_INT 70
13841: PPUSH
13842: LD_INT 49
13844: PPUSH
13845: LD_INT 25
13847: PPUSH
13848: LD_INT 1
13850: PPUSH
13851: CALL_OW 56
// if time > 5 5$00 then
13855: LD_VAR 0 2
13859: PUSH
13860: LD_INT 10500
13862: GREATER
13863: IFFALSE 13873
// time := 0 0$30 ;
13865: LD_ADDR_VAR 0 2
13869: PUSH
13870: LD_INT 1050
13872: ST_TO_ADDR
// end ;
13873: GO 13772
// end ;
13875: PPOPN 2
13877: END
// every 0 0$30 do var cr , time ;
13878: GO 13880
13880: DISABLE
13881: LD_INT 0
13883: PPUSH
13884: PPUSH
// begin time := 0 0$20 ;
13885: LD_ADDR_VAR 0 2
13889: PUSH
13890: LD_INT 700
13892: ST_TO_ADDR
// while game do
13893: LD_EXP 2
13897: IFFALSE 13986
// begin wait ( time ) ;
13899: LD_VAR 0 2
13903: PPUSH
13904: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13908: LD_ADDR_VAR 0 2
13912: PUSH
13913: LD_VAR 0 2
13917: PUSH
13918: LD_INT 490
13920: PUSH
13921: LD_INT 525
13923: PUSH
13924: LD_INT 560
13926: PUSH
13927: EMPTY
13928: LIST
13929: LIST
13930: LIST
13931: PUSH
13932: LD_OWVAR 67
13936: ARRAY
13937: PLUS
13938: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13939: LD_INT 3
13941: PPUSH
13942: LD_INT 5
13944: PPUSH
13945: CALL_OW 12
13949: PPUSH
13950: LD_INT 26
13952: PPUSH
13953: LD_INT 9
13955: PPUSH
13956: LD_INT 30
13958: PPUSH
13959: LD_INT 1
13961: PPUSH
13962: CALL_OW 56
// if time > 3 3$00 then
13966: LD_VAR 0 2
13970: PUSH
13971: LD_INT 6300
13973: GREATER
13974: IFFALSE 13984
// time := 0 0$20 ;
13976: LD_ADDR_VAR 0 2
13980: PUSH
13981: LD_INT 700
13983: ST_TO_ADDR
// end ;
13984: GO 13893
// end ;
13986: PPOPN 2
13988: END
// every 0 0$30 do var cr , time ;
13989: GO 13991
13991: DISABLE
13992: LD_INT 0
13994: PPUSH
13995: PPUSH
// begin time := 0 0$20 ;
13996: LD_ADDR_VAR 0 2
14000: PUSH
14001: LD_INT 700
14003: ST_TO_ADDR
// while game do
14004: LD_EXP 2
14008: IFFALSE 14133
// begin wait ( time ) ;
14010: LD_VAR 0 2
14014: PPUSH
14015: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14019: LD_ADDR_VAR 0 2
14023: PUSH
14024: LD_VAR 0 2
14028: PUSH
14029: LD_INT 175
14031: PUSH
14032: LD_INT 210
14034: PUSH
14035: LD_INT 280
14037: PUSH
14038: EMPTY
14039: LIST
14040: LIST
14041: LIST
14042: PUSH
14043: LD_OWVAR 67
14047: ARRAY
14048: PLUS
14049: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14050: LD_INT 1
14052: PPUSH
14053: LD_INT 5
14055: PPUSH
14056: CALL_OW 12
14060: PPUSH
14061: LD_INT 179
14063: PPUSH
14064: LD_INT 101
14066: PPUSH
14067: LD_INT 20
14069: PPUSH
14070: LD_INT 1
14072: PPUSH
14073: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14077: LD_INT 350
14079: PPUSH
14080: LD_INT 525
14082: PPUSH
14083: CALL_OW 12
14087: PPUSH
14088: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14092: LD_INT 1
14094: PPUSH
14095: LD_INT 5
14097: PPUSH
14098: CALL_OW 12
14102: PPUSH
14103: LD_INT 9
14105: PPUSH
14106: LD_INT 1
14108: PPUSH
14109: CALL_OW 55
// if time > 4 4$00 then
14113: LD_VAR 0 2
14117: PUSH
14118: LD_INT 8400
14120: GREATER
14121: IFFALSE 14131
// time := 0 0$30 ;
14123: LD_ADDR_VAR 0 2
14127: PUSH
14128: LD_INT 1050
14130: ST_TO_ADDR
// end ;
14131: GO 14004
// end ;
14133: PPOPN 2
14135: END
// every 0 0$30 do var cr , time ;
14136: GO 14138
14138: DISABLE
14139: LD_INT 0
14141: PPUSH
14142: PPUSH
// begin time := 0 0$10 ;
14143: LD_ADDR_VAR 0 2
14147: PUSH
14148: LD_INT 350
14150: ST_TO_ADDR
// while game do
14151: LD_EXP 2
14155: IFFALSE 14289
// begin wait ( time ) ;
14157: LD_VAR 0 2
14161: PPUSH
14162: CALL_OW 67
// time := time + 0 0$10 ;
14166: LD_ADDR_VAR 0 2
14170: PUSH
14171: LD_VAR 0 2
14175: PUSH
14176: LD_INT 350
14178: PLUS
14179: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14180: LD_INT 1
14182: PPUSH
14183: LD_INT 5
14185: PPUSH
14186: CALL_OW 12
14190: PPUSH
14191: LD_INT 11
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14201: LD_ADDR_VAR 0 1
14205: PUSH
14206: LD_INT 1
14208: PPUSH
14209: LD_INT 3
14211: PPUSH
14212: CALL_OW 12
14216: ST_TO_ADDR
// if cr = 1 then
14217: LD_VAR 0 1
14221: PUSH
14222: LD_INT 1
14224: EQUAL
14225: IFFALSE 14269
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14227: LD_INT 700
14229: PPUSH
14230: LD_INT 1575
14232: PPUSH
14233: CALL_OW 12
14237: PPUSH
14238: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14242: LD_INT 1
14244: PPUSH
14245: LD_INT 5
14247: PPUSH
14248: CALL_OW 12
14252: PPUSH
14253: LD_INT 34
14255: PPUSH
14256: LD_INT 50
14258: PPUSH
14259: LD_INT 7
14261: PPUSH
14262: LD_INT 1
14264: PPUSH
14265: CALL_OW 56
// end ; if time > 8 8$00 then
14269: LD_VAR 0 2
14273: PUSH
14274: LD_INT 16800
14276: GREATER
14277: IFFALSE 14287
// time := 0 0$40 ;
14279: LD_ADDR_VAR 0 2
14283: PUSH
14284: LD_INT 1400
14286: ST_TO_ADDR
// end ;
14287: GO 14151
// end ; end_of_file
14289: PPOPN 2
14291: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14292: LD_INT 0
14294: PPUSH
14295: PPUSH
// if exist_mode then
14296: LD_VAR 0 2
14300: IFFALSE 14325
// unit := CreateCharacter ( prefix & ident ) else
14302: LD_ADDR_VAR 0 5
14306: PUSH
14307: LD_VAR 0 3
14311: PUSH
14312: LD_VAR 0 1
14316: STR
14317: PPUSH
14318: CALL_OW 34
14322: ST_TO_ADDR
14323: GO 14340
// unit := NewCharacter ( ident ) ;
14325: LD_ADDR_VAR 0 5
14329: PUSH
14330: LD_VAR 0 1
14334: PPUSH
14335: CALL_OW 25
14339: ST_TO_ADDR
// result := unit ;
14340: LD_ADDR_VAR 0 4
14344: PUSH
14345: LD_VAR 0 5
14349: ST_TO_ADDR
// end ;
14350: LD_VAR 0 4
14354: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14355: LD_INT 0
14357: PPUSH
14358: PPUSH
// if not side or not nation then
14359: LD_VAR 0 1
14363: NOT
14364: PUSH
14365: LD_VAR 0 2
14369: NOT
14370: OR
14371: IFFALSE 14375
// exit ;
14373: GO 15139
// case nation of nation_american :
14375: LD_VAR 0 2
14379: PUSH
14380: LD_INT 1
14382: DOUBLE
14383: EQUAL
14384: IFTRUE 14388
14386: GO 14602
14388: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14389: LD_ADDR_VAR 0 4
14393: PUSH
14394: LD_INT 35
14396: PUSH
14397: LD_INT 45
14399: PUSH
14400: LD_INT 46
14402: PUSH
14403: LD_INT 47
14405: PUSH
14406: LD_INT 82
14408: PUSH
14409: LD_INT 83
14411: PUSH
14412: LD_INT 84
14414: PUSH
14415: LD_INT 85
14417: PUSH
14418: LD_INT 86
14420: PUSH
14421: LD_INT 1
14423: PUSH
14424: LD_INT 2
14426: PUSH
14427: LD_INT 6
14429: PUSH
14430: LD_INT 15
14432: PUSH
14433: LD_INT 16
14435: PUSH
14436: LD_INT 7
14438: PUSH
14439: LD_INT 12
14441: PUSH
14442: LD_INT 13
14444: PUSH
14445: LD_INT 10
14447: PUSH
14448: LD_INT 14
14450: PUSH
14451: LD_INT 20
14453: PUSH
14454: LD_INT 21
14456: PUSH
14457: LD_INT 22
14459: PUSH
14460: LD_INT 25
14462: PUSH
14463: LD_INT 32
14465: PUSH
14466: LD_INT 27
14468: PUSH
14469: LD_INT 36
14471: PUSH
14472: LD_INT 69
14474: PUSH
14475: LD_INT 39
14477: PUSH
14478: LD_INT 34
14480: PUSH
14481: LD_INT 40
14483: PUSH
14484: LD_INT 48
14486: PUSH
14487: LD_INT 49
14489: PUSH
14490: LD_INT 50
14492: PUSH
14493: LD_INT 51
14495: PUSH
14496: LD_INT 52
14498: PUSH
14499: LD_INT 53
14501: PUSH
14502: LD_INT 54
14504: PUSH
14505: LD_INT 55
14507: PUSH
14508: LD_INT 56
14510: PUSH
14511: LD_INT 57
14513: PUSH
14514: LD_INT 58
14516: PUSH
14517: LD_INT 59
14519: PUSH
14520: LD_INT 60
14522: PUSH
14523: LD_INT 61
14525: PUSH
14526: LD_INT 62
14528: PUSH
14529: LD_INT 80
14531: PUSH
14532: LD_INT 82
14534: PUSH
14535: LD_INT 83
14537: PUSH
14538: LD_INT 84
14540: PUSH
14541: LD_INT 85
14543: PUSH
14544: LD_INT 86
14546: PUSH
14547: EMPTY
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: LIST
14598: LIST
14599: ST_TO_ADDR
14600: GO 15063
14602: LD_INT 2
14604: DOUBLE
14605: EQUAL
14606: IFTRUE 14610
14608: GO 14832
14610: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
14611: LD_ADDR_VAR 0 4
14615: PUSH
14616: LD_INT 35
14618: PUSH
14619: LD_INT 45
14621: PUSH
14622: LD_INT 46
14624: PUSH
14625: LD_INT 47
14627: PUSH
14628: LD_INT 82
14630: PUSH
14631: LD_INT 83
14633: PUSH
14634: LD_INT 84
14636: PUSH
14637: LD_INT 85
14639: PUSH
14640: LD_INT 87
14642: PUSH
14643: LD_INT 70
14645: PUSH
14646: LD_INT 1
14648: PUSH
14649: LD_INT 11
14651: PUSH
14652: LD_INT 3
14654: PUSH
14655: LD_INT 4
14657: PUSH
14658: LD_INT 5
14660: PUSH
14661: LD_INT 6
14663: PUSH
14664: LD_INT 15
14666: PUSH
14667: LD_INT 18
14669: PUSH
14670: LD_INT 7
14672: PUSH
14673: LD_INT 17
14675: PUSH
14676: LD_INT 8
14678: PUSH
14679: LD_INT 20
14681: PUSH
14682: LD_INT 21
14684: PUSH
14685: LD_INT 22
14687: PUSH
14688: LD_INT 72
14690: PUSH
14691: LD_INT 26
14693: PUSH
14694: LD_INT 69
14696: PUSH
14697: LD_INT 39
14699: PUSH
14700: LD_INT 40
14702: PUSH
14703: LD_INT 41
14705: PUSH
14706: LD_INT 42
14708: PUSH
14709: LD_INT 43
14711: PUSH
14712: LD_INT 48
14714: PUSH
14715: LD_INT 49
14717: PUSH
14718: LD_INT 50
14720: PUSH
14721: LD_INT 51
14723: PUSH
14724: LD_INT 52
14726: PUSH
14727: LD_INT 53
14729: PUSH
14730: LD_INT 54
14732: PUSH
14733: LD_INT 55
14735: PUSH
14736: LD_INT 56
14738: PUSH
14739: LD_INT 60
14741: PUSH
14742: LD_INT 61
14744: PUSH
14745: LD_INT 62
14747: PUSH
14748: LD_INT 66
14750: PUSH
14751: LD_INT 67
14753: PUSH
14754: LD_INT 68
14756: PUSH
14757: LD_INT 81
14759: PUSH
14760: LD_INT 82
14762: PUSH
14763: LD_INT 83
14765: PUSH
14766: LD_INT 84
14768: PUSH
14769: LD_INT 85
14771: PUSH
14772: LD_INT 87
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: LIST
14779: LIST
14780: LIST
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: LIST
14795: LIST
14796: LIST
14797: LIST
14798: LIST
14799: LIST
14800: LIST
14801: LIST
14802: LIST
14803: LIST
14804: LIST
14805: LIST
14806: LIST
14807: LIST
14808: LIST
14809: LIST
14810: LIST
14811: LIST
14812: LIST
14813: LIST
14814: LIST
14815: LIST
14816: LIST
14817: LIST
14818: LIST
14819: LIST
14820: LIST
14821: LIST
14822: LIST
14823: LIST
14824: LIST
14825: LIST
14826: LIST
14827: LIST
14828: LIST
14829: ST_TO_ADDR
14830: GO 15063
14832: LD_INT 3
14834: DOUBLE
14835: EQUAL
14836: IFTRUE 14840
14838: GO 15062
14840: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14841: LD_ADDR_VAR 0 4
14845: PUSH
14846: LD_INT 46
14848: PUSH
14849: LD_INT 47
14851: PUSH
14852: LD_INT 1
14854: PUSH
14855: LD_INT 2
14857: PUSH
14858: LD_INT 82
14860: PUSH
14861: LD_INT 83
14863: PUSH
14864: LD_INT 84
14866: PUSH
14867: LD_INT 85
14869: PUSH
14870: LD_INT 86
14872: PUSH
14873: LD_INT 11
14875: PUSH
14876: LD_INT 9
14878: PUSH
14879: LD_INT 20
14881: PUSH
14882: LD_INT 19
14884: PUSH
14885: LD_INT 21
14887: PUSH
14888: LD_INT 24
14890: PUSH
14891: LD_INT 22
14893: PUSH
14894: LD_INT 25
14896: PUSH
14897: LD_INT 28
14899: PUSH
14900: LD_INT 29
14902: PUSH
14903: LD_INT 30
14905: PUSH
14906: LD_INT 31
14908: PUSH
14909: LD_INT 37
14911: PUSH
14912: LD_INT 38
14914: PUSH
14915: LD_INT 32
14917: PUSH
14918: LD_INT 27
14920: PUSH
14921: LD_INT 33
14923: PUSH
14924: LD_INT 69
14926: PUSH
14927: LD_INT 39
14929: PUSH
14930: LD_INT 34
14932: PUSH
14933: LD_INT 40
14935: PUSH
14936: LD_INT 71
14938: PUSH
14939: LD_INT 23
14941: PUSH
14942: LD_INT 44
14944: PUSH
14945: LD_INT 48
14947: PUSH
14948: LD_INT 49
14950: PUSH
14951: LD_INT 50
14953: PUSH
14954: LD_INT 51
14956: PUSH
14957: LD_INT 52
14959: PUSH
14960: LD_INT 53
14962: PUSH
14963: LD_INT 54
14965: PUSH
14966: LD_INT 55
14968: PUSH
14969: LD_INT 56
14971: PUSH
14972: LD_INT 57
14974: PUSH
14975: LD_INT 58
14977: PUSH
14978: LD_INT 59
14980: PUSH
14981: LD_INT 63
14983: PUSH
14984: LD_INT 64
14986: PUSH
14987: LD_INT 65
14989: PUSH
14990: LD_INT 82
14992: PUSH
14993: LD_INT 83
14995: PUSH
14996: LD_INT 84
14998: PUSH
14999: LD_INT 85
15001: PUSH
15002: LD_INT 86
15004: PUSH
15005: EMPTY
15006: LIST
15007: LIST
15008: LIST
15009: LIST
15010: LIST
15011: LIST
15012: LIST
15013: LIST
15014: LIST
15015: LIST
15016: LIST
15017: LIST
15018: LIST
15019: LIST
15020: LIST
15021: LIST
15022: LIST
15023: LIST
15024: LIST
15025: LIST
15026: LIST
15027: LIST
15028: LIST
15029: LIST
15030: LIST
15031: LIST
15032: LIST
15033: LIST
15034: LIST
15035: LIST
15036: LIST
15037: LIST
15038: LIST
15039: LIST
15040: LIST
15041: LIST
15042: LIST
15043: LIST
15044: LIST
15045: LIST
15046: LIST
15047: LIST
15048: LIST
15049: LIST
15050: LIST
15051: LIST
15052: LIST
15053: LIST
15054: LIST
15055: LIST
15056: LIST
15057: LIST
15058: LIST
15059: ST_TO_ADDR
15060: GO 15063
15062: POP
// if state > - 1 and state < 3 then
15063: LD_VAR 0 3
15067: PUSH
15068: LD_INT 1
15070: NEG
15071: GREATER
15072: PUSH
15073: LD_VAR 0 3
15077: PUSH
15078: LD_INT 3
15080: LESS
15081: AND
15082: IFFALSE 15139
// for i in result do
15084: LD_ADDR_VAR 0 5
15088: PUSH
15089: LD_VAR 0 4
15093: PUSH
15094: FOR_IN
15095: IFFALSE 15137
// if GetTech ( i , side ) <> state then
15097: LD_VAR 0 5
15101: PPUSH
15102: LD_VAR 0 1
15106: PPUSH
15107: CALL_OW 321
15111: PUSH
15112: LD_VAR 0 3
15116: NONEQUAL
15117: IFFALSE 15135
// result := result diff i ;
15119: LD_ADDR_VAR 0 4
15123: PUSH
15124: LD_VAR 0 4
15128: PUSH
15129: LD_VAR 0 5
15133: DIFF
15134: ST_TO_ADDR
15135: GO 15094
15137: POP
15138: POP
// end ;
15139: LD_VAR 0 4
15143: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15144: LD_INT 0
15146: PPUSH
15147: PPUSH
15148: PPUSH
// result := true ;
15149: LD_ADDR_VAR 0 3
15153: PUSH
15154: LD_INT 1
15156: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15157: LD_ADDR_VAR 0 5
15161: PUSH
15162: LD_VAR 0 2
15166: PPUSH
15167: CALL_OW 480
15171: ST_TO_ADDR
// if not tmp then
15172: LD_VAR 0 5
15176: NOT
15177: IFFALSE 15181
// exit ;
15179: GO 15230
// for i in tmp do
15181: LD_ADDR_VAR 0 4
15185: PUSH
15186: LD_VAR 0 5
15190: PUSH
15191: FOR_IN
15192: IFFALSE 15228
// if GetTech ( i , side ) <> state_researched then
15194: LD_VAR 0 4
15198: PPUSH
15199: LD_VAR 0 1
15203: PPUSH
15204: CALL_OW 321
15208: PUSH
15209: LD_INT 2
15211: NONEQUAL
15212: IFFALSE 15226
// begin result := false ;
15214: LD_ADDR_VAR 0 3
15218: PUSH
15219: LD_INT 0
15221: ST_TO_ADDR
// exit ;
15222: POP
15223: POP
15224: GO 15230
// end ;
15226: GO 15191
15228: POP
15229: POP
// end ;
15230: LD_VAR 0 3
15234: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15235: LD_INT 0
15237: PPUSH
15238: PPUSH
15239: PPUSH
15240: PPUSH
15241: PPUSH
15242: PPUSH
15243: PPUSH
15244: PPUSH
15245: PPUSH
15246: PPUSH
15247: PPUSH
15248: PPUSH
15249: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15250: LD_VAR 0 1
15254: NOT
15255: PUSH
15256: LD_VAR 0 1
15260: PPUSH
15261: CALL_OW 257
15265: PUSH
15266: LD_INT 9
15268: NONEQUAL
15269: OR
15270: IFFALSE 15274
// exit ;
15272: GO 15847
// side := GetSide ( unit ) ;
15274: LD_ADDR_VAR 0 9
15278: PUSH
15279: LD_VAR 0 1
15283: PPUSH
15284: CALL_OW 255
15288: ST_TO_ADDR
// tech_space := tech_spacanom ;
15289: LD_ADDR_VAR 0 12
15293: PUSH
15294: LD_INT 29
15296: ST_TO_ADDR
// tech_time := tech_taurad ;
15297: LD_ADDR_VAR 0 13
15301: PUSH
15302: LD_INT 28
15304: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15305: LD_ADDR_VAR 0 11
15309: PUSH
15310: LD_VAR 0 1
15314: PPUSH
15315: CALL_OW 310
15319: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15320: LD_VAR 0 11
15324: PPUSH
15325: CALL_OW 247
15329: PUSH
15330: LD_INT 2
15332: EQUAL
15333: IFFALSE 15337
// exit ;
15335: GO 15847
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15337: LD_ADDR_VAR 0 8
15341: PUSH
15342: LD_INT 81
15344: PUSH
15345: LD_VAR 0 9
15349: PUSH
15350: EMPTY
15351: LIST
15352: LIST
15353: PUSH
15354: LD_INT 3
15356: PUSH
15357: LD_INT 21
15359: PUSH
15360: LD_INT 3
15362: PUSH
15363: EMPTY
15364: LIST
15365: LIST
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: PPUSH
15375: CALL_OW 69
15379: ST_TO_ADDR
// if not tmp then
15380: LD_VAR 0 8
15384: NOT
15385: IFFALSE 15389
// exit ;
15387: GO 15847
// if in_unit then
15389: LD_VAR 0 11
15393: IFFALSE 15417
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15395: LD_ADDR_VAR 0 10
15399: PUSH
15400: LD_VAR 0 8
15404: PPUSH
15405: LD_VAR 0 11
15409: PPUSH
15410: CALL_OW 74
15414: ST_TO_ADDR
15415: GO 15437
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15417: LD_ADDR_VAR 0 10
15421: PUSH
15422: LD_VAR 0 8
15426: PPUSH
15427: LD_VAR 0 1
15431: PPUSH
15432: CALL_OW 74
15436: ST_TO_ADDR
// if not enemy then
15437: LD_VAR 0 10
15441: NOT
15442: IFFALSE 15446
// exit ;
15444: GO 15847
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15446: LD_VAR 0 11
15450: PUSH
15451: LD_VAR 0 11
15455: PPUSH
15456: LD_VAR 0 10
15460: PPUSH
15461: CALL_OW 296
15465: PUSH
15466: LD_INT 13
15468: GREATER
15469: AND
15470: PUSH
15471: LD_VAR 0 1
15475: PPUSH
15476: LD_VAR 0 10
15480: PPUSH
15481: CALL_OW 296
15485: PUSH
15486: LD_INT 12
15488: GREATER
15489: OR
15490: IFFALSE 15494
// exit ;
15492: GO 15847
// missile := [ 1 ] ;
15494: LD_ADDR_VAR 0 14
15498: PUSH
15499: LD_INT 1
15501: PUSH
15502: EMPTY
15503: LIST
15504: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15505: LD_VAR 0 9
15509: PPUSH
15510: LD_VAR 0 12
15514: PPUSH
15515: CALL_OW 325
15519: IFFALSE 15548
// missile := Insert ( missile , missile + 1 , 2 ) ;
15521: LD_ADDR_VAR 0 14
15525: PUSH
15526: LD_VAR 0 14
15530: PPUSH
15531: LD_VAR 0 14
15535: PUSH
15536: LD_INT 1
15538: PLUS
15539: PPUSH
15540: LD_INT 2
15542: PPUSH
15543: CALL_OW 2
15547: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15548: LD_VAR 0 9
15552: PPUSH
15553: LD_VAR 0 13
15557: PPUSH
15558: CALL_OW 325
15562: PUSH
15563: LD_VAR 0 10
15567: PPUSH
15568: CALL_OW 255
15572: PPUSH
15573: LD_VAR 0 13
15577: PPUSH
15578: CALL_OW 325
15582: NOT
15583: AND
15584: IFFALSE 15613
// missile := Insert ( missile , missile + 1 , 3 ) ;
15586: LD_ADDR_VAR 0 14
15590: PUSH
15591: LD_VAR 0 14
15595: PPUSH
15596: LD_VAR 0 14
15600: PUSH
15601: LD_INT 1
15603: PLUS
15604: PPUSH
15605: LD_INT 3
15607: PPUSH
15608: CALL_OW 2
15612: ST_TO_ADDR
// if missile < 2 then
15613: LD_VAR 0 14
15617: PUSH
15618: LD_INT 2
15620: LESS
15621: IFFALSE 15625
// exit ;
15623: GO 15847
// x := GetX ( enemy ) ;
15625: LD_ADDR_VAR 0 4
15629: PUSH
15630: LD_VAR 0 10
15634: PPUSH
15635: CALL_OW 250
15639: ST_TO_ADDR
// y := GetY ( enemy ) ;
15640: LD_ADDR_VAR 0 5
15644: PUSH
15645: LD_VAR 0 10
15649: PPUSH
15650: CALL_OW 251
15654: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15655: LD_ADDR_VAR 0 6
15659: PUSH
15660: LD_VAR 0 4
15664: PUSH
15665: LD_INT 1
15667: NEG
15668: PPUSH
15669: LD_INT 1
15671: PPUSH
15672: CALL_OW 12
15676: PLUS
15677: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15678: LD_ADDR_VAR 0 7
15682: PUSH
15683: LD_VAR 0 5
15687: PUSH
15688: LD_INT 1
15690: NEG
15691: PPUSH
15692: LD_INT 1
15694: PPUSH
15695: CALL_OW 12
15699: PLUS
15700: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15701: LD_VAR 0 6
15705: PPUSH
15706: LD_VAR 0 7
15710: PPUSH
15711: CALL_OW 488
15715: NOT
15716: IFFALSE 15738
// begin _x := x ;
15718: LD_ADDR_VAR 0 6
15722: PUSH
15723: LD_VAR 0 4
15727: ST_TO_ADDR
// _y := y ;
15728: LD_ADDR_VAR 0 7
15732: PUSH
15733: LD_VAR 0 5
15737: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15738: LD_ADDR_VAR 0 3
15742: PUSH
15743: LD_INT 1
15745: PPUSH
15746: LD_VAR 0 14
15750: PPUSH
15751: CALL_OW 12
15755: ST_TO_ADDR
// case i of 1 :
15756: LD_VAR 0 3
15760: PUSH
15761: LD_INT 1
15763: DOUBLE
15764: EQUAL
15765: IFTRUE 15769
15767: GO 15786
15769: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15770: LD_VAR 0 1
15774: PPUSH
15775: LD_VAR 0 10
15779: PPUSH
15780: CALL_OW 115
15784: GO 15847
15786: LD_INT 2
15788: DOUBLE
15789: EQUAL
15790: IFTRUE 15794
15792: GO 15816
15794: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15795: LD_VAR 0 1
15799: PPUSH
15800: LD_VAR 0 6
15804: PPUSH
15805: LD_VAR 0 7
15809: PPUSH
15810: CALL_OW 153
15814: GO 15847
15816: LD_INT 3
15818: DOUBLE
15819: EQUAL
15820: IFTRUE 15824
15822: GO 15846
15824: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15825: LD_VAR 0 1
15829: PPUSH
15830: LD_VAR 0 6
15834: PPUSH
15835: LD_VAR 0 7
15839: PPUSH
15840: CALL_OW 154
15844: GO 15847
15846: POP
// end ;
15847: LD_VAR 0 2
15851: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15852: LD_INT 0
15854: PPUSH
15855: PPUSH
15856: PPUSH
15857: PPUSH
15858: PPUSH
15859: PPUSH
// if not unit or not building then
15860: LD_VAR 0 1
15864: NOT
15865: PUSH
15866: LD_VAR 0 2
15870: NOT
15871: OR
15872: IFFALSE 15876
// exit ;
15874: GO 16034
// x := GetX ( building ) ;
15876: LD_ADDR_VAR 0 5
15880: PUSH
15881: LD_VAR 0 2
15885: PPUSH
15886: CALL_OW 250
15890: ST_TO_ADDR
// y := GetY ( building ) ;
15891: LD_ADDR_VAR 0 6
15895: PUSH
15896: LD_VAR 0 2
15900: PPUSH
15901: CALL_OW 251
15905: ST_TO_ADDR
// for i = 0 to 5 do
15906: LD_ADDR_VAR 0 4
15910: PUSH
15911: DOUBLE
15912: LD_INT 0
15914: DEC
15915: ST_TO_ADDR
15916: LD_INT 5
15918: PUSH
15919: FOR_TO
15920: IFFALSE 16032
// begin _x := ShiftX ( x , i , 3 ) ;
15922: LD_ADDR_VAR 0 7
15926: PUSH
15927: LD_VAR 0 5
15931: PPUSH
15932: LD_VAR 0 4
15936: PPUSH
15937: LD_INT 3
15939: PPUSH
15940: CALL_OW 272
15944: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15945: LD_ADDR_VAR 0 8
15949: PUSH
15950: LD_VAR 0 6
15954: PPUSH
15955: LD_VAR 0 4
15959: PPUSH
15960: LD_INT 3
15962: PPUSH
15963: CALL_OW 273
15967: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15968: LD_VAR 0 7
15972: PPUSH
15973: LD_VAR 0 8
15977: PPUSH
15978: CALL_OW 488
15982: NOT
15983: IFFALSE 15987
// continue ;
15985: GO 15919
// if HexInfo ( _x , _y ) = 0 then
15987: LD_VAR 0 7
15991: PPUSH
15992: LD_VAR 0 8
15996: PPUSH
15997: CALL_OW 428
16001: PUSH
16002: LD_INT 0
16004: EQUAL
16005: IFFALSE 16030
// begin ComMoveXY ( unit , _x , _y ) ;
16007: LD_VAR 0 1
16011: PPUSH
16012: LD_VAR 0 7
16016: PPUSH
16017: LD_VAR 0 8
16021: PPUSH
16022: CALL_OW 111
// exit ;
16026: POP
16027: POP
16028: GO 16034
// end ; end ;
16030: GO 15919
16032: POP
16033: POP
// end ;
16034: LD_VAR 0 3
16038: RET
// export function ScanBase ( side , base_area ) ; begin
16039: LD_INT 0
16041: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16042: LD_ADDR_VAR 0 3
16046: PUSH
16047: LD_VAR 0 2
16051: PPUSH
16052: LD_INT 81
16054: PUSH
16055: LD_VAR 0 1
16059: PUSH
16060: EMPTY
16061: LIST
16062: LIST
16063: PPUSH
16064: CALL_OW 70
16068: ST_TO_ADDR
// end ;
16069: LD_VAR 0 3
16073: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16074: LD_INT 0
16076: PPUSH
16077: PPUSH
16078: PPUSH
16079: PPUSH
// result := false ;
16080: LD_ADDR_VAR 0 2
16084: PUSH
16085: LD_INT 0
16087: ST_TO_ADDR
// side := GetSide ( unit ) ;
16088: LD_ADDR_VAR 0 3
16092: PUSH
16093: LD_VAR 0 1
16097: PPUSH
16098: CALL_OW 255
16102: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16103: LD_ADDR_VAR 0 4
16107: PUSH
16108: LD_VAR 0 1
16112: PPUSH
16113: CALL_OW 248
16117: ST_TO_ADDR
// case nat of 1 :
16118: LD_VAR 0 4
16122: PUSH
16123: LD_INT 1
16125: DOUBLE
16126: EQUAL
16127: IFTRUE 16131
16129: GO 16142
16131: POP
// tech := tech_lassight ; 2 :
16132: LD_ADDR_VAR 0 5
16136: PUSH
16137: LD_INT 12
16139: ST_TO_ADDR
16140: GO 16181
16142: LD_INT 2
16144: DOUBLE
16145: EQUAL
16146: IFTRUE 16150
16148: GO 16161
16150: POP
// tech := tech_mortar ; 3 :
16151: LD_ADDR_VAR 0 5
16155: PUSH
16156: LD_INT 41
16158: ST_TO_ADDR
16159: GO 16181
16161: LD_INT 3
16163: DOUBLE
16164: EQUAL
16165: IFTRUE 16169
16167: GO 16180
16169: POP
// tech := tech_bazooka ; end ;
16170: LD_ADDR_VAR 0 5
16174: PUSH
16175: LD_INT 44
16177: ST_TO_ADDR
16178: GO 16181
16180: POP
// if Researched ( side , tech ) then
16181: LD_VAR 0 3
16185: PPUSH
16186: LD_VAR 0 5
16190: PPUSH
16191: CALL_OW 325
16195: IFFALSE 16222
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16197: LD_ADDR_VAR 0 2
16201: PUSH
16202: LD_INT 5
16204: PUSH
16205: LD_INT 8
16207: PUSH
16208: LD_INT 9
16210: PUSH
16211: EMPTY
16212: LIST
16213: LIST
16214: LIST
16215: PUSH
16216: LD_VAR 0 4
16220: ARRAY
16221: ST_TO_ADDR
// end ;
16222: LD_VAR 0 2
16226: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16227: LD_INT 0
16229: PPUSH
16230: PPUSH
16231: PPUSH
// if not mines then
16232: LD_VAR 0 2
16236: NOT
16237: IFFALSE 16241
// exit ;
16239: GO 16385
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16241: LD_ADDR_VAR 0 5
16245: PUSH
16246: LD_INT 81
16248: PUSH
16249: LD_VAR 0 1
16253: PUSH
16254: EMPTY
16255: LIST
16256: LIST
16257: PUSH
16258: LD_INT 3
16260: PUSH
16261: LD_INT 21
16263: PUSH
16264: LD_INT 3
16266: PUSH
16267: EMPTY
16268: LIST
16269: LIST
16270: PUSH
16271: EMPTY
16272: LIST
16273: LIST
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: PPUSH
16279: CALL_OW 69
16283: ST_TO_ADDR
// for i in mines do
16284: LD_ADDR_VAR 0 4
16288: PUSH
16289: LD_VAR 0 2
16293: PUSH
16294: FOR_IN
16295: IFFALSE 16383
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16297: LD_VAR 0 4
16301: PUSH
16302: LD_INT 1
16304: ARRAY
16305: PPUSH
16306: LD_VAR 0 4
16310: PUSH
16311: LD_INT 2
16313: ARRAY
16314: PPUSH
16315: CALL_OW 458
16319: NOT
16320: IFFALSE 16324
// continue ;
16322: GO 16294
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16324: LD_VAR 0 4
16328: PUSH
16329: LD_INT 1
16331: ARRAY
16332: PPUSH
16333: LD_VAR 0 4
16337: PUSH
16338: LD_INT 2
16340: ARRAY
16341: PPUSH
16342: CALL_OW 428
16346: PUSH
16347: LD_VAR 0 5
16351: IN
16352: IFFALSE 16381
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16354: LD_VAR 0 4
16358: PUSH
16359: LD_INT 1
16361: ARRAY
16362: PPUSH
16363: LD_VAR 0 4
16367: PUSH
16368: LD_INT 2
16370: ARRAY
16371: PPUSH
16372: LD_VAR 0 1
16376: PPUSH
16377: CALL_OW 456
// end ;
16381: GO 16294
16383: POP
16384: POP
// end ;
16385: LD_VAR 0 3
16389: RET
// export function Count ( array ) ; var i ; begin
16390: LD_INT 0
16392: PPUSH
16393: PPUSH
// result := 0 ;
16394: LD_ADDR_VAR 0 2
16398: PUSH
16399: LD_INT 0
16401: ST_TO_ADDR
// for i in array do
16402: LD_ADDR_VAR 0 3
16406: PUSH
16407: LD_VAR 0 1
16411: PUSH
16412: FOR_IN
16413: IFFALSE 16437
// if i then
16415: LD_VAR 0 3
16419: IFFALSE 16435
// result := result + 1 ;
16421: LD_ADDR_VAR 0 2
16425: PUSH
16426: LD_VAR 0 2
16430: PUSH
16431: LD_INT 1
16433: PLUS
16434: ST_TO_ADDR
16435: GO 16412
16437: POP
16438: POP
// end ;
16439: LD_VAR 0 2
16443: RET
// export function IsEmpty ( building ) ; begin
16444: LD_INT 0
16446: PPUSH
// if not building then
16447: LD_VAR 0 1
16451: NOT
16452: IFFALSE 16456
// exit ;
16454: GO 16499
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
16456: LD_ADDR_VAR 0 2
16460: PUSH
16461: LD_VAR 0 1
16465: PUSH
16466: LD_INT 22
16468: PUSH
16469: LD_VAR 0 1
16473: PPUSH
16474: CALL_OW 255
16478: PUSH
16479: EMPTY
16480: LIST
16481: LIST
16482: PUSH
16483: LD_INT 58
16485: PUSH
16486: EMPTY
16487: LIST
16488: PUSH
16489: EMPTY
16490: LIST
16491: LIST
16492: PPUSH
16493: CALL_OW 69
16497: IN
16498: ST_TO_ADDR
// end ;
16499: LD_VAR 0 2
16503: RET
// export function IsNotFull ( building ) ; begin
16504: LD_INT 0
16506: PPUSH
// if not building then
16507: LD_VAR 0 1
16511: NOT
16512: IFFALSE 16516
// exit ;
16514: GO 16535
// result := UnitsInside ( building ) < 6 ;
16516: LD_ADDR_VAR 0 2
16520: PUSH
16521: LD_VAR 0 1
16525: PPUSH
16526: CALL_OW 313
16530: PUSH
16531: LD_INT 6
16533: LESS
16534: ST_TO_ADDR
// end ;
16535: LD_VAR 0 2
16539: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
16540: LD_INT 0
16542: PPUSH
16543: PPUSH
16544: PPUSH
16545: PPUSH
// tmp := [ ] ;
16546: LD_ADDR_VAR 0 3
16550: PUSH
16551: EMPTY
16552: ST_TO_ADDR
// list := [ ] ;
16553: LD_ADDR_VAR 0 5
16557: PUSH
16558: EMPTY
16559: ST_TO_ADDR
// for i = 16 to 25 do
16560: LD_ADDR_VAR 0 4
16564: PUSH
16565: DOUBLE
16566: LD_INT 16
16568: DEC
16569: ST_TO_ADDR
16570: LD_INT 25
16572: PUSH
16573: FOR_TO
16574: IFFALSE 16647
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
16576: LD_ADDR_VAR 0 3
16580: PUSH
16581: LD_VAR 0 3
16585: PUSH
16586: LD_INT 22
16588: PUSH
16589: LD_VAR 0 1
16593: PPUSH
16594: CALL_OW 255
16598: PUSH
16599: EMPTY
16600: LIST
16601: LIST
16602: PUSH
16603: LD_INT 91
16605: PUSH
16606: LD_VAR 0 1
16610: PUSH
16611: LD_INT 6
16613: PUSH
16614: EMPTY
16615: LIST
16616: LIST
16617: LIST
16618: PUSH
16619: LD_INT 30
16621: PUSH
16622: LD_VAR 0 4
16626: PUSH
16627: EMPTY
16628: LIST
16629: LIST
16630: PUSH
16631: EMPTY
16632: LIST
16633: LIST
16634: LIST
16635: PUSH
16636: EMPTY
16637: LIST
16638: PPUSH
16639: CALL_OW 69
16643: ADD
16644: ST_TO_ADDR
16645: GO 16573
16647: POP
16648: POP
// for i = 1 to tmp do
16649: LD_ADDR_VAR 0 4
16653: PUSH
16654: DOUBLE
16655: LD_INT 1
16657: DEC
16658: ST_TO_ADDR
16659: LD_VAR 0 3
16663: PUSH
16664: FOR_TO
16665: IFFALSE 16753
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
16667: LD_ADDR_VAR 0 5
16671: PUSH
16672: LD_VAR 0 5
16676: PUSH
16677: LD_VAR 0 3
16681: PUSH
16682: LD_VAR 0 4
16686: ARRAY
16687: PPUSH
16688: CALL_OW 266
16692: PUSH
16693: LD_VAR 0 3
16697: PUSH
16698: LD_VAR 0 4
16702: ARRAY
16703: PPUSH
16704: CALL_OW 250
16708: PUSH
16709: LD_VAR 0 3
16713: PUSH
16714: LD_VAR 0 4
16718: ARRAY
16719: PPUSH
16720: CALL_OW 251
16724: PUSH
16725: LD_VAR 0 3
16729: PUSH
16730: LD_VAR 0 4
16734: ARRAY
16735: PPUSH
16736: CALL_OW 254
16740: PUSH
16741: EMPTY
16742: LIST
16743: LIST
16744: LIST
16745: LIST
16746: PUSH
16747: EMPTY
16748: LIST
16749: ADD
16750: ST_TO_ADDR
16751: GO 16664
16753: POP
16754: POP
// result := list ;
16755: LD_ADDR_VAR 0 2
16759: PUSH
16760: LD_VAR 0 5
16764: ST_TO_ADDR
// end ;
16765: LD_VAR 0 2
16769: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16770: LD_INT 0
16772: PPUSH
16773: PPUSH
16774: PPUSH
16775: PPUSH
16776: PPUSH
16777: PPUSH
16778: PPUSH
// if not factory then
16779: LD_VAR 0 1
16783: NOT
16784: IFFALSE 16788
// exit ;
16786: GO 17381
// if control = control_apeman then
16788: LD_VAR 0 4
16792: PUSH
16793: LD_INT 5
16795: EQUAL
16796: IFFALSE 16905
// begin tmp := UnitsInside ( factory ) ;
16798: LD_ADDR_VAR 0 8
16802: PUSH
16803: LD_VAR 0 1
16807: PPUSH
16808: CALL_OW 313
16812: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16813: LD_VAR 0 8
16817: PPUSH
16818: LD_INT 25
16820: PUSH
16821: LD_INT 12
16823: PUSH
16824: EMPTY
16825: LIST
16826: LIST
16827: PPUSH
16828: CALL_OW 72
16832: NOT
16833: IFFALSE 16843
// control := control_manual ;
16835: LD_ADDR_VAR 0 4
16839: PUSH
16840: LD_INT 1
16842: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16843: LD_ADDR_VAR 0 8
16847: PUSH
16848: LD_VAR 0 1
16852: PPUSH
16853: CALL 16540 0 1
16857: ST_TO_ADDR
// if tmp then
16858: LD_VAR 0 8
16862: IFFALSE 16905
// begin for i in tmp do
16864: LD_ADDR_VAR 0 7
16868: PUSH
16869: LD_VAR 0 8
16873: PUSH
16874: FOR_IN
16875: IFFALSE 16903
// if i [ 1 ] = b_ext_radio then
16877: LD_VAR 0 7
16881: PUSH
16882: LD_INT 1
16884: ARRAY
16885: PUSH
16886: LD_INT 22
16888: EQUAL
16889: IFFALSE 16901
// begin control := control_remote ;
16891: LD_ADDR_VAR 0 4
16895: PUSH
16896: LD_INT 2
16898: ST_TO_ADDR
// break ;
16899: GO 16903
// end ;
16901: GO 16874
16903: POP
16904: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16905: LD_VAR 0 1
16909: PPUSH
16910: LD_VAR 0 2
16914: PPUSH
16915: LD_VAR 0 3
16919: PPUSH
16920: LD_VAR 0 4
16924: PPUSH
16925: LD_VAR 0 5
16929: PPUSH
16930: CALL_OW 448
16934: IFFALSE 16969
// begin result := [ chassis , engine , control , weapon ] ;
16936: LD_ADDR_VAR 0 6
16940: PUSH
16941: LD_VAR 0 2
16945: PUSH
16946: LD_VAR 0 3
16950: PUSH
16951: LD_VAR 0 4
16955: PUSH
16956: LD_VAR 0 5
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: LIST
16965: LIST
16966: ST_TO_ADDR
// exit ;
16967: GO 17381
// end ; _chassis := AvailableChassisList ( factory ) ;
16969: LD_ADDR_VAR 0 9
16973: PUSH
16974: LD_VAR 0 1
16978: PPUSH
16979: CALL_OW 475
16983: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16984: LD_ADDR_VAR 0 11
16988: PUSH
16989: LD_VAR 0 1
16993: PPUSH
16994: CALL_OW 476
16998: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16999: LD_ADDR_VAR 0 12
17003: PUSH
17004: LD_VAR 0 1
17008: PPUSH
17009: CALL_OW 477
17013: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17014: LD_ADDR_VAR 0 10
17018: PUSH
17019: LD_VAR 0 1
17023: PPUSH
17024: CALL_OW 478
17028: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17029: LD_VAR 0 9
17033: NOT
17034: PUSH
17035: LD_VAR 0 11
17039: NOT
17040: OR
17041: PUSH
17042: LD_VAR 0 12
17046: NOT
17047: OR
17048: PUSH
17049: LD_VAR 0 10
17053: NOT
17054: OR
17055: IFFALSE 17090
// begin result := [ chassis , engine , control , weapon ] ;
17057: LD_ADDR_VAR 0 6
17061: PUSH
17062: LD_VAR 0 2
17066: PUSH
17067: LD_VAR 0 3
17071: PUSH
17072: LD_VAR 0 4
17076: PUSH
17077: LD_VAR 0 5
17081: PUSH
17082: EMPTY
17083: LIST
17084: LIST
17085: LIST
17086: LIST
17087: ST_TO_ADDR
// exit ;
17088: GO 17381
// end ; if not chassis in _chassis then
17090: LD_VAR 0 2
17094: PUSH
17095: LD_VAR 0 9
17099: IN
17100: NOT
17101: IFFALSE 17127
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17103: LD_ADDR_VAR 0 2
17107: PUSH
17108: LD_VAR 0 9
17112: PUSH
17113: LD_INT 1
17115: PPUSH
17116: LD_VAR 0 9
17120: PPUSH
17121: CALL_OW 12
17125: ARRAY
17126: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17127: LD_VAR 0 2
17131: PPUSH
17132: LD_VAR 0 3
17136: PPUSH
17137: CALL 17386 0 2
17141: NOT
17142: IFFALSE 17201
// repeat engine := _engine [ 1 ] ;
17144: LD_ADDR_VAR 0 3
17148: PUSH
17149: LD_VAR 0 11
17153: PUSH
17154: LD_INT 1
17156: ARRAY
17157: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17158: LD_ADDR_VAR 0 11
17162: PUSH
17163: LD_VAR 0 11
17167: PPUSH
17168: LD_INT 1
17170: PPUSH
17171: CALL_OW 3
17175: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17176: LD_VAR 0 2
17180: PPUSH
17181: LD_VAR 0 3
17185: PPUSH
17186: CALL 17386 0 2
17190: PUSH
17191: LD_VAR 0 11
17195: PUSH
17196: EMPTY
17197: EQUAL
17198: OR
17199: IFFALSE 17144
// if not control in _control then
17201: LD_VAR 0 4
17205: PUSH
17206: LD_VAR 0 12
17210: IN
17211: NOT
17212: IFFALSE 17238
// control := _control [ rand ( 1 , _control ) ] ;
17214: LD_ADDR_VAR 0 4
17218: PUSH
17219: LD_VAR 0 12
17223: PUSH
17224: LD_INT 1
17226: PPUSH
17227: LD_VAR 0 12
17231: PPUSH
17232: CALL_OW 12
17236: ARRAY
17237: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17238: LD_VAR 0 2
17242: PPUSH
17243: LD_VAR 0 5
17247: PPUSH
17248: CALL 17606 0 2
17252: NOT
17253: IFFALSE 17312
// repeat weapon := _weapon [ 1 ] ;
17255: LD_ADDR_VAR 0 5
17259: PUSH
17260: LD_VAR 0 10
17264: PUSH
17265: LD_INT 1
17267: ARRAY
17268: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17269: LD_ADDR_VAR 0 10
17273: PUSH
17274: LD_VAR 0 10
17278: PPUSH
17279: LD_INT 1
17281: PPUSH
17282: CALL_OW 3
17286: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17287: LD_VAR 0 2
17291: PPUSH
17292: LD_VAR 0 5
17296: PPUSH
17297: CALL 17606 0 2
17301: PUSH
17302: LD_VAR 0 10
17306: PUSH
17307: EMPTY
17308: EQUAL
17309: OR
17310: IFFALSE 17255
// result := [ ] ;
17312: LD_ADDR_VAR 0 6
17316: PUSH
17317: EMPTY
17318: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17319: LD_VAR 0 1
17323: PPUSH
17324: LD_VAR 0 2
17328: PPUSH
17329: LD_VAR 0 3
17333: PPUSH
17334: LD_VAR 0 4
17338: PPUSH
17339: LD_VAR 0 5
17343: PPUSH
17344: CALL_OW 448
17348: IFFALSE 17381
// result := [ chassis , engine , control , weapon ] ;
17350: LD_ADDR_VAR 0 6
17354: PUSH
17355: LD_VAR 0 2
17359: PUSH
17360: LD_VAR 0 3
17364: PUSH
17365: LD_VAR 0 4
17369: PUSH
17370: LD_VAR 0 5
17374: PUSH
17375: EMPTY
17376: LIST
17377: LIST
17378: LIST
17379: LIST
17380: ST_TO_ADDR
// end ;
17381: LD_VAR 0 6
17385: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
17386: LD_INT 0
17388: PPUSH
// if not chassis or not engine then
17389: LD_VAR 0 1
17393: NOT
17394: PUSH
17395: LD_VAR 0 2
17399: NOT
17400: OR
17401: IFFALSE 17405
// exit ;
17403: GO 17601
// case engine of engine_solar :
17405: LD_VAR 0 2
17409: PUSH
17410: LD_INT 2
17412: DOUBLE
17413: EQUAL
17414: IFTRUE 17418
17416: GO 17456
17418: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
17419: LD_ADDR_VAR 0 3
17423: PUSH
17424: LD_INT 11
17426: PUSH
17427: LD_INT 12
17429: PUSH
17430: LD_INT 13
17432: PUSH
17433: LD_INT 14
17435: PUSH
17436: LD_INT 1
17438: PUSH
17439: LD_INT 2
17441: PUSH
17442: LD_INT 3
17444: PUSH
17445: EMPTY
17446: LIST
17447: LIST
17448: LIST
17449: LIST
17450: LIST
17451: LIST
17452: LIST
17453: ST_TO_ADDR
17454: GO 17585
17456: LD_INT 1
17458: DOUBLE
17459: EQUAL
17460: IFTRUE 17464
17462: GO 17526
17464: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
17465: LD_ADDR_VAR 0 3
17469: PUSH
17470: LD_INT 11
17472: PUSH
17473: LD_INT 12
17475: PUSH
17476: LD_INT 13
17478: PUSH
17479: LD_INT 14
17481: PUSH
17482: LD_INT 1
17484: PUSH
17485: LD_INT 2
17487: PUSH
17488: LD_INT 3
17490: PUSH
17491: LD_INT 4
17493: PUSH
17494: LD_INT 5
17496: PUSH
17497: LD_INT 21
17499: PUSH
17500: LD_INT 23
17502: PUSH
17503: LD_INT 22
17505: PUSH
17506: LD_INT 24
17508: PUSH
17509: EMPTY
17510: LIST
17511: LIST
17512: LIST
17513: LIST
17514: LIST
17515: LIST
17516: LIST
17517: LIST
17518: LIST
17519: LIST
17520: LIST
17521: LIST
17522: LIST
17523: ST_TO_ADDR
17524: GO 17585
17526: LD_INT 3
17528: DOUBLE
17529: EQUAL
17530: IFTRUE 17534
17532: GO 17584
17534: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17535: LD_ADDR_VAR 0 3
17539: PUSH
17540: LD_INT 13
17542: PUSH
17543: LD_INT 14
17545: PUSH
17546: LD_INT 2
17548: PUSH
17549: LD_INT 3
17551: PUSH
17552: LD_INT 4
17554: PUSH
17555: LD_INT 5
17557: PUSH
17558: LD_INT 21
17560: PUSH
17561: LD_INT 22
17563: PUSH
17564: LD_INT 23
17566: PUSH
17567: LD_INT 24
17569: PUSH
17570: EMPTY
17571: LIST
17572: LIST
17573: LIST
17574: LIST
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: ST_TO_ADDR
17582: GO 17585
17584: POP
// result := ( chassis in result ) ;
17585: LD_ADDR_VAR 0 3
17589: PUSH
17590: LD_VAR 0 1
17594: PUSH
17595: LD_VAR 0 3
17599: IN
17600: ST_TO_ADDR
// end ;
17601: LD_VAR 0 3
17605: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
17606: LD_INT 0
17608: PPUSH
// if not chassis or not weapon then
17609: LD_VAR 0 1
17613: NOT
17614: PUSH
17615: LD_VAR 0 2
17619: NOT
17620: OR
17621: IFFALSE 17625
// exit ;
17623: GO 18651
// case weapon of us_machine_gun :
17625: LD_VAR 0 2
17629: PUSH
17630: LD_INT 2
17632: DOUBLE
17633: EQUAL
17634: IFTRUE 17638
17636: GO 17668
17638: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
17639: LD_ADDR_VAR 0 3
17643: PUSH
17644: LD_INT 1
17646: PUSH
17647: LD_INT 2
17649: PUSH
17650: LD_INT 3
17652: PUSH
17653: LD_INT 4
17655: PUSH
17656: LD_INT 5
17658: PUSH
17659: EMPTY
17660: LIST
17661: LIST
17662: LIST
17663: LIST
17664: LIST
17665: ST_TO_ADDR
17666: GO 18635
17668: LD_INT 3
17670: DOUBLE
17671: EQUAL
17672: IFTRUE 17676
17674: GO 17706
17676: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
17677: LD_ADDR_VAR 0 3
17681: PUSH
17682: LD_INT 1
17684: PUSH
17685: LD_INT 2
17687: PUSH
17688: LD_INT 3
17690: PUSH
17691: LD_INT 4
17693: PUSH
17694: LD_INT 5
17696: PUSH
17697: EMPTY
17698: LIST
17699: LIST
17700: LIST
17701: LIST
17702: LIST
17703: ST_TO_ADDR
17704: GO 18635
17706: LD_INT 11
17708: DOUBLE
17709: EQUAL
17710: IFTRUE 17714
17712: GO 17744
17714: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17715: LD_ADDR_VAR 0 3
17719: PUSH
17720: LD_INT 1
17722: PUSH
17723: LD_INT 2
17725: PUSH
17726: LD_INT 3
17728: PUSH
17729: LD_INT 4
17731: PUSH
17732: LD_INT 5
17734: PUSH
17735: EMPTY
17736: LIST
17737: LIST
17738: LIST
17739: LIST
17740: LIST
17741: ST_TO_ADDR
17742: GO 18635
17744: LD_INT 4
17746: DOUBLE
17747: EQUAL
17748: IFTRUE 17752
17750: GO 17778
17752: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17753: LD_ADDR_VAR 0 3
17757: PUSH
17758: LD_INT 2
17760: PUSH
17761: LD_INT 3
17763: PUSH
17764: LD_INT 4
17766: PUSH
17767: LD_INT 5
17769: PUSH
17770: EMPTY
17771: LIST
17772: LIST
17773: LIST
17774: LIST
17775: ST_TO_ADDR
17776: GO 18635
17778: LD_INT 5
17780: DOUBLE
17781: EQUAL
17782: IFTRUE 17786
17784: GO 17812
17786: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17787: LD_ADDR_VAR 0 3
17791: PUSH
17792: LD_INT 2
17794: PUSH
17795: LD_INT 3
17797: PUSH
17798: LD_INT 4
17800: PUSH
17801: LD_INT 5
17803: PUSH
17804: EMPTY
17805: LIST
17806: LIST
17807: LIST
17808: LIST
17809: ST_TO_ADDR
17810: GO 18635
17812: LD_INT 9
17814: DOUBLE
17815: EQUAL
17816: IFTRUE 17820
17818: GO 17846
17820: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17821: LD_ADDR_VAR 0 3
17825: PUSH
17826: LD_INT 2
17828: PUSH
17829: LD_INT 3
17831: PUSH
17832: LD_INT 4
17834: PUSH
17835: LD_INT 5
17837: PUSH
17838: EMPTY
17839: LIST
17840: LIST
17841: LIST
17842: LIST
17843: ST_TO_ADDR
17844: GO 18635
17846: LD_INT 7
17848: DOUBLE
17849: EQUAL
17850: IFTRUE 17854
17852: GO 17880
17854: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17855: LD_ADDR_VAR 0 3
17859: PUSH
17860: LD_INT 2
17862: PUSH
17863: LD_INT 3
17865: PUSH
17866: LD_INT 4
17868: PUSH
17869: LD_INT 5
17871: PUSH
17872: EMPTY
17873: LIST
17874: LIST
17875: LIST
17876: LIST
17877: ST_TO_ADDR
17878: GO 18635
17880: LD_INT 12
17882: DOUBLE
17883: EQUAL
17884: IFTRUE 17888
17886: GO 17914
17888: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17889: LD_ADDR_VAR 0 3
17893: PUSH
17894: LD_INT 2
17896: PUSH
17897: LD_INT 3
17899: PUSH
17900: LD_INT 4
17902: PUSH
17903: LD_INT 5
17905: PUSH
17906: EMPTY
17907: LIST
17908: LIST
17909: LIST
17910: LIST
17911: ST_TO_ADDR
17912: GO 18635
17914: LD_INT 13
17916: DOUBLE
17917: EQUAL
17918: IFTRUE 17922
17920: GO 17948
17922: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17923: LD_ADDR_VAR 0 3
17927: PUSH
17928: LD_INT 2
17930: PUSH
17931: LD_INT 3
17933: PUSH
17934: LD_INT 4
17936: PUSH
17937: LD_INT 5
17939: PUSH
17940: EMPTY
17941: LIST
17942: LIST
17943: LIST
17944: LIST
17945: ST_TO_ADDR
17946: GO 18635
17948: LD_INT 14
17950: DOUBLE
17951: EQUAL
17952: IFTRUE 17956
17954: GO 17974
17956: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17957: LD_ADDR_VAR 0 3
17961: PUSH
17962: LD_INT 4
17964: PUSH
17965: LD_INT 5
17967: PUSH
17968: EMPTY
17969: LIST
17970: LIST
17971: ST_TO_ADDR
17972: GO 18635
17974: LD_INT 6
17976: DOUBLE
17977: EQUAL
17978: IFTRUE 17982
17980: GO 18000
17982: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17983: LD_ADDR_VAR 0 3
17987: PUSH
17988: LD_INT 4
17990: PUSH
17991: LD_INT 5
17993: PUSH
17994: EMPTY
17995: LIST
17996: LIST
17997: ST_TO_ADDR
17998: GO 18635
18000: LD_INT 10
18002: DOUBLE
18003: EQUAL
18004: IFTRUE 18008
18006: GO 18026
18008: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18009: LD_ADDR_VAR 0 3
18013: PUSH
18014: LD_INT 4
18016: PUSH
18017: LD_INT 5
18019: PUSH
18020: EMPTY
18021: LIST
18022: LIST
18023: ST_TO_ADDR
18024: GO 18635
18026: LD_INT 22
18028: DOUBLE
18029: EQUAL
18030: IFTRUE 18034
18032: GO 18060
18034: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18035: LD_ADDR_VAR 0 3
18039: PUSH
18040: LD_INT 11
18042: PUSH
18043: LD_INT 12
18045: PUSH
18046: LD_INT 13
18048: PUSH
18049: LD_INT 14
18051: PUSH
18052: EMPTY
18053: LIST
18054: LIST
18055: LIST
18056: LIST
18057: ST_TO_ADDR
18058: GO 18635
18060: LD_INT 23
18062: DOUBLE
18063: EQUAL
18064: IFTRUE 18068
18066: GO 18094
18068: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18069: LD_ADDR_VAR 0 3
18073: PUSH
18074: LD_INT 11
18076: PUSH
18077: LD_INT 12
18079: PUSH
18080: LD_INT 13
18082: PUSH
18083: LD_INT 14
18085: PUSH
18086: EMPTY
18087: LIST
18088: LIST
18089: LIST
18090: LIST
18091: ST_TO_ADDR
18092: GO 18635
18094: LD_INT 24
18096: DOUBLE
18097: EQUAL
18098: IFTRUE 18102
18100: GO 18128
18102: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18103: LD_ADDR_VAR 0 3
18107: PUSH
18108: LD_INT 11
18110: PUSH
18111: LD_INT 12
18113: PUSH
18114: LD_INT 13
18116: PUSH
18117: LD_INT 14
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: LIST
18125: ST_TO_ADDR
18126: GO 18635
18128: LD_INT 30
18130: DOUBLE
18131: EQUAL
18132: IFTRUE 18136
18134: GO 18162
18136: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18137: LD_ADDR_VAR 0 3
18141: PUSH
18142: LD_INT 11
18144: PUSH
18145: LD_INT 12
18147: PUSH
18148: LD_INT 13
18150: PUSH
18151: LD_INT 14
18153: PUSH
18154: EMPTY
18155: LIST
18156: LIST
18157: LIST
18158: LIST
18159: ST_TO_ADDR
18160: GO 18635
18162: LD_INT 25
18164: DOUBLE
18165: EQUAL
18166: IFTRUE 18170
18168: GO 18188
18170: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18171: LD_ADDR_VAR 0 3
18175: PUSH
18176: LD_INT 13
18178: PUSH
18179: LD_INT 14
18181: PUSH
18182: EMPTY
18183: LIST
18184: LIST
18185: ST_TO_ADDR
18186: GO 18635
18188: LD_INT 27
18190: DOUBLE
18191: EQUAL
18192: IFTRUE 18196
18194: GO 18214
18196: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18197: LD_ADDR_VAR 0 3
18201: PUSH
18202: LD_INT 13
18204: PUSH
18205: LD_INT 14
18207: PUSH
18208: EMPTY
18209: LIST
18210: LIST
18211: ST_TO_ADDR
18212: GO 18635
18214: LD_INT 28
18216: DOUBLE
18217: EQUAL
18218: IFTRUE 18222
18220: GO 18240
18222: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18223: LD_ADDR_VAR 0 3
18227: PUSH
18228: LD_INT 13
18230: PUSH
18231: LD_INT 14
18233: PUSH
18234: EMPTY
18235: LIST
18236: LIST
18237: ST_TO_ADDR
18238: GO 18635
18240: LD_INT 29
18242: DOUBLE
18243: EQUAL
18244: IFTRUE 18248
18246: GO 18266
18248: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18249: LD_ADDR_VAR 0 3
18253: PUSH
18254: LD_INT 13
18256: PUSH
18257: LD_INT 14
18259: PUSH
18260: EMPTY
18261: LIST
18262: LIST
18263: ST_TO_ADDR
18264: GO 18635
18266: LD_INT 31
18268: DOUBLE
18269: EQUAL
18270: IFTRUE 18274
18272: GO 18292
18274: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18275: LD_ADDR_VAR 0 3
18279: PUSH
18280: LD_INT 13
18282: PUSH
18283: LD_INT 14
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: ST_TO_ADDR
18290: GO 18635
18292: LD_INT 26
18294: DOUBLE
18295: EQUAL
18296: IFTRUE 18300
18298: GO 18318
18300: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18301: LD_ADDR_VAR 0 3
18305: PUSH
18306: LD_INT 13
18308: PUSH
18309: LD_INT 14
18311: PUSH
18312: EMPTY
18313: LIST
18314: LIST
18315: ST_TO_ADDR
18316: GO 18635
18318: LD_INT 42
18320: DOUBLE
18321: EQUAL
18322: IFTRUE 18326
18324: GO 18352
18326: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
18327: LD_ADDR_VAR 0 3
18331: PUSH
18332: LD_INT 21
18334: PUSH
18335: LD_INT 22
18337: PUSH
18338: LD_INT 23
18340: PUSH
18341: LD_INT 24
18343: PUSH
18344: EMPTY
18345: LIST
18346: LIST
18347: LIST
18348: LIST
18349: ST_TO_ADDR
18350: GO 18635
18352: LD_INT 43
18354: DOUBLE
18355: EQUAL
18356: IFTRUE 18360
18358: GO 18386
18360: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
18361: LD_ADDR_VAR 0 3
18365: PUSH
18366: LD_INT 21
18368: PUSH
18369: LD_INT 22
18371: PUSH
18372: LD_INT 23
18374: PUSH
18375: LD_INT 24
18377: PUSH
18378: EMPTY
18379: LIST
18380: LIST
18381: LIST
18382: LIST
18383: ST_TO_ADDR
18384: GO 18635
18386: LD_INT 44
18388: DOUBLE
18389: EQUAL
18390: IFTRUE 18394
18392: GO 18420
18394: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
18395: LD_ADDR_VAR 0 3
18399: PUSH
18400: LD_INT 21
18402: PUSH
18403: LD_INT 22
18405: PUSH
18406: LD_INT 23
18408: PUSH
18409: LD_INT 24
18411: PUSH
18412: EMPTY
18413: LIST
18414: LIST
18415: LIST
18416: LIST
18417: ST_TO_ADDR
18418: GO 18635
18420: LD_INT 45
18422: DOUBLE
18423: EQUAL
18424: IFTRUE 18428
18426: GO 18454
18428: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
18429: LD_ADDR_VAR 0 3
18433: PUSH
18434: LD_INT 21
18436: PUSH
18437: LD_INT 22
18439: PUSH
18440: LD_INT 23
18442: PUSH
18443: LD_INT 24
18445: PUSH
18446: EMPTY
18447: LIST
18448: LIST
18449: LIST
18450: LIST
18451: ST_TO_ADDR
18452: GO 18635
18454: LD_INT 49
18456: DOUBLE
18457: EQUAL
18458: IFTRUE 18462
18460: GO 18488
18462: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
18463: LD_ADDR_VAR 0 3
18467: PUSH
18468: LD_INT 21
18470: PUSH
18471: LD_INT 22
18473: PUSH
18474: LD_INT 23
18476: PUSH
18477: LD_INT 24
18479: PUSH
18480: EMPTY
18481: LIST
18482: LIST
18483: LIST
18484: LIST
18485: ST_TO_ADDR
18486: GO 18635
18488: LD_INT 51
18490: DOUBLE
18491: EQUAL
18492: IFTRUE 18496
18494: GO 18522
18496: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
18497: LD_ADDR_VAR 0 3
18501: PUSH
18502: LD_INT 21
18504: PUSH
18505: LD_INT 22
18507: PUSH
18508: LD_INT 23
18510: PUSH
18511: LD_INT 24
18513: PUSH
18514: EMPTY
18515: LIST
18516: LIST
18517: LIST
18518: LIST
18519: ST_TO_ADDR
18520: GO 18635
18522: LD_INT 52
18524: DOUBLE
18525: EQUAL
18526: IFTRUE 18530
18528: GO 18556
18530: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
18531: LD_ADDR_VAR 0 3
18535: PUSH
18536: LD_INT 21
18538: PUSH
18539: LD_INT 22
18541: PUSH
18542: LD_INT 23
18544: PUSH
18545: LD_INT 24
18547: PUSH
18548: EMPTY
18549: LIST
18550: LIST
18551: LIST
18552: LIST
18553: ST_TO_ADDR
18554: GO 18635
18556: LD_INT 53
18558: DOUBLE
18559: EQUAL
18560: IFTRUE 18564
18562: GO 18582
18564: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
18565: LD_ADDR_VAR 0 3
18569: PUSH
18570: LD_INT 23
18572: PUSH
18573: LD_INT 24
18575: PUSH
18576: EMPTY
18577: LIST
18578: LIST
18579: ST_TO_ADDR
18580: GO 18635
18582: LD_INT 46
18584: DOUBLE
18585: EQUAL
18586: IFTRUE 18590
18588: GO 18608
18590: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
18591: LD_ADDR_VAR 0 3
18595: PUSH
18596: LD_INT 23
18598: PUSH
18599: LD_INT 24
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: ST_TO_ADDR
18606: GO 18635
18608: LD_INT 47
18610: DOUBLE
18611: EQUAL
18612: IFTRUE 18616
18614: GO 18634
18616: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18617: LD_ADDR_VAR 0 3
18621: PUSH
18622: LD_INT 23
18624: PUSH
18625: LD_INT 24
18627: PUSH
18628: EMPTY
18629: LIST
18630: LIST
18631: ST_TO_ADDR
18632: GO 18635
18634: POP
// result := ( chassis in result ) ;
18635: LD_ADDR_VAR 0 3
18639: PUSH
18640: LD_VAR 0 1
18644: PUSH
18645: LD_VAR 0 3
18649: IN
18650: ST_TO_ADDR
// end ;
18651: LD_VAR 0 3
18655: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
18656: LD_INT 0
18658: PPUSH
18659: PPUSH
18660: PPUSH
18661: PPUSH
18662: PPUSH
18663: PPUSH
18664: PPUSH
// result := array ;
18665: LD_ADDR_VAR 0 5
18669: PUSH
18670: LD_VAR 0 1
18674: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18675: LD_VAR 0 1
18679: NOT
18680: PUSH
18681: LD_VAR 0 2
18685: NOT
18686: OR
18687: PUSH
18688: LD_VAR 0 3
18692: NOT
18693: OR
18694: PUSH
18695: LD_VAR 0 2
18699: PUSH
18700: LD_VAR 0 1
18704: GREATER
18705: OR
18706: PUSH
18707: LD_VAR 0 3
18711: PUSH
18712: LD_VAR 0 1
18716: GREATER
18717: OR
18718: IFFALSE 18722
// exit ;
18720: GO 19018
// if direction then
18722: LD_VAR 0 4
18726: IFFALSE 18790
// begin d := 1 ;
18728: LD_ADDR_VAR 0 9
18732: PUSH
18733: LD_INT 1
18735: ST_TO_ADDR
// if i_from > i_to then
18736: LD_VAR 0 2
18740: PUSH
18741: LD_VAR 0 3
18745: GREATER
18746: IFFALSE 18772
// length := ( array - i_from ) + i_to else
18748: LD_ADDR_VAR 0 11
18752: PUSH
18753: LD_VAR 0 1
18757: PUSH
18758: LD_VAR 0 2
18762: MINUS
18763: PUSH
18764: LD_VAR 0 3
18768: PLUS
18769: ST_TO_ADDR
18770: GO 18788
// length := i_to - i_from ;
18772: LD_ADDR_VAR 0 11
18776: PUSH
18777: LD_VAR 0 3
18781: PUSH
18782: LD_VAR 0 2
18786: MINUS
18787: ST_TO_ADDR
// end else
18788: GO 18851
// begin d := - 1 ;
18790: LD_ADDR_VAR 0 9
18794: PUSH
18795: LD_INT 1
18797: NEG
18798: ST_TO_ADDR
// if i_from > i_to then
18799: LD_VAR 0 2
18803: PUSH
18804: LD_VAR 0 3
18808: GREATER
18809: IFFALSE 18829
// length := i_from - i_to else
18811: LD_ADDR_VAR 0 11
18815: PUSH
18816: LD_VAR 0 2
18820: PUSH
18821: LD_VAR 0 3
18825: MINUS
18826: ST_TO_ADDR
18827: GO 18851
// length := ( array - i_to ) + i_from ;
18829: LD_ADDR_VAR 0 11
18833: PUSH
18834: LD_VAR 0 1
18838: PUSH
18839: LD_VAR 0 3
18843: MINUS
18844: PUSH
18845: LD_VAR 0 2
18849: PLUS
18850: ST_TO_ADDR
// end ; if not length then
18851: LD_VAR 0 11
18855: NOT
18856: IFFALSE 18860
// exit ;
18858: GO 19018
// tmp := array ;
18860: LD_ADDR_VAR 0 10
18864: PUSH
18865: LD_VAR 0 1
18869: ST_TO_ADDR
// for i = 1 to length do
18870: LD_ADDR_VAR 0 6
18874: PUSH
18875: DOUBLE
18876: LD_INT 1
18878: DEC
18879: ST_TO_ADDR
18880: LD_VAR 0 11
18884: PUSH
18885: FOR_TO
18886: IFFALSE 19006
// begin for j = 1 to array do
18888: LD_ADDR_VAR 0 7
18892: PUSH
18893: DOUBLE
18894: LD_INT 1
18896: DEC
18897: ST_TO_ADDR
18898: LD_VAR 0 1
18902: PUSH
18903: FOR_TO
18904: IFFALSE 18992
// begin k := j + d ;
18906: LD_ADDR_VAR 0 8
18910: PUSH
18911: LD_VAR 0 7
18915: PUSH
18916: LD_VAR 0 9
18920: PLUS
18921: ST_TO_ADDR
// if k > array then
18922: LD_VAR 0 8
18926: PUSH
18927: LD_VAR 0 1
18931: GREATER
18932: IFFALSE 18942
// k := 1 ;
18934: LD_ADDR_VAR 0 8
18938: PUSH
18939: LD_INT 1
18941: ST_TO_ADDR
// if not k then
18942: LD_VAR 0 8
18946: NOT
18947: IFFALSE 18959
// k := array ;
18949: LD_ADDR_VAR 0 8
18953: PUSH
18954: LD_VAR 0 1
18958: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18959: LD_ADDR_VAR 0 10
18963: PUSH
18964: LD_VAR 0 10
18968: PPUSH
18969: LD_VAR 0 8
18973: PPUSH
18974: LD_VAR 0 1
18978: PUSH
18979: LD_VAR 0 7
18983: ARRAY
18984: PPUSH
18985: CALL_OW 1
18989: ST_TO_ADDR
// end ;
18990: GO 18903
18992: POP
18993: POP
// array := tmp ;
18994: LD_ADDR_VAR 0 1
18998: PUSH
18999: LD_VAR 0 10
19003: ST_TO_ADDR
// end ;
19004: GO 18885
19006: POP
19007: POP
// result := array ;
19008: LD_ADDR_VAR 0 5
19012: PUSH
19013: LD_VAR 0 1
19017: ST_TO_ADDR
// end ;
19018: LD_VAR 0 5
19022: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19023: LD_INT 0
19025: PPUSH
19026: PPUSH
// result := 0 ;
19027: LD_ADDR_VAR 0 3
19031: PUSH
19032: LD_INT 0
19034: ST_TO_ADDR
// if not array or not value in array then
19035: LD_VAR 0 1
19039: NOT
19040: PUSH
19041: LD_VAR 0 2
19045: PUSH
19046: LD_VAR 0 1
19050: IN
19051: NOT
19052: OR
19053: IFFALSE 19057
// exit ;
19055: GO 19111
// for i = 1 to array do
19057: LD_ADDR_VAR 0 4
19061: PUSH
19062: DOUBLE
19063: LD_INT 1
19065: DEC
19066: ST_TO_ADDR
19067: LD_VAR 0 1
19071: PUSH
19072: FOR_TO
19073: IFFALSE 19109
// if value = array [ i ] then
19075: LD_VAR 0 2
19079: PUSH
19080: LD_VAR 0 1
19084: PUSH
19085: LD_VAR 0 4
19089: ARRAY
19090: EQUAL
19091: IFFALSE 19107
// begin result := i ;
19093: LD_ADDR_VAR 0 3
19097: PUSH
19098: LD_VAR 0 4
19102: ST_TO_ADDR
// exit ;
19103: POP
19104: POP
19105: GO 19111
// end ;
19107: GO 19072
19109: POP
19110: POP
// end ;
19111: LD_VAR 0 3
19115: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19116: LD_INT 0
19118: PPUSH
// vc_chassis := chassis ;
19119: LD_ADDR_OWVAR 37
19123: PUSH
19124: LD_VAR 0 1
19128: ST_TO_ADDR
// vc_engine := engine ;
19129: LD_ADDR_OWVAR 39
19133: PUSH
19134: LD_VAR 0 2
19138: ST_TO_ADDR
// vc_control := control ;
19139: LD_ADDR_OWVAR 38
19143: PUSH
19144: LD_VAR 0 3
19148: ST_TO_ADDR
// vc_weapon := weapon ;
19149: LD_ADDR_OWVAR 40
19153: PUSH
19154: LD_VAR 0 4
19158: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19159: LD_ADDR_OWVAR 41
19163: PUSH
19164: LD_VAR 0 5
19168: ST_TO_ADDR
// end ;
19169: LD_VAR 0 6
19173: RET
// export function WantPlant ( unit ) ; var task ; begin
19174: LD_INT 0
19176: PPUSH
19177: PPUSH
// result := false ;
19178: LD_ADDR_VAR 0 2
19182: PUSH
19183: LD_INT 0
19185: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19186: LD_ADDR_VAR 0 3
19190: PUSH
19191: LD_VAR 0 1
19195: PPUSH
19196: CALL_OW 437
19200: ST_TO_ADDR
// if task then
19201: LD_VAR 0 3
19205: IFFALSE 19233
// if task [ 1 ] [ 1 ] = p then
19207: LD_VAR 0 3
19211: PUSH
19212: LD_INT 1
19214: ARRAY
19215: PUSH
19216: LD_INT 1
19218: ARRAY
19219: PUSH
19220: LD_STRING p
19222: EQUAL
19223: IFFALSE 19233
// result := true ;
19225: LD_ADDR_VAR 0 2
19229: PUSH
19230: LD_INT 1
19232: ST_TO_ADDR
// end ;
19233: LD_VAR 0 2
19237: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19238: LD_INT 0
19240: PPUSH
19241: PPUSH
19242: PPUSH
19243: PPUSH
// if pos < 1 then
19244: LD_VAR 0 2
19248: PUSH
19249: LD_INT 1
19251: LESS
19252: IFFALSE 19256
// exit ;
19254: GO 19559
// if pos = 1 then
19256: LD_VAR 0 2
19260: PUSH
19261: LD_INT 1
19263: EQUAL
19264: IFFALSE 19297
// result := Replace ( arr , pos [ 1 ] , value ) else
19266: LD_ADDR_VAR 0 4
19270: PUSH
19271: LD_VAR 0 1
19275: PPUSH
19276: LD_VAR 0 2
19280: PUSH
19281: LD_INT 1
19283: ARRAY
19284: PPUSH
19285: LD_VAR 0 3
19289: PPUSH
19290: CALL_OW 1
19294: ST_TO_ADDR
19295: GO 19559
// begin tmp := arr ;
19297: LD_ADDR_VAR 0 6
19301: PUSH
19302: LD_VAR 0 1
19306: ST_TO_ADDR
// s_arr := [ tmp ] ;
19307: LD_ADDR_VAR 0 7
19311: PUSH
19312: LD_VAR 0 6
19316: PUSH
19317: EMPTY
19318: LIST
19319: ST_TO_ADDR
// for i = 1 to pos - 1 do
19320: LD_ADDR_VAR 0 5
19324: PUSH
19325: DOUBLE
19326: LD_INT 1
19328: DEC
19329: ST_TO_ADDR
19330: LD_VAR 0 2
19334: PUSH
19335: LD_INT 1
19337: MINUS
19338: PUSH
19339: FOR_TO
19340: IFFALSE 19385
// begin tmp := tmp [ pos [ i ] ] ;
19342: LD_ADDR_VAR 0 6
19346: PUSH
19347: LD_VAR 0 6
19351: PUSH
19352: LD_VAR 0 2
19356: PUSH
19357: LD_VAR 0 5
19361: ARRAY
19362: ARRAY
19363: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
19364: LD_ADDR_VAR 0 7
19368: PUSH
19369: LD_VAR 0 7
19373: PUSH
19374: LD_VAR 0 6
19378: PUSH
19379: EMPTY
19380: LIST
19381: ADD
19382: ST_TO_ADDR
// end ;
19383: GO 19339
19385: POP
19386: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
19387: LD_ADDR_VAR 0 6
19391: PUSH
19392: LD_VAR 0 6
19396: PPUSH
19397: LD_VAR 0 2
19401: PUSH
19402: LD_VAR 0 2
19406: ARRAY
19407: PPUSH
19408: LD_VAR 0 3
19412: PPUSH
19413: CALL_OW 1
19417: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
19418: LD_ADDR_VAR 0 7
19422: PUSH
19423: LD_VAR 0 7
19427: PPUSH
19428: LD_VAR 0 7
19432: PPUSH
19433: LD_VAR 0 6
19437: PPUSH
19438: CALL_OW 1
19442: ST_TO_ADDR
// for i = s_arr downto 2 do
19443: LD_ADDR_VAR 0 5
19447: PUSH
19448: DOUBLE
19449: LD_VAR 0 7
19453: INC
19454: ST_TO_ADDR
19455: LD_INT 2
19457: PUSH
19458: FOR_DOWNTO
19459: IFFALSE 19543
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
19461: LD_ADDR_VAR 0 6
19465: PUSH
19466: LD_VAR 0 7
19470: PUSH
19471: LD_VAR 0 5
19475: PUSH
19476: LD_INT 1
19478: MINUS
19479: ARRAY
19480: PPUSH
19481: LD_VAR 0 2
19485: PUSH
19486: LD_VAR 0 5
19490: PUSH
19491: LD_INT 1
19493: MINUS
19494: ARRAY
19495: PPUSH
19496: LD_VAR 0 7
19500: PUSH
19501: LD_VAR 0 5
19505: ARRAY
19506: PPUSH
19507: CALL_OW 1
19511: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
19512: LD_ADDR_VAR 0 7
19516: PUSH
19517: LD_VAR 0 7
19521: PPUSH
19522: LD_VAR 0 5
19526: PUSH
19527: LD_INT 1
19529: MINUS
19530: PPUSH
19531: LD_VAR 0 6
19535: PPUSH
19536: CALL_OW 1
19540: ST_TO_ADDR
// end ;
19541: GO 19458
19543: POP
19544: POP
// result := s_arr [ 1 ] ;
19545: LD_ADDR_VAR 0 4
19549: PUSH
19550: LD_VAR 0 7
19554: PUSH
19555: LD_INT 1
19557: ARRAY
19558: ST_TO_ADDR
// end ; end ;
19559: LD_VAR 0 4
19563: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
19564: LD_INT 0
19566: PPUSH
19567: PPUSH
// if not list then
19568: LD_VAR 0 1
19572: NOT
19573: IFFALSE 19577
// exit ;
19575: GO 19668
// i := list [ pos1 ] ;
19577: LD_ADDR_VAR 0 5
19581: PUSH
19582: LD_VAR 0 1
19586: PUSH
19587: LD_VAR 0 2
19591: ARRAY
19592: ST_TO_ADDR
// if not i then
19593: LD_VAR 0 5
19597: NOT
19598: IFFALSE 19602
// exit ;
19600: GO 19668
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
19602: LD_ADDR_VAR 0 1
19606: PUSH
19607: LD_VAR 0 1
19611: PPUSH
19612: LD_VAR 0 2
19616: PPUSH
19617: LD_VAR 0 1
19621: PUSH
19622: LD_VAR 0 3
19626: ARRAY
19627: PPUSH
19628: CALL_OW 1
19632: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
19633: LD_ADDR_VAR 0 1
19637: PUSH
19638: LD_VAR 0 1
19642: PPUSH
19643: LD_VAR 0 3
19647: PPUSH
19648: LD_VAR 0 5
19652: PPUSH
19653: CALL_OW 1
19657: ST_TO_ADDR
// result := list ;
19658: LD_ADDR_VAR 0 4
19662: PUSH
19663: LD_VAR 0 1
19667: ST_TO_ADDR
// end ;
19668: LD_VAR 0 4
19672: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19673: LD_INT 0
19675: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19676: LD_ADDR_VAR 0 5
19680: PUSH
19681: LD_VAR 0 1
19685: PPUSH
19686: CALL_OW 250
19690: PPUSH
19691: LD_VAR 0 1
19695: PPUSH
19696: CALL_OW 251
19700: PPUSH
19701: LD_VAR 0 2
19705: PPUSH
19706: LD_VAR 0 3
19710: PPUSH
19711: LD_VAR 0 4
19715: PPUSH
19716: CALL 19726 0 5
19720: ST_TO_ADDR
// end ;
19721: LD_VAR 0 5
19725: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19726: LD_INT 0
19728: PPUSH
19729: PPUSH
19730: PPUSH
19731: PPUSH
// if not list then
19732: LD_VAR 0 3
19736: NOT
19737: IFFALSE 19741
// exit ;
19739: GO 20129
// result := [ ] ;
19741: LD_ADDR_VAR 0 6
19745: PUSH
19746: EMPTY
19747: ST_TO_ADDR
// for i in list do
19748: LD_ADDR_VAR 0 7
19752: PUSH
19753: LD_VAR 0 3
19757: PUSH
19758: FOR_IN
19759: IFFALSE 19961
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19761: LD_ADDR_VAR 0 9
19765: PUSH
19766: LD_VAR 0 7
19770: PPUSH
19771: LD_VAR 0 1
19775: PPUSH
19776: LD_VAR 0 2
19780: PPUSH
19781: CALL_OW 297
19785: ST_TO_ADDR
// if not result then
19786: LD_VAR 0 6
19790: NOT
19791: IFFALSE 19817
// result := [ [ i , tmp ] ] else
19793: LD_ADDR_VAR 0 6
19797: PUSH
19798: LD_VAR 0 7
19802: PUSH
19803: LD_VAR 0 9
19807: PUSH
19808: EMPTY
19809: LIST
19810: LIST
19811: PUSH
19812: EMPTY
19813: LIST
19814: ST_TO_ADDR
19815: GO 19959
// begin if result [ result ] [ 2 ] < tmp then
19817: LD_VAR 0 6
19821: PUSH
19822: LD_VAR 0 6
19826: ARRAY
19827: PUSH
19828: LD_INT 2
19830: ARRAY
19831: PUSH
19832: LD_VAR 0 9
19836: LESS
19837: IFFALSE 19879
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19839: LD_ADDR_VAR 0 6
19843: PUSH
19844: LD_VAR 0 6
19848: PPUSH
19849: LD_VAR 0 6
19853: PUSH
19854: LD_INT 1
19856: PLUS
19857: PPUSH
19858: LD_VAR 0 7
19862: PUSH
19863: LD_VAR 0 9
19867: PUSH
19868: EMPTY
19869: LIST
19870: LIST
19871: PPUSH
19872: CALL_OW 2
19876: ST_TO_ADDR
19877: GO 19959
// for j = 1 to result do
19879: LD_ADDR_VAR 0 8
19883: PUSH
19884: DOUBLE
19885: LD_INT 1
19887: DEC
19888: ST_TO_ADDR
19889: LD_VAR 0 6
19893: PUSH
19894: FOR_TO
19895: IFFALSE 19957
// begin if tmp < result [ j ] [ 2 ] then
19897: LD_VAR 0 9
19901: PUSH
19902: LD_VAR 0 6
19906: PUSH
19907: LD_VAR 0 8
19911: ARRAY
19912: PUSH
19913: LD_INT 2
19915: ARRAY
19916: LESS
19917: IFFALSE 19955
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19919: LD_ADDR_VAR 0 6
19923: PUSH
19924: LD_VAR 0 6
19928: PPUSH
19929: LD_VAR 0 8
19933: PPUSH
19934: LD_VAR 0 7
19938: PUSH
19939: LD_VAR 0 9
19943: PUSH
19944: EMPTY
19945: LIST
19946: LIST
19947: PPUSH
19948: CALL_OW 2
19952: ST_TO_ADDR
// break ;
19953: GO 19957
// end ; end ;
19955: GO 19894
19957: POP
19958: POP
// end ; end ;
19959: GO 19758
19961: POP
19962: POP
// if result and not asc then
19963: LD_VAR 0 6
19967: PUSH
19968: LD_VAR 0 4
19972: NOT
19973: AND
19974: IFFALSE 20049
// begin tmp := result ;
19976: LD_ADDR_VAR 0 9
19980: PUSH
19981: LD_VAR 0 6
19985: ST_TO_ADDR
// for i = tmp downto 1 do
19986: LD_ADDR_VAR 0 7
19990: PUSH
19991: DOUBLE
19992: LD_VAR 0 9
19996: INC
19997: ST_TO_ADDR
19998: LD_INT 1
20000: PUSH
20001: FOR_DOWNTO
20002: IFFALSE 20047
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20004: LD_ADDR_VAR 0 6
20008: PUSH
20009: LD_VAR 0 6
20013: PPUSH
20014: LD_VAR 0 9
20018: PUSH
20019: LD_VAR 0 7
20023: MINUS
20024: PUSH
20025: LD_INT 1
20027: PLUS
20028: PPUSH
20029: LD_VAR 0 9
20033: PUSH
20034: LD_VAR 0 7
20038: ARRAY
20039: PPUSH
20040: CALL_OW 1
20044: ST_TO_ADDR
20045: GO 20001
20047: POP
20048: POP
// end ; tmp := [ ] ;
20049: LD_ADDR_VAR 0 9
20053: PUSH
20054: EMPTY
20055: ST_TO_ADDR
// if mode then
20056: LD_VAR 0 5
20060: IFFALSE 20129
// begin for i = 1 to result do
20062: LD_ADDR_VAR 0 7
20066: PUSH
20067: DOUBLE
20068: LD_INT 1
20070: DEC
20071: ST_TO_ADDR
20072: LD_VAR 0 6
20076: PUSH
20077: FOR_TO
20078: IFFALSE 20117
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20080: LD_ADDR_VAR 0 9
20084: PUSH
20085: LD_VAR 0 9
20089: PPUSH
20090: LD_VAR 0 7
20094: PPUSH
20095: LD_VAR 0 6
20099: PUSH
20100: LD_VAR 0 7
20104: ARRAY
20105: PUSH
20106: LD_INT 1
20108: ARRAY
20109: PPUSH
20110: CALL_OW 1
20114: ST_TO_ADDR
20115: GO 20077
20117: POP
20118: POP
// result := tmp ;
20119: LD_ADDR_VAR 0 6
20123: PUSH
20124: LD_VAR 0 9
20128: ST_TO_ADDR
// end ; end ;
20129: LD_VAR 0 6
20133: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20134: LD_INT 0
20136: PPUSH
20137: PPUSH
20138: PPUSH
20139: PPUSH
20140: PPUSH
20141: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20142: LD_ADDR_VAR 0 5
20146: PUSH
20147: LD_INT 0
20149: PUSH
20150: LD_INT 0
20152: PUSH
20153: LD_INT 0
20155: PUSH
20156: EMPTY
20157: PUSH
20158: EMPTY
20159: LIST
20160: LIST
20161: LIST
20162: LIST
20163: ST_TO_ADDR
// if not x or not y then
20164: LD_VAR 0 2
20168: NOT
20169: PUSH
20170: LD_VAR 0 3
20174: NOT
20175: OR
20176: IFFALSE 20180
// exit ;
20178: GO 21826
// if not range then
20180: LD_VAR 0 4
20184: NOT
20185: IFFALSE 20195
// range := 10 ;
20187: LD_ADDR_VAR 0 4
20191: PUSH
20192: LD_INT 10
20194: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20195: LD_ADDR_VAR 0 8
20199: PUSH
20200: LD_INT 81
20202: PUSH
20203: LD_VAR 0 1
20207: PUSH
20208: EMPTY
20209: LIST
20210: LIST
20211: PUSH
20212: LD_INT 92
20214: PUSH
20215: LD_VAR 0 2
20219: PUSH
20220: LD_VAR 0 3
20224: PUSH
20225: LD_VAR 0 4
20229: PUSH
20230: EMPTY
20231: LIST
20232: LIST
20233: LIST
20234: LIST
20235: PUSH
20236: LD_INT 3
20238: PUSH
20239: LD_INT 21
20241: PUSH
20242: LD_INT 3
20244: PUSH
20245: EMPTY
20246: LIST
20247: LIST
20248: PUSH
20249: EMPTY
20250: LIST
20251: LIST
20252: PUSH
20253: EMPTY
20254: LIST
20255: LIST
20256: LIST
20257: PPUSH
20258: CALL_OW 69
20262: ST_TO_ADDR
// if not tmp then
20263: LD_VAR 0 8
20267: NOT
20268: IFFALSE 20272
// exit ;
20270: GO 21826
// for i in tmp do
20272: LD_ADDR_VAR 0 6
20276: PUSH
20277: LD_VAR 0 8
20281: PUSH
20282: FOR_IN
20283: IFFALSE 21801
// begin points := [ 0 , 0 , 0 ] ;
20285: LD_ADDR_VAR 0 9
20289: PUSH
20290: LD_INT 0
20292: PUSH
20293: LD_INT 0
20295: PUSH
20296: LD_INT 0
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: LIST
20303: ST_TO_ADDR
// bpoints := 1 ;
20304: LD_ADDR_VAR 0 10
20308: PUSH
20309: LD_INT 1
20311: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20312: LD_VAR 0 6
20316: PPUSH
20317: CALL_OW 247
20321: PUSH
20322: LD_INT 1
20324: DOUBLE
20325: EQUAL
20326: IFTRUE 20330
20328: GO 20908
20330: POP
// begin if GetClass ( i ) = 1 then
20331: LD_VAR 0 6
20335: PPUSH
20336: CALL_OW 257
20340: PUSH
20341: LD_INT 1
20343: EQUAL
20344: IFFALSE 20365
// points := [ 10 , 5 , 3 ] ;
20346: LD_ADDR_VAR 0 9
20350: PUSH
20351: LD_INT 10
20353: PUSH
20354: LD_INT 5
20356: PUSH
20357: LD_INT 3
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: LIST
20364: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
20365: LD_VAR 0 6
20369: PPUSH
20370: CALL_OW 257
20374: PUSH
20375: LD_INT 2
20377: PUSH
20378: LD_INT 3
20380: PUSH
20381: LD_INT 4
20383: PUSH
20384: EMPTY
20385: LIST
20386: LIST
20387: LIST
20388: IN
20389: IFFALSE 20410
// points := [ 3 , 2 , 1 ] ;
20391: LD_ADDR_VAR 0 9
20395: PUSH
20396: LD_INT 3
20398: PUSH
20399: LD_INT 2
20401: PUSH
20402: LD_INT 1
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: LIST
20409: ST_TO_ADDR
// if GetClass ( i ) = 5 then
20410: LD_VAR 0 6
20414: PPUSH
20415: CALL_OW 257
20419: PUSH
20420: LD_INT 5
20422: EQUAL
20423: IFFALSE 20444
// points := [ 130 , 5 , 2 ] ;
20425: LD_ADDR_VAR 0 9
20429: PUSH
20430: LD_INT 130
20432: PUSH
20433: LD_INT 5
20435: PUSH
20436: LD_INT 2
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: LIST
20443: ST_TO_ADDR
// if GetClass ( i ) = 8 then
20444: LD_VAR 0 6
20448: PPUSH
20449: CALL_OW 257
20453: PUSH
20454: LD_INT 8
20456: EQUAL
20457: IFFALSE 20478
// points := [ 35 , 35 , 30 ] ;
20459: LD_ADDR_VAR 0 9
20463: PUSH
20464: LD_INT 35
20466: PUSH
20467: LD_INT 35
20469: PUSH
20470: LD_INT 30
20472: PUSH
20473: EMPTY
20474: LIST
20475: LIST
20476: LIST
20477: ST_TO_ADDR
// if GetClass ( i ) = 9 then
20478: LD_VAR 0 6
20482: PPUSH
20483: CALL_OW 257
20487: PUSH
20488: LD_INT 9
20490: EQUAL
20491: IFFALSE 20512
// points := [ 20 , 55 , 40 ] ;
20493: LD_ADDR_VAR 0 9
20497: PUSH
20498: LD_INT 20
20500: PUSH
20501: LD_INT 55
20503: PUSH
20504: LD_INT 40
20506: PUSH
20507: EMPTY
20508: LIST
20509: LIST
20510: LIST
20511: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
20512: LD_VAR 0 6
20516: PPUSH
20517: CALL_OW 257
20521: PUSH
20522: LD_INT 12
20524: PUSH
20525: LD_INT 16
20527: PUSH
20528: EMPTY
20529: LIST
20530: LIST
20531: IN
20532: IFFALSE 20553
// points := [ 5 , 3 , 2 ] ;
20534: LD_ADDR_VAR 0 9
20538: PUSH
20539: LD_INT 5
20541: PUSH
20542: LD_INT 3
20544: PUSH
20545: LD_INT 2
20547: PUSH
20548: EMPTY
20549: LIST
20550: LIST
20551: LIST
20552: ST_TO_ADDR
// if GetClass ( i ) = 17 then
20553: LD_VAR 0 6
20557: PPUSH
20558: CALL_OW 257
20562: PUSH
20563: LD_INT 17
20565: EQUAL
20566: IFFALSE 20587
// points := [ 100 , 50 , 75 ] ;
20568: LD_ADDR_VAR 0 9
20572: PUSH
20573: LD_INT 100
20575: PUSH
20576: LD_INT 50
20578: PUSH
20579: LD_INT 75
20581: PUSH
20582: EMPTY
20583: LIST
20584: LIST
20585: LIST
20586: ST_TO_ADDR
// if GetClass ( i ) = 15 then
20587: LD_VAR 0 6
20591: PPUSH
20592: CALL_OW 257
20596: PUSH
20597: LD_INT 15
20599: EQUAL
20600: IFFALSE 20621
// points := [ 10 , 5 , 3 ] ;
20602: LD_ADDR_VAR 0 9
20606: PUSH
20607: LD_INT 10
20609: PUSH
20610: LD_INT 5
20612: PUSH
20613: LD_INT 3
20615: PUSH
20616: EMPTY
20617: LIST
20618: LIST
20619: LIST
20620: ST_TO_ADDR
// if GetClass ( i ) = 14 then
20621: LD_VAR 0 6
20625: PPUSH
20626: CALL_OW 257
20630: PUSH
20631: LD_INT 14
20633: EQUAL
20634: IFFALSE 20655
// points := [ 10 , 0 , 0 ] ;
20636: LD_ADDR_VAR 0 9
20640: PUSH
20641: LD_INT 10
20643: PUSH
20644: LD_INT 0
20646: PUSH
20647: LD_INT 0
20649: PUSH
20650: EMPTY
20651: LIST
20652: LIST
20653: LIST
20654: ST_TO_ADDR
// if GetClass ( i ) = 11 then
20655: LD_VAR 0 6
20659: PPUSH
20660: CALL_OW 257
20664: PUSH
20665: LD_INT 11
20667: EQUAL
20668: IFFALSE 20689
// points := [ 30 , 10 , 5 ] ;
20670: LD_ADDR_VAR 0 9
20674: PUSH
20675: LD_INT 30
20677: PUSH
20678: LD_INT 10
20680: PUSH
20681: LD_INT 5
20683: PUSH
20684: EMPTY
20685: LIST
20686: LIST
20687: LIST
20688: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20689: LD_VAR 0 1
20693: PPUSH
20694: LD_INT 5
20696: PPUSH
20697: CALL_OW 321
20701: PUSH
20702: LD_INT 2
20704: EQUAL
20705: IFFALSE 20722
// bpoints := bpoints * 1.8 ;
20707: LD_ADDR_VAR 0 10
20711: PUSH
20712: LD_VAR 0 10
20716: PUSH
20717: LD_REAL  1.80000000000000E+0000
20720: MUL
20721: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20722: LD_VAR 0 6
20726: PPUSH
20727: CALL_OW 257
20731: PUSH
20732: LD_INT 1
20734: PUSH
20735: LD_INT 2
20737: PUSH
20738: LD_INT 3
20740: PUSH
20741: LD_INT 4
20743: PUSH
20744: EMPTY
20745: LIST
20746: LIST
20747: LIST
20748: LIST
20749: IN
20750: PUSH
20751: LD_VAR 0 1
20755: PPUSH
20756: LD_INT 51
20758: PPUSH
20759: CALL_OW 321
20763: PUSH
20764: LD_INT 2
20766: EQUAL
20767: AND
20768: IFFALSE 20785
// bpoints := bpoints * 1.2 ;
20770: LD_ADDR_VAR 0 10
20774: PUSH
20775: LD_VAR 0 10
20779: PUSH
20780: LD_REAL  1.20000000000000E+0000
20783: MUL
20784: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20785: LD_VAR 0 6
20789: PPUSH
20790: CALL_OW 257
20794: PUSH
20795: LD_INT 5
20797: PUSH
20798: LD_INT 7
20800: PUSH
20801: LD_INT 9
20803: PUSH
20804: EMPTY
20805: LIST
20806: LIST
20807: LIST
20808: IN
20809: PUSH
20810: LD_VAR 0 1
20814: PPUSH
20815: LD_INT 52
20817: PPUSH
20818: CALL_OW 321
20822: PUSH
20823: LD_INT 2
20825: EQUAL
20826: AND
20827: IFFALSE 20844
// bpoints := bpoints * 1.5 ;
20829: LD_ADDR_VAR 0 10
20833: PUSH
20834: LD_VAR 0 10
20838: PUSH
20839: LD_REAL  1.50000000000000E+0000
20842: MUL
20843: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20844: LD_VAR 0 1
20848: PPUSH
20849: LD_INT 66
20851: PPUSH
20852: CALL_OW 321
20856: PUSH
20857: LD_INT 2
20859: EQUAL
20860: IFFALSE 20877
// bpoints := bpoints * 1.1 ;
20862: LD_ADDR_VAR 0 10
20866: PUSH
20867: LD_VAR 0 10
20871: PUSH
20872: LD_REAL  1.10000000000000E+0000
20875: MUL
20876: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20877: LD_ADDR_VAR 0 10
20881: PUSH
20882: LD_VAR 0 10
20886: PUSH
20887: LD_VAR 0 6
20891: PPUSH
20892: LD_INT 1
20894: PPUSH
20895: CALL_OW 259
20899: PUSH
20900: LD_REAL  1.15000000000000E+0000
20903: MUL
20904: MUL
20905: ST_TO_ADDR
// end ; unit_vehicle :
20906: GO 21730
20908: LD_INT 2
20910: DOUBLE
20911: EQUAL
20912: IFTRUE 20916
20914: GO 21718
20916: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20917: LD_VAR 0 6
20921: PPUSH
20922: CALL_OW 264
20926: PUSH
20927: LD_INT 2
20929: PUSH
20930: LD_INT 42
20932: PUSH
20933: LD_INT 24
20935: PUSH
20936: EMPTY
20937: LIST
20938: LIST
20939: LIST
20940: IN
20941: IFFALSE 20962
// points := [ 25 , 5 , 3 ] ;
20943: LD_ADDR_VAR 0 9
20947: PUSH
20948: LD_INT 25
20950: PUSH
20951: LD_INT 5
20953: PUSH
20954: LD_INT 3
20956: PUSH
20957: EMPTY
20958: LIST
20959: LIST
20960: LIST
20961: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20962: LD_VAR 0 6
20966: PPUSH
20967: CALL_OW 264
20971: PUSH
20972: LD_INT 4
20974: PUSH
20975: LD_INT 43
20977: PUSH
20978: LD_INT 25
20980: PUSH
20981: EMPTY
20982: LIST
20983: LIST
20984: LIST
20985: IN
20986: IFFALSE 21007
// points := [ 40 , 15 , 5 ] ;
20988: LD_ADDR_VAR 0 9
20992: PUSH
20993: LD_INT 40
20995: PUSH
20996: LD_INT 15
20998: PUSH
20999: LD_INT 5
21001: PUSH
21002: EMPTY
21003: LIST
21004: LIST
21005: LIST
21006: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21007: LD_VAR 0 6
21011: PPUSH
21012: CALL_OW 264
21016: PUSH
21017: LD_INT 3
21019: PUSH
21020: LD_INT 23
21022: PUSH
21023: EMPTY
21024: LIST
21025: LIST
21026: IN
21027: IFFALSE 21048
// points := [ 7 , 25 , 8 ] ;
21029: LD_ADDR_VAR 0 9
21033: PUSH
21034: LD_INT 7
21036: PUSH
21037: LD_INT 25
21039: PUSH
21040: LD_INT 8
21042: PUSH
21043: EMPTY
21044: LIST
21045: LIST
21046: LIST
21047: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21048: LD_VAR 0 6
21052: PPUSH
21053: CALL_OW 264
21057: PUSH
21058: LD_INT 5
21060: PUSH
21061: LD_INT 27
21063: PUSH
21064: LD_INT 44
21066: PUSH
21067: EMPTY
21068: LIST
21069: LIST
21070: LIST
21071: IN
21072: IFFALSE 21093
// points := [ 14 , 50 , 16 ] ;
21074: LD_ADDR_VAR 0 9
21078: PUSH
21079: LD_INT 14
21081: PUSH
21082: LD_INT 50
21084: PUSH
21085: LD_INT 16
21087: PUSH
21088: EMPTY
21089: LIST
21090: LIST
21091: LIST
21092: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21093: LD_VAR 0 6
21097: PPUSH
21098: CALL_OW 264
21102: PUSH
21103: LD_INT 6
21105: PUSH
21106: LD_INT 46
21108: PUSH
21109: EMPTY
21110: LIST
21111: LIST
21112: IN
21113: IFFALSE 21134
// points := [ 32 , 120 , 70 ] ;
21115: LD_ADDR_VAR 0 9
21119: PUSH
21120: LD_INT 32
21122: PUSH
21123: LD_INT 120
21125: PUSH
21126: LD_INT 70
21128: PUSH
21129: EMPTY
21130: LIST
21131: LIST
21132: LIST
21133: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
21134: LD_VAR 0 6
21138: PPUSH
21139: CALL_OW 264
21143: PUSH
21144: LD_INT 7
21146: PUSH
21147: LD_INT 28
21149: PUSH
21150: LD_INT 45
21152: PUSH
21153: EMPTY
21154: LIST
21155: LIST
21156: LIST
21157: IN
21158: IFFALSE 21179
// points := [ 35 , 20 , 45 ] ;
21160: LD_ADDR_VAR 0 9
21164: PUSH
21165: LD_INT 35
21167: PUSH
21168: LD_INT 20
21170: PUSH
21171: LD_INT 45
21173: PUSH
21174: EMPTY
21175: LIST
21176: LIST
21177: LIST
21178: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21179: LD_VAR 0 6
21183: PPUSH
21184: CALL_OW 264
21188: PUSH
21189: LD_INT 47
21191: PUSH
21192: EMPTY
21193: LIST
21194: IN
21195: IFFALSE 21216
// points := [ 67 , 45 , 75 ] ;
21197: LD_ADDR_VAR 0 9
21201: PUSH
21202: LD_INT 67
21204: PUSH
21205: LD_INT 45
21207: PUSH
21208: LD_INT 75
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: LIST
21215: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21216: LD_VAR 0 6
21220: PPUSH
21221: CALL_OW 264
21225: PUSH
21226: LD_INT 26
21228: PUSH
21229: EMPTY
21230: LIST
21231: IN
21232: IFFALSE 21253
// points := [ 120 , 30 , 80 ] ;
21234: LD_ADDR_VAR 0 9
21238: PUSH
21239: LD_INT 120
21241: PUSH
21242: LD_INT 30
21244: PUSH
21245: LD_INT 80
21247: PUSH
21248: EMPTY
21249: LIST
21250: LIST
21251: LIST
21252: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21253: LD_VAR 0 6
21257: PPUSH
21258: CALL_OW 264
21262: PUSH
21263: LD_INT 22
21265: PUSH
21266: EMPTY
21267: LIST
21268: IN
21269: IFFALSE 21290
// points := [ 40 , 1 , 1 ] ;
21271: LD_ADDR_VAR 0 9
21275: PUSH
21276: LD_INT 40
21278: PUSH
21279: LD_INT 1
21281: PUSH
21282: LD_INT 1
21284: PUSH
21285: EMPTY
21286: LIST
21287: LIST
21288: LIST
21289: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21290: LD_VAR 0 6
21294: PPUSH
21295: CALL_OW 264
21299: PUSH
21300: LD_INT 29
21302: PUSH
21303: EMPTY
21304: LIST
21305: IN
21306: IFFALSE 21327
// points := [ 70 , 200 , 400 ] ;
21308: LD_ADDR_VAR 0 9
21312: PUSH
21313: LD_INT 70
21315: PUSH
21316: LD_INT 200
21318: PUSH
21319: LD_INT 400
21321: PUSH
21322: EMPTY
21323: LIST
21324: LIST
21325: LIST
21326: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
21327: LD_VAR 0 6
21331: PPUSH
21332: CALL_OW 264
21336: PUSH
21337: LD_INT 14
21339: PUSH
21340: LD_INT 53
21342: PUSH
21343: EMPTY
21344: LIST
21345: LIST
21346: IN
21347: IFFALSE 21368
// points := [ 40 , 10 , 20 ] ;
21349: LD_ADDR_VAR 0 9
21353: PUSH
21354: LD_INT 40
21356: PUSH
21357: LD_INT 10
21359: PUSH
21360: LD_INT 20
21362: PUSH
21363: EMPTY
21364: LIST
21365: LIST
21366: LIST
21367: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
21368: LD_VAR 0 6
21372: PPUSH
21373: CALL_OW 264
21377: PUSH
21378: LD_INT 9
21380: PUSH
21381: EMPTY
21382: LIST
21383: IN
21384: IFFALSE 21405
// points := [ 5 , 70 , 20 ] ;
21386: LD_ADDR_VAR 0 9
21390: PUSH
21391: LD_INT 5
21393: PUSH
21394: LD_INT 70
21396: PUSH
21397: LD_INT 20
21399: PUSH
21400: EMPTY
21401: LIST
21402: LIST
21403: LIST
21404: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
21405: LD_VAR 0 6
21409: PPUSH
21410: CALL_OW 264
21414: PUSH
21415: LD_INT 10
21417: PUSH
21418: EMPTY
21419: LIST
21420: IN
21421: IFFALSE 21442
// points := [ 35 , 110 , 70 ] ;
21423: LD_ADDR_VAR 0 9
21427: PUSH
21428: LD_INT 35
21430: PUSH
21431: LD_INT 110
21433: PUSH
21434: LD_INT 70
21436: PUSH
21437: EMPTY
21438: LIST
21439: LIST
21440: LIST
21441: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
21442: LD_VAR 0 6
21446: PPUSH
21447: CALL_OW 265
21451: PUSH
21452: LD_INT 25
21454: EQUAL
21455: IFFALSE 21476
// points := [ 80 , 65 , 100 ] ;
21457: LD_ADDR_VAR 0 9
21461: PUSH
21462: LD_INT 80
21464: PUSH
21465: LD_INT 65
21467: PUSH
21468: LD_INT 100
21470: PUSH
21471: EMPTY
21472: LIST
21473: LIST
21474: LIST
21475: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
21476: LD_VAR 0 6
21480: PPUSH
21481: CALL_OW 263
21485: PUSH
21486: LD_INT 1
21488: EQUAL
21489: IFFALSE 21524
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
21491: LD_ADDR_VAR 0 10
21495: PUSH
21496: LD_VAR 0 10
21500: PUSH
21501: LD_VAR 0 6
21505: PPUSH
21506: CALL_OW 311
21510: PPUSH
21511: LD_INT 3
21513: PPUSH
21514: CALL_OW 259
21518: PUSH
21519: LD_INT 4
21521: MUL
21522: MUL
21523: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
21524: LD_VAR 0 6
21528: PPUSH
21529: CALL_OW 263
21533: PUSH
21534: LD_INT 2
21536: EQUAL
21537: IFFALSE 21588
// begin j := IsControledBy ( i ) ;
21539: LD_ADDR_VAR 0 7
21543: PUSH
21544: LD_VAR 0 6
21548: PPUSH
21549: CALL_OW 312
21553: ST_TO_ADDR
// if j then
21554: LD_VAR 0 7
21558: IFFALSE 21588
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
21560: LD_ADDR_VAR 0 10
21564: PUSH
21565: LD_VAR 0 10
21569: PUSH
21570: LD_VAR 0 7
21574: PPUSH
21575: LD_INT 3
21577: PPUSH
21578: CALL_OW 259
21582: PUSH
21583: LD_INT 3
21585: MUL
21586: MUL
21587: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
21588: LD_VAR 0 6
21592: PPUSH
21593: CALL_OW 264
21597: PUSH
21598: LD_INT 5
21600: PUSH
21601: LD_INT 6
21603: PUSH
21604: LD_INT 46
21606: PUSH
21607: LD_INT 44
21609: PUSH
21610: LD_INT 47
21612: PUSH
21613: LD_INT 45
21615: PUSH
21616: LD_INT 28
21618: PUSH
21619: LD_INT 7
21621: PUSH
21622: LD_INT 27
21624: PUSH
21625: LD_INT 29
21627: PUSH
21628: EMPTY
21629: LIST
21630: LIST
21631: LIST
21632: LIST
21633: LIST
21634: LIST
21635: LIST
21636: LIST
21637: LIST
21638: LIST
21639: IN
21640: PUSH
21641: LD_VAR 0 1
21645: PPUSH
21646: LD_INT 52
21648: PPUSH
21649: CALL_OW 321
21653: PUSH
21654: LD_INT 2
21656: EQUAL
21657: AND
21658: IFFALSE 21675
// bpoints := bpoints * 1.2 ;
21660: LD_ADDR_VAR 0 10
21664: PUSH
21665: LD_VAR 0 10
21669: PUSH
21670: LD_REAL  1.20000000000000E+0000
21673: MUL
21674: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21675: LD_VAR 0 6
21679: PPUSH
21680: CALL_OW 264
21684: PUSH
21685: LD_INT 6
21687: PUSH
21688: LD_INT 46
21690: PUSH
21691: LD_INT 47
21693: PUSH
21694: EMPTY
21695: LIST
21696: LIST
21697: LIST
21698: IN
21699: IFFALSE 21716
// bpoints := bpoints * 1.2 ;
21701: LD_ADDR_VAR 0 10
21705: PUSH
21706: LD_VAR 0 10
21710: PUSH
21711: LD_REAL  1.20000000000000E+0000
21714: MUL
21715: ST_TO_ADDR
// end ; unit_building :
21716: GO 21730
21718: LD_INT 3
21720: DOUBLE
21721: EQUAL
21722: IFTRUE 21726
21724: GO 21729
21726: POP
// ; end ;
21727: GO 21730
21729: POP
// for j = 1 to 3 do
21730: LD_ADDR_VAR 0 7
21734: PUSH
21735: DOUBLE
21736: LD_INT 1
21738: DEC
21739: ST_TO_ADDR
21740: LD_INT 3
21742: PUSH
21743: FOR_TO
21744: IFFALSE 21797
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21746: LD_ADDR_VAR 0 5
21750: PUSH
21751: LD_VAR 0 5
21755: PPUSH
21756: LD_VAR 0 7
21760: PPUSH
21761: LD_VAR 0 5
21765: PUSH
21766: LD_VAR 0 7
21770: ARRAY
21771: PUSH
21772: LD_VAR 0 9
21776: PUSH
21777: LD_VAR 0 7
21781: ARRAY
21782: PUSH
21783: LD_VAR 0 10
21787: MUL
21788: PLUS
21789: PPUSH
21790: CALL_OW 1
21794: ST_TO_ADDR
21795: GO 21743
21797: POP
21798: POP
// end ;
21799: GO 20282
21801: POP
21802: POP
// result := Replace ( result , 4 , tmp ) ;
21803: LD_ADDR_VAR 0 5
21807: PUSH
21808: LD_VAR 0 5
21812: PPUSH
21813: LD_INT 4
21815: PPUSH
21816: LD_VAR 0 8
21820: PPUSH
21821: CALL_OW 1
21825: ST_TO_ADDR
// end ;
21826: LD_VAR 0 5
21830: RET
// export function DangerAtRange ( unit , range ) ; begin
21831: LD_INT 0
21833: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21834: LD_ADDR_VAR 0 3
21838: PUSH
21839: LD_VAR 0 1
21843: PPUSH
21844: CALL_OW 255
21848: PPUSH
21849: LD_VAR 0 1
21853: PPUSH
21854: CALL_OW 250
21858: PPUSH
21859: LD_VAR 0 1
21863: PPUSH
21864: CALL_OW 251
21868: PPUSH
21869: LD_VAR 0 2
21873: PPUSH
21874: CALL 20134 0 4
21878: ST_TO_ADDR
// end ;
21879: LD_VAR 0 3
21883: RET
// export function DangerInArea ( side , area ) ; begin
21884: LD_INT 0
21886: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21887: LD_ADDR_VAR 0 3
21891: PUSH
21892: LD_VAR 0 2
21896: PPUSH
21897: LD_INT 81
21899: PUSH
21900: LD_VAR 0 1
21904: PUSH
21905: EMPTY
21906: LIST
21907: LIST
21908: PPUSH
21909: CALL_OW 70
21913: ST_TO_ADDR
// end ;
21914: LD_VAR 0 3
21918: RET
// export function IsExtension ( b ) ; begin
21919: LD_INT 0
21921: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21922: LD_ADDR_VAR 0 2
21926: PUSH
21927: LD_VAR 0 1
21931: PUSH
21932: LD_INT 23
21934: PUSH
21935: LD_INT 20
21937: PUSH
21938: LD_INT 22
21940: PUSH
21941: LD_INT 17
21943: PUSH
21944: LD_INT 24
21946: PUSH
21947: LD_INT 21
21949: PUSH
21950: LD_INT 19
21952: PUSH
21953: LD_INT 16
21955: PUSH
21956: LD_INT 25
21958: PUSH
21959: LD_INT 18
21961: PUSH
21962: EMPTY
21963: LIST
21964: LIST
21965: LIST
21966: LIST
21967: LIST
21968: LIST
21969: LIST
21970: LIST
21971: LIST
21972: LIST
21973: IN
21974: ST_TO_ADDR
// end ;
21975: LD_VAR 0 2
21979: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
21980: LD_INT 0
21982: PPUSH
21983: PPUSH
21984: PPUSH
// result := [ ] ;
21985: LD_ADDR_VAR 0 3
21989: PUSH
21990: EMPTY
21991: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21992: LD_ADDR_VAR 0 4
21996: PUSH
21997: LD_VAR 0 2
22001: PPUSH
22002: LD_INT 21
22004: PUSH
22005: LD_INT 3
22007: PUSH
22008: EMPTY
22009: LIST
22010: LIST
22011: PPUSH
22012: CALL_OW 70
22016: ST_TO_ADDR
// if not tmp then
22017: LD_VAR 0 4
22021: NOT
22022: IFFALSE 22026
// exit ;
22024: GO 22084
// for i in tmp do
22026: LD_ADDR_VAR 0 5
22030: PUSH
22031: LD_VAR 0 4
22035: PUSH
22036: FOR_IN
22037: IFFALSE 22072
// if GetBase ( i ) <> base then
22039: LD_VAR 0 5
22043: PPUSH
22044: CALL_OW 274
22048: PUSH
22049: LD_VAR 0 1
22053: NONEQUAL
22054: IFFALSE 22070
// ComLinkToBase ( base , i ) ;
22056: LD_VAR 0 1
22060: PPUSH
22061: LD_VAR 0 5
22065: PPUSH
22066: CALL_OW 169
22070: GO 22036
22072: POP
22073: POP
// result := tmp ;
22074: LD_ADDR_VAR 0 3
22078: PUSH
22079: LD_VAR 0 4
22083: ST_TO_ADDR
// end ;
22084: LD_VAR 0 3
22088: RET
// export function ComComplete ( unit , b ) ; var i ; begin
22089: LD_INT 0
22091: PPUSH
22092: PPUSH
// if BuildingStatus ( b ) = bs_build then
22093: LD_VAR 0 2
22097: PPUSH
22098: CALL_OW 461
22102: PUSH
22103: LD_INT 1
22105: EQUAL
22106: IFFALSE 22166
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22108: LD_VAR 0 1
22112: PPUSH
22113: LD_STRING h
22115: PUSH
22116: LD_VAR 0 2
22120: PPUSH
22121: CALL_OW 250
22125: PUSH
22126: LD_VAR 0 2
22130: PPUSH
22131: CALL_OW 251
22135: PUSH
22136: LD_VAR 0 2
22140: PUSH
22141: LD_INT 0
22143: PUSH
22144: LD_INT 0
22146: PUSH
22147: LD_INT 0
22149: PUSH
22150: EMPTY
22151: LIST
22152: LIST
22153: LIST
22154: LIST
22155: LIST
22156: LIST
22157: LIST
22158: PUSH
22159: EMPTY
22160: LIST
22161: PPUSH
22162: CALL_OW 446
// end ;
22166: LD_VAR 0 3
22170: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22171: LD_INT 0
22173: PPUSH
22174: PPUSH
22175: PPUSH
22176: PPUSH
22177: PPUSH
22178: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
22179: LD_VAR 0 1
22183: NOT
22184: PUSH
22185: LD_VAR 0 1
22189: PPUSH
22190: CALL_OW 263
22194: PUSH
22195: LD_INT 2
22197: EQUAL
22198: NOT
22199: OR
22200: IFFALSE 22204
// exit ;
22202: GO 22520
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22204: LD_ADDR_VAR 0 6
22208: PUSH
22209: LD_INT 22
22211: PUSH
22212: LD_VAR 0 1
22216: PPUSH
22217: CALL_OW 255
22221: PUSH
22222: EMPTY
22223: LIST
22224: LIST
22225: PUSH
22226: LD_INT 2
22228: PUSH
22229: LD_INT 30
22231: PUSH
22232: LD_INT 36
22234: PUSH
22235: EMPTY
22236: LIST
22237: LIST
22238: PUSH
22239: LD_INT 34
22241: PUSH
22242: LD_INT 31
22244: PUSH
22245: EMPTY
22246: LIST
22247: LIST
22248: PUSH
22249: EMPTY
22250: LIST
22251: LIST
22252: LIST
22253: PUSH
22254: EMPTY
22255: LIST
22256: LIST
22257: PPUSH
22258: CALL_OW 69
22262: ST_TO_ADDR
// if not tmp then
22263: LD_VAR 0 6
22267: NOT
22268: IFFALSE 22272
// exit ;
22270: GO 22520
// result := [ ] ;
22272: LD_ADDR_VAR 0 2
22276: PUSH
22277: EMPTY
22278: ST_TO_ADDR
// for i in tmp do
22279: LD_ADDR_VAR 0 3
22283: PUSH
22284: LD_VAR 0 6
22288: PUSH
22289: FOR_IN
22290: IFFALSE 22361
// begin t := UnitsInside ( i ) ;
22292: LD_ADDR_VAR 0 4
22296: PUSH
22297: LD_VAR 0 3
22301: PPUSH
22302: CALL_OW 313
22306: ST_TO_ADDR
// if t then
22307: LD_VAR 0 4
22311: IFFALSE 22359
// for j in t do
22313: LD_ADDR_VAR 0 7
22317: PUSH
22318: LD_VAR 0 4
22322: PUSH
22323: FOR_IN
22324: IFFALSE 22357
// result := Insert ( result , result + 1 , j ) ;
22326: LD_ADDR_VAR 0 2
22330: PUSH
22331: LD_VAR 0 2
22335: PPUSH
22336: LD_VAR 0 2
22340: PUSH
22341: LD_INT 1
22343: PLUS
22344: PPUSH
22345: LD_VAR 0 7
22349: PPUSH
22350: CALL_OW 2
22354: ST_TO_ADDR
22355: GO 22323
22357: POP
22358: POP
// end ;
22359: GO 22289
22361: POP
22362: POP
// if not result then
22363: LD_VAR 0 2
22367: NOT
22368: IFFALSE 22372
// exit ;
22370: GO 22520
// mech := result [ 1 ] ;
22372: LD_ADDR_VAR 0 5
22376: PUSH
22377: LD_VAR 0 2
22381: PUSH
22382: LD_INT 1
22384: ARRAY
22385: ST_TO_ADDR
// if result > 1 then
22386: LD_VAR 0 2
22390: PUSH
22391: LD_INT 1
22393: GREATER
22394: IFFALSE 22506
// for i = 2 to result do
22396: LD_ADDR_VAR 0 3
22400: PUSH
22401: DOUBLE
22402: LD_INT 2
22404: DEC
22405: ST_TO_ADDR
22406: LD_VAR 0 2
22410: PUSH
22411: FOR_TO
22412: IFFALSE 22504
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
22414: LD_ADDR_VAR 0 4
22418: PUSH
22419: LD_VAR 0 2
22423: PUSH
22424: LD_VAR 0 3
22428: ARRAY
22429: PPUSH
22430: LD_INT 3
22432: PPUSH
22433: CALL_OW 259
22437: PUSH
22438: LD_VAR 0 2
22442: PUSH
22443: LD_VAR 0 3
22447: ARRAY
22448: PPUSH
22449: CALL_OW 432
22453: MINUS
22454: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
22455: LD_VAR 0 4
22459: PUSH
22460: LD_VAR 0 5
22464: PPUSH
22465: LD_INT 3
22467: PPUSH
22468: CALL_OW 259
22472: PUSH
22473: LD_VAR 0 5
22477: PPUSH
22478: CALL_OW 432
22482: MINUS
22483: GREATEREQUAL
22484: IFFALSE 22502
// mech := result [ i ] ;
22486: LD_ADDR_VAR 0 5
22490: PUSH
22491: LD_VAR 0 2
22495: PUSH
22496: LD_VAR 0 3
22500: ARRAY
22501: ST_TO_ADDR
// end ;
22502: GO 22411
22504: POP
22505: POP
// ComLinkTo ( vehicle , mech ) ;
22506: LD_VAR 0 1
22510: PPUSH
22511: LD_VAR 0 5
22515: PPUSH
22516: CALL_OW 135
// end ;
22520: LD_VAR 0 2
22524: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
22525: LD_INT 0
22527: PPUSH
22528: PPUSH
22529: PPUSH
22530: PPUSH
22531: PPUSH
22532: PPUSH
22533: PPUSH
22534: PPUSH
22535: PPUSH
22536: PPUSH
22537: PPUSH
22538: PPUSH
22539: PPUSH
// result := [ ] ;
22540: LD_ADDR_VAR 0 7
22544: PUSH
22545: EMPTY
22546: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
22547: LD_VAR 0 1
22551: PPUSH
22552: CALL_OW 266
22556: PUSH
22557: LD_INT 0
22559: PUSH
22560: LD_INT 1
22562: PUSH
22563: EMPTY
22564: LIST
22565: LIST
22566: IN
22567: NOT
22568: IFFALSE 22572
// exit ;
22570: GO 24203
// if name then
22572: LD_VAR 0 3
22576: IFFALSE 22592
// SetBName ( base_dep , name ) ;
22578: LD_VAR 0 1
22582: PPUSH
22583: LD_VAR 0 3
22587: PPUSH
22588: CALL_OW 500
// base := GetBase ( base_dep ) ;
22592: LD_ADDR_VAR 0 15
22596: PUSH
22597: LD_VAR 0 1
22601: PPUSH
22602: CALL_OW 274
22606: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
22607: LD_ADDR_VAR 0 16
22611: PUSH
22612: LD_VAR 0 1
22616: PPUSH
22617: CALL_OW 255
22621: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
22622: LD_ADDR_VAR 0 17
22626: PUSH
22627: LD_VAR 0 1
22631: PPUSH
22632: CALL_OW 248
22636: ST_TO_ADDR
// if sources then
22637: LD_VAR 0 5
22641: IFFALSE 22688
// for i = 1 to 3 do
22643: LD_ADDR_VAR 0 8
22647: PUSH
22648: DOUBLE
22649: LD_INT 1
22651: DEC
22652: ST_TO_ADDR
22653: LD_INT 3
22655: PUSH
22656: FOR_TO
22657: IFFALSE 22686
// AddResourceType ( base , i , sources [ i ] ) ;
22659: LD_VAR 0 15
22663: PPUSH
22664: LD_VAR 0 8
22668: PPUSH
22669: LD_VAR 0 5
22673: PUSH
22674: LD_VAR 0 8
22678: ARRAY
22679: PPUSH
22680: CALL_OW 276
22684: GO 22656
22686: POP
22687: POP
// buildings := GetBaseBuildings ( base , area ) ;
22688: LD_ADDR_VAR 0 18
22692: PUSH
22693: LD_VAR 0 15
22697: PPUSH
22698: LD_VAR 0 2
22702: PPUSH
22703: CALL 21980 0 2
22707: ST_TO_ADDR
// InitHc ;
22708: CALL_OW 19
// InitUc ;
22712: CALL_OW 18
// uc_side := side ;
22716: LD_ADDR_OWVAR 20
22720: PUSH
22721: LD_VAR 0 16
22725: ST_TO_ADDR
// uc_nation := nation ;
22726: LD_ADDR_OWVAR 21
22730: PUSH
22731: LD_VAR 0 17
22735: ST_TO_ADDR
// if buildings then
22736: LD_VAR 0 18
22740: IFFALSE 24062
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22742: LD_ADDR_VAR 0 19
22746: PUSH
22747: LD_VAR 0 18
22751: PPUSH
22752: LD_INT 2
22754: PUSH
22755: LD_INT 30
22757: PUSH
22758: LD_INT 29
22760: PUSH
22761: EMPTY
22762: LIST
22763: LIST
22764: PUSH
22765: LD_INT 30
22767: PUSH
22768: LD_INT 30
22770: PUSH
22771: EMPTY
22772: LIST
22773: LIST
22774: PUSH
22775: EMPTY
22776: LIST
22777: LIST
22778: LIST
22779: PPUSH
22780: CALL_OW 72
22784: ST_TO_ADDR
// if tmp then
22785: LD_VAR 0 19
22789: IFFALSE 22837
// for i in tmp do
22791: LD_ADDR_VAR 0 8
22795: PUSH
22796: LD_VAR 0 19
22800: PUSH
22801: FOR_IN
22802: IFFALSE 22835
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22804: LD_VAR 0 8
22808: PPUSH
22809: CALL_OW 250
22813: PPUSH
22814: LD_VAR 0 8
22818: PPUSH
22819: CALL_OW 251
22823: PPUSH
22824: LD_VAR 0 16
22828: PPUSH
22829: CALL_OW 441
22833: GO 22801
22835: POP
22836: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22837: LD_VAR 0 18
22841: PPUSH
22842: LD_INT 2
22844: PUSH
22845: LD_INT 30
22847: PUSH
22848: LD_INT 32
22850: PUSH
22851: EMPTY
22852: LIST
22853: LIST
22854: PUSH
22855: LD_INT 30
22857: PUSH
22858: LD_INT 33
22860: PUSH
22861: EMPTY
22862: LIST
22863: LIST
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: LIST
22869: PPUSH
22870: CALL_OW 72
22874: IFFALSE 22962
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22876: LD_ADDR_VAR 0 8
22880: PUSH
22881: LD_VAR 0 18
22885: PPUSH
22886: LD_INT 2
22888: PUSH
22889: LD_INT 30
22891: PUSH
22892: LD_INT 32
22894: PUSH
22895: EMPTY
22896: LIST
22897: LIST
22898: PUSH
22899: LD_INT 30
22901: PUSH
22902: LD_INT 33
22904: PUSH
22905: EMPTY
22906: LIST
22907: LIST
22908: PUSH
22909: EMPTY
22910: LIST
22911: LIST
22912: LIST
22913: PPUSH
22914: CALL_OW 72
22918: PUSH
22919: FOR_IN
22920: IFFALSE 22960
// begin if not GetBWeapon ( i ) then
22922: LD_VAR 0 8
22926: PPUSH
22927: CALL_OW 269
22931: NOT
22932: IFFALSE 22958
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22934: LD_VAR 0 8
22938: PPUSH
22939: LD_VAR 0 8
22943: PPUSH
22944: LD_VAR 0 2
22948: PPUSH
22949: CALL 24208 0 2
22953: PPUSH
22954: CALL_OW 431
// end ;
22958: GO 22919
22960: POP
22961: POP
// end ; for i = 1 to personel do
22962: LD_ADDR_VAR 0 8
22966: PUSH
22967: DOUBLE
22968: LD_INT 1
22970: DEC
22971: ST_TO_ADDR
22972: LD_VAR 0 6
22976: PUSH
22977: FOR_TO
22978: IFFALSE 24042
// begin if i > 4 then
22980: LD_VAR 0 8
22984: PUSH
22985: LD_INT 4
22987: GREATER
22988: IFFALSE 22992
// break ;
22990: GO 24042
// case i of 1 :
22992: LD_VAR 0 8
22996: PUSH
22997: LD_INT 1
22999: DOUBLE
23000: EQUAL
23001: IFTRUE 23005
23003: GO 23085
23005: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23006: LD_ADDR_VAR 0 12
23010: PUSH
23011: LD_VAR 0 18
23015: PPUSH
23016: LD_INT 22
23018: PUSH
23019: LD_VAR 0 16
23023: PUSH
23024: EMPTY
23025: LIST
23026: LIST
23027: PUSH
23028: LD_INT 58
23030: PUSH
23031: EMPTY
23032: LIST
23033: PUSH
23034: LD_INT 2
23036: PUSH
23037: LD_INT 30
23039: PUSH
23040: LD_INT 32
23042: PUSH
23043: EMPTY
23044: LIST
23045: LIST
23046: PUSH
23047: LD_INT 30
23049: PUSH
23050: LD_INT 4
23052: PUSH
23053: EMPTY
23054: LIST
23055: LIST
23056: PUSH
23057: LD_INT 30
23059: PUSH
23060: LD_INT 5
23062: PUSH
23063: EMPTY
23064: LIST
23065: LIST
23066: PUSH
23067: EMPTY
23068: LIST
23069: LIST
23070: LIST
23071: LIST
23072: PUSH
23073: EMPTY
23074: LIST
23075: LIST
23076: LIST
23077: PPUSH
23078: CALL_OW 72
23082: ST_TO_ADDR
23083: GO 23307
23085: LD_INT 2
23087: DOUBLE
23088: EQUAL
23089: IFTRUE 23093
23091: GO 23155
23093: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23094: LD_ADDR_VAR 0 12
23098: PUSH
23099: LD_VAR 0 18
23103: PPUSH
23104: LD_INT 22
23106: PUSH
23107: LD_VAR 0 16
23111: PUSH
23112: EMPTY
23113: LIST
23114: LIST
23115: PUSH
23116: LD_INT 2
23118: PUSH
23119: LD_INT 30
23121: PUSH
23122: LD_INT 0
23124: PUSH
23125: EMPTY
23126: LIST
23127: LIST
23128: PUSH
23129: LD_INT 30
23131: PUSH
23132: LD_INT 1
23134: PUSH
23135: EMPTY
23136: LIST
23137: LIST
23138: PUSH
23139: EMPTY
23140: LIST
23141: LIST
23142: LIST
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: PPUSH
23148: CALL_OW 72
23152: ST_TO_ADDR
23153: GO 23307
23155: LD_INT 3
23157: DOUBLE
23158: EQUAL
23159: IFTRUE 23163
23161: GO 23225
23163: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23164: LD_ADDR_VAR 0 12
23168: PUSH
23169: LD_VAR 0 18
23173: PPUSH
23174: LD_INT 22
23176: PUSH
23177: LD_VAR 0 16
23181: PUSH
23182: EMPTY
23183: LIST
23184: LIST
23185: PUSH
23186: LD_INT 2
23188: PUSH
23189: LD_INT 30
23191: PUSH
23192: LD_INT 2
23194: PUSH
23195: EMPTY
23196: LIST
23197: LIST
23198: PUSH
23199: LD_INT 30
23201: PUSH
23202: LD_INT 3
23204: PUSH
23205: EMPTY
23206: LIST
23207: LIST
23208: PUSH
23209: EMPTY
23210: LIST
23211: LIST
23212: LIST
23213: PUSH
23214: EMPTY
23215: LIST
23216: LIST
23217: PPUSH
23218: CALL_OW 72
23222: ST_TO_ADDR
23223: GO 23307
23225: LD_INT 4
23227: DOUBLE
23228: EQUAL
23229: IFTRUE 23233
23231: GO 23306
23233: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23234: LD_ADDR_VAR 0 12
23238: PUSH
23239: LD_VAR 0 18
23243: PPUSH
23244: LD_INT 22
23246: PUSH
23247: LD_VAR 0 16
23251: PUSH
23252: EMPTY
23253: LIST
23254: LIST
23255: PUSH
23256: LD_INT 2
23258: PUSH
23259: LD_INT 30
23261: PUSH
23262: LD_INT 6
23264: PUSH
23265: EMPTY
23266: LIST
23267: LIST
23268: PUSH
23269: LD_INT 30
23271: PUSH
23272: LD_INT 7
23274: PUSH
23275: EMPTY
23276: LIST
23277: LIST
23278: PUSH
23279: LD_INT 30
23281: PUSH
23282: LD_INT 8
23284: PUSH
23285: EMPTY
23286: LIST
23287: LIST
23288: PUSH
23289: EMPTY
23290: LIST
23291: LIST
23292: LIST
23293: LIST
23294: PUSH
23295: EMPTY
23296: LIST
23297: LIST
23298: PPUSH
23299: CALL_OW 72
23303: ST_TO_ADDR
23304: GO 23307
23306: POP
// if i = 1 then
23307: LD_VAR 0 8
23311: PUSH
23312: LD_INT 1
23314: EQUAL
23315: IFFALSE 23426
// begin tmp := [ ] ;
23317: LD_ADDR_VAR 0 19
23321: PUSH
23322: EMPTY
23323: ST_TO_ADDR
// for j in f do
23324: LD_ADDR_VAR 0 9
23328: PUSH
23329: LD_VAR 0 12
23333: PUSH
23334: FOR_IN
23335: IFFALSE 23408
// if GetBType ( j ) = b_bunker then
23337: LD_VAR 0 9
23341: PPUSH
23342: CALL_OW 266
23346: PUSH
23347: LD_INT 32
23349: EQUAL
23350: IFFALSE 23377
// tmp := Insert ( tmp , 1 , j ) else
23352: LD_ADDR_VAR 0 19
23356: PUSH
23357: LD_VAR 0 19
23361: PPUSH
23362: LD_INT 1
23364: PPUSH
23365: LD_VAR 0 9
23369: PPUSH
23370: CALL_OW 2
23374: ST_TO_ADDR
23375: GO 23406
// tmp := Insert ( tmp , tmp + 1 , j ) ;
23377: LD_ADDR_VAR 0 19
23381: PUSH
23382: LD_VAR 0 19
23386: PPUSH
23387: LD_VAR 0 19
23391: PUSH
23392: LD_INT 1
23394: PLUS
23395: PPUSH
23396: LD_VAR 0 9
23400: PPUSH
23401: CALL_OW 2
23405: ST_TO_ADDR
23406: GO 23334
23408: POP
23409: POP
// if tmp then
23410: LD_VAR 0 19
23414: IFFALSE 23426
// f := tmp ;
23416: LD_ADDR_VAR 0 12
23420: PUSH
23421: LD_VAR 0 19
23425: ST_TO_ADDR
// end ; x := personel [ i ] ;
23426: LD_ADDR_VAR 0 13
23430: PUSH
23431: LD_VAR 0 6
23435: PUSH
23436: LD_VAR 0 8
23440: ARRAY
23441: ST_TO_ADDR
// if x = - 1 then
23442: LD_VAR 0 13
23446: PUSH
23447: LD_INT 1
23449: NEG
23450: EQUAL
23451: IFFALSE 23660
// begin for j in f do
23453: LD_ADDR_VAR 0 9
23457: PUSH
23458: LD_VAR 0 12
23462: PUSH
23463: FOR_IN
23464: IFFALSE 23656
// repeat InitHc ;
23466: CALL_OW 19
// if GetBType ( j ) = b_barracks then
23470: LD_VAR 0 9
23474: PPUSH
23475: CALL_OW 266
23479: PUSH
23480: LD_INT 5
23482: EQUAL
23483: IFFALSE 23553
// begin if UnitsInside ( j ) < 3 then
23485: LD_VAR 0 9
23489: PPUSH
23490: CALL_OW 313
23494: PUSH
23495: LD_INT 3
23497: LESS
23498: IFFALSE 23534
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23500: LD_INT 0
23502: PPUSH
23503: LD_INT 5
23505: PUSH
23506: LD_INT 8
23508: PUSH
23509: LD_INT 9
23511: PUSH
23512: EMPTY
23513: LIST
23514: LIST
23515: LIST
23516: PUSH
23517: LD_VAR 0 17
23521: ARRAY
23522: PPUSH
23523: LD_VAR 0 4
23527: PPUSH
23528: CALL_OW 380
23532: GO 23551
// PrepareHuman ( false , i , skill ) ;
23534: LD_INT 0
23536: PPUSH
23537: LD_VAR 0 8
23541: PPUSH
23542: LD_VAR 0 4
23546: PPUSH
23547: CALL_OW 380
// end else
23551: GO 23570
// PrepareHuman ( false , i , skill ) ;
23553: LD_INT 0
23555: PPUSH
23556: LD_VAR 0 8
23560: PPUSH
23561: LD_VAR 0 4
23565: PPUSH
23566: CALL_OW 380
// un := CreateHuman ;
23570: LD_ADDR_VAR 0 14
23574: PUSH
23575: CALL_OW 44
23579: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23580: LD_ADDR_VAR 0 7
23584: PUSH
23585: LD_VAR 0 7
23589: PPUSH
23590: LD_INT 1
23592: PPUSH
23593: LD_VAR 0 14
23597: PPUSH
23598: CALL_OW 2
23602: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
23603: LD_VAR 0 14
23607: PPUSH
23608: LD_VAR 0 9
23612: PPUSH
23613: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
23617: LD_VAR 0 9
23621: PPUSH
23622: CALL_OW 313
23626: PUSH
23627: LD_INT 6
23629: EQUAL
23630: PUSH
23631: LD_VAR 0 9
23635: PPUSH
23636: CALL_OW 266
23640: PUSH
23641: LD_INT 32
23643: PUSH
23644: LD_INT 31
23646: PUSH
23647: EMPTY
23648: LIST
23649: LIST
23650: IN
23651: OR
23652: IFFALSE 23466
23654: GO 23463
23656: POP
23657: POP
// end else
23658: GO 24040
// for j = 1 to x do
23660: LD_ADDR_VAR 0 9
23664: PUSH
23665: DOUBLE
23666: LD_INT 1
23668: DEC
23669: ST_TO_ADDR
23670: LD_VAR 0 13
23674: PUSH
23675: FOR_TO
23676: IFFALSE 24038
// begin InitHc ;
23678: CALL_OW 19
// if not f then
23682: LD_VAR 0 12
23686: NOT
23687: IFFALSE 23776
// begin PrepareHuman ( false , i , skill ) ;
23689: LD_INT 0
23691: PPUSH
23692: LD_VAR 0 8
23696: PPUSH
23697: LD_VAR 0 4
23701: PPUSH
23702: CALL_OW 380
// un := CreateHuman ;
23706: LD_ADDR_VAR 0 14
23710: PUSH
23711: CALL_OW 44
23715: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23716: LD_ADDR_VAR 0 7
23720: PUSH
23721: LD_VAR 0 7
23725: PPUSH
23726: LD_INT 1
23728: PPUSH
23729: LD_VAR 0 14
23733: PPUSH
23734: CALL_OW 2
23738: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23739: LD_VAR 0 14
23743: PPUSH
23744: LD_VAR 0 1
23748: PPUSH
23749: CALL_OW 250
23753: PPUSH
23754: LD_VAR 0 1
23758: PPUSH
23759: CALL_OW 251
23763: PPUSH
23764: LD_INT 10
23766: PPUSH
23767: LD_INT 0
23769: PPUSH
23770: CALL_OW 50
// continue ;
23774: GO 23675
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23776: LD_VAR 0 12
23780: PUSH
23781: LD_INT 1
23783: ARRAY
23784: PPUSH
23785: CALL_OW 313
23789: PUSH
23790: LD_VAR 0 12
23794: PUSH
23795: LD_INT 1
23797: ARRAY
23798: PPUSH
23799: CALL_OW 266
23803: PUSH
23804: LD_INT 32
23806: PUSH
23807: LD_INT 31
23809: PUSH
23810: EMPTY
23811: LIST
23812: LIST
23813: IN
23814: AND
23815: PUSH
23816: LD_VAR 0 12
23820: PUSH
23821: LD_INT 1
23823: ARRAY
23824: PPUSH
23825: CALL_OW 313
23829: PUSH
23830: LD_INT 6
23832: EQUAL
23833: OR
23834: IFFALSE 23854
// f := Delete ( f , 1 ) ;
23836: LD_ADDR_VAR 0 12
23840: PUSH
23841: LD_VAR 0 12
23845: PPUSH
23846: LD_INT 1
23848: PPUSH
23849: CALL_OW 3
23853: ST_TO_ADDR
// if not f then
23854: LD_VAR 0 12
23858: NOT
23859: IFFALSE 23877
// begin x := x + 2 ;
23861: LD_ADDR_VAR 0 13
23865: PUSH
23866: LD_VAR 0 13
23870: PUSH
23871: LD_INT 2
23873: PLUS
23874: ST_TO_ADDR
// continue ;
23875: GO 23675
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23877: LD_VAR 0 12
23881: PUSH
23882: LD_INT 1
23884: ARRAY
23885: PPUSH
23886: CALL_OW 266
23890: PUSH
23891: LD_INT 5
23893: EQUAL
23894: IFFALSE 23968
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23896: LD_VAR 0 12
23900: PUSH
23901: LD_INT 1
23903: ARRAY
23904: PPUSH
23905: CALL_OW 313
23909: PUSH
23910: LD_INT 3
23912: LESS
23913: IFFALSE 23949
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23915: LD_INT 0
23917: PPUSH
23918: LD_INT 5
23920: PUSH
23921: LD_INT 8
23923: PUSH
23924: LD_INT 9
23926: PUSH
23927: EMPTY
23928: LIST
23929: LIST
23930: LIST
23931: PUSH
23932: LD_VAR 0 17
23936: ARRAY
23937: PPUSH
23938: LD_VAR 0 4
23942: PPUSH
23943: CALL_OW 380
23947: GO 23966
// PrepareHuman ( false , i , skill ) ;
23949: LD_INT 0
23951: PPUSH
23952: LD_VAR 0 8
23956: PPUSH
23957: LD_VAR 0 4
23961: PPUSH
23962: CALL_OW 380
// end else
23966: GO 23985
// PrepareHuman ( false , i , skill ) ;
23968: LD_INT 0
23970: PPUSH
23971: LD_VAR 0 8
23975: PPUSH
23976: LD_VAR 0 4
23980: PPUSH
23981: CALL_OW 380
// un := CreateHuman ;
23985: LD_ADDR_VAR 0 14
23989: PUSH
23990: CALL_OW 44
23994: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23995: LD_ADDR_VAR 0 7
23999: PUSH
24000: LD_VAR 0 7
24004: PPUSH
24005: LD_INT 1
24007: PPUSH
24008: LD_VAR 0 14
24012: PPUSH
24013: CALL_OW 2
24017: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24018: LD_VAR 0 14
24022: PPUSH
24023: LD_VAR 0 12
24027: PUSH
24028: LD_INT 1
24030: ARRAY
24031: PPUSH
24032: CALL_OW 52
// end ;
24036: GO 23675
24038: POP
24039: POP
// end ;
24040: GO 22977
24042: POP
24043: POP
// result := result ^ buildings ;
24044: LD_ADDR_VAR 0 7
24048: PUSH
24049: LD_VAR 0 7
24053: PUSH
24054: LD_VAR 0 18
24058: ADD
24059: ST_TO_ADDR
// end else
24060: GO 24203
// begin for i = 1 to personel do
24062: LD_ADDR_VAR 0 8
24066: PUSH
24067: DOUBLE
24068: LD_INT 1
24070: DEC
24071: ST_TO_ADDR
24072: LD_VAR 0 6
24076: PUSH
24077: FOR_TO
24078: IFFALSE 24201
// begin if i > 4 then
24080: LD_VAR 0 8
24084: PUSH
24085: LD_INT 4
24087: GREATER
24088: IFFALSE 24092
// break ;
24090: GO 24201
// x := personel [ i ] ;
24092: LD_ADDR_VAR 0 13
24096: PUSH
24097: LD_VAR 0 6
24101: PUSH
24102: LD_VAR 0 8
24106: ARRAY
24107: ST_TO_ADDR
// if x = - 1 then
24108: LD_VAR 0 13
24112: PUSH
24113: LD_INT 1
24115: NEG
24116: EQUAL
24117: IFFALSE 24121
// continue ;
24119: GO 24077
// PrepareHuman ( false , i , skill ) ;
24121: LD_INT 0
24123: PPUSH
24124: LD_VAR 0 8
24128: PPUSH
24129: LD_VAR 0 4
24133: PPUSH
24134: CALL_OW 380
// un := CreateHuman ;
24138: LD_ADDR_VAR 0 14
24142: PUSH
24143: CALL_OW 44
24147: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24148: LD_VAR 0 14
24152: PPUSH
24153: LD_VAR 0 1
24157: PPUSH
24158: CALL_OW 250
24162: PPUSH
24163: LD_VAR 0 1
24167: PPUSH
24168: CALL_OW 251
24172: PPUSH
24173: LD_INT 10
24175: PPUSH
24176: LD_INT 0
24178: PPUSH
24179: CALL_OW 50
// result := result ^ un ;
24183: LD_ADDR_VAR 0 7
24187: PUSH
24188: LD_VAR 0 7
24192: PUSH
24193: LD_VAR 0 14
24197: ADD
24198: ST_TO_ADDR
// end ;
24199: GO 24077
24201: POP
24202: POP
// end ; end ;
24203: LD_VAR 0 7
24207: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24208: LD_INT 0
24210: PPUSH
24211: PPUSH
24212: PPUSH
24213: PPUSH
24214: PPUSH
24215: PPUSH
24216: PPUSH
24217: PPUSH
24218: PPUSH
24219: PPUSH
24220: PPUSH
24221: PPUSH
24222: PPUSH
24223: PPUSH
24224: PPUSH
24225: PPUSH
// result := false ;
24226: LD_ADDR_VAR 0 3
24230: PUSH
24231: LD_INT 0
24233: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24234: LD_VAR 0 1
24238: NOT
24239: PUSH
24240: LD_VAR 0 1
24244: PPUSH
24245: CALL_OW 266
24249: PUSH
24250: LD_INT 32
24252: PUSH
24253: LD_INT 33
24255: PUSH
24256: EMPTY
24257: LIST
24258: LIST
24259: IN
24260: NOT
24261: OR
24262: IFFALSE 24266
// exit ;
24264: GO 25402
// nat := GetNation ( tower ) ;
24266: LD_ADDR_VAR 0 12
24270: PUSH
24271: LD_VAR 0 1
24275: PPUSH
24276: CALL_OW 248
24280: ST_TO_ADDR
// side := GetSide ( tower ) ;
24281: LD_ADDR_VAR 0 16
24285: PUSH
24286: LD_VAR 0 1
24290: PPUSH
24291: CALL_OW 255
24295: ST_TO_ADDR
// x := GetX ( tower ) ;
24296: LD_ADDR_VAR 0 10
24300: PUSH
24301: LD_VAR 0 1
24305: PPUSH
24306: CALL_OW 250
24310: ST_TO_ADDR
// y := GetY ( tower ) ;
24311: LD_ADDR_VAR 0 11
24315: PUSH
24316: LD_VAR 0 1
24320: PPUSH
24321: CALL_OW 251
24325: ST_TO_ADDR
// if not x or not y then
24326: LD_VAR 0 10
24330: NOT
24331: PUSH
24332: LD_VAR 0 11
24336: NOT
24337: OR
24338: IFFALSE 24342
// exit ;
24340: GO 25402
// weapon := 0 ;
24342: LD_ADDR_VAR 0 18
24346: PUSH
24347: LD_INT 0
24349: ST_TO_ADDR
// fac_list := [ ] ;
24350: LD_ADDR_VAR 0 17
24354: PUSH
24355: EMPTY
24356: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
24357: LD_ADDR_VAR 0 6
24361: PUSH
24362: LD_VAR 0 1
24366: PPUSH
24367: CALL_OW 274
24371: PPUSH
24372: LD_VAR 0 2
24376: PPUSH
24377: CALL 21980 0 2
24381: PPUSH
24382: LD_INT 30
24384: PUSH
24385: LD_INT 3
24387: PUSH
24388: EMPTY
24389: LIST
24390: LIST
24391: PPUSH
24392: CALL_OW 72
24396: ST_TO_ADDR
// if not factories then
24397: LD_VAR 0 6
24401: NOT
24402: IFFALSE 24406
// exit ;
24404: GO 25402
// for i in factories do
24406: LD_ADDR_VAR 0 8
24410: PUSH
24411: LD_VAR 0 6
24415: PUSH
24416: FOR_IN
24417: IFFALSE 24442
// fac_list := fac_list union AvailableWeaponList ( i ) ;
24419: LD_ADDR_VAR 0 17
24423: PUSH
24424: LD_VAR 0 17
24428: PUSH
24429: LD_VAR 0 8
24433: PPUSH
24434: CALL_OW 478
24438: UNION
24439: ST_TO_ADDR
24440: GO 24416
24442: POP
24443: POP
// if not fac_list then
24444: LD_VAR 0 17
24448: NOT
24449: IFFALSE 24453
// exit ;
24451: GO 25402
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
24453: LD_ADDR_VAR 0 5
24457: PUSH
24458: LD_INT 4
24460: PUSH
24461: LD_INT 5
24463: PUSH
24464: LD_INT 9
24466: PUSH
24467: LD_INT 10
24469: PUSH
24470: LD_INT 6
24472: PUSH
24473: LD_INT 7
24475: PUSH
24476: LD_INT 11
24478: PUSH
24479: EMPTY
24480: LIST
24481: LIST
24482: LIST
24483: LIST
24484: LIST
24485: LIST
24486: LIST
24487: PUSH
24488: LD_INT 27
24490: PUSH
24491: LD_INT 28
24493: PUSH
24494: LD_INT 26
24496: PUSH
24497: LD_INT 30
24499: PUSH
24500: EMPTY
24501: LIST
24502: LIST
24503: LIST
24504: LIST
24505: PUSH
24506: LD_INT 43
24508: PUSH
24509: LD_INT 44
24511: PUSH
24512: LD_INT 46
24514: PUSH
24515: LD_INT 45
24517: PUSH
24518: LD_INT 47
24520: PUSH
24521: LD_INT 49
24523: PUSH
24524: EMPTY
24525: LIST
24526: LIST
24527: LIST
24528: LIST
24529: LIST
24530: LIST
24531: PUSH
24532: EMPTY
24533: LIST
24534: LIST
24535: LIST
24536: PUSH
24537: LD_VAR 0 12
24541: ARRAY
24542: ST_TO_ADDR
// for i in list do
24543: LD_ADDR_VAR 0 8
24547: PUSH
24548: LD_VAR 0 5
24552: PUSH
24553: FOR_IN
24554: IFFALSE 24587
// if not i in fac_list then
24556: LD_VAR 0 8
24560: PUSH
24561: LD_VAR 0 17
24565: IN
24566: NOT
24567: IFFALSE 24585
// list := list diff i ;
24569: LD_ADDR_VAR 0 5
24573: PUSH
24574: LD_VAR 0 5
24578: PUSH
24579: LD_VAR 0 8
24583: DIFF
24584: ST_TO_ADDR
24585: GO 24553
24587: POP
24588: POP
// if not list then
24589: LD_VAR 0 5
24593: NOT
24594: IFFALSE 24598
// exit ;
24596: GO 25402
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
24598: LD_VAR 0 12
24602: PUSH
24603: LD_INT 3
24605: EQUAL
24606: PUSH
24607: LD_INT 49
24609: PUSH
24610: LD_VAR 0 5
24614: IN
24615: AND
24616: PUSH
24617: LD_INT 31
24619: PPUSH
24620: LD_VAR 0 16
24624: PPUSH
24625: CALL_OW 321
24629: PUSH
24630: LD_INT 2
24632: EQUAL
24633: AND
24634: IFFALSE 24694
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
24636: LD_INT 22
24638: PUSH
24639: LD_VAR 0 16
24643: PUSH
24644: EMPTY
24645: LIST
24646: LIST
24647: PUSH
24648: LD_INT 35
24650: PUSH
24651: LD_INT 49
24653: PUSH
24654: EMPTY
24655: LIST
24656: LIST
24657: PUSH
24658: LD_INT 91
24660: PUSH
24661: LD_VAR 0 1
24665: PUSH
24666: LD_INT 10
24668: PUSH
24669: EMPTY
24670: LIST
24671: LIST
24672: LIST
24673: PUSH
24674: EMPTY
24675: LIST
24676: LIST
24677: LIST
24678: PPUSH
24679: CALL_OW 69
24683: NOT
24684: IFFALSE 24694
// weapon := ru_time_lapser ;
24686: LD_ADDR_VAR 0 18
24690: PUSH
24691: LD_INT 49
24693: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24694: LD_VAR 0 12
24698: PUSH
24699: LD_INT 1
24701: PUSH
24702: LD_INT 2
24704: PUSH
24705: EMPTY
24706: LIST
24707: LIST
24708: IN
24709: PUSH
24710: LD_INT 11
24712: PUSH
24713: LD_VAR 0 5
24717: IN
24718: PUSH
24719: LD_INT 30
24721: PUSH
24722: LD_VAR 0 5
24726: IN
24727: OR
24728: AND
24729: PUSH
24730: LD_INT 6
24732: PPUSH
24733: LD_VAR 0 16
24737: PPUSH
24738: CALL_OW 321
24742: PUSH
24743: LD_INT 2
24745: EQUAL
24746: AND
24747: IFFALSE 24912
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24749: LD_INT 22
24751: PUSH
24752: LD_VAR 0 16
24756: PUSH
24757: EMPTY
24758: LIST
24759: LIST
24760: PUSH
24761: LD_INT 2
24763: PUSH
24764: LD_INT 35
24766: PUSH
24767: LD_INT 11
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: PUSH
24774: LD_INT 35
24776: PUSH
24777: LD_INT 30
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: PUSH
24784: EMPTY
24785: LIST
24786: LIST
24787: LIST
24788: PUSH
24789: LD_INT 91
24791: PUSH
24792: LD_VAR 0 1
24796: PUSH
24797: LD_INT 18
24799: PUSH
24800: EMPTY
24801: LIST
24802: LIST
24803: LIST
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: LIST
24809: PPUSH
24810: CALL_OW 69
24814: NOT
24815: PUSH
24816: LD_INT 22
24818: PUSH
24819: LD_VAR 0 16
24823: PUSH
24824: EMPTY
24825: LIST
24826: LIST
24827: PUSH
24828: LD_INT 2
24830: PUSH
24831: LD_INT 30
24833: PUSH
24834: LD_INT 32
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: LD_INT 30
24843: PUSH
24844: LD_INT 33
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: LIST
24855: PUSH
24856: LD_INT 91
24858: PUSH
24859: LD_VAR 0 1
24863: PUSH
24864: LD_INT 12
24866: PUSH
24867: EMPTY
24868: LIST
24869: LIST
24870: LIST
24871: PUSH
24872: EMPTY
24873: LIST
24874: LIST
24875: LIST
24876: PUSH
24877: EMPTY
24878: LIST
24879: PPUSH
24880: CALL_OW 69
24884: PUSH
24885: LD_INT 2
24887: GREATER
24888: AND
24889: IFFALSE 24912
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24891: LD_ADDR_VAR 0 18
24895: PUSH
24896: LD_INT 11
24898: PUSH
24899: LD_INT 30
24901: PUSH
24902: EMPTY
24903: LIST
24904: LIST
24905: PUSH
24906: LD_VAR 0 12
24910: ARRAY
24911: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24912: LD_VAR 0 18
24916: NOT
24917: PUSH
24918: LD_INT 40
24920: PPUSH
24921: LD_VAR 0 16
24925: PPUSH
24926: CALL_OW 321
24930: PUSH
24931: LD_INT 2
24933: EQUAL
24934: AND
24935: PUSH
24936: LD_INT 7
24938: PUSH
24939: LD_VAR 0 5
24943: IN
24944: PUSH
24945: LD_INT 28
24947: PUSH
24948: LD_VAR 0 5
24952: IN
24953: OR
24954: PUSH
24955: LD_INT 45
24957: PUSH
24958: LD_VAR 0 5
24962: IN
24963: OR
24964: AND
24965: IFFALSE 25219
// begin hex := GetHexInfo ( x , y ) ;
24967: LD_ADDR_VAR 0 4
24971: PUSH
24972: LD_VAR 0 10
24976: PPUSH
24977: LD_VAR 0 11
24981: PPUSH
24982: CALL_OW 546
24986: ST_TO_ADDR
// if hex [ 1 ] then
24987: LD_VAR 0 4
24991: PUSH
24992: LD_INT 1
24994: ARRAY
24995: IFFALSE 24999
// exit ;
24997: GO 25402
// height := hex [ 2 ] ;
24999: LD_ADDR_VAR 0 15
25003: PUSH
25004: LD_VAR 0 4
25008: PUSH
25009: LD_INT 2
25011: ARRAY
25012: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25013: LD_ADDR_VAR 0 14
25017: PUSH
25018: LD_INT 0
25020: PUSH
25021: LD_INT 2
25023: PUSH
25024: LD_INT 3
25026: PUSH
25027: LD_INT 5
25029: PUSH
25030: EMPTY
25031: LIST
25032: LIST
25033: LIST
25034: LIST
25035: ST_TO_ADDR
// for i in tmp do
25036: LD_ADDR_VAR 0 8
25040: PUSH
25041: LD_VAR 0 14
25045: PUSH
25046: FOR_IN
25047: IFFALSE 25217
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25049: LD_ADDR_VAR 0 9
25053: PUSH
25054: LD_VAR 0 10
25058: PPUSH
25059: LD_VAR 0 8
25063: PPUSH
25064: LD_INT 5
25066: PPUSH
25067: CALL_OW 272
25071: PUSH
25072: LD_VAR 0 11
25076: PPUSH
25077: LD_VAR 0 8
25081: PPUSH
25082: LD_INT 5
25084: PPUSH
25085: CALL_OW 273
25089: PUSH
25090: EMPTY
25091: LIST
25092: LIST
25093: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25094: LD_VAR 0 9
25098: PUSH
25099: LD_INT 1
25101: ARRAY
25102: PPUSH
25103: LD_VAR 0 9
25107: PUSH
25108: LD_INT 2
25110: ARRAY
25111: PPUSH
25112: CALL_OW 488
25116: IFFALSE 25215
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25118: LD_ADDR_VAR 0 4
25122: PUSH
25123: LD_VAR 0 9
25127: PUSH
25128: LD_INT 1
25130: ARRAY
25131: PPUSH
25132: LD_VAR 0 9
25136: PUSH
25137: LD_INT 2
25139: ARRAY
25140: PPUSH
25141: CALL_OW 546
25145: ST_TO_ADDR
// if hex [ 1 ] then
25146: LD_VAR 0 4
25150: PUSH
25151: LD_INT 1
25153: ARRAY
25154: IFFALSE 25158
// continue ;
25156: GO 25046
// h := hex [ 2 ] ;
25158: LD_ADDR_VAR 0 13
25162: PUSH
25163: LD_VAR 0 4
25167: PUSH
25168: LD_INT 2
25170: ARRAY
25171: ST_TO_ADDR
// if h + 7 < height then
25172: LD_VAR 0 13
25176: PUSH
25177: LD_INT 7
25179: PLUS
25180: PUSH
25181: LD_VAR 0 15
25185: LESS
25186: IFFALSE 25215
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25188: LD_ADDR_VAR 0 18
25192: PUSH
25193: LD_INT 7
25195: PUSH
25196: LD_INT 28
25198: PUSH
25199: LD_INT 45
25201: PUSH
25202: EMPTY
25203: LIST
25204: LIST
25205: LIST
25206: PUSH
25207: LD_VAR 0 12
25211: ARRAY
25212: ST_TO_ADDR
// break ;
25213: GO 25217
// end ; end ; end ;
25215: GO 25046
25217: POP
25218: POP
// end ; if not weapon then
25219: LD_VAR 0 18
25223: NOT
25224: IFFALSE 25284
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25226: LD_ADDR_VAR 0 5
25230: PUSH
25231: LD_VAR 0 5
25235: PUSH
25236: LD_INT 11
25238: PUSH
25239: LD_INT 30
25241: PUSH
25242: LD_INT 49
25244: PUSH
25245: EMPTY
25246: LIST
25247: LIST
25248: LIST
25249: DIFF
25250: ST_TO_ADDR
// if not list then
25251: LD_VAR 0 5
25255: NOT
25256: IFFALSE 25260
// exit ;
25258: GO 25402
// weapon := list [ rand ( 1 , list ) ] ;
25260: LD_ADDR_VAR 0 18
25264: PUSH
25265: LD_VAR 0 5
25269: PUSH
25270: LD_INT 1
25272: PPUSH
25273: LD_VAR 0 5
25277: PPUSH
25278: CALL_OW 12
25282: ARRAY
25283: ST_TO_ADDR
// end ; if weapon then
25284: LD_VAR 0 18
25288: IFFALSE 25402
// begin tmp := CostOfWeapon ( weapon ) ;
25290: LD_ADDR_VAR 0 14
25294: PUSH
25295: LD_VAR 0 18
25299: PPUSH
25300: CALL_OW 451
25304: ST_TO_ADDR
// j := GetBase ( tower ) ;
25305: LD_ADDR_VAR 0 9
25309: PUSH
25310: LD_VAR 0 1
25314: PPUSH
25315: CALL_OW 274
25319: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
25320: LD_VAR 0 9
25324: PPUSH
25325: LD_INT 1
25327: PPUSH
25328: CALL_OW 275
25332: PUSH
25333: LD_VAR 0 14
25337: PUSH
25338: LD_INT 1
25340: ARRAY
25341: GREATEREQUAL
25342: PUSH
25343: LD_VAR 0 9
25347: PPUSH
25348: LD_INT 2
25350: PPUSH
25351: CALL_OW 275
25355: PUSH
25356: LD_VAR 0 14
25360: PUSH
25361: LD_INT 2
25363: ARRAY
25364: GREATEREQUAL
25365: AND
25366: PUSH
25367: LD_VAR 0 9
25371: PPUSH
25372: LD_INT 3
25374: PPUSH
25375: CALL_OW 275
25379: PUSH
25380: LD_VAR 0 14
25384: PUSH
25385: LD_INT 3
25387: ARRAY
25388: GREATEREQUAL
25389: AND
25390: IFFALSE 25402
// result := weapon ;
25392: LD_ADDR_VAR 0 3
25396: PUSH
25397: LD_VAR 0 18
25401: ST_TO_ADDR
// end ; end ;
25402: LD_VAR 0 3
25406: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25407: LD_INT 0
25409: PPUSH
25410: PPUSH
// result := true ;
25411: LD_ADDR_VAR 0 3
25415: PUSH
25416: LD_INT 1
25418: ST_TO_ADDR
// if array1 = array2 then
25419: LD_VAR 0 1
25423: PUSH
25424: LD_VAR 0 2
25428: EQUAL
25429: IFFALSE 25489
// begin for i = 1 to array1 do
25431: LD_ADDR_VAR 0 4
25435: PUSH
25436: DOUBLE
25437: LD_INT 1
25439: DEC
25440: ST_TO_ADDR
25441: LD_VAR 0 1
25445: PUSH
25446: FOR_TO
25447: IFFALSE 25485
// if array1 [ i ] <> array2 [ i ] then
25449: LD_VAR 0 1
25453: PUSH
25454: LD_VAR 0 4
25458: ARRAY
25459: PUSH
25460: LD_VAR 0 2
25464: PUSH
25465: LD_VAR 0 4
25469: ARRAY
25470: NONEQUAL
25471: IFFALSE 25483
// begin result := false ;
25473: LD_ADDR_VAR 0 3
25477: PUSH
25478: LD_INT 0
25480: ST_TO_ADDR
// break ;
25481: GO 25485
// end ;
25483: GO 25446
25485: POP
25486: POP
// end else
25487: GO 25497
// result := false ;
25489: LD_ADDR_VAR 0 3
25493: PUSH
25494: LD_INT 0
25496: ST_TO_ADDR
// end ;
25497: LD_VAR 0 3
25501: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
25502: LD_INT 0
25504: PPUSH
25505: PPUSH
25506: PPUSH
// pom := GetBase ( fac ) ;
25507: LD_ADDR_VAR 0 5
25511: PUSH
25512: LD_VAR 0 1
25516: PPUSH
25517: CALL_OW 274
25521: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25522: LD_ADDR_VAR 0 4
25526: PUSH
25527: LD_VAR 0 2
25531: PUSH
25532: LD_INT 1
25534: ARRAY
25535: PPUSH
25536: LD_VAR 0 2
25540: PUSH
25541: LD_INT 2
25543: ARRAY
25544: PPUSH
25545: LD_VAR 0 2
25549: PUSH
25550: LD_INT 3
25552: ARRAY
25553: PPUSH
25554: LD_VAR 0 2
25558: PUSH
25559: LD_INT 4
25561: ARRAY
25562: PPUSH
25563: CALL_OW 449
25567: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25568: LD_ADDR_VAR 0 3
25572: PUSH
25573: LD_VAR 0 5
25577: PPUSH
25578: LD_INT 1
25580: PPUSH
25581: CALL_OW 275
25585: PUSH
25586: LD_VAR 0 4
25590: PUSH
25591: LD_INT 1
25593: ARRAY
25594: GREATEREQUAL
25595: PUSH
25596: LD_VAR 0 5
25600: PPUSH
25601: LD_INT 2
25603: PPUSH
25604: CALL_OW 275
25608: PUSH
25609: LD_VAR 0 4
25613: PUSH
25614: LD_INT 2
25616: ARRAY
25617: GREATEREQUAL
25618: AND
25619: PUSH
25620: LD_VAR 0 5
25624: PPUSH
25625: LD_INT 3
25627: PPUSH
25628: CALL_OW 275
25632: PUSH
25633: LD_VAR 0 4
25637: PUSH
25638: LD_INT 3
25640: ARRAY
25641: GREATEREQUAL
25642: AND
25643: ST_TO_ADDR
// end ;
25644: LD_VAR 0 3
25648: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25649: LD_INT 0
25651: PPUSH
25652: PPUSH
25653: PPUSH
25654: PPUSH
// pom := GetBase ( building ) ;
25655: LD_ADDR_VAR 0 3
25659: PUSH
25660: LD_VAR 0 1
25664: PPUSH
25665: CALL_OW 274
25669: ST_TO_ADDR
// if not pom then
25670: LD_VAR 0 3
25674: NOT
25675: IFFALSE 25679
// exit ;
25677: GO 25849
// btype := GetBType ( building ) ;
25679: LD_ADDR_VAR 0 5
25683: PUSH
25684: LD_VAR 0 1
25688: PPUSH
25689: CALL_OW 266
25693: ST_TO_ADDR
// if btype = b_armoury then
25694: LD_VAR 0 5
25698: PUSH
25699: LD_INT 4
25701: EQUAL
25702: IFFALSE 25712
// btype := b_barracks ;
25704: LD_ADDR_VAR 0 5
25708: PUSH
25709: LD_INT 5
25711: ST_TO_ADDR
// if btype = b_depot then
25712: LD_VAR 0 5
25716: PUSH
25717: LD_INT 0
25719: EQUAL
25720: IFFALSE 25730
// btype := b_warehouse ;
25722: LD_ADDR_VAR 0 5
25726: PUSH
25727: LD_INT 1
25729: ST_TO_ADDR
// if btype = b_workshop then
25730: LD_VAR 0 5
25734: PUSH
25735: LD_INT 2
25737: EQUAL
25738: IFFALSE 25748
// btype := b_factory ;
25740: LD_ADDR_VAR 0 5
25744: PUSH
25745: LD_INT 3
25747: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25748: LD_ADDR_VAR 0 4
25752: PUSH
25753: LD_VAR 0 5
25757: PPUSH
25758: LD_VAR 0 1
25762: PPUSH
25763: CALL_OW 248
25767: PPUSH
25768: CALL_OW 450
25772: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25773: LD_ADDR_VAR 0 2
25777: PUSH
25778: LD_VAR 0 3
25782: PPUSH
25783: LD_INT 1
25785: PPUSH
25786: CALL_OW 275
25790: PUSH
25791: LD_VAR 0 4
25795: PUSH
25796: LD_INT 1
25798: ARRAY
25799: GREATEREQUAL
25800: PUSH
25801: LD_VAR 0 3
25805: PPUSH
25806: LD_INT 2
25808: PPUSH
25809: CALL_OW 275
25813: PUSH
25814: LD_VAR 0 4
25818: PUSH
25819: LD_INT 2
25821: ARRAY
25822: GREATEREQUAL
25823: AND
25824: PUSH
25825: LD_VAR 0 3
25829: PPUSH
25830: LD_INT 3
25832: PPUSH
25833: CALL_OW 275
25837: PUSH
25838: LD_VAR 0 4
25842: PUSH
25843: LD_INT 3
25845: ARRAY
25846: GREATEREQUAL
25847: AND
25848: ST_TO_ADDR
// end ;
25849: LD_VAR 0 2
25853: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25854: LD_INT 0
25856: PPUSH
25857: PPUSH
25858: PPUSH
// pom := GetBase ( building ) ;
25859: LD_ADDR_VAR 0 4
25863: PUSH
25864: LD_VAR 0 1
25868: PPUSH
25869: CALL_OW 274
25873: ST_TO_ADDR
// if not pom then
25874: LD_VAR 0 4
25878: NOT
25879: IFFALSE 25883
// exit ;
25881: GO 25984
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25883: LD_ADDR_VAR 0 5
25887: PUSH
25888: LD_VAR 0 2
25892: PPUSH
25893: LD_VAR 0 1
25897: PPUSH
25898: CALL_OW 248
25902: PPUSH
25903: CALL_OW 450
25907: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25908: LD_ADDR_VAR 0 3
25912: PUSH
25913: LD_VAR 0 4
25917: PPUSH
25918: LD_INT 1
25920: PPUSH
25921: CALL_OW 275
25925: PUSH
25926: LD_VAR 0 5
25930: PUSH
25931: LD_INT 1
25933: ARRAY
25934: GREATEREQUAL
25935: PUSH
25936: LD_VAR 0 4
25940: PPUSH
25941: LD_INT 2
25943: PPUSH
25944: CALL_OW 275
25948: PUSH
25949: LD_VAR 0 5
25953: PUSH
25954: LD_INT 2
25956: ARRAY
25957: GREATEREQUAL
25958: AND
25959: PUSH
25960: LD_VAR 0 4
25964: PPUSH
25965: LD_INT 3
25967: PPUSH
25968: CALL_OW 275
25972: PUSH
25973: LD_VAR 0 5
25977: PUSH
25978: LD_INT 3
25980: ARRAY
25981: GREATEREQUAL
25982: AND
25983: ST_TO_ADDR
// end ;
25984: LD_VAR 0 3
25988: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
25989: LD_INT 0
25991: PPUSH
25992: PPUSH
25993: PPUSH
25994: PPUSH
25995: PPUSH
25996: PPUSH
25997: PPUSH
25998: PPUSH
25999: PPUSH
26000: PPUSH
// result := false ;
26001: LD_ADDR_VAR 0 6
26005: PUSH
26006: LD_INT 0
26008: ST_TO_ADDR
// if not base or not btype or not x or not y then
26009: LD_VAR 0 1
26013: NOT
26014: PUSH
26015: LD_VAR 0 2
26019: NOT
26020: OR
26021: PUSH
26022: LD_VAR 0 3
26026: NOT
26027: OR
26028: PUSH
26029: LD_VAR 0 4
26033: NOT
26034: OR
26035: IFFALSE 26039
// exit ;
26037: GO 26648
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
26039: LD_ADDR_VAR 0 12
26043: PUSH
26044: LD_VAR 0 2
26048: PPUSH
26049: LD_VAR 0 3
26053: PPUSH
26054: LD_VAR 0 4
26058: PPUSH
26059: LD_VAR 0 5
26063: PPUSH
26064: LD_VAR 0 1
26068: PUSH
26069: LD_INT 1
26071: ARRAY
26072: PPUSH
26073: CALL_OW 248
26077: PPUSH
26078: LD_INT 0
26080: PPUSH
26081: CALL 27485 0 6
26085: ST_TO_ADDR
// if not hexes then
26086: LD_VAR 0 12
26090: NOT
26091: IFFALSE 26095
// exit ;
26093: GO 26648
// for i = 1 to hexes do
26095: LD_ADDR_VAR 0 7
26099: PUSH
26100: DOUBLE
26101: LD_INT 1
26103: DEC
26104: ST_TO_ADDR
26105: LD_VAR 0 12
26109: PUSH
26110: FOR_TO
26111: IFFALSE 26646
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26113: LD_ADDR_VAR 0 11
26117: PUSH
26118: LD_VAR 0 12
26122: PUSH
26123: LD_VAR 0 7
26127: ARRAY
26128: PUSH
26129: LD_INT 1
26131: ARRAY
26132: PPUSH
26133: LD_VAR 0 12
26137: PUSH
26138: LD_VAR 0 7
26142: ARRAY
26143: PUSH
26144: LD_INT 2
26146: ARRAY
26147: PPUSH
26148: CALL_OW 428
26152: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26153: LD_VAR 0 12
26157: PUSH
26158: LD_VAR 0 7
26162: ARRAY
26163: PUSH
26164: LD_INT 1
26166: ARRAY
26167: PPUSH
26168: LD_VAR 0 12
26172: PUSH
26173: LD_VAR 0 7
26177: ARRAY
26178: PUSH
26179: LD_INT 2
26181: ARRAY
26182: PPUSH
26183: CALL_OW 351
26187: PUSH
26188: LD_VAR 0 12
26192: PUSH
26193: LD_VAR 0 7
26197: ARRAY
26198: PUSH
26199: LD_INT 1
26201: ARRAY
26202: PPUSH
26203: LD_VAR 0 12
26207: PUSH
26208: LD_VAR 0 7
26212: ARRAY
26213: PUSH
26214: LD_INT 2
26216: ARRAY
26217: PPUSH
26218: CALL_OW 488
26222: NOT
26223: OR
26224: PUSH
26225: LD_VAR 0 11
26229: PPUSH
26230: CALL_OW 247
26234: PUSH
26235: LD_INT 3
26237: EQUAL
26238: OR
26239: IFFALSE 26245
// exit ;
26241: POP
26242: POP
26243: GO 26648
// if not tmp or not tmp in base then
26245: LD_VAR 0 11
26249: NOT
26250: PUSH
26251: LD_VAR 0 11
26255: PUSH
26256: LD_VAR 0 1
26260: IN
26261: NOT
26262: OR
26263: IFFALSE 26267
// continue ;
26265: GO 26110
// result := true ;
26267: LD_ADDR_VAR 0 6
26271: PUSH
26272: LD_INT 1
26274: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26275: LD_ADDR_VAR 0 15
26279: PUSH
26280: LD_VAR 0 1
26284: PPUSH
26285: LD_INT 22
26287: PUSH
26288: LD_VAR 0 11
26292: PPUSH
26293: CALL_OW 255
26297: PUSH
26298: EMPTY
26299: LIST
26300: LIST
26301: PUSH
26302: LD_INT 2
26304: PUSH
26305: LD_INT 30
26307: PUSH
26308: LD_INT 0
26310: PUSH
26311: EMPTY
26312: LIST
26313: LIST
26314: PUSH
26315: LD_INT 30
26317: PUSH
26318: LD_INT 1
26320: PUSH
26321: EMPTY
26322: LIST
26323: LIST
26324: PUSH
26325: EMPTY
26326: LIST
26327: LIST
26328: LIST
26329: PUSH
26330: EMPTY
26331: LIST
26332: LIST
26333: PPUSH
26334: CALL_OW 72
26338: ST_TO_ADDR
// if dep then
26339: LD_VAR 0 15
26343: IFFALSE 26479
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
26345: LD_ADDR_VAR 0 14
26349: PUSH
26350: LD_VAR 0 15
26354: PUSH
26355: LD_INT 1
26357: ARRAY
26358: PPUSH
26359: CALL_OW 250
26363: PPUSH
26364: LD_VAR 0 15
26368: PUSH
26369: LD_INT 1
26371: ARRAY
26372: PPUSH
26373: CALL_OW 254
26377: PPUSH
26378: LD_INT 5
26380: PPUSH
26381: CALL_OW 272
26385: PUSH
26386: LD_VAR 0 15
26390: PUSH
26391: LD_INT 1
26393: ARRAY
26394: PPUSH
26395: CALL_OW 251
26399: PPUSH
26400: LD_VAR 0 15
26404: PUSH
26405: LD_INT 1
26407: ARRAY
26408: PPUSH
26409: CALL_OW 254
26413: PPUSH
26414: LD_INT 5
26416: PPUSH
26417: CALL_OW 273
26421: PUSH
26422: EMPTY
26423: LIST
26424: LIST
26425: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26426: LD_VAR 0 14
26430: PUSH
26431: LD_INT 1
26433: ARRAY
26434: PPUSH
26435: LD_VAR 0 14
26439: PUSH
26440: LD_INT 2
26442: ARRAY
26443: PPUSH
26444: CALL_OW 488
26448: IFFALSE 26479
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26450: LD_VAR 0 11
26454: PPUSH
26455: LD_VAR 0 14
26459: PUSH
26460: LD_INT 1
26462: ARRAY
26463: PPUSH
26464: LD_VAR 0 14
26468: PUSH
26469: LD_INT 2
26471: ARRAY
26472: PPUSH
26473: CALL_OW 111
// continue ;
26477: GO 26110
// end ; end ; r := GetDir ( tmp ) ;
26479: LD_ADDR_VAR 0 13
26483: PUSH
26484: LD_VAR 0 11
26488: PPUSH
26489: CALL_OW 254
26493: ST_TO_ADDR
// if r = 5 then
26494: LD_VAR 0 13
26498: PUSH
26499: LD_INT 5
26501: EQUAL
26502: IFFALSE 26512
// r := 0 ;
26504: LD_ADDR_VAR 0 13
26508: PUSH
26509: LD_INT 0
26511: ST_TO_ADDR
// for j = r to 5 do
26512: LD_ADDR_VAR 0 8
26516: PUSH
26517: DOUBLE
26518: LD_VAR 0 13
26522: DEC
26523: ST_TO_ADDR
26524: LD_INT 5
26526: PUSH
26527: FOR_TO
26528: IFFALSE 26642
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26530: LD_ADDR_VAR 0 9
26534: PUSH
26535: LD_VAR 0 11
26539: PPUSH
26540: CALL_OW 250
26544: PPUSH
26545: LD_VAR 0 8
26549: PPUSH
26550: LD_INT 2
26552: PPUSH
26553: CALL_OW 272
26557: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26558: LD_ADDR_VAR 0 10
26562: PUSH
26563: LD_VAR 0 11
26567: PPUSH
26568: CALL_OW 251
26572: PPUSH
26573: LD_VAR 0 8
26577: PPUSH
26578: LD_INT 2
26580: PPUSH
26581: CALL_OW 273
26585: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26586: LD_VAR 0 9
26590: PPUSH
26591: LD_VAR 0 10
26595: PPUSH
26596: CALL_OW 488
26600: PUSH
26601: LD_VAR 0 9
26605: PPUSH
26606: LD_VAR 0 10
26610: PPUSH
26611: CALL_OW 428
26615: NOT
26616: AND
26617: IFFALSE 26640
// begin ComMoveXY ( tmp , _x , _y ) ;
26619: LD_VAR 0 11
26623: PPUSH
26624: LD_VAR 0 9
26628: PPUSH
26629: LD_VAR 0 10
26633: PPUSH
26634: CALL_OW 111
// break ;
26638: GO 26642
// end ; end ;
26640: GO 26527
26642: POP
26643: POP
// end ;
26644: GO 26110
26646: POP
26647: POP
// end ;
26648: LD_VAR 0 6
26652: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
26653: LD_INT 0
26655: PPUSH
26656: PPUSH
26657: PPUSH
26658: PPUSH
26659: PPUSH
26660: PPUSH
26661: PPUSH
26662: PPUSH
26663: PPUSH
26664: PPUSH
// result := false ;
26665: LD_ADDR_VAR 0 6
26669: PUSH
26670: LD_INT 0
26672: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26673: LD_VAR 0 1
26677: NOT
26678: PUSH
26679: LD_VAR 0 1
26683: PPUSH
26684: CALL_OW 266
26688: PUSH
26689: LD_INT 0
26691: PUSH
26692: LD_INT 1
26694: PUSH
26695: EMPTY
26696: LIST
26697: LIST
26698: IN
26699: NOT
26700: OR
26701: PUSH
26702: LD_VAR 0 2
26706: NOT
26707: OR
26708: PUSH
26709: LD_VAR 0 5
26713: PUSH
26714: LD_INT 0
26716: PUSH
26717: LD_INT 1
26719: PUSH
26720: LD_INT 2
26722: PUSH
26723: LD_INT 3
26725: PUSH
26726: LD_INT 4
26728: PUSH
26729: LD_INT 5
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: LIST
26736: LIST
26737: LIST
26738: LIST
26739: IN
26740: NOT
26741: OR
26742: PUSH
26743: LD_VAR 0 3
26747: PPUSH
26748: LD_VAR 0 4
26752: PPUSH
26753: CALL_OW 488
26757: NOT
26758: OR
26759: IFFALSE 26763
// exit ;
26761: GO 27480
// pom := GetBase ( depot ) ;
26763: LD_ADDR_VAR 0 10
26767: PUSH
26768: LD_VAR 0 1
26772: PPUSH
26773: CALL_OW 274
26777: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26778: LD_ADDR_VAR 0 11
26782: PUSH
26783: LD_VAR 0 2
26787: PPUSH
26788: LD_VAR 0 1
26792: PPUSH
26793: CALL_OW 248
26797: PPUSH
26798: CALL_OW 450
26802: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26803: LD_VAR 0 10
26807: PPUSH
26808: LD_INT 1
26810: PPUSH
26811: CALL_OW 275
26815: PUSH
26816: LD_VAR 0 11
26820: PUSH
26821: LD_INT 1
26823: ARRAY
26824: GREATEREQUAL
26825: PUSH
26826: LD_VAR 0 10
26830: PPUSH
26831: LD_INT 2
26833: PPUSH
26834: CALL_OW 275
26838: PUSH
26839: LD_VAR 0 11
26843: PUSH
26844: LD_INT 2
26846: ARRAY
26847: GREATEREQUAL
26848: AND
26849: PUSH
26850: LD_VAR 0 10
26854: PPUSH
26855: LD_INT 3
26857: PPUSH
26858: CALL_OW 275
26862: PUSH
26863: LD_VAR 0 11
26867: PUSH
26868: LD_INT 3
26870: ARRAY
26871: GREATEREQUAL
26872: AND
26873: NOT
26874: IFFALSE 26878
// exit ;
26876: GO 27480
// if GetBType ( depot ) = b_depot then
26878: LD_VAR 0 1
26882: PPUSH
26883: CALL_OW 266
26887: PUSH
26888: LD_INT 0
26890: EQUAL
26891: IFFALSE 26903
// dist := 28 else
26893: LD_ADDR_VAR 0 14
26897: PUSH
26898: LD_INT 28
26900: ST_TO_ADDR
26901: GO 26911
// dist := 36 ;
26903: LD_ADDR_VAR 0 14
26907: PUSH
26908: LD_INT 36
26910: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26911: LD_VAR 0 1
26915: PPUSH
26916: LD_VAR 0 3
26920: PPUSH
26921: LD_VAR 0 4
26925: PPUSH
26926: CALL_OW 297
26930: PUSH
26931: LD_VAR 0 14
26935: GREATER
26936: IFFALSE 26940
// exit ;
26938: GO 27480
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
26940: LD_ADDR_VAR 0 12
26944: PUSH
26945: LD_VAR 0 2
26949: PPUSH
26950: LD_VAR 0 3
26954: PPUSH
26955: LD_VAR 0 4
26959: PPUSH
26960: LD_VAR 0 5
26964: PPUSH
26965: LD_VAR 0 1
26969: PPUSH
26970: CALL_OW 248
26974: PPUSH
26975: LD_INT 0
26977: PPUSH
26978: CALL 27485 0 6
26982: ST_TO_ADDR
// if not hexes then
26983: LD_VAR 0 12
26987: NOT
26988: IFFALSE 26992
// exit ;
26990: GO 27480
// hex := GetHexInfo ( x , y ) ;
26992: LD_ADDR_VAR 0 15
26996: PUSH
26997: LD_VAR 0 3
27001: PPUSH
27002: LD_VAR 0 4
27006: PPUSH
27007: CALL_OW 546
27011: ST_TO_ADDR
// if hex [ 1 ] then
27012: LD_VAR 0 15
27016: PUSH
27017: LD_INT 1
27019: ARRAY
27020: IFFALSE 27024
// exit ;
27022: GO 27480
// height := hex [ 2 ] ;
27024: LD_ADDR_VAR 0 13
27028: PUSH
27029: LD_VAR 0 15
27033: PUSH
27034: LD_INT 2
27036: ARRAY
27037: ST_TO_ADDR
// for i = 1 to hexes do
27038: LD_ADDR_VAR 0 7
27042: PUSH
27043: DOUBLE
27044: LD_INT 1
27046: DEC
27047: ST_TO_ADDR
27048: LD_VAR 0 12
27052: PUSH
27053: FOR_TO
27054: IFFALSE 27384
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27056: LD_VAR 0 12
27060: PUSH
27061: LD_VAR 0 7
27065: ARRAY
27066: PUSH
27067: LD_INT 1
27069: ARRAY
27070: PPUSH
27071: LD_VAR 0 12
27075: PUSH
27076: LD_VAR 0 7
27080: ARRAY
27081: PUSH
27082: LD_INT 2
27084: ARRAY
27085: PPUSH
27086: CALL_OW 488
27090: NOT
27091: PUSH
27092: LD_VAR 0 12
27096: PUSH
27097: LD_VAR 0 7
27101: ARRAY
27102: PUSH
27103: LD_INT 1
27105: ARRAY
27106: PPUSH
27107: LD_VAR 0 12
27111: PUSH
27112: LD_VAR 0 7
27116: ARRAY
27117: PUSH
27118: LD_INT 2
27120: ARRAY
27121: PPUSH
27122: CALL_OW 428
27126: PUSH
27127: LD_INT 0
27129: GREATER
27130: OR
27131: PUSH
27132: LD_VAR 0 12
27136: PUSH
27137: LD_VAR 0 7
27141: ARRAY
27142: PUSH
27143: LD_INT 1
27145: ARRAY
27146: PPUSH
27147: LD_VAR 0 12
27151: PUSH
27152: LD_VAR 0 7
27156: ARRAY
27157: PUSH
27158: LD_INT 2
27160: ARRAY
27161: PPUSH
27162: CALL_OW 351
27166: OR
27167: IFFALSE 27173
// exit ;
27169: POP
27170: POP
27171: GO 27480
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27173: LD_ADDR_VAR 0 8
27177: PUSH
27178: LD_VAR 0 12
27182: PUSH
27183: LD_VAR 0 7
27187: ARRAY
27188: PUSH
27189: LD_INT 1
27191: ARRAY
27192: PPUSH
27193: LD_VAR 0 12
27197: PUSH
27198: LD_VAR 0 7
27202: ARRAY
27203: PUSH
27204: LD_INT 2
27206: ARRAY
27207: PPUSH
27208: CALL_OW 546
27212: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27213: LD_VAR 0 8
27217: PUSH
27218: LD_INT 1
27220: ARRAY
27221: PUSH
27222: LD_VAR 0 8
27226: PUSH
27227: LD_INT 2
27229: ARRAY
27230: PUSH
27231: LD_VAR 0 13
27235: PUSH
27236: LD_INT 2
27238: PLUS
27239: GREATER
27240: OR
27241: PUSH
27242: LD_VAR 0 8
27246: PUSH
27247: LD_INT 2
27249: ARRAY
27250: PUSH
27251: LD_VAR 0 13
27255: PUSH
27256: LD_INT 2
27258: MINUS
27259: LESS
27260: OR
27261: PUSH
27262: LD_VAR 0 8
27266: PUSH
27267: LD_INT 3
27269: ARRAY
27270: PUSH
27271: LD_INT 0
27273: PUSH
27274: LD_INT 8
27276: PUSH
27277: LD_INT 9
27279: PUSH
27280: LD_INT 10
27282: PUSH
27283: LD_INT 11
27285: PUSH
27286: LD_INT 12
27288: PUSH
27289: LD_INT 13
27291: PUSH
27292: LD_INT 16
27294: PUSH
27295: LD_INT 17
27297: PUSH
27298: LD_INT 18
27300: PUSH
27301: LD_INT 19
27303: PUSH
27304: LD_INT 20
27306: PUSH
27307: LD_INT 21
27309: PUSH
27310: EMPTY
27311: LIST
27312: LIST
27313: LIST
27314: LIST
27315: LIST
27316: LIST
27317: LIST
27318: LIST
27319: LIST
27320: LIST
27321: LIST
27322: LIST
27323: LIST
27324: IN
27325: NOT
27326: OR
27327: PUSH
27328: LD_VAR 0 8
27332: PUSH
27333: LD_INT 5
27335: ARRAY
27336: NOT
27337: OR
27338: PUSH
27339: LD_VAR 0 8
27343: PUSH
27344: LD_INT 6
27346: ARRAY
27347: PUSH
27348: LD_INT 1
27350: PUSH
27351: LD_INT 2
27353: PUSH
27354: LD_INT 7
27356: PUSH
27357: LD_INT 9
27359: PUSH
27360: LD_INT 10
27362: PUSH
27363: LD_INT 11
27365: PUSH
27366: EMPTY
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: LIST
27372: LIST
27373: IN
27374: NOT
27375: OR
27376: IFFALSE 27382
// exit ;
27378: POP
27379: POP
27380: GO 27480
// end ;
27382: GO 27053
27384: POP
27385: POP
// side := GetSide ( depot ) ;
27386: LD_ADDR_VAR 0 9
27390: PUSH
27391: LD_VAR 0 1
27395: PPUSH
27396: CALL_OW 255
27400: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27401: LD_VAR 0 9
27405: PPUSH
27406: LD_VAR 0 3
27410: PPUSH
27411: LD_VAR 0 4
27415: PPUSH
27416: LD_INT 20
27418: PPUSH
27419: CALL 20134 0 4
27423: PUSH
27424: LD_INT 4
27426: ARRAY
27427: IFFALSE 27431
// exit ;
27429: GO 27480
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27431: LD_VAR 0 2
27435: PUSH
27436: LD_INT 29
27438: PUSH
27439: LD_INT 30
27441: PUSH
27442: EMPTY
27443: LIST
27444: LIST
27445: IN
27446: PUSH
27447: LD_VAR 0 3
27451: PPUSH
27452: LD_VAR 0 4
27456: PPUSH
27457: LD_VAR 0 9
27461: PPUSH
27462: CALL_OW 440
27466: NOT
27467: AND
27468: IFFALSE 27472
// exit ;
27470: GO 27480
// result := true ;
27472: LD_ADDR_VAR 0 6
27476: PUSH
27477: LD_INT 1
27479: ST_TO_ADDR
// end ;
27480: LD_VAR 0 6
27484: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
27485: LD_INT 0
27487: PPUSH
27488: PPUSH
27489: PPUSH
27490: PPUSH
27491: PPUSH
27492: PPUSH
27493: PPUSH
27494: PPUSH
27495: PPUSH
27496: PPUSH
27497: PPUSH
27498: PPUSH
27499: PPUSH
27500: PPUSH
27501: PPUSH
27502: PPUSH
27503: PPUSH
27504: PPUSH
27505: PPUSH
27506: PPUSH
27507: PPUSH
27508: PPUSH
27509: PPUSH
27510: PPUSH
27511: PPUSH
27512: PPUSH
27513: PPUSH
27514: PPUSH
27515: PPUSH
27516: PPUSH
27517: PPUSH
27518: PPUSH
27519: PPUSH
27520: PPUSH
27521: PPUSH
27522: PPUSH
27523: PPUSH
27524: PPUSH
27525: PPUSH
27526: PPUSH
27527: PPUSH
27528: PPUSH
27529: PPUSH
27530: PPUSH
27531: PPUSH
27532: PPUSH
27533: PPUSH
27534: PPUSH
27535: PPUSH
27536: PPUSH
27537: PPUSH
27538: PPUSH
27539: PPUSH
27540: PPUSH
27541: PPUSH
27542: PPUSH
27543: PPUSH
27544: PPUSH
// result = [ ] ;
27545: LD_ADDR_VAR 0 7
27549: PUSH
27550: EMPTY
27551: ST_TO_ADDR
// temp_list = [ ] ;
27552: LD_ADDR_VAR 0 9
27556: PUSH
27557: EMPTY
27558: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27559: LD_VAR 0 4
27563: PUSH
27564: LD_INT 0
27566: PUSH
27567: LD_INT 1
27569: PUSH
27570: LD_INT 2
27572: PUSH
27573: LD_INT 3
27575: PUSH
27576: LD_INT 4
27578: PUSH
27579: LD_INT 5
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: LIST
27589: IN
27590: NOT
27591: PUSH
27592: LD_VAR 0 1
27596: PUSH
27597: LD_INT 0
27599: PUSH
27600: LD_INT 1
27602: PUSH
27603: EMPTY
27604: LIST
27605: LIST
27606: IN
27607: PUSH
27608: LD_VAR 0 5
27612: PUSH
27613: LD_INT 1
27615: PUSH
27616: LD_INT 2
27618: PUSH
27619: LD_INT 3
27621: PUSH
27622: EMPTY
27623: LIST
27624: LIST
27625: LIST
27626: IN
27627: NOT
27628: AND
27629: OR
27630: IFFALSE 27634
// exit ;
27632: GO 46025
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
27634: LD_VAR 0 1
27638: PUSH
27639: LD_INT 6
27641: PUSH
27642: LD_INT 7
27644: PUSH
27645: LD_INT 8
27647: PUSH
27648: LD_INT 13
27650: PUSH
27651: LD_INT 12
27653: PUSH
27654: LD_INT 15
27656: PUSH
27657: LD_INT 11
27659: PUSH
27660: LD_INT 14
27662: PUSH
27663: LD_INT 10
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: LIST
27670: LIST
27671: LIST
27672: LIST
27673: LIST
27674: LIST
27675: LIST
27676: IN
27677: IFFALSE 27687
// btype = b_lab ;
27679: LD_ADDR_VAR 0 1
27683: PUSH
27684: LD_INT 6
27686: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27687: LD_VAR 0 6
27691: PUSH
27692: LD_INT 0
27694: PUSH
27695: LD_INT 1
27697: PUSH
27698: LD_INT 2
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: LIST
27705: IN
27706: NOT
27707: PUSH
27708: LD_VAR 0 1
27712: PUSH
27713: LD_INT 0
27715: PUSH
27716: LD_INT 1
27718: PUSH
27719: LD_INT 2
27721: PUSH
27722: LD_INT 3
27724: PUSH
27725: LD_INT 6
27727: PUSH
27728: LD_INT 36
27730: PUSH
27731: LD_INT 4
27733: PUSH
27734: LD_INT 5
27736: PUSH
27737: LD_INT 31
27739: PUSH
27740: LD_INT 32
27742: PUSH
27743: LD_INT 33
27745: PUSH
27746: EMPTY
27747: LIST
27748: LIST
27749: LIST
27750: LIST
27751: LIST
27752: LIST
27753: LIST
27754: LIST
27755: LIST
27756: LIST
27757: LIST
27758: IN
27759: NOT
27760: PUSH
27761: LD_VAR 0 6
27765: PUSH
27766: LD_INT 1
27768: EQUAL
27769: AND
27770: OR
27771: PUSH
27772: LD_VAR 0 1
27776: PUSH
27777: LD_INT 2
27779: PUSH
27780: LD_INT 3
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: IN
27787: NOT
27788: PUSH
27789: LD_VAR 0 6
27793: PUSH
27794: LD_INT 2
27796: EQUAL
27797: AND
27798: OR
27799: IFFALSE 27809
// mode = 0 ;
27801: LD_ADDR_VAR 0 6
27805: PUSH
27806: LD_INT 0
27808: ST_TO_ADDR
// case mode of 0 :
27809: LD_VAR 0 6
27813: PUSH
27814: LD_INT 0
27816: DOUBLE
27817: EQUAL
27818: IFTRUE 27822
27820: GO 39275
27822: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27823: LD_ADDR_VAR 0 11
27827: PUSH
27828: LD_INT 0
27830: PUSH
27831: LD_INT 0
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: LD_INT 0
27840: PUSH
27841: LD_INT 1
27843: NEG
27844: PUSH
27845: EMPTY
27846: LIST
27847: LIST
27848: PUSH
27849: LD_INT 1
27851: PUSH
27852: LD_INT 0
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: PUSH
27859: LD_INT 1
27861: PUSH
27862: LD_INT 1
27864: PUSH
27865: EMPTY
27866: LIST
27867: LIST
27868: PUSH
27869: LD_INT 0
27871: PUSH
27872: LD_INT 1
27874: PUSH
27875: EMPTY
27876: LIST
27877: LIST
27878: PUSH
27879: LD_INT 1
27881: NEG
27882: PUSH
27883: LD_INT 0
27885: PUSH
27886: EMPTY
27887: LIST
27888: LIST
27889: PUSH
27890: LD_INT 1
27892: NEG
27893: PUSH
27894: LD_INT 1
27896: NEG
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: PUSH
27902: LD_INT 1
27904: NEG
27905: PUSH
27906: LD_INT 2
27908: NEG
27909: PUSH
27910: EMPTY
27911: LIST
27912: LIST
27913: PUSH
27914: LD_INT 0
27916: PUSH
27917: LD_INT 2
27919: NEG
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: PUSH
27925: LD_INT 1
27927: PUSH
27928: LD_INT 1
27930: NEG
27931: PUSH
27932: EMPTY
27933: LIST
27934: LIST
27935: PUSH
27936: LD_INT 1
27938: PUSH
27939: LD_INT 2
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: PUSH
27946: LD_INT 0
27948: PUSH
27949: LD_INT 2
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PUSH
27956: LD_INT 1
27958: NEG
27959: PUSH
27960: LD_INT 1
27962: PUSH
27963: EMPTY
27964: LIST
27965: LIST
27966: PUSH
27967: LD_INT 1
27969: PUSH
27970: LD_INT 3
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: PUSH
27977: LD_INT 0
27979: PUSH
27980: LD_INT 3
27982: PUSH
27983: EMPTY
27984: LIST
27985: LIST
27986: PUSH
27987: LD_INT 1
27989: NEG
27990: PUSH
27991: LD_INT 2
27993: PUSH
27994: EMPTY
27995: LIST
27996: LIST
27997: PUSH
27998: EMPTY
27999: LIST
28000: LIST
28001: LIST
28002: LIST
28003: LIST
28004: LIST
28005: LIST
28006: LIST
28007: LIST
28008: LIST
28009: LIST
28010: LIST
28011: LIST
28012: LIST
28013: LIST
28014: LIST
28015: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28016: LD_ADDR_VAR 0 12
28020: PUSH
28021: LD_INT 0
28023: PUSH
28024: LD_INT 0
28026: PUSH
28027: EMPTY
28028: LIST
28029: LIST
28030: PUSH
28031: LD_INT 0
28033: PUSH
28034: LD_INT 1
28036: NEG
28037: PUSH
28038: EMPTY
28039: LIST
28040: LIST
28041: PUSH
28042: LD_INT 1
28044: PUSH
28045: LD_INT 0
28047: PUSH
28048: EMPTY
28049: LIST
28050: LIST
28051: PUSH
28052: LD_INT 1
28054: PUSH
28055: LD_INT 1
28057: PUSH
28058: EMPTY
28059: LIST
28060: LIST
28061: PUSH
28062: LD_INT 0
28064: PUSH
28065: LD_INT 1
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: PUSH
28072: LD_INT 1
28074: NEG
28075: PUSH
28076: LD_INT 0
28078: PUSH
28079: EMPTY
28080: LIST
28081: LIST
28082: PUSH
28083: LD_INT 1
28085: NEG
28086: PUSH
28087: LD_INT 1
28089: NEG
28090: PUSH
28091: EMPTY
28092: LIST
28093: LIST
28094: PUSH
28095: LD_INT 1
28097: PUSH
28098: LD_INT 1
28100: NEG
28101: PUSH
28102: EMPTY
28103: LIST
28104: LIST
28105: PUSH
28106: LD_INT 2
28108: PUSH
28109: LD_INT 0
28111: PUSH
28112: EMPTY
28113: LIST
28114: LIST
28115: PUSH
28116: LD_INT 2
28118: PUSH
28119: LD_INT 1
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 1
28128: NEG
28129: PUSH
28130: LD_INT 1
28132: PUSH
28133: EMPTY
28134: LIST
28135: LIST
28136: PUSH
28137: LD_INT 2
28139: NEG
28140: PUSH
28141: LD_INT 0
28143: PUSH
28144: EMPTY
28145: LIST
28146: LIST
28147: PUSH
28148: LD_INT 2
28150: NEG
28151: PUSH
28152: LD_INT 1
28154: NEG
28155: PUSH
28156: EMPTY
28157: LIST
28158: LIST
28159: PUSH
28160: LD_INT 2
28162: NEG
28163: PUSH
28164: LD_INT 1
28166: PUSH
28167: EMPTY
28168: LIST
28169: LIST
28170: PUSH
28171: LD_INT 3
28173: NEG
28174: PUSH
28175: LD_INT 0
28177: PUSH
28178: EMPTY
28179: LIST
28180: LIST
28181: PUSH
28182: LD_INT 3
28184: NEG
28185: PUSH
28186: LD_INT 1
28188: NEG
28189: PUSH
28190: EMPTY
28191: LIST
28192: LIST
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: LIST
28198: LIST
28199: LIST
28200: LIST
28201: LIST
28202: LIST
28203: LIST
28204: LIST
28205: LIST
28206: LIST
28207: LIST
28208: LIST
28209: LIST
28210: LIST
28211: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28212: LD_ADDR_VAR 0 13
28216: PUSH
28217: LD_INT 0
28219: PUSH
28220: LD_INT 0
28222: PUSH
28223: EMPTY
28224: LIST
28225: LIST
28226: PUSH
28227: LD_INT 0
28229: PUSH
28230: LD_INT 1
28232: NEG
28233: PUSH
28234: EMPTY
28235: LIST
28236: LIST
28237: PUSH
28238: LD_INT 1
28240: PUSH
28241: LD_INT 0
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PUSH
28248: LD_INT 1
28250: PUSH
28251: LD_INT 1
28253: PUSH
28254: EMPTY
28255: LIST
28256: LIST
28257: PUSH
28258: LD_INT 0
28260: PUSH
28261: LD_INT 1
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PUSH
28268: LD_INT 1
28270: NEG
28271: PUSH
28272: LD_INT 0
28274: PUSH
28275: EMPTY
28276: LIST
28277: LIST
28278: PUSH
28279: LD_INT 1
28281: NEG
28282: PUSH
28283: LD_INT 1
28285: NEG
28286: PUSH
28287: EMPTY
28288: LIST
28289: LIST
28290: PUSH
28291: LD_INT 1
28293: NEG
28294: PUSH
28295: LD_INT 2
28297: NEG
28298: PUSH
28299: EMPTY
28300: LIST
28301: LIST
28302: PUSH
28303: LD_INT 2
28305: PUSH
28306: LD_INT 1
28308: PUSH
28309: EMPTY
28310: LIST
28311: LIST
28312: PUSH
28313: LD_INT 2
28315: PUSH
28316: LD_INT 2
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PUSH
28323: LD_INT 1
28325: PUSH
28326: LD_INT 2
28328: PUSH
28329: EMPTY
28330: LIST
28331: LIST
28332: PUSH
28333: LD_INT 2
28335: NEG
28336: PUSH
28337: LD_INT 1
28339: NEG
28340: PUSH
28341: EMPTY
28342: LIST
28343: LIST
28344: PUSH
28345: LD_INT 2
28347: NEG
28348: PUSH
28349: LD_INT 2
28351: NEG
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: PUSH
28357: LD_INT 2
28359: NEG
28360: PUSH
28361: LD_INT 3
28363: NEG
28364: PUSH
28365: EMPTY
28366: LIST
28367: LIST
28368: PUSH
28369: LD_INT 3
28371: NEG
28372: PUSH
28373: LD_INT 2
28375: NEG
28376: PUSH
28377: EMPTY
28378: LIST
28379: LIST
28380: PUSH
28381: LD_INT 3
28383: NEG
28384: PUSH
28385: LD_INT 3
28387: NEG
28388: PUSH
28389: EMPTY
28390: LIST
28391: LIST
28392: PUSH
28393: EMPTY
28394: LIST
28395: LIST
28396: LIST
28397: LIST
28398: LIST
28399: LIST
28400: LIST
28401: LIST
28402: LIST
28403: LIST
28404: LIST
28405: LIST
28406: LIST
28407: LIST
28408: LIST
28409: LIST
28410: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28411: LD_ADDR_VAR 0 14
28415: PUSH
28416: LD_INT 0
28418: PUSH
28419: LD_INT 0
28421: PUSH
28422: EMPTY
28423: LIST
28424: LIST
28425: PUSH
28426: LD_INT 0
28428: PUSH
28429: LD_INT 1
28431: NEG
28432: PUSH
28433: EMPTY
28434: LIST
28435: LIST
28436: PUSH
28437: LD_INT 1
28439: PUSH
28440: LD_INT 0
28442: PUSH
28443: EMPTY
28444: LIST
28445: LIST
28446: PUSH
28447: LD_INT 1
28449: PUSH
28450: LD_INT 1
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: PUSH
28457: LD_INT 0
28459: PUSH
28460: LD_INT 1
28462: PUSH
28463: EMPTY
28464: LIST
28465: LIST
28466: PUSH
28467: LD_INT 1
28469: NEG
28470: PUSH
28471: LD_INT 0
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: LD_INT 1
28480: NEG
28481: PUSH
28482: LD_INT 1
28484: NEG
28485: PUSH
28486: EMPTY
28487: LIST
28488: LIST
28489: PUSH
28490: LD_INT 1
28492: NEG
28493: PUSH
28494: LD_INT 2
28496: NEG
28497: PUSH
28498: EMPTY
28499: LIST
28500: LIST
28501: PUSH
28502: LD_INT 0
28504: PUSH
28505: LD_INT 2
28507: NEG
28508: PUSH
28509: EMPTY
28510: LIST
28511: LIST
28512: PUSH
28513: LD_INT 1
28515: PUSH
28516: LD_INT 1
28518: NEG
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: PUSH
28524: LD_INT 1
28526: PUSH
28527: LD_INT 2
28529: PUSH
28530: EMPTY
28531: LIST
28532: LIST
28533: PUSH
28534: LD_INT 0
28536: PUSH
28537: LD_INT 2
28539: PUSH
28540: EMPTY
28541: LIST
28542: LIST
28543: PUSH
28544: LD_INT 1
28546: NEG
28547: PUSH
28548: LD_INT 1
28550: PUSH
28551: EMPTY
28552: LIST
28553: LIST
28554: PUSH
28555: LD_INT 1
28557: NEG
28558: PUSH
28559: LD_INT 3
28561: NEG
28562: PUSH
28563: EMPTY
28564: LIST
28565: LIST
28566: PUSH
28567: LD_INT 0
28569: PUSH
28570: LD_INT 3
28572: NEG
28573: PUSH
28574: EMPTY
28575: LIST
28576: LIST
28577: PUSH
28578: LD_INT 1
28580: PUSH
28581: LD_INT 2
28583: NEG
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: LIST
28593: LIST
28594: LIST
28595: LIST
28596: LIST
28597: LIST
28598: LIST
28599: LIST
28600: LIST
28601: LIST
28602: LIST
28603: LIST
28604: LIST
28605: LIST
28606: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28607: LD_ADDR_VAR 0 15
28611: PUSH
28612: LD_INT 0
28614: PUSH
28615: LD_INT 0
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: PUSH
28622: LD_INT 0
28624: PUSH
28625: LD_INT 1
28627: NEG
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: PUSH
28633: LD_INT 1
28635: PUSH
28636: LD_INT 0
28638: PUSH
28639: EMPTY
28640: LIST
28641: LIST
28642: PUSH
28643: LD_INT 1
28645: PUSH
28646: LD_INT 1
28648: PUSH
28649: EMPTY
28650: LIST
28651: LIST
28652: PUSH
28653: LD_INT 0
28655: PUSH
28656: LD_INT 1
28658: PUSH
28659: EMPTY
28660: LIST
28661: LIST
28662: PUSH
28663: LD_INT 1
28665: NEG
28666: PUSH
28667: LD_INT 0
28669: PUSH
28670: EMPTY
28671: LIST
28672: LIST
28673: PUSH
28674: LD_INT 1
28676: NEG
28677: PUSH
28678: LD_INT 1
28680: NEG
28681: PUSH
28682: EMPTY
28683: LIST
28684: LIST
28685: PUSH
28686: LD_INT 1
28688: PUSH
28689: LD_INT 1
28691: NEG
28692: PUSH
28693: EMPTY
28694: LIST
28695: LIST
28696: PUSH
28697: LD_INT 2
28699: PUSH
28700: LD_INT 0
28702: PUSH
28703: EMPTY
28704: LIST
28705: LIST
28706: PUSH
28707: LD_INT 2
28709: PUSH
28710: LD_INT 1
28712: PUSH
28713: EMPTY
28714: LIST
28715: LIST
28716: PUSH
28717: LD_INT 1
28719: NEG
28720: PUSH
28721: LD_INT 1
28723: PUSH
28724: EMPTY
28725: LIST
28726: LIST
28727: PUSH
28728: LD_INT 2
28730: NEG
28731: PUSH
28732: LD_INT 0
28734: PUSH
28735: EMPTY
28736: LIST
28737: LIST
28738: PUSH
28739: LD_INT 2
28741: NEG
28742: PUSH
28743: LD_INT 1
28745: NEG
28746: PUSH
28747: EMPTY
28748: LIST
28749: LIST
28750: PUSH
28751: LD_INT 2
28753: PUSH
28754: LD_INT 1
28756: NEG
28757: PUSH
28758: EMPTY
28759: LIST
28760: LIST
28761: PUSH
28762: LD_INT 3
28764: PUSH
28765: LD_INT 0
28767: PUSH
28768: EMPTY
28769: LIST
28770: LIST
28771: PUSH
28772: LD_INT 3
28774: PUSH
28775: LD_INT 1
28777: PUSH
28778: EMPTY
28779: LIST
28780: LIST
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: LIST
28786: LIST
28787: LIST
28788: LIST
28789: LIST
28790: LIST
28791: LIST
28792: LIST
28793: LIST
28794: LIST
28795: LIST
28796: LIST
28797: LIST
28798: LIST
28799: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28800: LD_ADDR_VAR 0 16
28804: PUSH
28805: LD_INT 0
28807: PUSH
28808: LD_INT 0
28810: PUSH
28811: EMPTY
28812: LIST
28813: LIST
28814: PUSH
28815: LD_INT 0
28817: PUSH
28818: LD_INT 1
28820: NEG
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: PUSH
28826: LD_INT 1
28828: PUSH
28829: LD_INT 0
28831: PUSH
28832: EMPTY
28833: LIST
28834: LIST
28835: PUSH
28836: LD_INT 1
28838: PUSH
28839: LD_INT 1
28841: PUSH
28842: EMPTY
28843: LIST
28844: LIST
28845: PUSH
28846: LD_INT 0
28848: PUSH
28849: LD_INT 1
28851: PUSH
28852: EMPTY
28853: LIST
28854: LIST
28855: PUSH
28856: LD_INT 1
28858: NEG
28859: PUSH
28860: LD_INT 0
28862: PUSH
28863: EMPTY
28864: LIST
28865: LIST
28866: PUSH
28867: LD_INT 1
28869: NEG
28870: PUSH
28871: LD_INT 1
28873: NEG
28874: PUSH
28875: EMPTY
28876: LIST
28877: LIST
28878: PUSH
28879: LD_INT 1
28881: NEG
28882: PUSH
28883: LD_INT 2
28885: NEG
28886: PUSH
28887: EMPTY
28888: LIST
28889: LIST
28890: PUSH
28891: LD_INT 2
28893: PUSH
28894: LD_INT 1
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: PUSH
28901: LD_INT 2
28903: PUSH
28904: LD_INT 2
28906: PUSH
28907: EMPTY
28908: LIST
28909: LIST
28910: PUSH
28911: LD_INT 1
28913: PUSH
28914: LD_INT 2
28916: PUSH
28917: EMPTY
28918: LIST
28919: LIST
28920: PUSH
28921: LD_INT 2
28923: NEG
28924: PUSH
28925: LD_INT 1
28927: NEG
28928: PUSH
28929: EMPTY
28930: LIST
28931: LIST
28932: PUSH
28933: LD_INT 2
28935: NEG
28936: PUSH
28937: LD_INT 2
28939: NEG
28940: PUSH
28941: EMPTY
28942: LIST
28943: LIST
28944: PUSH
28945: LD_INT 3
28947: PUSH
28948: LD_INT 2
28950: PUSH
28951: EMPTY
28952: LIST
28953: LIST
28954: PUSH
28955: LD_INT 3
28957: PUSH
28958: LD_INT 3
28960: PUSH
28961: EMPTY
28962: LIST
28963: LIST
28964: PUSH
28965: LD_INT 2
28967: PUSH
28968: LD_INT 3
28970: PUSH
28971: EMPTY
28972: LIST
28973: LIST
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: LIST
28979: LIST
28980: LIST
28981: LIST
28982: LIST
28983: LIST
28984: LIST
28985: LIST
28986: LIST
28987: LIST
28988: LIST
28989: LIST
28990: LIST
28991: LIST
28992: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28993: LD_ADDR_VAR 0 17
28997: PUSH
28998: LD_INT 0
29000: PUSH
29001: LD_INT 0
29003: PUSH
29004: EMPTY
29005: LIST
29006: LIST
29007: PUSH
29008: LD_INT 0
29010: PUSH
29011: LD_INT 1
29013: NEG
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: PUSH
29019: LD_INT 1
29021: PUSH
29022: LD_INT 0
29024: PUSH
29025: EMPTY
29026: LIST
29027: LIST
29028: PUSH
29029: LD_INT 1
29031: PUSH
29032: LD_INT 1
29034: PUSH
29035: EMPTY
29036: LIST
29037: LIST
29038: PUSH
29039: LD_INT 0
29041: PUSH
29042: LD_INT 1
29044: PUSH
29045: EMPTY
29046: LIST
29047: LIST
29048: PUSH
29049: LD_INT 1
29051: NEG
29052: PUSH
29053: LD_INT 0
29055: PUSH
29056: EMPTY
29057: LIST
29058: LIST
29059: PUSH
29060: LD_INT 1
29062: NEG
29063: PUSH
29064: LD_INT 1
29066: NEG
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 1
29074: NEG
29075: PUSH
29076: LD_INT 2
29078: NEG
29079: PUSH
29080: EMPTY
29081: LIST
29082: LIST
29083: PUSH
29084: LD_INT 0
29086: PUSH
29087: LD_INT 2
29089: NEG
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: PUSH
29095: LD_INT 1
29097: PUSH
29098: LD_INT 1
29100: NEG
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 2
29108: PUSH
29109: LD_INT 0
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: LD_INT 2
29118: PUSH
29119: LD_INT 1
29121: PUSH
29122: EMPTY
29123: LIST
29124: LIST
29125: PUSH
29126: LD_INT 2
29128: PUSH
29129: LD_INT 2
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: PUSH
29136: LD_INT 1
29138: PUSH
29139: LD_INT 2
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PUSH
29146: LD_INT 0
29148: PUSH
29149: LD_INT 2
29151: PUSH
29152: EMPTY
29153: LIST
29154: LIST
29155: PUSH
29156: LD_INT 1
29158: NEG
29159: PUSH
29160: LD_INT 1
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: PUSH
29167: LD_INT 2
29169: NEG
29170: PUSH
29171: LD_INT 0
29173: PUSH
29174: EMPTY
29175: LIST
29176: LIST
29177: PUSH
29178: LD_INT 2
29180: NEG
29181: PUSH
29182: LD_INT 1
29184: NEG
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: LD_INT 2
29192: NEG
29193: PUSH
29194: LD_INT 2
29196: NEG
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: LIST
29220: LIST
29221: LIST
29222: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29223: LD_ADDR_VAR 0 18
29227: PUSH
29228: LD_INT 0
29230: PUSH
29231: LD_INT 0
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 0
29240: PUSH
29241: LD_INT 1
29243: NEG
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: PUSH
29249: LD_INT 1
29251: PUSH
29252: LD_INT 0
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: PUSH
29259: LD_INT 1
29261: PUSH
29262: LD_INT 1
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 0
29271: PUSH
29272: LD_INT 1
29274: PUSH
29275: EMPTY
29276: LIST
29277: LIST
29278: PUSH
29279: LD_INT 1
29281: NEG
29282: PUSH
29283: LD_INT 0
29285: PUSH
29286: EMPTY
29287: LIST
29288: LIST
29289: PUSH
29290: LD_INT 1
29292: NEG
29293: PUSH
29294: LD_INT 1
29296: NEG
29297: PUSH
29298: EMPTY
29299: LIST
29300: LIST
29301: PUSH
29302: LD_INT 1
29304: NEG
29305: PUSH
29306: LD_INT 2
29308: NEG
29309: PUSH
29310: EMPTY
29311: LIST
29312: LIST
29313: PUSH
29314: LD_INT 0
29316: PUSH
29317: LD_INT 2
29319: NEG
29320: PUSH
29321: EMPTY
29322: LIST
29323: LIST
29324: PUSH
29325: LD_INT 1
29327: PUSH
29328: LD_INT 1
29330: NEG
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 2
29338: PUSH
29339: LD_INT 0
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: LD_INT 2
29348: PUSH
29349: LD_INT 1
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 2
29358: PUSH
29359: LD_INT 2
29361: PUSH
29362: EMPTY
29363: LIST
29364: LIST
29365: PUSH
29366: LD_INT 1
29368: PUSH
29369: LD_INT 2
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PUSH
29376: LD_INT 0
29378: PUSH
29379: LD_INT 2
29381: PUSH
29382: EMPTY
29383: LIST
29384: LIST
29385: PUSH
29386: LD_INT 1
29388: NEG
29389: PUSH
29390: LD_INT 1
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: PUSH
29397: LD_INT 2
29399: NEG
29400: PUSH
29401: LD_INT 0
29403: PUSH
29404: EMPTY
29405: LIST
29406: LIST
29407: PUSH
29408: LD_INT 2
29410: NEG
29411: PUSH
29412: LD_INT 1
29414: NEG
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 2
29422: NEG
29423: PUSH
29424: LD_INT 2
29426: NEG
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: LIST
29436: LIST
29437: LIST
29438: LIST
29439: LIST
29440: LIST
29441: LIST
29442: LIST
29443: LIST
29444: LIST
29445: LIST
29446: LIST
29447: LIST
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29453: LD_ADDR_VAR 0 19
29457: PUSH
29458: LD_INT 0
29460: PUSH
29461: LD_INT 0
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: PUSH
29468: LD_INT 0
29470: PUSH
29471: LD_INT 1
29473: NEG
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 1
29481: PUSH
29482: LD_INT 0
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: LD_INT 1
29491: PUSH
29492: LD_INT 1
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 0
29501: PUSH
29502: LD_INT 1
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: PUSH
29509: LD_INT 1
29511: NEG
29512: PUSH
29513: LD_INT 0
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: LD_INT 1
29522: NEG
29523: PUSH
29524: LD_INT 1
29526: NEG
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: LD_INT 1
29534: NEG
29535: PUSH
29536: LD_INT 2
29538: NEG
29539: PUSH
29540: EMPTY
29541: LIST
29542: LIST
29543: PUSH
29544: LD_INT 0
29546: PUSH
29547: LD_INT 2
29549: NEG
29550: PUSH
29551: EMPTY
29552: LIST
29553: LIST
29554: PUSH
29555: LD_INT 1
29557: PUSH
29558: LD_INT 1
29560: NEG
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 2
29568: PUSH
29569: LD_INT 0
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 2
29578: PUSH
29579: LD_INT 1
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 2
29588: PUSH
29589: LD_INT 2
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: LD_INT 1
29598: PUSH
29599: LD_INT 2
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: PUSH
29606: LD_INT 0
29608: PUSH
29609: LD_INT 2
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PUSH
29616: LD_INT 1
29618: NEG
29619: PUSH
29620: LD_INT 1
29622: PUSH
29623: EMPTY
29624: LIST
29625: LIST
29626: PUSH
29627: LD_INT 2
29629: NEG
29630: PUSH
29631: LD_INT 0
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: PUSH
29638: LD_INT 2
29640: NEG
29641: PUSH
29642: LD_INT 1
29644: NEG
29645: PUSH
29646: EMPTY
29647: LIST
29648: LIST
29649: PUSH
29650: LD_INT 2
29652: NEG
29653: PUSH
29654: LD_INT 2
29656: NEG
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PUSH
29662: EMPTY
29663: LIST
29664: LIST
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: LIST
29670: LIST
29671: LIST
29672: LIST
29673: LIST
29674: LIST
29675: LIST
29676: LIST
29677: LIST
29678: LIST
29679: LIST
29680: LIST
29681: LIST
29682: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29683: LD_ADDR_VAR 0 20
29687: PUSH
29688: LD_INT 0
29690: PUSH
29691: LD_INT 0
29693: PUSH
29694: EMPTY
29695: LIST
29696: LIST
29697: PUSH
29698: LD_INT 0
29700: PUSH
29701: LD_INT 1
29703: NEG
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 1
29711: PUSH
29712: LD_INT 0
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 1
29721: PUSH
29722: LD_INT 1
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: LD_INT 0
29731: PUSH
29732: LD_INT 1
29734: PUSH
29735: EMPTY
29736: LIST
29737: LIST
29738: PUSH
29739: LD_INT 1
29741: NEG
29742: PUSH
29743: LD_INT 0
29745: PUSH
29746: EMPTY
29747: LIST
29748: LIST
29749: PUSH
29750: LD_INT 1
29752: NEG
29753: PUSH
29754: LD_INT 1
29756: NEG
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 1
29764: NEG
29765: PUSH
29766: LD_INT 2
29768: NEG
29769: PUSH
29770: EMPTY
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 0
29776: PUSH
29777: LD_INT 2
29779: NEG
29780: PUSH
29781: EMPTY
29782: LIST
29783: LIST
29784: PUSH
29785: LD_INT 1
29787: PUSH
29788: LD_INT 1
29790: NEG
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 2
29798: PUSH
29799: LD_INT 0
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 2
29808: PUSH
29809: LD_INT 1
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 2
29818: PUSH
29819: LD_INT 2
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 1
29828: PUSH
29829: LD_INT 2
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 0
29838: PUSH
29839: LD_INT 2
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: PUSH
29846: LD_INT 1
29848: NEG
29849: PUSH
29850: LD_INT 1
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PUSH
29857: LD_INT 2
29859: NEG
29860: PUSH
29861: LD_INT 0
29863: PUSH
29864: EMPTY
29865: LIST
29866: LIST
29867: PUSH
29868: LD_INT 2
29870: NEG
29871: PUSH
29872: LD_INT 1
29874: NEG
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: PUSH
29880: LD_INT 2
29882: NEG
29883: PUSH
29884: LD_INT 2
29886: NEG
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: EMPTY
29893: LIST
29894: LIST
29895: LIST
29896: LIST
29897: LIST
29898: LIST
29899: LIST
29900: LIST
29901: LIST
29902: LIST
29903: LIST
29904: LIST
29905: LIST
29906: LIST
29907: LIST
29908: LIST
29909: LIST
29910: LIST
29911: LIST
29912: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29913: LD_ADDR_VAR 0 21
29917: PUSH
29918: LD_INT 0
29920: PUSH
29921: LD_INT 0
29923: PUSH
29924: EMPTY
29925: LIST
29926: LIST
29927: PUSH
29928: LD_INT 0
29930: PUSH
29931: LD_INT 1
29933: NEG
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PUSH
29939: LD_INT 1
29941: PUSH
29942: LD_INT 0
29944: PUSH
29945: EMPTY
29946: LIST
29947: LIST
29948: PUSH
29949: LD_INT 1
29951: PUSH
29952: LD_INT 1
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PUSH
29959: LD_INT 0
29961: PUSH
29962: LD_INT 1
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: LD_INT 1
29971: NEG
29972: PUSH
29973: LD_INT 0
29975: PUSH
29976: EMPTY
29977: LIST
29978: LIST
29979: PUSH
29980: LD_INT 1
29982: NEG
29983: PUSH
29984: LD_INT 1
29986: NEG
29987: PUSH
29988: EMPTY
29989: LIST
29990: LIST
29991: PUSH
29992: LD_INT 1
29994: NEG
29995: PUSH
29996: LD_INT 2
29998: NEG
29999: PUSH
30000: EMPTY
30001: LIST
30002: LIST
30003: PUSH
30004: LD_INT 0
30006: PUSH
30007: LD_INT 2
30009: NEG
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: PUSH
30015: LD_INT 1
30017: PUSH
30018: LD_INT 1
30020: NEG
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: LD_INT 2
30028: PUSH
30029: LD_INT 0
30031: PUSH
30032: EMPTY
30033: LIST
30034: LIST
30035: PUSH
30036: LD_INT 2
30038: PUSH
30039: LD_INT 1
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: PUSH
30046: LD_INT 2
30048: PUSH
30049: LD_INT 2
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: PUSH
30056: LD_INT 1
30058: PUSH
30059: LD_INT 2
30061: PUSH
30062: EMPTY
30063: LIST
30064: LIST
30065: PUSH
30066: LD_INT 0
30068: PUSH
30069: LD_INT 2
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: LD_INT 1
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: PUSH
30087: LD_INT 2
30089: NEG
30090: PUSH
30091: LD_INT 0
30093: PUSH
30094: EMPTY
30095: LIST
30096: LIST
30097: PUSH
30098: LD_INT 2
30100: NEG
30101: PUSH
30102: LD_INT 1
30104: NEG
30105: PUSH
30106: EMPTY
30107: LIST
30108: LIST
30109: PUSH
30110: LD_INT 2
30112: NEG
30113: PUSH
30114: LD_INT 2
30116: NEG
30117: PUSH
30118: EMPTY
30119: LIST
30120: LIST
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: LIST
30126: LIST
30127: LIST
30128: LIST
30129: LIST
30130: LIST
30131: LIST
30132: LIST
30133: LIST
30134: LIST
30135: LIST
30136: LIST
30137: LIST
30138: LIST
30139: LIST
30140: LIST
30141: LIST
30142: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30143: LD_ADDR_VAR 0 22
30147: PUSH
30148: LD_INT 0
30150: PUSH
30151: LD_INT 0
30153: PUSH
30154: EMPTY
30155: LIST
30156: LIST
30157: PUSH
30158: LD_INT 0
30160: PUSH
30161: LD_INT 1
30163: NEG
30164: PUSH
30165: EMPTY
30166: LIST
30167: LIST
30168: PUSH
30169: LD_INT 1
30171: PUSH
30172: LD_INT 0
30174: PUSH
30175: EMPTY
30176: LIST
30177: LIST
30178: PUSH
30179: LD_INT 1
30181: PUSH
30182: LD_INT 1
30184: PUSH
30185: EMPTY
30186: LIST
30187: LIST
30188: PUSH
30189: LD_INT 0
30191: PUSH
30192: LD_INT 1
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: PUSH
30199: LD_INT 1
30201: NEG
30202: PUSH
30203: LD_INT 0
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 1
30212: NEG
30213: PUSH
30214: LD_INT 1
30216: NEG
30217: PUSH
30218: EMPTY
30219: LIST
30220: LIST
30221: PUSH
30222: LD_INT 1
30224: NEG
30225: PUSH
30226: LD_INT 2
30228: NEG
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: PUSH
30234: LD_INT 0
30236: PUSH
30237: LD_INT 2
30239: NEG
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 1
30247: PUSH
30248: LD_INT 1
30250: NEG
30251: PUSH
30252: EMPTY
30253: LIST
30254: LIST
30255: PUSH
30256: LD_INT 2
30258: PUSH
30259: LD_INT 0
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: LD_INT 2
30268: PUSH
30269: LD_INT 1
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 2
30278: PUSH
30279: LD_INT 2
30281: PUSH
30282: EMPTY
30283: LIST
30284: LIST
30285: PUSH
30286: LD_INT 1
30288: PUSH
30289: LD_INT 2
30291: PUSH
30292: EMPTY
30293: LIST
30294: LIST
30295: PUSH
30296: LD_INT 0
30298: PUSH
30299: LD_INT 2
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: PUSH
30306: LD_INT 1
30308: NEG
30309: PUSH
30310: LD_INT 1
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: PUSH
30317: LD_INT 2
30319: NEG
30320: PUSH
30321: LD_INT 0
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: PUSH
30328: LD_INT 2
30330: NEG
30331: PUSH
30332: LD_INT 1
30334: NEG
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PUSH
30340: LD_INT 2
30342: NEG
30343: PUSH
30344: LD_INT 2
30346: NEG
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: LIST
30368: LIST
30369: LIST
30370: LIST
30371: LIST
30372: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30373: LD_ADDR_VAR 0 23
30377: PUSH
30378: LD_INT 0
30380: PUSH
30381: LD_INT 0
30383: PUSH
30384: EMPTY
30385: LIST
30386: LIST
30387: PUSH
30388: LD_INT 0
30390: PUSH
30391: LD_INT 1
30393: NEG
30394: PUSH
30395: EMPTY
30396: LIST
30397: LIST
30398: PUSH
30399: LD_INT 1
30401: PUSH
30402: LD_INT 0
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: LD_INT 1
30411: PUSH
30412: LD_INT 1
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 0
30421: PUSH
30422: LD_INT 1
30424: PUSH
30425: EMPTY
30426: LIST
30427: LIST
30428: PUSH
30429: LD_INT 1
30431: NEG
30432: PUSH
30433: LD_INT 0
30435: PUSH
30436: EMPTY
30437: LIST
30438: LIST
30439: PUSH
30440: LD_INT 1
30442: NEG
30443: PUSH
30444: LD_INT 1
30446: NEG
30447: PUSH
30448: EMPTY
30449: LIST
30450: LIST
30451: PUSH
30452: LD_INT 1
30454: NEG
30455: PUSH
30456: LD_INT 2
30458: NEG
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: PUSH
30464: LD_INT 0
30466: PUSH
30467: LD_INT 2
30469: NEG
30470: PUSH
30471: EMPTY
30472: LIST
30473: LIST
30474: PUSH
30475: LD_INT 1
30477: PUSH
30478: LD_INT 1
30480: NEG
30481: PUSH
30482: EMPTY
30483: LIST
30484: LIST
30485: PUSH
30486: LD_INT 2
30488: PUSH
30489: LD_INT 0
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: PUSH
30496: LD_INT 2
30498: PUSH
30499: LD_INT 1
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 2
30508: PUSH
30509: LD_INT 2
30511: PUSH
30512: EMPTY
30513: LIST
30514: LIST
30515: PUSH
30516: LD_INT 1
30518: PUSH
30519: LD_INT 2
30521: PUSH
30522: EMPTY
30523: LIST
30524: LIST
30525: PUSH
30526: LD_INT 0
30528: PUSH
30529: LD_INT 2
30531: PUSH
30532: EMPTY
30533: LIST
30534: LIST
30535: PUSH
30536: LD_INT 1
30538: NEG
30539: PUSH
30540: LD_INT 1
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: LD_INT 2
30549: NEG
30550: PUSH
30551: LD_INT 0
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: LD_INT 2
30560: NEG
30561: PUSH
30562: LD_INT 1
30564: NEG
30565: PUSH
30566: EMPTY
30567: LIST
30568: LIST
30569: PUSH
30570: LD_INT 2
30572: NEG
30573: PUSH
30574: LD_INT 2
30576: NEG
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 2
30584: NEG
30585: PUSH
30586: LD_INT 3
30588: NEG
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 1
30596: NEG
30597: PUSH
30598: LD_INT 3
30600: NEG
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 1
30608: PUSH
30609: LD_INT 2
30611: NEG
30612: PUSH
30613: EMPTY
30614: LIST
30615: LIST
30616: PUSH
30617: LD_INT 2
30619: PUSH
30620: LD_INT 1
30622: NEG
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: EMPTY
30629: LIST
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: LIST
30635: LIST
30636: LIST
30637: LIST
30638: LIST
30639: LIST
30640: LIST
30641: LIST
30642: LIST
30643: LIST
30644: LIST
30645: LIST
30646: LIST
30647: LIST
30648: LIST
30649: LIST
30650: LIST
30651: LIST
30652: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
30653: LD_ADDR_VAR 0 24
30657: PUSH
30658: LD_INT 0
30660: PUSH
30661: LD_INT 0
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: PUSH
30668: LD_INT 0
30670: PUSH
30671: LD_INT 1
30673: NEG
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: PUSH
30679: LD_INT 1
30681: PUSH
30682: LD_INT 0
30684: PUSH
30685: EMPTY
30686: LIST
30687: LIST
30688: PUSH
30689: LD_INT 1
30691: PUSH
30692: LD_INT 1
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: LD_INT 0
30701: PUSH
30702: LD_INT 1
30704: PUSH
30705: EMPTY
30706: LIST
30707: LIST
30708: PUSH
30709: LD_INT 1
30711: NEG
30712: PUSH
30713: LD_INT 0
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: PUSH
30720: LD_INT 1
30722: NEG
30723: PUSH
30724: LD_INT 1
30726: NEG
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 1
30734: NEG
30735: PUSH
30736: LD_INT 2
30738: NEG
30739: PUSH
30740: EMPTY
30741: LIST
30742: LIST
30743: PUSH
30744: LD_INT 0
30746: PUSH
30747: LD_INT 2
30749: NEG
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: LD_INT 1
30757: PUSH
30758: LD_INT 1
30760: NEG
30761: PUSH
30762: EMPTY
30763: LIST
30764: LIST
30765: PUSH
30766: LD_INT 2
30768: PUSH
30769: LD_INT 0
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: PUSH
30776: LD_INT 2
30778: PUSH
30779: LD_INT 1
30781: PUSH
30782: EMPTY
30783: LIST
30784: LIST
30785: PUSH
30786: LD_INT 2
30788: PUSH
30789: LD_INT 2
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 1
30798: PUSH
30799: LD_INT 2
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: PUSH
30806: LD_INT 0
30808: PUSH
30809: LD_INT 2
30811: PUSH
30812: EMPTY
30813: LIST
30814: LIST
30815: PUSH
30816: LD_INT 1
30818: NEG
30819: PUSH
30820: LD_INT 1
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: LD_INT 2
30829: NEG
30830: PUSH
30831: LD_INT 0
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: LD_INT 2
30840: NEG
30841: PUSH
30842: LD_INT 1
30844: NEG
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 2
30852: NEG
30853: PUSH
30854: LD_INT 2
30856: NEG
30857: PUSH
30858: EMPTY
30859: LIST
30860: LIST
30861: PUSH
30862: LD_INT 1
30864: PUSH
30865: LD_INT 2
30867: NEG
30868: PUSH
30869: EMPTY
30870: LIST
30871: LIST
30872: PUSH
30873: LD_INT 2
30875: PUSH
30876: LD_INT 1
30878: NEG
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: PUSH
30884: LD_INT 3
30886: PUSH
30887: LD_INT 1
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: LD_INT 3
30896: PUSH
30897: LD_INT 2
30899: PUSH
30900: EMPTY
30901: LIST
30902: LIST
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: LIST
30908: LIST
30909: LIST
30910: LIST
30911: LIST
30912: LIST
30913: LIST
30914: LIST
30915: LIST
30916: LIST
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: LIST
30922: LIST
30923: LIST
30924: LIST
30925: LIST
30926: LIST
30927: LIST
30928: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30929: LD_ADDR_VAR 0 25
30933: PUSH
30934: LD_INT 0
30936: PUSH
30937: LD_INT 0
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: LD_INT 0
30946: PUSH
30947: LD_INT 1
30949: NEG
30950: PUSH
30951: EMPTY
30952: LIST
30953: LIST
30954: PUSH
30955: LD_INT 1
30957: PUSH
30958: LD_INT 0
30960: PUSH
30961: EMPTY
30962: LIST
30963: LIST
30964: PUSH
30965: LD_INT 1
30967: PUSH
30968: LD_INT 1
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 0
30977: PUSH
30978: LD_INT 1
30980: PUSH
30981: EMPTY
30982: LIST
30983: LIST
30984: PUSH
30985: LD_INT 1
30987: NEG
30988: PUSH
30989: LD_INT 0
30991: PUSH
30992: EMPTY
30993: LIST
30994: LIST
30995: PUSH
30996: LD_INT 1
30998: NEG
30999: PUSH
31000: LD_INT 1
31002: NEG
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: PUSH
31008: LD_INT 1
31010: NEG
31011: PUSH
31012: LD_INT 2
31014: NEG
31015: PUSH
31016: EMPTY
31017: LIST
31018: LIST
31019: PUSH
31020: LD_INT 0
31022: PUSH
31023: LD_INT 2
31025: NEG
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: LD_INT 1
31036: NEG
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PUSH
31042: LD_INT 2
31044: PUSH
31045: LD_INT 0
31047: PUSH
31048: EMPTY
31049: LIST
31050: LIST
31051: PUSH
31052: LD_INT 2
31054: PUSH
31055: LD_INT 1
31057: PUSH
31058: EMPTY
31059: LIST
31060: LIST
31061: PUSH
31062: LD_INT 2
31064: PUSH
31065: LD_INT 2
31067: PUSH
31068: EMPTY
31069: LIST
31070: LIST
31071: PUSH
31072: LD_INT 1
31074: PUSH
31075: LD_INT 2
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PUSH
31082: LD_INT 0
31084: PUSH
31085: LD_INT 2
31087: PUSH
31088: EMPTY
31089: LIST
31090: LIST
31091: PUSH
31092: LD_INT 1
31094: NEG
31095: PUSH
31096: LD_INT 1
31098: PUSH
31099: EMPTY
31100: LIST
31101: LIST
31102: PUSH
31103: LD_INT 2
31105: NEG
31106: PUSH
31107: LD_INT 0
31109: PUSH
31110: EMPTY
31111: LIST
31112: LIST
31113: PUSH
31114: LD_INT 2
31116: NEG
31117: PUSH
31118: LD_INT 1
31120: NEG
31121: PUSH
31122: EMPTY
31123: LIST
31124: LIST
31125: PUSH
31126: LD_INT 2
31128: NEG
31129: PUSH
31130: LD_INT 2
31132: NEG
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: LD_INT 3
31140: PUSH
31141: LD_INT 1
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 3
31150: PUSH
31151: LD_INT 2
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PUSH
31158: LD_INT 2
31160: PUSH
31161: LD_INT 3
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: PUSH
31168: LD_INT 1
31170: PUSH
31171: LD_INT 3
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: LIST
31182: LIST
31183: LIST
31184: LIST
31185: LIST
31186: LIST
31187: LIST
31188: LIST
31189: LIST
31190: LIST
31191: LIST
31192: LIST
31193: LIST
31194: LIST
31195: LIST
31196: LIST
31197: LIST
31198: LIST
31199: LIST
31200: LIST
31201: LIST
31202: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31203: LD_ADDR_VAR 0 26
31207: PUSH
31208: LD_INT 0
31210: PUSH
31211: LD_INT 0
31213: PUSH
31214: EMPTY
31215: LIST
31216: LIST
31217: PUSH
31218: LD_INT 0
31220: PUSH
31221: LD_INT 1
31223: NEG
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 1
31231: PUSH
31232: LD_INT 0
31234: PUSH
31235: EMPTY
31236: LIST
31237: LIST
31238: PUSH
31239: LD_INT 1
31241: PUSH
31242: LD_INT 1
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: PUSH
31249: LD_INT 0
31251: PUSH
31252: LD_INT 1
31254: PUSH
31255: EMPTY
31256: LIST
31257: LIST
31258: PUSH
31259: LD_INT 1
31261: NEG
31262: PUSH
31263: LD_INT 0
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: PUSH
31270: LD_INT 1
31272: NEG
31273: PUSH
31274: LD_INT 1
31276: NEG
31277: PUSH
31278: EMPTY
31279: LIST
31280: LIST
31281: PUSH
31282: LD_INT 1
31284: NEG
31285: PUSH
31286: LD_INT 2
31288: NEG
31289: PUSH
31290: EMPTY
31291: LIST
31292: LIST
31293: PUSH
31294: LD_INT 0
31296: PUSH
31297: LD_INT 2
31299: NEG
31300: PUSH
31301: EMPTY
31302: LIST
31303: LIST
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: LD_INT 1
31310: NEG
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: PUSH
31316: LD_INT 2
31318: PUSH
31319: LD_INT 0
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: LD_INT 2
31328: PUSH
31329: LD_INT 1
31331: PUSH
31332: EMPTY
31333: LIST
31334: LIST
31335: PUSH
31336: LD_INT 2
31338: PUSH
31339: LD_INT 2
31341: PUSH
31342: EMPTY
31343: LIST
31344: LIST
31345: PUSH
31346: LD_INT 1
31348: PUSH
31349: LD_INT 2
31351: PUSH
31352: EMPTY
31353: LIST
31354: LIST
31355: PUSH
31356: LD_INT 0
31358: PUSH
31359: LD_INT 2
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: LD_INT 1
31368: NEG
31369: PUSH
31370: LD_INT 1
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: PUSH
31377: LD_INT 2
31379: NEG
31380: PUSH
31381: LD_INT 0
31383: PUSH
31384: EMPTY
31385: LIST
31386: LIST
31387: PUSH
31388: LD_INT 2
31390: NEG
31391: PUSH
31392: LD_INT 1
31394: NEG
31395: PUSH
31396: EMPTY
31397: LIST
31398: LIST
31399: PUSH
31400: LD_INT 2
31402: NEG
31403: PUSH
31404: LD_INT 2
31406: NEG
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 2
31414: PUSH
31415: LD_INT 3
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 1
31424: PUSH
31425: LD_INT 3
31427: PUSH
31428: EMPTY
31429: LIST
31430: LIST
31431: PUSH
31432: LD_INT 1
31434: NEG
31435: PUSH
31436: LD_INT 2
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 2
31445: NEG
31446: PUSH
31447: LD_INT 1
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: LIST
31458: LIST
31459: LIST
31460: LIST
31461: LIST
31462: LIST
31463: LIST
31464: LIST
31465: LIST
31466: LIST
31467: LIST
31468: LIST
31469: LIST
31470: LIST
31471: LIST
31472: LIST
31473: LIST
31474: LIST
31475: LIST
31476: LIST
31477: LIST
31478: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31479: LD_ADDR_VAR 0 27
31483: PUSH
31484: LD_INT 0
31486: PUSH
31487: LD_INT 0
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 0
31496: PUSH
31497: LD_INT 1
31499: NEG
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 1
31507: PUSH
31508: LD_INT 0
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: PUSH
31515: LD_INT 1
31517: PUSH
31518: LD_INT 1
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 0
31527: PUSH
31528: LD_INT 1
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: PUSH
31535: LD_INT 1
31537: NEG
31538: PUSH
31539: LD_INT 0
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: PUSH
31546: LD_INT 1
31548: NEG
31549: PUSH
31550: LD_INT 1
31552: NEG
31553: PUSH
31554: EMPTY
31555: LIST
31556: LIST
31557: PUSH
31558: LD_INT 1
31560: NEG
31561: PUSH
31562: LD_INT 2
31564: NEG
31565: PUSH
31566: EMPTY
31567: LIST
31568: LIST
31569: PUSH
31570: LD_INT 0
31572: PUSH
31573: LD_INT 2
31575: NEG
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 1
31583: PUSH
31584: LD_INT 1
31586: NEG
31587: PUSH
31588: EMPTY
31589: LIST
31590: LIST
31591: PUSH
31592: LD_INT 2
31594: PUSH
31595: LD_INT 0
31597: PUSH
31598: EMPTY
31599: LIST
31600: LIST
31601: PUSH
31602: LD_INT 2
31604: PUSH
31605: LD_INT 1
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: LD_INT 2
31614: PUSH
31615: LD_INT 2
31617: PUSH
31618: EMPTY
31619: LIST
31620: LIST
31621: PUSH
31622: LD_INT 1
31624: PUSH
31625: LD_INT 2
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 0
31634: PUSH
31635: LD_INT 2
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: LD_INT 1
31644: NEG
31645: PUSH
31646: LD_INT 1
31648: PUSH
31649: EMPTY
31650: LIST
31651: LIST
31652: PUSH
31653: LD_INT 2
31655: NEG
31656: PUSH
31657: LD_INT 0
31659: PUSH
31660: EMPTY
31661: LIST
31662: LIST
31663: PUSH
31664: LD_INT 2
31666: NEG
31667: PUSH
31668: LD_INT 1
31670: NEG
31671: PUSH
31672: EMPTY
31673: LIST
31674: LIST
31675: PUSH
31676: LD_INT 2
31678: NEG
31679: PUSH
31680: LD_INT 2
31682: NEG
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 1
31690: NEG
31691: PUSH
31692: LD_INT 2
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 2
31701: NEG
31702: PUSH
31703: LD_INT 1
31705: PUSH
31706: EMPTY
31707: LIST
31708: LIST
31709: PUSH
31710: LD_INT 3
31712: NEG
31713: PUSH
31714: LD_INT 1
31716: NEG
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: LD_INT 3
31724: NEG
31725: PUSH
31726: LD_INT 2
31728: NEG
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PUSH
31734: EMPTY
31735: LIST
31736: LIST
31737: LIST
31738: LIST
31739: LIST
31740: LIST
31741: LIST
31742: LIST
31743: LIST
31744: LIST
31745: LIST
31746: LIST
31747: LIST
31748: LIST
31749: LIST
31750: LIST
31751: LIST
31752: LIST
31753: LIST
31754: LIST
31755: LIST
31756: LIST
31757: LIST
31758: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31759: LD_ADDR_VAR 0 28
31763: PUSH
31764: LD_INT 0
31766: PUSH
31767: LD_INT 0
31769: PUSH
31770: EMPTY
31771: LIST
31772: LIST
31773: PUSH
31774: LD_INT 0
31776: PUSH
31777: LD_INT 1
31779: NEG
31780: PUSH
31781: EMPTY
31782: LIST
31783: LIST
31784: PUSH
31785: LD_INT 1
31787: PUSH
31788: LD_INT 0
31790: PUSH
31791: EMPTY
31792: LIST
31793: LIST
31794: PUSH
31795: LD_INT 1
31797: PUSH
31798: LD_INT 1
31800: PUSH
31801: EMPTY
31802: LIST
31803: LIST
31804: PUSH
31805: LD_INT 0
31807: PUSH
31808: LD_INT 1
31810: PUSH
31811: EMPTY
31812: LIST
31813: LIST
31814: PUSH
31815: LD_INT 1
31817: NEG
31818: PUSH
31819: LD_INT 0
31821: PUSH
31822: EMPTY
31823: LIST
31824: LIST
31825: PUSH
31826: LD_INT 1
31828: NEG
31829: PUSH
31830: LD_INT 1
31832: NEG
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: PUSH
31838: LD_INT 1
31840: NEG
31841: PUSH
31842: LD_INT 2
31844: NEG
31845: PUSH
31846: EMPTY
31847: LIST
31848: LIST
31849: PUSH
31850: LD_INT 0
31852: PUSH
31853: LD_INT 2
31855: NEG
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: PUSH
31861: LD_INT 1
31863: PUSH
31864: LD_INT 1
31866: NEG
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 2
31874: PUSH
31875: LD_INT 0
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 2
31884: PUSH
31885: LD_INT 1
31887: PUSH
31888: EMPTY
31889: LIST
31890: LIST
31891: PUSH
31892: LD_INT 2
31894: PUSH
31895: LD_INT 2
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 1
31904: PUSH
31905: LD_INT 2
31907: PUSH
31908: EMPTY
31909: LIST
31910: LIST
31911: PUSH
31912: LD_INT 0
31914: PUSH
31915: LD_INT 2
31917: PUSH
31918: EMPTY
31919: LIST
31920: LIST
31921: PUSH
31922: LD_INT 1
31924: NEG
31925: PUSH
31926: LD_INT 1
31928: PUSH
31929: EMPTY
31930: LIST
31931: LIST
31932: PUSH
31933: LD_INT 2
31935: NEG
31936: PUSH
31937: LD_INT 0
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: PUSH
31944: LD_INT 2
31946: NEG
31947: PUSH
31948: LD_INT 1
31950: NEG
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 2
31958: NEG
31959: PUSH
31960: LD_INT 2
31962: NEG
31963: PUSH
31964: EMPTY
31965: LIST
31966: LIST
31967: PUSH
31968: LD_INT 2
31970: NEG
31971: PUSH
31972: LD_INT 3
31974: NEG
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: PUSH
31980: LD_INT 1
31982: NEG
31983: PUSH
31984: LD_INT 3
31986: NEG
31987: PUSH
31988: EMPTY
31989: LIST
31990: LIST
31991: PUSH
31992: LD_INT 3
31994: NEG
31995: PUSH
31996: LD_INT 1
31998: NEG
31999: PUSH
32000: EMPTY
32001: LIST
32002: LIST
32003: PUSH
32004: LD_INT 3
32006: NEG
32007: PUSH
32008: LD_INT 2
32010: NEG
32011: PUSH
32012: EMPTY
32013: LIST
32014: LIST
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: LIST
32020: LIST
32021: LIST
32022: LIST
32023: LIST
32024: LIST
32025: LIST
32026: LIST
32027: LIST
32028: LIST
32029: LIST
32030: LIST
32031: LIST
32032: LIST
32033: LIST
32034: LIST
32035: LIST
32036: LIST
32037: LIST
32038: LIST
32039: LIST
32040: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32041: LD_ADDR_VAR 0 29
32045: PUSH
32046: LD_INT 0
32048: PUSH
32049: LD_INT 0
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 0
32058: PUSH
32059: LD_INT 1
32061: NEG
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 1
32069: PUSH
32070: LD_INT 0
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 1
32079: PUSH
32080: LD_INT 1
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 0
32089: PUSH
32090: LD_INT 1
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: LD_INT 1
32099: NEG
32100: PUSH
32101: LD_INT 0
32103: PUSH
32104: EMPTY
32105: LIST
32106: LIST
32107: PUSH
32108: LD_INT 1
32110: NEG
32111: PUSH
32112: LD_INT 1
32114: NEG
32115: PUSH
32116: EMPTY
32117: LIST
32118: LIST
32119: PUSH
32120: LD_INT 1
32122: NEG
32123: PUSH
32124: LD_INT 2
32126: NEG
32127: PUSH
32128: EMPTY
32129: LIST
32130: LIST
32131: PUSH
32132: LD_INT 0
32134: PUSH
32135: LD_INT 2
32137: NEG
32138: PUSH
32139: EMPTY
32140: LIST
32141: LIST
32142: PUSH
32143: LD_INT 1
32145: PUSH
32146: LD_INT 1
32148: NEG
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: LD_INT 2
32156: PUSH
32157: LD_INT 0
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: LD_INT 2
32166: PUSH
32167: LD_INT 1
32169: PUSH
32170: EMPTY
32171: LIST
32172: LIST
32173: PUSH
32174: LD_INT 1
32176: PUSH
32177: LD_INT 2
32179: PUSH
32180: EMPTY
32181: LIST
32182: LIST
32183: PUSH
32184: LD_INT 0
32186: PUSH
32187: LD_INT 2
32189: PUSH
32190: EMPTY
32191: LIST
32192: LIST
32193: PUSH
32194: LD_INT 1
32196: NEG
32197: PUSH
32198: LD_INT 1
32200: PUSH
32201: EMPTY
32202: LIST
32203: LIST
32204: PUSH
32205: LD_INT 2
32207: NEG
32208: PUSH
32209: LD_INT 1
32211: NEG
32212: PUSH
32213: EMPTY
32214: LIST
32215: LIST
32216: PUSH
32217: LD_INT 2
32219: NEG
32220: PUSH
32221: LD_INT 2
32223: NEG
32224: PUSH
32225: EMPTY
32226: LIST
32227: LIST
32228: PUSH
32229: LD_INT 2
32231: NEG
32232: PUSH
32233: LD_INT 3
32235: NEG
32236: PUSH
32237: EMPTY
32238: LIST
32239: LIST
32240: PUSH
32241: LD_INT 2
32243: PUSH
32244: LD_INT 1
32246: NEG
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 3
32254: PUSH
32255: LD_INT 1
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 1
32264: PUSH
32265: LD_INT 3
32267: PUSH
32268: EMPTY
32269: LIST
32270: LIST
32271: PUSH
32272: LD_INT 1
32274: NEG
32275: PUSH
32276: LD_INT 2
32278: PUSH
32279: EMPTY
32280: LIST
32281: LIST
32282: PUSH
32283: LD_INT 3
32285: NEG
32286: PUSH
32287: LD_INT 2
32289: NEG
32290: PUSH
32291: EMPTY
32292: LIST
32293: LIST
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: LIST
32303: LIST
32304: LIST
32305: LIST
32306: LIST
32307: LIST
32308: LIST
32309: LIST
32310: LIST
32311: LIST
32312: LIST
32313: LIST
32314: LIST
32315: LIST
32316: LIST
32317: LIST
32318: LIST
32319: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32320: LD_ADDR_VAR 0 30
32324: PUSH
32325: LD_INT 0
32327: PUSH
32328: LD_INT 0
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: PUSH
32335: LD_INT 0
32337: PUSH
32338: LD_INT 1
32340: NEG
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PUSH
32346: LD_INT 1
32348: PUSH
32349: LD_INT 0
32351: PUSH
32352: EMPTY
32353: LIST
32354: LIST
32355: PUSH
32356: LD_INT 1
32358: PUSH
32359: LD_INT 1
32361: PUSH
32362: EMPTY
32363: LIST
32364: LIST
32365: PUSH
32366: LD_INT 0
32368: PUSH
32369: LD_INT 1
32371: PUSH
32372: EMPTY
32373: LIST
32374: LIST
32375: PUSH
32376: LD_INT 1
32378: NEG
32379: PUSH
32380: LD_INT 0
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: LD_INT 1
32389: NEG
32390: PUSH
32391: LD_INT 1
32393: NEG
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: PUSH
32399: LD_INT 1
32401: NEG
32402: PUSH
32403: LD_INT 2
32405: NEG
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PUSH
32411: LD_INT 0
32413: PUSH
32414: LD_INT 2
32416: NEG
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: LD_INT 1
32424: PUSH
32425: LD_INT 1
32427: NEG
32428: PUSH
32429: EMPTY
32430: LIST
32431: LIST
32432: PUSH
32433: LD_INT 2
32435: PUSH
32436: LD_INT 0
32438: PUSH
32439: EMPTY
32440: LIST
32441: LIST
32442: PUSH
32443: LD_INT 2
32445: PUSH
32446: LD_INT 1
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PUSH
32453: LD_INT 2
32455: PUSH
32456: LD_INT 2
32458: PUSH
32459: EMPTY
32460: LIST
32461: LIST
32462: PUSH
32463: LD_INT 1
32465: PUSH
32466: LD_INT 2
32468: PUSH
32469: EMPTY
32470: LIST
32471: LIST
32472: PUSH
32473: LD_INT 1
32475: NEG
32476: PUSH
32477: LD_INT 1
32479: PUSH
32480: EMPTY
32481: LIST
32482: LIST
32483: PUSH
32484: LD_INT 2
32486: NEG
32487: PUSH
32488: LD_INT 0
32490: PUSH
32491: EMPTY
32492: LIST
32493: LIST
32494: PUSH
32495: LD_INT 2
32497: NEG
32498: PUSH
32499: LD_INT 1
32501: NEG
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 1
32509: NEG
32510: PUSH
32511: LD_INT 3
32513: NEG
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: PUSH
32522: LD_INT 2
32524: NEG
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 3
32532: PUSH
32533: LD_INT 2
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: LD_INT 2
32542: PUSH
32543: LD_INT 3
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: LD_INT 2
32552: NEG
32553: PUSH
32554: LD_INT 1
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PUSH
32561: LD_INT 3
32563: NEG
32564: PUSH
32565: LD_INT 1
32567: NEG
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: LIST
32577: LIST
32578: LIST
32579: LIST
32580: LIST
32581: LIST
32582: LIST
32583: LIST
32584: LIST
32585: LIST
32586: LIST
32587: LIST
32588: LIST
32589: LIST
32590: LIST
32591: LIST
32592: LIST
32593: LIST
32594: LIST
32595: LIST
32596: LIST
32597: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32598: LD_ADDR_VAR 0 31
32602: PUSH
32603: LD_INT 0
32605: PUSH
32606: LD_INT 0
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: LD_INT 0
32615: PUSH
32616: LD_INT 1
32618: NEG
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 1
32626: PUSH
32627: LD_INT 0
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: PUSH
32634: LD_INT 1
32636: PUSH
32637: LD_INT 1
32639: PUSH
32640: EMPTY
32641: LIST
32642: LIST
32643: PUSH
32644: LD_INT 0
32646: PUSH
32647: LD_INT 1
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: PUSH
32654: LD_INT 1
32656: NEG
32657: PUSH
32658: LD_INT 0
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 1
32667: NEG
32668: PUSH
32669: LD_INT 1
32671: NEG
32672: PUSH
32673: EMPTY
32674: LIST
32675: LIST
32676: PUSH
32677: LD_INT 1
32679: NEG
32680: PUSH
32681: LD_INT 2
32683: NEG
32684: PUSH
32685: EMPTY
32686: LIST
32687: LIST
32688: PUSH
32689: LD_INT 1
32691: PUSH
32692: LD_INT 1
32694: NEG
32695: PUSH
32696: EMPTY
32697: LIST
32698: LIST
32699: PUSH
32700: LD_INT 2
32702: PUSH
32703: LD_INT 0
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 2
32712: PUSH
32713: LD_INT 1
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 2
32722: PUSH
32723: LD_INT 2
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: PUSH
32730: LD_INT 1
32732: PUSH
32733: LD_INT 2
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: PUSH
32740: LD_INT 0
32742: PUSH
32743: LD_INT 2
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: PUSH
32750: LD_INT 1
32752: NEG
32753: PUSH
32754: LD_INT 1
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: PUSH
32761: LD_INT 2
32763: NEG
32764: PUSH
32765: LD_INT 1
32767: NEG
32768: PUSH
32769: EMPTY
32770: LIST
32771: LIST
32772: PUSH
32773: LD_INT 2
32775: NEG
32776: PUSH
32777: LD_INT 2
32779: NEG
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PUSH
32785: LD_INT 2
32787: NEG
32788: PUSH
32789: LD_INT 3
32791: NEG
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 2
32799: PUSH
32800: LD_INT 1
32802: NEG
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 3
32810: PUSH
32811: LD_INT 1
32813: PUSH
32814: EMPTY
32815: LIST
32816: LIST
32817: PUSH
32818: LD_INT 1
32820: PUSH
32821: LD_INT 3
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 1
32830: NEG
32831: PUSH
32832: LD_INT 2
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 3
32841: NEG
32842: PUSH
32843: LD_INT 2
32845: NEG
32846: PUSH
32847: EMPTY
32848: LIST
32849: LIST
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: LIST
32855: LIST
32856: LIST
32857: LIST
32858: LIST
32859: LIST
32860: LIST
32861: LIST
32862: LIST
32863: LIST
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32876: LD_ADDR_VAR 0 32
32880: PUSH
32881: LD_INT 0
32883: PUSH
32884: LD_INT 0
32886: PUSH
32887: EMPTY
32888: LIST
32889: LIST
32890: PUSH
32891: LD_INT 0
32893: PUSH
32894: LD_INT 1
32896: NEG
32897: PUSH
32898: EMPTY
32899: LIST
32900: LIST
32901: PUSH
32902: LD_INT 1
32904: PUSH
32905: LD_INT 0
32907: PUSH
32908: EMPTY
32909: LIST
32910: LIST
32911: PUSH
32912: LD_INT 1
32914: PUSH
32915: LD_INT 1
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: PUSH
32922: LD_INT 0
32924: PUSH
32925: LD_INT 1
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: PUSH
32932: LD_INT 1
32934: NEG
32935: PUSH
32936: LD_INT 0
32938: PUSH
32939: EMPTY
32940: LIST
32941: LIST
32942: PUSH
32943: LD_INT 1
32945: NEG
32946: PUSH
32947: LD_INT 1
32949: NEG
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 1
32957: NEG
32958: PUSH
32959: LD_INT 2
32961: NEG
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 0
32969: PUSH
32970: LD_INT 2
32972: NEG
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 1
32980: PUSH
32981: LD_INT 1
32983: NEG
32984: PUSH
32985: EMPTY
32986: LIST
32987: LIST
32988: PUSH
32989: LD_INT 2
32991: PUSH
32992: LD_INT 1
32994: PUSH
32995: EMPTY
32996: LIST
32997: LIST
32998: PUSH
32999: LD_INT 2
33001: PUSH
33002: LD_INT 2
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: PUSH
33009: LD_INT 1
33011: PUSH
33012: LD_INT 2
33014: PUSH
33015: EMPTY
33016: LIST
33017: LIST
33018: PUSH
33019: LD_INT 0
33021: PUSH
33022: LD_INT 2
33024: PUSH
33025: EMPTY
33026: LIST
33027: LIST
33028: PUSH
33029: LD_INT 1
33031: NEG
33032: PUSH
33033: LD_INT 1
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: LD_INT 2
33042: NEG
33043: PUSH
33044: LD_INT 0
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: LD_INT 2
33053: NEG
33054: PUSH
33055: LD_INT 1
33057: NEG
33058: PUSH
33059: EMPTY
33060: LIST
33061: LIST
33062: PUSH
33063: LD_INT 1
33065: NEG
33066: PUSH
33067: LD_INT 3
33069: NEG
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: PUSH
33075: LD_INT 1
33077: PUSH
33078: LD_INT 2
33080: NEG
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 3
33088: PUSH
33089: LD_INT 2
33091: PUSH
33092: EMPTY
33093: LIST
33094: LIST
33095: PUSH
33096: LD_INT 2
33098: PUSH
33099: LD_INT 3
33101: PUSH
33102: EMPTY
33103: LIST
33104: LIST
33105: PUSH
33106: LD_INT 2
33108: NEG
33109: PUSH
33110: LD_INT 1
33112: PUSH
33113: EMPTY
33114: LIST
33115: LIST
33116: PUSH
33117: LD_INT 3
33119: NEG
33120: PUSH
33121: LD_INT 1
33123: NEG
33124: PUSH
33125: EMPTY
33126: LIST
33127: LIST
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: LIST
33133: LIST
33134: LIST
33135: LIST
33136: LIST
33137: LIST
33138: LIST
33139: LIST
33140: LIST
33141: LIST
33142: LIST
33143: LIST
33144: LIST
33145: LIST
33146: LIST
33147: LIST
33148: LIST
33149: LIST
33150: LIST
33151: LIST
33152: LIST
33153: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33154: LD_ADDR_VAR 0 33
33158: PUSH
33159: LD_INT 0
33161: PUSH
33162: LD_INT 0
33164: PUSH
33165: EMPTY
33166: LIST
33167: LIST
33168: PUSH
33169: LD_INT 0
33171: PUSH
33172: LD_INT 1
33174: NEG
33175: PUSH
33176: EMPTY
33177: LIST
33178: LIST
33179: PUSH
33180: LD_INT 1
33182: PUSH
33183: LD_INT 0
33185: PUSH
33186: EMPTY
33187: LIST
33188: LIST
33189: PUSH
33190: LD_INT 1
33192: PUSH
33193: LD_INT 1
33195: PUSH
33196: EMPTY
33197: LIST
33198: LIST
33199: PUSH
33200: LD_INT 0
33202: PUSH
33203: LD_INT 1
33205: PUSH
33206: EMPTY
33207: LIST
33208: LIST
33209: PUSH
33210: LD_INT 1
33212: NEG
33213: PUSH
33214: LD_INT 0
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: PUSH
33221: LD_INT 1
33223: NEG
33224: PUSH
33225: LD_INT 1
33227: NEG
33228: PUSH
33229: EMPTY
33230: LIST
33231: LIST
33232: PUSH
33233: LD_INT 1
33235: NEG
33236: PUSH
33237: LD_INT 2
33239: NEG
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 1
33247: PUSH
33248: LD_INT 1
33250: NEG
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PUSH
33256: LD_INT 2
33258: PUSH
33259: LD_INT 0
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 2
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 1
33278: PUSH
33279: LD_INT 2
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: PUSH
33286: LD_INT 0
33288: PUSH
33289: LD_INT 2
33291: PUSH
33292: EMPTY
33293: LIST
33294: LIST
33295: PUSH
33296: LD_INT 1
33298: NEG
33299: PUSH
33300: LD_INT 1
33302: PUSH
33303: EMPTY
33304: LIST
33305: LIST
33306: PUSH
33307: LD_INT 2
33309: NEG
33310: PUSH
33311: LD_INT 0
33313: PUSH
33314: EMPTY
33315: LIST
33316: LIST
33317: PUSH
33318: LD_INT 2
33320: NEG
33321: PUSH
33322: LD_INT 1
33324: NEG
33325: PUSH
33326: EMPTY
33327: LIST
33328: LIST
33329: PUSH
33330: LD_INT 2
33332: NEG
33333: PUSH
33334: LD_INT 2
33336: NEG
33337: PUSH
33338: EMPTY
33339: LIST
33340: LIST
33341: PUSH
33342: LD_INT 2
33344: NEG
33345: PUSH
33346: LD_INT 3
33348: NEG
33349: PUSH
33350: EMPTY
33351: LIST
33352: LIST
33353: PUSH
33354: LD_INT 2
33356: PUSH
33357: LD_INT 1
33359: NEG
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 3
33367: PUSH
33368: LD_INT 1
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PUSH
33375: LD_INT 1
33377: PUSH
33378: LD_INT 3
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: LD_INT 1
33387: NEG
33388: PUSH
33389: LD_INT 2
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 3
33398: NEG
33399: PUSH
33400: LD_INT 2
33402: NEG
33403: PUSH
33404: EMPTY
33405: LIST
33406: LIST
33407: PUSH
33408: EMPTY
33409: LIST
33410: LIST
33411: LIST
33412: LIST
33413: LIST
33414: LIST
33415: LIST
33416: LIST
33417: LIST
33418: LIST
33419: LIST
33420: LIST
33421: LIST
33422: LIST
33423: LIST
33424: LIST
33425: LIST
33426: LIST
33427: LIST
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33433: LD_ADDR_VAR 0 34
33437: PUSH
33438: LD_INT 0
33440: PUSH
33441: LD_INT 0
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 0
33450: PUSH
33451: LD_INT 1
33453: NEG
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PUSH
33459: LD_INT 1
33461: PUSH
33462: LD_INT 0
33464: PUSH
33465: EMPTY
33466: LIST
33467: LIST
33468: PUSH
33469: LD_INT 1
33471: PUSH
33472: LD_INT 1
33474: PUSH
33475: EMPTY
33476: LIST
33477: LIST
33478: PUSH
33479: LD_INT 0
33481: PUSH
33482: LD_INT 1
33484: PUSH
33485: EMPTY
33486: LIST
33487: LIST
33488: PUSH
33489: LD_INT 1
33491: NEG
33492: PUSH
33493: LD_INT 0
33495: PUSH
33496: EMPTY
33497: LIST
33498: LIST
33499: PUSH
33500: LD_INT 1
33502: NEG
33503: PUSH
33504: LD_INT 1
33506: NEG
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 1
33514: NEG
33515: PUSH
33516: LD_INT 2
33518: NEG
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 0
33526: PUSH
33527: LD_INT 2
33529: NEG
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: PUSH
33535: LD_INT 1
33537: PUSH
33538: LD_INT 1
33540: NEG
33541: PUSH
33542: EMPTY
33543: LIST
33544: LIST
33545: PUSH
33546: LD_INT 2
33548: PUSH
33549: LD_INT 1
33551: PUSH
33552: EMPTY
33553: LIST
33554: LIST
33555: PUSH
33556: LD_INT 2
33558: PUSH
33559: LD_INT 2
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: PUSH
33566: LD_INT 1
33568: PUSH
33569: LD_INT 2
33571: PUSH
33572: EMPTY
33573: LIST
33574: LIST
33575: PUSH
33576: LD_INT 1
33578: NEG
33579: PUSH
33580: LD_INT 1
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: LD_INT 2
33589: NEG
33590: PUSH
33591: LD_INT 0
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 2
33600: NEG
33601: PUSH
33602: LD_INT 1
33604: NEG
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: PUSH
33610: LD_INT 2
33612: NEG
33613: PUSH
33614: LD_INT 2
33616: NEG
33617: PUSH
33618: EMPTY
33619: LIST
33620: LIST
33621: PUSH
33622: LD_INT 1
33624: NEG
33625: PUSH
33626: LD_INT 3
33628: NEG
33629: PUSH
33630: EMPTY
33631: LIST
33632: LIST
33633: PUSH
33634: LD_INT 1
33636: PUSH
33637: LD_INT 2
33639: NEG
33640: PUSH
33641: EMPTY
33642: LIST
33643: LIST
33644: PUSH
33645: LD_INT 3
33647: PUSH
33648: LD_INT 2
33650: PUSH
33651: EMPTY
33652: LIST
33653: LIST
33654: PUSH
33655: LD_INT 2
33657: PUSH
33658: LD_INT 3
33660: PUSH
33661: EMPTY
33662: LIST
33663: LIST
33664: PUSH
33665: LD_INT 2
33667: NEG
33668: PUSH
33669: LD_INT 1
33671: PUSH
33672: EMPTY
33673: LIST
33674: LIST
33675: PUSH
33676: LD_INT 3
33678: NEG
33679: PUSH
33680: LD_INT 1
33682: NEG
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: LIST
33702: LIST
33703: LIST
33704: LIST
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33713: LD_ADDR_VAR 0 35
33717: PUSH
33718: LD_INT 0
33720: PUSH
33721: LD_INT 0
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 0
33730: PUSH
33731: LD_INT 1
33733: NEG
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 1
33741: PUSH
33742: LD_INT 0
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: PUSH
33749: LD_INT 1
33751: PUSH
33752: LD_INT 1
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PUSH
33759: LD_INT 0
33761: PUSH
33762: LD_INT 1
33764: PUSH
33765: EMPTY
33766: LIST
33767: LIST
33768: PUSH
33769: LD_INT 1
33771: NEG
33772: PUSH
33773: LD_INT 0
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: LD_INT 1
33782: NEG
33783: PUSH
33784: LD_INT 1
33786: NEG
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 2
33794: PUSH
33795: LD_INT 1
33797: PUSH
33798: EMPTY
33799: LIST
33800: LIST
33801: PUSH
33802: LD_INT 2
33804: NEG
33805: PUSH
33806: LD_INT 1
33808: NEG
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: LIST
33818: LIST
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33825: LD_ADDR_VAR 0 36
33829: PUSH
33830: LD_INT 0
33832: PUSH
33833: LD_INT 0
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 0
33842: PUSH
33843: LD_INT 1
33845: NEG
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 1
33853: PUSH
33854: LD_INT 0
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 1
33863: PUSH
33864: LD_INT 1
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 0
33873: PUSH
33874: LD_INT 1
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: LD_INT 1
33883: NEG
33884: PUSH
33885: LD_INT 0
33887: PUSH
33888: EMPTY
33889: LIST
33890: LIST
33891: PUSH
33892: LD_INT 1
33894: NEG
33895: PUSH
33896: LD_INT 1
33898: NEG
33899: PUSH
33900: EMPTY
33901: LIST
33902: LIST
33903: PUSH
33904: LD_INT 1
33906: NEG
33907: PUSH
33908: LD_INT 2
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 1
33918: PUSH
33919: LD_INT 2
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: LIST
33930: LIST
33931: LIST
33932: LIST
33933: LIST
33934: LIST
33935: LIST
33936: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33937: LD_ADDR_VAR 0 37
33941: PUSH
33942: LD_INT 0
33944: PUSH
33945: LD_INT 0
33947: PUSH
33948: EMPTY
33949: LIST
33950: LIST
33951: PUSH
33952: LD_INT 0
33954: PUSH
33955: LD_INT 1
33957: NEG
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: LD_INT 1
33965: PUSH
33966: LD_INT 0
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: LD_INT 1
33975: PUSH
33976: LD_INT 1
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 0
33985: PUSH
33986: LD_INT 1
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 1
33995: NEG
33996: PUSH
33997: LD_INT 0
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 1
34006: NEG
34007: PUSH
34008: LD_INT 1
34010: NEG
34011: PUSH
34012: EMPTY
34013: LIST
34014: LIST
34015: PUSH
34016: LD_INT 1
34018: PUSH
34019: LD_INT 1
34021: NEG
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: LD_INT 1
34029: NEG
34030: PUSH
34031: LD_INT 1
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: PUSH
34038: EMPTY
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34049: LD_ADDR_VAR 0 38
34053: PUSH
34054: LD_INT 0
34056: PUSH
34057: LD_INT 0
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 0
34066: PUSH
34067: LD_INT 1
34069: NEG
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PUSH
34075: LD_INT 1
34077: PUSH
34078: LD_INT 0
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 1
34087: PUSH
34088: LD_INT 1
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: LD_INT 0
34097: PUSH
34098: LD_INT 1
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: LD_INT 1
34107: NEG
34108: PUSH
34109: LD_INT 0
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: LD_INT 1
34122: NEG
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 2
34130: PUSH
34131: LD_INT 1
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 2
34140: NEG
34141: PUSH
34142: LD_INT 1
34144: NEG
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: EMPTY
34151: LIST
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34161: LD_ADDR_VAR 0 39
34165: PUSH
34166: LD_INT 0
34168: PUSH
34169: LD_INT 0
34171: PUSH
34172: EMPTY
34173: LIST
34174: LIST
34175: PUSH
34176: LD_INT 0
34178: PUSH
34179: LD_INT 1
34181: NEG
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PUSH
34187: LD_INT 1
34189: PUSH
34190: LD_INT 0
34192: PUSH
34193: EMPTY
34194: LIST
34195: LIST
34196: PUSH
34197: LD_INT 1
34199: PUSH
34200: LD_INT 1
34202: PUSH
34203: EMPTY
34204: LIST
34205: LIST
34206: PUSH
34207: LD_INT 0
34209: PUSH
34210: LD_INT 1
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 1
34219: NEG
34220: PUSH
34221: LD_INT 0
34223: PUSH
34224: EMPTY
34225: LIST
34226: LIST
34227: PUSH
34228: LD_INT 1
34230: NEG
34231: PUSH
34232: LD_INT 1
34234: NEG
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: PUSH
34240: LD_INT 1
34242: NEG
34243: PUSH
34244: LD_INT 2
34246: NEG
34247: PUSH
34248: EMPTY
34249: LIST
34250: LIST
34251: PUSH
34252: LD_INT 1
34254: PUSH
34255: LD_INT 2
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34273: LD_ADDR_VAR 0 40
34277: PUSH
34278: LD_INT 0
34280: PUSH
34281: LD_INT 0
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: PUSH
34288: LD_INT 0
34290: PUSH
34291: LD_INT 1
34293: NEG
34294: PUSH
34295: EMPTY
34296: LIST
34297: LIST
34298: PUSH
34299: LD_INT 1
34301: PUSH
34302: LD_INT 0
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: PUSH
34309: LD_INT 1
34311: PUSH
34312: LD_INT 1
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 0
34321: PUSH
34322: LD_INT 1
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 1
34331: NEG
34332: PUSH
34333: LD_INT 0
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 1
34342: NEG
34343: PUSH
34344: LD_INT 1
34346: NEG
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 1
34354: PUSH
34355: LD_INT 1
34357: NEG
34358: PUSH
34359: EMPTY
34360: LIST
34361: LIST
34362: PUSH
34363: LD_INT 1
34365: NEG
34366: PUSH
34367: LD_INT 1
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: LIST
34381: LIST
34382: LIST
34383: LIST
34384: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34385: LD_ADDR_VAR 0 41
34389: PUSH
34390: LD_INT 0
34392: PUSH
34393: LD_INT 0
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: LD_INT 0
34402: PUSH
34403: LD_INT 1
34405: NEG
34406: PUSH
34407: EMPTY
34408: LIST
34409: LIST
34410: PUSH
34411: LD_INT 1
34413: PUSH
34414: LD_INT 0
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: PUSH
34424: LD_INT 1
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 0
34433: PUSH
34434: LD_INT 1
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 1
34443: NEG
34444: PUSH
34445: LD_INT 0
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 1
34454: NEG
34455: PUSH
34456: LD_INT 1
34458: NEG
34459: PUSH
34460: EMPTY
34461: LIST
34462: LIST
34463: PUSH
34464: LD_INT 1
34466: NEG
34467: PUSH
34468: LD_INT 2
34470: NEG
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PUSH
34476: LD_INT 1
34478: PUSH
34479: LD_INT 1
34481: NEG
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: PUSH
34487: LD_INT 2
34489: PUSH
34490: LD_INT 0
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 2
34499: PUSH
34500: LD_INT 1
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 2
34509: PUSH
34510: LD_INT 2
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: PUSH
34517: LD_INT 1
34519: PUSH
34520: LD_INT 2
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 1
34529: NEG
34530: PUSH
34531: LD_INT 1
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 2
34540: NEG
34541: PUSH
34542: LD_INT 0
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 2
34551: NEG
34552: PUSH
34553: LD_INT 1
34555: NEG
34556: PUSH
34557: EMPTY
34558: LIST
34559: LIST
34560: PUSH
34561: LD_INT 2
34563: NEG
34564: PUSH
34565: LD_INT 2
34567: NEG
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 2
34575: NEG
34576: PUSH
34577: LD_INT 3
34579: NEG
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 2
34587: PUSH
34588: LD_INT 1
34590: NEG
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 3
34598: PUSH
34599: LD_INT 0
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 3
34608: PUSH
34609: LD_INT 1
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 3
34618: PUSH
34619: LD_INT 2
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 3
34628: PUSH
34629: LD_INT 3
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PUSH
34636: LD_INT 2
34638: PUSH
34639: LD_INT 3
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: LD_INT 2
34648: NEG
34649: PUSH
34650: LD_INT 1
34652: PUSH
34653: EMPTY
34654: LIST
34655: LIST
34656: PUSH
34657: LD_INT 3
34659: NEG
34660: PUSH
34661: LD_INT 0
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: LD_INT 3
34670: NEG
34671: PUSH
34672: LD_INT 1
34674: NEG
34675: PUSH
34676: EMPTY
34677: LIST
34678: LIST
34679: PUSH
34680: LD_INT 3
34682: NEG
34683: PUSH
34684: LD_INT 2
34686: NEG
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 3
34694: NEG
34695: PUSH
34696: LD_INT 3
34698: NEG
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: EMPTY
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34735: LD_ADDR_VAR 0 42
34739: PUSH
34740: LD_INT 0
34742: PUSH
34743: LD_INT 0
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 0
34752: PUSH
34753: LD_INT 1
34755: NEG
34756: PUSH
34757: EMPTY
34758: LIST
34759: LIST
34760: PUSH
34761: LD_INT 1
34763: PUSH
34764: LD_INT 0
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: LD_INT 1
34773: PUSH
34774: LD_INT 1
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 0
34783: PUSH
34784: LD_INT 1
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: PUSH
34791: LD_INT 1
34793: NEG
34794: PUSH
34795: LD_INT 0
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: PUSH
34802: LD_INT 1
34804: NEG
34805: PUSH
34806: LD_INT 1
34808: NEG
34809: PUSH
34810: EMPTY
34811: LIST
34812: LIST
34813: PUSH
34814: LD_INT 1
34816: NEG
34817: PUSH
34818: LD_INT 2
34820: NEG
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PUSH
34826: LD_INT 0
34828: PUSH
34829: LD_INT 2
34831: NEG
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: PUSH
34837: LD_INT 1
34839: PUSH
34840: LD_INT 1
34842: NEG
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 2
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 2
34860: PUSH
34861: LD_INT 2
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 1
34870: PUSH
34871: LD_INT 2
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 0
34880: PUSH
34881: LD_INT 2
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 1
34890: NEG
34891: PUSH
34892: LD_INT 1
34894: PUSH
34895: EMPTY
34896: LIST
34897: LIST
34898: PUSH
34899: LD_INT 2
34901: NEG
34902: PUSH
34903: LD_INT 1
34905: NEG
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 2
34913: NEG
34914: PUSH
34915: LD_INT 2
34917: NEG
34918: PUSH
34919: EMPTY
34920: LIST
34921: LIST
34922: PUSH
34923: LD_INT 2
34925: NEG
34926: PUSH
34927: LD_INT 3
34929: NEG
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: LD_INT 1
34937: NEG
34938: PUSH
34939: LD_INT 3
34941: NEG
34942: PUSH
34943: EMPTY
34944: LIST
34945: LIST
34946: PUSH
34947: LD_INT 0
34949: PUSH
34950: LD_INT 3
34952: NEG
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: LD_INT 1
34960: PUSH
34961: LD_INT 2
34963: NEG
34964: PUSH
34965: EMPTY
34966: LIST
34967: LIST
34968: PUSH
34969: LD_INT 3
34971: PUSH
34972: LD_INT 2
34974: PUSH
34975: EMPTY
34976: LIST
34977: LIST
34978: PUSH
34979: LD_INT 3
34981: PUSH
34982: LD_INT 3
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: PUSH
34989: LD_INT 2
34991: PUSH
34992: LD_INT 3
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 1
35001: PUSH
35002: LD_INT 3
35004: PUSH
35005: EMPTY
35006: LIST
35007: LIST
35008: PUSH
35009: LD_INT 0
35011: PUSH
35012: LD_INT 3
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 1
35021: NEG
35022: PUSH
35023: LD_INT 2
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 3
35032: NEG
35033: PUSH
35034: LD_INT 2
35036: NEG
35037: PUSH
35038: EMPTY
35039: LIST
35040: LIST
35041: PUSH
35042: LD_INT 3
35044: NEG
35045: PUSH
35046: LD_INT 3
35048: NEG
35049: PUSH
35050: EMPTY
35051: LIST
35052: LIST
35053: PUSH
35054: EMPTY
35055: LIST
35056: LIST
35057: LIST
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: LIST
35063: LIST
35064: LIST
35065: LIST
35066: LIST
35067: LIST
35068: LIST
35069: LIST
35070: LIST
35071: LIST
35072: LIST
35073: LIST
35074: LIST
35075: LIST
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35085: LD_ADDR_VAR 0 43
35089: PUSH
35090: LD_INT 0
35092: PUSH
35093: LD_INT 0
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 0
35102: PUSH
35103: LD_INT 1
35105: NEG
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 1
35113: PUSH
35114: LD_INT 0
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PUSH
35121: LD_INT 1
35123: PUSH
35124: LD_INT 1
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: LD_INT 0
35133: PUSH
35134: LD_INT 1
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: LD_INT 1
35143: NEG
35144: PUSH
35145: LD_INT 0
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 1
35154: NEG
35155: PUSH
35156: LD_INT 1
35158: NEG
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 1
35166: NEG
35167: PUSH
35168: LD_INT 2
35170: NEG
35171: PUSH
35172: EMPTY
35173: LIST
35174: LIST
35175: PUSH
35176: LD_INT 0
35178: PUSH
35179: LD_INT 2
35181: NEG
35182: PUSH
35183: EMPTY
35184: LIST
35185: LIST
35186: PUSH
35187: LD_INT 1
35189: PUSH
35190: LD_INT 1
35192: NEG
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 2
35200: PUSH
35201: LD_INT 0
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 2
35210: PUSH
35211: LD_INT 1
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 1
35220: PUSH
35221: LD_INT 2
35223: PUSH
35224: EMPTY
35225: LIST
35226: LIST
35227: PUSH
35228: LD_INT 0
35230: PUSH
35231: LD_INT 2
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: LD_INT 1
35244: PUSH
35245: EMPTY
35246: LIST
35247: LIST
35248: PUSH
35249: LD_INT 2
35251: NEG
35252: PUSH
35253: LD_INT 0
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 2
35262: NEG
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: LD_INT 1
35274: NEG
35275: PUSH
35276: LD_INT 3
35278: NEG
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: PUSH
35284: LD_INT 0
35286: PUSH
35287: LD_INT 3
35289: NEG
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 1
35297: PUSH
35298: LD_INT 2
35300: NEG
35301: PUSH
35302: EMPTY
35303: LIST
35304: LIST
35305: PUSH
35306: LD_INT 2
35308: PUSH
35309: LD_INT 1
35311: NEG
35312: PUSH
35313: EMPTY
35314: LIST
35315: LIST
35316: PUSH
35317: LD_INT 3
35319: PUSH
35320: LD_INT 0
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: LD_INT 3
35329: PUSH
35330: LD_INT 1
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: LD_INT 1
35339: PUSH
35340: LD_INT 3
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 0
35349: PUSH
35350: LD_INT 3
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 1
35359: NEG
35360: PUSH
35361: LD_INT 2
35363: PUSH
35364: EMPTY
35365: LIST
35366: LIST
35367: PUSH
35368: LD_INT 2
35370: NEG
35371: PUSH
35372: LD_INT 1
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 3
35381: NEG
35382: PUSH
35383: LD_INT 0
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 3
35392: NEG
35393: PUSH
35394: LD_INT 1
35396: NEG
35397: PUSH
35398: EMPTY
35399: LIST
35400: LIST
35401: PUSH
35402: EMPTY
35403: LIST
35404: LIST
35405: LIST
35406: LIST
35407: LIST
35408: LIST
35409: LIST
35410: LIST
35411: LIST
35412: LIST
35413: LIST
35414: LIST
35415: LIST
35416: LIST
35417: LIST
35418: LIST
35419: LIST
35420: LIST
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35433: LD_ADDR_VAR 0 44
35437: PUSH
35438: LD_INT 0
35440: PUSH
35441: LD_INT 0
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 0
35450: PUSH
35451: LD_INT 1
35453: NEG
35454: PUSH
35455: EMPTY
35456: LIST
35457: LIST
35458: PUSH
35459: LD_INT 1
35461: PUSH
35462: LD_INT 0
35464: PUSH
35465: EMPTY
35466: LIST
35467: LIST
35468: PUSH
35469: LD_INT 1
35471: PUSH
35472: LD_INT 1
35474: PUSH
35475: EMPTY
35476: LIST
35477: LIST
35478: PUSH
35479: LD_INT 0
35481: PUSH
35482: LD_INT 1
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 1
35491: NEG
35492: PUSH
35493: LD_INT 0
35495: PUSH
35496: EMPTY
35497: LIST
35498: LIST
35499: PUSH
35500: LD_INT 1
35502: NEG
35503: PUSH
35504: LD_INT 1
35506: NEG
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 1
35514: NEG
35515: PUSH
35516: LD_INT 2
35518: NEG
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 1
35526: PUSH
35527: LD_INT 1
35529: NEG
35530: PUSH
35531: EMPTY
35532: LIST
35533: LIST
35534: PUSH
35535: LD_INT 2
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: LD_INT 2
35547: PUSH
35548: LD_INT 1
35550: PUSH
35551: EMPTY
35552: LIST
35553: LIST
35554: PUSH
35555: LD_INT 2
35557: PUSH
35558: LD_INT 2
35560: PUSH
35561: EMPTY
35562: LIST
35563: LIST
35564: PUSH
35565: LD_INT 1
35567: PUSH
35568: LD_INT 2
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: PUSH
35575: LD_INT 1
35577: NEG
35578: PUSH
35579: LD_INT 1
35581: PUSH
35582: EMPTY
35583: LIST
35584: LIST
35585: PUSH
35586: LD_INT 2
35588: NEG
35589: PUSH
35590: LD_INT 0
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: PUSH
35597: LD_INT 2
35599: NEG
35600: PUSH
35601: LD_INT 1
35603: NEG
35604: PUSH
35605: EMPTY
35606: LIST
35607: LIST
35608: PUSH
35609: LD_INT 2
35611: NEG
35612: PUSH
35613: LD_INT 2
35615: NEG
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 2
35623: NEG
35624: PUSH
35625: LD_INT 3
35627: NEG
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 2
35635: PUSH
35636: LD_INT 1
35638: NEG
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 3
35646: PUSH
35647: LD_INT 0
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: PUSH
35654: LD_INT 3
35656: PUSH
35657: LD_INT 1
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: PUSH
35664: LD_INT 3
35666: PUSH
35667: LD_INT 2
35669: PUSH
35670: EMPTY
35671: LIST
35672: LIST
35673: PUSH
35674: LD_INT 3
35676: PUSH
35677: LD_INT 3
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 2
35686: PUSH
35687: LD_INT 3
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 2
35696: NEG
35697: PUSH
35698: LD_INT 1
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 3
35707: NEG
35708: PUSH
35709: LD_INT 0
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 3
35718: NEG
35719: PUSH
35720: LD_INT 1
35722: NEG
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: PUSH
35728: LD_INT 3
35730: NEG
35731: PUSH
35732: LD_INT 2
35734: NEG
35735: PUSH
35736: EMPTY
35737: LIST
35738: LIST
35739: PUSH
35740: LD_INT 3
35742: NEG
35743: PUSH
35744: LD_INT 3
35746: NEG
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: LIST
35756: LIST
35757: LIST
35758: LIST
35759: LIST
35760: LIST
35761: LIST
35762: LIST
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: LIST
35768: LIST
35769: LIST
35770: LIST
35771: LIST
35772: LIST
35773: LIST
35774: LIST
35775: LIST
35776: LIST
35777: LIST
35778: LIST
35779: LIST
35780: LIST
35781: LIST
35782: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35783: LD_ADDR_VAR 0 45
35787: PUSH
35788: LD_INT 0
35790: PUSH
35791: LD_INT 0
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 0
35800: PUSH
35801: LD_INT 1
35803: NEG
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 1
35811: PUSH
35812: LD_INT 0
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: LD_INT 1
35821: PUSH
35822: LD_INT 1
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 0
35831: PUSH
35832: LD_INT 1
35834: PUSH
35835: EMPTY
35836: LIST
35837: LIST
35838: PUSH
35839: LD_INT 1
35841: NEG
35842: PUSH
35843: LD_INT 0
35845: PUSH
35846: EMPTY
35847: LIST
35848: LIST
35849: PUSH
35850: LD_INT 1
35852: NEG
35853: PUSH
35854: LD_INT 1
35856: NEG
35857: PUSH
35858: EMPTY
35859: LIST
35860: LIST
35861: PUSH
35862: LD_INT 1
35864: NEG
35865: PUSH
35866: LD_INT 2
35868: NEG
35869: PUSH
35870: EMPTY
35871: LIST
35872: LIST
35873: PUSH
35874: LD_INT 0
35876: PUSH
35877: LD_INT 2
35879: NEG
35880: PUSH
35881: EMPTY
35882: LIST
35883: LIST
35884: PUSH
35885: LD_INT 1
35887: PUSH
35888: LD_INT 1
35890: NEG
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: LD_INT 1
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 2
35908: PUSH
35909: LD_INT 2
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 1
35918: PUSH
35919: LD_INT 2
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 0
35928: PUSH
35929: LD_INT 2
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 1
35938: NEG
35939: PUSH
35940: LD_INT 1
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 2
35949: NEG
35950: PUSH
35951: LD_INT 1
35953: NEG
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PUSH
35959: LD_INT 2
35961: NEG
35962: PUSH
35963: LD_INT 2
35965: NEG
35966: PUSH
35967: EMPTY
35968: LIST
35969: LIST
35970: PUSH
35971: LD_INT 2
35973: NEG
35974: PUSH
35975: LD_INT 3
35977: NEG
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 1
35985: NEG
35986: PUSH
35987: LD_INT 3
35989: NEG
35990: PUSH
35991: EMPTY
35992: LIST
35993: LIST
35994: PUSH
35995: LD_INT 0
35997: PUSH
35998: LD_INT 3
36000: NEG
36001: PUSH
36002: EMPTY
36003: LIST
36004: LIST
36005: PUSH
36006: LD_INT 1
36008: PUSH
36009: LD_INT 2
36011: NEG
36012: PUSH
36013: EMPTY
36014: LIST
36015: LIST
36016: PUSH
36017: LD_INT 3
36019: PUSH
36020: LD_INT 2
36022: PUSH
36023: EMPTY
36024: LIST
36025: LIST
36026: PUSH
36027: LD_INT 3
36029: PUSH
36030: LD_INT 3
36032: PUSH
36033: EMPTY
36034: LIST
36035: LIST
36036: PUSH
36037: LD_INT 2
36039: PUSH
36040: LD_INT 3
36042: PUSH
36043: EMPTY
36044: LIST
36045: LIST
36046: PUSH
36047: LD_INT 1
36049: PUSH
36050: LD_INT 3
36052: PUSH
36053: EMPTY
36054: LIST
36055: LIST
36056: PUSH
36057: LD_INT 0
36059: PUSH
36060: LD_INT 3
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: PUSH
36067: LD_INT 1
36069: NEG
36070: PUSH
36071: LD_INT 2
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 3
36080: NEG
36081: PUSH
36082: LD_INT 2
36084: NEG
36085: PUSH
36086: EMPTY
36087: LIST
36088: LIST
36089: PUSH
36090: LD_INT 3
36092: NEG
36093: PUSH
36094: LD_INT 3
36096: NEG
36097: PUSH
36098: EMPTY
36099: LIST
36100: LIST
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: LIST
36106: LIST
36107: LIST
36108: LIST
36109: LIST
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36133: LD_ADDR_VAR 0 46
36137: PUSH
36138: LD_INT 0
36140: PUSH
36141: LD_INT 0
36143: PUSH
36144: EMPTY
36145: LIST
36146: LIST
36147: PUSH
36148: LD_INT 0
36150: PUSH
36151: LD_INT 1
36153: NEG
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PUSH
36159: LD_INT 1
36161: PUSH
36162: LD_INT 0
36164: PUSH
36165: EMPTY
36166: LIST
36167: LIST
36168: PUSH
36169: LD_INT 1
36171: PUSH
36172: LD_INT 1
36174: PUSH
36175: EMPTY
36176: LIST
36177: LIST
36178: PUSH
36179: LD_INT 0
36181: PUSH
36182: LD_INT 1
36184: PUSH
36185: EMPTY
36186: LIST
36187: LIST
36188: PUSH
36189: LD_INT 1
36191: NEG
36192: PUSH
36193: LD_INT 0
36195: PUSH
36196: EMPTY
36197: LIST
36198: LIST
36199: PUSH
36200: LD_INT 1
36202: NEG
36203: PUSH
36204: LD_INT 1
36206: NEG
36207: PUSH
36208: EMPTY
36209: LIST
36210: LIST
36211: PUSH
36212: LD_INT 1
36214: NEG
36215: PUSH
36216: LD_INT 2
36218: NEG
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 0
36226: PUSH
36227: LD_INT 2
36229: NEG
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 1
36237: PUSH
36238: LD_INT 1
36240: NEG
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 2
36248: PUSH
36249: LD_INT 0
36251: PUSH
36252: EMPTY
36253: LIST
36254: LIST
36255: PUSH
36256: LD_INT 2
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: PUSH
36266: LD_INT 1
36268: PUSH
36269: LD_INT 2
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 0
36278: PUSH
36279: LD_INT 2
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 1
36288: NEG
36289: PUSH
36290: LD_INT 1
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 2
36299: NEG
36300: PUSH
36301: LD_INT 0
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 2
36310: NEG
36311: PUSH
36312: LD_INT 1
36314: NEG
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 1
36322: NEG
36323: PUSH
36324: LD_INT 3
36326: NEG
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 0
36334: PUSH
36335: LD_INT 3
36337: NEG
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: PUSH
36343: LD_INT 1
36345: PUSH
36346: LD_INT 2
36348: NEG
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 2
36356: PUSH
36357: LD_INT 1
36359: NEG
36360: PUSH
36361: EMPTY
36362: LIST
36363: LIST
36364: PUSH
36365: LD_INT 3
36367: PUSH
36368: LD_INT 0
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 3
36377: PUSH
36378: LD_INT 1
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: PUSH
36385: LD_INT 1
36387: PUSH
36388: LD_INT 3
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: LD_INT 0
36397: PUSH
36398: LD_INT 3
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 1
36407: NEG
36408: PUSH
36409: LD_INT 2
36411: PUSH
36412: EMPTY
36413: LIST
36414: LIST
36415: PUSH
36416: LD_INT 2
36418: NEG
36419: PUSH
36420: LD_INT 1
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 3
36429: NEG
36430: PUSH
36431: LD_INT 0
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 3
36440: NEG
36441: PUSH
36442: LD_INT 1
36444: NEG
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: LIST
36454: LIST
36455: LIST
36456: LIST
36457: LIST
36458: LIST
36459: LIST
36460: LIST
36461: LIST
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36481: LD_ADDR_VAR 0 47
36485: PUSH
36486: LD_INT 0
36488: PUSH
36489: LD_INT 0
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 0
36498: PUSH
36499: LD_INT 1
36501: NEG
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: LD_INT 1
36509: PUSH
36510: LD_INT 0
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 1
36519: PUSH
36520: LD_INT 1
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: LD_INT 0
36529: PUSH
36530: LD_INT 1
36532: PUSH
36533: EMPTY
36534: LIST
36535: LIST
36536: PUSH
36537: LD_INT 1
36539: NEG
36540: PUSH
36541: LD_INT 0
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: LD_INT 1
36550: NEG
36551: PUSH
36552: LD_INT 1
36554: NEG
36555: PUSH
36556: EMPTY
36557: LIST
36558: LIST
36559: PUSH
36560: LD_INT 1
36562: NEG
36563: PUSH
36564: LD_INT 2
36566: NEG
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 0
36574: PUSH
36575: LD_INT 2
36577: NEG
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 1
36585: PUSH
36586: LD_INT 1
36588: NEG
36589: PUSH
36590: EMPTY
36591: LIST
36592: LIST
36593: PUSH
36594: LD_INT 2
36596: NEG
36597: PUSH
36598: LD_INT 1
36600: NEG
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: LD_INT 2
36608: NEG
36609: PUSH
36610: LD_INT 2
36612: NEG
36613: PUSH
36614: EMPTY
36615: LIST
36616: LIST
36617: PUSH
36618: EMPTY
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: LIST
36628: LIST
36629: LIST
36630: LIST
36631: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36632: LD_ADDR_VAR 0 48
36636: PUSH
36637: LD_INT 0
36639: PUSH
36640: LD_INT 0
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: LD_INT 0
36649: PUSH
36650: LD_INT 1
36652: NEG
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: PUSH
36658: LD_INT 1
36660: PUSH
36661: LD_INT 0
36663: PUSH
36664: EMPTY
36665: LIST
36666: LIST
36667: PUSH
36668: LD_INT 1
36670: PUSH
36671: LD_INT 1
36673: PUSH
36674: EMPTY
36675: LIST
36676: LIST
36677: PUSH
36678: LD_INT 0
36680: PUSH
36681: LD_INT 1
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 1
36690: NEG
36691: PUSH
36692: LD_INT 0
36694: PUSH
36695: EMPTY
36696: LIST
36697: LIST
36698: PUSH
36699: LD_INT 1
36701: NEG
36702: PUSH
36703: LD_INT 1
36705: NEG
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 1
36713: NEG
36714: PUSH
36715: LD_INT 2
36717: NEG
36718: PUSH
36719: EMPTY
36720: LIST
36721: LIST
36722: PUSH
36723: LD_INT 0
36725: PUSH
36726: LD_INT 2
36728: NEG
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: PUSH
36734: LD_INT 1
36736: PUSH
36737: LD_INT 1
36739: NEG
36740: PUSH
36741: EMPTY
36742: LIST
36743: LIST
36744: PUSH
36745: LD_INT 2
36747: PUSH
36748: LD_INT 0
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_INT 2
36757: PUSH
36758: LD_INT 1
36760: PUSH
36761: EMPTY
36762: LIST
36763: LIST
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: LIST
36769: LIST
36770: LIST
36771: LIST
36772: LIST
36773: LIST
36774: LIST
36775: LIST
36776: LIST
36777: LIST
36778: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36779: LD_ADDR_VAR 0 49
36783: PUSH
36784: LD_INT 0
36786: PUSH
36787: LD_INT 0
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 0
36796: PUSH
36797: LD_INT 1
36799: NEG
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: PUSH
36805: LD_INT 1
36807: PUSH
36808: LD_INT 0
36810: PUSH
36811: EMPTY
36812: LIST
36813: LIST
36814: PUSH
36815: LD_INT 1
36817: PUSH
36818: LD_INT 1
36820: PUSH
36821: EMPTY
36822: LIST
36823: LIST
36824: PUSH
36825: LD_INT 0
36827: PUSH
36828: LD_INT 1
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 1
36837: NEG
36838: PUSH
36839: LD_INT 0
36841: PUSH
36842: EMPTY
36843: LIST
36844: LIST
36845: PUSH
36846: LD_INT 1
36848: NEG
36849: PUSH
36850: LD_INT 1
36852: NEG
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: LD_INT 1
36860: PUSH
36861: LD_INT 1
36863: NEG
36864: PUSH
36865: EMPTY
36866: LIST
36867: LIST
36868: PUSH
36869: LD_INT 2
36871: PUSH
36872: LD_INT 0
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: PUSH
36879: LD_INT 2
36881: PUSH
36882: LD_INT 1
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 2
36891: PUSH
36892: LD_INT 2
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 1
36901: PUSH
36902: LD_INT 2
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: LIST
36913: LIST
36914: LIST
36915: LIST
36916: LIST
36917: LIST
36918: LIST
36919: LIST
36920: LIST
36921: LIST
36922: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36923: LD_ADDR_VAR 0 50
36927: PUSH
36928: LD_INT 0
36930: PUSH
36931: LD_INT 0
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 0
36940: PUSH
36941: LD_INT 1
36943: NEG
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: LD_INT 1
36951: PUSH
36952: LD_INT 0
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: LD_INT 1
36961: PUSH
36962: LD_INT 1
36964: PUSH
36965: EMPTY
36966: LIST
36967: LIST
36968: PUSH
36969: LD_INT 0
36971: PUSH
36972: LD_INT 1
36974: PUSH
36975: EMPTY
36976: LIST
36977: LIST
36978: PUSH
36979: LD_INT 1
36981: NEG
36982: PUSH
36983: LD_INT 0
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: PUSH
36990: LD_INT 1
36992: NEG
36993: PUSH
36994: LD_INT 1
36996: NEG
36997: PUSH
36998: EMPTY
36999: LIST
37000: LIST
37001: PUSH
37002: LD_INT 2
37004: PUSH
37005: LD_INT 1
37007: PUSH
37008: EMPTY
37009: LIST
37010: LIST
37011: PUSH
37012: LD_INT 2
37014: PUSH
37015: LD_INT 2
37017: PUSH
37018: EMPTY
37019: LIST
37020: LIST
37021: PUSH
37022: LD_INT 1
37024: PUSH
37025: LD_INT 2
37027: PUSH
37028: EMPTY
37029: LIST
37030: LIST
37031: PUSH
37032: LD_INT 0
37034: PUSH
37035: LD_INT 2
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 1
37044: NEG
37045: PUSH
37046: LD_INT 1
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: LIST
37057: LIST
37058: LIST
37059: LIST
37060: LIST
37061: LIST
37062: LIST
37063: LIST
37064: LIST
37065: LIST
37066: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37067: LD_ADDR_VAR 0 51
37071: PUSH
37072: LD_INT 0
37074: PUSH
37075: LD_INT 0
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 0
37084: PUSH
37085: LD_INT 1
37087: NEG
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: LD_INT 1
37095: PUSH
37096: LD_INT 0
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 1
37105: PUSH
37106: LD_INT 1
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 0
37115: PUSH
37116: LD_INT 1
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 1
37125: NEG
37126: PUSH
37127: LD_INT 0
37129: PUSH
37130: EMPTY
37131: LIST
37132: LIST
37133: PUSH
37134: LD_INT 1
37136: NEG
37137: PUSH
37138: LD_INT 1
37140: NEG
37141: PUSH
37142: EMPTY
37143: LIST
37144: LIST
37145: PUSH
37146: LD_INT 1
37148: PUSH
37149: LD_INT 2
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 0
37158: PUSH
37159: LD_INT 2
37161: PUSH
37162: EMPTY
37163: LIST
37164: LIST
37165: PUSH
37166: LD_INT 1
37168: NEG
37169: PUSH
37170: LD_INT 1
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PUSH
37177: LD_INT 2
37179: NEG
37180: PUSH
37181: LD_INT 0
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: PUSH
37188: LD_INT 2
37190: NEG
37191: PUSH
37192: LD_INT 1
37194: NEG
37195: PUSH
37196: EMPTY
37197: LIST
37198: LIST
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: LIST
37204: LIST
37205: LIST
37206: LIST
37207: LIST
37208: LIST
37209: LIST
37210: LIST
37211: LIST
37212: LIST
37213: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37214: LD_ADDR_VAR 0 52
37218: PUSH
37219: LD_INT 0
37221: PUSH
37222: LD_INT 0
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: PUSH
37229: LD_INT 0
37231: PUSH
37232: LD_INT 1
37234: NEG
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: PUSH
37240: LD_INT 1
37242: PUSH
37243: LD_INT 0
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 1
37252: PUSH
37253: LD_INT 1
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 0
37262: PUSH
37263: LD_INT 1
37265: PUSH
37266: EMPTY
37267: LIST
37268: LIST
37269: PUSH
37270: LD_INT 1
37272: NEG
37273: PUSH
37274: LD_INT 0
37276: PUSH
37277: EMPTY
37278: LIST
37279: LIST
37280: PUSH
37281: LD_INT 1
37283: NEG
37284: PUSH
37285: LD_INT 1
37287: NEG
37288: PUSH
37289: EMPTY
37290: LIST
37291: LIST
37292: PUSH
37293: LD_INT 1
37295: NEG
37296: PUSH
37297: LD_INT 2
37299: NEG
37300: PUSH
37301: EMPTY
37302: LIST
37303: LIST
37304: PUSH
37305: LD_INT 1
37307: NEG
37308: PUSH
37309: LD_INT 1
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: LD_INT 2
37318: NEG
37319: PUSH
37320: LD_INT 0
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: LD_INT 2
37329: NEG
37330: PUSH
37331: LD_INT 1
37333: NEG
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: PUSH
37339: LD_INT 2
37341: NEG
37342: PUSH
37343: LD_INT 2
37345: NEG
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: EMPTY
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37365: LD_ADDR_VAR 0 53
37369: PUSH
37370: LD_INT 0
37372: PUSH
37373: LD_INT 0
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PUSH
37380: LD_INT 0
37382: PUSH
37383: LD_INT 1
37385: NEG
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 1
37393: PUSH
37394: LD_INT 0
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: LD_INT 1
37403: PUSH
37404: LD_INT 1
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PUSH
37411: LD_INT 0
37413: PUSH
37414: LD_INT 1
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: PUSH
37421: LD_INT 1
37423: NEG
37424: PUSH
37425: LD_INT 0
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: LD_INT 1
37438: NEG
37439: PUSH
37440: EMPTY
37441: LIST
37442: LIST
37443: PUSH
37444: LD_INT 1
37446: NEG
37447: PUSH
37448: LD_INT 2
37450: NEG
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: LD_INT 0
37458: PUSH
37459: LD_INT 2
37461: NEG
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: LD_INT 1
37469: PUSH
37470: LD_INT 1
37472: NEG
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 2
37480: PUSH
37481: LD_INT 0
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PUSH
37488: LD_INT 2
37490: PUSH
37491: LD_INT 1
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 2
37500: PUSH
37501: LD_INT 2
37503: PUSH
37504: EMPTY
37505: LIST
37506: LIST
37507: PUSH
37508: LD_INT 1
37510: PUSH
37511: LD_INT 2
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 0
37520: PUSH
37521: LD_INT 2
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: LD_INT 1
37530: NEG
37531: PUSH
37532: LD_INT 1
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: PUSH
37539: LD_INT 2
37541: NEG
37542: PUSH
37543: LD_INT 0
37545: PUSH
37546: EMPTY
37547: LIST
37548: LIST
37549: PUSH
37550: LD_INT 2
37552: NEG
37553: PUSH
37554: LD_INT 1
37556: NEG
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 2
37564: NEG
37565: PUSH
37566: LD_INT 2
37568: NEG
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: LIST
37585: LIST
37586: LIST
37587: LIST
37588: LIST
37589: LIST
37590: LIST
37591: LIST
37592: LIST
37593: LIST
37594: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37595: LD_ADDR_VAR 0 54
37599: PUSH
37600: LD_INT 0
37602: PUSH
37603: LD_INT 0
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 0
37612: PUSH
37613: LD_INT 1
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: PUSH
37624: LD_INT 0
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 1
37633: PUSH
37634: LD_INT 1
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 0
37643: PUSH
37644: LD_INT 1
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 1
37653: NEG
37654: PUSH
37655: LD_INT 0
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 1
37664: NEG
37665: PUSH
37666: LD_INT 1
37668: NEG
37669: PUSH
37670: EMPTY
37671: LIST
37672: LIST
37673: PUSH
37674: LD_INT 1
37676: NEG
37677: PUSH
37678: LD_INT 2
37680: NEG
37681: PUSH
37682: EMPTY
37683: LIST
37684: LIST
37685: PUSH
37686: LD_INT 0
37688: PUSH
37689: LD_INT 2
37691: NEG
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: LD_INT 1
37699: PUSH
37700: LD_INT 1
37702: NEG
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: LD_INT 2
37710: PUSH
37711: LD_INT 0
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: LD_INT 2
37720: PUSH
37721: LD_INT 1
37723: PUSH
37724: EMPTY
37725: LIST
37726: LIST
37727: PUSH
37728: LD_INT 2
37730: PUSH
37731: LD_INT 2
37733: PUSH
37734: EMPTY
37735: LIST
37736: LIST
37737: PUSH
37738: LD_INT 1
37740: PUSH
37741: LD_INT 2
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: LD_INT 2
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 1
37760: NEG
37761: PUSH
37762: LD_INT 1
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 2
37771: NEG
37772: PUSH
37773: LD_INT 0
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: LD_INT 2
37782: NEG
37783: PUSH
37784: LD_INT 1
37786: NEG
37787: PUSH
37788: EMPTY
37789: LIST
37790: LIST
37791: PUSH
37792: LD_INT 2
37794: NEG
37795: PUSH
37796: LD_INT 2
37798: NEG
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: LIST
37810: LIST
37811: LIST
37812: LIST
37813: LIST
37814: LIST
37815: LIST
37816: LIST
37817: LIST
37818: LIST
37819: LIST
37820: LIST
37821: LIST
37822: LIST
37823: LIST
37824: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37825: LD_ADDR_VAR 0 55
37829: PUSH
37830: LD_INT 0
37832: PUSH
37833: LD_INT 0
37835: PUSH
37836: EMPTY
37837: LIST
37838: LIST
37839: PUSH
37840: LD_INT 0
37842: PUSH
37843: LD_INT 1
37845: NEG
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 1
37853: PUSH
37854: LD_INT 0
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 1
37863: PUSH
37864: LD_INT 1
37866: PUSH
37867: EMPTY
37868: LIST
37869: LIST
37870: PUSH
37871: LD_INT 0
37873: PUSH
37874: LD_INT 1
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 1
37883: NEG
37884: PUSH
37885: LD_INT 0
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: PUSH
37892: LD_INT 1
37894: NEG
37895: PUSH
37896: LD_INT 1
37898: NEG
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: LD_INT 1
37906: NEG
37907: PUSH
37908: LD_INT 2
37910: NEG
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: PUSH
37916: LD_INT 0
37918: PUSH
37919: LD_INT 2
37921: NEG
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: PUSH
37927: LD_INT 1
37929: PUSH
37930: LD_INT 1
37932: NEG
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 2
37940: PUSH
37941: LD_INT 0
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 2
37950: PUSH
37951: LD_INT 1
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: LD_INT 2
37960: PUSH
37961: LD_INT 2
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 1
37970: PUSH
37971: LD_INT 2
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 0
37980: PUSH
37981: LD_INT 2
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: PUSH
37988: LD_INT 1
37990: NEG
37991: PUSH
37992: LD_INT 1
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 2
38001: NEG
38002: PUSH
38003: LD_INT 0
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 2
38012: NEG
38013: PUSH
38014: LD_INT 1
38016: NEG
38017: PUSH
38018: EMPTY
38019: LIST
38020: LIST
38021: PUSH
38022: LD_INT 2
38024: NEG
38025: PUSH
38026: LD_INT 2
38028: NEG
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38055: LD_ADDR_VAR 0 56
38059: PUSH
38060: LD_INT 0
38062: PUSH
38063: LD_INT 0
38065: PUSH
38066: EMPTY
38067: LIST
38068: LIST
38069: PUSH
38070: LD_INT 0
38072: PUSH
38073: LD_INT 1
38075: NEG
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 1
38083: PUSH
38084: LD_INT 0
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 1
38093: PUSH
38094: LD_INT 1
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: LD_INT 0
38103: PUSH
38104: LD_INT 1
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PUSH
38111: LD_INT 1
38113: NEG
38114: PUSH
38115: LD_INT 0
38117: PUSH
38118: EMPTY
38119: LIST
38120: LIST
38121: PUSH
38122: LD_INT 1
38124: NEG
38125: PUSH
38126: LD_INT 1
38128: NEG
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: LD_INT 1
38136: NEG
38137: PUSH
38138: LD_INT 2
38140: NEG
38141: PUSH
38142: EMPTY
38143: LIST
38144: LIST
38145: PUSH
38146: LD_INT 0
38148: PUSH
38149: LD_INT 2
38151: NEG
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: LD_INT 1
38159: PUSH
38160: LD_INT 1
38162: NEG
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 2
38170: PUSH
38171: LD_INT 0
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: LD_INT 2
38180: PUSH
38181: LD_INT 1
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: LD_INT 2
38190: PUSH
38191: LD_INT 2
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: LD_INT 1
38200: PUSH
38201: LD_INT 2
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: PUSH
38208: LD_INT 0
38210: PUSH
38211: LD_INT 2
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 1
38220: NEG
38221: PUSH
38222: LD_INT 1
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: PUSH
38229: LD_INT 2
38231: NEG
38232: PUSH
38233: LD_INT 0
38235: PUSH
38236: EMPTY
38237: LIST
38238: LIST
38239: PUSH
38240: LD_INT 2
38242: NEG
38243: PUSH
38244: LD_INT 1
38246: NEG
38247: PUSH
38248: EMPTY
38249: LIST
38250: LIST
38251: PUSH
38252: LD_INT 2
38254: NEG
38255: PUSH
38256: LD_INT 2
38258: NEG
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: LIST
38275: LIST
38276: LIST
38277: LIST
38278: LIST
38279: LIST
38280: LIST
38281: LIST
38282: LIST
38283: LIST
38284: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38285: LD_ADDR_VAR 0 57
38289: PUSH
38290: LD_INT 0
38292: PUSH
38293: LD_INT 0
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 0
38302: PUSH
38303: LD_INT 1
38305: NEG
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 1
38313: PUSH
38314: LD_INT 0
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 1
38323: PUSH
38324: LD_INT 1
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: LD_INT 0
38333: PUSH
38334: LD_INT 1
38336: PUSH
38337: EMPTY
38338: LIST
38339: LIST
38340: PUSH
38341: LD_INT 1
38343: NEG
38344: PUSH
38345: LD_INT 0
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: PUSH
38352: LD_INT 1
38354: NEG
38355: PUSH
38356: LD_INT 1
38358: NEG
38359: PUSH
38360: EMPTY
38361: LIST
38362: LIST
38363: PUSH
38364: LD_INT 1
38366: NEG
38367: PUSH
38368: LD_INT 2
38370: NEG
38371: PUSH
38372: EMPTY
38373: LIST
38374: LIST
38375: PUSH
38376: LD_INT 0
38378: PUSH
38379: LD_INT 2
38381: NEG
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: LD_INT 1
38392: NEG
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 2
38400: PUSH
38401: LD_INT 0
38403: PUSH
38404: EMPTY
38405: LIST
38406: LIST
38407: PUSH
38408: LD_INT 2
38410: PUSH
38411: LD_INT 1
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 2
38420: PUSH
38421: LD_INT 2
38423: PUSH
38424: EMPTY
38425: LIST
38426: LIST
38427: PUSH
38428: LD_INT 1
38430: PUSH
38431: LD_INT 2
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 0
38440: PUSH
38441: LD_INT 2
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 1
38450: NEG
38451: PUSH
38452: LD_INT 1
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PUSH
38459: LD_INT 2
38461: NEG
38462: PUSH
38463: LD_INT 0
38465: PUSH
38466: EMPTY
38467: LIST
38468: LIST
38469: PUSH
38470: LD_INT 2
38472: NEG
38473: PUSH
38474: LD_INT 1
38476: NEG
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 2
38484: NEG
38485: PUSH
38486: LD_INT 2
38488: NEG
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: LIST
38498: LIST
38499: LIST
38500: LIST
38501: LIST
38502: LIST
38503: LIST
38504: LIST
38505: LIST
38506: LIST
38507: LIST
38508: LIST
38509: LIST
38510: LIST
38511: LIST
38512: LIST
38513: LIST
38514: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38515: LD_ADDR_VAR 0 58
38519: PUSH
38520: LD_INT 0
38522: PUSH
38523: LD_INT 0
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: LD_INT 0
38532: PUSH
38533: LD_INT 1
38535: NEG
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 1
38543: PUSH
38544: LD_INT 0
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 1
38553: PUSH
38554: LD_INT 1
38556: PUSH
38557: EMPTY
38558: LIST
38559: LIST
38560: PUSH
38561: LD_INT 0
38563: PUSH
38564: LD_INT 1
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: LD_INT 1
38573: NEG
38574: PUSH
38575: LD_INT 0
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: LD_INT 1
38588: NEG
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 1
38596: NEG
38597: PUSH
38598: LD_INT 2
38600: NEG
38601: PUSH
38602: EMPTY
38603: LIST
38604: LIST
38605: PUSH
38606: LD_INT 0
38608: PUSH
38609: LD_INT 2
38611: NEG
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 1
38619: PUSH
38620: LD_INT 1
38622: NEG
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PUSH
38628: LD_INT 2
38630: PUSH
38631: LD_INT 0
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 2
38640: PUSH
38641: LD_INT 1
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 2
38650: PUSH
38651: LD_INT 2
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 1
38660: PUSH
38661: LD_INT 2
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 0
38670: PUSH
38671: LD_INT 2
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 1
38680: NEG
38681: PUSH
38682: LD_INT 1
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 2
38691: NEG
38692: PUSH
38693: LD_INT 0
38695: PUSH
38696: EMPTY
38697: LIST
38698: LIST
38699: PUSH
38700: LD_INT 2
38702: NEG
38703: PUSH
38704: LD_INT 1
38706: NEG
38707: PUSH
38708: EMPTY
38709: LIST
38710: LIST
38711: PUSH
38712: LD_INT 2
38714: NEG
38715: PUSH
38716: LD_INT 2
38718: NEG
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: LIST
38728: LIST
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: LIST
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: LIST
38744: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38745: LD_ADDR_VAR 0 59
38749: PUSH
38750: LD_INT 0
38752: PUSH
38753: LD_INT 0
38755: PUSH
38756: EMPTY
38757: LIST
38758: LIST
38759: PUSH
38760: LD_INT 0
38762: PUSH
38763: LD_INT 1
38765: NEG
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 1
38773: PUSH
38774: LD_INT 0
38776: PUSH
38777: EMPTY
38778: LIST
38779: LIST
38780: PUSH
38781: LD_INT 1
38783: PUSH
38784: LD_INT 1
38786: PUSH
38787: EMPTY
38788: LIST
38789: LIST
38790: PUSH
38791: LD_INT 0
38793: PUSH
38794: LD_INT 1
38796: PUSH
38797: EMPTY
38798: LIST
38799: LIST
38800: PUSH
38801: LD_INT 1
38803: NEG
38804: PUSH
38805: LD_INT 0
38807: PUSH
38808: EMPTY
38809: LIST
38810: LIST
38811: PUSH
38812: LD_INT 1
38814: NEG
38815: PUSH
38816: LD_INT 1
38818: NEG
38819: PUSH
38820: EMPTY
38821: LIST
38822: LIST
38823: PUSH
38824: EMPTY
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38833: LD_ADDR_VAR 0 60
38837: PUSH
38838: LD_INT 0
38840: PUSH
38841: LD_INT 0
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 0
38850: PUSH
38851: LD_INT 1
38853: NEG
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 1
38861: PUSH
38862: LD_INT 0
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: PUSH
38869: LD_INT 1
38871: PUSH
38872: LD_INT 1
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: LD_INT 0
38881: PUSH
38882: LD_INT 1
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: LD_INT 1
38891: NEG
38892: PUSH
38893: LD_INT 0
38895: PUSH
38896: EMPTY
38897: LIST
38898: LIST
38899: PUSH
38900: LD_INT 1
38902: NEG
38903: PUSH
38904: LD_INT 1
38906: NEG
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: EMPTY
38913: LIST
38914: LIST
38915: LIST
38916: LIST
38917: LIST
38918: LIST
38919: LIST
38920: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38921: LD_ADDR_VAR 0 61
38925: PUSH
38926: LD_INT 0
38928: PUSH
38929: LD_INT 0
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: PUSH
38936: LD_INT 0
38938: PUSH
38939: LD_INT 1
38941: NEG
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PUSH
38947: LD_INT 1
38949: PUSH
38950: LD_INT 0
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: PUSH
38957: LD_INT 1
38959: PUSH
38960: LD_INT 1
38962: PUSH
38963: EMPTY
38964: LIST
38965: LIST
38966: PUSH
38967: LD_INT 0
38969: PUSH
38970: LD_INT 1
38972: PUSH
38973: EMPTY
38974: LIST
38975: LIST
38976: PUSH
38977: LD_INT 1
38979: NEG
38980: PUSH
38981: LD_INT 0
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 1
38990: NEG
38991: PUSH
38992: LD_INT 1
38994: NEG
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: LIST
39004: LIST
39005: LIST
39006: LIST
39007: LIST
39008: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39009: LD_ADDR_VAR 0 62
39013: PUSH
39014: LD_INT 0
39016: PUSH
39017: LD_INT 0
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PUSH
39024: LD_INT 0
39026: PUSH
39027: LD_INT 1
39029: NEG
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 1
39037: PUSH
39038: LD_INT 0
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 1
39047: PUSH
39048: LD_INT 1
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: LD_INT 0
39057: PUSH
39058: LD_INT 1
39060: PUSH
39061: EMPTY
39062: LIST
39063: LIST
39064: PUSH
39065: LD_INT 1
39067: NEG
39068: PUSH
39069: LD_INT 0
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: PUSH
39076: LD_INT 1
39078: NEG
39079: PUSH
39080: LD_INT 1
39082: NEG
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: LIST
39096: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39097: LD_ADDR_VAR 0 63
39101: PUSH
39102: LD_INT 0
39104: PUSH
39105: LD_INT 0
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 0
39114: PUSH
39115: LD_INT 1
39117: NEG
39118: PUSH
39119: EMPTY
39120: LIST
39121: LIST
39122: PUSH
39123: LD_INT 1
39125: PUSH
39126: LD_INT 0
39128: PUSH
39129: EMPTY
39130: LIST
39131: LIST
39132: PUSH
39133: LD_INT 1
39135: PUSH
39136: LD_INT 1
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 0
39145: PUSH
39146: LD_INT 1
39148: PUSH
39149: EMPTY
39150: LIST
39151: LIST
39152: PUSH
39153: LD_INT 1
39155: NEG
39156: PUSH
39157: LD_INT 0
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 1
39166: NEG
39167: PUSH
39168: LD_INT 1
39170: NEG
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: LIST
39180: LIST
39181: LIST
39182: LIST
39183: LIST
39184: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39185: LD_ADDR_VAR 0 64
39189: PUSH
39190: LD_INT 0
39192: PUSH
39193: LD_INT 0
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 0
39202: PUSH
39203: LD_INT 1
39205: NEG
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: PUSH
39211: LD_INT 1
39213: PUSH
39214: LD_INT 0
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 1
39223: PUSH
39224: LD_INT 1
39226: PUSH
39227: EMPTY
39228: LIST
39229: LIST
39230: PUSH
39231: LD_INT 0
39233: PUSH
39234: LD_INT 1
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: PUSH
39241: LD_INT 1
39243: NEG
39244: PUSH
39245: LD_INT 0
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 1
39254: NEG
39255: PUSH
39256: LD_INT 1
39258: NEG
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: PUSH
39264: EMPTY
39265: LIST
39266: LIST
39267: LIST
39268: LIST
39269: LIST
39270: LIST
39271: LIST
39272: ST_TO_ADDR
// end ; 1 :
39273: GO 45170
39275: LD_INT 1
39277: DOUBLE
39278: EQUAL
39279: IFTRUE 39283
39281: GO 41906
39283: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39284: LD_ADDR_VAR 0 11
39288: PUSH
39289: LD_INT 1
39291: NEG
39292: PUSH
39293: LD_INT 3
39295: NEG
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: LD_INT 0
39303: PUSH
39304: LD_INT 3
39306: NEG
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 1
39314: PUSH
39315: LD_INT 2
39317: NEG
39318: PUSH
39319: EMPTY
39320: LIST
39321: LIST
39322: PUSH
39323: EMPTY
39324: LIST
39325: LIST
39326: LIST
39327: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39328: LD_ADDR_VAR 0 12
39332: PUSH
39333: LD_INT 2
39335: PUSH
39336: LD_INT 1
39338: NEG
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 3
39346: PUSH
39347: LD_INT 0
39349: PUSH
39350: EMPTY
39351: LIST
39352: LIST
39353: PUSH
39354: LD_INT 3
39356: PUSH
39357: LD_INT 1
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: LIST
39368: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39369: LD_ADDR_VAR 0 13
39373: PUSH
39374: LD_INT 3
39376: PUSH
39377: LD_INT 2
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 3
39386: PUSH
39387: LD_INT 3
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 2
39396: PUSH
39397: LD_INT 3
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: LIST
39408: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39409: LD_ADDR_VAR 0 14
39413: PUSH
39414: LD_INT 1
39416: PUSH
39417: LD_INT 3
39419: PUSH
39420: EMPTY
39421: LIST
39422: LIST
39423: PUSH
39424: LD_INT 0
39426: PUSH
39427: LD_INT 3
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PUSH
39434: LD_INT 1
39436: NEG
39437: PUSH
39438: LD_INT 2
39440: PUSH
39441: EMPTY
39442: LIST
39443: LIST
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: LIST
39449: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39450: LD_ADDR_VAR 0 15
39454: PUSH
39455: LD_INT 2
39457: NEG
39458: PUSH
39459: LD_INT 1
39461: PUSH
39462: EMPTY
39463: LIST
39464: LIST
39465: PUSH
39466: LD_INT 3
39468: NEG
39469: PUSH
39470: LD_INT 0
39472: PUSH
39473: EMPTY
39474: LIST
39475: LIST
39476: PUSH
39477: LD_INT 3
39479: NEG
39480: PUSH
39481: LD_INT 1
39483: NEG
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: LIST
39493: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39494: LD_ADDR_VAR 0 16
39498: PUSH
39499: LD_INT 2
39501: NEG
39502: PUSH
39503: LD_INT 3
39505: NEG
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PUSH
39511: LD_INT 3
39513: NEG
39514: PUSH
39515: LD_INT 2
39517: NEG
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 3
39525: NEG
39526: PUSH
39527: LD_INT 3
39529: NEG
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: LIST
39539: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39540: LD_ADDR_VAR 0 17
39544: PUSH
39545: LD_INT 1
39547: NEG
39548: PUSH
39549: LD_INT 3
39551: NEG
39552: PUSH
39553: EMPTY
39554: LIST
39555: LIST
39556: PUSH
39557: LD_INT 0
39559: PUSH
39560: LD_INT 3
39562: NEG
39563: PUSH
39564: EMPTY
39565: LIST
39566: LIST
39567: PUSH
39568: LD_INT 1
39570: PUSH
39571: LD_INT 2
39573: NEG
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: LIST
39583: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39584: LD_ADDR_VAR 0 18
39588: PUSH
39589: LD_INT 2
39591: PUSH
39592: LD_INT 1
39594: NEG
39595: PUSH
39596: EMPTY
39597: LIST
39598: LIST
39599: PUSH
39600: LD_INT 3
39602: PUSH
39603: LD_INT 0
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: PUSH
39610: LD_INT 3
39612: PUSH
39613: LD_INT 1
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: LIST
39624: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39625: LD_ADDR_VAR 0 19
39629: PUSH
39630: LD_INT 3
39632: PUSH
39633: LD_INT 2
39635: PUSH
39636: EMPTY
39637: LIST
39638: LIST
39639: PUSH
39640: LD_INT 3
39642: PUSH
39643: LD_INT 3
39645: PUSH
39646: EMPTY
39647: LIST
39648: LIST
39649: PUSH
39650: LD_INT 2
39652: PUSH
39653: LD_INT 3
39655: PUSH
39656: EMPTY
39657: LIST
39658: LIST
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: LIST
39664: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39665: LD_ADDR_VAR 0 20
39669: PUSH
39670: LD_INT 1
39672: PUSH
39673: LD_INT 3
39675: PUSH
39676: EMPTY
39677: LIST
39678: LIST
39679: PUSH
39680: LD_INT 0
39682: PUSH
39683: LD_INT 3
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 1
39692: NEG
39693: PUSH
39694: LD_INT 2
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: LIST
39705: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39706: LD_ADDR_VAR 0 21
39710: PUSH
39711: LD_INT 2
39713: NEG
39714: PUSH
39715: LD_INT 1
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: PUSH
39722: LD_INT 3
39724: NEG
39725: PUSH
39726: LD_INT 0
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PUSH
39733: LD_INT 3
39735: NEG
39736: PUSH
39737: LD_INT 1
39739: NEG
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: LIST
39749: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39750: LD_ADDR_VAR 0 22
39754: PUSH
39755: LD_INT 2
39757: NEG
39758: PUSH
39759: LD_INT 3
39761: NEG
39762: PUSH
39763: EMPTY
39764: LIST
39765: LIST
39766: PUSH
39767: LD_INT 3
39769: NEG
39770: PUSH
39771: LD_INT 2
39773: NEG
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 3
39781: NEG
39782: PUSH
39783: LD_INT 3
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: LIST
39795: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39796: LD_ADDR_VAR 0 23
39800: PUSH
39801: LD_INT 0
39803: PUSH
39804: LD_INT 3
39806: NEG
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 1
39814: NEG
39815: PUSH
39816: LD_INT 4
39818: NEG
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 1
39826: PUSH
39827: LD_INT 3
39829: NEG
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: LIST
39839: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39840: LD_ADDR_VAR 0 24
39844: PUSH
39845: LD_INT 3
39847: PUSH
39848: LD_INT 0
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 3
39857: PUSH
39858: LD_INT 1
39860: NEG
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 4
39868: PUSH
39869: LD_INT 1
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: LIST
39880: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39881: LD_ADDR_VAR 0 25
39885: PUSH
39886: LD_INT 3
39888: PUSH
39889: LD_INT 3
39891: PUSH
39892: EMPTY
39893: LIST
39894: LIST
39895: PUSH
39896: LD_INT 4
39898: PUSH
39899: LD_INT 3
39901: PUSH
39902: EMPTY
39903: LIST
39904: LIST
39905: PUSH
39906: LD_INT 3
39908: PUSH
39909: LD_INT 4
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: LIST
39920: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39921: LD_ADDR_VAR 0 26
39925: PUSH
39926: LD_INT 0
39928: PUSH
39929: LD_INT 3
39931: PUSH
39932: EMPTY
39933: LIST
39934: LIST
39935: PUSH
39936: LD_INT 1
39938: PUSH
39939: LD_INT 4
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PUSH
39946: LD_INT 1
39948: NEG
39949: PUSH
39950: LD_INT 3
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: LIST
39961: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
39962: LD_ADDR_VAR 0 27
39966: PUSH
39967: LD_INT 3
39969: NEG
39970: PUSH
39971: LD_INT 0
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: PUSH
39978: LD_INT 3
39980: NEG
39981: PUSH
39982: LD_INT 1
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 4
39991: NEG
39992: PUSH
39993: LD_INT 1
39995: NEG
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: EMPTY
40002: LIST
40003: LIST
40004: LIST
40005: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40006: LD_ADDR_VAR 0 28
40010: PUSH
40011: LD_INT 3
40013: NEG
40014: PUSH
40015: LD_INT 3
40017: NEG
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PUSH
40023: LD_INT 3
40025: NEG
40026: PUSH
40027: LD_INT 4
40029: NEG
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PUSH
40035: LD_INT 4
40037: NEG
40038: PUSH
40039: LD_INT 3
40041: NEG
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: LIST
40051: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40052: LD_ADDR_VAR 0 29
40056: PUSH
40057: LD_INT 1
40059: NEG
40060: PUSH
40061: LD_INT 3
40063: NEG
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 0
40071: PUSH
40072: LD_INT 3
40074: NEG
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: LD_INT 1
40082: PUSH
40083: LD_INT 2
40085: NEG
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 1
40093: NEG
40094: PUSH
40095: LD_INT 4
40097: NEG
40098: PUSH
40099: EMPTY
40100: LIST
40101: LIST
40102: PUSH
40103: LD_INT 0
40105: PUSH
40106: LD_INT 4
40108: NEG
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PUSH
40114: LD_INT 1
40116: PUSH
40117: LD_INT 3
40119: NEG
40120: PUSH
40121: EMPTY
40122: LIST
40123: LIST
40124: PUSH
40125: LD_INT 1
40127: NEG
40128: PUSH
40129: LD_INT 5
40131: NEG
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PUSH
40137: LD_INT 0
40139: PUSH
40140: LD_INT 5
40142: NEG
40143: PUSH
40144: EMPTY
40145: LIST
40146: LIST
40147: PUSH
40148: LD_INT 1
40150: PUSH
40151: LD_INT 4
40153: NEG
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: PUSH
40159: LD_INT 1
40161: NEG
40162: PUSH
40163: LD_INT 6
40165: NEG
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: PUSH
40171: LD_INT 0
40173: PUSH
40174: LD_INT 6
40176: NEG
40177: PUSH
40178: EMPTY
40179: LIST
40180: LIST
40181: PUSH
40182: LD_INT 1
40184: PUSH
40185: LD_INT 5
40187: NEG
40188: PUSH
40189: EMPTY
40190: LIST
40191: LIST
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: LIST
40197: LIST
40198: LIST
40199: LIST
40200: LIST
40201: LIST
40202: LIST
40203: LIST
40204: LIST
40205: LIST
40206: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40207: LD_ADDR_VAR 0 30
40211: PUSH
40212: LD_INT 2
40214: PUSH
40215: LD_INT 1
40217: NEG
40218: PUSH
40219: EMPTY
40220: LIST
40221: LIST
40222: PUSH
40223: LD_INT 3
40225: PUSH
40226: LD_INT 0
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: LD_INT 3
40235: PUSH
40236: LD_INT 1
40238: PUSH
40239: EMPTY
40240: LIST
40241: LIST
40242: PUSH
40243: LD_INT 3
40245: PUSH
40246: LD_INT 1
40248: NEG
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 4
40256: PUSH
40257: LD_INT 0
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 4
40266: PUSH
40267: LD_INT 1
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 4
40276: PUSH
40277: LD_INT 1
40279: NEG
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 5
40287: PUSH
40288: LD_INT 0
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 5
40297: PUSH
40298: LD_INT 1
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: LD_INT 5
40307: PUSH
40308: LD_INT 1
40310: NEG
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: LD_INT 6
40318: PUSH
40319: LD_INT 0
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 6
40328: PUSH
40329: LD_INT 1
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: LIST
40340: LIST
40341: LIST
40342: LIST
40343: LIST
40344: LIST
40345: LIST
40346: LIST
40347: LIST
40348: LIST
40349: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
40350: LD_ADDR_VAR 0 31
40354: PUSH
40355: LD_INT 3
40357: PUSH
40358: LD_INT 2
40360: PUSH
40361: EMPTY
40362: LIST
40363: LIST
40364: PUSH
40365: LD_INT 3
40367: PUSH
40368: LD_INT 3
40370: PUSH
40371: EMPTY
40372: LIST
40373: LIST
40374: PUSH
40375: LD_INT 2
40377: PUSH
40378: LD_INT 3
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: LD_INT 4
40387: PUSH
40388: LD_INT 3
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: PUSH
40395: LD_INT 4
40397: PUSH
40398: LD_INT 4
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 3
40407: PUSH
40408: LD_INT 4
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: PUSH
40415: LD_INT 5
40417: PUSH
40418: LD_INT 4
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: PUSH
40425: LD_INT 5
40427: PUSH
40428: LD_INT 5
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: PUSH
40435: LD_INT 4
40437: PUSH
40438: LD_INT 5
40440: PUSH
40441: EMPTY
40442: LIST
40443: LIST
40444: PUSH
40445: LD_INT 6
40447: PUSH
40448: LD_INT 5
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: LD_INT 6
40457: PUSH
40458: LD_INT 6
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: LD_INT 5
40467: PUSH
40468: LD_INT 6
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: LIST
40479: LIST
40480: LIST
40481: LIST
40482: LIST
40483: LIST
40484: LIST
40485: LIST
40486: LIST
40487: LIST
40488: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40489: LD_ADDR_VAR 0 32
40493: PUSH
40494: LD_INT 1
40496: PUSH
40497: LD_INT 3
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 0
40506: PUSH
40507: LD_INT 3
40509: PUSH
40510: EMPTY
40511: LIST
40512: LIST
40513: PUSH
40514: LD_INT 1
40516: NEG
40517: PUSH
40518: LD_INT 2
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 1
40527: PUSH
40528: LD_INT 4
40530: PUSH
40531: EMPTY
40532: LIST
40533: LIST
40534: PUSH
40535: LD_INT 0
40537: PUSH
40538: LD_INT 4
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: PUSH
40545: LD_INT 1
40547: NEG
40548: PUSH
40549: LD_INT 3
40551: PUSH
40552: EMPTY
40553: LIST
40554: LIST
40555: PUSH
40556: LD_INT 1
40558: PUSH
40559: LD_INT 5
40561: PUSH
40562: EMPTY
40563: LIST
40564: LIST
40565: PUSH
40566: LD_INT 0
40568: PUSH
40569: LD_INT 5
40571: PUSH
40572: EMPTY
40573: LIST
40574: LIST
40575: PUSH
40576: LD_INT 1
40578: NEG
40579: PUSH
40580: LD_INT 4
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: PUSH
40587: LD_INT 1
40589: PUSH
40590: LD_INT 6
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: PUSH
40597: LD_INT 0
40599: PUSH
40600: LD_INT 6
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PUSH
40607: LD_INT 1
40609: NEG
40610: PUSH
40611: LD_INT 5
40613: PUSH
40614: EMPTY
40615: LIST
40616: LIST
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: LIST
40622: LIST
40623: LIST
40624: LIST
40625: LIST
40626: LIST
40627: LIST
40628: LIST
40629: LIST
40630: LIST
40631: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
40632: LD_ADDR_VAR 0 33
40636: PUSH
40637: LD_INT 2
40639: NEG
40640: PUSH
40641: LD_INT 1
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: PUSH
40648: LD_INT 3
40650: NEG
40651: PUSH
40652: LD_INT 0
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 3
40661: NEG
40662: PUSH
40663: LD_INT 1
40665: NEG
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PUSH
40671: LD_INT 3
40673: NEG
40674: PUSH
40675: LD_INT 1
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PUSH
40682: LD_INT 4
40684: NEG
40685: PUSH
40686: LD_INT 0
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: PUSH
40693: LD_INT 4
40695: NEG
40696: PUSH
40697: LD_INT 1
40699: NEG
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: PUSH
40705: LD_INT 4
40707: NEG
40708: PUSH
40709: LD_INT 1
40711: PUSH
40712: EMPTY
40713: LIST
40714: LIST
40715: PUSH
40716: LD_INT 5
40718: NEG
40719: PUSH
40720: LD_INT 0
40722: PUSH
40723: EMPTY
40724: LIST
40725: LIST
40726: PUSH
40727: LD_INT 5
40729: NEG
40730: PUSH
40731: LD_INT 1
40733: NEG
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: LD_INT 5
40741: NEG
40742: PUSH
40743: LD_INT 1
40745: PUSH
40746: EMPTY
40747: LIST
40748: LIST
40749: PUSH
40750: LD_INT 6
40752: NEG
40753: PUSH
40754: LD_INT 0
40756: PUSH
40757: EMPTY
40758: LIST
40759: LIST
40760: PUSH
40761: LD_INT 6
40763: NEG
40764: PUSH
40765: LD_INT 1
40767: NEG
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: LIST
40777: LIST
40778: LIST
40779: LIST
40780: LIST
40781: LIST
40782: LIST
40783: LIST
40784: LIST
40785: LIST
40786: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40787: LD_ADDR_VAR 0 34
40791: PUSH
40792: LD_INT 2
40794: NEG
40795: PUSH
40796: LD_INT 3
40798: NEG
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 3
40806: NEG
40807: PUSH
40808: LD_INT 2
40810: NEG
40811: PUSH
40812: EMPTY
40813: LIST
40814: LIST
40815: PUSH
40816: LD_INT 3
40818: NEG
40819: PUSH
40820: LD_INT 3
40822: NEG
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: LD_INT 3
40830: NEG
40831: PUSH
40832: LD_INT 4
40834: NEG
40835: PUSH
40836: EMPTY
40837: LIST
40838: LIST
40839: PUSH
40840: LD_INT 4
40842: NEG
40843: PUSH
40844: LD_INT 3
40846: NEG
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 4
40854: NEG
40855: PUSH
40856: LD_INT 4
40858: NEG
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: PUSH
40864: LD_INT 4
40866: NEG
40867: PUSH
40868: LD_INT 5
40870: NEG
40871: PUSH
40872: EMPTY
40873: LIST
40874: LIST
40875: PUSH
40876: LD_INT 5
40878: NEG
40879: PUSH
40880: LD_INT 4
40882: NEG
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 5
40890: NEG
40891: PUSH
40892: LD_INT 5
40894: NEG
40895: PUSH
40896: EMPTY
40897: LIST
40898: LIST
40899: PUSH
40900: LD_INT 5
40902: NEG
40903: PUSH
40904: LD_INT 6
40906: NEG
40907: PUSH
40908: EMPTY
40909: LIST
40910: LIST
40911: PUSH
40912: LD_INT 6
40914: NEG
40915: PUSH
40916: LD_INT 5
40918: NEG
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: LD_INT 6
40926: NEG
40927: PUSH
40928: LD_INT 6
40930: NEG
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: LIST
40940: LIST
40941: LIST
40942: LIST
40943: LIST
40944: LIST
40945: LIST
40946: LIST
40947: LIST
40948: LIST
40949: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
40950: LD_ADDR_VAR 0 41
40954: PUSH
40955: LD_INT 0
40957: PUSH
40958: LD_INT 2
40960: NEG
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 1
40968: NEG
40969: PUSH
40970: LD_INT 3
40972: NEG
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: PUSH
40978: LD_INT 1
40980: PUSH
40981: LD_INT 2
40983: NEG
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: PUSH
40989: EMPTY
40990: LIST
40991: LIST
40992: LIST
40993: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
40994: LD_ADDR_VAR 0 42
40998: PUSH
40999: LD_INT 2
41001: PUSH
41002: LD_INT 0
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 2
41011: PUSH
41012: LD_INT 1
41014: NEG
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: PUSH
41020: LD_INT 3
41022: PUSH
41023: LD_INT 1
41025: PUSH
41026: EMPTY
41027: LIST
41028: LIST
41029: PUSH
41030: EMPTY
41031: LIST
41032: LIST
41033: LIST
41034: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41035: LD_ADDR_VAR 0 43
41039: PUSH
41040: LD_INT 2
41042: PUSH
41043: LD_INT 2
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: PUSH
41050: LD_INT 3
41052: PUSH
41053: LD_INT 2
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 2
41062: PUSH
41063: LD_INT 3
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: EMPTY
41071: LIST
41072: LIST
41073: LIST
41074: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41075: LD_ADDR_VAR 0 44
41079: PUSH
41080: LD_INT 0
41082: PUSH
41083: LD_INT 2
41085: PUSH
41086: EMPTY
41087: LIST
41088: LIST
41089: PUSH
41090: LD_INT 1
41092: PUSH
41093: LD_INT 3
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 1
41102: NEG
41103: PUSH
41104: LD_INT 2
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: LIST
41115: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41116: LD_ADDR_VAR 0 45
41120: PUSH
41121: LD_INT 2
41123: NEG
41124: PUSH
41125: LD_INT 0
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: LD_INT 2
41134: NEG
41135: PUSH
41136: LD_INT 1
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PUSH
41143: LD_INT 3
41145: NEG
41146: PUSH
41147: LD_INT 1
41149: NEG
41150: PUSH
41151: EMPTY
41152: LIST
41153: LIST
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: LIST
41159: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41160: LD_ADDR_VAR 0 46
41164: PUSH
41165: LD_INT 2
41167: NEG
41168: PUSH
41169: LD_INT 2
41171: NEG
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 2
41179: NEG
41180: PUSH
41181: LD_INT 3
41183: NEG
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: LD_INT 3
41191: NEG
41192: PUSH
41193: LD_INT 2
41195: NEG
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: EMPTY
41202: LIST
41203: LIST
41204: LIST
41205: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41206: LD_ADDR_VAR 0 47
41210: PUSH
41211: LD_INT 2
41213: NEG
41214: PUSH
41215: LD_INT 3
41217: NEG
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: LD_INT 1
41225: NEG
41226: PUSH
41227: LD_INT 3
41229: NEG
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: EMPTY
41236: LIST
41237: LIST
41238: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41239: LD_ADDR_VAR 0 48
41243: PUSH
41244: LD_INT 1
41246: PUSH
41247: LD_INT 2
41249: NEG
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: PUSH
41255: LD_INT 2
41257: PUSH
41258: LD_INT 1
41260: NEG
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: EMPTY
41267: LIST
41268: LIST
41269: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
41270: LD_ADDR_VAR 0 49
41274: PUSH
41275: LD_INT 3
41277: PUSH
41278: LD_INT 1
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: LD_INT 3
41287: PUSH
41288: LD_INT 2
41290: PUSH
41291: EMPTY
41292: LIST
41293: LIST
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
41299: LD_ADDR_VAR 0 50
41303: PUSH
41304: LD_INT 2
41306: PUSH
41307: LD_INT 3
41309: PUSH
41310: EMPTY
41311: LIST
41312: LIST
41313: PUSH
41314: LD_INT 1
41316: PUSH
41317: LD_INT 3
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
41328: LD_ADDR_VAR 0 51
41332: PUSH
41333: LD_INT 1
41335: NEG
41336: PUSH
41337: LD_INT 2
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: LD_INT 2
41346: NEG
41347: PUSH
41348: LD_INT 1
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41359: LD_ADDR_VAR 0 52
41363: PUSH
41364: LD_INT 3
41366: NEG
41367: PUSH
41368: LD_INT 1
41370: NEG
41371: PUSH
41372: EMPTY
41373: LIST
41374: LIST
41375: PUSH
41376: LD_INT 3
41378: NEG
41379: PUSH
41380: LD_INT 2
41382: NEG
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41392: LD_ADDR_VAR 0 53
41396: PUSH
41397: LD_INT 1
41399: NEG
41400: PUSH
41401: LD_INT 3
41403: NEG
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 0
41411: PUSH
41412: LD_INT 3
41414: NEG
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 1
41422: PUSH
41423: LD_INT 2
41425: NEG
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: PUSH
41431: EMPTY
41432: LIST
41433: LIST
41434: LIST
41435: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41436: LD_ADDR_VAR 0 54
41440: PUSH
41441: LD_INT 2
41443: PUSH
41444: LD_INT 1
41446: NEG
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: PUSH
41452: LD_INT 3
41454: PUSH
41455: LD_INT 0
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: LD_INT 3
41464: PUSH
41465: LD_INT 1
41467: PUSH
41468: EMPTY
41469: LIST
41470: LIST
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: LIST
41476: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41477: LD_ADDR_VAR 0 55
41481: PUSH
41482: LD_INT 3
41484: PUSH
41485: LD_INT 2
41487: PUSH
41488: EMPTY
41489: LIST
41490: LIST
41491: PUSH
41492: LD_INT 3
41494: PUSH
41495: LD_INT 3
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: PUSH
41502: LD_INT 2
41504: PUSH
41505: LD_INT 3
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: PUSH
41512: EMPTY
41513: LIST
41514: LIST
41515: LIST
41516: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41517: LD_ADDR_VAR 0 56
41521: PUSH
41522: LD_INT 1
41524: PUSH
41525: LD_INT 3
41527: PUSH
41528: EMPTY
41529: LIST
41530: LIST
41531: PUSH
41532: LD_INT 0
41534: PUSH
41535: LD_INT 3
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: PUSH
41542: LD_INT 1
41544: NEG
41545: PUSH
41546: LD_INT 2
41548: PUSH
41549: EMPTY
41550: LIST
41551: LIST
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: LIST
41557: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41558: LD_ADDR_VAR 0 57
41562: PUSH
41563: LD_INT 2
41565: NEG
41566: PUSH
41567: LD_INT 1
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: PUSH
41574: LD_INT 3
41576: NEG
41577: PUSH
41578: LD_INT 0
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: LD_INT 3
41587: NEG
41588: PUSH
41589: LD_INT 1
41591: NEG
41592: PUSH
41593: EMPTY
41594: LIST
41595: LIST
41596: PUSH
41597: EMPTY
41598: LIST
41599: LIST
41600: LIST
41601: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41602: LD_ADDR_VAR 0 58
41606: PUSH
41607: LD_INT 2
41609: NEG
41610: PUSH
41611: LD_INT 3
41613: NEG
41614: PUSH
41615: EMPTY
41616: LIST
41617: LIST
41618: PUSH
41619: LD_INT 3
41621: NEG
41622: PUSH
41623: LD_INT 2
41625: NEG
41626: PUSH
41627: EMPTY
41628: LIST
41629: LIST
41630: PUSH
41631: LD_INT 3
41633: NEG
41634: PUSH
41635: LD_INT 3
41637: NEG
41638: PUSH
41639: EMPTY
41640: LIST
41641: LIST
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: LIST
41647: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
41648: LD_ADDR_VAR 0 59
41652: PUSH
41653: LD_INT 1
41655: NEG
41656: PUSH
41657: LD_INT 2
41659: NEG
41660: PUSH
41661: EMPTY
41662: LIST
41663: LIST
41664: PUSH
41665: LD_INT 0
41667: PUSH
41668: LD_INT 2
41670: NEG
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 1
41678: PUSH
41679: LD_INT 1
41681: NEG
41682: PUSH
41683: EMPTY
41684: LIST
41685: LIST
41686: PUSH
41687: EMPTY
41688: LIST
41689: LIST
41690: LIST
41691: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41692: LD_ADDR_VAR 0 60
41696: PUSH
41697: LD_INT 1
41699: PUSH
41700: LD_INT 1
41702: NEG
41703: PUSH
41704: EMPTY
41705: LIST
41706: LIST
41707: PUSH
41708: LD_INT 2
41710: PUSH
41711: LD_INT 0
41713: PUSH
41714: EMPTY
41715: LIST
41716: LIST
41717: PUSH
41718: LD_INT 2
41720: PUSH
41721: LD_INT 1
41723: PUSH
41724: EMPTY
41725: LIST
41726: LIST
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: LIST
41732: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41733: LD_ADDR_VAR 0 61
41737: PUSH
41738: LD_INT 2
41740: PUSH
41741: LD_INT 1
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PUSH
41748: LD_INT 2
41750: PUSH
41751: LD_INT 2
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PUSH
41758: LD_INT 1
41760: PUSH
41761: LD_INT 2
41763: PUSH
41764: EMPTY
41765: LIST
41766: LIST
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: LIST
41772: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41773: LD_ADDR_VAR 0 62
41777: PUSH
41778: LD_INT 1
41780: PUSH
41781: LD_INT 2
41783: PUSH
41784: EMPTY
41785: LIST
41786: LIST
41787: PUSH
41788: LD_INT 0
41790: PUSH
41791: LD_INT 2
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PUSH
41798: LD_INT 1
41800: NEG
41801: PUSH
41802: LD_INT 1
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: LIST
41813: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41814: LD_ADDR_VAR 0 63
41818: PUSH
41819: LD_INT 1
41821: NEG
41822: PUSH
41823: LD_INT 1
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 2
41832: NEG
41833: PUSH
41834: LD_INT 0
41836: PUSH
41837: EMPTY
41838: LIST
41839: LIST
41840: PUSH
41841: LD_INT 2
41843: NEG
41844: PUSH
41845: LD_INT 1
41847: NEG
41848: PUSH
41849: EMPTY
41850: LIST
41851: LIST
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: LIST
41857: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41858: LD_ADDR_VAR 0 64
41862: PUSH
41863: LD_INT 1
41865: NEG
41866: PUSH
41867: LD_INT 2
41869: NEG
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 2
41877: NEG
41878: PUSH
41879: LD_INT 1
41881: NEG
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: LD_INT 2
41889: NEG
41890: PUSH
41891: LD_INT 2
41893: NEG
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: LIST
41903: ST_TO_ADDR
// end ; 2 :
41904: GO 45170
41906: LD_INT 2
41908: DOUBLE
41909: EQUAL
41910: IFTRUE 41914
41912: GO 45169
41914: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41915: LD_ADDR_VAR 0 29
41919: PUSH
41920: LD_INT 4
41922: PUSH
41923: LD_INT 0
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: LD_INT 4
41932: PUSH
41933: LD_INT 1
41935: NEG
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PUSH
41941: LD_INT 5
41943: PUSH
41944: LD_INT 0
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PUSH
41951: LD_INT 5
41953: PUSH
41954: LD_INT 1
41956: PUSH
41957: EMPTY
41958: LIST
41959: LIST
41960: PUSH
41961: LD_INT 4
41963: PUSH
41964: LD_INT 1
41966: PUSH
41967: EMPTY
41968: LIST
41969: LIST
41970: PUSH
41971: LD_INT 3
41973: PUSH
41974: LD_INT 0
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: PUSH
41981: LD_INT 3
41983: PUSH
41984: LD_INT 1
41986: NEG
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: LD_INT 3
41994: PUSH
41995: LD_INT 2
41997: NEG
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: PUSH
42003: LD_INT 5
42005: PUSH
42006: LD_INT 2
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: PUSH
42013: LD_INT 3
42015: PUSH
42016: LD_INT 3
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: PUSH
42023: LD_INT 3
42025: PUSH
42026: LD_INT 2
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: PUSH
42033: LD_INT 4
42035: PUSH
42036: LD_INT 3
42038: PUSH
42039: EMPTY
42040: LIST
42041: LIST
42042: PUSH
42043: LD_INT 4
42045: PUSH
42046: LD_INT 4
42048: PUSH
42049: EMPTY
42050: LIST
42051: LIST
42052: PUSH
42053: LD_INT 3
42055: PUSH
42056: LD_INT 4
42058: PUSH
42059: EMPTY
42060: LIST
42061: LIST
42062: PUSH
42063: LD_INT 2
42065: PUSH
42066: LD_INT 3
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: PUSH
42073: LD_INT 2
42075: PUSH
42076: LD_INT 2
42078: PUSH
42079: EMPTY
42080: LIST
42081: LIST
42082: PUSH
42083: LD_INT 4
42085: PUSH
42086: LD_INT 2
42088: PUSH
42089: EMPTY
42090: LIST
42091: LIST
42092: PUSH
42093: LD_INT 2
42095: PUSH
42096: LD_INT 4
42098: PUSH
42099: EMPTY
42100: LIST
42101: LIST
42102: PUSH
42103: LD_INT 0
42105: PUSH
42106: LD_INT 4
42108: PUSH
42109: EMPTY
42110: LIST
42111: LIST
42112: PUSH
42113: LD_INT 0
42115: PUSH
42116: LD_INT 3
42118: PUSH
42119: EMPTY
42120: LIST
42121: LIST
42122: PUSH
42123: LD_INT 1
42125: PUSH
42126: LD_INT 4
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: PUSH
42133: LD_INT 1
42135: PUSH
42136: LD_INT 5
42138: PUSH
42139: EMPTY
42140: LIST
42141: LIST
42142: PUSH
42143: LD_INT 0
42145: PUSH
42146: LD_INT 5
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PUSH
42153: LD_INT 1
42155: NEG
42156: PUSH
42157: LD_INT 4
42159: PUSH
42160: EMPTY
42161: LIST
42162: LIST
42163: PUSH
42164: LD_INT 1
42166: NEG
42167: PUSH
42168: LD_INT 3
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: PUSH
42175: LD_INT 2
42177: PUSH
42178: LD_INT 5
42180: PUSH
42181: EMPTY
42182: LIST
42183: LIST
42184: PUSH
42185: LD_INT 2
42187: NEG
42188: PUSH
42189: LD_INT 3
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: LD_INT 3
42198: NEG
42199: PUSH
42200: LD_INT 0
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: LD_INT 3
42209: NEG
42210: PUSH
42211: LD_INT 1
42213: NEG
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: PUSH
42219: LD_INT 2
42221: NEG
42222: PUSH
42223: LD_INT 0
42225: PUSH
42226: EMPTY
42227: LIST
42228: LIST
42229: PUSH
42230: LD_INT 2
42232: NEG
42233: PUSH
42234: LD_INT 1
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 3
42243: NEG
42244: PUSH
42245: LD_INT 1
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 4
42254: NEG
42255: PUSH
42256: LD_INT 0
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 4
42265: NEG
42266: PUSH
42267: LD_INT 1
42269: NEG
42270: PUSH
42271: EMPTY
42272: LIST
42273: LIST
42274: PUSH
42275: LD_INT 4
42277: NEG
42278: PUSH
42279: LD_INT 2
42281: NEG
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: PUSH
42287: LD_INT 2
42289: NEG
42290: PUSH
42291: LD_INT 2
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: PUSH
42298: LD_INT 4
42300: NEG
42301: PUSH
42302: LD_INT 4
42304: NEG
42305: PUSH
42306: EMPTY
42307: LIST
42308: LIST
42309: PUSH
42310: LD_INT 4
42312: NEG
42313: PUSH
42314: LD_INT 5
42316: NEG
42317: PUSH
42318: EMPTY
42319: LIST
42320: LIST
42321: PUSH
42322: LD_INT 3
42324: NEG
42325: PUSH
42326: LD_INT 4
42328: NEG
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: PUSH
42334: LD_INT 3
42336: NEG
42337: PUSH
42338: LD_INT 3
42340: NEG
42341: PUSH
42342: EMPTY
42343: LIST
42344: LIST
42345: PUSH
42346: LD_INT 4
42348: NEG
42349: PUSH
42350: LD_INT 3
42352: NEG
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 5
42360: NEG
42361: PUSH
42362: LD_INT 4
42364: NEG
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 5
42372: NEG
42373: PUSH
42374: LD_INT 5
42376: NEG
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: PUSH
42382: LD_INT 3
42384: NEG
42385: PUSH
42386: LD_INT 5
42388: NEG
42389: PUSH
42390: EMPTY
42391: LIST
42392: LIST
42393: PUSH
42394: LD_INT 5
42396: NEG
42397: PUSH
42398: LD_INT 3
42400: NEG
42401: PUSH
42402: EMPTY
42403: LIST
42404: LIST
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: LIST
42410: LIST
42411: LIST
42412: LIST
42413: LIST
42414: LIST
42415: LIST
42416: LIST
42417: LIST
42418: LIST
42419: LIST
42420: LIST
42421: LIST
42422: LIST
42423: LIST
42424: LIST
42425: LIST
42426: LIST
42427: LIST
42428: LIST
42429: LIST
42430: LIST
42431: LIST
42432: LIST
42433: LIST
42434: LIST
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: LIST
42443: LIST
42444: LIST
42445: LIST
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42453: LD_ADDR_VAR 0 30
42457: PUSH
42458: LD_INT 4
42460: PUSH
42461: LD_INT 4
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: PUSH
42468: LD_INT 4
42470: PUSH
42471: LD_INT 3
42473: PUSH
42474: EMPTY
42475: LIST
42476: LIST
42477: PUSH
42478: LD_INT 5
42480: PUSH
42481: LD_INT 4
42483: PUSH
42484: EMPTY
42485: LIST
42486: LIST
42487: PUSH
42488: LD_INT 5
42490: PUSH
42491: LD_INT 5
42493: PUSH
42494: EMPTY
42495: LIST
42496: LIST
42497: PUSH
42498: LD_INT 4
42500: PUSH
42501: LD_INT 5
42503: PUSH
42504: EMPTY
42505: LIST
42506: LIST
42507: PUSH
42508: LD_INT 3
42510: PUSH
42511: LD_INT 4
42513: PUSH
42514: EMPTY
42515: LIST
42516: LIST
42517: PUSH
42518: LD_INT 3
42520: PUSH
42521: LD_INT 3
42523: PUSH
42524: EMPTY
42525: LIST
42526: LIST
42527: PUSH
42528: LD_INT 5
42530: PUSH
42531: LD_INT 3
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: LD_INT 3
42540: PUSH
42541: LD_INT 5
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PUSH
42548: LD_INT 0
42550: PUSH
42551: LD_INT 3
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PUSH
42558: LD_INT 0
42560: PUSH
42561: LD_INT 2
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: PUSH
42568: LD_INT 1
42570: PUSH
42571: LD_INT 3
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: PUSH
42578: LD_INT 1
42580: PUSH
42581: LD_INT 4
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: PUSH
42588: LD_INT 0
42590: PUSH
42591: LD_INT 4
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: LD_INT 1
42600: NEG
42601: PUSH
42602: LD_INT 3
42604: PUSH
42605: EMPTY
42606: LIST
42607: LIST
42608: PUSH
42609: LD_INT 1
42611: NEG
42612: PUSH
42613: LD_INT 2
42615: PUSH
42616: EMPTY
42617: LIST
42618: LIST
42619: PUSH
42620: LD_INT 2
42622: PUSH
42623: LD_INT 4
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: PUSH
42630: LD_INT 2
42632: NEG
42633: PUSH
42634: LD_INT 2
42636: PUSH
42637: EMPTY
42638: LIST
42639: LIST
42640: PUSH
42641: LD_INT 4
42643: NEG
42644: PUSH
42645: LD_INT 0
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: PUSH
42652: LD_INT 4
42654: NEG
42655: PUSH
42656: LD_INT 1
42658: NEG
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 3
42666: NEG
42667: PUSH
42668: LD_INT 0
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: PUSH
42675: LD_INT 3
42677: NEG
42678: PUSH
42679: LD_INT 1
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: PUSH
42686: LD_INT 4
42688: NEG
42689: PUSH
42690: LD_INT 1
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 5
42699: NEG
42700: PUSH
42701: LD_INT 0
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PUSH
42708: LD_INT 5
42710: NEG
42711: PUSH
42712: LD_INT 1
42714: NEG
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 5
42722: NEG
42723: PUSH
42724: LD_INT 2
42726: NEG
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: PUSH
42732: LD_INT 3
42734: NEG
42735: PUSH
42736: LD_INT 2
42738: PUSH
42739: EMPTY
42740: LIST
42741: LIST
42742: PUSH
42743: LD_INT 3
42745: NEG
42746: PUSH
42747: LD_INT 3
42749: NEG
42750: PUSH
42751: EMPTY
42752: LIST
42753: LIST
42754: PUSH
42755: LD_INT 3
42757: NEG
42758: PUSH
42759: LD_INT 4
42761: NEG
42762: PUSH
42763: EMPTY
42764: LIST
42765: LIST
42766: PUSH
42767: LD_INT 2
42769: NEG
42770: PUSH
42771: LD_INT 3
42773: NEG
42774: PUSH
42775: EMPTY
42776: LIST
42777: LIST
42778: PUSH
42779: LD_INT 2
42781: NEG
42782: PUSH
42783: LD_INT 2
42785: NEG
42786: PUSH
42787: EMPTY
42788: LIST
42789: LIST
42790: PUSH
42791: LD_INT 3
42793: NEG
42794: PUSH
42795: LD_INT 2
42797: NEG
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 4
42805: NEG
42806: PUSH
42807: LD_INT 3
42809: NEG
42810: PUSH
42811: EMPTY
42812: LIST
42813: LIST
42814: PUSH
42815: LD_INT 4
42817: NEG
42818: PUSH
42819: LD_INT 4
42821: NEG
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: PUSH
42827: LD_INT 2
42829: NEG
42830: PUSH
42831: LD_INT 4
42833: NEG
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PUSH
42839: LD_INT 4
42841: NEG
42842: PUSH
42843: LD_INT 2
42845: NEG
42846: PUSH
42847: EMPTY
42848: LIST
42849: LIST
42850: PUSH
42851: LD_INT 0
42853: PUSH
42854: LD_INT 4
42856: NEG
42857: PUSH
42858: EMPTY
42859: LIST
42860: LIST
42861: PUSH
42862: LD_INT 0
42864: PUSH
42865: LD_INT 5
42867: NEG
42868: PUSH
42869: EMPTY
42870: LIST
42871: LIST
42872: PUSH
42873: LD_INT 1
42875: PUSH
42876: LD_INT 4
42878: NEG
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: PUSH
42884: LD_INT 1
42886: PUSH
42887: LD_INT 3
42889: NEG
42890: PUSH
42891: EMPTY
42892: LIST
42893: LIST
42894: PUSH
42895: LD_INT 0
42897: PUSH
42898: LD_INT 3
42900: NEG
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: PUSH
42906: LD_INT 1
42908: NEG
42909: PUSH
42910: LD_INT 4
42912: NEG
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: LD_INT 1
42920: NEG
42921: PUSH
42922: LD_INT 5
42924: NEG
42925: PUSH
42926: EMPTY
42927: LIST
42928: LIST
42929: PUSH
42930: LD_INT 2
42932: PUSH
42933: LD_INT 3
42935: NEG
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: PUSH
42941: LD_INT 2
42943: NEG
42944: PUSH
42945: LD_INT 5
42947: NEG
42948: PUSH
42949: EMPTY
42950: LIST
42951: LIST
42952: PUSH
42953: EMPTY
42954: LIST
42955: LIST
42956: LIST
42957: LIST
42958: LIST
42959: LIST
42960: LIST
42961: LIST
42962: LIST
42963: LIST
42964: LIST
42965: LIST
42966: LIST
42967: LIST
42968: LIST
42969: LIST
42970: LIST
42971: LIST
42972: LIST
42973: LIST
42974: LIST
42975: LIST
42976: LIST
42977: LIST
42978: LIST
42979: LIST
42980: LIST
42981: LIST
42982: LIST
42983: LIST
42984: LIST
42985: LIST
42986: LIST
42987: LIST
42988: LIST
42989: LIST
42990: LIST
42991: LIST
42992: LIST
42993: LIST
42994: LIST
42995: LIST
42996: LIST
42997: LIST
42998: LIST
42999: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43000: LD_ADDR_VAR 0 31
43004: PUSH
43005: LD_INT 0
43007: PUSH
43008: LD_INT 4
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: PUSH
43015: LD_INT 0
43017: PUSH
43018: LD_INT 3
43020: PUSH
43021: EMPTY
43022: LIST
43023: LIST
43024: PUSH
43025: LD_INT 1
43027: PUSH
43028: LD_INT 4
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 1
43037: PUSH
43038: LD_INT 5
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: LD_INT 0
43047: PUSH
43048: LD_INT 5
43050: PUSH
43051: EMPTY
43052: LIST
43053: LIST
43054: PUSH
43055: LD_INT 1
43057: NEG
43058: PUSH
43059: LD_INT 4
43061: PUSH
43062: EMPTY
43063: LIST
43064: LIST
43065: PUSH
43066: LD_INT 1
43068: NEG
43069: PUSH
43070: LD_INT 3
43072: PUSH
43073: EMPTY
43074: LIST
43075: LIST
43076: PUSH
43077: LD_INT 2
43079: PUSH
43080: LD_INT 5
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: PUSH
43087: LD_INT 2
43089: NEG
43090: PUSH
43091: LD_INT 3
43093: PUSH
43094: EMPTY
43095: LIST
43096: LIST
43097: PUSH
43098: LD_INT 3
43100: NEG
43101: PUSH
43102: LD_INT 0
43104: PUSH
43105: EMPTY
43106: LIST
43107: LIST
43108: PUSH
43109: LD_INT 3
43111: NEG
43112: PUSH
43113: LD_INT 1
43115: NEG
43116: PUSH
43117: EMPTY
43118: LIST
43119: LIST
43120: PUSH
43121: LD_INT 2
43123: NEG
43124: PUSH
43125: LD_INT 0
43127: PUSH
43128: EMPTY
43129: LIST
43130: LIST
43131: PUSH
43132: LD_INT 2
43134: NEG
43135: PUSH
43136: LD_INT 1
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 3
43145: NEG
43146: PUSH
43147: LD_INT 1
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_INT 4
43156: NEG
43157: PUSH
43158: LD_INT 0
43160: PUSH
43161: EMPTY
43162: LIST
43163: LIST
43164: PUSH
43165: LD_INT 4
43167: NEG
43168: PUSH
43169: LD_INT 1
43171: NEG
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: LD_INT 4
43179: NEG
43180: PUSH
43181: LD_INT 2
43183: NEG
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PUSH
43189: LD_INT 2
43191: NEG
43192: PUSH
43193: LD_INT 2
43195: PUSH
43196: EMPTY
43197: LIST
43198: LIST
43199: PUSH
43200: LD_INT 4
43202: NEG
43203: PUSH
43204: LD_INT 4
43206: NEG
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: PUSH
43212: LD_INT 4
43214: NEG
43215: PUSH
43216: LD_INT 5
43218: NEG
43219: PUSH
43220: EMPTY
43221: LIST
43222: LIST
43223: PUSH
43224: LD_INT 3
43226: NEG
43227: PUSH
43228: LD_INT 4
43230: NEG
43231: PUSH
43232: EMPTY
43233: LIST
43234: LIST
43235: PUSH
43236: LD_INT 3
43238: NEG
43239: PUSH
43240: LD_INT 3
43242: NEG
43243: PUSH
43244: EMPTY
43245: LIST
43246: LIST
43247: PUSH
43248: LD_INT 4
43250: NEG
43251: PUSH
43252: LD_INT 3
43254: NEG
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: PUSH
43260: LD_INT 5
43262: NEG
43263: PUSH
43264: LD_INT 4
43266: NEG
43267: PUSH
43268: EMPTY
43269: LIST
43270: LIST
43271: PUSH
43272: LD_INT 5
43274: NEG
43275: PUSH
43276: LD_INT 5
43278: NEG
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: PUSH
43284: LD_INT 3
43286: NEG
43287: PUSH
43288: LD_INT 5
43290: NEG
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: PUSH
43296: LD_INT 5
43298: NEG
43299: PUSH
43300: LD_INT 3
43302: NEG
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PUSH
43308: LD_INT 0
43310: PUSH
43311: LD_INT 3
43313: NEG
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: PUSH
43319: LD_INT 0
43321: PUSH
43322: LD_INT 4
43324: NEG
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 1
43332: PUSH
43333: LD_INT 3
43335: NEG
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 1
43343: PUSH
43344: LD_INT 2
43346: NEG
43347: PUSH
43348: EMPTY
43349: LIST
43350: LIST
43351: PUSH
43352: LD_INT 0
43354: PUSH
43355: LD_INT 2
43357: NEG
43358: PUSH
43359: EMPTY
43360: LIST
43361: LIST
43362: PUSH
43363: LD_INT 1
43365: NEG
43366: PUSH
43367: LD_INT 3
43369: NEG
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: PUSH
43375: LD_INT 1
43377: NEG
43378: PUSH
43379: LD_INT 4
43381: NEG
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: LD_INT 2
43389: PUSH
43390: LD_INT 2
43392: NEG
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: PUSH
43398: LD_INT 2
43400: NEG
43401: PUSH
43402: LD_INT 4
43404: NEG
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: PUSH
43410: LD_INT 4
43412: PUSH
43413: LD_INT 0
43415: PUSH
43416: EMPTY
43417: LIST
43418: LIST
43419: PUSH
43420: LD_INT 4
43422: PUSH
43423: LD_INT 1
43425: NEG
43426: PUSH
43427: EMPTY
43428: LIST
43429: LIST
43430: PUSH
43431: LD_INT 5
43433: PUSH
43434: LD_INT 0
43436: PUSH
43437: EMPTY
43438: LIST
43439: LIST
43440: PUSH
43441: LD_INT 5
43443: PUSH
43444: LD_INT 1
43446: PUSH
43447: EMPTY
43448: LIST
43449: LIST
43450: PUSH
43451: LD_INT 4
43453: PUSH
43454: LD_INT 1
43456: PUSH
43457: EMPTY
43458: LIST
43459: LIST
43460: PUSH
43461: LD_INT 3
43463: PUSH
43464: LD_INT 0
43466: PUSH
43467: EMPTY
43468: LIST
43469: LIST
43470: PUSH
43471: LD_INT 3
43473: PUSH
43474: LD_INT 1
43476: NEG
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: LD_INT 3
43484: PUSH
43485: LD_INT 2
43487: NEG
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: PUSH
43493: LD_INT 5
43495: PUSH
43496: LD_INT 2
43498: PUSH
43499: EMPTY
43500: LIST
43501: LIST
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: LIST
43507: LIST
43508: LIST
43509: LIST
43510: LIST
43511: LIST
43512: LIST
43513: LIST
43514: LIST
43515: LIST
43516: LIST
43517: LIST
43518: LIST
43519: LIST
43520: LIST
43521: LIST
43522: LIST
43523: LIST
43524: LIST
43525: LIST
43526: LIST
43527: LIST
43528: LIST
43529: LIST
43530: LIST
43531: LIST
43532: LIST
43533: LIST
43534: LIST
43535: LIST
43536: LIST
43537: LIST
43538: LIST
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: LIST
43549: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43550: LD_ADDR_VAR 0 32
43554: PUSH
43555: LD_INT 4
43557: NEG
43558: PUSH
43559: LD_INT 0
43561: PUSH
43562: EMPTY
43563: LIST
43564: LIST
43565: PUSH
43566: LD_INT 4
43568: NEG
43569: PUSH
43570: LD_INT 1
43572: NEG
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 3
43580: NEG
43581: PUSH
43582: LD_INT 0
43584: PUSH
43585: EMPTY
43586: LIST
43587: LIST
43588: PUSH
43589: LD_INT 3
43591: NEG
43592: PUSH
43593: LD_INT 1
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: PUSH
43600: LD_INT 4
43602: NEG
43603: PUSH
43604: LD_INT 1
43606: PUSH
43607: EMPTY
43608: LIST
43609: LIST
43610: PUSH
43611: LD_INT 5
43613: NEG
43614: PUSH
43615: LD_INT 0
43617: PUSH
43618: EMPTY
43619: LIST
43620: LIST
43621: PUSH
43622: LD_INT 5
43624: NEG
43625: PUSH
43626: LD_INT 1
43628: NEG
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 5
43636: NEG
43637: PUSH
43638: LD_INT 2
43640: NEG
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: LD_INT 3
43648: NEG
43649: PUSH
43650: LD_INT 2
43652: PUSH
43653: EMPTY
43654: LIST
43655: LIST
43656: PUSH
43657: LD_INT 3
43659: NEG
43660: PUSH
43661: LD_INT 3
43663: NEG
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: PUSH
43669: LD_INT 3
43671: NEG
43672: PUSH
43673: LD_INT 4
43675: NEG
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: PUSH
43681: LD_INT 2
43683: NEG
43684: PUSH
43685: LD_INT 3
43687: NEG
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: LD_INT 2
43695: NEG
43696: PUSH
43697: LD_INT 2
43699: NEG
43700: PUSH
43701: EMPTY
43702: LIST
43703: LIST
43704: PUSH
43705: LD_INT 3
43707: NEG
43708: PUSH
43709: LD_INT 2
43711: NEG
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: PUSH
43717: LD_INT 4
43719: NEG
43720: PUSH
43721: LD_INT 3
43723: NEG
43724: PUSH
43725: EMPTY
43726: LIST
43727: LIST
43728: PUSH
43729: LD_INT 4
43731: NEG
43732: PUSH
43733: LD_INT 4
43735: NEG
43736: PUSH
43737: EMPTY
43738: LIST
43739: LIST
43740: PUSH
43741: LD_INT 2
43743: NEG
43744: PUSH
43745: LD_INT 4
43747: NEG
43748: PUSH
43749: EMPTY
43750: LIST
43751: LIST
43752: PUSH
43753: LD_INT 4
43755: NEG
43756: PUSH
43757: LD_INT 2
43759: NEG
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 0
43767: PUSH
43768: LD_INT 4
43770: NEG
43771: PUSH
43772: EMPTY
43773: LIST
43774: LIST
43775: PUSH
43776: LD_INT 0
43778: PUSH
43779: LD_INT 5
43781: NEG
43782: PUSH
43783: EMPTY
43784: LIST
43785: LIST
43786: PUSH
43787: LD_INT 1
43789: PUSH
43790: LD_INT 4
43792: NEG
43793: PUSH
43794: EMPTY
43795: LIST
43796: LIST
43797: PUSH
43798: LD_INT 1
43800: PUSH
43801: LD_INT 3
43803: NEG
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 0
43811: PUSH
43812: LD_INT 3
43814: NEG
43815: PUSH
43816: EMPTY
43817: LIST
43818: LIST
43819: PUSH
43820: LD_INT 1
43822: NEG
43823: PUSH
43824: LD_INT 4
43826: NEG
43827: PUSH
43828: EMPTY
43829: LIST
43830: LIST
43831: PUSH
43832: LD_INT 1
43834: NEG
43835: PUSH
43836: LD_INT 5
43838: NEG
43839: PUSH
43840: EMPTY
43841: LIST
43842: LIST
43843: PUSH
43844: LD_INT 2
43846: PUSH
43847: LD_INT 3
43849: NEG
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: LD_INT 2
43857: NEG
43858: PUSH
43859: LD_INT 5
43861: NEG
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 3
43869: PUSH
43870: LD_INT 0
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: LD_INT 3
43879: PUSH
43880: LD_INT 1
43882: NEG
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PUSH
43888: LD_INT 4
43890: PUSH
43891: LD_INT 0
43893: PUSH
43894: EMPTY
43895: LIST
43896: LIST
43897: PUSH
43898: LD_INT 4
43900: PUSH
43901: LD_INT 1
43903: PUSH
43904: EMPTY
43905: LIST
43906: LIST
43907: PUSH
43908: LD_INT 3
43910: PUSH
43911: LD_INT 1
43913: PUSH
43914: EMPTY
43915: LIST
43916: LIST
43917: PUSH
43918: LD_INT 2
43920: PUSH
43921: LD_INT 0
43923: PUSH
43924: EMPTY
43925: LIST
43926: LIST
43927: PUSH
43928: LD_INT 2
43930: PUSH
43931: LD_INT 1
43933: NEG
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PUSH
43939: LD_INT 2
43941: PUSH
43942: LD_INT 2
43944: NEG
43945: PUSH
43946: EMPTY
43947: LIST
43948: LIST
43949: PUSH
43950: LD_INT 4
43952: PUSH
43953: LD_INT 2
43955: PUSH
43956: EMPTY
43957: LIST
43958: LIST
43959: PUSH
43960: LD_INT 4
43962: PUSH
43963: LD_INT 4
43965: PUSH
43966: EMPTY
43967: LIST
43968: LIST
43969: PUSH
43970: LD_INT 4
43972: PUSH
43973: LD_INT 3
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: LD_INT 5
43982: PUSH
43983: LD_INT 4
43985: PUSH
43986: EMPTY
43987: LIST
43988: LIST
43989: PUSH
43990: LD_INT 5
43992: PUSH
43993: LD_INT 5
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: PUSH
44000: LD_INT 4
44002: PUSH
44003: LD_INT 5
44005: PUSH
44006: EMPTY
44007: LIST
44008: LIST
44009: PUSH
44010: LD_INT 3
44012: PUSH
44013: LD_INT 4
44015: PUSH
44016: EMPTY
44017: LIST
44018: LIST
44019: PUSH
44020: LD_INT 3
44022: PUSH
44023: LD_INT 3
44025: PUSH
44026: EMPTY
44027: LIST
44028: LIST
44029: PUSH
44030: LD_INT 5
44032: PUSH
44033: LD_INT 3
44035: PUSH
44036: EMPTY
44037: LIST
44038: LIST
44039: PUSH
44040: LD_INT 3
44042: PUSH
44043: LD_INT 5
44045: PUSH
44046: EMPTY
44047: LIST
44048: LIST
44049: PUSH
44050: EMPTY
44051: LIST
44052: LIST
44053: LIST
44054: LIST
44055: LIST
44056: LIST
44057: LIST
44058: LIST
44059: LIST
44060: LIST
44061: LIST
44062: LIST
44063: LIST
44064: LIST
44065: LIST
44066: LIST
44067: LIST
44068: LIST
44069: LIST
44070: LIST
44071: LIST
44072: LIST
44073: LIST
44074: LIST
44075: LIST
44076: LIST
44077: LIST
44078: LIST
44079: LIST
44080: LIST
44081: LIST
44082: LIST
44083: LIST
44084: LIST
44085: LIST
44086: LIST
44087: LIST
44088: LIST
44089: LIST
44090: LIST
44091: LIST
44092: LIST
44093: LIST
44094: LIST
44095: LIST
44096: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44097: LD_ADDR_VAR 0 33
44101: PUSH
44102: LD_INT 4
44104: NEG
44105: PUSH
44106: LD_INT 4
44108: NEG
44109: PUSH
44110: EMPTY
44111: LIST
44112: LIST
44113: PUSH
44114: LD_INT 4
44116: NEG
44117: PUSH
44118: LD_INT 5
44120: NEG
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: PUSH
44126: LD_INT 3
44128: NEG
44129: PUSH
44130: LD_INT 4
44132: NEG
44133: PUSH
44134: EMPTY
44135: LIST
44136: LIST
44137: PUSH
44138: LD_INT 3
44140: NEG
44141: PUSH
44142: LD_INT 3
44144: NEG
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: LD_INT 4
44152: NEG
44153: PUSH
44154: LD_INT 3
44156: NEG
44157: PUSH
44158: EMPTY
44159: LIST
44160: LIST
44161: PUSH
44162: LD_INT 5
44164: NEG
44165: PUSH
44166: LD_INT 4
44168: NEG
44169: PUSH
44170: EMPTY
44171: LIST
44172: LIST
44173: PUSH
44174: LD_INT 5
44176: NEG
44177: PUSH
44178: LD_INT 5
44180: NEG
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: PUSH
44186: LD_INT 3
44188: NEG
44189: PUSH
44190: LD_INT 5
44192: NEG
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: PUSH
44198: LD_INT 5
44200: NEG
44201: PUSH
44202: LD_INT 3
44204: NEG
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 0
44212: PUSH
44213: LD_INT 3
44215: NEG
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: PUSH
44221: LD_INT 0
44223: PUSH
44224: LD_INT 4
44226: NEG
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: LD_INT 1
44234: PUSH
44235: LD_INT 3
44237: NEG
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 1
44245: PUSH
44246: LD_INT 2
44248: NEG
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 0
44256: PUSH
44257: LD_INT 2
44259: NEG
44260: PUSH
44261: EMPTY
44262: LIST
44263: LIST
44264: PUSH
44265: LD_INT 1
44267: NEG
44268: PUSH
44269: LD_INT 3
44271: NEG
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: PUSH
44277: LD_INT 1
44279: NEG
44280: PUSH
44281: LD_INT 4
44283: NEG
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: LD_INT 2
44291: PUSH
44292: LD_INT 2
44294: NEG
44295: PUSH
44296: EMPTY
44297: LIST
44298: LIST
44299: PUSH
44300: LD_INT 2
44302: NEG
44303: PUSH
44304: LD_INT 4
44306: NEG
44307: PUSH
44308: EMPTY
44309: LIST
44310: LIST
44311: PUSH
44312: LD_INT 4
44314: PUSH
44315: LD_INT 0
44317: PUSH
44318: EMPTY
44319: LIST
44320: LIST
44321: PUSH
44322: LD_INT 4
44324: PUSH
44325: LD_INT 1
44327: NEG
44328: PUSH
44329: EMPTY
44330: LIST
44331: LIST
44332: PUSH
44333: LD_INT 5
44335: PUSH
44336: LD_INT 0
44338: PUSH
44339: EMPTY
44340: LIST
44341: LIST
44342: PUSH
44343: LD_INT 5
44345: PUSH
44346: LD_INT 1
44348: PUSH
44349: EMPTY
44350: LIST
44351: LIST
44352: PUSH
44353: LD_INT 4
44355: PUSH
44356: LD_INT 1
44358: PUSH
44359: EMPTY
44360: LIST
44361: LIST
44362: PUSH
44363: LD_INT 3
44365: PUSH
44366: LD_INT 0
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 3
44375: PUSH
44376: LD_INT 1
44378: NEG
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 3
44386: PUSH
44387: LD_INT 2
44389: NEG
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: PUSH
44395: LD_INT 5
44397: PUSH
44398: LD_INT 2
44400: PUSH
44401: EMPTY
44402: LIST
44403: LIST
44404: PUSH
44405: LD_INT 3
44407: PUSH
44408: LD_INT 3
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: LD_INT 3
44417: PUSH
44418: LD_INT 2
44420: PUSH
44421: EMPTY
44422: LIST
44423: LIST
44424: PUSH
44425: LD_INT 4
44427: PUSH
44428: LD_INT 3
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: PUSH
44435: LD_INT 4
44437: PUSH
44438: LD_INT 4
44440: PUSH
44441: EMPTY
44442: LIST
44443: LIST
44444: PUSH
44445: LD_INT 3
44447: PUSH
44448: LD_INT 4
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: PUSH
44455: LD_INT 2
44457: PUSH
44458: LD_INT 3
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: PUSH
44465: LD_INT 2
44467: PUSH
44468: LD_INT 2
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: LD_INT 4
44477: PUSH
44478: LD_INT 2
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 2
44487: PUSH
44488: LD_INT 4
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PUSH
44495: LD_INT 0
44497: PUSH
44498: LD_INT 4
44500: PUSH
44501: EMPTY
44502: LIST
44503: LIST
44504: PUSH
44505: LD_INT 0
44507: PUSH
44508: LD_INT 3
44510: PUSH
44511: EMPTY
44512: LIST
44513: LIST
44514: PUSH
44515: LD_INT 1
44517: PUSH
44518: LD_INT 4
44520: PUSH
44521: EMPTY
44522: LIST
44523: LIST
44524: PUSH
44525: LD_INT 1
44527: PUSH
44528: LD_INT 5
44530: PUSH
44531: EMPTY
44532: LIST
44533: LIST
44534: PUSH
44535: LD_INT 0
44537: PUSH
44538: LD_INT 5
44540: PUSH
44541: EMPTY
44542: LIST
44543: LIST
44544: PUSH
44545: LD_INT 1
44547: NEG
44548: PUSH
44549: LD_INT 4
44551: PUSH
44552: EMPTY
44553: LIST
44554: LIST
44555: PUSH
44556: LD_INT 1
44558: NEG
44559: PUSH
44560: LD_INT 3
44562: PUSH
44563: EMPTY
44564: LIST
44565: LIST
44566: PUSH
44567: LD_INT 2
44569: PUSH
44570: LD_INT 5
44572: PUSH
44573: EMPTY
44574: LIST
44575: LIST
44576: PUSH
44577: LD_INT 2
44579: NEG
44580: PUSH
44581: LD_INT 3
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: LIST
44592: LIST
44593: LIST
44594: LIST
44595: LIST
44596: LIST
44597: LIST
44598: LIST
44599: LIST
44600: LIST
44601: LIST
44602: LIST
44603: LIST
44604: LIST
44605: LIST
44606: LIST
44607: LIST
44608: LIST
44609: LIST
44610: LIST
44611: LIST
44612: LIST
44613: LIST
44614: LIST
44615: LIST
44616: LIST
44617: LIST
44618: LIST
44619: LIST
44620: LIST
44621: LIST
44622: LIST
44623: LIST
44624: LIST
44625: LIST
44626: LIST
44627: LIST
44628: LIST
44629: LIST
44630: LIST
44631: LIST
44632: LIST
44633: LIST
44634: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
44635: LD_ADDR_VAR 0 34
44639: PUSH
44640: LD_INT 0
44642: PUSH
44643: LD_INT 4
44645: NEG
44646: PUSH
44647: EMPTY
44648: LIST
44649: LIST
44650: PUSH
44651: LD_INT 0
44653: PUSH
44654: LD_INT 5
44656: NEG
44657: PUSH
44658: EMPTY
44659: LIST
44660: LIST
44661: PUSH
44662: LD_INT 1
44664: PUSH
44665: LD_INT 4
44667: NEG
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 1
44675: PUSH
44676: LD_INT 3
44678: NEG
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PUSH
44684: LD_INT 0
44686: PUSH
44687: LD_INT 3
44689: NEG
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PUSH
44695: LD_INT 1
44697: NEG
44698: PUSH
44699: LD_INT 4
44701: NEG
44702: PUSH
44703: EMPTY
44704: LIST
44705: LIST
44706: PUSH
44707: LD_INT 1
44709: NEG
44710: PUSH
44711: LD_INT 5
44713: NEG
44714: PUSH
44715: EMPTY
44716: LIST
44717: LIST
44718: PUSH
44719: LD_INT 2
44721: PUSH
44722: LD_INT 3
44724: NEG
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: PUSH
44730: LD_INT 2
44732: NEG
44733: PUSH
44734: LD_INT 5
44736: NEG
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: PUSH
44742: LD_INT 3
44744: PUSH
44745: LD_INT 0
44747: PUSH
44748: EMPTY
44749: LIST
44750: LIST
44751: PUSH
44752: LD_INT 3
44754: PUSH
44755: LD_INT 1
44757: NEG
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: PUSH
44763: LD_INT 4
44765: PUSH
44766: LD_INT 0
44768: PUSH
44769: EMPTY
44770: LIST
44771: LIST
44772: PUSH
44773: LD_INT 4
44775: PUSH
44776: LD_INT 1
44778: PUSH
44779: EMPTY
44780: LIST
44781: LIST
44782: PUSH
44783: LD_INT 3
44785: PUSH
44786: LD_INT 1
44788: PUSH
44789: EMPTY
44790: LIST
44791: LIST
44792: PUSH
44793: LD_INT 2
44795: PUSH
44796: LD_INT 0
44798: PUSH
44799: EMPTY
44800: LIST
44801: LIST
44802: PUSH
44803: LD_INT 2
44805: PUSH
44806: LD_INT 1
44808: NEG
44809: PUSH
44810: EMPTY
44811: LIST
44812: LIST
44813: PUSH
44814: LD_INT 2
44816: PUSH
44817: LD_INT 2
44819: NEG
44820: PUSH
44821: EMPTY
44822: LIST
44823: LIST
44824: PUSH
44825: LD_INT 4
44827: PUSH
44828: LD_INT 2
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: PUSH
44835: LD_INT 4
44837: PUSH
44838: LD_INT 4
44840: PUSH
44841: EMPTY
44842: LIST
44843: LIST
44844: PUSH
44845: LD_INT 4
44847: PUSH
44848: LD_INT 3
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: PUSH
44855: LD_INT 5
44857: PUSH
44858: LD_INT 4
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PUSH
44865: LD_INT 5
44867: PUSH
44868: LD_INT 5
44870: PUSH
44871: EMPTY
44872: LIST
44873: LIST
44874: PUSH
44875: LD_INT 4
44877: PUSH
44878: LD_INT 5
44880: PUSH
44881: EMPTY
44882: LIST
44883: LIST
44884: PUSH
44885: LD_INT 3
44887: PUSH
44888: LD_INT 4
44890: PUSH
44891: EMPTY
44892: LIST
44893: LIST
44894: PUSH
44895: LD_INT 3
44897: PUSH
44898: LD_INT 3
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: PUSH
44905: LD_INT 5
44907: PUSH
44908: LD_INT 3
44910: PUSH
44911: EMPTY
44912: LIST
44913: LIST
44914: PUSH
44915: LD_INT 3
44917: PUSH
44918: LD_INT 5
44920: PUSH
44921: EMPTY
44922: LIST
44923: LIST
44924: PUSH
44925: LD_INT 0
44927: PUSH
44928: LD_INT 3
44930: PUSH
44931: EMPTY
44932: LIST
44933: LIST
44934: PUSH
44935: LD_INT 0
44937: PUSH
44938: LD_INT 2
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: PUSH
44945: LD_INT 1
44947: PUSH
44948: LD_INT 3
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 1
44957: PUSH
44958: LD_INT 4
44960: PUSH
44961: EMPTY
44962: LIST
44963: LIST
44964: PUSH
44965: LD_INT 0
44967: PUSH
44968: LD_INT 4
44970: PUSH
44971: EMPTY
44972: LIST
44973: LIST
44974: PUSH
44975: LD_INT 1
44977: NEG
44978: PUSH
44979: LD_INT 3
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: PUSH
44986: LD_INT 1
44988: NEG
44989: PUSH
44990: LD_INT 2
44992: PUSH
44993: EMPTY
44994: LIST
44995: LIST
44996: PUSH
44997: LD_INT 2
44999: PUSH
45000: LD_INT 4
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: PUSH
45007: LD_INT 2
45009: NEG
45010: PUSH
45011: LD_INT 2
45013: PUSH
45014: EMPTY
45015: LIST
45016: LIST
45017: PUSH
45018: LD_INT 4
45020: NEG
45021: PUSH
45022: LD_INT 0
45024: PUSH
45025: EMPTY
45026: LIST
45027: LIST
45028: PUSH
45029: LD_INT 4
45031: NEG
45032: PUSH
45033: LD_INT 1
45035: NEG
45036: PUSH
45037: EMPTY
45038: LIST
45039: LIST
45040: PUSH
45041: LD_INT 3
45043: NEG
45044: PUSH
45045: LD_INT 0
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: PUSH
45052: LD_INT 3
45054: NEG
45055: PUSH
45056: LD_INT 1
45058: PUSH
45059: EMPTY
45060: LIST
45061: LIST
45062: PUSH
45063: LD_INT 4
45065: NEG
45066: PUSH
45067: LD_INT 1
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PUSH
45074: LD_INT 5
45076: NEG
45077: PUSH
45078: LD_INT 0
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PUSH
45085: LD_INT 5
45087: NEG
45088: PUSH
45089: LD_INT 1
45091: NEG
45092: PUSH
45093: EMPTY
45094: LIST
45095: LIST
45096: PUSH
45097: LD_INT 5
45099: NEG
45100: PUSH
45101: LD_INT 2
45103: NEG
45104: PUSH
45105: EMPTY
45106: LIST
45107: LIST
45108: PUSH
45109: LD_INT 3
45111: NEG
45112: PUSH
45113: LD_INT 2
45115: PUSH
45116: EMPTY
45117: LIST
45118: LIST
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: LIST
45124: LIST
45125: LIST
45126: LIST
45127: LIST
45128: LIST
45129: LIST
45130: LIST
45131: LIST
45132: LIST
45133: LIST
45134: LIST
45135: LIST
45136: LIST
45137: LIST
45138: LIST
45139: LIST
45140: LIST
45141: LIST
45142: LIST
45143: LIST
45144: LIST
45145: LIST
45146: LIST
45147: LIST
45148: LIST
45149: LIST
45150: LIST
45151: LIST
45152: LIST
45153: LIST
45154: LIST
45155: LIST
45156: LIST
45157: LIST
45158: LIST
45159: LIST
45160: LIST
45161: LIST
45162: LIST
45163: LIST
45164: LIST
45165: LIST
45166: ST_TO_ADDR
// end ; end ;
45167: GO 45170
45169: POP
// case btype of b_depot , b_warehouse :
45170: LD_VAR 0 1
45174: PUSH
45175: LD_INT 0
45177: DOUBLE
45178: EQUAL
45179: IFTRUE 45189
45181: LD_INT 1
45183: DOUBLE
45184: EQUAL
45185: IFTRUE 45189
45187: GO 45390
45189: POP
// case nation of nation_american :
45190: LD_VAR 0 5
45194: PUSH
45195: LD_INT 1
45197: DOUBLE
45198: EQUAL
45199: IFTRUE 45203
45201: GO 45259
45203: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
45204: LD_ADDR_VAR 0 9
45208: PUSH
45209: LD_VAR 0 11
45213: PUSH
45214: LD_VAR 0 12
45218: PUSH
45219: LD_VAR 0 13
45223: PUSH
45224: LD_VAR 0 14
45228: PUSH
45229: LD_VAR 0 15
45233: PUSH
45234: LD_VAR 0 16
45238: PUSH
45239: EMPTY
45240: LIST
45241: LIST
45242: LIST
45243: LIST
45244: LIST
45245: LIST
45246: PUSH
45247: LD_VAR 0 4
45251: PUSH
45252: LD_INT 1
45254: PLUS
45255: ARRAY
45256: ST_TO_ADDR
45257: GO 45388
45259: LD_INT 2
45261: DOUBLE
45262: EQUAL
45263: IFTRUE 45267
45265: GO 45323
45267: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
45268: LD_ADDR_VAR 0 9
45272: PUSH
45273: LD_VAR 0 17
45277: PUSH
45278: LD_VAR 0 18
45282: PUSH
45283: LD_VAR 0 19
45287: PUSH
45288: LD_VAR 0 20
45292: PUSH
45293: LD_VAR 0 21
45297: PUSH
45298: LD_VAR 0 22
45302: PUSH
45303: EMPTY
45304: LIST
45305: LIST
45306: LIST
45307: LIST
45308: LIST
45309: LIST
45310: PUSH
45311: LD_VAR 0 4
45315: PUSH
45316: LD_INT 1
45318: PLUS
45319: ARRAY
45320: ST_TO_ADDR
45321: GO 45388
45323: LD_INT 3
45325: DOUBLE
45326: EQUAL
45327: IFTRUE 45331
45329: GO 45387
45331: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
45332: LD_ADDR_VAR 0 9
45336: PUSH
45337: LD_VAR 0 23
45341: PUSH
45342: LD_VAR 0 24
45346: PUSH
45347: LD_VAR 0 25
45351: PUSH
45352: LD_VAR 0 26
45356: PUSH
45357: LD_VAR 0 27
45361: PUSH
45362: LD_VAR 0 28
45366: PUSH
45367: EMPTY
45368: LIST
45369: LIST
45370: LIST
45371: LIST
45372: LIST
45373: LIST
45374: PUSH
45375: LD_VAR 0 4
45379: PUSH
45380: LD_INT 1
45382: PLUS
45383: ARRAY
45384: ST_TO_ADDR
45385: GO 45388
45387: POP
45388: GO 45943
45390: LD_INT 2
45392: DOUBLE
45393: EQUAL
45394: IFTRUE 45404
45396: LD_INT 3
45398: DOUBLE
45399: EQUAL
45400: IFTRUE 45404
45402: GO 45460
45404: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45405: LD_ADDR_VAR 0 9
45409: PUSH
45410: LD_VAR 0 29
45414: PUSH
45415: LD_VAR 0 30
45419: PUSH
45420: LD_VAR 0 31
45424: PUSH
45425: LD_VAR 0 32
45429: PUSH
45430: LD_VAR 0 33
45434: PUSH
45435: LD_VAR 0 34
45439: PUSH
45440: EMPTY
45441: LIST
45442: LIST
45443: LIST
45444: LIST
45445: LIST
45446: LIST
45447: PUSH
45448: LD_VAR 0 4
45452: PUSH
45453: LD_INT 1
45455: PLUS
45456: ARRAY
45457: ST_TO_ADDR
45458: GO 45943
45460: LD_INT 16
45462: DOUBLE
45463: EQUAL
45464: IFTRUE 45522
45466: LD_INT 17
45468: DOUBLE
45469: EQUAL
45470: IFTRUE 45522
45472: LD_INT 18
45474: DOUBLE
45475: EQUAL
45476: IFTRUE 45522
45478: LD_INT 19
45480: DOUBLE
45481: EQUAL
45482: IFTRUE 45522
45484: LD_INT 22
45486: DOUBLE
45487: EQUAL
45488: IFTRUE 45522
45490: LD_INT 20
45492: DOUBLE
45493: EQUAL
45494: IFTRUE 45522
45496: LD_INT 21
45498: DOUBLE
45499: EQUAL
45500: IFTRUE 45522
45502: LD_INT 23
45504: DOUBLE
45505: EQUAL
45506: IFTRUE 45522
45508: LD_INT 24
45510: DOUBLE
45511: EQUAL
45512: IFTRUE 45522
45514: LD_INT 25
45516: DOUBLE
45517: EQUAL
45518: IFTRUE 45522
45520: GO 45578
45522: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45523: LD_ADDR_VAR 0 9
45527: PUSH
45528: LD_VAR 0 35
45532: PUSH
45533: LD_VAR 0 36
45537: PUSH
45538: LD_VAR 0 37
45542: PUSH
45543: LD_VAR 0 38
45547: PUSH
45548: LD_VAR 0 39
45552: PUSH
45553: LD_VAR 0 40
45557: PUSH
45558: EMPTY
45559: LIST
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: LIST
45565: PUSH
45566: LD_VAR 0 4
45570: PUSH
45571: LD_INT 1
45573: PLUS
45574: ARRAY
45575: ST_TO_ADDR
45576: GO 45943
45578: LD_INT 6
45580: DOUBLE
45581: EQUAL
45582: IFTRUE 45634
45584: LD_INT 7
45586: DOUBLE
45587: EQUAL
45588: IFTRUE 45634
45590: LD_INT 8
45592: DOUBLE
45593: EQUAL
45594: IFTRUE 45634
45596: LD_INT 13
45598: DOUBLE
45599: EQUAL
45600: IFTRUE 45634
45602: LD_INT 12
45604: DOUBLE
45605: EQUAL
45606: IFTRUE 45634
45608: LD_INT 15
45610: DOUBLE
45611: EQUAL
45612: IFTRUE 45634
45614: LD_INT 11
45616: DOUBLE
45617: EQUAL
45618: IFTRUE 45634
45620: LD_INT 14
45622: DOUBLE
45623: EQUAL
45624: IFTRUE 45634
45626: LD_INT 10
45628: DOUBLE
45629: EQUAL
45630: IFTRUE 45634
45632: GO 45690
45634: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
45635: LD_ADDR_VAR 0 9
45639: PUSH
45640: LD_VAR 0 41
45644: PUSH
45645: LD_VAR 0 42
45649: PUSH
45650: LD_VAR 0 43
45654: PUSH
45655: LD_VAR 0 44
45659: PUSH
45660: LD_VAR 0 45
45664: PUSH
45665: LD_VAR 0 46
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: LIST
45677: PUSH
45678: LD_VAR 0 4
45682: PUSH
45683: LD_INT 1
45685: PLUS
45686: ARRAY
45687: ST_TO_ADDR
45688: GO 45943
45690: LD_INT 36
45692: DOUBLE
45693: EQUAL
45694: IFTRUE 45698
45696: GO 45754
45698: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45699: LD_ADDR_VAR 0 9
45703: PUSH
45704: LD_VAR 0 47
45708: PUSH
45709: LD_VAR 0 48
45713: PUSH
45714: LD_VAR 0 49
45718: PUSH
45719: LD_VAR 0 50
45723: PUSH
45724: LD_VAR 0 51
45728: PUSH
45729: LD_VAR 0 52
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: LIST
45738: LIST
45739: LIST
45740: LIST
45741: PUSH
45742: LD_VAR 0 4
45746: PUSH
45747: LD_INT 1
45749: PLUS
45750: ARRAY
45751: ST_TO_ADDR
45752: GO 45943
45754: LD_INT 4
45756: DOUBLE
45757: EQUAL
45758: IFTRUE 45780
45760: LD_INT 5
45762: DOUBLE
45763: EQUAL
45764: IFTRUE 45780
45766: LD_INT 34
45768: DOUBLE
45769: EQUAL
45770: IFTRUE 45780
45772: LD_INT 37
45774: DOUBLE
45775: EQUAL
45776: IFTRUE 45780
45778: GO 45836
45780: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45781: LD_ADDR_VAR 0 9
45785: PUSH
45786: LD_VAR 0 53
45790: PUSH
45791: LD_VAR 0 54
45795: PUSH
45796: LD_VAR 0 55
45800: PUSH
45801: LD_VAR 0 56
45805: PUSH
45806: LD_VAR 0 57
45810: PUSH
45811: LD_VAR 0 58
45815: PUSH
45816: EMPTY
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: PUSH
45824: LD_VAR 0 4
45828: PUSH
45829: LD_INT 1
45831: PLUS
45832: ARRAY
45833: ST_TO_ADDR
45834: GO 45943
45836: LD_INT 31
45838: DOUBLE
45839: EQUAL
45840: IFTRUE 45886
45842: LD_INT 32
45844: DOUBLE
45845: EQUAL
45846: IFTRUE 45886
45848: LD_INT 33
45850: DOUBLE
45851: EQUAL
45852: IFTRUE 45886
45854: LD_INT 27
45856: DOUBLE
45857: EQUAL
45858: IFTRUE 45886
45860: LD_INT 26
45862: DOUBLE
45863: EQUAL
45864: IFTRUE 45886
45866: LD_INT 28
45868: DOUBLE
45869: EQUAL
45870: IFTRUE 45886
45872: LD_INT 29
45874: DOUBLE
45875: EQUAL
45876: IFTRUE 45886
45878: LD_INT 30
45880: DOUBLE
45881: EQUAL
45882: IFTRUE 45886
45884: GO 45942
45886: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
45887: LD_ADDR_VAR 0 9
45891: PUSH
45892: LD_VAR 0 59
45896: PUSH
45897: LD_VAR 0 60
45901: PUSH
45902: LD_VAR 0 61
45906: PUSH
45907: LD_VAR 0 62
45911: PUSH
45912: LD_VAR 0 63
45916: PUSH
45917: LD_VAR 0 64
45921: PUSH
45922: EMPTY
45923: LIST
45924: LIST
45925: LIST
45926: LIST
45927: LIST
45928: LIST
45929: PUSH
45930: LD_VAR 0 4
45934: PUSH
45935: LD_INT 1
45937: PLUS
45938: ARRAY
45939: ST_TO_ADDR
45940: GO 45943
45942: POP
// temp_list2 = [ ] ;
45943: LD_ADDR_VAR 0 10
45947: PUSH
45948: EMPTY
45949: ST_TO_ADDR
// for i in temp_list do
45950: LD_ADDR_VAR 0 8
45954: PUSH
45955: LD_VAR 0 9
45959: PUSH
45960: FOR_IN
45961: IFFALSE 46013
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
45963: LD_ADDR_VAR 0 10
45967: PUSH
45968: LD_VAR 0 10
45972: PUSH
45973: LD_VAR 0 8
45977: PUSH
45978: LD_INT 1
45980: ARRAY
45981: PUSH
45982: LD_VAR 0 2
45986: PLUS
45987: PUSH
45988: LD_VAR 0 8
45992: PUSH
45993: LD_INT 2
45995: ARRAY
45996: PUSH
45997: LD_VAR 0 3
46001: PLUS
46002: PUSH
46003: EMPTY
46004: LIST
46005: LIST
46006: PUSH
46007: EMPTY
46008: LIST
46009: ADD
46010: ST_TO_ADDR
46011: GO 45960
46013: POP
46014: POP
// result = temp_list2 ;
46015: LD_ADDR_VAR 0 7
46019: PUSH
46020: LD_VAR 0 10
46024: ST_TO_ADDR
// end ;
46025: LD_VAR 0 7
46029: RET
// export function EnemyInRange ( unit , dist ) ; begin
46030: LD_INT 0
46032: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46033: LD_ADDR_VAR 0 3
46037: PUSH
46038: LD_VAR 0 1
46042: PPUSH
46043: CALL_OW 255
46047: PPUSH
46048: LD_VAR 0 1
46052: PPUSH
46053: CALL_OW 250
46057: PPUSH
46058: LD_VAR 0 1
46062: PPUSH
46063: CALL_OW 251
46067: PPUSH
46068: LD_VAR 0 2
46072: PPUSH
46073: CALL 20134 0 4
46077: PUSH
46078: LD_INT 4
46080: ARRAY
46081: ST_TO_ADDR
// end ;
46082: LD_VAR 0 3
46086: RET
// export function PlayerSeeMe ( unit ) ; begin
46087: LD_INT 0
46089: PPUSH
// result := See ( your_side , unit ) ;
46090: LD_ADDR_VAR 0 2
46094: PUSH
46095: LD_OWVAR 2
46099: PPUSH
46100: LD_VAR 0 1
46104: PPUSH
46105: CALL_OW 292
46109: ST_TO_ADDR
// end ;
46110: LD_VAR 0 2
46114: RET
// export function ReverseDir ( unit ) ; begin
46115: LD_INT 0
46117: PPUSH
// if not unit then
46118: LD_VAR 0 1
46122: NOT
46123: IFFALSE 46127
// exit ;
46125: GO 46150
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46127: LD_ADDR_VAR 0 2
46131: PUSH
46132: LD_VAR 0 1
46136: PPUSH
46137: CALL_OW 254
46141: PUSH
46142: LD_INT 3
46144: PLUS
46145: PUSH
46146: LD_INT 6
46148: MOD
46149: ST_TO_ADDR
// end ;
46150: LD_VAR 0 2
46154: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
46155: LD_INT 0
46157: PPUSH
46158: PPUSH
46159: PPUSH
46160: PPUSH
46161: PPUSH
// if not hexes then
46162: LD_VAR 0 2
46166: NOT
46167: IFFALSE 46171
// exit ;
46169: GO 46319
// dist := 9999 ;
46171: LD_ADDR_VAR 0 5
46175: PUSH
46176: LD_INT 9999
46178: ST_TO_ADDR
// for i = 1 to hexes do
46179: LD_ADDR_VAR 0 4
46183: PUSH
46184: DOUBLE
46185: LD_INT 1
46187: DEC
46188: ST_TO_ADDR
46189: LD_VAR 0 2
46193: PUSH
46194: FOR_TO
46195: IFFALSE 46307
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
46197: LD_VAR 0 1
46201: PPUSH
46202: LD_VAR 0 2
46206: PUSH
46207: LD_VAR 0 4
46211: ARRAY
46212: PUSH
46213: LD_INT 1
46215: ARRAY
46216: PPUSH
46217: LD_VAR 0 2
46221: PUSH
46222: LD_VAR 0 4
46226: ARRAY
46227: PUSH
46228: LD_INT 2
46230: ARRAY
46231: PPUSH
46232: CALL_OW 297
46236: PUSH
46237: LD_VAR 0 5
46241: LESS
46242: IFFALSE 46305
// begin hex := hexes [ i ] ;
46244: LD_ADDR_VAR 0 7
46248: PUSH
46249: LD_VAR 0 2
46253: PUSH
46254: LD_VAR 0 4
46258: ARRAY
46259: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46260: LD_ADDR_VAR 0 5
46264: PUSH
46265: LD_VAR 0 1
46269: PPUSH
46270: LD_VAR 0 2
46274: PUSH
46275: LD_VAR 0 4
46279: ARRAY
46280: PUSH
46281: LD_INT 1
46283: ARRAY
46284: PPUSH
46285: LD_VAR 0 2
46289: PUSH
46290: LD_VAR 0 4
46294: ARRAY
46295: PUSH
46296: LD_INT 2
46298: ARRAY
46299: PPUSH
46300: CALL_OW 297
46304: ST_TO_ADDR
// end ; end ;
46305: GO 46194
46307: POP
46308: POP
// result := hex ;
46309: LD_ADDR_VAR 0 3
46313: PUSH
46314: LD_VAR 0 7
46318: ST_TO_ADDR
// end ;
46319: LD_VAR 0 3
46323: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
46324: LD_INT 0
46326: PPUSH
46327: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
46328: LD_VAR 0 1
46332: NOT
46333: PUSH
46334: LD_VAR 0 1
46338: PUSH
46339: LD_INT 21
46341: PUSH
46342: LD_INT 2
46344: PUSH
46345: EMPTY
46346: LIST
46347: LIST
46348: PUSH
46349: LD_INT 23
46351: PUSH
46352: LD_INT 2
46354: PUSH
46355: EMPTY
46356: LIST
46357: LIST
46358: PUSH
46359: EMPTY
46360: LIST
46361: LIST
46362: PPUSH
46363: CALL_OW 69
46367: IN
46368: NOT
46369: OR
46370: IFFALSE 46374
// exit ;
46372: GO 46421
// for i = 1 to 3 do
46374: LD_ADDR_VAR 0 3
46378: PUSH
46379: DOUBLE
46380: LD_INT 1
46382: DEC
46383: ST_TO_ADDR
46384: LD_INT 3
46386: PUSH
46387: FOR_TO
46388: IFFALSE 46419
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46390: LD_VAR 0 1
46394: PPUSH
46395: CALL_OW 250
46399: PPUSH
46400: LD_VAR 0 1
46404: PPUSH
46405: CALL_OW 251
46409: PPUSH
46410: LD_INT 1
46412: PPUSH
46413: CALL_OW 453
46417: GO 46387
46419: POP
46420: POP
// end ;
46421: LD_VAR 0 2
46425: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46426: LD_INT 0
46428: PPUSH
46429: PPUSH
46430: PPUSH
46431: PPUSH
46432: PPUSH
46433: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46434: LD_VAR 0 1
46438: NOT
46439: PUSH
46440: LD_VAR 0 2
46444: NOT
46445: OR
46446: PUSH
46447: LD_VAR 0 1
46451: PPUSH
46452: CALL_OW 314
46456: OR
46457: IFFALSE 46461
// exit ;
46459: GO 46902
// x := GetX ( enemy_unit ) ;
46461: LD_ADDR_VAR 0 7
46465: PUSH
46466: LD_VAR 0 2
46470: PPUSH
46471: CALL_OW 250
46475: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46476: LD_ADDR_VAR 0 8
46480: PUSH
46481: LD_VAR 0 2
46485: PPUSH
46486: CALL_OW 251
46490: ST_TO_ADDR
// if not x or not y then
46491: LD_VAR 0 7
46495: NOT
46496: PUSH
46497: LD_VAR 0 8
46501: NOT
46502: OR
46503: IFFALSE 46507
// exit ;
46505: GO 46902
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46507: LD_ADDR_VAR 0 6
46511: PUSH
46512: LD_VAR 0 7
46516: PPUSH
46517: LD_INT 0
46519: PPUSH
46520: LD_INT 4
46522: PPUSH
46523: CALL_OW 272
46527: PUSH
46528: LD_VAR 0 8
46532: PPUSH
46533: LD_INT 0
46535: PPUSH
46536: LD_INT 4
46538: PPUSH
46539: CALL_OW 273
46543: PUSH
46544: EMPTY
46545: LIST
46546: LIST
46547: PUSH
46548: LD_VAR 0 7
46552: PPUSH
46553: LD_INT 1
46555: PPUSH
46556: LD_INT 4
46558: PPUSH
46559: CALL_OW 272
46563: PUSH
46564: LD_VAR 0 8
46568: PPUSH
46569: LD_INT 1
46571: PPUSH
46572: LD_INT 4
46574: PPUSH
46575: CALL_OW 273
46579: PUSH
46580: EMPTY
46581: LIST
46582: LIST
46583: PUSH
46584: LD_VAR 0 7
46588: PPUSH
46589: LD_INT 2
46591: PPUSH
46592: LD_INT 4
46594: PPUSH
46595: CALL_OW 272
46599: PUSH
46600: LD_VAR 0 8
46604: PPUSH
46605: LD_INT 2
46607: PPUSH
46608: LD_INT 4
46610: PPUSH
46611: CALL_OW 273
46615: PUSH
46616: EMPTY
46617: LIST
46618: LIST
46619: PUSH
46620: LD_VAR 0 7
46624: PPUSH
46625: LD_INT 3
46627: PPUSH
46628: LD_INT 4
46630: PPUSH
46631: CALL_OW 272
46635: PUSH
46636: LD_VAR 0 8
46640: PPUSH
46641: LD_INT 3
46643: PPUSH
46644: LD_INT 4
46646: PPUSH
46647: CALL_OW 273
46651: PUSH
46652: EMPTY
46653: LIST
46654: LIST
46655: PUSH
46656: LD_VAR 0 7
46660: PPUSH
46661: LD_INT 4
46663: PPUSH
46664: LD_INT 4
46666: PPUSH
46667: CALL_OW 272
46671: PUSH
46672: LD_VAR 0 8
46676: PPUSH
46677: LD_INT 4
46679: PPUSH
46680: LD_INT 4
46682: PPUSH
46683: CALL_OW 273
46687: PUSH
46688: EMPTY
46689: LIST
46690: LIST
46691: PUSH
46692: LD_VAR 0 7
46696: PPUSH
46697: LD_INT 5
46699: PPUSH
46700: LD_INT 4
46702: PPUSH
46703: CALL_OW 272
46707: PUSH
46708: LD_VAR 0 8
46712: PPUSH
46713: LD_INT 5
46715: PPUSH
46716: LD_INT 4
46718: PPUSH
46719: CALL_OW 273
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: PUSH
46728: EMPTY
46729: LIST
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: ST_TO_ADDR
// for i = tmp downto 1 do
46736: LD_ADDR_VAR 0 4
46740: PUSH
46741: DOUBLE
46742: LD_VAR 0 6
46746: INC
46747: ST_TO_ADDR
46748: LD_INT 1
46750: PUSH
46751: FOR_DOWNTO
46752: IFFALSE 46853
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46754: LD_VAR 0 6
46758: PUSH
46759: LD_VAR 0 4
46763: ARRAY
46764: PUSH
46765: LD_INT 1
46767: ARRAY
46768: PPUSH
46769: LD_VAR 0 6
46773: PUSH
46774: LD_VAR 0 4
46778: ARRAY
46779: PUSH
46780: LD_INT 2
46782: ARRAY
46783: PPUSH
46784: CALL_OW 488
46788: NOT
46789: PUSH
46790: LD_VAR 0 6
46794: PUSH
46795: LD_VAR 0 4
46799: ARRAY
46800: PUSH
46801: LD_INT 1
46803: ARRAY
46804: PPUSH
46805: LD_VAR 0 6
46809: PUSH
46810: LD_VAR 0 4
46814: ARRAY
46815: PUSH
46816: LD_INT 2
46818: ARRAY
46819: PPUSH
46820: CALL_OW 428
46824: PUSH
46825: LD_INT 0
46827: NONEQUAL
46828: OR
46829: IFFALSE 46851
// tmp := Delete ( tmp , i ) ;
46831: LD_ADDR_VAR 0 6
46835: PUSH
46836: LD_VAR 0 6
46840: PPUSH
46841: LD_VAR 0 4
46845: PPUSH
46846: CALL_OW 3
46850: ST_TO_ADDR
46851: GO 46751
46853: POP
46854: POP
// j := GetClosestHex ( unit , tmp ) ;
46855: LD_ADDR_VAR 0 5
46859: PUSH
46860: LD_VAR 0 1
46864: PPUSH
46865: LD_VAR 0 6
46869: PPUSH
46870: CALL 46155 0 2
46874: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46875: LD_VAR 0 1
46879: PPUSH
46880: LD_VAR 0 5
46884: PUSH
46885: LD_INT 1
46887: ARRAY
46888: PPUSH
46889: LD_VAR 0 5
46893: PUSH
46894: LD_INT 2
46896: ARRAY
46897: PPUSH
46898: CALL_OW 111
// end ;
46902: LD_VAR 0 3
46906: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46907: LD_INT 0
46909: PPUSH
46910: PPUSH
46911: PPUSH
// uc_side = 0 ;
46912: LD_ADDR_OWVAR 20
46916: PUSH
46917: LD_INT 0
46919: ST_TO_ADDR
// uc_nation = 0 ;
46920: LD_ADDR_OWVAR 21
46924: PUSH
46925: LD_INT 0
46927: ST_TO_ADDR
// InitHc ;
46928: CALL_OW 19
// InitVc ;
46932: CALL_OW 20
// if mastodonts then
46936: LD_VAR 0 6
46940: IFFALSE 47007
// for i = 1 to mastodonts do
46942: LD_ADDR_VAR 0 11
46946: PUSH
46947: DOUBLE
46948: LD_INT 1
46950: DEC
46951: ST_TO_ADDR
46952: LD_VAR 0 6
46956: PUSH
46957: FOR_TO
46958: IFFALSE 47005
// begin vc_chassis := 31 ;
46960: LD_ADDR_OWVAR 37
46964: PUSH
46965: LD_INT 31
46967: ST_TO_ADDR
// vc_control := control_rider ;
46968: LD_ADDR_OWVAR 38
46972: PUSH
46973: LD_INT 4
46975: ST_TO_ADDR
// animal := CreateVehicle ;
46976: LD_ADDR_VAR 0 12
46980: PUSH
46981: CALL_OW 45
46985: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46986: LD_VAR 0 12
46990: PPUSH
46991: LD_VAR 0 8
46995: PPUSH
46996: LD_INT 0
46998: PPUSH
46999: CALL 49076 0 3
// end ;
47003: GO 46957
47005: POP
47006: POP
// if horses then
47007: LD_VAR 0 5
47011: IFFALSE 47078
// for i = 1 to horses do
47013: LD_ADDR_VAR 0 11
47017: PUSH
47018: DOUBLE
47019: LD_INT 1
47021: DEC
47022: ST_TO_ADDR
47023: LD_VAR 0 5
47027: PUSH
47028: FOR_TO
47029: IFFALSE 47076
// begin hc_class := 21 ;
47031: LD_ADDR_OWVAR 28
47035: PUSH
47036: LD_INT 21
47038: ST_TO_ADDR
// hc_gallery :=  ;
47039: LD_ADDR_OWVAR 33
47043: PUSH
47044: LD_STRING 
47046: ST_TO_ADDR
// animal := CreateHuman ;
47047: LD_ADDR_VAR 0 12
47051: PUSH
47052: CALL_OW 44
47056: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47057: LD_VAR 0 12
47061: PPUSH
47062: LD_VAR 0 8
47066: PPUSH
47067: LD_INT 0
47069: PPUSH
47070: CALL 49076 0 3
// end ;
47074: GO 47028
47076: POP
47077: POP
// if birds then
47078: LD_VAR 0 1
47082: IFFALSE 47149
// for i = 1 to birds do
47084: LD_ADDR_VAR 0 11
47088: PUSH
47089: DOUBLE
47090: LD_INT 1
47092: DEC
47093: ST_TO_ADDR
47094: LD_VAR 0 1
47098: PUSH
47099: FOR_TO
47100: IFFALSE 47147
// begin hc_class = 18 ;
47102: LD_ADDR_OWVAR 28
47106: PUSH
47107: LD_INT 18
47109: ST_TO_ADDR
// hc_gallery =  ;
47110: LD_ADDR_OWVAR 33
47114: PUSH
47115: LD_STRING 
47117: ST_TO_ADDR
// animal := CreateHuman ;
47118: LD_ADDR_VAR 0 12
47122: PUSH
47123: CALL_OW 44
47127: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47128: LD_VAR 0 12
47132: PPUSH
47133: LD_VAR 0 8
47137: PPUSH
47138: LD_INT 0
47140: PPUSH
47141: CALL 49076 0 3
// end ;
47145: GO 47099
47147: POP
47148: POP
// if tigers then
47149: LD_VAR 0 2
47153: IFFALSE 47237
// for i = 1 to tigers do
47155: LD_ADDR_VAR 0 11
47159: PUSH
47160: DOUBLE
47161: LD_INT 1
47163: DEC
47164: ST_TO_ADDR
47165: LD_VAR 0 2
47169: PUSH
47170: FOR_TO
47171: IFFALSE 47235
// begin hc_class = class_tiger ;
47173: LD_ADDR_OWVAR 28
47177: PUSH
47178: LD_INT 14
47180: ST_TO_ADDR
// hc_gallery =  ;
47181: LD_ADDR_OWVAR 33
47185: PUSH
47186: LD_STRING 
47188: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47189: LD_ADDR_OWVAR 35
47193: PUSH
47194: LD_INT 7
47196: NEG
47197: PPUSH
47198: LD_INT 7
47200: PPUSH
47201: CALL_OW 12
47205: ST_TO_ADDR
// animal := CreateHuman ;
47206: LD_ADDR_VAR 0 12
47210: PUSH
47211: CALL_OW 44
47215: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47216: LD_VAR 0 12
47220: PPUSH
47221: LD_VAR 0 8
47225: PPUSH
47226: LD_INT 0
47228: PPUSH
47229: CALL 49076 0 3
// end ;
47233: GO 47170
47235: POP
47236: POP
// if apemans then
47237: LD_VAR 0 3
47241: IFFALSE 47364
// for i = 1 to apemans do
47243: LD_ADDR_VAR 0 11
47247: PUSH
47248: DOUBLE
47249: LD_INT 1
47251: DEC
47252: ST_TO_ADDR
47253: LD_VAR 0 3
47257: PUSH
47258: FOR_TO
47259: IFFALSE 47362
// begin hc_class = class_apeman ;
47261: LD_ADDR_OWVAR 28
47265: PUSH
47266: LD_INT 12
47268: ST_TO_ADDR
// hc_gallery =  ;
47269: LD_ADDR_OWVAR 33
47273: PUSH
47274: LD_STRING 
47276: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
47277: LD_ADDR_OWVAR 35
47281: PUSH
47282: LD_INT 5
47284: NEG
47285: PPUSH
47286: LD_INT 5
47288: PPUSH
47289: CALL_OW 12
47293: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
47294: LD_ADDR_OWVAR 31
47298: PUSH
47299: LD_INT 1
47301: PPUSH
47302: LD_INT 3
47304: PPUSH
47305: CALL_OW 12
47309: PUSH
47310: LD_INT 1
47312: PPUSH
47313: LD_INT 3
47315: PPUSH
47316: CALL_OW 12
47320: PUSH
47321: LD_INT 0
47323: PUSH
47324: LD_INT 0
47326: PUSH
47327: EMPTY
47328: LIST
47329: LIST
47330: LIST
47331: LIST
47332: ST_TO_ADDR
// animal := CreateHuman ;
47333: LD_ADDR_VAR 0 12
47337: PUSH
47338: CALL_OW 44
47342: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47343: LD_VAR 0 12
47347: PPUSH
47348: LD_VAR 0 8
47352: PPUSH
47353: LD_INT 0
47355: PPUSH
47356: CALL 49076 0 3
// end ;
47360: GO 47258
47362: POP
47363: POP
// if enchidnas then
47364: LD_VAR 0 4
47368: IFFALSE 47435
// for i = 1 to enchidnas do
47370: LD_ADDR_VAR 0 11
47374: PUSH
47375: DOUBLE
47376: LD_INT 1
47378: DEC
47379: ST_TO_ADDR
47380: LD_VAR 0 4
47384: PUSH
47385: FOR_TO
47386: IFFALSE 47433
// begin hc_class = 13 ;
47388: LD_ADDR_OWVAR 28
47392: PUSH
47393: LD_INT 13
47395: ST_TO_ADDR
// hc_gallery =  ;
47396: LD_ADDR_OWVAR 33
47400: PUSH
47401: LD_STRING 
47403: ST_TO_ADDR
// animal := CreateHuman ;
47404: LD_ADDR_VAR 0 12
47408: PUSH
47409: CALL_OW 44
47413: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47414: LD_VAR 0 12
47418: PPUSH
47419: LD_VAR 0 8
47423: PPUSH
47424: LD_INT 0
47426: PPUSH
47427: CALL 49076 0 3
// end ;
47431: GO 47385
47433: POP
47434: POP
// if fishes then
47435: LD_VAR 0 7
47439: IFFALSE 47506
// for i = 1 to fishes do
47441: LD_ADDR_VAR 0 11
47445: PUSH
47446: DOUBLE
47447: LD_INT 1
47449: DEC
47450: ST_TO_ADDR
47451: LD_VAR 0 7
47455: PUSH
47456: FOR_TO
47457: IFFALSE 47504
// begin hc_class = 20 ;
47459: LD_ADDR_OWVAR 28
47463: PUSH
47464: LD_INT 20
47466: ST_TO_ADDR
// hc_gallery =  ;
47467: LD_ADDR_OWVAR 33
47471: PUSH
47472: LD_STRING 
47474: ST_TO_ADDR
// animal := CreateHuman ;
47475: LD_ADDR_VAR 0 12
47479: PUSH
47480: CALL_OW 44
47484: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
47485: LD_VAR 0 12
47489: PPUSH
47490: LD_VAR 0 9
47494: PPUSH
47495: LD_INT 0
47497: PPUSH
47498: CALL 49076 0 3
// end ;
47502: GO 47456
47504: POP
47505: POP
// end ;
47506: LD_VAR 0 10
47510: RET
// export function WantHeal ( sci , unit ) ; begin
47511: LD_INT 0
47513: PPUSH
// if GetTaskList ( sci ) > 0 then
47514: LD_VAR 0 1
47518: PPUSH
47519: CALL_OW 437
47523: PUSH
47524: LD_INT 0
47526: GREATER
47527: IFFALSE 47597
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
47529: LD_VAR 0 1
47533: PPUSH
47534: CALL_OW 437
47538: PUSH
47539: LD_INT 1
47541: ARRAY
47542: PUSH
47543: LD_INT 1
47545: ARRAY
47546: PUSH
47547: LD_STRING l
47549: EQUAL
47550: PUSH
47551: LD_VAR 0 1
47555: PPUSH
47556: CALL_OW 437
47560: PUSH
47561: LD_INT 1
47563: ARRAY
47564: PUSH
47565: LD_INT 4
47567: ARRAY
47568: PUSH
47569: LD_VAR 0 2
47573: EQUAL
47574: AND
47575: IFFALSE 47587
// result := true else
47577: LD_ADDR_VAR 0 3
47581: PUSH
47582: LD_INT 1
47584: ST_TO_ADDR
47585: GO 47595
// result := false ;
47587: LD_ADDR_VAR 0 3
47591: PUSH
47592: LD_INT 0
47594: ST_TO_ADDR
// end else
47595: GO 47605
// result := false ;
47597: LD_ADDR_VAR 0 3
47601: PUSH
47602: LD_INT 0
47604: ST_TO_ADDR
// end ;
47605: LD_VAR 0 3
47609: RET
// export function HealTarget ( sci ) ; begin
47610: LD_INT 0
47612: PPUSH
// if not sci then
47613: LD_VAR 0 1
47617: NOT
47618: IFFALSE 47622
// exit ;
47620: GO 47687
// result := 0 ;
47622: LD_ADDR_VAR 0 2
47626: PUSH
47627: LD_INT 0
47629: ST_TO_ADDR
// if GetTaskList ( sci ) then
47630: LD_VAR 0 1
47634: PPUSH
47635: CALL_OW 437
47639: IFFALSE 47687
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
47641: LD_VAR 0 1
47645: PPUSH
47646: CALL_OW 437
47650: PUSH
47651: LD_INT 1
47653: ARRAY
47654: PUSH
47655: LD_INT 1
47657: ARRAY
47658: PUSH
47659: LD_STRING l
47661: EQUAL
47662: IFFALSE 47687
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
47664: LD_ADDR_VAR 0 2
47668: PUSH
47669: LD_VAR 0 1
47673: PPUSH
47674: CALL_OW 437
47678: PUSH
47679: LD_INT 1
47681: ARRAY
47682: PUSH
47683: LD_INT 4
47685: ARRAY
47686: ST_TO_ADDR
// end ;
47687: LD_VAR 0 2
47691: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
47692: LD_INT 0
47694: PPUSH
47695: PPUSH
47696: PPUSH
47697: PPUSH
// if not base_units then
47698: LD_VAR 0 1
47702: NOT
47703: IFFALSE 47707
// exit ;
47705: GO 47794
// result := false ;
47707: LD_ADDR_VAR 0 2
47711: PUSH
47712: LD_INT 0
47714: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
47715: LD_ADDR_VAR 0 5
47719: PUSH
47720: LD_VAR 0 1
47724: PPUSH
47725: LD_INT 21
47727: PUSH
47728: LD_INT 3
47730: PUSH
47731: EMPTY
47732: LIST
47733: LIST
47734: PPUSH
47735: CALL_OW 72
47739: ST_TO_ADDR
// if not tmp then
47740: LD_VAR 0 5
47744: NOT
47745: IFFALSE 47749
// exit ;
47747: GO 47794
// for i in tmp do
47749: LD_ADDR_VAR 0 3
47753: PUSH
47754: LD_VAR 0 5
47758: PUSH
47759: FOR_IN
47760: IFFALSE 47792
// begin result := EnemyInRange ( i , 22 ) ;
47762: LD_ADDR_VAR 0 2
47766: PUSH
47767: LD_VAR 0 3
47771: PPUSH
47772: LD_INT 22
47774: PPUSH
47775: CALL 46030 0 2
47779: ST_TO_ADDR
// if result then
47780: LD_VAR 0 2
47784: IFFALSE 47790
// exit ;
47786: POP
47787: POP
47788: GO 47794
// end ;
47790: GO 47759
47792: POP
47793: POP
// end ;
47794: LD_VAR 0 2
47798: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
47799: LD_INT 0
47801: PPUSH
47802: PPUSH
// if not units then
47803: LD_VAR 0 1
47807: NOT
47808: IFFALSE 47812
// exit ;
47810: GO 47882
// result := [ ] ;
47812: LD_ADDR_VAR 0 3
47816: PUSH
47817: EMPTY
47818: ST_TO_ADDR
// for i in units do
47819: LD_ADDR_VAR 0 4
47823: PUSH
47824: LD_VAR 0 1
47828: PUSH
47829: FOR_IN
47830: IFFALSE 47880
// if GetTag ( i ) = tag then
47832: LD_VAR 0 4
47836: PPUSH
47837: CALL_OW 110
47841: PUSH
47842: LD_VAR 0 2
47846: EQUAL
47847: IFFALSE 47878
// result := Insert ( result , result + 1 , i ) ;
47849: LD_ADDR_VAR 0 3
47853: PUSH
47854: LD_VAR 0 3
47858: PPUSH
47859: LD_VAR 0 3
47863: PUSH
47864: LD_INT 1
47866: PLUS
47867: PPUSH
47868: LD_VAR 0 4
47872: PPUSH
47873: CALL_OW 2
47877: ST_TO_ADDR
47878: GO 47829
47880: POP
47881: POP
// end ;
47882: LD_VAR 0 3
47886: RET
// export function IsDriver ( un ) ; begin
47887: LD_INT 0
47889: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
47890: LD_ADDR_VAR 0 2
47894: PUSH
47895: LD_VAR 0 1
47899: PUSH
47900: LD_INT 55
47902: PUSH
47903: EMPTY
47904: LIST
47905: PPUSH
47906: CALL_OW 69
47910: IN
47911: ST_TO_ADDR
// end ;
47912: LD_VAR 0 2
47916: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
47917: LD_INT 0
47919: PPUSH
47920: PPUSH
// list := [ ] ;
47921: LD_ADDR_VAR 0 5
47925: PUSH
47926: EMPTY
47927: ST_TO_ADDR
// case d of 0 :
47928: LD_VAR 0 3
47932: PUSH
47933: LD_INT 0
47935: DOUBLE
47936: EQUAL
47937: IFTRUE 47941
47939: GO 48074
47941: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
47942: LD_ADDR_VAR 0 5
47946: PUSH
47947: LD_VAR 0 1
47951: PUSH
47952: LD_INT 4
47954: MINUS
47955: PUSH
47956: LD_VAR 0 2
47960: PUSH
47961: LD_INT 4
47963: MINUS
47964: PUSH
47965: LD_INT 2
47967: PUSH
47968: EMPTY
47969: LIST
47970: LIST
47971: LIST
47972: PUSH
47973: LD_VAR 0 1
47977: PUSH
47978: LD_INT 3
47980: MINUS
47981: PUSH
47982: LD_VAR 0 2
47986: PUSH
47987: LD_INT 1
47989: PUSH
47990: EMPTY
47991: LIST
47992: LIST
47993: LIST
47994: PUSH
47995: LD_VAR 0 1
47999: PUSH
48000: LD_INT 4
48002: PLUS
48003: PUSH
48004: LD_VAR 0 2
48008: PUSH
48009: LD_INT 4
48011: PUSH
48012: EMPTY
48013: LIST
48014: LIST
48015: LIST
48016: PUSH
48017: LD_VAR 0 1
48021: PUSH
48022: LD_INT 3
48024: PLUS
48025: PUSH
48026: LD_VAR 0 2
48030: PUSH
48031: LD_INT 3
48033: PLUS
48034: PUSH
48035: LD_INT 5
48037: PUSH
48038: EMPTY
48039: LIST
48040: LIST
48041: LIST
48042: PUSH
48043: LD_VAR 0 1
48047: PUSH
48048: LD_VAR 0 2
48052: PUSH
48053: LD_INT 4
48055: PLUS
48056: PUSH
48057: LD_INT 0
48059: PUSH
48060: EMPTY
48061: LIST
48062: LIST
48063: LIST
48064: PUSH
48065: EMPTY
48066: LIST
48067: LIST
48068: LIST
48069: LIST
48070: LIST
48071: ST_TO_ADDR
// end ; 1 :
48072: GO 48772
48074: LD_INT 1
48076: DOUBLE
48077: EQUAL
48078: IFTRUE 48082
48080: GO 48215
48082: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48083: LD_ADDR_VAR 0 5
48087: PUSH
48088: LD_VAR 0 1
48092: PUSH
48093: LD_VAR 0 2
48097: PUSH
48098: LD_INT 4
48100: MINUS
48101: PUSH
48102: LD_INT 3
48104: PUSH
48105: EMPTY
48106: LIST
48107: LIST
48108: LIST
48109: PUSH
48110: LD_VAR 0 1
48114: PUSH
48115: LD_INT 3
48117: MINUS
48118: PUSH
48119: LD_VAR 0 2
48123: PUSH
48124: LD_INT 3
48126: MINUS
48127: PUSH
48128: LD_INT 2
48130: PUSH
48131: EMPTY
48132: LIST
48133: LIST
48134: LIST
48135: PUSH
48136: LD_VAR 0 1
48140: PUSH
48141: LD_INT 4
48143: MINUS
48144: PUSH
48145: LD_VAR 0 2
48149: PUSH
48150: LD_INT 1
48152: PUSH
48153: EMPTY
48154: LIST
48155: LIST
48156: LIST
48157: PUSH
48158: LD_VAR 0 1
48162: PUSH
48163: LD_VAR 0 2
48167: PUSH
48168: LD_INT 3
48170: PLUS
48171: PUSH
48172: LD_INT 0
48174: PUSH
48175: EMPTY
48176: LIST
48177: LIST
48178: LIST
48179: PUSH
48180: LD_VAR 0 1
48184: PUSH
48185: LD_INT 4
48187: PLUS
48188: PUSH
48189: LD_VAR 0 2
48193: PUSH
48194: LD_INT 4
48196: PLUS
48197: PUSH
48198: LD_INT 5
48200: PUSH
48201: EMPTY
48202: LIST
48203: LIST
48204: LIST
48205: PUSH
48206: EMPTY
48207: LIST
48208: LIST
48209: LIST
48210: LIST
48211: LIST
48212: ST_TO_ADDR
// end ; 2 :
48213: GO 48772
48215: LD_INT 2
48217: DOUBLE
48218: EQUAL
48219: IFTRUE 48223
48221: GO 48352
48223: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48224: LD_ADDR_VAR 0 5
48228: PUSH
48229: LD_VAR 0 1
48233: PUSH
48234: LD_VAR 0 2
48238: PUSH
48239: LD_INT 3
48241: MINUS
48242: PUSH
48243: LD_INT 3
48245: PUSH
48246: EMPTY
48247: LIST
48248: LIST
48249: LIST
48250: PUSH
48251: LD_VAR 0 1
48255: PUSH
48256: LD_INT 4
48258: PLUS
48259: PUSH
48260: LD_VAR 0 2
48264: PUSH
48265: LD_INT 4
48267: PUSH
48268: EMPTY
48269: LIST
48270: LIST
48271: LIST
48272: PUSH
48273: LD_VAR 0 1
48277: PUSH
48278: LD_VAR 0 2
48282: PUSH
48283: LD_INT 4
48285: PLUS
48286: PUSH
48287: LD_INT 0
48289: PUSH
48290: EMPTY
48291: LIST
48292: LIST
48293: LIST
48294: PUSH
48295: LD_VAR 0 1
48299: PUSH
48300: LD_INT 3
48302: MINUS
48303: PUSH
48304: LD_VAR 0 2
48308: PUSH
48309: LD_INT 1
48311: PUSH
48312: EMPTY
48313: LIST
48314: LIST
48315: LIST
48316: PUSH
48317: LD_VAR 0 1
48321: PUSH
48322: LD_INT 4
48324: MINUS
48325: PUSH
48326: LD_VAR 0 2
48330: PUSH
48331: LD_INT 4
48333: MINUS
48334: PUSH
48335: LD_INT 2
48337: PUSH
48338: EMPTY
48339: LIST
48340: LIST
48341: LIST
48342: PUSH
48343: EMPTY
48344: LIST
48345: LIST
48346: LIST
48347: LIST
48348: LIST
48349: ST_TO_ADDR
// end ; 3 :
48350: GO 48772
48352: LD_INT 3
48354: DOUBLE
48355: EQUAL
48356: IFTRUE 48360
48358: GO 48493
48360: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
48361: LD_ADDR_VAR 0 5
48365: PUSH
48366: LD_VAR 0 1
48370: PUSH
48371: LD_INT 3
48373: PLUS
48374: PUSH
48375: LD_VAR 0 2
48379: PUSH
48380: LD_INT 4
48382: PUSH
48383: EMPTY
48384: LIST
48385: LIST
48386: LIST
48387: PUSH
48388: LD_VAR 0 1
48392: PUSH
48393: LD_INT 4
48395: PLUS
48396: PUSH
48397: LD_VAR 0 2
48401: PUSH
48402: LD_INT 4
48404: PLUS
48405: PUSH
48406: LD_INT 5
48408: PUSH
48409: EMPTY
48410: LIST
48411: LIST
48412: LIST
48413: PUSH
48414: LD_VAR 0 1
48418: PUSH
48419: LD_INT 4
48421: MINUS
48422: PUSH
48423: LD_VAR 0 2
48427: PUSH
48428: LD_INT 1
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: LIST
48435: PUSH
48436: LD_VAR 0 1
48440: PUSH
48441: LD_VAR 0 2
48445: PUSH
48446: LD_INT 4
48448: MINUS
48449: PUSH
48450: LD_INT 3
48452: PUSH
48453: EMPTY
48454: LIST
48455: LIST
48456: LIST
48457: PUSH
48458: LD_VAR 0 1
48462: PUSH
48463: LD_INT 3
48465: MINUS
48466: PUSH
48467: LD_VAR 0 2
48471: PUSH
48472: LD_INT 3
48474: MINUS
48475: PUSH
48476: LD_INT 2
48478: PUSH
48479: EMPTY
48480: LIST
48481: LIST
48482: LIST
48483: PUSH
48484: EMPTY
48485: LIST
48486: LIST
48487: LIST
48488: LIST
48489: LIST
48490: ST_TO_ADDR
// end ; 4 :
48491: GO 48772
48493: LD_INT 4
48495: DOUBLE
48496: EQUAL
48497: IFTRUE 48501
48499: GO 48634
48501: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
48502: LD_ADDR_VAR 0 5
48506: PUSH
48507: LD_VAR 0 1
48511: PUSH
48512: LD_VAR 0 2
48516: PUSH
48517: LD_INT 4
48519: PLUS
48520: PUSH
48521: LD_INT 0
48523: PUSH
48524: EMPTY
48525: LIST
48526: LIST
48527: LIST
48528: PUSH
48529: LD_VAR 0 1
48533: PUSH
48534: LD_INT 3
48536: PLUS
48537: PUSH
48538: LD_VAR 0 2
48542: PUSH
48543: LD_INT 3
48545: PLUS
48546: PUSH
48547: LD_INT 5
48549: PUSH
48550: EMPTY
48551: LIST
48552: LIST
48553: LIST
48554: PUSH
48555: LD_VAR 0 1
48559: PUSH
48560: LD_INT 4
48562: PLUS
48563: PUSH
48564: LD_VAR 0 2
48568: PUSH
48569: LD_INT 4
48571: PUSH
48572: EMPTY
48573: LIST
48574: LIST
48575: LIST
48576: PUSH
48577: LD_VAR 0 1
48581: PUSH
48582: LD_VAR 0 2
48586: PUSH
48587: LD_INT 3
48589: MINUS
48590: PUSH
48591: LD_INT 3
48593: PUSH
48594: EMPTY
48595: LIST
48596: LIST
48597: LIST
48598: PUSH
48599: LD_VAR 0 1
48603: PUSH
48604: LD_INT 4
48606: MINUS
48607: PUSH
48608: LD_VAR 0 2
48612: PUSH
48613: LD_INT 4
48615: MINUS
48616: PUSH
48617: LD_INT 2
48619: PUSH
48620: EMPTY
48621: LIST
48622: LIST
48623: LIST
48624: PUSH
48625: EMPTY
48626: LIST
48627: LIST
48628: LIST
48629: LIST
48630: LIST
48631: ST_TO_ADDR
// end ; 5 :
48632: GO 48772
48634: LD_INT 5
48636: DOUBLE
48637: EQUAL
48638: IFTRUE 48642
48640: GO 48771
48642: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
48643: LD_ADDR_VAR 0 5
48647: PUSH
48648: LD_VAR 0 1
48652: PUSH
48653: LD_INT 4
48655: MINUS
48656: PUSH
48657: LD_VAR 0 2
48661: PUSH
48662: LD_INT 1
48664: PUSH
48665: EMPTY
48666: LIST
48667: LIST
48668: LIST
48669: PUSH
48670: LD_VAR 0 1
48674: PUSH
48675: LD_VAR 0 2
48679: PUSH
48680: LD_INT 4
48682: MINUS
48683: PUSH
48684: LD_INT 3
48686: PUSH
48687: EMPTY
48688: LIST
48689: LIST
48690: LIST
48691: PUSH
48692: LD_VAR 0 1
48696: PUSH
48697: LD_INT 4
48699: PLUS
48700: PUSH
48701: LD_VAR 0 2
48705: PUSH
48706: LD_INT 4
48708: PLUS
48709: PUSH
48710: LD_INT 5
48712: PUSH
48713: EMPTY
48714: LIST
48715: LIST
48716: LIST
48717: PUSH
48718: LD_VAR 0 1
48722: PUSH
48723: LD_INT 3
48725: PLUS
48726: PUSH
48727: LD_VAR 0 2
48731: PUSH
48732: LD_INT 4
48734: PUSH
48735: EMPTY
48736: LIST
48737: LIST
48738: LIST
48739: PUSH
48740: LD_VAR 0 1
48744: PUSH
48745: LD_VAR 0 2
48749: PUSH
48750: LD_INT 3
48752: PLUS
48753: PUSH
48754: LD_INT 0
48756: PUSH
48757: EMPTY
48758: LIST
48759: LIST
48760: LIST
48761: PUSH
48762: EMPTY
48763: LIST
48764: LIST
48765: LIST
48766: LIST
48767: LIST
48768: ST_TO_ADDR
// end ; end ;
48769: GO 48772
48771: POP
// result := list ;
48772: LD_ADDR_VAR 0 4
48776: PUSH
48777: LD_VAR 0 5
48781: ST_TO_ADDR
// end ;
48782: LD_VAR 0 4
48786: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
48787: LD_INT 0
48789: PPUSH
48790: PPUSH
48791: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
48792: LD_VAR 0 1
48796: NOT
48797: PUSH
48798: LD_VAR 0 2
48802: PUSH
48803: LD_INT 1
48805: PUSH
48806: LD_INT 2
48808: PUSH
48809: LD_INT 3
48811: PUSH
48812: LD_INT 4
48814: PUSH
48815: EMPTY
48816: LIST
48817: LIST
48818: LIST
48819: LIST
48820: IN
48821: NOT
48822: OR
48823: IFFALSE 48827
// exit ;
48825: GO 48919
// tmp := [ ] ;
48827: LD_ADDR_VAR 0 5
48831: PUSH
48832: EMPTY
48833: ST_TO_ADDR
// for i in units do
48834: LD_ADDR_VAR 0 4
48838: PUSH
48839: LD_VAR 0 1
48843: PUSH
48844: FOR_IN
48845: IFFALSE 48888
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
48847: LD_ADDR_VAR 0 5
48851: PUSH
48852: LD_VAR 0 5
48856: PPUSH
48857: LD_VAR 0 5
48861: PUSH
48862: LD_INT 1
48864: PLUS
48865: PPUSH
48866: LD_VAR 0 4
48870: PPUSH
48871: LD_VAR 0 2
48875: PPUSH
48876: CALL_OW 259
48880: PPUSH
48881: CALL_OW 2
48885: ST_TO_ADDR
48886: GO 48844
48888: POP
48889: POP
// if not tmp then
48890: LD_VAR 0 5
48894: NOT
48895: IFFALSE 48899
// exit ;
48897: GO 48919
// result := SortListByListDesc ( units , tmp ) ;
48899: LD_ADDR_VAR 0 3
48903: PUSH
48904: LD_VAR 0 1
48908: PPUSH
48909: LD_VAR 0 5
48913: PPUSH
48914: CALL_OW 77
48918: ST_TO_ADDR
// end ;
48919: LD_VAR 0 3
48923: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
48924: LD_INT 0
48926: PPUSH
48927: PPUSH
48928: PPUSH
// x := GetX ( building ) ;
48929: LD_ADDR_VAR 0 4
48933: PUSH
48934: LD_VAR 0 2
48938: PPUSH
48939: CALL_OW 250
48943: ST_TO_ADDR
// y := GetY ( building ) ;
48944: LD_ADDR_VAR 0 5
48948: PUSH
48949: LD_VAR 0 2
48953: PPUSH
48954: CALL_OW 251
48958: ST_TO_ADDR
// if GetTaskList ( unit ) then
48959: LD_VAR 0 1
48963: PPUSH
48964: CALL_OW 437
48968: IFFALSE 49063
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
48970: LD_STRING e
48972: PUSH
48973: LD_VAR 0 1
48977: PPUSH
48978: CALL_OW 437
48982: PUSH
48983: LD_INT 1
48985: ARRAY
48986: PUSH
48987: LD_INT 1
48989: ARRAY
48990: EQUAL
48991: PUSH
48992: LD_VAR 0 4
48996: PUSH
48997: LD_VAR 0 1
49001: PPUSH
49002: CALL_OW 437
49006: PUSH
49007: LD_INT 1
49009: ARRAY
49010: PUSH
49011: LD_INT 2
49013: ARRAY
49014: EQUAL
49015: AND
49016: PUSH
49017: LD_VAR 0 5
49021: PUSH
49022: LD_VAR 0 1
49026: PPUSH
49027: CALL_OW 437
49031: PUSH
49032: LD_INT 1
49034: ARRAY
49035: PUSH
49036: LD_INT 3
49038: ARRAY
49039: EQUAL
49040: AND
49041: IFFALSE 49053
// result := true else
49043: LD_ADDR_VAR 0 3
49047: PUSH
49048: LD_INT 1
49050: ST_TO_ADDR
49051: GO 49061
// result := false ;
49053: LD_ADDR_VAR 0 3
49057: PUSH
49058: LD_INT 0
49060: ST_TO_ADDR
// end else
49061: GO 49071
// result := false ;
49063: LD_ADDR_VAR 0 3
49067: PUSH
49068: LD_INT 0
49070: ST_TO_ADDR
// end ;
49071: LD_VAR 0 3
49075: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49076: LD_INT 0
49078: PPUSH
49079: PPUSH
49080: PPUSH
49081: PPUSH
// if not unit or not area then
49082: LD_VAR 0 1
49086: NOT
49087: PUSH
49088: LD_VAR 0 2
49092: NOT
49093: OR
49094: IFFALSE 49098
// exit ;
49096: GO 49262
// tmp := AreaToList ( area , i ) ;
49098: LD_ADDR_VAR 0 6
49102: PUSH
49103: LD_VAR 0 2
49107: PPUSH
49108: LD_VAR 0 5
49112: PPUSH
49113: CALL_OW 517
49117: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49118: LD_ADDR_VAR 0 5
49122: PUSH
49123: DOUBLE
49124: LD_INT 1
49126: DEC
49127: ST_TO_ADDR
49128: LD_VAR 0 6
49132: PUSH
49133: LD_INT 1
49135: ARRAY
49136: PUSH
49137: FOR_TO
49138: IFFALSE 49260
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
49140: LD_ADDR_VAR 0 7
49144: PUSH
49145: LD_VAR 0 6
49149: PUSH
49150: LD_INT 1
49152: ARRAY
49153: PUSH
49154: LD_VAR 0 5
49158: ARRAY
49159: PUSH
49160: LD_VAR 0 6
49164: PUSH
49165: LD_INT 2
49167: ARRAY
49168: PUSH
49169: LD_VAR 0 5
49173: ARRAY
49174: PUSH
49175: EMPTY
49176: LIST
49177: LIST
49178: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
49179: LD_VAR 0 7
49183: PUSH
49184: LD_INT 1
49186: ARRAY
49187: PPUSH
49188: LD_VAR 0 7
49192: PUSH
49193: LD_INT 2
49195: ARRAY
49196: PPUSH
49197: CALL_OW 428
49201: PUSH
49202: LD_INT 0
49204: EQUAL
49205: IFFALSE 49258
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
49207: LD_VAR 0 1
49211: PPUSH
49212: LD_VAR 0 7
49216: PUSH
49217: LD_INT 1
49219: ARRAY
49220: PPUSH
49221: LD_VAR 0 7
49225: PUSH
49226: LD_INT 2
49228: ARRAY
49229: PPUSH
49230: LD_VAR 0 3
49234: PPUSH
49235: CALL_OW 48
// result := IsPlaced ( unit ) ;
49239: LD_ADDR_VAR 0 4
49243: PUSH
49244: LD_VAR 0 1
49248: PPUSH
49249: CALL_OW 305
49253: ST_TO_ADDR
// exit ;
49254: POP
49255: POP
49256: GO 49262
// end ; end ;
49258: GO 49137
49260: POP
49261: POP
// end ;
49262: LD_VAR 0 4
49266: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
49267: LD_INT 0
49269: PPUSH
49270: PPUSH
49271: PPUSH
// if not side or side > 8 then
49272: LD_VAR 0 1
49276: NOT
49277: PUSH
49278: LD_VAR 0 1
49282: PUSH
49283: LD_INT 8
49285: GREATER
49286: OR
49287: IFFALSE 49291
// exit ;
49289: GO 49478
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
49291: LD_ADDR_VAR 0 4
49295: PUSH
49296: LD_INT 22
49298: PUSH
49299: LD_VAR 0 1
49303: PUSH
49304: EMPTY
49305: LIST
49306: LIST
49307: PUSH
49308: LD_INT 21
49310: PUSH
49311: LD_INT 3
49313: PUSH
49314: EMPTY
49315: LIST
49316: LIST
49317: PUSH
49318: EMPTY
49319: LIST
49320: LIST
49321: PPUSH
49322: CALL_OW 69
49326: ST_TO_ADDR
// if not tmp then
49327: LD_VAR 0 4
49331: NOT
49332: IFFALSE 49336
// exit ;
49334: GO 49478
// enable_addtolog := true ;
49336: LD_ADDR_OWVAR 81
49340: PUSH
49341: LD_INT 1
49343: ST_TO_ADDR
// AddToLog ( [ ) ;
49344: LD_STRING [
49346: PPUSH
49347: CALL_OW 561
// for i in tmp do
49351: LD_ADDR_VAR 0 3
49355: PUSH
49356: LD_VAR 0 4
49360: PUSH
49361: FOR_IN
49362: IFFALSE 49469
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
49364: LD_STRING [
49366: PUSH
49367: LD_VAR 0 3
49371: PPUSH
49372: CALL_OW 266
49376: STR
49377: PUSH
49378: LD_STRING , 
49380: STR
49381: PUSH
49382: LD_VAR 0 3
49386: PPUSH
49387: CALL_OW 250
49391: STR
49392: PUSH
49393: LD_STRING , 
49395: STR
49396: PUSH
49397: LD_VAR 0 3
49401: PPUSH
49402: CALL_OW 251
49406: STR
49407: PUSH
49408: LD_STRING , 
49410: STR
49411: PUSH
49412: LD_VAR 0 3
49416: PPUSH
49417: CALL_OW 254
49421: STR
49422: PUSH
49423: LD_STRING , 
49425: STR
49426: PUSH
49427: LD_VAR 0 3
49431: PPUSH
49432: LD_INT 1
49434: PPUSH
49435: CALL_OW 268
49439: STR
49440: PUSH
49441: LD_STRING , 
49443: STR
49444: PUSH
49445: LD_VAR 0 3
49449: PPUSH
49450: LD_INT 2
49452: PPUSH
49453: CALL_OW 268
49457: STR
49458: PUSH
49459: LD_STRING ],
49461: STR
49462: PPUSH
49463: CALL_OW 561
// end ;
49467: GO 49361
49469: POP
49470: POP
// AddToLog ( ]; ) ;
49471: LD_STRING ];
49473: PPUSH
49474: CALL_OW 561
// end ;
49478: LD_VAR 0 2
49482: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
49483: LD_INT 0
49485: PPUSH
49486: PPUSH
49487: PPUSH
49488: PPUSH
49489: PPUSH
// if not area or not rate or not max then
49490: LD_VAR 0 1
49494: NOT
49495: PUSH
49496: LD_VAR 0 2
49500: NOT
49501: OR
49502: PUSH
49503: LD_VAR 0 4
49507: NOT
49508: OR
49509: IFFALSE 49513
// exit ;
49511: GO 49705
// while 1 do
49513: LD_INT 1
49515: IFFALSE 49705
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
49517: LD_ADDR_VAR 0 9
49521: PUSH
49522: LD_VAR 0 1
49526: PPUSH
49527: LD_INT 1
49529: PPUSH
49530: CALL_OW 287
49534: PUSH
49535: LD_INT 10
49537: MUL
49538: ST_TO_ADDR
// r := rate / 10 ;
49539: LD_ADDR_VAR 0 7
49543: PUSH
49544: LD_VAR 0 2
49548: PUSH
49549: LD_INT 10
49551: DIVREAL
49552: ST_TO_ADDR
// time := 1 1$00 ;
49553: LD_ADDR_VAR 0 8
49557: PUSH
49558: LD_INT 2100
49560: ST_TO_ADDR
// if amount < min then
49561: LD_VAR 0 9
49565: PUSH
49566: LD_VAR 0 3
49570: LESS
49571: IFFALSE 49589
// r := r * 2 else
49573: LD_ADDR_VAR 0 7
49577: PUSH
49578: LD_VAR 0 7
49582: PUSH
49583: LD_INT 2
49585: MUL
49586: ST_TO_ADDR
49587: GO 49615
// if amount > max then
49589: LD_VAR 0 9
49593: PUSH
49594: LD_VAR 0 4
49598: GREATER
49599: IFFALSE 49615
// r := r / 2 ;
49601: LD_ADDR_VAR 0 7
49605: PUSH
49606: LD_VAR 0 7
49610: PUSH
49611: LD_INT 2
49613: DIVREAL
49614: ST_TO_ADDR
// time := time / r ;
49615: LD_ADDR_VAR 0 8
49619: PUSH
49620: LD_VAR 0 8
49624: PUSH
49625: LD_VAR 0 7
49629: DIVREAL
49630: ST_TO_ADDR
// if time < 0 then
49631: LD_VAR 0 8
49635: PUSH
49636: LD_INT 0
49638: LESS
49639: IFFALSE 49656
// time := time * - 1 ;
49641: LD_ADDR_VAR 0 8
49645: PUSH
49646: LD_VAR 0 8
49650: PUSH
49651: LD_INT 1
49653: NEG
49654: MUL
49655: ST_TO_ADDR
// wait ( time ) ;
49656: LD_VAR 0 8
49660: PPUSH
49661: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
49665: LD_INT 35
49667: PPUSH
49668: LD_INT 875
49670: PPUSH
49671: CALL_OW 12
49675: PPUSH
49676: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
49680: LD_INT 1
49682: PPUSH
49683: LD_INT 5
49685: PPUSH
49686: CALL_OW 12
49690: PPUSH
49691: LD_VAR 0 1
49695: PPUSH
49696: LD_INT 1
49698: PPUSH
49699: CALL_OW 55
// end ;
49703: GO 49513
// end ;
49705: LD_VAR 0 5
49709: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
49710: LD_INT 0
49712: PPUSH
49713: PPUSH
49714: PPUSH
49715: PPUSH
49716: PPUSH
49717: PPUSH
49718: PPUSH
49719: PPUSH
// if not turrets or not factories then
49720: LD_VAR 0 1
49724: NOT
49725: PUSH
49726: LD_VAR 0 2
49730: NOT
49731: OR
49732: IFFALSE 49736
// exit ;
49734: GO 50043
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
49736: LD_ADDR_VAR 0 10
49740: PUSH
49741: LD_INT 5
49743: PUSH
49744: LD_INT 6
49746: PUSH
49747: EMPTY
49748: LIST
49749: LIST
49750: PUSH
49751: LD_INT 2
49753: PUSH
49754: LD_INT 4
49756: PUSH
49757: EMPTY
49758: LIST
49759: LIST
49760: PUSH
49761: LD_INT 3
49763: PUSH
49764: LD_INT 5
49766: PUSH
49767: EMPTY
49768: LIST
49769: LIST
49770: PUSH
49771: EMPTY
49772: LIST
49773: LIST
49774: LIST
49775: PUSH
49776: LD_INT 24
49778: PUSH
49779: LD_INT 25
49781: PUSH
49782: EMPTY
49783: LIST
49784: LIST
49785: PUSH
49786: LD_INT 23
49788: PUSH
49789: LD_INT 27
49791: PUSH
49792: EMPTY
49793: LIST
49794: LIST
49795: PUSH
49796: EMPTY
49797: LIST
49798: LIST
49799: PUSH
49800: LD_INT 42
49802: PUSH
49803: LD_INT 43
49805: PUSH
49806: EMPTY
49807: LIST
49808: LIST
49809: PUSH
49810: LD_INT 44
49812: PUSH
49813: LD_INT 46
49815: PUSH
49816: EMPTY
49817: LIST
49818: LIST
49819: PUSH
49820: LD_INT 45
49822: PUSH
49823: LD_INT 47
49825: PUSH
49826: EMPTY
49827: LIST
49828: LIST
49829: PUSH
49830: EMPTY
49831: LIST
49832: LIST
49833: LIST
49834: PUSH
49835: EMPTY
49836: LIST
49837: LIST
49838: LIST
49839: ST_TO_ADDR
// result := [ ] ;
49840: LD_ADDR_VAR 0 3
49844: PUSH
49845: EMPTY
49846: ST_TO_ADDR
// for i in turrets do
49847: LD_ADDR_VAR 0 4
49851: PUSH
49852: LD_VAR 0 1
49856: PUSH
49857: FOR_IN
49858: IFFALSE 50041
// begin nat := GetNation ( i ) ;
49860: LD_ADDR_VAR 0 7
49864: PUSH
49865: LD_VAR 0 4
49869: PPUSH
49870: CALL_OW 248
49874: ST_TO_ADDR
// weapon := 0 ;
49875: LD_ADDR_VAR 0 8
49879: PUSH
49880: LD_INT 0
49882: ST_TO_ADDR
// if not nat then
49883: LD_VAR 0 7
49887: NOT
49888: IFFALSE 49892
// continue ;
49890: GO 49857
// for j in list [ nat ] do
49892: LD_ADDR_VAR 0 5
49896: PUSH
49897: LD_VAR 0 10
49901: PUSH
49902: LD_VAR 0 7
49906: ARRAY
49907: PUSH
49908: FOR_IN
49909: IFFALSE 49950
// if GetBWeapon ( i ) = j [ 1 ] then
49911: LD_VAR 0 4
49915: PPUSH
49916: CALL_OW 269
49920: PUSH
49921: LD_VAR 0 5
49925: PUSH
49926: LD_INT 1
49928: ARRAY
49929: EQUAL
49930: IFFALSE 49948
// begin weapon := j [ 2 ] ;
49932: LD_ADDR_VAR 0 8
49936: PUSH
49937: LD_VAR 0 5
49941: PUSH
49942: LD_INT 2
49944: ARRAY
49945: ST_TO_ADDR
// break ;
49946: GO 49950
// end ;
49948: GO 49908
49950: POP
49951: POP
// if not weapon then
49952: LD_VAR 0 8
49956: NOT
49957: IFFALSE 49961
// continue ;
49959: GO 49857
// for k in factories do
49961: LD_ADDR_VAR 0 6
49965: PUSH
49966: LD_VAR 0 2
49970: PUSH
49971: FOR_IN
49972: IFFALSE 50037
// begin weapons := AvailableWeaponList ( k ) ;
49974: LD_ADDR_VAR 0 9
49978: PUSH
49979: LD_VAR 0 6
49983: PPUSH
49984: CALL_OW 478
49988: ST_TO_ADDR
// if not weapons then
49989: LD_VAR 0 9
49993: NOT
49994: IFFALSE 49998
// continue ;
49996: GO 49971
// if weapon in weapons then
49998: LD_VAR 0 8
50002: PUSH
50003: LD_VAR 0 9
50007: IN
50008: IFFALSE 50035
// begin result := [ i , weapon ] ;
50010: LD_ADDR_VAR 0 3
50014: PUSH
50015: LD_VAR 0 4
50019: PUSH
50020: LD_VAR 0 8
50024: PUSH
50025: EMPTY
50026: LIST
50027: LIST
50028: ST_TO_ADDR
// exit ;
50029: POP
50030: POP
50031: POP
50032: POP
50033: GO 50043
// end ; end ;
50035: GO 49971
50037: POP
50038: POP
// end ;
50039: GO 49857
50041: POP
50042: POP
// end ;
50043: LD_VAR 0 3
50047: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50048: LD_INT 0
50050: PPUSH
// if not side or side > 8 then
50051: LD_VAR 0 3
50055: NOT
50056: PUSH
50057: LD_VAR 0 3
50061: PUSH
50062: LD_INT 8
50064: GREATER
50065: OR
50066: IFFALSE 50070
// exit ;
50068: GO 50129
// if not range then
50070: LD_VAR 0 4
50074: NOT
50075: IFFALSE 50086
// range := - 12 ;
50077: LD_ADDR_VAR 0 4
50081: PUSH
50082: LD_INT 12
50084: NEG
50085: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50086: LD_VAR 0 1
50090: PPUSH
50091: LD_VAR 0 2
50095: PPUSH
50096: LD_VAR 0 3
50100: PPUSH
50101: LD_VAR 0 4
50105: PPUSH
50106: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50110: LD_VAR 0 1
50114: PPUSH
50115: LD_VAR 0 2
50119: PPUSH
50120: LD_VAR 0 3
50124: PPUSH
50125: CALL_OW 331
// end ;
50129: LD_VAR 0 5
50133: RET
// export function Video ( mode ) ; begin
50134: LD_INT 0
50136: PPUSH
// ingame_video = mode ;
50137: LD_ADDR_OWVAR 52
50141: PUSH
50142: LD_VAR 0 1
50146: ST_TO_ADDR
// interface_hidden = mode ;
50147: LD_ADDR_OWVAR 54
50151: PUSH
50152: LD_VAR 0 1
50156: ST_TO_ADDR
// end ;
50157: LD_VAR 0 2
50161: RET
// export function Join ( array , element ) ; begin
50162: LD_INT 0
50164: PPUSH
// result := array ^ element ;
50165: LD_ADDR_VAR 0 3
50169: PUSH
50170: LD_VAR 0 1
50174: PUSH
50175: LD_VAR 0 2
50179: ADD
50180: ST_TO_ADDR
// end ;
50181: LD_VAR 0 3
50185: RET
// export function JoinUnion ( array , element ) ; begin
50186: LD_INT 0
50188: PPUSH
// result := array union element ;
50189: LD_ADDR_VAR 0 3
50193: PUSH
50194: LD_VAR 0 1
50198: PUSH
50199: LD_VAR 0 2
50203: UNION
50204: ST_TO_ADDR
// end ;
50205: LD_VAR 0 3
50209: RET
// export function GetBehemoths ( side ) ; begin
50210: LD_INT 0
50212: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
50213: LD_ADDR_VAR 0 2
50217: PUSH
50218: LD_INT 22
50220: PUSH
50221: LD_VAR 0 1
50225: PUSH
50226: EMPTY
50227: LIST
50228: LIST
50229: PUSH
50230: LD_INT 31
50232: PUSH
50233: LD_INT 25
50235: PUSH
50236: EMPTY
50237: LIST
50238: LIST
50239: PUSH
50240: EMPTY
50241: LIST
50242: LIST
50243: PPUSH
50244: CALL_OW 69
50248: ST_TO_ADDR
// end ;
50249: LD_VAR 0 2
50253: RET
// export function Shuffle ( array ) ; var i , index ; begin
50254: LD_INT 0
50256: PPUSH
50257: PPUSH
50258: PPUSH
// result := [ ] ;
50259: LD_ADDR_VAR 0 2
50263: PUSH
50264: EMPTY
50265: ST_TO_ADDR
// if not array then
50266: LD_VAR 0 1
50270: NOT
50271: IFFALSE 50275
// exit ;
50273: GO 50374
// Randomize ;
50275: CALL_OW 10
// for i = array downto 1 do
50279: LD_ADDR_VAR 0 3
50283: PUSH
50284: DOUBLE
50285: LD_VAR 0 1
50289: INC
50290: ST_TO_ADDR
50291: LD_INT 1
50293: PUSH
50294: FOR_DOWNTO
50295: IFFALSE 50372
// begin index := rand ( 1 , array ) ;
50297: LD_ADDR_VAR 0 4
50301: PUSH
50302: LD_INT 1
50304: PPUSH
50305: LD_VAR 0 1
50309: PPUSH
50310: CALL_OW 12
50314: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
50315: LD_ADDR_VAR 0 2
50319: PUSH
50320: LD_VAR 0 2
50324: PPUSH
50325: LD_VAR 0 2
50329: PUSH
50330: LD_INT 1
50332: PLUS
50333: PPUSH
50334: LD_VAR 0 1
50338: PUSH
50339: LD_VAR 0 4
50343: ARRAY
50344: PPUSH
50345: CALL_OW 2
50349: ST_TO_ADDR
// array := Delete ( array , index ) ;
50350: LD_ADDR_VAR 0 1
50354: PUSH
50355: LD_VAR 0 1
50359: PPUSH
50360: LD_VAR 0 4
50364: PPUSH
50365: CALL_OW 3
50369: ST_TO_ADDR
// end ;
50370: GO 50294
50372: POP
50373: POP
// end ;
50374: LD_VAR 0 2
50378: RET
// export function GetBaseMaterials ( base ) ; begin
50379: LD_INT 0
50381: PPUSH
// result := [ 0 , 0 , 0 ] ;
50382: LD_ADDR_VAR 0 2
50386: PUSH
50387: LD_INT 0
50389: PUSH
50390: LD_INT 0
50392: PUSH
50393: LD_INT 0
50395: PUSH
50396: EMPTY
50397: LIST
50398: LIST
50399: LIST
50400: ST_TO_ADDR
// if not base then
50401: LD_VAR 0 1
50405: NOT
50406: IFFALSE 50410
// exit ;
50408: GO 50459
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
50410: LD_ADDR_VAR 0 2
50414: PUSH
50415: LD_VAR 0 1
50419: PPUSH
50420: LD_INT 1
50422: PPUSH
50423: CALL_OW 275
50427: PUSH
50428: LD_VAR 0 1
50432: PPUSH
50433: LD_INT 2
50435: PPUSH
50436: CALL_OW 275
50440: PUSH
50441: LD_VAR 0 1
50445: PPUSH
50446: LD_INT 3
50448: PPUSH
50449: CALL_OW 275
50453: PUSH
50454: EMPTY
50455: LIST
50456: LIST
50457: LIST
50458: ST_TO_ADDR
// end ; end_of_file
50459: LD_VAR 0 2
50463: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
50464: LD_INT 0
50466: PPUSH
50467: PPUSH
// skirmish := false ;
50468: LD_ADDR_EXP 57
50472: PUSH
50473: LD_INT 0
50475: ST_TO_ADDR
// debug_mc := false ;
50476: LD_ADDR_EXP 58
50480: PUSH
50481: LD_INT 0
50483: ST_TO_ADDR
// mc_bases := [ ] ;
50484: LD_ADDR_EXP 59
50488: PUSH
50489: EMPTY
50490: ST_TO_ADDR
// mc_sides := [ ] ;
50491: LD_ADDR_EXP 85
50495: PUSH
50496: EMPTY
50497: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
50498: LD_ADDR_EXP 60
50502: PUSH
50503: EMPTY
50504: ST_TO_ADDR
// mc_building_repairs := [ ] ;
50505: LD_ADDR_EXP 61
50509: PUSH
50510: EMPTY
50511: ST_TO_ADDR
// mc_need_heal := [ ] ;
50512: LD_ADDR_EXP 62
50516: PUSH
50517: EMPTY
50518: ST_TO_ADDR
// mc_healers := [ ] ;
50519: LD_ADDR_EXP 63
50523: PUSH
50524: EMPTY
50525: ST_TO_ADDR
// mc_build_list := [ ] ;
50526: LD_ADDR_EXP 64
50530: PUSH
50531: EMPTY
50532: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
50533: LD_ADDR_EXP 91
50537: PUSH
50538: EMPTY
50539: ST_TO_ADDR
// mc_builders := [ ] ;
50540: LD_ADDR_EXP 65
50544: PUSH
50545: EMPTY
50546: ST_TO_ADDR
// mc_construct_list := [ ] ;
50547: LD_ADDR_EXP 66
50551: PUSH
50552: EMPTY
50553: ST_TO_ADDR
// mc_turret_list := [ ] ;
50554: LD_ADDR_EXP 67
50558: PUSH
50559: EMPTY
50560: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
50561: LD_ADDR_EXP 68
50565: PUSH
50566: EMPTY
50567: ST_TO_ADDR
// mc_miners := [ ] ;
50568: LD_ADDR_EXP 73
50572: PUSH
50573: EMPTY
50574: ST_TO_ADDR
// mc_mines := [ ] ;
50575: LD_ADDR_EXP 72
50579: PUSH
50580: EMPTY
50581: ST_TO_ADDR
// mc_minefields := [ ] ;
50582: LD_ADDR_EXP 74
50586: PUSH
50587: EMPTY
50588: ST_TO_ADDR
// mc_crates := [ ] ;
50589: LD_ADDR_EXP 75
50593: PUSH
50594: EMPTY
50595: ST_TO_ADDR
// mc_crates_collector := [ ] ;
50596: LD_ADDR_EXP 76
50600: PUSH
50601: EMPTY
50602: ST_TO_ADDR
// mc_crates_area := [ ] ;
50603: LD_ADDR_EXP 77
50607: PUSH
50608: EMPTY
50609: ST_TO_ADDR
// mc_vehicles := [ ] ;
50610: LD_ADDR_EXP 78
50614: PUSH
50615: EMPTY
50616: ST_TO_ADDR
// mc_attack := [ ] ;
50617: LD_ADDR_EXP 79
50621: PUSH
50622: EMPTY
50623: ST_TO_ADDR
// mc_produce := [ ] ;
50624: LD_ADDR_EXP 80
50628: PUSH
50629: EMPTY
50630: ST_TO_ADDR
// mc_defender := [ ] ;
50631: LD_ADDR_EXP 81
50635: PUSH
50636: EMPTY
50637: ST_TO_ADDR
// mc_parking := [ ] ;
50638: LD_ADDR_EXP 83
50642: PUSH
50643: EMPTY
50644: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
50645: LD_ADDR_EXP 69
50649: PUSH
50650: EMPTY
50651: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
50652: LD_ADDR_EXP 71
50656: PUSH
50657: EMPTY
50658: ST_TO_ADDR
// mc_scan := [ ] ;
50659: LD_ADDR_EXP 82
50663: PUSH
50664: EMPTY
50665: ST_TO_ADDR
// mc_scan_area := [ ] ;
50666: LD_ADDR_EXP 84
50670: PUSH
50671: EMPTY
50672: ST_TO_ADDR
// mc_tech := [ ] ;
50673: LD_ADDR_EXP 86
50677: PUSH
50678: EMPTY
50679: ST_TO_ADDR
// mc_class := [ ] ;
50680: LD_ADDR_EXP 100
50684: PUSH
50685: EMPTY
50686: ST_TO_ADDR
// mc_class_case_use := [ ] ;
50687: LD_ADDR_EXP 101
50691: PUSH
50692: EMPTY
50693: ST_TO_ADDR
// end ;
50694: LD_VAR 0 1
50698: RET
// export function MC_Kill ( base ) ; begin
50699: LD_INT 0
50701: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
50702: LD_ADDR_EXP 59
50706: PUSH
50707: LD_EXP 59
50711: PPUSH
50712: LD_VAR 0 1
50716: PPUSH
50717: EMPTY
50718: PPUSH
50719: CALL_OW 1
50723: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
50724: LD_ADDR_EXP 60
50728: PUSH
50729: LD_EXP 60
50733: PPUSH
50734: LD_VAR 0 1
50738: PPUSH
50739: EMPTY
50740: PPUSH
50741: CALL_OW 1
50745: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
50746: LD_ADDR_EXP 61
50750: PUSH
50751: LD_EXP 61
50755: PPUSH
50756: LD_VAR 0 1
50760: PPUSH
50761: EMPTY
50762: PPUSH
50763: CALL_OW 1
50767: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
50768: LD_ADDR_EXP 62
50772: PUSH
50773: LD_EXP 62
50777: PPUSH
50778: LD_VAR 0 1
50782: PPUSH
50783: EMPTY
50784: PPUSH
50785: CALL_OW 1
50789: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
50790: LD_ADDR_EXP 63
50794: PUSH
50795: LD_EXP 63
50799: PPUSH
50800: LD_VAR 0 1
50804: PPUSH
50805: EMPTY
50806: PPUSH
50807: CALL_OW 1
50811: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
50812: LD_ADDR_EXP 64
50816: PUSH
50817: LD_EXP 64
50821: PPUSH
50822: LD_VAR 0 1
50826: PPUSH
50827: EMPTY
50828: PPUSH
50829: CALL_OW 1
50833: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
50834: LD_ADDR_EXP 65
50838: PUSH
50839: LD_EXP 65
50843: PPUSH
50844: LD_VAR 0 1
50848: PPUSH
50849: EMPTY
50850: PPUSH
50851: CALL_OW 1
50855: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
50856: LD_ADDR_EXP 66
50860: PUSH
50861: LD_EXP 66
50865: PPUSH
50866: LD_VAR 0 1
50870: PPUSH
50871: EMPTY
50872: PPUSH
50873: CALL_OW 1
50877: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
50878: LD_ADDR_EXP 67
50882: PUSH
50883: LD_EXP 67
50887: PPUSH
50888: LD_VAR 0 1
50892: PPUSH
50893: EMPTY
50894: PPUSH
50895: CALL_OW 1
50899: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
50900: LD_ADDR_EXP 68
50904: PUSH
50905: LD_EXP 68
50909: PPUSH
50910: LD_VAR 0 1
50914: PPUSH
50915: EMPTY
50916: PPUSH
50917: CALL_OW 1
50921: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
50922: LD_ADDR_EXP 69
50926: PUSH
50927: LD_EXP 69
50931: PPUSH
50932: LD_VAR 0 1
50936: PPUSH
50937: EMPTY
50938: PPUSH
50939: CALL_OW 1
50943: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
50944: LD_ADDR_EXP 70
50948: PUSH
50949: LD_EXP 70
50953: PPUSH
50954: LD_VAR 0 1
50958: PPUSH
50959: LD_INT 0
50961: PPUSH
50962: CALL_OW 1
50966: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
50967: LD_ADDR_EXP 71
50971: PUSH
50972: LD_EXP 71
50976: PPUSH
50977: LD_VAR 0 1
50981: PPUSH
50982: EMPTY
50983: PPUSH
50984: CALL_OW 1
50988: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
50989: LD_ADDR_EXP 72
50993: PUSH
50994: LD_EXP 72
50998: PPUSH
50999: LD_VAR 0 1
51003: PPUSH
51004: EMPTY
51005: PPUSH
51006: CALL_OW 1
51010: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51011: LD_ADDR_EXP 73
51015: PUSH
51016: LD_EXP 73
51020: PPUSH
51021: LD_VAR 0 1
51025: PPUSH
51026: EMPTY
51027: PPUSH
51028: CALL_OW 1
51032: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51033: LD_ADDR_EXP 74
51037: PUSH
51038: LD_EXP 74
51042: PPUSH
51043: LD_VAR 0 1
51047: PPUSH
51048: EMPTY
51049: PPUSH
51050: CALL_OW 1
51054: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51055: LD_ADDR_EXP 75
51059: PUSH
51060: LD_EXP 75
51064: PPUSH
51065: LD_VAR 0 1
51069: PPUSH
51070: EMPTY
51071: PPUSH
51072: CALL_OW 1
51076: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51077: LD_ADDR_EXP 76
51081: PUSH
51082: LD_EXP 76
51086: PPUSH
51087: LD_VAR 0 1
51091: PPUSH
51092: EMPTY
51093: PPUSH
51094: CALL_OW 1
51098: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51099: LD_ADDR_EXP 77
51103: PUSH
51104: LD_EXP 77
51108: PPUSH
51109: LD_VAR 0 1
51113: PPUSH
51114: EMPTY
51115: PPUSH
51116: CALL_OW 1
51120: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51121: LD_ADDR_EXP 78
51125: PUSH
51126: LD_EXP 78
51130: PPUSH
51131: LD_VAR 0 1
51135: PPUSH
51136: EMPTY
51137: PPUSH
51138: CALL_OW 1
51142: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51143: LD_ADDR_EXP 79
51147: PUSH
51148: LD_EXP 79
51152: PPUSH
51153: LD_VAR 0 1
51157: PPUSH
51158: EMPTY
51159: PPUSH
51160: CALL_OW 1
51164: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51165: LD_ADDR_EXP 80
51169: PUSH
51170: LD_EXP 80
51174: PPUSH
51175: LD_VAR 0 1
51179: PPUSH
51180: EMPTY
51181: PPUSH
51182: CALL_OW 1
51186: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51187: LD_ADDR_EXP 81
51191: PUSH
51192: LD_EXP 81
51196: PPUSH
51197: LD_VAR 0 1
51201: PPUSH
51202: EMPTY
51203: PPUSH
51204: CALL_OW 1
51208: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51209: LD_ADDR_EXP 82
51213: PUSH
51214: LD_EXP 82
51218: PPUSH
51219: LD_VAR 0 1
51223: PPUSH
51224: EMPTY
51225: PPUSH
51226: CALL_OW 1
51230: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51231: LD_ADDR_EXP 83
51235: PUSH
51236: LD_EXP 83
51240: PPUSH
51241: LD_VAR 0 1
51245: PPUSH
51246: EMPTY
51247: PPUSH
51248: CALL_OW 1
51252: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51253: LD_ADDR_EXP 84
51257: PUSH
51258: LD_EXP 84
51262: PPUSH
51263: LD_VAR 0 1
51267: PPUSH
51268: EMPTY
51269: PPUSH
51270: CALL_OW 1
51274: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51275: LD_ADDR_EXP 86
51279: PUSH
51280: LD_EXP 86
51284: PPUSH
51285: LD_VAR 0 1
51289: PPUSH
51290: EMPTY
51291: PPUSH
51292: CALL_OW 1
51296: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51297: LD_ADDR_EXP 88
51301: PUSH
51302: LD_EXP 88
51306: PPUSH
51307: LD_VAR 0 1
51311: PPUSH
51312: EMPTY
51313: PPUSH
51314: CALL_OW 1
51318: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51319: LD_ADDR_EXP 89
51323: PUSH
51324: LD_EXP 89
51328: PPUSH
51329: LD_VAR 0 1
51333: PPUSH
51334: EMPTY
51335: PPUSH
51336: CALL_OW 1
51340: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51341: LD_ADDR_EXP 90
51345: PUSH
51346: LD_EXP 90
51350: PPUSH
51351: LD_VAR 0 1
51355: PPUSH
51356: EMPTY
51357: PPUSH
51358: CALL_OW 1
51362: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51363: LD_ADDR_EXP 91
51367: PUSH
51368: LD_EXP 91
51372: PPUSH
51373: LD_VAR 0 1
51377: PPUSH
51378: EMPTY
51379: PPUSH
51380: CALL_OW 1
51384: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51385: LD_ADDR_EXP 92
51389: PUSH
51390: LD_EXP 92
51394: PPUSH
51395: LD_VAR 0 1
51399: PPUSH
51400: EMPTY
51401: PPUSH
51402: CALL_OW 1
51406: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
51407: LD_ADDR_EXP 93
51411: PUSH
51412: LD_EXP 93
51416: PPUSH
51417: LD_VAR 0 1
51421: PPUSH
51422: EMPTY
51423: PPUSH
51424: CALL_OW 1
51428: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
51429: LD_ADDR_EXP 94
51433: PUSH
51434: LD_EXP 94
51438: PPUSH
51439: LD_VAR 0 1
51443: PPUSH
51444: EMPTY
51445: PPUSH
51446: CALL_OW 1
51450: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
51451: LD_ADDR_EXP 95
51455: PUSH
51456: LD_EXP 95
51460: PPUSH
51461: LD_VAR 0 1
51465: PPUSH
51466: EMPTY
51467: PPUSH
51468: CALL_OW 1
51472: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
51473: LD_ADDR_EXP 96
51477: PUSH
51478: LD_EXP 96
51482: PPUSH
51483: LD_VAR 0 1
51487: PPUSH
51488: EMPTY
51489: PPUSH
51490: CALL_OW 1
51494: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
51495: LD_ADDR_EXP 97
51499: PUSH
51500: LD_EXP 97
51504: PPUSH
51505: LD_VAR 0 1
51509: PPUSH
51510: EMPTY
51511: PPUSH
51512: CALL_OW 1
51516: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
51517: LD_ADDR_EXP 98
51521: PUSH
51522: LD_EXP 98
51526: PPUSH
51527: LD_VAR 0 1
51531: PPUSH
51532: EMPTY
51533: PPUSH
51534: CALL_OW 1
51538: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
51539: LD_ADDR_EXP 99
51543: PUSH
51544: LD_EXP 99
51548: PPUSH
51549: LD_VAR 0 1
51553: PPUSH
51554: EMPTY
51555: PPUSH
51556: CALL_OW 1
51560: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
51561: LD_ADDR_EXP 100
51565: PUSH
51566: LD_EXP 100
51570: PPUSH
51571: LD_VAR 0 1
51575: PPUSH
51576: EMPTY
51577: PPUSH
51578: CALL_OW 1
51582: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
51583: LD_ADDR_EXP 101
51587: PUSH
51588: LD_EXP 101
51592: PPUSH
51593: LD_VAR 0 1
51597: PPUSH
51598: LD_INT 0
51600: PPUSH
51601: CALL_OW 1
51605: ST_TO_ADDR
// end ;
51606: LD_VAR 0 2
51610: RET
// export function MC_Add ( side , units ) ; var base ; begin
51611: LD_INT 0
51613: PPUSH
51614: PPUSH
// base := mc_bases + 1 ;
51615: LD_ADDR_VAR 0 4
51619: PUSH
51620: LD_EXP 59
51624: PUSH
51625: LD_INT 1
51627: PLUS
51628: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
51629: LD_ADDR_EXP 85
51633: PUSH
51634: LD_EXP 85
51638: PPUSH
51639: LD_VAR 0 4
51643: PPUSH
51644: LD_VAR 0 1
51648: PPUSH
51649: CALL_OW 1
51653: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
51654: LD_ADDR_EXP 59
51658: PUSH
51659: LD_EXP 59
51663: PPUSH
51664: LD_VAR 0 4
51668: PPUSH
51669: LD_VAR 0 2
51673: PPUSH
51674: CALL_OW 1
51678: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51679: LD_ADDR_EXP 60
51683: PUSH
51684: LD_EXP 60
51688: PPUSH
51689: LD_VAR 0 4
51693: PPUSH
51694: EMPTY
51695: PPUSH
51696: CALL_OW 1
51700: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51701: LD_ADDR_EXP 61
51705: PUSH
51706: LD_EXP 61
51710: PPUSH
51711: LD_VAR 0 4
51715: PPUSH
51716: EMPTY
51717: PPUSH
51718: CALL_OW 1
51722: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51723: LD_ADDR_EXP 62
51727: PUSH
51728: LD_EXP 62
51732: PPUSH
51733: LD_VAR 0 4
51737: PPUSH
51738: EMPTY
51739: PPUSH
51740: CALL_OW 1
51744: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51745: LD_ADDR_EXP 63
51749: PUSH
51750: LD_EXP 63
51754: PPUSH
51755: LD_VAR 0 4
51759: PPUSH
51760: EMPTY
51761: PPUSH
51762: CALL_OW 1
51766: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51767: LD_ADDR_EXP 64
51771: PUSH
51772: LD_EXP 64
51776: PPUSH
51777: LD_VAR 0 4
51781: PPUSH
51782: EMPTY
51783: PPUSH
51784: CALL_OW 1
51788: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51789: LD_ADDR_EXP 65
51793: PUSH
51794: LD_EXP 65
51798: PPUSH
51799: LD_VAR 0 4
51803: PPUSH
51804: EMPTY
51805: PPUSH
51806: CALL_OW 1
51810: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51811: LD_ADDR_EXP 66
51815: PUSH
51816: LD_EXP 66
51820: PPUSH
51821: LD_VAR 0 4
51825: PPUSH
51826: EMPTY
51827: PPUSH
51828: CALL_OW 1
51832: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51833: LD_ADDR_EXP 67
51837: PUSH
51838: LD_EXP 67
51842: PPUSH
51843: LD_VAR 0 4
51847: PPUSH
51848: EMPTY
51849: PPUSH
51850: CALL_OW 1
51854: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51855: LD_ADDR_EXP 68
51859: PUSH
51860: LD_EXP 68
51864: PPUSH
51865: LD_VAR 0 4
51869: PPUSH
51870: EMPTY
51871: PPUSH
51872: CALL_OW 1
51876: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51877: LD_ADDR_EXP 69
51881: PUSH
51882: LD_EXP 69
51886: PPUSH
51887: LD_VAR 0 4
51891: PPUSH
51892: EMPTY
51893: PPUSH
51894: CALL_OW 1
51898: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51899: LD_ADDR_EXP 70
51903: PUSH
51904: LD_EXP 70
51908: PPUSH
51909: LD_VAR 0 4
51913: PPUSH
51914: LD_INT 0
51916: PPUSH
51917: CALL_OW 1
51921: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51922: LD_ADDR_EXP 71
51926: PUSH
51927: LD_EXP 71
51931: PPUSH
51932: LD_VAR 0 4
51936: PPUSH
51937: EMPTY
51938: PPUSH
51939: CALL_OW 1
51943: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51944: LD_ADDR_EXP 72
51948: PUSH
51949: LD_EXP 72
51953: PPUSH
51954: LD_VAR 0 4
51958: PPUSH
51959: EMPTY
51960: PPUSH
51961: CALL_OW 1
51965: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51966: LD_ADDR_EXP 73
51970: PUSH
51971: LD_EXP 73
51975: PPUSH
51976: LD_VAR 0 4
51980: PPUSH
51981: EMPTY
51982: PPUSH
51983: CALL_OW 1
51987: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51988: LD_ADDR_EXP 74
51992: PUSH
51993: LD_EXP 74
51997: PPUSH
51998: LD_VAR 0 4
52002: PPUSH
52003: EMPTY
52004: PPUSH
52005: CALL_OW 1
52009: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52010: LD_ADDR_EXP 75
52014: PUSH
52015: LD_EXP 75
52019: PPUSH
52020: LD_VAR 0 4
52024: PPUSH
52025: EMPTY
52026: PPUSH
52027: CALL_OW 1
52031: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52032: LD_ADDR_EXP 76
52036: PUSH
52037: LD_EXP 76
52041: PPUSH
52042: LD_VAR 0 4
52046: PPUSH
52047: EMPTY
52048: PPUSH
52049: CALL_OW 1
52053: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52054: LD_ADDR_EXP 77
52058: PUSH
52059: LD_EXP 77
52063: PPUSH
52064: LD_VAR 0 4
52068: PPUSH
52069: EMPTY
52070: PPUSH
52071: CALL_OW 1
52075: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52076: LD_ADDR_EXP 78
52080: PUSH
52081: LD_EXP 78
52085: PPUSH
52086: LD_VAR 0 4
52090: PPUSH
52091: EMPTY
52092: PPUSH
52093: CALL_OW 1
52097: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52098: LD_ADDR_EXP 79
52102: PUSH
52103: LD_EXP 79
52107: PPUSH
52108: LD_VAR 0 4
52112: PPUSH
52113: EMPTY
52114: PPUSH
52115: CALL_OW 1
52119: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52120: LD_ADDR_EXP 80
52124: PUSH
52125: LD_EXP 80
52129: PPUSH
52130: LD_VAR 0 4
52134: PPUSH
52135: EMPTY
52136: PPUSH
52137: CALL_OW 1
52141: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52142: LD_ADDR_EXP 81
52146: PUSH
52147: LD_EXP 81
52151: PPUSH
52152: LD_VAR 0 4
52156: PPUSH
52157: EMPTY
52158: PPUSH
52159: CALL_OW 1
52163: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52164: LD_ADDR_EXP 82
52168: PUSH
52169: LD_EXP 82
52173: PPUSH
52174: LD_VAR 0 4
52178: PPUSH
52179: EMPTY
52180: PPUSH
52181: CALL_OW 1
52185: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52186: LD_ADDR_EXP 83
52190: PUSH
52191: LD_EXP 83
52195: PPUSH
52196: LD_VAR 0 4
52200: PPUSH
52201: EMPTY
52202: PPUSH
52203: CALL_OW 1
52207: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52208: LD_ADDR_EXP 84
52212: PUSH
52213: LD_EXP 84
52217: PPUSH
52218: LD_VAR 0 4
52222: PPUSH
52223: EMPTY
52224: PPUSH
52225: CALL_OW 1
52229: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52230: LD_ADDR_EXP 86
52234: PUSH
52235: LD_EXP 86
52239: PPUSH
52240: LD_VAR 0 4
52244: PPUSH
52245: EMPTY
52246: PPUSH
52247: CALL_OW 1
52251: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52252: LD_ADDR_EXP 88
52256: PUSH
52257: LD_EXP 88
52261: PPUSH
52262: LD_VAR 0 4
52266: PPUSH
52267: EMPTY
52268: PPUSH
52269: CALL_OW 1
52273: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52274: LD_ADDR_EXP 89
52278: PUSH
52279: LD_EXP 89
52283: PPUSH
52284: LD_VAR 0 4
52288: PPUSH
52289: EMPTY
52290: PPUSH
52291: CALL_OW 1
52295: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52296: LD_ADDR_EXP 90
52300: PUSH
52301: LD_EXP 90
52305: PPUSH
52306: LD_VAR 0 4
52310: PPUSH
52311: EMPTY
52312: PPUSH
52313: CALL_OW 1
52317: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52318: LD_ADDR_EXP 91
52322: PUSH
52323: LD_EXP 91
52327: PPUSH
52328: LD_VAR 0 4
52332: PPUSH
52333: EMPTY
52334: PPUSH
52335: CALL_OW 1
52339: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52340: LD_ADDR_EXP 92
52344: PUSH
52345: LD_EXP 92
52349: PPUSH
52350: LD_VAR 0 4
52354: PPUSH
52355: EMPTY
52356: PPUSH
52357: CALL_OW 1
52361: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52362: LD_ADDR_EXP 93
52366: PUSH
52367: LD_EXP 93
52371: PPUSH
52372: LD_VAR 0 4
52376: PPUSH
52377: EMPTY
52378: PPUSH
52379: CALL_OW 1
52383: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52384: LD_ADDR_EXP 94
52388: PUSH
52389: LD_EXP 94
52393: PPUSH
52394: LD_VAR 0 4
52398: PPUSH
52399: EMPTY
52400: PPUSH
52401: CALL_OW 1
52405: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52406: LD_ADDR_EXP 95
52410: PUSH
52411: LD_EXP 95
52415: PPUSH
52416: LD_VAR 0 4
52420: PPUSH
52421: EMPTY
52422: PPUSH
52423: CALL_OW 1
52427: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52428: LD_ADDR_EXP 96
52432: PUSH
52433: LD_EXP 96
52437: PPUSH
52438: LD_VAR 0 4
52442: PPUSH
52443: EMPTY
52444: PPUSH
52445: CALL_OW 1
52449: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52450: LD_ADDR_EXP 97
52454: PUSH
52455: LD_EXP 97
52459: PPUSH
52460: LD_VAR 0 4
52464: PPUSH
52465: EMPTY
52466: PPUSH
52467: CALL_OW 1
52471: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52472: LD_ADDR_EXP 98
52476: PUSH
52477: LD_EXP 98
52481: PPUSH
52482: LD_VAR 0 4
52486: PPUSH
52487: EMPTY
52488: PPUSH
52489: CALL_OW 1
52493: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52494: LD_ADDR_EXP 99
52498: PUSH
52499: LD_EXP 99
52503: PPUSH
52504: LD_VAR 0 4
52508: PPUSH
52509: EMPTY
52510: PPUSH
52511: CALL_OW 1
52515: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52516: LD_ADDR_EXP 100
52520: PUSH
52521: LD_EXP 100
52525: PPUSH
52526: LD_VAR 0 4
52530: PPUSH
52531: EMPTY
52532: PPUSH
52533: CALL_OW 1
52537: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52538: LD_ADDR_EXP 101
52542: PUSH
52543: LD_EXP 101
52547: PPUSH
52548: LD_VAR 0 4
52552: PPUSH
52553: LD_INT 0
52555: PPUSH
52556: CALL_OW 1
52560: ST_TO_ADDR
// result := base ;
52561: LD_ADDR_VAR 0 3
52565: PUSH
52566: LD_VAR 0 4
52570: ST_TO_ADDR
// end ;
52571: LD_VAR 0 3
52575: RET
// export function MC_Start ( ) ; var i ; begin
52576: LD_INT 0
52578: PPUSH
52579: PPUSH
// for i = 1 to mc_bases do
52580: LD_ADDR_VAR 0 2
52584: PUSH
52585: DOUBLE
52586: LD_INT 1
52588: DEC
52589: ST_TO_ADDR
52590: LD_EXP 59
52594: PUSH
52595: FOR_TO
52596: IFFALSE 53673
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
52598: LD_ADDR_EXP 59
52602: PUSH
52603: LD_EXP 59
52607: PPUSH
52608: LD_VAR 0 2
52612: PPUSH
52613: LD_EXP 59
52617: PUSH
52618: LD_VAR 0 2
52622: ARRAY
52623: PUSH
52624: LD_INT 0
52626: DIFF
52627: PPUSH
52628: CALL_OW 1
52632: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
52633: LD_ADDR_EXP 60
52637: PUSH
52638: LD_EXP 60
52642: PPUSH
52643: LD_VAR 0 2
52647: PPUSH
52648: EMPTY
52649: PPUSH
52650: CALL_OW 1
52654: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
52655: LD_ADDR_EXP 61
52659: PUSH
52660: LD_EXP 61
52664: PPUSH
52665: LD_VAR 0 2
52669: PPUSH
52670: EMPTY
52671: PPUSH
52672: CALL_OW 1
52676: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
52677: LD_ADDR_EXP 62
52681: PUSH
52682: LD_EXP 62
52686: PPUSH
52687: LD_VAR 0 2
52691: PPUSH
52692: EMPTY
52693: PPUSH
52694: CALL_OW 1
52698: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
52699: LD_ADDR_EXP 63
52703: PUSH
52704: LD_EXP 63
52708: PPUSH
52709: LD_VAR 0 2
52713: PPUSH
52714: EMPTY
52715: PUSH
52716: EMPTY
52717: PUSH
52718: EMPTY
52719: LIST
52720: LIST
52721: PPUSH
52722: CALL_OW 1
52726: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
52727: LD_ADDR_EXP 64
52731: PUSH
52732: LD_EXP 64
52736: PPUSH
52737: LD_VAR 0 2
52741: PPUSH
52742: EMPTY
52743: PPUSH
52744: CALL_OW 1
52748: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
52749: LD_ADDR_EXP 91
52753: PUSH
52754: LD_EXP 91
52758: PPUSH
52759: LD_VAR 0 2
52763: PPUSH
52764: EMPTY
52765: PPUSH
52766: CALL_OW 1
52770: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
52771: LD_ADDR_EXP 65
52775: PUSH
52776: LD_EXP 65
52780: PPUSH
52781: LD_VAR 0 2
52785: PPUSH
52786: EMPTY
52787: PPUSH
52788: CALL_OW 1
52792: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
52793: LD_ADDR_EXP 66
52797: PUSH
52798: LD_EXP 66
52802: PPUSH
52803: LD_VAR 0 2
52807: PPUSH
52808: EMPTY
52809: PPUSH
52810: CALL_OW 1
52814: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
52815: LD_ADDR_EXP 67
52819: PUSH
52820: LD_EXP 67
52824: PPUSH
52825: LD_VAR 0 2
52829: PPUSH
52830: LD_EXP 59
52834: PUSH
52835: LD_VAR 0 2
52839: ARRAY
52840: PPUSH
52841: LD_INT 2
52843: PUSH
52844: LD_INT 30
52846: PUSH
52847: LD_INT 32
52849: PUSH
52850: EMPTY
52851: LIST
52852: LIST
52853: PUSH
52854: LD_INT 30
52856: PUSH
52857: LD_INT 33
52859: PUSH
52860: EMPTY
52861: LIST
52862: LIST
52863: PUSH
52864: EMPTY
52865: LIST
52866: LIST
52867: LIST
52868: PPUSH
52869: CALL_OW 72
52873: PPUSH
52874: CALL_OW 1
52878: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
52879: LD_ADDR_EXP 68
52883: PUSH
52884: LD_EXP 68
52888: PPUSH
52889: LD_VAR 0 2
52893: PPUSH
52894: LD_EXP 59
52898: PUSH
52899: LD_VAR 0 2
52903: ARRAY
52904: PPUSH
52905: LD_INT 2
52907: PUSH
52908: LD_INT 30
52910: PUSH
52911: LD_INT 32
52913: PUSH
52914: EMPTY
52915: LIST
52916: LIST
52917: PUSH
52918: LD_INT 30
52920: PUSH
52921: LD_INT 31
52923: PUSH
52924: EMPTY
52925: LIST
52926: LIST
52927: PUSH
52928: EMPTY
52929: LIST
52930: LIST
52931: LIST
52932: PUSH
52933: LD_INT 58
52935: PUSH
52936: EMPTY
52937: LIST
52938: PUSH
52939: EMPTY
52940: LIST
52941: LIST
52942: PPUSH
52943: CALL_OW 72
52947: PPUSH
52948: CALL_OW 1
52952: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
52953: LD_ADDR_EXP 69
52957: PUSH
52958: LD_EXP 69
52962: PPUSH
52963: LD_VAR 0 2
52967: PPUSH
52968: EMPTY
52969: PPUSH
52970: CALL_OW 1
52974: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
52975: LD_ADDR_EXP 73
52979: PUSH
52980: LD_EXP 73
52984: PPUSH
52985: LD_VAR 0 2
52989: PPUSH
52990: EMPTY
52991: PPUSH
52992: CALL_OW 1
52996: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
52997: LD_ADDR_EXP 72
53001: PUSH
53002: LD_EXP 72
53006: PPUSH
53007: LD_VAR 0 2
53011: PPUSH
53012: EMPTY
53013: PPUSH
53014: CALL_OW 1
53018: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53019: LD_ADDR_EXP 74
53023: PUSH
53024: LD_EXP 74
53028: PPUSH
53029: LD_VAR 0 2
53033: PPUSH
53034: EMPTY
53035: PPUSH
53036: CALL_OW 1
53040: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53041: LD_ADDR_EXP 75
53045: PUSH
53046: LD_EXP 75
53050: PPUSH
53051: LD_VAR 0 2
53055: PPUSH
53056: EMPTY
53057: PPUSH
53058: CALL_OW 1
53062: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53063: LD_ADDR_EXP 76
53067: PUSH
53068: LD_EXP 76
53072: PPUSH
53073: LD_VAR 0 2
53077: PPUSH
53078: EMPTY
53079: PPUSH
53080: CALL_OW 1
53084: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53085: LD_ADDR_EXP 77
53089: PUSH
53090: LD_EXP 77
53094: PPUSH
53095: LD_VAR 0 2
53099: PPUSH
53100: EMPTY
53101: PPUSH
53102: CALL_OW 1
53106: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53107: LD_ADDR_EXP 78
53111: PUSH
53112: LD_EXP 78
53116: PPUSH
53117: LD_VAR 0 2
53121: PPUSH
53122: EMPTY
53123: PPUSH
53124: CALL_OW 1
53128: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53129: LD_ADDR_EXP 79
53133: PUSH
53134: LD_EXP 79
53138: PPUSH
53139: LD_VAR 0 2
53143: PPUSH
53144: EMPTY
53145: PPUSH
53146: CALL_OW 1
53150: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
53151: LD_ADDR_EXP 80
53155: PUSH
53156: LD_EXP 80
53160: PPUSH
53161: LD_VAR 0 2
53165: PPUSH
53166: EMPTY
53167: PPUSH
53168: CALL_OW 1
53172: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53173: LD_ADDR_EXP 81
53177: PUSH
53178: LD_EXP 81
53182: PPUSH
53183: LD_VAR 0 2
53187: PPUSH
53188: EMPTY
53189: PPUSH
53190: CALL_OW 1
53194: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
53195: LD_ADDR_EXP 70
53199: PUSH
53200: LD_EXP 70
53204: PPUSH
53205: LD_VAR 0 2
53209: PPUSH
53210: LD_INT 0
53212: PPUSH
53213: CALL_OW 1
53217: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
53218: LD_ADDR_EXP 83
53222: PUSH
53223: LD_EXP 83
53227: PPUSH
53228: LD_VAR 0 2
53232: PPUSH
53233: LD_INT 0
53235: PPUSH
53236: CALL_OW 1
53240: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53241: LD_ADDR_EXP 71
53245: PUSH
53246: LD_EXP 71
53250: PPUSH
53251: LD_VAR 0 2
53255: PPUSH
53256: EMPTY
53257: PPUSH
53258: CALL_OW 1
53262: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
53263: LD_ADDR_EXP 82
53267: PUSH
53268: LD_EXP 82
53272: PPUSH
53273: LD_VAR 0 2
53277: PPUSH
53278: LD_INT 0
53280: PPUSH
53281: CALL_OW 1
53285: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
53286: LD_ADDR_EXP 84
53290: PUSH
53291: LD_EXP 84
53295: PPUSH
53296: LD_VAR 0 2
53300: PPUSH
53301: EMPTY
53302: PPUSH
53303: CALL_OW 1
53307: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
53308: LD_ADDR_EXP 87
53312: PUSH
53313: LD_EXP 87
53317: PPUSH
53318: LD_VAR 0 2
53322: PPUSH
53323: LD_INT 0
53325: PPUSH
53326: CALL_OW 1
53330: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
53331: LD_ADDR_EXP 88
53335: PUSH
53336: LD_EXP 88
53340: PPUSH
53341: LD_VAR 0 2
53345: PPUSH
53346: EMPTY
53347: PPUSH
53348: CALL_OW 1
53352: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
53353: LD_ADDR_EXP 89
53357: PUSH
53358: LD_EXP 89
53362: PPUSH
53363: LD_VAR 0 2
53367: PPUSH
53368: EMPTY
53369: PPUSH
53370: CALL_OW 1
53374: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53375: LD_ADDR_EXP 90
53379: PUSH
53380: LD_EXP 90
53384: PPUSH
53385: LD_VAR 0 2
53389: PPUSH
53390: EMPTY
53391: PPUSH
53392: CALL_OW 1
53396: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
53397: LD_ADDR_EXP 92
53401: PUSH
53402: LD_EXP 92
53406: PPUSH
53407: LD_VAR 0 2
53411: PPUSH
53412: LD_EXP 59
53416: PUSH
53417: LD_VAR 0 2
53421: ARRAY
53422: PPUSH
53423: LD_INT 2
53425: PUSH
53426: LD_INT 30
53428: PUSH
53429: LD_INT 6
53431: PUSH
53432: EMPTY
53433: LIST
53434: LIST
53435: PUSH
53436: LD_INT 30
53438: PUSH
53439: LD_INT 7
53441: PUSH
53442: EMPTY
53443: LIST
53444: LIST
53445: PUSH
53446: LD_INT 30
53448: PUSH
53449: LD_INT 8
53451: PUSH
53452: EMPTY
53453: LIST
53454: LIST
53455: PUSH
53456: EMPTY
53457: LIST
53458: LIST
53459: LIST
53460: LIST
53461: PPUSH
53462: CALL_OW 72
53466: PPUSH
53467: CALL_OW 1
53471: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
53472: LD_ADDR_EXP 93
53476: PUSH
53477: LD_EXP 93
53481: PPUSH
53482: LD_VAR 0 2
53486: PPUSH
53487: EMPTY
53488: PPUSH
53489: CALL_OW 1
53493: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
53494: LD_ADDR_EXP 94
53498: PUSH
53499: LD_EXP 94
53503: PPUSH
53504: LD_VAR 0 2
53508: PPUSH
53509: EMPTY
53510: PPUSH
53511: CALL_OW 1
53515: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
53516: LD_ADDR_EXP 95
53520: PUSH
53521: LD_EXP 95
53525: PPUSH
53526: LD_VAR 0 2
53530: PPUSH
53531: EMPTY
53532: PPUSH
53533: CALL_OW 1
53537: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
53538: LD_ADDR_EXP 96
53542: PUSH
53543: LD_EXP 96
53547: PPUSH
53548: LD_VAR 0 2
53552: PPUSH
53553: EMPTY
53554: PPUSH
53555: CALL_OW 1
53559: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
53560: LD_ADDR_EXP 97
53564: PUSH
53565: LD_EXP 97
53569: PPUSH
53570: LD_VAR 0 2
53574: PPUSH
53575: EMPTY
53576: PPUSH
53577: CALL_OW 1
53581: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
53582: LD_ADDR_EXP 98
53586: PUSH
53587: LD_EXP 98
53591: PPUSH
53592: LD_VAR 0 2
53596: PPUSH
53597: EMPTY
53598: PPUSH
53599: CALL_OW 1
53603: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
53604: LD_ADDR_EXP 99
53608: PUSH
53609: LD_EXP 99
53613: PPUSH
53614: LD_VAR 0 2
53618: PPUSH
53619: EMPTY
53620: PPUSH
53621: CALL_OW 1
53625: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
53626: LD_ADDR_EXP 100
53630: PUSH
53631: LD_EXP 100
53635: PPUSH
53636: LD_VAR 0 2
53640: PPUSH
53641: EMPTY
53642: PPUSH
53643: CALL_OW 1
53647: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
53648: LD_ADDR_EXP 101
53652: PUSH
53653: LD_EXP 101
53657: PPUSH
53658: LD_VAR 0 2
53662: PPUSH
53663: LD_INT 0
53665: PPUSH
53666: CALL_OW 1
53670: ST_TO_ADDR
// end ;
53671: GO 52595
53673: POP
53674: POP
// MC_InitSides ( ) ;
53675: CALL 53961 0 0
// MC_InitResearch ( ) ;
53679: CALL 53700 0 0
// CustomInitMacro ( ) ;
53683: CALL 181 0 0
// skirmish := true ;
53687: LD_ADDR_EXP 57
53691: PUSH
53692: LD_INT 1
53694: ST_TO_ADDR
// end ;
53695: LD_VAR 0 1
53699: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
53700: LD_INT 0
53702: PPUSH
53703: PPUSH
53704: PPUSH
53705: PPUSH
53706: PPUSH
53707: PPUSH
// if not mc_bases then
53708: LD_EXP 59
53712: NOT
53713: IFFALSE 53717
// exit ;
53715: GO 53956
// for i = 1 to 8 do
53717: LD_ADDR_VAR 0 2
53721: PUSH
53722: DOUBLE
53723: LD_INT 1
53725: DEC
53726: ST_TO_ADDR
53727: LD_INT 8
53729: PUSH
53730: FOR_TO
53731: IFFALSE 53757
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
53733: LD_ADDR_EXP 86
53737: PUSH
53738: LD_EXP 86
53742: PPUSH
53743: LD_VAR 0 2
53747: PPUSH
53748: EMPTY
53749: PPUSH
53750: CALL_OW 1
53754: ST_TO_ADDR
53755: GO 53730
53757: POP
53758: POP
// tmp := [ ] ;
53759: LD_ADDR_VAR 0 5
53763: PUSH
53764: EMPTY
53765: ST_TO_ADDR
// for i = 1 to mc_sides do
53766: LD_ADDR_VAR 0 2
53770: PUSH
53771: DOUBLE
53772: LD_INT 1
53774: DEC
53775: ST_TO_ADDR
53776: LD_EXP 85
53780: PUSH
53781: FOR_TO
53782: IFFALSE 53840
// if not mc_sides [ i ] in tmp then
53784: LD_EXP 85
53788: PUSH
53789: LD_VAR 0 2
53793: ARRAY
53794: PUSH
53795: LD_VAR 0 5
53799: IN
53800: NOT
53801: IFFALSE 53838
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
53803: LD_ADDR_VAR 0 5
53807: PUSH
53808: LD_VAR 0 5
53812: PPUSH
53813: LD_VAR 0 5
53817: PUSH
53818: LD_INT 1
53820: PLUS
53821: PPUSH
53822: LD_EXP 85
53826: PUSH
53827: LD_VAR 0 2
53831: ARRAY
53832: PPUSH
53833: CALL_OW 2
53837: ST_TO_ADDR
53838: GO 53781
53840: POP
53841: POP
// if not tmp then
53842: LD_VAR 0 5
53846: NOT
53847: IFFALSE 53851
// exit ;
53849: GO 53956
// for j in tmp do
53851: LD_ADDR_VAR 0 3
53855: PUSH
53856: LD_VAR 0 5
53860: PUSH
53861: FOR_IN
53862: IFFALSE 53954
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
53864: LD_ADDR_VAR 0 6
53868: PUSH
53869: LD_INT 22
53871: PUSH
53872: LD_VAR 0 3
53876: PUSH
53877: EMPTY
53878: LIST
53879: LIST
53880: PPUSH
53881: CALL_OW 69
53885: ST_TO_ADDR
// if not un then
53886: LD_VAR 0 6
53890: NOT
53891: IFFALSE 53895
// continue ;
53893: GO 53861
// nation := GetNation ( un [ 1 ] ) ;
53895: LD_ADDR_VAR 0 4
53899: PUSH
53900: LD_VAR 0 6
53904: PUSH
53905: LD_INT 1
53907: ARRAY
53908: PPUSH
53909: CALL_OW 248
53913: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
53914: LD_ADDR_EXP 86
53918: PUSH
53919: LD_EXP 86
53923: PPUSH
53924: LD_VAR 0 3
53928: PPUSH
53929: LD_VAR 0 3
53933: PPUSH
53934: LD_VAR 0 4
53938: PPUSH
53939: LD_INT 1
53941: PPUSH
53942: CALL 14355 0 3
53946: PPUSH
53947: CALL_OW 1
53951: ST_TO_ADDR
// end ;
53952: GO 53861
53954: POP
53955: POP
// end ;
53956: LD_VAR 0 1
53960: RET
// export function MC_InitSides ( ) ; var i ; begin
53961: LD_INT 0
53963: PPUSH
53964: PPUSH
// if not mc_bases then
53965: LD_EXP 59
53969: NOT
53970: IFFALSE 53974
// exit ;
53972: GO 54048
// for i = 1 to mc_bases do
53974: LD_ADDR_VAR 0 2
53978: PUSH
53979: DOUBLE
53980: LD_INT 1
53982: DEC
53983: ST_TO_ADDR
53984: LD_EXP 59
53988: PUSH
53989: FOR_TO
53990: IFFALSE 54046
// if mc_bases [ i ] then
53992: LD_EXP 59
53996: PUSH
53997: LD_VAR 0 2
54001: ARRAY
54002: IFFALSE 54044
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54004: LD_ADDR_EXP 85
54008: PUSH
54009: LD_EXP 85
54013: PPUSH
54014: LD_VAR 0 2
54018: PPUSH
54019: LD_EXP 59
54023: PUSH
54024: LD_VAR 0 2
54028: ARRAY
54029: PUSH
54030: LD_INT 1
54032: ARRAY
54033: PPUSH
54034: CALL_OW 255
54038: PPUSH
54039: CALL_OW 1
54043: ST_TO_ADDR
54044: GO 53989
54046: POP
54047: POP
// end ;
54048: LD_VAR 0 1
54052: RET
// every 0 0$01 trigger skirmish do
54053: LD_EXP 57
54057: IFFALSE 54211
54059: GO 54061
54061: DISABLE
// begin enable ;
54062: ENABLE
// MC_CheckBuildings ( ) ;
54063: CALL 58709 0 0
// MC_CheckPeopleLife ( ) ;
54067: CALL 58834 0 0
// RaiseSailEvent ( 100 ) ;
54071: LD_INT 100
54073: PPUSH
54074: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
54078: LD_INT 103
54080: PPUSH
54081: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
54085: LD_INT 104
54087: PPUSH
54088: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
54092: LD_INT 105
54094: PPUSH
54095: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
54099: LD_INT 106
54101: PPUSH
54102: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
54106: LD_INT 107
54108: PPUSH
54109: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
54113: LD_INT 108
54115: PPUSH
54116: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
54120: LD_INT 109
54122: PPUSH
54123: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
54127: LD_INT 110
54129: PPUSH
54130: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
54134: LD_INT 111
54136: PPUSH
54137: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
54141: LD_INT 112
54143: PPUSH
54144: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
54148: LD_INT 113
54150: PPUSH
54151: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
54155: LD_INT 120
54157: PPUSH
54158: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
54162: LD_INT 121
54164: PPUSH
54165: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
54169: LD_INT 122
54171: PPUSH
54172: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
54176: LD_INT 123
54178: PPUSH
54179: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
54183: LD_INT 124
54185: PPUSH
54186: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
54190: LD_INT 125
54192: PPUSH
54193: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
54197: LD_INT 126
54199: PPUSH
54200: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
54204: LD_INT 200
54206: PPUSH
54207: CALL_OW 427
// end ;
54211: END
// on SailEvent ( event ) do begin if event < 100 then
54212: LD_VAR 0 1
54216: PUSH
54217: LD_INT 100
54219: LESS
54220: IFFALSE 54231
// CustomEvent ( event ) ;
54222: LD_VAR 0 1
54226: PPUSH
54227: CALL 13013 0 1
// if event = 100 then
54231: LD_VAR 0 1
54235: PUSH
54236: LD_INT 100
54238: EQUAL
54239: IFFALSE 54245
// MC_ClassManager ( ) ;
54241: CALL 54637 0 0
// if event = 101 then
54245: LD_VAR 0 1
54249: PUSH
54250: LD_INT 101
54252: EQUAL
54253: IFFALSE 54259
// MC_RepairBuildings ( ) ;
54255: CALL 59430 0 0
// if event = 102 then
54259: LD_VAR 0 1
54263: PUSH
54264: LD_INT 102
54266: EQUAL
54267: IFFALSE 54273
// MC_Heal ( ) ;
54269: CALL 60294 0 0
// if event = 103 then
54273: LD_VAR 0 1
54277: PUSH
54278: LD_INT 103
54280: EQUAL
54281: IFFALSE 54287
// MC_Build ( ) ;
54283: CALL 60716 0 0
// if event = 104 then
54287: LD_VAR 0 1
54291: PUSH
54292: LD_INT 104
54294: EQUAL
54295: IFFALSE 54301
// MC_TurretWeapon ( ) ;
54297: CALL 62329 0 0
// if event = 105 then
54301: LD_VAR 0 1
54305: PUSH
54306: LD_INT 105
54308: EQUAL
54309: IFFALSE 54315
// MC_BuildUpgrade ( ) ;
54311: CALL 61880 0 0
// if event = 106 then
54315: LD_VAR 0 1
54319: PUSH
54320: LD_INT 106
54322: EQUAL
54323: IFFALSE 54329
// MC_PlantMines ( ) ;
54325: CALL 62759 0 0
// if event = 107 then
54329: LD_VAR 0 1
54333: PUSH
54334: LD_INT 107
54336: EQUAL
54337: IFFALSE 54343
// MC_CollectCrates ( ) ;
54339: CALL 63557 0 0
// if event = 108 then
54343: LD_VAR 0 1
54347: PUSH
54348: LD_INT 108
54350: EQUAL
54351: IFFALSE 54357
// MC_LinkRemoteControl ( ) ;
54353: CALL 65333 0 0
// if event = 109 then
54357: LD_VAR 0 1
54361: PUSH
54362: LD_INT 109
54364: EQUAL
54365: IFFALSE 54371
// MC_ProduceVehicle ( ) ;
54367: CALL 65514 0 0
// if event = 110 then
54371: LD_VAR 0 1
54375: PUSH
54376: LD_INT 110
54378: EQUAL
54379: IFFALSE 54385
// MC_SendAttack ( ) ;
54381: CALL 65980 0 0
// if event = 111 then
54385: LD_VAR 0 1
54389: PUSH
54390: LD_INT 111
54392: EQUAL
54393: IFFALSE 54399
// MC_Defend ( ) ;
54395: CALL 66088 0 0
// if event = 112 then
54399: LD_VAR 0 1
54403: PUSH
54404: LD_INT 112
54406: EQUAL
54407: IFFALSE 54413
// MC_Research ( ) ;
54409: CALL 66693 0 0
// if event = 113 then
54413: LD_VAR 0 1
54417: PUSH
54418: LD_INT 113
54420: EQUAL
54421: IFFALSE 54427
// MC_MinesTrigger ( ) ;
54423: CALL 67807 0 0
// if event = 120 then
54427: LD_VAR 0 1
54431: PUSH
54432: LD_INT 120
54434: EQUAL
54435: IFFALSE 54441
// MC_RepairVehicle ( ) ;
54437: CALL 67906 0 0
// if event = 121 then
54441: LD_VAR 0 1
54445: PUSH
54446: LD_INT 121
54448: EQUAL
54449: IFFALSE 54455
// MC_TameApe ( ) ;
54451: CALL 68636 0 0
// if event = 122 then
54455: LD_VAR 0 1
54459: PUSH
54460: LD_INT 122
54462: EQUAL
54463: IFFALSE 54469
// MC_ChangeApeClass ( ) ;
54465: CALL 69465 0 0
// if event = 123 then
54469: LD_VAR 0 1
54473: PUSH
54474: LD_INT 123
54476: EQUAL
54477: IFFALSE 54483
// MC_Bazooka ( ) ;
54479: CALL 70115 0 0
// if event = 124 then
54483: LD_VAR 0 1
54487: PUSH
54488: LD_INT 124
54490: EQUAL
54491: IFFALSE 54497
// MC_TeleportExit ( ) ;
54493: CALL 70313 0 0
// if event = 125 then
54497: LD_VAR 0 1
54501: PUSH
54502: LD_INT 125
54504: EQUAL
54505: IFFALSE 54511
// MC_Deposits ( ) ;
54507: CALL 70960 0 0
// if event = 126 then
54511: LD_VAR 0 1
54515: PUSH
54516: LD_INT 126
54518: EQUAL
54519: IFFALSE 54525
// MC_RemoteDriver ( ) ;
54521: CALL 71585 0 0
// if event = 200 then
54525: LD_VAR 0 1
54529: PUSH
54530: LD_INT 200
54532: EQUAL
54533: IFFALSE 54539
// MC_Idle ( ) ;
54535: CALL 73534 0 0
// end ;
54539: PPOPN 1
54541: END
// export function MC_Reset ( base , tag ) ; var i ; begin
54542: LD_INT 0
54544: PPUSH
54545: PPUSH
// if not mc_bases [ base ] or not tag then
54546: LD_EXP 59
54550: PUSH
54551: LD_VAR 0 1
54555: ARRAY
54556: NOT
54557: PUSH
54558: LD_VAR 0 2
54562: NOT
54563: OR
54564: IFFALSE 54568
// exit ;
54566: GO 54632
// for i in mc_bases [ base ] union mc_ape [ base ] do
54568: LD_ADDR_VAR 0 4
54572: PUSH
54573: LD_EXP 59
54577: PUSH
54578: LD_VAR 0 1
54582: ARRAY
54583: PUSH
54584: LD_EXP 88
54588: PUSH
54589: LD_VAR 0 1
54593: ARRAY
54594: UNION
54595: PUSH
54596: FOR_IN
54597: IFFALSE 54630
// if GetTag ( i ) = tag then
54599: LD_VAR 0 4
54603: PPUSH
54604: CALL_OW 110
54608: PUSH
54609: LD_VAR 0 2
54613: EQUAL
54614: IFFALSE 54628
// SetTag ( i , 0 ) ;
54616: LD_VAR 0 4
54620: PPUSH
54621: LD_INT 0
54623: PPUSH
54624: CALL_OW 109
54628: GO 54596
54630: POP
54631: POP
// end ;
54632: LD_VAR 0 3
54636: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
54637: LD_INT 0
54639: PPUSH
54640: PPUSH
54641: PPUSH
54642: PPUSH
54643: PPUSH
54644: PPUSH
54645: PPUSH
54646: PPUSH
// if not mc_bases then
54647: LD_EXP 59
54651: NOT
54652: IFFALSE 54656
// exit ;
54654: GO 55114
// for i = 1 to mc_bases do
54656: LD_ADDR_VAR 0 2
54660: PUSH
54661: DOUBLE
54662: LD_INT 1
54664: DEC
54665: ST_TO_ADDR
54666: LD_EXP 59
54670: PUSH
54671: FOR_TO
54672: IFFALSE 55112
// begin tmp := MC_ClassCheckReq ( i ) ;
54674: LD_ADDR_VAR 0 4
54678: PUSH
54679: LD_VAR 0 2
54683: PPUSH
54684: CALL 55119 0 1
54688: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
54689: LD_ADDR_EXP 100
54693: PUSH
54694: LD_EXP 100
54698: PPUSH
54699: LD_VAR 0 2
54703: PPUSH
54704: LD_VAR 0 4
54708: PPUSH
54709: CALL_OW 1
54713: ST_TO_ADDR
// if not tmp then
54714: LD_VAR 0 4
54718: NOT
54719: IFFALSE 54723
// continue ;
54721: GO 54671
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
54723: LD_ADDR_VAR 0 6
54727: PUSH
54728: LD_EXP 59
54732: PUSH
54733: LD_VAR 0 2
54737: ARRAY
54738: PPUSH
54739: LD_INT 2
54741: PUSH
54742: LD_INT 30
54744: PUSH
54745: LD_INT 4
54747: PUSH
54748: EMPTY
54749: LIST
54750: LIST
54751: PUSH
54752: LD_INT 30
54754: PUSH
54755: LD_INT 5
54757: PUSH
54758: EMPTY
54759: LIST
54760: LIST
54761: PUSH
54762: EMPTY
54763: LIST
54764: LIST
54765: LIST
54766: PPUSH
54767: CALL_OW 72
54771: PUSH
54772: LD_EXP 59
54776: PUSH
54777: LD_VAR 0 2
54781: ARRAY
54782: PPUSH
54783: LD_INT 2
54785: PUSH
54786: LD_INT 30
54788: PUSH
54789: LD_INT 0
54791: PUSH
54792: EMPTY
54793: LIST
54794: LIST
54795: PUSH
54796: LD_INT 30
54798: PUSH
54799: LD_INT 1
54801: PUSH
54802: EMPTY
54803: LIST
54804: LIST
54805: PUSH
54806: EMPTY
54807: LIST
54808: LIST
54809: LIST
54810: PPUSH
54811: CALL_OW 72
54815: PUSH
54816: LD_EXP 59
54820: PUSH
54821: LD_VAR 0 2
54825: ARRAY
54826: PPUSH
54827: LD_INT 30
54829: PUSH
54830: LD_INT 3
54832: PUSH
54833: EMPTY
54834: LIST
54835: LIST
54836: PPUSH
54837: CALL_OW 72
54841: PUSH
54842: LD_EXP 59
54846: PUSH
54847: LD_VAR 0 2
54851: ARRAY
54852: PPUSH
54853: LD_INT 2
54855: PUSH
54856: LD_INT 30
54858: PUSH
54859: LD_INT 6
54861: PUSH
54862: EMPTY
54863: LIST
54864: LIST
54865: PUSH
54866: LD_INT 30
54868: PUSH
54869: LD_INT 7
54871: PUSH
54872: EMPTY
54873: LIST
54874: LIST
54875: PUSH
54876: LD_INT 30
54878: PUSH
54879: LD_INT 8
54881: PUSH
54882: EMPTY
54883: LIST
54884: LIST
54885: PUSH
54886: EMPTY
54887: LIST
54888: LIST
54889: LIST
54890: LIST
54891: PPUSH
54892: CALL_OW 72
54896: PUSH
54897: EMPTY
54898: LIST
54899: LIST
54900: LIST
54901: LIST
54902: ST_TO_ADDR
// for j = 1 to 4 do
54903: LD_ADDR_VAR 0 3
54907: PUSH
54908: DOUBLE
54909: LD_INT 1
54911: DEC
54912: ST_TO_ADDR
54913: LD_INT 4
54915: PUSH
54916: FOR_TO
54917: IFFALSE 55108
// begin if not tmp [ j ] then
54919: LD_VAR 0 4
54923: PUSH
54924: LD_VAR 0 3
54928: ARRAY
54929: NOT
54930: IFFALSE 54934
// continue ;
54932: GO 54916
// for p in tmp [ j ] do
54934: LD_ADDR_VAR 0 5
54938: PUSH
54939: LD_VAR 0 4
54943: PUSH
54944: LD_VAR 0 3
54948: ARRAY
54949: PUSH
54950: FOR_IN
54951: IFFALSE 55104
// begin if not b [ j ] then
54953: LD_VAR 0 6
54957: PUSH
54958: LD_VAR 0 3
54962: ARRAY
54963: NOT
54964: IFFALSE 54968
// break ;
54966: GO 55104
// e := 0 ;
54968: LD_ADDR_VAR 0 7
54972: PUSH
54973: LD_INT 0
54975: ST_TO_ADDR
// for k in b [ j ] do
54976: LD_ADDR_VAR 0 8
54980: PUSH
54981: LD_VAR 0 6
54985: PUSH
54986: LD_VAR 0 3
54990: ARRAY
54991: PUSH
54992: FOR_IN
54993: IFFALSE 55020
// if IsNotFull ( k ) then
54995: LD_VAR 0 8
54999: PPUSH
55000: CALL 16504 0 1
55004: IFFALSE 55018
// begin e := k ;
55006: LD_ADDR_VAR 0 7
55010: PUSH
55011: LD_VAR 0 8
55015: ST_TO_ADDR
// break ;
55016: GO 55020
// end ;
55018: GO 54992
55020: POP
55021: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55022: LD_VAR 0 7
55026: PUSH
55027: LD_VAR 0 5
55031: PPUSH
55032: LD_VAR 0 7
55036: PPUSH
55037: CALL 48924 0 2
55041: NOT
55042: AND
55043: IFFALSE 55102
// begin if IsInUnit ( p ) then
55045: LD_VAR 0 5
55049: PPUSH
55050: CALL_OW 310
55054: IFFALSE 55065
// ComExitBuilding ( p ) ;
55056: LD_VAR 0 5
55060: PPUSH
55061: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55065: LD_VAR 0 5
55069: PPUSH
55070: LD_VAR 0 7
55074: PPUSH
55075: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
55079: LD_VAR 0 5
55083: PPUSH
55084: LD_VAR 0 3
55088: PPUSH
55089: CALL_OW 183
// AddComExitBuilding ( p ) ;
55093: LD_VAR 0 5
55097: PPUSH
55098: CALL_OW 182
// end ; end ;
55102: GO 54950
55104: POP
55105: POP
// end ;
55106: GO 54916
55108: POP
55109: POP
// end ;
55110: GO 54671
55112: POP
55113: POP
// end ;
55114: LD_VAR 0 1
55118: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
55119: LD_INT 0
55121: PPUSH
55122: PPUSH
55123: PPUSH
55124: PPUSH
55125: PPUSH
55126: PPUSH
55127: PPUSH
55128: PPUSH
55129: PPUSH
55130: PPUSH
55131: PPUSH
55132: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55133: LD_VAR 0 1
55137: NOT
55138: PUSH
55139: LD_EXP 59
55143: PUSH
55144: LD_VAR 0 1
55148: ARRAY
55149: NOT
55150: OR
55151: PUSH
55152: LD_EXP 59
55156: PUSH
55157: LD_VAR 0 1
55161: ARRAY
55162: PPUSH
55163: LD_INT 2
55165: PUSH
55166: LD_INT 30
55168: PUSH
55169: LD_INT 0
55171: PUSH
55172: EMPTY
55173: LIST
55174: LIST
55175: PUSH
55176: LD_INT 30
55178: PUSH
55179: LD_INT 1
55181: PUSH
55182: EMPTY
55183: LIST
55184: LIST
55185: PUSH
55186: EMPTY
55187: LIST
55188: LIST
55189: LIST
55190: PPUSH
55191: CALL_OW 72
55195: NOT
55196: OR
55197: IFFALSE 55201
// exit ;
55199: GO 58704
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55201: LD_ADDR_VAR 0 4
55205: PUSH
55206: LD_EXP 59
55210: PUSH
55211: LD_VAR 0 1
55215: ARRAY
55216: PPUSH
55217: LD_INT 2
55219: PUSH
55220: LD_INT 25
55222: PUSH
55223: LD_INT 1
55225: PUSH
55226: EMPTY
55227: LIST
55228: LIST
55229: PUSH
55230: LD_INT 25
55232: PUSH
55233: LD_INT 2
55235: PUSH
55236: EMPTY
55237: LIST
55238: LIST
55239: PUSH
55240: LD_INT 25
55242: PUSH
55243: LD_INT 3
55245: PUSH
55246: EMPTY
55247: LIST
55248: LIST
55249: PUSH
55250: LD_INT 25
55252: PUSH
55253: LD_INT 4
55255: PUSH
55256: EMPTY
55257: LIST
55258: LIST
55259: PUSH
55260: LD_INT 25
55262: PUSH
55263: LD_INT 5
55265: PUSH
55266: EMPTY
55267: LIST
55268: LIST
55269: PUSH
55270: LD_INT 25
55272: PUSH
55273: LD_INT 8
55275: PUSH
55276: EMPTY
55277: LIST
55278: LIST
55279: PUSH
55280: LD_INT 25
55282: PUSH
55283: LD_INT 9
55285: PUSH
55286: EMPTY
55287: LIST
55288: LIST
55289: PUSH
55290: EMPTY
55291: LIST
55292: LIST
55293: LIST
55294: LIST
55295: LIST
55296: LIST
55297: LIST
55298: LIST
55299: PPUSH
55300: CALL_OW 72
55304: ST_TO_ADDR
// if not tmp then
55305: LD_VAR 0 4
55309: NOT
55310: IFFALSE 55314
// exit ;
55312: GO 58704
// for i in tmp do
55314: LD_ADDR_VAR 0 3
55318: PUSH
55319: LD_VAR 0 4
55323: PUSH
55324: FOR_IN
55325: IFFALSE 55356
// if GetTag ( i ) then
55327: LD_VAR 0 3
55331: PPUSH
55332: CALL_OW 110
55336: IFFALSE 55354
// tmp := tmp diff i ;
55338: LD_ADDR_VAR 0 4
55342: PUSH
55343: LD_VAR 0 4
55347: PUSH
55348: LD_VAR 0 3
55352: DIFF
55353: ST_TO_ADDR
55354: GO 55324
55356: POP
55357: POP
// if not tmp then
55358: LD_VAR 0 4
55362: NOT
55363: IFFALSE 55367
// exit ;
55365: GO 58704
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55367: LD_ADDR_VAR 0 5
55371: PUSH
55372: LD_EXP 59
55376: PUSH
55377: LD_VAR 0 1
55381: ARRAY
55382: PPUSH
55383: LD_INT 2
55385: PUSH
55386: LD_INT 25
55388: PUSH
55389: LD_INT 1
55391: PUSH
55392: EMPTY
55393: LIST
55394: LIST
55395: PUSH
55396: LD_INT 25
55398: PUSH
55399: LD_INT 5
55401: PUSH
55402: EMPTY
55403: LIST
55404: LIST
55405: PUSH
55406: LD_INT 25
55408: PUSH
55409: LD_INT 8
55411: PUSH
55412: EMPTY
55413: LIST
55414: LIST
55415: PUSH
55416: LD_INT 25
55418: PUSH
55419: LD_INT 9
55421: PUSH
55422: EMPTY
55423: LIST
55424: LIST
55425: PUSH
55426: EMPTY
55427: LIST
55428: LIST
55429: LIST
55430: LIST
55431: LIST
55432: PPUSH
55433: CALL_OW 72
55437: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
55438: LD_ADDR_VAR 0 6
55442: PUSH
55443: LD_EXP 59
55447: PUSH
55448: LD_VAR 0 1
55452: ARRAY
55453: PPUSH
55454: LD_INT 25
55456: PUSH
55457: LD_INT 2
55459: PUSH
55460: EMPTY
55461: LIST
55462: LIST
55463: PPUSH
55464: CALL_OW 72
55468: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
55469: LD_ADDR_VAR 0 7
55473: PUSH
55474: LD_EXP 59
55478: PUSH
55479: LD_VAR 0 1
55483: ARRAY
55484: PPUSH
55485: LD_INT 25
55487: PUSH
55488: LD_INT 3
55490: PUSH
55491: EMPTY
55492: LIST
55493: LIST
55494: PPUSH
55495: CALL_OW 72
55499: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
55500: LD_ADDR_VAR 0 8
55504: PUSH
55505: LD_EXP 59
55509: PUSH
55510: LD_VAR 0 1
55514: ARRAY
55515: PPUSH
55516: LD_INT 25
55518: PUSH
55519: LD_INT 4
55521: PUSH
55522: EMPTY
55523: LIST
55524: LIST
55525: PUSH
55526: LD_INT 24
55528: PUSH
55529: LD_INT 251
55531: PUSH
55532: EMPTY
55533: LIST
55534: LIST
55535: PUSH
55536: EMPTY
55537: LIST
55538: LIST
55539: PPUSH
55540: CALL_OW 72
55544: ST_TO_ADDR
// if mc_scan [ base ] then
55545: LD_EXP 82
55549: PUSH
55550: LD_VAR 0 1
55554: ARRAY
55555: IFFALSE 56016
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
55557: LD_ADDR_EXP 101
55561: PUSH
55562: LD_EXP 101
55566: PPUSH
55567: LD_VAR 0 1
55571: PPUSH
55572: LD_INT 4
55574: PPUSH
55575: CALL_OW 1
55579: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55580: LD_ADDR_VAR 0 12
55584: PUSH
55585: LD_EXP 59
55589: PUSH
55590: LD_VAR 0 1
55594: ARRAY
55595: PPUSH
55596: LD_INT 2
55598: PUSH
55599: LD_INT 30
55601: PUSH
55602: LD_INT 4
55604: PUSH
55605: EMPTY
55606: LIST
55607: LIST
55608: PUSH
55609: LD_INT 30
55611: PUSH
55612: LD_INT 5
55614: PUSH
55615: EMPTY
55616: LIST
55617: LIST
55618: PUSH
55619: EMPTY
55620: LIST
55621: LIST
55622: LIST
55623: PPUSH
55624: CALL_OW 72
55628: ST_TO_ADDR
// if not b then
55629: LD_VAR 0 12
55633: NOT
55634: IFFALSE 55638
// exit ;
55636: GO 58704
// p := [ ] ;
55638: LD_ADDR_VAR 0 11
55642: PUSH
55643: EMPTY
55644: ST_TO_ADDR
// if sci >= 2 then
55645: LD_VAR 0 8
55649: PUSH
55650: LD_INT 2
55652: GREATEREQUAL
55653: IFFALSE 55684
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
55655: LD_ADDR_VAR 0 8
55659: PUSH
55660: LD_VAR 0 8
55664: PUSH
55665: LD_INT 1
55667: ARRAY
55668: PUSH
55669: LD_VAR 0 8
55673: PUSH
55674: LD_INT 2
55676: ARRAY
55677: PUSH
55678: EMPTY
55679: LIST
55680: LIST
55681: ST_TO_ADDR
55682: GO 55745
// if sci = 1 then
55684: LD_VAR 0 8
55688: PUSH
55689: LD_INT 1
55691: EQUAL
55692: IFFALSE 55713
// sci := [ sci [ 1 ] ] else
55694: LD_ADDR_VAR 0 8
55698: PUSH
55699: LD_VAR 0 8
55703: PUSH
55704: LD_INT 1
55706: ARRAY
55707: PUSH
55708: EMPTY
55709: LIST
55710: ST_TO_ADDR
55711: GO 55745
// if sci = 0 then
55713: LD_VAR 0 8
55717: PUSH
55718: LD_INT 0
55720: EQUAL
55721: IFFALSE 55745
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
55723: LD_ADDR_VAR 0 11
55727: PUSH
55728: LD_VAR 0 4
55732: PPUSH
55733: LD_INT 4
55735: PPUSH
55736: CALL 48787 0 2
55740: PUSH
55741: LD_INT 1
55743: ARRAY
55744: ST_TO_ADDR
// if eng > 4 then
55745: LD_VAR 0 6
55749: PUSH
55750: LD_INT 4
55752: GREATER
55753: IFFALSE 55799
// for i = eng downto 4 do
55755: LD_ADDR_VAR 0 3
55759: PUSH
55760: DOUBLE
55761: LD_VAR 0 6
55765: INC
55766: ST_TO_ADDR
55767: LD_INT 4
55769: PUSH
55770: FOR_DOWNTO
55771: IFFALSE 55797
// eng := eng diff eng [ i ] ;
55773: LD_ADDR_VAR 0 6
55777: PUSH
55778: LD_VAR 0 6
55782: PUSH
55783: LD_VAR 0 6
55787: PUSH
55788: LD_VAR 0 3
55792: ARRAY
55793: DIFF
55794: ST_TO_ADDR
55795: GO 55770
55797: POP
55798: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
55799: LD_ADDR_VAR 0 4
55803: PUSH
55804: LD_VAR 0 4
55808: PUSH
55809: LD_VAR 0 5
55813: PUSH
55814: LD_VAR 0 6
55818: UNION
55819: PUSH
55820: LD_VAR 0 7
55824: UNION
55825: PUSH
55826: LD_VAR 0 8
55830: UNION
55831: DIFF
55832: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
55833: LD_ADDR_VAR 0 13
55837: PUSH
55838: LD_EXP 59
55842: PUSH
55843: LD_VAR 0 1
55847: ARRAY
55848: PPUSH
55849: LD_INT 2
55851: PUSH
55852: LD_INT 30
55854: PUSH
55855: LD_INT 32
55857: PUSH
55858: EMPTY
55859: LIST
55860: LIST
55861: PUSH
55862: LD_INT 30
55864: PUSH
55865: LD_INT 31
55867: PUSH
55868: EMPTY
55869: LIST
55870: LIST
55871: PUSH
55872: EMPTY
55873: LIST
55874: LIST
55875: LIST
55876: PPUSH
55877: CALL_OW 72
55881: PUSH
55882: LD_EXP 59
55886: PUSH
55887: LD_VAR 0 1
55891: ARRAY
55892: PPUSH
55893: LD_INT 2
55895: PUSH
55896: LD_INT 30
55898: PUSH
55899: LD_INT 4
55901: PUSH
55902: EMPTY
55903: LIST
55904: LIST
55905: PUSH
55906: LD_INT 30
55908: PUSH
55909: LD_INT 5
55911: PUSH
55912: EMPTY
55913: LIST
55914: LIST
55915: PUSH
55916: EMPTY
55917: LIST
55918: LIST
55919: LIST
55920: PPUSH
55921: CALL_OW 72
55925: PUSH
55926: LD_INT 6
55928: MUL
55929: PLUS
55930: ST_TO_ADDR
// if bcount < tmp then
55931: LD_VAR 0 13
55935: PUSH
55936: LD_VAR 0 4
55940: LESS
55941: IFFALSE 55987
// for i = tmp downto bcount do
55943: LD_ADDR_VAR 0 3
55947: PUSH
55948: DOUBLE
55949: LD_VAR 0 4
55953: INC
55954: ST_TO_ADDR
55955: LD_VAR 0 13
55959: PUSH
55960: FOR_DOWNTO
55961: IFFALSE 55985
// tmp := Delete ( tmp , tmp ) ;
55963: LD_ADDR_VAR 0 4
55967: PUSH
55968: LD_VAR 0 4
55972: PPUSH
55973: LD_VAR 0 4
55977: PPUSH
55978: CALL_OW 3
55982: ST_TO_ADDR
55983: GO 55960
55985: POP
55986: POP
// result := [ tmp , 0 , 0 , p ] ;
55987: LD_ADDR_VAR 0 2
55991: PUSH
55992: LD_VAR 0 4
55996: PUSH
55997: LD_INT 0
55999: PUSH
56000: LD_INT 0
56002: PUSH
56003: LD_VAR 0 11
56007: PUSH
56008: EMPTY
56009: LIST
56010: LIST
56011: LIST
56012: LIST
56013: ST_TO_ADDR
// exit ;
56014: GO 58704
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56016: LD_EXP 59
56020: PUSH
56021: LD_VAR 0 1
56025: ARRAY
56026: PPUSH
56027: LD_INT 2
56029: PUSH
56030: LD_INT 30
56032: PUSH
56033: LD_INT 6
56035: PUSH
56036: EMPTY
56037: LIST
56038: LIST
56039: PUSH
56040: LD_INT 30
56042: PUSH
56043: LD_INT 7
56045: PUSH
56046: EMPTY
56047: LIST
56048: LIST
56049: PUSH
56050: LD_INT 30
56052: PUSH
56053: LD_INT 8
56055: PUSH
56056: EMPTY
56057: LIST
56058: LIST
56059: PUSH
56060: EMPTY
56061: LIST
56062: LIST
56063: LIST
56064: LIST
56065: PPUSH
56066: CALL_OW 72
56070: NOT
56071: PUSH
56072: LD_EXP 59
56076: PUSH
56077: LD_VAR 0 1
56081: ARRAY
56082: PPUSH
56083: LD_INT 30
56085: PUSH
56086: LD_INT 3
56088: PUSH
56089: EMPTY
56090: LIST
56091: LIST
56092: PPUSH
56093: CALL_OW 72
56097: NOT
56098: AND
56099: IFFALSE 56171
// begin if eng = tmp then
56101: LD_VAR 0 6
56105: PUSH
56106: LD_VAR 0 4
56110: EQUAL
56111: IFFALSE 56115
// exit ;
56113: GO 58704
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
56115: LD_ADDR_EXP 101
56119: PUSH
56120: LD_EXP 101
56124: PPUSH
56125: LD_VAR 0 1
56129: PPUSH
56130: LD_INT 1
56132: PPUSH
56133: CALL_OW 1
56137: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
56138: LD_ADDR_VAR 0 2
56142: PUSH
56143: LD_INT 0
56145: PUSH
56146: LD_VAR 0 4
56150: PUSH
56151: LD_VAR 0 6
56155: DIFF
56156: PUSH
56157: LD_INT 0
56159: PUSH
56160: LD_INT 0
56162: PUSH
56163: EMPTY
56164: LIST
56165: LIST
56166: LIST
56167: LIST
56168: ST_TO_ADDR
// exit ;
56169: GO 58704
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56171: LD_EXP 86
56175: PUSH
56176: LD_EXP 85
56180: PUSH
56181: LD_VAR 0 1
56185: ARRAY
56186: ARRAY
56187: PUSH
56188: LD_EXP 59
56192: PUSH
56193: LD_VAR 0 1
56197: ARRAY
56198: PPUSH
56199: LD_INT 2
56201: PUSH
56202: LD_INT 30
56204: PUSH
56205: LD_INT 6
56207: PUSH
56208: EMPTY
56209: LIST
56210: LIST
56211: PUSH
56212: LD_INT 30
56214: PUSH
56215: LD_INT 7
56217: PUSH
56218: EMPTY
56219: LIST
56220: LIST
56221: PUSH
56222: LD_INT 30
56224: PUSH
56225: LD_INT 8
56227: PUSH
56228: EMPTY
56229: LIST
56230: LIST
56231: PUSH
56232: EMPTY
56233: LIST
56234: LIST
56235: LIST
56236: LIST
56237: PPUSH
56238: CALL_OW 72
56242: AND
56243: PUSH
56244: LD_EXP 59
56248: PUSH
56249: LD_VAR 0 1
56253: ARRAY
56254: PPUSH
56255: LD_INT 30
56257: PUSH
56258: LD_INT 3
56260: PUSH
56261: EMPTY
56262: LIST
56263: LIST
56264: PPUSH
56265: CALL_OW 72
56269: NOT
56270: AND
56271: IFFALSE 56485
// begin if sci >= 6 then
56273: LD_VAR 0 8
56277: PUSH
56278: LD_INT 6
56280: GREATEREQUAL
56281: IFFALSE 56285
// exit ;
56283: GO 58704
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
56285: LD_ADDR_EXP 101
56289: PUSH
56290: LD_EXP 101
56294: PPUSH
56295: LD_VAR 0 1
56299: PPUSH
56300: LD_INT 2
56302: PPUSH
56303: CALL_OW 1
56307: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
56308: LD_ADDR_VAR 0 9
56312: PUSH
56313: LD_VAR 0 4
56317: PUSH
56318: LD_VAR 0 8
56322: DIFF
56323: PPUSH
56324: LD_INT 4
56326: PPUSH
56327: CALL 48787 0 2
56331: ST_TO_ADDR
// p := [ ] ;
56332: LD_ADDR_VAR 0 11
56336: PUSH
56337: EMPTY
56338: ST_TO_ADDR
// if sci < 6 and sort > 6 then
56339: LD_VAR 0 8
56343: PUSH
56344: LD_INT 6
56346: LESS
56347: PUSH
56348: LD_VAR 0 9
56352: PUSH
56353: LD_INT 6
56355: GREATER
56356: AND
56357: IFFALSE 56438
// begin for i = 1 to 6 - sci do
56359: LD_ADDR_VAR 0 3
56363: PUSH
56364: DOUBLE
56365: LD_INT 1
56367: DEC
56368: ST_TO_ADDR
56369: LD_INT 6
56371: PUSH
56372: LD_VAR 0 8
56376: MINUS
56377: PUSH
56378: FOR_TO
56379: IFFALSE 56434
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
56381: LD_ADDR_VAR 0 11
56385: PUSH
56386: LD_VAR 0 11
56390: PPUSH
56391: LD_VAR 0 11
56395: PUSH
56396: LD_INT 1
56398: PLUS
56399: PPUSH
56400: LD_VAR 0 9
56404: PUSH
56405: LD_INT 1
56407: ARRAY
56408: PPUSH
56409: CALL_OW 2
56413: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
56414: LD_ADDR_VAR 0 9
56418: PUSH
56419: LD_VAR 0 9
56423: PPUSH
56424: LD_INT 1
56426: PPUSH
56427: CALL_OW 3
56431: ST_TO_ADDR
// end ;
56432: GO 56378
56434: POP
56435: POP
// end else
56436: GO 56458
// if sort then
56438: LD_VAR 0 9
56442: IFFALSE 56458
// p := sort [ 1 ] ;
56444: LD_ADDR_VAR 0 11
56448: PUSH
56449: LD_VAR 0 9
56453: PUSH
56454: LD_INT 1
56456: ARRAY
56457: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
56458: LD_ADDR_VAR 0 2
56462: PUSH
56463: LD_INT 0
56465: PUSH
56466: LD_INT 0
56468: PUSH
56469: LD_INT 0
56471: PUSH
56472: LD_VAR 0 11
56476: PUSH
56477: EMPTY
56478: LIST
56479: LIST
56480: LIST
56481: LIST
56482: ST_TO_ADDR
// exit ;
56483: GO 58704
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56485: LD_EXP 86
56489: PUSH
56490: LD_EXP 85
56494: PUSH
56495: LD_VAR 0 1
56499: ARRAY
56500: ARRAY
56501: PUSH
56502: LD_EXP 59
56506: PUSH
56507: LD_VAR 0 1
56511: ARRAY
56512: PPUSH
56513: LD_INT 2
56515: PUSH
56516: LD_INT 30
56518: PUSH
56519: LD_INT 6
56521: PUSH
56522: EMPTY
56523: LIST
56524: LIST
56525: PUSH
56526: LD_INT 30
56528: PUSH
56529: LD_INT 7
56531: PUSH
56532: EMPTY
56533: LIST
56534: LIST
56535: PUSH
56536: LD_INT 30
56538: PUSH
56539: LD_INT 8
56541: PUSH
56542: EMPTY
56543: LIST
56544: LIST
56545: PUSH
56546: EMPTY
56547: LIST
56548: LIST
56549: LIST
56550: LIST
56551: PPUSH
56552: CALL_OW 72
56556: AND
56557: PUSH
56558: LD_EXP 59
56562: PUSH
56563: LD_VAR 0 1
56567: ARRAY
56568: PPUSH
56569: LD_INT 30
56571: PUSH
56572: LD_INT 3
56574: PUSH
56575: EMPTY
56576: LIST
56577: LIST
56578: PPUSH
56579: CALL_OW 72
56583: AND
56584: IFFALSE 57318
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
56586: LD_ADDR_EXP 101
56590: PUSH
56591: LD_EXP 101
56595: PPUSH
56596: LD_VAR 0 1
56600: PPUSH
56601: LD_INT 3
56603: PPUSH
56604: CALL_OW 1
56608: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56609: LD_ADDR_VAR 0 2
56613: PUSH
56614: LD_INT 0
56616: PUSH
56617: LD_INT 0
56619: PUSH
56620: LD_INT 0
56622: PUSH
56623: LD_INT 0
56625: PUSH
56626: EMPTY
56627: LIST
56628: LIST
56629: LIST
56630: LIST
56631: ST_TO_ADDR
// if not eng then
56632: LD_VAR 0 6
56636: NOT
56637: IFFALSE 56700
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
56639: LD_ADDR_VAR 0 11
56643: PUSH
56644: LD_VAR 0 4
56648: PPUSH
56649: LD_INT 2
56651: PPUSH
56652: CALL 48787 0 2
56656: PUSH
56657: LD_INT 1
56659: ARRAY
56660: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
56661: LD_ADDR_VAR 0 2
56665: PUSH
56666: LD_VAR 0 2
56670: PPUSH
56671: LD_INT 2
56673: PPUSH
56674: LD_VAR 0 11
56678: PPUSH
56679: CALL_OW 1
56683: ST_TO_ADDR
// tmp := tmp diff p ;
56684: LD_ADDR_VAR 0 4
56688: PUSH
56689: LD_VAR 0 4
56693: PUSH
56694: LD_VAR 0 11
56698: DIFF
56699: ST_TO_ADDR
// end ; if tmp and sci < 6 then
56700: LD_VAR 0 4
56704: PUSH
56705: LD_VAR 0 8
56709: PUSH
56710: LD_INT 6
56712: LESS
56713: AND
56714: IFFALSE 56902
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
56716: LD_ADDR_VAR 0 9
56720: PUSH
56721: LD_VAR 0 4
56725: PUSH
56726: LD_VAR 0 8
56730: PUSH
56731: LD_VAR 0 7
56735: UNION
56736: DIFF
56737: PPUSH
56738: LD_INT 4
56740: PPUSH
56741: CALL 48787 0 2
56745: ST_TO_ADDR
// p := [ ] ;
56746: LD_ADDR_VAR 0 11
56750: PUSH
56751: EMPTY
56752: ST_TO_ADDR
// if sort then
56753: LD_VAR 0 9
56757: IFFALSE 56873
// for i = 1 to 6 - sci do
56759: LD_ADDR_VAR 0 3
56763: PUSH
56764: DOUBLE
56765: LD_INT 1
56767: DEC
56768: ST_TO_ADDR
56769: LD_INT 6
56771: PUSH
56772: LD_VAR 0 8
56776: MINUS
56777: PUSH
56778: FOR_TO
56779: IFFALSE 56871
// begin if i = sort then
56781: LD_VAR 0 3
56785: PUSH
56786: LD_VAR 0 9
56790: EQUAL
56791: IFFALSE 56795
// break ;
56793: GO 56871
// if GetClass ( i ) = 4 then
56795: LD_VAR 0 3
56799: PPUSH
56800: CALL_OW 257
56804: PUSH
56805: LD_INT 4
56807: EQUAL
56808: IFFALSE 56812
// continue ;
56810: GO 56778
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56812: LD_ADDR_VAR 0 11
56816: PUSH
56817: LD_VAR 0 11
56821: PPUSH
56822: LD_VAR 0 11
56826: PUSH
56827: LD_INT 1
56829: PLUS
56830: PPUSH
56831: LD_VAR 0 9
56835: PUSH
56836: LD_VAR 0 3
56840: ARRAY
56841: PPUSH
56842: CALL_OW 2
56846: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56847: LD_ADDR_VAR 0 4
56851: PUSH
56852: LD_VAR 0 4
56856: PUSH
56857: LD_VAR 0 9
56861: PUSH
56862: LD_VAR 0 3
56866: ARRAY
56867: DIFF
56868: ST_TO_ADDR
// end ;
56869: GO 56778
56871: POP
56872: POP
// if p then
56873: LD_VAR 0 11
56877: IFFALSE 56902
// result := Replace ( result , 4 , p ) ;
56879: LD_ADDR_VAR 0 2
56883: PUSH
56884: LD_VAR 0 2
56888: PPUSH
56889: LD_INT 4
56891: PPUSH
56892: LD_VAR 0 11
56896: PPUSH
56897: CALL_OW 1
56901: ST_TO_ADDR
// end ; if tmp and mech < 6 then
56902: LD_VAR 0 4
56906: PUSH
56907: LD_VAR 0 7
56911: PUSH
56912: LD_INT 6
56914: LESS
56915: AND
56916: IFFALSE 57104
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
56918: LD_ADDR_VAR 0 9
56922: PUSH
56923: LD_VAR 0 4
56927: PUSH
56928: LD_VAR 0 8
56932: PUSH
56933: LD_VAR 0 7
56937: UNION
56938: DIFF
56939: PPUSH
56940: LD_INT 3
56942: PPUSH
56943: CALL 48787 0 2
56947: ST_TO_ADDR
// p := [ ] ;
56948: LD_ADDR_VAR 0 11
56952: PUSH
56953: EMPTY
56954: ST_TO_ADDR
// if sort then
56955: LD_VAR 0 9
56959: IFFALSE 57075
// for i = 1 to 6 - mech do
56961: LD_ADDR_VAR 0 3
56965: PUSH
56966: DOUBLE
56967: LD_INT 1
56969: DEC
56970: ST_TO_ADDR
56971: LD_INT 6
56973: PUSH
56974: LD_VAR 0 7
56978: MINUS
56979: PUSH
56980: FOR_TO
56981: IFFALSE 57073
// begin if i = sort then
56983: LD_VAR 0 3
56987: PUSH
56988: LD_VAR 0 9
56992: EQUAL
56993: IFFALSE 56997
// break ;
56995: GO 57073
// if GetClass ( i ) = 3 then
56997: LD_VAR 0 3
57001: PPUSH
57002: CALL_OW 257
57006: PUSH
57007: LD_INT 3
57009: EQUAL
57010: IFFALSE 57014
// continue ;
57012: GO 56980
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57014: LD_ADDR_VAR 0 11
57018: PUSH
57019: LD_VAR 0 11
57023: PPUSH
57024: LD_VAR 0 11
57028: PUSH
57029: LD_INT 1
57031: PLUS
57032: PPUSH
57033: LD_VAR 0 9
57037: PUSH
57038: LD_VAR 0 3
57042: ARRAY
57043: PPUSH
57044: CALL_OW 2
57048: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57049: LD_ADDR_VAR 0 4
57053: PUSH
57054: LD_VAR 0 4
57058: PUSH
57059: LD_VAR 0 9
57063: PUSH
57064: LD_VAR 0 3
57068: ARRAY
57069: DIFF
57070: ST_TO_ADDR
// end ;
57071: GO 56980
57073: POP
57074: POP
// if p then
57075: LD_VAR 0 11
57079: IFFALSE 57104
// result := Replace ( result , 3 , p ) ;
57081: LD_ADDR_VAR 0 2
57085: PUSH
57086: LD_VAR 0 2
57090: PPUSH
57091: LD_INT 3
57093: PPUSH
57094: LD_VAR 0 11
57098: PPUSH
57099: CALL_OW 1
57103: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
57104: LD_VAR 0 4
57108: PUSH
57109: LD_INT 6
57111: GREATER
57112: PUSH
57113: LD_VAR 0 6
57117: PUSH
57118: LD_INT 6
57120: LESS
57121: AND
57122: IFFALSE 57316
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57124: LD_ADDR_VAR 0 9
57128: PUSH
57129: LD_VAR 0 4
57133: PUSH
57134: LD_VAR 0 8
57138: PUSH
57139: LD_VAR 0 7
57143: UNION
57144: PUSH
57145: LD_VAR 0 6
57149: UNION
57150: DIFF
57151: PPUSH
57152: LD_INT 2
57154: PPUSH
57155: CALL 48787 0 2
57159: ST_TO_ADDR
// p := [ ] ;
57160: LD_ADDR_VAR 0 11
57164: PUSH
57165: EMPTY
57166: ST_TO_ADDR
// if sort then
57167: LD_VAR 0 9
57171: IFFALSE 57287
// for i = 1 to 6 - eng do
57173: LD_ADDR_VAR 0 3
57177: PUSH
57178: DOUBLE
57179: LD_INT 1
57181: DEC
57182: ST_TO_ADDR
57183: LD_INT 6
57185: PUSH
57186: LD_VAR 0 6
57190: MINUS
57191: PUSH
57192: FOR_TO
57193: IFFALSE 57285
// begin if i = sort then
57195: LD_VAR 0 3
57199: PUSH
57200: LD_VAR 0 9
57204: EQUAL
57205: IFFALSE 57209
// break ;
57207: GO 57285
// if GetClass ( i ) = 2 then
57209: LD_VAR 0 3
57213: PPUSH
57214: CALL_OW 257
57218: PUSH
57219: LD_INT 2
57221: EQUAL
57222: IFFALSE 57226
// continue ;
57224: GO 57192
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57226: LD_ADDR_VAR 0 11
57230: PUSH
57231: LD_VAR 0 11
57235: PPUSH
57236: LD_VAR 0 11
57240: PUSH
57241: LD_INT 1
57243: PLUS
57244: PPUSH
57245: LD_VAR 0 9
57249: PUSH
57250: LD_VAR 0 3
57254: ARRAY
57255: PPUSH
57256: CALL_OW 2
57260: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57261: LD_ADDR_VAR 0 4
57265: PUSH
57266: LD_VAR 0 4
57270: PUSH
57271: LD_VAR 0 9
57275: PUSH
57276: LD_VAR 0 3
57280: ARRAY
57281: DIFF
57282: ST_TO_ADDR
// end ;
57283: GO 57192
57285: POP
57286: POP
// if p then
57287: LD_VAR 0 11
57291: IFFALSE 57316
// result := Replace ( result , 2 , p ) ;
57293: LD_ADDR_VAR 0 2
57297: PUSH
57298: LD_VAR 0 2
57302: PPUSH
57303: LD_INT 2
57305: PPUSH
57306: LD_VAR 0 11
57310: PPUSH
57311: CALL_OW 1
57315: ST_TO_ADDR
// end ; exit ;
57316: GO 58704
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
57318: LD_EXP 86
57322: PUSH
57323: LD_EXP 85
57327: PUSH
57328: LD_VAR 0 1
57332: ARRAY
57333: ARRAY
57334: NOT
57335: PUSH
57336: LD_EXP 59
57340: PUSH
57341: LD_VAR 0 1
57345: ARRAY
57346: PPUSH
57347: LD_INT 30
57349: PUSH
57350: LD_INT 3
57352: PUSH
57353: EMPTY
57354: LIST
57355: LIST
57356: PPUSH
57357: CALL_OW 72
57361: AND
57362: PUSH
57363: LD_EXP 64
57367: PUSH
57368: LD_VAR 0 1
57372: ARRAY
57373: AND
57374: IFFALSE 57982
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
57376: LD_ADDR_EXP 101
57380: PUSH
57381: LD_EXP 101
57385: PPUSH
57386: LD_VAR 0 1
57390: PPUSH
57391: LD_INT 5
57393: PPUSH
57394: CALL_OW 1
57398: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57399: LD_ADDR_VAR 0 2
57403: PUSH
57404: LD_INT 0
57406: PUSH
57407: LD_INT 0
57409: PUSH
57410: LD_INT 0
57412: PUSH
57413: LD_INT 0
57415: PUSH
57416: EMPTY
57417: LIST
57418: LIST
57419: LIST
57420: LIST
57421: ST_TO_ADDR
// if sci > 1 then
57422: LD_VAR 0 8
57426: PUSH
57427: LD_INT 1
57429: GREATER
57430: IFFALSE 57458
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
57432: LD_ADDR_VAR 0 4
57436: PUSH
57437: LD_VAR 0 4
57441: PUSH
57442: LD_VAR 0 8
57446: PUSH
57447: LD_VAR 0 8
57451: PUSH
57452: LD_INT 1
57454: ARRAY
57455: DIFF
57456: DIFF
57457: ST_TO_ADDR
// if tmp and not sci then
57458: LD_VAR 0 4
57462: PUSH
57463: LD_VAR 0 8
57467: NOT
57468: AND
57469: IFFALSE 57538
// begin sort := SortBySkill ( tmp , 4 ) ;
57471: LD_ADDR_VAR 0 9
57475: PUSH
57476: LD_VAR 0 4
57480: PPUSH
57481: LD_INT 4
57483: PPUSH
57484: CALL 48787 0 2
57488: ST_TO_ADDR
// if sort then
57489: LD_VAR 0 9
57493: IFFALSE 57509
// p := sort [ 1 ] ;
57495: LD_ADDR_VAR 0 11
57499: PUSH
57500: LD_VAR 0 9
57504: PUSH
57505: LD_INT 1
57507: ARRAY
57508: ST_TO_ADDR
// if p then
57509: LD_VAR 0 11
57513: IFFALSE 57538
// result := Replace ( result , 4 , p ) ;
57515: LD_ADDR_VAR 0 2
57519: PUSH
57520: LD_VAR 0 2
57524: PPUSH
57525: LD_INT 4
57527: PPUSH
57528: LD_VAR 0 11
57532: PPUSH
57533: CALL_OW 1
57537: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57538: LD_ADDR_VAR 0 4
57542: PUSH
57543: LD_VAR 0 4
57547: PUSH
57548: LD_VAR 0 7
57552: DIFF
57553: ST_TO_ADDR
// if tmp and mech < 6 then
57554: LD_VAR 0 4
57558: PUSH
57559: LD_VAR 0 7
57563: PUSH
57564: LD_INT 6
57566: LESS
57567: AND
57568: IFFALSE 57756
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57570: LD_ADDR_VAR 0 9
57574: PUSH
57575: LD_VAR 0 4
57579: PUSH
57580: LD_VAR 0 8
57584: PUSH
57585: LD_VAR 0 7
57589: UNION
57590: DIFF
57591: PPUSH
57592: LD_INT 3
57594: PPUSH
57595: CALL 48787 0 2
57599: ST_TO_ADDR
// p := [ ] ;
57600: LD_ADDR_VAR 0 11
57604: PUSH
57605: EMPTY
57606: ST_TO_ADDR
// if sort then
57607: LD_VAR 0 9
57611: IFFALSE 57727
// for i = 1 to 6 - mech do
57613: LD_ADDR_VAR 0 3
57617: PUSH
57618: DOUBLE
57619: LD_INT 1
57621: DEC
57622: ST_TO_ADDR
57623: LD_INT 6
57625: PUSH
57626: LD_VAR 0 7
57630: MINUS
57631: PUSH
57632: FOR_TO
57633: IFFALSE 57725
// begin if i = sort then
57635: LD_VAR 0 3
57639: PUSH
57640: LD_VAR 0 9
57644: EQUAL
57645: IFFALSE 57649
// break ;
57647: GO 57725
// if GetClass ( i ) = 3 then
57649: LD_VAR 0 3
57653: PPUSH
57654: CALL_OW 257
57658: PUSH
57659: LD_INT 3
57661: EQUAL
57662: IFFALSE 57666
// continue ;
57664: GO 57632
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57666: LD_ADDR_VAR 0 11
57670: PUSH
57671: LD_VAR 0 11
57675: PPUSH
57676: LD_VAR 0 11
57680: PUSH
57681: LD_INT 1
57683: PLUS
57684: PPUSH
57685: LD_VAR 0 9
57689: PUSH
57690: LD_VAR 0 3
57694: ARRAY
57695: PPUSH
57696: CALL_OW 2
57700: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57701: LD_ADDR_VAR 0 4
57705: PUSH
57706: LD_VAR 0 4
57710: PUSH
57711: LD_VAR 0 9
57715: PUSH
57716: LD_VAR 0 3
57720: ARRAY
57721: DIFF
57722: ST_TO_ADDR
// end ;
57723: GO 57632
57725: POP
57726: POP
// if p then
57727: LD_VAR 0 11
57731: IFFALSE 57756
// result := Replace ( result , 3 , p ) ;
57733: LD_ADDR_VAR 0 2
57737: PUSH
57738: LD_VAR 0 2
57742: PPUSH
57743: LD_INT 3
57745: PPUSH
57746: LD_VAR 0 11
57750: PPUSH
57751: CALL_OW 1
57755: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
57756: LD_ADDR_VAR 0 4
57760: PUSH
57761: LD_VAR 0 4
57765: PUSH
57766: LD_VAR 0 6
57770: DIFF
57771: ST_TO_ADDR
// if tmp and eng < 6 then
57772: LD_VAR 0 4
57776: PUSH
57777: LD_VAR 0 6
57781: PUSH
57782: LD_INT 6
57784: LESS
57785: AND
57786: IFFALSE 57980
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57788: LD_ADDR_VAR 0 9
57792: PUSH
57793: LD_VAR 0 4
57797: PUSH
57798: LD_VAR 0 8
57802: PUSH
57803: LD_VAR 0 7
57807: UNION
57808: PUSH
57809: LD_VAR 0 6
57813: UNION
57814: DIFF
57815: PPUSH
57816: LD_INT 2
57818: PPUSH
57819: CALL 48787 0 2
57823: ST_TO_ADDR
// p := [ ] ;
57824: LD_ADDR_VAR 0 11
57828: PUSH
57829: EMPTY
57830: ST_TO_ADDR
// if sort then
57831: LD_VAR 0 9
57835: IFFALSE 57951
// for i = 1 to 6 - eng do
57837: LD_ADDR_VAR 0 3
57841: PUSH
57842: DOUBLE
57843: LD_INT 1
57845: DEC
57846: ST_TO_ADDR
57847: LD_INT 6
57849: PUSH
57850: LD_VAR 0 6
57854: MINUS
57855: PUSH
57856: FOR_TO
57857: IFFALSE 57949
// begin if i = sort then
57859: LD_VAR 0 3
57863: PUSH
57864: LD_VAR 0 9
57868: EQUAL
57869: IFFALSE 57873
// break ;
57871: GO 57949
// if GetClass ( i ) = 2 then
57873: LD_VAR 0 3
57877: PPUSH
57878: CALL_OW 257
57882: PUSH
57883: LD_INT 2
57885: EQUAL
57886: IFFALSE 57890
// continue ;
57888: GO 57856
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57890: LD_ADDR_VAR 0 11
57894: PUSH
57895: LD_VAR 0 11
57899: PPUSH
57900: LD_VAR 0 11
57904: PUSH
57905: LD_INT 1
57907: PLUS
57908: PPUSH
57909: LD_VAR 0 9
57913: PUSH
57914: LD_VAR 0 3
57918: ARRAY
57919: PPUSH
57920: CALL_OW 2
57924: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57925: LD_ADDR_VAR 0 4
57929: PUSH
57930: LD_VAR 0 4
57934: PUSH
57935: LD_VAR 0 9
57939: PUSH
57940: LD_VAR 0 3
57944: ARRAY
57945: DIFF
57946: ST_TO_ADDR
// end ;
57947: GO 57856
57949: POP
57950: POP
// if p then
57951: LD_VAR 0 11
57955: IFFALSE 57980
// result := Replace ( result , 2 , p ) ;
57957: LD_ADDR_VAR 0 2
57961: PUSH
57962: LD_VAR 0 2
57966: PPUSH
57967: LD_INT 2
57969: PPUSH
57970: LD_VAR 0 11
57974: PPUSH
57975: CALL_OW 1
57979: ST_TO_ADDR
// end ; exit ;
57980: GO 58704
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
57982: LD_EXP 86
57986: PUSH
57987: LD_EXP 85
57991: PUSH
57992: LD_VAR 0 1
57996: ARRAY
57997: ARRAY
57998: NOT
57999: PUSH
58000: LD_EXP 59
58004: PUSH
58005: LD_VAR 0 1
58009: ARRAY
58010: PPUSH
58011: LD_INT 30
58013: PUSH
58014: LD_INT 3
58016: PUSH
58017: EMPTY
58018: LIST
58019: LIST
58020: PPUSH
58021: CALL_OW 72
58025: AND
58026: PUSH
58027: LD_EXP 64
58031: PUSH
58032: LD_VAR 0 1
58036: ARRAY
58037: NOT
58038: AND
58039: IFFALSE 58704
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58041: LD_ADDR_EXP 101
58045: PUSH
58046: LD_EXP 101
58050: PPUSH
58051: LD_VAR 0 1
58055: PPUSH
58056: LD_INT 6
58058: PPUSH
58059: CALL_OW 1
58063: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58064: LD_ADDR_VAR 0 2
58068: PUSH
58069: LD_INT 0
58071: PUSH
58072: LD_INT 0
58074: PUSH
58075: LD_INT 0
58077: PUSH
58078: LD_INT 0
58080: PUSH
58081: EMPTY
58082: LIST
58083: LIST
58084: LIST
58085: LIST
58086: ST_TO_ADDR
// if sci >= 1 then
58087: LD_VAR 0 8
58091: PUSH
58092: LD_INT 1
58094: GREATEREQUAL
58095: IFFALSE 58117
// tmp := tmp diff sci [ 1 ] ;
58097: LD_ADDR_VAR 0 4
58101: PUSH
58102: LD_VAR 0 4
58106: PUSH
58107: LD_VAR 0 8
58111: PUSH
58112: LD_INT 1
58114: ARRAY
58115: DIFF
58116: ST_TO_ADDR
// if tmp and not sci then
58117: LD_VAR 0 4
58121: PUSH
58122: LD_VAR 0 8
58126: NOT
58127: AND
58128: IFFALSE 58197
// begin sort := SortBySkill ( tmp , 4 ) ;
58130: LD_ADDR_VAR 0 9
58134: PUSH
58135: LD_VAR 0 4
58139: PPUSH
58140: LD_INT 4
58142: PPUSH
58143: CALL 48787 0 2
58147: ST_TO_ADDR
// if sort then
58148: LD_VAR 0 9
58152: IFFALSE 58168
// p := sort [ 1 ] ;
58154: LD_ADDR_VAR 0 11
58158: PUSH
58159: LD_VAR 0 9
58163: PUSH
58164: LD_INT 1
58166: ARRAY
58167: ST_TO_ADDR
// if p then
58168: LD_VAR 0 11
58172: IFFALSE 58197
// result := Replace ( result , 4 , p ) ;
58174: LD_ADDR_VAR 0 2
58178: PUSH
58179: LD_VAR 0 2
58183: PPUSH
58184: LD_INT 4
58186: PPUSH
58187: LD_VAR 0 11
58191: PPUSH
58192: CALL_OW 1
58196: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58197: LD_ADDR_VAR 0 4
58201: PUSH
58202: LD_VAR 0 4
58206: PUSH
58207: LD_VAR 0 7
58211: DIFF
58212: ST_TO_ADDR
// if tmp and mech < 6 then
58213: LD_VAR 0 4
58217: PUSH
58218: LD_VAR 0 7
58222: PUSH
58223: LD_INT 6
58225: LESS
58226: AND
58227: IFFALSE 58409
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
58229: LD_ADDR_VAR 0 9
58233: PUSH
58234: LD_VAR 0 4
58238: PUSH
58239: LD_VAR 0 7
58243: DIFF
58244: PPUSH
58245: LD_INT 3
58247: PPUSH
58248: CALL 48787 0 2
58252: ST_TO_ADDR
// p := [ ] ;
58253: LD_ADDR_VAR 0 11
58257: PUSH
58258: EMPTY
58259: ST_TO_ADDR
// if sort then
58260: LD_VAR 0 9
58264: IFFALSE 58380
// for i = 1 to 6 - mech do
58266: LD_ADDR_VAR 0 3
58270: PUSH
58271: DOUBLE
58272: LD_INT 1
58274: DEC
58275: ST_TO_ADDR
58276: LD_INT 6
58278: PUSH
58279: LD_VAR 0 7
58283: MINUS
58284: PUSH
58285: FOR_TO
58286: IFFALSE 58378
// begin if i = sort then
58288: LD_VAR 0 3
58292: PUSH
58293: LD_VAR 0 9
58297: EQUAL
58298: IFFALSE 58302
// break ;
58300: GO 58378
// if GetClass ( i ) = 3 then
58302: LD_VAR 0 3
58306: PPUSH
58307: CALL_OW 257
58311: PUSH
58312: LD_INT 3
58314: EQUAL
58315: IFFALSE 58319
// continue ;
58317: GO 58285
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58319: LD_ADDR_VAR 0 11
58323: PUSH
58324: LD_VAR 0 11
58328: PPUSH
58329: LD_VAR 0 11
58333: PUSH
58334: LD_INT 1
58336: PLUS
58337: PPUSH
58338: LD_VAR 0 9
58342: PUSH
58343: LD_VAR 0 3
58347: ARRAY
58348: PPUSH
58349: CALL_OW 2
58353: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58354: LD_ADDR_VAR 0 4
58358: PUSH
58359: LD_VAR 0 4
58363: PUSH
58364: LD_VAR 0 9
58368: PUSH
58369: LD_VAR 0 3
58373: ARRAY
58374: DIFF
58375: ST_TO_ADDR
// end ;
58376: GO 58285
58378: POP
58379: POP
// if p then
58380: LD_VAR 0 11
58384: IFFALSE 58409
// result := Replace ( result , 3 , p ) ;
58386: LD_ADDR_VAR 0 2
58390: PUSH
58391: LD_VAR 0 2
58395: PPUSH
58396: LD_INT 3
58398: PPUSH
58399: LD_VAR 0 11
58403: PPUSH
58404: CALL_OW 1
58408: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58409: LD_ADDR_VAR 0 4
58413: PUSH
58414: LD_VAR 0 4
58418: PUSH
58419: LD_VAR 0 6
58423: DIFF
58424: ST_TO_ADDR
// if tmp and eng < 4 then
58425: LD_VAR 0 4
58429: PUSH
58430: LD_VAR 0 6
58434: PUSH
58435: LD_INT 4
58437: LESS
58438: AND
58439: IFFALSE 58629
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
58441: LD_ADDR_VAR 0 9
58445: PUSH
58446: LD_VAR 0 4
58450: PUSH
58451: LD_VAR 0 7
58455: PUSH
58456: LD_VAR 0 6
58460: UNION
58461: DIFF
58462: PPUSH
58463: LD_INT 2
58465: PPUSH
58466: CALL 48787 0 2
58470: ST_TO_ADDR
// p := [ ] ;
58471: LD_ADDR_VAR 0 11
58475: PUSH
58476: EMPTY
58477: ST_TO_ADDR
// if sort then
58478: LD_VAR 0 9
58482: IFFALSE 58598
// for i = 1 to 4 - eng do
58484: LD_ADDR_VAR 0 3
58488: PUSH
58489: DOUBLE
58490: LD_INT 1
58492: DEC
58493: ST_TO_ADDR
58494: LD_INT 4
58496: PUSH
58497: LD_VAR 0 6
58501: MINUS
58502: PUSH
58503: FOR_TO
58504: IFFALSE 58596
// begin if i = sort then
58506: LD_VAR 0 3
58510: PUSH
58511: LD_VAR 0 9
58515: EQUAL
58516: IFFALSE 58520
// break ;
58518: GO 58596
// if GetClass ( i ) = 2 then
58520: LD_VAR 0 3
58524: PPUSH
58525: CALL_OW 257
58529: PUSH
58530: LD_INT 2
58532: EQUAL
58533: IFFALSE 58537
// continue ;
58535: GO 58503
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58537: LD_ADDR_VAR 0 11
58541: PUSH
58542: LD_VAR 0 11
58546: PPUSH
58547: LD_VAR 0 11
58551: PUSH
58552: LD_INT 1
58554: PLUS
58555: PPUSH
58556: LD_VAR 0 9
58560: PUSH
58561: LD_VAR 0 3
58565: ARRAY
58566: PPUSH
58567: CALL_OW 2
58571: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58572: LD_ADDR_VAR 0 4
58576: PUSH
58577: LD_VAR 0 4
58581: PUSH
58582: LD_VAR 0 9
58586: PUSH
58587: LD_VAR 0 3
58591: ARRAY
58592: DIFF
58593: ST_TO_ADDR
// end ;
58594: GO 58503
58596: POP
58597: POP
// if p then
58598: LD_VAR 0 11
58602: IFFALSE 58627
// result := Replace ( result , 2 , p ) ;
58604: LD_ADDR_VAR 0 2
58608: PUSH
58609: LD_VAR 0 2
58613: PPUSH
58614: LD_INT 2
58616: PPUSH
58617: LD_VAR 0 11
58621: PPUSH
58622: CALL_OW 1
58626: ST_TO_ADDR
// end else
58627: GO 58673
// for i = eng downto 5 do
58629: LD_ADDR_VAR 0 3
58633: PUSH
58634: DOUBLE
58635: LD_VAR 0 6
58639: INC
58640: ST_TO_ADDR
58641: LD_INT 5
58643: PUSH
58644: FOR_DOWNTO
58645: IFFALSE 58671
// tmp := tmp union eng [ i ] ;
58647: LD_ADDR_VAR 0 4
58651: PUSH
58652: LD_VAR 0 4
58656: PUSH
58657: LD_VAR 0 6
58661: PUSH
58662: LD_VAR 0 3
58666: ARRAY
58667: UNION
58668: ST_TO_ADDR
58669: GO 58644
58671: POP
58672: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
58673: LD_ADDR_VAR 0 2
58677: PUSH
58678: LD_VAR 0 2
58682: PPUSH
58683: LD_INT 1
58685: PPUSH
58686: LD_VAR 0 4
58690: PUSH
58691: LD_VAR 0 5
58695: DIFF
58696: PPUSH
58697: CALL_OW 1
58701: ST_TO_ADDR
// exit ;
58702: GO 58704
// end ; end ;
58704: LD_VAR 0 2
58708: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
58709: LD_INT 0
58711: PPUSH
58712: PPUSH
58713: PPUSH
// if not mc_bases then
58714: LD_EXP 59
58718: NOT
58719: IFFALSE 58723
// exit ;
58721: GO 58829
// for i = 1 to mc_bases do
58723: LD_ADDR_VAR 0 2
58727: PUSH
58728: DOUBLE
58729: LD_INT 1
58731: DEC
58732: ST_TO_ADDR
58733: LD_EXP 59
58737: PUSH
58738: FOR_TO
58739: IFFALSE 58820
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58741: LD_ADDR_VAR 0 3
58745: PUSH
58746: LD_EXP 59
58750: PUSH
58751: LD_VAR 0 2
58755: ARRAY
58756: PPUSH
58757: LD_INT 21
58759: PUSH
58760: LD_INT 3
58762: PUSH
58763: EMPTY
58764: LIST
58765: LIST
58766: PUSH
58767: LD_INT 3
58769: PUSH
58770: LD_INT 24
58772: PUSH
58773: LD_INT 1000
58775: PUSH
58776: EMPTY
58777: LIST
58778: LIST
58779: PUSH
58780: EMPTY
58781: LIST
58782: LIST
58783: PUSH
58784: EMPTY
58785: LIST
58786: LIST
58787: PPUSH
58788: CALL_OW 72
58792: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
58793: LD_ADDR_EXP 60
58797: PUSH
58798: LD_EXP 60
58802: PPUSH
58803: LD_VAR 0 2
58807: PPUSH
58808: LD_VAR 0 3
58812: PPUSH
58813: CALL_OW 1
58817: ST_TO_ADDR
// end ;
58818: GO 58738
58820: POP
58821: POP
// RaiseSailEvent ( 101 ) ;
58822: LD_INT 101
58824: PPUSH
58825: CALL_OW 427
// end ;
58829: LD_VAR 0 1
58833: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
58834: LD_INT 0
58836: PPUSH
58837: PPUSH
58838: PPUSH
58839: PPUSH
58840: PPUSH
58841: PPUSH
58842: PPUSH
// if not mc_bases then
58843: LD_EXP 59
58847: NOT
58848: IFFALSE 58852
// exit ;
58850: GO 59425
// for i = 1 to mc_bases do
58852: LD_ADDR_VAR 0 2
58856: PUSH
58857: DOUBLE
58858: LD_INT 1
58860: DEC
58861: ST_TO_ADDR
58862: LD_EXP 59
58866: PUSH
58867: FOR_TO
58868: IFFALSE 59416
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
58870: LD_ADDR_VAR 0 5
58874: PUSH
58875: LD_EXP 59
58879: PUSH
58880: LD_VAR 0 2
58884: ARRAY
58885: PUSH
58886: LD_EXP 88
58890: PUSH
58891: LD_VAR 0 2
58895: ARRAY
58896: UNION
58897: PPUSH
58898: LD_INT 21
58900: PUSH
58901: LD_INT 1
58903: PUSH
58904: EMPTY
58905: LIST
58906: LIST
58907: PUSH
58908: LD_INT 1
58910: PUSH
58911: LD_INT 3
58913: PUSH
58914: LD_INT 54
58916: PUSH
58917: EMPTY
58918: LIST
58919: PUSH
58920: EMPTY
58921: LIST
58922: LIST
58923: PUSH
58924: LD_INT 3
58926: PUSH
58927: LD_INT 24
58929: PUSH
58930: LD_INT 800
58932: PUSH
58933: EMPTY
58934: LIST
58935: LIST
58936: PUSH
58937: EMPTY
58938: LIST
58939: LIST
58940: PUSH
58941: EMPTY
58942: LIST
58943: LIST
58944: LIST
58945: PUSH
58946: EMPTY
58947: LIST
58948: LIST
58949: PPUSH
58950: CALL_OW 72
58954: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
58955: LD_ADDR_VAR 0 6
58959: PUSH
58960: LD_EXP 59
58964: PUSH
58965: LD_VAR 0 2
58969: ARRAY
58970: PPUSH
58971: LD_INT 21
58973: PUSH
58974: LD_INT 1
58976: PUSH
58977: EMPTY
58978: LIST
58979: LIST
58980: PUSH
58981: LD_INT 1
58983: PUSH
58984: LD_INT 3
58986: PUSH
58987: LD_INT 54
58989: PUSH
58990: EMPTY
58991: LIST
58992: PUSH
58993: EMPTY
58994: LIST
58995: LIST
58996: PUSH
58997: LD_INT 3
58999: PUSH
59000: LD_INT 24
59002: PUSH
59003: LD_INT 250
59005: PUSH
59006: EMPTY
59007: LIST
59008: LIST
59009: PUSH
59010: EMPTY
59011: LIST
59012: LIST
59013: PUSH
59014: EMPTY
59015: LIST
59016: LIST
59017: LIST
59018: PUSH
59019: EMPTY
59020: LIST
59021: LIST
59022: PPUSH
59023: CALL_OW 72
59027: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59028: LD_ADDR_VAR 0 7
59032: PUSH
59033: LD_VAR 0 5
59037: PUSH
59038: LD_VAR 0 6
59042: DIFF
59043: ST_TO_ADDR
// if not need_heal_1 then
59044: LD_VAR 0 6
59048: NOT
59049: IFFALSE 59082
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59051: LD_ADDR_EXP 62
59055: PUSH
59056: LD_EXP 62
59060: PPUSH
59061: LD_VAR 0 2
59065: PUSH
59066: LD_INT 1
59068: PUSH
59069: EMPTY
59070: LIST
59071: LIST
59072: PPUSH
59073: EMPTY
59074: PPUSH
59075: CALL 19238 0 3
59079: ST_TO_ADDR
59080: GO 59152
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
59082: LD_ADDR_EXP 62
59086: PUSH
59087: LD_EXP 62
59091: PPUSH
59092: LD_VAR 0 2
59096: PUSH
59097: LD_INT 1
59099: PUSH
59100: EMPTY
59101: LIST
59102: LIST
59103: PPUSH
59104: LD_EXP 62
59108: PUSH
59109: LD_VAR 0 2
59113: ARRAY
59114: PUSH
59115: LD_INT 1
59117: ARRAY
59118: PPUSH
59119: LD_INT 3
59121: PUSH
59122: LD_INT 24
59124: PUSH
59125: LD_INT 1000
59127: PUSH
59128: EMPTY
59129: LIST
59130: LIST
59131: PUSH
59132: EMPTY
59133: LIST
59134: LIST
59135: PPUSH
59136: CALL_OW 72
59140: PUSH
59141: LD_VAR 0 6
59145: UNION
59146: PPUSH
59147: CALL 19238 0 3
59151: ST_TO_ADDR
// if not need_heal_2 then
59152: LD_VAR 0 7
59156: NOT
59157: IFFALSE 59190
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
59159: LD_ADDR_EXP 62
59163: PUSH
59164: LD_EXP 62
59168: PPUSH
59169: LD_VAR 0 2
59173: PUSH
59174: LD_INT 2
59176: PUSH
59177: EMPTY
59178: LIST
59179: LIST
59180: PPUSH
59181: EMPTY
59182: PPUSH
59183: CALL 19238 0 3
59187: ST_TO_ADDR
59188: GO 59222
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
59190: LD_ADDR_EXP 62
59194: PUSH
59195: LD_EXP 62
59199: PPUSH
59200: LD_VAR 0 2
59204: PUSH
59205: LD_INT 2
59207: PUSH
59208: EMPTY
59209: LIST
59210: LIST
59211: PPUSH
59212: LD_VAR 0 7
59216: PPUSH
59217: CALL 19238 0 3
59221: ST_TO_ADDR
// if need_heal_2 then
59222: LD_VAR 0 7
59226: IFFALSE 59398
// for j in need_heal_2 do
59228: LD_ADDR_VAR 0 3
59232: PUSH
59233: LD_VAR 0 7
59237: PUSH
59238: FOR_IN
59239: IFFALSE 59396
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
59241: LD_ADDR_VAR 0 5
59245: PUSH
59246: LD_EXP 59
59250: PUSH
59251: LD_VAR 0 2
59255: ARRAY
59256: PPUSH
59257: LD_INT 2
59259: PUSH
59260: LD_INT 30
59262: PUSH
59263: LD_INT 6
59265: PUSH
59266: EMPTY
59267: LIST
59268: LIST
59269: PUSH
59270: LD_INT 30
59272: PUSH
59273: LD_INT 7
59275: PUSH
59276: EMPTY
59277: LIST
59278: LIST
59279: PUSH
59280: LD_INT 30
59282: PUSH
59283: LD_INT 8
59285: PUSH
59286: EMPTY
59287: LIST
59288: LIST
59289: PUSH
59290: LD_INT 30
59292: PUSH
59293: LD_INT 0
59295: PUSH
59296: EMPTY
59297: LIST
59298: LIST
59299: PUSH
59300: LD_INT 30
59302: PUSH
59303: LD_INT 1
59305: PUSH
59306: EMPTY
59307: LIST
59308: LIST
59309: PUSH
59310: LD_INT 25
59312: PUSH
59313: LD_INT 4
59315: PUSH
59316: EMPTY
59317: LIST
59318: LIST
59319: PUSH
59320: EMPTY
59321: LIST
59322: LIST
59323: LIST
59324: LIST
59325: LIST
59326: LIST
59327: LIST
59328: PPUSH
59329: CALL_OW 72
59333: ST_TO_ADDR
// if tmp then
59334: LD_VAR 0 5
59338: IFFALSE 59394
// begin k := NearestUnitToUnit ( tmp , j ) ;
59340: LD_ADDR_VAR 0 4
59344: PUSH
59345: LD_VAR 0 5
59349: PPUSH
59350: LD_VAR 0 3
59354: PPUSH
59355: CALL_OW 74
59359: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
59360: LD_VAR 0 3
59364: PPUSH
59365: LD_VAR 0 4
59369: PPUSH
59370: CALL_OW 296
59374: PUSH
59375: LD_INT 7
59377: GREATER
59378: IFFALSE 59394
// ComMoveUnit ( j , k ) ;
59380: LD_VAR 0 3
59384: PPUSH
59385: LD_VAR 0 4
59389: PPUSH
59390: CALL_OW 112
// end ; end ;
59394: GO 59238
59396: POP
59397: POP
// if not need_heal_1 and not need_heal_2 then
59398: LD_VAR 0 6
59402: NOT
59403: PUSH
59404: LD_VAR 0 7
59408: NOT
59409: AND
59410: IFFALSE 59414
// continue ;
59412: GO 58867
// end ;
59414: GO 58867
59416: POP
59417: POP
// RaiseSailEvent ( 102 ) ;
59418: LD_INT 102
59420: PPUSH
59421: CALL_OW 427
// end ;
59425: LD_VAR 0 1
59429: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
59430: LD_INT 0
59432: PPUSH
59433: PPUSH
59434: PPUSH
59435: PPUSH
59436: PPUSH
59437: PPUSH
59438: PPUSH
59439: PPUSH
// if not mc_bases then
59440: LD_EXP 59
59444: NOT
59445: IFFALSE 59449
// exit ;
59447: GO 60289
// for i = 1 to mc_bases do
59449: LD_ADDR_VAR 0 2
59453: PUSH
59454: DOUBLE
59455: LD_INT 1
59457: DEC
59458: ST_TO_ADDR
59459: LD_EXP 59
59463: PUSH
59464: FOR_TO
59465: IFFALSE 60287
// begin if not mc_building_need_repair [ i ] then
59467: LD_EXP 60
59471: PUSH
59472: LD_VAR 0 2
59476: ARRAY
59477: NOT
59478: IFFALSE 59652
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
59480: LD_ADDR_VAR 0 6
59484: PUSH
59485: LD_EXP 78
59489: PUSH
59490: LD_VAR 0 2
59494: ARRAY
59495: PPUSH
59496: LD_INT 3
59498: PUSH
59499: LD_INT 24
59501: PUSH
59502: LD_INT 1000
59504: PUSH
59505: EMPTY
59506: LIST
59507: LIST
59508: PUSH
59509: EMPTY
59510: LIST
59511: LIST
59512: PUSH
59513: LD_INT 2
59515: PUSH
59516: LD_INT 34
59518: PUSH
59519: LD_INT 13
59521: PUSH
59522: EMPTY
59523: LIST
59524: LIST
59525: PUSH
59526: LD_INT 34
59528: PUSH
59529: LD_INT 52
59531: PUSH
59532: EMPTY
59533: LIST
59534: LIST
59535: PUSH
59536: EMPTY
59537: LIST
59538: LIST
59539: LIST
59540: PUSH
59541: EMPTY
59542: LIST
59543: LIST
59544: PPUSH
59545: CALL_OW 72
59549: ST_TO_ADDR
// if cranes then
59550: LD_VAR 0 6
59554: IFFALSE 59616
// for j in cranes do
59556: LD_ADDR_VAR 0 3
59560: PUSH
59561: LD_VAR 0 6
59565: PUSH
59566: FOR_IN
59567: IFFALSE 59614
// if not IsInArea ( j , mc_parking [ i ] ) then
59569: LD_VAR 0 3
59573: PPUSH
59574: LD_EXP 83
59578: PUSH
59579: LD_VAR 0 2
59583: ARRAY
59584: PPUSH
59585: CALL_OW 308
59589: NOT
59590: IFFALSE 59612
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59592: LD_VAR 0 3
59596: PPUSH
59597: LD_EXP 83
59601: PUSH
59602: LD_VAR 0 2
59606: ARRAY
59607: PPUSH
59608: CALL_OW 113
59612: GO 59566
59614: POP
59615: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59616: LD_ADDR_EXP 61
59620: PUSH
59621: LD_EXP 61
59625: PPUSH
59626: LD_VAR 0 2
59630: PPUSH
59631: EMPTY
59632: PPUSH
59633: CALL_OW 1
59637: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
59638: LD_VAR 0 2
59642: PPUSH
59643: LD_INT 101
59645: PPUSH
59646: CALL 54542 0 2
// continue ;
59650: GO 59464
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
59652: LD_ADDR_EXP 65
59656: PUSH
59657: LD_EXP 65
59661: PPUSH
59662: LD_VAR 0 2
59666: PPUSH
59667: EMPTY
59668: PPUSH
59669: CALL_OW 1
59673: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
59674: LD_VAR 0 2
59678: PPUSH
59679: LD_INT 103
59681: PPUSH
59682: CALL 54542 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
59686: LD_ADDR_VAR 0 5
59690: PUSH
59691: LD_EXP 59
59695: PUSH
59696: LD_VAR 0 2
59700: ARRAY
59701: PUSH
59702: LD_EXP 88
59706: PUSH
59707: LD_VAR 0 2
59711: ARRAY
59712: UNION
59713: PPUSH
59714: LD_INT 2
59716: PUSH
59717: LD_INT 25
59719: PUSH
59720: LD_INT 2
59722: PUSH
59723: EMPTY
59724: LIST
59725: LIST
59726: PUSH
59727: LD_INT 25
59729: PUSH
59730: LD_INT 16
59732: PUSH
59733: EMPTY
59734: LIST
59735: LIST
59736: PUSH
59737: EMPTY
59738: LIST
59739: LIST
59740: LIST
59741: PUSH
59742: EMPTY
59743: LIST
59744: PPUSH
59745: CALL_OW 72
59749: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
59750: LD_ADDR_VAR 0 6
59754: PUSH
59755: LD_EXP 78
59759: PUSH
59760: LD_VAR 0 2
59764: ARRAY
59765: PPUSH
59766: LD_INT 2
59768: PUSH
59769: LD_INT 34
59771: PUSH
59772: LD_INT 13
59774: PUSH
59775: EMPTY
59776: LIST
59777: LIST
59778: PUSH
59779: LD_INT 34
59781: PUSH
59782: LD_INT 52
59784: PUSH
59785: EMPTY
59786: LIST
59787: LIST
59788: PUSH
59789: EMPTY
59790: LIST
59791: LIST
59792: LIST
59793: PPUSH
59794: CALL_OW 72
59798: ST_TO_ADDR
// if cranes then
59799: LD_VAR 0 6
59803: IFFALSE 59939
// begin for j in cranes do
59805: LD_ADDR_VAR 0 3
59809: PUSH
59810: LD_VAR 0 6
59814: PUSH
59815: FOR_IN
59816: IFFALSE 59937
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
59818: LD_VAR 0 3
59822: PPUSH
59823: CALL_OW 256
59827: PUSH
59828: LD_INT 500
59830: GREATEREQUAL
59831: PUSH
59832: LD_VAR 0 3
59836: PPUSH
59837: CALL_OW 314
59841: NOT
59842: AND
59843: IFFALSE 59877
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
59845: LD_VAR 0 3
59849: PPUSH
59850: LD_EXP 60
59854: PUSH
59855: LD_VAR 0 2
59859: ARRAY
59860: PPUSH
59861: LD_VAR 0 3
59865: PPUSH
59866: CALL_OW 74
59870: PPUSH
59871: CALL_OW 130
59875: GO 59935
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
59877: LD_VAR 0 3
59881: PPUSH
59882: CALL_OW 256
59886: PUSH
59887: LD_INT 500
59889: LESS
59890: PUSH
59891: LD_VAR 0 3
59895: PPUSH
59896: LD_EXP 83
59900: PUSH
59901: LD_VAR 0 2
59905: ARRAY
59906: PPUSH
59907: CALL_OW 308
59911: NOT
59912: AND
59913: IFFALSE 59935
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59915: LD_VAR 0 3
59919: PPUSH
59920: LD_EXP 83
59924: PUSH
59925: LD_VAR 0 2
59929: ARRAY
59930: PPUSH
59931: CALL_OW 113
59935: GO 59815
59937: POP
59938: POP
// end ; if not tmp then
59939: LD_VAR 0 5
59943: NOT
59944: IFFALSE 59948
// continue ;
59946: GO 59464
// for j in tmp do
59948: LD_ADDR_VAR 0 3
59952: PUSH
59953: LD_VAR 0 5
59957: PUSH
59958: FOR_IN
59959: IFFALSE 60283
// begin if mc_need_heal [ i ] then
59961: LD_EXP 62
59965: PUSH
59966: LD_VAR 0 2
59970: ARRAY
59971: IFFALSE 60019
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
59973: LD_VAR 0 3
59977: PUSH
59978: LD_EXP 62
59982: PUSH
59983: LD_VAR 0 2
59987: ARRAY
59988: PUSH
59989: LD_INT 1
59991: ARRAY
59992: IN
59993: PUSH
59994: LD_VAR 0 3
59998: PUSH
59999: LD_EXP 62
60003: PUSH
60004: LD_VAR 0 2
60008: ARRAY
60009: PUSH
60010: LD_INT 2
60012: ARRAY
60013: IN
60014: OR
60015: IFFALSE 60019
// continue ;
60017: GO 59958
// if IsInUnit ( j ) then
60019: LD_VAR 0 3
60023: PPUSH
60024: CALL_OW 310
60028: IFFALSE 60039
// ComExitBuilding ( j ) ;
60030: LD_VAR 0 3
60034: PPUSH
60035: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
60039: LD_VAR 0 3
60043: PUSH
60044: LD_EXP 61
60048: PUSH
60049: LD_VAR 0 2
60053: ARRAY
60054: IN
60055: NOT
60056: IFFALSE 60114
// begin SetTag ( j , 101 ) ;
60058: LD_VAR 0 3
60062: PPUSH
60063: LD_INT 101
60065: PPUSH
60066: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
60070: LD_ADDR_EXP 61
60074: PUSH
60075: LD_EXP 61
60079: PPUSH
60080: LD_VAR 0 2
60084: PUSH
60085: LD_EXP 61
60089: PUSH
60090: LD_VAR 0 2
60094: ARRAY
60095: PUSH
60096: LD_INT 1
60098: PLUS
60099: PUSH
60100: EMPTY
60101: LIST
60102: LIST
60103: PPUSH
60104: LD_VAR 0 3
60108: PPUSH
60109: CALL 19238 0 3
60113: ST_TO_ADDR
// end ; wait ( 1 ) ;
60114: LD_INT 1
60116: PPUSH
60117: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
60121: LD_ADDR_VAR 0 7
60125: PUSH
60126: LD_EXP 60
60130: PUSH
60131: LD_VAR 0 2
60135: ARRAY
60136: ST_TO_ADDR
// if mc_scan [ i ] then
60137: LD_EXP 82
60141: PUSH
60142: LD_VAR 0 2
60146: ARRAY
60147: IFFALSE 60216
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
60149: LD_ADDR_VAR 0 7
60153: PUSH
60154: LD_EXP 60
60158: PUSH
60159: LD_VAR 0 2
60163: ARRAY
60164: PPUSH
60165: LD_INT 3
60167: PUSH
60168: LD_INT 2
60170: PUSH
60171: LD_INT 30
60173: PUSH
60174: LD_INT 32
60176: PUSH
60177: EMPTY
60178: LIST
60179: LIST
60180: PUSH
60181: LD_INT 30
60183: PUSH
60184: LD_INT 33
60186: PUSH
60187: EMPTY
60188: LIST
60189: LIST
60190: PUSH
60191: LD_INT 30
60193: PUSH
60194: LD_INT 31
60196: PUSH
60197: EMPTY
60198: LIST
60199: LIST
60200: PUSH
60201: EMPTY
60202: LIST
60203: LIST
60204: LIST
60205: LIST
60206: PUSH
60207: EMPTY
60208: LIST
60209: LIST
60210: PPUSH
60211: CALL_OW 72
60215: ST_TO_ADDR
// if not to_repair_tmp then
60216: LD_VAR 0 7
60220: NOT
60221: IFFALSE 60225
// continue ;
60223: GO 59958
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
60225: LD_ADDR_VAR 0 8
60229: PUSH
60230: LD_VAR 0 7
60234: PPUSH
60235: LD_VAR 0 3
60239: PPUSH
60240: CALL_OW 74
60244: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
60245: LD_VAR 0 8
60249: PPUSH
60250: LD_INT 14
60252: PPUSH
60253: CALL 21831 0 2
60257: PUSH
60258: LD_INT 4
60260: ARRAY
60261: PUSH
60262: LD_INT 5
60264: LESS
60265: IFFALSE 60281
// ComRepairBuilding ( j , to_repair ) ;
60267: LD_VAR 0 3
60271: PPUSH
60272: LD_VAR 0 8
60276: PPUSH
60277: CALL_OW 130
// end ;
60281: GO 59958
60283: POP
60284: POP
// end ;
60285: GO 59464
60287: POP
60288: POP
// end ;
60289: LD_VAR 0 1
60293: RET
// export function MC_Heal ; var i , j , tmp ; begin
60294: LD_INT 0
60296: PPUSH
60297: PPUSH
60298: PPUSH
60299: PPUSH
// if not mc_bases then
60300: LD_EXP 59
60304: NOT
60305: IFFALSE 60309
// exit ;
60307: GO 60711
// for i = 1 to mc_bases do
60309: LD_ADDR_VAR 0 2
60313: PUSH
60314: DOUBLE
60315: LD_INT 1
60317: DEC
60318: ST_TO_ADDR
60319: LD_EXP 59
60323: PUSH
60324: FOR_TO
60325: IFFALSE 60709
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
60327: LD_EXP 62
60331: PUSH
60332: LD_VAR 0 2
60336: ARRAY
60337: PUSH
60338: LD_INT 1
60340: ARRAY
60341: NOT
60342: PUSH
60343: LD_EXP 62
60347: PUSH
60348: LD_VAR 0 2
60352: ARRAY
60353: PUSH
60354: LD_INT 2
60356: ARRAY
60357: NOT
60358: AND
60359: IFFALSE 60397
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
60361: LD_ADDR_EXP 63
60365: PUSH
60366: LD_EXP 63
60370: PPUSH
60371: LD_VAR 0 2
60375: PPUSH
60376: EMPTY
60377: PPUSH
60378: CALL_OW 1
60382: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
60383: LD_VAR 0 2
60387: PPUSH
60388: LD_INT 102
60390: PPUSH
60391: CALL 54542 0 2
// continue ;
60395: GO 60324
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60397: LD_ADDR_VAR 0 4
60401: PUSH
60402: LD_EXP 59
60406: PUSH
60407: LD_VAR 0 2
60411: ARRAY
60412: PPUSH
60413: LD_INT 25
60415: PUSH
60416: LD_INT 4
60418: PUSH
60419: EMPTY
60420: LIST
60421: LIST
60422: PPUSH
60423: CALL_OW 72
60427: ST_TO_ADDR
// if not tmp then
60428: LD_VAR 0 4
60432: NOT
60433: IFFALSE 60437
// continue ;
60435: GO 60324
// if mc_taming [ i ] then
60437: LD_EXP 90
60441: PUSH
60442: LD_VAR 0 2
60446: ARRAY
60447: IFFALSE 60471
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60449: LD_ADDR_EXP 90
60453: PUSH
60454: LD_EXP 90
60458: PPUSH
60459: LD_VAR 0 2
60463: PPUSH
60464: EMPTY
60465: PPUSH
60466: CALL_OW 1
60470: ST_TO_ADDR
// for j in tmp do
60471: LD_ADDR_VAR 0 3
60475: PUSH
60476: LD_VAR 0 4
60480: PUSH
60481: FOR_IN
60482: IFFALSE 60705
// begin if IsInUnit ( j ) then
60484: LD_VAR 0 3
60488: PPUSH
60489: CALL_OW 310
60493: IFFALSE 60504
// ComExitBuilding ( j ) ;
60495: LD_VAR 0 3
60499: PPUSH
60500: CALL_OW 122
// if not j in mc_healers [ i ] then
60504: LD_VAR 0 3
60508: PUSH
60509: LD_EXP 63
60513: PUSH
60514: LD_VAR 0 2
60518: ARRAY
60519: IN
60520: NOT
60521: IFFALSE 60567
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
60523: LD_ADDR_EXP 63
60527: PUSH
60528: LD_EXP 63
60532: PPUSH
60533: LD_VAR 0 2
60537: PUSH
60538: LD_EXP 63
60542: PUSH
60543: LD_VAR 0 2
60547: ARRAY
60548: PUSH
60549: LD_INT 1
60551: PLUS
60552: PUSH
60553: EMPTY
60554: LIST
60555: LIST
60556: PPUSH
60557: LD_VAR 0 3
60561: PPUSH
60562: CALL 19238 0 3
60566: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
60567: LD_VAR 0 3
60571: PPUSH
60572: CALL_OW 110
60576: PUSH
60577: LD_INT 102
60579: NONEQUAL
60580: IFFALSE 60594
// SetTag ( j , 102 ) ;
60582: LD_VAR 0 3
60586: PPUSH
60587: LD_INT 102
60589: PPUSH
60590: CALL_OW 109
// Wait ( 3 ) ;
60594: LD_INT 3
60596: PPUSH
60597: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
60601: LD_EXP 62
60605: PUSH
60606: LD_VAR 0 2
60610: ARRAY
60611: PUSH
60612: LD_INT 1
60614: ARRAY
60615: IFFALSE 60647
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
60617: LD_VAR 0 3
60621: PPUSH
60622: LD_EXP 62
60626: PUSH
60627: LD_VAR 0 2
60631: ARRAY
60632: PUSH
60633: LD_INT 1
60635: ARRAY
60636: PUSH
60637: LD_INT 1
60639: ARRAY
60640: PPUSH
60641: CALL_OW 128
60645: GO 60703
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
60647: LD_VAR 0 3
60651: PPUSH
60652: CALL_OW 314
60656: NOT
60657: PUSH
60658: LD_EXP 62
60662: PUSH
60663: LD_VAR 0 2
60667: ARRAY
60668: PUSH
60669: LD_INT 2
60671: ARRAY
60672: AND
60673: IFFALSE 60703
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
60675: LD_VAR 0 3
60679: PPUSH
60680: LD_EXP 62
60684: PUSH
60685: LD_VAR 0 2
60689: ARRAY
60690: PUSH
60691: LD_INT 2
60693: ARRAY
60694: PUSH
60695: LD_INT 1
60697: ARRAY
60698: PPUSH
60699: CALL_OW 128
// end ;
60703: GO 60481
60705: POP
60706: POP
// end ;
60707: GO 60324
60709: POP
60710: POP
// end ;
60711: LD_VAR 0 1
60715: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
60716: LD_INT 0
60718: PPUSH
60719: PPUSH
60720: PPUSH
60721: PPUSH
60722: PPUSH
// if not mc_bases then
60723: LD_EXP 59
60727: NOT
60728: IFFALSE 60732
// exit ;
60730: GO 61875
// for i = 1 to mc_bases do
60732: LD_ADDR_VAR 0 2
60736: PUSH
60737: DOUBLE
60738: LD_INT 1
60740: DEC
60741: ST_TO_ADDR
60742: LD_EXP 59
60746: PUSH
60747: FOR_TO
60748: IFFALSE 61873
// begin if mc_scan [ i ] then
60750: LD_EXP 82
60754: PUSH
60755: LD_VAR 0 2
60759: ARRAY
60760: IFFALSE 60764
// continue ;
60762: GO 60747
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
60764: LD_EXP 64
60768: PUSH
60769: LD_VAR 0 2
60773: ARRAY
60774: NOT
60775: PUSH
60776: LD_EXP 66
60780: PUSH
60781: LD_VAR 0 2
60785: ARRAY
60786: NOT
60787: AND
60788: PUSH
60789: LD_EXP 65
60793: PUSH
60794: LD_VAR 0 2
60798: ARRAY
60799: AND
60800: IFFALSE 60838
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
60802: LD_ADDR_EXP 65
60806: PUSH
60807: LD_EXP 65
60811: PPUSH
60812: LD_VAR 0 2
60816: PPUSH
60817: EMPTY
60818: PPUSH
60819: CALL_OW 1
60823: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60824: LD_VAR 0 2
60828: PPUSH
60829: LD_INT 103
60831: PPUSH
60832: CALL 54542 0 2
// continue ;
60836: GO 60747
// end ; if mc_construct_list [ i ] then
60838: LD_EXP 66
60842: PUSH
60843: LD_VAR 0 2
60847: ARRAY
60848: IFFALSE 61068
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
60850: LD_ADDR_VAR 0 4
60854: PUSH
60855: LD_EXP 59
60859: PUSH
60860: LD_VAR 0 2
60864: ARRAY
60865: PPUSH
60866: LD_INT 25
60868: PUSH
60869: LD_INT 2
60871: PUSH
60872: EMPTY
60873: LIST
60874: LIST
60875: PPUSH
60876: CALL_OW 72
60880: PUSH
60881: LD_EXP 61
60885: PUSH
60886: LD_VAR 0 2
60890: ARRAY
60891: DIFF
60892: ST_TO_ADDR
// if not tmp then
60893: LD_VAR 0 4
60897: NOT
60898: IFFALSE 60902
// continue ;
60900: GO 60747
// for j in tmp do
60902: LD_ADDR_VAR 0 3
60906: PUSH
60907: LD_VAR 0 4
60911: PUSH
60912: FOR_IN
60913: IFFALSE 61064
// begin if not mc_builders [ i ] then
60915: LD_EXP 65
60919: PUSH
60920: LD_VAR 0 2
60924: ARRAY
60925: NOT
60926: IFFALSE 60984
// begin SetTag ( j , 103 ) ;
60928: LD_VAR 0 3
60932: PPUSH
60933: LD_INT 103
60935: PPUSH
60936: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
60940: LD_ADDR_EXP 65
60944: PUSH
60945: LD_EXP 65
60949: PPUSH
60950: LD_VAR 0 2
60954: PUSH
60955: LD_EXP 65
60959: PUSH
60960: LD_VAR 0 2
60964: ARRAY
60965: PUSH
60966: LD_INT 1
60968: PLUS
60969: PUSH
60970: EMPTY
60971: LIST
60972: LIST
60973: PPUSH
60974: LD_VAR 0 3
60978: PPUSH
60979: CALL 19238 0 3
60983: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
60984: LD_VAR 0 3
60988: PPUSH
60989: CALL_OW 310
60993: IFFALSE 61004
// ComExitBuilding ( j ) ;
60995: LD_VAR 0 3
60999: PPUSH
61000: CALL_OW 122
// wait ( 3 ) ;
61004: LD_INT 3
61006: PPUSH
61007: CALL_OW 67
// if not mc_construct_list [ i ] then
61011: LD_EXP 66
61015: PUSH
61016: LD_VAR 0 2
61020: ARRAY
61021: NOT
61022: IFFALSE 61026
// break ;
61024: GO 61064
// if not HasTask ( j ) then
61026: LD_VAR 0 3
61030: PPUSH
61031: CALL_OW 314
61035: NOT
61036: IFFALSE 61062
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
61038: LD_VAR 0 3
61042: PPUSH
61043: LD_EXP 66
61047: PUSH
61048: LD_VAR 0 2
61052: ARRAY
61053: PUSH
61054: LD_INT 1
61056: ARRAY
61057: PPUSH
61058: CALL 22089 0 2
// end ;
61062: GO 60912
61064: POP
61065: POP
// end else
61066: GO 61871
// if mc_build_list [ i ] then
61068: LD_EXP 64
61072: PUSH
61073: LD_VAR 0 2
61077: ARRAY
61078: IFFALSE 61871
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61080: LD_ADDR_VAR 0 5
61084: PUSH
61085: LD_EXP 59
61089: PUSH
61090: LD_VAR 0 2
61094: ARRAY
61095: PPUSH
61096: LD_INT 2
61098: PUSH
61099: LD_INT 30
61101: PUSH
61102: LD_INT 0
61104: PUSH
61105: EMPTY
61106: LIST
61107: LIST
61108: PUSH
61109: LD_INT 30
61111: PUSH
61112: LD_INT 1
61114: PUSH
61115: EMPTY
61116: LIST
61117: LIST
61118: PUSH
61119: EMPTY
61120: LIST
61121: LIST
61122: LIST
61123: PPUSH
61124: CALL_OW 72
61128: ST_TO_ADDR
// if depot then
61129: LD_VAR 0 5
61133: IFFALSE 61151
// depot := depot [ 1 ] else
61135: LD_ADDR_VAR 0 5
61139: PUSH
61140: LD_VAR 0 5
61144: PUSH
61145: LD_INT 1
61147: ARRAY
61148: ST_TO_ADDR
61149: GO 61159
// depot := 0 ;
61151: LD_ADDR_VAR 0 5
61155: PUSH
61156: LD_INT 0
61158: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
61159: LD_EXP 64
61163: PUSH
61164: LD_VAR 0 2
61168: ARRAY
61169: PUSH
61170: LD_INT 1
61172: ARRAY
61173: PUSH
61174: LD_INT 1
61176: ARRAY
61177: PPUSH
61178: CALL 21919 0 1
61182: PUSH
61183: LD_EXP 59
61187: PUSH
61188: LD_VAR 0 2
61192: ARRAY
61193: PPUSH
61194: LD_INT 2
61196: PUSH
61197: LD_INT 30
61199: PUSH
61200: LD_INT 2
61202: PUSH
61203: EMPTY
61204: LIST
61205: LIST
61206: PUSH
61207: LD_INT 30
61209: PUSH
61210: LD_INT 3
61212: PUSH
61213: EMPTY
61214: LIST
61215: LIST
61216: PUSH
61217: EMPTY
61218: LIST
61219: LIST
61220: LIST
61221: PPUSH
61222: CALL_OW 72
61226: NOT
61227: AND
61228: IFFALSE 61333
// begin for j = 1 to mc_build_list [ i ] do
61230: LD_ADDR_VAR 0 3
61234: PUSH
61235: DOUBLE
61236: LD_INT 1
61238: DEC
61239: ST_TO_ADDR
61240: LD_EXP 64
61244: PUSH
61245: LD_VAR 0 2
61249: ARRAY
61250: PUSH
61251: FOR_TO
61252: IFFALSE 61331
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
61254: LD_EXP 64
61258: PUSH
61259: LD_VAR 0 2
61263: ARRAY
61264: PUSH
61265: LD_VAR 0 3
61269: ARRAY
61270: PUSH
61271: LD_INT 1
61273: ARRAY
61274: PUSH
61275: LD_INT 2
61277: EQUAL
61278: IFFALSE 61329
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
61280: LD_ADDR_EXP 64
61284: PUSH
61285: LD_EXP 64
61289: PPUSH
61290: LD_VAR 0 2
61294: PPUSH
61295: LD_EXP 64
61299: PUSH
61300: LD_VAR 0 2
61304: ARRAY
61305: PPUSH
61306: LD_VAR 0 3
61310: PPUSH
61311: LD_INT 1
61313: PPUSH
61314: LD_INT 0
61316: PPUSH
61317: CALL 18656 0 4
61321: PPUSH
61322: CALL_OW 1
61326: ST_TO_ADDR
// break ;
61327: GO 61331
// end ;
61329: GO 61251
61331: POP
61332: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
61333: LD_EXP 64
61337: PUSH
61338: LD_VAR 0 2
61342: ARRAY
61343: PUSH
61344: LD_INT 1
61346: ARRAY
61347: PUSH
61348: LD_INT 1
61350: ARRAY
61351: PUSH
61352: LD_INT 0
61354: EQUAL
61355: PUSH
61356: LD_VAR 0 5
61360: PUSH
61361: LD_VAR 0 5
61365: PPUSH
61366: LD_EXP 64
61370: PUSH
61371: LD_VAR 0 2
61375: ARRAY
61376: PUSH
61377: LD_INT 1
61379: ARRAY
61380: PUSH
61381: LD_INT 1
61383: ARRAY
61384: PPUSH
61385: LD_EXP 64
61389: PUSH
61390: LD_VAR 0 2
61394: ARRAY
61395: PUSH
61396: LD_INT 1
61398: ARRAY
61399: PUSH
61400: LD_INT 2
61402: ARRAY
61403: PPUSH
61404: LD_EXP 64
61408: PUSH
61409: LD_VAR 0 2
61413: ARRAY
61414: PUSH
61415: LD_INT 1
61417: ARRAY
61418: PUSH
61419: LD_INT 3
61421: ARRAY
61422: PPUSH
61423: LD_EXP 64
61427: PUSH
61428: LD_VAR 0 2
61432: ARRAY
61433: PUSH
61434: LD_INT 1
61436: ARRAY
61437: PUSH
61438: LD_INT 4
61440: ARRAY
61441: PPUSH
61442: CALL 26653 0 5
61446: AND
61447: OR
61448: IFFALSE 61729
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61450: LD_ADDR_VAR 0 4
61454: PUSH
61455: LD_EXP 59
61459: PUSH
61460: LD_VAR 0 2
61464: ARRAY
61465: PPUSH
61466: LD_INT 25
61468: PUSH
61469: LD_INT 2
61471: PUSH
61472: EMPTY
61473: LIST
61474: LIST
61475: PPUSH
61476: CALL_OW 72
61480: PUSH
61481: LD_EXP 61
61485: PUSH
61486: LD_VAR 0 2
61490: ARRAY
61491: DIFF
61492: ST_TO_ADDR
// if not tmp then
61493: LD_VAR 0 4
61497: NOT
61498: IFFALSE 61502
// continue ;
61500: GO 60747
// for j in tmp do
61502: LD_ADDR_VAR 0 3
61506: PUSH
61507: LD_VAR 0 4
61511: PUSH
61512: FOR_IN
61513: IFFALSE 61725
// begin if not mc_builders [ i ] then
61515: LD_EXP 65
61519: PUSH
61520: LD_VAR 0 2
61524: ARRAY
61525: NOT
61526: IFFALSE 61584
// begin SetTag ( j , 103 ) ;
61528: LD_VAR 0 3
61532: PPUSH
61533: LD_INT 103
61535: PPUSH
61536: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61540: LD_ADDR_EXP 65
61544: PUSH
61545: LD_EXP 65
61549: PPUSH
61550: LD_VAR 0 2
61554: PUSH
61555: LD_EXP 65
61559: PUSH
61560: LD_VAR 0 2
61564: ARRAY
61565: PUSH
61566: LD_INT 1
61568: PLUS
61569: PUSH
61570: EMPTY
61571: LIST
61572: LIST
61573: PPUSH
61574: LD_VAR 0 3
61578: PPUSH
61579: CALL 19238 0 3
61583: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61584: LD_VAR 0 3
61588: PPUSH
61589: CALL_OW 310
61593: IFFALSE 61604
// ComExitBuilding ( j ) ;
61595: LD_VAR 0 3
61599: PPUSH
61600: CALL_OW 122
// wait ( 3 ) ;
61604: LD_INT 3
61606: PPUSH
61607: CALL_OW 67
// if not mc_build_list [ i ] then
61611: LD_EXP 64
61615: PUSH
61616: LD_VAR 0 2
61620: ARRAY
61621: NOT
61622: IFFALSE 61626
// break ;
61624: GO 61725
// if not HasTask ( j ) then
61626: LD_VAR 0 3
61630: PPUSH
61631: CALL_OW 314
61635: NOT
61636: IFFALSE 61723
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
61638: LD_VAR 0 3
61642: PPUSH
61643: LD_EXP 64
61647: PUSH
61648: LD_VAR 0 2
61652: ARRAY
61653: PUSH
61654: LD_INT 1
61656: ARRAY
61657: PUSH
61658: LD_INT 1
61660: ARRAY
61661: PPUSH
61662: LD_EXP 64
61666: PUSH
61667: LD_VAR 0 2
61671: ARRAY
61672: PUSH
61673: LD_INT 1
61675: ARRAY
61676: PUSH
61677: LD_INT 2
61679: ARRAY
61680: PPUSH
61681: LD_EXP 64
61685: PUSH
61686: LD_VAR 0 2
61690: ARRAY
61691: PUSH
61692: LD_INT 1
61694: ARRAY
61695: PUSH
61696: LD_INT 3
61698: ARRAY
61699: PPUSH
61700: LD_EXP 64
61704: PUSH
61705: LD_VAR 0 2
61709: ARRAY
61710: PUSH
61711: LD_INT 1
61713: ARRAY
61714: PUSH
61715: LD_INT 4
61717: ARRAY
61718: PPUSH
61719: CALL_OW 145
// end ;
61723: GO 61512
61725: POP
61726: POP
// end else
61727: GO 61871
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
61729: LD_EXP 59
61733: PUSH
61734: LD_VAR 0 2
61738: ARRAY
61739: PPUSH
61740: LD_EXP 64
61744: PUSH
61745: LD_VAR 0 2
61749: ARRAY
61750: PUSH
61751: LD_INT 1
61753: ARRAY
61754: PUSH
61755: LD_INT 1
61757: ARRAY
61758: PPUSH
61759: LD_EXP 64
61763: PUSH
61764: LD_VAR 0 2
61768: ARRAY
61769: PUSH
61770: LD_INT 1
61772: ARRAY
61773: PUSH
61774: LD_INT 2
61776: ARRAY
61777: PPUSH
61778: LD_EXP 64
61782: PUSH
61783: LD_VAR 0 2
61787: ARRAY
61788: PUSH
61789: LD_INT 1
61791: ARRAY
61792: PUSH
61793: LD_INT 3
61795: ARRAY
61796: PPUSH
61797: LD_EXP 64
61801: PUSH
61802: LD_VAR 0 2
61806: ARRAY
61807: PUSH
61808: LD_INT 1
61810: ARRAY
61811: PUSH
61812: LD_INT 4
61814: ARRAY
61815: PPUSH
61816: CALL 25989 0 5
61820: NOT
61821: IFFALSE 61871
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
61823: LD_ADDR_EXP 64
61827: PUSH
61828: LD_EXP 64
61832: PPUSH
61833: LD_VAR 0 2
61837: PPUSH
61838: LD_EXP 64
61842: PUSH
61843: LD_VAR 0 2
61847: ARRAY
61848: PPUSH
61849: LD_INT 1
61851: PPUSH
61852: LD_INT 1
61854: NEG
61855: PPUSH
61856: LD_INT 0
61858: PPUSH
61859: CALL 18656 0 4
61863: PPUSH
61864: CALL_OW 1
61868: ST_TO_ADDR
// continue ;
61869: GO 60747
// end ; end ; end ;
61871: GO 60747
61873: POP
61874: POP
// end ;
61875: LD_VAR 0 1
61879: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
61880: LD_INT 0
61882: PPUSH
61883: PPUSH
61884: PPUSH
61885: PPUSH
61886: PPUSH
61887: PPUSH
// if not mc_bases then
61888: LD_EXP 59
61892: NOT
61893: IFFALSE 61897
// exit ;
61895: GO 62324
// for i = 1 to mc_bases do
61897: LD_ADDR_VAR 0 2
61901: PUSH
61902: DOUBLE
61903: LD_INT 1
61905: DEC
61906: ST_TO_ADDR
61907: LD_EXP 59
61911: PUSH
61912: FOR_TO
61913: IFFALSE 62322
// begin tmp := mc_build_upgrade [ i ] ;
61915: LD_ADDR_VAR 0 4
61919: PUSH
61920: LD_EXP 91
61924: PUSH
61925: LD_VAR 0 2
61929: ARRAY
61930: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
61931: LD_ADDR_VAR 0 6
61935: PUSH
61936: LD_EXP 92
61940: PUSH
61941: LD_VAR 0 2
61945: ARRAY
61946: PPUSH
61947: LD_INT 2
61949: PUSH
61950: LD_INT 30
61952: PUSH
61953: LD_INT 6
61955: PUSH
61956: EMPTY
61957: LIST
61958: LIST
61959: PUSH
61960: LD_INT 30
61962: PUSH
61963: LD_INT 7
61965: PUSH
61966: EMPTY
61967: LIST
61968: LIST
61969: PUSH
61970: EMPTY
61971: LIST
61972: LIST
61973: LIST
61974: PPUSH
61975: CALL_OW 72
61979: ST_TO_ADDR
// if not tmp and not lab then
61980: LD_VAR 0 4
61984: NOT
61985: PUSH
61986: LD_VAR 0 6
61990: NOT
61991: AND
61992: IFFALSE 61996
// continue ;
61994: GO 61912
// if tmp then
61996: LD_VAR 0 4
62000: IFFALSE 62120
// for j in tmp do
62002: LD_ADDR_VAR 0 3
62006: PUSH
62007: LD_VAR 0 4
62011: PUSH
62012: FOR_IN
62013: IFFALSE 62118
// begin if UpgradeCost ( j ) then
62015: LD_VAR 0 3
62019: PPUSH
62020: CALL 25649 0 1
62024: IFFALSE 62116
// begin ComUpgrade ( j ) ;
62026: LD_VAR 0 3
62030: PPUSH
62031: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
62035: LD_ADDR_EXP 91
62039: PUSH
62040: LD_EXP 91
62044: PPUSH
62045: LD_VAR 0 2
62049: PPUSH
62050: LD_EXP 91
62054: PUSH
62055: LD_VAR 0 2
62059: ARRAY
62060: PUSH
62061: LD_VAR 0 3
62065: DIFF
62066: PPUSH
62067: CALL_OW 1
62071: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62072: LD_ADDR_EXP 66
62076: PUSH
62077: LD_EXP 66
62081: PPUSH
62082: LD_VAR 0 2
62086: PUSH
62087: LD_EXP 66
62091: PUSH
62092: LD_VAR 0 2
62096: ARRAY
62097: PUSH
62098: LD_INT 1
62100: PLUS
62101: PUSH
62102: EMPTY
62103: LIST
62104: LIST
62105: PPUSH
62106: LD_VAR 0 3
62110: PPUSH
62111: CALL 19238 0 3
62115: ST_TO_ADDR
// end ; end ;
62116: GO 62012
62118: POP
62119: POP
// if not lab or not mc_lab_upgrade [ i ] then
62120: LD_VAR 0 6
62124: NOT
62125: PUSH
62126: LD_EXP 93
62130: PUSH
62131: LD_VAR 0 2
62135: ARRAY
62136: NOT
62137: OR
62138: IFFALSE 62142
// continue ;
62140: GO 61912
// for j in lab do
62142: LD_ADDR_VAR 0 3
62146: PUSH
62147: LD_VAR 0 6
62151: PUSH
62152: FOR_IN
62153: IFFALSE 62318
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
62155: LD_VAR 0 3
62159: PPUSH
62160: CALL_OW 266
62164: PUSH
62165: LD_INT 6
62167: PUSH
62168: LD_INT 7
62170: PUSH
62171: EMPTY
62172: LIST
62173: LIST
62174: IN
62175: PUSH
62176: LD_VAR 0 3
62180: PPUSH
62181: CALL_OW 461
62185: PUSH
62186: LD_INT 1
62188: NONEQUAL
62189: AND
62190: IFFALSE 62316
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
62192: LD_VAR 0 3
62196: PPUSH
62197: LD_EXP 93
62201: PUSH
62202: LD_VAR 0 2
62206: ARRAY
62207: PUSH
62208: LD_INT 1
62210: ARRAY
62211: PPUSH
62212: CALL 25854 0 2
62216: IFFALSE 62316
// begin ComCancel ( j ) ;
62218: LD_VAR 0 3
62222: PPUSH
62223: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
62227: LD_VAR 0 3
62231: PPUSH
62232: LD_EXP 93
62236: PUSH
62237: LD_VAR 0 2
62241: ARRAY
62242: PUSH
62243: LD_INT 1
62245: ARRAY
62246: PPUSH
62247: CALL_OW 207
// if not j in mc_construct_list [ i ] then
62251: LD_VAR 0 3
62255: PUSH
62256: LD_EXP 66
62260: PUSH
62261: LD_VAR 0 2
62265: ARRAY
62266: IN
62267: NOT
62268: IFFALSE 62314
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62270: LD_ADDR_EXP 66
62274: PUSH
62275: LD_EXP 66
62279: PPUSH
62280: LD_VAR 0 2
62284: PUSH
62285: LD_EXP 66
62289: PUSH
62290: LD_VAR 0 2
62294: ARRAY
62295: PUSH
62296: LD_INT 1
62298: PLUS
62299: PUSH
62300: EMPTY
62301: LIST
62302: LIST
62303: PPUSH
62304: LD_VAR 0 3
62308: PPUSH
62309: CALL 19238 0 3
62313: ST_TO_ADDR
// break ;
62314: GO 62318
// end ; end ; end ;
62316: GO 62152
62318: POP
62319: POP
// end ;
62320: GO 61912
62322: POP
62323: POP
// end ;
62324: LD_VAR 0 1
62328: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
62329: LD_INT 0
62331: PPUSH
62332: PPUSH
62333: PPUSH
62334: PPUSH
62335: PPUSH
62336: PPUSH
62337: PPUSH
62338: PPUSH
62339: PPUSH
// if not mc_bases then
62340: LD_EXP 59
62344: NOT
62345: IFFALSE 62349
// exit ;
62347: GO 62754
// for i = 1 to mc_bases do
62349: LD_ADDR_VAR 0 2
62353: PUSH
62354: DOUBLE
62355: LD_INT 1
62357: DEC
62358: ST_TO_ADDR
62359: LD_EXP 59
62363: PUSH
62364: FOR_TO
62365: IFFALSE 62752
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
62367: LD_EXP 67
62371: PUSH
62372: LD_VAR 0 2
62376: ARRAY
62377: NOT
62378: PUSH
62379: LD_EXP 59
62383: PUSH
62384: LD_VAR 0 2
62388: ARRAY
62389: PPUSH
62390: LD_INT 30
62392: PUSH
62393: LD_INT 3
62395: PUSH
62396: EMPTY
62397: LIST
62398: LIST
62399: PPUSH
62400: CALL_OW 72
62404: NOT
62405: OR
62406: IFFALSE 62410
// continue ;
62408: GO 62364
// busy := false ;
62410: LD_ADDR_VAR 0 8
62414: PUSH
62415: LD_INT 0
62417: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62418: LD_ADDR_VAR 0 4
62422: PUSH
62423: LD_EXP 59
62427: PUSH
62428: LD_VAR 0 2
62432: ARRAY
62433: PPUSH
62434: LD_INT 30
62436: PUSH
62437: LD_INT 3
62439: PUSH
62440: EMPTY
62441: LIST
62442: LIST
62443: PPUSH
62444: CALL_OW 72
62448: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
62449: LD_ADDR_VAR 0 6
62453: PUSH
62454: LD_EXP 67
62458: PUSH
62459: LD_VAR 0 2
62463: ARRAY
62464: PPUSH
62465: LD_INT 2
62467: PUSH
62468: LD_INT 30
62470: PUSH
62471: LD_INT 32
62473: PUSH
62474: EMPTY
62475: LIST
62476: LIST
62477: PUSH
62478: LD_INT 30
62480: PUSH
62481: LD_INT 33
62483: PUSH
62484: EMPTY
62485: LIST
62486: LIST
62487: PUSH
62488: EMPTY
62489: LIST
62490: LIST
62491: LIST
62492: PPUSH
62493: CALL_OW 72
62497: ST_TO_ADDR
// if not t then
62498: LD_VAR 0 6
62502: NOT
62503: IFFALSE 62507
// continue ;
62505: GO 62364
// for j in tmp do
62507: LD_ADDR_VAR 0 3
62511: PUSH
62512: LD_VAR 0 4
62516: PUSH
62517: FOR_IN
62518: IFFALSE 62548
// if not BuildingStatus ( j ) = bs_idle then
62520: LD_VAR 0 3
62524: PPUSH
62525: CALL_OW 461
62529: PUSH
62530: LD_INT 2
62532: EQUAL
62533: NOT
62534: IFFALSE 62546
// begin busy := true ;
62536: LD_ADDR_VAR 0 8
62540: PUSH
62541: LD_INT 1
62543: ST_TO_ADDR
// break ;
62544: GO 62548
// end ;
62546: GO 62517
62548: POP
62549: POP
// if busy then
62550: LD_VAR 0 8
62554: IFFALSE 62558
// continue ;
62556: GO 62364
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
62558: LD_ADDR_VAR 0 7
62562: PUSH
62563: LD_VAR 0 6
62567: PPUSH
62568: LD_INT 35
62570: PUSH
62571: LD_INT 0
62573: PUSH
62574: EMPTY
62575: LIST
62576: LIST
62577: PPUSH
62578: CALL_OW 72
62582: ST_TO_ADDR
// if tw then
62583: LD_VAR 0 7
62587: IFFALSE 62664
// begin tw := tw [ 1 ] ;
62589: LD_ADDR_VAR 0 7
62593: PUSH
62594: LD_VAR 0 7
62598: PUSH
62599: LD_INT 1
62601: ARRAY
62602: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
62603: LD_ADDR_VAR 0 9
62607: PUSH
62608: LD_VAR 0 7
62612: PPUSH
62613: LD_EXP 84
62617: PUSH
62618: LD_VAR 0 2
62622: ARRAY
62623: PPUSH
62624: CALL 24208 0 2
62628: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
62629: LD_EXP 98
62633: PUSH
62634: LD_VAR 0 2
62638: ARRAY
62639: IFFALSE 62662
// if not weapon in mc_allowed_tower_weapons [ i ] then
62641: LD_VAR 0 9
62645: PUSH
62646: LD_EXP 98
62650: PUSH
62651: LD_VAR 0 2
62655: ARRAY
62656: IN
62657: NOT
62658: IFFALSE 62662
// continue ;
62660: GO 62364
// end else
62662: GO 62727
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
62664: LD_ADDR_VAR 0 5
62668: PUSH
62669: LD_EXP 67
62673: PUSH
62674: LD_VAR 0 2
62678: ARRAY
62679: PPUSH
62680: LD_VAR 0 4
62684: PPUSH
62685: CALL 49710 0 2
62689: ST_TO_ADDR
// if not tmp2 then
62690: LD_VAR 0 5
62694: NOT
62695: IFFALSE 62699
// continue ;
62697: GO 62364
// tw := tmp2 [ 1 ] ;
62699: LD_ADDR_VAR 0 7
62703: PUSH
62704: LD_VAR 0 5
62708: PUSH
62709: LD_INT 1
62711: ARRAY
62712: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
62713: LD_ADDR_VAR 0 9
62717: PUSH
62718: LD_VAR 0 5
62722: PUSH
62723: LD_INT 2
62725: ARRAY
62726: ST_TO_ADDR
// end ; if not weapon then
62727: LD_VAR 0 9
62731: NOT
62732: IFFALSE 62736
// continue ;
62734: GO 62364
// ComPlaceWeapon ( tw , weapon ) ;
62736: LD_VAR 0 7
62740: PPUSH
62741: LD_VAR 0 9
62745: PPUSH
62746: CALL_OW 148
// end ;
62750: GO 62364
62752: POP
62753: POP
// end ;
62754: LD_VAR 0 1
62758: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
62759: LD_INT 0
62761: PPUSH
62762: PPUSH
62763: PPUSH
62764: PPUSH
62765: PPUSH
62766: PPUSH
// if not mc_bases then
62767: LD_EXP 59
62771: NOT
62772: IFFALSE 62776
// exit ;
62774: GO 63552
// for i = 1 to mc_bases do
62776: LD_ADDR_VAR 0 2
62780: PUSH
62781: DOUBLE
62782: LD_INT 1
62784: DEC
62785: ST_TO_ADDR
62786: LD_EXP 59
62790: PUSH
62791: FOR_TO
62792: IFFALSE 63550
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
62794: LD_EXP 72
62798: PUSH
62799: LD_VAR 0 2
62803: ARRAY
62804: NOT
62805: PUSH
62806: LD_EXP 72
62810: PUSH
62811: LD_VAR 0 2
62815: ARRAY
62816: PUSH
62817: LD_EXP 73
62821: PUSH
62822: LD_VAR 0 2
62826: ARRAY
62827: EQUAL
62828: OR
62829: PUSH
62830: LD_EXP 82
62834: PUSH
62835: LD_VAR 0 2
62839: ARRAY
62840: OR
62841: IFFALSE 62845
// continue ;
62843: GO 62791
// if mc_miners [ i ] then
62845: LD_EXP 73
62849: PUSH
62850: LD_VAR 0 2
62854: ARRAY
62855: IFFALSE 63237
// begin for j = mc_miners [ i ] downto 1 do
62857: LD_ADDR_VAR 0 3
62861: PUSH
62862: DOUBLE
62863: LD_EXP 73
62867: PUSH
62868: LD_VAR 0 2
62872: ARRAY
62873: INC
62874: ST_TO_ADDR
62875: LD_INT 1
62877: PUSH
62878: FOR_DOWNTO
62879: IFFALSE 63235
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
62881: LD_EXP 73
62885: PUSH
62886: LD_VAR 0 2
62890: ARRAY
62891: PUSH
62892: LD_VAR 0 3
62896: ARRAY
62897: PPUSH
62898: CALL_OW 301
62902: PUSH
62903: LD_EXP 73
62907: PUSH
62908: LD_VAR 0 2
62912: ARRAY
62913: PUSH
62914: LD_VAR 0 3
62918: ARRAY
62919: PPUSH
62920: CALL_OW 257
62924: PUSH
62925: LD_INT 1
62927: NONEQUAL
62928: OR
62929: IFFALSE 62992
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
62931: LD_ADDR_VAR 0 5
62935: PUSH
62936: LD_EXP 73
62940: PUSH
62941: LD_VAR 0 2
62945: ARRAY
62946: PUSH
62947: LD_EXP 73
62951: PUSH
62952: LD_VAR 0 2
62956: ARRAY
62957: PUSH
62958: LD_VAR 0 3
62962: ARRAY
62963: DIFF
62964: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
62965: LD_ADDR_EXP 73
62969: PUSH
62970: LD_EXP 73
62974: PPUSH
62975: LD_VAR 0 2
62979: PPUSH
62980: LD_VAR 0 5
62984: PPUSH
62985: CALL_OW 1
62989: ST_TO_ADDR
// continue ;
62990: GO 62878
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
62992: LD_EXP 73
62996: PUSH
62997: LD_VAR 0 2
63001: ARRAY
63002: PUSH
63003: LD_VAR 0 3
63007: ARRAY
63008: PPUSH
63009: CALL_OW 257
63013: PUSH
63014: LD_INT 1
63016: EQUAL
63017: PUSH
63018: LD_EXP 73
63022: PUSH
63023: LD_VAR 0 2
63027: ARRAY
63028: PUSH
63029: LD_VAR 0 3
63033: ARRAY
63034: PPUSH
63035: CALL_OW 459
63039: NOT
63040: AND
63041: PUSH
63042: LD_EXP 73
63046: PUSH
63047: LD_VAR 0 2
63051: ARRAY
63052: PUSH
63053: LD_VAR 0 3
63057: ARRAY
63058: PPUSH
63059: CALL_OW 314
63063: NOT
63064: AND
63065: IFFALSE 63233
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
63067: LD_EXP 73
63071: PUSH
63072: LD_VAR 0 2
63076: ARRAY
63077: PUSH
63078: LD_VAR 0 3
63082: ARRAY
63083: PPUSH
63084: CALL_OW 310
63088: IFFALSE 63111
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
63090: LD_EXP 73
63094: PUSH
63095: LD_VAR 0 2
63099: ARRAY
63100: PUSH
63101: LD_VAR 0 3
63105: ARRAY
63106: PPUSH
63107: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
63111: LD_EXP 73
63115: PUSH
63116: LD_VAR 0 2
63120: ARRAY
63121: PUSH
63122: LD_VAR 0 3
63126: ARRAY
63127: PPUSH
63128: CALL_OW 314
63132: NOT
63133: IFFALSE 63233
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
63135: LD_EXP 73
63139: PUSH
63140: LD_VAR 0 2
63144: ARRAY
63145: PUSH
63146: LD_VAR 0 3
63150: ARRAY
63151: PPUSH
63152: LD_EXP 72
63156: PUSH
63157: LD_VAR 0 2
63161: ARRAY
63162: PUSH
63163: LD_VAR 0 3
63167: PUSH
63168: LD_EXP 72
63172: PUSH
63173: LD_VAR 0 2
63177: ARRAY
63178: MOD
63179: PUSH
63180: LD_INT 1
63182: PLUS
63183: ARRAY
63184: PUSH
63185: LD_INT 1
63187: ARRAY
63188: PPUSH
63189: LD_EXP 72
63193: PUSH
63194: LD_VAR 0 2
63198: ARRAY
63199: PUSH
63200: LD_VAR 0 3
63204: PUSH
63205: LD_EXP 72
63209: PUSH
63210: LD_VAR 0 2
63214: ARRAY
63215: MOD
63216: PUSH
63217: LD_INT 1
63219: PLUS
63220: ARRAY
63221: PUSH
63222: LD_INT 2
63224: ARRAY
63225: PPUSH
63226: LD_INT 0
63228: PPUSH
63229: CALL_OW 193
// end ; end ;
63233: GO 62878
63235: POP
63236: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
63237: LD_ADDR_VAR 0 5
63241: PUSH
63242: LD_EXP 59
63246: PUSH
63247: LD_VAR 0 2
63251: ARRAY
63252: PPUSH
63253: LD_INT 2
63255: PUSH
63256: LD_INT 30
63258: PUSH
63259: LD_INT 4
63261: PUSH
63262: EMPTY
63263: LIST
63264: LIST
63265: PUSH
63266: LD_INT 30
63268: PUSH
63269: LD_INT 5
63271: PUSH
63272: EMPTY
63273: LIST
63274: LIST
63275: PUSH
63276: LD_INT 30
63278: PUSH
63279: LD_INT 32
63281: PUSH
63282: EMPTY
63283: LIST
63284: LIST
63285: PUSH
63286: EMPTY
63287: LIST
63288: LIST
63289: LIST
63290: LIST
63291: PPUSH
63292: CALL_OW 72
63296: ST_TO_ADDR
// if not tmp then
63297: LD_VAR 0 5
63301: NOT
63302: IFFALSE 63306
// continue ;
63304: GO 62791
// list := [ ] ;
63306: LD_ADDR_VAR 0 6
63310: PUSH
63311: EMPTY
63312: ST_TO_ADDR
// for j in tmp do
63313: LD_ADDR_VAR 0 3
63317: PUSH
63318: LD_VAR 0 5
63322: PUSH
63323: FOR_IN
63324: IFFALSE 63393
// begin for k in UnitsInside ( j ) do
63326: LD_ADDR_VAR 0 4
63330: PUSH
63331: LD_VAR 0 3
63335: PPUSH
63336: CALL_OW 313
63340: PUSH
63341: FOR_IN
63342: IFFALSE 63389
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
63344: LD_VAR 0 4
63348: PPUSH
63349: CALL_OW 257
63353: PUSH
63354: LD_INT 1
63356: EQUAL
63357: PUSH
63358: LD_VAR 0 4
63362: PPUSH
63363: CALL_OW 459
63367: NOT
63368: AND
63369: IFFALSE 63387
// list := list ^ k ;
63371: LD_ADDR_VAR 0 6
63375: PUSH
63376: LD_VAR 0 6
63380: PUSH
63381: LD_VAR 0 4
63385: ADD
63386: ST_TO_ADDR
63387: GO 63341
63389: POP
63390: POP
// end ;
63391: GO 63323
63393: POP
63394: POP
// list := list diff mc_miners [ i ] ;
63395: LD_ADDR_VAR 0 6
63399: PUSH
63400: LD_VAR 0 6
63404: PUSH
63405: LD_EXP 73
63409: PUSH
63410: LD_VAR 0 2
63414: ARRAY
63415: DIFF
63416: ST_TO_ADDR
// if not list then
63417: LD_VAR 0 6
63421: NOT
63422: IFFALSE 63426
// continue ;
63424: GO 62791
// k := mc_mines [ i ] - mc_miners [ i ] ;
63426: LD_ADDR_VAR 0 4
63430: PUSH
63431: LD_EXP 72
63435: PUSH
63436: LD_VAR 0 2
63440: ARRAY
63441: PUSH
63442: LD_EXP 73
63446: PUSH
63447: LD_VAR 0 2
63451: ARRAY
63452: MINUS
63453: ST_TO_ADDR
// if k > list then
63454: LD_VAR 0 4
63458: PUSH
63459: LD_VAR 0 6
63463: GREATER
63464: IFFALSE 63476
// k := list ;
63466: LD_ADDR_VAR 0 4
63470: PUSH
63471: LD_VAR 0 6
63475: ST_TO_ADDR
// for j = 1 to k do
63476: LD_ADDR_VAR 0 3
63480: PUSH
63481: DOUBLE
63482: LD_INT 1
63484: DEC
63485: ST_TO_ADDR
63486: LD_VAR 0 4
63490: PUSH
63491: FOR_TO
63492: IFFALSE 63546
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
63494: LD_ADDR_EXP 73
63498: PUSH
63499: LD_EXP 73
63503: PPUSH
63504: LD_VAR 0 2
63508: PUSH
63509: LD_EXP 73
63513: PUSH
63514: LD_VAR 0 2
63518: ARRAY
63519: PUSH
63520: LD_INT 1
63522: PLUS
63523: PUSH
63524: EMPTY
63525: LIST
63526: LIST
63527: PPUSH
63528: LD_VAR 0 6
63532: PUSH
63533: LD_VAR 0 3
63537: ARRAY
63538: PPUSH
63539: CALL 19238 0 3
63543: ST_TO_ADDR
63544: GO 63491
63546: POP
63547: POP
// end ;
63548: GO 62791
63550: POP
63551: POP
// end ;
63552: LD_VAR 0 1
63556: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
63557: LD_INT 0
63559: PPUSH
63560: PPUSH
63561: PPUSH
63562: PPUSH
63563: PPUSH
63564: PPUSH
63565: PPUSH
63566: PPUSH
63567: PPUSH
63568: PPUSH
// if not mc_bases then
63569: LD_EXP 59
63573: NOT
63574: IFFALSE 63578
// exit ;
63576: GO 65328
// for i = 1 to mc_bases do
63578: LD_ADDR_VAR 0 2
63582: PUSH
63583: DOUBLE
63584: LD_INT 1
63586: DEC
63587: ST_TO_ADDR
63588: LD_EXP 59
63592: PUSH
63593: FOR_TO
63594: IFFALSE 65326
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
63596: LD_EXP 59
63600: PUSH
63601: LD_VAR 0 2
63605: ARRAY
63606: NOT
63607: PUSH
63608: LD_EXP 66
63612: PUSH
63613: LD_VAR 0 2
63617: ARRAY
63618: OR
63619: IFFALSE 63623
// continue ;
63621: GO 63593
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
63623: LD_EXP 75
63627: PUSH
63628: LD_VAR 0 2
63632: ARRAY
63633: NOT
63634: PUSH
63635: LD_EXP 76
63639: PUSH
63640: LD_VAR 0 2
63644: ARRAY
63645: AND
63646: IFFALSE 63684
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63648: LD_ADDR_EXP 76
63652: PUSH
63653: LD_EXP 76
63657: PPUSH
63658: LD_VAR 0 2
63662: PPUSH
63663: EMPTY
63664: PPUSH
63665: CALL_OW 1
63669: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
63670: LD_VAR 0 2
63674: PPUSH
63675: LD_INT 107
63677: PPUSH
63678: CALL 54542 0 2
// continue ;
63682: GO 63593
// end ; target := [ ] ;
63684: LD_ADDR_VAR 0 6
63688: PUSH
63689: EMPTY
63690: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
63691: LD_ADDR_VAR 0 3
63695: PUSH
63696: DOUBLE
63697: LD_EXP 75
63701: PUSH
63702: LD_VAR 0 2
63706: ARRAY
63707: INC
63708: ST_TO_ADDR
63709: LD_INT 1
63711: PUSH
63712: FOR_DOWNTO
63713: IFFALSE 63973
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
63715: LD_EXP 75
63719: PUSH
63720: LD_VAR 0 2
63724: ARRAY
63725: PUSH
63726: LD_VAR 0 3
63730: ARRAY
63731: PUSH
63732: LD_INT 2
63734: ARRAY
63735: PPUSH
63736: LD_EXP 75
63740: PUSH
63741: LD_VAR 0 2
63745: ARRAY
63746: PUSH
63747: LD_VAR 0 3
63751: ARRAY
63752: PUSH
63753: LD_INT 3
63755: ARRAY
63756: PPUSH
63757: CALL_OW 488
63761: PUSH
63762: LD_EXP 75
63766: PUSH
63767: LD_VAR 0 2
63771: ARRAY
63772: PUSH
63773: LD_VAR 0 3
63777: ARRAY
63778: PUSH
63779: LD_INT 2
63781: ARRAY
63782: PPUSH
63783: LD_EXP 75
63787: PUSH
63788: LD_VAR 0 2
63792: ARRAY
63793: PUSH
63794: LD_VAR 0 3
63798: ARRAY
63799: PUSH
63800: LD_INT 3
63802: ARRAY
63803: PPUSH
63804: CALL_OW 284
63808: PUSH
63809: LD_INT 0
63811: EQUAL
63812: AND
63813: IFFALSE 63868
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
63815: LD_ADDR_VAR 0 5
63819: PUSH
63820: LD_EXP 75
63824: PUSH
63825: LD_VAR 0 2
63829: ARRAY
63830: PPUSH
63831: LD_VAR 0 3
63835: PPUSH
63836: CALL_OW 3
63840: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
63841: LD_ADDR_EXP 75
63845: PUSH
63846: LD_EXP 75
63850: PPUSH
63851: LD_VAR 0 2
63855: PPUSH
63856: LD_VAR 0 5
63860: PPUSH
63861: CALL_OW 1
63865: ST_TO_ADDR
// continue ;
63866: GO 63712
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
63868: LD_EXP 59
63872: PUSH
63873: LD_VAR 0 2
63877: ARRAY
63878: PUSH
63879: LD_INT 1
63881: ARRAY
63882: PPUSH
63883: CALL_OW 255
63887: PPUSH
63888: LD_EXP 75
63892: PUSH
63893: LD_VAR 0 2
63897: ARRAY
63898: PUSH
63899: LD_VAR 0 3
63903: ARRAY
63904: PUSH
63905: LD_INT 2
63907: ARRAY
63908: PPUSH
63909: LD_EXP 75
63913: PUSH
63914: LD_VAR 0 2
63918: ARRAY
63919: PUSH
63920: LD_VAR 0 3
63924: ARRAY
63925: PUSH
63926: LD_INT 3
63928: ARRAY
63929: PPUSH
63930: LD_INT 30
63932: PPUSH
63933: CALL 20134 0 4
63937: PUSH
63938: LD_INT 4
63940: ARRAY
63941: PUSH
63942: LD_INT 0
63944: EQUAL
63945: IFFALSE 63971
// begin target := mc_crates [ i ] [ j ] ;
63947: LD_ADDR_VAR 0 6
63951: PUSH
63952: LD_EXP 75
63956: PUSH
63957: LD_VAR 0 2
63961: ARRAY
63962: PUSH
63963: LD_VAR 0 3
63967: ARRAY
63968: ST_TO_ADDR
// break ;
63969: GO 63973
// end ; end ;
63971: GO 63712
63973: POP
63974: POP
// if not target then
63975: LD_VAR 0 6
63979: NOT
63980: IFFALSE 63984
// continue ;
63982: GO 63593
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
63984: LD_ADDR_VAR 0 7
63988: PUSH
63989: LD_EXP 78
63993: PUSH
63994: LD_VAR 0 2
63998: ARRAY
63999: PPUSH
64000: LD_INT 2
64002: PUSH
64003: LD_INT 3
64005: PUSH
64006: LD_INT 58
64008: PUSH
64009: EMPTY
64010: LIST
64011: PUSH
64012: EMPTY
64013: LIST
64014: LIST
64015: PUSH
64016: LD_INT 61
64018: PUSH
64019: EMPTY
64020: LIST
64021: PUSH
64022: LD_INT 33
64024: PUSH
64025: LD_INT 5
64027: PUSH
64028: EMPTY
64029: LIST
64030: LIST
64031: PUSH
64032: LD_INT 33
64034: PUSH
64035: LD_INT 3
64037: PUSH
64038: EMPTY
64039: LIST
64040: LIST
64041: PUSH
64042: EMPTY
64043: LIST
64044: LIST
64045: LIST
64046: LIST
64047: LIST
64048: PUSH
64049: LD_INT 2
64051: PUSH
64052: LD_INT 34
64054: PUSH
64055: LD_INT 32
64057: PUSH
64058: EMPTY
64059: LIST
64060: LIST
64061: PUSH
64062: LD_INT 34
64064: PUSH
64065: LD_INT 51
64067: PUSH
64068: EMPTY
64069: LIST
64070: LIST
64071: PUSH
64072: LD_INT 34
64074: PUSH
64075: LD_INT 12
64077: PUSH
64078: EMPTY
64079: LIST
64080: LIST
64081: PUSH
64082: EMPTY
64083: LIST
64084: LIST
64085: LIST
64086: LIST
64087: PUSH
64088: EMPTY
64089: LIST
64090: LIST
64091: PPUSH
64092: CALL_OW 72
64096: ST_TO_ADDR
// if not cargo then
64097: LD_VAR 0 7
64101: NOT
64102: IFFALSE 64745
// begin if mc_crates_collector [ i ] < 5 then
64104: LD_EXP 76
64108: PUSH
64109: LD_VAR 0 2
64113: ARRAY
64114: PUSH
64115: LD_INT 5
64117: LESS
64118: IFFALSE 64484
// begin if mc_ape [ i ] then
64120: LD_EXP 88
64124: PUSH
64125: LD_VAR 0 2
64129: ARRAY
64130: IFFALSE 64177
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
64132: LD_ADDR_VAR 0 5
64136: PUSH
64137: LD_EXP 88
64141: PUSH
64142: LD_VAR 0 2
64146: ARRAY
64147: PPUSH
64148: LD_INT 25
64150: PUSH
64151: LD_INT 16
64153: PUSH
64154: EMPTY
64155: LIST
64156: LIST
64157: PUSH
64158: LD_INT 24
64160: PUSH
64161: LD_INT 750
64163: PUSH
64164: EMPTY
64165: LIST
64166: LIST
64167: PUSH
64168: EMPTY
64169: LIST
64170: LIST
64171: PPUSH
64172: CALL_OW 72
64176: ST_TO_ADDR
// if not tmp then
64177: LD_VAR 0 5
64181: NOT
64182: IFFALSE 64229
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
64184: LD_ADDR_VAR 0 5
64188: PUSH
64189: LD_EXP 59
64193: PUSH
64194: LD_VAR 0 2
64198: ARRAY
64199: PPUSH
64200: LD_INT 25
64202: PUSH
64203: LD_INT 2
64205: PUSH
64206: EMPTY
64207: LIST
64208: LIST
64209: PUSH
64210: LD_INT 24
64212: PUSH
64213: LD_INT 750
64215: PUSH
64216: EMPTY
64217: LIST
64218: LIST
64219: PUSH
64220: EMPTY
64221: LIST
64222: LIST
64223: PPUSH
64224: CALL_OW 72
64228: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
64229: LD_EXP 88
64233: PUSH
64234: LD_VAR 0 2
64238: ARRAY
64239: PUSH
64240: LD_EXP 59
64244: PUSH
64245: LD_VAR 0 2
64249: ARRAY
64250: PPUSH
64251: LD_INT 25
64253: PUSH
64254: LD_INT 2
64256: PUSH
64257: EMPTY
64258: LIST
64259: LIST
64260: PUSH
64261: LD_INT 24
64263: PUSH
64264: LD_INT 750
64266: PUSH
64267: EMPTY
64268: LIST
64269: LIST
64270: PUSH
64271: EMPTY
64272: LIST
64273: LIST
64274: PPUSH
64275: CALL_OW 72
64279: AND
64280: PUSH
64281: LD_VAR 0 5
64285: PUSH
64286: LD_INT 5
64288: LESS
64289: AND
64290: IFFALSE 64372
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
64292: LD_ADDR_VAR 0 3
64296: PUSH
64297: LD_EXP 59
64301: PUSH
64302: LD_VAR 0 2
64306: ARRAY
64307: PPUSH
64308: LD_INT 25
64310: PUSH
64311: LD_INT 2
64313: PUSH
64314: EMPTY
64315: LIST
64316: LIST
64317: PUSH
64318: LD_INT 24
64320: PUSH
64321: LD_INT 750
64323: PUSH
64324: EMPTY
64325: LIST
64326: LIST
64327: PUSH
64328: EMPTY
64329: LIST
64330: LIST
64331: PPUSH
64332: CALL_OW 72
64336: PUSH
64337: FOR_IN
64338: IFFALSE 64370
// begin tmp := tmp union j ;
64340: LD_ADDR_VAR 0 5
64344: PUSH
64345: LD_VAR 0 5
64349: PUSH
64350: LD_VAR 0 3
64354: UNION
64355: ST_TO_ADDR
// if tmp >= 5 then
64356: LD_VAR 0 5
64360: PUSH
64361: LD_INT 5
64363: GREATEREQUAL
64364: IFFALSE 64368
// break ;
64366: GO 64370
// end ;
64368: GO 64337
64370: POP
64371: POP
// end ; if not tmp then
64372: LD_VAR 0 5
64376: NOT
64377: IFFALSE 64381
// continue ;
64379: GO 63593
// for j in tmp do
64381: LD_ADDR_VAR 0 3
64385: PUSH
64386: LD_VAR 0 5
64390: PUSH
64391: FOR_IN
64392: IFFALSE 64482
// if not GetTag ( j ) then
64394: LD_VAR 0 3
64398: PPUSH
64399: CALL_OW 110
64403: NOT
64404: IFFALSE 64480
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
64406: LD_ADDR_EXP 76
64410: PUSH
64411: LD_EXP 76
64415: PPUSH
64416: LD_VAR 0 2
64420: PUSH
64421: LD_EXP 76
64425: PUSH
64426: LD_VAR 0 2
64430: ARRAY
64431: PUSH
64432: LD_INT 1
64434: PLUS
64435: PUSH
64436: EMPTY
64437: LIST
64438: LIST
64439: PPUSH
64440: LD_VAR 0 3
64444: PPUSH
64445: CALL 19238 0 3
64449: ST_TO_ADDR
// SetTag ( j , 107 ) ;
64450: LD_VAR 0 3
64454: PPUSH
64455: LD_INT 107
64457: PPUSH
64458: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
64462: LD_EXP 76
64466: PUSH
64467: LD_VAR 0 2
64471: ARRAY
64472: PUSH
64473: LD_INT 5
64475: GREATEREQUAL
64476: IFFALSE 64480
// break ;
64478: GO 64482
// end ;
64480: GO 64391
64482: POP
64483: POP
// end ; if mc_crates_collector [ i ] and target then
64484: LD_EXP 76
64488: PUSH
64489: LD_VAR 0 2
64493: ARRAY
64494: PUSH
64495: LD_VAR 0 6
64499: AND
64500: IFFALSE 64743
// begin if mc_crates_collector [ i ] < target [ 1 ] then
64502: LD_EXP 76
64506: PUSH
64507: LD_VAR 0 2
64511: ARRAY
64512: PUSH
64513: LD_VAR 0 6
64517: PUSH
64518: LD_INT 1
64520: ARRAY
64521: LESS
64522: IFFALSE 64542
// tmp := mc_crates_collector [ i ] else
64524: LD_ADDR_VAR 0 5
64528: PUSH
64529: LD_EXP 76
64533: PUSH
64534: LD_VAR 0 2
64538: ARRAY
64539: ST_TO_ADDR
64540: GO 64556
// tmp := target [ 1 ] ;
64542: LD_ADDR_VAR 0 5
64546: PUSH
64547: LD_VAR 0 6
64551: PUSH
64552: LD_INT 1
64554: ARRAY
64555: ST_TO_ADDR
// k := 0 ;
64556: LD_ADDR_VAR 0 4
64560: PUSH
64561: LD_INT 0
64563: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
64564: LD_ADDR_VAR 0 3
64568: PUSH
64569: LD_EXP 76
64573: PUSH
64574: LD_VAR 0 2
64578: ARRAY
64579: PUSH
64580: FOR_IN
64581: IFFALSE 64741
// begin k := k + 1 ;
64583: LD_ADDR_VAR 0 4
64587: PUSH
64588: LD_VAR 0 4
64592: PUSH
64593: LD_INT 1
64595: PLUS
64596: ST_TO_ADDR
// if k > tmp then
64597: LD_VAR 0 4
64601: PUSH
64602: LD_VAR 0 5
64606: GREATER
64607: IFFALSE 64611
// break ;
64609: GO 64741
// if not GetClass ( j ) in [ 2 , 16 ] then
64611: LD_VAR 0 3
64615: PPUSH
64616: CALL_OW 257
64620: PUSH
64621: LD_INT 2
64623: PUSH
64624: LD_INT 16
64626: PUSH
64627: EMPTY
64628: LIST
64629: LIST
64630: IN
64631: NOT
64632: IFFALSE 64685
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
64634: LD_ADDR_EXP 76
64638: PUSH
64639: LD_EXP 76
64643: PPUSH
64644: LD_VAR 0 2
64648: PPUSH
64649: LD_EXP 76
64653: PUSH
64654: LD_VAR 0 2
64658: ARRAY
64659: PUSH
64660: LD_VAR 0 3
64664: DIFF
64665: PPUSH
64666: CALL_OW 1
64670: ST_TO_ADDR
// SetTag ( j , 0 ) ;
64671: LD_VAR 0 3
64675: PPUSH
64676: LD_INT 0
64678: PPUSH
64679: CALL_OW 109
// continue ;
64683: GO 64580
// end ; if IsInUnit ( j ) then
64685: LD_VAR 0 3
64689: PPUSH
64690: CALL_OW 310
64694: IFFALSE 64705
// ComExitBuilding ( j ) ;
64696: LD_VAR 0 3
64700: PPUSH
64701: CALL_OW 122
// wait ( 3 ) ;
64705: LD_INT 3
64707: PPUSH
64708: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
64712: LD_VAR 0 3
64716: PPUSH
64717: LD_VAR 0 6
64721: PUSH
64722: LD_INT 2
64724: ARRAY
64725: PPUSH
64726: LD_VAR 0 6
64730: PUSH
64731: LD_INT 3
64733: ARRAY
64734: PPUSH
64735: CALL_OW 117
// end ;
64739: GO 64580
64741: POP
64742: POP
// end ; end else
64743: GO 65324
// begin for j in cargo do
64745: LD_ADDR_VAR 0 3
64749: PUSH
64750: LD_VAR 0 7
64754: PUSH
64755: FOR_IN
64756: IFFALSE 65322
// begin if GetTag ( j ) <> 0 then
64758: LD_VAR 0 3
64762: PPUSH
64763: CALL_OW 110
64767: PUSH
64768: LD_INT 0
64770: NONEQUAL
64771: IFFALSE 64775
// continue ;
64773: GO 64755
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
64775: LD_VAR 0 3
64779: PPUSH
64780: CALL_OW 256
64784: PUSH
64785: LD_INT 1000
64787: LESS
64788: PUSH
64789: LD_VAR 0 3
64793: PPUSH
64794: LD_EXP 83
64798: PUSH
64799: LD_VAR 0 2
64803: ARRAY
64804: PPUSH
64805: CALL_OW 308
64809: NOT
64810: AND
64811: IFFALSE 64833
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64813: LD_VAR 0 3
64817: PPUSH
64818: LD_EXP 83
64822: PUSH
64823: LD_VAR 0 2
64827: ARRAY
64828: PPUSH
64829: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
64833: LD_VAR 0 3
64837: PPUSH
64838: CALL_OW 256
64842: PUSH
64843: LD_INT 1000
64845: LESS
64846: PUSH
64847: LD_VAR 0 3
64851: PPUSH
64852: LD_EXP 83
64856: PUSH
64857: LD_VAR 0 2
64861: ARRAY
64862: PPUSH
64863: CALL_OW 308
64867: AND
64868: IFFALSE 64872
// continue ;
64870: GO 64755
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
64872: LD_VAR 0 3
64876: PPUSH
64877: CALL_OW 262
64881: PUSH
64882: LD_INT 2
64884: EQUAL
64885: PUSH
64886: LD_VAR 0 3
64890: PPUSH
64891: CALL_OW 261
64895: PUSH
64896: LD_INT 15
64898: LESS
64899: AND
64900: IFFALSE 64904
// continue ;
64902: GO 64755
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
64904: LD_VAR 0 3
64908: PPUSH
64909: CALL_OW 262
64913: PUSH
64914: LD_INT 1
64916: EQUAL
64917: PUSH
64918: LD_VAR 0 3
64922: PPUSH
64923: CALL_OW 261
64927: PUSH
64928: LD_INT 10
64930: LESS
64931: AND
64932: IFFALSE 65261
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64934: LD_ADDR_VAR 0 8
64938: PUSH
64939: LD_EXP 59
64943: PUSH
64944: LD_VAR 0 2
64948: ARRAY
64949: PPUSH
64950: LD_INT 2
64952: PUSH
64953: LD_INT 30
64955: PUSH
64956: LD_INT 0
64958: PUSH
64959: EMPTY
64960: LIST
64961: LIST
64962: PUSH
64963: LD_INT 30
64965: PUSH
64966: LD_INT 1
64968: PUSH
64969: EMPTY
64970: LIST
64971: LIST
64972: PUSH
64973: EMPTY
64974: LIST
64975: LIST
64976: LIST
64977: PPUSH
64978: CALL_OW 72
64982: ST_TO_ADDR
// if not depot then
64983: LD_VAR 0 8
64987: NOT
64988: IFFALSE 64992
// continue ;
64990: GO 64755
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
64992: LD_VAR 0 3
64996: PPUSH
64997: LD_VAR 0 8
65001: PPUSH
65002: LD_VAR 0 3
65006: PPUSH
65007: CALL_OW 74
65011: PPUSH
65012: CALL_OW 296
65016: PUSH
65017: LD_INT 6
65019: LESS
65020: IFFALSE 65036
// SetFuel ( j , 100 ) else
65022: LD_VAR 0 3
65026: PPUSH
65027: LD_INT 100
65029: PPUSH
65030: CALL_OW 240
65034: GO 65261
// if GetFuel ( j ) = 0 then
65036: LD_VAR 0 3
65040: PPUSH
65041: CALL_OW 261
65045: PUSH
65046: LD_INT 0
65048: EQUAL
65049: IFFALSE 65261
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
65051: LD_ADDR_EXP 78
65055: PUSH
65056: LD_EXP 78
65060: PPUSH
65061: LD_VAR 0 2
65065: PPUSH
65066: LD_EXP 78
65070: PUSH
65071: LD_VAR 0 2
65075: ARRAY
65076: PUSH
65077: LD_VAR 0 3
65081: DIFF
65082: PPUSH
65083: CALL_OW 1
65087: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
65088: LD_VAR 0 3
65092: PPUSH
65093: CALL_OW 263
65097: PUSH
65098: LD_INT 1
65100: EQUAL
65101: IFFALSE 65117
// ComExitVehicle ( IsInUnit ( j ) ) ;
65103: LD_VAR 0 3
65107: PPUSH
65108: CALL_OW 310
65112: PPUSH
65113: CALL_OW 121
// if GetControl ( j ) = control_remote then
65117: LD_VAR 0 3
65121: PPUSH
65122: CALL_OW 263
65126: PUSH
65127: LD_INT 2
65129: EQUAL
65130: IFFALSE 65141
// ComUnlink ( j ) ;
65132: LD_VAR 0 3
65136: PPUSH
65137: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
65141: LD_ADDR_VAR 0 9
65145: PUSH
65146: LD_VAR 0 2
65150: PPUSH
65151: LD_INT 3
65153: PPUSH
65154: CALL 74614 0 2
65158: ST_TO_ADDR
// if fac then
65159: LD_VAR 0 9
65163: IFFALSE 65259
// begin for k in fac do
65165: LD_ADDR_VAR 0 4
65169: PUSH
65170: LD_VAR 0 9
65174: PUSH
65175: FOR_IN
65176: IFFALSE 65257
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
65178: LD_ADDR_VAR 0 10
65182: PUSH
65183: LD_VAR 0 9
65187: PPUSH
65188: LD_VAR 0 3
65192: PPUSH
65193: CALL_OW 265
65197: PPUSH
65198: LD_VAR 0 3
65202: PPUSH
65203: CALL_OW 262
65207: PPUSH
65208: LD_VAR 0 3
65212: PPUSH
65213: CALL_OW 263
65217: PPUSH
65218: LD_VAR 0 3
65222: PPUSH
65223: CALL_OW 264
65227: PPUSH
65228: CALL 16770 0 5
65232: ST_TO_ADDR
// if components then
65233: LD_VAR 0 10
65237: IFFALSE 65255
// begin MC_InsertProduceList ( i , components ) ;
65239: LD_VAR 0 2
65243: PPUSH
65244: LD_VAR 0 10
65248: PPUSH
65249: CALL 74159 0 2
// break ;
65253: GO 65257
// end ; end ;
65255: GO 65175
65257: POP
65258: POP
// end ; continue ;
65259: GO 64755
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
65261: LD_VAR 0 3
65265: PPUSH
65266: LD_INT 1
65268: PPUSH
65269: CALL_OW 289
65273: PUSH
65274: LD_INT 100
65276: LESS
65277: PUSH
65278: LD_VAR 0 3
65282: PPUSH
65283: CALL_OW 314
65287: NOT
65288: AND
65289: IFFALSE 65318
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65291: LD_VAR 0 3
65295: PPUSH
65296: LD_VAR 0 6
65300: PUSH
65301: LD_INT 2
65303: ARRAY
65304: PPUSH
65305: LD_VAR 0 6
65309: PUSH
65310: LD_INT 3
65312: ARRAY
65313: PPUSH
65314: CALL_OW 117
// break ;
65318: GO 65322
// end ;
65320: GO 64755
65322: POP
65323: POP
// end ; end ;
65324: GO 63593
65326: POP
65327: POP
// end ;
65328: LD_VAR 0 1
65332: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
65333: LD_INT 0
65335: PPUSH
65336: PPUSH
65337: PPUSH
65338: PPUSH
// if not mc_bases then
65339: LD_EXP 59
65343: NOT
65344: IFFALSE 65348
// exit ;
65346: GO 65509
// for i = 1 to mc_bases do
65348: LD_ADDR_VAR 0 2
65352: PUSH
65353: DOUBLE
65354: LD_INT 1
65356: DEC
65357: ST_TO_ADDR
65358: LD_EXP 59
65362: PUSH
65363: FOR_TO
65364: IFFALSE 65507
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
65366: LD_ADDR_VAR 0 4
65370: PUSH
65371: LD_EXP 78
65375: PUSH
65376: LD_VAR 0 2
65380: ARRAY
65381: PUSH
65382: LD_EXP 81
65386: PUSH
65387: LD_VAR 0 2
65391: ARRAY
65392: UNION
65393: PPUSH
65394: LD_INT 33
65396: PUSH
65397: LD_INT 2
65399: PUSH
65400: EMPTY
65401: LIST
65402: LIST
65403: PPUSH
65404: CALL_OW 72
65408: ST_TO_ADDR
// if tmp then
65409: LD_VAR 0 4
65413: IFFALSE 65505
// for j in tmp do
65415: LD_ADDR_VAR 0 3
65419: PUSH
65420: LD_VAR 0 4
65424: PUSH
65425: FOR_IN
65426: IFFALSE 65503
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
65428: LD_VAR 0 3
65432: PPUSH
65433: CALL_OW 312
65437: NOT
65438: PUSH
65439: LD_VAR 0 3
65443: PPUSH
65444: CALL_OW 256
65448: PUSH
65449: LD_INT 250
65451: GREATEREQUAL
65452: AND
65453: IFFALSE 65466
// Connect ( j ) else
65455: LD_VAR 0 3
65459: PPUSH
65460: CALL 22171 0 1
65464: GO 65501
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
65466: LD_VAR 0 3
65470: PPUSH
65471: CALL_OW 256
65475: PUSH
65476: LD_INT 250
65478: LESS
65479: PUSH
65480: LD_VAR 0 3
65484: PPUSH
65485: CALL_OW 312
65489: AND
65490: IFFALSE 65501
// ComUnlink ( j ) ;
65492: LD_VAR 0 3
65496: PPUSH
65497: CALL_OW 136
65501: GO 65425
65503: POP
65504: POP
// end ;
65505: GO 65363
65507: POP
65508: POP
// end ;
65509: LD_VAR 0 1
65513: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
65514: LD_INT 0
65516: PPUSH
65517: PPUSH
65518: PPUSH
65519: PPUSH
65520: PPUSH
// if not mc_bases then
65521: LD_EXP 59
65525: NOT
65526: IFFALSE 65530
// exit ;
65528: GO 65975
// for i = 1 to mc_bases do
65530: LD_ADDR_VAR 0 2
65534: PUSH
65535: DOUBLE
65536: LD_INT 1
65538: DEC
65539: ST_TO_ADDR
65540: LD_EXP 59
65544: PUSH
65545: FOR_TO
65546: IFFALSE 65973
// begin if not mc_produce [ i ] then
65548: LD_EXP 80
65552: PUSH
65553: LD_VAR 0 2
65557: ARRAY
65558: NOT
65559: IFFALSE 65563
// continue ;
65561: GO 65545
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65563: LD_ADDR_VAR 0 5
65567: PUSH
65568: LD_EXP 59
65572: PUSH
65573: LD_VAR 0 2
65577: ARRAY
65578: PPUSH
65579: LD_INT 30
65581: PUSH
65582: LD_INT 3
65584: PUSH
65585: EMPTY
65586: LIST
65587: LIST
65588: PPUSH
65589: CALL_OW 72
65593: ST_TO_ADDR
// if not fac then
65594: LD_VAR 0 5
65598: NOT
65599: IFFALSE 65603
// continue ;
65601: GO 65545
// for j in fac do
65603: LD_ADDR_VAR 0 3
65607: PUSH
65608: LD_VAR 0 5
65612: PUSH
65613: FOR_IN
65614: IFFALSE 65969
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
65616: LD_VAR 0 3
65620: PPUSH
65621: CALL_OW 461
65625: PUSH
65626: LD_INT 2
65628: NONEQUAL
65629: PUSH
65630: LD_VAR 0 3
65634: PPUSH
65635: LD_INT 15
65637: PPUSH
65638: CALL 21831 0 2
65642: PUSH
65643: LD_INT 4
65645: ARRAY
65646: OR
65647: IFFALSE 65651
// continue ;
65649: GO 65613
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
65651: LD_VAR 0 3
65655: PPUSH
65656: LD_EXP 80
65660: PUSH
65661: LD_VAR 0 2
65665: ARRAY
65666: PUSH
65667: LD_INT 1
65669: ARRAY
65670: PUSH
65671: LD_INT 1
65673: ARRAY
65674: PPUSH
65675: LD_EXP 80
65679: PUSH
65680: LD_VAR 0 2
65684: ARRAY
65685: PUSH
65686: LD_INT 1
65688: ARRAY
65689: PUSH
65690: LD_INT 2
65692: ARRAY
65693: PPUSH
65694: LD_EXP 80
65698: PUSH
65699: LD_VAR 0 2
65703: ARRAY
65704: PUSH
65705: LD_INT 1
65707: ARRAY
65708: PUSH
65709: LD_INT 3
65711: ARRAY
65712: PPUSH
65713: LD_EXP 80
65717: PUSH
65718: LD_VAR 0 2
65722: ARRAY
65723: PUSH
65724: LD_INT 1
65726: ARRAY
65727: PUSH
65728: LD_INT 4
65730: ARRAY
65731: PPUSH
65732: CALL_OW 448
65736: PUSH
65737: LD_VAR 0 3
65741: PPUSH
65742: LD_EXP 80
65746: PUSH
65747: LD_VAR 0 2
65751: ARRAY
65752: PUSH
65753: LD_INT 1
65755: ARRAY
65756: PUSH
65757: LD_INT 1
65759: ARRAY
65760: PUSH
65761: LD_EXP 80
65765: PUSH
65766: LD_VAR 0 2
65770: ARRAY
65771: PUSH
65772: LD_INT 1
65774: ARRAY
65775: PUSH
65776: LD_INT 2
65778: ARRAY
65779: PUSH
65780: LD_EXP 80
65784: PUSH
65785: LD_VAR 0 2
65789: ARRAY
65790: PUSH
65791: LD_INT 1
65793: ARRAY
65794: PUSH
65795: LD_INT 3
65797: ARRAY
65798: PUSH
65799: LD_EXP 80
65803: PUSH
65804: LD_VAR 0 2
65808: ARRAY
65809: PUSH
65810: LD_INT 1
65812: ARRAY
65813: PUSH
65814: LD_INT 4
65816: ARRAY
65817: PUSH
65818: EMPTY
65819: LIST
65820: LIST
65821: LIST
65822: LIST
65823: PPUSH
65824: CALL 25502 0 2
65828: AND
65829: IFFALSE 65967
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
65831: LD_VAR 0 3
65835: PPUSH
65836: LD_EXP 80
65840: PUSH
65841: LD_VAR 0 2
65845: ARRAY
65846: PUSH
65847: LD_INT 1
65849: ARRAY
65850: PUSH
65851: LD_INT 1
65853: ARRAY
65854: PPUSH
65855: LD_EXP 80
65859: PUSH
65860: LD_VAR 0 2
65864: ARRAY
65865: PUSH
65866: LD_INT 1
65868: ARRAY
65869: PUSH
65870: LD_INT 2
65872: ARRAY
65873: PPUSH
65874: LD_EXP 80
65878: PUSH
65879: LD_VAR 0 2
65883: ARRAY
65884: PUSH
65885: LD_INT 1
65887: ARRAY
65888: PUSH
65889: LD_INT 3
65891: ARRAY
65892: PPUSH
65893: LD_EXP 80
65897: PUSH
65898: LD_VAR 0 2
65902: ARRAY
65903: PUSH
65904: LD_INT 1
65906: ARRAY
65907: PUSH
65908: LD_INT 4
65910: ARRAY
65911: PPUSH
65912: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
65916: LD_ADDR_VAR 0 4
65920: PUSH
65921: LD_EXP 80
65925: PUSH
65926: LD_VAR 0 2
65930: ARRAY
65931: PPUSH
65932: LD_INT 1
65934: PPUSH
65935: CALL_OW 3
65939: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
65940: LD_ADDR_EXP 80
65944: PUSH
65945: LD_EXP 80
65949: PPUSH
65950: LD_VAR 0 2
65954: PPUSH
65955: LD_VAR 0 4
65959: PPUSH
65960: CALL_OW 1
65964: ST_TO_ADDR
// break ;
65965: GO 65969
// end ; end ;
65967: GO 65613
65969: POP
65970: POP
// end ;
65971: GO 65545
65973: POP
65974: POP
// end ;
65975: LD_VAR 0 1
65979: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
65980: LD_INT 0
65982: PPUSH
65983: PPUSH
65984: PPUSH
// if not mc_bases then
65985: LD_EXP 59
65989: NOT
65990: IFFALSE 65994
// exit ;
65992: GO 66083
// for i = 1 to mc_bases do
65994: LD_ADDR_VAR 0 2
65998: PUSH
65999: DOUBLE
66000: LD_INT 1
66002: DEC
66003: ST_TO_ADDR
66004: LD_EXP 59
66008: PUSH
66009: FOR_TO
66010: IFFALSE 66081
// begin if mc_attack [ i ] then
66012: LD_EXP 79
66016: PUSH
66017: LD_VAR 0 2
66021: ARRAY
66022: IFFALSE 66079
// begin tmp := mc_attack [ i ] [ 1 ] ;
66024: LD_ADDR_VAR 0 3
66028: PUSH
66029: LD_EXP 79
66033: PUSH
66034: LD_VAR 0 2
66038: ARRAY
66039: PUSH
66040: LD_INT 1
66042: ARRAY
66043: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
66044: LD_ADDR_EXP 79
66048: PUSH
66049: LD_EXP 79
66053: PPUSH
66054: LD_VAR 0 2
66058: PPUSH
66059: EMPTY
66060: PPUSH
66061: CALL_OW 1
66065: ST_TO_ADDR
// Attack ( tmp ) ;
66066: LD_VAR 0 3
66070: PPUSH
66071: CALL 92208 0 1
// exit ;
66075: POP
66076: POP
66077: GO 66083
// end ; end ;
66079: GO 66009
66081: POP
66082: POP
// end ;
66083: LD_VAR 0 1
66087: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
66088: LD_INT 0
66090: PPUSH
66091: PPUSH
66092: PPUSH
66093: PPUSH
66094: PPUSH
66095: PPUSH
66096: PPUSH
// if not mc_bases then
66097: LD_EXP 59
66101: NOT
66102: IFFALSE 66106
// exit ;
66104: GO 66688
// for i = 1 to mc_bases do
66106: LD_ADDR_VAR 0 2
66110: PUSH
66111: DOUBLE
66112: LD_INT 1
66114: DEC
66115: ST_TO_ADDR
66116: LD_EXP 59
66120: PUSH
66121: FOR_TO
66122: IFFALSE 66686
// begin if not mc_bases [ i ] then
66124: LD_EXP 59
66128: PUSH
66129: LD_VAR 0 2
66133: ARRAY
66134: NOT
66135: IFFALSE 66139
// continue ;
66137: GO 66121
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
66139: LD_ADDR_VAR 0 7
66143: PUSH
66144: LD_EXP 59
66148: PUSH
66149: LD_VAR 0 2
66153: ARRAY
66154: PUSH
66155: LD_INT 1
66157: ARRAY
66158: PPUSH
66159: CALL 16074 0 1
66163: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
66164: LD_ADDR_EXP 82
66168: PUSH
66169: LD_EXP 82
66173: PPUSH
66174: LD_VAR 0 2
66178: PPUSH
66179: LD_EXP 59
66183: PUSH
66184: LD_VAR 0 2
66188: ARRAY
66189: PUSH
66190: LD_INT 1
66192: ARRAY
66193: PPUSH
66194: CALL_OW 255
66198: PPUSH
66199: LD_EXP 84
66203: PUSH
66204: LD_VAR 0 2
66208: ARRAY
66209: PPUSH
66210: CALL 16039 0 2
66214: PPUSH
66215: CALL_OW 1
66219: ST_TO_ADDR
// if not mc_scan [ i ] then
66220: LD_EXP 82
66224: PUSH
66225: LD_VAR 0 2
66229: ARRAY
66230: NOT
66231: IFFALSE 66386
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66233: LD_ADDR_VAR 0 4
66237: PUSH
66238: LD_EXP 59
66242: PUSH
66243: LD_VAR 0 2
66247: ARRAY
66248: PPUSH
66249: LD_INT 2
66251: PUSH
66252: LD_INT 25
66254: PUSH
66255: LD_INT 5
66257: PUSH
66258: EMPTY
66259: LIST
66260: LIST
66261: PUSH
66262: LD_INT 25
66264: PUSH
66265: LD_INT 8
66267: PUSH
66268: EMPTY
66269: LIST
66270: LIST
66271: PUSH
66272: LD_INT 25
66274: PUSH
66275: LD_INT 9
66277: PUSH
66278: EMPTY
66279: LIST
66280: LIST
66281: PUSH
66282: EMPTY
66283: LIST
66284: LIST
66285: LIST
66286: LIST
66287: PPUSH
66288: CALL_OW 72
66292: ST_TO_ADDR
// if not tmp then
66293: LD_VAR 0 4
66297: NOT
66298: IFFALSE 66302
// continue ;
66300: GO 66121
// for j in tmp do
66302: LD_ADDR_VAR 0 3
66306: PUSH
66307: LD_VAR 0 4
66311: PUSH
66312: FOR_IN
66313: IFFALSE 66384
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
66315: LD_VAR 0 3
66319: PPUSH
66320: CALL_OW 310
66324: PPUSH
66325: CALL_OW 266
66329: PUSH
66330: LD_INT 5
66332: EQUAL
66333: PUSH
66334: LD_VAR 0 3
66338: PPUSH
66339: CALL_OW 257
66343: PUSH
66344: LD_INT 1
66346: EQUAL
66347: AND
66348: PUSH
66349: LD_VAR 0 3
66353: PPUSH
66354: CALL_OW 459
66358: NOT
66359: AND
66360: PUSH
66361: LD_VAR 0 7
66365: AND
66366: IFFALSE 66382
// ComChangeProfession ( j , class ) ;
66368: LD_VAR 0 3
66372: PPUSH
66373: LD_VAR 0 7
66377: PPUSH
66378: CALL_OW 123
66382: GO 66312
66384: POP
66385: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
66386: LD_EXP 82
66390: PUSH
66391: LD_VAR 0 2
66395: ARRAY
66396: PUSH
66397: LD_EXP 81
66401: PUSH
66402: LD_VAR 0 2
66406: ARRAY
66407: NOT
66408: AND
66409: PUSH
66410: LD_EXP 59
66414: PUSH
66415: LD_VAR 0 2
66419: ARRAY
66420: PPUSH
66421: LD_INT 30
66423: PUSH
66424: LD_INT 32
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PPUSH
66431: CALL_OW 72
66435: NOT
66436: AND
66437: PUSH
66438: LD_EXP 59
66442: PUSH
66443: LD_VAR 0 2
66447: ARRAY
66448: PPUSH
66449: LD_INT 2
66451: PUSH
66452: LD_INT 30
66454: PUSH
66455: LD_INT 4
66457: PUSH
66458: EMPTY
66459: LIST
66460: LIST
66461: PUSH
66462: LD_INT 30
66464: PUSH
66465: LD_INT 5
66467: PUSH
66468: EMPTY
66469: LIST
66470: LIST
66471: PUSH
66472: EMPTY
66473: LIST
66474: LIST
66475: LIST
66476: PPUSH
66477: CALL_OW 72
66481: NOT
66482: AND
66483: IFFALSE 66615
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66485: LD_ADDR_VAR 0 4
66489: PUSH
66490: LD_EXP 59
66494: PUSH
66495: LD_VAR 0 2
66499: ARRAY
66500: PPUSH
66501: LD_INT 2
66503: PUSH
66504: LD_INT 25
66506: PUSH
66507: LD_INT 1
66509: PUSH
66510: EMPTY
66511: LIST
66512: LIST
66513: PUSH
66514: LD_INT 25
66516: PUSH
66517: LD_INT 5
66519: PUSH
66520: EMPTY
66521: LIST
66522: LIST
66523: PUSH
66524: LD_INT 25
66526: PUSH
66527: LD_INT 8
66529: PUSH
66530: EMPTY
66531: LIST
66532: LIST
66533: PUSH
66534: LD_INT 25
66536: PUSH
66537: LD_INT 9
66539: PUSH
66540: EMPTY
66541: LIST
66542: LIST
66543: PUSH
66544: EMPTY
66545: LIST
66546: LIST
66547: LIST
66548: LIST
66549: LIST
66550: PPUSH
66551: CALL_OW 72
66555: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
66556: LD_ADDR_VAR 0 4
66560: PUSH
66561: LD_VAR 0 4
66565: PUSH
66566: LD_VAR 0 4
66570: PPUSH
66571: LD_INT 18
66573: PPUSH
66574: CALL 47799 0 2
66578: DIFF
66579: ST_TO_ADDR
// if tmp then
66580: LD_VAR 0 4
66584: IFFALSE 66615
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
66586: LD_VAR 0 2
66590: PPUSH
66591: LD_VAR 0 4
66595: PPUSH
66596: LD_EXP 84
66600: PUSH
66601: LD_VAR 0 2
66605: ARRAY
66606: PPUSH
66607: CALL 96917 0 3
// exit ;
66611: POP
66612: POP
66613: GO 66688
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
66615: LD_EXP 82
66619: PUSH
66620: LD_VAR 0 2
66624: ARRAY
66625: PUSH
66626: LD_EXP 81
66630: PUSH
66631: LD_VAR 0 2
66635: ARRAY
66636: AND
66637: IFFALSE 66684
// begin tmp := mc_defender [ i ] ;
66639: LD_ADDR_VAR 0 4
66643: PUSH
66644: LD_EXP 81
66648: PUSH
66649: LD_VAR 0 2
66653: ARRAY
66654: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
66655: LD_VAR 0 2
66659: PPUSH
66660: LD_VAR 0 4
66664: PPUSH
66665: LD_EXP 82
66669: PUSH
66670: LD_VAR 0 2
66674: ARRAY
66675: PPUSH
66676: CALL 97478 0 3
// exit ;
66680: POP
66681: POP
66682: GO 66688
// end ; end ;
66684: GO 66121
66686: POP
66687: POP
// end ;
66688: LD_VAR 0 1
66692: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
66693: LD_INT 0
66695: PPUSH
66696: PPUSH
66697: PPUSH
66698: PPUSH
66699: PPUSH
66700: PPUSH
66701: PPUSH
66702: PPUSH
66703: PPUSH
66704: PPUSH
66705: PPUSH
// if not mc_bases then
66706: LD_EXP 59
66710: NOT
66711: IFFALSE 66715
// exit ;
66713: GO 67802
// for i = 1 to mc_bases do
66715: LD_ADDR_VAR 0 2
66719: PUSH
66720: DOUBLE
66721: LD_INT 1
66723: DEC
66724: ST_TO_ADDR
66725: LD_EXP 59
66729: PUSH
66730: FOR_TO
66731: IFFALSE 67800
// begin tmp := mc_lab [ i ] ;
66733: LD_ADDR_VAR 0 6
66737: PUSH
66738: LD_EXP 92
66742: PUSH
66743: LD_VAR 0 2
66747: ARRAY
66748: ST_TO_ADDR
// if not tmp then
66749: LD_VAR 0 6
66753: NOT
66754: IFFALSE 66758
// continue ;
66756: GO 66730
// idle_lab := 0 ;
66758: LD_ADDR_VAR 0 11
66762: PUSH
66763: LD_INT 0
66765: ST_TO_ADDR
// for j in tmp do
66766: LD_ADDR_VAR 0 3
66770: PUSH
66771: LD_VAR 0 6
66775: PUSH
66776: FOR_IN
66777: IFFALSE 67796
// begin researching := false ;
66779: LD_ADDR_VAR 0 10
66783: PUSH
66784: LD_INT 0
66786: ST_TO_ADDR
// side := GetSide ( j ) ;
66787: LD_ADDR_VAR 0 4
66791: PUSH
66792: LD_VAR 0 3
66796: PPUSH
66797: CALL_OW 255
66801: ST_TO_ADDR
// if not mc_tech [ side ] then
66802: LD_EXP 86
66806: PUSH
66807: LD_VAR 0 4
66811: ARRAY
66812: NOT
66813: IFFALSE 66817
// continue ;
66815: GO 66776
// if BuildingStatus ( j ) = bs_idle then
66817: LD_VAR 0 3
66821: PPUSH
66822: CALL_OW 461
66826: PUSH
66827: LD_INT 2
66829: EQUAL
66830: IFFALSE 67018
// begin if idle_lab and UnitsInside ( j ) < 6 then
66832: LD_VAR 0 11
66836: PUSH
66837: LD_VAR 0 3
66841: PPUSH
66842: CALL_OW 313
66846: PUSH
66847: LD_INT 6
66849: LESS
66850: AND
66851: IFFALSE 66922
// begin tmp2 := UnitsInside ( idle_lab ) ;
66853: LD_ADDR_VAR 0 9
66857: PUSH
66858: LD_VAR 0 11
66862: PPUSH
66863: CALL_OW 313
66867: ST_TO_ADDR
// if tmp2 then
66868: LD_VAR 0 9
66872: IFFALSE 66914
// for x in tmp2 do
66874: LD_ADDR_VAR 0 7
66878: PUSH
66879: LD_VAR 0 9
66883: PUSH
66884: FOR_IN
66885: IFFALSE 66912
// begin ComExitBuilding ( x ) ;
66887: LD_VAR 0 7
66891: PPUSH
66892: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
66896: LD_VAR 0 7
66900: PPUSH
66901: LD_VAR 0 3
66905: PPUSH
66906: CALL_OW 180
// end ;
66910: GO 66884
66912: POP
66913: POP
// idle_lab := 0 ;
66914: LD_ADDR_VAR 0 11
66918: PUSH
66919: LD_INT 0
66921: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
66922: LD_ADDR_VAR 0 5
66926: PUSH
66927: LD_EXP 86
66931: PUSH
66932: LD_VAR 0 4
66936: ARRAY
66937: PUSH
66938: FOR_IN
66939: IFFALSE 66999
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
66941: LD_VAR 0 3
66945: PPUSH
66946: LD_VAR 0 5
66950: PPUSH
66951: CALL_OW 430
66955: PUSH
66956: LD_VAR 0 4
66960: PPUSH
66961: LD_VAR 0 5
66965: PPUSH
66966: CALL 15144 0 2
66970: AND
66971: IFFALSE 66997
// begin researching := true ;
66973: LD_ADDR_VAR 0 10
66977: PUSH
66978: LD_INT 1
66980: ST_TO_ADDR
// ComResearch ( j , t ) ;
66981: LD_VAR 0 3
66985: PPUSH
66986: LD_VAR 0 5
66990: PPUSH
66991: CALL_OW 124
// break ;
66995: GO 66999
// end ;
66997: GO 66938
66999: POP
67000: POP
// if not researching then
67001: LD_VAR 0 10
67005: NOT
67006: IFFALSE 67018
// idle_lab := j ;
67008: LD_ADDR_VAR 0 11
67012: PUSH
67013: LD_VAR 0 3
67017: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
67018: LD_VAR 0 3
67022: PPUSH
67023: CALL_OW 461
67027: PUSH
67028: LD_INT 10
67030: EQUAL
67031: IFFALSE 67619
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
67033: LD_EXP 88
67037: PUSH
67038: LD_VAR 0 2
67042: ARRAY
67043: NOT
67044: PUSH
67045: LD_EXP 89
67049: PUSH
67050: LD_VAR 0 2
67054: ARRAY
67055: NOT
67056: AND
67057: PUSH
67058: LD_EXP 86
67062: PUSH
67063: LD_VAR 0 4
67067: ARRAY
67068: PUSH
67069: LD_INT 1
67071: GREATER
67072: AND
67073: IFFALSE 67204
// begin ComCancel ( j ) ;
67075: LD_VAR 0 3
67079: PPUSH
67080: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
67084: LD_ADDR_EXP 86
67088: PUSH
67089: LD_EXP 86
67093: PPUSH
67094: LD_VAR 0 4
67098: PPUSH
67099: LD_EXP 86
67103: PUSH
67104: LD_VAR 0 4
67108: ARRAY
67109: PPUSH
67110: LD_EXP 86
67114: PUSH
67115: LD_VAR 0 4
67119: ARRAY
67120: PUSH
67121: LD_INT 1
67123: MINUS
67124: PPUSH
67125: LD_EXP 86
67129: PUSH
67130: LD_VAR 0 4
67134: ARRAY
67135: PPUSH
67136: LD_INT 0
67138: PPUSH
67139: CALL 18656 0 4
67143: PPUSH
67144: CALL_OW 1
67148: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
67149: LD_ADDR_EXP 86
67153: PUSH
67154: LD_EXP 86
67158: PPUSH
67159: LD_VAR 0 4
67163: PPUSH
67164: LD_EXP 86
67168: PUSH
67169: LD_VAR 0 4
67173: ARRAY
67174: PPUSH
67175: LD_EXP 86
67179: PUSH
67180: LD_VAR 0 4
67184: ARRAY
67185: PPUSH
67186: LD_INT 1
67188: PPUSH
67189: LD_INT 0
67191: PPUSH
67192: CALL 18656 0 4
67196: PPUSH
67197: CALL_OW 1
67201: ST_TO_ADDR
// continue ;
67202: GO 66776
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
67204: LD_EXP 88
67208: PUSH
67209: LD_VAR 0 2
67213: ARRAY
67214: PUSH
67215: LD_EXP 89
67219: PUSH
67220: LD_VAR 0 2
67224: ARRAY
67225: NOT
67226: AND
67227: IFFALSE 67354
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
67229: LD_ADDR_EXP 89
67233: PUSH
67234: LD_EXP 89
67238: PPUSH
67239: LD_VAR 0 2
67243: PUSH
67244: LD_EXP 89
67248: PUSH
67249: LD_VAR 0 2
67253: ARRAY
67254: PUSH
67255: LD_INT 1
67257: PLUS
67258: PUSH
67259: EMPTY
67260: LIST
67261: LIST
67262: PPUSH
67263: LD_EXP 88
67267: PUSH
67268: LD_VAR 0 2
67272: ARRAY
67273: PUSH
67274: LD_INT 1
67276: ARRAY
67277: PPUSH
67278: CALL 19238 0 3
67282: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
67283: LD_EXP 88
67287: PUSH
67288: LD_VAR 0 2
67292: ARRAY
67293: PUSH
67294: LD_INT 1
67296: ARRAY
67297: PPUSH
67298: LD_INT 112
67300: PPUSH
67301: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
67305: LD_ADDR_VAR 0 9
67309: PUSH
67310: LD_EXP 88
67314: PUSH
67315: LD_VAR 0 2
67319: ARRAY
67320: PPUSH
67321: LD_INT 1
67323: PPUSH
67324: CALL_OW 3
67328: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
67329: LD_ADDR_EXP 88
67333: PUSH
67334: LD_EXP 88
67338: PPUSH
67339: LD_VAR 0 2
67343: PPUSH
67344: LD_VAR 0 9
67348: PPUSH
67349: CALL_OW 1
67353: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
67354: LD_EXP 88
67358: PUSH
67359: LD_VAR 0 2
67363: ARRAY
67364: PUSH
67365: LD_EXP 89
67369: PUSH
67370: LD_VAR 0 2
67374: ARRAY
67375: AND
67376: PUSH
67377: LD_EXP 89
67381: PUSH
67382: LD_VAR 0 2
67386: ARRAY
67387: PUSH
67388: LD_INT 1
67390: ARRAY
67391: PPUSH
67392: CALL_OW 310
67396: NOT
67397: AND
67398: PUSH
67399: LD_VAR 0 3
67403: PPUSH
67404: CALL_OW 313
67408: PUSH
67409: LD_INT 6
67411: EQUAL
67412: AND
67413: IFFALSE 67469
// begin tmp2 := UnitsInside ( j ) ;
67415: LD_ADDR_VAR 0 9
67419: PUSH
67420: LD_VAR 0 3
67424: PPUSH
67425: CALL_OW 313
67429: ST_TO_ADDR
// if tmp2 = 6 then
67430: LD_VAR 0 9
67434: PUSH
67435: LD_INT 6
67437: EQUAL
67438: IFFALSE 67469
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
67440: LD_VAR 0 9
67444: PUSH
67445: LD_INT 1
67447: ARRAY
67448: PPUSH
67449: LD_INT 112
67451: PPUSH
67452: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
67456: LD_VAR 0 9
67460: PUSH
67461: LD_INT 1
67463: ARRAY
67464: PPUSH
67465: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
67469: LD_EXP 89
67473: PUSH
67474: LD_VAR 0 2
67478: ARRAY
67479: PUSH
67480: LD_EXP 89
67484: PUSH
67485: LD_VAR 0 2
67489: ARRAY
67490: PUSH
67491: LD_INT 1
67493: ARRAY
67494: PPUSH
67495: CALL_OW 314
67499: NOT
67500: AND
67501: PUSH
67502: LD_EXP 89
67506: PUSH
67507: LD_VAR 0 2
67511: ARRAY
67512: PUSH
67513: LD_INT 1
67515: ARRAY
67516: PPUSH
67517: CALL_OW 310
67521: NOT
67522: AND
67523: IFFALSE 67549
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
67525: LD_EXP 89
67529: PUSH
67530: LD_VAR 0 2
67534: ARRAY
67535: PUSH
67536: LD_INT 1
67538: ARRAY
67539: PPUSH
67540: LD_VAR 0 3
67544: PPUSH
67545: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
67549: LD_EXP 89
67553: PUSH
67554: LD_VAR 0 2
67558: ARRAY
67559: PUSH
67560: LD_INT 1
67562: ARRAY
67563: PPUSH
67564: CALL_OW 310
67568: PUSH
67569: LD_EXP 89
67573: PUSH
67574: LD_VAR 0 2
67578: ARRAY
67579: PUSH
67580: LD_INT 1
67582: ARRAY
67583: PPUSH
67584: CALL_OW 310
67588: PPUSH
67589: CALL_OW 461
67593: PUSH
67594: LD_INT 3
67596: NONEQUAL
67597: AND
67598: IFFALSE 67619
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
67600: LD_EXP 89
67604: PUSH
67605: LD_VAR 0 2
67609: ARRAY
67610: PUSH
67611: LD_INT 1
67613: ARRAY
67614: PPUSH
67615: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
67619: LD_VAR 0 3
67623: PPUSH
67624: CALL_OW 461
67628: PUSH
67629: LD_INT 6
67631: EQUAL
67632: PUSH
67633: LD_VAR 0 6
67637: PUSH
67638: LD_INT 1
67640: GREATER
67641: AND
67642: IFFALSE 67794
// begin sci := [ ] ;
67644: LD_ADDR_VAR 0 8
67648: PUSH
67649: EMPTY
67650: ST_TO_ADDR
// for x in ( tmp diff j ) do
67651: LD_ADDR_VAR 0 7
67655: PUSH
67656: LD_VAR 0 6
67660: PUSH
67661: LD_VAR 0 3
67665: DIFF
67666: PUSH
67667: FOR_IN
67668: IFFALSE 67720
// begin if sci = 6 then
67670: LD_VAR 0 8
67674: PUSH
67675: LD_INT 6
67677: EQUAL
67678: IFFALSE 67682
// break ;
67680: GO 67720
// if BuildingStatus ( x ) = bs_idle then
67682: LD_VAR 0 7
67686: PPUSH
67687: CALL_OW 461
67691: PUSH
67692: LD_INT 2
67694: EQUAL
67695: IFFALSE 67718
// sci := sci ^ UnitsInside ( x ) ;
67697: LD_ADDR_VAR 0 8
67701: PUSH
67702: LD_VAR 0 8
67706: PUSH
67707: LD_VAR 0 7
67711: PPUSH
67712: CALL_OW 313
67716: ADD
67717: ST_TO_ADDR
// end ;
67718: GO 67667
67720: POP
67721: POP
// if not sci then
67722: LD_VAR 0 8
67726: NOT
67727: IFFALSE 67731
// continue ;
67729: GO 66776
// for x in sci do
67731: LD_ADDR_VAR 0 7
67735: PUSH
67736: LD_VAR 0 8
67740: PUSH
67741: FOR_IN
67742: IFFALSE 67792
// if IsInUnit ( x ) and not HasTask ( x ) then
67744: LD_VAR 0 7
67748: PPUSH
67749: CALL_OW 310
67753: PUSH
67754: LD_VAR 0 7
67758: PPUSH
67759: CALL_OW 314
67763: NOT
67764: AND
67765: IFFALSE 67790
// begin ComExitBuilding ( x ) ;
67767: LD_VAR 0 7
67771: PPUSH
67772: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
67776: LD_VAR 0 7
67780: PPUSH
67781: LD_VAR 0 3
67785: PPUSH
67786: CALL_OW 180
// end ;
67790: GO 67741
67792: POP
67793: POP
// end ; end ;
67794: GO 66776
67796: POP
67797: POP
// end ;
67798: GO 66730
67800: POP
67801: POP
// end ;
67802: LD_VAR 0 1
67806: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
67807: LD_INT 0
67809: PPUSH
67810: PPUSH
// if not mc_bases then
67811: LD_EXP 59
67815: NOT
67816: IFFALSE 67820
// exit ;
67818: GO 67901
// for i = 1 to mc_bases do
67820: LD_ADDR_VAR 0 2
67824: PUSH
67825: DOUBLE
67826: LD_INT 1
67828: DEC
67829: ST_TO_ADDR
67830: LD_EXP 59
67834: PUSH
67835: FOR_TO
67836: IFFALSE 67899
// if mc_mines [ i ] and mc_miners [ i ] then
67838: LD_EXP 72
67842: PUSH
67843: LD_VAR 0 2
67847: ARRAY
67848: PUSH
67849: LD_EXP 73
67853: PUSH
67854: LD_VAR 0 2
67858: ARRAY
67859: AND
67860: IFFALSE 67897
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
67862: LD_EXP 73
67866: PUSH
67867: LD_VAR 0 2
67871: ARRAY
67872: PUSH
67873: LD_INT 1
67875: ARRAY
67876: PPUSH
67877: CALL_OW 255
67881: PPUSH
67882: LD_EXP 72
67886: PUSH
67887: LD_VAR 0 2
67891: ARRAY
67892: PPUSH
67893: CALL 16227 0 2
67897: GO 67835
67899: POP
67900: POP
// end ;
67901: LD_VAR 0 1
67905: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
67906: LD_INT 0
67908: PPUSH
67909: PPUSH
67910: PPUSH
67911: PPUSH
67912: PPUSH
67913: PPUSH
67914: PPUSH
67915: PPUSH
// if not mc_bases or not mc_parking then
67916: LD_EXP 59
67920: NOT
67921: PUSH
67922: LD_EXP 83
67926: NOT
67927: OR
67928: IFFALSE 67932
// exit ;
67930: GO 68631
// for i = 1 to mc_bases do
67932: LD_ADDR_VAR 0 2
67936: PUSH
67937: DOUBLE
67938: LD_INT 1
67940: DEC
67941: ST_TO_ADDR
67942: LD_EXP 59
67946: PUSH
67947: FOR_TO
67948: IFFALSE 68629
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
67950: LD_EXP 59
67954: PUSH
67955: LD_VAR 0 2
67959: ARRAY
67960: NOT
67961: PUSH
67962: LD_EXP 83
67966: PUSH
67967: LD_VAR 0 2
67971: ARRAY
67972: NOT
67973: OR
67974: IFFALSE 67978
// continue ;
67976: GO 67947
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
67978: LD_ADDR_VAR 0 5
67982: PUSH
67983: LD_EXP 59
67987: PUSH
67988: LD_VAR 0 2
67992: ARRAY
67993: PUSH
67994: LD_INT 1
67996: ARRAY
67997: PPUSH
67998: CALL_OW 255
68002: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68003: LD_ADDR_VAR 0 6
68007: PUSH
68008: LD_EXP 59
68012: PUSH
68013: LD_VAR 0 2
68017: ARRAY
68018: PPUSH
68019: LD_INT 30
68021: PUSH
68022: LD_INT 3
68024: PUSH
68025: EMPTY
68026: LIST
68027: LIST
68028: PPUSH
68029: CALL_OW 72
68033: ST_TO_ADDR
// if not fac then
68034: LD_VAR 0 6
68038: NOT
68039: IFFALSE 68090
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68041: LD_ADDR_VAR 0 6
68045: PUSH
68046: LD_EXP 59
68050: PUSH
68051: LD_VAR 0 2
68055: ARRAY
68056: PPUSH
68057: LD_INT 2
68059: PUSH
68060: LD_INT 30
68062: PUSH
68063: LD_INT 0
68065: PUSH
68066: EMPTY
68067: LIST
68068: LIST
68069: PUSH
68070: LD_INT 30
68072: PUSH
68073: LD_INT 1
68075: PUSH
68076: EMPTY
68077: LIST
68078: LIST
68079: PUSH
68080: EMPTY
68081: LIST
68082: LIST
68083: LIST
68084: PPUSH
68085: CALL_OW 72
68089: ST_TO_ADDR
// if not fac then
68090: LD_VAR 0 6
68094: NOT
68095: IFFALSE 68099
// continue ;
68097: GO 67947
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68099: LD_ADDR_VAR 0 7
68103: PUSH
68104: LD_EXP 83
68108: PUSH
68109: LD_VAR 0 2
68113: ARRAY
68114: PPUSH
68115: LD_INT 22
68117: PUSH
68118: LD_VAR 0 5
68122: PUSH
68123: EMPTY
68124: LIST
68125: LIST
68126: PUSH
68127: LD_INT 21
68129: PUSH
68130: LD_INT 2
68132: PUSH
68133: EMPTY
68134: LIST
68135: LIST
68136: PUSH
68137: LD_INT 3
68139: PUSH
68140: LD_INT 24
68142: PUSH
68143: LD_INT 1000
68145: PUSH
68146: EMPTY
68147: LIST
68148: LIST
68149: PUSH
68150: EMPTY
68151: LIST
68152: LIST
68153: PUSH
68154: EMPTY
68155: LIST
68156: LIST
68157: LIST
68158: PPUSH
68159: CALL_OW 70
68163: ST_TO_ADDR
// for j in fac do
68164: LD_ADDR_VAR 0 3
68168: PUSH
68169: LD_VAR 0 6
68173: PUSH
68174: FOR_IN
68175: IFFALSE 68256
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68177: LD_ADDR_VAR 0 7
68181: PUSH
68182: LD_VAR 0 7
68186: PUSH
68187: LD_INT 22
68189: PUSH
68190: LD_VAR 0 5
68194: PUSH
68195: EMPTY
68196: LIST
68197: LIST
68198: PUSH
68199: LD_INT 91
68201: PUSH
68202: LD_VAR 0 3
68206: PUSH
68207: LD_INT 15
68209: PUSH
68210: EMPTY
68211: LIST
68212: LIST
68213: LIST
68214: PUSH
68215: LD_INT 21
68217: PUSH
68218: LD_INT 2
68220: PUSH
68221: EMPTY
68222: LIST
68223: LIST
68224: PUSH
68225: LD_INT 3
68227: PUSH
68228: LD_INT 24
68230: PUSH
68231: LD_INT 1000
68233: PUSH
68234: EMPTY
68235: LIST
68236: LIST
68237: PUSH
68238: EMPTY
68239: LIST
68240: LIST
68241: PUSH
68242: EMPTY
68243: LIST
68244: LIST
68245: LIST
68246: LIST
68247: PPUSH
68248: CALL_OW 69
68252: UNION
68253: ST_TO_ADDR
68254: GO 68174
68256: POP
68257: POP
// if not vehs then
68258: LD_VAR 0 7
68262: NOT
68263: IFFALSE 68289
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
68265: LD_ADDR_EXP 71
68269: PUSH
68270: LD_EXP 71
68274: PPUSH
68275: LD_VAR 0 2
68279: PPUSH
68280: EMPTY
68281: PPUSH
68282: CALL_OW 1
68286: ST_TO_ADDR
// continue ;
68287: GO 67947
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68289: LD_ADDR_VAR 0 8
68293: PUSH
68294: LD_EXP 59
68298: PUSH
68299: LD_VAR 0 2
68303: ARRAY
68304: PPUSH
68305: LD_INT 30
68307: PUSH
68308: LD_INT 3
68310: PUSH
68311: EMPTY
68312: LIST
68313: LIST
68314: PPUSH
68315: CALL_OW 72
68319: ST_TO_ADDR
// if tmp then
68320: LD_VAR 0 8
68324: IFFALSE 68427
// begin for j in tmp do
68326: LD_ADDR_VAR 0 3
68330: PUSH
68331: LD_VAR 0 8
68335: PUSH
68336: FOR_IN
68337: IFFALSE 68425
// for k in UnitsInside ( j ) do
68339: LD_ADDR_VAR 0 4
68343: PUSH
68344: LD_VAR 0 3
68348: PPUSH
68349: CALL_OW 313
68353: PUSH
68354: FOR_IN
68355: IFFALSE 68421
// if k then
68357: LD_VAR 0 4
68361: IFFALSE 68419
// if not k in mc_repair_vehicle [ i ] then
68363: LD_VAR 0 4
68367: PUSH
68368: LD_EXP 71
68372: PUSH
68373: LD_VAR 0 2
68377: ARRAY
68378: IN
68379: NOT
68380: IFFALSE 68419
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
68382: LD_ADDR_EXP 71
68386: PUSH
68387: LD_EXP 71
68391: PPUSH
68392: LD_VAR 0 2
68396: PPUSH
68397: LD_EXP 71
68401: PUSH
68402: LD_VAR 0 2
68406: ARRAY
68407: PUSH
68408: LD_VAR 0 4
68412: UNION
68413: PPUSH
68414: CALL_OW 1
68418: ST_TO_ADDR
68419: GO 68354
68421: POP
68422: POP
68423: GO 68336
68425: POP
68426: POP
// end ; if not mc_repair_vehicle [ i ] then
68427: LD_EXP 71
68431: PUSH
68432: LD_VAR 0 2
68436: ARRAY
68437: NOT
68438: IFFALSE 68442
// continue ;
68440: GO 67947
// for j in mc_repair_vehicle [ i ] do
68442: LD_ADDR_VAR 0 3
68446: PUSH
68447: LD_EXP 71
68451: PUSH
68452: LD_VAR 0 2
68456: ARRAY
68457: PUSH
68458: FOR_IN
68459: IFFALSE 68625
// begin if GetClass ( j ) <> 3 then
68461: LD_VAR 0 3
68465: PPUSH
68466: CALL_OW 257
68470: PUSH
68471: LD_INT 3
68473: NONEQUAL
68474: IFFALSE 68515
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
68476: LD_ADDR_EXP 71
68480: PUSH
68481: LD_EXP 71
68485: PPUSH
68486: LD_VAR 0 2
68490: PPUSH
68491: LD_EXP 71
68495: PUSH
68496: LD_VAR 0 2
68500: ARRAY
68501: PUSH
68502: LD_VAR 0 3
68506: DIFF
68507: PPUSH
68508: CALL_OW 1
68512: ST_TO_ADDR
// continue ;
68513: GO 68458
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
68515: LD_VAR 0 3
68519: PPUSH
68520: CALL_OW 311
68524: NOT
68525: PUSH
68526: LD_VAR 0 3
68530: PUSH
68531: LD_EXP 62
68535: PUSH
68536: LD_VAR 0 2
68540: ARRAY
68541: PUSH
68542: LD_INT 1
68544: ARRAY
68545: IN
68546: NOT
68547: AND
68548: PUSH
68549: LD_VAR 0 3
68553: PUSH
68554: LD_EXP 62
68558: PUSH
68559: LD_VAR 0 2
68563: ARRAY
68564: PUSH
68565: LD_INT 2
68567: ARRAY
68568: IN
68569: NOT
68570: AND
68571: IFFALSE 68623
// begin if IsInUnit ( j ) then
68573: LD_VAR 0 3
68577: PPUSH
68578: CALL_OW 310
68582: IFFALSE 68593
// ComExitBuilding ( j ) ;
68584: LD_VAR 0 3
68588: PPUSH
68589: CALL_OW 122
// if not HasTask ( j ) then
68593: LD_VAR 0 3
68597: PPUSH
68598: CALL_OW 314
68602: NOT
68603: IFFALSE 68623
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
68605: LD_VAR 0 3
68609: PPUSH
68610: LD_VAR 0 7
68614: PUSH
68615: LD_INT 1
68617: ARRAY
68618: PPUSH
68619: CALL_OW 189
// end ; end ;
68623: GO 68458
68625: POP
68626: POP
// end ;
68627: GO 67947
68629: POP
68630: POP
// end ;
68631: LD_VAR 0 1
68635: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
68636: LD_INT 0
68638: PPUSH
68639: PPUSH
68640: PPUSH
68641: PPUSH
68642: PPUSH
68643: PPUSH
68644: PPUSH
68645: PPUSH
68646: PPUSH
68647: PPUSH
68648: PPUSH
// if not mc_bases then
68649: LD_EXP 59
68653: NOT
68654: IFFALSE 68658
// exit ;
68656: GO 69460
// for i = 1 to mc_bases do
68658: LD_ADDR_VAR 0 2
68662: PUSH
68663: DOUBLE
68664: LD_INT 1
68666: DEC
68667: ST_TO_ADDR
68668: LD_EXP 59
68672: PUSH
68673: FOR_TO
68674: IFFALSE 69458
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
68676: LD_EXP 87
68680: PUSH
68681: LD_VAR 0 2
68685: ARRAY
68686: NOT
68687: PUSH
68688: LD_EXP 62
68692: PUSH
68693: LD_VAR 0 2
68697: ARRAY
68698: PUSH
68699: LD_INT 1
68701: ARRAY
68702: OR
68703: PUSH
68704: LD_EXP 62
68708: PUSH
68709: LD_VAR 0 2
68713: ARRAY
68714: PUSH
68715: LD_INT 2
68717: ARRAY
68718: OR
68719: PUSH
68720: LD_EXP 85
68724: PUSH
68725: LD_VAR 0 2
68729: ARRAY
68730: PPUSH
68731: LD_INT 1
68733: PPUSH
68734: CALL_OW 325
68738: NOT
68739: OR
68740: PUSH
68741: LD_EXP 82
68745: PUSH
68746: LD_VAR 0 2
68750: ARRAY
68751: OR
68752: IFFALSE 68756
// continue ;
68754: GO 68673
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
68756: LD_ADDR_VAR 0 8
68760: PUSH
68761: LD_EXP 59
68765: PUSH
68766: LD_VAR 0 2
68770: ARRAY
68771: PPUSH
68772: LD_INT 25
68774: PUSH
68775: LD_INT 4
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: PUSH
68782: LD_INT 50
68784: PUSH
68785: EMPTY
68786: LIST
68787: PUSH
68788: LD_INT 3
68790: PUSH
68791: LD_INT 60
68793: PUSH
68794: EMPTY
68795: LIST
68796: PUSH
68797: EMPTY
68798: LIST
68799: LIST
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: LIST
68805: PPUSH
68806: CALL_OW 72
68810: PUSH
68811: LD_EXP 63
68815: PUSH
68816: LD_VAR 0 2
68820: ARRAY
68821: DIFF
68822: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68823: LD_ADDR_VAR 0 9
68827: PUSH
68828: LD_EXP 59
68832: PUSH
68833: LD_VAR 0 2
68837: ARRAY
68838: PPUSH
68839: LD_INT 2
68841: PUSH
68842: LD_INT 30
68844: PUSH
68845: LD_INT 0
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PUSH
68852: LD_INT 30
68854: PUSH
68855: LD_INT 1
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: PUSH
68862: EMPTY
68863: LIST
68864: LIST
68865: LIST
68866: PPUSH
68867: CALL_OW 72
68871: ST_TO_ADDR
// if not tmp or not dep then
68872: LD_VAR 0 8
68876: NOT
68877: PUSH
68878: LD_VAR 0 9
68882: NOT
68883: OR
68884: IFFALSE 68888
// continue ;
68886: GO 68673
// side := GetSide ( tmp [ 1 ] ) ;
68888: LD_ADDR_VAR 0 11
68892: PUSH
68893: LD_VAR 0 8
68897: PUSH
68898: LD_INT 1
68900: ARRAY
68901: PPUSH
68902: CALL_OW 255
68906: ST_TO_ADDR
// dep := dep [ 1 ] ;
68907: LD_ADDR_VAR 0 9
68911: PUSH
68912: LD_VAR 0 9
68916: PUSH
68917: LD_INT 1
68919: ARRAY
68920: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
68921: LD_ADDR_VAR 0 7
68925: PUSH
68926: LD_EXP 87
68930: PUSH
68931: LD_VAR 0 2
68935: ARRAY
68936: PPUSH
68937: LD_INT 22
68939: PUSH
68940: LD_INT 0
68942: PUSH
68943: EMPTY
68944: LIST
68945: LIST
68946: PUSH
68947: LD_INT 25
68949: PUSH
68950: LD_INT 12
68952: PUSH
68953: EMPTY
68954: LIST
68955: LIST
68956: PUSH
68957: EMPTY
68958: LIST
68959: LIST
68960: PPUSH
68961: CALL_OW 70
68965: PUSH
68966: LD_INT 22
68968: PUSH
68969: LD_INT 0
68971: PUSH
68972: EMPTY
68973: LIST
68974: LIST
68975: PUSH
68976: LD_INT 25
68978: PUSH
68979: LD_INT 12
68981: PUSH
68982: EMPTY
68983: LIST
68984: LIST
68985: PUSH
68986: LD_INT 91
68988: PUSH
68989: LD_VAR 0 9
68993: PUSH
68994: LD_INT 20
68996: PUSH
68997: EMPTY
68998: LIST
68999: LIST
69000: LIST
69001: PUSH
69002: EMPTY
69003: LIST
69004: LIST
69005: LIST
69006: PPUSH
69007: CALL_OW 69
69011: UNION
69012: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
69013: LD_ADDR_VAR 0 10
69017: PUSH
69018: LD_EXP 87
69022: PUSH
69023: LD_VAR 0 2
69027: ARRAY
69028: PPUSH
69029: LD_INT 81
69031: PUSH
69032: LD_VAR 0 11
69036: PUSH
69037: EMPTY
69038: LIST
69039: LIST
69040: PPUSH
69041: CALL_OW 70
69045: ST_TO_ADDR
// if not apes or danger_at_area then
69046: LD_VAR 0 7
69050: NOT
69051: PUSH
69052: LD_VAR 0 10
69056: OR
69057: IFFALSE 69107
// begin if mc_taming [ i ] then
69059: LD_EXP 90
69063: PUSH
69064: LD_VAR 0 2
69068: ARRAY
69069: IFFALSE 69105
// begin MC_Reset ( i , 121 ) ;
69071: LD_VAR 0 2
69075: PPUSH
69076: LD_INT 121
69078: PPUSH
69079: CALL 54542 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
69083: LD_ADDR_EXP 90
69087: PUSH
69088: LD_EXP 90
69092: PPUSH
69093: LD_VAR 0 2
69097: PPUSH
69098: EMPTY
69099: PPUSH
69100: CALL_OW 1
69104: ST_TO_ADDR
// end ; continue ;
69105: GO 68673
// end ; for j in tmp do
69107: LD_ADDR_VAR 0 3
69111: PUSH
69112: LD_VAR 0 8
69116: PUSH
69117: FOR_IN
69118: IFFALSE 69454
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
69120: LD_VAR 0 3
69124: PUSH
69125: LD_EXP 90
69129: PUSH
69130: LD_VAR 0 2
69134: ARRAY
69135: IN
69136: NOT
69137: PUSH
69138: LD_EXP 90
69142: PUSH
69143: LD_VAR 0 2
69147: ARRAY
69148: PUSH
69149: LD_INT 3
69151: LESS
69152: AND
69153: IFFALSE 69211
// begin SetTag ( j , 121 ) ;
69155: LD_VAR 0 3
69159: PPUSH
69160: LD_INT 121
69162: PPUSH
69163: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
69167: LD_ADDR_EXP 90
69171: PUSH
69172: LD_EXP 90
69176: PPUSH
69177: LD_VAR 0 2
69181: PUSH
69182: LD_EXP 90
69186: PUSH
69187: LD_VAR 0 2
69191: ARRAY
69192: PUSH
69193: LD_INT 1
69195: PLUS
69196: PUSH
69197: EMPTY
69198: LIST
69199: LIST
69200: PPUSH
69201: LD_VAR 0 3
69205: PPUSH
69206: CALL 19238 0 3
69210: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
69211: LD_VAR 0 3
69215: PUSH
69216: LD_EXP 90
69220: PUSH
69221: LD_VAR 0 2
69225: ARRAY
69226: IN
69227: IFFALSE 69452
// begin if GetClass ( j ) <> 4 then
69229: LD_VAR 0 3
69233: PPUSH
69234: CALL_OW 257
69238: PUSH
69239: LD_INT 4
69241: NONEQUAL
69242: IFFALSE 69295
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
69244: LD_ADDR_EXP 90
69248: PUSH
69249: LD_EXP 90
69253: PPUSH
69254: LD_VAR 0 2
69258: PPUSH
69259: LD_EXP 90
69263: PUSH
69264: LD_VAR 0 2
69268: ARRAY
69269: PUSH
69270: LD_VAR 0 3
69274: DIFF
69275: PPUSH
69276: CALL_OW 1
69280: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69281: LD_VAR 0 3
69285: PPUSH
69286: LD_INT 0
69288: PPUSH
69289: CALL_OW 109
// continue ;
69293: GO 69117
// end ; if IsInUnit ( j ) then
69295: LD_VAR 0 3
69299: PPUSH
69300: CALL_OW 310
69304: IFFALSE 69315
// ComExitBuilding ( j ) ;
69306: LD_VAR 0 3
69310: PPUSH
69311: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
69315: LD_ADDR_VAR 0 6
69319: PUSH
69320: LD_VAR 0 7
69324: PPUSH
69325: LD_VAR 0 3
69329: PPUSH
69330: CALL_OW 74
69334: ST_TO_ADDR
// if not ape then
69335: LD_VAR 0 6
69339: NOT
69340: IFFALSE 69344
// break ;
69342: GO 69454
// x := GetX ( ape ) ;
69344: LD_ADDR_VAR 0 4
69348: PUSH
69349: LD_VAR 0 6
69353: PPUSH
69354: CALL_OW 250
69358: ST_TO_ADDR
// y := GetY ( ape ) ;
69359: LD_ADDR_VAR 0 5
69363: PUSH
69364: LD_VAR 0 6
69368: PPUSH
69369: CALL_OW 251
69373: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
69374: LD_VAR 0 4
69378: PPUSH
69379: LD_VAR 0 5
69383: PPUSH
69384: CALL_OW 488
69388: NOT
69389: PUSH
69390: LD_VAR 0 11
69394: PPUSH
69395: LD_VAR 0 4
69399: PPUSH
69400: LD_VAR 0 5
69404: PPUSH
69405: LD_INT 20
69407: PPUSH
69408: CALL 20134 0 4
69412: PUSH
69413: LD_INT 4
69415: ARRAY
69416: OR
69417: IFFALSE 69421
// break ;
69419: GO 69454
// if not HasTask ( j ) then
69421: LD_VAR 0 3
69425: PPUSH
69426: CALL_OW 314
69430: NOT
69431: IFFALSE 69452
// ComTameXY ( j , x , y ) ;
69433: LD_VAR 0 3
69437: PPUSH
69438: LD_VAR 0 4
69442: PPUSH
69443: LD_VAR 0 5
69447: PPUSH
69448: CALL_OW 131
// end ; end ;
69452: GO 69117
69454: POP
69455: POP
// end ;
69456: GO 68673
69458: POP
69459: POP
// end ;
69460: LD_VAR 0 1
69464: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
69465: LD_INT 0
69467: PPUSH
69468: PPUSH
69469: PPUSH
69470: PPUSH
69471: PPUSH
69472: PPUSH
69473: PPUSH
69474: PPUSH
// if not mc_bases then
69475: LD_EXP 59
69479: NOT
69480: IFFALSE 69484
// exit ;
69482: GO 70110
// for i = 1 to mc_bases do
69484: LD_ADDR_VAR 0 2
69488: PUSH
69489: DOUBLE
69490: LD_INT 1
69492: DEC
69493: ST_TO_ADDR
69494: LD_EXP 59
69498: PUSH
69499: FOR_TO
69500: IFFALSE 70108
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
69502: LD_EXP 88
69506: PUSH
69507: LD_VAR 0 2
69511: ARRAY
69512: NOT
69513: PUSH
69514: LD_EXP 88
69518: PUSH
69519: LD_VAR 0 2
69523: ARRAY
69524: PPUSH
69525: LD_INT 25
69527: PUSH
69528: LD_INT 12
69530: PUSH
69531: EMPTY
69532: LIST
69533: LIST
69534: PPUSH
69535: CALL_OW 72
69539: NOT
69540: OR
69541: IFFALSE 69545
// continue ;
69543: GO 69499
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
69545: LD_ADDR_VAR 0 5
69549: PUSH
69550: LD_EXP 88
69554: PUSH
69555: LD_VAR 0 2
69559: ARRAY
69560: PUSH
69561: LD_INT 1
69563: ARRAY
69564: PPUSH
69565: CALL_OW 255
69569: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
69570: LD_VAR 0 5
69574: PPUSH
69575: LD_INT 2
69577: PPUSH
69578: CALL_OW 325
69582: IFFALSE 69835
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69584: LD_ADDR_VAR 0 4
69588: PUSH
69589: LD_EXP 88
69593: PUSH
69594: LD_VAR 0 2
69598: ARRAY
69599: PPUSH
69600: LD_INT 25
69602: PUSH
69603: LD_INT 16
69605: PUSH
69606: EMPTY
69607: LIST
69608: LIST
69609: PPUSH
69610: CALL_OW 72
69614: ST_TO_ADDR
// if tmp < 6 then
69615: LD_VAR 0 4
69619: PUSH
69620: LD_INT 6
69622: LESS
69623: IFFALSE 69835
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69625: LD_ADDR_VAR 0 6
69629: PUSH
69630: LD_EXP 59
69634: PUSH
69635: LD_VAR 0 2
69639: ARRAY
69640: PPUSH
69641: LD_INT 2
69643: PUSH
69644: LD_INT 30
69646: PUSH
69647: LD_INT 0
69649: PUSH
69650: EMPTY
69651: LIST
69652: LIST
69653: PUSH
69654: LD_INT 30
69656: PUSH
69657: LD_INT 1
69659: PUSH
69660: EMPTY
69661: LIST
69662: LIST
69663: PUSH
69664: EMPTY
69665: LIST
69666: LIST
69667: LIST
69668: PPUSH
69669: CALL_OW 72
69673: ST_TO_ADDR
// if depot then
69674: LD_VAR 0 6
69678: IFFALSE 69835
// begin selected := 0 ;
69680: LD_ADDR_VAR 0 7
69684: PUSH
69685: LD_INT 0
69687: ST_TO_ADDR
// for j in depot do
69688: LD_ADDR_VAR 0 3
69692: PUSH
69693: LD_VAR 0 6
69697: PUSH
69698: FOR_IN
69699: IFFALSE 69730
// begin if UnitsInside ( j ) < 6 then
69701: LD_VAR 0 3
69705: PPUSH
69706: CALL_OW 313
69710: PUSH
69711: LD_INT 6
69713: LESS
69714: IFFALSE 69728
// begin selected := j ;
69716: LD_ADDR_VAR 0 7
69720: PUSH
69721: LD_VAR 0 3
69725: ST_TO_ADDR
// break ;
69726: GO 69730
// end ; end ;
69728: GO 69698
69730: POP
69731: POP
// if selected then
69732: LD_VAR 0 7
69736: IFFALSE 69835
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
69738: LD_ADDR_VAR 0 3
69742: PUSH
69743: LD_EXP 88
69747: PUSH
69748: LD_VAR 0 2
69752: ARRAY
69753: PPUSH
69754: LD_INT 25
69756: PUSH
69757: LD_INT 12
69759: PUSH
69760: EMPTY
69761: LIST
69762: LIST
69763: PPUSH
69764: CALL_OW 72
69768: PUSH
69769: FOR_IN
69770: IFFALSE 69833
// if not HasTask ( j ) then
69772: LD_VAR 0 3
69776: PPUSH
69777: CALL_OW 314
69781: NOT
69782: IFFALSE 69831
// begin if not IsInUnit ( j ) then
69784: LD_VAR 0 3
69788: PPUSH
69789: CALL_OW 310
69793: NOT
69794: IFFALSE 69810
// ComEnterUnit ( j , selected ) ;
69796: LD_VAR 0 3
69800: PPUSH
69801: LD_VAR 0 7
69805: PPUSH
69806: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
69810: LD_VAR 0 3
69814: PPUSH
69815: LD_INT 16
69817: PPUSH
69818: CALL_OW 183
// AddComExitBuilding ( j ) ;
69822: LD_VAR 0 3
69826: PPUSH
69827: CALL_OW 182
// end ;
69831: GO 69769
69833: POP
69834: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
69835: LD_VAR 0 5
69839: PPUSH
69840: LD_INT 11
69842: PPUSH
69843: CALL_OW 325
69847: IFFALSE 70106
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69849: LD_ADDR_VAR 0 4
69853: PUSH
69854: LD_EXP 88
69858: PUSH
69859: LD_VAR 0 2
69863: ARRAY
69864: PPUSH
69865: LD_INT 25
69867: PUSH
69868: LD_INT 16
69870: PUSH
69871: EMPTY
69872: LIST
69873: LIST
69874: PPUSH
69875: CALL_OW 72
69879: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
69880: LD_VAR 0 4
69884: PUSH
69885: LD_INT 6
69887: GREATEREQUAL
69888: PUSH
69889: LD_VAR 0 5
69893: PPUSH
69894: LD_INT 2
69896: PPUSH
69897: CALL_OW 325
69901: NOT
69902: OR
69903: IFFALSE 70106
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
69905: LD_ADDR_VAR 0 8
69909: PUSH
69910: LD_EXP 59
69914: PUSH
69915: LD_VAR 0 2
69919: ARRAY
69920: PPUSH
69921: LD_INT 2
69923: PUSH
69924: LD_INT 30
69926: PUSH
69927: LD_INT 4
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: PUSH
69934: LD_INT 30
69936: PUSH
69937: LD_INT 5
69939: PUSH
69940: EMPTY
69941: LIST
69942: LIST
69943: PUSH
69944: EMPTY
69945: LIST
69946: LIST
69947: LIST
69948: PPUSH
69949: CALL_OW 72
69953: ST_TO_ADDR
// if barracks then
69954: LD_VAR 0 8
69958: IFFALSE 70106
// begin selected := 0 ;
69960: LD_ADDR_VAR 0 7
69964: PUSH
69965: LD_INT 0
69967: ST_TO_ADDR
// for j in barracks do
69968: LD_ADDR_VAR 0 3
69972: PUSH
69973: LD_VAR 0 8
69977: PUSH
69978: FOR_IN
69979: IFFALSE 70010
// begin if UnitsInside ( j ) < 6 then
69981: LD_VAR 0 3
69985: PPUSH
69986: CALL_OW 313
69990: PUSH
69991: LD_INT 6
69993: LESS
69994: IFFALSE 70008
// begin selected := j ;
69996: LD_ADDR_VAR 0 7
70000: PUSH
70001: LD_VAR 0 3
70005: ST_TO_ADDR
// break ;
70006: GO 70010
// end ; end ;
70008: GO 69978
70010: POP
70011: POP
// if selected then
70012: LD_VAR 0 7
70016: IFFALSE 70106
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70018: LD_ADDR_VAR 0 3
70022: PUSH
70023: LD_EXP 88
70027: PUSH
70028: LD_VAR 0 2
70032: ARRAY
70033: PPUSH
70034: LD_INT 25
70036: PUSH
70037: LD_INT 12
70039: PUSH
70040: EMPTY
70041: LIST
70042: LIST
70043: PPUSH
70044: CALL_OW 72
70048: PUSH
70049: FOR_IN
70050: IFFALSE 70104
// if not IsInUnit ( j ) and not HasTask ( j ) then
70052: LD_VAR 0 3
70056: PPUSH
70057: CALL_OW 310
70061: NOT
70062: PUSH
70063: LD_VAR 0 3
70067: PPUSH
70068: CALL_OW 314
70072: NOT
70073: AND
70074: IFFALSE 70102
// begin ComEnterUnit ( j , selected ) ;
70076: LD_VAR 0 3
70080: PPUSH
70081: LD_VAR 0 7
70085: PPUSH
70086: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
70090: LD_VAR 0 3
70094: PPUSH
70095: LD_INT 15
70097: PPUSH
70098: CALL_OW 183
// end ;
70102: GO 70049
70104: POP
70105: POP
// end ; end ; end ; end ; end ;
70106: GO 69499
70108: POP
70109: POP
// end ;
70110: LD_VAR 0 1
70114: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
70115: LD_INT 0
70117: PPUSH
70118: PPUSH
70119: PPUSH
70120: PPUSH
// if not mc_bases then
70121: LD_EXP 59
70125: NOT
70126: IFFALSE 70130
// exit ;
70128: GO 70308
// for i = 1 to mc_bases do
70130: LD_ADDR_VAR 0 2
70134: PUSH
70135: DOUBLE
70136: LD_INT 1
70138: DEC
70139: ST_TO_ADDR
70140: LD_EXP 59
70144: PUSH
70145: FOR_TO
70146: IFFALSE 70306
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
70148: LD_ADDR_VAR 0 4
70152: PUSH
70153: LD_EXP 59
70157: PUSH
70158: LD_VAR 0 2
70162: ARRAY
70163: PPUSH
70164: LD_INT 25
70166: PUSH
70167: LD_INT 9
70169: PUSH
70170: EMPTY
70171: LIST
70172: LIST
70173: PPUSH
70174: CALL_OW 72
70178: ST_TO_ADDR
// if not tmp then
70179: LD_VAR 0 4
70183: NOT
70184: IFFALSE 70188
// continue ;
70186: GO 70145
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
70188: LD_EXP 85
70192: PUSH
70193: LD_VAR 0 2
70197: ARRAY
70198: PPUSH
70199: LD_INT 29
70201: PPUSH
70202: CALL_OW 325
70206: NOT
70207: PUSH
70208: LD_EXP 85
70212: PUSH
70213: LD_VAR 0 2
70217: ARRAY
70218: PPUSH
70219: LD_INT 28
70221: PPUSH
70222: CALL_OW 325
70226: NOT
70227: AND
70228: IFFALSE 70232
// continue ;
70230: GO 70145
// for j in tmp do
70232: LD_ADDR_VAR 0 3
70236: PUSH
70237: LD_VAR 0 4
70241: PUSH
70242: FOR_IN
70243: IFFALSE 70302
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70245: LD_VAR 0 3
70249: PUSH
70250: LD_EXP 62
70254: PUSH
70255: LD_VAR 0 2
70259: ARRAY
70260: PUSH
70261: LD_INT 1
70263: ARRAY
70264: IN
70265: NOT
70266: PUSH
70267: LD_VAR 0 3
70271: PUSH
70272: LD_EXP 62
70276: PUSH
70277: LD_VAR 0 2
70281: ARRAY
70282: PUSH
70283: LD_INT 2
70285: ARRAY
70286: IN
70287: NOT
70288: AND
70289: IFFALSE 70300
// ComSpaceTimeShoot ( j ) ;
70291: LD_VAR 0 3
70295: PPUSH
70296: CALL 15235 0 1
70300: GO 70242
70302: POP
70303: POP
// end ;
70304: GO 70145
70306: POP
70307: POP
// end ;
70308: LD_VAR 0 1
70312: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
70313: LD_INT 0
70315: PPUSH
70316: PPUSH
70317: PPUSH
70318: PPUSH
70319: PPUSH
70320: PPUSH
70321: PPUSH
70322: PPUSH
70323: PPUSH
// if not mc_bases then
70324: LD_EXP 59
70328: NOT
70329: IFFALSE 70333
// exit ;
70331: GO 70955
// for i = 1 to mc_bases do
70333: LD_ADDR_VAR 0 2
70337: PUSH
70338: DOUBLE
70339: LD_INT 1
70341: DEC
70342: ST_TO_ADDR
70343: LD_EXP 59
70347: PUSH
70348: FOR_TO
70349: IFFALSE 70953
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
70351: LD_EXP 94
70355: PUSH
70356: LD_VAR 0 2
70360: ARRAY
70361: NOT
70362: PUSH
70363: LD_INT 38
70365: PPUSH
70366: LD_EXP 85
70370: PUSH
70371: LD_VAR 0 2
70375: ARRAY
70376: PPUSH
70377: CALL_OW 321
70381: PUSH
70382: LD_INT 2
70384: NONEQUAL
70385: OR
70386: IFFALSE 70390
// continue ;
70388: GO 70348
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
70390: LD_ADDR_VAR 0 8
70394: PUSH
70395: LD_EXP 59
70399: PUSH
70400: LD_VAR 0 2
70404: ARRAY
70405: PPUSH
70406: LD_INT 30
70408: PUSH
70409: LD_INT 34
70411: PUSH
70412: EMPTY
70413: LIST
70414: LIST
70415: PPUSH
70416: CALL_OW 72
70420: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
70421: LD_ADDR_VAR 0 9
70425: PUSH
70426: LD_EXP 59
70430: PUSH
70431: LD_VAR 0 2
70435: ARRAY
70436: PPUSH
70437: LD_INT 25
70439: PUSH
70440: LD_INT 4
70442: PUSH
70443: EMPTY
70444: LIST
70445: LIST
70446: PPUSH
70447: CALL_OW 72
70451: PPUSH
70452: LD_INT 0
70454: PPUSH
70455: CALL 47799 0 2
70459: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
70460: LD_VAR 0 9
70464: NOT
70465: PUSH
70466: LD_VAR 0 8
70470: NOT
70471: OR
70472: PUSH
70473: LD_EXP 59
70477: PUSH
70478: LD_VAR 0 2
70482: ARRAY
70483: PPUSH
70484: LD_INT 124
70486: PPUSH
70487: CALL 47799 0 2
70491: OR
70492: IFFALSE 70496
// continue ;
70494: GO 70348
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
70496: LD_EXP 95
70500: PUSH
70501: LD_VAR 0 2
70505: ARRAY
70506: PUSH
70507: LD_EXP 94
70511: PUSH
70512: LD_VAR 0 2
70516: ARRAY
70517: LESS
70518: PUSH
70519: LD_EXP 95
70523: PUSH
70524: LD_VAR 0 2
70528: ARRAY
70529: PUSH
70530: LD_VAR 0 8
70534: LESS
70535: AND
70536: IFFALSE 70951
// begin tmp := sci [ 1 ] ;
70538: LD_ADDR_VAR 0 7
70542: PUSH
70543: LD_VAR 0 9
70547: PUSH
70548: LD_INT 1
70550: ARRAY
70551: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
70552: LD_VAR 0 7
70556: PPUSH
70557: LD_INT 124
70559: PPUSH
70560: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
70564: LD_ADDR_VAR 0 3
70568: PUSH
70569: DOUBLE
70570: LD_EXP 94
70574: PUSH
70575: LD_VAR 0 2
70579: ARRAY
70580: INC
70581: ST_TO_ADDR
70582: LD_EXP 94
70586: PUSH
70587: LD_VAR 0 2
70591: ARRAY
70592: PUSH
70593: FOR_DOWNTO
70594: IFFALSE 70937
// begin if IsInUnit ( tmp ) then
70596: LD_VAR 0 7
70600: PPUSH
70601: CALL_OW 310
70605: IFFALSE 70616
// ComExitBuilding ( tmp ) ;
70607: LD_VAR 0 7
70611: PPUSH
70612: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
70616: LD_INT 35
70618: PPUSH
70619: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
70623: LD_VAR 0 7
70627: PPUSH
70628: CALL_OW 310
70632: NOT
70633: PUSH
70634: LD_VAR 0 7
70638: PPUSH
70639: CALL_OW 314
70643: NOT
70644: AND
70645: IFFALSE 70616
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
70647: LD_ADDR_VAR 0 6
70651: PUSH
70652: LD_VAR 0 7
70656: PPUSH
70657: CALL_OW 250
70661: PUSH
70662: LD_VAR 0 7
70666: PPUSH
70667: CALL_OW 251
70671: PUSH
70672: EMPTY
70673: LIST
70674: LIST
70675: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
70676: LD_INT 35
70678: PPUSH
70679: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
70683: LD_ADDR_VAR 0 4
70687: PUSH
70688: LD_EXP 94
70692: PUSH
70693: LD_VAR 0 2
70697: ARRAY
70698: PUSH
70699: LD_VAR 0 3
70703: ARRAY
70704: PUSH
70705: LD_INT 1
70707: ARRAY
70708: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
70709: LD_ADDR_VAR 0 5
70713: PUSH
70714: LD_EXP 94
70718: PUSH
70719: LD_VAR 0 2
70723: ARRAY
70724: PUSH
70725: LD_VAR 0 3
70729: ARRAY
70730: PUSH
70731: LD_INT 2
70733: ARRAY
70734: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
70735: LD_VAR 0 7
70739: PPUSH
70740: LD_INT 10
70742: PPUSH
70743: CALL 21831 0 2
70747: PUSH
70748: LD_INT 4
70750: ARRAY
70751: IFFALSE 70789
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
70753: LD_VAR 0 7
70757: PPUSH
70758: LD_VAR 0 6
70762: PUSH
70763: LD_INT 1
70765: ARRAY
70766: PPUSH
70767: LD_VAR 0 6
70771: PUSH
70772: LD_INT 2
70774: ARRAY
70775: PPUSH
70776: CALL_OW 111
// wait ( 0 0$10 ) ;
70780: LD_INT 350
70782: PPUSH
70783: CALL_OW 67
// end else
70787: GO 70815
// begin ComMoveXY ( tmp , x , y ) ;
70789: LD_VAR 0 7
70793: PPUSH
70794: LD_VAR 0 4
70798: PPUSH
70799: LD_VAR 0 5
70803: PPUSH
70804: CALL_OW 111
// wait ( 0 0$3 ) ;
70808: LD_INT 105
70810: PPUSH
70811: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
70815: LD_VAR 0 7
70819: PPUSH
70820: LD_VAR 0 4
70824: PPUSH
70825: LD_VAR 0 5
70829: PPUSH
70830: CALL_OW 307
70834: IFFALSE 70676
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
70836: LD_VAR 0 7
70840: PPUSH
70841: LD_VAR 0 4
70845: PPUSH
70846: LD_VAR 0 5
70850: PPUSH
70851: LD_VAR 0 8
70855: PUSH
70856: LD_VAR 0 3
70860: ARRAY
70861: PPUSH
70862: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
70866: LD_INT 35
70868: PPUSH
70869: CALL_OW 67
// until not HasTask ( tmp ) ;
70873: LD_VAR 0 7
70877: PPUSH
70878: CALL_OW 314
70882: NOT
70883: IFFALSE 70866
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
70885: LD_ADDR_EXP 95
70889: PUSH
70890: LD_EXP 95
70894: PPUSH
70895: LD_VAR 0 2
70899: PUSH
70900: LD_EXP 95
70904: PUSH
70905: LD_VAR 0 2
70909: ARRAY
70910: PUSH
70911: LD_INT 1
70913: PLUS
70914: PUSH
70915: EMPTY
70916: LIST
70917: LIST
70918: PPUSH
70919: LD_VAR 0 8
70923: PUSH
70924: LD_VAR 0 3
70928: ARRAY
70929: PPUSH
70930: CALL 19238 0 3
70934: ST_TO_ADDR
// end ;
70935: GO 70593
70937: POP
70938: POP
// MC_Reset ( i , 124 ) ;
70939: LD_VAR 0 2
70943: PPUSH
70944: LD_INT 124
70946: PPUSH
70947: CALL 54542 0 2
// end ; end ;
70951: GO 70348
70953: POP
70954: POP
// end ;
70955: LD_VAR 0 1
70959: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
70960: LD_INT 0
70962: PPUSH
70963: PPUSH
70964: PPUSH
// if not mc_bases then
70965: LD_EXP 59
70969: NOT
70970: IFFALSE 70974
// exit ;
70972: GO 71580
// for i = 1 to mc_bases do
70974: LD_ADDR_VAR 0 2
70978: PUSH
70979: DOUBLE
70980: LD_INT 1
70982: DEC
70983: ST_TO_ADDR
70984: LD_EXP 59
70988: PUSH
70989: FOR_TO
70990: IFFALSE 71578
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
70992: LD_ADDR_VAR 0 3
70996: PUSH
70997: LD_EXP 59
71001: PUSH
71002: LD_VAR 0 2
71006: ARRAY
71007: PPUSH
71008: LD_INT 25
71010: PUSH
71011: LD_INT 4
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PPUSH
71018: CALL_OW 72
71022: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
71023: LD_VAR 0 3
71027: NOT
71028: PUSH
71029: LD_EXP 96
71033: PUSH
71034: LD_VAR 0 2
71038: ARRAY
71039: NOT
71040: OR
71041: PUSH
71042: LD_EXP 59
71046: PUSH
71047: LD_VAR 0 2
71051: ARRAY
71052: PPUSH
71053: LD_INT 2
71055: PUSH
71056: LD_INT 30
71058: PUSH
71059: LD_INT 0
71061: PUSH
71062: EMPTY
71063: LIST
71064: LIST
71065: PUSH
71066: LD_INT 30
71068: PUSH
71069: LD_INT 1
71071: PUSH
71072: EMPTY
71073: LIST
71074: LIST
71075: PUSH
71076: EMPTY
71077: LIST
71078: LIST
71079: LIST
71080: PPUSH
71081: CALL_OW 72
71085: NOT
71086: OR
71087: IFFALSE 71137
// begin if mc_deposits_finder [ i ] then
71089: LD_EXP 97
71093: PUSH
71094: LD_VAR 0 2
71098: ARRAY
71099: IFFALSE 71135
// begin MC_Reset ( i , 125 ) ;
71101: LD_VAR 0 2
71105: PPUSH
71106: LD_INT 125
71108: PPUSH
71109: CALL 54542 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71113: LD_ADDR_EXP 97
71117: PUSH
71118: LD_EXP 97
71122: PPUSH
71123: LD_VAR 0 2
71127: PPUSH
71128: EMPTY
71129: PPUSH
71130: CALL_OW 1
71134: ST_TO_ADDR
// end ; continue ;
71135: GO 70989
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
71137: LD_EXP 96
71141: PUSH
71142: LD_VAR 0 2
71146: ARRAY
71147: PUSH
71148: LD_INT 1
71150: ARRAY
71151: PUSH
71152: LD_INT 3
71154: ARRAY
71155: PUSH
71156: LD_INT 1
71158: EQUAL
71159: PUSH
71160: LD_INT 20
71162: PPUSH
71163: LD_EXP 85
71167: PUSH
71168: LD_VAR 0 2
71172: ARRAY
71173: PPUSH
71174: CALL_OW 321
71178: PUSH
71179: LD_INT 2
71181: NONEQUAL
71182: AND
71183: IFFALSE 71233
// begin if mc_deposits_finder [ i ] then
71185: LD_EXP 97
71189: PUSH
71190: LD_VAR 0 2
71194: ARRAY
71195: IFFALSE 71231
// begin MC_Reset ( i , 125 ) ;
71197: LD_VAR 0 2
71201: PPUSH
71202: LD_INT 125
71204: PPUSH
71205: CALL 54542 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71209: LD_ADDR_EXP 97
71213: PUSH
71214: LD_EXP 97
71218: PPUSH
71219: LD_VAR 0 2
71223: PPUSH
71224: EMPTY
71225: PPUSH
71226: CALL_OW 1
71230: ST_TO_ADDR
// end ; continue ;
71231: GO 70989
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
71233: LD_EXP 96
71237: PUSH
71238: LD_VAR 0 2
71242: ARRAY
71243: PUSH
71244: LD_INT 1
71246: ARRAY
71247: PUSH
71248: LD_INT 1
71250: ARRAY
71251: PPUSH
71252: LD_EXP 96
71256: PUSH
71257: LD_VAR 0 2
71261: ARRAY
71262: PUSH
71263: LD_INT 1
71265: ARRAY
71266: PUSH
71267: LD_INT 2
71269: ARRAY
71270: PPUSH
71271: LD_EXP 85
71275: PUSH
71276: LD_VAR 0 2
71280: ARRAY
71281: PPUSH
71282: CALL_OW 440
71286: IFFALSE 71329
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
71288: LD_ADDR_EXP 96
71292: PUSH
71293: LD_EXP 96
71297: PPUSH
71298: LD_VAR 0 2
71302: PPUSH
71303: LD_EXP 96
71307: PUSH
71308: LD_VAR 0 2
71312: ARRAY
71313: PPUSH
71314: LD_INT 1
71316: PPUSH
71317: CALL_OW 3
71321: PPUSH
71322: CALL_OW 1
71326: ST_TO_ADDR
71327: GO 71576
// begin if not mc_deposits_finder [ i ] then
71329: LD_EXP 97
71333: PUSH
71334: LD_VAR 0 2
71338: ARRAY
71339: NOT
71340: IFFALSE 71392
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
71342: LD_ADDR_EXP 97
71346: PUSH
71347: LD_EXP 97
71351: PPUSH
71352: LD_VAR 0 2
71356: PPUSH
71357: LD_VAR 0 3
71361: PUSH
71362: LD_INT 1
71364: ARRAY
71365: PUSH
71366: EMPTY
71367: LIST
71368: PPUSH
71369: CALL_OW 1
71373: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
71374: LD_VAR 0 3
71378: PUSH
71379: LD_INT 1
71381: ARRAY
71382: PPUSH
71383: LD_INT 125
71385: PPUSH
71386: CALL_OW 109
// end else
71390: GO 71576
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
71392: LD_EXP 97
71396: PUSH
71397: LD_VAR 0 2
71401: ARRAY
71402: PUSH
71403: LD_INT 1
71405: ARRAY
71406: PPUSH
71407: CALL_OW 310
71411: IFFALSE 71434
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
71413: LD_EXP 97
71417: PUSH
71418: LD_VAR 0 2
71422: ARRAY
71423: PUSH
71424: LD_INT 1
71426: ARRAY
71427: PPUSH
71428: CALL_OW 122
71432: GO 71576
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
71434: LD_EXP 97
71438: PUSH
71439: LD_VAR 0 2
71443: ARRAY
71444: PUSH
71445: LD_INT 1
71447: ARRAY
71448: PPUSH
71449: CALL_OW 314
71453: NOT
71454: PUSH
71455: LD_EXP 97
71459: PUSH
71460: LD_VAR 0 2
71464: ARRAY
71465: PUSH
71466: LD_INT 1
71468: ARRAY
71469: PPUSH
71470: LD_EXP 96
71474: PUSH
71475: LD_VAR 0 2
71479: ARRAY
71480: PUSH
71481: LD_INT 1
71483: ARRAY
71484: PUSH
71485: LD_INT 1
71487: ARRAY
71488: PPUSH
71489: LD_EXP 96
71493: PUSH
71494: LD_VAR 0 2
71498: ARRAY
71499: PUSH
71500: LD_INT 1
71502: ARRAY
71503: PUSH
71504: LD_INT 2
71506: ARRAY
71507: PPUSH
71508: CALL_OW 297
71512: PUSH
71513: LD_INT 6
71515: GREATER
71516: AND
71517: IFFALSE 71576
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
71519: LD_EXP 97
71523: PUSH
71524: LD_VAR 0 2
71528: ARRAY
71529: PUSH
71530: LD_INT 1
71532: ARRAY
71533: PPUSH
71534: LD_EXP 96
71538: PUSH
71539: LD_VAR 0 2
71543: ARRAY
71544: PUSH
71545: LD_INT 1
71547: ARRAY
71548: PUSH
71549: LD_INT 1
71551: ARRAY
71552: PPUSH
71553: LD_EXP 96
71557: PUSH
71558: LD_VAR 0 2
71562: ARRAY
71563: PUSH
71564: LD_INT 1
71566: ARRAY
71567: PUSH
71568: LD_INT 2
71570: ARRAY
71571: PPUSH
71572: CALL_OW 111
// end ; end ; end ;
71576: GO 70989
71578: POP
71579: POP
// end ;
71580: LD_VAR 0 1
71584: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
71585: LD_INT 0
71587: PPUSH
71588: PPUSH
71589: PPUSH
71590: PPUSH
71591: PPUSH
71592: PPUSH
71593: PPUSH
71594: PPUSH
71595: PPUSH
71596: PPUSH
71597: PPUSH
// if not mc_bases then
71598: LD_EXP 59
71602: NOT
71603: IFFALSE 71607
// exit ;
71605: GO 72547
// for i = 1 to mc_bases do
71607: LD_ADDR_VAR 0 2
71611: PUSH
71612: DOUBLE
71613: LD_INT 1
71615: DEC
71616: ST_TO_ADDR
71617: LD_EXP 59
71621: PUSH
71622: FOR_TO
71623: IFFALSE 72545
// begin if not mc_bases [ i ] or mc_scan [ i ] then
71625: LD_EXP 59
71629: PUSH
71630: LD_VAR 0 2
71634: ARRAY
71635: NOT
71636: PUSH
71637: LD_EXP 82
71641: PUSH
71642: LD_VAR 0 2
71646: ARRAY
71647: OR
71648: IFFALSE 71652
// continue ;
71650: GO 71622
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
71652: LD_ADDR_VAR 0 7
71656: PUSH
71657: LD_EXP 59
71661: PUSH
71662: LD_VAR 0 2
71666: ARRAY
71667: PUSH
71668: LD_INT 1
71670: ARRAY
71671: PPUSH
71672: CALL_OW 248
71676: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
71677: LD_VAR 0 7
71681: PUSH
71682: LD_INT 3
71684: EQUAL
71685: PUSH
71686: LD_EXP 78
71690: PUSH
71691: LD_VAR 0 2
71695: ARRAY
71696: PUSH
71697: LD_EXP 81
71701: PUSH
71702: LD_VAR 0 2
71706: ARRAY
71707: UNION
71708: PPUSH
71709: LD_INT 33
71711: PUSH
71712: LD_INT 2
71714: PUSH
71715: EMPTY
71716: LIST
71717: LIST
71718: PPUSH
71719: CALL_OW 72
71723: NOT
71724: OR
71725: IFFALSE 71729
// continue ;
71727: GO 71622
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
71729: LD_ADDR_VAR 0 9
71733: PUSH
71734: LD_EXP 59
71738: PUSH
71739: LD_VAR 0 2
71743: ARRAY
71744: PPUSH
71745: LD_INT 30
71747: PUSH
71748: LD_INT 36
71750: PUSH
71751: EMPTY
71752: LIST
71753: LIST
71754: PPUSH
71755: CALL_OW 72
71759: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
71760: LD_ADDR_VAR 0 10
71764: PUSH
71765: LD_EXP 78
71769: PUSH
71770: LD_VAR 0 2
71774: ARRAY
71775: PPUSH
71776: LD_INT 34
71778: PUSH
71779: LD_INT 31
71781: PUSH
71782: EMPTY
71783: LIST
71784: LIST
71785: PPUSH
71786: CALL_OW 72
71790: ST_TO_ADDR
// if not cts and not mcts then
71791: LD_VAR 0 9
71795: NOT
71796: PUSH
71797: LD_VAR 0 10
71801: NOT
71802: AND
71803: IFFALSE 71807
// continue ;
71805: GO 71622
// x := cts ;
71807: LD_ADDR_VAR 0 11
71811: PUSH
71812: LD_VAR 0 9
71816: ST_TO_ADDR
// if not x then
71817: LD_VAR 0 11
71821: NOT
71822: IFFALSE 71834
// x := mcts ;
71824: LD_ADDR_VAR 0 11
71828: PUSH
71829: LD_VAR 0 10
71833: ST_TO_ADDR
// if not x then
71834: LD_VAR 0 11
71838: NOT
71839: IFFALSE 71843
// continue ;
71841: GO 71622
// if mc_remote_driver [ i ] then
71843: LD_EXP 99
71847: PUSH
71848: LD_VAR 0 2
71852: ARRAY
71853: IFFALSE 72240
// for j in mc_remote_driver [ i ] do
71855: LD_ADDR_VAR 0 3
71859: PUSH
71860: LD_EXP 99
71864: PUSH
71865: LD_VAR 0 2
71869: ARRAY
71870: PUSH
71871: FOR_IN
71872: IFFALSE 72238
// begin if GetClass ( j ) <> 3 then
71874: LD_VAR 0 3
71878: PPUSH
71879: CALL_OW 257
71883: PUSH
71884: LD_INT 3
71886: NONEQUAL
71887: IFFALSE 71940
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
71889: LD_ADDR_EXP 99
71893: PUSH
71894: LD_EXP 99
71898: PPUSH
71899: LD_VAR 0 2
71903: PPUSH
71904: LD_EXP 99
71908: PUSH
71909: LD_VAR 0 2
71913: ARRAY
71914: PUSH
71915: LD_VAR 0 3
71919: DIFF
71920: PPUSH
71921: CALL_OW 1
71925: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71926: LD_VAR 0 3
71930: PPUSH
71931: LD_INT 0
71933: PPUSH
71934: CALL_OW 109
// continue ;
71938: GO 71871
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
71940: LD_EXP 78
71944: PUSH
71945: LD_VAR 0 2
71949: ARRAY
71950: PPUSH
71951: LD_INT 34
71953: PUSH
71954: LD_INT 31
71956: PUSH
71957: EMPTY
71958: LIST
71959: LIST
71960: PUSH
71961: LD_INT 58
71963: PUSH
71964: EMPTY
71965: LIST
71966: PUSH
71967: EMPTY
71968: LIST
71969: LIST
71970: PPUSH
71971: CALL_OW 72
71975: PUSH
71976: LD_VAR 0 3
71980: PPUSH
71981: CALL 47887 0 1
71985: NOT
71986: AND
71987: IFFALSE 72058
// begin if IsInUnit ( j ) then
71989: LD_VAR 0 3
71993: PPUSH
71994: CALL_OW 310
71998: IFFALSE 72009
// ComExitBuilding ( j ) ;
72000: LD_VAR 0 3
72004: PPUSH
72005: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
72009: LD_VAR 0 3
72013: PPUSH
72014: LD_EXP 78
72018: PUSH
72019: LD_VAR 0 2
72023: ARRAY
72024: PPUSH
72025: LD_INT 34
72027: PUSH
72028: LD_INT 31
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: PUSH
72035: LD_INT 58
72037: PUSH
72038: EMPTY
72039: LIST
72040: PUSH
72041: EMPTY
72042: LIST
72043: LIST
72044: PPUSH
72045: CALL_OW 72
72049: PUSH
72050: LD_INT 1
72052: ARRAY
72053: PPUSH
72054: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
72058: LD_VAR 0 3
72062: PPUSH
72063: CALL_OW 310
72067: NOT
72068: PUSH
72069: LD_VAR 0 3
72073: PPUSH
72074: CALL_OW 310
72078: PPUSH
72079: CALL_OW 266
72083: PUSH
72084: LD_INT 36
72086: NONEQUAL
72087: PUSH
72088: LD_VAR 0 3
72092: PPUSH
72093: CALL 47887 0 1
72097: NOT
72098: AND
72099: OR
72100: IFFALSE 72236
// begin if IsInUnit ( j ) then
72102: LD_VAR 0 3
72106: PPUSH
72107: CALL_OW 310
72111: IFFALSE 72122
// ComExitBuilding ( j ) ;
72113: LD_VAR 0 3
72117: PPUSH
72118: CALL_OW 122
// ct := 0 ;
72122: LD_ADDR_VAR 0 8
72126: PUSH
72127: LD_INT 0
72129: ST_TO_ADDR
// for k in x do
72130: LD_ADDR_VAR 0 4
72134: PUSH
72135: LD_VAR 0 11
72139: PUSH
72140: FOR_IN
72141: IFFALSE 72214
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
72143: LD_VAR 0 4
72147: PPUSH
72148: CALL_OW 264
72152: PUSH
72153: LD_INT 31
72155: EQUAL
72156: PUSH
72157: LD_VAR 0 4
72161: PPUSH
72162: CALL_OW 311
72166: NOT
72167: AND
72168: PUSH
72169: LD_VAR 0 4
72173: PPUSH
72174: CALL_OW 266
72178: PUSH
72179: LD_INT 36
72181: EQUAL
72182: PUSH
72183: LD_VAR 0 4
72187: PPUSH
72188: CALL_OW 313
72192: PUSH
72193: LD_INT 3
72195: LESS
72196: AND
72197: OR
72198: IFFALSE 72212
// begin ct := k ;
72200: LD_ADDR_VAR 0 8
72204: PUSH
72205: LD_VAR 0 4
72209: ST_TO_ADDR
// break ;
72210: GO 72214
// end ;
72212: GO 72140
72214: POP
72215: POP
// if ct then
72216: LD_VAR 0 8
72220: IFFALSE 72236
// ComEnterUnit ( j , ct ) ;
72222: LD_VAR 0 3
72226: PPUSH
72227: LD_VAR 0 8
72231: PPUSH
72232: CALL_OW 120
// end ; end ;
72236: GO 71871
72238: POP
72239: POP
// places := 0 ;
72240: LD_ADDR_VAR 0 5
72244: PUSH
72245: LD_INT 0
72247: ST_TO_ADDR
// for j = 1 to x do
72248: LD_ADDR_VAR 0 3
72252: PUSH
72253: DOUBLE
72254: LD_INT 1
72256: DEC
72257: ST_TO_ADDR
72258: LD_VAR 0 11
72262: PUSH
72263: FOR_TO
72264: IFFALSE 72340
// if GetWeapon ( x [ j ] ) = ar_control_tower then
72266: LD_VAR 0 11
72270: PUSH
72271: LD_VAR 0 3
72275: ARRAY
72276: PPUSH
72277: CALL_OW 264
72281: PUSH
72282: LD_INT 31
72284: EQUAL
72285: IFFALSE 72303
// places := places + 1 else
72287: LD_ADDR_VAR 0 5
72291: PUSH
72292: LD_VAR 0 5
72296: PUSH
72297: LD_INT 1
72299: PLUS
72300: ST_TO_ADDR
72301: GO 72338
// if GetBType ( x [ j ] ) = b_control_tower then
72303: LD_VAR 0 11
72307: PUSH
72308: LD_VAR 0 3
72312: ARRAY
72313: PPUSH
72314: CALL_OW 266
72318: PUSH
72319: LD_INT 36
72321: EQUAL
72322: IFFALSE 72338
// places := places + 3 ;
72324: LD_ADDR_VAR 0 5
72328: PUSH
72329: LD_VAR 0 5
72333: PUSH
72334: LD_INT 3
72336: PLUS
72337: ST_TO_ADDR
72338: GO 72263
72340: POP
72341: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
72342: LD_VAR 0 5
72346: PUSH
72347: LD_INT 0
72349: EQUAL
72350: PUSH
72351: LD_VAR 0 5
72355: PUSH
72356: LD_EXP 99
72360: PUSH
72361: LD_VAR 0 2
72365: ARRAY
72366: LESSEQUAL
72367: OR
72368: IFFALSE 72372
// continue ;
72370: GO 71622
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
72372: LD_ADDR_VAR 0 6
72376: PUSH
72377: LD_EXP 59
72381: PUSH
72382: LD_VAR 0 2
72386: ARRAY
72387: PPUSH
72388: LD_INT 25
72390: PUSH
72391: LD_INT 3
72393: PUSH
72394: EMPTY
72395: LIST
72396: LIST
72397: PPUSH
72398: CALL_OW 72
72402: PUSH
72403: LD_EXP 99
72407: PUSH
72408: LD_VAR 0 2
72412: ARRAY
72413: DIFF
72414: PPUSH
72415: LD_INT 3
72417: PPUSH
72418: CALL 48787 0 2
72422: ST_TO_ADDR
// for j in tmp do
72423: LD_ADDR_VAR 0 3
72427: PUSH
72428: LD_VAR 0 6
72432: PUSH
72433: FOR_IN
72434: IFFALSE 72469
// if GetTag ( j ) > 0 then
72436: LD_VAR 0 3
72440: PPUSH
72441: CALL_OW 110
72445: PUSH
72446: LD_INT 0
72448: GREATER
72449: IFFALSE 72467
// tmp := tmp diff j ;
72451: LD_ADDR_VAR 0 6
72455: PUSH
72456: LD_VAR 0 6
72460: PUSH
72461: LD_VAR 0 3
72465: DIFF
72466: ST_TO_ADDR
72467: GO 72433
72469: POP
72470: POP
// if not tmp then
72471: LD_VAR 0 6
72475: NOT
72476: IFFALSE 72480
// continue ;
72478: GO 71622
// if places then
72480: LD_VAR 0 5
72484: IFFALSE 72543
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
72486: LD_ADDR_EXP 99
72490: PUSH
72491: LD_EXP 99
72495: PPUSH
72496: LD_VAR 0 2
72500: PPUSH
72501: LD_EXP 99
72505: PUSH
72506: LD_VAR 0 2
72510: ARRAY
72511: PUSH
72512: LD_VAR 0 6
72516: PUSH
72517: LD_INT 1
72519: ARRAY
72520: UNION
72521: PPUSH
72522: CALL_OW 1
72526: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
72527: LD_VAR 0 6
72531: PUSH
72532: LD_INT 1
72534: ARRAY
72535: PPUSH
72536: LD_INT 126
72538: PPUSH
72539: CALL_OW 109
// end ; end ;
72543: GO 71622
72545: POP
72546: POP
// end ;
72547: LD_VAR 0 1
72551: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
72552: LD_INT 0
72554: PPUSH
72555: PPUSH
72556: PPUSH
72557: PPUSH
72558: PPUSH
72559: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
72560: LD_VAR 0 1
72564: NOT
72565: PUSH
72566: LD_VAR 0 2
72570: NOT
72571: OR
72572: PUSH
72573: LD_VAR 0 3
72577: NOT
72578: OR
72579: PUSH
72580: LD_VAR 0 4
72584: PUSH
72585: LD_INT 1
72587: PUSH
72588: LD_INT 2
72590: PUSH
72591: LD_INT 3
72593: PUSH
72594: LD_INT 4
72596: PUSH
72597: LD_INT 5
72599: PUSH
72600: LD_INT 8
72602: PUSH
72603: LD_INT 9
72605: PUSH
72606: LD_INT 15
72608: PUSH
72609: LD_INT 16
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: LIST
72616: LIST
72617: LIST
72618: LIST
72619: LIST
72620: LIST
72621: LIST
72622: IN
72623: NOT
72624: OR
72625: IFFALSE 72629
// exit ;
72627: GO 73529
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
72629: LD_ADDR_VAR 0 2
72633: PUSH
72634: LD_VAR 0 2
72638: PPUSH
72639: LD_INT 21
72641: PUSH
72642: LD_INT 3
72644: PUSH
72645: EMPTY
72646: LIST
72647: LIST
72648: PUSH
72649: LD_INT 24
72651: PUSH
72652: LD_INT 250
72654: PUSH
72655: EMPTY
72656: LIST
72657: LIST
72658: PUSH
72659: EMPTY
72660: LIST
72661: LIST
72662: PPUSH
72663: CALL_OW 72
72667: ST_TO_ADDR
// case class of 1 , 15 :
72668: LD_VAR 0 4
72672: PUSH
72673: LD_INT 1
72675: DOUBLE
72676: EQUAL
72677: IFTRUE 72687
72679: LD_INT 15
72681: DOUBLE
72682: EQUAL
72683: IFTRUE 72687
72685: GO 72772
72687: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
72688: LD_ADDR_VAR 0 8
72692: PUSH
72693: LD_VAR 0 2
72697: PPUSH
72698: LD_INT 2
72700: PUSH
72701: LD_INT 30
72703: PUSH
72704: LD_INT 32
72706: PUSH
72707: EMPTY
72708: LIST
72709: LIST
72710: PUSH
72711: LD_INT 30
72713: PUSH
72714: LD_INT 31
72716: PUSH
72717: EMPTY
72718: LIST
72719: LIST
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: LIST
72725: PPUSH
72726: CALL_OW 72
72730: PUSH
72731: LD_VAR 0 2
72735: PPUSH
72736: LD_INT 2
72738: PUSH
72739: LD_INT 30
72741: PUSH
72742: LD_INT 4
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: LD_INT 30
72751: PUSH
72752: LD_INT 5
72754: PUSH
72755: EMPTY
72756: LIST
72757: LIST
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: LIST
72763: PPUSH
72764: CALL_OW 72
72768: ADD
72769: ST_TO_ADDR
72770: GO 73018
72772: LD_INT 2
72774: DOUBLE
72775: EQUAL
72776: IFTRUE 72786
72778: LD_INT 16
72780: DOUBLE
72781: EQUAL
72782: IFTRUE 72786
72784: GO 72832
72786: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
72787: LD_ADDR_VAR 0 8
72791: PUSH
72792: LD_VAR 0 2
72796: PPUSH
72797: LD_INT 2
72799: PUSH
72800: LD_INT 30
72802: PUSH
72803: LD_INT 0
72805: PUSH
72806: EMPTY
72807: LIST
72808: LIST
72809: PUSH
72810: LD_INT 30
72812: PUSH
72813: LD_INT 1
72815: PUSH
72816: EMPTY
72817: LIST
72818: LIST
72819: PUSH
72820: EMPTY
72821: LIST
72822: LIST
72823: LIST
72824: PPUSH
72825: CALL_OW 72
72829: ST_TO_ADDR
72830: GO 73018
72832: LD_INT 3
72834: DOUBLE
72835: EQUAL
72836: IFTRUE 72840
72838: GO 72886
72840: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
72841: LD_ADDR_VAR 0 8
72845: PUSH
72846: LD_VAR 0 2
72850: PPUSH
72851: LD_INT 2
72853: PUSH
72854: LD_INT 30
72856: PUSH
72857: LD_INT 2
72859: PUSH
72860: EMPTY
72861: LIST
72862: LIST
72863: PUSH
72864: LD_INT 30
72866: PUSH
72867: LD_INT 3
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: EMPTY
72875: LIST
72876: LIST
72877: LIST
72878: PPUSH
72879: CALL_OW 72
72883: ST_TO_ADDR
72884: GO 73018
72886: LD_INT 4
72888: DOUBLE
72889: EQUAL
72890: IFTRUE 72894
72892: GO 72951
72894: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
72895: LD_ADDR_VAR 0 8
72899: PUSH
72900: LD_VAR 0 2
72904: PPUSH
72905: LD_INT 2
72907: PUSH
72908: LD_INT 30
72910: PUSH
72911: LD_INT 6
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: LD_INT 30
72920: PUSH
72921: LD_INT 7
72923: PUSH
72924: EMPTY
72925: LIST
72926: LIST
72927: PUSH
72928: LD_INT 30
72930: PUSH
72931: LD_INT 8
72933: PUSH
72934: EMPTY
72935: LIST
72936: LIST
72937: PUSH
72938: EMPTY
72939: LIST
72940: LIST
72941: LIST
72942: LIST
72943: PPUSH
72944: CALL_OW 72
72948: ST_TO_ADDR
72949: GO 73018
72951: LD_INT 5
72953: DOUBLE
72954: EQUAL
72955: IFTRUE 72971
72957: LD_INT 8
72959: DOUBLE
72960: EQUAL
72961: IFTRUE 72971
72963: LD_INT 9
72965: DOUBLE
72966: EQUAL
72967: IFTRUE 72971
72969: GO 73017
72971: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
72972: LD_ADDR_VAR 0 8
72976: PUSH
72977: LD_VAR 0 2
72981: PPUSH
72982: LD_INT 2
72984: PUSH
72985: LD_INT 30
72987: PUSH
72988: LD_INT 4
72990: PUSH
72991: EMPTY
72992: LIST
72993: LIST
72994: PUSH
72995: LD_INT 30
72997: PUSH
72998: LD_INT 5
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: PUSH
73005: EMPTY
73006: LIST
73007: LIST
73008: LIST
73009: PPUSH
73010: CALL_OW 72
73014: ST_TO_ADDR
73015: GO 73018
73017: POP
// if not tmp then
73018: LD_VAR 0 8
73022: NOT
73023: IFFALSE 73027
// exit ;
73025: GO 73529
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
73027: LD_VAR 0 4
73031: PUSH
73032: LD_INT 1
73034: PUSH
73035: LD_INT 15
73037: PUSH
73038: EMPTY
73039: LIST
73040: LIST
73041: IN
73042: PUSH
73043: LD_EXP 68
73047: PUSH
73048: LD_VAR 0 1
73052: ARRAY
73053: AND
73054: IFFALSE 73210
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
73056: LD_ADDR_VAR 0 9
73060: PUSH
73061: LD_EXP 68
73065: PUSH
73066: LD_VAR 0 1
73070: ARRAY
73071: PUSH
73072: LD_INT 1
73074: ARRAY
73075: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
73076: LD_VAR 0 9
73080: PUSH
73081: LD_EXP 69
73085: PUSH
73086: LD_VAR 0 1
73090: ARRAY
73091: IN
73092: NOT
73093: IFFALSE 73208
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
73095: LD_ADDR_EXP 69
73099: PUSH
73100: LD_EXP 69
73104: PPUSH
73105: LD_VAR 0 1
73109: PUSH
73110: LD_EXP 69
73114: PUSH
73115: LD_VAR 0 1
73119: ARRAY
73120: PUSH
73121: LD_INT 1
73123: PLUS
73124: PUSH
73125: EMPTY
73126: LIST
73127: LIST
73128: PPUSH
73129: LD_VAR 0 9
73133: PPUSH
73134: CALL 19238 0 3
73138: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
73139: LD_ADDR_EXP 68
73143: PUSH
73144: LD_EXP 68
73148: PPUSH
73149: LD_VAR 0 1
73153: PPUSH
73154: LD_EXP 68
73158: PUSH
73159: LD_VAR 0 1
73163: ARRAY
73164: PUSH
73165: LD_VAR 0 9
73169: DIFF
73170: PPUSH
73171: CALL_OW 1
73175: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
73176: LD_VAR 0 3
73180: PPUSH
73181: LD_EXP 69
73185: PUSH
73186: LD_VAR 0 1
73190: ARRAY
73191: PUSH
73192: LD_EXP 69
73196: PUSH
73197: LD_VAR 0 1
73201: ARRAY
73202: ARRAY
73203: PPUSH
73204: CALL_OW 120
// end ; exit ;
73208: GO 73529
// end ; if tmp > 1 then
73210: LD_VAR 0 8
73214: PUSH
73215: LD_INT 1
73217: GREATER
73218: IFFALSE 73322
// for i = 2 to tmp do
73220: LD_ADDR_VAR 0 6
73224: PUSH
73225: DOUBLE
73226: LD_INT 2
73228: DEC
73229: ST_TO_ADDR
73230: LD_VAR 0 8
73234: PUSH
73235: FOR_TO
73236: IFFALSE 73320
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
73238: LD_VAR 0 8
73242: PUSH
73243: LD_VAR 0 6
73247: ARRAY
73248: PPUSH
73249: CALL_OW 461
73253: PUSH
73254: LD_INT 6
73256: EQUAL
73257: IFFALSE 73318
// begin x := tmp [ i ] ;
73259: LD_ADDR_VAR 0 9
73263: PUSH
73264: LD_VAR 0 8
73268: PUSH
73269: LD_VAR 0 6
73273: ARRAY
73274: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
73275: LD_ADDR_VAR 0 8
73279: PUSH
73280: LD_VAR 0 8
73284: PPUSH
73285: LD_VAR 0 6
73289: PPUSH
73290: CALL_OW 3
73294: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
73295: LD_ADDR_VAR 0 8
73299: PUSH
73300: LD_VAR 0 8
73304: PPUSH
73305: LD_INT 1
73307: PPUSH
73308: LD_VAR 0 9
73312: PPUSH
73313: CALL_OW 2
73317: ST_TO_ADDR
// end ;
73318: GO 73235
73320: POP
73321: POP
// for i in tmp do
73322: LD_ADDR_VAR 0 6
73326: PUSH
73327: LD_VAR 0 8
73331: PUSH
73332: FOR_IN
73333: IFFALSE 73402
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
73335: LD_VAR 0 6
73339: PPUSH
73340: CALL_OW 313
73344: PUSH
73345: LD_INT 6
73347: LESS
73348: PUSH
73349: LD_VAR 0 6
73353: PPUSH
73354: CALL_OW 266
73358: PUSH
73359: LD_INT 31
73361: PUSH
73362: LD_INT 32
73364: PUSH
73365: EMPTY
73366: LIST
73367: LIST
73368: IN
73369: NOT
73370: AND
73371: PUSH
73372: LD_VAR 0 6
73376: PPUSH
73377: CALL_OW 313
73381: PUSH
73382: LD_INT 0
73384: EQUAL
73385: OR
73386: IFFALSE 73400
// begin j := i ;
73388: LD_ADDR_VAR 0 7
73392: PUSH
73393: LD_VAR 0 6
73397: ST_TO_ADDR
// break ;
73398: GO 73402
// end ; end ;
73400: GO 73332
73402: POP
73403: POP
// if j then
73404: LD_VAR 0 7
73408: IFFALSE 73426
// ComEnterUnit ( unit , j ) else
73410: LD_VAR 0 3
73414: PPUSH
73415: LD_VAR 0 7
73419: PPUSH
73420: CALL_OW 120
73424: GO 73529
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73426: LD_ADDR_VAR 0 10
73430: PUSH
73431: LD_VAR 0 2
73435: PPUSH
73436: LD_INT 2
73438: PUSH
73439: LD_INT 30
73441: PUSH
73442: LD_INT 0
73444: PUSH
73445: EMPTY
73446: LIST
73447: LIST
73448: PUSH
73449: LD_INT 30
73451: PUSH
73452: LD_INT 1
73454: PUSH
73455: EMPTY
73456: LIST
73457: LIST
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: LIST
73463: PPUSH
73464: CALL_OW 72
73468: ST_TO_ADDR
// if depot then
73469: LD_VAR 0 10
73473: IFFALSE 73529
// begin depot := NearestUnitToUnit ( depot , unit ) ;
73475: LD_ADDR_VAR 0 10
73479: PUSH
73480: LD_VAR 0 10
73484: PPUSH
73485: LD_VAR 0 3
73489: PPUSH
73490: CALL_OW 74
73494: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
73495: LD_VAR 0 3
73499: PPUSH
73500: LD_VAR 0 10
73504: PPUSH
73505: CALL_OW 296
73509: PUSH
73510: LD_INT 10
73512: GREATER
73513: IFFALSE 73529
// ComStandNearbyBuilding ( unit , depot ) ;
73515: LD_VAR 0 3
73519: PPUSH
73520: LD_VAR 0 10
73524: PPUSH
73525: CALL 15852 0 2
// end ; end ; end ;
73529: LD_VAR 0 5
73533: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
73534: LD_INT 0
73536: PPUSH
73537: PPUSH
73538: PPUSH
73539: PPUSH
// if not mc_bases then
73540: LD_EXP 59
73544: NOT
73545: IFFALSE 73549
// exit ;
73547: GO 73788
// for i = 1 to mc_bases do
73549: LD_ADDR_VAR 0 2
73553: PUSH
73554: DOUBLE
73555: LD_INT 1
73557: DEC
73558: ST_TO_ADDR
73559: LD_EXP 59
73563: PUSH
73564: FOR_TO
73565: IFFALSE 73786
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
73567: LD_ADDR_VAR 0 4
73571: PUSH
73572: LD_EXP 59
73576: PUSH
73577: LD_VAR 0 2
73581: ARRAY
73582: PPUSH
73583: LD_INT 21
73585: PUSH
73586: LD_INT 1
73588: PUSH
73589: EMPTY
73590: LIST
73591: LIST
73592: PPUSH
73593: CALL_OW 72
73597: PUSH
73598: LD_EXP 88
73602: PUSH
73603: LD_VAR 0 2
73607: ARRAY
73608: UNION
73609: ST_TO_ADDR
// if not tmp then
73610: LD_VAR 0 4
73614: NOT
73615: IFFALSE 73619
// continue ;
73617: GO 73564
// for j in tmp do
73619: LD_ADDR_VAR 0 3
73623: PUSH
73624: LD_VAR 0 4
73628: PUSH
73629: FOR_IN
73630: IFFALSE 73782
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
73632: LD_VAR 0 3
73636: PPUSH
73637: CALL_OW 110
73641: NOT
73642: PUSH
73643: LD_VAR 0 3
73647: PPUSH
73648: CALL_OW 314
73652: NOT
73653: AND
73654: PUSH
73655: LD_VAR 0 3
73659: PPUSH
73660: CALL_OW 311
73664: NOT
73665: AND
73666: PUSH
73667: LD_VAR 0 3
73671: PPUSH
73672: CALL_OW 310
73676: NOT
73677: AND
73678: PUSH
73679: LD_VAR 0 3
73683: PUSH
73684: LD_EXP 62
73688: PUSH
73689: LD_VAR 0 2
73693: ARRAY
73694: PUSH
73695: LD_INT 1
73697: ARRAY
73698: IN
73699: NOT
73700: AND
73701: PUSH
73702: LD_VAR 0 3
73706: PUSH
73707: LD_EXP 62
73711: PUSH
73712: LD_VAR 0 2
73716: ARRAY
73717: PUSH
73718: LD_INT 2
73720: ARRAY
73721: IN
73722: NOT
73723: AND
73724: PUSH
73725: LD_VAR 0 3
73729: PUSH
73730: LD_EXP 71
73734: PUSH
73735: LD_VAR 0 2
73739: ARRAY
73740: IN
73741: NOT
73742: AND
73743: IFFALSE 73780
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
73745: LD_VAR 0 2
73749: PPUSH
73750: LD_EXP 59
73754: PUSH
73755: LD_VAR 0 2
73759: ARRAY
73760: PPUSH
73761: LD_VAR 0 3
73765: PPUSH
73766: LD_VAR 0 3
73770: PPUSH
73771: CALL_OW 257
73775: PPUSH
73776: CALL 72552 0 4
// end ;
73780: GO 73629
73782: POP
73783: POP
// end ;
73784: GO 73564
73786: POP
73787: POP
// end ;
73788: LD_VAR 0 1
73792: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
73793: LD_INT 0
73795: PPUSH
73796: PPUSH
73797: PPUSH
73798: PPUSH
73799: PPUSH
73800: PPUSH
// if not mc_bases [ base ] then
73801: LD_EXP 59
73805: PUSH
73806: LD_VAR 0 1
73810: ARRAY
73811: NOT
73812: IFFALSE 73816
// exit ;
73814: GO 73998
// tmp := [ ] ;
73816: LD_ADDR_VAR 0 6
73820: PUSH
73821: EMPTY
73822: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
73823: LD_ADDR_VAR 0 7
73827: PUSH
73828: LD_VAR 0 3
73832: PPUSH
73833: LD_INT 0
73835: PPUSH
73836: CALL_OW 517
73840: ST_TO_ADDR
// if not list then
73841: LD_VAR 0 7
73845: NOT
73846: IFFALSE 73850
// exit ;
73848: GO 73998
// for i = 1 to amount do
73850: LD_ADDR_VAR 0 5
73854: PUSH
73855: DOUBLE
73856: LD_INT 1
73858: DEC
73859: ST_TO_ADDR
73860: LD_VAR 0 2
73864: PUSH
73865: FOR_TO
73866: IFFALSE 73946
// begin x := rand ( 1 , list [ 1 ] ) ;
73868: LD_ADDR_VAR 0 8
73872: PUSH
73873: LD_INT 1
73875: PPUSH
73876: LD_VAR 0 7
73880: PUSH
73881: LD_INT 1
73883: ARRAY
73884: PPUSH
73885: CALL_OW 12
73889: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
73890: LD_ADDR_VAR 0 6
73894: PUSH
73895: LD_VAR 0 6
73899: PPUSH
73900: LD_VAR 0 5
73904: PPUSH
73905: LD_VAR 0 7
73909: PUSH
73910: LD_INT 1
73912: ARRAY
73913: PUSH
73914: LD_VAR 0 8
73918: ARRAY
73919: PUSH
73920: LD_VAR 0 7
73924: PUSH
73925: LD_INT 2
73927: ARRAY
73928: PUSH
73929: LD_VAR 0 8
73933: ARRAY
73934: PUSH
73935: EMPTY
73936: LIST
73937: LIST
73938: PPUSH
73939: CALL_OW 1
73943: ST_TO_ADDR
// end ;
73944: GO 73865
73946: POP
73947: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
73948: LD_ADDR_EXP 72
73952: PUSH
73953: LD_EXP 72
73957: PPUSH
73958: LD_VAR 0 1
73962: PPUSH
73963: LD_VAR 0 6
73967: PPUSH
73968: CALL_OW 1
73972: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
73973: LD_ADDR_EXP 74
73977: PUSH
73978: LD_EXP 74
73982: PPUSH
73983: LD_VAR 0 1
73987: PPUSH
73988: LD_VAR 0 3
73992: PPUSH
73993: CALL_OW 1
73997: ST_TO_ADDR
// end ;
73998: LD_VAR 0 4
74002: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
74003: LD_INT 0
74005: PPUSH
// if not mc_bases [ base ] then
74006: LD_EXP 59
74010: PUSH
74011: LD_VAR 0 1
74015: ARRAY
74016: NOT
74017: IFFALSE 74021
// exit ;
74019: GO 74046
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
74021: LD_ADDR_EXP 64
74025: PUSH
74026: LD_EXP 64
74030: PPUSH
74031: LD_VAR 0 1
74035: PPUSH
74036: LD_VAR 0 2
74040: PPUSH
74041: CALL_OW 1
74045: ST_TO_ADDR
// end ;
74046: LD_VAR 0 3
74050: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
74051: LD_INT 0
74053: PPUSH
// if not mc_bases [ base ] then
74054: LD_EXP 59
74058: PUSH
74059: LD_VAR 0 1
74063: ARRAY
74064: NOT
74065: IFFALSE 74069
// exit ;
74067: GO 74106
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
74069: LD_ADDR_EXP 64
74073: PUSH
74074: LD_EXP 64
74078: PPUSH
74079: LD_VAR 0 1
74083: PPUSH
74084: LD_EXP 64
74088: PUSH
74089: LD_VAR 0 1
74093: ARRAY
74094: PUSH
74095: LD_VAR 0 2
74099: UNION
74100: PPUSH
74101: CALL_OW 1
74105: ST_TO_ADDR
// end ;
74106: LD_VAR 0 3
74110: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
74111: LD_INT 0
74113: PPUSH
// if not mc_bases [ base ] then
74114: LD_EXP 59
74118: PUSH
74119: LD_VAR 0 1
74123: ARRAY
74124: NOT
74125: IFFALSE 74129
// exit ;
74127: GO 74154
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
74129: LD_ADDR_EXP 80
74133: PUSH
74134: LD_EXP 80
74138: PPUSH
74139: LD_VAR 0 1
74143: PPUSH
74144: LD_VAR 0 2
74148: PPUSH
74149: CALL_OW 1
74153: ST_TO_ADDR
// end ;
74154: LD_VAR 0 3
74158: RET
// export function MC_InsertProduceList ( base , components ) ; begin
74159: LD_INT 0
74161: PPUSH
// if not mc_bases [ base ] then
74162: LD_EXP 59
74166: PUSH
74167: LD_VAR 0 1
74171: ARRAY
74172: NOT
74173: IFFALSE 74177
// exit ;
74175: GO 74214
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
74177: LD_ADDR_EXP 80
74181: PUSH
74182: LD_EXP 80
74186: PPUSH
74187: LD_VAR 0 1
74191: PPUSH
74192: LD_EXP 80
74196: PUSH
74197: LD_VAR 0 1
74201: ARRAY
74202: PUSH
74203: LD_VAR 0 2
74207: ADD
74208: PPUSH
74209: CALL_OW 1
74213: ST_TO_ADDR
// end ;
74214: LD_VAR 0 3
74218: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
74219: LD_INT 0
74221: PPUSH
// if not mc_bases [ base ] then
74222: LD_EXP 59
74226: PUSH
74227: LD_VAR 0 1
74231: ARRAY
74232: NOT
74233: IFFALSE 74237
// exit ;
74235: GO 74291
// mc_defender := Replace ( mc_defender , base , deflist ) ;
74237: LD_ADDR_EXP 81
74241: PUSH
74242: LD_EXP 81
74246: PPUSH
74247: LD_VAR 0 1
74251: PPUSH
74252: LD_VAR 0 2
74256: PPUSH
74257: CALL_OW 1
74261: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
74262: LD_ADDR_EXP 70
74266: PUSH
74267: LD_EXP 70
74271: PPUSH
74272: LD_VAR 0 1
74276: PPUSH
74277: LD_VAR 0 2
74281: PUSH
74282: LD_INT 0
74284: PLUS
74285: PPUSH
74286: CALL_OW 1
74290: ST_TO_ADDR
// end ;
74291: LD_VAR 0 3
74295: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
74296: LD_INT 0
74298: PPUSH
// if not mc_bases [ base ] then
74299: LD_EXP 59
74303: PUSH
74304: LD_VAR 0 1
74308: ARRAY
74309: NOT
74310: IFFALSE 74314
// exit ;
74312: GO 74339
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
74314: LD_ADDR_EXP 70
74318: PUSH
74319: LD_EXP 70
74323: PPUSH
74324: LD_VAR 0 1
74328: PPUSH
74329: LD_VAR 0 2
74333: PPUSH
74334: CALL_OW 1
74338: ST_TO_ADDR
// end ;
74339: LD_VAR 0 3
74343: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
74344: LD_INT 0
74346: PPUSH
74347: PPUSH
74348: PPUSH
74349: PPUSH
// if not mc_bases [ base ] then
74350: LD_EXP 59
74354: PUSH
74355: LD_VAR 0 1
74359: ARRAY
74360: NOT
74361: IFFALSE 74365
// exit ;
74363: GO 74430
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
74365: LD_ADDR_EXP 79
74369: PUSH
74370: LD_EXP 79
74374: PPUSH
74375: LD_VAR 0 1
74379: PUSH
74380: LD_EXP 79
74384: PUSH
74385: LD_VAR 0 1
74389: ARRAY
74390: PUSH
74391: LD_INT 1
74393: PLUS
74394: PUSH
74395: EMPTY
74396: LIST
74397: LIST
74398: PPUSH
74399: LD_VAR 0 1
74403: PUSH
74404: LD_VAR 0 2
74408: PUSH
74409: LD_VAR 0 3
74413: PUSH
74414: LD_VAR 0 4
74418: PUSH
74419: EMPTY
74420: LIST
74421: LIST
74422: LIST
74423: LIST
74424: PPUSH
74425: CALL 19238 0 3
74429: ST_TO_ADDR
// end ;
74430: LD_VAR 0 5
74434: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
74435: LD_INT 0
74437: PPUSH
// if not mc_bases [ base ] then
74438: LD_EXP 59
74442: PUSH
74443: LD_VAR 0 1
74447: ARRAY
74448: NOT
74449: IFFALSE 74453
// exit ;
74451: GO 74478
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
74453: LD_ADDR_EXP 96
74457: PUSH
74458: LD_EXP 96
74462: PPUSH
74463: LD_VAR 0 1
74467: PPUSH
74468: LD_VAR 0 2
74472: PPUSH
74473: CALL_OW 1
74477: ST_TO_ADDR
// end ;
74478: LD_VAR 0 3
74482: RET
// export function MC_GetMinesField ( base ) ; begin
74483: LD_INT 0
74485: PPUSH
// result := mc_mines [ base ] ;
74486: LD_ADDR_VAR 0 2
74490: PUSH
74491: LD_EXP 72
74495: PUSH
74496: LD_VAR 0 1
74500: ARRAY
74501: ST_TO_ADDR
// end ;
74502: LD_VAR 0 2
74506: RET
// export function MC_GetProduceList ( base ) ; begin
74507: LD_INT 0
74509: PPUSH
// result := mc_produce [ base ] ;
74510: LD_ADDR_VAR 0 2
74514: PUSH
74515: LD_EXP 80
74519: PUSH
74520: LD_VAR 0 1
74524: ARRAY
74525: ST_TO_ADDR
// end ;
74526: LD_VAR 0 2
74530: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
74531: LD_INT 0
74533: PPUSH
74534: PPUSH
// if not mc_bases then
74535: LD_EXP 59
74539: NOT
74540: IFFALSE 74544
// exit ;
74542: GO 74609
// if mc_bases [ base ] then
74544: LD_EXP 59
74548: PUSH
74549: LD_VAR 0 1
74553: ARRAY
74554: IFFALSE 74609
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74556: LD_ADDR_VAR 0 3
74560: PUSH
74561: LD_EXP 59
74565: PUSH
74566: LD_VAR 0 1
74570: ARRAY
74571: PPUSH
74572: LD_INT 30
74574: PUSH
74575: LD_VAR 0 2
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PPUSH
74584: CALL_OW 72
74588: ST_TO_ADDR
// if result then
74589: LD_VAR 0 3
74593: IFFALSE 74609
// result := result [ 1 ] ;
74595: LD_ADDR_VAR 0 3
74599: PUSH
74600: LD_VAR 0 3
74604: PUSH
74605: LD_INT 1
74607: ARRAY
74608: ST_TO_ADDR
// end ; end ;
74609: LD_VAR 0 3
74613: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
74614: LD_INT 0
74616: PPUSH
74617: PPUSH
// if not mc_bases then
74618: LD_EXP 59
74622: NOT
74623: IFFALSE 74627
// exit ;
74625: GO 74672
// if mc_bases [ base ] then
74627: LD_EXP 59
74631: PUSH
74632: LD_VAR 0 1
74636: ARRAY
74637: IFFALSE 74672
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74639: LD_ADDR_VAR 0 3
74643: PUSH
74644: LD_EXP 59
74648: PUSH
74649: LD_VAR 0 1
74653: ARRAY
74654: PPUSH
74655: LD_INT 30
74657: PUSH
74658: LD_VAR 0 2
74662: PUSH
74663: EMPTY
74664: LIST
74665: LIST
74666: PPUSH
74667: CALL_OW 72
74671: ST_TO_ADDR
// end ;
74672: LD_VAR 0 3
74676: RET
// export function MC_SetTame ( base , area ) ; begin
74677: LD_INT 0
74679: PPUSH
// if not mc_bases or not base then
74680: LD_EXP 59
74684: NOT
74685: PUSH
74686: LD_VAR 0 1
74690: NOT
74691: OR
74692: IFFALSE 74696
// exit ;
74694: GO 74721
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
74696: LD_ADDR_EXP 87
74700: PUSH
74701: LD_EXP 87
74705: PPUSH
74706: LD_VAR 0 1
74710: PPUSH
74711: LD_VAR 0 2
74715: PPUSH
74716: CALL_OW 1
74720: ST_TO_ADDR
// end ;
74721: LD_VAR 0 3
74725: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
74726: LD_INT 0
74728: PPUSH
74729: PPUSH
// if not mc_bases or not base then
74730: LD_EXP 59
74734: NOT
74735: PUSH
74736: LD_VAR 0 1
74740: NOT
74741: OR
74742: IFFALSE 74746
// exit ;
74744: GO 74848
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74746: LD_ADDR_VAR 0 4
74750: PUSH
74751: LD_EXP 59
74755: PUSH
74756: LD_VAR 0 1
74760: ARRAY
74761: PPUSH
74762: LD_INT 30
74764: PUSH
74765: LD_VAR 0 2
74769: PUSH
74770: EMPTY
74771: LIST
74772: LIST
74773: PPUSH
74774: CALL_OW 72
74778: ST_TO_ADDR
// if not tmp then
74779: LD_VAR 0 4
74783: NOT
74784: IFFALSE 74788
// exit ;
74786: GO 74848
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
74788: LD_ADDR_EXP 91
74792: PUSH
74793: LD_EXP 91
74797: PPUSH
74798: LD_VAR 0 1
74802: PPUSH
74803: LD_EXP 91
74807: PUSH
74808: LD_VAR 0 1
74812: ARRAY
74813: PPUSH
74814: LD_EXP 91
74818: PUSH
74819: LD_VAR 0 1
74823: ARRAY
74824: PUSH
74825: LD_INT 1
74827: PLUS
74828: PPUSH
74829: LD_VAR 0 4
74833: PUSH
74834: LD_INT 1
74836: ARRAY
74837: PPUSH
74838: CALL_OW 2
74842: PPUSH
74843: CALL_OW 1
74847: ST_TO_ADDR
// end ;
74848: LD_VAR 0 3
74852: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
74853: LD_INT 0
74855: PPUSH
74856: PPUSH
// if not mc_bases or not base or not kinds then
74857: LD_EXP 59
74861: NOT
74862: PUSH
74863: LD_VAR 0 1
74867: NOT
74868: OR
74869: PUSH
74870: LD_VAR 0 2
74874: NOT
74875: OR
74876: IFFALSE 74880
// exit ;
74878: GO 74941
// for i in kinds do
74880: LD_ADDR_VAR 0 4
74884: PUSH
74885: LD_VAR 0 2
74889: PUSH
74890: FOR_IN
74891: IFFALSE 74939
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
74893: LD_ADDR_EXP 93
74897: PUSH
74898: LD_EXP 93
74902: PPUSH
74903: LD_VAR 0 1
74907: PUSH
74908: LD_EXP 93
74912: PUSH
74913: LD_VAR 0 1
74917: ARRAY
74918: PUSH
74919: LD_INT 1
74921: PLUS
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PPUSH
74927: LD_VAR 0 4
74931: PPUSH
74932: CALL 19238 0 3
74936: ST_TO_ADDR
74937: GO 74890
74939: POP
74940: POP
// end ;
74941: LD_VAR 0 3
74945: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
74946: LD_INT 0
74948: PPUSH
// if not mc_bases or not base or not areas then
74949: LD_EXP 59
74953: NOT
74954: PUSH
74955: LD_VAR 0 1
74959: NOT
74960: OR
74961: PUSH
74962: LD_VAR 0 2
74966: NOT
74967: OR
74968: IFFALSE 74972
// exit ;
74970: GO 74997
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
74972: LD_ADDR_EXP 77
74976: PUSH
74977: LD_EXP 77
74981: PPUSH
74982: LD_VAR 0 1
74986: PPUSH
74987: LD_VAR 0 2
74991: PPUSH
74992: CALL_OW 1
74996: ST_TO_ADDR
// end ;
74997: LD_VAR 0 3
75001: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
75002: LD_INT 0
75004: PPUSH
// if not mc_bases or not base or not teleports_exit then
75005: LD_EXP 59
75009: NOT
75010: PUSH
75011: LD_VAR 0 1
75015: NOT
75016: OR
75017: PUSH
75018: LD_VAR 0 2
75022: NOT
75023: OR
75024: IFFALSE 75028
// exit ;
75026: GO 75053
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
75028: LD_ADDR_EXP 94
75032: PUSH
75033: LD_EXP 94
75037: PPUSH
75038: LD_VAR 0 1
75042: PPUSH
75043: LD_VAR 0 2
75047: PPUSH
75048: CALL_OW 1
75052: ST_TO_ADDR
// end ;
75053: LD_VAR 0 3
75057: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
75058: LD_INT 0
75060: PPUSH
75061: PPUSH
75062: PPUSH
// if not mc_bases or not base or not ext_list then
75063: LD_EXP 59
75067: NOT
75068: PUSH
75069: LD_VAR 0 1
75073: NOT
75074: OR
75075: PUSH
75076: LD_VAR 0 5
75080: NOT
75081: OR
75082: IFFALSE 75086
// exit ;
75084: GO 75259
// tmp := GetFacExtXYD ( x , y , d ) ;
75086: LD_ADDR_VAR 0 8
75090: PUSH
75091: LD_VAR 0 2
75095: PPUSH
75096: LD_VAR 0 3
75100: PPUSH
75101: LD_VAR 0 4
75105: PPUSH
75106: CALL 47917 0 3
75110: ST_TO_ADDR
// if not tmp then
75111: LD_VAR 0 8
75115: NOT
75116: IFFALSE 75120
// exit ;
75118: GO 75259
// for i in tmp do
75120: LD_ADDR_VAR 0 7
75124: PUSH
75125: LD_VAR 0 8
75129: PUSH
75130: FOR_IN
75131: IFFALSE 75257
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
75133: LD_ADDR_EXP 64
75137: PUSH
75138: LD_EXP 64
75142: PPUSH
75143: LD_VAR 0 1
75147: PPUSH
75148: LD_EXP 64
75152: PUSH
75153: LD_VAR 0 1
75157: ARRAY
75158: PPUSH
75159: LD_EXP 64
75163: PUSH
75164: LD_VAR 0 1
75168: ARRAY
75169: PUSH
75170: LD_INT 1
75172: PLUS
75173: PPUSH
75174: LD_VAR 0 5
75178: PUSH
75179: LD_INT 1
75181: ARRAY
75182: PUSH
75183: LD_VAR 0 7
75187: PUSH
75188: LD_INT 1
75190: ARRAY
75191: PUSH
75192: LD_VAR 0 7
75196: PUSH
75197: LD_INT 2
75199: ARRAY
75200: PUSH
75201: LD_VAR 0 7
75205: PUSH
75206: LD_INT 3
75208: ARRAY
75209: PUSH
75210: EMPTY
75211: LIST
75212: LIST
75213: LIST
75214: LIST
75215: PPUSH
75216: CALL_OW 2
75220: PPUSH
75221: CALL_OW 1
75225: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
75226: LD_ADDR_VAR 0 5
75230: PUSH
75231: LD_VAR 0 5
75235: PPUSH
75236: LD_INT 1
75238: PPUSH
75239: CALL_OW 3
75243: ST_TO_ADDR
// if not ext_list then
75244: LD_VAR 0 5
75248: NOT
75249: IFFALSE 75255
// exit ;
75251: POP
75252: POP
75253: GO 75259
// end ;
75255: GO 75130
75257: POP
75258: POP
// end ;
75259: LD_VAR 0 6
75263: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
75264: LD_INT 0
75266: PPUSH
// if not mc_bases or not base or not weapon_list then
75267: LD_EXP 59
75271: NOT
75272: PUSH
75273: LD_VAR 0 1
75277: NOT
75278: OR
75279: PUSH
75280: LD_VAR 0 2
75284: NOT
75285: OR
75286: IFFALSE 75290
// exit ;
75288: GO 75315
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
75290: LD_ADDR_EXP 98
75294: PUSH
75295: LD_EXP 98
75299: PPUSH
75300: LD_VAR 0 1
75304: PPUSH
75305: LD_VAR 0 2
75309: PPUSH
75310: CALL_OW 1
75314: ST_TO_ADDR
// end ;
75315: LD_VAR 0 3
75319: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
75320: LD_INT 0
75322: PPUSH
// if not mc_bases or not base or not tech_list then
75323: LD_EXP 59
75327: NOT
75328: PUSH
75329: LD_VAR 0 1
75333: NOT
75334: OR
75335: PUSH
75336: LD_VAR 0 2
75340: NOT
75341: OR
75342: IFFALSE 75346
// exit ;
75344: GO 75371
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
75346: LD_ADDR_EXP 86
75350: PUSH
75351: LD_EXP 86
75355: PPUSH
75356: LD_VAR 0 1
75360: PPUSH
75361: LD_VAR 0 2
75365: PPUSH
75366: CALL_OW 1
75370: ST_TO_ADDR
// end ;
75371: LD_VAR 0 3
75375: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
75376: LD_INT 0
75378: PPUSH
// if not mc_bases or not parking_area or not base then
75379: LD_EXP 59
75383: NOT
75384: PUSH
75385: LD_VAR 0 2
75389: NOT
75390: OR
75391: PUSH
75392: LD_VAR 0 1
75396: NOT
75397: OR
75398: IFFALSE 75402
// exit ;
75400: GO 75427
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
75402: LD_ADDR_EXP 83
75406: PUSH
75407: LD_EXP 83
75411: PPUSH
75412: LD_VAR 0 1
75416: PPUSH
75417: LD_VAR 0 2
75421: PPUSH
75422: CALL_OW 1
75426: ST_TO_ADDR
// end ;
75427: LD_VAR 0 3
75431: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
75432: LD_INT 0
75434: PPUSH
// if not mc_bases or not base or not scan_area then
75435: LD_EXP 59
75439: NOT
75440: PUSH
75441: LD_VAR 0 1
75445: NOT
75446: OR
75447: PUSH
75448: LD_VAR 0 2
75452: NOT
75453: OR
75454: IFFALSE 75458
// exit ;
75456: GO 75483
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
75458: LD_ADDR_EXP 84
75462: PUSH
75463: LD_EXP 84
75467: PPUSH
75468: LD_VAR 0 1
75472: PPUSH
75473: LD_VAR 0 2
75477: PPUSH
75478: CALL_OW 1
75482: ST_TO_ADDR
// end ;
75483: LD_VAR 0 3
75487: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
75488: LD_INT 0
75490: PPUSH
75491: PPUSH
// if not mc_bases or not base then
75492: LD_EXP 59
75496: NOT
75497: PUSH
75498: LD_VAR 0 1
75502: NOT
75503: OR
75504: IFFALSE 75508
// exit ;
75506: GO 75572
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
75508: LD_ADDR_VAR 0 3
75512: PUSH
75513: LD_INT 1
75515: PUSH
75516: LD_INT 2
75518: PUSH
75519: LD_INT 3
75521: PUSH
75522: LD_INT 4
75524: PUSH
75525: LD_INT 11
75527: PUSH
75528: EMPTY
75529: LIST
75530: LIST
75531: LIST
75532: LIST
75533: LIST
75534: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
75535: LD_ADDR_EXP 86
75539: PUSH
75540: LD_EXP 86
75544: PPUSH
75545: LD_VAR 0 1
75549: PPUSH
75550: LD_EXP 86
75554: PUSH
75555: LD_VAR 0 1
75559: ARRAY
75560: PUSH
75561: LD_VAR 0 3
75565: DIFF
75566: PPUSH
75567: CALL_OW 1
75571: ST_TO_ADDR
// end ;
75572: LD_VAR 0 2
75576: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
75577: LD_INT 0
75579: PPUSH
// result := mc_vehicles [ base ] ;
75580: LD_ADDR_VAR 0 3
75584: PUSH
75585: LD_EXP 78
75589: PUSH
75590: LD_VAR 0 1
75594: ARRAY
75595: ST_TO_ADDR
// if onlyCombat then
75596: LD_VAR 0 2
75600: IFFALSE 75765
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
75602: LD_ADDR_VAR 0 3
75606: PUSH
75607: LD_VAR 0 3
75611: PUSH
75612: LD_VAR 0 3
75616: PPUSH
75617: LD_INT 2
75619: PUSH
75620: LD_INT 34
75622: PUSH
75623: LD_INT 12
75625: PUSH
75626: EMPTY
75627: LIST
75628: LIST
75629: PUSH
75630: LD_INT 34
75632: PUSH
75633: LD_INT 51
75635: PUSH
75636: EMPTY
75637: LIST
75638: LIST
75639: PUSH
75640: LD_INT 34
75642: PUSH
75643: LD_EXP 103
75647: PUSH
75648: EMPTY
75649: LIST
75650: LIST
75651: PUSH
75652: LD_INT 34
75654: PUSH
75655: LD_INT 32
75657: PUSH
75658: EMPTY
75659: LIST
75660: LIST
75661: PUSH
75662: LD_INT 34
75664: PUSH
75665: LD_INT 13
75667: PUSH
75668: EMPTY
75669: LIST
75670: LIST
75671: PUSH
75672: LD_INT 34
75674: PUSH
75675: LD_INT 52
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: LD_INT 34
75684: PUSH
75685: LD_INT 14
75687: PUSH
75688: EMPTY
75689: LIST
75690: LIST
75691: PUSH
75692: LD_INT 34
75694: PUSH
75695: LD_INT 53
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: PUSH
75702: LD_INT 34
75704: PUSH
75705: LD_EXP 102
75709: PUSH
75710: EMPTY
75711: LIST
75712: LIST
75713: PUSH
75714: LD_INT 34
75716: PUSH
75717: LD_INT 31
75719: PUSH
75720: EMPTY
75721: LIST
75722: LIST
75723: PUSH
75724: LD_INT 34
75726: PUSH
75727: LD_INT 48
75729: PUSH
75730: EMPTY
75731: LIST
75732: LIST
75733: PUSH
75734: LD_INT 34
75736: PUSH
75737: LD_INT 8
75739: PUSH
75740: EMPTY
75741: LIST
75742: LIST
75743: PUSH
75744: EMPTY
75745: LIST
75746: LIST
75747: LIST
75748: LIST
75749: LIST
75750: LIST
75751: LIST
75752: LIST
75753: LIST
75754: LIST
75755: LIST
75756: LIST
75757: LIST
75758: PPUSH
75759: CALL_OW 72
75763: DIFF
75764: ST_TO_ADDR
// end ; end_of_file
75765: LD_VAR 0 3
75769: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
75770: LD_INT 0
75772: PPUSH
75773: PPUSH
75774: PPUSH
// if not mc_bases or not skirmish then
75775: LD_EXP 59
75779: NOT
75780: PUSH
75781: LD_EXP 57
75785: NOT
75786: OR
75787: IFFALSE 75791
// exit ;
75789: GO 75956
// for i = 1 to mc_bases do
75791: LD_ADDR_VAR 0 4
75795: PUSH
75796: DOUBLE
75797: LD_INT 1
75799: DEC
75800: ST_TO_ADDR
75801: LD_EXP 59
75805: PUSH
75806: FOR_TO
75807: IFFALSE 75954
// begin if sci in mc_bases [ i ] then
75809: LD_VAR 0 2
75813: PUSH
75814: LD_EXP 59
75818: PUSH
75819: LD_VAR 0 4
75823: ARRAY
75824: IN
75825: IFFALSE 75952
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
75827: LD_ADDR_EXP 88
75831: PUSH
75832: LD_EXP 88
75836: PPUSH
75837: LD_VAR 0 4
75841: PUSH
75842: LD_EXP 88
75846: PUSH
75847: LD_VAR 0 4
75851: ARRAY
75852: PUSH
75853: LD_INT 1
75855: PLUS
75856: PUSH
75857: EMPTY
75858: LIST
75859: LIST
75860: PPUSH
75861: LD_VAR 0 1
75865: PPUSH
75866: CALL 19238 0 3
75870: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
75871: LD_ADDR_VAR 0 5
75875: PUSH
75876: LD_EXP 59
75880: PUSH
75881: LD_VAR 0 4
75885: ARRAY
75886: PPUSH
75887: LD_INT 2
75889: PUSH
75890: LD_INT 30
75892: PUSH
75893: LD_INT 0
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: PUSH
75900: LD_INT 30
75902: PUSH
75903: LD_INT 1
75905: PUSH
75906: EMPTY
75907: LIST
75908: LIST
75909: PUSH
75910: EMPTY
75911: LIST
75912: LIST
75913: LIST
75914: PPUSH
75915: CALL_OW 72
75919: PPUSH
75920: LD_VAR 0 1
75924: PPUSH
75925: CALL_OW 74
75929: ST_TO_ADDR
// if tmp then
75930: LD_VAR 0 5
75934: IFFALSE 75950
// ComStandNearbyBuilding ( ape , tmp ) ;
75936: LD_VAR 0 1
75940: PPUSH
75941: LD_VAR 0 5
75945: PPUSH
75946: CALL 15852 0 2
// break ;
75950: GO 75954
// end ; end ;
75952: GO 75806
75954: POP
75955: POP
// end ;
75956: LD_VAR 0 3
75960: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
75961: LD_INT 0
75963: PPUSH
75964: PPUSH
75965: PPUSH
// if not mc_bases or not skirmish then
75966: LD_EXP 59
75970: NOT
75971: PUSH
75972: LD_EXP 57
75976: NOT
75977: OR
75978: IFFALSE 75982
// exit ;
75980: GO 76071
// for i = 1 to mc_bases do
75982: LD_ADDR_VAR 0 4
75986: PUSH
75987: DOUBLE
75988: LD_INT 1
75990: DEC
75991: ST_TO_ADDR
75992: LD_EXP 59
75996: PUSH
75997: FOR_TO
75998: IFFALSE 76069
// begin if building in mc_busy_turret_list [ i ] then
76000: LD_VAR 0 1
76004: PUSH
76005: LD_EXP 69
76009: PUSH
76010: LD_VAR 0 4
76014: ARRAY
76015: IN
76016: IFFALSE 76067
// begin tmp := mc_busy_turret_list [ i ] diff building ;
76018: LD_ADDR_VAR 0 5
76022: PUSH
76023: LD_EXP 69
76027: PUSH
76028: LD_VAR 0 4
76032: ARRAY
76033: PUSH
76034: LD_VAR 0 1
76038: DIFF
76039: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
76040: LD_ADDR_EXP 69
76044: PUSH
76045: LD_EXP 69
76049: PPUSH
76050: LD_VAR 0 4
76054: PPUSH
76055: LD_VAR 0 5
76059: PPUSH
76060: CALL_OW 1
76064: ST_TO_ADDR
// break ;
76065: GO 76069
// end ; end ;
76067: GO 75997
76069: POP
76070: POP
// end ;
76071: LD_VAR 0 3
76075: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
76076: LD_INT 0
76078: PPUSH
76079: PPUSH
76080: PPUSH
// if not mc_bases or not skirmish then
76081: LD_EXP 59
76085: NOT
76086: PUSH
76087: LD_EXP 57
76091: NOT
76092: OR
76093: IFFALSE 76097
// exit ;
76095: GO 76296
// for i = 1 to mc_bases do
76097: LD_ADDR_VAR 0 5
76101: PUSH
76102: DOUBLE
76103: LD_INT 1
76105: DEC
76106: ST_TO_ADDR
76107: LD_EXP 59
76111: PUSH
76112: FOR_TO
76113: IFFALSE 76294
// if building in mc_bases [ i ] then
76115: LD_VAR 0 1
76119: PUSH
76120: LD_EXP 59
76124: PUSH
76125: LD_VAR 0 5
76129: ARRAY
76130: IN
76131: IFFALSE 76292
// begin tmp := mc_bases [ i ] diff building ;
76133: LD_ADDR_VAR 0 6
76137: PUSH
76138: LD_EXP 59
76142: PUSH
76143: LD_VAR 0 5
76147: ARRAY
76148: PUSH
76149: LD_VAR 0 1
76153: DIFF
76154: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
76155: LD_ADDR_EXP 59
76159: PUSH
76160: LD_EXP 59
76164: PPUSH
76165: LD_VAR 0 5
76169: PPUSH
76170: LD_VAR 0 6
76174: PPUSH
76175: CALL_OW 1
76179: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
76180: LD_VAR 0 1
76184: PUSH
76185: LD_EXP 67
76189: PUSH
76190: LD_VAR 0 5
76194: ARRAY
76195: IN
76196: IFFALSE 76235
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
76198: LD_ADDR_EXP 67
76202: PUSH
76203: LD_EXP 67
76207: PPUSH
76208: LD_VAR 0 5
76212: PPUSH
76213: LD_EXP 67
76217: PUSH
76218: LD_VAR 0 5
76222: ARRAY
76223: PUSH
76224: LD_VAR 0 1
76228: DIFF
76229: PPUSH
76230: CALL_OW 1
76234: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
76235: LD_VAR 0 1
76239: PUSH
76240: LD_EXP 68
76244: PUSH
76245: LD_VAR 0 5
76249: ARRAY
76250: IN
76251: IFFALSE 76290
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
76253: LD_ADDR_EXP 68
76257: PUSH
76258: LD_EXP 68
76262: PPUSH
76263: LD_VAR 0 5
76267: PPUSH
76268: LD_EXP 68
76272: PUSH
76273: LD_VAR 0 5
76277: ARRAY
76278: PUSH
76279: LD_VAR 0 1
76283: DIFF
76284: PPUSH
76285: CALL_OW 1
76289: ST_TO_ADDR
// break ;
76290: GO 76294
// end ;
76292: GO 76112
76294: POP
76295: POP
// end ;
76296: LD_VAR 0 4
76300: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
76301: LD_INT 0
76303: PPUSH
76304: PPUSH
76305: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
76306: LD_EXP 59
76310: NOT
76311: PUSH
76312: LD_EXP 57
76316: NOT
76317: OR
76318: PUSH
76319: LD_VAR 0 3
76323: PUSH
76324: LD_EXP 85
76328: IN
76329: NOT
76330: OR
76331: IFFALSE 76335
// exit ;
76333: GO 76458
// for i = 1 to mc_vehicles do
76335: LD_ADDR_VAR 0 6
76339: PUSH
76340: DOUBLE
76341: LD_INT 1
76343: DEC
76344: ST_TO_ADDR
76345: LD_EXP 78
76349: PUSH
76350: FOR_TO
76351: IFFALSE 76456
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
76353: LD_VAR 0 2
76357: PUSH
76358: LD_EXP 78
76362: PUSH
76363: LD_VAR 0 6
76367: ARRAY
76368: IN
76369: PUSH
76370: LD_VAR 0 1
76374: PUSH
76375: LD_EXP 78
76379: PUSH
76380: LD_VAR 0 6
76384: ARRAY
76385: IN
76386: OR
76387: IFFALSE 76454
// begin tmp := mc_vehicles [ i ] diff old ;
76389: LD_ADDR_VAR 0 7
76393: PUSH
76394: LD_EXP 78
76398: PUSH
76399: LD_VAR 0 6
76403: ARRAY
76404: PUSH
76405: LD_VAR 0 2
76409: DIFF
76410: ST_TO_ADDR
// tmp := tmp diff new ;
76411: LD_ADDR_VAR 0 7
76415: PUSH
76416: LD_VAR 0 7
76420: PUSH
76421: LD_VAR 0 1
76425: DIFF
76426: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
76427: LD_ADDR_EXP 78
76431: PUSH
76432: LD_EXP 78
76436: PPUSH
76437: LD_VAR 0 6
76441: PPUSH
76442: LD_VAR 0 7
76446: PPUSH
76447: CALL_OW 1
76451: ST_TO_ADDR
// break ;
76452: GO 76456
// end ;
76454: GO 76350
76456: POP
76457: POP
// end ;
76458: LD_VAR 0 5
76462: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
76463: LD_INT 0
76465: PPUSH
76466: PPUSH
76467: PPUSH
76468: PPUSH
// if not mc_bases or not skirmish then
76469: LD_EXP 59
76473: NOT
76474: PUSH
76475: LD_EXP 57
76479: NOT
76480: OR
76481: IFFALSE 76485
// exit ;
76483: GO 76862
// side := GetSide ( vehicle ) ;
76485: LD_ADDR_VAR 0 5
76489: PUSH
76490: LD_VAR 0 1
76494: PPUSH
76495: CALL_OW 255
76499: ST_TO_ADDR
// for i = 1 to mc_bases do
76500: LD_ADDR_VAR 0 4
76504: PUSH
76505: DOUBLE
76506: LD_INT 1
76508: DEC
76509: ST_TO_ADDR
76510: LD_EXP 59
76514: PUSH
76515: FOR_TO
76516: IFFALSE 76860
// begin if factory in mc_bases [ i ] then
76518: LD_VAR 0 2
76522: PUSH
76523: LD_EXP 59
76527: PUSH
76528: LD_VAR 0 4
76532: ARRAY
76533: IN
76534: IFFALSE 76858
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
76536: LD_EXP 81
76540: PUSH
76541: LD_VAR 0 4
76545: ARRAY
76546: PUSH
76547: LD_EXP 70
76551: PUSH
76552: LD_VAR 0 4
76556: ARRAY
76557: LESS
76558: PUSH
76559: LD_VAR 0 1
76563: PPUSH
76564: CALL_OW 264
76568: PUSH
76569: LD_INT 31
76571: PUSH
76572: LD_INT 32
76574: PUSH
76575: LD_INT 51
76577: PUSH
76578: LD_EXP 103
76582: PUSH
76583: LD_INT 12
76585: PUSH
76586: LD_INT 30
76588: PUSH
76589: LD_EXP 102
76593: PUSH
76594: LD_INT 11
76596: PUSH
76597: LD_INT 53
76599: PUSH
76600: LD_INT 14
76602: PUSH
76603: LD_EXP 106
76607: PUSH
76608: LD_INT 29
76610: PUSH
76611: LD_EXP 104
76615: PUSH
76616: LD_INT 13
76618: PUSH
76619: LD_INT 52
76621: PUSH
76622: LD_INT 48
76624: PUSH
76625: LD_INT 8
76627: PUSH
76628: EMPTY
76629: LIST
76630: LIST
76631: LIST
76632: LIST
76633: LIST
76634: LIST
76635: LIST
76636: LIST
76637: LIST
76638: LIST
76639: LIST
76640: LIST
76641: LIST
76642: LIST
76643: LIST
76644: LIST
76645: LIST
76646: IN
76647: NOT
76648: AND
76649: IFFALSE 76697
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
76651: LD_ADDR_EXP 81
76655: PUSH
76656: LD_EXP 81
76660: PPUSH
76661: LD_VAR 0 4
76665: PUSH
76666: LD_EXP 81
76670: PUSH
76671: LD_VAR 0 4
76675: ARRAY
76676: PUSH
76677: LD_INT 1
76679: PLUS
76680: PUSH
76681: EMPTY
76682: LIST
76683: LIST
76684: PPUSH
76685: LD_VAR 0 1
76689: PPUSH
76690: CALL 19238 0 3
76694: ST_TO_ADDR
76695: GO 76741
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
76697: LD_ADDR_EXP 78
76701: PUSH
76702: LD_EXP 78
76706: PPUSH
76707: LD_VAR 0 4
76711: PUSH
76712: LD_EXP 78
76716: PUSH
76717: LD_VAR 0 4
76721: ARRAY
76722: PUSH
76723: LD_INT 1
76725: PLUS
76726: PUSH
76727: EMPTY
76728: LIST
76729: LIST
76730: PPUSH
76731: LD_VAR 0 1
76735: PPUSH
76736: CALL 19238 0 3
76740: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
76741: LD_VAR 0 1
76745: PPUSH
76746: CALL_OW 263
76750: PUSH
76751: LD_INT 2
76753: EQUAL
76754: IFFALSE 76774
// begin repeat wait ( 0 0$1 ) ;
76756: LD_INT 35
76758: PPUSH
76759: CALL_OW 67
// until IsControledBy ( vehicle ) ;
76763: LD_VAR 0 1
76767: PPUSH
76768: CALL_OW 312
76772: IFFALSE 76756
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
76774: LD_VAR 0 1
76778: PPUSH
76779: LD_EXP 83
76783: PUSH
76784: LD_VAR 0 4
76788: ARRAY
76789: PPUSH
76790: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
76794: LD_VAR 0 1
76798: PPUSH
76799: CALL_OW 263
76803: PUSH
76804: LD_INT 1
76806: NONEQUAL
76807: IFFALSE 76811
// break ;
76809: GO 76860
// repeat wait ( 0 0$1 ) ;
76811: LD_INT 35
76813: PPUSH
76814: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
76818: LD_VAR 0 1
76822: PPUSH
76823: LD_EXP 83
76827: PUSH
76828: LD_VAR 0 4
76832: ARRAY
76833: PPUSH
76834: CALL_OW 308
76838: IFFALSE 76811
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
76840: LD_VAR 0 1
76844: PPUSH
76845: CALL_OW 311
76849: PPUSH
76850: CALL_OW 121
// exit ;
76854: POP
76855: POP
76856: GO 76862
// end ; end ;
76858: GO 76515
76860: POP
76861: POP
// end ;
76862: LD_VAR 0 3
76866: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
76867: LD_INT 0
76869: PPUSH
76870: PPUSH
76871: PPUSH
76872: PPUSH
// if not mc_bases or not skirmish then
76873: LD_EXP 59
76877: NOT
76878: PUSH
76879: LD_EXP 57
76883: NOT
76884: OR
76885: IFFALSE 76889
// exit ;
76887: GO 77242
// repeat wait ( 0 0$1 ) ;
76889: LD_INT 35
76891: PPUSH
76892: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
76896: LD_VAR 0 2
76900: PPUSH
76901: LD_VAR 0 3
76905: PPUSH
76906: CALL_OW 284
76910: IFFALSE 76889
// if GetResourceTypeXY ( x , y ) = mat_artefact then
76912: LD_VAR 0 2
76916: PPUSH
76917: LD_VAR 0 3
76921: PPUSH
76922: CALL_OW 283
76926: PUSH
76927: LD_INT 4
76929: EQUAL
76930: IFFALSE 76934
// exit ;
76932: GO 77242
// for i = 1 to mc_bases do
76934: LD_ADDR_VAR 0 7
76938: PUSH
76939: DOUBLE
76940: LD_INT 1
76942: DEC
76943: ST_TO_ADDR
76944: LD_EXP 59
76948: PUSH
76949: FOR_TO
76950: IFFALSE 77240
// begin if mc_crates_area [ i ] then
76952: LD_EXP 77
76956: PUSH
76957: LD_VAR 0 7
76961: ARRAY
76962: IFFALSE 77073
// for j in mc_crates_area [ i ] do
76964: LD_ADDR_VAR 0 8
76968: PUSH
76969: LD_EXP 77
76973: PUSH
76974: LD_VAR 0 7
76978: ARRAY
76979: PUSH
76980: FOR_IN
76981: IFFALSE 77071
// if InArea ( x , y , j ) then
76983: LD_VAR 0 2
76987: PPUSH
76988: LD_VAR 0 3
76992: PPUSH
76993: LD_VAR 0 8
76997: PPUSH
76998: CALL_OW 309
77002: IFFALSE 77069
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77004: LD_ADDR_EXP 75
77008: PUSH
77009: LD_EXP 75
77013: PPUSH
77014: LD_VAR 0 7
77018: PUSH
77019: LD_EXP 75
77023: PUSH
77024: LD_VAR 0 7
77028: ARRAY
77029: PUSH
77030: LD_INT 1
77032: PLUS
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PPUSH
77038: LD_VAR 0 4
77042: PUSH
77043: LD_VAR 0 2
77047: PUSH
77048: LD_VAR 0 3
77052: PUSH
77053: EMPTY
77054: LIST
77055: LIST
77056: LIST
77057: PPUSH
77058: CALL 19238 0 3
77062: ST_TO_ADDR
// exit ;
77063: POP
77064: POP
77065: POP
77066: POP
77067: GO 77242
// end ;
77069: GO 76980
77071: POP
77072: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77073: LD_ADDR_VAR 0 9
77077: PUSH
77078: LD_EXP 59
77082: PUSH
77083: LD_VAR 0 7
77087: ARRAY
77088: PPUSH
77089: LD_INT 2
77091: PUSH
77092: LD_INT 30
77094: PUSH
77095: LD_INT 0
77097: PUSH
77098: EMPTY
77099: LIST
77100: LIST
77101: PUSH
77102: LD_INT 30
77104: PUSH
77105: LD_INT 1
77107: PUSH
77108: EMPTY
77109: LIST
77110: LIST
77111: PUSH
77112: EMPTY
77113: LIST
77114: LIST
77115: LIST
77116: PPUSH
77117: CALL_OW 72
77121: ST_TO_ADDR
// if not depot then
77122: LD_VAR 0 9
77126: NOT
77127: IFFALSE 77131
// continue ;
77129: GO 76949
// for j in depot do
77131: LD_ADDR_VAR 0 8
77135: PUSH
77136: LD_VAR 0 9
77140: PUSH
77141: FOR_IN
77142: IFFALSE 77236
// if GetDistUnitXY ( j , x , y ) < 30 then
77144: LD_VAR 0 8
77148: PPUSH
77149: LD_VAR 0 2
77153: PPUSH
77154: LD_VAR 0 3
77158: PPUSH
77159: CALL_OW 297
77163: PUSH
77164: LD_INT 30
77166: LESS
77167: IFFALSE 77234
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77169: LD_ADDR_EXP 75
77173: PUSH
77174: LD_EXP 75
77178: PPUSH
77179: LD_VAR 0 7
77183: PUSH
77184: LD_EXP 75
77188: PUSH
77189: LD_VAR 0 7
77193: ARRAY
77194: PUSH
77195: LD_INT 1
77197: PLUS
77198: PUSH
77199: EMPTY
77200: LIST
77201: LIST
77202: PPUSH
77203: LD_VAR 0 4
77207: PUSH
77208: LD_VAR 0 2
77212: PUSH
77213: LD_VAR 0 3
77217: PUSH
77218: EMPTY
77219: LIST
77220: LIST
77221: LIST
77222: PPUSH
77223: CALL 19238 0 3
77227: ST_TO_ADDR
// exit ;
77228: POP
77229: POP
77230: POP
77231: POP
77232: GO 77242
// end ;
77234: GO 77141
77236: POP
77237: POP
// end ;
77238: GO 76949
77240: POP
77241: POP
// end ;
77242: LD_VAR 0 6
77246: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
77247: LD_INT 0
77249: PPUSH
77250: PPUSH
77251: PPUSH
77252: PPUSH
// if not mc_bases or not skirmish then
77253: LD_EXP 59
77257: NOT
77258: PUSH
77259: LD_EXP 57
77263: NOT
77264: OR
77265: IFFALSE 77269
// exit ;
77267: GO 77546
// side := GetSide ( lab ) ;
77269: LD_ADDR_VAR 0 4
77273: PUSH
77274: LD_VAR 0 2
77278: PPUSH
77279: CALL_OW 255
77283: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
77284: LD_VAR 0 4
77288: PUSH
77289: LD_EXP 85
77293: IN
77294: NOT
77295: PUSH
77296: LD_EXP 86
77300: NOT
77301: OR
77302: PUSH
77303: LD_EXP 59
77307: NOT
77308: OR
77309: IFFALSE 77313
// exit ;
77311: GO 77546
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
77313: LD_ADDR_EXP 86
77317: PUSH
77318: LD_EXP 86
77322: PPUSH
77323: LD_VAR 0 4
77327: PPUSH
77328: LD_EXP 86
77332: PUSH
77333: LD_VAR 0 4
77337: ARRAY
77338: PUSH
77339: LD_VAR 0 1
77343: DIFF
77344: PPUSH
77345: CALL_OW 1
77349: ST_TO_ADDR
// for i = 1 to mc_bases do
77350: LD_ADDR_VAR 0 5
77354: PUSH
77355: DOUBLE
77356: LD_INT 1
77358: DEC
77359: ST_TO_ADDR
77360: LD_EXP 59
77364: PUSH
77365: FOR_TO
77366: IFFALSE 77544
// begin if lab in mc_bases [ i ] then
77368: LD_VAR 0 2
77372: PUSH
77373: LD_EXP 59
77377: PUSH
77378: LD_VAR 0 5
77382: ARRAY
77383: IN
77384: IFFALSE 77542
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
77386: LD_VAR 0 1
77390: PUSH
77391: LD_INT 11
77393: PUSH
77394: LD_INT 4
77396: PUSH
77397: LD_INT 3
77399: PUSH
77400: LD_INT 2
77402: PUSH
77403: EMPTY
77404: LIST
77405: LIST
77406: LIST
77407: LIST
77408: IN
77409: PUSH
77410: LD_EXP 89
77414: PUSH
77415: LD_VAR 0 5
77419: ARRAY
77420: AND
77421: IFFALSE 77542
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
77423: LD_ADDR_VAR 0 6
77427: PUSH
77428: LD_EXP 89
77432: PUSH
77433: LD_VAR 0 5
77437: ARRAY
77438: PUSH
77439: LD_INT 1
77441: ARRAY
77442: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77443: LD_ADDR_EXP 89
77447: PUSH
77448: LD_EXP 89
77452: PPUSH
77453: LD_VAR 0 5
77457: PPUSH
77458: EMPTY
77459: PPUSH
77460: CALL_OW 1
77464: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
77465: LD_VAR 0 6
77469: PPUSH
77470: LD_INT 0
77472: PPUSH
77473: CALL_OW 109
// ComExitBuilding ( tmp ) ;
77477: LD_VAR 0 6
77481: PPUSH
77482: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
77486: LD_ADDR_EXP 88
77490: PUSH
77491: LD_EXP 88
77495: PPUSH
77496: LD_VAR 0 5
77500: PPUSH
77501: LD_EXP 88
77505: PUSH
77506: LD_VAR 0 5
77510: ARRAY
77511: PPUSH
77512: LD_INT 1
77514: PPUSH
77515: LD_VAR 0 6
77519: PPUSH
77520: CALL_OW 2
77524: PPUSH
77525: CALL_OW 1
77529: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
77530: LD_VAR 0 5
77534: PPUSH
77535: LD_INT 112
77537: PPUSH
77538: CALL 54542 0 2
// end ; end ; end ;
77542: GO 77365
77544: POP
77545: POP
// end ;
77546: LD_VAR 0 3
77550: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
77551: LD_INT 0
77553: PPUSH
77554: PPUSH
77555: PPUSH
77556: PPUSH
77557: PPUSH
77558: PPUSH
77559: PPUSH
77560: PPUSH
// if not mc_bases or not skirmish then
77561: LD_EXP 59
77565: NOT
77566: PUSH
77567: LD_EXP 57
77571: NOT
77572: OR
77573: IFFALSE 77577
// exit ;
77575: GO 78948
// for i = 1 to mc_bases do
77577: LD_ADDR_VAR 0 3
77581: PUSH
77582: DOUBLE
77583: LD_INT 1
77585: DEC
77586: ST_TO_ADDR
77587: LD_EXP 59
77591: PUSH
77592: FOR_TO
77593: IFFALSE 78946
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
77595: LD_VAR 0 1
77599: PUSH
77600: LD_EXP 59
77604: PUSH
77605: LD_VAR 0 3
77609: ARRAY
77610: IN
77611: PUSH
77612: LD_VAR 0 1
77616: PUSH
77617: LD_EXP 66
77621: PUSH
77622: LD_VAR 0 3
77626: ARRAY
77627: IN
77628: OR
77629: PUSH
77630: LD_VAR 0 1
77634: PUSH
77635: LD_EXP 81
77639: PUSH
77640: LD_VAR 0 3
77644: ARRAY
77645: IN
77646: OR
77647: PUSH
77648: LD_VAR 0 1
77652: PUSH
77653: LD_EXP 78
77657: PUSH
77658: LD_VAR 0 3
77662: ARRAY
77663: IN
77664: OR
77665: PUSH
77666: LD_VAR 0 1
77670: PUSH
77671: LD_EXP 88
77675: PUSH
77676: LD_VAR 0 3
77680: ARRAY
77681: IN
77682: OR
77683: PUSH
77684: LD_VAR 0 1
77688: PUSH
77689: LD_EXP 89
77693: PUSH
77694: LD_VAR 0 3
77698: ARRAY
77699: IN
77700: OR
77701: IFFALSE 78944
// begin if un in mc_ape [ i ] then
77703: LD_VAR 0 1
77707: PUSH
77708: LD_EXP 88
77712: PUSH
77713: LD_VAR 0 3
77717: ARRAY
77718: IN
77719: IFFALSE 77758
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
77721: LD_ADDR_EXP 88
77725: PUSH
77726: LD_EXP 88
77730: PPUSH
77731: LD_VAR 0 3
77735: PPUSH
77736: LD_EXP 88
77740: PUSH
77741: LD_VAR 0 3
77745: ARRAY
77746: PUSH
77747: LD_VAR 0 1
77751: DIFF
77752: PPUSH
77753: CALL_OW 1
77757: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
77758: LD_VAR 0 1
77762: PUSH
77763: LD_EXP 89
77767: PUSH
77768: LD_VAR 0 3
77772: ARRAY
77773: IN
77774: IFFALSE 77798
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77776: LD_ADDR_EXP 89
77780: PUSH
77781: LD_EXP 89
77785: PPUSH
77786: LD_VAR 0 3
77790: PPUSH
77791: EMPTY
77792: PPUSH
77793: CALL_OW 1
77797: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
77798: LD_VAR 0 1
77802: PPUSH
77803: CALL_OW 247
77807: PUSH
77808: LD_INT 2
77810: EQUAL
77811: PUSH
77812: LD_VAR 0 1
77816: PPUSH
77817: CALL_OW 110
77821: PUSH
77822: LD_INT 20
77824: EQUAL
77825: PUSH
77826: LD_VAR 0 1
77830: PUSH
77831: LD_EXP 81
77835: PUSH
77836: LD_VAR 0 3
77840: ARRAY
77841: IN
77842: OR
77843: PUSH
77844: LD_VAR 0 1
77848: PPUSH
77849: CALL_OW 264
77853: PUSH
77854: LD_INT 12
77856: PUSH
77857: LD_INT 51
77859: PUSH
77860: LD_EXP 103
77864: PUSH
77865: LD_INT 32
77867: PUSH
77868: LD_INT 13
77870: PUSH
77871: LD_INT 52
77873: PUSH
77874: LD_INT 31
77876: PUSH
77877: EMPTY
77878: LIST
77879: LIST
77880: LIST
77881: LIST
77882: LIST
77883: LIST
77884: LIST
77885: IN
77886: OR
77887: AND
77888: IFFALSE 78196
// begin if un in mc_defender [ i ] then
77890: LD_VAR 0 1
77894: PUSH
77895: LD_EXP 81
77899: PUSH
77900: LD_VAR 0 3
77904: ARRAY
77905: IN
77906: IFFALSE 77945
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
77908: LD_ADDR_EXP 81
77912: PUSH
77913: LD_EXP 81
77917: PPUSH
77918: LD_VAR 0 3
77922: PPUSH
77923: LD_EXP 81
77927: PUSH
77928: LD_VAR 0 3
77932: ARRAY
77933: PUSH
77934: LD_VAR 0 1
77938: DIFF
77939: PPUSH
77940: CALL_OW 1
77944: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
77945: LD_ADDR_VAR 0 8
77949: PUSH
77950: LD_VAR 0 3
77954: PPUSH
77955: LD_INT 3
77957: PPUSH
77958: CALL 74614 0 2
77962: ST_TO_ADDR
// if fac then
77963: LD_VAR 0 8
77967: IFFALSE 78196
// begin for j in fac do
77969: LD_ADDR_VAR 0 4
77973: PUSH
77974: LD_VAR 0 8
77978: PUSH
77979: FOR_IN
77980: IFFALSE 78194
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
77982: LD_ADDR_VAR 0 9
77986: PUSH
77987: LD_VAR 0 8
77991: PPUSH
77992: LD_VAR 0 1
77996: PPUSH
77997: CALL_OW 265
78001: PPUSH
78002: LD_VAR 0 1
78006: PPUSH
78007: CALL_OW 262
78011: PPUSH
78012: LD_VAR 0 1
78016: PPUSH
78017: CALL_OW 263
78021: PPUSH
78022: LD_VAR 0 1
78026: PPUSH
78027: CALL_OW 264
78031: PPUSH
78032: CALL 16770 0 5
78036: ST_TO_ADDR
// if components then
78037: LD_VAR 0 9
78041: IFFALSE 78192
// begin if GetWeapon ( un ) = ar_control_tower then
78043: LD_VAR 0 1
78047: PPUSH
78048: CALL_OW 264
78052: PUSH
78053: LD_INT 31
78055: EQUAL
78056: IFFALSE 78173
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
78058: LD_VAR 0 1
78062: PPUSH
78063: CALL_OW 311
78067: PPUSH
78068: LD_INT 0
78070: PPUSH
78071: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
78075: LD_ADDR_EXP 99
78079: PUSH
78080: LD_EXP 99
78084: PPUSH
78085: LD_VAR 0 3
78089: PPUSH
78090: LD_EXP 99
78094: PUSH
78095: LD_VAR 0 3
78099: ARRAY
78100: PUSH
78101: LD_VAR 0 1
78105: PPUSH
78106: CALL_OW 311
78110: DIFF
78111: PPUSH
78112: CALL_OW 1
78116: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
78117: LD_ADDR_VAR 0 7
78121: PUSH
78122: LD_EXP 80
78126: PUSH
78127: LD_VAR 0 3
78131: ARRAY
78132: PPUSH
78133: LD_INT 1
78135: PPUSH
78136: LD_VAR 0 9
78140: PPUSH
78141: CALL_OW 2
78145: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
78146: LD_ADDR_EXP 80
78150: PUSH
78151: LD_EXP 80
78155: PPUSH
78156: LD_VAR 0 3
78160: PPUSH
78161: LD_VAR 0 7
78165: PPUSH
78166: CALL_OW 1
78170: ST_TO_ADDR
// end else
78171: GO 78190
// MC_InsertProduceList ( i , [ components ] ) ;
78173: LD_VAR 0 3
78177: PPUSH
78178: LD_VAR 0 9
78182: PUSH
78183: EMPTY
78184: LIST
78185: PPUSH
78186: CALL 74159 0 2
// break ;
78190: GO 78194
// end ; end ;
78192: GO 77979
78194: POP
78195: POP
// end ; end ; if GetType ( un ) = unit_building then
78196: LD_VAR 0 1
78200: PPUSH
78201: CALL_OW 247
78205: PUSH
78206: LD_INT 3
78208: EQUAL
78209: IFFALSE 78612
// begin btype := GetBType ( un ) ;
78211: LD_ADDR_VAR 0 5
78215: PUSH
78216: LD_VAR 0 1
78220: PPUSH
78221: CALL_OW 266
78225: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
78226: LD_VAR 0 5
78230: PUSH
78231: LD_INT 29
78233: PUSH
78234: LD_INT 30
78236: PUSH
78237: EMPTY
78238: LIST
78239: LIST
78240: IN
78241: IFFALSE 78314
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
78243: LD_VAR 0 1
78247: PPUSH
78248: CALL_OW 250
78252: PPUSH
78253: LD_VAR 0 1
78257: PPUSH
78258: CALL_OW 251
78262: PPUSH
78263: LD_VAR 0 1
78267: PPUSH
78268: CALL_OW 255
78272: PPUSH
78273: CALL_OW 440
78277: NOT
78278: IFFALSE 78314
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
78280: LD_VAR 0 1
78284: PPUSH
78285: CALL_OW 250
78289: PPUSH
78290: LD_VAR 0 1
78294: PPUSH
78295: CALL_OW 251
78299: PPUSH
78300: LD_VAR 0 1
78304: PPUSH
78305: CALL_OW 255
78309: PPUSH
78310: CALL_OW 441
// end ; if btype = b_warehouse then
78314: LD_VAR 0 5
78318: PUSH
78319: LD_INT 1
78321: EQUAL
78322: IFFALSE 78340
// begin btype := b_depot ;
78324: LD_ADDR_VAR 0 5
78328: PUSH
78329: LD_INT 0
78331: ST_TO_ADDR
// pos := 1 ;
78332: LD_ADDR_VAR 0 6
78336: PUSH
78337: LD_INT 1
78339: ST_TO_ADDR
// end ; if btype = b_factory then
78340: LD_VAR 0 5
78344: PUSH
78345: LD_INT 3
78347: EQUAL
78348: IFFALSE 78366
// begin btype := b_workshop ;
78350: LD_ADDR_VAR 0 5
78354: PUSH
78355: LD_INT 2
78357: ST_TO_ADDR
// pos := 1 ;
78358: LD_ADDR_VAR 0 6
78362: PUSH
78363: LD_INT 1
78365: ST_TO_ADDR
// end ; if btype = b_barracks then
78366: LD_VAR 0 5
78370: PUSH
78371: LD_INT 5
78373: EQUAL
78374: IFFALSE 78384
// btype := b_armoury ;
78376: LD_ADDR_VAR 0 5
78380: PUSH
78381: LD_INT 4
78383: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
78384: LD_VAR 0 5
78388: PUSH
78389: LD_INT 7
78391: PUSH
78392: LD_INT 8
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: IN
78399: IFFALSE 78409
// btype := b_lab ;
78401: LD_ADDR_VAR 0 5
78405: PUSH
78406: LD_INT 6
78408: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
78409: LD_ADDR_EXP 64
78413: PUSH
78414: LD_EXP 64
78418: PPUSH
78419: LD_VAR 0 3
78423: PUSH
78424: LD_EXP 64
78428: PUSH
78429: LD_VAR 0 3
78433: ARRAY
78434: PUSH
78435: LD_INT 1
78437: PLUS
78438: PUSH
78439: EMPTY
78440: LIST
78441: LIST
78442: PPUSH
78443: LD_VAR 0 5
78447: PUSH
78448: LD_VAR 0 1
78452: PPUSH
78453: CALL_OW 250
78457: PUSH
78458: LD_VAR 0 1
78462: PPUSH
78463: CALL_OW 251
78467: PUSH
78468: LD_VAR 0 1
78472: PPUSH
78473: CALL_OW 254
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: LIST
78482: LIST
78483: PPUSH
78484: CALL 19238 0 3
78488: ST_TO_ADDR
// if pos = 1 then
78489: LD_VAR 0 6
78493: PUSH
78494: LD_INT 1
78496: EQUAL
78497: IFFALSE 78612
// begin tmp := mc_build_list [ i ] ;
78499: LD_ADDR_VAR 0 7
78503: PUSH
78504: LD_EXP 64
78508: PUSH
78509: LD_VAR 0 3
78513: ARRAY
78514: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78515: LD_VAR 0 7
78519: PPUSH
78520: LD_INT 2
78522: PUSH
78523: LD_INT 30
78525: PUSH
78526: LD_INT 0
78528: PUSH
78529: EMPTY
78530: LIST
78531: LIST
78532: PUSH
78533: LD_INT 30
78535: PUSH
78536: LD_INT 1
78538: PUSH
78539: EMPTY
78540: LIST
78541: LIST
78542: PUSH
78543: EMPTY
78544: LIST
78545: LIST
78546: LIST
78547: PPUSH
78548: CALL_OW 72
78552: IFFALSE 78562
// pos := 2 ;
78554: LD_ADDR_VAR 0 6
78558: PUSH
78559: LD_INT 2
78561: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
78562: LD_ADDR_VAR 0 7
78566: PUSH
78567: LD_VAR 0 7
78571: PPUSH
78572: LD_VAR 0 6
78576: PPUSH
78577: LD_VAR 0 7
78581: PPUSH
78582: CALL 19564 0 3
78586: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
78587: LD_ADDR_EXP 64
78591: PUSH
78592: LD_EXP 64
78596: PPUSH
78597: LD_VAR 0 3
78601: PPUSH
78602: LD_VAR 0 7
78606: PPUSH
78607: CALL_OW 1
78611: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
78612: LD_VAR 0 1
78616: PUSH
78617: LD_EXP 59
78621: PUSH
78622: LD_VAR 0 3
78626: ARRAY
78627: IN
78628: IFFALSE 78667
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
78630: LD_ADDR_EXP 59
78634: PUSH
78635: LD_EXP 59
78639: PPUSH
78640: LD_VAR 0 3
78644: PPUSH
78645: LD_EXP 59
78649: PUSH
78650: LD_VAR 0 3
78654: ARRAY
78655: PUSH
78656: LD_VAR 0 1
78660: DIFF
78661: PPUSH
78662: CALL_OW 1
78666: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
78667: LD_VAR 0 1
78671: PUSH
78672: LD_EXP 66
78676: PUSH
78677: LD_VAR 0 3
78681: ARRAY
78682: IN
78683: IFFALSE 78722
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
78685: LD_ADDR_EXP 66
78689: PUSH
78690: LD_EXP 66
78694: PPUSH
78695: LD_VAR 0 3
78699: PPUSH
78700: LD_EXP 66
78704: PUSH
78705: LD_VAR 0 3
78709: ARRAY
78710: PUSH
78711: LD_VAR 0 1
78715: DIFF
78716: PPUSH
78717: CALL_OW 1
78721: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
78722: LD_VAR 0 1
78726: PUSH
78727: LD_EXP 78
78731: PUSH
78732: LD_VAR 0 3
78736: ARRAY
78737: IN
78738: IFFALSE 78777
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
78740: LD_ADDR_EXP 78
78744: PUSH
78745: LD_EXP 78
78749: PPUSH
78750: LD_VAR 0 3
78754: PPUSH
78755: LD_EXP 78
78759: PUSH
78760: LD_VAR 0 3
78764: ARRAY
78765: PUSH
78766: LD_VAR 0 1
78770: DIFF
78771: PPUSH
78772: CALL_OW 1
78776: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
78777: LD_VAR 0 1
78781: PUSH
78782: LD_EXP 81
78786: PUSH
78787: LD_VAR 0 3
78791: ARRAY
78792: IN
78793: IFFALSE 78832
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78795: LD_ADDR_EXP 81
78799: PUSH
78800: LD_EXP 81
78804: PPUSH
78805: LD_VAR 0 3
78809: PPUSH
78810: LD_EXP 81
78814: PUSH
78815: LD_VAR 0 3
78819: ARRAY
78820: PUSH
78821: LD_VAR 0 1
78825: DIFF
78826: PPUSH
78827: CALL_OW 1
78831: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
78832: LD_VAR 0 1
78836: PUSH
78837: LD_EXP 68
78841: PUSH
78842: LD_VAR 0 3
78846: ARRAY
78847: IN
78848: IFFALSE 78887
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
78850: LD_ADDR_EXP 68
78854: PUSH
78855: LD_EXP 68
78859: PPUSH
78860: LD_VAR 0 3
78864: PPUSH
78865: LD_EXP 68
78869: PUSH
78870: LD_VAR 0 3
78874: ARRAY
78875: PUSH
78876: LD_VAR 0 1
78880: DIFF
78881: PPUSH
78882: CALL_OW 1
78886: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
78887: LD_VAR 0 1
78891: PUSH
78892: LD_EXP 67
78896: PUSH
78897: LD_VAR 0 3
78901: ARRAY
78902: IN
78903: IFFALSE 78942
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
78905: LD_ADDR_EXP 67
78909: PUSH
78910: LD_EXP 67
78914: PPUSH
78915: LD_VAR 0 3
78919: PPUSH
78920: LD_EXP 67
78924: PUSH
78925: LD_VAR 0 3
78929: ARRAY
78930: PUSH
78931: LD_VAR 0 1
78935: DIFF
78936: PPUSH
78937: CALL_OW 1
78941: ST_TO_ADDR
// end ; break ;
78942: GO 78946
// end ;
78944: GO 77592
78946: POP
78947: POP
// end ;
78948: LD_VAR 0 2
78952: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
78953: LD_INT 0
78955: PPUSH
78956: PPUSH
78957: PPUSH
// if not mc_bases or not skirmish then
78958: LD_EXP 59
78962: NOT
78963: PUSH
78964: LD_EXP 57
78968: NOT
78969: OR
78970: IFFALSE 78974
// exit ;
78972: GO 79189
// for i = 1 to mc_bases do
78974: LD_ADDR_VAR 0 3
78978: PUSH
78979: DOUBLE
78980: LD_INT 1
78982: DEC
78983: ST_TO_ADDR
78984: LD_EXP 59
78988: PUSH
78989: FOR_TO
78990: IFFALSE 79187
// begin if building in mc_construct_list [ i ] then
78992: LD_VAR 0 1
78996: PUSH
78997: LD_EXP 66
79001: PUSH
79002: LD_VAR 0 3
79006: ARRAY
79007: IN
79008: IFFALSE 79185
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79010: LD_ADDR_EXP 66
79014: PUSH
79015: LD_EXP 66
79019: PPUSH
79020: LD_VAR 0 3
79024: PPUSH
79025: LD_EXP 66
79029: PUSH
79030: LD_VAR 0 3
79034: ARRAY
79035: PUSH
79036: LD_VAR 0 1
79040: DIFF
79041: PPUSH
79042: CALL_OW 1
79046: ST_TO_ADDR
// if building in mc_lab [ i ] then
79047: LD_VAR 0 1
79051: PUSH
79052: LD_EXP 92
79056: PUSH
79057: LD_VAR 0 3
79061: ARRAY
79062: IN
79063: IFFALSE 79118
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
79065: LD_ADDR_EXP 93
79069: PUSH
79070: LD_EXP 93
79074: PPUSH
79075: LD_VAR 0 3
79079: PPUSH
79080: LD_EXP 93
79084: PUSH
79085: LD_VAR 0 3
79089: ARRAY
79090: PPUSH
79091: LD_INT 1
79093: PPUSH
79094: LD_EXP 93
79098: PUSH
79099: LD_VAR 0 3
79103: ARRAY
79104: PPUSH
79105: LD_INT 0
79107: PPUSH
79108: CALL 18656 0 4
79112: PPUSH
79113: CALL_OW 1
79117: ST_TO_ADDR
// if not building in mc_bases [ i ] then
79118: LD_VAR 0 1
79122: PUSH
79123: LD_EXP 59
79127: PUSH
79128: LD_VAR 0 3
79132: ARRAY
79133: IN
79134: NOT
79135: IFFALSE 79181
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79137: LD_ADDR_EXP 59
79141: PUSH
79142: LD_EXP 59
79146: PPUSH
79147: LD_VAR 0 3
79151: PUSH
79152: LD_EXP 59
79156: PUSH
79157: LD_VAR 0 3
79161: ARRAY
79162: PUSH
79163: LD_INT 1
79165: PLUS
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PPUSH
79171: LD_VAR 0 1
79175: PPUSH
79176: CALL 19238 0 3
79180: ST_TO_ADDR
// exit ;
79181: POP
79182: POP
79183: GO 79189
// end ; end ;
79185: GO 78989
79187: POP
79188: POP
// end ;
79189: LD_VAR 0 2
79193: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
79194: LD_INT 0
79196: PPUSH
79197: PPUSH
79198: PPUSH
79199: PPUSH
79200: PPUSH
79201: PPUSH
79202: PPUSH
// if not mc_bases or not skirmish then
79203: LD_EXP 59
79207: NOT
79208: PUSH
79209: LD_EXP 57
79213: NOT
79214: OR
79215: IFFALSE 79219
// exit ;
79217: GO 79880
// for i = 1 to mc_bases do
79219: LD_ADDR_VAR 0 3
79223: PUSH
79224: DOUBLE
79225: LD_INT 1
79227: DEC
79228: ST_TO_ADDR
79229: LD_EXP 59
79233: PUSH
79234: FOR_TO
79235: IFFALSE 79878
// begin if building in mc_construct_list [ i ] then
79237: LD_VAR 0 1
79241: PUSH
79242: LD_EXP 66
79246: PUSH
79247: LD_VAR 0 3
79251: ARRAY
79252: IN
79253: IFFALSE 79876
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79255: LD_ADDR_EXP 66
79259: PUSH
79260: LD_EXP 66
79264: PPUSH
79265: LD_VAR 0 3
79269: PPUSH
79270: LD_EXP 66
79274: PUSH
79275: LD_VAR 0 3
79279: ARRAY
79280: PUSH
79281: LD_VAR 0 1
79285: DIFF
79286: PPUSH
79287: CALL_OW 1
79291: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79292: LD_ADDR_EXP 59
79296: PUSH
79297: LD_EXP 59
79301: PPUSH
79302: LD_VAR 0 3
79306: PUSH
79307: LD_EXP 59
79311: PUSH
79312: LD_VAR 0 3
79316: ARRAY
79317: PUSH
79318: LD_INT 1
79320: PLUS
79321: PUSH
79322: EMPTY
79323: LIST
79324: LIST
79325: PPUSH
79326: LD_VAR 0 1
79330: PPUSH
79331: CALL 19238 0 3
79335: ST_TO_ADDR
// btype := GetBType ( building ) ;
79336: LD_ADDR_VAR 0 5
79340: PUSH
79341: LD_VAR 0 1
79345: PPUSH
79346: CALL_OW 266
79350: ST_TO_ADDR
// side := GetSide ( building ) ;
79351: LD_ADDR_VAR 0 8
79355: PUSH
79356: LD_VAR 0 1
79360: PPUSH
79361: CALL_OW 255
79365: ST_TO_ADDR
// if btype = b_lab then
79366: LD_VAR 0 5
79370: PUSH
79371: LD_INT 6
79373: EQUAL
79374: IFFALSE 79424
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
79376: LD_ADDR_EXP 92
79380: PUSH
79381: LD_EXP 92
79385: PPUSH
79386: LD_VAR 0 3
79390: PUSH
79391: LD_EXP 92
79395: PUSH
79396: LD_VAR 0 3
79400: ARRAY
79401: PUSH
79402: LD_INT 1
79404: PLUS
79405: PUSH
79406: EMPTY
79407: LIST
79408: LIST
79409: PPUSH
79410: LD_VAR 0 1
79414: PPUSH
79415: CALL 19238 0 3
79419: ST_TO_ADDR
// exit ;
79420: POP
79421: POP
79422: GO 79880
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
79424: LD_VAR 0 5
79428: PUSH
79429: LD_INT 0
79431: PUSH
79432: LD_INT 2
79434: PUSH
79435: LD_INT 4
79437: PUSH
79438: EMPTY
79439: LIST
79440: LIST
79441: LIST
79442: IN
79443: IFFALSE 79567
// begin if btype = b_armoury then
79445: LD_VAR 0 5
79449: PUSH
79450: LD_INT 4
79452: EQUAL
79453: IFFALSE 79463
// btype := b_barracks ;
79455: LD_ADDR_VAR 0 5
79459: PUSH
79460: LD_INT 5
79462: ST_TO_ADDR
// if btype = b_depot then
79463: LD_VAR 0 5
79467: PUSH
79468: LD_INT 0
79470: EQUAL
79471: IFFALSE 79481
// btype := b_warehouse ;
79473: LD_ADDR_VAR 0 5
79477: PUSH
79478: LD_INT 1
79480: ST_TO_ADDR
// if btype = b_workshop then
79481: LD_VAR 0 5
79485: PUSH
79486: LD_INT 2
79488: EQUAL
79489: IFFALSE 79499
// btype := b_factory ;
79491: LD_ADDR_VAR 0 5
79495: PUSH
79496: LD_INT 3
79498: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
79499: LD_VAR 0 5
79503: PPUSH
79504: LD_VAR 0 8
79508: PPUSH
79509: CALL_OW 323
79513: PUSH
79514: LD_INT 1
79516: EQUAL
79517: IFFALSE 79563
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
79519: LD_ADDR_EXP 91
79523: PUSH
79524: LD_EXP 91
79528: PPUSH
79529: LD_VAR 0 3
79533: PUSH
79534: LD_EXP 91
79538: PUSH
79539: LD_VAR 0 3
79543: ARRAY
79544: PUSH
79545: LD_INT 1
79547: PLUS
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: PPUSH
79553: LD_VAR 0 1
79557: PPUSH
79558: CALL 19238 0 3
79562: ST_TO_ADDR
// exit ;
79563: POP
79564: POP
79565: GO 79880
// end ; if btype in [ b_bunker , b_turret ] then
79567: LD_VAR 0 5
79571: PUSH
79572: LD_INT 32
79574: PUSH
79575: LD_INT 33
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: IN
79582: IFFALSE 79872
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
79584: LD_ADDR_EXP 67
79588: PUSH
79589: LD_EXP 67
79593: PPUSH
79594: LD_VAR 0 3
79598: PUSH
79599: LD_EXP 67
79603: PUSH
79604: LD_VAR 0 3
79608: ARRAY
79609: PUSH
79610: LD_INT 1
79612: PLUS
79613: PUSH
79614: EMPTY
79615: LIST
79616: LIST
79617: PPUSH
79618: LD_VAR 0 1
79622: PPUSH
79623: CALL 19238 0 3
79627: ST_TO_ADDR
// if btype = b_bunker then
79628: LD_VAR 0 5
79632: PUSH
79633: LD_INT 32
79635: EQUAL
79636: IFFALSE 79872
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
79638: LD_ADDR_EXP 68
79642: PUSH
79643: LD_EXP 68
79647: PPUSH
79648: LD_VAR 0 3
79652: PUSH
79653: LD_EXP 68
79657: PUSH
79658: LD_VAR 0 3
79662: ARRAY
79663: PUSH
79664: LD_INT 1
79666: PLUS
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PPUSH
79672: LD_VAR 0 1
79676: PPUSH
79677: CALL 19238 0 3
79681: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
79682: LD_ADDR_VAR 0 6
79686: PUSH
79687: LD_EXP 59
79691: PUSH
79692: LD_VAR 0 3
79696: ARRAY
79697: PPUSH
79698: LD_INT 25
79700: PUSH
79701: LD_INT 1
79703: PUSH
79704: EMPTY
79705: LIST
79706: LIST
79707: PUSH
79708: LD_INT 3
79710: PUSH
79711: LD_INT 54
79713: PUSH
79714: EMPTY
79715: LIST
79716: PUSH
79717: EMPTY
79718: LIST
79719: LIST
79720: PUSH
79721: EMPTY
79722: LIST
79723: LIST
79724: PPUSH
79725: CALL_OW 72
79729: ST_TO_ADDR
// if tmp then
79730: LD_VAR 0 6
79734: IFFALSE 79740
// exit ;
79736: POP
79737: POP
79738: GO 79880
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
79740: LD_ADDR_VAR 0 6
79744: PUSH
79745: LD_EXP 59
79749: PUSH
79750: LD_VAR 0 3
79754: ARRAY
79755: PPUSH
79756: LD_INT 2
79758: PUSH
79759: LD_INT 30
79761: PUSH
79762: LD_INT 4
79764: PUSH
79765: EMPTY
79766: LIST
79767: LIST
79768: PUSH
79769: LD_INT 30
79771: PUSH
79772: LD_INT 5
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: PUSH
79779: EMPTY
79780: LIST
79781: LIST
79782: LIST
79783: PPUSH
79784: CALL_OW 72
79788: ST_TO_ADDR
// if not tmp then
79789: LD_VAR 0 6
79793: NOT
79794: IFFALSE 79800
// exit ;
79796: POP
79797: POP
79798: GO 79880
// for j in tmp do
79800: LD_ADDR_VAR 0 4
79804: PUSH
79805: LD_VAR 0 6
79809: PUSH
79810: FOR_IN
79811: IFFALSE 79870
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
79813: LD_ADDR_VAR 0 7
79817: PUSH
79818: LD_VAR 0 4
79822: PPUSH
79823: CALL_OW 313
79827: PPUSH
79828: LD_INT 25
79830: PUSH
79831: LD_INT 1
79833: PUSH
79834: EMPTY
79835: LIST
79836: LIST
79837: PPUSH
79838: CALL_OW 72
79842: ST_TO_ADDR
// if units then
79843: LD_VAR 0 7
79847: IFFALSE 79868
// begin ComExitBuilding ( units [ 1 ] ) ;
79849: LD_VAR 0 7
79853: PUSH
79854: LD_INT 1
79856: ARRAY
79857: PPUSH
79858: CALL_OW 122
// exit ;
79862: POP
79863: POP
79864: POP
79865: POP
79866: GO 79880
// end ; end ;
79868: GO 79810
79870: POP
79871: POP
// end ; end ; exit ;
79872: POP
79873: POP
79874: GO 79880
// end ; end ;
79876: GO 79234
79878: POP
79879: POP
// end ;
79880: LD_VAR 0 2
79884: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
79885: LD_INT 0
79887: PPUSH
79888: PPUSH
79889: PPUSH
79890: PPUSH
79891: PPUSH
79892: PPUSH
79893: PPUSH
// if not mc_bases or not skirmish then
79894: LD_EXP 59
79898: NOT
79899: PUSH
79900: LD_EXP 57
79904: NOT
79905: OR
79906: IFFALSE 79910
// exit ;
79908: GO 80141
// btype := GetBType ( building ) ;
79910: LD_ADDR_VAR 0 6
79914: PUSH
79915: LD_VAR 0 1
79919: PPUSH
79920: CALL_OW 266
79924: ST_TO_ADDR
// x := GetX ( building ) ;
79925: LD_ADDR_VAR 0 7
79929: PUSH
79930: LD_VAR 0 1
79934: PPUSH
79935: CALL_OW 250
79939: ST_TO_ADDR
// y := GetY ( building ) ;
79940: LD_ADDR_VAR 0 8
79944: PUSH
79945: LD_VAR 0 1
79949: PPUSH
79950: CALL_OW 251
79954: ST_TO_ADDR
// d := GetDir ( building ) ;
79955: LD_ADDR_VAR 0 9
79959: PUSH
79960: LD_VAR 0 1
79964: PPUSH
79965: CALL_OW 254
79969: ST_TO_ADDR
// for i = 1 to mc_bases do
79970: LD_ADDR_VAR 0 4
79974: PUSH
79975: DOUBLE
79976: LD_INT 1
79978: DEC
79979: ST_TO_ADDR
79980: LD_EXP 59
79984: PUSH
79985: FOR_TO
79986: IFFALSE 80139
// begin if not mc_build_list [ i ] then
79988: LD_EXP 64
79992: PUSH
79993: LD_VAR 0 4
79997: ARRAY
79998: NOT
79999: IFFALSE 80003
// continue ;
80001: GO 79985
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
80003: LD_VAR 0 6
80007: PUSH
80008: LD_VAR 0 7
80012: PUSH
80013: LD_VAR 0 8
80017: PUSH
80018: LD_VAR 0 9
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: LIST
80027: LIST
80028: PPUSH
80029: LD_EXP 64
80033: PUSH
80034: LD_VAR 0 4
80038: ARRAY
80039: PUSH
80040: LD_INT 1
80042: ARRAY
80043: PPUSH
80044: CALL 25407 0 2
80048: IFFALSE 80137
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
80050: LD_ADDR_EXP 64
80054: PUSH
80055: LD_EXP 64
80059: PPUSH
80060: LD_VAR 0 4
80064: PPUSH
80065: LD_EXP 64
80069: PUSH
80070: LD_VAR 0 4
80074: ARRAY
80075: PPUSH
80076: LD_INT 1
80078: PPUSH
80079: CALL_OW 3
80083: PPUSH
80084: CALL_OW 1
80088: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
80089: LD_ADDR_EXP 66
80093: PUSH
80094: LD_EXP 66
80098: PPUSH
80099: LD_VAR 0 4
80103: PUSH
80104: LD_EXP 66
80108: PUSH
80109: LD_VAR 0 4
80113: ARRAY
80114: PUSH
80115: LD_INT 1
80117: PLUS
80118: PUSH
80119: EMPTY
80120: LIST
80121: LIST
80122: PPUSH
80123: LD_VAR 0 1
80127: PPUSH
80128: CALL 19238 0 3
80132: ST_TO_ADDR
// exit ;
80133: POP
80134: POP
80135: GO 80141
// end ; end ;
80137: GO 79985
80139: POP
80140: POP
// end ;
80141: LD_VAR 0 3
80145: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
80146: LD_INT 0
80148: PPUSH
80149: PPUSH
80150: PPUSH
// if not mc_bases or not skirmish then
80151: LD_EXP 59
80155: NOT
80156: PUSH
80157: LD_EXP 57
80161: NOT
80162: OR
80163: IFFALSE 80167
// exit ;
80165: GO 80357
// for i = 1 to mc_bases do
80167: LD_ADDR_VAR 0 4
80171: PUSH
80172: DOUBLE
80173: LD_INT 1
80175: DEC
80176: ST_TO_ADDR
80177: LD_EXP 59
80181: PUSH
80182: FOR_TO
80183: IFFALSE 80270
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
80185: LD_VAR 0 1
80189: PUSH
80190: LD_EXP 67
80194: PUSH
80195: LD_VAR 0 4
80199: ARRAY
80200: IN
80201: PUSH
80202: LD_VAR 0 1
80206: PUSH
80207: LD_EXP 68
80211: PUSH
80212: LD_VAR 0 4
80216: ARRAY
80217: IN
80218: NOT
80219: AND
80220: IFFALSE 80268
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80222: LD_ADDR_EXP 68
80226: PUSH
80227: LD_EXP 68
80231: PPUSH
80232: LD_VAR 0 4
80236: PUSH
80237: LD_EXP 68
80241: PUSH
80242: LD_VAR 0 4
80246: ARRAY
80247: PUSH
80248: LD_INT 1
80250: PLUS
80251: PUSH
80252: EMPTY
80253: LIST
80254: LIST
80255: PPUSH
80256: LD_VAR 0 1
80260: PPUSH
80261: CALL 19238 0 3
80265: ST_TO_ADDR
// break ;
80266: GO 80270
// end ; end ;
80268: GO 80182
80270: POP
80271: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
80272: LD_VAR 0 1
80276: PPUSH
80277: CALL_OW 257
80281: PUSH
80282: LD_EXP 85
80286: IN
80287: PUSH
80288: LD_VAR 0 1
80292: PPUSH
80293: CALL_OW 266
80297: PUSH
80298: LD_INT 5
80300: EQUAL
80301: AND
80302: PUSH
80303: LD_VAR 0 2
80307: PPUSH
80308: CALL_OW 110
80312: PUSH
80313: LD_INT 18
80315: NONEQUAL
80316: AND
80317: IFFALSE 80357
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
80319: LD_VAR 0 2
80323: PPUSH
80324: CALL_OW 257
80328: PUSH
80329: LD_INT 5
80331: PUSH
80332: LD_INT 8
80334: PUSH
80335: LD_INT 9
80337: PUSH
80338: EMPTY
80339: LIST
80340: LIST
80341: LIST
80342: IN
80343: IFFALSE 80357
// SetClass ( unit , 1 ) ;
80345: LD_VAR 0 2
80349: PPUSH
80350: LD_INT 1
80352: PPUSH
80353: CALL_OW 336
// end ;
80357: LD_VAR 0 3
80361: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
80362: LD_INT 0
80364: PPUSH
80365: PPUSH
// if not mc_bases or not skirmish then
80366: LD_EXP 59
80370: NOT
80371: PUSH
80372: LD_EXP 57
80376: NOT
80377: OR
80378: IFFALSE 80382
// exit ;
80380: GO 80498
// if GetLives ( abandoned_vehicle ) > 250 then
80382: LD_VAR 0 2
80386: PPUSH
80387: CALL_OW 256
80391: PUSH
80392: LD_INT 250
80394: GREATER
80395: IFFALSE 80399
// exit ;
80397: GO 80498
// for i = 1 to mc_bases do
80399: LD_ADDR_VAR 0 6
80403: PUSH
80404: DOUBLE
80405: LD_INT 1
80407: DEC
80408: ST_TO_ADDR
80409: LD_EXP 59
80413: PUSH
80414: FOR_TO
80415: IFFALSE 80496
// begin if driver in mc_bases [ i ] then
80417: LD_VAR 0 1
80421: PUSH
80422: LD_EXP 59
80426: PUSH
80427: LD_VAR 0 6
80431: ARRAY
80432: IN
80433: IFFALSE 80494
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
80435: LD_VAR 0 1
80439: PPUSH
80440: LD_EXP 59
80444: PUSH
80445: LD_VAR 0 6
80449: ARRAY
80450: PPUSH
80451: LD_INT 2
80453: PUSH
80454: LD_INT 30
80456: PUSH
80457: LD_INT 0
80459: PUSH
80460: EMPTY
80461: LIST
80462: LIST
80463: PUSH
80464: LD_INT 30
80466: PUSH
80467: LD_INT 1
80469: PUSH
80470: EMPTY
80471: LIST
80472: LIST
80473: PUSH
80474: EMPTY
80475: LIST
80476: LIST
80477: LIST
80478: PPUSH
80479: CALL_OW 72
80483: PUSH
80484: LD_INT 1
80486: ARRAY
80487: PPUSH
80488: CALL_OW 112
// break ;
80492: GO 80496
// end ; end ;
80494: GO 80414
80496: POP
80497: POP
// end ; end_of_file
80498: LD_VAR 0 5
80502: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
80503: GO 80505
80505: DISABLE
// begin ru_radar := 98 ;
80506: LD_ADDR_EXP 102
80510: PUSH
80511: LD_INT 98
80513: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
80514: LD_ADDR_EXP 103
80518: PUSH
80519: LD_INT 89
80521: ST_TO_ADDR
// us_hack := 99 ;
80522: LD_ADDR_EXP 104
80526: PUSH
80527: LD_INT 99
80529: ST_TO_ADDR
// us_artillery := 97 ;
80530: LD_ADDR_EXP 105
80534: PUSH
80535: LD_INT 97
80537: ST_TO_ADDR
// ar_bio_bomb := 91 ;
80538: LD_ADDR_EXP 106
80542: PUSH
80543: LD_INT 91
80545: ST_TO_ADDR
// tech_Artillery := 80 ;
80546: LD_ADDR_EXP 107
80550: PUSH
80551: LD_INT 80
80553: ST_TO_ADDR
// tech_RadMat := 81 ;
80554: LD_ADDR_EXP 108
80558: PUSH
80559: LD_INT 81
80561: ST_TO_ADDR
// tech_BasicTools := 82 ;
80562: LD_ADDR_EXP 109
80566: PUSH
80567: LD_INT 82
80569: ST_TO_ADDR
// tech_Cargo := 83 ;
80570: LD_ADDR_EXP 110
80574: PUSH
80575: LD_INT 83
80577: ST_TO_ADDR
// tech_Track := 84 ;
80578: LD_ADDR_EXP 111
80582: PUSH
80583: LD_INT 84
80585: ST_TO_ADDR
// tech_Crane := 85 ;
80586: LD_ADDR_EXP 112
80590: PUSH
80591: LD_INT 85
80593: ST_TO_ADDR
// tech_Bulldozer := 86 ;
80594: LD_ADDR_EXP 113
80598: PUSH
80599: LD_INT 86
80601: ST_TO_ADDR
// tech_Hovercraft := 87 ;
80602: LD_ADDR_EXP 114
80606: PUSH
80607: LD_INT 87
80609: ST_TO_ADDR
// end ; end_of_file end_of_file
80610: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
80611: GO 80613
80613: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
80614: LD_STRING initStreamRollete();
80616: PPUSH
80617: CALL_OW 559
// InitStreamMode ;
80621: CALL 80630 0 0
// DefineStreamItems ( ) ;
80625: CALL 81070 0 0
// end ;
80629: END
// function InitStreamMode ; begin
80630: LD_INT 0
80632: PPUSH
// streamModeActive := false ;
80633: LD_ADDR_EXP 115
80637: PUSH
80638: LD_INT 0
80640: ST_TO_ADDR
// normalCounter := 36 ;
80641: LD_ADDR_EXP 116
80645: PUSH
80646: LD_INT 36
80648: ST_TO_ADDR
// hardcoreCounter := 16 ;
80649: LD_ADDR_EXP 117
80653: PUSH
80654: LD_INT 16
80656: ST_TO_ADDR
// sRocket := false ;
80657: LD_ADDR_EXP 120
80661: PUSH
80662: LD_INT 0
80664: ST_TO_ADDR
// sSpeed := false ;
80665: LD_ADDR_EXP 119
80669: PUSH
80670: LD_INT 0
80672: ST_TO_ADDR
// sEngine := false ;
80673: LD_ADDR_EXP 121
80677: PUSH
80678: LD_INT 0
80680: ST_TO_ADDR
// sSpec := false ;
80681: LD_ADDR_EXP 118
80685: PUSH
80686: LD_INT 0
80688: ST_TO_ADDR
// sLevel := false ;
80689: LD_ADDR_EXP 122
80693: PUSH
80694: LD_INT 0
80696: ST_TO_ADDR
// sArmoury := false ;
80697: LD_ADDR_EXP 123
80701: PUSH
80702: LD_INT 0
80704: ST_TO_ADDR
// sRadar := false ;
80705: LD_ADDR_EXP 124
80709: PUSH
80710: LD_INT 0
80712: ST_TO_ADDR
// sBunker := false ;
80713: LD_ADDR_EXP 125
80717: PUSH
80718: LD_INT 0
80720: ST_TO_ADDR
// sHack := false ;
80721: LD_ADDR_EXP 126
80725: PUSH
80726: LD_INT 0
80728: ST_TO_ADDR
// sFire := false ;
80729: LD_ADDR_EXP 127
80733: PUSH
80734: LD_INT 0
80736: ST_TO_ADDR
// sRefresh := false ;
80737: LD_ADDR_EXP 128
80741: PUSH
80742: LD_INT 0
80744: ST_TO_ADDR
// sExp := false ;
80745: LD_ADDR_EXP 129
80749: PUSH
80750: LD_INT 0
80752: ST_TO_ADDR
// sDepot := false ;
80753: LD_ADDR_EXP 130
80757: PUSH
80758: LD_INT 0
80760: ST_TO_ADDR
// sFlag := false ;
80761: LD_ADDR_EXP 131
80765: PUSH
80766: LD_INT 0
80768: ST_TO_ADDR
// sKamikadze := false ;
80769: LD_ADDR_EXP 139
80773: PUSH
80774: LD_INT 0
80776: ST_TO_ADDR
// sTroll := false ;
80777: LD_ADDR_EXP 140
80781: PUSH
80782: LD_INT 0
80784: ST_TO_ADDR
// sSlow := false ;
80785: LD_ADDR_EXP 141
80789: PUSH
80790: LD_INT 0
80792: ST_TO_ADDR
// sLack := false ;
80793: LD_ADDR_EXP 142
80797: PUSH
80798: LD_INT 0
80800: ST_TO_ADDR
// sTank := false ;
80801: LD_ADDR_EXP 144
80805: PUSH
80806: LD_INT 0
80808: ST_TO_ADDR
// sRemote := false ;
80809: LD_ADDR_EXP 145
80813: PUSH
80814: LD_INT 0
80816: ST_TO_ADDR
// sPowell := false ;
80817: LD_ADDR_EXP 146
80821: PUSH
80822: LD_INT 0
80824: ST_TO_ADDR
// sTeleport := false ;
80825: LD_ADDR_EXP 149
80829: PUSH
80830: LD_INT 0
80832: ST_TO_ADDR
// sOilTower := false ;
80833: LD_ADDR_EXP 151
80837: PUSH
80838: LD_INT 0
80840: ST_TO_ADDR
// sShovel := false ;
80841: LD_ADDR_EXP 152
80845: PUSH
80846: LD_INT 0
80848: ST_TO_ADDR
// sSheik := false ;
80849: LD_ADDR_EXP 153
80853: PUSH
80854: LD_INT 0
80856: ST_TO_ADDR
// sEarthquake := false ;
80857: LD_ADDR_EXP 155
80861: PUSH
80862: LD_INT 0
80864: ST_TO_ADDR
// sAI := false ;
80865: LD_ADDR_EXP 156
80869: PUSH
80870: LD_INT 0
80872: ST_TO_ADDR
// sCargo := false ;
80873: LD_ADDR_EXP 159
80877: PUSH
80878: LD_INT 0
80880: ST_TO_ADDR
// sDLaser := false ;
80881: LD_ADDR_EXP 160
80885: PUSH
80886: LD_INT 0
80888: ST_TO_ADDR
// sExchange := false ;
80889: LD_ADDR_EXP 161
80893: PUSH
80894: LD_INT 0
80896: ST_TO_ADDR
// sFac := false ;
80897: LD_ADDR_EXP 162
80901: PUSH
80902: LD_INT 0
80904: ST_TO_ADDR
// sPower := false ;
80905: LD_ADDR_EXP 163
80909: PUSH
80910: LD_INT 0
80912: ST_TO_ADDR
// sRandom := false ;
80913: LD_ADDR_EXP 164
80917: PUSH
80918: LD_INT 0
80920: ST_TO_ADDR
// sShield := false ;
80921: LD_ADDR_EXP 165
80925: PUSH
80926: LD_INT 0
80928: ST_TO_ADDR
// sTime := false ;
80929: LD_ADDR_EXP 166
80933: PUSH
80934: LD_INT 0
80936: ST_TO_ADDR
// sTools := false ;
80937: LD_ADDR_EXP 167
80941: PUSH
80942: LD_INT 0
80944: ST_TO_ADDR
// sSold := false ;
80945: LD_ADDR_EXP 132
80949: PUSH
80950: LD_INT 0
80952: ST_TO_ADDR
// sDiff := false ;
80953: LD_ADDR_EXP 133
80957: PUSH
80958: LD_INT 0
80960: ST_TO_ADDR
// sFog := false ;
80961: LD_ADDR_EXP 136
80965: PUSH
80966: LD_INT 0
80968: ST_TO_ADDR
// sReset := false ;
80969: LD_ADDR_EXP 137
80973: PUSH
80974: LD_INT 0
80976: ST_TO_ADDR
// sSun := false ;
80977: LD_ADDR_EXP 138
80981: PUSH
80982: LD_INT 0
80984: ST_TO_ADDR
// sTiger := false ;
80985: LD_ADDR_EXP 134
80989: PUSH
80990: LD_INT 0
80992: ST_TO_ADDR
// sBomb := false ;
80993: LD_ADDR_EXP 135
80997: PUSH
80998: LD_INT 0
81000: ST_TO_ADDR
// sWound := false ;
81001: LD_ADDR_EXP 143
81005: PUSH
81006: LD_INT 0
81008: ST_TO_ADDR
// sBetray := false ;
81009: LD_ADDR_EXP 147
81013: PUSH
81014: LD_INT 0
81016: ST_TO_ADDR
// sContamin := false ;
81017: LD_ADDR_EXP 148
81021: PUSH
81022: LD_INT 0
81024: ST_TO_ADDR
// sOil := false ;
81025: LD_ADDR_EXP 150
81029: PUSH
81030: LD_INT 0
81032: ST_TO_ADDR
// sStu := false ;
81033: LD_ADDR_EXP 154
81037: PUSH
81038: LD_INT 0
81040: ST_TO_ADDR
// sBazooka := false ;
81041: LD_ADDR_EXP 157
81045: PUSH
81046: LD_INT 0
81048: ST_TO_ADDR
// sMortar := false ;
81049: LD_ADDR_EXP 158
81053: PUSH
81054: LD_INT 0
81056: ST_TO_ADDR
// sRanger := false ;
81057: LD_ADDR_EXP 168
81061: PUSH
81062: LD_INT 0
81064: ST_TO_ADDR
// end ;
81065: LD_VAR 0 1
81069: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
81070: LD_INT 0
81072: PPUSH
81073: PPUSH
81074: PPUSH
81075: PPUSH
81076: PPUSH
// result := [ ] ;
81077: LD_ADDR_VAR 0 1
81081: PUSH
81082: EMPTY
81083: ST_TO_ADDR
// if campaign_id = 1 then
81084: LD_OWVAR 69
81088: PUSH
81089: LD_INT 1
81091: EQUAL
81092: IFFALSE 84030
// begin case mission_number of 1 :
81094: LD_OWVAR 70
81098: PUSH
81099: LD_INT 1
81101: DOUBLE
81102: EQUAL
81103: IFTRUE 81107
81105: GO 81171
81107: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
81108: LD_ADDR_VAR 0 1
81112: PUSH
81113: LD_INT 2
81115: PUSH
81116: LD_INT 4
81118: PUSH
81119: LD_INT 11
81121: PUSH
81122: LD_INT 12
81124: PUSH
81125: LD_INT 15
81127: PUSH
81128: LD_INT 16
81130: PUSH
81131: LD_INT 22
81133: PUSH
81134: LD_INT 23
81136: PUSH
81137: LD_INT 26
81139: PUSH
81140: EMPTY
81141: LIST
81142: LIST
81143: LIST
81144: LIST
81145: LIST
81146: LIST
81147: LIST
81148: LIST
81149: LIST
81150: PUSH
81151: LD_INT 101
81153: PUSH
81154: LD_INT 102
81156: PUSH
81157: LD_INT 106
81159: PUSH
81160: EMPTY
81161: LIST
81162: LIST
81163: LIST
81164: PUSH
81165: EMPTY
81166: LIST
81167: LIST
81168: ST_TO_ADDR
81169: GO 84028
81171: LD_INT 2
81173: DOUBLE
81174: EQUAL
81175: IFTRUE 81179
81177: GO 81251
81179: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
81180: LD_ADDR_VAR 0 1
81184: PUSH
81185: LD_INT 2
81187: PUSH
81188: LD_INT 4
81190: PUSH
81191: LD_INT 11
81193: PUSH
81194: LD_INT 12
81196: PUSH
81197: LD_INT 15
81199: PUSH
81200: LD_INT 16
81202: PUSH
81203: LD_INT 22
81205: PUSH
81206: LD_INT 23
81208: PUSH
81209: LD_INT 26
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: LIST
81216: LIST
81217: LIST
81218: LIST
81219: LIST
81220: LIST
81221: LIST
81222: PUSH
81223: LD_INT 101
81225: PUSH
81226: LD_INT 102
81228: PUSH
81229: LD_INT 105
81231: PUSH
81232: LD_INT 106
81234: PUSH
81235: LD_INT 108
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: LIST
81242: LIST
81243: LIST
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: ST_TO_ADDR
81249: GO 84028
81251: LD_INT 3
81253: DOUBLE
81254: EQUAL
81255: IFTRUE 81259
81257: GO 81335
81259: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
81260: LD_ADDR_VAR 0 1
81264: PUSH
81265: LD_INT 2
81267: PUSH
81268: LD_INT 4
81270: PUSH
81271: LD_INT 5
81273: PUSH
81274: LD_INT 11
81276: PUSH
81277: LD_INT 12
81279: PUSH
81280: LD_INT 15
81282: PUSH
81283: LD_INT 16
81285: PUSH
81286: LD_INT 22
81288: PUSH
81289: LD_INT 26
81291: PUSH
81292: LD_INT 36
81294: PUSH
81295: EMPTY
81296: LIST
81297: LIST
81298: LIST
81299: LIST
81300: LIST
81301: LIST
81302: LIST
81303: LIST
81304: LIST
81305: LIST
81306: PUSH
81307: LD_INT 101
81309: PUSH
81310: LD_INT 102
81312: PUSH
81313: LD_INT 105
81315: PUSH
81316: LD_INT 106
81318: PUSH
81319: LD_INT 108
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: LIST
81326: LIST
81327: LIST
81328: PUSH
81329: EMPTY
81330: LIST
81331: LIST
81332: ST_TO_ADDR
81333: GO 84028
81335: LD_INT 4
81337: DOUBLE
81338: EQUAL
81339: IFTRUE 81343
81341: GO 81427
81343: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
81344: LD_ADDR_VAR 0 1
81348: PUSH
81349: LD_INT 2
81351: PUSH
81352: LD_INT 4
81354: PUSH
81355: LD_INT 5
81357: PUSH
81358: LD_INT 8
81360: PUSH
81361: LD_INT 11
81363: PUSH
81364: LD_INT 12
81366: PUSH
81367: LD_INT 15
81369: PUSH
81370: LD_INT 16
81372: PUSH
81373: LD_INT 22
81375: PUSH
81376: LD_INT 23
81378: PUSH
81379: LD_INT 26
81381: PUSH
81382: LD_INT 36
81384: PUSH
81385: EMPTY
81386: LIST
81387: LIST
81388: LIST
81389: LIST
81390: LIST
81391: LIST
81392: LIST
81393: LIST
81394: LIST
81395: LIST
81396: LIST
81397: LIST
81398: PUSH
81399: LD_INT 101
81401: PUSH
81402: LD_INT 102
81404: PUSH
81405: LD_INT 105
81407: PUSH
81408: LD_INT 106
81410: PUSH
81411: LD_INT 108
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: LIST
81418: LIST
81419: LIST
81420: PUSH
81421: EMPTY
81422: LIST
81423: LIST
81424: ST_TO_ADDR
81425: GO 84028
81427: LD_INT 5
81429: DOUBLE
81430: EQUAL
81431: IFTRUE 81435
81433: GO 81535
81435: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
81436: LD_ADDR_VAR 0 1
81440: PUSH
81441: LD_INT 2
81443: PUSH
81444: LD_INT 4
81446: PUSH
81447: LD_INT 5
81449: PUSH
81450: LD_INT 6
81452: PUSH
81453: LD_INT 8
81455: PUSH
81456: LD_INT 11
81458: PUSH
81459: LD_INT 12
81461: PUSH
81462: LD_INT 15
81464: PUSH
81465: LD_INT 16
81467: PUSH
81468: LD_INT 22
81470: PUSH
81471: LD_INT 23
81473: PUSH
81474: LD_INT 25
81476: PUSH
81477: LD_INT 26
81479: PUSH
81480: LD_INT 36
81482: PUSH
81483: EMPTY
81484: LIST
81485: LIST
81486: LIST
81487: LIST
81488: LIST
81489: LIST
81490: LIST
81491: LIST
81492: LIST
81493: LIST
81494: LIST
81495: LIST
81496: LIST
81497: LIST
81498: PUSH
81499: LD_INT 101
81501: PUSH
81502: LD_INT 102
81504: PUSH
81505: LD_INT 105
81507: PUSH
81508: LD_INT 106
81510: PUSH
81511: LD_INT 108
81513: PUSH
81514: LD_INT 109
81516: PUSH
81517: LD_INT 112
81519: PUSH
81520: EMPTY
81521: LIST
81522: LIST
81523: LIST
81524: LIST
81525: LIST
81526: LIST
81527: LIST
81528: PUSH
81529: EMPTY
81530: LIST
81531: LIST
81532: ST_TO_ADDR
81533: GO 84028
81535: LD_INT 6
81537: DOUBLE
81538: EQUAL
81539: IFTRUE 81543
81541: GO 81663
81543: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
81544: LD_ADDR_VAR 0 1
81548: PUSH
81549: LD_INT 2
81551: PUSH
81552: LD_INT 4
81554: PUSH
81555: LD_INT 5
81557: PUSH
81558: LD_INT 6
81560: PUSH
81561: LD_INT 8
81563: PUSH
81564: LD_INT 11
81566: PUSH
81567: LD_INT 12
81569: PUSH
81570: LD_INT 15
81572: PUSH
81573: LD_INT 16
81575: PUSH
81576: LD_INT 20
81578: PUSH
81579: LD_INT 21
81581: PUSH
81582: LD_INT 22
81584: PUSH
81585: LD_INT 23
81587: PUSH
81588: LD_INT 25
81590: PUSH
81591: LD_INT 26
81593: PUSH
81594: LD_INT 30
81596: PUSH
81597: LD_INT 31
81599: PUSH
81600: LD_INT 32
81602: PUSH
81603: LD_INT 36
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: LIST
81613: LIST
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: LIST
81619: LIST
81620: LIST
81621: LIST
81622: LIST
81623: LIST
81624: LIST
81625: LIST
81626: PUSH
81627: LD_INT 101
81629: PUSH
81630: LD_INT 102
81632: PUSH
81633: LD_INT 105
81635: PUSH
81636: LD_INT 106
81638: PUSH
81639: LD_INT 108
81641: PUSH
81642: LD_INT 109
81644: PUSH
81645: LD_INT 112
81647: PUSH
81648: EMPTY
81649: LIST
81650: LIST
81651: LIST
81652: LIST
81653: LIST
81654: LIST
81655: LIST
81656: PUSH
81657: EMPTY
81658: LIST
81659: LIST
81660: ST_TO_ADDR
81661: GO 84028
81663: LD_INT 7
81665: DOUBLE
81666: EQUAL
81667: IFTRUE 81671
81669: GO 81771
81671: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
81672: LD_ADDR_VAR 0 1
81676: PUSH
81677: LD_INT 2
81679: PUSH
81680: LD_INT 4
81682: PUSH
81683: LD_INT 5
81685: PUSH
81686: LD_INT 7
81688: PUSH
81689: LD_INT 11
81691: PUSH
81692: LD_INT 12
81694: PUSH
81695: LD_INT 15
81697: PUSH
81698: LD_INT 16
81700: PUSH
81701: LD_INT 20
81703: PUSH
81704: LD_INT 21
81706: PUSH
81707: LD_INT 22
81709: PUSH
81710: LD_INT 23
81712: PUSH
81713: LD_INT 25
81715: PUSH
81716: LD_INT 26
81718: PUSH
81719: EMPTY
81720: LIST
81721: LIST
81722: LIST
81723: LIST
81724: LIST
81725: LIST
81726: LIST
81727: LIST
81728: LIST
81729: LIST
81730: LIST
81731: LIST
81732: LIST
81733: LIST
81734: PUSH
81735: LD_INT 101
81737: PUSH
81738: LD_INT 102
81740: PUSH
81741: LD_INT 103
81743: PUSH
81744: LD_INT 105
81746: PUSH
81747: LD_INT 106
81749: PUSH
81750: LD_INT 108
81752: PUSH
81753: LD_INT 112
81755: PUSH
81756: EMPTY
81757: LIST
81758: LIST
81759: LIST
81760: LIST
81761: LIST
81762: LIST
81763: LIST
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: ST_TO_ADDR
81769: GO 84028
81771: LD_INT 8
81773: DOUBLE
81774: EQUAL
81775: IFTRUE 81779
81777: GO 81907
81779: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
81780: LD_ADDR_VAR 0 1
81784: PUSH
81785: LD_INT 2
81787: PUSH
81788: LD_INT 4
81790: PUSH
81791: LD_INT 5
81793: PUSH
81794: LD_INT 6
81796: PUSH
81797: LD_INT 7
81799: PUSH
81800: LD_INT 8
81802: PUSH
81803: LD_INT 11
81805: PUSH
81806: LD_INT 12
81808: PUSH
81809: LD_INT 15
81811: PUSH
81812: LD_INT 16
81814: PUSH
81815: LD_INT 20
81817: PUSH
81818: LD_INT 21
81820: PUSH
81821: LD_INT 22
81823: PUSH
81824: LD_INT 23
81826: PUSH
81827: LD_INT 25
81829: PUSH
81830: LD_INT 26
81832: PUSH
81833: LD_INT 30
81835: PUSH
81836: LD_INT 31
81838: PUSH
81839: LD_INT 32
81841: PUSH
81842: LD_INT 36
81844: PUSH
81845: EMPTY
81846: LIST
81847: LIST
81848: LIST
81849: LIST
81850: LIST
81851: LIST
81852: LIST
81853: LIST
81854: LIST
81855: LIST
81856: LIST
81857: LIST
81858: LIST
81859: LIST
81860: LIST
81861: LIST
81862: LIST
81863: LIST
81864: LIST
81865: LIST
81866: PUSH
81867: LD_INT 101
81869: PUSH
81870: LD_INT 102
81872: PUSH
81873: LD_INT 103
81875: PUSH
81876: LD_INT 105
81878: PUSH
81879: LD_INT 106
81881: PUSH
81882: LD_INT 108
81884: PUSH
81885: LD_INT 109
81887: PUSH
81888: LD_INT 112
81890: PUSH
81891: EMPTY
81892: LIST
81893: LIST
81894: LIST
81895: LIST
81896: LIST
81897: LIST
81898: LIST
81899: LIST
81900: PUSH
81901: EMPTY
81902: LIST
81903: LIST
81904: ST_TO_ADDR
81905: GO 84028
81907: LD_INT 9
81909: DOUBLE
81910: EQUAL
81911: IFTRUE 81915
81913: GO 82051
81915: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
81916: LD_ADDR_VAR 0 1
81920: PUSH
81921: LD_INT 2
81923: PUSH
81924: LD_INT 4
81926: PUSH
81927: LD_INT 5
81929: PUSH
81930: LD_INT 6
81932: PUSH
81933: LD_INT 7
81935: PUSH
81936: LD_INT 8
81938: PUSH
81939: LD_INT 11
81941: PUSH
81942: LD_INT 12
81944: PUSH
81945: LD_INT 15
81947: PUSH
81948: LD_INT 16
81950: PUSH
81951: LD_INT 20
81953: PUSH
81954: LD_INT 21
81956: PUSH
81957: LD_INT 22
81959: PUSH
81960: LD_INT 23
81962: PUSH
81963: LD_INT 25
81965: PUSH
81966: LD_INT 26
81968: PUSH
81969: LD_INT 28
81971: PUSH
81972: LD_INT 30
81974: PUSH
81975: LD_INT 31
81977: PUSH
81978: LD_INT 32
81980: PUSH
81981: LD_INT 36
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: LIST
81988: LIST
81989: LIST
81990: LIST
81991: LIST
81992: LIST
81993: LIST
81994: LIST
81995: LIST
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: PUSH
82007: LD_INT 101
82009: PUSH
82010: LD_INT 102
82012: PUSH
82013: LD_INT 103
82015: PUSH
82016: LD_INT 105
82018: PUSH
82019: LD_INT 106
82021: PUSH
82022: LD_INT 108
82024: PUSH
82025: LD_INT 109
82027: PUSH
82028: LD_INT 112
82030: PUSH
82031: LD_INT 114
82033: PUSH
82034: EMPTY
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: LIST
82040: LIST
82041: LIST
82042: LIST
82043: LIST
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: ST_TO_ADDR
82049: GO 84028
82051: LD_INT 10
82053: DOUBLE
82054: EQUAL
82055: IFTRUE 82059
82057: GO 82243
82059: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
82060: LD_ADDR_VAR 0 1
82064: PUSH
82065: LD_INT 2
82067: PUSH
82068: LD_INT 4
82070: PUSH
82071: LD_INT 5
82073: PUSH
82074: LD_INT 6
82076: PUSH
82077: LD_INT 7
82079: PUSH
82080: LD_INT 8
82082: PUSH
82083: LD_INT 9
82085: PUSH
82086: LD_INT 10
82088: PUSH
82089: LD_INT 11
82091: PUSH
82092: LD_INT 12
82094: PUSH
82095: LD_INT 13
82097: PUSH
82098: LD_INT 14
82100: PUSH
82101: LD_INT 15
82103: PUSH
82104: LD_INT 16
82106: PUSH
82107: LD_INT 17
82109: PUSH
82110: LD_INT 18
82112: PUSH
82113: LD_INT 19
82115: PUSH
82116: LD_INT 20
82118: PUSH
82119: LD_INT 21
82121: PUSH
82122: LD_INT 22
82124: PUSH
82125: LD_INT 23
82127: PUSH
82128: LD_INT 24
82130: PUSH
82131: LD_INT 25
82133: PUSH
82134: LD_INT 26
82136: PUSH
82137: LD_INT 28
82139: PUSH
82140: LD_INT 30
82142: PUSH
82143: LD_INT 31
82145: PUSH
82146: LD_INT 32
82148: PUSH
82149: LD_INT 36
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: LIST
82156: LIST
82157: LIST
82158: LIST
82159: LIST
82160: LIST
82161: LIST
82162: LIST
82163: LIST
82164: LIST
82165: LIST
82166: LIST
82167: LIST
82168: LIST
82169: LIST
82170: LIST
82171: LIST
82172: LIST
82173: LIST
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: PUSH
82183: LD_INT 101
82185: PUSH
82186: LD_INT 102
82188: PUSH
82189: LD_INT 103
82191: PUSH
82192: LD_INT 104
82194: PUSH
82195: LD_INT 105
82197: PUSH
82198: LD_INT 106
82200: PUSH
82201: LD_INT 107
82203: PUSH
82204: LD_INT 108
82206: PUSH
82207: LD_INT 109
82209: PUSH
82210: LD_INT 110
82212: PUSH
82213: LD_INT 111
82215: PUSH
82216: LD_INT 112
82218: PUSH
82219: LD_INT 114
82221: PUSH
82222: EMPTY
82223: LIST
82224: LIST
82225: LIST
82226: LIST
82227: LIST
82228: LIST
82229: LIST
82230: LIST
82231: LIST
82232: LIST
82233: LIST
82234: LIST
82235: LIST
82236: PUSH
82237: EMPTY
82238: LIST
82239: LIST
82240: ST_TO_ADDR
82241: GO 84028
82243: LD_INT 11
82245: DOUBLE
82246: EQUAL
82247: IFTRUE 82251
82249: GO 82443
82251: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
82252: LD_ADDR_VAR 0 1
82256: PUSH
82257: LD_INT 2
82259: PUSH
82260: LD_INT 3
82262: PUSH
82263: LD_INT 4
82265: PUSH
82266: LD_INT 5
82268: PUSH
82269: LD_INT 6
82271: PUSH
82272: LD_INT 7
82274: PUSH
82275: LD_INT 8
82277: PUSH
82278: LD_INT 9
82280: PUSH
82281: LD_INT 10
82283: PUSH
82284: LD_INT 11
82286: PUSH
82287: LD_INT 12
82289: PUSH
82290: LD_INT 13
82292: PUSH
82293: LD_INT 14
82295: PUSH
82296: LD_INT 15
82298: PUSH
82299: LD_INT 16
82301: PUSH
82302: LD_INT 17
82304: PUSH
82305: LD_INT 18
82307: PUSH
82308: LD_INT 19
82310: PUSH
82311: LD_INT 20
82313: PUSH
82314: LD_INT 21
82316: PUSH
82317: LD_INT 22
82319: PUSH
82320: LD_INT 23
82322: PUSH
82323: LD_INT 24
82325: PUSH
82326: LD_INT 25
82328: PUSH
82329: LD_INT 26
82331: PUSH
82332: LD_INT 28
82334: PUSH
82335: LD_INT 30
82337: PUSH
82338: LD_INT 31
82340: PUSH
82341: LD_INT 32
82343: PUSH
82344: LD_INT 34
82346: PUSH
82347: LD_INT 36
82349: PUSH
82350: EMPTY
82351: LIST
82352: LIST
82353: LIST
82354: LIST
82355: LIST
82356: LIST
82357: LIST
82358: LIST
82359: LIST
82360: LIST
82361: LIST
82362: LIST
82363: LIST
82364: LIST
82365: LIST
82366: LIST
82367: LIST
82368: LIST
82369: LIST
82370: LIST
82371: LIST
82372: LIST
82373: LIST
82374: LIST
82375: LIST
82376: LIST
82377: LIST
82378: LIST
82379: LIST
82380: LIST
82381: LIST
82382: PUSH
82383: LD_INT 101
82385: PUSH
82386: LD_INT 102
82388: PUSH
82389: LD_INT 103
82391: PUSH
82392: LD_INT 104
82394: PUSH
82395: LD_INT 105
82397: PUSH
82398: LD_INT 106
82400: PUSH
82401: LD_INT 107
82403: PUSH
82404: LD_INT 108
82406: PUSH
82407: LD_INT 109
82409: PUSH
82410: LD_INT 110
82412: PUSH
82413: LD_INT 111
82415: PUSH
82416: LD_INT 112
82418: PUSH
82419: LD_INT 114
82421: PUSH
82422: EMPTY
82423: LIST
82424: LIST
82425: LIST
82426: LIST
82427: LIST
82428: LIST
82429: LIST
82430: LIST
82431: LIST
82432: LIST
82433: LIST
82434: LIST
82435: LIST
82436: PUSH
82437: EMPTY
82438: LIST
82439: LIST
82440: ST_TO_ADDR
82441: GO 84028
82443: LD_INT 12
82445: DOUBLE
82446: EQUAL
82447: IFTRUE 82451
82449: GO 82659
82451: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
82452: LD_ADDR_VAR 0 1
82456: PUSH
82457: LD_INT 1
82459: PUSH
82460: LD_INT 2
82462: PUSH
82463: LD_INT 3
82465: PUSH
82466: LD_INT 4
82468: PUSH
82469: LD_INT 5
82471: PUSH
82472: LD_INT 6
82474: PUSH
82475: LD_INT 7
82477: PUSH
82478: LD_INT 8
82480: PUSH
82481: LD_INT 9
82483: PUSH
82484: LD_INT 10
82486: PUSH
82487: LD_INT 11
82489: PUSH
82490: LD_INT 12
82492: PUSH
82493: LD_INT 13
82495: PUSH
82496: LD_INT 14
82498: PUSH
82499: LD_INT 15
82501: PUSH
82502: LD_INT 16
82504: PUSH
82505: LD_INT 17
82507: PUSH
82508: LD_INT 18
82510: PUSH
82511: LD_INT 19
82513: PUSH
82514: LD_INT 20
82516: PUSH
82517: LD_INT 21
82519: PUSH
82520: LD_INT 22
82522: PUSH
82523: LD_INT 23
82525: PUSH
82526: LD_INT 24
82528: PUSH
82529: LD_INT 25
82531: PUSH
82532: LD_INT 26
82534: PUSH
82535: LD_INT 27
82537: PUSH
82538: LD_INT 28
82540: PUSH
82541: LD_INT 30
82543: PUSH
82544: LD_INT 31
82546: PUSH
82547: LD_INT 32
82549: PUSH
82550: LD_INT 33
82552: PUSH
82553: LD_INT 34
82555: PUSH
82556: LD_INT 36
82558: PUSH
82559: EMPTY
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: LIST
82572: LIST
82573: LIST
82574: LIST
82575: LIST
82576: LIST
82577: LIST
82578: LIST
82579: LIST
82580: LIST
82581: LIST
82582: LIST
82583: LIST
82584: LIST
82585: LIST
82586: LIST
82587: LIST
82588: LIST
82589: LIST
82590: LIST
82591: LIST
82592: LIST
82593: LIST
82594: PUSH
82595: LD_INT 101
82597: PUSH
82598: LD_INT 102
82600: PUSH
82601: LD_INT 103
82603: PUSH
82604: LD_INT 104
82606: PUSH
82607: LD_INT 105
82609: PUSH
82610: LD_INT 106
82612: PUSH
82613: LD_INT 107
82615: PUSH
82616: LD_INT 108
82618: PUSH
82619: LD_INT 109
82621: PUSH
82622: LD_INT 110
82624: PUSH
82625: LD_INT 111
82627: PUSH
82628: LD_INT 112
82630: PUSH
82631: LD_INT 113
82633: PUSH
82634: LD_INT 114
82636: PUSH
82637: EMPTY
82638: LIST
82639: LIST
82640: LIST
82641: LIST
82642: LIST
82643: LIST
82644: LIST
82645: LIST
82646: LIST
82647: LIST
82648: LIST
82649: LIST
82650: LIST
82651: LIST
82652: PUSH
82653: EMPTY
82654: LIST
82655: LIST
82656: ST_TO_ADDR
82657: GO 84028
82659: LD_INT 13
82661: DOUBLE
82662: EQUAL
82663: IFTRUE 82667
82665: GO 82863
82667: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
82668: LD_ADDR_VAR 0 1
82672: PUSH
82673: LD_INT 1
82675: PUSH
82676: LD_INT 2
82678: PUSH
82679: LD_INT 3
82681: PUSH
82682: LD_INT 4
82684: PUSH
82685: LD_INT 5
82687: PUSH
82688: LD_INT 8
82690: PUSH
82691: LD_INT 9
82693: PUSH
82694: LD_INT 10
82696: PUSH
82697: LD_INT 11
82699: PUSH
82700: LD_INT 12
82702: PUSH
82703: LD_INT 14
82705: PUSH
82706: LD_INT 15
82708: PUSH
82709: LD_INT 16
82711: PUSH
82712: LD_INT 17
82714: PUSH
82715: LD_INT 18
82717: PUSH
82718: LD_INT 19
82720: PUSH
82721: LD_INT 20
82723: PUSH
82724: LD_INT 21
82726: PUSH
82727: LD_INT 22
82729: PUSH
82730: LD_INT 23
82732: PUSH
82733: LD_INT 24
82735: PUSH
82736: LD_INT 25
82738: PUSH
82739: LD_INT 26
82741: PUSH
82742: LD_INT 27
82744: PUSH
82745: LD_INT 28
82747: PUSH
82748: LD_INT 30
82750: PUSH
82751: LD_INT 31
82753: PUSH
82754: LD_INT 32
82756: PUSH
82757: LD_INT 33
82759: PUSH
82760: LD_INT 34
82762: PUSH
82763: LD_INT 36
82765: PUSH
82766: EMPTY
82767: LIST
82768: LIST
82769: LIST
82770: LIST
82771: LIST
82772: LIST
82773: LIST
82774: LIST
82775: LIST
82776: LIST
82777: LIST
82778: LIST
82779: LIST
82780: LIST
82781: LIST
82782: LIST
82783: LIST
82784: LIST
82785: LIST
82786: LIST
82787: LIST
82788: LIST
82789: LIST
82790: LIST
82791: LIST
82792: LIST
82793: LIST
82794: LIST
82795: LIST
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 101
82801: PUSH
82802: LD_INT 102
82804: PUSH
82805: LD_INT 103
82807: PUSH
82808: LD_INT 104
82810: PUSH
82811: LD_INT 105
82813: PUSH
82814: LD_INT 106
82816: PUSH
82817: LD_INT 107
82819: PUSH
82820: LD_INT 108
82822: PUSH
82823: LD_INT 109
82825: PUSH
82826: LD_INT 110
82828: PUSH
82829: LD_INT 111
82831: PUSH
82832: LD_INT 112
82834: PUSH
82835: LD_INT 113
82837: PUSH
82838: LD_INT 114
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: LIST
82845: LIST
82846: LIST
82847: LIST
82848: LIST
82849: LIST
82850: LIST
82851: LIST
82852: LIST
82853: LIST
82854: LIST
82855: LIST
82856: PUSH
82857: EMPTY
82858: LIST
82859: LIST
82860: ST_TO_ADDR
82861: GO 84028
82863: LD_INT 14
82865: DOUBLE
82866: EQUAL
82867: IFTRUE 82871
82869: GO 83083
82871: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
82872: LD_ADDR_VAR 0 1
82876: PUSH
82877: LD_INT 1
82879: PUSH
82880: LD_INT 2
82882: PUSH
82883: LD_INT 3
82885: PUSH
82886: LD_INT 4
82888: PUSH
82889: LD_INT 5
82891: PUSH
82892: LD_INT 6
82894: PUSH
82895: LD_INT 7
82897: PUSH
82898: LD_INT 8
82900: PUSH
82901: LD_INT 9
82903: PUSH
82904: LD_INT 10
82906: PUSH
82907: LD_INT 11
82909: PUSH
82910: LD_INT 12
82912: PUSH
82913: LD_INT 13
82915: PUSH
82916: LD_INT 14
82918: PUSH
82919: LD_INT 15
82921: PUSH
82922: LD_INT 16
82924: PUSH
82925: LD_INT 17
82927: PUSH
82928: LD_INT 18
82930: PUSH
82931: LD_INT 19
82933: PUSH
82934: LD_INT 20
82936: PUSH
82937: LD_INT 21
82939: PUSH
82940: LD_INT 22
82942: PUSH
82943: LD_INT 23
82945: PUSH
82946: LD_INT 24
82948: PUSH
82949: LD_INT 25
82951: PUSH
82952: LD_INT 26
82954: PUSH
82955: LD_INT 27
82957: PUSH
82958: LD_INT 28
82960: PUSH
82961: LD_INT 29
82963: PUSH
82964: LD_INT 30
82966: PUSH
82967: LD_INT 31
82969: PUSH
82970: LD_INT 32
82972: PUSH
82973: LD_INT 33
82975: PUSH
82976: LD_INT 34
82978: PUSH
82979: LD_INT 36
82981: PUSH
82982: EMPTY
82983: LIST
82984: LIST
82985: LIST
82986: LIST
82987: LIST
82988: LIST
82989: LIST
82990: LIST
82991: LIST
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: LIST
82997: LIST
82998: LIST
82999: LIST
83000: LIST
83001: LIST
83002: LIST
83003: LIST
83004: LIST
83005: LIST
83006: LIST
83007: LIST
83008: LIST
83009: LIST
83010: LIST
83011: LIST
83012: LIST
83013: LIST
83014: LIST
83015: LIST
83016: LIST
83017: LIST
83018: PUSH
83019: LD_INT 101
83021: PUSH
83022: LD_INT 102
83024: PUSH
83025: LD_INT 103
83027: PUSH
83028: LD_INT 104
83030: PUSH
83031: LD_INT 105
83033: PUSH
83034: LD_INT 106
83036: PUSH
83037: LD_INT 107
83039: PUSH
83040: LD_INT 108
83042: PUSH
83043: LD_INT 109
83045: PUSH
83046: LD_INT 110
83048: PUSH
83049: LD_INT 111
83051: PUSH
83052: LD_INT 112
83054: PUSH
83055: LD_INT 113
83057: PUSH
83058: LD_INT 114
83060: PUSH
83061: EMPTY
83062: LIST
83063: LIST
83064: LIST
83065: LIST
83066: LIST
83067: LIST
83068: LIST
83069: LIST
83070: LIST
83071: LIST
83072: LIST
83073: LIST
83074: LIST
83075: LIST
83076: PUSH
83077: EMPTY
83078: LIST
83079: LIST
83080: ST_TO_ADDR
83081: GO 84028
83083: LD_INT 15
83085: DOUBLE
83086: EQUAL
83087: IFTRUE 83091
83089: GO 83303
83091: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
83092: LD_ADDR_VAR 0 1
83096: PUSH
83097: LD_INT 1
83099: PUSH
83100: LD_INT 2
83102: PUSH
83103: LD_INT 3
83105: PUSH
83106: LD_INT 4
83108: PUSH
83109: LD_INT 5
83111: PUSH
83112: LD_INT 6
83114: PUSH
83115: LD_INT 7
83117: PUSH
83118: LD_INT 8
83120: PUSH
83121: LD_INT 9
83123: PUSH
83124: LD_INT 10
83126: PUSH
83127: LD_INT 11
83129: PUSH
83130: LD_INT 12
83132: PUSH
83133: LD_INT 13
83135: PUSH
83136: LD_INT 14
83138: PUSH
83139: LD_INT 15
83141: PUSH
83142: LD_INT 16
83144: PUSH
83145: LD_INT 17
83147: PUSH
83148: LD_INT 18
83150: PUSH
83151: LD_INT 19
83153: PUSH
83154: LD_INT 20
83156: PUSH
83157: LD_INT 21
83159: PUSH
83160: LD_INT 22
83162: PUSH
83163: LD_INT 23
83165: PUSH
83166: LD_INT 24
83168: PUSH
83169: LD_INT 25
83171: PUSH
83172: LD_INT 26
83174: PUSH
83175: LD_INT 27
83177: PUSH
83178: LD_INT 28
83180: PUSH
83181: LD_INT 29
83183: PUSH
83184: LD_INT 30
83186: PUSH
83187: LD_INT 31
83189: PUSH
83190: LD_INT 32
83192: PUSH
83193: LD_INT 33
83195: PUSH
83196: LD_INT 34
83198: PUSH
83199: LD_INT 36
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: LIST
83206: LIST
83207: LIST
83208: LIST
83209: LIST
83210: LIST
83211: LIST
83212: LIST
83213: LIST
83214: LIST
83215: LIST
83216: LIST
83217: LIST
83218: LIST
83219: LIST
83220: LIST
83221: LIST
83222: LIST
83223: LIST
83224: LIST
83225: LIST
83226: LIST
83227: LIST
83228: LIST
83229: LIST
83230: LIST
83231: LIST
83232: LIST
83233: LIST
83234: LIST
83235: LIST
83236: LIST
83237: LIST
83238: PUSH
83239: LD_INT 101
83241: PUSH
83242: LD_INT 102
83244: PUSH
83245: LD_INT 103
83247: PUSH
83248: LD_INT 104
83250: PUSH
83251: LD_INT 105
83253: PUSH
83254: LD_INT 106
83256: PUSH
83257: LD_INT 107
83259: PUSH
83260: LD_INT 108
83262: PUSH
83263: LD_INT 109
83265: PUSH
83266: LD_INT 110
83268: PUSH
83269: LD_INT 111
83271: PUSH
83272: LD_INT 112
83274: PUSH
83275: LD_INT 113
83277: PUSH
83278: LD_INT 114
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: LIST
83285: LIST
83286: LIST
83287: LIST
83288: LIST
83289: LIST
83290: LIST
83291: LIST
83292: LIST
83293: LIST
83294: LIST
83295: LIST
83296: PUSH
83297: EMPTY
83298: LIST
83299: LIST
83300: ST_TO_ADDR
83301: GO 84028
83303: LD_INT 16
83305: DOUBLE
83306: EQUAL
83307: IFTRUE 83311
83309: GO 83435
83311: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
83312: LD_ADDR_VAR 0 1
83316: PUSH
83317: LD_INT 2
83319: PUSH
83320: LD_INT 4
83322: PUSH
83323: LD_INT 5
83325: PUSH
83326: LD_INT 7
83328: PUSH
83329: LD_INT 11
83331: PUSH
83332: LD_INT 12
83334: PUSH
83335: LD_INT 15
83337: PUSH
83338: LD_INT 16
83340: PUSH
83341: LD_INT 20
83343: PUSH
83344: LD_INT 21
83346: PUSH
83347: LD_INT 22
83349: PUSH
83350: LD_INT 23
83352: PUSH
83353: LD_INT 25
83355: PUSH
83356: LD_INT 26
83358: PUSH
83359: LD_INT 30
83361: PUSH
83362: LD_INT 31
83364: PUSH
83365: LD_INT 32
83367: PUSH
83368: LD_INT 33
83370: PUSH
83371: LD_INT 34
83373: PUSH
83374: EMPTY
83375: LIST
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: LIST
83393: LIST
83394: PUSH
83395: LD_INT 101
83397: PUSH
83398: LD_INT 102
83400: PUSH
83401: LD_INT 103
83403: PUSH
83404: LD_INT 106
83406: PUSH
83407: LD_INT 108
83409: PUSH
83410: LD_INT 112
83412: PUSH
83413: LD_INT 113
83415: PUSH
83416: LD_INT 114
83418: PUSH
83419: EMPTY
83420: LIST
83421: LIST
83422: LIST
83423: LIST
83424: LIST
83425: LIST
83426: LIST
83427: LIST
83428: PUSH
83429: EMPTY
83430: LIST
83431: LIST
83432: ST_TO_ADDR
83433: GO 84028
83435: LD_INT 17
83437: DOUBLE
83438: EQUAL
83439: IFTRUE 83443
83441: GO 83655
83443: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
83444: LD_ADDR_VAR 0 1
83448: PUSH
83449: LD_INT 1
83451: PUSH
83452: LD_INT 2
83454: PUSH
83455: LD_INT 3
83457: PUSH
83458: LD_INT 4
83460: PUSH
83461: LD_INT 5
83463: PUSH
83464: LD_INT 6
83466: PUSH
83467: LD_INT 7
83469: PUSH
83470: LD_INT 8
83472: PUSH
83473: LD_INT 9
83475: PUSH
83476: LD_INT 10
83478: PUSH
83479: LD_INT 11
83481: PUSH
83482: LD_INT 12
83484: PUSH
83485: LD_INT 13
83487: PUSH
83488: LD_INT 14
83490: PUSH
83491: LD_INT 15
83493: PUSH
83494: LD_INT 16
83496: PUSH
83497: LD_INT 17
83499: PUSH
83500: LD_INT 18
83502: PUSH
83503: LD_INT 19
83505: PUSH
83506: LD_INT 20
83508: PUSH
83509: LD_INT 21
83511: PUSH
83512: LD_INT 22
83514: PUSH
83515: LD_INT 23
83517: PUSH
83518: LD_INT 24
83520: PUSH
83521: LD_INT 25
83523: PUSH
83524: LD_INT 26
83526: PUSH
83527: LD_INT 27
83529: PUSH
83530: LD_INT 28
83532: PUSH
83533: LD_INT 29
83535: PUSH
83536: LD_INT 30
83538: PUSH
83539: LD_INT 31
83541: PUSH
83542: LD_INT 32
83544: PUSH
83545: LD_INT 33
83547: PUSH
83548: LD_INT 34
83550: PUSH
83551: LD_INT 36
83553: PUSH
83554: EMPTY
83555: LIST
83556: LIST
83557: LIST
83558: LIST
83559: LIST
83560: LIST
83561: LIST
83562: LIST
83563: LIST
83564: LIST
83565: LIST
83566: LIST
83567: LIST
83568: LIST
83569: LIST
83570: LIST
83571: LIST
83572: LIST
83573: LIST
83574: LIST
83575: LIST
83576: LIST
83577: LIST
83578: LIST
83579: LIST
83580: LIST
83581: LIST
83582: LIST
83583: LIST
83584: LIST
83585: LIST
83586: LIST
83587: LIST
83588: LIST
83589: LIST
83590: PUSH
83591: LD_INT 101
83593: PUSH
83594: LD_INT 102
83596: PUSH
83597: LD_INT 103
83599: PUSH
83600: LD_INT 104
83602: PUSH
83603: LD_INT 105
83605: PUSH
83606: LD_INT 106
83608: PUSH
83609: LD_INT 107
83611: PUSH
83612: LD_INT 108
83614: PUSH
83615: LD_INT 109
83617: PUSH
83618: LD_INT 110
83620: PUSH
83621: LD_INT 111
83623: PUSH
83624: LD_INT 112
83626: PUSH
83627: LD_INT 113
83629: PUSH
83630: LD_INT 114
83632: PUSH
83633: EMPTY
83634: LIST
83635: LIST
83636: LIST
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: LIST
83644: LIST
83645: LIST
83646: LIST
83647: LIST
83648: PUSH
83649: EMPTY
83650: LIST
83651: LIST
83652: ST_TO_ADDR
83653: GO 84028
83655: LD_INT 18
83657: DOUBLE
83658: EQUAL
83659: IFTRUE 83663
83661: GO 83799
83663: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
83664: LD_ADDR_VAR 0 1
83668: PUSH
83669: LD_INT 2
83671: PUSH
83672: LD_INT 4
83674: PUSH
83675: LD_INT 5
83677: PUSH
83678: LD_INT 7
83680: PUSH
83681: LD_INT 11
83683: PUSH
83684: LD_INT 12
83686: PUSH
83687: LD_INT 15
83689: PUSH
83690: LD_INT 16
83692: PUSH
83693: LD_INT 20
83695: PUSH
83696: LD_INT 21
83698: PUSH
83699: LD_INT 22
83701: PUSH
83702: LD_INT 23
83704: PUSH
83705: LD_INT 25
83707: PUSH
83708: LD_INT 26
83710: PUSH
83711: LD_INT 30
83713: PUSH
83714: LD_INT 31
83716: PUSH
83717: LD_INT 32
83719: PUSH
83720: LD_INT 33
83722: PUSH
83723: LD_INT 34
83725: PUSH
83726: LD_INT 35
83728: PUSH
83729: LD_INT 36
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: LIST
83736: LIST
83737: LIST
83738: LIST
83739: LIST
83740: LIST
83741: LIST
83742: LIST
83743: LIST
83744: LIST
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: PUSH
83755: LD_INT 101
83757: PUSH
83758: LD_INT 102
83760: PUSH
83761: LD_INT 103
83763: PUSH
83764: LD_INT 106
83766: PUSH
83767: LD_INT 108
83769: PUSH
83770: LD_INT 112
83772: PUSH
83773: LD_INT 113
83775: PUSH
83776: LD_INT 114
83778: PUSH
83779: LD_INT 115
83781: PUSH
83782: EMPTY
83783: LIST
83784: LIST
83785: LIST
83786: LIST
83787: LIST
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: PUSH
83793: EMPTY
83794: LIST
83795: LIST
83796: ST_TO_ADDR
83797: GO 84028
83799: LD_INT 19
83801: DOUBLE
83802: EQUAL
83803: IFTRUE 83807
83805: GO 84027
83807: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
83808: LD_ADDR_VAR 0 1
83812: PUSH
83813: LD_INT 1
83815: PUSH
83816: LD_INT 2
83818: PUSH
83819: LD_INT 3
83821: PUSH
83822: LD_INT 4
83824: PUSH
83825: LD_INT 5
83827: PUSH
83828: LD_INT 6
83830: PUSH
83831: LD_INT 7
83833: PUSH
83834: LD_INT 8
83836: PUSH
83837: LD_INT 9
83839: PUSH
83840: LD_INT 10
83842: PUSH
83843: LD_INT 11
83845: PUSH
83846: LD_INT 12
83848: PUSH
83849: LD_INT 13
83851: PUSH
83852: LD_INT 14
83854: PUSH
83855: LD_INT 15
83857: PUSH
83858: LD_INT 16
83860: PUSH
83861: LD_INT 17
83863: PUSH
83864: LD_INT 18
83866: PUSH
83867: LD_INT 19
83869: PUSH
83870: LD_INT 20
83872: PUSH
83873: LD_INT 21
83875: PUSH
83876: LD_INT 22
83878: PUSH
83879: LD_INT 23
83881: PUSH
83882: LD_INT 24
83884: PUSH
83885: LD_INT 25
83887: PUSH
83888: LD_INT 26
83890: PUSH
83891: LD_INT 27
83893: PUSH
83894: LD_INT 28
83896: PUSH
83897: LD_INT 29
83899: PUSH
83900: LD_INT 30
83902: PUSH
83903: LD_INT 31
83905: PUSH
83906: LD_INT 32
83908: PUSH
83909: LD_INT 33
83911: PUSH
83912: LD_INT 34
83914: PUSH
83915: LD_INT 35
83917: PUSH
83918: LD_INT 36
83920: PUSH
83921: EMPTY
83922: LIST
83923: LIST
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: LIST
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: LIST
83944: LIST
83945: LIST
83946: LIST
83947: LIST
83948: LIST
83949: LIST
83950: LIST
83951: LIST
83952: LIST
83953: LIST
83954: LIST
83955: LIST
83956: LIST
83957: LIST
83958: PUSH
83959: LD_INT 101
83961: PUSH
83962: LD_INT 102
83964: PUSH
83965: LD_INT 103
83967: PUSH
83968: LD_INT 104
83970: PUSH
83971: LD_INT 105
83973: PUSH
83974: LD_INT 106
83976: PUSH
83977: LD_INT 107
83979: PUSH
83980: LD_INT 108
83982: PUSH
83983: LD_INT 109
83985: PUSH
83986: LD_INT 110
83988: PUSH
83989: LD_INT 111
83991: PUSH
83992: LD_INT 112
83994: PUSH
83995: LD_INT 113
83997: PUSH
83998: LD_INT 114
84000: PUSH
84001: LD_INT 115
84003: PUSH
84004: EMPTY
84005: LIST
84006: LIST
84007: LIST
84008: LIST
84009: LIST
84010: LIST
84011: LIST
84012: LIST
84013: LIST
84014: LIST
84015: LIST
84016: LIST
84017: LIST
84018: LIST
84019: LIST
84020: PUSH
84021: EMPTY
84022: LIST
84023: LIST
84024: ST_TO_ADDR
84025: GO 84028
84027: POP
// end else
84028: GO 84247
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
84030: LD_ADDR_VAR 0 1
84034: PUSH
84035: LD_INT 1
84037: PUSH
84038: LD_INT 2
84040: PUSH
84041: LD_INT 3
84043: PUSH
84044: LD_INT 4
84046: PUSH
84047: LD_INT 5
84049: PUSH
84050: LD_INT 6
84052: PUSH
84053: LD_INT 7
84055: PUSH
84056: LD_INT 8
84058: PUSH
84059: LD_INT 9
84061: PUSH
84062: LD_INT 10
84064: PUSH
84065: LD_INT 11
84067: PUSH
84068: LD_INT 12
84070: PUSH
84071: LD_INT 13
84073: PUSH
84074: LD_INT 14
84076: PUSH
84077: LD_INT 15
84079: PUSH
84080: LD_INT 16
84082: PUSH
84083: LD_INT 17
84085: PUSH
84086: LD_INT 18
84088: PUSH
84089: LD_INT 19
84091: PUSH
84092: LD_INT 20
84094: PUSH
84095: LD_INT 21
84097: PUSH
84098: LD_INT 22
84100: PUSH
84101: LD_INT 23
84103: PUSH
84104: LD_INT 24
84106: PUSH
84107: LD_INT 25
84109: PUSH
84110: LD_INT 26
84112: PUSH
84113: LD_INT 27
84115: PUSH
84116: LD_INT 28
84118: PUSH
84119: LD_INT 29
84121: PUSH
84122: LD_INT 30
84124: PUSH
84125: LD_INT 31
84127: PUSH
84128: LD_INT 32
84130: PUSH
84131: LD_INT 33
84133: PUSH
84134: LD_INT 34
84136: PUSH
84137: LD_INT 35
84139: PUSH
84140: LD_INT 36
84142: PUSH
84143: EMPTY
84144: LIST
84145: LIST
84146: LIST
84147: LIST
84148: LIST
84149: LIST
84150: LIST
84151: LIST
84152: LIST
84153: LIST
84154: LIST
84155: LIST
84156: LIST
84157: LIST
84158: LIST
84159: LIST
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: LIST
84169: LIST
84170: LIST
84171: LIST
84172: LIST
84173: LIST
84174: LIST
84175: LIST
84176: LIST
84177: LIST
84178: LIST
84179: LIST
84180: PUSH
84181: LD_INT 101
84183: PUSH
84184: LD_INT 102
84186: PUSH
84187: LD_INT 103
84189: PUSH
84190: LD_INT 104
84192: PUSH
84193: LD_INT 105
84195: PUSH
84196: LD_INT 106
84198: PUSH
84199: LD_INT 107
84201: PUSH
84202: LD_INT 108
84204: PUSH
84205: LD_INT 109
84207: PUSH
84208: LD_INT 110
84210: PUSH
84211: LD_INT 111
84213: PUSH
84214: LD_INT 112
84216: PUSH
84217: LD_INT 113
84219: PUSH
84220: LD_INT 114
84222: PUSH
84223: LD_INT 115
84225: PUSH
84226: EMPTY
84227: LIST
84228: LIST
84229: LIST
84230: LIST
84231: LIST
84232: LIST
84233: LIST
84234: LIST
84235: LIST
84236: LIST
84237: LIST
84238: LIST
84239: LIST
84240: LIST
84241: LIST
84242: PUSH
84243: EMPTY
84244: LIST
84245: LIST
84246: ST_TO_ADDR
// if result then
84247: LD_VAR 0 1
84251: IFFALSE 84540
// begin normal :=  ;
84253: LD_ADDR_VAR 0 3
84257: PUSH
84258: LD_STRING 
84260: ST_TO_ADDR
// hardcore :=  ;
84261: LD_ADDR_VAR 0 4
84265: PUSH
84266: LD_STRING 
84268: ST_TO_ADDR
// for i = 1 to normalCounter do
84269: LD_ADDR_VAR 0 5
84273: PUSH
84274: DOUBLE
84275: LD_INT 1
84277: DEC
84278: ST_TO_ADDR
84279: LD_EXP 116
84283: PUSH
84284: FOR_TO
84285: IFFALSE 84386
// begin tmp := 0 ;
84287: LD_ADDR_VAR 0 2
84291: PUSH
84292: LD_STRING 0
84294: ST_TO_ADDR
// if result [ 1 ] then
84295: LD_VAR 0 1
84299: PUSH
84300: LD_INT 1
84302: ARRAY
84303: IFFALSE 84368
// if result [ 1 ] [ 1 ] = i then
84305: LD_VAR 0 1
84309: PUSH
84310: LD_INT 1
84312: ARRAY
84313: PUSH
84314: LD_INT 1
84316: ARRAY
84317: PUSH
84318: LD_VAR 0 5
84322: EQUAL
84323: IFFALSE 84368
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
84325: LD_ADDR_VAR 0 1
84329: PUSH
84330: LD_VAR 0 1
84334: PPUSH
84335: LD_INT 1
84337: PPUSH
84338: LD_VAR 0 1
84342: PUSH
84343: LD_INT 1
84345: ARRAY
84346: PPUSH
84347: LD_INT 1
84349: PPUSH
84350: CALL_OW 3
84354: PPUSH
84355: CALL_OW 1
84359: ST_TO_ADDR
// tmp := 1 ;
84360: LD_ADDR_VAR 0 2
84364: PUSH
84365: LD_STRING 1
84367: ST_TO_ADDR
// end ; normal := normal & tmp ;
84368: LD_ADDR_VAR 0 3
84372: PUSH
84373: LD_VAR 0 3
84377: PUSH
84378: LD_VAR 0 2
84382: STR
84383: ST_TO_ADDR
// end ;
84384: GO 84284
84386: POP
84387: POP
// for i = 1 to hardcoreCounter do
84388: LD_ADDR_VAR 0 5
84392: PUSH
84393: DOUBLE
84394: LD_INT 1
84396: DEC
84397: ST_TO_ADDR
84398: LD_EXP 117
84402: PUSH
84403: FOR_TO
84404: IFFALSE 84509
// begin tmp := 0 ;
84406: LD_ADDR_VAR 0 2
84410: PUSH
84411: LD_STRING 0
84413: ST_TO_ADDR
// if result [ 2 ] then
84414: LD_VAR 0 1
84418: PUSH
84419: LD_INT 2
84421: ARRAY
84422: IFFALSE 84491
// if result [ 2 ] [ 1 ] = 100 + i then
84424: LD_VAR 0 1
84428: PUSH
84429: LD_INT 2
84431: ARRAY
84432: PUSH
84433: LD_INT 1
84435: ARRAY
84436: PUSH
84437: LD_INT 100
84439: PUSH
84440: LD_VAR 0 5
84444: PLUS
84445: EQUAL
84446: IFFALSE 84491
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
84448: LD_ADDR_VAR 0 1
84452: PUSH
84453: LD_VAR 0 1
84457: PPUSH
84458: LD_INT 2
84460: PPUSH
84461: LD_VAR 0 1
84465: PUSH
84466: LD_INT 2
84468: ARRAY
84469: PPUSH
84470: LD_INT 1
84472: PPUSH
84473: CALL_OW 3
84477: PPUSH
84478: CALL_OW 1
84482: ST_TO_ADDR
// tmp := 1 ;
84483: LD_ADDR_VAR 0 2
84487: PUSH
84488: LD_STRING 1
84490: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
84491: LD_ADDR_VAR 0 4
84495: PUSH
84496: LD_VAR 0 4
84500: PUSH
84501: LD_VAR 0 2
84505: STR
84506: ST_TO_ADDR
// end ;
84507: GO 84403
84509: POP
84510: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
84511: LD_STRING getStreamItemsFromMission("
84513: PUSH
84514: LD_VAR 0 3
84518: STR
84519: PUSH
84520: LD_STRING ","
84522: STR
84523: PUSH
84524: LD_VAR 0 4
84528: STR
84529: PUSH
84530: LD_STRING ")
84532: STR
84533: PPUSH
84534: CALL_OW 559
// end else
84538: GO 84547
// ToLua ( getStreamItemsFromMission("","") ) ;
84540: LD_STRING getStreamItemsFromMission("","")
84542: PPUSH
84543: CALL_OW 559
// end ;
84547: LD_VAR 0 1
84551: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
84552: LD_VAR 0 2
84556: PUSH
84557: LD_INT 100
84559: EQUAL
84560: IFFALSE 85509
// begin if not StreamModeActive then
84562: LD_EXP 115
84566: NOT
84567: IFFALSE 84577
// StreamModeActive := true ;
84569: LD_ADDR_EXP 115
84573: PUSH
84574: LD_INT 1
84576: ST_TO_ADDR
// if p3 = 0 then
84577: LD_VAR 0 3
84581: PUSH
84582: LD_INT 0
84584: EQUAL
84585: IFFALSE 84591
// InitStreamMode ;
84587: CALL 80630 0 0
// if p3 = 1 then
84591: LD_VAR 0 3
84595: PUSH
84596: LD_INT 1
84598: EQUAL
84599: IFFALSE 84609
// sRocket := true ;
84601: LD_ADDR_EXP 120
84605: PUSH
84606: LD_INT 1
84608: ST_TO_ADDR
// if p3 = 2 then
84609: LD_VAR 0 3
84613: PUSH
84614: LD_INT 2
84616: EQUAL
84617: IFFALSE 84627
// sSpeed := true ;
84619: LD_ADDR_EXP 119
84623: PUSH
84624: LD_INT 1
84626: ST_TO_ADDR
// if p3 = 3 then
84627: LD_VAR 0 3
84631: PUSH
84632: LD_INT 3
84634: EQUAL
84635: IFFALSE 84645
// sEngine := true ;
84637: LD_ADDR_EXP 121
84641: PUSH
84642: LD_INT 1
84644: ST_TO_ADDR
// if p3 = 4 then
84645: LD_VAR 0 3
84649: PUSH
84650: LD_INT 4
84652: EQUAL
84653: IFFALSE 84663
// sSpec := true ;
84655: LD_ADDR_EXP 118
84659: PUSH
84660: LD_INT 1
84662: ST_TO_ADDR
// if p3 = 5 then
84663: LD_VAR 0 3
84667: PUSH
84668: LD_INT 5
84670: EQUAL
84671: IFFALSE 84681
// sLevel := true ;
84673: LD_ADDR_EXP 122
84677: PUSH
84678: LD_INT 1
84680: ST_TO_ADDR
// if p3 = 6 then
84681: LD_VAR 0 3
84685: PUSH
84686: LD_INT 6
84688: EQUAL
84689: IFFALSE 84699
// sArmoury := true ;
84691: LD_ADDR_EXP 123
84695: PUSH
84696: LD_INT 1
84698: ST_TO_ADDR
// if p3 = 7 then
84699: LD_VAR 0 3
84703: PUSH
84704: LD_INT 7
84706: EQUAL
84707: IFFALSE 84717
// sRadar := true ;
84709: LD_ADDR_EXP 124
84713: PUSH
84714: LD_INT 1
84716: ST_TO_ADDR
// if p3 = 8 then
84717: LD_VAR 0 3
84721: PUSH
84722: LD_INT 8
84724: EQUAL
84725: IFFALSE 84735
// sBunker := true ;
84727: LD_ADDR_EXP 125
84731: PUSH
84732: LD_INT 1
84734: ST_TO_ADDR
// if p3 = 9 then
84735: LD_VAR 0 3
84739: PUSH
84740: LD_INT 9
84742: EQUAL
84743: IFFALSE 84753
// sHack := true ;
84745: LD_ADDR_EXP 126
84749: PUSH
84750: LD_INT 1
84752: ST_TO_ADDR
// if p3 = 10 then
84753: LD_VAR 0 3
84757: PUSH
84758: LD_INT 10
84760: EQUAL
84761: IFFALSE 84771
// sFire := true ;
84763: LD_ADDR_EXP 127
84767: PUSH
84768: LD_INT 1
84770: ST_TO_ADDR
// if p3 = 11 then
84771: LD_VAR 0 3
84775: PUSH
84776: LD_INT 11
84778: EQUAL
84779: IFFALSE 84789
// sRefresh := true ;
84781: LD_ADDR_EXP 128
84785: PUSH
84786: LD_INT 1
84788: ST_TO_ADDR
// if p3 = 12 then
84789: LD_VAR 0 3
84793: PUSH
84794: LD_INT 12
84796: EQUAL
84797: IFFALSE 84807
// sExp := true ;
84799: LD_ADDR_EXP 129
84803: PUSH
84804: LD_INT 1
84806: ST_TO_ADDR
// if p3 = 13 then
84807: LD_VAR 0 3
84811: PUSH
84812: LD_INT 13
84814: EQUAL
84815: IFFALSE 84825
// sDepot := true ;
84817: LD_ADDR_EXP 130
84821: PUSH
84822: LD_INT 1
84824: ST_TO_ADDR
// if p3 = 14 then
84825: LD_VAR 0 3
84829: PUSH
84830: LD_INT 14
84832: EQUAL
84833: IFFALSE 84843
// sFlag := true ;
84835: LD_ADDR_EXP 131
84839: PUSH
84840: LD_INT 1
84842: ST_TO_ADDR
// if p3 = 15 then
84843: LD_VAR 0 3
84847: PUSH
84848: LD_INT 15
84850: EQUAL
84851: IFFALSE 84861
// sKamikadze := true ;
84853: LD_ADDR_EXP 139
84857: PUSH
84858: LD_INT 1
84860: ST_TO_ADDR
// if p3 = 16 then
84861: LD_VAR 0 3
84865: PUSH
84866: LD_INT 16
84868: EQUAL
84869: IFFALSE 84879
// sTroll := true ;
84871: LD_ADDR_EXP 140
84875: PUSH
84876: LD_INT 1
84878: ST_TO_ADDR
// if p3 = 17 then
84879: LD_VAR 0 3
84883: PUSH
84884: LD_INT 17
84886: EQUAL
84887: IFFALSE 84897
// sSlow := true ;
84889: LD_ADDR_EXP 141
84893: PUSH
84894: LD_INT 1
84896: ST_TO_ADDR
// if p3 = 18 then
84897: LD_VAR 0 3
84901: PUSH
84902: LD_INT 18
84904: EQUAL
84905: IFFALSE 84915
// sLack := true ;
84907: LD_ADDR_EXP 142
84911: PUSH
84912: LD_INT 1
84914: ST_TO_ADDR
// if p3 = 19 then
84915: LD_VAR 0 3
84919: PUSH
84920: LD_INT 19
84922: EQUAL
84923: IFFALSE 84933
// sTank := true ;
84925: LD_ADDR_EXP 144
84929: PUSH
84930: LD_INT 1
84932: ST_TO_ADDR
// if p3 = 20 then
84933: LD_VAR 0 3
84937: PUSH
84938: LD_INT 20
84940: EQUAL
84941: IFFALSE 84951
// sRemote := true ;
84943: LD_ADDR_EXP 145
84947: PUSH
84948: LD_INT 1
84950: ST_TO_ADDR
// if p3 = 21 then
84951: LD_VAR 0 3
84955: PUSH
84956: LD_INT 21
84958: EQUAL
84959: IFFALSE 84969
// sPowell := true ;
84961: LD_ADDR_EXP 146
84965: PUSH
84966: LD_INT 1
84968: ST_TO_ADDR
// if p3 = 22 then
84969: LD_VAR 0 3
84973: PUSH
84974: LD_INT 22
84976: EQUAL
84977: IFFALSE 84987
// sTeleport := true ;
84979: LD_ADDR_EXP 149
84983: PUSH
84984: LD_INT 1
84986: ST_TO_ADDR
// if p3 = 23 then
84987: LD_VAR 0 3
84991: PUSH
84992: LD_INT 23
84994: EQUAL
84995: IFFALSE 85005
// sOilTower := true ;
84997: LD_ADDR_EXP 151
85001: PUSH
85002: LD_INT 1
85004: ST_TO_ADDR
// if p3 = 24 then
85005: LD_VAR 0 3
85009: PUSH
85010: LD_INT 24
85012: EQUAL
85013: IFFALSE 85023
// sShovel := true ;
85015: LD_ADDR_EXP 152
85019: PUSH
85020: LD_INT 1
85022: ST_TO_ADDR
// if p3 = 25 then
85023: LD_VAR 0 3
85027: PUSH
85028: LD_INT 25
85030: EQUAL
85031: IFFALSE 85041
// sSheik := true ;
85033: LD_ADDR_EXP 153
85037: PUSH
85038: LD_INT 1
85040: ST_TO_ADDR
// if p3 = 26 then
85041: LD_VAR 0 3
85045: PUSH
85046: LD_INT 26
85048: EQUAL
85049: IFFALSE 85059
// sEarthquake := true ;
85051: LD_ADDR_EXP 155
85055: PUSH
85056: LD_INT 1
85058: ST_TO_ADDR
// if p3 = 27 then
85059: LD_VAR 0 3
85063: PUSH
85064: LD_INT 27
85066: EQUAL
85067: IFFALSE 85077
// sAI := true ;
85069: LD_ADDR_EXP 156
85073: PUSH
85074: LD_INT 1
85076: ST_TO_ADDR
// if p3 = 28 then
85077: LD_VAR 0 3
85081: PUSH
85082: LD_INT 28
85084: EQUAL
85085: IFFALSE 85095
// sCargo := true ;
85087: LD_ADDR_EXP 159
85091: PUSH
85092: LD_INT 1
85094: ST_TO_ADDR
// if p3 = 29 then
85095: LD_VAR 0 3
85099: PUSH
85100: LD_INT 29
85102: EQUAL
85103: IFFALSE 85113
// sDLaser := true ;
85105: LD_ADDR_EXP 160
85109: PUSH
85110: LD_INT 1
85112: ST_TO_ADDR
// if p3 = 30 then
85113: LD_VAR 0 3
85117: PUSH
85118: LD_INT 30
85120: EQUAL
85121: IFFALSE 85131
// sExchange := true ;
85123: LD_ADDR_EXP 161
85127: PUSH
85128: LD_INT 1
85130: ST_TO_ADDR
// if p3 = 31 then
85131: LD_VAR 0 3
85135: PUSH
85136: LD_INT 31
85138: EQUAL
85139: IFFALSE 85149
// sFac := true ;
85141: LD_ADDR_EXP 162
85145: PUSH
85146: LD_INT 1
85148: ST_TO_ADDR
// if p3 = 32 then
85149: LD_VAR 0 3
85153: PUSH
85154: LD_INT 32
85156: EQUAL
85157: IFFALSE 85167
// sPower := true ;
85159: LD_ADDR_EXP 163
85163: PUSH
85164: LD_INT 1
85166: ST_TO_ADDR
// if p3 = 33 then
85167: LD_VAR 0 3
85171: PUSH
85172: LD_INT 33
85174: EQUAL
85175: IFFALSE 85185
// sRandom := true ;
85177: LD_ADDR_EXP 164
85181: PUSH
85182: LD_INT 1
85184: ST_TO_ADDR
// if p3 = 34 then
85185: LD_VAR 0 3
85189: PUSH
85190: LD_INT 34
85192: EQUAL
85193: IFFALSE 85203
// sShield := true ;
85195: LD_ADDR_EXP 165
85199: PUSH
85200: LD_INT 1
85202: ST_TO_ADDR
// if p3 = 35 then
85203: LD_VAR 0 3
85207: PUSH
85208: LD_INT 35
85210: EQUAL
85211: IFFALSE 85221
// sTime := true ;
85213: LD_ADDR_EXP 166
85217: PUSH
85218: LD_INT 1
85220: ST_TO_ADDR
// if p3 = 36 then
85221: LD_VAR 0 3
85225: PUSH
85226: LD_INT 36
85228: EQUAL
85229: IFFALSE 85239
// sTools := true ;
85231: LD_ADDR_EXP 167
85235: PUSH
85236: LD_INT 1
85238: ST_TO_ADDR
// if p3 = 101 then
85239: LD_VAR 0 3
85243: PUSH
85244: LD_INT 101
85246: EQUAL
85247: IFFALSE 85257
// sSold := true ;
85249: LD_ADDR_EXP 132
85253: PUSH
85254: LD_INT 1
85256: ST_TO_ADDR
// if p3 = 102 then
85257: LD_VAR 0 3
85261: PUSH
85262: LD_INT 102
85264: EQUAL
85265: IFFALSE 85275
// sDiff := true ;
85267: LD_ADDR_EXP 133
85271: PUSH
85272: LD_INT 1
85274: ST_TO_ADDR
// if p3 = 103 then
85275: LD_VAR 0 3
85279: PUSH
85280: LD_INT 103
85282: EQUAL
85283: IFFALSE 85293
// sFog := true ;
85285: LD_ADDR_EXP 136
85289: PUSH
85290: LD_INT 1
85292: ST_TO_ADDR
// if p3 = 104 then
85293: LD_VAR 0 3
85297: PUSH
85298: LD_INT 104
85300: EQUAL
85301: IFFALSE 85311
// sReset := true ;
85303: LD_ADDR_EXP 137
85307: PUSH
85308: LD_INT 1
85310: ST_TO_ADDR
// if p3 = 105 then
85311: LD_VAR 0 3
85315: PUSH
85316: LD_INT 105
85318: EQUAL
85319: IFFALSE 85329
// sSun := true ;
85321: LD_ADDR_EXP 138
85325: PUSH
85326: LD_INT 1
85328: ST_TO_ADDR
// if p3 = 106 then
85329: LD_VAR 0 3
85333: PUSH
85334: LD_INT 106
85336: EQUAL
85337: IFFALSE 85347
// sTiger := true ;
85339: LD_ADDR_EXP 134
85343: PUSH
85344: LD_INT 1
85346: ST_TO_ADDR
// if p3 = 107 then
85347: LD_VAR 0 3
85351: PUSH
85352: LD_INT 107
85354: EQUAL
85355: IFFALSE 85365
// sBomb := true ;
85357: LD_ADDR_EXP 135
85361: PUSH
85362: LD_INT 1
85364: ST_TO_ADDR
// if p3 = 108 then
85365: LD_VAR 0 3
85369: PUSH
85370: LD_INT 108
85372: EQUAL
85373: IFFALSE 85383
// sWound := true ;
85375: LD_ADDR_EXP 143
85379: PUSH
85380: LD_INT 1
85382: ST_TO_ADDR
// if p3 = 109 then
85383: LD_VAR 0 3
85387: PUSH
85388: LD_INT 109
85390: EQUAL
85391: IFFALSE 85401
// sBetray := true ;
85393: LD_ADDR_EXP 147
85397: PUSH
85398: LD_INT 1
85400: ST_TO_ADDR
// if p3 = 110 then
85401: LD_VAR 0 3
85405: PUSH
85406: LD_INT 110
85408: EQUAL
85409: IFFALSE 85419
// sContamin := true ;
85411: LD_ADDR_EXP 148
85415: PUSH
85416: LD_INT 1
85418: ST_TO_ADDR
// if p3 = 111 then
85419: LD_VAR 0 3
85423: PUSH
85424: LD_INT 111
85426: EQUAL
85427: IFFALSE 85437
// sOil := true ;
85429: LD_ADDR_EXP 150
85433: PUSH
85434: LD_INT 1
85436: ST_TO_ADDR
// if p3 = 112 then
85437: LD_VAR 0 3
85441: PUSH
85442: LD_INT 112
85444: EQUAL
85445: IFFALSE 85455
// sStu := true ;
85447: LD_ADDR_EXP 154
85451: PUSH
85452: LD_INT 1
85454: ST_TO_ADDR
// if p3 = 113 then
85455: LD_VAR 0 3
85459: PUSH
85460: LD_INT 113
85462: EQUAL
85463: IFFALSE 85473
// sBazooka := true ;
85465: LD_ADDR_EXP 157
85469: PUSH
85470: LD_INT 1
85472: ST_TO_ADDR
// if p3 = 114 then
85473: LD_VAR 0 3
85477: PUSH
85478: LD_INT 114
85480: EQUAL
85481: IFFALSE 85491
// sMortar := true ;
85483: LD_ADDR_EXP 158
85487: PUSH
85488: LD_INT 1
85490: ST_TO_ADDR
// if p3 = 115 then
85491: LD_VAR 0 3
85495: PUSH
85496: LD_INT 115
85498: EQUAL
85499: IFFALSE 85509
// sRanger := true ;
85501: LD_ADDR_EXP 168
85505: PUSH
85506: LD_INT 1
85508: ST_TO_ADDR
// end ; end ;
85509: PPOPN 6
85511: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
85512: LD_EXP 115
85516: PUSH
85517: LD_EXP 120
85521: AND
85522: IFFALSE 85646
85524: GO 85526
85526: DISABLE
85527: LD_INT 0
85529: PPUSH
85530: PPUSH
// begin enable ;
85531: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
85532: LD_ADDR_VAR 0 2
85536: PUSH
85537: LD_INT 22
85539: PUSH
85540: LD_OWVAR 2
85544: PUSH
85545: EMPTY
85546: LIST
85547: LIST
85548: PUSH
85549: LD_INT 2
85551: PUSH
85552: LD_INT 34
85554: PUSH
85555: LD_INT 7
85557: PUSH
85558: EMPTY
85559: LIST
85560: LIST
85561: PUSH
85562: LD_INT 34
85564: PUSH
85565: LD_INT 45
85567: PUSH
85568: EMPTY
85569: LIST
85570: LIST
85571: PUSH
85572: LD_INT 34
85574: PUSH
85575: LD_INT 28
85577: PUSH
85578: EMPTY
85579: LIST
85580: LIST
85581: PUSH
85582: LD_INT 34
85584: PUSH
85585: LD_INT 47
85587: PUSH
85588: EMPTY
85589: LIST
85590: LIST
85591: PUSH
85592: EMPTY
85593: LIST
85594: LIST
85595: LIST
85596: LIST
85597: LIST
85598: PUSH
85599: EMPTY
85600: LIST
85601: LIST
85602: PPUSH
85603: CALL_OW 69
85607: ST_TO_ADDR
// if not tmp then
85608: LD_VAR 0 2
85612: NOT
85613: IFFALSE 85617
// exit ;
85615: GO 85646
// for i in tmp do
85617: LD_ADDR_VAR 0 1
85621: PUSH
85622: LD_VAR 0 2
85626: PUSH
85627: FOR_IN
85628: IFFALSE 85644
// begin SetLives ( i , 0 ) ;
85630: LD_VAR 0 1
85634: PPUSH
85635: LD_INT 0
85637: PPUSH
85638: CALL_OW 234
// end ;
85642: GO 85627
85644: POP
85645: POP
// end ;
85646: PPOPN 2
85648: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
85649: LD_EXP 115
85653: PUSH
85654: LD_EXP 121
85658: AND
85659: IFFALSE 85743
85661: GO 85663
85663: DISABLE
85664: LD_INT 0
85666: PPUSH
85667: PPUSH
// begin enable ;
85668: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
85669: LD_ADDR_VAR 0 2
85673: PUSH
85674: LD_INT 22
85676: PUSH
85677: LD_OWVAR 2
85681: PUSH
85682: EMPTY
85683: LIST
85684: LIST
85685: PUSH
85686: LD_INT 32
85688: PUSH
85689: LD_INT 3
85691: PUSH
85692: EMPTY
85693: LIST
85694: LIST
85695: PUSH
85696: EMPTY
85697: LIST
85698: LIST
85699: PPUSH
85700: CALL_OW 69
85704: ST_TO_ADDR
// if not tmp then
85705: LD_VAR 0 2
85709: NOT
85710: IFFALSE 85714
// exit ;
85712: GO 85743
// for i in tmp do
85714: LD_ADDR_VAR 0 1
85718: PUSH
85719: LD_VAR 0 2
85723: PUSH
85724: FOR_IN
85725: IFFALSE 85741
// begin SetLives ( i , 0 ) ;
85727: LD_VAR 0 1
85731: PPUSH
85732: LD_INT 0
85734: PPUSH
85735: CALL_OW 234
// end ;
85739: GO 85724
85741: POP
85742: POP
// end ;
85743: PPOPN 2
85745: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
85746: LD_EXP 115
85750: PUSH
85751: LD_EXP 118
85755: AND
85756: IFFALSE 85849
85758: GO 85760
85760: DISABLE
85761: LD_INT 0
85763: PPUSH
// begin enable ;
85764: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
85765: LD_ADDR_VAR 0 1
85769: PUSH
85770: LD_INT 22
85772: PUSH
85773: LD_OWVAR 2
85777: PUSH
85778: EMPTY
85779: LIST
85780: LIST
85781: PUSH
85782: LD_INT 2
85784: PUSH
85785: LD_INT 25
85787: PUSH
85788: LD_INT 5
85790: PUSH
85791: EMPTY
85792: LIST
85793: LIST
85794: PUSH
85795: LD_INT 25
85797: PUSH
85798: LD_INT 9
85800: PUSH
85801: EMPTY
85802: LIST
85803: LIST
85804: PUSH
85805: LD_INT 25
85807: PUSH
85808: LD_INT 8
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: PUSH
85815: EMPTY
85816: LIST
85817: LIST
85818: LIST
85819: LIST
85820: PUSH
85821: EMPTY
85822: LIST
85823: LIST
85824: PPUSH
85825: CALL_OW 69
85829: PUSH
85830: FOR_IN
85831: IFFALSE 85847
// begin SetClass ( i , 1 ) ;
85833: LD_VAR 0 1
85837: PPUSH
85838: LD_INT 1
85840: PPUSH
85841: CALL_OW 336
// end ;
85845: GO 85830
85847: POP
85848: POP
// end ;
85849: PPOPN 1
85851: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
85852: LD_EXP 115
85856: PUSH
85857: LD_EXP 119
85861: AND
85862: PUSH
85863: LD_OWVAR 65
85867: PUSH
85868: LD_INT 7
85870: LESS
85871: AND
85872: IFFALSE 85886
85874: GO 85876
85876: DISABLE
// begin enable ;
85877: ENABLE
// game_speed := 7 ;
85878: LD_ADDR_OWVAR 65
85882: PUSH
85883: LD_INT 7
85885: ST_TO_ADDR
// end ;
85886: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
85887: LD_EXP 115
85891: PUSH
85892: LD_EXP 122
85896: AND
85897: IFFALSE 86099
85899: GO 85901
85901: DISABLE
85902: LD_INT 0
85904: PPUSH
85905: PPUSH
85906: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
85907: LD_ADDR_VAR 0 3
85911: PUSH
85912: LD_INT 81
85914: PUSH
85915: LD_OWVAR 2
85919: PUSH
85920: EMPTY
85921: LIST
85922: LIST
85923: PUSH
85924: LD_INT 21
85926: PUSH
85927: LD_INT 1
85929: PUSH
85930: EMPTY
85931: LIST
85932: LIST
85933: PUSH
85934: EMPTY
85935: LIST
85936: LIST
85937: PPUSH
85938: CALL_OW 69
85942: ST_TO_ADDR
// if not tmp then
85943: LD_VAR 0 3
85947: NOT
85948: IFFALSE 85952
// exit ;
85950: GO 86099
// if tmp > 5 then
85952: LD_VAR 0 3
85956: PUSH
85957: LD_INT 5
85959: GREATER
85960: IFFALSE 85972
// k := 5 else
85962: LD_ADDR_VAR 0 2
85966: PUSH
85967: LD_INT 5
85969: ST_TO_ADDR
85970: GO 85982
// k := tmp ;
85972: LD_ADDR_VAR 0 2
85976: PUSH
85977: LD_VAR 0 3
85981: ST_TO_ADDR
// for i := 1 to k do
85982: LD_ADDR_VAR 0 1
85986: PUSH
85987: DOUBLE
85988: LD_INT 1
85990: DEC
85991: ST_TO_ADDR
85992: LD_VAR 0 2
85996: PUSH
85997: FOR_TO
85998: IFFALSE 86097
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
86000: LD_VAR 0 3
86004: PUSH
86005: LD_VAR 0 1
86009: ARRAY
86010: PPUSH
86011: LD_VAR 0 1
86015: PUSH
86016: LD_INT 4
86018: MOD
86019: PUSH
86020: LD_INT 1
86022: PLUS
86023: PPUSH
86024: CALL_OW 259
86028: PUSH
86029: LD_INT 10
86031: LESS
86032: IFFALSE 86095
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
86034: LD_VAR 0 3
86038: PUSH
86039: LD_VAR 0 1
86043: ARRAY
86044: PPUSH
86045: LD_VAR 0 1
86049: PUSH
86050: LD_INT 4
86052: MOD
86053: PUSH
86054: LD_INT 1
86056: PLUS
86057: PPUSH
86058: LD_VAR 0 3
86062: PUSH
86063: LD_VAR 0 1
86067: ARRAY
86068: PPUSH
86069: LD_VAR 0 1
86073: PUSH
86074: LD_INT 4
86076: MOD
86077: PUSH
86078: LD_INT 1
86080: PLUS
86081: PPUSH
86082: CALL_OW 259
86086: PUSH
86087: LD_INT 1
86089: PLUS
86090: PPUSH
86091: CALL_OW 237
86095: GO 85997
86097: POP
86098: POP
// end ;
86099: PPOPN 3
86101: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
86102: LD_EXP 115
86106: PUSH
86107: LD_EXP 123
86111: AND
86112: IFFALSE 86132
86114: GO 86116
86116: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
86117: LD_INT 4
86119: PPUSH
86120: LD_OWVAR 2
86124: PPUSH
86125: LD_INT 0
86127: PPUSH
86128: CALL_OW 324
86132: END
// every 0 0$1 trigger StreamModeActive and sShovel do
86133: LD_EXP 115
86137: PUSH
86138: LD_EXP 152
86142: AND
86143: IFFALSE 86163
86145: GO 86147
86147: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
86148: LD_INT 19
86150: PPUSH
86151: LD_OWVAR 2
86155: PPUSH
86156: LD_INT 0
86158: PPUSH
86159: CALL_OW 324
86163: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
86164: LD_EXP 115
86168: PUSH
86169: LD_EXP 124
86173: AND
86174: IFFALSE 86276
86176: GO 86178
86178: DISABLE
86179: LD_INT 0
86181: PPUSH
86182: PPUSH
// begin enable ;
86183: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
86184: LD_ADDR_VAR 0 2
86188: PUSH
86189: LD_INT 22
86191: PUSH
86192: LD_OWVAR 2
86196: PUSH
86197: EMPTY
86198: LIST
86199: LIST
86200: PUSH
86201: LD_INT 2
86203: PUSH
86204: LD_INT 34
86206: PUSH
86207: LD_INT 11
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: PUSH
86214: LD_INT 34
86216: PUSH
86217: LD_INT 30
86219: PUSH
86220: EMPTY
86221: LIST
86222: LIST
86223: PUSH
86224: EMPTY
86225: LIST
86226: LIST
86227: LIST
86228: PUSH
86229: EMPTY
86230: LIST
86231: LIST
86232: PPUSH
86233: CALL_OW 69
86237: ST_TO_ADDR
// if not tmp then
86238: LD_VAR 0 2
86242: NOT
86243: IFFALSE 86247
// exit ;
86245: GO 86276
// for i in tmp do
86247: LD_ADDR_VAR 0 1
86251: PUSH
86252: LD_VAR 0 2
86256: PUSH
86257: FOR_IN
86258: IFFALSE 86274
// begin SetLives ( i , 0 ) ;
86260: LD_VAR 0 1
86264: PPUSH
86265: LD_INT 0
86267: PPUSH
86268: CALL_OW 234
// end ;
86272: GO 86257
86274: POP
86275: POP
// end ;
86276: PPOPN 2
86278: END
// every 0 0$1 trigger StreamModeActive and sBunker do
86279: LD_EXP 115
86283: PUSH
86284: LD_EXP 125
86288: AND
86289: IFFALSE 86309
86291: GO 86293
86293: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
86294: LD_INT 32
86296: PPUSH
86297: LD_OWVAR 2
86301: PPUSH
86302: LD_INT 0
86304: PPUSH
86305: CALL_OW 324
86309: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
86310: LD_EXP 115
86314: PUSH
86315: LD_EXP 126
86319: AND
86320: IFFALSE 86501
86322: GO 86324
86324: DISABLE
86325: LD_INT 0
86327: PPUSH
86328: PPUSH
86329: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
86330: LD_ADDR_VAR 0 2
86334: PUSH
86335: LD_INT 22
86337: PUSH
86338: LD_OWVAR 2
86342: PUSH
86343: EMPTY
86344: LIST
86345: LIST
86346: PUSH
86347: LD_INT 33
86349: PUSH
86350: LD_INT 3
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PUSH
86357: EMPTY
86358: LIST
86359: LIST
86360: PPUSH
86361: CALL_OW 69
86365: ST_TO_ADDR
// if not tmp then
86366: LD_VAR 0 2
86370: NOT
86371: IFFALSE 86375
// exit ;
86373: GO 86501
// side := 0 ;
86375: LD_ADDR_VAR 0 3
86379: PUSH
86380: LD_INT 0
86382: ST_TO_ADDR
// for i := 1 to 8 do
86383: LD_ADDR_VAR 0 1
86387: PUSH
86388: DOUBLE
86389: LD_INT 1
86391: DEC
86392: ST_TO_ADDR
86393: LD_INT 8
86395: PUSH
86396: FOR_TO
86397: IFFALSE 86445
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
86399: LD_OWVAR 2
86403: PUSH
86404: LD_VAR 0 1
86408: NONEQUAL
86409: PUSH
86410: LD_OWVAR 2
86414: PPUSH
86415: LD_VAR 0 1
86419: PPUSH
86420: CALL_OW 81
86424: PUSH
86425: LD_INT 2
86427: EQUAL
86428: AND
86429: IFFALSE 86443
// begin side := i ;
86431: LD_ADDR_VAR 0 3
86435: PUSH
86436: LD_VAR 0 1
86440: ST_TO_ADDR
// break ;
86441: GO 86445
// end ;
86443: GO 86396
86445: POP
86446: POP
// if not side then
86447: LD_VAR 0 3
86451: NOT
86452: IFFALSE 86456
// exit ;
86454: GO 86501
// for i := 1 to tmp do
86456: LD_ADDR_VAR 0 1
86460: PUSH
86461: DOUBLE
86462: LD_INT 1
86464: DEC
86465: ST_TO_ADDR
86466: LD_VAR 0 2
86470: PUSH
86471: FOR_TO
86472: IFFALSE 86499
// if Prob ( 60 ) then
86474: LD_INT 60
86476: PPUSH
86477: CALL_OW 13
86481: IFFALSE 86497
// SetSide ( i , side ) ;
86483: LD_VAR 0 1
86487: PPUSH
86488: LD_VAR 0 3
86492: PPUSH
86493: CALL_OW 235
86497: GO 86471
86499: POP
86500: POP
// end ;
86501: PPOPN 3
86503: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
86504: LD_EXP 115
86508: PUSH
86509: LD_EXP 128
86513: AND
86514: IFFALSE 86633
86516: GO 86518
86518: DISABLE
86519: LD_INT 0
86521: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
86522: LD_ADDR_VAR 0 1
86526: PUSH
86527: LD_INT 22
86529: PUSH
86530: LD_OWVAR 2
86534: PUSH
86535: EMPTY
86536: LIST
86537: LIST
86538: PUSH
86539: LD_INT 21
86541: PUSH
86542: LD_INT 1
86544: PUSH
86545: EMPTY
86546: LIST
86547: LIST
86548: PUSH
86549: LD_INT 3
86551: PUSH
86552: LD_INT 23
86554: PUSH
86555: LD_INT 0
86557: PUSH
86558: EMPTY
86559: LIST
86560: LIST
86561: PUSH
86562: EMPTY
86563: LIST
86564: LIST
86565: PUSH
86566: EMPTY
86567: LIST
86568: LIST
86569: LIST
86570: PPUSH
86571: CALL_OW 69
86575: PUSH
86576: FOR_IN
86577: IFFALSE 86631
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
86579: LD_VAR 0 1
86583: PPUSH
86584: CALL_OW 257
86588: PUSH
86589: LD_INT 1
86591: PUSH
86592: LD_INT 2
86594: PUSH
86595: LD_INT 3
86597: PUSH
86598: LD_INT 4
86600: PUSH
86601: EMPTY
86602: LIST
86603: LIST
86604: LIST
86605: LIST
86606: IN
86607: IFFALSE 86629
// SetClass ( un , rand ( 1 , 4 ) ) ;
86609: LD_VAR 0 1
86613: PPUSH
86614: LD_INT 1
86616: PPUSH
86617: LD_INT 4
86619: PPUSH
86620: CALL_OW 12
86624: PPUSH
86625: CALL_OW 336
86629: GO 86576
86631: POP
86632: POP
// end ;
86633: PPOPN 1
86635: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
86636: LD_EXP 115
86640: PUSH
86641: LD_EXP 127
86645: AND
86646: IFFALSE 86725
86648: GO 86650
86650: DISABLE
86651: LD_INT 0
86653: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
86654: LD_ADDR_VAR 0 1
86658: PUSH
86659: LD_INT 22
86661: PUSH
86662: LD_OWVAR 2
86666: PUSH
86667: EMPTY
86668: LIST
86669: LIST
86670: PUSH
86671: LD_INT 21
86673: PUSH
86674: LD_INT 3
86676: PUSH
86677: EMPTY
86678: LIST
86679: LIST
86680: PUSH
86681: EMPTY
86682: LIST
86683: LIST
86684: PPUSH
86685: CALL_OW 69
86689: ST_TO_ADDR
// if not tmp then
86690: LD_VAR 0 1
86694: NOT
86695: IFFALSE 86699
// exit ;
86697: GO 86725
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
86699: LD_VAR 0 1
86703: PUSH
86704: LD_INT 1
86706: PPUSH
86707: LD_VAR 0 1
86711: PPUSH
86712: CALL_OW 12
86716: ARRAY
86717: PPUSH
86718: LD_INT 100
86720: PPUSH
86721: CALL_OW 234
// end ;
86725: PPOPN 1
86727: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
86728: LD_EXP 115
86732: PUSH
86733: LD_EXP 129
86737: AND
86738: IFFALSE 86836
86740: GO 86742
86742: DISABLE
86743: LD_INT 0
86745: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
86746: LD_ADDR_VAR 0 1
86750: PUSH
86751: LD_INT 22
86753: PUSH
86754: LD_OWVAR 2
86758: PUSH
86759: EMPTY
86760: LIST
86761: LIST
86762: PUSH
86763: LD_INT 21
86765: PUSH
86766: LD_INT 1
86768: PUSH
86769: EMPTY
86770: LIST
86771: LIST
86772: PUSH
86773: EMPTY
86774: LIST
86775: LIST
86776: PPUSH
86777: CALL_OW 69
86781: ST_TO_ADDR
// if not tmp then
86782: LD_VAR 0 1
86786: NOT
86787: IFFALSE 86791
// exit ;
86789: GO 86836
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
86791: LD_VAR 0 1
86795: PUSH
86796: LD_INT 1
86798: PPUSH
86799: LD_VAR 0 1
86803: PPUSH
86804: CALL_OW 12
86808: ARRAY
86809: PPUSH
86810: LD_INT 1
86812: PPUSH
86813: LD_INT 4
86815: PPUSH
86816: CALL_OW 12
86820: PPUSH
86821: LD_INT 3000
86823: PPUSH
86824: LD_INT 9000
86826: PPUSH
86827: CALL_OW 12
86831: PPUSH
86832: CALL_OW 492
// end ;
86836: PPOPN 1
86838: END
// every 0 0$1 trigger StreamModeActive and sDepot do
86839: LD_EXP 115
86843: PUSH
86844: LD_EXP 130
86848: AND
86849: IFFALSE 86869
86851: GO 86853
86853: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
86854: LD_INT 1
86856: PPUSH
86857: LD_OWVAR 2
86861: PPUSH
86862: LD_INT 0
86864: PPUSH
86865: CALL_OW 324
86869: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
86870: LD_EXP 115
86874: PUSH
86875: LD_EXP 131
86879: AND
86880: IFFALSE 86963
86882: GO 86884
86884: DISABLE
86885: LD_INT 0
86887: PPUSH
86888: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
86889: LD_ADDR_VAR 0 2
86893: PUSH
86894: LD_INT 22
86896: PUSH
86897: LD_OWVAR 2
86901: PUSH
86902: EMPTY
86903: LIST
86904: LIST
86905: PUSH
86906: LD_INT 21
86908: PUSH
86909: LD_INT 3
86911: PUSH
86912: EMPTY
86913: LIST
86914: LIST
86915: PUSH
86916: EMPTY
86917: LIST
86918: LIST
86919: PPUSH
86920: CALL_OW 69
86924: ST_TO_ADDR
// if not tmp then
86925: LD_VAR 0 2
86929: NOT
86930: IFFALSE 86934
// exit ;
86932: GO 86963
// for i in tmp do
86934: LD_ADDR_VAR 0 1
86938: PUSH
86939: LD_VAR 0 2
86943: PUSH
86944: FOR_IN
86945: IFFALSE 86961
// SetBLevel ( i , 10 ) ;
86947: LD_VAR 0 1
86951: PPUSH
86952: LD_INT 10
86954: PPUSH
86955: CALL_OW 241
86959: GO 86944
86961: POP
86962: POP
// end ;
86963: PPOPN 2
86965: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
86966: LD_EXP 115
86970: PUSH
86971: LD_EXP 132
86975: AND
86976: IFFALSE 87087
86978: GO 86980
86980: DISABLE
86981: LD_INT 0
86983: PPUSH
86984: PPUSH
86985: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
86986: LD_ADDR_VAR 0 3
86990: PUSH
86991: LD_INT 22
86993: PUSH
86994: LD_OWVAR 2
86998: PUSH
86999: EMPTY
87000: LIST
87001: LIST
87002: PUSH
87003: LD_INT 25
87005: PUSH
87006: LD_INT 1
87008: PUSH
87009: EMPTY
87010: LIST
87011: LIST
87012: PUSH
87013: EMPTY
87014: LIST
87015: LIST
87016: PPUSH
87017: CALL_OW 69
87021: ST_TO_ADDR
// if not tmp then
87022: LD_VAR 0 3
87026: NOT
87027: IFFALSE 87031
// exit ;
87029: GO 87087
// un := tmp [ rand ( 1 , tmp ) ] ;
87031: LD_ADDR_VAR 0 2
87035: PUSH
87036: LD_VAR 0 3
87040: PUSH
87041: LD_INT 1
87043: PPUSH
87044: LD_VAR 0 3
87048: PPUSH
87049: CALL_OW 12
87053: ARRAY
87054: ST_TO_ADDR
// if Crawls ( un ) then
87055: LD_VAR 0 2
87059: PPUSH
87060: CALL_OW 318
87064: IFFALSE 87075
// ComWalk ( un ) ;
87066: LD_VAR 0 2
87070: PPUSH
87071: CALL_OW 138
// SetClass ( un , class_sniper ) ;
87075: LD_VAR 0 2
87079: PPUSH
87080: LD_INT 5
87082: PPUSH
87083: CALL_OW 336
// end ;
87087: PPOPN 3
87089: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
87090: LD_EXP 115
87094: PUSH
87095: LD_EXP 133
87099: AND
87100: PUSH
87101: LD_OWVAR 67
87105: PUSH
87106: LD_INT 3
87108: LESS
87109: AND
87110: IFFALSE 87129
87112: GO 87114
87114: DISABLE
// Difficulty := Difficulty + 1 ;
87115: LD_ADDR_OWVAR 67
87119: PUSH
87120: LD_OWVAR 67
87124: PUSH
87125: LD_INT 1
87127: PLUS
87128: ST_TO_ADDR
87129: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
87130: LD_EXP 115
87134: PUSH
87135: LD_EXP 134
87139: AND
87140: IFFALSE 87243
87142: GO 87144
87144: DISABLE
87145: LD_INT 0
87147: PPUSH
// begin for i := 1 to 5 do
87148: LD_ADDR_VAR 0 1
87152: PUSH
87153: DOUBLE
87154: LD_INT 1
87156: DEC
87157: ST_TO_ADDR
87158: LD_INT 5
87160: PUSH
87161: FOR_TO
87162: IFFALSE 87241
// begin uc_nation := nation_nature ;
87164: LD_ADDR_OWVAR 21
87168: PUSH
87169: LD_INT 0
87171: ST_TO_ADDR
// uc_side := 0 ;
87172: LD_ADDR_OWVAR 20
87176: PUSH
87177: LD_INT 0
87179: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
87180: LD_ADDR_OWVAR 29
87184: PUSH
87185: LD_INT 12
87187: PUSH
87188: LD_INT 12
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: ST_TO_ADDR
// hc_agressivity := 20 ;
87195: LD_ADDR_OWVAR 35
87199: PUSH
87200: LD_INT 20
87202: ST_TO_ADDR
// hc_class := class_tiger ;
87203: LD_ADDR_OWVAR 28
87207: PUSH
87208: LD_INT 14
87210: ST_TO_ADDR
// hc_gallery :=  ;
87211: LD_ADDR_OWVAR 33
87215: PUSH
87216: LD_STRING 
87218: ST_TO_ADDR
// hc_name :=  ;
87219: LD_ADDR_OWVAR 26
87223: PUSH
87224: LD_STRING 
87226: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
87227: CALL_OW 44
87231: PPUSH
87232: LD_INT 0
87234: PPUSH
87235: CALL_OW 51
// end ;
87239: GO 87161
87241: POP
87242: POP
// end ;
87243: PPOPN 1
87245: END
// every 0 0$1 trigger StreamModeActive and sBomb do
87246: LD_EXP 115
87250: PUSH
87251: LD_EXP 135
87255: AND
87256: IFFALSE 87265
87258: GO 87260
87260: DISABLE
// StreamSibBomb ;
87261: CALL 87266 0 0
87265: END
// export function StreamSibBomb ; var i , x , y ; begin
87266: LD_INT 0
87268: PPUSH
87269: PPUSH
87270: PPUSH
87271: PPUSH
// result := false ;
87272: LD_ADDR_VAR 0 1
87276: PUSH
87277: LD_INT 0
87279: ST_TO_ADDR
// for i := 1 to 16 do
87280: LD_ADDR_VAR 0 2
87284: PUSH
87285: DOUBLE
87286: LD_INT 1
87288: DEC
87289: ST_TO_ADDR
87290: LD_INT 16
87292: PUSH
87293: FOR_TO
87294: IFFALSE 87493
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
87296: LD_ADDR_VAR 0 3
87300: PUSH
87301: LD_INT 10
87303: PUSH
87304: LD_INT 20
87306: PUSH
87307: LD_INT 30
87309: PUSH
87310: LD_INT 40
87312: PUSH
87313: LD_INT 50
87315: PUSH
87316: LD_INT 60
87318: PUSH
87319: LD_INT 70
87321: PUSH
87322: LD_INT 80
87324: PUSH
87325: LD_INT 90
87327: PUSH
87328: LD_INT 100
87330: PUSH
87331: LD_INT 110
87333: PUSH
87334: LD_INT 120
87336: PUSH
87337: LD_INT 130
87339: PUSH
87340: LD_INT 140
87342: PUSH
87343: LD_INT 150
87345: PUSH
87346: EMPTY
87347: LIST
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: LIST
87361: LIST
87362: PUSH
87363: LD_INT 1
87365: PPUSH
87366: LD_INT 15
87368: PPUSH
87369: CALL_OW 12
87373: ARRAY
87374: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
87375: LD_ADDR_VAR 0 4
87379: PUSH
87380: LD_INT 10
87382: PUSH
87383: LD_INT 20
87385: PUSH
87386: LD_INT 30
87388: PUSH
87389: LD_INT 40
87391: PUSH
87392: LD_INT 50
87394: PUSH
87395: LD_INT 60
87397: PUSH
87398: LD_INT 70
87400: PUSH
87401: LD_INT 80
87403: PUSH
87404: LD_INT 90
87406: PUSH
87407: LD_INT 100
87409: PUSH
87410: LD_INT 110
87412: PUSH
87413: LD_INT 120
87415: PUSH
87416: LD_INT 130
87418: PUSH
87419: LD_INT 140
87421: PUSH
87422: LD_INT 150
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: LIST
87429: LIST
87430: LIST
87431: LIST
87432: LIST
87433: LIST
87434: LIST
87435: LIST
87436: LIST
87437: LIST
87438: LIST
87439: LIST
87440: LIST
87441: PUSH
87442: LD_INT 1
87444: PPUSH
87445: LD_INT 15
87447: PPUSH
87448: CALL_OW 12
87452: ARRAY
87453: ST_TO_ADDR
// if ValidHex ( x , y ) then
87454: LD_VAR 0 3
87458: PPUSH
87459: LD_VAR 0 4
87463: PPUSH
87464: CALL_OW 488
87468: IFFALSE 87491
// begin result := [ x , y ] ;
87470: LD_ADDR_VAR 0 1
87474: PUSH
87475: LD_VAR 0 3
87479: PUSH
87480: LD_VAR 0 4
87484: PUSH
87485: EMPTY
87486: LIST
87487: LIST
87488: ST_TO_ADDR
// break ;
87489: GO 87493
// end ; end ;
87491: GO 87293
87493: POP
87494: POP
// if result then
87495: LD_VAR 0 1
87499: IFFALSE 87559
// begin ToLua ( playSibBomb() ) ;
87501: LD_STRING playSibBomb()
87503: PPUSH
87504: CALL_OW 559
// wait ( 0 0$14 ) ;
87508: LD_INT 490
87510: PPUSH
87511: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
87515: LD_VAR 0 1
87519: PUSH
87520: LD_INT 1
87522: ARRAY
87523: PPUSH
87524: LD_VAR 0 1
87528: PUSH
87529: LD_INT 2
87531: ARRAY
87532: PPUSH
87533: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
87537: LD_VAR 0 1
87541: PUSH
87542: LD_INT 1
87544: ARRAY
87545: PPUSH
87546: LD_VAR 0 1
87550: PUSH
87551: LD_INT 2
87553: ARRAY
87554: PPUSH
87555: CALL_OW 429
// end ; end ;
87559: LD_VAR 0 1
87563: RET
// every 0 0$1 trigger StreamModeActive and sReset do
87564: LD_EXP 115
87568: PUSH
87569: LD_EXP 137
87573: AND
87574: IFFALSE 87586
87576: GO 87578
87578: DISABLE
// YouLost (  ) ;
87579: LD_STRING 
87581: PPUSH
87582: CALL_OW 104
87586: END
// every 0 0$1 trigger StreamModeActive and sFog do
87587: LD_EXP 115
87591: PUSH
87592: LD_EXP 136
87596: AND
87597: IFFALSE 87611
87599: GO 87601
87601: DISABLE
// FogOff ( your_side ) ;
87602: LD_OWVAR 2
87606: PPUSH
87607: CALL_OW 344
87611: END
// every 0 0$1 trigger StreamModeActive and sSun do
87612: LD_EXP 115
87616: PUSH
87617: LD_EXP 138
87621: AND
87622: IFFALSE 87650
87624: GO 87626
87626: DISABLE
// begin solar_recharge_percent := 0 ;
87627: LD_ADDR_OWVAR 79
87631: PUSH
87632: LD_INT 0
87634: ST_TO_ADDR
// wait ( 5 5$00 ) ;
87635: LD_INT 10500
87637: PPUSH
87638: CALL_OW 67
// solar_recharge_percent := 100 ;
87642: LD_ADDR_OWVAR 79
87646: PUSH
87647: LD_INT 100
87649: ST_TO_ADDR
// end ;
87650: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
87651: LD_EXP 115
87655: PUSH
87656: LD_EXP 139
87660: AND
87661: IFFALSE 87900
87663: GO 87665
87665: DISABLE
87666: LD_INT 0
87668: PPUSH
87669: PPUSH
87670: PPUSH
// begin tmp := [ ] ;
87671: LD_ADDR_VAR 0 3
87675: PUSH
87676: EMPTY
87677: ST_TO_ADDR
// for i := 1 to 6 do
87678: LD_ADDR_VAR 0 1
87682: PUSH
87683: DOUBLE
87684: LD_INT 1
87686: DEC
87687: ST_TO_ADDR
87688: LD_INT 6
87690: PUSH
87691: FOR_TO
87692: IFFALSE 87797
// begin uc_nation := nation_nature ;
87694: LD_ADDR_OWVAR 21
87698: PUSH
87699: LD_INT 0
87701: ST_TO_ADDR
// uc_side := 0 ;
87702: LD_ADDR_OWVAR 20
87706: PUSH
87707: LD_INT 0
87709: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
87710: LD_ADDR_OWVAR 29
87714: PUSH
87715: LD_INT 12
87717: PUSH
87718: LD_INT 12
87720: PUSH
87721: EMPTY
87722: LIST
87723: LIST
87724: ST_TO_ADDR
// hc_agressivity := 20 ;
87725: LD_ADDR_OWVAR 35
87729: PUSH
87730: LD_INT 20
87732: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
87733: LD_ADDR_OWVAR 28
87737: PUSH
87738: LD_INT 17
87740: ST_TO_ADDR
// hc_gallery :=  ;
87741: LD_ADDR_OWVAR 33
87745: PUSH
87746: LD_STRING 
87748: ST_TO_ADDR
// hc_name :=  ;
87749: LD_ADDR_OWVAR 26
87753: PUSH
87754: LD_STRING 
87756: ST_TO_ADDR
// un := CreateHuman ;
87757: LD_ADDR_VAR 0 2
87761: PUSH
87762: CALL_OW 44
87766: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
87767: LD_VAR 0 2
87771: PPUSH
87772: LD_INT 1
87774: PPUSH
87775: CALL_OW 51
// tmp := tmp ^ un ;
87779: LD_ADDR_VAR 0 3
87783: PUSH
87784: LD_VAR 0 3
87788: PUSH
87789: LD_VAR 0 2
87793: ADD
87794: ST_TO_ADDR
// end ;
87795: GO 87691
87797: POP
87798: POP
// repeat wait ( 0 0$1 ) ;
87799: LD_INT 35
87801: PPUSH
87802: CALL_OW 67
// for un in tmp do
87806: LD_ADDR_VAR 0 2
87810: PUSH
87811: LD_VAR 0 3
87815: PUSH
87816: FOR_IN
87817: IFFALSE 87891
// begin if IsDead ( un ) then
87819: LD_VAR 0 2
87823: PPUSH
87824: CALL_OW 301
87828: IFFALSE 87848
// begin tmp := tmp diff un ;
87830: LD_ADDR_VAR 0 3
87834: PUSH
87835: LD_VAR 0 3
87839: PUSH
87840: LD_VAR 0 2
87844: DIFF
87845: ST_TO_ADDR
// continue ;
87846: GO 87816
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
87848: LD_VAR 0 2
87852: PPUSH
87853: LD_INT 3
87855: PUSH
87856: LD_INT 22
87858: PUSH
87859: LD_INT 0
87861: PUSH
87862: EMPTY
87863: LIST
87864: LIST
87865: PUSH
87866: EMPTY
87867: LIST
87868: LIST
87869: PPUSH
87870: CALL_OW 69
87874: PPUSH
87875: LD_VAR 0 2
87879: PPUSH
87880: CALL_OW 74
87884: PPUSH
87885: CALL_OW 115
// end ;
87889: GO 87816
87891: POP
87892: POP
// until not tmp ;
87893: LD_VAR 0 3
87897: NOT
87898: IFFALSE 87799
// end ;
87900: PPOPN 3
87902: END
// every 0 0$1 trigger StreamModeActive and sTroll do
87903: LD_EXP 115
87907: PUSH
87908: LD_EXP 140
87912: AND
87913: IFFALSE 87967
87915: GO 87917
87917: DISABLE
// begin ToLua ( displayTroll(); ) ;
87918: LD_STRING displayTroll();
87920: PPUSH
87921: CALL_OW 559
// wait ( 3 3$00 ) ;
87925: LD_INT 6300
87927: PPUSH
87928: CALL_OW 67
// ToLua ( hideTroll(); ) ;
87932: LD_STRING hideTroll();
87934: PPUSH
87935: CALL_OW 559
// wait ( 1 1$00 ) ;
87939: LD_INT 2100
87941: PPUSH
87942: CALL_OW 67
// ToLua ( displayTroll(); ) ;
87946: LD_STRING displayTroll();
87948: PPUSH
87949: CALL_OW 559
// wait ( 1 1$00 ) ;
87953: LD_INT 2100
87955: PPUSH
87956: CALL_OW 67
// ToLua ( hideTroll(); ) ;
87960: LD_STRING hideTroll();
87962: PPUSH
87963: CALL_OW 559
// end ;
87967: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
87968: LD_EXP 115
87972: PUSH
87973: LD_EXP 141
87977: AND
87978: IFFALSE 88041
87980: GO 87982
87982: DISABLE
87983: LD_INT 0
87985: PPUSH
// begin p := 0 ;
87986: LD_ADDR_VAR 0 1
87990: PUSH
87991: LD_INT 0
87993: ST_TO_ADDR
// repeat game_speed := 1 ;
87994: LD_ADDR_OWVAR 65
87998: PUSH
87999: LD_INT 1
88001: ST_TO_ADDR
// wait ( 0 0$1 ) ;
88002: LD_INT 35
88004: PPUSH
88005: CALL_OW 67
// p := p + 1 ;
88009: LD_ADDR_VAR 0 1
88013: PUSH
88014: LD_VAR 0 1
88018: PUSH
88019: LD_INT 1
88021: PLUS
88022: ST_TO_ADDR
// until p >= 60 ;
88023: LD_VAR 0 1
88027: PUSH
88028: LD_INT 60
88030: GREATEREQUAL
88031: IFFALSE 87994
// game_speed := 4 ;
88033: LD_ADDR_OWVAR 65
88037: PUSH
88038: LD_INT 4
88040: ST_TO_ADDR
// end ;
88041: PPOPN 1
88043: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
88044: LD_EXP 115
88048: PUSH
88049: LD_EXP 142
88053: AND
88054: IFFALSE 88200
88056: GO 88058
88058: DISABLE
88059: LD_INT 0
88061: PPUSH
88062: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
88063: LD_ADDR_VAR 0 1
88067: PUSH
88068: LD_INT 22
88070: PUSH
88071: LD_OWVAR 2
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: PUSH
88080: LD_INT 2
88082: PUSH
88083: LD_INT 30
88085: PUSH
88086: LD_INT 0
88088: PUSH
88089: EMPTY
88090: LIST
88091: LIST
88092: PUSH
88093: LD_INT 30
88095: PUSH
88096: LD_INT 1
88098: PUSH
88099: EMPTY
88100: LIST
88101: LIST
88102: PUSH
88103: EMPTY
88104: LIST
88105: LIST
88106: LIST
88107: PUSH
88108: EMPTY
88109: LIST
88110: LIST
88111: PPUSH
88112: CALL_OW 69
88116: ST_TO_ADDR
// if not depot then
88117: LD_VAR 0 1
88121: NOT
88122: IFFALSE 88126
// exit ;
88124: GO 88200
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
88126: LD_ADDR_VAR 0 2
88130: PUSH
88131: LD_VAR 0 1
88135: PUSH
88136: LD_INT 1
88138: PPUSH
88139: LD_VAR 0 1
88143: PPUSH
88144: CALL_OW 12
88148: ARRAY
88149: PPUSH
88150: CALL_OW 274
88154: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
88155: LD_VAR 0 2
88159: PPUSH
88160: LD_INT 1
88162: PPUSH
88163: LD_INT 0
88165: PPUSH
88166: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
88170: LD_VAR 0 2
88174: PPUSH
88175: LD_INT 2
88177: PPUSH
88178: LD_INT 0
88180: PPUSH
88181: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
88185: LD_VAR 0 2
88189: PPUSH
88190: LD_INT 3
88192: PPUSH
88193: LD_INT 0
88195: PPUSH
88196: CALL_OW 277
// end ;
88200: PPOPN 2
88202: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
88203: LD_EXP 115
88207: PUSH
88208: LD_EXP 143
88212: AND
88213: IFFALSE 88310
88215: GO 88217
88217: DISABLE
88218: LD_INT 0
88220: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
88221: LD_ADDR_VAR 0 1
88225: PUSH
88226: LD_INT 22
88228: PUSH
88229: LD_OWVAR 2
88233: PUSH
88234: EMPTY
88235: LIST
88236: LIST
88237: PUSH
88238: LD_INT 21
88240: PUSH
88241: LD_INT 1
88243: PUSH
88244: EMPTY
88245: LIST
88246: LIST
88247: PUSH
88248: LD_INT 3
88250: PUSH
88251: LD_INT 23
88253: PUSH
88254: LD_INT 0
88256: PUSH
88257: EMPTY
88258: LIST
88259: LIST
88260: PUSH
88261: EMPTY
88262: LIST
88263: LIST
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: LIST
88269: PPUSH
88270: CALL_OW 69
88274: ST_TO_ADDR
// if not tmp then
88275: LD_VAR 0 1
88279: NOT
88280: IFFALSE 88284
// exit ;
88282: GO 88310
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
88284: LD_VAR 0 1
88288: PUSH
88289: LD_INT 1
88291: PPUSH
88292: LD_VAR 0 1
88296: PPUSH
88297: CALL_OW 12
88301: ARRAY
88302: PPUSH
88303: LD_INT 200
88305: PPUSH
88306: CALL_OW 234
// end ;
88310: PPOPN 1
88312: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
88313: LD_EXP 115
88317: PUSH
88318: LD_EXP 144
88322: AND
88323: IFFALSE 88402
88325: GO 88327
88327: DISABLE
88328: LD_INT 0
88330: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
88331: LD_ADDR_VAR 0 1
88335: PUSH
88336: LD_INT 22
88338: PUSH
88339: LD_OWVAR 2
88343: PUSH
88344: EMPTY
88345: LIST
88346: LIST
88347: PUSH
88348: LD_INT 21
88350: PUSH
88351: LD_INT 2
88353: PUSH
88354: EMPTY
88355: LIST
88356: LIST
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PPUSH
88362: CALL_OW 69
88366: ST_TO_ADDR
// if not tmp then
88367: LD_VAR 0 1
88371: NOT
88372: IFFALSE 88376
// exit ;
88374: GO 88402
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
88376: LD_VAR 0 1
88380: PUSH
88381: LD_INT 1
88383: PPUSH
88384: LD_VAR 0 1
88388: PPUSH
88389: CALL_OW 12
88393: ARRAY
88394: PPUSH
88395: LD_INT 60
88397: PPUSH
88398: CALL_OW 234
// end ;
88402: PPOPN 1
88404: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
88405: LD_EXP 115
88409: PUSH
88410: LD_EXP 145
88414: AND
88415: IFFALSE 88514
88417: GO 88419
88419: DISABLE
88420: LD_INT 0
88422: PPUSH
88423: PPUSH
// begin enable ;
88424: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
88425: LD_ADDR_VAR 0 1
88429: PUSH
88430: LD_INT 22
88432: PUSH
88433: LD_OWVAR 2
88437: PUSH
88438: EMPTY
88439: LIST
88440: LIST
88441: PUSH
88442: LD_INT 61
88444: PUSH
88445: EMPTY
88446: LIST
88447: PUSH
88448: LD_INT 33
88450: PUSH
88451: LD_INT 2
88453: PUSH
88454: EMPTY
88455: LIST
88456: LIST
88457: PUSH
88458: EMPTY
88459: LIST
88460: LIST
88461: LIST
88462: PPUSH
88463: CALL_OW 69
88467: ST_TO_ADDR
// if not tmp then
88468: LD_VAR 0 1
88472: NOT
88473: IFFALSE 88477
// exit ;
88475: GO 88514
// for i in tmp do
88477: LD_ADDR_VAR 0 2
88481: PUSH
88482: LD_VAR 0 1
88486: PUSH
88487: FOR_IN
88488: IFFALSE 88512
// if IsControledBy ( i ) then
88490: LD_VAR 0 2
88494: PPUSH
88495: CALL_OW 312
88499: IFFALSE 88510
// ComUnlink ( i ) ;
88501: LD_VAR 0 2
88505: PPUSH
88506: CALL_OW 136
88510: GO 88487
88512: POP
88513: POP
// end ;
88514: PPOPN 2
88516: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
88517: LD_EXP 115
88521: PUSH
88522: LD_EXP 146
88526: AND
88527: IFFALSE 88667
88529: GO 88531
88531: DISABLE
88532: LD_INT 0
88534: PPUSH
88535: PPUSH
// begin ToLua ( displayPowell(); ) ;
88536: LD_STRING displayPowell();
88538: PPUSH
88539: CALL_OW 559
// uc_side := 0 ;
88543: LD_ADDR_OWVAR 20
88547: PUSH
88548: LD_INT 0
88550: ST_TO_ADDR
// uc_nation := 2 ;
88551: LD_ADDR_OWVAR 21
88555: PUSH
88556: LD_INT 2
88558: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
88559: LD_ADDR_OWVAR 37
88563: PUSH
88564: LD_INT 14
88566: ST_TO_ADDR
// vc_engine := engine_siberite ;
88567: LD_ADDR_OWVAR 39
88571: PUSH
88572: LD_INT 3
88574: ST_TO_ADDR
// vc_control := control_apeman ;
88575: LD_ADDR_OWVAR 38
88579: PUSH
88580: LD_INT 5
88582: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
88583: LD_ADDR_OWVAR 40
88587: PUSH
88588: LD_INT 29
88590: ST_TO_ADDR
// un := CreateVehicle ;
88591: LD_ADDR_VAR 0 2
88595: PUSH
88596: CALL_OW 45
88600: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
88601: LD_VAR 0 2
88605: PPUSH
88606: LD_INT 1
88608: PPUSH
88609: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
88613: LD_INT 35
88615: PPUSH
88616: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
88620: LD_VAR 0 2
88624: PPUSH
88625: LD_INT 22
88627: PUSH
88628: LD_OWVAR 2
88632: PUSH
88633: EMPTY
88634: LIST
88635: LIST
88636: PPUSH
88637: CALL_OW 69
88641: PPUSH
88642: LD_VAR 0 2
88646: PPUSH
88647: CALL_OW 74
88651: PPUSH
88652: CALL_OW 115
// until IsDead ( un ) ;
88656: LD_VAR 0 2
88660: PPUSH
88661: CALL_OW 301
88665: IFFALSE 88613
// end ;
88667: PPOPN 2
88669: END
// every 0 0$1 trigger StreamModeActive and sStu do
88670: LD_EXP 115
88674: PUSH
88675: LD_EXP 154
88679: AND
88680: IFFALSE 88696
88682: GO 88684
88684: DISABLE
// begin ToLua ( displayStucuk(); ) ;
88685: LD_STRING displayStucuk();
88687: PPUSH
88688: CALL_OW 559
// ResetFog ;
88692: CALL_OW 335
// end ;
88696: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
88697: LD_EXP 115
88701: PUSH
88702: LD_EXP 147
88706: AND
88707: IFFALSE 88848
88709: GO 88711
88711: DISABLE
88712: LD_INT 0
88714: PPUSH
88715: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
88716: LD_ADDR_VAR 0 2
88720: PUSH
88721: LD_INT 22
88723: PUSH
88724: LD_OWVAR 2
88728: PUSH
88729: EMPTY
88730: LIST
88731: LIST
88732: PUSH
88733: LD_INT 21
88735: PUSH
88736: LD_INT 1
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: PUSH
88743: EMPTY
88744: LIST
88745: LIST
88746: PPUSH
88747: CALL_OW 69
88751: ST_TO_ADDR
// if not tmp then
88752: LD_VAR 0 2
88756: NOT
88757: IFFALSE 88761
// exit ;
88759: GO 88848
// un := tmp [ rand ( 1 , tmp ) ] ;
88761: LD_ADDR_VAR 0 1
88765: PUSH
88766: LD_VAR 0 2
88770: PUSH
88771: LD_INT 1
88773: PPUSH
88774: LD_VAR 0 2
88778: PPUSH
88779: CALL_OW 12
88783: ARRAY
88784: ST_TO_ADDR
// SetSide ( un , 0 ) ;
88785: LD_VAR 0 1
88789: PPUSH
88790: LD_INT 0
88792: PPUSH
88793: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
88797: LD_VAR 0 1
88801: PPUSH
88802: LD_OWVAR 3
88806: PUSH
88807: LD_VAR 0 1
88811: DIFF
88812: PPUSH
88813: LD_VAR 0 1
88817: PPUSH
88818: CALL_OW 74
88822: PPUSH
88823: CALL_OW 115
// wait ( 0 0$20 ) ;
88827: LD_INT 700
88829: PPUSH
88830: CALL_OW 67
// SetSide ( un , your_side ) ;
88834: LD_VAR 0 1
88838: PPUSH
88839: LD_OWVAR 2
88843: PPUSH
88844: CALL_OW 235
// end ;
88848: PPOPN 2
88850: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
88851: LD_EXP 115
88855: PUSH
88856: LD_EXP 148
88860: AND
88861: IFFALSE 88967
88863: GO 88865
88865: DISABLE
88866: LD_INT 0
88868: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
88869: LD_ADDR_VAR 0 1
88873: PUSH
88874: LD_INT 22
88876: PUSH
88877: LD_OWVAR 2
88881: PUSH
88882: EMPTY
88883: LIST
88884: LIST
88885: PUSH
88886: LD_INT 2
88888: PUSH
88889: LD_INT 30
88891: PUSH
88892: LD_INT 0
88894: PUSH
88895: EMPTY
88896: LIST
88897: LIST
88898: PUSH
88899: LD_INT 30
88901: PUSH
88902: LD_INT 1
88904: PUSH
88905: EMPTY
88906: LIST
88907: LIST
88908: PUSH
88909: EMPTY
88910: LIST
88911: LIST
88912: LIST
88913: PUSH
88914: EMPTY
88915: LIST
88916: LIST
88917: PPUSH
88918: CALL_OW 69
88922: ST_TO_ADDR
// if not depot then
88923: LD_VAR 0 1
88927: NOT
88928: IFFALSE 88932
// exit ;
88930: GO 88967
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
88932: LD_VAR 0 1
88936: PUSH
88937: LD_INT 1
88939: ARRAY
88940: PPUSH
88941: CALL_OW 250
88945: PPUSH
88946: LD_VAR 0 1
88950: PUSH
88951: LD_INT 1
88953: ARRAY
88954: PPUSH
88955: CALL_OW 251
88959: PPUSH
88960: LD_INT 70
88962: PPUSH
88963: CALL_OW 495
// end ;
88967: PPOPN 1
88969: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
88970: LD_EXP 115
88974: PUSH
88975: LD_EXP 149
88979: AND
88980: IFFALSE 89191
88982: GO 88984
88984: DISABLE
88985: LD_INT 0
88987: PPUSH
88988: PPUSH
88989: PPUSH
88990: PPUSH
88991: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
88992: LD_ADDR_VAR 0 5
88996: PUSH
88997: LD_INT 22
88999: PUSH
89000: LD_OWVAR 2
89004: PUSH
89005: EMPTY
89006: LIST
89007: LIST
89008: PUSH
89009: LD_INT 21
89011: PUSH
89012: LD_INT 1
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: PUSH
89019: EMPTY
89020: LIST
89021: LIST
89022: PPUSH
89023: CALL_OW 69
89027: ST_TO_ADDR
// if not tmp then
89028: LD_VAR 0 5
89032: NOT
89033: IFFALSE 89037
// exit ;
89035: GO 89191
// for i in tmp do
89037: LD_ADDR_VAR 0 1
89041: PUSH
89042: LD_VAR 0 5
89046: PUSH
89047: FOR_IN
89048: IFFALSE 89189
// begin d := rand ( 0 , 5 ) ;
89050: LD_ADDR_VAR 0 4
89054: PUSH
89055: LD_INT 0
89057: PPUSH
89058: LD_INT 5
89060: PPUSH
89061: CALL_OW 12
89065: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
89066: LD_ADDR_VAR 0 2
89070: PUSH
89071: LD_VAR 0 1
89075: PPUSH
89076: CALL_OW 250
89080: PPUSH
89081: LD_VAR 0 4
89085: PPUSH
89086: LD_INT 3
89088: PPUSH
89089: LD_INT 12
89091: PPUSH
89092: CALL_OW 12
89096: PPUSH
89097: CALL_OW 272
89101: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
89102: LD_ADDR_VAR 0 3
89106: PUSH
89107: LD_VAR 0 1
89111: PPUSH
89112: CALL_OW 251
89116: PPUSH
89117: LD_VAR 0 4
89121: PPUSH
89122: LD_INT 3
89124: PPUSH
89125: LD_INT 12
89127: PPUSH
89128: CALL_OW 12
89132: PPUSH
89133: CALL_OW 273
89137: ST_TO_ADDR
// if ValidHex ( x , y ) then
89138: LD_VAR 0 2
89142: PPUSH
89143: LD_VAR 0 3
89147: PPUSH
89148: CALL_OW 488
89152: IFFALSE 89187
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
89154: LD_VAR 0 1
89158: PPUSH
89159: LD_VAR 0 2
89163: PPUSH
89164: LD_VAR 0 3
89168: PPUSH
89169: LD_INT 3
89171: PPUSH
89172: LD_INT 6
89174: PPUSH
89175: CALL_OW 12
89179: PPUSH
89180: LD_INT 1
89182: PPUSH
89183: CALL_OW 483
// end ;
89187: GO 89047
89189: POP
89190: POP
// end ;
89191: PPOPN 5
89193: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
89194: LD_EXP 115
89198: PUSH
89199: LD_EXP 150
89203: AND
89204: IFFALSE 89298
89206: GO 89208
89208: DISABLE
89209: LD_INT 0
89211: PPUSH
89212: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
89213: LD_ADDR_VAR 0 2
89217: PUSH
89218: LD_INT 22
89220: PUSH
89221: LD_OWVAR 2
89225: PUSH
89226: EMPTY
89227: LIST
89228: LIST
89229: PUSH
89230: LD_INT 32
89232: PUSH
89233: LD_INT 1
89235: PUSH
89236: EMPTY
89237: LIST
89238: LIST
89239: PUSH
89240: LD_INT 21
89242: PUSH
89243: LD_INT 2
89245: PUSH
89246: EMPTY
89247: LIST
89248: LIST
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: LIST
89254: PPUSH
89255: CALL_OW 69
89259: ST_TO_ADDR
// if not tmp then
89260: LD_VAR 0 2
89264: NOT
89265: IFFALSE 89269
// exit ;
89267: GO 89298
// for i in tmp do
89269: LD_ADDR_VAR 0 1
89273: PUSH
89274: LD_VAR 0 2
89278: PUSH
89279: FOR_IN
89280: IFFALSE 89296
// SetFuel ( i , 0 ) ;
89282: LD_VAR 0 1
89286: PPUSH
89287: LD_INT 0
89289: PPUSH
89290: CALL_OW 240
89294: GO 89279
89296: POP
89297: POP
// end ;
89298: PPOPN 2
89300: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
89301: LD_EXP 115
89305: PUSH
89306: LD_EXP 151
89310: AND
89311: IFFALSE 89377
89313: GO 89315
89315: DISABLE
89316: LD_INT 0
89318: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
89319: LD_ADDR_VAR 0 1
89323: PUSH
89324: LD_INT 22
89326: PUSH
89327: LD_OWVAR 2
89331: PUSH
89332: EMPTY
89333: LIST
89334: LIST
89335: PUSH
89336: LD_INT 30
89338: PUSH
89339: LD_INT 29
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PUSH
89346: EMPTY
89347: LIST
89348: LIST
89349: PPUSH
89350: CALL_OW 69
89354: ST_TO_ADDR
// if not tmp then
89355: LD_VAR 0 1
89359: NOT
89360: IFFALSE 89364
// exit ;
89362: GO 89377
// DestroyUnit ( tmp [ 1 ] ) ;
89364: LD_VAR 0 1
89368: PUSH
89369: LD_INT 1
89371: ARRAY
89372: PPUSH
89373: CALL_OW 65
// end ;
89377: PPOPN 1
89379: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
89380: LD_EXP 115
89384: PUSH
89385: LD_EXP 153
89389: AND
89390: IFFALSE 89519
89392: GO 89394
89394: DISABLE
89395: LD_INT 0
89397: PPUSH
// begin uc_side := 0 ;
89398: LD_ADDR_OWVAR 20
89402: PUSH
89403: LD_INT 0
89405: ST_TO_ADDR
// uc_nation := nation_arabian ;
89406: LD_ADDR_OWVAR 21
89410: PUSH
89411: LD_INT 2
89413: ST_TO_ADDR
// hc_gallery :=  ;
89414: LD_ADDR_OWVAR 33
89418: PUSH
89419: LD_STRING 
89421: ST_TO_ADDR
// hc_name :=  ;
89422: LD_ADDR_OWVAR 26
89426: PUSH
89427: LD_STRING 
89429: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
89430: LD_INT 1
89432: PPUSH
89433: LD_INT 11
89435: PPUSH
89436: LD_INT 10
89438: PPUSH
89439: CALL_OW 380
// un := CreateHuman ;
89443: LD_ADDR_VAR 0 1
89447: PUSH
89448: CALL_OW 44
89452: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
89453: LD_VAR 0 1
89457: PPUSH
89458: LD_INT 1
89460: PPUSH
89461: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
89465: LD_INT 35
89467: PPUSH
89468: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
89472: LD_VAR 0 1
89476: PPUSH
89477: LD_INT 22
89479: PUSH
89480: LD_OWVAR 2
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: PPUSH
89489: CALL_OW 69
89493: PPUSH
89494: LD_VAR 0 1
89498: PPUSH
89499: CALL_OW 74
89503: PPUSH
89504: CALL_OW 115
// until IsDead ( un ) ;
89508: LD_VAR 0 1
89512: PPUSH
89513: CALL_OW 301
89517: IFFALSE 89465
// end ;
89519: PPOPN 1
89521: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
89522: LD_EXP 115
89526: PUSH
89527: LD_EXP 155
89531: AND
89532: IFFALSE 89544
89534: GO 89536
89536: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
89537: LD_STRING earthquake(getX(game), 0, 32)
89539: PPUSH
89540: CALL_OW 559
89544: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
89545: LD_EXP 115
89549: PUSH
89550: LD_EXP 156
89554: AND
89555: IFFALSE 89646
89557: GO 89559
89559: DISABLE
89560: LD_INT 0
89562: PPUSH
// begin enable ;
89563: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
89564: LD_ADDR_VAR 0 1
89568: PUSH
89569: LD_INT 22
89571: PUSH
89572: LD_OWVAR 2
89576: PUSH
89577: EMPTY
89578: LIST
89579: LIST
89580: PUSH
89581: LD_INT 21
89583: PUSH
89584: LD_INT 2
89586: PUSH
89587: EMPTY
89588: LIST
89589: LIST
89590: PUSH
89591: LD_INT 33
89593: PUSH
89594: LD_INT 3
89596: PUSH
89597: EMPTY
89598: LIST
89599: LIST
89600: PUSH
89601: EMPTY
89602: LIST
89603: LIST
89604: LIST
89605: PPUSH
89606: CALL_OW 69
89610: ST_TO_ADDR
// if not tmp then
89611: LD_VAR 0 1
89615: NOT
89616: IFFALSE 89620
// exit ;
89618: GO 89646
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
89620: LD_VAR 0 1
89624: PUSH
89625: LD_INT 1
89627: PPUSH
89628: LD_VAR 0 1
89632: PPUSH
89633: CALL_OW 12
89637: ARRAY
89638: PPUSH
89639: LD_INT 1
89641: PPUSH
89642: CALL_OW 234
// end ;
89646: PPOPN 1
89648: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
89649: LD_EXP 115
89653: PUSH
89654: LD_EXP 157
89658: AND
89659: IFFALSE 89800
89661: GO 89663
89663: DISABLE
89664: LD_INT 0
89666: PPUSH
89667: PPUSH
89668: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
89669: LD_ADDR_VAR 0 3
89673: PUSH
89674: LD_INT 22
89676: PUSH
89677: LD_OWVAR 2
89681: PUSH
89682: EMPTY
89683: LIST
89684: LIST
89685: PUSH
89686: LD_INT 25
89688: PUSH
89689: LD_INT 1
89691: PUSH
89692: EMPTY
89693: LIST
89694: LIST
89695: PUSH
89696: EMPTY
89697: LIST
89698: LIST
89699: PPUSH
89700: CALL_OW 69
89704: ST_TO_ADDR
// if not tmp then
89705: LD_VAR 0 3
89709: NOT
89710: IFFALSE 89714
// exit ;
89712: GO 89800
// un := tmp [ rand ( 1 , tmp ) ] ;
89714: LD_ADDR_VAR 0 2
89718: PUSH
89719: LD_VAR 0 3
89723: PUSH
89724: LD_INT 1
89726: PPUSH
89727: LD_VAR 0 3
89731: PPUSH
89732: CALL_OW 12
89736: ARRAY
89737: ST_TO_ADDR
// if Crawls ( un ) then
89738: LD_VAR 0 2
89742: PPUSH
89743: CALL_OW 318
89747: IFFALSE 89758
// ComWalk ( un ) ;
89749: LD_VAR 0 2
89753: PPUSH
89754: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
89758: LD_VAR 0 2
89762: PPUSH
89763: LD_INT 9
89765: PPUSH
89766: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
89770: LD_INT 28
89772: PPUSH
89773: LD_OWVAR 2
89777: PPUSH
89778: LD_INT 2
89780: PPUSH
89781: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
89785: LD_INT 29
89787: PPUSH
89788: LD_OWVAR 2
89792: PPUSH
89793: LD_INT 2
89795: PPUSH
89796: CALL_OW 322
// end ;
89800: PPOPN 3
89802: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
89803: LD_EXP 115
89807: PUSH
89808: LD_EXP 158
89812: AND
89813: IFFALSE 89924
89815: GO 89817
89817: DISABLE
89818: LD_INT 0
89820: PPUSH
89821: PPUSH
89822: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
89823: LD_ADDR_VAR 0 3
89827: PUSH
89828: LD_INT 22
89830: PUSH
89831: LD_OWVAR 2
89835: PUSH
89836: EMPTY
89837: LIST
89838: LIST
89839: PUSH
89840: LD_INT 25
89842: PUSH
89843: LD_INT 1
89845: PUSH
89846: EMPTY
89847: LIST
89848: LIST
89849: PUSH
89850: EMPTY
89851: LIST
89852: LIST
89853: PPUSH
89854: CALL_OW 69
89858: ST_TO_ADDR
// if not tmp then
89859: LD_VAR 0 3
89863: NOT
89864: IFFALSE 89868
// exit ;
89866: GO 89924
// un := tmp [ rand ( 1 , tmp ) ] ;
89868: LD_ADDR_VAR 0 2
89872: PUSH
89873: LD_VAR 0 3
89877: PUSH
89878: LD_INT 1
89880: PPUSH
89881: LD_VAR 0 3
89885: PPUSH
89886: CALL_OW 12
89890: ARRAY
89891: ST_TO_ADDR
// if Crawls ( un ) then
89892: LD_VAR 0 2
89896: PPUSH
89897: CALL_OW 318
89901: IFFALSE 89912
// ComWalk ( un ) ;
89903: LD_VAR 0 2
89907: PPUSH
89908: CALL_OW 138
// SetClass ( un , class_mortar ) ;
89912: LD_VAR 0 2
89916: PPUSH
89917: LD_INT 8
89919: PPUSH
89920: CALL_OW 336
// end ;
89924: PPOPN 3
89926: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
89927: LD_EXP 115
89931: PUSH
89932: LD_EXP 159
89936: AND
89937: IFFALSE 90081
89939: GO 89941
89941: DISABLE
89942: LD_INT 0
89944: PPUSH
89945: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
89946: LD_ADDR_VAR 0 2
89950: PUSH
89951: LD_INT 22
89953: PUSH
89954: LD_OWVAR 2
89958: PUSH
89959: EMPTY
89960: LIST
89961: LIST
89962: PUSH
89963: LD_INT 21
89965: PUSH
89966: LD_INT 2
89968: PUSH
89969: EMPTY
89970: LIST
89971: LIST
89972: PUSH
89973: LD_INT 2
89975: PUSH
89976: LD_INT 34
89978: PUSH
89979: LD_INT 12
89981: PUSH
89982: EMPTY
89983: LIST
89984: LIST
89985: PUSH
89986: LD_INT 34
89988: PUSH
89989: LD_INT 51
89991: PUSH
89992: EMPTY
89993: LIST
89994: LIST
89995: PUSH
89996: LD_INT 34
89998: PUSH
89999: LD_INT 32
90001: PUSH
90002: EMPTY
90003: LIST
90004: LIST
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: LIST
90010: LIST
90011: PUSH
90012: EMPTY
90013: LIST
90014: LIST
90015: LIST
90016: PPUSH
90017: CALL_OW 69
90021: ST_TO_ADDR
// if not tmp then
90022: LD_VAR 0 2
90026: NOT
90027: IFFALSE 90031
// exit ;
90029: GO 90081
// for i in tmp do
90031: LD_ADDR_VAR 0 1
90035: PUSH
90036: LD_VAR 0 2
90040: PUSH
90041: FOR_IN
90042: IFFALSE 90079
// if GetCargo ( i , mat_artifact ) = 0 then
90044: LD_VAR 0 1
90048: PPUSH
90049: LD_INT 4
90051: PPUSH
90052: CALL_OW 289
90056: PUSH
90057: LD_INT 0
90059: EQUAL
90060: IFFALSE 90077
// SetCargo ( i , mat_siberit , 100 ) ;
90062: LD_VAR 0 1
90066: PPUSH
90067: LD_INT 3
90069: PPUSH
90070: LD_INT 100
90072: PPUSH
90073: CALL_OW 290
90077: GO 90041
90079: POP
90080: POP
// end ;
90081: PPOPN 2
90083: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
90084: LD_EXP 115
90088: PUSH
90089: LD_EXP 160
90093: AND
90094: IFFALSE 90247
90096: GO 90098
90098: DISABLE
90099: LD_INT 0
90101: PPUSH
90102: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
90103: LD_ADDR_VAR 0 2
90107: PUSH
90108: LD_INT 22
90110: PUSH
90111: LD_OWVAR 2
90115: PUSH
90116: EMPTY
90117: LIST
90118: LIST
90119: PPUSH
90120: CALL_OW 69
90124: ST_TO_ADDR
// if not tmp then
90125: LD_VAR 0 2
90129: NOT
90130: IFFALSE 90134
// exit ;
90132: GO 90247
// for i := 1 to 2 do
90134: LD_ADDR_VAR 0 1
90138: PUSH
90139: DOUBLE
90140: LD_INT 1
90142: DEC
90143: ST_TO_ADDR
90144: LD_INT 2
90146: PUSH
90147: FOR_TO
90148: IFFALSE 90245
// begin uc_side := your_side ;
90150: LD_ADDR_OWVAR 20
90154: PUSH
90155: LD_OWVAR 2
90159: ST_TO_ADDR
// uc_nation := nation_american ;
90160: LD_ADDR_OWVAR 21
90164: PUSH
90165: LD_INT 1
90167: ST_TO_ADDR
// vc_chassis := us_morphling ;
90168: LD_ADDR_OWVAR 37
90172: PUSH
90173: LD_INT 5
90175: ST_TO_ADDR
// vc_engine := engine_siberite ;
90176: LD_ADDR_OWVAR 39
90180: PUSH
90181: LD_INT 3
90183: ST_TO_ADDR
// vc_control := control_computer ;
90184: LD_ADDR_OWVAR 38
90188: PUSH
90189: LD_INT 3
90191: ST_TO_ADDR
// vc_weapon := us_double_laser ;
90192: LD_ADDR_OWVAR 40
90196: PUSH
90197: LD_INT 10
90199: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
90200: CALL_OW 45
90204: PPUSH
90205: LD_VAR 0 2
90209: PUSH
90210: LD_INT 1
90212: ARRAY
90213: PPUSH
90214: CALL_OW 250
90218: PPUSH
90219: LD_VAR 0 2
90223: PUSH
90224: LD_INT 1
90226: ARRAY
90227: PPUSH
90228: CALL_OW 251
90232: PPUSH
90233: LD_INT 12
90235: PPUSH
90236: LD_INT 1
90238: PPUSH
90239: CALL_OW 50
// end ;
90243: GO 90147
90245: POP
90246: POP
// end ;
90247: PPOPN 2
90249: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
90250: LD_EXP 115
90254: PUSH
90255: LD_EXP 161
90259: AND
90260: IFFALSE 90482
90262: GO 90264
90264: DISABLE
90265: LD_INT 0
90267: PPUSH
90268: PPUSH
90269: PPUSH
90270: PPUSH
90271: PPUSH
90272: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
90273: LD_ADDR_VAR 0 6
90277: PUSH
90278: LD_INT 22
90280: PUSH
90281: LD_OWVAR 2
90285: PUSH
90286: EMPTY
90287: LIST
90288: LIST
90289: PUSH
90290: LD_INT 21
90292: PUSH
90293: LD_INT 1
90295: PUSH
90296: EMPTY
90297: LIST
90298: LIST
90299: PUSH
90300: LD_INT 3
90302: PUSH
90303: LD_INT 23
90305: PUSH
90306: LD_INT 0
90308: PUSH
90309: EMPTY
90310: LIST
90311: LIST
90312: PUSH
90313: EMPTY
90314: LIST
90315: LIST
90316: PUSH
90317: EMPTY
90318: LIST
90319: LIST
90320: LIST
90321: PPUSH
90322: CALL_OW 69
90326: ST_TO_ADDR
// if not tmp then
90327: LD_VAR 0 6
90331: NOT
90332: IFFALSE 90336
// exit ;
90334: GO 90482
// s1 := rand ( 1 , 4 ) ;
90336: LD_ADDR_VAR 0 2
90340: PUSH
90341: LD_INT 1
90343: PPUSH
90344: LD_INT 4
90346: PPUSH
90347: CALL_OW 12
90351: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
90352: LD_ADDR_VAR 0 4
90356: PUSH
90357: LD_VAR 0 6
90361: PUSH
90362: LD_INT 1
90364: ARRAY
90365: PPUSH
90366: LD_VAR 0 2
90370: PPUSH
90371: CALL_OW 259
90375: ST_TO_ADDR
// if s1 = 1 then
90376: LD_VAR 0 2
90380: PUSH
90381: LD_INT 1
90383: EQUAL
90384: IFFALSE 90404
// s2 := rand ( 2 , 4 ) else
90386: LD_ADDR_VAR 0 3
90390: PUSH
90391: LD_INT 2
90393: PPUSH
90394: LD_INT 4
90396: PPUSH
90397: CALL_OW 12
90401: ST_TO_ADDR
90402: GO 90412
// s2 := 1 ;
90404: LD_ADDR_VAR 0 3
90408: PUSH
90409: LD_INT 1
90411: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
90412: LD_ADDR_VAR 0 5
90416: PUSH
90417: LD_VAR 0 6
90421: PUSH
90422: LD_INT 1
90424: ARRAY
90425: PPUSH
90426: LD_VAR 0 3
90430: PPUSH
90431: CALL_OW 259
90435: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
90436: LD_VAR 0 6
90440: PUSH
90441: LD_INT 1
90443: ARRAY
90444: PPUSH
90445: LD_VAR 0 2
90449: PPUSH
90450: LD_VAR 0 5
90454: PPUSH
90455: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
90459: LD_VAR 0 6
90463: PUSH
90464: LD_INT 1
90466: ARRAY
90467: PPUSH
90468: LD_VAR 0 3
90472: PPUSH
90473: LD_VAR 0 4
90477: PPUSH
90478: CALL_OW 237
// end ;
90482: PPOPN 6
90484: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
90485: LD_EXP 115
90489: PUSH
90490: LD_EXP 162
90494: AND
90495: IFFALSE 90574
90497: GO 90499
90499: DISABLE
90500: LD_INT 0
90502: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
90503: LD_ADDR_VAR 0 1
90507: PUSH
90508: LD_INT 22
90510: PUSH
90511: LD_OWVAR 2
90515: PUSH
90516: EMPTY
90517: LIST
90518: LIST
90519: PUSH
90520: LD_INT 30
90522: PUSH
90523: LD_INT 3
90525: PUSH
90526: EMPTY
90527: LIST
90528: LIST
90529: PUSH
90530: EMPTY
90531: LIST
90532: LIST
90533: PPUSH
90534: CALL_OW 69
90538: ST_TO_ADDR
// if not tmp then
90539: LD_VAR 0 1
90543: NOT
90544: IFFALSE 90548
// exit ;
90546: GO 90574
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
90548: LD_VAR 0 1
90552: PUSH
90553: LD_INT 1
90555: PPUSH
90556: LD_VAR 0 1
90560: PPUSH
90561: CALL_OW 12
90565: ARRAY
90566: PPUSH
90567: LD_INT 1
90569: PPUSH
90570: CALL_OW 234
// end ;
90574: PPOPN 1
90576: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
90577: LD_EXP 115
90581: PUSH
90582: LD_EXP 163
90586: AND
90587: IFFALSE 90699
90589: GO 90591
90591: DISABLE
90592: LD_INT 0
90594: PPUSH
90595: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
90596: LD_ADDR_VAR 0 2
90600: PUSH
90601: LD_INT 22
90603: PUSH
90604: LD_OWVAR 2
90608: PUSH
90609: EMPTY
90610: LIST
90611: LIST
90612: PUSH
90613: LD_INT 2
90615: PUSH
90616: LD_INT 30
90618: PUSH
90619: LD_INT 27
90621: PUSH
90622: EMPTY
90623: LIST
90624: LIST
90625: PUSH
90626: LD_INT 30
90628: PUSH
90629: LD_INT 26
90631: PUSH
90632: EMPTY
90633: LIST
90634: LIST
90635: PUSH
90636: LD_INT 30
90638: PUSH
90639: LD_INT 28
90641: PUSH
90642: EMPTY
90643: LIST
90644: LIST
90645: PUSH
90646: EMPTY
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: PUSH
90652: EMPTY
90653: LIST
90654: LIST
90655: PPUSH
90656: CALL_OW 69
90660: ST_TO_ADDR
// if not tmp then
90661: LD_VAR 0 2
90665: NOT
90666: IFFALSE 90670
// exit ;
90668: GO 90699
// for i in tmp do
90670: LD_ADDR_VAR 0 1
90674: PUSH
90675: LD_VAR 0 2
90679: PUSH
90680: FOR_IN
90681: IFFALSE 90697
// SetLives ( i , 1 ) ;
90683: LD_VAR 0 1
90687: PPUSH
90688: LD_INT 1
90690: PPUSH
90691: CALL_OW 234
90695: GO 90680
90697: POP
90698: POP
// end ;
90699: PPOPN 2
90701: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
90702: LD_EXP 115
90706: PUSH
90707: LD_EXP 164
90711: AND
90712: IFFALSE 90986
90714: GO 90716
90716: DISABLE
90717: LD_INT 0
90719: PPUSH
90720: PPUSH
90721: PPUSH
// begin i := rand ( 1 , 7 ) ;
90722: LD_ADDR_VAR 0 1
90726: PUSH
90727: LD_INT 1
90729: PPUSH
90730: LD_INT 7
90732: PPUSH
90733: CALL_OW 12
90737: ST_TO_ADDR
// case i of 1 :
90738: LD_VAR 0 1
90742: PUSH
90743: LD_INT 1
90745: DOUBLE
90746: EQUAL
90747: IFTRUE 90751
90749: GO 90761
90751: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
90752: LD_STRING earthquake(getX(game), 0, 32)
90754: PPUSH
90755: CALL_OW 559
90759: GO 90986
90761: LD_INT 2
90763: DOUBLE
90764: EQUAL
90765: IFTRUE 90769
90767: GO 90783
90769: POP
// begin ToLua ( displayStucuk(); ) ;
90770: LD_STRING displayStucuk();
90772: PPUSH
90773: CALL_OW 559
// ResetFog ;
90777: CALL_OW 335
// end ; 3 :
90781: GO 90986
90783: LD_INT 3
90785: DOUBLE
90786: EQUAL
90787: IFTRUE 90791
90789: GO 90895
90791: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90792: LD_ADDR_VAR 0 2
90796: PUSH
90797: LD_INT 22
90799: PUSH
90800: LD_OWVAR 2
90804: PUSH
90805: EMPTY
90806: LIST
90807: LIST
90808: PUSH
90809: LD_INT 25
90811: PUSH
90812: LD_INT 1
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: PUSH
90819: EMPTY
90820: LIST
90821: LIST
90822: PPUSH
90823: CALL_OW 69
90827: ST_TO_ADDR
// if not tmp then
90828: LD_VAR 0 2
90832: NOT
90833: IFFALSE 90837
// exit ;
90835: GO 90986
// un := tmp [ rand ( 1 , tmp ) ] ;
90837: LD_ADDR_VAR 0 3
90841: PUSH
90842: LD_VAR 0 2
90846: PUSH
90847: LD_INT 1
90849: PPUSH
90850: LD_VAR 0 2
90854: PPUSH
90855: CALL_OW 12
90859: ARRAY
90860: ST_TO_ADDR
// if Crawls ( un ) then
90861: LD_VAR 0 3
90865: PPUSH
90866: CALL_OW 318
90870: IFFALSE 90881
// ComWalk ( un ) ;
90872: LD_VAR 0 3
90876: PPUSH
90877: CALL_OW 138
// SetClass ( un , class_mortar ) ;
90881: LD_VAR 0 3
90885: PPUSH
90886: LD_INT 8
90888: PPUSH
90889: CALL_OW 336
// end ; 4 :
90893: GO 90986
90895: LD_INT 4
90897: DOUBLE
90898: EQUAL
90899: IFTRUE 90903
90901: GO 90964
90903: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
90904: LD_ADDR_VAR 0 2
90908: PUSH
90909: LD_INT 22
90911: PUSH
90912: LD_OWVAR 2
90916: PUSH
90917: EMPTY
90918: LIST
90919: LIST
90920: PUSH
90921: LD_INT 30
90923: PUSH
90924: LD_INT 29
90926: PUSH
90927: EMPTY
90928: LIST
90929: LIST
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: PPUSH
90935: CALL_OW 69
90939: ST_TO_ADDR
// if not tmp then
90940: LD_VAR 0 2
90944: NOT
90945: IFFALSE 90949
// exit ;
90947: GO 90986
// DestroyUnit ( tmp [ 1 ] ) ;
90949: LD_VAR 0 2
90953: PUSH
90954: LD_INT 1
90956: ARRAY
90957: PPUSH
90958: CALL_OW 65
// end ; 5 .. 7 :
90962: GO 90986
90964: LD_INT 5
90966: DOUBLE
90967: GREATEREQUAL
90968: IFFALSE 90976
90970: LD_INT 7
90972: DOUBLE
90973: LESSEQUAL
90974: IFTRUE 90978
90976: GO 90985
90978: POP
// StreamSibBomb ; end ;
90979: CALL 87266 0 0
90983: GO 90986
90985: POP
// end ;
90986: PPOPN 3
90988: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
90989: LD_EXP 115
90993: PUSH
90994: LD_EXP 165
90998: AND
90999: IFFALSE 91155
91001: GO 91003
91003: DISABLE
91004: LD_INT 0
91006: PPUSH
91007: PPUSH
91008: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
91009: LD_ADDR_VAR 0 2
91013: PUSH
91014: LD_INT 81
91016: PUSH
91017: LD_OWVAR 2
91021: PUSH
91022: EMPTY
91023: LIST
91024: LIST
91025: PUSH
91026: LD_INT 2
91028: PUSH
91029: LD_INT 21
91031: PUSH
91032: LD_INT 1
91034: PUSH
91035: EMPTY
91036: LIST
91037: LIST
91038: PUSH
91039: LD_INT 21
91041: PUSH
91042: LD_INT 2
91044: PUSH
91045: EMPTY
91046: LIST
91047: LIST
91048: PUSH
91049: EMPTY
91050: LIST
91051: LIST
91052: LIST
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: PPUSH
91058: CALL_OW 69
91062: ST_TO_ADDR
// if not tmp then
91063: LD_VAR 0 2
91067: NOT
91068: IFFALSE 91072
// exit ;
91070: GO 91155
// p := 0 ;
91072: LD_ADDR_VAR 0 3
91076: PUSH
91077: LD_INT 0
91079: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
91080: LD_INT 35
91082: PPUSH
91083: CALL_OW 67
// p := p + 1 ;
91087: LD_ADDR_VAR 0 3
91091: PUSH
91092: LD_VAR 0 3
91096: PUSH
91097: LD_INT 1
91099: PLUS
91100: ST_TO_ADDR
// for i in tmp do
91101: LD_ADDR_VAR 0 1
91105: PUSH
91106: LD_VAR 0 2
91110: PUSH
91111: FOR_IN
91112: IFFALSE 91143
// if GetLives ( i ) < 1000 then
91114: LD_VAR 0 1
91118: PPUSH
91119: CALL_OW 256
91123: PUSH
91124: LD_INT 1000
91126: LESS
91127: IFFALSE 91141
// SetLives ( i , 1000 ) ;
91129: LD_VAR 0 1
91133: PPUSH
91134: LD_INT 1000
91136: PPUSH
91137: CALL_OW 234
91141: GO 91111
91143: POP
91144: POP
// until p > 20 ;
91145: LD_VAR 0 3
91149: PUSH
91150: LD_INT 20
91152: GREATER
91153: IFFALSE 91080
// end ;
91155: PPOPN 3
91157: END
// every 0 0$1 trigger StreamModeActive and sTime do
91158: LD_EXP 115
91162: PUSH
91163: LD_EXP 166
91167: AND
91168: IFFALSE 91203
91170: GO 91172
91172: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
91173: LD_INT 28
91175: PPUSH
91176: LD_OWVAR 2
91180: PPUSH
91181: LD_INT 2
91183: PPUSH
91184: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
91188: LD_INT 30
91190: PPUSH
91191: LD_OWVAR 2
91195: PPUSH
91196: LD_INT 2
91198: PPUSH
91199: CALL_OW 322
// end ;
91203: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
91204: LD_EXP 115
91208: PUSH
91209: LD_EXP 167
91213: AND
91214: IFFALSE 91335
91216: GO 91218
91218: DISABLE
91219: LD_INT 0
91221: PPUSH
91222: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
91223: LD_ADDR_VAR 0 2
91227: PUSH
91228: LD_INT 22
91230: PUSH
91231: LD_OWVAR 2
91235: PUSH
91236: EMPTY
91237: LIST
91238: LIST
91239: PUSH
91240: LD_INT 21
91242: PUSH
91243: LD_INT 1
91245: PUSH
91246: EMPTY
91247: LIST
91248: LIST
91249: PUSH
91250: LD_INT 3
91252: PUSH
91253: LD_INT 23
91255: PUSH
91256: LD_INT 0
91258: PUSH
91259: EMPTY
91260: LIST
91261: LIST
91262: PUSH
91263: EMPTY
91264: LIST
91265: LIST
91266: PUSH
91267: EMPTY
91268: LIST
91269: LIST
91270: LIST
91271: PPUSH
91272: CALL_OW 69
91276: ST_TO_ADDR
// if not tmp then
91277: LD_VAR 0 2
91281: NOT
91282: IFFALSE 91286
// exit ;
91284: GO 91335
// for i in tmp do
91286: LD_ADDR_VAR 0 1
91290: PUSH
91291: LD_VAR 0 2
91295: PUSH
91296: FOR_IN
91297: IFFALSE 91333
// begin if Crawls ( i ) then
91299: LD_VAR 0 1
91303: PPUSH
91304: CALL_OW 318
91308: IFFALSE 91319
// ComWalk ( i ) ;
91310: LD_VAR 0 1
91314: PPUSH
91315: CALL_OW 138
// SetClass ( i , 2 ) ;
91319: LD_VAR 0 1
91323: PPUSH
91324: LD_INT 2
91326: PPUSH
91327: CALL_OW 336
// end ;
91331: GO 91296
91333: POP
91334: POP
// end ;
91335: PPOPN 2
91337: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
91338: LD_EXP 115
91342: PUSH
91343: LD_EXP 168
91347: AND
91348: IFFALSE 91629
91350: GO 91352
91352: DISABLE
91353: LD_INT 0
91355: PPUSH
91356: PPUSH
91357: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
91358: LD_OWVAR 2
91362: PPUSH
91363: LD_INT 9
91365: PPUSH
91366: LD_INT 1
91368: PPUSH
91369: LD_INT 1
91371: PPUSH
91372: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
91376: LD_INT 9
91378: PPUSH
91379: LD_OWVAR 2
91383: PPUSH
91384: CALL_OW 343
// uc_side := 9 ;
91388: LD_ADDR_OWVAR 20
91392: PUSH
91393: LD_INT 9
91395: ST_TO_ADDR
// uc_nation := 2 ;
91396: LD_ADDR_OWVAR 21
91400: PUSH
91401: LD_INT 2
91403: ST_TO_ADDR
// hc_name := Dark Warrior ;
91404: LD_ADDR_OWVAR 26
91408: PUSH
91409: LD_STRING Dark Warrior
91411: ST_TO_ADDR
// hc_gallery :=  ;
91412: LD_ADDR_OWVAR 33
91416: PUSH
91417: LD_STRING 
91419: ST_TO_ADDR
// hc_noskilllimit := true ;
91420: LD_ADDR_OWVAR 76
91424: PUSH
91425: LD_INT 1
91427: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
91428: LD_ADDR_OWVAR 31
91432: PUSH
91433: LD_INT 30
91435: PUSH
91436: LD_INT 30
91438: PUSH
91439: LD_INT 30
91441: PUSH
91442: LD_INT 30
91444: PUSH
91445: EMPTY
91446: LIST
91447: LIST
91448: LIST
91449: LIST
91450: ST_TO_ADDR
// un := CreateHuman ;
91451: LD_ADDR_VAR 0 3
91455: PUSH
91456: CALL_OW 44
91460: ST_TO_ADDR
// hc_noskilllimit := false ;
91461: LD_ADDR_OWVAR 76
91465: PUSH
91466: LD_INT 0
91468: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91469: LD_VAR 0 3
91473: PPUSH
91474: LD_INT 1
91476: PPUSH
91477: CALL_OW 51
// p := 0 ;
91481: LD_ADDR_VAR 0 2
91485: PUSH
91486: LD_INT 0
91488: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
91489: LD_INT 35
91491: PPUSH
91492: CALL_OW 67
// p := p + 1 ;
91496: LD_ADDR_VAR 0 2
91500: PUSH
91501: LD_VAR 0 2
91505: PUSH
91506: LD_INT 1
91508: PLUS
91509: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
91510: LD_VAR 0 3
91514: PPUSH
91515: CALL_OW 256
91519: PUSH
91520: LD_INT 1000
91522: LESS
91523: IFFALSE 91537
// SetLives ( un , 1000 ) ;
91525: LD_VAR 0 3
91529: PPUSH
91530: LD_INT 1000
91532: PPUSH
91533: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
91537: LD_VAR 0 3
91541: PPUSH
91542: LD_INT 81
91544: PUSH
91545: LD_OWVAR 2
91549: PUSH
91550: EMPTY
91551: LIST
91552: LIST
91553: PUSH
91554: LD_INT 91
91556: PUSH
91557: LD_VAR 0 3
91561: PUSH
91562: LD_INT 30
91564: PUSH
91565: EMPTY
91566: LIST
91567: LIST
91568: LIST
91569: PUSH
91570: EMPTY
91571: LIST
91572: LIST
91573: PPUSH
91574: CALL_OW 69
91578: PPUSH
91579: LD_VAR 0 3
91583: PPUSH
91584: CALL_OW 74
91588: PPUSH
91589: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
91593: LD_VAR 0 2
91597: PUSH
91598: LD_INT 60
91600: GREATER
91601: PUSH
91602: LD_VAR 0 3
91606: PPUSH
91607: CALL_OW 301
91611: OR
91612: IFFALSE 91489
// if un then
91614: LD_VAR 0 3
91618: IFFALSE 91629
// RemoveUnit ( un ) ;
91620: LD_VAR 0 3
91624: PPUSH
91625: CALL_OW 64
// end ; end_of_file
91629: PPOPN 3
91631: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
91632: LD_INT 0
91634: PPUSH
91635: PPUSH
91636: PPUSH
91637: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
91638: LD_VAR 0 1
91642: PPUSH
91643: CALL_OW 264
91647: PUSH
91648: LD_EXP 106
91652: EQUAL
91653: IFFALSE 91725
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
91655: LD_INT 68
91657: PPUSH
91658: LD_VAR 0 1
91662: PPUSH
91663: CALL_OW 255
91667: PPUSH
91668: CALL_OW 321
91672: PUSH
91673: LD_INT 2
91675: EQUAL
91676: IFFALSE 91688
// eff := 70 else
91678: LD_ADDR_VAR 0 4
91682: PUSH
91683: LD_INT 70
91685: ST_TO_ADDR
91686: GO 91696
// eff := 30 ;
91688: LD_ADDR_VAR 0 4
91692: PUSH
91693: LD_INT 30
91695: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
91696: LD_VAR 0 1
91700: PPUSH
91701: CALL_OW 250
91705: PPUSH
91706: LD_VAR 0 1
91710: PPUSH
91711: CALL_OW 251
91715: PPUSH
91716: LD_VAR 0 4
91720: PPUSH
91721: CALL_OW 495
// end ; end ;
91725: LD_VAR 0 2
91729: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
91730: LD_INT 0
91732: PPUSH
// end ;
91733: LD_VAR 0 4
91737: RET
// export function SOS_Command ( cmd ) ; begin
91738: LD_INT 0
91740: PPUSH
// end ;
91741: LD_VAR 0 2
91745: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
91746: LD_VAR 0 1
91750: PUSH
91751: LD_INT 255
91753: EQUAL
91754: PUSH
91755: LD_VAR 0 2
91759: PPUSH
91760: CALL_OW 264
91764: PUSH
91765: LD_INT 14
91767: PUSH
91768: LD_INT 53
91770: PUSH
91771: EMPTY
91772: LIST
91773: LIST
91774: IN
91775: AND
91776: PUSH
91777: LD_VAR 0 4
91781: PPUSH
91782: LD_VAR 0 5
91786: PPUSH
91787: CALL_OW 488
91791: AND
91792: IFFALSE 91816
// CutTreeXYR ( unit , x , y , 12 ) ;
91794: LD_VAR 0 2
91798: PPUSH
91799: LD_VAR 0 4
91803: PPUSH
91804: LD_VAR 0 5
91808: PPUSH
91809: LD_INT 12
91811: PPUSH
91812: CALL 91819 0 4
// end ;
91816: PPOPN 5
91818: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
91819: LD_INT 0
91821: PPUSH
91822: PPUSH
91823: PPUSH
91824: PPUSH
91825: PPUSH
91826: PPUSH
91827: PPUSH
91828: PPUSH
91829: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
91830: LD_VAR 0 1
91834: NOT
91835: PUSH
91836: LD_VAR 0 2
91840: PPUSH
91841: LD_VAR 0 3
91845: PPUSH
91846: CALL_OW 488
91850: NOT
91851: OR
91852: PUSH
91853: LD_VAR 0 4
91857: NOT
91858: OR
91859: IFFALSE 91863
// exit ;
91861: GO 92203
// list := [ ] ;
91863: LD_ADDR_VAR 0 13
91867: PUSH
91868: EMPTY
91869: ST_TO_ADDR
// if x - r < 0 then
91870: LD_VAR 0 2
91874: PUSH
91875: LD_VAR 0 4
91879: MINUS
91880: PUSH
91881: LD_INT 0
91883: LESS
91884: IFFALSE 91896
// min_x := 0 else
91886: LD_ADDR_VAR 0 7
91890: PUSH
91891: LD_INT 0
91893: ST_TO_ADDR
91894: GO 91912
// min_x := x - r ;
91896: LD_ADDR_VAR 0 7
91900: PUSH
91901: LD_VAR 0 2
91905: PUSH
91906: LD_VAR 0 4
91910: MINUS
91911: ST_TO_ADDR
// if y - r < 0 then
91912: LD_VAR 0 3
91916: PUSH
91917: LD_VAR 0 4
91921: MINUS
91922: PUSH
91923: LD_INT 0
91925: LESS
91926: IFFALSE 91938
// min_y := 0 else
91928: LD_ADDR_VAR 0 8
91932: PUSH
91933: LD_INT 0
91935: ST_TO_ADDR
91936: GO 91954
// min_y := y - r ;
91938: LD_ADDR_VAR 0 8
91942: PUSH
91943: LD_VAR 0 3
91947: PUSH
91948: LD_VAR 0 4
91952: MINUS
91953: ST_TO_ADDR
// max_x := x + r ;
91954: LD_ADDR_VAR 0 9
91958: PUSH
91959: LD_VAR 0 2
91963: PUSH
91964: LD_VAR 0 4
91968: PLUS
91969: ST_TO_ADDR
// max_y := y + r ;
91970: LD_ADDR_VAR 0 10
91974: PUSH
91975: LD_VAR 0 3
91979: PUSH
91980: LD_VAR 0 4
91984: PLUS
91985: ST_TO_ADDR
// for _x = min_x to max_x do
91986: LD_ADDR_VAR 0 11
91990: PUSH
91991: DOUBLE
91992: LD_VAR 0 7
91996: DEC
91997: ST_TO_ADDR
91998: LD_VAR 0 9
92002: PUSH
92003: FOR_TO
92004: IFFALSE 92121
// for _y = min_y to max_y do
92006: LD_ADDR_VAR 0 12
92010: PUSH
92011: DOUBLE
92012: LD_VAR 0 8
92016: DEC
92017: ST_TO_ADDR
92018: LD_VAR 0 10
92022: PUSH
92023: FOR_TO
92024: IFFALSE 92117
// begin if not ValidHex ( _x , _y ) then
92026: LD_VAR 0 11
92030: PPUSH
92031: LD_VAR 0 12
92035: PPUSH
92036: CALL_OW 488
92040: NOT
92041: IFFALSE 92045
// continue ;
92043: GO 92023
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
92045: LD_VAR 0 11
92049: PPUSH
92050: LD_VAR 0 12
92054: PPUSH
92055: CALL_OW 351
92059: PUSH
92060: LD_VAR 0 11
92064: PPUSH
92065: LD_VAR 0 12
92069: PPUSH
92070: CALL_OW 554
92074: AND
92075: IFFALSE 92115
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
92077: LD_ADDR_VAR 0 13
92081: PUSH
92082: LD_VAR 0 13
92086: PPUSH
92087: LD_VAR 0 13
92091: PUSH
92092: LD_INT 1
92094: PLUS
92095: PPUSH
92096: LD_VAR 0 11
92100: PUSH
92101: LD_VAR 0 12
92105: PUSH
92106: EMPTY
92107: LIST
92108: LIST
92109: PPUSH
92110: CALL_OW 2
92114: ST_TO_ADDR
// end ;
92115: GO 92023
92117: POP
92118: POP
92119: GO 92003
92121: POP
92122: POP
// if not list then
92123: LD_VAR 0 13
92127: NOT
92128: IFFALSE 92132
// exit ;
92130: GO 92203
// for i in list do
92132: LD_ADDR_VAR 0 6
92136: PUSH
92137: LD_VAR 0 13
92141: PUSH
92142: FOR_IN
92143: IFFALSE 92201
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
92145: LD_VAR 0 1
92149: PPUSH
92150: LD_STRING M
92152: PUSH
92153: LD_VAR 0 6
92157: PUSH
92158: LD_INT 1
92160: ARRAY
92161: PUSH
92162: LD_VAR 0 6
92166: PUSH
92167: LD_INT 2
92169: ARRAY
92170: PUSH
92171: LD_INT 0
92173: PUSH
92174: LD_INT 0
92176: PUSH
92177: LD_INT 0
92179: PUSH
92180: LD_INT 0
92182: PUSH
92183: EMPTY
92184: LIST
92185: LIST
92186: LIST
92187: LIST
92188: LIST
92189: LIST
92190: LIST
92191: PUSH
92192: EMPTY
92193: LIST
92194: PPUSH
92195: CALL_OW 447
92199: GO 92142
92201: POP
92202: POP
// end ; end_of_file
92203: LD_VAR 0 5
92207: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
92208: LD_INT 0
92210: PPUSH
92211: PPUSH
92212: PPUSH
92213: PPUSH
92214: PPUSH
92215: PPUSH
92216: PPUSH
92217: PPUSH
92218: PPUSH
92219: PPUSH
92220: PPUSH
92221: PPUSH
92222: PPUSH
92223: PPUSH
92224: PPUSH
92225: PPUSH
92226: PPUSH
92227: PPUSH
92228: PPUSH
92229: PPUSH
92230: PPUSH
92231: PPUSH
92232: PPUSH
92233: PPUSH
92234: PPUSH
92235: PPUSH
92236: PPUSH
92237: PPUSH
92238: PPUSH
92239: PPUSH
92240: PPUSH
92241: PPUSH
92242: PPUSH
92243: PPUSH
// if not list then
92244: LD_VAR 0 1
92248: NOT
92249: IFFALSE 92253
// exit ;
92251: GO 96912
// base := list [ 1 ] ;
92253: LD_ADDR_VAR 0 3
92257: PUSH
92258: LD_VAR 0 1
92262: PUSH
92263: LD_INT 1
92265: ARRAY
92266: ST_TO_ADDR
// group := list [ 2 ] ;
92267: LD_ADDR_VAR 0 4
92271: PUSH
92272: LD_VAR 0 1
92276: PUSH
92277: LD_INT 2
92279: ARRAY
92280: ST_TO_ADDR
// path := list [ 3 ] ;
92281: LD_ADDR_VAR 0 5
92285: PUSH
92286: LD_VAR 0 1
92290: PUSH
92291: LD_INT 3
92293: ARRAY
92294: ST_TO_ADDR
// flags := list [ 4 ] ;
92295: LD_ADDR_VAR 0 6
92299: PUSH
92300: LD_VAR 0 1
92304: PUSH
92305: LD_INT 4
92307: ARRAY
92308: ST_TO_ADDR
// mined := [ ] ;
92309: LD_ADDR_VAR 0 27
92313: PUSH
92314: EMPTY
92315: ST_TO_ADDR
// bombed := [ ] ;
92316: LD_ADDR_VAR 0 28
92320: PUSH
92321: EMPTY
92322: ST_TO_ADDR
// healers := [ ] ;
92323: LD_ADDR_VAR 0 31
92327: PUSH
92328: EMPTY
92329: ST_TO_ADDR
// to_heal := [ ] ;
92330: LD_ADDR_VAR 0 30
92334: PUSH
92335: EMPTY
92336: ST_TO_ADDR
// repairs := [ ] ;
92337: LD_ADDR_VAR 0 33
92341: PUSH
92342: EMPTY
92343: ST_TO_ADDR
// to_repair := [ ] ;
92344: LD_ADDR_VAR 0 32
92348: PUSH
92349: EMPTY
92350: ST_TO_ADDR
// if not group or not path then
92351: LD_VAR 0 4
92355: NOT
92356: PUSH
92357: LD_VAR 0 5
92361: NOT
92362: OR
92363: IFFALSE 92367
// exit ;
92365: GO 96912
// side := GetSide ( group [ 1 ] ) ;
92367: LD_ADDR_VAR 0 35
92371: PUSH
92372: LD_VAR 0 4
92376: PUSH
92377: LD_INT 1
92379: ARRAY
92380: PPUSH
92381: CALL_OW 255
92385: ST_TO_ADDR
// if flags then
92386: LD_VAR 0 6
92390: IFFALSE 92534
// begin f_ignore_area := flags [ 1 ] ;
92392: LD_ADDR_VAR 0 17
92396: PUSH
92397: LD_VAR 0 6
92401: PUSH
92402: LD_INT 1
92404: ARRAY
92405: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
92406: LD_ADDR_VAR 0 18
92410: PUSH
92411: LD_VAR 0 6
92415: PUSH
92416: LD_INT 2
92418: ARRAY
92419: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
92420: LD_ADDR_VAR 0 19
92424: PUSH
92425: LD_VAR 0 6
92429: PUSH
92430: LD_INT 3
92432: ARRAY
92433: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
92434: LD_ADDR_VAR 0 20
92438: PUSH
92439: LD_VAR 0 6
92443: PUSH
92444: LD_INT 4
92446: ARRAY
92447: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
92448: LD_ADDR_VAR 0 21
92452: PUSH
92453: LD_VAR 0 6
92457: PUSH
92458: LD_INT 5
92460: ARRAY
92461: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
92462: LD_ADDR_VAR 0 22
92466: PUSH
92467: LD_VAR 0 6
92471: PUSH
92472: LD_INT 6
92474: ARRAY
92475: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
92476: LD_ADDR_VAR 0 23
92480: PUSH
92481: LD_VAR 0 6
92485: PUSH
92486: LD_INT 7
92488: ARRAY
92489: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
92490: LD_ADDR_VAR 0 24
92494: PUSH
92495: LD_VAR 0 6
92499: PUSH
92500: LD_INT 8
92502: ARRAY
92503: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
92504: LD_ADDR_VAR 0 25
92508: PUSH
92509: LD_VAR 0 6
92513: PUSH
92514: LD_INT 9
92516: ARRAY
92517: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
92518: LD_ADDR_VAR 0 26
92522: PUSH
92523: LD_VAR 0 6
92527: PUSH
92528: LD_INT 10
92530: ARRAY
92531: ST_TO_ADDR
// end else
92532: GO 92614
// begin f_ignore_area := false ;
92534: LD_ADDR_VAR 0 17
92538: PUSH
92539: LD_INT 0
92541: ST_TO_ADDR
// f_capture := false ;
92542: LD_ADDR_VAR 0 18
92546: PUSH
92547: LD_INT 0
92549: ST_TO_ADDR
// f_ignore_civ := false ;
92550: LD_ADDR_VAR 0 19
92554: PUSH
92555: LD_INT 0
92557: ST_TO_ADDR
// f_murder := false ;
92558: LD_ADDR_VAR 0 20
92562: PUSH
92563: LD_INT 0
92565: ST_TO_ADDR
// f_mines := false ;
92566: LD_ADDR_VAR 0 21
92570: PUSH
92571: LD_INT 0
92573: ST_TO_ADDR
// f_repair := false ;
92574: LD_ADDR_VAR 0 22
92578: PUSH
92579: LD_INT 0
92581: ST_TO_ADDR
// f_heal := false ;
92582: LD_ADDR_VAR 0 23
92586: PUSH
92587: LD_INT 0
92589: ST_TO_ADDR
// f_spacetime := false ;
92590: LD_ADDR_VAR 0 24
92594: PUSH
92595: LD_INT 0
92597: ST_TO_ADDR
// f_attack_depot := false ;
92598: LD_ADDR_VAR 0 25
92602: PUSH
92603: LD_INT 0
92605: ST_TO_ADDR
// f_crawl := false ;
92606: LD_ADDR_VAR 0 26
92610: PUSH
92611: LD_INT 0
92613: ST_TO_ADDR
// end ; if f_heal then
92614: LD_VAR 0 23
92618: IFFALSE 92645
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
92620: LD_ADDR_VAR 0 31
92624: PUSH
92625: LD_VAR 0 4
92629: PPUSH
92630: LD_INT 25
92632: PUSH
92633: LD_INT 4
92635: PUSH
92636: EMPTY
92637: LIST
92638: LIST
92639: PPUSH
92640: CALL_OW 72
92644: ST_TO_ADDR
// if f_repair then
92645: LD_VAR 0 22
92649: IFFALSE 92676
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
92651: LD_ADDR_VAR 0 33
92655: PUSH
92656: LD_VAR 0 4
92660: PPUSH
92661: LD_INT 25
92663: PUSH
92664: LD_INT 3
92666: PUSH
92667: EMPTY
92668: LIST
92669: LIST
92670: PPUSH
92671: CALL_OW 72
92675: ST_TO_ADDR
// units_path := [ ] ;
92676: LD_ADDR_VAR 0 16
92680: PUSH
92681: EMPTY
92682: ST_TO_ADDR
// for i = 1 to group do
92683: LD_ADDR_VAR 0 7
92687: PUSH
92688: DOUBLE
92689: LD_INT 1
92691: DEC
92692: ST_TO_ADDR
92693: LD_VAR 0 4
92697: PUSH
92698: FOR_TO
92699: IFFALSE 92728
// units_path := Replace ( units_path , i , path ) ;
92701: LD_ADDR_VAR 0 16
92705: PUSH
92706: LD_VAR 0 16
92710: PPUSH
92711: LD_VAR 0 7
92715: PPUSH
92716: LD_VAR 0 5
92720: PPUSH
92721: CALL_OW 1
92725: ST_TO_ADDR
92726: GO 92698
92728: POP
92729: POP
// repeat for i = group downto 1 do
92730: LD_ADDR_VAR 0 7
92734: PUSH
92735: DOUBLE
92736: LD_VAR 0 4
92740: INC
92741: ST_TO_ADDR
92742: LD_INT 1
92744: PUSH
92745: FOR_DOWNTO
92746: IFFALSE 96868
// begin wait ( 5 ) ;
92748: LD_INT 5
92750: PPUSH
92751: CALL_OW 67
// tmp := [ ] ;
92755: LD_ADDR_VAR 0 14
92759: PUSH
92760: EMPTY
92761: ST_TO_ADDR
// attacking := false ;
92762: LD_ADDR_VAR 0 29
92766: PUSH
92767: LD_INT 0
92769: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
92770: LD_VAR 0 4
92774: PUSH
92775: LD_VAR 0 7
92779: ARRAY
92780: PPUSH
92781: CALL_OW 301
92785: PUSH
92786: LD_VAR 0 4
92790: PUSH
92791: LD_VAR 0 7
92795: ARRAY
92796: NOT
92797: OR
92798: IFFALSE 92907
// begin if GetType ( group [ i ] ) = unit_human then
92800: LD_VAR 0 4
92804: PUSH
92805: LD_VAR 0 7
92809: ARRAY
92810: PPUSH
92811: CALL_OW 247
92815: PUSH
92816: LD_INT 1
92818: EQUAL
92819: IFFALSE 92865
// begin to_heal := to_heal diff group [ i ] ;
92821: LD_ADDR_VAR 0 30
92825: PUSH
92826: LD_VAR 0 30
92830: PUSH
92831: LD_VAR 0 4
92835: PUSH
92836: LD_VAR 0 7
92840: ARRAY
92841: DIFF
92842: ST_TO_ADDR
// healers := healers diff group [ i ] ;
92843: LD_ADDR_VAR 0 31
92847: PUSH
92848: LD_VAR 0 31
92852: PUSH
92853: LD_VAR 0 4
92857: PUSH
92858: LD_VAR 0 7
92862: ARRAY
92863: DIFF
92864: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
92865: LD_ADDR_VAR 0 4
92869: PUSH
92870: LD_VAR 0 4
92874: PPUSH
92875: LD_VAR 0 7
92879: PPUSH
92880: CALL_OW 3
92884: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
92885: LD_ADDR_VAR 0 16
92889: PUSH
92890: LD_VAR 0 16
92894: PPUSH
92895: LD_VAR 0 7
92899: PPUSH
92900: CALL_OW 3
92904: ST_TO_ADDR
// continue ;
92905: GO 92745
// end ; if f_repair then
92907: LD_VAR 0 22
92911: IFFALSE 93400
// begin if GetType ( group [ i ] ) = unit_vehicle then
92913: LD_VAR 0 4
92917: PUSH
92918: LD_VAR 0 7
92922: ARRAY
92923: PPUSH
92924: CALL_OW 247
92928: PUSH
92929: LD_INT 2
92931: EQUAL
92932: IFFALSE 93122
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
92934: LD_VAR 0 4
92938: PUSH
92939: LD_VAR 0 7
92943: ARRAY
92944: PPUSH
92945: CALL_OW 256
92949: PUSH
92950: LD_INT 700
92952: LESS
92953: PUSH
92954: LD_VAR 0 4
92958: PUSH
92959: LD_VAR 0 7
92963: ARRAY
92964: PUSH
92965: LD_VAR 0 32
92969: IN
92970: NOT
92971: AND
92972: IFFALSE 92996
// to_repair := to_repair union group [ i ] ;
92974: LD_ADDR_VAR 0 32
92978: PUSH
92979: LD_VAR 0 32
92983: PUSH
92984: LD_VAR 0 4
92988: PUSH
92989: LD_VAR 0 7
92993: ARRAY
92994: UNION
92995: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
92996: LD_VAR 0 4
93000: PUSH
93001: LD_VAR 0 7
93005: ARRAY
93006: PPUSH
93007: CALL_OW 256
93011: PUSH
93012: LD_INT 1000
93014: EQUAL
93015: PUSH
93016: LD_VAR 0 4
93020: PUSH
93021: LD_VAR 0 7
93025: ARRAY
93026: PUSH
93027: LD_VAR 0 32
93031: IN
93032: AND
93033: IFFALSE 93057
// to_repair := to_repair diff group [ i ] ;
93035: LD_ADDR_VAR 0 32
93039: PUSH
93040: LD_VAR 0 32
93044: PUSH
93045: LD_VAR 0 4
93049: PUSH
93050: LD_VAR 0 7
93054: ARRAY
93055: DIFF
93056: ST_TO_ADDR
// if group [ i ] in to_repair then
93057: LD_VAR 0 4
93061: PUSH
93062: LD_VAR 0 7
93066: ARRAY
93067: PUSH
93068: LD_VAR 0 32
93072: IN
93073: IFFALSE 93120
// begin if not IsInArea ( group [ i ] , f_repair ) then
93075: LD_VAR 0 4
93079: PUSH
93080: LD_VAR 0 7
93084: ARRAY
93085: PPUSH
93086: LD_VAR 0 22
93090: PPUSH
93091: CALL_OW 308
93095: NOT
93096: IFFALSE 93118
// ComMoveToArea ( group [ i ] , f_repair ) ;
93098: LD_VAR 0 4
93102: PUSH
93103: LD_VAR 0 7
93107: ARRAY
93108: PPUSH
93109: LD_VAR 0 22
93113: PPUSH
93114: CALL_OW 113
// continue ;
93118: GO 92745
// end ; end else
93120: GO 93400
// if group [ i ] in repairs then
93122: LD_VAR 0 4
93126: PUSH
93127: LD_VAR 0 7
93131: ARRAY
93132: PUSH
93133: LD_VAR 0 33
93137: IN
93138: IFFALSE 93400
// begin if IsInUnit ( group [ i ] ) then
93140: LD_VAR 0 4
93144: PUSH
93145: LD_VAR 0 7
93149: ARRAY
93150: PPUSH
93151: CALL_OW 310
93155: IFFALSE 93223
// begin z := IsInUnit ( group [ i ] ) ;
93157: LD_ADDR_VAR 0 13
93161: PUSH
93162: LD_VAR 0 4
93166: PUSH
93167: LD_VAR 0 7
93171: ARRAY
93172: PPUSH
93173: CALL_OW 310
93177: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
93178: LD_VAR 0 13
93182: PUSH
93183: LD_VAR 0 32
93187: IN
93188: PUSH
93189: LD_VAR 0 13
93193: PPUSH
93194: LD_VAR 0 22
93198: PPUSH
93199: CALL_OW 308
93203: AND
93204: IFFALSE 93221
// ComExitVehicle ( group [ i ] ) ;
93206: LD_VAR 0 4
93210: PUSH
93211: LD_VAR 0 7
93215: ARRAY
93216: PPUSH
93217: CALL_OW 121
// end else
93221: GO 93400
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
93223: LD_ADDR_VAR 0 13
93227: PUSH
93228: LD_VAR 0 4
93232: PPUSH
93233: LD_INT 95
93235: PUSH
93236: LD_VAR 0 22
93240: PUSH
93241: EMPTY
93242: LIST
93243: LIST
93244: PUSH
93245: LD_INT 58
93247: PUSH
93248: EMPTY
93249: LIST
93250: PUSH
93251: EMPTY
93252: LIST
93253: LIST
93254: PPUSH
93255: CALL_OW 72
93259: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
93260: LD_VAR 0 4
93264: PUSH
93265: LD_VAR 0 7
93269: ARRAY
93270: PPUSH
93271: CALL_OW 314
93275: NOT
93276: IFFALSE 93398
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
93278: LD_ADDR_VAR 0 10
93282: PUSH
93283: LD_VAR 0 13
93287: PPUSH
93288: LD_VAR 0 4
93292: PUSH
93293: LD_VAR 0 7
93297: ARRAY
93298: PPUSH
93299: CALL_OW 74
93303: ST_TO_ADDR
// if not x then
93304: LD_VAR 0 10
93308: NOT
93309: IFFALSE 93313
// continue ;
93311: GO 92745
// if GetLives ( x ) < 1000 then
93313: LD_VAR 0 10
93317: PPUSH
93318: CALL_OW 256
93322: PUSH
93323: LD_INT 1000
93325: LESS
93326: IFFALSE 93350
// ComRepairVehicle ( group [ i ] , x ) else
93328: LD_VAR 0 4
93332: PUSH
93333: LD_VAR 0 7
93337: ARRAY
93338: PPUSH
93339: LD_VAR 0 10
93343: PPUSH
93344: CALL_OW 129
93348: GO 93398
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
93350: LD_VAR 0 23
93354: PUSH
93355: LD_VAR 0 4
93359: PUSH
93360: LD_VAR 0 7
93364: ARRAY
93365: PPUSH
93366: CALL_OW 256
93370: PUSH
93371: LD_INT 1000
93373: LESS
93374: AND
93375: NOT
93376: IFFALSE 93398
// ComEnterUnit ( group [ i ] , x ) ;
93378: LD_VAR 0 4
93382: PUSH
93383: LD_VAR 0 7
93387: ARRAY
93388: PPUSH
93389: LD_VAR 0 10
93393: PPUSH
93394: CALL_OW 120
// end ; continue ;
93398: GO 92745
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
93400: LD_VAR 0 23
93404: PUSH
93405: LD_VAR 0 4
93409: PUSH
93410: LD_VAR 0 7
93414: ARRAY
93415: PPUSH
93416: CALL_OW 247
93420: PUSH
93421: LD_INT 1
93423: EQUAL
93424: AND
93425: IFFALSE 93903
// begin if group [ i ] in healers then
93427: LD_VAR 0 4
93431: PUSH
93432: LD_VAR 0 7
93436: ARRAY
93437: PUSH
93438: LD_VAR 0 31
93442: IN
93443: IFFALSE 93716
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
93445: LD_VAR 0 4
93449: PUSH
93450: LD_VAR 0 7
93454: ARRAY
93455: PPUSH
93456: LD_VAR 0 23
93460: PPUSH
93461: CALL_OW 308
93465: NOT
93466: PUSH
93467: LD_VAR 0 4
93471: PUSH
93472: LD_VAR 0 7
93476: ARRAY
93477: PPUSH
93478: CALL_OW 314
93482: NOT
93483: AND
93484: IFFALSE 93508
// ComMoveToArea ( group [ i ] , f_heal ) else
93486: LD_VAR 0 4
93490: PUSH
93491: LD_VAR 0 7
93495: ARRAY
93496: PPUSH
93497: LD_VAR 0 23
93501: PPUSH
93502: CALL_OW 113
93506: GO 93714
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
93508: LD_VAR 0 4
93512: PUSH
93513: LD_VAR 0 7
93517: ARRAY
93518: PPUSH
93519: CALL 47610 0 1
93523: PPUSH
93524: CALL_OW 256
93528: PUSH
93529: LD_INT 1000
93531: EQUAL
93532: IFFALSE 93551
// ComStop ( group [ i ] ) else
93534: LD_VAR 0 4
93538: PUSH
93539: LD_VAR 0 7
93543: ARRAY
93544: PPUSH
93545: CALL_OW 141
93549: GO 93714
// if not HasTask ( group [ i ] ) and to_heal then
93551: LD_VAR 0 4
93555: PUSH
93556: LD_VAR 0 7
93560: ARRAY
93561: PPUSH
93562: CALL_OW 314
93566: NOT
93567: PUSH
93568: LD_VAR 0 30
93572: AND
93573: IFFALSE 93714
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
93575: LD_ADDR_VAR 0 13
93579: PUSH
93580: LD_VAR 0 30
93584: PPUSH
93585: LD_INT 3
93587: PUSH
93588: LD_INT 54
93590: PUSH
93591: EMPTY
93592: LIST
93593: PUSH
93594: EMPTY
93595: LIST
93596: LIST
93597: PPUSH
93598: CALL_OW 72
93602: PPUSH
93603: LD_VAR 0 4
93607: PUSH
93608: LD_VAR 0 7
93612: ARRAY
93613: PPUSH
93614: CALL_OW 74
93618: ST_TO_ADDR
// if z then
93619: LD_VAR 0 13
93623: IFFALSE 93714
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
93625: LD_INT 91
93627: PUSH
93628: LD_VAR 0 13
93632: PUSH
93633: LD_INT 10
93635: PUSH
93636: EMPTY
93637: LIST
93638: LIST
93639: LIST
93640: PUSH
93641: LD_INT 81
93643: PUSH
93644: LD_VAR 0 13
93648: PPUSH
93649: CALL_OW 255
93653: PUSH
93654: EMPTY
93655: LIST
93656: LIST
93657: PUSH
93658: EMPTY
93659: LIST
93660: LIST
93661: PPUSH
93662: CALL_OW 69
93666: PUSH
93667: LD_INT 0
93669: EQUAL
93670: IFFALSE 93694
// ComHeal ( group [ i ] , z ) else
93672: LD_VAR 0 4
93676: PUSH
93677: LD_VAR 0 7
93681: ARRAY
93682: PPUSH
93683: LD_VAR 0 13
93687: PPUSH
93688: CALL_OW 128
93692: GO 93714
// ComMoveToArea ( group [ i ] , f_heal ) ;
93694: LD_VAR 0 4
93698: PUSH
93699: LD_VAR 0 7
93703: ARRAY
93704: PPUSH
93705: LD_VAR 0 23
93709: PPUSH
93710: CALL_OW 113
// end ; continue ;
93714: GO 92745
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
93716: LD_VAR 0 4
93720: PUSH
93721: LD_VAR 0 7
93725: ARRAY
93726: PPUSH
93727: CALL_OW 256
93731: PUSH
93732: LD_INT 700
93734: LESS
93735: PUSH
93736: LD_VAR 0 4
93740: PUSH
93741: LD_VAR 0 7
93745: ARRAY
93746: PUSH
93747: LD_VAR 0 30
93751: IN
93752: NOT
93753: AND
93754: IFFALSE 93778
// to_heal := to_heal union group [ i ] ;
93756: LD_ADDR_VAR 0 30
93760: PUSH
93761: LD_VAR 0 30
93765: PUSH
93766: LD_VAR 0 4
93770: PUSH
93771: LD_VAR 0 7
93775: ARRAY
93776: UNION
93777: ST_TO_ADDR
// if group [ i ] in to_heal then
93778: LD_VAR 0 4
93782: PUSH
93783: LD_VAR 0 7
93787: ARRAY
93788: PUSH
93789: LD_VAR 0 30
93793: IN
93794: IFFALSE 93903
// begin if GetLives ( group [ i ] ) = 1000 then
93796: LD_VAR 0 4
93800: PUSH
93801: LD_VAR 0 7
93805: ARRAY
93806: PPUSH
93807: CALL_OW 256
93811: PUSH
93812: LD_INT 1000
93814: EQUAL
93815: IFFALSE 93841
// to_heal := to_heal diff group [ i ] else
93817: LD_ADDR_VAR 0 30
93821: PUSH
93822: LD_VAR 0 30
93826: PUSH
93827: LD_VAR 0 4
93831: PUSH
93832: LD_VAR 0 7
93836: ARRAY
93837: DIFF
93838: ST_TO_ADDR
93839: GO 93903
// begin if not IsInArea ( group [ i ] , to_heal ) then
93841: LD_VAR 0 4
93845: PUSH
93846: LD_VAR 0 7
93850: ARRAY
93851: PPUSH
93852: LD_VAR 0 30
93856: PPUSH
93857: CALL_OW 308
93861: NOT
93862: IFFALSE 93886
// ComMoveToArea ( group [ i ] , f_heal ) else
93864: LD_VAR 0 4
93868: PUSH
93869: LD_VAR 0 7
93873: ARRAY
93874: PPUSH
93875: LD_VAR 0 23
93879: PPUSH
93880: CALL_OW 113
93884: GO 93901
// ComHold ( group [ i ] ) ;
93886: LD_VAR 0 4
93890: PUSH
93891: LD_VAR 0 7
93895: ARRAY
93896: PPUSH
93897: CALL_OW 140
// continue ;
93901: GO 92745
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
93903: LD_VAR 0 4
93907: PUSH
93908: LD_VAR 0 7
93912: ARRAY
93913: PPUSH
93914: LD_INT 10
93916: PPUSH
93917: CALL 46030 0 2
93921: NOT
93922: PUSH
93923: LD_VAR 0 16
93927: PUSH
93928: LD_VAR 0 7
93932: ARRAY
93933: PUSH
93934: EMPTY
93935: EQUAL
93936: NOT
93937: AND
93938: IFFALSE 94204
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
93940: LD_VAR 0 4
93944: PUSH
93945: LD_VAR 0 7
93949: ARRAY
93950: PPUSH
93951: CALL_OW 262
93955: PUSH
93956: LD_INT 1
93958: PUSH
93959: LD_INT 2
93961: PUSH
93962: EMPTY
93963: LIST
93964: LIST
93965: IN
93966: IFFALSE 94007
// if GetFuel ( group [ i ] ) < 10 then
93968: LD_VAR 0 4
93972: PUSH
93973: LD_VAR 0 7
93977: ARRAY
93978: PPUSH
93979: CALL_OW 261
93983: PUSH
93984: LD_INT 10
93986: LESS
93987: IFFALSE 94007
// SetFuel ( group [ i ] , 12 ) ;
93989: LD_VAR 0 4
93993: PUSH
93994: LD_VAR 0 7
93998: ARRAY
93999: PPUSH
94000: LD_INT 12
94002: PPUSH
94003: CALL_OW 240
// if units_path [ i ] then
94007: LD_VAR 0 16
94011: PUSH
94012: LD_VAR 0 7
94016: ARRAY
94017: IFFALSE 94202
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
94019: LD_VAR 0 4
94023: PUSH
94024: LD_VAR 0 7
94028: ARRAY
94029: PPUSH
94030: LD_VAR 0 16
94034: PUSH
94035: LD_VAR 0 7
94039: ARRAY
94040: PUSH
94041: LD_INT 1
94043: ARRAY
94044: PUSH
94045: LD_INT 1
94047: ARRAY
94048: PPUSH
94049: LD_VAR 0 16
94053: PUSH
94054: LD_VAR 0 7
94058: ARRAY
94059: PUSH
94060: LD_INT 1
94062: ARRAY
94063: PUSH
94064: LD_INT 2
94066: ARRAY
94067: PPUSH
94068: CALL_OW 297
94072: PUSH
94073: LD_INT 6
94075: GREATER
94076: IFFALSE 94151
// begin if not HasTask ( group [ i ] ) then
94078: LD_VAR 0 4
94082: PUSH
94083: LD_VAR 0 7
94087: ARRAY
94088: PPUSH
94089: CALL_OW 314
94093: NOT
94094: IFFALSE 94149
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
94096: LD_VAR 0 4
94100: PUSH
94101: LD_VAR 0 7
94105: ARRAY
94106: PPUSH
94107: LD_VAR 0 16
94111: PUSH
94112: LD_VAR 0 7
94116: ARRAY
94117: PUSH
94118: LD_INT 1
94120: ARRAY
94121: PUSH
94122: LD_INT 1
94124: ARRAY
94125: PPUSH
94126: LD_VAR 0 16
94130: PUSH
94131: LD_VAR 0 7
94135: ARRAY
94136: PUSH
94137: LD_INT 1
94139: ARRAY
94140: PUSH
94141: LD_INT 2
94143: ARRAY
94144: PPUSH
94145: CALL_OW 114
// end else
94149: GO 94202
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
94151: LD_ADDR_VAR 0 15
94155: PUSH
94156: LD_VAR 0 16
94160: PUSH
94161: LD_VAR 0 7
94165: ARRAY
94166: PPUSH
94167: LD_INT 1
94169: PPUSH
94170: CALL_OW 3
94174: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
94175: LD_ADDR_VAR 0 16
94179: PUSH
94180: LD_VAR 0 16
94184: PPUSH
94185: LD_VAR 0 7
94189: PPUSH
94190: LD_VAR 0 15
94194: PPUSH
94195: CALL_OW 1
94199: ST_TO_ADDR
// continue ;
94200: GO 92745
// end ; end ; end else
94202: GO 96866
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
94204: LD_ADDR_VAR 0 14
94208: PUSH
94209: LD_INT 81
94211: PUSH
94212: LD_VAR 0 4
94216: PUSH
94217: LD_VAR 0 7
94221: ARRAY
94222: PPUSH
94223: CALL_OW 255
94227: PUSH
94228: EMPTY
94229: LIST
94230: LIST
94231: PPUSH
94232: CALL_OW 69
94236: ST_TO_ADDR
// if not tmp then
94237: LD_VAR 0 14
94241: NOT
94242: IFFALSE 94246
// continue ;
94244: GO 92745
// if f_ignore_area then
94246: LD_VAR 0 17
94250: IFFALSE 94338
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
94252: LD_ADDR_VAR 0 15
94256: PUSH
94257: LD_VAR 0 14
94261: PPUSH
94262: LD_INT 3
94264: PUSH
94265: LD_INT 92
94267: PUSH
94268: LD_VAR 0 17
94272: PUSH
94273: LD_INT 1
94275: ARRAY
94276: PUSH
94277: LD_VAR 0 17
94281: PUSH
94282: LD_INT 2
94284: ARRAY
94285: PUSH
94286: LD_VAR 0 17
94290: PUSH
94291: LD_INT 3
94293: ARRAY
94294: PUSH
94295: EMPTY
94296: LIST
94297: LIST
94298: LIST
94299: LIST
94300: PUSH
94301: EMPTY
94302: LIST
94303: LIST
94304: PPUSH
94305: CALL_OW 72
94309: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
94310: LD_VAR 0 14
94314: PUSH
94315: LD_VAR 0 15
94319: DIFF
94320: IFFALSE 94338
// tmp := tmp diff tmp2 ;
94322: LD_ADDR_VAR 0 14
94326: PUSH
94327: LD_VAR 0 14
94331: PUSH
94332: LD_VAR 0 15
94336: DIFF
94337: ST_TO_ADDR
// end ; if not f_murder then
94338: LD_VAR 0 20
94342: NOT
94343: IFFALSE 94401
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
94345: LD_ADDR_VAR 0 15
94349: PUSH
94350: LD_VAR 0 14
94354: PPUSH
94355: LD_INT 3
94357: PUSH
94358: LD_INT 50
94360: PUSH
94361: EMPTY
94362: LIST
94363: PUSH
94364: EMPTY
94365: LIST
94366: LIST
94367: PPUSH
94368: CALL_OW 72
94372: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
94373: LD_VAR 0 14
94377: PUSH
94378: LD_VAR 0 15
94382: DIFF
94383: IFFALSE 94401
// tmp := tmp diff tmp2 ;
94385: LD_ADDR_VAR 0 14
94389: PUSH
94390: LD_VAR 0 14
94394: PUSH
94395: LD_VAR 0 15
94399: DIFF
94400: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
94401: LD_ADDR_VAR 0 14
94405: PUSH
94406: LD_VAR 0 4
94410: PUSH
94411: LD_VAR 0 7
94415: ARRAY
94416: PPUSH
94417: LD_VAR 0 14
94421: PPUSH
94422: LD_INT 1
94424: PPUSH
94425: LD_INT 1
94427: PPUSH
94428: CALL 19673 0 4
94432: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
94433: LD_VAR 0 4
94437: PUSH
94438: LD_VAR 0 7
94442: ARRAY
94443: PPUSH
94444: CALL_OW 257
94448: PUSH
94449: LD_INT 1
94451: EQUAL
94452: IFFALSE 94900
// begin if WantPlant ( group [ i ] ) then
94454: LD_VAR 0 4
94458: PUSH
94459: LD_VAR 0 7
94463: ARRAY
94464: PPUSH
94465: CALL 19174 0 1
94469: IFFALSE 94473
// continue ;
94471: GO 92745
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
94473: LD_VAR 0 18
94477: PUSH
94478: LD_VAR 0 4
94482: PUSH
94483: LD_VAR 0 7
94487: ARRAY
94488: PPUSH
94489: CALL_OW 310
94493: NOT
94494: AND
94495: PUSH
94496: LD_VAR 0 14
94500: PUSH
94501: LD_INT 1
94503: ARRAY
94504: PUSH
94505: LD_VAR 0 14
94509: PPUSH
94510: LD_INT 21
94512: PUSH
94513: LD_INT 2
94515: PUSH
94516: EMPTY
94517: LIST
94518: LIST
94519: PUSH
94520: LD_INT 58
94522: PUSH
94523: EMPTY
94524: LIST
94525: PUSH
94526: EMPTY
94527: LIST
94528: LIST
94529: PPUSH
94530: CALL_OW 72
94534: IN
94535: AND
94536: IFFALSE 94572
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
94538: LD_VAR 0 4
94542: PUSH
94543: LD_VAR 0 7
94547: ARRAY
94548: PPUSH
94549: LD_VAR 0 14
94553: PUSH
94554: LD_INT 1
94556: ARRAY
94557: PPUSH
94558: CALL_OW 120
// attacking := true ;
94562: LD_ADDR_VAR 0 29
94566: PUSH
94567: LD_INT 1
94569: ST_TO_ADDR
// continue ;
94570: GO 92745
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
94572: LD_VAR 0 26
94576: PUSH
94577: LD_VAR 0 4
94581: PUSH
94582: LD_VAR 0 7
94586: ARRAY
94587: PPUSH
94588: CALL_OW 257
94592: PUSH
94593: LD_INT 1
94595: EQUAL
94596: AND
94597: PUSH
94598: LD_VAR 0 4
94602: PUSH
94603: LD_VAR 0 7
94607: ARRAY
94608: PPUSH
94609: CALL_OW 256
94613: PUSH
94614: LD_INT 800
94616: LESS
94617: AND
94618: PUSH
94619: LD_VAR 0 4
94623: PUSH
94624: LD_VAR 0 7
94628: ARRAY
94629: PPUSH
94630: CALL_OW 318
94634: NOT
94635: AND
94636: IFFALSE 94653
// ComCrawl ( group [ i ] ) ;
94638: LD_VAR 0 4
94642: PUSH
94643: LD_VAR 0 7
94647: ARRAY
94648: PPUSH
94649: CALL_OW 137
// if f_mines then
94653: LD_VAR 0 21
94657: IFFALSE 94900
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
94659: LD_VAR 0 14
94663: PUSH
94664: LD_INT 1
94666: ARRAY
94667: PPUSH
94668: CALL_OW 247
94672: PUSH
94673: LD_INT 3
94675: EQUAL
94676: PUSH
94677: LD_VAR 0 14
94681: PUSH
94682: LD_INT 1
94684: ARRAY
94685: PUSH
94686: LD_VAR 0 27
94690: IN
94691: NOT
94692: AND
94693: IFFALSE 94900
// begin x := GetX ( tmp [ 1 ] ) ;
94695: LD_ADDR_VAR 0 10
94699: PUSH
94700: LD_VAR 0 14
94704: PUSH
94705: LD_INT 1
94707: ARRAY
94708: PPUSH
94709: CALL_OW 250
94713: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
94714: LD_ADDR_VAR 0 11
94718: PUSH
94719: LD_VAR 0 14
94723: PUSH
94724: LD_INT 1
94726: ARRAY
94727: PPUSH
94728: CALL_OW 251
94732: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
94733: LD_ADDR_VAR 0 12
94737: PUSH
94738: LD_VAR 0 4
94742: PUSH
94743: LD_VAR 0 7
94747: ARRAY
94748: PPUSH
94749: CALL 46115 0 1
94753: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
94754: LD_VAR 0 4
94758: PUSH
94759: LD_VAR 0 7
94763: ARRAY
94764: PPUSH
94765: LD_VAR 0 10
94769: PPUSH
94770: LD_VAR 0 11
94774: PPUSH
94775: LD_VAR 0 14
94779: PUSH
94780: LD_INT 1
94782: ARRAY
94783: PPUSH
94784: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
94788: LD_VAR 0 4
94792: PUSH
94793: LD_VAR 0 7
94797: ARRAY
94798: PPUSH
94799: LD_VAR 0 10
94803: PPUSH
94804: LD_VAR 0 12
94808: PPUSH
94809: LD_INT 7
94811: PPUSH
94812: CALL_OW 272
94816: PPUSH
94817: LD_VAR 0 11
94821: PPUSH
94822: LD_VAR 0 12
94826: PPUSH
94827: LD_INT 7
94829: PPUSH
94830: CALL_OW 273
94834: PPUSH
94835: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
94839: LD_VAR 0 4
94843: PUSH
94844: LD_VAR 0 7
94848: ARRAY
94849: PPUSH
94850: LD_INT 71
94852: PPUSH
94853: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
94857: LD_ADDR_VAR 0 27
94861: PUSH
94862: LD_VAR 0 27
94866: PPUSH
94867: LD_VAR 0 27
94871: PUSH
94872: LD_INT 1
94874: PLUS
94875: PPUSH
94876: LD_VAR 0 14
94880: PUSH
94881: LD_INT 1
94883: ARRAY
94884: PPUSH
94885: CALL_OW 1
94889: ST_TO_ADDR
// attacking := true ;
94890: LD_ADDR_VAR 0 29
94894: PUSH
94895: LD_INT 1
94897: ST_TO_ADDR
// continue ;
94898: GO 92745
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
94900: LD_VAR 0 4
94904: PUSH
94905: LD_VAR 0 7
94909: ARRAY
94910: PPUSH
94911: CALL_OW 257
94915: PUSH
94916: LD_INT 17
94918: EQUAL
94919: PUSH
94920: LD_VAR 0 4
94924: PUSH
94925: LD_VAR 0 7
94929: ARRAY
94930: PPUSH
94931: CALL_OW 110
94935: PUSH
94936: LD_INT 71
94938: EQUAL
94939: NOT
94940: AND
94941: IFFALSE 95087
// begin attacking := false ;
94943: LD_ADDR_VAR 0 29
94947: PUSH
94948: LD_INT 0
94950: ST_TO_ADDR
// k := 5 ;
94951: LD_ADDR_VAR 0 9
94955: PUSH
94956: LD_INT 5
94958: ST_TO_ADDR
// if tmp < k then
94959: LD_VAR 0 14
94963: PUSH
94964: LD_VAR 0 9
94968: LESS
94969: IFFALSE 94981
// k := tmp ;
94971: LD_ADDR_VAR 0 9
94975: PUSH
94976: LD_VAR 0 14
94980: ST_TO_ADDR
// for j = 1 to k do
94981: LD_ADDR_VAR 0 8
94985: PUSH
94986: DOUBLE
94987: LD_INT 1
94989: DEC
94990: ST_TO_ADDR
94991: LD_VAR 0 9
94995: PUSH
94996: FOR_TO
94997: IFFALSE 95085
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
94999: LD_VAR 0 14
95003: PUSH
95004: LD_VAR 0 8
95008: ARRAY
95009: PUSH
95010: LD_VAR 0 14
95014: PPUSH
95015: LD_INT 58
95017: PUSH
95018: EMPTY
95019: LIST
95020: PPUSH
95021: CALL_OW 72
95025: IN
95026: NOT
95027: IFFALSE 95083
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
95029: LD_VAR 0 4
95033: PUSH
95034: LD_VAR 0 7
95038: ARRAY
95039: PPUSH
95040: LD_VAR 0 14
95044: PUSH
95045: LD_VAR 0 8
95049: ARRAY
95050: PPUSH
95051: CALL_OW 115
// attacking := true ;
95055: LD_ADDR_VAR 0 29
95059: PUSH
95060: LD_INT 1
95062: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
95063: LD_VAR 0 4
95067: PUSH
95068: LD_VAR 0 7
95072: ARRAY
95073: PPUSH
95074: LD_INT 71
95076: PPUSH
95077: CALL_OW 109
// continue ;
95081: GO 94996
// end ; end ;
95083: GO 94996
95085: POP
95086: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
95087: LD_VAR 0 4
95091: PUSH
95092: LD_VAR 0 7
95096: ARRAY
95097: PPUSH
95098: CALL_OW 257
95102: PUSH
95103: LD_INT 8
95105: EQUAL
95106: PUSH
95107: LD_VAR 0 4
95111: PUSH
95112: LD_VAR 0 7
95116: ARRAY
95117: PPUSH
95118: CALL_OW 264
95122: PUSH
95123: LD_INT 28
95125: PUSH
95126: LD_INT 45
95128: PUSH
95129: LD_INT 7
95131: PUSH
95132: LD_INT 47
95134: PUSH
95135: EMPTY
95136: LIST
95137: LIST
95138: LIST
95139: LIST
95140: IN
95141: OR
95142: IFFALSE 95398
// begin attacking := false ;
95144: LD_ADDR_VAR 0 29
95148: PUSH
95149: LD_INT 0
95151: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
95152: LD_VAR 0 14
95156: PUSH
95157: LD_INT 1
95159: ARRAY
95160: PPUSH
95161: CALL_OW 266
95165: PUSH
95166: LD_INT 32
95168: PUSH
95169: LD_INT 31
95171: PUSH
95172: LD_INT 33
95174: PUSH
95175: LD_INT 4
95177: PUSH
95178: LD_INT 5
95180: PUSH
95181: EMPTY
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: IN
95188: IFFALSE 95374
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
95190: LD_ADDR_VAR 0 9
95194: PUSH
95195: LD_VAR 0 14
95199: PUSH
95200: LD_INT 1
95202: ARRAY
95203: PPUSH
95204: CALL_OW 266
95208: PPUSH
95209: LD_VAR 0 14
95213: PUSH
95214: LD_INT 1
95216: ARRAY
95217: PPUSH
95218: CALL_OW 250
95222: PPUSH
95223: LD_VAR 0 14
95227: PUSH
95228: LD_INT 1
95230: ARRAY
95231: PPUSH
95232: CALL_OW 251
95236: PPUSH
95237: LD_VAR 0 14
95241: PUSH
95242: LD_INT 1
95244: ARRAY
95245: PPUSH
95246: CALL_OW 254
95250: PPUSH
95251: LD_VAR 0 14
95255: PUSH
95256: LD_INT 1
95258: ARRAY
95259: PPUSH
95260: CALL_OW 248
95264: PPUSH
95265: LD_INT 0
95267: PPUSH
95268: CALL 27485 0 6
95272: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
95273: LD_ADDR_VAR 0 8
95277: PUSH
95278: LD_VAR 0 4
95282: PUSH
95283: LD_VAR 0 7
95287: ARRAY
95288: PPUSH
95289: LD_VAR 0 9
95293: PPUSH
95294: CALL 46155 0 2
95298: ST_TO_ADDR
// if j then
95299: LD_VAR 0 8
95303: IFFALSE 95372
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
95305: LD_VAR 0 8
95309: PUSH
95310: LD_INT 1
95312: ARRAY
95313: PPUSH
95314: LD_VAR 0 8
95318: PUSH
95319: LD_INT 2
95321: ARRAY
95322: PPUSH
95323: CALL_OW 488
95327: IFFALSE 95372
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
95329: LD_VAR 0 4
95333: PUSH
95334: LD_VAR 0 7
95338: ARRAY
95339: PPUSH
95340: LD_VAR 0 8
95344: PUSH
95345: LD_INT 1
95347: ARRAY
95348: PPUSH
95349: LD_VAR 0 8
95353: PUSH
95354: LD_INT 2
95356: ARRAY
95357: PPUSH
95358: CALL_OW 116
// attacking := true ;
95362: LD_ADDR_VAR 0 29
95366: PUSH
95367: LD_INT 1
95369: ST_TO_ADDR
// continue ;
95370: GO 92745
// end ; end else
95372: GO 95398
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
95374: LD_VAR 0 4
95378: PUSH
95379: LD_VAR 0 7
95383: ARRAY
95384: PPUSH
95385: LD_VAR 0 14
95389: PUSH
95390: LD_INT 1
95392: ARRAY
95393: PPUSH
95394: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
95398: LD_VAR 0 4
95402: PUSH
95403: LD_VAR 0 7
95407: ARRAY
95408: PPUSH
95409: CALL_OW 265
95413: PUSH
95414: LD_INT 11
95416: EQUAL
95417: IFFALSE 95695
// begin k := 10 ;
95419: LD_ADDR_VAR 0 9
95423: PUSH
95424: LD_INT 10
95426: ST_TO_ADDR
// x := 0 ;
95427: LD_ADDR_VAR 0 10
95431: PUSH
95432: LD_INT 0
95434: ST_TO_ADDR
// if tmp < k then
95435: LD_VAR 0 14
95439: PUSH
95440: LD_VAR 0 9
95444: LESS
95445: IFFALSE 95457
// k := tmp ;
95447: LD_ADDR_VAR 0 9
95451: PUSH
95452: LD_VAR 0 14
95456: ST_TO_ADDR
// for j = k downto 1 do
95457: LD_ADDR_VAR 0 8
95461: PUSH
95462: DOUBLE
95463: LD_VAR 0 9
95467: INC
95468: ST_TO_ADDR
95469: LD_INT 1
95471: PUSH
95472: FOR_DOWNTO
95473: IFFALSE 95548
// begin if GetType ( tmp [ j ] ) = unit_human then
95475: LD_VAR 0 14
95479: PUSH
95480: LD_VAR 0 8
95484: ARRAY
95485: PPUSH
95486: CALL_OW 247
95490: PUSH
95491: LD_INT 1
95493: EQUAL
95494: IFFALSE 95546
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
95496: LD_VAR 0 4
95500: PUSH
95501: LD_VAR 0 7
95505: ARRAY
95506: PPUSH
95507: LD_VAR 0 14
95511: PUSH
95512: LD_VAR 0 8
95516: ARRAY
95517: PPUSH
95518: CALL 46426 0 2
// x := tmp [ j ] ;
95522: LD_ADDR_VAR 0 10
95526: PUSH
95527: LD_VAR 0 14
95531: PUSH
95532: LD_VAR 0 8
95536: ARRAY
95537: ST_TO_ADDR
// attacking := true ;
95538: LD_ADDR_VAR 0 29
95542: PUSH
95543: LD_INT 1
95545: ST_TO_ADDR
// end ; end ;
95546: GO 95472
95548: POP
95549: POP
// if not x then
95550: LD_VAR 0 10
95554: NOT
95555: IFFALSE 95695
// begin attacking := true ;
95557: LD_ADDR_VAR 0 29
95561: PUSH
95562: LD_INT 1
95564: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
95565: LD_VAR 0 4
95569: PUSH
95570: LD_VAR 0 7
95574: ARRAY
95575: PPUSH
95576: CALL_OW 250
95580: PPUSH
95581: LD_VAR 0 4
95585: PUSH
95586: LD_VAR 0 7
95590: ARRAY
95591: PPUSH
95592: CALL_OW 251
95596: PPUSH
95597: CALL_OW 546
95601: PUSH
95602: LD_INT 2
95604: ARRAY
95605: PUSH
95606: LD_VAR 0 14
95610: PUSH
95611: LD_INT 1
95613: ARRAY
95614: PPUSH
95615: CALL_OW 250
95619: PPUSH
95620: LD_VAR 0 14
95624: PUSH
95625: LD_INT 1
95627: ARRAY
95628: PPUSH
95629: CALL_OW 251
95633: PPUSH
95634: CALL_OW 546
95638: PUSH
95639: LD_INT 2
95641: ARRAY
95642: EQUAL
95643: IFFALSE 95671
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
95645: LD_VAR 0 4
95649: PUSH
95650: LD_VAR 0 7
95654: ARRAY
95655: PPUSH
95656: LD_VAR 0 14
95660: PUSH
95661: LD_INT 1
95663: ARRAY
95664: PPUSH
95665: CALL 46426 0 2
95669: GO 95695
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
95671: LD_VAR 0 4
95675: PUSH
95676: LD_VAR 0 7
95680: ARRAY
95681: PPUSH
95682: LD_VAR 0 14
95686: PUSH
95687: LD_INT 1
95689: ARRAY
95690: PPUSH
95691: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
95695: LD_VAR 0 4
95699: PUSH
95700: LD_VAR 0 7
95704: ARRAY
95705: PPUSH
95706: CALL_OW 264
95710: PUSH
95711: LD_INT 29
95713: EQUAL
95714: IFFALSE 96080
// begin if WantsToAttack ( group [ i ] ) in bombed then
95716: LD_VAR 0 4
95720: PUSH
95721: LD_VAR 0 7
95725: ARRAY
95726: PPUSH
95727: CALL_OW 319
95731: PUSH
95732: LD_VAR 0 28
95736: IN
95737: IFFALSE 95741
// continue ;
95739: GO 92745
// k := 8 ;
95741: LD_ADDR_VAR 0 9
95745: PUSH
95746: LD_INT 8
95748: ST_TO_ADDR
// x := 0 ;
95749: LD_ADDR_VAR 0 10
95753: PUSH
95754: LD_INT 0
95756: ST_TO_ADDR
// if tmp < k then
95757: LD_VAR 0 14
95761: PUSH
95762: LD_VAR 0 9
95766: LESS
95767: IFFALSE 95779
// k := tmp ;
95769: LD_ADDR_VAR 0 9
95773: PUSH
95774: LD_VAR 0 14
95778: ST_TO_ADDR
// for j = 1 to k do
95779: LD_ADDR_VAR 0 8
95783: PUSH
95784: DOUBLE
95785: LD_INT 1
95787: DEC
95788: ST_TO_ADDR
95789: LD_VAR 0 9
95793: PUSH
95794: FOR_TO
95795: IFFALSE 95927
// begin if GetType ( tmp [ j ] ) = unit_building then
95797: LD_VAR 0 14
95801: PUSH
95802: LD_VAR 0 8
95806: ARRAY
95807: PPUSH
95808: CALL_OW 247
95812: PUSH
95813: LD_INT 3
95815: EQUAL
95816: IFFALSE 95925
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
95818: LD_VAR 0 14
95822: PUSH
95823: LD_VAR 0 8
95827: ARRAY
95828: PUSH
95829: LD_VAR 0 28
95833: IN
95834: NOT
95835: PUSH
95836: LD_VAR 0 14
95840: PUSH
95841: LD_VAR 0 8
95845: ARRAY
95846: PPUSH
95847: CALL_OW 313
95851: AND
95852: IFFALSE 95925
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
95854: LD_VAR 0 4
95858: PUSH
95859: LD_VAR 0 7
95863: ARRAY
95864: PPUSH
95865: LD_VAR 0 14
95869: PUSH
95870: LD_VAR 0 8
95874: ARRAY
95875: PPUSH
95876: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
95880: LD_ADDR_VAR 0 28
95884: PUSH
95885: LD_VAR 0 28
95889: PPUSH
95890: LD_VAR 0 28
95894: PUSH
95895: LD_INT 1
95897: PLUS
95898: PPUSH
95899: LD_VAR 0 14
95903: PUSH
95904: LD_VAR 0 8
95908: ARRAY
95909: PPUSH
95910: CALL_OW 1
95914: ST_TO_ADDR
// attacking := true ;
95915: LD_ADDR_VAR 0 29
95919: PUSH
95920: LD_INT 1
95922: ST_TO_ADDR
// break ;
95923: GO 95927
// end ; end ;
95925: GO 95794
95927: POP
95928: POP
// if not attacking and f_attack_depot then
95929: LD_VAR 0 29
95933: NOT
95934: PUSH
95935: LD_VAR 0 25
95939: AND
95940: IFFALSE 96035
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
95942: LD_ADDR_VAR 0 13
95946: PUSH
95947: LD_VAR 0 14
95951: PPUSH
95952: LD_INT 2
95954: PUSH
95955: LD_INT 30
95957: PUSH
95958: LD_INT 0
95960: PUSH
95961: EMPTY
95962: LIST
95963: LIST
95964: PUSH
95965: LD_INT 30
95967: PUSH
95968: LD_INT 1
95970: PUSH
95971: EMPTY
95972: LIST
95973: LIST
95974: PUSH
95975: EMPTY
95976: LIST
95977: LIST
95978: LIST
95979: PPUSH
95980: CALL_OW 72
95984: ST_TO_ADDR
// if z then
95985: LD_VAR 0 13
95989: IFFALSE 96035
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
95991: LD_VAR 0 4
95995: PUSH
95996: LD_VAR 0 7
96000: ARRAY
96001: PPUSH
96002: LD_VAR 0 13
96006: PPUSH
96007: LD_VAR 0 4
96011: PUSH
96012: LD_VAR 0 7
96016: ARRAY
96017: PPUSH
96018: CALL_OW 74
96022: PPUSH
96023: CALL_OW 115
// attacking := true ;
96027: LD_ADDR_VAR 0 29
96031: PUSH
96032: LD_INT 1
96034: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
96035: LD_VAR 0 4
96039: PUSH
96040: LD_VAR 0 7
96044: ARRAY
96045: PPUSH
96046: CALL_OW 256
96050: PUSH
96051: LD_INT 500
96053: LESS
96054: IFFALSE 96080
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
96056: LD_VAR 0 4
96060: PUSH
96061: LD_VAR 0 7
96065: ARRAY
96066: PPUSH
96067: LD_VAR 0 14
96071: PUSH
96072: LD_INT 1
96074: ARRAY
96075: PPUSH
96076: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
96080: LD_VAR 0 4
96084: PUSH
96085: LD_VAR 0 7
96089: ARRAY
96090: PPUSH
96091: CALL_OW 264
96095: PUSH
96096: LD_INT 49
96098: EQUAL
96099: IFFALSE 96220
// begin if not HasTask ( group [ i ] ) then
96101: LD_VAR 0 4
96105: PUSH
96106: LD_VAR 0 7
96110: ARRAY
96111: PPUSH
96112: CALL_OW 314
96116: NOT
96117: IFFALSE 96220
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
96119: LD_ADDR_VAR 0 9
96123: PUSH
96124: LD_INT 81
96126: PUSH
96127: LD_VAR 0 4
96131: PUSH
96132: LD_VAR 0 7
96136: ARRAY
96137: PPUSH
96138: CALL_OW 255
96142: PUSH
96143: EMPTY
96144: LIST
96145: LIST
96146: PPUSH
96147: CALL_OW 69
96151: PPUSH
96152: LD_VAR 0 4
96156: PUSH
96157: LD_VAR 0 7
96161: ARRAY
96162: PPUSH
96163: CALL_OW 74
96167: ST_TO_ADDR
// if k then
96168: LD_VAR 0 9
96172: IFFALSE 96220
// if GetDistUnits ( group [ i ] , k ) > 10 then
96174: LD_VAR 0 4
96178: PUSH
96179: LD_VAR 0 7
96183: ARRAY
96184: PPUSH
96185: LD_VAR 0 9
96189: PPUSH
96190: CALL_OW 296
96194: PUSH
96195: LD_INT 10
96197: GREATER
96198: IFFALSE 96220
// ComMoveUnit ( group [ i ] , k ) ;
96200: LD_VAR 0 4
96204: PUSH
96205: LD_VAR 0 7
96209: ARRAY
96210: PPUSH
96211: LD_VAR 0 9
96215: PPUSH
96216: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
96220: LD_VAR 0 4
96224: PUSH
96225: LD_VAR 0 7
96229: ARRAY
96230: PPUSH
96231: CALL_OW 256
96235: PUSH
96236: LD_INT 250
96238: LESS
96239: PUSH
96240: LD_VAR 0 4
96244: PUSH
96245: LD_VAR 0 7
96249: ARRAY
96250: PUSH
96251: LD_INT 21
96253: PUSH
96254: LD_INT 2
96256: PUSH
96257: EMPTY
96258: LIST
96259: LIST
96260: PUSH
96261: LD_INT 23
96263: PUSH
96264: LD_INT 2
96266: PUSH
96267: EMPTY
96268: LIST
96269: LIST
96270: PUSH
96271: EMPTY
96272: LIST
96273: LIST
96274: PPUSH
96275: CALL_OW 69
96279: IN
96280: AND
96281: IFFALSE 96406
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
96283: LD_ADDR_VAR 0 9
96287: PUSH
96288: LD_OWVAR 3
96292: PUSH
96293: LD_VAR 0 4
96297: PUSH
96298: LD_VAR 0 7
96302: ARRAY
96303: DIFF
96304: PPUSH
96305: LD_VAR 0 4
96309: PUSH
96310: LD_VAR 0 7
96314: ARRAY
96315: PPUSH
96316: CALL_OW 74
96320: ST_TO_ADDR
// if not k then
96321: LD_VAR 0 9
96325: NOT
96326: IFFALSE 96330
// continue ;
96328: GO 92745
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
96330: LD_VAR 0 9
96334: PUSH
96335: LD_INT 81
96337: PUSH
96338: LD_VAR 0 4
96342: PUSH
96343: LD_VAR 0 7
96347: ARRAY
96348: PPUSH
96349: CALL_OW 255
96353: PUSH
96354: EMPTY
96355: LIST
96356: LIST
96357: PPUSH
96358: CALL_OW 69
96362: IN
96363: PUSH
96364: LD_VAR 0 9
96368: PPUSH
96369: LD_VAR 0 4
96373: PUSH
96374: LD_VAR 0 7
96378: ARRAY
96379: PPUSH
96380: CALL_OW 296
96384: PUSH
96385: LD_INT 5
96387: LESS
96388: AND
96389: IFFALSE 96406
// ComAutodestruct ( group [ i ] ) ;
96391: LD_VAR 0 4
96395: PUSH
96396: LD_VAR 0 7
96400: ARRAY
96401: PPUSH
96402: CALL 46324 0 1
// end ; if f_attack_depot then
96406: LD_VAR 0 25
96410: IFFALSE 96522
// begin k := 6 ;
96412: LD_ADDR_VAR 0 9
96416: PUSH
96417: LD_INT 6
96419: ST_TO_ADDR
// if tmp < k then
96420: LD_VAR 0 14
96424: PUSH
96425: LD_VAR 0 9
96429: LESS
96430: IFFALSE 96442
// k := tmp ;
96432: LD_ADDR_VAR 0 9
96436: PUSH
96437: LD_VAR 0 14
96441: ST_TO_ADDR
// for j = 1 to k do
96442: LD_ADDR_VAR 0 8
96446: PUSH
96447: DOUBLE
96448: LD_INT 1
96450: DEC
96451: ST_TO_ADDR
96452: LD_VAR 0 9
96456: PUSH
96457: FOR_TO
96458: IFFALSE 96520
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
96460: LD_VAR 0 8
96464: PPUSH
96465: CALL_OW 266
96469: PUSH
96470: LD_INT 0
96472: PUSH
96473: LD_INT 1
96475: PUSH
96476: EMPTY
96477: LIST
96478: LIST
96479: IN
96480: IFFALSE 96518
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
96482: LD_VAR 0 4
96486: PUSH
96487: LD_VAR 0 7
96491: ARRAY
96492: PPUSH
96493: LD_VAR 0 14
96497: PUSH
96498: LD_VAR 0 8
96502: ARRAY
96503: PPUSH
96504: CALL_OW 115
// attacking := true ;
96508: LD_ADDR_VAR 0 29
96512: PUSH
96513: LD_INT 1
96515: ST_TO_ADDR
// break ;
96516: GO 96520
// end ;
96518: GO 96457
96520: POP
96521: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
96522: LD_VAR 0 4
96526: PUSH
96527: LD_VAR 0 7
96531: ARRAY
96532: PPUSH
96533: CALL_OW 302
96537: PUSH
96538: LD_VAR 0 29
96542: NOT
96543: AND
96544: IFFALSE 96866
// begin if GetTag ( group [ i ] ) = 71 then
96546: LD_VAR 0 4
96550: PUSH
96551: LD_VAR 0 7
96555: ARRAY
96556: PPUSH
96557: CALL_OW 110
96561: PUSH
96562: LD_INT 71
96564: EQUAL
96565: IFFALSE 96606
// begin if HasTask ( group [ i ] ) then
96567: LD_VAR 0 4
96571: PUSH
96572: LD_VAR 0 7
96576: ARRAY
96577: PPUSH
96578: CALL_OW 314
96582: IFFALSE 96588
// continue else
96584: GO 92745
96586: GO 96606
// SetTag ( group [ i ] , 0 ) ;
96588: LD_VAR 0 4
96592: PUSH
96593: LD_VAR 0 7
96597: ARRAY
96598: PPUSH
96599: LD_INT 0
96601: PPUSH
96602: CALL_OW 109
// end ; k := 8 ;
96606: LD_ADDR_VAR 0 9
96610: PUSH
96611: LD_INT 8
96613: ST_TO_ADDR
// x := 0 ;
96614: LD_ADDR_VAR 0 10
96618: PUSH
96619: LD_INT 0
96621: ST_TO_ADDR
// if tmp < k then
96622: LD_VAR 0 14
96626: PUSH
96627: LD_VAR 0 9
96631: LESS
96632: IFFALSE 96644
// k := tmp ;
96634: LD_ADDR_VAR 0 9
96638: PUSH
96639: LD_VAR 0 14
96643: ST_TO_ADDR
// for j = 1 to k do
96644: LD_ADDR_VAR 0 8
96648: PUSH
96649: DOUBLE
96650: LD_INT 1
96652: DEC
96653: ST_TO_ADDR
96654: LD_VAR 0 9
96658: PUSH
96659: FOR_TO
96660: IFFALSE 96758
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
96662: LD_VAR 0 14
96666: PUSH
96667: LD_VAR 0 8
96671: ARRAY
96672: PPUSH
96673: CALL_OW 247
96677: PUSH
96678: LD_INT 1
96680: EQUAL
96681: PUSH
96682: LD_VAR 0 14
96686: PUSH
96687: LD_VAR 0 8
96691: ARRAY
96692: PPUSH
96693: CALL_OW 256
96697: PUSH
96698: LD_INT 250
96700: LESS
96701: PUSH
96702: LD_VAR 0 20
96706: AND
96707: PUSH
96708: LD_VAR 0 20
96712: NOT
96713: PUSH
96714: LD_VAR 0 14
96718: PUSH
96719: LD_VAR 0 8
96723: ARRAY
96724: PPUSH
96725: CALL_OW 256
96729: PUSH
96730: LD_INT 250
96732: GREATEREQUAL
96733: AND
96734: OR
96735: AND
96736: IFFALSE 96756
// begin x := tmp [ j ] ;
96738: LD_ADDR_VAR 0 10
96742: PUSH
96743: LD_VAR 0 14
96747: PUSH
96748: LD_VAR 0 8
96752: ARRAY
96753: ST_TO_ADDR
// break ;
96754: GO 96758
// end ;
96756: GO 96659
96758: POP
96759: POP
// if x then
96760: LD_VAR 0 10
96764: IFFALSE 96788
// ComAttackUnit ( group [ i ] , x ) else
96766: LD_VAR 0 4
96770: PUSH
96771: LD_VAR 0 7
96775: ARRAY
96776: PPUSH
96777: LD_VAR 0 10
96781: PPUSH
96782: CALL_OW 115
96786: GO 96812
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
96788: LD_VAR 0 4
96792: PUSH
96793: LD_VAR 0 7
96797: ARRAY
96798: PPUSH
96799: LD_VAR 0 14
96803: PUSH
96804: LD_INT 1
96806: ARRAY
96807: PPUSH
96808: CALL_OW 115
// if not HasTask ( group [ i ] ) then
96812: LD_VAR 0 4
96816: PUSH
96817: LD_VAR 0 7
96821: ARRAY
96822: PPUSH
96823: CALL_OW 314
96827: NOT
96828: IFFALSE 96866
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
96830: LD_VAR 0 4
96834: PUSH
96835: LD_VAR 0 7
96839: ARRAY
96840: PPUSH
96841: LD_VAR 0 14
96845: PPUSH
96846: LD_VAR 0 4
96850: PUSH
96851: LD_VAR 0 7
96855: ARRAY
96856: PPUSH
96857: CALL_OW 74
96861: PPUSH
96862: CALL_OW 115
// end ; end ; end ;
96866: GO 92745
96868: POP
96869: POP
// wait ( 0 0$2 ) ;
96870: LD_INT 70
96872: PPUSH
96873: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
96877: LD_VAR 0 4
96881: NOT
96882: PUSH
96883: LD_VAR 0 4
96887: PUSH
96888: EMPTY
96889: EQUAL
96890: OR
96891: PUSH
96892: LD_INT 81
96894: PUSH
96895: LD_VAR 0 35
96899: PUSH
96900: EMPTY
96901: LIST
96902: LIST
96903: PPUSH
96904: CALL_OW 69
96908: NOT
96909: OR
96910: IFFALSE 92730
// end ;
96912: LD_VAR 0 2
96916: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
96917: LD_INT 0
96919: PPUSH
96920: PPUSH
96921: PPUSH
96922: PPUSH
96923: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
96924: LD_VAR 0 1
96928: NOT
96929: PUSH
96930: LD_EXP 59
96934: PUSH
96935: LD_VAR 0 1
96939: ARRAY
96940: NOT
96941: OR
96942: PUSH
96943: LD_VAR 0 2
96947: NOT
96948: OR
96949: PUSH
96950: LD_VAR 0 3
96954: NOT
96955: OR
96956: IFFALSE 96960
// exit ;
96958: GO 97473
// side := mc_sides [ base ] ;
96960: LD_ADDR_VAR 0 6
96964: PUSH
96965: LD_EXP 85
96969: PUSH
96970: LD_VAR 0 1
96974: ARRAY
96975: ST_TO_ADDR
// if not side then
96976: LD_VAR 0 6
96980: NOT
96981: IFFALSE 96985
// exit ;
96983: GO 97473
// for i in solds do
96985: LD_ADDR_VAR 0 7
96989: PUSH
96990: LD_VAR 0 2
96994: PUSH
96995: FOR_IN
96996: IFFALSE 97057
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
96998: LD_VAR 0 7
97002: PPUSH
97003: CALL_OW 310
97007: PPUSH
97008: CALL_OW 266
97012: PUSH
97013: LD_INT 32
97015: PUSH
97016: LD_INT 31
97018: PUSH
97019: EMPTY
97020: LIST
97021: LIST
97022: IN
97023: IFFALSE 97043
// solds := solds diff i else
97025: LD_ADDR_VAR 0 2
97029: PUSH
97030: LD_VAR 0 2
97034: PUSH
97035: LD_VAR 0 7
97039: DIFF
97040: ST_TO_ADDR
97041: GO 97055
// SetTag ( i , 18 ) ;
97043: LD_VAR 0 7
97047: PPUSH
97048: LD_INT 18
97050: PPUSH
97051: CALL_OW 109
97055: GO 96995
97057: POP
97058: POP
// if not solds then
97059: LD_VAR 0 2
97063: NOT
97064: IFFALSE 97068
// exit ;
97066: GO 97473
// repeat wait ( 0 0$1 ) ;
97068: LD_INT 35
97070: PPUSH
97071: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
97075: LD_ADDR_VAR 0 5
97079: PUSH
97080: LD_VAR 0 6
97084: PPUSH
97085: LD_VAR 0 3
97089: PPUSH
97090: CALL 16039 0 2
97094: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
97095: LD_EXP 59
97099: PUSH
97100: LD_VAR 0 1
97104: ARRAY
97105: NOT
97106: PUSH
97107: LD_EXP 59
97111: PUSH
97112: LD_VAR 0 1
97116: ARRAY
97117: PUSH
97118: EMPTY
97119: EQUAL
97120: OR
97121: IFFALSE 97158
// begin for i in solds do
97123: LD_ADDR_VAR 0 7
97127: PUSH
97128: LD_VAR 0 2
97132: PUSH
97133: FOR_IN
97134: IFFALSE 97147
// ComStop ( i ) ;
97136: LD_VAR 0 7
97140: PPUSH
97141: CALL_OW 141
97145: GO 97133
97147: POP
97148: POP
// solds := [ ] ;
97149: LD_ADDR_VAR 0 2
97153: PUSH
97154: EMPTY
97155: ST_TO_ADDR
// exit ;
97156: GO 97473
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
97158: LD_VAR 0 5
97162: NOT
97163: PUSH
97164: LD_VAR 0 5
97168: PUSH
97169: LD_INT 3
97171: GREATER
97172: OR
97173: PUSH
97174: LD_EXP 81
97178: PUSH
97179: LD_VAR 0 1
97183: ARRAY
97184: OR
97185: IFFALSE 97226
// begin for i in solds do
97187: LD_ADDR_VAR 0 7
97191: PUSH
97192: LD_VAR 0 2
97196: PUSH
97197: FOR_IN
97198: IFFALSE 97222
// if HasTask ( i ) then
97200: LD_VAR 0 7
97204: PPUSH
97205: CALL_OW 314
97209: IFFALSE 97220
// ComStop ( i ) ;
97211: LD_VAR 0 7
97215: PPUSH
97216: CALL_OW 141
97220: GO 97197
97222: POP
97223: POP
// break ;
97224: GO 97461
// end ; for i in solds do
97226: LD_ADDR_VAR 0 7
97230: PUSH
97231: LD_VAR 0 2
97235: PUSH
97236: FOR_IN
97237: IFFALSE 97453
// begin if IsInUnit ( i ) then
97239: LD_VAR 0 7
97243: PPUSH
97244: CALL_OW 310
97248: IFFALSE 97259
// ComExitBuilding ( i ) ;
97250: LD_VAR 0 7
97254: PPUSH
97255: CALL_OW 122
// if GetLives ( i ) > 333 then
97259: LD_VAR 0 7
97263: PPUSH
97264: CALL_OW 256
97268: PUSH
97269: LD_INT 333
97271: GREATER
97272: IFFALSE 97300
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
97274: LD_VAR 0 7
97278: PPUSH
97279: LD_VAR 0 5
97283: PPUSH
97284: LD_VAR 0 7
97288: PPUSH
97289: CALL_OW 74
97293: PPUSH
97294: CALL_OW 115
97298: GO 97451
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
97300: LD_ADDR_VAR 0 8
97304: PUSH
97305: LD_EXP 59
97309: PUSH
97310: LD_VAR 0 1
97314: ARRAY
97315: PPUSH
97316: LD_INT 2
97318: PUSH
97319: LD_INT 30
97321: PUSH
97322: LD_INT 0
97324: PUSH
97325: EMPTY
97326: LIST
97327: LIST
97328: PUSH
97329: LD_INT 30
97331: PUSH
97332: LD_INT 1
97334: PUSH
97335: EMPTY
97336: LIST
97337: LIST
97338: PUSH
97339: LD_INT 30
97341: PUSH
97342: LD_INT 6
97344: PUSH
97345: EMPTY
97346: LIST
97347: LIST
97348: PUSH
97349: EMPTY
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: PPUSH
97355: CALL_OW 72
97359: PPUSH
97360: LD_VAR 0 7
97364: PPUSH
97365: CALL_OW 74
97369: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
97370: LD_VAR 0 7
97374: PPUSH
97375: LD_VAR 0 8
97379: PPUSH
97380: CALL_OW 250
97384: PPUSH
97385: LD_INT 3
97387: PPUSH
97388: LD_INT 5
97390: PPUSH
97391: CALL_OW 272
97395: PPUSH
97396: LD_VAR 0 8
97400: PPUSH
97401: CALL_OW 251
97405: PPUSH
97406: LD_INT 3
97408: PPUSH
97409: LD_INT 5
97411: PPUSH
97412: CALL_OW 273
97416: PPUSH
97417: CALL_OW 111
// SetTag ( i , 0 ) ;
97421: LD_VAR 0 7
97425: PPUSH
97426: LD_INT 0
97428: PPUSH
97429: CALL_OW 109
// solds := solds diff i ;
97433: LD_ADDR_VAR 0 2
97437: PUSH
97438: LD_VAR 0 2
97442: PUSH
97443: LD_VAR 0 7
97447: DIFF
97448: ST_TO_ADDR
// continue ;
97449: GO 97236
// end ; end ;
97451: GO 97236
97453: POP
97454: POP
// until solds ;
97455: LD_VAR 0 2
97459: IFFALSE 97068
// MC_Reset ( base , 18 ) ;
97461: LD_VAR 0 1
97465: PPUSH
97466: LD_INT 18
97468: PPUSH
97469: CALL 54542 0 2
// end ;
97473: LD_VAR 0 4
97477: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
97478: LD_INT 0
97480: PPUSH
97481: PPUSH
97482: PPUSH
97483: PPUSH
97484: PPUSH
97485: PPUSH
97486: PPUSH
97487: PPUSH
97488: PPUSH
97489: PPUSH
97490: PPUSH
97491: PPUSH
97492: PPUSH
97493: PPUSH
97494: PPUSH
97495: PPUSH
97496: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
97497: LD_ADDR_VAR 0 13
97501: PUSH
97502: LD_EXP 59
97506: PUSH
97507: LD_VAR 0 1
97511: ARRAY
97512: PPUSH
97513: LD_INT 25
97515: PUSH
97516: LD_INT 3
97518: PUSH
97519: EMPTY
97520: LIST
97521: LIST
97522: PPUSH
97523: CALL_OW 72
97527: ST_TO_ADDR
// if mc_remote_driver [ base ] then
97528: LD_EXP 99
97532: PUSH
97533: LD_VAR 0 1
97537: ARRAY
97538: IFFALSE 97562
// mechs := mechs diff mc_remote_driver [ base ] ;
97540: LD_ADDR_VAR 0 13
97544: PUSH
97545: LD_VAR 0 13
97549: PUSH
97550: LD_EXP 99
97554: PUSH
97555: LD_VAR 0 1
97559: ARRAY
97560: DIFF
97561: ST_TO_ADDR
// for i in mechs do
97562: LD_ADDR_VAR 0 5
97566: PUSH
97567: LD_VAR 0 13
97571: PUSH
97572: FOR_IN
97573: IFFALSE 97608
// if GetTag ( i ) > 0 then
97575: LD_VAR 0 5
97579: PPUSH
97580: CALL_OW 110
97584: PUSH
97585: LD_INT 0
97587: GREATER
97588: IFFALSE 97606
// mechs := mechs diff i ;
97590: LD_ADDR_VAR 0 13
97594: PUSH
97595: LD_VAR 0 13
97599: PUSH
97600: LD_VAR 0 5
97604: DIFF
97605: ST_TO_ADDR
97606: GO 97572
97608: POP
97609: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
97610: LD_ADDR_VAR 0 9
97614: PUSH
97615: LD_EXP 59
97619: PUSH
97620: LD_VAR 0 1
97624: ARRAY
97625: PPUSH
97626: LD_INT 2
97628: PUSH
97629: LD_INT 25
97631: PUSH
97632: LD_INT 1
97634: PUSH
97635: EMPTY
97636: LIST
97637: LIST
97638: PUSH
97639: LD_INT 25
97641: PUSH
97642: LD_INT 5
97644: PUSH
97645: EMPTY
97646: LIST
97647: LIST
97648: PUSH
97649: LD_INT 25
97651: PUSH
97652: LD_INT 8
97654: PUSH
97655: EMPTY
97656: LIST
97657: LIST
97658: PUSH
97659: LD_INT 25
97661: PUSH
97662: LD_INT 9
97664: PUSH
97665: EMPTY
97666: LIST
97667: LIST
97668: PUSH
97669: EMPTY
97670: LIST
97671: LIST
97672: LIST
97673: LIST
97674: LIST
97675: PPUSH
97676: CALL_OW 72
97680: ST_TO_ADDR
// if not defenders and not solds then
97681: LD_VAR 0 2
97685: NOT
97686: PUSH
97687: LD_VAR 0 9
97691: NOT
97692: AND
97693: IFFALSE 97697
// exit ;
97695: GO 99323
// depot_under_attack := false ;
97697: LD_ADDR_VAR 0 17
97701: PUSH
97702: LD_INT 0
97704: ST_TO_ADDR
// sold_defenders := [ ] ;
97705: LD_ADDR_VAR 0 18
97709: PUSH
97710: EMPTY
97711: ST_TO_ADDR
// if mechs then
97712: LD_VAR 0 13
97716: IFFALSE 97845
// for i in defenders do
97718: LD_ADDR_VAR 0 5
97722: PUSH
97723: LD_VAR 0 2
97727: PUSH
97728: FOR_IN
97729: IFFALSE 97843
// begin SetTag ( i , 20 ) ;
97731: LD_VAR 0 5
97735: PPUSH
97736: LD_INT 20
97738: PPUSH
97739: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
97743: LD_VAR 0 5
97747: PPUSH
97748: CALL_OW 263
97752: PUSH
97753: LD_INT 1
97755: EQUAL
97756: PUSH
97757: LD_VAR 0 5
97761: PPUSH
97762: CALL_OW 311
97766: NOT
97767: AND
97768: PUSH
97769: LD_VAR 0 13
97773: AND
97774: IFFALSE 97841
// begin un := mechs [ 1 ] ;
97776: LD_ADDR_VAR 0 11
97780: PUSH
97781: LD_VAR 0 13
97785: PUSH
97786: LD_INT 1
97788: ARRAY
97789: ST_TO_ADDR
// ComExitBuilding ( un ) ;
97790: LD_VAR 0 11
97794: PPUSH
97795: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
97799: LD_VAR 0 11
97803: PPUSH
97804: LD_VAR 0 5
97808: PPUSH
97809: CALL_OW 180
// SetTag ( un , 19 ) ;
97813: LD_VAR 0 11
97817: PPUSH
97818: LD_INT 19
97820: PPUSH
97821: CALL_OW 109
// mechs := mechs diff un ;
97825: LD_ADDR_VAR 0 13
97829: PUSH
97830: LD_VAR 0 13
97834: PUSH
97835: LD_VAR 0 11
97839: DIFF
97840: ST_TO_ADDR
// end ; end ;
97841: GO 97728
97843: POP
97844: POP
// if solds then
97845: LD_VAR 0 9
97849: IFFALSE 97908
// for i in solds do
97851: LD_ADDR_VAR 0 5
97855: PUSH
97856: LD_VAR 0 9
97860: PUSH
97861: FOR_IN
97862: IFFALSE 97906
// if not GetTag ( i ) then
97864: LD_VAR 0 5
97868: PPUSH
97869: CALL_OW 110
97873: NOT
97874: IFFALSE 97904
// begin defenders := defenders union i ;
97876: LD_ADDR_VAR 0 2
97880: PUSH
97881: LD_VAR 0 2
97885: PUSH
97886: LD_VAR 0 5
97890: UNION
97891: ST_TO_ADDR
// SetTag ( i , 18 ) ;
97892: LD_VAR 0 5
97896: PPUSH
97897: LD_INT 18
97899: PPUSH
97900: CALL_OW 109
// end ;
97904: GO 97861
97906: POP
97907: POP
// repeat wait ( 0 0$1 ) ;
97908: LD_INT 35
97910: PPUSH
97911: CALL_OW 67
// enemy := mc_scan [ base ] ;
97915: LD_ADDR_VAR 0 3
97919: PUSH
97920: LD_EXP 82
97924: PUSH
97925: LD_VAR 0 1
97929: ARRAY
97930: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
97931: LD_EXP 59
97935: PUSH
97936: LD_VAR 0 1
97940: ARRAY
97941: NOT
97942: PUSH
97943: LD_EXP 59
97947: PUSH
97948: LD_VAR 0 1
97952: ARRAY
97953: PUSH
97954: EMPTY
97955: EQUAL
97956: OR
97957: IFFALSE 97994
// begin for i in defenders do
97959: LD_ADDR_VAR 0 5
97963: PUSH
97964: LD_VAR 0 2
97968: PUSH
97969: FOR_IN
97970: IFFALSE 97983
// ComStop ( i ) ;
97972: LD_VAR 0 5
97976: PPUSH
97977: CALL_OW 141
97981: GO 97969
97983: POP
97984: POP
// defenders := [ ] ;
97985: LD_ADDR_VAR 0 2
97989: PUSH
97990: EMPTY
97991: ST_TO_ADDR
// exit ;
97992: GO 99323
// end ; for i in defenders do
97994: LD_ADDR_VAR 0 5
97998: PUSH
97999: LD_VAR 0 2
98003: PUSH
98004: FOR_IN
98005: IFFALSE 98823
// begin e := NearestUnitToUnit ( enemy , i ) ;
98007: LD_ADDR_VAR 0 14
98011: PUSH
98012: LD_VAR 0 3
98016: PPUSH
98017: LD_VAR 0 5
98021: PPUSH
98022: CALL_OW 74
98026: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
98027: LD_ADDR_VAR 0 8
98031: PUSH
98032: LD_EXP 59
98036: PUSH
98037: LD_VAR 0 1
98041: ARRAY
98042: PPUSH
98043: LD_INT 2
98045: PUSH
98046: LD_INT 30
98048: PUSH
98049: LD_INT 0
98051: PUSH
98052: EMPTY
98053: LIST
98054: LIST
98055: PUSH
98056: LD_INT 30
98058: PUSH
98059: LD_INT 1
98061: PUSH
98062: EMPTY
98063: LIST
98064: LIST
98065: PUSH
98066: EMPTY
98067: LIST
98068: LIST
98069: LIST
98070: PPUSH
98071: CALL_OW 72
98075: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
98076: LD_ADDR_VAR 0 17
98080: PUSH
98081: LD_VAR 0 8
98085: NOT
98086: PUSH
98087: LD_VAR 0 8
98091: PPUSH
98092: LD_INT 3
98094: PUSH
98095: LD_INT 24
98097: PUSH
98098: LD_INT 600
98100: PUSH
98101: EMPTY
98102: LIST
98103: LIST
98104: PUSH
98105: EMPTY
98106: LIST
98107: LIST
98108: PPUSH
98109: CALL_OW 72
98113: OR
98114: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
98115: LD_VAR 0 5
98119: PPUSH
98120: CALL_OW 247
98124: PUSH
98125: LD_INT 2
98127: DOUBLE
98128: EQUAL
98129: IFTRUE 98133
98131: GO 98529
98133: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
98134: LD_VAR 0 5
98138: PPUSH
98139: CALL_OW 256
98143: PUSH
98144: LD_INT 650
98146: GREATER
98147: PUSH
98148: LD_VAR 0 5
98152: PPUSH
98153: LD_VAR 0 14
98157: PPUSH
98158: CALL_OW 296
98162: PUSH
98163: LD_INT 40
98165: LESS
98166: PUSH
98167: LD_VAR 0 14
98171: PPUSH
98172: LD_EXP 84
98176: PUSH
98177: LD_VAR 0 1
98181: ARRAY
98182: PPUSH
98183: CALL_OW 308
98187: OR
98188: AND
98189: IFFALSE 98311
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
98191: LD_VAR 0 5
98195: PPUSH
98196: CALL_OW 262
98200: PUSH
98201: LD_INT 1
98203: EQUAL
98204: PUSH
98205: LD_VAR 0 5
98209: PPUSH
98210: CALL_OW 261
98214: PUSH
98215: LD_INT 30
98217: LESS
98218: AND
98219: PUSH
98220: LD_VAR 0 8
98224: AND
98225: IFFALSE 98295
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
98227: LD_VAR 0 5
98231: PPUSH
98232: LD_VAR 0 8
98236: PPUSH
98237: LD_VAR 0 5
98241: PPUSH
98242: CALL_OW 74
98246: PPUSH
98247: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
98251: LD_VAR 0 5
98255: PPUSH
98256: LD_VAR 0 8
98260: PPUSH
98261: LD_VAR 0 5
98265: PPUSH
98266: CALL_OW 74
98270: PPUSH
98271: CALL_OW 296
98275: PUSH
98276: LD_INT 6
98278: LESS
98279: IFFALSE 98293
// SetFuel ( i , 100 ) ;
98281: LD_VAR 0 5
98285: PPUSH
98286: LD_INT 100
98288: PPUSH
98289: CALL_OW 240
// end else
98293: GO 98309
// ComAttackUnit ( i , e ) ;
98295: LD_VAR 0 5
98299: PPUSH
98300: LD_VAR 0 14
98304: PPUSH
98305: CALL_OW 115
// end else
98309: GO 98412
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
98311: LD_VAR 0 14
98315: PPUSH
98316: LD_EXP 84
98320: PUSH
98321: LD_VAR 0 1
98325: ARRAY
98326: PPUSH
98327: CALL_OW 308
98331: NOT
98332: PUSH
98333: LD_VAR 0 5
98337: PPUSH
98338: LD_VAR 0 14
98342: PPUSH
98343: CALL_OW 296
98347: PUSH
98348: LD_INT 40
98350: GREATEREQUAL
98351: AND
98352: PUSH
98353: LD_VAR 0 5
98357: PPUSH
98358: CALL_OW 256
98362: PUSH
98363: LD_INT 650
98365: LESSEQUAL
98366: OR
98367: PUSH
98368: LD_VAR 0 5
98372: PPUSH
98373: LD_EXP 83
98377: PUSH
98378: LD_VAR 0 1
98382: ARRAY
98383: PPUSH
98384: CALL_OW 308
98388: NOT
98389: AND
98390: IFFALSE 98412
// ComMoveToArea ( i , mc_parking [ base ] ) ;
98392: LD_VAR 0 5
98396: PPUSH
98397: LD_EXP 83
98401: PUSH
98402: LD_VAR 0 1
98406: ARRAY
98407: PPUSH
98408: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
98412: LD_VAR 0 5
98416: PPUSH
98417: CALL_OW 256
98421: PUSH
98422: LD_INT 998
98424: LESS
98425: PUSH
98426: LD_VAR 0 5
98430: PPUSH
98431: CALL_OW 263
98435: PUSH
98436: LD_INT 1
98438: EQUAL
98439: AND
98440: PUSH
98441: LD_VAR 0 5
98445: PPUSH
98446: CALL_OW 311
98450: AND
98451: PUSH
98452: LD_VAR 0 5
98456: PPUSH
98457: LD_EXP 83
98461: PUSH
98462: LD_VAR 0 1
98466: ARRAY
98467: PPUSH
98468: CALL_OW 308
98472: AND
98473: IFFALSE 98527
// begin mech := IsDrivenBy ( i ) ;
98475: LD_ADDR_VAR 0 10
98479: PUSH
98480: LD_VAR 0 5
98484: PPUSH
98485: CALL_OW 311
98489: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
98490: LD_VAR 0 10
98494: PPUSH
98495: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
98499: LD_VAR 0 10
98503: PPUSH
98504: LD_VAR 0 5
98508: PPUSH
98509: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
98513: LD_VAR 0 10
98517: PPUSH
98518: LD_VAR 0 5
98522: PPUSH
98523: CALL_OW 180
// end ; end ; unit_human :
98527: GO 98794
98529: LD_INT 1
98531: DOUBLE
98532: EQUAL
98533: IFTRUE 98537
98535: GO 98793
98537: POP
// begin b := IsInUnit ( i ) ;
98538: LD_ADDR_VAR 0 19
98542: PUSH
98543: LD_VAR 0 5
98547: PPUSH
98548: CALL_OW 310
98552: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
98553: LD_ADDR_VAR 0 20
98557: PUSH
98558: LD_VAR 0 19
98562: NOT
98563: PUSH
98564: LD_VAR 0 19
98568: PPUSH
98569: CALL_OW 266
98573: PUSH
98574: LD_INT 32
98576: PUSH
98577: LD_INT 31
98579: PUSH
98580: EMPTY
98581: LIST
98582: LIST
98583: IN
98584: OR
98585: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
98586: LD_VAR 0 17
98590: PUSH
98591: LD_VAR 0 2
98595: PPUSH
98596: LD_INT 21
98598: PUSH
98599: LD_INT 2
98601: PUSH
98602: EMPTY
98603: LIST
98604: LIST
98605: PPUSH
98606: CALL_OW 72
98610: PUSH
98611: LD_INT 1
98613: LESSEQUAL
98614: OR
98615: PUSH
98616: LD_VAR 0 20
98620: AND
98621: PUSH
98622: LD_VAR 0 5
98626: PUSH
98627: LD_VAR 0 18
98631: IN
98632: NOT
98633: AND
98634: IFFALSE 98727
// begin if b then
98636: LD_VAR 0 19
98640: IFFALSE 98689
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
98642: LD_VAR 0 19
98646: PPUSH
98647: LD_VAR 0 3
98651: PPUSH
98652: LD_VAR 0 19
98656: PPUSH
98657: CALL_OW 74
98661: PPUSH
98662: CALL_OW 296
98666: PUSH
98667: LD_INT 10
98669: LESS
98670: PUSH
98671: LD_VAR 0 19
98675: PPUSH
98676: CALL_OW 461
98680: PUSH
98681: LD_INT 7
98683: NONEQUAL
98684: AND
98685: IFFALSE 98689
// continue ;
98687: GO 98004
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
98689: LD_ADDR_VAR 0 18
98693: PUSH
98694: LD_VAR 0 18
98698: PPUSH
98699: LD_VAR 0 18
98703: PUSH
98704: LD_INT 1
98706: PLUS
98707: PPUSH
98708: LD_VAR 0 5
98712: PPUSH
98713: CALL_OW 1
98717: ST_TO_ADDR
// ComExitBuilding ( i ) ;
98718: LD_VAR 0 5
98722: PPUSH
98723: CALL_OW 122
// end ; if sold_defenders then
98727: LD_VAR 0 18
98731: IFFALSE 98791
// if i in sold_defenders then
98733: LD_VAR 0 5
98737: PUSH
98738: LD_VAR 0 18
98742: IN
98743: IFFALSE 98791
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
98745: LD_VAR 0 5
98749: PPUSH
98750: CALL_OW 314
98754: NOT
98755: PUSH
98756: LD_VAR 0 5
98760: PPUSH
98761: LD_VAR 0 14
98765: PPUSH
98766: CALL_OW 296
98770: PUSH
98771: LD_INT 30
98773: LESS
98774: AND
98775: IFFALSE 98791
// ComAttackUnit ( i , e ) ;
98777: LD_VAR 0 5
98781: PPUSH
98782: LD_VAR 0 14
98786: PPUSH
98787: CALL_OW 115
// end ; end ; end ;
98791: GO 98794
98793: POP
// if IsDead ( i ) then
98794: LD_VAR 0 5
98798: PPUSH
98799: CALL_OW 301
98803: IFFALSE 98821
// defenders := defenders diff i ;
98805: LD_ADDR_VAR 0 2
98809: PUSH
98810: LD_VAR 0 2
98814: PUSH
98815: LD_VAR 0 5
98819: DIFF
98820: ST_TO_ADDR
// end ;
98821: GO 98004
98823: POP
98824: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
98825: LD_VAR 0 3
98829: NOT
98830: PUSH
98831: LD_VAR 0 2
98835: NOT
98836: OR
98837: PUSH
98838: LD_EXP 59
98842: PUSH
98843: LD_VAR 0 1
98847: ARRAY
98848: NOT
98849: OR
98850: IFFALSE 97908
// MC_Reset ( base , 18 ) ;
98852: LD_VAR 0 1
98856: PPUSH
98857: LD_INT 18
98859: PPUSH
98860: CALL 54542 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
98864: LD_ADDR_VAR 0 2
98868: PUSH
98869: LD_VAR 0 2
98873: PUSH
98874: LD_VAR 0 2
98878: PPUSH
98879: LD_INT 2
98881: PUSH
98882: LD_INT 25
98884: PUSH
98885: LD_INT 1
98887: PUSH
98888: EMPTY
98889: LIST
98890: LIST
98891: PUSH
98892: LD_INT 25
98894: PUSH
98895: LD_INT 5
98897: PUSH
98898: EMPTY
98899: LIST
98900: LIST
98901: PUSH
98902: LD_INT 25
98904: PUSH
98905: LD_INT 8
98907: PUSH
98908: EMPTY
98909: LIST
98910: LIST
98911: PUSH
98912: LD_INT 25
98914: PUSH
98915: LD_INT 9
98917: PUSH
98918: EMPTY
98919: LIST
98920: LIST
98921: PUSH
98922: EMPTY
98923: LIST
98924: LIST
98925: LIST
98926: LIST
98927: LIST
98928: PPUSH
98929: CALL_OW 72
98933: DIFF
98934: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
98935: LD_VAR 0 3
98939: NOT
98940: PUSH
98941: LD_VAR 0 2
98945: PPUSH
98946: LD_INT 21
98948: PUSH
98949: LD_INT 2
98951: PUSH
98952: EMPTY
98953: LIST
98954: LIST
98955: PPUSH
98956: CALL_OW 72
98960: AND
98961: IFFALSE 99299
// begin tmp := FilterByTag ( defenders , 19 ) ;
98963: LD_ADDR_VAR 0 12
98967: PUSH
98968: LD_VAR 0 2
98972: PPUSH
98973: LD_INT 19
98975: PPUSH
98976: CALL 47799 0 2
98980: ST_TO_ADDR
// if tmp then
98981: LD_VAR 0 12
98985: IFFALSE 99055
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
98987: LD_ADDR_VAR 0 12
98991: PUSH
98992: LD_VAR 0 12
98996: PPUSH
98997: LD_INT 25
98999: PUSH
99000: LD_INT 3
99002: PUSH
99003: EMPTY
99004: LIST
99005: LIST
99006: PPUSH
99007: CALL_OW 72
99011: ST_TO_ADDR
// if tmp then
99012: LD_VAR 0 12
99016: IFFALSE 99055
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
99018: LD_ADDR_EXP 71
99022: PUSH
99023: LD_EXP 71
99027: PPUSH
99028: LD_VAR 0 1
99032: PPUSH
99033: LD_EXP 71
99037: PUSH
99038: LD_VAR 0 1
99042: ARRAY
99043: PUSH
99044: LD_VAR 0 12
99048: UNION
99049: PPUSH
99050: CALL_OW 1
99054: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
99055: LD_VAR 0 1
99059: PPUSH
99060: LD_INT 19
99062: PPUSH
99063: CALL 54542 0 2
// repeat wait ( 0 0$1 ) ;
99067: LD_INT 35
99069: PPUSH
99070: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
99074: LD_EXP 59
99078: PUSH
99079: LD_VAR 0 1
99083: ARRAY
99084: NOT
99085: PUSH
99086: LD_EXP 59
99090: PUSH
99091: LD_VAR 0 1
99095: ARRAY
99096: PUSH
99097: EMPTY
99098: EQUAL
99099: OR
99100: IFFALSE 99137
// begin for i in defenders do
99102: LD_ADDR_VAR 0 5
99106: PUSH
99107: LD_VAR 0 2
99111: PUSH
99112: FOR_IN
99113: IFFALSE 99126
// ComStop ( i ) ;
99115: LD_VAR 0 5
99119: PPUSH
99120: CALL_OW 141
99124: GO 99112
99126: POP
99127: POP
// defenders := [ ] ;
99128: LD_ADDR_VAR 0 2
99132: PUSH
99133: EMPTY
99134: ST_TO_ADDR
// exit ;
99135: GO 99323
// end ; for i in defenders do
99137: LD_ADDR_VAR 0 5
99141: PUSH
99142: LD_VAR 0 2
99146: PUSH
99147: FOR_IN
99148: IFFALSE 99237
// begin if not IsInArea ( i , mc_parking [ base ] ) then
99150: LD_VAR 0 5
99154: PPUSH
99155: LD_EXP 83
99159: PUSH
99160: LD_VAR 0 1
99164: ARRAY
99165: PPUSH
99166: CALL_OW 308
99170: NOT
99171: IFFALSE 99195
// ComMoveToArea ( i , mc_parking [ base ] ) else
99173: LD_VAR 0 5
99177: PPUSH
99178: LD_EXP 83
99182: PUSH
99183: LD_VAR 0 1
99187: ARRAY
99188: PPUSH
99189: CALL_OW 113
99193: GO 99235
// if GetControl ( i ) = control_manual then
99195: LD_VAR 0 5
99199: PPUSH
99200: CALL_OW 263
99204: PUSH
99205: LD_INT 1
99207: EQUAL
99208: IFFALSE 99235
// if IsDrivenBy ( i ) then
99210: LD_VAR 0 5
99214: PPUSH
99215: CALL_OW 311
99219: IFFALSE 99235
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
99221: LD_VAR 0 5
99225: PPUSH
99226: CALL_OW 311
99230: PPUSH
99231: CALL_OW 121
// end ;
99235: GO 99147
99237: POP
99238: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
99239: LD_VAR 0 2
99243: PPUSH
99244: LD_INT 95
99246: PUSH
99247: LD_EXP 83
99251: PUSH
99252: LD_VAR 0 1
99256: ARRAY
99257: PUSH
99258: EMPTY
99259: LIST
99260: LIST
99261: PPUSH
99262: CALL_OW 72
99266: PUSH
99267: LD_VAR 0 2
99271: EQUAL
99272: PUSH
99273: LD_EXP 82
99277: PUSH
99278: LD_VAR 0 1
99282: ARRAY
99283: OR
99284: PUSH
99285: LD_EXP 59
99289: PUSH
99290: LD_VAR 0 1
99294: ARRAY
99295: NOT
99296: OR
99297: IFFALSE 99067
// end ; MC_Reset ( base , 19 ) ;
99299: LD_VAR 0 1
99303: PPUSH
99304: LD_INT 19
99306: PPUSH
99307: CALL 54542 0 2
// MC_Reset ( base , 20 ) ;
99311: LD_VAR 0 1
99315: PPUSH
99316: LD_INT 20
99318: PPUSH
99319: CALL 54542 0 2
// end ;
99323: LD_VAR 0 4
99327: RET
